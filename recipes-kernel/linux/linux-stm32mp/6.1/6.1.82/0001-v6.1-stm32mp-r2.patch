From 054ceddae5e573fdf4fa13021662469a3f54a056 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Fri, 12 Apr 2024 15:55:05 +0200
Subject: [PATCH] v6.1-stm32mp-r2

---
 CODE_OF_CONDUCT.md                            |   73 +
 CONTRIBUTING.md                               |   30 +
 Documentation/admin-guide/perf/index.rst      |    1 +
 .../admin-guide/perf/stm32-ddr-pmu.rst        |   44 +
 .../arm/stm32/stm32mp257-overview.rst         |   19 +
 .../bindings/arm/stm32/st,mlahb.yaml          |    2 +-
 .../bindings/arm/stm32/st,stm32-syscon.yaml   |   52 +-
 .../devicetree/bindings/arm/stm32/stm32.yaml  |   40 +-
 .../devicetree/bindings/bus/st,sys-bus.yaml   |  108 +
 .../bindings/clock/st,stm32mp1-rcc.yaml       |   23 +-
 .../bindings/clock/st,stm32mp25-rcc.yaml      |  107 +
 .../bindings/cpufreq/stm32-cpufreq.txt        |   61 +
 .../bindings/crypto/st,stm32-crc.yaml         |    8 +
 .../bindings/crypto/st,stm32-cryp.yaml        |    8 +
 .../bindings/crypto/st,stm32-hash.yaml        |   29 +-
 .../display/connector/hdmi-connector.yaml     |    3 +
 .../bindings/display/panel/panel-simple.yaml  |    2 +
 .../display/panel/rocktech,hx8394.yaml        |   56 +
 .../bindings/display/st,stm32-dsi.yaml        |   48 +-
 .../bindings/display/st,stm32-ltdc.yaml       |   12 +-
 .../bindings/display/st,stm32-lvds.yaml       |  109 +
 .../dma/{ => stm32}/st,stm32-dma.yaml         |   11 +-
 .../bindings/dma/stm32/st,stm32-dma3.yaml     |  160 +
 .../dma/{ => stm32}/st,stm32-dmamux.yaml      |   11 +-
 .../dma/{ => stm32}/st,stm32-mdma.yaml        |    6 +-
 .../feature-domain-controller.yaml            |   85 +
 .../devicetree/bindings/gpu/vivante,gc.yaml   |    5 +
 .../devicetree/bindings/hwlock/hwlock.txt     |   27 +-
 .../bindings/hwlock/st,stm32-hwspinlock.yaml  |    4 +-
 .../devicetree/bindings/i2c/i2c-rpmsg.yaml    |   46 +
 .../devicetree/bindings/i2c/st,stm32-i2c.yaml |   41 +-
 .../bindings/i3c/st,stm32-i3c-master.yaml     |   53 +
 .../iio/adc/sigma-delta-modulator.yaml        |    3 +
 .../bindings/iio/adc/st,stm32-adc.yaml        |  141 +-
 .../bindings/iio/adc/st,stm32-dfsdm-adc.yaml  |   20 +-
 .../bindings/iio/adc/st,stm32-mdf-adc.yaml    |  354 ++
 .../bindings/iio/dac/st,stm32-dac.yaml        |    5 +
 .../interrupt-controller/rpmsg,intc.yaml      |   39 +
 .../interrupt-controller/st,stm32-exti.yaml   |   28 +-
 .../leds/backlight/gpio-backlight.yaml        |    9 +
 .../bindings/mailbox/st,stm32-ipcc.yaml       |   17 +-
 .../bindings/media/i2c/galaxycore,gc2145.yaml |  115 +
 .../bindings/media/st,stm32-cec.yaml          |    5 +
 .../bindings/media/st,stm32-csi2host.yaml     |  122 +
 .../bindings/media/st,stm32-dcmi.yaml         |   23 +-
 .../bindings/media/st,stm32-dcmipp.yaml       |  135 +
 .../bindings/media/st,stm32mp25-vdec.yaml     |   71 +
 .../bindings/media/st,stm32mp25-venc.yaml     |   71 +
 .../memory-controllers/st,stm32-fmc2-ebi.yaml |   12 +-
 .../memory-controllers/st,stm32-omi.yaml      |  244 +
 .../bindings/mfd/st,stm32-lptimer.yaml        |   28 +-
 .../bindings/mfd/st,stm32-timers.yaml         |   21 +-
 .../bindings/mfd/st,stm32mp1-pwr.txt          |   57 +
 .../devicetree/bindings/mfd/st,stpmic1.yaml   |   10 +-
 .../bindings/misc/st,stm32-omm.yaml           |  184 +
 .../devicetree/bindings/mmc/arm,pl18x.yaml    |   11 +
 .../bindings/mtd/st,stm32-fmc2-nand.yaml      |   25 +-
 .../bindings/net/can/bosch,m_can.yaml         |    5 +
 .../devicetree/bindings/net/snps,dwmac.yaml   |    5 +
 .../devicetree/bindings/net/stm32-dwmac.yaml  |   14 +
 .../devicetree/bindings/net/stm32-ttt.yaml    |   90 +
 .../bindings/nvmem/st,stm32-romem.yaml        |   10 +
 .../bindings/nvmem/st,stm32-tamp-nvram.yaml   |   69 +
 .../bindings/pci/st,stm32-pcie-ep.yaml        |  101 +
 .../bindings/pci/st,stm32-pcie-host.yaml      |  163 +
 .../bindings/perf/stm32-ddr-pmu.yaml          |   44 +
 .../bindings/phy/phy-stm32-usbphyc.yaml       |    9 +
 .../bindings/phy/st,stm32-combophy.yaml       |  174 +
 .../bindings/phy/st,stm32-usb2phy.yaml        |  190 +
 .../pinctrl/st,stm32-pinctrl-hdp.yaml         |   91 +
 .../bindings/pinctrl/st,stm32-pinctrl.yaml    |   60 +-
 .../regulator/protection-consumer.txt         |   23 +
 .../bindings/regulator/st,stm32-vrefbuf.yaml  |    5 +
 .../bindings/remoteproc/rproc-srm.txt         |   58 +
 .../bindings/remoteproc/st,stm32-rproc.yaml   |  106 +-
 .../devicetree/bindings/rng/st,stm32-rng.yaml |   50 +-
 .../devicetree/bindings/rtc/st,stm32-rtc.yaml |   42 +-
 .../devicetree/bindings/serial/rs485.yaml     |   14 +
 .../bindings/serial/st,stm32-uart.yaml        |    9 +
 .../bindings/soc/st/st,stm32mp25-risaf.yaml   |   65 +
 .../bindings/sound/st,stm32-i2s.yaml          |   64 +-
 .../bindings/sound/st,stm32-sai.yaml          |   40 +-
 .../bindings/sound/st,stm32-spdifrx.yaml      |    5 +
 .../bindings/spi/st,stm32-qspi.yaml           |    5 +
 .../devicetree/bindings/spi/st,stm32-spi.yaml |   34 +-
 .../devicetree/bindings/usb/dwc2.yaml         |   14 +-
 .../devicetree/bindings/usb/generic-ehci.yaml |    5 +
 .../devicetree/bindings/usb/generic-ohci.yaml |    5 +
 .../bindings/usb/st,typec-stm32g0.yaml        |    6 +-
 .../devicetree/bindings/usb/stm32,dwc3.yaml   |  108 +
 .../devicetree/bindings/usb/stm32,usbh.yaml   |  113 +
 .../devicetree/bindings/vendor-prefixes.yaml  |    6 +
 Documentation/i2c/busses/index.rst            |    1 +
 Documentation/i2c/busses/rpmsg_i2c.rst        |   51 +
 Documentation/locking/hwspinlock.rst          |   10 +-
 Documentation/staging/remoteproc.rst          |   22 +
 MAINTAINERS                                   |   47 +
 Makefile                                      |   31 +-
 SECURITY.md                                   |    8 +
 arch/arm/boot/dts/Makefile                    |   31 +-
 arch/arm/boot/dts/stm32h743.dtsi              |    2 -
 arch/arm/boot/dts/stm32mp13-pinctrl.dtsi      |  444 ++
 arch/arm/boot/dts/stm32mp131.dtsi             | 1762 +++++-
 arch/arm/boot/dts/stm32mp133.dtsi             |   67 +
 arch/arm/boot/dts/stm32mp135.dtsi             |   24 +
 .../boot/dts/stm32mp135f-dk-a7-examples.dts   |  127 +
 arch/arm/boot/dts/stm32mp135f-dk.dts          |  580 +-
 arch/arm/boot/dts/stm32mp13xa.dtsi            |    5 +
 arch/arm/boot/dts/stm32mp13xc.dtsi            |   20 +-
 arch/arm/boot/dts/stm32mp13xd.dtsi            |    5 +
 arch/arm/boot/dts/stm32mp13xf.dtsi            |   20 +-
 .../boot/dts/stm32mp15-m4-srm-pinctrl.dtsi    |  524 ++
 arch/arm/boot/dts/stm32mp15-m4-srm.dtsi       |  447 ++
 arch/arm/boot/dts/stm32mp15-pinctrl.dtsi      |  304 +-
 arch/arm/boot/dts/stm32mp15-scmi.dtsi         |   68 -
 arch/arm/boot/dts/stm32mp151.dtsi             | 3360 ++++++-----
 arch/arm/boot/dts/stm32mp153.dtsi             |   53 +-
 arch/arm/boot/dts/stm32mp157.dtsi             |   10 +-
 .../boot/dts/stm32mp157a-dk1-a7-examples.dts  |   26 +
 .../boot/dts/stm32mp157a-dk1-m4-examples.dts  |  128 +
 ...dk1-scmi.dts => stm32mp157a-dk1-scmi.dtsi} |   20 +-
 arch/arm/boot/dts/stm32mp157a-dk1.dts         |    5 +-
 arch/arm/boot/dts/stm32mp157a-ed1-scmi.dtsi   |   94 +
 arch/arm/boot/dts/stm32mp157a-ed1.dts         |  433 ++
 .../boot/dts/stm32mp157a-ev1-a7-examples.dts  |   35 +
 .../boot/dts/stm32mp157a-ev1-m4-examples.dts  |   14 +
 arch/arm/boot/dts/stm32mp157a-ev1-scmi.dtsi   |   91 +
 arch/arm/boot/dts/stm32mp157a-ev1.dts         |  798 +++
 ...tm32mp157a-icore-stm32mp1-ctouch2-of10.dts |    7 +-
 .../stm32mp157a-icore-stm32mp1-edimm2.2.dts   |    7 +-
 ...157a-microgea-stm32mp1-microdev2.0-of7.dts |    3 +-
 .../boot/dts/stm32mp157c-dk2-a7-examples.dts  |   95 +
 .../boot/dts/stm32mp157c-dk2-m4-examples.dts  |  128 +
 ...dk2-scmi.dts => stm32mp157c-dk2-scmi.dtsi} |   25 +-
 arch/arm/boot/dts/stm32mp157c-dk2.dts         |   74 +-
 ...ed1-scmi.dts => stm32mp157c-ed1-scmi.dtsi} |   29 +-
 arch/arm/boot/dts/stm32mp157c-ed1.dts         |   89 +-
 .../boot/dts/stm32mp157c-ev1-a7-examples.dts  |   55 +
 .../boot/dts/stm32mp157c-ev1-m4-examples.dts  |  150 +
 ...ev1-scmi.dts => stm32mp157c-ev1-scmi.dtsi} |   27 +-
 arch/arm/boot/dts/stm32mp157c-ev1.dts         |  423 +-
 arch/arm/boot/dts/stm32mp157c-lxa-mc1.dts     |    3 +-
 .../boot/dts/stm32mp157d-dk1-a7-examples.dts  |   26 +
 .../boot/dts/stm32mp157d-dk1-m4-examples.dts  |  128 +
 arch/arm/boot/dts/stm32mp157d-dk1.dts         |   27 +
 arch/arm/boot/dts/stm32mp157d-ed1.dts         |  441 ++
 .../boot/dts/stm32mp157d-ev1-a7-examples.dts  |   35 +
 .../boot/dts/stm32mp157d-ev1-m4-examples.dts  |   14 +
 arch/arm/boot/dts/stm32mp157d-ev1.dts         |  798 +++
 .../boot/dts/stm32mp157f-dk2-a7-examples.dts  |   95 +
 .../boot/dts/stm32mp157f-dk2-m4-examples.dts  |  128 +
 arch/arm/boot/dts/stm32mp157f-dk2.dts         |  169 +
 arch/arm/boot/dts/stm32mp157f-ed1.dts         |  445 ++
 .../boot/dts/stm32mp157f-ev1-a7-examples.dts  |   55 +
 .../boot/dts/stm32mp157f-ev1-m4-examples.dts  |  151 +
 arch/arm/boot/dts/stm32mp157f-ev1.dts         |  811 +++
 arch/arm/boot/dts/stm32mp15xa.dtsi            |    5 +
 arch/arm/boot/dts/stm32mp15xc.dtsi            |   22 +-
 arch/arm/boot/dts/stm32mp15xd.dtsi            |   28 +
 arch/arm/boot/dts/stm32mp15xf.dtsi            |   26 +
 .../boot/dts/stm32mp15xx-dhcor-avenger96.dtsi |    6 +-
 arch/arm/boot/dts/stm32mp15xx-dkx.dtsi        |  146 +-
 .../fragment-01-multiv7_cleanup.config        |  263 +
 .../configs/fragment-02-multiv7_addons.config |  101 +
 arch/arm/configs/multi_v7_defconfig           |    1 +
 arch/arm/mach-stm32/Kconfig                   |    2 +-
 arch/arm/mach-stm32/board-dt.c                |    2 +
 arch/arm64/Kconfig.platforms                  |   15 +
 arch/arm64/boot/dts/Makefile                  |    1 +
 arch/arm64/boot/dts/st/Makefile               |    4 +
 arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi |  971 ++++
 arch/arm64/boot/dts/st/stm32mp251.dtsi        | 3178 +++++++++++
 arch/arm64/boot/dts/st/stm32mp253.dtsi        |  183 +
 arch/arm64/boot/dts/st/stm32mp255.dtsi        |   80 +
 arch/arm64/boot/dts/st/stm32mp257.dtsi        |   54 +
 .../st/stm32mp257f-dk-ca35tdcid-resmem.dtsi   |  167 +
 arch/arm64/boot/dts/st/stm32mp257f-dk.dts     |  754 +++
 .../st/stm32mp257f-ev1-ca35tdcid-resmem.dtsi  |  171 +
 arch/arm64/boot/dts/st/stm32mp257f-ev1.dts    |  825 +++
 arch/arm64/boot/dts/st/stm32mp25xc.dtsi       |   36 +
 arch/arm64/boot/dts/st/stm32mp25xf.dtsi       |   36 +
 .../boot/dts/st/stm32mp25xxai-pinctrl.dtsi    |   83 +
 .../boot/dts/st/stm32mp25xxak-pinctrl.dtsi    |   71 +
 .../boot/dts/st/stm32mp25xxal-pinctrl.dtsi    |   71 +
 .../fragment-01-defconfig-cleanup.config      |   50 +
 .../fragment-02-defconfig-addons.config       |  130 +
 crypto/ahash.c                                |    1 -
 crypto/algif_hash.c                           |   19 +-
 crypto/shash.c                                |    3 +-
 drivers/base/power/common.c                   |  134 +
 drivers/bus/Kconfig                           |    9 +
 drivers/bus/Makefile                          |    1 +
 drivers/bus/stm32_sys_bus.c                   |  701 +++
 drivers/bus/stm32_sys_bus.h                   |   13 +
 drivers/char/hw_random/stm32-rng.c            |  570 +-
 drivers/clk/Kconfig                           |   10 +
 drivers/clk/Makefile                          |    1 +
 drivers/clk/clk-composite.c                   |   16 +
 drivers/clk/clk-regmap.c                      |  186 +
 drivers/clk/clk-scmi.c                        |   37 +
 drivers/clk/clk-stm32mp1.c                    | 1657 +++++-
 drivers/clk/clk.c                             |    7 +-
 drivers/clk/stm32/Makefile                    |    2 +
 drivers/clk/stm32/clk-stm32-core.c            |  217 +-
 drivers/clk/stm32/clk-stm32-core.h            |   38 +
 drivers/clk/stm32/clk-stm32mp13.c             |  713 ++-
 drivers/clk/stm32/clk-stm32mp25-syscfg.c      |  142 +
 drivers/clk/stm32/clk-stm32mp25.c             | 2037 +++++++
 drivers/clk/stm32/reset-stm32.c               |   39 +
 drivers/clk/stm32/stm32mp25_rcc.h             | 4977 +++++++++++++++++
 drivers/clocksource/timer-stm32-lp.c          |    5 +-
 drivers/counter/stm32-lptimer-cnt.c           |    1 +
 drivers/counter/stm32-timer-cnt.c             |  467 +-
 drivers/cpufreq/Kconfig.arm                   |    7 +
 drivers/cpufreq/Makefile                      |    1 +
 drivers/cpufreq/cpufreq-dt-platdev.c          |    1 +
 drivers/cpufreq/stm32-cpufreq.c               |   99 +
 drivers/cpuidle/Kconfig.arm                   |    8 +
 drivers/cpuidle/Makefile                      |    1 +
 drivers/cpuidle/cpuidle-stm32.c               |  277 +
 drivers/crypto/stm32/Kconfig                  |    2 +
 drivers/crypto/stm32/stm32-cryp.c             |  755 ++-
 drivers/crypto/stm32/stm32-hash.c             | 1673 ++++--
 drivers/dma/Kconfig                           |   34 +-
 drivers/dma/Makefile                          |    4 +-
 drivers/dma/dmaengine.c                       |   16 +-
 drivers/dma/dmatest.c                         |   17 +-
 drivers/dma/idxd/dma.c                        |    2 +-
 drivers/dma/stm32/Kconfig                     |   47 +
 drivers/dma/stm32/Makefile                    |    5 +
 drivers/dma/{ => stm32}/stm32-dma.c           |    2 +-
 drivers/dma/stm32/stm32-dma3.c                | 2141 +++++++
 drivers/dma/{ => stm32}/stm32-dmamux.c        |    0
 drivers/dma/{ => stm32}/stm32-mdma.c          |    2 +-
 drivers/firmware/arm_scmi/clock.c             |   78 +
 drivers/firmware/arm_scmi/optee.c             |  445 +-
 drivers/gpu/drm/bridge/adv7511/adv7511.h      |    3 +
 .../gpu/drm/bridge/adv7511/adv7511_audio.c    |    4 +
 drivers/gpu/drm/bridge/adv7511/adv7511_drv.c  |   13 +
 drivers/gpu/drm/bridge/adv7511/adv7533.c      |   27 +-
 drivers/gpu/drm/bridge/display-connector.c    |   36 +
 drivers/gpu/drm/bridge/sii902x.c              |  106 +-
 drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c |  177 +-
 drivers/gpu/drm/drm_atomic_uapi.c             |    4 +
 drivers/gpu/drm/drm_connector.c               |   62 +
 drivers/gpu/drm/panel/Kconfig                 |    9 +
 drivers/gpu/drm/panel/Makefile                |    1 +
 drivers/gpu/drm/panel/panel-lvds.c            |    2 +-
 .../gpu/drm/panel/panel-orisetech-otm8009a.c  |  102 +-
 drivers/gpu/drm/panel/panel-raydium-rm68200.c |  130 +-
 drivers/gpu/drm/panel/panel-rocktech-hx8394.c |  433 ++
 drivers/gpu/drm/panel/panel-simple.c          |   36 +-
 drivers/gpu/drm/stm/Kconfig                   |    6 +
 drivers/gpu/drm/stm/Makefile                  |    2 +
 drivers/gpu/drm/stm/drv.c                     |   92 +-
 drivers/gpu/drm/stm/dw_mipi_dsi-stm.c         |  971 +++-
 drivers/gpu/drm/stm/ltdc.c                    | 1376 +++--
 drivers/gpu/drm/stm/ltdc.h                    |   24 +-
 drivers/gpu/drm/stm/lvds.c                    | 1360 +++++
 drivers/hwmon/mr75203.c                       |   38 +
 drivers/hwspinlock/Kconfig                    |    2 +-
 drivers/hwspinlock/hwspinlock_core.c          |   80 +-
 drivers/hwspinlock/hwspinlock_internal.h      |    2 +
 drivers/i2c/busses/Kconfig                    |    9 +
 drivers/i2c/busses/Makefile                   |    1 +
 drivers/i2c/busses/i2c-rpmsg.c                |  422 ++
 drivers/i2c/busses/i2c-stm32f7.c              |  454 +-
 drivers/i3c/master/Kconfig                    |    7 +
 drivers/i3c/master/Makefile                   |    1 +
 drivers/i3c/master/stm32-i3c-master.c         | 1884 +++++++
 drivers/iio/adc/Kconfig                       |   25 +
 drivers/iio/adc/Makefile                      |    3 +
 drivers/iio/adc/sd_adc_modulator.c            |   89 +-
 drivers/iio/adc/stm32-adc-core.c              |  241 +-
 drivers/iio/adc/stm32-adc-core.h              |   72 +
 drivers/iio/adc/stm32-adc.c                   |  788 ++-
 drivers/iio/adc/stm32-dfsdm-adc.c             |  107 +-
 drivers/iio/adc/stm32-dfsdm-core.c            |   91 +-
 drivers/iio/adc/stm32-dfsdm.h                 |   69 +-
 drivers/iio/adc/stm32-mdf-adc.c               | 1764 ++++++
 drivers/iio/adc/stm32-mdf-core.c              |  761 +++
 drivers/iio/adc/stm32-mdf-serial.c            |  310 +
 drivers/iio/adc/stm32-mdf.h                   |  314 ++
 drivers/iio/trigger/stm32-lptimer-trigger.c   |  105 +-
 drivers/iio/trigger/stm32-timer-trigger.c     |   30 +-
 drivers/input/touchscreen/edt-ft5x06.c        |   33 +-
 drivers/input/touchscreen/goodix.c            |   97 +-
 drivers/irqchip/Kconfig                       |   16 +
 drivers/irqchip/Makefile                      |    2 +
 drivers/irqchip/irq-rpmsg.c                   |  321 ++
 drivers/irqchip/irq-stm32-exti.c              |  617 +-
 drivers/irqchip/irq-stm32mp-exti.c            |  970 ++++
 drivers/mailbox/Kconfig                       |    2 +-
 drivers/mailbox/stm32-ipcc.c                  |  164 +-
 drivers/media/i2c/Kconfig                     |   13 +
 drivers/media/i2c/Makefile                    |    1 +
 drivers/media/i2c/gc2145.c                    | 1989 +++++++
 drivers/media/i2c/imx335.c                    |  116 +-
 drivers/media/i2c/ov5640.c                    | 1962 +++----
 drivers/media/platform/st/stm32/Kconfig       |   27 +
 drivers/media/platform/st/stm32/Makefile      |    2 +
 .../media/platform/st/stm32/stm32-csi2host.c  | 1220 ++++
 drivers/media/platform/st/stm32/stm32-dcmi.c  |  516 +-
 .../platform/st/stm32/stm32-dcmipp/Makefile   |    6 +
 .../st/stm32/stm32-dcmipp/dcmipp-bytecap.c    | 1068 ++++
 .../st/stm32/stm32-dcmipp/dcmipp-byteproc.c   |  760 +++
 .../st/stm32/stm32-dcmipp/dcmipp-colorconv.c  |  361 ++
 .../st/stm32/stm32-dcmipp/dcmipp-colorconv.h  |   27 +
 .../st/stm32/stm32-dcmipp/dcmipp-common.c     |  113 +
 .../st/stm32/stm32-dcmipp/dcmipp-common.h     |  257 +
 .../st/stm32/stm32-dcmipp/dcmipp-core.c       |  693 +++
 .../st/stm32/stm32-dcmipp/dcmipp-input.c      |  613 ++
 .../st/stm32/stm32-dcmipp/dcmipp-isp-params.c |  657 +++
 .../st/stm32/stm32-dcmipp/dcmipp-isp.c        |  729 +++
 .../st/stm32/stm32-dcmipp/dcmipp-pixelcap.c   | 1187 ++++
 .../st/stm32/stm32-dcmipp/dcmipp-pixelproc.c  | 1006 ++++
 .../st/stm32/stm32-dcmipp/dcmipp-statcap.c    | 1006 ++++
 drivers/media/platform/verisilicon/Kconfig    |   14 +-
 drivers/media/platform/verisilicon/Makefile   |    9 +
 drivers/media/platform/verisilicon/hantro.h   |   25 +
 .../platform/verisilicon/hantro_boolenc.c     |   69 +
 .../platform/verisilicon/hantro_boolenc.h     |   21 +
 .../media/platform/verisilicon/hantro_drv.c   |   87 +-
 .../media/platform/verisilicon/hantro_g1.c    |   17 +
 .../platform/verisilicon/hantro_g1_h264_dec.c |    9 +-
 .../verisilicon/hantro_g1_mpeg2_dec.c         |    5 +-
 .../platform/verisilicon/hantro_g1_regs.h     |    2 +
 .../platform/verisilicon/hantro_g1_vp8_dec.c  |   11 +-
 .../media/platform/verisilicon/hantro_h1.c    |  382 ++
 .../platform/verisilicon/hantro_h1_h264_enc.c |  443 ++
 .../platform/verisilicon/hantro_h1_jpeg_enc.c |   75 +-
 .../platform/verisilicon/hantro_h1_regs.h     |  105 +-
 .../platform/verisilicon/hantro_h1_vp8_enc.c  | 1609 ++++++
 .../media/platform/verisilicon/hantro_h264.c  |  779 +++
 .../media/platform/verisilicon/hantro_hw.h    |  123 +
 .../media/platform/verisilicon/hantro_v4l2.c  |    5 +-
 .../media/platform/verisilicon/hantro_vp8.c   |  118 +
 .../verisilicon/rockchip_vpu2_hw_vp8_enc.c    | 1574 ++++++
 .../platform/verisilicon/rockchip_vpu2_regs.h |    1 +
 .../platform/verisilicon/rockchip_vpu_hw.c    |   23 +-
 .../platform/verisilicon/stm32mp25_vdec_hw.c  |   92 +
 .../platform/verisilicon/stm32mp25_venc_hw.c  |  294 +
 drivers/media/v4l2-core/v4l2-ctrls-core.c     |   76 +
 drivers/media/v4l2-core/v4l2-ctrls-defs.c     |   22 +
 drivers/media/v4l2-core/v4l2-fwnode.c         |    3 +
 drivers/media/v4l2-core/v4l2-ioctl.c          |    2 +
 drivers/memory/Kconfig                        |   10 +-
 drivers/memory/Makefile                       |    1 +
 drivers/memory/stm32-fmc2-ebi.c               |  729 ++-
 drivers/memory/stm32-omi.c                    |  664 +++
 drivers/mfd/Kconfig                           |   10 +
 drivers/mfd/Makefile                          |    1 +
 drivers/mfd/stm32-lptimer.c                   |   38 +-
 drivers/mfd/stm32-pwr.c                       |  414 ++
 drivers/mfd/stm32-timers.c                    |   77 +-
 drivers/mfd/stmfx.c                           |   47 +-
 drivers/mfd/stpmic1.c                         |   11 +-
 drivers/mfd/wm8994-core.c                     |    6 +
 drivers/misc/Kconfig                          |   17 +
 drivers/misc/Makefile                         |    1 +
 drivers/misc/stm32_omm.c                      |  519 ++
 drivers/mmc/host/mmci.c                       |  104 +-
 drivers/mmc/host/mmci.h                       |   10 +-
 drivers/mmc/host/mmci_stm32_sdmmc.c           |  176 +-
 drivers/mtd/chips/cfi_cmdset_0002.c           |   25 +
 drivers/mtd/hyperbus/Kconfig                  |    6 +
 drivers/mtd/hyperbus/Makefile                 |    5 +-
 drivers/mtd/hyperbus/hyperbus-core.c          |   14 +-
 drivers/mtd/hyperbus/hyperbus-sfdp.c          |  314 ++
 drivers/mtd/hyperbus/hyperbus-stm32.c         |  428 ++
 drivers/mtd/nand/raw/Kconfig                  |    2 +-
 drivers/mtd/nand/raw/stm32_fmc2_nand.c        |   83 +-
 drivers/mtd/spi-nor/core.c                    |   40 +-
 drivers/mtd/spi-nor/core.h                    |    7 +
 drivers/mtd/spi-nor/macronix.c                |  154 +
 drivers/mtd/spi-nor/sfdp.c                    |   11 +
 drivers/mtd/spi-nor/sfdp.h                    |    1 +
 .../net/ethernet/stmicro/stmmac/dwmac-stm32.c |  335 +-
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.c  |   11 +
 .../net/ethernet/stmicro/stmmac/dwmac4_dma.h  |    5 +
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |    1 -
 .../ethernet/stmicro/stmmac/stmmac_ethtool.c  |   10 +-
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |   34 +-
 .../ethernet/stmicro/stmmac/stmmac_platform.c |    6 +
 .../net/ethernet/stmicro/stmmac/stmmac_ptp.h  |    2 +
 drivers/net/phy/phy_device.c                  |    4 +-
 drivers/net/phy/phylink.c                     |   31 +-
 drivers/net/phy/realtek.c                     |   15 +
 drivers/net/phy/smsc.c                        |   90 +-
 .../broadcom/brcm80211/brcmfmac/bcmsdh.c      |    6 +-
 drivers/nvmem/Kconfig                         |   20 +
 drivers/nvmem/Makefile                        |    3 +
 drivers/nvmem/stm32-bsec-optee-ta.c           |  298 +
 drivers/nvmem/stm32-bsec-optee-ta.h           |   80 +
 drivers/nvmem/stm32-romem.c                   |  128 +-
 drivers/nvmem/stm32-tamp-nvram.c              |  669 +++
 drivers/pci/controller/dwc/Kconfig            |   23 +
 drivers/pci/controller/dwc/Makefile           |    2 +
 .../pci/controller/dwc/pcie-designware-ep.c   |    1 +
 drivers/pci/controller/dwc/pcie-stm32-ep.c    |  431 ++
 drivers/pci/controller/dwc/pcie-stm32.c       |  590 ++
 drivers/pci/controller/dwc/pcie-stm32.h       |   24 +
 drivers/pci/endpoint/functions/pci-epf-test.c |    4 +-
 drivers/pci/pcie/aer.c                        |    1 +
 drivers/pci/pcie/portdrv_core.c               |   96 +-
 drivers/perf/Kconfig                          |    7 +
 drivers/perf/Makefile                         |    1 +
 drivers/perf/stm32_ddr_pmu.c                  |  439 ++
 drivers/phy/st/Kconfig                        |   19 +
 drivers/phy/st/Makefile                       |    2 +
 drivers/phy/st/phy-stm32-combophy.c           |  594 ++
 drivers/phy/st/phy-stm32-usb2phy.c            |  785 +++
 drivers/phy/st/phy-stm32-usbphyc.c            |   20 +
 drivers/pinctrl/devicetree.c                  |   10 +-
 drivers/pinctrl/pinctrl-stmfx.c               |   36 +-
 drivers/pinctrl/stm32/Kconfig                 |   22 +-
 drivers/pinctrl/stm32/Makefile                |    2 +
 drivers/pinctrl/stm32/pinctrl-stm32-hdp.c     |  310 +
 drivers/pinctrl/stm32/pinctrl-stm32.c         |  689 ++-
 drivers/pinctrl/stm32/pinctrl-stm32.h         |    9 +-
 drivers/pinctrl/stm32/pinctrl-stm32f429.c     |    1 +
 drivers/pinctrl/stm32/pinctrl-stm32f469.c     |    1 +
 drivers/pinctrl/stm32/pinctrl-stm32f746.c     |    1 +
 drivers/pinctrl/stm32/pinctrl-stm32f769.c     |    1 +
 drivers/pinctrl/stm32/pinctrl-stm32h743.c     |    1 +
 drivers/pinctrl/stm32/pinctrl-stm32mp257.c    | 2588 +++++++++
 drivers/ptp/ptp_chardev.c                     |   23 +
 drivers/ptp/ptp_clock.c                       |   20 +
 drivers/ptp/ptp_private.h                     |    3 +
 drivers/pwm/pwm-stm32-lp.c                    |  221 +-
 drivers/pwm/pwm-stm32.c                       |   38 +-
 drivers/regulator/Kconfig                     |   11 +
 drivers/regulator/Makefile                    |    1 +
 drivers/regulator/protection-consumer.c       |  137 +
 drivers/regulator/stm32-pwr.c                 |   85 +-
 drivers/regulator/stpmic1_regulator.c         |  224 +-
 drivers/remoteproc/Kconfig                    |   31 +-
 drivers/remoteproc/Makefile                   |    3 +
 drivers/remoteproc/remoteproc_core.c          |    8 +
 drivers/remoteproc/remoteproc_sysfs.c         |   22 +
 drivers/remoteproc/rproc_srm_core.c           |  292 +
 drivers/remoteproc/rproc_srm_core.h           |   98 +
 drivers/remoteproc/rproc_srm_dev.c            |  736 +++
 drivers/remoteproc/stm32_rproc.c              |  767 ++-
 drivers/remoteproc/tee_remoteproc.c           |  403 ++
 drivers/rpmsg/virtio_rpmsg_bus.c              |   13 +-
 drivers/rtc/Kconfig                           |    1 +
 drivers/rtc/rtc-stm32.c                       |  457 +-
 drivers/soc/Kconfig                           |    1 +
 drivers/soc/Makefile                          |    1 +
 drivers/soc/st/Kconfig                        |   19 +
 drivers/soc/st/Makefile                       |    2 +
 drivers/soc/st/stm32_pm_domain.c              |  212 +
 drivers/soc/st/stm32_risaf.c                  |  257 +
 drivers/spi/Kconfig                           |   12 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-mem.c                         |    4 +
 drivers/spi/spi-stm32-ospi.c                  | 1210 ++++
 drivers/spi/spi-stm32.c                       |  649 ++-
 drivers/spi/spi.c                             |   49 +
 drivers/tee/optee/call.c                      |  130 +-
 drivers/tee/optee/core.c                      |    4 +-
 drivers/tee/optee/ffa_abi.c                   |    3 +-
 drivers/tee/optee/optee_private.h             |  101 +-
 drivers/tee/optee/optee_smc.h                 |   39 +
 drivers/tee/optee/smc_abi.c                   |  525 +-
 drivers/tee/tee_core.c                        |   19 +
 drivers/thermal/st/stm_thermal.c              |   30 +-
 drivers/tty/n_tty.c                           |   92 +-
 drivers/tty/serial/Kconfig                    |    2 +-
 drivers/tty/serial/serial_core.c              |   14 +-
 drivers/tty/serial/stm32-usart.c              |  938 +++-
 drivers/tty/serial/stm32-usart.h              |   69 +-
 drivers/tty/tty_buffer.c                      |   63 +-
 drivers/tty/tty_port.c                        |   21 -
 drivers/usb/core/hcd.c                        |    9 +-
 drivers/usb/core/phy.c                        |   22 +-
 drivers/usb/core/phy.h                        |    6 +-
 drivers/usb/dwc2/core.h                       |    2 +
 drivers/usb/dwc2/core_intr.c                  |    3 +-
 drivers/usb/dwc2/drd.c                        |   19 +-
 drivers/usb/dwc2/gadget.c                     |    1 -
 drivers/usb/dwc2/hcd.c                        |   49 +-
 drivers/usb/dwc2/platform.c                   |   56 +-
 drivers/usb/dwc3/Kconfig                      |   11 +
 drivers/usb/dwc3/Makefile                     |    1 +
 drivers/usb/dwc3/core.c                       |   64 +-
 drivers/usb/dwc3/core.h                       |    9 +-
 drivers/usb/dwc3/drd.c                        |   10 +-
 drivers/usb/dwc3/dwc3-stm32.c                 |  266 +
 drivers/usb/dwc3/gadget.c                     |    1 +
 drivers/usb/dwc3/host.c                       |   35 +
 drivers/usb/gadget/function/f_ncm.c           |    9 +-
 drivers/usb/gadget/function/u_ether.c         |   19 +-
 drivers/usb/gadget/function/u_ether.h         |    1 +
 drivers/usb/host/Kconfig                      |   13 +
 drivers/usb/host/Makefile                     |    1 +
 drivers/usb/host/ehci-platform.c              |   16 +-
 drivers/usb/host/ohci-platform.c              |   14 +-
 drivers/usb/host/usbh-stm32.c                 |  183 +
 drivers/usb/host/xhci-plat.c                  |   18 +-
 drivers/usb/host/xhci-plat.h                  |    2 +
 drivers/usb/misc/onboard_usb_hub.c            |    9 +-
 drivers/usb/typec/ucsi/ucsi.c                 |    6 +-
 drivers/usb/typec/ucsi/ucsi_stm32g0.c         |   70 +-
 drivers/video/backlight/gpio_backlight.c      |    7 +-
 drivers/watchdog/arm_smc_wdt.c                |   18 +-
 drivers/watchdog/stm32_iwdg.c                 |   52 +-
 include/crypto/hash.h                         |    2 -
 include/drm/drm_connector.h                   |   14 +
 include/dt-bindings/bus/stm32mp13_sys_bus.h   |   60 +
 include/dt-bindings/bus/stm32mp15_sys_bus.h   |   98 +
 include/dt-bindings/bus/stm32mp25_sys_bus.h   |  127 +
 include/dt-bindings/clock/stm32mp1-clks.h     |    6 +
 include/dt-bindings/clock/stm32mp13-clks.h    |    8 +-
 include/dt-bindings/clock/stm32mp25-clks.h    |  496 ++
 include/dt-bindings/pinctrl/stm32-pinfunc.h   |    4 +
 include/dt-bindings/pinctrl/stm32mp13-hdp.h   |  130 +
 include/dt-bindings/pinctrl/stm32mp15-hdp.h   |  116 +
 include/dt-bindings/pinctrl/stm32mp25-hdp.h   |  144 +
 .../power/stm32mp25-power-domains.h           |   11 +
 .../regulator/st,stm32mp13-regulator.h        |   42 +
 .../regulator/st,stm32mp25-regulator.h        |   48 +
 include/dt-bindings/reset/stm32mp25-resets.h  |  166 +
 include/dt-bindings/rtc/rtc-stm32.h           |   14 +
 include/dt-bindings/spi/spi-stm32.h           |   15 +
 include/linux/clk-regmap.h                    |  117 +
 include/linux/counter.h                       |    3 +
 include/linux/dmaengine.h                     |    3 +-
 include/linux/iio/adc/stm32-mdf-adc.h         |   18 +
 include/linux/iio/timer/stm32-lptim-trigger.h |    9 +
 include/linux/iio/timer/stm32-timer-trigger.h |    6 +
 include/linux/mfd/stm32-lptimer.h             |   32 +-
 include/linux/mfd/stm32-timers.h              |   35 +
 include/linux/mmc/sdio_ids.h                  |    5 +-
 include/linux/msi.h                           |    6 +
 include/linux/mtd/cfi.h                       |    1 +
 include/linux/mtd/sfdp.h                      |   12 +
 include/linux/pci-epc.h                       |    2 +
 include/linux/phylink.h                       |    1 +
 include/linux/pm_domain.h                     |   38 +
 include/linux/ptp_clock_kernel.h              |    5 +
 include/linux/remoteproc.h                    |   13 +
 include/linux/scmi_protocol.h                 |    4 +
 include/linux/smscphy.h                       |   20 +
 include/linux/spi/spi-mem.h                   |    6 +
 include/linux/spi/spi.h                       |    4 +
 include/linux/stmmac.h                        |    3 +
 include/linux/tee_drv.h                       |   88 +
 include/linux/tee_remoteproc.h                |   99 +
 include/linux/timekeeping.h                   |    5 +
 include/linux/tty_buffer.h                    |    1 -
 include/linux/tty_ldisc.h                     |   14 -
 include/linux/tty_port.h                      |    2 -
 include/media/media-entity.h                  |    6 +
 include/media/v4l2-ctrls.h                    |    1 +
 include/media/v4l2-mediabus.h                 |    2 +
 include/memory/stm32-omi.h                    |  202 +
 include/sound/hdmi-codec.h                    |    5 +
 include/uapi/linux/counter.h                  |    2 +-
 include/uapi/linux/ethtool.h                  |   10 +-
 include/uapi/linux/ptp_clock.h                |   12 +-
 include/uapi/linux/serial.h                   |    6 +-
 include/uapi/linux/stm32-dcmipp-config.h      |  194 +
 include/uapi/linux/v4l2-controls.h            |  217 +
 include/uapi/linux/videodev2.h                |   12 +-
 kernel/power/suspend.c                        |    1 -
 net/ethtool/common.c                          |    4 +
 scripts/Makefile.lib                          |   18 +-
 scripts/checkpatch.pl                         |   12 +-
 sound/soc/codecs/Kconfig                      |    2 +-
 sound/soc/codecs/hdmi-codec.c                 |   45 +-
 sound/soc/codecs/wm8994.c                     |   81 +-
 sound/soc/stm/Kconfig                         |   13 +
 sound/soc/stm/Makefile                        |    3 +
 sound/soc/stm/stm32_amdf.c                    |  386 ++
 sound/soc/stm/stm32_i2s.c                     |  215 +-
 sound/soc/stm/stm32_sai.c                     |   61 +-
 sound/soc/stm/stm32_sai.h                     |    6 +
 sound/soc/stm/stm32_sai_sub.c                 |  144 +-
 sound/soc/stm/stm32_spdifrx.c                 |    2 +-
 tools/counter/Build                           |    1 +
 tools/counter/Makefile                        |   12 +-
 tools/counter/counter_watch_events.c          |  406 ++
 584 files changed, 97131 insertions(+), 7683 deletions(-)
 create mode 100644 CODE_OF_CONDUCT.md
 create mode 100644 CONTRIBUTING.md
 create mode 100644 Documentation/admin-guide/perf/stm32-ddr-pmu.rst
 create mode 100644 Documentation/arm/stm32/stm32mp257-overview.rst
 create mode 100644 Documentation/devicetree/bindings/bus/st,sys-bus.yaml
 create mode 100644 Documentation/devicetree/bindings/clock/st,stm32mp25-rcc.yaml
 create mode 100644 Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt
 create mode 100644 Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml
 create mode 100644 Documentation/devicetree/bindings/display/st,stm32-lvds.yaml
 rename Documentation/devicetree/bindings/dma/{ => stm32}/st,stm32-dma.yaml (91%)
 create mode 100644 Documentation/devicetree/bindings/dma/stm32/st,stm32-dma3.yaml
 rename Documentation/devicetree/bindings/dma/{ => stm32}/st,stm32-dmamux.yaml (73%)
 rename Documentation/devicetree/bindings/dma/{ => stm32}/st,stm32-mdma.yaml (95%)
 create mode 100644 Documentation/devicetree/bindings/feature-controllers/feature-domain-controller.yaml
 create mode 100644 Documentation/devicetree/bindings/i2c/i2c-rpmsg.yaml
 create mode 100644 Documentation/devicetree/bindings/i3c/st,stm32-i3c-master.yaml
 create mode 100644 Documentation/devicetree/bindings/iio/adc/st,stm32-mdf-adc.yaml
 create mode 100644 Documentation/devicetree/bindings/interrupt-controller/rpmsg,intc.yaml
 create mode 100644 Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml
 create mode 100644 Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml
 create mode 100644 Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml
 create mode 100644 Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt
 create mode 100644 Documentation/devicetree/bindings/misc/st,stm32-omm.yaml
 create mode 100644 Documentation/devicetree/bindings/net/stm32-ttt.yaml
 create mode 100644 Documentation/devicetree/bindings/nvmem/st,stm32-tamp-nvram.yaml
 create mode 100644 Documentation/devicetree/bindings/pci/st,stm32-pcie-ep.yaml
 create mode 100644 Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml
 create mode 100644 Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml
 create mode 100644 Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml
 create mode 100644 Documentation/devicetree/bindings/phy/st,stm32-usb2phy.yaml
 create mode 100644 Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl-hdp.yaml
 create mode 100644 Documentation/devicetree/bindings/regulator/protection-consumer.txt
 create mode 100644 Documentation/devicetree/bindings/remoteproc/rproc-srm.txt
 create mode 100644 Documentation/devicetree/bindings/soc/st/st,stm32mp25-risaf.yaml
 create mode 100644 Documentation/devicetree/bindings/usb/stm32,dwc3.yaml
 create mode 100644 Documentation/devicetree/bindings/usb/stm32,usbh.yaml
 create mode 100644 Documentation/i2c/busses/rpmsg_i2c.rst
 create mode 100644 SECURITY.md
 create mode 100644 arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp13xa.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp13xd.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15-m4-srm.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts
 rename arch/arm/boot/dts/{stm32mp157a-dk1-scmi.dts => stm32mp157a-dk1-scmi.dtsi} (79%)
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ed1-scmi.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ed1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ev1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ev1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ev1-scmi.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp157a-ev1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts
 rename arch/arm/boot/dts/{stm32mp157c-dk2-scmi.dts => stm32mp157c-dk2-scmi.dtsi} (78%)
 rename arch/arm/boot/dts/{stm32mp157c-ed1-scmi.dts => stm32mp157c-ed1-scmi.dtsi} (74%)
 create mode 100644 arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts
 rename arch/arm/boot/dts/{stm32mp157c-ev1-scmi.dts => stm32mp157c-ev1-scmi.dtsi} (78%)
 create mode 100644 arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-dk1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-ed1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-ev1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-ev1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157d-ev1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-dk2.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ed1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts
 create mode 100644 arch/arm/boot/dts/stm32mp157f-ev1.dts
 create mode 100644 arch/arm/boot/dts/stm32mp15xa.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15xd.dtsi
 create mode 100644 arch/arm/boot/dts/stm32mp15xf.dtsi
 create mode 100644 arch/arm/configs/fragment-01-multiv7_cleanup.config
 create mode 100644 arch/arm/configs/fragment-02-multiv7_addons.config
 create mode 100644 arch/arm64/boot/dts/st/Makefile
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp251.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp253.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp255.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-dk-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-dk.dts
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp257f-ev1.dts
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xc.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xf.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi
 create mode 100644 arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi
 create mode 100644 arch/arm64/configs/fragment-01-defconfig-cleanup.config
 create mode 100644 arch/arm64/configs/fragment-02-defconfig-addons.config
 create mode 100644 drivers/bus/stm32_sys_bus.c
 create mode 100644 drivers/bus/stm32_sys_bus.h
 create mode 100644 drivers/clk/clk-regmap.c
 create mode 100644 drivers/clk/stm32/clk-stm32mp25-syscfg.c
 create mode 100644 drivers/clk/stm32/clk-stm32mp25.c
 create mode 100644 drivers/clk/stm32/stm32mp25_rcc.h
 create mode 100644 drivers/cpufreq/stm32-cpufreq.c
 create mode 100644 drivers/cpuidle/cpuidle-stm32.c
 create mode 100644 drivers/dma/stm32/Kconfig
 create mode 100644 drivers/dma/stm32/Makefile
 rename drivers/dma/{ => stm32}/stm32-dma.c (99%)
 create mode 100644 drivers/dma/stm32/stm32-dma3.c
 rename drivers/dma/{ => stm32}/stm32-dmamux.c (100%)
 rename drivers/dma/{ => stm32}/stm32-mdma.c (99%)
 create mode 100644 drivers/gpu/drm/panel/panel-rocktech-hx8394.c
 create mode 100644 drivers/gpu/drm/stm/lvds.c
 create mode 100644 drivers/i2c/busses/i2c-rpmsg.c
 create mode 100644 drivers/i3c/master/stm32-i3c-master.c
 create mode 100644 drivers/iio/adc/stm32-mdf-adc.c
 create mode 100644 drivers/iio/adc/stm32-mdf-core.c
 create mode 100644 drivers/iio/adc/stm32-mdf-serial.c
 create mode 100644 drivers/iio/adc/stm32-mdf.h
 create mode 100644 drivers/irqchip/irq-rpmsg.c
 create mode 100644 drivers/irqchip/irq-stm32mp-exti.c
 create mode 100644 drivers/media/i2c/gc2145.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-csi2host.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/Makefile
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-bytecap.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-byteproc.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.h
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.h
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-input.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp-params.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelcap.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelproc.c
 create mode 100644 drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-statcap.c
 create mode 100644 drivers/media/platform/verisilicon/hantro_boolenc.c
 create mode 100644 drivers/media/platform/verisilicon/hantro_boolenc.h
 create mode 100644 drivers/media/platform/verisilicon/hantro_h1.c
 create mode 100644 drivers/media/platform/verisilicon/hantro_h1_h264_enc.c
 create mode 100644 drivers/media/platform/verisilicon/hantro_h1_vp8_enc.c
 create mode 100644 drivers/media/platform/verisilicon/rockchip_vpu2_hw_vp8_enc.c
 create mode 100644 drivers/media/platform/verisilicon/stm32mp25_vdec_hw.c
 create mode 100644 drivers/media/platform/verisilicon/stm32mp25_venc_hw.c
 create mode 100644 drivers/memory/stm32-omi.c
 create mode 100644 drivers/mfd/stm32-pwr.c
 create mode 100644 drivers/misc/stm32_omm.c
 create mode 100644 drivers/mtd/hyperbus/hyperbus-sfdp.c
 create mode 100644 drivers/mtd/hyperbus/hyperbus-stm32.c
 create mode 100644 drivers/nvmem/stm32-bsec-optee-ta.c
 create mode 100644 drivers/nvmem/stm32-bsec-optee-ta.h
 create mode 100644 drivers/nvmem/stm32-tamp-nvram.c
 create mode 100644 drivers/pci/controller/dwc/pcie-stm32-ep.c
 create mode 100644 drivers/pci/controller/dwc/pcie-stm32.c
 create mode 100644 drivers/pci/controller/dwc/pcie-stm32.h
 create mode 100644 drivers/perf/stm32_ddr_pmu.c
 create mode 100644 drivers/phy/st/phy-stm32-combophy.c
 create mode 100644 drivers/phy/st/phy-stm32-usb2phy.c
 create mode 100644 drivers/pinctrl/stm32/pinctrl-stm32-hdp.c
 create mode 100644 drivers/pinctrl/stm32/pinctrl-stm32mp257.c
 create mode 100644 drivers/regulator/protection-consumer.c
 create mode 100644 drivers/remoteproc/rproc_srm_core.c
 create mode 100644 drivers/remoteproc/rproc_srm_core.h
 create mode 100644 drivers/remoteproc/rproc_srm_dev.c
 create mode 100644 drivers/remoteproc/tee_remoteproc.c
 create mode 100644 drivers/soc/st/Kconfig
 create mode 100644 drivers/soc/st/Makefile
 create mode 100644 drivers/soc/st/stm32_pm_domain.c
 create mode 100644 drivers/soc/st/stm32_risaf.c
 create mode 100644 drivers/spi/spi-stm32-ospi.c
 create mode 100644 drivers/usb/dwc3/dwc3-stm32.c
 create mode 100644 drivers/usb/host/usbh-stm32.c
 create mode 100644 include/dt-bindings/bus/stm32mp13_sys_bus.h
 create mode 100644 include/dt-bindings/bus/stm32mp15_sys_bus.h
 create mode 100644 include/dt-bindings/bus/stm32mp25_sys_bus.h
 create mode 100644 include/dt-bindings/clock/stm32mp25-clks.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp13-hdp.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp15-hdp.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp25-hdp.h
 create mode 100644 include/dt-bindings/power/stm32mp25-power-domains.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp13-regulator.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp25-regulator.h
 create mode 100644 include/dt-bindings/reset/stm32mp25-resets.h
 create mode 100644 include/dt-bindings/rtc/rtc-stm32.h
 create mode 100644 include/dt-bindings/spi/spi-stm32.h
 create mode 100644 include/linux/clk-regmap.h
 create mode 100644 include/linux/iio/adc/stm32-mdf-adc.h
 create mode 100644 include/linux/mtd/sfdp.h
 create mode 100644 include/linux/tee_remoteproc.h
 create mode 100644 include/memory/stm32-omi.h
 create mode 100644 include/uapi/linux/stm32-dcmipp-config.h
 create mode 100644 sound/soc/stm/stm32_amdf.c
 create mode 100644 tools/counter/counter_watch_events.c

diff --git a/CODE_OF_CONDUCT.md b/CODE_OF_CONDUCT.md
new file mode 100644
index 000000000..bf0ca35d9
--- /dev/null
+++ b/CODE_OF_CONDUCT.md
@@ -0,0 +1,73 @@
+# Contributor Covenant Code of Conduct
+
+## Our Pledge
+
+In the interest of fostering an open and welcoming environment, we as
+contributors and maintainers pledge to making participation in our project and
+our community a harassment-free experience for everyone, regardless of age, body
+size, disability, ethnicity, sex characteristics, gender identity and expression,
+level of experience, education, socio-economic status, nationality, personal
+appearance, race, religion, or sexual identity and orientation.
+
+## Our Standards
+
+Examples of behavior that contributes to creating a positive environment
+include:
+
+* Using welcoming and inclusive language
+* Being respectful of differing viewpoints and experiences
+* Gracefully accepting constructive criticism
+* Focusing on what is best for the community
+* Showing empathy towards other community members
+
+Examples of unacceptable behavior by participants include:
+
+* The use of sexualized language or imagery and unwelcome sexual attention or
+ advances
+* Trolling, insulting/derogatory comments, and personal or political attacks
+* Public or private harassment
+* Publishing others' private information, such as a physical or electronic
+ address, without explicit permission
+* Other conduct which could reasonably be considered inappropriate in a
+ professional setting
+
+## Our Responsibilities
+
+Project maintainers are responsible for clarifying the standards of acceptable
+behavior and are expected to take appropriate and fair corrective action in
+response to any instances of unacceptable behavior.
+
+Project maintainers have the right and responsibility to remove, edit, or
+reject comments, commits, code, wiki edits, issues, and other contributions
+that are not aligned to this Code of Conduct, or to ban temporarily or
+permanently any contributor for other behaviors that they deem inappropriate,
+threatening, offensive, or harmful.
+
+## Scope
+
+This Code of Conduct applies both within project spaces and in public spaces
+when an individual is representing the project or its community. Examples of
+representing a project or community include using an official project e-mail
+address, posting via an official social media account, or acting as an appointed
+representative at an online or offline event. Representation of a project may be
+further defined and clarified by project maintainers.
+
+## Enforcement
+
+Instances of abusive, harassing, or otherwise unacceptable behavior may be
+reported by contacting the project team via this [link](https://www.st.com/content/st_com/en/contact-us.html).
+All complaints will be reviewed and investigated and will result in a response that
+is deemed necessary and appropriate to the circumstances. The project team is
+obligated to maintain confidentiality with regard to the reporter of an incident.
+Further details of specific enforcement policies may be posted separately.
+
+Project maintainers who do not follow or enforce the Code of Conduct in good
+faith may face temporary or permanent repercussions as determined by other
+members of the project's leadership.
+
+## Attribution
+
+This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4,
+available [here](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html).
+
+For answers to common questions about this code of conduct, refer to the FAQ section [here](https://www.contributor-covenant.org/faq).
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000..3d1bacd78
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/Documentation/admin-guide/perf/index.rst b/Documentation/admin-guide/perf/index.rst
index 793e1970b..b3394ebbc 100644
--- a/Documentation/admin-guide/perf/index.rst
+++ b/Documentation/admin-guide/perf/index.rst
@@ -13,6 +13,7 @@ Performance monitor support
    imx-ddr
    qcom_l2_pmu
    qcom_l3_pmu
+   stm32-ddr-pmu
    arm-ccn
    arm-cmn
    xgene-pmu
diff --git a/Documentation/admin-guide/perf/stm32-ddr-pmu.rst b/Documentation/admin-guide/perf/stm32-ddr-pmu.rst
new file mode 100644
index 000000000..db647fc1a
--- /dev/null
+++ b/Documentation/admin-guide/perf/stm32-ddr-pmu.rst
@@ -0,0 +1,44 @@
+========================================
+STM32 DDR Performance Monitor (DDRPERFM)
+========================================
+
+The DDRPERFM is the DDR Performance Monitor embedded in STM32MP1 SOC.
+See Documentation/arm/stm32/stm32mp157-overview.rst to get access to
+STM32MP157 reference manual RM0436 where DDRPERFM is described.
+
+
+The five following counters are supported by stm32-ddr-pmu driver:
+	cnt0: read operations counters		(read_cnt)
+	cnt1: write operations counters		(write_cnt)
+	cnt2: active state counters		(activate_cnt)
+	cnt3: idle state counters		(idle_cnt)
+	tcnt: time count, present for all sets	(time_cnt)
+
+The stm32-ddr-pmu driver relies on the perf PMU framework to expose the
+counters via sysfs:
+
+    .. code-block:: bash
+
+	$ ls /sys/bus/event_source/devices/ddrperfm/events
+	activate_cnt  idle_cnt  read_cnt  time_cnt  write_cnt
+
+
+The perf PMU framework is usually invoked via the 'perf stat' tool.
+
+The DDRPERFM is a system monitor that cannot isolate the traffic coming from a
+given thread or CPU, that is why stm32-ddr-pmu driver rejects any 'perf stat'
+call that does not request a system-wide collection: the '-a, --all-cpus'
+option is mandatory!
+
+Example:
+
+    .. code-block:: bash
+
+        $ perf stat -e ddrperfm/read_cnt/,ddrperfm/time_cnt/ -a sleep 20
+	Performance counter stats for 'system wide':
+
+	         342541560      ddrperfm/read_cnt/
+	       10660011400      ddrperfm/time_cnt/
+
+	      20.021068551 seconds time elapsed
+
diff --git a/Documentation/arm/stm32/stm32mp257-overview.rst b/Documentation/arm/stm32/stm32mp257-overview.rst
new file mode 100644
index 000000000..7e20b0d78
--- /dev/null
+++ b/Documentation/arm/stm32/stm32mp257-overview.rst
@@ -0,0 +1,19 @@
+STM32MP257 Overview
+===================
+
+Introduction
+------------
+
+The STM32MP257 is a Cortex-A MPU aimed at various applications.
+It features:
+
+- Dual core Cortex-A35 application core
+- 2D/3D image composition with GPU
+- Standard memories interface support
+- Standard connectivity, widely inherited from the STM32 MCU family
+- Comprehensive security support
+- RIF isolation mechanism
+
+:Authors:
+
+- Alexandre Torgue <alexandre.torgue@st.com>
diff --git a/Documentation/devicetree/bindings/arm/stm32/st,mlahb.yaml b/Documentation/devicetree/bindings/arm/stm32/st,mlahb.yaml
index ecb28e90f..f16652ffc 100644
--- a/Documentation/devicetree/bindings/arm/stm32/st,mlahb.yaml
+++ b/Documentation/devicetree/bindings/arm/stm32/st,mlahb.yaml
@@ -48,7 +48,7 @@ required:
   - compatible
   - '#address-cells'
   - '#size-cells'
-  - dma-ranges
+
 
 unevaluatedProperties: false
 
diff --git a/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml b/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml
index 6f846d69c..154f74264 100644
--- a/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml
+++ b/Documentation/devicetree/bindings/arm/stm32/st,stm32-syscon.yaml
@@ -4,7 +4,7 @@
 $id: "http://devicetree.org/schemas/arm/stm32/st,stm32-syscon.yaml#"
 $schema: "http://devicetree.org/meta-schemas/core.yaml#"
 
-title: STMicroelectronics STM32 Platforms System Controller bindings
+title: STMicroelectronics STM32 Platforms System Controller
 
 maintainers:
   - Alexandre Torgue <alexandre.torgue@foss.st.com>
@@ -16,10 +16,13 @@ properties:
       - items:
           - enum:
               - st,stm32mp157-syscfg
+              - st,stm32mp25-syscfg
               - st,stm32mp151-pwr-mcu
               - st,stm32-syscfg
               - st,stm32-power-config
               - st,stm32-tamp
+              - st,stm32mp25-tamp
+              - st,stm32mp25-a35ss-syscfg
           - const: syscon
       - items:
           - const: st,stm32-tamp
@@ -32,19 +35,48 @@ properties:
   clocks:
     maxItems: 1
 
+  '#address-cells':
+    const: 1
+
+  '#size-cells':
+    const: 1
+
+  ranges: true
+
+  reboot-mode:
+    type: object
+    $ref: /schemas/power/reset/reboot-mode.yaml#
+
+patternProperties:
+  "^nvram@[0-9a-f]+$":
+    type: object
+    $ref: /schemas/nvmem/st,stm32-tamp-nvram.yaml#
+
 required:
   - compatible
   - reg
 
-if:
-  properties:
-    compatible:
-      contains:
-        enum:
-          - st,stm32mp157-syscfg
-then:
-  required:
-    - clocks
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32mp157-syscfg
+    then:
+      required:
+        - clocks
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32-tamp
+    then:
+      required:
+        - '#address-cells'
+        - '#size-cells'
+        - ranges
 
 additionalProperties: false
 
diff --git a/Documentation/devicetree/bindings/arm/stm32/stm32.yaml b/Documentation/devicetree/bindings/arm/stm32/stm32.yaml
index 4c605bccc..23c9bf185 100644
--- a/Documentation/devicetree/bindings/arm/stm32/stm32.yaml
+++ b/Documentation/devicetree/bindings/arm/stm32/stm32.yaml
@@ -81,25 +81,33 @@ properties:
           - const: st,stm32mp157
 
       - items:
-          - const: st,stm32mp157a-dk1-scmi
-          - const: st,stm32mp157a-dk1
-          - const: st,stm32mp157
-      - items:
-          - const: st,stm32mp157c-dk2-scmi
-          - const: st,stm32mp157c-dk2
+          - enum:
+              - st,stm32mp157a-dk1
+              - st,stm32mp157d-dk1
           - const: st,stm32mp157
       - items:
-          - const: st,stm32mp157c-ed1-scmi
-          - const: st,stm32mp157c-ed1
+          - enum:
+              - st,stm32mp157c-dk2
+              - st,stm32mp157f-dk2
           - const: st,stm32mp157
       - items:
-          - const: st,stm32mp157c-ev1
-          - const: st,stm32mp157c-ed1
+          - enum:
+              - st,stm32mp157a-ed1
+              - st,stm32mp157c-ed1
+              - st,stm32mp157d-ed1
+              - st,stm32mp157f-ed1
           - const: st,stm32mp157
       - items:
-          - const: st,stm32mp157c-ev1-scmi
-          - const: st,stm32mp157c-ev1
-          - const: st,stm32mp157c-ed1
+          - enum:
+              - st,stm32mp157a-ev1
+              - st,stm32mp157c-ev1
+              - st,stm32mp157d-ev1
+              - st,stm32mp157f-ev1
+          - enum:
+              - st,stm32mp157a-ed1
+              - st,stm32mp157c-ed1
+              - st,stm32mp157d-ed1
+              - st,stm32mp157f-ed1
           - const: st,stm32mp157
 
       - description: DH STM32MP1 SoM based Boards
@@ -149,6 +157,12 @@ properties:
           - const: seeed,stm32mp157c-odyssey-som
           - const: st,stm32mp157
 
+      - items:
+          - enum:
+              - st,stm32mp257f-dk
+              - st,stm32mp257f-ev1
+          - const: st,stm32mp257
+
 additionalProperties: true
 
 ...
diff --git a/Documentation/devicetree/bindings/bus/st,sys-bus.yaml b/Documentation/devicetree/bindings/bus/st,sys-bus.yaml
new file mode 100644
index 000000000..caa0d9733
--- /dev/null
+++ b/Documentation/devicetree/bindings/bus/st,sys-bus.yaml
@@ -0,0 +1,108 @@
+# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/bus/stm32,sys-bus.yaml
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title:  STM32 System Bus
+
+description: |
+  The STM32 System Bus is an internal bus to which some internal peripherals
+  are connected. STM32 System Bus integrates a firewall controlling access to each
+  device. This bus prevents non-accessible devices to be probed.
+
+  To see which peripherals are securable, please check the SoC reference manual.
+
+maintainers:
+  - Gatien Chevallier <gatien.chevallier@foss.st.com>
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp13-sys-bus
+      - st,stm32mp15-sys-bus
+      - st,stm32mp25-sys-bus
+
+  reg:
+    maxItems: 1
+
+  "#address-cells":
+    description: |
+      The first cell is the bank number (chip select).
+      The second cell is the address offset within the bank.
+    const: 2
+
+  "#size-cells":
+    const: 1
+
+  '#feature-domain-cells':
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Number of cells in a domain controller specifier.
+      Set const to 2 here for nodes providing the peripheral
+      id for the firewall check.
+    const: 1
+
+  ranges: true
+
+  feature-domain-controller: true
+
+patternProperties:
+  "^.*@[1-5],[1-9a-f][0-9a-f]+$":
+    description: Devices attached to system bus
+    type: object
+
+required:
+  - compatible
+  - reg
+  - "#address-cells"
+  - "#size-cells"
+  - feature-domain-controller
+  - '#feature-domain-cells'
+  - ranges
+
+additionalProperties: false
+
+examples:
+  - |
+    // In this example,
+    // - the hash1 device refers to etzpc as his domain controller.
+    // - same goes for rng1.
+    // Access rights are verified before creating devices.
+
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/reset/stm32mp1-resets.h>
+    #include <dt-bindings/bus/stm32mp15_sys_bus.h>
+
+    etzpc: etzpc@0x5C007000 {
+        compatible = "st,stm32mp15-sys-bus";
+        reg = <0x5c007000 0x400>;
+        #address-cells = <1>;
+        #size-cells = <1>;
+        ranges;
+        feature-domain-controller;
+        #feature-domain-cells = <2>;
+
+        hash1: hash@54002000 {
+          compatible = "st,stm32f756-hash";
+          reg = <0x54002000 0x400>;
+          interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+          clocks = <&scmi_clk CK_SCMI_HASH1>;
+          resets = <&scmi_reset RST_SCMI_HASH1>;
+          dmas = <&mdma1 31 0x2 0x1000A02 0x0 0x0 0x0>;
+          dma-names = "in";
+          dma-maxburst = <2>;
+          feature-domains = <&etzpc STM32MP1_ETZPC_HASH1_ID>;
+          status = "disabled";
+        };
+
+        rng1: rng@54003000 {
+          compatible = "st,stm32-rng";
+          reg = <0x54003000 0x400>;
+          clocks = <&scmi_clk CK_SCMI_RNG1>;
+          resets = <&scmi_reset RST_SCMI_RNG1>;
+          feature-domains = <&etzpc STM32MP1_ETZPC_RNG1_ID>;
+          status = "disabled";
+        };
+    };
diff --git a/Documentation/devicetree/bindings/clock/st,stm32mp1-rcc.yaml b/Documentation/devicetree/bindings/clock/st,stm32mp1-rcc.yaml
index 242fe922b..7f25fadf7 100644
--- a/Documentation/devicetree/bindings/clock/st,stm32mp1-rcc.yaml
+++ b/Documentation/devicetree/bindings/clock/st,stm32mp1-rcc.yaml
@@ -77,7 +77,6 @@ if:
     compatible:
       contains:
         enum:
-          - st,stm32mp1-rcc-secure
           - st,stm32mp13-rcc
 then:
   properties:
@@ -99,11 +98,27 @@ else:
   properties:
     clocks:
       description:
-        Specifies the external RX clock for ethernet MAC.
-      maxItems: 1
+        Specifies oscillators and the external RX clock for ethernet MAC.
+      maxItems: 6
 
     clock-names:
-      const: ETH_RX_CLK/ETH_REF_CLK
+      items:
+        - const: hse
+        - const: hsi
+        - const: csi
+        - const: lse
+        - const: lsi
+        - const: ETH_RX_CLK/ETH_REF_CLK
+  if:
+    properties:
+      compatible:
+        contains:
+          enum:
+            - st,stm32mp1-rcc-secure
+  then:
+    required:
+      - clocks
+      - clock-names
 
 additionalProperties: false
 
diff --git a/Documentation/devicetree/bindings/clock/st,stm32mp25-rcc.yaml b/Documentation/devicetree/bindings/clock/st,stm32mp25-rcc.yaml
new file mode 100644
index 000000000..34df9a534
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/st,stm32mp25-rcc.yaml
@@ -0,0 +1,107 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/st,stm32mp25-rcc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32MP25 Reset Clock Controller
+
+maintainers:
+  - Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+
+description: |
+  The RCC hardware block is both a reset and a clock controller.
+  RCC makes also power management (resume/supend).
+
+  Specifying clocks
+  =================
+
+  All available clocks are defined as preprocessor macros in
+  dt-bindings/clock/stm32mp25-clks.h header and can be used in device
+  tree sources.
+  This file implements defines like:
+      #define CK_BUS_SDMMC1 245
+      #define CK_KER_SDMMC1 313
+
+  Specifying softreset control of devices
+  =======================================
+
+  Device nodes should specify the reset channel required in their "resets"
+  property, containing a phandle to the reset device node and an index
+  specifying which channel to use.
+  The index is the bit number within the RCC registers bank, starting from RCC
+  base address.
+  It is calculated as: index = register_offset / 4 * 32 + bit_offset.
+  Where bit_offset is the bit offset within the register.
+
+  For example on STM32MP25, for LTDC reset:
+     ltdc = RCC_LTDCCFGR offset / 4 * 32 + LTDC_bit_offset
+          = 0x840 / 4 * 32 + 0 = 16896
+
+  See also::
+    include/dt-bindings/clock/stm32mp25-clks.h
+    include/dt-bindings/reset/stm32mp25-resets.h
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp25-rcc
+
+  reg:
+    maxItems: 1
+
+  '#clock-cells':
+    const: 1
+
+  '#reset-cells':
+    const: 1
+
+  clocks:
+    items:
+      - description: CK_SCMI_HSE High Speed External oscillator (8 to 48 MHz)
+      - description: CK_SCMI_HSI High Speed Internal oscillator (~ 64 MHz)
+      - description: CK_SCMI_MSI Low Power Internal oscillator (~ 4 MHz or ~ 16 MHz)
+      - description: CK_SCMI_LSE Low Speed External oscillator (32 KHz)
+      - description: CK_SCMI_LSI Low Speed Internal oscillator (~ 32 KHz)
+
+  clock-names:
+    items:
+      - const: hse
+      - const: hsi
+      - const: msi
+      - const: lse
+      - const: lsi
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+required:
+  - compatible
+  - reg
+  - '#clock-cells'
+  - '#reset-cells'
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+
+    rcc: clock-controller@44200000 {
+        compatible = "st,stm32mp25-rcc";
+        reg = <0x44200000 0x10000>;
+        #clock-cells = <1>;
+        #reset-cells = <1>;
+        clock-names = "hse", "hsi", "msi", "lse", "lsi";
+        clocks = <&scmi_clk CK_SCMI_HSE>,
+                 <&scmi_clk CK_SCMI_HSI>,
+                 <&scmi_clk CK_SCMI_MSI>,
+                 <&scmi_clk CK_SCMI_LSE>,
+                 <&scmi_clk CK_SCMI_LSI>;
+        feature-domains = <&rifsc 156>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt b/Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt
new file mode 100644
index 000000000..1292eb261
--- /dev/null
+++ b/Documentation/devicetree/bindings/cpufreq/stm32-cpufreq.txt
@@ -0,0 +1,61 @@
+STM32 CPUFreq and OPP bindings
+==============================
+
+STM32 CPUFreq driver needs to read chip information from the SoC to list
+available OPPs. Then it depends on cpufreq-dt bindings.
+
+Required properties:
+--------------------
+- clocks: Phandle to the cpu clock "cpu".
+- clocks-name: Should contain "cpu".
+- nvmem-cells: Phandle to nvmem cell that contains "part_number".
+- nvmem-cell-names: Must be "part_number".
+- operating-points-v2: Phandle to operating points table. See ../power/opp.txt
+  for more details.
+
+Optional properties:
+--------------------
+See cpufreq-dt.txt for optional properties.
+
+Examples:
+---------
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&rcc CK_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+		};
+
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a7";
+			device_type = "cpu";
+			reg = <1>;
+			clocks = <&rcc CK_MPU>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+		};
+	};
+
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x1>;
+		};
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1350000>;
+			opp-supported-hw = <0x2>;
+		};
+	};
diff --git a/Documentation/devicetree/bindings/crypto/st,stm32-crc.yaml b/Documentation/devicetree/bindings/crypto/st,stm32-crc.yaml
index b72e4858f..1616f05fb 100644
--- a/Documentation/devicetree/bindings/crypto/st,stm32-crc.yaml
+++ b/Documentation/devicetree/bindings/crypto/st,stm32-crc.yaml
@@ -19,6 +19,14 @@ properties:
   clocks:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml b/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml
index ed23bf94a..3f55cf365 100644
--- a/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml
+++ b/Documentation/devicetree/bindings/crypto/st,stm32-cryp.yaml
@@ -27,6 +27,14 @@ properties:
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml b/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml
index 10ba94792..70f053515 100644
--- a/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml
+++ b/Documentation/devicetree/bindings/crypto/st,stm32-hash.yaml
@@ -6,14 +6,21 @@ $schema: http://devicetree.org/meta-schemas/core.yaml#
 
 title: STMicroelectronics STM32 HASH bindings
 
+description: The STM32 HASH block is built on the HASH block found in
+  the STn8820 SoC introduced in 2007, and subsequently used in the U8500
+  SoC in 2010.
+
 maintainers:
   - Lionel Debieve <lionel.debieve@foss.st.com>
 
 properties:
   compatible:
     enum:
+      - st,stn8820-hash
+      - stericsson,ux500-hash
       - st,stm32f456-hash
       - st,stm32f756-hash
+      - st,stm32mp13-hash
 
   reg:
     maxItems: 1
@@ -41,11 +48,31 @@ properties:
     maximum: 2
     default: 0
 
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
   - clocks
-  - interrupts
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          items:
+            const: stericsson,ux500-hash
+    then:
+      properties:
+        interrupts: false
+    else:
+      required:
+        - interrupts
 
 additionalProperties: false
 
diff --git a/Documentation/devicetree/bindings/display/connector/hdmi-connector.yaml b/Documentation/devicetree/bindings/display/connector/hdmi-connector.yaml
index 83c0d0082..ea15c65c5 100644
--- a/Documentation/devicetree/bindings/display/connector/hdmi-connector.yaml
+++ b/Documentation/devicetree/bindings/display/connector/hdmi-connector.yaml
@@ -36,6 +36,9 @@ properties:
     description: GPIO signal to enable DDC bus
     maxItems: 1
 
+  hdmi-pwr-supply:
+    description: Power supply for the HDMI_PWR pin
+
   port:
     $ref: /schemas/graph.yaml#/properties/port
     description: Connection to controller providing HDMI signals
diff --git a/Documentation/devicetree/bindings/display/panel/panel-simple.yaml b/Documentation/devicetree/bindings/display/panel/panel-simple.yaml
index 18241f405..a017b1b5c 100644
--- a/Documentation/devicetree/bindings/display/panel/panel-simple.yaml
+++ b/Documentation/devicetree/bindings/display/panel/panel-simple.yaml
@@ -274,6 +274,8 @@ properties:
       - qiaodian,qd43003c0-40
         # Shenzhen QiShenglong Industrialist Co., Ltd. Gopher 2b 4.3" 480(RGB)x272 TFT LCD panel
       - qishenglong,gopher2b-lcd
+        # Rocktech Display Ltd. RK043FN48H TFT 480x272
+      - rocktech,rk043fn48h"
         # Rocktech Displays Ltd. RK101II01D-CT 10.1" TFT 1280x800
       - rocktech,rk101ii01d-ct
         # Rocktech Display Ltd. RK070ER9427 800(RGB)x480 TFT LCD panel
diff --git a/Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml b/Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml
new file mode 100644
index 000000000..db548d94e
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/rocktech,hx8394.yaml
@@ -0,0 +1,56 @@
+# SPDX-License-Identifier: (GPL-2.0-only or BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/rocktech,hx8394.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title:  ROCKTECH DISPLAYS LIMITED HX8394 5.5" 720p MIPI-DSI TFT LCD panel
+
+maintainers:
+  - Yannick Fertre <yannick.fertre@foss.st.com>
+
+description: |
+  The  ROCKTECH DISPLAYS LIMITED HX8394 is a 5.5" 720x1280 TFT LCD
+  panel connected using a MIPI-DSI video interface.
+
+allOf:
+  - $ref: panel-common.yaml#
+
+properties:
+
+  compatible:
+    const: rocktech,hx8394
+
+  reg:
+    maxItems: 1
+    description: DSI virtual channel
+
+  backlight: true
+  enable-gpios: true
+  port: true
+  power-supply: true
+
+  reset-gpios:
+    maxItems: 1
+
+additionalProperties: false
+
+required:
+  - compatible
+  - power-supply
+  - reg
+
+examples:
+  - |
+    dsi {
+      #address-cells = <1>;
+      #size-cells = <0>;
+      panel@0 {
+        compatible = "rocktech,hx8394";
+        reg = <0>;
+        reset-gpios = <&gpiof 15 0>;
+        power-supply = <&v1v8>;
+        backlight = <&pwm_backlight>;
+      };
+    };
+...
diff --git a/Documentation/devicetree/bindings/display/st,stm32-dsi.yaml b/Documentation/devicetree/bindings/display/st,stm32-dsi.yaml
index c488308d7..98f1b5ae9 100644
--- a/Documentation/devicetree/bindings/display/st,stm32-dsi.yaml
+++ b/Documentation/devicetree/bindings/display/st,stm32-dsi.yaml
@@ -13,12 +13,11 @@ maintainers:
 description:
   The STMicroelectronics STM32 DSI controller uses the Synopsys DesignWare MIPI-DSI host controller.
 
-allOf:
-  - $ref: dsi-controller.yaml#
-
 properties:
   compatible:
-    const: st,stm32-dsi
+    enum:
+      - st,stm32-dsi
+      - st,stm32mp25-dsi
 
   reg:
     maxItems: 1
@@ -44,9 +43,13 @@ properties:
     items:
       - const: apb
 
-  phy-dsi-supply:
-    description:
-      Phandle of the regulator that provides the supply voltage.
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
 
   ports:
     $ref: /schemas/graph.yaml#/properties/ports
@@ -73,6 +76,37 @@ properties:
                   - const: 1
                   - const: 2
 
+allOf:
+  - $ref: dsi-controller.yaml#
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32-dsi
+    then:
+      properties:
+        phy-dsi-supply:
+          description:
+            Phandle of the regulator that provides the supply voltage.
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32mp25-dsi
+    then:
+      properties:
+        vdd-supply:
+          description:
+            Phandle of the regulator that provides the supply voltage vdd.
+
+        vdda18-supply:
+          description:
+            Phandle of the regulator that provides the supply voltage vdda18.
+
 required:
   - "#address-cells"
   - "#size-cells"
diff --git a/Documentation/devicetree/bindings/display/st,stm32-ltdc.yaml b/Documentation/devicetree/bindings/display/st,stm32-ltdc.yaml
index d6ea4d62a..db4306e8c 100644
--- a/Documentation/devicetree/bindings/display/st,stm32-ltdc.yaml
+++ b/Documentation/devicetree/bindings/display/st,stm32-ltdc.yaml
@@ -12,7 +12,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32-ltdc
+      enum:
+      - st,stm32-ltdc
+      - st,stm32mp25-ltdc
 
   reg:
     maxItems: 1
@@ -33,6 +35,9 @@ properties:
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   port:
     $ref: /schemas/graph.yaml#/properties/port
     description: |
@@ -42,6 +47,11 @@ properties:
       - for internal dpi input of the MIPI DSI host controller.
       Note: These 2 endpoints cannot be activated simultaneously.
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/display/st,stm32-lvds.yaml b/Documentation/devicetree/bindings/display/st,stm32-lvds.yaml
new file mode 100644
index 000000000..5cf27a61b
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/st,stm32-lvds.yaml
@@ -0,0 +1,109 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/st,stm32-lvds.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 LVDS Display Interface Transmitter
+
+maintainers:
+  - Raphael Gallais-Pou <raphael.gallais-pou@foss.st.com>
+  - Yannick Fertre <yannick.fertre@foss.st.com>
+
+description: |
+  The STMicroelectronics STM32 LVDS Display Interface Transmitter handles the
+  LVDS protocol: it maps the pixels received from the upstream Pixel-DMA (LTDC)
+  onto the LVDS PHY.
+
+properties:
+  "#clock-cells":
+    const: 0
+
+  compatible:
+    const: st,stm32mp25-lvds
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: APB peripheral clock
+      - description: Reference clock for the internal PLL
+
+  clock-names:
+    items:
+      - const: pclk
+      - const: ref
+
+  resets:
+    maxItems: 1
+
+  feature-domains:
+    minItems: 1
+    maxItems: 2
+
+  power-domains:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/properties/port
+        description: |
+          LVDS input port node, connected to the LTDC RGB output port.
+
+      port@1:
+        $ref: /schemas/graph.yaml#/properties/port
+        description: |
+          LVDS output port node, connected to a panel or bridge input port.
+
+required:
+  - "#clock-cells"
+  - compatible
+  - reg
+  - clocks
+  - clock-names
+  - resets
+  - ports
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/bus/stm32mp25_sys_bus.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    lvds: lvds@48060000 {
+        #clock-cells = <0>;
+        compatible = "st,stm32-lvds";
+        reg = <0x48060000 0x2000>;
+        clocks = <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+        clock-names = "pclk", "ref";
+        resets = <&rcc LVDS_R>;
+        feature-domains = <&rifsc STM32MP25_RIFSC_LVDS_ID>;
+        power-domains = <&CLUSTER_PD>;
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                reg = <0>;
+                lvds_in: endpoint {
+                   remote-endpoint = <&ltdc_ep1_out>;
+                };
+            };
+
+            port@1 {
+                reg = <1>;
+                lvds_out0: endpoint {
+                   remote-endpoint = <&lvds_panel_in>;
+                };
+            };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/dma/st,stm32-dma.yaml b/Documentation/devicetree/bindings/dma/stm32/st,stm32-dma.yaml
similarity index 91%
rename from Documentation/devicetree/bindings/dma/st,stm32-dma.yaml
rename to Documentation/devicetree/bindings/dma/stm32/st,stm32-dma.yaml
index 55faab6a4..2888b3d1f 100644
--- a/Documentation/devicetree/bindings/dma/st,stm32-dma.yaml
+++ b/Documentation/devicetree/bindings/dma/stm32/st,stm32-dma.yaml
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 %YAML 1.2
 ---
-$id: http://devicetree.org/schemas/dma/st,stm32-dma.yaml#
+$id: http://devicetree.org/schemas/dma/stm32/st,stm32-dma.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
-title: STMicroelectronics STM32 DMA Controller bindings
+title: STMicroelectronics STM32 DMA Controller
 
 description: |
   The STM32 DMA is a general-purpose direct memory access controller capable of
@@ -53,7 +53,7 @@ maintainers:
   - Amelie Delaunay <amelie.delaunay@foss.st.com>
 
 allOf:
-  - $ref: "dma-controller.yaml#"
+  - $ref: /schemas/dma/dma-controller.yaml#
 
 properties:
   "#dma-cells":
@@ -82,6 +82,11 @@ properties:
     description: if defined, it indicates that the controller
       supports memory-to-memory transfer
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/dma/stm32/st,stm32-dma3.yaml b/Documentation/devicetree/bindings/dma/stm32/st,stm32-dma3.yaml
new file mode 100644
index 000000000..813107c1b
--- /dev/null
+++ b/Documentation/devicetree/bindings/dma/stm32/st,stm32-dma3.yaml
@@ -0,0 +1,160 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/dma/stm32/st,stm32-dma3.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 DMA3 Controller
+
+description: |
+  The STM32 DMA3 is a direct memory access controller with different features
+  depending on its hardware configuration.
+  It is either called LPDMA (Low Power), GPDMA (General Purpose) or
+  HPDMA (High Performance).
+  Its hardware configuration registers allow to dynamically expose its features.
+
+  GPDMA and HPDMA support 16 independent DMA channels, while only 4 for LPDMA.
+  GPDMA and HPDMA support 256 DMA requests from peripherals, 8 for LPDMA.
+
+  Bindings are generic for these 3 STM32 DMA3 configurations.
+
+  DMA clients connected to the STM32 DMA3 controller must use the format described
+  in the ../dma.txt file, using a four-cell specifier for each channel.
+  A phandle to the DMA controller plus the following three integer cells:
+    1. The request line number
+    2. A 32-bit mask specifying the DMA channel requirements
+      -bit 0-1: The priority level
+        0x0: low priority, low weight
+        0x1: low priority, mid weight
+        0x2: low priority, high weight
+        0x3: high priority
+      -bit 4-7: The FIFO requirement for queuing source and destination transfers
+        0x0: no FIFO requirement/any channel can fit
+        0x2: FIFO of 8 bytes (2^2+1)
+        0x4: FIFO of 32 bytes (2^4+1)
+        0x6: FIFO of 128 bytes (2^6+1)
+        0x7: FIFO of 256 bytes (2^7+1)
+    3. A 32-bit mask specifying the DMA transfer requirements
+      -bit 0: The source incrementing burst
+        0x0: fixed burst
+        0x1: contiguously incremented burst
+      -bit 1: The source allocated port
+        0x0: port 0 is allocated to the source transfer
+        0x1: port 1 is allocated to the source transfer
+      -bit 4: The destination incrementing burst
+        0x0: fixed burst
+        0x1: contiguously incremented burst
+      -bit 5: The destination allocated port
+        0x0: port 0 is allocated to the destination transfer
+        0x1: port 1 is allocated to the destination transfer
+      -bit 8: The type of hardware request
+        0x0: burst
+        0x1: block
+      -bit 9: The control mode
+        0x0: DMA controller control mode
+        0x1: peripheral control mode
+      -bit 12-13: The transfer complete event mode
+        0x0: at block level, transfer complete event is generated at the end of a block
+        0x2: at LLI level, the transfer complete event is generated at the end of the LLI transfer,
+             including the update of the LLI if any
+        0x3: at channel level, the transfer complete event is generated at the end of the last LLI
+      -bit 16: Prevent packing/unpacking mode
+        0x0: pack/unpack enabled when source data width/burst != destination data width/burst
+        0x1: memory data width/burst forced to peripheral data width/burst to prevent pack/unpack
+      -bit 17: Prevent linked-list refactoring
+        0x0: don't prevent driver to refactor the linked-list for optimal performance
+        0x1: prevent driver to refactor the linked-list, despite not optimal performance
+
+maintainers:
+  - Amelie Delaunay <amelie.delaunay@foss.st.com>
+
+allOf:
+  - $ref: /schemas/dma/dma-controller.yaml#
+
+properties:
+  "#dma-cells":
+    const: 3
+
+  compatible:
+    const: st,stm32-dma3
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    minItems: 4
+    maxItems: 16
+
+  lli-bus-interface:
+    description: |
+      To select port 1 for fetching linked-list items (LLIs).
+      If not defined, port 0 is used by default.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [0, 1]
+    default: 0
+
+  memory-region:
+    description: |
+      Phandle to a /reserved-memory child node assigned to STM32 DMA3 for linked-list items
+      allocation. When not defined, linked-list items are allocated in DDR.
+      During transfer, STM32 DMA3 updates its registers reading the linked-list items in memory.
+      There reads are 32-bit single read. Allocating the linked-list items in internal RAM improves
+      the STM32 DMA3 performance.
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  st,axi-max-burst-len:
+    description: |
+      Restrict AXI burst length in unit of beat by value specified in this property.
+      The value specified in this property is clamped to the maximum burst length supported by DMA3.
+      If this property is missing, the maximum burst length supported by DMA3 is used.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 1
+    maximum: 256
+    default: 64
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - interrupts
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    dma-controller@40400000 {
+      compatible = "st,stm32-dma3";
+      reg = <0x40400000 0x1000>;
+      interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+                   <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+      clocks = <&rcc CK_BUS_HPDMA1>;
+      #dma-cells = <3>;
+      st,axi-max-burst-len = <16>;
+    };
+...
+
diff --git a/Documentation/devicetree/bindings/dma/st,stm32-dmamux.yaml b/Documentation/devicetree/bindings/dma/stm32/st,stm32-dmamux.yaml
similarity index 73%
rename from Documentation/devicetree/bindings/dma/st,stm32-dmamux.yaml
rename to Documentation/devicetree/bindings/dma/stm32/st,stm32-dmamux.yaml
index 1e1d8549b..224e6469c 100644
--- a/Documentation/devicetree/bindings/dma/st,stm32-dmamux.yaml
+++ b/Documentation/devicetree/bindings/dma/stm32/st,stm32-dmamux.yaml
@@ -1,16 +1,16 @@
 # SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 %YAML 1.2
 ---
-$id: http://devicetree.org/schemas/dma/st,stm32-dmamux.yaml#
+$id: http://devicetree.org/schemas/dma/stm32/st,stm32-dmamux.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
-title: STMicroelectronics STM32 DMA MUX (DMA request router) bindings
+title: STMicroelectronics STM32 DMA MUX (DMA request router)
 
 maintainers:
   - Amelie Delaunay <amelie.delaunay@foss.st.com>
 
 allOf:
-  - $ref: "dma-router.yaml#"
+  - $ref: /schemas/dma/dma-router.yaml#
 
 properties:
   "#dma-cells":
@@ -28,6 +28,11 @@ properties:
   resets:
     maxItems: 1
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml b/Documentation/devicetree/bindings/dma/stm32/st,stm32-mdma.yaml
similarity index 95%
rename from Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml
rename to Documentation/devicetree/bindings/dma/stm32/st,stm32-mdma.yaml
index 00cfa3913..45fe91db1 100644
--- a/Documentation/devicetree/bindings/dma/st,stm32-mdma.yaml
+++ b/Documentation/devicetree/bindings/dma/stm32/st,stm32-mdma.yaml
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 %YAML 1.2
 ---
-$id: http://devicetree.org/schemas/dma/st,stm32-mdma.yaml#
+$id: http://devicetree.org/schemas/dma/stm32/st,stm32-mdma.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
-title: STMicroelectronics STM32 MDMA Controller bindings
+title: STMicroelectronics STM32 MDMA Controller
 
 description: |
   The STM32 MDMA is a general-purpose direct memory access controller capable of
@@ -53,7 +53,7 @@ maintainers:
   - Amelie Delaunay <amelie.delaunay@foss.st.com>
 
 allOf:
-  - $ref: "dma-controller.yaml#"
+  - $ref: /schemas/dma/dma-controller.yaml#
 
 properties:
   "#dma-cells":
diff --git a/Documentation/devicetree/bindings/feature-controllers/feature-domain-controller.yaml b/Documentation/devicetree/bindings/feature-controllers/feature-domain-controller.yaml
new file mode 100644
index 000000000..300565f93
--- /dev/null
+++ b/Documentation/devicetree/bindings/feature-controllers/feature-domain-controller.yaml
@@ -0,0 +1,85 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/feature-controllers/feature-domain-controller.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Generic Domain Controller
+
+maintainers:
+  - Oleksii Moisieiev <oleksii_moisieiev@epam.com>
+
+description: |+
+  Common Feature Domains Controller bindings properties
+
+  Domain controllers allow to divided system on chip into multiple feature
+  domains that can be used to select by who hardware blocks could be accessed.
+  A feature domain could be a cluster of CPUs (or coprocessors), a range of
+  addresses or a group of hardware blocks.
+
+  This device tree bindings can be used to bind feature domain consumer devices
+  with their feature domains provided by feature-domains controllers.
+  Feature omain controller provider can be represened by any node in the
+  device tree and can provide one or more configuration parameters, needed to
+  control parameters of the consumer device. A consumer node can refer to the
+  provider by phandle and a set of phandle arguments, specified by
+  '#feature-domain-cells' property in the device controller provider node.
+
+  Device controllers are typically used to set the permissions of the hardware
+  block. The contents of the feature-domains configuration properties are
+  defined by the binding for the individual feature-domains controller device.
+
+  Each node can be a consumer for the several providers. The first
+  configuration of 'feature-domains' or the one named 'default' is applied
+  before probing the device itself.
+
+# always select the core schema
+select: true
+
+properties:
+  '#feature-domain-cells':
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Number of cells in a feature-domains controller specifier;
+      Can be any value as specified by device tree binding documentation
+      of a particular provider.
+
+  feature-domain-controller:
+    type: boolean
+    description:
+      Indicates that the node is feature-domain-controller provider.
+
+  feature-domain-names:
+    $ref: '/schemas/types.yaml#/definitions/string-array'
+    description:
+      A list of feature-domains names, sorted in the same order as
+      feature-domains entries. Consumer drivers will use feature-domain-names
+      to match with existing feature-domains entries.
+
+  feature-domains:
+    $ref: "/schemas/types.yaml#/definitions/phandle-array"
+    description:
+      A list of feature-domains controller specifiers, as defined by the
+      bindings of the feature-domain-controller provider.
+
+additionalProperties: true
+
+examples:
+  - |
+    ctrl0: ctrl@100 {
+        feature-domain-controller;
+        reg = <0x100 0x10>;
+        #feature-domain-cells = <2>;
+    };
+
+    ctrl1: ctrl@110 {
+        feature-domain-controller;
+        reg = <0x110 0x10>;
+        #feature-domain-cells = <3>;
+    };
+
+    foo@0 {
+        reg = <0x0 0x1>;
+        feature-domains = <&ctrl0 1 2>, <&ctrl1 3 4 5>;
+        feature-domain-names = "default", "unbind";
+    };
diff --git a/Documentation/devicetree/bindings/gpu/vivante,gc.yaml b/Documentation/devicetree/bindings/gpu/vivante,gc.yaml
index 93e7244cd..fbe9ef0ee 100644
--- a/Documentation/devicetree/bindings/gpu/vivante,gc.yaml
+++ b/Documentation/devicetree/bindings/gpu/vivante,gc.yaml
@@ -49,6 +49,11 @@ properties:
   power-domains:
     maxItems: 1
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/hwlock/hwlock.txt b/Documentation/devicetree/bindings/hwlock/hwlock.txt
index 085d1f5c9..e98088a40 100644
--- a/Documentation/devicetree/bindings/hwlock/hwlock.txt
+++ b/Documentation/devicetree/bindings/hwlock/hwlock.txt
@@ -13,7 +13,7 @@ hwlock providers:
 
 Required properties:
 - #hwlock-cells:        Specifies the number of cells needed to represent a
-                        specific lock.
+                        specific lock. Shall be 1 or 2 (see hwlocks below).
 
 hwlock users:
 =============
@@ -27,6 +27,11 @@ Required properties:
                         #hwlock-cells. The list can have just a single hwlock
                         or multiple hwlocks, with each hwlock represented by
                         a phandle and a corresponding args specifier.
+                        If #hwlock-cells is 1, all of the locks are exclusive
+                        (cannot be used by several users).
+                        If #hwlock-cells is 2, the value of the second cell
+                        defines whether the lock is for exclusive usage (0) or
+                        shared (1) i.e. can be used by several users.
 
 Optional properties:
 - hwlock-names:         List of hwlock name strings defined in the same order
@@ -46,14 +51,22 @@ of length 1.
 		...
 	};
 
-2. Example of a node using multiple specific hwlocks:
+2. Example of nodes using multiple and shared specific hwlocks:
 
-The following example has a node requesting two hwlocks, a hwlock within
-the hwlock device node 'hwlock1' with #hwlock-cells value of 1, and another
-hwlock within the hwlock device node 'hwlock2' with #hwlock-cells value of 2.
+The following example has a nodeA requesting two hwlocks:
+- an exclusive one (#hwlock-cells = 1) within the hwlock device node 'hwlock1'
+- a shared one (#hwlock-cells = 2, second cell = 1) within the hwlock device
+  node 'hwlock2'.
+The shared lock is also be used by nodeB.
 
-	node {
+	nodeA {
 		...
-		hwlocks = <&hwlock1 2>, <&hwlock2 0 3>;
+		hwlocks = <&hwlock1 2>, <&hwlock2 0 1>;
 		...
 	};
+
+	nodeB {
+		...
+		hwlocks = <&hwlock2 0 1>;
+		...
+	};
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml b/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml
index b18c61603..dd6fa3758 100644
--- a/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml
+++ b/Documentation/devicetree/bindings/hwlock/st,stm32-hwspinlock.yaml
@@ -11,7 +11,7 @@ maintainers:
 
 properties:
   "#hwlock-cells":
-    const: 1
+    const: 2
 
   compatible:
     const: st,stm32-hwspinlock
@@ -40,7 +40,7 @@ examples:
     #include <dt-bindings/clock/stm32mp1-clks.h>
     hwspinlock@4c000000 {
         compatible = "st,stm32-hwspinlock";
-        #hwlock-cells = <1>;
+        #hwlock-cells = <2>;
         reg = <0x4c000000 0x400>;
         clocks = <&rcc HSEM>;
         clock-names = "hsem";
diff --git a/Documentation/devicetree/bindings/i2c/i2c-rpmsg.yaml b/Documentation/devicetree/bindings/i2c/i2c-rpmsg.yaml
new file mode 100644
index 000000000..b6074416d
--- /dev/null
+++ b/Documentation/devicetree/bindings/i2c/i2c-rpmsg.yaml
@@ -0,0 +1,46 @@
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+# Copyright (c) 2023 STMicroelectronics.
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/i2c/i2c-rpmsg.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: RPMsg I2C Adapter
+
+maintainers:
+  - Arnaud Pouliquen <arnaud.pouliquen@foss.st.com>
+
+allOf:
+  - $ref: /schemas/i2c/i2c-controller.yaml#
+
+description:
+  RPMsg I2C adapter for I2C protocol support over RPMsg
+
+properties:
+  compatible:
+    const: rpmsg,i2c-controller
+
+  rpmsg,dev-id:
+    description:
+      Id name of the rpmsg_i2c device instance
+
+required:
+  - compatible
+  - dev-id
+
+examples:
+  - |
+    rpmsg_i2c: i2c@0 {
+        compatible = "rpmsg,i2c-controller";
+        reg = <0 0>;
+        rpmsg,dev-id = "rpmsg_i2c";
+        status = "okay";
+
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        light-sensor@20 {
+            compatible = "dynaimage,al3320a";
+            reg = <0x20>;
+        };
+    };
diff --git a/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml b/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml
index bf396e946..9fd7d1d75 100644
--- a/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml
+++ b/Documentation/devicetree/bindings/i2c/st,stm32-i2c.yaml
@@ -19,6 +19,7 @@ allOf:
               - st,stm32f7-i2c
               - st,stm32mp13-i2c
               - st,stm32mp15-i2c
+              - st,stm32mp25-i2c
     then:
       properties:
         i2c-scl-rising-time-ns:
@@ -41,6 +42,33 @@ allOf:
         clock-frequency:
           enum: [100000, 400000]
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32f7-i2c
+              - st,stm32mp13-i2c
+              - st,stm32mp15-i2c
+    then:
+      properties:
+        interrupts:
+          items:
+            - description: interrupt ID for I2C event
+            - description: interrupt ID for I2C error
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32mp25-i2c
+    then:
+      properties:
+        interrupts:
+          items:
+            - description: common interrupt for events and errors
+
 properties:
   compatible:
     enum:
@@ -48,14 +76,11 @@ properties:
       - st,stm32f7-i2c
       - st,stm32mp13-i2c
       - st,stm32mp15-i2c
+      - st,stm32mp25-i2c
 
   reg:
     maxItems: 1
 
-  interrupts:
-    items:
-      - description: interrupt ID for I2C event
-      - description: interrupt ID for I2C error
 
   interrupt-names:
     items:
@@ -68,6 +93,9 @@ properties:
   clocks:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   dmas:
     items:
       - description: RX DMA Channel phandle
@@ -99,6 +127,11 @@ properties:
 
   wakeup-source: true
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/i3c/st,stm32-i3c-master.yaml b/Documentation/devicetree/bindings/i3c/st,stm32-i3c-master.yaml
new file mode 100644
index 000000000..6b6331316
--- /dev/null
+++ b/Documentation/devicetree/bindings/i3c/st,stm32-i3c-master.yaml
@@ -0,0 +1,53 @@
+# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/i3c/st,stm32-i3c.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 I3C master
+
+maintainers:
+  - Amelie Delaunay <amelie.delaunay@foss.st.com>
+
+allOf:
+  - $ref: "i3c.yaml#"
+
+properties:
+  compatible:
+    const: st,stm32-i3c
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    i3c@40190000 {
+      #address-cells = <3>;
+      #size-cells = <0>;
+      compatible = "st,stm32-i3c";
+      reg = <0x40190000 0x400>;
+      interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+      clocks = <&rcc CK_KER_I3C1>;
+      resets = <&rcc I3C4_R>;
+      status = "disabled";
+    };
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml b/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml
index 2287697f1..cc028fe94 100644
--- a/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml
+++ b/Documentation/devicetree/bindings/iio/adc/sigma-delta-modulator.yaml
@@ -21,6 +21,9 @@ properties:
   '#io-channel-cells':
     const: 0
 
+  vref-supply:
+    description: Phandle to the vref input analog reference voltage.
+
 required:
   - compatible
   - '#io-channel-cells'
diff --git a/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml b/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml
index fa8da42cb..70124141b 100644
--- a/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml
+++ b/Documentation/devicetree/bindings/iio/adc/st,stm32-adc.yaml
@@ -27,6 +27,8 @@ properties:
       - st,stm32f4-adc-core
       - st,stm32h7-adc-core
       - st,stm32mp1-adc-core
+      - st,stm32mp13-adc-core
+      - st,stm32mp25-adc-core
 
   reg:
     maxItems: 1
@@ -37,6 +39,7 @@ properties:
         - stm32f4 and stm32h7 share a common ADC interrupt line.
         - stm32mp1 has two separate interrupt lines, one for each ADC within
           ADC block.
+        - stm32mp13 has an interrupt line per ADC block.
     minItems: 1
     maxItems: 2
 
@@ -74,6 +77,9 @@ properties:
       Phandle to the vdd input voltage. It can be used to supply ADC analog
       input switches on stm32mp1.
 
+  power-domains:
+    maxItems: 1
+
   st,syscfg:
     description:
       Phandle to system configuration controller. It can be used to control the
@@ -91,6 +97,11 @@ properties:
   '#size-cells':
     const: 0
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 allOf:
   - if:
       properties:
@@ -180,6 +191,58 @@ allOf:
           maximum: 36000000
           default: 36000000
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp13-adc-core
+
+    then:
+      properties:
+        clocks:
+          minItems: 1
+          maxItems: 2
+
+        clock-names:
+          items:
+            - const: bus
+            - const: adc
+          minItems: 1
+
+        interrupts:
+          items:
+            - description: ADC interrupt line
+
+        st,max-clk-rate-hz:
+          minimum: 150000
+          maximum: 75000000
+          default: 75000000
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-adc-core
+
+    then:
+      properties:
+        clocks:
+          maxItems: 1
+
+        clock-names:
+          const: adc
+
+        interrupts:
+          items:
+            - description: interrupt line for ADC1 or ADC3
+            - description: interrupt line for ADC2
+          minItems: 1
+
+        st,max-clk-rate-hz:
+          minimum: 700000
+          maximum: 70000000
+          default: 70000000
+
 additionalProperties: false
 
 required:
@@ -208,6 +271,8 @@ patternProperties:
           - st,stm32f4-adc
           - st,stm32h7-adc
           - st,stm32mp1-adc
+          - st,stm32mp13-adc
+          - st,stm32mp25-adc
 
       reg:
         description: |
@@ -229,7 +294,7 @@ patternProperties:
       interrupts:
         description: |
           IRQ Line for the ADC instance. Valid values are:
-            - 0 for adc@0
+            - 0 for adc@0 (single adc for stm32mp13)
             - 1 for adc@100
             - 2 for adc@200 (stm32f4 only)
         maxItems: 1
@@ -250,15 +315,16 @@ patternProperties:
       assigned-resolution-bits:
         description: |
           Resolution (bits) to use for conversions:
-            - can be 6, 8, 10 or 12 on stm32f4
+            - can be 6, 8, 10 or 12 on stm32f4 and stm32mp13
             - can be 8, 10, 12, 14 or 16 on stm32h7 and stm32mp1
 
       st,adc-channels:
         description: |
           List of single-ended channels muxed for this ADC. It can have up to:
             - 16 channels, numbered from 0 to 15 (for in0..in15) on stm32f4
-            - 20 channels, numbered from 0 to 19 (for in0..in19) on stm32h7 and
-              stm32mp1.
+            - 19 channels, numbered from 0 to 18 (for in0..in18) on stm32mp13.
+            - 20 channels, numbered from 0 to 19 (for in0..in19) on stm32h7,
+              stm32mp1 and stm32mp25.
         $ref: /schemas/types.yaml#/definitions/uint32-array
         deprecated: true
 
@@ -322,7 +388,7 @@ patternProperties:
           label:
             description: |
               Unique name to identify which channel this is.
-              Reserved label names "vddcore", "vrefint" and "vbat"
+              Reserved label names "vddcore", "vddcpu", "vddq_ddr", "vrefint" and "vbat"
               are used to identify internal channels with matching names.
 
           diff-channels:
@@ -419,6 +485,71 @@ patternProperties:
               items:
                 minimum: 40
 
+
+      - if:
+          properties:
+            compatible:
+              contains:
+                const: st,stm32mp13-adc
+
+        then:
+          properties:
+            reg:
+              const: 0x0
+
+            interrupts:
+              const: 0
+
+            assigned-resolution-bits:
+              enum: [6, 8, 10, 12]
+              default: 12
+
+            st,adc-channels:
+              minItems: 1
+              maxItems: 19
+              items:
+                minimum: 0
+                maximum: 18
+
+            st,min-sample-time-nsecs:
+              minItems: 1
+              maxItems: 19
+              items:
+                minimum: 40
+
+      - if:
+          properties:
+            compatible:
+              contains:
+                const: st,stm32mp25-adc
+
+        then:
+          properties:
+            reg:
+              enum:
+                - 0x0
+                - 0x100
+
+            interrupts:
+              minimum: 0
+              maximum: 1
+
+            assigned-resolution-bits:
+              enum: [6, 8, 10, 12]
+              default: 12
+
+            st,adc-channels:
+              minItems: 1
+              maxItems: 20
+              items:
+                minimum: 0
+                maximum: 19
+
+            st,min-sample-time-nsecs:
+              minItems: 1
+              maxItems: 20
+              items:
+                minimum: 40
     additionalProperties: false
 
     required:
diff --git a/Documentation/devicetree/bindings/iio/adc/st,stm32-dfsdm-adc.yaml b/Documentation/devicetree/bindings/iio/adc/st,stm32-dfsdm-adc.yaml
index 197050338..aced27b50 100644
--- a/Documentation/devicetree/bindings/iio/adc/st,stm32-dfsdm-adc.yaml
+++ b/Documentation/devicetree/bindings/iio/adc/st,stm32-dfsdm-adc.yaml
@@ -59,6 +59,11 @@ properties:
       If not, SPI CLKOUT frequency will not be accurate.
     maximum: 20000000
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
@@ -138,11 +143,12 @@ patternProperties:
 
       st,adc-alt-channel:
         description:
-          Must be defined if two sigma delta modulators are
-          connected on same SPI input.
-          If not set, channel n is connected to SPI input n.
-          If set, channel n is connected to SPI input n + 1.
-        type: boolean
+          Must be defined if two sigma delta modulators are connected on same SPI input.
+          - If set to 0 channel n is connected to SPI input n.
+          - If set to 1 channel n is connected to SPI input n + 1.
+        items:
+          enum: [ 0, 1 ]
+        $ref: /schemas/types.yaml#/definitions/uint32-array
 
       st,filter0-sync:
         description:
@@ -242,6 +248,10 @@ patternProperties:
                     From common IIO binding. Used to pipe external sigma delta
                     modulator or internal ADC output to DFSDM channel.
 
+                port:
+                  $ref: audio-graph-port.yaml#
+                  unevaluatedProperties: false
+
               required:
                 - compatible
                 - "#sound-dai-cells"
diff --git a/Documentation/devicetree/bindings/iio/adc/st,stm32-mdf-adc.yaml b/Documentation/devicetree/bindings/iio/adc/st,stm32-mdf-adc.yaml
new file mode 100644
index 000000000..c95efe3ff
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/adc/st,stm32-mdf-adc.yaml
@@ -0,0 +1,354 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/iio/adc/st,stm32-mdf-adc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 Multi-function Digital Filter (MDF) ADC
+
+maintainers:
+  - Olivier Moysan <olivier.moysan@foss.st.com>
+
+description: |
+  STM32 MDF ADC is a sigma delta analog-to-digital converter dedicated to
+  interface external sigma delta modulators to STM32 micro controllers.
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp25-mdf
+
+  reg:
+    minItems: 1
+    maxItems: 2
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    description: Internal clock used for MDF digital processing.
+    items:
+      - const: ker_ck
+
+  "#clock-cells":
+    enum: [0, 1]
+
+  clock-output-names:
+    description: |
+      CCK0 and CCK1 are optional output clocks, which share the same clock frequency,
+      but can be gated independently to save power.
+    minItems: 1
+    items:
+      - const: cck0
+      - const: cck1
+
+  clock-frequency:
+    description: |
+      Common clock frequency (Hz) for CCK0 and CCK1 output clocks.
+      The frequency must be a multiple of the "ker_ck" clock frequency.
+    maximum: 25000000
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 1
+
+  ranges: true
+
+  clock-ranges: true
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    items:
+      - const: mdf
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  power-domains:
+    maxItems: 1
+
+  st,interleave:
+    description: |
+      List of phandles of interleaved filters. The indexes of interleaved filters must be
+      consecutives starting from 0 (i.e in range [0..N]). The samples from interleaved filters
+      are muxed in a single channel and retrieved through the device associated to the filter 0.
+      The filters 1..N have to be enabled, but inherit their configuration from filter 0.
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+
+required:
+  - compatible
+  - reg
+  - ranges
+  - clocks
+  - clock-names
+  - clock-ranges
+  - "#address-cells"
+  - "#size-cells"
+
+additionalProperties: false
+
+patternProperties:
+  "^sitf@[0-9]+$":
+    type: object
+    description: Serial interface child node
+
+    properties:
+      compatible:
+        enum:
+          - st,stm32mp25-sitf-mdf
+
+      reg:
+        description: Specify the SITF serial interface instance
+        maxItems: 1
+
+      clocks:
+        description: |
+          Serial interface clock (optional depending on interface mode)
+        maxItems: 1
+
+      st,sitf-mode:
+        description: |
+          Select serial interface protocol
+          - spi: SPI mode
+          - lf_spi: low frequency SPI mode for low power applications
+        $ref: "/schemas/types.yaml#/definitions/string"
+        enum:
+          - spi
+          - lf_spi
+
+        required:
+          - reg
+          - st,sitf-mode
+
+    additionalProperties: false
+
+  "^filter@[0-9]+$":
+    type: object
+    description: Digital filter path child node
+
+    properties:
+      compatible:
+        enum:
+          - st,stm32mp25-mdf-dmic
+          - st,stm32mp25-mdf-adc
+
+      reg:
+        description: Specify the MDF filter instance
+        maxItems: 1
+
+      interrupts:
+        maxItems: 1
+
+      clocks:
+        minItems: 1
+        description: Internal clock used for MDF digital processing and control blocks.
+
+      clock-names:
+        items:
+          - const: ker_ck
+
+      dmas:
+        maxItems: 1
+
+      dma-names:
+        items:
+          - const: rx
+
+      "#io-channel-cells":
+        const: 1
+
+      st,cic-mode:
+        description: |
+          Cascaded-integrator-comb (CIC) filter configuration
+          - 0: MCIC & ACIC filters in FastSinc mode
+          - [1-3]: MCIC & ACIC filters in Sinc mode order 1 to 3
+          - [4-5]: Single CIC filter in Sinc mode order 4 to 5
+          For audio purpose it is recommended to use CIC Sinc4 or Sinc5
+          This property is mandatory for filter 0 or filters not used in interleave mode.
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 5
+
+      st,rs-filter-bypass:
+        description: Bypass RSFLT reshaping filter.
+        $ref: /schemas/types.yaml#/definitions/flag
+
+      st,hpf-filter-cutoff-bp:
+        description: |
+          High Pass Filter (HPF) cut-off frequency expressed as a fraction of the PCM sampling rate.
+          Cut-off frequency = st,hpf-filter-cutoff-bp x Fpcm / 100.
+          If this property is not defined the HPF is disabled.
+        enum: [625, 1250, 2500, 9500]
+
+      st,sync:
+        description:
+          Synchronize to another filter.
+          Must contain the phandle of the filter providing the synchronization.
+        allOf:
+          - $ref: /schemas/types.yaml#/definitions/phandle-array
+          - maxItems: 1
+
+      st,sitf:
+        $ref: /schemas/types.yaml#/definitions/phandle-array
+        items:
+          - items:
+              - description: Phandle of the serial interface connected to the digital filter
+              - description: |
+                  The phandle's argument selects the bitstream on the falling or rising edge
+                  of the serial interface clock:
+                  - 0: rising edge
+                  - 1: falling edge
+                enum: [0, 1]
+                default: 0
+        description:
+          Should be phandle/bitstream pair.
+
+    required:
+      - compatible
+      - reg
+      - interrupts
+      - "#io-channel-cells"
+      - st,sitf
+
+    allOf:
+      - if:
+          properties:
+            compatible:
+              contains:
+                const: st,stm32mp25-mdf-adc
+
+        then:
+          properties:
+            '#address-cells':
+              const: 1
+
+            '#size-cells':
+              const: 0
+
+          required:
+            - '#address-cells'
+            - '#size-cells'
+
+          patternProperties:
+            "^channel@([0-9])$":
+              type: object
+              $ref: "adc.yaml"
+              description: Represents the external channel which is connected to the MDF.
+
+              properties:
+                reg:
+                  maxItems: 1
+                  items:
+                    minimum: 0
+                    maximum: 8
+
+              required:
+                - reg
+
+              additionalProperties: false
+
+      - if:
+          properties:
+            compatible:
+              contains:
+                const: st,stm32mp25-mdf-dmic
+
+        then:
+          patternProperties:
+            "^mdf-dai+$":
+              type: object
+              description: child node
+
+              properties:
+                compatible:
+                  enum:
+                    - st,stm32mp25-mdf-dai
+
+                "#sound-dai-cells":
+                  const: 0
+
+                io-channels:
+                  description:
+                    From common IIO binding. Used to pipe external sigma delta
+                    modulator or internal ADC output to MDF channel.
+
+                power-domains:
+                  maxItems: 1
+
+                port:
+                  $ref: /schemas/sound/audio-graph-port.yaml#
+                  unevaluatedProperties: false
+
+              required:
+                - compatible
+                - "#sound-dai-cells"
+                - io-channels
+
+              additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    mdf1: mdf@504d0000 {
+      compatible = "st,stm32mp25-mdf";
+      ranges = <0 0x504d0000 0x1000>;
+      reg = <0x504d0000 0x8>, <0x504d0ff0 0x10>;
+      #address-cells = <1>;
+      #size-cells = <1>;
+      clocks = <&rcc CK_KER_MDF1>;
+      clock-names = "ker_ck";
+      clock-ranges;
+      #clock-cells = <1>;
+      clock-output-names = "cck0", "cck1";
+      clock-frequency = <2048000>;
+
+      sitf5: sitf@300 {
+        compatible = "st,stm32mp25-sitf-mdf";
+        reg = <0x300 0x4>;
+        st,sitf-mode = "spi";
+        clocks = <&mdf1 0>;
+      };
+
+      filter0: filter@84 {
+        compatible = "st,stm32mp25-mdf-dmic";
+        reg = <0x84 0x70>;
+        #io-channel-cells = <1>;
+        interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&hpdma 63 0x63 0x12 0>;
+        dma-names = "rx";
+        st,cic-mode	= <5>;
+        st,sitf = <&sitf5 0>;
+
+        asoc_pdm0: mdf-dai {
+          compatible = "st,stm32mp25-mdf-dai";
+          #sound-dai-cells = <0>;
+          io-channels = <&filter0 0>;
+        };
+      };
+
+      filter1: filter@104  {
+        compatible = "st,stm32mp25-mdf-adc";
+        reg = <0x104 0x70>;
+        #io-channel-cells = <1>;
+        interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&hpdma 64 0x63 0x12 0>;
+        dma-names = "rx";
+        st,cic-mode = <2>;
+        st,sitf = <&sitf5 1>;
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        channel@1 {
+          reg = <1>;
+        };
+      };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/iio/dac/st,stm32-dac.yaml b/Documentation/devicetree/bindings/iio/dac/st,stm32-dac.yaml
index 6adeda408..0aeaa3083 100644
--- a/Documentation/devicetree/bindings/iio/dac/st,stm32-dac.yaml
+++ b/Documentation/devicetree/bindings/iio/dac/st,stm32-dac.yaml
@@ -45,6 +45,11 @@ properties:
   '#size-cells':
     const: 0
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 additionalProperties: false
 
 required:
diff --git a/Documentation/devicetree/bindings/interrupt-controller/rpmsg,intc.yaml b/Documentation/devicetree/bindings/interrupt-controller/rpmsg,intc.yaml
new file mode 100644
index 000000000..59c3e83df
--- /dev/null
+++ b/Documentation/devicetree/bindings/interrupt-controller/rpmsg,intc.yaml
@@ -0,0 +1,39 @@
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
+# Copyright (c) 2023 STMicroelectronics.
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/interrupt-controller/rpmsg,intc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: RPMSG Interrupt controller
+
+maintainers:
+  - Arnaud Pouliquen <arnaud.pouliquen@foss.st.com>
+
+allOf:
+  - $ref: /schemas/interrupt-controller.yaml#
+
+description:
+  RPMsg interrupt controller for interprocessor communication based on interrupt signaling
+
+properties:
+  compatible:
+    const: rpmsg,intc
+
+  '#interrupt-cells':
+    const: 1
+
+  interrupt-controller: true
+
+required:
+  - compatible
+  - '#interrupt-cells'
+  - interrupt-controller
+
+examples:
+  - |
+    intc_rpmsg: interrupt-controller {
+        compatible = "rpmsg,intc";
+        #interrupt-cells = <1>;
+        interrupt-controller;
+    };
diff --git a/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml b/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml
index 00c10a825..b4bc1d413 100644
--- a/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml
+++ b/Documentation/devicetree/bindings/interrupt-controller/st,stm32-exti.yaml
@@ -12,16 +12,21 @@ maintainers:
 
 properties:
   compatible:
+    description:
+      Legacy syscon is allowed for backward compatibility with old devicetree.
+      Don't use it on new devicetree.
     oneOf:
       - items:
           - enum:
               - st,stm32-exti
               - st,stm32h7-exti
+              - st,stm32mp1-exti
       - items:
           - enum:
               - st,stm32mp1-exti
               - st,stm32mp13-exti
           - const: syscon
+        deprecated: true
 
   "#interrupt-cells":
     const: 2
@@ -42,6 +47,8 @@ properties:
     description:
       Interrupts references to primary interrupt controller
 
+  wakeup-parent: true
+
 required:
   - "#interrupt-cells"
   - compatible
@@ -83,14 +90,31 @@ examples:
   - |
     //Example 1
     exti1: interrupt-controller@5000d000 {
-        compatible = "st,stm32mp1-exti", "syscon";
+        compatible = "st,stm32mp1-exti";
         interrupt-controller;
         #interrupt-cells = <2>;
         reg = <0x5000d000 0x400>;
     };
 
+  - |
     //Example 2
-    exti2: interrupt-controller@40013c00 {
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    exti2: interrupt-controller@5000d000 {
+        compatible = "st,stm32mp1-exti";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+        reg = <0x5000d000 0x400>;
+        wakeup-parent = <&pwr_irq>;
+        interrupts-extended =
+            <&intc GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>,
+            <0>,
+            <&pwr_irq 0 IRQ_TYPE_EDGE_FALLING 0>,
+            <&intc GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+    };
+
+  - |
+    //Example 3
+    exti3: interrupt-controller@40013c00 {
         compatible = "st,stm32-exti";
         interrupt-controller;
         #interrupt-cells = <2>;
diff --git a/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml b/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml
index 3300451fc..f27ec28cd 100644
--- a/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml
+++ b/Documentation/devicetree/bindings/leds/backlight/gpio-backlight.yaml
@@ -23,6 +23,15 @@ properties:
     description: enable the backlight at boot.
     type: boolean
 
+  default-brightness-level:
+    description:
+      The default brightness level (index into the array defined by the
+      "brightness-levels" property).
+    $ref: /schemas/types.yaml#/definitions/uint32
+
+dependencies:
+  default-brightness-level: [brightness-levels]
+
 required:
   - compatible
   - gpios
diff --git a/Documentation/devicetree/bindings/mailbox/st,stm32-ipcc.yaml b/Documentation/devicetree/bindings/mailbox/st,stm32-ipcc.yaml
index 2c8b47285..2ea07e8f8 100644
--- a/Documentation/devicetree/bindings/mailbox/st,stm32-ipcc.yaml
+++ b/Documentation/devicetree/bindings/mailbox/st,stm32-ipcc.yaml
@@ -11,6 +11,8 @@ description:
   retrieve messages in an atomic way between two processors.
   It provides the signaling for N bidirectionnal channels. The number of
   channels (N) can be read from a dedicated register.
+  Depending on the DT channel parameter, the client can choice between be called under interrupt
+  normal or context.
 
 maintainers:
   - Fabien Dessenne <fabien.dessenne@foss.st.com>
@@ -59,6 +61,7 @@ additionalProperties: false
 
 examples:
   - |
+
     #include <dt-bindings/interrupt-controller/arm-gic.h>
     #include <dt-bindings/clock/stm32mp1-clks.h>
     ipcc: mailbox@4c001000 {
@@ -73,4 +76,16 @@ examples:
       wakeup-source;
     };
 
-...
+    /*The client 1 uses the mailbox channel 0 and 1 in normal context */
+    mbox_clt1 {
+      mboxes = <&ipcc 0x0>, <&ipcc 1>;
+    };
+
+    /*
+     * The Client 2 uses mailbox channel 2 and 3 in interrupt context
+     * (add 0x100 to the channel value).
+     */
+
+    mbox_clt2 {
+      mboxes = <&ipcc 0x102>, <&ipcc 103>;
+    };
diff --git a/Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml b/Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
new file mode 100644
index 000000000..af07250ce
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
@@ -0,0 +1,115 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/i2c/galaxycore,gc2145.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Galaxy Core 1/5'' UXGA CMOS Image Sensor
+
+maintainers:
+  - Alain Volmat <alain.volmat@foss.st.com>
+
+description: |
+  The Galaxy Core GC2145 is a high quality 2 Mega CMOS image sensor, for mobile phone camera
+  applications and digital camera products. GC2145 incorporates a 1616V x 1232H active pixel
+  array, on-chip 10-bit ADC, and image signal processor. It is programmable through an I2C
+  interface. Image data is sent either through a parallel interface or through MIPI CSI-2.
+
+allOf:
+  - $ref: ../video-interface-devices.yaml#
+
+properties:
+  compatible:
+    const: galaxycore,gc2145
+
+  reg:
+    enum:
+      - 0x3c
+
+  clocks:
+    description: Reference to the xclk clock.
+    maxItems: 1
+
+  powerdown-gpios:
+    description: GPIO descriptor for the powerdown pin.
+    maxItems: 1
+
+  reset-gpios:
+    description: GPIO descriptor for the reset pin.
+    maxItems: 1
+
+  IOVDD-supply:
+    description: Power Supply for I/O circuits (1.7 - 3V).
+
+  AVDD-supply:
+    description: Power for analog circuit/sensor array (2.7 - 3V).
+
+  DVDD-supply:
+    description: Power for digital core (1.7 - 1.9V).
+
+  port:
+    $ref: /schemas/graph.yaml#/$defs/port-base
+    description: |
+      Video output port.
+
+    properties:
+      endpoint:
+        $ref: /schemas/media/video-interfaces.yaml#
+        unevaluatedProperties: false
+
+        properties:
+          data-lanes:
+            anyOf:
+              - items:
+                  - const: 1
+                  - const: 2
+              - items:
+                  - const: 1
+                  - const: 2
+
+        required:
+          - data-lanes
+
+    additionalProperties: false
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - powerdown-gpios
+  - reset-gpios
+  - IOVDD-supply
+  - AVDD-supply
+  - DVDD-supply
+  - port
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+
+    i2c5 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        gc2145@3c {
+            compatible = "galaxycore,gc2145";
+            reg = <0x3c>;
+            clocks = <&clk_ext_camera>;
+            IOVDD-supply = <&scmi_v3v3_sw>;
+            AVDD-supply = <&scmi_v3v3_sw>;
+            DVDD-supply = <&scmi_v3v3_sw>;
+            powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+            reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+            port {
+                gc2145_ep: endpoint {
+                    remote-endpoint = <&mipid02_0>;
+                    data-lanes = <1 2>;
+                };
+            };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/media/st,stm32-cec.yaml b/Documentation/devicetree/bindings/media/st,stm32-cec.yaml
index 77144cc6f..0a30de5f7 100644
--- a/Documentation/devicetree/bindings/media/st,stm32-cec.yaml
+++ b/Documentation/devicetree/bindings/media/st,stm32-cec.yaml
@@ -29,6 +29,11 @@ properties:
       - const: cec
       - const: hdmi-cec
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml b/Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
new file mode 100644
index 000000000..6a01554ef
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
@@ -0,0 +1,122 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/st,stm32-csi2host.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 CSI2HOST
+
+maintainers:
+  - Alain Volmat <alain.volmat@foss.st.com>
+
+properties:
+  compatible:
+    enum:
+      - st,stm32-csi2host
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 3
+
+  clock-names:
+    items:
+      - const: pclk
+      - const: txesc
+      - const: csi2phy
+
+  resets:
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/$defs/port-base
+        unevaluatedProperties: false
+        description:
+          Input port node
+
+        properties:
+          endpoint:
+            $ref: video-interfaces.yaml#
+            unevaluatedProperties: false
+
+            properties:
+              data-lanes:
+                description:
+                  Indicate the number of data-lanes and their mapping.
+
+                items:
+                  minItems: 1
+                  items:
+                    - const: 1
+                    - const: 2
+
+            required:
+              - data-lanes
+
+      port@1:
+        $ref: /schemas/graph.yaml#/properties/port
+        description:
+          Output port node
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - resets
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    csi2host: csi2host@48020000 {
+        compatible = "st,stm32-csi2host";
+        reg = <0x48020000 0x2000>;
+        interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+        resets = <&rcc CSI_R>;
+        clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>, <&rcc CK_KER_CSIPHY>;
+        clock-names = "pclk", "txesc", "csi2phy";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            port@0 {
+                reg = <0>;
+                csi2host_sink: endpoint {
+                    remote-endpoint = <&imx219_ep>;
+                    data-lanes = <0 1>;
+                    bus-type = <4>;
+                };
+            };
+
+            port@1 {
+                reg = <1>;
+                csi2host_source: endpoint {
+                    remote-endpoint = <&dcmipp_0>;
+                };
+            };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/media/st,stm32-dcmi.yaml b/Documentation/devicetree/bindings/media/st,stm32-dcmi.yaml
index 9c1262a27..60138c2b3 100644
--- a/Documentation/devicetree/bindings/media/st,stm32-dcmi.yaml
+++ b/Documentation/devicetree/bindings/media/st,stm32-dcmi.yaml
@@ -4,7 +4,7 @@
 $id: http://devicetree.org/schemas/media/st,stm32-dcmi.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
-title: STMicroelectronics STM32 Digital Camera Memory Interface (DCMI) binding
+title: STMicroelectronics STM32 Digital Camera Memory Interface (DCMI)
 
 maintainers:
   - Hugues Fruchet <hugues.fruchet@foss.st.com>
@@ -27,15 +27,34 @@ properties:
       - const: mclk
 
   dmas:
-    maxItems: 1
+    minItems: 1
+    maxItems: 2
 
   dma-names:
     items:
       - const: tx
+      - const: mdma-tx
+    minItems: 1
 
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
+  sram:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description:
+      phandles to a reserved SRAM region which is used as temporary
+      storage memory between DMA and MDMA engines.
+      The region should be defined as child nodes of the AHB SRAM node
+      as per the generic bindings in Documentation/devicetree/bindings/sram/sram.yaml
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
   port:
     $ref: /schemas/graph.yaml#/$defs/port-base
     unevaluatedProperties: false
diff --git a/Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml b/Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
new file mode 100644
index 000000000..81e17bcf2
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
@@ -0,0 +1,135 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/st,stm32-dcmipp.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 DCMIPP Digital Camera Memory Interface Pixel Processor
+
+maintainers:
+  - Hugues Fruchet <hugues.fruchet@foss.st.com>
+  - Alain Volmat <alain.volmat@foss.st.com>
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp13-dcmipp
+      - st,stm32mp25-dcmipp
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    minItems: 1
+    maxItems: 2
+
+  clock-names:
+    items:
+      - const: kclk
+      - const: mclk
+    minItems: 1
+
+  resets:
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  port:
+    $ref: /schemas/graph.yaml#/$defs/port-base
+    unevaluatedProperties: false
+    description:
+      DCMIPP supports a single port node with parallel bus.
+
+    properties:
+      endpoint:
+        $ref: video-interfaces.yaml#
+        unevaluatedProperties: false
+
+        properties:
+          bus-type:
+            enum: [4, 5, 6]
+            default: 5
+
+          bus-width:
+            enum: [8, 10, 12, 14]
+            default: 8
+
+          pclk-sample: true
+          hsync-active: true
+          vsync-active: true
+
+          pclk-max-frequency:
+            description:
+              Maximum acceptable pixel clock frequency.
+
+        required:
+          - pclk-sample
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - resets
+  - port
+
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp13-dcmipp
+    then:
+      properties:
+        clocks:
+          maxItems: 1
+
+        clock-names:
+          items:
+            - const: kclk
+
+        port:
+          properties:
+            endpoint:
+              properties:
+                bus-type:
+                  enum: [5, 6]
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp13-clks.h>
+    #include <dt-bindings/reset/stm32mp13-resets.h>
+    dcmipp: dcmipp@5a000000 {
+        compatible = "st,stm32mp13-dcmipp";
+        reg = <0x5a000000 0x400>;
+        interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+        resets = <&rcc DCMIPP_R>;
+        clocks = <&rcc DCMIPP_K>;
+        clock-names = "kclk";
+
+        port {
+             dcmipp_0: endpoint {
+                   remote-endpoint = <&mipid02_2>;
+                   bus-width = <8>;
+                   hsync-active = <0>;
+                   vsync-active = <0>;
+                   pclk-sample = <0>;
+                   pclk-max-frequency = <120000000>;
+             };
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml b/Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml
new file mode 100644
index 000000000..917bbcc57
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32mp25-vdec.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/st,stm32mp25-vdec.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32MP25 VDEC video decoder
+
+maintainers:
+  - Hugues Fruchet <hugues.fruchet@foss.st.com>
+
+description:
+  The STMicroelectronics STM32MP25 SOCs embeds a VDEC video hardware decoder
+  peripheral based on Verisilicon VC8000NanoD IP (former Hantro G1).
+
+properties:
+  compatible:
+    const: st,stm32mp25-vdec
+
+  reg:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  interrupt-names:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+required:
+  - compatible
+  - reg
+  - resets
+  - interrupts
+  - interrupt-names
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    vdec: vdec@580d0000 {
+        compatible = "st,stm32mp25-vdec";
+        reg = <0x580d0000 0x3c8>;
+        resets = <&rcc VDEC_R>;
+        interrupt-names = "vdec";
+        interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+        clock-names = "vdec-clk";
+        clocks = <&rcc CK_BUS_VDEC>;
+    };
diff --git a/Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml b/Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml
new file mode 100644
index 000000000..13e5df17c
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,stm32mp25-venc.yaml
@@ -0,0 +1,71 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/media/st,stm32mp25-venc.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32MP25 VENC video encoder
+
+maintainers:
+  - Hugues Fruchet <hugues.fruchet@foss.st.com>
+
+description:
+  The STMicroelectronics STM32MP25 SOCs embeds a VENC video hardware encoder
+  peripheral based on Verisilicon VC8000NanoE IP (former Hantro H1).
+
+properties:
+  compatible:
+    const: st,stm32mp25-venc
+
+  reg:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  interrupt-names:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  clock-names:
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+required:
+  - compatible
+  - reg
+  - resets
+  - interrupts
+  - interrupt-names
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    venc: venc@580e0000 {
+        compatible = "st,stm32mp25-venc";
+        reg = <0x580e0000 0x800>;
+        resets = <&rcc VENC_R>;
+        interrupt-names = "venc";
+        interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+        clock-names = "venc-clk";
+        clocks = <&rcc CK_BUS_VENC>;
+    };
diff --git a/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml b/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml
index 6b516d389..3125bc193 100644
--- a/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml
+++ b/Documentation/devicetree/bindings/memory-controllers/st,stm32-fmc2-ebi.yaml
@@ -23,7 +23,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32mp1-fmc2-ebi
+    enum:
+      - st,stm32mp1-fmc2-ebi
+      - st,stm32mp25-fmc2-ebi
 
   reg:
     maxItems: 1
@@ -34,6 +36,9 @@ properties:
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   "#address-cells":
     const: 2
 
@@ -45,6 +50,11 @@ properties:
       Reflects the memory layout with four integer values per bank. Format:
       <bank-number> 0 <address of the bank> <size>
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 patternProperties:
   "^.*@[0-4],[a-f0-9]+$":
     type: object
diff --git a/Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml b/Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml
new file mode 100644
index 000000000..154bb1448
--- /dev/null
+++ b/Documentation/devicetree/bindings/memory-controllers/st,stm32-omi.yaml
@@ -0,0 +1,244 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/memory-controllers/st,stm32-omi.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 OSPI Memory Interface (OMI)
+
+maintainers:
+  - Patrice Chotard <patrice.chotard@foss.st.com>
+
+description: |
+  STM32 OSPI Memory Interface allows a SPI flash or HyperFlash connected to
+  the SoC to be accessed via the external address space.
+
+  The flash chip itself should be represented by a subnode of the STM32 OSPI
+  Memory Interface node. The flash interface is selected based on the
+  "compatible" property of this subnode:
+  - if it contains "jedec,spi-nor", then SPI is used;
+  - if it contains "spi-nand", then SPI is used.
+  - if it contains "cfi-flash", then HyperFlash is used.
+
+properties:
+  compatible:
+    items:
+      - const: st,stm32mp25-omi
+
+  reg:
+    description: registers
+
+  "#address-cells":
+    enum: [1, 2]
+
+  "#size-cells":
+    enum: [0, 1]
+
+  memory-region:
+    description: Phandle to a node describing memory-map region to be used
+
+  clocks:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  resets:
+    maxItems: 2
+
+  dmas:
+    description: tx and rx DMA channel
+    minItems: 1
+    maxItems: 2
+
+  dma-names:
+    items:
+      enum: [tx, rx]
+    minItems: 1
+    maxItems: 2
+
+  st,syscfg-dlyb:
+    description: |
+      Use to set the OSPI delay block within SYSCFG to:
+        Tune the phase of the RX sampling clock (or DQS) in order
+        to sample the data in their valid window.
+        Tune the phase of the TX launch clock in order to meet setup
+        and hold constraints of TX signals versus the memory clock.
+    $ref: "/schemas/types.yaml#/definitions/phandle-array"
+    items:
+      minItems: 2
+      maxItems: 2
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  power-domains:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - "#address-cells"
+  - "#size-cells"
+  - clocks
+  - interrupts
+  - st,syscfg-dlyb
+
+patternProperties:
+  "flash@[0-9a-f]+$":
+    type: object
+    properties:
+      compatible:
+        oneOf:
+          - items:
+              - enum:
+                  - cypress,hyperflash
+              - const: cfi-flash
+          - enum:
+              - jedec,spi-nor
+              - spi-nand
+              - st,octal-bus
+
+    allOf:
+      - if:
+          properties:
+            compatible:
+              enum:
+                - jedec,spi-nor
+                - spi-nand
+                - st,octal-bus
+
+        then:
+          $ref: "/schemas/spi/spi-controller.yaml#"
+
+      - if:
+          properties:
+            compatible:
+              contains:
+                enum:
+                  - cfi-flash
+
+        then:
+          $ref: "/schemas/mtd/mtd-physmap.yaml#"
+
+          properties:
+            st,max-frequency:
+              $ref: /schemas/types.yaml#/definitions/uint32
+              description:
+                Maximum clocking speed of the device in Hz.
+
+            st,tacc-ns:
+              description:
+                Device initial access time.
+
+            st,wzl:
+              $ref: /schemas/types.yaml#/definitions/flag
+              description:
+                Enable write zero latency
+
+          required:
+            - st,max-frequency
+
+      - if:
+          properties:
+            compatible:
+              contains:
+                enum:
+                  - st,octal-bus
+
+        then:
+          required:
+            - spi-max-frequency
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/bus/stm32mp25_sys_bus.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    spi@40430000 {
+      compatible = "st,stm32mp25-omi";
+      reg = <0x40430000 0x400>;
+      memory-region = <&mm_ospi1>;
+      interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+      dmas = <&hpdma 2 0x62 0x00003121 0x0>,
+             <&hpdma 2 0x42 0x00003112 0x0>;
+      dma-names = "tx", "rx";
+      st,syscfg-dlyb = <&syscfg 0x1000>;
+      clocks = <&scmi_clk CK_SCMI_OSPI1>;
+      resets = <&scmi_reset RST_SCMI_OSPI1DLL>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+      feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI1_ID>;
+      power-domains = <&CLUSTER_PD>;
+
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      flash@0 {
+        compatible = "jedec,spi-nor";
+        reg = <0>;
+        spi-rx-bus-width = <4>;
+        spi-max-frequency = <108000000>;
+      };
+    };
+
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/bus/stm32mp25_sys_bus.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    memory-controller@40430000 {
+      compatible = "st,stm32mp25-omi";
+      reg = <0x40430000 0x400>;
+      memory-region = <&mm_ospi1>;
+      interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+      dmas = <&hpdma 2 0x42 0x00003013 0x0>;
+      dma-names = "rx";
+      st,syscfg-dlyb = <&syscfg 0x1000>;
+      clocks = <&scmi_clk CK_SCMI_OSPI1>;
+      resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+      feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI1_ID>;
+      power-domains = <&CLUSTER_PD>;
+
+      #address-cells = <2>;
+      #size-cells = <1>;
+
+      flash@0 {
+        compatible = "cypress,hyperflash", "cfi-flash";
+        reg = <0x2 0x0 0x4000000>;
+        st,max-frequency = <100000000>;
+        st,tacc-ns = <48>;
+      };
+    };
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/bus/stm32mp25_sys_bus.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+    memory-controller@40430000 {
+      compatible = "st,stm32mp25-omi";
+      reg = <0x40430000 0x400>;
+      memory-region = <&mm_ospi1>;
+      interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+      dmas = <&hpdma 2 0x62 0x00003121 0x0>,
+             <&hpdma 2 0x42 0x00003112 0x0>;
+      dma-names = "tx", "rx";
+      st,syscfg-dlyb = <&syscfg 0x1000>;
+      clocks = <&scmi_clk CK_SCMI_OSPI1>;
+      resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+      feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI1_ID>;
+      power-domains = <&CLUSTER_PD>;
+      cs-gpios = <&gpiod 1 GPIO_ACTIVE_LOW>;
+
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      flash@0 {
+        compatible = "st,octal-bus";
+        reg = <0>;
+        spi-max-frequency = <50000000>;
+      };
+    };
diff --git a/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml b/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml
index d950dd5d4..a4a5dc785 100644
--- a/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml
+++ b/Documentation/devicetree/bindings/mfd/st,stm32-lptimer.yaml
@@ -21,7 +21,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32-lptimer
+    enum:
+      - st,stm32-lptimer
+      - st,stm32mp25-lptimer
 
   reg:
     maxItems: 1
@@ -44,13 +46,23 @@ properties:
 
   wakeup-source: true
 
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
   pwm:
     type: object
     additionalProperties: false
 
     properties:
       compatible:
-        const: st,stm32-pwm-lp
+        enum:
+          - st,stm32-pwm-lp
+          - st,stm32mp25-pwm-lp
 
       "#pwm-cells":
         const: 3
@@ -65,7 +77,9 @@ properties:
 
     properties:
       compatible:
-        const: st,stm32-lptimer-counter
+        enum:
+          - st,stm32-lptimer-counter
+          - st,stm32mp25-lptimer-counter
 
     required:
       - compatible
@@ -76,7 +90,9 @@ properties:
 
     properties:
       compatible:
-        const: st,stm32-lptimer-timer
+        enum:
+          - st,stm32-lptimer-timer
+          - st,stm32mp25-lptimer-timer
 
     required:
       - compatible
@@ -88,7 +104,9 @@ patternProperties:
 
     properties:
       compatible:
-        const: st,stm32-lptimer-trigger
+        enum:
+          - st,stm32-lptimer-trigger
+          - st,stm32mp25-lptimer-trigger
 
       reg:
         description: Identify trigger hardware block.
diff --git a/Documentation/devicetree/bindings/mfd/st,stm32-timers.yaml b/Documentation/devicetree/bindings/mfd/st,stm32-timers.yaml
index e2c3c3b44..3994c8b3b 100644
--- a/Documentation/devicetree/bindings/mfd/st,stm32-timers.yaml
+++ b/Documentation/devicetree/bindings/mfd/st,stm32-timers.yaml
@@ -21,7 +21,9 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32-timers
+    enum:
+      - st,stm32-timers
+      - st,stm32mp25-timers
 
   reg:
     maxItems: 1
@@ -36,6 +38,9 @@ properties:
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   dmas:
     minItems: 1
     maxItems: 7
@@ -67,13 +72,20 @@ properties:
   "#size-cells":
     const: 0
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
   pwm:
     type: object
     additionalProperties: false
 
     properties:
       compatible:
-        const: st,stm32-pwm
+        enum:
+          - st,stm32-pwm
+          - st,stm32mp25-pwm
 
       "#pwm-cells":
         const: 3
@@ -109,7 +121,9 @@ properties:
 
     properties:
       compatible:
-        const: st,stm32-timer-counter
+        enum:
+          - st,stm32-timer-counter
+          - st,stm32mp25-timer-counter
 
     required:
       - compatible
@@ -124,6 +138,7 @@ patternProperties:
         enum:
           - st,stm32-timer-trigger
           - st,stm32h7-timer-trigger
+          - st,stm32mp25-timer-trigger
 
       reg:
         description: Identify trigger hardware block.
diff --git a/Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt b/Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt
new file mode 100644
index 000000000..b5f414a19
--- /dev/null
+++ b/Documentation/devicetree/bindings/mfd/st,stm32mp1-pwr.txt
@@ -0,0 +1,57 @@
+STMicroelectronics STM32MP1 Power Management Controller
+=======================================================
+
+The PWR IP is responsible for handling the power related resources such as
+clocks, power supplies and resets. It provides 6 wake-up pins that are handled
+by an interrupt-controller. Wake-up pin can be used to wake-up from STANDBY SoC state.
+
+Required properties:
+- compatible should be: "st,stm32mp1-pwr"
+- reg: should be register base and length as documented in the
+  datasheet
+- interrupts: contains the reference to the gic wake-up pin interrupt
+- interrupt-controller; Enable interrupt controller for wake-up pins.
+- #interrupt-cells = <3>
+- st,wakeup-pins: contains a list of GPIO spec describing each wake-up pin.
+
+Optional Properties:
+- pwr-supply: main soc power supply
+
+Interrupt consumers have to specify 3 cells:
+  - cell 1: wake-up pin id from 0 to 5
+  - cell 2: IRQ_TYPE_EDGE_FALLING or IRQ_TYPE_EDGE_RISING
+  - cell 3: Pull config: 0 = No Pull, 1=Pull Up, 2=Pull Down
+
+
+Example:
+
+	pwr: pwr@50001000 {
+		compatible = "st,stm32mp1-pwr", "simple-mfd";
+		reg = <0x50001000 0x400>;
+		interrupts = <GIC_SPI 149 IRQ_TYPE_NONE>;
+		interrupt-controller;
+		#interrupt-cells = <3>;
+
+		st,wakeup-pins = <&gpioa 0 0>, <&gpioa 2 0>,
+				 <&gpioc 13 0>, <&gpioi 8 0>,
+				 <&gpioi 11 0>, <&gpioc 1 0>;
+
+		pwr-supply = <&vdd>;
+	};
+
+
+Example of interrupt user:
+gpio_keys {
+	compatible = "gpio-keys";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	button@4 {
+		label = "WakeUp4";
+		linux,code = <BTN_4>;
+		interrupt-parent = <&pwr>;
+		interrupts = <3 IRQ_TYPE_EDGE_FALLING 1>;
+		wakeup-source;
+	};
+};
+
diff --git a/Documentation/devicetree/bindings/mfd/st,stpmic1.yaml b/Documentation/devicetree/bindings/mfd/st,stpmic1.yaml
index 426658ad8..62e3dfee5 100644
--- a/Documentation/devicetree/bindings/mfd/st,stpmic1.yaml
+++ b/Documentation/devicetree/bindings/mfd/st,stpmic1.yaml
@@ -95,10 +95,10 @@ properties:
         - ldo4 for LDO LDO4
         - ldo5 for LDO LDO5
         - ldo6 for LDO LDO6
-        - vref_ddr for LDO Vref DDR
+        - vref_ddr or vref-ddr for LDO Vref DDR
         - boost for Buck BOOST
-        - pwr_sw1 for VBUS_OTG switch
-        - pwr_sw2 for SW_OUT switch
+        - pwr_sw1 or pwr-sw1 for VBUS_OTG switch
+        - pwr_sw2 or pwr-sw2 for SW_OUT switch
       Switches are fixed voltage regulators with only enable/disable capability.
 
     properties:
@@ -187,7 +187,7 @@ properties:
       "^(buck[1-4]|ldo[1-6]|boost|pwr_sw[1-2])-supply$":
         description: STPMIC1 voltage regulators supplies
 
-      "^(buck[1-4]|ldo[1-6]|boost|vref_ddr|pwr_sw[1-2])$":
+      "^(buck[1-4]|ldo[1-6]|boost|vref_ddr|pwr_sw[1-2]|pwr-sw[1-2])$":
         $ref: ../regulator/regulator.yaml
 
       "^ldo[1-2,5-6]$":
@@ -236,7 +236,7 @@ properties:
 
         additionalProperties: false
 
-      "^pwr_sw[1-2]$":
+      "^pwr_sw[1-2]|pwr-sw[1-2]$":
         type: object
 
         properties:
diff --git a/Documentation/devicetree/bindings/misc/st,stm32-omm.yaml b/Documentation/devicetree/bindings/misc/st,stm32-omm.yaml
new file mode 100644
index 000000000..0560bb508
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/st,stm32-omm.yaml
@@ -0,0 +1,184 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/misc/st,stm32-omm.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 Octo Memory Manager (OMM)
+
+maintainers:
+  - Patrice Chotard <patrice.chotard@foss.st.com>
+
+description: |
+  The STM32 Octo Memory Manager is a low-level interface that enables an
+  efficient OCTOSPI pin assignment with a full I/O matrix (before alternate
+  function map) and multiplex of single/dual/quad/octal SPI interfaces over
+  the same bus.
+
+properties:
+  compatible:
+    const: st,stm32mp25-omm
+
+  "#address-cells":
+    const: 2
+
+  "#size-cells":
+    const: 1
+
+  ranges:
+    description: |
+      Reflects the memory layout with four integer values per bank. Format:
+      <bank-number> 0 <address of the bank> <size>
+
+  reg:
+    items:
+      - description: registers
+      - description: memory mapping
+
+  reg-names:
+    items:
+      - const: omm
+      - const: omm_mm
+
+  memory-region:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to a node describing memory-map region to be used.
+
+  memory-region-names:
+    minItems: 1
+    items:
+      - const: mm_ospi1
+      - const: mm_ospi2
+
+  clocks:
+    items:
+      - description: Octo Memory Manager clock
+
+  resets:
+    items:
+      - description: Octo Memory Manager reset
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  st,syscfg-amcr:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      The Address Mapping Control Register (AMCR) is used to split the 256MB
+      memory map area shared between the 2 OSPI Memory Interface (OMI). The Octo
+      Memory Manager sets the AMCR depending of the memory-region configuration.
+      Format is phandle to syscfg / register offset within syscfg / memory split
+      bitmask.
+    items:
+      minItems: 3
+      maxItems: 3
+
+  st,omm-req2ack-ns:
+    description: |
+      In multiplexed mode (MUXEN = 1), this field defines the time in
+      nanoseconds between two transactions.
+
+  st,omm-cssel-ovr:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description: |
+      Configure the chip select selector override for the 2 OCTOSPIs.
+      The 2 bits mask muxing description is:
+        -bit 0: Chip select selector override setting for OCTOSPI1
+          0x0: the chip select signal from OCTOSPI1 is sent to NCS1
+          0x1: the chip select signal from OCTOSPI1 is sent to NCS2
+        -bit 1: Chip select selector override setting for OCTOSPI2
+          0x0: the chip select signal from OCTOSPI2 is sent to NCS1
+          0x1: the chip select signal from OCTOSPI2 is sent to NCS2
+
+  st,omm-mux:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description: |
+      Configure the muxing between the 2 OCTOSPIs busses and the 2 output ports.
+      The muxing 2 bits mask description is:
+        - 0x0: direct mode, default
+        - 0x1: mux OCTOSPI1 and OCTOSPI2 to port 1
+        - 0x2: swapped mode
+        - 0x3: mux OCTOSPI1 and OCTOSPI2 to port 2
+
+  power-domains:
+    maxItems: 1
+
+patternProperties:
+  "^spi@[a-f0-9]+$":
+    type: object
+    $ref: "/schemas/memory-controllers/st,stm32-omi.yaml#"
+
+  "^memory-controller@[a-f0-9]+$":
+    type: object
+    $ref: "/schemas/memory-controllers/st,stm32-omi.yaml#"
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - st,syscfg-amcr
+  - ranges
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/bus/stm32mp25_sys_bus.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    ommanager@40500000 {
+      #address-cells = <2>;
+      #size-cells = <1>;
+      compatible = "st,stm32mp25-omm";
+      reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+      reg-names = "omm", "omm_mm";
+      memory-region = <&mm_ospi1>, <&mm_ospi2>;
+      memory-region-names = "mm_ospi1", "mm_ospi2";
+      clocks = <&rcc CK_BUS_OSPIIOM>;
+      resets = <&rcc OSPIIOM_R>;
+      st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+      st,omm-req2ack-ns = <0x0>;
+      st,omm-mux = <0x0>;
+      st,omm-cssel-ovr = <0x0>;
+      feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPIM_ID>;
+      power-domains = <&CLUSTER_PD>;
+
+      ranges = <0 0 0x40430000 0x400>,
+               <1 0 0x40440000 0x400>;
+
+      spi@40430000 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        compatible = "st,stm32mp25-omi";
+        reg = <0 0 0x400>;
+        interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&hpdma 2 0x62 0x00003121 0x0>,
+               <&hpdma 2 0x42 0x00003112 0x0>;
+        dma-names = "tx", "rx";
+        st,syscfg-dlyb = <&syscfg 0x1000>;
+        clocks = <&rcc CK_KER_OSPI1>;
+        resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+        feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI1_ID>;
+        power-domains = <&CLUSTER_PD>;
+      };
+
+      memory-controller@40440000 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        compatible = "st,stm32mp25-omi";
+        reg = <1 0 0x400>;
+        interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&hpdma 3 0x62 0x00003121 0x0>,
+               <&hpdma 3 0x42 0x00003112 0x0>;
+        dma-names = "tx", "rx";
+        st,syscfg-dlyb = <&syscfg 0x1400>;
+        clocks = <&rcc CK_KER_OSPI2>;
+        resets = <&rcc OSPI2_R>, <&rcc OSPI2DLL_R>;
+        feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI2_ID>;
+        power-domains = <&CLUSTER_PD>;
+      };
+    };
diff --git a/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml b/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml
index 1e69a5a42..7777680d9 100644
--- a/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml
+++ b/Documentation/devicetree/bindings/mmc/arm,pl18x.yaml
@@ -59,6 +59,12 @@ properties:
           - const: st,stm32-sdmmc2
           - const: arm,pl18x
           - const: arm,primecell
+      - description: Entry for STMicroelectronics variant of PL18x for
+          STM32MP25. This dedicated compatible is used by bootloaders.
+        items:
+          - const: st,stm32mp25-sdmmc2
+          - const: arm,pl18x
+          - const: arm,primecell
 
   clocks:
     description: One or two clocks, the "apb_pclk" and the "MCLK"
@@ -78,6 +84,11 @@ properties:
           - const: rx
           - const: tx
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
   power-domains: true
 
   resets:
diff --git a/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml b/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml
index eab8ea3da..07331e68e 100644
--- a/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml
+++ b/Documentation/devicetree/bindings/mtd/st,stm32-fmc2-nand.yaml
@@ -14,10 +14,11 @@ properties:
     enum:
       - st,stm32mp15-fmc2
       - st,stm32mp1-fmc2-nfc
+      - st,stm32mp25-fmc2-nfc
 
   reg:
     minItems: 6
-    maxItems: 7
+    maxItems: 12
 
   interrupts:
     maxItems: 1
@@ -89,6 +90,28 @@ allOf:
             - description: Chip select 1 command
             - description: Chip select 1 address space
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-fmc2-nfc
+    then:
+      properties:
+        reg:
+          items:
+            - description: Chip select 0 data
+            - description: Chip select 0 command
+            - description: Chip select 0 address space
+            - description: Chip select 1 data
+            - description: Chip select 1 command
+            - description: Chip select 1 address space
+            - description: Chip select 2 data
+            - description: Chip select 2 command
+            - description: Chip select 2 address space
+            - description: Chip select 3 data
+            - description: Chip select 3 command
+            - description: Chip select 3 address space
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/net/can/bosch,m_can.yaml b/Documentation/devicetree/bindings/net/can/bosch,m_can.yaml
index 26aa0830e..71d05cb05 100644
--- a/Documentation/devicetree/bindings/net/can/bosch,m_can.yaml
+++ b/Documentation/devicetree/bindings/net/can/bosch,m_can.yaml
@@ -118,6 +118,11 @@ properties:
   phys:
     maxItems: 1
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/net/snps,dwmac.yaml b/Documentation/devicetree/bindings/net/snps,dwmac.yaml
index 13b984076..f8d9bdff7 100644
--- a/Documentation/devicetree/bindings/net/snps,dwmac.yaml
+++ b/Documentation/devicetree/bindings/net/snps,dwmac.yaml
@@ -294,6 +294,11 @@ properties:
     description:
       Frequency division factor for MDC clock.
 
+  snps,ext-systime:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description:
+      Enable PTP External System Time bus.
+
   mdio:
     $ref: mdio.yaml#
     unevaluatedProperties: false
diff --git a/Documentation/devicetree/bindings/net/stm32-dwmac.yaml b/Documentation/devicetree/bindings/net/stm32-dwmac.yaml
index 5c93167b3..f3507ee0a 100644
--- a/Documentation/devicetree/bindings/net/stm32-dwmac.yaml
+++ b/Documentation/devicetree/bindings/net/stm32-dwmac.yaml
@@ -72,6 +72,9 @@ properties:
         - eth-ck
         - ptp_ref
 
+  power-domains:
+    maxItems: 1
+
   st,syscon:
     $ref: "/schemas/types.yaml#/definitions/phandle-array"
     items:
@@ -93,6 +96,17 @@ properties:
       select RCC clock instead of ETH_REF_CLK.
     type: boolean
 
+  st,eth-ptp-from-rcc:
+    description:
+      set this property when PTP (IEEE1588) clock selection is from RCC,
+      by default ETHSW ptp ref clock is used
+    type: boolean
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - clocks
diff --git a/Documentation/devicetree/bindings/net/stm32-ttt.yaml b/Documentation/devicetree/bindings/net/stm32-ttt.yaml
new file mode 100644
index 000000000..d45db83a4
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/stm32-ttt.yaml
@@ -0,0 +1,90 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+# Copyright 2019 BayLibre, SAS
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/net/stm32-ttt.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: STMicroelectronics STM32 TSN switch glue layer controller
+
+maintainers:
+  - Alexandre Torgue <alexandre.torgue@foss.st.com>
+
+description:
+  This file documents platform glue layer for the TSN switch.
+
+properties:
+  compatible:
+    contains:
+      enum:
+        - st,stm32-deip
+
+patternProperties:
+  "^deip-sw@[0-9a-f]+$":
+    type: object
+    properties:
+      compatible:
+        enum:
+          - ttt,deip-sw
+    required:
+      - compatible
+
+  "^acm@[0-9a-f]+$":
+    type: object
+    properties:
+      compatible:
+        enum:
+          - ttt,acm-4.0
+    required:
+      - compatible
+
+required:
+  - compatible
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    switch0: ttt-sw@4c000000 {
+        #address-cells  = <1>;
+        #size-cells     = <1>;
+        compatible = "st,stm32-deip";
+        clock-names = "ethsw-bus-clk", "ethsw-clk",
+                      "ethswacmcfg-bus-clk", "ethswacmmsg-bus-clk";
+        clocks = <&rcc CK_BUS_ETHSW>,
+                 <&rcc CK_KER_ETHSW>,
+                 <&rcc CK_BUS_ETHSWACMCFG>,
+                 <&rcc CK_BUS_ETHSWACMMSG>;
+        st,syscon = <&syscfg 0x3800>;
+        ranges = <0x4b000000 0x4b000000 0xc0000>,
+                 <0x4c000000 0x4c000000 0x2000000>;
+        status = "disabled";
+
+        deip_sw0: deip-sw@4c000000 {
+                compatible =  "ttt,deip-sw";
+                reg = <0x4c000000 0x2000000>;
+                interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
+        };
+
+        acm@4b000000 {
+                compatible = "ttt,acm-4.0";
+                reg = <0x4b000000 0x00400>,
+                      <0x4b010000 0x10000>,
+                      <0x4b030000 0x10000>,
+                      <0x4b050000 0x10000>,
+                      <0x4b060000 0x20000>,
+                      <0x4b080000 0x40000>;
+                reg-names = "CommonRegister",
+                            "Bypass1",
+                            "Bypass0",
+                            "Redundancy",
+                            "Scheduler",
+                            "Messagebuffer";
+                buffers = <32>;
+                ptp_worker = <&deip_sw0>;
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml b/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml
index 448a2678d..6c0339c9b 100644
--- a/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml
+++ b/Documentation/devicetree/bindings/nvmem/st,stm32-romem.yaml
@@ -22,7 +22,9 @@ properties:
   compatible:
     enum:
       - st,stm32f4-otp
+      - st,stm32mp13-bsec
       - st,stm32mp15-bsec
+      - st,stm32mp25-bsec
 
   reg:
     maxItems: 1
@@ -39,6 +41,14 @@ patternProperties:
           related area can only be reached by the secure world.
         type: boolean
 
+      st,secure-otp:
+        description: |
+          This property explicits a factory programmed area that only the secure
+          world of the main processor can access.
+          It is needed when the related area must be only not reached by the
+          secure world of the coprocessor, it is not shadowed.
+        type: boolean
+
 required:
   - "#address-cells"
   - "#size-cells"
diff --git a/Documentation/devicetree/bindings/nvmem/st,stm32-tamp-nvram.yaml b/Documentation/devicetree/bindings/nvmem/st,stm32-tamp-nvram.yaml
new file mode 100644
index 000000000..8f4dc7649
--- /dev/null
+++ b/Documentation/devicetree/bindings/nvmem/st,stm32-tamp-nvram.yaml
@@ -0,0 +1,69 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/nvmem/st,stm32-tamp-nvram.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 backup registers as NVMEM
+
+description: |
+  This represents STM32 backup registers area presented as nvmem cells.
+  This contains various information (e.g. boot mode passed to bootloaders).
+
+maintainers:
+  - Simon Marijon <simeon.marijon@foss.st.com>
+
+allOf:
+  - $ref: "nvmem.yaml#"
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp15-tamp-nvram
+      - st,stm32mp25-tamp-nvram
+
+  reg:
+    description:
+      TAMP Registers bank location and size.
+    maxItems: 1
+
+  '#address-cells':
+    const: 1
+
+  '#size-cells':
+    const: 1
+
+patternProperties:
+  "^tamp-bkp@[0-9a-f]+$":
+    type: object
+    required:
+      - reg
+
+required:
+  - compatible
+  - reg
+  - "#address-cells"
+  - "#size-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+          nvram: nvram@5c00a100 {
+              #address-cells = <1>;
+              #size-cells = <1>;
+              reg = <0x5c00a100 0x80>;
+              compatible = "st,stm32mp15-tamp-nvram";
+
+              /* Data cells */
+              saes_secret_key: tamp-bkp@0 {
+                  /*see saes secret key feature */
+                  reg = <0x0 0x20>;
+              };
+
+              boot_mode: tamp-bkp@78 {
+                  /*see boot mode selection feature*/
+                  reg = <0x78 0x4>;
+              };
+          };
+...
diff --git a/Documentation/devicetree/bindings/pci/st,stm32-pcie-ep.yaml b/Documentation/devicetree/bindings/pci/st,stm32-pcie-ep.yaml
new file mode 100644
index 000000000..03ee45f29
--- /dev/null
+++ b/Documentation/devicetree/bindings/pci/st,stm32-pcie-ep.yaml
@@ -0,0 +1,101 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/pci/st,stm32-pcie-ep.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: PCIe EP controller on STM32MP25 SoC
+
+maintainers:
+  - Christian Bruel <christian.bruel@foss.st.com>
+
+description: |
+  PCIe EP controller based on the Synopsys DesignWare PCIe core.
+
+allOf:
+  - $ref: /schemas/pci/snps,dw-pcie-ep.yaml#
+
+properties:
+  compatible:
+    const: st,stm32mp25-pcie-ep
+
+  reg:
+    items:
+      - description: Data Bus Interface (DBI) registers.
+      - description: PCIe configuration registers.
+
+  reg-names:
+    items:
+      - const: dbi
+      - const: addr_space
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to the SYSCON entry required for configuring PCIe mode.
+
+  clocks:
+    maxItems: 1
+    description: PCIe system clock
+
+  clock-names:
+    const: core
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    const: pcie
+
+  phys:
+    maxItems: 1
+
+  phy-names:
+    const: pcie-phy
+
+  reset-gpios:
+    description: GPIO controlled connection to PERST# signal
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    maxItems: 1
+
+required:
+  - st,syscfg
+  - resets
+  - reset-names
+  - clocks
+  - clock-names
+  - phys
+  - phy-names
+  - reset-gpios
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/phy/phy.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    pcie_ep: pcie-ep@48400000 {
+             compatible = "st,stm32mp25-pcie-ep";
+             num-lanes = <1>;
+             reg = <0x48400000 0x400000>,
+                   <0x10000000 0x8000000>;
+             reg-names = "dbi", "addr_space";
+             st,syscfg = <&syscfg>;
+             clocks = <&rcc CK_BUS_PCIE>;
+             clock-names = "core";
+             phys = <&combophy PHY_TYPE_PCIE>;
+             phy-names = "pcie-phy";
+             resets = <&rcc PCIE_R>;
+             reset-names = "pcie";
+             pinctrl-names = "default", "init";
+             pinctrl-0 = <&pcie_pins_a>;
+             pinctrl-1 = <&pcie_init_pins_a>;
+             reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+    };
diff --git a/Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml b/Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml
new file mode 100644
index 000000000..f482ec49e
--- /dev/null
+++ b/Documentation/devicetree/bindings/pci/st,stm32-pcie-host.yaml
@@ -0,0 +1,163 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/pci/st,stm32-pcie-host.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: PCIe RC controller on STM32MP25 SoC
+
+maintainers:
+  - Christian Bruel <christian.bruel@foss.st.com>
+
+description: |
+  PCIe RC controller based on the Synopsys DesignWare PCIe core.
+
+allOf:
+  - $ref: /schemas/pci/snps,dw-pcie.yaml#
+
+properties:
+  compatible:
+    const: st,stm32mp25-pcie-rc
+
+  reg:
+    items:
+      - description: Data Bus Interface (DBI) registers.
+      - description: PCIe configuration registers.
+
+  reg-names:
+    items:
+      - const: dbi
+      - const: config
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to the SYSCON entry required for configuring PCIe mode.
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    const: pcie
+
+  clocks:
+    maxItems: 1
+    description: PCIe system clock
+
+  clock-names:
+    const: core
+
+  interrupts:
+    description: AER and PME interrupts
+    minItems: 1
+    maxItems: 2
+
+  interrupt-names:
+    items:
+      - const: aer_msi
+      - const: pme_msi
+
+  phys:
+    maxItems: 1
+
+  phy-names:
+    const: pcie-phy
+
+  num-lanes:
+    const: 1
+
+  max-link-speed:
+    enum: [1, 2]
+    default: 2
+
+  max-payload-size:
+    description: Maximum TLP Payload size to use in device control
+      register.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    enum: [128, 256]
+    default: 128
+
+  msi-parent:
+    maxItems: 1
+
+  reset-gpios:
+    description: GPIO controlled connection to PERST# signal
+    maxItems: 1
+
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    maxItems: 1
+
+  wake-gpios:
+    description: GPIO controlled connection to WAKE# input signal
+    maxItems: 1
+
+  wakeup-source: true
+
+if:
+  required:
+     - wakeup-source
+then:
+  required:
+     - wake-gpios
+
+  st,limit_mrrs:
+    type: boolean
+    description: If present limit downstream MRRS to 256B
+
+required:
+  - st,syscfg
+  - interrupt-map
+  - interrupt-map-mask
+  - ranges
+  - resets
+  - reset-names
+  - clocks
+  - clock-names
+  - phys
+  - phy-names
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/phy/phy.h>
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    pcie_rc: pcie@48400000 {
+             compatible = "st,stm32mp25-pcie-rc";
+             device_type = "pci";
+             num-lanes = <1>;
+             reg = <0x48400000 0x400000>,
+                   <0x10000000 0x10000>;
+             reg-names = "dbi", "config";
+             st,syscfg = <&syscfg>;
+             #interrupt-cells = <1>;
+             interrupt-map-mask = <0 0 0 7>;
+             interrupt-map = <0 0 0 1 &intc 0 0 GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+                             <0 0 0 2 &intc 0 0 GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+                             <0 0 0 3 &intc 0 0 GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+                             <0 0 0 4 &intc 0 0 GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>;
+             interrupts = <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>,
+                          <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
+             interrupt-names = "aer_msi", "pme_msi";
+             #address-cells = <3>;
+             #size-cells = <2>;
+             ranges = <0x01000000 0 0x10010000 0x10010000 0 0x10000>,
+                      <0x02000000 0 0x10020000 0x10020000 0 0x7fe0000>,
+                      <0x42000000 0 0x18000000 0x18000000 0 0x8000000>;
+             bus-range = <0x00 0xff>;
+             clocks = <&rcc CK_BUS_PCIE>;
+             clock-names = "core";
+             phys = <&combophy PHY_TYPE_PCIE>;
+             phy-names = "pcie-phy";
+             resets = <&rcc PCIE_R>;
+             reset-names = "pcie";
+             wakeup-source;
+             wake-gpios = <&gpioh 5 GPIO_ACTIVE_LOW>;
+             msi-parent = <&v2m0>;
+    };
diff --git a/Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml b/Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml
new file mode 100644
index 000000000..085f2886e
--- /dev/null
+++ b/Documentation/devicetree/bindings/perf/stm32-ddr-pmu.yaml
@@ -0,0 +1,44 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/perf/stm32-ddr-pmu.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+maintainers:
+  - Gerald Baeza <gerald.baeza@st.com>
+
+title: STMicroelectronics STM32 DDR Performance Monitor (DDRPERFM) bindings
+
+properties:
+  compatible:
+    const: st,stm32-ddr-pmu
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  resets:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - resets
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/reset/stm32mp1-resets.h>
+
+    ddrperfm: perf@5a007000 {
+        compatible = "st,stm32-ddr-pmu";
+        reg = <0x5a007000 0x400>;
+        clocks = <&rcc DDRPERFM>;
+        resets = <&rcc DDRPERFM_R>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml b/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml
index 801993813..b9025dead 100644
--- a/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml
+++ b/Documentation/devicetree/bindings/phy/phy-stm32-usbphyc.yaml
@@ -55,6 +55,11 @@ properties:
     description: number of clock cells for ck_usbo_48m consumer
     const: 0
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 #Required child nodes:
 
 patternProperties:
@@ -74,6 +79,10 @@ patternProperties:
       "#phy-cells":
         enum: [ 0x0, 0x1 ]
 
+      interrupts:
+        maxItems: 1
+        description: interrupt used for wakeup when port is used by USBH controller
+
       connector:
         type: object
         $ref: /schemas/connector/usb-connector.yaml
diff --git a/Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml b/Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml
new file mode 100644
index 000000000..4c80ceb96
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/st,stm32-combophy.yaml
@@ -0,0 +1,174 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/phy/st,stm32-combophy.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32MP25 USB3/PCIe ComboPHY binding.
+
+maintainers:
+  - Christian Bruel <christian.bruel@foss.st.com>
+
+description: |
+  Single lane PHY shared (exclusive) between the USB3 and PCIe controllers.
+  Supports 5Gbit/s for USB3 and PCIe gen2 or 2.5Gbit/s for PCIe gen1.
+
+properties:
+  compatible:
+    const: st,stm32mp25-combophy
+
+  reg:
+    maxItems: 1
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: Phandle to the SYSCON entry required for configuring PCIe
+      or USB3.
+
+  "#phy-cells":
+    const: 1
+    description: |
+      The cells contain the following arguments.
+
+      - description: The PHY type
+          enum:
+            - PHY_TYPE_USB3
+            - PHY_TYPE_PCIE
+
+  clocks:
+    anyOf:
+      - description: apb-clk Bus clock mandatory to access registers.
+      - description: ker-clk Internal RCC reference clock for USB3 or PCIe
+      - description: pad-clk Optional on board clock input for PCIe only. Typically an
+                     external 100Mhz oscillator wired on dedicated CLKIN pad. Used as reference
+                     clock input instead of the ker-clk
+
+  clock-names:
+    oneOf:
+      - items:
+          - const: apb-clk
+          - const: ker-clk
+
+      - items:
+          - const: apb-clk
+          - const: ker-clk
+          - const: pad-clk
+
+  resets:
+    maxItems: 1
+
+  reset-names:
+    const: phy-rst
+
+  power-domains:
+    maxItems: 1
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  st,ssc-on:
+    type: boolean
+    description:
+      A boolean property whose presence indicates that the SSC for common clock
+      needs to be set.
+
+  st,rx_equalizer:
+    minimum: 0
+    maximum: 7
+    default: 2
+    description:
+      A 3 bit value describing internal filter settings for the RX equalizer.
+
+  st,output-micro-ohms:
+    minimum: 3999000
+    maximum: 6090000
+    default: 4968000
+    description:
+      A value property to tune the PCIe 100Mhz Single Ended Output Impedance, simulations
+      results at 25C for a VDDP=0.8V.
+      The hardware accepts discrete values in this range.
+
+  st,output-vswing-microvolt:
+    minimum: 442000
+    maximum: 803000
+    default: 803000
+    description:
+      A value property in microvolt to tune the PCIe 100Mhz differential Single Ended Output
+      Voltage Swing to change the Vlo, Vhi for a VDDP = 0.8V.
+      The hardware accepts discrete values in this range.
+
+  wakeup-source: true
+
+  interrupts:
+    maxItems: 1
+    description: interrupt used for wakeup
+
+required:
+  - compatible
+  - reg
+  - st,syscfg
+  - '#phy-cells'
+  - resets
+  - reset-names
+  - clocks
+  - clock-names
+
+allOf:
+  - if:
+      required:
+        - wakeup-source
+    then:
+      anyOf:
+        - required: [interrupts]
+        - required: [interrupts-extended]
+
+additionalProperties: false
+
+examples:
+  - |
+    // Example 1: Combophy configured to use internal reference clock
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    combophy_internal: phy@480c0000 {
+              compatible = "st,stm32mp25-combophy";
+              reg = <0x480c0000 0x1000>;
+              #phy-cells = <1>;
+              clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
+              clock-names = "apb-clk", "ker-clk";
+              resets = <&rcc USB3PCIEPHY_R>;
+              reset-names = "phy-rst";
+              st,syscfg = <&syscfg>;
+              wakeup-source;
+              interrupts-extended = <&exti1 45 IRQ_TYPE_EDGE_FALLING>;
+    };
+
+  - |
+    // Example 2: Combophy configured to use extrenal 100MHz reference clock
+    // on CLKIN pad for PCIe
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    clocks {
+        pad_clk: pad-clk {
+                #clock-cells = <0>;
+                compatible = "fixed-clock";
+                clock-frequency = <100000000>;
+        };
+    };
+
+    combophy_pad: phy@480c0000 {
+              compatible = "st,stm32mp25-combophy";
+              reg = <0x480c0000 0x1000>;
+              #phy-cells = <1>;
+              clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>, <&pad_clk>;
+              clock-names = "apb-clk", "ker-clk", "pad-clk";
+              resets = <&rcc USB3PCIEPHY_R>;
+              reset-names = "phy-rst";
+              st,syscfg = <&syscfg>;
+              wakeup-source;
+              interrupts-extended = <&exti1 45 IRQ_TYPE_EDGE_FALLING>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/phy/st,stm32-usb2phy.yaml b/Documentation/devicetree/bindings/phy/st,stm32-usb2phy.yaml
new file mode 100644
index 000000000..de37f52ec
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/st,stm32-usb2phy.yaml
@@ -0,0 +1,190 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/phy/st,stm32-usb2phy.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: STMicroelectronics STM32 MPU High-Speed USB PHY
+
+description:
+  USB2 PHY block inside STM32 is used for supporting the HS/FS/LS operation
+  for USB controller. For stm32mp25, it is used by USBH ctrl in HS/FS/LS mode
+  and by DWC3 ctrl in USB2 LS/FS/HS modes (when host) or USB2 FS/HS modes (when device)
+
+maintainers:
+  - Fabrice Gasnier <fabrice.gasnier@foss.st.com>
+  - Pankaj Dev <pankaj.dev@st.com>
+
+properties:
+  compatible:
+    const: st,stm32mp25-usb2phy
+
+  "#phy-cells":
+    const: 0
+
+  clocks:
+    items:
+      description: PHY ref clock
+
+  resets:
+    items:
+      description: PHY core reset
+
+  vdd33-supply:
+    description: phandle to regulator providing 3V3 power supply to the USB2 HS PHY
+
+  vdda18-supply:
+    description: phandle to regulator providing 1V8 power supply to the USB2 HS PHY
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array #(arm/stm32/st,stm32-syscon.yaml#)
+    description: Phandle to the STM32-MPU System Controller DT node
+                 <syscon-handle cr-offset>
+
+  st,pll-ipath-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: PLL Integral Path Tune
+                 0->0.5x 1->1.0x 2->1.5x 3->2.0x
+    minimum: 0
+    maximum: 3
+    default: 0
+
+  st,pll-ppath-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: PLL Proportional Path Tune
+                 0->1.0x 1->1.50x 2->2.0x ... 15->5.5x
+    minimum: 0
+    maximum: 15
+    default: 12
+
+  st,comp-dis-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Disconnect Threshold Adjustment
+                 0->-9% 1->-6% 2->-4% 3->0% 4->3% 5->7% 6->10% 7->12%
+    minimum: 0
+    maximum: 7
+    default: 3
+
+  st,sqrx-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Squelch Threshold Adjustment
+                 0->15% 1->10% 2->5% 3->0% 4->-5% 5->-10% 6->-15% 7->-20%
+    minimum: 0
+    maximum: 7
+    default: 3
+
+  st,vdatref-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Data Detect Voltage Adjustment
+                 0->10% 1->0% 2->-10% 3->-20%
+    minimum: 0
+    maximum: 3
+    default: 1
+
+  st,otg-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: VBUS Valid Threshold Adjustment
+                 0->-9% 1->-6% 2->-3% 3->0% 4->3% 5->6% 6->9% 7->12%
+    minimum: 0
+    maximum: 7
+    default: 3
+
+  st,txhsxv-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: Transmitter High Speed Crossover Adjustment
+                 0->Rsvd 1->-15mV 2->15mV 3->0mV
+    minimum: 1
+    maximum: 3
+    default: 3
+
+  st,txfsls-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: FS/LS Source Impedance Adjustment
+                 0->14% 1->6.5% 2->Rsvd 3->0% 7->-5/6% 15->-10.7% other-values->Rsvd
+    enum: [ 0, 1, 3, 7, 15 ]
+    default: 3
+
+  st,txvref-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS DC Voltage Level Adjustment
+                 0->-6% 1->-4% 2->-2% 3->0% 4->2% 5->4% 6->6% ... 15->24%
+    minimum: 0
+    maximum: 15
+    default: 3
+
+  st,txrise-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS Transmitter Rise/Fall Time Adjustment
+                 0->+5.4% 1->nominal 2->-7.2% 3->-8.1%
+    minimum: 0
+    maximum: 3
+    default: 1
+
+  st,txres-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: USB Source Impedance Adjustment
+                 0->+1.3Ohm 1->0Ohm 2->-3.6Ohm 3->-5.6Ohm
+    minimum: 0
+    maximum: 3
+    default: 1
+
+  st,txpreempamp-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS Transmitter Pre Emphasis Current Control
+                 0->Disabled 1->1x 2->2x 3->3x
+    minimum: 0
+    maximum: 3
+    default: 0
+
+  st,txpreemppulse-tune:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    description: HS Transmitter Pre Emphasis Duration Control
+                 0->2x 1->1x
+    minimum: 0
+    maximum: 1
+    default: 0
+
+  "#clock-cells":
+    description: number of clock cells for ck_usb2phyXXXX_48m consumer
+    const: 0
+
+required:
+  - compatible
+  - "#phy-cells"
+  - clocks
+  - resets
+  - vdd33-supply
+  - st,syscfg
+  - "#clock-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    usb2_phy2: usb-phy {
+        compatible      = "st,stm32mp25-usb2phy";
+        #phy-cells      = <0>;
+        #clock-cells    = <0>;
+        st,syscfg       = <&syscfg 0x2800>;
+        clocks          = <&rcc CK_KER_USB2PHY2>;
+        resets          = <&rcc USB2PHY2_R>;
+        vdd33-supply    = <&vdd33usb>;
+
+        st,pll-ipath-tune = /bits/ 8 <0>;
+        st,pll-ppath-tune = /bits/ 8 <0>;
+        st,comp-dis-tune = /bits/ 8 <0>;
+        st,sqrx-tune = /bits/ 8 <0>;
+        st,vdatref-tune = /bits/ 8 <0>;
+        st,otg-tune = /bits/ 8 <0>;
+        st,txhsxv-tune = /bits/ 8 <1>;
+        st,txfsls-tune = /bits/ 8 <0>;
+        st,txvref-tune = /bits/ 8 <0>;
+        st,txrise-tune = /bits/ 8 <1>;
+        st,txres-tune = /bits/ 8 <0>;
+        st,txpreempamp-tune = /bits/ 8 <0>;
+        st,txpreemppulse-tune = /bits/ 8 <0>;
+    };
diff --git a/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl-hdp.yaml b/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl-hdp.yaml
new file mode 100644
index 000000000..429601891
--- /dev/null
+++ b/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl-hdp.yaml
@@ -0,0 +1,91 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# Copyright (C) STMicroelectronics 2024.
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/pinctrl/st,stm32-pinctrl-hdp.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 Hardware Debug Port Mux/Config
+
+maintainers:
+  - Clment LE GOFFIC <clement.legoffic@foss.st.com>
+
+description: |
+  STMicroelectronics's STM32 MPUs integrate a Hardware Debug Port (HDP).
+  It permits to output internal signals on SoC's GPIO.
+
+properties:
+  compatible:
+    const: st,stm32mp-hdp
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+patternProperties:
+  '-pins$':
+    type: object
+    $ref: pinmux-node.yaml#
+
+    properties:
+      function:
+        enum: [ "0", "1", "2", "3", "4", "5", "6", "7",
+                "8", "9", "10", "11", "12", "13", "14",
+                "15" ]
+
+      pins:
+        enum: [ hdp0, hdp1, hdp2, hdp3, hdp4, hdp5, hdp6, hdp7 ]
+
+    required:
+      - function
+      - pins
+
+    additionalProperties: false
+
+allOf:
+  - $ref: "pinctrl.yaml#"
+
+required:
+  - compatible
+  - reg
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/pinctrl/stm32mp15-hdp.h>
+    //Example 1
+    hdp: pinctrl@54090000 {
+      compatible = "st,stm32mp-hdp";
+      reg = <0x54090000 0x400>;
+      clocks = <&rcc HDP>;
+      pinctrl-names = "default";
+      pinctrl-0 = <&hdp2>;
+      hdp2: hdp2-pins {
+        function = HDP2_GPOVAL_2;
+        pins = "hdp2";
+      };
+    };
+
+  - |
+    #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/pinctrl/stm32mp15-hdp.h>
+    //Example 2
+    hdp: pinctrl@54090000 {
+      compatible = "st,stm32mp-hdp";
+      reg = <0x54090000 0x400>;
+      clocks = <&rcc HDP>;
+      hdp2: hdp2-pins {
+        pins = "hdp2";
+        function = HDP2_GPOVAL_2;
+      };
+    };
+
+    foo {
+      pinctrl-names = "default";
+      pinctrl-0 = <&hdp2>;
+    };
diff --git a/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml b/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml
index 9d59208d8..1fb225ea1 100644
--- a/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml
+++ b/Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl.yaml
@@ -27,6 +27,8 @@ properties:
       - st,stm32mp135-pinctrl
       - st,stm32mp157-pinctrl
       - st,stm32mp157-z-pinctrl
+      - st,stm32mp257-pinctrl
+      - st,stm32mp257-z-pinctrl
 
   '#address-cells':
     const: 1
@@ -54,7 +56,7 @@ properties:
       Indicates the SOC package used.
       More details in include/dt-bindings/pinctrl/stm32-pinfunc.h
     $ref: /schemas/types.yaml#/definitions/uint32
-    enum: [1, 2, 4, 8]
+    enum: [0x1, 0x2, 0x4, 0x8, 0x100, 0x400, 0x800]
 
 patternProperties:
   '^gpio@[0-9a-f]*$':
@@ -155,9 +157,13 @@ patternProperties:
               * ...
               * 16 : Alternate Function 15
               * 17 : Analog
+              * 18 : Reserved
               To simplify the usage, macro is available to generate "pinmux" field.
               This macro is available here:
                 - include/dt-bindings/pinctrl/stm32-pinfunc.h
+              Setting the pinmux's function to the Reserved (RSVD) value is used to inform
+              the driver that it shall not apply the mux setting. This can be used to
+              reserve some pins, for example to a co-processor not running Linux.
               Some examples of using macro:
                /* GPIO A9 set as alernate function 2 */
                ... {
@@ -171,6 +177,10 @@ patternProperties:
                ... {
                           pinmux = <STM32_PINMUX('A', 9, ANALOG)>;
                };
+               /* GPIO A9 reserved for co-processor */
+               ... {
+                          pinmux = <STM32_PINMUX('A', 9, RSVD)>;
+               };
 
           bias-disable:
             type: boolean
@@ -194,6 +204,54 @@ patternProperties:
               3: High speed
             $ref: /schemas/types.yaml#/definitions/uint32
             enum: [0, 1, 2, 3]
+          st,io-delay-path:
+            description: |
+              IO synchronization delay path location
+              0: Delay switched into the output path
+              1: Delay switched into the input path
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-clk-edge:
+            description: |
+              IO synchronization clock edge
+              0: Data single-edge (changing on rising or falling clock edge)
+              1: Data double-edge (changing on both clock edges)
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-clk-type:
+            description: |
+              IO synchronization clock inversion
+              0: IO clocks not inverted. Data retimed to rising clock edge
+              1: IO clocks inverted. Data retimed to falling clock edge
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-retime:
+            description: |
+              IO synchronization data retime
+              0: Data not synchronized or retimed on clock edges
+              1: Data retimed to either rising or falling clock edge
+            $ref: /schemas/types.yaml#/definitions/uint32
+            enum: [0, 1]
+          st,io-delay:
+            description: |
+              IO synchronization delay applied to the input or output path
+              0: No delay
+              1: Delay 0.30 ns
+              2: Delay 0.50 ns
+              3: Delay 0.75 ns
+              4: Delay 1.00 ns
+              5: Delay 1.25 ns
+              6: Delay 1.50 ns
+              7: Delay 1.75 ns
+              8: Delay 2.00 ns
+              9: Delay 2.25 ns
+              10: Delay 2.50 ns
+              11: Delay 2.75 ns
+              12: Delay 3.00 ns
+              13: Delay 3.25 ns
+            $ref: /schemas/types.yaml#/definitions/uint32
+            minimum: 0
+            maximum: 13
 
         required:
           - pinmux
diff --git a/Documentation/devicetree/bindings/regulator/protection-consumer.txt b/Documentation/devicetree/bindings/regulator/protection-consumer.txt
new file mode 100644
index 000000000..bf8169e00
--- /dev/null
+++ b/Documentation/devicetree/bindings/regulator/protection-consumer.txt
@@ -0,0 +1,23 @@
+regulator protection bindings
+
+
+Required properties:
+	compatible: "protection-consumer"
+	protection-supply: the phandle of the regulator to control
+
+Optional properties:
+--------------------
+	interrupt
+
+
+Example:
+
+	regulator_protection {
+		compatible = "protection-consumer";
+		protection-supply = <&vdd>;
+		status = "okay";
+
+		interrupts = <15 2>;
+		interrupt-parent = <&gpiof>;
+	};
+
diff --git a/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml b/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml
index a5a27ee0a..454f56e43 100644
--- a/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml
+++ b/Documentation/devicetree/bindings/regulator/st,stm32-vrefbuf.yaml
@@ -30,6 +30,11 @@ properties:
   vdda-supply:
     description: phandle to the vdda input analog voltage.
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/remoteproc/rproc-srm.txt b/Documentation/devicetree/bindings/remoteproc/rproc-srm.txt
new file mode 100644
index 000000000..baa6e8e13
--- /dev/null
+++ b/Documentation/devicetree/bindings/remoteproc/rproc-srm.txt
@@ -0,0 +1,58 @@
+Remoteproc System Resource Manager
+----------------------------------
+
+The remoteproc SRM (System Resource Manager) handles resources allocated
+to remote processors.
+This makes it possible for remote proc to reserve and initialize system
+resources for a peripheral assigned to a coprocessor.
+
+The devices are grouped in a core node
+
+Core
+====
+Required properties:
+- compatible: should be "rproc-srm-core"
+
+Dev
+===
+Required properties:
+- compatible: should be "rproc-srm-dev"
+
+Optional properties:
+- reg: register base address and length
+- clocks: clocks required by the coprocessor
+- clock-names: see clock-bindings.txt
+- pinctrl-0: pins configurations required by the coprocessor
+	The SRM reserves the pins for the coprocessor, which prevents the local
+	processor to use them.
+- pinctrl-names: must be "default".
+- x-supply: power supplies required by the coprocessor
+- interrupts: external interrupts configurations required by the coprocessor.
+	This is optional since the configuration is done by the coprocessor.
+	When defined, the SRM (over)writes the configuration which allows the
+	interrupt controller to check for configuration conflicts.
+- interrupt-parent: see interrupts.txt
+- interrupt-names: see interrupts.txt
+
+Example:
+	system_resources {
+		compatible = "rproc-srm-core";
+
+		mmc0: sdhci@09060000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x09060000 0x100>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_pinctrl_mmc0>;
+			clock-names = "mmc", "icn";
+			clocks = <&clk_s_c0_flexgen CLK_MMC_0>,
+				 <&clk_s_c0_flexgen CLK_RX_ICN_HVA>;
+			vdda-supply = <&vdda>;
+		};
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <5 1>;
+			interrupt-names = "gpio_key";
+		};
+	};
diff --git a/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml b/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml
index da50f0e99..d73c5f06d 100644
--- a/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml
+++ b/Documentation/devicetree/bindings/remoteproc/st,stm32-rproc.yaml
@@ -16,8 +16,16 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32mp1-m4
-
+    enum:
+      - st,stm32mp1-m4
+      - st,stm32mp1-m4-tee
+      - st,stm32mp2-m33
+      - st,stm32mp2-m33-tee
+    description:
+      Use "st,stm32mp1-m4" for the stm32mp15 Cortex-M4 coprocessor management by Linux
+      Use "st,stm32mp1-m4-tee" for the stm32mp15 Cortex-M4 coprocessor management by OPTEE
+      Use "st,stm32mp2-m33" for the stm32mp2 Cortex-M33 coprocessor management by Linux
+      Use "st,stm32mp2-m33-tee" for the stm32mp2 Cortex-M33 coprocessor management by OPTEE
   reg:
     description:
       Address ranges of the RETRAM and MCU SRAM memories used by the remote
@@ -25,7 +33,14 @@ properties:
     maxItems: 3
 
   resets:
-    maxItems: 1
+    minItems: 1
+    maxItems: 2
+
+  reset-names:
+    items:
+      - const: mcu_rst
+      - const: hold_boot
+    minItems: 1
 
   st,syscfg-holdboot:
     description: remote processor reset hold boot
@@ -36,16 +51,6 @@ properties:
           - description: The offset of the hold boot setting register
           - description: The field mask of the hold boot
 
-  st,syscfg-tz:
-    description:
-      Reference to the system configuration which holds the RCC trust zone mode
-    $ref: "/schemas/types.yaml#/definitions/phandle-array"
-    items:
-      - items:
-          - description: Phandle of syscon block
-          - description: The offset of the trust zone setting register
-          - description: The field mask of the trust zone state
-
   interrupts:
     description: Should contain the WWDG1 watchdog reset interrupt
     maxItems: 1
@@ -104,10 +109,18 @@ properties:
           - description: The offset of the power setting register
           - description: The field mask of the PDDS selection
 
-  st,syscfg-m4-state:
+  st,syscfg-nsvtor:
     $ref: "/schemas/types.yaml#/definitions/phandle-array"
     description: |
-      Reference to the tamp register which exposes the Cortex-M4 state.
+      Reference to the system configuration register which stores the remote processor
+      non-secure vector table pointer.
+      address, used to boot it.
+    maxItems: 1
+
+  st,syscfg-cm-state:
+    $ref: "/schemas/types.yaml#/definitions/phandle-array"
+    description: |
+      Reference to the register which exposes the Cortex-M state.
     items:
       - items:
           - description: Phandle of syscon block with the tamp register
@@ -125,6 +138,17 @@ properties:
           - description: The offset of the tamp register
           - description: The field mask of the Cortex-M4 resource table address
 
+  nvmem-cells:
+    maxItems: 2
+    description: |
+      Specify the resource table address and size for firmware started by
+      the boot loader.
+
+  nvmem-cell-names:
+    items:
+      - const: rsc-tbl-addr
+      - const: rsc-tbl-size
+
   st,auto-boot:
     $ref: /schemas/types.yaml#/definitions/flag
     description:
@@ -135,12 +159,35 @@ required:
   - compatible
   - reg
   - resets
-  - st,syscfg-holdboot
-  - st,syscfg-tz
+
+allOf:
+  - if:
+      properties:
+        reset-names:
+          not:
+            contains:
+              const: hold_boot
+    then:
+      required:
+        - st,syscfg-holdboot
+    else:
+      properties:
+        st,syscfg-holdboot: false
+      properties:
+        compatible:
+          enum:
+            - st,stm32mp1-m4-tee
+    then:
+      required:
+        - memory-region
+
 
 additionalProperties: false
 
 examples:
+#--------------------
+# Without SCMI server
+#--------------------
   - |
     #include <dt-bindings/reset/stm32mp1-resets.h>
     m4_rproc: m4@10000000 {
@@ -148,11 +195,30 @@ examples:
       reg = <0x10000000 0x40000>,
             <0x30000000 0x40000>,
             <0x38000000 0x10000>;
-      resets = <&rcc MCU_R>;
+      memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+                      <&m_ipc_shm>, <&vdev0vring1>, <&vdev0buffer>;
+      resets = <&scmi_reset RST_SCMI_MCU>;
+      reset-names = "mcu_rst";
+      /* Hold boot managed using system config*/
       st,syscfg-holdboot = <&rcc 0x10C 0x1>;
-      st,syscfg-tz = <&rcc 0x000 0x1>;
       st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
-      st,syscfg-m4-state = <&tamp 0x148 0xFFFFFFFF>;
+      st,syscfg-cm-state = <&tamp 0x148 0xFFFFFFFF>;
     };
 
+#--------------------
+# With SCMI server
+#--------------------
+  - |
+    #include <dt-bindings/reset/stm32mp1-resets.h>
+    m4_rproc_w_scmi: m4@10000000 {
+      compatible = "st,stm32mp1-m4";
+      reg = <0x10000000 0x40000>,
+            <0x30000000 0x40000>,
+            <0x38000000 0x10000>;
+      resets = <&scmi_reset RST_SCMI_MCU>,
+               <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+      reset-names = "mcu_rst", "hold_boot";
+      st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
+      st,syscfg-cm-state = <&tamp 0x148 0xFFFFFFFF>;
+    };
 ...
diff --git a/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml b/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml
index fcd86f822..2b627d74d 100644
--- a/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml
+++ b/Documentation/devicetree/bindings/rng/st,stm32-rng.yaml
@@ -4,7 +4,7 @@
 $id: http://devicetree.org/schemas/rng/st,stm32-rng.yaml#
 $schema: http://devicetree.org/meta-schemas/core.yaml#
 
-title: STMicroelectronics STM32 RNG bindings
+title: STMicroelectronics STM32 RNG
 
 description: |
   The STM32 hardware random number generator is a simple fixed purpose
@@ -15,26 +15,70 @@ maintainers:
 
 properties:
   compatible:
-    const: st,stm32-rng
+    enum:
+      - st,stm32-rng
+      - st,stm32mp13-rng
+      - st,stm32mp25-rng
 
   reg:
     maxItems: 1
 
   clocks:
-    maxItems: 1
+    minItems: 1
 
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   clock-error-detect:
     type: boolean
     description: If set enable the clock detection management
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
   - clocks
 
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            enum:
+              - st,stm32mp13-rng
+              - st,stm32mp25-rng
+    then:
+      properties:
+        st,rng-lock-conf:
+          type: boolean
+          description: If set, the RNG configuration in RNG_CR, RNG_HTCR and
+                       RNG_NSCR will be locked.
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-rng
+    then:
+      properties:
+        clocks:
+          minItems: 2
+
+        clock-names:
+          items:
+            - const: rng_clk  # RNG kernel clock
+            - const: rng_hclk # RNG bus clock
+
+      required:
+        - clock-names
+
 additionalProperties: false
 
 examples:
diff --git a/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml b/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml
index 764717ce1..d3dba2ad5 100644
--- a/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml
+++ b/Documentation/devicetree/bindings/rtc/st,stm32-rtc.yaml
@@ -15,6 +15,7 @@ properties:
       - st,stm32-rtc
       - st,stm32h7-rtc
       - st,stm32mp1-rtc
+      - st,stm32mp25-rtc
 
   reg:
     maxItems: 1
@@ -52,6 +53,20 @@ properties:
       override default rtc_ck parent clock phandle of the new parent clock of rtc_ck
     maxItems: 1
 
+  st,lsco:
+    $ref: "/schemas/types.yaml#/definitions/uint32"
+    description: |
+      To select and enable RTC Low Speed Clock Output.
+      Refer to <include/dt-bindings/rtc/rtc-stm32.h> for the supported values.
+      Pinctrl state named "default" may be defined to reserve pin for RTC output.
+
+  st,alarm:
+    $ref: "/schemas/types.yaml#/definitions/uint32"
+    description: |
+      To select and enable RTC Alarm A output.
+      Refer to <include/dt-bindings/rtc/rtc-stm32.h> for the supported values.
+      Pinctrl state named "default" may be defined to reserve pin for RTC output.
+
 allOf:
   - if:
       properties:
@@ -65,6 +80,12 @@ allOf:
           minItems: 1
           maxItems: 1
 
+        st,lsco:
+          maxItems: 0
+
+        st,alarm:
+          maxItems: 0
+
         clock-names: false
 
       required:
@@ -82,6 +103,12 @@ allOf:
           minItems: 2
           maxItems: 2
 
+        st,lsco:
+          maxItems: 0
+
+        st,alarm:
+          maxItems: 0
+
       required:
         - clock-names
         - st,syscfg
@@ -90,7 +117,9 @@ allOf:
       properties:
         compatible:
           contains:
-            const: st,stm32mp1-rtc
+            anyOf:
+              - const: st,stm32mp1-rtc
+              - const: st,stm32mp25-rtc
 
     then:
       properties:
@@ -101,6 +130,12 @@ allOf:
         assigned-clocks: false
         assigned-clock-parents: false
 
+        st,lsco:
+          maxItems: 1
+
+        st,alarm:
+          maxItems: 1
+
       required:
         - clock-names
 
@@ -130,12 +165,17 @@ examples:
   - |
     #include <dt-bindings/interrupt-controller/arm-gic.h>
     #include <dt-bindings/clock/stm32mp1-clks.h>
+    #include <dt-bindings/rtc/rtc-stm32.h>
     rtc@5c004000 {
       compatible = "st,stm32mp1-rtc";
       reg = <0x5c004000 0x400>;
       clocks = <&rcc RTCAPB>, <&rcc RTC>;
       clock-names = "pclk", "rtc_ck";
       interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+      st,alarm = <RTC_OUT1>;
+      st,lsco = <RTC_OUT2_RMP>;
+      pinctrl-0 = <&rtc_out1_pins_a &rtc_out2_rmp_pins_a>;
+      pinctrl-names = "default";
     };
 
 ...
diff --git a/Documentation/devicetree/bindings/serial/rs485.yaml b/Documentation/devicetree/bindings/serial/rs485.yaml
index 90a1bab40..3627d7e27 100644
--- a/Documentation/devicetree/bindings/serial/rs485.yaml
+++ b/Documentation/devicetree/bindings/serial/rs485.yaml
@@ -29,6 +29,20 @@ properties:
           default: 0
           maximum: 100
 
+  rs485-rts-delay-ns:
+    description: prop-encoded-array <a b>
+    items:
+      items:
+        - description: Delay between rts signal and beginning of data sent in
+            nanoseconds. It corresponds to the delay before sending data.
+          default: 0
+          maximum: 1000
+        - description: Delay between end of data sent and rts signal in nanoseconds.
+            It corresponds to the delay after sending data and actual release
+            of the line.
+          default: 0
+          maximum: 1000
+
   rs485-rts-active-low:
     description: drive RTS low when sending (default is high).
     $ref: /schemas/types.yaml#/definitions/flag
diff --git a/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml b/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml
index 333dc4272..f7ed6416b 100644
--- a/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml
+++ b/Documentation/devicetree/bindings/serial/st,stm32-uart.yaml
@@ -61,10 +61,14 @@ properties:
   wakeup-source: true
 
   rs485-rts-delay: true
+  rs485-rts-delay-ns: true
   rs485-rts-active-low: true
   linux,rs485-enabled-at-boot-time: true
   rs485-rx-during-tx: true
 
+  power-domains:
+    maxItems: 1
+
   rx-threshold:
     description:
       If value is set to 1, RX FIFO threshold is disabled.
@@ -77,6 +81,11 @@ properties:
     enum: [1, 2, 4, 8, 12, 14, 16]
     default: 8
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 allOf:
   - $ref: rs485.yaml#
   - $ref: serial.yaml#
diff --git a/Documentation/devicetree/bindings/soc/st/st,stm32mp25-risaf.yaml b/Documentation/devicetree/bindings/soc/st/st,stm32mp25-risaf.yaml
new file mode 100644
index 000000000..c870f46eb
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/st/st,stm32mp25-risaf.yaml
@@ -0,0 +1,65 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/soc/st/st,stm32mp25-risaf.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STM32 Resource isolation peripheral unit for address space protection
+       (full version)
+
+maintainers:
+  - Gatien Chevallier <gatien.chevallier@foss.st.com>
+
+description: |
+  The RIF (resource isolation framework) is a comprehensive set of hardware
+  blocks designed to enforce and manage isolation of STM32 hardware resources,
+  like memories and peripherals.
+  Through RISAF registers, a trusted domain, or the domain to whom the
+  configuration has been delegated, assigns memory regions and subregions to
+  one or more security domains (secure, privilege, compartment).
+  RISAF managing DRR includes the DDR memory cipher engine (DDRMCE) feature.
+
+properties:
+  compatible:
+    enum:
+      - st,stm32mp25-risaf
+      - st,stm32mp25-risaf-enc
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  st,mem-map:
+    $ref: /schemas/types.yaml#/definitions/uint32-array
+    minItems: 2
+    maxItems: 4
+    description:
+      Defines the memory address range covered by the RISAF instance.
+
+  memory-region:
+    minItems: 1
+    maxItems: 16
+    description: |
+      Phandle to a node describing memory areas to be configured by the RISAF.
+      These regions cannot overlap. A zone must be within st,mem-map range.
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - st,mem-map
+
+additionalProperties: false
+
+examples:
+  - |
+        #include <dt-bindings/clock/stm32mp25-clks.h>
+
+        risaf4: risaf@420d0000 {
+          compatible = "st,stm32mp25-risaf-enc";
+          reg = <0x420d0000 0x1000>;
+          clocks = <&rcc CK_BUS_RISAF4>;
+          st,mem-map = <0x0 0x80000000 0x1 0x00000000>;
+        };
diff --git a/Documentation/devicetree/bindings/sound/st,stm32-i2s.yaml b/Documentation/devicetree/bindings/sound/st,stm32-i2s.yaml
index d3966ae04..03dc7c51a 100644
--- a/Documentation/devicetree/bindings/sound/st,stm32-i2s.yaml
+++ b/Documentation/devicetree/bindings/sound/st,stm32-i2s.yaml
@@ -17,6 +17,7 @@ properties:
   compatible:
     enum:
       - st,stm32h7-i2s
+      - st,stm32mp25-i2s
 
   "#sound-dai-cells":
     const: 0
@@ -25,18 +26,12 @@ properties:
     maxItems: 1
 
   clocks:
-    items:
-      - description: clock feeding the peripheral bus interface.
-      - description: clock feeding the internal clock generator.
-      - description: I2S parent clock for sampling rates multiple of 8kHz.
-      - description: I2S parent clock for sampling rates multiple of 11.025kHz.
+    minItems: 2
+    maxItems: 4
 
   clock-names:
-    items:
-      - const: pclk
-      - const: i2sclk
-      - const: x8k
-      - const: x11k
+    minItems: 2
+    maxItems: 4
 
   interrupts:
     maxItems: 1
@@ -54,10 +49,18 @@ properties:
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   "#clock-cells":
     description: Configure the I2S device as MCLK clock provider.
     const: 0
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - "#sound-dai-cells"
@@ -68,6 +71,47 @@ required:
   - dmas
   - dma-names
 
+allOf:
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32h7-i2s
+
+    then:
+      properties:
+        clocks:
+          items:
+            - description: clock feeding the peripheral bus interface.
+            - description: clock feeding the internal clock generator.
+            - description: I2S parent clock for sampling rates multiple of 8kHz.
+            - description: I2S parent clock for sampling rates multiple of 11.025kHz.
+
+        clock-names:
+          items:
+            - const: pclk
+            - const: i2sclk
+            - const: x8k
+            - const: x11k
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-i2s
+
+    then:
+      properties:
+        clocks:
+          items:
+            - description: clock feeding the peripheral bus interface.
+            - description: clock feeding the internal clock generator.
+
+        clock-names:
+          items:
+            - const: pclk
+            - const: i2sclk
+
 additionalProperties: false
 
 examples:
diff --git a/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml b/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml
index 56d206f97..1a0f692ac 100644
--- a/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml
+++ b/Documentation/devicetree/bindings/sound/st,stm32-sai.yaml
@@ -20,6 +20,7 @@ properties:
     enum:
       - st,stm32f4-sai
       - st,stm32h7-sai
+      - st,stm32mp25-sai
 
   reg:
     items:
@@ -43,11 +44,21 @@ properties:
     const: 1
 
   clocks:
+    minItems: 1
     maxItems: 3
 
   clock-names:
+    minItems: 1
     maxItems: 3
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+  power-domains:
+    maxItems: 1
+
 required:
   - compatible
   - reg
@@ -88,6 +99,9 @@ patternProperties:
           - const: MCLK
         minItems: 1
 
+      power-domains:
+        maxItems: 1
+
       dmas:
         maxItems: 1
 
@@ -141,6 +155,7 @@ allOf:
         compatible:
           contains:
             const: st,stm32f4-sai
+
     then:
       properties:
         clocks:
@@ -152,7 +167,14 @@ allOf:
           items:
             - const: x8k
             - const: x11k
-    else:
+
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mph7-sai
+
+    then:
       properties:
         clocks:
           items:
@@ -166,6 +188,22 @@ allOf:
             - const: x8k
             - const: x11k
 
+  - if:
+      properties:
+        compatible:
+          contains:
+            const: st,stm32mp25-sai
+
+    then:
+      properties:
+        clocks:
+          items:
+            - description: pclk feeds the peripheral bus interface.
+
+        clock-names:
+          items:
+            - const: pclk
+
 additionalProperties: false
 
 examples:
diff --git a/Documentation/devicetree/bindings/sound/st,stm32-spdifrx.yaml b/Documentation/devicetree/bindings/sound/st,stm32-spdifrx.yaml
index 837e830c4..f802d2b01 100644
--- a/Documentation/devicetree/bindings/sound/st,stm32-spdifrx.yaml
+++ b/Documentation/devicetree/bindings/sound/st,stm32-spdifrx.yaml
@@ -47,6 +47,11 @@ properties:
   resets:
     maxItems: 1
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - "#sound-dai-cells"
diff --git a/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml b/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml
index 6ec6f5561..9193db152 100644
--- a/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml
+++ b/Documentation/devicetree/bindings/spi/st,stm32-qspi.yaml
@@ -46,6 +46,11 @@ properties:
       - const: tx
       - const: rx
 
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml b/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml
index 3d64bed26..be4049a9c 100644
--- a/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml
+++ b/Documentation/devicetree/bindings/spi/st,stm32-spi.yaml
@@ -27,12 +27,18 @@ allOf:
     then:
       properties:
         st,spi-midi-ns: false
+        spi-slave: false
+        st,spi-slave-underrun: false
 
 properties:
+  "#address-cells": true
+  "#size-cells": true
+
   compatible:
     enum:
       - st,stm32f4-spi
       - st,stm32h7-spi
+      - st,stm32mp25-spi
 
   reg:
     maxItems: 1
@@ -46,6 +52,9 @@ properties:
   resets:
     maxItems: 1
 
+  power-domains:
+    maxItems: 1
+
   dmas:
     description: |
       DMA specifiers for tx and rx dma. DMA fifo mode must be used. See
@@ -59,6 +68,29 @@ properties:
       - const: rx
       - const: tx
 
+  spi-slave:
+    description:
+      The SPI controller acts as a slave, instead of a master.
+
+  cs-gpios:
+    description:
+      In case of spi-slave not defined, cs-gpios behave as defined in
+      spi-controller.yaml.
+      In case of spi-slave defined, if <0>, indicate that SS should be
+      detected via the dedicated HW pin
+
+  st,spi-slave-underrun:
+    $ref: /schemas/types.yaml#/definitions/uint32-array
+    description:
+      First parameter enables and selects slave underrun reaction.
+      Refer to "dt-bindings/spi/spi-stm32.h" for the supported values.
+      Second parameter is the pattern in case of SPI_SEND_PATTERN mode.
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 patternProperties:
   "^[a-zA-Z][a-zA-Z0-9,+\\-._]{0,63}@[0-9a-f]+$":
     type: object
@@ -67,7 +99,7 @@ patternProperties:
     properties:
       st,spi-midi-ns:
         description: |
-          Only for STM32H7, (Master Inter-Data Idleness) minimum time
+          Only available since STM32H7, (Master Inter-Data Idleness) minimum time
           delay in nanoseconds inserted between two consecutive data frames.
 
 required:
diff --git a/Documentation/devicetree/bindings/usb/dwc2.yaml b/Documentation/devicetree/bindings/usb/dwc2.yaml
index dc4988c00..ee0eb3907 100644
--- a/Documentation/devicetree/bindings/usb/dwc2.yaml
+++ b/Documentation/devicetree/bindings/usb/dwc2.yaml
@@ -72,11 +72,14 @@ properties:
     maxItems: 1
 
   clocks:
-    maxItems: 1
+    minItems: 1
+    maxItems: 2
 
   clock-names:
     items:
       - const: otg
+      - const: utmi
+    minItems: 1
 
   disable-over-current:
     type: boolean
@@ -165,6 +168,15 @@ properties:
 
   tpl-support: true
 
+  wakeup-source:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description: If present indicates this device has wakeup capabilities
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
 dependencies:
   port: [ usb-role-switch ]
   role-switch-default-mode: [ usb-role-switch ]
diff --git a/Documentation/devicetree/bindings/usb/generic-ehci.yaml b/Documentation/devicetree/bindings/usb/generic-ehci.yaml
index c5f629c5b..ebad4baf6 100644
--- a/Documentation/devicetree/bindings/usb/generic-ehci.yaml
+++ b/Documentation/devicetree/bindings/usb/generic-ehci.yaml
@@ -146,6 +146,11 @@ properties:
       - host
       - otg
 
+  wakeup-source:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description:
+      Indicate this device has wakeup capabilities.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/usb/generic-ohci.yaml b/Documentation/devicetree/bindings/usb/generic-ohci.yaml
index f838f78d6..21103ba71 100644
--- a/Documentation/devicetree/bindings/usb/generic-ohci.yaml
+++ b/Documentation/devicetree/bindings/usb/generic-ohci.yaml
@@ -118,6 +118,11 @@ properties:
       - host
       - otg
 
+  wakeup-source:
+    $ref: /schemas/types.yaml#/definitions/flag
+    description:
+      Indicate this device has wakeup capabilities.
+
 required:
   - compatible
   - reg
diff --git a/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml b/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml
index 1cb68cabe..3ba25957b 100644
--- a/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml
+++ b/Documentation/devicetree/bindings/usb/st,typec-stm32g0.yaml
@@ -10,13 +10,17 @@ description: |
   The STM32G0 MCU can be programmed to control Type-C connector(s) through I2C
   typically using the UCSI protocol over I2C, with a dedicated alert
   (interrupt) pin.
+  On STM32MP25, the co-processor can be used with a dedicated firmware to
+  achieve similar Type-C and Power Delivery functionality.
 
 maintainers:
   - Fabrice Gasnier <fabrice.gasnier@foss.st.com>
 
 properties:
   compatible:
-    const: st,stm32g0-typec
+    enum:
+      - st,stm32g0-typec
+      - st,stm32mp25-typec
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/usb/stm32,dwc3.yaml b/Documentation/devicetree/bindings/usb/stm32,dwc3.yaml
new file mode 100644
index 000000000..8ad90037c
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/stm32,dwc3.yaml
@@ -0,0 +1,108 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/stm32,dwc3.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 MPU DWC3 USB SoC controller
+
+description:
+  The STM32 MPU DWC3 USB SoC controller block supports both Host(SS/HS/FS/LS)
+  or Device(SS/HS/FS) mode operation
+
+maintainers:
+  - Fabrice Gasnier <fabrice.gasnier@foss.st.com>
+
+properties:
+  compatible:
+    const: st,stm32mp25-dwc3
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 1
+
+  ranges: true
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array #(arm/stm32/st,stm32-syscon.yaml#)
+    description: <Phandle to the STM32-MPU System Controller DT node> <offset-for-usr3drcr-reg>
+
+  st,vbusen-active-low:
+    type: boolean
+    description: VBUS-ENABLE signal polarity is active-low
+
+  st,ovrcur-active-low:
+    type: boolean
+    description: Over-Current signal polarity is active-low
+
+  st,enable-port-power-control:
+    type: boolean
+    description: Enable Host-Mode Port Power Control (bit-3 of capability param HCCPARAMS)
+
+  wakeup-source: true
+
+  interrupts:
+    maxItems: 1
+    description: interrupt used for wakeup
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+# Required child node:
+
+patternProperties:
+  "^usb@[0-9a-f]+$":
+    $ref: snps,dwc3.yaml#
+
+required:
+  - compatible
+  - "#address-cells"
+  - "#size-cells"
+  - ranges
+  - st,syscfg
+
+allOf:
+  - if:
+      required:
+        - wakeup-source
+    then:
+      anyOf:
+        - required: [interrupts]
+        - required: [interrupts-extended]
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+    usb3dr: usb@48300000 {
+        compatible      = "st,stm32mp25-dwc3";
+        st,syscfg       = <&syscfg 0x4800>;
+        #address-cells  = <1>;
+        #size-cells     = <1>;
+        ranges = <0x48300000 0x48300000 0x100000>;
+        st,ovrcur-active-low;
+        st,vbusen-active-low;
+        wakeup-source;
+        interrupts-extended = <&exti1 44 IRQ_TYPE_EDGE_RISING>;
+
+        dwc3: usb@48300000 {
+            compatible      = "snps,dwc3";
+            reg             = <0x48300000 0x100000>;
+            interrupts      = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+            clock-names     = "ref", "bus_early", "suspend";
+            clocks          = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DR>,
+                              <&rcc CK_KER_USB2PHY2>;
+            resets          = <&rcc USB3DR_R>;
+            phys            = <&usb2_phy>, <&usb3_phy>;
+            phy-names       = "usb2-phy", "usb3-phy";
+            wakeup-source;
+        };
+    };
diff --git a/Documentation/devicetree/bindings/usb/stm32,usbh.yaml b/Documentation/devicetree/bindings/usb/stm32,usbh.yaml
new file mode 100644
index 000000000..c452f44a3
--- /dev/null
+++ b/Documentation/devicetree/bindings/usb/stm32,usbh.yaml
@@ -0,0 +1,113 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/usb/stm32,usbh.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: STMicroelectronics STM32 MPU USB2 Host SoC controller
+
+maintainers:
+  - Pankaj Dev <pankaj.dev@st.com>
+
+properties:
+  compatible:
+    const: st,stm32mp25-usbh
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 1
+
+  ranges: true
+
+  st,syscfg:
+    $ref: /schemas/types.yaml#/definitions/phandle-array #(arm/stm32/st,stm32-syscon.yaml#)
+    description: Phandle to the STM32-MPU System Controller DT node
+                 <syscon-handle usbhcr-offset>
+
+  st,vbusen-active-low:
+    type: boolean
+    description: VBUS-ENABLE signal polarity is active-low
+
+  st,ovrcur-active-low:
+    type: boolean
+    description: Over-Current signal polarity is active-low
+
+  wakeup-source: true
+
+  interrupts:
+    maxItems: 1
+    description: interrupt used for wakeup
+
+  feature-domains:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    description: |
+      Phandle to the rifsc device to check access right.
+
+# Required child node:
+
+patternProperties:
+  "^usb@[0-9a-f]+$":
+    oneOf:
+      - $ref: generic-ohci.yaml#
+      - $ref: generic-ehci.yaml#
+
+required:
+  - compatible
+  - "#address-cells"
+  - "#size-cells"
+  - ranges
+  - st,syscfg
+
+allOf:
+  - if:
+      required:
+        - wakeup-source
+    then:
+      anyOf:
+        - required: [interrupts]
+        - required: [interrupts-extended]
+
+additionalProperties: false
+
+examples:
+  - |
+
+    #include <dt-bindings/clock/stm32mp25-clks.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/reset/stm32mp25-resets.h>
+
+
+    usbh: usb@482e0000 {
+        compatible      = "st,stm32mp25-usbh";
+        st,syscfg       = <&syscfg 0x2420>;
+        #address-cells  = <1>;
+        #size-cells     = <1>;
+        ranges = <0x482e0000 0x482e0000 0x2000>;
+        st,ovrcur-active-low;
+        st,vbusen-active-low;
+        wakeup-source;
+        interrupts-extended = <&exti1 43 IRQ_TYPE_EDGE_RISING>;
+
+        usbh_ohci: usb@482e0000 {
+            compatible = "generic-ohci";
+            reg = <0x482e0000 0x1000>;
+            clocks = <&rcc CK_BUS_USB2OHCI>;
+            resets = <&rcc USB2_R>;
+            interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+            phys = <&usb2_phy1>;
+            phy-names = "usb";
+        };
+
+        usbh_ehci: usb@482f0000 {
+            compatible = "generic-ehci";
+            reg = <0x482f0000 0x1000>;
+            clocks = <&rcc CK_BUS_USB2EHCI>;
+            resets = <&rcc USB2_R>;
+            interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+            companion = <&usbh_ohci>;
+            phys = <&usb2_phy1>;
+            phy-names = "usb";
+        };
+    };
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 6e323a380..a23441d7e 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -472,6 +472,8 @@ patternProperties:
     description: Fujitsu Ltd.
   "^fxtec,.*":
     description: FX Technology Ltd.
+  "^galaxycore,.*":
+    description: Galaxy Core Inc.
   "^gardena,.*":
     description: GARDENA GmbH
   "^gateworks,.*":
@@ -1093,6 +1095,8 @@ patternProperties:
     description: Shenzhen Roofull Technology Co, Ltd
   "^roseapplepi,.*":
     description: RoseapplePi.org
+  "^rpmsg,.*":
+    description: remote processor messaging Device Specification
   "^samsung,.*":
     description: Samsung Semiconductor
   "^samtec,.*":
@@ -1330,6 +1334,8 @@ patternProperties:
     description: TPO
   "^tq,.*":
     description: TQ-Systems GmbH
+  "^ttt,.*":
+    description: TTTech
   "^traverse,.*":
     description: Traverse Technologies Australia Pty Ltd
   "^tronfy,.*":
diff --git a/Documentation/i2c/busses/index.rst b/Documentation/i2c/busses/index.rst
index 5e4077b08..371126554 100644
--- a/Documentation/i2c/busses/index.rst
+++ b/Documentation/i2c/busses/index.rst
@@ -29,4 +29,5 @@ I2C Bus Drivers
    i2c-taos-evm
    i2c-viapro
    i2c-via
+   rpmsg-i2c
    scx200_acb
diff --git a/Documentation/i2c/busses/rpmsg_i2c.rst b/Documentation/i2c/busses/rpmsg_i2c.rst
new file mode 100644
index 000000000..5fc88946d
--- /dev/null
+++ b/Documentation/i2c/busses/rpmsg_i2c.rst
@@ -0,0 +1,51 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+=======================
+Kernel driver rpmsg_i2c
+=======================
+
+Author: Maxime Mr for STMicroelectronics <maxime.mere@st.com>
+
+Description
+-----------
+
+rpmsg_i2c is a virtual I2C bus driver based on rpmsg framework.
+It allows user to communicate with a remote processor like if it was connected
+on an I2C bus.
+
+This driver was initially designed to grant linux side to emulate I2C connection
+with her internal coprocessor.
+
+Message exchanged to emulate the I2C communication must respect the following
+structure:
+
+struct rpmsg_i2c_msg {
+	u8 addr;
+	u32 count;
+	u8 result;
+	u8 buf[0];
+};
+
+addr corresponds to the i2c slave address + the R/W bit, count is the number of
+bytes contained inside the buffer, result is a flag used by the slave to indicate
+an ACK or a NACK and buf is the data container.
+
+This driver supports only the master mode, meaning that virtual devices defined in
+the coprocessor are slave only. A communication between a slave and its master
+works as follow:
+
+In case of write:
+
+	- the master sends the structure with the R/W bit low and the appropriate
+	  "count" and "buffer" value and then wait for an ACK
+
+	- the slave sends an empty rpmsg_i2c struct, except for "result" which will
+	  be set to an ACK or a NACK
+
+In case of read:
+
+	- the master sends the structure with the R/W bit high and the others
+	  fields empty and wait for the slave reply
+
+	- the slave sends the structure back with the appropriate count and buffer
+	  value and result is set to ACK
diff --git a/Documentation/locking/hwspinlock.rst b/Documentation/locking/hwspinlock.rst
index 6f03713b7..605bd2dc8 100644
--- a/Documentation/locking/hwspinlock.rst
+++ b/Documentation/locking/hwspinlock.rst
@@ -54,9 +54,11 @@ Should be called from a process context (might sleep).
   struct hwspinlock *hwspin_lock_request_specific(unsigned int id);
 
 Assign a specific hwspinlock id and return its address, or NULL
-if that hwspinlock is already in use. Usually board code will
-be calling this function in order to reserve specific hwspinlock
-ids for predefined purposes.
+if that hwspinlock is already in use and not shared. If that specific
+hwspinlock is declared as shared, it can be requested and used by
+several users.
+Usually board code will be calling this function in order to reserve
+specific hwspinlock ids for predefined purposes.
 
 Should be called from a process context (might sleep).
 
@@ -449,11 +451,13 @@ of which represents a single hardware lock::
 	* struct hwspinlock - this struct represents a single hwspinlock instance
 	* @bank: the hwspinlock_device structure which owns this lock
 	* @lock: initialized and used by hwspinlock core
+	* @refcount: number of users (when shared)
 	* @priv: private data, owned by the underlying platform-specific hwspinlock drv
 	*/
 	struct hwspinlock {
 		struct hwspinlock_device *bank;
 		spinlock_t lock;
+		unsigned int refcount;
 		void *priv;
 	};
 
diff --git a/Documentation/staging/remoteproc.rst b/Documentation/staging/remoteproc.rst
index 348ee7e50..fadd42edb 100644
--- a/Documentation/staging/remoteproc.rst
+++ b/Documentation/staging/remoteproc.rst
@@ -358,3 +358,25 @@ Of course, RSC_VDEV resource entries are only good enough for static
 allocation of virtio devices. Dynamic allocations will also be made possible
 using the rpmsg bus (similar to how we already do dynamic allocations of
 rpmsg channels; read more about it in rpmsg.txt).
+
+8. System Resource Manager (SRM)
+
+Since some resources are shared (directly or not) between the processors, a
+processor cannot manage such resources without potentially impacting the other
+processors : as an example, if a processor changes the frequency of a clock, the
+frequency of another clock managed by another processor may be updated too.
+
+The System Resource Manager prevents such resource conflicts between the
+processors : it reserves and initializes the system resources of the peripherals
+assigned to a remote processor.
+
+As of today the following resources are controlled by the SRM:
+- clocks
+- regulators (power supplies)
+
+The SRM is implemented as an 'rproc_subdev' and registered to remoteproc_core.
+Unlike the virtio device (vdev), the SRM subdev is probed *before* the rproc
+boots, ensuring the availability of the resources before the remoteproc starts.
+
+The resources handled by the SRM are defined in the DeviceTree: please read
+Documentation/devicetree/bindings/remoteproc/rproc-srm.txt for details.
diff --git a/MAINTAINERS b/MAINTAINERS
index bbfedb0b2..322338f4e 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -8500,6 +8500,14 @@ F:	kernel/futex/*
 F:	tools/perf/bench/futex*
 F:	tools/testing/selftests/futex/
 
+GALAXYCORE GC2145 SENSOR DRIVER
+M:	Alain Volmat <alain.volmat@foss.st.com>
+L:	linux-media@vger.kernel.org
+S:	Maintained
+T:	git git://linuxtv.org/media_tree.git
+F:	Documentation/devicetree/bindings/media/i2c/galaxycore,gc2145.yaml
+F:	drivers/media/i2c/gc2145.c
+
 GATEWORKS SYSTEM CONTROLLER (GSC) DRIVER
 M:	Tim Harvey <tharvey@gateworks.com>
 S:	Maintained
@@ -12865,6 +12873,14 @@ W:	https://linuxtv.org
 T:	git git://linuxtv.org/media_tree.git
 F:	drivers/media/dvb-frontends/stv6111*
 
+MEDIA DRIVERS FOR STM32 - CSI2HOST
+M:	Alain Volmat <alain.volmat@foss.st.com>
+L:	linux-media@vger.kernel.org
+S:	Supported
+T:	git git://linuxtv.org/media_tree.git
+F:	Documentation/devicetree/bindings/media/st,stm32-csi2host.yaml
+F:	drivers/media/platform/stm32/stm32-csi2host.c
+
 MEDIA DRIVERS FOR STM32 - DCMI
 M:	Hugues Fruchet <hugues.fruchet@foss.st.com>
 L:	linux-media@vger.kernel.org
@@ -12873,6 +12889,15 @@ T:	git git://linuxtv.org/media_tree.git
 F:	Documentation/devicetree/bindings/media/st,stm32-dcmi.yaml
 F:	drivers/media/platform/st/stm32/stm32-dcmi.c
 
+MEDIA DRIVERS FOR STM32 - DCMIPP
+M:	Hugues Fruchet <hugues.fruchet@foss.st.com>
+M:	Alain Volmat <alain.volmat@foss.st.com>
+L:	linux-media@vger.kernel.org
+S:	Supported
+T:	git git://linuxtv.org/media_tree.git
+F:	Documentation/devicetree/bindings/media/st,stm32-dcmipp.yaml
+F:	drivers/media/platform/st/stm32/stm32-dcmipp/*
+
 MEDIA INPUT INFRASTRUCTURE (V4L/DVB)
 M:	Mauro Carvalho Chehab <mchehab@kernel.org>
 L:	linux-media@vger.kernel.org
@@ -19520,6 +19545,13 @@ T:	git git://linuxtv.org/media_tree.git
 F:	Documentation/devicetree/bindings/media/i2c/st,st-mipid02.txt
 F:	drivers/media/i2c/st-mipid02.c
 
+ST STM32 HDP PINCTRL DRIVER
+M:	Clment Le Goffic <clement.legoffic@foss.st.com>
+S:	Maintained
+F:	Documentation/devicetree/bindings/pinctrl/st,stm32-pinctrl-hdp.yaml
+F:	drivers/pinctrl/stm32/pinctrl-stm32-hdp.c
+F:	include/dt-bindings/pinctrl/stm32mp*-hdp.h
+
 ST STM32 I2C/SMBUS DRIVER
 M:	Pierre-Yves MORDRET <pierre-yves.mordret@foss.st.com>
 M:	Alain Volmat <alain.volmat@foss.st.com>
@@ -19710,6 +19742,21 @@ F:	Documentation/devicetree/bindings/iio/adc/st,stm32-dfsdm-adc.yaml
 F:	Documentation/devicetree/bindings/sound/st,stm32-*.yaml
 F:	sound/soc/stm/
 
+STM32 DMA DRIVERS
+M:	Amelie Delaunay <amelie.delaunay@foss.st.com>
+L:	dmaengine@vger.kernel.org
+L:	linux-stm32@st-md-mailman.stormreply.com (moderated for non-subscribers)
+S:	Maintained
+F:	Documentation/arch/arm/stm32/stm32-dma-mdma-chaining.rst
+F:	Documentation/devicetree/bindings/dma/stm32/
+F:	drivers/dma/stm32/
+
+STM32 TAMP DRIVERS
+M:	Simon Marijon <simeon.marijon@foss.st.com>
+S:	Maintained
+F:	Documentation/devicetree/bindings/nvmem/st,stm32-tamp-nvram.yaml
+F:	drivers/nvmem/stm32-tamp-nvram.c
+
 STM32 TIMER/LPTIMER DRIVERS
 M:	Fabrice Gasnier <fabrice.gasnier@foss.st.com>
 S:	Maintained
diff --git a/Makefile b/Makefile
index c5345f3eb..50c77e591 100644
--- a/Makefile
+++ b/Makefile
@@ -1461,17 +1461,42 @@ ifneq ($(wildcard $(srctree)/arch/$(SRCARCH)/boot/dts/),)
 dtstree := arch/$(SRCARCH)/boot/dts
 endif
 
-ifneq ($(dtstree),)
+ifdef CONFIG_ARCH_STM32
+ifeq ("$(SRCARCH)", "arm")
+export TARGET_ARM32=y
+stdtstree := $(dtstree)
+else ifeq ("$(SRCARCH)", "arm64")
+export TARGET_ARM64=y
+stdtstree := $(dtstree)/st
+endif
+
+# Default path for external device trees
+KBUILD_EXTDTS ?= $(realpath $(srctree))/$(stdtstree)/external-dt/linux
+ifneq ($(wildcard $(KBUILD_EXTDTS)),)
+export DTS_INCLUDE := $(srctree)/$(stdtstree)
+endif
+endif #ARCH_STM32
+
+ifneq ($(stdtstree),)
+
+KBUILD_EXTDTB := $(or $(and $(wildcard $(KBUILD_EXTDTS)), 1), 0)
 
 %.dtb: dtbs_prepare
-	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@
+	$(Q)$(MAKE) $(build)=$(stdtstree) $(dtstree)/$@ || ( \
+	test ! -e $(dtstree)/$@ -a $(KBUILD_EXTDTB) -eq 1  && ( \
+		echo "Looking for $(patsubst st/%.dtb,%.dtb,$@) into $(KBUILD_EXTDTS)"; \
+		$(MAKE) $(build)=$(stdtstree) src=$(KBUILD_EXTDTS) $(dtstree)/$@ || \
+		/bin/false) || /bin/false)
 
 %.dtbo: dtbs_prepare
 	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@
 
 PHONY += dtbs dtbs_prepare dtbs_install dtbs_check
 dtbs: dtbs_prepare
-	$(Q)$(MAKE) $(build)=$(dtstree)
+	$(Q)$(MAKE) $(build)=$(stdtstree)
+	$(Q)test $(KBUILD_EXTDTB) -eq 0 || ( \
+		echo "Looking for device trees into $(KBUILD_EXTDTS)"; \
+		$(MAKE) $(build)=$(stdtstree) src=$(KBUILD_EXTDTS) || /bin/false)
 
 # include/config/kernel.release is actually needed when installing DTBs because
 # INSTALL_DTBS_PATH contains $(KERNELRELEASE). However, we do not want to make
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 000000000..4b3e4e6ba
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,8 @@
+# Report potential product security vulnerabilities
+ST places a high priority on security, and our Product Security Incident Response Team (PSIRT) is committed to rapidly addressing potential security vulnerabilities affecting our products. PSIRT's long history and vast experience in security allows ST to perform clear analyses and provide appropriate guidance on mitigations  and solutions when applicable.
+If you wish to report potential security vulnerabilities regarding our products, **please do not report them through public GitHub issues.** Instead, we encourage you to report them to our ST PSIRT following the process described at: **https://www.st.com/content/st_com/en/security/report-vulnerabilities.html**
+
+### IMPORTANT - READ CAREFULLY:
+STMicroelectronics International N.V., on behalf of itself, its affiliates and  subsidiaries, (collectively ST) takes all potential security vulnerability reports or other related communications (Report(s))  seriously. In order to review Your Report (the terms You and Yours  include your employer, and all affiliates, subsidiaries and related  persons or entities) and take actions as deemed appropriate, ST requires that we have the rights and Your permission to do so.
+As such, by submitting Your Report to ST, You agree that You have the right to do so, and You grant to ST the rights to use the Report for purposes related to security vulnerability analysis, testing, correction, patching, reporting and any other related purpose or function.
+By submitting Your Report, You agree that STs [Privacy Policy](https://www.st.com/content/st_com/en/common/privacy-portal.html) applies to all related communications.
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index df6d905ee..0fe3d02a5 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -1215,6 +1215,7 @@ dtb-$(CONFIG_ARCH_STM32) += \
 	stm32h743i-disco.dtb \
 	stm32h750i-art-pi.dtb \
 	stm32mp135f-dk.dtb \
+	stm32mp135f-dk-a7-examples.dtb \
 	stm32mp151a-prtt1a.dtb \
 	stm32mp151a-prtt1c.dtb \
 	stm32mp151a-prtt1s.dtb \
@@ -1223,7 +1224,12 @@ dtb-$(CONFIG_ARCH_STM32) += \
 	stm32mp157a-avenger96.dtb \
 	stm32mp157a-dhcor-avenger96.dtb \
 	stm32mp157a-dk1.dtb \
-	stm32mp157a-dk1-scmi.dtb \
+	stm32mp157a-dk1-a7-examples.dtb \
+	stm32mp157a-dk1-m4-examples.dtb \
+	stm32mp157a-ed1.dtb \
+	stm32mp157a-ev1.dtb \
+	stm32mp157a-ev1-a7-examples.dtb \
+	stm32mp157a-ev1-m4-examples.dtb \
 	stm32mp157a-iot-box.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dtb \
@@ -1234,14 +1240,29 @@ dtb-$(CONFIG_ARCH_STM32) += \
 	stm32mp157c-dhcom-pdk2.dtb \
 	stm32mp157c-dhcom-picoitx.dtb \
 	stm32mp157c-dk2.dtb \
-	stm32mp157c-dk2-scmi.dtb \
+	stm32mp157c-dk2-a7-examples.dtb \
+	stm32mp157c-dk2-m4-examples.dtb \
 	stm32mp157c-ed1.dtb \
-	stm32mp157c-ed1-scmi.dtb \
 	stm32mp157c-emsbc-argon.dtb \
 	stm32mp157c-ev1.dtb \
-	stm32mp157c-ev1-scmi.dtb \
+	stm32mp157c-ev1-a7-examples.dtb \
+	stm32mp157c-ev1-m4-examples.dtb \
 	stm32mp157c-lxa-mc1.dtb \
-	stm32mp157c-odyssey.dtb
+	stm32mp157c-odyssey.dtb \
+	stm32mp157d-dk1.dtb \
+	stm32mp157d-dk1-a7-examples.dtb \
+	stm32mp157d-dk1-m4-examples.dtb \
+	stm32mp157d-ed1.dtb \
+	stm32mp157d-ev1.dtb \
+	stm32mp157d-ev1-a7-examples.dtb \
+	stm32mp157d-ev1-m4-examples.dtb \
+	stm32mp157f-dk2.dtb \
+	stm32mp157f-dk2-a7-examples.dtb \
+	stm32mp157f-dk2-m4-examples.dtb \
+	stm32mp157f-ed1.dtb \
+	stm32mp157f-ev1.dtb \
+	stm32mp157f-ev1-a7-examples.dtb \
+	stm32mp157f-ev1-m4-examples.dtb
 dtb-$(CONFIG_MACH_SUN4I) += \
 	sun4i-a10-a1000.dtb \
 	sun4i-a10-ba10-tvbox.dtb \
diff --git a/arch/arm/boot/dts/stm32h743.dtsi b/arch/arm/boot/dts/stm32h743.dtsi
index 2059593da..28e3deb20 100644
--- a/arch/arm/boot/dts/stm32h743.dtsi
+++ b/arch/arm/boot/dts/stm32h743.dtsi
@@ -375,7 +375,6 @@ sdmmc1: mmc@52007000 {
 			arm,primecell-periphid = <0x10153180>;
 			reg = <0x52007000 0x1000>;
 			interrupts = <49>;
-			interrupt-names = "cmd_irq";
 			clocks = <&rcc SDMMC1_CK>;
 			clock-names = "apb_pclk";
 			resets = <&rcc STM32H7_AHB3_RESET(SDMMC1)>;
@@ -389,7 +388,6 @@ sdmmc2: mmc@48022400 {
 			arm,primecell-periphid = <0x10153180>;
 			reg = <0x48022400 0x400>;
 			interrupts = <124>;
-			interrupt-names = "cmd_irq";
 			clocks = <&rcc SDMMC2_CK>;
 			clock-names = "apb_pclk";
 			resets = <&rcc STM32H7_AHB2_RESET(SDMMC2)>;
diff --git a/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi
index efdd163eb..6a7ae1447 100644
--- a/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi
+++ b/arch/arm/boot/dts/stm32mp13-pinctrl.dtsi
@@ -6,6 +6,163 @@
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
 
 &pinctrl {
+	adc1_usb_cc_pins_a: adc1-usb-cc-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1 in6 */
+				 <STM32_PINMUX('A', 3, ANALOG)>; /* ADC1 in12 */
+		};
+	};
+
+	dcmipp_pins_a: dcmi-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  AF13)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  AF13)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  AF14)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  AF13)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  AF13)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  AF13)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  AF13)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  AF14)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  AF13)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  AF13)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  AF13)>;/* DCMI_D7 */
+			bias-disable;
+		};
+	};
+
+	dcmipp_sleep_pins_a: dcmi-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  ANALOG)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  ANALOG)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  ANALOG)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  ANALOG)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  ANALOG)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  ANALOG)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  ANALOG)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  ANALOG)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  ANALOG)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  ANALOG)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  ANALOG)>;/* DCMI_D7 */
+		};
+	};
+
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	dfsdm_datin1_pins_a: dfsdm-datin1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF6)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin1_sleep_pins_a: dfsdm-datin1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin3_pins_a: dfsdm-datin3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	dfsdm_datin3_sleep_pins_a: dfsdm-datin3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	eth1_rmii_pins_a: eth1-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, AF10)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+
+	};
+
+	eth1_rmii_sleep_pins_a: eth1-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	eth2_rmii_pins_a: eth2-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, AF10)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, AF13)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, AF10)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, AF11)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+	};
+
+	eth2_rmii_sleep_pins_a: eth2-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	goodix_pins_a: goodix-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 5, GPIO)>;
+			bias-pull-down;
+		};
+	};
+
 	i2c1_pins_a: i2c1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
@@ -40,6 +197,157 @@ pins {
 		};
 	};
 
+	ltdc_pins_a: ltdc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, AF13)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, AF14)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, AF11)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, AF11)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, AF14)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, AF13)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, AF14)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, AF14)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, AF14)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, AF14)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, AF14)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, AF14)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, AF14)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, AF14)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, AF11)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, AF14)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, AF14)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, AF11)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, AF14)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, AF7)>,  /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, AF13)>; /* LCD_B7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ltdc_sleep_pins_a: ltdc-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, ANALOG)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, ANALOG)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, ANALOG)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, ANALOG)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, ANALOG)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, ANALOG)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, ANALOG)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, ANALOG)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, ANALOG)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, ANALOG)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, ANALOG)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, ANALOG)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, ANALOG)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, ANALOG)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, ANALOG)>, /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, ANALOG)>; /* LCD_B7 */
+		};
+	};
+
+	mcp23017_pins_a: mcp23017-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, GPIO)>;
+			bias-pull-up;
+		};
+	};
+
+	pwm3_pins_a: pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF2)>; /* TIM3_CH4 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm3_sleep_pins_a: pwm3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* TIM3_CH4 */
+		};
+	};
+
+	pwm4_pins_a: pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, AF2)>; /* TIM4_CH2 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm4_sleep_pins_a: pwm4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, ANALOG)>; /* TIM4_CH2 */
+		};
+	};
+
+	pwm8_pins_a: pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, AF3)>; /* TIM8_CH3 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm8_sleep_pins_a: pwm8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, ANALOG)>; /* TIM8_CH3 */
+		};
+	};
+
+	pwm14_pins_a: pwm14-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 9, AF9)>; /* TIM14_CH1 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm14_sleep_pins_a: pwm14-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 9, ANALOG)>; /* TIM14_CH1 */
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 1, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1_pins_a: sai1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, AF12)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, AF6)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, AF6)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, AF6)>; /* SAI1_FS_A */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sai1_sleep_pins_a: sai1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, ANALOG)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, ANALOG)>; /* SAI1_FS_A */
+		};
+	};
+
 	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -165,6 +473,13 @@ pins {
 		};
 	};
 
+	stm32g0_intn_pins_a: stm32g0-intn-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, GPIO)>;
+			bias-pull-up;
+		};
+	};
+
 	uart4_pins_a: uart4-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('D', 6, AF8)>; /* UART4_TX */
@@ -177,4 +492,133 @@ pins2 {
 			bias-disable;
 		};
 	};
+
+	uart4_idle_pins_a: uart4-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>; /* UART4_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 8, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	uart4_sleep_pins_a: uart4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>, /* UART4_TX */
+				 <STM32_PINMUX('D', 8, ANALOG)>; /* UART4_RX */
+		};
+	};
+
+	uart8_pins_a: uart8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, AF8)>; /* UART8_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart8_idle_pins_a: uart8-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>; /* UART8_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart8_sleep_pins_a: uart8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>, /* UART8_TX */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* UART8_RX */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, AF7)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>, /* USART1_RX */
+				 <STM32_PINMUX('A', 7, AF7)>; /* USART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('A', 7, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>; /* USART1_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* USART1_RTS */
+				 <STM32_PINMUX('A', 7, ANALOG)>, /* USART1_CTS_NSS */
+				 <STM32_PINMUX('B', 0, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 12, AF1)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, AF3)>; /* USART2_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>, /* USART2_RX */
+				 <STM32_PINMUX('E', 11, AF2)>; /* USART2_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 12, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('E', 11, ANALOG)>; /* USART2_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 4, AF3)>; /* USART2_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 12, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 15, ANALOG)>, /* USART2_RX */
+				 <STM32_PINMUX('E', 11, ANALOG)>; /* USART2_CTS_NSS */
+		};
+	};
 };
diff --git a/arch/arm/boot/dts/stm32mp131.dtsi b/arch/arm/boot/dts/stm32mp131.dtsi
index 723787f72..108ac5d6f 100644
--- a/arch/arm/boot/dts/stm32mp131.dtsi
+++ b/arch/arm/boot/dts/stm32mp131.dtsi
@@ -3,9 +3,12 @@
  * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
+#include <dt-bindings/bus/stm32mp13_sys_bus.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/clock/stm32mp13-clks.h>
+#include <dt-bindings/regulator/st,stm32mp13-regulator.h>
 #include <dt-bindings/reset/stm32mp13-resets.h>
+#include <dt-bindings/thermal/thermal.h>
 
 / {
 	#address-cells = <1>;
@@ -19,9 +22,22 @@ cpu0: cpu@0 {
 			compatible = "arm,cortex-a7";
 			device_type = "cpu";
 			reg = <0>;
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
 		};
 	};
 
+	intc: interrupt-controller@a0021000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0xa0021000 0x1000>,
+		      <0xa0022000 0x2000>;
+	};
+
 	arm-pmu {
 		compatible = "arm,cortex-a7-pmu";
 		interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
@@ -29,10 +45,35 @@ arm-pmu {
 		interrupt-parent = <&intc>;
 	};
 
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xb200005a>;
+		status = "disabled";
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		interrupt-parent = <&intc>;
+		always-on;
+	};
+
 	firmware {
-		optee {
+		optee: optee {
 			method = "smc";
 			compatible = "linaro,optee-tz";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
 		};
 
 		scmi: scmi {
@@ -40,7 +81,11 @@ scmi: scmi {
 			#address-cells = <1>;
 			#size-cells = <0>;
 			linaro,optee-channel-id = <0>;
-			shmem = <&scmi_shm>;
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
 
 			scmi_clk: protocol@14 {
 				reg = <0x14>;
@@ -51,30 +96,77 @@ scmi_reset: protocol@16 {
 				reg = <0x16>;
 				#reset-cells = <1>;
 			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_reg11: regulator@0 {
+						reg = <VOLTD_SCMI_REG11>;
+						regulator-name = "reg11";
+					};
+					scmi_reg18: regulator@1 {
+						reg = <VOLTD_SCMI_REG18>;
+						regulator-name = "reg18";
+					};
+					scmi_usb33: regulator@2 {
+						reg = <VOLTD_SCMI_USB33>;
+						regulator-name = "usb33";
+					};
+				};
+			};
 		};
 	};
 
-	intc: interrupt-controller@a0021000 {
-		compatible = "arm,cortex-a7-gic";
-		#interrupt-cells = <3>;
-		interrupt-controller;
-		reg = <0xa0021000 0x1000>,
-		      <0xa0022000 0x2000>;
-	};
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
 
-	psci {
-		compatible = "arm,psci-1.0";
-		method = "smc";
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
+		};
 	};
 
-	timer {
-		compatible = "arm,armv7-timer";
-		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
-		interrupt-parent = <&intc>;
-		always-on;
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&dts>;
+
+			trips {
+				cpu_alert: cpu-alert0 {
+					temperature = <95000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+				cpu_crit: cpu-crit0 {
+					temperature = <120000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 1 1>;
+				};
+			};
+		};
 	};
 
 	soc {
@@ -84,17 +176,241 @@ soc {
 		interrupt-parent = <&intc>;
 		ranges;
 
-		scmi_sram: sram@2ffff000 {
-			compatible = "mmio-sram";
-			reg = <0x2ffff000 0x1000>;
+		timers2: timer@40000000 {
 			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x2ffff000 0x1000>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40000000 0x400>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 18 0x400 0x1>,
+			       <&dmamux1 19 0x400 0x1>,
+			       <&dmamux1 20 0x400 0x1>,
+			       <&dmamux1 21 0x400 0x1>,
+			       <&dmamux1 22 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@1 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <1>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers3: timer@40001000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40001000 0x400>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 23 0x400 0x1>,
+			       <&dmamux1 24 0x400 0x1>,
+			       <&dmamux1 25 0x400 0x1>,
+			       <&dmamux1 26 0x400 0x1>,
+			       <&dmamux1 27 0x400 0x1>,
+			       <&dmamux1 28 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@2 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <2>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers4: timer@40002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40002000 0x400>;
+			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 29 0x400 0x1>,
+			       <&dmamux1 30 0x400 0x1>,
+			       <&dmamux1 31 0x400 0x1>,
+			       <&dmamux1 32 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@3 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <3>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers5: timer@40003000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40003000 0x400>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 55 0x400 0x1>,
+			       <&dmamux1 56 0x400 0x1>,
+			       <&dmamux1 57 0x400 0x1>,
+			       <&dmamux1 58 0x400 0x1>,
+			       <&dmamux1 59 0x400 0x1>,
+			       <&dmamux1 60 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@4 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <4>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers6: timer@40004000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40004000 0x400>;
+			interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 69 0x400 0x1>;
+			dma-names = "up";
+			status = "disabled";
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+
+			timer@5 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <5>;
+				status = "disabled";
+			};
+		};
+
+		timers7: timer@40005000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40005000 0x400>;
+			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 70 0x400 0x1>;
+			dma-names = "up";
+			status = "disabled";
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+
+			timer@6 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <6>;
+				status = "disabled";
+			};
+		};
+
+		lptimer1: timer@40009000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-lptimer";
+			reg = <0x40009000 0x400>;
+			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
 
-			scmi_shm: scmi-sram@0 {
-				compatible = "arm,scmi-shmem";
-				reg = <0 0x80>;
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
 			};
+
+			trigger@0 {
+				compatible = "st,stm32-lptimer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		i2s2: audio-controller@4000b000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000b000 0x400>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
 		};
 
 		spi2: spi@4000b000 {
@@ -111,6 +427,17 @@ spi2: spi@4000b000 {
 			status = "disabled";
 		};
 
+		i2s3: audio-controller@4000c000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000c000 0x400>;
+			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 61 0x400 0x01>,
+			       <&dmamux1 62 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
 		spi3: spi@4000c000 {
 			compatible = "st,stm32h7-spi";
 			reg = <0x4000c000 0x400>;
@@ -125,12 +452,58 @@ spi3: spi@4000c000 {
 			status = "disabled";
 		};
 
+		spdifrx: audio-controller@4000d000 {
+			compatible = "st,stm32h7-spdifrx";
+			#sound-dai-cells = <0>;
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 93 0x400 0x01>,
+			       <&dmamux1 94 0x400 0x01>;
+			dma-names = "rx", "rx-ctrl";
+			status = "disabled";
+		};
+
+		usart3: serial@4000f000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4000f000 0x400>;
+			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART3_K>;
+			resets = <&rcc USART3_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 45 0x400 0x5>,
+			       <&dmamux1 46 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
 		uart4: serial@40010000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x40010000 0x400>;
-			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc UART4_K>;
 			resets = <&rcc UART4_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 63 0x400 0x5>,
+			       <&dmamux1 64 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart5: serial@40011000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40011000 0x400>;
+			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART5_K>;
+			resets = <&rcc UART5_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 65 0x400 0x5>,
+			       <&dmamux1 66 0x400 0x1>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
@@ -170,6 +543,141 @@ i2c2: i2c@40013000 {
 			status = "disabled";
 		};
 
+		uart7: serial@40018000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40018000 0x400>;
+			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART7_K>;
+			resets = <&rcc UART7_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 79 0x400 0x5>,
+			       <&dmamux1 80 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart8: serial@40019000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40019000 0x400>;
+			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART8_K>;
+			resets = <&rcc UART8_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 81 0x400 0x5>,
+			       <&dmamux1 82 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		timers1: timer@44000000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x44000000 0x400>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "brk", "up", "trg-com", "cc";
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 11 0x400 0x1>,
+			       <&dmamux1 12 0x400 0x1>,
+			       <&dmamux1 13 0x400 0x1>,
+			       <&dmamux1 14 0x400 0x1>,
+			       <&dmamux1 15 0x400 0x1>,
+			       <&dmamux1 16 0x400 0x1>,
+			       <&dmamux1 17 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@0 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers8: timer@44001000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x44001000 0x400>;
+			interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "brk", "up", "trg-com", "cc";
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 47 0x400 0x1>,
+			       <&dmamux1 48 0x400 0x1>,
+			       <&dmamux1 49 0x400 0x1>,
+			       <&dmamux1 50 0x400 0x1>,
+			       <&dmamux1 51 0x400 0x1>,
+			       <&dmamux1 52 0x400 0x1>,
+			       <&dmamux1 53 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@7 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <7>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		usart6: serial@44003000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x44003000 0x400>;
+			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART6_K>;
+			resets = <&rcc USART6_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 71 0x400 0x5>,
+			       <&dmamux1 72 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: audio-controller@44004000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x44004000 0x400>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 37 0x400 0x01>,
+			       <&dmamux1 38 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
 		spi1: spi@44004000 {
 			compatible = "st,stm32h7-spi";
 			reg = <0x44004000 0x400>;
@@ -184,6 +692,99 @@ spi1: spi@44004000 {
 			status = "disabled";
 		};
 
+		sai1: sai@4400a000 {
+			compatible = "st,stm32h7-sai";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x4400a000 0x400>;
+			reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
+			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI1_R>;
+			status = "disabled";
+
+			sai1a: audio-controller@4400a004 {
+				#sound-dai-cells = <0>;
+
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				clocks = <&rcc SAI1_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 87 0x400 0x01>;
+				status = "disabled";
+			};
+
+			sai1b: audio-controller@4400a024 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				clocks = <&rcc SAI1_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 88 0x400 0x01>;
+				status = "disabled";
+			};
+		};
+
+		sai2: sai@4400b000 {
+			compatible = "st,stm32h7-sai";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x4400b000 0x400>;
+			reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
+			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI2_R>;
+			status = "disabled";
+
+			sai2a: audio-controller@4400b004 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				clocks = <&rcc SAI2_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 89 0x400 0x01>;
+				status = "disabled";
+			};
+
+			sai2b: audio-controller@4400b024 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				clocks = <&rcc SAI2_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 90 0x400 0x01>;
+				status = "disabled";
+			};
+		};
+
+		dfsdm: dfsdm@4400d000 {
+			compatible = "st,stm32mp1-dfsdm";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>;
+			clock-names = "dfsdm";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			dfsdm0: filter@0 {
+				compatible = "st,stm32-dfsdm-adc";
+				#io-channel-cells = <1>;
+				reg = <0>;
+				interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 101 0x400 0x01>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+
+			dfsdm1: filter@1 {
+				compatible = "st,stm32-dfsdm-adc";
+				#io-channel-cells = <1>;
+				reg = <1>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 102 0x400 0x01>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+		};
+
 		dma1: dma-controller@48000000 {
 			compatible = "st,stm32-dma";
 			reg = <0x48000000 0x400>;
@@ -231,201 +832,25 @@ dmamux1: dma-router@48002000 {
 			dma-channels = <16>;
 		};
 
-		spi4: spi@4c002000 {
-			compatible = "st,stm32h7-spi";
-			reg = <0x4c002000 0x400>;
-			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI4_K>;
-			resets = <&rcc SPI4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 83 0x400 0x01>,
-			       <&dmamux1 84 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				 <&scmi_clk CK_SCMI_HSI>,
+				 <&scmi_clk CK_SCMI_CSI>,
+				 <&scmi_clk CK_SCMI_LSE>,
+				 <&scmi_clk CK_SCMI_LSI>;
 		};
 
-		spi5: spi@4c003000 {
-			compatible = "st,stm32h7-spi";
-			reg = <0x4c003000 0x400>;
-			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI5_K>;
-			resets = <&rcc SPI5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 85 0x400 0x01>,
-			       <&dmamux1 86 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
-
-		i2c3: i2c@4c004000 {
-			compatible = "st,stm32mp13-i2c";
-			reg = <0x4c004000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C3_K>;
-			resets = <&rcc I2C3_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 73 0x400 0x1>,
-			       <&dmamux1 74 0x400 0x1>;
-			dma-names = "rx", "tx";
-			st,syscfg-fmp = <&syscfg 0x4 0x4>;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
-		i2c4: i2c@4c005000 {
-			compatible = "st,stm32mp13-i2c";
-			reg = <0x4c005000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C4_K>;
-			resets = <&rcc I2C4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 75 0x400 0x1>,
-			       <&dmamux1 76 0x400 0x1>;
-			dma-names = "rx", "tx";
-			st,syscfg-fmp = <&syscfg 0x4 0x8>;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
-		i2c5: i2c@4c006000 {
-			compatible = "st,stm32mp13-i2c";
-			reg = <0x4c006000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C5_K>;
-			resets = <&rcc I2C5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			dmas = <&dmamux1 115 0x400 0x1>,
-			       <&dmamux1 116 0x400 0x1>;
-			dma-names = "rx", "tx";
-			st,syscfg-fmp = <&syscfg 0x4 0x10>;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
-		rcc: rcc@50000000 {
-			compatible = "st,stm32mp13-rcc", "syscon";
-			reg = <0x50000000 0x1000>;
-			#clock-cells = <1>;
-			#reset-cells = <1>;
-			clock-names = "hse", "hsi", "csi", "lse", "lsi";
-			clocks = <&scmi_clk CK_SCMI_HSE>,
-				 <&scmi_clk CK_SCMI_HSI>,
-				 <&scmi_clk CK_SCMI_CSI>,
-				 <&scmi_clk CK_SCMI_LSE>,
-				 <&scmi_clk CK_SCMI_LSI>;
-		};
-
-		exti: interrupt-controller@5000d000 {
-			compatible = "st,stm32mp13-exti", "syscon";
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			reg = <0x5000d000 0x400>;
-		};
-
-		syscfg: syscon@50020000 {
-			compatible = "st,stm32mp157-syscfg", "syscon";
-			reg = <0x50020000 0x400>;
-			clocks = <&rcc SYSCFG>;
-		};
-
-		mdma: dma-controller@58000000 {
-			compatible = "st,stm32h7-mdma";
-			reg = <0x58000000 0x1000>;
-			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc MDMA>;
-			#dma-cells = <5>;
-			dma-channels = <32>;
-			dma-requests = <48>;
-		};
-
-		sdmmc1: mmc@58005000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x20253180>;
-			reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
-			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC1_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC1_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <130000000>;
-			status = "disabled";
-		};
-
-		sdmmc2: mmc@58007000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x20253180>;
-			reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
-			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC2_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC2_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <130000000>;
-			status = "disabled";
-		};
-
-		iwdg2: watchdog@5a002000 {
-			compatible = "st,stm32mp1-iwdg";
-			reg = <0x5a002000 0x400>;
-			clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
-			clock-names = "pclk", "lsi";
-			status = "disabled";
-		};
-
-		rtc: rtc@5c004000 {
-			compatible = "st,stm32mp1-rtc";
-			reg = <0x5c004000 0x400>;
-			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&scmi_clk CK_SCMI_RTCAPB>,
-				 <&scmi_clk CK_SCMI_RTC>;
-			clock-names = "pclk", "rtc_ck";
-			status = "disabled";
-		};
-
-		bsec: efuse@5c005000 {
-			compatible = "st,stm32mp15-bsec";
-			reg = <0x5c005000 0x400>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			part_number_otp: part_number_otp@4 {
-				reg = <0x4 0x2>;
-				bits = <0 12>;
-			};
-			ts_cal1: calib@5c {
-				reg = <0x5c 0x2>;
-			};
-			ts_cal2: calib@5e {
-				reg = <0x5e 0x2>;
-			};
-		};
-
-		/*
-		 * Break node order to solve dependency probe issue between
-		 * pinctrl and exti.
-		 */
-		pinctrl: pinctrl@50002000 {
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32mp135-pinctrl";
 			ranges = <0 0x50002000 0x8400>;
 			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
 			pins-are-numbered;
 
 			gpioa: gpio@50002000 {
@@ -536,5 +961,908 @@ gpioi: gpio@5000a000 {
 				gpio-ranges = <&pinctrl 0 128 8>;
 			};
 		};
+
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 68  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 41  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 43  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 78  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 34  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 73  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 54  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 84  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_40 */
+				<0>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 96  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 92  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<&intc GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 63  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
+		};
+
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
+		};
+
+		lptimer4: timer@50023000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50023000 0x400>;
+			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer5: timer@50024000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50024000 0x400>;
+			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc DTS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
+			reg = <0x50028000 0x100>;
+			status = "disabled";
+		};
+
+		hdp: pinctrl@5002a000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
+			status = "disabled";
+		};
+
+		mdma: dma-controller@58000000 {
+			compatible = "st,stm32h7-mdma";
+			reg = <0x58000000 0x1000>;
+			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc MDMA>;
+			#dma-cells = <5>;
+			dma-channels = <32>;
+			dma-requests = <48>;
+		};
+
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
+			status = "disabled";
+		};
+
+		usbh_ohci: usb@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		usbh_ehci: usb@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
+			status = "disabled";
+		};
+
+		rtc: rtc@5c004000 {
+			compatible = "st,stm32mp1-rtc";
+			reg = <0x5c004000 0x400>;
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_RTCAPB>,
+				 <&scmi_clk CK_SCMI_RTC>;
+			clock-names = "pclk", "rtc_ck";
+			status = "disabled";
+		};
+
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp13-bsec";
+			reg = <0x5c005000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp: part-number-otp@4 {
+				reg = <0x4 0x2>;
+				bits = <0 12>;
+			};
+			vrefint: vrefin-cal@52 {
+				reg = <0x52 0x2>;
+			};
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			ethernet_mac1_address: mac1@e4 {
+				reg = <0xe4 0x6>;
+			};
+			ethernet_mac2_address: mac2@ea {
+				reg = <0xea 0x6>;
+			};
+		};
+
+		etzpc: etzpc@5c007000 {
+			compatible = "st,stm32mp13-sys-bus";
+			reg = <0x5c007000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+			feature-domain-controller;
+			#feature-domain-cells = <1>;
+
+			adc_2: adc@48004000 {
+				reg = <0x48004000 0x400>;
+				compatible = "st,stm32mp13-adc-core";
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC2>, <&rcc ADC2_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ADC2_ID>;
+				status = "disabled";
+
+				adc2: adc@0 {
+					compatible = "st,stm32mp13-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_2>;
+					interrupts = <0>;
+					dmas = <&dmamux1 10 0x400 0x80000001>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+
+					channel@13 {
+						reg = <13>;
+						label = "vrefint";
+					};
+					channel@14 {
+						reg = <14>;
+						label = "vddcore";
+					};
+					channel@16 {
+						reg = <16>;
+						label = "vddcpu";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddq_ddr";
+					};
+				};
+			};
+
+			usbotg_hs: usb@49000000 {
+				compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+				reg = <0x49000000 0x40000>;
+				clocks = <&rcc USBO_K>;
+				clock-names = "otg";
+				resets = <&rcc USBO_R>;
+				reset-names = "dwc2";
+				interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+				g-rx-fifo-size = <512>;
+				g-np-tx-fifo-size = <32>;
+				g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				usb33d-supply = <&scmi_usb33>;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_OTG_ID>;
+				status = "disabled";
+			};
+
+			usart1: serial@4c000000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4c000000 0x400>;
+				interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART1_K>;
+				resets = <&rcc USART1_R>;
+				wakeup-source;
+				power-domains = <&pd_core_ret>;
+				dmas = <&dmamux1 41 0x400 0x5>,
+				       <&dmamux1 42 0x400 0x1>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART1_ID>;
+				status = "disabled";
+			};
+
+			usart2: serial@4c001000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4c001000 0x400>;
+				interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART2_K>;
+				resets = <&rcc USART2_R>;
+				wakeup-source;
+				power-domains = <&pd_core_ret>;
+				dmas = <&dmamux1 43 0x400 0x5>,
+				       <&dmamux1 44 0x400 0x1>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART2_ID>;
+				status = "disabled";
+			};
+
+			i2s4: audio-controller@4c002000 {
+				compatible = "st,stm32h7-i2s";
+				#sound-dai-cells = <0>;
+				reg = <0x4c002000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI4_ID>;
+				status = "disabled";
+			};
+
+			spi4: spi@4c002000 {
+				compatible = "st,stm32h7-spi";
+				reg = <0x4c002000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI4_K>;
+				resets = <&rcc SPI4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI4_ID>;
+				status = "disabled";
+			};
+
+			spi5: spi@4c003000 {
+				compatible = "st,stm32h7-spi";
+				reg = <0x4c003000 0x400>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI5_K>;
+				resets = <&rcc SPI5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 85 0x400 0x01>,
+				       <&dmamux1 86 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI5_ID>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@4c004000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c004000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C3_K>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 73 0x400 0x1>,
+				       <&dmamux1 74 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x4>;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C3_ID>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@4c005000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c005000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C4_K>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 75 0x400 0x1>,
+				       <&dmamux1 76 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x8>;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C4_ID>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@4c006000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c006000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C5_K>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 115 0x400 0x1>,
+				       <&dmamux1 116 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x10>;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C5_ID>;
+				status = "disabled";
+			};
+
+			timers12: timer@4c007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c007000 0x400>;
+				interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM12_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM12_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@4c008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c008000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM13_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM13_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@4c009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c009000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM14_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM14_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			timers15: timer@4c00a000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00a000 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM15_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 105 0x400 0x1>,
+				       <&dmamux1 106 0x400 0x1>,
+				       <&dmamux1 107 0x400 0x1>,
+				       <&dmamux1 108 0x400 0x1>;
+				dma-names = "ch1", "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM15_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@4c00b000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00b000 0x400>;
+				interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM16_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 109 0x400 0x1>,
+				       <&dmamux1 110 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM16_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@4c00c000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00c000 0x400>;
+				interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM17_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 111 0x400 0x1>,
+				       <&dmamux1 112 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM17_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@50021000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50021000 0x400>;
+				interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM2_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core_ret>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM2_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
+
+			lptimer3: timer@50022000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50022000 0x400>;
+				interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM3_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core_ret>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM3_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
+
+			hash: hash@54003000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x54003000 0x400>;
+				interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&mdma 30 0x2 0x1000a02 0x0 0x0 0x0>;
+				dma-names = "in";
+				feature-domains = <&etzpc STM32MP1_ETZPC_HASH_ID>;
+				status = "disabled";
+			};
+
+			rng: rng@54004000 {
+				compatible = "st,stm32mp13-rng";
+				reg = <0x54004000 0x400>;
+				clocks = <&rcc RNG1_K>;
+				resets = <&rcc RNG1_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_RNG_ID>;
+				status = "disabled";
+			};
+
+			fmc: memory-controller@58002000 {
+				compatible = "st,stm32mp1-fmc2-ebi";
+				reg = <0x58002000 0x1000>;
+				ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+					 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+					 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+					 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+					 <4 0 0x80000000 0x10000000>; /* NAND */
+				#address-cells = <2>;
+				#size-cells = <1>;
+				clocks = <&rcc FMC_K>;
+				resets = <&rcc FMC_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_FMC_ID>;
+				status = "disabled";
+
+				nand-controller@4,0 {
+					compatible = "st,stm32mp1-fmc2-nfc";
+					reg = <4 0x00000000 0x1000>,
+					      <4 0x08010000 0x1000>,
+					      <4 0x08020000 0x1000>,
+					      <4 0x01000000 0x1000>,
+					      <4 0x09010000 0x1000>,
+					      <4 0x09020000 0x1000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&mdma 24 0x2 0x12000a02 0x0 0x0>,
+					       <&mdma 24 0x2 0x12000a08 0x0 0x0>,
+					       <&mdma 25 0x2 0x12000a0a 0x0 0x0>;
+					dma-names = "tx", "rx", "ecc";
+					status = "disabled";
+				};
+			};
+
+			qspi: spi@58003000 {
+				compatible = "st,stm32f469-qspi";
+				reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+				reg-names = "qspi", "qspi_mm";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma 26 0x2 0x10100002 0x0 0x0>,
+				       <&mdma 26 0x2 0x10100008 0x0 0x0>;
+				dma-names = "tx", "rx";
+				clocks = <&rcc QSPI_K>;
+				resets = <&rcc QSPI_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_QSPI_ID>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@58005000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x20253180>;
+				reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
+				interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC1_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <130000000>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SDMMC1_ID>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@58007000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x20253180>;
+				reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC2_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <130000000>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SDMMC2_ID>;
+				status = "disabled";
+			};
+
+			eth1: eth1@5800a000 {
+				compatible = "snps,dwmac-4.20a", "st,stm32mp13-dwmac";
+				reg = <0x5800a000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti 68 1>;
+				interrupt-names = "macirq", "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc ETH1MAC>,
+					 <&rcc ETH1TX>,
+					 <&rcc ETH1RX>,
+					 <&rcc ETH1STP>,
+					 <&rcc ETH1CK_K>;
+				st,syscon = <&syscfg 0x4 0xff0000>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ETH1_ID>;
+				status = "disabled";
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+			};
+
+			usbphyc: usbphyc@5a006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#clock-cells = <0>;
+				compatible = "st,stm32mp1-usbphyc";
+				reg = <0x5a006000 0x1000>;
+				clocks = <&rcc USBPHY_K>;
+				resets = <&rcc USBPHY_R>;
+				vdda1v1-supply = <&scmi_reg11>;
+				vdda1v8-supply = <&scmi_reg18>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_USBPHYCTRL_ID>;
+				status = "disabled";
+
+				usbphyc_port0: usb-phy@0 {
+					#phy-cells = <0>;
+					reg = <0>;
+					interrupts-extended = <&exti 42 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				usbphyc_port1: usb-phy@1 {
+					#phy-cells = <1>;
+					reg = <1>;
+					interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+				};
+			};
+		};
+
+		tamp: tamp@5c00a000 {
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x5c00a000 0x400>;
+			ranges;
+
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x5c00a100 0x80>;
+
+				saes_secret_key: tamp-bkp@0 {
+					/* see saes secret key feature */
+					reg = <0x0 0x20>;
+				};
+				boot_mode: tamp-bkp@78 {
+					/* see boot mode selection feature */
+					reg = <0x78 0x4>;
+				};
+				boot_counter: tamp-bkp@7c {
+					/* see boot counter feature */
+					reg = <0x7c 0x4>;
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp133.dtsi b/arch/arm/boot/dts/stm32mp133.dtsi
index 531c263c9..41b1c5718 100644
--- a/arch/arm/boot/dts/stm32mp133.dtsi
+++ b/arch/arm/boot/dts/stm32mp133.dtsi
@@ -33,5 +33,72 @@ m_can2: can@4400f000 {
 			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
 			status = "disabled";
 		};
+
+		etzpc: etzpc@5c007000 {
+			adc_1: adc@48003000 {
+				compatible = "st,stm32mp13-adc-core";
+				reg = <0x48003000 0x400>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC1>, <&rcc ADC1_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ADC1_ID>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp13-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_1>;
+					interrupts = <0>;
+					dmas = <&dmamux1 9 0x400 0x80000001>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+
+					channel@18 {
+						reg = <18>;
+						label = "vrefint";
+					};
+				};
+			};
+
+			eth2: eth2@5800e000 {
+				compatible = "snps,dwmac-4.20a", "st,stm32mp13-dwmac";
+				reg = <0x5800e000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc ETH2MAC>,
+					 <&rcc ETH2TX>,
+					 <&rcc ETH2RX>,
+					 <&rcc ETH2STP>,
+					 <&rcc ETH2CK_K>;
+				st,syscon = <&syscfg 0x4 0xff000000>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,axi-config = <&stmmac_axi_config_2>;
+				snps,tso;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ETH2_ID>;
+				status = "disabled";
+
+				stmmac_axi_config_2: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+			};
+		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp135.dtsi b/arch/arm/boot/dts/stm32mp135.dtsi
index abf2acd37..c3d4b3198 100644
--- a/arch/arm/boot/dts/stm32mp135.dtsi
+++ b/arch/arm/boot/dts/stm32mp135.dtsi
@@ -8,5 +8,29 @@
 
 / {
 	soc {
+		etzpc: etzpc@5c007000 {
+			dcmipp: dcmipp@5a000000 {
+				compatible = "st,stm32mp13-dcmipp";
+				reg = <0x5a000000 0x400>;
+				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPP_R>;
+				clocks = <&rcc DCMIPP_K>;
+				clock-names = "kclk";
+				feature-domains = <&etzpc STM32MP1_ETZPC_DCMIPP_ID>;
+				status = "disabled";
+			};
+
+			ltdc: display-controller@5a001000 {
+				compatible = "st,stm32-ltdc";
+				reg = <0x5a001000 0x400>;
+				interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LTDC_PX>;
+				clock-names = "lcd";
+				resets = <&scmi_reset RST_SCMI_LTDC>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LTDC_ID>;
+				status = "disabled";
+			};
+		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts b/arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts
new file mode 100644
index 000000000..e3217e36e
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp135f-dk-a7-examples.dts
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp135f-dk.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP135F-DK configured to run Linux A7 examples";
+	compatible = "st,stm32mp135f-dk-a7-examples", "st,stm32mp135f-dk", "st,stm32mp135";
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+		status = "disabled";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+		status = "disabled";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+/*
+ * Sound card to support external digital microphones connected
+ * on the expansion connector.
+ */
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP13-DK";
+		dais = <&dfsdm0_port &dfsdm1_port>;
+		status = "disabled";
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_datin1_pins_a &dfsdm_datin3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_datin1_sleep_pins_a &dfsdm_datin3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "disabled";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic0";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic1";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers8 {
+	status = "okay";
+};
+
+&uart8 {
+	status = "okay";
+};
+
+&usart1 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp135f-dk.dts b/arch/arm/boot/dts/stm32mp135f-dk.dts
index de341d17e..e0b1ce734 100644
--- a/arch/arm/boot/dts/stm32mp135f-dk.dts
+++ b/arch/arm/boot/dts/stm32mp135f-dk.dts
@@ -9,6 +9,8 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/st,stm32mp13-regulator.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
 #include "stm32mp135.dtsi"
 #include "stm32mp13xf.dtsi"
 #include "stm32mp13-pinctrl.dtsi"
@@ -18,7 +20,39 @@ / {
 	compatible = "st,stm32mp135f-dk", "st,stm32mp135";
 
 	aliases {
+		ethernet0 = &eth1;
+		ethernet1 = &eth2;
 		serial0 = &uart4;
+		serial1 = &usart1;
+		serial2 = &uart8;
+		serial3 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_mco1: clk-mco1 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
 	};
 
 	memory@c0000000 {
@@ -59,13 +93,181 @@ led-blue {
 		};
 	};
 
-	vdd_sd: vdd-sd {
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioe 12 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	panel_rgb: panel-rgb {
+		compatible = "rocktech,rk043fn48h", "panel-dpi";
+		enable-gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_backlight>;
+		power-supply = <&scmi_v3v3_sw>;
+		data-mapping = "bgr666";
+		status = "okay";
+
+		width-mm = <105>;
+		height-mm = <67>;
+
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&ltdc_out_rgb>;
+			};
+		};
+
+		panel-timing {
+			clock-frequency = <10000000>;
+			hactive = <480>;
+			vactive = <272>;
+			hsync-len = <52>;
+			hfront-porch = <10>;
+			hback-porch = <10>;
+			vsync-len = <10>;
+			vfront-porch = <10>;
+			vback-porch = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <1>;
+		};
+	};
+
+	v3v3_ao: v3v3-ao {
 		compatible = "regulator-fixed";
-		regulator-name = "vdd_sd";
-		regulator-min-microvolt = <2900000>;
-		regulator-max-microvolt = <2900000>;
+		regulator-name = "v3v3_ao";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
 		regulator-always-on;
 	};
+
+	wake_up {
+		compatible = "gpio-keys";
+		status = "okay";
+
+		button {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&mcp23017 11 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&adc_1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc1_usb_cc_pins_a>;
+	vdda-supply = <&scmi_vdd_adc>;
+	vref-supply = <&scmi_vdd_adc>;
+	status = "okay";
+	adc1: adc@0 {
+		status = "okay";
+		/*
+		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in6 & in12.
+		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
+		 * 5 * (5.1 + 47kOhms) * 5pF => 1.3us.
+		 * Use arbitrary margin here (e.g. 5us).
+		 */
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@12 {
+			reg = <12>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp {
+	status = "okay";
+};
+
+&dcmipp {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmipp_pins_a>;
+	pinctrl-1 = <&dcmipp_sleep_pins_a>;
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&mipid02_2>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <0>;
+			pclk-max-frequency = <120000000>;
+		};
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rmii_pins_a>;
+	pinctrl-1 = <&eth1_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios =  <&mcp23017 9 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+			wakeup-source;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rmii_pins_a>;
+	pinctrl-1 = <&eth2_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	phy-supply = <&scmi_v3v3_sw>;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios = <&mcp23017 10 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+		};
+	};
 };
 
 &i2c1 {
@@ -79,6 +281,39 @@ &i2c1 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
+
+	mcp23017: pinctrl@21 {
+		compatible = "microchip,mcp23017";
+		reg = <0x21>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-parent = <&gpiog>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mcp23017_pins_a>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		microchip,irq-mirror;
+	};
+
+	typec@53 {
+		compatible = "st,stm32g0-typec";
+		reg = <0x53>;
+		/* Alert pin on PI2 (PWR wakeup pin), managed by optee */
+		interrupts-extended = <&optee 1>;
+		firmware-name = "stm32g0-ucsi.mp135f-dk.fw";
+		wakeup-source;
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+
+			port {
+				con_usb_c_g0_ep: endpoint {
+					remote-endpoint = <&usbotg_hs_ep>;
+				};
+			};
+		};
+	};
 };
 
 &i2c5 {
@@ -92,30 +327,189 @@ &i2c5 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
+
+	stmipi: stmipi@14 {
+		compatible = "st,st-mipid02";
+		reg = <0x14>;
+		status = "okay";
+		clocks = <&clk_mco1>;
+		clock-names = "xclk";
+		VDDE-supply = <&scmi_v1v8_periph>;
+		VDDIN-supply = <&scmi_v1v8_periph>;
+		reset-gpios = <&mcp23017 2 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+
+				mipid02_0: endpoint {
+					data-lanes = <1 2>;
+					lane-polarities = <0 0 0>;
+					remote-endpoint = <&gc2145_ep>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+
+				mipid02_2: endpoint {
+					bus-width = <8>;
+					hsync-active = <0>;
+					vsync-active = <0>;
+					pclk-sample = <0>;
+					remote-endpoint = <&dcmipp_0>;
+				};
+			};
+		};
+	};
+
+	gc2145: gc2145@3c {
+		compatible = "galaxycore,gc2145";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		IOVDD-supply = <&scmi_v3v3_sw>;
+		AVDD-supply = <&scmi_v3v3_sw>;
+		DVDD-supply = <&scmi_v3v3_sw>;
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			gc2145_ep: endpoint {
+				remote-endpoint = <&mipid02_0>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&scmi_v3v3_sw>;
+		status = "disabled";
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		port {
+			ov5640_0: endpoint {
+				/*remote-endpoint = <&mipid02_0>;*/
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	goodix: goodix-ts@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&goodix_pins_a>;
+		interrupt-parent = <&gpiof>;
+		interrupts = <5 IRQ_TYPE_NONE>;
+		reset-gpios = <&gpioh 2 GPIO_ACTIVE_LOW>;
+		AVDD28-supply = <&scmi_v3v3_sw>;
+		VDDIO-supply = <&scmi_v3v3_sw>;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <272>;
+		status = "okay" ;
+	};
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	default-on;
 	status = "okay";
+
+	port {
+		ltdc_out_rgb: endpoint {
+			remote-endpoint = <&panel_in_rgb>;
+		};
+	};
 };
 
 &rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
 	status = "okay";
 };
 
+&scmi_regu {
+	scmi_vddcpu: regulator@6 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK1>;
+		regulator-name = "vddcpu";
+	};
+	scmi_vdd: regulator@8 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK3>;
+		regulator-name = "vdd";
+	};
+	scmi_vddcore: regulator@9 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK4>;
+		regulator-name = "vddcore";
+	};
+	scmi_vdd_adc: regulator@10 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO1>;
+		regulator-name = "vdd_adc";
+	};
+	scmi_vdd_usb: regulator@13 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO4>;
+		regulator-name = "vdd_usb";
+	};
+	scmi_vdd_sd: regulator@14 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO5>;
+		regulator-name = "vdd_sd";
+	};
+	scmi_v1v8_periph: regulator@15 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO6>;
+		regulator-name = "v1v8_periph";
+	};
+	scmi_v3v3_sw: regulator@19 {
+		reg = <VOLTD_SCMI_STPMIC1_PWR_SW2>;
+		regulator-name = "v3v3_sw";
+	};
+};
+
 &sdmmc1 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_clk_pins_a>;
 	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_clk_pins_a>;
 	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
-	broken-cd;
+	cd-gpios = <&gpioh 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 	disable-wp;
 	st,neg-edge;
 	bus-width = <4>;
-	vmmc-supply = <&vdd_sd>;
+	vmmc-supply = <&scmi_vdd_sd>;
 	status = "okay";
 };
 
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	cap-sdio-irq;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3_ao>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
 &spi5 {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi5_pins_a>;
@@ -123,8 +517,176 @@ &spi5 {
 	status = "disabled";
 };
 
+&timers3 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm3_pins_a>;
+		pinctrl-1 = <&pwm3_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@2 {
+		status = "okay";
+	};
+};
+
+&timers4 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm4_pins_a>;
+		pinctrl-1 = <&pwm4_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@3 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers14 {
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm14_pins_a>;
+		pinctrl-1 = <&pwm14_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@13 {
+		status = "okay";
+	};
+};
+
 &uart4 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 };
+
+&uart8 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart8_pins_a>;
+	pinctrl-1 = <&uart8_sleep_pins_a>;
+	pinctrl-2 = <&uart8_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_sleep_pins_a>;
+	pinctrl-2 = <&usart2_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&mcp23017 13 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3_ao>;
+		vddio-supply = <&v3v3_ao>;
+	};
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&scmi_v3v3_sw>;
+	};
+};
+
+&usbotg_hs {
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	usb-role-switch;
+	status = "okay";
+	port {
+		usbotg_hs_ep: endpoint {
+			remote-endpoint = <&con_usb_c_g0_ep>;
+		};
+	};
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&scmi_vdd_usb>;
+	st,current-boost-microamp = <1000>;
+	st,decrease-hs-slew-rate;
+	st,tune-hs-dc-level = <2>;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <11>;
+	st,trim-hs-impedance = <2>;
+	st,tune-squelch-level = <1>;
+	st,enable-hs-rx-gain-eq;
+	st,no-hs-ftime-ctrl;
+	st,no-lsfs-sc;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&scmi_vdd_usb>;
+	st,current-boost-microamp = <1000>;
+	st,decrease-hs-slew-rate;
+	st,tune-hs-dc-level = <2>;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <11>;
+	st,trim-hs-impedance = <2>;
+	st,tune-squelch-level = <1>;
+	st,enable-hs-rx-gain-eq;
+	st,no-hs-ftime-ctrl;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/boot/dts/stm32mp13xa.dtsi b/arch/arm/boot/dts/stm32mp13xa.dtsi
new file mode 100644
index 000000000..cc6456e71
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/boot/dts/stm32mp13xc.dtsi b/arch/arm/boot/dts/stm32mp13xc.dtsi
index 4d00e7592..aa4ce81c7 100644
--- a/arch/arm/boot/dts/stm32mp13xc.dtsi
+++ b/arch/arm/boot/dts/stm32mp13xc.dtsi
@@ -6,13 +6,19 @@
 
 / {
 	soc {
-		cryp: crypto@54002000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
+		etzpc: etzpc@5c007000 {
+			cryp: crypto@54002000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma 28 0x0 0x400202 0x0 0x0>,
+				       <&mdma 29 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp13xd.dtsi b/arch/arm/boot/dts/stm32mp13xd.dtsi
new file mode 100644
index 000000000..cc6456e71
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp13xd.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/boot/dts/stm32mp13xf.dtsi b/arch/arm/boot/dts/stm32mp13xf.dtsi
index 4d00e7592..aa4ce81c7 100644
--- a/arch/arm/boot/dts/stm32mp13xf.dtsi
+++ b/arch/arm/boot/dts/stm32mp13xf.dtsi
@@ -6,13 +6,19 @@
 
 / {
 	soc {
-		cryp: crypto@54002000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
+		etzpc: etzpc@5c007000 {
+			cryp: crypto@54002000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma 28 0x0 0x400202 0x0 0x0>,
+				       <&mdma 29 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi
new file mode 100644
index 000000000..49a3ea5db
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15-m4-srm-pinctrl.dtsi
@@ -0,0 +1,524 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	m4_adc1_in6_pins_a: m4-adc1-in6 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, RSVD)>;
+		};
+	};
+
+	m4_adc12_ain_pins_a: m4-adc12-ain-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>, /* ADC1 in13 */
+				 <STM32_PINMUX('F', 12, RSVD)>, /* ADC1 in6 */
+				 <STM32_PINMUX('F', 13, RSVD)>, /* ADC2 in2 */
+				 <STM32_PINMUX('F', 14, RSVD)>; /* ADC2 in6 */
+		};
+	};
+
+	m4_adc12_usb_pwr_pins_a: m4-adc12-usb-pwr-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>, /* ADC12 in18 */
+				 <STM32_PINMUX('A', 5, RSVD)>; /* ADC12 in19 */
+		};
+	};
+
+	m4_cec_pins_a: m4-cec-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, RSVD)>;
+		};
+	};
+
+	m4_cec_pins_b: m4-cec-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, RSVD)>;
+		};
+	};
+
+	m4_dac_ch1_pins_a: m4-dac-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>;
+		};
+	};
+
+	m4_dac_ch2_pins_a: m4-dac-ch2 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, RSVD)>;
+		};
+	};
+
+	m4_dcmi_pins_a: m4-dcmi-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 8,  RSVD)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('B', 7,  RSVD)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('A', 6,  RSVD)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('H', 9,  RSVD)>,/* DCMI_D0 */
+				 <STM32_PINMUX('H', 10, RSVD)>,/* DCMI_D1 */
+				 <STM32_PINMUX('H', 11, RSVD)>,/* DCMI_D2 */
+				 <STM32_PINMUX('H', 12, RSVD)>,/* DCMI_D3 */
+				 <STM32_PINMUX('H', 14, RSVD)>,/* DCMI_D4 */
+				 <STM32_PINMUX('I', 4,  RSVD)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B', 8,  RSVD)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 6,  RSVD)>,/* DCMI_D7 */
+				 <STM32_PINMUX('I', 1,  RSVD)>,/* DCMI_D8 */
+				 <STM32_PINMUX('H', 7,  RSVD)>,/* DCMI_D9 */
+				 <STM32_PINMUX('I', 3,  RSVD)>,/* DCMI_D10 */
+				 <STM32_PINMUX('H', 15, RSVD)>;/* DCMI_D11 */
+		};
+	};
+
+	m4_dfsdm_clkout_pins_a: m4-dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, RSVD)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	m4_dfsdm_data1_pins_a: m4-dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>; /* DFSDM_DATA1 */
+		};
+	};
+
+	m4_dfsdm_data3_pins_a: m4-dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, RSVD)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	m4_ethernet0_rgmii_pins_a: m4-ethernet0-rgmii-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 5, RSVD)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, RSVD)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, RSVD)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, RSVD)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, RSVD)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, RSVD)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, RSVD)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('C', 1, RSVD)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 2, RSVD)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 4, RSVD)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, RSVD)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('B', 0, RSVD)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, RSVD)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, RSVD)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, RSVD)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	m4_fmc_pins_a: m4-fmc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, RSVD)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, RSVD)>, /* FMC_NWE */
+				 <STM32_PINMUX('D', 11, RSVD)>, /* FMC_A16_FMC_CLE */
+				 <STM32_PINMUX('D', 12, RSVD)>, /* FMC_A17_FMC_ALE */
+				 <STM32_PINMUX('D', 14, RSVD)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, RSVD)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, RSVD)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, RSVD)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, RSVD)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, RSVD)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, RSVD)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, RSVD)>, /* FMC_D7 */
+				 <STM32_PINMUX('G', 9, RSVD)>, /* FMC_NE2_FMC_NCE */
+				 <STM32_PINMUX('D', 6, RSVD)>; /* FMC_NWAIT */
+		};
+	};
+
+	m4_hdp0_pins_a: m4-hdp0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 12, RSVD)>; /* HDP0 */
+		};
+	};
+
+	m4_hdp6_pins_a: m4-hdp6-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 5, RSVD)>; /* HDP6 */
+		};
+	};
+
+	m4_hdp7_pins_a: m4-hdp7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 6, RSVD)>; /* HDP7 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, RSVD)>, /* I2C1_SCL */
+				 <STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_i2c2_pins_a: m4-i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 4, RSVD)>, /* I2C2_SCL */
+				 <STM32_PINMUX('H', 5, RSVD)>; /* I2C2_SDA */
+		};
+	};
+
+	m4_i2c5_pins_a: m4-i2c5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* I2C5_SCL */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* I2C5_SDA */
+		};
+	};
+
+	m4_i2s2_pins_a: m4-i2s2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 3, RSVD)>, /* I2S2_SDO */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* I2S2_WS */
+				 <STM32_PINMUX('A', 9, RSVD)>; /* I2S2_CK */
+		};
+	};
+
+	m4_ltdc_pins_a: m4-ltdc-a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G',  7, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 10, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I',  9, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('F', 10, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('H',  2, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('H',  3, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('H',  8, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('H',  9, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('H', 10, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('C',  0, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('H', 12, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('E', 15, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('E',  5, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('E',  6, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('H', 13, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('H', 14, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('H', 15, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('I',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('I',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('I',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('D',  9, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('G', 12, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('D', 10, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('I',  4, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('A',  3, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  8, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('D',  8, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_ltdc_pins_b: m4-ltdc-b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 14, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 12, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I', 13, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('K',  7, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('I', 15, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('J',  0, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('J',  1, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('J',  2, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('J',  3, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('J',  4, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('J',  5, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('J',  6, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('J',  7, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('J',  8, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('J',  9, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('J', 10, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('J', 11, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('K',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('K',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('K',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('J', 12, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('J', 13, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('J', 14, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('J', 15, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('K',  3, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('K',  4, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('K',  5, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('K',  6, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_m_can1_pins_a: m4-m-can1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 13, RSVD)>, /* CAN1_TX */
+				 <STM32_PINMUX('I', 9, RSVD)>; /* CAN1_RX */
+		};
+	};
+
+	m4_pwm1_pins_a: m4-pwm1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>, /* TIM1_CH1 */
+				 <STM32_PINMUX('E', 11, RSVD)>, /* TIM1_CH2 */
+				 <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_pwm2_pins_a: m4-pwm2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, RSVD)>; /* TIM2_CH4 */
+		};
+	};
+
+	m4_pwm3_pins_a: m4-pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, RSVD)>; /* TIM3_CH2 */
+		};
+	};
+
+	m4_pwm4_pins_a: m4-pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 14, RSVD)>, /* TIM4_CH3 */
+				 <STM32_PINMUX('D', 15, RSVD)>; /* TIM4_CH4 */
+		};
+	};
+
+	m4_pwm4_pins_b: m4-pwm4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, RSVD)>; /* TIM4_CH2 */
+		};
+	};
+
+	m4_pwm5_pins_a: m4-pwm5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, RSVD)>; /* TIM5_CH2 */
+		};
+	};
+
+	m4_pwm8_pins_a: m4-pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, RSVD)>; /* TIM8_CH4 */
+		};
+	};
+
+	m4_pwm12_pins_a: m4-pwm12-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 6, RSVD)>; /* TIM12_CH1 */
+		};
+	};
+
+	m4_qspi_bk1_pins_a: m4-qspi-bk1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 8, RSVD)>, /* QSPI_BK1_IO0 */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* QSPI_BK1_IO1 */
+				 <STM32_PINMUX('F', 7, RSVD)>, /* QSPI_BK1_IO2 */
+				 <STM32_PINMUX('F', 6, RSVD)>, /* QSPI_BK1_IO3 */
+				 <STM32_PINMUX('B', 6, RSVD)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	m4_qspi_bk2_pins_a: m4-qspi-bk2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, RSVD)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, RSVD)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, RSVD)>, /* QSPI_BK2_IO3 */
+				 <STM32_PINMUX('C', 0, RSVD)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	m4_qspi_clk_pins_a: m4-qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, RSVD)>; /* QSPI_CLK */
+		};
+	};
+
+	m4_rtc_out2_rmp_pins_a: m4-rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, RSVD)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	m4_sai2a_pins_a: m4-sai2a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 5, RSVD)>, /* SAI2_SCK_A */
+				 <STM32_PINMUX('I', 6, RSVD)>, /* SAI2_SD_A */
+				 <STM32_PINMUX('I', 7, RSVD)>, /* SAI2_FS_A */
+				 <STM32_PINMUX('E', 0, RSVD)>; /* SAI2_MCLK_A */
+		};
+	};
+
+	m4_sai2b_pins_a: m4-sai2b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('E', 13, RSVD)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SAI2_MCLK_B */
+				 <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai2b_pins_b: m4-sai2b-2 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai4a_pins_a: m4-sai4a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, RSVD)>; /* SAI4_SD_A */
+		};
+	};
+
+	m4_sdmmc1_b4_pins_a: m4-sdmmc1-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, RSVD)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, RSVD)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, RSVD)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, RSVD)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, RSVD)>, /* SDMMC1_CMD */
+				 <STM32_PINMUX('C', 12, RSVD)>; /* SDMMC1_CK */
+		};
+	};
+
+	m4_sdmmc1_dir_pins_a: m4-sdmmc1-dir-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, RSVD)>, /* SDMMC1_D0DIR */
+				 <STM32_PINMUX('C', 7, RSVD)>, /* SDMMC1_D123DIR */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* SDMMC1_CDIR */
+				 <STM32_PINMUX('E', 4, RSVD)>; /* SDMMC1_CKIN */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_a: m4-sdmmc2-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_b: m4-sdmmc2-b4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_d47_pins_a: m4-sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, RSVD)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, RSVD)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 5, RSVD)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* SDMMC2_D7 */
+		};
+	};
+
+	m4_sdmmc3_b4_pins_a: m4-sdmmc3-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 0, RSVD)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('F', 4, RSVD)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('F', 5, RSVD)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('D', 7, RSVD)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('F', 1, RSVD)>, /* SDMMC3_CMD */
+				 <STM32_PINMUX('G', 15, RSVD)>; /* SDMMC3_CK */
+		};
+	};
+
+	m4_spdifrx_pins_a: m4-spdifrx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, RSVD)>; /* SPDIF_IN1 */
+		};
+	};
+
+	m4_spi4_pins_a: m4-spi4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SPI4_MOSI */
+				 <STM32_PINMUX('E', 13, RSVD)>; /* SPI4_MISO */
+		};
+	};
+
+	m4_spi5_pins_a: m4-spi5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, RSVD)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* SPI5_MOSI */
+				 <STM32_PINMUX('F', 8, RSVD)>; /* SPI5_MISO */
+		};
+	};
+
+	m4_stusb1600_pins_a: m4-stusb1600-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 11, RSVD)>;
+		};
+	};
+
+	m4_uart4_pins_a: m4-uart4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, RSVD)>, /* UART4_TX */
+				 <STM32_PINMUX('B', 2, RSVD)>; /* UART4_RX */
+		};
+	};
+
+	m4_uart7_pins_a: m4-uart7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 8, RSVD)>, /* USART7_TX */
+				 <STM32_PINMUX('E', 7, RSVD)>; /* USART7_RX */
+		};
+	};
+
+	m4_usart2_pins_a: m4-usart2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 5, RSVD)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, RSVD)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 6, RSVD)>, /* USART2_RX */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* USART2_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('I', 10, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_b: m4-usart3-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 13, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usbotg_fs_dp_dm_pins_a: m4-usbotg-fs-dp-dm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* OTG_FS_DP */
+		};
+	};
+
+	m4_usbotg_hs_pins_a: m4-usbotg-hs-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, RSVD)>; /* OTG_ID */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_i2c4_pins_a: m4-i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, RSVD)>, /* I2C4_SCL */
+				 <STM32_PINMUX('Z', 5, RSVD)>; /* I2C4_SDA */
+		};
+	};
+
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 2, RSVD)>, /* SPI1_MOSI */
+				 <STM32_PINMUX('Z', 1, RSVD)>; /* SPI1_MISO */
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15-m4-srm.dtsi b/arch/arm/boot/dts/stm32mp15-m4-srm.dtsi
new file mode 100644
index 000000000..7fa3ca411
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15-m4-srm.dtsi
@@ -0,0 +1,447 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&m4_rproc {
+	m4_system_resources {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		m4_timers2: timer@40000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40000000 0x400>;
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers3: timer@40001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40001000 0x400>;
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers4: timer@40002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40002000 0x400>;
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers5: timer@40003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40003000 0x400>;
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers6: timer@40004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40004000 0x400>;
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers7: timer@40005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40005000 0x400>;
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers12: timer@40006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40006000 0x400>;
+			clocks = <&rcc TIM12_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers13: timer@40007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40007000 0x400>;
+			clocks = <&rcc TIM13_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers14: timer@40008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40008000 0x400>;
+			clocks = <&rcc TIM14_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_lptimer1: timer@40009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40009000 0x400>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_spi2: spi@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			clocks = <&rcc SPI2_K>;
+			status = "disabled";
+		};
+		m4_i2s2: audio-controller@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			status = "disabled";
+		};
+		m4_spi3: spi@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			clocks = <&rcc SPI3_K>;
+			status = "disabled";
+		};
+		m4_i2s3: audio-controller@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			status = "disabled";
+		};
+		m4_spdifrx: audio-controller@4000d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			status = "disabled";
+		};
+		m4_usart2: serial@4000e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000e000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <27 1>;
+			clocks = <&rcc USART2_K>;
+			status = "disabled";
+		};
+		m4_usart3: serial@4000f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000f000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <28 1>;
+			clocks = <&rcc USART3_K>;
+			status = "disabled";
+		};
+		m4_uart4: serial@40010000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40010000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <30 1>;
+			clocks = <&rcc UART4_K>;
+			status = "disabled";
+		};
+		m4_uart5: serial@40011000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40011000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <31 1>;
+			clocks = <&rcc UART5_K>;
+			status = "disabled";
+		};
+		m4_i2c1: i2c@40012000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40012000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <21 1>;
+			clocks = <&rcc I2C1_K>;
+			status = "disabled";
+		};
+		m4_i2c2: i2c@40013000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40013000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <22 1>;
+			clocks = <&rcc I2C2_K>;
+			status = "disabled";
+		};
+		m4_i2c3: i2c@40014000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40014000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <23 1>;
+			clocks = <&rcc I2C3_K>;
+			status = "disabled";
+		};
+		m4_i2c5: i2c@40015000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40015000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <25 1>;
+			clocks = <&rcc I2C5_K>;
+			status = "disabled";
+		};
+		m4_cec: cec@40016000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40016000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <69 1>;
+			clocks = <&rcc CEC_K>, <&rcc CEC>;
+			clock-names = "cec", "hdmi-cec";
+			status = "disabled";
+		};
+		m4_dac: dac@40017000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40017000 0x400>;
+			clocks = <&rcc DAC12>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+		m4_uart7: serial@40018000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40018000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <32 1>;
+			clocks = <&rcc UART7_K>;
+			status = "disabled";
+		};
+		m4_uart8: serial@40019000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40019000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <33 1>;
+			clocks = <&rcc UART8_K>;
+			status = "disabled";
+		};
+		m4_timers1: timer@44000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44000000 0x400>;
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers8: timer@44001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44001000 0x400>;
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_usart6: serial@44003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44003000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <29 1>;
+			clocks = <&rcc USART6_K>;
+			status = "disabled";
+		};
+		m4_spi1: spi@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			clocks = <&rcc SPI1_K>;
+			status = "disabled";
+		};
+		m4_i2s1: audio-controller@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			status = "disabled";
+		};
+		m4_spi4: spi@44005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44005000 0x400>;
+			clocks = <&rcc SPI4_K>;
+			status = "disabled";
+		};
+		m4_timers15: timer@44006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44006000 0x400>;
+			clocks = <&rcc TIM15_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers16: timer@44007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44007000 0x400>;
+			clocks = <&rcc TIM16_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers17: timer@44008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44008000 0x400>;
+			clocks = <&rcc TIM17_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_spi5: spi@44009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44009000 0x400>;
+			clocks = <&rcc SPI5_K>;
+			status = "disabled";
+		};
+		m4_sai1: sai@4400a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400a000 0x4>;
+			clocks = <&rcc SAI1_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai2: sai@4400b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400b000 0x4>;
+			clocks = <&rcc SAI2_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai3: sai@4400c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400c000 0x4>;
+			clocks = <&rcc SAI3_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_dfsdm: dfsdm@4400d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+			clock-names = "dfsdm", "audio";
+			status = "disabled";
+		};
+		m4_m_can1: can@4400e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400e000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_m_can2: can@4400f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_dma1: dma@48000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48000000 0x400>;
+			clocks = <&rcc DMA1>;
+			status = "disabled";
+		};
+		m4_dma2: dma@48001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48001000 0x400>;
+			clocks = <&rcc DMA2>;
+			status = "disabled";
+		};
+		m4_dmamux1: dma-router@48002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48002000 0x1c>;
+			clocks = <&rcc DMAMUX>;
+			status = "disabled";
+		};
+		m4_adc: adc@48003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48003000 0x400>;
+			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+			clock-names = "bus", "adc";
+			status = "disabled";
+		};
+		m4_sdmmc3: sdmmc@48004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48004000 0x400>, <0x48005000 0x400>;
+			clocks = <&rcc SDMMC3_K>;
+			status = "disabled";
+		};
+		m4_usbotg_hs: usb-otg@49000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x49000000 0x10000>;
+			clocks = <&rcc USBO_K>;
+			clock-names = "otg";
+			status = "disabled";
+		};
+		m4_hash2: hash@4c002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c002000 0x400>;
+			clocks = <&rcc HASH2>;
+			status = "disabled";
+		};
+		m4_rng2: rng@4c003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c003000 0x400>;
+			clocks = <&rcc RNG2_K>;
+			status = "disabled";
+		};
+		m4_crc2: crc@4c004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c004000 0x400>;
+			clocks = <&rcc CRC2>;
+			status = "disabled";
+		};
+		m4_cryp2: cryp@4c005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c005000 0x400>;
+			clocks = <&rcc CRYP2>;
+			status = "disabled";
+		};
+		m4_dcmi: dcmi@4c006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c006000 0x400>;
+			clocks = <&rcc DCMI>;
+			clock-names = "mclk";
+			status = "disabled";
+		};
+		m4_lptimer2: timer@50021000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50021000 0x400>;
+			clocks = <&rcc LPTIM2_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer3: timer@50022000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50022000 0x400>;
+			clocks = <&rcc LPTIM3_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer4: timer@50023000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50023000 0x400>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer5: timer@50024000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50024000 0x400>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_sai4: sai@50027000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50027000 0x4>;
+			clocks = <&rcc SAI4_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+			};
+		m4_fmc: memory-controller@58002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800200 0x1000>;
+			clocks = <&rcc FMC_K>;
+			status = "disabled";
+		};
+		m4_qspi: qspi@58003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+			clocks = <&rcc QSPI_K>;
+			status = "disabled";
+		};
+		m4_ethernet0: ethernet@5800a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800a000 0x2000>;
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "syscfg-clk";
+			clocks = <&rcc ETHMAC>,
+				 <&rcc ETHTX>,
+				 <&rcc ETHRX>,
+				 <&rcc ETHSTP>,
+				 <&rcc SYSCFG>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi b/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
index e15a3b2a9..20b4f0d82 100644
--- a/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
+++ b/arch/arm/boot/dts/stm32mp15-pinctrl.dtsi
@@ -4,6 +4,14 @@
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
+#include <dt-bindings/pinctrl/stm32mp15-hdp.h>
+
+&hdp {
+	hdp2_gpo: hdp2-pins {
+		pins = "hdp2";
+		function = HDP2_GPOVAL_2;
+	};
+};
 
 &pinctrl {
 	adc1_in6_pins_a: adc1-in6-0 {
@@ -188,7 +196,41 @@ pins {
 		};
 	};
 
-	ethernet0_rgmii_pins_a: rgmii-0 {
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+	dfsdm_data1_pins_a: dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_DATA1 */
+		};
+	};
+	dfsdm_data1_sleep_pins_a: dfsdm-data1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_DATA1 */
+		};
+	};
+	dfsdm_data3_pins_a: dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATA3 */
+		};
+	};
+	dfsdm_data3_sleep_pins_a: dfsdm-data3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	ethernet0_rgmii_pins_a: ethernet0-rgmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -219,7 +261,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_a: rgmii-sleep-0 {
+	ethernet0_rgmii_sleep_pins_a: ethernet0-rgmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -239,7 +281,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rgmii_pins_b: rgmii-1 {
+	ethernet0_rgmii_pins_b: ethernet0-rgmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -270,7 +312,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_b: rgmii-sleep-1 {
+	ethernet0_rgmii_sleep_pins_b: ethernet0-rgmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -290,7 +332,7 @@ pins1 {
 		 };
 	};
 
-	ethernet0_rgmii_pins_c: rgmii-2 {
+	ethernet0_rgmii_pins_c: ethernet0-rgmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -321,7 +363,7 @@ pins3 {
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_c: rgmii-sleep-2 {
+	ethernet0_rgmii_sleep_pins_c: ethernet0-rgmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -341,7 +383,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rmii_pins_a: rmii-0 {
+	ethernet0_rmii_pins_a: ethernet0-rmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -361,7 +403,7 @@ pins2 {
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_a: rmii-sleep-0 {
+	ethernet0_rmii_sleep_pins_a: ethernet0-rmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -375,7 +417,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rmii_pins_b: rmii-1 {
+	ethernet0_rmii_pins_b: ethernet0-rmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('B', 5, AF0)>, /* ETH1_CLK */
 				<STM32_PINMUX('C', 1, AF11)>, /* ETH1_MDC */
@@ -402,7 +444,7 @@ pins4 {
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_b: rmii-sleep-1 {
+	ethernet0_rmii_sleep_pins_b: ethernet0-rmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
 				<STM32_PINMUX('A', 7, ANALOG)>, /* ETH1_CRS_DV */
@@ -416,7 +458,7 @@ pins1 {
 		};
 	};
 
-	ethernet0_rmii_pins_c: rmii-2 {
+	ethernet0_rmii_pins_c: ethernet0-rmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -436,7 +478,7 @@ pins2 {
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_c: rmii-sleep-2 {
+	ethernet0_rmii_sleep_pins_c: ethernet0-rmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -549,6 +591,21 @@ pins {
 		};
 	};
 
+	hdp2_pins_a: hdp2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, AF0)>; /* HDP2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp2_sleep_pins_a: hdp2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>; /* HDP2 */
+		};
+	};
+
 	i2c1_pins_a: i2c1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
@@ -960,36 +1017,6 @@ pins {
 		};
 	};
 
-	mco1_pins_a: mco1-0 {
-		pins {
-			pinmux = <STM32_PINMUX('A', 13, AF2)>; /* MCO1 */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <1>;
-		};
-	};
-
-	mco1_sleep_pins_a: mco1-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('A', 13, ANALOG)>; /* MCO1 */
-		};
-	};
-
-	mco2_pins_a: mco2-0 {
-		pins {
-			pinmux = <STM32_PINMUX('G', 2, AF1)>; /* MCO2 */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <2>;
-		};
-	};
-
-	mco2_sleep_pins_a: mco2-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('G', 2, ANALOG)>; /* MCO2 */
-		};
-	};
-
 	m_can1_pins_a: m-can1-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('H', 13, AF9)>; /* CAN1_TX */
@@ -1003,7 +1030,7 @@ pins2 {
 		};
 	};
 
-	m_can1_sleep_pins_a: m_can1-sleep-0 {
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('I', 9, ANALOG)>; /* CAN1_RX */
@@ -1023,7 +1050,7 @@ pins2 {
 		};
 	};
 
-	m_can1_sleep_pins_b: m_can1-sleep-1 {
+	m_can1_sleep_pins_b: m-can1-sleep-1 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('A', 11, ANALOG)>; /* CAN1_RX */
@@ -1043,7 +1070,7 @@ pins2 {
 		};
 	};
 
-	m_can1_sleep_pins_c: m_can1-sleep-2 {
+	m_can1_sleep_pins_c: m-can1-sleep-2 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('H', 14, ANALOG)>; /* CAN1_RX */
@@ -1063,13 +1090,43 @@ pins2 {
 		};
 	};
 
-	m_can2_sleep_pins_a: m_can2-sleep-0 {
+	m_can2_sleep_pins_a: m-can2-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 13, ANALOG)>, /* CAN2_TX */
 				 <STM32_PINMUX('B', 5, ANALOG)>; /* CAN2_RX */
 		};
 	};
 
+	mco1_pins_a: mco1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, AF2)>; /* MCO1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	mco1_sleep_pins_a: mco1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, ANALOG)>; /* MCO1 */
+		};
+	};
+
+	mco2_pins_a: mco2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 2, AF1)>; /* MCO2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	mco2_sleep_pins_a: mco2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 2, ANALOG)>; /* MCO2 */
+		};
+	};
+
 	pwm1_pins_a: pwm1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('E', 9, AF1)>, /* TIM1_CH1 */
@@ -1245,21 +1302,6 @@ pins {
 		};
 	};
 
-	qspi_clk_pins_a: qspi-clk-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <3>;
-		};
-	};
-
-	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
-		};
-	};
-
 	qspi_bk1_pins_a: qspi-bk1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* QSPI_BK1_IO0 */
@@ -1302,6 +1344,21 @@ pins {
 		};
 	};
 
+	qspi_clk_pins_a: qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+		};
+	};
+
 	qspi_cs1_pins_a: qspi-cs1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
@@ -1332,6 +1389,12 @@ pins {
 		};
 	};
 
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
 	sai2a_pins_a: sai2a-0 {
 		pins {
 			pinmux = <STM32_PINMUX('I', 5, AF10)>, /* SAI2_SCK_A */
@@ -1475,6 +1538,18 @@ pins2 {
 		};
 	};
 
+	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
 	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -1499,18 +1574,6 @@ pins3 {
 		};
 	};
 
-	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
-		pins1 {
-			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
-				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
-				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
-				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
-			slew-rate = <1>;
-			drive-push-pull;
-			bias-disable;
-		};
-	};
-
 	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
@@ -1939,6 +2002,52 @@ pins2 {
 		};
 	};
 
+	spi4_pins_b: spi4-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 12, AF5)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, AF5)>; /* SPI4_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 13, AF5)>; /* SPI4_MISO */
+			bias-disable;
+		};
+	};
+
+	spi4_sleep_pins_b: spi4-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, ANALOG)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* SPI4_MISO */
+				 <STM32_PINMUX('E', 14, ANALOG)>; /* SPI4_MOSI */
+		};
+	};
+
+	spi5_pins_a: spi5-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF5)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, AF5)>; /* SPI5_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF5)>; /* SPI5_MISO */
+			bias-disable;
+		};
+	};
+
+	spi5_sleep_pins_a: spi5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* SPI5_MISO */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* SPI5_MOSI */
+		};
+	};
+
 	stusb1600_pins_a: stusb1600-0 {
 		pins {
 			pinmux = <STM32_PINMUX('I', 11, GPIO)>;
@@ -2178,7 +2287,7 @@ pins1 {
 				 <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
 			bias-disable;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>, /* USART2_RX */
@@ -2196,7 +2305,7 @@ pins2 {
 			pinmux = <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
 			bias-disable;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 		pins3 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>; /* USART2_RX */
@@ -2385,16 +2494,16 @@ pins {
 		};
 	};
 
-	usbotg_hs_pins_a: usbotg-hs-0 {
+	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
 		};
 	};
 
-	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
+	usbotg_hs_pins_a: usbotg-hs-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
-				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
 		};
 	};
 };
@@ -2463,4 +2572,39 @@ pins2 {
 			bias-disable;
 		};
 	};
+
+	spi1_sleep_pins_a: spi1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, ANALOG)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 6, AF4)>; /* USART1_CK */
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 7, AF7)>; /* USART1_TX_RX */
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART1_TX_RX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART1_CK */
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART1_TX_RX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART1_CK */
+		};
+	};
 };
diff --git a/arch/arm/boot/dts/stm32mp15-scmi.dtsi b/arch/arm/boot/dts/stm32mp15-scmi.dtsi
index 543f24c2f..caa8c15a3 100644
--- a/arch/arm/boot/dts/stm32mp15-scmi.dtsi
+++ b/arch/arm/boot/dts/stm32mp15-scmi.dtsi
@@ -16,7 +16,6 @@ scmi: scmi {
 			#address-cells = <1>;
 			#size-cells = <0>;
 			linaro,optee-channel-id = <0>;
-			shmem = <&scmi_shm>;
 
 			scmi_clk: protocol@14 {
 				reg = <0x14>;
@@ -27,77 +26,10 @@ scmi_reset: protocol@16 {
 				reg = <0x16>;
 				#reset-cells = <1>;
 			};
-
-			scmi_voltd: protocol@17 {
-				reg = <0x17>;
-
-				scmi_reguls: regulators {
-					#address-cells = <1>;
-					#size-cells = <0>;
-
-					scmi_reg11: reg11@0 {
-						reg = <0>;
-						regulator-name = "reg11";
-						regulator-min-microvolt = <1100000>;
-						regulator-max-microvolt = <1100000>;
-					};
-
-					scmi_reg18: reg18@1 {
-						voltd-name = "reg18";
-						reg = <1>;
-						regulator-name = "reg18";
-						regulator-min-microvolt = <1800000>;
-						regulator-max-microvolt = <1800000>;
-					};
-
-					scmi_usb33: usb33@2 {
-						reg = <2>;
-						regulator-name = "usb33";
-						regulator-min-microvolt = <3300000>;
-						regulator-max-microvolt = <3300000>;
-					};
-				};
-			};
-		};
-	};
-
-	soc {
-		scmi_sram: sram@2ffff000 {
-			compatible = "mmio-sram";
-			reg = <0x2ffff000 0x1000>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x2ffff000 0x1000>;
-
-			scmi_shm: scmi-sram@0 {
-				compatible = "arm,scmi-shmem";
-				reg = <0 0x80>;
-			};
 		};
 	};
 };
 
-&reg11 {
-	status = "disabled";
-};
-
-&reg18 {
-	status = "disabled";
-};
-
-&usb33 {
-	status = "disabled";
-};
-
-&usbotg_hs {
-	usb33d-supply = <&scmi_usb33>;
-};
-
-&usbphyc {
-	vdda1v1-supply = <&scmi_reg11>;
-	vdda1v8-supply = <&scmi_reg18>;
-};
-
 /delete-node/ &clk_hse;
 /delete-node/ &clk_hsi;
 /delete-node/ &clk_lse;
diff --git a/arch/arm/boot/dts/stm32mp151.dtsi b/arch/arm/boot/dts/stm32mp151.dtsi
index e02b3f5d4..c3d8cf012 100644
--- a/arch/arm/boot/dts/stm32mp151.dtsi
+++ b/arch/arm/boot/dts/stm32mp151.dtsi
@@ -3,8 +3,10 @@
  * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
+#include <dt-bindings/bus/stm32mp15_sys_bus.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
 
 / {
@@ -17,12 +19,48 @@ cpus {
 
 		cpu0: cpu@0 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <0>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
 		};
 	};
 
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x2>;
+			opp-suspend;
+		};
+
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x1>;
+		};
+
+		opp-800000000 {
+			opp-hz = /bits/ 64 <800000000>;
+			opp-microvolt = <1350000>;
+			opp-supported-hw = <0x2>;
+		};
+	};
+
+	intc: interrupt-controller@a0021000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0xa0021000 0x1000>,
+		      <0xa0022000 0x2000>;
+	};
+
 	arm-pmu {
 		compatible = "arm,cortex-a7-pmu";
 		interrupts = <GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>;
@@ -30,19 +68,17 @@ arm-pmu {
 		interrupt-parent = <&intc>;
 	};
 
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xb200005a>;
+		status = "disabled";
+	};
+
 	psci {
 		compatible = "arm,psci-1.0";
 		method = "smc";
 	};
 
-	intc: interrupt-controller@a0021000 {
-		compatible = "arm,cortex-a7-gic";
-		#interrupt-cells = <3>;
-		interrupt-controller;
-		reg = <0xa0021000 0x1000>,
-		      <0xa0022000 0x2000>;
-	};
-
 	timer {
 		compatible = "arm,armv7-timer";
 		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
@@ -53,6 +89,12 @@ timer {
 	};
 
 	clocks {
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+
 		clk_hse: clk-hse {
 			#clock-cells = <0>;
 			compatible = "fixed-clock";
@@ -76,14 +118,34 @@ clk_lsi: clk-lsi {
 			compatible = "fixed-clock";
 			clock-frequency = <32000>;
 		};
+	};
 
-		clk_csi: clk-csi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <4000000>;
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
 		};
 	};
 
+	booster: regulator-booster {
+		compatible = "st,stm32mp1-booster";
+		st,syscfg = <&syscfg>;
+		status = "disabled";
+	};
+
 	thermal-zones {
 		cpu_thermal: cpu-thermal {
 			polling-delay-passive = <0>;
@@ -91,12 +153,6 @@ cpu_thermal: cpu-thermal {
 			thermal-sensors = <&dts>;
 
 			trips {
-				cpu_alert1: cpu-alert1 {
-					temperature = <85000>;
-					hysteresis = <0>;
-					type = "passive";
-				};
-
 				cpu-crit {
 					temperature = <120000>;
 					hysteresis = <0>;
@@ -109,12 +165,6 @@ cooling-maps {
 		};
 	};
 
-	booster: regulator-booster {
-		compatible = "st,stm32mp1-booster";
-		st,syscfg = <&syscfg>;
-		status = "disabled";
-	};
-
 	soc {
 		compatible = "simple-bus";
 		#address-cells = <1>;
@@ -122,1690 +172,2106 @@ soc {
 		interrupt-parent = <&intc>;
 		ranges;
 
-		timers2: timer@40000000 {
+		sram4: sram@10050000 {
+			compatible = "mmio-sram";
+			reg = <0x10050000 0x10000>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40000000 0x400>;
-			interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM2_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 18 0x400 0x1>,
-			       <&dmamux1 19 0x400 0x1>,
-			       <&dmamux1 20 0x400 0x1>,
-			       <&dmamux1 21 0x400 0x1>,
-			       <&dmamux1 22 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@1 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <1>;
-				status = "disabled";
-			};
+			#size-cells = <1>;
+			ranges = <0 0x10050000 0x10000>;
+		};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+		hsem: hwspinlock@4c000000 {
+			compatible = "st,stm32-hwspinlock";
+			#hwlock-cells = <2>;
+			reg = <0x4c000000 0x400>;
+			clocks = <&rcc HSEM>;
+			clock-names = "hsem";
 		};
 
-		timers3: timer@40001000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40001000 0x400>;
-			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM3_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 23 0x400 0x1>,
-			       <&dmamux1 24 0x400 0x1>,
-			       <&dmamux1 25 0x400 0x1>,
-			       <&dmamux1 26 0x400 0x1>,
-			       <&dmamux1 27 0x400 0x1>,
-			       <&dmamux1 28 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+		ipcc: mailbox@4c001000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x4c001000 0x400>;
+			st,proc-id = <0>;
+			interrupts-extended =
+				<&exti 61 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&rcc IPCC>;
+			wakeup-source;
+			power-domains = <&pd_core>;
 			status = "disabled";
+		};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@2 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <2>;
-				status = "disabled";
-			};
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp1-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&clk_hse>, <&clk_hsi>, <&clk_csi>,
+				 <&clk_lse>, <&clk_lsi>;
 		};
 
-		timers4: timer@40002000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40002000 0x400>;
-			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM4_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 29 0x400 0x1>,
-			       <&dmamux1 30 0x400 0x1>,
-			       <&dmamux1 31 0x400 0x1>,
-			       <&dmamux1 32 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4";
-			status = "disabled";
+		pwr_regulators: pwr@50001000 {
+			compatible = "st,stm32mp1,pwr-reg";
+			reg = <0x50001000 0x10>;
+			st,tzcr = <&rcc 0x0 0x1>;
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+			reg11: reg11 {
+				regulator-name = "reg11";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1100000>;
 			};
 
-			timer@3 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <3>;
-				status = "disabled";
+			reg18: reg18 {
+				regulator-name = "reg18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
 			};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			usb33: usb33 {
+				regulator-name = "usb33";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
 			};
 		};
 
-		timers5: timer@40003000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40003000 0x400>;
-			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM5_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 55 0x400 0x1>,
-			       <&dmamux1 56 0x400 0x1>,
-			       <&dmamux1 57 0x400 0x1>,
-			       <&dmamux1 58 0x400 0x1>,
-			       <&dmamux1 59 0x400 0x1>,
-			       <&dmamux1 60 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@4 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <4>;
-				status = "disabled";
-			};
-
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+		pwr_mcu: pwr-mcu@50001014 {
+			compatible = "st,stm32mp151-pwr-mcu", "syscon";
+			reg = <0x50001014 0x4>;
 		};
 
-		timers6: timer@40004000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40004000 0x400>;
-			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM6_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 69 0x400 0x1>;
-			dma-names = "up";
-			status = "disabled";
+		pwr_irq: pwr@50001020 {
+			compatible = "st,stm32mp1-pwr";
+			reg = <0x50001020 0x100>;
+			interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
 
-			timer@5 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <5>;
-				status = "disabled";
-			};
+			st,wakeup-pins = <&gpioa 0 GPIO_ACTIVE_HIGH>,
+					 <&gpioa 2 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 13 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 8 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 11 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 1 GPIO_ACTIVE_HIGH>;
 		};
 
-		timers7: timer@40005000 {
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40005000 0x400>;
-			interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM7_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 70 0x400 0x1>;
-			dma-names = "up";
-			status = "disabled";
+			#size-cells = <1>;
+			compatible = "st,stm32mp157-pinctrl";
+			ranges = <0 0x50002000 0xa400>;
+			interrupt-parent = <&exti>;
+			hwlocks = <&hsem 0 1>;
+			pins-are-numbered;
 
-			timer@6 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <6>;
+			gpioa: gpio@50002000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc GPIOA>;
+				st,bank-name = "GPIOA";
 				status = "disabled";
 			};
-		};
-
-		timers12: timer@40006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40006000 0x400>;
-			interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM12_K>;
-			clock-names = "int";
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiob: gpio@50003000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x1000 0x400>;
+				clocks = <&rcc GPIOB>;
+				st,bank-name = "GPIOB";
 				status = "disabled";
 			};
 
-			timer@11 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <11>;
+			gpioc: gpio@50004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x2000 0x400>;
+				clocks = <&rcc GPIOC>;
+				st,bank-name = "GPIOC";
 				status = "disabled";
 			};
-		};
-
-		timers13: timer@40007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40007000 0x400>;
-			interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM13_K>;
-			clock-names = "int";
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiod: gpio@50005000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x3000 0x400>;
+				clocks = <&rcc GPIOD>;
+				st,bank-name = "GPIOD";
 				status = "disabled";
 			};
 
-			timer@12 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <12>;
+			gpioe: gpio@50006000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x4000 0x400>;
+				clocks = <&rcc GPIOE>;
+				st,bank-name = "GPIOE";
 				status = "disabled";
 			};
-		};
 
-		timers14: timer@40008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40008000 0x400>;
-			interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM14_K>;
-			clock-names = "int";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiof: gpio@50007000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x5000 0x400>;
+				clocks = <&rcc GPIOF>;
+				st,bank-name = "GPIOF";
 				status = "disabled";
 			};
 
-			timer@13 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <13>;
+			gpiog: gpio@50008000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x6000 0x400>;
+				clocks = <&rcc GPIOG>;
+				st,bank-name = "GPIOG";
 				status = "disabled";
 			};
-		};
-
-		lptimer1: timer@40009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x40009000 0x400>;
-			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM1_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
+			gpioh: gpio@50009000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x7000 0x400>;
+				clocks = <&rcc GPIOH>;
+				st,bank-name = "GPIOH";
 				status = "disabled";
 			};
 
-			trigger@0 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <0>;
+			gpioi: gpio@5000a000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x8000 0x400>;
+				clocks = <&rcc GPIOI>;
+				st,bank-name = "GPIOI";
 				status = "disabled";
 			};
 
-			counter {
-				compatible = "st,stm32-lptimer-counter";
+			gpioj: gpio@5000b000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x9000 0x400>;
+				clocks = <&rcc GPIOJ>;
+				st,bank-name = "GPIOJ";
 				status = "disabled";
 			};
-		};
 
-		spi2: spi@4000b000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI2_K>;
-			resets = <&rcc SPI2_R>;
-			dmas = <&dmamux1 39 0x400 0x05>,
-			       <&dmamux1 40 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			gpiok: gpio@5000c000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa000 0x400>;
+				clocks = <&rcc GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
 
-		i2s2: audio-controller@4000b000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 39 0x400 0x01>,
-			       <&dmamux1 40 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+			hwlocks = <&hsem 1 1>;
+			wakeup-parent = <&pwr_irq>;
+			interrupts-extended =
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 64  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 42  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 76  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 33  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 95  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 37  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 71  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 52  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 82  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<&intc GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+				<&pwr_irq 0 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 1 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 2 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 3 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 4 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 5 IRQ_TYPE_EDGE_FALLING 0>,		/* EXTI_60 */
+				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 94  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 62  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		spi3: spi@4000c000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI3_K>;
-			resets = <&rcc SPI3_R>;
-			dmas = <&dmamux1 61 0x400 0x05>,
-			       <&dmamux1 62 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
 		};
 
-		i2s3: audio-controller@4000c000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 61 0x400 0x01>,
-			       <&dmamux1 62 0x400 0x01>;
-			dma-names = "rx", "tx";
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			reg = <0x50028000 0x100>;
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc TMPSENS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
 			status = "disabled";
 		};
 
-		spdifrx: audio-controller@4000d000 {
-			compatible = "st,stm32h7-spdifrx";
-			#sound-dai-cells = <0>;
-			reg = <0x4000d000 0x400>;
-			clocks = <&rcc SPDIF_K>;
-			clock-names = "kclk";
-			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 93 0x400 0x01>,
-			       <&dmamux1 94 0x400 0x01>;
-			dma-names = "rx", "rx-ctrl";
+		hdp: pinctrl@5002a000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
 			status = "disabled";
 		};
 
-		usart2: serial@4000e000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4000e000 0x400>;
-			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART2_K>;
-			wakeup-source;
-			dmas = <&dmamux1 43 0x400 0x15>,
-			       <&dmamux1 44 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		pinctrl_z: pinctrl@54004000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp157-z-pinctrl";
+			ranges = <0 0x54004000 0x400>;
+			pins-are-numbered;
+			interrupt-parent = <&exti>;
+			hwlocks = <&hsem 0 1>;
+
+			gpioz: gpio@54004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&rcc GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
 		};
 
-		usart3: serial@4000f000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4000f000 0x400>;
-			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART3_K>;
-			wakeup-source;
-			dmas = <&dmamux1 45 0x400 0x15>,
-			       <&dmamux1 46 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		mdma1: dma-controller@58000000 {
+			compatible = "st,stm32h7-mdma";
+			reg = <0x58000000 0x1000>;
+			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc MDMA>;
+			resets = <&rcc MDMA_R>;
+			#dma-cells = <5>;
+			dma-channels = <32>;
+			dma-requests = <48>;
 		};
 
-		uart4: serial@40010000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40010000 0x400>;
-			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART4_K>;
-			wakeup-source;
-			dmas = <&dmamux1 63 0x400 0x15>,
-			       <&dmamux1 64 0x400 0x11>;
-			dma-names = "rx", "tx";
+		sdmmc1: mmc@58005000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00253180>;
+			reg = <0x58005000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SDMMC1_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
 			status = "disabled";
 		};
 
-		uart5: serial@40011000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40011000 0x400>;
-			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART5_K>;
-			wakeup-source;
-			dmas = <&dmamux1 65 0x400 0x15>,
-			       <&dmamux1 66 0x400 0x11>;
-			dma-names = "rx", "tx";
+		sdmmc2: mmc@58007000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00253180>;
+			reg = <0x58007000 0x1000>;
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SDMMC2_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
 			status = "disabled";
 		};
 
-		i2c1: i2c@40012000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40012000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C1_K>;
-			resets = <&rcc I2C1_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x1>;
-			wakeup-source;
-			i2c-analog-filter;
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
 			status = "disabled";
 		};
 
-		i2c2: i2c@40013000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40013000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C2_K>;
-			resets = <&rcc I2C2_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x2>;
-			wakeup-source;
-			i2c-analog-filter;
+		usbh_ohci: usb@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
-		i2c3: i2c@40014000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40014000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C3_K>;
-			resets = <&rcc I2C3_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x4>;
+		usbh_ehci: usb@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
 			wakeup-source;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
-		i2c5: i2c@40015000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40015000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C5_K>;
-			resets = <&rcc I2C5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x10>;
-			wakeup-source;
-			i2c-analog-filter;
+		ltdc: display-controller@5a001000 {
+			compatible = "st,stm32-ltdc";
+			reg = <0x5a001000 0x400>;
+			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LTDC_PX>;
+			clock-names = "lcd";
+			resets = <&rcc LTDC_R>;
 			status = "disabled";
 		};
 
-		cec: cec@40016000 {
-			compatible = "st,stm32-cec";
-			reg = <0x40016000 0x400>;
-			interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CEC_K>, <&rcc CEC>;
-			clock-names = "cec", "hdmi-cec";
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
+			clock-names = "pclk", "lsi";
 			status = "disabled";
 		};
 
-		dac: dac@40017000 {
-			compatible = "st,stm32h7-dac-core";
-			reg = <0x40017000 0x400>;
-			clocks = <&rcc DAC12>;
-			clock-names = "pclk";
+		usbphyc: usbphyc@5a006000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
+			#clock-cells = <0>;
+			compatible = "st,stm32mp1-usbphyc";
+			reg = <0x5a006000 0x1000>;
+			clocks = <&rcc USBPHY_K>;
+			resets = <&rcc USBPHY_R>;
+			vdda1v1-supply = <&reg11>;
+			vdda1v8-supply = <&reg18>;
 			status = "disabled";
 
-			dac1: dac@1 {
-				compatible = "st,stm32-dac";
-				#io-channel-cells = <1>;
-				reg = <1>;
-				status = "disabled";
+			usbphyc_port0: usb-phy@0 {
+				#phy-cells = <0>;
+				reg = <0>;
 			};
 
-			dac2: dac@2 {
-				compatible = "st,stm32-dac";
-				#io-channel-cells = <1>;
-				reg = <2>;
-				status = "disabled";
+			usbphyc_port1: usb-phy@1 {
+				#phy-cells = <1>;
+				reg = <1>;
 			};
 		};
 
-		uart7: serial@40018000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40018000 0x400>;
-			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART7_K>;
-			wakeup-source;
-			dmas = <&dmamux1 79 0x400 0x15>,
-			       <&dmamux1 80 0x400 0x11>;
-			dma-names = "rx", "tx";
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
 			status = "disabled";
 		};
 
-		uart8: serial@40019000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40019000 0x400>;
-			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART8_K>;
-			wakeup-source;
-			dmas = <&dmamux1 81 0x400 0x15>,
-			       <&dmamux1 82 0x400 0x11>;
-			dma-names = "rx", "tx";
+		rtc: rtc@5c004000 {
+			compatible = "st,stm32mp1-rtc";
+			reg = <0x5c004000 0x400>;
+			clocks = <&rcc RTCAPB>, <&rcc RTC>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
-		timers1: timer@44000000 {
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp15-bsec";
+			reg = <0x5c005000 0x400>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44000000 0x400>;
-			interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "brk", "up", "trg-com", "cc";
-			clocks = <&rcc TIM1_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 11 0x400 0x1>,
-			       <&dmamux1 12 0x400 0x1>,
-			       <&dmamux1 13 0x400 0x1>,
-			       <&dmamux1 14 0x400 0x1>,
-			       <&dmamux1 15 0x400 0x1>,
-			       <&dmamux1 16 0x400 0x1>,
-			       <&dmamux1 17 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4",
-				    "up", "trig", "com";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+			#size-cells = <1>;
+			part_number_otp: part-number-otp@4 {
+				reg = <0x4 0x1>;
 			};
-
-			timer@0 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <0>;
-				status = "disabled";
+			vrefint: vrefin-cal@52 {
+				reg = <0x52 0x2>;
 			};
-
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			ethernet_mac_address: mac@e4 {
+				reg = <0xe4 0x6>;
 			};
 		};
 
-		timers8: timer@44001000 {
+		etzpc: etzpc@5c007000 {
+			compatible = "st,stm32mp15-sys-bus";
+			reg = <0x5c007000 0x400>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44001000 0x400>;
-			interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "brk", "up", "trg-com", "cc";
-			clocks = <&rcc TIM8_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 47 0x400 0x1>,
-			       <&dmamux1 48 0x400 0x1>,
-			       <&dmamux1 49 0x400 0x1>,
-			       <&dmamux1 50 0x400 0x1>,
-			       <&dmamux1 51 0x400 0x1>,
-			       <&dmamux1 52 0x400 0x1>,
-			       <&dmamux1 53 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4",
-				    "up", "trig", "com";
-			status = "disabled";
+			#size-cells = <1>;
+			ranges;
+			feature-domain-controller;
+			#feature-domain-cells = <1>;
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
+			timers2: timer@40000000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM2_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 18 0x400 0x1>,
+				       <&dmamux1 19 0x400 0x1>,
+				       <&dmamux1 20 0x400 0x1>,
+				       <&dmamux1 21 0x400 0x1>,
+				       <&dmamux1 22 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM2_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			timer@7 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <7>;
-				status = "disabled";
-			};
+				timer@1 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
-		};
 
-		usart6: serial@44003000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x44003000 0x400>;
-			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART6_K>;
-			wakeup-source;
-			dmas = <&dmamux1 71 0x400 0x15>,
-			       <&dmamux1 72 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers3: timer@40001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40001000 0x400>;
+				interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM3_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 23 0x400 0x1>,
+				       <&dmamux1 24 0x400 0x1>,
+				       <&dmamux1 25 0x400 0x1>,
+				       <&dmamux1 26 0x400 0x1>,
+				       <&dmamux1 27 0x400 0x1>,
+				       <&dmamux1 28 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM3_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		spi1: spi@44004000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44004000 0x400>;
-			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI1_K>;
-			resets = <&rcc SPI1_R>;
-			dmas = <&dmamux1 37 0x400 0x05>,
-			       <&dmamux1 38 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+				timer@2 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
 
-		i2s1: audio-controller@44004000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x44004000 0x400>;
-			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 37 0x400 0x01>,
-			       <&dmamux1 38 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+			};
 
-		spi4: spi@44005000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44005000 0x400>;
-			interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI4_K>;
-			resets = <&rcc SPI4_R>;
-			dmas = <&dmamux1 83 0x400 0x05>,
-			       <&dmamux1 84 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers4: timer@40002000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40002000 0x400>;
+				interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM4_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 29 0x400 0x1>,
+				       <&dmamux1 30 0x400 0x1>,
+				       <&dmamux1 31 0x400 0x1>,
+				       <&dmamux1 32 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM4_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		timers15: timer@44006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44006000 0x400>;
-			interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM15_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 105 0x400 0x1>,
-			       <&dmamux1 106 0x400 0x1>,
-			       <&dmamux1 107 0x400 0x1>,
-			       <&dmamux1 108 0x400 0x1>;
-			dma-names = "ch1", "up", "trig", "com";
-			status = "disabled";
+				timer@3 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			timer@14 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <14>;
-				status = "disabled";
-			};
-		};
+			timers5: timer@40003000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40003000 0x400>;
+				interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM5_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 55 0x400 0x1>,
+				       <&dmamux1 56 0x400 0x1>,
+				       <&dmamux1 57 0x400 0x1>,
+				       <&dmamux1 58 0x400 0x1>,
+				       <&dmamux1 59 0x400 0x1>,
+				       <&dmamux1 60 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM5_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		timers16: timer@44007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44007000 0x400>;
-			interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM16_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 109 0x400 0x1>,
-			       <&dmamux1 110 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
+				timer@4 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-			timer@15 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <15>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
-		};
 
-		timers17: timer@44008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44008000 0x400>;
-			interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "global";
-			clocks = <&rcc TIM17_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 111 0x400 0x1>,
-			       <&dmamux1 112 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
+			timers6: timer@40004000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40004000 0x400>;
+				interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM6_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 69 0x400 0x1>;
+				dma-names = "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM6_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				timer@5 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
 			};
 
-			timer@16 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <16>;
-				status = "disabled";
+			timers7: timer@40005000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40005000 0x400>;
+				interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM7_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 70 0x400 0x1>;
+				dma-names = "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM7_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
 			};
-		};
 
-		spi5: spi@44009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44009000 0x400>;
-			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI5_K>;
-			resets = <&rcc SPI5_R>;
-			dmas = <&dmamux1 85 0x400 0x05>,
-			       <&dmamux1 86 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers12: timer@40006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40006000 0x400>;
+				interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM12_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM12_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		sai1: sai@4400a000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400a000 0x400>;
-			reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
-			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI1_R>;
-			status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			sai1a: audio-controller@4400a004 {
-				#sound-dai-cells = <0>;
-
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x4 0x20>;
-				clocks = <&rcc SAI1_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 87 0x400 0x01>;
-				status = "disabled";
+				timer@11 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
 			};
 
-			sai1b: audio-controller@4400a024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI1_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 88 0x400 0x01>;
-				status = "disabled";
-			};
-		};
+			timers13: timer@40007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40007000 0x400>;
+				interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM13_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM13_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		sai2: sai@4400b000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400b000 0x400>;
-			reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
-			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI2_R>;
-			status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			sai2a: audio-controller@4400b004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x4 0x20>;
-				clocks = <&rcc SAI2_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 89 0x400 0x01>;
-				status = "disabled";
+				timer@12 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
 			};
 
-			sai2b: audio-controller@4400b024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI2_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 90 0x400 0x01>;
-				status = "disabled";
+			timers14: timer@40008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40008000 0x400>;
+				interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM14_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM14_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
 			};
-		};
 
-		sai3: sai@4400c000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400c000 0x400>;
-			reg = <0x4400c000 0x4>, <0x4400c3f0 0x10>;
-			interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI3_R>;
-			status = "disabled";
+			lptimer1: timer@40009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x40009000 0x400>;
+				interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM1_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM1_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			sai3a: audio-controller@4400c004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x04 0x20>;
-				clocks = <&rcc SAI3_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 113 0x400 0x01>;
-				status = "disabled";
+				trigger@0 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			sai3b: audio-controller@4400c024 {
+			i2s2: audio-controller@4000b000 {
+				compatible = "st,stm32h7-i2s";
 				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI3_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 114 0x400 0x01>;
+				reg = <0x4000b000 0x400>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 39 0x400 0x01>,
+				       <&dmamux1 40 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI2_ID>;
 				status = "disabled";
 			};
-		};
-
-		dfsdm: dfsdm@4400d000 {
-			compatible = "st,stm32mp1-dfsdm";
-			reg = <0x4400d000 0x800>;
-			clocks = <&rcc DFSDM_K>;
-			clock-names = "dfsdm";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
 
-			dfsdm0: filter@0 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <0>;
-				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 101 0x400 0x01>;
-				dma-names = "rx";
+			spi2: spi@4000b000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x4000b000 0x400>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI2_K>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&dmamux1 39 0x400 0x01>,
+				       <&dmamux1 40 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI2_ID>;
 				status = "disabled";
 			};
 
-			dfsdm1: filter@1 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <1>;
-				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 102 0x400 0x01>;
-				dma-names = "rx";
+			i2s3: audio-controller@4000c000 {
+				compatible = "st,stm32h7-i2s";
+				#sound-dai-cells = <0>;
+				reg = <0x4000c000 0x400>;
+				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 61 0x400 0x01>,
+				       <&dmamux1 62 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI3_ID>;
 				status = "disabled";
 			};
 
-			dfsdm2: filter@2 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <2>;
-				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 103 0x400 0x01>;
-				dma-names = "rx";
+			spi3: spi@4000c000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x4000c000 0x400>;
+				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI3_K>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&dmamux1 61 0x400 0x01>,
+				       <&dmamux1 62 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI3_ID>;
 				status = "disabled";
 			};
 
-			dfsdm3: filter@3 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <3>;
-				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 104 0x400 0x01>;
-				dma-names = "rx";
+			spdifrx: audio-controller@4000d000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x4000d000 0x400>;
+				clocks = <&rcc SPDIF_K>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 93 0x400 0x01>,
+				       <&dmamux1 94 0x400 0x01>;
+				dma-names = "rx", "rx-ctrl";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPDIFRX_ID>;
+				status = "disabled";
+			};
+
+			usart2: serial@4000e000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4000e000 0x400>;
+				interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART2_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 43 0x400 0x15>,
+				       <&dmamux1 44 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART2_ID>;
+				status = "disabled";
+			};
+
+			usart3: serial@4000f000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4000f000 0x400>;
+				interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART3_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 45 0x400 0x15>,
+				       <&dmamux1 46 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART3_ID>;
+				status = "disabled";
+			};
+
+			uart4: serial@40010000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40010000 0x400>;
+				interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART4_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 63 0x400 0x15>,
+				       <&dmamux1 64 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART4_ID>;
+				status = "disabled";
+			};
+
+			uart5: serial@40011000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40011000 0x400>;
+				interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART5_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 65 0x400 0x15>,
+				       <&dmamux1 66 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART5_ID>;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40012000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40012000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 21 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C1_K>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 33 0x400 0x1>,
+				       <&dmamux1 34 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x1>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C1_ID>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40013000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40013000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C2_K>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 35 0x400 0x1>,
+				       <&dmamux1 36 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x2>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C2_ID>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40014000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40014000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 23 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C3_K>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 73 0x400 0x1>,
+				       <&dmamux1 74 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x4>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C3_ID>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40015000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40015000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 25 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C5_K>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 115 0x400 0x1>,
+				       <&dmamux1 116 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x10>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C5_ID>;
 				status = "disabled";
 			};
 
-			dfsdm4: filter@4 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <4>;
-				interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 91 0x400 0x01>;
-				dma-names = "rx";
+			cec: cec@40016000 {
+				compatible = "st,stm32-cec";
+				reg = <0x40016000 0x400>;
+				interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CEC_K>, <&rcc CEC>;
+				clock-names = "cec", "hdmi-cec";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CEC_ID>;
 				status = "disabled";
 			};
 
-			dfsdm5: filter@5 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <5>;
-				interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 92 0x400 0x01>;
-				dma-names = "rx";
+			dac: dac@40017000 {
+				compatible = "st,stm32h7-dac-core";
+				reg = <0x40017000 0x400>;
+				clocks = <&rcc DAC12>;
+				clock-names = "pclk";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DAC_ID>;
 				status = "disabled";
-			};
-		};
-
-		dma1: dma-controller@48000000 {
-			compatible = "st,stm32-dma";
-			reg = <0x48000000 0x400>;
-			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc DMA1>;
-			resets = <&rcc DMA1_R>;
-			#dma-cells = <4>;
-			st,mem2mem;
-			dma-requests = <8>;
-		};
-
-		dma2: dma-controller@48001000 {
-			compatible = "st,stm32-dma";
-			reg = <0x48001000 0x400>;
-			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc DMA2>;
-			resets = <&rcc DMA2_R>;
-			#dma-cells = <4>;
-			st,mem2mem;
-			dma-requests = <8>;
-		};
 
-		dmamux1: dma-router@48002000 {
-			compatible = "st,stm32h7-dmamux";
-			reg = <0x48002000 0x40>;
-			#dma-cells = <3>;
-			dma-requests = <128>;
-			dma-masters = <&dma1 &dma2>;
-			dma-channels = <16>;
-			clocks = <&rcc DMAMUX>;
-			resets = <&rcc DMAMUX_R>;
-		};
+				dac1: dac@1 {
+					compatible = "st,stm32-dac";
+					#io-channel-cells = <1>;
+					reg = <1>;
+					status = "disabled";
+				};
 
-		adc: adc@48003000 {
-			compatible = "st,stm32mp1-adc-core";
-			reg = <0x48003000 0x400>;
-			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
-			clock-names = "bus", "adc";
-			interrupt-controller;
-			st,syscfg = <&syscfg>;
-			#interrupt-cells = <1>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
+				dac2: dac@2 {
+					compatible = "st,stm32-dac";
+					#io-channel-cells = <1>;
+					reg = <2>;
+					status = "disabled";
+				};
+			};
 
-			adc1: adc@0 {
-				compatible = "st,stm32mp1-adc";
-				#io-channel-cells = <1>;
-				reg = <0x0>;
-				interrupt-parent = <&adc>;
-				interrupts = <0>;
-				dmas = <&dmamux1 9 0x400 0x01>;
-				dma-names = "rx";
+			uart7: serial@40018000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40018000 0x400>;
+				interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART7_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 79 0x400 0x15>,
+				       <&dmamux1 80 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART7_ID>;
 				status = "disabled";
 			};
 
-			adc2: adc@100 {
-				compatible = "st,stm32mp1-adc";
-				#io-channel-cells = <1>;
-				reg = <0x100>;
-				interrupt-parent = <&adc>;
-				interrupts = <1>;
-				dmas = <&dmamux1 10 0x400 0x01>;
-				dma-names = "rx";
+			uart8: serial@40019000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40019000 0x400>;
+				interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART8_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 81 0x400 0x15>,
+				       <&dmamux1 82 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART8_ID>;
 				status = "disabled";
 			};
-		};
-
-		sdmmc3: mmc@48004000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x48004000 0x400>;
-			interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC3_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC3_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
-
-		usbotg_hs: usb-otg@49000000 {
-			compatible = "st,stm32mp15-hsotg", "snps,dwc2";
-			reg = <0x49000000 0x10000>;
-			clocks = <&rcc USBO_K>;
-			clock-names = "otg";
-			resets = <&rcc USBO_R>;
-			reset-names = "dwc2";
-			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
-			g-rx-fifo-size = <512>;
-			g-np-tx-fifo-size = <32>;
-			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
-			dr_mode = "otg";
-			otg-rev = <0x200>;
-			usb33d-supply = <&usb33>;
-			status = "disabled";
-		};
-
-		ipcc: mailbox@4c001000 {
-			compatible = "st,stm32mp1-ipcc";
-			#mbox-cells = <1>;
-			reg = <0x4c001000 0x400>;
-			st,proc-id = <0>;
-			interrupts-extended =
-				<&exti 61 1>,
-				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "rx", "tx";
-			clocks = <&rcc IPCC>;
-			wakeup-source;
-			status = "disabled";
-		};
-
-		dcmi: dcmi@4c006000 {
-			compatible = "st,stm32-dcmi";
-			reg = <0x4c006000 0x400>;
-			interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc CAMITF_R>;
-			clocks = <&rcc DCMI>;
-			clock-names = "mclk";
-			dmas = <&dmamux1 75 0x400 0x01>;
-			dma-names = "tx";
-			status = "disabled";
-		};
-
-		rcc: rcc@50000000 {
-			compatible = "st,stm32mp1-rcc", "syscon";
-			reg = <0x50000000 0x1000>;
-			#clock-cells = <1>;
-			#reset-cells = <1>;
-		};
-
-		pwr_regulators: pwr@50001000 {
-			compatible = "st,stm32mp1,pwr-reg";
-			reg = <0x50001000 0x10>;
 
-			reg11: reg11 {
-				regulator-name = "reg11";
-				regulator-min-microvolt = <1100000>;
-				regulator-max-microvolt = <1100000>;
-			};
+			timers1: timer@44000000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44000000 0x400>;
+				interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc TIM1_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 11 0x400 0x1>,
+				       <&dmamux1 12 0x400 0x1>,
+				       <&dmamux1 13 0x400 0x1>,
+				       <&dmamux1 14 0x400 0x1>,
+				       <&dmamux1 15 0x400 0x1>,
+				       <&dmamux1 16 0x400 0x1>,
+				       <&dmamux1 17 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4",
+					    "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM1_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			reg18: reg18 {
-				regulator-name = "reg18";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-			};
+				timer@0 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
 
-			usb33: usb33 {
-				regulator-name = "usb33";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
-		};
-
-		pwr_mcu: pwr_mcu@50001014 {
-			compatible = "st,stm32mp151-pwr-mcu", "syscon";
-			reg = <0x50001014 0x4>;
-		};
-
-		exti: interrupt-controller@5000d000 {
-			compatible = "st,stm32mp1-exti", "syscon";
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			reg = <0x5000d000 0x400>;
-		};
 
-		syscfg: syscon@50020000 {
-			compatible = "st,stm32mp157-syscfg", "syscon";
-			reg = <0x50020000 0x400>;
-			clocks = <&rcc SYSCFG>;
-		};
+			timers8: timer@44001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44001000 0x400>;
+				interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc TIM8_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 47 0x400 0x1>,
+				       <&dmamux1 48 0x400 0x1>,
+				       <&dmamux1 49 0x400 0x1>,
+				       <&dmamux1 50 0x400 0x1>,
+				       <&dmamux1 51 0x400 0x1>,
+				       <&dmamux1 52 0x400 0x1>,
+				       <&dmamux1 53 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4",
+					    "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM8_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		lptimer2: timer@50021000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50021000 0x400>;
-			interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM2_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+				timer@7 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			trigger@1 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <1>;
+			usart6: serial@44003000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x44003000 0x400>;
+				interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART6_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 71 0x400 0x15>,
+				       <&dmamux1 72 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART6_ID>;
 				status = "disabled";
 			};
 
-			counter {
-				compatible = "st,stm32-lptimer-counter";
+			i2s1: audio-controller@44004000 {
+				compatible = "st,stm32h7-i2s";
+				#sound-dai-cells = <0>;
+				reg = <0x44004000 0x400>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 37 0x400 0x01>,
+				       <&dmamux1 38 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI1_ID>;
 				status = "disabled";
 			};
-		};
-
-		lptimer3: timer@50022000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50022000 0x400>;
-			interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM3_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
+			spi1: spi@44004000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44004000 0x400>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI1_K>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&dmamux1 37 0x400 0x01>,
+				       <&dmamux1 38 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI1_ID>;
 				status = "disabled";
 			};
 
-			trigger@2 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <2>;
+			spi4: spi@44005000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44005000 0x400>;
+				interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI4_K>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI4_ID>;
 				status = "disabled";
 			};
-		};
 
-		lptimer4: timer@50023000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50023000 0x400>;
-			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM4_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+			timers15: timer@44006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44006000 0x400>;
+				interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM15_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 105 0x400 0x1>,
+				       <&dmamux1 106 0x400 0x1>,
+				       <&dmamux1 107 0x400 0x1>,
+				       <&dmamux1 108 0x400 0x1>;
+				dma-names = "ch1", "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM15_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
 			};
-		};
 
-		lptimer5: timer@50024000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50024000 0x400>;
-			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM5_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+			timers16: timer@44007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44007000 0x400>;
+				interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM16_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 109 0x400 0x1>,
+				       <&dmamux1 110 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM16_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
 			};
-		};
 
-		vrefbuf: vrefbuf@50025000 {
-			compatible = "st,stm32-vrefbuf";
-			reg = <0x50025000 0x8>;
-			regulator-min-microvolt = <1500000>;
-			regulator-max-microvolt = <2500000>;
-			clocks = <&rcc VREF>;
-			status = "disabled";
-		};
+			timers17: timer@44008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44008000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM17_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 111 0x400 0x1>,
+				       <&dmamux1 112 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM17_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		sai4: sai@50027000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x50027000 0x400>;
-			reg = <0x50027000 0x4>, <0x500273f0 0x10>;
-			interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI4_R>;
-			status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			sai4a: audio-controller@50027004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x04 0x20>;
-				clocks = <&rcc SAI4_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 99 0x400 0x01>;
-				status = "disabled";
+				timer@16 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
 			};
 
-			sai4b: audio-controller@50027024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI4_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 100 0x400 0x01>;
+			spi5: spi@44009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44009000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI5_K>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&dmamux1 85 0x400 0x01>,
+				       <&dmamux1 86 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI5_ID>;
 				status = "disabled";
 			};
-		};
 
-		dts: thermal@50028000 {
-			compatible = "st,stm32-thermal";
-			reg = <0x50028000 0x100>;
-			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc TMPSENS>;
-			clock-names = "pclk";
-			#thermal-sensor-cells = <0>;
-			status = "disabled";
-		};
+			sai1: sai@4400a000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400a000 0x400>;
+				reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI1_ID>;
+				status = "disabled";
+
+				sai1a: audio-controller@4400a004 {
+					#sound-dai-cells = <0>;
+
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					clocks = <&rcc SAI1_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 87 0x400 0x01>;
+					status = "disabled";
+				};
 
-		hash1: hash@54002000 {
-			compatible = "st,stm32f756-hash";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc HASH1>;
-			resets = <&rcc HASH1_R>;
-			dmas = <&mdma1 31 0x2 0x1000A02 0x0 0x0>;
-			dma-names = "in";
-			dma-maxburst = <2>;
-			status = "disabled";
-		};
+				sai1b: audio-controller@4400a024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI1_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 88 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-		rng1: rng@54003000 {
-			compatible = "st,stm32-rng";
-			reg = <0x54003000 0x400>;
-			clocks = <&rcc RNG1_K>;
-			resets = <&rcc RNG1_R>;
-			status = "disabled";
-		};
+			sai2: sai@4400b000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400b000 0x400>;
+				reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI2_ID>;
+				status = "disabled";
+
+				sai2a: audio-controller@4400b004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					clocks = <&rcc SAI2_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 89 0x400 0x01>;
+					status = "disabled";
+				};
 
-		mdma1: dma-controller@58000000 {
-			compatible = "st,stm32h7-mdma";
-			reg = <0x58000000 0x1000>;
-			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc MDMA>;
-			resets = <&rcc MDMA_R>;
-			#dma-cells = <5>;
-			dma-channels = <32>;
-			dma-requests = <48>;
-		};
+				sai2b: audio-controller@4400b024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI2_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 90 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-		fmc: memory-controller@58002000 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp1-fmc2-ebi";
-			reg = <0x58002000 0x1000>;
-			clocks = <&rcc FMC_K>;
-			resets = <&rcc FMC_R>;
-			status = "disabled";
+			sai3: sai@4400c000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400c000 0x400>;
+				reg = <0x4400c000 0x4>, <0x4400c3f0 0x10>;
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI3_ID>;
+				status = "disabled";
+
+				sai3a: audio-controller@4400c004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x04 0x20>;
+					clocks = <&rcc SAI3_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 113 0x400 0x01>;
+					status = "disabled";
+				};
 
-			ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
-				 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
-				 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
-				 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
-				 <4 0 0x80000000 0x10000000>; /* NAND */
+				sai3b: audio-controller@4400c024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI3_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 114 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-			nand-controller@4,0 {
+			dfsdm: dfsdm@4400d000 {
+				compatible = "st,stm32mp1-dfsdm";
+				reg = <0x4400d000 0x800>;
+				clocks = <&rcc DFSDM_K>;
+				clock-names = "dfsdm";
 				#address-cells = <1>;
 				#size-cells = <0>;
-				compatible = "st,stm32mp1-fmc2-nfc";
-				reg = <4 0x00000000 0x1000>,
-				      <4 0x08010000 0x1000>,
-				      <4 0x08020000 0x1000>,
-				      <4 0x01000000 0x1000>,
-				      <4 0x09010000 0x1000>,
-				      <4 0x09020000 0x1000>;
-				interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
-				       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
-				       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
-				dma-names = "tx", "rx", "ecc";
+				feature-domains = <&etzpc STM32MP1_ETZPC_DFSDM_ID>;
 				status = "disabled";
-			};
-		};
 
-		qspi: spi@58003000 {
-			compatible = "st,stm32f469-qspi";
-			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
-			reg-names = "qspi", "qspi_mm";
-			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
-			       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
-			dma-names = "tx", "rx";
-			clocks = <&rcc QSPI_K>;
-			resets = <&rcc QSPI_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
+				dfsdm0: filter@0 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <0>;
+					interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 101 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-		sdmmc1: mmc@58005000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x58005000 0x1000>;
-			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC1_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC1_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
+				dfsdm1: filter@1 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <1>;
+					interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 102 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-		sdmmc2: mmc@58007000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x58007000 0x1000>;
-			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC2_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC2_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
+				dfsdm2: filter@2 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <2>;
+					interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 103 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-		crc1: crc@58009000 {
-			compatible = "st,stm32f7-crc";
-			reg = <0x58009000 0x400>;
-			clocks = <&rcc CRC1>;
-			status = "disabled";
-		};
+				dfsdm3: filter@3 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <3>;
+					interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 104 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-		ethernet0: ethernet@5800a000 {
-			compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
-			reg = <0x5800a000 0x2000>;
-			reg-names = "stmmaceth";
-			interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "macirq";
-			clock-names = "stmmaceth",
-				      "mac-clk-tx",
-				      "mac-clk-rx",
-				      "eth-ck",
-				      "ptp_ref",
-				      "ethstp";
-			clocks = <&rcc ETHMAC>,
-				 <&rcc ETHTX>,
-				 <&rcc ETHRX>,
-				 <&rcc ETHCK_K>,
-				 <&rcc ETHPTP_K>,
-				 <&rcc ETHSTP>;
-			st,syscon = <&syscfg 0x4>;
-			snps,mixed-burst;
-			snps,pbl = <2>;
-			snps,en-tx-lpi-clockgating;
-			snps,axi-config = <&stmmac_axi_config_0>;
-			snps,tso;
-			status = "disabled";
+				dfsdm4: filter@4 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <4>;
+					interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 91 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			stmmac_axi_config_0: stmmac-axi-config {
-				snps,wr_osr_lmt = <0x7>;
-				snps,rd_osr_lmt = <0x7>;
-				snps,blen = <0 0 0 0 16 8 4>;
+				dfsdm5: filter@5 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <5>;
+					interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 92 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 			};
-		};
 
-		usbh_ohci: usb@5800c000 {
-			compatible = "generic-ohci";
-			reg = <0x5800c000 0x1000>;
-			clocks = <&usbphyc>, <&rcc USBH>;
-			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
-			status = "disabled";
-		};
-
-		usbh_ehci: usb@5800d000 {
-			compatible = "generic-ehci";
-			reg = <0x5800d000 0x1000>;
-			clocks = <&usbphyc>, <&rcc USBH>;
-			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
-			companion = <&usbh_ohci>;
-			status = "disabled";
-		};
-
-		ltdc: display-controller@5a001000 {
-			compatible = "st,stm32-ltdc";
-			reg = <0x5a001000 0x400>;
-			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LTDC_PX>;
-			clock-names = "lcd";
-			resets = <&rcc LTDC_R>;
-			status = "disabled";
-
-			port {
+			dma1: dma-controller@48000000 {
+				compatible = "st,stm32-dma";
+				reg = <0x48000000 0x400>;
+				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc DMA1>;
+				resets = <&rcc DMA1_R>;
+				#dma-cells = <4>;
+				st,mem2mem;
+				dma-requests = <8>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DMA1_ID>;
+			};
+
+			dma2: dma-controller@48001000 {
+				compatible = "st,stm32-dma";
+				reg = <0x48001000 0x400>;
+				interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc DMA2>;
+				resets = <&rcc DMA2_R>;
+				#dma-cells = <4>;
+				st,mem2mem;
+				dma-requests = <8>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DMA2_ID>;
+			};
+
+			dmamux1: dma-router@48002000 {
+				compatible = "st,stm32h7-dmamux";
+				reg = <0x48002000 0x40>;
+				#dma-cells = <3>;
+				dma-requests = <128>;
+				dma-masters = <&dma1 &dma2>;
+				dma-channels = <16>;
+				clocks = <&rcc DMAMUX>;
+				resets = <&rcc DMAMUX_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DMAMUX_ID>;
+			};
+
+			adc: adc@48003000 {
+				compatible = "st,stm32mp1-adc-core";
+				reg = <0x48003000 0x400>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				st,syscfg = <&syscfg>;
+				#interrupt-cells = <1>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ADC_ID>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp1-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc>;
+					interrupts = <0>;
+					dmas = <&dmamux1 9 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				adc2: adc@100 {
+					compatible = "st,stm32mp1-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x100>;
+					interrupt-parent = <&adc>;
+					interrupts = <1>;
+					dmas = <&dmamux1 10 0x400 0x01>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@13 {
+						reg = <13>;
+						label = "vrefint";
+					};
+					channel@14 {
+						reg = <14>;
+						label = "vddcore";
+					};
+				};
 			};
-		};
 
-		iwdg2: watchdog@5a002000 {
-			compatible = "st,stm32mp1-iwdg";
-			reg = <0x5a002000 0x400>;
-			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
-			clock-names = "pclk", "lsi";
-			status = "disabled";
-		};
+			sdmmc3: mmc@48004000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00253180>;
+				reg = <0x48004000 0x400>;
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC3_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				status = "disabled";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SDMMC3_ID>;
+			};
+
+			usbotg_hs: usb-otg@49000000 {
+				compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+				reg = <0x49000000 0x10000>;
+				clocks = <&rcc USBO_K>, <&usbphyc>;
+				clock-names = "otg", "utmi";
+				resets = <&rcc USBO_R>;
+				reset-names = "dwc2";
+				interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+				g-rx-fifo-size = <512>;
+				g-np-tx-fifo-size = <32>;
+				g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				usb33d-supply = <&usb33>;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_OTG_ID>;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@4c006000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x4c006000 0x400>;
+				interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CAMITF_R>;
+				clocks = <&rcc DCMI>;
+				clock-names = "mclk";
+				dmas = <&dmamux1 75 0x400 0x01>;
+				dma-names = "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_DCMI_ID>;
+				status = "disabled";
+			};
+
+			lptimer2: timer@50021000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50021000 0x400>;
+				interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM2_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM2_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		usbphyc: usbphyc@5a006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			#clock-cells = <0>;
-			compatible = "st,stm32mp1-usbphyc";
-			reg = <0x5a006000 0x1000>;
-			clocks = <&rcc USBPHY_K>;
-			resets = <&rcc USBPHY_R>;
-			vdda1v1-supply = <&reg11>;
-			vdda1v8-supply = <&reg18>;
-			status = "disabled";
+				trigger@1 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
 
-			usbphyc_port0: usb-phy@0 {
-				#phy-cells = <0>;
-				reg = <0>;
-			};
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
 
-			usbphyc_port1: usb-phy@1 {
-				#phy-cells = <1>;
-				reg = <1>;
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
-		};
-
-		usart1: serial@5c000000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x5c000000 0x400>;
-			interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART1_K>;
-			wakeup-source;
-			status = "disabled";
-		};
-
-		spi6: spi@5c001000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x5c001000 0x400>;
-			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI6_K>;
-			resets = <&rcc SPI6_R>;
-			dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
-			       <&mdma1 35 0x0 0x40002 0x0 0x0>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
 
-		i2c4: i2c@5c002000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x5c002000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C4_K>;
-			resets = <&rcc I2C4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x8>;
-			wakeup-source;
-			i2c-analog-filter;
-			status = "disabled";
-		};
+			lptimer3: timer@50022000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50022000 0x400>;
+				interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM3_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM3_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		rtc: rtc@5c004000 {
-			compatible = "st,stm32mp1-rtc";
-			reg = <0x5c004000 0x400>;
-			clocks = <&rcc RTCAPB>, <&rcc RTC>;
-			clock-names = "pclk", "rtc_ck";
-			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
-			status = "disabled";
-		};
+				trigger@2 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
 
-		bsec: efuse@5c005000 {
-			compatible = "st,stm32mp15-bsec";
-			reg = <0x5c005000 0x400>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ts_cal1: calib@5c {
-				reg = <0x5c 0x2>;
-			};
-			ts_cal2: calib@5e {
-				reg = <0x5e 0x2>;
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
-		};
 
-		i2c6: i2c@5c009000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x5c009000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C6_K>;
-			resets = <&rcc I2C6_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x20>;
-			wakeup-source;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
-		tamp: tamp@5c00a000 {
-			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
-			reg = <0x5c00a000 0x400>;
-		};
+			lptimer4: timer@50023000 {
+				compatible = "st,stm32-lptimer";
+				reg = <0x50023000 0x400>;
+				interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM4_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM4_ID>;
+				status = "disabled";
 
-		/*
-		 * Break node order to solve dependency probe issue between
-		 * pinctrl and exti.
-		 */
-		pinctrl: pinctrl@50002000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp157-pinctrl";
-			ranges = <0 0x50002000 0xa400>;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
-			pins-are-numbered;
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			gpioa: gpio@50002000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x0 0x400>;
-				clocks = <&rcc GPIOA>;
-				st,bank-name = "GPIOA";
-				status = "disabled";
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			gpiob: gpio@50003000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x1000 0x400>;
-				clocks = <&rcc GPIOB>;
-				st,bank-name = "GPIOB";
+			lptimer5: timer@50024000 {
+				compatible = "st,stm32-lptimer";
+				reg = <0x50024000 0x400>;
+				interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM5_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM5_ID>;
 				status = "disabled";
-			};
 
-			gpioc: gpio@50004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x2000 0x400>;
-				clocks = <&rcc GPIOC>;
-				st,bank-name = "GPIOC";
-				status = "disabled";
-			};
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			gpiod: gpio@50005000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x3000 0x400>;
-				clocks = <&rcc GPIOD>;
-				st,bank-name = "GPIOD";
-				status = "disabled";
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			gpioe: gpio@50006000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x4000 0x400>;
-				clocks = <&rcc GPIOE>;
-				st,bank-name = "GPIOE";
+			vrefbuf: vrefbuf@50025000 {
+				compatible = "st,stm32-vrefbuf";
+				reg = <0x50025000 0x8>;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <2500000>;
+				clocks = <&rcc VREF>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_VREFBUF_ID>;
 				status = "disabled";
 			};
 
-			gpiof: gpio@50007000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x5000 0x400>;
-				clocks = <&rcc GPIOF>;
-				st,bank-name = "GPIOF";
-				status = "disabled";
-			};
+			sai4: sai@50027000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x50027000 0x400>;
+				reg = <0x50027000 0x4>, <0x500273f0 0x10>;
+				interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI4_ID>;
+				status = "disabled";
+
+				sai4a: audio-controller@50027004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x04 0x20>;
+					clocks = <&rcc SAI4_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 99 0x400 0x01>;
+					status = "disabled";
+				};
 
-			gpiog: gpio@50008000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x6000 0x400>;
-				clocks = <&rcc GPIOG>;
-				st,bank-name = "GPIOG";
-				status = "disabled";
+				sai4b: audio-controller@50027024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI4_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 100 0x400 0x01>;
+					status = "disabled";
+				};
 			};
 
-			gpioh: gpio@50009000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x7000 0x400>;
-				clocks = <&rcc GPIOH>;
-				st,bank-name = "GPIOH";
-				status = "disabled";
+			hash1: hash@54002000 {
+				compatible = "st,stm32f756-hash";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&mdma1 31 0x2 0x1000a02 0x0 0x0>;
+				dma-names = "in";
+				dma-maxburst = <2>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_HASH1_ID>;
+				status = "disabled";
+			};
+
+			rng1: rng@54003000 {
+				compatible = "st,stm32-rng";
+				reg = <0x54003000 0x400>;
+				clocks = <&rcc RNG1_K>;
+				resets = <&rcc RNG1_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_RNG1_ID>;
+				status = "disabled";
+			};
+
+			fmc: memory-controller@58002000 {
+				#address-cells = <2>;
+				#size-cells = <1>;
+				compatible = "st,stm32mp1-fmc2-ebi";
+				reg = <0x58002000 0x1000>;
+				clocks = <&rcc FMC_K>;
+				resets = <&rcc FMC_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_FMC_ID>;
+				status = "disabled";
+
+				ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+					 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+					 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+					 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+					 <4 0 0x80000000 0x10000000>; /* NAND */
+
+				nand-controller@4,0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "st,stm32mp1-fmc2-nfc";
+					reg = <4 0x00000000 0x1000>,
+					      <4 0x08010000 0x1000>,
+					      <4 0x08020000 0x1000>,
+					      <4 0x01000000 0x1000>,
+					      <4 0x09010000 0x1000>,
+					      <4 0x09020000 0x1000>;
+					interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
+					       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
+					       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
+					dma-names = "tx", "rx", "ecc";
+					status = "disabled";
+				};
 			};
 
-			gpioi: gpio@5000a000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x8000 0x400>;
-				clocks = <&rcc GPIOI>;
-				st,bank-name = "GPIOI";
-				status = "disabled";
+			qspi: spi@58003000 {
+				compatible = "st,stm32f469-qspi";
+				reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+				reg-names = "qspi", "qspi_mm";
+				interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
+				       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
+				dma-names = "tx", "rx";
+				clocks = <&rcc QSPI_K>;
+				resets = <&rcc QSPI_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_QSPI_ID>;
+				status = "disabled";
+			};
+
+			ethernet0: ethernet@5800a000 {
+				compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
+				reg = <0x5800a000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti 70 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "eth-ck",
+					      "ptp_ref",
+					      "ethstp";
+				clocks = <&rcc ETHMAC>,
+					 <&rcc ETHTX>,
+					 <&rcc ETHRX>,
+					 <&rcc ETHCK_K>,
+					 <&rcc ETHPTP_K>,
+					 <&rcc ETHSTP>;
+				st,syscon = <&syscfg 0x4>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,en-tx-lpi-clockgating;
+				snps,axi-config = <&stmmac_axi_config_0>;
+				snps,tso;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ETH_ID>;
+				status = "disabled";
+				power-domains = <&pd_core>;
+
+				stmmac_axi_config_0: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
 			};
 
-			gpioj: gpio@5000b000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x9000 0x400>;
-				clocks = <&rcc GPIOJ>;
-				st,bank-name = "GPIOJ";
+			usart1: serial@5c000000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x5c000000 0x400>;
+				interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART1_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART1_ID>;
 				status = "disabled";
 			};
 
-			gpiok: gpio@5000c000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0xa000 0x400>;
-				clocks = <&rcc GPIOK>;
-				st,bank-name = "GPIOK";
+			spi6: spi@5c001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x5c001000 0x400>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI6_K>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 35 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI6_ID>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@5c002000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x5c002000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C4_K>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&mdma1 36 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 37 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x8>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C4_ID>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@5c009000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x5c009000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C6_K>;
+				resets = <&rcc I2C6_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&mdma1 38 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 39 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x20>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C6_ID>;
 				status = "disabled";
 			};
 		};
 
-		pinctrl_z: pinctrl@54004000 {
+		tamp: tamp@5c00a000 {
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
 			#address-cells = <1>;
 			#size-cells = <1>;
-			compatible = "st,stm32mp157-z-pinctrl";
-			ranges = <0 0x54004000 0x400>;
-			pins-are-numbered;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
+			reg = <0x5c00a000 0x400>;
+			ranges;
 
-			gpioz: gpio@54004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0 0x400>;
-				clocks = <&rcc GPIOZ>;
-				st,bank-name = "GPIOZ";
-				st,bank-ioport = <11>;
-				status = "disabled";
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x5c00a100 0x80>;
+
+				wakeup_sec: tamp-bkp@0 {
+					reg = <0x0 0x4>;
+				};
+
+				m4_security_perimeter_exti1: tamp-bkp@4 {
+					/* see cortex-m4 wake up feature */
+					reg = <0x4 0x4>;
+				};
+
+				m4_security_perimeter_exti2: tamp-bkp@8 {
+					/* see cortex-m4 wake up feature */
+					reg = <0x8 0x4>;
+				};
+
+				m4_security_perimeter_exti3: tamp-bkp@c {
+					/* see cortex-m4 wtake up feature */
+					reg = <0xc 0x4>;
+				};
+
+				magic_number: tamp-bkp@10 {
+					/* see ddr and cpu wake up management feature */
+					reg = <0x10 0x4>;
+				};
+
+				branch_address: tamp-bkp@14 {
+					/* see ddr and cpu wake up management feature */
+					reg = <0x14 0x4>;
+				};
+
+				fwu_info: tamp-bkp@28 {
+					/* see firmware update info feature */
+					reg = <0x28 0x4>;
+				};
+
+				copro_rsc_tbl_address: tamp-bkp@44 {
+					/* see cortex-m4 management feature */
+					reg = <0x44 0x4>;
+				};
+
+				cortex_m_state: tamp-bkp@48 {
+					/* see cortex-m4 management feature */
+					reg = <0x48 0x4>;
+				};
+
+				boot_mode: tamp-bkp@50 {
+					/* see boot mode selection feature */
+					reg = <0x50 0x4>;
+				};
+
+				boot_counter: tamp-bkp@54 {
+					/* see boot counter feature */
+					reg = <0x54 0x4>;
+				};
+
+				m4_wakeup_area_start: tamp-bkp@58 {
+					/* see cortex-m4 wake up feature */
+					reg = <0x58 0x4>;
+				};
+
+				m4_wakeup_area_length: tamp-bkp@5c {
+					/* see cortex-m4 wake up feature */
+					reg = <0x5c 0x4>;
+				};
+
+				m4_wakeup_area_hash: tamp-bkp@60 {
+					/* SHA-0x100 value see Cortex-M4 wake up feature */
+					reg = <0x60 0x20>;
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
 			};
 		};
 	};
@@ -1825,12 +2291,16 @@ m4_rproc: m4@10000000 {
 			      <0x30000000 0x40000>,
 			      <0x38000000 0x10000>;
 			resets = <&rcc MCU_R>;
-			st,syscfg-holdboot = <&rcc 0x10C 0x1>;
-			st,syscfg-tz = <&rcc 0x000 0x1>;
+			st,syscfg-holdboot = <&rcc 0x10c 0x1>;
 			st,syscfg-pdds = <&pwr_mcu 0x0 0x1>;
-			st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
-			st,syscfg-m4-state = <&tamp 0x148 0xFFFFFFFF>;
+			st,syscfg-rsc-tbl = <&tamp 0x144 0xffffffff>;
+			st,syscfg-cm-state = <&tamp 0x148 0xffffffff>;
 			status = "disabled";
+
+			m4_system_resources {
+				compatible = "rproc-srm-core";
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp153.dtsi b/arch/arm/boot/dts/stm32mp153.dtsi
index 486084e0b..e7faba5b0 100644
--- a/arch/arm/boot/dts/stm32mp153.dtsi
+++ b/arch/arm/boot/dts/stm32mp153.dtsi
@@ -10,9 +10,10 @@ / {
 	cpus {
 		cpu1: cpu@1 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <1>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
 		};
 	};
 
@@ -30,30 +31,34 @@ timer {
 	};
 
 	soc {
-		m_can1: can@4400e000 {
-			compatible = "bosch,m_can";
-			reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
-			reg-names = "m_can", "message_ram";
-			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
-			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
-			status = "disabled";
-		};
+		etzpc: etzpc@5c007000 {
+			m_can1: can@4400e000 {
+				compatible = "bosch,m_can";
+				reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_TT_FDCAN_ID>;
+				status = "disabled";
+			};
 
-		m_can2: can@4400f000 {
-			compatible = "bosch,m_can";
-			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
-			reg-names = "m_can", "message_ram";
-			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
-			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
-			status = "disabled";
+			m_can2: can@4400f000 {
+				compatible = "bosch,m_can";
+				reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_TT_FDCAN_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp157.dtsi b/arch/arm/boot/dts/stm32mp157.dtsi
index 54e73ccea..3756ee7ee 100644
--- a/arch/arm/boot/dts/stm32mp157.dtsi
+++ b/arch/arm/boot/dts/stm32mp157.dtsi
@@ -20,18 +20,12 @@ gpu: gpu@59000000 {
 		dsi: dsi@5a000000 {
 			compatible = "st,stm32-dsi";
 			reg = <0x5a000000 0x800>;
-			clocks = <&rcc DSI_K>, <&clk_hse>, <&rcc DSI_PX>;
+			phy-dsi-supply = <&reg18>;
+			clocks = <&rcc DSI>, <&clk_hse>, <&rcc DSI_PX>;
 			clock-names = "pclk", "ref", "px_clk";
 			resets = <&rcc DSI_R>;
 			reset-names = "apb";
-			#address-cells = <1>;
-			#size-cells = <0>;
 			status = "disabled";
-
-			ports {
-				#address-cells = <1>;
-				#size-cells = <0>;
-			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts
new file mode 100644
index 000000000..6ae06baab
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-dk1-a7-examples.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157a-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157A-DK1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157a-dk1-a7-examples", "st,stm32mp157a-dk1", "st,stm32mp157";
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts
new file mode 100644
index 000000000..4bd40eba1
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-dk1-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157a-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157A-DK1 configured to run M4 examples";
+	compatible = "st,stm32mp157a-dk1-m4-examples", "st,stm32mp157a-dk1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1-scmi.dts b/arch/arm/boot/dts/stm32mp157a-dk1-scmi.dtsi
similarity index 79%
rename from arch/arm/boot/dts/stm32mp157a-dk1-scmi.dts
rename to arch/arm/boot/dts/stm32mp157a-dk1-scmi.dtsi
index 942a6ca38..34fcf8c15 100644
--- a/arch/arm/boot/dts/stm32mp157a-dk1-scmi.dts
+++ b/arch/arm/boot/dts/stm32mp157a-dk1-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157a-dk1.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157A-DK1 SCMI Discovery Board";
-	compatible = "st,stm32mp157a-dk1-scmi", "st,stm32mp157";
-
 	reserved-memory {
 		optee@de000000 {
 			reg = <0xde000000 0x2000000>;
@@ -30,7 +24,7 @@ &cpu1 {
 };
 
 &dsi {
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -47,10 +41,22 @@ &i2c4 {
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
diff --git a/arch/arm/boot/dts/stm32mp157a-dk1.dts b/arch/arm/boot/dts/stm32mp157a-dk1.dts
index 4c8be9c8e..e262d22d4 100644
--- a/arch/arm/boot/dts/stm32mp157a-dk1.dts
+++ b/arch/arm/boot/dts/stm32mp157a-dk1.dts
@@ -7,9 +7,11 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157a-dk1-scmi.dtsi"
 
 / {
 	model = "STMicroelectronics STM32MP157A-DK1 Discovery Board";
@@ -17,9 +19,6 @@ / {
 
 	aliases {
 		ethernet0 = &ethernet0;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &uart7;
 	};
 
 	chosen {
diff --git a/arch/arm/boot/dts/stm32mp157a-ed1-scmi.dtsi b/arch/arm/boot/dts/stm32mp157a-ed1-scmi.dtsi
new file mode 100644
index 000000000..c36fa23ff
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ed1-scmi.dtsi
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15-scmi.dtsi"
+
+/ {
+	reserved-memory {
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-ed1.dts b/arch/arm/boot/dts/stm32mp157a-ed1.dts
new file mode 100644
index 000000000..578ca4064
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ed1.dts
@@ -0,0 +1,433 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157a-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter";
+	compatible = "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-ev1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157a-ev1-a7-examples.dts
new file mode 100644
index 000000000..f6b28d373
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ev1-a7-examples.dts
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157a-ev1.dts"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A-EV1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157a-ev1-a7-examples", "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	test_keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		status = "okay";
+		/* gpio needs vdd core in retention for wakeup */
+		power-domains = <&pd_core_ret>;
+
+		button-1 {
+				label = "PA13";
+				linux,code = <BTN_1>;
+				gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+				status = "okay";
+				wakeup-source;
+		};
+	};
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-ev1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157a-ev1-m4-examples.dts
new file mode 100644
index 000000000..760ca55c2
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ev1-m4-examples.dts
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157a-ev1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157A-EV1 configured to run M4 examples";
+	compatible = "st,stm32mp157a-ev1-m4-examples", "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-ev1-scmi.dtsi b/arch/arm/boot/dts/stm32mp157a-ev1-scmi.dtsi
new file mode 100644
index 000000000..0c79a2b3e
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ev1-scmi.dtsi
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	reserved-memory {
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&m_can1 {
+	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-ev1.dts b/arch/arm/boot/dts/stm32mp157a-ev1.dts
new file mode 100644
index 000000000..c17d288ec
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157a-ev1.dts
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157a-ed1.dts"
+#include "stm32mp157a-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter on eval mother";
+	compatible = "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-ctouch2-of10.dts b/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-ctouch2-of10.dts
index 9a2a4bc7d..e64f162ae 100644
--- a/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-ctouch2-of10.dts
+++ b/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-ctouch2-of10.dts
@@ -46,9 +46,11 @@ panel_in_lvds: endpoint {
 
 &dsi {
 	status = "okay";
-	phy-dsi-supply = <&reg18>;
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in: endpoint {
@@ -104,8 +106,7 @@ &ltdc {
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&dsi_in>;
 		};
 	};
diff --git a/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-edimm2.2.dts b/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-edimm2.2.dts
index 390ee8c05..5f25ab3bf 100644
--- a/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-edimm2.2.dts
+++ b/arch/arm/boot/dts/stm32mp157a-icore-stm32mp1-edimm2.2.dts
@@ -46,9 +46,11 @@ panel_out_bridge: endpoint {
 
 &dsi {
 	status = "okay";
-	phy-dsi-supply = <&reg18>;
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in_ltdc: endpoint {
@@ -104,8 +106,7 @@ &ltdc {
 	status = "okay";
 
 	port {
-		ltdc_out_dsi: endpoint@0 {
-			reg = <0>;
+		ltdc_out_dsi: endpoint {
 			remote-endpoint = <&dsi_in_ltdc>;
 		};
 	};
diff --git a/arch/arm/boot/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts b/arch/arm/boot/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
index 0d7560ba2..5116a7785 100644
--- a/arch/arm/boot/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
+++ b/arch/arm/boot/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
@@ -81,8 +81,7 @@ &ltdc {
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&panel_in>;
 		};
 	};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts b/arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts
new file mode 100644
index 000000000..533ed4efe
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-dk2-a7-examples.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157C-DK2 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157c-dk2-a7-examples", "st,stm32mp157c-dk2", "st,stm32mp157";
+};
+
+&adc {
+	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+
+	adc1: adc@0 {
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@13 {
+			reg = <13>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+
+	adc2: adc@100 {
+		/* Set IRQ mode as example. DMA is the preferred mode, yet. */
+		/delete-property/dmas;
+		/delete-property/dma-names;
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&timers1 {
+	status = "okay";
+};
+
+&timers3 {
+	status = "okay";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers5 {
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts b/arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts
new file mode 100644
index 000000000..1fbd2b8c4
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-dk2-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157C-DK2 configured to run M4 examples";
+	compatible = "st,stm32mp157c-dk2-m4-examples", "st,stm32mp157c-dk2", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2-scmi.dts b/arch/arm/boot/dts/stm32mp157c-dk2-scmi.dtsi
similarity index 78%
rename from arch/arm/boot/dts/stm32mp157c-dk2-scmi.dts
rename to arch/arm/boot/dts/stm32mp157c-dk2-scmi.dtsi
index 99c4ff1f5..0b8bba427 100644
--- a/arch/arm/boot/dts/stm32mp157c-dk2-scmi.dts
+++ b/arch/arm/boot/dts/stm32mp157c-dk2-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-dk2.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157C-DK2 SCMI Discovery Board";
-	compatible = "st,stm32mp157c-dk2-scmi", "st,stm32mp157";
-
 	reserved-memory {
 		optee@de000000 {
 			reg = <0xde000000 0x2000000>;
@@ -35,8 +29,7 @@ &cryp1 {
 };
 
 &dsi {
-	phy-dsi-supply = <&scmi_reg18>;
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -53,10 +46,22 @@ &i2c4 {
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
@@ -83,3 +88,7 @@ &rng1 {
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-dk2.dts b/arch/arm/boot/dts/stm32mp157c-dk2.dts
index 2bc92ef3a..e4fe9a754 100644
--- a/arch/arm/boot/dts/stm32mp157c-dk2.dts
+++ b/arch/arm/boot/dts/stm32mp157c-dk2.dts
@@ -11,6 +11,8 @@
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157c-dk2-scmi.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C-DK2 Discovery Board";
@@ -18,14 +20,25 @@ / {
 
 	aliases {
 		ethernet0 = &ethernet0;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &uart7;
 		serial3 = &usart2;
 	};
 
 	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
 		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
 	};
 };
 
@@ -34,10 +47,14 @@ &cryp1 {
 };
 
 &dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
 	status = "okay";
-	phy-dsi-supply = <&reg18>;
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in: endpoint {
@@ -53,7 +70,7 @@ dsi_out: endpoint {
 		};
 	};
 
-	panel@0 {
+	panel_otm8009a: panel-otm8009a@0 {
 		compatible = "orisetech,otm8009a";
 		reg = <0>;
 		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
@@ -77,14 +94,21 @@ touchscreen@38 {
 		interrupt-controller;
 		touchscreen-size-x = <480>;
 		touchscreen-size-y = <800>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		panel = <&panel_otm8009a>;
 		status = "okay";
 	};
 };
 
 &ltdc {
+	default-on;
 	status = "okay";
 
 	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		ltdc_ep1_out: endpoint@1 {
 			reg = <1>;
 			remote-endpoint = <&dsi_in>;
@@ -92,10 +116,48 @@ ltdc_ep1_out: endpoint@1 {
 	};
 };
 
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	cap-sdio-irq;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+/* Bluetooth */
 &usart2 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart2_pins_c>;
 	pinctrl-1 = <&usart2_sleep_pins_c>;
 	pinctrl-2 = <&usart2_idle_pins_c>;
-	status = "disabled";
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
 };
diff --git a/arch/arm/boot/dts/stm32mp157c-ed1-scmi.dts b/arch/arm/boot/dts/stm32mp157c-ed1-scmi.dtsi
similarity index 74%
rename from arch/arm/boot/dts/stm32mp157c-ed1-scmi.dts
rename to arch/arm/boot/dts/stm32mp157c-ed1-scmi.dtsi
index 21010458b..a26929e69 100644
--- a/arch/arm/boot/dts/stm32mp157c-ed1-scmi.dts
+++ b/arch/arm/boot/dts/stm32mp157c-ed1-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-ed1.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157C-ED1 SCMI eval daughter";
-	compatible = "st,stm32mp157c-ed1-scmi", "st,stm32mp157";
-
 	reserved-memory {
 		optee@fe000000 {
 			reg = <0xfe000000 0x2000000>;
@@ -35,7 +29,7 @@ &cryp1 {
 };
 
 &dsi {
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -52,10 +46,22 @@ &i2c4 {
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
@@ -82,3 +88,12 @@ &rng1 {
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-ed1.dts b/arch/arm/boot/dts/stm32mp157c-ed1.dts
index b1eb688a2..849227aa4 100644
--- a/arch/arm/boot/dts/stm32mp157c-ed1.dts
+++ b/arch/arm/boot/dts/stm32mp157c-ed1.dts
@@ -9,6 +9,9 @@
 #include "stm32mp15xc.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157c-ed1-scmi.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
 
@@ -16,13 +19,17 @@ / {
 	model = "STMicroelectronics STM32MP157C eval daughter";
 	compatible = "st,stm32mp157c-ed1", "st,stm32mp157";
 
+	aliases {
+		serial0 = &uart4;
+	};
+
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
 
 	memory@c0000000 {
 		device_type = "memory";
-		reg = <0xC0000000 0x40000000>;
+		reg = <0xc0000000 0x40000000>;
 	};
 
 	reserved-memory {
@@ -54,6 +61,12 @@ vdev0buffer: vdev0buffer@10042000 {
 			no-map;
 		};
 
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -70,13 +83,28 @@ gpu_reserved: gpu@e8000000 {
 			reg = <0xe8000000 0x8000000>;
 			no-map;
 		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
 	};
 
-	aliases {
-		serial0 = &uart4;
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
 	};
 
-	sd_switch: regulator-sd_switch {
+	sd_switch: regulator-sd-switch {
 		compatible = "regulator-gpio";
 		regulator-name = "sd_switch";
 		regulator-min-microvolt = <1800000>;
@@ -108,13 +136,36 @@ &adc {
 	vref-supply = <&vdda>;
 	status = "disabled";
 	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		/* 16.5 ck_cycles sampling time */
-		st,min-sample-time-nsecs = <400>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
 	};
 };
 
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
 &crc1 {
 	status = "okay";
 };
@@ -163,7 +214,7 @@ &i2c4 {
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -264,7 +315,7 @@ v1v8: ldo6 {
 				interrupts = <IT_CURLIM_LDO6 0>;
 			};
 
-			vref_ddr: vref_ddr {
+			vref_ddr: vref-ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 			};
@@ -274,16 +325,16 @@ bst_out: boost {
 				interrupts = <IT_OCP_BOOST 0>;
 			};
 
-			vbus_otg: pwr_sw1 {
+			vbus_otg: pwr-sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr-sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
-			 };
+			};
 		};
 
 		onkey {
@@ -305,18 +356,14 @@ &ipcc {
 	status = "okay";
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -325,10 +372,6 @@ &pwr_regulators {
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts
new file mode 100644
index 000000000..7d05d6e91
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-ev1-a7-examples.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-ev1.dts"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157C-EV1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157c-ev1-a7-examples", "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
+
+	test_keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		status = "okay";
+		/* gpio needs vdd core in retention for wakeup */
+		power-domains = <&pd_core_ret>;
+
+		button-1 {
+			label = "PA13";
+			linux,code = <BTN_1>;
+			gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+			status = "okay";
+			wakeup-source;
+		};
+	};
+};
+
+&adc {
+	status = "okay";
+};
+
+&dac {
+	status = "okay";
+};
+
+&timers2 {
+	status = "okay";
+};
+
+&timers8 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts
new file mode 100644
index 000000000..2266a3ce5
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157c-ev1-m4-examples.dts
@@ -0,0 +1,150 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157c-ev1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157C-EV1 configured to run M4 examples";
+	compatible = "st,stm32mp157c-ev1-m4-examples", "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dcmi {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&fmc {
+	status = "disabled";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&m4_adc {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_qspi_clk_pins_a &m4_qspi_bk1_pins_a
+		     &m4_qspi_bk2_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+	/*	button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+	*/
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm2_pins_a>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 8, RSVD)>;
+		};
+	};
+};
+
+&qspi {
+	status = "disabled";
+};
+
+&sai2b {
+	status = "disabled";
+};
+
+&sound {
+	status = "disabled";
+};
+
+&timers2 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1-scmi.dts b/arch/arm/boot/dts/stm32mp157c-ev1-scmi.dtsi
similarity index 78%
rename from arch/arm/boot/dts/stm32mp157c-ev1-scmi.dts
rename to arch/arm/boot/dts/stm32mp157c-ev1-scmi.dtsi
index d37637149..b682649eb 100644
--- a/arch/arm/boot/dts/stm32mp157c-ev1-scmi.dts
+++ b/arch/arm/boot/dts/stm32mp157c-ev1-scmi.dtsi
@@ -4,15 +4,7 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-ev1.dts"
-#include "stm32mp15-scmi.dtsi"
-
 / {
-	model = "STMicroelectronics STM32MP157C-EV1 SCMI eval daughter on eval mother";
-	compatible = "st,stm32mp157c-ev1-scmi", "st,stm32mp157c-ed1", "st,stm32mp157";
-
 	reserved-memory {
 		optee@fe000000 {
 			reg = <0xfe000000 0x2000000>;
@@ -35,8 +27,7 @@ &cryp1 {
 };
 
 &dsi {
-	phy-dsi-supply = <&scmi_reg18>;
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -53,10 +44,22 @@ &i2c4 {
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &m_can1 {
 	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 };
@@ -87,3 +90,7 @@ &rng1 {
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157c-ev1.dts b/arch/arm/boot/dts/stm32mp157c-ev1.dts
index b72d5e8aa..ac37098b9 100644
--- a/arch/arm/boot/dts/stm32mp157c-ev1.dts
+++ b/arch/arm/boot/dts/stm32mp157c-ev1.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "stm32mp157c-ed1.dts"
+#include "stm32mp157c-ev1-scmi.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 
@@ -13,16 +14,25 @@ / {
 	model = "STMicroelectronics STM32MP157C eval daughter on eval mother";
 	compatible = "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
 
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
-
 	aliases {
-		serial0 = &uart4;
 		serial1 = &usart3;
+		serial4 = &usart1;
 		ethernet0 = &ethernet0;
 	};
 
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
 	clocks {
 		clk_ext_camera: clk-ext-camera {
 			#clock-cells = <0>;
@@ -31,6 +41,54 @@ clk_ext_camera: clk-ext-camera {
 		};
 	};
 
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
 	joystick {
 		compatible = "gpio-keys";
 		pinctrl-0 = <&joystick_pins>;
@@ -71,8 +129,45 @@ panel_backlight: panel-backlight {
 		compatible = "gpio-backlight";
 		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
 		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
 		status = "okay";
 	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
 };
 
 &cec {
@@ -86,6 +181,14 @@ &dcmi {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&dcmi_pins_a>;
 	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
 
 	port {
 		dcmi_0: endpoint {
@@ -95,15 +198,128 @@ dcmi_0: endpoint {
 			hsync-active = <0>;
 			vsync-active = <0>;
 			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
 		};
 	};
 };
 
 &dsi {
-	phy-dsi-supply = <&reg18>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	default-on;
 	status = "okay";
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in: endpoint {
@@ -119,7 +335,7 @@ dsi_out: endpoint {
 		};
 	};
 
-	panel-dsi@0 {
+	panel_dsi: panel-dsi@0 {
 		compatible = "raydium,rm68200";
 		reg = <0>;
 		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
@@ -178,8 +394,52 @@ &i2c2 {
 	pinctrl-1 = <&i2c2_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
 	ov5640: camera@3c {
 		compatible = "ovti,ov5640";
 		reg = <0x3c>;
@@ -199,6 +459,7 @@ ov5640_0: endpoint {
 				hsync-active = <0>;
 				vsync-active = <0>;
 				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
 			};
 		};
 	};
@@ -218,12 +479,41 @@ stmfx_pinctrl: pinctrl {
 			#interrupt-cells = <2>;
 			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
 
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
 			joystick_pins: joystick-pins {
 				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
 				bias-pull-down;
 			};
 		};
 	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
 };
 
 &i2c5 {
@@ -232,15 +522,17 @@ &i2c5 {
 	pinctrl-1 = <&i2c5_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 };
 
 &ltdc {
+	default-on;
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&dsi_in>;
 		};
 	};
@@ -289,6 +581,65 @@ flash1: flash@1 {
 	};
 };
 
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
 &sdmmc3 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc3_b4_pins_a>;
@@ -301,17 +652,41 @@ &sdmmc3 {
 	status = "disabled";
 };
 
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
 &spi1 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
 	status = "disabled";
 };
 
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
 &timers2 {
 	/* spare dmas for other usage (un-delete to enable pwm capture) */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm2_pins_a>;
 		pinctrl-1 = <&pwm2_sleep_pins_a>;
@@ -327,6 +702,9 @@ &timers8 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm8_pins_a>;
 		pinctrl-1 = <&pwm8_sleep_pins_a>;
@@ -342,6 +720,9 @@ &timers12 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
 		pinctrl-1 = <&pwm12_sleep_pins_a>;
@@ -353,6 +734,16 @@ timer@11 {
 	};
 };
 
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
 &usart3 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart3_pins_b>;
@@ -370,6 +761,14 @@ &usart3 {
 &usbh_ehci {
 	phys = <&usbphyc_port0>;
 	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
 };
 
 &usbotg_hs {
@@ -393,6 +792,10 @@ &usbphyc_port0 {
 	st,tune-squelch-level = <3>;
 	st,tune-hs-rx-offset = <2>;
 	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
 };
 
 &usbphyc_port1 {
diff --git a/arch/arm/boot/dts/stm32mp157c-lxa-mc1.dts b/arch/arm/boot/dts/stm32mp157c-lxa-mc1.dts
index cb00ce7ce..273724367 100644
--- a/arch/arm/boot/dts/stm32mp157c-lxa-mc1.dts
+++ b/arch/arm/boot/dts/stm32mp157c-lxa-mc1.dts
@@ -161,8 +161,7 @@ &ltdc {
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&panel_input>;
 		};
 	};
diff --git a/arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts
new file mode 100644
index 000000000..c5cf176c3
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-dk1-a7-examples.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157d-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157d-dk1-a7-examples", "st,stm32mp157d-dk1", "st,stm32mp157";
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts
new file mode 100644
index 000000000..8e37e7640
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-dk1-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Amelie Delaunay <amelie.delaunay@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157d-dk1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 configured to run M4 examples";
+	compatible = "st,stm32mp157d-dk1-m4-examples", "st,stm32mp157d-dk1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-dk1.dts b/arch/arm/boot/dts/stm32mp157d-dk1.dts
new file mode 100644
index 000000000..4bc9fc868
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-dk1.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157a-dk1-scmi.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 Discovery Board";
+	compatible = "st,stm32mp157d-dk1", "st,stm32mp157";
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-ed1.dts b/arch/arm/boot/dts/stm32mp157d-ed1.dts
new file mode 100644
index 000000000..0584b6adb
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-ed1.dts
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157a-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter";
+	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-ev1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157d-ev1-a7-examples.dts
new file mode 100644
index 000000000..60dde36f0
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-ev1-a7-examples.dts
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157d-ev1.dts"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157C-EV1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157d-ev1-a7-examples", "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	test_keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		status = "okay";
+		/* gpio needs vdd core in retention for wakeup */
+		power-domains = <&pd_core_ret>;
+
+		button-1 {
+				label = "PA13";
+				linux,code = <BTN_1>;
+				gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+				status = "okay";
+				wakeup-source;
+		};
+	};
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-ev1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157d-ev1-m4-examples.dts
new file mode 100644
index 000000000..4a4cb1532
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-ev1-m4-examples.dts
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157d-ev1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-EV1 configured to run M4 examples";
+	compatible = "st,stm32mp157d-ev1-m4-examples", "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+};
diff --git a/arch/arm/boot/dts/stm32mp157d-ev1.dts b/arch/arm/boot/dts/stm32mp157d-ev1.dts
new file mode 100644
index 000000000..730b466d6
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157d-ev1.dts
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157d-ed1.dts"
+#include "stm32mp157a-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter on eval mother";
+	compatible = "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts b/arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts
new file mode 100644
index 000000000..8da80c96c
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dk2-a7-examples.dts
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157f-dk2-a7-examples", "st,stm32mp157f-dk2", "st,stm32mp157";
+};
+
+&adc {
+	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+
+	adc1: adc@0 {
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@13 {
+			reg = <13>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+
+	adc2: adc@100 {
+		/* Set IRQ mode as example. DMA is the preferred mode, yet. */
+		/delete-property/dmas;
+		/delete-property/dma-names;
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+&timers1 {
+	status = "okay";
+};
+
+&timers3 {
+	status = "okay";
+};
+
+&timers4 {
+	status = "okay";
+};
+
+&timers5 {
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts b/arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts
new file mode 100644
index 000000000..ccec51342
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dk2-m4-examples.dts
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-dk2.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 configured to run M4 examples";
+	compatible = "st,stm32mp157f-dk2-m4-examples", "st,stm32mp157f-dk2", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&m4_adc {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vrefbuf>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi4_pins_a>;
+	status = "okay";
+};
+
+&m4_timers1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm1_pins_a_ch1>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	status = "okay";
+};
+
+&m4_uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_uart7_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, RSVD)>;
+		};
+	};
+
+	m4_pwm1_pins_a_ch1: m4-pwm1-0-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>;
+		};
+	};
+};
+
+&timers1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-dk2.dts b/arch/arm/boot/dts/stm32mp157f-dk2.dts
new file mode 100644
index 000000000..24626567d
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-dk2.dts
@@ -0,0 +1,169 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157c-dk2-scmi.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 Discovery Board";
+	compatible = "st,stm32mp157f-dk2", "st,stm32mp157";
+
+	aliases {
+		serial3 = &usart2;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+
+	panel_otm8009a: panel-otm8009a@0 {
+		compatible = "orisetech,otm8009a";
+		reg = <0>;
+		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&hdp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdp2_gpo &hdp2_pins_a>;
+	pinctrl-1 = <&hdp2_sleep_pins_a>;
+	status = "disabled";
+};
+
+&i2c1 {
+	touchscreen@38 {
+		compatible = "focaltech,ft6236";
+		reg = <0x38>;
+		interrupts = <2 2>;
+		interrupt-parent = <&gpiof>;
+		interrupt-controller;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <800>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		panel = <&panel_otm8009a>;
+		status = "okay";
+	};
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	cap-sdio-irq;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_c>;
+	pinctrl-1 = <&usart2_sleep_pins_c>;
+	pinctrl-2 = <&usart2_idle_pins_c>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ed1.dts b/arch/arm/boot/dts/stm32mp157f-ed1.dts
new file mode 100644
index 000000000..127af532e
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ed1.dts
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157c-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter";
+	compatible = "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts b/arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts
new file mode 100644
index 000000000..1d6691b41
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ev1-a7-examples.dts
@@ -0,0 +1,55 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-ev1.dts"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-EV1 configured to run Linux A7 examples";
+	compatible = "st,stm32mp157f-ev1-a7-examples", "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	test_keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		status = "okay";
+		/* gpio needs vdd core in retention for wakeup */
+		power-domains = <&pd_core_ret>;
+
+		button-1 {
+			label = "PA13";
+			linux,code = <BTN_1>;
+			gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+			status = "okay";
+			wakeup-source;
+		};
+	};
+};
+
+&adc {
+	status = "okay";
+};
+
+&dac {
+	status = "okay";
+};
+
+&timers2 {
+	status = "okay";
+};
+
+&timers8 {
+	status = "okay";
+};
+
+&timers12 {
+	status = "okay";
+};
+
+&usart3 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts b/arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts
new file mode 100644
index 000000000..6964892a1
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ev1-m4-examples.dts
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157f-ev1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-EV1 configured to run M4 examples";
+	compatible = "st,stm32mp157f-ev1-m4-examples", "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+};
+
+&adc {
+	status = "disabled";
+};
+
+&dac {
+	status = "disabled";
+};
+
+&dcmi {
+	status = "disabled";
+};
+
+&dma2 {
+	status = "disabled";
+};
+
+&dmamux1 {
+	dma-masters = <&dma1>;
+	dma-channels = <8>;
+};
+
+&fmc {
+	status = "disabled";
+};
+
+&i2c5 {
+	status = "disabled";
+};
+
+&m4_adc {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_crc2 {
+	status = "okay";
+};
+
+&m4_cryp2 {
+	status = "okay";
+};
+
+&m4_dac {
+	vref-supply = <&vdda>;
+	status = "okay";
+};
+
+&m4_dma2 {
+	status = "okay";
+};
+
+&m4_hash2 {
+	status = "okay";
+};
+
+&m4_i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_i2c5_pins_a>;
+	status = "okay";
+};
+
+&m4_qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_qspi_clk_pins_a &m4_qspi_bk1_pins_a
+		     &m4_qspi_bk2_pins_a>;
+	status = "okay";
+};
+
+&m4_rng2 {
+	status = "okay";
+};
+
+&m4_rproc {
+	m4_system_resources {
+		status = "okay";
+
+	/*
+		button {
+			compatible = "rproc-srm-dev";
+			interrupt-parent = <&gpioa>;
+			interrupts = <14 2>;
+			interrupt-names = "irq";
+			status = "okay";
+		};
+	*/
+
+		m4_led: m4-led {
+			compatible = "rproc-srm-dev";
+			pinctrl-names = "default";
+			pinctrl-0 = <&m4_leds_orange_pins>;
+			status = "okay";
+		};
+	};
+};
+
+&m4_spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_spi1_pins_a>;
+	status = "okay";
+};
+
+&m4_timers2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_pwm2_pins_a>;
+	status = "okay";
+};
+
+&m4_usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&m4_usart3_pins_a>;
+	status = "okay";
+};
+
+&pinctrl {
+	m4_leds_orange_pins: m4-leds-orange-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 8, RSVD)>;
+		};
+	};
+};
+
+&qspi {
+	status = "disabled";
+};
+
+&sai2b {
+	status = "disabled";
+};
+
+&sound {
+	status = "disabled";
+};
+
+&timers2 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/stm32mp157f-ev1.dts b/arch/arm/boot/dts/stm32mp157f-ev1.dts
new file mode 100644
index 000000000..fb8051fab
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp157f-ev1.dts
@@ -0,0 +1,811 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157f-ed1.dts"
+#include "stm32mp157c-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter on eval mother";
+	compatible = "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	default-on;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/boot/dts/stm32mp15xa.dtsi b/arch/arm/boot/dts/stm32mp15xa.dtsi
new file mode 100644
index 000000000..cc6456e71
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/boot/dts/stm32mp15xc.dtsi b/arch/arm/boot/dts/stm32mp15xc.dtsi
index b06a55a2f..f5c26b7f3 100644
--- a/arch/arm/boot/dts/stm32mp15xc.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xc.dtsi
@@ -4,15 +4,23 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
+#include "stm32mp15xa.dtsi"
+
 / {
 	soc {
-		cryp1: cryp@54001000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54001000 0x400>;
-			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
+		etzpc: etzpc@5c007000 {
+			cryp1: cryp@54001000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54001000 0x400>;
+				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma1 29 0x0 0x400202 0x0 0x0>,
+				       <&mdma1 30 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP1_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/stm32mp15xd.dtsi b/arch/arm/boot/dts/stm32mp15xd.dtsi
new file mode 100644
index 000000000..d8a14c55b
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xd.dtsi
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&cpu_thermal {
+	trips {
+		cpu-crit {
+			temperature = <105000>;
+			hysteresis = <0>;
+			type = "critical";
+		};
+
+		cpu_alert: cpu-alert {
+			temperature = <95000>;
+			hysteresis = <10000>;
+			type = "passive";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu_alert>;
+			cooling-device = <&cpu0 1 1>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15xf.dtsi b/arch/arm/boot/dts/stm32mp15xf.dtsi
new file mode 100644
index 000000000..9f8dc6cbe
--- /dev/null
+++ b/arch/arm/boot/dts/stm32mp15xf.dtsi
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15xd.dtsi"
+
+/ {
+	soc {
+		etzpc: etzpc@5c007000 {
+			cryp1: cryp@54001000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54001000 0x400>;
+				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma1 29 0x0 0x400202 0x0 0x0>,
+				       <&mdma1 30 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP1_ID>;
+				status = "disabled";
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi b/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi
index b7ba43865..a0c927ca6 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dhcor-avenger96.dtsi
@@ -359,11 +359,7 @@ &ltdc {
 	status = "okay";
 
 	port {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&adv7513_in>;
 		};
 	};
diff --git a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
index 73a6a7b27..f28072380 100644
--- a/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/boot/dts/stm32mp15xx-dkx.dtsi
@@ -6,8 +6,17 @@
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
 
 / {
+	aliases {
+		ethernet0 = &ethernet0;
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+	};
+
 	memory@c0000000 {
 		device_type = "memory";
 		reg = <0xc0000000 0x20000000>;
@@ -42,6 +51,12 @@ vdev0buffer: vdev0buffer@10042000 {
 			no-map;
 		};
 
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -60,6 +75,19 @@ gpu_reserved: gpu@d4000000 {
 		};
 	};
 
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&sii9022_out>;
+			};
+		};
+	};
+
 	led {
 		compatible = "gpio-leds";
 		led-blue {
@@ -72,7 +100,7 @@ led-blue {
 
 	sound {
 		compatible = "audio-graph-card";
-		label = "STM32MP1-DK";
+		label = "STM32MP15-DK";
 		routing =
 			"Playback" , "MCLK",
 			"Capture" , "MCLK",
@@ -92,31 +120,47 @@ vin: vin {
 
 &adc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+	pinctrl-0 = <&adc12_usb_cc_pins_a>;
 	vdd-supply = <&vdd>;
 	vdda-supply = <&vdd>;
 	vref-supply = <&vrefbuf>;
-	status = "disabled";
+	status = "okay";
 	adc1: adc@0 {
+		status = "okay";
 		/*
 		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in18 & in19.
 		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
 		 * 5 * (56 + 47kOhms) * 5pF => 2.5us.
 		 * Use arbitrary margin here (e.g. 5us).
 		 */
-		st,min-sample-time-nsecs = <5000>;
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 6 13 18 19>;
-		status = "okay";
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 	adc2: adc@100 {
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 2 6 18 19>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		/* USB Type-C CC1 & CC2 */
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
 &cec {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&cec_pins_b>;
@@ -124,6 +168,14 @@ &cec {
 	status = "okay";
 };
 
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
 &crc1 {
 	status = "okay";
 };
@@ -140,6 +192,8 @@ &ethernet0 {
 	phy-mode = "rgmii-id";
 	max-speed = <1000>;
 	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
 
 	mdio {
 		#address-cells = <1>;
@@ -191,6 +245,13 @@ sii9022_in: endpoint {
 				};
 			};
 
+			port@1 {
+				reg = <1>;
+				sii9022_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
 			port@3 {
 				reg = <3>;
 				sii9022_tx_endpoint: endpoint {
@@ -273,7 +334,7 @@ con_usbotg_hs_ep: endpoint {
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -377,26 +438,26 @@ v1v2_hdmi: ldo6 {
 				interrupts = <IT_CURLIM_LDO6 0>;
 			};
 
-			vref_ddr: vref_ddr {
+			vref_ddr: vref-ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 			};
 
-			 bst_out: boost {
+			bst_out: boost {
 				regulator-name = "bst_out";
 				interrupts = <IT_OCP_BOOST 0>;
-			 };
+			};
 
-			vbus_otg: pwr_sw1 {
+			vbus_otg: pwr-sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr-sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
-			 };
+			};
 		};
 
 		onkey {
@@ -448,11 +509,6 @@ &ipcc {
 	status = "okay";
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
 &ltdc {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&ltdc_pins_a>;
@@ -460,8 +516,7 @@ &ltdc {
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&sii9022_in>;
 		};
 	};
@@ -469,11 +524,12 @@ ltdc_ep0_out: endpoint@0 {
 
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -482,10 +538,6 @@ &pwr_regulators {
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
@@ -501,8 +553,6 @@ &sai2 {
 	sai2a: audio-controller@4400b004 {
 		#clock-cells = <0>;
 		dma-names = "tx";
-		clocks = <&rcc SAI2_K>;
-		clock-names = "sai_ck";
 		status = "okay";
 
 		sai2a_port: port {
@@ -560,11 +610,28 @@ &sdmmc3 {
 	status = "disabled";
 };
 
+&spi4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi4_pins_b>;
+	pinctrl-1 = <&spi4_sleep_pins_b>;
+	status = "disabled";
+};
+
+&spi5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi5_pins_a>;
+	pinctrl-1 = <&spi5_sleep_pins_a>;
+	status = "disabled";
+};
+
 &timers1 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm1_pins_a>;
 		pinctrl-1 = <&pwm1_sleep_pins_a>;
@@ -580,6 +647,9 @@ &timers3 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm3_pins_a>;
 		pinctrl-1 = <&pwm3_sleep_pins_a>;
@@ -595,6 +665,9 @@ &timers4 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm4_pins_a &pwm4_pins_b>;
 		pinctrl-1 = <&pwm4_sleep_pins_a &pwm4_sleep_pins_b>;
@@ -610,6 +683,9 @@ &timers5 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm5_pins_a>;
 		pinctrl-1 = <&pwm5_sleep_pins_a>;
@@ -625,6 +701,9 @@ &timers6 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	timer@5 {
 		status = "okay";
 	};
@@ -634,6 +713,9 @@ &timers12 {
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
 		pinctrl-1 = <&pwm12_sleep_pins_a>;
diff --git a/arch/arm/configs/fragment-01-multiv7_cleanup.config b/arch/arm/configs/fragment-01-multiv7_cleanup.config
new file mode 100644
index 000000000..04dbdba02
--- /dev/null
+++ b/arch/arm/configs/fragment-01-multiv7_cleanup.config
@@ -0,0 +1,263 @@
+#  ALPHABETICALLY SORTED: $LC_ALL=C sort fragment-01-multiv7_cleanup.config -o fragment-01-multiv7_cleanup.config
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_AIROHA is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_HPE is not set
+# CONFIG_ARCH_INTEL_SOCFPGA is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MILBEAUT is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MSTARV7 is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_NPCM is not set
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_RDA is not set
+# CONFIG_ARCH_REALTEK is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_SUNPLUS is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ATAGS is not set
+# CONFIG_CACHE_L2X0 is not set
+# CONFIG_CAN_MCP251X is not set
+# CONFIG_CAN_RCAR is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_CXD2880_SPI_DRV is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_DRM_FBDEV_EMULATION is not set
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_AU8522 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_CXD2880 is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_HELENE is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT3306A is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_M88DS3103 is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_MAX_ADAPTERS is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_MB86A20S is not set
+# CONFIG_DVB_MN88443X is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_MXL692 is not set
+# CONFIG_DVB_NET is not set
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_RTL2830 is not set
+# CONFIG_DVB_RTL2832 is not set
+# CONFIG_DVB_RTL2832_SDR is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_S5H1411 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_SI2168 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_SP2 is not set
+# CONFIG_DVB_SP8870 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STV0297 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_TDA10071 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_EFI is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_EXTCON is not set
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_GCC_PLUGINS is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SLAVE_EEPROM is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_KEXEC is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_MEDIA_CONTROLLER_REQUEST_API is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_MEDIA_TUNER is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MTD_NAND_PL35X is not set
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+# CONFIG_PAGE_POOL_STATS is not set
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PWM_ATMEL_TCB is not set
+# CONFIG_REGULATOR_WM8994 is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+# CONFIG_SERIAL_8250 is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_BRCMSTB is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_STAGING is not set
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_USB_CONFIGFS_RNDIS is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_ETH_RNDIS is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_VIRTIO_CONSOLE is not set
diff --git a/arch/arm/configs/fragment-02-multiv7_addons.config b/arch/arm/configs/fragment-02-multiv7_addons.config
new file mode 100644
index 000000000..53b9d2f51
--- /dev/null
+++ b/arch/arm/configs/fragment-02-multiv7_addons.config
@@ -0,0 +1,101 @@
+#  ALPHABETICALLY SORTED: $LC_ALL=C sort fragment-02-multiv7_addons.config -o fragment-02-multiv7_addons.config
+CONFIG_AEABI=y
+CONFIG_ARM_CPUIDLE=n
+CONFIG_ARM_SCMI_PROTOCOL=y
+CONFIG_ARM_SMC_MBOX=y
+CONFIG_ARM_SMC_WATCHDOG=y
+CONFIG_ARM_STM32_CPUIDLE=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_CAN_M_CAN=y
+CONFIG_CAN_M_CAN_PLATFORM=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CLKSRC_STM32_LP=y
+CONFIG_COMMON_CLK_SCMI=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_CRC_ITU_T=m
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_DNS_RESOLVER=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_PANEL_ORISETECH_OTM8009A=y
+CONFIG_DRM_PANEL_RAYDIUM_RM68200=y
+CONFIG_DRM_PANEL_ROCKTECH_HX8394=y
+CONFIG_DRM_SII902X=y
+CONFIG_DRM_SIMPLEDRM=y
+CONFIG_DRM_STM=y
+CONFIG_DRM_STM_DSI=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_FORCE_MAX_ZONEORDER=12
+CONFIG_FUTEX=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+CONFIG_GDB_SCRIPTS=y
+CONFIG_GENERIC_IRQ_DEBUGFS=y
+CONFIG_HIGHMEM=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_STM32=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_JFFS2_FS=y
+CONFIG_KEYS=y
+CONFIG_LEGACY_PTY_COUNT=8
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_MCPM=y
+CONFIG_MEMCG=y
+CONFIG_MTD_MCHP23K256=m
+CONFIG_MTD_SPI_NAND=y
+CONFIG_NAMESPACES=y
+CONFIG_NR_CPUS=2
+CONFIG_NVMEM_REBOOT_MODE=y
+CONFIG_NVMEM_STM32_ROMEM=y
+CONFIG_NVMEM_STM32_TAMP=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OPTEE=y
+CONFIG_OVERLAY_FS=y
+CONFIG_PINCTRL_MCP23S08=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_PROFILING=y
+CONFIG_REGULATOR_ARM_SCMI=y
+CONFIG_REGULATOR_PROTECTION_CONSUMER=y
+CONFIG_REMOTEPROC=y
+CONFIG_REMOTEPROC_SRM_CORE=y
+CONFIG_REMOTEPROC_SRM_DEV=y
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_TTY=m
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_SAMPLES=y
+CONFIG_SAMPLE_RPMSG_CLIENT=y
+CONFIG_SCHED_MC=y
+CONFIG_SD_ADC_MODULATOR=y
+CONFIG_SENSORS_IIO_HWMON=y
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_SRAM=y
+CONFIG_STM32_IPCC=y
+CONFIG_STM32_RPROC=y
+CONFIG_TEE=y
+CONFIG_THERMAL=y
+CONFIG_TMPFS=y
+CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TYPEC_UCSI=m
+CONFIG_UCSI_STM32G0=m
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_ONBOARD_HUB=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USELIB=y
+CONFIG_VFP=y
+CONFIG_VIDEO_GC2145=m
+CONFIG_VIDEO_OV5640=m
+CONFIG_VIDEO_STM32_HDMI_CEC=y
+CONFIG_VIDEO_ST_MIPID02=m
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_ZBOOT_ROM_TEXT=0x0
diff --git a/arch/arm/configs/multi_v7_defconfig b/arch/arm/configs/multi_v7_defconfig
index b61b2e3d1..5b4dac249 100644
--- a/arch/arm/configs/multi_v7_defconfig
+++ b/arch/arm/configs/multi_v7_defconfig
@@ -665,6 +665,7 @@ CONFIG_V4L_MEM2MEM_DRIVERS=y
 CONFIG_VIDEO_ASPEED=m
 CONFIG_VIDEO_ATMEL_ISC=m
 CONFIG_VIDEO_ATMEL_XISC=m
+CONFIG_VIDEO_STM32_DCMIPP=m
 CONFIG_VIDEO_ATMEL_ISI=m
 CONFIG_VIDEO_MICROCHIP_CSI2DC=m
 CONFIG_VIDEO_MMP_CAMERA=m
diff --git a/arch/arm/mach-stm32/Kconfig b/arch/arm/mach-stm32/Kconfig
index 981450315..8c8d5fc12 100644
--- a/arch/arm/mach-stm32/Kconfig
+++ b/arch/arm/mach-stm32/Kconfig
@@ -11,7 +11,7 @@ menuconfig ARCH_STM32
 	select CLKSRC_STM32
 	select PINCTRL
 	select RESET_CONTROLLER
-	select STM32_EXTI
+	select STM32_EXTI if ARM_SINGLE_ARMV7M
 	help
 	  Support for STMicroelectronics STM32 processors.
 
diff --git a/arch/arm/mach-stm32/board-dt.c b/arch/arm/mach-stm32/board-dt.c
index 2ccaa11aa..9ff06f2fc 100644
--- a/arch/arm/mach-stm32/board-dt.c
+++ b/arch/arm/mach-stm32/board-dt.c
@@ -21,6 +21,8 @@ static const char *const stm32_compat[] __initconst = {
 	"st,stm32mp131",
 	"st,stm32mp133",
 	"st,stm32mp135",
+	"st,stm32mp151",
+	"st,stm32mp153",
 	"st,stm32mp157",
 	NULL
 };
diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 76580b932..65a7dcbd0 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -279,6 +279,21 @@ config ARCH_INTEL_SOCFPGA
 	  Stratix 10 (ex. Altera), Stratix10 Software Virtual Platform,
 	  Agilex and eASIC N5X.
 
+config ARCH_STM32
+	bool "STMicroelectronics STM32 SoC Family"
+	select ARCH_HAS_RESET_CONTROLLER
+	select GPIOLIB
+	select PINCTRL
+	select RESET_CONTROLLER
+	select COMMON_CLK_STM32MP257
+	select RESET_STM32MP1
+	select ARM_SMC_MBOX
+	select ARM_SCMI_PROTOCOL
+	select COMMON_CLK_SCMI
+	select STM32_SYS_BUS
+	help
+	  This enables support for ARMv8 based STMicroelectronics STM32 family.
+
 config ARCH_SYNQUACER
 	bool "Socionext SynQuacer SoC Family"
 	select IRQ_FASTEOI_HIERARCHY_HANDLERS
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index 7b107fa74..30dd6347a 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -27,6 +27,7 @@ subdir-y += renesas
 subdir-y += rockchip
 subdir-y += socionext
 subdir-y += sprd
+subdir-y += st
 subdir-y += synaptics
 subdir-y += tesla
 subdir-y += ti
diff --git a/arch/arm64/boot/dts/st/Makefile b/arch/arm64/boot/dts/st/Makefile
new file mode 100644
index 000000000..0cc12f2b1
--- /dev/null
+++ b/arch/arm64/boot/dts/st/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0-only
+dtb-$(CONFIG_ARCH_STM32) += \
+	stm32mp257f-dk.dtb \
+	stm32mp257f-ev1.dtb
diff --git a/arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi
new file mode 100644
index 000000000..b97e10591
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25-pinctrl.dtsi
@@ -0,0 +1,971 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	eth1_mdio_pins_a: eth1-mdio-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 2, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	eth1_mdio_sleep_pins_a: eth1-mdio-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 2, ANALOG)>; /* ETH_MDIO */
+		};
+	};
+
+	eth1_rgmii_pins_a: eth1-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_sleep_pins_a: eth1-rgmii-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 9, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 14, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth1_rgmii_pins_b: eth1-rgmii-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, AF10)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 10, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_sleep_pins_b: eth1-rgmii-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 9, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth2_rgmii_pins_a: eth2-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 7, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, AF10)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 5, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('G', 0, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins5 {
+			pinmux = <STM32_PINMUX('F', 6, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth2_rgmii_sleep_pins_a: eth2-rgmii-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 0, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('F', 6, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth3_rgmii_pins_a: eth3-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF14)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, AF14)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, AF14)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, AF14)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, AF14)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 2, AF14)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-delay = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('A', 9, AF14)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, AF14)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, AF14)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, AF14)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, AF14)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 5, AF14)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth3_rgmii_sleep_pins_a: eth3-rgmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 2, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 5, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	i2c2_pins_a: i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('B', 4, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_a: i2c2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('B', 4, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2c2_pins_b: i2c2-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_b: i2c2-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2s2_pins_a: i2s2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('K', 1, AF2)>, /* I2S2_SDO */
+				 <STM32_PINMUX('I', 14, AF2)>, /* I2S2_WS */
+				 <STM32_PINMUX('B', 0, AF2)>; /* I2S2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	i2s2_sleep_pins_a: i2s2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 1, ANALOG)>, /* I2S2_SDO */
+				 <STM32_PINMUX('I', 14, ANALOG)>, /* I2S2_WS */
+				 <STM32_PINMUX('B', 0, ANALOG)>; /* I2S2_CK */
+		};
+	};
+
+	i2s2_pins_b: i2s2-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 2, AF2)>, /* I2S2_SDO */
+				<STM32_PINMUX('B', 3, AF2)>, /* I2S2_WS */
+				<STM32_PINMUX('B', 0, AF2)>; /* I2S2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	i2s2_sleep_pins_b: i2s2-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 2, ANALOG)>, /* I2S2_SDO */
+				<STM32_PINMUX('B', 3, ANALOG)>, /* I2S2_WS */
+				<STM32_PINMUX('B', 0, ANALOG)>; /* I2S2_CK */
+		};
+	};
+
+	m_can1_pins_a: m-can1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 11, AF7)>; /* CAN1_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 12, AF7)>; /* CAN1_RX */
+			bias-disable;
+		};
+	};
+
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, ANALOG)>, /* CAN3_TX */
+				 <STM32_PINMUX('G', 12, ANALOG)>; /* CAN3_RX */
+		};
+	};
+
+	m_can3_pins_a: m-can3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 14, AF7)>; /* CAN3_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 12, AF7)>; /* CAN3_RX */
+			bias-disable;
+		};
+	};
+
+	m_can3_sleep_pins_a: m-can3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 14, ANALOG)>, /* CAN3_TX */
+				 <STM32_PINMUX('I', 12, ANALOG)>; /* CAN3_RX */
+		};
+	};
+
+	mdf_cck0_pins_a: mdf-cck0-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 7, AF5)>; /* MDF1_CCK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_cck0_sleep_pins_a: mdf-cck0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 7, ANALOG)>; /* MDF1_CCK */
+		};
+	};
+
+	mdf_sdi6_pins_a: mdf-sdi6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF5)>; /* MDF1_SDI6 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_sdi6_sleep_pins_a: mdf-sdi6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>; /* MDF1_SDI6 */
+		};
+	};
+
+	ospi_port1_clk_pins_a: ospi-port1-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, AF10)>; /* OSPI1_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	ospi_port1_clk_sleep_pins_a: ospi-port1-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, ANALOG)>; /* OSPI1_CLK */
+		};
+	};
+
+	ospi_port1_cs0_pins_a: ospi-port1-cs0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, AF10)>; /* OSPI_NCS0 */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_cs0_sleep_pins_a: ospi-port1-cs0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, ANALOG)>; /* OSPI_NCS0 */
+		};
+	};
+
+	ospi_port1_io03_pins_a: ospi-port1-io03-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF10)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, AF10)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, AF10)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, AF10)>; /* OSPI_IO3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_io03_sleep_pins_a: ospi-port1-io03-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, ANALOG)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, ANALOG)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, ANALOG)>; /* OSPI_IO3 */
+		};
+	};
+
+	pcie_pins_a: pcie-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, AF4)>;
+			bias-disable;
+		};
+	};
+
+	pcie_init_pins_a: pcie-init-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, GPIO)>;
+			output-low;
+		};
+	};
+
+	pcie_sleep_pins_a: pcie-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, ANALOG)>;
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1a_pins_a: sai1a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 9, AF3)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('D', 8, AF3)>, /* SAI1_FS_A */
+				 <STM32_PINMUX('D', 10, AF3)>; /* SAI1_SCK_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 11, AF3)>; /* SAI1_MCLK_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	sai1a_sleep_pins_a: sai1a-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 9, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('D', 8, ANALOG)>, /* SAI1_FS_A */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('D', 11, ANALOG)>; /* SAI1_MCLK_A */
+		};
+	};
+
+	sai1b_pins_a: sai1b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF4)>; /* SAI1_SD_B */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sai1b_sleep_pins_a: sai1b-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>; /* SAI1_SD_B */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>; /* SDMMC1_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 4, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('E', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_pins_a: sdmmc2-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>; /* SDMMC2_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_sleep_pins_a: sdmmc2-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 14, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('E', 15, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_sleep_pins_a: sdmmc2-d47-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, ANALOG)>; /* SDMMC2_D7 */
+		};
+	};
+
+	sdmmc3_b4_pins_a: sdmmc3-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_od_pins_a: sdmmc3-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>; /* SDMMC3_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_sleep_pins_a: sdmmc3-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('D', 13, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('I', 11, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('B', 13, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('D', 12, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	spi3_pins_a: spi3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 7, AF1)>, /* SPI3_SCK */
+				 <STM32_PINMUX('B', 8, AF1)>; /* SPI3_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 10, AF1)>; /* SPI3_MISO */
+			bias-disable;
+		};
+	};
+
+	spi3_sleep_pins_a: spi3-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 7, ANALOG)>, /* SPI3_SCK */
+				 <STM32_PINMUX('B', 8, ANALOG)>, /* SPI3_MOSI */
+				 <STM32_PINMUX('B', 10, ANALOG)>; /* SPI3_MISO */
+		};
+	};
+
+	spi6_pins_a: spi6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF3)>, /* SPI6_SCK */
+				 <STM32_PINMUX('C', 7, AF3)>; /* SPI6_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF3)>; /* SPI6_MISO */
+			bias-disable;
+		};
+	};
+
+	spi6_sleep_pins_a: spi6-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI6_SCK */
+				 <STM32_PINMUX('C', 7, ANALOG)>, /* SPI6_MOSI */
+				 <STM32_PINMUX('C', 4, ANALOG)>; /* SPI6_MISO */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, AF6)>, /* USART1_TX */
+				<STM32_PINMUX('I', 2, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 15, AF6)>, /* USART1_RX */
+				<STM32_PINMUX('I', 3, AF6)>; /* USART1_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				<STM32_PINMUX('I', 3, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 2, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('G', 15, AF6)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				<STM32_PINMUX('I', 2, ANALOG)>, /* USART1_RTS */
+				<STM32_PINMUX('I', 3, ANALOG)>, /* USART1_CTS_NSS */
+				<STM32_PINMUX('G', 15, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>; /* USART2_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('A', 8, ANALOG)>; /* USART2_RX */
+		};
+	};
+
+	usart6_pins_a: usart6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, AF3)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, AF3)>;  /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>, /* USART6_RX */
+				 <STM32_PINMUX('F', 15, AF3)>; /* USART6_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart6_idle_pins_a: usart6-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('F', 15, ANALOG)>; /* USART6_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 5, AF3)>; /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>; /* USART6_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart6_sleep_pins_a: usart6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, ANALOG)>,  /* USART6_RTS */
+				 <STM32_PINMUX('F', 15, ANALOG)>, /* USART6_CTS_NSS */
+				 <STM32_PINMUX('F', 14, ANALOG)>; /* USART6_RX */
+		};
+	};
+};
+
+&pinctrl_z {
+	i2c8_pins_a: i2c8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF8)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, AF8)>; /* I2C8_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c8_sleep_pins_a: i2c8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I2C8_SDA */
+		};
+	};
+
+	i3c4_pins_a: i3c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF11)>, /* I3C4_SCL */
+				 <STM32_PINMUX('Z', 3, AF11)>; /* I3C4_SDA */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c4_init_pins_a: i3c4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 4, AF11)>; /* I3C4_SCL */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 3, AF11)>; /* I3C4_SDA */
+			drive-push-pull;
+			bias-pull-up;
+			slew-rate = <1>;
+		};
+	};
+
+	i3c4_sleep_pins_a: i3c4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I3C4_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I3C4_SDA */
+		};
+	};
+
+	lpuart1_pins_a: lpuart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, AF6)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 5, AF6)>; /* LPUART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 8, AF6)>, /* LPUART1_RX */
+				 <STM32_PINMUX('Z', 6, AF6)>; /* LPUART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	lpuart1_idle_pins_a: lpuart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* LPUART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 5, AF6)>; /* LPUART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('Z', 8, AF6)>; /* LPUART1_RX */
+			bias-pull-up;
+		};
+	};
+
+	lpuart1_sleep_pins_a: lpuart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 5, ANALOG)>, /* LPUART1_RTS */
+				 <STM32_PINMUX('Z', 6, ANALOG)>, /* LPUART1_CTS_NSS */
+				 <STM32_PINMUX('Z', 8, ANALOG)>; /* LPUART1_RX */
+		};
+	};
+
+	spi8_pins_a: spi8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 2, AF3)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 0, AF3)>; /* SPI8_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 1, AF3)>; /* SPI8_MISO */
+			bias-disable;
+		};
+	};
+
+	spi8_sleep_pins_a: spi8-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 2, ANALOG)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI8_MOSI */
+				 <STM32_PINMUX('Z', 1, ANALOG)>; /* SPI8_MISO */
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp251.dtsi b/arch/arm64/boot/dts/st/stm32mp251.dtsi
new file mode 100644
index 000000000..4ec04c776
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp251.dtsi
@@ -0,0 +1,3178 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/arm/coresight-cti-dt.h>
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+#include <dt-bindings/clock/stm32mp25-clks.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/reset/stm32mp25-resets.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD0>;
+			power-domain-names = "psci";
+		};
+
+		idle-states {
+			entry-method = "psci";
+
+			CPU_PWRDN: cpu-power-down {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00000001>;
+				local-timer-stop;
+				entry-latency-us = <300>;
+				exit-latency-us = <500>;
+				min-residency-us = <1000>;
+			};
+		};
+
+		domain-idle-states {
+			STOP1: domain-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000011>;
+				entry-latency-us = <400>;
+				exit-latency-us = <1200>;
+				min-residency-us = <1500>;
+			};
+
+			LP_STOP1: domain-lp-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x0000021>;
+				entry-latency-us = <500>;
+				exit-latency-us = <2000>;
+				min-residency-us = <3000>;
+			};
+
+			LPLV_STOP1: domain-lplv-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000211>;
+				entry-latency-us = <500>;
+				exit-latency-us = <3000>;
+				min-residency-us = <4000>;
+			};
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a35-pmu";
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xb200005a>;
+		status = "disabled";
+	};
+
+	clocks {
+		clk_rcbsec: clk-rcbsec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+	};
+
+	cs_replicator: replicator {
+		compatible = "arm,coresight-static-replicator";
+		clocks = <&scmi_clk CK_SCMI_SYSATB>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				replicator_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				replicator_out_port0: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				replicator_out_port1: endpoint {
+					remote-endpoint = <&tpiu_in_port>;
+				};
+			};
+		};
+	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+
+			scmi_devpd: protocol@11 {
+				reg = <0x11>;
+				#power-domain-cells = <1>;
+			};
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_vddio1: regulator@0 {
+						voltd-name = "vddio1";
+						reg = <VOLTD_SCMI_VDDIO1>;
+						regulator-name = "vddio1";
+					};
+					scmi_vddio2: regulator@1 {
+						voltd-name = "vddio2";
+						reg = <VOLTD_SCMI_VDDIO2>;
+						regulator-name = "vddio2";
+					};
+					scmi_vddio3: regulator@2 {
+						voltd-name = "vddio3";
+						reg = <VOLTD_SCMI_VDDIO3>;
+						regulator-name = "vddio3";
+					};
+					scmi_vddio4: regulator@3 {
+						voltd-name = "vddio4";
+						reg = <VOLTD_SCMI_VDDIO4>;
+						regulator-name = "vddio4";
+					};
+					scmi_vdd33ucpd: regulator@5 {
+						voltd-name = "vdd33ucpd";
+						reg = <VOLTD_SCMI_UCPD>;
+						regulator-name = "vdd33ucpd";
+					};
+					scmi_vdda18adc: regulator@7 {
+						voltd-name = "vdda18adc";
+						reg = <VOLTD_SCMI_ADC>;
+						regulator-name = "vdda18adc";
+					};
+					scmi_vddgpu: regulator@8 {
+						voltd-name = "vddgpu";
+						reg = <VOLTD_SCMI_GPU>;
+						regulator-name = "vddgpu";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x0 0x4ac10000 0x0 0x1000>,
+		      <0x0 0x4ac20000 0x0 0x2000>,
+		      <0x0 0x4ac40000 0x0 0x2000>,
+		      <0x0 0x4ac60000 0x0 0x2000>;
+
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		v2m0: v2m@48090000 {
+			compatible = "arm,gic-v2m-frame";
+			reg = <0x0 0x48090000 0x0 0x1000>;
+			msi-controller;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+
+		CPU_PD0: power-domain-cpu0 {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+
+		CLUSTER_PD: power-domain-cluster {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&STOP1>, <&LP_STOP1>;
+			power-domains = <&RET_PD>;
+		};
+
+		RET_PD: power-domain-retention {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&LPLV_STOP1>;
+		};
+	};
+
+	thermal-zones {
+		cpu0-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 0>;
+
+			trips {
+				cpu0_crit {
+					temperature = <95000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu1-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 1>;
+
+			trips {
+				cpu1_crit {
+					temperature = <95000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		arm,no-tick-in-suspend;
+	};
+
+	usb2_phy1: usb2-phy1 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2400>;
+		clocks          = <&rcc CK_KER_USB2PHY1>;
+		resets          = <&rcc USB2PHY1_R>;
+		status          = "disabled";
+	};
+
+	usb2_phy2: usb2-phy2 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2800>;
+		clocks          = <&rcc CK_KER_USB2PHY2EN>;
+		resets          = <&rcc USB2PHY2_R>;
+		status          = "disabled";
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x80000000>;
+
+		hpdma: dma-controller@40400000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40400000 0x1000>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA1>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma2: dma-controller@40410000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40410000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA2>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma3: dma-controller@40420000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40420000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA3>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		ipcc1: mailbox@40490000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x40490000 0x400>;
+			st,proc-id = <0>;
+			interrupts = <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi_clk CK_SCMI_IPCC1>;
+			status = "disabled";
+		};
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+			feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPIM_ID>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 2 0x62 0x00003121>,
+				       <&hpdma 2 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1000>;
+				clocks = <&scmi_clk CK_SCMI_OSPI1>;
+				resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 3 0x62 0x00003121>,
+				       <&hpdma 3 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1400>;
+				clocks = <&scmi_clk CK_SCMI_OSPI2>;
+				resets = <&scmi_reset RST_SCMI_OSPI2>, <&scmi_reset RST_SCMI_OSPI2DLL>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		rifsc: rifsc@42080000 {
+			compatible = "st,stm32mp25-sys-bus";
+			reg = <0x42080000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+			feature-domain-controller;
+			#feature-domain-cells = <1>;
+
+			timers2: timer@40000000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM2>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@1 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers3: timer@40010000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40010000 0x400>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM3>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@2 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers4: timer@40020000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40020000 0x400>;
+				interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM4>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@3 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers5: timer@40030000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40030000 0x400>;
+				interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM5>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@4 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers6: timer@40040000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40040000 0x400>;
+				interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM6>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@5 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
+			};
+
+			timers7: timer@40050000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40050000 0x400>;
+				interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM7>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
+			};
+
+			timers12: timer@40060000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40060000 0x400>;
+				interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM12>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM12_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@40070000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40070000 0x400>;
+				interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM13>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM13_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@40080000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40080000 0x400>;
+				interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM14>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM14_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			lptimer1: timer@40090000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x40090000 0x400>;
+				interrupts-extended = <&exti1 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM1>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM1_ID>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@0 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@400a0000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x400a0000 0x400>;
+				interrupts-extended = <&exti1 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM2>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM2_ID>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+			};
+
+			i2s2: audio-controller@400b0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400b0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI2>, <&rcc CK_KER_SPI2>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x43 0x12>,
+					<&hpdma 52 0x43 0x21>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI2_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi2: spi@400b0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400b0000 0x400>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI2>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x20 0x00003012>,
+				       <&hpdma 52 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2s3: audio-controller@400c0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400c0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI3>, <&rcc CK_KER_SPI3>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x43 0x12>,
+					<&hpdma 54 0x43 0x21>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI3_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi3: spi@400c0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400c0000 0x400>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI3>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x20 0x00003012>,
+				       <&hpdma 54 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spdifrx: audio-controller@400d0000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x400d0000 0x400>;
+				clocks = <&rcc CK_KER_SPDIFRX>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 71 0x43 0x212>,
+					<&hpdma 72 0x43 0x212>;
+				dma-names = "rx", "rx-ctrl";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPDIFRX_ID>;
+				status = "disabled";
+			};
+
+			usart2: serial@400e0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400e0000 0x400>;
+				interrupts-extended = <&exti1 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART2>;
+				dmas = <&hpdma 11 0x20 0x10012>,
+				       <&hpdma 12 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			usart3: serial@400f0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400f0000 0x400>;
+				interrupts-extended = <&exti1 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART3>;
+				dmas = <&hpdma 13 0x20 0x10012>,
+				       <&hpdma 14 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart4: serial@40100000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40100000 0x400>;
+				interrupts-extended = <&exti1 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART4>;
+				dmas = <&hpdma 15 0x20 0x10012>,
+				       <&hpdma 16 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart5: serial@40110000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40110000 0x400>;
+				interrupts-extended = <&exti1 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART5>;
+				dmas = <&hpdma 17 0x20 0x10012>,
+				       <&hpdma 18 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40120000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40120000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C1>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 27 0x20 0x00003012>,
+				       <&hpdma 28 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40130000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40130000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C2>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 30 0x20 0x00003012>,
+				       <&hpdma 31 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40140000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40140000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C3>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 33 0x20 0x00003012>,
+				       <&hpdma 34 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@40150000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40150000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C4>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 36 0x20 0x00003012>,
+				       <&hpdma 37 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40160000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40160000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C5>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 39 0x20 0x00003012>,
+				       <&hpdma 40 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@40170000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40170000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C6>;
+				resets = <&rcc I2C6_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 42 0x20 0x00003012>,
+				       <&hpdma 43 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c7: i2c@40180000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40180000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C7>;
+				resets = <&rcc I2C7_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 45 0x20 0x00003012>,
+				       <&hpdma 46 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c1: i3c@40190000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x40190000 0x400>;
+				interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C1>;
+				resets = <&rcc I3C1_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c2: i3c@401a0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401a0000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C2>;
+				resets = <&rcc I3C2_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c3: i3c@401b0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401b0000 0x400>;
+				interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C3>;
+				resets = <&rcc I3C3_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers10: timer@401c0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401c0000 0x400>;
+				interrupts = <GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM10>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM10_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@9 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <9>;
+					status = "disabled";
+				};
+			};
+
+			timers11: timer@401d0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401d0000 0x400>;
+				interrupts = <GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM11>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM11_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@10 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <10>;
+					status = "disabled";
+				};
+			};
+
+			timers1: timer@40200000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40200000 0x400>;
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM1>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@0 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers8: timer@40210000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40210000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM8>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@7 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart6: serial@40220000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40220000 0x400>;
+				interrupts-extended = <&exti1 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART6>;
+				dmas = <&hpdma 19 0x20 0x10012>,
+				       <&hpdma 20 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2s1: audio-controller@40230000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x40230000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI1>, <&rcc CK_KER_SPI1>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x43 0x12>,
+					<&hpdma 50 0x43 0x21>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI1_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi1: spi@40230000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40230000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI1>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x20 0x00003012>,
+				       <&hpdma 50 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi4: spi@40240000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40240000 0x400>;
+				interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI4>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&hpdma 55 0x20 0x00003012>,
+				       <&hpdma 56 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers15: timer@40250000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40250000 0x400>;
+				interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM15>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM15_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@40260000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40260000 0x400>;
+				interrupts = <GIC_SPI 194 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM16>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM16_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@40270000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40270000 0x400>;
+				interrupts = <GIC_SPI 195 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM17>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM17_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			spi5: spi@40280000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40280000 0x400>;
+				interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI5>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&hpdma 57 0x20 0x00003012>,
+				       <&hpdma 58 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sai1: sai@40290000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40290000 0x4>, <0x4029a3f0 0x10>;
+				ranges = <0 0x40290000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI1>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai1a: audio-controller@40290004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 73 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai1b: audio-controller@40290024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 74 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai2: sai@402a0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402a0000 0x4>, <0x402aa3f0 0x10>;
+				ranges = <0 0x402a0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI2>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai2a: audio-controller@402a0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 75 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai2b: audio-controller@402a0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 76 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai3: sai@402b0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402b0000 0x4>, <0x402ba3f0 0x10>;
+				ranges = <0 0x402b0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI3>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai3a: audio-controller@402b0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 77 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai3b: audio-controller@502b0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 78 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			uart9: serial@402c0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x402c0000 0x400>;
+				interrupts-extended = <&exti1 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART9>;
+				dmas = <&hpdma 25 0x20 0x10012>,
+				       <&hpdma 26 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART9_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			timers20: timer@40320000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40320000 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM20>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM20_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@19 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <19>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart1: serial@40330000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40330000 0x400>;
+				interrupts-extended = <&exti1 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART1>;
+				dmas = <&hpdma 9 0x20 0x10012>,
+				       <&hpdma 10 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			sai4: sai@40340000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40340000 0x4>, <0x4034a3f0 0x10>;
+				ranges = <0 0x40340000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI4>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai4a: audio-controller@40340004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 79 0x63 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai4b: audio-controller@40340024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 80 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			spi6: spi@40350000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40350000 0x400>;
+				interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI6>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&hpdma 59 0x20 0x00003012>,
+				       <&hpdma 60 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi7: spi@40360000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40360000 0x400>;
+				interrupts = <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI7>;
+				resets = <&rcc SPI7_R>;
+				dmas = <&hpdma 61 0x20 0x00003012>,
+				       <&hpdma 62 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			uart7: serial@40370000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40370000 0x400>;
+				interrupts-extended = <&exti1 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART7>;
+				dmas = <&hpdma 21 0x20 0x10012>,
+				       <&hpdma 22 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart8: serial@40380000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40380000 0x400>;
+				interrupts-extended = <&exti1 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART8>;
+				dmas = <&hpdma 23 0x20 0x10012>,
+				       <&hpdma 24 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@404a0000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x404a0000 0x400>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CCI_R>;
+				clocks = <&rcc CK_BUS_CCI>;
+				clock-names = "mclk";
+				dmas = <&hpdma 137 0x60 0x00003012>;
+				dma-names = "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_DCMI_PSSI_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			crc: crc@404c0000 {
+				compatible = "st,stm32f7-crc";
+				reg = <0x404c0000 0x400>;
+				clocks = <&rcc CK_BUS_CRC>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_CRC_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			adc_12: adc@404e0000 {
+				compatible = "st,stm32mp25-adc-core";
+				reg = <0x404e0000 0x400>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC12>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ADC12_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <0>;
+					dmas = <&hpdma 81 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+				};
+
+				adc2: adc@100 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x100>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <1>;
+					dmas = <&hpdma 82 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			mdf1: mdf@404d0000 {
+				compatible = "st,stm32mp25-mdf";
+				ranges = <0 0x404d0000 0x1000>;
+				reg = <0x404d0000 0x8>, <0x404d0ff0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_KER_MDF1>;
+				clock-names = "ker_ck";
+				clock-ranges;
+				resets = <&rcc MDF1_R>;
+				reset-names = "mdf";
+				feature-domains = <&rifsc STM32MP25_RIFSC_MDF1_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+
+				sitf0: sitf@80 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x80 0x4>;
+					status = "disabled";
+				};
+
+				sitf1: sitf@100 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x100 0x4>;
+					status = "disabled";
+				};
+
+				sitf2: sitf@180 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x180 0x4>;
+					status = "disabled";
+				};
+
+				sitf3: sitf@200 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x200 0x4>;
+					status = "disabled";
+				};
+
+				sitf4: sitf@280 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x280 0x4>;
+					status = "disabled";
+				};
+
+				sitf5: sitf@300 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x300 0x4>;
+					status = "disabled";
+				};
+
+				sitf6: sitf@380 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x380 0x4>;
+					status = "disabled";
+				};
+
+				sitf7: sitf@400 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x400 0x4>;
+					status = "disabled";
+				};
+
+				filter0: filter@84 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x84 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 63 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter1: filter@104 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x104 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 64 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter2: filter@184 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x184 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 65 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter3: filter@204 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x204 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 66 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter4: filter@284 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x284 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 67 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter5: filter@304 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x304 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 68 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter6: filter@384 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x384 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 69 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter7: filter@404 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x404 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 70 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+			};
+
+			adc_3: adc@404f0000 {
+				compatible = "st,stm32mp25-adc-core";
+				reg = <0x404f0000 0x400>;
+				interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC3>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ADC3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc3: adc@0 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_3>;
+					interrupts = <0>;
+					dmas = <&hpdma 83 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			hash: hash@42010000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x42010000 0x400>;
+				interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_HASH>;
+				resets = <&rcc HASH_R>;
+				dmas = <&hpdma 6 0x40 0x3021>;
+				dma-names = "in";
+				feature-domains = <&rifsc STM32MP25_RIFSC_HASH_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			rng: rng@42020000 {
+				compatible = "st,stm32mp25-rng";
+				reg = <0x42020000 0x400>;
+				clocks = <&clk_rcbsec>, <&rcc CK_BUS_RNG>;
+				clock-names = "rng_clk", "rng_hclk";
+				resets = <&rcc RNG_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_RNG_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			iwdg1: watchdog@44010000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44010000 0x400>;
+				interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG1>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				feature-domains = <&rifsc STM32MP25_RIFSC_IWDG1_ID>;
+				status = "disabled";
+			};
+
+			iwdg2: watchdog@44020000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44020000 0x400>;
+				interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				feature-domains = <&rifsc STM32MP25_RIFSC_IWDG2_ID>;
+				status = "disabled";
+			};
+
+			spi8: spi@46020000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x46020000 0x400>;
+				interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI8>;
+				resets = <&rcc SPI8_R>;
+				dmas = <&hpdma 171 0x20 0x00003012>,
+				       <&hpdma 172 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lpuart1: serial@46030000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x46030000 0x400>;
+				interrupts-extended = <&exti2 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPUART1>;
+				dmas = <&hpdma 166 0x20 0x10012>,
+				       <&hpdma 167 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPUART1_ID>;
+				status = "disabled";
+			};
+
+			i2c8: i2c@46040000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x46040000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C8>;
+				resets = <&rcc I2C8_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 168 0x20 0x00003012>,
+				       <&hpdma 169 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lptimer3: timer@46050000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46050000 0x400>;
+				interrupts-extended = <&exti2 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM3>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM3_ID>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			lptimer4: timer@46060000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46060000 0x400>;
+				interrupts-extended = <&exti2 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM4>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM4_ID>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@3 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+			};
+
+			lptimer5: timer@46070000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46070000 0x400>;
+				interrupts-extended = <&exti2 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM5>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM5_ID>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@4 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+			};
+
+			i3c4: i3c@46080000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x46080000 0x400>;
+				interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C4>;
+				resets = <&rcc I3C4_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ltdc: display-controller@48010000 {
+				compatible = "st,stm32mp25-ltdc";
+				reg = <0x48010000 0x400>;
+				st,syscon = <&syscfg>;
+				interrupts = <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+				clock-names = "bus", "lcd";
+				resets = <&rcc LTDC_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LTDC_CMN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			csi2host: csi2host@48020000 {
+				compatible = "st,stm32-csi2host";
+				reg = <0x48020000 0x2000>;
+				interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CSI_R>;
+				clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>,
+					 <&rcc CK_KER_CSIPHY>;
+				clock-names = "pclk", "txesc", "csi2phy";
+				feature-domains = <&rifsc STM32MP25_RIFSC_CSI_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			dcmipp: dcmipp@48030000 {
+				compatible = "st,stm32mp25-dcmipp";
+				reg = <0x48030000 0x1000>;
+				interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPP_R>;
+				clocks = <&rcc CK_BUS_DCMIPP>, <&rcc CK_KER_CSI>;
+				clock-names = "kclk", "mclk";
+				feature-domains = <&rifsc STM32MP25_RIFSC_DCMIPP_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			combophy: phy@480c0000 {
+				compatible = "st,stm32mp25-combophy";
+				reg = <0x480c0000 0x1000>;
+				#phy-cells = <1>;
+				clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
+				clock-names = "apb-clk", "ker-clk";
+				resets = <&rcc USB3PCIEPHY_R>;
+				reset-names = "phy-rst";
+				st,syscfg = <&syscfg>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_COMBOPHY_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 45 IRQ_TYPE_EDGE_FALLING>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@48220000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48220000 0x400>, <0x44230400 0x8>;
+				interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC1>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SDMMC1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@48230000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48230000 0x400>, <0x44230800 0x8>;
+				interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC2>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SDMMC2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc3: mmc@48240000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48240000 0x400>, <0x44230c00 0x8>;
+				interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC3>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SDMMC3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			eth1: eth1@482c0000 {
+				compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+				reg = <0x482c0000 0x4000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti1 68 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ptp_ref",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc CK_ETH1_MAC>,
+					 <&rcc CK_ETH1_TX>,
+					 <&rcc CK_ETH1_RX>,
+					 <&rcc CK_KER_ETH1PTP>,
+					 <&rcc CK_ETH1_STP>,
+					 <&rcc CK_KER_ETH1>;
+				st,syscon = <&syscfg 0x3000 0xffffffff>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,txqos = <7>;
+				snps,rxqos = <7>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ETH1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+				snps,mtl-rx-config = <&mtl_rx_setup_1>;
+				snps,mtl-tx-config = <&mtl_tx_setup_1>;
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+
+				mtl_rx_setup_1: rx-queues-config {
+					snps,rx-queues-to-use = <2>;
+					queue0 {};
+					queue1 {};
+				};
+
+				mtl_tx_setup_1: tx-queues-config {
+					snps,tx-queues-to-use = <4>;
+					queue0 {};
+					queue1 {};
+					queue2 {};
+					queue3 {};
+				};
+			};
+
+			usbh: usb@482e0000 {
+				compatible = "st,stm32mp25-usbh";
+				st,syscfg = <&syscfg 0x2420>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x482e0000 0x482e0000 0x20000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_USBH_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 43 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				usbh_ohci: usb@482e0000 {
+					compatible = "generic-ohci";
+					reg = <0x482e0000 0x1000>;
+					clocks = <&usb2_phy1>, <&rcc CK_BUS_USB2OHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+
+				usbh_ehci: usb@482f0000 {
+					compatible = "generic-ehci";
+					reg = <0x482f0000 0x1000>;
+					clocks = <&rcc CK_BUS_USB2EHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+					companion = <&usbh_ohci>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+			};
+
+			usb3dr: usb@48300000 {
+				compatible = "st,stm32mp25-dwc3";
+				st,syscfg = <&syscfg 0x4800>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x48300000 0x48300000 0x100000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_USB3DR_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 44 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				dwc3: usb@48300000 {
+					compatible = "snps,dwc3";
+					reg = <0x48300000 0x100000>;
+					interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+					clock-names = "ref", "bus_early", "suspend";
+					clocks = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DR>,
+						 <&rcc CK_KER_USB2PHY2>;
+					resets = <&rcc USB3DR_R>;
+					phys = <&usb2_phy2>;
+					phy-names = "usb2-phy";
+					wakeup-source;
+				};
+			};
+
+			pcie_ep: pcie-ep@48400000 {
+				compatible = "st,stm32mp25-pcie-ep";
+				num-lanes = <1>;
+				reg = <0x48400000 0x400000>,
+				      <0x10000000 0x8000000>;
+				reg-names = "dbi", "addr_space";
+				st,syscfg = <&syscfg>;
+				clocks = <&rcc CK_BUS_PCIE>;
+				clock-names = "core";
+				resets = <&rcc PCIE_R>;
+				reset-names = "pcie";
+				phys = <&combophy PHY_TYPE_PCIE>;
+				phy-names = "pcie-phy";
+				feature-domains = <&rifsc STM32MP25_RIFSC_PCIE_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			pcie_rc: pcie@48400000 {
+				compatible = "st,stm32mp25-pcie-rc";
+				device_type = "pci";
+				num-lanes = <1>;
+				reg = <0x48400000 0x400000>,
+				      <0x10000000 0x10000>;
+				reg-names = "dbi", "config";
+				st,syscfg = <&syscfg>;
+				#interrupt-cells = <1>;
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &intc 0 0 GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 2 &intc 0 0 GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 3 &intc 0 0 GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 4 &intc 0 0 GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>;
+				interrupts = <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "aer_msi", "pme_msi";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges = <0x01000000 0 0x10010000 0x10010000 0 0x10000>,
+					 <0x02000000 0 0x10020000 0x10020000 0 0x7fe0000>,
+					 <0x42000000 0 0x18000000 0x18000000 0 0x8000000>;
+				bus-range = <0x00 0xff>;
+				clocks = <&rcc CK_BUS_PCIE>;
+				clock-names = "core";
+				resets = <&rcc PCIE_R>;
+				reset-names = "pcie";
+				phys = <&combophy PHY_TYPE_PCIE>;
+				phy-names = "pcie-phy";
+
+				msi-parent = <&v2m0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_PCIE_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		risaf1: risaf@420a0000 {
+			compatible = "st,stm32mp25-risaf";
+			reg = <0x420a0000 0x1000>;
+			clocks = <&rcc CK_BUS_BKPSRAM>;
+			st,mem-map = <0x0 0x42000000 0x0 0x2000>;
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32mp25-risaf-enc";
+			reg = <0x420d0000 0x1000>;
+			clocks = <&rcc CK_BUS_RISAF4>;
+			st,mem-map = <0x0 0x80000000 0x1 0x00000000>;
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+
+			vrefint: vrefin-cal@1b8 {
+				reg = <0x1b8 0x2>;
+			};
+
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		dts: thermal-sensor@44070000 {
+			compatible = "moortec,mr75203";
+			reg = <0x44070000 0x80>,
+			      <0x44070080 0x180>,
+			      <0x44070200 0x200>,
+			      <0x44070400 0xc00>;
+			reg-names = "common", "ts", "pd", "vm";
+			clocks = <&rcc CK_KER_DTS>;
+			resets = <&rcc DTS_R>;
+			#thermal-sensor-cells = <1>;
+		};
+
+		hdp: pinctrl@44090000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x44090000 0x400>;
+			clocks = <&rcc CK_BUS_HDP>;
+			status = "disabled";
+		};
+
+		rcc: rcc@44200000 {
+			compatible = "st,stm32mp25-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clock-names = "hse", "hsi", "msi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				<&scmi_clk CK_SCMI_HSI>,
+				<&scmi_clk CK_SCMI_MSI>,
+				<&scmi_clk CK_SCMI_LSE>,
+				<&scmi_clk CK_SCMI_LSI>;
+			feature-domains = <&rifsc 156>;
+		};
+
+		pwr: syscon@44210000 {
+			compatible = "st,stm32mp25-pwr", "syscon";
+			reg = <0x44210000 0x0400>;
+		};
+
+		exti1: interrupt-controller@44220000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x44220000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 0   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<&intc GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 209 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<&intc GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_80 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+			#clock-cells = <1>;
+		};
+
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			interrupt-parent = <&exti1>;
+			pins-are-numbered;
+			interrupts-extended =
+				<&exti1  0 0>, <&exti1  1 0>, <&exti1  2 0>, <&exti1  3 0>,
+				<&exti1  4 0>, <&exti1  5 0>, <&exti1  6 0>, <&exti1  7 0>,
+				<&exti1  8 0>, <&exti1  9 0>, <&exti1 10 0>, <&exti1 11 0>,
+				<&exti1 12 0>, <&exti1 13 0>, <&exti1 14 0>, <&exti1 15 0>,
+				<&exti2  0 0>, <&exti2  1 0>, <&exti2  2 0>, <&exti2  3 0>,
+				<&exti2  4 0>, <&exti2  5 0>, <&exti2  6 0>, <&exti2  7 0>,
+				<&exti2  8 0>, <&exti2  9 0>, <&exti2 10 0>, <&exti2 11 0>,
+				<&exti2 12 0>, <&exti2 13 0>, <&exti2 14 0>, <&exti2 15 0>;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		rtc: rtc@46000000 {
+			compatible = "st,stm32mp25-rtc";
+			reg = <0x46000000 0x400>;
+			clocks = <&scmi_clk CK_SCMI_RTC>,
+				 <&scmi_clk CK_SCMI_RTCCK>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti2 17 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x46010000 0x400>;
+			ranges;
+
+			nvram: nvram@46010100 {
+				compatible = "st,stm32mp25-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x46010100 0x200>;
+
+				boot_mode: tamp-bkp@180 {
+					reg = <0x180 0x4>;
+				};
+				rsc_tbl_addr: tamp-bkp@184 {
+					reg = <0x184 0x4>;
+				};
+				rsc_tbl_size: tamp-bkp@188 {
+					reg = <0x188 0x4>;
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			interrupt-parent = <&exti1>;
+			pins-are-numbered;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+		};
+
+		exti2: interrupt-controller@46230000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x46230000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 17  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 18  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 19  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 20  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 21  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 22  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 25  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 26  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 27  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 28  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 29  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 30  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 12  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 13  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 14  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 15  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 11  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 5   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 4   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 2   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
+		};
+
+		fmc: memory-controller@48200000 {
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+			#address-cells = <2>;
+			#size-cells = <1>;
+			clocks = <&scmi_clk CK_SCMI_FMC>;
+			resets = <&scmi_reset RST_SCMI_FMC>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+
+			nand-controller@4,0 {
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 0 0x62 0x00003101>,
+				       <&hpdma 0 0x62 0x00003110>,
+				       <&hpdma 1 0x22 0x00003113>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		a35ss_syscfg: syscon@48802000  {
+			compatible = "st,stm32mp25-a35ss-syscfg", "syscon";
+			reg = <0x48802000 0xac>;
+			status = "disabled";
+		};
+
+		cs_funnel: funnel@4a020000 {
+			compatible = "arm,coresight-dynamic-funnel", "arm,primecell";
+			reg = <0x4a020000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					funnel_in_port0: endpoint {
+						remote-endpoint = <&etm0_out_port>;
+					};
+				};
+
+				port@2 {
+					reg = <2>;
+					funnel_in_port2: endpoint {
+						remote-endpoint = <&stm_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					funnel_out_port: endpoint {
+						remote-endpoint = <&etf_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etf: etf@4a030000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a030000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					etf_in_port: endpoint {
+						remote-endpoint = <&funnel_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					etf_out_port: endpoint {
+						remote-endpoint = <&replicator_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etr: etr@4a040000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a040000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_BUS_ETR>, <&scmi_clk CK_SCMI_KER_ETR>;
+			clock-names = "apb_pclk", "atclk";
+			arm,max-burst-size = <3>;
+			arm,scatter-gather;
+			status = "disabled";
+
+			in-ports {
+				port {
+					etr_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port0>;
+					};
+				};
+			};
+		};
+
+		cs_tpiu: tpiu@4a050000 {
+			compatible = "arm,coresight-tpiu", "arm,primecell";
+			reg = <0x4a050000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_TPIU>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					tpiu_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port1>;
+					};
+				};
+			};
+		};
+
+		cs_stm: stm@4a080000 {
+			compatible = "arm,coresight-stm", "arm,primecell";
+			reg = <0x4a080000 0x1000>,
+			      <0x4a800000 0x400000>;
+			reg-names = "stm-base", "stm-stimulus-base";
+			clocks = <&scmi_clk CK_SCMI_BUS_STM>, <&scmi_clk CK_SCMI_KER_STM>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			out-ports {
+				port {
+					stm_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port2>;
+					};
+				};
+			};
+		};
+
+		cs_cti0: cti@4a090000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a090000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0 1>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <0 1>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etr>;
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-in-sigs = <2 3>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <2 3>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etf>;
+			};
+
+			trig-conns@2 {
+				reg = <2>;
+				arm,trig-out-sigs = <4 5>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_tpiu>;
+			};
+
+			trig-conns@3 {
+				reg = <3>;
+				arm,trig-in-sigs = <4 5 6 7>;
+				arm,trig-in-types = <STM_TOUT_SPTE
+						     STM_TOUT_SW
+						     STM_TOUT_HETE
+						     STM_ASYNCOUT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cti1: cti@4a0a0000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a0a0000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0>;
+				arm,trig-in-types = <GEN_IO>;
+				arm,trig-out-sigs = <0>;
+				arm,trig-out-types = <GEN_IO>;
+				arm,trig-conn-name = "dbtrgio";
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-out-sigs = <1 2>;
+				arm,trig-out-types = <STM_HWEVENT
+						      STM_HWEVENT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cpu_debug0: cpu-debug@4a210000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a210000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		cs_cti_cpu0: cti@4a220000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a220000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu0>;
+			arm,cs-dev-assoc = <&cs_etm0>;
+			status = "disabled";
+		};
+
+		cs_etm0: etm@4a240000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a240000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu0>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm0_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port0>;
+					};
+				};
+			};
+		};
+	};
+
+	mlahb: ahb@1 {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0xfffffffc>;
+		dma-ranges = <0x0 0x0 0x0 0xfffffffc>;
+
+		m33_rproc: m33@0 {
+			compatible = "st,stm32mp2-m33";
+			reg = <0 0>;
+			resets = <&scmi_reset RST_SCMI_C2_R>,
+				 <&scmi_reset RST_SCMI_C2_HOLDBOOT_R>;
+			reset-names = "mcu_rst", "hold_boot";
+			st,syscfg-cm-state = <&pwr 0x204 0x0000000c>;
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			nvmem-cells = <&rsc_tbl_addr>, <&rsc_tbl_size>;
+			nvmem-cell-names = "rsc-tbl-addr", "rsc-tbl-size";
+
+			status = "disabled";
+		};
+	};
+
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp253.dtsi b/arch/arm64/boot/dts/st/stm32mp253.dtsi
new file mode 100644
index 000000000..4e9568a56
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp253.dtsi
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp251.dtsi"
+
+/ {
+	cpus {
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD1>;
+			power-domain-names = "psci";
+		};
+	};
+
+	arm-pmu {
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>;
+	};
+
+	psci {
+		CPU_PD1: power-domain-cpu1 {
+			#power-domain-cells = <0>;
+			domain-idle-states =  <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+	};
+
+	timer {
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	soc@0 {
+		rifsc: rifsc@42080000 {
+			m_can1: can@402d0000 {
+				compatible = "bosch,m_can";
+				reg = <0x402d0000 0x400>, <0x40310000 0x1400>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_FDCAN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			m_can3: can@402f0000 {
+				compatible = "bosch,m_can";
+				reg = <0x402f0000 0x400>, <0x40310000 0x2800>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_FDCAN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			eth2: eth2@482d0000 {
+				compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+				reg = <0x482d0000 0x4000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti1 70 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ptp_ref",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc CK_ETH2_MAC>,
+					 <&rcc CK_ETH2_TX>,
+					 <&rcc CK_ETH2_RX>,
+					 <&rcc CK_KER_ETH2PTP>,
+					 <&rcc CK_ETH2_STP>,
+					 <&rcc CK_KER_ETH2>;
+				st,syscon = <&syscfg 0x3400 0xffffffff>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,txqos = <7>;
+				snps,rxqos = <7>;
+				snps,axi-config = <&stmmac_axi_config_2>;
+				snps,tso;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ETH2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+				snps,mtl-rx-config = <&mtl_rx_setup_2>;
+				snps,mtl-tx-config = <&mtl_tx_setup_2>;
+
+				stmmac_axi_config_2: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+
+				mtl_rx_setup_2: rx-queues-config {
+					snps,rx-queues-to-use = <2>;
+					queue0 {};
+					queue1 {};
+				};
+
+				mtl_tx_setup_2: tx-queues-config {
+					snps,tx-queues-to-use = <4>;
+					queue0 {};
+					queue1 {};
+					queue2 {};
+					queue3 {};
+				};
+			};
+		};
+
+		cs_cpu_debug1: cpu-debug@4a310000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a310000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+		};
+
+		cs_cti_cpu1: cti@4a320000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a320000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			arm,cs-dev-assoc = <&cs_etm1>;
+			status = "disabled";
+		};
+
+		cs_etm1: etm@4a340000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a340000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm1_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port1>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&cs_funnel {
+	in-ports {
+		port@1 {
+			reg = <1>;
+			funnel_in_port1: endpoint {
+				remote-endpoint = <&etm1_out_port>;
+			};
+		};
+	};
+};
+
+&optee {
+	interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp255.dtsi b/arch/arm64/boot/dts/st/stm32mp255.dtsi
new file mode 100644
index 000000000..918e1fa94
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp255.dtsi
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/power/stm32mp25-power-domains.h>
+#include "stm32mp253.dtsi"
+
+/ {
+	soc@0 {
+		rifsc: rifsc@42080000 {
+			dsi: dsi@48000000 {
+				compatible = "st,stm32mp25-dsi";
+				reg = <0x48000000 0x800>;
+				#clock-cells = <0>;
+				clocks = <&rcc CK_BUS_DSI>, <&rcc CK_KER_DSIPHY>,
+					 <&rcc CK_KER_LTDC>;
+				clock-names = "pclk", "ref", "px_clk";
+				resets = <&rcc DSI_R>;
+				reset-names = "apb";
+				feature-domains = <&rifsc STM32MP25_RIFSC_DSI_CMN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lvds: lvds@48060000 {
+				#clock-cells = <0>;
+				compatible = "st,stm32mp25-lvds";
+				reg = <0x48060000 0x2000>;
+				clocks = <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+				clock-names = "pclk", "ref";
+				resets = <&rcc LVDS_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LVDS_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			vdec: vdec@480d0000 {
+				compatible = "st,stm32mp25-vdec";
+				reg = <0x480d0000 0x3c8>;
+				resets = <&rcc VDEC_R>;
+				interrupt-names = "vdec";
+				interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+				clock-names = "vdec-clk";
+				clocks = <&rcc CK_BUS_VDEC>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_VDEC_ID>;
+				power-domains = <&CLUSTER_PD>;
+			};
+			venc: venc@480e0000 {
+				compatible = "st,stm32mp25-venc";
+				reg = <0x480e0000 0x800>;
+				reset-names = "venc-rst";
+				resets = <&rcc VENC_R>;
+				interrupt-names = "venc";
+				interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+				clock-names = "venc-clk";
+				clocks = <&rcc CK_BUS_VENC>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_VENC_ID>;
+				power-domains = <&CLUSTER_PD>;
+			};
+
+			gpu: gpu@48280000 {
+				compatible = "vivante,gc";
+				reg = <0x48280000 0x800>;
+				interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc GPU_R>;
+				clock-names = "axi", "core";
+				clocks = <&rcc CK_BUS_GPU>, <&rcc CK_KER_GPU>;
+				power-domains = <&scmi_devpd PD_SCMI_GPU>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_GPU_ID>;
+				status = "disabled";
+			};
+		};
+	};
+};
+
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>, <&syscfg 0>, <&lvds 0>;
+	clock-names = "bus", "ref", "lcd", "lvds";
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257.dtsi b/arch/arm64/boot/dts/st/stm32mp257.dtsi
new file mode 100644
index 000000000..f074157b2
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257.dtsi
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp255.dtsi"
+
+/ {
+	soc@0 {
+		rifsc: rifsc@42080000 {
+			switch0: ttt-sw@4c000000 {
+				#address-cells  = <1>;
+				#size-cells     = <1>;
+				compatible = "st,stm32-deip";
+				clock-names = "ethsw-bus-clk", "ethsw-clk",
+					      "ethswacmcfg-bus-clk", "ethswacmmsg-bus-clk";
+				clocks = <&rcc CK_BUS_ETHSW>,
+					 <&rcc CK_KER_ETHSW>,
+					 <&rcc CK_BUS_ETHSWACMCFG>,
+					 <&rcc CK_BUS_ETHSWACMMSG>;
+				st,syscon = <&syscfg 0x3800>;
+				ranges = <0x4c000000 0x4c000000 0x2000000>,
+					 <0x4b000000 0x4b000000 0xc0000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ETHSW_DEIP_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				deip_sw0: deip-sw@4c000000 {
+					compatible =  "ttt,deip-sw";
+					reg = <0x4c000000 0x2000000>;
+					interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				acm@4b000000 {
+					compatible = "ttt,acm-4.0";
+					reg = <0x4b000000 0x00400>,
+					      <0x4b010000 0x10000>,
+					      <0x4b030000 0x10000>,
+					      <0x4b050000 0x10000>,
+					      <0x4b060000 0x20000>,
+					      <0x4b080000 0x40000>;
+					reg-names = "CommonRegister",
+						    "Bypass1",
+						    "Bypass0",
+						    "Redundancy",
+						    "Scheduler",
+						    "Messagebuffer";
+					buffers = <32>;
+					ptp_worker = <&deip_sw0>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-dk-ca35tdcid-resmem.dtsi b/arch/arm64/boot/dts/st/stm32mp257f-dk-ca35tdcid-resmem.dtsi
new file mode 100644
index 000000000..7e2df3569
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-dk-ca35tdcid-resmem.dtsi
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 3/6/2024 11:20:05 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-dk.dts b/arch/arm64/boot/dts/st/stm32mp257f-dk.dts
new file mode 100644
index 000000000..0345d346e
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-dk.dts
@@ -0,0 +1,754 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxak-pinctrl.dtsi"
+#include "stm32mp257f-dk-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-DK Discovery Board";
+	compatible = "st,stm32mp257f-dk", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &usart1;
+		ethernet0 = &eth1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_ext_cec: clk-ext-cec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint1>;
+			};
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpioc 5 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpioc 11 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioh 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+		hdmi-pwr-supply = <&scmi_v5v_hdmi>;
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv7535_out>;
+			};
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x0>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpioi 4 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <0>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-DK";
+		dais = <&i2s2_port &mdf1_port0 &mdf1_port1>;
+		status = "okay";
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpiog 8 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&combophy {
+	st,ssc-on;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&csi2host {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi2host_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi2host_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi2host_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv7535_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_b>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_b>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioa 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_b>;
+	pinctrl-1 = <&i2c2_sleep_pins_b>;
+	i2c-scl-rising-time-ns = <108>;
+	i2c-scl-falling-time-ns = <12>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		reset-gpios = <&gpiob 1 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpiob 11 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi2host_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv7535: hdmi@3d {
+		compatible = "adi,adv7535";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		status = "okay";
+		adi,dsi-lanes = <4>;
+		clocks = <&clk_ext_cec>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiob>;
+		interrupts = <4 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiob 6 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv7535_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv7535_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv7535_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpioi 0 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <100000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_b>;
+	pinctrl-1 = <&i2s2_sleep_pins_b>;
+	status = "okay";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv7535_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	status = "okay";
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&mdf1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdf_cck0_pins_a>;
+	pinctrl-1 = <&mdf_cck0_sleep_pins_a>;
+	#clock-cells = <0>;
+	clock-output-names = "cck0";
+	clock-frequency = <1536000>;
+	status = "okay";
+
+	sitf6: sitf@380 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&mdf_sdi6_pins_a>;
+		pinctrl-1 = <&mdf_sdi6_sleep_pins_a>;
+		st,sitf-mode = "spi";
+		clocks = <&mdf1>;
+		status = "okay";
+	};
+
+	filter0: filter@84  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf6 0>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm0: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter0 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port0: port {
+				mdf_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	filter1: filter@104  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf6 1>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm1: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter1 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port1: port {
+				mdf_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_v5v_hdmi: regulator@21 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO5>;
+		regulator-name = "v5v_hdmi";
+	};
+	scmi_v5v_vconn: regulator@22 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO6>;
+		regulator-name = "v5v_vconn";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+/* Wifi */
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	cap-sdio-irq;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+&spi6 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi6_pins_a>;
+	pinctrl-1 = <&spi6_sleep_pins_a>;
+	status = "disabled";
+};
+
+/* Bluetooth */
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpiog 4 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&scmi_v3v3>;
+		vddio-supply = <&scmi_v3v3>;
+	};
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		phys            = <&usb2_phy2>, <&combophy PHY_TYPE_USB3>;
+		phy-names       = "usb2-phy", "usb3-phy";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-ev1-ca35tdcid-resmem.dtsi b/arch/arm64/boot/dts/st/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
new file mode 100644
index 000000000..fba1febc6
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 7/4/2023 9:06:24 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp257f-ev1.dts b/arch/arm64/boot/dts/st/stm32mp257f-ev1.dts
new file mode 100644
index 000000000..19393d47a
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp257f-ev1.dts
@@ -0,0 +1,825 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+#include "stm32mp257f-ev1-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-EV1 Evaluation Board";
+	compatible = "st,stm32mp257f-ev1", "st,stm32mp257";
+
+	aliases {
+		ethernet0 = &eth2;
+		ethernet1 = &eth1;
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &lpuart1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>,
+				 <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		cec_clock: cec-clock {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <12000000>;
+		};
+
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		pad_clk: pad-clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpiod 2 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpiog 8 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioj 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv753x_out>;
+			};
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x0>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpiog 15 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 5 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-EV1";
+		dais = <&i2s2_port>;
+		status = "disabled";
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&combophy {
+	clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>, <&pad_clk>;
+	clock-names = "apb-clk", "ker-clk", "pad-clk";
+	st,rx_equalizer = <1>;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&cs_cpu_debug0 {
+	status = "okay";
+};
+
+&cs_cpu_debug1 {
+	status = "okay";
+};
+
+&cs_cti0 {
+	status = "okay";
+};
+
+&cs_cti1 {
+	status = "okay";
+};
+
+&cs_cti_cpu0 {
+	status = "okay";
+};
+
+&cs_cti_cpu1 {
+	status = "okay";
+};
+
+&cs_etf {
+	status = "okay";
+};
+
+&cs_etm0 {
+	status = "okay";
+};
+
+&cs_etm1 {
+	status = "okay";
+};
+
+&cs_etr {
+	status = "okay";
+};
+
+&cs_funnel {
+	status = "okay";
+};
+
+&cs_replicator {
+	status = "okay";
+};
+
+&cs_stm {
+	status = "okay";
+};
+
+&cs_tpiu {
+	status = "okay";
+};
+
+&csi2host {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi2host_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi2host_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi2host_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv753x_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_a &eth1_mdio_pins_a>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_a &eth1_mdio_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-clk-sel;
+	snps,ext-systime;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@4 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioj 9 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <4>;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rgmii_pins_a>;
+	pinctrl-1 = <&eth2_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth2>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth2: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpiog 6 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <13>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		reset-gpios = <&gpioi 7 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpioi 0 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi2host_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv753x: hdmi@3d {
+		/*
+		 * With MB1232 board, use "adi,adv7533" (1080p30)
+		 * With MB1752 board, use "adi,adv7535" (1080p60)
+		 */
+		compatible = "adi,adv7533";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		clocks = <&cec_clock>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiod>;
+		interrupts = <10 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+		adi,dsi-lanes = <4>;
+		reset-gpios = <&gpiog 14 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv753x_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv753x_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv753x_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiog 14 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <57>;
+	i2c-scl-falling-time-ns = <7>;
+	clock-frequency = <400000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_a>;
+	pinctrl-1 = <&i2s2_sleep_pins_a>;
+	status = "disabled";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv753x_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&lpuart1 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&lpuart1_pins_a>;
+	pinctrl-1 = <&lpuart1_idle_pins_a>;
+	pinctrl-2 = <&lpuart1_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	wakeup-source;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&ltdc {
+	default-on;
+	rotation-memory = <&ltdc_sec_rotation>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	default-on;
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&m_can3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can3_pins_a>;
+	pinctrl-1 = <&m_can3_sleep_pins_a>;
+	status = "okay";
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&ommanager {
+	memory-region = <&mm_ospi1>;
+	memory-region-names = "mm_ospi1";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ospi_port1_clk_pins_a
+		     &ospi_port1_io03_pins_a
+		     &ospi_port1_cs0_pins_a>;
+	pinctrl-1 = <&ospi_port1_clk_sleep_pins_a
+		     &ospi_port1_io03_sleep_pins_a
+		     &ospi_port1_cs0_sleep_pins_a>;
+	status = "okay";
+
+	spi@40430000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		memory-region = <&mm_ospi1>;
+		status = "okay";
+
+		flash0: flash@0 {
+			compatible = "jedec,spi-nor";
+			reg = <0>;
+			spi-rx-bus-width = <4>;
+			spi-tx-bus-width = <4>;
+			spi-max-frequency = <84000000>;
+		};
+	};
+};
+
+&pcie_ep {
+	pinctrl-names = "default", "init";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	status = "disabled";
+};
+
+&pcie_rc {
+	pinctrl-names = "default", "init", "sleep";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	pinctrl-2 = <&pcie_sleep_pins_a>;
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	wakeup-source;
+	wake-gpios = <&gpioh 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	status = "disabled";
+};
+
+&spi3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi3_pins_a>;
+	pinctrl-1 = <&spi3_sleep_pins_a>;
+	status = "disabled";
+};
+
+&spi8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi8_pins_a>;
+	pinctrl-1 = <&spi8_sleep_pins_a>;
+	status = "disabled";
+};
+
+&switch0 {
+	status = "disabled";
+	pinctrl-0 = <&eth1_rgmii_pins_a>, <&eth3_rgmii_pins_a>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_a>, <&eth3_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii";
+	st,ethsw-internal-125;
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ehci: usb@482f0000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		/* onboard HUB */
+		hub@1 {
+			compatible = "usb424,2514";
+			reg = <1>;
+			vdd-supply = <&scmi_v3v3>;
+		};
+	};
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		maximum-speed = "high-speed";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xc.dtsi b/arch/arm64/boot/dts/st/stm32mp25xc.dtsi
new file mode 100644
index 000000000..8d6ae78f5
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xc.dtsi
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP1_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	cryp2: crypto@42040000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42040000 0x1000>;
+		interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP2>;
+		resets = <&rcc CRYP2_R>;
+		dmas = <&hpdma 140 0x40 0x3021>,
+		       <&hpdma 141 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP2_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xf.dtsi b/arch/arm64/boot/dts/st/stm32mp25xf.dtsi
new file mode 100644
index 000000000..8d6ae78f5
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xf.dtsi
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP1_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	cryp2: crypto@42040000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42040000 0x1000>;
+		interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP2>;
+		resets = <&rcc CRYP2_R>;
+		dmas = <&hpdma 140 0x40 0x3021>,
+		       <&hpdma 141 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP2_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi
new file mode 100644
index 000000000..abdbc7aeb
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xxai-pinctrl.dtsi
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AI>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@442d0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@442e0000 {
+		status = "okay";
+		ngpios = <8>;
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi
new file mode 100644
index 000000000..2e0d4d349
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xxak-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AK>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi b/arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi
new file mode 100644
index 000000000..2406e9725
--- /dev/null
+++ b/arch/arm64/boot/dts/st/stm32mp25xxal-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AL>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm64/configs/fragment-01-defconfig-cleanup.config b/arch/arm64/configs/fragment-01-defconfig-cleanup.config
new file mode 100644
index 000000000..1a4b31f86
--- /dev/null
+++ b/arch/arm64/configs/fragment-01-defconfig-cleanup.config
@@ -0,0 +1,50 @@
+#  ALPHABETICALLY SORTED: $LC_ALL=C sort fragment-01-defconfig-cleanup.config -o fragment-01-defconfig-cleanup.config
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_APPLE is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCMBCA is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_BRCMSTB is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_INTEL_SOCFPGA is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_KEEMBAY is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+# CONFIG_ARCH_LG1K is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_NPCM is not set
+# CONFIG_ARCH_NXP is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S32 is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SYNQUACER is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_TESLA_FSD is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_THUNDER2 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_VISCONTI is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_DRM_FBDEV_EMULATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+# CONFIG_PAGE_POOL_STATS is not set
diff --git a/arch/arm64/configs/fragment-02-defconfig-addons.config b/arch/arm64/configs/fragment-02-defconfig-addons.config
new file mode 100644
index 000000000..00d70ac85
--- /dev/null
+++ b/arch/arm64/configs/fragment-02-defconfig-addons.config
@@ -0,0 +1,130 @@
+#  ALPHABETICALLY SORTED: $LC_ALL=C sort fragment-02-defconfig-addons.config -o fragment-02-defconfig-addons.config
+CONFIG_ARCH_STM32=y
+CONFIG_ARM_SCMI_CPUFREQ=y
+CONFIG_ARM_SMC_WATCHDOG=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_BT_HS=y
+CONFIG_BT_LE=y
+CONFIG_CAN_M_CAN=m
+CONFIG_CAN_M_CAN_PLATFORM=m
+CONFIG_CLKSRC_STM32_LP=y
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_CPU_DEBUG=y
+CONFIG_CORESIGHT_CTI=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+CONFIG_CORESIGHT_SINK_TPIU=y
+CONFIG_CORESIGHT_SOURCE_ETM4X=y
+CONFIG_CORESIGHT_STM=y
+CONFIG_COUNTER=m
+CONFIG_CRYPTO_DEV_STM32_CRC=m
+CONFIG_CRYPTO_DEV_STM32_CRYP=m
+CONFIG_CRYPTO_DEV_STM32_HASH=m
+CONFIG_DRM=y
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_DW_MIPI_DSI=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_MIPI_DSI=y
+CONFIG_DRM_PANEL=y
+CONFIG_DRM_PANEL_BRIDGE=y
+CONFIG_DRM_PANEL_LVDS=y
+CONFIG_DRM_PANEL_RAYDIUM_RM68200=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_SIMPLEDRM=y
+CONFIG_DRM_STM=y
+CONFIG_DRM_STM_DSI=y
+CONFIG_DRM_STM_LVDS=y
+CONFIG_DWMAC_GENERIC=y
+CONFIG_DWMAC_STM32=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_GENERIC_IRQ_DEBUGFS=y
+CONFIG_HDMI=y
+CONFIG_I2C_RPMSG=m
+CONFIG_I2C_STM32F7=y
+CONFIG_I3C=y
+CONFIG_IGC=m
+CONFIG_IIO_STM32_LPTIMER_TRIGGER=m
+CONFIG_IIO_STM32_TIMER_TRIGGER=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_JFFS2_FS=y
+CONFIG_MEDIA_TEST_SUPPORT=y
+CONFIG_MFD_STM32_LPTIMER=m
+CONFIG_MFD_STM32_TIMERS=m
+CONFIG_MFD_WM8994=m
+CONFIG_MTD_HYPERBUS=y
+CONFIG_MTD_NAND_STM32_FMC2=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_UBI=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_VLAN=m
+CONFIG_NET_CLS_U32=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_SKBPRIO=m
+CONFIG_NVMEM_REBOOT_MODE=y
+CONFIG_NVMEM_STM32_ROMEM=y
+CONFIG_NVMEM_STM32_TAMP=y
+CONFIG_OF_OVERLAY=y
+CONFIG_PCIE_STM32=y
+CONFIG_PCIE_STM32_EP=y
+CONFIG_PHY_STM32_COMBOPHY=y
+CONFIG_PHY_STM32_USB2PHY=y
+CONFIG_PTM=y
+CONFIG_PWM_STM32=m
+CONFIG_PWM_STM32_LP=m
+CONFIG_REGULATOR_ARM_SCMI=y
+CONFIG_RPMSG_CHAR=m
+CONFIG_RPMSG_CTRL=m
+CONFIG_RPMSG_IRQ=m
+CONFIG_RPMSG_TTY=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_RTC_DRV_STM32=y
+CONFIG_SENSORS_MR75203=y
+CONFIG_SERIAL_STM32=y
+CONFIG_SERIAL_STM32_CONSOLE=y
+CONFIG_SND_SOC_CS42L51=m
+CONFIG_SND_SOC_CS42L51_I2C=m
+CONFIG_SND_SOC_STM32_I2S=m
+CONFIG_SND_SOC_STM32_MDF=m
+CONFIG_SND_SOC_STM32_SAI=m
+CONFIG_SND_SOC_STM32_SPDIFRX=m
+CONFIG_SND_SOC_WM8994=m
+CONFIG_SPI_STM32=m
+CONFIG_SPI_STM32_OSPI=y
+CONFIG_STM32_ADC=m
+CONFIG_STM32_ADC_CORE=m
+CONFIG_STM32_DMA3=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_STM32_HYPERBUS=y
+CONFIG_STM32_I3C_MASTER=m
+CONFIG_STM32_IPCC=y
+CONFIG_STM32_LPTIMER_CNT=m
+CONFIG_STM32_MDF_ADC=m
+CONFIG_STM32_MDF_CORE=m
+CONFIG_STM32_OMI=y
+CONFIG_STM32_OMM=y
+CONFIG_STM32_RPROC=y
+CONFIG_STM32_TIMER_CNT=m
+CONFIG_STMMAC_ETH=y
+CONFIG_STMMAC_PLATFORM=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_ILI210X=y
+CONFIG_TYPEC_UCSI=m
+CONFIG_UBIFS_FS=y
+CONFIG_UCSI_STM32G0=m
+CONFIG_USB_DWC3_STM32=y
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_ONBOARD_HUB=y
+CONFIG_USB_STM32_USBH=y
+CONFIG_V4L_TEST_DRIVERS=y
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_VIDEO_HANTRO=m
+CONFIG_VIDEO_HANTRO_STM32MP25=y
+CONFIG_VIDEO_IMX335=m
+CONFIG_VIDEO_STM32_CSI2HOST=m
+CONFIG_VIDEO_STM32_DCMI=m
+CONFIG_VIDEO_STM32_DCMIPP=m
+CONFIG_VIDEO_VIVID=m
diff --git a/crypto/ahash.c b/crypto/ahash.c
index c2ca631a1..477761afd 100644
--- a/crypto/ahash.c
+++ b/crypto/ahash.c
@@ -570,7 +570,6 @@ static int ahash_prepare_alg(struct ahash_alg *alg)
 	struct crypto_alg *base = &alg->halg.base;
 
 	if (alg->halg.digestsize > HASH_MAX_DIGESTSIZE ||
-	    alg->halg.statesize > HASH_MAX_STATESIZE ||
 	    alg->halg.statesize == 0)
 		return -EINVAL;
 
diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c
index 1d017ec5c..63af72e19 100644
--- a/crypto/algif_hash.c
+++ b/crypto/algif_hash.c
@@ -235,24 +235,31 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags,
 	struct alg_sock *ask = alg_sk(sk);
 	struct hash_ctx *ctx = ask->private;
 	struct ahash_request *req = &ctx->req;
-	char state[HASH_MAX_STATESIZE];
+	struct crypto_ahash *tfm;
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
+	char *state;
 	bool more;
 	int err;
 
+	tfm = crypto_ahash_reqtfm(req);
+	state = kmalloc(crypto_ahash_statesize(tfm), GFP_KERNEL);
+	err = -ENOMEM;
+	if (!state)
+		goto out;
+
 	lock_sock(sk);
 	more = ctx->more;
 	err = more ? crypto_ahash_export(req, state) : 0;
 	release_sock(sk);
 
 	if (err)
-		return err;
+		goto out_free_state;
 
 	err = af_alg_accept(ask->parent, newsock, kern);
 	if (err)
-		return err;
+		goto out_free_state;
 
 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
@@ -260,7 +267,7 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags,
 	ctx2->more = more;
 
 	if (!more)
-		return err;
+		goto out_free_state;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {
@@ -268,6 +275,10 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags,
 		sock_put(sk2);
 	}
 
+out_free_state:
+	kfree_sensitive(state);
+
+out:
 	return err;
 }
 
diff --git a/crypto/shash.c b/crypto/shash.c
index 4c88e63b3..7d934e7a6 100644
--- a/crypto/shash.c
+++ b/crypto/shash.c
@@ -532,8 +532,7 @@ static int shash_prepare_alg(struct shash_alg *alg)
 	struct crypto_alg *base = &alg->base;
 
 	if (alg->digestsize > HASH_MAX_DIGESTSIZE ||
-	    alg->descsize > HASH_MAX_DESCSIZE ||
-	    alg->statesize > HASH_MAX_STATESIZE)
+	    alg->descsize > HASH_MAX_DESCSIZE)
 		return -EINVAL;
 
 	if ((alg->export && !alg->import) || (alg->import && !alg->export))
diff --git a/drivers/base/power/common.c b/drivers/base/power/common.c
index 72115917e..299496e13 100644
--- a/drivers/base/power/common.c
+++ b/drivers/base/power/common.c
@@ -167,6 +167,115 @@ struct device *dev_pm_domain_attach_by_name(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_name);
 
+/**
+ * dev_pm_domain_attach_list - Associate a device with its PM domains.
+ * @dev: The device used to lookup the PM domains for.
+ * @data: The data used for attaching to the PM domains.
+ * @list: An out-parameter with an allocated list of attached PM domains.
+ *
+ * This function helps to attach a device to its multiple PM domains. The
+ * caller, which is typically a driver's probe function, may provide a list of
+ * names for the PM domains that we should try to attach the device to, but it
+ * may also provide an empty list, in case the attach should be done for all of
+ * the available PM domains.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ *
+ * Returns the number of attached PM domains or a negative error code in case of
+ * a failure. Note that, to detach the list of PM domains, the driver shall call
+ * dev_pm_domain_detach_list(), typically during the remove phase.
+ */
+int dev_pm_domain_attach_list(struct device *dev,
+			      const struct dev_pm_domain_attach_data *data,
+			      struct dev_pm_domain_list **list)
+{
+	struct device_node *np = dev->of_node;
+	struct dev_pm_domain_list *pds;
+	struct device *pd_dev = NULL;
+	int ret, i, num_pds = 0;
+	bool by_id = true;
+	u32 pd_flags = data ? data->pd_flags : 0;
+	u32 link_flags = pd_flags & PD_FLAG_NO_DEV_LINK ? 0 :
+			DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME;
+
+	if (dev->pm_domain)
+		return -EEXIST;
+
+	/* For now this is limited to OF based platforms. */
+	if (!np)
+		return 0;
+
+	if (data && data->pd_names) {
+		num_pds = data->num_pd_names;
+		by_id = false;
+	} else {
+		num_pds = of_count_phandle_with_args(np, "power-domains",
+						     "#power-domain-cells");
+	}
+
+	if (num_pds <= 0)
+		return 0;
+
+	pds = devm_kzalloc(dev, sizeof(*pds), GFP_KERNEL);
+	if (!pds)
+		return -ENOMEM;
+
+	pds->pd_devs = devm_kcalloc(dev, num_pds, sizeof(*pds->pd_devs),
+				    GFP_KERNEL);
+	if (!pds->pd_devs)
+		return -ENOMEM;
+
+	pds->pd_links = devm_kcalloc(dev, num_pds, sizeof(*pds->pd_links),
+				     GFP_KERNEL);
+	if (!pds->pd_links)
+		return -ENOMEM;
+
+	if (link_flags && pd_flags & PD_FLAG_DEV_LINK_ON)
+		link_flags |= DL_FLAG_RPM_ACTIVE;
+
+	for (i = 0; i < num_pds; i++) {
+		if (by_id)
+			pd_dev = dev_pm_domain_attach_by_id(dev, i);
+		else
+			pd_dev = dev_pm_domain_attach_by_name(dev,
+							data->pd_names[i]);
+		if (IS_ERR_OR_NULL(pd_dev)) {
+			ret = pd_dev ? PTR_ERR(pd_dev) : -ENODEV;
+			goto err_attach;
+		}
+
+		if (link_flags) {
+			struct device_link *link;
+
+			link = device_link_add(dev, pd_dev, link_flags);
+			if (!link) {
+				ret = -ENODEV;
+				goto err_link;
+			}
+
+			pds->pd_links[i] = link;
+		}
+
+		pds->pd_devs[i] = pd_dev;
+	}
+
+	pds->num_pds = num_pds;
+	*list = pds;
+	return num_pds;
+
+err_link:
+	dev_pm_domain_detach(pd_dev, true);
+err_attach:
+	while (--i >= 0) {
+		if (pds->pd_links[i])
+			device_link_del(pds->pd_links[i]);
+		dev_pm_domain_detach(pds->pd_devs[i], true);
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_attach_list);
+
 /**
  * dev_pm_domain_detach - Detach a device from its PM domain.
  * @dev: Device to detach.
@@ -187,6 +296,31 @@ void dev_pm_domain_detach(struct device *dev, bool power_off)
 }
 EXPORT_SYMBOL_GPL(dev_pm_domain_detach);
 
+/**
+ * dev_pm_domain_detach_list - Detach a list of PM domains.
+ * @list: The list of PM domains to detach.
+ *
+ * This function reverse the actions from dev_pm_domain_attach_list().
+ * Typically it should be invoked during the remove phase from drivers.
+ *
+ * Callers must ensure proper synchronization of this function with power
+ * management callbacks.
+ */
+void dev_pm_domain_detach_list(struct dev_pm_domain_list *list)
+{
+	int i;
+
+	if (!list)
+		return;
+
+	for (i = 0; i < list->num_pds; i++) {
+		if (list->pd_links[i])
+			device_link_del(list->pd_links[i]);
+		dev_pm_domain_detach(list->pd_devs[i], true);
+	}
+}
+EXPORT_SYMBOL_GPL(dev_pm_domain_detach_list);
+
 /**
  * dev_pm_domain_start - Start the device through its PM domain.
  * @dev: Device to start.
diff --git a/drivers/bus/Kconfig b/drivers/bus/Kconfig
index 7bfe998f3..441c531ce 100644
--- a/drivers/bus/Kconfig
+++ b/drivers/bus/Kconfig
@@ -163,6 +163,15 @@ config QCOM_SSC_BLOCK_BUS
 	  i2c/spi/uart controllers, a hexagon core, and a clock controller
 	  which provides clocks for the above.
 
+config STM32_SYS_BUS
+	bool "STM32 System bus controller"
+	depends on ARCH_STM32
+	default MACH_STM32MP157 || MACH_STM32MP13 || MACH_STM32MP25
+	help
+	  Say y to enable device access right verification before device probing.
+	  If access not granted, device won't be probed and an error message will
+	  provide the reason.
+
 config SUN50I_DE2_BUS
 	bool "Allwinner A64 DE2 Bus Driver"
 	  default ARM64
diff --git a/drivers/bus/Makefile b/drivers/bus/Makefile
index d90eed189..b15fdc42d 100644
--- a/drivers/bus/Makefile
+++ b/drivers/bus/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_OMAP_INTERCONNECT)	+= omap_l3_smx.o omap_l3_noc.o
 obj-$(CONFIG_OMAP_OCP2SCP)	+= omap-ocp2scp.o
 obj-$(CONFIG_QCOM_EBI2)		+= qcom-ebi2.o
 obj-$(CONFIG_QCOM_SSC_BLOCK_BUS)	+= qcom-ssc-block-bus.o
+obj-$(CONFIG_STM32_SYS_BUS)	+= stm32_sys_bus.o
 obj-$(CONFIG_SUN50I_DE2_BUS)	+= sun50i-de2.o
 obj-$(CONFIG_SUNXI_RSB)		+= sunxi-rsb.o
 obj-$(CONFIG_OF)		+= simple-pm-bus.o
diff --git a/drivers/bus/stm32_sys_bus.c b/drivers/bus/stm32_sys_bus.c
new file mode 100644
index 000000000..0ee643d9a
--- /dev/null
+++ b/drivers/bus/stm32_sys_bus.c
@@ -0,0 +1,701 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include "stm32_sys_bus.h"
+
+/* ETZPC peripheral as firewall bus */
+/* ETZPC registers */
+#define ETZPC_DECPROT			0x10
+
+/* ETZPC miscellaneous */
+#define ETZPC_PROT_MASK			GENMASK(1, 0)
+#define ETZPC_PROT_A7NS			0x3
+#define ETZPC_DECPROT_SHIFT		1
+
+#define IDS_PER_DECPROT_REGS		16
+#define STM32MP15_ETZPC_ENTRIES		96
+#define STM32MP13_ETZPC_ENTRIES		64
+
+/* RIFSC peripheral as firewall bus */
+/* RIFSC offset register */
+#define RIFSC_RISC_SECCFGR0		0x10
+#define RIFSC_RISC_PRIVCFGR0		0x30
+#define RIFSC_RISC_PER0_CIDCFGR		0x100
+#define RIFSC_RISC_PER0_SEMCR		0x104
+
+/*
+ * SEMCR register
+ */
+#define SEMCR_MUTEX			BIT(0)
+
+/* RIFSC miscellaneous */
+#define RIFSC_RISC_SCID_MASK		GENMASK(6, 4)
+#define RIFSC_RISC_SEMWL_MASK		GENMASK(23, 16)
+#define RIFSC_RISC_PER_ID_MASK		GENMASK(31, 24)
+
+#define RIFSC_RISC_PERx_CID_MASK	(RIFSC_RISC_CFEN_MASK | \
+					 RIFSC_RISC_SEM_EN_MASK | \
+					 RIFSC_RISC_SCID_MASK | \
+					 RIFSC_RISC_SEML_MASK)
+
+#define IDS_PER_RISC_SEC_PRIV_REGS	32
+
+/* RIF miscellaneous */
+/*
+ * CIDCFGR register fields
+ */
+#define CIDCFGR_CFEN			BIT(0)
+#define CIDCFGR_SEMEN			BIT(1)
+#define CIDCFGR_SEMWL(x)		BIT(RIFSC_RISC_SEML_SHIFT + (x))
+
+#define SEMWL_SHIFT			16
+
+/* Compartiment IDs */
+#define RIF_CID0			0x0
+#define RIF_CID1			0x1
+
+#define STM32MP25_RIFSC_ENTRIES		178
+
+struct sys_bus_data;
+
+struct stm32_sys_bus_match_data {
+	const u32 *map_table;
+	unsigned int max_entries;
+	int (*sys_bus_get_access)(struct sys_bus_data *pdata, struct device_node *np);
+#ifdef CONFIG_DEBUG_FS
+	const char *bus_name;
+#endif
+};
+
+struct sys_bus_data {
+	struct stm32_sys_bus_match_data *pconf;
+	void __iomem *sys_bus_base;
+	struct device *dev;
+#ifdef CONFIG_DEBUG_FS
+	struct rifsc_master_debug_data *m_dbg_data;
+	struct rifsc_dev_debug_data *d_dbg_data;
+#endif
+};
+
+static struct sys_bus_data *bus_data;
+
+#ifdef CONFIG_DEBUG_FS
+#define STM32MP25_RIFSC_NAWARE_ENTRIES	128
+#define STM32MP25_RIFSC_MASTER_ENTRIES	16
+
+#define RIFSC_RIMC_ATTR0	0xC10
+
+#define RIFSC_RIMC_CIDSEL	BIT(2)
+#define RIFSC_RIMC_MCID_MASK	GENMASK(6, 4)
+#define RIFSC_RIMC_MSEC		BIT(8)
+#define RIFSC_RIMC_MPRIV	BIT(9)
+
+static const char *stm32mp25_rif_master_names[STM32MP25_RIFSC_MASTER_ENTRIES] = {
+	"ETR",
+	"SDMMC1",
+	"SDMMC2",
+	"SDMMC3",
+	"USB3DR",
+	"USBH",
+	"ETH1",
+	"ETH2",
+	"PCIE",
+	"GPU",
+	"DMCIPP",
+	"LTDC_L1/L2",
+	"LTDC_L3",
+	"LTDC_ROT",
+	"VDEC",
+	"VENC"
+};
+
+static const char *stm32mp25_rif_dev_names[STM32MP25_RIFSC_NAWARE_ENTRIES] = {
+	"TIM1",
+	"TIM2",
+	"TIM3",
+	"TIM4",
+	"TIM5",
+	"TIM6",
+	"TIM7",
+	"TIM8",
+	"TIM10",
+	"TIM11",
+	"TIM12",
+	"TIM13",
+	"TIM14",
+	"TIM15",
+	"TIM16",
+	"TIM17",
+	"TIM20",
+	"LPTIM1",
+	"LPTIM2",
+	"LPTIM3",
+	"LPTIM4",
+	"LPTIM5",
+	"SPI1",
+	"SPI2",
+	"SPI3",
+	"SPI4",
+	"SPI5",
+	"SPI6",
+	"SPI7",
+	"SPI8",
+	"SPDIFRX",
+	"USART1",
+	"USART2",
+	"USART3",
+	"UART4",
+	"UART5",
+	"USART6",
+	"UART7",
+	"UART8",
+	"UART9",
+	"LPUART1",
+	"I2C1",
+	"I2C2",
+	"I2C3",
+	"I2C4",
+	"I2C5",
+	"I2C6",
+	"I2C7",
+	"I2C8",
+	"SAI1",
+	"SAI2",
+	"SAI3",
+	"SAI4",
+	"RESERVED",
+	"MDF1",
+	"ADF1",
+	"FDCAN",
+	"HDP",
+	"ADC12",
+	"ADC3",
+	"ETH1",
+	"ETH2",
+	"RESERVED",
+	"USBH",
+	"RESERVED",
+	"RESERVED",
+	"USB3DR",
+	"COMBOPHY",
+	"PCIE",
+	"UCPD1",
+	"ETHSW_DEIP",
+	"ETHSW_ACM_CF",
+	"ETHSW_ACM_MSGBU",
+	"STGEN",
+	"OCTOSPI1",
+	"OCTOSPI2",
+	"SDMMC1",
+	"SDMMC2",
+	"SDMMC3",
+	"GPU",
+	"LTDC_CMN",
+	"DSI_CMN",
+	"RESERVED",
+	"RESERVED",
+	"LVDS",
+	"RESERVED",
+	"CSI",
+	"DCMIPP",
+	"DCMI_PSSI",
+	"VDEC",
+	"VENC",
+	"RESERVED",
+	"RNG",
+	"PKA",
+	"SAES",
+	"HASH",
+	"CRYP1",
+	"CRYP2",
+	"IWDG1",
+	"IWDG2",
+	"IWDG3",
+	"IWDG4",
+	"IWDG5",
+	"WWDG1",
+	"WWDG2",
+	"RESERVED",
+	"VREFBUF",
+	"DTS",
+	"RAMCFG",
+	"CRC",
+	"SERC",
+	"OCTOSPIM",
+	"GICV2M",
+	"RESERVED",
+	"I3C1",
+	"I3C2",
+	"I3C3",
+	"I3C4",
+	"ICACHE_DCACHE",
+	"LTDC_L0L1",
+	"LTDC_L2",
+	"LTDC_ROT",
+	"DSI_TRIG",
+	"DSI_RDFIFO",
+	"RESERVED",
+	"OTFDEC1",
+	"OTFDEC2",
+	"IAC",
+};
+
+struct rifsc_dev_debug_data {
+	char dev_name[15];
+	u8 dev_cid;
+	u8 dev_sem_cids;
+	u8 dev_id;
+	bool dev_cid_filt_en;
+	bool dev_sem_en;
+	bool dev_priv;
+	bool dev_sec;
+};
+
+struct rifsc_master_debug_data {
+	char m_name[11];
+	u8 m_cid;
+	bool cidsel;
+	bool m_sec;
+	bool m_priv;
+};
+
+static void stm32_rifsc_fill_master_dbg_entry(struct sys_bus_data *pdata,
+					      struct rifsc_master_debug_data *dbg_entry,
+					      int i)
+{
+	u32 rimc_attr = readl_relaxed(pdata->sys_bus_base + RIFSC_RIMC_ATTR0 + 0x4 * i);
+
+	snprintf(dbg_entry->m_name, sizeof(dbg_entry->m_name), "%s", stm32mp25_rif_master_names[i]);
+	dbg_entry->m_cid = FIELD_GET(RIFSC_RIMC_MCID_MASK, rimc_attr);
+	dbg_entry->cidsel = rimc_attr & RIFSC_RIMC_CIDSEL;
+	dbg_entry->m_sec = rimc_attr & RIFSC_RIMC_MSEC;
+	dbg_entry->m_priv = rimc_attr & RIFSC_RIMC_MPRIV;
+}
+
+static void stm32_rifsc_fill_dev_dbg_entry(struct sys_bus_data *pdata,
+					   struct rifsc_dev_debug_data *dbg_entry,
+					   int i)
+{
+	u32 cid_cfgr, sec_cfgr, priv_cfgr;
+	u8 reg_id = i / IDS_PER_RISC_SEC_PRIV_REGS;
+	u8 reg_offset = i % IDS_PER_RISC_SEC_PRIV_REGS;
+
+	cid_cfgr = readl_relaxed(pdata->sys_bus_base + RIFSC_RISC_PER0_CIDCFGR + 0x8 * i);
+	sec_cfgr = readl_relaxed(pdata->sys_bus_base + RIFSC_RISC_SECCFGR0 + 0x4 * reg_id);
+	priv_cfgr = readl_relaxed(pdata->sys_bus_base + RIFSC_RISC_PRIVCFGR0 + 0x4 * reg_id);
+
+	snprintf(dbg_entry->dev_name, sizeof(dbg_entry->dev_name), "%s",
+		 stm32mp25_rif_dev_names[i]);
+	dbg_entry->dev_id = i;
+	dbg_entry->dev_cid_filt_en = cid_cfgr & CIDCFGR_CFEN;
+	dbg_entry->dev_sem_en = cid_cfgr & CIDCFGR_SEMEN;
+	dbg_entry->dev_cid = FIELD_GET(RIFSC_RISC_SCID_MASK, cid_cfgr);
+	dbg_entry->dev_sem_cids = FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_cfgr);
+	dbg_entry->dev_sec = sec_cfgr & BIT(reg_offset) ?  true : false;
+	dbg_entry->dev_priv = priv_cfgr & BIT(reg_offset) ?  true : false;
+}
+
+static int stm32_rifsc_conf_dump_show(struct seq_file *s, void *data)
+{
+	struct sys_bus_data *debug_data = (struct sys_bus_data *)s->private;
+	int i;
+
+	seq_puts(s, "\n=============================================\n");
+	seq_puts(s, "                 RIFSC dump\n");
+	seq_puts(s, "=============================================\n\n");
+
+	seq_puts(s, "\n=============================================\n");
+	seq_puts(s, "                 RISUP dump\n");
+	seq_puts(s, "=============================================\n");
+
+	seq_printf(s, "\n| %-15s |", "Peripheral name");
+	seq_puts(s, "| Firewall ID |");
+	seq_puts(s, "| N/SECURE |");
+	seq_puts(s, "| N/PRIVILEGED |");
+	seq_puts(s, "| CID filtering |");
+	seq_puts(s, "| Semaphore mode |");
+	seq_puts(s, "| SCID |");
+	seq_printf(s, "| %7s |\n", "SEMWL");
+
+	for (i = 0; i < STM32MP25_RIFSC_NAWARE_ENTRIES; i++) {
+		struct rifsc_dev_debug_data d_dbg_entry;
+
+		stm32_rifsc_fill_dev_dbg_entry(debug_data, &d_dbg_entry, i);
+
+		seq_printf(s, "| %-15s |", d_dbg_entry.dev_name);
+		seq_printf(s, "| %-11d |", d_dbg_entry.dev_id);
+		seq_printf(s, "| %-8s |", d_dbg_entry.dev_sec ? "SEC" : "NSEC");
+		seq_printf(s, "| %-12s |", d_dbg_entry.dev_priv ? "PRIV" : "NPRIV");
+		seq_printf(s, "| %-13s |",
+			   d_dbg_entry.dev_cid_filt_en ? "enabled" : "disabled");
+		seq_printf(s, "| %-14s |",
+			   d_dbg_entry.dev_sem_en ? "enabled" : "disabled");
+		seq_printf(s, "| %-4d |", d_dbg_entry.dev_cid);
+		seq_printf(s, "| %#-7x |\n", d_dbg_entry.dev_sem_cids);
+	}
+
+	seq_puts(s, "\n=============================================\n");
+	seq_puts(s, "                  RIMU dump\n");
+	seq_puts(s, "=============================================\n");
+
+	seq_puts(s, "| Master name |");
+	seq_puts(s, "| CIDSEL |");
+	seq_puts(s, "| MCID |");
+	seq_puts(s, "| N/SECURE |");
+	seq_puts(s, "| N/PRIVILEGED |\n");
+
+	for (i = 0; i < STM32MP25_RIFSC_MASTER_ENTRIES; i++) {
+		struct rifsc_master_debug_data m_dbg_entry;
+
+		stm32_rifsc_fill_master_dbg_entry(debug_data, &m_dbg_entry, i);
+
+		seq_printf(s, "| %-11s |", m_dbg_entry.m_name);
+		seq_printf(s, "| %-6s |", m_dbg_entry.cidsel ? "CIDSEL" : "");
+		seq_printf(s, "| %-4d |", m_dbg_entry.m_cid);
+		seq_printf(s, "| %-8s |", m_dbg_entry.m_sec ? "SEC" : "NSEC");
+		seq_printf(s, "| %-12s |\n", m_dbg_entry.m_priv ? "PRIV" : "NPRIV");
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(stm32_rifsc_conf_dump);
+
+static int stm32_sys_bus_register_debugfs(struct sys_bus_data *pdata)
+{
+	struct dentry *root = NULL;
+
+	/* Only supported for RIFSC at the moment */
+	if (strcmp(pdata->pconf->bus_name, "rifsc"))
+		return 0;
+
+	root = debugfs_lookup("stm32_firewall", NULL);
+	if (!root)
+		root = debugfs_create_dir("stm32_firewall", NULL);
+
+	if (IS_ERR(root))
+		return PTR_ERR(root);
+
+	debugfs_create_file("rifsc", 0444, root, pdata, &stm32_rifsc_conf_dump_fops);
+
+	return 0;
+}
+#endif /* CONFIG_DEBUG_FS */
+
+static int stm32_sys_bus_get_periph_id(struct sys_bus_data *pdata, struct device_node *np, u32 *id)
+{
+	int err;
+	u32 feature_domain_cell[2];
+	u32 id_bus;
+
+	/* Get reg from device node */
+	err = of_property_read_u32_array(np, "feature-domains", feature_domain_cell, 2);
+	if (err) {
+		dev_err(pdata->dev, "Unable to find feature-domains property\n");
+		return -ENODEV;
+	}
+
+	id_bus = feature_domain_cell[1];
+
+	if (id_bus >= pdata->pconf->max_entries) {
+		dev_err(pdata->dev, "Invalid sys bus ID for %s\n", np->full_name);
+		return -EINVAL;
+	}
+
+	*id = id_bus;
+
+	return 0;
+}
+
+static int stm32_etzpc_get_access(struct sys_bus_data *pdata, struct device_node *np)
+{
+	int err;
+	u32 offset, reg_offset, sec_val, id;
+
+	err = stm32_sys_bus_get_periph_id(pdata, np, &id);
+	if (err)
+		return err;
+
+	/* Check access configuration, 16 peripherals per register */
+	reg_offset = ETZPC_DECPROT + 0x4 * (id / IDS_PER_DECPROT_REGS);
+	offset = (id % IDS_PER_DECPROT_REGS) << ETZPC_DECPROT_SHIFT;
+
+	/* Verify peripheral is non-secure and attributed to cortex A7 */
+	sec_val = (readl(pdata->sys_bus_base + reg_offset) >> offset) & ETZPC_PROT_MASK;
+	if (sec_val != ETZPC_PROT_A7NS) {
+		dev_dbg(pdata->dev, "Invalid bus configuration: reg_offset %#x, value %d\n",
+			reg_offset, sec_val);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+static bool stm32_rif_is_semaphore_available(void __iomem *addr)
+{
+	return !(readl(addr) & SEMCR_MUTEX);
+}
+
+static int stm32_rif_acquire_semaphore(struct sys_bus_data *pdata, int id)
+{
+	void __iomem *addr = pdata->sys_bus_base + RIFSC_RISC_PER0_SEMCR + 0x8 * id;
+
+	writel(SEMCR_MUTEX, addr);
+
+	/* Check that CID1 has the semaphore */
+	if (stm32_rif_is_semaphore_available(addr) ||
+	    FIELD_GET(RIFSC_RISC_SCID_MASK, (readl(addr)) != RIF_CID1))
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32_rifsc_get_access_by_node(struct sys_bus_data *pdata, struct device_node *np)
+{
+	int err;
+	u32 id;
+
+	err = stm32_sys_bus_get_periph_id(pdata, np, &id);
+	if (err)
+		return err;
+
+	return stm32_rifsc_get_access_by_id(id);
+}
+
+int stm32_rifsc_check_access_by_id(u32 id)
+{
+	struct sys_bus_data *pdata = bus_data;
+	u32 reg_offset, reg_id, sec_reg_value, cid_reg_value;
+	void __iomem *addr;
+
+	if (id >= STM32MP25_RIFSC_ENTRIES)
+		return -EINVAL;
+
+	/*
+	 * RIFSC_RISC_PRIVCFGRx and RIFSC_RISC_SECCFGRx both handle configuration access for
+	 * 32 peripherals. On the other hand, there is one _RIFSC_RISC_PERx_CIDCFGR register
+	 * per peripheral
+	 */
+	reg_id = id / IDS_PER_RISC_SEC_PRIV_REGS;
+	reg_offset = id % IDS_PER_RISC_SEC_PRIV_REGS;
+	sec_reg_value = readl(pdata->sys_bus_base + RIFSC_RISC_SECCFGR0 + 0x4 * reg_id);
+	cid_reg_value = readl(pdata->sys_bus_base + RIFSC_RISC_PER0_CIDCFGR + 0x8 * id);
+
+	/* Check security configuration */
+	if (sec_reg_value & BIT(reg_offset)) {
+		dev_dbg(pdata->dev, "Invalid security configuration for peripheral: %d\n", id);
+		return -EACCES;
+	}
+
+	/* Skip CID check if CID filtering isn't enabled */
+	if (!(cid_reg_value & CIDCFGR_CFEN))
+		return 0;
+
+	if (FIELD_GET(RIFSC_RISC_SCID_MASK, cid_reg_value) == RIF_CID1)
+		return 0;
+
+	/*
+	 * First check conditions for semaphore mode, which doesn't take into account static CID.
+	 * CID for Cortex A35 is RIF_CID1.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN) {
+		addr = pdata->sys_bus_base + RIFSC_RISC_PER0_SEMCR + 0x8 * id;
+
+		/* Check that CID1 has the semaphore */
+		if (!stm32_rif_is_semaphore_available(addr) &&
+		    (FIELD_GET(RIFSC_RISC_SCID_MASK, readl(addr)) == RIF_CID1)) {
+			return 0;
+		}
+	}
+
+	return -EACCES;
+}
+
+int stm32_rifsc_get_access_by_id(u32 id)
+{
+	int err;
+	struct sys_bus_data *pdata = bus_data;
+	u32 reg_offset, reg_id, sec_reg_value, cid_reg_value;
+
+	if (id >= STM32MP25_RIFSC_ENTRIES)
+		return -EINVAL;
+
+	/*
+	 * RIFSC_RISC_PRIVCFGRx and RIFSC_RISC_SECCFGRx both handle configuration access for
+	 * 32 peripherals. On the other hand, there is one _RIFSC_RISC_PERx_CIDCFGR register
+	 * per peripheral
+	 */
+	reg_id = id / IDS_PER_RISC_SEC_PRIV_REGS;
+	reg_offset = id % IDS_PER_RISC_SEC_PRIV_REGS;
+	sec_reg_value = readl(pdata->sys_bus_base + RIFSC_RISC_SECCFGR0 + 0x4 * reg_id);
+	cid_reg_value = readl(pdata->sys_bus_base + RIFSC_RISC_PER0_CIDCFGR + 0x8 * id);
+
+	/*
+	 * First check conditions for semaphore mode, which doesn't take into account static CID.
+	 * CID for Cortex A35 is RIF_CID1.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN) {
+		if (cid_reg_value & BIT(RIF_CID1 + SEMWL_SHIFT)) {
+			/* Static CID is irrelevant if semaphore mode */
+			goto skip_cid_check;
+		} else {
+			dev_dbg(pdata->dev, "Invalid bus semaphore configuration: index %d\n", id);
+			return -EACCES;
+		}
+	}
+
+	/* Skip CID check if CID filtering isn't enabled */
+	if (!(cid_reg_value & CIDCFGR_CFEN))
+		goto skip_cid_check;
+
+	/* Coherency check with the CID configuration */
+	if (FIELD_GET(RIFSC_RISC_SCID_MASK, cid_reg_value) != RIF_CID1) {
+		dev_dbg(pdata->dev, "Invalid CID configuration for peripheral: %d\n", id);
+		return -EACCES;
+	}
+
+skip_cid_check:
+	/* Check security configuration */
+	if (sec_reg_value & BIT(reg_offset)) {
+		dev_dbg(pdata->dev, "Invalid security configuration for peripheral: %d\n", id);
+		return -EACCES;
+	}
+
+	/*
+	 * If the peripheral is in semaphore mode, take the semaphore so that
+	 * the CID1 has the ownership.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN) {
+		err = stm32_rif_acquire_semaphore(pdata, id);
+		if (err) {
+			dev_err(pdata->dev, "Couldn't acquire semaphore for peripheral: %d\n", id);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static void stm32_sys_bus_populate(struct sys_bus_data *pdata)
+{
+	struct device *parent;
+	struct device_node *child;
+
+	parent = pdata->dev;
+
+	dev_dbg(parent, "Populating %s system bus\n", pdata->dev->driver->name);
+
+	for_each_available_child_of_node(dev_of_node(parent), child) {
+		if (pdata->pconf->sys_bus_get_access(pdata, child)) {
+			/*
+			 * Peripheral access not allowed.
+			 * Mark the node as populated so platform bus won't probe it
+			 */
+			of_node_set_flag(child, OF_POPULATED);
+			dev_err(parent, "%s: Peripheral will not be probed\n",
+				child->full_name);
+		}
+	}
+}
+
+static int stm32_sys_bus_probe(struct platform_device *pdev)
+{
+	struct sys_bus_data *pdata;
+	struct resource *res;
+	void __iomem *mmio;
+	struct stm32_sys_bus_match_data *mdata;
+	struct device_node *np = pdev->dev.of_node;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mmio = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mmio))
+		return PTR_ERR(mmio);
+
+	pdata->sys_bus_base = mmio;
+
+	mdata = (struct stm32_sys_bus_match_data *)of_device_get_match_data(&pdev->dev);
+	if (!mdata)
+		return -EINVAL;
+
+	pdata->pconf = mdata;
+	pdata->dev = &pdev->dev;
+
+	/* Todo: Use firewall framework */
+	bus_data = pdata;
+
+	platform_set_drvdata(pdev, pdata);
+
+#ifdef CONFIG_DEBUG_FS
+	stm32_sys_bus_register_debugfs(pdata);
+#endif
+
+	stm32_sys_bus_populate(pdata);
+
+	/* Populate all available nodes */
+	return of_platform_populate(np, NULL, NULL, &pdev->dev);
+}
+
+static const struct stm32_sys_bus_match_data stm32mp15_sys_bus_data = {
+	.max_entries = STM32MP15_ETZPC_ENTRIES,
+	.sys_bus_get_access = stm32_etzpc_get_access,
+#ifdef CONFIG_DEBUG_FS
+	.bus_name = "etzpc"
+#endif
+};
+
+static const struct stm32_sys_bus_match_data stm32mp13_sys_bus_data = {
+	.max_entries = STM32MP13_ETZPC_ENTRIES,
+	.sys_bus_get_access = stm32_etzpc_get_access,
+#ifdef CONFIG_DEBUG_FS
+	.bus_name = "etzpc"
+#endif
+};
+
+static const struct stm32_sys_bus_match_data stm32mp25_sys_bus_data = {
+	.max_entries = STM32MP25_RIFSC_ENTRIES,
+	.sys_bus_get_access = stm32_rifsc_get_access_by_node,
+#ifdef CONFIG_DEBUG_FS
+	.bus_name = "rifsc"
+#endif
+};
+
+static const struct of_device_id stm32_sys_bus_of_match[] = {
+	{ .compatible = "st,stm32mp15-sys-bus", .data = &stm32mp15_sys_bus_data },
+	{ .compatible = "st,stm32mp13-sys-bus", .data = &stm32mp13_sys_bus_data },
+	{ .compatible = "st,stm32mp25-sys-bus", .data = &stm32mp25_sys_bus_data },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_sys_bus_of_match);
+
+static struct platform_driver stm32_sys_bus_driver = {
+	.probe  = stm32_sys_bus_probe,
+	.driver = {
+		.name = "stm32-sys-bus",
+		.of_match_table = stm32_sys_bus_of_match,
+	},
+};
+
+static int __init stm32_sys_bus_init(void)
+{
+	return platform_driver_register(&stm32_sys_bus_driver);
+}
+arch_initcall(stm32_sys_bus_init);
+
diff --git a/drivers/bus/stm32_sys_bus.h b/drivers/bus/stm32_sys_bus.h
new file mode 100644
index 000000000..8e5a3bba2
--- /dev/null
+++ b/drivers/bus/stm32_sys_bus.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef __ARCH_ARM_MACH_STM32MP25_SYSTEM_BUS
+#define __ARCH_ARM_MACH_STM32MP25_SYSTEM_BUS
+
+#include <linux/types.h>
+
+int stm32_rifsc_get_access_by_id(u32 id);
+int stm32_rifsc_check_access_by_id(u32 id);
+
+#endif /* __ARCH_ARM_MACH_STM32MP25_SYSTEM_BUS */
diff --git a/drivers/char/hw_random/stm32-rng.c b/drivers/char/hw_random/stm32-rng.c
index bc22178f8..56b081923 100644
--- a/drivers/char/hw_random/stm32-rng.c
+++ b/drivers/char/hw_random/stm32-rng.c
@@ -16,58 +16,233 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 
-#define RNG_CR 0x00
-#define RNG_CR_RNGEN BIT(2)
-#define RNG_CR_CED BIT(5)
-
-#define RNG_SR 0x04
-#define RNG_SR_SEIS BIT(6)
-#define RNG_SR_CEIS BIT(5)
-#define RNG_SR_DRDY BIT(0)
+#define RNG_CR			0x00
+#define RNG_CR_RNGEN		BIT(2)
+#define RNG_CR_CED		BIT(5)
+#define RNG_CR_CONFIG1		GENMASK(11, 8)
+#define RNG_CR_NISTC		BIT(12)
+#define RNG_CR_CONFIG2		GENMASK(15, 13)
+#define RNG_CR_CLKDIV_SHIFT	16
+#define RNG_CR_CLKDIV		GENMASK(19, 16)
+#define RNG_CR_CONFIG3		GENMASK(25, 20)
+#define RNG_CR_CONDRST		BIT(30)
+#define RNG_CR_CONFLOCK		BIT(31)
+#define RNG_CR_ENTROPY_SRC_MASK	(RNG_CR_CONFIG1 | RNG_CR_NISTC | RNG_CR_CONFIG2 | RNG_CR_CONFIG3)
+#define RNG_CR_CONFIG_MASK	(RNG_CR_ENTROPY_SRC_MASK | RNG_CR_CED | RNG_CR_CLKDIV)
+
+#define RNG_SR			0x04
+#define RNG_SR_DRDY		BIT(0)
+#define RNG_SR_CECS		BIT(1)
+#define RNG_SR_SECS		BIT(2)
+#define RNG_SR_CEIS		BIT(5)
+#define RNG_SR_SEIS		BIT(6)
+
+#define RNG_DR		0x08
+
+#define RNG_NSCR		0x0C
+#define RNG_NSCR_MASK		GENMASK(17, 0)
+
+#define RNG_HTCR	0x10
+
+#define RNG_NB_RECOVER_TRIES	3
+
+struct stm32_rng_data {
+	uint	max_clock_rate;
+	uint	nb_clock;
+	u32	cr;
+	u32	nscr;
+	u32	htcr;
+	bool	has_cond_reset;
+};
 
-#define RNG_DR 0x08
+/**
+ * struct stm32_rng_config - RNG configuration data
+ *
+ * @cr:			RNG configuration. 0 means default hardware RNG configuration
+ * @nscr:		Noise sources control configuration.
+ * @htcr:		Health tests configuration.
+ */
+struct stm32_rng_config {
+	u32 cr;
+	u32 nscr;
+	u32 htcr;
+};
 
 struct stm32_rng_private {
 	struct hwrng rng;
 	void __iomem *base;
 	struct clk *clk;
+	struct clk *bus_clk;
 	struct reset_control *rst;
+	struct stm32_rng_config pm_conf;
+	const struct stm32_rng_data *data;
 	bool ced;
+	bool lock_conf;
+};
+
+/*
+ * Extracts from the STM32 RNG specification when RNG supports CONDRST.
+ *
+ * When a noise source (or seed) error occurs, the RNG stops generating
+ * random numbers and sets to 1 both SEIS and SECS bits to indicate
+ * that a seed error occurred. (...)
+ *
+ * 1. Software reset by writing CONDRST at 1 and at 0 (see bitfield
+ * description for details). This step is needed only if SECS is set.
+ * Indeed, when SEIS is set and SECS is cleared it means RNG performed
+ * the reset automatically (auto-reset).
+ * 2. If SECS was set in step 1 (no auto-reset) wait for CONDRST
+ * to be cleared in the RNG_CR register, then confirm that SEIS is
+ * cleared in the RNG_SR register. Otherwise just clear SEIS bit in
+ * the RNG_SR register.
+ * 3. If SECS was set in step 1 (no auto-reset) wait for SECS to be
+ * cleared by RNG. The random number generation is now back to normal.
+ */
+static int stm32_rng_conceal_seed_error_cond_reset(struct stm32_rng_private *priv)
+{
+	struct device *dev = (struct device *)priv->rng.priv;
+	u32 sr = readl_relaxed(priv->base + RNG_SR);
+	u32 cr = readl_relaxed(priv->base + RNG_CR);
+	int err;
+
+	if (sr & RNG_SR_SECS) {
+		/* Conceal by resetting the subsystem (step 1.) */
+		writel_relaxed(cr | RNG_CR_CONDRST, priv->base + RNG_CR);
+		writel_relaxed(cr & ~RNG_CR_CONDRST, priv->base + RNG_CR);
+	} else {
+		/* RNG auto-reset (step 2.) */
+		writel_relaxed(sr & ~RNG_SR_SEIS, priv->base + RNG_SR);
+		goto end;
+	}
+
+	err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_CR, cr, !(cr & RNG_CR_CONDRST), 10,
+						100000);
+	if (err) {
+		dev_err(dev, "%s: timeout %x\n", __func__, sr);
+		return err;
+	}
+
+	/* Check SEIS is cleared (step 2.) */
+	if (readl_relaxed(priv->base + RNG_SR) & RNG_SR_SEIS)
+		return -EINVAL;
+
+	err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_SR, sr, !(sr & RNG_SR_SECS), 10,
+						100000);
+	if (err) {
+		dev_err(dev, "%s: timeout %x\n", __func__, sr);
+		return err;
+	}
+
+end:
+	return 0;
+}
+
+/*
+ * Extracts from the STM32 RNG specification, when CONDRST is not supported
+ *
+ * When a noise source (or seed) error occurs, the RNG stops generating
+ * random numbers and sets to 1 both SEIS and SECS bits to indicate
+ * that a seed error occurred. (...)
+ *
+ * The following sequence shall be used to fully recover from a seed
+ * error after the RNG initialization:
+ * 1. Clear the SEIS bit by writing it to 0.
+ * 2. Read out 12 words from the RNG_DR register, and discard each of
+ * them in order to clean the pipeline.
+ * 3. Confirm that SEIS is still cleared. Random number generation is
+ * back to normal.
+ */
+static int stm32_rng_conceal_seed_error_sw_reset(struct stm32_rng_private *priv)
+{
+	unsigned int i = 0;
+	u32 sr = readl_relaxed(priv->base + RNG_SR);
+
+	writel_relaxed(sr & ~RNG_SR_SEIS, priv->base + RNG_SR);
+
+	for (i = 12; i != 0; i--)
+		(void)readl_relaxed(priv->base + RNG_DR);
+
+	if (readl_relaxed(priv->base + RNG_SR) & RNG_SR_SEIS)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int stm32_rng_conceal_seed_error(struct hwrng *rng)
+{
+	struct stm32_rng_private *priv = container_of(rng, struct stm32_rng_private, rng);
+
+	dev_dbg((struct device *)priv->rng.priv, "Concealing seed error\n");
+
+	if (priv->data->has_cond_reset)
+		return stm32_rng_conceal_seed_error_cond_reset(priv);
+	else
+		return stm32_rng_conceal_seed_error_sw_reset(priv);
 };
 
+
 static int stm32_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)
 {
-	struct stm32_rng_private *priv =
-	    container_of(rng, struct stm32_rng_private, rng);
+	struct stm32_rng_private *priv = container_of(rng, struct stm32_rng_private, rng);
+	unsigned int i = 0;
+	int retval = 0, err = 0;
 	u32 sr;
-	int retval = 0;
 
 	pm_runtime_get_sync((struct device *) priv->rng.priv);
 
 	while (max > sizeof(u32)) {
 		sr = readl_relaxed(priv->base + RNG_SR);
-		/* Manage timeout which is based on timer and take */
-		/* care of initial delay time when enabling rng	*/
+		/*
+		 * Manage timeout which is based on timer and take
+		 * care of initial delay time when enabling the RNG.
+		 */
 		if (!sr && wait) {
-			retval = readl_relaxed_poll_timeout_atomic(priv->base
+			err = readl_relaxed_poll_timeout_atomic(priv->base
 								   + RNG_SR,
 								   sr, sr,
 								   10, 50000);
-			if (retval)
+			if (err) {
 				dev_err((struct device *)priv->rng.priv,
 					"%s: timeout %x!\n", __func__, sr);
+				break;
+			}
+		} else if (!sr) {
+			/* The FIFO is being filled up */
+			break;
 		}
 
-		/* If error detected or data not ready... */
 		if (sr != RNG_SR_DRDY) {
-			if (WARN_ONCE(sr & (RNG_SR_SEIS | RNG_SR_CEIS),
-					"bad RNG status - %x\n", sr))
+			if (sr & RNG_SR_SEIS) {
+				err = stm32_rng_conceal_seed_error(rng);
+				i++;
+				if (err && i > RNG_NB_RECOVER_TRIES) {
+					dev_err((struct device *)priv->rng.priv,
+						"Couldn't recover from seed error\n");
+					return -ENOTRECOVERABLE;
+				}
+
+				continue;
+			}
+
+			if (WARN_ONCE((sr & RNG_SR_CEIS), "RNG clock too slow - %x\n", sr))
 				writel_relaxed(0, priv->base + RNG_SR);
-			break;
 		}
 
+		/* Late seed error case: DR being 0 is an error status */
 		*(u32 *)data = readl_relaxed(priv->base + RNG_DR);
+		if (!*(u32 *)data) {
+			err = stm32_rng_conceal_seed_error(rng);
+			i++;
+			if (err && i > RNG_NB_RECOVER_TRIES) {
+				dev_err((struct device *)priv->rng.priv,
+					"Couldn't recover from seed error");
+				return -ENOTRECOVERABLE;
+			}
+
+			continue;
+		}
 
+		i = 0;
 		retval += sizeof(u32);
 		data += sizeof(u32);
 		max -= sizeof(u32);
@@ -79,86 +254,121 @@ static int stm32_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)
 	return retval || !wait ? retval : -EIO;
 }
 
-static int stm32_rng_init(struct hwrng *rng)
+static uint stm32_rng_clock_freq_restrain(struct hwrng *rng)
 {
 	struct stm32_rng_private *priv =
 	    container_of(rng, struct stm32_rng_private, rng);
-	int err;
+	unsigned long clock_rate = 0;
+	uint clock_div = 0;
 
-	err = clk_prepare_enable(priv->clk);
-	if (err)
-		return err;
+	clock_rate = clk_get_rate(priv->clk);
 
-	if (priv->ced)
-		writel_relaxed(RNG_CR_RNGEN, priv->base + RNG_CR);
-	else
-		writel_relaxed(RNG_CR_RNGEN | RNG_CR_CED,
-			       priv->base + RNG_CR);
+	/*
+	 * Get the exponent to apply on the CLKDIV field in RNG_CR register
+	 * No need to handle the case when clock-div > 0xF as it is physically
+	 * impossible
+	 */
+	while ((clock_rate >> clock_div) > priv->data->max_clock_rate)
+		clock_div++;
 
-	/* clear error indicators */
-	writel_relaxed(0, priv->base + RNG_SR);
+	pr_debug("RNG clk rate : %lu\n", clk_get_rate(priv->clk) >> clock_div);
 
-	return 0;
+	return clock_div;
 }
 
-static void stm32_rng_cleanup(struct hwrng *rng)
+static int stm32_rng_init(struct hwrng *rng)
 {
 	struct stm32_rng_private *priv =
 	    container_of(rng, struct stm32_rng_private, rng);
-
-	writel_relaxed(0, priv->base + RNG_CR);
-	clk_disable_unprepare(priv->clk);
-}
-
-static int stm32_rng_probe(struct platform_device *ofdev)
-{
-	struct device *dev = &ofdev->dev;
-	struct device_node *np = ofdev->dev.of_node;
-	struct stm32_rng_private *priv;
-	struct resource res;
 	int err;
+	u32 reg;
 
-	priv = devm_kzalloc(dev, sizeof(struct stm32_rng_private), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	err = of_address_to_resource(np, 0, &res);
+	err = clk_prepare_enable(priv->clk);
 	if (err)
 		return err;
 
-	priv->base = devm_ioremap_resource(dev, &res);
-	if (IS_ERR(priv->base))
-		return PTR_ERR(priv->base);
+	if (priv->bus_clk) {
+		err = clk_prepare_enable(priv->bus_clk);
+		if (err)
+			return err;
+	}
 
-	priv->clk = devm_clk_get(&ofdev->dev, NULL);
-	if (IS_ERR(priv->clk))
-		return PTR_ERR(priv->clk);
+	/* clear error indicators */
+	writel_relaxed(0, priv->base + RNG_SR);
 
-	priv->rst = devm_reset_control_get(&ofdev->dev, NULL);
-	if (!IS_ERR(priv->rst)) {
-		reset_control_assert(priv->rst);
-		udelay(2);
-		reset_control_deassert(priv->rst);
-	}
+	reg = readl_relaxed(priv->base + RNG_CR);
+
+	/*
+	 * Keep default RNG configuration if none was specified.
+	 * 0 is an invalid value as it disables all entropy sources.
+	 */
+	if (priv->data->has_cond_reset && priv->data->cr) {
+		uint clock_div = stm32_rng_clock_freq_restrain(rng);
+
+		reg &= ~RNG_CR_CONFIG_MASK;
+		reg |= RNG_CR_CONDRST | (priv->data->cr & RNG_CR_ENTROPY_SRC_MASK) |
+		       (clock_div << RNG_CR_CLKDIV_SHIFT);
+		if (priv->ced)
+			reg &= ~RNG_CR_CED;
+		else
+			reg |= RNG_CR_CED;
+		writel_relaxed(reg, priv->base + RNG_CR);
+
+		/* Health tests and noise control registers */
+		writel_relaxed(priv->data->htcr, priv->base + RNG_HTCR);
+		writel_relaxed(priv->data->nscr & RNG_NSCR_MASK, priv->base + RNG_NSCR);
+
+		reg &= ~RNG_CR_CONDRST;
+		reg |= RNG_CR_RNGEN;
+		if (priv->lock_conf)
+			reg |= RNG_CR_CONFLOCK;
+		writel_relaxed(reg, priv->base + RNG_CR);
+
+		err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_CR, reg,
+							(!(reg & RNG_CR_CONDRST)),
+							10, 50000);
+		if (err) {
+			dev_err((struct device *)priv->rng.priv,
+				"%s: timeout %x!\n", __func__, reg);
+			return -EINVAL;
+		}
+	} else {
+		/* Handle all RNG versions by checking if conditional reset should be set */
+		if (priv->data->has_cond_reset)
+			reg |= RNG_CR_CONDRST;
 
-	priv->ced = of_property_read_bool(np, "clock-error-detect");
+		if (priv->ced)
+			reg &= ~RNG_CR_CED;
+		else
+			reg |= RNG_CR_CED;
 
-	dev_set_drvdata(dev, priv);
+		writel_relaxed(reg, priv->base + RNG_CR);
 
-	priv->rng.name = dev_driver_string(dev);
-#ifndef CONFIG_PM
-	priv->rng.init = stm32_rng_init;
-	priv->rng.cleanup = stm32_rng_cleanup;
-#endif
-	priv->rng.read = stm32_rng_read;
-	priv->rng.priv = (unsigned long) dev;
-	priv->rng.quality = 900;
+		if (priv->data->has_cond_reset)
+			reg &= ~RNG_CR_CONDRST;
 
-	pm_runtime_set_autosuspend_delay(dev, 100);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_enable(dev);
+		if (priv->lock_conf)
+			reg |= RNG_CR_CONFLOCK;
 
-	return devm_hwrng_register(dev, &priv->rng);
+		reg |= RNG_CR_RNGEN;
+
+		writel_relaxed(reg, priv->base + RNG_CR);
+	}
+
+	err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_SR, reg,
+						reg & RNG_SR_DRDY,
+						10, 100000);
+	if (err || (reg & ~RNG_SR_DRDY)) {
+		if (priv->bus_clk)
+			clk_disable_unprepare(priv->bus_clk);
+		clk_disable_unprepare(priv->clk);
+
+		dev_err((struct device *)priv->rng.priv,
+			"%s: timeout:%x SR: %x!\n", __func__, err, reg);
+		return -EINVAL;
+	}
+
+	return 0;
 }
 
 static int stm32_rng_remove(struct platform_device *ofdev)
@@ -172,8 +382,36 @@ static int stm32_rng_remove(struct platform_device *ofdev)
 static int stm32_rng_runtime_suspend(struct device *dev)
 {
 	struct stm32_rng_private *priv = dev_get_drvdata(dev);
+	u32 reg;
+
+	reg = readl_relaxed(priv->base + RNG_CR);
+	reg &= ~RNG_CR_RNGEN;
+	writel_relaxed(reg, priv->base + RNG_CR);
+
+	if (priv->bus_clk)
+		clk_disable_unprepare(priv->bus_clk);
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int stm32_rng_suspend(struct device *dev)
+{
+	struct stm32_rng_private *priv = dev_get_drvdata(dev);
+
+	if (priv->data->has_cond_reset) {
+		priv->pm_conf.nscr = readl_relaxed(priv->base + RNG_NSCR);
+		priv->pm_conf.htcr = readl_relaxed(priv->base + RNG_HTCR);
+	}
+
+	/* Do not save that RNG is enabled as it will be handled at resume */
+	priv->pm_conf.cr = readl_relaxed(priv->base + RNG_CR) & ~RNG_CR_RNGEN;
+
+	writel_relaxed(priv->pm_conf.cr, priv->base + RNG_CR);
 
-	stm32_rng_cleanup(&priv->rng);
+	if (priv->bus_clk)
+		clk_disable_unprepare(priv->bus_clk);
+	clk_disable_unprepare(priv->clk);
 
 	return 0;
 }
@@ -181,27 +419,197 @@ static int stm32_rng_runtime_suspend(struct device *dev)
 static int stm32_rng_runtime_resume(struct device *dev)
 {
 	struct stm32_rng_private *priv = dev_get_drvdata(dev);
+	int err;
+	u32 reg;
+
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	if (priv->bus_clk) {
+		err = clk_prepare_enable(priv->bus_clk);
+		if (err)
+			return err;
+	}
+
+	/* Clean error indications */
+	writel_relaxed(0, priv->base + RNG_SR);
+
+	reg = readl_relaxed(priv->base + RNG_CR);
+	reg |= RNG_CR_RNGEN;
+	writel_relaxed(reg, priv->base + RNG_CR);
+
+	return 0;
+}
+
+static int stm32_rng_resume(struct device *dev)
+{
+	struct stm32_rng_private *priv = dev_get_drvdata(dev);
+	int err;
+	u32 reg;
+
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	if (priv->bus_clk) {
+		err = clk_prepare_enable(priv->bus_clk);
+		if (err)
+			return err;
+	}
+
+	/* Clean error indications */
+	writel_relaxed(0, priv->base + RNG_SR);
+
+	if (priv->data->has_cond_reset) {
+		/*
+		 * Correct configuration in bits [29:4] must be set in the same
+		 * access that set RNG_CR_CONDRST bit. Else config setting is
+		 * not taken into account. CONFIGLOCK bit must also be unset but
+		 * it is not handled at the moment.
+		 */
+		writel_relaxed(priv->pm_conf.cr | RNG_CR_CONDRST, priv->base + RNG_CR);
+
+		writel_relaxed(priv->pm_conf.nscr, priv->base + RNG_NSCR);
+		writel_relaxed(priv->pm_conf.htcr, priv->base + RNG_HTCR);
+
+		reg = readl_relaxed(priv->base + RNG_CR);
+		reg |= RNG_CR_RNGEN;
+		reg &= ~RNG_CR_CONDRST;
+		writel_relaxed(reg, priv->base + RNG_CR);
+
+		err = readl_relaxed_poll_timeout_atomic(priv->base + RNG_CR, reg,
+							reg & ~RNG_CR_CONDRST, 10, 100000);
+
+		if (err) {
+			if (priv->bus_clk)
+				clk_disable_unprepare(priv->bus_clk);
+			clk_disable_unprepare(priv->clk);
+			dev_err((struct device *)priv->rng.priv,
+				"%s: timeout:%x CR: %x!\n", __func__, err, reg);
+			return -EINVAL;
+		}
+	} else {
+		reg = priv->pm_conf.cr;
+		reg |= RNG_CR_RNGEN;
+		writel_relaxed(reg, priv->base + RNG_CR);
+	}
 
-	return stm32_rng_init(&priv->rng);
+	return 0;
 }
-#endif
+#endif /* CONFIG_PM */
 
 static const struct dev_pm_ops stm32_rng_pm_ops = {
 	SET_RUNTIME_PM_OPS(stm32_rng_runtime_suspend,
 			   stm32_rng_runtime_resume, NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_rng_suspend,
+				stm32_rng_resume)
+};
+
+static const struct stm32_rng_data stm32mp25_rng_data = {
+	.has_cond_reset = true,
+	.max_clock_rate = 48000000,
+	.nb_clock = 2,
+	.cr = 0x00F00D00,
+	.nscr = 0x2B5BB,
+	.htcr = 0x969D,
+};
+
+static const struct stm32_rng_data stm32mp13_rng_data = {
+	.has_cond_reset = true,
+	.max_clock_rate = 48000000,
+	.nb_clock = 1,
+	.cr = 0x00F00D00,
+	.nscr = 0x2B5BB,
+	.htcr = 0x969D,
 };
 
+static const struct stm32_rng_data stm32_rng_data = {
+	.has_cond_reset = false,
+	.max_clock_rate = 48000000,
+	.nb_clock = 1,
+};
 
 static const struct of_device_id stm32_rng_match[] = {
+	{
+		.compatible = "st,stm32mp25-rng",
+		.data = &stm32mp25_rng_data,
+	},
+	{
+		.compatible = "st,stm32mp13-rng",
+		.data = &stm32mp13_rng_data,
+	},
 	{
 		.compatible = "st,stm32-rng",
+		.data = &stm32_rng_data,
 	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_rng_match);
 
+static int stm32_rng_probe(struct platform_device *ofdev)
+{
+	const struct of_device_id *match;
+	struct device *dev = &ofdev->dev;
+	struct device_node *np = ofdev->dev.of_node;
+	struct stm32_rng_private *priv;
+	struct resource *res;
+
+	priv = devm_kzalloc(dev, sizeof(struct stm32_rng_private), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->base = devm_platform_get_and_ioremap_resource(ofdev, 0, &res);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+
+	priv->rst = devm_reset_control_get(&ofdev->dev, NULL);
+	if (!IS_ERR(priv->rst)) {
+		reset_control_assert(priv->rst);
+		udelay(2);
+		reset_control_deassert(priv->rst);
+	}
+
+	priv->ced = of_property_read_bool(np, "clock-error-detect");
+	priv->lock_conf = of_property_read_bool(np, "st,rng-lock-conf");
+
+	match = of_match_device(of_match_ptr(stm32_rng_match), dev);
+	if (!match) {
+		dev_err(dev, "no compatible OF match\n");
+		return -EINVAL;
+	}
+
+	priv->data = match->data;
+
+	dev_set_drvdata(dev, priv);
+
+	priv->rng.name = dev_driver_string(dev);
+	priv->rng.init = stm32_rng_init;
+	priv->rng.read = stm32_rng_read;
+	priv->rng.priv = (unsigned long) dev;
+	priv->rng.quality = 900;
+
+	if (priv->data->nb_clock > 1) {
+		priv->clk = devm_clk_get(&ofdev->dev, "rng_clk");
+		if (IS_ERR(priv->clk))
+			return PTR_ERR(priv->clk);
+
+		priv->bus_clk = devm_clk_get(&ofdev->dev, "rng_hclk");
+		if (IS_ERR(priv->clk))
+			return PTR_ERR(priv->bus_clk);
+	} else {
+		priv->clk = devm_clk_get(&ofdev->dev, NULL);
+		if (IS_ERR(priv->clk))
+			return PTR_ERR(priv->clk);
+	}
+
+	pm_runtime_set_autosuspend_delay(dev, 100);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_enable(dev);
+
+	return devm_hwrng_register(dev, &priv->rng);
+}
+
 static struct platform_driver stm32_rng_driver = {
 	.driver = {
 		.name = "stm32-rng",
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index a5dcc7293..af7c61aab 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -34,6 +34,10 @@ menuconfig COMMON_CLK
 
 if COMMON_CLK
 
+config COMMON_CLK_REGMAP
+	tristate
+	select REGMAP
+
 config COMMON_CLK_WM831X
 	tristate "Clock driver for WM831x/2x PMICs"
 	depends on MFD_WM831X
@@ -396,6 +400,12 @@ config COMMON_CLK_STM32MP157
 	help
 	  Support for stm32mp157 SoC family clocks
 
+config COMMON_CLK_STM32MP257
+	def_bool COMMON_CLK && MACH_STM32MP25
+	select COMMON_CLK_REGMAP
+	help
+	  Support for stm32mp25x SoC family clocks
+
 config COMMON_CLK_STM32F
 	def_bool COMMON_CLK && (MACH_STM32F429 || MACH_STM32F469 || MACH_STM32F746)
 	help
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index e3ca0d058..396f1e691 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_COMMON_CLK_PALMAS)		+= clk-palmas.o
 obj-$(CONFIG_CLK_LS1028A_PLLDIG)	+= clk-plldig.o
 obj-$(CONFIG_COMMON_CLK_PWM)		+= clk-pwm.o
 obj-$(CONFIG_CLK_QORIQ)			+= clk-qoriq.o
+obj-$(CONFIG_COMMON_CLK_REGMAP)		+= clk-regmap.o
 obj-$(CONFIG_COMMON_CLK_RK808)		+= clk-rk808.o
 obj-$(CONFIG_COMMON_CLK_HI655X)		+= clk-hi655x.o
 obj-$(CONFIG_COMMON_CLK_S2MPS11)	+= clk-s2mps11.o
diff --git a/drivers/clk/clk-composite.c b/drivers/clk/clk-composite.c
index edfa94641..8e05c0dac 100644
--- a/drivers/clk/clk-composite.c
+++ b/drivers/clk/clk-composite.c
@@ -42,6 +42,18 @@ static unsigned long clk_composite_recalc_rate(struct clk_hw *hw,
 	return rate_ops->recalc_rate(rate_hw, parent_rate);
 }
 
+static int clk_composite_get_duty_cycle(struct clk_hw *hw,
+					struct clk_duty *duty)
+{
+	struct clk_composite *composite = to_clk_composite(hw);
+	const struct clk_ops *rate_ops = composite->rate_ops;
+	struct clk_hw *rate_hw = composite->rate_hw;
+
+	__clk_hw_set_clk(rate_hw, hw);
+
+	return rate_ops->get_duty_cycle(rate_hw, duty);
+}
+
 static int clk_composite_determine_rate_for_parent(struct clk_hw *rate_hw,
 						   struct clk_rate_request *req,
 						   struct clk_hw *parent_hw,
@@ -282,6 +294,9 @@ static struct clk_hw *__clk_hw_register_composite(struct device *dev,
 		}
 		clk_composite_ops->recalc_rate = clk_composite_recalc_rate;
 
+		if (rate_ops->get_duty_cycle)
+			clk_composite_ops->get_duty_cycle = clk_composite_get_duty_cycle;
+
 		if (rate_ops->determine_rate)
 			clk_composite_ops->determine_rate =
 				clk_composite_determine_rate;
@@ -487,3 +502,4 @@ struct clk_hw *devm_clk_hw_register_composite_pdata(struct device *dev,
 						rate_hw, rate_ops, gate_hw,
 						gate_ops, flags);
 }
+EXPORT_SYMBOL_GPL(devm_clk_hw_register_composite_pdata);
diff --git a/drivers/clk/clk-regmap.c b/drivers/clk/clk-regmap.c
new file mode 100644
index 000000000..491d6d52d
--- /dev/null
+++ b/drivers/clk/clk-regmap.c
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0 GPL-2.0-only
+/*
+ * Copyright (c) 2018 BayLibre, SAS.
+ * Author: Jerome Brunet <jbrunet@baylibre.com>
+ */
+
+#include <linux/module.h>
+#include <linux/clk-regmap.h>
+
+static int clk_regmap_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);
+	int set = gate->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;
+
+	set ^= enable;
+
+	return regmap_update_bits(clk->map, gate->offset, BIT(gate->bit_idx),
+				  set ? BIT(gate->bit_idx) : 0);
+}
+
+static int clk_regmap_gate_enable(struct clk_hw *hw)
+{
+	return clk_regmap_gate_endisable(hw, 1);
+}
+
+static void clk_regmap_gate_disable(struct clk_hw *hw)
+{
+	clk_regmap_gate_endisable(hw, 0);
+}
+
+static int clk_regmap_gate_is_enabled(struct clk_hw *hw)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_gate_data *gate = clk_get_regmap_gate_data(clk);
+	unsigned int val;
+
+	regmap_read(clk->map, gate->offset, &val);
+	if (gate->flags & CLK_GATE_SET_TO_DISABLE)
+		val ^= BIT(gate->bit_idx);
+
+	val &= BIT(gate->bit_idx);
+
+	return val ? 1 : 0;
+}
+
+const struct clk_ops clk_regmap_gate_ops = {
+	.enable = clk_regmap_gate_enable,
+	.disable = clk_regmap_gate_disable,
+	.is_enabled = clk_regmap_gate_is_enabled,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_gate_ops);
+
+const struct clk_ops clk_regmap_gate_ro_ops = {
+	.is_enabled = clk_regmap_gate_is_enabled,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_gate_ro_ops);
+
+static unsigned long clk_regmap_div_recalc_rate(struct clk_hw *hw,
+						unsigned long prate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(clk->map, div->offset, &val);
+	if (ret)
+		/* Gives a hint that something is wrong */
+		return 0;
+
+	val >>= div->shift;
+	val &= clk_div_mask(div->width);
+	return divider_recalc_rate(hw, prate, val, div->table, div->flags,
+				   div->width);
+}
+
+static int clk_regmap_div_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	unsigned int val;
+	int ret;
+
+	/* if read only, just return current value */
+	if (div->flags & CLK_DIVIDER_READ_ONLY) {
+		ret = regmap_read(clk->map, div->offset, &val);
+		if (ret)
+			return ret;
+
+		val >>= div->shift;
+		val &= clk_div_mask(div->width);
+
+		return divider_ro_determine_rate(hw, req, div->table,
+						 div->width, div->flags, val);
+	}
+
+	return divider_determine_rate(hw, req, div->table, div->width,
+				      div->flags);
+}
+
+static int clk_regmap_div_set_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long parent_rate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_div_data *div = clk_get_regmap_div_data(clk);
+	unsigned int val;
+	int ret;
+
+	ret = divider_get_val(rate, parent_rate, div->table, div->width,
+			      div->flags);
+	if (ret < 0)
+		return ret;
+
+	val = (unsigned int)ret << div->shift;
+	return regmap_update_bits(clk->map, div->offset,
+				  clk_div_mask(div->width) << div->shift, val);
+};
+
+/* Would prefer clk_regmap_div_ro_ops but clashes with qcom */
+
+const struct clk_ops clk_regmap_divider_ops = {
+	.recalc_rate = clk_regmap_div_recalc_rate,
+	.determine_rate = clk_regmap_div_determine_rate,
+	.set_rate = clk_regmap_div_set_rate,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_divider_ops);
+
+const struct clk_ops clk_regmap_divider_ro_ops = {
+	.recalc_rate = clk_regmap_div_recalc_rate,
+	.determine_rate = clk_regmap_div_determine_rate,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_divider_ro_ops);
+
+static u8 clk_regmap_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(clk->map, mux->offset, &val);
+	if (ret)
+		return ret;
+
+	val >>= mux->shift;
+	val &= mux->mask;
+	return clk_mux_val_to_index(hw, mux->table, mux->flags, val);
+}
+
+static int clk_regmap_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+	unsigned int val = clk_mux_index_to_val(mux->table, mux->flags, index);
+
+	return regmap_update_bits(clk->map, mux->offset,
+				  mux->mask << mux->shift,
+				  val << mux->shift);
+}
+
+static int clk_regmap_mux_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	struct clk_regmap_mux_data *mux = clk_get_regmap_mux_data(clk);
+
+	return clk_mux_determine_rate_flags(hw, req, mux->flags);
+}
+
+const struct clk_ops clk_regmap_mux_ops = {
+	.get_parent = clk_regmap_mux_get_parent,
+	.set_parent = clk_regmap_mux_set_parent,
+	.determine_rate = clk_regmap_mux_determine_rate,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_mux_ops);
+
+const struct clk_ops clk_regmap_mux_ro_ops = {
+	.get_parent = clk_regmap_mux_get_parent,
+};
+EXPORT_SYMBOL_GPL(clk_regmap_mux_ro_ops);
+
+MODULE_DESCRIPTION("Amlogic regmap backed clock driver");
+MODULE_AUTHOR("Jerome Brunet <jbrunet@baylibre.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/clk-scmi.c b/drivers/clk/clk-scmi.c
index fdec715c9..757de52e2 100644
--- a/drivers/clk/clk-scmi.c
+++ b/drivers/clk/clk-scmi.c
@@ -9,6 +9,7 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/of.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/scmi_protocol.h>
 #include <asm/div64.h>
@@ -37,6 +38,37 @@ static unsigned long scmi_clk_recalc_rate(struct clk_hw *hw,
 	return rate;
 }
 
+static unsigned long scmi_clk_round_rate_get(struct clk_hw *hw,
+					     unsigned long rate,
+					     unsigned long *parent_rate)
+{
+	int ret;
+	u64 round_rate = rate;
+	struct scmi_clk *clk = to_scmi_clk(hw);
+
+	ret = scmi_proto_clk_ops->round_rate_get(clk->ph, clk->id, &round_rate);
+	if (ret)
+		return 0;
+
+	return round_rate;
+}
+
+static int scmi_clk_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)
+{
+	struct scmi_clk *clk = to_scmi_clk(hw);
+	int ret;
+
+	ret = scmi_proto_clk_ops->get_duty_cycle(clk->ph, clk->id,
+						 &duty->num, &duty->den);
+	if (ret) {
+		/* Assume a default value of 50% */
+		duty->num = 1;
+		duty->den = 2;
+	}
+
+	return 0;
+}
+
 static long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 				unsigned long *parent_rate)
 {
@@ -59,6 +91,9 @@ static long scmi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 	else if (rate >= fmax)
 		return fmax;
 
+	if (clk->info->range.step_size == 0)
+		return scmi_clk_round_rate_get(hw, rate, parent_rate);
+
 	ftmp = rate - fmin;
 	ftmp += clk->info->range.step_size - 1; /* to round up */
 	do_div(ftmp, clk->info->range.step_size);
@@ -121,6 +156,7 @@ static const struct clk_ops scmi_clk_ops = {
 	.set_rate = scmi_clk_set_rate,
 	.prepare = scmi_clk_enable,
 	.unprepare = scmi_clk_disable,
+	.get_duty_cycle = scmi_clk_get_duty_cycle,
 };
 
 static const struct clk_ops scmi_atomic_clk_ops = {
@@ -129,6 +165,7 @@ static const struct clk_ops scmi_atomic_clk_ops = {
 	.set_rate = scmi_clk_set_rate,
 	.enable = scmi_clk_atomic_enable,
 	.disable = scmi_clk_atomic_disable,
+	.get_duty_cycle = scmi_clk_get_duty_cycle,
 };
 
 static int scmi_clk_ops_init(struct device *dev, struct scmi_clk *sclk,
diff --git a/drivers/clk/clk-stm32mp1.c b/drivers/clk/clk-stm32mp1.c
index 7ad2e6203..8cac8fe06 100644
--- a/drivers/clk/clk-stm32mp1.c
+++ b/drivers/clk/clk-stm32mp1.c
@@ -116,11 +116,11 @@ static const char * const ref3_parents[] = {
 };
 
 static const char * const ref4_parents[] = {
-	"ck_hsi", "ck_hse", "ck_csi"
+	"ck_hsi", "ck_hse", "ck_csi", "i2s_ckin"
 };
 
 static const char * const cpu_src[] = {
-	"ck_hsi", "ck_hse", "pll1_p"
+	"ck_hsi", "ck_hse", "pll1_p", "pll1_p_div"
 };
 
 static const char * const axi_src[] = {
@@ -298,6 +298,7 @@ static const struct clk_div_table ck_trace_div_table[] = {
 struct stm32_mmux {
 	u8 nbr_clk;
 	struct clk_hw *hws[MAX_MUX_CLK];
+	u8 saved_parent;
 };
 
 struct stm32_clk_mmux {
@@ -727,7 +728,7 @@ static int clk_mmux_set_parent(struct clk_hw *hw, u8 index)
 
 	for (n = 0; n < clk_mmux->mmux->nbr_clk; n++)
 		if (clk_mmux->mmux->hws[n] != hw)
-			clk_hw_reparent(clk_mmux->mmux->hws[n], hwp);
+			clk_hw_set_parent(clk_mmux->mmux->hws[n], hwp);
 
 	return 0;
 }
@@ -738,156 +739,212 @@ static const struct clk_ops clk_mmux_ops = {
 	.determine_rate	= __clk_mux_determine_rate,
 };
 
-/* STM32 PLL */
-struct stm32_pll_obj {
-	/* lock pll enable/disable registers */
-	spinlock_t *lock;
-	void __iomem *reg;
-	struct clk_hw hw;
-	struct clk_mux mux;
-};
+static bool is_all_clk_on_switch_are_off(struct clk_hw *hw)
+{
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
+	int i = 0;
 
-#define to_pll(_hw) container_of(_hw, struct stm32_pll_obj, hw)
+	for (i = 0; i < clk_mmux->mmux->nbr_clk; i++)
+		if (__clk_is_enabled(clk_mmux->mmux->hws[i]->clk))
+			return false;
 
-#define PLL_ON		BIT(0)
-#define PLL_RDY		BIT(1)
-#define DIVN_MASK	0x1FF
-#define DIVM_MASK	0x3F
-#define DIVM_SHIFT	16
-#define DIVN_SHIFT	0
-#define FRAC_OFFSET	0xC
-#define FRAC_MASK	0x1FFF
-#define FRAC_SHIFT	3
-#define FRACLE		BIT(16)
-#define PLL_MUX_SHIFT	0
-#define PLL_MUX_MASK	3
+	return true;
+}
 
-static int __pll_is_enabled(struct clk_hw *hw)
+#define MMUX_SAFE_POSITION 0
+
+static int clk_mmux_set_safe_position(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	return readl_relaxed(clk_elem->reg) & PLL_ON;
-}
+	clk_mmux->mmux->saved_parent = clk_mmux_get_parent(mux_hw);
+	clk_mux_ops.set_parent(mux_hw, MMUX_SAFE_POSITION);
 
-#define TIMEOUT 5
+	return 0;
+}
 
-static int pll_enable(struct clk_hw *hw)
+static int clk_mmux_restore_parent(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	unsigned long flags = 0;
-	unsigned int timeout = TIMEOUT;
-	int bit_status = 0;
+	struct clk_composite *composite = to_clk_composite(hw);
+	struct clk_hw *mux_hw = composite->mux_hw;
+	struct clk_mux *mux = to_clk_mux(mux_hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	spin_lock_irqsave(clk_elem->lock, flags);
+	clk_mux_ops.set_parent(mux_hw, clk_mmux->mmux->saved_parent);
 
-	if (__pll_is_enabled(hw))
-		goto unlock;
+	return 0;
+}
 
-	reg = readl_relaxed(clk_elem->reg);
-	reg |= PLL_ON;
-	writel_relaxed(reg, clk_elem->reg);
+static u8 clk_mmux_get_parent_safe(struct clk_hw *hw)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-	/* We can't use readl_poll_timeout() because we can be blocked if
-	 * someone enables this clock before clocksource changes.
-	 * Only jiffies counter is available. Jiffies are incremented by
-	 * interruptions and enable op does not allow to be interrupted.
-	 */
-	do {
-		bit_status = !(readl_relaxed(clk_elem->reg) & PLL_RDY);
+	clk_mmux->mmux->saved_parent = clk_mmux_get_parent(hw);
 
-		if (bit_status)
-			udelay(120);
+	return clk_mmux->mmux->saved_parent;
+}
 
-	} while (bit_status && --timeout);
+static int clk_mmux_set_parent_safe(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	struct stm32_clk_mmux *clk_mmux = to_clk_mmux(mux);
 
-unlock:
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	clk_mmux_set_parent(hw, index);
+	clk_mmux->mmux->saved_parent = index;
 
-	return bit_status;
+	return 0;
 }
 
-static void pll_disable(struct clk_hw *hw)
-{
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	unsigned long flags = 0;
+static const struct clk_ops clk_mmux_safe_ops = {
+	.get_parent	= clk_mmux_get_parent_safe,
+	.set_parent	= clk_mmux_set_parent_safe,
+	.determine_rate	= __clk_mux_determine_rate,
+};
 
-	spin_lock_irqsave(clk_elem->lock, flags);
+static int mp1_mgate_clk_enable_safe(struct clk_hw *hw)
+{
+	struct clk_hw *composite_hw = __clk_get_hw(hw->clk);
 
-	reg = readl_relaxed(clk_elem->reg);
-	reg &= ~PLL_ON;
-	writel_relaxed(reg, clk_elem->reg);
+	clk_mmux_restore_parent(composite_hw);
+	mp1_mgate_clk_enable(hw);
 
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	return  0;
 }
 
-static u32 pll_frac_val(struct clk_hw *hw)
+static void mp1_mgate_clk_disable_safe(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg, frac = 0;
+	struct clk_hw *composite_hw = __clk_get_hw(hw->clk);
 
-	reg = readl_relaxed(clk_elem->reg + FRAC_OFFSET);
-	if (reg & FRACLE)
-		frac = (reg >> FRAC_SHIFT) & FRAC_MASK;
+	mp1_mgate_clk_disable(hw);
 
-	return frac;
+	if (is_all_clk_on_switch_are_off(composite_hw))
+		clk_mmux_set_safe_position(composite_hw);
 }
 
-static unsigned long pll_recalc_rate(struct clk_hw *hw,
-				     unsigned long parent_rate)
-{
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	u32 reg;
-	u32 frac, divm, divn;
-	u64 rate, rate_frac = 0;
+static const struct clk_ops mp1_mgate_clk_safe_ops = {
+	.enable		= mp1_mgate_clk_enable_safe,
+	.disable	= mp1_mgate_clk_disable_safe,
+	.is_enabled	= clk_gate_is_enabled,
+};
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+
+	/* lock pll enable/disable registers */
+	spinlock_t *lock;
+};
 
-	reg = readl_relaxed(clk_elem->reg + 4);
+#define to_pll_fractional_divider(_hw)\
+	container_of(_hw, struct clk_pll_fractional_divider, hw)
 
-	divm = ((reg >> DIVM_SHIFT) & DIVM_MASK) + 1;
-	divn = ((reg >> DIVN_SHIFT) & DIVN_MASK) + 1;
-	rate = (u64)parent_rate * divn;
+static unsigned long clk_pll_frac_div_recalc_rate(struct clk_hw *hw,
+						  unsigned long parent_rate)
+{
+	struct clk_pll_fractional_divider *fd = to_pll_fractional_divider(hw);
+	u32 mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	u32 nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	u32 fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
 
-	do_div(rate, divm);
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
 
-	frac = pll_frac_val(hw);
-	if (frac) {
-		rate_frac = (u64)parent_rate * (u64)frac;
-		do_div(rate_frac, (divm * 8192));
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
 	}
-
-	return rate + rate_frac;
+	return rate + frate;
 }
 
-static int pll_is_enabled(struct clk_hw *hw)
+static const struct clk_ops clk_pll_frac_div_ops = {
+	.recalc_rate	= clk_pll_frac_div_recalc_rate,
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+#define TIMEOUT 5
+
+static int pll_enable(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	unsigned long flags = 0;
-	int ret;
+	struct clk_gate *gate = to_clk_gate(hw);
+	u32 timeout = TIMEOUT;
+	int bit_status = 0;
 
-	spin_lock_irqsave(clk_elem->lock, flags);
-	ret = __pll_is_enabled(hw);
-	spin_unlock_irqrestore(clk_elem->lock, flags);
+	if (clk_gate_ops.is_enabled(hw))
+		return 0;
 
-	return ret;
+	clk_gate_ops.enable(hw);
+
+	do {
+		bit_status = !(readl_relaxed(gate->reg) & BIT(PLL_BIT_RDY));
+
+		if (bit_status)
+			udelay(120);
+
+	} while (bit_status && --timeout);
+
+	return bit_status;
 }
 
-static u8 pll_get_parent(struct clk_hw *hw)
+static void pll_disable(struct clk_hw *hw)
 {
-	struct stm32_pll_obj *clk_elem = to_pll(hw);
-	struct clk_hw *mux_hw = &clk_elem->mux.hw;
-
-	__clk_hw_set_clk(mux_hw, hw);
+	if (!clk_gate_ops.is_enabled(hw))
+		return;
 
-	return clk_mux_ops.get_parent(mux_hw);
+	clk_gate_ops.disable(hw);
 }
 
-static const struct clk_ops pll_ops = {
+const struct clk_ops pll_gate_ops = {
 	.enable		= pll_enable,
 	.disable	= pll_disable,
-	.recalc_rate	= pll_recalc_rate,
-	.is_enabled	= pll_is_enabled,
-	.get_parent	= pll_get_parent,
+	.is_enabled	= clk_gate_is_enabled,
 };
 
 static struct clk_hw *clk_register_pll(struct device *dev, const char *name,
@@ -898,39 +955,50 @@ static struct clk_hw *clk_register_pll(struct device *dev, const char *name,
 				       unsigned long flags,
 				       spinlock_t *lock)
 {
-	struct stm32_pll_obj *element;
-	struct clk_init_data init;
-	struct clk_hw *hw;
-	int err;
+	struct clk_pll_fractional_divider *frac_div;
+	struct clk_gate *gate;
+	struct clk_mux *mux;
 
-	element = devm_kzalloc(dev, sizeof(*element), GFP_KERNEL);
-	if (!element)
+	mux = devm_kzalloc(dev, sizeof(*mux), GFP_KERNEL);
+	if (!mux)
 		return ERR_PTR(-ENOMEM);
 
-	init.name = name;
-	init.ops = &pll_ops;
-	init.flags = flags;
-	init.parent_names = parent_names;
-	init.num_parents = num_parents;
+	mux->reg = mux_reg;
+	mux->shift = PLL_MUX_SHIFT;
+	mux->mask = PLL_MUX_MASK;
+	mux->flags = CLK_MUX_READ_ONLY;
+	mux->table = NULL;
+	mux->lock = lock;
 
-	element->mux.lock = lock;
-	element->mux.reg =  mux_reg;
-	element->mux.shift = PLL_MUX_SHIFT;
-	element->mux.mask =  PLL_MUX_MASK;
-	element->mux.flags =  CLK_MUX_READ_ONLY;
-	element->mux.reg =  mux_reg;
+	gate = devm_kzalloc(dev, sizeof(*gate), GFP_KERNEL);
+	if (!gate)
+		return ERR_PTR(-ENOMEM);
 
-	element->hw.init = &init;
-	element->reg = reg;
-	element->lock = lock;
+	gate->reg = reg;
+	gate->bit_idx = PLL_BIT_ON;
+	gate->flags = 0;
+	gate->lock = lock;
 
-	hw = &element->hw;
-	err = clk_hw_register(dev, hw);
+	frac_div = devm_kzalloc(dev, sizeof(*frac_div), GFP_KERNEL);
+	if (!frac_div)
+		return ERR_PTR(-ENOMEM);
 
-	if (err)
-		return ERR_PTR(err);
+	frac_div->mreg = reg + PLL_DIVMN_OFFSET;
+	frac_div->mshift = PLL_DIVM_SHIFT;
+	frac_div->mwidth = PLL_DIVM_WIDTH;
+	frac_div->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	frac_div->nreg = reg + PLL_DIVMN_OFFSET;
+	frac_div->nshift = PLL_DIVN_SHIFT;
+	frac_div->nwidth = PLL_DIVN_WIDTH;
+	frac_div->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	frac_div->freg = reg + PLL_FRAC_OFFSET;
+	frac_div->fshift = PLL_FRAC_SHIFT;
+	frac_div->fwidth = PLL_FRAC_WIDTH;
 
-	return hw;
+	return clk_hw_register_composite(dev, name, parent_names, num_parents,
+					 &mux->hw, &clk_mux_ops,
+					 &frac_div->hw, &clk_pll_frac_div_ops,
+					 &gate->hw, &pll_gate_ops, flags);
 }
 
 /* Kernel Timer */
@@ -1100,9 +1168,49 @@ static const struct clk_ops rtc_div_clk_ops = {
 	.determine_rate = clk_divider_rtc_determine_rate
 };
 
+static int clk_div_get_duty_cycle(struct clk_hw *hw, struct clk_duty *duty)
+{
+	struct clk_divider *divider = to_clk_divider(hw);
+	unsigned int val;
+
+	val = readl(divider->reg) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+
+	duty->num = (val + 1) / 2;
+	duty->den = (val + 1);
+
+	return 0;
+}
+
+static unsigned long clk_div_duty_cycle_recalc_rate(struct clk_hw *hw,
+						    unsigned long parent_rate)
+{
+	return clk_divider_ops.recalc_rate(hw, parent_rate);
+}
+
+static long clk_div_duty_cycle_round_rate(struct clk_hw *hw, unsigned long rate,
+					  unsigned long *prate)
+{
+	return clk_divider_ops.round_rate(hw, rate, prate);
+}
+
+static int clk_div_duty_cycle_set_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	return clk_divider_ops.set_rate(hw, rate, parent_rate);
+}
+
+static const struct clk_ops div_dc_clk_ops = {
+	.recalc_rate	= clk_div_duty_cycle_recalc_rate,
+	.round_rate	= clk_div_duty_cycle_round_rate,
+	.set_rate	= clk_div_duty_cycle_set_rate,
+	.get_duty_cycle = clk_div_get_duty_cycle,
+};
+
 struct stm32_pll_cfg {
 	u32 offset;
 	u32 muxoff;
+	const struct clk_ops *ops;
 };
 
 static struct clk_hw *_clk_register_pll(struct device *dev,
@@ -1302,7 +1410,7 @@ _clk_stm32_register_composite(struct device *dev,
 		    NULL, &mp1_gate_clk_ops)\
 
 #define _MGATE_MP1(_mgate)\
-	.gate = &per_gate_cfg[_mgate]
+	&per_gate_cfg[_mgate]
 
 #define GATE_MP1(_id, _name, _parent, _flags, _offset, _bit_idx, _gate_flags)\
 	STM32_GATE(_id, _name, _parent, _flags,\
@@ -1318,7 +1426,7 @@ _clk_stm32_register_composite(struct device *dev,
 
 #define _STM32_DIV(_div_offset, _div_shift, _div_width,\
 		   _div_flags, _div_table, _ops)\
-	.div = &(struct stm32_div_cfg) {\
+	(&(struct stm32_div_cfg) {\
 		&(struct div_cfg) {\
 			.reg_off	= _div_offset,\
 			.shift		= _div_shift,\
@@ -1327,18 +1435,23 @@ _clk_stm32_register_composite(struct device *dev,
 			.table		= _div_table,\
 		},\
 		.ops		= _ops,\
-	}
+	})
 
 #define _DIV(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\
 	_STM32_DIV(_div_offset, _div_shift, _div_width,\
-		   _div_flags, _div_table, NULL)\
+		   _div_flags, _div_table, NULL)
+
+#define _DIV_DUTY_CYCLE(_div_offset, _div_shift, _div_width, _div_flags,\
+			_div_table)\
+	_STM32_DIV(_div_offset, _div_shift, _div_width,\
+		   _div_flags, _div_table, &div_dc_clk_ops)
 
 #define _DIV_RTC(_div_offset, _div_shift, _div_width, _div_flags, _div_table)\
 	_STM32_DIV(_div_offset, _div_shift, _div_width,\
 		   _div_flags, _div_table, &rtc_div_clk_ops)
 
 #define _STM32_MUX(_offset, _shift, _width, _mux_flags, _mmux, _ops)\
-	.mux = &(struct stm32_mux_cfg) {\
+	(&(struct stm32_mux_cfg) {\
 		&(struct mux_cfg) {\
 			.reg_off	= _offset,\
 			.shift		= _shift,\
@@ -1348,18 +1461,18 @@ _clk_stm32_register_composite(struct device *dev,
 		},\
 		.mmux		= _mmux,\
 		.ops		= _ops,\
-	}
+	})
 
 #define _MUX(_offset, _shift, _width, _mux_flags)\
-	_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)\
+	_STM32_MUX(_offset, _shift, _width, _mux_flags, NULL, NULL)
 
-#define _MMUX(_mmux) .mux = &ker_mux_cfg[_mmux]
+#define _MMUX(_mmux)		&ker_mux_cfg[_mmux]
 
-#define PARENT(_parent) ((const char *[]) { _parent})
+#define PARENT(_parent)		((const char *[]) { _parent})
 
-#define _NO_MUX .mux = NULL
-#define _NO_DIV .div = NULL
-#define _NO_GATE .gate = NULL
+#define _NO_MUX			NULL
+#define _NO_DIV			NULL
+#define _NO_GATE		NULL
 
 #define COMPOSITE(_id, _name, _parents, _flags, _gate, _mux, _div)\
 {\
@@ -1369,9 +1482,9 @@ _clk_stm32_register_composite(struct device *dev,
 	.num_parents	= ARRAY_SIZE(_parents),\
 	.flags		= _flags,\
 	.cfg		= &(struct stm32_composite_cfg) {\
-		_gate,\
-		_mux,\
-		_div,\
+		.gate = (_gate),\
+		.mux = (_mux),\
+		.div = (_div),\
 	},\
 	.func		= _clk_stm32_register_composite,\
 }
@@ -1526,6 +1639,10 @@ static struct stm32_mgate mp1_mgate[G_LAST];
 	_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\
 	       &mp1_mgate[_id], &mp1_mgate_clk_ops)
 
+#define K_MGATE_SAFE(_id, _gate_offset, _gate_bit_idx, _gate_flags)\
+	_K_GATE(_id, _gate_offset, _gate_bit_idx, _gate_flags,\
+		&mp1_mgate[_id], &mp1_mgate_clk_safe_ops)
+
 /* Peripheral gates */
 static struct stm32_gate_cfg per_gate_cfg[G_LAST] = {
 	/* Multi gates */
@@ -1637,10 +1754,10 @@ static struct stm32_gate_cfg per_gate_cfg[G_LAST] = {
 
 	K_GATE(G_USBH,		RCC_AHB6ENSETR, 24, 0),
 	K_GATE(G_CRC1,		RCC_AHB6ENSETR, 20, 0),
-	K_MGATE(G_SDMMC2,	RCC_AHB6ENSETR, 17, 0),
-	K_MGATE(G_SDMMC1,	RCC_AHB6ENSETR, 16, 0),
-	K_MGATE(G_QSPI,		RCC_AHB6ENSETR, 14, 0),
-	K_MGATE(G_FMC,		RCC_AHB6ENSETR, 12, 0),
+	K_MGATE_SAFE(G_SDMMC2,	RCC_AHB6ENSETR, 17, 0),
+	K_MGATE_SAFE(G_SDMMC1,	RCC_AHB6ENSETR, 16, 0),
+	K_MGATE_SAFE(G_QSPI,	RCC_AHB6ENSETR, 14, 0),
+	K_MGATE_SAFE(G_FMC,	RCC_AHB6ENSETR, 12, 0),
 	K_GATE(G_ETHMAC,	RCC_AHB6ENSETR, 10, 0),
 	K_GATE(G_ETHRX,		RCC_AHB6ENSETR, 9, 0),
 	K_GATE(G_ETHTX,		RCC_AHB6ENSETR, 8, 0),
@@ -1712,9 +1829,13 @@ static struct stm32_mmux ker_mux[M_LAST];
 	_K_MUX(_id, _offset, _shift, _width, _mux_flags,\
 			&ker_mux[_id], &clk_mmux_ops)
 
+#define K_MMUX_SAFE(_id, _offset, _shift, _width, _mux_flags)\
+	_K_MUX(_id, _offset, _shift, _width, _mux_flags,\
+			&ker_mux[_id], &clk_mmux_safe_ops)
+
 static const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {
 	/* Kernel multi mux */
-	K_MMUX(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),
+	K_MMUX_SAFE(M_SDMMC12, RCC_SDMMC12CKSELR, 0, 3, 0),
 	K_MMUX(M_SPI23, RCC_SPI2S23CKSELR, 0, 3, 0),
 	K_MMUX(M_SPI45, RCC_SPI2S45CKSELR, 0, 3, 0),
 	K_MMUX(M_I2C12, RCC_I2C12CKSELR, 0, 3, 0),
@@ -1731,8 +1852,8 @@ static const struct stm32_mux_cfg ker_mux_cfg[M_LAST] = {
 	/*  Kernel simple mux */
 	K_MUX(M_RNG2, RCC_RNG2CKSELR, 0, 2, 0),
 	K_MUX(M_SDMMC3, RCC_SDMMC3CKSELR, 0, 3, 0),
-	K_MUX(M_FMC, RCC_FMCCKSELR, 0, 2, 0),
-	K_MUX(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),
+	K_MMUX_SAFE(M_FMC, RCC_FMCCKSELR, 0, 2, 0),
+	K_MMUX_SAFE(M_QSPI, RCC_QSPICKSELR, 0, 2, 0),
 	K_MUX(M_USBPHY, RCC_USBCKSELR, 0, 2, 0),
 	K_MUX(M_USBO, RCC_USBCKSELR, 4, 1, 0),
 	K_MUX(M_SPDIF, RCC_SPDIFCKSELR, 0, 2, 0),
@@ -1776,7 +1897,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PLL(PLL4, "pll4", ref4_parents, 0, RCC_PLL4CR, RCC_RCK4SELR),
 
 	/* ODF */
-	COMPOSITE(PLL1_P, "pll1_p", PARENT("pll1"), 0,
+	COMPOSITE(PLL1_P, "pll1_p", PARENT("pll1"), CLK_SET_RATE_PARENT,
 		  _GATE(RCC_PLL1CR, 4, 0),
 		  _NO_MUX,
 		  _DIV(RCC_PLL1CFGR2, 0, 7, 0, NULL)),
@@ -1804,7 +1925,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	COMPOSITE(PLL3_Q, "pll3_q", PARENT("pll3"), 0,
 		  _GATE(RCC_PLL3CR, 5, 0),
 		  _NO_MUX,
-		  _DIV(RCC_PLL3CFGR2, 8, 7, 0, NULL)),
+		  _DIV_DUTY_CYCLE(RCC_PLL3CFGR2, 8, 7, 0, NULL)),
 
 	COMPOSITE(PLL3_R, "pll3_r", PARENT("pll3"), 0,
 		  _GATE(RCC_PLL3CR, 6, 0),
@@ -1824,40 +1945,40 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	COMPOSITE(PLL4_R, "pll4_r", PARENT("pll4"), 0,
 		  _GATE(RCC_PLL4CR, 6, 0),
 		  _NO_MUX,
-		  _DIV(RCC_PLL4CFGR2, 16, 7, 0, NULL)),
+		  _DIV_DUTY_CYCLE(RCC_PLL4CFGR2, 16, 7, 0, NULL)),
 
 	/* MUX system clocks */
 	MUX(CK_PER, "ck_per", per_src, CLK_OPS_PARENT_ENABLE,
 	    RCC_CPERCKSELR, 0, 2, 0),
 
 	MUX(CK_MPU, "ck_mpu", cpu_src, CLK_OPS_PARENT_ENABLE |
-	     CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),
+	    CLK_SET_RATE_PARENT | CLK_IS_CRITICAL, RCC_MPCKSELR, 0, 2, 0),
 
 	COMPOSITE(CK_AXI, "ck_axi", axi_src, CLK_IS_CRITICAL |
-		   CLK_OPS_PARENT_ENABLE,
-		   _NO_GATE,
-		   _MUX(RCC_ASSCKSELR, 0, 2, 0),
-		   _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),
+		  CLK_OPS_PARENT_ENABLE,
+		  _NO_GATE,
+		  _MUX(RCC_ASSCKSELR, 0, 2, 0),
+		  _DIV(RCC_AXIDIVR, 0, 3, 0, axi_div_table)),
 
 	COMPOSITE(CK_MCU, "ck_mcu", mcu_src, CLK_IS_CRITICAL |
-		   CLK_OPS_PARENT_ENABLE,
-		   _NO_GATE,
-		   _MUX(RCC_MSSCKSELR, 0, 2, 0),
-		   _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),
+		  CLK_OPS_PARENT_ENABLE,
+		  _NO_GATE,
+		  _MUX(RCC_MSSCKSELR, 0, 2, 0),
+		  _DIV(RCC_MCUDIVR, 0, 4, 0, mcu_div_table)),
 
-	DIV_TABLE(NO_ID, "pclk1", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,
+	DIV_TABLE(PCLK1, "pclk1", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB1DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk2", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,
+	DIV_TABLE(PCLK2, "pclk2", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB2DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk3", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,
+	DIV_TABLE(PCLK3, "pclk3", "ck_mcu", CLK_IGNORE_UNUSED, RCC_APB3DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk4", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,
+	DIV_TABLE(PCLK4, "pclk4", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB4DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
-	DIV_TABLE(NO_ID, "pclk5", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,
+	DIV_TABLE(PCLK5, "pclk5", "ck_axi", CLK_IGNORE_UNUSED, RCC_APB5DIVR, 0,
 		  3, CLK_DIVIDER_READ_ONLY, apb_div_table),
 
 	/* Kernel Timers */
@@ -1939,8 +2060,7 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PCLK(I2C4, "i2c4", "pclk5", 0, G_I2C4),
 	PCLK(I2C6, "i2c6", "pclk5", 0, G_I2C6),
 	PCLK(USART1, "usart1", "pclk5", 0, G_USART1),
-	PCLK(RTCAPB, "rtcapb", "pclk5", CLK_IGNORE_UNUSED |
-	     CLK_IS_CRITICAL, G_RTCAPB),
+	PCLK(RTCAPB, "rtcapb", "pclk5", CLK_IS_CRITICAL, G_RTCAPB),
 	PCLK(TZC1, "tzc1", "ck_axi", CLK_IGNORE_UNUSED, G_TZC1),
 	PCLK(TZC2, "tzc2", "ck_axi", CLK_IGNORE_UNUSED, G_TZC2),
 	PCLK(TZPC, "tzpc", "pclk5", CLK_IGNORE_UNUSED, G_TZPC),
@@ -1981,10 +2101,6 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	PCLK(ETHTX, "ethtx", "ck_axi", 0, G_ETHTX),
 	PCLK_PDATA(ETHRX, "ethrx", ethrx_src, 0, G_ETHRX),
 	PCLK(ETHMAC, "ethmac", "ck_axi", 0, G_ETHMAC),
-	PCLK(FMC, "fmc", "ck_axi", CLK_IGNORE_UNUSED, G_FMC),
-	PCLK(QSPI, "qspi", "ck_axi", CLK_IGNORE_UNUSED, G_QSPI),
-	PCLK(SDMMC1, "sdmmc1", "ck_axi", 0, G_SDMMC1),
-	PCLK(SDMMC2, "sdmmc2", "ck_axi", 0, G_SDMMC2),
 	PCLK(CRC1, "crc1", "ck_axi", 0, G_CRC1),
 	PCLK(USBH, "usbh", "ck_axi", 0, G_USBH),
 	PCLK(ETHSTP, "ethstp", "ck_axi", 0, G_ETHSTP),
@@ -2078,7 +2194,8 @@ static const struct clock_config stm32mp1_clock_cfg[] = {
 	GATE(CK_DBG, "ck_sys_dbg", "ck_axi", CLK_IGNORE_UNUSED,
 	     RCC_DBGCFGR, 8, 0),
 
-	COMPOSITE(CK_TRACE, "ck_trace", ck_trace_src, CLK_OPS_PARENT_ENABLE,
+	COMPOSITE(CK_TRACE, "ck_trace", ck_trace_src,
+		  CLK_OPS_PARENT_ENABLE | CLK_IGNORE_UNUSED,
 		  _GATE(RCC_DBGCFGR, 9, 0),
 		  _NO_MUX,
 		  _DIV(RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table)),
@@ -2368,6 +2485,8 @@ static int stm32_rcc_init(struct device *dev, void __iomem *base,
 	return 0;
 }
 
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base);
+
 static int stm32mp1_rcc_init(struct device *dev)
 {
 	void __iomem *base;
@@ -2388,6 +2507,8 @@ static int stm32mp1_rcc_init(struct device *dev)
 			iounmap(base);
 
 		of_node_put(dev_of_node(dev));
+	} else {
+		stm32_clk_summary_debugfs_create(dev, base);
 	}
 
 	return ret;
@@ -2459,3 +2580,1183 @@ static int __init stm32mp1_clocks_init(void)
 	return platform_driver_register(&stm32mp1_rcc_clocks_driver);
 }
 core_initcall(stm32mp1_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+#define NO_STM32_MUX		0xFFFF
+#define NO_STM32_DIV		0xFFFF
+#define NO_STM32_GATE		0xFFFF
+
+enum enum_gate_cfg {
+	GATE_HSI,
+	GATE_CSI,
+	GATE_LSI,
+	GATE_HSE,
+	GATE_LSE,
+	GATE_PLL1,
+	GATE_PLL2,
+	GATE_PLL3,
+	GATE_PLL4,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
+	GATE_RTCCK,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_DBGCK,
+	GATE_TRACECK,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPDIF,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_USART2,
+	GATE_UART4,
+	GATE_USART3,
+	GATE_UART5,
+	GATE_USART1,
+	GATE_USART6,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_LTDC,
+	GATE_DSI,
+	GATE_QSPI,
+	GATE_FMC,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_USBO,
+	GATE_USBPHY,
+	GATE_RNG1,
+	GATE_RNG2,
+	GATE_FDCAN,
+	GATE_DAC12,
+	GATE_CEC,
+	GATE_ADC12,
+	GATE_GPU,
+	GATE_STGEN,
+	GATE_DFSDM,
+	GATE_ADFSDM,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_MDIO,
+	GATE_TIM1,
+	GATE_TIM8,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_SYSCFG,
+	GATE_VREF,
+	GATE_TMPSENS,
+	GATE_PMBCTRL,
+	GATE_HDP,
+	GATE_IWDG2,
+	GATE_STGENRO,
+	GATE_DMA1,
+	GATE_DMA2,
+	GATE_DMAMUX,
+	GATE_DCMI,
+	GATE_CRYP2,
+	GATE_HASH2,
+	GATE_CRC2,
+	GATE_HSEM,
+	GATE_IPCC,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_GPIOJ,
+	GATE_GPIOK,
+	GATE_MDMA,
+	GATE_ETHCK,
+	GATE_ETHTX,
+	GATE_ETHRX,
+	GATE_ETHMAC,
+	GATE_CRC1,
+	GATE_USBH,
+	GATE_ETHSTP,
+	GATE_RTCAPB,
+	GATE_TZC1,
+	GATE_TZC2,
+	GATE_TZPC,
+	GATE_IWDG1,
+	GATE_BSEC,
+	GATE_GPIOZ,
+	GATE_CRYP1,
+	GATE_HASH1,
+	GATE_BKPSRAM,
+	GATE_DDRPERFM,
+
+	GATE_NB
+};
+
+struct cs_gate_cfg {
+	u16	offset;
+	u8	bit_idx;
+};
+
+#define CFG_GATE(_id, _offset, _bit_idx)\
+	[(_id)] = {\
+		.offset = (_offset),\
+		.bit_idx = (_bit_idx),\
+	}
+
+static struct cs_gate_cfg stm32mp15_gates[] = {
+	CFG_GATE(GATE_HSI,		RCC_OCENSETR,	0),
+	CFG_GATE(GATE_CSI,		RCC_OCENSETR,	4),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,	0),
+	CFG_GATE(GATE_HSE,		RCC_OCENSETR,	8),
+	CFG_GATE(GATE_LSE,		RCC_BDCR,	0),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,	20),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,	0),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,	4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,	5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,	6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,	0),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,	4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,	5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,	6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,	0),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,	4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,	5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,	6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,	0),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,	4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,	5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,	6),
+	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,	12),
+	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,	12),
+	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,	8),
+	CFG_GATE(GATE_TRACECK,		RCC_DBGCFGR,	9),
+	CFG_GATE(GATE_MDIO,		RCC_APB1ENSETR, 31),
+	CFG_GATE(GATE_DAC12,		RCC_APB1ENSETR, 29),
+	CFG_GATE(GATE_CEC,		RCC_APB1ENSETR, 27),
+	CFG_GATE(GATE_SPDIF,		RCC_APB1ENSETR, 26),
+	CFG_GATE(GATE_I2C5,		RCC_APB1ENSETR, 24),
+	CFG_GATE(GATE_I2C3,		RCC_APB1ENSETR, 23),
+	CFG_GATE(GATE_I2C2,		RCC_APB1ENSETR, 22),
+	CFG_GATE(GATE_I2C1,		RCC_APB1ENSETR, 21),
+	CFG_GATE(GATE_UART8,		RCC_APB1ENSETR, 19),
+	CFG_GATE(GATE_UART7,		RCC_APB1ENSETR, 18),
+	CFG_GATE(GATE_UART5,		RCC_APB1ENSETR, 17),
+	CFG_GATE(GATE_UART4,		RCC_APB1ENSETR, 16),
+	CFG_GATE(GATE_USART3,		RCC_APB1ENSETR, 15),
+	CFG_GATE(GATE_USART2,		RCC_APB1ENSETR, 14),
+	CFG_GATE(GATE_SPI3,		RCC_APB1ENSETR, 12),
+	CFG_GATE(GATE_SPI2,		RCC_APB1ENSETR, 11),
+	CFG_GATE(GATE_LPTIM1,		RCC_APB1ENSETR, 9),
+	CFG_GATE(GATE_TIM14,		RCC_APB1ENSETR, 8),
+	CFG_GATE(GATE_TIM13,		RCC_APB1ENSETR, 7),
+	CFG_GATE(GATE_TIM12,		RCC_APB1ENSETR, 6),
+	CFG_GATE(GATE_TIM7,		RCC_APB1ENSETR, 5),
+	CFG_GATE(GATE_TIM6,		RCC_APB1ENSETR, 4),
+	CFG_GATE(GATE_TIM5,		RCC_APB1ENSETR, 3),
+	CFG_GATE(GATE_TIM4,		RCC_APB1ENSETR, 2),
+	CFG_GATE(GATE_TIM3,		RCC_APB1ENSETR, 1),
+	CFG_GATE(GATE_TIM2,		RCC_APB1ENSETR, 0),
+	CFG_GATE(GATE_FDCAN,		RCC_APB2ENSETR, 24),
+	CFG_GATE(GATE_ADFSDM,		RCC_APB2ENSETR, 21),
+	CFG_GATE(GATE_DFSDM,		RCC_APB2ENSETR, 20),
+	CFG_GATE(GATE_SAI3,		RCC_APB2ENSETR, 18),
+	CFG_GATE(GATE_SAI2,		RCC_APB2ENSETR, 17),
+	CFG_GATE(GATE_SAI1,		RCC_APB2ENSETR, 16),
+	CFG_GATE(GATE_USART6,		RCC_APB2ENSETR, 13),
+	CFG_GATE(GATE_SPI5,		RCC_APB2ENSETR, 10),
+	CFG_GATE(GATE_SPI4,		RCC_APB2ENSETR, 9),
+	CFG_GATE(GATE_SPI1,		RCC_APB2ENSETR, 8),
+	CFG_GATE(GATE_TIM17,		RCC_APB2ENSETR, 4),
+	CFG_GATE(GATE_TIM16,		RCC_APB2ENSETR, 3),
+	CFG_GATE(GATE_TIM15,		RCC_APB2ENSETR, 2),
+	CFG_GATE(GATE_TIM8,		RCC_APB2ENSETR, 1),
+	CFG_GATE(GATE_TIM1,		RCC_APB2ENSETR, 0),
+	CFG_GATE(GATE_HDP,		RCC_APB3ENSETR, 20),
+	CFG_GATE(GATE_PMBCTRL,		RCC_APB3ENSETR, 17),
+	CFG_GATE(GATE_TMPSENS,		RCC_APB3ENSETR, 16),
+	CFG_GATE(GATE_VREF,		RCC_APB3ENSETR, 13),
+	CFG_GATE(GATE_SYSCFG,		RCC_APB3ENSETR, 11),
+	CFG_GATE(GATE_SAI4,		RCC_APB3ENSETR, 8),
+	CFG_GATE(GATE_LPTIM5,		RCC_APB3ENSETR, 3),
+	CFG_GATE(GATE_LPTIM4,		RCC_APB3ENSETR, 2),
+	CFG_GATE(GATE_LPTIM3,		RCC_APB3ENSETR, 1),
+	CFG_GATE(GATE_LPTIM2,		RCC_APB3ENSETR, 0),
+	CFG_GATE(GATE_STGENRO,		RCC_APB4ENSETR, 20),
+	CFG_GATE(GATE_USBPHY,		RCC_APB4ENSETR, 16),
+	CFG_GATE(GATE_IWDG2,		RCC_APB4ENSETR, 15),
+	CFG_GATE(GATE_DDRPERFM,		RCC_APB4ENSETR, 8),
+	CFG_GATE(GATE_DSI,		RCC_APB4ENSETR, 4),
+	CFG_GATE(GATE_LTDC,		RCC_APB4ENSETR, 0),
+	CFG_GATE(GATE_STGEN,		RCC_APB5ENSETR, 20),
+	CFG_GATE(GATE_BSEC,		RCC_APB5ENSETR, 16),
+	CFG_GATE(GATE_IWDG1,		RCC_APB5ENSETR, 15),
+	CFG_GATE(GATE_TZPC,		RCC_APB5ENSETR, 13),
+	CFG_GATE(GATE_TZC2,		RCC_APB5ENSETR, 12),
+	CFG_GATE(GATE_TZC1,		RCC_APB5ENSETR, 11),
+	CFG_GATE(GATE_RTCAPB,		RCC_APB5ENSETR, 8),
+	CFG_GATE(GATE_USART1,		RCC_APB5ENSETR, 4),
+	CFG_GATE(GATE_I2C6,		RCC_APB5ENSETR, 3),
+	CFG_GATE(GATE_I2C4,		RCC_APB5ENSETR, 2),
+	CFG_GATE(GATE_SPI6,		RCC_APB5ENSETR, 0),
+	CFG_GATE(GATE_SDMMC3,		RCC_AHB2ENSETR, 16),
+	CFG_GATE(GATE_USBO,		RCC_AHB2ENSETR, 8),
+	CFG_GATE(GATE_ADC12,		RCC_AHB2ENSETR, 5),
+	CFG_GATE(GATE_DMAMUX,		RCC_AHB2ENSETR, 2),
+	CFG_GATE(GATE_DMA2,		RCC_AHB2ENSETR, 1),
+	CFG_GATE(GATE_DMA1,		RCC_AHB2ENSETR, 0),
+	CFG_GATE(GATE_IPCC,		RCC_AHB3ENSETR, 12),
+	CFG_GATE(GATE_HSEM,		RCC_AHB3ENSETR, 11),
+	CFG_GATE(GATE_CRC2,		RCC_AHB3ENSETR, 7),
+	CFG_GATE(GATE_RNG2,		RCC_AHB3ENSETR, 6),
+	CFG_GATE(GATE_HASH2,		RCC_AHB3ENSETR, 5),
+	CFG_GATE(GATE_CRYP2,		RCC_AHB3ENSETR, 4),
+	CFG_GATE(GATE_DCMI,		RCC_AHB3ENSETR, 0),
+	CFG_GATE(GATE_GPIOK,		RCC_AHB4ENSETR, 10),
+	CFG_GATE(GATE_GPIOJ,		RCC_AHB4ENSETR, 9),
+	CFG_GATE(GATE_GPIOI,		RCC_AHB4ENSETR, 8),
+	CFG_GATE(GATE_GPIOH,		RCC_AHB4ENSETR, 7),
+	CFG_GATE(GATE_GPIOG,		RCC_AHB4ENSETR, 6),
+	CFG_GATE(GATE_GPIOF,		RCC_AHB4ENSETR, 5),
+	CFG_GATE(GATE_GPIOE,		RCC_AHB4ENSETR, 4),
+	CFG_GATE(GATE_GPIOD,		RCC_AHB4ENSETR, 3),
+	CFG_GATE(GATE_GPIOC,		RCC_AHB4ENSETR, 2),
+	CFG_GATE(GATE_GPIOB,		RCC_AHB4ENSETR, 1),
+	CFG_GATE(GATE_GPIOA,		RCC_AHB4ENSETR, 0),
+	CFG_GATE(GATE_BKPSRAM,		RCC_AHB5ENSETR, 8),
+	CFG_GATE(GATE_RNG1,		RCC_AHB5ENSETR, 6),
+	CFG_GATE(GATE_HASH1,		RCC_AHB5ENSETR, 5),
+	CFG_GATE(GATE_CRYP1,		RCC_AHB5ENSETR, 4),
+	CFG_GATE(GATE_GPIOZ,		RCC_AHB5ENSETR, 0),
+	CFG_GATE(GATE_USBH,		RCC_AHB6ENSETR, 24),
+	CFG_GATE(GATE_CRC1,		RCC_AHB6ENSETR, 20),
+	CFG_GATE(GATE_SDMMC2,		RCC_AHB6ENSETR, 17),
+	CFG_GATE(GATE_SDMMC1,		RCC_AHB6ENSETR, 16),
+	CFG_GATE(GATE_QSPI,		RCC_AHB6ENSETR, 14),
+	CFG_GATE(GATE_FMC,		RCC_AHB6ENSETR, 12),
+	CFG_GATE(GATE_ETHMAC,		RCC_AHB6ENSETR, 10),
+	CFG_GATE(GATE_ETHRX,		RCC_AHB6ENSETR, 9),
+	CFG_GATE(GATE_ETHTX,		RCC_AHB6ENSETR, 8),
+	CFG_GATE(GATE_ETHCK,		RCC_AHB6ENSETR, 7),
+	CFG_GATE(GATE_GPU,		RCC_AHB6ENSETR, 5),
+	CFG_GATE(GATE_MDMA,		RCC_AHB6ENSETR, 0),
+	CFG_GATE(GATE_ETHSTP,		RCC_AHB6LPENSETR, 11),
+};
+
+enum enum_mux_cfg {
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MCU,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_CKPER,
+	MUX_RTC,
+	MUX_SDMMC12,
+	MUX_SDMMC3,
+	MUX_FMC,
+	MUX_QSPI,
+	MUX_RNG1,
+	MUX_RNG2,
+	MUX_USBPHY,
+	MUX_USBO,
+	MUX_STGEN,
+	MUX_SPDIF,
+	MUX_SPI1,
+	MUX_SPI23,
+	MUX_SPI45,
+	MUX_SPI6,
+	MUX_CEC,
+	MUX_I2C12,
+	MUX_I2C35,
+	MUX_I2C46,
+	MUX_LPTIM1,
+	MUX_LPTIM23,
+	MUX_LPTIM45,
+	MUX_USART1,
+	MUX_UART24,
+	MUX_UART35,
+	MUX_USART6,
+	MUX_UART78,
+	MUX_SAI1,
+	MUX_SAI2,
+	MUX_SAI3,
+	MUX_SAI4,
+	MUX_DSI,
+	MUX_FDCAN,
+	MUX_ADC12,
+	MUX_ETHCK,
+	MUX_MCO1,
+	MUX_MCO2,
+};
+
+struct cs_mux_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	u32	*table;
+};
+
+#define CFG_MUX(_id, _offset, _shift, _witdh, _flags)\
+	[_id] = {\
+		.offset = (_offset),\
+		.shift = (_shift),\
+		.width = (_witdh),\
+		.flags = (_flags),\
+	}
+
+static const struct cs_mux_cfg stm32mp15_muxes[] = {
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR, 0, 2, 0),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR, 0, 2, 0),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR, 0, 2, 0),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR, 0, 3, 0),
+	CFG_MUX(MUX_MCU,	RCC_MSSCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_RTC,	RCC_BDCR, 16, 2, 0),
+	CFG_MUX(MUX_SDMMC12,	RCC_SDMMC12CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI45,	RCC_SPI2S45CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_I2C35,	RCC_I2C35CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_LPTIM23,	RCC_LPTIM23CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART24,	RCC_UART24CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART35,	RCC_UART35CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_UART78,	RCC_UART78CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI1,	RCC_SAI1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_ETHCK,	RCC_ETHCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_I2C46,	RCC_I2C46CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_RNG2,	RCC_RNG2CKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SDMMC3,	RCC_SDMMC3CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_FMC,	RCC_FMCCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_QSPI,	RCC_QSPICKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USBPHY,	RCC_USBCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USBO,	RCC_USBCKSELR, 4, 1, 0),
+	CFG_MUX(MUX_SPDIF,	RCC_SPDIFCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SPI1,	RCC_SPI2S1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_CEC,	RCC_CECCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_LPTIM1,	RCC_LPTIM1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_USART6,	RCC_UART6CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_FDCAN,	RCC_FDCANCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_SAI2,	RCC_SAI2CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI3,	RCC_SAI3CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SAI4,	RCC_SAI4CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_ADC12,	RCC_ADCCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_DSI,	RCC_DSICKSELR, 0, 1, 0),
+	CFG_MUX(MUX_RNG1,	RCC_RNG1CKSELR, 0, 2, 0),
+	CFG_MUX(MUX_STGEN,	RCC_STGENCKSELR, 0, 2, 0),
+	CFG_MUX(MUX_USART1,	RCC_UART1CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_SPI6,	RCC_SPI6CKSELR, 0, 3, 0),
+	CFG_MUX(MUX_MCO1,	RCC_MCO1CFGR, 0, 3, 0),
+	CFG_MUX(MUX_MCO2,	RCC_MCO2CFGR, 0, 3, 0),
+};
+
+enum enum_div_cfg {
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MCU,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_RTC,
+	DIV_HSI,
+	DIV_MCO1,
+	DIV_MCO2,
+	DIV_TRACE,
+	DIV_ETHPTP,
+	DIV_NB
+};
+
+struct cs_div_cfg {
+	u16	offset;
+	u8	shift;
+	u8	width;
+	u8	flags;
+	const struct clk_div_table *table;
+};
+
+#define CFG_DIV(_id, _offset, _shift, _width, _flags, _table)\
+	[(_id)] = {\
+		.offset = (_offset),\
+		.shift = (_shift),\
+		.width = (_width),\
+		.flags = (_flags),\
+		.table = (_table),\
+	}
+
+static const struct cs_div_cfg stm32mp15_dividers[DIV_NB] = {
+	CFG_DIV(DIV_MPU,	RCC_MPCKDIVR, 0, 4, 0, NULL),
+	CFG_DIV(DIV_AXI,	RCC_AXIDIVR, 0, 3, 0, axi_div_table),
+	CFG_DIV(DIV_MCU,	RCC_MCUDIVR, 0, 4, 0, mcu_div_table),
+	CFG_DIV(DIV_APB1,	RCC_APB1DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB2,	RCC_APB2DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB3,	RCC_APB3DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB4,	RCC_APB4DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_APB5,	RCC_APB5DIVR, 0, 3, 0, apb_div_table),
+	CFG_DIV(DIV_HSI,	RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL),
+	CFG_DIV(DIV_PLL1DIVP,	RCC_PLL1CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVP,	RCC_PLL2CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVQ,	RCC_PLL2CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL2DIVR,	RCC_PLL2CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVP,	RCC_PLL3CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVQ,	RCC_PLL3CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL3DIVR,	RCC_PLL3CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVP,	RCC_PLL4CFGR2, 0, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVQ,	RCC_PLL4CFGR2, 8, 7, 0, NULL),
+	CFG_DIV(DIV_PLL4DIVR,	RCC_PLL4CFGR2, 16, 7, 0, NULL),
+	CFG_DIV(DIV_RTC,	RCC_RTCDIVR, 0, 6, 0, NULL),
+	CFG_DIV(DIV_MCO1,	RCC_MCO1CFGR, 4, 4, 0, NULL),
+	CFG_DIV(DIV_MCO2,	RCC_MCO2CFGR, 4, 4, 0, NULL),
+	CFG_DIV(DIV_TRACE,	RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table),
+	CFG_DIV(DIV_ETHPTP,	RCC_ETHCKSELR, 4, 4, 0, NULL),
+};
+
+struct clk_stm32_clock_data {
+	const struct cs_gate_cfg *gates;
+	const struct cs_mux_cfg *muxes;
+	const struct cs_div_cfg *dividers;
+};
+
+struct clock_summary {
+	struct clk_summary *clocks;
+	int nb_clocks;
+	void __iomem *base;
+	struct clk_stm32_clock_data *clock_data;
+};
+
+struct clk_summary {
+	const char *name;
+	unsigned long rate;
+	int enabled;
+	int nb_parents;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+	unsigned long (*get_rate)(struct clock_summary *cs,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	const char * const *parent_names;
+};
+
+static u8 clk_stm32_get_parent_mux(void __iomem *base,
+				   struct clk_stm32_clock_data *data,
+				   u16 mux_id)
+{
+	const struct cs_mux_cfg *mux = &data->muxes[mux_id];
+	u32 mask = BIT(mux->width) - 1;
+	u32 val;
+
+	val = readl(base + mux->offset) >> mux->shift;
+	val &= mask;
+
+	return val;
+}
+
+static int clk_stm32_is_enabled_gate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 gate_id)
+{
+	const struct cs_gate_cfg *gate = &data->gates[gate_id];
+
+	return (readl(base + gate->offset) & BIT(gate->bit_idx)) != 0;
+}
+
+static unsigned int _get_table_div(const struct clk_div_table *table,
+				   unsigned int val)
+{
+	const struct clk_div_table *clkt;
+
+	for (clkt = table; clkt->div; clkt++)
+		if (clkt->val == val)
+			return clkt->div;
+	return 0;
+}
+
+static unsigned int _get_div(const struct clk_div_table *table,
+			     unsigned int val, unsigned long flags, u8 width)
+{
+	if (flags & CLK_DIVIDER_ONE_BASED)
+		return val;
+	if (flags & CLK_DIVIDER_POWER_OF_TWO)
+		return 1 << val;
+	if (table)
+		return _get_table_div(table, val);
+	return val + 1;
+}
+
+static unsigned long clk_stm32_get_rate_divider(void __iomem *base,
+						struct clk_stm32_clock_data *data,
+						u16 div_id,
+						unsigned long parent_rate)
+{
+	const struct cs_div_cfg *divider = &data->dividers[div_id];
+	unsigned int val;
+	unsigned int div;
+
+	val =  readl(base + divider->offset) >> divider->shift;
+	val &= clk_div_mask(divider->width);
+	div = _get_div(divider->table, val, divider->flags, divider->width);
+
+	if (!div) {
+		WARN(!(divider->flags & CLK_DIVIDER_ALLOW_ZERO),
+		     "%d: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n", div_id);
+		return parent_rate;
+	}
+
+	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
+}
+
+struct cs_pll {
+	u32 offset;
+};
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clock_summary *cs,
+							  struct clk_summary *c,
+							  unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = cs->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clock_summary *cs,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+static unsigned long clk_summary_osc_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long clk_summary_div_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return clk_stm32_get_rate_divider(cs->base, cs->clock_data, c->div_id, parent_rate);
+}
+
+static unsigned long clk_summary_rtc_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = clk_stm32_get_parent_mux(cs->base, cs->clock_data, c->mux_id);
+	if (parent == HSE_RTC)
+		return clk_summary_div_recalc_rate(cs, c, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clock_summary *cs,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = cs->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_osc_recalc_rate,\
+}
+
+#define CS_DIV2(_name, _parent) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_MUX(_name, _parents, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.mux_id		= _mux,\
+	.gate_id	= NO_STM32_GATE,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_COMPOSITE(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_rtc_recalc_rate,\
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static struct clk_summary stm32mp15_clock_summary[] = {
+	CS_OSC("ck_hsi", GATE_HSI),
+	CS_OSC("ck_csi", GATE_CSI),
+	CS_OSC("ck_lsi", GATE_LSI),
+	CS_OSC("ck_hse", GATE_HSE),
+	CS_OSC("ck_lse", GATE_LSE),
+	CS_OSC("ck_usbo_48m", NO_STM32_GATE),
+	CS_OSC("i2s_ckin", NO_STM32_GATE),
+	CS_DIV2("clk-hse-div2", "ck_hse"),
+	CS_MUX("ck_per", per_src, MUX_CKPER),
+
+	CS_PLL("pll1", ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR),
+	CS_GATEDIV("pll1_p", "pll1", GATE_PLL1_DIVP, DIV_PLL1DIVP),
+
+	CS_DIV("pll1_p_div", "pll1_p", DIV_MPU),
+
+	CS_PLL("pll2", ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR),
+	CS_GATEDIV("pll2_p", "pll2", GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	CS_GATEDIV("pll2_q", "pll2", GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	CS_GATEDIV("pll2_r", "pll2", GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	CS_PLL("pll3", ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR),
+	CS_GATEDIV("pll3_p", "pll3", GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	CS_GATEDIV("pll3_q", "pll3", GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	CS_GATEDIV("pll3_r", "pll3", GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	CS_PLL("pll4", ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR),
+	CS_GATEDIV("pll4_p", "pll4", GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	CS_GATEDIV("pll4_q", "pll4", GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	CS_GATEDIV("pll4_r", "pll4", GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	CS_MUX("ck_mpu", cpu_src, MUX_MPU),
+	CS_COMPOSITE("ck_axi", axi_src, NO_STM32_GATE, MUX_AXI, DIV_AXI),
+	CS_COMPOSITE("ck_mcu", mcu_src, NO_STM32_GATE, MUX_MCU, DIV_MCU),
+
+	CS_DIV("pclk1", "ck_mcu", DIV_APB1),
+	CS_DIV("pclk2", "ck_mcu", DIV_APB2),
+	CS_DIV("pclk3", "ck_mcu", DIV_APB3),
+	CS_DIV("pclk4", "ck_axi", DIV_APB4),
+	CS_DIV("pclk5", "ck_axi", DIV_APB5),
+
+	CS_STM32_TIMER("ck1_tim", "pclk1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("ck2_tim", "pclk2", RCC_APB2DIVR, RCC_TIMG2PRER),
+
+	CS_GATE("tim2_k", "ck1_tim", GATE_TIM2),
+	CS_GATE("tim3_k", "ck1_tim", GATE_TIM3),
+	CS_GATE("tim4_k", "ck1_tim", GATE_TIM4),
+	CS_GATE("tim5_k", "ck1_tim", GATE_TIM5),
+	CS_GATE("tim6_k", "ck1_tim", GATE_TIM6),
+	CS_GATE("tim7_k", "ck1_tim", GATE_TIM7),
+	CS_GATE("tim12_k", "ck1_tim", GATE_TIM12),
+	CS_GATE("tim13_k", "ck1_tim", GATE_TIM13),
+	CS_GATE("tim14_k", "ck1_tim", GATE_TIM14),
+	CS_GATE("tim1_k", "ck2_tim", GATE_TIM1),
+	CS_GATE("tim8_k", "ck2_tim", GATE_TIM8),
+	CS_GATE("tim15_k", "ck2_tim", GATE_TIM15),
+	CS_GATE("tim16_k", "ck2_tim", GATE_TIM16),
+	CS_GATE("tim17_k", "ck2_tim", GATE_TIM17),
+
+	CS_GATE("tim2", "pclk1", GATE_TIM2),
+	CS_GATE("tim3", "pclk1", GATE_TIM3),
+	CS_GATE("tim4", "pclk1", GATE_TIM4),
+	CS_GATE("tim5", "pclk1", GATE_TIM5),
+	CS_GATE("tim6", "pclk1", GATE_TIM6),
+	CS_GATE("tim7", "pclk1", GATE_TIM7),
+	CS_GATE("tim12", "pclk1", GATE_TIM12),
+	CS_GATE("tim13", "pclk1", GATE_TIM13),
+	CS_GATE("tim14", "pclk1", GATE_TIM14),
+	CS_GATE("lptim1", "pclk1", GATE_LPTIM1),
+	CS_GATE("spi2", "pclk1", GATE_SPI2),
+	CS_GATE("spi3", "pclk1", GATE_SPI3),
+	CS_GATE("usart2", "pclk1", GATE_USART2),
+	CS_GATE("usart3", "pclk1", GATE_USART3),
+	CS_GATE("uart4", "pclk1", GATE_UART4),
+	CS_GATE("uart5", "pclk1", GATE_UART5),
+	CS_GATE("uart7", "pclk1", GATE_UART7),
+	CS_GATE("uart8", "pclk1", GATE_UART8),
+	CS_GATE("i2c1", "pclk1", GATE_I2C1),
+	CS_GATE("i2c2", "pclk1", GATE_I2C2),
+	CS_GATE("i2c3", "pclk1", GATE_I2C3),
+	CS_GATE("i2c5", "pclk1", GATE_I2C5),
+	CS_GATE("spdif", "pclk1", GATE_SPDIF),
+	CS_GATE("cec", "pclk1", GATE_CEC),
+	CS_GATE("dac12", "pclk1", GATE_DAC12),
+	CS_GATE("mdio", "pclk1", GATE_MDIO),
+	CS_GATE("tim1", "pclk2", GATE_TIM1),
+	CS_GATE("tim8", "pclk2", GATE_TIM8),
+	CS_GATE("tim15", "pclk2", GATE_TIM15),
+	CS_GATE("tim16", "pclk2", GATE_TIM16),
+	CS_GATE("tim17", "pclk2", GATE_TIM17),
+	CS_GATE("spi1", "pclk2", GATE_SPI1),
+	CS_GATE("spi4", "pclk2", GATE_SPI4),
+	CS_GATE("spi5", "pclk2", GATE_SPI5),
+	CS_GATE("usart6", "pclk2", GATE_USART6),
+	CS_GATE("sai1", "pclk2", GATE_SAI1),
+	CS_GATE("sai2", "pclk2", GATE_SAI2),
+	CS_GATE("sai3", "pclk2", GATE_SAI3),
+	CS_GATE("dfsdm", "pclk2", GATE_DFSDM),
+	CS_GATE("fdcan", "pclk2", GATE_FDCAN),
+	CS_GATE("lptim2", "pclk3", GATE_LPTIM2),
+	CS_GATE("lptim3", "pclk3", GATE_LPTIM3),
+	CS_GATE("lptim4", "pclk3", GATE_LPTIM4),
+	CS_GATE("lptim5", "pclk3", GATE_LPTIM5),
+	CS_GATE("sai4", "pclk3", GATE_SAI4),
+	CS_GATE("syscfg", "pclk3", GATE_SYSCFG),
+	CS_GATE("vref", "pclk3", GATE_VREF),
+	CS_GATE("tmpsens", "pclk3", GATE_TMPSENS),
+	CS_GATE("pmbctrl", "pclk3", GATE_PMBCTRL),
+	CS_GATE("hdp", "pclk3", GATE_HDP),
+	CS_GATE("ltdc", "pclk4", GATE_LTDC),
+	CS_GATE("dsi", "pclk4", GATE_DSI),
+	CS_GATE("iwdg2", "pclk4", GATE_IWDG2),
+	CS_GATE("usbphy", "pclk4", GATE_USBPHY),
+	CS_GATE("stgenro", "pclk4", GATE_STGENRO),
+	CS_GATE("spi6", "pclk5", GATE_SPI6),
+	CS_GATE("i2c4", "pclk5", GATE_I2C4),
+	CS_GATE("i2c6", "pclk5", GATE_I2C6),
+	CS_GATE("usart1", "pclk5", GATE_USART1),
+	CS_GATE("rtcapb", "pclk5", GATE_RTCAPB),
+	CS_GATE("tzc1", "ck_axi", GATE_TZC1),
+	CS_GATE("tzc2", "ck_axi", GATE_TZC2),
+	CS_GATE("tzpc", "pclk5", GATE_TZPC),
+	CS_GATE("iwdg1", "pclk5", GATE_IWDG1),
+	CS_GATE("bsec", "pclk5", GATE_BSEC),
+	CS_GATE("stgen", "pclk5", GATE_STGEN),
+	CS_GATE("dma1", "ck_mcu", GATE_DMA1),
+	CS_GATE("dma2", "ck_mcu", GATE_DMA2),
+	CS_GATE("dmamux", "ck_mcu", GATE_DMAMUX),
+	CS_GATE("adc12", "ck_mcu", GATE_ADC12),
+	CS_GATE("usbo", "ck_mcu", GATE_USBO),
+	CS_GATE("sdmmc3", "ck_mcu", GATE_SDMMC3),
+	CS_GATE("dcmi", "ck_mcu", GATE_DCMI),
+	CS_GATE("cryp2", "ck_mcu", GATE_CRYP2),
+	CS_GATE("hash2", "ck_mcu", GATE_HASH2),
+	CS_GATE("rng2", "ck_mcu", GATE_RNG2),
+	CS_GATE("crc2", "ck_mcu", GATE_CRC2),
+	CS_GATE("hsem", "ck_mcu", GATE_HSEM),
+	CS_GATE("ipcc", "ck_mcu", GATE_IPCC),
+	CS_GATE("gpioa", "ck_mcu", GATE_GPIOA),
+	CS_GATE("gpiob", "ck_mcu", GATE_GPIOB),
+	CS_GATE("gpioc", "ck_mcu", GATE_GPIOC),
+	CS_GATE("gpiod", "ck_mcu", GATE_GPIOD),
+	CS_GATE("gpioe", "ck_mcu", GATE_GPIOE),
+	CS_GATE("gpiof", "ck_mcu", GATE_GPIOF),
+	CS_GATE("gpiog", "ck_mcu", GATE_GPIOG),
+	CS_GATE("gpioh", "ck_mcu", GATE_GPIOH),
+	CS_GATE("gpioi", "ck_mcu", GATE_GPIOI),
+	CS_GATE("gpioj", "ck_mcu", GATE_GPIOJ),
+	CS_GATE("gpiok", "ck_mcu", GATE_GPIOK),
+	CS_GATE("gpioz", "ck_axi", GATE_GPIOZ),
+	CS_GATE("cryp1", "ck_axi", GATE_CRYP1),
+	CS_GATE("hash1", "ck_axi", GATE_HASH1),
+	CS_GATE("rng1", "ck_axi", GATE_RNG1),
+	CS_GATE("bkpsram", "ck_axi", GATE_BKPSRAM),
+	CS_GATE("mdma", "ck_axi", GATE_MDMA),
+	CS_GATE("gpu", "ck_axi", GATE_GPU),
+	CS_GATE("ethtx", "ck_axi", GATE_ETHTX),
+	CS_GATE("ethrx", "ck_axi", GATE_ETHRX),
+	CS_GATE("ethmac", "ck_axi", GATE_ETHMAC),
+	CS_GATE("crc1", "ck_axi", GATE_CRC1),
+	CS_GATE("usbh", "ck_axi", GATE_USBH),
+	CS_GATE("ethstp", "ck_axi", GATE_ETHSTP),
+	CS_GATE("ddrperfm", "pclk4", GATE_DDRPERFM),
+
+	CS_GATEMUX("sdmmc1_k", sdmmc12_src, GATE_SDMMC1, MUX_SDMMC12),
+	CS_GATEMUX("sdmmc2_k", sdmmc12_src, GATE_SDMMC2, MUX_SDMMC12),
+	CS_GATEMUX("sdmmc3_k", sdmmc3_src, GATE_SDMMC3, MUX_SDMMC3),
+	CS_GATEMUX("fmc_k", fmc_src, GATE_FMC, MUX_FMC),
+	CS_GATEMUX("qspi_k", qspi_src, GATE_QSPI, MUX_QSPI),
+	CS_GATEMUX("rng1_k", rng_src, GATE_RNG1, MUX_RNG1),
+	CS_GATEMUX("rng2_k", rng_src, GATE_RNG2, MUX_RNG2),
+	CS_GATEMUX("usbphy_k", usbphy_src, GATE_USBPHY, MUX_USBPHY),
+	CS_GATEMUX("stgen_k", stgen_src, GATE_STGEN, MUX_STGEN),
+	CS_GATEMUX("spdif_k", spdif_src, GATE_SPDIF, MUX_SPDIF),
+	CS_GATEMUX("spi1_k", spi123_src, GATE_SPI1, MUX_SPI1),
+	CS_GATEMUX("spi2_k", spi123_src, GATE_SPI2, MUX_SPI23),
+	CS_GATEMUX("spi3_k", spi123_src, GATE_SPI3, MUX_SPI23),
+	CS_GATEMUX("spi4_k", spi45_src, GATE_SPI4, MUX_SPI45),
+	CS_GATEMUX("spi5_k", spi45_src, GATE_SPI5, MUX_SPI45),
+	CS_GATEMUX("spi6_k", spi6_src, GATE_SPI6, MUX_SPI6),
+	CS_GATEMUX("cec_k", cec_src, GATE_CEC, MUX_CEC),
+	CS_GATEMUX("i2c1_k", i2c12_src, GATE_I2C1, MUX_I2C12),
+	CS_GATEMUX("i2c2_k", i2c12_src, GATE_I2C2, MUX_I2C12),
+	CS_GATEMUX("i2c3_k", i2c35_src, GATE_I2C3, MUX_I2C35),
+	CS_GATEMUX("i2c5_k", i2c35_src, GATE_I2C5, MUX_I2C35),
+	CS_GATEMUX("i2c4_k", i2c46_src, GATE_I2C4, MUX_I2C46),
+	CS_GATEMUX("i2c6_k", i2c46_src, GATE_I2C6, MUX_I2C46),
+	CS_GATEMUX("lptim1_k", lptim1_src, GATE_LPTIM1, MUX_LPTIM1),
+	CS_GATEMUX("lptim2_k", lptim23_src, GATE_LPTIM2, MUX_LPTIM23),
+	CS_GATEMUX("lptim3_k", lptim23_src, GATE_LPTIM3, MUX_LPTIM23),
+	CS_GATEMUX("lptim4_k", lptim45_src, GATE_LPTIM4, MUX_LPTIM45),
+	CS_GATEMUX("lptim5_k", lptim45_src, GATE_LPTIM5, MUX_LPTIM45),
+	CS_GATEMUX("usart1_k", usart1_src, GATE_USART1, MUX_USART1),
+	CS_GATEMUX("usart2_k", usart234578_src, GATE_USART2, MUX_UART24),
+	CS_GATEMUX("usart3_k", usart234578_src, GATE_USART3, MUX_UART35),
+	CS_GATEMUX("uart4_k", usart234578_src, GATE_UART4, MUX_UART24),
+	CS_GATEMUX("uart5_k", usart234578_src, GATE_UART5, MUX_UART35),
+	CS_GATEMUX("uart6_k", usart6_src, GATE_USART6, MUX_USART6),
+	CS_GATEMUX("uart7_k", usart234578_src, GATE_UART7, MUX_UART78),
+	CS_GATEMUX("uart8_k", usart234578_src, GATE_UART8, MUX_UART78),
+	CS_GATEMUX("fdcan_k", fdcan_src, GATE_FDCAN, MUX_FDCAN),
+	CS_GATEMUX("sai1_k", sai_src, GATE_SAI1, MUX_SAI1),
+	CS_GATEMUX("sai2_k", sai2_src, GATE_SAI2, MUX_SAI2),
+	CS_GATEMUX("sai3_k", sai_src, GATE_SAI3, MUX_SAI3),
+	CS_GATEMUX("sai4_k", sai_src, GATE_SAI4, MUX_SAI4),
+	CS_GATEMUX("adc12_k", adc12_src, GATE_ADC12, MUX_ADC12),
+	CS_GATEMUX("dsi_k", dsi_src, GATE_DSI, MUX_DSI),
+	CS_GATEMUX("adfsdm_k", sai_src, GATE_ADFSDM, MUX_SAI1),
+	CS_GATEMUX("usbo_k", usbo_src, GATE_USBO, MUX_USBO),
+	CS_GATEMUX("ethck_k", eth_src, GATE_ETHCK, MUX_ETHCK),
+
+	CS_GATE("dfsdm_k", "ck_mcu", GATE_DFSDM),
+	CS_GATE("dsi_px", "pll4_q", GATE_DSI),
+	CS_GATE("ltdc_px", "pll4_q", GATE_LTDC),
+	CS_GATE("gpu_k", "pll2_q", GATE_GPU),
+	CS_GATE("dac12_k", "ck_lsi", GATE_DAC12),
+
+	CS_COMPOSITE("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1),
+	CS_COMPOSITE("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2),
+	CS_GATE("ck_sys_dbg", "ck_axi", GATE_DBGCK),
+
+	CS_COMPOSITE("ethptp_k", eth_src, NO_STM32_GATE, MUX_ETHCK, DIV_ETHPTP),
+
+	CS_RTC("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC),
+
+	CS_GATEDIV("ck_trace", "ck_axi", GATE_TRACECK, DIV_TRACE),
+};
+
+static void rcc_summary_show_one(struct seq_file *s, struct clk_summary *c,
+				 int level)
+{
+	char enabled;
+
+	seq_printf(s, "%*s%-*s %11lu ",
+		   level * 3 + 1, "",
+		   30 - level * 3,
+		   c->name,
+		   c->rate
+		);
+
+	switch (c->enabled) {
+	case 0:
+		enabled = 'N';
+		break;
+	case 1:
+		enabled = 'Y';
+		break;
+	default:
+		enabled = '?';
+		break;
+	}
+
+	seq_printf(s, " %9c\n", enabled);
+}
+
+static int clock_summary_clk_is_enabled(struct clock_summary *cs,
+					struct clk_summary *c)
+{
+	return clk_stm32_is_enabled_gate(cs->base, cs->clock_data, c->gate_id);
+}
+
+static const char *clock_summary_get_parent_name(struct clock_summary *cs,
+						 struct clk_summary *c)
+{
+	int id = 0;
+
+	if (c->nb_parents == 0)
+		return NULL;
+
+	if (c->nb_parents > 1)
+		id = clk_stm32_get_parent_mux(cs->base, cs->clock_data, c->mux_id);
+
+	return c->parent_names[id];
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct clock_summary *cs = (struct clock_summary *)s->private;
+	int i;
+
+	if (c->get_rate)
+		c->rate = c->get_rate(cs, c, parent_rate);
+	else
+		c->rate = parent_rate;
+
+	c->enabled = -1;
+	if (c->gate_id != NO_STM32_GATE)
+		c->enabled = clock_summary_clk_is_enabled(cs, c);
+
+	rcc_summary_show_one(s, c, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = &cs->clocks[i];
+		const char *parent_name = clock_summary_get_parent_name(cs, child);
+
+		if (!parent_name)
+			continue;
+
+		if (!strcmp(c->name, parent_name))
+			rcc_summary_show_subtree(s, child, c->rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct clock_summary *cs = (struct clock_summary *)s->private;
+	int i;
+
+	seq_puts(s, "                                              hardware\n");
+	seq_puts(s, "   clock                               rate     enable\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = &cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+struct clk_stm32_clock_data stm32mp15_clock_data = {
+	.gates		= stm32mp15_gates,
+	.muxes		= stm32mp15_muxes,
+	.dividers	= stm32mp15_dividers,
+};
+
+static struct clock_summary clock_summary_mp15 = {
+	.clocks		= stm32mp15_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp15_clock_summary),
+	.clock_data	= &stm32mp15_clock_data,
+};
+
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	clock_summary_mp15.base = base;
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir,
+			    &clock_summary_mp15, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev, void __iomem *base)
+{
+}
+
+#endif
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 33fedbd09..8eb006787 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -1935,6 +1935,7 @@ static void clk_reparent(struct clk_core *core, struct clk_core *new_parent)
 	core->parent = new_parent;
 }
 
+static const struct clk_ops clk_nodrv_ops;
 static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 					   struct clk_core *parent)
 {
@@ -1963,7 +1964,8 @@ static struct clk_core *__clk_set_parent_before(struct clk_core *core,
 
 	/* enable old_parent & parent if CLK_OPS_PARENT_ENABLE is set */
 	if (core->flags & CLK_OPS_PARENT_ENABLE) {
-		clk_core_prepare_enable(old_parent);
+		if (old_parent && old_parent->ops != &clk_nodrv_ops)
+			clk_core_prepare_enable(old_parent);
 		clk_core_prepare_enable(parent);
 	}
 
@@ -1997,7 +1999,8 @@ static void __clk_set_parent_after(struct clk_core *core,
 	/* re-balance ref counting if CLK_OPS_PARENT_ENABLE is set */
 	if (core->flags & CLK_OPS_PARENT_ENABLE) {
 		clk_core_disable_unprepare(parent);
-		clk_core_disable_unprepare(old_parent);
+		if (old_parent && old_parent->ops != &clk_nodrv_ops)
+			clk_core_disable_unprepare(old_parent);
 	}
 }
 
diff --git a/drivers/clk/stm32/Makefile b/drivers/clk/stm32/Makefile
index 95bd2230b..1c0979add 100644
--- a/drivers/clk/stm32/Makefile
+++ b/drivers/clk/stm32/Makefile
@@ -1 +1,3 @@
 obj-$(CONFIG_COMMON_CLK_STM32MP135)	+= clk-stm32mp13.o clk-stm32-core.o reset-stm32.o
+obj-$(CONFIG_COMMON_CLK_STM32MP257)	+= clk-stm32mp25.o clk-stm32-core.o reset-stm32.o
+obj-$(CONFIG_COMMON_CLK_STM32MP257)	+= clk-stm32mp25-syscfg.o
diff --git a/drivers/clk/stm32/clk-stm32-core.c b/drivers/clk/stm32/clk-stm32-core.c
index 45a279e73..5379543b6 100644
--- a/drivers/clk/stm32/clk-stm32-core.c
+++ b/drivers/clk/stm32/clk-stm32-core.c
@@ -19,6 +19,9 @@
 
 static DEFINE_SPINLOCK(rlock);
 
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data);
+
 static int stm32_rcc_clock_init(struct device *dev,
 				const struct of_device_id *match,
 				void __iomem *base)
@@ -28,6 +31,7 @@ static int stm32_rcc_clock_init(struct device *dev,
 	struct device_node *np = dev_of_node(dev);
 	struct clk_hw **hws;
 	int n, max_binding;
+	int ret;
 
 	max_binding =  data->maxbinding;
 
@@ -35,6 +39,8 @@ static int stm32_rcc_clock_init(struct device *dev,
 	if (!clk_data)
 		return -ENOMEM;
 
+	data->clock_data->base = base;
+
 	clk_data->num = max_binding;
 
 	hws = clk_data->hws;
@@ -64,7 +70,14 @@ static int stm32_rcc_clock_init(struct device *dev,
 			hws[cfg_clock->id] = hw;
 	}
 
-	return of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);
+	ret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	if (data->clock_summary)
+		stm32_clk_summary_debugfs_create(dev, data);
+
+	return ret;
 }
 
 int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
@@ -96,9 +109,9 @@ int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
 	return 0;
 }
 
-static u8 stm32_mux_get_parent(void __iomem *base,
-			       struct clk_stm32_clock_data *data,
-			       u16 mux_id)
+u8 stm32_mux_get_parent(void __iomem *base,
+			struct clk_stm32_clock_data *data,
+			u16 mux_id)
 {
 	const struct stm32_mux_cfg *mux = &data->muxes[mux_id];
 	u32 mask = BIT(mux->width) - 1;
@@ -128,6 +141,29 @@ static int stm32_mux_set_parent(void __iomem *base,
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static void stm32_gate_force_endisable(void __iomem *base,
+				       struct clk_stm32_clock_data *data,
+				       u16 gate_id,
+				       int enable)
+{
+	const struct stm32_gate_cfg *gate = &data->gates[gate_id];
+	void __iomem *addr = base + gate->offset;
+
+	if (enable) {
+		if (gate->set_clr != 0)
+			writel(BIT(gate->bit_idx), addr);
+		else
+			writel(readl(addr) | BIT(gate->bit_idx), addr);
+	} else {
+		if (gate->set_clr != 0)
+			writel(BIT(gate->bit_idx), addr + gate->set_clr);
+		else
+			writel(readl(addr) & ~BIT(gate->bit_idx), addr);
+	}
+}
+#endif
+
 static void stm32_gate_endisable(void __iomem *base,
 				 struct clk_stm32_clock_data *data,
 				 u16 gate_id, int enable)
@@ -202,10 +238,10 @@ static unsigned int _get_div(const struct clk_div_table *table,
 	return val + 1;
 }
 
-static unsigned long stm32_divider_get_rate(void __iomem *base,
-					    struct clk_stm32_clock_data *data,
-					    u16 div_id,
-					    unsigned long parent_rate)
+unsigned long stm32_divider_get_rate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 div_id,
+				     unsigned long parent_rate)
 {
 	const struct stm32_div_cfg *divider = &data->dividers[div_id];
 	unsigned int val;
@@ -322,11 +358,28 @@ static void clk_stm32_gate_disable_unused(struct clk_hw *hw)
 	spin_unlock_irqrestore(gate->lock, flags);
 }
 
+#ifdef CONFIG_PM_SLEEP
+static void clk_stm32_pm_gate_restore(struct clk_hw *hw)
+{
+	struct clk_stm32_gate *gate = to_clk_stm32_gate(hw);
+	unsigned long flags = 0;
+
+	if (__clk_get_enable_count(hw->clk)) {
+		spin_lock_irqsave(gate->lock, flags);
+		stm32_gate_force_endisable(gate->base, gate->clock_data, gate->gate_id, 1);
+		spin_unlock_irqrestore(gate->lock, flags);
+	}
+}
+#endif
+
 const struct clk_ops clk_stm32_gate_ops = {
 	.enable		= clk_stm32_gate_enable,
 	.disable	= clk_stm32_gate_disable,
 	.is_enabled	= clk_stm32_gate_is_enabled,
 	.disable_unused	= clk_stm32_gate_disable_unused,
+#ifdef CONFIG_PM_SLEEP
+	.restore_context = clk_stm32_pm_gate_restore,
+#endif
 };
 
 static int clk_stm32_divider_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -598,6 +651,21 @@ static void clk_stm32_composite_disable_unused(struct clk_hw *hw)
 	spin_unlock_irqrestore(composite->lock, flags);
 }
 
+#ifdef CONFIG_PM_SLEEP
+static void clk_stm32_pm_composite_restore(struct clk_hw *hw)
+{
+	struct clk_stm32_composite *composite = to_clk_stm32_composite(hw);
+	unsigned long flags = 0;
+
+	if (__clk_get_enable_count(hw->clk)) {
+		spin_lock_irqsave(composite->lock, flags);
+		stm32_gate_force_endisable(composite->base, composite->clock_data,
+					   composite->gate_id, 1);
+		spin_unlock_irqrestore(composite->lock, flags);
+	}
+}
+#endif
+
 const struct clk_ops clk_stm32_composite_ops = {
 	.set_rate	= clk_stm32_composite_set_rate,
 	.recalc_rate	= clk_stm32_composite_recalc_rate,
@@ -608,6 +676,9 @@ const struct clk_ops clk_stm32_composite_ops = {
 	.disable	= clk_stm32_composite_gate_disable,
 	.is_enabled	= clk_stm32_composite_is_enabled,
 	.disable_unused	= clk_stm32_composite_disable_unused,
+#ifdef CONFIG_PM_SLEEP
+	.restore_context = clk_stm32_pm_composite_restore,
+#endif
 };
 
 struct clk_hw *clk_stm32_mux_register(struct device *dev,
@@ -693,3 +764,133 @@ struct clk_hw *clk_stm32_composite_register(struct device *dev,
 
 	return hw;
 }
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+static void rcc_summary_show_one(struct seq_file *s, struct clk_summary *c,
+				 int level)
+{
+	char enabled;
+
+	seq_printf(s, "%*s%-*s %11lu ",
+		   level * 3 + 1, "",
+		   30 - level * 3,
+		   c->name,
+		   c->rate
+		);
+
+	switch (c->enabled) {
+	case 0:
+		enabled = 'N';
+		break;
+	case 1:
+		enabled = 'Y';
+		break;
+	default:
+		enabled = '?';
+		break;
+	}
+
+	seq_printf(s, " %9c\n", enabled);
+}
+
+static int clock_summary_clk_is_enabled(struct clk_stm32_clock_data *data,
+					struct clk_summary *c)
+{
+	return stm32_gate_is_enabled(data->base, data, c->gate_id);
+}
+
+static const char *clock_summary_get_parent_name(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c)
+{
+	int id = 0;
+
+	if (c->nb_parents == 0)
+		return NULL;
+
+	if (c->nb_parents > 1) {
+		if (c->get_parent)
+			id = c->get_parent(data, c);
+		else
+			id = stm32_mux_get_parent(data->base, data, c->mux_id);
+	}
+
+	return c->parent_names[id];
+}
+
+static void rcc_summary_show_subtree(struct seq_file *s, struct clk_summary *c,
+				     unsigned long parent_rate, int level)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clk_stm32_clock_data *data = match_data->clock_data;
+	struct clock_summary *cs = match_data->clock_summary;
+	int i;
+
+	if (c->get_rate)
+		c->rate = c->get_rate(data, c, parent_rate);
+	else
+		c->rate = parent_rate;
+
+	c->enabled = -1;
+
+	if (c->is_enabled)
+		c->enabled = c->is_enabled(data, c);
+
+	else if (c->gate_id != NO_STM32_GATE)
+		c->enabled = clock_summary_clk_is_enabled(data, c);
+
+	rcc_summary_show_one(s, c, level);
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *child = &cs->clocks[i];
+		const char *parent_name = clock_summary_get_parent_name(data, child);
+
+		if (!parent_name)
+			continue;
+
+		if (!strcmp(c->name, parent_name))
+			rcc_summary_show_subtree(s, child, c->rate, level + 1);
+	}
+}
+
+static int rcc_summary_show(struct seq_file *s, void *data)
+{
+	struct stm32_rcc_match_data *match_data = (struct stm32_rcc_match_data *)s->private;
+	struct clock_summary *cs = match_data->clock_summary;
+
+	int i;
+
+	seq_puts(s, "                                              hardware\n");
+	seq_puts(s, "   clock                               rate     enable\n");
+	seq_puts(s, "------------------------------------------------------\n");
+
+	for (i = 0; i < cs->nb_clocks; i++) {
+		struct clk_summary *c = &cs->clocks[i];
+
+		if (c->nb_parents == 0)
+			rcc_summary_show_subtree(s, c, 0, 0);
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(rcc_summary);
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+{
+	struct dentry *rootdir = debugfs_lookup("clk", NULL);
+
+	debugfs_create_file("stm32_clk_summary", 0444, rootdir, (void *)data, &rcc_summary_fops);
+}
+
+#else
+
+static void stm32_clk_summary_debugfs_create(struct device *dev,
+					     const struct stm32_rcc_match_data *data)
+
+{
+}
+#endif
diff --git a/drivers/clk/stm32/clk-stm32-core.h b/drivers/clk/stm32/clk-stm32-core.h
index 76cffda02..39b91a8c3 100644
--- a/drivers/clk/stm32/clk-stm32-core.h
+++ b/drivers/clk/stm32/clk-stm32-core.h
@@ -57,6 +57,7 @@ struct clock_config {
 };
 
 struct clk_stm32_clock_data {
+	void __iomem			*base;
 	u16 *gate_cpt;
 	const struct stm32_gate_cfg	*gates;
 	const struct stm32_mux_cfg	*muxes;
@@ -64,6 +65,31 @@ struct clk_stm32_clock_data {
 	struct clk_hw *(*is_multi_mux)(struct clk_hw *hw);
 };
 
+struct clock_summary {
+	struct clk_summary *clocks;
+	int nb_clocks;
+};
+
+struct clk_summary {
+	const char *name;
+	unsigned long rate;
+	int enabled;
+	int nb_parents;
+	int gate_id;
+	int mux_id;
+	int div_id;
+	void *data;
+
+	bool (*is_enabled)(struct clk_stm32_clock_data *data,
+			   struct clk_summary *c);
+	u8 (*get_parent)(struct clk_stm32_clock_data *data,
+			 struct clk_summary *c);
+	unsigned long (*get_rate)(struct clk_stm32_clock_data *data,
+				  struct clk_summary *c,
+				  unsigned long parent_rate);
+	const char * const *parent_names;
+};
+
 struct stm32_rcc_match_data {
 	struct clk_hw_onecell_data	*hw_clks;
 	unsigned int			num_clocks;
@@ -71,9 +97,12 @@ struct stm32_rcc_match_data {
 	unsigned int			maxbinding;
 	struct clk_stm32_clock_data	*clock_data;
 	u32				clear_offset;
+
 	int (*check_security)(void __iomem *base,
 			      const struct clock_config *cfg);
 	int (*multi_mux)(void __iomem *base, const struct clock_config *cfg);
+	u32				reset_us;
+	struct clock_summary		*clock_summary;
 };
 
 int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
@@ -82,6 +111,15 @@ int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
 int stm32_rcc_init(struct device *dev, const struct of_device_id *match_data,
 		   void __iomem *base);
 
+unsigned long stm32_divider_get_rate(void __iomem *base,
+				     struct clk_stm32_clock_data *data,
+				     u16 div_id,
+				     unsigned long parent_rate);
+
+u8 stm32_mux_get_parent(void __iomem *base,
+			struct clk_stm32_clock_data *data,
+			u16 mux_id);
+
 /* MUX define */
 #define MUX_NO_RDY		0xFF
 #define MUX_SAFE		BIT(7)
diff --git a/drivers/clk/stm32/clk-stm32mp13.c b/drivers/clk/stm32/clk-stm32mp13.c
index 1192eee8a..7a5e83457 100644
--- a/drivers/clk/stm32/clk-stm32mp13.c
+++ b/drivers/clk/stm32/clk-stm32mp13.c
@@ -16,6 +16,53 @@
 
 /* STM32 Gates definition */
 enum enum_gate_cfg {
+	GATE_LSE,
+	GATE_LSE_RDY,
+	GATE_LSI,
+	GATE_LSI_RDY,
+	GATE_HSI,
+	GATE_HSI_RDY,
+	GATE_CSI,
+	GATE_CSI_RDY,
+	GATE_HSE,
+	GATE_HSE_RDY,
+	GATE_PLL1,
+	GATE_PLL1_RDY,
+	GATE_PLL2,
+	GATE_PLL2_RDY,
+	GATE_PLL3,
+	GATE_PLL3_RDY,
+	GATE_PLL4,
+	GATE_PLL4_RDY,
+	GATE_HSIDIVRDY,
+	GATE_MPUSRCRDY,
+	GATE_AXISSRCRDY,
+	GATE_MCUSSRCRDY,
+	GATE_PLL12SRCRDY,
+	GATE_PLL3SRCRDY,
+	GATE_PLL4SRCRDY,
+	GATE_MPUDIVRDY,
+	GATE_AXIDIVRDY,
+	GATE_MLAHBDIVRDY,
+	GATE_APB1DIVRDY,
+	GATE_APB2DIVRDY,
+	GATE_APB3DIVRDY,
+	GATE_APB4DIVRDY,
+	GATE_APB5DIVRDY,
+	GATE_APB6DIVRDY,
+	GATE_RTCCK,
+	GATE_PLL1_DIVP,
+	GATE_PLL1_DIVQ,
+	GATE_PLL1_DIVR,
+	GATE_PLL2_DIVP,
+	GATE_PLL2_DIVQ,
+	GATE_PLL2_DIVR,
+	GATE_PLL3_DIVP,
+	GATE_PLL3_DIVQ,
+	GATE_PLL3_DIVR,
+	GATE_PLL4_DIVP,
+	GATE_PLL4_DIVQ,
+	GATE_PLL4_DIVR,
 	GATE_MCO1,
 	GATE_MCO2,
 	GATE_DBGCK,
@@ -149,6 +196,53 @@ enum enum_gate_cfg {
 	_CFG_GATE(_id, _offset, _bit_idx, RCC_CLR_OFFSET)
 
 static struct stm32_gate_cfg stm32mp13_gates[] = {
+	CFG_GATE(GATE_LSE,		RCC_BDCR,		0),
+	CFG_GATE(GATE_LSE_RDY,		RCC_BDCR,		2),
+	CFG_GATE(GATE_RTCCK,		RCC_BDCR,		20),
+	CFG_GATE(GATE_LSI,		RCC_RDLSICR,		0),
+	CFG_GATE(GATE_LSI_RDY,		RCC_RDLSICR,		1),
+	CFG_GATE_SETCLR(GATE_HSI,	RCC_OCENSETR,		0),
+	CFG_GATE(GATE_HSI_RDY,		RCC_OCRDYR,		0),
+	CFG_GATE_SETCLR(GATE_CSI,	RCC_OCENSETR,		4),
+	CFG_GATE(GATE_CSI_RDY,		RCC_OCRDYR,		4),
+	CFG_GATE_SETCLR(GATE_HSE,	RCC_OCENSETR,		8),
+	CFG_GATE(GATE_HSE_RDY,		RCC_OCRDYR,		8),
+	CFG_GATE(GATE_HSIDIVRDY,	RCC_OCRDYR,		2),
+	CFG_GATE(GATE_MPUSRCRDY,	RCC_MPCKSELR,		31),
+	CFG_GATE(GATE_AXISSRCRDY,	RCC_ASSCKSELR,		31),
+	CFG_GATE(GATE_MCUSSRCRDY,	RCC_MSSCKSELR,		31),
+	CFG_GATE(GATE_PLL12SRCRDY,	RCC_RCK12SELR,		31),
+	CFG_GATE(GATE_PLL3SRCRDY,	RCC_RCK3SELR,		31),
+	CFG_GATE(GATE_PLL4SRCRDY,	RCC_RCK4SELR,		31),
+	CFG_GATE(GATE_MPUDIVRDY,	RCC_MPCKDIVR,		31),
+	CFG_GATE(GATE_AXIDIVRDY,	RCC_AXIDIVR,		31),
+	CFG_GATE(GATE_MLAHBDIVRDY,	RCC_MLAHBDIVR,		31),
+	CFG_GATE(GATE_APB1DIVRDY,	RCC_APB1DIVR,		31),
+	CFG_GATE(GATE_APB2DIVRDY,	RCC_APB2DIVR,		31),
+	CFG_GATE(GATE_APB3DIVRDY,	RCC_APB3DIVR,		31),
+	CFG_GATE(GATE_APB4DIVRDY,	RCC_APB4DIVR,		31),
+	CFG_GATE(GATE_APB5DIVRDY,	RCC_APB5DIVR,		31),
+	CFG_GATE(GATE_APB6DIVRDY,	RCC_APB6DIVR,		31),
+	CFG_GATE(GATE_PLL1,		RCC_PLL1CR,		0),
+	CFG_GATE(GATE_PLL1_RDY,		RCC_PLL1CR,		1),
+	CFG_GATE(GATE_PLL1_DIVP,	RCC_PLL1CR,		4),
+	CFG_GATE(GATE_PLL1_DIVQ,	RCC_PLL1CR,		5),
+	CFG_GATE(GATE_PLL1_DIVR,	RCC_PLL1CR,		6),
+	CFG_GATE(GATE_PLL2,		RCC_PLL2CR,		0),
+	CFG_GATE(GATE_PLL2_RDY,		RCC_PLL2CR,		1),
+	CFG_GATE(GATE_PLL2_DIVP,	RCC_PLL2CR,		4),
+	CFG_GATE(GATE_PLL2_DIVQ,	RCC_PLL2CR,		5),
+	CFG_GATE(GATE_PLL2_DIVR,	RCC_PLL2CR,		6),
+	CFG_GATE(GATE_PLL3,		RCC_PLL3CR,		0),
+	CFG_GATE(GATE_PLL3_RDY,		RCC_PLL3CR,		1),
+	CFG_GATE(GATE_PLL3_DIVP,	RCC_PLL3CR,		4),
+	CFG_GATE(GATE_PLL3_DIVQ,	RCC_PLL3CR,		5),
+	CFG_GATE(GATE_PLL3_DIVR,	RCC_PLL3CR,		6),
+	CFG_GATE(GATE_PLL4,		RCC_PLL4CR,		0),
+	CFG_GATE(GATE_PLL4_RDY,		RCC_PLL4CR,		1),
+	CFG_GATE(GATE_PLL4_DIVP,	RCC_PLL4CR,		4),
+	CFG_GATE(GATE_PLL4_DIVQ,	RCC_PLL4CR,		5),
+	CFG_GATE(GATE_PLL4_DIVR,	RCC_PLL4CR,		6),
 	CFG_GATE(GATE_MCO1,		RCC_MCO1CFGR,		12),
 	CFG_GATE(GATE_MCO2,		RCC_MCO2CFGR,		12),
 	CFG_GATE(GATE_DBGCK,		RCC_DBGCFGR,		8),
@@ -269,6 +363,25 @@ static struct stm32_gate_cfg stm32mp13_gates[] = {
 
 /* STM32 Divivers definition */
 enum enum_div_cfg {
+	DIV_PLL1DIVP,
+	DIV_PLL2DIVP,
+	DIV_PLL2DIVQ,
+	DIV_PLL2DIVR,
+	DIV_PLL3DIVP,
+	DIV_PLL3DIVQ,
+	DIV_PLL3DIVR,
+	DIV_PLL4DIVP,
+	DIV_PLL4DIVQ,
+	DIV_PLL4DIVR,
+	DIV_MPU,
+	DIV_AXI,
+	DIV_MLAHB,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APB5,
+	DIV_APB6,
 	DIV_RTC,
 	DIV_HSI,
 	DIV_MCO1,
@@ -279,6 +392,26 @@ enum enum_div_cfg {
 	DIV_NB
 };
 
+static const struct clk_div_table axi_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 },
+	{ 4, 4 }, { 5, 4 }, { 6, 4 }, { 7, 4 },
+	{ 0 },
+};
+
+static const struct clk_div_table mlahb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 32 }, { 6, 64 }, { 7, 128 },
+	{ 8, 256 }, { 9, 512 }, { 10, 512}, { 11, 512 },
+	{ 12, 512 }, { 13, 512 }, { 14, 512}, { 15, 512 },
+	{ 0 },
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+
 static const struct clk_div_table ck_trace_div_table[] = {
 	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
 	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
@@ -296,6 +429,28 @@ static const struct clk_div_table ck_trace_div_table[] = {
 	}
 
 static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
+	CFG_DIV(DIV_MPU, RCC_MPCKDIVR, 0, 4, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_AXI, RCC_AXIDIVR, 0, 3, 0, axi_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_MLAHB, RCC_MLAHBDIVR, 0, 4, 0, mlahb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB5, RCC_APB5DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_APB6, RCC_APB6DIVR, 0, 3, 0, apb_div_table, DIV_NO_RDY),
+	CFG_DIV(DIV_HSI, RCC_HSICFGR, 0, 2, CLK_DIVIDER_POWER_OF_TWO, NULL, DIV_NO_RDY),
+
+	CFG_DIV(DIV_PLL1DIVP, RCC_PLL1CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVP, RCC_PLL2CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVQ, RCC_PLL2CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL2DIVR, RCC_PLL2CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVP, RCC_PLL3CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVQ, RCC_PLL3CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL3DIVR, RCC_PLL3CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVP, RCC_PLL4CFGR2, 0, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVQ, RCC_PLL4CFGR2, 8, 7, 0, NULL, DIV_NO_RDY),
+	CFG_DIV(DIV_PLL4DIVR, RCC_PLL4CFGR2, 16, 7, 0, NULL, DIV_NO_RDY),
+
 	CFG_DIV(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, DIV_NO_RDY),
 	CFG_DIV(DIV_MCO1, RCC_MCO1CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
 	CFG_DIV(DIV_MCO2, RCC_MCO2CFGR, 4, 4, 0, NULL, DIV_NO_RDY),
@@ -306,6 +461,14 @@ static const struct stm32_div_cfg stm32mp13_dividers[DIV_NB] = {
 
 /* STM32 Muxes definition */
 enum enum_mux_cfg {
+	MUX_MPU,
+	MUX_AXI,
+	MUX_MLAHB,
+	MUX_PLL12,
+	MUX_PLL3,
+	MUX_PLL4,
+	MUX_RTC,
+	MUX_CKPER,
 	MUX_ADC1,
 	MUX_ADC2,
 	MUX_DCMIPP,
@@ -363,6 +526,14 @@ enum enum_mux_cfg {
 	_CFG_MUX(_id, _offset, _shift, _witdh, MUX_NO_RDY, MUX_SAFE)
 
 static const struct stm32_mux_cfg stm32mp13_muxes[] = {
+	CFG_MUX(MUX_MPU,	RCC_MPCKSELR,		0, 2),
+	CFG_MUX(MUX_AXI,	RCC_ASSCKSELR,		0, 3),
+	CFG_MUX(MUX_MLAHB,	RCC_MSSCKSELR,		0, 2),
+	CFG_MUX(MUX_PLL12,	RCC_RCK12SELR,		0, 2),
+	CFG_MUX(MUX_PLL3,	RCC_RCK3SELR,		0, 2),
+	CFG_MUX(MUX_PLL4,	RCC_RCK4SELR,		0, 2),
+	CFG_MUX(MUX_CKPER,	RCC_CPERCKSELR,		0, 2),
+	CFG_MUX(MUX_RTC,	RCC_BDCR,		16, 2),
 	CFG_MUX(MUX_I2C12,	RCC_I2C12CKSELR,	0, 3),
 	CFG_MUX(MUX_LPTIM45,	RCC_LPTIM45CKSELR,	0, 3),
 	CFG_MUX(MUX_SPI23,	RCC_SPI2S23CKSELR,	0, 3),
@@ -581,7 +752,7 @@ static const char * const qspi_src[] = {
 };
 
 static const char * const rng1_src[] = {
-	"ck_csi", "pll4_r", "ck_lse", "ck_lsi"
+	"ck_csi", "pll4_r", "reserved", "ck_lsi"
 };
 
 static const char * const saes_src[] = {
@@ -712,6 +883,16 @@ static struct clk_stm32_gate tim17_k = {
 };
 
 /* Peripheral clocks */
+static struct clk_stm32_gate spi2 = {
+	.gate_id = GATE_SPI2,
+	.hw.init = CLK_HW_INIT("spi2", "pclk1", &clk_stm32_gate_ops, 0),
+};
+
+static struct clk_stm32_gate spi3 = {
+	.gate_id = GATE_SPI3,
+	.hw.init = CLK_HW_INIT("spi3", "pclk1", &clk_stm32_gate_ops, 0),
+};
+
 static struct clk_stm32_gate sai1 = {
 	.gate_id = GATE_SAI1,
 	.hw.init = CLK_HW_INIT("sai1", "pclk2", &clk_stm32_gate_ops, 0),
@@ -722,6 +903,11 @@ static struct clk_stm32_gate sai2 = {
 	.hw.init = CLK_HW_INIT("sai2", "pclk2", &clk_stm32_gate_ops, 0),
 };
 
+static struct clk_stm32_gate spi1 = {
+	.gate_id = GATE_SPI1,
+	.hw.init = CLK_HW_INIT("spi1", "pclk2", &clk_stm32_gate_ops, 0),
+};
+
 static struct clk_stm32_gate syscfg = {
 	.gate_id = GATE_SYSCFG,
 	.hw.init = CLK_HW_INIT("syscfg", "pclk3", &clk_stm32_gate_ops, 0),
@@ -827,6 +1013,16 @@ static struct clk_stm32_gate bsec = {
 	.hw.init = CLK_HW_INIT("bsec", "pclk5", &clk_stm32_gate_ops, 0),
 };
 
+static struct clk_stm32_gate spi4 = {
+	.gate_id = GATE_SPI4,
+	.hw.init = CLK_HW_INIT("spi4", "pclk6", &clk_stm32_gate_ops, 0),
+};
+
+static struct clk_stm32_gate spi5 = {
+	.gate_id = GATE_SPI5,
+	.hw.init = CLK_HW_INIT("spi5", "pclk6", &clk_stm32_gate_ops, 0),
+};
+
 static struct clk_stm32_gate dma1 = {
 	.gate_id = GATE_DMA1,
 	.hw.init = CLK_HW_INIT("dma1", "ck_mlahb", &clk_stm32_gate_ops, 0),
@@ -1351,6 +1547,11 @@ static const struct clock_config stm32mp13_clock_cfg[] = {
 	STM32_GATE_CFG(TIM17_K, tim17_k, SECF_TIM17),
 
 	/* Peripheral clocks */
+	STM32_GATE_CFG(SPI1, spi1, SECF_NONE),
+	STM32_GATE_CFG(SPI2, spi2, SECF_NONE),
+	STM32_GATE_CFG(SPI3, spi3, SECF_NONE),
+	STM32_GATE_CFG(SPI4, spi4, SECF_SPI4),
+	STM32_GATE_CFG(SPI5, spi5, SECF_SPI5),
 	STM32_GATE_CFG(SAI1, sai1, SECF_NONE),
 	STM32_GATE_CFG(SAI2, sai2, SECF_NONE),
 	STM32_GATE_CFG(SYSCFG, syscfg, SECF_NONE),
@@ -1503,6 +1704,10 @@ static struct clk_hw *stm32mp13_is_multi_mux(struct clk_hw *hw)
 
 static u16 stm32mp13_cpt_gate[GATE_NB];
 
+#ifdef CONFIG_DEBUG_FS
+static struct clock_summary clock_summary_mp13;
+#endif
+
 static struct clk_stm32_clock_data stm32mp13_clock_data = {
 	.gate_cpt	= stm32mp13_cpt_gate,
 	.gates		= stm32mp13_gates,
@@ -1518,6 +1723,10 @@ static const struct stm32_rcc_match_data stm32mp13_data = {
 	.check_security = &stm32mp13_clock_is_provided_by_secure,
 	.maxbinding	= STM32MP1_LAST_CLK,
 	.clear_offset	= RCC_CLR_OFFSET,
+	.reset_us	= 2,
+#ifdef CONFIG_DEBUG_FS
+	.clock_summary	= &clock_summary_mp13,
+#endif
 };
 
 static const struct of_device_id stm32mp13_match_data[] = {
@@ -1618,3 +1827,505 @@ static int __init stm32mp13_clocks_init(void)
 	return platform_driver_register(&stm32mp13_rcc_clocks_driver);
 }
 core_initcall(stm32mp13_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+/* STM32 PLL */
+struct clk_pll_fractional_divider {
+	struct clk_hw hw;
+	void __iomem *mreg;
+	u8 mshift;
+	u8 mwidth;
+	u8 mflags;
+	void __iomem *nreg;
+	u8 nshift;
+	u8 nwidth;
+	u8 nflags;
+	void __iomem *freg;
+	u8 fshift;
+	u8 fwidth;
+
+	/* lock pll enable/disable registers */
+	spinlock_t *lock;
+};
+
+struct cs_pll {
+	u32 offset;
+};
+
+#define PLL_BIT_ON		0
+#define PLL_BIT_RDY		1
+#define PLL_MUX_SHIFT		0
+#define PLL_MUX_MASK		3
+#define PLL_DIVMN_OFFSET	4
+#define PLL_DIVM_SHIFT		16
+#define PLL_DIVM_WIDTH		6
+#define PLL_DIVN_SHIFT		0
+#define PLL_DIVN_WIDTH		9
+#define PLL_FRAC_OFFSET		0xC
+#define PLL_FRAC_SHIFT		3
+#define PLL_FRAC_WIDTH		13
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clk_stm32_clock_data *data,
+							  struct clk_summary *c,
+							  unsigned long parent_rate)
+{
+	struct cs_pll *pll = (struct cs_pll *)c->data;
+	struct clk_pll_fractional_divider fracdiv;
+	struct clk_pll_fractional_divider *fd = &fracdiv;
+	void __iomem *reg;
+	u32 mmask;
+	u32 nmask;
+	u32 fmask;
+	unsigned long m, n, f;
+	u64 rate, frate = 0;
+	u32 val;
+
+	reg = data->base + pll->offset;
+	fd->mreg = reg + PLL_DIVMN_OFFSET;
+	fd->mshift = PLL_DIVM_SHIFT;
+	fd->mwidth = PLL_DIVM_WIDTH;
+	fd->mflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->nreg = reg + PLL_DIVMN_OFFSET;
+	fd->nshift = PLL_DIVN_SHIFT;
+	fd->nwidth = PLL_DIVN_WIDTH;
+	fd->nflags = CLK_FRAC_DIVIDER_ZERO_BASED;
+	fd->freg = reg + PLL_FRAC_OFFSET;
+	fd->fshift = PLL_FRAC_SHIFT;
+	fd->fwidth = PLL_FRAC_WIDTH;
+
+	mmask = GENMASK(fd->mwidth - 1, 0) << fd->mshift;
+	nmask = GENMASK(fd->nwidth - 1, 0) << fd->nshift;
+	fmask = GENMASK(fd->fwidth - 1, 0) << fd->fshift;
+
+	val = readl(fd->mreg);
+	m = (val & mmask) >> fd->mshift;
+	if (fd->mflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		m++;
+
+	val = readl(fd->nreg);
+	n = (val & nmask) >> fd->nshift;
+	if (fd->nflags & CLK_FRAC_DIVIDER_ZERO_BASED)
+		n++;
+
+	if (!n || !m)
+		return parent_rate;
+
+	rate = (u64)parent_rate * n;
+	do_div(rate, m);
+
+	val = readl(fd->freg);
+	f = (val & fmask) >> fd->fshift;
+	if (f) {
+		frate = (u64)parent_rate * (u64)f;
+		do_div(frate, (m * (1 << fd->fwidth)));
+	}
+
+	return rate + frate;
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	return parent_rate / 2;
+}
+
+static unsigned long clk_summary_osc_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+static unsigned long clk_summary_div_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return stm32_divider_get_rate(data->base, data, c->div_id, parent_rate);
+}
+
+/* The divider of RTC clock concerns only ck_hse clock */
+#define HSE_RTC 3
+
+static unsigned long clk_summary_rtc_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	u8 parent;
+
+	parent = stm32_mux_get_parent(data->base, data, c->mux_id);
+	if (parent == HSE_RTC)
+		return clk_summary_div_recalc_rate(data, c, parent_rate);
+
+	return parent_rate;
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+#define APB_DIV_MASK 0x07
+#define TIM_PRE_MASK 0x01
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = (struct cs_stm32_timer *)c->data;
+	void __iomem *rcc_base = data->base;
+	u32 prescaler, timpre;
+
+	prescaler = readl(rcc_base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(rcc_base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define PARENT(_parent)	((const char *[]) { _parent})
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_osc_recalc_rate,\
+}
+
+#define CS_DIV2(_name, _parent) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_MUX(_name, _parents, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.mux_id		= _mux,\
+	.gate_id	= NO_STM32_GATE,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_COMPOSITE(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_RTC(_name, _parents, _gate, _mux, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 4,\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= _div,\
+	.get_rate	= clk_summary_rtc_recalc_rate,\
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static const char * const ref12_parents[] = {
+	"ck_hsi", "ck_hse"
+};
+
+static const char * const ref3_parents[] = {
+	"ck_hsi", "ck_hse", "ck_csi"
+};
+
+static const char * const ref4_parents[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "i2s_ckin"
+};
+
+static const char * const cpu_src[] = {
+	"ck_hsi", "ck_hse", "pll1_p", "pll1_p_div"
+};
+
+static const char * const axi_src[] = {
+	"ck_hsi", "ck_hse", "pll2_p"
+};
+
+static const char * const mlahb_src[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "pll3_p"
+};
+
+static const char * const per_src[] = {
+	"ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const rtc_src[] = {
+	"off", "ck_lse", "ck_lsi", "ck_hse"
+};
+
+static struct clk_summary stm32mp13_clock_summary[] = {
+	CS_OSC("ck_hsi", GATE_HSI),
+	CS_OSC("ck_csi", GATE_CSI),
+	CS_OSC("ck_lsi", GATE_LSI),
+	CS_OSC("ck_hse", GATE_HSE),
+	CS_OSC("ck_lse", GATE_LSE),
+	CS_OSC("ck_usbo_48m", NO_STM32_GATE),
+	CS_DIV2("clk-hse-div2", "ck_hse"),
+
+	CS_PLL("pll1", ref12_parents, GATE_PLL1, MUX_PLL12, RCC_PLL1CR),
+
+	CS_GATEDIV("pll1_p", "pll1", GATE_PLL1_DIVP, DIV_PLL1DIVP),
+
+	CS_DIV("pll1_p_div", "pll1_p", DIV_MPU),
+
+	CS_PLL("pll2", ref12_parents, GATE_PLL2, MUX_PLL12, RCC_PLL2CR),
+	CS_GATEDIV("pll2_p", "pll2", GATE_PLL2_DIVP, DIV_PLL2DIVP),
+	CS_GATEDIV("pll2_q", "pll2", GATE_PLL2_DIVQ, DIV_PLL2DIVQ),
+	CS_GATEDIV("pll2_r", "pll2", GATE_PLL2_DIVR, DIV_PLL2DIVR),
+
+	CS_PLL("pll3", ref3_parents, GATE_PLL3, MUX_PLL3, RCC_PLL3CR),
+	CS_GATEDIV("pll3_p", "pll3", GATE_PLL3_DIVP, DIV_PLL3DIVP),
+	CS_GATEDIV("pll3_q", "pll3", GATE_PLL3_DIVQ, DIV_PLL3DIVQ),
+	CS_GATEDIV("pll3_r", "pll3", GATE_PLL3_DIVR, DIV_PLL3DIVR),
+
+	CS_PLL("pll4", ref4_parents, GATE_PLL4, MUX_PLL4, RCC_PLL4CR),
+	CS_GATEDIV("pll4_p", "pll4", GATE_PLL4_DIVP, DIV_PLL4DIVP),
+	CS_GATEDIV("pll4_q", "pll4", GATE_PLL4_DIVQ, DIV_PLL4DIVQ),
+	CS_GATEDIV("pll4_r", "pll4", GATE_PLL4_DIVR, DIV_PLL4DIVR),
+
+	CS_MUX("ck_mpu", cpu_src, MUX_MPU),
+	CS_MUX("ck_axi", axi_src, MUX_AXI),
+	CS_MUX("ck_mlahb", mlahb_src, MUX_MLAHB),
+	CS_MUX("ck_per", per_src, MUX_CKPER),
+
+	CS_DIV("pclk1", "ck_mlahb", DIV_APB1),
+	CS_DIV("pclk2", "ck_mlahb", DIV_APB2),
+	CS_DIV("pclk3", "ck_mlahb", DIV_APB3),
+	CS_DIV("pclk4", "ck_axi", DIV_APB4),
+	CS_DIV("pclk5", "ck_axi", DIV_APB5),
+	CS_DIV("pclk6", "ck_mlahb", DIV_APB6),
+
+	CS_STM32_TIMER("timg1_ck", "pclk1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("timg2_ck", "pclk2", RCC_APB2DIVR, RCC_TIMG2PRER),
+	CS_STM32_TIMER("timg3_ck", "pclk1", RCC_APB6DIVR, RCC_TIMG3PRER),
+
+	CS_GATE("tim2_k", "timg1_ck", GATE_TIM2),
+	CS_GATE("tim3_k", "timg1_ck", GATE_TIM3),
+	CS_GATE("tim4_k", "timg1_ck", GATE_TIM4),
+	CS_GATE("tim5_k", "timg1_ck", GATE_TIM5),
+	CS_GATE("tim6_k", "timg1_ck", GATE_TIM6),
+	CS_GATE("tim7_k", "timg1_ck", GATE_TIM7),
+	CS_GATE("tim1_k", "timg2_ck", GATE_TIM1),
+	CS_GATE("tim8_k", "timg2_ck", GATE_TIM8),
+	CS_GATE("tim12_k", "timg3_ck", GATE_TIM12),
+	CS_GATE("tim13_k", "timg3_ck", GATE_TIM13),
+	CS_GATE("tim14_k", "timg3_ck", GATE_TIM14),
+	CS_GATE("tim15_k", "timg3_ck", GATE_TIM15),
+	CS_GATE("tim16_k", "timg3_ck", GATE_TIM16),
+	CS_GATE("tim17_k", "timg3_ck", GATE_TIM17),
+
+	CS_GATE("spi2", "pclk1", GATE_SPI2),
+	CS_GATE("spi3", "pclk1", GATE_SPI3),
+
+	CS_GATE("sai1", "pclk2", GATE_SAI1),
+	CS_GATE("sai2", "pclk2", GATE_SAI2),
+	CS_GATE("spi1", "pclk2", GATE_SPI1),
+
+	CS_GATE("syscfg", "pclk3", GATE_SYSCFG),
+	CS_GATE("vref", "pclk3", GATE_VREF),
+	CS_GATE("dts", "pclk3", GATE_DTS),
+	CS_GATE("pmbctrl", "pclk3", GATE_PMBCTRL),
+	CS_GATE("hdp", "pclk3", GATE_HDP),
+
+	CS_GATE("iwdg2", "pclk4", GATE_IWDG2APB),
+	CS_GATE("stgenro", "pclk4", GATE_STGENRO),
+	CS_GATE("gpioa", "pclk4", GATE_GPIOA),
+	CS_GATE("gpiob", "pclk4", GATE_GPIOB),
+	CS_GATE("gpioc", "pclk4", GATE_GPIOC),
+	CS_GATE("gpiod", "pclk4", GATE_GPIOD),
+	CS_GATE("gpioe", "pclk4", GATE_GPIOE),
+	CS_GATE("gpiof", "pclk4", GATE_GPIOF),
+	CS_GATE("gpiog", "pclk4", GATE_GPIOG),
+	CS_GATE("gpioh", "pclk4", GATE_GPIOH),
+	CS_GATE("gpioi", "pclk4", GATE_GPIOI),
+	CS_GATE("tsc", "pclk4", GATE_TSC),
+	CS_GATE("ddrperfm", "pclk4", GATE_DDRPERFM),
+
+	CS_GATE("tzpc", "pclk5", GATE_TZC),
+	CS_GATE("iwdg1", "pclk5", GATE_IWDG1APB),
+	CS_GATE("bsec", "pclk5", GATE_BSEC),
+
+	CS_GATE("spi4", "pclk6", GATE_SPI4),
+	CS_GATE("spi5", "pclk6", GATE_SPI5),
+
+	CS_GATE("dma1", "ck_mlahb", GATE_DMA1),
+	CS_GATE("dma2", "ck_mlahb", GATE_DMA2),
+	CS_GATE("dmamux1", "ck_mlahb", GATE_DMAMUX1),
+	CS_GATE("dma3", "ck_mlahb", GATE_DMA3),
+	CS_GATE("dmamux2", "ck_mlahb", GATE_DMAMUX2),
+	CS_GATE("adc1", "ck_mlahb", GATE_ADC1),
+	CS_GATE("adc2", "ck_mlahb", GATE_ADC2),
+
+	CS_GATE("pka", "ck_axi", GATE_PKA),
+	CS_GATE("cryp1", "ck_axi", GATE_CRYP1),
+	CS_GATE("hash1", "ck_axi", GATE_HASH1),
+	CS_GATE("bkpsram", "ck_axi", GATE_BKPSRAM),
+	CS_GATE("mdma", "ck_axi", GATE_MDMA),
+	CS_GATE("eth1tx", "ck_axi", GATE_ETH1TX),
+	CS_GATE("eth1rx", "ck_axi", GATE_ETH1RX),
+	CS_GATE("eth1mac", "ck_axi", GATE_ETH1MAC),
+	CS_GATE("eth2tx", "ck_axi", GATE_ETH2TX),
+	CS_GATE("eth2rx", "ck_axi", GATE_ETH2RX),
+	CS_GATE("eth2mac", "ck_axi", GATE_ETH2MAC),
+	CS_GATE("crc1", "ck_axi", GATE_CRC1),
+	CS_GATE("usbh", "ck_axi", GATE_USBH),
+	CS_GATE("eth1stp", "ck_axi", GATE_ETH1STP),
+	CS_GATE("eth2stp", "ck_axi", GATE_ETH2STP),
+
+	CS_GATEMUX("sdmmc1_k", sdmmc12_src, GATE_SDMMC1, MUX_SDMMC1),
+	CS_GATEMUX("sdmmc2_k", sdmmc12_src, GATE_SDMMC2, MUX_SDMMC2),
+	CS_GATEMUX("fmc_k", fmc_src, GATE_FMC, MUX_FMC),
+	CS_GATEMUX("qspi_k", qspi_src, GATE_QSPI, MUX_QSPI),
+	CS_GATEMUX("spi2_k", spi123_src, GATE_SPI2, MUX_SPI23),
+	CS_GATEMUX("spi3_k", spi123_src, GATE_SPI3, MUX_SPI23),
+	CS_GATEMUX("i2c1_k", i2c12_src, GATE_I2C1, MUX_I2C12),
+	CS_GATEMUX("i2c2_k", i2c12_src, GATE_I2C2, MUX_I2C12),
+	CS_GATEMUX("lptim4_k", lptim45_src, GATE_LPTIM4, MUX_LPTIM45),
+	CS_GATEMUX("lptim5_k", lptim45_src, GATE_LPTIM5, MUX_LPTIM45),
+	CS_GATEMUX("usart3_k", usart34578_src, GATE_USART3, MUX_UART35),
+	CS_GATEMUX("uart5_k", usart34578_src, GATE_UART5, MUX_UART35),
+	CS_GATEMUX("uart7_k", usart34578_src, GATE_UART7, MUX_UART78),
+	CS_GATEMUX("uart8_k", usart34578_src, GATE_UART8, MUX_UART78),
+	CS_GATEMUX("sai1_k", sai1_src, GATE_SAI1, MUX_SAI1),
+	CS_GATEMUX("adfsdm_k", sai1_src, GATE_ADFSDM, MUX_SAI1),
+	CS_GATEMUX("sai2_k", sai2_src, GATE_SAI2, MUX_SAI2),
+	CS_GATEMUX("adc1_k", adc12_src, GATE_ADC1, MUX_ADC1),
+	CS_GATEMUX("adc2_k", adc12_src, GATE_ADC2, MUX_ADC2),
+	CS_GATEMUX("rng1_k", rng1_src, GATE_RNG1, MUX_RNG1),
+	CS_GATEMUX("usbphy_k", usbphy_src, GATE_USBPHY, MUX_USBPHY),
+	CS_GATEMUX("stgen_k", stgen_src, GATE_STGENC, MUX_STGEN),
+	CS_GATEMUX("spdif_k", spdif_src, GATE_SPDIF, MUX_SPDIF),
+	CS_GATEMUX("spi1_k", spi123_src, GATE_SPI1, MUX_SPI1),
+	CS_GATEMUX("spi4_k", spi4_src, GATE_SPI4, MUX_SPI4),
+	CS_GATEMUX("spi5_k", spi5_src, GATE_SPI5, MUX_SPI5),
+	CS_GATEMUX("i2c3_k", i2c345_src, GATE_I2C3, MUX_I2C3),
+	CS_GATEMUX("i2c4_k", i2c345_src, GATE_I2C4, MUX_I2C4),
+	CS_GATEMUX("i2c5_k", i2c345_src, GATE_I2C5, MUX_I2C5),
+	CS_GATEMUX("lptim1_k", lptim1_src, GATE_LPTIM1, MUX_LPTIM1),
+	CS_GATEMUX("lptim2_k", lptim23_src, GATE_LPTIM2, MUX_LPTIM2),
+	CS_GATEMUX("lptim3_k", lptim23_src, GATE_LPTIM3, MUX_LPTIM3),
+	CS_GATEMUX("usart1_k", usart12_src, GATE_USART1, MUX_UART1),
+	CS_GATEMUX("usart2_k", usart12_src, GATE_USART2, MUX_UART2),
+	CS_GATEMUX("uart4_k", usart34578_src, GATE_UART4, MUX_UART4),
+	CS_GATEMUX("uart6_k", usart6_src, GATE_USART6, MUX_UART6),
+	CS_GATEMUX("fdcan_k", fdcan_src, GATE_FDCAN, MUX_FDCAN),
+	CS_GATEMUX("dcmipp_k", dcmipp_src, GATE_DCMIPP, MUX_DCMIPP),
+	CS_GATEMUX("usbo_k", usbo_src, GATE_USBO, MUX_USBO),
+	CS_GATEMUX("eth1ck_k", eth12_src, GATE_ETH1CK, MUX_ETH1),
+	CS_GATEMUX("eth2ck_k", eth12_src, GATE_ETH2CK, MUX_ETH2),
+	CS_GATEMUX("saes_k", saes_src, GATE_SAES, MUX_SAES),
+	CS_GATE("dfsdm_k", "ck_mlahb", GATE_DFSDM),
+	CS_GATE("ltdc_px", "pll4_q", GATE_LTDC),
+	CS_COMPOSITE("eth1ptp_k", eth12_src, NO_STM32_GATE, MUX_ETH1, DIV_ETH1PTP),
+	CS_COMPOSITE("eth2ptp_k", eth12_src, NO_STM32_GATE, MUX_ETH2, DIV_ETH2PTP),
+	CS_COMPOSITE("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1, DIV_MCO1),
+	CS_COMPOSITE("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2, DIV_MCO2),
+	CS_GATE("ck_sys_dbg", "ck_axi", GATE_DBGCK),
+	CS_GATEDIV("ck_trace", "ck_axi", GATE_TRACECK, DIV_TRACE),
+	CS_GATE("rtcapb", "pclk5", GATE_RTCAPB),
+	CS_RTC("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC, DIV_RTC),
+};
+
+static struct clock_summary clock_summary_mp13 = {
+	.clocks		= stm32mp13_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp13_clock_summary),
+};
+
+#endif
diff --git a/drivers/clk/stm32/clk-stm32mp25-syscfg.c b/drivers/clk/stm32/clk-stm32mp25-syscfg.c
new file mode 100644
index 000000000..d004a2ce6
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp25-syscfg.c
@@ -0,0 +1,142 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk-regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define SYSCFG_DISPLAYCLKCR	0x5000
+
+static const char * const clk_pix_ltdc_src[] = {
+	"txbyteclk", "clk_pix_lvds", "ck_ker_ltdc"
+};
+
+static u8 clk_regmap_mux_get_parent(struct clk_hw *hw)
+{
+	return clk_regmap_mux_ops.get_parent(hw);
+}
+
+static int clk_regmap_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	return clk_regmap_mux_ops.set_parent(hw, index);
+}
+
+static int clk_regmap_mux_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	return clk_regmap_mux_ops.determine_rate(hw, req);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void clk_regmap_mux_pm_restore(struct clk_hw *hw)
+{
+	struct clk_hw *hwp = clk_hw_get_parent(hw);
+	int index;
+
+	if (hwp != NULL) {
+		index = clk_hw_get_parent_index(hw);
+		clk_regmap_mux_set_parent(hw, index);
+	}
+}
+#endif
+
+static const struct clk_ops clk_syscfg_mux_ops = {
+	.get_parent = clk_regmap_mux_get_parent,
+	.set_parent = clk_regmap_mux_set_parent,
+	.determine_rate = clk_regmap_mux_determine_rate,
+#ifdef CONFIG_PM_SLEEP
+	.restore_context = clk_regmap_mux_pm_restore,
+#endif
+};
+
+static struct clk_regmap clk_pix_ltdc = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = SYSCFG_DISPLAYCLKCR,
+		.mask = 0x3,
+		.shift = 0,
+	},
+	.hw.init = CLK_HW_INIT_PARENTS("clk_pix_ltdc", clk_pix_ltdc_src, &clk_syscfg_mux_ops,
+				       CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT),
+};
+
+static struct clk_hw *stm32_syscfg_mp25_hw_clocks[] = {
+		&clk_pix_ltdc.hw,
+};
+
+struct stm32_syscfg_match_data {
+	unsigned int	num_clocks;
+	struct clk_hw	**tab_clocks;
+};
+
+static struct stm32_syscfg_match_data syscfg_mp25_data = {
+	.tab_clocks	= stm32_syscfg_mp25_hw_clocks,
+	.num_clocks	= ARRAY_SIZE(stm32_syscfg_mp25_hw_clocks),
+};
+
+static int stm32mp25_syscfg_clocks_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	const struct stm32_syscfg_match_data *data;
+	struct regmap *regmap;
+	struct clk_hw_onecell_data *hw_data;
+	int ret, n;
+
+	data = device_get_match_data(dev);
+	if (!data)
+		return -EINVAL;
+
+	regmap = syscon_node_to_regmap(np);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	hw_data = devm_kzalloc(dev, struct_size(hw_data, hws, data->num_clocks), GFP_KERNEL);
+	if (!hw_data)
+		return -ENOMEM;
+
+	hw_data->num = data->num_clocks;
+
+	for (n = 0; n < data->num_clocks; n++) {
+		struct clk_hw *hw = data->tab_clocks[n];
+		struct clk_regmap *clk = to_clk_regmap(hw);
+
+		clk->map = regmap;
+
+		ret = devm_clk_hw_register(dev, hw);
+		if (ret) {
+			dev_warn(dev, "failed to register %s\n", hw->init->name);
+			hw = ERR_PTR(-ENOENT);
+		}
+
+		hw_data->hws[n] = hw;
+	}
+
+	ret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, hw_data);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static const struct of_device_id stm32mp25_syscfg_match_data[] = {
+	{
+		.compatible = "st,stm32mp25-syscfg",
+		.data = &syscfg_mp25_data,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm32mp25_syscfg_match_data);
+
+static struct platform_driver stm32mp25_syscfg_driver = {
+	.probe = stm32mp25_syscfg_clocks_probe,
+	.driver = {
+		.name = "stm32mp25_syscfg",
+		.of_match_table = stm32mp25_syscfg_match_data,
+	},
+};
+module_platform_driver(stm32mp25_syscfg_driver);
diff --git a/drivers/clk/stm32/clk-stm32mp25.c b/drivers/clk/stm32/clk-stm32mp25.c
new file mode 100644
index 000000000..72d55012a
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp25.c
@@ -0,0 +1,2037 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "clk-stm32-core.h"
+
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+#include <dt-bindings/clock/stm32mp25-clks.h>
+
+#include "stm32mp25_rcc.h"
+
+/* Temporary */
+#include "../../bus/stm32_sys_bus.h"
+
+/* Clock security definition */
+#define SECF_NONE		-1
+
+#define RCC_REG_SIZE	32
+#define RCC_SECCFGR(x)	(((x) / RCC_REG_SIZE) * 0x4 + RCC_SECCFGR0)
+#define RCC_CIDCFGR(x)	((x) * 0x8 + RCC_R0CIDCFGR)
+#define RCC_SEMCR(x)	((x) * 0x8 + RCC_R0SEMCR)
+#define RCC_CID1	1
+
+/* Register: RIFSC_CIDCFGR */
+#define RCC_CIDCFGR_CFEN	BIT(0)
+#define RCC_CIDCFGR_SEM_EN	BIT(1)
+#define RCC_CIDCFGR_SEMWLC1_EN	BIT(17)
+#define RCC_CIDCFGR_SCID_MASK	GENMASK(6, 4)
+
+/* Register: RIFSC_SEMCR */
+#define RCC_SEMCR_SEMCID_MASK	GENMASK(6, 4)
+
+#define STM32MP25_RIFRCC_DBG_ID		73
+#define STM32MP25_RIFRCC_IS2M_ID	107
+#define STM32MP25_RIFRCC_MCO1_ID	108
+#define STM32MP25_RIFRCC_MCO2_ID	109
+#define STM32MP25_RIFRCC_OSPI1_ID	110
+#define STM32MP25_RIFRCC_OSPI2_ID	111
+
+#define SEC_RIFSC_FLAG		BIT(31)
+#define SEC_RIFRCC(_id)		(STM32MP25_RIFRCC_##_id##_ID)
+#define SEC_RIFSC(_name)	(STM32MP25_RIFSC_##_name##_ID | SEC_RIFSC_FLAG)
+
+static const char * const adc12_src[] = {
+	"ck_flexgen_46", "ck_icn_ls_mcu"
+};
+
+static const char * const adc3_src[] = {
+	"ck_flexgen_47", "ck_icn_ls_mcu", "ck_flexgen_46"
+};
+
+static const char * const usb2phy1_src[] = {
+	"ck_flexgen_57", "hse_div2_ck"
+};
+
+static const char * const usb2phy2_src[] = {
+	"ck_flexgen_58", "hse_div2_ck"
+};
+
+static const char * const usb3pciphy_src[] = {
+	"ck_flexgen_34", "hse_div2_ck"
+};
+
+static const char * const dsiblane_src[] = {
+	"txbyteclk", "ck_ker_ltdc"
+};
+
+static const char * const dsiphy_src[] = {
+	"ck_flexgen_28", "hse_ck"
+};
+
+static const char * const lvdsphy_src[] = {
+	"ck_flexgen_32", "hse_ck"
+};
+
+static const char * const dts_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const mco1_src[] = {
+	"ck_flexgen_61", "ck_obs0"
+};
+
+static const char * const mco2_src[] = {
+	"ck_flexgen_62", "ck_obs1"
+};
+
+enum enum_mux_cfg {
+	MUX_MCO1,
+	MUX_MCO2,
+	MUX_ADC12,
+	MUX_ADC3,
+	MUX_USB2PHY1,
+	MUX_USB2PHY2,
+	MUX_USB3PCIEPHY,
+	MUX_DSIBLANE,
+	MUX_DSIPHY,
+	MUX_LVDSPHY,
+	MUX_DTS,
+
+#ifdef CONFIG_DEBUG_FS
+	MUX_MUXSEL0,
+	MUX_MUXSEL1,
+	MUX_MUXSEL2,
+	MUX_MUXSEL3,
+	MUX_MUXSEL4,
+	MUX_MUXSEL5,
+	MUX_MUXSEL6,
+	MUX_MUXSEL7,
+	MUX_XBARSEL,
+	MUX_RTC,
+	MUX_CPU1,
+	MUX_D3PER,
+#endif
+	MUX_NB
+};
+
+#define MUX_CFG(id, _offset, _shift, _witdh)\
+	[id] = {\
+		.offset		= (_offset),\
+		.shift		= (_shift),\
+		.width		= (_witdh),\
+	}
+
+static const struct stm32_mux_cfg stm32mp25_muxes[MUX_NB] = {
+	MUX_CFG(MUX_MCO1,		RCC_MCO1CFGR,		0,	1),
+	MUX_CFG(MUX_MCO2,		RCC_MCO2CFGR,		0,	1),
+	MUX_CFG(MUX_ADC12,		RCC_ADC12CFGR,		12,	1),
+	MUX_CFG(MUX_ADC3,		RCC_ADC3CFGR,		12,	2),
+	MUX_CFG(MUX_USB2PHY1,		RCC_USB2PHY1CFGR,	15,	1),
+	MUX_CFG(MUX_USB2PHY2,		RCC_USB2PHY2CFGR,	15,	1),
+	MUX_CFG(MUX_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	15,	1),
+	MUX_CFG(MUX_DSIBLANE,		RCC_DSICFGR,		12,	1),
+	MUX_CFG(MUX_DSIPHY,		RCC_DSICFGR,		15,	1),
+	MUX_CFG(MUX_LVDSPHY,		RCC_LVDSCFGR,		15,	1),
+	MUX_CFG(MUX_DTS,		RCC_DTSCFGR,		12,	2),
+
+#ifdef CONFIG_DEBUG_FS
+	MUX_CFG(MUX_MUXSEL0,		RCC_MUXSELCFGR,		0,	2),
+	MUX_CFG(MUX_MUXSEL1,		RCC_MUXSELCFGR,		4,	2),
+	MUX_CFG(MUX_MUXSEL2,		RCC_MUXSELCFGR,		8,	2),
+	MUX_CFG(MUX_MUXSEL3,		RCC_MUXSELCFGR,		12,	2),
+	MUX_CFG(MUX_MUXSEL4,		RCC_MUXSELCFGR,		16,	2),
+	MUX_CFG(MUX_MUXSEL5,		RCC_MUXSELCFGR,		20,	2),
+	MUX_CFG(MUX_MUXSEL6,		RCC_MUXSELCFGR,		24,	2),
+	MUX_CFG(MUX_MUXSEL7,		RCC_MUXSELCFGR,		28,	2),
+	MUX_CFG(MUX_XBARSEL,		RCC_XBAR0CFGR,		0,	4),
+	MUX_CFG(MUX_RTC,		RCC_BDCR,		16,	2),
+	MUX_CFG(MUX_D3PER,		RCC_D3DCR,		16,	2),
+#endif
+};
+
+enum enum_gate_cfg {
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_OSPI1,
+	GATE_OSPI2,
+	GATE_DBG,
+	GATE_TRACE,
+	GATE_STM,
+	GATE_IS2M,
+	GATE_TIM1,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM8,
+	GATE_TIM10,
+	GATE_TIM11,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_TIM20,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPI7,
+	GATE_SPI8,
+	GATE_SPDIFRX,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_USART3,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_USART6,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_UART9,
+	GATE_LPUART1,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_I2C7,
+	GATE_I2C8,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_MDF1,
+	GATE_ADF1,
+	GATE_FDCAN,
+	GATE_HDP,
+	GATE_ADC12,
+	GATE_ADC3,
+	GATE_ETH1MAC,
+	GATE_ETH1,
+	GATE_ETH1TX,
+	GATE_ETH1RX,
+	GATE_ETH1STP,
+	GATE_ETH2MAC,
+	GATE_ETH2,
+	GATE_ETH2STP,
+	GATE_ETH2TX,
+	GATE_ETH2RX,
+	GATE_USB2,
+	GATE_USB2PHY1,
+	GATE_USB2PHY2,
+	GATE_USB3DR,
+	GATE_USB3PCIEPHY,
+	GATE_PCIE,
+	GATE_USBTC,
+	GATE_ETHSWMAC,
+	GATE_ETHSW,
+	GATE_ETHSWREF,
+	GATE_ETHSWACMCFG,
+	GATE_ETHSWACMMSG,
+	GATE_STGEN,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_GPU,
+	GATE_LTDC,
+	GATE_DSI,
+	GATE_LVDS,
+	GATE_CSI,
+	GATE_DCMIPP,
+	GATE_CCI,
+	GATE_VDEC,
+	GATE_VENC,
+	GATE_RNG,
+	GATE_PKA,
+	GATE_SAES,
+	GATE_HASH,
+	GATE_CRYP1,
+	GATE_CRYP2,
+	GATE_IWDG1,
+	GATE_IWDG2,
+	GATE_IWDG3,
+	GATE_IWDG4,
+	GATE_IWDG5,
+	GATE_WWDG1,
+	GATE_WWDG2,
+	GATE_VREF,
+	GATE_DTS,
+	GATE_CRC,
+	GATE_SERC,
+	GATE_OSPIIOM,
+	GATE_I3C1,
+	GATE_I3C2,
+	GATE_I3C3,
+	GATE_I3C4,
+
+#ifdef CONFIG_DEBUG_FS
+	GATE_HSI,
+	GATE_HSE,
+	GATE_LSE,
+	GATE_LSI,
+	GATE_MSI,
+	GATE_HSEDIV2,
+	GATE_PLL1,
+	GATE_PLL2,
+	GATE_PLL3,
+	GATE_PLL4,
+	GATE_PLL5,
+	GATE_PLL6,
+	GATE_PLL7,
+	GATE_PLL8,
+	GATE_RTCCK,
+	GATE_C3,
+	GATE_LPTIM3C3,
+	GATE_LPTIM4C3,
+	GATE_LPTIM5C3,
+	GATE_SPI8C3,
+	GATE_LPUART1C3,
+	GATE_I2C8C3,
+	GATE_ADF1C3,
+	GATE_GPIOZC3,
+	GATE_LPDMAC3,
+	GATE_RTCC3,
+	GATE_I3C4C3,
+	GATE_DDRCP,
+	GATE_DDRCAPB,
+	GATE_DDRPHYCAPB,
+	GATE_DDRPHYC,
+	GATE_DDRCFG,
+	GATE_SYSRAM,
+	GATE_VDERAM,
+	GATE_SRAM1,
+	GATE_SRAM2,
+	GATE_RETRAM,
+	GATE_BKPSRAM,
+	GATE_LPSRAM1,
+	GATE_LPSRAM2,
+	GATE_LPSRAM3,
+	GATE_FMC,
+	GATE_ETR,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_GPIOJ,
+	GATE_GPIOK,
+	GATE_GPIOZ,
+	GATE_HPDMA1,
+	GATE_HPDMA2,
+	GATE_HPDMA3,
+	GATE_LPDMA,
+	GATE_HSEM,
+	GATE_IPCC1,
+	GATE_IPCC2,
+	GATE_RTC,
+	GATE_SYSCPU1,
+	GATE_BSEC,
+	GATE_GICV2M,
+#endif
+	GATE_NB
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)\
+	[id] = {\
+		.offset		= (_offset),\
+		.bit_idx	= (_bit_idx),\
+		.set_clr	= (_offset_clr),\
+	}
+
+static const struct stm32_gate_cfg stm32mp25_gates[GATE_NB] = {
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,		8,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,		8,	0),
+	GATE_CFG(GATE_OSPI1,		RCC_OSPI1CFGR,		1,	0),
+	GATE_CFG(GATE_OSPI2,		RCC_OSPI2CFGR,		1,	0),
+	GATE_CFG(GATE_DBG,		RCC_DBGCFGR,		8,	0),
+	GATE_CFG(GATE_TRACE,		RCC_DBGCFGR,		9,	0),
+	GATE_CFG(GATE_STM,		RCC_STMCFGR,		1,	0),
+	GATE_CFG(GATE_IS2M,		RCC_IS2MCFGR,		1,	0),
+	GATE_CFG(GATE_TIM1,		RCC_TIM1CFGR,		1,	0),
+	GATE_CFG(GATE_TIM2,		RCC_TIM2CFGR,		1,	0),
+	GATE_CFG(GATE_TIM3,		RCC_TIM3CFGR,		1,	0),
+	GATE_CFG(GATE_TIM4,		RCC_TIM4CFGR,		1,	0),
+	GATE_CFG(GATE_TIM5,		RCC_TIM5CFGR,		1,	0),
+	GATE_CFG(GATE_TIM6,		RCC_TIM6CFGR,		1,	0),
+	GATE_CFG(GATE_TIM7,		RCC_TIM7CFGR,		1,	0),
+	GATE_CFG(GATE_TIM8,		RCC_TIM8CFGR,		1,	0),
+	GATE_CFG(GATE_TIM10,		RCC_TIM10CFGR,		1,	0),
+	GATE_CFG(GATE_TIM11,		RCC_TIM11CFGR,		1,	0),
+	GATE_CFG(GATE_TIM12,		RCC_TIM12CFGR,		1,	0),
+	GATE_CFG(GATE_TIM13,		RCC_TIM13CFGR,		1,	0),
+	GATE_CFG(GATE_TIM14,		RCC_TIM14CFGR,		1,	0),
+	GATE_CFG(GATE_TIM15,		RCC_TIM15CFGR,		1,	0),
+	GATE_CFG(GATE_TIM16,		RCC_TIM16CFGR,		1,	0),
+	GATE_CFG(GATE_TIM17,		RCC_TIM17CFGR,		1,	0),
+	GATE_CFG(GATE_TIM20,		RCC_TIM20CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM1,		RCC_LPTIM1CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM2,		RCC_LPTIM2CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3,		RCC_LPTIM3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM4,		RCC_LPTIM4CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM5,		RCC_LPTIM5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI1,		RCC_SPI1CFGR,		1,	0),
+	GATE_CFG(GATE_SPI2,		RCC_SPI2CFGR,		1,	0),
+	GATE_CFG(GATE_SPI3,		RCC_SPI3CFGR,		1,	0),
+	GATE_CFG(GATE_SPI4,		RCC_SPI4CFGR,		1,	0),
+	GATE_CFG(GATE_SPI5,		RCC_SPI5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI6,		RCC_SPI6CFGR,		1,	0),
+	GATE_CFG(GATE_SPI7,		RCC_SPI7CFGR,		1,	0),
+	GATE_CFG(GATE_SPI8,		RCC_SPI8CFGR,		1,	0),
+	GATE_CFG(GATE_SPDIFRX,		RCC_SPDIFRXCFGR,	1,	0),
+	GATE_CFG(GATE_USART1,		RCC_USART1CFGR,		1,	0),
+	GATE_CFG(GATE_USART2,		RCC_USART2CFGR,		1,	0),
+	GATE_CFG(GATE_USART3,		RCC_USART3CFGR,		1,	0),
+	GATE_CFG(GATE_UART4,		RCC_UART4CFGR,		1,	0),
+	GATE_CFG(GATE_UART5,		RCC_UART5CFGR,		1,	0),
+	GATE_CFG(GATE_USART6,		RCC_USART6CFGR,		1,	0),
+	GATE_CFG(GATE_UART7,		RCC_UART7CFGR,		1,	0),
+	GATE_CFG(GATE_UART8,		RCC_UART8CFGR,		1,	0),
+	GATE_CFG(GATE_UART9,		RCC_UART9CFGR,		1,	0),
+	GATE_CFG(GATE_LPUART1,		RCC_LPUART1CFGR,	1,	0),
+	GATE_CFG(GATE_I2C1,		RCC_I2C1CFGR,		1,	0),
+	GATE_CFG(GATE_I2C2,		RCC_I2C2CFGR,		1,	0),
+	GATE_CFG(GATE_I2C3,		RCC_I2C3CFGR,		1,	0),
+	GATE_CFG(GATE_I2C4,		RCC_I2C4CFGR,		1,	0),
+	GATE_CFG(GATE_I2C5,		RCC_I2C5CFGR,		1,	0),
+	GATE_CFG(GATE_I2C6,		RCC_I2C6CFGR,		1,	0),
+	GATE_CFG(GATE_I2C7,		RCC_I2C7CFGR,		1,	0),
+	GATE_CFG(GATE_I2C8,		RCC_I2C8CFGR,		1,	0),
+	GATE_CFG(GATE_SAI1,		RCC_SAI1CFGR,		1,	0),
+	GATE_CFG(GATE_SAI2,		RCC_SAI2CFGR,		1,	0),
+	GATE_CFG(GATE_SAI3,		RCC_SAI3CFGR,		1,	0),
+	GATE_CFG(GATE_SAI4,		RCC_SAI4CFGR,		1,	0),
+	GATE_CFG(GATE_MDF1,		RCC_MDF1CFGR,		1,	0),
+	GATE_CFG(GATE_ADF1,		RCC_ADF1CFGR,		1,	0),
+	GATE_CFG(GATE_FDCAN,		RCC_FDCANCFGR,		1,	0),
+	GATE_CFG(GATE_HDP,		RCC_HDPCFGR,		1,	0),
+	GATE_CFG(GATE_ADC12,		RCC_ADC12CFGR,		1,	0),
+	GATE_CFG(GATE_ADC3,		RCC_ADC3CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1MAC,		RCC_ETH1CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1STP,		RCC_ETH1CFGR,		4,	0),
+	GATE_CFG(GATE_ETH1,		RCC_ETH1CFGR,		5,	0),
+	GATE_CFG(GATE_ETH1TX,		RCC_ETH1CFGR,		8,	0),
+	GATE_CFG(GATE_ETH1RX,		RCC_ETH1CFGR,		10,	0),
+	GATE_CFG(GATE_ETH2MAC,		RCC_ETH2CFGR,		1,	0),
+	GATE_CFG(GATE_ETH2STP,		RCC_ETH2CFGR,		4,	0),
+	GATE_CFG(GATE_ETH2,		RCC_ETH2CFGR,		5,	0),
+	GATE_CFG(GATE_ETH2TX,		RCC_ETH2CFGR,		8,	0),
+	GATE_CFG(GATE_ETH2RX,		RCC_ETH2CFGR,		10,	0),
+	GATE_CFG(GATE_USB2,		RCC_USB2CFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY1,		RCC_USB2PHY1CFGR,	1,	0),
+	GATE_CFG(GATE_USB2PHY2,		RCC_USB2PHY2CFGR,	1,	0),
+	GATE_CFG(GATE_USB3DR,		RCC_USB3DRCFGR,	1,	0),
+	GATE_CFG(GATE_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	1,	0),
+	GATE_CFG(GATE_PCIE,		RCC_PCIECFGR,		1,	0),
+	GATE_CFG(GATE_USBTC,		RCC_USBTCCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSWMAC,		RCC_ETHSWCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSW,		RCC_ETHSWCFGR,		5,	0),
+	GATE_CFG(GATE_ETHSWREF,		RCC_ETHSWCFGR,		21,	0),
+	GATE_CFG(GATE_ETHSWACMCFG,	RCC_ETHSWACMCFGR,	1,	0),
+	GATE_CFG(GATE_ETHSWACMMSG,	RCC_ETHSWACMMSGCFGR,	1,	0),
+	GATE_CFG(GATE_STGEN,		RCC_STGENCFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC1,		RCC_SDMMC1CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC2,		RCC_SDMMC2CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC3,		RCC_SDMMC3CFGR,		1,	0),
+	GATE_CFG(GATE_GPU,		RCC_GPUCFGR,		1,	0),
+	GATE_CFG(GATE_LTDC,		RCC_LTDCCFGR,		1,	0),
+	GATE_CFG(GATE_DSI,		RCC_DSICFGR,		1,	0),
+	GATE_CFG(GATE_LVDS,		RCC_LVDSCFGR,		1,	0),
+	GATE_CFG(GATE_CSI,		RCC_CSICFGR,		1,	0),
+	GATE_CFG(GATE_DCMIPP,		RCC_DCMIPPCFGR,		1,	0),
+	GATE_CFG(GATE_CCI,		RCC_CCICFGR,		1,	0),
+	GATE_CFG(GATE_VDEC,		RCC_VDECCFGR,		1,	0),
+	GATE_CFG(GATE_VENC,		RCC_VENCCFGR,		1,	0),
+	GATE_CFG(GATE_RNG,		RCC_RNGCFGR,		1,	0),
+	GATE_CFG(GATE_PKA,		RCC_PKACFGR,		1,	0),
+	GATE_CFG(GATE_SAES,		RCC_SAESCFGR,		1,	0),
+	GATE_CFG(GATE_HASH,		RCC_HASHCFGR,		1,	0),
+	GATE_CFG(GATE_CRYP1,		RCC_CRYP1CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP2,		RCC_CRYP2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG1,		RCC_IWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG2,		RCC_IWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG3,		RCC_IWDG3CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG4,		RCC_IWDG4CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG5,		RCC_IWDG5CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG1,		RCC_WWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG2,		RCC_WWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_VREF,		RCC_VREFCFGR,		1,	0),
+	GATE_CFG(GATE_DTS,		RCC_DTSCFGR,		1,	0),
+	GATE_CFG(GATE_CRC,		RCC_CRCCFGR,		1,	0),
+	GATE_CFG(GATE_SERC,		RCC_SERCCFGR,		1,	0),
+	GATE_CFG(GATE_OSPIIOM,		RCC_OSPIIOMCFGR,	1,	0),
+	GATE_CFG(GATE_I3C1,		RCC_I3C1CFGR,		1,	0),
+	GATE_CFG(GATE_I3C2,		RCC_I3C2CFGR,		1,	0),
+	GATE_CFG(GATE_I3C3,		RCC_I3C3CFGR,		1,	0),
+	GATE_CFG(GATE_I3C4,		RCC_I3C4CFGR,		1,	0),
+
+#ifdef CONFIG_DEBUG_FS
+	GATE_CFG(GATE_LSE,		RCC_BDCR,		0,	0),
+	GATE_CFG(GATE_LSI,		RCC_BDCR,		9,	0),
+	GATE_CFG(GATE_RTCCK,		RCC_BDCR,		20,	0),
+	GATE_CFG(GATE_MSI,		RCC_D3DCR,		0,	0),
+	GATE_CFG(GATE_PLL1,		RCC_PLL2CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL2,		RCC_PLL2CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL3,		RCC_PLL3CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL4,		RCC_PLL4CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL5,		RCC_PLL5CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL6,		RCC_PLL6CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL7,		RCC_PLL7CFGR1,		8,	0),
+	GATE_CFG(GATE_PLL8,		RCC_PLL8CFGR1,		8,	0),
+	GATE_CFG(GATE_C3,		RCC_C3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3C3,		RCC_C3CFGR,		16,	0),
+	GATE_CFG(GATE_LPTIM4C3,		RCC_C3CFGR,		17,	0),
+	GATE_CFG(GATE_LPTIM5C3,		RCC_C3CFGR,		18,	0),
+	GATE_CFG(GATE_SPI8C3,		RCC_C3CFGR,		19,	0),
+	GATE_CFG(GATE_LPUART1C3,	RCC_C3CFGR,		20,	0),
+	GATE_CFG(GATE_I2C8C3,		RCC_C3CFGR,		21,	0),
+	GATE_CFG(GATE_ADF1C3,		RCC_C3CFGR,		23,	0),
+	GATE_CFG(GATE_GPIOZC3,		RCC_C3CFGR,		24,	0),
+	GATE_CFG(GATE_LPDMAC3,		RCC_C3CFGR,		25,	0),
+	GATE_CFG(GATE_RTCC3,		RCC_C3CFGR,		26,	0),
+	GATE_CFG(GATE_I3C4C3,		RCC_C3CFGR,		27,	0),
+	GATE_CFG(GATE_HSI,		RCC_OCENSETR,		0,	1),
+	GATE_CFG(GATE_HSEDIV2,		RCC_OCENSETR,		5,	1),
+	GATE_CFG(GATE_HSE,		RCC_OCENSETR,		8,	1),
+	GATE_CFG(GATE_DDRCP,		RCC_DDRCPCFGR,		1,	0),
+	GATE_CFG(GATE_DDRCAPB,		RCC_DDRCAPBCFGR,	1,	0),
+	GATE_CFG(GATE_DDRPHYCAPB,	RCC_DDRPHYCAPBCFGR,	1,	0),
+	GATE_CFG(GATE_DDRPHYC,		RCC_DDRPHYCCFGR,	1,	0),
+	GATE_CFG(GATE_DDRCFG,		RCC_DDRCFGR,		1,	0),
+	GATE_CFG(GATE_SYSRAM,		RCC_SYSRAMCFGR,		1,	0),
+	GATE_CFG(GATE_VDERAM,		RCC_VDERAMCFGR,		1,	0),
+	GATE_CFG(GATE_SRAM1,		RCC_SRAM1CFGR,		1,	0),
+	GATE_CFG(GATE_SRAM2,		RCC_SRAM2CFGR,		1,	0),
+	GATE_CFG(GATE_RETRAM,		RCC_RETRAMCFGR,		1,	0),
+	GATE_CFG(GATE_BKPSRAM,		RCC_BKPSRAMCFGR,	1,	0),
+	GATE_CFG(GATE_LPSRAM1,		RCC_LPSRAM1CFGR,	1,	0),
+	GATE_CFG(GATE_LPSRAM2,		RCC_LPSRAM2CFGR,	1,	0),
+	GATE_CFG(GATE_LPSRAM3,		RCC_LPSRAM3CFGR,	1,	0),
+	GATE_CFG(GATE_FMC,		RCC_FMCCFGR,		1,	0),
+	GATE_CFG(GATE_ETR,		RCC_ETRCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOA,		RCC_GPIOACFGR,		1,	0),
+	GATE_CFG(GATE_GPIOB,		RCC_GPIOBCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOC,		RCC_GPIOCCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOD,		RCC_GPIODCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOE,		RCC_GPIOECFGR,		1,	0),
+	GATE_CFG(GATE_GPIOF,		RCC_GPIOFCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOG,		RCC_GPIOGCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOH,		RCC_GPIOHCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOI,		RCC_GPIOICFGR,		1,	0),
+	GATE_CFG(GATE_GPIOJ,		RCC_GPIOJCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOK,		RCC_GPIOKCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOZ,		RCC_GPIOZCFGR,		1,	0),
+	GATE_CFG(GATE_HPDMA1,		RCC_HPDMA1CFGR,		1,	0),
+	GATE_CFG(GATE_HPDMA2,		RCC_HPDMA2CFGR,		1,	0),
+	GATE_CFG(GATE_HPDMA3,		RCC_HPDMA3CFGR,		1,	0),
+	GATE_CFG(GATE_LPDMA,		RCC_LPDMACFGR,		1,	0),
+	GATE_CFG(GATE_HSEM,		RCC_HSEMCFGR,		1,	0),
+	GATE_CFG(GATE_IPCC1,		RCC_IPCC1CFGR,		1,	0),
+	GATE_CFG(GATE_IPCC2,		RCC_IPCC2CFGR,		1,	0),
+	GATE_CFG(GATE_RTC,		RCC_RTCCFGR,		1,	0),
+	GATE_CFG(GATE_SYSCPU1,		RCC_SYSCPU1CFGR,	1,	0),
+	GATE_CFG(GATE_BSEC,		RCC_BSECCFGR,		1,	0),
+	GATE_CFG(GATE_GICV2M,		RCC_GICV2MCFGR,		1,	0),
+#endif
+};
+
+#ifdef CONFIG_DEBUG_FS
+enum enum_div_cfg {
+	DIV_LSMCU,
+	DIV_APB1,
+	DIV_APB2,
+	DIV_APB3,
+	DIV_APB4,
+	DIV_APBDBG,
+	DIV_RTC,
+	DIV_NB
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 },  { 1, 2 },  { 2, 4 },  { 3, 8 }, { 4, 16 },
+	{ 5, 16 }, { 6, 16 }, { 7, 16 }, { 0 },
+};
+
+#define DIV_CFG(_id, _offset, _shift, _width, _table)\
+	[(_id)] = {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_width),\
+		.table	= (_table),\
+	}
+
+static const struct stm32_div_cfg stm32mp25_dividers[DIV_NB] = {
+	DIV_CFG(DIV_RTC,	RCC_RTCDIVR,	0, 6, NULL),
+	DIV_CFG(DIV_APB1,	RCC_APB1DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APB2,	RCC_APB2DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APB3,	RCC_APB3DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APB4,	RCC_APB4DIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_APBDBG,	RCC_APBDBGDIVR,	0, 3, apb_div_table),
+	DIV_CFG(DIV_LSMCU,	RCC_LSMCUDIVR,	0, 1, NULL),
+};
+#endif
+
+#define CLK_STM32_GATE(_name, _parent, _flags, _gate_id)\
+struct clk_stm32_gate _name = {\
+	.gate_id = _gate_id,\
+	.hw.init = CLK_HW_INIT(#_name, _parent, &clk_stm32_gate_ops, _flags),\
+}
+
+#define CLK_STM32_MUX(_name, _parents, _flags, _mux_id)\
+struct clk_stm32_mux _name = {\
+	.mux_id = _mux_id,\
+	.hw.init = CLK_HW_INIT_PARENTS(#_name, _parents, &clk_stm32_mux_ops, _flags),\
+}
+
+#define CLK_STM32_DIV(_name, _parent, _flags, _div_id)\
+struct clk_stm32_div _name = {\
+	.div_id = _div_id,\
+	.hw.init = CLK_HW_INIT(#_name, _parent, &clk_stm32_divider_ops, _flags),\
+}
+
+#define CLK_STM32_COMPOSITE(_name, _parents, _flags, _gate_id, _mux_id, _div_id)\
+struct clk_stm32_composite _name = {\
+	.gate_id = _gate_id,\
+	.mux_id = _mux_id,\
+	.div_id = _div_id,\
+	.hw.init = CLK_HW_INIT_PARENTS(#_name, _parents, &clk_stm32_composite_ops, _flags),\
+}
+
+/* ADC */
+static CLK_STM32_GATE(ck_icn_p_adc12, "ck_icn_ls_mcu", 0, GATE_ADC12);
+static CLK_STM32_COMPOSITE(ck_ker_adc12, adc12_src, 0, GATE_ADC12, MUX_ADC12, NO_STM32_DIV);
+static CLK_STM32_GATE(ck_icn_p_adc3, "ck_icn_ls_mcu", 0, GATE_ADC3);
+static CLK_STM32_COMPOSITE(ck_ker_adc3, adc3_src, 0, GATE_ADC3, MUX_ADC3, NO_STM32_DIV);
+
+/* ADF */
+static CLK_STM32_GATE(ck_icn_p_adf1, "ck_icn_ls_mcu", 0, GATE_ADF1);
+static CLK_STM32_GATE(ck_ker_adf1, "ck_flexgen_42", 0, GATE_ADF1);
+
+/* DCMI */
+static CLK_STM32_GATE(ck_icn_p_cci, "ck_icn_ls_mcu", 0, GATE_CCI);
+
+/* CSI-HOST */
+static CLK_STM32_GATE(ck_icn_p_csi, "ck_icn_apb4", 0, GATE_CSI);
+static CLK_STM32_GATE(ck_ker_csi, "ck_flexgen_29", 0, GATE_CSI);
+static CLK_STM32_GATE(ck_ker_csitxesc, "ck_flexgen_30", 0, GATE_CSI);
+
+/* CSI-PHY */
+static CLK_STM32_GATE(ck_ker_csiphy, "ck_flexgen_31", 0, GATE_CSI);
+
+/* DCMIPP */
+static CLK_STM32_GATE(ck_icn_p_dcmipp, "ck_icn_apb4", 0, GATE_DCMIPP);
+
+/* CRC */
+static CLK_STM32_GATE(ck_icn_p_crc, "ck_icn_ls_mcu", 0, GATE_CRC);
+
+/* CRYP */
+static CLK_STM32_GATE(ck_icn_p_cryp1, "ck_icn_ls_mcu", 0, GATE_CRYP1);
+static CLK_STM32_GATE(ck_icn_p_cryp2, "ck_icn_ls_mcu", 0, GATE_CRYP2);
+
+/* DBG & TRACE*/
+/* Trace and debug clocks are managed by SCMI */
+
+/* LTDC */
+static CLK_STM32_GATE(ck_icn_p_ltdc, "ck_icn_apb4", 0, GATE_LTDC);
+static CLK_STM32_GATE(ck_ker_ltdc, "ck_flexgen_27", CLK_SET_RATE_PARENT, GATE_LTDC);
+
+/* DSI */
+static CLK_STM32_GATE(ck_icn_p_dsi, "ck_icn_apb4", 0, GATE_DSI);
+static CLK_STM32_COMPOSITE(clk_lanebyte, dsiblane_src, 0, GATE_DSI, MUX_DSIBLANE, NO_STM32_DIV);
+
+/* LVDS */
+static CLK_STM32_GATE(ck_icn_p_lvds, "ck_icn_apb4", 0, GATE_LVDS);
+
+/* DSI PHY */
+static CLK_STM32_COMPOSITE(clk_phy_dsi, dsiphy_src, 0, GATE_DSI, MUX_DSIPHY, NO_STM32_DIV);
+
+/* LVDS PHY */
+static CLK_STM32_COMPOSITE(ck_ker_lvdsphy, lvdsphy_src, 0, GATE_LVDS, MUX_LVDSPHY, NO_STM32_DIV);
+
+/* DTS */
+static CLK_STM32_COMPOSITE(ck_ker_dts, dts_src, 0, GATE_DTS, MUX_DTS, NO_STM32_DIV);
+
+/* ETHERNET */
+static CLK_STM32_GATE(ck_icn_p_eth1, "ck_icn_ls_mcu", 0, GATE_ETH1);
+static CLK_STM32_GATE(ck_ker_eth1stp, "ck_icn_ls_mcu", 0, GATE_ETH1STP);
+static CLK_STM32_GATE(ck_ker_eth1, "ck_flexgen_54", 0, GATE_ETH1);
+static CLK_STM32_GATE(ck_ker_eth1ptp, "ck_flexgen_56", 0, GATE_ETH1);
+static CLK_STM32_GATE(ck_ker_eth1mac, "ck_icn_ls_mcu", 0, GATE_ETH1MAC);
+static CLK_STM32_GATE(ck_ker_eth1tx, "ck_icn_ls_mcu", 0, GATE_ETH1TX);
+static CLK_STM32_GATE(ck_ker_eth1rx, "ck_icn_ls_mcu", 0, GATE_ETH1RX);
+
+static CLK_STM32_GATE(ck_icn_p_eth2, "ck_icn_ls_mcu", 0, GATE_ETH2);
+static CLK_STM32_GATE(ck_ker_eth2stp, "ck_icn_ls_mcu", 0, GATE_ETH2STP);
+static CLK_STM32_GATE(ck_ker_eth2, "ck_flexgen_55", 0, GATE_ETH2);
+static CLK_STM32_GATE(ck_ker_eth2ptp, "ck_flexgen_56", 0, GATE_ETH2);
+static CLK_STM32_GATE(ck_ker_eth2mac, "ck_icn_ls_mcu", 0, GATE_ETH2MAC);
+static CLK_STM32_GATE(ck_ker_eth2tx, "ck_icn_ls_mcu", 0, GATE_ETH2TX);
+static CLK_STM32_GATE(ck_ker_eth2rx, "ck_icn_ls_mcu", 0, GATE_ETH2RX);
+
+static CLK_STM32_GATE(ck_icn_p_ethsw, "ck_icn_ls_mcu", 0, GATE_ETHSWMAC);
+static CLK_STM32_GATE(ck_ker_ethsw, "ck_flexgen_54", 0, GATE_ETHSW);
+static CLK_STM32_GATE(ck_ker_ethswref, "ck_flexgen_60", 0, GATE_ETHSWREF);
+
+static CLK_STM32_GATE(ck_icn_p_ethsw_acm_cfg, "ck_icn_ls_mcu", 0, GATE_ETHSWACMCFG);
+static CLK_STM32_GATE(ck_icn_p_ethsw_acm_msg, "ck_icn_ls_mcu", 0, GATE_ETHSWACMMSG);
+
+/* FDCAN */
+static CLK_STM32_GATE(ck_icn_p_fdcan, "ck_icn_apb2", 0, GATE_FDCAN);
+static CLK_STM32_GATE(ck_ker_fdcan, "ck_flexgen_26", 0, GATE_FDCAN);
+
+/* GPU */
+static CLK_STM32_GATE(ck_icn_m_gpu, "ck_flexgen_59", 0, GATE_GPU);
+static CLK_STM32_GATE(ck_ker_gpu, "ck_pll3", 0, GATE_GPU);
+
+/* HASH */
+static CLK_STM32_GATE(ck_icn_p_hash, "ck_icn_ls_mcu", 0, GATE_HASH);
+
+/* HDP */
+static CLK_STM32_GATE(ck_icn_p_hdp, "ck_icn_apb3", 0, GATE_HDP);
+
+/* I2C */
+static CLK_STM32_GATE(ck_icn_p_i2c8, "ck_icn_ls_mcu", 0, GATE_I2C8);
+static CLK_STM32_GATE(ck_icn_p_i2c1, "ck_icn_apb1", 0, GATE_I2C1);
+static CLK_STM32_GATE(ck_icn_p_i2c2, "ck_icn_apb1", 0, GATE_I2C2);
+static CLK_STM32_GATE(ck_icn_p_i2c3, "ck_icn_apb1", 0, GATE_I2C3);
+static CLK_STM32_GATE(ck_icn_p_i2c4, "ck_icn_apb1", 0, GATE_I2C4);
+static CLK_STM32_GATE(ck_icn_p_i2c5, "ck_icn_apb1", 0, GATE_I2C5);
+static CLK_STM32_GATE(ck_icn_p_i2c6, "ck_icn_apb1", 0, GATE_I2C6);
+static CLK_STM32_GATE(ck_icn_p_i2c7, "ck_icn_apb1", 0, GATE_I2C7);
+
+static CLK_STM32_GATE(ck_ker_i2c1, "ck_flexgen_12", 0, GATE_I2C1);
+static CLK_STM32_GATE(ck_ker_i2c2, "ck_flexgen_12", 0, GATE_I2C2);
+static CLK_STM32_GATE(ck_ker_i2c3, "ck_flexgen_13", 0, GATE_I2C3);
+static CLK_STM32_GATE(ck_ker_i2c5, "ck_flexgen_13", 0, GATE_I2C5);
+static CLK_STM32_GATE(ck_ker_i2c4, "ck_flexgen_14", 0, GATE_I2C4);
+static CLK_STM32_GATE(ck_ker_i2c6, "ck_flexgen_14", 0, GATE_I2C6);
+static CLK_STM32_GATE(ck_ker_i2c7, "ck_flexgen_15", 0, GATE_I2C7);
+static CLK_STM32_GATE(ck_ker_i2c8, "ck_flexgen_38", 0, GATE_I2C8);
+
+/* I3C */
+static CLK_STM32_GATE(ck_icn_p_i3c1, "ck_icn_apb1", 0, GATE_I3C1);
+static CLK_STM32_GATE(ck_icn_p_i3c2, "ck_icn_apb1", 0, GATE_I3C2);
+static CLK_STM32_GATE(ck_icn_p_i3c3, "ck_icn_apb1", 0, GATE_I3C3);
+static CLK_STM32_GATE(ck_icn_p_i3c4, "ck_icn_ls_mcu", 0, GATE_I3C4);
+
+static CLK_STM32_GATE(ck_ker_i3c1, "ck_flexgen_12", 0, GATE_I3C1);
+static CLK_STM32_GATE(ck_ker_i3c2, "ck_flexgen_12", 0, GATE_I3C2);
+static CLK_STM32_GATE(ck_ker_i3c3, "ck_flexgen_13", 0, GATE_I3C3);
+static CLK_STM32_GATE(ck_ker_i3c4, "ck_flexgen_36", 0, GATE_I3C4);
+
+/* I2S */
+static CLK_STM32_GATE(ck_icn_p_is2m, "ck_icn_apb3", 0, GATE_IS2M);
+
+/* IWDG */
+static CLK_STM32_GATE(ck_icn_p_iwdg1, "ck_icn_apb3", 0, GATE_IWDG1);
+static CLK_STM32_GATE(ck_icn_p_iwdg2, "ck_icn_apb3", 0, GATE_IWDG2);
+static CLK_STM32_GATE(ck_icn_p_iwdg3, "ck_icn_apb3", 0, GATE_IWDG3);
+static CLK_STM32_GATE(ck_icn_p_iwdg4, "ck_icn_apb3", 0, GATE_IWDG4);
+static CLK_STM32_GATE(ck_icn_p_iwdg5, "ck_icn_ls_mcu", 0, GATE_IWDG5);
+
+/* LPTIM */
+static CLK_STM32_GATE(ck_icn_p_lptim1, "ck_icn_apb1", 0, GATE_LPTIM1);
+static CLK_STM32_GATE(ck_icn_p_lptim2, "ck_icn_apb1", 0, GATE_LPTIM2);
+static CLK_STM32_GATE(ck_icn_p_lptim3, "ck_icn_ls_mcu", 0, GATE_LPTIM3);
+static CLK_STM32_GATE(ck_icn_p_lptim4, "ck_icn_ls_mcu", 0, GATE_LPTIM4);
+static CLK_STM32_GATE(ck_icn_p_lptim5, "ck_icn_ls_mcu", 0, GATE_LPTIM5);
+
+static CLK_STM32_GATE(ck_ker_lptim1, "ck_flexgen_07", 0, GATE_LPTIM1);
+static CLK_STM32_GATE(ck_ker_lptim2, "ck_flexgen_07", 0, GATE_LPTIM2);
+static CLK_STM32_GATE(ck_ker_lptim3, "ck_flexgen_40", 0, GATE_LPTIM3);
+static CLK_STM32_GATE(ck_ker_lptim4, "ck_flexgen_41", 0, GATE_LPTIM4);
+static CLK_STM32_GATE(ck_ker_lptim5, "ck_flexgen_41", 0, GATE_LPTIM5);
+
+/* LPUART */
+static CLK_STM32_GATE(ck_icn_p_lpuart1, "ck_icn_ls_mcu", 0, GATE_LPUART1);
+static CLK_STM32_GATE(ck_ker_lpuart1, "ck_flexgen_39", 0, GATE_LPUART1);
+
+/* MCO1 & MCO2 */
+static CLK_STM32_COMPOSITE(ck_mco1, mco1_src, 0, GATE_MCO1, MUX_MCO1, NO_STM32_DIV);
+static CLK_STM32_COMPOSITE(ck_mco2, mco2_src, 0, GATE_MCO2, MUX_MCO2, NO_STM32_DIV);
+
+/* MDF */
+static CLK_STM32_GATE(ck_icn_p_mdf1, "ck_icn_ls_mcu", 0, GATE_MDF1);
+static CLK_STM32_GATE(ck_ker_mdf1, "ck_flexgen_23", CLK_SET_RATE_PARENT, GATE_MDF1);
+
+/* OSPI */
+static CLK_STM32_GATE(ck_icn_p_ospiiom, "ck_icn_ls_mcu", 0, GATE_OSPIIOM);
+
+/* PCIE */
+static CLK_STM32_GATE(ck_icn_p_pcie, "ck_icn_ls_mcu", 0, GATE_PCIE);
+
+/* PKA */
+static CLK_STM32_GATE(ck_icn_p_pka, "ck_icn_ls_mcu", 0, GATE_PKA);
+
+/* RNG */
+static CLK_STM32_GATE(ck_icn_p_rng, "ck_icn_ls_mcu", 0, GATE_RNG);
+
+/* SAES */
+static CLK_STM32_GATE(ck_icn_p_saes, "ck_icn_ls_mcu", 0, GATE_SAES);
+
+/* SAI */
+static CLK_STM32_GATE(ck_icn_p_sai1, "ck_icn_apb2", 0, GATE_SAI1);
+static CLK_STM32_GATE(ck_icn_p_sai2, "ck_icn_apb2", 0, GATE_SAI2);
+static CLK_STM32_GATE(ck_icn_p_sai3, "ck_icn_apb2", 0, GATE_SAI3);
+static CLK_STM32_GATE(ck_icn_p_sai4, "ck_icn_apb2", 0, GATE_SAI4);
+static CLK_STM32_GATE(ck_ker_sai1, "ck_flexgen_23", CLK_SET_RATE_PARENT, GATE_SAI1);
+static CLK_STM32_GATE(ck_ker_sai2, "ck_flexgen_24", CLK_SET_RATE_PARENT, GATE_SAI2);
+static CLK_STM32_GATE(ck_ker_sai3, "ck_flexgen_25", CLK_SET_RATE_PARENT, GATE_SAI3);
+static CLK_STM32_GATE(ck_ker_sai4, "ck_flexgen_25", CLK_SET_RATE_PARENT, GATE_SAI4);
+
+/* SDMMC */
+static CLK_STM32_GATE(ck_icn_m_sdmmc1, "ck_icn_sdmmc", 0, GATE_SDMMC1);
+static CLK_STM32_GATE(ck_icn_m_sdmmc2, "ck_icn_sdmmc", 0, GATE_SDMMC2);
+static CLK_STM32_GATE(ck_icn_m_sdmmc3, "ck_icn_sdmmc", 0, GATE_SDMMC3);
+static CLK_STM32_GATE(ck_ker_sdmmc1, "ck_flexgen_51", 0, GATE_SDMMC1);
+static CLK_STM32_GATE(ck_ker_sdmmc2, "ck_flexgen_52", 0, GATE_SDMMC2);
+static CLK_STM32_GATE(ck_ker_sdmmc3, "ck_flexgen_53", 0, GATE_SDMMC3);
+
+/* SERC */
+static CLK_STM32_GATE(ck_icn_p_serc, "ck_icn_apb3", 0, GATE_SERC);
+
+/* SPDIF */
+static CLK_STM32_GATE(ck_icn_p_spdifrx, "ck_icn_apb1", 0, GATE_SPDIFRX);
+static CLK_STM32_GATE(ck_ker_spdifrx, "ck_flexgen_11", 0, GATE_SPDIFRX);
+
+/* SPI */
+static CLK_STM32_GATE(ck_icn_p_spi1, "ck_icn_apb2", 0, GATE_SPI1);
+static CLK_STM32_GATE(ck_icn_p_spi2, "ck_icn_apb1", 0, GATE_SPI2);
+static CLK_STM32_GATE(ck_icn_p_spi3, "ck_icn_apb1", 0, GATE_SPI3);
+static CLK_STM32_GATE(ck_icn_p_spi4, "ck_icn_apb2", 0, GATE_SPI4);
+static CLK_STM32_GATE(ck_icn_p_spi5, "ck_icn_apb2", 0, GATE_SPI5);
+static CLK_STM32_GATE(ck_icn_p_spi6, "ck_icn_apb2", 0, GATE_SPI6);
+static CLK_STM32_GATE(ck_icn_p_spi7, "ck_icn_apb2", 0, GATE_SPI7);
+static CLK_STM32_GATE(ck_icn_p_spi8, "ck_icn_ls_mcu", 0, GATE_SPI8);
+
+static CLK_STM32_GATE(ck_ker_spi1, "ck_flexgen_16", CLK_SET_RATE_PARENT, GATE_SPI1);
+static CLK_STM32_GATE(ck_ker_spi2, "ck_flexgen_10", CLK_SET_RATE_PARENT, GATE_SPI2);
+static CLK_STM32_GATE(ck_ker_spi3, "ck_flexgen_10", CLK_SET_RATE_PARENT, GATE_SPI3);
+static CLK_STM32_GATE(ck_ker_spi4, "ck_flexgen_17", 0, GATE_SPI4);
+static CLK_STM32_GATE(ck_ker_spi5, "ck_flexgen_17", 0, GATE_SPI5);
+static CLK_STM32_GATE(ck_ker_spi6, "ck_flexgen_18", 0, GATE_SPI6);
+static CLK_STM32_GATE(ck_ker_spi7, "ck_flexgen_18", 0, GATE_SPI7);
+static CLK_STM32_GATE(ck_ker_spi8, "ck_flexgen_37", 0, GATE_SPI8);
+
+/* Timers */
+static CLK_STM32_GATE(ck_icn_p_tim2, "ck_icn_apb1", 0, GATE_TIM2);
+static CLK_STM32_GATE(ck_icn_p_tim3, "ck_icn_apb1", 0, GATE_TIM3);
+static CLK_STM32_GATE(ck_icn_p_tim4, "ck_icn_apb1", 0, GATE_TIM4);
+static CLK_STM32_GATE(ck_icn_p_tim5, "ck_icn_apb1", 0, GATE_TIM5);
+static CLK_STM32_GATE(ck_icn_p_tim6, "ck_icn_apb1", 0, GATE_TIM6);
+static CLK_STM32_GATE(ck_icn_p_tim7, "ck_icn_apb1", 0, GATE_TIM7);
+static CLK_STM32_GATE(ck_icn_p_tim10, "ck_icn_apb1", 0, GATE_TIM10);
+static CLK_STM32_GATE(ck_icn_p_tim11, "ck_icn_apb1", 0, GATE_TIM11);
+static CLK_STM32_GATE(ck_icn_p_tim12, "ck_icn_apb1", 0, GATE_TIM12);
+static CLK_STM32_GATE(ck_icn_p_tim13, "ck_icn_apb1", 0, GATE_TIM13);
+static CLK_STM32_GATE(ck_icn_p_tim14, "ck_icn_apb1", 0, GATE_TIM14);
+
+static CLK_STM32_GATE(ck_icn_p_tim1, "ck_icn_apb2", 0, GATE_TIM1);
+static CLK_STM32_GATE(ck_icn_p_tim8, "ck_icn_apb2", 0, GATE_TIM8);
+static CLK_STM32_GATE(ck_icn_p_tim15, "ck_icn_apb2", 0, GATE_TIM15);
+static CLK_STM32_GATE(ck_icn_p_tim16, "ck_icn_apb2", 0, GATE_TIM16);
+static CLK_STM32_GATE(ck_icn_p_tim17, "ck_icn_apb2", 0, GATE_TIM17);
+static CLK_STM32_GATE(ck_icn_p_tim20, "ck_icn_apb2", 0, GATE_TIM20);
+
+static CLK_STM32_GATE(ck_ker_tim2, "timg1_ck", 0, GATE_TIM2);
+static CLK_STM32_GATE(ck_ker_tim3, "timg1_ck", 0, GATE_TIM3);
+static CLK_STM32_GATE(ck_ker_tim4, "timg1_ck", 0, GATE_TIM4);
+static CLK_STM32_GATE(ck_ker_tim5, "timg1_ck", 0, GATE_TIM5);
+static CLK_STM32_GATE(ck_ker_tim6, "timg1_ck", 0, GATE_TIM6);
+static CLK_STM32_GATE(ck_ker_tim7, "timg1_ck", 0, GATE_TIM7);
+static CLK_STM32_GATE(ck_ker_tim10, "timg1_ck", 0, GATE_TIM10);
+static CLK_STM32_GATE(ck_ker_tim11, "timg1_ck", 0, GATE_TIM11);
+static CLK_STM32_GATE(ck_ker_tim12, "timg1_ck", 0, GATE_TIM12);
+static CLK_STM32_GATE(ck_ker_tim13, "timg1_ck", 0, GATE_TIM13);
+static CLK_STM32_GATE(ck_ker_tim14, "timg1_ck", 0, GATE_TIM14);
+
+static CLK_STM32_GATE(ck_ker_tim1, "timg2_ck", 0, GATE_TIM1);
+static CLK_STM32_GATE(ck_ker_tim8, "timg2_ck", 0, GATE_TIM8);
+static CLK_STM32_GATE(ck_ker_tim15, "timg2_ck", 0, GATE_TIM15);
+static CLK_STM32_GATE(ck_ker_tim16, "timg2_ck", 0, GATE_TIM16);
+static CLK_STM32_GATE(ck_ker_tim17, "timg2_ck", 0, GATE_TIM17);
+static CLK_STM32_GATE(ck_ker_tim20, "timg2_ck", 0, GATE_TIM20);
+
+/* UART/USART */
+static CLK_STM32_GATE(ck_icn_p_usart2, "ck_icn_apb1", 0, GATE_USART2);
+static CLK_STM32_GATE(ck_icn_p_usart3, "ck_icn_apb1", 0, GATE_USART3);
+static CLK_STM32_GATE(ck_icn_p_uart4, "ck_icn_apb1", 0, GATE_UART4);
+static CLK_STM32_GATE(ck_icn_p_uart5, "ck_icn_apb1", 0, GATE_UART5);
+static CLK_STM32_GATE(ck_icn_p_usart1, "ck_icn_apb2", 0, GATE_USART1);
+static CLK_STM32_GATE(ck_icn_p_usart6, "ck_icn_apb2", 0, GATE_USART6);
+static CLK_STM32_GATE(ck_icn_p_uart7, "ck_icn_apb2", 0, GATE_UART7);
+static CLK_STM32_GATE(ck_icn_p_uart8, "ck_icn_apb2", 0, GATE_UART8);
+static CLK_STM32_GATE(ck_icn_p_uart9, "ck_icn_apb2", 0, GATE_UART9);
+
+static CLK_STM32_GATE(ck_ker_usart2, "ck_flexgen_08", 0, GATE_USART2);
+static CLK_STM32_GATE(ck_ker_uart4, "ck_flexgen_08", 0, GATE_UART4);
+static CLK_STM32_GATE(ck_ker_usart3, "ck_flexgen_09", 0, GATE_USART3);
+static CLK_STM32_GATE(ck_ker_uart5, "ck_flexgen_09", 0, GATE_UART5);
+static CLK_STM32_GATE(ck_ker_usart1, "ck_flexgen_19", 0, GATE_USART1);
+static CLK_STM32_GATE(ck_ker_usart6, "ck_flexgen_20", 0, GATE_USART6);
+static CLK_STM32_GATE(ck_ker_uart7, "ck_flexgen_21", 0, GATE_UART7);
+static CLK_STM32_GATE(ck_ker_uart8, "ck_flexgen_21", 0, GATE_UART8);
+static CLK_STM32_GATE(ck_ker_uart9, "ck_flexgen_22", 0, GATE_UART9);
+
+/* USB2PHY1 */
+static CLK_STM32_COMPOSITE(ck_ker_usb2phy1, usb2phy1_src, 0,
+			   GATE_USB2PHY1, MUX_USB2PHY1, NO_STM32_DIV);
+
+/* USBH */
+static CLK_STM32_GATE(ck_icn_m_usb2ehci, "ck_icn_hsl", 0, GATE_USB2);
+static CLK_STM32_GATE(ck_icn_m_usb2ohci, "ck_icn_hsl", 0, GATE_USB2);
+
+/* USB2PHY2 */
+static CLK_STM32_COMPOSITE(ck_ker_usb2phy2_en, usb2phy2_src, 0,
+			   GATE_USB2PHY2, MUX_USB2PHY2, NO_STM32_DIV);
+
+/* USB3 PCIe COMBOPHY */
+static CLK_STM32_GATE(ck_icn_p_usb3pciephy, "ck_icn_apb4", 0, GATE_USB3PCIEPHY);
+
+static CLK_STM32_COMPOSITE(ck_ker_usb3pciephy, usb3pciphy_src, 0,
+			   GATE_USB3PCIEPHY, MUX_USB3PCIEPHY, NO_STM32_DIV);
+
+/* USB3 DRD */
+static CLK_STM32_GATE(ck_icn_m_usb3dr, "ck_icn_hsl", 0, GATE_USB3DR);
+static CLK_STM32_GATE(ck_ker_usb2phy2, "ck_flexgen_58", 0, GATE_USB3DR);
+
+/* USBTC */
+static CLK_STM32_GATE(ck_icn_p_usbtc, "ck_icn_apb4", 0, GATE_USBTC);
+static CLK_STM32_GATE(ck_ker_usbtc, "ck_flexgen_35", 0, GATE_USBTC);
+
+/* VDEC / VENC */
+static CLK_STM32_GATE(ck_icn_p_vdec, "ck_icn_apb4", 0, GATE_VDEC);
+static CLK_STM32_GATE(ck_icn_p_venc, "ck_icn_apb4", 0, GATE_VENC);
+
+/* VREF */
+static CLK_STM32_GATE(ck_icn_p_vref, "ck_icn_apb3", 0, GATE_VREF);
+
+/* WWDG */
+static CLK_STM32_GATE(ck_icn_p_wwdg1, "ck_icn_apb3", 0, GATE_WWDG1);
+static CLK_STM32_GATE(ck_icn_p_wwdg2, "ck_icn_ls_mcu", 0, GATE_WWDG2);
+
+static int stm32_rcc_get_access(void __iomem *base, u32 index)
+{
+	u32 seccfgr, cidcfgr, semcr;
+	int bit, cid;
+
+	bit = index % RCC_REG_SIZE;
+
+	seccfgr = readl(base + RCC_SECCFGR(index));
+	if (seccfgr & BIT(bit))
+		return -EACCES;
+
+	cidcfgr = readl(base + RCC_CIDCFGR(index));
+	if (!(cidcfgr & RCC_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & RCC_CIDCFGR_SEM_EN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(RCC_CIDCFGR_SCID_MASK, cidcfgr);
+		if (cid != RCC_CID1)
+			return -EACCES;
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & RCC_CIDCFGR_SEMWLC1_EN))
+		return -EACCES;
+
+	semcr = readl(base + RCC_SEMCR(index));
+
+	cid = FIELD_GET(RCC_SEMCR_SEMCID_MASK, semcr);
+	if (cid != RCC_CID1)
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32mp25_check_security(void __iomem *base,
+				    const struct clock_config *cfg)
+{
+	int ret = 0;
+
+	if (cfg->sec_id != SECF_NONE) {
+		u32 index = (u32)cfg->sec_id;
+
+		if (index & SEC_RIFSC_FLAG)
+			ret = stm32_rifsc_check_access_by_id(index & ~SEC_RIFSC_FLAG);
+		else
+			ret = stm32_rcc_get_access(base, cfg->sec_id & ~SEC_RIFSC_FLAG);
+	}
+
+	return ret;
+}
+
+static const struct clock_config stm32mp25_clock_cfg[] = {
+	STM32_GATE_CFG(CK_BUS_ETH1, ck_icn_p_eth1, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_BUS_ETH2, ck_icn_p_eth2, SEC_RIFSC(ETH2)),
+	STM32_GATE_CFG(CK_BUS_PCIE, ck_icn_p_pcie, SEC_RIFSC(PCIE)),
+	STM32_GATE_CFG(CK_BUS_ETHSW, ck_icn_p_ethsw, SEC_RIFSC(ETHSW_DEIP)),
+	STM32_GATE_CFG(CK_BUS_ADC12, ck_icn_p_adc12, SEC_RIFSC(ADC12)),
+	STM32_GATE_CFG(CK_BUS_ADC3, ck_icn_p_adc3, SEC_RIFSC(ADC3)),
+	STM32_GATE_CFG(CK_BUS_CCI, ck_icn_p_cci, SEC_RIFSC(DCMI_PSSI)),
+	STM32_GATE_CFG(CK_BUS_CRC, ck_icn_p_crc, SEC_RIFSC(CRC)),
+	STM32_GATE_CFG(CK_BUS_MDF1, ck_icn_p_mdf1, SEC_RIFSC(MDF1)),
+	STM32_GATE_CFG(CK_BUS_OSPIIOM, ck_icn_p_ospiiom, SEC_RIFSC(OCTOSPIM)),
+	STM32_GATE_CFG(CK_BUS_HASH, ck_icn_p_hash, SEC_RIFSC(HASH)),
+	STM32_GATE_CFG(CK_BUS_RNG, ck_icn_p_rng, SEC_RIFSC(RNG)),
+	STM32_GATE_CFG(CK_BUS_CRYP1, ck_icn_p_cryp1, SEC_RIFSC(CRYP1)),
+	STM32_GATE_CFG(CK_BUS_CRYP2, ck_icn_p_cryp2, SEC_RIFSC(CRYP2)),
+	STM32_GATE_CFG(CK_BUS_SAES, ck_icn_p_saes, SEC_RIFSC(SAES)),
+	STM32_GATE_CFG(CK_BUS_PKA, ck_icn_p_pka, SEC_RIFSC(PKA)),
+	STM32_GATE_CFG(CK_BUS_ADF1, ck_icn_p_adf1, SEC_RIFSC(ADF1)),
+	STM32_GATE_CFG(CK_BUS_SPI8, ck_icn_p_spi8, SEC_RIFSC(SPI8)),
+	STM32_GATE_CFG(CK_BUS_LPUART1, ck_icn_p_lpuart1, SEC_RIFSC(LPUART1)),
+	STM32_GATE_CFG(CK_BUS_I2C8, ck_icn_p_i2c8, SEC_RIFSC(I2C8)),
+	STM32_GATE_CFG(CK_BUS_LPTIM3, ck_icn_p_lptim3, SEC_RIFSC(LPTIM3)),
+	STM32_GATE_CFG(CK_BUS_LPTIM4, ck_icn_p_lptim4, SEC_RIFSC(LPTIM4)),
+	STM32_GATE_CFG(CK_BUS_LPTIM5, ck_icn_p_lptim5, SEC_RIFSC(LPTIM5)),
+	STM32_GATE_CFG(CK_BUS_IWDG5, ck_icn_p_iwdg5, SEC_RIFSC(IWDG5)),
+	STM32_GATE_CFG(CK_BUS_WWDG2, ck_icn_p_wwdg2, SEC_RIFSC(WWDG2)),
+	STM32_GATE_CFG(CK_BUS_I3C4, ck_icn_p_i3c4, SEC_RIFSC(I3C4)),
+	STM32_GATE_CFG(CK_BUS_SDMMC1, ck_icn_m_sdmmc1, SEC_RIFSC(SDMMC1)),
+	STM32_GATE_CFG(CK_BUS_SDMMC2, ck_icn_m_sdmmc2, SEC_RIFSC(SDMMC2)),
+	STM32_GATE_CFG(CK_BUS_SDMMC3, ck_icn_m_sdmmc3, SEC_RIFSC(SDMMC3)),
+	STM32_GATE_CFG(CK_BUS_USB2OHCI, ck_icn_m_usb2ohci, SEC_RIFSC(USBH)),
+	STM32_GATE_CFG(CK_BUS_USB2EHCI, ck_icn_m_usb2ehci, SEC_RIFSC(USBH)),
+	STM32_GATE_CFG(CK_BUS_USB3DR, ck_icn_m_usb3dr, SEC_RIFSC(USB3DR)),
+	STM32_GATE_CFG(CK_BUS_TIM2, ck_icn_p_tim2, SEC_RIFSC(TIM2)),
+	STM32_GATE_CFG(CK_BUS_TIM3, ck_icn_p_tim3, SEC_RIFSC(TIM3)),
+	STM32_GATE_CFG(CK_BUS_TIM4, ck_icn_p_tim4, SEC_RIFSC(TIM4)),
+	STM32_GATE_CFG(CK_BUS_TIM5, ck_icn_p_tim5, SEC_RIFSC(TIM5)),
+	STM32_GATE_CFG(CK_BUS_TIM6, ck_icn_p_tim6, SEC_RIFSC(TIM6)),
+	STM32_GATE_CFG(CK_BUS_TIM7, ck_icn_p_tim7, SEC_RIFSC(TIM7)),
+	STM32_GATE_CFG(CK_BUS_TIM10, ck_icn_p_tim10, SEC_RIFSC(TIM10)),
+	STM32_GATE_CFG(CK_BUS_TIM11, ck_icn_p_tim11, SEC_RIFSC(TIM11)),
+	STM32_GATE_CFG(CK_BUS_TIM12, ck_icn_p_tim12, SEC_RIFSC(TIM12)),
+	STM32_GATE_CFG(CK_BUS_TIM13, ck_icn_p_tim13, SEC_RIFSC(TIM13)),
+	STM32_GATE_CFG(CK_BUS_TIM14, ck_icn_p_tim14, SEC_RIFSC(TIM14)),
+	STM32_GATE_CFG(CK_BUS_LPTIM1, ck_icn_p_lptim1, SEC_RIFSC(LPTIM1)),
+	STM32_GATE_CFG(CK_BUS_LPTIM2, ck_icn_p_lptim2, SEC_RIFSC(LPTIM2)),
+	STM32_GATE_CFG(CK_BUS_SPI2, ck_icn_p_spi2, SEC_RIFSC(SPI2)),
+	STM32_GATE_CFG(CK_BUS_SPI3, ck_icn_p_spi3, SEC_RIFSC(SPI3)),
+	STM32_GATE_CFG(CK_BUS_SPDIFRX, ck_icn_p_spdifrx, SEC_RIFSC(SPDIFRX)),
+	STM32_GATE_CFG(CK_BUS_USART2, ck_icn_p_usart2, SEC_RIFSC(USART2)),
+	STM32_GATE_CFG(CK_BUS_USART3, ck_icn_p_usart3, SEC_RIFSC(USART3)),
+	STM32_GATE_CFG(CK_BUS_UART4, ck_icn_p_uart4, SEC_RIFSC(UART4)),
+	STM32_GATE_CFG(CK_BUS_UART5, ck_icn_p_uart5, SEC_RIFSC(UART5)),
+	STM32_GATE_CFG(CK_BUS_I2C1, ck_icn_p_i2c1, SEC_RIFSC(I2C1)),
+	STM32_GATE_CFG(CK_BUS_I2C2, ck_icn_p_i2c2, SEC_RIFSC(I2C2)),
+	STM32_GATE_CFG(CK_BUS_I2C3, ck_icn_p_i2c3, SEC_RIFSC(I2C3)),
+	STM32_GATE_CFG(CK_BUS_I2C4, ck_icn_p_i2c4, SEC_RIFSC(I2C4)),
+	STM32_GATE_CFG(CK_BUS_I2C5, ck_icn_p_i2c5, SEC_RIFSC(I2C5)),
+	STM32_GATE_CFG(CK_BUS_I2C6, ck_icn_p_i2c6, SEC_RIFSC(I2C6)),
+	STM32_GATE_CFG(CK_BUS_I2C7, ck_icn_p_i2c7, SEC_RIFSC(I2C7)),
+	STM32_GATE_CFG(CK_BUS_I3C1, ck_icn_p_i3c1, SEC_RIFSC(I3C1)),
+	STM32_GATE_CFG(CK_BUS_I3C2, ck_icn_p_i3c2, SEC_RIFSC(I3C2)),
+	STM32_GATE_CFG(CK_BUS_I3C3, ck_icn_p_i3c3, SEC_RIFSC(I3C3)),
+	STM32_GATE_CFG(CK_BUS_TIM1, ck_icn_p_tim1, SEC_RIFSC(TIM1)),
+	STM32_GATE_CFG(CK_BUS_TIM8, ck_icn_p_tim8, SEC_RIFSC(TIM8)),
+	STM32_GATE_CFG(CK_BUS_TIM15, ck_icn_p_tim15, SEC_RIFSC(TIM15)),
+	STM32_GATE_CFG(CK_BUS_TIM16, ck_icn_p_tim16, SEC_RIFSC(TIM16)),
+	STM32_GATE_CFG(CK_BUS_TIM17, ck_icn_p_tim17, SEC_RIFSC(TIM17)),
+	STM32_GATE_CFG(CK_BUS_TIM20, ck_icn_p_tim20, SEC_RIFSC(TIM20)),
+	STM32_GATE_CFG(CK_BUS_SAI1, ck_icn_p_sai1, SEC_RIFSC(SAI1)),
+	STM32_GATE_CFG(CK_BUS_SAI2, ck_icn_p_sai2, SEC_RIFSC(SAI2)),
+	STM32_GATE_CFG(CK_BUS_SAI3, ck_icn_p_sai3, SEC_RIFSC(SAI3)),
+	STM32_GATE_CFG(CK_BUS_SAI4, ck_icn_p_sai4, SEC_RIFSC(SAI4)),
+	STM32_GATE_CFG(CK_BUS_USART1, ck_icn_p_usart1, SEC_RIFSC(USART1)),
+	STM32_GATE_CFG(CK_BUS_USART6, ck_icn_p_usart6, SEC_RIFSC(USART6)),
+	STM32_GATE_CFG(CK_BUS_UART7, ck_icn_p_uart7, SEC_RIFSC(UART7)),
+	STM32_GATE_CFG(CK_BUS_UART8, ck_icn_p_uart8, SEC_RIFSC(UART8)),
+	STM32_GATE_CFG(CK_BUS_UART9, ck_icn_p_uart9, SEC_RIFSC(UART9)),
+	STM32_GATE_CFG(CK_BUS_FDCAN, ck_icn_p_fdcan, SEC_RIFSC(FDCAN)),
+	STM32_GATE_CFG(CK_BUS_SPI1, ck_icn_p_spi1, SEC_RIFSC(SPI1)),
+	STM32_GATE_CFG(CK_BUS_SPI4, ck_icn_p_spi4, SEC_RIFSC(SPI4)),
+	STM32_GATE_CFG(CK_BUS_SPI5, ck_icn_p_spi5, SEC_RIFSC(SPI5)),
+	STM32_GATE_CFG(CK_BUS_SPI6, ck_icn_p_spi6, SEC_RIFSC(SPI6)),
+	STM32_GATE_CFG(CK_BUS_SPI7, ck_icn_p_spi7, SEC_RIFSC(SPI7)),
+	STM32_GATE_CFG(CK_BUS_IWDG1, ck_icn_p_iwdg1, SEC_RIFSC(IWDG1)),
+	STM32_GATE_CFG(CK_BUS_IWDG2, ck_icn_p_iwdg2, SEC_RIFSC(IWDG2)),
+	STM32_GATE_CFG(CK_BUS_IWDG3, ck_icn_p_iwdg3, SEC_RIFSC(IWDG3)),
+	STM32_GATE_CFG(CK_BUS_IWDG4, ck_icn_p_iwdg4, SEC_RIFSC(IWDG4)),
+	STM32_GATE_CFG(CK_BUS_WWDG1, ck_icn_p_wwdg1, SEC_RIFSC(WWDG1)),
+	STM32_GATE_CFG(CK_BUS_VREF, ck_icn_p_vref, SEC_RIFSC(VREFBUF)),
+	STM32_GATE_CFG(CK_BUS_SERC, ck_icn_p_serc, SEC_RIFSC(SERC)),
+	STM32_GATE_CFG(CK_BUS_HDP, ck_icn_p_hdp, SEC_RIFSC(HDP)),
+	STM32_GATE_CFG(CK_BUS_IS2M, ck_icn_p_is2m, SEC_RIFRCC(IS2M)),
+	STM32_GATE_CFG(CK_BUS_DSI, ck_icn_p_dsi, SEC_RIFSC(DSI_CMN)),
+	STM32_GATE_CFG(CK_BUS_LTDC, ck_icn_p_ltdc, SEC_RIFSC(LTDC_CMN)),
+	STM32_GATE_CFG(CK_BUS_CSI, ck_icn_p_csi, SEC_RIFSC(CSI)),
+	STM32_GATE_CFG(CK_BUS_DCMIPP, ck_icn_p_dcmipp, SEC_RIFSC(DCMIPP)),
+	STM32_GATE_CFG(CK_BUS_LVDS, ck_icn_p_lvds, SEC_RIFSC(LVDS)),
+	STM32_GATE_CFG(CK_BUS_USBTC, ck_icn_p_usbtc, SEC_RIFSC(UCPD1)),
+	STM32_GATE_CFG(CK_BUS_USB3PCIEPHY, ck_icn_p_usb3pciephy, SEC_RIFSC(USB3DR)),
+	STM32_GATE_CFG(CK_BUS_VDEC, ck_icn_p_vdec, SEC_RIFSC(VDEC)),
+	STM32_GATE_CFG(CK_BUS_VENC, ck_icn_p_venc, SEC_RIFSC(VENC)),
+	STM32_GATE_CFG(CK_KER_TIM2, ck_ker_tim2, SEC_RIFSC(TIM2)),
+	STM32_GATE_CFG(CK_KER_TIM3, ck_ker_tim3, SEC_RIFSC(TIM3)),
+	STM32_GATE_CFG(CK_KER_TIM4, ck_ker_tim4, SEC_RIFSC(TIM4)),
+	STM32_GATE_CFG(CK_KER_TIM5, ck_ker_tim5, SEC_RIFSC(TIM5)),
+	STM32_GATE_CFG(CK_KER_TIM6, ck_ker_tim6, SEC_RIFSC(TIM6)),
+	STM32_GATE_CFG(CK_KER_TIM7, ck_ker_tim7, SEC_RIFSC(TIM7)),
+	STM32_GATE_CFG(CK_KER_TIM10, ck_ker_tim10, SEC_RIFSC(TIM10)),
+	STM32_GATE_CFG(CK_KER_TIM11, ck_ker_tim11, SEC_RIFSC(TIM11)),
+	STM32_GATE_CFG(CK_KER_TIM12, ck_ker_tim12, SEC_RIFSC(TIM12)),
+	STM32_GATE_CFG(CK_KER_TIM13, ck_ker_tim13, SEC_RIFSC(TIM13)),
+	STM32_GATE_CFG(CK_KER_TIM14, ck_ker_tim14, SEC_RIFSC(TIM14)),
+	STM32_GATE_CFG(CK_KER_TIM1, ck_ker_tim1, SEC_RIFSC(TIM1)),
+	STM32_GATE_CFG(CK_KER_TIM8, ck_ker_tim8, SEC_RIFSC(TIM8)),
+	STM32_GATE_CFG(CK_KER_TIM15, ck_ker_tim15, SEC_RIFSC(TIM15)),
+	STM32_GATE_CFG(CK_KER_TIM16, ck_ker_tim16, SEC_RIFSC(TIM16)),
+	STM32_GATE_CFG(CK_KER_TIM17, ck_ker_tim17, SEC_RIFSC(TIM17)),
+	STM32_GATE_CFG(CK_KER_TIM20, ck_ker_tim20, SEC_RIFSC(TIM20)),
+	STM32_GATE_CFG(CK_KER_LPTIM1, ck_ker_lptim1, SEC_RIFSC(LPTIM1)),
+	STM32_GATE_CFG(CK_KER_LPTIM2, ck_ker_lptim2, SEC_RIFSC(LPTIM2)),
+	STM32_GATE_CFG(CK_KER_USART2, ck_ker_usart2, SEC_RIFSC(USART2)),
+	STM32_GATE_CFG(CK_KER_UART4, ck_ker_uart4, SEC_RIFSC(UART4)),
+	STM32_GATE_CFG(CK_KER_USART3, ck_ker_usart3, SEC_RIFSC(USART3)),
+	STM32_GATE_CFG(CK_KER_UART5, ck_ker_uart5, SEC_RIFSC(UART5)),
+	STM32_GATE_CFG(CK_KER_SPI2, ck_ker_spi2, SEC_RIFSC(SPI2)),
+	STM32_GATE_CFG(CK_KER_SPI3, ck_ker_spi3, SEC_RIFSC(SPI3)),
+	STM32_GATE_CFG(CK_KER_SPDIFRX, ck_ker_spdifrx, SEC_RIFSC(SPDIFRX)),
+	STM32_GATE_CFG(CK_KER_I2C1, ck_ker_i2c1, SEC_RIFSC(I2C1)),
+	STM32_GATE_CFG(CK_KER_I2C2, ck_ker_i2c2, SEC_RIFSC(I2C2)),
+	STM32_GATE_CFG(CK_KER_I3C1, ck_ker_i3c1, SEC_RIFSC(I3C1)),
+	STM32_GATE_CFG(CK_KER_I3C2, ck_ker_i3c2, SEC_RIFSC(I3C2)),
+	STM32_GATE_CFG(CK_KER_I2C3, ck_ker_i2c3, SEC_RIFSC(I2C3)),
+	STM32_GATE_CFG(CK_KER_I2C5, ck_ker_i2c5, SEC_RIFSC(I2C5)),
+	STM32_GATE_CFG(CK_KER_I3C3, ck_ker_i3c3, SEC_RIFSC(I3C3)),
+	STM32_GATE_CFG(CK_KER_I2C4, ck_ker_i2c4, SEC_RIFSC(I2C4)),
+	STM32_GATE_CFG(CK_KER_I2C6, ck_ker_i2c6, SEC_RIFSC(I2C6)),
+	STM32_GATE_CFG(CK_KER_I2C7, ck_ker_i2c7, SEC_RIFSC(I2C7)),
+	STM32_GATE_CFG(CK_KER_SPI1, ck_ker_spi1, SEC_RIFSC(SPI1)),
+	STM32_GATE_CFG(CK_KER_SPI4, ck_ker_spi4, SEC_RIFSC(SPI4)),
+	STM32_GATE_CFG(CK_KER_SPI5, ck_ker_spi5, SEC_RIFSC(SPI5)),
+	STM32_GATE_CFG(CK_KER_SPI6, ck_ker_spi6, SEC_RIFSC(SPI6)),
+	STM32_GATE_CFG(CK_KER_SPI7, ck_ker_spi7, SEC_RIFSC(SPI7)),
+	STM32_GATE_CFG(CK_KER_USART1, ck_ker_usart1, SEC_RIFSC(USART1)),
+	STM32_GATE_CFG(CK_KER_USART6, ck_ker_usart6, SEC_RIFSC(USART6)),
+	STM32_GATE_CFG(CK_KER_UART7, ck_ker_uart7, SEC_RIFSC(UART7)),
+	STM32_GATE_CFG(CK_KER_UART8, ck_ker_uart8, SEC_RIFSC(UART8)),
+	STM32_GATE_CFG(CK_KER_UART9, ck_ker_uart9, SEC_RIFSC(UART9)),
+	STM32_GATE_CFG(CK_KER_MDF1, ck_ker_mdf1, SEC_RIFSC(MDF1)),
+	STM32_GATE_CFG(CK_KER_SAI1, ck_ker_sai1, SEC_RIFSC(SAI1)),
+	STM32_GATE_CFG(CK_KER_SAI2, ck_ker_sai2, SEC_RIFSC(SAI2)),
+	STM32_GATE_CFG(CK_KER_SAI3, ck_ker_sai3, SEC_RIFSC(SAI3)),
+	STM32_GATE_CFG(CK_KER_SAI4, ck_ker_sai4, SEC_RIFSC(SAI4)),
+	STM32_GATE_CFG(CK_KER_FDCAN, ck_ker_fdcan, SEC_RIFSC(FDCAN)),
+	STM32_GATE_CFG(CK_KER_CSI, ck_ker_csi, SEC_RIFSC(CSI)),
+	STM32_GATE_CFG(CK_KER_CSITXESC, ck_ker_csitxesc, SEC_RIFSC(CSI)),
+	STM32_GATE_CFG(CK_KER_CSIPHY, ck_ker_csiphy, SEC_RIFSC(CSI)),
+	STM32_GATE_CFG(CK_KER_USBTC, ck_ker_usbtc, SEC_RIFSC(UCPD1)),
+	STM32_GATE_CFG(CK_KER_I3C4, ck_ker_i3c4, SEC_RIFSC(I3C4)),
+	STM32_GATE_CFG(CK_KER_SPI8, ck_ker_spi8, SEC_RIFSC(SPI8)),
+	STM32_GATE_CFG(CK_KER_I2C8, ck_ker_i2c8, SEC_RIFSC(I2C8)),
+	STM32_GATE_CFG(CK_KER_LPUART1, ck_ker_lpuart1, SEC_RIFSC(LPUART1)),
+	STM32_GATE_CFG(CK_KER_LPTIM3, ck_ker_lptim3, SEC_RIFSC(LPTIM3)),
+	STM32_GATE_CFG(CK_KER_LPTIM4, ck_ker_lptim4, SEC_RIFSC(LPTIM4)),
+	STM32_GATE_CFG(CK_KER_LPTIM5, ck_ker_lptim5, SEC_RIFSC(LPTIM5)),
+	STM32_GATE_CFG(CK_KER_ADF1, ck_ker_adf1, SEC_RIFSC(ADF1)),
+	STM32_GATE_CFG(CK_KER_SDMMC1, ck_ker_sdmmc1, SEC_RIFSC(SDMMC1)),
+	STM32_GATE_CFG(CK_KER_SDMMC2, ck_ker_sdmmc2, SEC_RIFSC(SDMMC2)),
+	STM32_GATE_CFG(CK_KER_SDMMC3, ck_ker_sdmmc3, SEC_RIFSC(SDMMC3)),
+	STM32_GATE_CFG(CK_KER_ETH1, ck_ker_eth1, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_ETH1_STP, ck_ker_eth1stp, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_KER_ETHSW, ck_ker_ethsw, SEC_RIFSC(ETHSW_DEIP)),
+	STM32_GATE_CFG(CK_KER_ETH2, ck_ker_eth2, SEC_RIFSC(ETH2)),
+	STM32_GATE_CFG(CK_ETH2_STP, ck_ker_eth2stp, SEC_RIFSC(ETH2)),
+	STM32_GATE_CFG(CK_KER_ETH1PTP, ck_ker_eth1ptp, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_KER_ETH2PTP, ck_ker_eth2ptp, SEC_RIFSC(ETH2)),
+	STM32_GATE_CFG(CK_BUS_GPU, ck_icn_m_gpu, SEC_RIFSC(GPU)),
+	STM32_GATE_CFG(CK_KER_GPU, ck_ker_gpu, SEC_RIFSC(GPU)),
+	STM32_GATE_CFG(CK_KER_ETHSWREF, ck_ker_ethswref, SEC_RIFSC(ETHSW_DEIP)),
+	STM32_GATE_CFG(CK_BUS_ETHSWACMCFG, ck_icn_p_ethsw_acm_cfg, SEC_RIFSC(ETHSW_ACM_CFG)),
+	STM32_GATE_CFG(CK_BUS_ETHSWACMMSG, ck_icn_p_ethsw_acm_msg, SEC_RIFSC(ETHSW_ACM_MSGBUF)),
+	STM32_GATE_CFG(CK_ETH1_MAC, ck_ker_eth1mac, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_ETH1_TX, ck_ker_eth1tx, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_ETH1_RX, ck_ker_eth1rx, SEC_RIFSC(ETH1)),
+	STM32_GATE_CFG(CK_ETH2_MAC, ck_ker_eth2mac, SEC_RIFSC(ETH2)),
+	STM32_GATE_CFG(CK_ETH2_TX, ck_ker_eth2tx, SEC_RIFSC(ETH2)),
+	STM32_GATE_CFG(CK_ETH2_RX, ck_ker_eth2rx, SEC_RIFSC(ETH2)),
+	STM32_COMPOSITE_CFG(CK_MCO1, ck_mco1, SEC_RIFRCC(MCO1)),
+	STM32_COMPOSITE_CFG(CK_MCO2, ck_mco2, SEC_RIFRCC(MCO2)),
+	STM32_COMPOSITE_CFG(CK_KER_ADC12, ck_ker_adc12, SEC_RIFSC(ADC12)),
+	STM32_COMPOSITE_CFG(CK_KER_ADC3, ck_ker_adc3, SEC_RIFSC(ADC3)),
+	STM32_COMPOSITE_CFG(CK_KER_USB2PHY1, ck_ker_usb2phy1, SEC_RIFSC(USBH)),
+	STM32_GATE_CFG(CK_KER_USB2PHY2, ck_ker_usb2phy2, SEC_RIFSC(USBH)),
+	STM32_COMPOSITE_CFG(CK_KER_USB2PHY2EN, ck_ker_usb2phy2_en, SEC_RIFSC(USBH)),
+	STM32_COMPOSITE_CFG(CK_KER_USB3PCIEPHY, ck_ker_usb3pciephy, SEC_RIFSC(USB3DR)),
+	STM32_COMPOSITE_CFG(CK_KER_DSIBLANE, clk_lanebyte, SEC_RIFSC(DSI_CMN)),
+	STM32_COMPOSITE_CFG(CK_KER_DSIPHY, clk_phy_dsi, SEC_RIFSC(DSI_CMN)),
+	STM32_COMPOSITE_CFG(CK_KER_LVDSPHY, ck_ker_lvdsphy, SEC_RIFSC(LVDS)),
+	STM32_COMPOSITE_CFG(CK_KER_DTS, ck_ker_dts, SEC_RIFSC(DTS)),
+	STM32_GATE_CFG(CK_KER_LTDC, ck_ker_ltdc, SEC_RIFSC(LTDC_CMN)),
+};
+
+u16 stm32mp25_cpt_gate[GATE_NB];
+
+#ifdef CONFIG_DEBUG_FS
+static struct clock_summary clock_summary_mp25;
+#endif
+
+struct clk_stm32_clock_data stm32mp25_clock_data = {
+	.gate_cpt	= stm32mp25_cpt_gate,
+	.gates		= stm32mp25_gates,
+	.muxes		= stm32mp25_muxes,
+#ifdef CONFIG_DEBUG_FS
+	.dividers	= stm32mp25_dividers,
+#endif
+};
+
+static struct stm32_rcc_match_data stm32mp25_data = {
+	.tab_clocks	= stm32mp25_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp25_clock_cfg),
+	.maxbinding	= STM32MP25_LAST_CLK,
+	.clock_data	= &stm32mp25_clock_data,
+	.check_security = &stm32mp25_check_security,
+	.reset_us	= 2,
+#ifdef CONFIG_DEBUG_FS
+	.clock_summary	= &clock_summary_mp25,
+#endif
+};
+
+static const struct of_device_id stm32mp25_match_data[] = {
+	{
+		.compatible = "st,stm32mp25-rcc",
+		.data = &stm32mp25_data,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm32mp25_match_data);
+
+static int stm32mp25_rcc_init(struct device *dev)
+{
+	void __iomem *base;
+	int ret;
+
+	base = of_iomap(dev_of_node(dev), 0);
+	if (!base) {
+		dev_err(dev, "%pOFn: unable to map resource", dev_of_node(dev));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = stm32_rcc_init(dev, stm32mp25_match_data, base);
+
+out:
+	if (ret) {
+		if (base)
+			iounmap(base);
+
+		of_node_put(dev_of_node(dev));
+	}
+
+	return ret;
+}
+
+static int get_clock_deps(struct device *dev)
+{
+	static const char * const clock_deps_name[] = {
+		"hsi", "hse", "msi", "lsi", "lse",
+	};
+	size_t deps_size = sizeof(struct clk *) * ARRAY_SIZE(clock_deps_name);
+	struct clk **clk_deps;
+	int i;
+
+	clk_deps = devm_kzalloc(dev, deps_size, GFP_KERNEL);
+	if (!clk_deps)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(clock_deps_name); i++) {
+		struct clk *clk;
+
+		clk = of_clk_get_by_name(dev_of_node(dev), clock_deps_name[i]);
+
+		if (IS_ERR(clk)) {
+			if (PTR_ERR(clk) != -EINVAL && PTR_ERR(clk) != -ENOENT)
+				return PTR_ERR(clk);
+		} else {
+			/* Device gets a reference count on the clock */
+			clk_deps[i] = devm_clk_get(dev, __clk_get_name(clk));
+			clk_put(clk);
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp25_rcc_clocks_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret = get_clock_deps(dev);
+
+	if (!ret)
+		ret = stm32mp25_rcc_init(dev);
+
+	return ret;
+}
+
+static int stm32mp25_rcc_clocks_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *child, *np = dev_of_node(dev);
+
+	for_each_available_child_of_node(np, child)
+		of_clk_del_provider(child);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int stm32_rcc_suspend(struct device *dev)
+{
+	clk_save_context();
+
+	return 0;
+}
+
+static int stm32_rcc_resume(struct device *dev)
+{
+	clk_restore_context();
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops stm32_rcc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_rcc_suspend, stm32_rcc_resume)
+};
+
+static struct platform_driver stm32mp25_rcc_clocks_driver = {
+	.driver	= {
+		.name = "stm32mp25_rcc",
+		.of_match_table = stm32mp25_match_data,
+		.pm = &stm32_rcc_pm_ops,
+	},
+	.probe = stm32mp25_rcc_clocks_probe,
+	.remove = stm32mp25_rcc_clocks_remove,
+};
+
+static int __init stm32mp25_clocks_init(void)
+{
+	return platform_driver_register(&stm32mp25_rcc_clocks_driver);
+}
+
+core_initcall(stm32mp25_clocks_init);
+
+#ifdef CONFIG_DEBUG_FS
+
+#include <linux/debugfs.h>
+
+static const char * const pll_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const flexgen_src[] = {
+	"ck_pll4", "ck_pll5", "ck_pll6", "ck_pll7", "ck_pll8",
+	"hsi_ck", "hse_ck", "msi_ck", "hsi_ck", "hse_ck", "msi_ck",
+	"spdifsymb", "i2sckin", "lsi_ck", "lse_ck"
+};
+
+static unsigned long clk_summary_div_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	return stm32_divider_get_rate(data->base, data, c->div_id, parent_rate);
+}
+
+#define PARENT(_parent)	((const char *[]) { _parent})
+
+#define CS_DIV(_name, _parent, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= _div,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_div_recalc_rate,\
+}
+
+#define CS_GATE(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEMUX(_name, _parents, _gate, _mux) \
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+}
+
+#define CS_GATEDIV(_name, _parent, _gate, _div) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= _div,\
+}
+
+static unsigned long clk_summary_clk_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct clk *clk = __clk_lookup(c->name);
+
+	if (clk)
+		return clk_get_rate(clk);
+
+	return 0;
+}
+
+#define CS_OSC(_name, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_clk_recalc_rate,\
+}
+
+static unsigned long clk_summary_hsediv2_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long parent_rate)
+{
+	void __iomem *addr = data->base + RCC_OCENSETR;
+
+	if ((readl(addr) & RCC_OCENSETR_HSEDIV2BYP) != 0U)
+		return parent_rate;
+
+	return parent_rate / 2;
+}
+
+#define CS_HSE_DIV2(_name, _parent, _gate) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.gate_id	= _gate,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.get_rate	= clk_summary_hsediv2_recalc_rate,\
+}
+
+static bool clk_summary_cpu1_is_enabled(struct clk_stm32_clock_data *data,
+					struct clk_summary *c)
+{
+	return true;
+}
+
+#define CS_CPU1(_name) \
+{\
+	.name		= _name,\
+	.nb_parents	= 0,\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.get_rate	= clk_summary_clk_recalc_rate,\
+	.is_enabled	= clk_summary_cpu1_is_enabled,\
+}
+
+/* PLL configuration registers offsets from RCC_PLLxCFGR1 */
+#define RCC_OFFSET_PLLXCFGR1	0x00
+#define RCC_OFFSET_PLLXCFGR2	0x04
+#define RCC_OFFSET_PLLXCFGR3	0x08
+#define RCC_OFFSET_PLLXCFGR4	0x0C
+#define RCC_OFFSET_PLLXCFGR5	0x10
+#define RCC_OFFSET_PLLXCFGR6	0x18
+#define RCC_OFFSET_PLLXCFGR7	0x1C
+
+struct cs_pll {
+	u32 offset;
+};
+
+static unsigned long clk_get_pll_fvco(struct clk_stm32_clock_data *data, u32 offset_base,
+				      unsigned long prate)
+{
+	void __iomem *pllxcfgr1 = data->base + offset_base;
+	void __iomem *pllxcfgr2 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR2;
+	void __iomem *pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+	unsigned long fvco = 0UL;
+	u32 fracin, fbdiv, refdiv;
+
+	fracin = readl(pllxcfgr3) & RCC_PLLxCFGR3_FRACIN_MASK;
+	fbdiv = (readl(pllxcfgr2) & RCC_PLLxCFGR2_FBDIV_MASK) >>
+		RCC_PLLxCFGR2_FBDIV_SHIFT;
+
+	refdiv = readl(pllxcfgr2) & RCC_PLLxCFGR2_FREFDIV_MASK;
+
+	if (fracin != 0U) {
+		unsigned long long numerator, denominator;
+
+		numerator = ((unsigned long long)fbdiv << 24) + fracin;
+		fvco = prate * numerator;
+		denominator = (unsigned long long)refdiv << 24;
+		do_div(fvco, denominator);
+
+	} else {
+		fvco = (u64)prate * fbdiv;
+		do_div(fvco, refdiv);
+	}
+
+	return fvco;
+}
+
+static unsigned long clk_summary_pll_frac_div_recalc_rate(struct clk_stm32_clock_data *data,
+							  struct clk_summary *c,
+							  unsigned long prate)
+{
+	struct cs_pll *cfg = c->data;
+	void __iomem *pllxcfgr1 = data->base + cfg->offset;
+	void __iomem *pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	void __iomem *pllxcfgr6 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR6;
+	void __iomem *pllxcfgr7 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR7;
+	unsigned long dfout;
+	u32 postdiv1, postdiv2;
+
+	postdiv1 = readl(pllxcfgr6) & RCC_PLLxCFGR6_POSTDIV1_MASK;
+	postdiv2 = readl(pllxcfgr7) & RCC_PLLxCFGR7_POSTDIV2_MASK;
+
+	if ((readl(pllxcfgr4) & RCC_PLLxCFGR4_BYPASS) != 0U) {
+		dfout = prate;
+	} else {
+		if (postdiv1 == 0U || postdiv2 == 0U)
+			dfout = prate;
+		else
+			dfout = clk_get_pll_fvco(data, cfg->offset, prate) /
+						 (postdiv1 * postdiv2);
+	}
+
+	return dfout;
+}
+
+#define CS_PLL(_name, _parents, _gate, _mux, _offset)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(_parents),\
+	.parent_names	= _parents,\
+	.gate_id	= _gate,\
+	.mux_id		= _mux,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_pll) {\
+		.offset		= _offset,\
+	},\
+	.get_rate	= clk_summary_pll_frac_div_recalc_rate,\
+}
+
+struct cs_flexgen {
+	u32 channel;
+};
+
+static bool clk_summary_flexgen_is_enabled(struct clk_stm32_clock_data *data,
+					   struct clk_summary *c)
+{
+	struct cs_flexgen *cfg = c->data;
+
+	return !!(readl(data->base + RCC_FINDIV0CFGR + (0x4 * cfg->channel)) &
+		RCC_FINDIVxCFGR_FINDIVxEN);
+}
+
+static u8 clk_summary_flexgen_get_parent(struct clk_stm32_clock_data *data,
+					 struct clk_summary *c)
+{
+	struct cs_flexgen *cfg = c->data;
+	void __iomem *address = data->base + RCC_XBAR0CFGR + (cfg->channel * 4);
+
+	return readl(address) & RCC_XBARxCFGR_XBARxSEL_MASK;
+}
+
+static unsigned long clk_summary_flexgen_recalc_rate(struct clk_stm32_clock_data *data,
+						     struct clk_summary *c,
+						     unsigned long prate)
+{
+	struct cs_flexgen *cfg = c->data;
+	u8 channel = cfg->channel;
+	u32 prediv, findiv;
+	unsigned long freq = prate;
+
+	prediv = readl(data->base + RCC_PREDIV0CFGR + (0x4 * channel)) &
+		       RCC_PREDIVxCFGR_PREDIVx_MASK;
+
+	findiv = readl(data->base + RCC_FINDIV0CFGR + (0x4 * channel)) &
+		       RCC_FINDIVxCFGR_FINDIVx_MASK;
+
+	if (freq == 0)
+		return 0;
+
+	switch (prediv) {
+	case 0x0:
+		break;
+
+	case 0x1:
+		freq /= 2;
+		break;
+
+	case 0x3:
+		freq /= 4;
+		break;
+
+	case 0x3FF:
+		freq /= 1024;
+		break;
+	}
+
+	freq /= (findiv + 1);
+
+	return freq;
+}
+
+#define CS_FLEXGEN(_name, _channel)\
+{\
+	.name		= _name,\
+	.nb_parents	= ARRAY_SIZE(flexgen_src),\
+	.parent_names	= flexgen_src,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.div_id		= NO_STM32_DIV,\
+	.data		=  &(struct cs_flexgen) {\
+		.channel		= _channel,\
+	},\
+	.is_enabled	= clk_summary_flexgen_is_enabled,\
+	.get_parent	= clk_summary_flexgen_get_parent,\
+	.get_rate	= clk_summary_flexgen_recalc_rate,\
+}
+
+struct cs_stm32_timer {
+	u32 apbdiv;
+	u32 timpre;
+};
+
+#define APB_DIV_MASK 0x07
+#define TIM_PRE_MASK 0x01
+
+static unsigned long clk_stm32_timer_recalc_rate(struct clk_stm32_clock_data *data,
+						 struct clk_summary *c,
+						 unsigned long parent_rate)
+{
+	struct cs_stm32_timer *tim = c->data;
+	u32 prescaler, timpre;
+
+	prescaler = readl(data->base + tim->apbdiv) & APB_DIV_MASK;
+
+	timpre = readl(data->base + tim->timpre) & TIM_PRE_MASK;
+
+	if (prescaler == 0U)
+		return parent_rate;
+
+	return parent_rate * (timpre + 1U) * 2U;
+}
+
+#define CS_STM32_TIMER(_name, _parent, _apbdiv, _timpre) \
+{\
+	.name		= _name,\
+	.nb_parents	= 1,\
+	.parent_names	= PARENT(_parent),\
+	.div_id		= NO_STM32_DIV,\
+	.gate_id	= NO_STM32_GATE,\
+	.mux_id		= NO_STM32_MUX,\
+	.data		=  &(struct cs_stm32_timer) {\
+		.apbdiv		= _apbdiv,\
+		.timpre		= _timpre,\
+	},\
+	.get_rate	= clk_stm32_timer_recalc_rate,\
+}
+
+static const char * const rtc_src[] = {
+	"off", "hse_ck", "lsi_ck", "ck_hse_rtc"
+};
+
+static struct clk_summary stm32mp25_clock_summary[] = {
+	CS_OSC("hsi_ck", GATE_HSI),
+	CS_OSC("lsi_ck", GATE_LSI),
+	CS_OSC("msi_ck", GATE_MSI),
+	CS_OSC("hse_ck", GATE_HSE),
+	CS_OSC("lse_ck", GATE_LSE),
+
+	CS_HSE_DIV2("hse_div2_ck", "hse_ck", GATE_HSEDIV2),
+	CS_DIV("ck_hse_rtc", "hse_ck", DIV_RTC),
+
+	CS_PLL("ck_pll2", pll_src, GATE_PLL2, MUX_MUXSEL6, RCC_PLL2CFGR1),
+	CS_PLL("ck_pll3", pll_src, GATE_PLL3, MUX_MUXSEL7, RCC_PLL3CFGR1),
+	CS_PLL("ck_pll4", pll_src, GATE_PLL4, MUX_MUXSEL0, RCC_PLL4CFGR1),
+	CS_PLL("ck_pll5", pll_src, GATE_PLL5, MUX_MUXSEL1, RCC_PLL5CFGR1),
+	CS_PLL("ck_pll6", pll_src, GATE_PLL6, MUX_MUXSEL2, RCC_PLL6CFGR1),
+	CS_PLL("ck_pll7", pll_src, GATE_PLL7, MUX_MUXSEL3, RCC_PLL7CFGR1),
+	CS_PLL("ck_pll8", pll_src, GATE_PLL8, MUX_MUXSEL4, RCC_PLL8CFGR1),
+
+	CS_CPU1("ck_cpu1"),
+
+	CS_FLEXGEN("ck_icn_hs_mcu", 0),
+
+	CS_DIV("ck_icn_ls_mcu", "ck_icn_hs_mcu", DIV_LSMCU),
+
+	CS_FLEXGEN("ck_icn_sdmmc", 1),
+	CS_FLEXGEN("ck_icn_ddr", 2),
+	CS_FLEXGEN("ck_icn_display", 3),
+	CS_FLEXGEN("ck_icn_hsl", 4),
+	CS_FLEXGEN("ck_icn_nic", 5),
+	CS_FLEXGEN("ck_icn_vid", 6),
+	CS_FLEXGEN("ck_flexgen_07", 7),
+	CS_FLEXGEN("ck_flexgen_08", 8),
+	CS_FLEXGEN("ck_flexgen_09", 9),
+	CS_FLEXGEN("ck_flexgen_10", 10),
+	CS_FLEXGEN("ck_flexgen_11", 11),
+	CS_FLEXGEN("ck_flexgen_12", 12),
+	CS_FLEXGEN("ck_flexgen_13", 13),
+	CS_FLEXGEN("ck_flexgen_14", 14),
+	CS_FLEXGEN("ck_flexgen_15", 15),
+	CS_FLEXGEN("ck_flexgen_16", 16),
+	CS_FLEXGEN("ck_flexgen_17", 17),
+	CS_FLEXGEN("ck_flexgen_18", 18),
+	CS_FLEXGEN("ck_flexgen_19", 19),
+	CS_FLEXGEN("ck_flexgen_20", 20),
+	CS_FLEXGEN("ck_flexgen_21", 21),
+	CS_FLEXGEN("ck_flexgen_22", 22),
+	CS_FLEXGEN("ck_flexgen_23", 23),
+	CS_FLEXGEN("ck_flexgen_24", 24),
+	CS_FLEXGEN("ck_flexgen_25", 25),
+	CS_FLEXGEN("ck_flexgen_26", 26),
+	CS_FLEXGEN("ck_flexgen_27", 27),
+	CS_FLEXGEN("ck_flexgen_28", 28),
+	CS_FLEXGEN("ck_flexgen_29", 29),
+	CS_FLEXGEN("ck_flexgen_30", 30),
+	CS_FLEXGEN("ck_flexgen_31", 31),
+	CS_FLEXGEN("ck_flexgen_32", 32),
+	CS_FLEXGEN("ck_flexgen_33", 33),
+	CS_FLEXGEN("ck_flexgen_34", 34),
+	CS_FLEXGEN("ck_flexgen_35", 35),
+	CS_FLEXGEN("ck_flexgen_36", 36),
+	CS_FLEXGEN("ck_flexgen_37", 37),
+	CS_FLEXGEN("ck_flexgen_38", 38),
+	CS_FLEXGEN("ck_flexgen_39", 39),
+	CS_FLEXGEN("ck_flexgen_40", 40),
+	CS_FLEXGEN("ck_flexgen_41", 41),
+	CS_FLEXGEN("ck_flexgen_42", 42),
+	CS_FLEXGEN("ck_flexgen_43", 43),
+	CS_FLEXGEN("ck_flexgen_44", 44),
+	CS_FLEXGEN("ck_flexgen_45", 45),
+	CS_FLEXGEN("ck_flexgen_46", 46),
+	CS_FLEXGEN("ck_flexgen_47", 47),
+	CS_FLEXGEN("ck_flexgen_48", 48),
+	CS_FLEXGEN("ck_flexgen_49", 49),
+	CS_FLEXGEN("ck_flexgen_50", 50),
+	CS_FLEXGEN("ck_flexgen_51", 51),
+	CS_FLEXGEN("ck_flexgen_52", 52),
+	CS_FLEXGEN("ck_flexgen_53", 53),
+	CS_FLEXGEN("ck_flexgen_54", 54),
+	CS_FLEXGEN("ck_flexgen_55", 55),
+	CS_FLEXGEN("ck_flexgen_56", 56),
+	CS_FLEXGEN("ck_flexgen_57", 57),
+	CS_FLEXGEN("ck_flexgen_58", 58),
+	CS_FLEXGEN("ck_flexgen_59", 59),
+	CS_FLEXGEN("ck_flexgen_60", 60),
+	CS_FLEXGEN("ck_flexgen_61", 61),
+	CS_FLEXGEN("ck_flexgen_62", 62),
+	CS_FLEXGEN("ck_flexgen_63", 63),
+
+	CS_DIV("ck_icn_apb1", "ck_icn_ls_mcu", DIV_APB1),
+	CS_DIV("ck_icn_apb2", "ck_icn_ls_mcu", DIV_APB2),
+	CS_DIV("ck_icn_apb3", "ck_icn_ls_mcu", DIV_APB3),
+	CS_DIV("ck_icn_apb4", "ck_icn_ls_mcu", DIV_APB4),
+	CS_GATEDIV("ck_icn_apbdbg", "ck_icn_ls_mcu", GATE_DBG, DIV_APBDBG),
+
+	CS_STM32_TIMER("ck_timg1", "ck_icn_apb1", RCC_APB1DIVR, RCC_TIMG1PRER),
+	CS_STM32_TIMER("ck_timg2", "ck_icn_apb2", RCC_APB2DIVR, RCC_TIMG2PRER),
+
+	CS_GATE("ck_icn_s_sysram", "ck_icn_hs_mcu", GATE_SYSRAM),
+	CS_GATE("ck_icn_s_vderam", "ck_icn_hs_mcu", GATE_VDERAM),
+	CS_GATE("ck_icn_s_retram", "ck_icn_hs_mcu", GATE_RETRAM),
+	CS_GATE("ck_icn_s_sram1", "ck_icn_hs_mcu", GATE_SRAM1),
+	CS_GATE("ck_icn_s_sram2", "ck_icn_hs_mcu", GATE_SRAM2),
+	CS_GATE("ck_icn_s_ospi1", "ck_icn_hs_mcu", GATE_OSPI1),
+	CS_GATE("ck_icn_s_ospi2", "ck_icn_hs_mcu", GATE_OSPI2),
+	CS_GATE("ck_icn_p_otfd1", "ck_icn_hs_mcu", GATE_OSPI1),
+	CS_GATE("ck_icn_p_otfd2", "ck_icn_hs_mcu", GATE_OSPI2),
+	CS_GATE("ck_icn_s_bkpsram", "ck_icn_ls_mcu", GATE_BKPSRAM),
+	CS_GATE("ck_icn_p_ddrphyc", "ck_icn_ls_mcu", GATE_DDRPHYCAPB),
+	CS_GATE("ck_icn_p_syscpu1", "ck_icn_ls_mcu", GATE_SYSCPU1),
+	CS_GATE("ck_icn_p_hpdma1", "ck_icn_ls_mcu", GATE_HPDMA1),
+	CS_GATE("ck_icn_p_hpdma2", "ck_icn_ls_mcu", GATE_HPDMA2),
+	CS_GATE("ck_icn_p_hpdma3", "ck_icn_ls_mcu", GATE_HPDMA3),
+	CS_GATE("ck_icn_p_ipcc1", "ck_icn_ls_mcu", GATE_IPCC1),
+	CS_GATE("ck_icn_p_ipcc2", "ck_icn_ls_mcu", GATE_IPCC2),
+	CS_GATE("ck_icn_p_cci", "ck_icn_ls_mcu", GATE_CCI),
+	CS_GATE("ck_icn_p_crc", "ck_icn_ls_mcu", GATE_CRC),
+	CS_GATE("ck_icn_p_ospiiom", "ck_icn_ls_mcu", GATE_OSPIIOM),
+	CS_GATE("ck_icn_p_hash", "ck_icn_ls_mcu", GATE_HASH),
+	CS_GATE("ck_icn_p_rng", "ck_icn_ls_mcu", GATE_RNG),
+	CS_GATE("ck_icn_p_cryp1", "ck_icn_ls_mcu", GATE_CRYP1),
+	CS_GATE("ck_icn_p_cryp2", "ck_icn_ls_mcu", GATE_CRYP2),
+	CS_GATE("ck_icn_p_saes", "ck_icn_ls_mcu", GATE_SAES),
+	CS_GATE("ck_icn_p_pka", "ck_icn_ls_mcu", GATE_PKA),
+	CS_GATE("ck_icn_p_gpioa", "ck_icn_ls_mcu", GATE_GPIOA),
+	CS_GATE("ck_icn_p_gpiob", "ck_icn_ls_mcu", GATE_GPIOB),
+	CS_GATE("ck_icn_p_gpioc", "ck_icn_ls_mcu", GATE_GPIOC),
+	CS_GATE("ck_icn_p_gpiod", "ck_icn_ls_mcu", GATE_GPIOD),
+	CS_GATE("ck_icn_p_gpioe", "ck_icn_ls_mcu", GATE_GPIOE),
+	CS_GATE("ck_icn_p_gpiof", "ck_icn_ls_mcu", GATE_GPIOF),
+	CS_GATE("ck_icn_p_gpiog", "ck_icn_ls_mcu", GATE_GPIOG),
+	CS_GATE("ck_icn_p_gpioh", "ck_icn_ls_mcu", GATE_GPIOH),
+	CS_GATE("ck_icn_p_gpioi", "ck_icn_ls_mcu", GATE_GPIOI),
+	CS_GATE("ck_icn_p_gpioj", "ck_icn_ls_mcu", GATE_GPIOJ),
+	CS_GATE("ck_icn_p_gpiok", "ck_icn_ls_mcu", GATE_GPIOK),
+	CS_GATE("ck_icn_s_lpsram1", "ck_icn_ls_mcu", GATE_LPSRAM1),
+	CS_GATE("ck_icn_s_lpsram2", "ck_icn_ls_mcu", GATE_LPSRAM2),
+	CS_GATE("ck_icn_s_lpsram3", "ck_icn_ls_mcu", GATE_LPSRAM3),
+	CS_GATE("ck_icn_p_gpioz", "ck_icn_ls_mcu", GATE_GPIOZ),
+	CS_GATE("ck_icn_p_lpdma", "ck_icn_ls_mcu", GATE_LPDMA),
+	CS_GATE("ck_icn_p_adf1", "ck_icn_ls_mcu", GATE_ADF1),
+	CS_GATE("ck_icn_p_hsem", "ck_icn_ls_mcu", GATE_HSEM),
+	CS_GATE("ck_icn_p_rtc", "ck_icn_ls_mcu", GATE_RTC),
+	CS_GATE("ck_icn_p_iwdg5", "ck_icn_ls_mcu", GATE_IWDG5),
+	CS_GATE("ck_icn_p_wwdg2", "ck_icn_ls_mcu", GATE_WWDG2),
+	CS_GATE("ck_icn_s_stm", "ck_icn_ls_mcu", GATE_STM),
+	CS_GATE("ck_icn_p_fmc", "ck_icn_ls_mcu", GATE_FMC),
+	CS_GATE("ck_icn_p_eth1", "ck_icn_ls_mcu", GATE_ETH1),
+	CS_GATE("ck_icn_p_ethsw", "ck_icn_ls_mcu", GATE_ETHSWMAC),
+	CS_GATE("ck_icn_p_eth2", "ck_icn_ls_mcu", GATE_ETH2),
+	CS_GATE("ck_icn_p_pcie", "ck_icn_ls_mcu", GATE_PCIE),
+	CS_GATE("ck_icn_p_adc12", "ck_icn_ls_mcu", GATE_ADC12),
+	CS_GATE("ck_icn_p_adc3", "ck_icn_ls_mcu", GATE_ADC3),
+	CS_GATE("ck_icn_p_mdf1", "ck_icn_ls_mcu", GATE_MDF1),
+	CS_GATE("ck_icn_p_spi8", "ck_icn_ls_mcu", GATE_SPI8),
+	CS_GATE("ck_icn_p_lpuart1", "ck_icn_ls_mcu", GATE_LPUART1),
+	CS_GATE("ck_icn_p_i2c8", "ck_icn_ls_mcu", GATE_I2C8),
+	CS_GATE("ck_icn_p_lptim3", "ck_icn_ls_mcu", GATE_LPTIM3),
+	CS_GATE("ck_icn_p_lptim4", "ck_icn_ls_mcu", GATE_LPTIM4),
+	CS_GATE("ck_icn_p_lptim5", "ck_icn_ls_mcu", GATE_LPTIM5),
+	CS_GATE("ck_icn_p_risaf4", "ck_icn_ls_mcu", GATE_DDRCP),
+	CS_GATE("ck_icn_m_sdmmc1", "ck_icn_sdmmc", GATE_SDMMC1),
+	CS_GATE("ck_icn_m_sdmmc2", "ck_icn_sdmmc", GATE_SDMMC2),
+	CS_GATE("ck_icn_m_sdmmc3", "ck_icn_sdmmc", GATE_SDMMC3),
+	CS_GATE("ck_icn_s_ddr", "ck_icn_ddr", GATE_DDRCP),
+	CS_GATE("ck_icn_m_usb2ohci", "ck_icn_hsl", GATE_USB2),
+	CS_GATE("ck_icn_m_usb2ehci", "ck_icn_hsl", GATE_USB2),
+	CS_GATE("ck_icn_m_usb3dr", "ck_icn_hsl", GATE_USB3DR),
+	CS_GATE("ck_icn_p_tim2", "ck_icn_apb1", GATE_TIM2),
+	CS_GATE("ck_icn_p_tim3", "ck_icn_apb1", GATE_TIM3),
+	CS_GATE("ck_icn_p_tim4", "ck_icn_apb1", GATE_TIM4),
+	CS_GATE("ck_icn_p_tim5", "ck_icn_apb1", GATE_TIM5),
+	CS_GATE("ck_icn_p_tim6", "ck_icn_apb1", GATE_TIM6),
+	CS_GATE("ck_icn_p_tim7", "ck_icn_apb1", GATE_TIM7),
+	CS_GATE("ck_icn_p_tim10", "ck_icn_apb1", GATE_TIM10),
+	CS_GATE("ck_icn_p_tim11", "ck_icn_apb1", GATE_TIM11),
+	CS_GATE("ck_icn_p_tim12", "ck_icn_apb1", GATE_TIM12),
+	CS_GATE("ck_icn_p_tim13", "ck_icn_apb1", GATE_TIM13),
+	CS_GATE("ck_icn_p_tim14", "ck_icn_apb1", GATE_TIM14),
+	CS_GATE("ck_icn_p_lptim1", "ck_icn_apb1", GATE_LPTIM1),
+	CS_GATE("ck_icn_p_lptim2", "ck_icn_apb1", GATE_LPTIM2),
+	CS_GATE("ck_icn_p_spi2", "ck_icn_apb1", GATE_SPI2),
+	CS_GATE("ck_icn_p_spi3", "ck_icn_apb1", GATE_SPI3),
+	CS_GATE("ck_icn_p_spdifrx", "ck_icn_apb1", GATE_SPDIFRX),
+	CS_GATE("ck_icn_p_usart2", "ck_icn_apb1", GATE_USART2),
+	CS_GATE("ck_icn_p_usart3", "ck_icn_apb1", GATE_USART3),
+	CS_GATE("ck_icn_p_uart4", "ck_icn_apb1", GATE_UART4),
+	CS_GATE("ck_icn_p_uart5", "ck_icn_apb1", GATE_UART5),
+	CS_GATE("ck_icn_p_i2c1", "ck_icn_apb1", GATE_I2C1),
+	CS_GATE("ck_icn_p_i2c2", "ck_icn_apb1", GATE_I2C2),
+	CS_GATE("ck_icn_p_i2c3", "ck_icn_apb1", GATE_I2C3),
+	CS_GATE("ck_icn_p_i2c4", "ck_icn_apb1", GATE_I2C4),
+	CS_GATE("ck_icn_p_i2c5", "ck_icn_apb1", GATE_I2C5),
+	CS_GATE("ck_icn_p_i2c6", "ck_icn_apb1", GATE_I2C6),
+	CS_GATE("ck_icn_p_i2c7", "ck_icn_apb1", GATE_I2C7),
+	CS_GATE("ck_icn_p_i3c1", "ck_icn_apb1", GATE_I3C1),
+	CS_GATE("ck_icn_p_i3c2", "ck_icn_apb1", GATE_I3C2),
+	CS_GATE("ck_icn_p_i3c3", "ck_icn_apb1", GATE_I3C3),
+	CS_GATE("ck_icn_p_i3c4", "ck_icn_ls_mcu", GATE_I3C4),
+	CS_GATE("ck_icn_p_tim1", "ck_icn_apb2", GATE_TIM1),
+	CS_GATE("ck_icn_p_tim8", "ck_icn_apb2", GATE_TIM8),
+	CS_GATE("ck_icn_p_tim15", "ck_icn_apb2", GATE_TIM15),
+	CS_GATE("ck_icn_p_tim16", "ck_icn_apb2", GATE_TIM16),
+	CS_GATE("ck_icn_p_tim17", "ck_icn_apb2", GATE_TIM17),
+	CS_GATE("ck_icn_p_tim20", "ck_icn_apb2", GATE_TIM20),
+	CS_GATE("ck_icn_p_sai1", "ck_icn_apb2", GATE_SAI1),
+	CS_GATE("ck_icn_p_sai2", "ck_icn_apb2", GATE_SAI2),
+	CS_GATE("ck_icn_p_sai3", "ck_icn_apb2", GATE_SAI3),
+	CS_GATE("ck_icn_p_sai4", "ck_icn_apb2", GATE_SAI4),
+	CS_GATE("ck_icn_p_usart1", "ck_icn_apb2", GATE_USART1),
+	CS_GATE("ck_icn_p_usart6", "ck_icn_apb2", GATE_USART6),
+	CS_GATE("ck_icn_p_uart7", "ck_icn_apb2", GATE_UART7),
+	CS_GATE("ck_icn_p_uart8", "ck_icn_apb2", GATE_UART8),
+	CS_GATE("ck_icn_p_uart9", "ck_icn_apb2", GATE_UART9),
+	CS_GATE("ck_icn_p_fdcan", "ck_icn_apb2", GATE_FDCAN),
+	CS_GATE("ck_icn_p_spi1", "ck_icn_apb2", GATE_SPI1),
+	CS_GATE("ck_icn_p_spi4", "ck_icn_apb2", GATE_SPI4),
+	CS_GATE("ck_icn_p_spi5", "ck_icn_apb2", GATE_SPI5),
+	CS_GATE("ck_icn_p_spi6", "ck_icn_apb2", GATE_SPI6),
+	CS_GATE("ck_icn_p_spi7", "ck_icn_apb2", GATE_SPI7),
+	CS_GATE("ck_icn_p_bsec", "ck_icn_apb3", GATE_BSEC),
+	CS_GATE("ck_icn_p_iwdg1", "ck_icn_apb3", GATE_IWDG1),
+	CS_GATE("ck_icn_p_iwdg2", "ck_icn_apb3", GATE_IWDG2),
+	CS_GATE("ck_icn_p_iwdg3", "ck_icn_apb3", GATE_IWDG3),
+	CS_GATE("ck_icn_p_iwdg4", "ck_icn_apb3", GATE_IWDG4),
+	CS_GATE("ck_icn_p_wwdg1", "ck_icn_apb3", GATE_WWDG1),
+	CS_GATE("ck_icn_p_vref", "ck_icn_apb3", GATE_VREF),
+	CS_GATE("ck_icn_p_dts", "ck_icn_apb3", GATE_DTS),
+	CS_GATE("ck_icn_p_serc", "ck_icn_apb3", GATE_SERC),
+	CS_GATE("ck_icn_p_hdp", "ck_icn_apb3", GATE_HDP),
+	CS_GATE("ck_icn_p_is2m", "ck_icn_apb3", GATE_IS2M),
+	CS_GATE("ck_icn_p_dsi", "ck_icn_apb4", GATE_DSI),
+	CS_GATE("ck_icn_p_ltdc", "ck_icn_apb4", GATE_LTDC),
+	CS_GATE("ck_icn_p_csi2", "ck_icn_apb4", GATE_CSI),
+	CS_GATE("ck_icn_p_dcmipp", "ck_icn_apb4", GATE_DCMIPP),
+	CS_GATE("ck_icn_p_ddrc", "ck_icn_apb4", GATE_DDRCAPB),
+	CS_GATE("ck_icn_p_ddrcfg", "ck_icn_apb4", GATE_DDRCFG),
+	CS_GATE("ck_icn_p_lvds", "ck_icn_apb4", GATE_LVDS),
+	CS_GATE("ck_icn_p_gicv2m", "ck_icn_apb4", GATE_GICV2M),
+	CS_GATE("ck_icn_p_usbtc", "ck_icn_apb4", GATE_USBTC),
+	CS_GATE("ck_icn_p_usb3pciephy", "ck_icn_apb4", GATE_USB3PCIEPHY),
+	CS_GATE("ck_icn_p_stgen", "ck_icn_apb4", GATE_STGEN),
+	CS_GATE("ck_icn_p_vdec", "ck_icn_apb4", GATE_VDEC),
+	CS_GATE("ck_icn_p_venc", "ck_icn_apb4", GATE_VENC),
+	CS_GATE("ck_sys_dbg", "ck_icn_apbdbg", GATE_DBG),
+	CS_GATE("ck_icn_p_stm", "ck_icn_apbdbg", GATE_STM),
+	CS_GATE("ck_icn_p_etr", "ck_icn_apbdbg", GATE_ETR),
+	CS_GATE("ck_ker_tim2", "ck_timg1", GATE_TIM2),
+	CS_GATE("ck_ker_tim3", "ck_timg1", GATE_TIM3),
+	CS_GATE("ck_ker_tim4", "ck_timg1", GATE_TIM4),
+	CS_GATE("ck_ker_tim5", "ck_timg1", GATE_TIM5),
+	CS_GATE("ck_ker_tim6", "ck_timg1", GATE_TIM6),
+	CS_GATE("ck_ker_tim7", "ck_timg1", GATE_TIM7),
+	CS_GATE("ck_ker_tim10", "ck_timg1", GATE_TIM10),
+	CS_GATE("ck_ker_tim11", "ck_timg1", GATE_TIM11),
+	CS_GATE("ck_ker_tim12", "ck_timg1", GATE_TIM12),
+	CS_GATE("ck_ker_tim13", "ck_timg1", GATE_TIM13),
+	CS_GATE("ck_ker_tim14", "ck_timg1", GATE_TIM14),
+	CS_GATE("ck_ker_tim1", "ck_timg2", GATE_TIM1),
+	CS_GATE("ck_ker_tim8", "ck_timg2", GATE_TIM8),
+	CS_GATE("ck_ker_tim15", "ck_timg2", GATE_TIM15),
+	CS_GATE("ck_ker_tim16", "ck_timg2", GATE_TIM16),
+	CS_GATE("ck_ker_tim17", "ck_timg2", GATE_TIM17),
+	CS_GATE("ck_ker_tim20", "ck_timg2", GATE_TIM20),
+	CS_GATE("ck_ker_lptim1", "ck_flexgen_07", GATE_LPTIM1),
+	CS_GATE("ck_ker_lptim2", "ck_flexgen_07", GATE_LPTIM2),
+	CS_GATE("ck_ker_usart2", "ck_flexgen_08", GATE_USART2),
+	CS_GATE("ck_ker_uart4", "ck_flexgen_08", GATE_UART4),
+	CS_GATE("ck_ker_usart3", "ck_flexgen_09", GATE_USART3),
+	CS_GATE("ck_ker_uart5", "ck_flexgen_09", GATE_UART5),
+	CS_GATE("ck_ker_spi2", "ck_flexgen_10", GATE_SPI2),
+	CS_GATE("ck_ker_spi3", "ck_flexgen_10", GATE_SPI3),
+	CS_GATE("ck_ker_spdifrx", "ck_flexgen_11", GATE_SPDIFRX),
+	CS_GATE("ck_ker_i2c1", "ck_flexgen_12", GATE_I2C1),
+	CS_GATE("ck_ker_i2c2", "ck_flexgen_12", GATE_I2C2),
+	CS_GATE("ck_ker_i3c1", "ck_flexgen_12", GATE_I3C1),
+	CS_GATE("ck_ker_i3c2", "ck_flexgen_12", GATE_I3C2),
+	CS_GATE("ck_ker_i2c3", "ck_flexgen_13", GATE_I2C3),
+	CS_GATE("ck_ker_i2c5", "ck_flexgen_13", GATE_I2C5),
+	CS_GATE("ck_ker_i3c3", "ck_flexgen_13", GATE_I3C3),
+	CS_GATE("ck_ker_i2c4", "ck_flexgen_14", GATE_I2C4),
+	CS_GATE("ck_ker_i2c6", "ck_flexgen_14", GATE_I2C6),
+	CS_GATE("ck_ker_i2c7", "ck_flexgen_15", GATE_I2C7),
+	CS_GATE("ck_ker_spi1", "ck_flexgen_16", GATE_SPI1),
+	CS_GATE("ck_ker_spi4", "ck_flexgen_17", GATE_SPI4),
+	CS_GATE("ck_ker_spi5", "ck_flexgen_17", GATE_SPI5),
+	CS_GATE("ck_ker_spi6", "ck_flexgen_18", GATE_SPI6),
+	CS_GATE("ck_ker_spi7", "ck_flexgen_18", GATE_SPI7),
+	CS_GATE("ck_ker_usart1", "ck_flexgen_19", GATE_USART1),
+	CS_GATE("ck_ker_usart6", "ck_flexgen_20", GATE_USART6),
+	CS_GATE("ck_ker_uart7", "ck_flexgen_21", GATE_UART7),
+	CS_GATE("ck_ker_uart8", "ck_flexgen_21", GATE_UART8),
+	CS_GATE("ck_ker_uart9", "ck_flexgen_22", GATE_UART9),
+	CS_GATE("ck_ker_mdf1", "ck_flexgen_23", GATE_MDF1),
+	CS_GATE("ck_ker_sai1", "ck_flexgen_23", GATE_SAI1),
+	CS_GATE("ck_ker_sai2", "ck_flexgen_24", GATE_SAI2),
+	CS_GATE("ck_ker_sai3", "ck_flexgen_25", GATE_SAI3),
+	CS_GATE("ck_ker_sai4", "ck_flexgen_25", GATE_SAI4),
+	CS_GATE("ck_ker_fdcan", "ck_flexgen_26", GATE_FDCAN),
+	CS_GATE("ck_ker_csi2", "ck_flexgen_29", GATE_CSI),
+	CS_GATE("ck_ker_csi2txesc", "ck_flexgen_30", GATE_CSI),
+	CS_GATE("ck_ker_csi2phy", "ck_flexgen_31", GATE_CSI),
+	CS_GATE("ck_ker_stgen", "ck_flexgen_33", GATE_STGEN),
+	CS_GATE("ck_ker_usbtc", "ck_flexgen_35", GATE_USBTC),
+	CS_GATE("ck_ker_i3c4", "ck_flexgen_36", GATE_I3C4),
+	CS_GATE("ck_ker_spi8", "ck_flexgen_37", GATE_SPI8),
+	CS_GATE("ck_ker_i2c8", "ck_flexgen_38", GATE_I2C8),
+	CS_GATE("ck_ker_lpuart1", "ck_flexgen_39", GATE_LPUART1),
+	CS_GATE("ck_ker_lptim3", "ck_flexgen_40", GATE_LPTIM3),
+	CS_GATE("ck_ker_lptim4", "ck_flexgen_41", GATE_LPTIM4),
+	CS_GATE("ck_ker_lptim5", "ck_flexgen_41", GATE_LPTIM5),
+	CS_GATE("ck_ker_adf1", "ck_flexgen_42", GATE_ADF1),
+	CS_GATE("ck_ker_tsdbg", "ck_flexgen_43", GATE_DBG),
+	CS_GATE("ck_ker_tpiu", "ck_flexgen_44", GATE_TRACE),
+	CS_GATE("ck_icn_m_etr", "ck_flexgen_45", GATE_ETR),
+	CS_GATE("ck_sys_atb", "ck_flexgen_45", GATE_DBG),
+	CS_GATE("ck_ker_ospi1", "ck_flexgen_48", GATE_OSPI1),
+	CS_GATE("ck_ker_ospi2", "ck_flexgen_49", GATE_OSPI2),
+	CS_GATE("ck_ker_fmc", "ck_flexgen_50", GATE_FMC),
+	CS_GATE("ck_ker_sdmmc1", "ck_flexgen_51", GATE_SDMMC1),
+	CS_GATE("ck_ker_sdmmc2", "ck_flexgen_52", GATE_SDMMC2),
+	CS_GATE("ck_ker_sdmmc3", "ck_flexgen_53", GATE_SDMMC3),
+	CS_GATE("ck_ker_eth1", "ck_flexgen_54", GATE_ETH1),
+	CS_GATE("ck_ker_ethsw", "ck_flexgen_54", GATE_ETHSW),
+	CS_GATE("ck_ker_eth2", "ck_flexgen_55", GATE_ETH2),
+	CS_GATE("ck_ker_eth1ptp", "ck_flexgen_56", GATE_ETH1),
+	CS_GATE("ck_ker_eth2ptp", "ck_flexgen_56", GATE_ETH2),
+	CS_GATE("ck_ker_usb2phy2", "ck_flexgen_58", GATE_USB3DR),
+	CS_GATE("ck_icn_m_gpu", "ck_flexgen_59", GATE_GPU),
+	CS_GATE("ck_ker_gpu", "ck_pll3", GATE_GPU),
+	CS_GATE("ck_ker_ethswref", "ck_flexgen_60", GATE_ETHSWREF),
+	CS_GATE("ck_ker_eth1stp", "ck_icn_ls_mcu", GATE_ETH1STP),
+	CS_GATE("ck_ker_eth2stp", "ck_icn_ls_mcu", GATE_ETH2STP),
+	CS_GATE("ck_ker_ltdc", "ck_flexgen_27", GATE_LTDC),
+
+	CS_GATEMUX("ck_mco1", mco1_src, GATE_MCO1, MUX_MCO1),
+	CS_GATEMUX("ck_mco2", mco2_src, GATE_MCO2, MUX_MCO2),
+	CS_GATEMUX("ck_ker_adc12", adc12_src, GATE_ADC12, MUX_ADC12),
+	CS_GATEMUX("ck_ker_adc3", adc3_src, GATE_ADC3, MUX_ADC3),
+	CS_GATEMUX("ck_ker_usb2phy1", usb2phy1_src, GATE_USB2PHY1, MUX_USB2PHY1),
+	CS_GATEMUX("ck_ker_usb2phy2_en", usb2phy2_src, GATE_USB2PHY2, MUX_USB2PHY2),
+	CS_GATEMUX("ck_ker_usb3pciephy", usb3pciphy_src, GATE_USB3PCIEPHY, MUX_USB3PCIEPHY),
+	CS_GATEMUX("clk_lanebyte", dsiblane_src, GATE_DSI, MUX_DSIBLANE),
+	CS_GATEMUX("clk_phy_dsi", dsiphy_src, GATE_DSI, MUX_DSIPHY),
+	CS_GATEMUX("ck_ker_lvdsphy", lvdsphy_src, GATE_LVDS, MUX_LVDSPHY),
+	CS_GATEMUX("ck_ker_dts", dts_src, GATE_DTS, MUX_DTS),
+	CS_GATEMUX("ck_rtc", rtc_src, GATE_RTCCK, MUX_RTC),
+};
+
+static struct clock_summary clock_summary_mp25 = {
+	.clocks		= stm32mp25_clock_summary,
+	.nb_clocks	= ARRAY_SIZE(stm32mp25_clock_summary),
+};
+
+#endif
diff --git a/drivers/clk/stm32/reset-stm32.c b/drivers/clk/stm32/reset-stm32.c
index e89381528..76288f71f 100644
--- a/drivers/clk/stm32/reset-stm32.c
+++ b/drivers/clk/stm32/reset-stm32.c
@@ -21,6 +21,7 @@ struct stm32_reset_data {
 	struct reset_controller_dev	rcdev;
 	void __iomem			*membase;
 	u32				clear_offset;
+	unsigned int			reset_us;
 };
 
 static inline struct stm32_reset_data *
@@ -93,9 +94,46 @@ static int stm32_reset_status(struct reset_controller_dev *rcdev,
 	return !!(reg & BIT(offset));
 }
 
+static int stm32_check_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int reg_width = sizeof(u32);
+	int bank = id / (reg_width * BITS_PER_BYTE);
+	int offset = id % (reg_width * BITS_PER_BYTE);
+	u32 reg;
+
+	return readl_poll_timeout(data->membase + (bank * reg_width), reg,
+				  !(reg & BIT(offset)), 10, 10 * USEC_PER_MSEC);
+}
+
+static int stm32_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct stm32_reset_data *data = to_stm32_reset_data(rcdev);
+	int ret;
+
+	ret = stm32_reset_assert(rcdev, id);
+	if (ret)
+		return ret;
+
+	if (!data->reset_us)
+		usleep_range(data->reset_us, data->reset_us * 2);
+
+	ret = stm32_reset_deassert(rcdev, id);
+	if (ret)
+		return ret;
+
+	ret = stm32_check_deassert(rcdev, id);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static const struct reset_control_ops stm32_reset_ops = {
 	.assert		= stm32_reset_assert,
 	.deassert	= stm32_reset_deassert,
+	.reset		= stm32_reset,
 	.status		= stm32_reset_status,
 };
 
@@ -118,6 +156,7 @@ int stm32_rcc_reset_init(struct device *dev, const struct of_device_id *match,
 	reset_data->rcdev.of_node = dev_of_node(dev);
 	reset_data->rcdev.nr_resets = STM32_RESET_ID_MASK;
 	reset_data->clear_offset = data->clear_offset;
+	reset_data->reset_us = data->reset_us;
 
 	return reset_controller_register(&reset_data->rcdev);
 }
diff --git a/drivers/clk/stm32/stm32mp25_rcc.h b/drivers/clk/stm32/stm32mp25_rcc.h
new file mode 100644
index 000000000..0e223ee55
--- /dev/null
+++ b/drivers/clk/stm32/stm32mp25_rcc.h
@@ -0,0 +1,4977 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef STM32MP25_RCC_H
+#define STM32MP25_RCC_H
+
+#define RCC_SECCFGR0				0x0
+#define RCC_SECCFGR1				0x4
+#define RCC_SECCFGR2				0x8
+#define RCC_SECCFGR3				0xC
+#define RCC_PRIVCFGR0				0x10
+#define RCC_PRIVCFGR1				0x14
+#define RCC_PRIVCFGR2				0x18
+#define RCC_PRIVCFGR3				0x1C
+#define RCC_RCFGLOCKR0				0x20
+#define RCC_RCFGLOCKR1				0x24
+#define RCC_RCFGLOCKR2				0x28
+#define RCC_RCFGLOCKR3				0x2C
+#define RCC_R0CIDCFGR				0x30
+#define RCC_R0SEMCR				0x34
+#define RCC_R1CIDCFGR				0x38
+#define RCC_R1SEMCR				0x3C
+#define RCC_R2CIDCFGR				0x40
+#define RCC_R2SEMCR				0x44
+#define RCC_R3CIDCFGR				0x48
+#define RCC_R3SEMCR				0x4C
+#define RCC_R4CIDCFGR				0x50
+#define RCC_R4SEMCR				0x54
+#define RCC_R5CIDCFGR				0x58
+#define RCC_R5SEMCR				0x5C
+#define RCC_R6CIDCFGR				0x60
+#define RCC_R6SEMCR				0x64
+#define RCC_R7CIDCFGR				0x68
+#define RCC_R7SEMCR				0x6C
+#define RCC_R8CIDCFGR				0x70
+#define RCC_R8SEMCR				0x74
+#define RCC_R9CIDCFGR				0x78
+#define RCC_R9SEMCR				0x7C
+#define RCC_R10CIDCFGR				0x80
+#define RCC_R10SEMCR				0x84
+#define RCC_R11CIDCFGR				0x88
+#define RCC_R11SEMCR				0x8C
+#define RCC_R12CIDCFGR				0x90
+#define RCC_R12SEMCR				0x94
+#define RCC_R13CIDCFGR				0x98
+#define RCC_R13SEMCR				0x9C
+#define RCC_R14CIDCFGR				0xA0
+#define RCC_R14SEMCR				0xA4
+#define RCC_R15CIDCFGR				0xA8
+#define RCC_R15SEMCR				0xAC
+#define RCC_R16CIDCFGR				0xB0
+#define RCC_R16SEMCR				0xB4
+#define RCC_R17CIDCFGR				0xB8
+#define RCC_R17SEMCR				0xBC
+#define RCC_R18CIDCFGR				0xC0
+#define RCC_R18SEMCR				0xC4
+#define RCC_R19CIDCFGR				0xC8
+#define RCC_R19SEMCR				0xCC
+#define RCC_R20CIDCFGR				0xD0
+#define RCC_R20SEMCR				0xD4
+#define RCC_R21CIDCFGR				0xD8
+#define RCC_R21SEMCR				0xDC
+#define RCC_R22CIDCFGR				0xE0
+#define RCC_R22SEMCR				0xE4
+#define RCC_R23CIDCFGR				0xE8
+#define RCC_R23SEMCR				0xEC
+#define RCC_R24CIDCFGR				0xF0
+#define RCC_R24SEMCR				0xF4
+#define RCC_R25CIDCFGR				0xF8
+#define RCC_R25SEMCR				0xFC
+#define RCC_R26CIDCFGR				0x100
+#define RCC_R26SEMCR				0x104
+#define RCC_R27CIDCFGR				0x108
+#define RCC_R27SEMCR				0x10C
+#define RCC_R28CIDCFGR				0x110
+#define RCC_R28SEMCR				0x114
+#define RCC_R29CIDCFGR				0x118
+#define RCC_R29SEMCR				0x11C
+#define RCC_R30CIDCFGR				0x120
+#define RCC_R30SEMCR				0x124
+#define RCC_R31CIDCFGR				0x128
+#define RCC_R31SEMCR				0x12C
+#define RCC_R32CIDCFGR				0x130
+#define RCC_R32SEMCR				0x134
+#define RCC_R33CIDCFGR				0x138
+#define RCC_R33SEMCR				0x13C
+#define RCC_R34CIDCFGR				0x140
+#define RCC_R34SEMCR				0x144
+#define RCC_R35CIDCFGR				0x148
+#define RCC_R35SEMCR				0x14C
+#define RCC_R36CIDCFGR				0x150
+#define RCC_R36SEMCR				0x154
+#define RCC_R37CIDCFGR				0x158
+#define RCC_R37SEMCR				0x15C
+#define RCC_R38CIDCFGR				0x160
+#define RCC_R38SEMCR				0x164
+#define RCC_R39CIDCFGR				0x168
+#define RCC_R39SEMCR				0x16C
+#define RCC_R40CIDCFGR				0x170
+#define RCC_R40SEMCR				0x174
+#define RCC_R41CIDCFGR				0x178
+#define RCC_R41SEMCR				0x17C
+#define RCC_R42CIDCFGR				0x180
+#define RCC_R42SEMCR				0x184
+#define RCC_R43CIDCFGR				0x188
+#define RCC_R43SEMCR				0x18C
+#define RCC_R44CIDCFGR				0x190
+#define RCC_R44SEMCR				0x194
+#define RCC_R45CIDCFGR				0x198
+#define RCC_R45SEMCR				0x19C
+#define RCC_R46CIDCFGR				0x1A0
+#define RCC_R46SEMCR				0x1A4
+#define RCC_R47CIDCFGR				0x1A8
+#define RCC_R47SEMCR				0x1AC
+#define RCC_R48CIDCFGR				0x1B0
+#define RCC_R48SEMCR				0x1B4
+#define RCC_R49CIDCFGR				0x1B8
+#define RCC_R49SEMCR				0x1BC
+#define RCC_R50CIDCFGR				0x1C0
+#define RCC_R50SEMCR				0x1C4
+#define RCC_R51CIDCFGR				0x1C8
+#define RCC_R51SEMCR				0x1CC
+#define RCC_R52CIDCFGR				0x1D0
+#define RCC_R52SEMCR				0x1D4
+#define RCC_R53CIDCFGR				0x1D8
+#define RCC_R53SEMCR				0x1DC
+#define RCC_R54CIDCFGR				0x1E0
+#define RCC_R54SEMCR				0x1E4
+#define RCC_R55CIDCFGR				0x1E8
+#define RCC_R55SEMCR				0x1EC
+#define RCC_R56CIDCFGR				0x1F0
+#define RCC_R56SEMCR				0x1F4
+#define RCC_R57CIDCFGR				0x1F8
+#define RCC_R57SEMCR				0x1FC
+#define RCC_R58CIDCFGR				0x200
+#define RCC_R58SEMCR				0x204
+#define RCC_R59CIDCFGR				0x208
+#define RCC_R59SEMCR				0x20C
+#define RCC_R60CIDCFGR				0x210
+#define RCC_R60SEMCR				0x214
+#define RCC_R61CIDCFGR				0x218
+#define RCC_R61SEMCR				0x21C
+#define RCC_R62CIDCFGR				0x220
+#define RCC_R62SEMCR				0x224
+#define RCC_R63CIDCFGR				0x228
+#define RCC_R63SEMCR				0x22C
+#define RCC_R64CIDCFGR				0x230
+#define RCC_R64SEMCR				0x234
+#define RCC_R65CIDCFGR				0x238
+#define RCC_R65SEMCR				0x23C
+#define RCC_R66CIDCFGR				0x240
+#define RCC_R66SEMCR				0x244
+#define RCC_R67CIDCFGR				0x248
+#define RCC_R67SEMCR				0x24C
+#define RCC_R68CIDCFGR				0x250
+#define RCC_R68SEMCR				0x254
+#define RCC_R69CIDCFGR				0x258
+#define RCC_R69SEMCR				0x25C
+#define RCC_R70CIDCFGR				0x260
+#define RCC_R70SEMCR				0x264
+#define RCC_R71CIDCFGR				0x268
+#define RCC_R71SEMCR				0x26C
+#define RCC_R72CIDCFGR				0x270
+#define RCC_R72SEMCR				0x274
+#define RCC_R73CIDCFGR				0x278
+#define RCC_R73SEMCR				0x27C
+#define RCC_R74CIDCFGR				0x280
+#define RCC_R74SEMCR				0x284
+#define RCC_R75CIDCFGR				0x288
+#define RCC_R75SEMCR				0x28C
+#define RCC_R76CIDCFGR				0x290
+#define RCC_R76SEMCR				0x294
+#define RCC_R77CIDCFGR				0x298
+#define RCC_R77SEMCR				0x29C
+#define RCC_R78CIDCFGR				0x2A0
+#define RCC_R78SEMCR				0x2A4
+#define RCC_R79CIDCFGR				0x2A8
+#define RCC_R79SEMCR				0x2AC
+#define RCC_R80CIDCFGR				0x2B0
+#define RCC_R80SEMCR				0x2B4
+#define RCC_R81CIDCFGR				0x2B8
+#define RCC_R81SEMCR				0x2BC
+#define RCC_R82CIDCFGR				0x2C0
+#define RCC_R82SEMCR				0x2C4
+#define RCC_R83CIDCFGR				0x2C8
+#define RCC_R83SEMCR				0x2CC
+#define RCC_R84CIDCFGR				0x2D0
+#define RCC_R84SEMCR				0x2D4
+#define RCC_R85CIDCFGR				0x2D8
+#define RCC_R85SEMCR				0x2DC
+#define RCC_R86CIDCFGR				0x2E0
+#define RCC_R86SEMCR				0x2E4
+#define RCC_R87CIDCFGR				0x2E8
+#define RCC_R87SEMCR				0x2EC
+#define RCC_R88CIDCFGR				0x2F0
+#define RCC_R88SEMCR				0x2F4
+#define RCC_R89CIDCFGR				0x2F8
+#define RCC_R89SEMCR				0x2FC
+#define RCC_R90CIDCFGR				0x300
+#define RCC_R90SEMCR				0x304
+#define RCC_R91CIDCFGR				0x308
+#define RCC_R91SEMCR				0x30C
+#define RCC_R92CIDCFGR				0x310
+#define RCC_R92SEMCR				0x314
+#define RCC_R93CIDCFGR				0x318
+#define RCC_R93SEMCR				0x31C
+#define RCC_R94CIDCFGR				0x320
+#define RCC_R94SEMCR				0x324
+#define RCC_R95CIDCFGR				0x328
+#define RCC_R95SEMCR				0x32C
+#define RCC_R96CIDCFGR				0x330
+#define RCC_R96SEMCR				0x334
+#define RCC_R97CIDCFGR				0x338
+#define RCC_R97SEMCR				0x33C
+#define RCC_R98CIDCFGR				0x340
+#define RCC_R98SEMCR				0x344
+#define RCC_R99CIDCFGR				0x348
+#define RCC_R99SEMCR				0x34C
+#define RCC_R100CIDCFGR				0x350
+#define RCC_R100SEMCR				0x354
+#define RCC_R101CIDCFGR				0x358
+#define RCC_R101SEMCR				0x35C
+#define RCC_R102CIDCFGR				0x360
+#define RCC_R102SEMCR				0x364
+#define RCC_R103CIDCFGR				0x368
+#define RCC_R103SEMCR				0x36C
+#define RCC_R104CIDCFGR				0x370
+#define RCC_R104SEMCR				0x374
+#define RCC_R105CIDCFGR				0x378
+#define RCC_R105SEMCR				0x37C
+#define RCC_R106CIDCFGR				0x380
+#define RCC_R106SEMCR				0x384
+#define RCC_R107CIDCFGR				0x388
+#define RCC_R107SEMCR				0x38C
+#define RCC_R108CIDCFGR				0x390
+#define RCC_R108SEMCR				0x394
+#define RCC_R109CIDCFGR				0x398
+#define RCC_R109SEMCR				0x39C
+#define RCC_R110CIDCFGR				0x3A0
+#define RCC_R110SEMCR				0x3A4
+#define RCC_R111CIDCFGR				0x3A8
+#define RCC_R111SEMCR				0x3AC
+#define RCC_R112CIDCFGR				0x3B0
+#define RCC_R112SEMCR				0x3B4
+#define RCC_R113CIDCFGR				0x3B8
+#define RCC_R113SEMCR				0x3BC
+#define RCC_GRSTCSETR				0x400
+#define RCC_C1RSTCSETR				0x404
+#define RCC_C1P1RSTCSETR			0x408
+#define RCC_C2RSTCSETR				0x40C
+#define RCC_HWRSTSCLRR				0x410
+#define RCC_C1HWRSTSCLRR			0x414
+#define RCC_C2HWRSTSCLRR			0x418
+#define RCC_C1BOOTRSTSSETR			0x41C
+#define RCC_C1BOOTRSTSCLRR			0x420
+#define RCC_C2BOOTRSTSSETR			0x424
+#define RCC_C2BOOTRSTSCLRR			0x428
+#define RCC_C1SREQSETR				0x42C
+#define RCC_C1SREQCLRR				0x430
+#define RCC_CPUBOOTCR				0x434
+#define RCC_STBYBOOTCR				0x438
+#define RCC_LEGBOOTCR				0x43C
+#define RCC_BDCR				0x440
+#define RCC_D3DCR				0x444
+#define RCC_D3DSR				0x448
+#define RCC_RDCR				0x44C
+#define RCC_C1MSRDCR				0x450
+#define RCC_PWRLPDLYCR				0x454
+#define RCC_C1CIESETR				0x458
+#define RCC_C1CIFCLRR				0x45C
+#define RCC_C2CIESETR				0x460
+#define RCC_C2CIFCLRR				0x464
+#define RCC_IWDGC1FZSETR			0x468
+#define RCC_IWDGC1FZCLRR			0x46C
+#define RCC_IWDGC1CFGSETR			0x470
+#define RCC_IWDGC1CFGCLRR			0x474
+#define RCC_IWDGC2FZSETR			0x478
+#define RCC_IWDGC2FZCLRR			0x47C
+#define RCC_IWDGC2CFGSETR			0x480
+#define RCC_IWDGC2CFGCLRR			0x484
+#define RCC_IWDGC3CFGSETR			0x488
+#define RCC_IWDGC3CFGCLRR			0x48C
+#define RCC_C3CFGR				0x490
+#define RCC_MCO1CFGR				0x494
+#define RCC_MCO2CFGR				0x498
+#define RCC_OCENSETR				0x49C
+#define RCC_OCENCLRR				0x4A0
+#define RCC_OCRDYR				0x4A4
+#define RCC_HSICFGR				0x4A8
+#define RCC_MSICFGR				0x4AC
+#define RCC_RTCDIVR				0x4B0
+#define RCC_APB1DIVR				0x4B4
+#define RCC_APB2DIVR				0x4B8
+#define RCC_APB3DIVR				0x4BC
+#define RCC_APB4DIVR				0x4C0
+#define RCC_APBDBGDIVR				0x4C4
+#define RCC_TIMG1PRER				0x4C8
+#define RCC_TIMG2PRER				0x4CC
+#define RCC_LSMCUDIVR				0x4D0
+#define RCC_DDRCPCFGR				0x4D4
+#define RCC_DDRCAPBCFGR				0x4D8
+#define RCC_DDRPHYCAPBCFGR			0x4DC
+#define RCC_DDRPHYCCFGR				0x4E0
+#define RCC_DDRCFGR				0x4E4
+#define RCC_DDRITFCFGR				0x4E8
+#define RCC_SYSRAMCFGR				0x4F0
+#define RCC_VDERAMCFGR				0x4F4
+#define RCC_SRAM1CFGR				0x4F8
+#define RCC_SRAM2CFGR				0x4FC
+#define RCC_RETRAMCFGR				0x500
+#define RCC_BKPSRAMCFGR				0x504
+#define RCC_LPSRAM1CFGR				0x508
+#define RCC_LPSRAM2CFGR				0x50C
+#define RCC_LPSRAM3CFGR				0x510
+#define RCC_OSPI1CFGR				0x514
+#define RCC_OSPI2CFGR				0x518
+#define RCC_FMCCFGR				0x51C
+#define RCC_DBGCFGR				0x520
+#define RCC_STMCFGR				0x524
+#define RCC_ETRCFGR				0x528
+#define RCC_GPIOACFGR				0x52C
+#define RCC_GPIOBCFGR				0x530
+#define RCC_GPIOCCFGR				0x534
+#define RCC_GPIODCFGR				0x538
+#define RCC_GPIOECFGR				0x53C
+#define RCC_GPIOFCFGR				0x540
+#define RCC_GPIOGCFGR				0x544
+#define RCC_GPIOHCFGR				0x548
+#define RCC_GPIOICFGR				0x54C
+#define RCC_GPIOJCFGR				0x550
+#define RCC_GPIOKCFGR				0x554
+#define RCC_GPIOZCFGR				0x558
+#define RCC_HPDMA1CFGR				0x55C
+#define RCC_HPDMA2CFGR				0x560
+#define RCC_HPDMA3CFGR				0x564
+#define RCC_LPDMACFGR				0x568
+#define RCC_HSEMCFGR				0x56C
+#define RCC_IPCC1CFGR				0x570
+#define RCC_IPCC2CFGR				0x574
+#define RCC_RTCCFGR				0x578
+#define RCC_SYSCPU1CFGR				0x580
+#define RCC_BSECCFGR				0x584
+#define RCC_IS2MCFGR				0x58C
+#define RCC_PLL2CFGR1				0x590
+#define RCC_PLL2CFGR2				0x594
+#define RCC_PLL2CFGR3				0x598
+#define RCC_PLL2CFGR4				0x59C
+#define RCC_PLL2CFGR5				0x5A0
+#define RCC_PLL2CFGR6				0x5A8
+#define RCC_PLL2CFGR7				0x5AC
+#define RCC_PLL3CFGR1				0x5B8
+#define RCC_PLL3CFGR2				0x5BC
+#define RCC_PLL3CFGR3				0x5C0
+#define RCC_PLL3CFGR4				0x5C4
+#define RCC_PLL3CFGR5				0x5C8
+#define RCC_PLL3CFGR6				0x5D0
+#define RCC_PLL3CFGR7				0x5D4
+#define RCC_HSIFMONCR				0x5E0
+#define RCC_HSIFVALR				0x5E4
+#define RCC_TIM1CFGR				0x700
+#define RCC_TIM2CFGR				0x704
+#define RCC_TIM3CFGR				0x708
+#define RCC_TIM4CFGR				0x70C
+#define RCC_TIM5CFGR				0x710
+#define RCC_TIM6CFGR				0x714
+#define RCC_TIM7CFGR				0x718
+#define RCC_TIM8CFGR				0x71C
+#define RCC_TIM10CFGR				0x720
+#define RCC_TIM11CFGR				0x724
+#define RCC_TIM12CFGR				0x728
+#define RCC_TIM13CFGR				0x72C
+#define RCC_TIM14CFGR				0x730
+#define RCC_TIM15CFGR				0x734
+#define RCC_TIM16CFGR				0x738
+#define RCC_TIM17CFGR				0x73C
+#define RCC_TIM20CFGR				0x740
+#define RCC_LPTIM1CFGR				0x744
+#define RCC_LPTIM2CFGR				0x748
+#define RCC_LPTIM3CFGR				0x74C
+#define RCC_LPTIM4CFGR				0x750
+#define RCC_LPTIM5CFGR				0x754
+#define RCC_SPI1CFGR				0x758
+#define RCC_SPI2CFGR				0x75C
+#define RCC_SPI3CFGR				0x760
+#define RCC_SPI4CFGR				0x764
+#define RCC_SPI5CFGR				0x768
+#define RCC_SPI6CFGR				0x76C
+#define RCC_SPI7CFGR				0x770
+#define RCC_SPI8CFGR				0x774
+#define RCC_SPDIFRXCFGR				0x778
+#define RCC_USART1CFGR				0x77C
+#define RCC_USART2CFGR				0x780
+#define RCC_USART3CFGR				0x784
+#define RCC_UART4CFGR				0x788
+#define RCC_UART5CFGR				0x78C
+#define RCC_USART6CFGR				0x790
+#define RCC_UART7CFGR				0x794
+#define RCC_UART8CFGR				0x798
+#define RCC_UART9CFGR				0x79C
+#define RCC_LPUART1CFGR				0x7A0
+#define RCC_I2C1CFGR				0x7A4
+#define RCC_I2C2CFGR				0x7A8
+#define RCC_I2C3CFGR				0x7AC
+#define RCC_I2C4CFGR				0x7B0
+#define RCC_I2C5CFGR				0x7B4
+#define RCC_I2C6CFGR				0x7B8
+#define RCC_I2C7CFGR				0x7BC
+#define RCC_I2C8CFGR				0x7C0
+#define RCC_SAI1CFGR				0x7C4
+#define RCC_SAI2CFGR				0x7C8
+#define RCC_SAI3CFGR				0x7CC
+#define RCC_SAI4CFGR				0x7D0
+#define RCC_MDF1CFGR				0x7D8
+#define RCC_ADF1CFGR				0x7DC
+#define RCC_FDCANCFGR				0x7E0
+#define RCC_HDPCFGR				0x7E4
+#define RCC_ADC12CFGR				0x7E8
+#define RCC_ADC3CFGR				0x7EC
+#define RCC_ETH1CFGR				0x7F0
+#define RCC_ETH2CFGR				0x7F4
+#define RCC_USB2CFGR				0x7FC
+#define RCC_USB2PHY1CFGR			0x800
+#define RCC_USB2PHY2CFGR			0x804
+#define RCC_USB3DRCFGR				0x808
+#define RCC_USB3PCIEPHYCFGR			0x80C
+#define RCC_PCIECFGR				0x810
+#define RCC_USBTCCFGR				0x814
+#define RCC_ETHSWCFGR				0x818
+#define RCC_ETHSWACMCFGR			0x81C
+#define RCC_ETHSWACMMSGCFGR			0x820
+#define RCC_STGENCFGR				0x824
+#define RCC_SDMMC1CFGR				0x830
+#define RCC_SDMMC2CFGR				0x834
+#define RCC_SDMMC3CFGR				0x838
+#define RCC_GPUCFGR				0x83C
+#define RCC_LTDCCFGR				0x840
+#define RCC_DSICFGR				0x844
+#define RCC_LVDSCFGR				0x850
+#define RCC_CSICFGR				0x858
+#define RCC_DCMIPPCFGR				0x85C
+#define RCC_CCICFGR				0x860
+#define RCC_VDECCFGR				0x864
+#define RCC_VENCCFGR				0x868
+#define RCC_RNGCFGR				0x870
+#define RCC_PKACFGR				0x874
+#define RCC_SAESCFGR				0x878
+#define RCC_HASHCFGR				0x87C
+#define RCC_CRYP1CFGR				0x880
+#define RCC_CRYP2CFGR				0x884
+#define RCC_IWDG1CFGR				0x888
+#define RCC_IWDG2CFGR				0x88C
+#define RCC_IWDG3CFGR				0x890
+#define RCC_IWDG4CFGR				0x894
+#define RCC_IWDG5CFGR				0x898
+#define RCC_WWDG1CFGR				0x89C
+#define RCC_WWDG2CFGR				0x8A0
+#define RCC_VREFCFGR				0x8A8
+#define RCC_DTSCFGR				0x8AC
+#define RCC_CRCCFGR				0x8B4
+#define RCC_SERCCFGR				0x8B8
+#define RCC_OSPIIOMCFGR				0x8BC
+#define RCC_GICV2MCFGR				0x8C0
+#define RCC_I3C1CFGR				0x8C8
+#define RCC_I3C2CFGR				0x8CC
+#define RCC_I3C3CFGR				0x8D0
+#define RCC_I3C4CFGR				0x8D4
+#define RCC_MUXSELCFGR				0x1000
+#define RCC_XBAR0CFGR				0x1018
+#define RCC_XBAR1CFGR				0x101C
+#define RCC_XBAR2CFGR				0x1020
+#define RCC_XBAR3CFGR				0x1024
+#define RCC_XBAR4CFGR				0x1028
+#define RCC_XBAR5CFGR				0x102C
+#define RCC_XBAR6CFGR				0x1030
+#define RCC_XBAR7CFGR				0x1034
+#define RCC_XBAR8CFGR				0x1038
+#define RCC_XBAR9CFGR				0x103C
+#define RCC_XBAR10CFGR				0x1040
+#define RCC_XBAR11CFGR				0x1044
+#define RCC_XBAR12CFGR				0x1048
+#define RCC_XBAR13CFGR				0x104C
+#define RCC_XBAR14CFGR				0x1050
+#define RCC_XBAR15CFGR				0x1054
+#define RCC_XBAR16CFGR				0x1058
+#define RCC_XBAR17CFGR				0x105C
+#define RCC_XBAR18CFGR				0x1060
+#define RCC_XBAR19CFGR				0x1064
+#define RCC_XBAR20CFGR				0x1068
+#define RCC_XBAR21CFGR				0x106C
+#define RCC_XBAR22CFGR				0x1070
+#define RCC_XBAR23CFGR				0x1074
+#define RCC_XBAR24CFGR				0x1078
+#define RCC_XBAR25CFGR				0x107C
+#define RCC_XBAR26CFGR				0x1080
+#define RCC_XBAR27CFGR				0x1084
+#define RCC_XBAR28CFGR				0x1088
+#define RCC_XBAR29CFGR				0x108C
+#define RCC_XBAR30CFGR				0x1090
+#define RCC_XBAR31CFGR				0x1094
+#define RCC_XBAR32CFGR				0x1098
+#define RCC_XBAR33CFGR				0x109C
+#define RCC_XBAR34CFGR				0x10A0
+#define RCC_XBAR35CFGR				0x10A4
+#define RCC_XBAR36CFGR				0x10A8
+#define RCC_XBAR37CFGR				0x10AC
+#define RCC_XBAR38CFGR				0x10B0
+#define RCC_XBAR39CFGR				0x10B4
+#define RCC_XBAR40CFGR				0x10B8
+#define RCC_XBAR41CFGR				0x10BC
+#define RCC_XBAR42CFGR				0x10C0
+#define RCC_XBAR43CFGR				0x10C4
+#define RCC_XBAR44CFGR				0x10C8
+#define RCC_XBAR45CFGR				0x10CC
+#define RCC_XBAR46CFGR				0x10D0
+#define RCC_XBAR47CFGR				0x10D4
+#define RCC_XBAR48CFGR				0x10D8
+#define RCC_XBAR49CFGR				0x10DC
+#define RCC_XBAR50CFGR				0x10E0
+#define RCC_XBAR51CFGR				0x10E4
+#define RCC_XBAR52CFGR				0x10E8
+#define RCC_XBAR53CFGR				0x10EC
+#define RCC_XBAR54CFGR				0x10F0
+#define RCC_XBAR55CFGR				0x10F4
+#define RCC_XBAR56CFGR				0x10F8
+#define RCC_XBAR57CFGR				0x10FC
+#define RCC_XBAR58CFGR				0x1100
+#define RCC_XBAR59CFGR				0x1104
+#define RCC_XBAR60CFGR				0x1108
+#define RCC_XBAR61CFGR				0x110C
+#define RCC_XBAR62CFGR				0x1110
+#define RCC_XBAR63CFGR				0x1114
+#define RCC_PREDIV0CFGR				0x1118
+#define RCC_PREDIV1CFGR				0x111C
+#define RCC_PREDIV2CFGR				0x1120
+#define RCC_PREDIV3CFGR				0x1124
+#define RCC_PREDIV4CFGR				0x1128
+#define RCC_PREDIV5CFGR				0x112C
+#define RCC_PREDIV6CFGR				0x1130
+#define RCC_PREDIV7CFGR				0x1134
+#define RCC_PREDIV8CFGR				0x1138
+#define RCC_PREDIV9CFGR				0x113C
+#define RCC_PREDIV10CFGR			0x1140
+#define RCC_PREDIV11CFGR			0x1144
+#define RCC_PREDIV12CFGR			0x1148
+#define RCC_PREDIV13CFGR			0x114C
+#define RCC_PREDIV14CFGR			0x1150
+#define RCC_PREDIV15CFGR			0x1154
+#define RCC_PREDIV16CFGR			0x1158
+#define RCC_PREDIV17CFGR			0x115C
+#define RCC_PREDIV18CFGR			0x1160
+#define RCC_PREDIV19CFGR			0x1164
+#define RCC_PREDIV20CFGR			0x1168
+#define RCC_PREDIV21CFGR			0x116C
+#define RCC_PREDIV22CFGR			0x1170
+#define RCC_PREDIV23CFGR			0x1174
+#define RCC_PREDIV24CFGR			0x1178
+#define RCC_PREDIV25CFGR			0x117C
+#define RCC_PREDIV26CFGR			0x1180
+#define RCC_PREDIV27CFGR			0x1184
+#define RCC_PREDIV28CFGR			0x1188
+#define RCC_PREDIV29CFGR			0x118C
+#define RCC_PREDIV30CFGR			0x1190
+#define RCC_PREDIV31CFGR			0x1194
+#define RCC_PREDIV32CFGR			0x1198
+#define RCC_PREDIV33CFGR			0x119C
+#define RCC_PREDIV34CFGR			0x11A0
+#define RCC_PREDIV35CFGR			0x11A4
+#define RCC_PREDIV36CFGR			0x11A8
+#define RCC_PREDIV37CFGR			0x11AC
+#define RCC_PREDIV38CFGR			0x11B0
+#define RCC_PREDIV39CFGR			0x11B4
+#define RCC_PREDIV40CFGR			0x11B8
+#define RCC_PREDIV41CFGR			0x11BC
+#define RCC_PREDIV42CFGR			0x11C0
+#define RCC_PREDIV43CFGR			0x11C4
+#define RCC_PREDIV44CFGR			0x11C8
+#define RCC_PREDIV45CFGR			0x11CC
+#define RCC_PREDIV46CFGR			0x11D0
+#define RCC_PREDIV47CFGR			0x11D4
+#define RCC_PREDIV48CFGR			0x11D8
+#define RCC_PREDIV49CFGR			0x11DC
+#define RCC_PREDIV50CFGR			0x11E0
+#define RCC_PREDIV51CFGR			0x11E4
+#define RCC_PREDIV52CFGR			0x11E8
+#define RCC_PREDIV53CFGR			0x11EC
+#define RCC_PREDIV54CFGR			0x11F0
+#define RCC_PREDIV55CFGR			0x11F4
+#define RCC_PREDIV56CFGR			0x11F8
+#define RCC_PREDIV57CFGR			0x11FC
+#define RCC_PREDIV58CFGR			0x1200
+#define RCC_PREDIV59CFGR			0x1204
+#define RCC_PREDIV60CFGR			0x1208
+#define RCC_PREDIV61CFGR			0x120C
+#define RCC_PREDIV62CFGR			0x1210
+#define RCC_PREDIV63CFGR			0x1214
+#define RCC_PREDIVSR1				0x1218
+#define RCC_PREDIVSR2				0x121C
+#define RCC_FINDIV0CFGR				0x1224
+#define RCC_FINDIV1CFGR				0x1228
+#define RCC_FINDIV2CFGR				0x122C
+#define RCC_FINDIV3CFGR				0x1230
+#define RCC_FINDIV4CFGR				0x1234
+#define RCC_FINDIV5CFGR				0x1238
+#define RCC_FINDIV6CFGR				0x123C
+#define RCC_FINDIV7CFGR				0x1240
+#define RCC_FINDIV8CFGR				0x1244
+#define RCC_FINDIV9CFGR				0x1248
+#define RCC_FINDIV10CFGR			0x124C
+#define RCC_FINDIV11CFGR			0x1250
+#define RCC_FINDIV12CFGR			0x1254
+#define RCC_FINDIV13CFGR			0x1258
+#define RCC_FINDIV14CFGR			0x125C
+#define RCC_FINDIV15CFGR			0x1260
+#define RCC_FINDIV16CFGR			0x1264
+#define RCC_FINDIV17CFGR			0x1268
+#define RCC_FINDIV18CFGR			0x126C
+#define RCC_FINDIV19CFGR			0x1270
+#define RCC_FINDIV20CFGR			0x1274
+#define RCC_FINDIV21CFGR			0x1278
+#define RCC_FINDIV22CFGR			0x127C
+#define RCC_FINDIV23CFGR			0x1280
+#define RCC_FINDIV24CFGR			0x1284
+#define RCC_FINDIV25CFGR			0x1288
+#define RCC_FINDIV26CFGR			0x128C
+#define RCC_FINDIV27CFGR			0x1290
+#define RCC_FINDIV28CFGR			0x1294
+#define RCC_FINDIV29CFGR			0x1298
+#define RCC_FINDIV30CFGR			0x129C
+#define RCC_FINDIV31CFGR			0x12A0
+#define RCC_FINDIV32CFGR			0x12A4
+#define RCC_FINDIV33CFGR			0x12A8
+#define RCC_FINDIV34CFGR			0x12AC
+#define RCC_FINDIV35CFGR			0x12B0
+#define RCC_FINDIV36CFGR			0x12B4
+#define RCC_FINDIV37CFGR			0x12B8
+#define RCC_FINDIV38CFGR			0x12BC
+#define RCC_FINDIV39CFGR			0x12C0
+#define RCC_FINDIV40CFGR			0x12C4
+#define RCC_FINDIV41CFGR			0x12C8
+#define RCC_FINDIV42CFGR			0x12CC
+#define RCC_FINDIV43CFGR			0x12D0
+#define RCC_FINDIV44CFGR			0x12D4
+#define RCC_FINDIV45CFGR			0x12D8
+#define RCC_FINDIV46CFGR			0x12DC
+#define RCC_FINDIV47CFGR			0x12E0
+#define RCC_FINDIV48CFGR			0x12E4
+#define RCC_FINDIV49CFGR			0x12E8
+#define RCC_FINDIV50CFGR			0x12EC
+#define RCC_FINDIV51CFGR			0x12F0
+#define RCC_FINDIV52CFGR			0x12F4
+#define RCC_FINDIV53CFGR			0x12F8
+#define RCC_FINDIV54CFGR			0x12FC
+#define RCC_FINDIV55CFGR			0x1300
+#define RCC_FINDIV56CFGR			0x1304
+#define RCC_FINDIV57CFGR			0x1308
+#define RCC_FINDIV58CFGR			0x130C
+#define RCC_FINDIV59CFGR			0x1310
+#define RCC_FINDIV60CFGR			0x1314
+#define RCC_FINDIV61CFGR			0x1318
+#define RCC_FINDIV62CFGR			0x131C
+#define RCC_FINDIV63CFGR			0x1320
+#define RCC_FINDIVSR1				0x1324
+#define RCC_FINDIVSR2				0x1328
+#define RCC_FCALCOBS0CFGR			0x1340
+#define RCC_FCALCOBS1CFGR			0x1344
+#define RCC_FCALCREFCFGR			0x1348
+#define RCC_FCALCCR1				0x134C
+#define RCC_FCALCCR2				0x1354
+#define RCC_FCALCSR				0x1358
+#define RCC_PLL4CFGR1				0x1360
+#define RCC_PLL4CFGR2				0x1364
+#define RCC_PLL4CFGR3				0x1368
+#define RCC_PLL4CFGR4				0x136C
+#define RCC_PLL4CFGR5				0x1370
+#define RCC_PLL4CFGR6				0x1378
+#define RCC_PLL4CFGR7				0x137C
+#define RCC_PLL5CFGR1				0x1388
+#define RCC_PLL5CFGR2				0x138C
+#define RCC_PLL5CFGR3				0x1390
+#define RCC_PLL5CFGR4				0x1394
+#define RCC_PLL5CFGR5				0x1398
+#define RCC_PLL5CFGR6				0x13A0
+#define RCC_PLL5CFGR7				0x13A4
+#define RCC_PLL6CFGR1				0x13B0
+#define RCC_PLL6CFGR2				0x13B4
+#define RCC_PLL6CFGR3				0x13B8
+#define RCC_PLL6CFGR4				0x13BC
+#define RCC_PLL6CFGR5				0x13C0
+#define RCC_PLL6CFGR6				0x13C8
+#define RCC_PLL6CFGR7				0x13CC
+#define RCC_PLL7CFGR1				0x13D8
+#define RCC_PLL7CFGR2				0x13DC
+#define RCC_PLL7CFGR3				0x13E0
+#define RCC_PLL7CFGR4				0x13E4
+#define RCC_PLL7CFGR5				0x13E8
+#define RCC_PLL7CFGR6				0x13F0
+#define RCC_PLL7CFGR7				0x13F4
+#define RCC_PLL8CFGR1				0x1400
+#define RCC_PLL8CFGR2				0x1404
+#define RCC_PLL8CFGR3				0x1408
+#define RCC_PLL8CFGR4				0x140C
+#define RCC_PLL8CFGR5				0x1410
+#define RCC_PLL8CFGR6				0x1418
+#define RCC_PLL8CFGR7				0x141C
+#define RCC_VERR				0xFFF4
+#define RCC_IDR					0xFFF8
+#define RCC_SIDR				0xFFFC
+
+/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
+#define RCC_MP_ENCLRR_OFFSET			4
+
+/* RCC_SECCFGR3 register fields */
+#define RCC_SECCFGR3_SEC_MASK			GENMASK(17, 0)
+#define RCC_SECCFGR3_SEC_SHIFT			0
+
+/* RCC_PRIVCFGR3 register fields */
+#define RCC_PRIVCFGR3_PRIV_MASK			GENMASK(17, 0)
+#define RCC_PRIVCFGR3_PRIV_SHIFT		0
+
+/* RCC_RCFGLOCKR3 register fields */
+#define RCC_RCFGLOCKR3_RLOCK_MASK		GENMASK(17, 0)
+#define RCC_RCFGLOCKR3_RLOCK_SHIFT		0
+
+/* RCC_R0CIDCFGR register fields */
+#define RCC_R0CIDCFGR_CFEN			BIT(0)
+#define RCC_R0CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R0CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R0CIDCFGR_SCID_SHIFT		4
+#define RCC_R0CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R0CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R0SEMCR register fields */
+#define RCC_R0SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R0SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R0SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R1CIDCFGR register fields */
+#define RCC_R1CIDCFGR_CFEN			BIT(0)
+#define RCC_R1CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R1CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R1CIDCFGR_SCID_SHIFT		4
+#define RCC_R1CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R1CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R1SEMCR register fields */
+#define RCC_R1SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R1SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R1SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R2CIDCFGR register fields */
+#define RCC_R2CIDCFGR_CFEN			BIT(0)
+#define RCC_R2CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R2CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R2CIDCFGR_SCID_SHIFT		4
+#define RCC_R2CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R2CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R2SEMCR register fields */
+#define RCC_R2SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R2SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R2SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R3CIDCFGR register fields */
+#define RCC_R3CIDCFGR_CFEN			BIT(0)
+#define RCC_R3CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R3CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R3CIDCFGR_SCID_SHIFT		4
+#define RCC_R3CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R3CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R3SEMCR register fields */
+#define RCC_R3SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R3SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R3SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R4CIDCFGR register fields */
+#define RCC_R4CIDCFGR_CFEN			BIT(0)
+#define RCC_R4CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R4CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R4CIDCFGR_SCID_SHIFT		4
+#define RCC_R4CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R4CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R4SEMCR register fields */
+#define RCC_R4SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R4SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R4SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R5CIDCFGR register fields */
+#define RCC_R5CIDCFGR_CFEN			BIT(0)
+#define RCC_R5CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R5CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R5CIDCFGR_SCID_SHIFT		4
+#define RCC_R5CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R5CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R5SEMCR register fields */
+#define RCC_R5SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R5SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R5SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R6CIDCFGR register fields */
+#define RCC_R6CIDCFGR_CFEN			BIT(0)
+#define RCC_R6CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R6CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R6CIDCFGR_SCID_SHIFT		4
+#define RCC_R6CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R6CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R6SEMCR register fields */
+#define RCC_R6SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R6SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R6SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R7CIDCFGR register fields */
+#define RCC_R7CIDCFGR_CFEN			BIT(0)
+#define RCC_R7CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R7CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R7CIDCFGR_SCID_SHIFT		4
+#define RCC_R7CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R7CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R7SEMCR register fields */
+#define RCC_R7SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R7SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R7SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R8CIDCFGR register fields */
+#define RCC_R8CIDCFGR_CFEN			BIT(0)
+#define RCC_R8CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R8CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R8CIDCFGR_SCID_SHIFT		4
+#define RCC_R8CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R8CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R8SEMCR register fields */
+#define RCC_R8SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R8SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R8SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R9CIDCFGR register fields */
+#define RCC_R9CIDCFGR_CFEN			BIT(0)
+#define RCC_R9CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R9CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R9CIDCFGR_SCID_SHIFT		4
+#define RCC_R9CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R9CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R9SEMCR register fields */
+#define RCC_R9SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R9SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R9SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R10CIDCFGR register fields */
+#define RCC_R10CIDCFGR_CFEN			BIT(0)
+#define RCC_R10CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R10CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R10CIDCFGR_SCID_SHIFT		4
+#define RCC_R10CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R10CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R10SEMCR register fields */
+#define RCC_R10SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R10SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R10SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R11CIDCFGR register fields */
+#define RCC_R11CIDCFGR_CFEN			BIT(0)
+#define RCC_R11CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R11CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R11CIDCFGR_SCID_SHIFT		4
+#define RCC_R11CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R11CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R11SEMCR register fields */
+#define RCC_R11SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R11SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R11SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R12CIDCFGR register fields */
+#define RCC_R12CIDCFGR_CFEN			BIT(0)
+#define RCC_R12CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R12CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R12CIDCFGR_SCID_SHIFT		4
+#define RCC_R12CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R12CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R12SEMCR register fields */
+#define RCC_R12SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R12SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R12SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R13CIDCFGR register fields */
+#define RCC_R13CIDCFGR_CFEN			BIT(0)
+#define RCC_R13CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R13CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R13CIDCFGR_SCID_SHIFT		4
+#define RCC_R13CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R13CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R13SEMCR register fields */
+#define RCC_R13SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R13SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R13SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R14CIDCFGR register fields */
+#define RCC_R14CIDCFGR_CFEN			BIT(0)
+#define RCC_R14CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R14CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R14CIDCFGR_SCID_SHIFT		4
+#define RCC_R14CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R14CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R14SEMCR register fields */
+#define RCC_R14SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R14SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R14SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R15CIDCFGR register fields */
+#define RCC_R15CIDCFGR_CFEN			BIT(0)
+#define RCC_R15CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R15CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R15CIDCFGR_SCID_SHIFT		4
+#define RCC_R15CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R15CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R15SEMCR register fields */
+#define RCC_R15SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R15SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R15SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R16CIDCFGR register fields */
+#define RCC_R16CIDCFGR_CFEN			BIT(0)
+#define RCC_R16CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R16CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R16CIDCFGR_SCID_SHIFT		4
+#define RCC_R16CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R16CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R16SEMCR register fields */
+#define RCC_R16SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R16SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R16SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R17CIDCFGR register fields */
+#define RCC_R17CIDCFGR_CFEN			BIT(0)
+#define RCC_R17CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R17CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R17CIDCFGR_SCID_SHIFT		4
+#define RCC_R17CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R17CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R17SEMCR register fields */
+#define RCC_R17SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R17SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R17SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R18CIDCFGR register fields */
+#define RCC_R18CIDCFGR_CFEN			BIT(0)
+#define RCC_R18CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R18CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R18CIDCFGR_SCID_SHIFT		4
+#define RCC_R18CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R18CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R18SEMCR register fields */
+#define RCC_R18SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R18SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R18SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R19CIDCFGR register fields */
+#define RCC_R19CIDCFGR_CFEN			BIT(0)
+#define RCC_R19CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R19CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R19CIDCFGR_SCID_SHIFT		4
+#define RCC_R19CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R19CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R19SEMCR register fields */
+#define RCC_R19SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R19SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R19SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R20CIDCFGR register fields */
+#define RCC_R20CIDCFGR_CFEN			BIT(0)
+#define RCC_R20CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R20CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R20CIDCFGR_SCID_SHIFT		4
+#define RCC_R20CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R20CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R20SEMCR register fields */
+#define RCC_R20SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R20SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R20SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R21CIDCFGR register fields */
+#define RCC_R21CIDCFGR_CFEN			BIT(0)
+#define RCC_R21CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R21CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R21CIDCFGR_SCID_SHIFT		4
+#define RCC_R21CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R21CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R21SEMCR register fields */
+#define RCC_R21SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R21SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R21SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R22CIDCFGR register fields */
+#define RCC_R22CIDCFGR_CFEN			BIT(0)
+#define RCC_R22CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R22CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R22CIDCFGR_SCID_SHIFT		4
+#define RCC_R22CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R22CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R22SEMCR register fields */
+#define RCC_R22SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R22SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R22SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R23CIDCFGR register fields */
+#define RCC_R23CIDCFGR_CFEN			BIT(0)
+#define RCC_R23CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R23CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R23CIDCFGR_SCID_SHIFT		4
+#define RCC_R23CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R23CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R23SEMCR register fields */
+#define RCC_R23SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R23SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R23SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R24CIDCFGR register fields */
+#define RCC_R24CIDCFGR_CFEN			BIT(0)
+#define RCC_R24CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R24CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R24CIDCFGR_SCID_SHIFT		4
+#define RCC_R24CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R24CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R24SEMCR register fields */
+#define RCC_R24SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R24SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R24SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R25CIDCFGR register fields */
+#define RCC_R25CIDCFGR_CFEN			BIT(0)
+#define RCC_R25CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R25CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R25CIDCFGR_SCID_SHIFT		4
+#define RCC_R25CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R25CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R25SEMCR register fields */
+#define RCC_R25SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R25SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R25SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R26CIDCFGR register fields */
+#define RCC_R26CIDCFGR_CFEN			BIT(0)
+#define RCC_R26CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R26CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R26CIDCFGR_SCID_SHIFT		4
+#define RCC_R26CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R26CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R26SEMCR register fields */
+#define RCC_R26SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R26SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R26SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R27CIDCFGR register fields */
+#define RCC_R27CIDCFGR_CFEN			BIT(0)
+#define RCC_R27CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R27CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R27CIDCFGR_SCID_SHIFT		4
+#define RCC_R27CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R27CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R27SEMCR register fields */
+#define RCC_R27SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R27SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R27SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R28CIDCFGR register fields */
+#define RCC_R28CIDCFGR_CFEN			BIT(0)
+#define RCC_R28CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R28CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R28CIDCFGR_SCID_SHIFT		4
+#define RCC_R28CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R28CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R28SEMCR register fields */
+#define RCC_R28SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R28SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R28SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R29CIDCFGR register fields */
+#define RCC_R29CIDCFGR_CFEN			BIT(0)
+#define RCC_R29CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R29CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R29CIDCFGR_SCID_SHIFT		4
+#define RCC_R29CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R29CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R29SEMCR register fields */
+#define RCC_R29SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R29SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R29SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R30CIDCFGR register fields */
+#define RCC_R30CIDCFGR_CFEN			BIT(0)
+#define RCC_R30CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R30CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R30CIDCFGR_SCID_SHIFT		4
+#define RCC_R30CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R30CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R30SEMCR register fields */
+#define RCC_R30SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R30SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R30SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R31CIDCFGR register fields */
+#define RCC_R31CIDCFGR_CFEN			BIT(0)
+#define RCC_R31CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R31CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R31CIDCFGR_SCID_SHIFT		4
+#define RCC_R31CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R31CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R31SEMCR register fields */
+#define RCC_R31SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R31SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R31SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R32CIDCFGR register fields */
+#define RCC_R32CIDCFGR_CFEN			BIT(0)
+#define RCC_R32CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R32CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R32CIDCFGR_SCID_SHIFT		4
+#define RCC_R32CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R32CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R32SEMCR register fields */
+#define RCC_R32SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R32SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R32SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R33CIDCFGR register fields */
+#define RCC_R33CIDCFGR_CFEN			BIT(0)
+#define RCC_R33CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R33CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R33CIDCFGR_SCID_SHIFT		4
+#define RCC_R33CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R33CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R33SEMCR register fields */
+#define RCC_R33SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R33SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R33SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R34CIDCFGR register fields */
+#define RCC_R34CIDCFGR_CFEN			BIT(0)
+#define RCC_R34CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R34CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R34CIDCFGR_SCID_SHIFT		4
+#define RCC_R34CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R34CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R34SEMCR register fields */
+#define RCC_R34SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R34SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R34SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R35CIDCFGR register fields */
+#define RCC_R35CIDCFGR_CFEN			BIT(0)
+#define RCC_R35CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R35CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R35CIDCFGR_SCID_SHIFT		4
+#define RCC_R35CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R35CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R35SEMCR register fields */
+#define RCC_R35SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R35SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R35SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R36CIDCFGR register fields */
+#define RCC_R36CIDCFGR_CFEN			BIT(0)
+#define RCC_R36CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R36CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R36CIDCFGR_SCID_SHIFT		4
+#define RCC_R36CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R36CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R36SEMCR register fields */
+#define RCC_R36SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R36SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R36SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R37CIDCFGR register fields */
+#define RCC_R37CIDCFGR_CFEN			BIT(0)
+#define RCC_R37CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R37CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R37CIDCFGR_SCID_SHIFT		4
+#define RCC_R37CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R37CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R37SEMCR register fields */
+#define RCC_R37SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R37SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R37SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R38CIDCFGR register fields */
+#define RCC_R38CIDCFGR_CFEN			BIT(0)
+#define RCC_R38CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R38CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R38CIDCFGR_SCID_SHIFT		4
+#define RCC_R38CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R38CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R38SEMCR register fields */
+#define RCC_R38SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R38SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R38SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R39CIDCFGR register fields */
+#define RCC_R39CIDCFGR_CFEN			BIT(0)
+#define RCC_R39CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R39CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R39CIDCFGR_SCID_SHIFT		4
+#define RCC_R39CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R39CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R39SEMCR register fields */
+#define RCC_R39SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R39SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R39SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R40CIDCFGR register fields */
+#define RCC_R40CIDCFGR_CFEN			BIT(0)
+#define RCC_R40CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R40CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R40CIDCFGR_SCID_SHIFT		4
+#define RCC_R40CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R40CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R40SEMCR register fields */
+#define RCC_R40SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R40SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R40SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R41CIDCFGR register fields */
+#define RCC_R41CIDCFGR_CFEN			BIT(0)
+#define RCC_R41CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R41CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R41CIDCFGR_SCID_SHIFT		4
+#define RCC_R41CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R41CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R41SEMCR register fields */
+#define RCC_R41SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R41SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R41SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R42CIDCFGR register fields */
+#define RCC_R42CIDCFGR_CFEN			BIT(0)
+#define RCC_R42CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R42CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R42CIDCFGR_SCID_SHIFT		4
+#define RCC_R42CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R42CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R42SEMCR register fields */
+#define RCC_R42SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R42SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R42SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R43CIDCFGR register fields */
+#define RCC_R43CIDCFGR_CFEN			BIT(0)
+#define RCC_R43CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R43CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R43CIDCFGR_SCID_SHIFT		4
+#define RCC_R43CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R43CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R43SEMCR register fields */
+#define RCC_R43SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R43SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R43SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R44CIDCFGR register fields */
+#define RCC_R44CIDCFGR_CFEN			BIT(0)
+#define RCC_R44CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R44CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R44CIDCFGR_SCID_SHIFT		4
+#define RCC_R44CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R44CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R44SEMCR register fields */
+#define RCC_R44SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R44SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R44SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R45CIDCFGR register fields */
+#define RCC_R45CIDCFGR_CFEN			BIT(0)
+#define RCC_R45CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R45CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R45CIDCFGR_SCID_SHIFT		4
+#define RCC_R45CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R45CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R45SEMCR register fields */
+#define RCC_R45SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R45SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R45SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R46CIDCFGR register fields */
+#define RCC_R46CIDCFGR_CFEN			BIT(0)
+#define RCC_R46CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R46CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R46CIDCFGR_SCID_SHIFT		4
+#define RCC_R46CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R46CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R46SEMCR register fields */
+#define RCC_R46SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R46SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R46SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R47CIDCFGR register fields */
+#define RCC_R47CIDCFGR_CFEN			BIT(0)
+#define RCC_R47CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R47CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R47CIDCFGR_SCID_SHIFT		4
+#define RCC_R47CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R47CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R47SEMCR register fields */
+#define RCC_R47SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R47SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R47SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R48CIDCFGR register fields */
+#define RCC_R48CIDCFGR_CFEN			BIT(0)
+#define RCC_R48CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R48CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R48CIDCFGR_SCID_SHIFT		4
+#define RCC_R48CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R48CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R48SEMCR register fields */
+#define RCC_R48SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R48SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R48SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R49CIDCFGR register fields */
+#define RCC_R49CIDCFGR_CFEN			BIT(0)
+#define RCC_R49CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R49CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R49CIDCFGR_SCID_SHIFT		4
+#define RCC_R49CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R49CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R49SEMCR register fields */
+#define RCC_R49SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R49SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R49SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R50CIDCFGR register fields */
+#define RCC_R50CIDCFGR_CFEN			BIT(0)
+#define RCC_R50CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R50CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R50CIDCFGR_SCID_SHIFT		4
+#define RCC_R50CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R50CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R50SEMCR register fields */
+#define RCC_R50SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R50SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R50SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R51CIDCFGR register fields */
+#define RCC_R51CIDCFGR_CFEN			BIT(0)
+#define RCC_R51CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R51CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R51CIDCFGR_SCID_SHIFT		4
+#define RCC_R51CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R51CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R51SEMCR register fields */
+#define RCC_R51SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R51SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R51SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R52CIDCFGR register fields */
+#define RCC_R52CIDCFGR_CFEN			BIT(0)
+#define RCC_R52CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R52CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R52CIDCFGR_SCID_SHIFT		4
+#define RCC_R52CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R52CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R52SEMCR register fields */
+#define RCC_R52SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R52SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R52SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R53CIDCFGR register fields */
+#define RCC_R53CIDCFGR_CFEN			BIT(0)
+#define RCC_R53CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R53CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R53CIDCFGR_SCID_SHIFT		4
+#define RCC_R53CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R53CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R53SEMCR register fields */
+#define RCC_R53SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R53SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R53SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R54CIDCFGR register fields */
+#define RCC_R54CIDCFGR_CFEN			BIT(0)
+#define RCC_R54CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R54CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R54CIDCFGR_SCID_SHIFT		4
+#define RCC_R54CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R54CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R54SEMCR register fields */
+#define RCC_R54SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R54SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R54SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R55CIDCFGR register fields */
+#define RCC_R55CIDCFGR_CFEN			BIT(0)
+#define RCC_R55CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R55CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R55CIDCFGR_SCID_SHIFT		4
+#define RCC_R55CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R55CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R55SEMCR register fields */
+#define RCC_R55SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R55SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R55SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R56CIDCFGR register fields */
+#define RCC_R56CIDCFGR_CFEN			BIT(0)
+#define RCC_R56CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R56CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R56CIDCFGR_SCID_SHIFT		4
+#define RCC_R56CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R56CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R56SEMCR register fields */
+#define RCC_R56SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R56SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R56SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R57CIDCFGR register fields */
+#define RCC_R57CIDCFGR_CFEN			BIT(0)
+#define RCC_R57CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R57CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R57CIDCFGR_SCID_SHIFT		4
+#define RCC_R57CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R57CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R57SEMCR register fields */
+#define RCC_R57SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R57SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R57SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R58CIDCFGR register fields */
+#define RCC_R58CIDCFGR_CFEN			BIT(0)
+#define RCC_R58CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R58CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R58CIDCFGR_SCID_SHIFT		4
+#define RCC_R58CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R58CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R58SEMCR register fields */
+#define RCC_R58SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R58SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R58SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R59CIDCFGR register fields */
+#define RCC_R59CIDCFGR_CFEN			BIT(0)
+#define RCC_R59CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R59CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R59CIDCFGR_SCID_SHIFT		4
+#define RCC_R59CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R59CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R59SEMCR register fields */
+#define RCC_R59SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R59SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R59SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R60CIDCFGR register fields */
+#define RCC_R60CIDCFGR_CFEN			BIT(0)
+#define RCC_R60CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R60CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R60CIDCFGR_SCID_SHIFT		4
+#define RCC_R60CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R60CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R60SEMCR register fields */
+#define RCC_R60SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R60SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R60SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R61CIDCFGR register fields */
+#define RCC_R61CIDCFGR_CFEN			BIT(0)
+#define RCC_R61CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R61CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R61CIDCFGR_SCID_SHIFT		4
+#define RCC_R61CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R61CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R61SEMCR register fields */
+#define RCC_R61SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R61SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R61SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R62CIDCFGR register fields */
+#define RCC_R62CIDCFGR_CFEN			BIT(0)
+#define RCC_R62CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R62CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R62CIDCFGR_SCID_SHIFT		4
+#define RCC_R62CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R62CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R62SEMCR register fields */
+#define RCC_R62SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R62SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R62SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R63CIDCFGR register fields */
+#define RCC_R63CIDCFGR_CFEN			BIT(0)
+#define RCC_R63CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R63CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R63CIDCFGR_SCID_SHIFT		4
+#define RCC_R63CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R63CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R63SEMCR register fields */
+#define RCC_R63SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R63SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R63SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R64CIDCFGR register fields */
+#define RCC_R64CIDCFGR_CFEN			BIT(0)
+#define RCC_R64CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R64CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R64CIDCFGR_SCID_SHIFT		4
+#define RCC_R64CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R64CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R64SEMCR register fields */
+#define RCC_R64SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R64SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R64SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R65CIDCFGR register fields */
+#define RCC_R65CIDCFGR_CFEN			BIT(0)
+#define RCC_R65CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R65CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R65CIDCFGR_SCID_SHIFT		4
+#define RCC_R65CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R65CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R65SEMCR register fields */
+#define RCC_R65SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R65SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R65SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R66CIDCFGR register fields */
+#define RCC_R66CIDCFGR_CFEN			BIT(0)
+#define RCC_R66CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R66CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R66CIDCFGR_SCID_SHIFT		4
+#define RCC_R66CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R66CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R66SEMCR register fields */
+#define RCC_R66SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R66SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R66SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R67CIDCFGR register fields */
+#define RCC_R67CIDCFGR_CFEN			BIT(0)
+#define RCC_R67CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R67CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R67CIDCFGR_SCID_SHIFT		4
+#define RCC_R67CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R67CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R67SEMCR register fields */
+#define RCC_R67SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R67SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R67SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R68CIDCFGR register fields */
+#define RCC_R68CIDCFGR_CFEN			BIT(0)
+#define RCC_R68CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R68CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R68CIDCFGR_SCID_SHIFT		4
+#define RCC_R68CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R68CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R68SEMCR register fields */
+#define RCC_R68SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R68SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R68SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R69CIDCFGR register fields */
+#define RCC_R69CIDCFGR_CFEN			BIT(0)
+#define RCC_R69CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R69CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R69CIDCFGR_SCID_SHIFT		4
+#define RCC_R69CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R69CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R69SEMCR register fields */
+#define RCC_R69SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R69SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R69SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R70CIDCFGR register fields */
+#define RCC_R70CIDCFGR_CFEN			BIT(0)
+#define RCC_R70CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R70CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R70CIDCFGR_SCID_SHIFT		4
+#define RCC_R70CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R70CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R70SEMCR register fields */
+#define RCC_R70SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R70SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R70SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R71CIDCFGR register fields */
+#define RCC_R71CIDCFGR_CFEN			BIT(0)
+#define RCC_R71CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R71CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R71CIDCFGR_SCID_SHIFT		4
+#define RCC_R71CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R71CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R71SEMCR register fields */
+#define RCC_R71SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R71SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R71SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R72CIDCFGR register fields */
+#define RCC_R72CIDCFGR_CFEN			BIT(0)
+#define RCC_R72CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R72CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R72CIDCFGR_SCID_SHIFT		4
+#define RCC_R72CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R72CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R72SEMCR register fields */
+#define RCC_R72SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R72SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R72SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R73CIDCFGR register fields */
+#define RCC_R73CIDCFGR_CFEN			BIT(0)
+#define RCC_R73CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R73CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R73CIDCFGR_SCID_SHIFT		4
+#define RCC_R73CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R73CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R73SEMCR register fields */
+#define RCC_R73SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R73SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R73SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R74CIDCFGR register fields */
+#define RCC_R74CIDCFGR_CFEN			BIT(0)
+#define RCC_R74CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R74CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R74CIDCFGR_SCID_SHIFT		4
+#define RCC_R74CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R74CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R74SEMCR register fields */
+#define RCC_R74SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R74SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R74SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R75CIDCFGR register fields */
+#define RCC_R75CIDCFGR_CFEN			BIT(0)
+#define RCC_R75CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R75CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R75CIDCFGR_SCID_SHIFT		4
+#define RCC_R75CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R75CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R75SEMCR register fields */
+#define RCC_R75SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R75SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R75SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R76CIDCFGR register fields */
+#define RCC_R76CIDCFGR_CFEN			BIT(0)
+#define RCC_R76CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R76CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R76CIDCFGR_SCID_SHIFT		4
+#define RCC_R76CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R76CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R76SEMCR register fields */
+#define RCC_R76SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R76SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R76SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R77CIDCFGR register fields */
+#define RCC_R77CIDCFGR_CFEN			BIT(0)
+#define RCC_R77CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R77CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R77CIDCFGR_SCID_SHIFT		4
+#define RCC_R77CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R77CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R77SEMCR register fields */
+#define RCC_R77SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R77SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R77SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R78CIDCFGR register fields */
+#define RCC_R78CIDCFGR_CFEN			BIT(0)
+#define RCC_R78CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R78CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R78CIDCFGR_SCID_SHIFT		4
+#define RCC_R78CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R78CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R78SEMCR register fields */
+#define RCC_R78SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R78SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R78SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R79CIDCFGR register fields */
+#define RCC_R79CIDCFGR_CFEN			BIT(0)
+#define RCC_R79CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R79CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R79CIDCFGR_SCID_SHIFT		4
+#define RCC_R79CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R79CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R79SEMCR register fields */
+#define RCC_R79SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R79SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R79SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R80CIDCFGR register fields */
+#define RCC_R80CIDCFGR_CFEN			BIT(0)
+#define RCC_R80CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R80CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R80CIDCFGR_SCID_SHIFT		4
+#define RCC_R80CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R80CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R80SEMCR register fields */
+#define RCC_R80SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R80SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R80SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R81CIDCFGR register fields */
+#define RCC_R81CIDCFGR_CFEN			BIT(0)
+#define RCC_R81CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R81CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R81CIDCFGR_SCID_SHIFT		4
+#define RCC_R81CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R81CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R81SEMCR register fields */
+#define RCC_R81SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R81SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R81SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R82CIDCFGR register fields */
+#define RCC_R82CIDCFGR_CFEN			BIT(0)
+#define RCC_R82CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R82CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R82CIDCFGR_SCID_SHIFT		4
+#define RCC_R82CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R82CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R82SEMCR register fields */
+#define RCC_R82SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R82SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R82SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R83CIDCFGR register fields */
+#define RCC_R83CIDCFGR_CFEN			BIT(0)
+#define RCC_R83CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R83CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R83CIDCFGR_SCID_SHIFT		4
+#define RCC_R83CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R83CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R83SEMCR register fields */
+#define RCC_R83SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R83SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R83SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R84CIDCFGR register fields */
+#define RCC_R84CIDCFGR_CFEN			BIT(0)
+#define RCC_R84CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R84CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R84CIDCFGR_SCID_SHIFT		4
+#define RCC_R84CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R84CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R84SEMCR register fields */
+#define RCC_R84SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R84SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R84SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R85CIDCFGR register fields */
+#define RCC_R85CIDCFGR_CFEN			BIT(0)
+#define RCC_R85CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R85CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R85CIDCFGR_SCID_SHIFT		4
+#define RCC_R85CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R85CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R85SEMCR register fields */
+#define RCC_R85SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R85SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R85SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R86CIDCFGR register fields */
+#define RCC_R86CIDCFGR_CFEN			BIT(0)
+#define RCC_R86CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R86CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R86CIDCFGR_SCID_SHIFT		4
+#define RCC_R86CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R86CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R86SEMCR register fields */
+#define RCC_R86SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R86SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R86SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R87CIDCFGR register fields */
+#define RCC_R87CIDCFGR_CFEN			BIT(0)
+#define RCC_R87CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R87CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R87CIDCFGR_SCID_SHIFT		4
+#define RCC_R87CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R87CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R87SEMCR register fields */
+#define RCC_R87SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R87SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R87SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R88CIDCFGR register fields */
+#define RCC_R88CIDCFGR_CFEN			BIT(0)
+#define RCC_R88CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R88CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R88CIDCFGR_SCID_SHIFT		4
+#define RCC_R88CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R88CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R88SEMCR register fields */
+#define RCC_R88SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R88SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R88SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R89CIDCFGR register fields */
+#define RCC_R89CIDCFGR_CFEN			BIT(0)
+#define RCC_R89CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R89CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R89CIDCFGR_SCID_SHIFT		4
+#define RCC_R89CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R89CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R89SEMCR register fields */
+#define RCC_R89SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R89SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R89SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R90CIDCFGR register fields */
+#define RCC_R90CIDCFGR_CFEN			BIT(0)
+#define RCC_R90CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R90CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R90CIDCFGR_SCID_SHIFT		4
+#define RCC_R90CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R90CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R90SEMCR register fields */
+#define RCC_R90SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R90SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R90SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R91CIDCFGR register fields */
+#define RCC_R91CIDCFGR_CFEN			BIT(0)
+#define RCC_R91CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R91CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R91CIDCFGR_SCID_SHIFT		4
+#define RCC_R91CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R91CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R91SEMCR register fields */
+#define RCC_R91SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R91SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R91SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R92CIDCFGR register fields */
+#define RCC_R92CIDCFGR_CFEN			BIT(0)
+#define RCC_R92CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R92CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R92CIDCFGR_SCID_SHIFT		4
+#define RCC_R92CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R92CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R92SEMCR register fields */
+#define RCC_R92SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R92SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R92SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R93CIDCFGR register fields */
+#define RCC_R93CIDCFGR_CFEN			BIT(0)
+#define RCC_R93CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R93CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R93CIDCFGR_SCID_SHIFT		4
+#define RCC_R93CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R93CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R93SEMCR register fields */
+#define RCC_R93SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R93SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R93SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R94CIDCFGR register fields */
+#define RCC_R94CIDCFGR_CFEN			BIT(0)
+#define RCC_R94CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R94CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R94CIDCFGR_SCID_SHIFT		4
+#define RCC_R94CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R94CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R94SEMCR register fields */
+#define RCC_R94SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R94SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R94SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R95CIDCFGR register fields */
+#define RCC_R95CIDCFGR_CFEN			BIT(0)
+#define RCC_R95CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R95CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R95CIDCFGR_SCID_SHIFT		4
+#define RCC_R95CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R95CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R95SEMCR register fields */
+#define RCC_R95SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R95SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R95SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R96CIDCFGR register fields */
+#define RCC_R96CIDCFGR_CFEN			BIT(0)
+#define RCC_R96CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R96CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R96CIDCFGR_SCID_SHIFT		4
+#define RCC_R96CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R96CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R96SEMCR register fields */
+#define RCC_R96SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R96SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R96SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R97CIDCFGR register fields */
+#define RCC_R97CIDCFGR_CFEN			BIT(0)
+#define RCC_R97CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R97CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R97CIDCFGR_SCID_SHIFT		4
+#define RCC_R97CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R97CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R97SEMCR register fields */
+#define RCC_R97SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R97SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R97SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R98CIDCFGR register fields */
+#define RCC_R98CIDCFGR_CFEN			BIT(0)
+#define RCC_R98CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R98CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R98CIDCFGR_SCID_SHIFT		4
+#define RCC_R98CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R98CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R98SEMCR register fields */
+#define RCC_R98SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R98SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R98SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R99CIDCFGR register fields */
+#define RCC_R99CIDCFGR_CFEN			BIT(0)
+#define RCC_R99CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R99CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R99CIDCFGR_SCID_SHIFT		4
+#define RCC_R99CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R99CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R99SEMCR register fields */
+#define RCC_R99SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R99SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R99SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R100CIDCFGR register fields */
+#define RCC_R100CIDCFGR_CFEN			BIT(0)
+#define RCC_R100CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R100CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R100CIDCFGR_SCID_SHIFT		4
+#define RCC_R100CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R100CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R100SEMCR register fields */
+#define RCC_R100SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R100SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R100SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R101CIDCFGR register fields */
+#define RCC_R101CIDCFGR_CFEN			BIT(0)
+#define RCC_R101CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R101CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R101CIDCFGR_SCID_SHIFT		4
+#define RCC_R101CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R101CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R101SEMCR register fields */
+#define RCC_R101SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R101SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R101SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R102CIDCFGR register fields */
+#define RCC_R102CIDCFGR_CFEN			BIT(0)
+#define RCC_R102CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R102CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R102CIDCFGR_SCID_SHIFT		4
+#define RCC_R102CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R102CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R102SEMCR register fields */
+#define RCC_R102SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R102SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R102SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R103CIDCFGR register fields */
+#define RCC_R103CIDCFGR_CFEN			BIT(0)
+#define RCC_R103CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R103CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R103CIDCFGR_SCID_SHIFT		4
+#define RCC_R103CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R103CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R103SEMCR register fields */
+#define RCC_R103SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R103SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R103SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R104CIDCFGR register fields */
+#define RCC_R104CIDCFGR_CFEN			BIT(0)
+#define RCC_R104CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R104CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R104CIDCFGR_SCID_SHIFT		4
+#define RCC_R104CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R104CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R104SEMCR register fields */
+#define RCC_R104SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R104SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R104SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R105CIDCFGR register fields */
+#define RCC_R105CIDCFGR_CFEN			BIT(0)
+#define RCC_R105CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R105CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R105CIDCFGR_SCID_SHIFT		4
+#define RCC_R105CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R105CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R105SEMCR register fields */
+#define RCC_R105SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R105SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R105SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R106CIDCFGR register fields */
+#define RCC_R106CIDCFGR_CFEN			BIT(0)
+#define RCC_R106CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R106CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R106CIDCFGR_SCID_SHIFT		4
+#define RCC_R106CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R106CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R106SEMCR register fields */
+#define RCC_R106SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R106SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R106SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R107CIDCFGR register fields */
+#define RCC_R107CIDCFGR_CFEN			BIT(0)
+#define RCC_R107CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R107CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R107CIDCFGR_SCID_SHIFT		4
+#define RCC_R107CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R107CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R107SEMCR register fields */
+#define RCC_R107SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R107SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R107SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R108CIDCFGR register fields */
+#define RCC_R108CIDCFGR_CFEN			BIT(0)
+#define RCC_R108CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R108CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R108CIDCFGR_SCID_SHIFT		4
+#define RCC_R108CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R108CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R108SEMCR register fields */
+#define RCC_R108SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R108SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R108SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R109CIDCFGR register fields */
+#define RCC_R109CIDCFGR_CFEN			BIT(0)
+#define RCC_R109CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R109CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R109CIDCFGR_SCID_SHIFT		4
+#define RCC_R109CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R109CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R109SEMCR register fields */
+#define RCC_R109SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R109SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R109SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R110CIDCFGR register fields */
+#define RCC_R110CIDCFGR_CFEN			BIT(0)
+#define RCC_R110CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R110CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R110CIDCFGR_SCID_SHIFT		4
+#define RCC_R110CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R110CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R110SEMCR register fields */
+#define RCC_R110SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R110SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R110SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R111CIDCFGR register fields */
+#define RCC_R111CIDCFGR_CFEN			BIT(0)
+#define RCC_R111CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R111CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R111CIDCFGR_SCID_SHIFT		4
+#define RCC_R111CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R111CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R111SEMCR register fields */
+#define RCC_R111SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R111SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R111SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R112CIDCFGR register fields */
+#define RCC_R112CIDCFGR_CFEN			BIT(0)
+#define RCC_R112CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R112CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R112CIDCFGR_SCID_SHIFT		4
+#define RCC_R112CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R112CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R112SEMCR register fields */
+#define RCC_R112SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R112SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R112SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R113CIDCFGR register fields */
+#define RCC_R113CIDCFGR_CFEN			BIT(0)
+#define RCC_R113CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R113CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R113CIDCFGR_SCID_SHIFT		4
+#define RCC_R113CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R113CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R113SEMCR register fields */
+#define RCC_R113SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R113SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R113SEMCR_SEMCID_SHIFT		4
+
+/* RCC_RxCIDCFGR register fields */
+#define RCC_RxCIDCFGR_CFEN			BIT(0)
+#define RCC_RxCIDCFGR_SEM_EN			BIT(1)
+#define RCC_RxCIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_RxCIDCFGR_SCID_SHIFT		4
+#define RCC_RxCIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_RxCIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_RxSEMCR register fields */
+#define RCC_RxSEMCR_SEM_MUTEX			BIT(0)
+#define RCC_RxSEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_RxSEMCR_SEMCID_SHIFT		4
+
+/* RCC_GRSTCSETR register fields */
+#define RCC_GRSTCSETR_SYSRST			BIT(0)
+
+/* RCC_C1RSTCSETR register fields */
+#define RCC_C1RSTCSETR_C1RST			BIT(0)
+
+/* RCC_C1P1RSTCSETR register fields */
+#define RCC_C1P1RSTCSETR_C1P1PORRST		BIT(0)
+#define RCC_C1P1RSTCSETR_C1P1RST		BIT(1)
+
+/* RCC_C2RSTCSETR register fields */
+#define RCC_C2RSTCSETR_C2RST			BIT(0)
+
+/* RCC_CxRSTCSETR register fields */
+#define RCC_CxRSTCSETR_CxRST			BIT(0)
+
+/* RCC_HWRSTSCLRR register fields */
+#define RCC_HWRSTSCLRR_PORRSTF			BIT(0)
+#define RCC_HWRSTSCLRR_BORRSTF			BIT(1)
+#define RCC_HWRSTSCLRR_PADRSTF			BIT(2)
+#define RCC_HWRSTSCLRR_HCSSRSTF			BIT(3)
+#define RCC_HWRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_HWRSTSCLRR_SYSC1RSTF		BIT(5)
+#define RCC_HWRSTSCLRR_SYSC2RSTF		BIT(6)
+#define RCC_HWRSTSCLRR_IWDG1SYSRSTF		BIT(7)
+#define RCC_HWRSTSCLRR_IWDG2SYSRSTF		BIT(8)
+#define RCC_HWRSTSCLRR_IWDG3SYSRSTF		BIT(9)
+#define RCC_HWRSTSCLRR_IWDG4SYSRSTF		BIT(10)
+#define RCC_HWRSTSCLRR_IWDG5SYSRSTF		BIT(11)
+#define RCC_HWRSTSCLRR_RETCRCERRRSTF		BIT(12)
+#define RCC_HWRSTSCLRR_RETECCFAILCRCRSTF	BIT(13)
+#define RCC_HWRSTSCLRR_RETECCFAILRESTRSTF	BIT(14)
+
+/* RCC_C1HWRSTSCLRR register fields */
+#define RCC_C1HWRSTSCLRR_VCPURSTF		BIT(0)
+#define RCC_C1HWRSTSCLRR_C1RSTF			BIT(1)
+#define RCC_C1HWRSTSCLRR_C1P1RSTF		BIT(2)
+
+/* RCC_C2HWRSTSCLRR register fields */
+#define RCC_C2HWRSTSCLRR_C2RSTF			BIT(0)
+
+/* RCC_C1BOOTRSTSSETR register fields */
+#define RCC_C1BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSSETR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSSETR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSSETR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSSETR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSSETR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1BOOTRSTSCLRR register fields */
+#define RCC_C1BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSCLRR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSCLRR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSCLRR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSCLRR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSCLRR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSSETR register fields */
+#define RCC_C2BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSSETR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSSETR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSCLRR register fields */
+#define RCC_C2BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSCLRR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSCLRR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1SREQSETR register fields */
+#define RCC_C1SREQSETR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQSETR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQSETR_ESLPREQ			BIT(16)
+
+/* RCC_C1SREQCLRR register fields */
+#define RCC_C1SREQCLRR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQCLRR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQCLRR_ESLPREQ			BIT(16)
+
+/* RCC_CPUBOOTCR register fields */
+#define RCC_CPUBOOTCR_BOOT_CPU2			BIT(0)
+#define RCC_CPUBOOTCR_BOOT_CPU1			BIT(1)
+
+/* RCC_STBYBOOTCR register fields */
+#define RCC_STBYBOOTCR_CPU_BEN_SEL		BIT(1)
+#define RCC_STBYBOOTCR_COLD_CPU2		BIT(2)
+#define RCC_STBYBOOTCR_CPU2_HW_BEN		BIT(4)
+#define RCC_STBYBOOTCR_CPU1_HW_BEN		BIT(5)
+#define RCC_STBYBOOTCR_RET_CRCERR_RSTEN		BIT(8)
+
+/* RCC_LEGBOOTCR register fields */
+#define RCC_LEGBOOTCR_LEGACY_BEN		BIT(0)
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON				BIT(0)
+#define RCC_BDCR_LSEBYP				BIT(1)
+#define RCC_BDCR_LSERDY				BIT(2)
+#define RCC_BDCR_LSEDIGBYP			BIT(3)
+#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSECSSON			BIT(6)
+#define RCC_BDCR_LSEGFON			BIT(7)
+#define RCC_BDCR_LSECSSD			BIT(8)
+#define RCC_BDCR_LSION				BIT(9)
+#define RCC_BDCR_LSIRDY				BIT(10)
+#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
+#define RCC_BDCR_RTCSRC_SHIFT			16
+#define RCC_BDCR_RTCCKEN			BIT(20)
+#define RCC_BDCR_MSIFREQSEL			BIT(24)
+#define RCC_BDCR_C3SYSTICKSEL			BIT(25)
+#define RCC_BDCR_VSWRST				BIT(31)
+#define RCC_BDCR_LSEBYP_BIT			1
+#define RCC_BDCR_LSEDIGBYP_BIT			3
+#define RCC_BDCR_LSECSSON_BIT			6
+#define RCC_BDCR_LSERDY_BIT			2
+#define RCC_BDCR_LSIRDY_BIT			10
+
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSEDRV_WIDTH			2
+
+/* RCC_D3DCR register fields */
+#define RCC_D3DCR_MSION				BIT(0)
+#define RCC_D3DCR_MSIKERON			BIT(1)
+#define RCC_D3DCR_MSIRDY			BIT(2)
+#define RCC_D3DCR_D3PERCKSEL_MASK		GENMASK(17, 16)
+#define RCC_D3DCR_D3PERCKSEL_SHIFT		16
+#define RCC_D3DCR_MSIRDY_BIT			2
+
+/* RCC_D3DSR register fields */
+#define RCC_D3DSR_D3STATE_MASK			GENMASK(1, 0)
+#define RCC_D3DSR_D3STATE_SHIFT			0
+
+/* RCC_RDCR register fields */
+#define RCC_RDCR_MRD_MASK			GENMASK(20, 16)
+#define RCC_RDCR_MRD_SHIFT			16
+#define RCC_RDCR_EADLY_MASK			GENMASK(27, 24)
+#define RCC_RDCR_EADLY_SHIFT			24
+
+/* RCC_C1MSRDCR register fields */
+#define RCC_C1MSRDCR_C1MSRD_MASK		GENMASK(4, 0)
+#define RCC_C1MSRDCR_C1MSRD_SHIFT		0
+#define RCC_C1MSRDCR_C1MSRST			BIT(8)
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
+#define RCC_PWRLPDLYCR_CPU2TMPSKP		BIT(24)
+
+/* RCC_C1CIESETR register fields */
+#define RCC_C1CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C1CIESETR_LSERDYIE			BIT(1)
+#define RCC_C1CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C1CIESETR_HSERDYIE			BIT(3)
+#define RCC_C1CIESETR_MSIRDYIE			BIT(4)
+#define RCC_C1CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C1CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C1CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C1CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C1CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C1CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C1CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C1CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C1CIESETR_LSECSSIE			BIT(16)
+#define RCC_C1CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C1CIFCLRR register fields */
+#define RCC_C1CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C1CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C1CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C1CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C1CIFCLRR_MSIRDYF			BIT(4)
+#define RCC_C1CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C1CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C1CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C1CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C1CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C1CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C1CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C1CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C1CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C1CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_C2CIESETR register fields */
+#define RCC_C2CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C2CIESETR_LSERDYIE			BIT(1)
+#define RCC_C2CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C2CIESETR_HSERDYIE			BIT(3)
+#define RCC_C2CIESETR_MSIRDYIE			BIT(4)
+#define RCC_C2CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C2CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C2CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C2CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C2CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C2CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C2CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C2CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C2CIESETR_LSECSSIE			BIT(16)
+#define RCC_C2CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C2CIFCLRR register fields */
+#define RCC_C2CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C2CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C2CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C2CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C2CIFCLRR_MSIRDYF			BIT(4)
+#define RCC_C2CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C2CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C2CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C2CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C2CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C2CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C2CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C2CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C2CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C2CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_CxCIESETR register fields */
+#define RCC_CxCIESETR_LSIRDYIE			BIT(0)
+#define RCC_CxCIESETR_LSERDYIE			BIT(1)
+#define RCC_CxCIESETR_HSIRDYIE			BIT(2)
+#define RCC_CxCIESETR_HSERDYIE			BIT(3)
+#define RCC_CxCIESETR_MSIRDYIE			BIT(4)
+#define RCC_CxCIESETR_SHSIRDYIE			BIT(5)
+#define RCC_CxCIESETR_PLL1RDYIE			BIT(6)
+#define RCC_CxCIESETR_PLL2RDYIE			BIT(7)
+#define RCC_CxCIESETR_PLL3RDYIE			BIT(8)
+#define RCC_CxCIESETR_PLL4RDYIE			BIT(9)
+#define RCC_CxCIESETR_PLL5RDYIE			BIT(10)
+#define RCC_CxCIESETR_PLL6RDYIE			BIT(11)
+#define RCC_CxCIESETR_PLL7RDYIE			BIT(12)
+#define RCC_CxCIESETR_PLL8RDYIE			BIT(13)
+#define RCC_CxCIESETR_LSECSSIE			BIT(16)
+#define RCC_CxCIESETR_WKUPIE			BIT(20)
+
+/* RCC_CxCIFCLRR register fields */
+#define RCC_CxCIFCLRR_LSIRDYF			BIT(0)
+#define RCC_CxCIFCLRR_LSERDYF			BIT(1)
+#define RCC_CxCIFCLRR_HSIRDYF			BIT(2)
+#define RCC_CxCIFCLRR_HSERDYF			BIT(3)
+#define RCC_CxCIFCLRR_MSIRDYF			BIT(4)
+#define RCC_CxCIFCLRR_SHSIRDYF			BIT(5)
+#define RCC_CxCIFCLRR_PLL1RDYF			BIT(6)
+#define RCC_CxCIFCLRR_PLL2RDYF			BIT(7)
+#define RCC_CxCIFCLRR_PLL3RDYF			BIT(8)
+#define RCC_CxCIFCLRR_PLL4RDYF			BIT(9)
+#define RCC_CxCIFCLRR_PLL5RDYF			BIT(10)
+#define RCC_CxCIFCLRR_PLL6RDYF			BIT(11)
+#define RCC_CxCIFCLRR_PLL7RDYF			BIT(12)
+#define RCC_CxCIFCLRR_PLL8RDYF			BIT(13)
+#define RCC_CxCIFCLRR_LSECSSF			BIT(16)
+#define RCC_CxCIFCLRR_WKUPF			BIT(20)
+
+/* RCC_IWDGC1FZSETR register fields */
+#define RCC_IWDGC1FZSETR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZSETR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1FZCLRR register fields */
+#define RCC_IWDGC1FZCLRR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZCLRR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1CFGSETR register fields */
+#define RCC_IWDGC1CFGSETR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGSETR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGSETR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC1CFGCLRR register fields */
+#define RCC_IWDGC1CFGCLRR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGCLRR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGCLRR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC2FZSETR register fields */
+#define RCC_IWDGC2FZSETR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZSETR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2FZCLRR register fields */
+#define RCC_IWDGC2FZCLRR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZCLRR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2CFGSETR register fields */
+#define RCC_IWDGC2CFGSETR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGSETR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGSETR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC2CFGCLRR register fields */
+#define RCC_IWDGC2CFGCLRR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGCLRR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGCLRR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC3CFGSETR register fields */
+#define RCC_IWDGC3CFGSETR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_IWDGC3CFGCLRR register fields */
+#define RCC_IWDGC3CFGCLRR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_C3CFGR register fields */
+#define RCC_C3CFGR_C3RST			BIT(0)
+#define RCC_C3CFGR_C3EN				BIT(1)
+#define RCC_C3CFGR_C3LPEN			BIT(2)
+#define RCC_C3CFGR_C3AMEN			BIT(3)
+#define RCC_C3CFGR_LPTIM3C3EN			BIT(16)
+#define RCC_C3CFGR_LPTIM4C3EN			BIT(17)
+#define RCC_C3CFGR_LPTIM5C3EN			BIT(18)
+#define RCC_C3CFGR_SPI8C3EN			BIT(19)
+#define RCC_C3CFGR_LPUART1C3EN			BIT(20)
+#define RCC_C3CFGR_I2C8C3EN			BIT(21)
+#define RCC_C3CFGR_ADF1C3EN			BIT(23)
+#define RCC_C3CFGR_GPIOZC3EN			BIT(24)
+#define RCC_C3CFGR_LPDMAC3EN			BIT(25)
+#define RCC_C3CFGR_RTCC3EN			BIT(26)
+#define RCC_C3CFGR_I3C4C3EN			BIT(27)
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL			BIT(0)
+#define RCC_MCO1CFGR_MCO1ON			BIT(8)
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL			BIT(0)
+#define RCC_MCO2CFGR_MCO2ON			BIT(8)
+
+/* RCC_MCOxCFGR register fields */
+#define RCC_MCOxCFGR_MCOxSEL			BIT(0)
+#define RCC_MCOxCFGR_MCOxON			BIT(8)
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION			BIT(0)
+#define RCC_OCENSETR_HSIKERON			BIT(1)
+#define RCC_OCENSETR_HSEDIV2ON			BIT(5)
+#define RCC_OCENSETR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENSETR_HSEDIGBYP			BIT(7)
+#define RCC_OCENSETR_HSEON			BIT(8)
+#define RCC_OCENSETR_HSEKERON			BIT(9)
+#define RCC_OCENSETR_HSEBYP			BIT(10)
+#define RCC_OCENSETR_HSECSSON			BIT(11)
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION			BIT(0)
+#define RCC_OCENCLRR_HSIKERON			BIT(1)
+#define RCC_OCENCLRR_HSEDIV2ON			BIT(5)
+#define RCC_OCENCLRR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENCLRR_HSEDIGBYP			BIT(7)
+#define RCC_OCENCLRR_HSEON			BIT(8)
+#define RCC_OCENCLRR_HSEKERON			BIT(9)
+#define RCC_OCENCLRR_HSEBYP			BIT(10)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY			BIT(0)
+#define RCC_OCRDYR_HSERDY			BIT(8)
+#define RCC_OCRDYR_CKREST			BIT(25)
+
+#define RCC_OCRDYR_HSIRDY_BIT			0
+#define RCC_OCRDYR_HSERDY_BIT			8
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
+#define RCC_HSICFGR_HSITRIM_SHIFT		8
+#define RCC_HSICFGR_HSICAL_MASK			GENMASK(24, 16)
+#define RCC_HSICFGR_HSICAL_SHIFT		16
+
+/* osc_data register fields */
+#define RCC_MSICFGR_MSITRIM_MASK		GENMASK(12, 8)
+#define RCC_MSICFGR_MSITRIM_SHIFT		8
+#define RCC_MSICFGR_MSICAL_MASK			GENMASK(23, 16)
+#define RCC_MSICFGR_MSICAL_SHIFT		16
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT		0
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIV_SHIFT		0
+#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIV_SHIFT		0
+#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIV_SHIFT		0
+#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIV_SHIFT		0
+#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
+
+/* RCC_APBDBGDIVR register fields */
+#define RCC_APBDBGDIVR_APBDBGDIV_MASK		GENMASK(2, 0)
+#define RCC_APBDBGDIVR_APBDBGDIV_SHIFT		0
+#define RCC_APBDBGDIVR_APBDBGDIVRDY		BIT(31)
+
+/* RCC_APBxDIVR register fields */
+#define RCC_APBxDIVR_APBxDIV_MASK		GENMASK(2, 0)
+#define RCC_APBxDIVR_APBxDIV_SHIFT		0
+#define RCC_APBxDIVR_APBxDIVRDY			BIT(31)
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
+
+/* RCC_TIMGxPRER register fields */
+#define RCC_TIMGxPRER_TIMGxPRE			BIT(0)
+#define RCC_TIMGxPRER_TIMGxPRERDY		BIT(31)
+
+/* RCC_LSMCUDIVR register fields */
+#define RCC_LSMCUDIVR_LSMCUDIV			BIT(0)
+#define RCC_LSMCUDIVR_LSMCUDIVRDY		BIT(31)
+
+/* RCC_DDRCPCFGR register fields */
+#define RCC_DDRCPCFGR_DDRCPRST			BIT(0)
+#define RCC_DDRCPCFGR_DDRCPEN			BIT(1)
+#define RCC_DDRCPCFGR_DDRCPLPEN			BIT(2)
+
+/* RCC_DDRCAPBCFGR register fields */
+#define RCC_DDRCAPBCFGR_DDRCAPBRST		BIT(0)
+#define RCC_DDRCAPBCFGR_DDRCAPBEN		BIT(1)
+#define RCC_DDRCAPBCFGR_DDRCAPBLPEN		BIT(2)
+
+/* RCC_DDRPHYCAPBCFGR register fields */
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST	BIT(0)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN		BIT(1)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN	BIT(2)
+
+/* RCC_DDRPHYCCFGR register fields */
+#define RCC_DDRPHYCCFGR_DDRPHYCEN		BIT(1)
+
+/* RCC_DDRCFGR register fields */
+#define RCC_DDRCFGR_DDRCFGRST			BIT(0)
+#define RCC_DDRCFGR_DDRCFGEN			BIT(1)
+#define RCC_DDRCFGR_DDRCFGLPEN			BIT(2)
+
+/* RCC_DDRITFCFGR register fields */
+#define RCC_DDRITFCFGR_DDRRST			BIT(0)
+#define RCC_DDRITFCFGR_DDRCKMOD_MASK		GENMASK(5, 4)
+#define RCC_DDRITFCFGR_DDRCKMOD_SHIFT		4
+#define RCC_DDRITFCFGR_DDRSHR			BIT(8)
+#define RCC_DDRITFCFGR_DDRPHYDLP		BIT(16)
+
+/* RCC_SYSRAMCFGR register fields */
+#define RCC_SYSRAMCFGR_SYSRAMEN			BIT(1)
+#define RCC_SYSRAMCFGR_SYSRAMLPEN		BIT(2)
+
+/* RCC_VDERAMCFGR register fields */
+#define RCC_VDERAMCFGR_VDERAMEN			BIT(1)
+#define RCC_VDERAMCFGR_VDERAMLPEN		BIT(2)
+
+/* RCC_SRAM1CFGR register fields */
+#define RCC_SRAM1CFGR_SRAM1EN			BIT(1)
+#define RCC_SRAM1CFGR_SRAM1LPEN			BIT(2)
+
+/* RCC_SRAM2CFGR register fields */
+#define RCC_SRAM2CFGR_SRAM2EN			BIT(1)
+#define RCC_SRAM2CFGR_SRAM2LPEN			BIT(2)
+
+/* RCC_RETRAMCFGR register fields */
+#define RCC_RETRAMCFGR_RETRAMEN			BIT(1)
+#define RCC_RETRAMCFGR_RETRAMLPEN		BIT(2)
+
+/* RCC_BKPSRAMCFGR register fields */
+#define RCC_BKPSRAMCFGR_BKPSRAMEN		BIT(1)
+#define RCC_BKPSRAMCFGR_BKPSRAMLPEN		BIT(2)
+
+/* RCC_LPSRAM1CFGR register fields */
+#define RCC_LPSRAM1CFGR_LPSRAM1EN		BIT(1)
+#define RCC_LPSRAM1CFGR_LPSRAM1LPEN		BIT(2)
+#define RCC_LPSRAM1CFGR_LPSRAM1AMEN		BIT(3)
+
+/* RCC_LPSRAM2CFGR register fields */
+#define RCC_LPSRAM2CFGR_LPSRAM2EN		BIT(1)
+#define RCC_LPSRAM2CFGR_LPSRAM2LPEN		BIT(2)
+#define RCC_LPSRAM2CFGR_LPSRAM2AMEN		BIT(3)
+
+/* RCC_LPSRAM3CFGR register fields */
+#define RCC_LPSRAM3CFGR_LPSRAM3EN		BIT(1)
+#define RCC_LPSRAM3CFGR_LPSRAM3LPEN		BIT(2)
+#define RCC_LPSRAM3CFGR_LPSRAM3AMEN		BIT(3)
+
+/* RCC_OSPI1CFGR register fields */
+#define RCC_OSPI1CFGR_OSPI1RST			BIT(0)
+#define RCC_OSPI1CFGR_OSPI1EN			BIT(1)
+#define RCC_OSPI1CFGR_OSPI1LPEN			BIT(2)
+#define RCC_OSPI1CFGR_OTFDEC1RST		BIT(8)
+#define RCC_OSPI1CFGR_OSPI1DLLRST		BIT(16)
+
+/* RCC_OSPI2CFGR register fields */
+#define RCC_OSPI2CFGR_OSPI2RST			BIT(0)
+#define RCC_OSPI2CFGR_OSPI2EN			BIT(1)
+#define RCC_OSPI2CFGR_OSPI2LPEN			BIT(2)
+#define RCC_OSPI2CFGR_OTFDEC2RST		BIT(8)
+#define RCC_OSPI2CFGR_OSPI2DLLRST		BIT(16)
+
+/* RCC_OSPIxCFGR register fields */
+#define RCC_OSPIxCFGR_OSPIxRST			BIT(0)
+#define RCC_OSPIxCFGR_OSPIxEN			BIT(1)
+#define RCC_OSPIxCFGR_OSPIxLPEN			BIT(2)
+#define RCC_OSPIxCFGR_OTFDECxRST		BIT(8)
+#define RCC_OSPIxCFGR_OSPIxDLLRST		BIT(16)
+
+/* RCC_FMCCFGR register fields */
+#define RCC_FMCCFGR_FMCRST			BIT(0)
+#define RCC_FMCCFGR_FMCEN			BIT(1)
+#define RCC_FMCCFGR_FMCLPEN			BIT(2)
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_DBGEN			BIT(8)
+#define RCC_DBGCFGR_TRACEEN			BIT(9)
+#define RCC_DBGCFGR_DBGRST			BIT(12)
+
+/* RCC_STMCFGR register fields */
+#define RCC_STMCFGR_STMEN			BIT(1)
+#define RCC_STMCFGR_STMLPEN			BIT(2)
+
+/* RCC_ETRCFGR register fields */
+#define RCC_ETRCFGR_ETREN			BIT(1)
+#define RCC_ETRCFGR_ETRLPEN			BIT(2)
+
+/* RCC_GPIOACFGR register fields */
+#define RCC_GPIOACFGR_GPIOARST			BIT(0)
+#define RCC_GPIOACFGR_GPIOAEN			BIT(1)
+#define RCC_GPIOACFGR_GPIOALPEN			BIT(2)
+
+/* RCC_GPIOBCFGR register fields */
+#define RCC_GPIOBCFGR_GPIOBRST			BIT(0)
+#define RCC_GPIOBCFGR_GPIOBEN			BIT(1)
+#define RCC_GPIOBCFGR_GPIOBLPEN			BIT(2)
+
+/* RCC_GPIOCCFGR register fields */
+#define RCC_GPIOCCFGR_GPIOCRST			BIT(0)
+#define RCC_GPIOCCFGR_GPIOCEN			BIT(1)
+#define RCC_GPIOCCFGR_GPIOCLPEN			BIT(2)
+
+/* RCC_GPIODCFGR register fields */
+#define RCC_GPIODCFGR_GPIODRST			BIT(0)
+#define RCC_GPIODCFGR_GPIODEN			BIT(1)
+#define RCC_GPIODCFGR_GPIODLPEN			BIT(2)
+
+/* RCC_GPIOECFGR register fields */
+#define RCC_GPIOECFGR_GPIOERST			BIT(0)
+#define RCC_GPIOECFGR_GPIOEEN			BIT(1)
+#define RCC_GPIOECFGR_GPIOELPEN			BIT(2)
+
+/* RCC_GPIOFCFGR register fields */
+#define RCC_GPIOFCFGR_GPIOFRST			BIT(0)
+#define RCC_GPIOFCFGR_GPIOFEN			BIT(1)
+#define RCC_GPIOFCFGR_GPIOFLPEN			BIT(2)
+
+/* RCC_GPIOGCFGR register fields */
+#define RCC_GPIOGCFGR_GPIOGRST			BIT(0)
+#define RCC_GPIOGCFGR_GPIOGEN			BIT(1)
+#define RCC_GPIOGCFGR_GPIOGLPEN			BIT(2)
+
+/* RCC_GPIOHCFGR register fields */
+#define RCC_GPIOHCFGR_GPIOHRST			BIT(0)
+#define RCC_GPIOHCFGR_GPIOHEN			BIT(1)
+#define RCC_GPIOHCFGR_GPIOHLPEN			BIT(2)
+
+/* RCC_GPIOICFGR register fields */
+#define RCC_GPIOICFGR_GPIOIRST			BIT(0)
+#define RCC_GPIOICFGR_GPIOIEN			BIT(1)
+#define RCC_GPIOICFGR_GPIOILPEN			BIT(2)
+
+/* RCC_GPIOJCFGR register fields */
+#define RCC_GPIOJCFGR_GPIOJRST			BIT(0)
+#define RCC_GPIOJCFGR_GPIOJEN			BIT(1)
+#define RCC_GPIOJCFGR_GPIOJLPEN			BIT(2)
+
+/* RCC_GPIOKCFGR register fields */
+#define RCC_GPIOKCFGR_GPIOKRST			BIT(0)
+#define RCC_GPIOKCFGR_GPIOKEN			BIT(1)
+#define RCC_GPIOKCFGR_GPIOKLPEN			BIT(2)
+
+/* RCC_GPIOZCFGR register fields */
+#define RCC_GPIOZCFGR_GPIOZRST			BIT(0)
+#define RCC_GPIOZCFGR_GPIOZEN			BIT(1)
+#define RCC_GPIOZCFGR_GPIOZLPEN			BIT(2)
+#define RCC_GPIOZCFGR_GPIOZAMEN			BIT(3)
+
+/* RCC_GPIOxCFGR register fields */
+#define RCC_GPIOxCFGR_GPIOxRST			BIT(0)
+#define RCC_GPIOxCFGR_GPIOxEN			BIT(1)
+#define RCC_GPIOxCFGR_GPIOxLPEN			BIT(2)
+#define RCC_GPIOxCFGR_GPIOxAMEN			BIT(3)
+
+/* RCC_HPDMA1CFGR register fields */
+#define RCC_HPDMA1CFGR_HPDMA1RST		BIT(0)
+#define RCC_HPDMA1CFGR_HPDMA1EN			BIT(1)
+#define RCC_HPDMA1CFGR_HPDMA1LPEN		BIT(2)
+
+/* RCC_HPDMA2CFGR register fields */
+#define RCC_HPDMA2CFGR_HPDMA2RST		BIT(0)
+#define RCC_HPDMA2CFGR_HPDMA2EN			BIT(1)
+#define RCC_HPDMA2CFGR_HPDMA2LPEN		BIT(2)
+
+/* RCC_HPDMA3CFGR register fields */
+#define RCC_HPDMA3CFGR_HPDMA3RST		BIT(0)
+#define RCC_HPDMA3CFGR_HPDMA3EN			BIT(1)
+#define RCC_HPDMA3CFGR_HPDMA3LPEN		BIT(2)
+
+/* RCC_HPDMAxCFGR register fields */
+#define RCC_HPDMAxCFGR_HPDMAxRST		BIT(0)
+#define RCC_HPDMAxCFGR_HPDMAxEN			BIT(1)
+#define RCC_HPDMAxCFGR_HPDMAxLPEN		BIT(2)
+
+/* RCC_LPDMACFGR register fields */
+#define RCC_LPDMACFGR_LPDMARST			BIT(0)
+#define RCC_LPDMACFGR_LPDMAEN			BIT(1)
+#define RCC_LPDMACFGR_LPDMALPEN			BIT(2)
+#define RCC_LPDMACFGR_LPDMAAMEN			BIT(3)
+
+/* RCC_HSEMCFGR register fields */
+#define RCC_HSEMCFGR_HSEMRST			BIT(0)
+#define RCC_HSEMCFGR_HSEMEN			BIT(1)
+#define RCC_HSEMCFGR_HSEMLPEN			BIT(2)
+#define RCC_HSEMCFGR_HSEMAMEN			BIT(3)
+
+/* RCC_IPCC1CFGR register fields */
+#define RCC_IPCC1CFGR_IPCC1RST			BIT(0)
+#define RCC_IPCC1CFGR_IPCC1EN			BIT(1)
+#define RCC_IPCC1CFGR_IPCC1LPEN			BIT(2)
+
+/* RCC_IPCC2CFGR register fields */
+#define RCC_IPCC2CFGR_IPCC2RST			BIT(0)
+#define RCC_IPCC2CFGR_IPCC2EN			BIT(1)
+#define RCC_IPCC2CFGR_IPCC2LPEN			BIT(2)
+#define RCC_IPCC2CFGR_IPCC2AMEN			BIT(3)
+
+/* RCC_RTCCFGR register fields */
+#define RCC_RTCCFGR_RTCEN			BIT(1)
+#define RCC_RTCCFGR_RTCLPEN			BIT(2)
+#define RCC_RTCCFGR_RTCAMEN			BIT(3)
+
+/* RCC_SYSCPU1CFGR register fields */
+#define RCC_SYSCPU1CFGR_SYSCPU1EN		BIT(1)
+#define RCC_SYSCPU1CFGR_SYSCPU1LPEN		BIT(2)
+
+/* RCC_BSECCFGR register fields */
+#define RCC_BSECCFGR_BSECEN			BIT(1)
+#define RCC_BSECCFGR_BSECLPEN			BIT(2)
+
+/* RCC_IS2MCFGR register fields */
+#define RCC_IS2MCFGR_IS2MRST			BIT(0)
+#define RCC_IS2MCFGR_IS2MEN			BIT(1)
+#define RCC_IS2MCFGR_IS2MLPEN			BIT(2)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL2CFGR1_PLLEN			BIT(8)
+#define RCC_PLL2CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL2CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL2CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL2CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL2CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL2CFGR3 register fields */
+#define RCC_PLL2CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL2CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL2CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL2CFGR3_DACEN			BIT(25)
+#define RCC_PLL2CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL2CFGR4 register fields */
+#define RCC_PLL2CFGR4_DSMEN			BIT(8)
+#define RCC_PLL2CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL2CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL2CFGR5 register fields */
+#define RCC_PLL2CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL2CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL2CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL2CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL2CFGR6 register fields */
+#define RCC_PLL2CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL2CFGR7 register fields */
+#define RCC_PLL2CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL3CFGR1_PLLEN			BIT(8)
+#define RCC_PLL3CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL3CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL3CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL3CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL3CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL3CFGR3 register fields */
+#define RCC_PLL3CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL3CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL3CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL3CFGR3_DACEN			BIT(25)
+#define RCC_PLL3CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL3CFGR4 register fields */
+#define RCC_PLL3CFGR4_DSMEN			BIT(8)
+#define RCC_PLL3CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL3CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL3CFGR5 register fields */
+#define RCC_PLL3CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL3CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL3CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL3CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL3CFGR6 register fields */
+#define RCC_PLL3CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL3CFGR7 register fields */
+#define RCC_PLL3CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_HSIFMONCR register fields */
+#define RCC_HSIFMONCR_HSIREF_MASK		GENMASK(10, 0)
+#define RCC_HSIFMONCR_HSIREF_SHIFT		0
+#define RCC_HSIFMONCR_HSIMONEN			BIT(15)
+#define RCC_HSIFMONCR_HSIDEV_MASK		GENMASK(21, 16)
+#define RCC_HSIFMONCR_HSIDEV_SHIFT		16
+#define RCC_HSIFMONCR_HSIMONIE			BIT(30)
+#define RCC_HSIFMONCR_HSIMONF			BIT(31)
+
+/* RCC_HSIFVALR register fields */
+#define RCC_HSIFVALR_HSIVAL_MASK		GENMASK(10, 0)
+#define RCC_HSIFVALR_HSIVAL_SHIFT		0
+
+/* RCC_TIM1CFGR register fields */
+#define RCC_TIM1CFGR_TIM1RST			BIT(0)
+#define RCC_TIM1CFGR_TIM1EN			BIT(1)
+#define RCC_TIM1CFGR_TIM1LPEN			BIT(2)
+
+/* RCC_TIM2CFGR register fields */
+#define RCC_TIM2CFGR_TIM2RST			BIT(0)
+#define RCC_TIM2CFGR_TIM2EN			BIT(1)
+#define RCC_TIM2CFGR_TIM2LPEN			BIT(2)
+
+/* RCC_TIM3CFGR register fields */
+#define RCC_TIM3CFGR_TIM3RST			BIT(0)
+#define RCC_TIM3CFGR_TIM3EN			BIT(1)
+#define RCC_TIM3CFGR_TIM3LPEN			BIT(2)
+
+/* RCC_TIM4CFGR register fields */
+#define RCC_TIM4CFGR_TIM4RST			BIT(0)
+#define RCC_TIM4CFGR_TIM4EN			BIT(1)
+#define RCC_TIM4CFGR_TIM4LPEN			BIT(2)
+
+/* RCC_TIM5CFGR register fields */
+#define RCC_TIM5CFGR_TIM5RST			BIT(0)
+#define RCC_TIM5CFGR_TIM5EN			BIT(1)
+#define RCC_TIM5CFGR_TIM5LPEN			BIT(2)
+
+/* RCC_TIM6CFGR register fields */
+#define RCC_TIM6CFGR_TIM6RST			BIT(0)
+#define RCC_TIM6CFGR_TIM6EN			BIT(1)
+#define RCC_TIM6CFGR_TIM6LPEN			BIT(2)
+
+/* RCC_TIM7CFGR register fields */
+#define RCC_TIM7CFGR_TIM7RST			BIT(0)
+#define RCC_TIM7CFGR_TIM7EN			BIT(1)
+#define RCC_TIM7CFGR_TIM7LPEN			BIT(2)
+
+/* RCC_TIM8CFGR register fields */
+#define RCC_TIM8CFGR_TIM8RST			BIT(0)
+#define RCC_TIM8CFGR_TIM8EN			BIT(1)
+#define RCC_TIM8CFGR_TIM8LPEN			BIT(2)
+
+/* RCC_TIM10CFGR register fields */
+#define RCC_TIM10CFGR_TIM10RST			BIT(0)
+#define RCC_TIM10CFGR_TIM10EN			BIT(1)
+#define RCC_TIM10CFGR_TIM10LPEN			BIT(2)
+
+/* RCC_TIM11CFGR register fields */
+#define RCC_TIM11CFGR_TIM11RST			BIT(0)
+#define RCC_TIM11CFGR_TIM11EN			BIT(1)
+#define RCC_TIM11CFGR_TIM11LPEN			BIT(2)
+
+/* RCC_TIM12CFGR register fields */
+#define RCC_TIM12CFGR_TIM12RST			BIT(0)
+#define RCC_TIM12CFGR_TIM12EN			BIT(1)
+#define RCC_TIM12CFGR_TIM12LPEN			BIT(2)
+
+/* RCC_TIM13CFGR register fields */
+#define RCC_TIM13CFGR_TIM13RST			BIT(0)
+#define RCC_TIM13CFGR_TIM13EN			BIT(1)
+#define RCC_TIM13CFGR_TIM13LPEN			BIT(2)
+
+/* RCC_TIM14CFGR register fields */
+#define RCC_TIM14CFGR_TIM14RST			BIT(0)
+#define RCC_TIM14CFGR_TIM14EN			BIT(1)
+#define RCC_TIM14CFGR_TIM14LPEN			BIT(2)
+
+/* RCC_TIM15CFGR register fields */
+#define RCC_TIM15CFGR_TIM15RST			BIT(0)
+#define RCC_TIM15CFGR_TIM15EN			BIT(1)
+#define RCC_TIM15CFGR_TIM15LPEN			BIT(2)
+
+/* RCC_TIM16CFGR register fields */
+#define RCC_TIM16CFGR_TIM16RST			BIT(0)
+#define RCC_TIM16CFGR_TIM16EN			BIT(1)
+#define RCC_TIM16CFGR_TIM16LPEN			BIT(2)
+
+/* RCC_TIM17CFGR register fields */
+#define RCC_TIM17CFGR_TIM17RST			BIT(0)
+#define RCC_TIM17CFGR_TIM17EN			BIT(1)
+#define RCC_TIM17CFGR_TIM17LPEN			BIT(2)
+
+/* RCC_TIM20CFGR register fields */
+#define RCC_TIM20CFGR_TIM20RST			BIT(0)
+#define RCC_TIM20CFGR_TIM20EN			BIT(1)
+#define RCC_TIM20CFGR_TIM20LPEN			BIT(2)
+
+/* RCC_LPTIM1CFGR register fields */
+#define RCC_LPTIM1CFGR_LPTIM1RST		BIT(0)
+#define RCC_LPTIM1CFGR_LPTIM1EN			BIT(1)
+#define RCC_LPTIM1CFGR_LPTIM1LPEN		BIT(2)
+
+/* RCC_LPTIM2CFGR register fields */
+#define RCC_LPTIM2CFGR_LPTIM2RST		BIT(0)
+#define RCC_LPTIM2CFGR_LPTIM2EN			BIT(1)
+#define RCC_LPTIM2CFGR_LPTIM2LPEN		BIT(2)
+
+/* RCC_LPTIM3CFGR register fields */
+#define RCC_LPTIM3CFGR_LPTIM3RST		BIT(0)
+#define RCC_LPTIM3CFGR_LPTIM3EN			BIT(1)
+#define RCC_LPTIM3CFGR_LPTIM3LPEN		BIT(2)
+#define RCC_LPTIM3CFGR_LPTIM3AMEN		BIT(3)
+
+/* RCC_LPTIM4CFGR register fields */
+#define RCC_LPTIM4CFGR_LPTIM4RST		BIT(0)
+#define RCC_LPTIM4CFGR_LPTIM4EN			BIT(1)
+#define RCC_LPTIM4CFGR_LPTIM4LPEN		BIT(2)
+#define RCC_LPTIM4CFGR_LPTIM4AMEN		BIT(3)
+
+/* RCC_LPTIM5CFGR register fields */
+#define RCC_LPTIM5CFGR_LPTIM5RST		BIT(0)
+#define RCC_LPTIM5CFGR_LPTIM5EN			BIT(1)
+#define RCC_LPTIM5CFGR_LPTIM5LPEN		BIT(2)
+#define RCC_LPTIM5CFGR_LPTIM5AMEN		BIT(3)
+
+/* RCC_LPTIMxCFGR register fields */
+#define RCC_LPTIMxCFGR_LPTIMxRST		BIT(0)
+#define RCC_LPTIMxCFGR_LPTIMxEN			BIT(1)
+#define RCC_LPTIMxCFGR_LPTIMxLPEN		BIT(2)
+#define RCC_LPTIMxCFGR_LPTIMxAMEN		BIT(3)
+
+/* RCC_SPI1CFGR register fields */
+#define RCC_SPI1CFGR_SPI1RST			BIT(0)
+#define RCC_SPI1CFGR_SPI1EN			BIT(1)
+#define RCC_SPI1CFGR_SPI1LPEN			BIT(2)
+
+/* RCC_SPI2CFGR register fields */
+#define RCC_SPI2CFGR_SPI2RST			BIT(0)
+#define RCC_SPI2CFGR_SPI2EN			BIT(1)
+#define RCC_SPI2CFGR_SPI2LPEN			BIT(2)
+
+/* RCC_SPI3CFGR register fields */
+#define RCC_SPI3CFGR_SPI3RST			BIT(0)
+#define RCC_SPI3CFGR_SPI3EN			BIT(1)
+#define RCC_SPI3CFGR_SPI3LPEN			BIT(2)
+
+/* RCC_SPI4CFGR register fields */
+#define RCC_SPI4CFGR_SPI4RST			BIT(0)
+#define RCC_SPI4CFGR_SPI4EN			BIT(1)
+#define RCC_SPI4CFGR_SPI4LPEN			BIT(2)
+
+/* RCC_SPI5CFGR register fields */
+#define RCC_SPI5CFGR_SPI5RST			BIT(0)
+#define RCC_SPI5CFGR_SPI5EN			BIT(1)
+#define RCC_SPI5CFGR_SPI5LPEN			BIT(2)
+
+/* RCC_SPI6CFGR register fields */
+#define RCC_SPI6CFGR_SPI6RST			BIT(0)
+#define RCC_SPI6CFGR_SPI6EN			BIT(1)
+#define RCC_SPI6CFGR_SPI6LPEN			BIT(2)
+
+/* RCC_SPI7CFGR register fields */
+#define RCC_SPI7CFGR_SPI7RST			BIT(0)
+#define RCC_SPI7CFGR_SPI7EN			BIT(1)
+#define RCC_SPI7CFGR_SPI7LPEN			BIT(2)
+
+/* RCC_SPI8CFGR register fields */
+#define RCC_SPI8CFGR_SPI8RST			BIT(0)
+#define RCC_SPI8CFGR_SPI8EN			BIT(1)
+#define RCC_SPI8CFGR_SPI8LPEN			BIT(2)
+#define RCC_SPI8CFGR_SPI8AMEN			BIT(3)
+
+/* RCC_SPIxCFGR register fields */
+#define RCC_SPIxCFGR_SPIxRST			BIT(0)
+#define RCC_SPIxCFGR_SPIxEN			BIT(1)
+#define RCC_SPIxCFGR_SPIxLPEN			BIT(2)
+#define RCC_SPIxCFGR_SPIxAMEN			BIT(3)
+
+/* RCC_SPDIFRXCFGR register fields */
+#define RCC_SPDIFRXCFGR_SPDIFRXRST		BIT(0)
+#define RCC_SPDIFRXCFGR_SPDIFRXEN		BIT(1)
+#define RCC_SPDIFRXCFGR_SPDIFRXLPEN		BIT(2)
+
+/* RCC_USART1CFGR register fields */
+#define RCC_USART1CFGR_USART1RST		BIT(0)
+#define RCC_USART1CFGR_USART1EN			BIT(1)
+#define RCC_USART1CFGR_USART1LPEN		BIT(2)
+
+/* RCC_USART2CFGR register fields */
+#define RCC_USART2CFGR_USART2RST		BIT(0)
+#define RCC_USART2CFGR_USART2EN			BIT(1)
+#define RCC_USART2CFGR_USART2LPEN		BIT(2)
+
+/* RCC_USART3CFGR register fields */
+#define RCC_USART3CFGR_USART3RST		BIT(0)
+#define RCC_USART3CFGR_USART3EN			BIT(1)
+#define RCC_USART3CFGR_USART3LPEN		BIT(2)
+
+/* RCC_UART4CFGR register fields */
+#define RCC_UART4CFGR_UART4RST			BIT(0)
+#define RCC_UART4CFGR_UART4EN			BIT(1)
+#define RCC_UART4CFGR_UART4LPEN			BIT(2)
+
+/* RCC_UART5CFGR register fields */
+#define RCC_UART5CFGR_UART5RST			BIT(0)
+#define RCC_UART5CFGR_UART5EN			BIT(1)
+#define RCC_UART5CFGR_UART5LPEN			BIT(2)
+
+/* RCC_USART6CFGR register fields */
+#define RCC_USART6CFGR_USART6RST		BIT(0)
+#define RCC_USART6CFGR_USART6EN			BIT(1)
+#define RCC_USART6CFGR_USART6LPEN		BIT(2)
+
+/* RCC_UART7CFGR register fields */
+#define RCC_UART7CFGR_UART7RST			BIT(0)
+#define RCC_UART7CFGR_UART7EN			BIT(1)
+#define RCC_UART7CFGR_UART7LPEN			BIT(2)
+
+/* RCC_UART8CFGR register fields */
+#define RCC_UART8CFGR_UART8RST			BIT(0)
+#define RCC_UART8CFGR_UART8EN			BIT(1)
+#define RCC_UART8CFGR_UART8LPEN			BIT(2)
+
+/* RCC_UART9CFGR register fields */
+#define RCC_UART9CFGR_UART9RST			BIT(0)
+#define RCC_UART9CFGR_UART9EN			BIT(1)
+#define RCC_UART9CFGR_UART9LPEN			BIT(2)
+
+/* RCC_USARTxCFGR register fields */
+#define RCC_USARTxCFGR_USARTxRST		BIT(0)
+#define RCC_USARTxCFGR_USARTxEN			BIT(1)
+#define RCC_USARTxCFGR_USARTxLPEN		BIT(2)
+
+/* RCC_UARTxCFGR register fields */
+#define RCC_UARTxCFGR_UARTxRST			BIT(0)
+#define RCC_UARTxCFGR_UARTxEN			BIT(1)
+#define RCC_UARTxCFGR_UARTxLPEN			BIT(2)
+
+/* RCC_LPUART1CFGR register fields */
+#define RCC_LPUART1CFGR_LPUART1RST		BIT(0)
+#define RCC_LPUART1CFGR_LPUART1EN		BIT(1)
+#define RCC_LPUART1CFGR_LPUART1LPEN		BIT(2)
+#define RCC_LPUART1CFGR_LPUART1AMEN		BIT(3)
+
+/* RCC_I2C1CFGR register fields */
+#define RCC_I2C1CFGR_I2C1RST			BIT(0)
+#define RCC_I2C1CFGR_I2C1EN			BIT(1)
+#define RCC_I2C1CFGR_I2C1LPEN			BIT(2)
+
+/* RCC_I2C2CFGR register fields */
+#define RCC_I2C2CFGR_I2C2RST			BIT(0)
+#define RCC_I2C2CFGR_I2C2EN			BIT(1)
+#define RCC_I2C2CFGR_I2C2LPEN			BIT(2)
+
+/* RCC_I2C3CFGR register fields */
+#define RCC_I2C3CFGR_I2C3RST			BIT(0)
+#define RCC_I2C3CFGR_I2C3EN			BIT(1)
+#define RCC_I2C3CFGR_I2C3LPEN			BIT(2)
+
+/* RCC_I2C4CFGR register fields */
+#define RCC_I2C4CFGR_I2C4RST			BIT(0)
+#define RCC_I2C4CFGR_I2C4EN			BIT(1)
+#define RCC_I2C4CFGR_I2C4LPEN			BIT(2)
+
+/* RCC_I2C5CFGR register fields */
+#define RCC_I2C5CFGR_I2C5RST			BIT(0)
+#define RCC_I2C5CFGR_I2C5EN			BIT(1)
+#define RCC_I2C5CFGR_I2C5LPEN			BIT(2)
+
+/* RCC_I2C6CFGR register fields */
+#define RCC_I2C6CFGR_I2C6RST			BIT(0)
+#define RCC_I2C6CFGR_I2C6EN			BIT(1)
+#define RCC_I2C6CFGR_I2C6LPEN			BIT(2)
+
+/* RCC_I2C7CFGR register fields */
+#define RCC_I2C7CFGR_I2C7RST			BIT(0)
+#define RCC_I2C7CFGR_I2C7EN			BIT(1)
+#define RCC_I2C7CFGR_I2C7LPEN			BIT(2)
+
+/* RCC_I2C8CFGR register fields */
+#define RCC_I2C8CFGR_I2C8RST			BIT(0)
+#define RCC_I2C8CFGR_I2C8EN			BIT(1)
+#define RCC_I2C8CFGR_I2C8LPEN			BIT(2)
+#define RCC_I2C8CFGR_I2C8AMEN			BIT(3)
+
+/* RCC_I2CxCFGR register fields */
+#define RCC_I2CxCFGR_I2CxRST			BIT(0)
+#define RCC_I2CxCFGR_I2CxEN			BIT(1)
+#define RCC_I2CxCFGR_I2CxLPEN			BIT(2)
+#define RCC_I2CxCFGR_I2CxAMEN			BIT(3)
+
+/* RCC_SAI1CFGR register fields */
+#define RCC_SAI1CFGR_SAI1RST			BIT(0)
+#define RCC_SAI1CFGR_SAI1EN			BIT(1)
+#define RCC_SAI1CFGR_SAI1LPEN			BIT(2)
+
+/* RCC_SAI2CFGR register fields */
+#define RCC_SAI2CFGR_SAI2RST			BIT(0)
+#define RCC_SAI2CFGR_SAI2EN			BIT(1)
+#define RCC_SAI2CFGR_SAI2LPEN			BIT(2)
+
+/* RCC_SAI3CFGR register fields */
+#define RCC_SAI3CFGR_SAI3RST			BIT(0)
+#define RCC_SAI3CFGR_SAI3EN			BIT(1)
+#define RCC_SAI3CFGR_SAI3LPEN			BIT(2)
+
+/* RCC_SAI4CFGR register fields */
+#define RCC_SAI4CFGR_SAI4RST			BIT(0)
+#define RCC_SAI4CFGR_SAI4EN			BIT(1)
+#define RCC_SAI4CFGR_SAI4LPEN			BIT(2)
+
+/* RCC_SAIxCFGR register fields */
+#define RCC_SAIxCFGR_SAIxRST			BIT(0)
+#define RCC_SAIxCFGR_SAIxEN			BIT(1)
+#define RCC_SAIxCFGR_SAIxLPEN			BIT(2)
+
+/* RCC_MDF1CFGR register fields */
+#define RCC_MDF1CFGR_MDF1RST			BIT(0)
+#define RCC_MDF1CFGR_MDF1EN			BIT(1)
+#define RCC_MDF1CFGR_MDF1LPEN			BIT(2)
+
+/* RCC_ADF1CFGR register fields */
+#define RCC_ADF1CFGR_ADF1RST			BIT(0)
+#define RCC_ADF1CFGR_ADF1EN			BIT(1)
+#define RCC_ADF1CFGR_ADF1LPEN			BIT(2)
+#define RCC_ADF1CFGR_ADF1AMEN			BIT(3)
+
+/* RCC_FDCANCFGR register fields */
+#define RCC_FDCANCFGR_FDCANRST			BIT(0)
+#define RCC_FDCANCFGR_FDCANEN			BIT(1)
+#define RCC_FDCANCFGR_FDCANLPEN			BIT(2)
+
+/* RCC_HDPCFGR register fields */
+#define RCC_HDPCFGR_HDPRST			BIT(0)
+#define RCC_HDPCFGR_HDPEN			BIT(1)
+
+/* RCC_ADC12CFGR register fields */
+#define RCC_ADC12CFGR_ADC12RST			BIT(0)
+#define RCC_ADC12CFGR_ADC12EN			BIT(1)
+#define RCC_ADC12CFGR_ADC12LPEN			BIT(2)
+#define RCC_ADC12CFGR_ADC12KERSEL		BIT(12)
+
+/* RCC_ADC3CFGR register fields */
+#define RCC_ADC3CFGR_ADC3RST			BIT(0)
+#define RCC_ADC3CFGR_ADC3EN			BIT(1)
+#define RCC_ADC3CFGR_ADC3LPEN			BIT(2)
+#define RCC_ADC3CFGR_ADC3KERSEL_MASK		GENMASK(13, 12)
+#define RCC_ADC3CFGR_ADC3KERSEL_SHIFT		12
+
+/* RCC_ETH1CFGR register fields */
+#define RCC_ETH1CFGR_ETH1RST			BIT(0)
+#define RCC_ETH1CFGR_ETH1MACEN			BIT(1)
+#define RCC_ETH1CFGR_ETH1MACLPEN		BIT(2)
+#define RCC_ETH1CFGR_ETH1STPEN			BIT(4)
+#define RCC_ETH1CFGR_ETH1EN			BIT(5)
+#define RCC_ETH1CFGR_ETH1LPEN			BIT(6)
+#define RCC_ETH1CFGR_ETH1TXEN			BIT(8)
+#define RCC_ETH1CFGR_ETH1TXLPEN			BIT(9)
+#define RCC_ETH1CFGR_ETH1RXEN			BIT(10)
+#define RCC_ETH1CFGR_ETH1RXLPEN			BIT(11)
+
+/* RCC_ETH2CFGR register fields */
+#define RCC_ETH2CFGR_ETH2RST			BIT(0)
+#define RCC_ETH2CFGR_ETH2MACEN			BIT(1)
+#define RCC_ETH2CFGR_ETH2MACLPEN		BIT(2)
+#define RCC_ETH2CFGR_ETH2STPEN			BIT(4)
+#define RCC_ETH2CFGR_ETH2EN			BIT(5)
+#define RCC_ETH2CFGR_ETH2LPEN			BIT(6)
+#define RCC_ETH2CFGR_ETH2TXEN			BIT(8)
+#define RCC_ETH2CFGR_ETH2TXLPEN			BIT(9)
+#define RCC_ETH2CFGR_ETH2RXEN			BIT(10)
+#define RCC_ETH2CFGR_ETH2RXLPEN			BIT(11)
+
+/* RCC_ETHxCFGR register fields */
+#define RCC_ETHxCFGR_ETHxRST			BIT(0)
+#define RCC_ETHxCFGR_ETHxMACEN			BIT(1)
+#define RCC_ETHxCFGR_ETHxMACLPEN		BIT(2)
+#define RCC_ETHxCFGR_ETHxSTPEN			BIT(4)
+#define RCC_ETHxCFGR_ETHxEN			BIT(5)
+#define RCC_ETHxCFGR_ETHxLPEN			BIT(6)
+#define RCC_ETHxCFGR_ETHxTXEN			BIT(8)
+#define RCC_ETHxCFGR_ETHxTXLPEN			BIT(9)
+#define RCC_ETHxCFGR_ETHxRXEN			BIT(10)
+#define RCC_ETHxCFGR_ETHxRXLPEN			BIT(11)
+
+/* RCC_USB2CFGR register fields */
+#define RCC_USB2CFGR_USB2RST			BIT(0)
+#define RCC_USB2CFGR_USB2EN			BIT(1)
+#define RCC_USB2CFGR_USB2LPEN			BIT(2)
+#define RCC_USB2CFGR_USB2STPEN			BIT(4)
+
+/* RCC_USB2PHY1CFGR register fields */
+#define RCC_USB2PHY1CFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHY1CFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHY1CFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHY1CFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHY1CFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB2PHY2CFGR register fields */
+#define RCC_USB2PHY2CFGR_USB2PHY2RST		BIT(0)
+#define RCC_USB2PHY2CFGR_USB2PHY2EN		BIT(1)
+#define RCC_USB2PHY2CFGR_USB2PHY2LPEN		BIT(2)
+#define RCC_USB2PHY2CFGR_USB2PHY2STPEN		BIT(4)
+#define RCC_USB2PHY2CFGR_USB2PHY2CKREFSEL	BIT(15)
+
+/* RCC_USB2PHYxCFGR register fields */
+#define RCC_USB2PHYxCFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHYxCFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHYxCFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHYxCFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHYxCFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB3DRCFGR register fields */
+#define RCC_USB3DRCFGR_USB3DRRST		BIT(0)
+#define RCC_USB3DRCFGR_USB3DREN			BIT(1)
+#define RCC_USB3DRCFGR_USB3DRLPEN		BIT(2)
+#define RCC_USB3DRCFGR_USB3DRSTPEN		BIT(4)
+
+/* RCC_USB3PCIEPHYCFGR register fields */
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYRST	BIT(0)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYEN	BIT(1)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYLPEN	BIT(2)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYSTPEN	BIT(4)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYCKREFSEL	BIT(15)
+
+/* RCC_PCIECFGR register fields */
+#define RCC_PCIECFGR_PCIERST			BIT(0)
+#define RCC_PCIECFGR_PCIEEN			BIT(1)
+#define RCC_PCIECFGR_PCIELPEN			BIT(2)
+#define RCC_PCIECFGR_PCIESTPEN			BIT(4)
+
+/* RCC_USBTCCFGR register fields */
+#define RCC_USBTCCFGR_USBTCRST			BIT(0)
+#define RCC_USBTCCFGR_USBTCEN			BIT(1)
+#define RCC_USBTCCFGR_USBTCLPEN			BIT(2)
+
+/* RCC_ETHSWCFGR register fields */
+#define RCC_ETHSWCFGR_ETHSWRST			BIT(0)
+#define RCC_ETHSWCFGR_ETHSWMACEN		BIT(1)
+#define RCC_ETHSWCFGR_ETHSWMACLPEN		BIT(2)
+#define RCC_ETHSWCFGR_ETHSWEN			BIT(5)
+#define RCC_ETHSWCFGR_ETHSWLPEN			BIT(6)
+#define RCC_ETHSWCFGR_ETHSWREFEN		BIT(21)
+#define RCC_ETHSWCFGR_ETHSWREFLPEN		BIT(22)
+
+/* RCC_ETHSWACMCFGR register fields */
+#define RCC_ETHSWACMCFGR_ETHSWACMEN		BIT(1)
+#define RCC_ETHSWACMCFGR_ETHSWACMLPEN		BIT(2)
+
+/* RCC_ETHSWACMMSGCFGR register fields */
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGEN	BIT(1)
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGLPEN	BIT(2)
+
+/* RCC_STGENCFGR register fields */
+#define RCC_STGENCFGR_STGENEN			BIT(1)
+#define RCC_STGENCFGR_STGENLPEN			BIT(2)
+#define RCC_STGENCFGR_STGENSTPEN		BIT(4)
+
+/* RCC_SDMMC1CFGR register fields */
+#define RCC_SDMMC1CFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMC1CFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMC1CFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMC1CFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_SDMMC2CFGR register fields */
+#define RCC_SDMMC2CFGR_SDMMC2RST		BIT(0)
+#define RCC_SDMMC2CFGR_SDMMC2EN			BIT(1)
+#define RCC_SDMMC2CFGR_SDMMC2LPEN		BIT(2)
+#define RCC_SDMMC2CFGR_SDMMC2DLLRST		BIT(16)
+
+/* RCC_SDMMC3CFGR register fields */
+#define RCC_SDMMC3CFGR_SDMMC3RST		BIT(0)
+#define RCC_SDMMC3CFGR_SDMMC3EN			BIT(1)
+#define RCC_SDMMC3CFGR_SDMMC3LPEN		BIT(2)
+#define RCC_SDMMC3CFGR_SDMMC3DLLRST		BIT(16)
+
+/* RCC_SDMMCxCFGR register fields */
+#define RCC_SDMMCxCFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMCxCFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMCxCFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMCxCFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_GPUCFGR register fields */
+#define RCC_GPUCFGR_GPURST			BIT(0)
+#define RCC_GPUCFGR_GPUEN			BIT(1)
+#define RCC_GPUCFGR_GPULPEN			BIT(2)
+
+/* RCC_LTDCCFGR register fields */
+#define RCC_LTDCCFGR_LTDCRST			BIT(0)
+#define RCC_LTDCCFGR_LTDCEN			BIT(1)
+#define RCC_LTDCCFGR_LTDCLPEN			BIT(2)
+
+/* RCC_DSICFGR register fields */
+#define RCC_DSICFGR_DSIRST			BIT(0)
+#define RCC_DSICFGR_DSIEN			BIT(1)
+#define RCC_DSICFGR_DSILPEN			BIT(2)
+#define RCC_DSICFGR_DSIBLSEL			BIT(12)
+#define RCC_DSICFGR_DSIPHYCKREFSEL		BIT(15)
+
+/* RCC_LVDSCFGR register fields */
+#define RCC_LVDSCFGR_LVDSRST			BIT(0)
+#define RCC_LVDSCFGR_LVDSEN			BIT(1)
+#define RCC_LVDSCFGR_LVDSLPEN			BIT(2)
+#define RCC_LVDSCFGR_LVDSPHYCKREFSEL		BIT(15)
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSIRST			BIT(0)
+#define RCC_CSICFGR_CSIEN			BIT(1)
+#define RCC_CSICFGR_CSILPEN			BIT(2)
+
+/* RCC_DCMIPPCFGR register fields */
+#define RCC_DCMIPPCFGR_DCMIPPRST		BIT(0)
+#define RCC_DCMIPPCFGR_DCMIPPEN			BIT(1)
+#define RCC_DCMIPPCFGR_DCMIPPLPEN		BIT(2)
+
+/* RCC_CCICFGR register fields */
+#define RCC_CCICFGR_CCIRST			BIT(0)
+#define RCC_CCICFGR_CCIEN			BIT(1)
+#define RCC_CCICFGR_CCILPEN			BIT(2)
+
+/* RCC_VDECCFGR register fields */
+#define RCC_VDECCFGR_VDECRST			BIT(0)
+#define RCC_VDECCFGR_VDECEN			BIT(1)
+#define RCC_VDECCFGR_VDECLPEN			BIT(2)
+
+/* RCC_VENCCFGR register fields */
+#define RCC_VENCCFGR_VENCRST			BIT(0)
+#define RCC_VENCCFGR_VENCEN			BIT(1)
+#define RCC_VENCCFGR_VENCLPEN			BIT(2)
+
+/* RCC_RNGCFGR register fields */
+#define RCC_RNGCFGR_RNGRST			BIT(0)
+#define RCC_RNGCFGR_RNGEN			BIT(1)
+#define RCC_RNGCFGR_RNGLPEN			BIT(2)
+
+/* RCC_PKACFGR register fields */
+#define RCC_PKACFGR_PKARST			BIT(0)
+#define RCC_PKACFGR_PKAEN			BIT(1)
+#define RCC_PKACFGR_PKALPEN			BIT(2)
+
+/* RCC_SAESCFGR register fields */
+#define RCC_SAESCFGR_SAESRST			BIT(0)
+#define RCC_SAESCFGR_SAESEN			BIT(1)
+#define RCC_SAESCFGR_SAESLPEN			BIT(2)
+
+/* RCC_HASHCFGR register fields */
+#define RCC_HASHCFGR_HASHRST			BIT(0)
+#define RCC_HASHCFGR_HASHEN			BIT(1)
+#define RCC_HASHCFGR_HASHLPEN			BIT(2)
+
+/* RCC_CRYP1CFGR register fields */
+#define RCC_CRYP1CFGR_CRYP1RST			BIT(0)
+#define RCC_CRYP1CFGR_CRYP1EN			BIT(1)
+#define RCC_CRYP1CFGR_CRYP1LPEN			BIT(2)
+
+/* RCC_CRYP2CFGR register fields */
+#define RCC_CRYP2CFGR_CRYP2RST			BIT(0)
+#define RCC_CRYP2CFGR_CRYP2EN			BIT(1)
+#define RCC_CRYP2CFGR_CRYP2LPEN			BIT(2)
+
+/* RCC_CRYPxCFGR register fields */
+#define RCC_CRYPxCFGR_CRYPxRST			BIT(0)
+#define RCC_CRYPxCFGR_CRYPxEN			BIT(1)
+#define RCC_CRYPxCFGR_CRYPxLPEN			BIT(2)
+
+/* RCC_IWDG1CFGR register fields */
+#define RCC_IWDG1CFGR_IWDG1EN			BIT(1)
+#define RCC_IWDG1CFGR_IWDG1LPEN			BIT(2)
+
+/* RCC_IWDG2CFGR register fields */
+#define RCC_IWDG2CFGR_IWDG2EN			BIT(1)
+#define RCC_IWDG2CFGR_IWDG2LPEN			BIT(2)
+
+/* RCC_IWDG3CFGR register fields */
+#define RCC_IWDG3CFGR_IWDG3EN			BIT(1)
+#define RCC_IWDG3CFGR_IWDG3LPEN			BIT(2)
+
+/* RCC_IWDG4CFGR register fields */
+#define RCC_IWDG4CFGR_IWDG4EN			BIT(1)
+#define RCC_IWDG4CFGR_IWDG4LPEN			BIT(2)
+
+/* RCC_IWDGxCFGR register fields */
+#define RCC_IWDGxCFGR_IWDGxEN			BIT(1)
+#define RCC_IWDGxCFGR_IWDGxLPEN			BIT(2)
+
+/* RCC_IWDG5CFGR register fields */
+#define RCC_IWDG5CFGR_IWDG5EN			BIT(1)
+#define RCC_IWDG5CFGR_IWDG5LPEN			BIT(2)
+#define RCC_IWDG5CFGR_IWDG5AMEN			BIT(3)
+
+/* RCC_WWDG1CFGR register fields */
+#define RCC_WWDG1CFGR_WWDG1RST			BIT(0)
+#define RCC_WWDG1CFGR_WWDG1EN			BIT(1)
+#define RCC_WWDG1CFGR_WWDG1LPEN			BIT(2)
+
+/* RCC_WWDG2CFGR register fields */
+#define RCC_WWDG2CFGR_WWDG2RST			BIT(0)
+#define RCC_WWDG2CFGR_WWDG2EN			BIT(1)
+#define RCC_WWDG2CFGR_WWDG2LPEN			BIT(2)
+#define RCC_WWDG2CFGR_WWDG2AMEN			BIT(3)
+
+/* RCC_VREFCFGR register fields */
+#define RCC_VREFCFGR_VREFRST			BIT(0)
+#define RCC_VREFCFGR_VREFEN			BIT(1)
+#define RCC_VREFCFGR_VREFLPEN			BIT(2)
+
+/* RCC_DTSCFGR register fields */
+#define RCC_DTSCFGR_DTSRST			BIT(0)
+#define RCC_DTSCFGR_DTSEN			BIT(1)
+#define RCC_DTSCFGR_DTSLPEN			BIT(2)
+#define RCC_DTSCFGR_DTSKERSEL_MASK		GENMASK(13, 12)
+#define RCC_DTSCFGR_DTSKERSEL_SHIFT		12
+
+/* RCC_CRCCFGR register fields */
+#define RCC_CRCCFGR_CRCRST			BIT(0)
+#define RCC_CRCCFGR_CRCEN			BIT(1)
+#define RCC_CRCCFGR_CRCLPEN			BIT(2)
+
+/* RCC_SERCCFGR register fields */
+#define RCC_SERCCFGR_SERCRST			BIT(0)
+#define RCC_SERCCFGR_SERCEN			BIT(1)
+#define RCC_SERCCFGR_SERCLPEN			BIT(2)
+
+/* RCC_OSPIIOMCFGR register fields */
+#define RCC_OSPIIOMCFGR_OSPIIOMRST		BIT(0)
+#define RCC_OSPIIOMCFGR_OSPIIOMEN		BIT(1)
+#define RCC_OSPIIOMCFGR_OSPIIOMLPEN		BIT(2)
+
+/* RCC_GICV2MCFGR register fields */
+#define RCC_GICV2MCFGR_GICV2MEN			BIT(1)
+#define RCC_GICV2MCFGR_GICV2MLPEN		BIT(2)
+
+/* RCC_I3C1CFGR register fields */
+#define RCC_I3C1CFGR_I3C1RST			BIT(0)
+#define RCC_I3C1CFGR_I3C1EN			BIT(1)
+#define RCC_I3C1CFGR_I3C1LPEN			BIT(2)
+
+/* RCC_I3C2CFGR register fields */
+#define RCC_I3C2CFGR_I3C2RST			BIT(0)
+#define RCC_I3C2CFGR_I3C2EN			BIT(1)
+#define RCC_I3C2CFGR_I3C2LPEN			BIT(2)
+
+/* RCC_I3C3CFGR register fields */
+#define RCC_I3C3CFGR_I3C3RST			BIT(0)
+#define RCC_I3C3CFGR_I3C3EN			BIT(1)
+#define RCC_I3C3CFGR_I3C3LPEN			BIT(2)
+
+/* RCC_I3C4CFGR register fields */
+#define RCC_I3C4CFGR_I3C4RST			BIT(0)
+#define RCC_I3C4CFGR_I3C4EN			BIT(1)
+#define RCC_I3C4CFGR_I3C4LPEN			BIT(2)
+#define RCC_I3C4CFGR_I3C4AMEN			BIT(3)
+
+/* RCC_I3CxCFGR register fields */
+#define RCC_I3CxCFGR_I3CxRST			BIT(0)
+#define RCC_I3CxCFGR_I3CxEN			BIT(1)
+#define RCC_I3CxCFGR_I3CxLPEN			BIT(2)
+#define RCC_I3CxCFGR_I3CxAMEN			BIT(3)
+
+/* RCC_MUXSELCFGR register fields */
+#define RCC_MUXSELCFGR_MUXSEL0_MASK		GENMASK(1, 0)
+#define RCC_MUXSELCFGR_MUXSEL0_SHIFT		0
+#define RCC_MUXSELCFGR_MUXSEL1_MASK		GENMASK(5, 4)
+#define RCC_MUXSELCFGR_MUXSEL1_SHIFT		4
+#define RCC_MUXSELCFGR_MUXSEL2_MASK		GENMASK(9, 8)
+#define RCC_MUXSELCFGR_MUXSEL2_SHIFT		8
+#define RCC_MUXSELCFGR_MUXSEL3_MASK		GENMASK(13, 12)
+#define RCC_MUXSELCFGR_MUXSEL3_SHIFT		12
+#define RCC_MUXSELCFGR_MUXSEL4_MASK		GENMASK(17, 16)
+#define RCC_MUXSELCFGR_MUXSEL4_SHIFT		16
+#define RCC_MUXSELCFGR_MUXSEL5_MASK		GENMASK(21, 20)
+#define RCC_MUXSELCFGR_MUXSEL5_SHIFT		20
+#define RCC_MUXSELCFGR_MUXSEL6_MASK		GENMASK(25, 24)
+#define RCC_MUXSELCFGR_MUXSEL6_SHIFT		24
+#define RCC_MUXSELCFGR_MUXSEL7_MASK		GENMASK(29, 28)
+#define RCC_MUXSELCFGR_MUXSEL7_SHIFT		28
+
+/* RCC_XBAR0CFGR register fields */
+#define RCC_XBAR0CFGR_XBAR0SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR0CFGR_XBAR0SEL_SHIFT		0
+#define RCC_XBAR0CFGR_XBAR0EN			BIT(6)
+#define RCC_XBAR0CFGR_XBAR0STS			BIT(7)
+
+/* RCC_XBAR1CFGR register fields */
+#define RCC_XBAR1CFGR_XBAR1SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR1CFGR_XBAR1SEL_SHIFT		0
+#define RCC_XBAR1CFGR_XBAR1EN			BIT(6)
+#define RCC_XBAR1CFGR_XBAR1STS			BIT(7)
+
+/* RCC_XBAR2CFGR register fields */
+#define RCC_XBAR2CFGR_XBAR2SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR2CFGR_XBAR2SEL_SHIFT		0
+#define RCC_XBAR2CFGR_XBAR2EN			BIT(6)
+#define RCC_XBAR2CFGR_XBAR2STS			BIT(7)
+
+/* RCC_XBAR3CFGR register fields */
+#define RCC_XBAR3CFGR_XBAR3SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR3CFGR_XBAR3SEL_SHIFT		0
+#define RCC_XBAR3CFGR_XBAR3EN			BIT(6)
+#define RCC_XBAR3CFGR_XBAR3STS			BIT(7)
+
+/* RCC_XBAR4CFGR register fields */
+#define RCC_XBAR4CFGR_XBAR4SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR4CFGR_XBAR4SEL_SHIFT		0
+#define RCC_XBAR4CFGR_XBAR4EN			BIT(6)
+#define RCC_XBAR4CFGR_XBAR4STS			BIT(7)
+
+/* RCC_XBAR5CFGR register fields */
+#define RCC_XBAR5CFGR_XBAR5SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR5CFGR_XBAR5SEL_SHIFT		0
+#define RCC_XBAR5CFGR_XBAR5EN			BIT(6)
+#define RCC_XBAR5CFGR_XBAR5STS			BIT(7)
+
+/* RCC_XBAR6CFGR register fields */
+#define RCC_XBAR6CFGR_XBAR6SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR6CFGR_XBAR6SEL_SHIFT		0
+#define RCC_XBAR6CFGR_XBAR6EN			BIT(6)
+#define RCC_XBAR6CFGR_XBAR6STS			BIT(7)
+
+/* RCC_XBAR7CFGR register fields */
+#define RCC_XBAR7CFGR_XBAR7SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR7CFGR_XBAR7SEL_SHIFT		0
+#define RCC_XBAR7CFGR_XBAR7EN			BIT(6)
+#define RCC_XBAR7CFGR_XBAR7STS			BIT(7)
+
+/* RCC_XBAR8CFGR register fields */
+#define RCC_XBAR8CFGR_XBAR8SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR8CFGR_XBAR8SEL_SHIFT		0
+#define RCC_XBAR8CFGR_XBAR8EN			BIT(6)
+#define RCC_XBAR8CFGR_XBAR8STS			BIT(7)
+
+/* RCC_XBAR9CFGR register fields */
+#define RCC_XBAR9CFGR_XBAR9SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR9CFGR_XBAR9SEL_SHIFT		0
+#define RCC_XBAR9CFGR_XBAR9EN			BIT(6)
+#define RCC_XBAR9CFGR_XBAR9STS			BIT(7)
+
+/* RCC_XBAR10CFGR register fields */
+#define RCC_XBAR10CFGR_XBAR10SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR10CFGR_XBAR10SEL_SHIFT		0
+#define RCC_XBAR10CFGR_XBAR10EN			BIT(6)
+#define RCC_XBAR10CFGR_XBAR10STS		BIT(7)
+
+/* RCC_XBAR11CFGR register fields */
+#define RCC_XBAR11CFGR_XBAR11SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR11CFGR_XBAR11SEL_SHIFT		0
+#define RCC_XBAR11CFGR_XBAR11EN			BIT(6)
+#define RCC_XBAR11CFGR_XBAR11STS		BIT(7)
+
+/* RCC_XBAR12CFGR register fields */
+#define RCC_XBAR12CFGR_XBAR12SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR12CFGR_XBAR12SEL_SHIFT		0
+#define RCC_XBAR12CFGR_XBAR12EN			BIT(6)
+#define RCC_XBAR12CFGR_XBAR12STS		BIT(7)
+
+/* RCC_XBAR13CFGR register fields */
+#define RCC_XBAR13CFGR_XBAR13SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR13CFGR_XBAR13SEL_SHIFT		0
+#define RCC_XBAR13CFGR_XBAR13EN			BIT(6)
+#define RCC_XBAR13CFGR_XBAR13STS		BIT(7)
+
+/* RCC_XBAR14CFGR register fields */
+#define RCC_XBAR14CFGR_XBAR14SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR14CFGR_XBAR14SEL_SHIFT		0
+#define RCC_XBAR14CFGR_XBAR14EN			BIT(6)
+#define RCC_XBAR14CFGR_XBAR14STS		BIT(7)
+
+/* RCC_XBAR15CFGR register fields */
+#define RCC_XBAR15CFGR_XBAR15SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR15CFGR_XBAR15SEL_SHIFT		0
+#define RCC_XBAR15CFGR_XBAR15EN			BIT(6)
+#define RCC_XBAR15CFGR_XBAR15STS		BIT(7)
+
+/* RCC_XBAR16CFGR register fields */
+#define RCC_XBAR16CFGR_XBAR16SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR16CFGR_XBAR16SEL_SHIFT		0
+#define RCC_XBAR16CFGR_XBAR16EN			BIT(6)
+#define RCC_XBAR16CFGR_XBAR16STS		BIT(7)
+
+/* RCC_XBAR17CFGR register fields */
+#define RCC_XBAR17CFGR_XBAR17SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR17CFGR_XBAR17SEL_SHIFT		0
+#define RCC_XBAR17CFGR_XBAR17EN			BIT(6)
+#define RCC_XBAR17CFGR_XBAR17STS		BIT(7)
+
+/* RCC_XBAR18CFGR register fields */
+#define RCC_XBAR18CFGR_XBAR18SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR18CFGR_XBAR18SEL_SHIFT		0
+#define RCC_XBAR18CFGR_XBAR18EN			BIT(6)
+#define RCC_XBAR18CFGR_XBAR18STS		BIT(7)
+
+/* RCC_XBAR19CFGR register fields */
+#define RCC_XBAR19CFGR_XBAR19SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR19CFGR_XBAR19SEL_SHIFT		0
+#define RCC_XBAR19CFGR_XBAR19EN			BIT(6)
+#define RCC_XBAR19CFGR_XBAR19STS		BIT(7)
+
+/* RCC_XBAR20CFGR register fields */
+#define RCC_XBAR20CFGR_XBAR20SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR20CFGR_XBAR20SEL_SHIFT		0
+#define RCC_XBAR20CFGR_XBAR20EN			BIT(6)
+#define RCC_XBAR20CFGR_XBAR20STS		BIT(7)
+
+/* RCC_XBAR21CFGR register fields */
+#define RCC_XBAR21CFGR_XBAR21SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR21CFGR_XBAR21SEL_SHIFT		0
+#define RCC_XBAR21CFGR_XBAR21EN			BIT(6)
+#define RCC_XBAR21CFGR_XBAR21STS		BIT(7)
+
+/* RCC_XBAR22CFGR register fields */
+#define RCC_XBAR22CFGR_XBAR22SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR22CFGR_XBAR22SEL_SHIFT		0
+#define RCC_XBAR22CFGR_XBAR22EN			BIT(6)
+#define RCC_XBAR22CFGR_XBAR22STS		BIT(7)
+
+/* RCC_XBAR23CFGR register fields */
+#define RCC_XBAR23CFGR_XBAR23SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR23CFGR_XBAR23SEL_SHIFT		0
+#define RCC_XBAR23CFGR_XBAR23EN			BIT(6)
+#define RCC_XBAR23CFGR_XBAR23STS		BIT(7)
+
+/* RCC_XBAR24CFGR register fields */
+#define RCC_XBAR24CFGR_XBAR24SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR24CFGR_XBAR24SEL_SHIFT		0
+#define RCC_XBAR24CFGR_XBAR24EN			BIT(6)
+#define RCC_XBAR24CFGR_XBAR24STS		BIT(7)
+
+/* RCC_XBAR25CFGR register fields */
+#define RCC_XBAR25CFGR_XBAR25SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR25CFGR_XBAR25SEL_SHIFT		0
+#define RCC_XBAR25CFGR_XBAR25EN			BIT(6)
+#define RCC_XBAR25CFGR_XBAR25STS		BIT(7)
+
+/* RCC_XBAR26CFGR register fields */
+#define RCC_XBAR26CFGR_XBAR26SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR26CFGR_XBAR26SEL_SHIFT		0
+#define RCC_XBAR26CFGR_XBAR26EN			BIT(6)
+#define RCC_XBAR26CFGR_XBAR26STS		BIT(7)
+
+/* RCC_XBAR27CFGR register fields */
+#define RCC_XBAR27CFGR_XBAR27SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR27CFGR_XBAR27SEL_SHIFT		0
+#define RCC_XBAR27CFGR_XBAR27EN			BIT(6)
+#define RCC_XBAR27CFGR_XBAR27STS		BIT(7)
+
+/* RCC_XBAR28CFGR register fields */
+#define RCC_XBAR28CFGR_XBAR28SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR28CFGR_XBAR28SEL_SHIFT		0
+#define RCC_XBAR28CFGR_XBAR28EN			BIT(6)
+#define RCC_XBAR28CFGR_XBAR28STS		BIT(7)
+
+/* RCC_XBAR29CFGR register fields */
+#define RCC_XBAR29CFGR_XBAR29SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR29CFGR_XBAR29SEL_SHIFT		0
+#define RCC_XBAR29CFGR_XBAR29EN			BIT(6)
+#define RCC_XBAR29CFGR_XBAR29STS		BIT(7)
+
+/* RCC_XBAR30CFGR register fields */
+#define RCC_XBAR30CFGR_XBAR30SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR30CFGR_XBAR30SEL_SHIFT		0
+#define RCC_XBAR30CFGR_XBAR30EN			BIT(6)
+#define RCC_XBAR30CFGR_XBAR30STS		BIT(7)
+
+/* RCC_XBAR31CFGR register fields */
+#define RCC_XBAR31CFGR_XBAR31SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR31CFGR_XBAR31SEL_SHIFT		0
+#define RCC_XBAR31CFGR_XBAR31EN			BIT(6)
+#define RCC_XBAR31CFGR_XBAR31STS		BIT(7)
+
+/* RCC_XBAR32CFGR register fields */
+#define RCC_XBAR32CFGR_XBAR32SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR32CFGR_XBAR32SEL_SHIFT		0
+#define RCC_XBAR32CFGR_XBAR32EN			BIT(6)
+#define RCC_XBAR32CFGR_XBAR32STS		BIT(7)
+
+/* RCC_XBAR33CFGR register fields */
+#define RCC_XBAR33CFGR_XBAR33SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR33CFGR_XBAR33SEL_SHIFT		0
+#define RCC_XBAR33CFGR_XBAR33EN			BIT(6)
+#define RCC_XBAR33CFGR_XBAR33STS		BIT(7)
+
+/* RCC_XBAR34CFGR register fields */
+#define RCC_XBAR34CFGR_XBAR34SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR34CFGR_XBAR34SEL_SHIFT		0
+#define RCC_XBAR34CFGR_XBAR34EN			BIT(6)
+#define RCC_XBAR34CFGR_XBAR34STS		BIT(7)
+
+/* RCC_XBAR35CFGR register fields */
+#define RCC_XBAR35CFGR_XBAR35SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR35CFGR_XBAR35SEL_SHIFT		0
+#define RCC_XBAR35CFGR_XBAR35EN			BIT(6)
+#define RCC_XBAR35CFGR_XBAR35STS		BIT(7)
+
+/* RCC_XBAR36CFGR register fields */
+#define RCC_XBAR36CFGR_XBAR36SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR36CFGR_XBAR36SEL_SHIFT		0
+#define RCC_XBAR36CFGR_XBAR36EN			BIT(6)
+#define RCC_XBAR36CFGR_XBAR36STS		BIT(7)
+
+/* RCC_XBAR37CFGR register fields */
+#define RCC_XBAR37CFGR_XBAR37SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR37CFGR_XBAR37SEL_SHIFT		0
+#define RCC_XBAR37CFGR_XBAR37EN			BIT(6)
+#define RCC_XBAR37CFGR_XBAR37STS		BIT(7)
+
+/* RCC_XBAR38CFGR register fields */
+#define RCC_XBAR38CFGR_XBAR38SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR38CFGR_XBAR38SEL_SHIFT		0
+#define RCC_XBAR38CFGR_XBAR38EN			BIT(6)
+#define RCC_XBAR38CFGR_XBAR38STS		BIT(7)
+
+/* RCC_XBAR39CFGR register fields */
+#define RCC_XBAR39CFGR_XBAR39SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR39CFGR_XBAR39SEL_SHIFT		0
+#define RCC_XBAR39CFGR_XBAR39EN			BIT(6)
+#define RCC_XBAR39CFGR_XBAR39STS		BIT(7)
+
+/* RCC_XBAR40CFGR register fields */
+#define RCC_XBAR40CFGR_XBAR40SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR40CFGR_XBAR40SEL_SHIFT		0
+#define RCC_XBAR40CFGR_XBAR40EN			BIT(6)
+#define RCC_XBAR40CFGR_XBAR40STS		BIT(7)
+
+/* RCC_XBAR41CFGR register fields */
+#define RCC_XBAR41CFGR_XBAR41SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR41CFGR_XBAR41SEL_SHIFT		0
+#define RCC_XBAR41CFGR_XBAR41EN			BIT(6)
+#define RCC_XBAR41CFGR_XBAR41STS		BIT(7)
+
+/* RCC_XBAR42CFGR register fields */
+#define RCC_XBAR42CFGR_XBAR42SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR42CFGR_XBAR42SEL_SHIFT		0
+#define RCC_XBAR42CFGR_XBAR42EN			BIT(6)
+#define RCC_XBAR42CFGR_XBAR42STS		BIT(7)
+
+/* RCC_XBAR43CFGR register fields */
+#define RCC_XBAR43CFGR_XBAR43SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR43CFGR_XBAR43SEL_SHIFT		0
+#define RCC_XBAR43CFGR_XBAR43EN			BIT(6)
+#define RCC_XBAR43CFGR_XBAR43STS		BIT(7)
+
+/* RCC_XBAR44CFGR register fields */
+#define RCC_XBAR44CFGR_XBAR44SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR44CFGR_XBAR44SEL_SHIFT		0
+#define RCC_XBAR44CFGR_XBAR44EN			BIT(6)
+#define RCC_XBAR44CFGR_XBAR44STS		BIT(7)
+
+/* RCC_XBAR45CFGR register fields */
+#define RCC_XBAR45CFGR_XBAR45SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR45CFGR_XBAR45SEL_SHIFT		0
+#define RCC_XBAR45CFGR_XBAR45EN			BIT(6)
+#define RCC_XBAR45CFGR_XBAR45STS		BIT(7)
+
+/* RCC_XBAR46CFGR register fields */
+#define RCC_XBAR46CFGR_XBAR46SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR46CFGR_XBAR46SEL_SHIFT		0
+#define RCC_XBAR46CFGR_XBAR46EN			BIT(6)
+#define RCC_XBAR46CFGR_XBAR46STS		BIT(7)
+
+/* RCC_XBAR47CFGR register fields */
+#define RCC_XBAR47CFGR_XBAR47SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR47CFGR_XBAR47SEL_SHIFT		0
+#define RCC_XBAR47CFGR_XBAR47EN			BIT(6)
+#define RCC_XBAR47CFGR_XBAR47STS		BIT(7)
+
+/* RCC_XBAR48CFGR register fields */
+#define RCC_XBAR48CFGR_XBAR48SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR48CFGR_XBAR48SEL_SHIFT		0
+#define RCC_XBAR48CFGR_XBAR48EN			BIT(6)
+#define RCC_XBAR48CFGR_XBAR48STS		BIT(7)
+
+/* RCC_XBAR49CFGR register fields */
+#define RCC_XBAR49CFGR_XBAR49SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR49CFGR_XBAR49SEL_SHIFT		0
+#define RCC_XBAR49CFGR_XBAR49EN			BIT(6)
+#define RCC_XBAR49CFGR_XBAR49STS		BIT(7)
+
+/* RCC_XBAR50CFGR register fields */
+#define RCC_XBAR50CFGR_XBAR50SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR50CFGR_XBAR50SEL_SHIFT		0
+#define RCC_XBAR50CFGR_XBAR50EN			BIT(6)
+#define RCC_XBAR50CFGR_XBAR50STS		BIT(7)
+
+/* RCC_XBAR51CFGR register fields */
+#define RCC_XBAR51CFGR_XBAR51SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR51CFGR_XBAR51SEL_SHIFT		0
+#define RCC_XBAR51CFGR_XBAR51EN			BIT(6)
+#define RCC_XBAR51CFGR_XBAR51STS		BIT(7)
+
+/* RCC_XBAR52CFGR register fields */
+#define RCC_XBAR52CFGR_XBAR52SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR52CFGR_XBAR52SEL_SHIFT		0
+#define RCC_XBAR52CFGR_XBAR52EN			BIT(6)
+#define RCC_XBAR52CFGR_XBAR52STS		BIT(7)
+
+/* RCC_XBAR53CFGR register fields */
+#define RCC_XBAR53CFGR_XBAR53SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR53CFGR_XBAR53SEL_SHIFT		0
+#define RCC_XBAR53CFGR_XBAR53EN			BIT(6)
+#define RCC_XBAR53CFGR_XBAR53STS		BIT(7)
+
+/* RCC_XBAR54CFGR register fields */
+#define RCC_XBAR54CFGR_XBAR54SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR54CFGR_XBAR54SEL_SHIFT		0
+#define RCC_XBAR54CFGR_XBAR54EN			BIT(6)
+#define RCC_XBAR54CFGR_XBAR54STS		BIT(7)
+
+/* RCC_XBAR55CFGR register fields */
+#define RCC_XBAR55CFGR_XBAR55SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR55CFGR_XBAR55SEL_SHIFT		0
+#define RCC_XBAR55CFGR_XBAR55EN			BIT(6)
+#define RCC_XBAR55CFGR_XBAR55STS		BIT(7)
+
+/* RCC_XBAR56CFGR register fields */
+#define RCC_XBAR56CFGR_XBAR56SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR56CFGR_XBAR56SEL_SHIFT		0
+#define RCC_XBAR56CFGR_XBAR56EN			BIT(6)
+#define RCC_XBAR56CFGR_XBAR56STS		BIT(7)
+
+/* RCC_XBAR57CFGR register fields */
+#define RCC_XBAR57CFGR_XBAR57SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR57CFGR_XBAR57SEL_SHIFT		0
+#define RCC_XBAR57CFGR_XBAR57EN			BIT(6)
+#define RCC_XBAR57CFGR_XBAR57STS		BIT(7)
+
+/* RCC_XBAR58CFGR register fields */
+#define RCC_XBAR58CFGR_XBAR58SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR58CFGR_XBAR58SEL_SHIFT		0
+#define RCC_XBAR58CFGR_XBAR58EN			BIT(6)
+#define RCC_XBAR58CFGR_XBAR58STS		BIT(7)
+
+/* RCC_XBAR59CFGR register fields */
+#define RCC_XBAR59CFGR_XBAR59SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR59CFGR_XBAR59SEL_SHIFT		0
+#define RCC_XBAR59CFGR_XBAR59EN			BIT(6)
+#define RCC_XBAR59CFGR_XBAR59STS		BIT(7)
+
+/* RCC_XBAR60CFGR register fields */
+#define RCC_XBAR60CFGR_XBAR60SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR60CFGR_XBAR60SEL_SHIFT		0
+#define RCC_XBAR60CFGR_XBAR60EN			BIT(6)
+#define RCC_XBAR60CFGR_XBAR60STS		BIT(7)
+
+/* RCC_XBAR61CFGR register fields */
+#define RCC_XBAR61CFGR_XBAR61SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR61CFGR_XBAR61SEL_SHIFT		0
+#define RCC_XBAR61CFGR_XBAR61EN			BIT(6)
+#define RCC_XBAR61CFGR_XBAR61STS		BIT(7)
+
+/* RCC_XBAR62CFGR register fields */
+#define RCC_XBAR62CFGR_XBAR62SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR62CFGR_XBAR62SEL_SHIFT		0
+#define RCC_XBAR62CFGR_XBAR62EN			BIT(6)
+#define RCC_XBAR62CFGR_XBAR62STS		BIT(7)
+
+/* RCC_XBAR63CFGR register fields */
+#define RCC_XBAR63CFGR_XBAR63SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR63CFGR_XBAR63SEL_SHIFT		0
+#define RCC_XBAR63CFGR_XBAR63EN			BIT(6)
+#define RCC_XBAR63CFGR_XBAR63STS		BIT(7)
+
+/* RCC_XBARxCFGR register fields */
+#define RCC_XBARxCFGR_XBARxSEL_MASK		GENMASK(3, 0)
+#define RCC_XBARxCFGR_XBARxSEL_SHIFT		0
+#define RCC_XBARxCFGR_XBARxEN			BIT(6)
+#define RCC_XBARxCFGR_XBARxSTS			BIT(7)
+
+/* RCC_PREDIV0CFGR register fields */
+#define RCC_PREDIV0CFGR_PREDIV0_MASK		GENMASK(9, 0)
+#define RCC_PREDIV0CFGR_PREDIV0_SHIFT		0
+
+/* RCC_PREDIV1CFGR register fields */
+#define RCC_PREDIV1CFGR_PREDIV1_MASK		GENMASK(9, 0)
+#define RCC_PREDIV1CFGR_PREDIV1_SHIFT		0
+
+/* RCC_PREDIV2CFGR register fields */
+#define RCC_PREDIV2CFGR_PREDIV2_MASK		GENMASK(9, 0)
+#define RCC_PREDIV2CFGR_PREDIV2_SHIFT		0
+
+/* RCC_PREDIV3CFGR register fields */
+#define RCC_PREDIV3CFGR_PREDIV3_MASK		GENMASK(9, 0)
+#define RCC_PREDIV3CFGR_PREDIV3_SHIFT		0
+
+/* RCC_PREDIV4CFGR register fields */
+#define RCC_PREDIV4CFGR_PREDIV4_MASK		GENMASK(9, 0)
+#define RCC_PREDIV4CFGR_PREDIV4_SHIFT		0
+
+/* RCC_PREDIV5CFGR register fields */
+#define RCC_PREDIV5CFGR_PREDIV5_MASK		GENMASK(9, 0)
+#define RCC_PREDIV5CFGR_PREDIV5_SHIFT		0
+
+/* RCC_PREDIV6CFGR register fields */
+#define RCC_PREDIV6CFGR_PREDIV6_MASK		GENMASK(9, 0)
+#define RCC_PREDIV6CFGR_PREDIV6_SHIFT		0
+
+/* RCC_PREDIV7CFGR register fields */
+#define RCC_PREDIV7CFGR_PREDIV7_MASK		GENMASK(9, 0)
+#define RCC_PREDIV7CFGR_PREDIV7_SHIFT		0
+
+/* RCC_PREDIV8CFGR register fields */
+#define RCC_PREDIV8CFGR_PREDIV8_MASK		GENMASK(9, 0)
+#define RCC_PREDIV8CFGR_PREDIV8_SHIFT		0
+
+/* RCC_PREDIV9CFGR register fields */
+#define RCC_PREDIV9CFGR_PREDIV9_MASK		GENMASK(9, 0)
+#define RCC_PREDIV9CFGR_PREDIV9_SHIFT		0
+
+/* RCC_PREDIV10CFGR register fields */
+#define RCC_PREDIV10CFGR_PREDIV10_MASK		GENMASK(9, 0)
+#define RCC_PREDIV10CFGR_PREDIV10_SHIFT		0
+
+/* RCC_PREDIV11CFGR register fields */
+#define RCC_PREDIV11CFGR_PREDIV11_MASK		GENMASK(9, 0)
+#define RCC_PREDIV11CFGR_PREDIV11_SHIFT		0
+
+/* RCC_PREDIV12CFGR register fields */
+#define RCC_PREDIV12CFGR_PREDIV12_MASK		GENMASK(9, 0)
+#define RCC_PREDIV12CFGR_PREDIV12_SHIFT		0
+
+/* RCC_PREDIV13CFGR register fields */
+#define RCC_PREDIV13CFGR_PREDIV13_MASK		GENMASK(9, 0)
+#define RCC_PREDIV13CFGR_PREDIV13_SHIFT		0
+
+/* RCC_PREDIV14CFGR register fields */
+#define RCC_PREDIV14CFGR_PREDIV14_MASK		GENMASK(9, 0)
+#define RCC_PREDIV14CFGR_PREDIV14_SHIFT		0
+
+/* RCC_PREDIV15CFGR register fields */
+#define RCC_PREDIV15CFGR_PREDIV15_MASK		GENMASK(9, 0)
+#define RCC_PREDIV15CFGR_PREDIV15_SHIFT		0
+
+/* RCC_PREDIV16CFGR register fields */
+#define RCC_PREDIV16CFGR_PREDIV16_MASK		GENMASK(9, 0)
+#define RCC_PREDIV16CFGR_PREDIV16_SHIFT		0
+
+/* RCC_PREDIV17CFGR register fields */
+#define RCC_PREDIV17CFGR_PREDIV17_MASK		GENMASK(9, 0)
+#define RCC_PREDIV17CFGR_PREDIV17_SHIFT		0
+
+/* RCC_PREDIV18CFGR register fields */
+#define RCC_PREDIV18CFGR_PREDIV18_MASK		GENMASK(9, 0)
+#define RCC_PREDIV18CFGR_PREDIV18_SHIFT		0
+
+/* RCC_PREDIV19CFGR register fields */
+#define RCC_PREDIV19CFGR_PREDIV19_MASK		GENMASK(9, 0)
+#define RCC_PREDIV19CFGR_PREDIV19_SHIFT		0
+
+/* RCC_PREDIV20CFGR register fields */
+#define RCC_PREDIV20CFGR_PREDIV20_MASK		GENMASK(9, 0)
+#define RCC_PREDIV20CFGR_PREDIV20_SHIFT		0
+
+/* RCC_PREDIV21CFGR register fields */
+#define RCC_PREDIV21CFGR_PREDIV21_MASK		GENMASK(9, 0)
+#define RCC_PREDIV21CFGR_PREDIV21_SHIFT		0
+
+/* RCC_PREDIV22CFGR register fields */
+#define RCC_PREDIV22CFGR_PREDIV22_MASK		GENMASK(9, 0)
+#define RCC_PREDIV22CFGR_PREDIV22_SHIFT		0
+
+/* RCC_PREDIV23CFGR register fields */
+#define RCC_PREDIV23CFGR_PREDIV23_MASK		GENMASK(9, 0)
+#define RCC_PREDIV23CFGR_PREDIV23_SHIFT		0
+
+/* RCC_PREDIV24CFGR register fields */
+#define RCC_PREDIV24CFGR_PREDIV24_MASK		GENMASK(9, 0)
+#define RCC_PREDIV24CFGR_PREDIV24_SHIFT		0
+
+/* RCC_PREDIV25CFGR register fields */
+#define RCC_PREDIV25CFGR_PREDIV25_MASK		GENMASK(9, 0)
+#define RCC_PREDIV25CFGR_PREDIV25_SHIFT		0
+
+/* RCC_PREDIV26CFGR register fields */
+#define RCC_PREDIV26CFGR_PREDIV26_MASK		GENMASK(9, 0)
+#define RCC_PREDIV26CFGR_PREDIV26_SHIFT		0
+
+/* RCC_PREDIV27CFGR register fields */
+#define RCC_PREDIV27CFGR_PREDIV27_MASK		GENMASK(9, 0)
+#define RCC_PREDIV27CFGR_PREDIV27_SHIFT		0
+
+/* RCC_PREDIV28CFGR register fields */
+#define RCC_PREDIV28CFGR_PREDIV28_MASK		GENMASK(9, 0)
+#define RCC_PREDIV28CFGR_PREDIV28_SHIFT		0
+
+/* RCC_PREDIV29CFGR register fields */
+#define RCC_PREDIV29CFGR_PREDIV29_MASK		GENMASK(9, 0)
+#define RCC_PREDIV29CFGR_PREDIV29_SHIFT		0
+
+/* RCC_PREDIV30CFGR register fields */
+#define RCC_PREDIV30CFGR_PREDIV30_MASK		GENMASK(9, 0)
+#define RCC_PREDIV30CFGR_PREDIV30_SHIFT		0
+
+/* RCC_PREDIV31CFGR register fields */
+#define RCC_PREDIV31CFGR_PREDIV31_MASK		GENMASK(9, 0)
+#define RCC_PREDIV31CFGR_PREDIV31_SHIFT		0
+
+/* RCC_PREDIV32CFGR register fields */
+#define RCC_PREDIV32CFGR_PREDIV32_MASK		GENMASK(9, 0)
+#define RCC_PREDIV32CFGR_PREDIV32_SHIFT		0
+
+/* RCC_PREDIV33CFGR register fields */
+#define RCC_PREDIV33CFGR_PREDIV33_MASK		GENMASK(9, 0)
+#define RCC_PREDIV33CFGR_PREDIV33_SHIFT		0
+
+/* RCC_PREDIV34CFGR register fields */
+#define RCC_PREDIV34CFGR_PREDIV34_MASK		GENMASK(9, 0)
+#define RCC_PREDIV34CFGR_PREDIV34_SHIFT		0
+
+/* RCC_PREDIV35CFGR register fields */
+#define RCC_PREDIV35CFGR_PREDIV35_MASK		GENMASK(9, 0)
+#define RCC_PREDIV35CFGR_PREDIV35_SHIFT		0
+
+/* RCC_PREDIV36CFGR register fields */
+#define RCC_PREDIV36CFGR_PREDIV36_MASK		GENMASK(9, 0)
+#define RCC_PREDIV36CFGR_PREDIV36_SHIFT		0
+
+/* RCC_PREDIV37CFGR register fields */
+#define RCC_PREDIV37CFGR_PREDIV37_MASK		GENMASK(9, 0)
+#define RCC_PREDIV37CFGR_PREDIV37_SHIFT		0
+
+/* RCC_PREDIV38CFGR register fields */
+#define RCC_PREDIV38CFGR_PREDIV38_MASK		GENMASK(9, 0)
+#define RCC_PREDIV38CFGR_PREDIV38_SHIFT		0
+
+/* RCC_PREDIV39CFGR register fields */
+#define RCC_PREDIV39CFGR_PREDIV39_MASK		GENMASK(9, 0)
+#define RCC_PREDIV39CFGR_PREDIV39_SHIFT		0
+
+/* RCC_PREDIV40CFGR register fields */
+#define RCC_PREDIV40CFGR_PREDIV40_MASK		GENMASK(9, 0)
+#define RCC_PREDIV40CFGR_PREDIV40_SHIFT		0
+
+/* RCC_PREDIV41CFGR register fields */
+#define RCC_PREDIV41CFGR_PREDIV41_MASK		GENMASK(9, 0)
+#define RCC_PREDIV41CFGR_PREDIV41_SHIFT		0
+
+/* RCC_PREDIV42CFGR register fields */
+#define RCC_PREDIV42CFGR_PREDIV42_MASK		GENMASK(9, 0)
+#define RCC_PREDIV42CFGR_PREDIV42_SHIFT		0
+
+/* RCC_PREDIV43CFGR register fields */
+#define RCC_PREDIV43CFGR_PREDIV43_MASK		GENMASK(9, 0)
+#define RCC_PREDIV43CFGR_PREDIV43_SHIFT		0
+
+/* RCC_PREDIV44CFGR register fields */
+#define RCC_PREDIV44CFGR_PREDIV44_MASK		GENMASK(9, 0)
+#define RCC_PREDIV44CFGR_PREDIV44_SHIFT		0
+
+/* RCC_PREDIV45CFGR register fields */
+#define RCC_PREDIV45CFGR_PREDIV45_MASK		GENMASK(9, 0)
+#define RCC_PREDIV45CFGR_PREDIV45_SHIFT		0
+
+/* RCC_PREDIV46CFGR register fields */
+#define RCC_PREDIV46CFGR_PREDIV46_MASK		GENMASK(9, 0)
+#define RCC_PREDIV46CFGR_PREDIV46_SHIFT		0
+
+/* RCC_PREDIV47CFGR register fields */
+#define RCC_PREDIV47CFGR_PREDIV47_MASK		GENMASK(9, 0)
+#define RCC_PREDIV47CFGR_PREDIV47_SHIFT		0
+
+/* RCC_PREDIV48CFGR register fields */
+#define RCC_PREDIV48CFGR_PREDIV48_MASK		GENMASK(9, 0)
+#define RCC_PREDIV48CFGR_PREDIV48_SHIFT		0
+
+/* RCC_PREDIV49CFGR register fields */
+#define RCC_PREDIV49CFGR_PREDIV49_MASK		GENMASK(9, 0)
+#define RCC_PREDIV49CFGR_PREDIV49_SHIFT		0
+
+/* RCC_PREDIV50CFGR register fields */
+#define RCC_PREDIV50CFGR_PREDIV50_MASK		GENMASK(9, 0)
+#define RCC_PREDIV50CFGR_PREDIV50_SHIFT		0
+
+/* RCC_PREDIV51CFGR register fields */
+#define RCC_PREDIV51CFGR_PREDIV51_MASK		GENMASK(9, 0)
+#define RCC_PREDIV51CFGR_PREDIV51_SHIFT		0
+
+/* RCC_PREDIV52CFGR register fields */
+#define RCC_PREDIV52CFGR_PREDIV52_MASK		GENMASK(9, 0)
+#define RCC_PREDIV52CFGR_PREDIV52_SHIFT		0
+
+/* RCC_PREDIV53CFGR register fields */
+#define RCC_PREDIV53CFGR_PREDIV53_MASK		GENMASK(9, 0)
+#define RCC_PREDIV53CFGR_PREDIV53_SHIFT		0
+
+/* RCC_PREDIV54CFGR register fields */
+#define RCC_PREDIV54CFGR_PREDIV54_MASK		GENMASK(9, 0)
+#define RCC_PREDIV54CFGR_PREDIV54_SHIFT		0
+
+/* RCC_PREDIV55CFGR register fields */
+#define RCC_PREDIV55CFGR_PREDIV55_MASK		GENMASK(9, 0)
+#define RCC_PREDIV55CFGR_PREDIV55_SHIFT		0
+
+/* RCC_PREDIV56CFGR register fields */
+#define RCC_PREDIV56CFGR_PREDIV56_MASK		GENMASK(9, 0)
+#define RCC_PREDIV56CFGR_PREDIV56_SHIFT		0
+
+/* RCC_PREDIV57CFGR register fields */
+#define RCC_PREDIV57CFGR_PREDIV57_MASK		GENMASK(9, 0)
+#define RCC_PREDIV57CFGR_PREDIV57_SHIFT		0
+
+/* RCC_PREDIV58CFGR register fields */
+#define RCC_PREDIV58CFGR_PREDIV58_MASK		GENMASK(9, 0)
+#define RCC_PREDIV58CFGR_PREDIV58_SHIFT		0
+
+/* RCC_PREDIV59CFGR register fields */
+#define RCC_PREDIV59CFGR_PREDIV59_MASK		GENMASK(9, 0)
+#define RCC_PREDIV59CFGR_PREDIV59_SHIFT		0
+
+/* RCC_PREDIV60CFGR register fields */
+#define RCC_PREDIV60CFGR_PREDIV60_MASK		GENMASK(9, 0)
+#define RCC_PREDIV60CFGR_PREDIV60_SHIFT		0
+
+/* RCC_PREDIV61CFGR register fields */
+#define RCC_PREDIV61CFGR_PREDIV61_MASK		GENMASK(9, 0)
+#define RCC_PREDIV61CFGR_PREDIV61_SHIFT		0
+
+/* RCC_PREDIV62CFGR register fields */
+#define RCC_PREDIV62CFGR_PREDIV62_MASK		GENMASK(9, 0)
+#define RCC_PREDIV62CFGR_PREDIV62_SHIFT		0
+
+/* RCC_PREDIV63CFGR register fields */
+#define RCC_PREDIV63CFGR_PREDIV63_MASK		GENMASK(9, 0)
+#define RCC_PREDIV63CFGR_PREDIV63_SHIFT		0
+
+/* RCC_PREDIVxCFGR register fields */
+#define RCC_PREDIVxCFGR_PREDIVx_MASK		GENMASK(9, 0)
+#define RCC_PREDIVxCFGR_PREDIVx_SHIFT		0
+
+/* RCC_FINDIV0CFGR register fields */
+#define RCC_FINDIV0CFGR_FINDIV0_MASK		GENMASK(5, 0)
+#define RCC_FINDIV0CFGR_FINDIV0_SHIFT		0
+#define RCC_FINDIV0CFGR_FINDIV0EN		BIT(6)
+
+/* RCC_FINDIV1CFGR register fields */
+#define RCC_FINDIV1CFGR_FINDIV1_MASK		GENMASK(5, 0)
+#define RCC_FINDIV1CFGR_FINDIV1_SHIFT		0
+#define RCC_FINDIV1CFGR_FINDIV1EN		BIT(6)
+
+/* RCC_FINDIV2CFGR register fields */
+#define RCC_FINDIV2CFGR_FINDIV2_MASK		GENMASK(5, 0)
+#define RCC_FINDIV2CFGR_FINDIV2_SHIFT		0
+#define RCC_FINDIV2CFGR_FINDIV2EN		BIT(6)
+
+/* RCC_FINDIV3CFGR register fields */
+#define RCC_FINDIV3CFGR_FINDIV3_MASK		GENMASK(5, 0)
+#define RCC_FINDIV3CFGR_FINDIV3_SHIFT		0
+#define RCC_FINDIV3CFGR_FINDIV3EN		BIT(6)
+
+/* RCC_FINDIV4CFGR register fields */
+#define RCC_FINDIV4CFGR_FINDIV4_MASK		GENMASK(5, 0)
+#define RCC_FINDIV4CFGR_FINDIV4_SHIFT		0
+#define RCC_FINDIV4CFGR_FINDIV4EN		BIT(6)
+
+/* RCC_FINDIV5CFGR register fields */
+#define RCC_FINDIV5CFGR_FINDIV5_MASK		GENMASK(5, 0)
+#define RCC_FINDIV5CFGR_FINDIV5_SHIFT		0
+#define RCC_FINDIV5CFGR_FINDIV5EN		BIT(6)
+
+/* RCC_FINDIV6CFGR register fields */
+#define RCC_FINDIV6CFGR_FINDIV6_MASK		GENMASK(5, 0)
+#define RCC_FINDIV6CFGR_FINDIV6_SHIFT		0
+#define RCC_FINDIV6CFGR_FINDIV6EN		BIT(6)
+
+/* RCC_FINDIV7CFGR register fields */
+#define RCC_FINDIV7CFGR_FINDIV7_MASK		GENMASK(5, 0)
+#define RCC_FINDIV7CFGR_FINDIV7_SHIFT		0
+#define RCC_FINDIV7CFGR_FINDIV7EN		BIT(6)
+
+/* RCC_FINDIV8CFGR register fields */
+#define RCC_FINDIV8CFGR_FINDIV8_MASK		GENMASK(5, 0)
+#define RCC_FINDIV8CFGR_FINDIV8_SHIFT		0
+#define RCC_FINDIV8CFGR_FINDIV8EN		BIT(6)
+
+/* RCC_FINDIV9CFGR register fields */
+#define RCC_FINDIV9CFGR_FINDIV9_MASK		GENMASK(5, 0)
+#define RCC_FINDIV9CFGR_FINDIV9_SHIFT		0
+#define RCC_FINDIV9CFGR_FINDIV9EN		BIT(6)
+
+/* RCC_FINDIV10CFGR register fields */
+#define RCC_FINDIV10CFGR_FINDIV10_MASK		GENMASK(5, 0)
+#define RCC_FINDIV10CFGR_FINDIV10_SHIFT		0
+#define RCC_FINDIV10CFGR_FINDIV10EN		BIT(6)
+
+/* RCC_FINDIV11CFGR register fields */
+#define RCC_FINDIV11CFGR_FINDIV11_MASK		GENMASK(5, 0)
+#define RCC_FINDIV11CFGR_FINDIV11_SHIFT		0
+#define RCC_FINDIV11CFGR_FINDIV11EN		BIT(6)
+
+/* RCC_FINDIV12CFGR register fields */
+#define RCC_FINDIV12CFGR_FINDIV12_MASK		GENMASK(5, 0)
+#define RCC_FINDIV12CFGR_FINDIV12_SHIFT		0
+#define RCC_FINDIV12CFGR_FINDIV12EN		BIT(6)
+
+/* RCC_FINDIV13CFGR register fields */
+#define RCC_FINDIV13CFGR_FINDIV13_MASK		GENMASK(5, 0)
+#define RCC_FINDIV13CFGR_FINDIV13_SHIFT		0
+#define RCC_FINDIV13CFGR_FINDIV13EN		BIT(6)
+
+/* RCC_FINDIV14CFGR register fields */
+#define RCC_FINDIV14CFGR_FINDIV14_MASK		GENMASK(5, 0)
+#define RCC_FINDIV14CFGR_FINDIV14_SHIFT		0
+#define RCC_FINDIV14CFGR_FINDIV14EN		BIT(6)
+
+/* RCC_FINDIV15CFGR register fields */
+#define RCC_FINDIV15CFGR_FINDIV15_MASK		GENMASK(5, 0)
+#define RCC_FINDIV15CFGR_FINDIV15_SHIFT		0
+#define RCC_FINDIV15CFGR_FINDIV15EN		BIT(6)
+
+/* RCC_FINDIV16CFGR register fields */
+#define RCC_FINDIV16CFGR_FINDIV16_MASK		GENMASK(5, 0)
+#define RCC_FINDIV16CFGR_FINDIV16_SHIFT		0
+#define RCC_FINDIV16CFGR_FINDIV16EN		BIT(6)
+
+/* RCC_FINDIV17CFGR register fields */
+#define RCC_FINDIV17CFGR_FINDIV17_MASK		GENMASK(5, 0)
+#define RCC_FINDIV17CFGR_FINDIV17_SHIFT		0
+#define RCC_FINDIV17CFGR_FINDIV17EN		BIT(6)
+
+/* RCC_FINDIV18CFGR register fields */
+#define RCC_FINDIV18CFGR_FINDIV18_MASK		GENMASK(5, 0)
+#define RCC_FINDIV18CFGR_FINDIV18_SHIFT		0
+#define RCC_FINDIV18CFGR_FINDIV18EN		BIT(6)
+
+/* RCC_FINDIV19CFGR register fields */
+#define RCC_FINDIV19CFGR_FINDIV19_MASK		GENMASK(5, 0)
+#define RCC_FINDIV19CFGR_FINDIV19_SHIFT		0
+#define RCC_FINDIV19CFGR_FINDIV19EN		BIT(6)
+
+/* RCC_FINDIV20CFGR register fields */
+#define RCC_FINDIV20CFGR_FINDIV20_MASK		GENMASK(5, 0)
+#define RCC_FINDIV20CFGR_FINDIV20_SHIFT		0
+#define RCC_FINDIV20CFGR_FINDIV20EN		BIT(6)
+
+/* RCC_FINDIV21CFGR register fields */
+#define RCC_FINDIV21CFGR_FINDIV21_MASK		GENMASK(5, 0)
+#define RCC_FINDIV21CFGR_FINDIV21_SHIFT		0
+#define RCC_FINDIV21CFGR_FINDIV21EN		BIT(6)
+
+/* RCC_FINDIV22CFGR register fields */
+#define RCC_FINDIV22CFGR_FINDIV22_MASK		GENMASK(5, 0)
+#define RCC_FINDIV22CFGR_FINDIV22_SHIFT		0
+#define RCC_FINDIV22CFGR_FINDIV22EN		BIT(6)
+
+/* RCC_FINDIV23CFGR register fields */
+#define RCC_FINDIV23CFGR_FINDIV23_MASK		GENMASK(5, 0)
+#define RCC_FINDIV23CFGR_FINDIV23_SHIFT		0
+#define RCC_FINDIV23CFGR_FINDIV23EN		BIT(6)
+
+/* RCC_FINDIV24CFGR register fields */
+#define RCC_FINDIV24CFGR_FINDIV24_MASK		GENMASK(5, 0)
+#define RCC_FINDIV24CFGR_FINDIV24_SHIFT		0
+#define RCC_FINDIV24CFGR_FINDIV24EN		BIT(6)
+
+/* RCC_FINDIV25CFGR register fields */
+#define RCC_FINDIV25CFGR_FINDIV25_MASK		GENMASK(5, 0)
+#define RCC_FINDIV25CFGR_FINDIV25_SHIFT		0
+#define RCC_FINDIV25CFGR_FINDIV25EN		BIT(6)
+
+/* RCC_FINDIV26CFGR register fields */
+#define RCC_FINDIV26CFGR_FINDIV26_MASK		GENMASK(5, 0)
+#define RCC_FINDIV26CFGR_FINDIV26_SHIFT		0
+#define RCC_FINDIV26CFGR_FINDIV26EN		BIT(6)
+
+/* RCC_FINDIV27CFGR register fields */
+#define RCC_FINDIV27CFGR_FINDIV27_MASK		GENMASK(5, 0)
+#define RCC_FINDIV27CFGR_FINDIV27_SHIFT		0
+#define RCC_FINDIV27CFGR_FINDIV27EN		BIT(6)
+
+/* RCC_FINDIV28CFGR register fields */
+#define RCC_FINDIV28CFGR_FINDIV28_MASK		GENMASK(5, 0)
+#define RCC_FINDIV28CFGR_FINDIV28_SHIFT		0
+#define RCC_FINDIV28CFGR_FINDIV28EN		BIT(6)
+
+/* RCC_FINDIV29CFGR register fields */
+#define RCC_FINDIV29CFGR_FINDIV29_MASK		GENMASK(5, 0)
+#define RCC_FINDIV29CFGR_FINDIV29_SHIFT		0
+#define RCC_FINDIV29CFGR_FINDIV29EN		BIT(6)
+
+/* RCC_FINDIV30CFGR register fields */
+#define RCC_FINDIV30CFGR_FINDIV30_MASK		GENMASK(5, 0)
+#define RCC_FINDIV30CFGR_FINDIV30_SHIFT		0
+#define RCC_FINDIV30CFGR_FINDIV30EN		BIT(6)
+
+/* RCC_FINDIV31CFGR register fields */
+#define RCC_FINDIV31CFGR_FINDIV31_MASK		GENMASK(5, 0)
+#define RCC_FINDIV31CFGR_FINDIV31_SHIFT		0
+#define RCC_FINDIV31CFGR_FINDIV31EN		BIT(6)
+
+/* RCC_FINDIV32CFGR register fields */
+#define RCC_FINDIV32CFGR_FINDIV32_MASK		GENMASK(5, 0)
+#define RCC_FINDIV32CFGR_FINDIV32_SHIFT		0
+#define RCC_FINDIV32CFGR_FINDIV32EN		BIT(6)
+
+/* RCC_FINDIV33CFGR register fields */
+#define RCC_FINDIV33CFGR_FINDIV33_MASK		GENMASK(5, 0)
+#define RCC_FINDIV33CFGR_FINDIV33_SHIFT		0
+#define RCC_FINDIV33CFGR_FINDIV33EN		BIT(6)
+
+/* RCC_FINDIV34CFGR register fields */
+#define RCC_FINDIV34CFGR_FINDIV34_MASK		GENMASK(5, 0)
+#define RCC_FINDIV34CFGR_FINDIV34_SHIFT		0
+#define RCC_FINDIV34CFGR_FINDIV34EN		BIT(6)
+
+/* RCC_FINDIV35CFGR register fields */
+#define RCC_FINDIV35CFGR_FINDIV35_MASK		GENMASK(5, 0)
+#define RCC_FINDIV35CFGR_FINDIV35_SHIFT		0
+#define RCC_FINDIV35CFGR_FINDIV35EN		BIT(6)
+
+/* RCC_FINDIV36CFGR register fields */
+#define RCC_FINDIV36CFGR_FINDIV36_MASK		GENMASK(5, 0)
+#define RCC_FINDIV36CFGR_FINDIV36_SHIFT		0
+#define RCC_FINDIV36CFGR_FINDIV36EN		BIT(6)
+
+/* RCC_FINDIV37CFGR register fields */
+#define RCC_FINDIV37CFGR_FINDIV37_MASK		GENMASK(5, 0)
+#define RCC_FINDIV37CFGR_FINDIV37_SHIFT		0
+#define RCC_FINDIV37CFGR_FINDIV37EN		BIT(6)
+
+/* RCC_FINDIV38CFGR register fields */
+#define RCC_FINDIV38CFGR_FINDIV38_MASK		GENMASK(5, 0)
+#define RCC_FINDIV38CFGR_FINDIV38_SHIFT		0
+#define RCC_FINDIV38CFGR_FINDIV38EN		BIT(6)
+
+/* RCC_FINDIV39CFGR register fields */
+#define RCC_FINDIV39CFGR_FINDIV39_MASK		GENMASK(5, 0)
+#define RCC_FINDIV39CFGR_FINDIV39_SHIFT		0
+#define RCC_FINDIV39CFGR_FINDIV39EN		BIT(6)
+
+/* RCC_FINDIV40CFGR register fields */
+#define RCC_FINDIV40CFGR_FINDIV40_MASK		GENMASK(5, 0)
+#define RCC_FINDIV40CFGR_FINDIV40_SHIFT		0
+#define RCC_FINDIV40CFGR_FINDIV40EN		BIT(6)
+
+/* RCC_FINDIV41CFGR register fields */
+#define RCC_FINDIV41CFGR_FINDIV41_MASK		GENMASK(5, 0)
+#define RCC_FINDIV41CFGR_FINDIV41_SHIFT		0
+#define RCC_FINDIV41CFGR_FINDIV41EN		BIT(6)
+
+/* RCC_FINDIV42CFGR register fields */
+#define RCC_FINDIV42CFGR_FINDIV42_MASK		GENMASK(5, 0)
+#define RCC_FINDIV42CFGR_FINDIV42_SHIFT		0
+#define RCC_FINDIV42CFGR_FINDIV42EN		BIT(6)
+
+/* RCC_FINDIV43CFGR register fields */
+#define RCC_FINDIV43CFGR_FINDIV43_MASK		GENMASK(5, 0)
+#define RCC_FINDIV43CFGR_FINDIV43_SHIFT		0
+#define RCC_FINDIV43CFGR_FINDIV43EN		BIT(6)
+
+/* RCC_FINDIV44CFGR register fields */
+#define RCC_FINDIV44CFGR_FINDIV44_MASK		GENMASK(5, 0)
+#define RCC_FINDIV44CFGR_FINDIV44_SHIFT		0
+#define RCC_FINDIV44CFGR_FINDIV44EN		BIT(6)
+
+/* RCC_FINDIV45CFGR register fields */
+#define RCC_FINDIV45CFGR_FINDIV45_MASK		GENMASK(5, 0)
+#define RCC_FINDIV45CFGR_FINDIV45_SHIFT		0
+#define RCC_FINDIV45CFGR_FINDIV45EN		BIT(6)
+
+/* RCC_FINDIV46CFGR register fields */
+#define RCC_FINDIV46CFGR_FINDIV46_MASK		GENMASK(5, 0)
+#define RCC_FINDIV46CFGR_FINDIV46_SHIFT		0
+#define RCC_FINDIV46CFGR_FINDIV46EN		BIT(6)
+
+/* RCC_FINDIV47CFGR register fields */
+#define RCC_FINDIV47CFGR_FINDIV47_MASK		GENMASK(5, 0)
+#define RCC_FINDIV47CFGR_FINDIV47_SHIFT		0
+#define RCC_FINDIV47CFGR_FINDIV47EN		BIT(6)
+
+/* RCC_FINDIV48CFGR register fields */
+#define RCC_FINDIV48CFGR_FINDIV48_MASK		GENMASK(5, 0)
+#define RCC_FINDIV48CFGR_FINDIV48_SHIFT		0
+#define RCC_FINDIV48CFGR_FINDIV48EN		BIT(6)
+
+/* RCC_FINDIV49CFGR register fields */
+#define RCC_FINDIV49CFGR_FINDIV49_MASK		GENMASK(5, 0)
+#define RCC_FINDIV49CFGR_FINDIV49_SHIFT		0
+#define RCC_FINDIV49CFGR_FINDIV49EN		BIT(6)
+
+/* RCC_FINDIV50CFGR register fields */
+#define RCC_FINDIV50CFGR_FINDIV50_MASK		GENMASK(5, 0)
+#define RCC_FINDIV50CFGR_FINDIV50_SHIFT		0
+#define RCC_FINDIV50CFGR_FINDIV50EN		BIT(6)
+
+/* RCC_FINDIV51CFGR register fields */
+#define RCC_FINDIV51CFGR_FINDIV51_MASK		GENMASK(5, 0)
+#define RCC_FINDIV51CFGR_FINDIV51_SHIFT		0
+#define RCC_FINDIV51CFGR_FINDIV51EN		BIT(6)
+
+/* RCC_FINDIV52CFGR register fields */
+#define RCC_FINDIV52CFGR_FINDIV52_MASK		GENMASK(5, 0)
+#define RCC_FINDIV52CFGR_FINDIV52_SHIFT		0
+#define RCC_FINDIV52CFGR_FINDIV52EN		BIT(6)
+
+/* RCC_FINDIV53CFGR register fields */
+#define RCC_FINDIV53CFGR_FINDIV53_MASK		GENMASK(5, 0)
+#define RCC_FINDIV53CFGR_FINDIV53_SHIFT		0
+#define RCC_FINDIV53CFGR_FINDIV53EN		BIT(6)
+
+/* RCC_FINDIV54CFGR register fields */
+#define RCC_FINDIV54CFGR_FINDIV54_MASK		GENMASK(5, 0)
+#define RCC_FINDIV54CFGR_FINDIV54_SHIFT		0
+#define RCC_FINDIV54CFGR_FINDIV54EN		BIT(6)
+
+/* RCC_FINDIV55CFGR register fields */
+#define RCC_FINDIV55CFGR_FINDIV55_MASK		GENMASK(5, 0)
+#define RCC_FINDIV55CFGR_FINDIV55_SHIFT		0
+#define RCC_FINDIV55CFGR_FINDIV55EN		BIT(6)
+
+/* RCC_FINDIV56CFGR register fields */
+#define RCC_FINDIV56CFGR_FINDIV56_MASK		GENMASK(5, 0)
+#define RCC_FINDIV56CFGR_FINDIV56_SHIFT		0
+#define RCC_FINDIV56CFGR_FINDIV56EN		BIT(6)
+
+/* RCC_FINDIV57CFGR register fields */
+#define RCC_FINDIV57CFGR_FINDIV57_MASK		GENMASK(5, 0)
+#define RCC_FINDIV57CFGR_FINDIV57_SHIFT		0
+#define RCC_FINDIV57CFGR_FINDIV57EN		BIT(6)
+
+/* RCC_FINDIV58CFGR register fields */
+#define RCC_FINDIV58CFGR_FINDIV58_MASK		GENMASK(5, 0)
+#define RCC_FINDIV58CFGR_FINDIV58_SHIFT		0
+#define RCC_FINDIV58CFGR_FINDIV58EN		BIT(6)
+
+/* RCC_FINDIV59CFGR register fields */
+#define RCC_FINDIV59CFGR_FINDIV59_MASK		GENMASK(5, 0)
+#define RCC_FINDIV59CFGR_FINDIV59_SHIFT		0
+#define RCC_FINDIV59CFGR_FINDIV59EN		BIT(6)
+
+/* RCC_FINDIV60CFGR register fields */
+#define RCC_FINDIV60CFGR_FINDIV60_MASK		GENMASK(5, 0)
+#define RCC_FINDIV60CFGR_FINDIV60_SHIFT		0
+#define RCC_FINDIV60CFGR_FINDIV60EN		BIT(6)
+
+/* RCC_FINDIV61CFGR register fields */
+#define RCC_FINDIV61CFGR_FINDIV61_MASK		GENMASK(5, 0)
+#define RCC_FINDIV61CFGR_FINDIV61_SHIFT		0
+#define RCC_FINDIV61CFGR_FINDIV61EN		BIT(6)
+
+/* RCC_FINDIV62CFGR register fields */
+#define RCC_FINDIV62CFGR_FINDIV62_MASK		GENMASK(5, 0)
+#define RCC_FINDIV62CFGR_FINDIV62_SHIFT		0
+#define RCC_FINDIV62CFGR_FINDIV62EN		BIT(6)
+
+/* RCC_FINDIV63CFGR register fields */
+#define RCC_FINDIV63CFGR_FINDIV63_MASK		GENMASK(5, 0)
+#define RCC_FINDIV63CFGR_FINDIV63_SHIFT		0
+#define RCC_FINDIV63CFGR_FINDIV63EN		BIT(6)
+
+/* RCC_FINDIVxCFGR register fields */
+#define RCC_FINDIVxCFGR_FINDIVx_MASK		GENMASK(5, 0)
+#define RCC_FINDIVxCFGR_FINDIVx_SHIFT		0
+#define RCC_FINDIVxCFGR_FINDIVxEN		BIT(6)
+
+/* RCC_FCALCOBS0CFGR register fields */
+#define RCC_FCALCOBS0CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS0CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS0CFGR_FCALCCKEXTSEL		BIT(15)
+#define RCC_FCALCOBS0CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS0CFGR_FCALCCKINV		BIT(17)
+#define RCC_FCALCOBS0CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS0CFGR_FCALCCKEN		BIT(25)
+#define RCC_FCALCOBS0CFGR_CKOBSEN		BIT(26)
+
+/* RCC_FCALCOBS1CFGR register fields */
+#define RCC_FCALCOBS1CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS1CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS1CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS1CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS1CFGR_CKOBSEN		BIT(26)
+#define RCC_FCALCOBS1CFGR_FCALCRSTN		BIT(27)
+
+/* RCC_FCALCREFCFGR register fields */
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_MASK	GENMASK(2, 0)
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_SHIFT	0
+
+/* RCC_FCALCCR1 register fields */
+#define RCC_FCALCCR1_FCALCRUN			BIT(0)
+
+/* RCC_FCALCCR2 register fields */
+#define RCC_FCALCCR2_FCALCMD_MASK		GENMASK(4, 3)
+#define RCC_FCALCCR2_FCALCMD_SHIFT		3
+#define RCC_FCALCCR2_FCALCTWC_MASK		GENMASK(14, 11)
+#define RCC_FCALCCR2_FCALCTWC_SHIFT		11
+#define RCC_FCALCCR2_FCALCTYP_MASK		GENMASK(21, 17)
+#define RCC_FCALCCR2_FCALCTYP_SHIFT		17
+
+/* RCC_FCALCSR register fields */
+#define RCC_FCALCSR_FVAL_MASK			GENMASK(16, 0)
+#define RCC_FCALCSR_FVAL_SHIFT			0
+#define RCC_FCALCSR_FCALCSTS			BIT(19)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL4CFGR1_PLLEN			BIT(8)
+#define RCC_PLL4CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL4CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL4CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL4CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL4CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL4CFGR3 register fields */
+#define RCC_PLL4CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL4CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL4CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL4CFGR3_DACEN			BIT(25)
+#define RCC_PLL4CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL4CFGR4 register fields */
+#define RCC_PLL4CFGR4_DSMEN			BIT(8)
+#define RCC_PLL4CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL4CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL4CFGR5 register fields */
+#define RCC_PLL4CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL4CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL4CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL4CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL4CFGR6 register fields */
+#define RCC_PLL4CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL4CFGR7 register fields */
+#define RCC_PLL4CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL5CFGR1 register fields */
+#define RCC_PLL5CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL5CFGR1_PLLEN			BIT(8)
+#define RCC_PLL5CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL5CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL5CFGR2 register fields */
+#define RCC_PLL5CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL5CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL5CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL5CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL5CFGR3 register fields */
+#define RCC_PLL5CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL5CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL5CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL5CFGR3_DACEN			BIT(25)
+#define RCC_PLL5CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL5CFGR4 register fields */
+#define RCC_PLL5CFGR4_DSMEN			BIT(8)
+#define RCC_PLL5CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL5CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL5CFGR5 register fields */
+#define RCC_PLL5CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL5CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL5CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL5CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL5CFGR6 register fields */
+#define RCC_PLL5CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL5CFGR7 register fields */
+#define RCC_PLL5CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL6CFGR1 register fields */
+#define RCC_PLL6CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL6CFGR1_PLLEN			BIT(8)
+#define RCC_PLL6CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL6CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL6CFGR2 register fields */
+#define RCC_PLL6CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL6CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL6CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL6CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL6CFGR3 register fields */
+#define RCC_PLL6CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL6CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL6CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL6CFGR3_DACEN			BIT(25)
+#define RCC_PLL6CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL6CFGR4 register fields */
+#define RCC_PLL6CFGR4_DSMEN			BIT(8)
+#define RCC_PLL6CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL6CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL6CFGR5 register fields */
+#define RCC_PLL6CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL6CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL6CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL6CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL6CFGR6 register fields */
+#define RCC_PLL6CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL6CFGR7 register fields */
+#define RCC_PLL6CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL7CFGR1 register fields */
+#define RCC_PLL7CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL7CFGR1_PLLEN			BIT(8)
+#define RCC_PLL7CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL7CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL7CFGR2 register fields */
+#define RCC_PLL7CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL7CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL7CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL7CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL7CFGR3 register fields */
+#define RCC_PLL7CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL7CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL7CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL7CFGR3_DACEN			BIT(25)
+#define RCC_PLL7CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL7CFGR4 register fields */
+#define RCC_PLL7CFGR4_DSMEN			BIT(8)
+#define RCC_PLL7CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL7CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL7CFGR5 register fields */
+#define RCC_PLL7CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL7CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL7CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL7CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL7CFGR6 register fields */
+#define RCC_PLL7CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL7CFGR7 register fields */
+#define RCC_PLL7CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL8CFGR1 register fields */
+#define RCC_PLL8CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL8CFGR1_PLLEN			BIT(8)
+#define RCC_PLL8CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL8CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL8CFGR2 register fields */
+#define RCC_PLL8CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL8CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL8CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL8CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL8CFGR3 register fields */
+#define RCC_PLL8CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL8CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL8CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL8CFGR3_DACEN			BIT(25)
+#define RCC_PLL8CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL8CFGR4 register fields */
+#define RCC_PLL8CFGR4_DSMEN			BIT(8)
+#define RCC_PLL8CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL8CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL8CFGR5 register fields */
+#define RCC_PLL8CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL8CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL8CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL8CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL8CFGR6 register fields */
+#define RCC_PLL8CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL8CFGR7 register fields */
+#define RCC_PLL8CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RCC_VERR_MINREV_SHIFT			0
+#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RCC_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP25_RCC_H */
diff --git a/drivers/clocksource/timer-stm32-lp.c b/drivers/clocksource/timer-stm32-lp.c
index db2841d0b..41ee2cb4e 100644
--- a/drivers/clocksource/timer-stm32-lp.c
+++ b/drivers/clocksource/timer-stm32-lp.c
@@ -168,9 +168,7 @@ static int stm32_clkevent_lp_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_bool(pdev->dev.parent->of_node, "wakeup-source")) {
-		ret = device_init_wakeup(&pdev->dev, true);
-		if (ret)
-			goto out_clk_disable;
+		device_set_wakeup_capable(&pdev->dev, true);
 
 		ret = dev_pm_set_wake_irq(&pdev->dev, irq);
 		if (ret)
@@ -202,6 +200,7 @@ static int stm32_clkevent_lp_remove(struct platform_device *pdev)
 
 static const struct of_device_id stm32_clkevent_lp_of_match[] = {
 	{ .compatible = "st,stm32-lptimer-timer", },
+	{ .compatible = "st,stm32mp25-lptimer-timer", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_clkevent_lp_of_match);
diff --git a/drivers/counter/stm32-lptimer-cnt.c b/drivers/counter/stm32-lptimer-cnt.c
index 843975555..309398118 100644
--- a/drivers/counter/stm32-lptimer-cnt.c
+++ b/drivers/counter/stm32-lptimer-cnt.c
@@ -502,6 +502,7 @@ static SIMPLE_DEV_PM_OPS(stm32_lptim_cnt_pm_ops, stm32_lptim_cnt_suspend,
 
 static const struct of_device_id stm32_lptim_cnt_of_match[] = {
 	{ .compatible = "st,stm32-lptimer-counter", },
+	{ .compatible = "st,stm32mp25-lptimer-counter", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_lptim_cnt_of_match);
diff --git a/drivers/counter/stm32-timer-cnt.c b/drivers/counter/stm32-timer-cnt.c
index 9bf20a5d6..d80521196 100644
--- a/drivers/counter/stm32-timer-cnt.c
+++ b/drivers/counter/stm32-timer-cnt.c
@@ -8,9 +8,11 @@
  *
  */
 #include <linux/counter.h>
+#include <linux/interrupt.h>
 #include <linux/mfd/stm32-timers.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/types.h>
@@ -21,6 +23,12 @@
 #define TIM_CCER_MASK	(TIM_CCER_CC1P | TIM_CCER_CC1NP | \
 			 TIM_CCER_CC2P | TIM_CCER_CC2NP)
 
+#define STM32_CH1_SIG		0
+#define STM32_CH2_SIG		1
+#define STM32_CLOCK_SIG		2
+#define STM32_CH3_SIG		3
+#define STM32_CH4_SIG		4
+
 struct stm32_timer_regs {
 	u32 cr1;
 	u32 cnt;
@@ -34,6 +42,11 @@ struct stm32_timer_cnt {
 	u32 max_arr;
 	bool enabled;
 	struct stm32_timer_regs bak;
+	bool has_encoder;
+	unsigned int nchannels;
+	unsigned int nr_irqs;
+	spinlock_t lock; /* protects nb_ovf */
+	u64 nb_ovf;
 };
 
 static const enum counter_function stm32_count_functions[] = {
@@ -107,12 +120,18 @@ static int stm32_count_function_write(struct counter_device *counter,
 		sms = TIM_SMCR_SMS_SLAVE_MODE_DISABLED;
 		break;
 	case COUNTER_FUNCTION_QUADRATURE_X2_A:
+		if (!priv->has_encoder)
+			return -EOPNOTSUPP;
 		sms = TIM_SMCR_SMS_ENCODER_MODE_1;
 		break;
 	case COUNTER_FUNCTION_QUADRATURE_X2_B:
+		if (!priv->has_encoder)
+			return -EOPNOTSUPP;
 		sms = TIM_SMCR_SMS_ENCODER_MODE_2;
 		break;
 	case COUNTER_FUNCTION_QUADRATURE_X4:
+		if (!priv->has_encoder)
+			return -EOPNOTSUPP;
 		sms = TIM_SMCR_SMS_ENCODER_MODE_3;
 		break;
 	default:
@@ -216,11 +235,108 @@ static int stm32_count_enable_write(struct counter_device *counter,
 	return 0;
 }
 
+static int stm32_count_prescaler_read(struct counter_device *counter,
+				      struct counter_count *count, u64 *prescaler)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	u32 psc;
+
+	regmap_read(priv->regmap, TIM_PSC, &psc);
+
+	*prescaler = psc + 1;
+
+	return 0;
+}
+
+static int stm32_count_prescaler_write(struct counter_device *counter,
+				       struct counter_count *count, u64 prescaler)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	u32 psc;
+
+	if (!prescaler || prescaler > MAX_TIM_PSC + 1)
+		return -ERANGE;
+
+	psc = prescaler - 1;
+
+	return regmap_write(priv->regmap, TIM_PSC, psc);
+}
+
+static int stm32_count_cap_read(struct counter_device *counter,
+				struct counter_count *count,
+				size_t ch, u64 *cap)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	u32 ccrx;
+
+	if (ch >= priv->nchannels)
+		return -EOPNOTSUPP;
+
+	switch (ch) {
+	case 0:
+		regmap_read(priv->regmap, TIM_CCR1, &ccrx);
+		break;
+	case 1:
+		regmap_read(priv->regmap, TIM_CCR2, &ccrx);
+		break;
+	case 2:
+		regmap_read(priv->regmap, TIM_CCR3, &ccrx);
+		break;
+	case 3:
+		regmap_read(priv->regmap, TIM_CCR4, &ccrx);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(counter->parent, "CCR%zu: 0x%08x\n", ch + 1, ccrx);
+
+	*cap = ccrx;
+
+	return 0;
+}
+
+static int stm32_count_nb_ovf_read(struct counter_device *counter,
+				   struct counter_count *count, u64 *val)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&priv->lock, irqflags);
+	*val = priv->nb_ovf;
+	spin_unlock_irqrestore(&priv->lock, irqflags);
+
+	return 0;
+}
+
+static int stm32_count_nb_ovf_write(struct counter_device *counter,
+				    struct counter_count *count, u64 val)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&priv->lock, irqflags);
+	priv->nb_ovf = val;
+	spin_unlock_irqrestore(&priv->lock, irqflags);
+
+	return 0;
+}
+
+static DEFINE_COUNTER_ARRAY_CAPTURE(stm32_count_cap_array, 4);
+
 static struct counter_comp stm32_count_ext[] = {
 	COUNTER_COMP_DIRECTION(stm32_count_direction_read),
 	COUNTER_COMP_ENABLE(stm32_count_enable_read, stm32_count_enable_write),
 	COUNTER_COMP_CEILING(stm32_count_ceiling_read,
 			     stm32_count_ceiling_write),
+	COUNTER_COMP_COUNT_U64("prescaler", stm32_count_prescaler_read,
+			       stm32_count_prescaler_write),
+	COUNTER_COMP_ARRAY_CAPTURE(stm32_count_cap_read, NULL, stm32_count_cap_array),
+	COUNTER_COMP_COUNT_U64("num_overflows", stm32_count_nb_ovf_read, stm32_count_nb_ovf_write),
+};
+
+static const enum counter_synapse_action stm32_clock_synapse_actions[] = {
+	COUNTER_SYNAPSE_ACTION_RISING_EDGE,
 };
 
 static const enum counter_synapse_action stm32_synapse_actions[] = {
@@ -243,25 +359,152 @@ static int stm32_action_read(struct counter_device *counter,
 	switch (function) {
 	case COUNTER_FUNCTION_INCREASE:
 		/* counts on internal clock when CEN=1 */
-		*action = COUNTER_SYNAPSE_ACTION_NONE;
+		if (synapse->signal->id == STM32_CLOCK_SIG)
+			*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;
+		else
+			*action = COUNTER_SYNAPSE_ACTION_NONE;
 		return 0;
 	case COUNTER_FUNCTION_QUADRATURE_X2_A:
 		/* counts up/down on TI1FP1 edge depending on TI2FP2 level */
-		if (synapse->signal->id == count->synapses[0].signal->id)
+		if (synapse->signal->id == STM32_CH1_SIG)
 			*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;
 		else
 			*action = COUNTER_SYNAPSE_ACTION_NONE;
 		return 0;
 	case COUNTER_FUNCTION_QUADRATURE_X2_B:
 		/* counts up/down on TI2FP2 edge depending on TI1FP1 level */
-		if (synapse->signal->id == count->synapses[1].signal->id)
+		if (synapse->signal->id == STM32_CH2_SIG)
 			*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;
 		else
 			*action = COUNTER_SYNAPSE_ACTION_NONE;
 		return 0;
 	case COUNTER_FUNCTION_QUADRATURE_X4:
 		/* counts up/down on both TI1FP1 and TI2FP2 edges */
-		*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;
+		if (synapse->signal->id == STM32_CH1_SIG || synapse->signal->id == STM32_CH2_SIG)
+			*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;
+		else
+			*action = COUNTER_SYNAPSE_ACTION_NONE;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+struct stm32_count_cc_regs {
+	u32 ccmr_reg;
+	u32 ccmr_mask;
+	u32 ccmr_bits;
+	u32 ccer_bits;
+};
+
+static const struct stm32_count_cc_regs stm32_cc[] = {
+	{ TIM_CCMR1, TIM_CCMR_CC1S, TIM_CCMR_CC1S_TI1,
+		TIM_CCER_CC1E | TIM_CCER_CC1P | TIM_CCER_CC1NP },
+	{ TIM_CCMR1, TIM_CCMR_CC2S, TIM_CCMR_CC2S_TI2,
+		TIM_CCER_CC2E | TIM_CCER_CC2P | TIM_CCER_CC2NP },
+	{ TIM_CCMR2, TIM_CCMR_CC3S, TIM_CCMR_CC3S_TI3,
+		TIM_CCER_CC3E | TIM_CCER_CC3P | TIM_CCER_CC3NP },
+	{ TIM_CCMR2, TIM_CCMR_CC4S, TIM_CCMR_CC4S_TI4,
+		TIM_CCER_CC4E | TIM_CCER_CC4P | TIM_CCER_CC4NP },
+};
+
+static int stm32_count_capture_configure(struct counter_device *counter, unsigned int ch,
+					 bool enable)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	const struct stm32_count_cc_regs *cc;
+	u32 ccmr, ccer;
+
+	if (ch >= ARRAY_SIZE(stm32_cc) || ch >= priv->nchannels) {
+		dev_err(counter->parent, "invalid ch: %d\n", ch);
+		return -EINVAL;
+	}
+
+	cc = &stm32_cc[ch];
+
+	/*
+	 * configure channel in input capture mode, map channel 1 on TI1, channel2 on TI2...
+	 * Select both edges / non-inverted to trigger a capture.
+	 */
+	if (enable) {
+		/* first clear possibly latched capture flag upon enabling */
+		if (!regmap_test_bits(priv->regmap, TIM_CCER, cc->ccer_bits))
+			regmap_write(priv->regmap, TIM_SR, ~TIM_SR_CC_IF(ch));
+		regmap_update_bits(priv->regmap, cc->ccmr_reg, cc->ccmr_mask,
+				   cc->ccmr_bits);
+		regmap_set_bits(priv->regmap, TIM_CCER, cc->ccer_bits);
+	} else {
+		regmap_clear_bits(priv->regmap, TIM_CCER, cc->ccer_bits);
+		regmap_clear_bits(priv->regmap, cc->ccmr_reg, cc->ccmr_mask);
+	}
+
+	regmap_read(priv->regmap, cc->ccmr_reg, &ccmr);
+	regmap_read(priv->regmap, TIM_CCER, &ccer);
+	dev_dbg(counter->parent, "%s(%s) ch%d 0x%08x 0x%08x\n", __func__, enable ? "ena" : "dis",
+		ch, ccmr, ccer);
+
+	return 0;
+}
+
+static int stm32_count_events_configure(struct counter_device *counter)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	struct counter_event_node *event_node;
+	u32 dier = 0;
+	int i, ret;
+
+	list_for_each_entry(event_node, &counter->events_list, l) {
+		switch (event_node->event) {
+		case COUNTER_EVENT_OVERFLOW_UNDERFLOW:
+			/* first clear possibly latched UIF before enabling */
+			if (!regmap_test_bits(priv->regmap, TIM_DIER, TIM_DIER_UIE))
+				regmap_write(priv->regmap, TIM_SR, (u32)~TIM_SR_UIF);
+			dier |= TIM_DIER_UIE;
+			break;
+		case COUNTER_EVENT_CAPTURE:
+			ret = stm32_count_capture_configure(counter, event_node->channel, true);
+			if (ret)
+				return ret;
+			dier |= TIM_DIER_CC_IE(event_node->channel);
+			break;
+		default:
+			/* should never reach this path */
+			return -EINVAL;
+		}
+	}
+
+	/* Enable / disable all events at once, from events_list, so write all DIER bits */
+	regmap_write(priv->regmap, TIM_DIER, dier);
+
+	/* check for disabled capture events */
+	for (i = 0 ; i < priv->nchannels; i++) {
+		if (!(dier & TIM_DIER_CC_IE(i))) {
+			ret = stm32_count_capture_configure(counter, i, false);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_count_watch_validate(struct counter_device *counter,
+				      const struct counter_watch *watch)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+
+	/* Interrupts are optional */
+	if (!priv->nr_irqs)
+		return -EOPNOTSUPP;
+
+	switch (watch->event) {
+	case COUNTER_EVENT_CAPTURE:
+		if (watch->channel >= priv->nchannels) {
+			dev_err(counter->parent, "Invalid channel %d\n", watch->channel);
+			return -EINVAL;
+		}
+		return 0;
+	case COUNTER_EVENT_OVERFLOW_UNDERFLOW:
 		return 0;
 	default:
 		return -EINVAL;
@@ -274,35 +517,89 @@ static const struct counter_ops stm32_timer_cnt_ops = {
 	.function_read = stm32_count_function_read,
 	.function_write = stm32_count_function_write,
 	.action_read = stm32_action_read,
+	.events_configure = stm32_count_events_configure,
+	.watch_validate = stm32_count_watch_validate,
+};
+
+static int stm32_count_clk_get_freq(struct counter_device *counter,
+				    struct counter_signal *signal, u64 *freq)
+{
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+
+	*freq = clk_get_rate(priv->clk);
+
+	return 0;
+}
+
+static struct counter_comp stm32_count_clock_ext[] = {
+	COUNTER_COMP_FREQUENCY(stm32_count_clk_get_freq),
 };
 
 static struct counter_signal stm32_signals[] = {
+	/*
+	 * Need to declare all the signals as a static array, and keep the signals order here,
+	 * even if they're unused or unexisting on some timer instances. It's an abstraction,
+	 * e.g. high level view of the counter features.
+	 *
+	 * Userspace programs may rely on signal0 to be "Channel 1", signal1 to be "Channel 2",
+	 * and so on. When a signal is unexisting, the COUNTER_SYNAPSE_ACTION_NONE can be used,
+	 * to indicate that a signal doesn't affect the counter.
+	 */
 	{
-		.id = 0,
-		.name = "Channel 1 Quadrature A"
+		.id = STM32_CH1_SIG,
+		.name = "Channel 1"
 	},
 	{
-		.id = 1,
-		.name = "Channel 1 Quadrature B"
-	}
+		.id = STM32_CH2_SIG,
+		.name = "Channel 2"
+	},
+	{
+		.id = STM32_CLOCK_SIG,
+		.name = "Clock",
+		.ext = stm32_count_clock_ext,
+		.num_ext = ARRAY_SIZE(stm32_count_clock_ext),
+	},
+	{
+		.id = STM32_CH3_SIG,
+		.name = "Channel 3"
+	},
+	{
+		.id = STM32_CH4_SIG,
+		.name = "Channel 4"
+	},
 };
 
 static struct counter_synapse stm32_count_synapses[] = {
 	{
 		.actions_list = stm32_synapse_actions,
 		.num_actions = ARRAY_SIZE(stm32_synapse_actions),
-		.signal = &stm32_signals[0]
+		.signal = &stm32_signals[STM32_CH1_SIG]
 	},
 	{
 		.actions_list = stm32_synapse_actions,
 		.num_actions = ARRAY_SIZE(stm32_synapse_actions),
-		.signal = &stm32_signals[1]
-	}
+		.signal = &stm32_signals[STM32_CH2_SIG]
+	},
+	{
+		.actions_list = stm32_clock_synapse_actions,
+		.num_actions = ARRAY_SIZE(stm32_clock_synapse_actions),
+		.signal = &stm32_signals[STM32_CLOCK_SIG]
+	},
+	{
+		.actions_list = stm32_synapse_actions,
+		.num_actions = ARRAY_SIZE(stm32_synapse_actions),
+		.signal = &stm32_signals[STM32_CH3_SIG]
+	},
+	{
+		.actions_list = stm32_synapse_actions,
+		.num_actions = ARRAY_SIZE(stm32_synapse_actions),
+		.signal = &stm32_signals[STM32_CH4_SIG]
+	},
 };
 
 static struct counter_count stm32_counts = {
 	.id = 0,
-	.name = "Channel 1 Count",
+	.name = "STM32 Timer Counter",
 	.functions_list = stm32_count_functions,
 	.num_functions = ARRAY_SIZE(stm32_count_functions),
 	.synapses = stm32_count_synapses,
@@ -311,13 +608,113 @@ static struct counter_count stm32_counts = {
 	.num_ext = ARRAY_SIZE(stm32_count_ext)
 };
 
+static irqreturn_t stm32_timer_cnt_isr(int irq, void *ptr)
+{
+	struct counter_device *counter = ptr;
+	struct stm32_timer_cnt *const priv = counter_priv(counter);
+	u32 clr = GENMASK(31, 0); /* SR flags can be cleared by writing 0 (wr 1 has no effect) */
+	u32 sr, dier;
+	int i;
+
+	regmap_read(priv->regmap, TIM_SR, &sr);
+	regmap_read(priv->regmap, TIM_DIER, &dier);
+	/*
+	 * Some status bits in SR don't match with the enable bits in DIER. Only take care of
+	 * the possibly enabled bits in DIER (that matches in between SR and DIER).
+	 */
+	dier &= (TIM_DIER_UIE | TIM_DIER_CC1IE | TIM_DIER_CC2IE | TIM_DIER_CC3IE | TIM_DIER_CC4IE);
+	sr &= dier;
+
+	if (sr & TIM_SR_UIF) {
+		spin_lock(&priv->lock);
+		priv->nb_ovf++;
+		spin_unlock(&priv->lock);
+		counter_push_event(counter, COUNTER_EVENT_OVERFLOW_UNDERFLOW, 0);
+		dev_dbg(counter->parent, "COUNTER_EVENT_OVERFLOW_UNDERFLOW\n");
+		/* SR flags can be cleared by writing 0, only clear relevant flag */
+		clr &= ~TIM_SR_UIF;
+	}
+
+	/* Check capture events */
+	for (i = 0 ; i < priv->nchannels; i++) {
+		if (sr & TIM_SR_CC_IF(i)) {
+			counter_push_event(counter, COUNTER_EVENT_CAPTURE, i);
+			clr &= ~TIM_SR_CC_IF(i);
+			dev_dbg(counter->parent, "COUNTER_EVENT_CAPTURE, %d\n", i);
+		}
+	}
+
+	regmap_write(priv->regmap, TIM_SR, clr);
+
+	return IRQ_HANDLED;
+};
+
+static void stm32_timer_cnt_detect_channels(struct device *dev,
+					    struct stm32_timer_cnt *priv)
+{
+	u32 ccer, ccer_backup;
+
+	regmap_read(priv->regmap, TIM_CCER, &ccer_backup);
+	regmap_set_bits(priv->regmap, TIM_CCER, TIM_CCER_CCXE);
+	regmap_read(priv->regmap, TIM_CCER, &ccer);
+	regmap_write(priv->regmap, TIM_CCER, ccer_backup);
+	priv->nchannels = hweight32(ccer & TIM_CCER_CCXE);
+
+	dev_dbg(dev, "has %d cc channels\n", priv->nchannels);
+}
+
+/* encoder supported on TIM1 TIM2 TIM3 TIM4 TIM5 TIM8 TIM20 */
+#define STM32_TIM_ENCODER_SUPPORTED	(BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(7) | \
+					 BIT(19))
+
+static const char * const stm32_timer_trigger_compat[] = {
+	"st,stm32-timer-trigger",
+	"st,stm32h7-timer-trigger",
+	"st,stm32mp25-timer-trigger",
+};
+
+static int stm32_timer_cnt_probe_encoder(struct device *dev,
+					 struct stm32_timer_cnt *priv)
+{
+	struct device *parent = dev->parent;
+	struct device_node *tnode = NULL, *pnode = parent->of_node;
+	int i, ret;
+	u32 idx;
+
+	/*
+	 * Need to retrieve the trigger node index from DT, to be able
+	 * to determine if the counter supports encoder mode. It also
+	 * enforce backward compatibility, and allow to support other
+	 * counter modes in this driver (when the timer doesn't support
+	 * encoder).
+	 */
+	for (i = 0; i < ARRAY_SIZE(stm32_timer_trigger_compat) && !tnode; i++)
+		tnode = of_get_compatible_child(pnode, stm32_timer_trigger_compat[i]);
+	if (!tnode) {
+		dev_err(dev, "Can't find trigger node\n");
+		return -ENODATA;
+	}
+
+	ret = of_property_read_u32(tnode, "reg", &idx);
+	if (ret) {
+		dev_err(dev, "Can't get index (%d)\n", ret);
+		return ret;
+	}
+
+	priv->has_encoder = !!(STM32_TIM_ENCODER_SUPPORTED & BIT(idx));
+
+	dev_dbg(dev, "encoder support: %s\n", priv->has_encoder ? "yes" : "no");
+
+	return 0;
+}
+
 static int stm32_timer_cnt_probe(struct platform_device *pdev)
 {
 	struct stm32_timers *ddata = dev_get_drvdata(pdev->dev.parent);
 	struct device *dev = &pdev->dev;
 	struct stm32_timer_cnt *priv;
 	struct counter_device *counter;
-	int ret;
+	int i, ret;
 
 	if (IS_ERR_OR_NULL(ddata))
 		return -EINVAL;
@@ -331,6 +728,13 @@ static int stm32_timer_cnt_probe(struct platform_device *pdev)
 	priv->regmap = ddata->regmap;
 	priv->clk = ddata->clk;
 	priv->max_arr = ddata->max_arr;
+	priv->nr_irqs = ddata->nr_irqs;
+
+	ret = stm32_timer_cnt_probe_encoder(dev, priv);
+	if (ret)
+		return ret;
+
+	stm32_timer_cnt_detect_channels(dev, priv);
 
 	counter->name = dev_name(dev);
 	counter->parent = dev;
@@ -340,8 +744,42 @@ static int stm32_timer_cnt_probe(struct platform_device *pdev)
 	counter->signals = stm32_signals;
 	counter->num_signals = ARRAY_SIZE(stm32_signals);
 
+	spin_lock_init(&priv->lock);
+
 	platform_set_drvdata(pdev, priv);
 
+	/* STM32 Timers can have either 1 global, or 4 dedicated interrupts (optional) */
+	if (priv->nr_irqs == 1) {
+		/* All events reported through the global interrupt */
+		ret = devm_request_irq(&pdev->dev, ddata->irq[0], stm32_timer_cnt_isr,
+				       0, dev_name(dev), counter);
+		if (ret) {
+			dev_err(dev, "Failed to request irq %d (err %d)\n",
+				ddata->irq[0], ret);
+			return ret;
+		}
+	} else {
+		for (i = 0; i < priv->nr_irqs; i++) {
+			/*
+			 * Only take care of update IRQ for overflow events, and cc for
+			 * capture events.
+			 */
+			if (i != STM32_TIMERS_IRQ_UP && i != STM32_TIMERS_IRQ_CC)
+				continue;
+
+			ret = devm_request_irq(&pdev->dev, ddata->irq[i], stm32_timer_cnt_isr,
+					       0, dev_name(dev), counter);
+			if (ret) {
+				dev_err(dev, "Failed to request irq %d (err %d)\n",
+					ddata->irq[i], ret);
+				return ret;
+			}
+		}
+	}
+
+	/* Reset input selector to its default input */
+	regmap_write(priv->regmap, TIM_TISEL, 0x0);
+
 	/* Register Counter device */
 	ret = devm_counter_add(dev, counter);
 	if (ret < 0)
@@ -399,6 +837,7 @@ static SIMPLE_DEV_PM_OPS(stm32_timer_cnt_pm_ops, stm32_timer_cnt_suspend,
 
 static const struct of_device_id stm32_timer_cnt_of_match[] = {
 	{ .compatible = "st,stm32-timer-counter", },
+	{ .compatible = "st,stm32mp25-timer-counter", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_timer_cnt_of_match);
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index 82e5de1f6..1f976d831 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -311,6 +311,13 @@ config ARM_STI_CPUFREQ
 	  this config option if you wish to add CPUFreq support for STi based
 	  SoCs.
 
+config ARM_STM32_CPUFREQ
+	tristate "STM32 CPUFreq support"
+	depends on MACH_STM32MP157
+	default y
+	help
+	  This adds the CPUFreq driver support for STM32 MPU SOCs.
+
 config ARM_TEGRA20_CPUFREQ
 	tristate "Tegra20/30 CPUFreq support"
 	depends on ARCH_TEGRA && CPUFREQ_DT
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 49b98c62c..5a483649e 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_ARM_SCMI_CPUFREQ)		+= scmi-cpufreq.o
 obj-$(CONFIG_ARM_SCPI_CPUFREQ)		+= scpi-cpufreq.o
 obj-$(CONFIG_ARM_SPEAR_CPUFREQ)		+= spear-cpufreq.o
 obj-$(CONFIG_ARM_STI_CPUFREQ)		+= sti-cpufreq.o
+obj-$(CONFIG_ARM_STM32_CPUFREQ)		+= stm32-cpufreq.o
 obj-$(CONFIG_ARM_ALLWINNER_SUN50I_CPUFREQ_NVMEM) += sun50i-cpufreq-nvmem.o
 obj-$(CONFIG_ARM_TEGRA20_CPUFREQ)	+= tegra20-cpufreq.o
 obj-$(CONFIG_ARM_TEGRA124_CPUFREQ)	+= tegra124-cpufreq.o
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index 8514bb62d..78eb2e12b 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -157,6 +157,7 @@ static const struct of_device_id blocklist[] __initconst = {
 	{ .compatible = "st,stih407", },
 	{ .compatible = "st,stih410", },
 	{ .compatible = "st,stih418", },
+	{ .compatible = "st,stm32mp157", },
 
 	{ .compatible = "ti,am33xx", },
 	{ .compatible = "ti,am43", },
diff --git a/drivers/cpufreq/stm32-cpufreq.c b/drivers/cpufreq/stm32-cpufreq.c
new file mode 100644
index 000000000..b552e22e6
--- /dev/null
+++ b/drivers/cpufreq/stm32-cpufreq.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Authors: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of_platform.h>
+#include <linux/pm_opp.h>
+
+struct stm32_cpufreq_priv {
+	int token;
+	struct platform_device *cpufreq_dt_pdev;
+};
+
+static int stm32_cpufreq_probe(struct platform_device *pdev)
+{
+	struct stm32_cpufreq_priv *priv;
+	struct device_node *opp_node;
+	struct device *cpu_dev;
+	u8 part_number;
+	u32 supported_hw;
+	int ret;
+
+	cpu_dev = get_cpu_device(0);
+	if (!cpu_dev) {
+		dev_err(&pdev->dev, "failed to get cpu0 device\n");
+		return -ENODEV;
+	}
+	opp_node = dev_pm_opp_of_get_opp_desc_node(cpu_dev);
+	if (!opp_node) {
+		dev_err(&pdev->dev, "OPP-v2 not supported\n");
+		return -ENODEV;
+	}
+
+	/* Get chip info */
+	ret = nvmem_cell_read_u8(cpu_dev, "part_number", &part_number);
+	if (ret) {
+		dev_err_probe(&pdev->dev, ret, "Failed to get chip info: %d\n", ret);
+		return ret;
+	}
+
+	supported_hw = BIT((part_number & 0x80) >> 7);
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->token = dev_pm_opp_set_supported_hw(cpu_dev, &supported_hw, 1);
+	if (priv->token < 0) {
+		ret = priv->token;
+		dev_err_probe(&pdev->dev, ret, "Failed to set supported opp: %d\n", ret);
+		return ret;
+	}
+
+	of_node_put(opp_node);
+	priv->cpufreq_dt_pdev = platform_device_register_simple("cpufreq-dt",
+								-1, NULL, 0);
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static int stm32_cpufreq_remove(struct platform_device *pdev)
+{
+	struct stm32_cpufreq_priv *priv	= platform_get_drvdata(pdev);
+
+	platform_device_unregister(priv->cpufreq_dt_pdev);
+	dev_pm_opp_put_supported_hw(priv->token);
+
+	return 0;
+}
+
+static int stm32_cpufreq_init(void)
+{
+	platform_device_register_simple("stm32-cpufreq", -1, NULL, 0);
+
+	return 0;
+}
+module_init(stm32_cpufreq_init);
+
+static struct platform_driver stm32_cpufreq_platdrv = {
+	.driver = {
+		.name	= "stm32-cpufreq",
+	},
+	.probe		= stm32_cpufreq_probe,
+	.remove		= stm32_cpufreq_remove,
+};
+module_platform_driver(stm32_cpufreq_platdrv);
+
+MODULE_DESCRIPTION("STM32 CPU freq driver");
+MODULE_AUTHOR("Alexandre Torgue <alexandre.torgue@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/cpuidle/Kconfig.arm b/drivers/cpuidle/Kconfig.arm
index f0714a329..73a8f12fe 100644
--- a/drivers/cpuidle/Kconfig.arm
+++ b/drivers/cpuidle/Kconfig.arm
@@ -93,6 +93,14 @@ config ARM_EXYNOS_CPUIDLE
 	help
 	  Select this to enable cpuidle for Exynos processors.
 
+config ARM_STM32_CPUIDLE
+	bool "Cpu Idle Driver for the STM32 processors"
+	depends on MACH_STM32MP157
+	select DT_IDLE_STATES
+	select ARCH_NEEDS_CPU_IDLE_COUPLED if SMP
+	help
+	  Select this to enable cpuidle for STM32 processors.
+
 config ARM_MVEBU_V7_CPUIDLE
 	bool "CPU Idle Driver for mvebu v7 family processors"
 	depends on (ARCH_MVEBU || COMPILE_TEST) && !ARM64
diff --git a/drivers/cpuidle/Makefile b/drivers/cpuidle/Makefile
index d103342b7..169d60fb9 100644
--- a/drivers/cpuidle/Makefile
+++ b/drivers/cpuidle/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_ARM_PSCI_CPUIDLE)		+= cpuidle-psci.o
 obj-$(CONFIG_ARM_PSCI_CPUIDLE_DOMAIN)	+= cpuidle-psci-domain.o
 obj-$(CONFIG_ARM_TEGRA_CPUIDLE)		+= cpuidle-tegra.o
 obj-$(CONFIG_ARM_QCOM_SPM_CPUIDLE)	+= cpuidle-qcom-spm.o
+obj-$(CONFIG_ARM_STM32_CPUIDLE)		+= cpuidle-stm32.o
 
 ###############################################################################
 # MIPS drivers
diff --git a/drivers/cpuidle/cpuidle-stm32.c b/drivers/cpuidle/cpuidle-stm32.c
new file mode 100644
index 000000000..8baf43721
--- /dev/null
+++ b/drivers/cpuidle/cpuidle-stm32.c
@@ -0,0 +1,277 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) STMicroelectronics 2019
+// Author:
+
+#include <linux/arm-smccc.h>
+#include <linux/cpu_pm.h>
+#include <linux/cpuidle.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/tick.h>
+
+#include <asm/cpuidle.h>
+
+#include "dt_idle_states.h"
+
+#define SMC_AUTOSTOP()				\
+{								\
+	struct arm_smccc_res res;				\
+	arm_smccc_smc(0x8200100a, 0, 0, 0,			\
+		      0, 0, 0, 0, &res);			\
+}
+
+struct stm32_pm_domain {
+	struct device *dev;
+	struct generic_pm_domain genpd;
+	int id;
+};
+
+static atomic_t stm_idle_barrier;
+
+static int stm32_enter_idle(struct cpuidle_device *dev,
+			    struct cpuidle_driver *drv, int index)
+{
+	/*
+	 * Call idle CPU PM enter notifier chain so that
+	 * VFP and per CPU interrupt context is saved.
+	 */
+	cpu_pm_enter();
+
+	/*
+	 * be sure that both cpu enter at the same time
+	 * normally not needed is the state is declared as coupled
+	 */
+	cpuidle_coupled_parallel_barrier(dev, &stm_idle_barrier);
+
+	/* Enter broadcast mode for periodic timers */
+	tick_broadcast_enable();
+
+	/* Enter broadcast mode for one-shot timers */
+	tick_broadcast_enter();
+
+	if (dev->cpu == 0)
+		cpu_cluster_pm_enter();
+
+	SMC_AUTOSTOP();
+
+	if (dev->cpu == 0)
+		cpu_cluster_pm_exit();
+
+	tick_broadcast_exit();
+
+	cpuidle_coupled_parallel_barrier(dev, &stm_idle_barrier);
+
+	/*
+	 * Call idle CPU PM exit notifier chain to restore
+	 * VFP and per CPU IRQ context.
+	 */
+	cpu_pm_exit();
+
+	return index;
+}
+
+static const struct of_device_id stm32_idle_state_match[] = {
+	{ .compatible = "arm,idle-state",
+	  .data = stm32_enter_idle },
+	{ },
+};
+
+static struct cpuidle_driver stm32_idle_driver = {
+	.name = "stm32_idle",
+	.states = {
+		ARM_CPUIDLE_WFI_STATE,
+		{
+			.enter		  = stm32_enter_idle,
+			.exit_latency	  = 620,
+			.target_residency = 700,
+			.flags		  = /*CPUIDLE_FLAG_TIMER_STOP | */
+						CPUIDLE_FLAG_COUPLED,
+			.name		  = "CStop",
+			.desc		  = "Clocks off",
+		},
+	},
+	.safe_state_index = 0,
+	.state_count = 2,
+};
+
+static int stm32_pd_cpuidle_off(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct cpuidle_device *cpuidle_dev = per_cpu(cpuidle_devices,
+							     cpu);
+
+		cpuidle_dev->states_usage[1].disable = false;
+	}
+
+	dev_dbg(priv->dev, "%s OFF\n", domain->name);
+
+	return 0;
+}
+
+static int stm32_pd_cpuidle_on(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct cpuidle_device *cpuidle_dev = per_cpu(cpuidle_devices,
+							     cpu);
+
+		cpuidle_dev->states_usage[1].disable = true;
+	}
+
+	dev_dbg(priv->dev, "%s ON\n", domain->name);
+
+	return 0;
+}
+
+static void stm32_cpuidle_domain_remove(struct stm32_pm_domain *domain)
+{
+	int ret;
+
+	ret = pm_genpd_remove(&domain->genpd);
+	if (ret)
+		dev_err(domain->dev, "failed to remove PM domain %s: %d\n",
+			domain->genpd.name, ret);
+}
+
+static int stm32_cpuidle_domain_add(struct stm32_pm_domain *domain,
+				    struct device *dev,
+				    struct device_node *np)
+{
+	int ret;
+
+	domain->dev = dev;
+	domain->genpd.name = np->name;
+	domain->genpd.power_off = stm32_pd_cpuidle_off;
+	domain->genpd.power_on = stm32_pd_cpuidle_on;
+
+	ret = pm_genpd_init(&domain->genpd, NULL, 0);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to initialise PM domain %s: %d\n",
+			np->name, ret);
+		return ret;
+	}
+
+	ret = of_genpd_add_provider_simple(np, &domain->genpd);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to register PM domain %s: %d\n",
+			np->name, ret);
+		stm32_cpuidle_domain_remove(domain);
+		return ret;
+	}
+
+	dev_info(domain->dev, "domain %s registered\n", np->name);
+
+	return 0;
+}
+
+static int stm32_cpuidle_probe(struct platform_device *pdev)
+{
+	struct cpuidle_driver *drv;
+	struct stm32_pm_domain *domain;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct of_phandle_args child, parent;
+	struct device_node *np_child;
+	int cpu, ret;
+
+	drv = devm_kmemdup(dev, &stm32_idle_driver, sizeof(*drv), GFP_KERNEL);
+	if (!drv)
+		return -ENOMEM;
+
+	/* Start at index 1, index 0 standard WFI */
+	ret = dt_init_idle_driver(drv, stm32_idle_state_match, 1);
+	if (ret < 0)
+		return ret;
+
+	/* all the cpus of the system are coupled */
+	ret = cpuidle_register(drv, cpu_possible_mask);
+	if (ret)
+		return ret;
+
+	/* Declare cpuidle domain */
+	domain = devm_kzalloc(dev, sizeof(*domain), GFP_KERNEL);
+	if (!domain)
+		return -ENOMEM;
+
+	ret = stm32_cpuidle_domain_add(domain, dev, np);
+	if (ret) {
+		devm_kfree(dev, domain);
+		return ret;
+	}
+
+	/* disable cpu idle */
+	for_each_possible_cpu(cpu) {
+		struct cpuidle_device *cpuidle_dev = per_cpu(cpuidle_devices,
+							     cpu);
+
+		cpuidle_dev->states_usage[1].disable = true;
+	}
+
+	/*  link main cpuidle domain to consumer domain */
+	for_each_child_of_node(np, np_child) {
+		if (!of_parse_phandle_with_args(np_child, "power-domains",
+						"#power-domain-cells",
+						0, &child)) {
+			struct device_node *np_test = child.np;
+
+			parent.np = np;
+			parent.args_count = 0;
+
+			ret = of_genpd_add_subdomain(&parent, &child);
+			if (ret < 0)
+				dev_err(dev, "failed to add Sub PM domain %d\n",
+					ret);
+
+			dev_dbg(dev, "%s, add sub cpuidle of %s, with child %s\n",
+				__func__, np->name, np_test->name);
+
+			pm_runtime_put(dev);
+		}
+	}
+
+	dev_info(dev, "cpuidle domain probed\n");
+
+	return 0;
+}
+
+int stm32_cpuidle_remove(struct platform_device *pdev)
+{
+	cpuidle_unregister(&stm32_idle_driver);
+	return 0;
+}
+
+static const struct of_device_id stm32_cpuidle_of_match[] = {
+	{
+		.compatible = "stm32,cpuidle",
+	},
+	{ /* sentinel */ },
+};
+
+static struct platform_driver stm32_cpuidle_driver = {
+	.probe = stm32_cpuidle_probe,
+	.remove = stm32_cpuidle_remove,
+	.driver = {
+		   .name = "stm32_cpuidle",
+		   .owner = THIS_MODULE,
+		   .of_match_table = stm32_cpuidle_of_match,
+		   },
+};
+
+module_platform_driver(stm32_cpuidle_driver);
+
+MODULE_AUTHOR("<>");
+MODULE_DESCRIPTION("STM32 cpu idle driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/crypto/stm32/Kconfig b/drivers/crypto/stm32/Kconfig
index 4a4c3284a..f77a923ce 100644
--- a/drivers/crypto/stm32/Kconfig
+++ b/drivers/crypto/stm32/Kconfig
@@ -16,6 +16,8 @@ config CRYPTO_DEV_STM32_HASH
 	select CRYPTO_MD5
 	select CRYPTO_SHA1
 	select CRYPTO_SHA256
+	select CRYPTO_SHA512
+	select CRYPTO_SHA3
 	select CRYPTO_ENGINE
 	help
 	  This enables support for the HASH hw accelerator which can be found
diff --git a/drivers/crypto/stm32/stm32-cryp.c b/drivers/crypto/stm32/stm32-cryp.c
index 59ef54112..5f0cf7769 100644
--- a/drivers/crypto/stm32/stm32-cryp.c
+++ b/drivers/crypto/stm32/stm32-cryp.c
@@ -4,8 +4,12 @@
  * Author: Fabien Dessenne <fabien.dessenne@st.com>
  */
 
+#include <linux/bottom_half.h>
 #include <linux/clk.h>
+#include <linux/debugfs.h>
 #include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
 #include <linux/interrupt.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -37,6 +41,8 @@
 /* Mode mask = bits [15..0] */
 #define FLG_MODE_MASK           GENMASK(15, 0)
 /* Bit [31..16] status  */
+#define FLG_IN_OUT_DMA          BIT(16)
+#define FLG_HEADER_DMA          BIT(17)
 
 /* Registers */
 #define CRYP_CR                 0x00000000
@@ -62,6 +68,21 @@
 #define CRYP_CSGCMCCM0R         0x00000050
 #define CRYP_CSGCM0R            0x00000070
 
+static const struct debugfs_reg32 stm32_cryp_regs[] = {
+	{
+		.name = "cr",
+		.offset = CRYP_CR
+	},
+	{
+		.name = "sr",
+		.offset = CRYP_SR
+	},
+	{
+		.name = "dmacr",
+		.offset = CRYP_DMACR
+	}
+};
+
 /* Registers values */
 #define CR_DEC_NOT_ENC          0x00000004
 #define CR_TDES_ECB             0x00000000
@@ -92,8 +113,12 @@
 #define CR_PH_MASK              0x00030000
 #define CR_NBPBL_SHIFT          20
 
-#define SR_BUSY                 0x00000010
-#define SR_OFNE                 0x00000004
+#define SR_IFNF                 BIT(1)
+#define SR_OFNE                 BIT(2)
+#define SR_BUSY                 BIT(4)
+
+#define DMACR_DIEN              BIT(0)
+#define DMACR_DOEN              BIT(1)
 
 #define IMSCR_IN                BIT(0)
 #define IMSCR_OUT               BIT(1)
@@ -104,7 +129,15 @@
 /* Misc */
 #define AES_BLOCK_32            (AES_BLOCK_SIZE / sizeof(u32))
 #define GCM_CTR_INIT            2
-#define CRYP_AUTOSUSPEND_DELAY	50
+#define CRYP_AUTOSUSPEND_DELAY  50
+
+#define CRYP_DMA_BURST_REG      4
+
+enum stm32_dma_mode {
+	NO_DMA,
+	DMA_PLAIN_SG,
+	DMA_NEED_SG_TRUNC
+};
 
 struct stm32_cryp_caps {
 	bool                    swap_final;
@@ -127,11 +160,13 @@ struct stm32_cryp {
 	struct list_head        list;
 	struct device           *dev;
 	void __iomem            *regs;
+	phys_addr_t             phys_base;
 	struct clk              *clk;
 	unsigned long           flags;
 	u32                     irq_status;
 	const struct stm32_cryp_caps *caps;
 	struct stm32_cryp_ctx   *ctx;
+	struct dentry           *dbgdir;
 
 	struct crypto_engine    *engine;
 
@@ -145,8 +180,20 @@ struct stm32_cryp {
 	size_t                  header_in;
 	size_t                  payload_out;
 
+	/* DMA process fields */
+	struct scatterlist      *in_sg;
+	struct scatterlist      *header_sg;
 	struct scatterlist      *out_sg;
+	size_t                  in_sg_len;
+	size_t                  header_sg_len;
+	size_t                  out_sg_len;
+	struct completion	dma_completion;
 
+	struct dma_chan         *dma_lch_in;
+	struct dma_chan         *dma_lch_out;
+	enum stm32_dma_mode     dma_mode;
+
+	/* IT process fields */
 	struct scatter_walk     in_walk;
 	struct scatter_walk     out_walk;
 
@@ -245,16 +292,29 @@ static inline int stm32_cryp_wait_enable(struct stm32_cryp *cryp)
 			!(status & CR_CRYPEN), 10, 100000);
 }
 
+static inline int stm32_cryp_wait_input(struct stm32_cryp *cryp)
+{
+	u32 status;
+
+	return readl_relaxed_poll_timeout_atomic(cryp->regs + CRYP_SR, status,
+			status & SR_IFNF, 1, 10);
+}
+
 static inline int stm32_cryp_wait_output(struct stm32_cryp *cryp)
 {
 	u32 status;
 
-	return readl_relaxed_poll_timeout(cryp->regs + CRYP_SR, status,
-			status & SR_OFNE, 10, 100000);
+	return readl_relaxed_poll_timeout_atomic(cryp->regs + CRYP_SR, status,
+			status & SR_OFNE, 1, 10);
 }
 
+static void stm32_cryp_irq_read_data(struct stm32_cryp *cryp);
+static void stm32_cryp_irq_write_data(struct stm32_cryp *cryp);
+static void stm32_cryp_irq_write_gcmccm_header(struct stm32_cryp *cryp);
 static int stm32_cryp_read_auth_tag(struct stm32_cryp *cryp);
 static void stm32_cryp_finish_req(struct stm32_cryp *cryp, int err);
+static int stm32_cryp_dma_start(struct stm32_cryp *cryp);
+static int stm32_cryp_it_start(struct stm32_cryp *cryp);
 
 static struct stm32_cryp *stm32_cryp_find_dev(struct stm32_cryp_ctx *ctx)
 {
@@ -642,11 +702,237 @@ static void stm32_cryp_finish_req(struct stm32_cryp *cryp, int err)
 	if (is_gcm(cryp) || is_ccm(cryp))
 		crypto_finalize_aead_request(cryp->engine, cryp->areq, err);
 	else
-		crypto_finalize_skcipher_request(cryp->engine, cryp->req,
-						   err);
+		crypto_finalize_skcipher_request(cryp->engine, cryp->req, err);
+}
+
+static void stm32_cryp_header_dma_callback(void *param)
+{
+	struct stm32_cryp *cryp = (struct stm32_cryp *)param;
+	int ret;
+	u32 reg;
+
+	dma_unmap_sg(cryp->dev, cryp->header_sg, cryp->header_sg_len, DMA_TO_DEVICE);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg & ~(DMACR_DOEN | DMACR_DIEN));
+
+	kfree(cryp->header_sg);
+
+	reg = stm32_cryp_read(cryp, CRYP_CR);
+
+	if (cryp->header_in) {
+		stm32_cryp_write(cryp, CRYP_CR, reg | CR_CRYPEN);
+
+		ret = stm32_cryp_wait_input(cryp);
+		if (ret) {
+			dev_err(cryp->dev, "input header ready timeout after dma\n");
+			stm32_cryp_finish_req(cryp, ret);
+			return;
+		}
+		stm32_cryp_irq_write_gcmccm_header(cryp);
+		WARN_ON(cryp->header_in);
+	}
+
+	if (stm32_cryp_get_input_text_len(cryp)) {
+		/* Phase 3 : payload */
+		reg = stm32_cryp_read(cryp, CRYP_CR);
+		stm32_cryp_write(cryp, CRYP_CR, reg & ~CR_CRYPEN);
+
+		reg &= ~CR_PH_MASK;
+		reg |= CR_PH_PAYLOAD | CR_CRYPEN;
+		stm32_cryp_write(cryp, CRYP_CR, reg);
+
+		if (cryp->flags & FLG_IN_OUT_DMA) {
+			ret = stm32_cryp_dma_start(cryp);
+			if (ret)
+				stm32_cryp_finish_req(cryp, ret);
+		} else {
+			stm32_cryp_it_start(cryp);
+		}
+	} else {
+		/*
+		 * Phase 4 : tag.
+		 * Nothing to read, nothing to write => end request
+		 */
+		stm32_cryp_finish_req(cryp, 0);
+	}
+}
+static void stm32_cryp_dma_callback(void *param)
+{
+	struct stm32_cryp *cryp = (struct stm32_cryp *)param;
+	int ret;
+	u32 reg;
+
+	complete(&cryp->dma_completion); /* completion to indicate no timeout */
+
+	dma_sync_sg_for_device(cryp->dev, cryp->out_sg, cryp->out_sg_len, DMA_FROM_DEVICE);
+
+	if (cryp->in_sg != cryp->out_sg)
+		dma_unmap_sg(cryp->dev, cryp->in_sg, cryp->in_sg_len, DMA_TO_DEVICE);
+
+	dma_unmap_sg(cryp->dev, cryp->out_sg, cryp->out_sg_len, DMA_FROM_DEVICE);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg & ~(DMACR_DOEN | DMACR_DIEN));
+
+	reg = stm32_cryp_read(cryp, CRYP_CR);
+
+	if (is_gcm(cryp) || is_ccm(cryp)) {
+		kfree(cryp->in_sg);
+		kfree(cryp->out_sg);
+	} else {
+		if (cryp->in_sg != cryp->req->src)
+			kfree(cryp->in_sg);
+		if (cryp->out_sg != cryp->req->dst)
+			kfree(cryp->out_sg);
+	}
+
+	if (cryp->payload_in) {
+		stm32_cryp_write(cryp, CRYP_CR, reg | CR_CRYPEN);
+
+		ret = stm32_cryp_wait_input(cryp);
+		if (ret) {
+			dev_err(cryp->dev, "input ready timeout after dma\n");
+			stm32_cryp_finish_req(cryp, ret);
+			return;
+		}
+		stm32_cryp_irq_write_data(cryp);
+
+		ret = stm32_cryp_wait_output(cryp);
+		if (ret) {
+			dev_err(cryp->dev, "output ready timeout after dma\n");
+			stm32_cryp_finish_req(cryp, ret);
+			return;
+		}
+		stm32_cryp_irq_read_data(cryp);
+	}
+
+	stm32_cryp_finish_req(cryp, 0);
+}
+
+static int stm32_cryp_header_dma_start(struct stm32_cryp *cryp)
+{
+	int err;
+	struct dma_async_tx_descriptor *tx_in;
+	u32 reg;
+	size_t align_size;
+
+	err = dma_map_sg(cryp->dev, cryp->header_sg, cryp->header_sg_len, DMA_TO_DEVICE);
+	if (!err) {
+		dev_err(cryp->dev, "dma_map_sg() error\n");
+		return -ENOMEM;
+	}
+
+	dma_sync_sg_for_device(cryp->dev, cryp->header_sg, cryp->header_sg_len, DMA_TO_DEVICE);
+
+	tx_in = dmaengine_prep_slave_sg(cryp->dma_lch_in, cryp->header_sg, cryp->header_sg_len,
+					DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!tx_in) {
+		dev_err(cryp->dev, "IN prep_slave_sg() failed\n");
+		return -EINVAL;
+	}
+
+	tx_in->callback_param = cryp;
+	tx_in->callback = stm32_cryp_header_dma_callback;
+
+	/* Advance scatterwalk to not DMA'ed data */
+	align_size = ALIGN_DOWN(cryp->header_in, cryp->hw_blocksize);
+	scatterwalk_copychunks(NULL, &cryp->in_walk, align_size, 2);
+	cryp->header_in -= align_size;
+
+	err = dma_submit_error(dmaengine_submit(tx_in));
+	if (err < 0) {
+		dev_err(cryp->dev, "DMA in submit failed\n");
+		return err;
+	}
+	dma_async_issue_pending(cryp->dma_lch_in);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg | DMACR_DIEN);
+
+	return 0;
 }
 
-static int stm32_cryp_cpu_start(struct stm32_cryp *cryp)
+static int stm32_cryp_dma_start(struct stm32_cryp *cryp)
+{
+	int err;
+	size_t align_size;
+	struct dma_async_tx_descriptor *tx_in, *tx_out;
+	u32 reg;
+
+	if (cryp->in_sg != cryp->out_sg) {
+		err = dma_map_sg(cryp->dev, cryp->in_sg, cryp->in_sg_len, DMA_TO_DEVICE);
+		if (!err) {
+			dev_err(cryp->dev, "dma_map_sg() error\n");
+			return -ENOMEM;
+		}
+	}
+
+	err = dma_map_sg(cryp->dev, cryp->out_sg, cryp->out_sg_len, DMA_FROM_DEVICE);
+	if (!err) {
+		dev_err(cryp->dev, "dma_map_sg() error\n");
+		return -ENOMEM;
+	}
+
+	dma_sync_sg_for_device(cryp->dev, cryp->in_sg, cryp->in_sg_len, DMA_TO_DEVICE);
+
+	tx_in = dmaengine_prep_slave_sg(cryp->dma_lch_in, cryp->in_sg, cryp->in_sg_len,
+					DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!tx_in) {
+		dev_err(cryp->dev, "IN prep_slave_sg() failed\n");
+		return -EINVAL;
+	}
+
+	/* No callback necessary */
+	tx_in->callback_param = cryp;
+	tx_in->callback = NULL;
+
+	tx_out = dmaengine_prep_slave_sg(cryp->dma_lch_out, cryp->out_sg, cryp->out_sg_len,
+					 DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!tx_out) {
+		dev_err(cryp->dev, "OUT prep_slave_sg() failed\n");
+		return -EINVAL;
+	}
+
+	reinit_completion(&cryp->dma_completion);
+	tx_out->callback = stm32_cryp_dma_callback;
+	tx_out->callback_param = cryp;
+
+	/* Advance scatterwalk to not DMA'ed data */
+	align_size = ALIGN_DOWN(cryp->payload_in, cryp->hw_blocksize);
+	scatterwalk_copychunks(NULL, &cryp->in_walk, align_size, 2);
+	cryp->payload_in -= align_size;
+
+	err = dma_submit_error(dmaengine_submit(tx_in));
+	if (err < 0) {
+		dev_err(cryp->dev, "DMA in submit failed\n");
+		return err;
+	}
+	dma_async_issue_pending(cryp->dma_lch_in);
+
+	/* Advance scatterwalk to not DMA'ed data */
+	scatterwalk_copychunks(NULL, &cryp->out_walk, align_size, 2);
+	cryp->payload_out -= align_size;
+	err = dma_submit_error(dmaengine_submit(tx_out));
+	if (err < 0) {
+		dev_err(cryp->dev, "DMA out submit failed\n");
+		return err;
+	}
+	dma_async_issue_pending(cryp->dma_lch_out);
+
+	reg = stm32_cryp_read(cryp, CRYP_DMACR);
+	stm32_cryp_write(cryp, CRYP_DMACR, reg | DMACR_DOEN | DMACR_DIEN);
+
+	if (!wait_for_completion_timeout(&cryp->dma_completion, msecs_to_jiffies(1000))) {
+		dev_err(cryp->dev, "DMA out timed out\n");
+		dmaengine_terminate_sync(cryp->dma_lch_out);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int stm32_cryp_it_start(struct stm32_cryp *cryp)
 {
 	/* Enable interrupt and let the IRQ handler do everything */
 	stm32_cryp_write(cryp, CRYP_IMSCR, IMSCR_IN | IMSCR_OUT);
@@ -993,13 +1279,254 @@ static int stm32_cryp_tdes_cbc_decrypt(struct skcipher_request *req)
 	return stm32_cryp_crypt(req, FLG_TDES | FLG_CBC);
 }
 
+static enum stm32_dma_mode stm32_cryp_dma_check_sg(struct scatterlist *test_sg, size_t len,
+						   size_t block_size)
+{
+	struct scatterlist *sg;
+	int i;
+
+	if (len <= 16)
+		return NO_DMA; /* Faster */
+
+	for_each_sg(test_sg, sg, sg_nents(test_sg), i) {
+		if (!IS_ALIGNED(sg->length, block_size) && !sg_is_last(sg))
+			return NO_DMA;
+
+		if (sg->offset % sizeof(u32))
+			return NO_DMA;
+
+		if (sg_is_last(sg) && !IS_ALIGNED(sg->length, AES_BLOCK_SIZE))
+			return DMA_NEED_SG_TRUNC;
+	}
+
+	return DMA_PLAIN_SG;
+}
+
+static enum stm32_dma_mode stm32_cryp_dma_check(struct stm32_cryp *cryp, struct scatterlist *in_sg,
+						struct scatterlist *out_sg)
+{
+	enum stm32_dma_mode ret = DMA_PLAIN_SG;
+
+	if (!is_aes(cryp))
+		return NO_DMA;
+
+	if (!cryp->dma_lch_in || !cryp->dma_lch_out)
+		return NO_DMA;
+
+	ret = stm32_cryp_dma_check_sg(in_sg, cryp->payload_in, AES_BLOCK_SIZE);
+	if (ret == NO_DMA)
+		return ret;
+
+	ret = stm32_cryp_dma_check_sg(out_sg, cryp->payload_out, AES_BLOCK_SIZE);
+	if (ret == NO_DMA)
+		return ret;
+
+	/* Check CTR counter overflow */
+	if (is_aes(cryp) && is_ctr(cryp)) {
+		u32 c;
+		__be32 iv3;
+
+		memcpy(&iv3, &cryp->req->iv[3*sizeof(u32)], sizeof(iv3));
+		c = be32_to_cpu(iv3);
+		if ((c + cryp->payload_in) < cryp->payload_in)
+			return NO_DMA;
+	}
+
+	/* Workaround */
+	if (is_aes(cryp) && is_ctr(cryp) && ret == DMA_NEED_SG_TRUNC)
+		return NO_DMA;
+
+	return ret;
+}
+
+static int stm32_cryp_truncate_sg(struct scatterlist **new_sg, size_t *new_sg_len,
+				  struct scatterlist *sg, off_t skip, size_t size)
+{
+	struct scatterlist *cur;
+	size_t alloc_sg_len;
+
+	*new_sg_len = 0;
+
+	if (!sg || !size) {
+		*new_sg = NULL;
+		return 0;
+	}
+
+	alloc_sg_len = sg_nents_for_len(sg, skip + size);
+	if (alloc_sg_len < 0)
+		return alloc_sg_len;
+
+	/* We allocate to much sg entry, but it is easier */
+	*new_sg = kmalloc_array(alloc_sg_len, sizeof(struct scatterlist), GFP_KERNEL);
+	if (!*new_sg)
+		return -ENOMEM;
+
+	sg_init_table(*new_sg, alloc_sg_len);
+
+	cur = *new_sg;
+	while (sg && size) {
+		unsigned int len = sg->length;
+		unsigned int offset = sg->offset;
+
+		if (skip > len) {
+			skip -= len;
+			sg = sg_next(sg);
+			continue;
+		}
+
+		if (skip) {
+			len -= skip;
+			offset += skip;
+			skip = 0;
+		}
+
+		if (size < len)
+			len = size;
+
+		if (len > 0) {
+			(*new_sg_len)++;
+			size -= len;
+			sg_set_page(cur, sg_page(sg), len, offset);
+			if (size == 0)
+				sg_mark_end(cur);
+			cur = sg_next(cur);
+		}
+
+		sg = sg_next(sg);
+	}
+
+	return 0;
+}
+
+static int stm32_cryp_cipher_prepare(struct stm32_cryp *cryp, struct scatterlist *in_sg,
+				     struct scatterlist *out_sg)
+{
+	size_t align_size;
+
+	cryp->dma_mode = stm32_cryp_dma_check(cryp, in_sg, out_sg);
+
+	scatterwalk_start(&cryp->in_walk, in_sg);
+	scatterwalk_start(&cryp->out_walk, out_sg);
+
+	if (cryp->dma_mode == NO_DMA) {
+		cryp->flags &= ~FLG_IN_OUT_DMA;
+
+		if (is_ctr(cryp))
+			memset(cryp->last_ctr, 0, sizeof(cryp->last_ctr));
+
+	} else if (cryp->dma_mode == DMA_NEED_SG_TRUNC) {
+		int ret;
+
+		cryp->flags |= FLG_IN_OUT_DMA;
+
+		align_size = ALIGN_DOWN(cryp->payload_in, cryp->hw_blocksize);
+		ret = stm32_cryp_truncate_sg(&cryp->in_sg, &cryp->in_sg_len, in_sg, 0, align_size);
+		if (ret)
+			return ret;
+
+		ret = stm32_cryp_truncate_sg(&cryp->out_sg, &cryp->out_sg_len, out_sg, 0,
+					     align_size);
+		if (ret) {
+			kfree(cryp->in_sg);
+			return ret;
+		}
+	} else {
+		cryp->flags |= FLG_IN_OUT_DMA;
+
+		cryp->in_sg = in_sg;
+		cryp->out_sg = out_sg;
+
+		cryp->in_sg_len = sg_nents_for_len(cryp->in_sg, cryp->payload_in);
+		if (cryp->in_sg_len < 0)
+			return cryp->in_sg_len;
+
+		cryp->out_sg_len = sg_nents_for_len(out_sg, cryp->payload_out);
+		if (cryp->out_sg_len < 0)
+			return cryp->out_sg_len;
+	}
+
+	return 0;
+}
+
+static int stm32_cryp_aead_prepare(struct stm32_cryp *cryp, struct scatterlist *in_sg,
+				   struct scatterlist *out_sg)
+{
+	size_t align_size;
+	off_t skip;
+	int ret, ret2;
+
+	cryp->header_sg = NULL;
+	cryp->in_sg = NULL;
+	cryp->out_sg = NULL;
+
+	if (!cryp->dma_lch_in || !cryp->dma_lch_out) {
+		cryp->dma_mode = NO_DMA;
+		cryp->flags &= ~(FLG_IN_OUT_DMA | FLG_HEADER_DMA);
+
+		return 0;
+	}
+
+	/* CCM hw_init may have advanced in header */
+	skip = cryp->areq->assoclen - cryp->header_in;
+
+	align_size = ALIGN_DOWN(cryp->header_in, cryp->hw_blocksize);
+	ret = stm32_cryp_truncate_sg(&cryp->header_sg, &cryp->header_sg_len, in_sg, skip,
+				     align_size);
+	if (ret)
+		return ret;
+
+	ret = stm32_cryp_dma_check_sg(cryp->header_sg, align_size, AES_BLOCK_SIZE);
+	if (ret == NO_DMA) {
+		/* We cannot DMA the header */
+		kfree(cryp->header_sg);
+		cryp->header_sg = NULL;
+
+		cryp->flags &= ~FLG_HEADER_DMA;
+	} else {
+		cryp->flags |= FLG_HEADER_DMA;
+	}
+
+	/* Now skip all header to be at payload start */
+	skip = cryp->areq->assoclen;
+	align_size = ALIGN_DOWN(cryp->payload_in, cryp->hw_blocksize);
+	ret = stm32_cryp_truncate_sg(&cryp->in_sg, &cryp->in_sg_len, in_sg, skip, align_size);
+	if (ret) {
+		kfree(cryp->header_sg);
+		return ret;
+	}
+
+	/* For out buffer align_size is same as in buffer */
+	ret = stm32_cryp_truncate_sg(&cryp->out_sg, &cryp->out_sg_len, out_sg, skip, align_size);
+	if (ret) {
+		kfree(cryp->header_sg);
+		kfree(cryp->in_sg);
+		return ret;
+	}
+
+	ret = stm32_cryp_dma_check_sg(cryp->in_sg, align_size, AES_BLOCK_SIZE);
+	ret2 = stm32_cryp_dma_check_sg(cryp->out_sg, align_size, AES_BLOCK_SIZE);
+	if (ret == NO_DMA || ret2 == NO_DMA) {
+		kfree(cryp->in_sg);
+		cryp->in_sg = NULL;
+
+		kfree(cryp->out_sg);
+		cryp->out_sg = NULL;
+
+		cryp->flags &= ~FLG_IN_OUT_DMA;
+	} else {
+		cryp->flags |= FLG_IN_OUT_DMA;
+	}
+
+	return 0;
+}
+
 static int stm32_cryp_prepare_req(struct skcipher_request *req,
 				  struct aead_request *areq)
 {
 	struct stm32_cryp_ctx *ctx;
 	struct stm32_cryp *cryp;
 	struct stm32_cryp_reqctx *rctx;
-	struct scatterlist *in_sg;
+	struct scatterlist *in_sg, *out_sg;
 	int ret;
 
 	if (!req && !areq)
@@ -1016,8 +1543,6 @@ static int stm32_cryp_prepare_req(struct skcipher_request *req,
 	rctx = req ? skcipher_request_ctx(req) : aead_request_ctx(areq);
 	rctx->mode &= FLG_MODE_MASK;
 
-	ctx->cryp = cryp;
-
 	cryp->flags = (cryp->flags & ~FLG_MODE_MASK) | rctx->mode;
 	cryp->hw_blocksize = is_aes(cryp) ? AES_BLOCK_SIZE : DES_BLOCK_SIZE;
 	cryp->ctx = ctx;
@@ -1029,6 +1554,15 @@ static int stm32_cryp_prepare_req(struct skcipher_request *req,
 		cryp->payload_in = req->cryptlen;
 		cryp->payload_out = req->cryptlen;
 		cryp->authsize = 0;
+
+		in_sg = req->src;
+		out_sg = req->dst;
+
+		ret = stm32_cryp_cipher_prepare(cryp, in_sg, out_sg);
+		if (ret)
+			return ret;
+
+		ret = stm32_cryp_hw_init(cryp);
 	} else {
 		/*
 		 * Length of input and output data:
@@ -1058,23 +1592,22 @@ static int stm32_cryp_prepare_req(struct skcipher_request *req,
 			cryp->header_in = areq->assoclen;
 			cryp->payload_out = cryp->payload_in;
 		}
-	}
-
-	in_sg = req ? req->src : areq->src;
-	scatterwalk_start(&cryp->in_walk, in_sg);
 
-	cryp->out_sg = req ? req->dst : areq->dst;
-	scatterwalk_start(&cryp->out_walk, cryp->out_sg);
+		in_sg = areq->src;
+		out_sg = areq->dst;
 
-	if (is_gcm(cryp) || is_ccm(cryp)) {
+		scatterwalk_start(&cryp->in_walk, in_sg);
+		scatterwalk_start(&cryp->out_walk, out_sg);
 		/* In output, jump after assoc data */
 		scatterwalk_copychunks(NULL, &cryp->out_walk, cryp->areq->assoclen, 2);
-	}
 
-	if (is_ctr(cryp))
-		memset(cryp->last_ctr, 0, sizeof(cryp->last_ctr));
+		ret = stm32_cryp_hw_init(cryp);
+		if (ret)
+			return ret;
+
+		ret = stm32_cryp_aead_prepare(cryp, in_sg, out_sg);
+	}
 
-	ret = stm32_cryp_hw_init(cryp);
 	return ret;
 }
 
@@ -1096,11 +1629,31 @@ static int stm32_cryp_cipher_one_req(struct crypto_engine *engine, void *areq)
 	struct stm32_cryp_ctx *ctx = crypto_skcipher_ctx(
 			crypto_skcipher_reqtfm(req));
 	struct stm32_cryp *cryp = ctx->cryp;
+	int err;
 
 	if (!cryp)
 		return -ENODEV;
 
-	return stm32_cryp_cpu_start(cryp);
+	/* Avoid to use DMA if peripheral 32 bit counter is about to overflow with ctr(aes) */
+	if (is_aes(cryp) && is_ctr(cryp)) {
+		u32 iv_overflow[4];
+
+		memcpy(iv_overflow, req->iv, sizeof(__be32) * 4);
+		iv_overflow[3] = 0xffffffff - be32_to_cpu((__be32)iv_overflow[3]);
+
+		if (req->src->length > iv_overflow[3])
+			cryp->flags &= ~FLG_IN_OUT_DMA;
+	}
+
+	if (cryp->flags & FLG_IN_OUT_DMA)
+		err = stm32_cryp_dma_start(cryp);
+	else
+		err = stm32_cryp_it_start(cryp);
+
+	if (err == -ETIMEDOUT)
+		stm32_cryp_finish_req(cryp, err);
+
+	return err;
 }
 
 static int stm32_cryp_prepare_aead_req(struct crypto_engine *engine, void *areq)
@@ -1121,13 +1674,20 @@ static int stm32_cryp_aead_one_req(struct crypto_engine *engine, void *areq)
 	if (!cryp)
 		return -ENODEV;
 
-	if (unlikely(!cryp->payload_in && !cryp->header_in)) {
+	if (!stm32_cryp_get_input_text_len(cryp) && !cryp->header_in &&
+	    !(cryp->flags & FLG_HEADER_DMA)) {
 		/* No input data to process: get tag and finish */
 		stm32_cryp_finish_req(cryp, 0);
 		return 0;
 	}
 
-	return stm32_cryp_cpu_start(cryp);
+	if (cryp->flags & FLG_HEADER_DMA)
+		return stm32_cryp_header_dma_start(cryp);
+
+	if (!cryp->header_in && cryp->flags & FLG_IN_OUT_DMA)
+		return stm32_cryp_dma_start(cryp);
+
+	return stm32_cryp_it_start(cryp);
 }
 
 static int stm32_cryp_read_auth_tag(struct stm32_cryp *cryp)
@@ -1538,8 +2098,11 @@ static irqreturn_t stm32_cryp_irq_thread(int irq, void *arg)
 		it_mask &= ~IMSCR_OUT;
 	stm32_cryp_write(cryp, CRYP_IMSCR, it_mask);
 
-	if (!cryp->payload_in && !cryp->header_in && !cryp->payload_out)
+	if (!cryp->payload_in && !cryp->header_in && !cryp->payload_out) {
+		local_bh_disable();
 		stm32_cryp_finish_req(cryp, 0);
+		local_bh_enable();
+	}
 
 	return IRQ_HANDLED;
 }
@@ -1553,12 +2116,71 @@ static irqreturn_t stm32_cryp_irq(int irq, void *arg)
 	return IRQ_WAKE_THREAD;
 }
 
+static int stm32_cryp_dma_init(struct stm32_cryp *cryp)
+{
+	struct dma_slave_config dma_conf;
+	struct dma_chan *chan;
+	int err;
+
+	memset(&dma_conf, 0, sizeof(dma_conf));
+
+	dma_conf.direction = DMA_MEM_TO_DEV;
+	dma_conf.dst_addr = cryp->phys_base + CRYP_DIN;
+	dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dma_conf.dst_maxburst = CRYP_DMA_BURST_REG;
+	dma_conf.device_fc = false;
+
+	chan = dma_request_chan(cryp->dev, "in");
+	if (IS_ERR(chan))
+		return PTR_ERR(chan);
+
+	cryp->dma_lch_in = chan;
+	err = dmaengine_slave_config(cryp->dma_lch_in, &dma_conf);
+	if (err) {
+		dma_release_channel(cryp->dma_lch_in);
+		cryp->dma_lch_in = NULL;
+		dev_err(cryp->dev, "Couldn't configure DMA in slave.\n");
+		return err;
+	}
+
+	memset(&dma_conf, 0, sizeof(dma_conf));
+
+	dma_conf.direction = DMA_DEV_TO_MEM;
+	dma_conf.src_addr = cryp->phys_base + CRYP_DOUT;
+	dma_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dma_conf.src_maxburst = CRYP_DMA_BURST_REG;
+	dma_conf.device_fc = false;
+
+	chan = dma_request_chan(cryp->dev, "out");
+	if (IS_ERR(chan)) {
+		dma_release_channel(cryp->dma_lch_in);
+		cryp->dma_lch_in = NULL;
+		return PTR_ERR(chan);
+	}
+
+	cryp->dma_lch_out = chan;
+
+	err = dmaengine_slave_config(cryp->dma_lch_out, &dma_conf);
+	if (err) {
+		dma_release_channel(cryp->dma_lch_out);
+		cryp->dma_lch_out = NULL;
+		dev_err(cryp->dev, "Couldn't configure DMA out slave.\n");
+		dma_release_channel(cryp->dma_lch_in);
+		cryp->dma_lch_in = NULL;
+		return err;
+	}
+
+	init_completion(&cryp->dma_completion);
+
+	return 0;
+}
+
 static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ecb(aes)",
 	.base.cra_driver_name	= "stm32-ecb-aes",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= AES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1574,8 +2196,8 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "cbc(aes)",
 	.base.cra_driver_name	= "stm32-cbc-aes",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= AES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1592,8 +2214,8 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ctr(aes)",
 	.base.cra_driver_name	= "stm32-ctr-aes",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= 1,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1610,8 +2232,8 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ecb(des)",
 	.base.cra_driver_name	= "stm32-ecb-des",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1627,8 +2249,8 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "cbc(des)",
 	.base.cra_driver_name	= "stm32-cbc-des",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1645,8 +2267,8 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "ecb(des3_ede)",
 	.base.cra_driver_name	= "stm32-ecb-des3",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1662,8 +2284,8 @@ static struct skcipher_alg crypto_algs[] = {
 {
 	.base.cra_name		= "cbc(des3_ede)",
 	.base.cra_driver_name	= "stm32-cbc-des3",
-	.base.cra_priority	= 200,
-	.base.cra_flags		= CRYPTO_ALG_ASYNC,
+	.base.cra_priority	= 1200,
+	.base.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 	.base.cra_blocksize	= DES_BLOCK_SIZE,
 	.base.cra_ctxsize	= sizeof(struct stm32_cryp_ctx),
 	.base.cra_alignmask	= 0,
@@ -1693,7 +2315,7 @@ static struct aead_alg aead_algs[] = {
 		.cra_name		= "gcm(aes)",
 		.cra_driver_name	= "stm32-gcm-aes",
 		.cra_priority		= 200,
-		.cra_flags		= CRYPTO_ALG_ASYNC,
+		.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 		.cra_blocksize		= 1,
 		.cra_ctxsize		= sizeof(struct stm32_cryp_ctx),
 		.cra_alignmask		= 0,
@@ -1713,7 +2335,7 @@ static struct aead_alg aead_algs[] = {
 		.cra_name		= "ccm(aes)",
 		.cra_driver_name	= "stm32-ccm-aes",
 		.cra_priority		= 200,
-		.cra_flags		= CRYPTO_ALG_ASYNC,
+		.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
 		.cra_blocksize		= 1,
 		.cra_ctxsize		= sizeof(struct stm32_cryp_ctx),
 		.cra_alignmask		= 0,
@@ -1739,6 +2361,26 @@ static const struct of_device_id stm32_dt_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, stm32_dt_ids);
 
+static void cryp_debugfs(struct stm32_cryp *cryp)
+{
+	struct debugfs_regset32 *regset;
+
+	cryp->dbgdir = debugfs_create_dir("stm32_cryp", NULL);
+	if (IS_ERR_OR_NULL(cryp->dbgdir))
+		return;
+
+	regset = devm_kzalloc(cryp->dev, sizeof(*regset), GFP_KERNEL);
+	if (!regset)
+		return;
+
+	regset->dev = cryp->dev;
+	regset->regs = stm32_cryp_regs;
+	regset->nregs = ARRAY_SIZE(stm32_cryp_regs);
+	regset->base = cryp->regs;
+
+	debugfs_create_regset32("regset", 0444, cryp->dbgdir, regset);
+}
+
 static int stm32_cryp_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1760,6 +2402,8 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	if (IS_ERR(cryp->regs))
 		return PTR_ERR(cryp->regs);
 
+	cryp->phys_base = platform_get_resource(pdev, IORESOURCE_MEM, 0)->start;
+
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
@@ -1805,6 +2449,17 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, cryp);
 
+	ret = stm32_cryp_dma_init(cryp);
+	switch (ret) {
+	case 0:
+		break;
+	case -ENODEV:
+		dev_dbg(dev, "DMA mode not available\n");
+		break;
+	default:
+		goto err_dma;
+	}
+
 	spin_lock(&cryp_list.lock);
 	list_add(&cryp->list, &cryp_list.dev_list);
 	spin_unlock(&cryp_list.lock);
@@ -1833,6 +2488,7 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_aead_algs;
 
+	cryp_debugfs(cryp);
 	dev_info(dev, "Initialized\n");
 
 	pm_runtime_put_sync(dev);
@@ -1848,6 +2504,12 @@ static int stm32_cryp_probe(struct platform_device *pdev)
 	spin_lock(&cryp_list.lock);
 	list_del(&cryp->list);
 	spin_unlock(&cryp_list.lock);
+
+	if (cryp->dma_lch_in)
+		dma_release_channel(cryp->dma_lch_in);
+	if (cryp->dma_lch_out)
+		dma_release_channel(cryp->dma_lch_out);
+err_dma:
 err_rst:
 	pm_runtime_disable(dev);
 	pm_runtime_put_noidle(dev);
@@ -1869,6 +2531,9 @@ static int stm32_cryp_remove(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	debugfs_remove_recursive(cryp->dbgdir);
+	cryp->dbgdir = NULL;
+
 	crypto_unregister_aeads(aead_algs, ARRAY_SIZE(aead_algs));
 	crypto_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
 
@@ -1878,6 +2543,12 @@ static int stm32_cryp_remove(struct platform_device *pdev)
 	list_del(&cryp->list);
 	spin_unlock(&cryp_list.lock);
 
+	if (cryp->dma_lch_in)
+		dma_release_channel(cryp->dma_lch_in);
+
+	if (cryp->dma_lch_out)
+		dma_release_channel(cryp->dma_lch_out);
+
 	pm_runtime_disable(cryp->dev);
 	pm_runtime_put_noidle(cryp->dev);
 
diff --git a/drivers/crypto/stm32/stm32-hash.c b/drivers/crypto/stm32/stm32-hash.c
index 4df5330af..e6d22a28a 100644
--- a/drivers/crypto/stm32/stm32-hash.c
+++ b/drivers/crypto/stm32/stm32-hash.c
@@ -7,7 +7,6 @@
  */
 
 #include <linux/clk.h>
-#include <linux/crypto.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
@@ -27,11 +26,13 @@
 #include <crypto/scatterwalk.h>
 #include <crypto/sha1.h>
 #include <crypto/sha2.h>
+#include <crypto/sha3.h>
 #include <crypto/internal/hash.h>
 
 #define HASH_CR				0x00
 #define HASH_DIN			0x04
 #define HASH_STR			0x08
+#define HASH_UX500_HREG(x)		(0x0c + ((x) * 0x04))
 #define HASH_IMR			0x20
 #define HASH_SR				0x24
 #define HASH_CSR(x)			(0x0F8 + ((x) * 0x04))
@@ -45,15 +46,11 @@
 #define HASH_CR_DMAE			BIT(3)
 #define HASH_CR_DATATYPE_POS		4
 #define HASH_CR_MODE			BIT(6)
+#define HASH_CR_ALGO_POS		7
 #define HASH_CR_MDMAT			BIT(13)
 #define HASH_CR_DMAA			BIT(14)
 #define HASH_CR_LKEY			BIT(16)
 
-#define HASH_CR_ALGO_SHA1		0x0
-#define HASH_CR_ALGO_MD5		0x80
-#define HASH_CR_ALGO_SHA224		0x40000
-#define HASH_CR_ALGO_SHA256		0x40080
-
 /* Interrupt */
 #define HASH_DINIE			BIT(0)
 #define HASH_DCIE			BIT(1)
@@ -62,9 +59,6 @@
 #define HASH_MASK_CALC_COMPLETION	BIT(0)
 #define HASH_MASK_DATA_INPUT		BIT(1)
 
-/* Context swap register */
-#define HASH_CSR_REGISTER_NUMBER	53
-
 /* Status Flags */
 #define HASH_SR_DATA_INPUT_READY	BIT(0)
 #define HASH_SR_OUTPUT_READY		BIT(1)
@@ -75,28 +69,40 @@
 #define HASH_STR_NBLW_MASK		GENMASK(4, 0)
 #define HASH_STR_DCAL			BIT(8)
 
+/* HWCFGR Register */
+#define HASH_HWCFG_DMA_MASK		GENMASK(3, 0)
+
+/* Context swap register */
+#define HASH_CSR_NB_SHA256_HMAC		54
+#define HASH_CSR_NB_SHA256		38
+#define HASH_CSR_NB_SHA512_HMAC		103
+#define HASH_CSR_NB_SHA512		91
+#define HASH_CSR_NB_SHA3_HMAC		88
+#define HASH_CSR_NB_SHA3		72
+#define HASH_CSR_NB_MAX			HASH_CSR_NB_SHA512_HMAC
+
 #define HASH_FLAGS_INIT			BIT(0)
 #define HASH_FLAGS_OUTPUT_READY		BIT(1)
 #define HASH_FLAGS_CPU			BIT(2)
-#define HASH_FLAGS_DMA_READY		BIT(3)
-#define HASH_FLAGS_DMA_ACTIVE		BIT(4)
-#define HASH_FLAGS_HMAC_INIT		BIT(5)
-#define HASH_FLAGS_HMAC_FINAL		BIT(6)
-#define HASH_FLAGS_HMAC_KEY		BIT(7)
-
+#define HASH_FLAGS_DMA_ACTIVE		BIT(3)
+#define HASH_FLAGS_HMAC_INIT		BIT(4)
+#define HASH_FLAGS_HMAC_FINAL		BIT(5)
+#define HASH_FLAGS_HMAC_KEY		BIT(6)
+#define HASH_FLAGS_SHA3_MODE		BIT(7)
 #define HASH_FLAGS_FINAL		BIT(15)
 #define HASH_FLAGS_FINUP		BIT(16)
-#define HASH_FLAGS_ALGO_MASK		GENMASK(21, 18)
-#define HASH_FLAGS_MD5			BIT(18)
-#define HASH_FLAGS_SHA1			BIT(19)
-#define HASH_FLAGS_SHA224		BIT(20)
-#define HASH_FLAGS_SHA256		BIT(21)
-#define HASH_FLAGS_ERRORS		BIT(22)
+#define HASH_FLAGS_ALGO_MASK		GENMASK(20, 17)
+#define HASH_FLAGS_ALGO_SHIFT		17
+#define HASH_FLAGS_ERRORS		BIT(21)
+#define HASH_FLAGS_EMPTY		BIT(22)
 #define HASH_FLAGS_HMAC			BIT(23)
+#define HASH_FLAGS_SGS_COPIED		BIT(24)
 
 #define HASH_OP_UPDATE			1
 #define HASH_OP_FINAL			2
 
+#define HASH_BURST_LEVEL		4
+
 enum stm32_hash_data_format {
 	HASH_DATA_32_BITS		= 0x0,
 	HASH_DATA_16_BITS		= 0x1,
@@ -104,35 +110,60 @@ enum stm32_hash_data_format {
 	HASH_DATA_1_BIT			= 0x3
 };
 
-#define HASH_BUFLEN			256
-#define HASH_LONG_KEY			64
-#define HASH_MAX_KEY_SIZE		(SHA256_BLOCK_SIZE * 8)
-#define HASH_QUEUE_LENGTH		16
-#define HASH_DMA_THRESHOLD		50
+#define HASH_BUFLEN			(SHA3_224_BLOCK_SIZE + 4)
+#define HASH_MAX_KEY_SIZE		(SHA512_BLOCK_SIZE * 8)
+
+enum stm32_hash_algo {
+	HASH_SHA1			= 0,
+	HASH_MD5			= 1,
+	HASH_SHA224			= 2,
+	HASH_SHA256			= 3,
+	HASH_SHA3_224			= 4,
+	HASH_SHA3_256			= 5,
+	HASH_SHA3_384			= 6,
+	HASH_SHA3_512			= 7,
+	HASH_SHA384			= 12,
+	HASH_SHA512			= 15,
+};
+
+enum ux500_hash_algo {
+	HASH_SHA256_UX500		= 0,
+	HASH_SHA1_UX500			= 1,
+};
 
 #define HASH_AUTOSUSPEND_DELAY		50
 
 struct stm32_hash_ctx {
 	struct crypto_engine_ctx enginectx;
 	struct stm32_hash_dev	*hdev;
+	struct crypto_shash	*xtfm;
 	unsigned long		flags;
 
 	u8			key[HASH_MAX_KEY_SIZE];
 	int			keylen;
 };
 
+struct stm32_hash_state {
+	u32			flags;
+
+	u16			bufcnt;
+	u16			blocklen;
+
+	u8 buffer[HASH_BUFLEN] __aligned(sizeof(u32));
+
+	/* hash state */
+	u32			hw_context[3 + HASH_CSR_NB_MAX];
+};
+
 struct stm32_hash_request_ctx {
 	struct stm32_hash_dev	*hdev;
-	unsigned long		flags;
 	unsigned long		op;
 
-	u8 digest[SHA256_DIGEST_SIZE] __aligned(sizeof(u32));
+	u8 digest[SHA512_DIGEST_SIZE] __aligned(sizeof(u32));
 	size_t			digcnt;
-	size_t			bufcnt;
-	size_t			buflen;
 
-	/* DMA */
 	struct scatterlist	*sg;
+	struct scatterlist	sgl[2]; /* scatterlist used to realize alignment */
 	unsigned int		offset;
 	unsigned int		total;
 	struct scatterlist	sg_key;
@@ -143,10 +174,7 @@ struct stm32_hash_request_ctx {
 
 	u8			data_type;
 
-	u8 buffer[HASH_BUFLEN] __aligned(sizeof(u32));
-
-	/* Export Context */
-	u32			*hw_context;
+	struct stm32_hash_state state;
 };
 
 struct stm32_hash_algs_info {
@@ -155,8 +183,14 @@ struct stm32_hash_algs_info {
 };
 
 struct stm32_hash_pdata {
-	struct stm32_hash_algs_info	*algs_info;
-	size_t				algs_info_size;
+	const int				alg_shift;
+	const struct stm32_hash_algs_info	*algs_info;
+	size_t					algs_info_size;
+	bool					has_sr;
+	bool					has_mdmat;
+	bool					context_secured;
+	bool					broken_emptymsg;
+	bool					ux500;
 };
 
 struct stm32_hash_dev {
@@ -166,13 +200,13 @@ struct stm32_hash_dev {
 	struct reset_control	*rst;
 	void __iomem		*io_base;
 	phys_addr_t		phys_base;
+	u8			xmit_buf[HASH_BUFLEN] __aligned(sizeof(u32));
 	u32			dma_mode;
-	u32			dma_maxburst;
+	bool			polled;
 
 	struct ahash_request	*req;
 	struct crypto_engine	*engine;
 
-	int			err;
 	unsigned long		flags;
 
 	struct dma_chan		*dma_lch;
@@ -204,14 +238,29 @@ static inline void stm32_hash_write(struct stm32_hash_dev *hdev,
 	writel_relaxed(value, hdev->io_base + offset);
 }
 
+/**
+ * stm32_hash_wait_busy - wait until hash processor is available. It return an
+ * error if the hash core is processing a block of data for more than 10 ms.
+ * @hdev: the stm32_hash_dev device.
+ */
 static inline int stm32_hash_wait_busy(struct stm32_hash_dev *hdev)
 {
 	u32 status;
 
+	/* The Ux500 lacks the special status register, we poll the DCAL bit instead */
+	if (!hdev->pdata->has_sr)
+		return readl_relaxed_poll_timeout(hdev->io_base + HASH_STR, status,
+						  !(status & HASH_STR_DCAL), 10, 10000);
+
 	return readl_relaxed_poll_timeout(hdev->io_base + HASH_SR, status,
 				   !(status & HASH_SR_BUSY), 10, 10000);
 }
 
+/**
+ * stm32_hash_set_nblw - set the number of valid bytes in the last word.
+ * @hdev: the stm32_hash_dev device.
+ * @length: the length of the final word.
+ */
 static void stm32_hash_set_nblw(struct stm32_hash_dev *hdev, int length)
 {
 	u32 reg;
@@ -249,58 +298,66 @@ static int stm32_hash_write_key(struct stm32_hash_dev *hdev)
 	return 0;
 }
 
+/**
+ * stm32_hash_write_ctrl - Initialize the hash processor, only if
+ * HASH_FLAGS_INIT is set.
+ * @hdev: the stm32_hash_dev device
+ */
 static void stm32_hash_write_ctrl(struct stm32_hash_dev *hdev)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(hdev->req);
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);
+	struct stm32_hash_state *state = &rctx->state;
+	u32 alg = (state->flags & HASH_FLAGS_ALGO_MASK) >> HASH_FLAGS_ALGO_SHIFT;
 
 	u32 reg = HASH_CR_INIT;
 
 	if (!(hdev->flags & HASH_FLAGS_INIT)) {
-		switch (rctx->flags & HASH_FLAGS_ALGO_MASK) {
-		case HASH_FLAGS_MD5:
-			reg |= HASH_CR_ALGO_MD5;
-			break;
-		case HASH_FLAGS_SHA1:
-			reg |= HASH_CR_ALGO_SHA1;
-			break;
-		case HASH_FLAGS_SHA224:
-			reg |= HASH_CR_ALGO_SHA224;
-			break;
-		case HASH_FLAGS_SHA256:
-			reg |= HASH_CR_ALGO_SHA256;
-			break;
-		default:
-			reg |= HASH_CR_ALGO_MD5;
+		if (hdev->pdata->ux500) {
+			reg |= ((alg & BIT(0)) << HASH_CR_ALGO_POS);
+		} else {
+			if (hdev->pdata->alg_shift == HASH_CR_ALGO_POS)
+				reg |= ((alg & BIT(1)) << 17) |
+				       ((alg & BIT(0)) << HASH_CR_ALGO_POS);
+			else
+				reg |= alg << hdev->pdata->alg_shift;
 		}
 
 		reg |= (rctx->data_type << HASH_CR_DATATYPE_POS);
 
-		if (rctx->flags & HASH_FLAGS_HMAC) {
+		if (state->flags & HASH_FLAGS_HMAC) {
 			hdev->flags |= HASH_FLAGS_HMAC;
 			reg |= HASH_CR_MODE;
-			if (ctx->keylen > HASH_LONG_KEY)
+			if (ctx->keylen > crypto_ahash_blocksize(tfm))
 				reg |= HASH_CR_LKEY;
 		}
 
-		stm32_hash_write(hdev, HASH_IMR, HASH_DCIE);
+		if (!hdev->polled)
+			stm32_hash_write(hdev, HASH_IMR, HASH_DCIE);
 
 		stm32_hash_write(hdev, HASH_CR, reg);
 
 		hdev->flags |= HASH_FLAGS_INIT;
 
+		/*
+		 * After first block + 1 words are fill up,
+		 * we only need to fill 1 block to start partial computation
+		 */
+		rctx->state.blocklen -= sizeof(u32);
+
 		dev_dbg(hdev->dev, "Write Control %x\n", reg);
 	}
 }
 
 static void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)
 {
+	struct stm32_hash_state *state = &rctx->state;
 	size_t count;
 
-	while ((rctx->bufcnt < rctx->buflen) && rctx->total) {
+	while ((state->bufcnt < state->blocklen) && rctx->total) {
 		count = min(rctx->sg->length - rctx->offset, rctx->total);
-		count = min(count, rctx->buflen - rctx->bufcnt);
+		count = min_t(size_t, count, state->blocklen - state->bufcnt);
 
 		if (count <= 0) {
 			if ((rctx->sg->length == 0) && !sg_is_last(rctx->sg)) {
@@ -311,10 +368,10 @@ static void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)
 			}
 		}
 
-		scatterwalk_map_and_copy(rctx->buffer + rctx->bufcnt, rctx->sg,
-					 rctx->offset, count, 0);
+		scatterwalk_map_and_copy(state->buffer + state->bufcnt,
+					 rctx->sg, rctx->offset, count, 0);
 
-		rctx->bufcnt += count;
+		state->bufcnt += count;
 		rctx->offset += count;
 		rctx->total -= count;
 
@@ -331,13 +388,23 @@ static void stm32_hash_append_sg(struct stm32_hash_request_ctx *rctx)
 static int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,
 			       const u8 *buf, size_t length, int final)
 {
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	struct stm32_hash_state *state = &rctx->state;
 	unsigned int count, len32;
 	const u32 *buffer = (const u32 *)buf;
 	u32 reg;
 
-	if (final)
+	if (final) {
 		hdev->flags |= HASH_FLAGS_FINAL;
 
+		/* Do not process empty messages if hw is buggy. */
+		if (!(hdev->flags & HASH_FLAGS_INIT) && !length &&
+		    hdev->pdata->broken_emptymsg) {
+			state->flags |= HASH_FLAGS_EMPTY;
+			return 0;
+		}
+	}
+
 	len32 = DIV_ROUND_UP(length, sizeof(u32));
 
 	dev_dbg(hdev->dev, "%s: length: %zd, final: %x len32 %i\n",
@@ -362,6 +429,9 @@ static int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,
 		stm32_hash_write(hdev, HASH_DIN, buffer[count]);
 
 	if (final) {
+		if (stm32_hash_wait_busy(hdev))
+			return -ETIMEDOUT;
+
 		stm32_hash_set_nblw(hdev, length);
 		reg = stm32_hash_read(hdev, HASH_STR);
 		reg |= HASH_STR_DCAL;
@@ -377,43 +447,90 @@ static int stm32_hash_xmit_cpu(struct stm32_hash_dev *hdev,
 	return 0;
 }
 
+static int hash_swap_reg(struct stm32_hash_request_ctx *rctx)
+{
+	struct stm32_hash_state *state = &rctx->state;
+
+	switch ((state->flags & HASH_FLAGS_ALGO_MASK) >>
+		HASH_FLAGS_ALGO_SHIFT) {
+	case HASH_MD5:
+	case HASH_SHA1:
+	case HASH_SHA224:
+	case HASH_SHA256:
+		if (state->flags & HASH_FLAGS_HMAC)
+			return HASH_CSR_NB_SHA256_HMAC;
+		else
+			return HASH_CSR_NB_SHA256;
+		break;
+
+	case HASH_SHA384:
+	case HASH_SHA512:
+		if (state->flags & HASH_FLAGS_HMAC)
+			return HASH_CSR_NB_SHA512_HMAC;
+		else
+			return HASH_CSR_NB_SHA512;
+		break;
+
+	case HASH_SHA3_224:
+	case HASH_SHA3_256:
+	case HASH_SHA3_384:
+	case HASH_SHA3_512:
+		if (state->flags & HASH_FLAGS_HMAC)
+			return HASH_CSR_NB_SHA3_HMAC;
+		else
+			return HASH_CSR_NB_SHA3;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+}
+
 static int stm32_hash_update_cpu(struct stm32_hash_dev *hdev)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	struct stm32_hash_state *state = &rctx->state;
 	int bufcnt, err = 0, final;
 
-	dev_dbg(hdev->dev, "%s flags %lx\n", __func__, rctx->flags);
+	dev_dbg(hdev->dev, "%s flags %x\n", __func__, state->flags);
 
-	final = (rctx->flags & HASH_FLAGS_FINUP);
+	final = state->flags & HASH_FLAGS_FINAL;
 
-	while ((rctx->total >= rctx->buflen) ||
-	       (rctx->bufcnt + rctx->total >= rctx->buflen)) {
+	while ((rctx->total >= state->blocklen) ||
+	       (state->bufcnt + rctx->total >= state->blocklen)) {
 		stm32_hash_append_sg(rctx);
-		bufcnt = rctx->bufcnt;
-		rctx->bufcnt = 0;
-		err = stm32_hash_xmit_cpu(hdev, rctx->buffer, bufcnt, 0);
+		bufcnt = state->bufcnt;
+		state->bufcnt = 0;
+		err = stm32_hash_xmit_cpu(hdev, state->buffer, bufcnt, 0);
+		if (err)
+			return err;
 	}
 
 	stm32_hash_append_sg(rctx);
 
 	if (final) {
-		bufcnt = rctx->bufcnt;
-		rctx->bufcnt = 0;
-		err = stm32_hash_xmit_cpu(hdev, rctx->buffer, bufcnt,
-					  (rctx->flags & HASH_FLAGS_FINUP));
+		bufcnt = state->bufcnt;
+		state->bufcnt = 0;
+		return stm32_hash_xmit_cpu(hdev, state->buffer, bufcnt, 1);
 	}
 
 	return err;
 }
 
 static int stm32_hash_xmit_dma(struct stm32_hash_dev *hdev,
-			       struct scatterlist *sg, int length, int mdma)
+			       struct scatterlist *sg, int length, int mdmat)
 {
 	struct dma_async_tx_descriptor *in_desc;
 	dma_cookie_t cookie;
 	u32 reg;
 	int err;
 
+	dev_dbg(hdev->dev, "%s mdmat: %x length: %d\n", __func__, mdmat, length);
+
+	/* do not use dma if there is no data to send */
+	if (length <= 0)
+		return 0;
+
 	in_desc = dmaengine_prep_slave_sg(hdev->dma_lch, sg, 1,
 					  DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT |
 					  DMA_CTRL_ACK);
@@ -426,21 +543,20 @@ static int stm32_hash_xmit_dma(struct stm32_hash_dev *hdev,
 	in_desc->callback = stm32_hash_dma_callback;
 	in_desc->callback_param = hdev;
 
-	hdev->flags |= HASH_FLAGS_FINAL;
 	hdev->flags |= HASH_FLAGS_DMA_ACTIVE;
 
 	reg = stm32_hash_read(hdev, HASH_CR);
 
-	if (mdma)
-		reg |= HASH_CR_MDMAT;
-	else
-		reg &= ~HASH_CR_MDMAT;
-
+	if (hdev->pdata->has_mdmat) {
+		if (mdmat)
+			reg |= HASH_CR_MDMAT;
+		else
+			reg &= ~HASH_CR_MDMAT;
+	}
 	reg |= HASH_CR_DMAE;
 
 	stm32_hash_write(hdev, HASH_CR, reg);
 
-	stm32_hash_set_nblw(hdev, length);
 
 	cookie = dmaengine_submit(in_desc);
 	err = dma_submit_error(cookie);
@@ -471,8 +587,6 @@ static void stm32_hash_dma_callback(void *param)
 	struct stm32_hash_dev *hdev = param;
 
 	complete(&hdev->dma_completion);
-
-	hdev->flags |= HASH_FLAGS_DMA_READY;
 }
 
 static int stm32_hash_hmac_dma_send(struct stm32_hash_dev *hdev)
@@ -482,7 +596,7 @@ static int stm32_hash_hmac_dma_send(struct stm32_hash_dev *hdev)
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);
 	int err;
 
-	if (ctx->keylen < HASH_DMA_THRESHOLD || (hdev->dma_mode == 1)) {
+	if (ctx->keylen < rctx->state.blocklen || hdev->dma_mode > 0) {
 		err = stm32_hash_write_key(hdev);
 		if (stm32_hash_wait_busy(hdev))
 			return -ETIMEDOUT;
@@ -517,8 +631,8 @@ static int stm32_hash_dma_init(struct stm32_hash_dev *hdev)
 	dma_conf.direction = DMA_MEM_TO_DEV;
 	dma_conf.dst_addr = hdev->phys_base + HASH_DIN;
 	dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	dma_conf.src_maxburst = hdev->dma_maxburst;
-	dma_conf.dst_maxburst = hdev->dma_maxburst;
+	dma_conf.src_maxburst = HASH_BURST_LEVEL;
+	dma_conf.dst_maxburst = HASH_BURST_LEVEL;
 	dma_conf.device_fc = false;
 
 	chan = dma_request_chan(hdev->dev, "in");
@@ -543,22 +657,24 @@ static int stm32_hash_dma_init(struct stm32_hash_dev *hdev)
 static int stm32_hash_dma_send(struct stm32_hash_dev *hdev)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	u32 *buffer = (void *)rctx->state.buffer;
 	struct scatterlist sg[1], *tsg;
-	int err = 0, len = 0, reg, ncp = 0;
-	unsigned int i;
-	u32 *buffer = (void *)rctx->buffer;
+	int err = 0, reg, ncp = 0;
+	unsigned int i, len = 0, bufcnt = 0;
+	bool final = hdev->flags & HASH_FLAGS_FINAL;
+	bool is_last = false;
+	u32 last_word;
 
-	rctx->sg = hdev->req->src;
-	rctx->total = hdev->req->nbytes;
-
-	rctx->nents = sg_nents(rctx->sg);
+	dev_dbg(hdev->dev, "%s total: %d bufcnt: %d final: %d\n",
+		__func__, rctx->total, rctx->state.bufcnt, final);
 
 	if (rctx->nents < 0)
 		return -EINVAL;
 
 	stm32_hash_write_ctrl(hdev);
 
-	if (hdev->flags & HASH_FLAGS_HMAC) {
+	if (hdev->flags & HASH_FLAGS_HMAC && (!(hdev->flags & HASH_FLAGS_HMAC_KEY))) {
+		hdev->flags |= HASH_FLAGS_HMAC_KEY;
 		err = stm32_hash_hmac_dma_send(hdev);
 		if (err != -EINPROGRESS)
 			return err;
@@ -568,21 +684,37 @@ static int stm32_hash_dma_send(struct stm32_hash_dev *hdev)
 		sg[0] = *tsg;
 		len = sg->length;
 
-		if (sg_is_last(sg)) {
-			if (hdev->dma_mode == 1) {
-				len = (ALIGN(sg->length, 16) - 16);
-
-				ncp = sg_pcopy_to_buffer(
-					rctx->sg, rctx->nents,
-					rctx->buffer, sg->length - len,
-					rctx->total - sg->length + len);
-
-				sg->length = len;
+		if (sg_is_last(sg) || (bufcnt + sg[0].length) >= rctx->total) {
+			if (!final) {
+				/* Always manually put the last word of a non-final transfer. */
+				len -= sizeof(u32);
+				sg_pcopy_to_buffer(rctx->sg, rctx->nents, &last_word, 4, len);
+				sg->length -= sizeof(u32);
 			} else {
-				if (!(IS_ALIGNED(sg->length, sizeof(u32)))) {
-					len = sg->length;
-					sg->length = ALIGN(sg->length,
-							   sizeof(u32));
+				/*
+				 * In Multiple DMA mode, DMA must be aborted before the final
+				 * transfer.
+				 */
+				sg->length = rctx->total - bufcnt;
+				if (hdev->dma_mode > 0) {
+					len = (ALIGN(sg->length, 16) - 16);
+
+					ncp = sg_pcopy_to_buffer(rctx->sg, rctx->nents,
+								 rctx->state.buffer,
+								 sg->length - len,
+								 rctx->total - sg->length + len);
+
+					if (!len)
+						break;
+
+					sg->length = len;
+				} else {
+					is_last = true;
+					if (!(IS_ALIGNED(sg->length, sizeof(u32)))) {
+						len = sg->length;
+						sg->length = ALIGN(sg->length,
+								   sizeof(u32));
+					}
 				}
 			}
 		}
@@ -594,43 +726,69 @@ static int stm32_hash_dma_send(struct stm32_hash_dev *hdev)
 			return -ENOMEM;
 		}
 
-		err = stm32_hash_xmit_dma(hdev, sg, len,
-					  !sg_is_last(sg));
+		err = stm32_hash_xmit_dma(hdev, sg, len, !is_last);
+
+		/* The last word of a non final transfer is sent manually. */
+		if (!final) {
+			stm32_hash_write(hdev, HASH_DIN, last_word);
+			len += sizeof(u32);
+		}
+
+		rctx->total -= len;
 
+		bufcnt += sg[0].length;
 		dma_unmap_sg(hdev->dev, sg, 1, DMA_TO_DEVICE);
 
-		if (err == -ENOMEM)
+		if (err == -ENOMEM || err == -ETIMEDOUT)
 			return err;
+		if (is_last)
+			break;
 	}
 
-	if (hdev->dma_mode == 1) {
-		if (stm32_hash_wait_busy(hdev))
-			return -ETIMEDOUT;
-		reg = stm32_hash_read(hdev, HASH_CR);
-		reg &= ~HASH_CR_DMAE;
-		reg |= HASH_CR_DMAA;
-		stm32_hash_write(hdev, HASH_CR, reg);
+	/*
+	 * When the second last block transfer of 4 words is performed by the DMA,
+	 * the software must set the DMA Abort bit (DMAA) to 1 before completing the
+	 * last transfer of 4 words or less.
+	 */
+	if (final) {
+		if (hdev->dma_mode > 0) {
+			if (stm32_hash_wait_busy(hdev))
+				return -ETIMEDOUT;
+			reg = stm32_hash_read(hdev, HASH_CR);
+			reg &= ~HASH_CR_DMAE;
+			reg |= HASH_CR_DMAA;
+			stm32_hash_write(hdev, HASH_CR, reg);
+
+			if (ncp) {
+				memset(buffer + ncp, 0, 4 - DIV_ROUND_UP(ncp, sizeof(u32)));
+				writesl(hdev->io_base + HASH_DIN, buffer,
+					DIV_ROUND_UP(ncp, sizeof(u32)));
+			}
 
-		if (ncp) {
-			memset(buffer + ncp, 0,
-			       DIV_ROUND_UP(ncp, sizeof(u32)) - ncp);
-			writesl(hdev->io_base + HASH_DIN, buffer,
-				DIV_ROUND_UP(ncp, sizeof(u32)));
+			stm32_hash_set_nblw(hdev, ncp);
+			reg = stm32_hash_read(hdev, HASH_STR);
+			reg |= HASH_STR_DCAL;
+			stm32_hash_write(hdev, HASH_STR, reg);
+			err = -EINPROGRESS;
 		}
-		stm32_hash_set_nblw(hdev, ncp);
-		reg = stm32_hash_read(hdev, HASH_STR);
-		reg |= HASH_STR_DCAL;
-		stm32_hash_write(hdev, HASH_STR, reg);
-		err = -EINPROGRESS;
-	}
 
-	if (hdev->flags & HASH_FLAGS_HMAC) {
-		if (stm32_hash_wait_busy(hdev))
-			return -ETIMEDOUT;
-		err = stm32_hash_hmac_dma_send(hdev);
+		/*
+		 * The hash processor needs the key to be loaded a second time in order
+		 * to process the HMAC.
+		 */
+		if (hdev->flags & HASH_FLAGS_HMAC) {
+			if (stm32_hash_wait_busy(hdev))
+				return -ETIMEDOUT;
+			err = stm32_hash_hmac_dma_send(hdev);
+		}
+
+		return err;
 	}
 
-	return err;
+	if (err != -EINPROGRESS)
+		return err;
+
+	return 0;
 }
 
 static struct stm32_hash_dev *stm32_hash_find_dev(struct stm32_hash_ctx *ctx)
@@ -653,79 +811,97 @@ static struct stm32_hash_dev *stm32_hash_find_dev(struct stm32_hash_ctx *ctx)
 	return hdev;
 }
 
-static bool stm32_hash_dma_aligned_data(struct ahash_request *req)
-{
-	struct scatterlist *sg;
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	int i;
-
-	if (req->nbytes <= HASH_DMA_THRESHOLD)
-		return false;
-
-	if (sg_nents(req->src) > 1) {
-		if (hdev->dma_mode == 1)
-			return false;
-		for_each_sg(req->src, sg, sg_nents(req->src), i) {
-			if ((!IS_ALIGNED(sg->length, sizeof(u32))) &&
-			    (!sg_is_last(sg)))
-				return false;
-		}
-	}
-
-	if (req->src->offset % 4)
-		return false;
-
-	return true;
-}
-
 static int stm32_hash_init(struct ahash_request *req)
 {
 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(tfm);
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
+	struct stm32_hash_state *state = &rctx->state;
+	bool sha3_mode = ctx->flags & HASH_FLAGS_SHA3_MODE;
 
 	rctx->hdev = hdev;
+	state->flags = 0;
 
-	rctx->flags = HASH_FLAGS_CPU;
+	if (!(hdev->dma_lch &&  hdev->pdata->has_mdmat))
+		state->flags |= HASH_FLAGS_CPU;
+
+	if (sha3_mode)
+		state->flags |= HASH_FLAGS_SHA3_MODE;
 
 	rctx->digcnt = crypto_ahash_digestsize(tfm);
 	switch (rctx->digcnt) {
 	case MD5_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_MD5;
+		state->flags |= HASH_MD5 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	case SHA1_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_SHA1;
+		if (hdev->pdata->ux500)
+			state->flags |= HASH_SHA1_UX500 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			state->flags |= HASH_SHA1 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	case SHA224_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_SHA224;
+		if (sha3_mode)
+			state->flags |= HASH_SHA3_224 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			state->flags |= HASH_SHA224 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	case SHA256_DIGEST_SIZE:
-		rctx->flags |= HASH_FLAGS_SHA256;
+		if (sha3_mode) {
+			state->flags |= HASH_SHA3_256 << HASH_FLAGS_ALGO_SHIFT;
+		} else {
+			if (hdev->pdata->ux500)
+				state->flags |= HASH_SHA256_UX500 << HASH_FLAGS_ALGO_SHIFT;
+			else
+				state->flags |= HASH_SHA256 << HASH_FLAGS_ALGO_SHIFT;
+		}
+		break;
+	case SHA384_DIGEST_SIZE:
+		if (sha3_mode)
+			state->flags |= HASH_SHA3_384 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			state->flags |= HASH_SHA384 << HASH_FLAGS_ALGO_SHIFT;
+		break;
+	case SHA512_DIGEST_SIZE:
+		if (sha3_mode)
+			state->flags |= HASH_SHA3_512 << HASH_FLAGS_ALGO_SHIFT;
+		else
+			state->flags |= HASH_SHA512 << HASH_FLAGS_ALGO_SHIFT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	rctx->bufcnt = 0;
-	rctx->buflen = HASH_BUFLEN;
+	rctx->state.bufcnt = 0;
+	rctx->state.blocklen = crypto_ahash_blocksize(tfm) + sizeof(u32);
+	if (rctx->state.blocklen > HASH_BUFLEN) {
+		dev_err(hdev->dev, "Error, block too large");
+		return -EINVAL;
+	}
+	rctx->nents = 0;
 	rctx->total = 0;
 	rctx->offset = 0;
 	rctx->data_type = HASH_DATA_8_BITS;
 
-	memset(rctx->buffer, 0, HASH_BUFLEN);
-
 	if (ctx->flags & HASH_FLAGS_HMAC)
-		rctx->flags |= HASH_FLAGS_HMAC;
+		state->flags |= HASH_FLAGS_HMAC;
 
-	dev_dbg(hdev->dev, "%s Flags %lx\n", __func__, rctx->flags);
+	dev_dbg(hdev->dev, "%s Flags %x\n", __func__, state->flags);
 
 	return 0;
 }
 
 static int stm32_hash_update_req(struct stm32_hash_dev *hdev)
 {
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(hdev->req);
+	struct stm32_hash_state *state = &rctx->state;
+
+	dev_dbg(hdev->dev, "update_req: total: %u, digcnt: %zd, final: 0",
+		rctx->total, rctx->digcnt);
+
+	if (!(state->flags & HASH_FLAGS_CPU))
+		return stm32_hash_dma_send(hdev);
+
 	return stm32_hash_update_cpu(hdev);
 }
 
@@ -733,51 +909,83 @@ static int stm32_hash_final_req(struct stm32_hash_dev *hdev)
 {
 	struct ahash_request *req = hdev->req;
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	int err;
-	int buflen = rctx->bufcnt;
+	struct stm32_hash_state *state = &rctx->state;
+	int buflen = state->bufcnt;
 
-	rctx->bufcnt = 0;
+	if (!(state->flags & HASH_FLAGS_CPU)) {
+		hdev->flags |= HASH_FLAGS_FINAL;
+		return stm32_hash_dma_send(hdev);
+	}
 
-	if (!(rctx->flags & HASH_FLAGS_CPU))
-		err = stm32_hash_dma_send(hdev);
-	else
-		err = stm32_hash_xmit_cpu(hdev, rctx->buffer, buflen, 1);
+	if (state->flags & HASH_FLAGS_FINUP)
+		return stm32_hash_update_req(hdev);
 
+	state->bufcnt = 0;
 
-	return err;
+	return stm32_hash_xmit_cpu(hdev, state->buffer, buflen, 1);
+}
+
+static void stm32_hash_emptymsg_fallback(struct ahash_request *req)
+{
+	struct crypto_ahash *ahash = crypto_ahash_reqtfm(req);
+	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(ahash);
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_dev *hdev = rctx->hdev;
+	int ret;
+
+	dev_dbg(hdev->dev, "use fallback message size 0 key size %d\n",
+		ctx->keylen);
+
+	if (!ctx->xtfm) {
+		dev_err(hdev->dev, "no fallback engine\n");
+		return;
+	}
+
+	if (ctx->keylen) {
+		ret = crypto_shash_setkey(ctx->xtfm, ctx->key, ctx->keylen);
+		if (ret) {
+			dev_err(hdev->dev, "failed to set key ret=%d\n", ret);
+			return;
+		}
+	}
+
+	ret = crypto_shash_tfm_digest(ctx->xtfm, NULL, 0, rctx->digest);
+	if (ret)
+		dev_err(hdev->dev, "shash digest error\n");
 }
 
 static void stm32_hash_copy_hash(struct ahash_request *req)
 {
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
+	struct stm32_hash_dev *hdev = rctx->hdev;
 	__be32 *hash = (void *)rctx->digest;
 	unsigned int i, hashsize;
 
-	switch (rctx->flags & HASH_FLAGS_ALGO_MASK) {
-	case HASH_FLAGS_MD5:
-		hashsize = MD5_DIGEST_SIZE;
-		break;
-	case HASH_FLAGS_SHA1:
-		hashsize = SHA1_DIGEST_SIZE;
-		break;
-	case HASH_FLAGS_SHA224:
-		hashsize = SHA224_DIGEST_SIZE;
-		break;
-	case HASH_FLAGS_SHA256:
-		hashsize = SHA256_DIGEST_SIZE;
-		break;
-	default:
-		return;
-	}
+	if (hdev->pdata->broken_emptymsg && (state->flags & HASH_FLAGS_EMPTY))
+		return stm32_hash_emptymsg_fallback(req);
+
+	hashsize = crypto_ahash_digestsize(tfm);
 
-	for (i = 0; i < hashsize / sizeof(u32); i++)
-		hash[i] = cpu_to_be32(stm32_hash_read(rctx->hdev,
-						      HASH_HREG(i)));
+	for (i = 0; i < hashsize / sizeof(u32); i++) {
+		if (hdev->pdata->ux500)
+			hash[i] = cpu_to_be32(stm32_hash_read(hdev,
+					      HASH_UX500_HREG(i)));
+		else
+			hash[i] = cpu_to_be32(stm32_hash_read(hdev,
+					      HASH_HREG(i)));
+	}
 }
 
 static int stm32_hash_finish(struct ahash_request *req)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	u32 reg;
+
+	reg = stm32_hash_read(rctx->hdev, HASH_SR);
+	reg &= ~HASH_SR_OUTPUT_READY;
+	stm32_hash_write(rctx->hdev, HASH_SR, reg);
 
 	if (!req->result)
 		return -EINVAL;
@@ -790,93 +998,94 @@ static int stm32_hash_finish(struct ahash_request *req)
 static void stm32_hash_finish_req(struct ahash_request *req, int err)
 {
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
 	struct stm32_hash_dev *hdev = rctx->hdev;
 
+	if (hdev->flags & HASH_FLAGS_DMA_ACTIVE)
+		state->flags |= HASH_FLAGS_DMA_ACTIVE;
+	else
+		state->flags &= ~HASH_FLAGS_DMA_ACTIVE;
+
 	if (!err && (HASH_FLAGS_FINAL & hdev->flags)) {
 		stm32_hash_copy_hash(req);
 		err = stm32_hash_finish(req);
-		hdev->flags &= ~(HASH_FLAGS_FINAL | HASH_FLAGS_CPU |
-				 HASH_FLAGS_INIT | HASH_FLAGS_DMA_READY |
-				 HASH_FLAGS_OUTPUT_READY | HASH_FLAGS_HMAC |
-				 HASH_FLAGS_HMAC_INIT | HASH_FLAGS_HMAC_FINAL |
-				 HASH_FLAGS_HMAC_KEY);
-	} else {
-		rctx->flags |= HASH_FLAGS_ERRORS;
 	}
 
-	pm_runtime_mark_last_busy(hdev->dev);
-	pm_runtime_put_autosuspend(hdev->dev);
-
 	crypto_finalize_hash_request(hdev->engine, req, err);
 }
 
-static int stm32_hash_hw_init(struct stm32_hash_dev *hdev,
-			      struct stm32_hash_request_ctx *rctx)
-{
-	pm_runtime_get_sync(hdev->dev);
-
-	if (!(HASH_FLAGS_INIT & hdev->flags)) {
-		stm32_hash_write(hdev, HASH_CR, HASH_CR_INIT);
-		stm32_hash_write(hdev, HASH_STR, 0);
-		stm32_hash_write(hdev, HASH_DIN, 0);
-		stm32_hash_write(hdev, HASH_IMR, 0);
-		hdev->err = 0;
-	}
-
-	return 0;
-}
-
-static int stm32_hash_one_request(struct crypto_engine *engine, void *areq);
-static int stm32_hash_prepare_req(struct crypto_engine *engine, void *areq);
-
 static int stm32_hash_handle_queue(struct stm32_hash_dev *hdev,
 				   struct ahash_request *req)
 {
 	return crypto_transfer_hash_request_to_engine(hdev->engine, req);
 }
 
-static int stm32_hash_prepare_req(struct crypto_engine *engine, void *areq)
+static int stm32_hash_one_request(struct crypto_engine *engine, void *areq)
 {
 	struct ahash_request *req = container_of(areq, struct ahash_request,
 						 base);
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	struct stm32_hash_request_ctx *rctx;
+	struct stm32_hash_state *state = &rctx->state;
+	int swap_reg;
+	int err = 0;
 
 	if (!hdev)
 		return -ENODEV;
 
-	hdev->req = req;
-
-	rctx = ahash_request_ctx(req);
-
 	dev_dbg(hdev->dev, "processing new req, op: %lu, nbytes %d\n",
 		rctx->op, req->nbytes);
 
-	return stm32_hash_hw_init(hdev, rctx);
-}
+	pm_runtime_get_sync(hdev->dev);
 
-static int stm32_hash_one_request(struct crypto_engine *engine, void *areq)
-{
-	struct ahash_request *req = container_of(areq, struct ahash_request,
-						 base);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	struct stm32_hash_request_ctx *rctx;
-	int err = 0;
+	hdev->req = req;
+	hdev->flags = 0;
+	swap_reg = hash_swap_reg(rctx);
+
+	if (state->flags & HASH_FLAGS_INIT) {
+		u32 *preg = rctx->state.hw_context;
+		u32 reg;
+		int i;
+
+		if (!hdev->pdata->ux500)
+			stm32_hash_write(hdev, HASH_IMR, *preg++);
+		stm32_hash_write(hdev, HASH_STR, *preg++);
+		stm32_hash_write(hdev, HASH_CR, *preg);
+		reg = *preg++ | HASH_CR_INIT;
+		stm32_hash_write(hdev, HASH_CR, reg);
 
-	if (!hdev)
-		return -ENODEV;
+		for (i = 0; i < swap_reg; i++)
+			stm32_hash_write(hdev, HASH_CSR(i), *preg++);
 
-	hdev->req = req;
+		hdev->flags |= HASH_FLAGS_INIT;
 
-	rctx = ahash_request_ctx(req);
+		if (state->flags & HASH_FLAGS_HMAC)
+			hdev->flags |= HASH_FLAGS_HMAC |
+				       HASH_FLAGS_HMAC_KEY;
+
+		if (state->flags & HASH_FLAGS_CPU)
+			hdev->flags |= HASH_FLAGS_CPU;
+
+		if (state->flags & HASH_FLAGS_DMA_ACTIVE)
+			hdev->flags |= HASH_FLAGS_DMA_ACTIVE;
+	}
 
 	if (rctx->op == HASH_OP_UPDATE)
 		err = stm32_hash_update_req(hdev);
 	else if (rctx->op == HASH_OP_FINAL)
 		err = stm32_hash_final_req(hdev);
 
+	/* If we have an IRQ, wait for that, else poll for completion */
+	if (err == -EINPROGRESS && hdev->polled) {
+		if (stm32_hash_wait_busy(hdev))
+			err = -ETIMEDOUT;
+		else {
+			hdev->flags |= HASH_FLAGS_OUTPUT_READY;
+			err = 0;
+		}
+	}
+
 	if (err != -EINPROGRESS)
 	/* done task will not finish it, so do it here */
 		stm32_hash_finish_req(req, err);
@@ -884,137 +1093,371 @@ static int stm32_hash_one_request(struct crypto_engine *engine, void *areq)
 	return 0;
 }
 
-static int stm32_hash_enqueue(struct ahash_request *req, unsigned int op)
+static int stm32_hash_copy_sgs(struct stm32_hash_request_ctx *rctx,
+			       struct scatterlist *sg, int bs,
+			       unsigned int new_len)
 {
-	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
-	struct stm32_hash_dev *hdev = ctx->hdev;
+	struct stm32_hash_state *state = &rctx->state;
+	int pages;
+	void *buf;
 
-	rctx->op = op;
+	pages = get_order(new_len);
 
-	return stm32_hash_handle_queue(hdev, req);
+	buf = (void *)__get_free_pages(GFP_ATOMIC, pages);
+	if (!buf) {
+		pr_err("Couldn't allocate pages for unaligned cases.\n");
+		return -ENOMEM;
+	}
+
+	if (state->bufcnt)
+		memcpy(buf, rctx->hdev->xmit_buf, state->bufcnt);
+
+	scatterwalk_map_and_copy(buf + state->bufcnt, sg, rctx->offset,
+				 min(new_len, rctx->total) - state->bufcnt, 0);
+	sg_init_table(rctx->sgl, 1);
+	sg_set_buf(rctx->sgl, buf, new_len);
+	rctx->sg = rctx->sgl;
+	state->flags |= HASH_FLAGS_SGS_COPIED;
+	rctx->nents = 1;
+	rctx->offset += new_len - state->bufcnt;
+	state->bufcnt = 0;
+	rctx->total = new_len;
+
+	return 0;
 }
 
-static int stm32_hash_update(struct ahash_request *req)
+static int stm32_hash_align_sgs(struct scatterlist *sg,
+				int nbytes, int bs, bool init, bool final,
+				struct stm32_hash_request_ctx *rctx)
 {
-	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
+	struct stm32_hash_dev *hdev = rctx->hdev;
+	struct scatterlist *sg_tmp = sg;
+	int offset = rctx->offset;
+	int new_len;
+	int n = 0;
+	int bufcnt = state->bufcnt;
+	bool secure_ctx = hdev->pdata->context_secured;
+	bool aligned = true;
+
+	if (!sg || !sg->length || !nbytes) {
+		if (bufcnt) {
+			bufcnt = DIV_ROUND_UP(bufcnt, bs) * bs;
+			sg_init_table(rctx->sgl, 1);
+			sg_set_buf(rctx->sgl, rctx->hdev->xmit_buf, bufcnt);
+			rctx->sg = rctx->sgl;
+			rctx->nents = 1;
+		}
 
-	if (!req->nbytes || !(rctx->flags & HASH_FLAGS_CPU))
 		return 0;
+	}
 
-	rctx->total = req->nbytes;
-	rctx->sg = req->src;
-	rctx->offset = 0;
+	new_len = nbytes;
 
-	if ((rctx->bufcnt + rctx->total < rctx->buflen)) {
-		stm32_hash_append_sg(rctx);
-		return 0;
+	if (offset)
+		aligned = false;
+
+	if (final) {
+		new_len = DIV_ROUND_UP(new_len, bs) * bs;
+	} else {
+		new_len = (new_len - 1) / bs * bs; // return n block - 1 block
+
+		/*
+		 * Context save in some version of HASH IP can only be done when the
+		 * FIFO is ready to get a new block. This implies to send n block plus a
+		 * 32 bit word in the first DMA send.
+		 */
+		if (init && secure_ctx) {
+			new_len += sizeof(u32);
+			if (unlikely(new_len > nbytes))
+				new_len -= bs;
+		}
 	}
 
-	return stm32_hash_enqueue(req, HASH_OP_UPDATE);
-}
+	if (!new_len)
+		return 0;
 
-static int stm32_hash_final(struct ahash_request *req)
-{
-	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	if (nbytes != new_len)
+		aligned = false;
 
-	rctx->flags |= HASH_FLAGS_FINUP;
+	while (nbytes > 0 && sg_tmp) {
+		n++;
 
-	return stm32_hash_enqueue(req, HASH_OP_FINAL);
-}
+		if (bufcnt) {
+			if (!IS_ALIGNED(bufcnt, bs)) {
+				aligned = false;
+				break;
+			}
+			nbytes -= bufcnt;
+			bufcnt = 0;
+			if (!nbytes)
+				aligned = false;
 
-static int stm32_hash_finup(struct ahash_request *req)
-{
-	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
-	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
-	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	int err1, err2;
+			continue;
+		}
 
-	rctx->flags |= HASH_FLAGS_FINUP;
+		if (offset < sg_tmp->length) {
+			if (!IS_ALIGNED(offset + sg_tmp->offset, 4)) {
+				aligned = false;
+				break;
+			}
 
-	if (hdev->dma_lch && stm32_hash_dma_aligned_data(req))
-		rctx->flags &= ~HASH_FLAGS_CPU;
+			if (!IS_ALIGNED(sg_tmp->length - offset, bs)) {
+				aligned = false;
+				break;
+			}
+		}
 
-	err1 = stm32_hash_update(req);
+		if (offset) {
+			offset -= sg_tmp->length;
+			if (offset < 0) {
+				nbytes += offset;
+				offset = 0;
+			}
+		} else {
+			nbytes -= sg_tmp->length;
+		}
 
-	if (err1 == -EINPROGRESS || err1 == -EBUSY)
-		return err1;
+		sg_tmp = sg_next(sg_tmp);
 
-	/*
-	 * final() has to be always called to cleanup resources
-	 * even if update() failed, except EINPROGRESS
-	 */
-	err2 = stm32_hash_final(req);
+		if (nbytes < 0) {
+			aligned = false;
+			break;
+		}
+	}
 
-	return err1 ?: err2;
-}
+	if (!aligned)
+		return stm32_hash_copy_sgs(rctx, sg, bs, new_len);
+
+	rctx->total = new_len;
+	rctx->offset += new_len;
+	rctx->nents = n;
+	if (state->bufcnt) {
+		sg_init_table(rctx->sgl, 2);
+		sg_set_buf(rctx->sgl, rctx->hdev->xmit_buf, state->bufcnt);
+		sg_chain(rctx->sgl, 2, sg);
+		rctx->sg = rctx->sgl;
+	} else {
+		rctx->sg = sg;
+	}
 
-static int stm32_hash_digest(struct ahash_request *req)
-{
-	return stm32_hash_init(req) ?: stm32_hash_finup(req);
+	return 0;
 }
 
-static int stm32_hash_export(struct ahash_request *req, void *out)
+static int stm32_hash_prepare_request(struct crypto_engine *engine, void *areq)
 {
-	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct ahash_request *req = container_of(areq, struct ahash_request, base);
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
 	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	u32 *preg;
-	unsigned int i;
-
-	pm_runtime_get_sync(hdev->dev);
+	struct stm32_hash_state *state = &rctx->state;
+	unsigned int nbytes;
+	int ret, hash_later, bs;
+	bool update = rctx->op & HASH_OP_UPDATE;
+	bool init = !(state->flags & HASH_FLAGS_INIT);
+	bool finup = state->flags & HASH_FLAGS_FINUP;
+	bool final = state->flags & HASH_FLAGS_FINAL;
+
+	if (!hdev->dma_lch || state->flags & HASH_FLAGS_CPU)
+		return 0;
 
-	while ((stm32_hash_read(hdev, HASH_SR) & HASH_SR_BUSY))
-		cpu_relax();
+	bs = crypto_ahash_blocksize(tfm);
 
-	rctx->hw_context = kmalloc_array(3 + HASH_CSR_REGISTER_NUMBER,
-					 sizeof(u32),
-					 GFP_KERNEL);
+	nbytes = state->bufcnt;
 
-	preg = rctx->hw_context;
+	/*
+	 * In case of update request nbytes must correspond to the content of the
+	 * buffer + the offset minus the content of the request already in the
+	 * buffer.
+	 */
+	if (update || finup)
+		nbytes += req->nbytes - rctx->offset;
 
-	*preg++ = stm32_hash_read(hdev, HASH_IMR);
-	*preg++ = stm32_hash_read(hdev, HASH_STR);
-	*preg++ = stm32_hash_read(hdev, HASH_CR);
-	for (i = 0; i < HASH_CSR_REGISTER_NUMBER; i++)
-		*preg++ = stm32_hash_read(hdev, HASH_CSR(i));
+	dev_dbg(hdev->dev,
+		"%s: nbytes=%d, bs=%d, total=%d, offset=%d, bufcnt=%d\n",
+		__func__, nbytes, bs, rctx->total, rctx->offset, state->bufcnt);
 
-	pm_runtime_mark_last_busy(hdev->dev);
-	pm_runtime_put_autosuspend(hdev->dev);
+	if (!nbytes)
+		return 0;
+
+	rctx->total = nbytes;
+
+	/* copy buffer in a temporary one that is used for sg alignment */
+	if (state->bufcnt)
+		memcpy(hdev->xmit_buf, state->buffer, state->bufcnt);
+
+	ret = stm32_hash_align_sgs(req->src, nbytes, bs, init, final, rctx);
+	if (ret)
+		return ret;
 
-	memcpy(out, rctx, sizeof(*rctx));
+	hash_later = nbytes - rctx->total;
+	if (hash_later < 0)
+		hash_later = 0;
+
+	if (hash_later && hash_later <= state->blocklen) {
+		scatterwalk_map_and_copy(state->buffer,
+					 req->src,
+					 req->nbytes - hash_later,
+					 hash_later, 0);
+
+		state->bufcnt = hash_later;
+	} else {
+		state->bufcnt = 0;
+	}
+
+	if (hash_later > state->blocklen) {
+		/* FIXME: add support of this case */
+		pr_err("Buffer contains more than one block.\n");
+		return -ENOMEM;
+	}
+
+	rctx->total = min(nbytes, rctx->total);
 
 	return 0;
 }
 
-static int stm32_hash_import(struct ahash_request *req, const void *in)
+static int stm32_hash_unprepare_request(struct crypto_engine *engine, void *areq)
 {
+	struct ahash_request *req = container_of(areq, struct ahash_request, base);
 	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
 	struct stm32_hash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
 	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
-	const u32 *preg = in;
-	u32 reg;
-	unsigned int i;
+	u32 *preg = state->hw_context;
+	int swap_reg, i;
 
-	memcpy(rctx, in, sizeof(*rctx));
+	if (hdev->dma_lch)
+		dmaengine_terminate_sync(hdev->dma_lch);
 
-	preg = rctx->hw_context;
+	if (state->flags & HASH_FLAGS_SGS_COPIED)
+		free_pages((unsigned long)sg_virt(rctx->sg), get_order(rctx->sg->length));
 
-	pm_runtime_get_sync(hdev->dev);
+	rctx->sg = NULL;
+	rctx->offset = 0;
 
-	stm32_hash_write(hdev, HASH_IMR, *preg++);
-	stm32_hash_write(hdev, HASH_STR, *preg++);
-	stm32_hash_write(hdev, HASH_CR, *preg);
-	reg = *preg++ | HASH_CR_INIT;
-	stm32_hash_write(hdev, HASH_CR, reg);
+	state->flags &= ~(HASH_FLAGS_SGS_COPIED);
+
+	if (!(hdev->flags & HASH_FLAGS_INIT))
+		goto pm_runtime;
+
+	state->flags |= HASH_FLAGS_INIT;
+
+	if (stm32_hash_wait_busy(hdev))
+		return -ETIMEDOUT;
 
-	for (i = 0; i < HASH_CSR_REGISTER_NUMBER; i++)
-		stm32_hash_write(hdev, HASH_CSR(i), *preg++);
+	swap_reg = hash_swap_reg(rctx);
 
+	if (!hdev->pdata->ux500)
+		*preg++ = stm32_hash_read(hdev, HASH_IMR);
+	*preg++ = stm32_hash_read(hdev, HASH_STR);
+	*preg++ = stm32_hash_read(hdev, HASH_CR);
+	for (i = 0; i < swap_reg; i++)
+		*preg++ = stm32_hash_read(hdev, HASH_CSR(i));
+
+pm_runtime:
 	pm_runtime_mark_last_busy(hdev->dev);
 	pm_runtime_put_autosuspend(hdev->dev);
 
-	kfree(rctx->hw_context);
+	return 0;
+}
+
+static int stm32_hash_enqueue(struct ahash_request *req, unsigned int op)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct stm32_hash_dev *hdev = ctx->hdev;
+
+	rctx->op = op;
+
+	return stm32_hash_handle_queue(hdev, req);
+}
+
+static int stm32_hash_update(struct ahash_request *req)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
+
+	if (!req->nbytes)
+		return 0;
+
+	if (state->flags & HASH_FLAGS_CPU) {
+		rctx->total = req->nbytes;
+		rctx->sg = req->src;
+		rctx->offset = 0;
+
+		if ((state->bufcnt + rctx->total < state->blocklen)) {
+			stm32_hash_append_sg(rctx);
+			return 0;
+		}
+	} else { /* DMA mode */
+		if (state->bufcnt + req->nbytes <= state->blocklen) {
+			scatterwalk_map_and_copy(state->buffer + state->bufcnt, req->src,
+						 0, req->nbytes, 0);
+			state->bufcnt += req->nbytes;
+			return 0;
+		}
+	}
+
+	return stm32_hash_enqueue(req, HASH_OP_UPDATE);
+}
+
+static int stm32_hash_final(struct ahash_request *req)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
+
+	state->flags |= HASH_FLAGS_FINAL;
+
+	return stm32_hash_enqueue(req, HASH_OP_FINAL);
+}
+
+static int stm32_hash_finup(struct ahash_request *req)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+	struct stm32_hash_state *state = &rctx->state;
+
+	if (!req->nbytes)
+		goto out;
+
+	state->flags |= HASH_FLAGS_FINUP;
+
+	if ((state->flags & HASH_FLAGS_CPU)) {
+		rctx->total = req->nbytes;
+		rctx->sg = req->src;
+		rctx->offset = 0;
+	}
+
+out:
+	return stm32_hash_final(req);
+}
+
+static int stm32_hash_digest(struct ahash_request *req)
+{
+	int ret;
+
+	ret = stm32_hash_init(req);
+	if (ret)
+		return ret;
+
+	return stm32_hash_finup(req);
+}
+
+static int stm32_hash_export(struct ahash_request *req, void *out)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+
+	memcpy(out, &rctx->state, sizeof(rctx->state));
+
+	return 0;
+}
+
+static int stm32_hash_import(struct ahash_request *req, const void *in)
+{
+	struct stm32_hash_request_ctx *rctx = ahash_request_ctx(req);
+
+	stm32_hash_init(req);
+	memcpy(&rctx->state, in, sizeof(rctx->state));
 
 	return 0;
 }
@@ -1034,8 +1477,30 @@ static int stm32_hash_setkey(struct crypto_ahash *tfm,
 	return 0;
 }
 
-static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm,
-				    const char *algs_hmac_name)
+static int stm32_hash_init_fallback(struct crypto_tfm *tfm)
+{
+	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct stm32_hash_dev *hdev = stm32_hash_find_dev(ctx);
+	const char *name = crypto_tfm_alg_name(tfm);
+	struct crypto_shash *xtfm;
+
+	/* The fallback is only needed on Ux500 */
+	if (!hdev->pdata->ux500)
+		return 0;
+
+	xtfm = crypto_alloc_shash(name, 0, CRYPTO_ALG_NEED_FALLBACK);
+	if (IS_ERR(xtfm)) {
+		dev_err(hdev->dev, "failed to allocate %s fallback\n",
+			name);
+		return PTR_ERR(xtfm);
+	}
+	dev_info(hdev->dev, "allocated %s fallback\n", name);
+	ctx->xtfm = xtfm;
+
+	return 0;
+}
+
+static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm, u32 algs_flags)
 {
 	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);
 
@@ -1044,54 +1509,53 @@ static int stm32_hash_cra_init_algs(struct crypto_tfm *tfm,
 
 	ctx->keylen = 0;
 
-	if (algs_hmac_name)
-		ctx->flags |= HASH_FLAGS_HMAC;
+	if (algs_flags)
+		ctx->flags |= algs_flags;
 
 	ctx->enginectx.op.do_one_request = stm32_hash_one_request;
-	ctx->enginectx.op.prepare_request = stm32_hash_prepare_req;
-	ctx->enginectx.op.unprepare_request = NULL;
-	return 0;
+	ctx->enginectx.op.prepare_request = stm32_hash_prepare_request;
+	ctx->enginectx.op.unprepare_request = stm32_hash_unprepare_request;
+
+	return stm32_hash_init_fallback(tfm);
 }
 
 static int stm32_hash_cra_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, NULL);
+	return stm32_hash_cra_init_algs(tfm, 0);
 }
 
-static int stm32_hash_cra_md5_init(struct crypto_tfm *tfm)
+static int stm32_hash_cra_hmac_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "md5");
+	return stm32_hash_cra_init_algs(tfm, HASH_FLAGS_HMAC);
 }
 
-static int stm32_hash_cra_sha1_init(struct crypto_tfm *tfm)
+static int stm32_hash_cra_sha3_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "sha1");
+	return stm32_hash_cra_init_algs(tfm, HASH_FLAGS_SHA3_MODE);
 }
 
-static int stm32_hash_cra_sha224_init(struct crypto_tfm *tfm)
+static int stm32_hash_cra_sha3_hmac_init(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "sha224");
+	return stm32_hash_cra_init_algs(tfm, HASH_FLAGS_SHA3_MODE |
+					HASH_FLAGS_HMAC);
 }
 
-static int stm32_hash_cra_sha256_init(struct crypto_tfm *tfm)
+
+static void stm32_hash_cra_exit(struct crypto_tfm *tfm)
 {
-	return stm32_hash_cra_init_algs(tfm, "sha256");
+	struct stm32_hash_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	if (ctx->xtfm)
+		crypto_free_shash(ctx->xtfm);
 }
 
 static irqreturn_t stm32_hash_irq_thread(int irq, void *dev_id)
 {
 	struct stm32_hash_dev *hdev = dev_id;
 
-	if (HASH_FLAGS_CPU & hdev->flags) {
-		if (HASH_FLAGS_OUTPUT_READY & hdev->flags) {
-			hdev->flags &= ~HASH_FLAGS_OUTPUT_READY;
-			goto finish;
-		}
-	} else if (HASH_FLAGS_DMA_READY & hdev->flags) {
-		if (HASH_FLAGS_DMA_ACTIVE & hdev->flags) {
-			hdev->flags &= ~HASH_FLAGS_DMA_ACTIVE;
-				goto finish;
-		}
+	if (HASH_FLAGS_OUTPUT_READY & hdev->flags) {
+		hdev->flags &= ~HASH_FLAGS_OUTPUT_READY;
+		goto finish;
 	}
 
 	return IRQ_HANDLED;
@@ -1110,8 +1574,6 @@ static irqreturn_t stm32_hash_irq_handler(int irq, void *dev_id)
 
 	reg = stm32_hash_read(hdev, HASH_SR);
 	if (reg & HASH_SR_OUTPUT_READY) {
-		reg &= ~HASH_SR_OUTPUT_READY;
-		stm32_hash_write(hdev, HASH_SR, reg);
 		hdev->flags |= HASH_FLAGS_OUTPUT_READY;
 		/* Disable IT*/
 		stm32_hash_write(hdev, HASH_IMR, 0);
@@ -1121,7 +1583,7 @@ static irqreturn_t stm32_hash_irq_handler(int irq, void *dev_id)
 	return IRQ_NONE;
 }
 
-static struct ahash_alg algs_md5_sha1[] = {
+static struct ahash_alg algs_md5[] = {
 	{
 		.init = stm32_hash_init,
 		.update = stm32_hash_update,
@@ -1132,7 +1594,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = MD5_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "md5",
 				.cra_driver_name = "stm32-md5",
@@ -1143,6 +1605,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
 				.cra_init = stm32_hash_cra_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
@@ -1158,7 +1621,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.setkey = stm32_hash_setkey,
 		.halg = {
 			.digestsize = MD5_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(md5)",
 				.cra_driver_name = "stm32-hmac-md5",
@@ -1168,11 +1631,15 @@ static struct ahash_alg algs_md5_sha1[] = {
 				.cra_blocksize = MD5_HMAC_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_md5_init,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
-	},
+	}
+};
+
+static struct ahash_alg algs_sha1[] = {
 	{
 		.init = stm32_hash_init,
 		.update = stm32_hash_update,
@@ -1183,7 +1650,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA1_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "sha1",
 				.cra_driver_name = "stm32-sha1",
@@ -1194,6 +1661,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
 				.cra_init = stm32_hash_cra_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
@@ -1209,7 +1677,7 @@ static struct ahash_alg algs_md5_sha1[] = {
 		.setkey = stm32_hash_setkey,
 		.halg = {
 			.digestsize = SHA1_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(sha1)",
 				.cra_driver_name = "stm32-hmac-sha1",
@@ -1219,14 +1687,15 @@ static struct ahash_alg algs_md5_sha1[] = {
 				.cra_blocksize = SHA1_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_sha1_init,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
 	},
 };
 
-static struct ahash_alg algs_sha224_sha256[] = {
+static struct ahash_alg algs_sha224[] = {
 	{
 		.init = stm32_hash_init,
 		.update = stm32_hash_update,
@@ -1237,7 +1706,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA224_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "sha224",
 				.cra_driver_name = "stm32-sha224",
@@ -1248,6 +1717,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
 				.cra_init = stm32_hash_cra_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
@@ -1263,7 +1733,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA224_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(sha224)",
 				.cra_driver_name = "stm32-hmac-sha224",
@@ -1273,11 +1743,15 @@ static struct ahash_alg algs_sha224_sha256[] = {
 				.cra_blocksize = SHA224_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_sha224_init,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
 	},
+};
+
+static struct ahash_alg algs_sha256[] = {
 	{
 		.init = stm32_hash_init,
 		.update = stm32_hash_update,
@@ -1288,7 +1762,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.import = stm32_hash_import,
 		.halg = {
 			.digestsize = SHA256_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "sha256",
 				.cra_driver_name = "stm32-sha256",
@@ -1299,6 +1773,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
 				.cra_init = stm32_hash_cra_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
@@ -1314,7 +1789,7 @@ static struct ahash_alg algs_sha224_sha256[] = {
 		.setkey = stm32_hash_setkey,
 		.halg = {
 			.digestsize = SHA256_DIGEST_SIZE,
-			.statesize = sizeof(struct stm32_hash_request_ctx),
+			.statesize = sizeof(struct stm32_hash_state),
 			.base = {
 				.cra_name = "hmac(sha256)",
 				.cra_driver_name = "stm32-hmac-sha256",
@@ -1324,13 +1799,338 @@ static struct ahash_alg algs_sha224_sha256[] = {
 				.cra_blocksize = SHA256_BLOCK_SIZE,
 				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
 				.cra_alignmask = 3,
-				.cra_init = stm32_hash_cra_sha256_init,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
 				.cra_module = THIS_MODULE,
 			}
 		}
 	},
 };
 
+static struct ahash_alg algs_sha384_sha512[] = {
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha384",
+				.cra_driver_name = "stm32-sha384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.setkey = stm32_hash_setkey,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha384)",
+				.cra_driver_name = "stm32-hmac-sha384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha512",
+				.cra_driver_name = "stm32-sha512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha512)",
+				.cra_driver_name = "stm32-hmac-sha512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+};
+
+static struct ahash_alg algs_sha3[] = {
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_224_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-224",
+				.cra_driver_name = "stm32-sha3-224",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_224_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-224)",
+				.cra_driver_name = "stm32-hmac-sha3-224",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+		{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_256_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-256",
+				.cra_driver_name = "stm32-sha3-256",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_256_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-256)",
+				.cra_driver_name = "stm32-hmac-sha3-256",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-384",
+				.cra_driver_name = "stm32-sha3-384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_384_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-384)",
+				.cra_driver_name = "stm32-hmac-sha3-384",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_384_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.halg = {
+			.digestsize = SHA3_512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "sha3-512",
+				.cra_driver_name = "stm32-sha3-512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	},
+	{
+		.init = stm32_hash_init,
+		.update = stm32_hash_update,
+		.final = stm32_hash_final,
+		.finup = stm32_hash_finup,
+		.digest = stm32_hash_digest,
+		.export = stm32_hash_export,
+		.import = stm32_hash_import,
+		.setkey = stm32_hash_setkey,
+		.halg = {
+			.digestsize = SHA3_512_DIGEST_SIZE,
+			.statesize = sizeof(struct stm32_hash_state),
+			.base = {
+				.cra_name = "hmac(sha3-512)",
+				.cra_driver_name = "stm32-hmac-sha3-512",
+				.cra_priority = 200,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA3_512_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct stm32_hash_ctx),
+				.cra_alignmask = 3,
+				.cra_init = stm32_hash_cra_sha3_hmac_init,
+				.cra_exit = stm32_hash_cra_exit,
+				.cra_module = THIS_MODULE,
+			}
+		}
+	}
+};
+
 static int stm32_hash_register_algs(struct stm32_hash_dev *hdev)
 {
 	unsigned int i, j;
@@ -1370,43 +2170,108 @@ static int stm32_hash_unregister_algs(struct stm32_hash_dev *hdev)
 	return 0;
 }
 
+static struct stm32_hash_algs_info stm32_hash_algs_info_ux500[] = {
+	{
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
+	},
+	{
+		.algs_list	= algs_sha256,
+		.size		= ARRAY_SIZE(algs_sha256),
+	},
+};
+
+static const struct stm32_hash_pdata stm32_hash_pdata_ux500 = {
+	.alg_shift	= 7,
+	.algs_info	= stm32_hash_algs_info_ux500,
+	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_ux500),
+	.broken_emptymsg = true,
+	.ux500		= true,
+};
+
 static struct stm32_hash_algs_info stm32_hash_algs_info_stm32f4[] = {
 	{
-		.algs_list	= algs_md5_sha1,
-		.size		= ARRAY_SIZE(algs_md5_sha1),
+		.algs_list	= algs_md5,
+		.size		= ARRAY_SIZE(algs_md5),
+	},
+	{
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
 	},
 };
 
 static const struct stm32_hash_pdata stm32_hash_pdata_stm32f4 = {
+	.alg_shift	= 7,
 	.algs_info	= stm32_hash_algs_info_stm32f4,
 	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_stm32f4),
+	.has_sr		= true,
+	.has_mdmat	= true,
 };
 
 static struct stm32_hash_algs_info stm32_hash_algs_info_stm32f7[] = {
 	{
-		.algs_list	= algs_md5_sha1,
-		.size		= ARRAY_SIZE(algs_md5_sha1),
+		.algs_list	= algs_md5,
+		.size		= ARRAY_SIZE(algs_md5),
+	},
+	{
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
 	},
 	{
-		.algs_list	= algs_sha224_sha256,
-		.size		= ARRAY_SIZE(algs_sha224_sha256),
+		.algs_list	= algs_sha224,
+		.size		= ARRAY_SIZE(algs_sha224),
+	},
+	{
+		.algs_list	= algs_sha256,
+		.size		= ARRAY_SIZE(algs_sha256),
 	},
 };
 
 static const struct stm32_hash_pdata stm32_hash_pdata_stm32f7 = {
+	.alg_shift	= 7,
 	.algs_info	= stm32_hash_algs_info_stm32f7,
 	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_stm32f7),
+	.has_sr		= true,
+	.has_mdmat	= true,
 };
 
-static const struct of_device_id stm32_hash_of_match[] = {
+static struct stm32_hash_algs_info stm32_hash_algs_info_stm32mp13[] = {
+	{
+		.algs_list	= algs_sha1,
+		.size		= ARRAY_SIZE(algs_sha1),
+	},
+	{
+		.algs_list	= algs_sha224,
+		.size		= ARRAY_SIZE(algs_sha224),
+	},
+	{
+		.algs_list	= algs_sha256,
+		.size		= ARRAY_SIZE(algs_sha256),
+	},
 	{
-		.compatible = "st,stm32f456-hash",
-		.data = &stm32_hash_pdata_stm32f4,
+		.algs_list	= algs_sha384_sha512,
+		.size		= ARRAY_SIZE(algs_sha384_sha512),
 	},
 	{
-		.compatible = "st,stm32f756-hash",
-		.data = &stm32_hash_pdata_stm32f7,
+		.algs_list	= algs_sha3,
+		.size		= ARRAY_SIZE(algs_sha3),
 	},
+};
+
+static const struct stm32_hash_pdata stm32_hash_pdata_stm32mp13 = {
+	.alg_shift	= 17,
+	.algs_info	= stm32_hash_algs_info_stm32mp13,
+	.algs_info_size	= ARRAY_SIZE(stm32_hash_algs_info_stm32mp13),
+	.has_sr		= true,
+	.has_mdmat	= true,
+	.context_secured = true,
+};
+
+static const struct of_device_id stm32_hash_of_match[] = {
+	{ .compatible = "stericsson,ux500-hash", .data = &stm32_hash_pdata_ux500 },
+	{ .compatible = "st,stm32f456-hash", .data = &stm32_hash_pdata_stm32f4 },
+	{ .compatible = "st,stm32f756-hash", .data = &stm32_hash_pdata_stm32f7 },
+	{ .compatible = "st,stm32mp13-hash", .data = &stm32_hash_pdata_stm32mp13 },
 	{},
 };
 
@@ -1421,12 +2286,6 @@ static int stm32_hash_get_of_match(struct stm32_hash_dev *hdev,
 		return -EINVAL;
 	}
 
-	if (of_property_read_u32(dev->of_node, "dma-maxburst",
-				 &hdev->dma_maxburst)) {
-		dev_info(dev, "dma-maxburst not specified, using 0\n");
-		hdev->dma_maxburst = 0;
-	}
-
 	return 0;
 }
 
@@ -1441,8 +2300,7 @@ static int stm32_hash_probe(struct platform_device *pdev)
 	if (!hdev)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	hdev->io_base = devm_ioremap_resource(dev, res);
+	hdev->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(hdev->io_base))
 		return PTR_ERR(hdev->io_base);
 
@@ -1452,16 +2310,23 @@ static int stm32_hash_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
+	irq = platform_get_irq_optional(pdev, 0);
+	if (irq < 0 && irq != -ENXIO)
 		return irq;
 
-	ret = devm_request_threaded_irq(dev, irq, stm32_hash_irq_handler,
-					stm32_hash_irq_thread, IRQF_ONESHOT,
-					dev_name(dev), hdev);
-	if (ret) {
-		dev_err(dev, "Cannot grab IRQ\n");
-		return ret;
+	if (irq > 0) {
+		ret = devm_request_threaded_irq(dev, irq,
+						stm32_hash_irq_handler,
+						stm32_hash_irq_thread,
+						IRQF_ONESHOT,
+						dev_name(dev), hdev);
+		if (ret) {
+			dev_err(dev, "Cannot grab IRQ\n");
+			return ret;
+		}
+	} else {
+		dev_info(dev, "No IRQ, use polling mode\n");
+		hdev->polled = true;
 	}
 
 	hdev->clk = devm_clk_get(&pdev->dev, NULL);
@@ -1503,9 +2368,11 @@ static int stm32_hash_probe(struct platform_device *pdev)
 	case 0:
 		break;
 	case -ENOENT:
-		dev_dbg(dev, "DMA mode not available\n");
+	case -ENODEV:
+		dev_info(dev, "DMA mode not available\n");
 		break;
 	default:
+		dev_err(dev, "DMA init error %d\n", ret);
 		goto err_dma;
 	}
 
@@ -1524,7 +2391,11 @@ static int stm32_hash_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_engine_start;
 
-	hdev->dma_mode = stm32_hash_read(hdev, HASH_HWCFGR);
+	if (hdev->pdata->ux500)
+		/* FIXME: implement DMA mode for Ux500 */
+		hdev->dma_mode = 0;
+	else
+		hdev->dma_mode = stm32_hash_read(hdev, HASH_HWCFGR) & HASH_HWCFG_DMA_MASK;
 
 	/* Register algos */
 	ret = stm32_hash_register_algs(hdev);
@@ -1632,6 +2503,6 @@ static struct platform_driver stm32_hash_driver = {
 
 module_platform_driver(stm32_hash_driver);
 
-MODULE_DESCRIPTION("STM32 SHA1/224/256 & MD5 (HMAC) hw accelerator driver");
+MODULE_DESCRIPTION("STM32 SHA1/SHA2/SHA3 & MD5 (HMAC) hw accelerator driver");
 MODULE_AUTHOR("Lionel Debieve <lionel.debieve@st.com>");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 81de833cc..f3209c19c 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -579,38 +579,6 @@ config ST_FDMA
 	  Say Y here if you have such a chipset.
 	  If unsure, say N.
 
-config STM32_DMA
-	bool "STMicroelectronics STM32 DMA support"
-	depends on ARCH_STM32 || COMPILE_TEST
-	select DMA_ENGINE
-	select DMA_VIRTUAL_CHANNELS
-	help
-	  Enable support for the on-chip DMA controller on STMicroelectronics
-	  STM32 MCUs.
-	  If you have a board based on such a MCU and wish to use DMA say Y
-	  here.
-
-config STM32_DMAMUX
-	bool "STMicroelectronics STM32 dma multiplexer support"
-	depends on STM32_DMA || COMPILE_TEST
-	help
-	  Enable support for the on-chip DMA multiplexer on STMicroelectronics
-	  STM32 MCUs.
-	  If you have a board based on such a MCU and wish to use DMAMUX say Y
-	  here.
-
-config STM32_MDMA
-	bool "STMicroelectronics STM32 master dma support"
-	depends on ARCH_STM32 || COMPILE_TEST
-	depends on OF
-	select DMA_ENGINE
-	select DMA_VIRTUAL_CHANNELS
-	help
-	  Enable support for the on-chip MDMA controller on STMicroelectronics
-	  STM32 platforms.
-	  If you have a board based on STM32 SoC and wish to use the master DMA
-	  say Y here.
-
 config SPRD_DMA
 	tristate "Spreadtrum DMA support"
 	depends on ARCH_SPRD || COMPILE_TEST
@@ -780,6 +748,8 @@ source "drivers/dma/fsl-dpaa2-qdma/Kconfig"
 
 source "drivers/dma/lgm/Kconfig"
 
+source "drivers/dma/stm32/Kconfig"
+
 # clients
 comment "DMA Clients"
 	depends on DMA_ENGINE
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 10f7d4241..14e7e49f3 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -67,9 +67,6 @@ obj-$(CONFIG_PXA_DMA) += pxa_dma.o
 obj-$(CONFIG_RENESAS_DMA) += sh/
 obj-$(CONFIG_SF_PDMA) += sf-pdma/
 obj-$(CONFIG_STE_DMA40) += ste_dma40.o ste_dma40_ll.o
-obj-$(CONFIG_STM32_DMA) += stm32-dma.o
-obj-$(CONFIG_STM32_DMAMUX) += stm32-dmamux.o
-obj-$(CONFIG_STM32_MDMA) += stm32-mdma.o
 obj-$(CONFIG_SPRD_DMA) += sprd-dma.o
 obj-$(CONFIG_S3C24XX_DMAC) += s3c24xx-dma.o
 obj-$(CONFIG_TXX9_DMAC) += txx9dmac.o
@@ -86,5 +83,6 @@ obj-$(CONFIG_INTEL_LDMA) += lgm/
 
 obj-y += mediatek/
 obj-y += qcom/
+obj-y += stm32/
 obj-y += ti/
 obj-y += xilinx/
diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index 892e83892..baaa1cf06 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -1037,7 +1037,8 @@ static int get_dma_id(struct dma_device *device)
 }
 
 static int __dma_async_device_channel_register(struct dma_device *device,
-					       struct dma_chan *chan)
+					       struct dma_chan *chan,
+					       const char *name)
 {
 	int rc;
 
@@ -1066,8 +1067,10 @@ static int __dma_async_device_channel_register(struct dma_device *device,
 	chan->dev->device.parent = device->dev;
 	chan->dev->chan = chan;
 	chan->dev->dev_id = device->dev_id;
-	dev_set_name(&chan->dev->device, "dma%dchan%d",
-		     device->dev_id, chan->chan_id);
+	if (!name)
+		dev_set_name(&chan->dev->device, "dma%dchan%d", device->dev_id, chan->chan_id);
+	else
+		dev_set_name(&chan->dev->device, name);
 	rc = device_register(&chan->dev->device);
 	if (rc)
 		goto err_out_ida;
@@ -1087,11 +1090,12 @@ static int __dma_async_device_channel_register(struct dma_device *device,
 }
 
 int dma_async_device_channel_register(struct dma_device *device,
-				      struct dma_chan *chan)
+				      struct dma_chan *chan,
+				      const char *name)
 {
 	int rc;
 
-	rc = __dma_async_device_channel_register(device, chan);
+	rc = __dma_async_device_channel_register(device, chan, name);
 	if (rc < 0)
 		return rc;
 
@@ -1245,7 +1249,7 @@ int dma_async_device_register(struct dma_device *device)
 
 	/* represent channels in sysfs. Probably want devs too */
 	list_for_each_entry(chan, &device->channels, device_node) {
-		rc = __dma_async_device_channel_register(device, chan);
+		rc = __dma_async_device_channel_register(device, chan, NULL);
 		if (rc < 0)
 			goto err_out;
 	}
diff --git a/drivers/dma/dmatest.c b/drivers/dma/dmatest.c
index ffe621695..02d8ff1ee 100644
--- a/drivers/dma/dmatest.c
+++ b/drivers/dma/dmatest.c
@@ -21,6 +21,10 @@
 #include <linux/slab.h>
 #include <linux/wait.h>
 
+static bool nobounce;
+module_param(nobounce, bool, 0644);
+MODULE_PARM_DESC(nobounce, "Prevent using swiotlb buffer (default: use swiotlb buffer)");
+
 static unsigned int test_buf_size = 16384;
 module_param(test_buf_size, uint, 0644);
 MODULE_PARM_DESC(test_buf_size, "Size of the memcpy test buffer");
@@ -90,6 +94,7 @@ MODULE_PARM_DESC(polled, "Use polling for completion instead of interrupts");
 
 /**
  * struct dmatest_params - test parameters.
+ * @nobounce:		avoid using swiotlb buffer
  * @buf_size:		size of the memcpy test buffer
  * @channel:		bus ID of the channel to test
  * @device:		bus ID of the DMA Engine to test
@@ -106,6 +111,7 @@ MODULE_PARM_DESC(polled, "Use polling for completion instead of interrupts");
  * @polled:		use polling for completion instead of interrupts
  */
 struct dmatest_params {
+	bool		nobounce;
 	unsigned int	buf_size;
 	char		channel[20];
 	char		device[32];
@@ -215,6 +221,7 @@ struct dmatest_done {
 struct dmatest_data {
 	u8		**raw;
 	u8		**aligned;
+	gfp_t		gfp_flags;
 	unsigned int	cnt;
 	unsigned int	off;
 };
@@ -533,7 +540,7 @@ static int dmatest_alloc_test_data(struct dmatest_data *d,
 		goto err;
 
 	for (i = 0; i < d->cnt; i++) {
-		d->raw[i] = kmalloc(buf_size + align, GFP_KERNEL);
+		d->raw[i] = kmalloc(buf_size + align, d->gfp_flags);
 		if (!d->raw[i])
 			goto err;
 
@@ -655,6 +662,13 @@ static int dmatest_func(void *data)
 		goto err_free_coefs;
 	}
 
+	src->gfp_flags = GFP_KERNEL;
+	dst->gfp_flags = GFP_KERNEL;
+	if (params->nobounce) {
+		src->gfp_flags = GFP_DMA;
+		dst->gfp_flags = GFP_DMA;
+	}
+
 	if (dmatest_alloc_test_data(src, buf_size, align) < 0)
 		goto err_free_coefs;
 
@@ -1093,6 +1107,7 @@ static void add_threaded_test(struct dmatest_info *info)
 	struct dmatest_params *params = &info->params;
 
 	/* Copy test parameters */
+	params->nobounce = nobounce;
 	params->buf_size = test_buf_size;
 	strscpy(params->channel, strim(test_channel), sizeof(params->channel));
 	strscpy(params->device, strim(test_device), sizeof(params->device));
diff --git a/drivers/dma/idxd/dma.c b/drivers/dma/idxd/dma.c
index e0874cb47..d938c23fb 100644
--- a/drivers/dma/idxd/dma.c
+++ b/drivers/dma/idxd/dma.c
@@ -274,7 +274,7 @@ static int idxd_register_dma_channel(struct idxd_wq *wq)
 		desc->txd.tx_submit = idxd_dma_tx_submit;
 	}
 
-	rc = dma_async_device_channel_register(dma, chan);
+	rc = dma_async_device_channel_register(dma, chan, NULL);
 	if (rc < 0) {
 		kfree(idxd_chan);
 		return rc;
diff --git a/drivers/dma/stm32/Kconfig b/drivers/dma/stm32/Kconfig
new file mode 100644
index 000000000..4d8d80631
--- /dev/null
+++ b/drivers/dma/stm32/Kconfig
@@ -0,0 +1,47 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# STM32 DMA controllers drivers
+#
+if ARCH_STM32 || COMPILE_TEST
+
+config STM32_DMA
+	bool "STMicroelectronics STM32 DMA support"
+	select DMA_ENGINE
+	select DMA_VIRTUAL_CHANNELS
+	help
+	  Enable support for the on-chip DMA controller on STMicroelectronics
+	  STM32 platforms.
+	  If you have a board based on STM32 SoC with such DMA controller
+	  and want to use DMA say Y here.
+
+config STM32_DMAMUX
+	bool "STMicroelectronics STM32 DMA multiplexer support"
+	depends on STM32_DMA
+	help
+	  Enable support for the on-chip DMA multiplexer on STMicroelectronics
+	  STM32 platforms.
+	  If you have a board based on STM32 SoC with such DMA multiplexer
+	  and want to use DMAMUX say Y here.
+
+config STM32_MDMA
+	bool "STMicroelectronics STM32 master DMA support"
+	depends on OF
+	select DMA_ENGINE
+	select DMA_VIRTUAL_CHANNELS
+	help
+	  Enable support for the on-chip MDMA controller on STMicroelectronics
+	  STM32 platforms.
+	  If you have a board based on STM32 SoC with such DMA controller
+	  and want to use MDMA say Y here.
+
+config STM32_DMA3
+	tristate "STMicroelectronics STM32 DMA3 support"
+	select DMA_ENGINE
+	select DMA_VIRTUAL_CHANNELS
+	help
+	  Enable support for the on-chip DMA3 controller on STMicroelectronics
+	  STM32 platforms.
+	  If you have a board based on STM32 SoC with such DMA3 controller
+	  and want to use DMA3, say Y here.
+
+endif
diff --git a/drivers/dma/stm32/Makefile b/drivers/dma/stm32/Makefile
new file mode 100644
index 000000000..5082db4b4
--- /dev/null
+++ b/drivers/dma/stm32/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_STM32_DMA) += stm32-dma.o
+obj-$(CONFIG_STM32_DMAMUX) += stm32-dmamux.o
+obj-$(CONFIG_STM32_MDMA) += stm32-mdma.o
+obj-$(CONFIG_STM32_DMA3) += stm32-dma3.o
diff --git a/drivers/dma/stm32-dma.c b/drivers/dma/stm32/stm32-dma.c
similarity index 99%
rename from drivers/dma/stm32-dma.c
rename to drivers/dma/stm32/stm32-dma.c
index 7abcd7f28..c2a8e0780 100644
--- a/drivers/dma/stm32-dma.c
+++ b/drivers/dma/stm32/stm32-dma.c
@@ -29,7 +29,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 
-#include "virt-dma.h"
+#include "../virt-dma.h"
 
 #define STM32_DMA_LISR			0x0000 /* DMA Low Int Status Reg */
 #define STM32_DMA_HISR			0x0004 /* DMA High Int Status Reg */
diff --git a/drivers/dma/stm32/stm32-dma3.c b/drivers/dma/stm32/stm32-dma3.c
new file mode 100644
index 000000000..cc2e05982
--- /dev/null
+++ b/drivers/dma/stm32/stm32-dma3.c
@@ -0,0 +1,2141 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STM32 DMA3 controller driver
+ *
+ * Copyright (C) STMicroelectronics 2024
+ * Author(s): Amelie Delaunay <amelie.delaunay@foss.st.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/dmapool.h>
+#include <linux/genalloc.h>
+#include <linux/init.h>
+#include <linux/iopoll.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of_dma.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include "../virt-dma.h"
+
+#define STM32_DMA3_SECCFGR		0x00
+#define STM32_DMA3_PRIVCFGR		0x04
+#define STM32_DMA3_RCFGLOCKR		0x08
+#define STM32_DMA3_MISR			0x0C
+#define STM32_DMA3_SMISR		0x10
+
+#define STM32_DMA3_CLBAR(x)		(0x50 + 0x80 * (x))
+#define STM32_DMA3_CCIDCFGR(x)		(0x54 + 0x80 * (x))
+#define STM32_DMA3_CSEMCR(x)		(0x58 + 0x80 * (x))
+#define STM32_DMA3_CFCR(x)		(0x5C + 0x80 * (x))
+#define STM32_DMA3_CSR(x)		(0x60 + 0x80 * (x))
+#define STM32_DMA3_CCR(x)		(0x64 + 0x80 * (x))
+#define STM32_DMA3_CTR1(x)		(0x90 + 0x80 * (x))
+#define STM32_DMA3_CTR2(x)		(0x94 + 0x80 * (x))
+#define STM32_DMA3_CBR1(x)		(0x98 + 0x80 * (x))
+#define STM32_DMA3_CSAR(x)		(0x9C + 0x80 * (x))
+#define STM32_DMA3_CDAR(x)		(0xA0 + 0x80 * (x))
+#define STM32_DMA3_CLLR(x)		(0xCC + 0x80 * (x))
+
+#define STM32_DMA3_HWCFGR13		0xFC0 /* G_PER_CTRL(X) x=8..15 */
+#define STM32_DMA3_HWCFGR12		0xFC4 /* G_PER_CTRL(X) x=0..7 */
+#define STM32_DMA3_HWCFGR4		0xFE4 /* G_FIFO_SIZE(X) x=8..15 */
+#define STM32_DMA3_HWCFGR3		0xFE8 /* G_FIFO_SIZE(X) x=0..7 */
+#define STM32_DMA3_HWCFGR2		0xFEC /* G_MAX_REQ_ID */
+#define STM32_DMA3_HWCFGR1		0xFF0 /* G_MASTER_PORTS, G_NUM_CHANNELS, G_Mx_DATA_WIDTH */
+#define STM32_DMA3_VERR			0xFF4
+
+/* SECCFGR DMA secure configuration register */
+#define SECCFGR_SEC(x)			BIT(x)
+
+/* MISR DMA non-secure/secure masked interrupt status register */
+#define MISR_MIS(x)			BIT(x)
+
+/* CxLBAR DMA channel x linked_list base address register */
+#define CLBAR_LBA			GENMASK(31, 16)
+
+/* CxCIDCFGR DMA channel x CID register */
+#define CCIDCFGR_CFEN			BIT(0)
+#define CCIDCFGR_SEM_EN			BIT(1)
+#define CCIDCFGR_SCID			GENMASK(5, 4)
+#define CCIDCFGR_SEM_WLIST_CID0		BIT(16)
+#define CCIDCFGR_SEM_WLIST_CID1		BIT(17)
+#define CCIDCFGR_SEM_WLIST_CID2		BIT(18)
+
+enum ccidcfgr_cid {
+	CCIDCFGR_CID0,
+	CCIDCFGR_CID1,
+	CCIDCFGR_CID2,
+};
+
+/* CxSEMCR DMA channel x semaphore control register */
+#define CSEMCR_SEM_MUTEX		BIT(0)
+#define CSEMCR_SEM_CCID			GENMASK(5, 4)
+
+/* CxFCR DMA channel x flag clear register */
+#define CFCR_TCF			BIT(8)
+#define CFCR_HTF			BIT(9)
+#define CFCR_DTEF			BIT(10)
+#define CFCR_ULEF			BIT(11)
+#define CFCR_USEF			BIT(12)
+#define CFCR_SUSPF			BIT(13)
+
+/* CxSR DMA channel x status register */
+#define CSR_IDLEF			BIT(0)
+#define CSR_TCF				BIT(8)
+#define CSR_HTF				BIT(9)
+#define CSR_DTEF			BIT(10)
+#define CSR_ULEF			BIT(11)
+#define CSR_USEF			BIT(12)
+#define CSR_SUSPF			BIT(13)
+#define CSR_ALL_F			GENMASK(13, 8)
+#define CSR_FIFOL			GENMASK(24, 16)
+
+/* CxCR DMA channel x control register */
+#define CCR_EN				BIT(0)
+#define CCR_RESET			BIT(1)
+#define CCR_SUSP			BIT(2)
+#define CCR_TCIE			BIT(8)
+#define CCR_HTIE			BIT(9)
+#define CCR_DTEIE			BIT(10)
+#define CCR_ULEIE			BIT(11)
+#define CCR_USEIE			BIT(12)
+#define CCR_SUSPIE			BIT(13)
+#define CCR_ALLIE			GENMASK(13, 8)
+#define CCR_LSM				BIT(16)
+#define CCR_LAP				BIT(17)
+#define CCR_PRIO			GENMASK(23, 22)
+
+enum ccr_prio {
+	CCR_PRIO_LOW,
+	CCR_PRIO_MID,
+	CCR_PRIO_HIGH,
+	CCR_PRIO_VERY_HIGH,
+};
+
+/* CxTR1 DMA channel x transfer register 1 */
+#define CTR1_SINC			BIT(3)
+#define CTR1_SBL_1			GENMASK(9, 4)
+#define CTR1_DINC			BIT(19)
+#define CTR1_DBL_1			GENMASK(25, 20)
+#define CTR1_SDW_LOG2			GENMASK(1, 0)
+#define CTR1_PAM			GENMASK(12, 11)
+#define CTR1_SAP			BIT(14)
+#define CTR1_DDW_LOG2			GENMASK(17, 16)
+#define CTR1_DAP			BIT(30)
+
+enum ctr1_dw {
+	CTR1_DW_BYTE,
+	CTR1_DW_HWORD,
+	CTR1_DW_WORD,
+	CTR1_DW_DWORD, /* Depends on HWCFGR1.G_M0_DATA_WIDTH_ENC and .G_M1_DATA_WIDTH_ENC */
+};
+
+enum ctr1_pam {
+	CTR1_PAM_0S_LT, /* if DDW > SDW, padded with 0s else left-truncated */
+	CTR1_PAM_SE_RT, /* if DDW > SDW, sign extended else right-truncated */
+	CTR1_PAM_PACK_UNPACK, /* FIFO queued */
+};
+
+/* CxTR2 DMA channel x transfer register 2 */
+#define CTR2_REQSEL			GENMASK(7, 0)
+#define CTR2_SWREQ			BIT(9)
+#define CTR2_DREQ			BIT(10)
+#define CTR2_BREQ			BIT(11)
+#define CTR2_PFREQ			BIT(12)
+#define CTR2_TCEM			GENMASK(31, 30)
+
+enum ctr2_tcem {
+	CTR2_TCEM_BLOCK,
+	CTR2_TCEM_REPEAT_BLOCK,
+	CTR2_TCEM_LLI,
+	CTR2_TCEM_CHANNEL,
+};
+
+/* CxBR1 DMA channel x block register 1 */
+#define CBR1_BNDT			GENMASK(15, 0)
+
+/* CxLLR DMA channel x linked-list address register */
+#define CLLR_LA				GENMASK(15, 2)
+#define CLLR_ULL			BIT(16)
+#define CLLR_UDA			BIT(27)
+#define CLLR_USA			BIT(28)
+#define CLLR_UB1			BIT(29)
+#define CLLR_UT2			BIT(30)
+#define CLLR_UT1			BIT(31)
+
+/* HWCFGR13 DMA hardware configuration register 13 x=8..15 */
+/* HWCFGR12 DMA hardware configuration register 12 x=0..7 */
+#define G_PER_CTRL(x)			(ULL(0x1) << (4 * (x)))
+
+/* HWCFGR4 DMA hardware configuration register 4 x=8..15 */
+/* HWCFGR3 DMA hardware configuration register 3 x=0..7 */
+#define G_FIFO_SIZE(x)			(ULL(0x7) << (4 * (x)))
+
+#define get_chan_hwcfg(x, mask, reg)	(((reg) & (mask)) >> (4 * (x)))
+
+/* HWCFGR2 DMA hardware configuration register 2 */
+#define G_MAX_REQ_ID			GENMASK(7, 0)
+
+/* HWCFGR1 DMA hardware configuration register 1 */
+#define G_MASTER_PORTS			GENMASK(2, 0)
+#define G_NUM_CHANNELS			GENMASK(12, 8)
+#define G_M0_DATA_WIDTH_ENC		GENMASK(25, 24)
+#define G_M1_DATA_WIDTH_ENC		GENMASK(29, 28)
+
+enum stm32_dma3_master_ports {
+	AXI64, /* 1x AXI: 64-bit port 0 */
+	AHB32, /* 1x AHB: 32-bit port 0 */
+	AHB32_AHB32, /* 2x AHB: 32-bit port 0 and 32-bit port 1 */
+	AXI64_AHB32, /* 1x AXI 64-bit port 0 and 1x AHB 32-bit port 1 */
+	AXI64_AXI64, /* 2x AXI: 64-bit port 0 and 64-bit port 1 */
+	AXI128_AHB32, /* 1x AXI 128-bit port 0 and 1x AHB 32-bit port 1 */
+};
+
+enum stm32_dma3_port_data_width {
+	DW_32, /* 32-bit, for AHB */
+	DW_64, /* 64-bit, for AXI */
+	DW_128, /* 128-bit, for AXI */
+	DW_INVALID,
+};
+
+/* VERR DMA version register */
+#define VERR_MINREV			GENMASK(3, 0)
+#define VERR_MAJREV			GENMASK(7, 4)
+
+/* Device tree */
+/* struct stm32_dma3_dt_conf */
+/* .ch_conf */
+#define STM32_DMA3_DT_PRIO		GENMASK(1, 0) /* CCR_PRIO */
+#define STM32_DMA3_DT_FIFO		GENMASK(7, 4)
+/* .tr_conf */
+#define STM32_DMA3_DT_SINC		BIT(0) /* CTR1_SINC */
+#define STM32_DMA3_DT_SAP		BIT(1) /* CTR1_SAP */
+#define STM32_DMA3_DT_DINC		BIT(4) /* CTR1_DINC */
+#define STM32_DMA3_DT_DAP		BIT(5) /* CTR1_DAP */
+#define STM32_DMA3_DT_BREQ		BIT(8) /* CTR2_BREQ */
+#define STM32_DMA3_DT_PFREQ		BIT(9) /* CTR2_PFREQ */
+#define STM32_DMA3_DT_TCEM		GENMASK(13, 12) /* CTR2_TCEM */
+#define STM32_DMA3_DT_NOPACK		BIT(16) /* CTR1_PAM */
+#define STM32_DMA3_DT_NOREFACT		BIT(17)
+
+/* struct stm32_dma3_chan .config_set bitfield */
+#define STM32_DMA3_CFG_SET_DT		BIT(0)
+#define STM32_DMA3_CFG_SET_DMA		BIT(1)
+#define STM32_DMA3_CFG_SET_BOTH		(STM32_DMA3_CFG_SET_DT | STM32_DMA3_CFG_SET_DMA)
+
+#define STM32_DMA3_MAX_BLOCK_SIZE	ALIGN_DOWN(CBR1_BNDT, 64)
+#define STM32_DMA3_MAX_BURST_LEN	(1 + min_t(u32, FIELD_GET(CTR1_SBL_1, CTR1_SBL_1), \
+							FIELD_GET(CTR1_DBL_1, CTR1_DBL_1)))
+#define port_is_ahb(maxdw)		({ typeof(maxdw) (_maxdw) = (maxdw); \
+					   ((_maxdw) != DW_INVALID) && ((_maxdw) == DW_32); })
+#define port_is_axi(maxdw)		({ typeof(maxdw) (_maxdw) = (maxdw); \
+					   ((_maxdw) != DW_INVALID) && ((_maxdw) != DW_32); })
+#define get_chan_max_dw(maxdw, maxburst)((port_is_ahb(maxdw) ||			     \
+					  (maxburst) < DMA_SLAVE_BUSWIDTH_8_BYTES) ? \
+					 DMA_SLAVE_BUSWIDTH_4_BYTES : DMA_SLAVE_BUSWIDTH_8_BYTES)
+
+/* Static linked-list data structure (depends on update bits UT1/UT2/UB1/USA/UDA/ULL) */
+struct stm32_dma3_hwdesc {
+	u32 ctr1;
+	u32 ctr2;
+	u32 cbr1;
+	u32 csar;
+	u32 cdar;
+	u32 cllr;
+} __aligned(32);
+
+/*
+ * CLLR_LA / sizeof(struct stm32_dma3_hwdesc) represents the number of hdwdesc that can be addressed
+ * by the pointer to the next linked-list data structure. The __aligned forces the 32-byte
+ * alignment. So use hardcoded 32. Multiplied by the max block size of each item, it represents
+ * the sg size limitation.
+ */
+#define STM32_DMA3_MAX_SEG_SIZE		((CLLR_LA / 32) * STM32_DMA3_MAX_BLOCK_SIZE)
+
+/*
+ * Linked-list items
+ */
+struct stm32_dma3_lli {
+	struct stm32_dma3_hwdesc *hwdesc;
+	dma_addr_t hwdesc_addr;
+};
+
+struct stm32_dma3_swdesc {
+	struct virt_dma_desc vdesc;
+	u32 ccr;
+	bool cyclic;
+	u32 lli_size;
+	struct stm32_dma3_lli lli[]; // __counted_by(lli_size);
+};
+
+struct stm32_dma3_dt_conf {
+	u32 ch_id;
+	u32 req_line;
+	u32 ch_conf;
+	u32 tr_conf;
+};
+
+struct stm32_dma3_chan {
+	struct virt_dma_chan vchan;
+	u32 id;
+	int irq;
+	u32 fifo_size;
+	u32 max_burst;
+	bool semaphore_mode;
+	bool semaphore_taken;
+	struct stm32_dma3_dt_conf dt_config;
+	struct dma_slave_config dma_config;
+	u8 config_set;
+	struct stm32_dma3_swdesc *swdesc;
+	enum ctr2_tcem tcem;
+	u32 dma_status;
+};
+
+struct stm32_dma3_ddata {
+	struct dma_device dma_dev;
+	void __iomem *base;
+	struct clk *clk;
+	struct stm32_dma3_chan *chans;
+	u32 dma_channels;
+	u32 dma_requests;
+	enum stm32_dma3_port_data_width ports_max_dw[2];
+	u32 axi_max_burst_len;
+	u32 lap;
+	struct gen_pool *gen_pool;
+	struct dma_pool *dma_pool;
+};
+
+static inline struct stm32_dma3_ddata *to_stm32_dma3_ddata(struct stm32_dma3_chan *chan)
+{
+	return container_of(chan->vchan.chan.device, struct stm32_dma3_ddata, dma_dev);
+}
+
+static inline struct stm32_dma3_chan *to_stm32_dma3_chan(struct dma_chan *c)
+{
+	return container_of(c, struct stm32_dma3_chan, vchan.chan);
+}
+
+static inline struct stm32_dma3_swdesc *to_stm32_dma3_swdesc(struct virt_dma_desc *vdesc)
+{
+	return container_of(vdesc, struct stm32_dma3_swdesc, vdesc);
+}
+
+static struct device *chan2dev(struct stm32_dma3_chan *chan)
+{
+	return &chan->vchan.chan.dev->device;
+}
+
+static void stm32_dma3_chan_dump_reg(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct device *dev = chan2dev(chan);
+	u32 id = chan->id, offset;
+
+	offset = STM32_DMA3_SECCFGR;
+	dev_dbg(dev, "SECCFGR(0x%03x): %08x\n", offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_PRIVCFGR;
+	dev_dbg(dev, "PRIVCFGR(0x%03x): %08x\n", offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CCIDCFGR(id);
+	dev_dbg(dev, "C%dCIDCFGR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CSEMCR(id);
+	dev_dbg(dev, "C%dSEMCR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CSR(id);
+	dev_dbg(dev, "C%dSR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CCR(id);
+	dev_dbg(dev, "C%dCR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CTR1(id);
+	dev_dbg(dev, "C%dTR1(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CTR2(id);
+	dev_dbg(dev, "C%dTR2(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CBR1(id);
+	dev_dbg(dev, "C%dBR1(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CSAR(id);
+	dev_dbg(dev, "C%dSAR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CDAR(id);
+	dev_dbg(dev, "C%dDAR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CLLR(id);
+	dev_dbg(dev, "C%dLLR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+	offset = STM32_DMA3_CLBAR(id);
+	dev_dbg(dev, "C%dLBAR(0x%03x): %08x\n", id, offset, readl_relaxed(ddata->base + offset));
+}
+
+static void stm32_dma3_chan_dump_hwdesc(struct stm32_dma3_chan *chan,
+					struct stm32_dma3_swdesc *swdesc)
+{
+	struct stm32_dma3_hwdesc *hwdesc;
+	int i;
+
+	for (i = 0; i < swdesc->lli_size; i++) {
+		hwdesc = swdesc->lli[i].hwdesc;
+		if (i)
+			dev_dbg(chan2dev(chan), "V\n");
+		dev_dbg(chan2dev(chan), "[%d]@%pad\n", i, &swdesc->lli[i].hwdesc_addr);
+		dev_dbg(chan2dev(chan), "| C%dTR1: %08x\n", chan->id, hwdesc->ctr1);
+		dev_dbg(chan2dev(chan), "| C%dTR2: %08x\n", chan->id, hwdesc->ctr2);
+		dev_dbg(chan2dev(chan), "| C%dBR1: %08x\n", chan->id, hwdesc->cbr1);
+		dev_dbg(chan2dev(chan), "| C%dSAR: %08x\n", chan->id, hwdesc->csar);
+		dev_dbg(chan2dev(chan), "| C%dDAR: %08x\n", chan->id, hwdesc->cdar);
+		dev_dbg(chan2dev(chan), "| C%dLLR: %08x\n", chan->id, hwdesc->cllr);
+	}
+
+	if (swdesc->cyclic) {
+		dev_dbg(chan2dev(chan), "|\n");
+		dev_dbg(chan2dev(chan), "-->[0]@%pad\n", &swdesc->lli[0].hwdesc_addr);
+	} else {
+		dev_dbg(chan2dev(chan), "X\n");
+	}
+}
+
+static int stm32_dma3_lli_pool_create(struct platform_device *pdev, struct stm32_dma3_ddata *ddata)
+{
+	struct device_node *rmem_np;
+	struct reserved_mem *rmem;
+	void *rmem_va;
+	phys_addr_t base;
+	size_t size;
+	int ret;
+
+	/* Check if a specific pool is specified in device tree for Linked-List Items */
+	rmem_np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+	if (!rmem_np)
+		goto no_specific_pool;
+
+	rmem = of_reserved_mem_lookup(rmem_np);
+	if (!rmem)
+		goto no_specific_pool;
+
+	base = rmem->base;
+	size = rmem->size;
+	if  (((base + size - 1) & CLBAR_LBA) != (base & CLBAR_LBA)) {
+		phys_addr_t new_base;
+		size_t boundary, size_before, size_after;
+
+		/* Check if the size is bigger before the first 64KiB boundary or after */
+		boundary = min_t(size_t, size, SZ_64K);
+		new_base = (base + boundary - 1) & CLBAR_LBA;
+		size_before = new_base - base;
+		size_after = size - size_before;
+		if (size_after > size_before) {
+			size = min_t(size_t, size_after, SZ_64K);
+			base = new_base;
+		} else {
+			size = size_before;
+			/* Keep original base */
+		}
+
+		dev_notice(&pdev->dev, "LLI gen_pool truncated (%ldKiB instead of %lldKiB)\n",
+			   size / SZ_1K, rmem->size / SZ_1K);
+	}
+
+	ddata->gen_pool = devm_gen_pool_create(&pdev->dev, ilog2(sizeof(struct stm32_dma3_hwdesc)),
+					       dev_to_node(&pdev->dev),	dev_name(&pdev->dev));
+	if (!ddata->gen_pool)
+		goto no_specific_pool;
+
+	rmem_va = devm_memremap(&pdev->dev, base, size, MEMREMAP_WC);
+	ret = gen_pool_add_virt(ddata->gen_pool, (unsigned long)rmem_va, base, size,
+				dev_to_node(&pdev->dev));
+	if (ret) {
+		gen_pool_destroy(ddata->gen_pool);
+		ddata->gen_pool = NULL;
+		goto no_specific_pool;
+	}
+
+	dev_info(&pdev->dev, "created LLI gen_pool at %pap, size %ldKiB\n",
+		 &base, gen_pool_size(ddata->gen_pool) / SZ_1K);
+
+no_specific_pool:
+	of_node_put(rmem_np);
+
+	/* Fallback pool */
+	ddata->dma_pool = dmam_pool_create(dev_name(&pdev->dev), &pdev->dev,
+					   sizeof(struct stm32_dma3_hwdesc),
+					   __alignof__(struct stm32_dma3_hwdesc), SZ_64K);
+	if (!ddata->gen_pool && !ddata->dma_pool)
+		return -ENOMEM;
+
+	dev_dbg(&pdev->dev, "created LLI %sdma_pool in DDR\n", ddata->gen_pool ? "fallback " : "");
+
+	return 0;
+}
+
+static void stm32_dma3_lli_pool_dma_free(struct stm32_dma3_ddata *ddata, struct stm32_dma3_lli lli)
+{
+	unsigned long addr = (unsigned long)lli.hwdesc;
+	size_t size = sizeof(struct stm32_dma3_hwdesc);
+
+	if (ddata->gen_pool && gen_pool_has_addr(ddata->gen_pool, addr, size))
+		gen_pool_free(ddata->gen_pool, addr, size);
+	else
+		dma_pool_free(ddata->dma_pool, lli.hwdesc, lli.hwdesc_addr);
+}
+
+static int stm32_dma3_lli_pool_dma_alloc(struct stm32_dma3_ddata *ddata, struct stm32_dma3_lli *lli,
+					 u32 count)
+{
+	size_t avail;
+	int i;
+
+	/* Fallback to dma_pool, if no gen_pool */
+	if (!ddata->gen_pool)
+		goto from_dma_pool;
+
+	/* Check if there is enough room in gen_pool, otherwise fallback to dma_pool */
+	avail = gen_pool_avail(ddata->gen_pool);
+	if (avail < (count * __alignof__(struct stm32_dma3_hwdesc)))
+		goto from_dma_pool;
+
+	/* Allocate LLIs in gen_pool */
+	for (i = 0; i < count; i++) {
+		lli[i].hwdesc = gen_pool_dma_zalloc_align(ddata->gen_pool,
+							  sizeof(struct stm32_dma3_hwdesc),
+							  &lli[i].hwdesc_addr,
+							  __alignof__(struct stm32_dma3_hwdesc));
+		if (!lli[i].hwdesc)
+			goto gen_pool_free;
+	}
+
+	return 0;
+
+gen_pool_free:
+	while (--i >= 0)
+		stm32_dma3_lli_pool_dma_free(ddata, lli[i]);
+
+from_dma_pool:
+	if (ddata->gen_pool)
+		dev_dbg(ddata->dma_dev.dev, "gen_pool not usable, use dma_pool as fallback\n");
+
+	/* Allocate LLIs in dma_pool */
+	for (i = 0; i < count; i++) {
+		lli[i].hwdesc = dma_pool_zalloc(ddata->dma_pool, GFP_NOWAIT, &lli[i].hwdesc_addr);
+		if (!lli[i].hwdesc)
+			goto err_pool_free;
+	}
+
+	return 0;
+
+err_pool_free:
+	while (--i >= 0)
+		stm32_dma3_lli_pool_dma_free(ddata, lli[i]);
+
+	return -ENOMEM;
+}
+
+static struct stm32_dma3_swdesc *stm32_dma3_chan_desc_alloc(struct stm32_dma3_chan *chan, u32 count)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct stm32_dma3_swdesc *swdesc;
+	int ret;
+
+	/*
+	 * If the memory to be allocated for the number of hwdesc (6 u32 members but 32-bytes
+	 * aligned) is greater than the maximum address of CLLR_LA, then the last items can't be
+	 * addressed, so abort the allocation.
+	 */
+	if ((count * 32) > CLLR_LA) {
+		dev_err(chan2dev(chan), "Transfer is too big (> %luB)\n", STM32_DMA3_MAX_SEG_SIZE);
+		return NULL;
+	}
+
+	swdesc = kzalloc(struct_size(swdesc, lli, count), GFP_NOWAIT);
+	if (!swdesc)
+		return NULL;
+
+	/* Allocate all LLIs in the same pool so that the LL base address is the same */
+	ret = stm32_dma3_lli_pool_dma_alloc(ddata, swdesc->lli, count);
+	if (ret) {
+		dev_err(chan2dev(chan), "Failed to alloc descriptors\n");
+		kfree(swdesc);
+		return NULL;
+	}
+	swdesc->lli_size = count;
+
+	/* Set LL base address */
+	writel_relaxed(swdesc->lli[0].hwdesc_addr & CLBAR_LBA,
+		       ddata->base + STM32_DMA3_CLBAR(chan->id));
+
+	/* Set LL allocated port */
+	swdesc->ccr = FIELD_PREP(CCR_LAP, ddata->lap);
+
+	return swdesc;
+}
+
+static void stm32_dma3_chan_desc_free(struct stm32_dma3_chan *chan,
+				      struct stm32_dma3_swdesc *swdesc)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	int i;
+
+	for (i = 0; i < swdesc->lli_size; i++)
+		stm32_dma3_lli_pool_dma_free(ddata, swdesc->lli[i]);
+
+	kfree(swdesc);
+}
+
+static void stm32_dma3_chan_vdesc_free(struct virt_dma_desc *vdesc)
+{
+	struct stm32_dma3_swdesc *swdesc = to_stm32_dma3_swdesc(vdesc);
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(vdesc->tx.chan);
+
+	stm32_dma3_chan_desc_free(chan, swdesc);
+}
+
+static void stm32_dma3_check_user_setting(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct device *dev = chan2dev(chan);
+	u32 ctr1 = readl_relaxed(ddata->base + STM32_DMA3_CTR1(chan->id));
+	u32 cbr1 = readl_relaxed(ddata->base + STM32_DMA3_CBR1(chan->id));
+	u32 csar = readl_relaxed(ddata->base + STM32_DMA3_CSAR(chan->id));
+	u32 cdar = readl_relaxed(ddata->base + STM32_DMA3_CDAR(chan->id));
+	u32 cllr = readl_relaxed(ddata->base + STM32_DMA3_CLLR(chan->id));
+	u32 bndt = FIELD_GET(CBR1_BNDT, cbr1);
+	u32 sdw = 1 << FIELD_GET(CTR1_SDW_LOG2, ctr1);
+	u32 ddw = 1 << FIELD_GET(CTR1_DDW_LOG2, ctr1);
+	u32 sap = FIELD_GET(CTR1_SAP, ctr1);
+	u32 dap = FIELD_GET(CTR1_DAP, ctr1);
+
+	if (!bndt && !FIELD_GET(CLLR_UB1, cllr))
+		dev_err(dev, "null source block size and no update of this value\n");
+	if (bndt % sdw)
+		dev_err(dev, "source block size not multiple of src data width\n");
+	if (FIELD_GET(CTR1_PAM, ctr1) == CTR1_PAM_PACK_UNPACK && bndt % ddw)
+		dev_err(dev, "(un)packing mode w/ src block size not multiple of dst data width\n");
+	if (csar % sdw)
+		dev_err(dev, "unaligned source address not multiple of src data width\n");
+	if (cdar % ddw)
+		dev_err(dev, "unaligned destination address not multiple of dst data width\n");
+	if (sdw == DMA_SLAVE_BUSWIDTH_8_BYTES && port_is_ahb(ddata->ports_max_dw[sap]))
+		dev_err(dev, "double-word source data width not supported on port %u\n", sap);
+	if (ddw == DMA_SLAVE_BUSWIDTH_8_BYTES && port_is_ahb(ddata->ports_max_dw[dap]))
+		dev_err(dev, "double-word destination data width not supported on port %u\n", dap);
+}
+
+static void stm32_dma3_chan_prep_hwdesc(struct stm32_dma3_chan *chan,
+					struct stm32_dma3_swdesc *swdesc,
+					u32 curr, dma_addr_t src, dma_addr_t dst, u32 len,
+					u32 ctr1, u32 ctr2, bool is_last, bool is_cyclic)
+{
+	struct stm32_dma3_hwdesc *hwdesc;
+	dma_addr_t next_lli;
+	u32 next = curr + 1;
+
+	hwdesc = swdesc->lli[curr].hwdesc;
+	hwdesc->ctr1 = ctr1;
+	hwdesc->ctr2 = ctr2;
+	hwdesc->cbr1 = FIELD_PREP(CBR1_BNDT, len);
+	hwdesc->csar = src;
+	hwdesc->cdar = dst;
+
+	if (is_last) {
+		if (is_cyclic)
+			next_lli = swdesc->lli[0].hwdesc_addr;
+		else
+			next_lli = 0;
+	} else {
+		next_lli = swdesc->lli[next].hwdesc_addr;
+	}
+
+	hwdesc->cllr = 0;
+	if (next_lli) {
+		hwdesc->cllr |= CLLR_UT1 | CLLR_UT2 | CLLR_UB1;
+		hwdesc->cllr |= CLLR_USA | CLLR_UDA | CLLR_ULL;
+		hwdesc->cllr |= (next_lli & CLLR_LA);
+	}
+}
+
+static enum dma_slave_buswidth stm32_dma3_get_max_dw(u32 chan_max_burst,
+						     enum stm32_dma3_port_data_width port_max_dw,
+						     u32 len, dma_addr_t addr)
+{
+	enum dma_slave_buswidth max_dw = get_chan_max_dw(port_max_dw, chan_max_burst);
+
+	/* len and addr must be a multiple of dw */
+	return 1 << __ffs(len | addr | max_dw);
+}
+
+static u32 stm32_dma3_get_max_burst(u32 len, enum dma_slave_buswidth dw,
+				    u32 chan_max_burst, u32 bus_max_burst)
+{
+	u32 max_burst = chan_max_burst ? chan_max_burst / dw : 1;
+
+	/* len is a multiple of dw, so if len is < chan_max_burst, shorten burst */
+	if (len < chan_max_burst)
+		max_burst = len / dw;
+
+	/*
+	 * HW doesn't modify the burst if burst size <= half of the fifo size.
+	 * If len is not a multiple of burst size, last burst is shortened by HW.
+	 * Take care of maximum burst supported on interconnect bus.
+	 */
+	return min_t(u32, max_burst, bus_max_burst);
+}
+
+static int stm32_dma3_chan_prep_hw(struct stm32_dma3_chan *chan, enum dma_transfer_direction dir,
+				   u32 *ccr, u32 *ctr1, u32 *ctr2,
+				   dma_addr_t src_addr, dma_addr_t dst_addr, u32 len)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct dma_device dma_device = ddata->dma_dev;
+	u32 src_max_burst = STM32_DMA3_MAX_BURST_LEN, dst_max_burst = STM32_DMA3_MAX_BURST_LEN;
+	u32 sdw, ddw, sbl_max, dbl_max, tcem, init_dw, init_bl_max;
+	u32 _ctr1 = 0, _ctr2 = 0;
+	u32 ch_conf = chan->dt_config.ch_conf;
+	u32 tr_conf = chan->dt_config.tr_conf;
+	u32 sap = FIELD_GET(STM32_DMA3_DT_SAP, tr_conf), sap_max_dw;
+	u32 dap = FIELD_GET(STM32_DMA3_DT_DAP, tr_conf), dap_max_dw;
+
+	dev_dbg(chan2dev(chan), "%s from %pad to %pad\n",
+		dmaengine_get_direction_text(dir), &src_addr, &dst_addr);
+
+	sdw = chan->dma_config.src_addr_width ? : get_chan_max_dw(sap, chan->max_burst);
+	ddw = chan->dma_config.dst_addr_width ? : get_chan_max_dw(dap, chan->max_burst);
+	sbl_max = chan->dma_config.src_maxburst ? : 1;
+	dbl_max = chan->dma_config.dst_maxburst ? : 1;
+
+	/* Following conditions would raise User Setting Error interrupt */
+	if (!(dma_device.src_addr_widths & BIT(sdw)) || !(dma_device.dst_addr_widths & BIT(ddw))) {
+		dev_err(chan2dev(chan), "Bus width (src=%u, dst=%u) not supported\n", sdw, ddw);
+		return -EINVAL;
+	}
+
+	if (ddata->ports_max_dw[1] == DW_INVALID && (sap || dap)) {
+		dev_err(chan2dev(chan), "Only one master port, port 1 is not supported\n");
+		return -EINVAL;
+	}
+
+	sap_max_dw = ddata->ports_max_dw[sap];
+	dap_max_dw = ddata->ports_max_dw[dap];
+	if ((port_is_ahb(sap_max_dw) && sdw == DMA_SLAVE_BUSWIDTH_8_BYTES) ||
+	    (port_is_ahb(dap_max_dw) && ddw == DMA_SLAVE_BUSWIDTH_8_BYTES)) {
+		dev_err(chan2dev(chan),
+			"8 bytes buswidth (src=%u, dst=%u) not supported on port (sap=%u, dap=%u\n",
+			sdw, ddw, sap, dap);
+		return -EINVAL;
+	}
+
+	if (FIELD_GET(STM32_DMA3_DT_SINC, tr_conf))
+		_ctr1 |= CTR1_SINC;
+	if (sap)
+		_ctr1 |= CTR1_SAP;
+	if (port_is_axi(sap_max_dw)) /* AXI - apply axi maximum burst limitation */
+		src_max_burst = ddata->axi_max_burst_len;
+	if (FIELD_GET(STM32_DMA3_DT_DINC, tr_conf))
+		_ctr1 |= CTR1_DINC;
+	if (dap)
+		_ctr1 |= CTR1_DAP;
+	if (port_is_axi(dap_max_dw)) /* AXI - apply axi maximum burst limitation */
+		dst_max_burst = ddata->axi_max_burst_len;
+
+	_ctr2 |= FIELD_PREP(CTR2_REQSEL, chan->dt_config.req_line) & ~CTR2_SWREQ;
+	if (FIELD_GET(STM32_DMA3_DT_BREQ, tr_conf))
+		_ctr2 |= CTR2_BREQ;
+	if (dir == DMA_DEV_TO_MEM && FIELD_GET(STM32_DMA3_DT_PFREQ, tr_conf))
+		_ctr2 |= CTR2_PFREQ;
+	tcem = FIELD_GET(STM32_DMA3_DT_TCEM, tr_conf);
+	_ctr2 |= FIELD_PREP(CTR2_TCEM, tcem);
+
+	/* Store TCEM to know on which event TC flag occurred */
+	chan->tcem = tcem;
+	/* Store direction for residue computation */
+	chan->dma_config.direction = dir;
+
+	switch (dir) {
+	case DMA_MEM_TO_DEV:
+		/* Set destination (device) data width and burst */
+		ddw = min_t(u32, ddw, stm32_dma3_get_max_dw(chan->max_burst, dap_max_dw,
+							    len, dst_addr));
+		dbl_max = min_t(u32, dbl_max, stm32_dma3_get_max_burst(len, ddw, chan->max_burst,
+								       dst_max_burst));
+
+		/* Set source (memory) data width and burst */
+		sdw = stm32_dma3_get_max_dw(chan->max_burst, sap_max_dw, len, src_addr);
+		sbl_max = stm32_dma3_get_max_burst(len, sdw, chan->max_burst, src_max_burst);
+		if (!!FIELD_GET(STM32_DMA3_DT_NOPACK, tr_conf)) {
+			sdw = ddw;
+			sbl_max = dbl_max;
+		}
+
+		_ctr1 |= FIELD_PREP(CTR1_SDW_LOG2, ilog2(sdw));
+		_ctr1 |= FIELD_PREP(CTR1_SBL_1, sbl_max - 1);
+		_ctr1 |= FIELD_PREP(CTR1_DDW_LOG2, ilog2(ddw));
+		_ctr1 |= FIELD_PREP(CTR1_DBL_1, dbl_max - 1);
+
+		if (ddw != sdw) {
+			_ctr1 |= FIELD_PREP(CTR1_PAM, CTR1_PAM_PACK_UNPACK);
+			/* Should never reach this case as ddw is clamped down */
+			if (len & (ddw - 1)) {
+				dev_err(chan2dev(chan),
+					"Packing mode is enabled and len is not multiple of ddw");
+				return -EINVAL;
+			}
+		}
+
+		/* dst = dev */
+		_ctr2 |= CTR2_DREQ;
+
+		break;
+
+	case DMA_DEV_TO_MEM:
+		/* Set source (device) data width and burst */
+		sdw = min_t(u32, sdw, stm32_dma3_get_max_dw(chan->max_burst, sap_max_dw,
+							    len, src_addr));
+		sbl_max = min_t(u32, sbl_max, stm32_dma3_get_max_burst(len, sdw, chan->max_burst,
+								       src_max_burst));
+
+		/* Set destination (memory) data width and burst */
+		ddw = stm32_dma3_get_max_dw(chan->max_burst, dap_max_dw, len, dst_addr);
+		dbl_max = stm32_dma3_get_max_burst(len, ddw, chan->max_burst, dst_max_burst);
+		if (!!FIELD_GET(STM32_DMA3_DT_NOPACK, tr_conf) ||
+		    ((_ctr2 & CTR2_PFREQ) && ddw > sdw)) { /* Packing to wider ddw not supported */
+			ddw = sdw;
+			dbl_max = sbl_max;
+		}
+
+		_ctr1 |= FIELD_PREP(CTR1_SDW_LOG2, ilog2(sdw));
+		_ctr1 |= FIELD_PREP(CTR1_SBL_1, sbl_max - 1);
+		_ctr1 |= FIELD_PREP(CTR1_DDW_LOG2, ilog2(ddw));
+		_ctr1 |= FIELD_PREP(CTR1_DBL_1, dbl_max - 1);
+
+		if (ddw != sdw) {
+			_ctr1 |= FIELD_PREP(CTR1_PAM, CTR1_PAM_PACK_UNPACK);
+			/* Should never reach this case as ddw is clamped down */
+			if (len & (ddw - 1)) {
+				dev_err(chan2dev(chan),
+					"Packing mode is enabled and len is not multiple of ddw\n");
+				return -EINVAL;
+			}
+		}
+
+		/* dst = mem */
+		_ctr2 &= ~CTR2_DREQ;
+
+		break;
+
+	case DMA_MEM_TO_MEM:
+		/* Set source (memory) data width and burst */
+		init_dw = sdw;
+		init_bl_max = sbl_max;
+		sdw = stm32_dma3_get_max_dw(chan->max_burst, sap_max_dw, len, src_addr);
+		sbl_max = stm32_dma3_get_max_burst(len, sdw, chan->max_burst, src_max_burst);
+		if (chan->config_set & STM32_DMA3_CFG_SET_DMA) {
+			sdw = min_t(u32, init_dw, sdw);
+			sbl_max = min_t(u32, init_bl_max, stm32_dma3_get_max_burst(len, sdw,
+										   chan->max_burst,
+										   src_max_burst));
+		}
+
+		/* Set destination (memory) data width and burst */
+		init_dw = ddw;
+		init_bl_max = dbl_max;
+		ddw = stm32_dma3_get_max_dw(chan->max_burst, dap_max_dw, len, dst_addr);
+		dbl_max = stm32_dma3_get_max_burst(len, ddw, chan->max_burst, dst_max_burst);
+		if (chan->config_set & STM32_DMA3_CFG_SET_DMA) {
+			ddw = min_t(u32, init_dw, ddw);
+			dbl_max = min_t(u32, init_bl_max, stm32_dma3_get_max_burst(len, ddw,
+										   chan->max_burst,
+										   dst_max_burst));
+		}
+
+		_ctr1 |= FIELD_PREP(CTR1_SDW_LOG2, ilog2(sdw));
+		_ctr1 |= FIELD_PREP(CTR1_SBL_1, sbl_max - 1);
+		_ctr1 |= FIELD_PREP(CTR1_DDW_LOG2, ilog2(ddw));
+		_ctr1 |= FIELD_PREP(CTR1_DBL_1, dbl_max - 1);
+
+		if (ddw != sdw) {
+			_ctr1 |= FIELD_PREP(CTR1_PAM, CTR1_PAM_PACK_UNPACK);
+			/* Should never reach this case as ddw is clamped down */
+			if (len & (ddw - 1)) {
+				dev_err(chan2dev(chan),
+					"Packing mode is enabled and len is not multiple of ddw");
+				return -EINVAL;
+			}
+		}
+
+		/* CTR2_REQSEL/DREQ/BREQ/PFREQ are ignored with CTR2_SWREQ=1 */
+		_ctr2 |= CTR2_SWREQ;
+
+		break;
+
+	default:
+		dev_err(chan2dev(chan), "Direction %s not supported\n",
+			dmaengine_get_direction_text(dir));
+		return -EINVAL;
+	}
+
+	*ccr |= FIELD_PREP(CCR_PRIO, FIELD_GET(STM32_DMA3_DT_PRIO, ch_conf));
+	*ctr1 = _ctr1;
+	*ctr2 = _ctr2;
+
+	dev_dbg(chan2dev(chan), "%s: sdw=%u bytes sbl=%u beats ddw=%u bytes dbl=%u beats\n",
+		__func__, sdw, sbl_max, ddw, dbl_max);
+
+	return 0;
+}
+
+static void stm32_dma3_chan_start(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct virt_dma_desc *vdesc;
+	struct stm32_dma3_hwdesc *hwdesc;
+	u32 id = chan->id;
+	u32 csr, ccr;
+
+	vdesc = vchan_next_desc(&chan->vchan);
+	if (!vdesc) {
+		chan->swdesc = NULL;
+		return;
+	}
+	list_del(&vdesc->node);
+
+	chan->swdesc = to_stm32_dma3_swdesc(vdesc);
+	hwdesc = chan->swdesc->lli[0].hwdesc;
+
+	stm32_dma3_chan_dump_hwdesc(chan, chan->swdesc);
+
+	writel_relaxed(chan->swdesc->ccr, ddata->base + STM32_DMA3_CCR(id));
+	writel_relaxed(hwdesc->ctr1, ddata->base + STM32_DMA3_CTR1(id));
+	writel_relaxed(hwdesc->ctr2, ddata->base + STM32_DMA3_CTR2(id));
+	writel_relaxed(hwdesc->cbr1, ddata->base + STM32_DMA3_CBR1(id));
+	writel_relaxed(hwdesc->csar, ddata->base + STM32_DMA3_CSAR(id));
+	writel_relaxed(hwdesc->cdar, ddata->base + STM32_DMA3_CDAR(id));
+	writel_relaxed(hwdesc->cllr, ddata->base + STM32_DMA3_CLLR(id));
+
+	/* Clear any pending interrupts */
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(id));
+	if (csr & CSR_ALL_F)
+		writel_relaxed(csr, ddata->base + STM32_DMA3_CFCR(id));
+
+	stm32_dma3_chan_dump_reg(chan);
+
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(id));
+	writel_relaxed(ccr | CCR_EN, ddata->base + STM32_DMA3_CCR(id));
+
+	chan->dma_status = DMA_IN_PROGRESS;
+
+	dev_dbg(chan2dev(chan), "vchan %pK: started\n", &chan->vchan);
+}
+
+static int stm32_dma3_chan_suspend(struct stm32_dma3_chan *chan, bool susp)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	u32 csr, ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id)) & ~CCR_EN;
+	int ret = 0;
+
+	if (susp)
+		ccr |= CCR_SUSP;
+	else
+		ccr &= ~CCR_SUSP;
+
+	writel_relaxed(ccr, ddata->base + STM32_DMA3_CCR(chan->id));
+
+	if (susp) {
+		ret = readl_relaxed_poll_timeout_atomic(ddata->base + STM32_DMA3_CSR(chan->id), csr,
+							csr & CSR_SUSPF, 1, 10);
+		if (!ret)
+			writel_relaxed(CFCR_SUSPF, ddata->base + STM32_DMA3_CFCR(chan->id));
+
+		stm32_dma3_chan_dump_reg(chan);
+	}
+
+	return ret;
+}
+
+static void stm32_dma3_chan_reset(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	u32 ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id)) & ~CCR_EN;
+
+	writel_relaxed(ccr |= CCR_RESET, ddata->base + STM32_DMA3_CCR(chan->id));
+}
+
+static int stm32_dma3_chan_get_curr_hwdesc(struct stm32_dma3_swdesc *swdesc, u32 cllr, u32 *residue)
+{
+	u32 i, lli_offset, next_lli_offset = cllr & CLLR_LA;
+
+	/* If cllr is null, it means it is either the last or single item */
+	if (!cllr)
+		return swdesc->lli_size - 1;
+
+	/* In cyclic mode, go fast and first check we are not on the last item */
+	if (swdesc->cyclic && next_lli_offset == (swdesc->lli[0].hwdesc_addr & CLLR_LA))
+		return swdesc->lli_size - 1;
+
+	/* As transfer is in progress, look backward from the last item */
+	for (i = swdesc->lli_size - 1; i > 0; i--) {
+		*residue += FIELD_GET(CBR1_BNDT, swdesc->lli[i].hwdesc->cbr1);
+		lli_offset = swdesc->lli[i].hwdesc_addr & CLLR_LA;
+		if (lli_offset == next_lli_offset)
+			return i - 1;
+	}
+
+	return -EINVAL;
+}
+
+static void stm32_dma3_chan_set_residue(struct stm32_dma3_chan *chan,
+					struct stm32_dma3_swdesc *swdesc,
+					struct dma_tx_state *txstate)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct device *dev = chan2dev(chan);
+	struct stm32_dma3_hwdesc *hwdesc;
+	u32 residue, curr_lli, csr, cdar, cbr1, cllr, bndt, fifol;
+	bool pack_unpack;
+	int ret;
+
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(chan->id));
+	if (!(csr & CSR_IDLEF) && chan->dma_status != DMA_PAUSED) {
+		/* Suspend current transfer to read registers for a snapshot */
+		writel_relaxed(swdesc->ccr | CCR_SUSP, ddata->base + STM32_DMA3_CCR(chan->id));
+		ret = readl_relaxed_poll_timeout_atomic(ddata->base + STM32_DMA3_CSR(chan->id), csr,
+							csr & (CSR_SUSPF | CSR_IDLEF), 1, 10);
+
+		if (ret || ((csr & CSR_TCF) && (csr & CSR_IDLEF))) {
+			writel_relaxed(CFCR_SUSPF, ddata->base + STM32_DMA3_CFCR(chan->id));
+			writel_relaxed(swdesc->ccr, ddata->base + STM32_DMA3_CCR(chan->id));
+			if (ret)
+				dev_err(dev, "Channel suspension timeout, csr=%08x\n", csr);
+		}
+	}
+
+	/* If channel is still active (CSR_IDLEF is not set), can't get a reliable residue */
+	if (!(csr & CSR_IDLEF))
+		dev_warn(dev, "Can't get residue: channel still active, csr=%08x\n", csr);
+
+	/*
+	 * If channel is not suspended, but Idle and Transfer Complete are set,
+	 * linked-list is over, no residue
+	 */
+	if (!(csr & CSR_SUSPF) && (csr & CSR_TCF) && (csr & CSR_IDLEF))
+		return;
+
+	/* Read registers to have a snapshot */
+	cllr = readl_relaxed(ddata->base + STM32_DMA3_CLLR(chan->id));
+	cbr1 = readl_relaxed(ddata->base + STM32_DMA3_CBR1(chan->id));
+	cdar = readl_relaxed(ddata->base + STM32_DMA3_CDAR(chan->id));
+
+	/* Resume current transfer */
+	if (csr & CSR_SUSPF) {
+		writel_relaxed(CFCR_SUSPF, ddata->base + STM32_DMA3_CFCR(chan->id));
+		writel_relaxed(swdesc->ccr, ddata->base + STM32_DMA3_CCR(chan->id));
+	}
+
+	/* Add current BNDT */
+	bndt = FIELD_GET(CBR1_BNDT, cbr1);
+	residue = bndt;
+
+	/* Get current hwdesc and cumulate residue of pending hwdesc BNDT */
+	ret = stm32_dma3_chan_get_curr_hwdesc(swdesc, cllr, &residue);
+	if (ret < 0) {
+		dev_err(chan2dev(chan), "Can't get residue: current hwdesc not found\n");
+		return;
+	}
+	curr_lli = ret;
+
+	/* Read current FIFO level - in units of programmed destination data width */
+	hwdesc = swdesc->lli[curr_lli].hwdesc;
+	fifol = FIELD_GET(CSR_FIFOL, csr) * (1 << FIELD_GET(CTR1_DDW_LOG2, hwdesc->ctr1));
+	/* If the FIFO contains as many bytes as its size, it can't contain more */
+	if (fifol == (1 << (chan->fifo_size + 1)))
+		goto skip_fifol_update;
+
+	/*
+	 * In case of PACKING (Destination burst length > Source burst length) or UNPACKING
+	 * (Source burst length > Destination burst length), bytes could be pending in the FIFO
+	 * (to be packed up to Destination burst length or unpacked into Destination burst length
+	 * chunks).
+	 * BNDT is not reliable, as it reflects the number of bytes read from the source but not the
+	 * number of bytes written to the destination.
+	 * FIFOL is also not sufficient, because it reflects the number of available write beats in
+	 * units of Destination data width but not the bytes not yet packed or unpacked.
+	 * In case of Destination increment DINC, it is possible to compute the number of bytes in
+	 * the FIFO:
+	 * fifol_in_bytes = bytes_read - bytes_written.
+	 */
+	pack_unpack = !!(FIELD_GET(CTR1_PAM, hwdesc->ctr1) == CTR1_PAM_PACK_UNPACK);
+	if (pack_unpack && (hwdesc->ctr1 & CTR1_DINC)) {
+		int bytes_read = FIELD_GET(CBR1_BNDT, hwdesc->cbr1) - bndt;
+		int bytes_written = cdar - hwdesc->cdar;
+
+		if (bytes_read > 0)
+			fifol = bytes_read - bytes_written;
+	}
+
+skip_fifol_update:
+	if (fifol) {
+		dev_dbg(chan2dev(chan), "%u byte(s) in the FIFO\n", fifol);
+		dma_set_in_flight_bytes(txstate, fifol);
+		/*
+		 * Residue is already accurate for DMA_MEM_TO_DEV as BNDT reflects data read from
+		 * the source memory buffer, so just need to add fifol to residue in case of
+		 * DMA_DEV_TO_MEM transfer because these bytes are not yet written in destination
+		 * memory buffer.
+		 */
+		if (chan->dma_config.direction == DMA_DEV_TO_MEM)
+			residue += fifol;
+	}
+	dma_set_residue(txstate, residue);
+}
+
+static int stm32_dma3_chan_stop(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	u32 ccr;
+	int ret = 0;
+
+	chan->dma_status = DMA_COMPLETE;
+
+	/* Disable interrupts */
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id));
+	writel_relaxed(ccr & ~(CCR_ALLIE | CCR_EN), ddata->base + STM32_DMA3_CCR(chan->id));
+
+	if (!(ccr & CCR_SUSP) && (ccr & CCR_EN)) {
+		/* Suspend the channel */
+		ret = stm32_dma3_chan_suspend(chan, true);
+		if (ret)
+			dev_warn(chan2dev(chan), "%s: timeout, data might be lost\n", __func__);
+	}
+
+	/*
+	 * Reset the channel: this causes the reset of the FIFO and the reset of the channel
+	 * internal state, the reset of CCR_EN and CCR_SUSP bits.
+	 */
+	stm32_dma3_chan_reset(chan);
+
+	return ret;
+}
+
+static void stm32_dma3_chan_complete(struct stm32_dma3_chan *chan)
+{
+	if (!chan->swdesc)
+		return;
+
+	vchan_cookie_complete(&chan->swdesc->vdesc);
+	chan->swdesc = NULL;
+	stm32_dma3_chan_start(chan);
+}
+
+static irqreturn_t stm32_dma3_chan_irq(int irq, void *devid)
+{
+	struct stm32_dma3_chan *chan = devid;
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	u32 misr, csr, ccr;
+
+	spin_lock(&chan->vchan.lock);
+
+	misr = readl_relaxed(ddata->base + STM32_DMA3_MISR);
+	if (!(misr & MISR_MIS(chan->id))) {
+		spin_unlock(&chan->vchan.lock);
+		return IRQ_NONE;
+	}
+
+	csr = readl_relaxed(ddata->base + STM32_DMA3_CSR(chan->id));
+	ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id)) & CCR_ALLIE;
+
+	if (csr & CSR_TCF && ccr & CCR_TCIE) {
+		if (chan->swdesc->cyclic)
+			vchan_cyclic_callback(&chan->swdesc->vdesc);
+		else
+			stm32_dma3_chan_complete(chan);
+	}
+
+	if (csr & CSR_USEF && ccr & CCR_USEIE) {
+		dev_err(chan2dev(chan), "User setting error\n");
+		chan->dma_status = DMA_ERROR;
+		/* CCR.EN automatically cleared by HW */
+		stm32_dma3_check_user_setting(chan);
+		stm32_dma3_chan_reset(chan);
+	}
+
+	if (csr & CSR_ULEF && ccr & CCR_ULEIE) {
+		dev_err(chan2dev(chan), "Update link transfer error\n");
+		chan->dma_status = DMA_ERROR;
+		/* CCR.EN automatically cleared by HW */
+		stm32_dma3_chan_reset(chan);
+	}
+
+	if (csr & CSR_DTEF && ccr & CCR_DTEIE) {
+		dev_err(chan2dev(chan), "Data transfer error\n");
+		chan->dma_status = DMA_ERROR;
+		/* CCR.EN automatically cleared by HW */
+		stm32_dma3_chan_reset(chan);
+	}
+
+	/*
+	 * Half Transfer Interrupt may be disabled but Half Transfer Flag can be set,
+	 * ensure HTF flag to be cleared, with other flags.
+	 */
+	csr &= (ccr | CCR_HTIE);
+
+	if (csr)
+		writel_relaxed(csr, ddata->base + STM32_DMA3_CFCR(chan->id));
+
+	spin_unlock(&chan->vchan.lock);
+
+	return IRQ_HANDLED;
+}
+
+static int stm32_dma3_get_chan_sem(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	u32 csemcr, ccid;
+
+	/* Check if channel is not already under CID1 control */
+	csemcr = readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(chan->id));
+	ccid = FIELD_GET(CSEMCR_SEM_CCID, csemcr);
+	if (csemcr & CSEMCR_SEM_MUTEX) {
+		if (ccid == CCIDCFGR_CID1)
+			return 0;
+		goto bad_cid;
+	}
+
+	/* Make an attempt to take the channel semaphore */
+	writel_relaxed(CSEMCR_SEM_MUTEX, ddata->base + STM32_DMA3_CSEMCR(chan->id));
+	csemcr = readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(chan->id));
+	ccid = FIELD_GET(CSEMCR_SEM_CCID, csemcr);
+	if (!(csemcr & CSEMCR_SEM_MUTEX) || ccid != CCIDCFGR_CID1)
+		goto bad_cid;
+
+	chan->semaphore_taken = true;
+	dev_dbg(chan2dev(chan), "under CID1 control (semcr=0x%08x)\n", csemcr);
+
+	return 0;
+
+bad_cid:
+	chan->semaphore_taken = false;
+	dev_err(chan2dev(chan), "not under CID1 control (in-use by CID%d)\n", ccid);
+
+	return -EACCES;
+}
+
+static void stm32_dma3_put_chan_sem(struct stm32_dma3_chan *chan)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+
+	if (chan->semaphore_taken) {
+		writel_relaxed(0, ddata->base + STM32_DMA3_CSEMCR(chan->id));
+		chan->semaphore_taken = false;
+		dev_dbg(chan2dev(chan), "no more under CID1 control\n");
+	}
+}
+
+static int stm32_dma3_alloc_chan_resources(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	int ret;
+
+	ret = pm_runtime_resume_and_get(ddata->dma_dev.dev);
+	if (ret < 0)
+		return ret;
+
+	/* Ensure the channel is free */
+	if (chan->semaphore_mode &&
+	    readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(chan->id)) & CSEMCR_SEM_MUTEX) {
+		ret = -EBUSY;
+		goto err_put_sync;
+	}
+
+	/* Take the channel semaphore */
+	if (chan->semaphore_mode) {
+		ret = stm32_dma3_get_chan_sem(chan);
+		if (ret)
+			goto err_put_sync;
+	}
+
+	return 0;
+
+err_put_sync:
+	pm_runtime_put_sync(ddata->dma_dev.dev);
+
+	return ret;
+}
+
+static void stm32_dma3_free_chan_resources(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	unsigned long flags;
+
+	/* Ensure channel is in idle state */
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+	stm32_dma3_chan_stop(chan);
+	chan->swdesc = NULL;
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+	vchan_free_chan_resources(to_virt_chan(c));
+
+	/* Release the channel semaphore */
+	if (chan->semaphore_mode)
+		stm32_dma3_put_chan_sem(chan);
+
+	pm_runtime_put_sync(ddata->dma_dev.dev);
+
+	/* Reset configuration */
+	memset(&chan->dt_config, 0, sizeof(chan->dt_config));
+	memset(&chan->dma_config, 0, sizeof(chan->dma_config));
+	chan->config_set = 0;
+}
+
+static u32 stm32_dma3_get_ll_count(struct stm32_dma3_chan *chan, size_t len, bool prevent_refactor)
+{
+	u32 count;
+
+	if (prevent_refactor)
+		return DIV_ROUND_UP(len, STM32_DMA3_MAX_BLOCK_SIZE);
+
+	count = len / STM32_DMA3_MAX_BLOCK_SIZE;
+	len -= (len / STM32_DMA3_MAX_BLOCK_SIZE) * STM32_DMA3_MAX_BLOCK_SIZE;
+
+	if (len >= chan->max_burst) {
+		count += 1; /* len < STM32_DMA3_MAX_BLOCK_SIZE here, so it fits in one item */
+		len -= (len / chan->max_burst) * chan->max_burst;
+	}
+
+	/* Unaligned remainder fits in one extra item */
+	if (len > 0)
+		count += 1;
+
+	return count;
+}
+
+static void stm32_dma3_init_chan_config_for_memcpy(struct stm32_dma3_chan *chan,
+						   dma_addr_t dst, dma_addr_t src)
+{
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	u32 dw = get_chan_max_dw(ddata->ports_max_dw[0], chan->max_burst); /* port 0 by default */
+	u32 burst = chan->max_burst / dw;
+
+	/* Initialize dt_config if channel not pre-configured through DT */
+	if (!(chan->config_set & STM32_DMA3_CFG_SET_DT)) {
+		chan->dt_config.ch_conf = FIELD_PREP(STM32_DMA3_DT_PRIO, CCR_PRIO_VERY_HIGH);
+		chan->dt_config.ch_conf |= FIELD_PREP(STM32_DMA3_DT_FIFO, chan->fifo_size);
+		chan->dt_config.tr_conf = STM32_DMA3_DT_SINC | STM32_DMA3_DT_DINC;
+		chan->dt_config.tr_conf |= FIELD_PREP(STM32_DMA3_DT_TCEM, CTR2_TCEM_CHANNEL);
+	}
+
+	/* Initialize dma_config if dmaengine_slave_config() not used */
+	if (!(chan->config_set & STM32_DMA3_CFG_SET_DMA)) {
+		chan->dma_config.src_addr_width = dw;
+		chan->dma_config.dst_addr_width = dw;
+		chan->dma_config.src_maxburst = burst;
+		chan->dma_config.dst_maxburst = burst;
+		chan->dma_config.src_addr = src;
+		chan->dma_config.dst_addr = dst;
+	}
+}
+
+static struct dma_async_tx_descriptor *stm32_dma3_prep_dma_memcpy(struct dma_chan *c,
+								  dma_addr_t dst, dma_addr_t src,
+								  size_t len, unsigned long flags)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc;
+	size_t next_size, offset;
+	u32 count, i, ctr1, ctr2;
+	bool prevent_refactor = !!FIELD_GET(STM32_DMA3_DT_NOPACK, chan->dt_config.tr_conf) ||
+				!!FIELD_GET(STM32_DMA3_DT_NOREFACT, chan->dt_config.tr_conf);
+
+	/* Semaphore could be lost during suspend/resume */
+	if (chan->semaphore_mode && !chan->semaphore_taken)
+		return NULL;
+
+	count = stm32_dma3_get_ll_count(chan, len, prevent_refactor);
+
+	swdesc = stm32_dma3_chan_desc_alloc(chan, count);
+	if (!swdesc)
+		return NULL;
+
+	if (chan->config_set != STM32_DMA3_CFG_SET_BOTH)
+		stm32_dma3_init_chan_config_for_memcpy(chan, dst, src);
+
+	for (i = 0, offset = 0; offset < len; i++, offset += next_size) {
+		size_t remaining;
+		int ret;
+
+		remaining = len - offset;
+		next_size = min_t(size_t, remaining, STM32_DMA3_MAX_BLOCK_SIZE);
+
+		if (!prevent_refactor &&
+		    (next_size < STM32_DMA3_MAX_BLOCK_SIZE && next_size >= chan->max_burst))
+			next_size = chan->max_burst * (remaining / chan->max_burst);
+
+		ret = stm32_dma3_chan_prep_hw(chan, DMA_MEM_TO_MEM, &swdesc->ccr, &ctr1, &ctr2,
+					      src + offset, dst + offset, next_size);
+		if (ret)
+			goto err_desc_free;
+
+		stm32_dma3_chan_prep_hwdesc(chan, swdesc, i, src + offset, dst + offset, next_size,
+					    ctr1, ctr2, next_size == remaining, false);
+	}
+
+	/* Enable Errors interrupts */
+	swdesc->ccr |= CCR_USEIE | CCR_ULEIE | CCR_DTEIE;
+	/* Enable Transfer state interrupts */
+	swdesc->ccr |= CCR_TCIE;
+
+	swdesc->cyclic = false;
+
+	return vchan_tx_prep(&chan->vchan, &swdesc->vdesc, flags);
+
+err_desc_free:
+	stm32_dma3_chan_desc_free(chan, swdesc);
+
+	return NULL;
+}
+
+static struct dma_async_tx_descriptor *stm32_dma3_prep_slave_sg(struct dma_chan *c,
+								struct scatterlist *sgl,
+								unsigned int sg_len,
+								enum dma_transfer_direction dir,
+								unsigned long flags, void *context)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc;
+	struct scatterlist *sg;
+	size_t len;
+	dma_addr_t sg_addr, dev_addr, src, dst;
+	u32 i, j, count, ctr1, ctr2;
+	bool prevent_refactor = !!FIELD_GET(STM32_DMA3_DT_NOPACK, chan->dt_config.tr_conf) ||
+				!!FIELD_GET(STM32_DMA3_DT_NOREFACT, chan->dt_config.tr_conf);
+	int ret;
+
+	/* Semaphore could be lost during suspend/resume */
+	if (chan->semaphore_mode && !chan->semaphore_taken)
+		return NULL;
+
+	count = 0;
+	for_each_sg(sgl, sg, sg_len, i)
+		count += stm32_dma3_get_ll_count(chan, sg_dma_len(sg), prevent_refactor);
+
+	swdesc = stm32_dma3_chan_desc_alloc(chan, count);
+	if (!swdesc)
+		return NULL;
+
+	/* sg_len and i correspond to the initial sgl; count and j correspond to the hwdesc LL */
+	j = 0;
+	for_each_sg(sgl, sg, sg_len, i) {
+		sg_addr = sg_dma_address(sg);
+		dev_addr = (dir == DMA_MEM_TO_DEV) ? chan->dma_config.dst_addr :
+						     chan->dma_config.src_addr;
+		len = sg_dma_len(sg);
+
+		do {
+			size_t chunk = min_t(size_t, len, STM32_DMA3_MAX_BLOCK_SIZE);
+
+			if (!prevent_refactor &&
+			    (chunk < STM32_DMA3_MAX_BLOCK_SIZE && chunk >= chan->max_burst))
+				chunk = chan->max_burst * (len / chan->max_burst);
+
+			if (dir == DMA_MEM_TO_DEV) {
+				src = sg_addr;
+				dst = dev_addr;
+
+				ret = stm32_dma3_chan_prep_hw(chan, dir, &swdesc->ccr, &ctr1, &ctr2,
+							      src, dst, chunk);
+
+				if (FIELD_GET(CTR1_DINC, ctr1))
+					dev_addr += chunk;
+			} else { /* (dir == DMA_DEV_TO_MEM || dir == DMA_MEM_TO_MEM) */
+				src = dev_addr;
+				dst = sg_addr;
+
+				ret = stm32_dma3_chan_prep_hw(chan, dir, &swdesc->ccr, &ctr1, &ctr2,
+							      src, dst, chunk);
+
+				if (FIELD_GET(CTR1_SINC, ctr1))
+					dev_addr += chunk;
+			}
+
+			if (ret)
+				goto err_desc_free;
+
+			stm32_dma3_chan_prep_hwdesc(chan, swdesc, j, src, dst, chunk,
+						    ctr1, ctr2, j == (count - 1), false);
+
+			sg_addr += chunk;
+			len -= chunk;
+			j++;
+		} while (len);
+	}
+
+	if (count != sg_len && chan->tcem != CTR2_TCEM_CHANNEL)
+		dev_warn(chan2dev(chan), "Linked-list refactored, %d items instead of %d\n",
+			 count, sg_len);
+
+	/* Enable Error interrupts */
+	swdesc->ccr |= CCR_USEIE | CCR_ULEIE | CCR_DTEIE;
+	/* Enable Transfer state interrupts */
+	swdesc->ccr |= CCR_TCIE;
+
+	swdesc->cyclic = false;
+
+	return vchan_tx_prep(&chan->vchan, &swdesc->vdesc, flags);
+
+err_desc_free:
+	stm32_dma3_chan_desc_free(chan, swdesc);
+
+	return NULL;
+}
+
+static struct dma_async_tx_descriptor *stm32_dma3_prep_dma_cyclic(struct dma_chan *c,
+								  dma_addr_t buf_addr,
+								  size_t buf_len, size_t period_len,
+								  enum dma_transfer_direction dir,
+								  unsigned long flags)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc;
+	dma_addr_t src, dst;
+	u32 count, i, ctr1, ctr2;
+	int ret;
+
+	/* Semaphore could be lost during suspend/resume */
+	if (chan->semaphore_mode && !chan->semaphore_taken)
+		return NULL;
+
+	if (!buf_len || !period_len || period_len > STM32_DMA3_MAX_BLOCK_SIZE) {
+		dev_err(chan2dev(chan), "Invalid buffer/period length\n");
+		return NULL;
+	}
+
+	if (buf_len % period_len) {
+		dev_err(chan2dev(chan), "Buffer length not multiple of period length\n");
+		return NULL;
+	}
+
+	count = buf_len / period_len;
+	swdesc = stm32_dma3_chan_desc_alloc(chan, count);
+	if (!swdesc)
+		return NULL;
+
+	if (dir == DMA_MEM_TO_DEV) {
+		src = buf_addr;
+		dst = chan->dma_config.dst_addr;
+
+		ret = stm32_dma3_chan_prep_hw(chan, DMA_MEM_TO_DEV, &swdesc->ccr, &ctr1, &ctr2,
+					      src, dst, period_len);
+	} else if (dir == DMA_DEV_TO_MEM) {
+		src = chan->dma_config.src_addr;
+		dst = buf_addr;
+
+		ret = stm32_dma3_chan_prep_hw(chan, DMA_DEV_TO_MEM, &swdesc->ccr, &ctr1, &ctr2,
+					      src, dst, period_len);
+	} else {
+		dev_err(chan2dev(chan), "Invalid direction\n");
+		ret = -EINVAL;
+	}
+
+	if (ret)
+		goto err_desc_free;
+
+	for (i = 0; i < count; i++) {
+		if (dir == DMA_MEM_TO_DEV) {
+			src = buf_addr + i * period_len;
+			dst = chan->dma_config.dst_addr;
+		} else { /* (dir == DMA_DEV_TO_MEM || dir == DMA_MEM_TO_MEM) */
+			src = chan->dma_config.src_addr;
+			dst = buf_addr + i * period_len;
+		}
+
+		stm32_dma3_chan_prep_hwdesc(chan, swdesc, i, src, dst, period_len,
+					    ctr1, ctr2, i == (count - 1), true);
+	}
+
+	/* Enable Error interrupts */
+	swdesc->ccr |= CCR_USEIE | CCR_ULEIE | CCR_DTEIE;
+	/* Enable Transfer state interrupts */
+	swdesc->ccr |= CCR_TCIE;
+
+	swdesc->cyclic = true;
+
+	return vchan_tx_prep(&chan->vchan, &swdesc->vdesc, flags);
+
+err_desc_free:
+	stm32_dma3_chan_desc_free(chan, swdesc);
+
+	return NULL;
+}
+
+static void stm32_dma3_caps(struct dma_chan *c, struct dma_slave_caps *caps)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	if (!chan->fifo_size) {
+		caps->max_burst = 0;
+		caps->src_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+		caps->dst_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+	} else {
+		/* Burst transfer should not exceed half of the fifo size */
+		caps->max_burst = chan->max_burst;
+		if (caps->max_burst < DMA_SLAVE_BUSWIDTH_8_BYTES) {
+			caps->src_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+			caps->dst_addr_widths &= ~BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+		}
+	}
+}
+
+static int stm32_dma3_config(struct dma_chan *c, struct dma_slave_config *config)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	memcpy(&chan->dma_config, config, sizeof(*config));
+	chan->config_set |= STM32_DMA3_CFG_SET_DMA;
+
+	return 0;
+}
+
+static int stm32_dma3_pause(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	int ret;
+
+	ret = stm32_dma3_chan_suspend(chan, true);
+	if (ret)
+		return ret;
+
+	chan->dma_status = DMA_PAUSED;
+
+	dev_dbg(chan2dev(chan), "vchan %pK: paused\n", &chan->vchan);
+
+	return 0;
+}
+
+static int stm32_dma3_resume(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	stm32_dma3_chan_suspend(chan, false);
+
+	chan->dma_status = DMA_IN_PROGRESS;
+
+	dev_dbg(chan2dev(chan), "vchan %pK: resumed\n", &chan->vchan);
+
+	return 0;
+}
+
+static int stm32_dma3_terminate_all(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	unsigned long flags;
+	LIST_HEAD(head);
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	if (chan->swdesc) {
+		vchan_terminate_vdesc(&chan->swdesc->vdesc);
+		chan->swdesc = NULL;
+	}
+
+	stm32_dma3_chan_stop(chan);
+
+	vchan_get_all_descriptors(&chan->vchan, &head);
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+	vchan_dma_desc_free_list(&chan->vchan, &head);
+
+	dev_dbg(chan2dev(chan), "vchan %pK: terminated\n", &chan->vchan);
+
+	return 0;
+}
+
+static void stm32_dma3_synchronize(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+	vchan_synchronize(&chan->vchan);
+}
+
+static enum dma_status stm32_dma3_tx_status(struct dma_chan *c, dma_cookie_t cookie,
+					    struct dma_tx_state *txstate)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_swdesc *swdesc = NULL;
+	enum dma_status status;
+	unsigned long flags;
+	struct virt_dma_desc *vd;
+
+	status = dma_cookie_status(c, cookie, txstate);
+	if (status == DMA_COMPLETE)
+		return status;
+
+	if (!txstate)
+		return chan->dma_status;
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	vd = vchan_find_desc(&chan->vchan, cookie);
+	if (vd)
+		swdesc = to_stm32_dma3_swdesc(vd);
+	else if (chan->swdesc && chan->swdesc->vdesc.tx.cookie == cookie)
+		swdesc = chan->swdesc;
+
+	/* Get residue/in_flight_bytes only if a transfer is currently running (swdesc != NULL) */
+	if (swdesc)
+		stm32_dma3_chan_set_residue(chan, swdesc, txstate);
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+
+	return chan->dma_status;
+}
+
+static void stm32_dma3_issue_pending(struct dma_chan *c)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->vchan.lock, flags);
+
+	if (vchan_issue_pending(&chan->vchan) && !chan->swdesc) {
+		dev_dbg(chan2dev(chan), "vchan %pK: issued\n", &chan->vchan);
+		stm32_dma3_chan_start(chan);
+	}
+
+	spin_unlock_irqrestore(&chan->vchan.lock, flags);
+}
+
+static bool stm32_dma3_filter_fn(struct dma_chan *c, void *fn_param)
+{
+	struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+	struct stm32_dma3_ddata *ddata = to_stm32_dma3_ddata(chan);
+	struct stm32_dma3_dt_conf *conf = fn_param;
+	u32 mask, semcr;
+	int ret;
+
+	dev_dbg(c->device->dev, "%s(%s): req_line=%d ch_conf=%08x tr_conf=%08x\n",
+		__func__, dma_chan_name(c), conf->req_line, conf->ch_conf, conf->tr_conf);
+
+	if (!of_property_read_u32(c->device->dev->of_node, "dma-channel-mask", &mask))
+		if (!(mask & BIT(chan->id)))
+			return false;
+
+	ret = pm_runtime_resume_and_get(ddata->dma_dev.dev);
+	if (ret < 0)
+		return false;
+	semcr = readl_relaxed(ddata->base + STM32_DMA3_CSEMCR(chan->id));
+	pm_runtime_put_sync(ddata->dma_dev.dev);
+
+	/* Check if chan is free */
+	if (semcr & CSEMCR_SEM_MUTEX)
+		return false;
+
+	/* Check if chan fifo fits well */
+	if (FIELD_GET(STM32_DMA3_DT_FIFO, conf->ch_conf) != chan->fifo_size)
+		return false;
+
+	return true;
+}
+
+static struct dma_chan *stm32_dma3_of_xlate(struct of_phandle_args *dma_spec, struct of_dma *ofdma)
+{
+	struct stm32_dma3_ddata *ddata = ofdma->of_dma_data;
+	dma_cap_mask_t mask = ddata->dma_dev.cap_mask;
+	struct stm32_dma3_dt_conf conf;
+	struct stm32_dma3_chan *chan;
+	struct dma_chan *c;
+
+	if (dma_spec->args_count < 3) {
+		dev_err(ddata->dma_dev.dev, "Invalid args count\n");
+		return NULL;
+	}
+
+	conf.req_line = dma_spec->args[0];
+	conf.ch_conf = dma_spec->args[1];
+	conf.tr_conf = dma_spec->args[2];
+
+	if (conf.req_line >= ddata->dma_requests) {
+		dev_err(ddata->dma_dev.dev, "Invalid request line\n");
+		return NULL;
+	}
+
+	/* Request dma channel among the generic dma controller list */
+	c = dma_request_channel(mask, stm32_dma3_filter_fn, &conf);
+	if (!c) {
+		dev_err(ddata->dma_dev.dev, "No suitable channel found\n");
+		return NULL;
+	}
+
+	chan = to_stm32_dma3_chan(c);
+	chan->dt_config = conf;
+	chan->config_set |= STM32_DMA3_CFG_SET_DT;
+
+	return c;
+}
+
+static u32 stm32_dma3_check_rif(struct stm32_dma3_ddata *ddata)
+{
+	u32 chan_reserved, mask = 0, i, ccidcfgr, invalid_cid = 0;
+
+	/* Reserve Secure channels */
+	chan_reserved = readl_relaxed(ddata->base + STM32_DMA3_SECCFGR);
+
+	/*
+	 * CID filtering must be configured to ensure that the DMA3 channel will inherit the CID of
+	 * the processor which is configuring and using the given channel.
+	 * In case CID filtering is not configured, dma-channel-mask property can be used to
+	 * specify available DMA channels to the kernel.
+	 */
+	of_property_read_u32(ddata->dma_dev.dev->of_node, "dma-channel-mask", &mask);
+
+	/* Reserve !CID-filtered not in dma-channel-mask, static CID != CID1, CID1 not allowed */
+	for (i = 0; i < ddata->dma_channels; i++) {
+		ccidcfgr = readl_relaxed(ddata->base + STM32_DMA3_CCIDCFGR(i));
+
+		if (!(ccidcfgr & CCIDCFGR_CFEN)) { /* !CID-filtered */
+			invalid_cid |= BIT(i);
+			if (!(mask & BIT(i))) /* Not in dma-channel-mask */
+				chan_reserved |= BIT(i);
+		} else { /* CID-filtered */
+			if (!(ccidcfgr & CCIDCFGR_SEM_EN)) { /* Static CID mode */
+				if (FIELD_GET(CCIDCFGR_SCID, ccidcfgr) != CCIDCFGR_CID1)
+					chan_reserved |= BIT(i);
+			} else { /* Semaphore mode */
+				if (!FIELD_GET(CCIDCFGR_SEM_WLIST_CID1, ccidcfgr))
+					chan_reserved |= BIT(i);
+				ddata->chans[i].semaphore_mode = true;
+			}
+		}
+		dev_dbg(ddata->dma_dev.dev, "chan%d: %s mode, %s\n", i,
+			!(ccidcfgr & CCIDCFGR_CFEN) ? "!CID-filtered" :
+			ddata->chans[i].semaphore_mode ? "Semaphore" : "Static CID",
+			(chan_reserved & BIT(i)) ? "denied" :
+			mask & BIT(i) ? "force allowed" : "allowed");
+	}
+
+	if (invalid_cid)
+		dev_warn(ddata->dma_dev.dev, "chan%*pbl have invalid CID configuration\n",
+			 ddata->dma_channels, &invalid_cid);
+
+	return chan_reserved;
+}
+
+static const struct of_device_id stm32_dma3_of_match[] = {
+	{ .compatible = "st,stm32-dma3", },
+	{ /* sentinel */},
+};
+MODULE_DEVICE_TABLE(of, stm32_dma3_of_match);
+
+static int stm32_dma3_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct stm32_dma3_ddata *ddata;
+	struct reset_control *reset;
+	struct stm32_dma3_chan *chan;
+	struct dma_device *dma_dev;
+	u32 master_ports, chan_reserved, i, verr;
+	u64 hwcfgr;
+	int ret;
+
+	ddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);
+	if (!ddata)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, ddata);
+
+	dma_dev = &ddata->dma_dev;
+
+	ddata->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ddata->base))
+		return PTR_ERR(ddata->base);
+
+	ddata->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ddata->clk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(ddata->clk), "Failed to get clk\n");
+
+	reset = devm_reset_control_get_optional(&pdev->dev, NULL);
+	if (IS_ERR(reset))
+		return dev_err_probe(&pdev->dev, PTR_ERR(reset), "Failed to get reset\n");
+
+	ret = clk_prepare_enable(ddata->clk);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "Failed to enable clk\n");
+
+	reset_control_reset(reset);
+
+	INIT_LIST_HEAD(&dma_dev->channels);
+
+	dma_cap_set(DMA_SLAVE, dma_dev->cap_mask);
+	dma_cap_set(DMA_PRIVATE, dma_dev->cap_mask);
+	dma_cap_set(DMA_CYCLIC, dma_dev->cap_mask);
+	dma_cap_set(DMA_MEMCPY, dma_dev->cap_mask);
+	dma_dev->dev = &pdev->dev;
+	/*
+	 * This controller supports up to 8-byte buswidth depending on the port used and the
+	 * channel, and can only access address at even boundaries, multiple of the buswidth.
+	 */
+	dma_dev->copy_align = DMAENGINE_ALIGN_8_BYTES;
+	dma_dev->src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+				   BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+	dma_dev->dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+				   BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) |
+				   BIT(DMA_SLAVE_BUSWIDTH_8_BYTES);
+	dma_dev->directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV) | BIT(DMA_MEM_TO_MEM);
+
+	dma_dev->descriptor_reuse = true;
+	dma_dev->max_sg_burst = STM32_DMA3_MAX_SEG_SIZE;
+	dma_dev->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+	dma_dev->device_alloc_chan_resources = stm32_dma3_alloc_chan_resources;
+	dma_dev->device_free_chan_resources = stm32_dma3_free_chan_resources;
+	dma_dev->device_prep_dma_memcpy = stm32_dma3_prep_dma_memcpy;
+	dma_dev->device_prep_slave_sg = stm32_dma3_prep_slave_sg;
+	dma_dev->device_prep_dma_cyclic = stm32_dma3_prep_dma_cyclic;
+	dma_dev->device_caps = stm32_dma3_caps;
+	dma_dev->device_config = stm32_dma3_config;
+	dma_dev->device_pause = stm32_dma3_pause;
+	dma_dev->device_resume = stm32_dma3_resume;
+	dma_dev->device_terminate_all = stm32_dma3_terminate_all;
+	dma_dev->device_synchronize = stm32_dma3_synchronize;
+	dma_dev->device_tx_status = stm32_dma3_tx_status;
+	dma_dev->device_issue_pending = stm32_dma3_issue_pending;
+
+	/* if dma_channels is not modified, get it from hwcfgr1 */
+	if (of_property_read_u32(np, "dma-channels", &ddata->dma_channels)) {
+		hwcfgr = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR1);
+		ddata->dma_channels = FIELD_GET(G_NUM_CHANNELS, hwcfgr);
+	}
+
+	/* if dma_requests is not modified, get it from hwcfgr2 */
+	if (of_property_read_u32(np, "dma-requests", &ddata->dma_requests)) {
+		hwcfgr = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR2);
+		ddata->dma_requests = FIELD_GET(G_MAX_REQ_ID, hwcfgr) + 1;
+	}
+
+	/* G_MASTER_PORTS, G_M0_DATA_WIDTH_ENC, G_M1_DATA_WIDTH_ENC in HWCFGR1 */
+	hwcfgr = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR1);
+	master_ports = FIELD_GET(G_MASTER_PORTS, hwcfgr);
+
+	ddata->ports_max_dw[0] = FIELD_GET(G_M0_DATA_WIDTH_ENC, hwcfgr);
+	if (master_ports == AXI64 || master_ports == AHB32) { /* Single master port */
+		ddata->ports_max_dw[1] = DW_INVALID;
+		ddata->lap = 0;
+	} else { /* Dual master ports */
+		ddata->ports_max_dw[1] = FIELD_GET(G_M1_DATA_WIDTH_ENC, hwcfgr);
+		/* lli-bus-interface is optional, Link Allocated Port is set to port 0 by default */
+		if (of_property_read_u32(np, "lli-bus-interface", &ddata->lap))
+			ddata->lap = 0;
+	}
+
+	/* st,axi-max-burst-len is optional, if not defined, use STM32_DMA3_MAX_BURST_LEN  */
+	if (of_property_read_u32(np, "st,axi-max-burst-len", &ddata->axi_max_burst_len))
+		ddata->axi_max_burst_len = STM32_DMA3_MAX_BURST_LEN;
+	else
+		ddata->axi_max_burst_len = min_t(u32, ddata->axi_max_burst_len,
+						 STM32_DMA3_MAX_BURST_LEN);
+	dev_dbg(&pdev->dev, "Burst is limited to %u beats\n", ddata->axi_max_burst_len);
+
+	ret = stm32_dma3_lli_pool_create(pdev, ddata);
+	if (ret)
+		goto err_clk_disable;
+
+	ddata->chans = devm_kcalloc(&pdev->dev, ddata->dma_channels, sizeof(*ddata->chans),
+				    GFP_KERNEL);
+	if (!ddata->chans) {
+		ret = -ENOMEM;
+		goto err_clk_disable;
+	}
+
+	chan_reserved = stm32_dma3_check_rif(ddata);
+
+	if (chan_reserved == GENMASK(ddata->dma_channels - 1, 0)) {
+		ret = -ENODEV;
+		dev_err_probe(&pdev->dev, ret, "No channel available, abort registration\n");
+		goto err_clk_disable;
+	}
+
+	/* G_FIFO_SIZE x=0..7 in HWCFGR3 and G_FIFO_SIZE x=8..15 in HWCFGR4 */
+	hwcfgr = readl_relaxed(ddata->base + STM32_DMA3_HWCFGR3);
+	hwcfgr |= ((u64)readl_relaxed(ddata->base + STM32_DMA3_HWCFGR4)) << 32;
+
+	for (i = 0; i < ddata->dma_channels; i++) {
+		if (chan_reserved & BIT(i))
+			continue;
+
+		chan = &ddata->chans[i];
+		chan->id = i;
+		chan->fifo_size = get_chan_hwcfg(i, G_FIFO_SIZE(i), hwcfgr);
+		/* If chan->fifo_size > 0 then half of the fifo size, else no burst when no FIFO */
+		chan->max_burst = (chan->fifo_size) ? (1 << (chan->fifo_size + 1)) / 2 : 0;
+	}
+
+	ret = dmaenginem_async_device_register(dma_dev);
+	if (ret)
+		goto err_clk_disable;
+
+	for (i = 0; i < ddata->dma_channels; i++) {
+		char name[12];
+
+		if (chan_reserved & BIT(i))
+			continue;
+
+		chan = &ddata->chans[i];
+		snprintf(name, sizeof(name), "dma%dchan%d", ddata->dma_dev.dev_id, chan->id);
+
+		chan->vchan.desc_free = stm32_dma3_chan_vdesc_free;
+		vchan_init(&chan->vchan, dma_dev);
+
+		ret = dma_async_device_channel_register(&ddata->dma_dev, &chan->vchan.chan, name);
+		if (ret) {
+			dev_err_probe(&pdev->dev, ret, "Failed to register channel %s\n", name);
+			goto err_clk_disable;
+		}
+
+		ret = platform_get_irq(pdev, i);
+		if (ret < 0)
+			goto err_clk_disable;
+		chan->irq = ret;
+
+		ret = devm_request_irq(&pdev->dev, chan->irq, stm32_dma3_chan_irq, 0,
+				       dev_name(chan2dev(chan)), chan);
+		if (ret) {
+			dev_err_probe(&pdev->dev, ret, "Failed to request channel %s IRQ\n",
+				      dev_name(chan2dev(chan)));
+			goto err_clk_disable;
+		}
+	}
+
+	ret = of_dma_controller_register(np, stm32_dma3_of_xlate, ddata);
+	if (ret) {
+		dev_err_probe(&pdev->dev, ret, "Failed to register controller\n");
+		goto err_clk_disable;
+	}
+
+	verr = readl_relaxed(ddata->base + STM32_DMA3_VERR);
+
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_put(&pdev->dev);
+
+	dev_info(&pdev->dev, "STM32 DMA3 registered rev:%lu.%lu\n",
+		 FIELD_GET(VERR_MAJREV, verr), FIELD_GET(VERR_MINREV, verr));
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(ddata->clk);
+
+	return ret;
+}
+
+static void stm32_dma3_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+}
+
+static int stm32_dma3_runtime_suspend(struct device *dev)
+{
+	struct stm32_dma3_ddata *ddata = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(ddata->clk);
+
+	return 0;
+}
+
+static int stm32_dma3_runtime_resume(struct device *dev)
+{
+	struct stm32_dma3_ddata *ddata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(ddata->clk);
+	if (ret)
+		dev_err(dev, "Failed to enable clk: %d\n", ret);
+
+	return ret;
+}
+
+static int stm32_dma3_pm_suspend(struct device *dev)
+{
+	struct stm32_dma3_ddata *ddata = dev_get_drvdata(dev);
+	struct dma_device *dma_dev = &ddata->dma_dev;
+	struct dma_chan *c;
+	int ccr, ret;
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
+	list_for_each_entry(c, &dma_dev->channels, device_node) {
+		struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+		ccr = readl_relaxed(ddata->base + STM32_DMA3_CCR(chan->id));
+		if (ccr & CCR_EN) {
+			dev_warn(dev, "Suspend is prevented: %s still in use by %s\n",
+				 dma_chan_name(c), dev_name(c->slave));
+			pm_runtime_put_sync(dev);
+			return -EBUSY;
+		}
+	}
+
+	pm_runtime_put_sync(dev);
+
+	pm_runtime_force_suspend(dev);
+
+	return 0;
+}
+
+static int stm32_dma3_pm_resume(struct device *dev)
+{
+	struct stm32_dma3_ddata *ddata = dev_get_drvdata(dev);
+	struct dma_device *dma_dev = &ddata->dma_dev;
+	struct dma_chan *c;
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0)
+		return ret;
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Channel semaphores need to be restored in case of registers reset during low power.
+	 * stm32_dma3_get_chan_sem() will prior check the semaphore status.
+	 */
+	list_for_each_entry(c, &dma_dev->channels, device_node) {
+		struct stm32_dma3_chan *chan = to_stm32_dma3_chan(c);
+
+		if (chan->semaphore_mode && chan->semaphore_taken)
+			stm32_dma3_get_chan_sem(chan);
+	}
+
+	pm_runtime_put_sync(dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_dma3_pm_ops = {
+	SYSTEM_SLEEP_PM_OPS(stm32_dma3_pm_suspend, stm32_dma3_pm_resume)
+	RUNTIME_PM_OPS(stm32_dma3_runtime_suspend, stm32_dma3_runtime_resume, NULL)
+};
+
+static struct platform_driver stm32_dma3_driver = {
+	.probe = stm32_dma3_probe,
+	.remove_new = stm32_dma3_remove,
+	.driver = {
+		.name = "stm32-dma3",
+		.of_match_table = stm32_dma3_of_match,
+		.pm = pm_ptr(&stm32_dma3_pm_ops),
+	},
+};
+
+static int __init stm32_dma3_init(void)
+{
+	return platform_driver_register(&stm32_dma3_driver);
+}
+
+subsys_initcall(stm32_dma3_init);
+
+MODULE_DESCRIPTION("STM32 DMA3 controller driver");
+MODULE_AUTHOR("Amelie Delaunay <amelie.delaunay@foss.st.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/dma/stm32-dmamux.c b/drivers/dma/stm32/stm32-dmamux.c
similarity index 100%
rename from drivers/dma/stm32-dmamux.c
rename to drivers/dma/stm32/stm32-dmamux.c
diff --git a/drivers/dma/stm32-mdma.c b/drivers/dma/stm32/stm32-mdma.c
similarity index 99%
rename from drivers/dma/stm32-mdma.c
rename to drivers/dma/stm32/stm32-mdma.c
index 65ef1f5ca..b5a1a4479 100644
--- a/drivers/dma/stm32-mdma.c
+++ b/drivers/dma/stm32/stm32-mdma.c
@@ -31,7 +31,7 @@
 #include <linux/reset.h>
 #include <linux/slab.h>
 
-#include "virt-dma.h"
+#include "../virt-dma.h"
 
 #define STM32_MDMA_GISR0		0x0000 /* MDMA Int Status Reg 1 */
 
diff --git a/drivers/firmware/arm_scmi/clock.c b/drivers/firmware/arm_scmi/clock.c
index 96060bf90..726ce3391 100644
--- a/drivers/firmware/arm_scmi/clock.c
+++ b/drivers/firmware/arm_scmi/clock.c
@@ -21,6 +21,8 @@ enum scmi_clock_protocol_cmd {
 	CLOCK_NAME_GET = 0x8,
 	CLOCK_RATE_NOTIFY = 0x9,
 	CLOCK_RATE_CHANGE_REQUESTED_NOTIFY = 0xA,
+	CLOCK_DUTY_CYCLE_GET = 0xB,
+	CLOCK_ROUND_RATE_GET = 0xC,
 };
 
 struct scmi_msg_resp_clock_protocol_attributes {
@@ -65,6 +67,11 @@ struct scmi_msg_resp_clock_describe_rates {
 })
 };
 
+struct scmi_msg_resp_get_duty_cyle {
+	__le32 num;
+	__le32 den;
+};
+
 struct scmi_clock_set_rate {
 	__le32 flags;
 #define CLOCK_SET_ASYNC		BIT(0)
@@ -324,6 +331,34 @@ scmi_clock_describe_rates_get(const struct scmi_protocol_handle *ph, u32 clk_id,
 	return ret;
 }
 
+static int
+scmi_clock_get_duty_cycle(const struct scmi_protocol_handle *ph,
+			  u32 clk_id, int *num, int *den)
+{
+	int ret;
+	struct scmi_xfer *t;
+	struct scmi_msg_resp_get_duty_cyle *resp;
+
+	ret = ph->xops->xfer_get_init(ph, CLOCK_DUTY_CYCLE_GET,
+				      sizeof(__le32), sizeof(u64), &t);
+	if (ret)
+		return ret;
+
+	resp = t->rx.buf;
+
+	put_unaligned_le32(clk_id, t->tx.buf);
+
+	ret = ph->xops->do_xfer(ph, t);
+	if (!ret) {
+		*num = resp->num;
+		*den = resp->den;
+	}
+
+	ph->xops->xfer_put(ph, t);
+
+	return ret;
+}
+
 static int
 scmi_clock_rate_get(const struct scmi_protocol_handle *ph,
 		    u32 clk_id, u64 *value)
@@ -393,6 +428,47 @@ static int scmi_clock_rate_set(const struct scmi_protocol_handle *ph,
 	return ret;
 }
 
+static int
+scmi_clock_round_rate_get(const struct scmi_protocol_handle *ph,
+			  u32 clk_id, u64 *value)
+{
+	int ret;
+	struct scmi_xfer *t;
+	struct scmi_clock_set_rate *cfg;
+	struct clock_info *ci = ph->get_priv(ph);
+	u32 flags = 0;
+
+	ret = ph->xops->xfer_get_init(ph, CLOCK_ROUND_RATE_GET,
+				      sizeof(*cfg), 0, &t);
+	if (ret)
+		return ret;
+
+	if (ci->max_async_req &&
+	    atomic_inc_return(&ci->cur_async_req) < ci->max_async_req)
+		flags |= CLOCK_SET_ASYNC;
+
+	cfg = t->tx.buf;
+	cfg->flags = cpu_to_le32(flags);
+	cfg->id = cpu_to_le32(clk_id);
+	cfg->value_low = cpu_to_le32(*value & 0xffffffff);
+	cfg->value_high = cpu_to_le32(*value >> 32);
+
+	if (flags & CLOCK_SET_ASYNC)
+		ret = ph->xops->do_xfer_with_response(ph, t);
+	else
+		ret = ph->xops->do_xfer(ph, t);
+
+	if (ci->max_async_req)
+		atomic_dec(&ci->cur_async_req);
+
+	if (!ret)
+		*value = get_unaligned_le64(t->rx.buf);
+
+	ph->xops->xfer_put(ph, t);
+
+	return ret;
+}
+
 static int
 scmi_clock_config_set(const struct scmi_protocol_handle *ph, u32 clk_id,
 		      u32 config, bool atomic)
@@ -472,6 +548,8 @@ static const struct scmi_clk_proto_ops clk_proto_ops = {
 	.disable = scmi_clock_disable,
 	.enable_atomic = scmi_clock_enable_atomic,
 	.disable_atomic = scmi_clock_disable_atomic,
+	.get_duty_cycle = scmi_clock_get_duty_cycle,
+	.round_rate_get = scmi_clock_round_rate_get,
 };
 
 static int scmi_clk_rate_notify(const struct scmi_protocol_handle *ph,
diff --git a/drivers/firmware/arm_scmi/optee.c b/drivers/firmware/arm_scmi/optee.c
index 2a7aeab40..5ffedcd35 100644
--- a/drivers/firmware/arm_scmi/optee.c
+++ b/drivers/firmware/arm_scmi/optee.c
@@ -80,8 +80,39 @@ enum scmi_optee_pta_cmd {
 	 * payload.
 	 */
 	PTA_SCMI_CMD_PROCESS_MSG_CHANNEL = 4,
+
+	/*
+	 * PTA_SCMI_CMD_OCALL2_SMT_THREAD - Allocate a thread context using
+	 * OCALL2 for processing of SMT messages.
+	 *
+	 * [in]     value[0].a: channel handle
+	 *
+	 * Use Ocall support to create a provisioned OP-TEE thread context for
+	 * the channel. Successful creation of the thread makes this command to
+	 * return with Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY.
+	 */
+	PTA_SCMI_CMD_OCALL2_SMT_THREAD = 2048,
+
+	/*
+	 * PTA_SCMI_CMD_OCALL2_MSG_THREAD - Allocate an thread context using
+	 * OCALL2 for processing of MSG messages.
+	 *
+	 * [in]     value[0].a: channel handle
+	 * [in]     memref[1]: Message buffer (MSG and SCMI payload)
+	 * [out]    memref[2]: Response buffer (MSG and SCMI payload)
+
+	 * Use Ocall support to create a provisioned OP-TEE thread context for
+	 * the channel. Successful creation of the thread makes this command to
+	 * return with Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY.
+	 */
+	PTA_SCMI_CMD_OCALL2_MSG_THREAD = 2049,
 };
 
+/* IDs defined in GPD TEE specification OP-TEE is based on */
+#define TEEC_SUCCESS			0
+#define TEEC_ERROR_GENERIC		0xffff0000
+#define TEEC_ERROR_NOT_SUPPORTED	0xffff000a
+
 /*
  * OP-TEE SCMI service capabilities bit flags (32bit)
  *
@@ -97,8 +128,105 @@ enum scmi_optee_pta_cmd {
 #define PTA_SCMI_CAPS_NONE		0
 #define PTA_SCMI_CAPS_SMT_HEADER	BIT(0)
 #define PTA_SCMI_CAPS_MSG_HEADER	BIT(1)
+/*
+ * Channel can use command PTA_SCMI_CMD_OCALL_THREAD to provision a
+ * TEE thread for SCMI message passing.
+ */
+#define PTA_SCMI_CAPS_OCALL2_THREAD	BIT(31)
+
 #define PTA_SCMI_CAPS_MASK		(PTA_SCMI_CAPS_SMT_HEADER | \
-					 PTA_SCMI_CAPS_MSG_HEADER)
+					 PTA_SCMI_CAPS_MSG_HEADER | \
+					 PTA_SCMI_CAPS_OCALL2_THREAD)
+
+/*
+ * enum optee_scmi_ocall_cmd
+ * enum optee_scmi_ocall_reply
+ *
+ * These enumerates define the IDs used by REE/TEE to communicate in the
+ * established REE/TEE Ocall thread context.
+ *
+ * At channel setup, we start from the REE: caller requests an Ocall context.
+ *
+ * 0. REE opens a session toward PTA SCMI. REE invokes PTA command
+ *    PTA_SCMI_CMD_GET_CHANNEL to get a channel handler.
+ *
+ * 1. REE invokes command PTA_SCMI_CMD_OCALL2_SMT_THREAD with an Ocall context.
+ *    This is the initial invocation of the Ocall thread context. Any further
+ *    error in the thread communication make the Ocall to return from REE to
+ *    TEE with an error status (Ocall2 out_param1 == 0) upon which SCMI PTA
+ *    will return from initial command PTA_SCMI_CMD_OCALL2_SMT_THREAD with an
+ *    error result.
+ *
+ * 2. Upon support of Ocall the PTA creates an Ocall context and returns to
+ *    REE with Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY.
+ *
+ * 3. REE returns to the PTA, from the Ocall, with output out_param1
+ *    set to PTA_SCMI_OCALL_PROCESS_SMT_MESSAGE to post an SCMI message.
+ *    In such case, OP-TEE processes the message and returns to REE with
+ *    Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY. The SCMI response is in
+ *    the shared memory buffer.
+ *
+ * 4. Alternatively REE can return from the Ocall with out_param1 set to
+ *    PTA_SCMI_OCALL_CLOSE_THREAD. This requests OP-TEE to terminate the
+ *    Ocall, release resources and return from initial command invocation at
+ *    step 1. as if REE closes the SCMI communication.
+ *
+ * At anytime if an error is reported by Ocall command replies, SCMI PTA
+ * releases the Ocall thread context and returns from initial invocation
+ * at step 1. PTA_SCMI_OCALL_ERROR is used in Ocall return to force an error
+ * report.
+ *
+ * REE channel initialization completes when returning from step 2.
+ * REE agent posts an SCMI message through step 3.
+ * At channel release, REE driver executes step 4.
+ */
+
+enum scmi_optee_ocall_cmd {
+	/*
+	 * PTA_SCMI_OCALL_CMD_THREAD_READY - SCMI PTA send this Ocall command
+	 * when it is ready to process an SCMI message on return of this
+	 * Ocall.
+	 *
+	 * Ocall2 parameters value:
+	 * [in] param1: PTA_SCMI_OCALL_CMD_THREAD_READY
+	 * [in] ocall_arg in_param2: unused.
+	 *
+	 * [out] param1: One of enum scmi_optee_ocall_reply
+	 * [out] param2: unused.
+	 */
+	PTA_SCMI_OCALL_CMD_THREAD_READY = 0,
+};
+
+enum scmi_optee_ocall_reply {
+	/* Ocall error: on return of Ocall, SCMI PTA closes the Ocall thread */
+	PTA_SCMI_OCALL_ERROR = TEE_OCALL2_OUT_PARAM1_ERROR,
+	/* On return of Ocall, SCMI PTA shall close the Ocall thread */
+	PTA_SCMI_OCALL_CLOSE_THREAD = 1,
+	/*
+	 * On return of Ocall, SCMI PTA shall process channel's SCMI message and
+	 * issue Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY again.
+	 */
+	PTA_SCMI_OCALL_PROCESS_SMT_MESSAGE = 2,
+	/*
+	 * On return of Ocall, SCMI PTA shall process channel's MSG SCMI message
+	 * and issue Ocall command PTA_SCMI_OCALL_CMD_THREAD_READY again.
+	 */
+	PTA_SCMI_OCALL_PROCESS_MSG = 3,
+};
+
+/*
+ * struct ocall_ctx - Context of the Ocall used for initial command
+ * PTA_SCMI_CMD_OCALL2_*_THREAD and on return of Ocalls.
+ *
+ * @arg: TEE invoke command arguments
+ * @param: TEE invoke command parameters
+ * @ocall_arg: TEE Ocall2 arguments
+ */
+struct ocall_ctx {
+	struct tee_ioctl_invoke_arg args;
+	struct tee_param param[4];
+	struct tee_ocall2_arg ocall_arg;
+};
 
 /**
  * struct scmi_optee_channel - Description of an OP-TEE SCMI channel
@@ -112,6 +240,7 @@ enum scmi_optee_pta_cmd {
  * @shmem: Virtual base address of the shared memory
  * @req: Shared memory protocol handle for SCMI request and synchronous response
  * @tee_shm: TEE shared memory handle @req or NULL if using IOMEM shmem
+ * @ocall_ctx: OP-TEE Ocall context the SCMI channel is executing in
  * @link: Reference in agent's channel list
  */
 struct scmi_optee_channel {
@@ -126,6 +255,8 @@ struct scmi_optee_channel {
 		struct scmi_msg_payld *msg;
 	} req;
 	struct tee_shm *tee_shm;
+	struct ocall_ctx *ocall_ctx;
+	struct scmi_optee_agent *agent;
 	struct list_head link;
 };
 
@@ -220,7 +351,7 @@ static int get_capabilities(struct scmi_optee_agent *agent)
 
 static int get_channel(struct scmi_optee_channel *channel)
 {
-	struct device *dev = scmi_optee_private->dev;
+	struct device *dev = channel->agent->dev;
 	struct tee_ioctl_invoke_arg arg = { };
 	struct tee_param param[1] = { };
 	unsigned int caps = 0;
@@ -231,6 +362,9 @@ static int get_channel(struct scmi_optee_channel *channel)
 	else
 		caps = PTA_SCMI_CAPS_SMT_HEADER;
 
+	if (channel->agent->caps & PTA_SCMI_CAPS_OCALL2_THREAD)
+		caps |= PTA_SCMI_CAPS_OCALL2_THREAD;
+
 	arg.func = PTA_SCMI_CMD_GET_CHANNEL;
 	arg.session = channel->tee_session;
 	arg.num_params = 1;
@@ -239,7 +373,28 @@ static int get_channel(struct scmi_optee_channel *channel)
 	param[0].u.value.a = channel->channel_id;
 	param[0].u.value.b = caps;
 
-	ret = tee_client_invoke_func(scmi_optee_private->tee_ctx, &arg, param);
+	ret = tee_client_invoke_func(channel->agent->tee_ctx, &arg, param);
+
+	if (!ret && (caps & PTA_SCMI_CAPS_OCALL2_THREAD) &&
+	    arg.ret == TEEC_ERROR_NOT_SUPPORTED) {
+		dev_info(dev, "Ocall not supported, fallback to non-Ocall\n");
+
+		caps &= ~PTA_SCMI_CAPS_OCALL2_THREAD;
+
+		memset(&arg, 0, sizeof(arg));
+		memset(&param, 0, sizeof(param));
+
+		arg.func = PTA_SCMI_CMD_GET_CHANNEL;
+		arg.session = channel->tee_session;
+		arg.num_params = 1;
+
+		param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;
+		param[0].u.value.a = channel->channel_id;
+		param[0].u.value.b = caps;
+
+		ret = tee_client_invoke_func(channel->agent->tee_ctx,
+					     &arg, param);
+	}
 
 	if (ret || arg.ret) {
 		dev_err(dev, "Can't get channel with caps %#x: %d / %#x\n", caps, ret, arg.ret);
@@ -253,6 +408,230 @@ static int get_channel(struct scmi_optee_channel *channel)
 	return 0;
 }
 
+/*
+ * Invoke function with Ocall context.
+ * The below creates an Ocall thread context for SCMI agent to invoke by
+ * returning from an Ocall instead of invoking a command. This provisions
+ * a secure thread for SCMI system communication.
+ */
+static int invoke_optee_ocall(struct scmi_optee_channel *channel)
+{
+	return tee_client_invoke_func_ocall2(channel->agent->tee_ctx,
+					     &channel->ocall_ctx->args,
+					     channel->ocall_ctx->param,
+					     &channel->ocall_ctx->ocall_arg);
+}
+
+static bool return_is_ocall(struct ocall_ctx *ocall_ctx)
+{
+	return tee_ocall_in_progress(&ocall_ctx->ocall_arg);
+}
+
+static int alloc_ocall_ctx(struct scmi_optee_channel *channel)
+{
+	if (WARN_ON(channel->ocall_ctx))
+		return -EINVAL;
+
+	channel->ocall_ctx = devm_kzalloc(channel->agent->dev,
+					  sizeof(*channel->ocall_ctx),
+					  GFP_KERNEL);
+	if (!channel->ocall_ctx)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void free_ocall_ctx(struct scmi_optee_channel *channel)
+{
+	devm_kfree(channel->agent->dev, channel->ocall_ctx);
+	channel->ocall_ctx = NULL;
+}
+
+static void abort_ocall(struct scmi_optee_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	int ret;
+
+	ocall_ctx->ocall_arg.out_param1 = PTA_SCMI_OCALL_ERROR;
+	ocall_ctx->ocall_arg.out_param2 = 0;
+
+	ret = invoke_optee_ocall(channel);
+
+	WARN_ONCE(ret || return_is_ocall(ocall_ctx), "Unexpected error\n");
+}
+
+static bool ocall_thread_is_ready(struct scmi_optee_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	struct device *dev = channel->agent->dev;
+
+	if (!return_is_ocall(ocall_ctx)) {
+		dev_err(dev, "Ocall expected\n");
+		return false;
+	}
+
+	if (ocall_ctx->ocall_arg.in_param1 != PTA_SCMI_OCALL_CMD_THREAD_READY) {
+		dev_err(dev, "Unexpected Ocall function %#x\n",
+			ocall_ctx->ocall_arg.in_param1);
+		return false;
+	}
+
+	return true;
+}
+
+static int setup_ocall_thread(struct scmi_optee_channel *channel)
+{
+	struct device *dev = channel->agent->dev;
+	int ret;
+
+	if (WARN_ONCE(channel->ocall_ctx, "Unexpected error\n"))
+		return -EINVAL;
+
+	ret = alloc_ocall_ctx(channel);
+	if (ret)
+		return ret;
+
+	/*
+	 * Setup parameters for initial TEE invocation with an Ocall
+	 * context to return from tee_client_invoke_func() with
+	 * a provisioned OP-TEE thread.
+	 */
+	if (channel->tee_shm) {
+		*channel->ocall_ctx = (struct ocall_ctx){
+			.args.func = PTA_SCMI_CMD_OCALL2_MSG_THREAD,
+			.args.session = channel->tee_session,
+			.args.num_params = 3,
+			.param[0] = {
+				.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+				.u.value.a = channel->channel_id,
+			},
+			.param[1] = {
+				.attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT,
+				.u.memref.shm = channel->tee_shm,
+				.u.memref.size = SCMI_OPTEE_MAX_MSG_SIZE,
+			},
+			.param[2] = {
+				.attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT,
+				.u.memref.shm = channel->tee_shm,
+				.u.memref.size = SCMI_OPTEE_MAX_MSG_SIZE,
+			},
+			.ocall_arg = TEE_OCALL2_ARG_INIT,
+		};
+	} else {
+		*channel->ocall_ctx = (struct ocall_ctx){
+			.args.func = PTA_SCMI_CMD_OCALL2_SMT_THREAD,
+			.args.session = channel->tee_session,
+			.args.num_params = 1,
+			.param[0] = {
+				.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+				.u.value.a = channel->channel_id,
+			},
+			.ocall_arg = TEE_OCALL2_ARG_INIT,
+		};
+	}
+
+	/* This is the initial invocation that should return in an Ocall */
+	ret = invoke_optee_ocall(channel);
+	if (ret)
+		goto err;
+
+	if (ocall_thread_is_ready(channel))
+		return 0;
+
+	ret = -EPROTO;
+
+	if (!return_is_ocall(channel->ocall_ctx)) {
+		struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+
+		switch (ocall_ctx->args.ret) {
+		case TEEC_SUCCESS:
+			dev_dbg(dev, "unexpected successfull invocation\n");
+			break;
+		case TEEC_ERROR_NOT_SUPPORTED:
+			ret = -EOPNOTSUPP;
+			break;
+		default:
+			dev_dbg(dev, "invoke error %#x\n", ocall_ctx->args.ret);
+			break;
+		}
+	} else {
+		dev_dbg(dev, "Unexpected ocall context\n");
+	}
+
+err:
+	if (return_is_ocall(channel->ocall_ctx))
+		abort_ocall(channel);
+	free_ocall_ctx(channel);
+
+	return ret;
+}
+
+static int close_ocall_thread(struct scmi_optee_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	int ret;
+
+	if(!ocall_ctx)
+		return 0;
+
+	ocall_ctx->ocall_arg.out_param1 = PTA_SCMI_OCALL_CLOSE_THREAD;
+	ocall_ctx->ocall_arg.out_param2 = 0;
+
+	ret = invoke_optee_ocall(channel);
+
+	if (ret) {
+		dev_dbg(channel->agent->dev, "can't invoke OP-TEE: %d\n", ret);
+	} else {
+		if (return_is_ocall(channel->ocall_ctx)) {
+			ret = -EPROTO;
+			abort_ocall(channel);
+		}
+	}
+
+	free_ocall_ctx(channel);
+
+	return ret;
+}
+
+static int invoke_ocall_thread(struct scmi_optee_channel *channel)
+{
+	if (!invoke_optee_ocall(channel) && ocall_thread_is_ready(channel))
+		return 0;
+
+	if (return_is_ocall(channel->ocall_ctx))
+		abort_ocall(channel);
+
+	free_ocall_ctx(channel);
+
+	return -EPROTO;
+}
+
+static int invoke_ocall_msg_thread(struct scmi_optee_channel *channel,
+				   size_t msg_size)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+	int ret;
+
+	ocall_ctx->ocall_arg.out_param1 = PTA_SCMI_OCALL_PROCESS_MSG;
+	ocall_ctx->ocall_arg.out_param2 = msg_size;
+
+	ret = invoke_ocall_thread(channel);
+	if (!ret)
+		channel->rx_len = ocall_ctx->ocall_arg.in_param2;
+
+	return ret;
+}
+
+static int invoke_ocall_smt_thread(struct scmi_optee_channel *channel)
+{
+	struct ocall_ctx *ocall_ctx = channel->ocall_ctx;
+
+	ocall_ctx->ocall_arg.out_param1 = PTA_SCMI_OCALL_PROCESS_SMT_MESSAGE;
+	ocall_ctx->ocall_arg.out_param2 = 0;
+
+	return invoke_ocall_thread(channel);
+}
+
 static int invoke_process_smt_channel(struct scmi_optee_channel *channel)
 {
 	struct tee_ioctl_invoke_arg arg = {
@@ -266,9 +645,9 @@ static int invoke_process_smt_channel(struct scmi_optee_channel *channel)
 	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
 	param[0].u.value.a = channel->channel_id;
 
-	ret = tee_client_invoke_func(scmi_optee_private->tee_ctx, &arg, param);
+	ret = tee_client_invoke_func(channel->agent->tee_ctx, &arg, param);
 	if (ret < 0 || arg.ret) {
-		dev_err(scmi_optee_private->dev, "Can't invoke channel %u: %d / %#x\n",
+		dev_err(channel->agent->dev, "Can't invoke channel %u: %d / %#x\n",
 			channel->channel_id, ret, arg.ret);
 		return -EIO;
 	}
@@ -297,9 +676,9 @@ static int invoke_process_msg_channel(struct scmi_optee_channel *channel, size_t
 	param[2].u.memref.shm = channel->tee_shm;
 	param[2].u.memref.size = SCMI_OPTEE_MAX_MSG_SIZE;
 
-	ret = tee_client_invoke_func(scmi_optee_private->tee_ctx, &arg, param);
+	ret = tee_client_invoke_func(channel->agent->tee_ctx, &arg, param);
 	if (ret < 0 || arg.ret) {
-		dev_err(scmi_optee_private->dev, "Can't invoke channel %u: %d / %#x\n",
+		dev_err(channel->agent->dev, "Can't invoke channel %u: %d / %#x\n",
 			channel->channel_id, ret, arg.ret);
 		return -EIO;
 	}
@@ -430,31 +809,46 @@ static int scmi_optee_chan_setup(struct scmi_chan_info *cinfo, struct device *de
 	cinfo->transport_info = channel;
 	channel->cinfo = cinfo;
 	channel->channel_id = channel_id;
+	channel->agent = scmi_optee_private;
 	mutex_init(&channel->mu);
 
 	ret = setup_shmem(dev, cinfo, channel);
 	if (ret)
 		return ret;
 
-	ret = open_session(scmi_optee_private, &channel->tee_session);
+	ret = open_session(channel->agent, &channel->tee_session);
 	if (ret)
 		goto err_free_shm;
 
+	ret = tee_client_system_session(channel->agent->tee_ctx, channel->tee_session);
+	if (ret)
+		dev_warn(dev, "Could not switch to system session, do best effort\n");
+
 	ret = get_channel(channel);
 	if (ret)
 		goto err_close_sess;
 
+	if (channel->caps & PTA_SCMI_CAPS_OCALL2_THREAD) {
+		ret = setup_ocall_thread(channel);
+		if (ret) {
+			if (ret != -EOPNOTSUPP)
+				goto err_close_sess;
+
+			dev_warn(dev, "Ocall failed, will use regular calls\n");
+		}
+	}
+
 	/* Enable polling */
 	cinfo->no_completion_irq = true;
 
-	mutex_lock(&scmi_optee_private->mu);
-	list_add(&channel->link, &scmi_optee_private->channel_list);
-	mutex_unlock(&scmi_optee_private->mu);
+	mutex_lock(&channel->agent->mu);
+	list_add(&channel->link, &channel->agent->channel_list);
+	mutex_unlock(&channel->agent->mu);
 
 	return 0;
 
 err_close_sess:
-	close_session(scmi_optee_private, channel->tee_session);
+	close_session(channel->agent, channel->tee_session);
 err_free_shm:
 	if (channel->tee_shm)
 		tee_shm_free(channel->tee_shm);
@@ -466,12 +860,17 @@ static int scmi_optee_chan_free(int id, void *p, void *data)
 {
 	struct scmi_chan_info *cinfo = p;
 	struct scmi_optee_channel *channel = cinfo->transport_info;
+	int ret;
 
-	mutex_lock(&scmi_optee_private->mu);
+	ret = close_ocall_thread(channel);
+	if (ret)
+		return ret;
+
+	mutex_lock(&channel->agent->mu);
 	list_del(&channel->link);
-	mutex_unlock(&scmi_optee_private->mu);
+	mutex_unlock(&channel->agent->mu);
 
-	close_session(scmi_optee_private, channel->tee_session);
+	close_session(channel->agent, channel->tee_session);
 
 	if (channel->tee_shm) {
 		tee_shm_free(channel->tee_shm);
@@ -483,6 +882,8 @@ static int scmi_optee_chan_free(int id, void *p, void *data)
 
 	scmi_free_channel(cinfo, data, id);
 
+	devm_kfree(channel->agent->dev, channel);
+
 	return 0;
 }
 
@@ -496,10 +897,20 @@ static int scmi_optee_send_message(struct scmi_chan_info *cinfo,
 
 	if (channel->tee_shm) {
 		msg_tx_prepare(channel->req.msg, xfer);
-		ret = invoke_process_msg_channel(channel, msg_command_size(xfer));
+
+		if (channel->ocall_ctx)
+			ret = invoke_ocall_msg_thread(channel,
+						      msg_command_size(xfer));
+		else
+			ret = invoke_process_msg_channel(channel,
+							 msg_command_size(xfer));
 	} else {
 		shmem_tx_prepare(channel->req.shmem, xfer, cinfo);
-		ret = invoke_process_smt_channel(channel);
+
+		if (channel->ocall_ctx)
+			ret = invoke_ocall_smt_thread(channel);
+		else
+			ret = invoke_process_smt_channel(channel);
 	}
 
 	if (ret)
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511.h b/drivers/gpu/drm/bridge/adv7511/adv7511.h
index 174458002..2d0d2ca51 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511.h
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511.h
@@ -404,6 +404,9 @@ void adv7533_dsi_power_on(struct adv7511 *adv);
 void adv7533_dsi_power_off(struct adv7511 *adv);
 enum drm_mode_status adv7533_mode_valid(struct adv7511 *adv,
 					const struct drm_display_mode *mode);
+bool adv7533_mode_fixup(struct adv7511 *adv,
+			const struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode);
 int adv7533_patch_registers(struct adv7511 *adv);
 int adv7533_patch_cec_registers(struct adv7511 *adv);
 int adv7533_attach_dsi(struct adv7511 *adv);
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c b/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c
index 61f4a38e7..ce6eda87b 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_audio.c
@@ -232,8 +232,12 @@ static const struct hdmi_codec_ops adv7511_codec_ops = {
 
 static const struct hdmi_codec_pdata codec_data = {
 	.ops = &adv7511_codec_ops,
+	.i2s_formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |
+			SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE |
+			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE),
 	.max_i2s_channels = 2,
 	.i2s = 1,
+	.no_i2s_capture = 1,
 	.spdif = 1,
 };
 
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
index 9f9874acf..a18f4d4d9 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c
@@ -927,6 +927,18 @@ static enum drm_mode_status adv7511_bridge_mode_valid(struct drm_bridge *bridge,
 		return adv7511_mode_valid(adv, mode);
 }
 
+static bool adv7511_bridge_mode_fixup(struct drm_bridge *bridge,
+				 const struct drm_display_mode *mode,
+				 struct drm_display_mode *adjusted_mode)
+{
+	struct adv7511 *adv = bridge_to_adv7511(bridge);
+
+	if (adv->type == ADV7533 || adv->type == ADV7535)
+		return adv7533_mode_fixup(adv, mode, adjusted_mode);
+	else
+		return true;
+}
+
 static int adv7511_bridge_attach(struct drm_bridge *bridge,
 				 enum drm_bridge_attach_flags flags)
 {
@@ -975,6 +987,7 @@ static const struct drm_bridge_funcs adv7511_bridge_funcs = {
 	.disable = adv7511_bridge_disable,
 	.mode_set = adv7511_bridge_mode_set,
 	.mode_valid = adv7511_bridge_mode_valid,
+	.mode_fixup = adv7511_bridge_mode_fixup,
 	.attach = adv7511_bridge_attach,
 	.detect = adv7511_bridge_detect,
 	.get_edid = adv7511_bridge_get_edid,
diff --git a/drivers/gpu/drm/bridge/adv7511/adv7533.c b/drivers/gpu/drm/bridge/adv7511/adv7533.c
index b8eeaf473..0361c8500 100644
--- a/drivers/gpu/drm/bridge/adv7511/adv7533.c
+++ b/drivers/gpu/drm/bridge/adv7511/adv7533.c
@@ -120,6 +120,31 @@ enum drm_mode_status adv7533_mode_valid(struct adv7511 *adv,
 	return MODE_OK;
 }
 
+bool adv7533_mode_fixup(struct adv7511 *adv,
+			const struct drm_display_mode *mode,
+			struct drm_display_mode *adjusted_mode)
+{
+	struct mipi_dsi_device *dsi = adv->dsi;
+	int lanes, ret;
+
+	if (mode->clock > 80000)
+		lanes = 4;
+	else
+		lanes = 3;
+
+	if (lanes != dsi->lanes) {
+		mipi_dsi_detach(dsi);
+		dsi->lanes = lanes;
+		ret = mipi_dsi_attach(dsi);
+		if (ret) {
+			dev_err(&dsi->dev, "failed to change host lanes\n");
+			return false;
+		}
+	}
+
+	return true;
+}
+
 int adv7533_patch_registers(struct adv7511 *adv)
 {
 	return regmap_register_patch(adv->regmap,
@@ -147,7 +172,7 @@ int adv7533_attach_dsi(struct adv7511 *adv)
 
 	host = of_find_mipi_dsi_host_by_node(adv->host_node);
 	if (!host) {
-		dev_err(dev, "failed to find dsi host\n");
+		dev_dbg(dev, "failed to find dsi host\n");
 		return -EPROBE_DEFER;
 	}
 
diff --git a/drivers/gpu/drm/bridge/display-connector.c b/drivers/gpu/drm/bridge/display-connector.c
index 9a12449ad..7d3f5eda3 100644
--- a/drivers/gpu/drm/bridge/display-connector.c
+++ b/drivers/gpu/drm/bridge/display-connector.c
@@ -25,6 +25,7 @@ struct display_connector {
 	int			hpd_irq;
 
 	struct regulator	*dp_pwr;
+	struct regulator	*hdmi_pwr;
 	struct gpio_desc	*ddc_en;
 };
 
@@ -315,6 +316,38 @@ static int display_connector_probe(struct platform_device *pdev)
 		}
 	}
 
+	/* Get the PWR for HDMI connector. */
+	if (type == DRM_MODE_CONNECTOR_HDMIA) {
+		int ret;
+
+		conn->hdmi_pwr = devm_regulator_get_optional(&pdev->dev, "hdmi-pwr");
+
+		if (IS_ERR(conn->hdmi_pwr)) {
+			ret = PTR_ERR(conn->hdmi_pwr);
+
+			switch (ret) {
+			case -ENODEV:
+				conn->hdmi_pwr = NULL;
+				break;
+
+			case -EPROBE_DEFER:
+				return -EPROBE_DEFER;
+
+			default:
+				dev_err(&pdev->dev, "failed to get HDMI regulator: %d\n", ret);
+				return ret;
+			}
+		}
+
+		if (conn->hdmi_pwr) {
+			ret = regulator_enable(conn->hdmi_pwr);
+			if (ret) {
+				dev_err(&pdev->dev, "failed to enable HDMI regulator: %d\n", ret);
+				return ret;
+			}
+		}
+	}
+
 	/* Get the DP PWR for DP connector. */
 	if (type == DRM_MODE_CONNECTOR_DisplayPort) {
 		int ret;
@@ -392,6 +425,9 @@ static int display_connector_remove(struct platform_device *pdev)
 	if (conn->dp_pwr)
 		regulator_disable(conn->dp_pwr);
 
+	if (conn->hdmi_pwr)
+		regulator_disable(conn->hdmi_pwr);
+
 	drm_bridge_remove(&conn->bridge);
 
 	if (!IS_ERR(conn->bridge.ddc))
diff --git a/drivers/gpu/drm/bridge/sii902x.c b/drivers/gpu/drm/bridge/sii902x.c
index 6359d6f53..8f58c698a 100644
--- a/drivers/gpu/drm/bridge/sii902x.c
+++ b/drivers/gpu/drm/bridge/sii902x.c
@@ -17,6 +17,7 @@
 #include <linux/i2c.h>
 #include <linux/media-bus-format.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/clk.h>
@@ -163,6 +164,11 @@
 
 #define SII902X_AUDIO_PORT_INDEX		3
 
+/* CEC device */
+#define SII902X_CEC_I2C_ADDR			0x30
+
+#define SII902X_CEC_SETUP			0x8e
+
 struct sii902x {
 	struct i2c_client *i2c;
 	struct regmap *regmap;
@@ -171,6 +177,7 @@ struct sii902x {
 	struct drm_connector connector;
 	struct gpio_desc *reset_gpio;
 	struct i2c_mux_core *i2cmux;
+	struct regulator_bulk_data supplies[2];
 	bool sink_is_hdmi;
 	/*
 	 * Mutex protects audio and video functions from interfering
@@ -1002,6 +1009,13 @@ static int sii902x_init(struct sii902x *sii902x)
 {
 	struct device *dev = &sii902x->i2c->dev;
 	unsigned int status = 0;
+	unsigned char data[2] = { SII902X_CEC_SETUP, 0};
+	struct i2c_msg msg = {
+		.addr	= SII902X_CEC_I2C_ADDR << 1,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= data,
+	};
 	u8 chipid[4];
 	int ret;
 
@@ -1024,13 +1038,22 @@ static int sii902x_init(struct sii902x *sii902x)
 		return -EINVAL;
 	}
 
+	/*
+	 * By default, CEC must be disabled to allow other CEC devives
+	 * to bypass the bridge.
+	 */
+	ret = i2c_transfer(sii902x->i2c->adapter, &msg, 1);
+	if (ret < 0)
+		dev_warn(&sii902x->i2c->dev, "Failed to disable CEC device!\n");
+
 	/* Clear all pending interrupts */
 	regmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);
 	regmap_write(sii902x->regmap, SII902X_INT_STATUS, status);
 
 	if (sii902x->i2c->irq > 0) {
-		regmap_write(sii902x->regmap, SII902X_INT_ENABLE,
-			     SII902X_HOTPLUG_EVENT);
+		regmap_update_bits(sii902x->regmap, SII902X_INT_ENABLE,
+				   SII902X_HOTPLUG_EVENT,
+				   SII902X_HOTPLUG_EVENT);
 
 		ret = devm_request_threaded_irq(dev, sii902x->i2c->irq, NULL,
 						sii902x_interrupt,
@@ -1085,7 +1108,6 @@ static int sii902x_probe(struct i2c_client *client,
 	struct device *dev = &client->dev;
 	struct device_node *endpoint;
 	struct sii902x *sii902x;
-	static const char * const supplies[] = {"iovcc", "cvcc12"};
 	int ret;
 
 	ret = i2c_check_functionality(client->adapter,
@@ -1136,11 +1158,27 @@ static int sii902x_probe(struct i2c_client *client,
 
 	mutex_init(&sii902x->mutex);
 
-	ret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(supplies), supplies);
+	sii902x->supplies[0].supply = "iovcc";
+	sii902x->supplies[1].supply = "cvcc12";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(sii902x->supplies),
+				      sii902x->supplies);
 	if (ret < 0)
-		return dev_err_probe(dev, ret, "Failed to enable supplies");
+		return ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(sii902x->supplies),
+				    sii902x->supplies);
+	if (ret < 0) {
+		dev_err_probe(dev, ret, "Failed to enable supplies");
+		return ret;
+	}
+
+	ret = sii902x_init(sii902x);
+	if (ret < 0) {
+		regulator_bulk_disable(ARRAY_SIZE(sii902x->supplies),
+				       sii902x->supplies);
+	}
 
-	return sii902x_init(sii902x);
+	return ret;
 }
 
 static void sii902x_remove(struct i2c_client *client)
@@ -1154,6 +1192,61 @@ static void sii902x_remove(struct i2c_client *client)
 		platform_device_unregister(sii902x->audio.pdev);
 }
 
+static int sii902x_pm_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sii902x *sii902x = i2c_get_clientdata(client);
+
+	if (sii902x->reset_gpio)
+		gpiod_set_value(sii902x->reset_gpio, 1);
+
+	regulator_bulk_disable(ARRAY_SIZE(sii902x->supplies),
+			       sii902x->supplies);
+
+	return 0;
+}
+
+static int sii902x_pm_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sii902x *sii902x = i2c_get_clientdata(client);
+	unsigned char data[2] = { SII902X_CEC_SETUP, 0};
+	struct i2c_msg msg = {
+		.addr	= SII902X_CEC_I2C_ADDR << 1,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= data,
+	};
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(sii902x->supplies),
+				    sii902x->supplies);
+	if (ret) {
+		dev_err(&sii902x->i2c->dev, "regulator_bulk_enable failed\n");
+		return ret;
+	}
+
+	if (sii902x->reset_gpio)
+		gpiod_set_value(sii902x->reset_gpio, 0);
+
+	regmap_write(sii902x->regmap, SII902X_REG_TPI_RQB, 0x00);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0)
+		dev_err(&sii902x->i2c->dev, "Failed to disable CEC device!\n");
+
+	if (client->irq > 0)
+		regmap_update_bits(sii902x->regmap, SII902X_INT_ENABLE,
+				   SII902X_HOTPLUG_EVENT,
+				   SII902X_HOTPLUG_EVENT);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sii902x_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sii902x_pm_suspend, sii902x_pm_resume)
+};
+
 static const struct of_device_id sii902x_dt_ids[] = {
 	{ .compatible = "sil,sii9022", },
 	{ }
@@ -1172,6 +1265,7 @@ static struct i2c_driver sii902x_driver = {
 	.driver = {
 		.name = "sii902x",
 		.of_match_table = sii902x_dt_ids,
+		.pm = &sii902x_pm_ops,
 	},
 	.id_table = sii902x_i2c_ids,
 };
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
index b2efecf7d..8d5a32767 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
@@ -12,6 +12,8 @@
 #include <linux/component.h>
 #include <linux/debugfs.h>
 #include <linux/iopoll.h>
+#include <linux/math64.h>
+#include <linux/media-bus-format.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/pm_runtime.h>
@@ -251,6 +253,7 @@ struct dw_mipi_dsi {
 	u32 lanes;
 	u32 format;
 	unsigned long mode_flags;
+	int rotation;
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfs;
@@ -315,7 +318,7 @@ static int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,
 	struct dw_mipi_dsi *dsi = host_to_dsi(host);
 	const struct dw_mipi_dsi_plat_data *pdata = dsi->plat_data;
 	struct drm_bridge *bridge;
-	int ret;
+	int ret, nb_endpoints, i;
 
 	if (device->lanes > dsi->plat_data->max_data_lanes) {
 		dev_err(dsi->dev, "the number of data lanes(%u) is too many\n",
@@ -328,13 +331,31 @@ static int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,
 	dsi->format = device->format;
 	dsi->mode_flags = device->mode_flags;
 
-	bridge = devm_drm_of_get_bridge(dsi->dev, dsi->dev->of_node, 1, 0);
-	if (IS_ERR(bridge))
-		return PTR_ERR(bridge);
+	nb_endpoints = of_graph_get_endpoint_count(dsi->dev->of_node);
+	if (!nb_endpoints)
+		return -ENODEV;
 
-	dsi->panel_bridge = bridge;
+	for (i = 1; i < nb_endpoints; i ++) {
+		bridge = devm_drm_of_get_bridge(dsi->dev, dsi->dev->of_node, i, 0);
+
+		/*
+		 * If at least one endpoint is -ENODEV, continue probing,
+		 * else if at least one endpoint returned an error
+		 * (ie -EPROBE_DEFER) then stop probing.
+		 */
+		if (IS_ERR(bridge)) {
+			if (PTR_ERR(bridge) == -ENODEV)
+				continue;
+			else
+				return PTR_ERR(bridge);
+		} else {
+			dsi->panel_bridge = bridge;
 
-	drm_bridge_add(&dsi->bridge);
+			drm_bridge_add(&dsi->bridge);
+
+			break;
+		}
+	}
 
 	if (pdata->host_ops && pdata->host_ops->attach) {
 		ret = pdata->host_ops->attach(pdata->priv_data, device);
@@ -342,6 +363,12 @@ static int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,
 			return ret;
 	}
 
+	/* check if a rotation is required on panel */
+	ret = of_property_read_u32(bridge->of_node, "rotation", &dsi->rotation);
+	if (ret < 0)
+		/* fail to get rotation, set 0 by default */
+		dsi->rotation = 0;
+
 	return 0;
 }
 
@@ -628,7 +655,7 @@ static void dw_mipi_dsi_init(struct dw_mipi_dsi *dsi)
 	 * timeout clock division should be computed with the
 	 * high speed transmission counter timeout and byte lane...
 	 */
-	dsi_write(dsi, DSI_CLKMGR_CFG, TO_CLK_DIVISION(10) |
+	dsi_write(dsi, DSI_CLKMGR_CFG, TO_CLK_DIVISION(0) |
 		  TX_ESC_CLK_DIVISION(esc_clk_division));
 }
 
@@ -636,6 +663,21 @@ static void dw_mipi_dsi_dpi_config(struct dw_mipi_dsi *dsi,
 				   const struct drm_display_mode *mode)
 {
 	u32 val = 0, color = 0;
+	struct drm_bridge *bridge = &dsi->bridge;
+	struct drm_encoder *encoder = bridge->encoder;
+	struct drm_connector_list_iter iter;
+	struct drm_connector *connector = NULL;
+	u32 bus_flags = 0;
+
+	/* Get the connector from encoder */
+	drm_connector_list_iter_begin(encoder->dev, &iter);
+	drm_for_each_connector_iter(connector, &iter)
+		if (connector->encoder == encoder)
+			break;
+	drm_connector_list_iter_end(&iter);
+
+	if (connector)
+		bus_flags = connector->display_info.bus_flags;
 
 	switch (dsi->format) {
 	case MIPI_DSI_FMT_RGB888:
@@ -656,6 +698,8 @@ static void dw_mipi_dsi_dpi_config(struct dw_mipi_dsi *dsi,
 		val |= VSYNC_ACTIVE_LOW;
 	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
 		val |= HSYNC_ACTIVE_LOW;
+	if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+		val |= DATAEN_ACTIVE_LOW;
 
 	dsi_write(dsi, DSI_DPI_VCID, DPI_VCID(dsi->channel));
 	dsi_write(dsi, DSI_DPI_COLOR_CODING, color);
@@ -677,11 +721,16 @@ static void dw_mipi_dsi_video_packet_config(struct dw_mipi_dsi *dsi,
 	 * DSI_VNPCR.NPSIZE... especially because this driver supports
 	 * non-burst video modes, see dw_mipi_dsi_video_mode_config()...
 	 */
-
-	dsi_write(dsi, DSI_VID_PKT_SIZE,
-		       dw_mipi_is_dual_mode(dsi) ?
-				VID_PKT_SIZE(mode->hdisplay / 2) :
-				VID_PKT_SIZE(mode->hdisplay));
+	if (dsi->rotation == 90 || dsi->rotation == 270)
+		dsi_write(dsi, DSI_VID_PKT_SIZE,
+			       dw_mipi_is_dual_mode(dsi) ?
+					VID_PKT_SIZE(mode->vdisplay / 2) :
+					VID_PKT_SIZE(mode->vdisplay));
+	else
+		dsi_write(dsi, DSI_VID_PKT_SIZE,
+			       dw_mipi_is_dual_mode(dsi) ?
+					VID_PKT_SIZE(mode->hdisplay / 2) :
+					VID_PKT_SIZE(mode->hdisplay));
 }
 
 static void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)
@@ -691,7 +740,7 @@ static void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)
 	 * compute high speed transmission counter timeout according
 	 * to the timeout clock division (TO_CLK_DIVISION) and byte lane...
 	 */
-	dsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(1000) | LPRX_TO_CNT(1000));
+	dsi_write(dsi, DSI_TO_CNT_CFG, HSTX_TO_CNT(0) | LPRX_TO_CNT(0));
 	/*
 	 * TODO dw drv improvements
 	 * the Bus-Turn-Around Timeout Counter should be computed
@@ -701,20 +750,45 @@ static void dw_mipi_dsi_command_mode_config(struct dw_mipi_dsi *dsi)
 	dsi_write(dsi, DSI_MODE_CFG, ENABLE_CMD_MODE);
 }
 
+static const u32 minimum_lbccs[] = {10, 5, 4, 3};
+
+static inline u32 dw_mipi_dsi_get_minimum_lbcc(struct dw_mipi_dsi *dsi)
+{
+	return minimum_lbccs[dsi->lanes - 1];
+}
+
 /* Get lane byte clock cycles. */
 static u32 dw_mipi_dsi_get_hcomponent_lbcc(struct dw_mipi_dsi *dsi,
 					   const struct drm_display_mode *mode,
 					   u32 hcomponent)
 {
-	u32 frac, lbcc;
+	u32 frac, lbcc, minimum_lbcc;
+	int bpp;
 
-	lbcc = hcomponent * dsi->lane_mbps * MSEC_PER_SEC / 8;
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST) {
+		/* lbcc based on lane_mbps */
+		lbcc = hcomponent * dsi->lane_mbps * MSEC_PER_SEC / 8;
+	} else {
+		/* lbcc based on pixel clock rate */
+		bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+		if (bpp < 0) {
+			dev_err(dsi->dev, "failed to get bpp\n");
+			return 0;
+		}
+
+		lbcc = div_u64((u64)hcomponent * mode->clock * bpp, dsi->lanes * 8);
+	}
 
 	frac = lbcc % mode->clock;
 	lbcc = lbcc / mode->clock;
 	if (frac)
 		lbcc++;
 
+	minimum_lbcc = dw_mipi_dsi_get_minimum_lbcc(dsi);
+
+	if (lbcc < minimum_lbcc)
+		lbcc = minimum_lbcc;
+
 	return lbcc;
 }
 
@@ -723,9 +797,15 @@ static void dw_mipi_dsi_line_timer_config(struct dw_mipi_dsi *dsi,
 {
 	u32 htotal, hsa, hbp, lbcc;
 
-	htotal = mode->htotal;
-	hsa = mode->hsync_end - mode->hsync_start;
-	hbp = mode->htotal - mode->hsync_end;
+	if (dsi->rotation == 90 || dsi->rotation == 270) {
+		htotal = mode->vtotal;
+		hsa = mode->vsync_end - mode->vsync_start;
+		hbp = mode->vtotal - mode->vsync_end;
+	} else {
+		htotal = mode->htotal;
+		hsa = mode->hsync_end - mode->hsync_start;
+		hbp = mode->htotal - mode->hsync_end;
+	}
 
 	/*
 	 * TODO dw drv improvements
@@ -746,10 +826,17 @@ static void dw_mipi_dsi_vertical_timing_config(struct dw_mipi_dsi *dsi,
 {
 	u32 vactive, vsa, vfp, vbp;
 
-	vactive = mode->vdisplay;
-	vsa = mode->vsync_end - mode->vsync_start;
-	vfp = mode->vsync_start - mode->vdisplay;
-	vbp = mode->vtotal - mode->vsync_end;
+	if (dsi->rotation == 90 || dsi->rotation == 270) {
+		vactive = mode->hdisplay;
+		vsa = mode->hsync_end - mode->hsync_start;
+		vfp = mode->hsync_start - mode->hdisplay;
+		vbp = mode->htotal - mode->hsync_end;
+	} else {
+		vactive = mode->vdisplay;
+		vsa = mode->vsync_end - mode->vsync_start;
+		vfp = mode->vsync_start - mode->vdisplay;
+		vbp = mode->vtotal - mode->vsync_end;
+	}
 
 	dsi_write(dsi, DSI_VID_VACTIVE_LINES, vactive);
 	dsi_write(dsi, DSI_VID_VSA_LINES, vsa);
@@ -851,6 +938,9 @@ static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 	const struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;
 
+	if (!pm_runtime_active(dsi->dev))
+		return;
+
 	/*
 	 * Switch to command mode before panel-bridge post_disable &
 	 * panel unprepare.
@@ -878,7 +968,6 @@ static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
 	}
 	dw_mipi_dsi_disable(dsi);
 
-	clk_disable_unprepare(dsi->pclk);
 	pm_runtime_put(dsi->dev);
 }
 
@@ -904,14 +993,11 @@ static void dw_mipi_dsi_mode_set(struct dw_mipi_dsi *dsi,
 	int ret;
 	u32 lanes = dw_mipi_dsi_get_lanes(dsi);
 
-	clk_prepare_enable(dsi->pclk);
-
 	ret = phy_ops->get_lane_mbps(priv_data, adjusted_mode, dsi->mode_flags,
 				     lanes, dsi->format, &dsi->lane_mbps);
 	if (ret)
 		DRM_DEBUG_DRIVER("Phy get_lane_mbps() failed\n");
 
-	pm_runtime_get_sync(dsi->dev);
 	dw_mipi_dsi_init(dsi);
 	dw_mipi_dsi_dpi_config(dsi, adjusted_mode);
 	dw_mipi_dsi_packet_handler_config(dsi);
@@ -948,6 +1034,8 @@ static void dw_mipi_dsi_bridge_mode_set(struct drm_bridge *bridge,
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
+	pm_runtime_get_sync(dsi->dev);
+
 	dw_mipi_dsi_mode_set(dsi, adjusted_mode);
 	if (dsi->slave)
 		dw_mipi_dsi_mode_set(dsi->slave, adjusted_mode);
@@ -958,6 +1046,9 @@ static void dw_mipi_dsi_bridge_atomic_enable(struct drm_bridge *bridge,
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
+	if (!pm_runtime_active(dsi->dev))
+		return;
+
 	/* Switch to video mode for panel-bridge enable & panel enable */
 	dw_mipi_dsi_set_mode(dsi, MIPI_DSI_MODE_VIDEO);
 	if (dsi->slave)
@@ -1139,28 +1230,30 @@ __dw_mipi_dsi_probe(struct platform_device *pdev,
 	 * Note that the reset was not defined in the initial device tree, so
 	 * we have to be prepared for it not being found.
 	 */
-	apb_rst = devm_reset_control_get_optional_exclusive(dev, "apb");
-	if (IS_ERR(apb_rst)) {
-		ret = PTR_ERR(apb_rst);
+	if (!device_property_read_bool(dev, "default-on")) {
+		apb_rst = devm_reset_control_get_optional_exclusive(dev, "apb");
+		if (IS_ERR(apb_rst)) {
+			ret = PTR_ERR(apb_rst);
 
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "Unable to get reset control: %d\n", ret);
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "Unable to get reset control: %d\n", ret);
 
-		return ERR_PTR(ret);
-	}
-
-	if (apb_rst) {
-		ret = clk_prepare_enable(dsi->pclk);
-		if (ret) {
-			dev_err(dev, "%s: Failed to enable pclk\n", __func__);
 			return ERR_PTR(ret);
 		}
 
-		reset_control_assert(apb_rst);
-		usleep_range(10, 20);
-		reset_control_deassert(apb_rst);
+		if (apb_rst) {
+			ret = clk_prepare_enable(dsi->pclk);
+			if (ret) {
+				dev_err(dev, "%s: Failed to enable pclk\n", __func__);
+				return ERR_PTR(ret);
+			}
 
-		clk_disable_unprepare(dsi->pclk);
+			reset_control_assert(apb_rst);
+			usleep_range(10, 20);
+			reset_control_deassert(apb_rst);
+
+			clk_disable_unprepare(dsi->pclk);
+		}
 	}
 
 	dw_mipi_dsi_debugfs_init(dsi);
diff --git a/drivers/gpu/drm/drm_atomic_uapi.c b/drivers/gpu/drm/drm_atomic_uapi.c
index 79730fa1d..423e853d2 100644
--- a/drivers/gpu/drm/drm_atomic_uapi.c
+++ b/drivers/gpu/drm/drm_atomic_uapi.c
@@ -737,6 +737,8 @@ static int drm_atomic_connector_set_property(struct drm_connector *connector,
 		state->content_type = val;
 	} else if (property == connector->scaling_mode_property) {
 		state->scaling_mode = val;
+	} else if (property == connector->dithering_property) {
+		state->dithering = val;
 	} else if (property == config->content_protection_property) {
 		if (val == DRM_MODE_CONTENT_PROTECTION_ENABLED) {
 			drm_dbg_kms(dev, "only drivers can set CP Enabled\n");
@@ -828,6 +830,8 @@ drm_atomic_connector_get_property(struct drm_connector *connector,
 		*val = state->colorspace;
 	} else if (property == connector->scaling_mode_property) {
 		*val = state->scaling_mode;
+	} else if (property == connector->dithering_property) {
+		*val = state->dithering;
 	} else if (property == config->hdr_output_metadata_property) {
 		*val = state->hdr_output_metadata ?
 			state->hdr_output_metadata->base.id : 0;
diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
index 27de2a97f..76df92391 100644
--- a/drivers/gpu/drm/drm_connector.c
+++ b/drivers/gpu/drm/drm_connector.c
@@ -947,6 +947,12 @@ static const struct drm_prop_enum_list drm_scaling_mode_enum_list[] = {
 	{ DRM_MODE_SCALE_ASPECT, "Full aspect" },
 };
 
+static const struct drm_prop_enum_list drm_dithering_enum_list[] = {
+	{ DRM_MODE_DITHERING_OFF, "Off" },
+	{ DRM_MODE_DITHERING_ON, "On" },
+	{ DRM_MODE_DITHERING_AUTO, "Automatic" },
+};
+
 static const struct drm_prop_enum_list drm_aspect_ratio_enum_list[] = {
 	{ DRM_MODE_PICTURE_ASPECT_NONE, "Automatic" },
 	{ DRM_MODE_PICTURE_ASPECT_4_3, "4:3" },
@@ -1919,6 +1925,62 @@ int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 }
 EXPORT_SYMBOL(drm_connector_attach_scaling_mode_property);
 
+/**
+ * drm_connector_attach_dithering_property - attach atomic dithering property
+ * @connector: connector to attach dithering property on.
+ * @dithering_mask: or'ed mask of BIT(%DRM_MODE_DITHERING_\*).
+ *
+ * This is used to add support for dithering to atomic drivers.
+ *
+ * Returns:
+ * Zero on success, negative errno on failure.
+ */
+int drm_connector_attach_dithering_property(struct drm_connector *connector,
+					    u32 dithering_mask)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_property *dithering_property;
+	int i;
+	const unsigned int valid_dithering_mask =
+		(1U << ARRAY_SIZE(drm_dithering_enum_list)) - 1;
+
+	if (WARN_ON(hweight32(dithering_mask) < 2 ||
+		    dithering_mask & ~valid_dithering_mask))
+		return -EINVAL;
+
+	dithering_property =
+		drm_property_create(dev, DRM_MODE_PROP_ENUM, "dithering",
+				    hweight32(dithering_mask));
+
+	if (!dithering_property)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(drm_dithering_enum_list); i++) {
+		int ret;
+
+		if (!(BIT(i) & dithering_mask))
+			continue;
+
+		ret = drm_property_add_enum(dithering_property,
+					    drm_dithering_enum_list[i].type,
+					    drm_dithering_enum_list[i].name);
+
+		if (ret) {
+			drm_property_destroy(dev, dithering_property);
+
+			return ret;
+		}
+	}
+
+	drm_object_attach_property(&connector->base,
+				   dithering_property, 0);
+
+	connector->dithering_property = dithering_property;
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_connector_attach_dithering_property);
+
 /**
  * drm_mode_create_aspect_ratio_property - create aspect ratio property
  * @dev: DRM device
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index a582ddd58..30f016358 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -435,6 +435,15 @@ config DRM_PANEL_RAYDIUM_RM68200
 	  Say Y here if you want to enable support for Raydium RM68200
 	  720x1280 DSI video mode panel.
 
+config DRM_PANEL_ROCKTECH_HX8394
+	tristate "Rocktech HX8394 720x1280 DSI video mode panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for Rocktech HX8394
+	  720x1280 DSI video mode panel.
+
 config DRM_PANEL_RONBO_RB070D30
 	tristate "Ronbo Electronics RB070D30 panel"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 34e717382..4d0a07e72 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_DRM_PANEL_EBBG_FT8719) += panel-ebbg-ft8719.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
 obj-$(CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02) += panel-feixin-k101-im2ba02.o
 obj-$(CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D) += panel-feiyang-fy07024di26a30d.o
+obj-$(CONFIG_DRM_PANEL_ROCKTECH_HX8394) += panel-rocktech-hx8394.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9341) += panel-ilitek-ili9341.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9881C) += panel-ilitek-ili9881c.o
diff --git a/drivers/gpu/drm/panel/panel-lvds.c b/drivers/gpu/drm/panel/panel-lvds.c
index de8758c30..65ae09382 100644
--- a/drivers/gpu/drm/panel/panel-lvds.c
+++ b/drivers/gpu/drm/panel/panel-lvds.c
@@ -190,7 +190,7 @@ static int panel_lvds_probe(struct platform_device *pdev)
 
 	/* Get GPIOs and backlight controller. */
 	lvds->enable_gpio = devm_gpiod_get_optional(lvds->dev, "enable",
-						     GPIOD_OUT_LOW);
+						     GPIOD_OUT_HIGH);
 	if (IS_ERR(lvds->enable_gpio)) {
 		ret = PTR_ERR(lvds->enable_gpio);
 		dev_err(lvds->dev, "failed to request %s GPIO: %d\n",
diff --git a/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c b/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
index 898b892f1..e4140b436 100644
--- a/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
+++ b/drivers/gpu/drm/panel/panel-orisetech-otm8009a.c
@@ -10,6 +10,7 @@
 #include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
 #include <video/mipi_display.h>
@@ -109,13 +110,16 @@ static inline struct otm8009a *panel_to_otm8009a(struct drm_panel *panel)
 	return container_of(panel, struct otm8009a, panel);
 }
 
-static void otm8009a_dcs_write_buf(struct otm8009a *ctx, const void *data,
-				   size_t len)
+static int otm8009a_dcs_write_buf(struct otm8009a *ctx, const void *data, size_t len)
 {
 	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret = 0;
 
-	if (mipi_dsi_dcs_write_buffer(dsi, data, len) < 0)
+	ret = mipi_dsi_dcs_write_buffer(dsi, data, len);
+	if (ret < 0)
 		dev_warn(ctx->dev, "mipi dsi dcs write buffer failed\n");
+
+	return ret;
 }
 
 #define dcs_write_seq(ctx, seq...)			\
@@ -290,16 +294,16 @@ static int otm8009a_disable(struct drm_panel *panel)
 static int otm8009a_unprepare(struct drm_panel *panel)
 {
 	struct otm8009a *ctx = panel_to_otm8009a(panel);
+	int ret;
 
 	if (!ctx->prepared)
 		return 0;
 
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-	}
-
-	regulator_disable(ctx->supply);
+	pm_runtime_set_autosuspend_delay(ctx->dev, 1000);
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
+	if (ret < 0)
+		return ret;
 
 	ctx->prepared = false;
 
@@ -314,20 +318,12 @@ static int otm8009a_prepare(struct drm_panel *panel)
 	if (ctx->prepared)
 		return 0;
 
-	ret = regulator_enable(ctx->supply);
+	ret = pm_runtime_get_sync(panel->dev);
 	if (ret < 0) {
-		dev_err(panel->dev, "failed to enable supply: %d\n", ret);
+		pm_runtime_put_autosuspend(panel->dev);
 		return ret;
 	}
 
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-		msleep(100);
-	}
-
 	ret = otm8009a_init_sequence(ctx);
 	if (ret)
 		return ret;
@@ -380,6 +376,8 @@ static int otm8009a_get_modes(struct drm_panel *panel,
 
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
 
 	return num_modes;
 }
@@ -400,10 +398,11 @@ static int otm8009a_backlight_update_status(struct backlight_device *bd)
 {
 	struct otm8009a *ctx = bl_get_data(bd);
 	u8 data[2];
+	int ret = 0;
 
 	if (!ctx->prepared) {
 		dev_dbg(&bd->dev, "lcd not ready yet for setting its backlight!\n");
-		return -ENXIO;
+		return 0;
 	}
 
 	if (bd->props.power <= FB_BLANK_NORMAL) {
@@ -413,11 +412,12 @@ static int otm8009a_backlight_update_status(struct backlight_device *bd)
 		 */
 		data[0] = MIPI_DCS_SET_DISPLAY_BRIGHTNESS;
 		data[1] = bd->props.brightness;
-		otm8009a_dcs_write_buf(ctx, data, ARRAY_SIZE(data));
+		ret = otm8009a_dcs_write_buf(ctx, data, ARRAY_SIZE(data));
+		if (ret < 0)
+			return ret;
 
 		/* set Brightness Control & Backlight on */
 		data[1] = 0x24;
-
 	} else {
 		/* Power off the backlight: set Brightness Control & Bl off */
 		data[1] = 0;
@@ -425,7 +425,9 @@ static int otm8009a_backlight_update_status(struct backlight_device *bd)
 
 	/* Update Brightness Control & Backlight */
 	data[0] = MIPI_DCS_WRITE_CONTROL_DISPLAY;
-	otm8009a_dcs_write_buf(ctx, data, ARRAY_SIZE(data));
+	ret = otm8009a_dcs_write_buf(ctx, data, ARRAY_SIZE(data));
+	if (ret < 0)
+		return ret;
 
 	return 0;
 }
@@ -446,8 +448,10 @@ static int otm8009a_probe(struct mipi_dsi_device *dsi)
 
 	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio)) {
-		dev_err(dev, "cannot get reset-gpio\n");
-		return PTR_ERR(ctx->reset_gpio);
+		ret = PTR_ERR(ctx->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		return ret;
 	}
 
 	ctx->supply = devm_regulator_get(dev, "power");
@@ -467,9 +471,18 @@ static int otm8009a_probe(struct mipi_dsi_device *dsi)
 	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
 			  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;
 
+	pm_runtime_enable(ctx->dev);
+	/* set delay to 60s to keep alive the panel to wait the splash screen */
+	pm_runtime_set_autosuspend_delay(ctx->dev, 60000);
+	pm_runtime_use_autosuspend(ctx->dev);
+
 	drm_panel_init(&ctx->panel, dev, &otm8009a_drm_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
 
+	pm_runtime_get_sync(ctx->dev);
+	pm_runtime_mark_last_busy(ctx->dev);
+	pm_runtime_put_autosuspend(ctx->dev);
+
 	ctx->bl_dev = devm_backlight_device_register(dev, dev_name(dev),
 						     dev, ctx,
 						     &otm8009a_backlight_ops,
@@ -503,8 +516,46 @@ static void otm8009a_remove(struct mipi_dsi_device *dsi)
 
 	mipi_dsi_detach(dsi);
 	drm_panel_remove(&ctx->panel);
+
+	pm_runtime_dont_use_autosuspend(ctx->dev);
+	pm_runtime_disable(ctx->dev);
 }
 
+static __maybe_unused int orisetech_otm8009a_suspend(struct device *dev)
+{
+	struct otm8009a *ctx = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static __maybe_unused int orisetech_otm8009a_resume(struct device *dev)
+{
+	struct otm8009a *ctx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(100);
+
+	return 0;
+}
+
+static const struct dev_pm_ops orisetech_otm8009a_pm_ops = {
+	SET_RUNTIME_PM_OPS(orisetech_otm8009a_suspend, orisetech_otm8009a_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
 static const struct of_device_id orisetech_otm8009a_of_match[] = {
 	{ .compatible = "orisetech,otm8009a" },
 	{ }
@@ -517,6 +568,7 @@ static struct mipi_dsi_driver orisetech_otm8009a_driver = {
 	.driver = {
 		.name = "panel-orisetech-otm8009a",
 		.of_match_table = orisetech_otm8009a_of_match,
+		.pm = &orisetech_otm8009a_pm_ops,
 	},
 };
 module_mipi_dsi_driver(orisetech_otm8009a_driver);
diff --git a/drivers/gpu/drm/panel/panel-raydium-rm68200.c b/drivers/gpu/drm/panel/panel-raydium-rm68200.c
index 5f9b34058..13113dbdc 100644
--- a/drivers/gpu/drm/panel/panel-raydium-rm68200.c
+++ b/drivers/gpu/drm/panel/panel-raydium-rm68200.c
@@ -10,6 +10,8 @@
 #include <linux/gpio/consumer.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
 #include <linux/regulator/consumer.h>
 
 #include <video/mipi_display.h>
@@ -91,11 +93,26 @@ static const struct drm_display_mode default_mode = {
 	.vsync_start = 1280 + 12,
 	.vsync_end = 1280 + 12 + 5,
 	.vtotal = 1280 + 12 + 5 + 12,
-	.flags = 0,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
 	.width_mm = 68,
 	.height_mm = 122,
 };
 
+static const struct drm_display_mode rotate_mode = {
+	.clock = 54000,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 12,
+	.hsync_end = 1280 + 12 + 5,
+	.htotal = 1280 + 12 + 5 + 12,
+	.vdisplay = 720,
+	.vsync_start = 720 + 48,
+	.vsync_end = 720 + 48 + 9,
+	.vtotal = 720 + 48 + 9 + 48,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 122,
+	.height_mm = 68,
+};
+
 static inline struct rm68200 *panel_to_rm68200(struct drm_panel *panel)
 {
 	return container_of(panel, struct rm68200, panel);
@@ -260,14 +277,11 @@ static int rm68200_unprepare(struct drm_panel *panel)
 	if (ret)
 		dev_warn(panel->dev, "failed to enter sleep mode: %d\n", ret);
 
-	msleep(120);
-
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-	}
-
-	regulator_disable(ctx->supply);
+	pm_runtime_set_autosuspend_delay(ctx->dev, 1000);
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
+	if (ret < 0)
+		return ret;
 
 	ctx->prepared = false;
 
@@ -283,19 +297,12 @@ static int rm68200_prepare(struct drm_panel *panel)
 	if (ctx->prepared)
 		return 0;
 
-	ret = regulator_enable(ctx->supply);
+	ret = pm_runtime_get_sync(panel->dev);
 	if (ret < 0) {
-		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		pm_runtime_put_autosuspend(panel->dev);
 		return ret;
 	}
 
-	if (ctx->reset_gpio) {
-		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
-		msleep(20);
-		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
-		msleep(100);
-	}
-
 	rm68200_init_sequence(ctx);
 
 	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
@@ -331,13 +338,33 @@ static int rm68200_get_modes(struct drm_panel *panel,
 			     struct drm_connector *connector)
 {
 	struct drm_display_mode *mode;
-
-	mode = drm_mode_duplicate(connector->dev, &default_mode);
-	if (!mode) {
-		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
-			default_mode.hdisplay, default_mode.vdisplay,
-			drm_mode_vrefresh(&default_mode));
-		return -ENOMEM;
+	struct rm68200 *ctx = panel_to_rm68200(panel);
+	struct device *dev = ctx->dev;
+	int rotation, ret;
+
+
+	ret = of_property_read_u32(dev->of_node, "rotation", &rotation);
+	if (ret == -EINVAL)
+		rotation = 0;
+
+	if (rotation == 90 || rotation == 270) {
+		mode = drm_mode_duplicate(connector->dev, &rotate_mode);
+
+		if (!mode) {
+			dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+				rotate_mode.hdisplay, rotate_mode.vdisplay,
+				drm_mode_vrefresh(&rotate_mode));
+			return -ENOMEM;
+		}
+	} else {
+		mode = drm_mode_duplicate(connector->dev, &default_mode);
+
+		if (!mode) {
+			dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+				default_mode.hdisplay, default_mode.vdisplay,
+				drm_mode_vrefresh(&default_mode));
+			return -ENOMEM;
+		}
 	}
 
 	drm_mode_set_name(mode);
@@ -347,6 +374,8 @@ static int rm68200_get_modes(struct drm_panel *panel,
 
 	connector->display_info.width_mm = mode->width_mm;
 	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
 
 	return 1;
 }
@@ -372,7 +401,8 @@ static int rm68200_probe(struct mipi_dsi_device *dsi)
 	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset_gpio)) {
 		ret = PTR_ERR(ctx->reset_gpio);
-		dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
 		return ret;
 	}
 
@@ -393,9 +423,18 @@ static int rm68200_probe(struct mipi_dsi_device *dsi)
 	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
 			  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;
 
+	pm_runtime_enable(ctx->dev);
+	/* set delay to 60s to keep alive the panel to wait the splash screen */
+	pm_runtime_set_autosuspend_delay(ctx->dev, 60000);
+	pm_runtime_use_autosuspend(ctx->dev);
+
 	drm_panel_init(&ctx->panel, dev, &rm68200_drm_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
 
+	pm_runtime_get_sync(ctx->dev);
+	pm_runtime_mark_last_busy(ctx->dev);
+	pm_runtime_put_autosuspend(ctx->dev);
+
 	ret = drm_panel_of_backlight(&ctx->panel);
 	if (ret)
 		return ret;
@@ -418,8 +457,46 @@ static void rm68200_remove(struct mipi_dsi_device *dsi)
 
 	mipi_dsi_detach(dsi);
 	drm_panel_remove(&ctx->panel);
+
+	pm_runtime_dont_use_autosuspend(ctx->dev);
+	pm_runtime_disable(ctx->dev);
 }
 
+static __maybe_unused int raydium_rm68200_suspend(struct device *dev)
+{
+	struct rm68200 *ctx = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static __maybe_unused int raydium_rm68200_resume(struct device *dev)
+{
+	struct rm68200 *ctx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(100);
+
+	return 0;
+}
+
+static const struct dev_pm_ops raydium_rm68200_pm_ops = {
+	SET_RUNTIME_PM_OPS(raydium_rm68200_suspend, raydium_rm68200_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
 static const struct of_device_id raydium_rm68200_of_match[] = {
 	{ .compatible = "raydium,rm68200" },
 	{ }
@@ -432,6 +509,7 @@ static struct mipi_dsi_driver raydium_rm68200_driver = {
 	.driver = {
 		.name = "panel-raydium-rm68200",
 		.of_match_table = raydium_rm68200_of_match,
+		.pm = &raydium_rm68200_pm_ops,
 	},
 };
 module_mipi_dsi_driver(raydium_rm68200_driver);
diff --git a/drivers/gpu/drm/panel/panel-rocktech-hx8394.c b/drivers/gpu/drm/panel/panel-rocktech-hx8394.c
new file mode 100644
index 000000000..f2b87bf3d
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-rocktech-hx8394.c
@@ -0,0 +1,433 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics SA 2022
+ *
+ * Author: Yannick Fertre <yannick.fertre@foss.st.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct hx8394 {
+	struct device *dev;
+	struct drm_panel panel;
+	struct gpio_desc *reset_gpio;
+	struct regulator *supply;
+	bool prepared;
+	bool enabled;
+};
+
+static const struct drm_display_mode default_mode = {
+	.clock = 54000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 48,
+	.hsync_end = 720 + 48 + 9,
+	.htotal = 720 + 48 + 9 + 48,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 12,
+	.vsync_end = 1280 + 12 + 5,
+	.vtotal = 1280 + 12 + 5 + 12,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+	.width_mm = 68,
+	.height_mm = 122,
+};
+
+#define MCS_SETPOWER	0xB1
+#define MCS_SETDISP	0xB2
+#define MCS_SETCYC	0xB4
+#define MCS_SETVCOM	0xB6
+#define MCS_SETEXTC	0xB9
+#define MCS_SETMIPI	0xBA
+#define MCS_SET_BANK	0xBD
+#define MCS_NO_DOC1	0xBF
+#define MCS_NO_DOC2	0xC0
+#define MCS_NO_DOC3	0xC6
+#define MCS_NO_DOC4	0xD8
+#define MCS_NO_DOC5	0xD4
+#define MCS_SETPANEL	0xCC
+#define MCS_SETGIP_0	0xD3
+#define MCS_SETGIP_1	0xD5
+#define MCS_SETGIP_2	0xD6
+
+#define MCS_SETGAMMA	0xE0
+#define MCS_READ_ID1	0xDA
+#define MCS_READ_ID2	0xDB
+#define MCS_READ_ID3	0xDC
+
+#define MY	BIT(7)	/* Row Address Order */
+#define MX	BIT(6)	/* Column Address Order */
+#define MV	BIT(5)	/* Row/Column Exchange */
+#define ML	BIT(4)	/* Vertical Refresh Order */
+#define RGB	BIT(3)	/* RGB-BGR Order */
+#define DDL	BIT(2)	/* Display Data Latch Order */
+#define FH	BIT(1)	/* Flip Horizontal */
+#define FV	BIT(0)	/* Flip Vertical */
+
+static inline struct hx8394 *panel_to_hx8394(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394, panel);
+}
+
+#define dcs_write_cmd_seq(c, cmd, seq...)						\
+({											\
+	static const u8 d[] = { seq };							\
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device((c)->dev);			\
+	int err;									\
+	err = mipi_dsi_dcs_write(dsi, cmd, d, ARRAY_SIZE(d));				\
+	if (err < 0)									\
+		dev_err(ctx->dev, "MIPI DSI DCS write failed: %d\n", err);		\
+})
+
+static void hx8394_dcs_write_buf(struct hx8394 *ctx, const void *data,
+				 size_t len)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int err;
+
+	err = mipi_dsi_dcs_write_buffer(dsi, data, len);
+	if (err < 0)
+		dev_err_ratelimited(ctx->dev, "MIPI DSI DCS write buffer failed: %d\n", err);
+}
+
+#define dcs_write_seq(ctx, seq...)				\
+({								\
+	static const u8 d[] = { seq };				\
+								\
+	hx8394_dcs_write_buf(ctx, d, ARRAY_SIZE(d));	\
+})
+
+static void hx8394_init_sequence(struct hx8394 *ctx)
+{
+	dcs_write_cmd_seq(ctx, MCS_SETEXTC, 0xFF, 0x83, 0x94);
+	dcs_write_cmd_seq(ctx, MCS_SETMIPI, 0x61, 0x03, 0x68, 0x6B, 0xB2, 0xC0);
+	dcs_write_seq(ctx, MCS_SETPOWER, 0x48, 0x12, 0x72, 0x09, 0x32, 0x54, 0x71, 0x71, 0x57,
+		      0x47);
+	dcs_write_cmd_seq(ctx, MCS_SETDISP, 0x00, 0x80, 0x64, 0x0C, 0x0D, 0x2F);
+	dcs_write_seq(ctx, MCS_SETCYC, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86, 0x75,
+		      0x00, 0x3F, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86);
+	dcs_write_seq(ctx, MCS_SETGIP_0, 0x00, 0x00, 0x07, 0x07, 0x40, 0x07, 0x0C, 0x00, 0x08, 0x10,
+		      0x08, 0x00, 0x08, 0x54, 0x15, 0x0A, 0x05, 0x0A, 0x02, 0x15, 0x06, 0x05, 0x06,
+		      0x47, 0x44, 0x0A, 0x0A, 0x4B, 0x10, 0x07, 0x07, 0x0C, 0x40);
+	dcs_write_seq(ctx, MCS_SETGIP_1, 0x1C, 0x1C, 0x1D, 0x1D, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
+		      0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x24, 0x25, 0x18, 0x18, 0x26, 0x27, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x20, 0x21, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_seq(ctx, MCS_SETGIP_2, 0x1C, 0x1C, 0x1D, 0x1D, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
+		      0x01, 0x00, 0x0B, 0x0A, 0x09, 0x08, 0x21, 0x20, 0x18, 0x18, 0x27, 0x26, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x25, 0x24, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_cmd_seq(ctx, MCS_SETVCOM, 0x92, 0x92);
+	dcs_write_seq(ctx, MCS_SETGAMMA, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24, 0x22, 0x47, 0x56,
+		      0x65, 0x66, 0x6E, 0x82, 0x88, 0x8B, 0x9A, 0x9D, 0x98, 0xA8, 0xB9, 0x5D, 0x5C,
+		      0x61, 0x66, 0x6A, 0x6F, 0x7F, 0x7F, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24,
+		      0x22, 0x47, 0x56, 0x65, 0x65, 0x6E, 0x81, 0x87, 0x8B, 0x98, 0x9D, 0x99, 0xA8,
+		      0xBA, 0x5D, 0x5D, 0x62, 0x67, 0x6B, 0x72, 0x7F,  0x7F);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC2, 0x1F, 0x31);
+	dcs_write_cmd_seq(ctx, MCS_SETPANEL, 0x03);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC5, 0x02);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x02);
+	dcs_write_seq(ctx, MCS_NO_DOC4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		      0xFF, 0xFF);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x01);
+	dcs_write_cmd_seq(ctx, MCS_SETPOWER, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC1, 0x40, 0x81, 0x50, 0x00, 0x1A, 0xFC, 0x01);
+	dcs_write_cmd_seq(ctx, MCS_NO_DOC3, 0xED);
+	dcs_write_cmd_seq(ctx, MIPI_DCS_SET_ADDRESS_MODE, FH);
+}
+
+static int hx8394_read_id(struct hx8394 *ctx)
+{
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	u8 id1, id2, id3;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID1, &id1, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID1\n");
+		return ret;
+	}
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID2, &id2, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID2\n");
+		return ret;
+	}
+	ret = mipi_dsi_dcs_read(dsi, MCS_READ_ID3, &id3, 1);
+	if (ret < 0) {
+		dev_err(ctx->dev, "could not read MTP ID3\n");
+		return ret;
+	}
+
+	dev_info(ctx->dev, "MTP ID manufacturer: %02x version: %02x driver: %02x\n", id1, id2, id3);
+
+	return 0;
+}
+
+static int hx8394_enable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+
+	if (ctx->enabled)
+		return 0;
+
+	ctx->enabled = true;
+
+	return 0;
+}
+
+static int hx8394_disable(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+
+	if (!ctx->enabled)
+		return 0;
+
+	ctx->enabled = false;
+
+	return 0;
+}
+
+static int hx8394_prepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = pm_runtime_get_sync(panel->dev);
+	if (ret < 0) {
+		pm_runtime_put_autosuspend(panel->dev);
+		return ret;
+	}
+
+	ret = hx8394_read_id(ctx);
+	if (ret < 0)
+		return ret;
+
+	hx8394_init_sequence(ctx);
+
+	ret = mipi_dsi_dcs_set_tear_off(dsi);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret)
+		return ret;
+
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret)
+		return ret;
+
+	msleep(50);
+
+	ctx->prepared = true;
+
+	return 0;
+}
+
+static int hx8394_unprepare(struct drm_panel *panel)
+{
+	struct hx8394 *ctx = panel_to_hx8394(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret)
+		dev_warn(panel->dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret)
+		dev_warn(panel->dev, "failed to enter sleep mode: %d\n", ret);
+
+	pm_runtime_set_autosuspend_delay(ctx->dev, 1000);
+	pm_runtime_mark_last_busy(panel->dev);
+	ret = pm_runtime_put_autosuspend(panel->dev);
+	if (ret < 0)
+		return ret;
+
+	ctx->prepared = false;
+
+	return 0;
+}
+
+static int hx8394_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+			default_mode.hdisplay, default_mode.vdisplay,
+			drm_mode_vrefresh(&default_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_DE_HIGH |
+					    DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs hx8394_drm_funcs = {
+	.disable = hx8394_disable,
+	.unprepare = hx8394_unprepare,
+	.prepare = hx8394_prepare,
+	.enable = hx8394_enable,
+	.get_modes = hx8394_get_modes,
+};
+
+static int hx8394_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio)) {
+		ret = PTR_ERR(ctx->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply)) {
+		ret = PTR_ERR(ctx->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "cannot get regulator: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	pm_runtime_enable(ctx->dev);
+	/* set delay to 60s to keep alive the panel to wait the splash screen */
+	pm_runtime_set_autosuspend_delay(ctx->dev, 60000);
+	pm_runtime_use_autosuspend(ctx->dev);
+
+	drm_panel_init(&ctx->panel, dev, &hx8394_drm_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	pm_runtime_get_sync(ctx->dev);
+	pm_runtime_mark_last_busy(ctx->dev);
+	pm_runtime_put_autosuspend(ctx->dev);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach() failed: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void hx8394_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394 *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	pm_runtime_dont_use_autosuspend(ctx->dev);
+	pm_runtime_disable(ctx->dev);
+}
+
+static __maybe_unused int rocktech_hx8394_suspend(struct device *dev)
+{
+	struct hx8394 *ctx = dev_get_drvdata(dev);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static __maybe_unused int rocktech_hx8394_resume(struct device *dev)
+{
+	struct hx8394 *ctx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(ctx->dev, "failed to enable supply: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rocktech_hx8394_pm_ops = {
+	SET_RUNTIME_PM_OPS(rocktech_hx8394_suspend, rocktech_hx8394_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
+static const struct of_device_id rocktech_hx8394_of_match[] = {
+	{ .compatible = "rocktech,hx8394" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, rocktech_hx8394_of_match);
+
+static struct mipi_dsi_driver rocktech_hx8394_driver = {
+	.probe = hx8394_probe,
+	.remove = hx8394_remove,
+	.driver = {
+		.name = "panel-rocktech-hx8394",
+		.of_match_table = rocktech_hx8394_of_match,
+		.pm = &rocktech_hx8394_pm_ops,
+	},
+};
+module_mipi_dsi_driver(rocktech_hx8394_driver);
+
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_DESCRIPTION("DRM Driver for rocktech HX8394 MIPI DSI panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index b714ee1bc..92401e1f5 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -324,6 +324,7 @@ static int panel_simple_unprepare(struct drm_panel *panel)
 	if (!p->prepared)
 		return 0;
 
+	pm_runtime_set_autosuspend_delay(panel->dev, 1000);
 	pm_runtime_mark_last_busy(panel->dev);
 	ret = pm_runtime_put_autosuspend(panel->dev);
 	if (ret < 0)
@@ -467,6 +468,7 @@ static int panel_dpi_probe(struct device *dev,
 	struct panel_desc *desc;
 	unsigned int bus_flags;
 	struct videomode vm;
+	const char *mapping;
 	int ret;
 
 	np = dev->of_node;
@@ -491,6 +493,30 @@ static int panel_dpi_probe(struct device *dev,
 	of_property_read_u32(np, "width-mm", &desc->size.width);
 	of_property_read_u32(np, "height-mm", &desc->size.height);
 
+	of_property_read_string(np, "data-mapping", &mapping);
+
+	if (mapping) {
+		if (!strcmp(mapping, "rgb24")) {
+			desc->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+			desc->bpc = 8;
+		} else if (!strcmp(mapping, "rgb565")) {
+			desc->bus_format = MEDIA_BUS_FMT_RGB565_1X16;
+			desc->bpc = 6;
+		} else if (!strcmp(mapping, "bgr666")) {
+			desc->bus_format = MEDIA_BUS_FMT_RGB666_1X18;
+			desc->bpc = 6;
+		} else if (!strcmp(mapping, "lvds666")) {
+			desc->bus_format = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;
+			desc->bpc = 6;
+		}
+	} else {
+		/* No data-mapping node found, set by default bus format & bpc */
+		dev_warn(dev, "%pOF: no data-mapping node found for \"panel-dpi\" binding\n",
+			np);
+		desc->bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+		desc->bpc = 8;
+	}
+
 	/* Extract bus_flags from display_timing */
 	bus_flags = 0;
 	vm.flags = timing->flags;
@@ -573,8 +599,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	if (IS_ERR(panel->supply))
 		return PTR_ERR(panel->supply);
 
-	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable",
-						     GPIOD_OUT_LOW);
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_HIGH);
 	if (IS_ERR(panel->enable_gpio))
 		return dev_err_probe(dev, PTR_ERR(panel->enable_gpio),
 				     "failed to request GPIO\n");
@@ -668,11 +693,16 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	 * fully enabling the panel.
 	 */
 	pm_runtime_enable(dev);
-	pm_runtime_set_autosuspend_delay(dev, 1000);
+	/* set delay to 60s to keep alive the panel to wait the splash screen */
+	pm_runtime_set_autosuspend_delay(dev, 60000);
 	pm_runtime_use_autosuspend(dev);
 
 	drm_panel_init(&panel->base, dev, &panel_simple_funcs, connector_type);
 
+	pm_runtime_get_sync(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
 	err = drm_panel_of_backlight(&panel->base);
 	if (err) {
 		dev_err_probe(dev, err, "Could not find backlight\n");
diff --git a/drivers/gpu/drm/stm/Kconfig b/drivers/gpu/drm/stm/Kconfig
index ded72f879..a0bdfda4f 100644
--- a/drivers/gpu/drm/stm/Kconfig
+++ b/drivers/gpu/drm/stm/Kconfig
@@ -20,3 +20,9 @@ config DRM_STM_DSI
 	select DRM_DW_MIPI_DSI
 	help
 	  Choose this option for MIPI DSI support on STMicroelectronics SoC.
+
+config DRM_STM_LVDS
+	tristate "STMicroelectronics LVDS Display Interface Transmitter DRM driver"
+	depends on DRM_STM
+	help
+	  Enable support for LVDS encoders on STMicroelectronics SoC.
diff --git a/drivers/gpu/drm/stm/Makefile b/drivers/gpu/drm/stm/Makefile
index 4df5caf01..ad740d617 100644
--- a/drivers/gpu/drm/stm/Makefile
+++ b/drivers/gpu/drm/stm/Makefile
@@ -5,4 +5,6 @@ stm-drm-y := \
 
 obj-$(CONFIG_DRM_STM_DSI) += dw_mipi_dsi-stm.o
 
+obj-$(CONFIG_DRM_STM_LVDS) += lvds.o
+
 obj-$(CONFIG_DRM_STM) += stm-drm.o
diff --git a/drivers/gpu/drm/stm/drv.c b/drivers/gpu/drm/stm/drv.c
index 0a09a85ac..06f7cc117 100644
--- a/drivers/gpu/drm/stm/drv.c
+++ b/drivers/gpu/drm/stm/drv.c
@@ -69,17 +69,10 @@ static const struct drm_driver drv_driver = {
 static int drv_load(struct drm_device *ddev)
 {
 	struct platform_device *pdev = to_platform_device(ddev->dev);
-	struct ltdc_device *ldev;
 	int ret;
 
 	DRM_DEBUG("%s\n", __func__);
 
-	ldev = devm_kzalloc(ddev->dev, sizeof(*ldev), GFP_KERNEL);
-	if (!ldev)
-		return -ENOMEM;
-
-	ddev->dev_private = (void *)ldev;
-
 	ret = drmm_mode_config_init(ddev);
 	if (ret)
 		return ret;
@@ -156,9 +149,10 @@ static __maybe_unused int drv_resume(struct device *dev)
 static __maybe_unused int drv_runtime_suspend(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct ltdc_device *ldev = ddev->dev_private;
 
 	DRM_DEBUG_DRIVER("\n");
-	ltdc_suspend(ddev);
+	ltdc_suspend(ldev);
 
 	return 0;
 }
@@ -166,9 +160,10 @@ static __maybe_unused int drv_runtime_suspend(struct device *dev)
 static __maybe_unused int drv_runtime_resume(struct device *dev)
 {
 	struct drm_device *ddev = dev_get_drvdata(dev);
+	struct ltdc_device *ldev = ddev->dev_private;
 
 	DRM_DEBUG_DRIVER("\n");
-	return ltdc_resume(ddev);
+	return ltdc_resume(ldev);
 }
 
 static const struct dev_pm_ops drv_pm_ops = {
@@ -181,19 +176,73 @@ static int stm_drm_platform_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct drm_device *ddev;
-	int ret;
+	struct ltdc_device *ldev;
+	struct device *sfdev;
+	struct device_node *node;
+	int ret = 0;
 
-	DRM_DEBUG("%s\n", __func__);
+	DRM_DEBUG_DRIVER("\n");
 
-	ret = drm_aperture_remove_framebuffers(&drv_driver);
+	/*
+	 * To avoid conflicts between the simple-framebuffer and the display-controller,
+	 * a check was added concerning the state of the simple-framebuffer (must be probed).
+	 */
+	node = of_find_compatible_node(NULL, NULL, "simple-framebuffer");
+	if (!IS_ERR(node)) {
+		if (of_device_is_available(node)) {
+			sfdev = bus_find_device_by_of_node(&platform_bus_type, node);
+			if (sfdev) {
+				if (!device_is_bound(sfdev))
+					ret = -EPROBE_DEFER;
+				put_device(sfdev);
+			}
+		}
+		of_node_put(node);
+		if (ret)
+			return ret;
+	}
+
+	ldev = devm_kzalloc(dev, sizeof(*ldev), GFP_KERNEL);
+	if (!ldev)
+		return -ENOMEM;
+
+	ret = ltdc_parse_device_tree(dev);
 	if (ret)
 		return ret;
 
-	dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	ret = ltdc_get_clk(dev, ldev);
+	if (ret)
+		return ret;
+
+	/* Resume device to enable the clocks */
+	ret = ltdc_resume(ldev);
+	if (ret)
+		return ret;
+
+	ret = drm_aperture_remove_framebuffers(&drv_driver);
+	if (ret)
+		goto err_suspend;
+
+	/* Configure the DMA segment size to make sure we get contiguous & coherent memory */
+	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+	if (ret) {
+		dev_err(dev, "Failed to set DMA segment mask\n");
+		goto err_suspend;
+	}
+
+	ret = dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
+	if (ret) {
+		dev_err(dev, "Failed to set DMA segment size\n");
+		goto err_suspend;
+	}
 
 	ddev = drm_dev_alloc(&drv_driver, dev);
-	if (IS_ERR(ddev))
-		return PTR_ERR(ddev);
+	if (IS_ERR(ddev)) {
+		ret =  PTR_ERR(ddev);
+		goto err_suspend;
+	}
+
+	ddev->dev_private = (void *)ldev;
 
 	ret = drv_load(ddev);
 	if (ret)
@@ -209,6 +258,8 @@ static int stm_drm_platform_probe(struct platform_device *pdev)
 
 err_put:
 	drm_dev_put(ddev);
+err_suspend:
+	ltdc_suspend(ldev);
 
 	return ret;
 }
@@ -226,8 +277,17 @@ static int stm_drm_platform_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static struct ltdc_plat_data stm_drm_plat_data = {
+	.pad_max_freq_hz = 90000000,
+};
+
+static struct ltdc_plat_data stm_drm_plat_data_mp25 = {
+	.pad_max_freq_hz = 150000000,
+};
+
 static const struct of_device_id drv_dt_ids[] = {
-	{ .compatible = "st,stm32-ltdc"},
+	{ .compatible = "st,stm32-ltdc", .data = &stm_drm_plat_data, },
+	{ .compatible = "st,stm32mp25-ltdc", .data = &stm_drm_plat_data_mp25, },
 	{ /* end node */ },
 };
 MODULE_DEVICE_TABLE(of, drv_dt_ids);
diff --git a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
index 89897d5f5..0a5740e1b 100644
--- a/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
+++ b/drivers/gpu/drm/stm/dw_mipi_dsi-stm.c
@@ -4,13 +4,18 @@
  *
  * Authors: Philippe Cornu <philippe.cornu@st.com>
  *          Yannick Fertre <yannick.fertre@st.com>
+ *          Raphal Gallais-Pou <raphael.gallais-pou@foss.st.com>
  */
 
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/iopoll.h>
+#include <linux/kernel.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 
 #include <video/mipi_display.h>
@@ -21,6 +26,7 @@
 
 #define HWVER_130			0x31333000	/* IP version 1.30 */
 #define HWVER_131			0x31333100	/* IP version 1.31 */
+#define HWVER_141			0x31343100	/* IP version 1.41 */
 
 /* DSI digital registers & bit definitions */
 #define DSI_VERSION			0x00
@@ -57,6 +63,50 @@
 #define ODF_MIN		1
 #define ODF_MAX		8
 
+/* specific registers for hardware version 1.41 */
+#define DSI_WPCR1	0x0430		/* Wrapper Phy Conf Reg 1 */
+#define WPCR1_CCF	GENMASK(5, 0)	/* Configuration clock frequency */
+#define WPCR1_HSFR	GENMASK(14, 8)	/* High speed frequency range in Tx mode */
+#define WPCR1_DLD	BIT(16)		/* Data lanes 0 direction */
+
+#define DSI_WRPCR0	0x0434		/* Wrapper regulator and PLL configuration register 0 */
+#define WRPCR0_IDF	GENMASK(3, 0)	/* PLL input division ratio */
+#define WRPCR0_NDIV	GENMASK(13, 4)	/* PLL InLoop division ratio */
+#define WRPCR0_PSC	BIT(16)		/* PLL shadow control */
+
+#define DSI_WRPCR1	0x0438		/* Wrapper regulator and PLL configuration register 1 */
+#define WRPCR1_PROP	GENMASK(5, 0)	/* Proportional charge pump */
+#define WRPCR1_GMP	GENMASK(7, 6)	/* Loop filter resistance */
+#define WRPCR1_INT	GENMASK(13, 8)	/* Integral of charge pump */
+#define WRPCR1_BIAS	GENMASK(22, 16)	/* Charge pump bias */
+#define WRPCR1_VCO	GENMASK(27, 24)	/* VCO operating range */
+#define WRPCR1_ODF	GENMASK(29, 28)	/* Output division factor */
+
+#define DSI_WRPCR2	0x043C		/* Wrapper regulator and PLL configuration register 2 */
+#define WRPCR2_SEL	GENMASK(1, 0)	/* Output selection for PLL Clock */
+#define WRPCR2_PLLEN	BIT(8)		/* PLL ENable */
+#define WRPCR2_UPD	BIT(16)		/* Update (copies) the PLL shadow registers */
+#define WRPCR2_CLR	BIT(24)		/* Clears the PLL shadow registers to their reset values */
+#define WRPCR2_FPLL	BIT(28)		/* Force PLL lock signal */
+
+#define DSI_PTCR0	0x00B4		/* Host PHY test control register 0 */
+#define PTCR0_TRSEN	BIT(0)		/* Test-interface reset enable for the TDI bus */
+#define PTCR0_TCKEN	BIT(1)		/* Test-interface clock enable for the TDI bus */
+
+#define DSI_PCTLR	0x00A0		/* Host PHY control register */
+#define PCTLR_PWEN	BIT(0)		/* Power enable */
+#define PCTLR_DEN	BIT(1)		/* Digital enable */
+#define PCTLR_CKEN	BIT(2)		/* Clock enable */
+#define PCTLR_UCKEN	BIT(3)		/* ULPS clock enable */
+
+#define DSI_PSR		0x00B0		/* Host PHY status register */
+#define PSR_PSSC	BIT(2)		/* PHY stop state clock lane */
+
+#define IDF_PHY_141_MIN		1
+#define IDF_PHY_141_MAX		16
+#define NDIV_PHY_141_MIN	64
+#define NDIV_PHY_141_MAX	625
+
 /* dsi color format coding according to the datasheet */
 enum dsi_color {
 	DSI_RGB565_CONF1,
@@ -70,18 +120,32 @@ enum dsi_color {
 #define LANE_MIN_KBPS	31250
 #define LANE_MAX_KBPS	500000
 
+#define LANE_MIN_PHY_141_KBPS	80000
+#define LANE_MAX_PHY_141_KBPS	2500000
+#define FVCO_MIN_PHY_141_KBPS	320000
+#define FVCO_MAX_PHY_141_KBPS	1250000
+
 /* Sleep & timeout for regulator on/off, pll lock/unlock & fifo empty */
 #define SLEEP_US	1000
 #define TIMEOUT_US	200000
 
 struct dw_mipi_dsi_stm {
 	void __iomem *base;
+	struct device *dev;
 	struct clk *pllref_clk;
+	struct clk *pclk;
+	struct clk *px_clk;
+	struct clk_hw txbyte_clk;
 	struct dw_mipi_dsi *dsi;
 	u32 hw_version;
 	int lane_min_kbps;
 	int lane_max_kbps;
 	struct regulator *vdd_supply;
+	struct regulator *vdda18_supply;
+	struct dw_mipi_dsi_plat_data pdata;
+	unsigned int lane_mbps;
+	u32 format;
+	bool probe_done;
 };
 
 static inline void dsi_write(struct dw_mipi_dsi_stm *dsi, u32 reg, u32 val)
@@ -194,29 +258,559 @@ static int dsi_pll_get_params(struct dw_mipi_dsi_stm *dsi,
 	return 0;
 }
 
-static int dw_mipi_dsi_phy_init(void *priv_data)
+struct dphy_pll_parameter_map {
+	u32 data_rate;	/* upper margin of frequency range */
+	u8 hs_freq;	/* hsfreqrange */
+	u8 odf;
+	u8 vco;
+	u8 prop;
+};
+
+static const struct dphy_pll_parameter_map dppa_map[] = {
+	{80, 0x00, 0x03, 0x0F, 0x0B},
+	{90, 0x10, 0x03, 0x0F, 0x0B},
+	{100, 0x20, 0x03, 0x0F, 0x0B},
+	{110, 0x30, 0x03, 0x09, 0x0B},
+	{120, 0x01, 0x03, 0x09, 0x0B},
+	{130, 0x11, 0x03, 0x09, 0x0B},
+	{140, 0x21, 0x03, 0x09, 0x0B},
+	{150, 0x31, 0x03, 0x09, 0x0B},
+	{160, 0x02, 0x02, 0x0F, 0x0B},
+	{170, 0x12, 0x02, 0x0F, 0x0B},
+	{180, 0x22, 0x02, 0x0F, 0x0B},
+	{190, 0x32, 0x02, 0x0F, 0x0B},
+	{205, 0x03, 0x02, 0x0F, 0x0B},
+	{220, 0x13, 0x02, 0x09, 0x0B},
+	{235, 0x23, 0x02, 0x09, 0x0B},
+	{250, 0x33, 0x02, 0x09, 0x0B},
+	{275, 0x04, 0x02, 0x09, 0x0B},
+	{300, 0x14, 0x02, 0x09, 0x0B},
+	{325, 0x25, 0x01, 0x0F, 0x0B},
+	{350, 0x35, 0x01, 0x0F, 0x0B},
+	{400, 0x05, 0x01, 0x0F, 0x0B},
+	{450, 0x16, 0x01, 0x09, 0x0B},
+	{500, 0x26, 0x01, 0x09, 0x0B},
+	{550, 0x37, 0x01, 0x09, 0x0B},
+	{600, 0x07, 0x01, 0x09, 0x0B},
+	{650, 0x18, 0x00, 0x0F, 0x0B},
+	{700, 0x28, 0x00, 0x0F, 0x0B},
+	{750, 0x39, 0x00, 0x0F, 0x0B},
+	{800, 0x09, 0x00, 0x0F, 0x0B},
+	{850, 0x19, 0x00, 0x09, 0x0B},
+	{900, 0x29, 0x00, 0x09, 0x0B},
+	{950, 0x3A, 0x00, 0x09, 0x0B},
+	{1000, 0x0A, 0x00, 0x09, 0x0B},
+	{1050, 0x1A, 0x00, 0x09, 0x0B},
+	{1100, 0x2A, 0x00, 0x09, 0x0B},
+	{1150, 0x3B, 0x00, 0x09, 0x0B},
+	{1200, 0x0B, 0x00, 0x09, 0x0B},
+	{1250, 0x1B, 0x00, 0x09, 0x0B},
+	{1300, 0x2B, 0x00, 0x03, 0x0B},
+	{1350, 0x3C, 0x00, 0x03, 0x0B},
+	{1400, 0x0C, 0x00, 0x03, 0x0B},
+	{1450, 0x1C, 0x00, 0x03, 0x0B},
+	{1500, 0x2C, 0x00, 0x03, 0x0B},
+	{1550, 0x3D, 0x00, 0x03, 0x0B},
+	{1600, 0x0D, 0x00, 0x03, 0x0B},
+	{1650, 0x1D, 0x00, 0x03, 0x0B},
+	{1700, 0x2E, 0x00, 0x03, 0x0B},
+	{1750, 0x3E, 0x00, 0x03, 0x0B},
+	{1800, 0x0E, 0x00, 0x03, 0x0B},
+	{1850, 0x1E, 0x00, 0x03, 0x0B},
+	{1900, 0x2F, 0x00, 0x03, 0x0B},
+	{1950, 0x3F, 0x00, 0x03, 0x0B},
+	{2000, 0x0F, 0x00, 0x03, 0x0B},
+	{2050, 0x40, 0x00, 0x03, 0x0B},
+	{2100, 0x41, 0x00, 0x03, 0x0B},
+	{2150, 0x42, 0x00, 0x03, 0x0B},
+	{2200, 0x43, 0x00, 0x01, 0x0B},
+	{2250, 0x44, 0x00, 0x01, 0x0B},
+	{2300, 0x45, 0x00, 0x01, 0x0C},
+	{2350, 0x46, 0x00, 0x01, 0x0C},
+	{2400, 0x47, 0x00, 0x01, 0x0C},
+	{2450, 0x48, 0x00, 0x01, 0x0C},
+	{2500, 0x49, 0x00, 0x01, 0x0C}
+};
+
+static int dsi_phy_141_pll_get_params(struct dw_mipi_dsi_stm *dsi,
+				      int clkin_khz, int clkout_khz,
+				      int *idf, int *ndiv, int *odf, int *index)
+{
+	int i, n;
+	int delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map); i++) {
+		if (dsi->lane_mbps < dppa_map[i].data_rate) {
+			if (i == ARRAY_SIZE(dppa_map) - 1)
+				DRM_WARN("Could not find frequency mapped index\n");
+			i--;
+			break;
+		}
+	}
+
+	/* Save index only if reference exists */
+	if (index)
+		*index = i;
+
+	*odf = int_pow(2, ((dppa_map[i].odf & WRPCR1_ODF) >> 28));
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = IDF_PHY_141_MIN; i <= IDF_PHY_141_MAX; i++) {
+		for (n = NDIV_PHY_141_MIN; n <= NDIV_PHY_141_MAX; n++) {
+			/* Check if new delta is better & saves parameters */
+			delta = dsi_pll_get_clkout_khz(clkin_khz, i, n, *odf) - clkout_khz;
+
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				*idf = i;
+				*ndiv = n;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int dw_mipi_dsi_phy_141_init(void *priv_data)
 {
 	struct dw_mipi_dsi_stm *dsi = priv_data;
-	u32 val;
 	int ret;
 
-	/* Enable the regulator */
-	dsi_set(dsi, DSI_WRPCR, WRPCR_REGEN | WRPCR_BGREN);
-	ret = readl_poll_timeout(dsi->base + DSI_WISR, val, val & WISR_RRS,
-				 SLEEP_US, TIMEOUT_US);
+	DRM_DEBUG_DRIVER("\n");
+
+	/* Select video mode by resetting DSIM bit */
+	dsi_clear(dsi, DSI_WCFGR, WCFGR_DSIM);
+
+	/* Select the color coding */
+	dsi_update_bits(dsi, DSI_WCFGR, WCFGR_COLMUX,
+			dsi_color_from_mipi(dsi->format) << 1);
+
+	dsi_write(dsi, DSI_PCTLR, 0x00);
+
+	/* clear the pll shadow regs */
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	/* set testclr = 1 */
+	dsi_set(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	if (clk_hw_is_enabled(&dsi->txbyte_clk))
+		clk_disable_unprepare(dsi->txbyte_clk.clk);
+
+	/* dummy set rate ... */
+	clk_set_rate(dsi->txbyte_clk.clk, dsi->lane_mbps * 1000000);
+
+	ret = clk_set_rate(dsi->txbyte_clk.clk, dsi->lane_mbps * 1000000 / 2);
 	if (ret)
-		DRM_DEBUG_DRIVER("!TIMEOUT! waiting REGU, let's continue\n");
+		return ret;
+
+	ret = clk_prepare_enable(dsi->txbyte_clk.clk);
+
+	return ret;
+}
+
+static int
+dw_mipi_dsi_phy_141_get_lane_mbps(void *priv_data,
+				  const struct drm_display_mode *mode,
+				  unsigned long mode_flags, u32 lanes,
+				  u32 format, unsigned int *lane_mbps)
+{
+	struct dw_mipi_dsi_stm *dsi = priv_data;
+	unsigned int pll_out_khz, pll_in_khz;
+	u32 ndiv, odf, idf;
+	int bpp;
+
+	/* Compute requested pll out */
+	dsi->format = format;
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	pll_out_khz = mode->clock * bpp / (lanes * 2);
+
+	/* Add 20% to pll out to be higher than pixel bw (burst mode only) */
+	if (mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		pll_out_khz = (pll_out_khz * 12) / 10;
+
+	if (pll_out_khz > dsi->lane_max_kbps) {
+		pll_out_khz = dsi->lane_max_kbps;
+		DRM_WARN("Warning max phy mbps is used\n");
+	}
+	if (pll_out_khz < dsi->lane_min_kbps) {
+		pll_out_khz = dsi->lane_min_kbps;
+		DRM_WARN("Warning min phy mbps is used\n");
+	}
+
+	pll_in_khz = (unsigned int)(clk_get_rate(dsi->pllref_clk) / 1000);
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf, NULL);
+
+	/* Get the adjusted lane data rate value, lane data rate = 2 * pll output */
+	*lane_mbps = 2 * dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf) / 1000;
+	dsi->lane_mbps = *lane_mbps;
+
+	DRM_DEBUG_DRIVER("lane_mbps %d\n", *lane_mbps);
+
+	return 0;
+}
+
+#define clk_to_dw_mipi_dsi_stm(clk) \
+	container_of(clk, struct dw_mipi_dsi_stm, txbyte_clk)
+
+static void dw_mipi_dsi_clk_disable(struct clk_hw *clk)
+{
+	struct dw_mipi_dsi_stm *dsi = clk_to_dw_mipi_dsi_stm(clk);
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	if (!dsi->probe_done)
+		return;
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		return;
+	}
+
+	if (dsi->hw_version == HWVER_141) {
+		/* Disable the DSI PLL */
+		dsi_clear(dsi, DSI_WRPCR2, WRPCR2_PLLEN);
+	} else {
+		/* Disable the DSI PLL */
+		dsi_clear(dsi, DSI_WRPCR, WRPCR_PLLEN);
+
+		/* Disable the regulator */
+		dsi_clear(dsi, DSI_WRPCR, WRPCR_REGEN | WRPCR_BGREN);
+	}
+
+	clk_disable_unprepare(dsi->pclk);
+}
+
+static int dw_mipi_dsi_clk_enable(struct clk_hw *clk)
+{
+	struct dw_mipi_dsi_stm *dsi = clk_to_dw_mipi_dsi_stm(clk);
+	u32 val;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	if (!dsi->probe_done)
+		return 0;
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		return ret;
+	}
+
+	if (dsi->hw_version == HWVER_141) {
+		ret = readl_poll_timeout_atomic(dsi->base + DSI_PSR, val, val & PSR_PSSC,
+						SLEEP_US, TIMEOUT_US);
+		if (ret)
+			DRM_ERROR("!TIMEOUT! waiting PLL, let's continue\n");
+
+		dsi_set(dsi, DSI_WRPCR2, WRPCR2_PLLEN);
+	} else {
+		/* Enable the regulator */
+		dsi_set(dsi, DSI_WRPCR, WRPCR_REGEN | WRPCR_BGREN);
+		ret = readl_poll_timeout_atomic(dsi->base + DSI_WISR, val, val & WISR_RRS,
+						SLEEP_US, TIMEOUT_US);
+		if (ret)
+			DRM_DEBUG_DRIVER("!TIMEOUT! waiting REGU, let's continue\n");
+
+		/* Enable the DSI PLL & wait for its lock */
+		dsi_set(dsi, DSI_WRPCR, WRPCR_PLLEN);
+		ret = readl_poll_timeout_atomic(dsi->base + DSI_WISR, val, val & WISR_PLLLS,
+						SLEEP_US, TIMEOUT_US);
+		if (ret)
+			DRM_DEBUG_DRIVER("!TIMEOUT! waiting PLL, let's continue\n");
+	}
+
+	clk_disable_unprepare(dsi->pclk);
+
+	return 0;
+}
+
+static int dw_mipi_dsi_clk_is_enabled(struct clk_hw *hw)
+{
+	struct dw_mipi_dsi_stm *dsi = clk_to_dw_mipi_dsi_stm(hw);
+	int ret;
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		return false;
+	}
+
+	if (dsi->hw_version == HWVER_141)
+		ret = dsi_read(dsi, DSI_WRPCR2) & WRPCR2_PLLEN;
+	else
+		ret = dsi_read(dsi, DSI_WRPCR) & WRPCR_PLLEN;
+
+	clk_disable_unprepare(dsi->pclk);
+
+	return ret;
+}
+
+static unsigned long dw_mipi_dsi_clk_recalc_rate(struct clk_hw *hw,
+						 unsigned long parent_rate)
+{
+	struct dw_mipi_dsi_stm *dsi = clk_to_dw_mipi_dsi_stm(hw);
+	unsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz;
+	int ret;
+	u32 val;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		return -EINVAL;
+	}
+
+	pll_in_khz = (unsigned int)(parent_rate / 1000);
+
+	if (dsi->hw_version == HWVER_141) {
+		val = dsi_read(dsi, DSI_WRPCR0);
+
+		idf = (val & WRPCR0_IDF) + 1;
+		ndiv = ((val & WRPCR0_NDIV) >> 4) + 2;
+
+		val = dsi_read(dsi, DSI_WRPCR1);
+
+		odf = int_pow(2, (val & WRPCR1_ODF) >> 28);
+	} else {
+		val = dsi_read(dsi, DSI_WRPCR);
+
+		idf = (val & WRPCR_IDF) >> 11;
+		if (!idf)
+			idf = 1;
+		ndiv = (val & WRPCR_NDIV) >> 2;
+		odf = int_pow(2, (val & WRPCR_ODF) >> 16);
+	}
+
+	/* Get the adjusted pll out value */
+	pll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);
+
+	clk_disable_unprepare(dsi->pclk);
+
+	return (unsigned long)pll_out_khz * 1000;
+}
+
+static long dw_mipi_dsi_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long *parent_rate)
+{
+	struct dw_mipi_dsi_stm *dsi = clk_to_dw_mipi_dsi_stm(hw);
+	unsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		return -EINVAL;
+	}
 
-	/* Enable the DSI PLL & wait for its lock */
-	dsi_set(dsi, DSI_WRPCR, WRPCR_PLLEN);
-	ret = readl_poll_timeout(dsi->base + DSI_WISR, val, val & WISR_PLLLS,
-				 SLEEP_US, TIMEOUT_US);
+	pll_in_khz = (unsigned int)(*parent_rate / 1000);
+
+	/* Compute best pll parameters */
+	idf = 0;
+	ndiv = 0;
+	odf = 0;
+
+	if (dsi->hw_version == HWVER_141)
+		ret = dsi_phy_141_pll_get_params(dsi, pll_in_khz, rate / 1000,
+						 &idf, &ndiv, &odf, NULL);
+	else
+		ret = dsi_pll_get_params(dsi, pll_in_khz, rate / 1000,
+					 &idf, &ndiv, &odf);
 	if (ret)
-		DRM_DEBUG_DRIVER("!TIMEOUT! waiting PLL, let's continue\n");
+		DRM_WARN("Warning dsi_pll_get_params(): bad params\n");
+
+	/* Get the adjusted pll out value */
+	pll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);
+
+	clk_disable_unprepare(dsi->pclk);
+
+	return pll_out_khz * 1000;
+}
+
+static int dw_mipi_dsi_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+				    unsigned long parent_rate)
+{
+	struct dw_mipi_dsi_stm *dsi = clk_to_dw_mipi_dsi_stm(hw);
+	u32 val, ccf, prop, gmp, int1, bias, vco;
+	unsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz, hsfreq;
+	int ret, dppa_index;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	pll_in_khz = (unsigned int)(parent_rate / 1000);
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Compute best pll parameters */
+	idf = 0;
+	ndiv = 0;
+	odf = 0;
+
+	if (dsi->hw_version == HWVER_141) {
+		/* Compute requested pll out, pll out is the half of the lane data rate */
+		pll_out_khz = dsi->lane_mbps * 1000 / 2;
+
+		ret = dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz,
+						 &idf, &ndiv, &odf, &dppa_index);
+		if (ret)
+			DRM_WARN("Warning dsi_pll_get_params(): bad params\n");
+
+		ccf = ((pll_in_khz / 1000 - 17)) * 4;
+		hsfreq = dppa_map[dppa_index].hs_freq;
+
+		vco = dppa_map[dppa_index].vco;
+		bias = 0x10;
+		int1 = 0x00;
+		gmp = 0x01;
+		prop = dppa_map[dppa_index].prop;
+
+		/* set DLD, HSFR & CCF */
+		val = (hsfreq << 8) | ccf;
+		dsi_write(dsi, DSI_WPCR1, val);
+
+		val = ((ndiv - 2) << 4) | (idf - 1);
+		dsi_write(dsi, DSI_WRPCR0, val);
+
+		val = ((odf - 1) << 28) | (vco << 24) | (bias << 16)
+		       | (int1 << 8) | (gmp << 6) | prop;
+		dsi_write(dsi, DSI_WRPCR1, val);
+
+		dsi_write(dsi, DSI_PCTLR, PCTLR_CKEN);
+
+		dsi_update_bits(dsi, DSI_WRPCR2, WRPCR2_SEL, 0x01);
+
+		dsi_set(dsi, DSI_WRPCR2, WRPCR2_UPD);
+		mdelay(1);
+
+		dsi_clear(dsi, DSI_WRPCR2, WRPCR2_UPD);
+		mdelay(1);
+
+		dsi_set(dsi, DSI_PCTLR, PCTLR_PWEN | PCTLR_DEN);
+	} else {
+		ret = dsi_pll_get_params(dsi, pll_in_khz, rate / 1000,
+					 &idf, &ndiv, &odf);
+		if (ret)
+			DRM_WARN("Warning dsi_pll_get_params(): bad params\n");
+
+		/* Get the adjusted pll out value */
+		pll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);
+
+		/* Set the PLL division factors */
+		dsi_update_bits(dsi, DSI_WRPCR, WRPCR_NDIV | WRPCR_IDF | WRPCR_ODF,
+				(ndiv << 2) | (idf << 11) | ((ffs(odf) - 1) << 16));
+
+		/* Compute uix4 & set the bit period in high-speed mode */
+		val = 4000000 / pll_out_khz;
+		dsi_update_bits(dsi, DSI_WPCR0, WPCR0_UIX4, val);
+	}
+
+	clk_disable_unprepare(dsi->pclk);
 
 	return 0;
 }
 
+static void dw_mipi_dsi_clk_unregister(void *data)
+{
+	struct dw_mipi_dsi_stm *dsi = data;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	of_clk_del_provider(dsi->dev->of_node);
+	clk_hw_unregister(&dsi->txbyte_clk);
+}
+
+static const struct clk_ops dw_mipi_dsi_stm_clk_ops = {
+	.enable = dw_mipi_dsi_clk_enable,
+	.disable = dw_mipi_dsi_clk_disable,
+	.is_enabled = dw_mipi_dsi_clk_is_enabled,
+	.recalc_rate = dw_mipi_dsi_clk_recalc_rate,
+	.round_rate = dw_mipi_dsi_clk_round_rate,
+	.set_rate = dw_mipi_dsi_clk_set_rate,
+};
+
+static struct clk_init_data cdata_init = {
+	.name = "ck_dsi_phy",
+	.ops = &dw_mipi_dsi_stm_clk_ops,
+	.parent_names = (const char * []) {"ck_hse"},
+	.num_parents = 1,
+};
+
+static struct clk_init_data cdata_init_141 = {
+	.name = "txbyteclk",
+	.ops = &dw_mipi_dsi_stm_clk_ops,
+	.parent_names = (const char * []) {"clk_phy_dsi"},
+	.num_parents = 1,
+};
+
+static int dw_mipi_dsi_clk_register(struct dw_mipi_dsi_stm *dsi,
+				    struct device *dev)
+{
+	struct device_node *node = dev->of_node;
+	int ret;
+
+	DRM_DEBUG_DRIVER("Registering clk\n");
+
+	if (dsi->hw_version == HWVER_131 || dsi->hw_version == HWVER_130) {
+		dsi->txbyte_clk.init = &cdata_init;
+	} else if (dsi->hw_version == HWVER_141) {
+		dsi->txbyte_clk.init = &cdata_init_141;
+	} else {
+		DRM_ERROR("Version hw_clk not supported\n");
+		return -ENODEV;
+	}
+
+	ret = clk_hw_register(dev, &dsi->txbyte_clk);
+	if (ret)
+		return ret;
+
+	ret = of_clk_add_hw_provider(node, of_clk_hw_simple_get,
+				     &dsi->txbyte_clk);
+	if (ret)
+		clk_hw_unregister(&dsi->txbyte_clk);
+
+	return ret;
+}
+
+static int dw_mipi_dsi_phy_init(void *priv_data)
+{
+	struct dw_mipi_dsi_stm *dsi = priv_data;
+	int ret = 0;
+
+	if (!clk_hw_is_enabled(&dsi->txbyte_clk))
+		ret = clk_prepare_enable(dsi->txbyte_clk.clk);
+
+	return ret;
+}
+
 static void dw_mipi_dsi_phy_power_on(void *priv_data)
 {
 	struct dw_mipi_dsi_stm *dsi = priv_data;
@@ -233,6 +827,8 @@ static void dw_mipi_dsi_phy_power_off(void *priv_data)
 
 	DRM_DEBUG_DRIVER("\n");
 
+	clk_disable_unprepare(dsi->txbyte_clk.clk);
+
 	/* Disable the DSI wrapper */
 	dsi_clear(dsi, DSI_WCR, WCR_DSIEN);
 }
@@ -243,9 +839,8 @@ dw_mipi_dsi_get_lane_mbps(void *priv_data, const struct drm_display_mode *mode,
 			  unsigned int *lane_mbps)
 {
 	struct dw_mipi_dsi_stm *dsi = priv_data;
-	unsigned int idf, ndiv, odf, pll_in_khz, pll_out_khz;
+	unsigned int pll_in_khz, pll_out_khz;
 	int ret, bpp;
-	u32 val;
 
 	pll_in_khz = (unsigned int)(clk_get_rate(dsi->pllref_clk) / 1000);
 
@@ -266,25 +861,10 @@ dw_mipi_dsi_get_lane_mbps(void *priv_data, const struct drm_display_mode *mode,
 		DRM_WARN("Warning min phy mbps is used\n");
 	}
 
-	/* Compute best pll parameters */
-	idf = 0;
-	ndiv = 0;
-	odf = 0;
-	ret = dsi_pll_get_params(dsi, pll_in_khz, pll_out_khz,
-				 &idf, &ndiv, &odf);
+	ret = clk_set_rate((dsi->txbyte_clk.clk), pll_out_khz * 1000);
 	if (ret)
-		DRM_WARN("Warning dsi_pll_get_params(): bad params\n");
-
-	/* Get the adjusted pll out value */
-	pll_out_khz = dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf);
-
-	/* Set the PLL division factors */
-	dsi_update_bits(dsi, DSI_WRPCR,	WRPCR_NDIV | WRPCR_IDF | WRPCR_ODF,
-			(ndiv << 2) | (idf << 11) | ((ffs(odf) - 1) << 16));
-
-	/* Compute uix4 & set the bit period in high-speed mode */
-	val = 4000000 / pll_out_khz;
-	dsi_update_bits(dsi, DSI_WPCR0, WPCR0_UIX4, val);
+		DRM_DEBUG_DRIVER("ERROR Could not set rate of %d to %s clk->name",
+				 pll_out_khz, clk_hw_get_name(&dsi->txbyte_clk));
 
 	/* Select video mode by resetting DSIM bit */
 	dsi_clear(dsi, DSI_WCFGR, WCFGR_DSIM);
@@ -322,6 +902,107 @@ dw_mipi_dsi_phy_get_timing(void *priv_data, unsigned int lane_mbps,
 	return 0;
 }
 
+struct hstt {
+	unsigned int maxfreq;
+	struct dw_mipi_dsi_dphy_timing timing;
+};
+
+#define HSTT(_maxfreq, _c_lp2hs, _c_hs2lp, _d_lp2hs, _d_hs2lp)	\
+{					\
+	.maxfreq = _maxfreq,		\
+	.timing = {			\
+		.clk_lp2hs = _c_lp2hs,	\
+		.clk_hs2lp = _c_hs2lp,	\
+		.data_lp2hs = _d_lp2hs,	\
+		.data_hs2lp = _d_hs2lp,	\
+	}				\
+}
+
+/* Table High-Speed Transition Times */
+struct hstt hstt_phy_141_table[] = {
+	HSTT(80, 21, 17, 15, 10),
+	HSTT(90, 23, 17, 16, 10),
+	HSTT(100, 22, 17, 16, 10),
+	HSTT(110, 25, 18, 17, 11),
+	HSTT(120, 26, 20, 18, 11),
+	HSTT(130, 27, 19, 19, 11),
+	HSTT(140, 27, 19, 19, 11),
+	HSTT(150, 28, 20, 20, 12),
+	HSTT(160, 30, 21, 22, 13),
+	HSTT(170, 30, 21, 23, 13),
+	HSTT(180, 31, 21, 23, 13),
+	HSTT(190, 32, 22, 24, 13),
+	HSTT(205, 35, 22, 25, 13),
+	HSTT(220, 37, 26, 27, 15),
+	HSTT(235, 38, 28, 27, 16),
+	HSTT(250, 41, 29, 30, 17),
+	HSTT(275, 43, 29, 32, 18),
+	HSTT(300, 45, 32, 35, 19),
+	HSTT(325, 48, 33, 36, 18),
+	HSTT(350, 51, 35, 40, 20),
+	HSTT(400, 59, 37, 44, 21),
+	HSTT(450, 65, 40, 49, 23),
+	HSTT(500, 71, 41, 54, 24),
+	HSTT(550, 77, 44, 57, 26),
+	HSTT(600, 82, 46, 64, 27),
+	HSTT(650, 87, 48, 67, 28),
+	HSTT(700, 94, 52, 71, 29),
+	HSTT(750, 99, 52, 75, 31),
+	HSTT(800, 105, 55, 82, 32),
+	HSTT(850, 110, 58, 85, 32),
+	HSTT(900, 115, 58, 88, 35),
+	HSTT(950, 120, 62, 93, 36),
+	HSTT(1000, 128, 63, 99, 38),
+	HSTT(1050, 132, 65, 102, 38),
+	HSTT(1100, 138, 67, 106, 39),
+	HSTT(1150, 146, 69, 112, 42),
+	HSTT(1200, 151, 71, 117, 43),
+	HSTT(1250, 153, 74, 120, 45),
+	HSTT(1300, 160, 73, 124, 46),
+	HSTT(1350, 165, 76, 130, 47),
+	HSTT(1400, 172, 78, 134, 49),
+	HSTT(1450, 177, 80, 138, 49),
+	HSTT(1500, 183, 81, 143, 52),
+	HSTT(1550, 191, 84, 147, 52),
+	HSTT(1600, 194, 85, 152, 52),
+	HSTT(1650, 201, 86, 155, 53),
+	HSTT(1700, 208, 88, 161, 53),
+	HSTT(1750, 212, 89, 165, 53),
+	HSTT(1800, 220, 90, 171, 54),
+	HSTT(1850, 223, 92, 175, 55),
+	HSTT(1900, 231, 91, 180, 56),
+	HSTT(1950, 236, 95, 185, 56),
+	HSTT(2000, 243, 97, 190, 58),
+	HSTT(2050, 248, 99, 194, 59),
+	HSTT(2100, 252, 100, 199, 61),
+	HSTT(2150, 259, 102, 204, 62),
+	HSTT(2200, 266, 105, 210, 63),
+	HSTT(2250, 269, 109, 213, 65),
+	HSTT(2300, 272, 109, 217, 66),
+	HSTT(2350, 281, 112, 225, 66),
+	HSTT(2400, 283, 115, 226, 67),
+	HSTT(2450, 282, 115, 226, 67),
+	HSTT(2500, 281, 118, 227, 68)
+};
+
+static int
+dw_mipi_dsi_phy_141_get_timing(void *priv_data, unsigned int lane_mbps,
+			       struct dw_mipi_dsi_dphy_timing *timing)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hstt_phy_141_table); i++)
+		if (lane_mbps < hstt_phy_141_table[i].maxfreq)
+			break;
+
+	if (i == ARRAY_SIZE(hstt_phy_141_table))
+		i--;
+
+	*timing = hstt_phy_141_table[i].timing;
+
+	return 0;
+}
+
 #define CLK_TOLERANCE_HZ 50
 
 static enum drm_mode_status
@@ -402,18 +1083,21 @@ dw_mipi_dsi_stm_mode_valid(void *priv_data,
 		}
 
 		lane_mbps = pll_out_khz / 1000;
-		ret = dw_mipi_dsi_phy_get_timing(priv_data, lane_mbps, &dphy_timing);
-		if (ret)
-			return MODE_ERROR;
-		/*
-		 * In non-burst mode DSI has to enter in LP during HFP
-		 * (horizontal front porch) or HBP (horizontal back porch) to
-		 * resync with LTDC pixel clock.
-		 */
-		delay_to_lp = DIV_ROUND_UP((dphy_timing.data_hs2lp + dphy_timing.data_lp2hs) *
-					   lanes * BITS_PER_BYTE, bpp);
-		if (hfp < delay_to_lp && hbp < delay_to_lp)
-			return MODE_HSYNC;
+
+		if (dsi->hw_version < HWVER_141) {
+			ret = dw_mipi_dsi_phy_get_timing(priv_data, lane_mbps, &dphy_timing);
+			if (ret)
+				return MODE_ERROR;
+			/*
+			 * In non-burst mode DSI has to enter in LP during HFP
+			 * (horizontal front porch) or HBP (horizontal back porch) to
+			 * resync with LTDC pixel clock.
+			 */
+			delay_to_lp = DIV_ROUND_UP((dphy_timing.data_hs2lp + dphy_timing.data_lp2hs)
+						   * lanes * BITS_PER_BYTE, bpp);
+			if (hfp < delay_to_lp && hbp < delay_to_lp)
+				return MODE_HSYNC;
+		}
 	}
 
 	return MODE_OK;
@@ -427,14 +1111,29 @@ static const struct dw_mipi_dsi_phy_ops dw_mipi_dsi_stm_phy_ops = {
 	.get_timing = dw_mipi_dsi_phy_get_timing,
 };
 
+static const struct dw_mipi_dsi_phy_ops dw_mipi_dsi_stm_phy_141_ops = {
+	.init = dw_mipi_dsi_phy_141_init,
+	.power_on = dw_mipi_dsi_phy_power_on,
+	.power_off = dw_mipi_dsi_phy_power_off,
+	.get_lane_mbps = dw_mipi_dsi_phy_141_get_lane_mbps,
+	.get_timing = dw_mipi_dsi_phy_141_get_timing,
+};
+
 static struct dw_mipi_dsi_plat_data dw_mipi_dsi_stm_plat_data = {
 	.max_data_lanes = 2,
 	.mode_valid = dw_mipi_dsi_stm_mode_valid,
 	.phy_ops = &dw_mipi_dsi_stm_phy_ops,
 };
 
+static struct dw_mipi_dsi_plat_data dw_mipi_dsi_stm32mp25_plat_data = {
+	.max_data_lanes = 4,
+	.mode_valid = dw_mipi_dsi_stm_mode_valid,
+	.phy_ops = &dw_mipi_dsi_stm_phy_141_ops,
+};
+
 static const struct of_device_id dw_mipi_dsi_stm_dt_ids[] = {
 	{ .compatible = "st,stm32-dsi", .data = &dw_mipi_dsi_stm_plat_data, },
+	{ .compatible = "st,stm32mp25-dsi", .data = &dw_mipi_dsi_stm32mp25_plat_data, },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, dw_mipi_dsi_stm_dt_ids);
@@ -443,94 +1142,157 @@ static int dw_mipi_dsi_stm_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct dw_mipi_dsi_stm *dsi;
-	struct clk *pclk;
-	struct resource *res;
+	const struct dw_mipi_dsi_plat_data *pdata = of_device_get_match_data(dev);
 	int ret;
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
 	if (!dsi)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dsi->base = devm_ioremap_resource(dev, res);
+	dsi->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(dsi->base)) {
 		ret = PTR_ERR(dsi->base);
 		DRM_ERROR("Unable to get dsi registers %d\n", ret);
 		return ret;
 	}
 
-	dsi->vdd_supply = devm_regulator_get(dev, "phy-dsi");
-	if (IS_ERR(dsi->vdd_supply)) {
-		ret = PTR_ERR(dsi->vdd_supply);
-		dev_err_probe(dev, ret, "Failed to request regulator\n");
-		return ret;
+	if (of_device_is_compatible(dev->of_node, "st,stm32-dsi")) {
+		dsi->vdd_supply = devm_regulator_get(dev, "phy-dsi");
+		if (IS_ERR(dsi->vdd_supply)) {
+			ret = PTR_ERR(dsi->vdd_supply);
+			dev_err_probe(dev, ret, "Failed to request regulator\n");
+			return ret;
+		}
+
+		ret = regulator_enable(dsi->vdd_supply);
+		if (ret) {
+			DRM_ERROR("Failed to enable regulator vdd: %d\n", ret);
+			return ret;
+		}
 	}
 
-	ret = regulator_enable(dsi->vdd_supply);
-	if (ret) {
-		DRM_ERROR("Failed to enable regulator: %d\n", ret);
-		return ret;
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-dsi")) {
+		dsi->vdd_supply = devm_regulator_get(dev, "vdd");
+		if (IS_ERR(dsi->vdd_supply)) {
+			ret = PTR_ERR(dsi->vdd_supply);
+			dev_err_probe(dev, ret, "Failed to request regulator\n");
+			return ret;
+		}
+
+		ret = regulator_enable(dsi->vdd_supply);
+		if (ret) {
+			DRM_ERROR("Failed to enable regulator vdd: %d\n", ret);
+			return ret;
+		}
+
+		dsi->vdda18_supply = devm_regulator_get(dev, "vdda18");
+		if (IS_ERR(dsi->vdda18_supply)) {
+			ret = PTR_ERR(dsi->vdda18_supply);
+			dev_err_probe(dev, ret, "Failed to request regulator\n");
+			goto err_clk_get;
+		}
+
+		ret = regulator_enable(dsi->vdda18_supply);
+		if (ret) {
+			DRM_ERROR("Failed to enable regulator vdda18: %d\n", ret);
+			return ret;
+		}
 	}
 
 	dsi->pllref_clk = devm_clk_get(dev, "ref");
 	if (IS_ERR(dsi->pllref_clk)) {
 		ret = PTR_ERR(dsi->pllref_clk);
 		dev_err_probe(dev, ret, "Unable to get pll reference clock\n");
-		goto err_clk_get;
-	}
-
-	ret = clk_prepare_enable(dsi->pllref_clk);
-	if (ret) {
-		DRM_ERROR("Failed to enable pllref_clk: %d\n", ret);
-		goto err_clk_get;
+		goto err_regu_enable;
 	}
 
-	pclk = devm_clk_get(dev, "pclk");
-	if (IS_ERR(pclk)) {
-		ret = PTR_ERR(pclk);
+	dsi->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(dsi->pclk)) {
+		ret = PTR_ERR(dsi->pclk);
 		DRM_ERROR("Unable to get peripheral clock: %d\n", ret);
-		goto err_dsi_probe;
+		goto err_regu_enable;
 	}
 
-	ret = clk_prepare_enable(pclk);
+	ret = clk_prepare_enable(dsi->pclk);
 	if (ret) {
 		DRM_ERROR("%s: Failed to enable peripheral clk\n", __func__);
-		goto err_dsi_probe;
+		goto err_regu_enable;
 	}
 
 	dsi->hw_version = dsi_read(dsi, DSI_VERSION) & VERSION;
-	clk_disable_unprepare(pclk);
 
-	if (dsi->hw_version != HWVER_130 && dsi->hw_version != HWVER_131) {
+	if (dsi->hw_version != HWVER_130 &&
+	    dsi->hw_version != HWVER_131 &&
+	    dsi->hw_version != HWVER_141) {
 		ret = -ENODEV;
 		DRM_ERROR("bad dsi hardware version\n");
 		goto err_dsi_probe;
 	}
 
-	/* set lane capabilities according to hw version */
-	dsi->lane_min_kbps = LANE_MIN_KBPS;
-	dsi->lane_max_kbps = LANE_MAX_KBPS;
-	if (dsi->hw_version == HWVER_131) {
-		dsi->lane_min_kbps *= 2;
-		dsi->lane_max_kbps *= 2;
+	/* Update lane capabilities according to hw version */
+	switch (dsi->hw_version) {
+	case HWVER_141:
+		dsi->lane_min_kbps = LANE_MIN_PHY_141_KBPS;
+		dsi->lane_max_kbps = LANE_MAX_PHY_141_KBPS;
+	break;
+	case HWVER_131:
+		dsi->lane_min_kbps = 2 * LANE_MIN_KBPS;
+		dsi->lane_max_kbps = 2 * LANE_MAX_KBPS;
+	break;
+	default:
+		dsi->lane_min_kbps = LANE_MIN_KBPS;
+		dsi->lane_max_kbps = LANE_MAX_KBPS;
+	break;
 	}
 
-	dw_mipi_dsi_stm_plat_data.base = dsi->base;
-	dw_mipi_dsi_stm_plat_data.priv_data = dsi;
+	dsi->pdata = *pdata;
+	dsi->pdata.base = dsi->base;
+	dsi->pdata.priv_data = dsi;
 
 	platform_set_drvdata(pdev, dsi);
 
-	dsi->dsi = dw_mipi_dsi_probe(pdev, &dw_mipi_dsi_stm_plat_data);
+	dsi->dsi = dw_mipi_dsi_probe(pdev, &dsi->pdata);
 	if (IS_ERR(dsi->dsi)) {
 		ret = PTR_ERR(dsi->dsi);
 		dev_err_probe(dev, ret, "Failed to initialize mipi dsi host\n");
 		goto err_dsi_probe;
 	}
 
+	ret = dw_mipi_dsi_clk_register(dsi, dev);
+	if (ret) {
+		DRM_ERROR("Failed to register DSI pixel clock: %d\n", ret);
+		goto err_dsi_probe;
+	}
+
+	dsi->px_clk = devm_clk_get(dev, "px_clk");
+	/* No need to return since only MP25 has it */
+	if (IS_ERR(dsi->px_clk))
+		dev_err_probe(dev, PTR_ERR(dsi->px_clk), "Unable to get px_clk clock\n");
+
+	dsi->probe_done = true;
+
+	/*
+	 * To obtain a continuous display after the probe, the txbyte clock must
+	 * remain activated
+	 */
+	if (device_property_read_bool(dev, "default-on")) {
+		ret = clk_prepare_enable(dsi->txbyte_clk.clk);
+		if (ret) {
+			DRM_ERROR("Failed to enable DSI pixel clock: %d\n", ret);
+			goto err_dsi_probe;
+		}
+	}
+
+	clk_disable_unprepare(dsi->pclk);
+	regulator_disable(dsi->vdd_supply);
+
 	return 0;
 
 err_dsi_probe:
-	clk_disable_unprepare(dsi->pllref_clk);
+	clk_disable_unprepare(dsi->pclk);
+err_regu_enable:
+	if (dsi->vdda18_supply)
+		regulator_disable(dsi->vdda18_supply);
 err_clk_get:
 	regulator_disable(dsi->vdd_supply);
 
@@ -542,40 +1304,64 @@ static int dw_mipi_dsi_stm_remove(struct platform_device *pdev)
 	struct dw_mipi_dsi_stm *dsi = platform_get_drvdata(pdev);
 
 	dw_mipi_dsi_remove(dsi->dsi);
-	clk_disable_unprepare(dsi->pllref_clk);
-	regulator_disable(dsi->vdd_supply);
+	dw_mipi_dsi_clk_unregister(dsi);
 
 	return 0;
 }
 
 static int __maybe_unused dw_mipi_dsi_stm_suspend(struct device *dev)
 {
-	struct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;
+	struct dw_mipi_dsi_stm *dsi = dev_get_drvdata(dev);
 
 	DRM_DEBUG_DRIVER("\n");
 
 	clk_disable_unprepare(dsi->pllref_clk);
+	clk_disable_unprepare(dsi->pclk);
 	regulator_disable(dsi->vdd_supply);
+	if (dsi->vdda18_supply)
+		regulator_disable(dsi->vdda18_supply);
 
 	return 0;
 }
 
 static int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)
 {
-	struct dw_mipi_dsi_stm *dsi = dw_mipi_dsi_stm_plat_data.priv_data;
+	struct dw_mipi_dsi_stm *dsi = dev_get_drvdata(dev);
 	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
 
+	if (dsi->vdda18_supply) {
+		ret = regulator_enable(dsi->vdda18_supply);
+		if (ret) {
+			DRM_ERROR("Failed to enable regulator vdda18: %d\n", ret);
+			return ret;
+		}
+	}
+
 	ret = regulator_enable(dsi->vdd_supply);
 	if (ret) {
-		DRM_ERROR("Failed to enable regulator: %d\n", ret);
+		if (dsi->vdda18_supply)
+			regulator_disable(dsi->vdda18_supply);
+		DRM_ERROR("Failed to enable regulator vdd: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(dsi->pclk);
+	if (ret) {
+		regulator_disable(dsi->vdd_supply);
+		if (dsi->vdda18_supply)
+			regulator_disable(dsi->vdda18_supply);
+		DRM_ERROR("Failed to enable pclk: %d\n", ret);
 		return ret;
 	}
 
 	ret = clk_prepare_enable(dsi->pllref_clk);
 	if (ret) {
+		clk_disable_unprepare(dsi->pclk);
 		regulator_disable(dsi->vdd_supply);
+		if (dsi->vdda18_supply)
+			regulator_disable(dsi->vdda18_supply);
 		DRM_ERROR("Failed to enable pllref_clk: %d\n", ret);
 		return ret;
 	}
@@ -584,8 +1370,10 @@ static int __maybe_unused dw_mipi_dsi_stm_resume(struct device *dev)
 }
 
 static const struct dev_pm_ops dw_mipi_dsi_stm_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(dw_mipi_dsi_stm_suspend,
-				dw_mipi_dsi_stm_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(dw_mipi_dsi_stm_suspend,
+			   dw_mipi_dsi_stm_resume, NULL)
 };
 
 static struct platform_driver dw_mipi_dsi_stm_driver = {
@@ -600,7 +1388,8 @@ static struct platform_driver dw_mipi_dsi_stm_driver = {
 
 module_platform_driver(dw_mipi_dsi_stm_driver);
 
-MODULE_AUTHOR("Philippe Cornu <philippe.cornu@st.com>");
-MODULE_AUTHOR("Yannick Fertre <yannick.fertre@st.com>");
+MODULE_AUTHOR("Philippe Cornu <philippe.cornu@foss.st.com>");
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_AUTHOR("Raphal Gallais-Pou <raphael.gallais-pou@foss.st.com>");
 MODULE_DESCRIPTION("STMicroelectronics DW MIPI DSI host controller driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/stm/ltdc.c b/drivers/gpu/drm/stm/ltdc.c
index b8be4c1db..2be0b1a48 100644
--- a/drivers/gpu/drm/stm/ltdc.c
+++ b/drivers/gpu/drm/stm/ltdc.c
@@ -15,7 +15,9 @@
 #include <linux/media-bus-format.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
+#include <linux/of_device.h>
 #include <linux/of_graph.h>
+#include <linux/of_reserved_mem.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
@@ -34,10 +36,16 @@
 #include <drm/drm_gem_atomic_helper.h>
 #include <drm/drm_gem_dma_helper.h>
 #include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_plane_helper.h>
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_simple_kms_helper.h>
 #include <drm/drm_vblank.h>
 
+/* Temporary (wait to firewall interface) */
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+#include "../../../bus/stm32_sys_bus.h"
+
 #include <video/videomode.h>
 
 #include "ltdc.h"
@@ -51,6 +59,7 @@
 #define HWVER_10300 0x010300
 #define HWVER_20101 0x020101
 #define HWVER_40100 0x040100
+#define HWVER_40101 0x040101
 
 /*
  * The address of some registers depends on the HW version: such registers have
@@ -81,6 +90,10 @@
 #define LTDC_CDSR	0x0048		/* Current Display Status */
 #define LTDC_EDCR	0x0060		/* External Display Control */
 #define LTDC_CCRCR	0x007C		/* Computed CRC value */
+#define LTDC_RB0AR	0x0080		/* Rotation Buffer 0 address */
+#define LTDC_RB1AR	0x0084		/* Rotation Buffer 1 address */
+#define LTDC_RBPR	0x0088		/* Rotation Buffer Pitch */
+#define LTDC_RIFCR	0x008C		/* Rotation Intermediate Frame Color */
 #define LTDC_FUT	0x0090		/* Fifo underrun Threshold */
 
 /* Layer register offsets */
@@ -105,10 +118,16 @@
 #define LTDC_L1AFBLR	(ldev->caps.layer_regs[18])	/* L1 auxiliary frame buffer length */
 #define LTDC_L1AFBLNR	(ldev->caps.layer_regs[19])	/* L1 auxiliary frame buffer line number */
 #define LTDC_L1CLUTWR	(ldev->caps.layer_regs[20])	/* L1 CLUT write */
-#define LTDC_L1CYR0R	(ldev->caps.layer_regs[21])	/* L1 Conversion YCbCr RGB 0 */
-#define LTDC_L1CYR1R	(ldev->caps.layer_regs[22])	/* L1 Conversion YCbCr RGB 1 */
-#define LTDC_L1FPF0R	(ldev->caps.layer_regs[23])	/* L1 Flexible Pixel Format 0 */
-#define LTDC_L1FPF1R	(ldev->caps.layer_regs[24])	/* L1 Flexible Pixel Format 1 */
+#define LTDC_L1SISR	(ldev->caps.layer_regs[21])	/* L1 scaler input size */
+#define LTDC_L1SOSR	(ldev->caps.layer_regs[22])	/* L1 scaler output size */
+#define LTDC_L1SVSFR	(ldev->caps.layer_regs[23])	/* L1 scaler vertical scaling factor */
+#define LTDC_L1SVSPR	(ldev->caps.layer_regs[24])	/* L1 scaler vertical scaling phase */
+#define LTDC_L1SHSFR	(ldev->caps.layer_regs[25])	/* L1 scaler horizontal scaling factor */
+#define LTDC_L1SHSPR	(ldev->caps.layer_regs[26])	/* L1 scaler horizontal scaling phase */
+#define LTDC_L1CYR0R	(ldev->caps.layer_regs[27])	/* L1 Conversion YCbCr RGB 0 */
+#define LTDC_L1CYR1R	(ldev->caps.layer_regs[28])	/* L1 Conversion YCbCr RGB 1 */
+#define LTDC_L1FPF0R	(ldev->caps.layer_regs[29])	/* L1 Flexible Pixel Format 0 */
+#define LTDC_L1FPF1R	(ldev->caps.layer_regs[30])	/* L1 Flexible Pixel Format 1 */
 
 /* Bit definitions */
 #define SSCR_VSH	GENMASK(10, 0)	/* Vertical Synchronization Height */
@@ -124,6 +143,7 @@
 #define TWCR_TOTALW	GENMASK(27, 16)	/* TOTAL Width */
 
 #define GCR_LTDCEN	BIT(0)		/* LTDC ENable */
+#define GCR_ROTEN	BIT(2)		/* ROTation ENable */
 #define GCR_DEN		BIT(16)		/* Dither ENable */
 #define GCR_CRCEN	BIT(19)		/* CRC ENable */
 #define GCR_PCPOL	BIT(28)		/* Pixel Clock POLarity-Inverted */
@@ -154,6 +174,7 @@
 #define GC2R_DPAEN	BIT(3)		/* Dual-Port Ability ENabled */
 #define GC2R_BW		GENMASK(6, 4)	/* Bus Width (log2 of nb of bytes) */
 #define GC2R_EDCEN	BIT(7)		/* External Display Control ENabled */
+#define GC2R_ROTA	BIT(10)		/* ROTAtion support ability */
 
 #define SRCR_IMR	BIT(0)		/* IMmediate Reload */
 #define SRCR_VBR	BIT(1)		/* Vertical Blanking Reload */
@@ -164,12 +185,20 @@
 #define BCCR_BCRED	GENMASK(23, 16)	/* Background Color RED */
 #define BCCR_BCWHITE	GENMASK(23, 0)	/* Background Color WHITE */
 
+#define DCCR_DCBLACK	0x00		/* Default Color BLACK */
+#define DCCR_DCBLUE	GENMASK(7, 0)	/* Default Color BLUE */
+#define DCCR_DCGREEN	GENMASK(15, 8)	/* Default Color GREEN */
+#define DCCR_DCRED	GENMASK(23, 16)	/* Default Color RED */
+#define DCCR_DCWHITE	GENMASK(23, 0)	/* Default Color WHITE */
+
 #define IER_LIE		BIT(0)		/* Line Interrupt Enable */
 #define IER_FUWIE	BIT(1)		/* Fifo Underrun Warning Interrupt Enable */
 #define IER_TERRIE	BIT(2)		/* Transfer ERRor Interrupt Enable */
 #define IER_RRIE	BIT(3)		/* Register Reload Interrupt Enable */
 #define IER_FUEIE	BIT(6)		/* Fifo Underrun Error Interrupt Enable */
 #define IER_CRCIE	BIT(7)		/* CRC Error Interrupt Enable */
+#define IER_FURIE	BIT(8)		/* Fifo Underrun Rotation Interrupt Enable */
+#define IER_MASK (IER_LIE | IER_FUWIE | IER_TERRIE | IER_RRIE | IER_FUEIE | IER_CRCIE | IER_FURIE)
 
 #define CPSR_CYPOS	GENMASK(15, 0)	/* Current Y position */
 
@@ -179,6 +208,7 @@
 #define ISR_RRIF	BIT(3)		/* Register Reload Interrupt Flag */
 #define ISR_FUEIF	BIT(6)		/* Fifo Underrun Error Interrupt Flag */
 #define ISR_CRCIF	BIT(7)		/* CRC Error Interrupt Flag */
+#define ISR_FURIF	BIT(8)		/* Fifo Underrun Rotation Interrupt Flag */
 
 #define EDCR_OCYEN	BIT(25)		/* Output Conversion to YCbCr 422: ENable */
 #define EDCR_OCYSEL	BIT(26)		/* Output Conversion to YCbCr 422: SELection of the CCIR */
@@ -188,6 +218,8 @@
 #define LXCR_COLKEN	BIT(1)		/* Color Keying Enable */
 #define LXCR_CLUTEN	BIT(4)		/* Color Look-Up Table ENable */
 #define LXCR_HMEN	BIT(8)		/* Horizontal Mirroring ENable */
+#define LXCR_SCEN	BIT(10)		/* SCaler ENable */
+#define LXCR_MASK (LXCR_LEN | LXCR_COLKEN | LXCR_CLUTEN | LXCR_HMEN | LXCR_SCEN)
 
 #define LXWHPCR_WHSTPOS	GENMASK(11, 0)	/* Window Horizontal StarT POSition */
 #define LXWHPCR_WHSPPOS	GENMASK(27, 16)	/* Window Horizontal StoP POSition */
@@ -389,6 +421,12 @@ static const u32 ltdc_layer_regs_a0[] = {
 	0x00,	/* not available */
 	0x00,	/* not available */
 	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
 	0x00	/* not available */
 };
 
@@ -417,6 +455,12 @@ static const u32 ltdc_layer_regs_a1[] = {
 	0x00,	/* not available */
 	0x00,	/* not available */
 	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
+	0x00,	/* not available */
 	0x00	/* not available */
 };
 
@@ -442,6 +486,12 @@ static const u32 ltdc_layer_regs_a2[] = {
 	0x148,	/* L1 auxiliary frame buffer length */
 	0x14c,	/* L1 auxiliary frame buffer line number */
 	0x150,	/* L1 CLUT write */
+	0x154,	/* L1 scaler input size */
+	0x158,	/* L1 scaler output size */
+	0x15c,	/* L1 scaler vertical scaling factor */
+	0x160,	/* L1 scaler vertical scaling phase */
+	0x164,	/* L1 scaler horizontal scaling factor */
+	0x168,	/* L1 scaler horizontal scaling phase */
 	0x16c,	/* L1 Conversion YCbCr RGB 0 */
 	0x170,	/* L1 Conversion YCbCr RGB 1 */
 	0x174,	/* L1 Flexible Pixel Format 0 */
@@ -453,7 +503,7 @@ static const u64 ltdc_format_modifiers[] = {
 	DRM_FORMAT_MOD_INVALID
 };
 
-static const struct regmap_config stm32_ltdc_regmap_cfg = {
+static struct regmap_config stm32_ltdc_regmap_cfg = {
 	.reg_bits = 32,
 	.val_bits = 32,
 	.reg_stride = sizeof(u32),
@@ -685,26 +735,6 @@ static inline void ltdc_set_ycbcr_coeffs(struct drm_plane *plane)
 		     ltdc_ycbcr2rgb_coeffs[enc][ran][1]);
 }
 
-static inline void ltdc_irq_crc_handle(struct ltdc_device *ldev,
-				       struct drm_crtc *crtc)
-{
-	u32 crc;
-	int ret;
-
-	if (ldev->crc_skip_count < CRC_SKIP_FRAMES) {
-		ldev->crc_skip_count++;
-		return;
-	}
-
-	/* Get the CRC of the frame */
-	ret = regmap_read(ldev->regmap, LTDC_CCRCR, &crc);
-	if (ret)
-		return;
-
-	/* Report to DRM the CRC (hw dependent feature) */
-	drm_crtc_add_crc_entry(crtc, true, drm_crtc_accurate_vblank_count(crtc), &crc);
-}
-
 static irqreturn_t ltdc_irq_thread(int irq, void *arg)
 {
 	struct drm_device *ddev = arg;
@@ -713,11 +743,18 @@ static irqreturn_t ltdc_irq_thread(int irq, void *arg)
 
 	/* Line IRQ : trigger the vblank event */
 	if (ldev->irq_status & ISR_LIF) {
-		drm_crtc_handle_vblank(crtc);
-
-		/* Early return if CRC is not active */
-		if (ldev->crc_active)
-			ltdc_irq_crc_handle(ldev, crtc);
+		if (ldev->vblank_active)
+			drm_crtc_handle_vblank(crtc);
+
+		if (ldev->crc_active) {
+			if (ldev->crc_skip_count < CRC_SKIP_FRAMES)
+				ldev->crc_skip_count++;
+			else
+				/* Report to DRM the CRC (hw dependent feature) */
+				drm_crtc_add_crc_entry(crtc, true,
+						       drm_crtc_accurate_vblank_count(crtc),
+						       &ldev->crc);
+		}
 	}
 
 	mutex_lock(&ldev->err_lock);
@@ -727,6 +764,8 @@ static irqreturn_t ltdc_irq_thread(int irq, void *arg)
 		ldev->fifo_err++;
 	if (ldev->irq_status & ISR_FUWIF)
 		ldev->fifo_warn++;
+	if (ldev->irq_status & ISR_FURIF)
+		ldev->fifo_rot++;
 	mutex_unlock(&ldev->err_lock);
 
 	return IRQ_HANDLED;
@@ -744,6 +783,8 @@ static irqreturn_t ltdc_irq(int irq, void *arg)
 	 */
 	ldev->irq_status = readl_relaxed(ldev->regs + LTDC_ISR);
 	writel_relaxed(ldev->irq_status, ldev->regs + LTDC_ICR);
+	if (ldev->crc_active)
+		ldev->crc = readl_relaxed(ldev->regs + LTDC_CCRCR);
 
 	return IRQ_WAKE_THREAD;
 }
@@ -752,143 +793,8 @@ static irqreturn_t ltdc_irq(int irq, void *arg)
  * DRM_CRTC
  */
 
-static void ltdc_crtc_update_clut(struct drm_crtc *crtc)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	struct drm_color_lut *lut;
-	u32 val;
-	int i;
-
-	if (!crtc->state->color_mgmt_changed || !crtc->state->gamma_lut)
-		return;
-
-	lut = (struct drm_color_lut *)crtc->state->gamma_lut->data;
-
-	for (i = 0; i < CLUT_SIZE; i++, lut++) {
-		val = ((lut->red << 8) & 0xff0000) | (lut->green & 0xff00) |
-			(lut->blue >> 8) | (i << 24);
-		regmap_write(ldev->regmap, LTDC_L1CLUTWR, val);
-	}
-}
-
 static void ltdc_crtc_atomic_enable(struct drm_crtc *crtc,
 				    struct drm_atomic_state *state)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	struct drm_device *ddev = crtc->dev;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	pm_runtime_get_sync(ddev->dev);
-
-	/* Sets the background color value */
-	regmap_write(ldev->regmap, LTDC_BCCR, BCCR_BCBLACK);
-
-	/* Enable IRQ */
-	regmap_set_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_RRIE | IER_TERRIE);
-
-	/* Commit shadow registers = update planes at next vblank */
-	if (!ldev->caps.plane_reg_shadow)
-		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);
-
-	drm_crtc_vblank_on(crtc);
-}
-
-static void ltdc_crtc_atomic_disable(struct drm_crtc *crtc,
-				     struct drm_atomic_state *state)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	struct drm_device *ddev = crtc->dev;
-	int layer_index = 0;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	drm_crtc_vblank_off(crtc);
-
-	/* Disable all layers */
-	for (layer_index = 0; layer_index < ldev->caps.nb_layers; layer_index++)
-		regmap_write_bits(ldev->regmap, LTDC_L1CR + layer_index * LAY_OFS,
-				  LXCR_CLUTEN | LXCR_LEN, 0);
-
-	/* disable IRQ */
-	regmap_clear_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_RRIE | IER_TERRIE);
-
-	/* immediately commit disable of layers before switching off LTDC */
-	if (!ldev->caps.plane_reg_shadow)
-		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_IMR);
-
-	pm_runtime_put_sync(ddev->dev);
-
-	/*  clear interrupt error counters */
-	mutex_lock(&ldev->err_lock);
-	ldev->transfer_err = 0;
-	ldev->fifo_err = 0;
-	ldev->fifo_warn = 0;
-	mutex_unlock(&ldev->err_lock);
-}
-
-#define CLK_TOLERANCE_HZ 50
-
-static enum drm_mode_status
-ltdc_crtc_mode_valid(struct drm_crtc *crtc,
-		     const struct drm_display_mode *mode)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	int target = mode->clock * 1000;
-	int target_min = target - CLK_TOLERANCE_HZ;
-	int target_max = target + CLK_TOLERANCE_HZ;
-	int result;
-
-	result = clk_round_rate(ldev->pixel_clk, target);
-
-	DRM_DEBUG_DRIVER("clk rate target %d, available %d\n", target, result);
-
-	/* Filter modes according to the max frequency supported by the pads */
-	if (result > ldev->caps.pad_max_freq_hz)
-		return MODE_CLOCK_HIGH;
-
-	/*
-	 * Accept all "preferred" modes:
-	 * - this is important for panels because panel clock tolerances are
-	 *   bigger than hdmi ones and there is no reason to not accept them
-	 *   (the fps may vary a little but it is not a problem).
-	 * - the hdmi preferred mode will be accepted too, but userland will
-	 *   be able to use others hdmi "valid" modes if necessary.
-	 */
-	if (mode->type & DRM_MODE_TYPE_PREFERRED)
-		return MODE_OK;
-
-	/*
-	 * Filter modes according to the clock value, particularly useful for
-	 * hdmi modes that require precise pixel clocks.
-	 */
-	if (result < target_min || result > target_max)
-		return MODE_CLOCK_RANGE;
-
-	return MODE_OK;
-}
-
-static bool ltdc_crtc_mode_fixup(struct drm_crtc *crtc,
-				 const struct drm_display_mode *mode,
-				 struct drm_display_mode *adjusted_mode)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	int rate = mode->clock * 1000;
-
-	if (clk_set_rate(ldev->pixel_clk, rate) < 0) {
-		DRM_ERROR("Cannot set rate (%dHz) for pixel clk\n", rate);
-		return false;
-	}
-
-	adjusted_mode->clock = clk_get_rate(ldev->pixel_clk) / 1000;
-
-	DRM_DEBUG_DRIVER("requested clock %dkHz, adjusted clock %dkHz\n",
-			 mode->clock, adjusted_mode->clock);
-
-	return true;
-}
-
-static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 {
 	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 	struct drm_device *ddev = crtc->dev;
@@ -897,13 +803,15 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	struct drm_encoder *encoder = NULL, *en_iter;
 	struct drm_bridge *bridge = NULL, *br_iter;
 	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
-	u32 hsync, vsync, accum_hbp, accum_vbp, accum_act_w, accum_act_h;
-	u32 total_width, total_height;
+	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
 	u32 bus_formats = MEDIA_BUS_FMT_RGB888_1X24;
 	u32 bus_flags = 0;
+	u32 pitch, rota0_buf, rota1_buf;
 	u32 val;
 	int ret;
 
+	DRM_DEBUG_DRIVER("\n");
+
 	/* get encoder from crtc */
 	drm_for_each_encoder(en_iter, ddev)
 		if (en_iter->crtc == crtc) {
@@ -933,6 +841,8 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 		bus_flags = connector->display_info.bus_flags;
 		if (connector->display_info.num_bus_formats)
 			bus_formats = connector->display_info.bus_formats[0];
+
+		orientation = connector->display_info.panel_orientation;
 	}
 
 	if (!pm_runtime_active(ddev->dev)) {
@@ -943,26 +853,6 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 		}
 	}
 
-	DRM_DEBUG_DRIVER("CRTC:%d mode:%s\n", crtc->base.id, mode->name);
-	DRM_DEBUG_DRIVER("Video mode: %dx%d", mode->hdisplay, mode->vdisplay);
-	DRM_DEBUG_DRIVER(" hfp %d hbp %d hsl %d vfp %d vbp %d vsl %d\n",
-			 mode->hsync_start - mode->hdisplay,
-			 mode->htotal - mode->hsync_end,
-			 mode->hsync_end - mode->hsync_start,
-			 mode->vsync_start - mode->vdisplay,
-			 mode->vtotal - mode->vsync_end,
-			 mode->vsync_end - mode->vsync_start);
-
-	/* Convert video timings to ltdc timings */
-	hsync = mode->hsync_end - mode->hsync_start - 1;
-	vsync = mode->vsync_end - mode->vsync_start - 1;
-	accum_hbp = mode->htotal - mode->hsync_start - 1;
-	accum_vbp = mode->vtotal - mode->vsync_start - 1;
-	accum_act_w = accum_hbp + mode->hdisplay;
-	accum_act_h = accum_vbp + mode->vdisplay;
-	total_width = mode->htotal - 1;
-	total_height = mode->vtotal - 1;
-
 	/* Configures the HS, VS, DE and PC polarities. Default Active Low */
 	val = 0;
 
@@ -978,26 +868,11 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 	if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)
 		val |= GCR_PCPOL;
 
-	regmap_update_bits(ldev->regmap, LTDC_GCR,
-			   GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL, val);
-
-	/* Set Synchronization size */
-	val = (hsync << 16) | vsync;
-	regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
-
-	/* Set Accumulated Back porch */
-	val = (accum_hbp << 16) | accum_vbp;
-	regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
-
-	/* Set Accumulated Active Width */
-	val = (accum_act_w << 16) | accum_act_h;
-	regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+	if (connector && connector->state->dithering == DRM_MODE_DITHERING_ON)
+		val |= GCR_DEN;
 
-	/* Set total width & height */
-	val = (total_width << 16) | total_height;
-	regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
-
-	regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_h + 1));
+	regmap_update_bits(ldev->regmap, LTDC_GCR,
+			   GCR_HSPOL | GCR_VSPOL | GCR_DEPOL | GCR_PCPOL | GCR_DEN, val);
 
 	/* Configure the output format (hw version dependent) */
 	if (ldev->caps.ycbcr_output) {
@@ -1028,73 +903,346 @@ static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
 			break;
 		}
 	}
-}
 
-static void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,
-				   struct drm_atomic_state *state)
-{
-	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
-	struct drm_device *ddev = crtc->dev;
-	struct drm_pending_vblank_event *event = crtc->state->event;
+	/* check that an output rotation is required */
+	if (ldev->caps.crtc_rotation &&
+	    (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP ||
+	     orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP)) {
+		/*
+		 * Size of the rotation buffer must be larger than the size
+		 * of two frames (format RGB24).
+		 */
+		if (ldev->rot_mem->size < mode->hdisplay * mode->vdisplay * 2 * 3) {
+			DRM_WARN("Rotation buffer too small");
+			return;
+		}
 
-	DRM_DEBUG_ATOMIC("\n");
+		/* The width of the framebuffer must not exceed 1366 pixels */
+		if (mode->vdisplay > 1366)
+			return;
+
+		rota0_buf = (u32)ldev->rot_mem->base;
+		rota1_buf = (u32)ldev->rot_mem->base + (ldev->rot_mem->size >> 1);
+
+		regmap_write(ldev->regmap, LTDC_RB0AR, rota0_buf);
+		regmap_write(ldev->regmap, LTDC_RB1AR, rota1_buf);
+
+		/*
+		 * LTDC_RBPR register is used define the pitch (line-to-line address increment)
+		 * of the stored rotation buffer. The pitch is proportional to the width of the
+		 * composed display (before rotation) and,(after rotation) proportional to the
+		 * non-raster dimension of the display panel.
+		 */
+		pitch = ((mode->hdisplay + 9) / 10) * 64;
+		regmap_write(ldev->regmap, LTDC_RBPR, pitch);
 
-	ltdc_crtc_update_clut(crtc);
+		DRM_DEBUG_DRIVER("Rotation buffer0 address %x\n", rota0_buf);
+		DRM_DEBUG_DRIVER("Rotation buffer1 address %x\n", rota1_buf);
+		DRM_DEBUG_DRIVER("Rotation buffer picth %x\n", pitch);
+
+		if (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP ||
+		    orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP)
+			regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_ROTEN);
+		else
+			regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_ROTEN);
+	}
+
+	/* Sets the background color value */
+	regmap_write(ldev->regmap, LTDC_BCCR, BCCR_BCBLACK);
+
+	/* Enable error IRQ */
+	regmap_set_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_TERRIE);
+
+	if (ldev->caps.crtc_rotation)
+		regmap_set_bits(ldev->regmap, LTDC_IER, IER_FURIE);
 
 	/* Commit shadow registers = update planes at next vblank */
 	if (!ldev->caps.plane_reg_shadow)
 		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);
 
-	if (event) {
-		crtc->state->event = NULL;
+	drm_crtc_vblank_on(crtc);
 
-		spin_lock_irq(&ddev->event_lock);
-		if (drm_crtc_vblank_get(crtc) == 0)
-			drm_crtc_arm_vblank_event(crtc, event);
-		else
-			drm_crtc_send_vblank_event(crtc, event);
-		spin_unlock_irq(&ddev->event_lock);
-	}
+	/* set fifo underrun threshold register */
+	if (ldev->caps.fifo_threshold)
+		regmap_write(ldev->regmap, LTDC_FUT, ldev->fifo_threshold);
+
+	/* Enable LTDC */
+	regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
 }
 
-static bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,
-					   bool in_vblank_irq,
-					   int *vpos, int *hpos,
-					   ktime_t *stime, ktime_t *etime,
-					   const struct drm_display_mode *mode)
+static void ltdc_crtc_atomic_disable(struct drm_crtc *crtc,
+				     struct drm_atomic_state *state)
 {
+	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 	struct drm_device *ddev = crtc->dev;
-	struct ltdc_device *ldev = ddev->dev_private;
-	int line, vactive_start, vactive_end, vtotal;
+	int layer_index = 0;
+	int ret;
 
-	if (stime)
-		*stime = ktime_get();
+	DRM_DEBUG_DRIVER("\n");
 
-	/* The active area starts after vsync + front porch and ends
-	 * at vsync + front porc + display size.
-	 * The total height also include back porch.
-	 * We have 3 possible cases to handle:
-	 * - line < vactive_start: vpos = line - vactive_start and will be
-	 * negative
-	 * - vactive_start < line < vactive_end: vpos = line - vactive_start
-	 * and will be positive
-	 * - line > vactive_end: vpos = line - vtotal - vactive_start
-	 * and will negative
-	 *
-	 * Computation for the two first cases are identical so we can
-	 * simplify the code and only test if line > vactive_end
-	 */
-	if (pm_runtime_active(ddev->dev)) {
-		regmap_read(ldev->regmap, LTDC_CPSR, &line);
-		line &= CPSR_CYPOS;
-		regmap_read(ldev->regmap, LTDC_BPCR, &vactive_start);
-		vactive_start &= BPCR_AVBP;
-		regmap_read(ldev->regmap, LTDC_AWCR, &vactive_end);
-		vactive_end &= AWCR_AAH;
-		regmap_read(ldev->regmap, LTDC_TWCR, &vtotal);
-		vtotal &= TWCR_TOTALH;
+	drm_crtc_vblank_off(crtc);
 
-		if (line > vactive_end)
+	/* Disable all layers */
+	for (layer_index = 0; layer_index < ldev->caps.nb_layers; layer_index++)
+		regmap_write_bits(ldev->regmap, LTDC_L1CR + layer_index * LAY_OFS, LXCR_MASK, 0);
+
+	/* disable IRQ errors */
+	regmap_clear_bits(ldev->regmap, LTDC_IER, IER_FUWIE | IER_FUEIE | IER_TERRIE | IER_FURIE);
+
+	/* immediately commit disable of layers before switching off LTDC */
+	if (!ldev->caps.plane_reg_shadow)
+		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_IMR);
+	else
+		for (layer_index = 0; layer_index < ldev->caps.nb_layers; layer_index++)
+			regmap_write_bits(ldev->regmap, LTDC_L1RCR + layer_index * LAY_OFS,
+					  LXRCR_IMR | LXRCR_VBR | LXRCR_GRMSK, LXRCR_IMR);
+
+	/* Disable LTDC */
+	regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
+
+	/* Set to sleep state the pinctrl whatever type of encoder */
+	pinctrl_pm_select_sleep_state(ddev->dev);
+
+	pm_runtime_put_sync_suspend(ddev->dev);
+
+	/* restore to kernel ltdc clock as parent of pixel clock */
+	if (ldev->ltdc_clk) {
+		ret = clk_set_parent(ldev->pixel_clk, ldev->ltdc_clk);
+		if (ret) {
+			DRM_ERROR("Could not set parent clock: %d\n", ret);
+			return;
+		}
+	}
+
+	/*  clear interrupt error counters */
+	mutex_lock(&ldev->err_lock);
+	ldev->transfer_err = 0;
+	ldev->fifo_err = 0;
+	ldev->fifo_warn = 0;
+	ldev->fifo_rot = 0;
+	mutex_unlock(&ldev->err_lock);
+}
+
+static void ltdc_crtc_mode_set_nofb(struct drm_crtc *crtc)
+{
+	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
+	struct drm_device *ddev = crtc->dev;
+	struct drm_connector_list_iter iter;
+	struct drm_connector *connector = NULL;
+	struct drm_encoder *encoder = NULL, *en_iter;
+	struct drm_display_mode *mode = &crtc->state->adjusted_mode;
+	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
+	int rate = mode->clock * 1000;
+	u32 hsync, vsync, accum_hbp, accum_vbp, accum_act_w, accum_act_h;
+	u32 total_width, total_height;
+	u32 val;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	/* disable to stream frame if previous session is still alive */
+	if (pm_runtime_active(ddev->dev)) {
+		regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
+		pm_runtime_put_sync_suspend(ddev->dev);
+	}
+
+	/* get encoder from crtc */
+	drm_for_each_encoder(en_iter, ddev)
+		if (en_iter->crtc == crtc) {
+			encoder = en_iter;
+			break;
+		}
+
+	if (encoder) {
+		/* Get the connector from encoder */
+		drm_connector_list_iter_begin(ddev, &iter);
+		drm_for_each_connector_iter(connector, &iter)
+			if (connector->encoder == encoder)
+				break;
+		drm_connector_list_iter_end(&iter);
+	}
+
+	if (connector)
+		orientation = connector->display_info.panel_orientation;
+
+	if (encoder->encoder_type == DRM_MODE_ENCODER_LVDS) {
+		if (ldev->lvds_clk) {
+			ret = clk_set_parent(ldev->pixel_clk, ldev->lvds_clk);
+			if (ret) {
+				DRM_ERROR("Could not set parent clock: %d\n", ret);
+				return;
+			}
+		}
+	} else {
+		if (ldev->ltdc_clk) {
+			ret = clk_set_parent(ldev->pixel_clk, ldev->ltdc_clk);
+			if (ret) {
+				DRM_ERROR("Could not set parent clock: %d\n", ret);
+				return;
+			}
+		}
+	}
+
+	if (clk_set_rate(ldev->pixel_clk, rate) < 0) {
+		DRM_ERROR("Cannot set rate (%dHz) for pixel clk\n", rate);
+		return;
+	}
+
+	/*
+	 * Set to default state the pinctrl only with DPI type.
+	 * Others types like DSI, don't need pinctrl due to
+	 * internal bridge (the signals do not come out of the chipset).
+	 */
+	if (encoder->encoder_type == DRM_MODE_ENCODER_DPI)
+		pinctrl_pm_select_default_state(ddev->dev);
+	else
+		pinctrl_pm_select_sleep_state(ddev->dev);
+
+	ret = pm_runtime_get_sync(ddev->dev);
+	if (ret) {
+		DRM_ERROR("Failed to set mode, cannot get sync\n");
+		return;
+	}
+
+	DRM_DEBUG_DRIVER("CRTC:%d mode:%s\n", crtc->base.id, mode->name);
+	DRM_DEBUG_DRIVER("Video mode: %dx%d", mode->hdisplay, mode->vdisplay);
+	DRM_DEBUG_DRIVER(" hfp %d hbp %d hsl %d vfp %d vbp %d vsl %d\n",
+			 mode->hsync_start - mode->hdisplay,
+			 mode->htotal - mode->hsync_end,
+			 mode->hsync_end - mode->hsync_start,
+			 mode->vsync_start - mode->vdisplay,
+			 mode->vtotal - mode->vsync_end,
+			 mode->vsync_end - mode->vsync_start);
+
+	/* Convert video timings to ltdc timings */
+	hsync = mode->hsync_end - mode->hsync_start - 1;
+	vsync = mode->vsync_end - mode->vsync_start - 1;
+	accum_hbp = mode->htotal - mode->hsync_start - 1;
+	accum_vbp = mode->vtotal - mode->vsync_start - 1;
+	accum_act_w = accum_hbp + mode->hdisplay;
+	accum_act_h = accum_vbp + mode->vdisplay;
+	total_width = mode->htotal - 1;
+	total_height = mode->vtotal - 1;
+
+	/* check that an output rotation is required */
+	if (ldev->caps.crtc_rotation &&
+	    (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP ||
+	     orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP)) {
+		/* Set Synchronization size */
+		val = (vsync << 16) | hsync;
+		regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+
+		/* Set Accumulated Back porch */
+		val = (accum_vbp << 16) | accum_hbp;
+		regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+
+		/* Set Accumulated Active Width */
+		val = (accum_act_h << 16) | accum_act_w;
+		regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+
+		/* Set total width & height */
+		val = (total_height << 16) | total_width;
+		regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+
+		regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_w + 1));
+	} else {
+		/* Set Synchronization size */
+		val = (hsync << 16) | vsync;
+		regmap_update_bits(ldev->regmap, LTDC_SSCR, SSCR_VSH | SSCR_HSW, val);
+
+		/* Set Accumulated Back porch */
+		val = (accum_hbp << 16) | accum_vbp;
+		regmap_update_bits(ldev->regmap, LTDC_BPCR, BPCR_AVBP | BPCR_AHBP, val);
+
+		/* Set Accumulated Active Width */
+		val = (accum_act_w << 16) | accum_act_h;
+		regmap_update_bits(ldev->regmap, LTDC_AWCR, AWCR_AAW | AWCR_AAH, val);
+
+		/* Set total width & height */
+		val = (total_width << 16) | total_height;
+		regmap_update_bits(ldev->regmap, LTDC_TWCR, TWCR_TOTALH | TWCR_TOTALW, val);
+
+		regmap_write(ldev->regmap, LTDC_LIPCR, (accum_act_h + 1));
+	}
+}
+
+static void ltdc_crtc_atomic_flush(struct drm_crtc *crtc,
+				   struct drm_atomic_state *state)
+{
+	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
+	struct drm_device *ddev = crtc->dev;
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	DRM_DEBUG_ATOMIC("\n");
+
+	/* Commit shadow registers = update planes at next vblank */
+	if (!ldev->caps.plane_reg_shadow)
+		regmap_set_bits(ldev->regmap, LTDC_SRCR, SRCR_VBR);
+
+	if (event) {
+		crtc->state->event = NULL;
+
+		spin_lock_irq(&ddev->event_lock);
+		if (drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&ddev->event_lock);
+	}
+}
+
+static int ltdc_crtc_atomic_check(struct drm_crtc *crtc,
+				  struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
+
+	DRM_DEBUG_ATOMIC("\n");
+
+	/* force a full mode set if active state changed */
+	if (crtc_state->active_changed)
+		crtc_state->mode_changed = true;
+
+	return 0;
+}
+
+static bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,
+					   bool in_vblank_irq,
+					   int *vpos, int *hpos,
+					   ktime_t *stime, ktime_t *etime,
+					   const struct drm_display_mode *mode)
+{
+	struct drm_device *ddev = crtc->dev;
+	struct ltdc_device *ldev = ddev->dev_private;
+	int line, vactive_start, vactive_end, vtotal;
+
+	if (stime)
+		*stime = ktime_get();
+
+	/* The active area starts after vsync + front porch and ends
+	 * at vsync + front porc + display size.
+	 * The total height also include back porch.
+	 * We have 3 possible cases to handle:
+	 * - line < vactive_start: vpos = line - vactive_start and will be
+	 * negative
+	 * - vactive_start < line < vactive_end: vpos = line - vactive_start
+	 * and will be positive
+	 * - line > vactive_end: vpos = line - vtotal - vactive_start
+	 * and will negative
+	 *
+	 * Computation for the two first cases are identical so we can
+	 * simplify the code and only test if line > vactive_end
+	 */
+	if (pm_runtime_active(ddev->dev)) {
+		regmap_read(ldev->regmap, LTDC_CPSR, &line);
+		line &= CPSR_CYPOS;
+		regmap_read(ldev->regmap, LTDC_BPCR, &vactive_start);
+		vactive_start &= BPCR_AVBP;
+		regmap_read(ldev->regmap, LTDC_AWCR, &vactive_end);
+		vactive_end &= AWCR_AAH;
+		regmap_read(ldev->regmap, LTDC_TWCR, &vtotal);
+		vtotal &= TWCR_TOTALH;
+
+		if (line > vactive_end)
 			*vpos = line - vtotal - vactive_start;
 		else
 			*vpos = line - vactive_start;
@@ -1111,12 +1259,11 @@ static bool ltdc_crtc_get_scanout_position(struct drm_crtc *crtc,
 }
 
 static const struct drm_crtc_helper_funcs ltdc_crtc_helper_funcs = {
-	.mode_valid = ltdc_crtc_mode_valid,
-	.mode_fixup = ltdc_crtc_mode_fixup,
 	.mode_set_nofb = ltdc_crtc_mode_set_nofb,
 	.atomic_flush = ltdc_crtc_atomic_flush,
 	.atomic_enable = ltdc_crtc_atomic_enable,
 	.atomic_disable = ltdc_crtc_atomic_disable,
+	.atomic_check = ltdc_crtc_atomic_check,
 	.get_scanout_position = ltdc_crtc_get_scanout_position,
 };
 
@@ -1127,9 +1274,10 @@ static int ltdc_crtc_enable_vblank(struct drm_crtc *crtc)
 
 	DRM_DEBUG_DRIVER("\n");
 
-	if (state->enable)
+	if (state->enable) {
+		ldev->vblank_active = true;
 		regmap_set_bits(ldev->regmap, LTDC_IER, IER_LIE);
-	else
+	} else
 		return -EPERM;
 
 	return 0;
@@ -1140,7 +1288,11 @@ static void ltdc_crtc_disable_vblank(struct drm_crtc *crtc)
 	struct ltdc_device *ldev = crtc_to_ltdc(crtc);
 
 	DRM_DEBUG_DRIVER("\n");
-	regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE);
+
+	ldev->vblank_active = false;
+
+	if (!ldev->vblank_active && !ldev->crc_active)
+		regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE);
 }
 
 static int ltdc_crtc_set_crc_source(struct drm_crtc *crtc, const char *source)
@@ -1157,9 +1309,12 @@ static int ltdc_crtc_set_crc_source(struct drm_crtc *crtc, const char *source)
 
 	if (source && strcmp(source, "auto") == 0) {
 		ldev->crc_active = true;
+		regmap_set_bits(ldev->regmap, LTDC_IER, IER_LIE);
 		ret = regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_CRCEN);
 	} else if (!source) {
 		ldev->crc_active = false;
+		if (!ldev->vblank_active && !ldev->crc_active)
+			regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE);
 		ret = regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_CRCEN);
 	} else {
 		ret = -EINVAL;
@@ -1196,6 +1351,7 @@ static void ltdc_crtc_atomic_print_state(struct drm_printer *p,
 	drm_printf(p, "\ttransfer_error=%d\n", ldev->transfer_err);
 	drm_printf(p, "\tfifo_underrun_error=%d\n", ldev->fifo_err);
 	drm_printf(p, "\tfifo_underrun_warning=%d\n", ldev->fifo_warn);
+	drm_printf(p, "\tfifo_underrun_rotation=%d\n", ldev->fifo_rot);
 	drm_printf(p, "\tfifo_underrun_threshold=%d\n", ldev->fifo_threshold);
 }
 
@@ -1234,10 +1390,10 @@ static const struct drm_crtc_funcs ltdc_crtc_with_crc_support_funcs = {
 static int ltdc_plane_atomic_check(struct drm_plane *plane,
 				   struct drm_atomic_state *state)
 {
-	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
-										 plane);
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state, plane);
 	struct drm_framebuffer *fb = new_plane_state->fb;
-	u32 src_w, src_h;
+	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	u32 src_w, src_h, crtc_w, crtc_h;
 
 	DRM_DEBUG_DRIVER("\n");
 
@@ -1247,65 +1403,190 @@ static int ltdc_plane_atomic_check(struct drm_plane *plane,
 	/* convert src_ from 16:16 format */
 	src_w = new_plane_state->src_w >> 16;
 	src_h = new_plane_state->src_h >> 16;
+	crtc_w = new_plane_state->crtc_w;
+	crtc_h = new_plane_state->crtc_h;
 
-	/* Reject scaling */
-	if (src_w != new_plane_state->crtc_w || src_h != new_plane_state->crtc_h) {
-		DRM_DEBUG_DRIVER("Scaling is not supported");
+	if (ldev->caps.plane_scaling[plane->index]) {
+		if (fb->format->is_yuv) {
+			if (src_w != crtc_w || src_h != crtc_h) {
+				DRM_DEBUG_DRIVER("Scaling is not supported with yuv pixel format");
+				return -EINVAL;
+			}
+		}
 
-		return -EINVAL;
+		if (src_w > crtc_w || src_h > crtc_h) {
+			DRM_DEBUG_DRIVER("Downscaling is not supported");
+			return -EINVAL;
+		}
+	} else {
+		if (src_w != crtc_w || src_h != crtc_h) {
+			DRM_DEBUG_DRIVER("Scaling is not supported on layer %d", plane->index);
+			return -EINVAL;
+		}
 	}
 
 	return 0;
 }
 
+#define SCALER_FRACTION 12
+
+static u32 calculateScalingFactor(u32 in, u32 out)
+{
+	u32 factor = 0x1000;
+
+	if (out != 1)
+		factor = ((in - 1) << SCALER_FRACTION) / (out - 1);
+
+	return factor & 0xFFFF;
+}
+
+static void ltdc_plane_update_clut(struct drm_plane *plane,
+				   struct drm_plane_state *state)
+{
+	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_crtc *crtc = state->crtc;
+	struct drm_color_lut *lut;
+	u32 lofs = plane->index * LAY_OFS;
+	u32 val;
+	int lut_size;
+	int i;
+
+	if (!crtc || !crtc->state)
+		return;
+
+	if (!crtc->state->color_mgmt_changed || !crtc->state->gamma_lut)
+		return;
+
+	lut = (struct drm_color_lut *)crtc->state->gamma_lut->data;
+	lut_size = drm_color_lut_size(crtc->state->gamma_lut);
+	if (lut_size > CLUT_SIZE)
+		return;
+
+	for (i = 0; i < CLUT_SIZE; i++, lut++) {
+		val = ((lut->red << 8) & 0xff0000) | (lut->green & 0xff00) |
+		      (lut->blue >> 8) | (i << 24);
+		regmap_write(ldev->regmap, LTDC_L1CLUTWR + lofs, val);
+	}
+}
+
 static void ltdc_plane_atomic_update(struct drm_plane *plane,
 				     struct drm_atomic_state *state)
 {
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
+	struct device *dev = ddev->dev;
 	struct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state,
 									  plane);
 	struct drm_framebuffer *fb = newstate->fb;
 	u32 lofs = plane->index * LAY_OFS;
-	u32 x0 = newstate->crtc_x;
-	u32 x1 = newstate->crtc_x + newstate->crtc_w - 1;
-	u32 y0 = newstate->crtc_y;
-	u32 y1 = newstate->crtc_y + newstate->crtc_h - 1;
-	u32 src_x, src_y, src_w, src_h;
 	u32 val, pitch_in_bytes, line_length, line_number, ahbp, avbp, bpcr;
-	u32 paddr, paddr1, paddr2;
+	u32 paddr, paddr1, paddr2, lxcr;
 	enum ltdc_pix_fmt pf;
+	unsigned int plane_rotation = newstate->rotation;
+	struct drm_connector_list_iter co_iter;
+	struct drm_connector *connector = NULL;
+	struct drm_encoder *encoder = NULL, *en_iter;
+	struct drm_rect dst, src;
+	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
 
 	if (!newstate->crtc || !fb) {
 		DRM_DEBUG_DRIVER("fb or crtc NULL");
 		return;
 	}
 
+	/* get encoder from crtc */
+	drm_for_each_encoder(en_iter, ddev)
+		if (en_iter->crtc == newstate->crtc) {
+			encoder = en_iter;
+			break;
+		}
+
+	if (encoder) {
+		/* Get the connector from encoder */
+		drm_connector_list_iter_begin(ddev, &co_iter);
+		drm_for_each_connector_iter(connector, &co_iter)
+			if (connector->encoder == encoder)
+				break;
+		drm_connector_list_iter_end(&co_iter);
+
+		if (connector)
+			orientation = connector->display_info.panel_orientation;
+	}
+
 	/* convert src_ from 16:16 format */
-	src_x = newstate->src_x >> 16;
-	src_y = newstate->src_y >> 16;
-	src_w = newstate->src_w >> 16;
-	src_h = newstate->src_h >> 16;
+	drm_rect_init(&src, newstate->src_x >> 16, newstate->src_y >> 16,
+		      newstate->src_w >> 16, newstate->src_h >> 16);
 
-	DRM_DEBUG_DRIVER("plane:%d fb:%d (%dx%d)@(%d,%d) -> (%dx%d)@(%d,%d)\n",
-			 plane->base.id, fb->base.id,
-			 src_w, src_h, src_x, src_y,
-			 newstate->crtc_w, newstate->crtc_h,
-			 newstate->crtc_x, newstate->crtc_y);
+	drm_rect_init(&dst, newstate->crtc_x, newstate->crtc_y,
+		      newstate->crtc_w, newstate->crtc_h);
 
-	regmap_read(ldev->regmap, LTDC_BPCR, &bpcr);
+	DRM_DEBUG_DRIVER("plane:%d fb:%d src: " DRM_RECT_FMT " -> crtc: " DRM_RECT_FMT "\n",
+			 plane->base.id, fb->base.id, DRM_RECT_ARG(&src), DRM_RECT_ARG(&dst));
 
-	ahbp = (bpcr & BPCR_AHBP) >> 16;
-	avbp = bpcr & BPCR_AVBP;
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
+	regmap_read(ldev->regmap, LTDC_BPCR, &bpcr);
 
-	/* Configures the horizontal start and stop position */
-	val = ((x1 + 1 + ahbp) << 16) + (x0 + 1 + ahbp);
-	regmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,
-			  LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
+	if (ldev->caps.crtc_rotation &&
+	    (orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP ||
+	     orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP)) {
+		avbp = (bpcr & BPCR_AHBP) >> 16;
+		ahbp = bpcr & BPCR_AVBP;
+
+		/* Configures the horizontal start and stop position */
+		val = (dst.x1 + 1 + ahbp) + ((dst.x2 + ahbp) << 16);
+		regmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,
+				  LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
+
+		/* Configures the vertical start and stop position */
+		val = (dst.y1 + 1 + avbp) + ((dst.y2 + avbp) << 16);
+		regmap_write_bits(ldev->regmap, LTDC_L1WVPCR + lofs,
+				  LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS, val);
+
+		/* need to mirroring on X (rotation will switch lines & columns,
+		   not a real rotate */
+		if (orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP) {
+			if (plane_rotation & DRM_MODE_REFLECT_X)
+				plane_rotation &= ~DRM_MODE_REFLECT_X;
+			else
+				plane_rotation |= DRM_MODE_REFLECT_X;
+		}
 
-	/* Configures the vertical start and stop position */
-	val = ((y1 + 1 + avbp) << 16) + (y0 + 1 + avbp);
-	regmap_write_bits(ldev->regmap, LTDC_L1WVPCR + lofs,
-			  LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS, val);
+		/* need to mirroring on Y (rotation will switch lines & columns,
+		   not a real rotate */
+		if (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP) {
+			if (plane_rotation & DRM_MODE_REFLECT_Y)
+				plane_rotation &= ~DRM_MODE_REFLECT_Y;
+			else
+				plane_rotation |= DRM_MODE_REFLECT_Y;
+		}
+	} else {
+		ahbp = (bpcr & BPCR_AHBP) >> 16;
+		avbp = bpcr & BPCR_AVBP;
+
+		/* Configures the horizontal start and stop position */
+		val = ((dst.x2 + ahbp) << 16) + (dst.x1 + 1 + ahbp);
+		regmap_write_bits(ldev->regmap, LTDC_L1WHPCR + lofs,
+				  LXWHPCR_WHSTPOS | LXWHPCR_WHSPPOS, val);
+
+		/* Configures the vertical start and stop position */
+		val = ((dst.y2 + avbp) << 16) + (dst.y1 + 1 + avbp);
+		regmap_write_bits(ldev->regmap, LTDC_L1WVPCR + lofs,
+				  LXWVPCR_WVSTPOS | LXWVPCR_WVSPPOS, val);
+
+		if (orientation == DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP) {
+			if (plane_rotation & DRM_MODE_REFLECT_X)
+				plane_rotation &= ~DRM_MODE_REFLECT_X;
+			else
+				plane_rotation |= DRM_MODE_REFLECT_X;
+
+			if (plane_rotation & DRM_MODE_REFLECT_Y)
+				plane_rotation &= ~DRM_MODE_REFLECT_Y;
+			else
+				plane_rotation |= DRM_MODE_REFLECT_Y;
+		}
+	}
 
 	/* Specifies the pixel format */
 	pf = to_ltdc_pixelformat(fb->format->format);
@@ -1328,6 +1609,9 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	val = newstate->alpha >> 8;
 	regmap_write_bits(ldev->regmap, LTDC_L1CACR + lofs, LXCACR_CONSTA, val);
 
+	/* Sets the default color to black */
+	regmap_write(ldev->regmap, LTDC_L1DCCR + lofs, DCCR_DCBLACK);
+
 	/* Specifies the blending factors */
 	val = BF1_PAXCA | BF2_1PAXCA;
 	if (!fb->format->has_alpha)
@@ -1350,20 +1634,19 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	/* Sets the FB address */
 	paddr = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 0);
 
-	if (newstate->rotation & DRM_MODE_REFLECT_X)
-		paddr += (fb->format->cpp[0] * (x1 - x0 + 1)) - 1;
+	if (plane_rotation & DRM_MODE_REFLECT_X)
+		paddr += (fb->format->cpp[0] * drm_rect_width(&src)) - 1;
 
-	if (newstate->rotation & DRM_MODE_REFLECT_Y)
-		paddr += (fb->pitches[0] * (y1 - y0));
+	if (plane_rotation & DRM_MODE_REFLECT_Y)
+		paddr += (fb->pitches[0] * (drm_rect_height(&src) - 1));
 
 	DRM_DEBUG_DRIVER("fb: phys 0x%08x", paddr);
 	regmap_write(ldev->regmap, LTDC_L1CFBAR + lofs, paddr);
 
 	/* Configures the color frame buffer pitch in bytes & line length */
-	line_length = fb->format->cpp[0] *
-		      (x1 - x0 + 1) + (ldev->caps.bus_width >> 3) - 1;
+	line_length = fb->format->cpp[0] * drm_rect_width(&src) + (ldev->caps.bus_width >> 3) - 1;
 
-	if (newstate->rotation & DRM_MODE_REFLECT_Y)
+	if (plane_rotation & DRM_MODE_REFLECT_Y)
 		/* Compute negative value (signed on 16 bits) for the picth */
 		pitch_in_bytes = 0x10000 - fb->pitches[0];
 	else
@@ -1373,7 +1656,7 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 	regmap_write_bits(ldev->regmap, LTDC_L1CFBLR + lofs, LXCFBLR_CFBLL | LXCFBLR_CFBP, val);
 
 	/* Configures the frame buffer line number */
-	line_number = y1 - y0 + 1;
+	line_number = drm_rect_height(&src);
 	regmap_write_bits(ldev->regmap, LTDC_L1CFBLNR + lofs, LXCFBLNR_CFBLN, line_number);
 
 	if (ldev->caps.ycbcr_input) {
@@ -1384,11 +1667,11 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 			/* Configure the auxiliary frame buffer address 0 */
 			paddr1 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 1);
 
-			if (newstate->rotation & DRM_MODE_REFLECT_X)
-				paddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;
+			if (plane_rotation & DRM_MODE_REFLECT_X)
+				paddr1 += ((fb->format->cpp[1] * drm_rect_width(&src)) >> 1) - 1;
 
-			if (newstate->rotation & DRM_MODE_REFLECT_Y)
-				paddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;
+			if (plane_rotation & DRM_MODE_REFLECT_Y)
+				paddr1 += (fb->pitches[1] * (drm_rect_height(&src) - 1)) >> 1;
 
 			regmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);
 			break;
@@ -1397,14 +1680,14 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 			paddr1 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 1);
 			paddr2 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 2);
 
-			if (newstate->rotation & DRM_MODE_REFLECT_X) {
-				paddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;
-				paddr2 += ((fb->format->cpp[2] * (x1 - x0 + 1)) >> 1) - 1;
+			if (plane_rotation & DRM_MODE_REFLECT_X) {
+				paddr1 += ((fb->format->cpp[1] * drm_rect_width(&src)) >> 1) - 1;
+				paddr2 += ((fb->format->cpp[2] * drm_rect_width(&src)) >> 1) - 1;
 			}
 
-			if (newstate->rotation & DRM_MODE_REFLECT_Y) {
-				paddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;
-				paddr2 += (fb->pitches[2] * (y1 - y0 - 1)) >> 1;
+			if (plane_rotation & DRM_MODE_REFLECT_Y) {
+				paddr1 += (fb->pitches[1] * (drm_rect_height(&src) - 1)) >> 1;
+				paddr2 += (fb->pitches[2] * (drm_rect_height(&src) - 1)) >> 1;
 			}
 
 			regmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);
@@ -1415,14 +1698,14 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 			paddr1 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 2);
 			paddr2 = (u32)drm_fb_dma_get_gem_addr(fb, newstate, 1);
 
-			if (newstate->rotation & DRM_MODE_REFLECT_X) {
-				paddr1 += ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) - 1;
-				paddr2 += ((fb->format->cpp[2] * (x1 - x0 + 1)) >> 1) - 1;
+			if (plane_rotation & DRM_MODE_REFLECT_X) {
+				paddr1 += ((fb->format->cpp[1] * drm_rect_width(&src)) >> 1) - 1;
+				paddr2 += ((fb->format->cpp[2] * drm_rect_width(&src)) >> 1) - 1;
 			}
 
-			if (newstate->rotation & DRM_MODE_REFLECT_Y) {
-				paddr1 += (fb->pitches[1] * (y1 - y0 - 1)) >> 1;
-				paddr2 += (fb->pitches[2] * (y1 - y0 - 1)) >> 1;
+			if (plane_rotation & DRM_MODE_REFLECT_Y) {
+				paddr1 += (fb->pitches[1] * (drm_rect_height(&src) - 1)) >> 1;
+				paddr2 += (fb->pitches[2] * (drm_rect_height(&src) - 1)) >> 1;
 			}
 
 			regmap_write(ldev->regmap, LTDC_L1AFBA0R + lofs, paddr1);
@@ -1435,7 +1718,7 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 			 * buffers if the framebuffer contains more than one plane.
 			 */
 			if (fb->format->num_planes > 1) {
-				if (newstate->rotation & DRM_MODE_REFLECT_Y)
+				if (plane_rotation & DRM_MODE_REFLECT_Y)
 					/*
 					 * Compute negative value (signed on 16 bits)
 					 * for the picth
@@ -1444,7 +1727,7 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 				else
 					pitch_in_bytes = fb->pitches[1];
 
-				line_length = ((fb->format->cpp[1] * (x1 - x0 + 1)) >> 1) +
+				line_length = ((fb->format->cpp[1] * drm_rect_width(&src)) >> 1) +
 					      (ldev->caps.bus_width >> 3) - 1;
 
 				/* Configure the auxiliary buffer length */
@@ -1467,15 +1750,51 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 		}
 	}
 
+	/* Configure burst length */
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc"))
+		regmap_write(ldev->regmap, LTDC_L1BLCR + lofs, ldev->max_burst_length);
+
+	/* set color look-up table */
+	if (fb->format->format == DRM_FORMAT_C8)
+		ltdc_plane_update_clut(plane, newstate);
+
 	/* Enable layer and CLUT if needed */
-	val = fb->format->format == DRM_FORMAT_C8 ? LXCR_CLUTEN : 0;
-	val |= LXCR_LEN;
+	lxcr = fb->format->format == DRM_FORMAT_C8 ? LXCR_CLUTEN : 0;
+	lxcr |= LXCR_LEN;
 
 	/* Enable horizontal mirroring if requested */
-	if (newstate->rotation & DRM_MODE_REFLECT_X)
-		val |= LXCR_HMEN;
+	if (plane_rotation & DRM_MODE_REFLECT_X)
+		lxcr |= LXCR_HMEN;
+
+	if (ldev->caps.plane_scaling[plane->index] &&
+	    (drm_rect_width(&src) != drm_rect_width(&dst) ||
+	     drm_rect_height(&src) != drm_rect_height(&dst))) {
+		lxcr |= LXCR_SCEN;
+
+		/* Configure the scaler input size */
+		val = (drm_rect_height(&src) << 16U) | drm_rect_width(&src);
+		regmap_write(ldev->regmap, LTDC_L1SISR + lofs, val);
+
+		/* Configure the scaler output size */
+		val = (drm_rect_height(&dst) << 16U) | drm_rect_width(&dst);
+		regmap_write(ldev->regmap, LTDC_L1SOSR + lofs, val);
 
-	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN | LXCR_HMEN, val);
+		/* Configure the vertical scaling factor */
+		val = calculateScalingFactor(drm_rect_height(&src), drm_rect_height(&dst));
+		regmap_write(ldev->regmap, LTDC_L1SVSFR + lofs, val);
+
+		/* Configure the vertical scaling phase */
+		regmap_write(ldev->regmap, LTDC_L1SHSPR + lofs, val);
+
+		/* Configure the horizontal scaling factor */
+		val = calculateScalingFactor(drm_rect_width(&src), drm_rect_width(&dst));
+		regmap_write(ldev->regmap, LTDC_L1SHSFR + lofs, val);
+
+		/* Configure the vertical scaling phase */
+		regmap_write(ldev->regmap, LTDC_L1SVSPR + lofs, val + (1 << SCALER_FRACTION));
+	}
+
+	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_MASK, lxcr);
 
 	/* Commit shadow registers = update plane at next vblank */
 	if (ldev->caps.plane_reg_shadow)
@@ -1490,6 +1809,11 @@ static void ltdc_plane_atomic_update(struct drm_plane *plane,
 		ldev->transfer_err = 0;
 	}
 
+	if (ldev->fifo_rot) {
+		DRM_WARN("ltdc fifo rotation error\n");
+		ldev->fifo_rot = 0;
+	}
+
 	if (ldev->caps.fifo_threshold) {
 		if (ldev->fifo_err) {
 			DRM_WARN("ltdc fifo underrun: please verify display mode\n");
@@ -1510,10 +1834,17 @@ static void ltdc_plane_atomic_disable(struct drm_plane *plane,
 	struct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state,
 									  plane);
 	struct ltdc_device *ldev = plane_to_ltdc(plane);
+	struct drm_device *ddev = plane->dev;
 	u32 lofs = plane->index * LAY_OFS;
 
+	if (!pm_runtime_active(ddev->dev))
+		return;
+
 	/* Disable layer */
-	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_LEN | LXCR_CLUTEN |  LXCR_HMEN, 0);
+	regmap_write_bits(ldev->regmap, LTDC_L1CR + lofs, LXCR_MASK, 0);
+
+	/* Set the transparency of the layer to the default value */
+	regmap_write_bits(ldev->regmap, LTDC_L1CACR + lofs, LXCACR_CONSTA, 0x00);
 
 	/* Commit shadow registers = update plane at next vblank */
 	if (ldev->caps.plane_reg_shadow)
@@ -1602,15 +1933,22 @@ static struct drm_plane *ltdc_plane_create(struct drm_device *ddev,
 			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp) * sizeof(*formats));
 			nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_cp);
 		}
-		if (val & LXCR_C1R_YSPA) {
-			memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_sp,
-			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp) * sizeof(*formats));
-			nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp);
-		}
-		if (val & LXCR_C1R_YFPA) {
-			memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_fp,
-			       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp) * sizeof(*formats));
-			nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp);
+
+		/*
+		 * Soc MP25 doesn't support pixel formats yuv semiplanar &
+		 * planar on layer1 only.
+		 */
+		if (!(of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc") && !index)) {
+			if (val & LXCR_C1R_YSPA) {
+				memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_sp,
+				       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp) * sizeof(*formats));
+				nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_sp);
+			}
+			if (val & LXCR_C1R_YFPA) {
+				memcpy(&formats[nb_fmt], ltdc_drm_fmt_ycbcr_fp,
+				       ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp) * sizeof(*formats));
+				nb_fmt += ARRAY_SIZE(ltdc_drm_fmt_ycbcr_fp);
+			}
 		}
 	}
 
@@ -1660,6 +1998,16 @@ static int ltdc_crtc_init(struct drm_device *ddev, struct drm_crtc *crtc)
 	int supported_rotations = DRM_MODE_ROTATE_0 | DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y;
 	unsigned int i;
 	int ret;
+	struct drm_connector *connector = NULL;
+	struct drm_connector_list_iter iter;
+
+	/* Add the dithering property to all connectors */
+	drm_connector_list_iter_begin(ddev, &iter);
+	drm_for_each_connector_iter(connector, &iter)
+		drm_connector_attach_dithering_property(connector,
+							BIT(DRM_MODE_DITHERING_OFF) |
+							BIT(DRM_MODE_DITHERING_ON));
+	drm_connector_list_iter_end(&iter);
 
 	primary = ltdc_plane_create(ddev, DRM_PLANE_TYPE_PRIMARY, 0);
 	if (!primary) {
@@ -1720,56 +2068,108 @@ static int ltdc_crtc_init(struct drm_device *ddev, struct drm_crtc *crtc)
 	return ret;
 }
 
-static void ltdc_encoder_disable(struct drm_encoder *encoder)
+#define CLK_TOLERANCE_HZ 50
+
+static enum drm_mode_status ltdc_encoder_mode_valid(struct drm_encoder *encoder,
+						    const struct drm_display_mode *mode)
 {
 	struct drm_device *ddev = encoder->dev;
-	struct ltdc_device *ldev = ddev->dev_private;
+	struct ltdc_device *ldev =  ddev->dev_private;
+	struct device *dev = ddev->dev;
+	struct drm_connector *connector = NULL;
+	struct drm_connector_list_iter iter;
+	int orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
+	int target = mode->clock * 1000;
+	int target_min = target - CLK_TOLERANCE_HZ;
+	int target_max = target + CLK_TOLERANCE_HZ;
+	int result;
 
-	DRM_DEBUG_DRIVER("\n");
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc")) {
+		if (encoder->encoder_type == DRM_MODE_ENCODER_LVDS)
+			result = clk_round_rate(ldev->lvds_clk, target);
+		else
+			result = clk_round_rate(ldev->ltdc_clk, target);
+	} else {
+		result = clk_round_rate(ldev->pixel_clk, target);
+	}
 
-	/* Disable LTDC */
-	regmap_clear_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
+	DRM_DEBUG_DRIVER("clk rate target %d, available %d\n", target, result);
 
-	/* Set to sleep state the pinctrl whatever type of encoder */
-	pinctrl_pm_select_sleep_state(ddev->dev);
-}
+	/* Get the connector from encoder */
+	drm_connector_list_iter_begin(ddev, &iter);
+	drm_for_each_connector_iter(connector, &iter)
+		if (connector->encoder == encoder)
+			break;
+	drm_connector_list_iter_end(&iter);
 
-static void ltdc_encoder_enable(struct drm_encoder *encoder)
-{
-	struct drm_device *ddev = encoder->dev;
-	struct ltdc_device *ldev = ddev->dev_private;
+	if (connector)
+		orientation = connector->display_info.panel_orientation;
 
-	DRM_DEBUG_DRIVER("\n");
+	/* check that an output rotation is required */
+	if (ldev->caps.crtc_rotation &&
+	    (orientation == DRM_MODE_PANEL_ORIENTATION_LEFT_UP ||
+	     orientation == DRM_MODE_PANEL_ORIENTATION_RIGHT_UP)) {
+		/*
+		 * Size of the rotation buffer must be larger than the size
+		 * of two frames (format RGB24).
+		 */
+		if (ldev->rot_mem->size < mode->hdisplay * mode->vdisplay * 2 * 3)
+			return MODE_MEM;
 
-	/* set fifo underrun threshold register */
-	if (ldev->caps.fifo_threshold)
-		regmap_write(ldev->regmap, LTDC_FUT, ldev->fifo_threshold);
+		/* The width of the framebuffer must not exceed 1366 pixels */
+		if (mode->vdisplay > 1366)
+			return MODE_BAD_WIDTH;
+	}
 
-	/* Enable LTDC */
-	regmap_set_bits(ldev->regmap, LTDC_GCR, GCR_LTDCEN);
+	/* Filter modes according to the max frequency supported by the pads */
+	if (result > ldev->caps.pad_max_freq_hz)
+		return MODE_CLOCK_HIGH;
+
+	/*
+	 * Accept all "preferred" modes:
+	 * - this is important for panels because panel clock tolerances are
+	 *   bigger than hdmi ones and there is no reason to not accept them
+	 *   (the fps may vary a little but it is not a problem).
+	 * - the hdmi preferred mode will be accepted too, but userland will
+	 *   be able to use others hdmi "valid" modes if necessary.
+	 */
+	if (mode->type & DRM_MODE_TYPE_PREFERRED)
+		return MODE_OK;
+
+	/*
+	 * Filter modes according to the clock value, particularly useful for
+	 * hdmi modes that require precise pixel clocks.
+	 */
+	if (result < target_min || result > target_max)
+		return MODE_CLOCK_RANGE;
+
+	return MODE_OK;
 }
 
-static void ltdc_encoder_mode_set(struct drm_encoder *encoder,
-				  struct drm_display_mode *mode,
-				  struct drm_display_mode *adjusted_mode)
+static bool ltdc_encoder_mode_fixup(struct drm_encoder *encoder,
+				    const struct drm_display_mode *mode,
+				    struct drm_display_mode *adjusted_mode)
 {
 	struct drm_device *ddev = encoder->dev;
+	struct ltdc_device *ldev =  ddev->dev_private;
+	int rate = mode->clock * 1000;
 
-	DRM_DEBUG_DRIVER("\n");
+	if (clk_set_rate(ldev->pixel_clk, rate) < 0) {
+		DRM_ERROR("Cannot set rate (%dHz) for pixel clk\n", rate);
+		return false;
+	}
 
-	/*
-	 * Set to default state the pinctrl only with DPI type.
-	 * Others types like DSI, don't need pinctrl due to
-	 * internal bridge (the signals do not come out of the chipset).
-	 */
-	if (encoder->encoder_type == DRM_MODE_ENCODER_DPI)
-		pinctrl_pm_select_default_state(ddev->dev);
+	adjusted_mode->clock = clk_get_rate(ldev->pixel_clk) / 1000;
+
+	DRM_DEBUG_DRIVER("requested clock %dkHz, adjusted clock %dkHz\n",
+			 mode->clock, adjusted_mode->clock);
+
+	return true;
 }
 
 static const struct drm_encoder_helper_funcs ltdc_encoder_helper_funcs = {
-	.disable = ltdc_encoder_disable,
-	.enable = ltdc_encoder_enable,
-	.mode_set = ltdc_encoder_mode_set,
+	.mode_fixup = ltdc_encoder_mode_fixup,
+	.mode_valid = ltdc_encoder_mode_valid,
 };
 
 static int ltdc_encoder_init(struct drm_device *ddev, struct drm_bridge *bridge)
@@ -1803,7 +2203,10 @@ static int ltdc_encoder_init(struct drm_device *ddev, struct drm_bridge *bridge)
 static int ltdc_get_caps(struct drm_device *ddev)
 {
 	struct ltdc_device *ldev = ddev->dev_private;
-	u32 bus_width_log2, lcr, gc2r;
+	struct device *dev = ddev->dev;
+	u32 bus_width_log2, lcr, gc2r, lxc1r;
+	const struct ltdc_plat_data *pdata = of_device_get_match_data(ddev->dev);
+	int ret;
 
 	/*
 	 * at least 1 layer must be managed & the number of layers
@@ -1813,12 +2216,25 @@ static int ltdc_get_caps(struct drm_device *ddev)
 
 	ldev->caps.nb_layers = clamp((int)lcr, 1, LTDC_MAX_LAYER);
 
+	/*
+	 * Check the security of layer 2.
+	 * Do not expose this layer to the user (do not create a plan)
+	 * if this one is reserved for secure application.
+	 */
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc")) {
+		ret = stm32_rifsc_check_access_by_id(STM32MP25_RIFSC_LTDC_L2_ID);
+		if (ret)
+			ldev->caps.nb_layers--;
+	}
+
 	/* set data bus width */
 	regmap_read(ldev->regmap, LTDC_GC2R, &gc2r);
 	bus_width_log2 = (gc2r & GC2R_BW) >> 4;
 	ldev->caps.bus_width = 8 << bus_width_log2;
 	regmap_read(ldev->regmap, LTDC_IDR, &ldev->caps.hw_version);
 
+	ldev->caps.pad_max_freq_hz = pdata->pad_max_freq_hz;
+
 	switch (ldev->caps.hw_version) {
 	case HWVER_10200:
 	case HWVER_10300:
@@ -1836,7 +2252,6 @@ static int ltdc_get_caps(struct drm_device *ddev)
 		 * does not work on 2nd layer.
 		 */
 		ldev->caps.non_alpha_only_l1 = true;
-		ldev->caps.pad_max_freq_hz = 90000000;
 		if (ldev->caps.hw_version == HWVER_10200)
 			ldev->caps.pad_max_freq_hz = 65000000;
 		ldev->caps.nb_irq = 2;
@@ -1846,6 +2261,7 @@ static int ltdc_get_caps(struct drm_device *ddev)
 		ldev->caps.crc = false;
 		ldev->caps.dynamic_zorder = false;
 		ldev->caps.plane_rotation = false;
+		ldev->caps.crtc_rotation = false;
 		ldev->caps.fifo_threshold = false;
 		break;
 	case HWVER_20101:
@@ -1864,9 +2280,11 @@ static int ltdc_get_caps(struct drm_device *ddev)
 		ldev->caps.crc = false;
 		ldev->caps.dynamic_zorder = false;
 		ldev->caps.plane_rotation = false;
+		ldev->caps.crtc_rotation = false;
 		ldev->caps.fifo_threshold = false;
 		break;
 	case HWVER_40100:
+	case HWVER_40101:
 		ldev->caps.layer_ofs = LAY_OFS_1;
 		ldev->caps.layer_regs = ltdc_layer_regs_a2;
 		ldev->caps.pix_fmt_hw = ltdc_pix_fmt_a2;
@@ -1874,7 +2292,6 @@ static int ltdc_get_caps(struct drm_device *ddev)
 		ldev->caps.pix_fmt_nb = ARRAY_SIZE(ltdc_drm_fmt_a2);
 		ldev->caps.pix_fmt_flex = true;
 		ldev->caps.non_alpha_only_l1 = false;
-		ldev->caps.pad_max_freq_hz = 90000000;
 		ldev->caps.nb_irq = 2;
 		ldev->caps.ycbcr_input = true;
 		ldev->caps.ycbcr_output = true;
@@ -1882,7 +2299,22 @@ static int ltdc_get_caps(struct drm_device *ddev)
 		ldev->caps.crc = true;
 		ldev->caps.dynamic_zorder = true;
 		ldev->caps.plane_rotation = true;
+		/* check if the outuput rotaion is available */
+		if (gc2r & GC2R_ROTA)
+			ldev->caps.crtc_rotation = true;
+		else
+			ldev->caps.crtc_rotation = false;
 		ldev->caps.fifo_threshold = true;
+
+		for (int i = 0; i < lcr; i++) {
+			/* read 1st register of layer's configuration */
+			regmap_read(ldev->regmap, LTDC_L1C1R + i * LAY_OFS, &lxc1r);
+
+			if (lxc1r & LXCR_C1R_SCA)
+				ldev->caps.plane_scaling[i] = true;
+			else
+				ldev->caps.plane_scaling[i] = false;
+		}
 		break;
 	default:
 		return -ENODEV;
@@ -1891,17 +2323,17 @@ static int ltdc_get_caps(struct drm_device *ddev)
 	return 0;
 }
 
-void ltdc_suspend(struct drm_device *ddev)
+void ltdc_suspend(struct ltdc_device *ldev)
 {
-	struct ltdc_device *ldev = ddev->dev_private;
-
 	DRM_DEBUG_DRIVER("\n");
+
 	clk_disable_unprepare(ldev->pixel_clk);
+	if (ldev->bus_clk)
+		clk_disable_unprepare(ldev->bus_clk);
 }
 
-int ltdc_resume(struct drm_device *ddev)
+int ltdc_resume(struct ltdc_device *ldev)
 {
-	struct ltdc_device *ldev = ddev->dev_private;
 	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
@@ -1911,6 +2343,12 @@ int ltdc_resume(struct drm_device *ddev)
 		DRM_ERROR("failed to enable pixel clock (%d)\n", ret);
 		return ret;
 	}
+	if (ldev->bus_clk) {
+		if (clk_prepare_enable(ldev->bus_clk)) {
+			DRM_ERROR("Unable to prepare bus clock\n");
+			return -ENODEV;
+		}
+	}
 
 	return 0;
 }
@@ -1925,9 +2363,10 @@ int ltdc_load(struct drm_device *ddev)
 	struct drm_panel *panel;
 	struct drm_crtc *crtc;
 	struct reset_control *rstc;
-	struct resource *res;
 	int irq, i, nb_endpoints;
 	int ret = -ENODEV;
+	u32 mbl;
+	bool def_value;
 
 	DRM_DEBUG_DRIVER("\n");
 
@@ -1936,16 +2375,14 @@ int ltdc_load(struct drm_device *ddev)
 	if (!nb_endpoints)
 		return -ENODEV;
 
-	ldev->pixel_clk = devm_clk_get(dev, "lcd");
-	if (IS_ERR(ldev->pixel_clk)) {
-		if (PTR_ERR(ldev->pixel_clk) != -EPROBE_DEFER)
-			DRM_ERROR("Unable to get lcd clock\n");
-		return PTR_ERR(ldev->pixel_clk);
-	}
-
-	if (clk_prepare_enable(ldev->pixel_clk)) {
-		DRM_ERROR("Unable to prepare pixel clock\n");
-		return -ENODEV;
+	if (of_device_is_compatible(np, "st,stm32mp25-ltdc")) {
+		/* Get max burst length */
+		ret = of_property_read_u32(np, "st,burstlen", &mbl);
+		if (ret)
+			/* set to max burst length value */
+			ldev->max_burst_length = 0;
+		else
+			ldev->max_burst_length = mbl / 8;
 	}
 
 	/* Get endpoints if any */
@@ -1960,7 +2397,7 @@ int ltdc_load(struct drm_device *ddev)
 		if (ret == -ENODEV)
 			continue;
 		else if (ret)
-			goto err;
+			return ret;
 
 		if (panel) {
 			bridge = drm_panel_bridge_add_typed(panel,
@@ -1968,7 +2405,7 @@ int ltdc_load(struct drm_device *ddev)
 			if (IS_ERR(bridge)) {
 				DRM_ERROR("panel-bridge endpoint %d\n", i);
 				ret = PTR_ERR(bridge);
-				goto err;
+				return ret;
 			}
 		}
 
@@ -1977,7 +2414,7 @@ int ltdc_load(struct drm_device *ddev)
 			if (ret) {
 				if (ret != -EPROBE_DEFER)
 					DRM_ERROR("init encoder endpoint %d\n", i);
-				goto err;
+				return ret;
 			}
 		}
 	}
@@ -1986,20 +2423,38 @@ int ltdc_load(struct drm_device *ddev)
 
 	mutex_init(&ldev->err_lock);
 
-	if (!IS_ERR(rstc)) {
-		reset_control_assert(rstc);
-		usleep_range(10, 20);
-		reset_control_deassert(rstc);
+	def_value = device_property_read_bool(dev, "default-on");
+
+	/*
+	 * To obtain a continuous display after the probe, the clocks must
+	 * remain activated and reset shouldn't be done
+	 */
+	if (!def_value) {
+		if (!IS_ERR(rstc)) {
+			reset_control_assert(rstc);
+			usleep_range(10, 20);
+			reset_control_deassert(rstc);
+		}
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	ldev->regs = devm_ioremap_resource(dev, res);
+	ldev->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(ldev->regs)) {
 		DRM_ERROR("Unable to get ltdc registers\n");
 		ret = PTR_ERR(ldev->regs);
 		goto err;
 	}
 
+	/*
+	 * Check the security of layer 2.
+	 * If layer 2 is secure then its registers are not accessible
+	 * (reduce mapping of ltdc registers to common registers and layers 0 and 1 registers).
+	 */
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc")) {
+		ret = stm32_rifsc_check_access_by_id(STM32MP25_RIFSC_LTDC_L2_ID);
+		if (ret)
+			stm32_ltdc_regmap_cfg.max_register = 0x300;
+	}
+
 	ldev->regmap = devm_regmap_init_mmio(&pdev->dev, ldev->regs, &stm32_ltdc_regmap_cfg);
 	if (IS_ERR(ldev->regmap)) {
 		DRM_ERROR("Unable to regmap ltdc registers\n");
@@ -2014,13 +2469,8 @@ int ltdc_load(struct drm_device *ddev)
 		goto err;
 	}
 
-	/* Disable interrupts */
-	if (ldev->caps.fifo_threshold)
-		regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE | IER_RRIE | IER_FUWIE |
-				  IER_TERRIE);
-	else
-		regmap_clear_bits(ldev->regmap, LTDC_IER, IER_LIE | IER_RRIE | IER_FUWIE |
-				  IER_TERRIE | IER_FUEIE);
+	/* Disable all interrupts */
+	regmap_clear_bits(ldev->regmap, LTDC_IER, IER_MASK);
 
 	DRM_DEBUG_DRIVER("ltdc hw version 0x%08x\n", ldev->caps.hw_version);
 
@@ -2028,8 +2478,13 @@ int ltdc_load(struct drm_device *ddev)
 	ldev->transfer_err = 0;
 	ldev->fifo_err = 0;
 	ldev->fifo_warn = 0;
+	ldev->fifo_rot = 0;
 	ldev->fifo_threshold = FUT_DFT;
 
+	/* initialize default value for vblank & crc active flags */
+	ldev->crc_active = false;
+	ldev->vblank_active = false;
+
 	for (i = 0; i < ldev->caps.nb_irq; i++) {
 		irq = platform_get_irq(pdev, i);
 		if (irq < 0) {
@@ -2065,19 +2520,33 @@ int ltdc_load(struct drm_device *ddev)
 		goto err;
 	}
 
-	clk_disable_unprepare(ldev->pixel_clk);
+	pm_runtime_set_active(ddev->dev);
+	pm_runtime_enable(ddev->dev);
 
-	pinctrl_pm_select_sleep_state(ddev->dev);
+	if (def_value) {
+		/* keep runtime active after the probe */
+		pm_runtime_get_sync(ddev->dev);
+	} else {
+		/* set to sleep state the pinctrl to stop data trasfert */
+		pinctrl_pm_select_sleep_state(ddev->dev);
+	}
 
-	pm_runtime_enable(ddev->dev);
+	/* Get the secure rotation buffer memory resource */
+	np = of_parse_phandle(dev->of_node, "rotation-memory", 0);
+	if (np)
+		ldev->rot_mem = of_reserved_mem_lookup(np);
+
+	/* fail to get reserved memory for rotation */
+	if (!ldev->rot_mem)
+		ldev->caps.crtc_rotation = false;
 
 	return 0;
 err:
+	of_reserved_mem_device_release(dev);
+
 	for (i = 0; i < nb_endpoints; i++)
 		drm_of_panel_bridge_remove(ddev->dev->of_node, 0, i);
 
-	clk_disable_unprepare(ldev->pixel_clk);
-
 	return ret;
 }
 
@@ -2096,6 +2565,97 @@ void ltdc_unload(struct drm_device *ddev)
 	pm_runtime_disable(ddev->dev);
 }
 
+int ltdc_parse_device_tree(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct drm_bridge *bridge;
+	struct drm_panel *panel;
+	int i, nb_endpoints;
+	int ret = -ENODEV;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	/* Get number of endpoints */
+	nb_endpoints = of_graph_get_endpoint_count(np);
+	if (!nb_endpoints)
+		return -ENODEV;
+
+	/* Get endpoints if any */
+	for (i = 0; i < nb_endpoints; i++) {
+		ret = drm_of_find_panel_or_bridge(np, 0, i, &panel, &bridge);
+
+		/*
+		 * If at least one endpoint is -ENODEV, continue probing,
+		 * else if at least one endpoint returned an error
+		 * (ie -EPROBE_DEFER) then stop probing.
+		 */
+		if (ret == -ENODEV)
+			continue;
+		else if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int ltdc_get_clk(struct device *dev, struct ltdc_device *ldev)
+{
+	struct device_node *node;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ldev->pixel_clk = devm_clk_get(dev, "lcd");
+	if (IS_ERR(ldev->pixel_clk)) {
+		if (PTR_ERR(ldev->pixel_clk) != -EPROBE_DEFER)
+			DRM_ERROR("Unable to get lcd clock\n");
+		return PTR_ERR(ldev->pixel_clk);
+	}
+
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp25-ltdc")) {
+		ldev->bus_clk = devm_clk_get(dev, "bus");
+		if (IS_ERR(ldev->bus_clk))
+			return dev_err_probe(dev, PTR_ERR(ldev->bus_clk),
+					     "Unable to get bus clock\n");
+
+		ldev->ltdc_clk = devm_clk_get(dev, "ref");
+		if (IS_ERR(ldev->ltdc_clk))
+			return dev_err_probe(dev, PTR_ERR(ldev->ltdc_clk),
+					     "Unable to get ltdc clock\n");
+
+		/*
+		 * The lvds output clock is not available if the lvds is not probed.
+		 * This is a usual case, it is necessary to check the node to avoid
+	 * looking for a clock that will never be available.
+		 */
+		node = of_find_compatible_node(NULL, NULL, "st,stm32mp25-lvds");
+		if (!IS_ERR(node)) {
+			if (of_device_is_available(node)) {
+				ldev->lvds_clk = devm_clk_get(dev, "lvds");
+				if (IS_ERR(ldev->lvds_clk)) {
+					return dev_err_probe(dev, PTR_ERR(ldev->lvds_clk),
+							     "Unable to get lvds clock\n");
+				}
+			}
+			of_node_put(node);
+		}
+
+		/*
+		 * Parent of the pixel clock should default to the reference clock (rcc clock).
+		 * If the driver has already been started, this action is not necessary and
+		 *  may cause an issue on register reading/writing.
+		 */
+		if (!device_property_read_bool(dev, "default-on")) {
+			ret = clk_set_parent(ldev->pixel_clk, ldev->ltdc_clk);
+			if (ret)
+				return dev_err_probe(dev, PTR_ERR(ldev->lvds_clk),
+						     "Could not set parent clock\n");
+		}
+	}
+
+	return 0;
+}
+
 MODULE_AUTHOR("Philippe Cornu <philippe.cornu@st.com>");
 MODULE_AUTHOR("Yannick Fertre <yannick.fertre@st.com>");
 MODULE_AUTHOR("Fabien Dessenne <fabien.dessenne@st.com>");
diff --git a/drivers/gpu/drm/stm/ltdc.h b/drivers/gpu/drm/stm/ltdc.h
index 9d488043f..b8883ff99 100644
--- a/drivers/gpu/drm/stm/ltdc.h
+++ b/drivers/gpu/drm/stm/ltdc.h
@@ -11,6 +11,8 @@
 #ifndef _LTDC_H_
 #define _LTDC_H_
 
+#define LTDC_MAX_LAYER	4
+
 struct ltdc_caps {
 	u32 hw_version;		/* hardware version */
 	u32 nb_layers;		/* number of supported layers */
@@ -30,36 +32,50 @@ struct ltdc_caps {
 	bool crc;		/* cyclic redundancy check supported */
 	bool dynamic_zorder;	/* dynamic z-order */
 	bool plane_rotation;	/* plane rotation */
+	bool crtc_rotation;	/* crtc rotation */
 	bool fifo_threshold;	/* fifo underrun threshold supported */
+	bool plane_scaling[LTDC_MAX_LAYER];	/* plane scaling ability */
 };
 
-#define LTDC_MAX_LAYER	4
-
 struct fps_info {
 	unsigned int counter;
 	ktime_t last_timestamp;
 };
 
+struct ltdc_plat_data {
+	int pad_max_freq_hz;	/* max frequency supported by pad */
+};
+
 struct ltdc_device {
 	void __iomem *regs;
 	struct regmap *regmap;
 	struct clk *pixel_clk;	/* lcd pixel clock */
+	struct clk *bus_clk;	/* bus clock */
+	struct clk *ltdc_clk;	/* kernel clock */
+	struct clk *lvds_clk;	/* lvds clock */
 	struct mutex err_lock;	/* protecting error_status */
 	struct ltdc_caps caps;
 	u32 irq_status;
 	u32 fifo_err;		/* fifo underrun error counter */
 	u32 fifo_warn;		/* fifo underrun warning counter */
+	u32 fifo_rot;		/* fifo underrun rotation counter */
 	u32 fifo_threshold;	/* fifo underrun threshold */
 	u32 transfer_err;	/* transfer error counter */
 	struct fps_info plane_fpsi[LTDC_MAX_LAYER];
 	struct drm_atomic_state *suspend_state;
 	int crc_skip_count;
 	bool crc_active;
+	bool vblank_active;
+	u32 crc;
+	u32 max_burst_length;
+	struct reserved_mem *rot_mem;
 };
 
+int ltdc_parse_device_tree(struct device *dev);
+int ltdc_get_clk(struct device *dev, struct ltdc_device *ldev);
 int ltdc_load(struct drm_device *ddev);
 void ltdc_unload(struct drm_device *ddev);
-void ltdc_suspend(struct drm_device *ddev);
-int ltdc_resume(struct drm_device *ddev);
+void ltdc_suspend(struct ltdc_device *ldev);
+int ltdc_resume(struct ltdc_device *ldev);
 
 #endif
diff --git a/drivers/gpu/drm/stm/lvds.c b/drivers/gpu/drm/stm/lvds.c
new file mode 100644
index 000000000..313fc51ac
--- /dev/null
+++ b/drivers/gpu/drm/stm/lvds.c
@@ -0,0 +1,1360 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Raphal GALLAIS-POU <raphael.gallais-pou@foss.st.com> for STMicroelectronics.
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_device.h>
+#include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+
+/* LVDS Host registers */
+#define LVDS_CR		0x0000  /* configuration register */
+#define LVDS_DMLCR0	0x0004  /* data mapping lsb configuration register 0	*/
+#define LVDS_DMMCR0	0x0008  /* data mapping msb configuration register 0	*/
+#define LVDS_DMLCR1	0x000C  /* data mapping lsb configuration register 1	*/
+#define LVDS_DMMCR1	0x0010  /* data mapping msb configuration register 1	*/
+#define LVDS_DMLCR2	0x0014  /* data mapping lsb configuration register 2	*/
+#define LVDS_DMMCR2	0x0018  /* data mapping msb configuration register 2	*/
+#define LVDS_DMLCR3	0x001C  /* data mapping lsb configuration register 3	*/
+#define LVDS_DMMCR3	0x0020  /* data mapping msb configuration register 3	*/
+#define LVDS_DMLCR4	0x0024  /* data mapping lsb configuration register 4	*/
+#define LVDS_DMMCR4	0x0028  /* data mapping msb configuration register 4	*/
+#define LVDS_CDL1CR	0x002C  /* channel distrib link 1 configuration register	*/
+#define LVDS_CDL2CR	0x0030  /* channel distrib link 2 configuration register	*/
+
+#define CDL1CR_DEFAULT	0x04321	/* Default value for CDL1CR */
+#define CDL2CR_DEFAULT	0x59876	/* Default value for CDL2CR */
+
+/* LVDS Wrapper registers */
+#define LVDS_WCLKCR	0x11B0  /* Wrapper clock control register */
+
+#define LVDS_HWCFGR	0x1FF0  /* HW configuration register	*/
+#define LVDS_VERR	0x1FF4  /* Version register	*/
+#define LVDS_IPIDR	0x1FF8  /* Identification register	*/
+#define LVDS_SIDR	0x1FFC  /* Size Identification register	*/
+
+#define CR_LVDSEN	BIT(0)  /* LVDS PHY Enable */
+#define CR_HSPOL	BIT(1)  /* HS Polarity (horizontal sync) */
+#define CR_VSPOL	BIT(2)  /* VS Polarity (vertical sync) */
+#define CR_DEPOL	BIT(3)  /* DE Polarity (data enable) */
+#define CR_CI		BIT(4)  /* Control Internal (software controlled bit) */
+#define CR_LKMOD	BIT(5)  /* Link Mode, for both Links */
+#define CR_LKPHA	BIT(6)  /* Link Phase, for both Links */
+#define CR_LK1POL	GENMASK(20, 16)  /* Link-1 output Polarity */
+#define CR_LK2POL	GENMASK(25, 21)  /* Link-2 output Polarity */
+
+#define DMMCRx_MAP0	GENMASK(4, 0)
+#define DMMCRx_MAP1	GENMASK(9, 5)
+#define DMMCRx_MAP2	GENMASK(14, 10)
+#define DMMCRx_MAP3	GENMASK(19, 15)
+#define DMLCRx_MAP4	GENMASK(4, 0)
+#define DMLCRx_MAP5	GENMASK(9, 5)
+#define DMLCRx_MAP6	GENMASK(14, 10)
+
+#define CDLCRx_DISTR0	GENMASK(3, 0)
+#define CDLCRx_DISTR1	GENMASK(7, 4)
+#define CDLCRx_DISTR2	GENMASK(11, 8)
+#define CDLCRx_DISTR3	GENMASK(15, 12)
+#define CDLCRx_DISTR4	GENMASK(19, 16)
+
+#define FREF_INDEX	0
+#define NDIV_INDEX	1
+#define FPFD_INDEX	2
+#define MDIV_INDEX	3
+#define FVCO_INDEX	4
+#define BDIV_INDEX	5
+#define FBIT_INDEX	6
+#define FLS_INDEX	7
+#define FDP_INDEX	8
+
+#define PHY_GCR_BIT_CLK_OUT	BIT(0)
+#define PHY_GCR_LS_CLK_OUT	BIT(4)
+#define PHY_GCR_DP_CLK_OUT	BIT(8)
+#define PHY_GCR_RSTZ		BIT(24)
+#define PHY_GCR_DIV_RSTN	BIT(25)
+
+#define PHY_PxPLLTESTCR_TDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_NDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_BDIV	GENMASK(9, 0)
+#define PHY_PxPLLSDCR1_MDIV	GENMASK(9, 0)
+
+#define PLL_EN		BIT(0)
+#define PLL_LOCK	BIT(0)
+#define CM_EN_DL	(BIT(28) | BIT(20) | BIT(12) | BIT(4))
+#define CM_EN_DL4	BIT(4)
+#define VM_EN_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_BIAS_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_DIG_DL	GENMASK(4, 0)
+#define BIAS_EN		BIT(28)
+#define POWER_OK	BIT(12)
+
+#define WCLKCR_SLV_CLKPIX_SEL	BIT(0)
+#define WCLKCR_SRCSEL		BIT(8)
+
+/* Sleep & timeout for pll lock/unlock */
+#define SLEEP_US	1000
+#define TIMEOUT_US	200000
+
+#define PHY_SLV_OFS	0x100
+
+/*
+ * The link phase defines whether an ODD pixel is carried over together with
+ * the next EVEN pixel or together with the previous EVEN pixel.
+ *
+ * LVDS_DUAL_LINK_EVEN_ODD_PIXELS (LKPHA = 0)
+ *
+ * ,--------.  ,--------.  ,--------.  ,--------.  ,---------.
+ * | ODD  LK \/ PIXEL  3 \/ PIXEL  1 \/ PIXEL' 1 \/ PIXEL' 3 |
+ * | EVEN LK /\ PIXEL  2 /\ PIXEL' 0 /\ PIXEL' 2 /\ PIXEL' 4 |
+ * `--------'  `--------'  `--------'  `--------'  `---------'
+ *
+ * LVDS_DUAL_LINK_ODD_EVEN_PIXELS (LKPHA = 1)
+ *
+ * ,--------.  ,--------.  ,--------.  ,--------.  ,---------.
+ * | ODD  LK \/ PIXEL  3 \/ PIXEL  1 \/ PIXEL' 1 \/ PIXEL' 3 |
+ * | EVEN LK /\ PIXEL  4 /\ PIXEL  2 /\ PIXEL' 0 /\ PIXEL' 2 |
+ * `--------'  `--------'  `--------'  `--------'  `---------'
+ *
+ */
+enum lvds_link_type {
+	LVDS_SINGLE_LINK_MASTER = 0,
+	LVDS_SINGLE_LINK_SLAVE = 1,
+	LVDS_DUAL_LINK_EVEN_ODD_PIXELS = 2,
+	LVDS_DUAL_LINK_ODD_EVEN_PIXELS = 3,
+};
+
+enum lvds_pixel {
+	PIX_R_0		= 0x00,
+	PIX_R_1		= 0x01,
+	PIX_R_2		= 0x02,
+	PIX_R_3		= 0x03,
+	PIX_R_4		= 0x04,
+	PIX_R_5		= 0x05,
+	PIX_R_6		= 0x06,
+	PIX_R_7		= 0x07,
+	PIX_G_0		= 0x08,
+	PIX_G_1		= 0x09,
+	PIX_G_2		= 0x0A,
+	PIX_G_3		= 0x0B,
+	PIX_G_4		= 0x0C,
+	PIX_G_5		= 0x0D,
+	PIX_G_6		= 0x0E,
+	PIX_G_7		= 0x0F,
+	PIX_B_0		= 0x10,
+	PIX_B_1		= 0x11,
+	PIX_B_2		= 0x12,
+	PIX_B_3		= 0x13,
+	PIX_B_4		= 0x14,
+	PIX_B_5		= 0x15,
+	PIX_B_6		= 0x16,
+	PIX_B_7		= 0x17,
+	PIX_H_S		= 0x18,
+	PIX_V_S		= 0x19,
+	PIX_D_E		= 0x1A,
+	PIX_C_E		= 0x1B,
+	PIX_C_I		= 0x1C,
+	PIX_TOG		= 0x1D,
+	PIX_ONE		= 0x1E,
+	PIX_ZER		= 0x1F,
+};
+
+struct phy_offsets {
+	u32 PxGCR;	/* Global Control Register	*/
+	u32 PxCMCR1;    /* Current Mode Control Register 1 */
+	u32 PxCMCR2;    /* Current Mode Control Register 2 */
+	u32 PxSCR;      /* Serial Control Register	*/
+	u32 PxBCR1;     /* Bias Control Register 1	*/
+	u32 PxBCR2;     /* Bias Control Register 2	*/
+	u32 PxBCR3;     /* Bias Control Register 3	*/
+	u32 PxMPLCR;    /* Monitor PLL Lock Control Register */
+	u32 PxDCR;      /* Debug Control Register	*/
+	u32 PxSSR1;     /* Spare Status Register 1	*/
+	u32 PxCFGCR;    /* Configuration Control Register */
+	u32 PxPLLCR1;   /* PLL_MODE 1 Control Register	*/
+	u32 PxPLLCR2;   /* PLL_MODE 2 Control Register	*/
+	u32 PxPLLSR;    /* PLL Status Register	*/
+	u32 PxPLLSDCR1; /* PLL_SD_1 Control Register	*/
+	u32 PxPLLSDCR2; /* PLL_SD_2 Control Register	*/
+	u32 PxPLLTWGCR1;/* PLL_TWG_1 Control Register	*/
+	u32 PxPLLTWGCR2;/* PLL_TWG_2 Control Register	*/
+	u32 PxPLLCPCR;	/* PLL_CP Control Register	*/
+	u32 PxPLLTESTCR;/* PLL_TEST Control Register	*/
+};
+
+struct lvds_phy_info {
+	u32 base;
+	struct phy_offsets ofs;
+};
+
+static struct lvds_phy_info lvds_phy_16ff_master = {
+	.base = 0x1000,
+	.ofs = {
+		.PxGCR = 0x0,
+		.PxCMCR1 = 0xC,
+		.PxCMCR2 = 0x10,
+		.PxSCR = 0x20,
+		.PxBCR1 = 0x2C,
+		.PxBCR2 = 0x30,
+		.PxBCR3 = 0x34,
+		.PxMPLCR = 0x64,
+		.PxDCR = 0x84,
+		.PxSSR1 = 0x88,
+		.PxCFGCR = 0xA0,
+		.PxPLLCR1 = 0xC0,
+		.PxPLLCR2 = 0xC4,
+		.PxPLLSR = 0xC8,
+		.PxPLLSDCR1 = 0xCC,
+		.PxPLLSDCR2 = 0xD0,
+		.PxPLLTWGCR1 = 0xD4,
+		.PxPLLTWGCR2 = 0xD8,
+		.PxPLLCPCR = 0xE0,
+		.PxPLLTESTCR = 0xE8,
+	}
+};
+
+static struct lvds_phy_info lvds_phy_16ff_slave = {
+	.base = 0x1100,
+	.ofs = {
+		.PxGCR = 0x0,
+		.PxCMCR1 = 0xC,
+		.PxCMCR2 = 0x10,
+		.PxSCR = 0x20,
+		.PxBCR1 = 0x2C,
+		.PxBCR2 = 0x30,
+		.PxBCR3 = 0x34,
+		.PxMPLCR = 0x64,
+		.PxDCR = 0x84,
+		.PxSSR1 = 0x88,
+		.PxCFGCR = 0xA0,
+		.PxPLLCR1 = 0xC0,
+		.PxPLLCR2 = 0xC4,
+		.PxPLLSR = 0xC8,
+		.PxPLLSDCR1 = 0xCC,
+		.PxPLLSDCR2 = 0xD0,
+		.PxPLLTWGCR1 = 0xD4,
+		.PxPLLTWGCR2 = 0xD8,
+		.PxPLLCPCR = 0xE0,
+		.PxPLLTESTCR = 0xE8,
+	}
+};
+
+struct lvds_clk_data {
+	const char *clk_name;
+	const struct clk_ops *clk_ops;
+	const char * const *clk_src;
+	unsigned int max_clk_src;
+};
+
+struct stm_lvds {
+	void __iomem *base;
+	struct device *dev;
+	struct clk *pclk;		/* APB bus clock */
+	struct clk *pllref_clk;		/* HSE / Flexclkgen */
+	struct clk_hw lvds_ck_px;	/* Pixel clock */
+	u32 pixel_clock_rate;		/* Pixel clock rate */
+	struct {
+		u32 hw_version;
+		u32 link_type;
+	} config;
+	struct lvds_phy_info *phy_master;
+	struct lvds_phy_info *phy_slave;
+
+	struct drm_bridge	lvds_bridge;
+	struct drm_bridge	*next_bridge;
+	struct drm_connector	connector;
+	struct drm_encoder	*encoder;
+	struct drm_panel	*panel;
+
+	struct regulator *vdd_supply;
+	struct regulator *vdda18_supply;
+};
+
+#define bridge_to_stm_lvds(b) \
+	container_of(b, struct stm_lvds, lvds_bridge)
+
+#define connector_to_stm_lvds(c) \
+	container_of(c, struct stm_lvds, connector)
+
+#define lvds_is_dual_link(lvds) \
+	({	\
+	typeof(lvds) __lvds = (lvds);	\
+	__lvds == LVDS_DUAL_LINK_EVEN_ODD_PIXELS ||	\
+	__lvds == LVDS_DUAL_LINK_ODD_EVEN_PIXELS;	\
+	})
+
+static inline void lvds_write(struct stm_lvds *lvds, u32 reg, u32 val)
+{
+	writel(val, lvds->base + reg);
+}
+
+static inline u32 lvds_read(struct stm_lvds *lvds, u32 reg)
+{
+	return readl(lvds->base + reg);
+}
+
+static inline void lvds_set(struct stm_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_write(lvds, reg, lvds_read(lvds, reg) | mask);
+}
+
+static inline void lvds_clear(struct stm_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_write(lvds, reg, lvds_read(lvds, reg) & ~mask);
+}
+
+static inline void lvds_update_bits(struct stm_lvds *lvds, u32 reg,
+				    u32 mask, u32 val)
+{
+	lvds_write(lvds, reg, (lvds_read(lvds, reg) & ~mask) | val);
+}
+
+/*
+ * Expected JEIDA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ * CHAN0   {ONE, ONE, ZERO, ZERO, ZERO, ONE, ONE}
+ * CHAN1   {G2,  R7,  R6,   R5,   R4,   R3,  R2}
+ * CHAN2   {B3,  B2,  G7,   G6,   G5,   G4,  G3}
+ * CHAN3   {DE,  VS,  HS,   B7,   B6,   B5,  B4}
+ * CHAN4   {CE,  B1,  B0,   G1,   G0,   R1,  R0}
+ */
+const enum lvds_pixel lvds_bitmap_jeida_rgb888[5][7] = {
+	{
+		PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE
+	}, {
+		PIX_G_2, PIX_R_7, PIX_R_6, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2
+	}, {
+		PIX_B_3, PIX_B_2, PIX_G_7, PIX_G_6, PIX_G_5, PIX_G_4, PIX_G_3
+	}, {
+		PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_7, PIX_B_6, PIX_B_5, PIX_B_4
+	}, {
+		PIX_C_E, PIX_B_1, PIX_B_0, PIX_G_1, PIX_G_0, PIX_R_1, PIX_R_0
+	}
+};
+
+/*
+ * Expected VESA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ * CHAN0   {ONE, ONE, ZERO, ZERO, ZERO, ONE, ONE}
+ * CHAN1   {G0,  R5,  R4,   R3,   R2,   R1,  R0}
+ * CHAN2   {B1,  B0,  G5,   G4,   G3,   G2,  G1}
+ * CHAN3   {DE,  VS,  HS,   B5,   B4,   B3,  B2}
+ * CHAN4   {CE,  B7,  B6,   G7,   G6,   R7,  R6}
+ */
+const enum lvds_pixel lvds_bitmap_vesa_rgb888[5][7] = {
+	{
+		PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE
+	}, {
+		PIX_G_0, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2, PIX_R_1, PIX_R_0
+	}, {
+		PIX_B_1, PIX_B_0, PIX_G_5, PIX_G_4, PIX_G_3, PIX_G_2, PIX_G_1
+	}, {
+		PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_5, PIX_B_4, PIX_B_3, PIX_B_2
+	}, {
+		PIX_C_E, PIX_B_7, PIX_B_6, PIX_G_7, PIX_G_6, PIX_R_7, PIX_R_6
+	}
+};
+
+static int lvds_pll_enable(struct stm_lvds *lvds, struct lvds_phy_info *phy)
+{
+	u32 lvds_gcr;
+	int ret, val;
+
+	/* PLL lock timing control for the monitor unmask after startup (pll_en) */
+	/* Adjust the value so that the masking window is opened at start-up */
+	/* MST_MON_PLL_LOCK_UNMASK_TUNE */
+	lvds_write(lvds, phy->base + phy->ofs.PxMPLCR, (0x200 - 0x160) << 16);
+
+	lvds_write(lvds, phy->base + phy->ofs.PxBCR2, BIAS_EN);
+
+	lvds_gcr = PHY_GCR_DP_CLK_OUT | PHY_GCR_LS_CLK_OUT | PHY_GCR_BIT_CLK_OUT;
+	lvds_set(lvds, phy->base + phy->ofs.PxGCR, lvds_gcr);
+
+	/* TODO hardcoded values for now */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLTESTCR, BIT(8) /* PLL_TEST_DIV_EN */);
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCR1, BIT(8) /* PLL_DIVIDERS_ENABLE */);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxSCR, BIT(16) /* SER_DATA_OK */);
+
+	/* Enable the LVDS PLL & wait for its lock */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCR1, PLL_EN);
+	ret = readl_poll_timeout_atomic(lvds->base + phy->base + phy->ofs.PxPLLSR,
+					val, val & PLL_LOCK,
+					SLEEP_US, TIMEOUT_US);
+	if (ret)
+		DRM_ERROR("!TIMEOUT! waiting PLL, let's continue\n");
+
+	/* Select MST PHY clock as pixel clock for the LDITX instead of FREF */
+	/* WCLKCR_SLV_CLKPIX_SEL is for dual link */
+	lvds_write(lvds, LVDS_WCLKCR, WCLKCR_SLV_CLKPIX_SEL);
+
+	/* JF Duret */
+	lvds_set(lvds, phy->ofs.PxPLLTESTCR, BIT(0));
+
+	return ret;
+}
+
+/* Integer mode */
+#define EN_SD		0
+#define EN_TWG		0
+#define DOWN_SPREAD	0
+#define TEST_DIV	70
+
+static int pll_get_clkout_khz(int clkin_khz, int bdiv, int mdiv, int ndiv)
+{
+	int divisor = ndiv * bdiv;
+
+	/* Prevents from division by 0 */
+	if (!divisor)
+		return 0;
+
+	return clkin_khz * mdiv / divisor;
+}
+
+#define NDIV_MIN	2
+#define NDIV_MAX	6
+#define BDIV_MIN	2
+#define BDIV_MAX	6
+#define MDIV_MIN	1
+#define MDIV_MAX	1023
+
+static int lvds_pll_get_params(struct stm_lvds *lvds,
+			       unsigned int clkin_khz, unsigned int clkout_khz,
+			       unsigned int *bdiv, unsigned int *mdiv, unsigned int *ndiv)
+{
+	int i, o, n;
+	int delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = NDIV_MIN; i <= NDIV_MAX; i++) {
+		for (o = BDIV_MIN; o <= BDIV_MAX; o++) {
+			n = DIV_ROUND_CLOSEST(i * o * clkout_khz, clkin_khz);
+			/* Check ndiv according to vco range */
+			if (n < MDIV_MIN || n > MDIV_MAX)
+				continue;
+			/* Check if new delta is better & saves parameters */
+			delta = pll_get_clkout_khz(clkin_khz, i, n, o) - clkout_khz;
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				*ndiv = i;
+				*mdiv = n;
+				*bdiv = o;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static void lvds_pll_config(struct stm_lvds *lvds, struct lvds_phy_info *phy)
+{
+	/* Set PLL Slv & Mst configs and timings */
+	struct clk_hw *hwclk;
+	unsigned int pll_in_khz, bdiv, mdiv, ndiv;
+	int multiplier;
+
+	/*
+	 * The LVDS PLL is made of a pre-divider and a multiplier (strangely
+	 * enough called M and N respectively), followed by a post-divider E.
+	 *
+	 *          ,------.         ,-----.     ,-----.
+	 * Fref --> | NDIV | -Fpdf-> | PFD | --> | VCO | --> Fvco
+	 *          `------'     ,-> |     |     `-----'  |
+	 *                       |   `-----'              |
+	 *                       |         ,------.       |
+	 *                       `-------- | MDIV | <-----'
+	 *                                 `------'
+	 *
+	 * The clock output by the PLL is then further divided by a programmable
+	 * divider DIV to achieve the desired target frequency. Finally, an
+	 * optional fixed /7 divider is used to convert the bit clock to a pixel
+	 * clock (as LVDS transmits 7 bits per lane per clock sample).
+	 *
+	 *          ,------.     ,-----.     ,-------.     |\
+	 * Fvco --> | BDIV | --> | 1/7 | --> | 1/3.5 | --> | |
+	 *          `------'  |  `-----'     `-------'     | | --> dot clock
+	 *                    `--------------------------> | |
+	 *                                                 |/
+	 *
+	 * The /7 divider is optional, it is enabled when the LVDS PLL is used
+	 * to drive the LVDS encoder, and disabled when used to generate a dot
+	 * clock for the display unit RGB output, without using the LVDS
+	 * encoder.
+	 *
+	 * The PLL allowed input frequency range is 12 MHz to 192 MHz.
+	 */
+
+	/* TODO resolv blocking subroutine */
+	hwclk = __clk_get_hw(lvds->pllref_clk);
+	if (!hwclk)
+		return;
+
+	pll_in_khz = clk_hw_get_rate(hwclk) / 1000;
+
+	if (lvds_is_dual_link(lvds->config.link_type))
+		multiplier = 2;
+	else
+		multiplier = 1;
+
+	lvds_pll_get_params(lvds, pll_in_khz,
+			    lvds->pixel_clock_rate * 7 / 1000 / multiplier,
+			    &bdiv, &mdiv, &ndiv);
+
+	/* MST_PLL_INPUT_DIV */
+	lvds_write(lvds, phy->base + phy->ofs.PxPLLCR2, ndiv << 16);
+	/* MST_PLL_BIT_DIV */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCR2, bdiv);
+	/* MST_PLL_SD_INT_RATIO */
+	lvds_write(lvds, phy->base + phy->ofs.PxPLLSDCR1, mdiv);
+	/* MST_PLL_TEST_DIV_SETTINGS */
+	lvds_write(lvds, phy->base + phy->ofs.PxPLLTESTCR, TEST_DIV << 16);
+
+	/*
+	 * PLL integer mode:
+	 *	- MST_PLL_TWG_STEP = MST_PLL_SD_INT_RATIO
+	 *	- EN_TWG = 0
+	 *	- EN_SD = 0
+	 *	- DOWN_SPREAD = 0
+	 *
+	 * PLL fractional mode:
+	 *	- EN_TWG = 0
+	 *	- EN_SD = 1
+	 *	- DOWN_SPREAD = 0
+	 */
+
+	/* For now, PLL just need to be in integer mode */
+	lvds_clear(lvds, phy->base + phy->ofs.PxPLLCR1, EN_TWG | EN_SD); /* Disable TWG and SD */
+
+	/* Power up bias and PLL dividers */
+	lvds_set(lvds, phy->base + phy->ofs.PxDCR, POWER_OK);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxCMCR1, CM_EN_DL);
+	lvds_set(lvds, phy->base + phy->ofs.PxCMCR2, CM_EN_DL4);
+
+	/* JF Duret */
+	lvds_set(lvds, phy->base + phy->ofs.PxPLLCPCR, 0x1);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxBCR3, VM_EN_DL);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxBCR1, EN_BIAS_DL);
+
+	lvds_set(lvds, phy->base + phy->ofs.PxCFGCR, EN_DIG_DL);
+}
+
+/* TODO enhance & make clearer logic */
+static int lvds_pixel_clk_enable(struct clk_hw *hw)
+{
+	/* PLL enable here */
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+	struct lvds_phy_info *phy;
+	int ret;
+
+	ret = clk_prepare_enable(lvds->pclk);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(lvds->pllref_clk);
+	if (ret)
+		goto err_pclk;
+
+	/*
+	 * In case we are operating in dual link, PHY Slv is set before PHY
+	 * Mst.
+	 */
+	if (lvds->phy_slave) {
+		phy = lvds->phy_slave;
+
+		lvds_set(lvds, phy->base + phy->ofs.PxGCR, PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+		lvds_pll_config(lvds, phy);
+
+		ret = lvds_pll_enable(lvds, phy);
+		if (ret) {
+			DRM_ERROR("Unable to enable PHY PLL Slv: %d\n", ret);
+			goto err_pllref;
+		}
+	}
+
+	if (lvds->phy_master) {
+		phy = lvds->phy_master;
+
+		/* Release LVDS PHY from reset mode */
+		lvds_set(lvds, phy->base + phy->ofs.PxGCR, PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+		lvds_pll_config(lvds, phy);
+
+		ret = lvds_pll_enable(lvds, phy);
+		if (ret) {
+			DRM_ERROR("Unable to enable PHY PLL Mst: %d\n", ret);
+			goto err_pllref;
+		}
+	}
+
+	return 0;
+
+err_pllref:
+	clk_disable_unprepare(lvds->pllref_clk);
+err_pclk:
+	clk_disable_unprepare(lvds->pclk);
+
+	return ret;
+}
+
+static void lvds_pixel_clk_disable(struct clk_hw *hw)
+{
+	/* PLL disable here */
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+
+	/* TODO Disable D-PHY clocks and digital */
+//	lvds_clear(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxGCR,
+//		   (PHY_GCR_DP_CLK_OUT | PHY_GCR_LS_CLK_OUT | PHY_GCR_BIT_CLK_OUT));
+
+	/* Assert LVDS PHY Master & Slave in reset mode */
+	if (lvds->phy_master)
+		lvds_clear(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxGCR,
+			   PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+
+	if (lvds->phy_slave)
+		lvds_clear(lvds, lvds->phy_slave->base + lvds->phy_slave->ofs.PxGCR,
+			   PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+
+	clk_disable_unprepare(lvds->pllref_clk);
+	clk_disable_unprepare(lvds->pclk);
+}
+
+static unsigned long lvds_pixel_clk_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+	unsigned int pll_in_khz, bdiv, mdiv, ndiv;
+	int multiplier;
+
+	pll_in_khz = (unsigned int)(parent_rate / 1000);
+
+	if (lvds_is_dual_link(lvds->config.link_type))
+		multiplier = 2;
+	else
+		multiplier = 1;
+
+	lvds_pll_get_params(lvds, pll_in_khz,
+			    lvds->pixel_clock_rate * 7 / 1000 / multiplier,
+			    &bdiv, &mdiv, &ndiv);
+
+	/* X7 because for each pixel in 1 lane there is 7 bits
+	 * We want pixclk, not bitclk
+	 */
+	lvds->pixel_clock_rate = (unsigned long)pll_get_clkout_khz(pll_in_khz, bdiv, mdiv, ndiv)
+					 * 1000 * multiplier / 7;
+
+	return (unsigned long)lvds->pixel_clock_rate;
+}
+
+static long lvds_pixel_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *parent_rate)
+{
+	struct stm_lvds *lvds = container_of(hw, struct stm_lvds, lvds_ck_px);
+	unsigned int pll_in_khz, bdiv, mdiv, ndiv;
+	const struct drm_display_mode *mode;
+	const struct drm_connector *connector;
+	int multiplier;
+
+	connector = &lvds->connector;
+	if (!connector)
+		return -EINVAL;
+
+	if (list_empty(&connector->modes)) {
+		dev_dbg(lvds->dev, "connector: empty modes list\n");
+		return -EINVAL;
+	}
+
+	mode = list_first_entry(&connector->modes,
+				struct drm_display_mode, head);
+
+	pll_in_khz = (unsigned int)(*parent_rate / 1000);
+
+	if (lvds_is_dual_link(lvds->config.link_type))
+		multiplier = 2;
+	else
+		multiplier = 1;
+
+	lvds_pll_get_params(lvds, pll_in_khz, mode->clock * 7 / multiplier, &bdiv, &mdiv, &ndiv);
+
+	/* X7 because for each pixel in 1 lane there is 7 bits
+	 * We want pixclk, not bitclk
+	 */
+	lvds->pixel_clock_rate = (unsigned long)pll_get_clkout_khz(pll_in_khz, bdiv, mdiv, ndiv)
+					 * 1000 * multiplier / 7;
+
+	return lvds->pixel_clock_rate;
+}
+
+static const struct clk_ops lvds_pixel_clk_ops = {
+	.enable = lvds_pixel_clk_enable,
+	.disable = lvds_pixel_clk_disable,
+	.recalc_rate = lvds_pixel_clk_recalc_rate,
+	.round_rate = lvds_pixel_clk_round_rate,
+};
+
+static const struct lvds_clk_data clk_data = {
+	.clk_name = "clk_pix_lvds",
+	.clk_ops = &lvds_pixel_clk_ops,
+	.clk_src = (const char * []) {"ck_ker_lvdsphy"},
+	.max_clk_src = 1,
+};
+
+static void lvds_pixel_clk_unregister(void *data)
+{
+	struct stm_lvds *lvds = data;
+
+	of_clk_del_provider(lvds->dev->of_node);
+	clk_hw_unregister(&lvds->lvds_ck_px);
+}
+
+static int lvds_pixel_clk_register(struct stm_lvds *lvds)
+{
+	struct device_node *node = lvds->dev->of_node;
+	struct clk_init_data init = {
+		.name = clk_data.clk_name,
+		.ops = clk_data.clk_ops,
+		.parent_names = clk_data.clk_src,
+		.num_parents = clk_data.max_clk_src,
+		.flags = CLK_IGNORE_UNUSED,
+	};
+	int ret;
+
+	lvds->lvds_ck_px.init = &init;
+
+	/* set the rate by default at 148500000 */
+	lvds->pixel_clock_rate = 148500000;
+
+	ret = clk_hw_register(lvds->dev, &lvds->lvds_ck_px);
+	if (ret)
+		return ret;
+
+	ret = of_clk_add_hw_provider(node, of_clk_hw_simple_get,
+				     &lvds->lvds_ck_px);
+	if (ret)
+		clk_hw_unregister(&lvds->lvds_ck_px);
+
+	return ret;
+}
+
+/* ------------------------------------------------------------------------- */
+static void lvds_config_data_mapping(struct stm_lvds *lvds)
+{
+	const struct drm_display_info *info;
+	u32 lvds_dmlcr[5], lvds_dmmcr[5]; /* 4 data lanes + 1 clk lane */
+	int i;
+
+	info = &(&lvds->connector)->display_info;
+	if (!info->num_bus_formats || !info->bus_formats) {
+		dev_warn(lvds->dev, "No LVDS bus format reported\n");
+		return;
+	}
+
+/*      Mode mirror : TODO
+ *      info->bus_flags & DRM_BUS_FLAG_DATA_LSB_TO_MSB
+ */
+
+	switch (info->bus_formats[0]) {
+	case MEDIA_BUS_FMT_RGB666_1X7X3_SPWG: /* VESA-RGB666 */
+		DRM_WARN("Pixel format with data mapping not yet compatible.\n");
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG: /* VESA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr[i] = ((lvds_bitmap_vesa_rgb888[i][0])
+					 + (lvds_bitmap_vesa_rgb888[i][1] << 5)
+					 + (lvds_bitmap_vesa_rgb888[i][2] << 10)
+					 + (lvds_bitmap_vesa_rgb888[i][3] << 15));
+			lvds_dmmcr[i] = ((lvds_bitmap_vesa_rgb888[i][4])
+					 + (lvds_bitmap_vesa_rgb888[i][5] << 5)
+					 + (lvds_bitmap_vesa_rgb888[i][6] << 10));
+		}
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA: /* JEIDA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr[i] = ((lvds_bitmap_jeida_rgb888[i][0])
+					+ (lvds_bitmap_jeida_rgb888[i][1] << 5)
+					+ (lvds_bitmap_jeida_rgb888[i][2] << 10)
+					+ (lvds_bitmap_jeida_rgb888[i][3] << 15));
+			lvds_dmmcr[i] = ((lvds_bitmap_jeida_rgb888[i][4])
+					+ (lvds_bitmap_jeida_rgb888[i][5] << 5)
+					+ (lvds_bitmap_jeida_rgb888[i][6] << 10));
+		}
+		break;
+	default:
+		dev_warn(lvds->dev, "Unsupported LVDS bus format 0x%04x\n",
+			 info->bus_formats[0]);
+	}
+
+	/* Write registers at the end of computations */
+	/* TODO use for loop */
+	lvds_write(lvds, LVDS_DMLCR0, lvds_dmlcr[0]);
+	lvds_write(lvds, LVDS_DMMCR0, lvds_dmmcr[0]);
+	lvds_write(lvds, LVDS_DMLCR1, lvds_dmlcr[1]);
+	lvds_write(lvds, LVDS_DMMCR1, lvds_dmmcr[1]);
+	lvds_write(lvds, LVDS_DMLCR2, lvds_dmlcr[2]);
+	lvds_write(lvds, LVDS_DMMCR2, lvds_dmmcr[2]);
+	lvds_write(lvds, LVDS_DMLCR3, lvds_dmlcr[3]);
+	lvds_write(lvds, LVDS_DMMCR3, lvds_dmmcr[3]);
+	lvds_write(lvds, LVDS_DMLCR4, lvds_dmlcr[4]);
+	lvds_write(lvds, LVDS_DMMCR4, lvds_dmmcr[4]);
+}
+
+static int lvds_config_mode(struct stm_lvds *lvds)
+{
+	const struct drm_display_mode *mode;
+	const struct drm_connector *connector;
+	u32 bus_flags, lvds_cr, lvds_cdl1cr, lvds_cdl2cr;
+
+	lvds_cr = 0;
+	lvds_cdl1cr = 0;
+	lvds_cdl2cr = 0;
+
+	connector = &lvds->connector;
+	if (!connector)
+		return -EINVAL;
+
+	if (list_empty(&connector->modes)) {
+		dev_dbg(lvds->dev, "connector: empty modes list\n");
+		return -EINVAL;
+	}
+
+	bus_flags = connector->display_info.bus_flags;
+	mode = list_first_entry(&connector->modes,
+				struct drm_display_mode, head);
+
+	lvds_clear(lvds, LVDS_CR, CR_LKMOD);
+	lvds_clear(lvds, LVDS_CDL1CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+	lvds_clear(lvds, LVDS_CDL2CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+
+	/* Set channel distribution */
+	/* TODO Hardcoded values for now */
+	if (lvds->phy_master)
+		lvds_cdl1cr = CDL1CR_DEFAULT;
+
+	if (lvds->phy_slave) {
+		lvds_cr |= CR_LKMOD;
+		lvds_cdl2cr = CDL2CR_DEFAULT;
+	}
+
+	/* Set signal polarity */
+	if (bus_flags & DRM_BUS_FLAG_DE_LOW)
+		lvds_cr |= CR_DEPOL;
+
+	if (mode->flags & DRM_MODE_FLAG_NHSYNC)
+		lvds_cr |= CR_HSPOL;
+
+	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
+		lvds_cr |= CR_VSPOL;
+
+	switch (lvds->config.link_type) {
+	case LVDS_DUAL_LINK_EVEN_ODD_PIXELS: /* LKPHA = 0 */
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	case LVDS_DUAL_LINK_ODD_EVEN_PIXELS: /* LKPHA = 1 */
+		lvds_cr |= CR_LKPHA;
+		break;
+	default:
+		dev_warn(lvds->dev, "No phase precised, setting default\n");
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	}
+
+	/* Write config to registers */
+	lvds_set(lvds, LVDS_CR, lvds_cr);
+	lvds_write(lvds, LVDS_CDL1CR, lvds_cdl1cr);
+	lvds_write(lvds, LVDS_CDL2CR, lvds_cdl2cr);
+
+	/* Set Data Mapping */
+	lvds_config_data_mapping(lvds);
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------------- */
+static int lvds_connector_get_modes(struct drm_connector *connector)
+{
+	struct stm_lvds *lvds = connector_to_stm_lvds(connector);
+	int ret;
+
+	ret = drm_panel_get_modes(lvds->panel, connector);
+
+	return ret;
+}
+
+static int lvds_connector_atomic_check(struct drm_connector *connector,
+				       struct drm_atomic_state *state)
+{
+	struct stm_lvds *lvds = connector_to_stm_lvds(connector);
+	const struct drm_display_mode *panel_mode;
+	struct drm_connector_state *conn_state;
+	struct drm_crtc_state *crtc_state;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (!conn_state->crtc)
+		return 0;
+
+	if (list_empty(&connector->modes)) {
+		dev_dbg(lvds->dev, "connector: empty modes list\n");
+		return -EINVAL;
+	}
+
+	panel_mode = list_first_entry(&connector->modes,
+				      struct drm_display_mode, head);
+
+	/* We're not allowed to modify the resolution. */
+	crtc_state = drm_atomic_get_crtc_state(state, conn_state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	if (crtc_state->mode.hdisplay != panel_mode->hdisplay ||
+	    crtc_state->mode.vdisplay != panel_mode->vdisplay)
+		return -EINVAL;
+
+	/* The flat panel mode is fixed, just copy it to the adjusted mode. */
+	drm_mode_copy(&crtc_state->adjusted_mode, panel_mode);
+
+	return 0;
+}
+
+static const struct drm_connector_helper_funcs lvds_conn_helper_funcs = {
+	.get_modes = lvds_connector_get_modes,
+	.atomic_check = lvds_connector_atomic_check,
+};
+
+static const struct drm_connector_funcs lvds_conn_funcs = {
+	.reset = drm_atomic_helper_connector_reset,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+/* ------------------------------------------------------------------------- */
+static int lvds_attach(struct drm_bridge *bridge,
+		       enum drm_bridge_attach_flags flags)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+	struct drm_connector *connector = &lvds->connector;
+	struct drm_encoder *encoder = bridge->encoder;
+	int ret = -ENODEV;
+
+	if (!bridge->encoder) {
+		DRM_ERROR("Parent encoder object not found\n");
+		return -ENODEV;
+	}
+
+	/* Set the encoder type as caller does not know it */
+	bridge->encoder->encoder_type = DRM_MODE_ENCODER_LVDS;
+
+	/* No cloning support */
+	bridge->encoder->possible_clones = 0;
+
+	/* If we have a next bridge just attach it. */
+	if (lvds->next_bridge)
+		return drm_bridge_attach(bridge->encoder, lvds->next_bridge,
+					 bridge, flags);
+
+	if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {
+		DRM_ERROR("Fix bridge driver to make connector optional!");
+		return -EINVAL;
+	}
+
+	/* Otherwise if we have a panel, create a connector. */
+	if (!lvds->panel)
+		return 0;
+
+	ret = drm_connector_init(bridge->dev, connector,
+				 &lvds_conn_funcs, DRM_MODE_CONNECTOR_LVDS);
+	if (ret < 0)
+		return ret;
+
+	drm_connector_helper_add(connector, &lvds_conn_helper_funcs);
+
+	ret = drm_connector_attach_encoder(connector, encoder);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void lvds_detach(struct drm_bridge *bridge)
+{}
+
+static void __lvds_atomic_enable(struct drm_bridge *bridge,
+				 struct drm_atomic_state *state,
+				 struct drm_crtc *crtc,
+				 struct drm_connector *connector)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+
+	lvds_config_mode(lvds);
+
+	/* Turn the output on. */
+	lvds_set(lvds, LVDS_CR, CR_LVDSEN);
+
+	if (lvds->panel) {
+		drm_panel_prepare(lvds->panel);
+		drm_panel_enable(lvds->panel);
+	}
+}
+
+static void lvds_atomic_enable(struct drm_bridge *bridge,
+			       struct drm_bridge_state *old_bridge_state)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+	struct drm_atomic_state *state = old_bridge_state->base.state;
+	struct drm_connector *connector;
+	struct drm_crtc *crtc;
+	int ret;
+
+	if (!pm_runtime_active(lvds->dev)) {
+		ret = pm_runtime_get_sync(lvds->dev);
+		if (ret < 0) {
+			DRM_ERROR("Failed to set mode, cannot get sync\n");
+			return;
+		}
+	}
+
+	connector = drm_atomic_get_new_connector_for_encoder(state,
+							     bridge->encoder);
+	crtc = drm_atomic_get_new_connector_state(state, connector)->crtc;
+
+	__lvds_atomic_enable(bridge, state, crtc, connector);
+}
+
+static void lvds_atomic_disable(struct drm_bridge *bridge,
+				struct drm_bridge_state *old_bridge_state)
+{
+	struct stm_lvds *lvds = bridge_to_stm_lvds(bridge);
+
+	if (lvds->panel) {
+		drm_panel_disable(lvds->panel);
+		drm_panel_unprepare(lvds->panel);
+	}
+
+	/* Check the LVDS handle allocation ? */
+
+	/* Disable LVDS module */
+	lvds_clear(lvds, LVDS_CR, CR_LVDSEN);
+
+	/* Shutdown the LVDS PLL */
+	/*
+	 * TODO: bug if PLL_EN cleared
+	 * Do NOT uncomment this line
+	 */
+	//lvds_clear(lvds, lvds->phy_master->base + lvds->phy_master->ofs.PxPLLCR1, PLL_EN);
+	pm_runtime_put(lvds->dev);
+}
+
+static const struct drm_bridge_funcs lvds_bridge_funcs = {
+	.attach = lvds_attach,
+	.detach = lvds_detach,
+	.atomic_enable = lvds_atomic_enable,
+	.atomic_disable = lvds_atomic_disable,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+/* ------------------------------------------------------------------------- */
+static int lvds_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *port1, *port2, *remote;
+	struct stm_lvds *lvds;
+	struct reset_control *rstc;
+	struct lvds_phy_info *phy;
+	unsigned int pll_in_khz, bdiv, mdiv, ndiv;
+	int multiplier, rate;
+	int ret, dual_link;
+
+	DRM_DEBUG_DRIVER("Probing LVDS driver...\n");
+
+	lvds = devm_kzalloc(dev, sizeof(*lvds), GFP_KERNEL);
+	if (!lvds)
+		return -ENOMEM;
+
+	lvds->dev = dev;
+
+	ret = drm_of_find_panel_or_bridge(lvds->dev->of_node, 1, 0,
+					  &lvds->panel, &lvds->next_bridge);
+	if (ret) {
+		dev_err_probe(dev, ret, "Panel not found\n");
+		return ret;
+	}
+
+	lvds->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(lvds->base)) {
+		ret = PTR_ERR(lvds->base);
+		DRM_ERROR("Unable to get regs %d\n", ret);
+		return ret;
+	}
+
+	lvds->vdd_supply = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(lvds->vdd_supply)) {
+		dev_err_probe(dev, ret, "Failed to request regulator\n");
+		return PTR_ERR(lvds->vdd_supply);
+	}
+
+	lvds->vdda18_supply = devm_regulator_get(dev, "vdda18");
+	if (IS_ERR(lvds->vdda18_supply)) {
+		dev_err_probe(dev, ret, "Failed to request regulator\n");
+		return  PTR_ERR(lvds->vdda18_supply);
+	}
+
+	/* To obtain a continuous display after the probe, reset shouldn't be done */
+	if (!device_property_read_bool(dev, "default-on")) {
+		rstc = devm_reset_control_get_exclusive(dev, NULL);
+
+		if (IS_ERR(rstc)) {
+			ret = PTR_ERR(rstc);
+			return ret;
+		}
+
+		reset_control_assert(rstc);
+		usleep_range(10, 20);
+		reset_control_deassert(rstc);
+	}
+
+	port1 = of_graph_get_port_by_id(dev->of_node, 1);
+	port2 = of_graph_get_port_by_id(dev->of_node, 2);
+	dual_link = drm_of_lvds_get_dual_link_pixel_order(port1, port2);
+
+	switch (dual_link) {
+	case DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS:
+		lvds->config.link_type = LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+		lvds->phy_master = &lvds_phy_16ff_master;
+		lvds->phy_slave = &lvds_phy_16ff_slave;
+		break;
+	case DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS:
+		lvds->config.link_type = LVDS_DUAL_LINK_EVEN_ODD_PIXELS;
+		lvds->phy_master = &lvds_phy_16ff_master;
+		lvds->phy_slave = &lvds_phy_16ff_slave;
+		break;
+	case -EINVAL:
+		/*
+		 * drm_of_lvds_get_dual_pixel_order returns 4 possible values.
+		 * In the case where the returned value is an error, it can be
+		 * either ENODEV or EINVAL. Seeing the structure of this
+		 * function, EINVAL means that either port1 or port2 is not
+		 * present in the device tree.
+		 * In that case, the lvds panel can be a single link panel, or
+		 * there is a semantical error in the device tree code.
+		 */
+		remote = of_get_next_available_child(port1, NULL);
+		if (remote) {
+			if (of_graph_get_remote_endpoint(remote)) {
+				lvds->config.link_type = LVDS_SINGLE_LINK_MASTER;
+				lvds->phy_master = &lvds_phy_16ff_master;
+				lvds->phy_slave = NULL;
+			} else {
+				ret = -EINVAL;
+			}
+
+			of_node_put(remote);
+		}
+
+		remote = of_get_next_available_child(port2, NULL);
+		if (remote) {
+			if (of_graph_get_remote_endpoint(remote)) {
+				lvds->config.link_type = LVDS_SINGLE_LINK_SLAVE;
+				lvds->phy_master = NULL;
+				lvds->phy_slave = &lvds_phy_16ff_slave;
+			} else {
+				ret = (ret == -EINVAL) ? -EINVAL : 0;
+			}
+
+			of_node_put(remote);
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	of_node_put(port1);
+	of_node_put(port2);
+
+	lvds->pclk = devm_clk_get(lvds->dev, "pclk");
+	if (IS_ERR(lvds->pclk)) {
+		ret = PTR_ERR(lvds->pclk);
+		DRM_ERROR("Unable to get peripheral clock: %d\n", ret);
+		return ret;
+	}
+
+	lvds->pllref_clk = devm_clk_get(lvds->dev, "ref");
+	if (IS_ERR(lvds->pllref_clk)) {
+		ret = PTR_ERR(lvds->pllref_clk);
+		DRM_ERROR("Unable to get reference clock: %d\n", ret);
+		return ret;
+	}
+
+	ret = lvds_pixel_clk_register(lvds);
+	if (ret) {
+		DRM_ERROR("Failed to register LVDS pixel clock: %d\n", ret);
+		return ret;
+	}
+
+	lvds->lvds_bridge.funcs = &lvds_bridge_funcs;
+	lvds->lvds_bridge.of_node = dev->of_node;
+
+	drm_bridge_add(&lvds->lvds_bridge);
+	platform_set_drvdata(pdev, lvds);
+
+	pm_runtime_enable(dev);
+
+	/*
+	 * To obtain a continuous display after the probe,
+	 *  the clocks must remain activated
+	 */
+	if (device_property_read_bool(dev, "default-on")) {
+		pm_runtime_get_sync(dev);
+
+		if (lvds->phy_master) {
+			if (lvds_is_dual_link(lvds->config.link_type))
+				multiplier = 2;
+			else
+				multiplier = 1;
+
+			phy = lvds->phy_master;
+			pll_in_khz = clk_get_rate(lvds->pllref_clk) / 1000;
+
+			ndiv = lvds_read(lvds, phy->base + phy->ofs.PxPLLCR2) >> 16;
+			bdiv = lvds_read(lvds, phy->base + phy->ofs.PxPLLCR2) & 0xFFFF;
+			mdiv = lvds_read(lvds, phy->base + phy->ofs.PxPLLSDCR1);
+
+			/* X7 because for each pixel in 1 lane there is 7 bits
+			 * We want pixclk, not bitclk
+			 */
+			rate = pll_get_clkout_khz(pll_in_khz, bdiv, mdiv, ndiv);
+			lvds->pixel_clock_rate = (unsigned long) rate  * 1000 * multiplier / 7;
+		}
+	}
+
+	return 0;
+}
+
+static int lvds_remove(struct platform_device *pdev)
+{
+	struct stm_lvds *lvds = platform_get_drvdata(pdev);
+
+	lvds_pixel_clk_unregister(lvds);
+	pm_runtime_disable(&pdev->dev);
+
+	/* Unregister LVDS bridge */
+	drm_bridge_remove(&lvds->lvds_bridge);
+
+	return 0;
+}
+
+static int __maybe_unused lvds_runtime_suspend(struct device *dev)
+{
+	struct stm_lvds *lvds = dev_get_drvdata(dev);
+
+	DRM_DEBUG_DRIVER("\n");
+
+	clk_disable_unprepare(lvds->pllref_clk);
+	clk_disable_unprepare(lvds->pclk);
+	regulator_disable(lvds->vdd_supply);
+	regulator_disable(lvds->vdda18_supply);
+
+	return 0;
+}
+
+static int __maybe_unused lvds_runtime_resume(struct device *dev)
+{
+	struct stm_lvds *lvds = dev_get_drvdata(dev);
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = regulator_enable(lvds->vdda18_supply);
+	if (ret) {
+		DRM_ERROR("Failed to enable regulator vdda18: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_enable(lvds->vdd_supply);
+	if (ret) {
+		regulator_disable(lvds->vdda18_supply);
+		DRM_ERROR("Failed to enable regulator vdd: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(lvds->pclk);
+	if (ret) {
+		regulator_disable(lvds->vdd_supply);
+		regulator_disable(lvds->vdda18_supply);
+		DRM_ERROR("Failed to enable pclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(lvds->pllref_clk);
+	if (ret) {
+		clk_disable_unprepare(lvds->pclk);
+		regulator_disable(lvds->vdd_supply);
+		regulator_disable(lvds->vdda18_supply);
+		DRM_ERROR("Failed to enable pllref_clk: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static const struct of_device_id lvds_dt_ids[] = {
+	{
+		.compatible = "st,stm32mp25-lvds",
+		.data = NULL
+	},
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, lvds_dt_ids);
+
+static const struct dev_pm_ops lvds_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(lvds_runtime_suspend, lvds_runtime_resume, NULL)
+};
+
+static struct platform_driver lvds_platform_driver = {
+	.probe	  = lvds_probe,
+	.remove	 = lvds_remove,
+	.driver	 = {
+		.name   = "stm32-display-lvds",
+		.owner  = THIS_MODULE,
+		.of_match_table = lvds_dt_ids,
+		.pm = &lvds_pm_ops,
+	},
+};
+
+module_platform_driver(lvds_platform_driver);
+
+MODULE_AUTHOR("Raphal Gallais-Pou <raphael.gallais-pou@foss.st.com>");
+MODULE_AUTHOR("Philippe Cornu <philippe.cornu@foss.st.com>");
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics LVDS Display Interface Transmitter DRM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/hwmon/mr75203.c b/drivers/hwmon/mr75203.c
index 394a4c7e4..7d079b546 100644
--- a/drivers/hwmon/mr75203.c
+++ b/drivers/hwmon/mr75203.c
@@ -763,6 +763,41 @@ static int pvt_set_temp_coeff(struct device *dev, struct pvt_device *pvt)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int mr75203_suspend(struct device *dev)
+{
+	struct pvt_device *pvt = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(pvt->clk);
+
+	return 0;
+}
+
+static int mr75203_resume(struct device *dev)
+{
+	struct pvt_device *pvt = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pvt->clk);
+	if (ret) {
+		dev_err(dev, "failed to enable clock: %d\n", ret);
+		return ret;
+	}
+
+	ret = pvt_init(pvt);
+	if (ret) {
+		dev_err(dev, "failed to init pvt: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops mr75203_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mr75203_suspend, mr75203_resume)
+};
+
 static int mr75203_probe(struct platform_device *pdev)
 {
 	u32 ts_num, vm_num, pd_num, ch_num, val, index, i;
@@ -906,6 +941,8 @@ static int mr75203_probe(struct platform_device *pdev)
 							 &pvt_chip_info,
 							 NULL);
 
+	platform_set_drvdata(pdev, pvt);
+
 	return PTR_ERR_OR_ZERO(hwmon_dev);
 }
 
@@ -919,6 +956,7 @@ static struct platform_driver moortec_pvt_driver = {
 	.driver = {
 		.name = "moortec-pvt",
 		.of_match_table = moortec_pvt_of_match,
+		.pm = &mr75203_pm_ops,
 	},
 	.probe = mr75203_probe,
 };
diff --git a/drivers/hwspinlock/Kconfig b/drivers/hwspinlock/Kconfig
index 3874d15b0..c77b5a01e 100644
--- a/drivers/hwspinlock/Kconfig
+++ b/drivers/hwspinlock/Kconfig
@@ -38,7 +38,7 @@ config HWSPINLOCK_SPRD
 
 config HWSPINLOCK_STM32
 	tristate "STM32 Hardware Spinlock device"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	  Say y here to support the STM32 Hardware Spinlock device.
 
diff --git a/drivers/hwspinlock/hwspinlock_core.c b/drivers/hwspinlock/hwspinlock_core.c
index fd5f5c5a5..a2197af89 100644
--- a/drivers/hwspinlock/hwspinlock_core.c
+++ b/drivers/hwspinlock/hwspinlock_core.c
@@ -29,6 +29,8 @@
 
 /* radix tree tags */
 #define HWSPINLOCK_UNUSED	(0) /* tags an hwspinlock as unused */
+#define HWSPINLOCK_EXCLUSIVE	(1) /* tags an hwspinlock as exclusive */
+#define HWSPINLOCK_SHARED	(2) /* tags an hwspinlock as shared */
 
 /*
  * A radix tree is used to maintain the available hwspinlock instances.
@@ -308,7 +310,7 @@ EXPORT_SYMBOL_GPL(__hwspin_unlock);
  * @hwlock_spec: hwlock specifier as found in the device tree
  *
  * This is a simple translation function, suitable for hwspinlock platform
- * drivers that only has a lock specifier length of 1.
+ * drivers that only has a lock specifier length of 1 or 2.
  *
  * Returns a relative index of the lock within a specified bank on success,
  * or -EINVAL on invalid specifier cell count.
@@ -316,7 +318,8 @@ EXPORT_SYMBOL_GPL(__hwspin_unlock);
 static inline int
 of_hwspin_lock_simple_xlate(const struct of_phandle_args *hwlock_spec)
 {
-	if (WARN_ON(hwlock_spec->args_count != 1))
+	if (WARN_ON(hwlock_spec->args_count != 1 &&
+		    hwlock_spec->args_count != 2))
 		return -EINVAL;
 
 	return hwlock_spec->args[0];
@@ -339,11 +342,12 @@ of_hwspin_lock_simple_xlate(const struct of_phandle_args *hwlock_spec)
 int of_hwspin_lock_get_id(struct device_node *np, int index)
 {
 	struct of_phandle_args args;
-	struct hwspinlock *hwlock;
+	struct hwspinlock *hwlock, *tmp;
 	struct radix_tree_iter iter;
 	void **slot;
 	int id;
 	int ret;
+	unsigned int tag;
 
 	ret = of_parse_phandle_with_args(np, "hwlocks", "#hwlock-cells", index,
 					 &args);
@@ -383,6 +387,37 @@ int of_hwspin_lock_get_id(struct device_node *np, int index)
 	}
 	id += hwlock->bank->base_id;
 
+	/* Set the EXCLUSIVE / SHARED tag */
+	if (args.args_count == 2 && args.args[1]) {
+		/* Tag SHARED unless already tagged EXCLUSIVE */
+		if (radix_tree_tag_get(&hwspinlock_tree, id,
+				       HWSPINLOCK_EXCLUSIVE)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		tag = HWSPINLOCK_SHARED;
+	} else {
+		/* Tag EXCLUSIVE unless already tagged SHARED */
+		if (radix_tree_tag_get(&hwspinlock_tree, id,
+				       HWSPINLOCK_SHARED)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		tag = HWSPINLOCK_EXCLUSIVE;
+	}
+
+	/* mark this hwspinlock */
+	hwlock = radix_tree_lookup(&hwspinlock_tree, id);
+	if (!hwlock) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	tmp = radix_tree_tag_set(&hwspinlock_tree, id, tag);
+
+	/* self-sanity check which should never fail */
+	WARN_ON(tmp != hwlock);
+
 out:
 	of_node_put(args.np);
 	return ret ? ret : id;
@@ -505,6 +540,7 @@ int hwspin_lock_register(struct hwspinlock_device *bank, struct device *dev,
 
 		spin_lock_init(&hwlock->lock);
 		hwlock->bank = bank;
+		hwlock->refcount = 0;
 
 		ret = hwspin_lock_register_single(hwlock, base_id + i);
 		if (ret)
@@ -647,7 +683,7 @@ static int __hwspin_lock_request(struct hwspinlock *hwlock)
 {
 	struct device *dev = hwlock->bank->dev;
 	struct hwspinlock *tmp;
-	int ret;
+	int ret, id;
 
 	/* prevent underlying implementation from being removed */
 	if (!try_module_get(dev->driver->owner)) {
@@ -666,13 +702,18 @@ static int __hwspin_lock_request(struct hwspinlock *hwlock)
 
 	ret = 0;
 
+	/* update shareable refcount */
+	id = hwlock_to_id(hwlock);
+	if (radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_SHARED) &&
+	    hwlock->refcount++)
+		goto out;
+
 	/* mark hwspinlock as used, should not fail */
-	tmp = radix_tree_tag_clear(&hwspinlock_tree, hwlock_to_id(hwlock),
-							HWSPINLOCK_UNUSED);
+	tmp = radix_tree_tag_clear(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
 
 	/* self-sanity check that should never fail */
 	WARN_ON(tmp != hwlock);
-
+out:
 	return ret;
 }
 
@@ -766,9 +807,9 @@ struct hwspinlock *hwspin_lock_request_specific(unsigned int id)
 	/* sanity check (this shouldn't happen) */
 	WARN_ON(hwlock_to_id(hwlock) != id);
 
-	/* make sure this hwspinlock is unused */
-	ret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
-	if (ret == 0) {
+	/* make sure this hwspinlock is unused or shareable */
+	if (!radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_SHARED) &&
+	    !radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED)) {
 		pr_warn("hwspinlock %u is already in use\n", id);
 		hwlock = NULL;
 		goto out;
@@ -801,7 +842,7 @@ int hwspin_lock_free(struct hwspinlock *hwlock)
 {
 	struct device *dev;
 	struct hwspinlock *tmp;
-	int ret;
+	int ret, id;
 
 	if (!hwlock) {
 		pr_err("invalid hwlock\n");
@@ -812,28 +853,33 @@ int hwspin_lock_free(struct hwspinlock *hwlock)
 	mutex_lock(&hwspinlock_tree_lock);
 
 	/* make sure the hwspinlock is used */
-	ret = radix_tree_tag_get(&hwspinlock_tree, hwlock_to_id(hwlock),
-							HWSPINLOCK_UNUSED);
+	id = hwlock_to_id(hwlock);
+	ret = radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
 	if (ret == 1) {
 		dev_err(dev, "%s: hwlock is already free\n", __func__);
 		dump_stack();
 		ret = -EINVAL;
-		goto out;
+		goto unlock;
 	}
 
 	/* notify the underlying device that power is not needed */
 	pm_runtime_put(dev);
 
+	/* update shareable refcount */
+	if (radix_tree_tag_get(&hwspinlock_tree, id, HWSPINLOCK_SHARED) &&
+	    --hwlock->refcount)
+		goto put;
+
 	/* mark this hwspinlock as available */
-	tmp = radix_tree_tag_set(&hwspinlock_tree, hwlock_to_id(hwlock),
-							HWSPINLOCK_UNUSED);
+	tmp = radix_tree_tag_set(&hwspinlock_tree, id, HWSPINLOCK_UNUSED);
 
 	/* sanity check (this shouldn't happen) */
 	WARN_ON(tmp != hwlock);
 
+put:
 	module_put(dev->driver->owner);
 
-out:
+unlock:
 	mutex_unlock(&hwspinlock_tree_lock);
 	return ret;
 }
diff --git a/drivers/hwspinlock/hwspinlock_internal.h b/drivers/hwspinlock/hwspinlock_internal.h
index 29892767b..e1f9c9600 100644
--- a/drivers/hwspinlock/hwspinlock_internal.h
+++ b/drivers/hwspinlock/hwspinlock_internal.h
@@ -35,11 +35,13 @@ struct hwspinlock_ops {
  * struct hwspinlock - this struct represents a single hwspinlock instance
  * @bank: the hwspinlock_device structure which owns this lock
  * @lock: initialized and used by hwspinlock core
+ * @refcount: number of users (when shared)
  * @priv: private data, owned by the underlying platform-specific hwspinlock drv
  */
 struct hwspinlock {
 	struct hwspinlock_device *bank;
 	spinlock_t lock;
+	unsigned int refcount;
 	void *priv;
 };
 
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index e50f9603d..5573eca52 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -1457,4 +1457,13 @@ config I2C_VIRTIO
           This driver can also be built as a module. If so, the module
           will be called i2c-virtio.
 
+config I2C_RPMSG
+	tristate "RPMSG I2C driver"
+	depends on RPMSG
+	help
+	  Say y here to export RPMsg endpoints as I2C Bus.
+
+	  This makes it possible for I2C clients to send and receive
+	  RPMsg as a standard I2C protocol.
+
 endmenu
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 784a80327..c3d1eb8d1 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -153,5 +153,6 @@ obj-$(CONFIG_I2C_XGENE_SLIMPRO) += i2c-xgene-slimpro.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_I2C_FSI)		+= i2c-fsi.o
 obj-$(CONFIG_I2C_VIRTIO)	+= i2c-virtio.o
+obj-$(CONFIG_I2C_RPMSG)		+= i2c-rpmsg.o
 
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff --git a/drivers/i2c/busses/i2c-rpmsg.c b/drivers/i2c/busses/i2c-rpmsg.c
new file mode 100644
index 000000000..33f59975c
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rpmsg.c
@@ -0,0 +1,422 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Virtual Driver for RPMSG based I2C bus controller
+ *
+ * Copyright (c) 2023 STMicroelectronics.
+ *
+ */
+
+#include <linux/completion.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/rpmsg.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+/* rpmsg_i2c_msg result flag */
+#define RPMSG_I2C_ACK	0x01
+#define RPMSG_I2C_NACK	0x02
+
+static LIST_HEAD(rpmsg_i2c_list);   /* i2c adapter instances list */
+static DEFINE_MUTEX(rpmsg_i2c_lock);  /* protect adapter list */
+
+/**
+ * struct rpmsg_i2c_msg - client specific data
+ * @count: number of bytes to be transferred
+ * @addr: 8-bit slave addr, including r/w bit
+ * @result: used by the slave as an acknowledge
+ * @reserved: header padding for 32-bit alignment
+ * @buf: data buffer
+ */
+struct rpmsg_i2c_msg {
+	u32 count;
+	u8 addr;
+	u8 result;
+	u8 reserved[2];
+	u8 buf[0];
+} __packed;
+
+/**
+ * struct rpmsg_i2c_dev - device private data
+ * @is_read: indicate that driver waiting a rd callback
+ * @is_write: indicate that driver waiting a wr callback
+ * @complete: completion for waiting data
+ * @adap: i2c adapter handler
+ * @list: rpmsg_i2c adapter list
+ * @rpdrv: rpmsg driver handler
+ * @dev_id: rpmsg driver device id
+ * @dev: rpmsg i2c device declared in the device tree
+ * @rpdev: rpmsg device handler
+ * @msg:  i2c client specific data
+ * @i2cscan_work: to fix context issue of rpmsg_register_device
+ * call on context of nameservicing notification.
+ */
+struct rpmsg_i2c_dev {
+	bool is_read;
+	bool is_write;
+	struct completion complete;
+	struct i2c_adapter *adap;
+
+	struct list_head list; /* adapter device list */
+	struct rpmsg_driver rpdrv;
+	struct rpmsg_device_id dev_id[2];
+	struct device *dev;
+
+	struct rpmsg_device *rpdev;
+	struct rpmsg_i2c_msg *msg;
+
+	struct work_struct i2cscan_work;
+};
+
+static int rpmsg_i2c_cb(struct rpmsg_device *rpdev, void *data, int len, void *priv, u32 src)
+{
+	struct rpmsg_i2c_dev *ri2c_dev = dev_get_drvdata(&rpdev->dev);
+	struct rpmsg_i2c_msg *msg = ri2c_dev->msg;
+
+	msg->result = 0;
+
+	dev_dbg(&rpdev->dev, "incoming msg (src: 0x%x), R:%d W:%d R:0x%x (len=%d)\n", src,
+		ri2c_dev->is_read, ri2c_dev->is_write, msg->result, len);
+
+	if (ri2c_dev->is_read || ri2c_dev->is_write) {
+		memcpy(msg, data, len);
+
+		if (ri2c_dev->is_read || msg->result)
+			complete(&ri2c_dev->complete);
+		else
+			dev_err(&rpdev->dev, "Expecting ack or nack\n");
+	} else {
+		/*
+		 * Invalid message. As it not straightforward to determine the reason, or
+		 * to propagate the error, just discard the message and display an error
+		 * message.
+		 */
+		dev_err(&rpdev->dev, "unexpected message\n");
+	}
+
+	return 0;
+}
+
+static int rpmsg_i2c_write(struct rpmsg_i2c_dev *ri2c_dev, struct i2c_msg *msg)
+{
+	struct rpmsg_device *rpdev = ri2c_dev->rpdev;
+	struct rpmsg_i2c_msg *r_msg = ri2c_dev->msg;
+	unsigned long time_left;
+	int msg_size = sizeof(struct rpmsg_i2c_msg) + msg->len;
+	int ret;
+
+	if (!rpdev)
+		return -EIO;
+
+	if (msg_size > rpmsg_get_mtu(rpdev->ept))
+		return -EINVAL;
+
+	r_msg->addr = i2c_8bit_addr_from_msg(msg);
+	r_msg->count = msg->len;
+	r_msg->result = 0;
+	memcpy(r_msg->buf, msg->buf, msg->len);
+
+	dev_dbg(&rpdev->dev, "%s: %x (len=%d)", __func__, r_msg->addr, r_msg->count);
+	ri2c_dev->is_write = true;
+	reinit_completion(&ri2c_dev->complete);
+
+	ret = rpmsg_send(rpdev->ept, r_msg, msg_size);
+	if (ret) {
+		dev_err(&rpdev->dev, "write: rpmsg_send failed: %d\n", ret);
+		goto err_wr;
+	}
+
+	time_left = wait_for_completion_timeout(&ri2c_dev->complete, ri2c_dev->adap->timeout);
+	if (!time_left)
+		ret = -ETIMEDOUT;
+
+	if (r_msg->result & RPMSG_I2C_NACK)
+		ret = -ENXIO;
+
+err_wr:
+	ri2c_dev->is_write = false;
+
+	return ret;
+}
+
+static int rpmsg_i2c_read(struct rpmsg_i2c_dev *ri2c_dev, struct i2c_msg *msg)
+{
+	struct rpmsg_device *rpdev = ri2c_dev->rpdev;
+	struct rpmsg_i2c_msg *r_msg = ri2c_dev->msg;
+	unsigned long time_left;
+	int msg_size = sizeof(struct rpmsg_i2c_msg);
+	int ret;
+
+	if (!rpdev)
+		return -EIO;
+
+	r_msg->addr = i2c_8bit_addr_from_msg(msg);
+	r_msg->count = msg->len;
+	r_msg->result = 0;
+
+	ri2c_dev->is_read = true;
+	reinit_completion(&ri2c_dev->complete);
+
+	dev_dbg(&rpdev->dev, "%s: %x (len=%d)", __func__, r_msg->addr, r_msg->count);
+
+	ret = rpmsg_send(rpdev->ept, r_msg, msg_size);
+	if (ret) {
+		dev_err(&rpdev->dev, "read: rpmsg_send failed: %d\n", ret);
+		goto err_rd;
+	}
+
+	time_left = wait_for_completion_timeout(&ri2c_dev->complete, ri2c_dev->adap->timeout);
+	ri2c_dev->is_read = false;
+	if (time_left) {
+		if (r_msg->result & RPMSG_I2C_NACK)
+			ret = -ENXIO;
+
+		if (msg->len != r_msg->count)
+			dev_warn(&rpdev->dev, "Unexpected read size (%u), expected (%u)\n",
+				 r_msg->count, msg->len);
+
+		memcpy(msg->buf, r_msg->buf, msg->len);
+	} else {
+		ret = -ETIMEDOUT;
+		goto err_rd;
+	}
+
+	return ret;
+
+err_rd:
+	ri2c_dev->is_read = false;
+	return ret;
+}
+
+static int rpmsg_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct rpmsg_i2c_dev *ri2c_dev = i2c_get_adapdata(i2c_adap);
+	struct i2c_msg *pmsg;
+	int err = 0, count = 0, i;
+	u32 status;
+
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		status = pmsg->flags;
+
+		if ((status & I2C_M_RD) != false)
+			err = rpmsg_i2c_read(ri2c_dev, pmsg);
+		else
+			err = rpmsg_i2c_write(ri2c_dev, pmsg);
+
+		if (err < 0)
+			break;
+		count++;
+	}
+	return (err < 0) ? err : count;
+}
+
+static u32 rpmsg_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm rpmsg_i2c_algo = {
+	.master_xfer = rpmsg_i2c_xfer,
+	.functionality = rpmsg_i2c_func,
+};
+
+static void rpmsg_i2c_scan_work(struct work_struct *ws)
+{
+	struct rpmsg_i2c_dev *ri2c_dev = container_of(ws, struct rpmsg_i2c_dev, i2cscan_work);
+	struct rpmsg_device *rpdev = ri2c_dev->rpdev;
+	int ret;
+
+	mutex_lock(&rpmsg_i2c_lock);
+
+	if (!ri2c_dev->adap)
+		goto out;
+
+	ret = i2c_add_adapter(ri2c_dev->adap);
+	if (ret) {
+		dev_err(&rpdev->dev, "failed to add I2C adapter: %d\n", ret);
+		goto out;
+	}
+
+out:
+	mutex_unlock(&rpmsg_i2c_lock);
+}
+
+static int rpmsg_i2c_probe(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_i2c_dev *ri2c_dev;
+	struct i2c_adapter *adap;
+	bool adap_found = false;
+	int ret;
+
+	mutex_lock(&rpmsg_i2c_lock);
+
+	list_for_each_entry(ri2c_dev, &rpmsg_i2c_list, list) {
+		if (!strcmp(ri2c_dev->dev_id[0].name, rpdev->id.name)) {
+			if (ri2c_dev->rpdev) {
+				ret = -EBUSY;
+				goto out;
+			}
+			adap_found = true;
+			break;
+		}
+	}
+
+	if (!adap_found) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	adap = devm_kzalloc(&rpdev->dev, sizeof(*adap), GFP_KERNEL);
+	ri2c_dev->msg = devm_kzalloc(&rpdev->dev, rpmsg_get_mtu(rpdev->ept), GFP_KERNEL);
+	if (!adap || !ri2c_dev->msg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	i2c_set_adapdata(adap, ri2c_dev);
+	ri2c_dev->adap = adap;
+
+	snprintf(adap->name, sizeof(adap->name), "%s-%#x adapter ",
+		 rpdev->id.name, rpdev->src);
+	adap->owner = THIS_MODULE;
+	adap->timeout = msecs_to_jiffies(100); /* 100 ms timeout */
+	adap->retries = 0;
+	adap->algo = &rpmsg_i2c_algo;
+	adap->dev.parent = ri2c_dev->dev;
+	adap->dev.of_node = ri2c_dev->dev->of_node;
+	init_completion(&ri2c_dev->complete);
+
+	/* match between proc id and service name */
+	dev_info(&rpdev->dev, "new channel: 0x%x -> 0x%x!\n",
+		 rpdev->src, rpdev->dst);
+
+	ri2c_dev->rpdev = rpdev;
+	dev_set_drvdata(&rpdev->dev, ri2c_dev);
+
+	mutex_unlock(&rpmsg_i2c_lock);
+
+	/*
+	 * The RPMsg driver can be called under interrupt context to ensure that the
+	 * I2C protocol (Ack/Nack) is running in interrupt context.
+	 * To be sure to call i2c_add_adapter in normal context, schedule a work.
+	 */
+	schedule_work(&ri2c_dev->i2cscan_work);
+
+	return 0;
+
+out:
+	mutex_unlock(&rpmsg_i2c_lock);
+
+	return ret;
+}
+
+static void rpmsg_i2c_remove(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_i2c_dev *ri2c_dev = dev_get_drvdata(&rpdev->dev);
+
+	cancel_work_sync(&ri2c_dev->i2cscan_work);
+	if (ri2c_dev->adap)
+		i2c_del_adapter(ri2c_dev->adap);
+
+	ri2c_dev->adap = NULL;
+	ri2c_dev->rpdev = NULL;
+}
+
+static int rpmsg_i2c_platform_probe(struct platform_device *pdev)
+{
+	struct rpmsg_i2c_dev *ri2c_dev;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	const char *dev_id_name;
+	int ret;
+
+	ri2c_dev = devm_kzalloc(&pdev->dev, sizeof(*ri2c_dev), GFP_KERNEL);
+	if (!ri2c_dev)
+		return -ENOMEM;
+
+	ri2c_dev->dev = dev;
+	ri2c_dev->rpdev = NULL;
+	ri2c_dev->is_read = false;
+	ri2c_dev->is_write = false;
+
+	platform_set_drvdata(pdev, ri2c_dev);
+
+	INIT_WORK(&ri2c_dev->i2cscan_work, rpmsg_i2c_scan_work);
+
+	/* Generation of a specific rpmsg driver for this particular instance */
+	ret = of_property_read_string(np, "rpmsg,dev-id", &dev_id_name);
+	if (ret) {
+		dev_err(dev, "Error, proc-id property is missing: %d\n", ret);
+		return ret;
+	}
+	strncpy(ri2c_dev->dev_id[0].name, dev_id_name, RPMSG_NAME_SIZE - 1);
+
+	ri2c_dev->rpdrv.drv.name = "rpmsg_i2c";
+	ri2c_dev->rpdrv.id_table = ri2c_dev->dev_id;
+	ri2c_dev->rpdrv.probe = rpmsg_i2c_probe;
+	ri2c_dev->rpdrv.callback = rpmsg_i2c_cb;
+	ri2c_dev->rpdrv.remove = rpmsg_i2c_remove;
+
+	ret = register_rpmsg_driver(&ri2c_dev->rpdrv);
+	if (ret)
+		return ret;
+
+	/*
+	 * Adding the adapter inside a list head to match it later with the
+	 * corresponding rpmsg device
+	 */
+	mutex_lock(&rpmsg_i2c_lock);
+	list_add_tail(&ri2c_dev->list, &rpmsg_i2c_list);
+	mutex_unlock(&rpmsg_i2c_lock);
+
+	return 0;
+}
+
+static int rpmsg_i2c_platform_remove(struct platform_device *pdev)
+{
+	struct rpmsg_i2c_dev *ri2c_dev = platform_get_drvdata(pdev);
+
+	unregister_rpmsg_driver(&ri2c_dev->rpdrv);
+	list_del(&ri2c_dev->list);
+
+	return 0;
+}
+
+static const struct of_device_id rpmsg_i2c_dt_ids[] = {
+	{ .compatible = "rpmsg,i2c-controller" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rpmsg_i2c_dt_ids);
+
+static struct platform_driver rpmsg_i2c_platform_driver = {
+	.driver = {
+		.name	= "rpmsg_i2c",
+		.of_match_table = rpmsg_i2c_dt_ids,
+	},
+	.probe		= rpmsg_i2c_platform_probe,
+	.remove		= rpmsg_i2c_platform_remove
+};
+
+static int __init rpmsg_i2c_init(void)
+{
+	return platform_driver_register(&rpmsg_i2c_platform_driver);
+}
+
+static void __exit rpmsg_i2c_exit(void)
+{
+	platform_driver_unregister(&rpmsg_i2c_platform_driver);
+}
+
+module_init(rpmsg_i2c_init);
+module_exit(rpmsg_i2c_exit);
+
+MODULE_AUTHOR("Maxime Mere <maxime.mere@st.com>");
+MODULE_DESCRIPTION("Remote processor messaging I2C driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i2c/busses/i2c-stm32f7.c b/drivers/i2c/busses/i2c-stm32f7.c
index cb995449e..c9109cb82 100644
--- a/drivers/i2c/busses/i2c-stm32f7.c
+++ b/drivers/i2c/busses/i2c-stm32f7.c
@@ -50,6 +50,7 @@
 #define STM32F7_I2C_TXDR			0x28
 
 /* STM32F7 I2C control 1 */
+#define STM32_I2C_CR1_FMP			BIT(24)
 #define STM32F7_I2C_CR1_PECEN			BIT(23)
 #define STM32F7_I2C_CR1_ALERTEN			BIT(22)
 #define STM32F7_I2C_CR1_SMBHEN			BIT(20)
@@ -179,7 +180,12 @@ enum {
 #define STM32F7_SCLH_MAX			BIT(8)
 #define STM32F7_SCLL_MAX			BIT(8)
 
-#define STM32F7_AUTOSUSPEND_DELAY		(HZ / 100)
+/*
+ * This autosuspend delay should be long enough so that a clk client device performing i2c
+ * transfer within its prepare_lock protected handler should be able to perform the whole
+ * handling without having the autosuspend to try to suspend the i2c adapter
+ */
+#define STM32F7_AUTOSUSPEND_DELAY		HZ
 
 /**
  * struct stm32f7_i2c_regs - i2c f7 registers backup
@@ -226,6 +232,8 @@ struct stm32f7_i2c_spec {
  * @rise_time: Rise time (ns)
  * @fall_time: Fall time (ns)
  * @fmp_clr_offset: Fast Mode Plus clear register offset from set register
+ * @single_it_line: Only a single IT line is used for both events/errors
+ * @fmp_cr1_bit: Fast Mode Plus control is done via a bit in CR1
  */
 struct stm32f7_i2c_setup {
 	u32 speed_freq;
@@ -233,6 +241,8 @@ struct stm32f7_i2c_setup {
 	u32 rise_time;
 	u32 fall_time;
 	u32 fmp_clr_offset;
+	bool single_it_line;
+	bool fmp_cr1_bit;
 };
 
 /**
@@ -416,6 +426,13 @@ static const struct stm32f7_i2c_setup stm32mp13_setup = {
 	.fmp_clr_offset = 0x4,
 };
 
+static const struct stm32f7_i2c_setup stm32mp25_setup = {
+	.rise_time = STM32F7_I2C_RISE_TIME_DEFAULT,
+	.fall_time = STM32F7_I2C_FALL_TIME_DEFAULT,
+	.single_it_line = true,
+	.fmp_cr1_bit = true,
+};
+
 static inline void stm32f7_i2c_set_bits(void __iomem *reg, u32 mask)
 {
 	writel_relaxed(readl_relaxed(reg) | mask, reg);
@@ -1413,17 +1430,15 @@ static bool stm32f7_i2c_is_slave_busy(struct stm32f7_i2c_dev *i2c_dev)
 	return i == busy;
 }
 
-static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
+static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev, u32 status)
 {
 	void __iomem *base = i2c_dev->base;
-	u32 cr2, status, mask;
+	u32 cr2, mask;
 	u8 val;
 	int ret;
 
-	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
-
 	/* Slave transmitter mode */
-	if (status & STM32F7_I2C_ISR_TXIS) {
+	if (i2c_dev->slave_running && (status & STM32F7_I2C_ISR_TXIS)) {
 		i2c_slave_event(i2c_dev->slave_running,
 				I2C_SLAVE_READ_PROCESSED,
 				&val);
@@ -1433,7 +1448,8 @@ static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
 	}
 
 	/* Transfer Complete Reload for Slave receiver mode */
-	if (status & STM32F7_I2C_ISR_TCR || status & STM32F7_I2C_ISR_RXNE) {
+	if (i2c_dev->slave_running &&
+	    (status & STM32F7_I2C_ISR_TCR || status & STM32F7_I2C_ISR_RXNE)) {
 		/*
 		 * Read data byte then set NBYTES to receive next byte or NACK
 		 * the current received byte
@@ -1459,7 +1475,7 @@ static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
 	}
 
 	/* STOP received */
-	if (status & STM32F7_I2C_ISR_STOPF) {
+	if (i2c_dev->slave_running && (status & STM32F7_I2C_ISR_STOPF)) {
 		/* Disable interrupts */
 		stm32f7_i2c_disable_irq(i2c_dev, STM32F7_I2C_XFER_IRQ_MASK);
 
@@ -1488,23 +1504,81 @@ static irqreturn_t stm32f7_i2c_slave_isr_event(struct stm32f7_i2c_dev *i2c_dev)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
+static irqreturn_t stm32f7_i2c_handle_isr_errs(struct stm32f7_i2c_dev *i2c_dev, u32 status)
 {
-	struct stm32f7_i2c_dev *i2c_dev = data;
 	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
-	struct stm32_i2c_dma *dma = i2c_dev->dma;
+	u16 addr = f7_msg->addr;
 	void __iomem *base = i2c_dev->base;
-	u32 status, mask;
-	int ret = IRQ_HANDLED;
+	struct device *dev = i2c_dev->dev;
+	struct stm32_i2c_dma *dma = i2c_dev->dma;
 
-	/* Check if the interrupt if for a slave device */
-	if (!i2c_dev->master_mode) {
-		ret = stm32f7_i2c_slave_isr_event(i2c_dev);
-		return ret;
+	/* Bus error */
+	if (status & STM32F7_I2C_ISR_BERR) {
+		dev_err(dev, "Bus error accessing addr 0x%x\n", addr);
+		writel_relaxed(STM32F7_I2C_ICR_BERRCF, base + STM32F7_I2C_ICR);
+		stm32f7_i2c_release_bus(&i2c_dev->adap);
+		f7_msg->result = -EIO;
+	}
+
+	/* Arbitration loss */
+	if (status & STM32F7_I2C_ISR_ARLO) {
+		dev_dbg(dev, "Arbitration loss accessing addr 0x%x\n", addr);
+		writel_relaxed(STM32F7_I2C_ICR_ARLOCF, base + STM32F7_I2C_ICR);
+		f7_msg->result = -EAGAIN;
 	}
 
+	if (status & STM32F7_I2C_ISR_PECERR) {
+		dev_err(dev, "PEC error in reception accessing addr 0x%x\n", addr);
+		writel_relaxed(STM32F7_I2C_ICR_PECCF, base + STM32F7_I2C_ICR);
+		f7_msg->result = -EINVAL;
+	}
+
+	if (status & STM32F7_I2C_ISR_ALERT) {
+		dev_dbg(dev, "SMBus alert received\n");
+		writel_relaxed(STM32F7_I2C_ICR_ALERTCF, base + STM32F7_I2C_ICR);
+		i2c_handle_smbus_alert(i2c_dev->alert->ara);
+		return IRQ_HANDLED;
+	}
+
+	if (!i2c_dev->slave_running) {
+		u32 mask;
+		/* Disable interrupts */
+		if (stm32f7_i2c_is_slave_registered(i2c_dev))
+			mask = STM32F7_I2C_XFER_IRQ_MASK;
+		else
+			mask = STM32F7_I2C_ALL_IRQ_MASK;
+		stm32f7_i2c_disable_irq(i2c_dev, mask);
+	}
+
+	/* Disable dma */
+	if (i2c_dev->use_dma) {
+		stm32f7_i2c_disable_dma_req(i2c_dev);
+		dmaengine_terminate_async(dma->chan_using);
+	}
+
+	i2c_dev->master_mode = false;
+	complete(&i2c_dev->complete);
+
+	return IRQ_HANDLED;
+}
+
+#define STM32F7_ERR_EVENTS (STM32F7_I2C_ISR_BERR | STM32F7_I2C_ISR_ARLO |\
+			    STM32F7_I2C_ISR_PECERR | STM32F7_I2C_ISR_ALERT)
+static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
+{
+	struct stm32f7_i2c_dev *i2c_dev = data;
+	u32 status;
+
 	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
 
+	/*
+	 * Check if the interrupt is for a slave device or related
+	 * to errors flags (in case of single it line mode)
+	 */
+	if (!i2c_dev->master_mode ||
+	    (i2c_dev->setup.single_it_line && (status & STM32F7_ERR_EVENTS)))
+		return IRQ_WAKE_THREAD;
+
 	/* Tx empty */
 	if (status & STM32F7_I2C_ISR_TXIS)
 		stm32f7_i2c_write_tx_data(i2c_dev);
@@ -1513,6 +1587,33 @@ static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
 	if (status & STM32F7_I2C_ISR_RXNE)
 		stm32f7_i2c_read_rx_data(i2c_dev);
 
+	/* Wake up the thread if other flags are raised */
+	if (status &
+	    (STM32F7_I2C_ISR_NACKF | STM32F7_I2C_ISR_STOPF |
+	     STM32F7_I2C_ISR_TC | STM32F7_I2C_ISR_TCR))
+		return IRQ_WAKE_THREAD;
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)
+{
+	struct stm32f7_i2c_dev *i2c_dev = data;
+	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
+	struct stm32_i2c_dma *dma = i2c_dev->dma;
+	void __iomem *base = i2c_dev->base;
+	u32 status, mask;
+	int ret;
+
+	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
+
+	/* Handle errors in case of this handler is used for events/errors */
+	if (i2c_dev->setup.single_it_line && (status & STM32F7_ERR_EVENTS))
+		return stm32f7_i2c_handle_isr_errs(i2c_dev, status);
+
+	if (!i2c_dev->master_mode)
+		return stm32f7_i2c_slave_isr_event(i2c_dev, status);
+
 	/* NACK received */
 	if (status & STM32F7_I2C_ISR_NACKF) {
 		dev_dbg(i2c_dev->dev, "<%s>: Receive NACK (addr %x)\n",
@@ -1525,33 +1626,28 @@ static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
 		f7_msg->result = -ENXIO;
 	}
 
-	/* STOP detection flag */
-	if (status & STM32F7_I2C_ISR_STOPF) {
-		/* Disable interrupts */
-		if (stm32f7_i2c_is_slave_registered(i2c_dev))
-			mask = STM32F7_I2C_XFER_IRQ_MASK;
+	if (status & STM32F7_I2C_ISR_TCR) {
+		if (f7_msg->smbus)
+			stm32f7_i2c_smbus_reload(i2c_dev);
 		else
-			mask = STM32F7_I2C_ALL_IRQ_MASK;
-		stm32f7_i2c_disable_irq(i2c_dev, mask);
-
-		/* Clear STOP flag */
-		writel_relaxed(STM32F7_I2C_ICR_STOPCF, base + STM32F7_I2C_ICR);
-
-		if (i2c_dev->use_dma && !f7_msg->result) {
-			ret = IRQ_WAKE_THREAD;
-		} else {
-			i2c_dev->master_mode = false;
-			complete(&i2c_dev->complete);
-		}
+			stm32f7_i2c_reload(i2c_dev);
 	}
 
 	/* Transfer complete */
 	if (status & STM32F7_I2C_ISR_TC) {
+		/* Wait for dma transfer completion before sending next message */
+		if (i2c_dev->use_dma && !f7_msg->result) {
+			ret = wait_for_completion_timeout(&i2c_dev->dma->dma_complete, HZ);
+			if (!ret) {
+				dev_dbg(i2c_dev->dev, "<%s>: Timed out\n", __func__);
+				stm32f7_i2c_disable_dma_req(i2c_dev);
+				dmaengine_terminate_async(dma->chan_using);
+				f7_msg->result = -ETIMEDOUT;
+			}
+		}
 		if (f7_msg->stop) {
 			mask = STM32F7_I2C_CR2_STOP;
 			stm32f7_i2c_set_bits(base + STM32F7_I2C_CR2, mask);
-		} else if (i2c_dev->use_dma && !f7_msg->result) {
-			ret = IRQ_WAKE_THREAD;
 		} else if (f7_msg->smbus) {
 			stm32f7_i2c_smbus_rep_start(i2c_dev);
 		} else {
@@ -1561,47 +1657,18 @@ static irqreturn_t stm32f7_i2c_isr_event(int irq, void *data)
 		}
 	}
 
-	if (status & STM32F7_I2C_ISR_TCR) {
-		if (f7_msg->smbus)
-			stm32f7_i2c_smbus_reload(i2c_dev);
+	/* STOP detection flag */
+	if (status & STM32F7_I2C_ISR_STOPF) {
+		/* Disable interrupts */
+		if (stm32f7_i2c_is_slave_registered(i2c_dev))
+			mask = STM32F7_I2C_XFER_IRQ_MASK;
 		else
-			stm32f7_i2c_reload(i2c_dev);
-	}
-
-	return ret;
-}
-
-static irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)
-{
-	struct stm32f7_i2c_dev *i2c_dev = data;
-	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
-	struct stm32_i2c_dma *dma = i2c_dev->dma;
-	u32 status;
-	int ret;
-
-	/*
-	 * Wait for dma transfer completion before sending next message or
-	 * notity the end of xfer to the client
-	 */
-	ret = wait_for_completion_timeout(&i2c_dev->dma->dma_complete, HZ);
-	if (!ret) {
-		dev_dbg(i2c_dev->dev, "<%s>: Timed out\n", __func__);
-		stm32f7_i2c_disable_dma_req(i2c_dev);
-		dmaengine_terminate_async(dma->chan_using);
-		f7_msg->result = -ETIMEDOUT;
-	}
+			mask = STM32F7_I2C_ALL_IRQ_MASK;
+		stm32f7_i2c_disable_irq(i2c_dev, mask);
 
-	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
+		/* Clear STOP flag */
+		writel_relaxed(STM32F7_I2C_ICR_STOPCF, base + STM32F7_I2C_ICR);
 
-	if (status & STM32F7_I2C_ISR_TC) {
-		if (f7_msg->smbus) {
-			stm32f7_i2c_smbus_rep_start(i2c_dev);
-		} else {
-			i2c_dev->msg_id++;
-			i2c_dev->msg++;
-			stm32f7_i2c_xfer_msg(i2c_dev, i2c_dev->msg);
-		}
-	} else {
 		i2c_dev->master_mode = false;
 		complete(&i2c_dev->complete);
 	}
@@ -1609,68 +1676,14 @@ static irqreturn_t stm32f7_i2c_isr_event_thread(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t stm32f7_i2c_isr_error(int irq, void *data)
+static irqreturn_t stm32f7_i2c_isr_error_thread(int irq, void *data)
 {
 	struct stm32f7_i2c_dev *i2c_dev = data;
-	struct stm32f7_i2c_msg *f7_msg = &i2c_dev->f7_msg;
-	void __iomem *base = i2c_dev->base;
-	struct device *dev = i2c_dev->dev;
-	struct stm32_i2c_dma *dma = i2c_dev->dma;
 	u32 status;
 
 	status = readl_relaxed(i2c_dev->base + STM32F7_I2C_ISR);
 
-	/* Bus error */
-	if (status & STM32F7_I2C_ISR_BERR) {
-		dev_err(dev, "<%s>: Bus error accessing addr 0x%x\n",
-			__func__, f7_msg->addr);
-		writel_relaxed(STM32F7_I2C_ICR_BERRCF, base + STM32F7_I2C_ICR);
-		stm32f7_i2c_release_bus(&i2c_dev->adap);
-		f7_msg->result = -EIO;
-	}
-
-	/* Arbitration loss */
-	if (status & STM32F7_I2C_ISR_ARLO) {
-		dev_dbg(dev, "<%s>: Arbitration loss accessing addr 0x%x\n",
-			__func__, f7_msg->addr);
-		writel_relaxed(STM32F7_I2C_ICR_ARLOCF, base + STM32F7_I2C_ICR);
-		f7_msg->result = -EAGAIN;
-	}
-
-	if (status & STM32F7_I2C_ISR_PECERR) {
-		dev_err(dev, "<%s>: PEC error in reception accessing addr 0x%x\n",
-			__func__, f7_msg->addr);
-		writel_relaxed(STM32F7_I2C_ICR_PECCF, base + STM32F7_I2C_ICR);
-		f7_msg->result = -EINVAL;
-	}
-
-	if (status & STM32F7_I2C_ISR_ALERT) {
-		dev_dbg(dev, "<%s>: SMBus alert received\n", __func__);
-		writel_relaxed(STM32F7_I2C_ICR_ALERTCF, base + STM32F7_I2C_ICR);
-		i2c_handle_smbus_alert(i2c_dev->alert->ara);
-		return IRQ_HANDLED;
-	}
-
-	if (!i2c_dev->slave_running) {
-		u32 mask;
-		/* Disable interrupts */
-		if (stm32f7_i2c_is_slave_registered(i2c_dev))
-			mask = STM32F7_I2C_XFER_IRQ_MASK;
-		else
-			mask = STM32F7_I2C_ALL_IRQ_MASK;
-		stm32f7_i2c_disable_irq(i2c_dev, mask);
-	}
-
-	/* Disable dma */
-	if (i2c_dev->use_dma) {
-		stm32f7_i2c_disable_dma_req(i2c_dev);
-		dmaengine_terminate_async(dma->chan_using);
-	}
-
-	i2c_dev->master_mode = false;
-	complete(&i2c_dev->complete);
-
-	return IRQ_HANDLED;
+	return stm32f7_i2c_handle_isr_errs(i2c_dev, status);
 }
 
 static int stm32f7_i2c_xfer(struct i2c_adapter *i2c_adap,
@@ -1969,23 +1982,27 @@ static int stm32f7_i2c_unreg_slave(struct i2c_client *slave)
 static int stm32f7_i2c_write_fm_plus_bits(struct stm32f7_i2c_dev *i2c_dev,
 					  bool enable)
 {
-	int ret;
+	int ret = 0;
 
 	if (i2c_dev->bus_rate <= I2C_MAX_FAST_MODE_FREQ ||
-	    IS_ERR_OR_NULL(i2c_dev->regmap))
+	    (!i2c_dev->setup.fmp_cr1_bit && IS_ERR_OR_NULL(i2c_dev->regmap)))
 		/* Optional */
 		return 0;
 
-	if (i2c_dev->fmp_sreg == i2c_dev->fmp_creg)
-		ret = regmap_update_bits(i2c_dev->regmap,
-					 i2c_dev->fmp_sreg,
-					 i2c_dev->fmp_mask,
-					 enable ? i2c_dev->fmp_mask : 0);
-	else
-		ret = regmap_write(i2c_dev->regmap,
-				   enable ? i2c_dev->fmp_sreg :
-					    i2c_dev->fmp_creg,
-				   i2c_dev->fmp_mask);
+	if (i2c_dev->setup.fmp_cr1_bit) {
+		if (enable)
+			stm32f7_i2c_set_bits(i2c_dev->base + STM32F7_I2C_CR1, STM32_I2C_CR1_FMP);
+		else
+			stm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1, STM32_I2C_CR1_FMP);
+	} else {
+		if (i2c_dev->fmp_sreg == i2c_dev->fmp_creg)
+			ret = regmap_update_bits(i2c_dev->regmap, i2c_dev->fmp_sreg,
+						 i2c_dev->fmp_mask, enable ? i2c_dev->fmp_mask : 0);
+		else
+			ret = regmap_write(i2c_dev->regmap,
+					   enable ? i2c_dev->fmp_sreg : i2c_dev->fmp_creg,
+					   i2c_dev->fmp_mask);
+	}
 
 	return ret;
 }
@@ -2118,18 +2135,22 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 	if (!i2c_dev)
 		return -ENOMEM;
 
+	setup = of_device_get_match_data(&pdev->dev);
+	if (!setup) {
+		dev_err(&pdev->dev, "Can't get device data\n");
+		ret = -ENODEV;
+		goto clk_free;
+	}
+	i2c_dev->setup = *setup;
+
 	i2c_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(i2c_dev->base))
 		return PTR_ERR(i2c_dev->base);
 	phy_addr = (dma_addr_t)res->start;
 
 	irq_event = platform_get_irq(pdev, 0);
-	if (irq_event <= 0)
-		return irq_event ? : -ENOENT;
-
-	irq_error = platform_get_irq(pdev, 1);
-	if (irq_error <= 0)
-		return irq_error ? : -ENOENT;
+	if (irq_event < 0)
+		return irq_event;
 
 	i2c_dev->wakeup_src = of_property_read_bool(pdev->dev.of_node,
 						    "wakeup-source");
@@ -2168,21 +2189,24 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 		goto clk_free;
 	}
 
-	ret = devm_request_irq(&pdev->dev, irq_error, stm32f7_i2c_isr_error, 0,
-			       pdev->name, i2c_dev);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to request irq error %i\n",
-			irq_error);
-		goto clk_free;
-	}
+	if (!i2c_dev->setup.single_it_line) {
+		irq_error = platform_get_irq(pdev, 1);
+		if (irq_error < 0) {
+			ret = irq_error;
+			goto clk_free;
+		}
 
-	setup = of_device_get_match_data(&pdev->dev);
-	if (!setup) {
-		dev_err(&pdev->dev, "Can't get device data\n");
-		ret = -ENODEV;
-		goto clk_free;
+		ret = devm_request_threaded_irq(&pdev->dev, irq_error,
+						NULL,
+						stm32f7_i2c_isr_error_thread,
+						IRQF_ONESHOT,
+						pdev->name, i2c_dev);
+		if (ret) {
+			dev_err(&pdev->dev, "Failed to request irq error %i\n",
+				irq_error);
+			goto clk_free;
+		}
 	}
-	i2c_dev->setup = *setup;
 
 	ret = stm32f7_i2c_setup_timing(i2c_dev, &i2c_dev->setup);
 	if (ret)
@@ -2190,9 +2214,11 @@ static int stm32f7_i2c_probe(struct platform_device *pdev)
 
 	/* Setup Fast mode plus if necessary */
 	if (i2c_dev->bus_rate > I2C_MAX_FAST_MODE_FREQ) {
-		ret = stm32f7_i2c_setup_fm_plus_bits(pdev, i2c_dev);
-		if (ret)
-			goto clk_free;
+		if (!i2c_dev->setup.fmp_cr1_bit) {
+			ret = stm32f7_i2c_setup_fm_plus_bits(pdev, i2c_dev);
+			if (ret)
+				goto clk_free;
+		}
 		ret = stm32f7_i2c_write_fm_plus_bits(i2c_dev, true);
 		if (ret)
 			goto clk_free;
@@ -2348,63 +2374,23 @@ static int stm32f7_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int __maybe_unused stm32f7_i2c_runtime_suspend(struct device *dev)
+static void __maybe_unused stm32f7_i2c_regs_backup(struct stm32f7_i2c_dev *i2c_dev)
 {
-	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
-
-	if (!stm32f7_i2c_is_slave_registered(i2c_dev))
-		clk_disable_unprepare(i2c_dev->clk);
-
-	return 0;
-}
-
-static int __maybe_unused stm32f7_i2c_runtime_resume(struct device *dev)
-{
-	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
-	int ret;
-
-	if (!stm32f7_i2c_is_slave_registered(i2c_dev)) {
-		ret = clk_prepare_enable(i2c_dev->clk);
-		if (ret) {
-			dev_err(dev, "failed to prepare_enable clock\n");
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
-static int __maybe_unused stm32f7_i2c_regs_backup(struct stm32f7_i2c_dev *i2c_dev)
-{
-	int ret;
 	struct stm32f7_i2c_regs *backup_regs = &i2c_dev->backup_regs;
 
-	ret = pm_runtime_resume_and_get(i2c_dev->dev);
-	if (ret < 0)
-		return ret;
-
 	backup_regs->cr1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR1);
 	backup_regs->cr2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR2);
 	backup_regs->oar1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR1);
 	backup_regs->oar2 = readl_relaxed(i2c_dev->base + STM32F7_I2C_OAR2);
 	backup_regs->tmgr = readl_relaxed(i2c_dev->base + STM32F7_I2C_TIMINGR);
 	stm32f7_i2c_write_fm_plus_bits(i2c_dev, false);
-
-	pm_runtime_put_sync(i2c_dev->dev);
-
-	return ret;
 }
 
-static int __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_dev)
+static void __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_dev)
 {
 	u32 cr1;
-	int ret;
 	struct stm32f7_i2c_regs *backup_regs = &i2c_dev->backup_regs;
 
-	ret = pm_runtime_resume_and_get(i2c_dev->dev);
-	if (ret < 0)
-		return ret;
-
 	cr1 = readl_relaxed(i2c_dev->base + STM32F7_I2C_CR1);
 	if (cr1 & STM32F7_I2C_CR1_PE)
 		stm32f7_i2c_clr_bits(i2c_dev->base + STM32F7_I2C_CR1,
@@ -2420,29 +2406,48 @@ static int __maybe_unused stm32f7_i2c_regs_restore(struct stm32f7_i2c_dev *i2c_d
 	writel_relaxed(backup_regs->oar1, i2c_dev->base + STM32F7_I2C_OAR1);
 	writel_relaxed(backup_regs->oar2, i2c_dev->base + STM32F7_I2C_OAR2);
 	stm32f7_i2c_write_fm_plus_bits(i2c_dev, true);
+}
 
-	pm_runtime_put_sync(i2c_dev->dev);
+static int __maybe_unused stm32f7_i2c_runtime_suspend(struct device *dev)
+{
+	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
 
-	return ret;
+	stm32f7_i2c_regs_backup(i2c_dev);
+
+	if (!stm32f7_i2c_is_slave_registered(i2c_dev))
+		clk_disable_unprepare(i2c_dev->clk);
+
+	return 0;
 }
 
-static int __maybe_unused stm32f7_i2c_suspend(struct device *dev)
+static int __maybe_unused stm32f7_i2c_runtime_resume(struct device *dev)
 {
 	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
 	int ret;
 
-	i2c_mark_adapter_suspended(&i2c_dev->adap);
-
-	if (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {
-		ret = stm32f7_i2c_regs_backup(i2c_dev);
-		if (ret < 0) {
-			i2c_mark_adapter_resumed(&i2c_dev->adap);
+	if (!stm32f7_i2c_is_slave_registered(i2c_dev)) {
+		ret = clk_prepare_enable(i2c_dev->clk);
+		if (ret) {
+			dev_err(dev, "failed to prepare_enable clock\n");
 			return ret;
 		}
+	}
 
+	stm32f7_i2c_regs_restore(i2c_dev);
+
+	return 0;
+}
+
+static int __maybe_unused stm32f7_i2c_suspend(struct device *dev)
+{
+	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
+
+	i2c_mark_adapter_suspended(&i2c_dev->adap);
+
+	if (!device_may_wakeup(dev) && !device_wakeup_path(dev))
 		pinctrl_pm_select_sleep_state(dev);
-		pm_runtime_force_suspend(dev);
-	}
+
+	pm_runtime_force_suspend(dev);
 
 	return 0;
 }
@@ -2452,16 +2457,12 @@ static int __maybe_unused stm32f7_i2c_resume(struct device *dev)
 	struct stm32f7_i2c_dev *i2c_dev = dev_get_drvdata(dev);
 	int ret;
 
-	if (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {
-		ret = pm_runtime_force_resume(dev);
-		if (ret < 0)
-			return ret;
-		pinctrl_pm_select_default_state(dev);
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0)
+		return ret;
 
-		ret = stm32f7_i2c_regs_restore(i2c_dev);
-		if (ret < 0)
-			return ret;
-	}
+	if (!device_may_wakeup(dev) && !device_wakeup_path(dev))
+		pinctrl_pm_select_default_state(dev);
 
 	i2c_mark_adapter_resumed(&i2c_dev->adap);
 
@@ -2478,6 +2479,7 @@ static const struct of_device_id stm32f7_i2c_match[] = {
 	{ .compatible = "st,stm32f7-i2c", .data = &stm32f7_setup},
 	{ .compatible = "st,stm32mp15-i2c", .data = &stm32mp15_setup},
 	{ .compatible = "st,stm32mp13-i2c", .data = &stm32mp13_setup},
+	{ .compatible = "st,stm32mp25-i2c", .data = &stm32mp25_setup},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32f7_i2c_match);
diff --git a/drivers/i3c/master/Kconfig b/drivers/i3c/master/Kconfig
index 3b8f95916..4d476340e 100644
--- a/drivers/i3c/master/Kconfig
+++ b/drivers/i3c/master/Kconfig
@@ -22,6 +22,13 @@ config DW_I3C_MASTER
 	  This driver can also be built as a module.  If so, the module
 	  will be called dw-i3c-master.
 
+config STM32_I3C_MASTER
+	tristate "STM32 I3C driver"
+	depends on I3C
+	depends on HAS_IOMEM
+	help
+	  Support for STmicroelectronics STM32 I3C controller.
+
 config SVC_I3C_MASTER
 	tristate "Silvaco I3C Dual-Role Master driver"
 	depends on I3C
diff --git a/drivers/i3c/master/Makefile b/drivers/i3c/master/Makefile
index b3fee0f69..2e4e241b6 100644
--- a/drivers/i3c/master/Makefile
+++ b/drivers/i3c/master/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_CDNS_I3C_MASTER)		+= i3c-master-cdns.o
 obj-$(CONFIG_DW_I3C_MASTER)		+= dw-i3c-master.o
+obj-$(CONFIG_STM32_I3C_MASTER) 		+= stm32-i3c-master.o
 obj-$(CONFIG_SVC_I3C_MASTER)		+= svc-i3c-master.o
 obj-$(CONFIG_MIPI_I3C_HCI)		+= mipi-i3c-hci/
diff --git a/drivers/i3c/master/stm32-i3c-master.c b/drivers/i3c/master/stm32-i3c-master.c
new file mode 100644
index 000000000..bfef3e101
--- /dev/null
+++ b/drivers/i3c/master/stm32-i3c-master.c
@@ -0,0 +1,1884 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STM32 I3C controller driver
+ *
+ * Copyright (C) STMicroelectronics 2024
+ * Author(s): Amelie Delaunay <amelie.delaunay@foss.st.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/i3c/master.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/units.h>
+
+#define STM32_I3C_CR            0x00
+#define STM32_I3C_CFGR          0x04
+#define STM32_I3C_RDR           0x10
+#define STM32_I3C_RDWR          0x14
+#define STM32_I3C_TDR           0x18
+#define STM32_I3C_TDWR          0x1c
+#define STM32_I3C_IBIDR         0x20
+#define STM32_I3C_TGTTDR        0x24 /* Target only */
+#define STM32_I3C_SR            0x30
+#define STM32_I3C_SER           0x34
+#define STM32_I3C_RMR           0x40
+#define STM32_I3C_EVR           0x50
+#define STM32_I3C_IER           0x54
+#define STM32_I3C_CEVR          0x58
+#define STM32_I3C_DEVR0         0x60
+#define STM32_I3C_DEVR(x)       (0x64 + (0x4 * (x)))
+#define STM32_I3C_MAXRLR        0x90 /* Target only */
+#define STM32_I3C_MAXWLR        0x94 /* Target only */
+#define STM32_I3C_TIMINGR0      0xa0
+#define STM32_I3C_TIMINGR1      0xa4
+#define STM32_I3C_TIMINGR2      0xa8
+#define STM32_I3C_BCR           0xc0 /* Target only */
+#define STM32_I3C_DCR           0xc4 /* Target only */
+#define STM32_I3C_GETCAPR       0xc8 /* Target only */
+#define STM32_I3C_CRCAPR        0xcc /* Target only */
+#define STM32_I3C_GETMXDSR      0xd0 /* Target only */
+#define STM32_I3C_EPIDR         0xd4 /* Target only */
+#define STM32_I3C_HWCFGR        0x3f0
+#define STM32_I3C_VERR          0x3f4
+
+/* I3C_CR I3C message control register */
+#define I3C_CR_DCNT		GENMASK(15, 0)
+#define I3C_CR_RNW		BIT(16)
+#define I3C_CR_ADD		GENMASK(23, 17)
+#define I3C_CR_CCC		GENMASK(23, 16) /* [alternate] I3C_CR, for CCC */
+#define I3C_CR_MTYPE		GENMASK(30, 27)
+#define I3C_CR_MEND		BIT(31)
+#define MTYPE_I3C_SCL_STOP	0 /* in case of CE1 error */
+#define MTYPE_I3C_HEADER_MSG	1 /* ?in case of escalation stage */
+#define MTYPE_I3C_PRIV_MSG	2 /* .priv_xfers */
+#define MTYPE_I3C_DIRECT_MSG	3 /* second part of .send_ccc_cmd(direct) */
+#define MTYPE_I2C_MSG		4 /* .i2c_xfers */
+#define MTYPE_I3C_CCC_CMD	6 /* .send_ccc_cmd(broadcast/direct), .do_daa */
+
+/* I3C_CFGR I3C configuration register */
+#define I3C_CFGR_EN		BIT(0)
+#define I3C_CFGR_CRINIT		BIT(1)
+#define I3C_CFGR_NOARBH		BIT(2)
+#define I3C_CFGR_RSTPTRN	BIT(3)
+#define I3C_CFGR_EXITPTRN	BIT(4)
+#define I3C_CFGR_HKSDAEN	BIT(5)
+#define I3C_CFGR_HJACK		BIT(7)
+#define I3C_CFGR_RXDMAEN	BIT(8)
+#define I3C_CFGR_RXFLUSH	BIT(9)
+#define I3C_CFGR_RXTHRES	BIT(10)
+#define I3C_CFGR_TXDMAEN	BIT(12)
+#define I3C_CFGR_TXFLUSH	BIT(13)
+#define I3C_CFGR_TXTHRES	BIT(14)
+#define I3C_CFGR_SDMAEN		BIT(16)
+#define I3C_CFGR_SFLUSH		BIT(17)
+#define I3C_CFGR_SMODE		BIT(18)
+#define I3C_CFGR_TMODE		BIT(19)
+#define I3C_CFGR_CDMAEN		BIT(20)
+#define I3C_CFGR_CFLUSH		BIT(21)
+#define I3C_CFGR_TSFSET		BIT(30)
+
+/* I3C_RDR I3C receive data byte register */
+#define I3C_RDR_RDB0		GENMASK(7, 0)
+
+/* I3C_RDWR I3C receive data word register */
+#define I3C_RDWR_RDB0		GENMASK(7, 0)
+#define I3C_RDWR_RDB1		GENMASK(15, 8)
+#define I3C_RDWR_RDB2		GENMASK(23, 16)
+#define I3C_RDWR_RDB3		GENMASK(31, 24)
+
+/* I3C_TDR I3C transmit data byte register */
+#define I3C_RDR_TDB0		GENMASK(7, 0)
+
+/* I3C_TDWR I3C receive data word register */
+#define I3C_TDWR_TDB0		GENMASK(7, 0)
+#define I3C_TDWR_TDB1		GENMASK(15, 8)
+#define I3C_TDWR_TDB2		GENMASK(23, 16)
+#define I3C_TDWR_TDB3		GENMASK(31, 24)
+
+/* I3C_IBIDR I3C IBI payload data register */
+#define I3C_IBIDR_IBIDB0	GENMASK(7, 0)
+#define I3C_IBIDR_IBIDB1	GENMASK(15, 8)
+#define I3C_IBIDR_IBIDB2	GENMASK(23, 16)
+#define I3C_IBIDR_IBIDB3	GENMASK(31, 24)
+
+/* I3C_SR I3C status register */
+#define I3C_SR_XDCNT		GENMASK(15, 0)
+#define I3C_SR_ABT		BIT(17)
+#define I3C_SR_DIR		BIT(18)
+#define I3C_SR_MID		GENMASK(31, 24)
+
+/* I3C_SER I3C status error register */
+#define I3C_SER_CODERR		GENMASK(3, 0)
+#define I3C_SER_PERR		BIT(4)
+#define I3C_SER_STALL		BIT(5)
+#define I3C_SER_DOVR		BIT(6)
+#define I3C_SER_COVR		BIT(7)
+#define I3C_SER_ANACK		BIT(8)
+#define I3C_SER_DNACK		BIT(9)
+#define I3C_SER_DERR		BIT(10)
+
+/* I3C_RMR I3C received message register */
+#define I3C_RMR_IBIRDCNT	GENMASK(2, 0)
+#define I3C_RMR_RCODE		GENMASK(15, 8)
+#define I3C_RMR_RADD		GENMASK(23, 17)
+
+/* I3C_EVR I3C event register */
+#define I3C_EVR_CFEF		BIT(0)
+#define I3C_EVR_TXFEF		BIT(1)
+#define I3C_EVR_CFNFF		BIT(2)
+#define I3C_EVR_SFNEF		BIT(3)
+#define I3C_EVR_TXFNFF		BIT(4)
+#define I3C_EVR_RXFNEF		BIT(5)
+#define I3C_EVR_TXLASTF		BIT(6)
+#define I3C_EVR_RXLASTF		BIT(7)
+#define I3C_EVR_FCF		BIT(9)
+#define I3C_EVR_RXTGTENDF	BIT(10)
+#define I3C_EVR_ERRF		BIT(11)
+#define I3C_EVR_IBIF		BIT(15)
+#define I3C_EVR_IBIENDF		BIT(16)
+#define I3C_EVR_CRF		BIT(17)
+#define I3C_EVR_CRUPDF		BIT(18)
+#define I3C_EVR_HJF		BIT(19)
+#define I3C_EVR_WKPF		BIT(21) /* Target */
+#define I3C_EVR_GETF		BIT(22) /* Target */
+#define I3C_EVR_STAF		BIT(23) /* Target */
+#define I3C_EVR_DAUPDF		BIT(24) /* Target */
+#define I3C_EVR_MWLUPDF		BIT(25) /* Target */
+#define I3C_EVR_MRLUPDF		BIT(26) /* Target */
+#define I3C_EVR_RSTF		BIT(27) /* Target */
+#define I3C_EVR_ASUPDF		BIT(28) /* Target */
+#define I3C_EVR_INTUPDF		BIT(29) /* Target */
+#define I3C_EVR_DEFF		BIT(30) /* Target */
+#define I3C_EVR_GRPF		BIT(31) /* Target */
+
+/* I3C_IER I3C interrupt enable register */
+#define I3C_IER_CFNFIE		BIT(2)
+#define I3C_IER_SFNEIE		BIT(3)
+#define I3C_IER_TXFNFIE		BIT(4)
+#define I3C_IER_RXFNEIE		BIT(5)
+#define I3C_IER_FCIE		BIT(9)
+#define I3C_IER_RXTGTENDIE	BIT(10)
+#define I3C_IER_ERRIE		BIT(11)
+#define I3C_IER_IBIIE		BIT(15)
+#define I3C_IER_IBIENDIE	BIT(16) /* Target */
+#define I3C_IER_CRIE		BIT(17)
+#define I3C_IER_CRUPDIE		BIT(18) /* Target */
+#define I3C_IER_HJIE		BIT(19)
+#define I3C_IER_WKPIE		BIT(21) /* Target */
+#define I3C_IER_GETIE		BIT(22) /* Target */
+#define I3C_IER_STAIE		BIT(23) /* Target */
+#define I3C_IER_DAUPDIE		BIT(24) /* Target */
+#define I3C_IER_MWLUPDIE	BIT(25) /* Target */
+#define I3C_IER_MRLUPDIE	BIT(26) /* Target */
+#define I3C_IER_RSTIE		BIT(27) /* Target */
+#define I3C_IER_ASUPDIE		BIT(28) /* Target */
+#define I3C_IER_INTUPDIE	BIT(29) /* Target */
+#define I3C_IER_DEFIE		BIT(30) /* Target */
+#define I3C_IER_GRPIE		BIT(31) /* Target */
+#define I3C_IER_CTRL_IE		(I3C_IER_FCIE | I3C_IER_RXTGTENDIE | I3C_IER_ERRIE | \
+				 I3C_IER_IBIIE | I3C_IER_CRIE | I3C_IER_HJIE)
+#define I3C_IER_FIFO_IE		(I3C_IER_CFNFIE | I3C_IER_SFNEIE | \
+				 I3C_IER_TXFNFIE | I3C_IER_RXFNEIE)
+
+/* I3C_CEVR I3C clear event register */
+#define I3C_CEVR_CFCF		BIT(9)
+#define I3C_CEVR_CRXTGTENDF	BIT(10)
+#define I3C_CEVR_CERRF		BIT(11)
+#define I3C_CEVR_CIBIF		BIT(15)
+#define I3C_CEVR_CIBIENDF	BIT(16)
+#define I3C_CEVR_CCRF		BIT(17)
+#define I3C_CEVR_CCRUPDF	BIT(18)
+#define I3C_CEVR_CHJF		BIT(19)
+#define I3C_CEVR_CWKPF		BIT(21) /* Target */
+#define I3C_CEVR_CGETF		BIT(22) /* Target */
+#define I3C_CEVR_CSTAF		BIT(23) /* Target */
+#define I3C_CEVR_CDAUPDF	BIT(24) /* Target */
+#define I3C_CEVR_CMWLUPDF	BIT(25) /* Target */
+#define I3C_CEVR_CMRLUPDF	BIT(26) /* Target */
+#define I3C_CEVR_CRSTF		BIT(27) /* Target */
+#define I3C_CEVR_CASUPDF	BIT(28) /* Target */
+#define I3C_CEVR_CINTUPDF	BIT(29) /* Target */
+#define I3C_CEVR_CDEFF		BIT(30) /* Target */
+#define I3C_CEVR_CGRPF		BIT(31) /* Target */
+
+/* I3C_DEVR0 I3C own device characteristics register */
+#define I3C_DEVR0_DAVAL		BIT(0) /* Target */
+#define I3C_DEVR0_DA		GENMASK(7, 1)
+#define I3C_DEVR0_IBIEN		BIT(16) /* Target */
+#define I3C_DEVR0_CREN		BIT(17) /* Target */
+#define I3C_DEVR0_HJEN		BIT(19) /* Target */
+#define I3C_DEVR0_AS		GENMASK(21, 20) /* Target */
+#define I3C_DEVR0_RSTACT	GENMASK(23, 22) /* Target */
+#define I3C_DEVR0_RSTVAL	BIT(24) /* Target */
+
+/* I3C_DEVRx I3C_device x characteristics register */
+#define I3C_DEVR_DA		GENMASK(7, 1)
+#define I3C_DEVR_IBIACK		BIT(16)
+#define I3C_DEVR_CRACK		BIT(17)
+#define I3C_DEVR_IBIDEN		BIT(18)
+#define I3C_DEVR_SUSP		BIT(19)
+#define I3C_DEVR_DIS		BIT(31)
+
+/* I3C_MAXRLR maximum read length register */
+/* I3C_MAXWLR maximum write length register */
+
+/* I3C_TIMINGR0 I3C timing register 0 */
+#define I3C_TIMINGR0_SCLL_PP	GENMASK(7, 0)
+#define I3C_TIMINGR0_SCLH_I3C	GENMASK(15, 8)
+#define I3C_TIMINGR0_SCLL_OD	GENMASK(23, 16)
+#define I3C_TIMINGR0_SCLH_I2C	GENMASK(31, 24)
+
+/* I3C_TIMINGR1 I3C timing register 1 */
+#define I3C_TIMINGR1_AVAL	GENMASK(7, 0)
+#define I3C_TIMINGR1_ASNCR	GENMASK(9, 8)
+#define I3C_TIMINGR1_FREE	GENMASK(22, 16)
+#define I3C_TIMINGR1_SDA_HD	BIT(28)
+
+/* I3C_TIMINGR2 I3C timing register 2 */
+#define I3C_TIMINGR2_STALLT	BIT(0)
+#define I3C_TIMINGR2_STALLD	BIT(1)
+#define I3C_TIMINGR2_STALLC	BIT(2)
+#define I3C_TIMINGR2_STALLA	BIT(3)
+#define I3C_TIMINGR2_STALL	GENMASK(15, 8)
+
+/* I3C_BCR I3C bus characteristics register */
+/* I3C_DCR I3C device characteristics register */
+/* I3C_GETCAPR I3C get capability register */
+/* I3C_CRCAPR I3C controller-role capability register */
+/* I3C_GETMXDSR I3C get capability (maximum data speed) register */
+/* I3C_EPIDR I3C extended provisioned ID register */
+
+/* I3C_HWCFGR I3C hardware configuration register */
+#define I3C_HWCFGR_CSIZE        GENMASK(3, 0)
+#define I3C_HWCFGR_SSIZE        GENMASK(7, 4)
+#define I3C_HWCFGR_TSIZE        GENMASK(11, 8)
+#define I3C_HWCFGR_RSIZE        GENMASK(15, 12)
+#define I3C_HWCFGR_NBT          GENMASK(19, 16)
+
+/* I3C_VERR I3C version register */
+#define I3C_VERR_MINREV         GENMASK(3, 0)
+#define I3C_VERR_MAJREV         GENMASK(7, 4)
+
+#define I3C_BUS_TDIGH_MIN_PS		32000	/* 32ns tDIG_H Min */
+#define I3C_BUS_THIGH_OD_MAX_PS		41000	/* 41ns tHIGH Max*/
+#define I3C_BUS_THIGH_PP_MAX_PS		45000	/* 45ns tHIGH Max*/
+#define I3C_BUS_I2C_FM_TLOW_MIN_PS	1300000	/* 1300ns tLOW Min I2C FM */
+#define I3C_BUS_I2C_FMP_TLOW_MIN_PS	500000	/* 500ns tLOW Min I2C FMP */
+#define I3C_BUS_HD_PP_MIN_PS		3000	/* 3ns tHD_PP Min*/
+#define I3C_BUS_CAS_MIN_PS		38400	/* 38.4ns */
+
+#define I3C_IBI_MAX_PAYLOAD_LEN		32 /* 4 bytes in I3C_IBIDR */
+
+struct stm32_i3c_cmd {
+	u32 msg_cr; /* Used to prepare MTYPE, (ADD, RNW/CCC) */
+	unsigned int data_len;
+	union {
+		const void *tx;
+		void *rx;
+	} data;
+	enum i3c_error_code error;
+};
+
+struct stm32_i3c_xfer {
+	struct list_head node;
+	struct completion comp;
+	int ret;
+	int cur_cmd;
+	unsigned int ncmds;
+	struct stm32_i3c_cmd cmds[]; //__counted_by(ncmds);
+};
+
+struct stm32_i3c_dev_ibi_data {
+	struct i3c_ibi_slot *ibi_slot;
+	struct i3c_generic_ibi_pool *ibi_pool;
+	unsigned int max_len;
+};
+
+struct stm32_i3c_dev_data {
+	int dev_idx;
+	struct stm32_i3c_dev_ibi_data *ibi_data;
+};
+
+struct stm32_i3c_ddata {
+	struct device *dev;
+	struct i3c_master_controller master;
+	void __iomem *base;
+	struct clk *clk;
+	u32 nslots; /* Number of I3C targets, I2C targets are not limited */
+	unsigned long *slots;
+	struct {
+		struct list_head list;
+		struct stm32_i3c_xfer *cur_xfer;
+		/* Prevent races between transfers */
+		spinlock_t lock;
+	} xferqueue;
+	u32 sda_rise_ns; /* time SDA signal takes to rise to 0.7xVdd in ns */
+};
+
+static inline struct stm32_i3c_ddata *to_stm32_i3c_ddata(struct i3c_master_controller *m)
+{
+	return container_of(m, struct stm32_i3c_ddata, master);
+}
+
+static inline struct i3c_dev_desc *addr_to_i3c_dev_desc(struct i3c_master_controller *m, u8 addr)
+{
+	struct i3c_bus *bus = i3c_master_get_bus(m);
+	struct i3c_dev_desc *i3cdev;
+
+	i3c_bus_for_each_i3cdev(bus, i3cdev) {
+		if (i3cdev->info.dyn_addr == addr)
+			return i3cdev;
+	}
+	return NULL;
+}
+
+static void stm32_i3c_master_send_stop(struct stm32_i3c_ddata *ddata)
+{
+	u32 cr = FIELD_PREP(I3C_CR_MTYPE, MTYPE_I3C_SCL_STOP) | I3C_CR_MEND;
+
+	writel_relaxed(cr, ddata->base + STM32_I3C_CR);
+	dev_warn(ddata->dev, "Stop SCL\n");
+
+	/*
+	 * Must wait at least 150us before emitting another message.
+	 * stm32_i3c_master_send_stop() can be called from atomic context, hence udelay.
+	 */
+	udelay(150);
+}
+
+static int stm32_i3c_master_write_txfifo(struct stm32_i3c_ddata *ddata)
+{
+	struct stm32_i3c_xfer *cur_xfer = ddata->xferqueue.cur_xfer;
+	u32 offset = 0, len, evr;
+	const u8 *p;
+	int ret;
+
+	if (!cur_xfer) /* TODO: flush? */
+		return -EINVAL;
+
+	p = cur_xfer->cmds[cur_xfer->cur_cmd].data.tx;
+	len = cur_xfer->cmds[cur_xfer->cur_cmd].data_len;
+	/* FIXME: keep offset of data pointer? */
+	while (offset < len) {
+		ret = readl_relaxed_poll_timeout_atomic(ddata->base + STM32_I3C_EVR, evr,
+							evr & I3C_EVR_TXFNFF, 0, 1000);
+		if (ret)
+			return ret;
+
+		/* TODO I3C_CFGR.TXTHRES=1
+		 * writel_relaxed(p[offset], ddata->base + STM32_I3C_TDWR);
+		 * offset += sizeof(u32);
+		 */
+		writeb_relaxed(p[offset++], ddata->base + STM32_I3C_TDR);
+	}
+
+	return 0;
+}
+
+static int stm32_i3c_master_read_rxfifo(struct stm32_i3c_ddata *ddata)
+{
+	struct stm32_i3c_xfer *cur_xfer = ddata->xferqueue.cur_xfer;
+	u32 len, evr;
+	u8 *p;
+	int ret;
+
+	if (!cur_xfer) /* TODO: flush? */
+		return -EINVAL;
+
+	p = cur_xfer->cmds[cur_xfer->cur_cmd].data.rx;
+	len = cur_xfer->cmds[cur_xfer->cur_cmd].data_len;
+	/* FIXME: keep offset of data pointer */
+	while (len) {
+		ret = readl_relaxed_poll_timeout_atomic(ddata->base + STM32_I3C_EVR, evr,
+							evr & I3C_EVR_RXFNEF, 0, 1000);
+		if (ret)
+			return ret;
+
+		/* TODO I3C_CFGR.RXTHRES=1
+		 * *p = readl_relaxed(ddata->base + STM32_I3C_RDWR);
+		 * if (len < sizeof(u32)) {
+		 *	p += len;
+		 *	len = 0;
+		 * } else {
+		 *	p += sizeof(u32);
+		 *	len -= sizeof(u32);
+		 * }
+		 */
+		*p = readb_relaxed(ddata->base + STM32_I3C_RDR);
+		p++;
+		len--;
+	}
+
+	return 0;
+}
+
+static u32 stm32_i3c_master_read_error(struct stm32_i3c_ddata *ddata)
+{
+	u32 ser = readl_relaxed(ddata->base + STM32_I3C_SER);
+	const char *bus_name = dev_name(&ddata->master.dev);
+
+	if (ser & I3C_SER_DERR)
+		dev_warn(ddata->dev, "(%s) data error during controller-role hand-off\n", bus_name);
+
+	if (ser & I3C_SER_DNACK)
+		dev_warn(ddata->dev, "(%s) data not acknowledged\n", bus_name);
+
+	if (ser & I3C_SER_ANACK)
+		dev_warn(ddata->dev, "(%s) address not acknowledged\n", bus_name);
+
+	if (ser & I3C_SER_COVR)
+		dev_warn(ddata->dev, "(%s) C-FIFO underrun or S-FIFO overrun\n", bus_name);
+
+	if (ser & I3C_SER_DOVR)
+		dev_warn(ddata->dev, "(%s) RX-FIFO overrun or TX-FIFO underrun\n", bus_name);
+
+	if (ser & I3C_SER_PERR)
+		dev_warn(ddata->dev, "(%s) protocol error [M%lu]\n",
+			 bus_name, FIELD_GET(I3C_SER_CODERR, ser));
+
+	return ser;
+}
+
+static u32 stm32_i3c_master_read_status(struct stm32_i3c_ddata *ddata)
+{
+	u32 sr = readl_relaxed(ddata->base + STM32_I3C_SR);
+
+	dev_dbg(ddata->dev, "%s: %s transfer %lu, data counter=%lu\n", __func__,
+		FIELD_GET(I3C_SR_DIR, sr) == 0 ? "Write" : "Read",
+		FIELD_GET(I3C_SR_MID, sr) + 1, FIELD_GET(I3C_SR_XDCNT, sr));
+
+	return sr;
+}
+
+static void stm32_i3c_master_fifo_flush(struct stm32_i3c_ddata *ddata)
+{
+	u32 cfgr = readl_relaxed(ddata->base + STM32_I3C_CFGR);
+
+	cfgr |= I3C_CFGR_CFLUSH | I3C_CFGR_SFLUSH | I3C_CFGR_TXFLUSH | I3C_CFGR_RXFLUSH;
+
+	writel_relaxed(cfgr, ddata->base + STM32_I3C_CFGR);
+}
+
+static void stm32_i3c_master_request_xfer(struct stm32_i3c_ddata *ddata)
+{
+	u32 cfgr = readl_relaxed(ddata->base + STM32_I3C_CFGR);
+
+	writel_relaxed(cfgr | I3C_CFGR_TSFSET, ddata->base + STM32_I3C_CFGR);
+
+	dev_dbg(ddata->dev, "%s: cfgr=%#x\n", __func__, cfgr);
+	/*
+	 * This causes the HW to raise I3C_EVR.CFNFF=1,
+	 * to request a first control word I3C_CR to be written.
+	 */
+
+	/*
+	 * Alternative is to write a first control word into I3C_CR, while I3C_EVR.CFEF = 1,
+	 * if I3C_CR.MEND = 0, this will cause the HW to raise I3C_EVR.CNFF=1 to request the next
+	 * control word.
+	 */
+}
+
+static void stm32_i3c_master_set_arb_header(struct stm32_i3c_ddata *ddata, bool enable)
+{
+	u32 cfgr = readl_relaxed(ddata->base + STM32_I3C_CFGR);
+
+	/*
+	 * This is a more performing option (when the emission of the 0x7E arbitrable header is
+	 * useless), but must be used only when the controller is sure that the addressed target
+	 * device cannot emit concurrently an IBI or a controller-role request (to insure no
+	 * misinterpretation and no potential conflict between the address emitted by the controller
+	 * in open-drain mode and the same address a target device can emit after a start, for IBI
+	 * or MR).
+	 */
+	if (enable)
+		cfgr &= ~I3C_CFGR_NOARBH; /* Arbitration header (7'h7E) is sent after Start */
+	else
+		cfgr |= I3C_CFGR_NOARBH; /* Target address is sent after Start */
+
+	writel_relaxed(cfgr, ddata->base + STM32_I3C_CFGR);
+}
+
+static void stm32_i3c_master_set_fifo_preload(struct stm32_i3c_ddata *ddata, bool enable)
+{
+	u32 cfgr = readl_relaxed(ddata->base + STM32_I3C_CFGR);
+	/*
+	 * 0: C-FIFO and TX-FIFO are not preloaded before starting to emit a frame transfer.
+	 * A frame transfer starts as soon as the first control word is present in C-FIFO.
+	 * 1: C-FIFO and TX-FIFO are first preloaded (also TX-FIFO if needed, depending on the frame
+	 * format) before starting to emit a frame transfer.
+	 */
+
+	if (enable)
+		cfgr |= I3C_CFGR_TMODE; /* Start as soon as 1st control word written in C-FIFO */
+	else
+		cfgr &= ~I3C_CFGR_TMODE; /* C-FIFO (& TX-FIFO if needed) preload before Start */
+
+	writel_relaxed(cfgr, ddata->base + STM32_I3C_CFGR);
+}
+
+static void stm32_i3c_master_dequeue_xfer(struct stm32_i3c_ddata *ddata,
+					  struct stm32_i3c_xfer *xfer)
+{
+	if (ddata->xferqueue.cur_xfer == xfer) {
+		ddata->xferqueue.cur_xfer = NULL;
+
+		/* FIXME: reset/flush FIFOs? */
+	} else {
+		list_del_init(&xfer->node);
+	}
+}
+
+//TODO: needed?
+static void __maybe_unused stm32_i3c_master_dequeue_xfer_locked(struct stm32_i3c_ddata *ddata,
+								struct stm32_i3c_xfer *xfer)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ddata->xferqueue.lock, flags);
+	stm32_i3c_master_dequeue_xfer(ddata, xfer);
+	spin_unlock_irqrestore(&ddata->xferqueue.lock, flags);
+}
+
+static void stm32_i3c_master_start_xfer_locked(struct stm32_i3c_ddata *ddata)
+{
+	struct stm32_i3c_xfer *xfer = ddata->xferqueue.cur_xfer;
+	u32 mtype;
+
+	if (!xfer) {
+		dev_dbg(ddata->dev, "%s: no cur_xfer\n", __func__);
+		return;
+	}
+
+	mtype = FIELD_GET(I3C_CR_MTYPE, xfer->cmds[0].msg_cr);
+	if (mtype == MTYPE_I2C_MSG || mtype == MTYPE_I3C_PRIV_MSG)
+		stm32_i3c_master_set_arb_header(ddata, false);
+	else
+		stm32_i3c_master_set_arb_header(ddata, true);
+
+	stm32_i3c_master_set_fifo_preload(ddata, true);
+
+	stm32_i3c_master_request_xfer(ddata);
+}
+
+static void stm32_i3c_master_end_xfer_locked(struct stm32_i3c_ddata *ddata, u32 evr)
+{
+	struct stm32_i3c_xfer *xfer = ddata->xferqueue.cur_xfer;
+	u32 status, id, error, code = 0;
+	int i, ret = 0;
+
+	if (!xfer)
+		return;
+
+	status = stm32_i3c_master_read_status(ddata);
+	id = FIELD_GET(I3C_SR_MID, status);
+	if (!(evr & I3C_EVR_ERRF))
+		goto skip_error;
+
+	error = stm32_i3c_master_read_error(ddata);
+
+	if ((error & I3C_SER_COVR) | (error & I3C_SER_DOVR)) {
+		ret = -ENOSPC;
+	} else if ((error & I3C_SER_DNACK) | (error & I3C_SER_ANACK)) {
+		ret = -EIO;
+	} else if (error & I3C_SER_DERR) {
+		ret = -EINVAL;
+	} else if (error & I3C_SER_PERR) {
+		code = FIELD_GET(I3C_SER_CODERR, error) + 1;
+		if (code == I3C_ERROR_M1 && !(evr & I3C_EVR_RXTGTENDF))
+			stm32_i3c_master_send_stop(ddata);
+		ret = -EPROTO;
+	}
+
+	/* In case error, the message ID stored in status register is the faulty one */
+	if (ret)
+		for (i = id; i < xfer->ncmds; i++)
+			xfer->cmds[i].error = code;
+
+skip_error:
+	if (!ret)
+		dev_dbg(ddata->dev, "Transfer %s (%u/%u) success\n",
+			(evr & I3C_EVR_RXTGTENDF) ? "prematurely ended" : "ended",
+			id + 1, xfer->ncmds);
+	else
+		dev_dbg(ddata->dev, "Transfer end (%u/%u) %s [%pe]\n", id + 1, xfer->ncmds,
+			code == I3C_ERROR_M2 ? "nacked" : "error", ERR_PTR(ret));
+
+	xfer->ret = ret;
+	complete(&xfer->comp);
+
+	stm32_i3c_master_fifo_flush(ddata);
+
+	xfer = list_first_entry_or_null(&ddata->xferqueue.list, struct stm32_i3c_xfer, node);
+	if (xfer)
+		list_del_init(&xfer->node);
+
+	ddata->xferqueue.cur_xfer = xfer;
+	stm32_i3c_master_start_xfer_locked(ddata);
+}
+
+static void stm32_i3c_master_queue_xfer(struct stm32_i3c_ddata *ddata,
+					struct stm32_i3c_xfer *xfer)
+{
+	unsigned long flags;
+
+	init_completion(&xfer->comp);
+	spin_lock_irqsave(&ddata->xferqueue.lock, flags);
+	if (ddata->xferqueue.cur_xfer) {
+		dev_dbg(ddata->dev, "%s: added to xferqueue\n", __func__);
+		list_add_tail(&xfer->node, &ddata->xferqueue.list);
+	} else {
+		dev_dbg(ddata->dev, "%s: started\n", __func__);
+		ddata->xferqueue.cur_xfer = xfer;
+		stm32_i3c_master_start_xfer_locked(ddata);
+	}
+	spin_unlock_irqrestore(&ddata->xferqueue.lock, flags);
+}
+
+static struct stm32_i3c_xfer *stm32_i3c_master_alloc_xfer(struct stm32_i3c_ddata *ddata,
+							  unsigned int ncmds)
+{
+	struct stm32_i3c_xfer *xfer;
+
+	xfer = kzalloc(struct_size(xfer, cmds, ncmds), GFP_KERNEL);
+	if (!xfer)
+		return NULL;
+
+	INIT_LIST_HEAD(&xfer->node);
+	xfer->ncmds = ncmds;
+	xfer->ret = -ETIMEDOUT;
+
+	return xfer;
+}
+
+static void stm32_i3c_master_free_xfer(struct stm32_i3c_xfer *xfer)
+{
+	kfree(xfer);
+}
+
+static void stm32_i3c_master_handle_ibi(struct stm32_i3c_ddata *ddata)
+{
+	struct stm32_i3c_dev_ibi_data *ibi_data;
+	struct stm32_i3c_dev_data *i3cdev_data;
+	struct i3c_dev_desc *i3cdev;
+	u8 addr, len;
+	u32 rmr;
+	u8 *p;
+
+	rmr = readl_relaxed(ddata->base + STM32_I3C_RMR);
+	addr = FIELD_GET(I3C_RMR_RADD, rmr);
+	len = FIELD_GET(I3C_RMR_IBIRDCNT, rmr);
+
+	dev_dbg(ddata->dev, "%s: %#x\n", __func__, rmr);
+
+	i3cdev = addr_to_i3c_dev_desc(&ddata->master, addr);
+	if (!i3cdev) {
+		dev_err(ddata->dev, "IBI received but unknown target %#x\n", addr);
+		return;
+	}
+
+	i3cdev_data = i3c_dev_get_master_data(i3cdev);
+	if (!i3cdev_data) {
+		dev_err(ddata->dev, "IBI received but unattached target %#x\n", addr);
+		return;
+	}
+
+	ibi_data = i3cdev_data->ibi_data;
+	if (!ibi_data) {
+		dev_err(ddata->dev, "IBI received but IBI disabled for target %#x\n", addr);
+		return;
+	}
+
+	if (len > ibi_data->max_len) {
+		dev_err(ddata->dev, "IBI payload size too big (%dB > %dB)\n",
+			len, ibi_data->max_len);
+		return;
+	}
+
+	ibi_data->ibi_slot = i3c_generic_ibi_get_free_slot(ibi_data->ibi_pool);
+	if (!ibi_data->ibi_slot) {
+		dev_err(ddata->dev, "No free slot for target %#x IBI\n", addr);
+		return;
+	}
+
+	ibi_data->ibi_slot->len = len;
+	p = ibi_data->ibi_slot->data;
+
+	while (len--)
+		*p++ = readb_relaxed(ddata->base + STM32_I3C_IBIDR);
+}
+
+static irqreturn_t stm32_i3c_irq_handler(int irq, void *dev_id)
+{
+	struct stm32_i3c_ddata *ddata = dev_id;
+	struct stm32_i3c_xfer *cur_xfer = ddata->xferqueue.cur_xfer;
+	u32 evr, ier;
+
+	/* IRQF_ONESHOT ensures the IRQ line kept disabled until this handler has been run */
+
+	evr = readl_relaxed(ddata->base + STM32_I3C_EVR);
+	ier = readl_relaxed(ddata->base + STM32_I3C_IER);
+	dev_dbg(ddata->dev, "%s events: %#x/%#x\n", __func__, evr, ier);
+
+	evr &= ier;
+	if (!evr)
+		return IRQ_NONE;
+
+	/* I3C specific requests */
+	if (evr & I3C_EVR_IBIF) {
+		dev_dbg(ddata->dev, "IBI request\n");
+		stm32_i3c_master_handle_ibi(ddata);
+	}
+
+	if (evr & I3C_EVR_HJF) {
+		/* TODO Hot-Join request */
+		dev_info(ddata->dev, "Hot-Join request\n");
+	}
+
+	if (evr & I3C_EVR_CRF) {
+		/* TODO Controller-role request */
+		dev_err(ddata->dev, "Controller-role request not supported yet\n");
+	}
+
+	/* FIFOs management */
+	if (evr & I3C_EVR_CFNFF) {
+		dev_dbg(ddata->dev, "Data word is to be written to C-FIFO? %s\n",
+			cur_xfer ? "yes" : "no");
+		/* TODO C-FIFO write request */
+		if (cur_xfer) {
+			cur_xfer->cur_cmd++;
+			writel_relaxed(cur_xfer->cmds[cur_xfer->cur_cmd].msg_cr,
+				       ddata->base + STM32_I3C_CR);
+		}
+	}
+
+	if (evr & I3C_EVR_RXFNEF) {
+		dev_dbg(ddata->dev, "Data byte/word is to be read from RX-FIFO\n");
+		stm32_i3c_master_read_rxfifo(ddata);
+	}
+
+	if (evr & I3C_EVR_TXFNFF) {
+		dev_dbg(ddata->dev, "Data byte/word is to be written to TX-FIFO\n");
+		stm32_i3c_master_write_txfifo(ddata);
+	}
+
+	if (evr & I3C_EVR_SFNEF) {
+		/* Never set if I3C_CFGR.SMODE = 0 */
+		stm32_i3c_master_read_status(ddata);
+	}
+
+	/* End of frame management */
+	if (evr & I3C_EVR_FCF) {
+		dev_dbg(ddata->dev, "Frame complete\n");
+		spin_lock(&ddata->xferqueue.lock);
+		stm32_i3c_master_end_xfer_locked(ddata, evr);
+		spin_unlock(&ddata->xferqueue.lock);
+	}
+
+	if (evr & I3C_EVR_RXTGTENDF) {
+		dev_dbg(ddata->dev, "Target has prematurely ended a read transfer\n");
+		spin_lock(&ddata->xferqueue.lock);
+		stm32_i3c_master_end_xfer_locked(ddata, evr);
+		spin_unlock(&ddata->xferqueue.lock);
+	}
+
+	if (evr & I3C_EVR_ERRF) {
+		dev_dbg(ddata->dev, "Error\n");
+		if (cur_xfer) {
+			spin_lock(&ddata->xferqueue.lock);
+			stm32_i3c_master_end_xfer_locked(ddata, evr);
+			spin_unlock(&ddata->xferqueue.lock);
+		} else {
+			stm32_i3c_master_read_error(ddata);
+		}
+	}
+
+	writel_relaxed(evr, ddata->base + STM32_I3C_CEVR);
+
+	return IRQ_HANDLED;
+}
+
+static int stm32_i3c_pure_timing_cfg(struct i3c_master_controller *m, unsigned long i3cclk_rate)
+{
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct i3c_bus *bus = i3c_master_get_bus(m);
+	unsigned long duty_cycle, ti3cclk_ps, ti3c_pp_min_ps, ti3cl_od_min_ps;
+	u32 sclhi3c, scllpp, scllod, sdahold, free, aval;
+	u32 timingr0, timingr1;
+
+	dev_dbg(ddata->dev, "mode=%u, i3c freq=%lu\n", bus->mode, bus->scl_rate.i3c);
+
+	duty_cycle = 50; //TODO SCL duty-cycle in I3C ?
+	ti3cclk_ps = DIV_ROUND_CLOSEST(PICO, i3cclk_rate);
+	ti3c_pp_min_ps = DIV_ROUND_CLOSEST(PICO, bus->scl_rate.i3c);
+	ti3cl_od_min_ps = I3C_BUS_TLOW_OD_MIN_NS * 1000;
+
+	/* I3C Open Drain SCL Clock High Period */
+	sclhi3c = DIV_ROUND_CLOSEST(ti3c_pp_min_ps * duty_cycle / 100, ti3cclk_ps) - 1;
+
+	/* I3C Push Pull SCL Clock Low Period */
+	scllpp = DIV_ROUND_CLOSEST(ti3c_pp_min_ps - (sclhi3c + 1) * ti3cclk_ps, ti3cclk_ps) - 1;
+
+	/* I3C Open Drain SCL Clock Low Period */
+	if (ti3c_pp_min_ps < ti3cl_od_min_ps)
+		scllod = DIV_ROUND_UP(ti3cl_od_min_ps, ti3cclk_ps) - 1;
+	else
+		scllod = scllpp;
+
+	/* Check that I3C Open Drain SCL Clock Low period is greater than Rise Time of SDA */
+	if ((scllod + 1) * ti3cclk_ps < (ddata->sda_rise_ns * 1000))
+		scllod = DIV_ROUND_UP((ddata->sda_rise_ns * 1000), ti3cclk_ps) - 1;
+
+	/*
+	 * By default, SDA generation is delayed from one I3CCLK half-period.
+	 * For high I3CCLK frequencies, one I3CCLK period delay can be added by setting the bit
+	 * I3C_TIMINGR1.SDA_HD.
+	 * tHD_PPmin > 3ns <=> (0.5 * tI3CCLK) > 3ns <=> tI3CCLK > 2 * 3ns
+	 */
+	if (ti3cclk_ps > 2 * I3C_BUS_HD_PP_MIN_PS)
+		sdahold = 0;
+	else
+		sdahold = 1;
+
+	/* Bus free condition : tCAS = [(FREE[6:0] + 1) x 2 - (0.5 + SDA_HD)] x tI3CCLK */
+	free = DIV_ROUND_CLOSEST(I3C_BUS_CAS_MIN_PS + (ddata->sda_rise_ns * 1000), 2 * ti3cclk_ps);
+
+	/* Bus available condition : tAVAL = 1us, 1us = 1000000ps */
+	aval = DIV_ROUND_CLOSEST(1000000, ti3cclk_ps) - 1;
+
+	timingr0 = FIELD_PREP(I3C_TIMINGR0_SCLL_PP, scllpp) |
+		   FIELD_PREP(I3C_TIMINGR0_SCLH_I3C, sclhi3c) |
+		   FIELD_PREP(I3C_TIMINGR0_SCLL_OD, scllod);
+		   /* I2C SCL Clock High Period (SCLH_I3C) not used when I3C_BUS_MODE_PURE */
+
+	if (scllpp != FIELD_GET(I3C_TIMINGR0_SCLL_PP, timingr0) ||
+	    sclhi3c != FIELD_GET(I3C_TIMINGR0_SCLH_I3C, timingr0) ||
+	    scllod != FIELD_GET(I3C_TIMINGR0_SCLL_OD, timingr0)) {
+		dev_err(ddata->dev, "I3C input clock too high (%luHz)\n", i3cclk_rate);
+		return -EINVAL;
+	}
+
+	timingr1 = FIELD_PREP(I3C_TIMINGR1_AVAL, aval) |
+		   FIELD_PREP(I3C_TIMINGR1_FREE, free) |
+		   FIELD_PREP(I3C_TIMINGR1_SDA_HD, sdahold);
+
+	writel_relaxed(timingr0, ddata->base + STM32_I3C_TIMINGR0);
+	writel_relaxed(timingr1, ddata->base + STM32_I3C_TIMINGR1);
+
+	dev_dbg(ddata->dev, "%s: timingr0=%#x timingr1=%#x timingr2=0\n",
+		__func__, timingr0, timingr1);
+
+	//TODO: to remove when mature
+	pr_debug("\t32ns < tSCLH_I3C=%ldns < 41ns,\n\t32ns < tSCLL_PP=%ldns,\n",
+		 (sclhi3c + 1) * ti3cclk_ps / 1000, (scllpp + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t200 < tSCLL_OD=%ldns,\n", (scllod + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t78.125ns < tSCLH_I3C+tSCLL_PP=%ldns,\n\t200ns < tSCLH_I3C+tSCLL_OD=%ldns\n",
+		 (sclhi3c + 1) * ti3cclk_ps / 1000 + (scllpp + 1) * ti3cclk_ps / 1000,
+		 (sclhi3c + 1) * ti3cclk_ps / 1000 + (scllod + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t38.4ns < tCAS=%ldns < 1us(ENTAS0)<100us(ENTAS1)<2ms(ENTAS2)<50ms(ENTAS3)\n",
+		 (free + 1) * 2 * ti3cclk_ps / 1000);
+	pr_debug("\t1us=aval=%ldps\n", (aval + 1) * ti3cclk_ps);
+
+	return 0;
+}
+
+static int stm32_i3c_mixed_timing_cfg(struct i3c_master_controller *m, unsigned long i3cclk_rate)
+{
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct i3c_bus *bus = i3c_master_get_bus(m);
+	unsigned long ti3cclk_ps, ti3c_pp_min_ps, ti2c_od_min_ps, /*tfmp_od_min_ps, */tfm_od_min_ps;
+	u32 duty_cycle, sclhi3c, scllpp, scllod, sclhi2c, sdahold, free, aval;
+	u32 timingr0, timingr1, timingr2;
+
+	dev_dbg(ddata->dev, "mode=%u, i3c freq=%lu, i2c freq=%lu\n",
+		bus->mode, bus->scl_rate.i3c, bus->scl_rate.i2c);
+
+	duty_cycle = 40; //TODO SCL duty-cycle in I2C ?
+	ti3cclk_ps = DIV_ROUND_CLOSEST(PICO, i3cclk_rate);
+	ti3c_pp_min_ps = DIV_ROUND_CLOSEST(PICO, bus->scl_rate.i3c);
+	ti2c_od_min_ps = DIV_ROUND_CLOSEST(PICO, bus->scl_rate.i2c);
+	/*tfmp_od_min_ps = DIV_ROUND_CLOSEST(PICO, I3C_BUS_I2C_FM_PLUS_SCL_RATE);*/
+	tfm_od_min_ps = DIV_ROUND_CLOSEST(PICO, I3C_BUS_I2C_FM_SCL_RATE);
+
+	/* I3C Open Drain SCL Clock High Period */
+	sclhi3c = DIV_ROUND_CLOSEST(ti3c_pp_min_ps * duty_cycle / 100, ti3cclk_ps) - 1;
+
+	//TODO Check if next is needed
+	if (((sclhi3c + 1) * ti3cclk_ps) > I3C_BUS_THIGH_PP_MAX_PS) {
+		dev_warn(&m->dev, "%s: tSCLH_I3C=%lds > %uns\n", __func__,
+			 (sclhi3c + 1) * ti3cclk_ps / 1000, I3C_BUS_THIGH_PP_MAX_PS / 1000);
+		sclhi3c = DIV_ROUND_CLOSEST(I3C_BUS_TDIGH_MIN_PS, ti3cclk_ps) - 1;
+	}
+
+	/* I3C/I2C Push Pull SCL Clock Low Period */
+	scllpp = DIV_ROUND_CLOSEST(ti3c_pp_min_ps - (sclhi3c + 1) * ti3cclk_ps, ti3cclk_ps) - 1;
+
+	/* I3C/I2C Open Drain SCL Clock Low Period */
+	scllod = DIV_ROUND_CLOSEST(ti2c_od_min_ps * (100 - duty_cycle) / 100, ti3cclk_ps) - 1;
+	if (ti2c_od_min_ps < tfm_od_min_ps) { /* Fast Mode Plus */
+		if ((scllod + 1) * ti3cclk_ps < I3C_BUS_I2C_FMP_TLOW_MIN_PS)
+			scllod = DIV_ROUND_UP(I3C_BUS_I2C_FMP_TLOW_MIN_PS, ti3cclk_ps) - 1;
+	} else { /* Fast Mode */
+		if ((scllod + 1) * ti3cclk_ps < I3C_BUS_I2C_FM_TLOW_MIN_PS)
+			scllod = DIV_ROUND_UP(I3C_BUS_I2C_FM_TLOW_MIN_PS, ti3cclk_ps) - 1;
+	}
+
+	/* I2C Open Drain SCL Clock High Period */
+	sclhi2c = DIV_ROUND_CLOSEST(ti2c_od_min_ps - (scllod + 1) * ti3cclk_ps, ti3cclk_ps) - 1;
+
+	/*
+	 * By default, SDA generation is delayed from one I3CCLK half-period.
+	 * For high I3CCLK frequencies, one I3CCLK period delay can be added by setting the bit
+	 * I3C_TIMINGR1.SDA_HD.
+	 * tHD_PPmin > 3ns <=> (0.5 * tI3CCLK) > 3ns <=> tI3CCLK > 2 * 3ns
+	 */
+	if (ti3cclk_ps > 2 * I3C_BUS_HD_PP_MIN_PS)
+		sdahold = 0;
+	else
+		sdahold = 1;
+
+	/*
+	 * Bus free condition : tBUF = ((FREE[6:0] + 1) x 2 - (0,5 + SDA_HD)) x tI3CCLK
+	 *			tBUF = I2C tLOW = (scllod + 1) * ti3cclk_ps
+	 */
+	free = DIV_ROUND_CLOSEST((scllod + 1) * ti3cclk_ps + (ddata->sda_rise_ns * 1000),
+				 2 * ti3cclk_ps);
+
+	/* Bus available condition : tAVAL = 1us, 1us = 1000000ps */
+	aval = DIV_ROUND_CLOSEST(1000000, ti3cclk_ps) - 1;
+
+	timingr0 = FIELD_PREP(I3C_TIMINGR0_SCLL_PP, scllpp) |
+		   FIELD_PREP(I3C_TIMINGR0_SCLH_I3C, sclhi3c) |
+		   FIELD_PREP(I3C_TIMINGR0_SCLL_OD, scllod) |
+		   FIELD_PREP(I3C_TIMINGR0_SCLH_I2C, sclhi2c);
+
+	if (scllpp != FIELD_GET(I3C_TIMINGR0_SCLL_PP, timingr0) ||
+	    sclhi3c != FIELD_GET(I3C_TIMINGR0_SCLH_I3C, timingr0) ||
+	    scllod != FIELD_GET(I3C_TIMINGR0_SCLL_OD, timingr0) ||
+	    sclhi2c != FIELD_GET(I3C_TIMINGR0_SCLH_I2C, timingr0)) {
+		dev_err(ddata->dev, "I3C input clock too high (%luHz)\n", i3cclk_rate);
+		return -EINVAL;
+	}
+
+	timingr1 = FIELD_PREP(I3C_TIMINGR1_AVAL, aval) |
+		   FIELD_PREP(I3C_TIMINGR1_FREE, free) |
+		   FIELD_PREP(I3C_TIMINGR1_SDA_HD, sdahold);
+
+	timingr2 = FIELD_PREP(I3C_TIMINGR2_STALL, ((aval + 1) * 100)) |
+		   //I3C_TIMINGR2_STALLA |
+		   //I3C_TIMINGR2_STALLC |
+		   I3C_TIMINGR2_STALLD;// |
+		   //I3C_TIMINGR2_STALLT;
+
+	writel_relaxed(timingr0, ddata->base + STM32_I3C_TIMINGR0);
+	writel_relaxed(timingr1, ddata->base + STM32_I3C_TIMINGR1);
+	writel_relaxed(timingr2, ddata->base + STM32_I3C_TIMINGR2);
+
+	dev_dbg(ddata->dev, "%s: timingr0=%#x timingr1=%#x timingr2=%#x\n",
+		__func__, timingr0, timingr1, timingr2);
+
+	//TODO: to remove when mature
+	pr_debug("\ttSCLH_I3C=%ldns < 41ns,\n\t32ns < tSCLL_PP=%ldns,\n",
+		 (sclhi3c + 1) * ti3cclk_ps / 1000, (scllpp + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t1300ns(FM)/500ns(FM+) < tSCLL_OD=%ldns,\n",
+		 (scllod + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t600ns(FM)/260ns(FM+) < tSCLH_I2C=%ldns,\n",
+		 (sclhi2c + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t78.125ns < tSCLH_I3C+tSCLL_PP=%ldns,\n\t200ns < tSCLH_I3C+tSCLL_OD=%ldns\n",
+		 (sclhi3c + 1) * ti3cclk_ps / 1000 + (scllpp + 1) * ti3cclk_ps / 1000,
+		 (sclhi3c + 1) * ti3cclk_ps / 1000 + (scllod + 1) * ti3cclk_ps / 1000);
+	pr_debug("\t1300ns(FM)/500ns(FM+) < tBUF=%ldns\n", (free + 1) * 2 * ti3cclk_ps / 1000);
+	pr_debug("\t1us=aval=%ldps\n", (aval + 1) * ti3cclk_ps);
+
+	return 0;
+}
+
+static int stm32_i3c_master_bus_init(struct i3c_master_controller *m)
+{
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct i3c_bus *bus = i3c_master_get_bus(m);
+	struct i3c_device_info info = {};
+	unsigned long ti3cclk_rate;
+	struct pinctrl *pctl;
+	u32 cfgr, ier;
+	int ret;
+
+	ti3cclk_rate = clk_get_rate(ddata->clk);
+	if (!ti3cclk_rate)
+		return -EINVAL;
+
+	/* Set I3C as controller */
+	cfgr = I3C_CFGR_CRINIT;
+
+	/* Enable/disable SDA high keeper */
+	cfgr |= I3C_CFGR_HKSDAEN; //TODO: when using it?
+
+	/* TODO Configure I3C bus timings
+	 * I3C_TIMINGR0, I3C_TIMINGR1, I3C_TIMINGR2
+	 * RM0457 77.6.2 I3C clocks and requirements
+	 * frequency of i3cclk kernel clock > 2x frequency of the SCL clock
+	 * sustaining fscl_max = 12.9Mhz means fi3cclk > 25.8Mhz
+	 * Configure SCL Clock timings (I3C_TIMINGR0 register)
+	 * I3C_TIMINGR0.SCLH_I3C shall be > 32ns (OD & PP) and < 41ns (OD)
+	 * I3C_TIMINGR0.SCLH_I2C shall be > 600ns (FM), > 260ns (FM+)
+	 * I3C_TIMINGR0.SCLL_OD shall be > 200ns if I3C, > 500ns if I2C (FM+), > 1300ns if I2C (FM)
+	 * I3C_TIMINGR0.SCLL_PP shall be > (80ns - SCLH_I3C)
+	 */
+	switch (bus->mode) {
+	case I3C_BUS_MODE_PURE:
+		ret = stm32_i3c_pure_timing_cfg(m, ti3cclk_rate);
+		break;
+	case I3C_BUS_MODE_MIXED_FAST:
+	case I3C_BUS_MODE_MIXED_LIMITED:
+	case I3C_BUS_MODE_MIXED_SLOW:
+		ret = stm32_i3c_mixed_timing_cfg(m, ti3cclk_rate);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	// TODO: could be removed if *_timing_cfg return void
+	if (ret)
+		return ret;
+
+	/* Set own dynamic address */
+	ret = i3c_master_get_free_addr(m, 0);
+	if (ret < 0)
+		return ret;
+
+	info.dyn_addr = ret;
+
+	writel_relaxed(FIELD_PREP(I3C_DEVR0_DA, info.dyn_addr), ddata->base + STM32_I3C_DEVR0);
+
+	ret = i3c_master_set_info(&ddata->master, &info);
+	if (ret)
+		return ret;
+
+	/* TODO
+	 * Configure controller features in I3C_CFGR
+	 * DMA for FIFOs: TXDMAEN, CDMAEN, RXDMAEN, SDMAEN
+	 * TX/RX-FIFO threshold: TXTHRES, RXTHRES
+	 * TX-FIFO and C-FIFO preload: TMODE
+	 * S-FIFO: SMODE
+	 * Hot-join Ack: HJACK
+	 * HDR exit pattern: EXITPTRN
+	 * HDR reset pattern: RSTPTRN
+	 * arbitrable header: NOARBH
+	 */
+	//cfgr |= I3C_CFGR_TMODE;
+	//cfgr |= I3C_CFGR_SMODE;
+
+	ier = I3C_IER_CTRL_IE; /* FCIE, TXTGTENDIE, ERRIE, IBIIE, CRIE, HJIE */
+	ier |= I3C_IER_FIFO_IE; /* CFNFIE, SFNEIE, TXFNFIE, RXFNEIE */
+	if (!(cfgr & I3C_CFGR_SMODE))
+		ier &= ~I3C_IER_SFNEIE;
+	writel_relaxed(ier, ddata->base + STM32_I3C_IER);
+
+	/* Move from I3C state = DISABLED to I3C state = IDLE, safely with init pin configuration */
+	writel_relaxed(cfgr | I3C_CFGR_EN, ddata->base + STM32_I3C_CFGR);
+
+	/* Anticipate default pin configuration needed for transfers done in i3c_master_bus_init */
+	pctl = devm_pinctrl_get_select_default(ddata->dev);
+	if (IS_ERR(pctl))
+		dev_warn(ddata->dev, "Pins are not well configured\n");
+
+	return 0;
+}
+
+static void stm32_i3c_master_bus_cleanup(struct i3c_master_controller *m)
+{
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+
+	/* TODO: all the possible target requests must be disable using DISEC CCC */
+
+	/* Move to I3C state = DISABLED */
+	writel_relaxed(0, ddata->base + STM32_I3C_CFGR);
+
+	/* Disable interrupts */
+	writel_relaxed(0, ddata->base + STM32_I3C_IER);
+}
+
+static int stm32_i3c_master_get_slot(struct stm32_i3c_ddata *ddata)
+{
+	u32 slot;
+
+	slot = find_first_zero_bit(ddata->slots, ddata->nslots);
+	if (slot >= ddata->nslots)
+		return -ENXIO;
+	__set_bit(slot, ddata->slots);
+
+	return slot;
+}
+
+static void stm32_i3c_master_put_slot(struct stm32_i3c_ddata *ddata, u32 slot)
+{
+	__clear_bit(slot, ddata->slots);
+}
+
+static int stm32_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct stm32_i3c_dev_data *dev_data;
+	int slot;
+
+	slot = stm32_i3c_master_get_slot(ddata);
+	if (slot < 0)
+		return slot;
+
+	dev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);
+	if (!dev_data) {
+		stm32_i3c_master_put_slot(ddata, slot);
+		return -ENOMEM;
+	}
+
+	dev_dbg(ddata->dev, "%s: idx=%d addr=%#x bcr=%#x\n",
+		__func__, slot, dev->info.dyn_addr ? : dev->info.static_addr, dev->info.bcr);
+
+	dev_data->dev_idx = slot;
+
+	i3c_dev_set_master_data(dev, dev_data);
+
+	return 0;
+}
+
+static int stm32_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev, u8 old_dyn_addr)
+{
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+
+	dev_dbg(ddata->dev, "%s: idx=%d addr=%#x\n",
+		__func__, dev_data->dev_idx, dev->info.dyn_addr ? : dev->info.static_addr);
+
+	writel_relaxed(FIELD_PREP(I3C_DEVR_DA, dev->info.dyn_addr ? : dev->info.static_addr),
+		       ddata->base + STM32_I3C_DEVR(dev_data->dev_idx));
+
+	return 0;
+}
+
+static void stm32_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)
+{
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+
+	dev_dbg(ddata->dev, "%s: idx=%d addr=%#x\n",
+		__func__, dev_data->dev_idx, dev->info.dyn_addr ? : dev->info.static_addr);
+
+	writel_relaxed(FIELD_PREP(I3C_DEVR_DA, 0),
+		       ddata->base + STM32_I3C_DEVR(dev_data->dev_idx));
+	stm32_i3c_master_put_slot(ddata, dev_data->dev_idx);
+
+	kfree(dev_data);
+}
+
+static int stm32_i3c_master_do_daa_locked(struct stm32_i3c_ddata *ddata,
+					  u8 *addrs, unsigned int *count)
+{
+	struct stm32_i3c_xfer *xfer;
+	struct stm32_i3c_cmd *_cmd;
+	u32 ier, cfgr, evr, sr, ser;
+	unsigned int _count = 0;
+	int ret;
+
+	xfer = stm32_i3c_master_alloc_xfer(ddata, 1);
+	if (!xfer) {
+		ret = -ENOMEM;
+		goto abort_daa;
+	}
+
+	_cmd = xfer->cmds;
+	_cmd->msg_cr = FIELD_PREP(I3C_CR_MTYPE, MTYPE_I3C_CCC_CMD) |
+		       FIELD_PREP(I3C_CR_CCC, I3C_CCC_ENTDAA) |
+		       I3C_CR_MEND;
+
+	/* Disable interrupts: ENTDAA is managed in polling mode */
+	ier = readl_relaxed(ddata->base + STM32_I3C_IER);
+	writel_relaxed(0, ddata->base + STM32_I3C_IER);
+
+	/* Set 1-word/4-bytes RX FIFO threshold */
+	cfgr = readl_relaxed(ddata->base + STM32_I3C_CFGR);
+	writel_relaxed(cfgr | I3C_CFGR_RXTHRES, ddata->base + STM32_I3C_CFGR);
+
+	stm32_i3c_master_set_arb_header(ddata, true);
+	stm32_i3c_master_set_fifo_preload(ddata, false);
+
+	/* Send ENTDAA CCC */
+	ret = readl_relaxed_poll_timeout(ddata->base + STM32_I3C_EVR, evr,
+					 evr & I3C_EVR_CFEF, 0, 1000);
+	if (ret) {
+		dev_err(ddata->dev, "C-FIFO not empty: evr=%#x\n", evr);
+		goto abort_restore_regs;
+	}
+	writel_relaxed(_cmd->msg_cr, ddata->base + STM32_I3C_CR);
+
+	/*
+	 * While DAA process is not over, read 48-bit provisional ID + BCR and DCR,
+	 * then write addr 1 byte.
+	 */
+	evr = readl_relaxed(ddata->base + STM32_I3C_EVR);
+	while (!(evr & I3C_EVR_FCF)) {
+		u64 payload;
+
+		/* A specific HW mechanism set TXFNFF=1 when RX-FIFO is empty & ENTDAA */
+		ret = readl_relaxed_poll_timeout(ddata->base + STM32_I3C_EVR, evr,
+						 evr & (I3C_EVR_TXFNFF | I3C_EVR_FCF), 0, 1000000);
+		if (ret || (evr & I3C_EVR_FCF)) {
+			if (ret)
+				dev_dbg(ddata->dev,
+					"RX-FIFO empty: evr=%#x, count=%d\n", evr, _count);
+			goto exit_daa;
+		}
+
+		/* 48-bit Provisioned ID followed by BCR and DCR (using Big Endian bit order) */
+		payload = readl_relaxed(ddata->base + STM32_I3C_RDWR);
+		payload |= ((u64)readl_relaxed(ddata->base + STM32_I3C_RDWR)) << 32;
+		dev_dbg(ddata->dev, "target#%d payload=%#llx", _count, be64_to_cpu(payload));
+
+		/* Assign address to winning target */
+		ret = readl_relaxed_poll_timeout(ddata->base + STM32_I3C_EVR, evr,
+						 evr & (I3C_EVR_TXFNFF | I3C_EVR_FCF), 0, 1000000);
+		if (ret || (evr & I3C_EVR_FCF)) {
+			if (ret)
+				dev_dbg(ddata->dev,
+					"TX-FIFO full: evr=%#x count=%d\n", evr, _count);
+			goto exit_daa;
+		}
+
+		/*
+		 * HW automatically performs a single-retry if addr is NACK-ed for the first time,
+		 * or automatically emits a stop if addr is NACK-ed for the second time.
+		 */
+		writeb_relaxed(addrs[_count], ddata->base + STM32_I3C_TDR);
+		if (!stm32_i3c_master_read_error(ddata))
+			_count++;
+	}
+exit_daa:
+	/* Wait on DAA end until timeout */
+	ret = readl_relaxed_poll_timeout(ddata->base + STM32_I3C_EVR, evr,
+					 evr & (I3C_EVR_FCF | I3C_EVR_ERRF), 0, 1000000);
+
+	sr = stm32_i3c_master_read_status(ddata);
+	ser = stm32_i3c_master_read_error(ddata);
+
+	if (ret) {
+		u32 code = FIELD_GET(I3C_SER_CODERR, ser) + 1;
+
+		if (code == I3C_ERROR_M1)
+			stm32_i3c_master_send_stop(ddata);
+		if (code == I3C_ERROR_M2)
+			ret = 0;
+	}
+
+	/* Clear flags */
+	writel_relaxed(evr & ier, ddata->base + STM32_I3C_CEVR);
+
+	stm32_i3c_master_fifo_flush(ddata);
+
+	if (_count != FIELD_GET(I3C_SR_XDCNT, sr)) {
+		dev_err(ddata->dev, "%lu target(s) assigned but %u counted\n",
+			FIELD_GET(I3C_SR_XDCNT, sr), _count);
+		ret = -EINVAL;
+	} else {
+		dev_dbg(ddata->dev, "%lu target(s) assigned\n", FIELD_GET(I3C_SR_XDCNT, sr));
+	}
+
+abort_restore_regs:
+	writel_relaxed(cfgr, ddata->base + STM32_I3C_CFGR);
+	writel_relaxed(ier, ddata->base + STM32_I3C_IER);
+abort_daa:
+	*count = _count;
+
+	return ret;
+}
+
+static int stm32_i3c_master_do_daa(struct i3c_master_controller *m)
+{
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	unsigned int count = 0, nb_assigned = 0, i = 0;
+	unsigned long flags;
+	u8 next_addr = 0, *addrs;
+	int slot, ret;
+
+	addrs = kcalloc(ddata->nslots, sizeof(*addrs), GFP_KERNEL);
+	if (!addrs)
+		return -ENOMEM;
+
+	for (;;) {
+		ret = stm32_i3c_master_get_slot(ddata);
+		if (ret < 0)
+			break;
+		slot = ret;
+
+		ret = i3c_master_get_free_addr(m, next_addr + 1);
+		if (ret < 0)
+			break;
+		next_addr = ret;
+
+		dev_dbg(&m->dev, "next_addr = 0x%02x, DAA using #%d", next_addr, slot);
+
+		addrs[count++] = next_addr;
+	}
+
+	if (!count) {
+		dev_err(&m->dev, "No free slot for device\n");
+		kfree(addrs);
+		return -ENOSPC;
+	}
+
+	spin_lock_irqsave(&ddata->xferqueue.lock, flags);
+	ret = stm32_i3c_master_do_daa_locked(ddata, addrs, &nb_assigned);
+	spin_unlock_irqrestore(&ddata->xferqueue.lock, flags);
+	if (ret)
+		goto abort_free;
+
+	/* Register devices to the core */
+	for (i = 0; i < nb_assigned; i++) {
+		stm32_i3c_master_put_slot(ddata, i);
+		/* PID, BCR and DCR will be retrieved with i3c_master_retrieve_dev_info() */
+		ret = i3c_master_add_i3c_dev_locked(m, addrs[i]);
+		if (ret)
+			break;
+	}
+
+abort_free:
+	for (; i < count; i++)
+		stm32_i3c_master_put_slot(ddata, i);
+	kfree(addrs);
+
+	return ret;
+}
+
+/* Optional stm32_i3c_master_supports_ccc_cmd */
+static bool stm32_i3c_master_supports_ccc_cmd(struct i3c_master_controller *m,
+					      const struct i3c_ccc_cmd *cmd)
+{
+	/*
+	 * TODO fwk limitation or HW limitation?
+	 *  @ndests: number of destinations. Should always be one for broadcast commands
+	 */
+	if (cmd->ndests > 1)
+		return false;
+
+	switch (cmd->id) {
+	case I3C_CCC_ENEC(true):			//0x00
+	case I3C_CCC_DISEC(true):			//0x01
+	case I3C_CCC_ENTAS(0, true):			//0x02
+	case I3C_CCC_ENTAS(1, true):			//0x03
+	case I3C_CCC_ENTAS(2, true):			//0x04
+	case I3C_CCC_ENTAS(3, true):			//0x05
+	case I3C_CCC_RSTDAA(true):			//0x06
+	case I3C_CCC_ENTDAA:				//0x07
+	case I3C_CCC_DEFSLVS:				//0x08 (DEFTGTS)
+	case I3C_CCC_SETMWL(true):			//0x09
+	case I3C_CCC_SETMRL(true):			//0x0A
+	case I3C_CCC_ENTTM:				//0x0B
+	case I3C_CCC_SETXTIME(true):			//0x28
+	//case I3C_CCC_RSTACT(true):			//0x2A
+
+	case I3C_CCC_ENEC(false):			//0x80
+	case I3C_CCC_DISEC(false):			//0x81
+	case I3C_CCC_ENTAS(0, false):			//0x82
+	case I3C_CCC_ENTAS(1, false):			//0x83
+	case I3C_CCC_ENTAS(2, false):			//0x84
+	case I3C_CCC_ENTAS(3, false):			//0x85
+	case I3C_CCC_SETDASA:				//0x87
+	case I3C_CCC_SETNEWDA:				//0x88
+	case I3C_CCC_SETMWL(false):			//0x89
+	case I3C_CCC_SETMRL(false):			//0x8A
+	case I3C_CCC_GETMWL:				//0x8B
+	case I3C_CCC_GETMRL:				//0x8C
+	case I3C_CCC_GETPID:				//0x8D
+	case I3C_CCC_GETBCR:				//0x8E
+	case I3C_CCC_GETDCR:				//0x8F
+	case I3C_CCC_GETSTATUS:				//0x90
+	case I3C_CCC_GETACCMST: //GETACCCR		//0x91
+	case I3C_CCC_GETMXDS:				//0x94
+	case I3C_CCC_GETHDRCAP: //GETCAPS		//0x95
+	case I3C_CCC_SETXTIME(false):			//0x98
+	case I3C_CCC_GETXTIME:				//0x99
+	//case I3C_CCC_RSTACT(false):			//0x9A
+		return true;
+	default:
+	//case I3C_CCC_ENTHDR(x) not supported		//0x20+(x)
+	//case I3C_CCC_SETAASA				//0x29
+	//case I3C_CCC_DEFGRPA(true)			//0x2B
+	//case I3C_CCC_RSTGRPA(true)			//0x2C
+	//case I3C_CCC_VENDOR(id, true) not supported	//0x61
+
+	//case I3C_CCC_RSTDAA(false) not supported	//0x86
+	//case I3C_CCC_SETBRGTGT not supported		//0x93
+	//case I3C_CCC_D2DXFER?				//0x97
+	//case I3C_CCC_DEFGRPA/SETGRPA(false)?		//0x9B
+	//case I3C_CCC_RSTGRPA(false)?			//0x9C
+	//case I3C_CCC_VENDOR(id, false) not supported	//0xE0
+		return false;
+	}
+}
+
+static int stm32_i3c_master_send_bdcast_ccc_cmd(struct stm32_i3c_ddata *ddata,
+						struct i3c_ccc_cmd *cmd)
+{
+	struct stm32_i3c_xfer *xfer;
+	struct stm32_i3c_cmd *_cmd;
+	int ret;
+
+	xfer = stm32_i3c_master_alloc_xfer(ddata, 1);
+	if (!xfer)
+		return -ENOMEM;
+
+	_cmd = xfer->cmds;
+	_cmd->msg_cr = FIELD_PREP(I3C_CR_MTYPE, MTYPE_I3C_CCC_CMD) |
+		       FIELD_PREP(I3C_CR_CCC, cmd->id) | I3C_CR_MEND;
+	_cmd->data_len = cmd->dests[0].payload.len;
+	_cmd->data.tx = cmd->dests[0].payload.data;
+	_cmd->msg_cr |= FIELD_PREP(I3C_CR_DCNT, _cmd->data_len);
+	xfer->cur_cmd = -1;
+
+	stm32_i3c_master_queue_xfer(ddata, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))
+		stm32_i3c_master_dequeue_xfer(ddata, xfer);
+
+	ret = xfer->ret;
+	cmd->err = xfer->cmds->error;
+
+	stm32_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int stm32_i3c_master_send_direct_ccc_cmd(struct stm32_i3c_ddata *ddata,
+						struct i3c_ccc_cmd *cmd)
+{
+	struct stm32_i3c_xfer *xfer;
+	struct stm32_i3c_cmd *_cmd;
+	int ret;
+
+	xfer = stm32_i3c_master_alloc_xfer(ddata, 2);
+	if (!xfer)
+		return -ENOMEM;
+
+	/* Broadcasted message */
+	_cmd = &xfer->cmds[0];
+	_cmd->msg_cr = FIELD_PREP(I3C_CR_MTYPE, MTYPE_I3C_CCC_CMD) |
+		       FIELD_PREP(I3C_CR_CCC, cmd->id);
+	_cmd->data_len = 1;
+
+	/* Directed message */
+	_cmd = &xfer->cmds[1];
+	_cmd->msg_cr |= FIELD_PREP(I3C_CR_ADD, cmd->dests[0].addr);
+	_cmd->data_len = cmd->dests[0].payload.len;
+	_cmd->msg_cr |= FIELD_PREP(I3C_CR_DCNT, _cmd->data_len);
+	if (cmd->rnw) {
+		_cmd->msg_cr |= I3C_CR_RNW;
+		_cmd->data.rx = cmd->dests[0].payload.data;
+	} else {
+		_cmd->data.tx = cmd->dests[0].payload.data;
+	}
+	_cmd->msg_cr |= I3C_CR_MEND;
+	xfer->cur_cmd = -1;
+
+	stm32_i3c_master_queue_xfer(ddata, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))
+		stm32_i3c_master_dequeue_xfer(ddata, xfer);
+
+	ret = xfer->ret;
+	cmd->err = xfer->cmds[1].error;
+
+	stm32_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+/* TODO: to remove when mature */
+static char *ccc_to_string(u8 id)
+{
+	switch (id) {
+	case I3C_CCC_ENEC(true):
+	case I3C_CCC_ENEC(false):
+		return "ENEC";
+	case I3C_CCC_DISEC(true):
+	case I3C_CCC_DISEC(false):
+		return "DISEC";
+	case I3C_CCC_ENTAS(0, true):
+	case I3C_CCC_ENTAS(1, true):
+	case I3C_CCC_ENTAS(2, true):
+	case I3C_CCC_ENTAS(3, true):
+	case I3C_CCC_ENTAS(0, false):
+	case I3C_CCC_ENTAS(1, false):
+	case I3C_CCC_ENTAS(2, false):
+	case I3C_CCC_ENTAS(3, false):
+		return "ENTAS";
+	case I3C_CCC_RSTDAA(true):
+	case I3C_CCC_RSTDAA(false):
+		return "RSTDAA";
+	case I3C_CCC_SETMWL(true):
+	case I3C_CCC_SETMWL(false):
+		return "SETMWL";
+	case I3C_CCC_SETMRL(true):
+	case I3C_CCC_SETMRL(false):
+		return "SETMRL";
+	case I3C_CCC_SETXTIME(true):
+	case I3C_CCC_SETXTIME(false):
+		return "SETXTIME";
+	//case I3C_CCC_VENDOR(id, broadcast):
+	case I3C_CCC_ENTDAA:
+		return "ENTDAA";
+	case I3C_CCC_DEFSLVS:
+		return "DEFSLVS";
+	case I3C_CCC_ENTTM:
+		return "ENTTM";
+	case I3C_CCC_SETDASA:
+		return "SETDASA";
+	case I3C_CCC_SETNEWDA:
+		return "SETNEWDA";
+	case I3C_CCC_GETMWL:
+		return "GETMWL";
+	case I3C_CCC_GETMRL:
+		return "GETMRL";
+	case I3C_CCC_GETPID:
+		return "GETPID";
+	case I3C_CCC_GETBCR:
+		return "GETBCR";
+	case I3C_CCC_GETDCR:
+		return "GETDCR";
+	case I3C_CCC_GETSTATUS:
+		return "GETSTATUS";
+	case I3C_CCC_GETACCMST:
+		return "GETACCMST";
+	case I3C_CCC_GETMXDS:
+		return "GETMXDS";
+	case I3C_CCC_GETHDRCAP:
+		return "GETHDRCAP";
+	case I3C_CCC_GETXTIME:
+		return "GETXTIME";
+	default:
+		return "not supported";
+	}
+}
+
+static int stm32_i3c_master_send_ccc_cmd(struct i3c_master_controller *m, struct i3c_ccc_cmd *cmd)
+{
+	/*
+	 * cmd->id & I3C_CCC_DIRECT => CCC[7] = 1 => I3C SDR direct CCC command
+	 * !(cmd->id & I3C_CCC_DIRECT) => CCC[7] = 0 => I3C SDR broadcast CCC command
+	 */
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	bool direct = cmd->id & I3C_CCC_DIRECT;
+
+	dev_dbg(&m->dev, "%s: id=%s(%#x), rnw=%u, ndest=%u, dest.addr=%#x, dest.payload.len=%d\n",
+		__func__, ccc_to_string(cmd->id), cmd->id, cmd->rnw, cmd->ndests,
+		cmd->dests[0].addr, cmd->dests[0].payload.len);
+
+	if (direct)
+		return stm32_i3c_master_send_direct_ccc_cmd(ddata, cmd);
+	else
+		return stm32_i3c_master_send_bdcast_ccc_cmd(ddata, cmd);
+}
+
+static int stm32_i3c_master_priv_xfers(struct i3c_dev_desc *dev, struct i3c_priv_xfer *xfers,
+				       int nxfers)
+{
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct stm32_i3c_xfer *xfer;
+	u8 addr;
+	int i, ret = 0;
+
+	xfer = stm32_i3c_master_alloc_xfer(ddata, nxfers);
+	if (!xfer)
+		return -ENOMEM;
+
+	addr = FIELD_GET(I3C_DEVR_DA,
+			 readl_relaxed(ddata->base + STM32_I3C_DEVR(dev_data->dev_idx)));
+
+	for (i = 0; i < nxfers; i++) {
+		struct stm32_i3c_cmd *_cmd = &xfer->cmds[i];
+
+		_cmd->msg_cr = FIELD_PREP(I3C_CR_MTYPE, MTYPE_I3C_PRIV_MSG);
+		_cmd->msg_cr |= FIELD_PREP(I3C_CR_ADD, addr);
+		_cmd->msg_cr |= FIELD_PREP(I3C_CR_DCNT, xfers[i].len);
+		_cmd->data_len = xfers[i].len;
+
+		if (xfers[i].rnw) {
+			_cmd->msg_cr |= I3C_CR_RNW;
+			_cmd->data.rx = xfers[i].data.in;
+		} else {
+			_cmd->data.tx = xfers[i].data.out;
+		}
+
+		if (i + 1 == nxfers) /* Last */
+			_cmd->msg_cr |= I3C_CR_MEND;
+	}
+	xfer->cur_cmd = -1;
+
+	stm32_i3c_master_queue_xfer(ddata, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))
+		stm32_i3c_master_dequeue_xfer(ddata, xfer);
+
+	ret = xfer->ret;
+
+	stm32_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int stm32_i3c_master_i2c_xfers(struct i2c_dev_desc *dev, const struct i2c_msg *xfers,
+				      int nxfers)
+{
+	struct i3c_master_controller *m = i2c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	struct stm32_i3c_xfer *xfer;
+	int i, ret = 0;
+
+	dev_dbg(&m->dev, "%s: nxfers=%i, rnw=%u, dest_addr=%x, dest_payload_len=%d\n",
+		__func__, nxfers, xfers[0].flags & I2C_M_RD, xfers[0].addr, xfers[0].len);
+
+	xfer = stm32_i3c_master_alloc_xfer(ddata, nxfers);
+	if (!xfer)
+		return -ENOMEM;
+
+	for (i = 0; i < nxfers; i++) {
+		struct stm32_i3c_cmd *_cmd = &xfer->cmds[i];
+
+		_cmd->msg_cr = FIELD_PREP(I3C_CR_MTYPE, MTYPE_I2C_MSG);
+		_cmd->msg_cr |= FIELD_PREP(I3C_CR_ADD, xfers[i].addr);
+		_cmd->msg_cr |= FIELD_PREP(I3C_CR_DCNT, xfers[i].len);
+		_cmd->data_len = xfers[i].len;
+
+		if (xfers[i].flags & I2C_M_RD) {
+			_cmd->msg_cr |= I3C_CR_RNW;
+			_cmd->data.rx = xfers[i].buf;
+
+		} else {
+			_cmd->data.tx = xfers[i].buf;
+		}
+
+		if (i + 1 == nxfers) /* Last */
+			_cmd->msg_cr |= I3C_CR_MEND;
+	}
+	xfer->cur_cmd = -1;
+
+	stm32_i3c_master_queue_xfer(ddata, xfer);
+	if (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))
+		stm32_i3c_master_dequeue_xfer(ddata, xfer);
+
+	ret = xfer->ret;
+
+	stm32_i3c_master_free_xfer(xfer);
+
+	return ret;
+}
+
+static int stm32_i3c_master_request_ibi(struct i3c_dev_desc *dev, const struct i3c_ibi_setup *req)
+{
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(i3c_dev_get_master(dev));
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct i3c_generic_ibi_pool *ibi_pool;
+	struct stm32_i3c_dev_ibi_data *dev_ibi;
+
+	dev_dbg(ddata->dev, "%s: idx=%d addr=%#x, ibi_len=%d\n", __func__, dev_data->dev_idx,
+		dev->info.dyn_addr ? : dev->info.static_addr, dev->ibi->max_payload_len);
+
+	if (dev->ibi->max_payload_len > I3C_IBI_MAX_PAYLOAD_LEN) {
+		dev_err(ddata->dev, "IBI payload size too big (%dB > %dB)\n",
+			dev->ibi->max_payload_len, I3C_IBI_MAX_PAYLOAD_LEN);
+		return -EMSGSIZE;
+	}
+
+	dev_ibi = kmalloc(sizeof(*dev_ibi), GFP_KERNEL);
+	if (!dev_ibi)
+		return -ENOMEM;
+
+	ibi_pool = i3c_generic_ibi_alloc_pool(dev, req);
+	if (IS_ERR(ibi_pool)) {
+		kfree(dev_ibi);
+		return PTR_ERR(ibi_pool);
+	}
+
+	dev_ibi->ibi_pool = ibi_pool;
+	dev_ibi->max_len = req->max_payload_len;
+	dev_data->ibi_data = dev_ibi;
+
+	return 0;
+}
+
+static void stm32_i3c_master_free_ibi(struct i3c_dev_desc *dev)
+{
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct stm32_i3c_dev_ibi_data *dev_ibi = dev_data->ibi_data;
+
+	dev_data->ibi_data = NULL;
+	i3c_generic_ibi_free_pool(dev_ibi->ibi_pool);
+	kfree(dev_ibi);
+}
+
+static int stm32_i3c_master_enable_ibi(struct i3c_dev_desc *dev)
+{
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	u32 devr;
+
+	devr = readl_relaxed(ddata->base + STM32_I3C_DEVR(dev_data->dev_idx));
+	devr |= I3C_DEVR_IBIDEN | I3C_DEVR_IBIACK;
+	writel_relaxed(devr, ddata->base + STM32_I3C_DEVR(dev_data->dev_idx));
+
+	return i3c_master_enec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);
+}
+
+static int stm32_i3c_master_disable_ibi(struct i3c_dev_desc *dev)
+{
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct i3c_master_controller *m = i3c_dev_get_master(dev);
+	struct stm32_i3c_ddata *ddata = to_stm32_i3c_ddata(m);
+	u32 devr;
+
+	devr = readl_relaxed(ddata->base + STM32_I3C_DEVR(dev_data->dev_idx));
+	devr &= ~(I3C_DEVR_IBIDEN | I3C_DEVR_IBIACK);
+	writel_relaxed(devr, ddata->base + STM32_I3C_DEVR(dev_data->dev_idx));
+
+	return i3c_master_disec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);
+}
+
+static void stm32_i3c_master_recycle_ibi_slot(struct i3c_dev_desc *dev, struct i3c_ibi_slot *slot)
+{
+	struct stm32_i3c_dev_data *dev_data = i3c_dev_get_master_data(dev);
+	struct stm32_i3c_dev_ibi_data *dev_ibi = dev_data->ibi_data;
+
+	i3c_generic_ibi_recycle_slot(dev_ibi->ibi_pool, slot);
+}
+
+static const struct i3c_master_controller_ops stm32_i3c_master_ops = {
+	.bus_init = stm32_i3c_master_bus_init,			/* Mandatory */
+	.bus_cleanup = stm32_i3c_master_bus_cleanup,
+	.attach_i3c_dev = stm32_i3c_master_attach_i3c_dev,
+	.reattach_i3c_dev = stm32_i3c_master_reattach_i3c_dev,
+	.detach_i3c_dev = stm32_i3c_master_detach_i3c_dev,
+	.do_daa = stm32_i3c_master_do_daa,			/* Required */
+	.supports_ccc_cmd = stm32_i3c_master_supports_ccc_cmd,
+	.send_ccc_cmd = stm32_i3c_master_send_ccc_cmd,		/* Required */
+	.priv_xfers = stm32_i3c_master_priv_xfers,		/* Required */
+	.i2c_xfers = stm32_i3c_master_i2c_xfers,		/* Required */
+	.request_ibi = stm32_i3c_master_request_ibi,		/* Optional but... */
+	.free_ibi = stm32_i3c_master_free_ibi,			/* Required if .request_ibi */
+	.enable_ibi = stm32_i3c_master_enable_ibi,		/* Required if .request_ibi */
+	.disable_ibi = stm32_i3c_master_disable_ibi,		/* Required if .request_ibi */
+	.recycle_ibi_slot = stm32_i3c_master_recycle_ibi_slot,	/* Required if .request_ibi */
+};
+
+static int stm32_i3c_probe(struct platform_device *pdev)
+{
+	struct stm32_i3c_ddata *ddata;
+	struct reset_control *rst;
+	u32 hwcfgr, verr;
+	int irq, ret;
+
+	ddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);
+	if (!ddata)
+		return -ENOMEM;
+
+	ddata->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ddata->base))
+		return PTR_ERR(ddata->base);
+
+	ddata->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ddata->clk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(ddata->clk), "Failed to get clk\n");
+
+	rst = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(rst))
+		return dev_err_probe(&pdev->dev, PTR_ERR(rst), "Failed to get reset\n");
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = clk_prepare_enable(ddata->clk);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "Failed to enable clk\n");
+
+	reset_control_reset(rst);
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL, stm32_i3c_irq_handler, IRQF_ONESHOT,
+					dev_name(&pdev->dev), ddata);
+	if (ret) {
+		dev_err_probe(&pdev->dev, ret, "Failed to request IRQ\n");
+		goto err_clk_disable;
+	}
+
+	ret = device_property_read_u32(&pdev->dev, "i3c-sda-rising-time-ns", &ddata->sda_rise_ns);
+	if (ret)
+		ddata->sda_rise_ns = 0;
+
+	hwcfgr = readl_relaxed(ddata->base + STM32_I3C_HWCFGR);
+
+	/* Number of I3C targets whose IBI/controller-role can be managed by this I3C controller */
+	ddata->nslots = FIELD_GET(I3C_HWCFGR_NBT, hwcfgr);
+	ddata->slots = devm_bitmap_zalloc(&pdev->dev, ddata->nslots, GFP_KERNEL);
+	if (!ddata->slots) {
+		ret = -ENOMEM;
+		goto err_clk_disable;
+	}
+
+	ddata->dev = &pdev->dev;
+	platform_set_drvdata(pdev, ddata);
+
+	ret = i3c_master_register(&ddata->master, ddata->dev, &stm32_i3c_master_ops, false);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register I3C master: %d\n", ret);
+		goto err_clk_disable;
+	}
+
+	verr = readl_relaxed(ddata->base + STM32_I3C_VERR);
+
+	dev_info(ddata->dev, "STM32 I3C registered rev:%lu.%lu\n",
+		 FIELD_GET(I3C_VERR_MAJREV, verr), FIELD_GET(I3C_VERR_MINREV, verr));
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(ddata->clk);
+
+	return ret;
+}
+
+static int stm32_i3c_remove(struct platform_device *pdev)
+{
+	struct stm32_i3c_ddata *ddata = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = i3c_master_unregister(&ddata->master);
+	if (ret)
+		return ret;
+
+	clk_disable_unprepare(ddata->clk);
+
+	return 0;
+}
+
+static const struct of_device_id stm32_i3c_of_match[] = {
+	{ .compatible = "st,stm32-i3c" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, stm32_i3c_of_match);
+
+static struct platform_driver stm32_i3c_driver = {
+	.probe = stm32_i3c_probe,
+	.remove = stm32_i3c_remove,
+	.driver = {
+		.name = "stm32-i3c",
+		.of_match_table = stm32_i3c_of_match,
+	},
+};
+module_platform_driver(stm32_i3c_driver);
+
+MODULE_DESCRIPTION("STM32 I3C controller driver");
+MODULE_AUTHOR("Amelie Delaunay <amelie.delaunay@foss.st.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 791612ca6..0feb3426f 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -1046,6 +1046,31 @@ config STM32_DFSDM_ADC
 	  This driver can also be built as a module.  If so, the module
 	  will be called stm32-dfsdm-adc.
 
+config STM32_MDF_CORE
+	tristate "STMicroelectronics STM32 MDF core"
+	depends on (ARCH_STM32 && OF) || COMPILE_TEST
+	select REGMAP
+	select REGMAP_MMIO
+	help
+	  Select this option to enable the driver for STMicroelectronics
+	  STM32 Multi-function Digital Filter for sigma delta converter.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called stm32-mdf-core.
+
+config STM32_MDF_ADC
+	tristate "STMicroelectronics STM32 MDF adc"
+	depends on (ARCH_STM32 && OF) || COMPILE_TEST
+	select STM32_MDF_CORE
+	select IIO_BUFFER
+	select IIO_BUFFER_HW_CONSUMER
+	help
+	  Select this option to support ADCSigma delta modulator for
+	  STMicroelectronics STM32 Multi-function digital filter.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called stm32-mdf-adc.
+
 config STMPE_ADC
 	tristate "STMicroelectronics STMPE ADC driver"
 	depends on OF && MFD_STMPE
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index 46caba7a0..f46b3baec 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -95,6 +95,9 @@ obj-$(CONFIG_STM32_ADC_CORE) += stm32-adc-core.o
 obj-$(CONFIG_STM32_ADC) += stm32-adc.o
 obj-$(CONFIG_STM32_DFSDM_CORE) += stm32-dfsdm-core.o
 obj-$(CONFIG_STM32_DFSDM_ADC) += stm32-dfsdm-adc.o
+obj-$(CONFIG_STM32_MDF_CORE) += stm32-mdf-core.o
+obj-$(CONFIG_STM32_MDF_CORE) += stm32-mdf-serial.o
+obj-$(CONFIG_STM32_MDF_ADC) += stm32-mdf-adc.o
 obj-$(CONFIG_STMPE_ADC) += stmpe-adc.o
 obj-$(CONFIG_TI_ADC081C) += ti-adc081c.o
 obj-$(CONFIG_TI_ADC0832) += ti-adc0832.o
diff --git a/drivers/iio/adc/sd_adc_modulator.c b/drivers/iio/adc/sd_adc_modulator.c
index 327cc2097..ceb150296 100644
--- a/drivers/iio/adc/sd_adc_modulator.c
+++ b/drivers/iio/adc/sd_adc_modulator.c
@@ -9,10 +9,8 @@
 #include <linux/iio/iio.h>
 #include <linux/iio/triggered_buffer.h>
 #include <linux/module.h>
-#include <linux/mod_devicetable.h>
-#include <linux/platform_device.h>
-
-static const struct iio_info iio_sd_mod_iio_info;
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
 
 static const struct iio_chan_spec iio_sd_mod_ch = {
 	.type = IIO_VOLTAGE,
@@ -22,34 +20,99 @@ static const struct iio_chan_spec iio_sd_mod_ch = {
 		.realbits = 1,
 		.shift = 0,
 	},
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),
+};
+
+static const struct iio_chan_spec iio_sd_mod_ch_ads = {
+	.type = IIO_VOLTAGE,
+	.indexed = 1,
+	.scan_type = {
+		.sign = 'u',
+		.realbits = 1,
+		.shift = 0,
+	},
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),
+	.differential = 1,
+};
+
+struct iio_sd_mod_priv {
+	int vref_mv;
+};
+
+static const struct of_device_id sd_adc_of_match[] = {
+	{ .compatible = "sd-modulator", .data = &iio_sd_mod_ch },
+	{ .compatible = "ads1201", .data = &iio_sd_mod_ch_ads },
+	{ }
+};
+
+static int iio_sd_mod_read_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan, int *val,
+			       int *val2, long mask)
+{
+	struct iio_sd_mod_priv *priv = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		*val = priv->vref_mv;
+		*val2 = chan->scan_type.realbits;
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info iio_sd_mod_iio_info = {
+	.read_raw = iio_sd_mod_read_raw,
 };
 
 static int iio_sd_mod_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct iio_sd_mod_priv *priv;
+	struct regulator *vref;
 	struct iio_dev *iio;
+	int ret;
 
-	iio = devm_iio_device_alloc(dev, 0);
+	iio = devm_iio_device_alloc(dev, sizeof(*priv));
 	if (!iio)
 		return -ENOMEM;
 
+	iio->channels = (const struct iio_chan_spec *)
+			of_match_device(sd_adc_of_match, &pdev->dev)->data;
+
+	priv = iio_priv(iio);
+
+	iio->dev.parent = dev;
+	iio->dev.of_node = dev->of_node;
 	iio->name = dev_name(dev);
 	iio->info = &iio_sd_mod_iio_info;
 	iio->modes = INDIO_BUFFER_HARDWARE;
-
 	iio->num_channels = 1;
-	iio->channels = &iio_sd_mod_ch;
 
-	platform_set_drvdata(pdev, iio);
+	vref = devm_regulator_get_optional(dev, "vref");
+	if (IS_ERR(vref)) {
+		ret = PTR_ERR(vref);
+		if (ret != -ENODEV) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "vref get failed, %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!IS_ERR(vref)) {
+		ret = regulator_get_voltage(vref);
+		if (ret < 0) {
+			dev_err(dev, "vref get failed, %d\n", ret);
+			return ret;
+		}
+
+		priv->vref_mv = ret / 1000;
+		dev_dbg(dev, "vref+=%dmV\n", priv->vref_mv);
+	}
 
 	return devm_iio_device_register(&pdev->dev, iio);
 }
 
-static const struct of_device_id sd_adc_of_match[] = {
-	{ .compatible = "sd-modulator" },
-	{ .compatible = "ads1201" },
-	{ }
-};
 MODULE_DEVICE_TABLE(of, sd_adc_of_match);
 
 static struct platform_driver iio_sd_mod_adc = {
diff --git a/drivers/iio/adc/stm32-adc-core.c b/drivers/iio/adc/stm32-adc-core.c
index dee47b899..0aee68062 100644
--- a/drivers/iio/adc/stm32-adc-core.c
+++ b/drivers/iio/adc/stm32-adc-core.c
@@ -18,10 +18,12 @@
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
+#include <linux/units.h>
 
 #include "stm32-adc-core.h"
 
@@ -46,6 +48,8 @@
  * @ovr_msk:    array of ovr (overrun flag) masks in csr for adc1..n
  * @ier:	interrupt enable register offset for each adc
  * @eocie_msk:	end of conversion interrupt enable mask in @ier
+ * @presc_msk:	prescaler mask in ccr
+ * @presc_shift: prescaler bit shift in ccr
  */
 struct stm32_adc_common_regs {
 	u32 csr;
@@ -54,6 +58,8 @@ struct stm32_adc_common_regs {
 	u32 ovr_msk[STM32_ADC_MAX_ADCS];
 	u32 ier;
 	u32 eocie_msk;
+	u32 presc_msk;
+	u32 presc_shift;
 };
 
 struct stm32_adc_priv;
@@ -62,6 +68,8 @@ struct stm32_adc_priv;
  * struct stm32_adc_priv_cfg - stm32 core compatible configuration data
  * @regs:	common registers for all instances
  * @clk_sel:	clock selection routine
+ * @presc:	clock prescaler array
+ * @num_presc:	number of clock prescalers in presc array
  * @max_clk_rate_hz: maximum analog clock rate (Hz, from datasheet)
  * @ipid:	adc identification number
  * @has_syscfg: SYSCFG capability flags
@@ -71,6 +79,8 @@ struct stm32_adc_priv;
 struct stm32_adc_priv_cfg {
 	const struct stm32_adc_common_regs *regs;
 	int (*clk_sel)(struct platform_device *, struct stm32_adc_priv *);
+	int *presc;
+	int num_presc;
 	u32 max_clk_rate_hz;
 	u32 ipid;
 	unsigned int has_syscfg;
@@ -80,8 +90,11 @@ struct stm32_adc_priv_cfg {
 
 /**
  * struct stm32_adc_priv - stm32 ADC core private data
+ * @dev:		pointer to adc device
  * @irq:		irq(s) for ADC block
+ * @irq_map:		mapping between children and parents irqs
  * @nb_adc_max:		actual maximum number of instance per ADC block
+ * @nb_irqs:		number of IRQs in the ADC block
  * @domain:		irq domain reference
  * @aclk:		clock reference for the analog circuitry
  * @bclk:		bus clock common for all ADCs, depends on part used
@@ -98,8 +111,11 @@ struct stm32_adc_priv_cfg {
  * @syscfg:		reference to syscon, system control registers
  */
 struct stm32_adc_priv {
+	struct device			*dev;
 	int				irq[STM32_ADC_MAX_ADCS];
+	int				irq_map[STM32_ADC_MAX_ADCS];
 	unsigned int			nb_adc_max;
+	unsigned int			nb_irqs;
 	struct irq_domain		*domain;
 	struct clk			*aclk;
 	struct clk			*bclk;
@@ -124,20 +140,23 @@ static struct stm32_adc_priv *to_stm32_adc_priv(struct stm32_adc_common *com)
 /* STM32F4 ADC internal common clock prescaler division ratios */
 static int stm32f4_pclk_div[] = {2, 4, 6, 8};
 
+/* STM32MP25 ADC internal common clock prescaler division ratios */
+static int stm32mp25_presc_div[] = {1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256};
+
 /**
- * stm32f4_adc_clk_sel() - Select stm32f4 ADC common clock prescaler
+ * stm32_adc_clk_sel() - Select stm32f4 ADC common clock prescaler
  * @pdev: platform device
  * @priv: stm32 ADC core private data
  * Select clock prescaler used for analog conversions, before using ADC.
  */
-static int stm32f4_adc_clk_sel(struct platform_device *pdev,
-			       struct stm32_adc_priv *priv)
+static int stm32_adc_clk_sel(struct platform_device *pdev,
+			     struct stm32_adc_priv *priv)
 {
 	unsigned long rate;
 	u32 val;
 	int i;
 
-	/* stm32f4 has one clk input for analog (mandatory), enforce it here */
+	/* stm32f4/mp25 has one clk input for analog (mandatory), enforce it here */
 	if (!priv->aclk) {
 		dev_err(&pdev->dev, "No 'adc' clock found\n");
 		return -ENOENT;
@@ -149,20 +168,20 @@ static int stm32f4_adc_clk_sel(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(stm32f4_pclk_div); i++) {
-		if ((rate / stm32f4_pclk_div[i]) <= priv->max_clk_rate)
+	for (i = 0; i < priv->cfg->num_presc; i++) {
+		if ((rate / priv->cfg->presc[i]) <= priv->max_clk_rate)
 			break;
 	}
-	if (i >= ARRAY_SIZE(stm32f4_pclk_div)) {
+	if (i >= priv->cfg->num_presc) {
 		dev_err(&pdev->dev, "adc clk selection failed\n");
 		return -EINVAL;
 	}
 
-	priv->common.rate = rate / stm32f4_pclk_div[i];
-	val = readl_relaxed(priv->common.base + STM32F4_ADC_CCR);
-	val &= ~STM32F4_ADC_ADCPRE_MASK;
-	val |= i << STM32F4_ADC_ADCPRE_SHIFT;
-	writel_relaxed(val, priv->common.base + STM32F4_ADC_CCR);
+	priv->common.rate = rate / priv->cfg->presc[i];
+	val = readl_relaxed(priv->common.base + priv->cfg->regs->ccr);
+	val &= ~priv->cfg->regs->presc_msk;
+	val |= i << priv->cfg->regs->presc_shift;
+	writel_relaxed(val, priv->common.base + priv->cfg->regs->ccr);
 
 	dev_dbg(&pdev->dev, "Using analog clock source at %ld kHz\n",
 		priv->common.rate / 1000);
@@ -306,20 +325,44 @@ static int stm32h7_adc_clk_sel(struct platform_device *pdev,
 static const struct stm32_adc_common_regs stm32f4_adc_common_regs = {
 	.csr = STM32F4_ADC_CSR,
 	.ccr = STM32F4_ADC_CCR,
-	.eoc_msk = { STM32F4_EOC1, STM32F4_EOC2, STM32F4_EOC3},
-	.ovr_msk = { STM32F4_OVR1, STM32F4_OVR2, STM32F4_OVR3},
+	.eoc_msk = { STM32F4_EOC1, STM32F4_EOC2, STM32F4_EOC3 },
+	.ovr_msk = { STM32F4_OVR1, STM32F4_OVR2, STM32F4_OVR3 },
 	.ier = STM32F4_ADC_CR1,
 	.eocie_msk = STM32F4_EOCIE,
+	.presc_msk = STM32F4_ADC_ADCPRE_MASK,
+	.presc_shift = STM32F4_ADC_ADCPRE_SHIFT,
 };
 
 /* STM32H7 common registers definitions */
 static const struct stm32_adc_common_regs stm32h7_adc_common_regs = {
+	.csr = STM32H7_ADC_CSR,
+	.ccr = STM32H7_ADC_CCR,
+	.eoc_msk = { STM32H7_EOC_MST, STM32H7_EOC_SLV },
+	.ovr_msk = { STM32H7_OVR_MST, STM32H7_OVR_SLV },
+	.ier = STM32H7_ADC_IER,
+	.eocie_msk = STM32H7_EOCIE,
+};
+
+/* STM32MP13 common registers definitions */
+static const struct stm32_adc_common_regs stm32mp13_adc_common_regs = {
+	.csr = STM32H7_ADC_CSR,
+	.ccr = STM32H7_ADC_CCR,
+	.eoc_msk = { STM32H7_EOC_MST },
+	.ovr_msk = { STM32H7_OVR_MST },
+	.ier = STM32H7_ADC_IER,
+	.eocie_msk = STM32H7_EOCIE,
+};
+
+/* STM32MP25 common registers definitions */
+static const struct stm32_adc_common_regs stm32mp25_adc_common_regs = {
 	.csr = STM32H7_ADC_CSR,
 	.ccr = STM32H7_ADC_CCR,
 	.eoc_msk = { STM32H7_EOC_MST, STM32H7_EOC_SLV},
 	.ovr_msk = { STM32H7_OVR_MST, STM32H7_OVR_SLV},
 	.ier = STM32H7_ADC_IER,
 	.eocie_msk = STM32H7_EOCIE,
+	.presc_msk = STM32H7_PRESC_MASK,
+	.presc_shift = STM32H7_PRESC_SHIFT,
 };
 
 static const unsigned int stm32_adc_offset[STM32_ADC_MAX_ADCS] = {
@@ -369,24 +412,84 @@ static void stm32_adc_irq_handler(struct irq_desc *desc)
 	chained_irq_exit(chip, desc);
 };
 
-static int stm32_adc_domain_map(struct irq_domain *d, unsigned int irq,
-				irq_hw_number_t hwirq)
+static void stm32_adc_core_mask(struct irq_data *d)
 {
-	irq_set_chip_data(irq, d->host_data);
-	irq_set_chip_and_handler(irq, &dummy_irq_chip, handle_level_irq);
+	if (d->parent_data->chip)
+		irq_chip_mask_parent(d);
+}
 
-	return 0;
+static void stm32_adc_core_unmask(struct irq_data *d)
+{
+	if (d->parent_data->chip)
+		irq_chip_unmask_parent(d);
 }
 
-static void stm32_adc_domain_unmap(struct irq_domain *d, unsigned int irq)
+struct irq_chip stm32_irq_chip = {
+	.name		= "stm32_adc_core",
+	.irq_mask	= stm32_adc_core_mask,
+	.irq_unmask	= stm32_adc_core_unmask,
+	.flags		= IRQCHIP_SKIP_SET_WAKE,
+};
+
+static int stm32_adc_core_domain_alloc(struct irq_domain *dm, unsigned int virq,
+				       unsigned int nr_irqs, void *data)
+{
+	irq_hw_number_t hwirq;
+	struct stm32_adc_priv *priv = dm->host_data;
+	struct irq_fwspec *fwspec = data;
+	struct irq_data *irq_data, *irq_data_p;
+	u32 irq_parent;
+	int ret, virq_p;
+
+	if (!dm->parent) {
+		dev_err(priv->dev, "parent domain missing\n");
+		return -EINVAL;
+	}
+
+	hwirq = fwspec->param[0];
+	dev_dbg(priv->dev, "adc child hw irq %lu virt irq %u\n", hwirq, virq);
+
+	ret = irq_domain_set_hwirq_and_chip(dm, virq, hwirq, &stm32_irq_chip, NULL);
+	if (ret < 0)
+		return ret;
+
+	irq_set_chip_data(virq, dm->host_data);
+	irq_set_chip_and_handler(virq, &stm32_irq_chip, handle_level_irq);
+
+	irq_parent = priv->irq_map[hwirq];
+
+	virq_p = irq_find_mapping(dm->parent, irq_parent);
+	dev_dbg(priv->dev, "adc core hw irq %d, virt irq %d\n", irq_parent, virq_p);
+
+	irq_data = irq_get_irq_data(virq);
+	irq_data_p = irq_get_irq_data(virq_p);
+
+	if (!irq_data || !irq_data_p)
+		return -EINVAL;
+
+	irq_data->parent_data = irq_data_p;
+
+	return 0;
+};
+
+static void stm32_adc_core_domain_free(struct irq_domain *domain, unsigned int virq,
+				       unsigned int nr_irqs)
 {
-	irq_set_chip_and_handler(irq, NULL, NULL);
-	irq_set_chip_data(irq, NULL);
+	struct irq_data *irq_data;
+
+	irq_set_chip_and_handler(virq, NULL, NULL);
+	irq_set_chip_data(virq, NULL);
+
+	irq_data = irq_get_irq_data(virq);
+	if (!irq_data)
+		return;
+
+	irq_data->parent_data = NULL;
 }
 
 static const struct irq_domain_ops stm32_adc_domain_ops = {
-	.map = stm32_adc_domain_map,
-	.unmap  = stm32_adc_domain_unmap,
+	.alloc	= stm32_adc_core_domain_alloc,
+	.free = stm32_adc_core_domain_free,
 	.xlate = irq_domain_xlate_onecell,
 };
 
@@ -394,28 +497,57 @@ static int stm32_adc_irq_probe(struct platform_device *pdev,
 			       struct stm32_adc_priv *priv)
 {
 	struct device_node *np = pdev->dev.of_node;
-	unsigned int i;
+	struct irq_domain *parent_domain;
+	struct irq_data *irqd;
+	int i;
 
 	/*
 	 * Interrupt(s) must be provided, depending on the compatible:
 	 * - stm32f4/h7 shares a common interrupt line.
 	 * - stm32mp1, has one line per ADC
+	 * - stm32mp25, has a dual ADC12 and standalone ADC3. Each ADC has an IRQ
+	 *   (two for ADC12, one for ADC3)
+	 *
+	 * Assume that children hw irqs are numbered from 0 to nb_adc_max-1
+	 * By default hw parent and children irqs are mapped by pair
+	 * If the ADC shares a common irq, all children irqs are mapped on the
+	 * same parent, yet.
 	 */
-	for (i = 0; i < priv->cfg->num_irqs; i++) {
+	for (i = 0; i < priv->nb_irqs; i++) {
 		priv->irq[i] = platform_get_irq(pdev, i);
 		if (priv->irq[i] < 0)
 			return priv->irq[i];
+		irqd = irq_get_irq_data(priv->irq[i]);
+		if (!irqd)
+			return -EINVAL;
+		priv->irq_map[i] = irqd->hwirq;
+	}
+
+	if (priv->nb_irqs != priv->nb_adc_max) {
+		if (priv->cfg->num_irqs == 1) {
+			for (i = 1; i < priv->nb_adc_max; i++)
+				priv->irq_map[i] = priv->irq_map[0];
+		} else {
+			dev_err(&pdev->dev, "Could not map child irqs on parent irqs\n");
+			return -EINVAL;
+		}
 	}
 
-	priv->domain = irq_domain_add_simple(np, STM32_ADC_MAX_ADCS, 0,
-					     &stm32_adc_domain_ops,
-					     priv);
+	parent_domain = irq_find_host(of_irq_find_parent(np));
+	if (!parent_domain) {
+		dev_err(&pdev->dev, "GIC interrupt-parent not found\n");
+		return -EINVAL;
+	}
+
+	priv->domain = irq_domain_add_hierarchy(parent_domain, 0, priv->nb_adc_max,
+						np, &stm32_adc_domain_ops, priv);
+
 	if (!priv->domain) {
 		dev_err(&pdev->dev, "Failed to add irq domain\n");
 		return -ENOMEM;
 	}
 
-	for (i = 0; i < priv->cfg->num_irqs; i++) {
+	for (i = 0; i < priv->nb_irqs; i++) {
 		irq_set_chained_handler(priv->irq[i], stm32_adc_irq_handler);
 		irq_set_handler_data(priv->irq[i], priv);
 	}
@@ -433,8 +565,10 @@ static void stm32_adc_irq_remove(struct platform_device *pdev,
 		irq_dispose_mapping(irq_find_mapping(priv->domain, hwirq));
 	irq_domain_remove(priv->domain);
 
-	for (i = 0; i < priv->cfg->num_irqs; i++)
+	for (i = 0; i < priv->nb_irqs; i++) {
 		irq_set_chained_handler(priv->irq[i], NULL);
+		irq_dispose_mapping(priv->irq[i]);
+	}
 }
 
 static int stm32_adc_core_switches_supply_en(struct stm32_adc_priv *priv,
@@ -682,6 +816,21 @@ static int stm32_adc_probe_identification(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
+	if (priv->cfg->ipid == STM32MP25_IPIDR_NUMBER) {
+		/*
+		 * ADC diversity on STM32MP25 is handled here. There may be:
+		 * - 2 IRQs for ADC12 block
+		 * - 1 IRQ for ADC3 block.
+		 * There cannot be more IRQs than the actual number of ADCs.
+		 */
+		if (priv->nb_irqs > priv->nb_adc_max)
+			priv->nb_irqs = priv->nb_adc_max;
+
+		/* Identifies ADC3 trigger list, e.g. stm32mp25_adc3_trigs */
+		if (priv->nb_adc_max == 1)
+			priv->common.trig_id = 1;
+	}
+
 	val = readl_relaxed(priv->common.base + STM32MP1_ADC_VERR);
 	dev_dbg(&pdev->dev, "ADC version: %lu.%lu\n",
 		FIELD_GET(STM32MP1_MAJREV_MASK, val),
@@ -709,12 +858,14 @@ static int stm32_adc_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	platform_set_drvdata(pdev, &priv->common);
 
+	priv->dev = dev;
 	of_id = of_match_device(dev->driver->of_match_table, dev);
 	if (!of_id)
 		return -ENODEV;
 
 	priv->cfg = (const struct stm32_adc_priv_cfg *)of_id->data;
 	priv->nb_adc_max = priv->cfg->num_adcs;
+	priv->nb_irqs = priv->cfg->num_irqs;
 	spin_lock_init(&priv->common.lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -849,7 +1000,9 @@ static DEFINE_RUNTIME_DEV_PM_OPS(stm32_adc_core_pm_ops,
 
 static const struct stm32_adc_priv_cfg stm32f4_adc_priv_cfg = {
 	.regs = &stm32f4_adc_common_regs,
-	.clk_sel = stm32f4_adc_clk_sel,
+	.clk_sel = stm32_adc_clk_sel,
+	.presc = stm32f4_pclk_div,
+	.num_presc = ARRAY_SIZE(stm32f4_pclk_div),
 	.max_clk_rate_hz = 36000000,
 	.num_irqs = 1,
 	.num_adcs = 3,
@@ -873,6 +1026,24 @@ static const struct stm32_adc_priv_cfg stm32mp1_adc_priv_cfg = {
 	.num_irqs = 2,
 };
 
+static const struct stm32_adc_priv_cfg stm32mp13_adc_priv_cfg = {
+	.regs = &stm32mp13_adc_common_regs,
+	.clk_sel = stm32h7_adc_clk_sel,
+	.max_clk_rate_hz = 75 * HZ_PER_MHZ,
+	.ipid = STM32MP13_IPIDR_NUMBER,
+	.num_irqs = 1,
+};
+
+static const struct stm32_adc_priv_cfg stm32mp25_adc_priv_cfg = {
+	.regs = &stm32mp25_adc_common_regs,
+	.clk_sel = stm32_adc_clk_sel,
+	.presc = stm32mp25_presc_div,
+	.num_presc = ARRAY_SIZE(stm32mp25_presc_div),
+	.max_clk_rate_hz = 70000000,
+	.ipid = STM32MP25_IPIDR_NUMBER,
+	.num_irqs = 2, /* 2 IRQs for ADC12, 1 irq for ADC3 */
+};
+
 static const struct of_device_id stm32_adc_of_match[] = {
 	{
 		.compatible = "st,stm32f4-adc-core",
@@ -883,6 +1054,12 @@ static const struct of_device_id stm32_adc_of_match[] = {
 	}, {
 		.compatible = "st,stm32mp1-adc-core",
 		.data = (void *)&stm32mp1_adc_priv_cfg
+	}, {
+		.compatible = "st,stm32mp13-adc-core",
+		.data = (void *)&stm32mp13_adc_priv_cfg
+	}, {
+		.compatible = "st,stm32mp25-adc-core",
+		.data = (void *)&stm32mp25_adc_priv_cfg
 	}, {
 	},
 };
diff --git a/drivers/iio/adc/stm32-adc-core.h b/drivers/iio/adc/stm32-adc-core.h
index 2118ef638..dbcf8528f 100644
--- a/drivers/iio/adc/stm32-adc-core.h
+++ b/drivers/iio/adc/stm32-adc-core.h
@@ -91,6 +91,7 @@
 #define STM32H7_ADC_IER			0x04
 #define STM32H7_ADC_CR			0x08
 #define STM32H7_ADC_CFGR		0x0C
+#define STM32H7_ADC_CFGR2		0x10
 #define STM32H7_ADC_SMPR1		0x14
 #define STM32H7_ADC_SMPR2		0x18
 #define STM32H7_ADC_PCSEL		0x1C
@@ -112,6 +113,14 @@
 #define STM32MP1_ADC_IPDR		0x3F8
 #define STM32MP1_ADC_SIDR		0x3FC
 
+/* STM32MP13 - Registers for each ADC instance */
+#define STM32MP13_ADC_DIFSEL		0xB0
+#define STM32MP13_ADC_CALFACT		0xB4
+#define STM32MP13_ADC2_OR		0xC8
+
+/* STM32MP25 - ADC2 and ADC3 option register */
+#define STM32MP25_ADC23_OR		0xD0
+
 /* STM32H7 - common registers for all ADC instances */
 #define STM32H7_ADC_CSR			(STM32_ADCX_COMN_OFFSET + 0x00)
 #define STM32H7_ADC_CCR			(STM32_ADCX_COMN_OFFSET + 0x08)
@@ -137,6 +146,7 @@
 #define STM32H7_LINCALRDYW3		BIT(24)
 #define STM32H7_LINCALRDYW2		BIT(23)
 #define STM32H7_LINCALRDYW1		BIT(22)
+#define STM32H7_LINCALRDYW_MASK		GENMASK(27, 22)
 #define STM32H7_ADCALLIN		BIT(16)
 #define STM32H7_BOOST			BIT(8)
 #define STM32H7_ADSTP			BIT(4)
@@ -154,6 +164,14 @@
 #define STM32H7_DMNGT_SHIFT		0
 #define STM32H7_DMNGT_MASK		GENMASK(1, 0)
 
+/* STM32H7_ADC_CFGR2 bit fields */
+#define STM32H7_OVSR_SHIFT		16 /* Correspond to OSVR field in datasheet */
+#define STM32H7_OVSR_MASK		GENMASK(25, 16)
+#define STM32H7_OVSR_BITS		10
+#define STM32H7_OVSS_SHIFT		5
+#define STM32H7_OVSS_MASK		GENMASK(8, 5)
+#define STM32H7_ROVSE			BIT(0)
+
 enum stm32h7_adc_dmngt {
 	STM32H7_DMNGT_DR_ONLY,		/* Regular data in DR only */
 	STM32H7_DMNGT_DMA_ONESHOT,	/* DMA one shot mode */
@@ -161,6 +179,9 @@ enum stm32h7_adc_dmngt {
 	STM32H7_DMNGT_DMA_CIRC,		/* DMA circular mode */
 };
 
+/* STM32H7_ADC_DIFSEL - bit fields */
+#define STM32H7_DIFSEL_MASK		GENMASK(19, 0)
+
 /* STM32H7_ADC_CALFACT - bit fields */
 #define STM32H7_CALFACT_D_SHIFT		16
 #define STM32H7_CALFACT_D_MASK		GENMASK(26, 16)
@@ -210,7 +231,56 @@ enum stm32h7_adc_dmngt {
 /* STM32MP1_ADC_SIDR - bit fields */
 #define STM32MP1_SIDR_MASK		GENMASK(31, 0)
 
+/* STM32MP13_ADC_CFGR specific bit fields */
+#define STM32MP13_DMAEN			BIT(0)
+#define STM32MP13_DMACFG		BIT(1)
+#define STM32MP13_DFSDMCFG		BIT(2)
+#define STM32MP13_RES_SHIFT		3
+#define STM32MP13_RES_MASK		GENMASK(4, 3)
+
+/* STM32MP13_ADC_CFGR2 bit fields */
+#define STM32MP13_OVSR_SHIFT		2
+#define STM32MP13_OVSR_MASK		GENMASK(4, 2)
+#define STM32MP13_OVSR_BITS		3
+#define STM32MP13_OVSS_SHIFT		5
+#define STM32MP13_OVSS_MASK		GENMASK(8, 5)
+
+/* STM32MP13_ADC_DIFSEL - bit fields */
+#define STM32MP13_DIFSEL_MASK		GENMASK(18, 0)
+
+/* STM32MP13_ADC_CALFACT - bit fields */
+#define STM32MP13_CALFACT_D_SHIFT	16
+#define STM32MP13_CALFACT_D_MASK	GENMASK(22, 16)
+#define STM32MP13_CALFACT_S_SHIFT	0
+#define STM32MP13_CALFACT_S_MASK	GENMASK(6, 0)
+
+/* STM32MP13_ADC2_OR - bit fields */
+#define STM32MP13_OP2			BIT(2)
+#define STM32MP13_OP1			BIT(1)
+#define STM32MP13_OP0			BIT(0)
+
+/* STM32MP25 - Registers for each ADC instance */
+#define STM32MP25_ADC_CALFACT		0xC4
+
+/* STM32MP25_ADC_CALFACT - bit fields */
+#define STM32MP25_CALFACT_CALADDOS	BIT(31)
+#define STM32MP25_CALFACT_D_MASK	GENMASK(24, 16)
+#define STM32MP25_CALFACT_S_MASK	GENMASK(8, 0)
+
+/* STM32MP25_ADC_CFGR specific bit fields */
+#define STM32MP25_RES_SHIFT		2
+#define STM32MP25_RES_MASK		GENMASK(3, 2)
+
+/* STM32MP25_ADC23_OR - specific bit fields */
+#define STM32MP25_VDDGPUEN		BIT(4)
+#define STM32MP25_VDDCPUEN		BIT(3)
+#define STM32MP25_VDDCOREEN		BIT(2)
+#define STM32MP25_SELBG			BIT(1)
+#define STM32MP25_SELREF		BIT(0)
+
 #define STM32MP15_IPIDR_NUMBER		0x00110005
+#define STM32MP13_IPIDR_NUMBER		0x00110006
+#define STM32MP25_IPIDR_NUMBER		0x00110008
 
 /**
  * struct stm32_adc_common - stm32 ADC driver common data (for all instances)
@@ -219,6 +289,7 @@ enum stm32h7_adc_dmngt {
  * @rate:		clock rate used for analog circuitry
  * @vref_mv:		vref voltage (mv)
  * @lock:		spinlock
+ * @trig_id:		identifies HW trigger list (diversity added since stm32mp25)
  */
 struct stm32_adc_common {
 	void __iomem			*base;
@@ -226,6 +297,7 @@ struct stm32_adc_common {
 	unsigned long			rate;
 	int				vref_mv;
 	spinlock_t			lock;		/* lock for common register */
+	int				trig_id;
 };
 
 #endif
diff --git a/drivers/iio/adc/stm32-adc.c b/drivers/iio/adc/stm32-adc.c
index a5d5b7b38..2873d04c7 100644
--- a/drivers/iio/adc/stm32-adc.c
+++ b/drivers/iio/adc/stm32-adc.c
@@ -6,12 +6,15 @@
  * Author: Fabrice Gasnier <fabrice.gasnier@st.com>.
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
+#include <linux/debugfs.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmaengine.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
 #include <linux/iio/timer/stm32-lptim-trigger.h>
 #include <linux/iio/timer/stm32-timer-trigger.h>
 #include <linux/iio/trigger.h>
@@ -26,12 +29,16 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/property.h>
+#include <linux/util_macros.h>
 
 #include "stm32-adc-core.h"
 
 /* Number of linear calibration shadow registers / LINCALRDYW control bits */
 #define STM32H7_LINCALFACT_NUM		6
 
+/* Number of loops in the calibration procedure to average data on STM32MP25 */
+#define STM32MP25_CALIB_LOOP		8
+
 /* BOOST bit must be set on STM32H7 when ADC clock is above 20MHz */
 #define STM32H7_BOOST_CLKRATE		20000000UL
 
@@ -42,7 +49,6 @@
 #define STM32_ADC_TIMEOUT_US		100000
 #define STM32_ADC_TIMEOUT	(msecs_to_jiffies(STM32_ADC_TIMEOUT_US / 1000))
 #define STM32_ADC_HW_STOP_DELAY_MS	100
-#define STM32_ADC_VREFINT_VOLTAGE	3300
 
 #define STM32_DMA_BUFFER_SIZE		PAGE_SIZE
 
@@ -77,13 +83,24 @@ enum stm32_adc_extsel {
 	STM32_EXT18,
 	STM32_EXT19,
 	STM32_EXT20,
+	STM32_EXT21,
+	STM32_EXT22,
+	STM32_EXT23,
+	STM32_EXT24,
+	STM32_EXT25,
+	STM32_EXT26,
+	STM32_EXT27,
+	STM32_EXT28,
 };
 
 enum stm32_adc_int_ch {
 	STM32_ADC_INT_CH_NONE = -1,
 	STM32_ADC_INT_CH_VDDCORE,
+	STM32_ADC_INT_CH_VDDCPU,
+	STM32_ADC_INT_CH_VDDQ_DDR,
 	STM32_ADC_INT_CH_VREFINT,
 	STM32_ADC_INT_CH_VBAT,
+	STM32_ADC_INT_CH_VDDGPU,
 	STM32_ADC_INT_CH_NB,
 };
 
@@ -99,8 +116,11 @@ struct stm32_adc_ic {
 
 static const struct stm32_adc_ic stm32_adc_ic[STM32_ADC_INT_CH_NB] = {
 	{ "vddcore", STM32_ADC_INT_CH_VDDCORE },
+	{ "vddcpu", STM32_ADC_INT_CH_VDDCPU },
+	{ "vddq_ddr", STM32_ADC_INT_CH_VDDQ_DDR },
 	{ "vrefint", STM32_ADC_INT_CH_VREFINT },
 	{ "vbat", STM32_ADC_INT_CH_VBAT },
+	{ "vddgpu", STM32_ADC_INT_CH_VDDGPU },
 };
 
 /**
@@ -115,16 +135,12 @@ struct stm32_adc_trig_info {
 
 /**
  * struct stm32_adc_calib - optional adc calibration data
- * @calfact_s: Calibration offset for single ended channels
- * @calfact_d: Calibration offset in differential
  * @lincalfact: Linearity calibration factor
- * @calibrated: Indicates calibration status
+ * @lincal_saved: Indicates that linear calibration factors are saved
  */
 struct stm32_adc_calib {
-	u32			calfact_s;
-	u32			calfact_d;
 	u32			lincalfact[STM32H7_LINCALFACT_NUM];
-	bool			calibrated;
+	bool			lincal_saved;
 };
 
 /**
@@ -160,9 +176,13 @@ struct stm32_adc_vrefint {
  * @exten:		trigger control register & bitfield
  * @extsel:		trigger selection register & bitfield
  * @res:		resolution selection register & bitfield
+ * @difsel:		differential mode selection register & bitfield
  * @smpr:		smpr1 & smpr2 registers offset array
  * @smp_bits:		smpr1 & smpr2 index and bitfields
- * @or_vdd:		option register & vddcore bitfield
+ * @or_vddcore:		option register & vddcore bitfield
+ * @or_vddcpu:		option register & vddcpu bitfield
+ * @or_vddgpu:		option register & vddgpu bitfield
+ * @or_vddq_ddr:	option register & vddq_ddr bitfield
  * @ccr_vbat:		common register & vbat bitfield
  * @ccr_vref:		common register & vrefint bitfield
  */
@@ -176,9 +196,13 @@ struct stm32_adc_regspec {
 	const struct stm32_adc_regs exten;
 	const struct stm32_adc_regs extsel;
 	const struct stm32_adc_regs res;
+	const struct stm32_adc_regs difsel;
 	const u32 smpr[2];
 	const struct stm32_adc_regs *smp_bits;
-	const struct stm32_adc_regs or_vdd;
+	const struct stm32_adc_regs or_vddcore;
+	const struct stm32_adc_regs or_vddcpu;
+	const struct stm32_adc_regs or_vddgpu;
+	const struct stm32_adc_regs or_vddq_ddr;
 	const struct stm32_adc_regs ccr_vbat;
 	const struct stm32_adc_regs ccr_vref;
 };
@@ -192,27 +216,39 @@ struct stm32_adc;
  * @trigs:		external trigger sources
  * @clk_required:	clock is required
  * @has_vregready:	vregready status flag presence
+ * @has_boostmode:	boost mode support flag
+ * @has_linearcal:	linear calibration support flag
+ * @has_presel:		channel preselection support flag
+ * @has_oversampling:	oversampling support flag
  * @prepare:		optional prepare routine (power-up, enable)
  * @start_conv:		routine to start conversions
  * @stop_conv:		routine to stop conversions
  * @unprepare:		optional unprepare routine (disable, power-down)
  * @irq_clear:		routine to clear irqs
+ * @set_ovs:		routine to set oversampling configuration
  * @smp_cycles:		programmable sampling time (ADC clock cycles)
- * @ts_vrefint_ns:	vrefint minimum sampling time in ns
+ * @ts_int_ch:		pointer to array of internal channels minimum sampling time in ns
+ * @vref_charac:	Vref characterization voltage (mv) used to measure vrefint calibration value
  */
 struct stm32_adc_cfg {
 	const struct stm32_adc_regspec	*regs;
 	const struct stm32_adc_info	*adc_info;
-	struct stm32_adc_trig_info	*trigs;
+	struct stm32_adc_trig_info	*trigs[2];
 	bool clk_required;
 	bool has_vregready;
+	bool has_boostmode;
+	bool has_linearcal;
+	bool has_presel;
+	bool has_oversampling;
 	int (*prepare)(struct iio_dev *);
 	void (*start_conv)(struct iio_dev *, bool dma);
 	void (*stop_conv)(struct iio_dev *);
 	void (*unprepare)(struct iio_dev *);
 	void (*irq_clear)(struct iio_dev *indio_dev, u32 msk);
+	void (*set_ovs)(struct iio_dev *indio_dev, u32 ovs_idx);
 	const unsigned int *smp_cycles;
-	const unsigned int ts_vrefint_ns;
+	const unsigned int *ts_int_ch;
+	const int vref_charac;
 };
 
 /**
@@ -242,6 +278,8 @@ struct stm32_adc_cfg {
  * @num_diff:		number of differential channels
  * @int_ch:		internal channel indexes array
  * @nsmps:		number of channels with optional sample time
+ * @ovs_idx:		current oversampling ratio index (in oversampling array)
+ * @trigs:		trigger list in use
  */
 struct stm32_adc {
 	struct stm32_adc_common	*common;
@@ -269,6 +307,8 @@ struct stm32_adc {
 	u32			num_diff;
 	int			int_ch[STM32_ADC_INT_CH_NB];
 	int			nsmps;
+	int			ovs_idx;
+	struct stm32_adc_trig_info	*trigs;
 };
 
 struct stm32_adc_diff_channel {
@@ -280,12 +320,24 @@ struct stm32_adc_diff_channel {
  * struct stm32_adc_info - stm32 ADC, per instance config data
  * @max_channels:	Number of channels
  * @resolutions:	available resolutions
+ * @oversampling:	available oversampling ratios
  * @num_res:		number of available resolutions
+ * @num_ovs:		number of available oversampling ratios
  */
 struct stm32_adc_info {
 	int max_channels;
 	const unsigned int *resolutions;
+	const unsigned int *oversampling;
 	const unsigned int num_res;
+	const unsigned int num_ovs;
+};
+
+static const unsigned int stm32h7_adc_oversampling_avail[] = {
+1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
+};
+
+static const unsigned int stm32mp13_adc_oversampling_avail[] = {
+1, 2, 4, 8, 16, 32, 64, 128, 256
 };
 
 static const unsigned int stm32f4_adc_resolutions[] = {
@@ -309,7 +361,27 @@ static const unsigned int stm32h7_adc_resolutions[] = {
 static const struct stm32_adc_info stm32h7_adc_info = {
 	.max_channels = STM32_ADC_CH_MAX,
 	.resolutions = stm32h7_adc_resolutions,
+	.oversampling = stm32h7_adc_oversampling_avail,
 	.num_res = ARRAY_SIZE(stm32h7_adc_resolutions),
+	.num_ovs = ARRAY_SIZE(stm32h7_adc_oversampling_avail),
+};
+
+/* stm32mp13 can have up to 19 channels */
+static const struct stm32_adc_info stm32mp13_adc_info = {
+	.max_channels = 19,
+	.resolutions = stm32f4_adc_resolutions,
+	.oversampling = stm32mp13_adc_oversampling_avail,
+	.num_res = ARRAY_SIZE(stm32f4_adc_resolutions),
+	.num_ovs = ARRAY_SIZE(stm32mp13_adc_oversampling_avail),
+};
+
+/* stm32mp25 can have up to 20 channels */
+static const struct stm32_adc_info stm32mp25_adc_info = {
+	.max_channels = STM32_ADC_CH_MAX,
+	.resolutions = stm32f4_adc_resolutions,
+	.oversampling = stm32h7_adc_oversampling_avail,
+	.num_res = ARRAY_SIZE(stm32f4_adc_resolutions),
+	.num_ovs = ARRAY_SIZE(stm32h7_adc_oversampling_avail),
 };
 
 /*
@@ -497,10 +569,129 @@ static const struct stm32_adc_regspec stm32h7_adc_regspec = {
 	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
 		    STM32H7_EXTSEL_SHIFT },
 	.res = { STM32H7_ADC_CFGR, STM32H7_RES_MASK, STM32H7_RES_SHIFT },
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},
 	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
 	.smp_bits = stm32h7_smp_bits,
 };
 
+/* STM32MP25 external trigger sources for ADC12 */
+static struct stm32_adc_trig_info stm32mp25_adc12_trigs[] = {
+	{ TIM1_TRGO, STM32_EXT0 },
+	{ TIM1_TRGO2, STM32_EXT1 },
+	{ TIM8_TRGO, STM32_EXT2 },
+	{ TIM8_TRGO2, STM32_EXT3 },
+	{ TIM20_TRGO, STM32_EXT4 },
+	{ TIM20_TRGO2, STM32_EXT5 },
+	{ TIM2_TRGO, STM32_EXT6 },
+	{ TIM3_TRGO, STM32_EXT7 },
+	{ TIM4_TRGO, STM32_EXT8 },
+	{ TIM5_TRGO, STM32_EXT9 },
+	{ TIM6_TRGO, STM32_EXT10 },
+	{ TIM15_TRGO, STM32_EXT11 },
+	{ TIM1_CH1, STM32_EXT12 },
+	{ TIM1_CH2, STM32_EXT13 },
+	{ TIM1_CH3, STM32_EXT14 },
+	{ TIM20_OC1, STM32_EXT15 },
+	{ TIM20_OC2, STM32_EXT16 },
+	{ TIM20_OC3, STM32_EXT17 },
+	{ TIM2_CH2, STM32_EXT18 },
+	{ TIM3_CH4, STM32_EXT19 },
+	{ TIM4_CH4, STM32_EXT20 },
+	{ TIM5_CH1, STM32_EXT21 },
+	{ TIM12_CH1, STM32_EXT22 },
+	{ LPTIM1_CH1, STM32_EXT24 },
+	{ LPTIM2_CH1, STM32_EXT25 },
+	{ LPTIM3_CH1, STM32_EXT26 },
+	{ LPTIM4_CH1, STM32_EXT27 },
+	{ LPTIM5_OUT, STM32_EXT28 },
+	{},
+};
+
+/* STM32MP25 external trigger sources for ADC3 */
+static struct stm32_adc_trig_info stm32mp25_adc3_trigs[] = {
+	{ TIM1_TRGO, STM32_EXT0 },
+	{ TIM1_TRGO2, STM32_EXT1 },
+	{ TIM8_TRGO, STM32_EXT2 },
+	{ TIM8_TRGO2, STM32_EXT3 },
+	{ TIM20_TRGO, STM32_EXT4 },
+	{ TIM20_TRGO2, STM32_EXT5 },
+	{ TIM2_TRGO, STM32_EXT6 },
+	{ TIM3_TRGO, STM32_EXT7 },
+	{ TIM4_TRGO, STM32_EXT8 },
+	{ TIM5_TRGO, STM32_EXT9 },
+	{ TIM6_TRGO, STM32_EXT10 },
+	{ TIM7_TRGO, STM32_EXT11 },
+	{ TIM15_TRGO, STM32_EXT12 },
+	{ TIM17_OC1, STM32_EXT13 },
+	{ TIM1_CH3, STM32_EXT14 },
+	{ TIM8_CH1, STM32_EXT15 },
+	{ TIM20_OC1, STM32_EXT16 },
+	{ TIM2_CH1, STM32_EXT17 },
+	{ TIM2_CH3, STM32_EXT18 },
+	{ TIM3_CH1, STM32_EXT19 },
+	{ TIM4_CH1, STM32_EXT20 },
+	{ TIM5_CH3, STM32_EXT21 },
+	{ TIM12_CH1, STM32_EXT22 },
+	{ LPTIM1_CH1, STM32_EXT24 },
+	{ LPTIM2_CH1, STM32_EXT25 },
+	{ LPTIM3_CH1, STM32_EXT26 },
+	{ LPTIM4_CH1, STM32_EXT27 },
+	{ LPTIM5_OUT, STM32_EXT28 },
+	{},
+};
+
+/* STM32MP25 programmable sampling time (ADC clock cycles, rounded down) */
+static const unsigned int stm32mp25_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {
+	2, 3, 7, 12, 24, 47, 247, 1501,
+};
+
+static const struct stm32_adc_regspec stm32mp25_adc_regspec = {
+	.dr = STM32H7_ADC_DR,
+	.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },
+	.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },
+	.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },
+	.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },
+	.sqr = stm32h7_sq,
+	.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },
+	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
+		    STM32H7_EXTSEL_SHIFT },
+	.res = { STM32H7_ADC_CFGR, STM32MP25_RES_MASK, STM32MP25_RES_SHIFT },
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},
+	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
+	.smp_bits = stm32h7_smp_bits,
+	.or_vddcore = { STM32MP25_ADC23_OR, STM32MP25_VDDCOREEN },
+	.or_vddcpu = { STM32MP25_ADC23_OR, STM32MP25_VDDCPUEN },
+	.or_vddgpu = { STM32MP25_ADC23_OR, STM32MP25_VDDGPUEN },
+	.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },
+	.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },
+};
+
+/* STM32MP13 programmable sampling time (ADC clock cycles, rounded down) */
+static const unsigned int stm32mp13_adc_smp_cycles[STM32_ADC_MAX_SMP + 1] = {
+	2, 6, 12, 24, 47, 92, 247, 640,
+};
+
+static const struct stm32_adc_regspec stm32mp13_adc_regspec = {
+	.dr = STM32H7_ADC_DR,
+	.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },
+	.ier_ovr = { STM32H7_ADC_IER, STM32H7_OVRIE },
+	.isr_eoc = { STM32H7_ADC_ISR, STM32H7_EOC },
+	.isr_ovr = { STM32H7_ADC_ISR, STM32H7_OVR },
+	.sqr = stm32h7_sq,
+	.exten = { STM32H7_ADC_CFGR, STM32H7_EXTEN_MASK, STM32H7_EXTEN_SHIFT },
+	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
+		    STM32H7_EXTSEL_SHIFT },
+	.res = { STM32H7_ADC_CFGR, STM32MP13_RES_MASK, STM32MP13_RES_SHIFT },
+	.difsel = { STM32MP13_ADC_DIFSEL, STM32MP13_DIFSEL_MASK},
+	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
+	.smp_bits = stm32h7_smp_bits,
+	.or_vddcore = { STM32MP13_ADC2_OR, STM32MP13_OP0 },
+	.or_vddcpu = { STM32MP13_ADC2_OR, STM32MP13_OP1 },
+	.or_vddq_ddr = { STM32MP13_ADC2_OR, STM32MP13_OP2 },
+	.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },
+	.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },
+};
+
 static const struct stm32_adc_regspec stm32mp1_adc_regspec = {
 	.dr = STM32H7_ADC_DR,
 	.ier_eoc = { STM32H7_ADC_IER, STM32H7_EOCIE },
@@ -512,9 +703,10 @@ static const struct stm32_adc_regspec stm32mp1_adc_regspec = {
 	.extsel = { STM32H7_ADC_CFGR, STM32H7_EXTSEL_MASK,
 		    STM32H7_EXTSEL_SHIFT },
 	.res = { STM32H7_ADC_CFGR, STM32H7_RES_MASK, STM32H7_RES_SHIFT },
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK},
 	.smpr = { STM32H7_ADC_SMPR1, STM32H7_ADC_SMPR2 },
 	.smp_bits = stm32h7_smp_bits,
-	.or_vdd = { STM32MP1_ADC2_OR, STM32MP1_VDDCOREEN },
+	.or_vddcore = { STM32MP1_ADC2_OR, STM32MP1_VDDCOREEN },
 	.ccr_vbat = { STM32H7_ADC_CCR, STM32H7_VBATEN },
 	.ccr_vref = { STM32H7_ADC_CCR, STM32H7_VREFEN },
 };
@@ -675,8 +867,18 @@ static void stm32_adc_int_ch_enable(struct iio_dev *indio_dev)
 		switch (i) {
 		case STM32_ADC_INT_CH_VDDCORE:
 			dev_dbg(&indio_dev->dev, "Enable VDDCore\n");
-			stm32_adc_set_bits(adc, adc->cfg->regs->or_vdd.reg,
-					   adc->cfg->regs->or_vdd.mask);
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddcore.reg,
+					   adc->cfg->regs->or_vddcore.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDCPU:
+			dev_dbg(&indio_dev->dev, "Enable VDDCPU\n");
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddcpu.reg,
+					   adc->cfg->regs->or_vddcpu.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDQ_DDR:
+			dev_dbg(&indio_dev->dev, "Enable VDDQ_DDR\n");
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddq_ddr.reg,
+					   adc->cfg->regs->or_vddq_ddr.mask);
 			break;
 		case STM32_ADC_INT_CH_VREFINT:
 			dev_dbg(&indio_dev->dev, "Enable VREFInt\n");
@@ -688,6 +890,11 @@ static void stm32_adc_int_ch_enable(struct iio_dev *indio_dev)
 			stm32_adc_set_bits_common(adc, adc->cfg->regs->ccr_vbat.reg,
 						  adc->cfg->regs->ccr_vbat.mask);
 			break;
+		case STM32_ADC_INT_CH_VDDGPU:
+			dev_dbg(&indio_dev->dev, "Enable VDDGPU\n");
+			stm32_adc_set_bits(adc, adc->cfg->regs->or_vddgpu.reg,
+					   adc->cfg->regs->or_vddgpu.mask);
+			break;
 		}
 	}
 }
@@ -702,8 +909,16 @@ static void stm32_adc_int_ch_disable(struct stm32_adc *adc)
 
 		switch (i) {
 		case STM32_ADC_INT_CH_VDDCORE:
-			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vdd.reg,
-					   adc->cfg->regs->or_vdd.mask);
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddcore.reg,
+					   adc->cfg->regs->or_vddcore.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDCPU:
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddcpu.reg,
+					   adc->cfg->regs->or_vddcpu.mask);
+			break;
+		case STM32_ADC_INT_CH_VDDQ_DDR:
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddq_ddr.reg,
+					   adc->cfg->regs->or_vddq_ddr.mask);
 			break;
 		case STM32_ADC_INT_CH_VREFINT:
 			stm32_adc_clr_bits_common(adc, adc->cfg->regs->ccr_vref.reg,
@@ -713,6 +928,10 @@ static void stm32_adc_int_ch_disable(struct stm32_adc *adc)
 			stm32_adc_clr_bits_common(adc, adc->cfg->regs->ccr_vbat.reg,
 						  adc->cfg->regs->ccr_vbat.mask);
 			break;
+		case STM32_ADC_INT_CH_VDDGPU:
+			stm32_adc_clr_bits(adc, adc->cfg->regs->or_vddgpu.reg,
+					   adc->cfg->regs->or_vddgpu.mask);
+			break;
 		}
 	}
 }
@@ -801,6 +1020,7 @@ static void stm32h7_adc_stop_conv(struct iio_dev *indio_dev)
 	if (ret)
 		dev_warn(&indio_dev->dev, "stop failed\n");
 
+	/* STM32H7_DMNGT_MASK covers STM32MP13_DMAEN & STM32MP13_DMACFG */
 	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR, STM32H7_DMNGT_MASK);
 }
 
@@ -811,6 +1031,55 @@ static void stm32h7_adc_irq_clear(struct iio_dev *indio_dev, u32 msk)
 	stm32_adc_set_bits(adc, adc->cfg->regs->isr_eoc.reg, msk);
 }
 
+static void stm32mp13_adc_start_conv(struct iio_dev *indio_dev, bool dma)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+
+	if (dma)
+		stm32_adc_set_bits(adc, STM32H7_ADC_CFGR,
+				   STM32MP13_DMAEN | STM32MP13_DMACFG);
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTART);
+}
+
+static void stm32h7_adc_set_ovs(struct iio_dev *indio_dev, u32 ovs_idx)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 ovsr_bits, bits, msk = STM32H7_ROVSE;
+
+	msk |= STM32H7_OVSR_MASK | STM32H7_OVSS_MASK;
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR2, msk);
+
+	if (!ovs_idx)
+		return;
+
+	bits = STM32H7_ROVSE;
+	ovsr_bits = (1 << ovs_idx) - 1;
+	bits |= ovsr_bits << STM32H7_OVSR_SHIFT;
+	bits |= ovs_idx << STM32H7_OVSS_SHIFT;
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CFGR2, bits & msk);
+}
+
+static void stm32mp13_adc_set_ovs(struct iio_dev *indio_dev, u32 ovs_idx)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 bits, msk = STM32H7_ROVSE;
+
+	msk |= STM32MP13_OVSR_MASK | STM32MP13_OVSS_MASK;
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR2, msk);
+
+	if (!ovs_idx)
+		return;
+
+	bits = STM32H7_ROVSE;
+	if (ovs_idx - 1)
+		bits |= (ovs_idx - 1) << STM32MP13_OVSR_SHIFT;
+	bits |= ovs_idx << STM32MP13_OVSS_SHIFT;
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CFGR2, bits & msk);
+}
+
 static int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
@@ -821,7 +1090,8 @@ static int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)
 	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADVREGEN);
 
-	if (adc->common->rate > STM32H7_BOOST_CLKRATE)
+	if (adc->cfg->has_boostmode &&
+	    adc->common->rate > STM32H7_BOOST_CLKRATE)
 		stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);
 
 	/* Wait for startup time */
@@ -843,7 +1113,8 @@ static int stm32h7_adc_exit_pwr_down(struct iio_dev *indio_dev)
 
 static void stm32h7_adc_enter_pwr_down(struct stm32_adc *adc)
 {
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);
+	if (adc->cfg->has_boostmode)
+		stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_BOOST);
 
 	/* Setting DEEPPWD disables ADC vreg and clears ADVREGEN */
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_DEEPPWD);
@@ -922,14 +1193,7 @@ static int stm32h7_adc_read_selfcalib(struct iio_dev *indio_dev)
 
 		lincalrdyw_mask >>= 1;
 	}
-
-	/* Read offset calibration */
-	val = stm32_adc_readl(adc, STM32H7_ADC_CALFACT);
-	adc->cal.calfact_s = (val & STM32H7_CALFACT_S_MASK);
-	adc->cal.calfact_s >>= STM32H7_CALFACT_S_SHIFT;
-	adc->cal.calfact_d = (val & STM32H7_CALFACT_D_MASK);
-	adc->cal.calfact_d >>= STM32H7_CALFACT_D_SHIFT;
-	adc->cal.calibrated = true;
+	adc->cal.lincal_saved = true;
 
 	return 0;
 }
@@ -945,10 +1209,6 @@ static int stm32h7_adc_restore_selfcalib(struct iio_dev *indio_dev)
 	int i, ret;
 	u32 lincalrdyw_mask, val;
 
-	val = (adc->cal.calfact_s << STM32H7_CALFACT_S_SHIFT) |
-		(adc->cal.calfact_d << STM32H7_CALFACT_D_SHIFT);
-	stm32_adc_writel(adc, STM32H7_ADC_CALFACT, val);
-
 	lincalrdyw_mask = STM32H7_LINCALRDYW6;
 	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
 		/*
@@ -1010,17 +1270,21 @@ static int stm32h7_adc_restore_selfcalib(struct iio_dev *indio_dev)
 /**
  * stm32h7_adc_selfcalib() - Procedure to calibrate ADC
  * @indio_dev: IIO device instance
+ * @do_lincal: linear calibration request flag
  * Note: Must be called once ADC is out of power down.
+ *
+ * Run offset calibration unconditionally.
+ * Run linear calibration if requested & supported.
  */
-static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
+static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev, int do_lincal)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
 	int ret;
+	u32 msk = STM32H7_ADCALDIF;
 	u32 val;
 
-	if (adc->cal.calibrated)
-		return true;
-
+	if (adc->cfg->has_linearcal && do_lincal)
+		msk |= STM32H7_ADCALLIN;
 	/* ADC must be disabled for calibration */
 	stm32h7_adc_disable(indio_dev);
 
@@ -1029,8 +1293,7 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 	 * - Offset calibration for single ended inputs
 	 * - No linearity calibration (do it later, before reading it)
 	 */
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALLIN);
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, msk);
 
 	/* Start calibration, then wait for completion */
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
@@ -1038,7 +1301,7 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 					   !(val & STM32H7_ADCAL), 100,
 					   STM32H7_ADC_CALIB_TIMEOUT_US);
 	if (ret) {
-		dev_err(&indio_dev->dev, "calibration failed\n");
+		dev_err(&indio_dev->dev, "calibration (single-ended) error %d\n", ret);
 		goto out;
 	}
 
@@ -1048,24 +1311,50 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 	 * - Linearity calibration (needs to be done only once for single/diff)
 	 *   will run simultaneously with offset calibration.
 	 */
-	stm32_adc_set_bits(adc, STM32H7_ADC_CR,
-			   STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, msk);
 	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
 	ret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,
 					   !(val & STM32H7_ADCAL), 100,
 					   STM32H7_ADC_CALIB_TIMEOUT_US);
 	if (ret) {
-		dev_err(&indio_dev->dev, "calibration failed\n");
+		dev_err(&indio_dev->dev, "calibration (diff%s) error %d\n",
+			(msk & STM32H7_ADCALLIN) ? "+linear" : "", ret);
 		goto out;
 	}
 
 out:
-	stm32_adc_clr_bits(adc, STM32H7_ADC_CR,
-			   STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, msk);
 
 	return ret;
 }
 
+/**
+ * stm32h7_adc_check_selfcalib() - Check linear calibration status
+ * @indio_dev: IIO device instance
+ *
+ * Used to check if linear calibration has been done.
+ * Return true if linear calibration factors are already saved in private data
+ * or if a linear calibration has been done at boot stage.
+ */
+static int stm32h7_adc_check_selfcalib(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 val;
+
+	if (adc->cal.lincal_saved)
+		return true;
+
+	/*
+	 * Check if linear calibration factors are available in ADC registers,
+	 * by checking that all LINCALRDYWx bits are set.
+	 */
+	val = stm32_adc_readl(adc, STM32H7_ADC_CR) & STM32H7_LINCALRDYW_MASK;
+	if (val == STM32H7_LINCALRDYW_MASK)
+		return true;
+
+	return false;
+}
+
 /**
  * stm32h7_adc_prepare() - Leave power down mode to enable ADC.
  * @indio_dev: IIO device instance
@@ -1080,34 +1369,41 @@ static int stm32h7_adc_selfcalib(struct iio_dev *indio_dev)
 static int stm32h7_adc_prepare(struct iio_dev *indio_dev)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
-	int calib, ret;
+	int lincal_done = false;
+	int ret;
 
 	ret = stm32h7_adc_exit_pwr_down(indio_dev);
 	if (ret)
 		return ret;
 
-	ret = stm32h7_adc_selfcalib(indio_dev);
+	if (adc->cfg->has_linearcal)
+		lincal_done = stm32h7_adc_check_selfcalib(indio_dev);
+
+	/* Always run offset calibration. Run linear calibration only once */
+	ret = stm32h7_adc_selfcalib(indio_dev, !lincal_done);
 	if (ret < 0)
 		goto pwr_dwn;
-	calib = ret;
 
 	stm32_adc_int_ch_enable(indio_dev);
 
-	stm32_adc_writel(adc, STM32H7_ADC_DIFSEL, adc->difsel);
+	stm32_adc_writel(adc, adc->cfg->regs->difsel.reg, adc->difsel);
 
 	ret = stm32h7_adc_enable(indio_dev);
 	if (ret)
 		goto ch_disable;
 
-	/* Either restore or read calibration result for future reference */
-	if (calib)
-		ret = stm32h7_adc_restore_selfcalib(indio_dev);
-	else
-		ret = stm32h7_adc_read_selfcalib(indio_dev);
-	if (ret)
-		goto disable;
+	if (adc->cfg->has_linearcal) {
+		if (!adc->cal.lincal_saved)
+			ret = stm32h7_adc_read_selfcalib(indio_dev);
+		else
+			ret = stm32h7_adc_restore_selfcalib(indio_dev);
+
+		if (ret)
+			goto disable;
+	}
 
-	stm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);
 
 	return 0;
 
@@ -1125,9 +1421,167 @@ static void stm32h7_adc_unprepare(struct iio_dev *indio_dev)
 {
 	struct stm32_adc *adc = iio_priv(indio_dev);
 
-	stm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);
+	stm32h7_adc_disable(indio_dev);
+	stm32_adc_int_ch_disable(adc);
+	stm32h7_adc_enter_pwr_down(adc);
+}
+
+/*
+ * STM32MP25 offset calibration software procedure. Basically the calibration routine is
+ * expected to average (for example) 8 samples in calibration mode, for single-ended  and
+ * differential channels, to calibrate the zero offset. In case offset is "negative", an
+ * additional offset can be added, to determine calibration factor. It must be kept later
+ * for all conversions.
+ */
+static int stm32mp25_adc_calib_get_average_data(struct iio_dev *indio_dev, u32 *average)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	const struct stm32_adc_regspec *regs = adc->cfg->regs;
+	u32 val, avg = 0;
+	int i, ret;
+
+	/* Repeat several conversions in calibration mode, average the results */
+	for (i = 0; i < STM32MP25_CALIB_LOOP; i++) {
+		stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADSTART);
+		ret = stm32_adc_readl_poll_timeout(STM32H7_ADC_CR, val,
+						   !(val & (STM32H7_ADSTART)),
+						   100, STM32_ADC_TIMEOUT_US);
+		if (ret) {
+			dev_err(&indio_dev->dev, "calibration average error %d\n", ret);
+			return ret;
+		}
+
+		val = stm32_adc_readl(adc, regs->dr);
+		dev_vdbg(&indio_dev->dev, "dr[%d]=0x%08x\n", i, val);
+		avg += val;
+	}
+
+	*average = DIV_ROUND_CLOSEST(avg, STM32MP25_CALIB_LOOP);
+	dev_vdbg(&indio_dev->dev, "average=0x%08x\n", *average);
+
+	return 0;
+}
+
+static int stm32mp25_adc_calib(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	u32 calfact = 0, average;
+	int ret;
+
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
+	/* Clears CALADDOS (and old calibration data if any) */
+	stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, 0);
+	/* Select single ended input calibration */
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
+	/* Use default resolution (e.g. 12 bits) */
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CFGR, STM32MP25_RES_MASK);
+
+retry:
+	ret = stm32mp25_adc_calib_get_average_data(indio_dev, &average);
+	if (ret)
+		goto out;
+
+	/* If the averaged data is zero, retry with additional offset (set CALADDOS) */
+	if (!average) {
+		if (!calfact) {
+			/* Averaged data is zero, retry with additional offset */
+			calfact = STM32MP25_CALFACT_CALADDOS;
+			stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, calfact);
+			goto retry;
+		}
+		/* Averaged data is still zero with additional offset, just warn about it */
+		dev_warn(&indio_dev->dev, "Single-ended calibration average: 0\n");
+	}
+
+	calfact |= FIELD_PREP(STM32MP25_CALFACT_S_MASK, average);
+
+	/* Select differential input calibration (keep previous CALADDOS value) */
+	stm32_adc_set_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
+	ret = stm32mp25_adc_calib_get_average_data(indio_dev, &average);
+	if (ret)
+		goto out;
+
+	/*
+	 * If the averaged data is below 0x800 (half value in 12-bits mode),
+	 * retry with additional offset
+	 */
+	if (average < BIT(adc->cfg->adc_info->resolutions[0] - 1)) {
+		if (!(calfact & STM32MP25_CALFACT_CALADDOS)) {
+			/* Retry the whole calibration with additional offset */
+			stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCALDIF);
+			calfact = STM32MP25_CALFACT_CALADDOS;
+			stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, calfact);
+			goto retry;
+		}
+		/*
+		 * Averaged data is still below center value. It needs to be clamped to zero,
+		 * so don't use the result here, warn about it.
+		 */
+		dev_warn(&indio_dev->dev, "Differential calibration clamped(0): 0x%x\n", average);
+	} else {
+		calfact |= FIELD_PREP(STM32MP25_CALFACT_D_MASK, average);
+	}
+
+	stm32_adc_writel(adc, STM32MP25_ADC_CALFACT, calfact);
+
+	dev_dbg(&indio_dev->dev, "set calfact_s=0x%03lx, calfact_d=0x%03lx, calados=%ld\n",
+		FIELD_GET(STM32MP25_CALFACT_S_MASK, calfact),
+		FIELD_GET(STM32MP25_CALFACT_D_MASK, calfact),
+		FIELD_GET(STM32MP25_CALFACT_CALADDOS, calfact));
+out:
+	stm32_adc_clr_bits(adc, STM32H7_ADC_CR, STM32H7_ADCAL);
+	stm32_adc_set_res(adc);
+
+	return ret;
+}
+
+static int stm32mp25_adc_prepare(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	ret = stm32h7_adc_exit_pwr_down(indio_dev);
+	if (ret)
+		return ret;
+
+	/* Must enable the ADC before running software-assisted calibration */
+	ret = stm32h7_adc_enable(indio_dev);
+	if (ret)
+		goto pwr_dwn;
+
+	/* Always run offset calibration */
+	ret = stm32mp25_adc_calib(indio_dev);
+	if (ret)
+		goto adc_dis;
+
+	stm32_adc_int_ch_enable(indio_dev);
+
+	stm32_adc_writel(adc, adc->cfg->regs->difsel.reg, adc->difsel);
+
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, adc->pcsel);
+
+	return 0;
+
+adc_dis:
 	stm32h7_adc_disable(indio_dev);
+pwr_dwn:
+	stm32h7_adc_enter_pwr_down(adc);
+
+	return ret;
+}
+
+static void stm32mp25_adc_unprepare(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+
+	/* Undo things in the reverse order */
+	if (adc->cfg->has_presel)
+		stm32_adc_writel(adc, STM32H7_ADC_PCSEL, 0);
 	stm32_adc_int_ch_disable(adc);
+	stm32h7_adc_disable(indio_dev);
 	stm32h7_adc_enter_pwr_down(adc);
 }
 
@@ -1200,15 +1654,15 @@ static int stm32_adc_get_trig_extsel(struct iio_dev *indio_dev,
 	int i;
 
 	/* lookup triggers registered by stm32 timer trigger driver */
-	for (i = 0; adc->cfg->trigs[i].name; i++) {
+	for (i = 0; adc->trigs[i].name; i++) {
 		/**
 		 * Checking both stm32 timer trigger type and trig name
 		 * should be safe against arbitrary trigger names.
 		 */
 		if ((is_stm32_timer_trigger(trig) ||
 		     is_stm32_lptim_trigger(trig)) &&
-		    !strcmp(adc->cfg->trigs[i].name, trig->name)) {
-			return adc->cfg->trigs[i].extsel;
+		    !strcmp(adc->trigs[i].name, trig->name)) {
+			return adc->trigs[i].extsel;
 		}
 	}
 
@@ -1355,6 +1809,71 @@ static int stm32_adc_single_conv(struct iio_dev *indio_dev,
 	return ret;
 }
 
+static int stm32_adc_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+			       int val, int val2, long mask)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	struct device *dev = indio_dev->dev.parent;
+	int nb = adc->cfg->adc_info->num_ovs;
+	u32 idx;
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		if (val2) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		for (idx = 0; idx < nb; idx++)
+			if (adc->cfg->adc_info->oversampling[idx] == val)
+				break;
+
+		if (idx >= nb) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = pm_runtime_resume_and_get(dev);
+		if (ret < 0)
+			goto err;
+
+		adc->cfg->set_ovs(indio_dev, idx);
+
+		pm_runtime_mark_last_busy(dev);
+		pm_runtime_put_autosuspend(dev);
+
+		adc->ovs_idx = idx;
+
+err:
+		iio_device_release_direct_mode(indio_dev);
+
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_adc_read_avail(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+				const int **vals, int *type, int *length, long m)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+
+	switch (m) {
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*type = IIO_VAL_INT;
+		*length = adc->cfg->adc_info->num_ovs;
+		*vals = adc->cfg->adc_info->oversampling;
+		return IIO_AVAIL_LIST;
+	default:
+		return -EINVAL;
+	}
+}
+
 static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 			      struct iio_chan_spec const *chan,
 			      int *val, int *val2, long mask)
@@ -1374,7 +1893,7 @@ static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 			ret = -EINVAL;
 
 		if (mask == IIO_CHAN_INFO_PROCESSED)
-			*val = STM32_ADC_VREFINT_VOLTAGE * adc->vrefint.vrefint_cal / *val;
+			*val = adc->cfg->vref_charac * adc->vrefint.vrefint_cal / *val;
 
 		iio_device_release_direct_mode(indio_dev);
 		return ret;
@@ -1397,6 +1916,10 @@ static int stm32_adc_read_raw(struct iio_dev *indio_dev,
 			*val = 0;
 		return IIO_VAL_INT;
 
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*val = adc->cfg->adc_info->oversampling[adc->ovs_idx];
+		return IIO_VAL_INT;
+
 	default:
 		return -EINVAL;
 	}
@@ -1573,6 +2096,8 @@ static int stm32_adc_debugfs_reg_access(struct iio_dev *indio_dev,
 
 static const struct iio_info stm32_adc_iio_info = {
 	.read_raw = stm32_adc_read_raw,
+	.write_raw = stm32_adc_write_raw,
+	.read_avail = stm32_adc_read_avail,
 	.validate_trigger = stm32_adc_validate_trigger,
 	.hwfifo_set_watermark = stm32_adc_set_watermark,
 	.update_scan_mode = stm32_adc_update_scan_mode,
@@ -1774,6 +2299,23 @@ static const struct iio_chan_spec_ext_info stm32_adc_ext_info[] = {
 	{},
 };
 
+static void stm32_adc_debugfs_init(struct iio_dev *indio_dev)
+{
+	struct stm32_adc *adc = iio_priv(indio_dev);
+	struct dentry *d = iio_get_debugfs_dentry(indio_dev);
+	struct stm32_adc_calib *cal = &adc->cal;
+	char buf[16];
+	unsigned int i;
+
+	if (!adc->cfg->has_linearcal)
+		return;
+
+	for (i = 0; i < STM32H7_LINCALFACT_NUM; i++) {
+		snprintf(buf, sizeof(buf), "lincalfact%d", i + 1);
+		debugfs_create_u32(buf, 0444, d, &cal->lincalfact[i]);
+	}
+}
+
 static int stm32_adc_fw_get_resolution(struct iio_dev *indio_dev)
 {
 	struct device *dev = &indio_dev->dev;
@@ -1802,14 +2344,15 @@ static void stm32_adc_smpr_init(struct stm32_adc *adc, int channel, u32 smp_ns)
 {
 	const struct stm32_adc_regs *smpr = &adc->cfg->regs->smp_bits[channel];
 	u32 period_ns, shift = smpr->shift, mask = smpr->mask;
-	unsigned int smp, r = smpr->reg;
+	unsigned int i, smp, r = smpr->reg;
 
 	/*
-	 * For vrefint channel, ensure that the sampling time cannot
+	 * For internal channels, ensure that the sampling time cannot
 	 * be lower than the one specified in the datasheet
 	 */
-	if (channel == adc->int_ch[STM32_ADC_INT_CH_VREFINT])
-		smp_ns = max(smp_ns, adc->cfg->ts_vrefint_ns);
+	for (i = 0; i < STM32_ADC_INT_CH_NB; i++)
+		if (channel == adc->int_ch[i] && adc->int_ch[i] != STM32_ADC_INT_CH_NONE)
+			smp_ns = max(smp_ns, adc->cfg->ts_int_ch[i]);
 
 	/* Determine sampling time (ADC clock cycles) */
 	period_ns = NSEC_PER_SEC / adc->common->rate;
@@ -1848,6 +2391,10 @@ static void stm32_adc_chan_init_one(struct iio_dev *indio_dev,
 		chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
 	chan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |
 					 BIT(IIO_CHAN_INFO_OFFSET);
+	if (adc->cfg->has_oversampling) {
+		chan->info_mask_shared_by_all |= BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO);
+		chan->info_mask_shared_by_all_available = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO);
+	}
 	chan->scan_type.sign = 'u';
 	chan->scan_type.realbits = adc->cfg->adc_info->resolutions[adc->res];
 	chan->scan_type.storagebits = 16;
@@ -1857,7 +2404,7 @@ static void stm32_adc_chan_init_one(struct iio_dev *indio_dev,
 	adc->pcsel |= BIT(chan->channel);
 	if (differential) {
 		/* pre-build diff channels mask */
-		adc->difsel |= BIT(chan->channel);
+		adc->difsel |= BIT(chan->channel) & adc->cfg->regs->difsel.mask;
 		/* Also add negative input to pre-selected channels */
 		adc->pcsel |= BIT(chan->channel2);
 	}
@@ -2001,6 +2548,35 @@ static int stm32_adc_populate_int_ch(struct iio_dev *indio_dev, const char *ch_n
 
 	for (i = 0; i < STM32_ADC_INT_CH_NB; i++) {
 		if (!strncmp(stm32_adc_ic[i].name, ch_name, STM32_ADC_CH_SZ)) {
+			/* Check internal channel availability */
+			switch (i) {
+			case STM32_ADC_INT_CH_VDDCORE:
+				if (!adc->cfg->regs->or_vddcore.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VDDCPU:
+				if (!adc->cfg->regs->or_vddcpu.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VDDQ_DDR:
+				if (!adc->cfg->regs->or_vddq_ddr.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VREFINT:
+				if (!adc->cfg->regs->ccr_vref.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			case STM32_ADC_INT_CH_VBAT:
+				if (!adc->cfg->regs->ccr_vbat.reg)
+					dev_warn(&indio_dev->dev,
+						 "%s channel not available\n", ch_name);
+				break;
+			}
+
 			if (stm32_adc_ic[i].idx != STM32_ADC_INT_CH_VREFINT) {
 				adc->int_ch[i] = chan;
 				break;
@@ -2288,6 +2864,14 @@ static int stm32_adc_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
+	if (adc->cfg->trigs[adc->common->trig_id])
+		adc->trigs = adc->cfg->trigs[adc->common->trig_id];
+
+	if (!adc->trigs) {
+		dev_err(&pdev->dev, "Can't get trigger list\n");
+		return -EINVAL;
+	}
+
 	ret = stm32_adc_dma_request(dev, indio_dev);
 	if (ret < 0)
 		return ret;
@@ -2333,6 +2917,9 @@ static int stm32_adc_probe(struct platform_device *pdev)
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
 
+	if (IS_ENABLED(CONFIG_DEBUG_FS))
+		stm32_adc_debugfs_init(indio_dev);
+
 	return 0;
 
 err_hw_stop:
@@ -2361,6 +2948,7 @@ static int stm32_adc_remove(struct platform_device *pdev)
 	struct stm32_adc *adc = iio_priv(indio_dev);
 
 	pm_runtime_get_sync(&pdev->dev);
+	/* iio_device_unregister() also removes debugfs entries */
 	iio_device_unregister(indio_dev);
 	stm32_adc_hw_stop(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -2426,44 +3014,106 @@ static const struct dev_pm_ops stm32_adc_pm_ops = {
 static const struct stm32_adc_cfg stm32f4_adc_cfg = {
 	.regs = &stm32f4_adc_regspec,
 	.adc_info = &stm32f4_adc_info,
-	.trigs = stm32f4_adc_trigs,
+	.trigs = { stm32f4_adc_trigs, },
 	.clk_required = true,
 	.start_conv = stm32f4_adc_start_conv,
 	.stop_conv = stm32f4_adc_stop_conv,
 	.smp_cycles = stm32f4_adc_smp_cycles,
 	.irq_clear = stm32f4_adc_irq_clear,
+	.vref_charac = 3300,
 };
 
+static const unsigned int stm32_adc_min_ts_h7[] = { 0, 0, 0, 4300, 9000, 0 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_h7) == STM32_ADC_INT_CH_NB);
+
 static const struct stm32_adc_cfg stm32h7_adc_cfg = {
 	.regs = &stm32h7_adc_regspec,
 	.adc_info = &stm32h7_adc_info,
-	.trigs = stm32h7_adc_trigs,
+	.trigs = { stm32h7_adc_trigs, },
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
+	.has_oversampling = true,
 	.start_conv = stm32h7_adc_start_conv,
 	.stop_conv = stm32h7_adc_stop_conv,
 	.prepare = stm32h7_adc_prepare,
 	.unprepare = stm32h7_adc_unprepare,
 	.smp_cycles = stm32h7_adc_smp_cycles,
 	.irq_clear = stm32h7_adc_irq_clear,
+	.ts_int_ch = stm32_adc_min_ts_h7,
+	.set_ovs = stm32h7_adc_set_ovs,
+	.vref_charac = 3300,
 };
 
+static const unsigned int stm32_adc_min_ts_mp1[] = { 100, 100, 100, 4300, 9800, 0 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_mp1) == STM32_ADC_INT_CH_NB);
+
 static const struct stm32_adc_cfg stm32mp1_adc_cfg = {
 	.regs = &stm32mp1_adc_regspec,
 	.adc_info = &stm32h7_adc_info,
-	.trigs = stm32h7_adc_trigs,
+	.trigs = { stm32h7_adc_trigs, },
 	.has_vregready = true,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
+	.has_oversampling = true,
 	.start_conv = stm32h7_adc_start_conv,
 	.stop_conv = stm32h7_adc_stop_conv,
 	.prepare = stm32h7_adc_prepare,
 	.unprepare = stm32h7_adc_unprepare,
 	.smp_cycles = stm32h7_adc_smp_cycles,
 	.irq_clear = stm32h7_adc_irq_clear,
-	.ts_vrefint_ns = 4300,
+	.ts_int_ch = stm32_adc_min_ts_mp1,
+	.set_ovs = stm32h7_adc_set_ovs,
+	.vref_charac = 3300,
+};
+
+static const unsigned int stm32_adc_min_ts_mp13[] = { 100, 0, 0, 4300, 9800, 0 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_mp13) == STM32_ADC_INT_CH_NB);
+
+static const struct stm32_adc_cfg stm32mp13_adc_cfg = {
+	.regs = &stm32mp13_adc_regspec,
+	.adc_info = &stm32mp13_adc_info,
+	.trigs = { stm32h7_adc_trigs, },
+	.has_oversampling = true,
+	.start_conv = stm32mp13_adc_start_conv,
+	.stop_conv = stm32h7_adc_stop_conv,
+	.prepare = stm32h7_adc_prepare,
+	.unprepare = stm32h7_adc_unprepare,
+	.smp_cycles = stm32mp13_adc_smp_cycles,
+	.irq_clear = stm32h7_adc_irq_clear,
+	.ts_int_ch = stm32_adc_min_ts_mp13,
+	.set_ovs = stm32mp13_adc_set_ovs,
+	.vref_charac = 3300,
+};
+
+/* TODO: Update min sampling time with databrief */
+static const unsigned int stm32_adc_min_ts_mp25[] = { 10000, 10000, 0, 10000, 10000, 10000 };
+static_assert(ARRAY_SIZE(stm32_adc_min_ts_mp25) == STM32_ADC_INT_CH_NB);
+
+static const struct stm32_adc_cfg stm32mp25_adc_cfg = {
+	.regs = &stm32mp25_adc_regspec,
+	.adc_info = &stm32mp25_adc_info,
+	.trigs = { stm32mp25_adc12_trigs, stm32mp25_adc3_trigs },
+	.has_oversampling = true,
+	.has_presel = true,
+	.start_conv = stm32h7_adc_start_conv,
+	.stop_conv = stm32h7_adc_stop_conv,
+	.prepare = stm32mp25_adc_prepare,
+	.unprepare = stm32mp25_adc_unprepare,
+	.smp_cycles = stm32mp25_adc_smp_cycles,
+	.irq_clear = stm32h7_adc_irq_clear,
+	.set_ovs = stm32h7_adc_set_ovs,
+	.ts_int_ch = stm32_adc_min_ts_mp25,
+	.vref_charac = 1800,
 };
 
 static const struct of_device_id stm32_adc_of_match[] = {
 	{ .compatible = "st,stm32f4-adc", .data = (void *)&stm32f4_adc_cfg },
 	{ .compatible = "st,stm32h7-adc", .data = (void *)&stm32h7_adc_cfg },
 	{ .compatible = "st,stm32mp1-adc", .data = (void *)&stm32mp1_adc_cfg },
+	{ .compatible = "st,stm32mp13-adc", .data = (void *)&stm32mp13_adc_cfg },
+	{ .compatible = "st,stm32mp25-adc", .data = (void *)&stm32mp25_adc_cfg },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_adc_of_match);
diff --git a/drivers/iio/adc/stm32-dfsdm-adc.c b/drivers/iio/adc/stm32-dfsdm-adc.c
index a428bdb56..4de991366 100644
--- a/drivers/iio/adc/stm32-dfsdm-adc.c
+++ b/drivers/iio/adc/stm32-dfsdm-adc.c
@@ -10,6 +10,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/iio/adc/stm32-dfsdm-adc.h>
 #include <linux/iio/buffer.h>
+#include <linux/iio/consumer.h>
 #include <linux/iio/hw-consumer.h>
 #include <linux/iio/sysfs.h>
 #include <linux/iio/timer/stm32-lptim-trigger.h>
@@ -67,6 +68,13 @@ struct stm32_dfsdm_dev_data {
 	const struct regmap_config *regmap_cfg;
 };
 
+struct stm32_dfsdm_sd_chan_info {
+	int scale_val;
+	int scale_val2;
+	int offset;
+	unsigned int differential;
+};
+
 struct stm32_dfsdm_adc {
 	struct stm32_dfsdm *dfsdm;
 	const struct stm32_dfsdm_dev_data *dev_data;
@@ -79,6 +87,7 @@ struct stm32_dfsdm_adc {
 	struct iio_hw_consumer *hwc;
 	struct completion completion;
 	u32 *buffer;
+	struct stm32_dfsdm_sd_chan_info *sd_chan;
 
 	/* Audio specific */
 	unsigned int spi_freq;  /* SPI bus clock frequency */
@@ -1223,7 +1232,13 @@ static int stm32_dfsdm_read_raw(struct iio_dev *indio_dev,
 				int *val2, long mask)
 {
 	struct stm32_dfsdm_adc *adc = iio_priv(indio_dev);
-	int ret;
+	struct stm32_dfsdm_filter *fl = &adc->dfsdm->fl_list[adc->fl_id];
+	struct stm32_dfsdm_filter_osr *flo = &fl->flo[fl->fast];
+	u32 max = flo->max << (flo->lshift - chan->scan_type.shift);
+	int ret, idx = chan->scan_index;
+
+	if (flo->lshift < chan->scan_type.shift)
+		max = flo->max >> (chan->scan_type.shift - flo->lshift);
 
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
@@ -1259,6 +1274,39 @@ static int stm32_dfsdm_read_raw(struct iio_dev *indio_dev,
 		*val = adc->sample_freq;
 
 		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_SCALE:
+		/*
+		 * Scale is expressed in mV.
+		 * When fast mode is disabled, actual resolution may be lower
+		 * than 2^n, where n=realbits-1.
+		 * This leads to underestimating input voltage. To
+		 * compensate this deviation, the voltage reference can be
+		 * corrected with a factor = realbits resolution / actual max
+		 */
+		*val = div_u64((u64)adc->sd_chan[idx].scale_val *
+			       (u64)BIT(DFSDM_DATA_RES - 1), max);
+		*val2 = chan->scan_type.realbits;
+		if (adc->sd_chan[idx].differential)
+			*val *= 2;
+		return IIO_VAL_FRACTIONAL_LOG2;
+
+	case IIO_CHAN_INFO_OFFSET:
+		/*
+		 * DFSDM output data are in the range [-2^n,2^n-1],
+		 * with n=realbits-1.
+		 * - Differential modulator:
+		 * Offset correspond to SD modulator offset.
+		 * - Single ended modulator:
+		 * Input is in [0V,Vref] range, where 0V corresponds to -2^n.
+		 * Add 2^n to offset. (i.e. middle of input range)
+		 * offset = offset(sd) * vref / res(sd) * max / vref.
+		 */
+		*val = div_u64((u64)max * adc->sd_chan[idx].offset,
+			       BIT(adc->sd_chan[idx].scale_val2 - 1));
+		if (!adc->sd_chan[idx].differential)
+			*val += max;
+		return IIO_VAL_INT;
 	}
 
 	return -EINVAL;
@@ -1383,7 +1431,9 @@ static int stm32_dfsdm_adc_chan_init_one(struct iio_dev *indio_dev,
 	 * IIO_CHAN_INFO_RAW: used to compute regular conversion
 	 * IIO_CHAN_INFO_OVERSAMPLING_RATIO: used to set oversampling
 	 */
-	ch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	ch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				 BIT(IIO_CHAN_INFO_SCALE) |
+				 BIT(IIO_CHAN_INFO_OFFSET);
 	ch->info_mask_shared_by_all = BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO) |
 					BIT(IIO_CHAN_INFO_SAMP_FREQ);
 
@@ -1393,7 +1443,7 @@ static int stm32_dfsdm_adc_chan_init_one(struct iio_dev *indio_dev,
 		ch->scan_type.shift = 8;
 	}
 	ch->scan_type.sign = 's';
-	ch->scan_type.realbits = 24;
+	ch->scan_type.realbits = DFSDM_DATA_RES;
 	ch->scan_type.storagebits = 32;
 
 	return stm32_dfsdm_chan_configure(adc->dfsdm,
@@ -1434,8 +1484,10 @@ static int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)
 {
 	struct iio_chan_spec *ch;
 	struct stm32_dfsdm_adc *adc = iio_priv(indio_dev);
+	struct iio_channel *channels, *chan;
+	struct stm32_dfsdm_sd_chan_info *sd_chan;
 	int num_ch;
-	int ret, chan_idx;
+	int ret, chan_idx, val2;
 
 	adc->oversamp = DFSDM_DEFAULT_OVERSAMPLING;
 	ret = stm32_dfsdm_compute_all_osrs(indio_dev, adc->oversamp);
@@ -1459,6 +1511,21 @@ static int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)
 	if (!ch)
 		return -ENOMEM;
 
+	/* Get SD modulator channels */
+	channels = iio_channel_get_all(&indio_dev->dev);
+	if (IS_ERR(channels)) {
+		dev_err(&indio_dev->dev, "Failed to get channel %ld\n",
+			PTR_ERR(channels));
+		return PTR_ERR(channels);
+	}
+	chan = &channels[0];
+
+	adc->sd_chan = devm_kzalloc(&indio_dev->dev,
+				    sizeof(*adc->sd_chan) * num_ch, GFP_KERNEL);
+	if (!adc->sd_chan)
+		return -ENOMEM;
+	sd_chan = adc->sd_chan;
+
 	for (chan_idx = 0; chan_idx < num_ch; chan_idx++) {
 		ch[chan_idx].scan_index = chan_idx;
 		ret = stm32_dfsdm_adc_chan_init_one(indio_dev, &ch[chan_idx]);
@@ -1466,6 +1533,38 @@ static int stm32_dfsdm_adc_init(struct device *dev, struct iio_dev *indio_dev)
 			dev_err(&indio_dev->dev, "Channels init failed\n");
 			return ret;
 		}
+
+		if (!chan->indio_dev)
+			return -EINVAL;
+
+		ret = iio_read_channel_scale(chan, &sd_chan->scale_val,
+					     &sd_chan->scale_val2);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev,
+				"Failed to get channel %d scale\n", chan_idx);
+			return ret;
+		}
+
+		if (iio_channel_has_info(chan->channel, IIO_CHAN_INFO_OFFSET)) {
+			ret = iio_read_channel_offset(chan, &sd_chan->offset,
+						      &val2);
+			if (ret < 0) {
+				dev_err(&indio_dev->dev,
+					"Failed to get channel %d offset\n",
+					chan_idx);
+				return ret;
+			}
+		}
+
+		sd_chan->differential = chan->channel->differential;
+
+		dev_dbg(&indio_dev->dev, "Channel %d %s scale ref=%d offset=%d",
+			chan_idx, chan->channel->differential ?
+			"differential" : "single-ended",
+			sd_chan->scale_val, sd_chan->offset);
+
+		chan++;
+		sd_chan++;
 	}
 
 	indio_dev->num_channels = num_ch;
diff --git a/drivers/iio/adc/stm32-dfsdm-core.c b/drivers/iio/adc/stm32-dfsdm-core.c
index a3d4de6ba..5e19df4c6 100644
--- a/drivers/iio/adc/stm32-dfsdm-core.c
+++ b/drivers/iio/adc/stm32-dfsdm-core.c
@@ -6,6 +6,7 @@
  * Author(s): Arnaud Pouliquen <arnaud.pouliquen@st.com> for STMicroelectronics.
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
@@ -20,6 +21,7 @@
 #include "stm32-dfsdm.h"
 
 struct stm32_dfsdm_dev_data {
+	u32 ipid;
 	unsigned int num_filters;
 	unsigned int num_channels;
 	const struct regmap_config *regmap_cfg;
@@ -27,8 +29,6 @@ struct stm32_dfsdm_dev_data {
 
 #define STM32H7_DFSDM_NUM_FILTERS	4
 #define STM32H7_DFSDM_NUM_CHANNELS	8
-#define STM32MP1_DFSDM_NUM_FILTERS	6
-#define STM32MP1_DFSDM_NUM_CHANNELS	8
 
 static bool stm32_dfsdm_volatile_reg(struct device *dev, unsigned int reg)
 {
@@ -75,8 +75,7 @@ static const struct regmap_config stm32mp1_dfsdm_regmap_cfg = {
 };
 
 static const struct stm32_dfsdm_dev_data stm32mp1_dfsdm_data = {
-	.num_filters = STM32MP1_DFSDM_NUM_FILTERS,
-	.num_channels = STM32MP1_DFSDM_NUM_CHANNELS,
+	.ipid = STM32MP15_IPIDR_NUMBER,
 	.regmap_cfg = &stm32mp1_dfsdm_regmap_cfg,
 };
 
@@ -295,6 +294,64 @@ static const struct of_device_id stm32_dfsdm_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, stm32_dfsdm_of_match);
 
+static int stm32_dfsdm_config_check(struct platform_device *pdev,
+				    struct dfsdm_priv *priv,
+				    const struct stm32_dfsdm_dev_data *dev_data)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	struct stm32_dfsdm *dfsdm = &priv->dfsdm;
+	const char *compat;
+	int ret, count = 0;
+	u32 id, val;
+
+	if (!dev_data->ipid) {
+		dfsdm->num_fls = dev_data->num_filters;
+		dfsdm->num_chs = dev_data->num_channels;
+		return 0;
+	}
+
+	ret = regmap_read(dfsdm->regmap, DFSDM_IPIDR, &val);
+	if (ret)
+		return ret;
+
+	id = FIELD_GET(DFSDM_IPIDR_MASK, val);
+	if (id != dev_data->ipid) {
+		dev_err(&pdev->dev, "Unexpected IP version: 0x%x", id);
+		return -EINVAL;
+	}
+
+	for_each_child_of_node(np, child) {
+		ret = of_property_read_string(child, "compatible", &compat);
+		if (ret)
+			continue;
+		count++;
+	}
+
+	ret = regmap_read(dfsdm->regmap, DFSDM_HWCFGR, &val);
+	if (ret)
+		return ret;
+
+	dfsdm->num_fls = FIELD_GET(DFSDM_HWCFGR_NBF_MASK, val);
+	dfsdm->num_chs = FIELD_GET(DFSDM_HWCFGR_NBT_MASK, val);
+
+	if (count > dfsdm->num_fls) {
+		dev_err(&pdev->dev, "Unexpected child number: %d", count);
+		return -EINVAL;
+	}
+
+	ret = regmap_read(dfsdm->regmap, DFSDM_VERR, &val);
+	if (ret)
+		return ret;
+
+	dev_dbg(&pdev->dev, "DFSDM version: %lu.%lu. %d channels/%d filters\n",
+		FIELD_GET(DFSDM_VERR_MAJREV_MASK, val),
+		FIELD_GET(DFSDM_VERR_MINREV_MASK, val),
+		dfsdm->num_chs, dfsdm->num_fls);
+
+	return 0;
+}
+
 static int stm32_dfsdm_probe(struct platform_device *pdev)
 {
 	struct dfsdm_priv *priv;
@@ -311,18 +368,6 @@ static int stm32_dfsdm_probe(struct platform_device *pdev)
 	dev_data = of_device_get_match_data(&pdev->dev);
 
 	dfsdm = &priv->dfsdm;
-	dfsdm->fl_list = devm_kcalloc(&pdev->dev, dev_data->num_filters,
-				      sizeof(*dfsdm->fl_list), GFP_KERNEL);
-	if (!dfsdm->fl_list)
-		return -ENOMEM;
-
-	dfsdm->num_fls = dev_data->num_filters;
-	dfsdm->ch_list = devm_kcalloc(&pdev->dev, dev_data->num_channels,
-				      sizeof(*dfsdm->ch_list),
-				      GFP_KERNEL);
-	if (!dfsdm->ch_list)
-		return -ENOMEM;
-	dfsdm->num_chs = dev_data->num_channels;
 
 	ret = stm32_dfsdm_parse_of(pdev, priv);
 	if (ret < 0)
@@ -338,6 +383,20 @@ static int stm32_dfsdm_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = stm32_dfsdm_config_check(pdev, priv, dev_data);
+	if (ret < 0)
+		return ret;
+
+	dfsdm->fl_list = devm_kcalloc(&pdev->dev, dfsdm->num_fls,
+				      sizeof(*dfsdm->fl_list), GFP_KERNEL);
+	if (!dfsdm->fl_list)
+		return -ENOMEM;
+
+	dfsdm->ch_list = devm_kcalloc(&pdev->dev, dfsdm->num_chs,
+				      sizeof(*dfsdm->ch_list), GFP_KERNEL);
+	if (!dfsdm->ch_list)
+		return -ENOMEM;
+
 	platform_set_drvdata(pdev, dfsdm);
 
 	ret = stm32_dfsdm_clk_prepare_enable(dfsdm);
diff --git a/drivers/iio/adc/stm32-dfsdm.h b/drivers/iio/adc/stm32-dfsdm.h
index 4afc1f528..4f230e2a7 100644
--- a/drivers/iio/adc/stm32-dfsdm.h
+++ b/drivers/iio/adc/stm32-dfsdm.h
@@ -13,25 +13,28 @@
 
 /*
  * STM32 DFSDM - global register map
- * ________________________________________________________
- * | Offset |                 Registers block             |
- * --------------------------------------------------------
- * | 0x000  |      CHANNEL 0 + COMMON CHANNEL FIELDS      |
- * --------------------------------------------------------
- * | 0x020  |                CHANNEL 1                    |
- * --------------------------------------------------------
- * | ...    |                .....                        |
- * --------------------------------------------------------
- * | 0x0E0  |                CHANNEL 7                    |
- * --------------------------------------------------------
- * | 0x100  |      FILTER  0 + COMMON  FILTER FIELDs      |
- * --------------------------------------------------------
- * | 0x200  |                FILTER  1                    |
- * --------------------------------------------------------
- * | 0x300  |                FILTER  2                    |
- * --------------------------------------------------------
- * | 0x400  |                FILTER  3                    |
- * --------------------------------------------------------
+ * __________________________________________________________
+ * | Offset   |                 Registers block             |
+ * ----------------------------------------------------------
+ * | 0x000    |      CHANNEL 0 + COMMON CHANNEL FIELDS      |
+ * ----------------------------------------------------------
+ * | 0x020    |                CHANNEL 1                    |
+ * ----------------------------------------------------------
+ * | ...      |                .....                        |
+ * ----------------------------------------------------------
+ * | 0x20 x n |                CHANNEL n                    |
+ * ----------------------------------------------------------
+ * | 0x100    |      FILTER  0 + COMMON FILTER FIELDs       |
+ * ----------------------------------------------------------
+ * | 0x200    |                FILTER  1                    |
+ * ----------------------------------------------------------
+ * |          |                .....                        |
+ * ----------------------------------------------------------
+ * | 0x100 x m|                FILTER  m                    |
+ * ----------------------------------------------------------
+ * ----------------------------------------------------------
+ * | 0x7F0-7FC|         Identification registers            |
+ * ----------------------------------------------------------
  */
 
 /*
@@ -231,6 +234,34 @@
 #define DFSDM_AWCFR_AWHTF_MASK	GENMASK(15, 8)
 #define DFSDM_AWCFR_AWHTF(v)	FIELD_PREP(DFSDM_AWCFR_AWHTF_MASK, v)
 
+/*
+ * Identification register definitions
+ */
+#define DFSDM_HWCFGR		0x7F0
+#define DFSDM_VERR		0x7F4
+#define DFSDM_IPIDR		0x7F8
+#define DFSDM_SIDR		0x7FC
+
+/* HWCFGR: Hardware configuration register */
+#define DFSDM_HWCFGR_NBT_SHIFT	0
+#define DFSDM_HWCFGR_NBT_MASK	GENMASK(7, 0)
+#define DFSDM_HWCFGR_NBF_SHIFT	8
+#define DFSDM_HWCFGR_NBF_MASK	GENMASK(15, 8)
+
+/* VERR: Version register */
+#define DFSDM_VERR_MINREV_SHIFT	0
+#define DFSDM_VERR_MINREV_MASK	GENMASK(3, 0)
+#define DFSDM_VERR_MAJREV_SHIFT	4
+#define DFSDM_VERR_MAJREV_MASK	GENMASK(7, 4)
+
+/* IPDR: Identification register */
+#define DFSDM_IPIDR_MASK	GENMASK(31, 0)
+
+/* SIDR: Size identification register */
+#define DFSDM_SIDR_MASK		GENMASK(31, 0)
+
+#define STM32MP15_IPIDR_NUMBER	0x00110031
+
 /* DFSDM filter order  */
 enum stm32_dfsdm_sinc_order {
 	DFSDM_FASTSINC_ORDER, /* FastSinc filter type */
diff --git a/drivers/iio/adc/stm32-mdf-adc.c b/drivers/iio/adc/stm32-mdf-adc.c
new file mode 100644
index 000000000..84c1f0620
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf-adc.c
@@ -0,0 +1,1764 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/iio/adc/stm32-mdf-adc.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/hw-consumer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/timer/stm32-lptim-trigger.h>
+#include <linux/iio/timer/stm32-timer-trigger.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#include "stm32-mdf.h"
+
+#define MDF_DMA_BUFFER_SIZE (4 * PAGE_SIZE)
+#define STM32_MDF_ITF_MAX 8
+#define STM32_MDF_DATA_RES 24
+#define STM32_MDF_HPF_BYPASS -1
+#define STM32_MDF_TIMEOUT_MS msecs_to_jiffies(100)
+#define MDF_DEFAULT_SAMPLING_FREQ 1024
+
+#define MDF_IS_FILTER0(adc)			(!((adc)->fl_id))
+#define MDF_IS_INTERLEAVED_FILT(adc)		((adc)->interleaved)
+#define MDF_IS_INTERLEAVED_FILT_NOT_0(adc)	({ typeof(adc) x = (adc);\
+						MDF_IS_INTERLEAVED_FILT(x) && !MDF_IS_FILTER0(x); })
+
+struct stm32_mdf_dev_data {
+	int type;
+	int (*init)(struct device *dev, struct iio_dev *indio_dev);
+};
+
+/*
+ * struct stm32_mdf_adc - STM32 MDF ADC private data
+ * @entry: pointer to serial interfaces list
+ * @dev: pointer to filter device
+ * @mdf: pointer to mdf common data
+ * @regmap: regmap pointer for register read/write
+ * @node: pointer to filter node
+ * @dma_chan: filter dma channel pointer
+ * @dev_data: mdf device data pointer
+ * @sitf: pointer to serial interface feeding the filter
+ * @completion: completion for conversion
+ * @dma_buf: physical dma address
+ * @phys_addr: mdf physical address
+ * @cb: iio consumer callback function pointer
+ * @cb_priv: pointer to consumer private structure
+ * @sck_freq: serial interface frequency
+ * @sample_freq: audio sampling frequency
+ * @fl_id: filter index
+ * @decim_ratio: total decimation ratio
+ * @decim_cic: CIC filter decimation ratio
+ * @bufi: dma buffer current position
+ * @buf_sz: dma buffer size
+ * @buffer: buffer pointer for raw conversion
+ * @cicmode: cic filter order
+ * @hpf_cutoff: high pass filter cut-off frequency
+ * @delay: microphone delay
+ * @datsrc: data source path
+ * @rx_buf: dma buffer pointer
+ * @rsflt_bypass: reshape filter bypass flag
+ * @synced: synchronous flag
+ * @trgo: TRGO trigger flag
+ * @interleaved: interleave flag
+ */
+struct stm32_mdf_adc {
+	struct list_head entry;
+	struct device *dev;
+	struct stm32_mdf *mdf;
+	struct regmap *regmap;
+	struct fwnode_handle *node;
+	struct dma_chan *dma_chan;
+	const struct stm32_mdf_dev_data *dev_data;
+	struct stm32_mdf_sitf *sitf;
+	struct completion completion;
+	dma_addr_t dma_buf;
+	phys_addr_t phys_addr;
+	int (*cb)(const void *data, size_t size, void *cb_priv);
+	void *cb_priv;
+	unsigned long sck_freq;
+	unsigned long sample_freq;
+	unsigned int fl_id;
+	unsigned int decim_ratio;
+	unsigned int decim_cic;
+	unsigned int bufi;
+	unsigned int buf_sz;
+	u32 *buffer;
+	u32 cicmode;
+	u32 hpf_cutoff;
+	u32 delay;
+	u32 datsrc;
+	u8 *rx_buf;
+	bool rsflt_bypass;
+	bool synced;
+	bool trgo;
+	bool interleaved;
+};
+
+struct stm32_mdf_scales {
+	unsigned int scale;
+	int gain;
+};
+
+struct stm32_mdf_log10 {
+	unsigned int raw;
+	unsigned int log;
+};
+
+enum stm32_mdf_converter_type {
+	STM32_MDF_AUDIO,
+	STM32_MDF_IIO,
+};
+
+enum stm32_mdf_data_src_type {
+	STM32_MDF_DATSRC_BSMX,
+	STM32_MDF_DATSRC_UNSUPPORTED,
+	STM32_MDF_DATSRC_ADCITF1,
+	STM32_MDF_DATSRC_ADCITF2,
+	STM32_MDF_DATSRC_NB,
+};
+
+enum stm32_mdf_acq_mode {
+	STM32_MDF_ACQ_MODE_ASYNC_CONT,
+	STM32_MDF_ACQ_MODE_ASYNC_SINGLE_SHOT,
+	STM32_MDF_ACQ_MODE_SYNC_CONT,
+	STM32_MDF_ACQ_MODE_SYNC_SINGLE_SHOT,
+	STM32_MDF_ACQ_MODE_WINDOW_CONT,
+	STM32_MDF_ACQ_MODE_SYNC_SNAPSHOT,
+	STM32_MDF_ACQ_MODE_NB,
+};
+
+enum stm32_trig_type {
+	STM32_MDF_TRGSRC_TRGO,
+	STM32_MDF_TRGSRC_OLD,
+	STM32_MDF_TRGSRC_EXT,
+	STM32_MDF_TRGSRC_NB,
+};
+
+enum stm32_trig_sens {
+	STM32_MDF_TRGSENS_RISING_EDGE,
+	STM32_MDF_TRGSENS_FALLING_EDGE,
+};
+
+enum stm32_trig_src {
+	STM32_MDF_TRGSRC_TIM1_TRGO2 = 0x2,
+	STM32_MDF_TRGSRC_TIM8_TRGO2,
+	STM32_MDF_TRGSRC_TIM20_TRGO2,
+	STM32_MDF_TRGSRC_TIM16_OC1,
+	STM32_MDF_TRGSRC_TIM6_TRGO,
+	STM32_MDF_TRGSRC_TIM7_TRGO,
+	STM32_MDF_TRGSRC_EXTI11,
+	STM32_MDF_TRGSRC_EXTI15,
+	STM32_MDF_TRGSRC_LPTIM1_CH1,
+	STM32_MDF_TRGSRC_LPTIM2_CH1,
+	STM32_MDF_TRGSRC_LPTIM3_CH1,
+};
+
+struct stm32_mdf_ext_trig_src {
+	const char *name;
+	unsigned int trgsrc;
+};
+
+static const struct stm32_mdf_ext_trig_src stm32_mdf_trigs[] = {
+	{ TIM1_TRGO2, STM32_MDF_TRGSRC_TIM1_TRGO2 },
+	{ TIM8_TRGO2, STM32_MDF_TRGSRC_TIM8_TRGO2 },
+	{ TIM20_TRGO2, STM32_MDF_TRGSRC_TIM20_TRGO2 },
+	{ TIM16_OC1, STM32_MDF_TRGSRC_TIM16_OC1 },
+	{ TIM6_TRGO, STM32_MDF_TRGSRC_TIM6_TRGO },
+	{ TIM7_TRGO, STM32_MDF_TRGSRC_TIM7_TRGO },
+	{ LPTIM1_CH1, STM32_MDF_TRGSRC_LPTIM1_CH1 },
+	{ LPTIM2_CH1, STM32_MDF_TRGSRC_LPTIM2_CH1 },
+	{ LPTIM3_CH1, STM32_MDF_TRGSRC_LPTIM3_CH1 },
+	{},
+};
+
+static const unsigned int stm32_mdf_hpf_cutoff_ratio[] = {
+	625, 1250, 2500, 9500
+};
+
+/*
+ * The CIC output data resolution cannot exceed 26 bits.
+ * Output data resolution: D = N * ln(D) / ln(2) + 1 (for serial interface data),
+ * where N is filter order and D the CIC decimation factor.
+ * Following table gives the maximum decimation ratio for filter order [0..5].
+ */
+static const unsigned int stm32_mdf_cic_max_decim_sitf[] = {
+512, 512, 512, 322, 76, 32
+};
+
+/* Gain (dB) x 10 according to scale value in hex */
+static const struct stm32_mdf_scales stm32_mdf_scale_table[] = {
+	{0x20, -482},
+	{0x21, -446},
+	{0x22, -421},
+	{0x23, -386},
+	{0x24, -361},
+	{0x25, -326},
+	{0x26, -301},
+	{0x27, -266},
+	{0x28, -241},
+	{0x29, -206},
+	{0x2A, -181},
+	{0x2B, -145},
+	{0x2C, -120},
+	{0x2D, -85},
+	{0x2E, -60},
+	{0x2F, -25},
+	{0x00, 0},
+	{0x01, 35},
+	{0x02, 60},
+	{0x03, 95},
+	{0x04, 120},
+	{0x05, 156},
+	{0x06, 181},
+	{0x07, 216},
+	{0x08, 241},
+	{0x09, 276},
+	{0x0A, 301},
+	{0x0B, 336},
+	{0x0C, 361},
+	{0x0D, 396},
+	{0x0E, 421},
+	{0x0F, 457},
+	{0x10, 482},
+	{0x11, 517},
+	{0x12, 542},
+	{0x13, 577},
+	{0x14, 602},
+	{0x15, 637},
+	{0x16, 662},
+	{0x17, 697},
+	{0x18, 722},
+};
+
+/* Prime number 1000 x log10 table */
+static const struct stm32_mdf_log10 stm32_mdf_log_table[] = {
+	{2, 301}, {3, 477}, {5, 699}, {7, 845}, {11, 1041}, {13, 1114}, {17, 1230}, {19, 1279},
+	{23, 1362}, {29, 1462}, {31, 1491}, {37, 1568}, {41, 1613}, {43, 1633}, {47, 1672},
+	{53, 1724}, {59, 1771}, {61, 1785}, {67, 1826}, {71, 1851}, {73, 1863}, {79, 1898},
+	{83, 1919}, {89, 1949}, {97, 1987}, {101, 2004}, {103, 2013}, {107, 2029}, {109, 2037},
+	{113, 2053}, {127, 2104}
+};
+
+static bool stm32_mdf_adc_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_BSMXCR_REG:
+	case MDF_DFLTCR_REG:
+	case MDF_DFLTCICR_REG:
+	case MDF_DFLTRSFR_REG:
+	case MDF_DFLTINTR_REG:
+	case MDF_OLDCR_REG:
+	case MDF_OLDTHLR_REG:
+	case MDF_OLDTHHR_REG:
+	case MDF_DLYCR_REG:
+	case MDF_SCDCR_REG:
+	case MDF_DFLTIER_REG:
+	case MDF_DFLTISR_REG:
+	case MDF_OECCR_REG:
+	case MDF_SNPSDR:
+	case MDF_DFLTDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_adc_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/*
+	 * In MDF_DFLTCR_REG register only DFLTACTIVE & DFLTRUN bits are volatile.
+	 * MDF_DFLTCR_REG is not marked as volatible to ease the suspend/resume case, and benefit
+	 * from the regcache API. Access to volatile bits is managed specifically instead.
+	 */
+	switch (reg) {
+	case MDF_DFLTISR_REG:
+	case MDF_SNPSDR:
+	case MDF_DFLTDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_adc_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_BSMXCR_REG:
+	case MDF_DFLTCR_REG:
+	case MDF_DFLTCICR_REG:
+	case MDF_DFLTRSFR_REG:
+	case MDF_DFLTINTR_REG:
+	case MDF_OLDCR_REG:
+	case MDF_OLDTHLR_REG:
+	case MDF_OLDTHHR_REG:
+	case MDF_DLYCR_REG:
+	case MDF_SCDCR_REG:
+	case MDF_DFLTIER_REG:
+	case MDF_DFLTISR_REG:
+	case MDF_OECCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config stm32_mdf_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = sizeof(u32),
+	.max_register = MDF_DFLTDR_REG,
+	.readable_reg = stm32_mdf_adc_readable_reg,
+	.volatile_reg = stm32_mdf_adc_volatile_reg,
+	.writeable_reg = stm32_mdf_adc_writeable_reg,
+	.num_reg_defaults_raw = MDF_DFLTDR_REG / sizeof(u32) + 1,
+	.cache_type = REGCACHE_FLAT,
+	.fast_io = true,
+};
+
+static struct stm32_mdf_adc *stm32_mdf_get_filter_by_handle(struct stm32_mdf *mdf,
+							    struct fwnode_handle *node)
+{
+	struct stm32_mdf_adc *adc;
+
+	/* Look for filter data from filter node handle */
+	list_for_each_entry(adc, &mdf->filter_list, entry) {
+		if (adc->node == node)
+			return adc;
+	}
+	return NULL;
+}
+
+static int stm32_mdf_adc_start_filter(struct stm32_mdf_adc *adc)
+{
+	struct stm32_mdf_adc *adc_inter;
+	struct stm32_mdf *mdf = adc->mdf;
+	u32 val;
+
+	if (MDF_IS_FILTER0(adc))
+		list_for_each_entry(adc_inter, &mdf->filter_list, entry)
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+				stm32_mdf_adc_start_filter(adc_inter);
+
+	/* Check filter status. Bypass cache to access volatile MDF_DFLTCR_ACTIVE bit */
+	regcache_cache_bypass(adc->regmap, true);
+	regmap_read(adc->regmap, MDF_DFLTCR_REG, &val);
+	regcache_cache_bypass(adc->regmap, false);
+	if (val & MDF_DFLTCR_ACTIVE) {
+		dev_err(adc->dev, "Filter [%d] is already running\n", adc->fl_id);
+		return -EBUSY;
+	}
+
+	return regmap_set_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+}
+
+static void stm32_mdf_adc_stop_filter(struct stm32_mdf_adc *adc)
+{
+	struct stm32_mdf_adc *adc_inter;
+	struct stm32_mdf *mdf = adc->mdf;
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DFLTEN);
+
+	if (MDF_IS_FILTER0(adc))
+		list_for_each_entry(adc_inter, &mdf->filter_list, entry)
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+				stm32_mdf_adc_stop_filter(adc_inter);
+}
+
+static int stm32_mdf_adc_get_trig(struct iio_dev *indio_dev, struct iio_trigger *trig)
+{
+	int i;
+
+	/* lookup triggers registered by stm32 timer trigger driver */
+	for (i = 0; stm32_mdf_trigs[i].name; i++) {
+		/**
+		 * Checking both stm32 timer trigger type and trig name
+		 * should be safe against arbitrary trigger names.
+		 */
+		if ((is_stm32_timer_trigger(trig) ||
+		     is_stm32_lptim_trigger(trig)) &&
+		     !strcmp(stm32_mdf_trigs[i].name, trig->name)) {
+			dev_dbg(&indio_dev->dev, "Trigger [%d] found\n", i);
+			return stm32_mdf_trigs[i].trgsrc;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int stm32_mdf_adc_filter_set_trig(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct iio_trigger *trig = indio_dev->trig;
+	u32 trgsrc = 0;
+	/* set trigger polarity to rising edge by default */
+	u32 trgsens = STM32_MDF_TRGSENS_RISING_EDGE;
+	int ret;
+
+	if (trig) {
+		ret = stm32_mdf_adc_get_trig(indio_dev, trig);
+		if (ret < 0)
+			return ret;
+	}
+
+	dev_dbg(adc->dev, "Set trigger source [%d] on filter [%d]\n", trgsrc, adc->fl_id);
+
+	return regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
+				  MDF_DFLTCR_TRGSRC_MASK | MDF_DFLTCR_TRGSENS,
+				  MDF_DFLTCR_TRGSRC(trgsrc) | MDF_DFLTCR_TRGSENS_SET(trgsens));
+}
+
+static void stm32_mdf_adc_filter_clear_trig(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
+			   MDF_DFLTCR_TRGSRC_MASK | MDF_DFLTCR_TRGSENS, 0);
+}
+
+static int stm32_mdf_adc_filter_set_mode(struct stm32_mdf_adc *adc, bool cont)
+{
+	struct stm32_mdf_adc *adc_inter;
+	struct iio_dev *indio_dev = dev_get_drvdata(adc->dev);
+	struct iio_trigger *trig = indio_dev->trig;
+	u32 mode;
+
+	if (MDF_IS_FILTER0(adc)) {
+		list_for_each_entry(adc_inter, &adc->mdf->filter_list, entry) {
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+				stm32_mdf_adc_filter_set_mode(adc_inter, cont);
+		}
+	}
+
+	if (adc->synced || MDF_IS_INTERLEAVED_FILT(adc) || trig) {
+		if (cont)
+			mode = STM32_MDF_ACQ_MODE_SYNC_CONT;
+		else
+			mode = STM32_MDF_ACQ_MODE_SYNC_SINGLE_SHOT;
+	} else {
+		if (cont)
+			mode = STM32_MDF_ACQ_MODE_ASYNC_CONT;
+		else
+			mode = STM32_MDF_ACQ_MODE_ASYNC_SINGLE_SHOT;
+	}
+
+	dev_dbg(adc->dev, "Set mode [0x%x] on filter [%d]\n", mode, adc->fl_id);
+
+	return regmap_update_bits(adc->regmap, MDF_DFLTCR_REG,
+				  MDF_DFLTCR_ACQMOD_MASK, MDF_DFLTCR_ACQMOD(mode));
+}
+
+static int stm32_mdf_adc_compute_scale(struct device *dev, unsigned int decim,
+				       unsigned int order, unsigned int data_size)
+{
+	unsigned long max = ARRAY_SIZE(stm32_mdf_log_table);
+	unsigned int prime_factors[16];
+	unsigned int num, div, logd;
+	int i, j, scale;
+
+	/* Decompose decimation ratio D, as prime number factors, to compute log10(D) */
+	j = 0;
+	num = decim;
+	while (num > 1) {
+		i = 0;
+		while (i < max) {
+			div = stm32_mdf_log_table[i].raw;
+			if (!(num % div)) {
+				prime_factors[j] = stm32_mdf_log_table[i].log;
+				num = num / div;
+				j++;
+				break;
+			}
+			i++;
+		}
+		if (i == max) {
+			dev_warn(dev, "Failed to set scale. Output signal may saturate.\n");
+			return 0;
+		}
+	}
+
+	for (i = 0; i < j; i++)
+		logd += prime_factors[i];
+
+	/* scale = 20 * ((DS - 1) * log10(2) - NF * log10(D)) */
+	scale = 20 * ((data_size - 1) * stm32_mdf_log_table[0].log - order * logd);
+
+	return scale;
+}
+
+static int stm32_mdf_adc_apply_filters_config(struct stm32_mdf_adc *adc, unsigned int scale)
+{
+	struct stm32_mdf_adc *adc_inter;
+	u32 msk, val;
+	int ret, cnt = 0;
+
+	/* Apply conf from filter0 to interleaved filters if any */
+	if (MDF_IS_FILTER0(adc) && adc->mdf->nb_interleave) {
+		list_for_each_entry(adc_inter, &adc->mdf->filter_list, entry) {
+			if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter)) {
+				adc_inter->datsrc = adc->datsrc;
+				adc_inter->cicmode = adc->cicmode;
+				adc_inter->decim_cic = adc->decim_cic;
+				adc_inter->hpf_cutoff = adc->hpf_cutoff;
+
+				stm32_mdf_adc_apply_filters_config(adc_inter, scale);
+				cnt++;
+			}
+		}
+		if (cnt != adc->mdf->nb_interleave - 1) {
+			dev_err(adc->dev, "Interleaved filter number [%d] / expected [%d]\n",
+				cnt, adc->mdf->nb_interleave - 1);
+			return -EINVAL;
+		}
+	}
+
+	/* Configure delay */
+	ret = regmap_update_bits(adc->regmap, MDF_DLYCR_REG, MDF_DLYCR_SKPDLY_MASK, adc->delay);
+	if (ret)
+		return ret;
+
+	/* Configure CICR */
+	msk = MDF_SITFCR_SCKSRC_MASK | MDF_DFLTCICR_CICMOD_MASK |
+	      MDF_DFLTCICR_MCICD_MASK | MDF_DFLTCICR_SCALE_MASK;
+	val = MDF_SITFCR_SCKSRC(adc->datsrc) | MDF_DFLTCICR_CICMOD(adc->cicmode) |
+	      MDF_DFLTCICR_MCICD(adc->decim_cic - 1) | MDF_DFLTCICR_SCALE(scale);
+
+	ret = regmap_update_bits(adc->regmap, MDF_DFLTCICR_REG, msk, val);
+	if (ret)
+		return ret;
+
+	/* Configure RSFR & HPF */
+	if (adc->hpf_cutoff == STM32_MDF_HPF_BYPASS)
+		val = MDF_DFLTRSFR_HPFBYP;
+	else
+		val = MDF_DFLTRSFR_HPFC(adc->hpf_cutoff);
+	val |= adc->rsflt_bypass ? MDF_DFLTRSFR_RSFLTBYP : 0;
+	msk = MDF_DFLTRSFR_RSFLTBYP | MDF_DFLTRSFR_HPFBYP | MDF_DFLTRSFR_HPFC_MASK;
+
+	return regmap_update_bits(adc->regmap, MDF_DFLTRSFR_REG, msk, val);
+}
+
+static int stm32_mdf_adc_set_filters_config(struct iio_dev *indio_dev, unsigned int decim)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct device *dev = &indio_dev->dev;
+	unsigned int decim_cic, decim_rsflt = 1;
+	unsigned int data_size = STM32_MDF_DATA_RES, order = adc->cicmode;
+	int i, log, scale, max_scale;
+
+	if (!adc->rsflt_bypass) {
+		decim_rsflt = 4;
+		data_size -= 2;
+
+		/* Check if total decimation factor is a multiple of reshape filter decimation */
+		if (decim % decim_rsflt) {
+			dev_err(dev, "Total decimation factor [%d] not multiple of [%d]\n",
+				decim, decim_rsflt);
+			return -EINVAL;
+		}
+	}
+
+	decim_cic = DIV_ROUND_CLOSEST(decim, decim_rsflt);
+	if (decim_cic < MDF_DFLTCICR_MCICD_MIN ||
+	    decim_cic > stm32_mdf_cic_max_decim_sitf[order]) {
+		dev_err(dev, "Decimation factor [%d] out of range for CIC filter order [%d]\n",
+			decim_cic, adc->cicmode);
+		return -EINVAL;
+	}
+
+	/*
+	 * Compute scaling:
+	 * max scale = 20 * log10( 2 exp DS / D exp NF )
+	 * - DS = max data size at scale output (RSFLT on: DS = 22 / RSFLT off: DS = 24)
+	 * - NF = Main CIC filter order
+	 */
+	if (is_power_of_2(decim_cic)) {
+		/*
+		 * Decimation ratio is a power of 2: D = 2 exp n
+		 * max scale = 20 * (DS - n * NF) * log10(2)
+		 */
+		log = stm32_mdf_log_table[0].log;
+
+		/* Compute max scale (dB) * 1000 */
+		max_scale = (20 * (data_size - 1 - (order * (fls(decim_cic) - 1))) * log);
+	} else {
+		/*
+		 * Decimation ratio is not a power of 2
+		 * max scale = 20 * ((DS - 1) * log10(2) - NF * log10(D))
+		 */
+		max_scale = stm32_mdf_adc_compute_scale(dev, decim_cic, order, data_size);
+	}
+
+	dev_dbg(dev, "Filter order [%d], decimation [%d], data size [%d], max scale [%d]\n",
+		order, decim_cic, data_size, max_scale / 1000);
+
+	/*
+	 * Find scale register setting.
+	 * Limit max_scale accuracy to first decimal for comparison with scale table values.
+	 */
+	max_scale = DIV_ROUND_CLOSEST(max_scale, 100);
+	i = ARRAY_SIZE(stm32_mdf_scale_table) - 1;
+	while (i > 0) {
+		if (stm32_mdf_scale_table[i].gain < max_scale)
+			break;
+		i--;
+	};
+	scale = stm32_mdf_scale_table[i].scale;
+	adc->decim_cic = decim_cic;
+
+	dev_dbg(dev, "Set scale to [%d] dB: [0x%x]\n", stm32_mdf_scale_table[i].gain / 10, scale);
+
+	return stm32_mdf_adc_apply_filters_config(adc, scale);
+}
+
+static int stm32_mdf_adc_check_clock_config(struct stm32_mdf_adc *adc, unsigned long sck_freq)
+{
+	unsigned int ratio;
+	unsigned int decim_ratio;
+
+	ratio = DIV_ROUND_CLOSEST(adc->mdf->fproc, sck_freq);
+	decim_ratio = DIV_ROUND_CLOSEST(24, adc->decim_cic);
+
+	if ((adc->sitf->mode == STM32_MDF_MODE_SPI && ratio <= 4) ||
+	    (adc->sitf->mode == STM32_MDF_MODE_LF_SPI && ratio <= 2))
+		goto err;
+
+	if (adc->rsflt_bypass && ratio <= decim_ratio)
+		goto err;
+
+	return 0;
+
+err:
+	dev_err(adc->dev, "Wrong Fproc/Fsck ratio [%d] for sitf mode [%d] with RSFLT [%s]\n",
+		ratio, adc->sitf->mode, adc->rsflt_bypass ? "off" : "on");
+
+	return -EINVAL;
+}
+
+static int mdf_adc_set_samp_freq(struct iio_dev *indio_dev, unsigned long sample_freq, int lock)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	unsigned int decim_ratio;
+	unsigned long delta, delta_ppm, sck_freq;
+	unsigned long cck_expected_freq;
+	int ret;
+
+	if (lock) {
+		ret = stm32_mdf_core_lock_kclk_rate(adc->mdf);
+		if (ret < 0)
+			return ret;
+	}
+
+	sck_freq = clk_get_rate(adc->sitf->sck);
+	if (!sck_freq) {
+		dev_err(&indio_dev->dev, "Unexpected serial clock frequency: 0Hz\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/*
+	 * MDF may share its parent clock with SAI, so kernel clock rate may have been changed.
+	 * The set_rate ops is called implicitly through clk_get_rate() call, and MDF dividers
+	 * may have been updated to keep the expected rate on cck clock. Check if sitf clock
+	 * frequency is still the expected one. If not, try to restore the kernel clock rate
+	 * for audio use case.
+	 */
+	cck_expected_freq = stm32_mdf_core_get_cck(adc->mdf);
+	if (sck_freq != cck_expected_freq) {
+		ret = stm32_mdf_core_restore_cck(adc->mdf);
+		if (ret < 0)
+			goto err;
+
+		sck_freq = clk_get_rate(adc->sitf->sck);
+		if (!sck_freq) {
+			ret = -EINVAL;
+			goto err;
+		}
+	}
+
+	decim_ratio = DIV_ROUND_CLOSEST(sck_freq, sample_freq);
+
+	delta = abs(sck_freq - (decim_ratio * sample_freq));
+	delta_ppm = (1000000 * delta) / sck_freq;
+	if (delta_ppm > 1000)
+		dev_warn(&indio_dev->dev, "Sample rate deviation [%lu] ppm: [%lu] vs [%lu] Hz\n",
+			 delta_ppm, sck_freq / decim_ratio, sample_freq);
+	else if (delta)
+		dev_dbg(&indio_dev->dev, "Sample rate deviation [%lu] ppm: [%lu] vs [%lu] Hz\n",
+			delta_ppm, sck_freq / decim_ratio, sample_freq);
+
+	ret = stm32_mdf_adc_set_filters_config(indio_dev, decim_ratio);
+	if (ret < 0)
+		goto err;
+
+	ret = stm32_mdf_adc_check_clock_config(adc, sck_freq);
+	if (ret < 0)
+		goto err;
+
+	adc->sample_freq = DIV_ROUND_CLOSEST(sck_freq, decim_ratio);
+	adc->decim_ratio = decim_ratio;
+
+	return 0;
+
+err:
+	if (lock)
+		stm32_mdf_core_unlock_kclk_rate(adc->mdf);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_start_mdf(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	ret = clk_prepare_enable(adc->sitf->sck);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "Failed to enable clock %s\n",
+			__clk_get_name(adc->sitf->sck));
+		return ret;
+	}
+
+	ret = stm32_mdf_core_start_mdf(adc->mdf);
+	if (ret < 0)
+		clk_disable_unprepare(adc->sitf->sck);
+
+	return ret;
+}
+
+static void stm32_mdf_adc_stop_mdf(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	stm32_mdf_core_stop_mdf(adc->mdf);
+
+	clk_disable_unprepare(adc->sitf->sck);
+}
+
+static int stm32_mdf_adc_start_conv(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	ret = stm32_mdf_sitf_start(adc->sitf);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * In audio use cases the sampling frequency is always provided on stream startup.
+	 * In analog use cases the sampling frequency may not be already set in IIO sysfs.
+	 * Set a default frequency here, if frequency is not yet defined.
+	 * Note: The filters configuration is applied when the sampling frequency is set.
+	 * This involves that all the filters are already probed in interleaved case,
+	 * before setting the sampling frequency.
+	 */
+	if (!adc->sample_freq) {
+		ret = mdf_adc_set_samp_freq(indio_dev, MDF_DEFAULT_SAMPLING_FREQ, 1);
+		if (ret < 0)
+			goto stop_sitf;
+	}
+
+	ret = stm32_mdf_adc_start_filter(adc);
+	if (ret < 0)
+		goto stop_sitf;
+
+	if (adc->trgo) {
+		ret = stm32_mdf_core_trigger(adc->mdf);
+		if (ret < 0)
+			goto stop_filter;
+	}
+
+	return 0;
+
+stop_filter:
+	stm32_mdf_adc_stop_filter(adc);
+stop_sitf:
+	stm32_mdf_sitf_stop(adc->sitf);
+
+	return ret;
+}
+
+static void stm32_mdf_adc_stop_conv(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	stm32_mdf_adc_stop_filter(adc);
+
+	stm32_mdf_sitf_stop(adc->sitf);
+}
+
+static unsigned int stm32_mdf_adc_dma_residue(struct stm32_mdf_adc *adc)
+{
+	struct dma_tx_state state;
+	enum dma_status status;
+
+	status = dmaengine_tx_status(adc->dma_chan, adc->dma_chan->cookie, &state);
+	if (status == DMA_IN_PROGRESS) {
+		/* Residue is size in bytes from end of buffer */
+		unsigned int i = adc->buf_sz - state.residue;
+		unsigned int size;
+
+		/* Return available bytes */
+		if (i >= adc->bufi)
+			size = i - adc->bufi;
+		else
+			size = adc->buf_sz + i - adc->bufi;
+
+		return size;
+	}
+
+	return 0;
+}
+
+static void stm32_mdf_adc_dma_buffer_done(void *data)
+{
+	struct iio_dev *indio_dev = data;
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int available = stm32_mdf_adc_dma_residue(adc);
+	size_t old_pos;
+
+	dev_dbg(&indio_dev->dev, "pos = %d, available = %d\n", adc->bufi, available);
+	old_pos = adc->bufi;
+
+	while (available >= indio_dev->scan_bytes) {
+		s32 *buffer = (s32 *)&adc->rx_buf[adc->bufi];
+		adc->bufi += indio_dev->scan_bytes;
+		if (adc->bufi >= adc->buf_sz) {
+			if (adc->cb)
+				adc->cb(&adc->rx_buf[old_pos], adc->buf_sz - old_pos, adc->cb_priv);
+			adc->bufi = 0;
+			old_pos = 0;
+		}
+		if (adc->dev_data->type == STM32_MDF_IIO)
+			iio_push_to_buffers(indio_dev, buffer);
+		available -= indio_dev->scan_bytes;
+	}
+	if (adc->cb)
+		adc->cb(&adc->rx_buf[old_pos], adc->bufi - old_pos, adc->cb_priv);
+}
+
+static int stm32_mdf_adc_dma_start(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct dma_slave_config config = {
+		.src_addr = (dma_addr_t)adc->phys_addr + MDF_DFLTDR_REG,
+		.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,
+	};
+	struct dma_async_tx_descriptor *desc;
+	int ret;
+
+	if (!adc->dma_chan)
+		return -EINVAL;
+
+	dev_dbg(&indio_dev->dev, "size=%d watermark=%d\n", adc->buf_sz, adc->buf_sz / 2);
+
+	ret = dmaengine_slave_config(adc->dma_chan, &config);
+	if (ret)
+		return ret;
+
+	/* Prepare a DMA cyclic transaction */
+	desc = dmaengine_prep_dma_cyclic(adc->dma_chan, adc->dma_buf,
+					 adc->buf_sz, adc->buf_sz / 2,
+					 DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT);
+	if (!desc)
+		return -EBUSY;
+
+	desc->callback = stm32_mdf_adc_dma_buffer_done;
+	desc->callback_param = indio_dev;
+
+	ret = dma_submit_error(dmaengine_submit(desc));
+	if (ret)
+		goto err_stop_dma;
+
+	/* Issue pending DMA requests */
+	dma_async_issue_pending(adc->dma_chan);
+
+	/* Enable regular DMA transfer*/
+	ret = regmap_set_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DMAEN);
+	if (ret < 0)
+		goto err_stop_dma;
+
+	return 0;
+
+err_stop_dma:
+	dmaengine_terminate_sync(adc->dma_chan);
+
+	return ret;
+}
+
+static void stm32_mdf_adc_dma_stop(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	if (!adc->dma_chan)
+		return;
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTCR_REG, MDF_DFLTCR_DMAEN);
+
+	dmaengine_terminate_sync(adc->dma_chan);
+}
+
+static int stm32_mdf_adc_postenable(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	/* Reset adc buffer index */
+	adc->bufi = 0;
+
+	ret = stm32_mdf_adc_start_mdf(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	stm32_mdf_adc_filter_set_mode(adc, true);
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTISR_REG,
+			  MDF_DFLTISR_DOVRF_MASK | MDF_DFLTISR_SATF_MASK);
+
+	regmap_set_bits(adc->regmap, MDF_DFLTIER_REG,
+			MDF_DFLTIER_DOVRIE_MASK | MDF_DFLTIER_SATIE_MASK);
+
+	ret = stm32_mdf_adc_dma_start(indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Can't start DMA\n");
+		goto err_dma;
+	}
+
+	ret = stm32_mdf_adc_filter_set_trig(indio_dev);
+	if (ret < 0)
+		goto err_trig;
+
+	ret = stm32_mdf_adc_start_conv(indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Can't start conversion\n");
+		goto err_conv;
+	}
+
+	return 0;
+
+err_conv:
+	stm32_mdf_adc_filter_clear_trig(indio_dev);
+err_trig:
+	stm32_mdf_adc_dma_stop(indio_dev);
+err_dma:
+	stm32_mdf_adc_stop_mdf(indio_dev);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_predisable(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	stm32_mdf_adc_stop_conv(indio_dev);
+
+	stm32_mdf_adc_filter_clear_trig(indio_dev);
+
+	stm32_mdf_adc_dma_stop(indio_dev);
+
+	regmap_clear_bits(adc->regmap, MDF_DFLTIER_REG,
+			  MDF_DFLTIER_DOVRIE_MASK | MDF_DFLTIER_SATIE_MASK);
+
+	stm32_mdf_adc_stop_mdf(indio_dev);
+
+	return 0;
+}
+
+static const struct iio_buffer_setup_ops stm32_mdf_buffer_setup_ops = {
+	.postenable = &stm32_mdf_adc_postenable,
+	.predisable = &stm32_mdf_adc_predisable,
+};
+
+static void stm32_mdf_dma_release(struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	if (adc && adc->dma_chan) {
+		dma_free_coherent(adc->dma_chan->device->dev,
+				  MDF_DMA_BUFFER_SIZE, adc->rx_buf, adc->dma_buf);
+		dma_release_channel(adc->dma_chan);
+	}
+}
+
+static int stm32_mdf_dma_request(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct dma_chan *dma_chan;
+
+	dma_chan = dma_request_chan(dev, "rx");
+	if (IS_ERR(dma_chan))
+		return PTR_ERR(dma_chan) ? PTR_ERR(dma_chan) : -ENODEV;
+	adc->dma_chan = dma_chan;
+
+	adc->rx_buf = dma_alloc_coherent(adc->dma_chan->device->dev,
+					 MDF_DMA_BUFFER_SIZE, &adc->dma_buf, GFP_KERNEL);
+	if (!adc->rx_buf) {
+		dma_release_channel(adc->dma_chan);
+		return -ENOMEM;
+	}
+
+	indio_dev->modes |= INDIO_BUFFER_SOFTWARE;
+	indio_dev->setup_ops = &stm32_mdf_buffer_setup_ops;
+
+	return 0;
+}
+
+static int stm32_mdf_channel_parse_of(struct iio_dev *indio_dev, struct fwnode_handle *node,
+				      struct iio_chan_spec *ch)
+{
+	int ret;
+
+	ret = fwnode_property_read_u32(node, "reg", &ch->channel);
+	if (ret < 0)
+		dev_err(&indio_dev->dev, "Missing channel index %d\n", ret);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_chan_init_one(struct iio_dev *indio_dev, struct fwnode_handle *node,
+				       struct iio_chan_spec *ch, int idx)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	if (adc->dev_data->type == STM32_MDF_IIO) {
+		ret = stm32_mdf_channel_parse_of(indio_dev, node, ch);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "Failed to parse channel [%d]\n", idx);
+			return ret;
+		}
+	}
+
+	ch->type = IIO_VOLTAGE;
+	ch->indexed = 1;
+	ch->scan_index = idx;
+
+	ch->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	ch->info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ);
+	ch->scan_type.sign = 's';
+	if (adc->dev_data->type == STM32_MDF_IIO)
+		ch->scan_type.shift = 8;
+	ch->scan_type.realbits = STM32_MDF_DATA_RES;
+	ch->scan_type.storagebits = 32;
+
+	return 0;
+}
+
+static int stm32_mdf_adc_chan_init(struct iio_dev *indio_dev, struct iio_chan_spec *channels)
+{
+	struct fwnode_handle *child;
+	int chan_idx = 0, ret;
+
+	device_for_each_child_node(indio_dev->dev.parent, child) {
+		ret = stm32_mdf_adc_chan_init_one(indio_dev, child, &channels[chan_idx], chan_idx);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "Channels [%d] init failed\n", chan_idx);
+			goto err;
+		}
+
+		chan_idx++;
+	}
+
+	return chan_idx;
+
+err:
+	fwnode_handle_put(child);
+
+	return ret;
+}
+
+static int stm32_mdf_set_watermark(struct iio_dev *indio_dev, unsigned int val)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	unsigned int watermark = MDF_DMA_BUFFER_SIZE / 2;
+	unsigned int rx_buf_sz = MDF_DMA_BUFFER_SIZE;
+
+	/*
+	 * DMA cyclic transfers are used, buffer is split into two periods.
+	 * There should be :
+	 * - always one buffer (period) DMA is working on
+	 * - one buffer (period) driver pushed to ASoC side.
+	 */
+	watermark = min(watermark, val * (unsigned int)(sizeof(u32)));
+	adc->buf_sz = min(rx_buf_sz, watermark * 2);
+
+	return 0;
+}
+
+static int stm32_mdf_adc_single_conv(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan, int *res)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	long timeout;
+	int ret;
+
+	reinit_completion(&adc->completion);
+
+	ret = stm32_mdf_adc_start_mdf(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_update_bits(adc->regmap, MDF_DFLTIER_REG,
+				 MDF_DFLTIER_FTHIE_MASK, MDF_DFLTIER_FTHIE_MASK);
+	if (ret < 0)
+		goto err_conv;
+
+	stm32_mdf_adc_filter_set_mode(adc, false);
+
+	ret = stm32_mdf_adc_start_conv(indio_dev);
+	if (ret < 0) {
+		regmap_update_bits(adc->regmap, MDF_DFLTIER_REG, MDF_DFLTIER_FTHIE_MASK, 0);
+		goto err_conv;
+	}
+
+	timeout = wait_for_completion_interruptible_timeout(&adc->completion, STM32_MDF_TIMEOUT_MS);
+
+	regmap_update_bits(adc->regmap, MDF_DFLTIER_REG, MDF_DFLTIER_FTHIE_MASK, 0);
+
+	if (timeout == 0) {
+		dev_err(&indio_dev->dev, "Timeout reached on channel [%d]", chan->channel);
+		ret = -ETIMEDOUT;
+	} else if (timeout < 0) {
+		ret = timeout;
+	} else {
+		ret = IIO_VAL_INT;
+	}
+
+	if (MDF_IS_INTERLEAVED_FILT(adc))
+		*res = adc->buffer[chan->channel];
+	else
+		*res = adc->buffer[0];
+
+	stm32_mdf_adc_stop_conv(indio_dev);
+
+err_conv:
+	stm32_mdf_adc_stop_mdf(indio_dev);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+				   int val, int val2, long mask)
+{
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (!val)
+			return -EINVAL;
+
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		ret = mdf_adc_set_samp_freq(indio_dev, val, 0);
+		iio_device_release_direct_mode(indio_dev);
+
+		return ret;
+	}
+
+	return -EINVAL;
+}
+
+static int stm32_mdf_adc_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan,
+				  int *val, int *val2, long mask)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+
+		ret = stm32_mdf_adc_single_conv(indio_dev, chan, val);
+
+		iio_device_release_direct_mode(indio_dev);
+		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = adc->sample_freq;
+
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info stm32_mdf_info_audio = {
+	.hwfifo_set_watermark = stm32_mdf_set_watermark,
+	.write_raw = stm32_mdf_adc_write_raw,
+	.read_raw = stm32_mdf_adc_read_raw,
+};
+
+static const struct iio_info stm32_mdf_info_adc = {
+	.hwfifo_set_watermark = stm32_mdf_set_watermark,
+	.write_raw = stm32_mdf_adc_write_raw,
+	.read_raw = stm32_mdf_adc_read_raw,
+	.validate_trigger = stm32_mdf_adc_get_trig,
+};
+
+static irqreturn_t stm32_mdf_irq(int irq, void *arg)
+{
+	struct iio_dev *indio_dev = arg;
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev), *adc_inter;
+	struct regmap *regmap = adc->regmap;
+	u32 *ptr = adc->buffer;
+	u32 isr, ier, flags;
+
+	regmap_read(regmap, MDF_DFLTISR_REG, &isr);
+	regmap_read(regmap, MDF_DFLTIER_REG, &ier);
+
+	flags = isr & ier;
+	if (!flags)
+		return IRQ_NONE;
+
+	if (flags & MDF_DFLTISR_FTHF_MASK) {
+		/* Reading the data register clear the IRQ status */
+		regmap_read(regmap, MDF_DFLTDR_REG, ptr++);
+
+		if (MDF_IS_FILTER0(adc))
+			list_for_each_entry(adc_inter, &adc->mdf->filter_list, entry)
+				if (MDF_IS_INTERLEAVED_FILT_NOT_0(adc_inter))
+					regmap_read(regmap, MDF_DFLTDR_REG, ptr++);
+
+		complete(&adc->completion);
+	}
+
+	if (flags & MDF_DFLTISR_DOVRF_MASK) {
+		dev_warn(&indio_dev->dev, "Data overflow detected\n");
+		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_DOVRF_MASK);
+	}
+
+	if (flags & MDF_DFLTISR_RFOVRF_MASK) {
+		dev_warn(&indio_dev->dev, "Reshape filter overrun detected\n");
+		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_RFOVRF_MASK);
+	}
+
+	if (flags & MDF_DFLTISR_SATF_MASK) {
+		dev_warn(&indio_dev->dev, "Saturation detected\n");
+		regmap_set_bits(regmap, MDF_DFLTISR_REG, MDF_DFLTISR_SATF_MASK);
+
+		/* Notify only once */
+		regmap_clear_bits(adc->regmap, MDF_DFLTIER_REG, MDF_DFLTIER_SATIE_MASK);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int stm32_mdf_audio_init(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct iio_chan_spec *ch;
+	int ret;
+
+	ch = devm_kzalloc(&indio_dev->dev, sizeof(*ch), GFP_KERNEL);
+	if (!ch)
+		return -ENOMEM;
+
+	ret = stm32_mdf_adc_chan_init(indio_dev, ch);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "Channels init failed\n");
+		return ret;
+	}
+	indio_dev->num_channels = 1;
+	indio_dev->channels = ch;
+
+	ret = stm32_mdf_dma_request(dev, indio_dev);
+	if (ret) {
+		dev_err(&indio_dev->dev, "Failed to get dma: %d\n", ret);
+		return ret;
+	}
+
+	ret =  stm32_mdf_adc_filter_set_mode(adc, true);
+	if (ret)
+		stm32_mdf_dma_release(indio_dev);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_init(struct device *dev, struct iio_dev *indio_dev)
+{
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	struct iio_chan_spec *ch = NULL;
+	unsigned int num_ch;
+	int ret;
+
+	num_ch = device_get_child_node_count(indio_dev->dev.parent);
+	if (num_ch) {
+		/* Filter0 may have several channels in interleaved mode */
+		if (num_ch > 1) {
+			if (!MDF_IS_FILTER0(adc)) {
+				dev_err(dev, "Too many channels for filter [%d]\n", adc->fl_id);
+				return -EINVAL;
+			} else if (num_ch != adc->mdf->nb_interleave) {
+				dev_err(dev, "Unexpected channels number for filter0: [%d]\n",
+					num_ch);
+				return -EINVAL;
+			}
+		}
+
+		ch = devm_kzalloc(&indio_dev->dev, num_ch * sizeof(*ch), GFP_KERNEL);
+		if (!ch)
+			return -ENOMEM;
+
+		ret = stm32_mdf_adc_chan_init(indio_dev, ch);
+		if (ret < 0) {
+			dev_err(&indio_dev->dev, "Channels init failed\n");
+			return ret;
+		}
+	}
+
+	indio_dev->num_channels = num_ch;
+	indio_dev->channels = ch;
+
+	init_completion(&adc->completion);
+
+	/* Optionally request DMA */
+	ret = stm32_mdf_dma_request(dev, indio_dev);
+	if (ret) {
+		if (ret != -ENODEV)
+			return dev_err_probe(dev, ret, "DMA channel request failed with\n");
+
+		dev_dbg(dev, "No DMA support\n");
+		return 0;
+	}
+
+	ret = iio_triggered_buffer_setup(indio_dev,
+					 &iio_pollfunc_store_time, NULL,
+					 &stm32_mdf_buffer_setup_ops);
+	if (ret) {
+		stm32_mdf_dma_release(indio_dev);
+		dev_err(&indio_dev->dev, "buffer setup failed\n");
+		return ret;
+	}
+
+	/* lptimer/timer hardware triggers */
+	indio_dev->modes |= INDIO_HARDWARE_TRIGGERED;
+
+	return 0;
+}
+
+static const struct stm32_mdf_dev_data stm32h7_mdf_adc_data = {
+	.type = STM32_MDF_IIO,
+	.init = stm32_mdf_adc_init,
+};
+
+static const struct stm32_mdf_dev_data stm32_mdf_audio_data = {
+	.type = STM32_MDF_AUDIO,
+	.init = stm32_mdf_audio_init,
+};
+
+/**
+ * stm32_mdf_get_buff_cb() - register a callback that will be called when
+ *                           DMA transfer period is achieved.
+ *
+ * @iio_dev: Handle to IIO device.
+ * @cb: Pointer to callback function:
+ *      - data: pointer to data buffer
+ *      - size: size in byte of the data buffer
+ *      - private: pointer to consumer private structure.
+ * @private: Pointer to consumer private structure.
+ */
+int stm32_mdf_get_buff_cb(struct iio_dev *iio_dev,
+			  int (*cb)(const void *data, size_t size, void *private), void *private)
+{
+	struct stm32_mdf_adc *adc;
+
+	if (!iio_dev)
+		return -EINVAL;
+	adc = iio_priv(iio_dev);
+
+	if (!adc)
+		return -EINVAL;
+
+	adc->cb = cb;
+	adc->cb_priv = private;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_get_buff_cb);
+
+/**
+ * stm32_mdf_release_buff_cb - unregister buffer callback
+ *
+ * @iio_dev: Handle to IIO device.
+ */
+int stm32_mdf_release_buff_cb(struct iio_dev *iio_dev)
+{
+	struct stm32_mdf_adc *adc;
+
+	if (!iio_dev)
+		return -EINVAL;
+	adc = iio_priv(iio_dev);
+
+	if (!adc)
+		return -EINVAL;
+
+	adc->cb = NULL;
+	adc->cb_priv = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_release_buff_cb);
+
+static const struct of_device_id stm32_mdf_adc_match[] = {
+	{
+		.compatible = "st,stm32mp25-mdf-adc",
+		.data = &stm32h7_mdf_adc_data,
+	},
+	{
+		.compatible = "st,stm32mp25-mdf-dmic",
+		.data = &stm32_mdf_audio_data,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_mdf_adc_match);
+
+static int stm32_mdf_get_sitf(struct device *dev, struct stm32_mdf_adc *adc,
+			      struct fwnode_handle *sitf_node)
+{
+	struct stm32_mdf_sitf *sitf;
+
+	/* Look for sitf interface from node handle */
+	list_for_each_entry(sitf, &adc->mdf->sitf_list, entry) {
+		if (sitf->node == sitf_node) {
+			adc->sitf = sitf;
+			break;
+		}
+	}
+
+	if (!adc->sitf) {
+		dev_dbg(dev, "Serial interface not registered\n");
+		return -EPROBE_DEFER;
+	}
+
+	return 0;
+}
+
+static int stm32_mdf_get_filters_config(struct device *dev, struct stm32_mdf_adc *adc)
+{
+	int i, ret;
+	u32 val;
+
+	ret = device_property_read_u32(dev, "st,cic-mode", &val);
+	if (ret) {
+		dev_err(dev, "Could not get cic filter mode: %d\n", ret);
+		return ret;
+	}
+	adc->cicmode = val;
+
+	adc->rsflt_bypass = device_property_present(dev, "st,rs-filter-bypass");
+
+	adc->hpf_cutoff = STM32_MDF_HPF_BYPASS;
+	if (device_property_present(dev, "st,hpf-filter-cutoff-bp")) {
+		ret = device_property_read_u32(dev, "st,hpf-filter-cutoff-bp", &val);
+		if (ret) {
+			dev_err(dev, "Could not read HPF cut-off frequency: %d\n", ret);
+			return ret;
+		}
+
+		for (i = 0; i < ARRAY_SIZE(stm32_mdf_hpf_cutoff_ratio); i++) {
+			if (stm32_mdf_hpf_cutoff_ratio[i] == val) {
+				adc->hpf_cutoff = i;
+				break;
+			}
+		}
+
+		if (adc->hpf_cutoff == STM32_MDF_HPF_BYPASS) {
+			dev_err(dev, "Unknwon HPF cut-off frequency ratio: %d\n", val);
+			return -EINVAL;
+		}
+	}
+
+	dev_dbg(dev, "Filter [%d] config: cic mode [%d], rsflt [%s], hpf [%s]\n", adc->fl_id,
+		adc->cicmode, adc->rsflt_bypass ? "off" : "on",
+		adc->hpf_cutoff == STM32_MDF_HPF_BYPASS ? "off" : "on");
+
+	return 0;
+}
+
+static int stm32_mdf_adc_parse_of(struct platform_device *pdev, struct stm32_mdf_adc *adc)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_mdf_adc *adcm;
+	struct fwnode_handle *sitf_node;
+	struct fwnode_handle *filt_node;
+	struct fwnode_reference_args args;
+	int i, ret, stream, buf_size = 1;
+	u32 idx, bsmx, val;
+
+	ret = device_property_read_u32(dev, "reg", &idx);
+	if (ret) {
+		dev_err(dev, "Could not get filter index: %d\n", ret);
+		return ret;
+	}
+
+	if ((idx - 4) % 0x80) {
+		dev_err(dev, "Unexpected reg property value [%x]\n", idx);
+		return -EINVAL;
+	}
+
+	adc->fl_id = (idx >> 7) - 1;
+	if (adc->fl_id >= adc->mdf->nbf) {
+		dev_err(dev, "Wrong filter index [%d]\n", adc->fl_id);
+		return -EINVAL;
+	}
+	adc->node = dev_fwnode(dev);
+
+	if (device_property_present(&pdev->dev, "st,sync")) {
+		filt_node = fwnode_find_reference(dev_fwnode(dev), "st,sync", 0);
+		if (IS_ERR(filt_node)) {
+			dev_err(dev, "Failed to get filter sync handle %ld\n", PTR_ERR(filt_node));
+			return PTR_ERR(filt_node);
+		}
+		adc->synced = true;
+
+		adcm = stm32_mdf_get_filter_by_handle(adc->mdf, filt_node);
+		if (!adcm)
+			return dev_err_probe(dev, -EPROBE_DEFER, "Failed to get filter synchro\n");
+
+		/* The Synchronized master filter is the TRGO trigger source */
+		adcm->trgo = true;
+	}
+
+	if (device_property_present(&pdev->dev, "st,delay")) {
+		ret = device_property_read_u32(dev, "st,delay", &val);
+		if (ret) {
+			dev_err(dev, "Could not get filter delay: %d\n", ret);
+			return ret;
+		}
+		adc->delay = val;
+	}
+
+	/*
+	 * In interleave mode the filters in range [1..n] share their configuration with filter 0.
+	 * In this case, use config from filter 0, instead of parsing DT.
+	 */
+	if (!MDF_IS_FILTER0(adc) && adc->fl_id < adc->mdf->nb_interleave) {
+		/* Check if filter is in interleave filter list */
+		for (i = 0; i < adc->mdf->nb_interleave; i++) {
+			if (adc->mdf->fh_interleave[i] == adc->node) {
+				adc->interleaved = true;
+				break;
+			}
+		}
+
+		if (!adc->interleaved) {
+			dev_err(dev, "Filter [%d] not in interleave property\n", adc->fl_id);
+			return -EINVAL;
+		}
+	} else {
+		ret = stm32_mdf_get_filters_config(dev, adc);
+		if (ret)
+			return ret;
+
+		if (MDF_IS_FILTER0(adc) && adc->mdf->nb_interleave) {
+			/* Filter 0 is the TRGO trigger source in interleave mode */
+			adc->trgo = true;
+			adc->interleaved = true;
+			buf_size = adc->mdf->nb_interleave;
+		}
+	}
+
+	adc->buffer = kcalloc(buf_size, sizeof(u32), GFP_KERNEL);
+	if (!adc->buffer)
+		return -ENOMEM;
+
+	/* Retrieve serial interface */
+	ret = fwnode_property_get_reference_args(dev_fwnode(dev), "st,sitf", NULL, 1, 0, &args);
+	if (ret) {
+		dev_err(dev, "Serial interface node not found: %d\n", ret);
+		return ret;
+	}
+	sitf_node = args.fwnode;
+
+	/* Get stream index */
+	if (args.nargs != 1) {
+		dev_err(dev, "Failed to get stream index in st,sitf property\n");
+		return -EINVAL;
+	}
+	stream = args.args[0];
+
+	/* Retrieve sitf data from sitf node phanle */
+	ret = stm32_mdf_get_sitf(dev, adc, sitf_node);
+	if (ret)
+		return ret;
+
+	bsmx = adc->sitf->id * 2 + stream;
+
+	dev_dbg(dev, "Digital filter [%d] linked to sitf [%d]\n", adc->fl_id, adc->sitf->id);
+
+	/* Only support BSMX filter source right now */
+	adc->datsrc = STM32_MDF_DATSRC_BSMX;
+
+	list_add(&adc->entry, &adc->mdf->filter_list);
+
+	/* Configure BSMXCR */
+	regmap_update_bits(adc->regmap, MDF_BSMXCR_REG,
+			   MDF_BSMXCR_BSSEL_MASK, MDF_BSMXCR_BSSEL(bsmx));
+
+	return 0;
+}
+
+static int stm32_mdf_adc_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct stm32_mdf_adc *adc;
+	const struct stm32_mdf_dev_data *dev_data;
+	struct iio_dev *iio;
+	struct resource *res;
+	void __iomem *base;
+	int ret, irq;
+
+	dev_data = of_device_get_match_data(dev);
+	iio = devm_iio_device_alloc(dev, sizeof(*adc));
+	if (!iio) {
+		dev_err(dev, "Failed to allocate IIO device\n");
+		return -ENOMEM;
+	}
+	iio->modes = INDIO_DIRECT_MODE;
+
+	adc = iio_priv(iio);
+	adc->mdf = dev_get_drvdata(dev->parent);
+
+	platform_set_drvdata(pdev, iio);
+
+	base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(base))
+		return dev_err_probe(dev, PTR_ERR(base), "Failed to get resource\n");
+	adc->phys_addr = res->start;
+
+	adc->regmap = devm_regmap_init_mmio_clk(dev, "ker_ck", base, &stm32_mdf_regmap_cfg);
+	if (IS_ERR(adc->regmap))
+		return dev_err_probe(dev, PTR_ERR(adc->regmap), "Failed to get kernel clock\n");
+
+	ret = stm32_mdf_adc_parse_of(pdev, adc);
+	if (ret < 0)
+		return ret;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return dev_err_probe(dev, irq, "Failed to get IRQ\n");
+
+	ret = devm_request_irq(dev, irq, stm32_mdf_irq, 0, pdev->name, iio);
+	if (ret < 0) {
+		dev_err(dev, "Failed to request IRQ\n");
+		return ret;
+	}
+
+	if (dev_data->type == STM32_MDF_AUDIO)
+		iio->info = &stm32_mdf_info_audio;
+	else
+		iio->info = &stm32_mdf_info_adc;
+	iio->name = dev_name(&pdev->dev);
+
+	adc->dev = dev;
+	adc->dev_data = dev_data;
+	ret = dev_data->init(dev, iio);
+	if (ret < 0)
+		return ret;
+
+	if (!MDF_IS_INTERLEAVED_FILT_NOT_0(adc)) {
+		ret = iio_device_register(iio);
+		if (ret < 0) {
+			dev_err(dev, "Failed to register IIO device: %d\n", ret);
+			goto err_cleanup;
+		}
+	}
+
+	if (dev_data->type == STM32_MDF_AUDIO) {
+		ret = of_platform_populate(node, NULL, NULL, dev);
+		if (ret < 0) {
+			dev_err_probe(dev, ret, "Failed to find an audio DAI\n");
+			goto err_unregister;
+		}
+	}
+
+	return 0;
+
+err_unregister:
+	iio_device_unregister(iio);
+err_cleanup:
+	stm32_mdf_dma_release(iio);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+
+	if (adc->dev_data->type == STM32_MDF_AUDIO)
+		of_platform_depopulate(&pdev->dev);
+	if (!MDF_IS_INTERLEAVED_FILT_NOT_0(adc))
+		iio_device_unregister(indio_dev);
+	stm32_mdf_dma_release(indio_dev);
+
+	return 0;
+}
+
+static int stm32_mdf_adc_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret = 0;
+
+	if (iio_buffer_enabled(indio_dev))
+		ret = stm32_mdf_adc_predisable(indio_dev);
+
+	regcache_cache_only(adc->regmap, true);
+	regcache_mark_dirty(adc->regmap);
+
+	return ret;
+}
+
+static int stm32_mdf_adc_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct stm32_mdf_adc *adc = iio_priv(indio_dev);
+	int ret;
+
+	regcache_cache_only(adc->regmap, false);
+	ret = regcache_sync(adc->regmap);
+
+	if (!ret && iio_buffer_enabled(indio_dev))
+		ret = stm32_mdf_adc_postenable(indio_dev);
+
+	return ret;
+}
+
+static SIMPLE_DEV_PM_OPS(stm32_mdf_adc_pm_ops, stm32_mdf_adc_suspend, stm32_mdf_adc_resume);
+
+static struct platform_driver stm32_mdf_adc_driver = {
+	.driver = {
+		.name = "stm32-mdf-adc",
+		.of_match_table = stm32_mdf_adc_match,
+		.pm = &stm32_mdf_adc_pm_ops,
+	},
+	.probe = stm32_mdf_adc_probe,
+	.remove = stm32_mdf_adc_remove,
+};
+module_platform_driver(stm32_mdf_adc_driver);
+
+MODULE_DESCRIPTION("STM32 MDF sigma delta ADC");
+MODULE_AUTHOR("Olivier Moysan <olivier.moysan@foss.st.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/stm32-mdf-core.c b/drivers/iio/adc/stm32-mdf-core.c
new file mode 100644
index 000000000..87e1a7858
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf-core.c
@@ -0,0 +1,761 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ * Author: Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clk-regmap.h>
+#include <linux/device.h>
+#include <linux/gcd.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+
+#include "stm32-mdf.h"
+
+static bool stm32_mdf_core_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_GCR_REG:
+	case MDF_CKGCR_REG:
+	case MDF_HWCFGR_REG:
+	case MDF_VERR_REG:
+	case MDF_IPIDR_REG:
+	case MDF_SIDR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_core_volatile_reg(struct device *dev, unsigned int reg)
+{
+	/*
+	 * In MDF_CKGCR_REG register only CKGACTIVE bit is volatile. MDF_CKGCR_REG is not marked
+	 * as volatible to ease the suspend/resume case, and benefit from the regcache API.
+	 * Access to CKGACTIVE bit is managed specifically instead.
+	 */
+	return false;
+}
+
+static bool stm32_mdf_core_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_GCR_REG:
+	case MDF_CKGCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config stm32_mdf_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = sizeof(u32),
+	.max_register = MDF_SIDR_REG,
+	.readable_reg = stm32_mdf_core_readable_reg,
+	.volatile_reg = stm32_mdf_core_volatile_reg,
+	.writeable_reg = stm32_mdf_core_writeable_reg,
+	.num_reg_defaults_raw = MDF_SIDR_REG / sizeof(u32) + 1,
+	.fast_io = true,
+	.cache_type = REGCACHE_FLAT,
+};
+
+/*
+ * struct stm32_mdf_priv - STM32 MDF private data
+ * @mdf: mdf common data
+ * @pdev: platform device pointer
+ * @regmap: regmap for register read/write
+ * @kclk: mdf kernel clock handle
+ * @base: mdf registers base cpu address
+ * @phys_base: mdf registers base physical address
+ * @n_active_ch: number of active channels
+ * @lock: lock to manage common resources
+ * @kclk_rate: save kclk rate at probe
+ * @cck_freq: output cck clocks frequency requested in DT
+ * @cck_freq_actual: actual output cck clocks frequency
+ * @exclusive_flg: exclusive rate request flag
+ */
+struct stm32_mdf_priv {
+	struct stm32_mdf mdf;
+	struct platform_device *pdev;
+	struct regmap *regmap;
+	struct clk *kclk;
+	void __iomem *base;
+	phys_addr_t phys_base;
+	atomic_t n_active_ch;
+	spinlock_t lock; /* Manage common resources race conditions */
+	unsigned long kclk_rate;
+	unsigned long cck_freq;
+	unsigned long cck_freq_actual;
+	bool exclusive_flg;
+};
+
+#define STM32_MDF_MAX_CCK 2
+
+static inline struct stm32_mdf_priv *to_stm32_mdf_priv(struct stm32_mdf *mdf)
+{
+	return container_of(mdf, struct stm32_mdf_priv, mdf);
+}
+
+int stm32_mdf_core_start_mdf(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	struct device *dev = &priv->pdev->dev;
+	int ret;
+	u32 val;
+
+	if (atomic_inc_return(&priv->n_active_ch) == 1) {
+		ret = pm_runtime_resume_and_get(dev);
+		if (ret < 0)
+			goto err;
+
+		/* Enable PROCDIV and CCKDIV clock dividers */
+		ret = regmap_set_bits(priv->regmap, MDF_CKGCR_REG, MDF_CKG_CKGDEN);
+		if (ret < 0)
+			goto pm_put;
+
+		/* Check clock status. Bypass cache to access volatile CKGACTIVE active bit */
+		regcache_cache_bypass(priv->regmap, true);
+		regmap_read(priv->regmap, MDF_CKGCR_REG, &val);
+		regcache_cache_bypass(priv->regmap, false);
+		if (!(val & MDF_CKG_ACTIVE)) {
+			ret = -EINVAL;
+			dev_err(dev, "MDF clock not active\n");
+			goto pm_put;
+		}
+
+		if (!priv->exclusive_flg) {
+			clk_rate_exclusive_get(priv->kclk);
+			priv->exclusive_flg = true;
+		}
+	}
+
+	return 0;
+
+pm_put:
+	pm_runtime_put_sync(dev);
+err:
+	atomic_dec(&priv->n_active_ch);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_start_mdf);
+
+int stm32_mdf_core_trigger(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	int ret;
+	u32 val;
+
+	spin_lock(&priv->lock);
+
+	/* Bypass cache to access TRGO volatile bit */
+	regcache_cache_bypass(priv->regmap, true);
+
+	ret = regmap_read(priv->regmap, MDF_GCR_REG, &val);
+	if (ret < 0)
+		goto err;
+
+	if (val & MDF_GCR_TRGO) {
+		ret = -EBUSY;
+		goto err;
+	}
+
+	ret = regmap_set_bits(priv->regmap, MDF_GCR_REG, MDF_GCR_TRGO);
+
+err:
+	regcache_cache_bypass(priv->regmap, false);
+	spin_unlock(&priv->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_trigger);
+
+unsigned long stm32_mdf_core_get_cck(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+
+	return priv->cck_freq_actual;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_get_cck);
+
+int stm32_mdf_core_lock_kclk_rate(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	int ret;
+
+	if (!atomic_read(&priv->n_active_ch)) {
+		/* Request rate exclusivity on kernel clock right now */
+		ret = clk_rate_exclusive_get(priv->kclk);
+		if (ret < 0)
+			return ret;
+
+		priv->exclusive_flg = true;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_lock_kclk_rate);
+
+void stm32_mdf_core_unlock_kclk_rate(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+
+	if (!atomic_read(&priv->n_active_ch)) {
+		clk_rate_exclusive_put(priv->kclk);
+		priv->exclusive_flg = false;
+	}
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_unlock_kclk_rate);
+
+int stm32_mdf_core_restore_cck(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	struct device *dev = &priv->pdev->dev;
+	int ret;
+
+	ret = clk_set_rate(priv->kclk, priv->kclk_rate);
+	if (ret) {
+		dev_err(dev, "Changing MDF kernel clock rate returned error %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(dev, "MDF kernel clock rate changed to [%lu]Kz.\n", priv->kclk_rate);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_restore_cck);
+
+int stm32_mdf_core_stop_mdf(struct stm32_mdf *mdf)
+{
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	int ret = 0;
+
+	if (atomic_dec_and_test(&priv->n_active_ch)) {
+		if (priv->exclusive_flg) {
+			clk_rate_exclusive_put(priv->kclk);
+			priv->exclusive_flg = false;
+		}
+
+		ret = regmap_clear_bits(priv->regmap, MDF_CKGCR_REG, MDF_CKG_CKGDEN);
+
+		pm_runtime_put_sync(&priv->pdev->dev);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_core_stop_mdf);
+
+static struct clk_regmap clk_cck;
+
+static struct clk_regmap clk_cck0 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = MDF_CKGCR_REG,
+		.bit_idx = 1,
+	},
+};
+
+static struct clk_regmap clk_cck1 = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = MDF_CKGCR_REG,
+		.bit_idx = 2,
+	},
+};
+
+static int stm32_mdf_core_cck_divider_set_rate(struct platform_device *pdev,
+					       struct stm32_mdf_priv *priv,
+					       unsigned long parent_rate)
+{
+	struct device *dev = &pdev->dev;
+	unsigned long rate = priv->cck_freq;
+	unsigned long ratio, delta, delta_ppm;
+	unsigned int cckdiv, procdiv;
+
+	ratio = DIV_ROUND_CLOSEST(parent_rate, rate);
+	if (!ratio) {
+		dev_err(dev, "CCK frequency above kernel frequency\n");
+		return -EINVAL;
+	}
+
+	delta = abs(parent_rate - (ratio * rate));
+
+	delta_ppm = (1000000 * delta) / parent_rate;
+	priv->cck_freq_actual = DIV_ROUND_CLOSEST(parent_rate, ratio);
+
+	if (delta_ppm > 1000) {
+		/* If frequency deviation is higher than 1000 ppm return error */
+		dev_dbg(dev, "CCK clock deviation [%lu] ppm too large: [%lu] vs [%lu] Hz\n",
+			delta_ppm, priv->cck_freq_actual, rate);
+		return -EINVAL;
+	} else if (delta_ppm) {
+		dev_dbg(dev, "CCK clock frequency not accurate: [%lu] ppm deviation\n", delta_ppm);
+	}
+
+	/*
+	 * The total divider ratio must be split between proc divider and
+	 * cck divider. Try to maximize cck divider first, to help fulfilling
+	 * frequency ratio requirements between fproc and fcck.
+	 */
+	cckdiv = gcd(ratio, MDF_CCKDIV_MAX);
+	procdiv = ratio / cckdiv;
+
+	if (procdiv > MDF_PROCDIV_MAX) {
+		dev_err(dev, "Proc divider out of range: %d > %d\n", procdiv, MDF_PROCDIV_MAX);
+		return -EINVAL;
+	}
+
+	priv->mdf.fproc = DIV_ROUND_CLOSEST(parent_rate, procdiv);
+
+	/* Configure CKGCR register */
+	dev_dbg(dev, "Set MDF dividers: CCKDIV [%d], PROCDIV [%d]\n", cckdiv, procdiv);
+	return regmap_update_bits(priv->regmap, MDF_CKGCR_REG,
+				  MDF_CKG_CCKDIV_MASK | MDF_CKG_PROCDIV_MASK,
+				  MDF_CKG_CCKDIV(cckdiv - 1) |
+				  MDF_CKG_PROCDIV(procdiv - 1));
+}
+
+static int stm32_mdf_core_cck_set_rate(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	struct stm32_mdf_priv *priv = (struct stm32_mdf_priv *)clk_cck.data;
+	struct platform_device *pdev = priv->pdev;
+
+	return stm32_mdf_core_cck_divider_set_rate(pdev, priv, parent_rate);
+}
+
+static long stm32_mdf_core_cck_round_rate(struct clk_hw *hw, unsigned long rate,
+					  unsigned long *parent_rate)
+{
+	struct stm32_mdf_priv *priv = (struct stm32_mdf_priv *)clk_cck.data;
+	struct platform_device *pdev = priv->pdev;
+	unsigned long ratio;
+
+	ratio = DIV_ROUND_CLOSEST(*parent_rate, rate);
+	if (!ratio) {
+		dev_err(&pdev->dev, "CCK frequency above kernel frequency\n");
+		return -EINVAL;
+	}
+
+	return DIV_ROUND_CLOSEST(*parent_rate, ratio);
+}
+
+static unsigned long stm32_mdf_core_cck_divider_recalc_rate(struct clk_hw *hw,
+							    unsigned long parent_rate)
+{
+	struct clk_regmap *clk = to_clk_regmap(hw);
+	unsigned int val;
+	unsigned int ratio;
+	int ret;
+
+	ret = regmap_read(clk->map, MDF_CKGCR_REG, &val);
+	if (ret)
+		/* Gives a hint that something is wrong */
+		return 0;
+
+	ratio = (FIELD_GET(MDF_CKG_PROCDIV_MASK, val) + 1) *
+		(FIELD_GET(MDF_CKG_CCKDIV_MASK, val) + 1);
+
+	return DIV_ROUND_CLOSEST_ULL((u64)parent_rate, ratio);
+};
+
+static const struct clk_ops clk_cck_ops = {
+	.recalc_rate = stm32_mdf_core_cck_divider_recalc_rate,
+	.set_rate = stm32_mdf_core_cck_set_rate,
+	.round_rate = stm32_mdf_core_cck_round_rate,
+};
+
+static int stm32_mdf_core_register_clock_provider(struct platform_device *pdev,
+						  struct stm32_mdf_priv *priv)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct property *prop;
+	struct clk_regmap *clk;
+	const char *clk_name;
+	u32 ckgcr = 0;
+	int index = 0, ret, clk_id;
+	struct clk_hw *mdf_hw[] = { &clk_cck0.hw, &clk_cck1.hw };
+
+	clk_cck.hw.init = CLK_HW_INIT_FW_NAME("clk_cck", "ker_ck", &clk_cck_ops, 0);
+	clk_cck0.hw.init = CLK_HW_INIT_HW(STM32_MDF_CCK0, &clk_cck.hw,
+					  &clk_regmap_gate_ops, CLK_SET_RATE_PARENT);
+	clk_cck1.hw.init = CLK_HW_INIT_HW(STM32_MDF_CCK1, &clk_cck.hw,
+					  &clk_regmap_gate_ops, CLK_SET_RATE_PARENT);
+
+	clk_cck.data = priv;
+
+	clk = to_clk_regmap(&clk_cck.hw);
+	clk->map = priv->regmap;
+
+	ret = devm_clk_hw_register(dev, &clk_cck.hw);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to register clk_cck");
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, STM32_MDF_MAX_CCK), GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	of_property_for_each_string(node, "clock-output-names", prop, clk_name) {
+		if (index >= STM32_MDF_MAX_CCK) {
+			dev_err(dev, "Too many cck providers defined\n");
+			return -EINVAL;
+		}
+
+		if (!strncmp(clk_name, "cck0", 4)) {
+			clk_id = 0;
+		} else if (!strncmp(clk_name, "cck1", 4)) {
+			clk_id = 1;
+		} else {
+			dev_err(dev, "Unexpected cck clock provider name [%s]\n", clk_name);
+			return -EINVAL;
+		}
+
+		clk = to_clk_regmap(mdf_hw[clk_id]);
+		clk->map = priv->regmap;
+
+		ret = devm_clk_hw_register(dev, mdf_hw[clk_id]);
+		if (ret)
+			return dev_err_probe(dev, ret, "Failed to register %s clock provider",
+					     clk_name);
+
+		clk_data->hws[index] = mdf_hw[clk_id];
+
+		/* Configure the CCKx clock as output */
+		ckgcr |= clk_id ? MDF_CKG_CCK1DIR : MDF_CKG_CCK0DIR;
+
+		index++;
+	}
+
+	/*
+	 * Set num to max number of clock. This allows any clocks indice below maximum
+	 * in of_clk_hw_onecell_get, whatever the actual number of providers.
+	 */
+	clk_data->num = STM32_MDF_MAX_CCK;
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret) {
+		dev_err(dev, "Failed to add %s clock provider: %d\n", clk_name, ret);
+		return ret;
+	}
+
+	/* Configure CKGCR register */
+	return regmap_update_bits(priv->regmap, MDF_CKGCR_REG,
+				  MDF_CKG_CCK1DIR | MDF_CKG_CCK0DIR, ckgcr);
+}
+
+static int stm32_mdf_core_of_cck_get(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct device *dev = &pdev->dev;
+	u32 freq;
+	int ret;
+
+	ret = device_property_read_u32(dev, "clock-frequency", &freq);
+	if (ret < 0) {
+		/* If property does not exist return immediately */
+		if (ret == -EINVAL)
+			return 0;
+
+		dev_err(dev, "Failed to read clock-frequency property: %d\n", ret);
+		return ret;
+	}
+
+	if (!freq) {
+		dev_err(dev, "Null frequency not allowed for cck output frequency\n");
+		return -EINVAL;
+	}
+	priv->cck_freq = freq;
+
+	return 0;
+}
+
+static int stm32_mdf_core_parse_clocks(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct device *dev = &pdev->dev;
+	struct clk *kclk;
+	int ret;
+
+	kclk = devm_clk_get(dev, "ker_ck");
+	if (IS_ERR(kclk))
+		return dev_err_probe(dev, PTR_ERR(kclk), "Failed to get kernel clock\n");
+
+	priv->kclk = kclk;
+	priv->kclk_rate = clk_get_rate(kclk);
+
+	/* CCK0 and CCK1 clocks are optional. Used only in SPI master modes. */
+	ret = stm32_mdf_core_of_cck_get(pdev, priv);
+	if (ret)
+		return ret;
+
+	if (priv->cck_freq) {
+		ret = stm32_mdf_core_cck_divider_set_rate(pdev, priv, priv->kclk_rate);
+		if (ret) {
+			dev_err(dev, "Failed to set cck rate: %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = stm32_mdf_core_register_clock_provider(pdev, priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stm32_mdf_core_parse_of(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct reset_control *rst;
+	struct device *dev = &pdev->dev;
+	struct fwnode_handle *fwnode = dev_fwnode(dev);
+	struct fwnode_handle *handle;
+	struct fwnode_handle **fh;
+	int count, ret, i;
+
+	if (!node)
+		return -EINVAL;
+
+	rst = devm_reset_control_get_optional_exclusive(&pdev->dev, "mdf");
+	if (IS_ERR(rst))
+		return dev_err_probe(dev, PTR_ERR(rst), "Failed to get reset controller\n");
+
+	ret = reset_control_reset(rst);
+	if (ret) {
+		dev_err(&pdev->dev, "reset_control_reset failed %d\n", ret);
+		return ret;
+	}
+
+	ret = stm32_mdf_core_parse_clocks(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	if (device_property_present(&pdev->dev, "st,interleave")) {
+		count = fwnode_property_count_u32(fwnode, "st,interleave");
+		if (count < 2 || count > priv->mdf.nbf) {
+			dev_err(dev, "Wrong interleave filters number [%d]\n", count);
+			return -EINVAL;
+		}
+
+		fh = devm_kzalloc(dev, count * sizeof(*fh), GFP_KERNEL);
+		if (!fh)
+			return -ENOMEM;
+		priv->mdf.fh_interleave = fh;
+
+		for (i = 0; i < count; i++) {
+			handle = fwnode_find_reference(fwnode, "st,interleave", i);
+			if (IS_ERR(handle)) {
+				dev_err(dev, "Failed to read filter handle: %ld\n",
+					PTR_ERR(handle));
+				return PTR_ERR(handle);
+			}
+			priv->mdf.fh_interleave[i] = handle;
+		}
+
+		priv->mdf.nb_interleave = count;
+
+		/* Configure GCR */
+		ret = regmap_update_bits(priv->regmap, MDF_GCR_REG,
+					 MDF_GCR_ILVNB_MASK, MDF_GCR_ILVNB(count - 1));
+	}
+
+	return ret;
+}
+
+static int stm32_mdf_core_identification(struct platform_device *pdev, struct stm32_mdf_priv *priv)
+{
+	struct stm32_mdf *mdf = &priv->mdf;
+	u32 val;
+	int ret;
+
+	ret = regmap_read(priv->regmap, MDF_IPIDR_REG, &val);
+	if (ret)
+		return ret;
+
+	if (val == STM32MP25_MDF_IPIDR_NUMBER) {
+		ret = regmap_read(priv->regmap, MDF_HWCFGR_REG, &val);
+		if (ret)
+			return ret;
+
+		mdf->nbf = FIELD_GET(MDF_HWCFGR_NBF_MASK, val);
+
+		ret = regmap_read(priv->regmap, MDF_VERR_REG, &val);
+
+		dev_dbg(&pdev->dev, "MDF version: %lu.%lu\n", FIELD_GET(MDF_VERR_MAJREV_MASK, val),
+			FIELD_GET(MDF_VERR_MINREV_MASK, val));
+	} else {
+		dev_err(&pdev->dev, "Unexpected ID number: 0x%x\n", val);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32_mdf_core_probe(struct platform_device *pdev)
+{
+	struct stm32_mdf_priv *priv;
+	struct resource *res;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->pdev = pdev;
+	spin_lock_init(&priv->lock);
+
+	priv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(priv->base))
+		return PTR_ERR(priv->base);
+	priv->phys_base = res->start;
+
+	priv->regmap =
+		devm_regmap_init_mmio_clk(&pdev->dev, "ker_ck", priv->base, &stm32_mdf_regmap_cfg);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(&pdev->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	ret = stm32_mdf_core_identification(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_mdf_core_parse_of(pdev, priv);
+	if (ret < 0)
+		return ret;
+
+	INIT_LIST_HEAD(&priv->mdf.sitf_list);
+	INIT_LIST_HEAD(&priv->mdf.filter_list);
+
+	platform_set_drvdata(pdev, priv);
+
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
+	ret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);
+	if (ret)
+		goto pm_put;
+
+	pm_runtime_put(&pdev->dev);
+
+	return 0;
+
+pm_put:
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+
+	return ret;
+}
+
+static int stm32_mdf_core_remove(struct platform_device *pdev)
+{
+	pm_runtime_get_sync(&pdev->dev);
+	of_platform_depopulate(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+
+	return 0;
+}
+
+static int stm32_mdf_core_suspend(struct device *dev)
+{
+	struct stm32_mdf *mdf = dev_get_drvdata(dev);
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	int ret;
+
+	ret = pm_runtime_force_suspend(dev);
+	if (ret)
+		return ret;
+
+	regcache_cache_only(priv->regmap, true);
+	regcache_mark_dirty(priv->regmap);
+
+	/* Balance devm_regmap_init_mmio_clk() clk_prepare() */
+	clk_unprepare(priv->kclk);
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int stm32_mdf_core_resume(struct device *dev)
+{
+	struct stm32_mdf *mdf = dev_get_drvdata(dev);
+	struct stm32_mdf_priv *priv = to_stm32_mdf_priv(mdf);
+	int ret;
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret) {
+		dev_err(dev, "Failed to set pins default state: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare(priv->kclk);
+	if (ret) {
+		dev_err(dev, "Failed to prepare kernel clock: %d\n", ret);
+		goto err_clk;
+	}
+
+	regcache_cache_only(priv->regmap, false);
+	ret = regcache_sync(priv->regmap);
+	if (ret) {
+		dev_err(dev, "Failed to sync cache: %d\n", ret);
+		goto err_cache;
+	}
+
+	return pm_runtime_force_resume(dev);
+
+err_cache:
+	clk_unprepare(priv->kclk);
+err_clk:
+	pinctrl_pm_select_sleep_state(dev);
+
+	return ret;
+}
+
+static int stm32_mdf_core_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int stm32_mdf_core_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_mdf_core_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_mdf_core_suspend, stm32_mdf_core_resume)
+	SET_RUNTIME_PM_OPS(stm32_mdf_core_runtime_suspend, stm32_mdf_core_runtime_resume, NULL)
+};
+
+static const struct of_device_id stm32_mdf_of_match[] = {
+	{ .compatible = "st,stm32mp25-mdf" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_mdf_of_match);
+
+static struct platform_driver stm32_mdf_driver = {
+	.probe = stm32_mdf_core_probe,
+	.remove = stm32_mdf_core_remove,
+	.driver = {
+		.name = "stm32-mdf",
+		.of_match_table = stm32_mdf_of_match,
+		.pm = &stm32_mdf_core_pm_ops,
+	},
+};
+
+module_platform_driver(stm32_mdf_driver);
+
+MODULE_AUTHOR("Olivier Moysan <olivier.moysan@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 MDF driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/stm32-mdf-serial.c b/drivers/iio/adc/stm32-mdf-serial.c
new file mode 100644
index 000000000..011840908
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf-serial.c
@@ -0,0 +1,310 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/regmap.h>
+
+#include "stm32-mdf.h"
+
+#define STM32_MDF_MODE_SZ 12
+
+enum {
+	STM32_MDF_SCKSRC_CCK0,
+	STM32_MDF_SCKSRC_CCK1,
+	STM32_MDF_SCKSRC_CLK,
+	STM32_MDF_SCKSRC_NONE,
+};
+
+struct stm32_mdf_sf_mode {
+	const char *name;
+	u32 mode;
+};
+
+static const struct stm32_mdf_sf_mode stm32_mdf_mode[STM32_MDF_MODE_NB] = {
+	{ "spi", STM32_MDF_MODE_SPI },
+	{ "lf_spi", STM32_MDF_MODE_LF_SPI },
+	{ "manchester_r", STM32_MDF_MODE_MANCHESTER_R },
+	{ "manchester_f", STM32_MDF_MODE_MANCHESTER_F },
+};
+
+static bool stm32_mdf_sitf_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_SITFCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool stm32_mdf_sitf_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MDF_SITFCR_REG:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config stm32_sitf_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = sizeof(u32),
+	.max_register = MDF_SITFCR_REG,
+	.readable_reg = stm32_mdf_sitf_readable_reg,
+	.writeable_reg = stm32_mdf_sitf_writeable_reg,
+	.fast_io = true,
+	/* Do not use regcache as it does not support single register map */
+};
+
+int stm32_mdf_sitf_start(struct stm32_mdf_sitf *sitf)
+{
+	int ret;
+
+	spin_lock(&sitf->lock);
+
+	ret = regmap_set_bits(sitf->regmap, MDF_SITFCR_REG, MDF_SITFCR_SITFEN);
+	if (!ret)
+		sitf->refcnt++;
+
+	spin_unlock(&sitf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_sitf_start);
+
+int stm32_mdf_sitf_stop(struct stm32_mdf_sitf *sitf)
+{
+	int ret = 0;
+
+	spin_lock(&sitf->lock);
+
+	if (!sitf->refcnt) {
+		dev_err(sitf->dev, "Unbalanced serial interface stop ?\n");
+		ret = -EPERM;
+		goto out;
+	} else {
+		sitf->refcnt--;
+	}
+
+	if (!sitf->refcnt)
+		ret = regmap_clear_bits(sitf->regmap, MDF_SITFCR_REG, MDF_SITFCR_SITFEN);
+
+out:
+	spin_unlock(&sitf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(stm32_mdf_sitf_stop);
+
+static int stm32_mdf_sitf_get_clk(struct device *dev, struct stm32_mdf_sitf *sitf)
+{
+	struct clk *sck;
+
+	/* Optional clock. Clock not needed in Manchester mode */
+	sck = clk_get_optional(sitf->dev, 0);
+	if (IS_ERR(sck))
+		return dev_err_probe(sitf->dev, PTR_ERR(sck), "Can't get serial clock\n");
+
+	sitf->sck = sck;
+
+	if (sitf->sck) {
+		if (!strncmp(__clk_get_name(sck), STM32_MDF_CCK0, sizeof(STM32_MDF_CCK0)))
+			sitf->scksrc = STM32_MDF_SCKSRC_CCK0;
+		else if (!strncmp(__clk_get_name(sck), STM32_MDF_CCK1, sizeof(STM32_MDF_CCK1)))
+			sitf->scksrc = STM32_MDF_SCKSRC_CCK1;
+		else
+			sitf->scksrc = STM32_MDF_SCKSRC_CLK;
+	}
+
+	return 0;
+};
+
+static int stm32_mdf_sitf_parse(struct platform_device *pdev, struct stm32_mdf_sitf *sitf)
+{
+	struct device *dev = &pdev->dev;
+	const char *str;
+	int ret, i = 0;
+	u32 idx, mode, sitfcr;
+
+	ret = device_property_read_u32(dev, "reg", &idx);
+	if (ret) {
+		dev_err(dev, "Could not get interface index: %d\n", ret);
+		return ret;
+	}
+
+	if (idx % 0x80) {
+		dev_err(dev, "Unexpected reg property value [%x]\n", idx);
+		return -EINVAL;
+	}
+
+	idx = (idx >> 7) - 1;
+	if (idx > sitf->mdf->nbf) {
+		dev_err(dev, "Interface index [%d] exceeds maximum [%d]\n", idx, sitf->mdf->nbf);
+		return -EINVAL;
+	}
+
+	/* Get SITF mode */
+	ret = device_property_read_string(dev, "st,sitf-mode", &str);
+	if (ret) {
+		dev_err(dev, "Could not get interface mode: %d\n", ret);
+		return ret;
+	}
+
+	while (i < STM32_MDF_MODE_NB) {
+		if (!strncmp(stm32_mdf_mode[i].name, str, STM32_MDF_MODE_SZ)) {
+			mode = stm32_mdf_mode[i].mode;
+			break;
+		}
+		i++;
+	}
+
+	if (i >= STM32_MDF_MODE_NB) {
+		dev_err(dev, "Unknown serial interface mode [%s]\n", str);
+		return -EINVAL;
+	}
+
+	sitf->mode = mode;
+	sitfcr = MDF_SITFCR_SITFMOD(mode);
+
+	ret = stm32_mdf_sitf_get_clk(dev, sitf);
+	if (ret)
+		return ret;
+
+	if (mode == STM32_MDF_MODE_SPI && sitf->scksrc == STM32_MDF_SCKSRC_NONE) {
+		dev_err(dev, "Missing clock for serial interface [%d] in SPI mode\n", idx);
+		return -EINVAL;
+	}
+
+	if (mode == STM32_MDF_MODE_LF_SPI && (sitf->scksrc != STM32_MDF_SCKSRC_CCK0 &&
+					      sitf->scksrc != STM32_MDF_SCKSRC_CCK1)) {
+		dev_err(dev, "Missing CCKx clock for serial interface [%d] in LF_SPI mode\n", idx);
+		return -EINVAL;
+	}
+
+	sitf->id = idx;
+	sitf->node = dev_fwnode(dev);
+	spin_lock_init(&sitf->lock);
+
+	sitfcr |= MDF_SITFCR_SCKSRC(sitf->scksrc);
+
+	/* Configure SITF register */
+	regmap_set_bits(sitf->regmap, MDF_SITFCR_REG, sitfcr);
+
+	dev_dbg(dev, "Serial interface [%d] registered\n", idx);
+
+	return 0;
+}
+
+static int stm32_mdf_sitf_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_mdf_sitf *sitf;
+	struct regmap *regmap;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	sitf = devm_kzalloc(&pdev->dev, sizeof(*sitf), GFP_KERNEL);
+	if (!sitf)
+		return -ENOMEM;
+	sitf->dev = dev;
+	sitf->mdf = dev_get_drvdata(dev->parent);
+
+	base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	regmap = devm_regmap_init_mmio_clk(dev, "ker_ck", base, &stm32_sitf_regmap_cfg);
+	if (IS_ERR(regmap))
+		return dev_err_probe(dev, PTR_ERR(regmap), "Failed to init regmap\n");
+	sitf->regmap = regmap;
+
+	ret = stm32_mdf_sitf_parse(pdev, sitf);
+	if (ret < 0)
+		return ret;
+
+	list_add(&sitf->entry, &sitf->mdf->sitf_list);
+
+	platform_set_drvdata(pdev, sitf);
+
+	return 0;
+}
+
+static int stm32_mdf_sitf_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_mdf_sitf *sitf = dev_get_drvdata(dev);
+
+	list_del(&sitf->entry);
+
+	return 0;
+}
+
+static int stm32_mdf_sitf_suspend(struct device *dev)
+{
+	struct stm32_mdf_sitf *sitf = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pinctrl_pm_select_sleep_state(dev);
+
+	regmap_read(sitf->regmap, MDF_SITFCR_REG, &sitf->sitfcr);
+
+	return ret;
+}
+
+static int stm32_mdf_sitf_resume(struct device *dev)
+{
+	struct stm32_mdf_sitf *sitf = dev_get_drvdata(dev);
+
+	regmap_write(sitf->regmap, MDF_SITFCR_REG, sitf->sitfcr);
+
+	return pinctrl_pm_select_default_state(dev);
+}
+
+static int stm32_mdf_sitf_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int stm32_mdf_sitf_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_mdf_sitf_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_mdf_sitf_suspend, stm32_mdf_sitf_resume)
+	SET_RUNTIME_PM_OPS(stm32_mdf_sitf_runtime_suspend, stm32_mdf_sitf_runtime_resume, NULL)
+};
+
+static const struct of_device_id stm32_mdf_sitf_of_match[] = {
+	{ .compatible = "st,stm32mp25-sitf-mdf" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_mdf_sitf_of_match);
+
+static struct platform_driver stm32_mdf_sitf_driver = {
+	.probe = stm32_mdf_sitf_probe,
+	.remove = stm32_mdf_sitf_remove,
+	.driver = {
+		.name = "stm32-mdf-sitf",
+		.of_match_table = stm32_mdf_sitf_of_match,
+		.pm = &stm32_mdf_sitf_pm_ops,
+	},
+};
+
+module_platform_driver(stm32_mdf_sitf_driver);
+
+MODULE_AUTHOR("Olivier Moysan <olivier.moysan@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 MDF serial driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/stm32-mdf.h b/drivers/iio/adc/stm32-mdf.h
new file mode 100644
index 000000000..830e3b64e
--- /dev/null
+++ b/drivers/iio/adc/stm32-mdf.h
@@ -0,0 +1,314 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * This file is part of STM32 MDF driver
+ *
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ * Author: Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#include <linux/bitfield.h>
+
+/* Register definitions */
+#define MDF_GCR_REG 0x00
+#define MDF_CKGCR_REG 0x04
+#define MDF_HWCFGR_REG 0xff0
+#define MDF_VERR_REG 0xff4
+#define MDF_IPIDR_REG 0xff8
+#define MDF_SIDR_REG 0xffc
+
+/* Registers offsets relative to sitf base address */
+#define MDF_SITFCR_REG 0x00 /* 0x80 * x + offset */
+
+/* Registers offsets relative to filter base address */
+#define MDF_BSMXCR_REG 0x00 /* 0x84 * x + offset */
+#define MDF_DFLTCR_REG 0x04
+#define MDF_DFLTCICR_REG 0x08
+#define MDF_DFLTRSFR_REG 0x0c
+#define MDF_DFLTINTR_REG 0x10
+#define MDF_OLDCR_REG 0x14
+#define MDF_OLDTHLR_REG 0x18
+#define MDF_OLDTHHR_REG 0x1c
+#define MDF_DLYCR_REG 0x20
+#define MDF_SCDCR_REG 0x24
+#define MDF_DFLTIER_REG 0x28
+#define MDF_DFLTISR_REG 0x2C
+#define MDF_OECCR_REG 0x30
+#define MDF_SNPSDR 0x64
+#define MDF_DFLTDR_REG 0x6c
+
+/* MDF_GCR: Global Control Register */
+#define MDF_GCR_TRGO BIT(0)
+#define MDF_GCR_ILVNB_MASK GENMASK(7, 4)
+#define MDF_GCR_ILVNB(v) FIELD_PREP(MDF_GCR_ILVNB_MASK, v)
+
+/* MDF_CKGCR: Clock Generator Control Register */
+#define MDF_CKG_CKGDEN BIT(0)
+#define MDF_CKG_CCK0EN BIT(1)
+#define MDF_CKG_CCK1EN BIT(2)
+#define MDF_CKG_CKGMOD BIT(4)
+#define MDF_CKG_CCK0DIR BIT(5)
+#define MDF_CKG_CCK1DIR BIT(6)
+#define MDF_CKG_TRGSENS BIT(8)
+#define MDF_CKG_TRGSRC_MASK GENMASK(15, 12)
+#define MDF_CKG_TRGSRC(v) FIELD_PREP(MDF_CKG_TRGSRC_MASK, v)
+#define MDF_CKG_CCKDIV_MASK GENMASK(19, 16)
+#define MDF_CKG_CCKDIV_SHIFT 16
+#define MDF_CKG_CCKDIV_WIDTH 4
+#define MDF_CKG_CCKDIV(v) FIELD_PREP(MDF_CKG_CCKDIV_MASK, v)
+#define MDF_CKG_PROCDIV_MASK GENMASK(30, 24)
+#define MDF_CKG_PROCDIV(v) FIELD_PREP(MDF_CKG_PROCDIV_MASK, v)
+#define MDF_CKG_ACTIVE BIT(31)
+
+/* MDF_OR: Option Register */
+#define MDF_OR_OPTION_MASK OPTION(31, 0)
+#define MDF_OR_OPTION(v) FIELD_PREP(MDF_OR_OPTION_MASK, v)
+
+/* MDF_SITFCR: Serial Interface Control Register */
+#define MDF_SITFCR_SITFEN BIT(0)
+#define MDF_SITFCR_SCKSRC_MASK GENMASK(2, 1)
+#define MDF_SITFCR_SCKSRC(v) FIELD_PREP(MDF_SITFCR_SCKSRC_MASK, v)
+#define MDF_SITFCR_SITFMOD_MASK GENMASK(5, 4)
+#define MDF_SITFCR_SITFMOD(v) FIELD_PREP(MDF_SITFCR_SITFMOD_MASK, v)
+#define MDF_SITFCR_STH_MASK GENMASK(12, 8)
+#define MDF_SITFCR_STH(v) FIELD_PREP(MDF_SITFCR_STH_MASK, v)
+#define MDF_SITFCR_ACTIVE BIT(31)
+
+/* MDF_BSMXCR: Bitstream Matrix Control Register */
+#define MDF_BSMXCR_BSSEL_MASK GENMASK(4, 0)
+#define MDF_BSMXCR_BSSEL(v) FIELD_PREP(MDF_BSMXCR_BSSEL_MASK, v)
+#define MDF_BSMXCR_ACTIVE BIT(31)
+
+/* MDF_DFLTCR: Digital Filter Control Register */
+#define MDF_DFLTCR_DFLTEN BIT(0)
+#define MDF_DFLTCR_DMAEN BIT(1)
+#define MDF_DFLTCR_FTH BIT(2)
+#define MDF_DFLTCR_ACQMOD_MASK GENMASK(6, 4)
+#define MDF_DFLTCR_ACQMOD(v) FIELD_PREP(MDF_DFLTCR_ACQMOD_MASK, v)
+#define MDF_DFLTCR_TRGSENS BIT(8)
+#define MDF_DFLTCR_TRGSENS_SET(v) FIELD_PREP(MDF_DFLTCR_TRGSENS, v)
+#define MDF_DFLTCR_TRGSRC_MASK GENMASK(15, 12)
+#define MDF_DFLTCR_TRGSRC(v) FIELD_PREP(MDF_DFLTCR_TRGSRC_MASK, v)
+#define MDF_DFLTCR_SNPSFMT BIT(16)
+#define MDF_DFLTCR_NBDIS_MASK GENMASK(27, 20)
+#define MDF_DFLTCR_NBDIS(v) FIELD_PREP(MDF_DFLTCR_NBDIS_MASK, v)
+#define MDF_DFLTCR_DFLTRUN BIT(30)
+#define MDF_DFLTCR_ACTIVE BIT(31)
+
+/* MDF_DFLTCICR: Digital Filter Configuration Register */
+#define MDF_DFLTCICR_DATSRC_MASK GENMASK(1, 0)
+#define MDF_DFLTCICR_DATSRC(v) FIELD_PREP(MDF_DFLTCICR_DATSRC_MASK, v)
+#define MDF_DFLTCICR_CICMOD_MASK GENMASK(6, 4)
+#define MDF_DFLTCICR_CICMOD(v) FIELD_PREP(MDF_DFLTCICR_CICMOD_MASK, v)
+#define MDF_DFLTCICR_MCICD_MASK GENMASK(16, 8)
+#define MDF_DFLTCICR_MCICD(v) FIELD_PREP(MDF_DFLTCICR_MCICD_MASK, v)
+#define MDF_DFLTCICR_MCICD_MIN 2
+#define MDF_DFLTCICR_SCALE_MASK GENMASK(25, 20)
+#define MDF_DFLTCICR_SCALE(v) FIELD_PREP(MDF_DFLTCICR_SCALE_MASK, v)
+
+/* MDF_DFLTRSFR: Reshape Filter Configuration Register */
+#define MDF_DFLTRSFR_RSFLTBYP BIT(0)
+#define MDF_DFLTRSFR_RSFLTD BIT(4)
+#define MDF_DFLTRSFR_HPFBYP BIT(7)
+#define MDF_DFLTRSFR_HPFC_MASK GENMASK(9, 8)
+#define MDF_DFLTRSFR_HPFC(v) FIELD_PREP(MDF_DFLTRSFR_HPFC_MASK, v)
+
+/* MDF_DFLTINTR: Integrator Configuration Register */
+#define MDF_DFLTINTR_INTDIV_MASK GENMASK(1, 0)
+#define MDF_DFLTINTR_INTDIV(v) FIELD_PREP(MDF_DFLTINTR_INTDIV_MASK, v)
+#define MDF_DFLTINTR_INTVAL_MASK GENMASK(10, 4)
+#define MDF_DFLTINTR_INTVAL(v) FIELD_PREP(MDF_DFLTINTR_INTVAL_MASK, v)
+
+/* MDF_OLDCR: Out-Of Limit Detector Control Register */
+#define MDF_OLDCR_OLDEN_MASK BIT(0)
+#define MDF_OLDCR_OLDEN(v) FIELD_PREP(MDF_OLDCR_OLDEN_MASK, v)
+#define MDF_OLDCR_THINB_MASK BIT(1)
+#define MDF_OLDCR_THINB(v) FIELD_PREP(MDF_OLDCR_THINB_MASK, v)
+#define MDF_OLDCR_BKOLD_MASK GENMASK(7, 4)
+#define MDF_OLDCR_BKOLD(v) FIELD_PREP(MDF_OLDCR_BKOLD_MASK, v)
+#define MDF_OLDCR_ACICN_MASK GENMASK(13, 12)
+#define MDF_OLDCR_ACICN(v) FIELD_PREP(MDF_OLDCR_ACICN_MASK, v)
+#define MDF_OLDCR_ACICD_MASK GENMASK(21, 17)
+#define MDF_OLDCR_ACICD(v) FIELD_PREP(MDF_OLDCR_ACICD_MASK, v)
+#define MDF_OLDCR_ACTIVE_MASK BIT(31)
+#define MDF_OLDCR_ACTIVE(v) FIELD_PREP(MDF_OLDCR_ACTIVE_MASK, v)
+
+/* MDF_OLDxTHLR: OLD Threshold Low Register */
+#define MDF_OLDTHLR_OLDTHL_MASK GENMASK(25, 0)
+#define MDF_OLDTHLR_OLDTHL(v) FIELD_PREP(MDF_OLDTHLR_OLDTHL_MASK, v)
+
+/* MDF_OLDxTHHR: OLD Threshold High Register */
+#define MDF_OLDTHHR_OLDTHH_MASK GENMASK(25, 0)
+#define MDF_OLDTHHR_OLDTHH(v) FIELD_PREP(MDF_OLDTHHR_OLDTHH_MASK, v)
+
+/* MDF_DLYCR: Delay control Register */
+#define MDF_DLYCR_SKPDLY_MASK GENMASK(6, 0)
+#define MDF_DLYCR_SKPDLY(v) FIELD_PREP(MDF_DLYCR_SKPDLY_MASK, v)
+
+/* MDF_SCDCR: Short circuit detector control Register */
+#define MDF_SCDCR_CDEN_MASK BIT(0)
+#define MDF_SCDCR_CDEN(v) FIELD_PREP(MDF_SCDCR_CDEN_MASK, v)
+#define MDF_SCDCR_BKSCD_MASK GENMASK(7, 4)
+#define MDF_SCDCR_BKSCD(v) FIELD_PREP(MDF_SCDCR_BKSCD_MASK, v)
+#define MDF_SCDCR_SCDT_MASK GENMASK(19, 12)
+#define MDF_SCDCR_SCDT(v) FIELD_PREP(MDF_SCDCR_SCDT_MASK, v)
+#define MDF_SCDCR_ACTIVE_MASK BIT(31)
+#define MDF_SCDCR_ACTIVE(v) FIELD_PREP(MDF_SCDCR_ACTIVE_MASK, v)
+
+/* MDF_DFLTIER: DFLT Interrupt enable Register */
+#define MDF_DFLTIER_FTHIE_MASK BIT(0)
+#define MDF_DFLTIER_FTHIE(v) FIELD_PREP(MDF_DFLTIER_FTHIE_MASK, v)
+#define MDF_DFLTIER_DOVRIE_MASK BIT(1)
+#define MDF_DFLTIER_DOVRIE(v) FIELD_PREP(MDF_DFLTIER_DOVRIE_MASK, v)
+#define MDF_DFLTIER_SSDRIE_MASK BIT(2)
+#define MDF_DFLTIER_SSDRIE(v) FIELD_PREP(MDF_DFLTIER_SSDRIE_MASK, v)
+#define MDF_DFLTIER_OLDIE_MASK BIT(4)
+#define MDF_DFLTIER_OLDIE(v) FIELD_PREP(MDF_DFLTIER_OLDIE_MASK, v)
+#define MDF_DFLTIER_SSOVRIE_MASK BIT(7)
+#define MDF_DFLTIER_SSOVRIE(v) FIELD_PREP(MDF_DFLTIER_SSOVRIE_MASK, v)
+#define MDF_DFLTIER_SCDIE_MASK BIT(8)
+#define MDF_DFLTIER_SCDIE(v) FIELD_PREP(MDF_DFLTIER_SCDIE_MASK, v)
+#define MDF_DFLTIER_SATIE_MASK BIT(9)
+#define MDF_DFLTIER_SATIE(v) FIELD_PREP(MDF_DFLTIER_SATIE_MASK, v)
+#define MDF_DFLTIER_CKABIE_MASK BIT(10)
+#define MDF_DFLTIER_CKABIE(v) FIELD_PREP(MDF_DFLTIER_CKABIE_MASK, v)
+#define MDF_DFLTIER_RFOVRIE_MASK BIT(11)
+#define MDF_DFLTIER_RFOVRIE(v) FIELD_PREP(MDF_DFLTIER_RFOVRIE_MASK, v)
+
+/* MDF_DFLTISR: DFLT Interrupt status Register */
+#define MDF_DFLTISR_FTHF_MASK BIT(0)
+#define MDF_DFLTISR_FTHF(v) FIELD_PREP(MDF_DFLTISR_FTHF_MASK, v)
+#define MDF_DFLTISR_DOVRF_MASK BIT(1)
+#define MDF_DFLTISR_DOVRF(v) FIELD_PREP(MDF_DFLTISR_DOVRF_MASK, v)
+#define MDF_DFLTISR_SSDRF_MASK BIT(2)
+#define MDF_DFLTISR_SSDRF(v) FIELD_PREP(MDF_DFLTISR_SSDRF_MASK, v)
+#define MDF_DFLTISR_OLDF_MASK BIT(4)
+#define MDF_DFLTISR_OLDF(v) FIELD_PREP(MDF_DFLTISR_OLDF_MASK, v)
+#define MDF_DFLTISR_SSOVRF_MASK BIT(7)
+#define MDF_DFLTISR_SSOVRF(v) FIELD_PREP(MDF_DFLTISR_SSOVRF_MASK, v)
+#define MDF_DFLTISR_SCDF_MASK BIT(8)
+#define MDF_DFLTISR_SCDF(v) FIELD_PREP(MDF_DFLTISR_SCDF_MASK, v)
+#define MDF_DFLTISR_SATF_MASK BIT(9)
+#define MDF_DFLTISR_SATF(v) FIELD_PREP(MDF_DFLTISR_SATF_MASK, v)
+#define MDF_DFLTISR_CKABF_MASK BIT(10)
+#define MDF_DFLTISR_CKABF(v) FIELD_PREP(MDF_DFLTISR_CKABF_MASK, v)
+#define MDF_DFLTISR_RFOVRF_MASK BIT(11)
+#define MDF_DFLTISR_RFOVRF(v) FIELD_PREP(MDF_DFLTISR_RFOVRF_MASK, v)
+
+/* MDF_OECCR: Offset Error Compensation Control Register */
+#define MDF_OECCR_OFFSET_MASK GENMASK(25, 0)
+#define MDF_OECCR_OFFSET(v) FIELD_PREP(MDF_OECCR_OFFSET_MASK, v)
+
+/* MDF_SNPSDR:  Snapshot Data Register */
+#define MDF_SNPSDR_MCICDC_MASK GENMASK(8, 0)
+#define MDF_SNPSDR_MCICDC(v) FIELD_PREP(MDF_SNPSDR_MCICDC_MASK, v)
+#define MDF_SNPSDR_EXTSDR_MASK GENMASK(15, 9)
+#define MDF_SNPSDR_EXTSDR(v) FIELD_PREP(MDF_SNPSDR_EXTSDR_MASK, v)
+#define MDF_SNPSDR_SDR_MASK GENMASK(31, 16)
+#define MDF_SNPSDR_SDR(v) FIELD_PREP(MDF_SNPSDR_SDR_MASK, v)
+
+/* MDF_DFLTDR: Digital Filter Data Register */
+#define MDF_DFLTDR_DR_MASK GENMASK(31, 8)
+#define MDF_DFLTDR_DR(v) FIELD_PREP(MDF_DFLTDR_DR_MASK, v)
+
+/* MDF_HWCFGR: Hardware configuration register */
+#define MDF_HWCFGR_FIFO_SIZE_MASK GENMASK(7, 0)
+#define MDF_HWCFGR_FIFO_SIZE(v) FIELD_PREP(MDF_HWCFGR_FIFO_SIZE_MASK, v)
+#define MDF_HWCFGR_NBF_MASK GENMASK(15, 8)
+#define MDF_HWCFGR_NBF(v) FIELD_PREP(MDF_HWCFGR_NBF_MASK, v)
+#define MDF_HWCFGR_FLT_CFG_MASK GENMASK(19, 16)
+#define MDF_HWCFGR_FLT_CFG(v) FIELD_PREP(MDF_HWCFGR_FLT_CFG_MASK, v)
+#define MDF_HWCFGR_SAD_MASK GENMASK(23, 20)
+#define MDF_HWCFGR_SAD(v) FIELD_PREP(MDF_HWCFGR_SAD_MASK, v)
+#define MDF_HWCFGR_OPTION_MASK GENMASK(31, 24)
+#define MDF_HWCFGR_OPTION(v) FIELD_PREP(MDF_HWCFGR_OPTION_MASK, v)
+
+/* MDF_VERR: Version Register */
+#define MDF_VERR_MINREV_MASK GENMASK(3, 0)
+#define MDF_VERR_MINREV(v) FIELD_PREP(MDF_VERR_MINREV_MASK, v)
+#define MDF_VERR_MAJREV_MASK GENMASK(7, 4)
+#define MDF_VERR_MAJREV(v) FIELD_PREP(MDF_VERR_MAJREV_MASK, v)
+
+/* MDF_IPIDR: Identification Register */
+#define MDF_IPIDR_ID_MASK GENMASK(31, 0)
+#define MDF_IPIDR_ID_MINREV(v) FIELD_PREP(MDF_IPIDR_ID_MASK, v)
+
+/* MDF_SIDR: Size Identification Register */
+#define MDF_SIDR_SID_MASK GENMASK(31, 0)
+#define MDF_SIDR_SID(v) FIELD_PREP(MDF_SIDR_SID_MASK, v)
+
+#define MDF_PROCDIV_MAX 512
+#define MDF_CCKDIV_MAX 16
+
+#define STM32MP25_MDF_IPIDR_NUMBER 0x00110032
+
+#define STM32_MDF_CCK0 "clk_cck0"
+#define STM32_MDF_CCK1 "clk_cck1"
+
+enum stm32_sitf_mode {
+	STM32_MDF_MODE_LF_SPI,
+	STM32_MDF_MODE_SPI,
+	STM32_MDF_MODE_MANCHESTER_R,
+	STM32_MDF_MODE_MANCHESTER_F,
+	STM32_MDF_MODE_NB,
+};
+
+/*
+ * struct stm32_mdf_sitf - STM32 MDF serial interface data
+ * @entry: serial interface list head
+ * @dev: pointer to parent device
+ * @regmap: regmap for register read/write
+ * @mdf: mdf common data pointer
+ * @node: serial interface node handle
+ * @sck: sitf clock handle
+ * @base: sitf registers base cpu addr
+ * @lock: sitf state manegement lock
+ * @refcnt: sitf usage reference counter
+ * @scksrc: sitf clock source
+ * @id: serial interface index
+ * @mode: sitf mode
+ * @sitfcr: sitf configuration register backup
+ */
+struct stm32_mdf_sitf {
+	struct list_head entry;
+	struct device *dev;
+	struct regmap *regmap;
+	struct stm32_mdf *mdf;
+	struct fwnode_handle *node;
+	struct clk *sck;
+	void __iomem *base;
+	spinlock_t lock; /* Manage race conditions on sitf state */
+	unsigned int refcnt;
+	unsigned int scksrc;
+	u32 id;
+	u32 mode;
+	u32 sitfcr;
+};
+
+/*
+ * struct stm32_mdf - STM32 MDF driver common data (for all instances)
+ * @sitf_list: pointer to serial interfaces list
+ * @filter_list: pointer to filter interfaces list
+ * @fh_interleave: interleaved filter handle list pointer
+ * @fproc: processing clock frequency
+ * @nbf: total number of digital filters
+ * @nb_interleave: number of interleaved filters
+ */
+struct stm32_mdf {
+	struct list_head sitf_list;
+	struct list_head filter_list;
+	struct fwnode_handle **fh_interleave;
+	unsigned long fproc;
+	unsigned int nbf;
+	unsigned int nb_interleave;
+};
+
+int stm32_mdf_core_start_mdf(struct stm32_mdf *mdf);
+int stm32_mdf_core_stop_mdf(struct stm32_mdf *mdf);
+int stm32_mdf_core_trigger(struct stm32_mdf *mdf);
+int stm32_mdf_core_restore_cck(struct stm32_mdf *mdf);
+int stm32_mdf_core_lock_kclk_rate(struct stm32_mdf *mdf);
+void stm32_mdf_core_unlock_kclk_rate(struct stm32_mdf *mdf);
+unsigned long stm32_mdf_core_get_cck(struct stm32_mdf *mdf);
+
+int stm32_mdf_sitf_start(struct stm32_mdf_sitf *sitf);
+int stm32_mdf_sitf_stop(struct stm32_mdf_sitf *sitf);
diff --git a/drivers/iio/trigger/stm32-lptimer-trigger.c b/drivers/iio/trigger/stm32-lptimer-trigger.c
index 2e447a3f0..77c74a031 100644
--- a/drivers/iio/trigger/stm32-lptimer-trigger.c
+++ b/drivers/iio/trigger/stm32-lptimer-trigger.c
@@ -16,16 +16,43 @@
 #include <linux/platform_device.h>
 #include <linux/property.h>
 
-/* List Low-Power Timer triggers */
-static const char * const stm32_lptim_triggers[] = {
-	LPTIM1_OUT,
-	LPTIM2_OUT,
-	LPTIM3_OUT,
+#define MAX_TRIGGERS 2
+
+struct stm32_lptim_cfg {
+	const char * const (*triggers)[MAX_TRIGGERS];
+	unsigned int nb_triggers;
+};
+
+/* List Low-Power Timer triggers for H7, MP13, MP15 */
+static const char * const stm32_lptim_triggers[][MAX_TRIGGERS] = {
+	{ LPTIM1_OUT,},
+	{ LPTIM2_OUT,},
+	{ LPTIM3_OUT,},
+};
+
+/* List Low-Power Timer triggers for STM32MP25 */
+static const char * const stm32mp25_lptim_triggers[][MAX_TRIGGERS] = {
+	{ LPTIM1_CH1, LPTIM1_CH2, },
+	{ LPTIM2_CH1, LPTIM2_CH2, },
+	{ LPTIM3_CH1,},
+	{ LPTIM4_CH1,},
+	{ LPTIM5_OUT,},
+};
+
+static const struct stm32_lptim_cfg stm32mp15_lptim_cfg = {
+	.triggers = stm32_lptim_triggers,
+	.nb_triggers = ARRAY_SIZE(stm32_lptim_triggers),
+};
+
+static const struct stm32_lptim_cfg stm32mp25_lptim_cfg = {
+	.triggers = stm32mp25_lptim_triggers,
+	.nb_triggers = ARRAY_SIZE(stm32mp25_lptim_triggers),
 };
 
 struct stm32_lptim_trigger {
 	struct device *dev;
-	const char *trg;
+	const char * const *triggers;
+	struct list_head tr_list;
 };
 
 static int stm32_lptim_validate_device(struct iio_trigger *trig,
@@ -54,24 +81,47 @@ bool is_stm32_lptim_trigger(struct iio_trigger *trig)
 }
 EXPORT_SYMBOL(is_stm32_lptim_trigger);
 
-static int stm32_lptim_setup_trig(struct stm32_lptim_trigger *priv)
+static void stm32_lptim_unregister_triggers(struct stm32_lptim_trigger *priv)
 {
-	struct iio_trigger *trig;
+	struct iio_trigger *tr;
 
-	trig = devm_iio_trigger_alloc(priv->dev, "%s", priv->trg);
-	if  (!trig)
-		return -ENOMEM;
+	list_for_each_entry(tr, &priv->tr_list, alloc_list)
+		iio_trigger_unregister(tr);
+}
+
+static int stm32_lptim_register_triggers(struct stm32_lptim_trigger *priv)
+{
+	const char * const *cur = priv->triggers;
+	int ret;
 
-	trig->dev.parent = priv->dev->parent;
-	trig->ops = &stm32_lptim_trigger_ops;
-	iio_trigger_set_drvdata(trig, priv);
+	INIT_LIST_HEAD(&priv->tr_list);
 
-	return devm_iio_trigger_register(priv->dev, trig);
+	while (cur && *cur) {
+		struct iio_trigger *trig;
+
+		trig = devm_iio_trigger_alloc(priv->dev, "%s", *cur);
+		if  (!trig)
+			return -ENOMEM;
+
+		trig->dev.parent = priv->dev->parent;
+		trig->ops = &stm32_lptim_trigger_ops;
+		iio_trigger_set_drvdata(trig, priv);
+
+		ret = iio_trigger_register(trig);
+		if (ret)
+			return ret;
+
+		list_add_tail(&trig->alloc_list, &priv->tr_list);
+		cur++;
+	}
+
+	return 0;
 }
 
 static int stm32_lptim_trigger_probe(struct platform_device *pdev)
 {
 	struct stm32_lptim_trigger *priv;
+	struct stm32_lptim_cfg const *lptim_cfg;
 	u32 index;
 	int ret;
 
@@ -82,29 +132,44 @@ static int stm32_lptim_trigger_probe(struct platform_device *pdev)
 	if (device_property_read_u32(&pdev->dev, "reg", &index))
 		return -EINVAL;
 
-	if (index >= ARRAY_SIZE(stm32_lptim_triggers))
+	lptim_cfg = device_get_match_data(&pdev->dev);
+
+	if (index >= lptim_cfg->nb_triggers)
 		return -EINVAL;
 
 	priv->dev = &pdev->dev;
-	priv->trg = stm32_lptim_triggers[index];
+	priv->triggers = lptim_cfg->triggers[index];
 
-	ret = stm32_lptim_setup_trig(priv);
-	if (ret)
+	ret = stm32_lptim_register_triggers(priv);
+	if (ret) {
+		stm32_lptim_unregister_triggers(priv);
 		return ret;
+	}
 
 	platform_set_drvdata(pdev, priv);
 
 	return 0;
 }
 
+static int stm32_lptim_trigger_remove(struct platform_device *pdev)
+{
+	struct stm32_lptim_trigger *priv = platform_get_drvdata(pdev);
+
+	stm32_lptim_unregister_triggers(priv);
+
+	return 0;
+}
+
 static const struct of_device_id stm32_lptim_trig_of_match[] = {
-	{ .compatible = "st,stm32-lptimer-trigger", },
+	{ .compatible = "st,stm32-lptimer-trigger", .data = (void *)&stm32mp15_lptim_cfg },
+	{ .compatible = "st,stm32mp25-lptimer-trigger", .data = (void *)&stm32mp25_lptim_cfg},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_lptim_trig_of_match);
 
 static struct platform_driver stm32_lptim_trigger_driver = {
 	.probe = stm32_lptim_trigger_probe,
+	.remove = stm32_lptim_trigger_remove,
 	.driver = {
 		.name = "stm32-lptimer-trigger",
 		.of_match_table = stm32_lptim_trig_of_match,
diff --git a/drivers/iio/trigger/stm32-timer-trigger.c b/drivers/iio/trigger/stm32-timer-trigger.c
index 3643c4afa..cd78a7f6b 100644
--- a/drivers/iio/trigger/stm32-timer-trigger.c
+++ b/drivers/iio/trigger/stm32-timer-trigger.c
@@ -38,6 +38,9 @@ static const void *triggers_table[][MAX_TRIGGERS] = {
 	{ TIM15_TRGO,},
 	{ TIM16_OC1,},
 	{ TIM17_OC1,},
+	{ }, /* timer 18 */
+	{ }, /* timer 19 */
+	{ TIM20_TRGO, TIM20_TRGO2, TIM20_OC1, TIM20_OC2, TIM20_OC3, },
 };
 
 /* List the triggers accepted by each timer */
@@ -430,10 +433,8 @@ static int stm32_register_iio_triggers(struct stm32_timer_trigger *priv)
 		iio_trigger_set_drvdata(trig, priv);
 
 		ret = iio_trigger_register(trig);
-		if (ret) {
-			stm32_unregister_iio_triggers(priv);
+		if (ret)
 			return ret;
-		}
 
 		list_add_tail(&trig->alloc_list, &priv->tr_list);
 		cur++;
@@ -783,7 +784,7 @@ static int stm32_timer_trigger_probe(struct platform_device *pdev)
 		return -EINVAL;
 
 	/* Create an IIO device only if we have triggers to be validated */
-	if (*cfg->valids_table[index])
+	if (cfg->valids_table && *cfg->valids_table[index])
 		priv = stm32_setup_counter_device(dev);
 	else
 		priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
@@ -796,13 +797,16 @@ static int stm32_timer_trigger_probe(struct platform_device *pdev)
 	priv->clk = ddata->clk;
 	priv->max_arr = ddata->max_arr;
 	priv->triggers = triggers_table[index];
-	priv->valids = cfg->valids_table[index];
+	if (cfg->valids_table && *cfg->valids_table[index])
+		priv->valids = cfg->valids_table[index];
 	stm32_timer_detect_trgo2(priv);
 	mutex_init(&priv->lock);
 
 	ret = stm32_register_iio_triggers(priv);
-	if (ret)
+	if (ret) {
+		stm32_unregister_iio_triggers(priv);
 		return ret;
+	}
 
 	platform_set_drvdata(pdev, priv);
 
@@ -890,6 +894,17 @@ static const struct stm32_timer_trigger_cfg stm32h7_timer_trg_cfg = {
 	.num_valids_table = ARRAY_SIZE(stm32h7_valids_table),
 };
 
+static const struct stm32_timer_trigger_cfg stm32mp25_timer_trg_cfg = {
+	/*
+	 * valids_table not used: counter framework is now superseding the deprecated IIO
+	 * counter interface (IIO_COUNT), so don't support it. num_valids_table is only
+	 * kept here to register the IIO HW triggers. valids_table should be moved at some
+	 * point to the stm32-timer-cnt driver instead (on-going discussions at the time of
+	 * writing).
+	 */
+	.num_valids_table = ARRAY_SIZE(triggers_table),
+};
+
 static const struct of_device_id stm32_trig_of_match[] = {
 	{
 		.compatible = "st,stm32-timer-trigger",
@@ -897,6 +912,9 @@ static const struct of_device_id stm32_trig_of_match[] = {
 	}, {
 		.compatible = "st,stm32h7-timer-trigger",
 		.data = (void *)&stm32h7_timer_trg_cfg,
+	}, {
+		.compatible = "st,stm32mp25-timer-trigger",
+		.data = (void *)&stm32mp25_timer_trg_cfg,
 	},
 	{ /* end node */ },
 };
diff --git a/drivers/input/touchscreen/edt-ft5x06.c b/drivers/input/touchscreen/edt-ft5x06.c
index 9ac137861..198960488 100644
--- a/drivers/input/touchscreen/edt-ft5x06.c
+++ b/drivers/input/touchscreen/edt-ft5x06.c
@@ -31,6 +31,8 @@
 #include <linux/uaccess.h>
 
 #include <asm/unaligned.h>
+#include <linux/of_device.h>
+#include <drm/drm_mipi_dsi.h>
 
 #define WORK_REGISTER_THRESHOLD		0x00
 #define WORK_REGISTER_REPORT_RATE	0x08
@@ -972,6 +974,10 @@ static int edt_ft5x06_ts_identify(struct i2c_client *client,
 			snprintf(model_name, EDT_NAME_LEN, "EP%i%i0ML00",
 				rdbuf[0] >> 4, rdbuf[0] & 0x0F);
 			break;
+		case 0x51:   /* Rocktech Rk043fn48h Display */
+			tsdata->version = EV_FT;
+			snprintf(model_name, EDT_NAME_LEN, "FT5336GQQ");
+			break;
 		case 0x5a:   /* Solomon Goldentek Display */
 			snprintf(model_name, EDT_NAME_LEN, "GKTW50SCED1R0");
 			break;
@@ -1137,13 +1143,38 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 	const struct edt_i2c_chip_data *chip_data;
 	struct edt_ft5x06_ts_data *tsdata;
 	u8 buf[2] = { 0xfc, 0x00 };
+	struct mipi_dsi_device *panel;
+	struct device_node *np;
 	struct input_dev *input;
 	unsigned long irq_flags;
+	struct device_link *dlink;
 	int error;
 	u32 report_rate;
 
 	dev_dbg(&client->dev, "probing for EDT FT5x06 I2C\n");
 
+	np = of_parse_phandle(client->dev.of_node, "panel", 0);
+	if (np) {
+		panel = of_find_mipi_dsi_device_by_node(np);
+		of_node_put(np);
+		if (!panel)
+			return -EPROBE_DEFER;
+
+		dlink = device_link_add(&client->dev, &panel->dev, DL_FLAG_AUTOREMOVE_CONSUMER);
+
+		if (IS_ERR(dlink)) {
+			error = PTR_ERR(dlink);
+			dev_err(&client->dev,
+				"Failed to add link to device %d\n", error);
+			return error;
+		}
+
+		if (dlink && dlink->status != DL_STATE_CONSUMER_PROBE)
+			return -EPROBE_DEFER;
+
+		put_device(&panel->dev);
+	}
+
 	tsdata = devm_kzalloc(&client->dev, sizeof(*tsdata), GFP_KERNEL);
 	if (!tsdata) {
 		dev_err(&client->dev, "failed to allocate driver data.\n");
@@ -1255,7 +1286,7 @@ static int edt_ft5x06_ts_probe(struct i2c_client *client,
 
 	error = edt_ft5x06_ts_identify(client, tsdata);
 	if (error) {
-		dev_err(&client->dev, "touchscreen probe failed\n");
+		dev_dbg(&client->dev, "touchscreen probe failed\n");
 		return error;
 	}
 
diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index 6de64b3f9..1d700ec1d 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -16,6 +16,7 @@
 #include <linux/firmware.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <drm/drm_mipi_dsi.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/platform_data/x86/soc.h>
@@ -183,13 +184,7 @@ int goodix_i2c_read(struct i2c_client *client, u16 reg, u8 *buf, int len)
 	msgs[1].buf   = buf;
 
 	ret = i2c_transfer(client->adapter, msgs, 2);
-	if (ret >= 0)
-		ret = (ret == ARRAY_SIZE(msgs) ? 0 : -EIO);
-
-	if (ret)
-		dev_err(&client->dev, "Error reading %d bytes from 0x%04x: %d\n",
-			len, reg, ret);
-	return ret;
+	return ret < 0 ? ret : (ret != ARRAY_SIZE(msgs) ? -EIO : 0);
 }
 
 /**
@@ -220,15 +215,8 @@ int goodix_i2c_write(struct i2c_client *client, u16 reg, const u8 *buf, int len)
 	msg.len = len + 2;
 
 	ret = i2c_transfer(client->adapter, &msg, 1);
-	if (ret >= 0)
-		ret = (ret == 1 ? 0 : -EIO);
-
 	kfree(addr_buf);
-
-	if (ret)
-		dev_err(&client->dev, "Error writing %d bytes to 0x%04x: %d\n",
-			len, reg, ret);
-	return ret;
+	return ret < 0 ? ret : (ret != 1 ? -EIO : 0);
 }
 
 int goodix_i2c_write_u8(struct i2c_client *client, u16 reg, u8 value)
@@ -270,8 +258,11 @@ static int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data)
 	do {
 		error = goodix_i2c_read(ts->client, addr, data,
 					header_contact_keycode_size);
-		if (error)
+		if (error) {
+			dev_dbg(&ts->client->dev, "I2C transfer error: %d\n",
+					error);
 			return error;
+		}
 
 		if (data[0] & GOODIX_BUFFER_STATUS_READY) {
 			touch_num = data[0] & 0x0f;
@@ -508,7 +499,9 @@ static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
 	struct goodix_ts_data *ts = dev_id;
 
 	goodix_process_events(ts);
-	goodix_i2c_write_u8(ts->client, GOODIX_READ_COOR_ADDR, 0);
+
+	if (goodix_i2c_write_u8(ts->client, GOODIX_READ_COOR_ADDR, 0) < 0)
+		dev_dbg(&ts->client->dev, "I2C write end_cmd error\n");
 
 	return IRQ_HANDLED;
 }
@@ -633,9 +626,11 @@ int goodix_send_cfg(struct goodix_ts_data *ts, const u8 *cfg, int len)
 		return error;
 
 	error = goodix_i2c_write(ts->client, ts->chip->config_addr, cfg, len);
-	if (error)
+	if (error) {
+		dev_err(&ts->client->dev, "Failed to write config data: %d",
+			error);
 		return error;
-
+	}
 	dev_dbg(&ts->client->dev, "Config sent successfully.");
 
 	/* Let the firmware reconfigure itself, so sleep for 10ms */
@@ -1098,8 +1093,10 @@ static int goodix_read_version(struct goodix_ts_data *ts)
 	char id_str[GOODIX_ID_MAX_LEN + 1];
 
 	error = goodix_i2c_read(ts->client, GOODIX_REG_ID, buf, sizeof(buf));
-	if (error)
+	if (error) {
+		dev_err(&ts->client->dev, "read version failed: %d\n", error);
 		return error;
+	}
 
 	memcpy(id_str, buf, GOODIX_ID_MAX_LEN);
 	id_str[GOODIX_ID_MAX_LEN] = 0;
@@ -1125,10 +1122,13 @@ static int goodix_i2c_test(struct i2c_client *client)
 	u8 test;
 
 	while (retry++ < 2) {
-		error = goodix_i2c_read(client, GOODIX_REG_ID, &test, 1);
+		error = goodix_i2c_read(client, GOODIX_REG_ID,
+					&test, 1);
 		if (!error)
 			return 0;
 
+		dev_err(&client->dev, "i2c test failed attempt %d: %d\n",
+			retry, error);
 		msleep(20);
 	}
 
@@ -1315,10 +1315,35 @@ static int goodix_ts_probe(struct i2c_client *client,
 {
 	struct goodix_ts_data *ts;
 	const char *cfg_name;
+	struct mipi_dsi_device *panel;
+	struct device_node *np;
+	struct device_link *dlink;
 	int error;
 
 	dev_dbg(&client->dev, "I2C Address: 0x%02x\n", client->addr);
 
+	np = of_parse_phandle(client->dev.of_node, "panel", 0);
+	if (np) {
+		panel = of_find_mipi_dsi_device_by_node(np);
+		of_node_put(np);
+		if (!panel)
+			return -EPROBE_DEFER;
+
+		dlink = device_link_add(&client->dev, &panel->dev, DL_FLAG_AUTOREMOVE_CONSUMER);
+
+		if (IS_ERR(dlink)) {
+			error = PTR_ERR(dlink);
+			dev_err(&client->dev,
+				"Failed to add link to device %d\n", error);
+			return error;
+		}
+
+		if (dlink && dlink->status != DL_STATE_CONSUMER_PROBE)
+			return -EPROBE_DEFER;
+
+		put_device(&panel->dev);
+	}
+
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
 		dev_err(&client->dev, "I2C check functionality failed.\n");
 		return -ENXIO;
@@ -1366,6 +1391,26 @@ static int goodix_ts_probe(struct i2c_client *client,
 		error = goodix_reset(ts);
 		if (error)
 			return error;
+	} else {
+		/* reset the controller */
+		if (ts->gpiod_rst) {
+			error = gpiod_direction_output(ts->gpiod_rst, 1);
+			if (error) {
+				dev_err(&client->dev, "Gpio reset failed.\n");
+				return error;
+			}
+
+			msleep(20);
+
+			error = gpiod_direction_output(ts->gpiod_rst, 0);
+			if (error) {
+				dev_err(&client->dev, "Gpio unreset failed.\n");
+				return error;
+			}
+
+			/* need a delay after reset to test I2C */
+			msleep(100);
+		}
 	}
 
 	error = goodix_i2c_test(client);
@@ -1385,8 +1430,10 @@ static int goodix_ts_probe(struct i2c_client *client,
 		return error;
 
 	error = goodix_read_version(ts);
-	if (error)
+	if (error) {
+		dev_err(&client->dev, "Read version failed.\n");
 		return error;
+	}
 
 	ts->chip = goodix_get_chip_data(ts->id);
 
@@ -1463,6 +1510,7 @@ static int __maybe_unused goodix_suspend(struct device *dev)
 	error = goodix_i2c_write_u8(ts->client, GOODIX_REG_COMMAND,
 				    GOODIX_CMD_SCREEN_OFF);
 	if (error) {
+		dev_err(&ts->client->dev, "Screen off command failed\n");
 		goodix_irq_direction_input(ts);
 		goodix_request_irq(ts);
 		return -EAGAIN;
@@ -1505,7 +1553,10 @@ static int __maybe_unused goodix_resume(struct device *dev)
 
 	error = goodix_i2c_read(ts->client, ts->chip->config_addr,
 				&config_ver, 1);
-	if (!error && config_ver != ts->config[0])
+	if (error)
+		dev_warn(dev, "Error reading config version: %d, resetting controller\n",
+			 error);
+	else if (config_ver != ts->config[0])
 		dev_info(dev, "Config version mismatch %d != %d, resetting controller\n",
 			 config_ver, ts->config[0]);
 
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index a29a426e4..99b6ce023 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -395,6 +395,15 @@ config LS_SCFG_MSI
 config PARTITION_PERCPU
 	bool
 
+config STM32MP_EXTI
+	tristate "STM32MP extended interrupts and event controller"
+	depends on (ARCH_STM32 && !ARM_SINGLE_ARMV7M) || COMPILE_TEST
+	default y
+	select IRQ_DOMAIN
+	select GENERIC_IRQ_CHIP
+	help
+	  Support STM32MP EXTI (extended interrupts and event) controller.
+
 config STM32_EXTI
 	bool
 	select IRQ_DOMAIN
@@ -696,4 +705,11 @@ config SUNPLUS_SP7021_INTC
 	  chained controller, routing all interrupt source in P-Chip to
 	  the primary controller on C-Chip.
 
+config RPMSG_IRQ
+	tristate "RPMSG irq driver"
+	depends on RPMSG
+	select IRQ_DOMAIN
+	help
+	  Support for the RPMSG Interrupt Controller.
+
 endmenu
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 87b49a109..9029d1f0a 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -85,6 +85,7 @@ obj-$(CONFIG_MVEBU_SEI)			+= irq-mvebu-sei.o
 obj-$(CONFIG_LS_EXTIRQ)			+= irq-ls-extirq.o
 obj-$(CONFIG_LS_SCFG_MSI)		+= irq-ls-scfg-msi.o
 obj-$(CONFIG_ARCH_ASPEED)		+= irq-aspeed-vic.o irq-aspeed-i2c-ic.o irq-aspeed-scu-ic.o
+obj-$(CONFIG_STM32MP_EXTI)		+= irq-stm32mp-exti.o
 obj-$(CONFIG_STM32_EXTI) 		+= irq-stm32-exti.o
 obj-$(CONFIG_QCOM_IRQ_COMBINER)		+= qcom-irq-combiner.o
 obj-$(CONFIG_IRQ_UNIPHIER_AIDET)	+= irq-uniphier-aidet.o
@@ -121,3 +122,4 @@ obj-$(CONFIG_IRQ_IDT3243X)		+= irq-idt3243x.o
 obj-$(CONFIG_APPLE_AIC)			+= irq-apple-aic.o
 obj-$(CONFIG_MCHP_EIC)			+= irq-mchp-eic.o
 obj-$(CONFIG_SUNPLUS_SP7021_INTC)	+= irq-sp7021-intc.o
+obj-$(CONFIG_RPMSG_IRQ)			+= irq-rpmsg.o
diff --git a/drivers/irqchip/irq-rpmsg.c b/drivers/irqchip/irq-rpmsg.c
new file mode 100644
index 000000000..f0f15ccb9
--- /dev/null
+++ b/drivers/irqchip/irq-rpmsg.c
@@ -0,0 +1,321 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 STMicroelectronics.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/rpmsg.h>
+
+#define VIRT_INTC_PEND		0x01U
+#define VIRT_INTC_CFG		0x02U
+
+#define IRQS_PER_BANK 32
+#define TO_BANK_ID(_hwirq)	((_hwirq) / IRQS_PER_BANK)
+#define TO_BANK_IRQ(_hwirq)	((_hwirq) % IRQS_PER_BANK)
+#define RPMSG_INTC_TIMEOUT	msecs_to_jiffies(50)
+
+struct rpmsg_intc_msg {
+	u8 reg;
+	u32 val;
+	u32 bank_id;
+};
+
+struct rpmsg_intc_bank {
+	u32 mask;		/* 1: activated 0: disabled */
+};
+
+struct rpmsg_irq_dev {
+	struct platform_device	*pdev;
+	atomic_t initialized;
+
+	struct irq_domain *irqd;
+
+	u32 nb_bank;
+	struct rpmsg_intc_bank *banks;
+
+	struct rpmsg_device *rpdev;
+	struct rpmsg_driver rpdrv;
+
+	struct completion complete;
+	struct work_struct irqrpmsg_work;
+};
+
+#define to_rpmsg_driver(__d) container_of(__d, struct rpmsg_driver, drv)
+#define to_rpmsg_irq(__d) container_of(__d, struct rpmsg_irq_dev, rpdrv)
+
+static void irq_rpmsg_mask_irq(struct irq_data *d)
+{
+	struct rpmsg_irq_dev *rirq_dev = irq_data_get_irq_chip_data(d);
+	struct rpmsg_intc_bank *bank = &rirq_dev->banks[TO_BANK_ID(d->hwirq)];
+
+	bank->mask &= ~BIT(TO_BANK_IRQ(d->hwirq));
+}
+
+static void irq_rpmsg_unmask_irq(struct irq_data *d)
+{
+	struct rpmsg_irq_dev *rirq_dev = irq_data_get_irq_chip_data(d);
+	struct rpmsg_intc_bank *bank = &rirq_dev->banks[TO_BANK_ID(d->hwirq)];
+
+	bank->mask |= BIT(TO_BANK_IRQ(d->hwirq));
+}
+
+static struct irq_chip irq_rpmsg_chip = {
+	.name		= "irq-rpmsg",
+	.irq_mask	= irq_rpmsg_mask_irq,
+	.irq_unmask	= irq_rpmsg_unmask_irq,
+	.flags		= IRQCHIP_SKIP_SET_WAKE,
+};
+
+static int irq_rpmsg_map(struct irq_domain *d,
+			 unsigned int virq, irq_hw_number_t hw)
+{
+	struct rpmsg_irq_dev *rirq_dev = d->host_data;
+
+	if (!atomic_read(&rirq_dev->initialized))
+		return -EPROBE_DEFER;
+
+	irq_set_status_flags(virq, IRQ_LEVEL);
+	irq_set_chip_and_handler(virq, &irq_rpmsg_chip, handle_level_irq);
+	irq_set_chip_data(virq, d->host_data);
+	irq_set_nested_thread(virq, 1);
+
+	return 0;
+}
+
+static const struct irq_domain_ops irq_rpmsg_domain_ops = {
+	.map = irq_rpmsg_map,
+	.xlate = irq_domain_xlate_onecell,
+};
+
+static int irq_rpmsg_event(struct rpmsg_irq_dev *rirq_dev,
+			   struct rpmsg_intc_msg *msg)
+{
+	struct rpmsg_intc_bank *bank = &rirq_dev->banks[msg->bank_id];
+	unsigned long pending = msg->val;
+	unsigned int irq_offset = msg->bank_id * IRQS_PER_BANK;
+	u32 hwirq;
+
+	if (msg->bank_id >= rirq_dev->nb_bank)
+		return -EINVAL;
+
+	pending &= bank->mask;
+
+	for_each_set_bit(hwirq, &pending, IRQS_PER_BANK)
+		handle_nested_irq(irq_find_mapping(rirq_dev->irqd,
+						   irq_offset + hwirq));
+
+	return 0;
+}
+
+static int irq_rpmsg_cb(struct rpmsg_device *rpdev, void *data, int len,
+			void *priv, u32 src)
+{
+	struct rpmsg_irq_dev *rirq_dev = dev_get_drvdata(&rpdev->dev);
+	struct rpmsg_intc_msg *msg = data;
+	int ret = 0;
+
+	if (len != sizeof(struct rpmsg_intc_msg)) {
+		dev_err(&rpdev->dev, "wrong msg size\n");
+		return -EINVAL;
+	}
+
+	switch (msg->reg) {
+	case VIRT_INTC_PEND:
+		ret = irq_rpmsg_event(rirq_dev, msg);
+		break;
+
+	case VIRT_INTC_CFG:
+		rirq_dev->nb_bank = msg->val;
+		complete(&rirq_dev->complete);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int irq_rpmsg_read_val(struct rpmsg_irq_dev *rirq_dev,
+			      struct rpmsg_intc_msg *msg)
+{
+	struct rpmsg_device *rpdev = rirq_dev->rpdev;
+	int ret;
+
+	init_completion(&rirq_dev->complete);
+	ret = rpmsg_send(rpdev->ept, msg, sizeof(struct rpmsg_intc_msg));
+	if (ret)
+		return ret;
+
+	if (!wait_for_completion_timeout(&rirq_dev->complete, RPMSG_INTC_TIMEOUT))
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static void irq_rpmsg_setup_work(struct work_struct *ws)
+{
+	struct rpmsg_irq_dev *rirq_dev = container_of(ws, struct rpmsg_irq_dev,
+						      irqrpmsg_work);
+	struct rpmsg_device *rpdev = rirq_dev->rpdev;
+	struct rpmsg_intc_msg msg = {VIRT_INTC_CFG, 0, 0};
+	int ret;
+
+	ret = irq_rpmsg_read_val(rirq_dev, &msg);
+	if (ret) {
+		dev_err(&rpdev->dev, "read intc cfg failed: %d\n", ret);
+		goto err;
+	}
+
+	/*
+	 * Workaround
+	 * we can't manage IRQ domain creation here, this would leads to crash on remove.
+	 * There is no devlink between the IRQ domain client and the rpmsg device, so the IRQ domain
+	 * can be removed before the IRQs are freed.
+	 */
+	if (rirq_dev->nb_bank > 1) {
+		dev_err(&rpdev->dev, "only one IRQ bank supported\n");
+		goto err;
+	}
+
+	atomic_set(&rirq_dev->initialized, 1);
+
+	return;
+
+err:
+	dev_err(&rpdev->dev, "unregister rpmsg device: %s\n", rpdev->id.name);
+	device_unregister(&rpdev->dev);
+	put_device(&rpdev->dev);
+}
+
+/*
+ * WARNING
+ * Not multi instance, all rpdev have same rpmsg_irq_dev
+ */
+static int irq_rpmsg_probe(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);
+	struct rpmsg_irq_dev *rirq_dev = to_rpmsg_irq(rpdrv);
+
+	/*
+	 * WORKAROUND RPMsg
+	 * The RPMsg device is call under RPMsg Name Service callback
+	 * (irq context). Init and schedule a work to probe irq device in
+	 * task context.
+	 */
+	rirq_dev->rpdev = rpdev;
+	dev_set_drvdata(&rpdev->dev, rirq_dev);
+	rpdev->dev.of_node = rirq_dev->pdev->dev.of_node;
+	rpdev->dev.fwnode = rirq_dev->pdev->dev.fwnode;
+
+	atomic_set(&rirq_dev->initialized, 0);
+
+	INIT_WORK(&rirq_dev->irqrpmsg_work, irq_rpmsg_setup_work);
+	schedule_work(&rirq_dev->irqrpmsg_work);
+
+	return 0;
+}
+
+static void irq_rpmsg_remove(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_irq_dev *rirq_dev = dev_get_drvdata(&rpdev->dev);
+
+	cancel_work_sync(&rirq_dev->irqrpmsg_work);
+
+	atomic_set(&rirq_dev->initialized, 0);
+}
+
+static struct rpmsg_device_id irq_rpmsg_ids[] = {
+	{ .name	= "rpmsg-intc" },
+	{ },
+};
+
+static struct rpmsg_driver rpmsg_irq_drv = {
+	.drv.name	= "rpmsg_intc",
+	.id_table	= irq_rpmsg_ids,
+	.probe		= irq_rpmsg_probe,
+	.callback	= irq_rpmsg_cb,
+	.remove		= irq_rpmsg_remove,
+};
+
+static int irq_rpmsg_plat_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rpmsg_irq_dev *rirq_dev;
+	int ret;
+
+	rirq_dev = devm_kcalloc(dev, 1, sizeof(*rirq_dev), GFP_KERNEL);
+	if (!rirq_dev)
+		return -ENOMEM;
+
+	rirq_dev->pdev = pdev;
+	platform_set_drvdata(pdev, rirq_dev);
+
+	rirq_dev->rpdrv = rpmsg_irq_drv;
+
+	rirq_dev->banks = devm_kmalloc(dev, sizeof(struct rpmsg_intc_bank), GFP_KERNEL);
+	if (!rirq_dev->banks)
+		return -ENOMEM;
+
+	rirq_dev->irqd = irq_domain_create_linear(dev->fwnode, IRQS_PER_BANK, &irq_rpmsg_domain_ops,
+						  rirq_dev);
+	if (!rirq_dev->irqd) {
+		dev_err(dev, "Failed to create IRQ domain\n");
+		return -EINVAL;
+	}
+
+	ret = register_rpmsg_driver(&rirq_dev->rpdrv);
+	if (ret) {
+		dev_err_probe(dev, ret, "failed to register rpmsg drv\n");
+		irq_domain_remove(rirq_dev->irqd);
+
+		return ret;
+	}
+
+	return 0;
+}
+
+static int irq_rpmsg_plat_remove(struct platform_device *pdev)
+{
+	struct rpmsg_irq_dev *rirq_dev = platform_get_drvdata(pdev);
+
+	unregister_rpmsg_driver(&rirq_dev->rpdrv);
+
+	irq_domain_remove(rirq_dev->irqd);
+
+	return 0;
+}
+
+static const struct of_device_id irq_rpmsg_plat_ids[] = {
+	{ .compatible = "rpmsg,intc", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, irq_rpmsg_plat_ids);
+
+static struct platform_driver irq_rpmsg_plat_driver = {
+	.probe	= &irq_rpmsg_plat_probe,
+	.remove = &irq_rpmsg_plat_remove,
+	.driver = {
+		.name	= "irq_rpmsg",
+		.of_match_table	= of_match_ptr(irq_rpmsg_plat_ids),
+	}
+};
+
+static int __init irq_rpmsg_init(void)
+{
+	return platform_driver_register(&irq_rpmsg_plat_driver);
+}
+
+static void __exit irq_rpmsg_exit(void)
+{
+	platform_driver_unregister(&irq_rpmsg_plat_driver);
+}
+
+subsys_initcall(irq_rpmsg_init);
+module_exit(irq_rpmsg_exit);
+
+MODULE_DESCRIPTION("RPMsg IRQC Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/irqchip/irq-stm32-exti.c b/drivers/irqchip/irq-stm32-exti.c
index dc6f67dec..d424ec2ab 100644
--- a/drivers/irqchip/irq-stm32-exti.c
+++ b/drivers/irqchip/irq-stm32-exti.c
@@ -1,30 +1,21 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) Maxime Coquelin 2015
- * Copyright (C) STMicroelectronics 2017
+ * Copyright (C) STMicroelectronics 2017-2024
  * Author:  Maxime Coquelin <mcoquelin.stm32@gmail.com>
  */
 
 #include <linux/bitops.h>
-#include <linux/delay.h>
-#include <linux/hwspinlock.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/irqchip.h>
 #include <linux/irqchip/chained_irq.h>
 #include <linux/irqdomain.h>
-#include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
-#include <linux/of_platform.h>
-#include <linux/syscore_ops.h>
 
-#include <dt-bindings/interrupt-controller/arm-gic.h>
-
-#define IRQS_PER_BANK 32
-
-#define HWSPNLCK_TIMEOUT	1000 /* usec */
+#define IRQS_PER_BANK			32
 
 struct stm32_exti_bank {
 	u32 imr_ofst;
@@ -33,12 +24,8 @@ struct stm32_exti_bank {
 	u32 ftsr_ofst;
 	u32 swier_ofst;
 	u32 rpr_ofst;
-	u32 fpr_ofst;
-	u32 trg_ofst;
 };
 
-#define UNDEF_REG ~0
-
 struct stm32_exti_drv_data {
 	const struct stm32_exti_bank **exti_banks;
 	const u8 *desc_irqs;
@@ -48,22 +35,20 @@ struct stm32_exti_drv_data {
 struct stm32_exti_chip_data {
 	struct stm32_exti_host_data *host_data;
 	const struct stm32_exti_bank *reg_bank;
-	struct raw_spinlock rlock;
 	u32 wake_active;
 	u32 mask_cache;
 	u32 rtsr_cache;
 	u32 ftsr_cache;
+	u32 event_reserved;
 };
 
 struct stm32_exti_host_data {
 	void __iomem *base;
+	struct device *dev;
 	struct stm32_exti_chip_data *chips_data;
 	const struct stm32_exti_drv_data *drv_data;
-	struct hwspinlock *hwlock;
 };
 
-static struct stm32_exti_host_data *stm32_host_data;
-
 static const struct stm32_exti_bank stm32f4xx_exti_b1 = {
 	.imr_ofst	= 0x00,
 	.emr_ofst	= 0x04,
@@ -71,8 +56,6 @@ static const struct stm32_exti_bank stm32f4xx_exti_b1 = {
 	.ftsr_ofst	= 0x0C,
 	.swier_ofst	= 0x10,
 	.rpr_ofst	= 0x14,
-	.fpr_ofst	= UNDEF_REG,
-	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank *stm32f4xx_exti_banks[] = {
@@ -91,8 +74,6 @@ static const struct stm32_exti_bank stm32h7xx_exti_b1 = {
 	.ftsr_ofst	= 0x04,
 	.swier_ofst	= 0x08,
 	.rpr_ofst	= 0x88,
-	.fpr_ofst	= UNDEF_REG,
-	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank stm32h7xx_exti_b2 = {
@@ -102,8 +83,6 @@ static const struct stm32_exti_bank stm32h7xx_exti_b2 = {
 	.ftsr_ofst	= 0x24,
 	.swier_ofst	= 0x28,
 	.rpr_ofst	= 0x98,
-	.fpr_ofst	= UNDEF_REG,
-	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank stm32h7xx_exti_b3 = {
@@ -113,8 +92,6 @@ static const struct stm32_exti_bank stm32h7xx_exti_b3 = {
 	.ftsr_ofst	= 0x44,
 	.swier_ofst	= 0x48,
 	.rpr_ofst	= 0xA8,
-	.fpr_ofst	= UNDEF_REG,
-	.trg_ofst	= UNDEF_REG,
 };
 
 static const struct stm32_exti_bank *stm32h7xx_exti_banks[] = {
@@ -128,168 +105,6 @@ static const struct stm32_exti_drv_data stm32h7xx_drv_data = {
 	.bank_nr = ARRAY_SIZE(stm32h7xx_exti_banks),
 };
 
-static const struct stm32_exti_bank stm32mp1_exti_b1 = {
-	.imr_ofst	= 0x80,
-	.emr_ofst	= UNDEF_REG,
-	.rtsr_ofst	= 0x00,
-	.ftsr_ofst	= 0x04,
-	.swier_ofst	= 0x08,
-	.rpr_ofst	= 0x0C,
-	.fpr_ofst	= 0x10,
-	.trg_ofst	= 0x3EC,
-};
-
-static const struct stm32_exti_bank stm32mp1_exti_b2 = {
-	.imr_ofst	= 0x90,
-	.emr_ofst	= UNDEF_REG,
-	.rtsr_ofst	= 0x20,
-	.ftsr_ofst	= 0x24,
-	.swier_ofst	= 0x28,
-	.rpr_ofst	= 0x2C,
-	.fpr_ofst	= 0x30,
-	.trg_ofst	= 0x3E8,
-};
-
-static const struct stm32_exti_bank stm32mp1_exti_b3 = {
-	.imr_ofst	= 0xA0,
-	.emr_ofst	= UNDEF_REG,
-	.rtsr_ofst	= 0x40,
-	.ftsr_ofst	= 0x44,
-	.swier_ofst	= 0x48,
-	.rpr_ofst	= 0x4C,
-	.fpr_ofst	= 0x50,
-	.trg_ofst	= 0x3E4,
-};
-
-static const struct stm32_exti_bank *stm32mp1_exti_banks[] = {
-	&stm32mp1_exti_b1,
-	&stm32mp1_exti_b2,
-	&stm32mp1_exti_b3,
-};
-
-static struct irq_chip stm32_exti_h_chip;
-static struct irq_chip stm32_exti_h_chip_direct;
-
-#define EXTI_INVALID_IRQ       U8_MAX
-#define STM32MP1_DESC_IRQ_SIZE (ARRAY_SIZE(stm32mp1_exti_banks) * IRQS_PER_BANK)
-
-/*
- * Use some intentionally tricky logic here to initialize the whole array to
- * EXTI_INVALID_IRQ, but then override certain fields, requiring us to indicate
- * that we "know" that there are overrides in this structure, and we'll need to
- * disable that warning from W=1 builds.
- */
-__diag_push();
-__diag_ignore_all("-Woverride-init",
-		  "logic to initialize all and then override some is OK");
-
-static const u8 stm32mp1_desc_irq[] = {
-	/* default value */
-	[0 ... (STM32MP1_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,
-
-	[0] = 6,
-	[1] = 7,
-	[2] = 8,
-	[3] = 9,
-	[4] = 10,
-	[5] = 23,
-	[6] = 64,
-	[7] = 65,
-	[8] = 66,
-	[9] = 67,
-	[10] = 40,
-	[11] = 42,
-	[12] = 76,
-	[13] = 77,
-	[14] = 121,
-	[15] = 127,
-	[16] = 1,
-	[19] = 3,
-	[21] = 31,
-	[22] = 33,
-	[23] = 72,
-	[24] = 95,
-	[25] = 107,
-	[26] = 37,
-	[27] = 38,
-	[28] = 39,
-	[29] = 71,
-	[30] = 52,
-	[31] = 53,
-	[32] = 82,
-	[33] = 83,
-	[47] = 93,
-	[48] = 138,
-	[50] = 139,
-	[52] = 140,
-	[53] = 141,
-	[54] = 135,
-	[61] = 100,
-	[65] = 144,
-	[68] = 143,
-	[70] = 62,
-	[73] = 129,
-};
-
-static const u8 stm32mp13_desc_irq[] = {
-	/* default value */
-	[0 ... (STM32MP1_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,
-
-	[0] = 6,
-	[1] = 7,
-	[2] = 8,
-	[3] = 9,
-	[4] = 10,
-	[5] = 24,
-	[6] = 65,
-	[7] = 66,
-	[8] = 67,
-	[9] = 68,
-	[10] = 41,
-	[11] = 43,
-	[12] = 77,
-	[13] = 78,
-	[14] = 106,
-	[15] = 109,
-	[16] = 1,
-	[19] = 3,
-	[21] = 32,
-	[22] = 34,
-	[23] = 73,
-	[24] = 93,
-	[25] = 114,
-	[26] = 38,
-	[27] = 39,
-	[28] = 40,
-	[29] = 72,
-	[30] = 53,
-	[31] = 54,
-	[32] = 83,
-	[33] = 84,
-	[44] = 96,
-	[47] = 92,
-	[48] = 116,
-	[50] = 117,
-	[52] = 118,
-	[53] = 119,
-	[68] = 63,
-	[70] = 98,
-};
-
-__diag_pop();
-
-static const struct stm32_exti_drv_data stm32mp1_drv_data = {
-	.exti_banks = stm32mp1_exti_banks,
-	.bank_nr = ARRAY_SIZE(stm32mp1_exti_banks),
-	.desc_irqs = stm32mp1_desc_irq,
-};
-
-static const struct stm32_exti_drv_data stm32mp13_drv_data = {
-	.exti_banks = stm32mp1_exti_banks,
-	.bank_nr = ARRAY_SIZE(stm32mp1_exti_banks),
-	.desc_irqs = stm32mp13_desc_irq,
-};
-
 static unsigned long stm32_exti_pending(struct irq_chip_generic *gc)
 {
 	struct stm32_exti_chip_data *chip_data = gc->private;
@@ -297,8 +112,6 @@ static unsigned long stm32_exti_pending(struct irq_chip_generic *gc)
 	unsigned long pending;
 
 	pending = irq_reg_readl(gc, stm32_bank->rpr_ofst);
-	if (stm32_bank->fpr_ofst != UNDEF_REG)
-		pending |= irq_reg_readl(gc, stm32_bank->fpr_ofst);
 
 	return pending;
 }
@@ -320,7 +133,7 @@ static void stm32_irq_handler(struct irq_desc *desc)
 		while ((pending = stm32_exti_pending(gc))) {
 			for_each_set_bit(n, &pending, IRQS_PER_BANK)
 				generic_handle_domain_irq(domain, irq_base + n);
- 		}
+		}
 	}
 
 	chained_irq_exit(chip, desc);
@@ -356,33 +169,21 @@ static int stm32_irq_set_type(struct irq_data *d, unsigned int type)
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct stm32_exti_chip_data *chip_data = gc->private;
 	const struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;
-	struct hwspinlock *hwlock = chip_data->host_data->hwlock;
 	u32 rtsr, ftsr;
 	int err;
 
 	irq_gc_lock(gc);
 
-	if (hwlock) {
-		err = hwspin_lock_timeout_in_atomic(hwlock, HWSPNLCK_TIMEOUT);
-		if (err) {
-			pr_err("%s can't get hwspinlock (%d)\n", __func__, err);
-			goto unlock;
-		}
-	}
-
 	rtsr = irq_reg_readl(gc, stm32_bank->rtsr_ofst);
 	ftsr = irq_reg_readl(gc, stm32_bank->ftsr_ofst);
 
 	err = stm32_exti_set_type(d, type, &rtsr, &ftsr);
 	if (err)
-		goto unspinlock;
+		goto unlock;
 
 	irq_reg_writel(gc, rtsr, stm32_bank->rtsr_ofst);
 	irq_reg_writel(gc, ftsr, stm32_bank->ftsr_ofst);
 
-unspinlock:
-	if (hwlock)
-		hwspin_unlock_in_atomic(hwlock);
 unlock:
 	irq_gc_unlock(gc);
 
@@ -470,282 +271,10 @@ static void stm32_irq_ack(struct irq_data *d)
 	irq_gc_lock(gc);
 
 	irq_reg_writel(gc, d->mask, stm32_bank->rpr_ofst);
-	if (stm32_bank->fpr_ofst != UNDEF_REG)
-		irq_reg_writel(gc, d->mask, stm32_bank->fpr_ofst);
 
 	irq_gc_unlock(gc);
 }
 
-/* directly set the target bit without reading first. */
-static inline void stm32_exti_write_bit(struct irq_data *d, u32 reg)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	void __iomem *base = chip_data->host_data->base;
-	u32 val = BIT(d->hwirq % IRQS_PER_BANK);
-
-	writel_relaxed(val, base + reg);
-}
-
-static inline u32 stm32_exti_set_bit(struct irq_data *d, u32 reg)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	void __iomem *base = chip_data->host_data->base;
-	u32 val;
-
-	val = readl_relaxed(base + reg);
-	val |= BIT(d->hwirq % IRQS_PER_BANK);
-	writel_relaxed(val, base + reg);
-
-	return val;
-}
-
-static inline u32 stm32_exti_clr_bit(struct irq_data *d, u32 reg)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	void __iomem *base = chip_data->host_data->base;
-	u32 val;
-
-	val = readl_relaxed(base + reg);
-	val &= ~BIT(d->hwirq % IRQS_PER_BANK);
-	writel_relaxed(val, base + reg);
-
-	return val;
-}
-
-static void stm32_exti_h_eoi(struct irq_data *d)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	const struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;
-
-	raw_spin_lock(&chip_data->rlock);
-
-	stm32_exti_write_bit(d, stm32_bank->rpr_ofst);
-	if (stm32_bank->fpr_ofst != UNDEF_REG)
-		stm32_exti_write_bit(d, stm32_bank->fpr_ofst);
-
-	raw_spin_unlock(&chip_data->rlock);
-
-	if (d->parent_data->chip)
-		irq_chip_eoi_parent(d);
-}
-
-static void stm32_exti_h_mask(struct irq_data *d)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	const struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;
-
-	raw_spin_lock(&chip_data->rlock);
-	chip_data->mask_cache = stm32_exti_clr_bit(d, stm32_bank->imr_ofst);
-	raw_spin_unlock(&chip_data->rlock);
-
-	if (d->parent_data->chip)
-		irq_chip_mask_parent(d);
-}
-
-static void stm32_exti_h_unmask(struct irq_data *d)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	const struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;
-
-	raw_spin_lock(&chip_data->rlock);
-	chip_data->mask_cache = stm32_exti_set_bit(d, stm32_bank->imr_ofst);
-	raw_spin_unlock(&chip_data->rlock);
-
-	if (d->parent_data->chip)
-		irq_chip_unmask_parent(d);
-}
-
-static int stm32_exti_h_set_type(struct irq_data *d, unsigned int type)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	const struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;
-	struct hwspinlock *hwlock = chip_data->host_data->hwlock;
-	void __iomem *base = chip_data->host_data->base;
-	u32 rtsr, ftsr;
-	int err;
-
-	raw_spin_lock(&chip_data->rlock);
-
-	if (hwlock) {
-		err = hwspin_lock_timeout_in_atomic(hwlock, HWSPNLCK_TIMEOUT);
-		if (err) {
-			pr_err("%s can't get hwspinlock (%d)\n", __func__, err);
-			goto unlock;
-		}
-	}
-
-	rtsr = readl_relaxed(base + stm32_bank->rtsr_ofst);
-	ftsr = readl_relaxed(base + stm32_bank->ftsr_ofst);
-
-	err = stm32_exti_set_type(d, type, &rtsr, &ftsr);
-	if (err)
-		goto unspinlock;
-
-	writel_relaxed(rtsr, base + stm32_bank->rtsr_ofst);
-	writel_relaxed(ftsr, base + stm32_bank->ftsr_ofst);
-
-unspinlock:
-	if (hwlock)
-		hwspin_unlock_in_atomic(hwlock);
-unlock:
-	raw_spin_unlock(&chip_data->rlock);
-
-	return err;
-}
-
-static int stm32_exti_h_set_wake(struct irq_data *d, unsigned int on)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	u32 mask = BIT(d->hwirq % IRQS_PER_BANK);
-
-	raw_spin_lock(&chip_data->rlock);
-
-	if (on)
-		chip_data->wake_active |= mask;
-	else
-		chip_data->wake_active &= ~mask;
-
-	raw_spin_unlock(&chip_data->rlock);
-
-	return 0;
-}
-
-static int stm32_exti_h_set_affinity(struct irq_data *d,
-				     const struct cpumask *dest, bool force)
-{
-	if (d->parent_data->chip)
-		return irq_chip_set_affinity_parent(d, dest, force);
-
-	return IRQ_SET_MASK_OK_DONE;
-}
-
-static int __maybe_unused stm32_exti_h_suspend(void)
-{
-	struct stm32_exti_chip_data *chip_data;
-	int i;
-
-	for (i = 0; i < stm32_host_data->drv_data->bank_nr; i++) {
-		chip_data = &stm32_host_data->chips_data[i];
-		raw_spin_lock(&chip_data->rlock);
-		stm32_chip_suspend(chip_data, chip_data->wake_active);
-		raw_spin_unlock(&chip_data->rlock);
-	}
-
-	return 0;
-}
-
-static void __maybe_unused stm32_exti_h_resume(void)
-{
-	struct stm32_exti_chip_data *chip_data;
-	int i;
-
-	for (i = 0; i < stm32_host_data->drv_data->bank_nr; i++) {
-		chip_data = &stm32_host_data->chips_data[i];
-		raw_spin_lock(&chip_data->rlock);
-		stm32_chip_resume(chip_data, chip_data->mask_cache);
-		raw_spin_unlock(&chip_data->rlock);
-	}
-}
-
-static struct syscore_ops stm32_exti_h_syscore_ops = {
-#ifdef CONFIG_PM_SLEEP
-	.suspend	= stm32_exti_h_suspend,
-	.resume		= stm32_exti_h_resume,
-#endif
-};
-
-static void stm32_exti_h_syscore_init(struct stm32_exti_host_data *host_data)
-{
-	stm32_host_data = host_data;
-	register_syscore_ops(&stm32_exti_h_syscore_ops);
-}
-
-static void stm32_exti_h_syscore_deinit(void)
-{
-	unregister_syscore_ops(&stm32_exti_h_syscore_ops);
-}
-
-static int stm32_exti_h_retrigger(struct irq_data *d)
-{
-	struct stm32_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
-	const struct stm32_exti_bank *stm32_bank = chip_data->reg_bank;
-	void __iomem *base = chip_data->host_data->base;
-	u32 mask = BIT(d->hwirq % IRQS_PER_BANK);
-
-	writel_relaxed(mask, base + stm32_bank->swier_ofst);
-
-	return 0;
-}
-
-static struct irq_chip stm32_exti_h_chip = {
-	.name			= "stm32-exti-h",
-	.irq_eoi		= stm32_exti_h_eoi,
-	.irq_mask		= stm32_exti_h_mask,
-	.irq_unmask		= stm32_exti_h_unmask,
-	.irq_retrigger		= stm32_exti_h_retrigger,
-	.irq_set_type		= stm32_exti_h_set_type,
-	.irq_set_wake		= stm32_exti_h_set_wake,
-	.flags			= IRQCHIP_MASK_ON_SUSPEND,
-	.irq_set_affinity	= IS_ENABLED(CONFIG_SMP) ? stm32_exti_h_set_affinity : NULL,
-};
-
-static struct irq_chip stm32_exti_h_chip_direct = {
-	.name			= "stm32-exti-h-direct",
-	.irq_eoi		= irq_chip_eoi_parent,
-	.irq_ack		= irq_chip_ack_parent,
-	.irq_mask		= stm32_exti_h_mask,
-	.irq_unmask		= stm32_exti_h_unmask,
-	.irq_retrigger		= irq_chip_retrigger_hierarchy,
-	.irq_set_type		= irq_chip_set_type_parent,
-	.irq_set_wake		= stm32_exti_h_set_wake,
-	.flags			= IRQCHIP_MASK_ON_SUSPEND,
-	.irq_set_affinity	= IS_ENABLED(CONFIG_SMP) ? irq_chip_set_affinity_parent : NULL,
-};
-
-static int stm32_exti_h_domain_alloc(struct irq_domain *dm,
-				     unsigned int virq,
-				     unsigned int nr_irqs, void *data)
-{
-	struct stm32_exti_host_data *host_data = dm->host_data;
-	struct stm32_exti_chip_data *chip_data;
-	u8 desc_irq;
-	struct irq_fwspec *fwspec = data;
-	struct irq_fwspec p_fwspec;
-	irq_hw_number_t hwirq;
-	int bank;
-	u32 event_trg;
-	struct irq_chip *chip;
-
-	hwirq = fwspec->param[0];
-	if (hwirq >= host_data->drv_data->bank_nr * IRQS_PER_BANK)
-		return -EINVAL;
-
-	bank  = hwirq / IRQS_PER_BANK;
-	chip_data = &host_data->chips_data[bank];
-
-	event_trg = readl_relaxed(host_data->base + chip_data->reg_bank->trg_ofst);
-	chip = (event_trg & BIT(hwirq % IRQS_PER_BANK)) ?
-	       &stm32_exti_h_chip : &stm32_exti_h_chip_direct;
-
-	irq_domain_set_hwirq_and_chip(dm, virq, hwirq, chip, chip_data);
-
-	if (!host_data->drv_data->desc_irqs)
-		return -EINVAL;
-
-	desc_irq = host_data->drv_data->desc_irqs[hwirq];
-	if (desc_irq != EXTI_INVALID_IRQ) {
-		p_fwspec.fwnode = dm->parent->fwnode;
-		p_fwspec.param_count = 3;
-		p_fwspec.param[0] = GIC_SPI;
-		p_fwspec.param[1] = desc_irq;
-		p_fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;
-
-		return irq_domain_alloc_irqs_parent(dm, virq, 1, &p_fwspec);
-	}
-
-	return 0;
-}
-
 static struct
 stm32_exti_host_data *stm32_exti_host_init(const struct stm32_exti_drv_data *dd,
 					   struct device_node *node)
@@ -769,8 +298,6 @@ stm32_exti_host_data *stm32_exti_host_init(const struct stm32_exti_drv_data *dd,
 		goto free_chips_data;
 	}
 
-	stm32_host_data = host_data;
-
 	return host_data;
 
 free_chips_data:
@@ -795,15 +322,12 @@ stm32_exti_chip_data *stm32_exti_chip_init(struct stm32_exti_host_data *h_data,
 	chip_data->host_data = h_data;
 	chip_data->reg_bank = stm32_bank;
 
-	raw_spin_lock_init(&chip_data->rlock);
-
 	/*
 	 * This IP has no reset, so after hot reboot we should
 	 * clear registers to avoid residue
 	 */
 	writel_relaxed(0, base + stm32_bank->imr_ofst);
-	if (stm32_bank->emr_ofst != UNDEF_REG)
-		writel_relaxed(0, base + stm32_bank->emr_ofst);
+	writel_relaxed(0, base + stm32_bank->emr_ofst);
 
 	pr_info("%pOF: bank%d\n", node, bank_idx);
 
@@ -883,133 +407,6 @@ static int __init stm32_exti_init(const struct stm32_exti_drv_data *drv_data,
 	return ret;
 }
 
-static const struct irq_domain_ops stm32_exti_h_domain_ops = {
-	.alloc	= stm32_exti_h_domain_alloc,
-	.free	= irq_domain_free_irqs_common,
-	.xlate = irq_domain_xlate_twocell,
-};
-
-static void stm32_exti_remove_irq(void *data)
-{
-	struct irq_domain *domain = data;
-
-	irq_domain_remove(domain);
-}
-
-static int stm32_exti_remove(struct platform_device *pdev)
-{
-	stm32_exti_h_syscore_deinit();
-	return 0;
-}
-
-static int stm32_exti_probe(struct platform_device *pdev)
-{
-	int ret, i;
-	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
-	struct irq_domain *parent_domain, *domain;
-	struct stm32_exti_host_data *host_data;
-	const struct stm32_exti_drv_data *drv_data;
-
-	host_data = devm_kzalloc(dev, sizeof(*host_data), GFP_KERNEL);
-	if (!host_data)
-		return -ENOMEM;
-
-	/* check for optional hwspinlock which may be not available yet */
-	ret = of_hwspin_lock_get_id(np, 0);
-	if (ret == -EPROBE_DEFER)
-		/* hwspinlock framework not yet ready */
-		return ret;
-
-	if (ret >= 0) {
-		host_data->hwlock = devm_hwspin_lock_request_specific(dev, ret);
-		if (!host_data->hwlock) {
-			dev_err(dev, "Failed to request hwspinlock\n");
-			return -EINVAL;
-		}
-	} else if (ret != -ENOENT) {
-		/* note: ENOENT is a valid case (means 'no hwspinlock') */
-		dev_err(dev, "Failed to get hwspinlock\n");
-		return ret;
-	}
-
-	/* initialize host_data */
-	drv_data = of_device_get_match_data(dev);
-	if (!drv_data) {
-		dev_err(dev, "no of match data\n");
-		return -ENODEV;
-	}
-	host_data->drv_data = drv_data;
-
-	host_data->chips_data = devm_kcalloc(dev, drv_data->bank_nr,
-					     sizeof(*host_data->chips_data),
-					     GFP_KERNEL);
-	if (!host_data->chips_data)
-		return -ENOMEM;
-
-	host_data->base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(host_data->base))
-		return PTR_ERR(host_data->base);
-
-	for (i = 0; i < drv_data->bank_nr; i++)
-		stm32_exti_chip_init(host_data, i, np);
-
-	parent_domain = irq_find_host(of_irq_find_parent(np));
-	if (!parent_domain) {
-		dev_err(dev, "GIC interrupt-parent not found\n");
-		return -EINVAL;
-	}
-
-	domain = irq_domain_add_hierarchy(parent_domain, 0,
-					  drv_data->bank_nr * IRQS_PER_BANK,
-					  np, &stm32_exti_h_domain_ops,
-					  host_data);
-
-	if (!domain) {
-		dev_err(dev, "Could not register exti domain\n");
-		return -ENOMEM;
-	}
-
-	ret = devm_add_action_or_reset(dev, stm32_exti_remove_irq, domain);
-	if (ret)
-		return ret;
-
-	stm32_exti_h_syscore_init(host_data);
-
-	return 0;
-}
-
-/* platform driver only for MP1 */
-static const struct of_device_id stm32_exti_ids[] = {
-	{ .compatible = "st,stm32mp1-exti", .data = &stm32mp1_drv_data},
-	{ .compatible = "st,stm32mp13-exti", .data = &stm32mp13_drv_data},
-	{},
-};
-MODULE_DEVICE_TABLE(of, stm32_exti_ids);
-
-static struct platform_driver stm32_exti_driver = {
-	.probe		= stm32_exti_probe,
-	.remove		= stm32_exti_remove,
-	.driver		= {
-		.name	= "stm32_exti",
-		.of_match_table = stm32_exti_ids,
-	},
-};
-
-static int __init stm32_exti_arch_init(void)
-{
-	return platform_driver_register(&stm32_exti_driver);
-}
-
-static void __exit stm32_exti_arch_exit(void)
-{
-	return platform_driver_unregister(&stm32_exti_driver);
-}
-
-arch_initcall(stm32_exti_arch_init);
-module_exit(stm32_exti_arch_exit);
-
-/* no platform driver for F4 and H7 */
 static int __init stm32f4_exti_of_init(struct device_node *np,
 				       struct device_node *parent)
 {
diff --git a/drivers/irqchip/irq-stm32mp-exti.c b/drivers/irqchip/irq-stm32mp-exti.c
new file mode 100644
index 000000000..5aaed1d49
--- /dev/null
+++ b/drivers/irqchip/irq-stm32mp-exti.c
@@ -0,0 +1,970 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) Maxime Coquelin 2015
+ * Copyright (C) STMicroelectronics 2017-2024
+ * Author:  Maxime Coquelin <mcoquelin.stm32@gmail.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/hwspinlock.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/pm.h>
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#define IRQS_PER_BANK			32
+
+#define STM32MP_GPIO_IRQ_LINES		16
+
+/* to receive bank_ioport_nr from GPIO in struct irq_fwspec::param[1] */
+#define STM32MP_GPIO_BANK_MASK		GENMASK(23, 16)
+
+#define HWSPNLCK_TIMEOUT		1000 /* usec */
+
+#define EXTI_CR(n)			(0x060 + ((n) / 4) * 4)
+#define EXTI_CR_SHIFT(n)		(((n) % 4) * 8)
+#define EXTI_CR_MASK(n)			(GENMASK(7, 0) << EXTI_CR_SHIFT(n))
+
+#define EXTI_EnCIDCFGR(n)		(0x180 + (n) * 4)
+#define EXTI_HWCFGR1			0x3f0
+
+/* Register: EXTI_EnCIDCFGR(n) */
+#define EXTI_CIDCFGR_CFEN_MASK		BIT(0)
+#define EXTI_CIDCFGR_CID_MASK		GENMASK(6, 4)
+#define EXTI_CIDCFGR_CID_SHIFT		4
+
+/* Register: EXTI_HWCFGR1 */
+#define EXTI_HWCFGR1_CIDWIDTH_MASK	GENMASK(27, 24)
+
+#define EXTI_CID1			1
+
+struct stm32mp_exti_bank {
+	u32 imr_ofst;
+	u32 rtsr_ofst;
+	u32 ftsr_ofst;
+	u32 swier_ofst;
+	u32 rpr_ofst;
+	u32 fpr_ofst;
+	u32 trg_ofst;
+	u32 seccfgr_ofst;
+};
+
+struct stm32mp_exti_drv_data {
+	const struct stm32mp_exti_bank **exti_banks;
+	const u8 *desc_irqs;
+	u32 bank_nr;
+};
+
+struct stm32mp_exti_chip_data {
+	struct stm32mp_exti_host_data *host_data;
+	const struct stm32mp_exti_bank *reg_bank;
+	struct raw_spinlock rlock;
+	u32 wake_active;
+	u32 mask_cache;
+	u32 rtsr_cache;
+	u32 ftsr_cache;
+	u32 event_reserved;
+};
+
+struct stm32mp_exti_host_data {
+	void __iomem *base;
+	struct device *dev;
+	struct stm32mp_exti_chip_data *chips_data;
+	const struct stm32mp_exti_drv_data *drv_data;
+	struct hwspinlock *hwlock;
+	bool dt_has_irqs_desc; /* skip internal desc_irqs array and get it from DT */
+	bool has_syscon; /* using old DT; keep backward compatibility */
+	struct raw_spinlock gpio_mux_lock;
+	DECLARE_BITMAP(gpio_mux_used, STM32MP_GPIO_IRQ_LINES);
+	u8 gpio_mux_pos[STM32MP_GPIO_IRQ_LINES];
+};
+
+static const struct stm32mp_exti_bank stm32mp_exti_b1 = {
+	.imr_ofst	= 0x80,
+	.rtsr_ofst	= 0x00,
+	.ftsr_ofst	= 0x04,
+	.swier_ofst	= 0x08,
+	.rpr_ofst	= 0x0C,
+	.fpr_ofst	= 0x10,
+	.trg_ofst	= 0x3EC,
+	.seccfgr_ofst	= 0x14,
+};
+
+static const struct stm32mp_exti_bank stm32mp_exti_b2 = {
+	.imr_ofst	= 0x90,
+	.rtsr_ofst	= 0x20,
+	.ftsr_ofst	= 0x24,
+	.swier_ofst	= 0x28,
+	.rpr_ofst	= 0x2C,
+	.fpr_ofst	= 0x30,
+	.trg_ofst	= 0x3E8,
+	.seccfgr_ofst	= 0x34,
+};
+
+static const struct stm32mp_exti_bank stm32mp_exti_b3 = {
+	.imr_ofst	= 0xA0,
+	.rtsr_ofst	= 0x40,
+	.ftsr_ofst	= 0x44,
+	.swier_ofst	= 0x48,
+	.rpr_ofst	= 0x4C,
+	.fpr_ofst	= 0x50,
+	.trg_ofst	= 0x3E4,
+	.seccfgr_ofst	= 0x54,
+};
+
+static const struct stm32mp_exti_bank *stm32mp_exti_banks[] = {
+	&stm32mp_exti_b1,
+	&stm32mp_exti_b2,
+	&stm32mp_exti_b3,
+};
+
+static struct irq_chip stm32mp_exti_chip;
+static struct irq_chip stm32mp_exti_chip_direct;
+
+#define EXTI_INVALID_IRQ	U8_MAX
+#define STM32MP_DESC_IRQ_SIZE	(ARRAY_SIZE(stm32mp_exti_banks) * IRQS_PER_BANK)
+
+/*
+ * Use some intentionally tricky logic here to initialize the whole array to
+ * EXTI_INVALID_IRQ, but then override certain fields, requiring us to indicate
+ * that we "know" that there are overrides in this structure, and we'll need to
+ * disable that warning from W=1 builds.
+ */
+__diag_push();
+__diag_ignore_all("-Woverride-init",
+		  "logic to initialize all and then override some is OK");
+
+static const u8 stm32mp1_desc_irq[] = {
+	/* default value */
+	[0 ... (STM32MP_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,
+
+	[0] = 6,
+	[1] = 7,
+	[2] = 8,
+	[3] = 9,
+	[4] = 10,
+	[5] = 23,
+	[6] = 64,
+	[7] = 65,
+	[8] = 66,
+	[9] = 67,
+	[10] = 40,
+	[11] = 42,
+	[12] = 76,
+	[13] = 77,
+	[14] = 121,
+	[15] = 127,
+	[16] = 1,
+	[19] = 3,
+	[21] = 31,
+	[22] = 33,
+	[23] = 72,
+	[24] = 95,
+	[25] = 107,
+	[26] = 37,
+	[27] = 38,
+	[28] = 39,
+	[29] = 71,
+	[30] = 52,
+	[31] = 53,
+	[32] = 82,
+	[33] = 83,
+	[47] = 93,
+	[48] = 138,
+	[50] = 139,
+	[52] = 140,
+	[53] = 141,
+	[54] = 135,
+	[61] = 100,
+	[65] = 144,
+	[68] = 143,
+	[70] = 62,
+	[73] = 129,
+};
+
+static const u8 stm32mp13_desc_irq[] = {
+	/* default value */
+	[0 ... (STM32MP_DESC_IRQ_SIZE - 1)] = EXTI_INVALID_IRQ,
+
+	[0] = 6,
+	[1] = 7,
+	[2] = 8,
+	[3] = 9,
+	[4] = 10,
+	[5] = 24,
+	[6] = 65,
+	[7] = 66,
+	[8] = 67,
+	[9] = 68,
+	[10] = 41,
+	[11] = 43,
+	[12] = 77,
+	[13] = 78,
+	[14] = 106,
+	[15] = 109,
+	[16] = 1,
+	[19] = 3,
+	[21] = 32,
+	[22] = 34,
+	[23] = 73,
+	[24] = 93,
+	[25] = 114,
+	[26] = 38,
+	[27] = 39,
+	[28] = 40,
+	[29] = 72,
+	[30] = 53,
+	[31] = 54,
+	[32] = 83,
+	[33] = 84,
+	[44] = 96,
+	[47] = 92,
+	[48] = 116,
+	[50] = 117,
+	[52] = 118,
+	[53] = 119,
+	[68] = 63,
+	[70] = 98,
+};
+
+__diag_pop();
+
+static const struct stm32mp_exti_drv_data stm32mp1_drv_data = {
+	.exti_banks = stm32mp_exti_banks,
+	.bank_nr = ARRAY_SIZE(stm32mp_exti_banks),
+	.desc_irqs = stm32mp1_desc_irq,
+};
+
+static const struct stm32mp_exti_drv_data stm32mp13_drv_data = {
+	.exti_banks = stm32mp_exti_banks,
+	.bank_nr = ARRAY_SIZE(stm32mp_exti_banks),
+	.desc_irqs = stm32mp13_desc_irq,
+};
+
+static int stm32mp_exti_convert_type(struct irq_data *d,
+				     unsigned int type, u32 *rtsr, u32 *ftsr)
+{
+	u32 mask = BIT(d->hwirq % IRQS_PER_BANK);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		*rtsr |= mask;
+		*ftsr &= ~mask;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		*rtsr &= ~mask;
+		*ftsr |= mask;
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		*rtsr |= mask;
+		*ftsr |= mask;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void stm32mp_chip_suspend(struct stm32mp_exti_chip_data *chip_data,
+				 u32 wake_active)
+{
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+	void __iomem *base = chip_data->host_data->base;
+
+	/* save rtsr, ftsr registers */
+	chip_data->rtsr_cache = readl_relaxed(base + bank->rtsr_ofst);
+	chip_data->ftsr_cache = readl_relaxed(base + bank->ftsr_ofst);
+
+	writel_relaxed(wake_active, base + bank->imr_ofst);
+}
+
+static void stm32mp_chip_resume(struct stm32mp_exti_chip_data *chip_data,
+				u32 mask_cache)
+{
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+	void __iomem *base = chip_data->host_data->base;
+
+	/* restore rtsr, ftsr, registers */
+	writel_relaxed(chip_data->rtsr_cache, base + bank->rtsr_ofst);
+	writel_relaxed(chip_data->ftsr_cache, base + bank->ftsr_ofst);
+
+	writel_relaxed(mask_cache, base + bank->imr_ofst);
+}
+
+/* directly set the target bit without reading first. */
+static inline void stm32mp_exti_write_bit(struct irq_data *d, u32 reg)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	void __iomem *base = chip_data->host_data->base;
+	u32 val = BIT(d->hwirq % IRQS_PER_BANK);
+
+	writel_relaxed(val, base + reg);
+}
+
+static inline u32 stm32mp_exti_set_bit(struct irq_data *d, u32 reg)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	void __iomem *base = chip_data->host_data->base;
+	u32 val;
+
+	val = readl_relaxed(base + reg);
+	val |= BIT(d->hwirq % IRQS_PER_BANK);
+	writel_relaxed(val, base + reg);
+
+	return val;
+}
+
+static inline u32 stm32mp_exti_clr_bit(struct irq_data *d, u32 reg)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	void __iomem *base = chip_data->host_data->base;
+	u32 val;
+
+	val = readl_relaxed(base + reg);
+	val &= ~BIT(d->hwirq % IRQS_PER_BANK);
+	writel_relaxed(val, base + reg);
+
+	return val;
+}
+
+static void stm32mp_exti_eoi(struct irq_data *d)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+
+	raw_spin_lock(&chip_data->rlock);
+
+	stm32mp_exti_write_bit(d, bank->rpr_ofst);
+	stm32mp_exti_write_bit(d, bank->fpr_ofst);
+
+	chip_data->mask_cache = stm32mp_exti_set_bit(d, bank->imr_ofst);
+
+	raw_spin_unlock(&chip_data->rlock);
+
+	irq_chip_eoi_parent(d);
+}
+
+static void stm32mp_exti_mask(struct irq_data *d)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+
+	raw_spin_lock(&chip_data->rlock);
+	chip_data->mask_cache = stm32mp_exti_clr_bit(d, bank->imr_ofst);
+	raw_spin_unlock(&chip_data->rlock);
+
+	irq_chip_mask_parent(d);
+}
+
+static void stm32mp_exti_unmask(struct irq_data *d)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+
+	raw_spin_lock(&chip_data->rlock);
+	chip_data->mask_cache = stm32mp_exti_set_bit(d, bank->imr_ofst);
+	raw_spin_unlock(&chip_data->rlock);
+
+	irq_chip_unmask_parent(d);
+}
+
+static int stm32mp_exti_set_type(struct irq_data *d, unsigned int type)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+	struct hwspinlock *hwlock = chip_data->host_data->hwlock;
+	void __iomem *base = chip_data->host_data->base;
+	u32 rtsr, ftsr;
+	int err;
+
+	raw_spin_lock(&chip_data->rlock);
+
+	if (hwlock) {
+		err = hwspin_lock_timeout_in_atomic(hwlock, HWSPNLCK_TIMEOUT);
+		if (err) {
+			pr_err("%s can't get hwspinlock (%d)\n", __func__, err);
+			goto unlock;
+		}
+	}
+
+	rtsr = readl_relaxed(base + bank->rtsr_ofst);
+	ftsr = readl_relaxed(base + bank->ftsr_ofst);
+
+	err = stm32mp_exti_convert_type(d, type, &rtsr, &ftsr);
+	if (err)
+		goto unspinlock;
+
+	writel_relaxed(rtsr, base + bank->rtsr_ofst);
+	writel_relaxed(ftsr, base + bank->ftsr_ofst);
+
+unspinlock:
+	if (hwlock)
+		hwspin_unlock_in_atomic(hwlock);
+unlock:
+	raw_spin_unlock(&chip_data->rlock);
+
+	if (err)
+		return err;
+
+	/* configurable events only propagate level high type to GIC */
+	return irq_chip_set_type_parent(d, IRQ_TYPE_LEVEL_HIGH);
+}
+
+static int stm32mp_exti_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	u32 mask = BIT(d->hwirq % IRQS_PER_BANK);
+
+	raw_spin_lock(&chip_data->rlock);
+
+	if (on)
+		chip_data->wake_active |= mask;
+	else
+		chip_data->wake_active &= ~mask;
+
+	raw_spin_unlock(&chip_data->rlock);
+
+	return irq_chip_set_wake_parent(d, on);
+}
+
+static int stm32mp_exti_suspend(struct device *dev)
+{
+	struct stm32mp_exti_host_data *host_data = dev_get_drvdata(dev);
+	struct stm32mp_exti_chip_data *chip_data;
+	int i;
+
+	for (i = 0; i < host_data->drv_data->bank_nr; i++) {
+		chip_data = &host_data->chips_data[i];
+		stm32mp_chip_suspend(chip_data, chip_data->wake_active);
+	}
+
+	return 0;
+}
+
+static void stm32mp_exti_resume_gpio_mux(struct stm32mp_exti_host_data *host_data)
+{
+	bool write_cr = false;
+	unsigned int i;
+	u32 cr = 0;
+
+	for (i = 0; i < STM32MP_GPIO_IRQ_LINES; i++) {
+		if (test_bit(i, host_data->gpio_mux_used)) {
+			write_cr = true;
+			cr |= (host_data->gpio_mux_pos[i] << EXTI_CR_SHIFT(i)) & EXTI_CR_MASK(i);
+		}
+
+		if ((i % 4) == 3 && write_cr) {
+			writel_relaxed(cr, host_data->base + EXTI_CR(i));
+			write_cr = false;
+			cr = 0;
+		}
+	}
+}
+
+static int stm32mp_exti_resume(struct device *dev)
+{
+	struct stm32mp_exti_host_data *host_data = dev_get_drvdata(dev);
+	struct stm32mp_exti_chip_data *chip_data;
+	int i;
+
+	for (i = 0; i < host_data->drv_data->bank_nr; i++) {
+		chip_data = &host_data->chips_data[i];
+		if (i == 0)
+			stm32mp_exti_resume_gpio_mux(host_data);
+		stm32mp_chip_resume(chip_data, chip_data->mask_cache);
+	}
+
+	return 0;
+}
+
+static int stm32mp_exti_retrigger(struct irq_data *d)
+{
+	struct stm32mp_exti_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	const struct stm32mp_exti_bank *bank = chip_data->reg_bank;
+	void __iomem *base = chip_data->host_data->base;
+	u32 mask = BIT(d->hwirq % IRQS_PER_BANK);
+
+	writel_relaxed(mask, base + bank->swier_ofst);
+
+	return 0;
+}
+
+static struct irq_chip stm32mp_exti_chip = {
+	.name			= "stm32mp-exti",
+	.irq_eoi		= stm32mp_exti_eoi,
+	.irq_ack		= irq_chip_ack_parent,
+	.irq_mask		= stm32mp_exti_mask,
+	.irq_unmask		= stm32mp_exti_unmask,
+	.irq_request_resources	= irq_chip_request_resources_parent,
+	.irq_release_resources	= irq_chip_release_resources_parent,
+	.irq_retrigger		= stm32mp_exti_retrigger,
+	.irq_set_type		= stm32mp_exti_set_type,
+	.irq_set_wake		= stm32mp_exti_set_wake,
+	.flags			= IRQCHIP_MASK_ON_SUSPEND,
+	.irq_set_affinity	= IS_ENABLED(CONFIG_SMP) ? irq_chip_set_affinity_parent : NULL,
+};
+
+static struct irq_chip stm32mp_exti_chip_direct = {
+	.name			= "stm32mp-exti-direct",
+	.irq_eoi		= irq_chip_eoi_parent,
+	.irq_ack		= irq_chip_ack_parent,
+	.irq_mask		= stm32mp_exti_mask,
+	.irq_unmask		= stm32mp_exti_unmask,
+	.irq_request_resources	= irq_chip_request_resources_parent,
+	.irq_release_resources	= irq_chip_release_resources_parent,
+	.irq_retrigger		= irq_chip_retrigger_hierarchy,
+	.irq_set_type		= irq_chip_set_type_parent,
+	.irq_set_wake		= stm32mp_exti_set_wake,
+	.flags			= IRQCHIP_MASK_ON_SUSPEND,
+	.irq_set_affinity	= IS_ENABLED(CONFIG_SMP) ? irq_chip_set_affinity_parent : NULL,
+};
+
+static bool stm32mp_exti_test_gpio_mux_available(struct stm32mp_exti_host_data *host_data,
+						 unsigned int bank_nr,
+						 unsigned int gpio_nr)
+{
+	if (gpio_nr >= STM32MP_GPIO_IRQ_LINES)
+		return false;
+
+	if (!test_bit(gpio_nr, host_data->gpio_mux_used) ||
+	    bank_nr == host_data->gpio_mux_pos[gpio_nr])
+		return true;
+
+	return false;
+}
+
+static int stm32mp_exti_domain_match(struct irq_domain *dm,
+				     struct device_node *node,
+				     enum irq_domain_bus_token bus_token)
+{
+	struct stm32mp_exti_host_data *host_data = dm->host_data;
+
+	if (!node ||
+	    (bus_token != DOMAIN_BUS_ANY && dm->bus_token != bus_token))
+		return 0;
+
+	if (!host_data->dt_has_irqs_desc)
+		return (to_of_node(dm->fwnode) == node);
+
+	if (node != host_data->dev->of_node)
+		return 0;
+
+	return (to_of_node(dm->parent->fwnode) ==
+		of_irq_find_parent(host_data->dev->of_node));
+}
+
+static int stm32mp_exti_domain_select(struct irq_domain *dm,
+				      struct irq_fwspec *fwspec,
+				      enum irq_domain_bus_token bus_token)
+{
+	struct fwnode_handle *fwnode = fwspec->fwnode;
+	struct stm32mp_exti_host_data *host_data = dm->host_data;
+	irq_hw_number_t hwirq = fwspec->param[0];
+	struct of_phandle_args out_irq;
+	u32 gpio_bank;
+	int ret;
+
+	if (!fwnode ||
+	    (bus_token != DOMAIN_BUS_ANY && dm->bus_token != bus_token))
+		return 0;
+
+	if (!host_data->dt_has_irqs_desc)
+		return (dm->fwnode == fwnode);
+
+	if (fwnode != of_node_to_fwnode(host_data->dev->of_node))
+		return 0;
+
+	gpio_bank = FIELD_GET(STM32MP_GPIO_BANK_MASK, fwspec->param[1]);
+
+	if (hwirq < STM32MP_GPIO_IRQ_LINES && !host_data->has_syscon &&
+	    ((host_data->chips_data[0].event_reserved & BIT(hwirq)) ||
+	     !stm32mp_exti_test_gpio_mux_available(host_data, gpio_bank, hwirq)))
+		return 0;
+
+	ret = of_irq_parse_one(host_data->dev->of_node, hwirq, &out_irq);
+	if (ret)
+		return 0;
+
+	return (dm->parent->fwnode == of_node_to_fwnode(out_irq.np));
+}
+
+static int stm32mp_exti_gpio_bank_alloc(struct irq_domain *dm, struct irq_fwspec *fwspec)
+{
+	struct stm32mp_exti_host_data *host_data = dm->host_data;
+	struct hwspinlock *hwlock = host_data->hwlock;
+	irq_hw_number_t hwirq = fwspec->param[0];
+	void __iomem *base = host_data->base;
+	u32 cr, gpio_bank;
+	int ret;
+
+	if (host_data->has_syscon)
+		return 0;
+
+	if (hwirq >= STM32MP_GPIO_IRQ_LINES)
+		return 0;
+
+	gpio_bank = FIELD_GET(STM32MP_GPIO_BANK_MASK, fwspec->param[1]);
+
+	if (!stm32mp_exti_test_gpio_mux_available(host_data, gpio_bank, hwirq)) {
+		pr_debug("GPIO IRQ %ld already in use\n", hwirq);
+		return -EBUSY;
+	}
+
+	raw_spin_lock(&host_data->gpio_mux_lock);
+
+	if (hwlock) {
+		ret = hwspin_lock_timeout_in_atomic(hwlock, HWSPNLCK_TIMEOUT);
+		if (ret) {
+			pr_err("%s can't get hwspinlock (%d)\n", __func__, ret);
+			raw_spin_unlock(&host_data->gpio_mux_lock);
+			return ret;
+		}
+	}
+
+	cr = readl_relaxed(base + EXTI_CR(hwirq));
+	cr &= ~EXTI_CR_MASK(hwirq);
+	cr |= (gpio_bank << EXTI_CR_SHIFT(hwirq)) & EXTI_CR_MASK(hwirq);
+	writel_relaxed(cr, base + EXTI_CR(hwirq));
+
+	if (hwlock)
+		hwspin_unlock_in_atomic(hwlock);
+
+	raw_spin_unlock(&host_data->gpio_mux_lock);
+
+	set_bit(hwirq, host_data->gpio_mux_used);
+	host_data->gpio_mux_pos[hwirq] = gpio_bank;
+
+	return 0;
+}
+
+static void stm32mp_exti_gpio_bank_free(struct irq_domain *dm, irq_hw_number_t hwirq)
+{
+	struct stm32mp_exti_host_data *host_data = dm->host_data;
+
+	if (host_data->has_syscon)
+		return;
+
+	if (hwirq < STM32MP_GPIO_IRQ_LINES)
+		clear_bit(hwirq, host_data->gpio_mux_used);
+}
+
+static int stm32mp_exti_domain_alloc(struct irq_domain *dm,
+				     unsigned int virq,
+				     unsigned int nr_irqs, void *data)
+{
+	struct stm32mp_exti_host_data *host_data = dm->host_data;
+	struct stm32mp_exti_chip_data *chip_data;
+	u8 desc_irq;
+	struct irq_fwspec *fwspec = data;
+	struct irq_fwspec p_fwspec;
+	struct of_phandle_args out_irq;
+	irq_hw_number_t hwirq;
+	int bank, ret;
+	u32 event_trg;
+	struct irq_chip *chip;
+
+	hwirq = fwspec->param[0];
+	if (hwirq >= host_data->drv_data->bank_nr * IRQS_PER_BANK)
+		return -EINVAL;
+
+	bank  = hwirq / IRQS_PER_BANK;
+	chip_data = &host_data->chips_data[bank];
+
+	/* Check if event is reserved (Secure) */
+	if (chip_data->event_reserved & BIT(hwirq % IRQS_PER_BANK)) {
+		dev_err(host_data->dev, "event %lu is reserved, secure\n", hwirq);
+		return -EPERM;
+	}
+
+	ret = stm32mp_exti_gpio_bank_alloc(dm, fwspec);
+	if (ret)
+		return ret;
+
+	event_trg = readl_relaxed(host_data->base + chip_data->reg_bank->trg_ofst);
+	chip = (event_trg & BIT(hwirq % IRQS_PER_BANK)) ?
+	       &stm32mp_exti_chip : &stm32mp_exti_chip_direct;
+
+	irq_domain_set_hwirq_and_chip(dm, virq, hwirq, chip, chip_data);
+
+	if (host_data->dt_has_irqs_desc) {
+		ret = of_irq_parse_one(host_data->dev->of_node, hwirq, &out_irq);
+		if (ret) {
+			stm32mp_exti_gpio_bank_free(dm, hwirq);
+			return ret;
+		}
+
+		of_phandle_args_to_fwspec(out_irq.np, out_irq.args,
+					  out_irq.args_count, &p_fwspec);
+
+		ret = irq_domain_alloc_irqs_parent(dm, virq, 1, &p_fwspec);
+		if (ret)
+			stm32mp_exti_gpio_bank_free(dm, hwirq);
+
+		return ret;
+	}
+
+	if (!host_data->drv_data->desc_irqs) {
+		stm32mp_exti_gpio_bank_free(dm, hwirq);
+		return -EINVAL;
+	}
+
+	desc_irq = host_data->drv_data->desc_irqs[hwirq];
+	if (desc_irq != EXTI_INVALID_IRQ) {
+		p_fwspec.fwnode = dm->parent->fwnode;
+		p_fwspec.param_count = 3;
+		p_fwspec.param[0] = GIC_SPI;
+		p_fwspec.param[1] = desc_irq;
+		p_fwspec.param[2] = IRQ_TYPE_LEVEL_HIGH;
+
+		ret = irq_domain_alloc_irqs_parent(dm, virq, 1, &p_fwspec);
+		if (ret)
+			stm32mp_exti_gpio_bank_free(dm, hwirq);
+
+		return ret;
+	}
+
+	return 0;
+}
+
+static void stm32mp_exti_domain_free(struct irq_domain *dm, unsigned int virq,
+				     unsigned int nr_irqs)
+{
+	struct irq_data *irq_data = irq_domain_get_irq_data(dm, virq);
+
+	stm32mp_exti_gpio_bank_free(dm, irq_data->hwirq);
+
+	irq_domain_free_irqs_common(dm, virq, nr_irqs);
+}
+
+static struct
+stm32mp_exti_chip_data *stm32mp_exti_chip_init(struct stm32mp_exti_host_data *h_data,
+					       u32 bank_idx,
+					       struct device_node *node)
+{
+	const struct stm32mp_exti_bank *bank;
+	struct stm32mp_exti_chip_data *chip_data;
+	void __iomem *base = h_data->base;
+
+	bank = h_data->drv_data->exti_banks[bank_idx];
+	chip_data = &h_data->chips_data[bank_idx];
+	chip_data->host_data = h_data;
+	chip_data->reg_bank = bank;
+
+	raw_spin_lock_init(&chip_data->rlock);
+
+	/*
+	 * This IP has no reset, so after hot reboot we should
+	 * clear registers to avoid residue
+	 */
+	writel_relaxed(0, base + bank->imr_ofst);
+
+	/* reserve Secure events */
+	chip_data->event_reserved = readl_relaxed(base + bank->seccfgr_ofst);
+
+	pr_info("%pOF: bank%d\n", node, bank_idx);
+
+	return chip_data;
+}
+
+static const struct irq_domain_ops stm32mp_exti_domain_ops = {
+	.match	= stm32mp_exti_domain_match,
+	.select = stm32mp_exti_domain_select,
+	.alloc	= stm32mp_exti_domain_alloc,
+	.free	= stm32mp_exti_domain_free,
+	.xlate = irq_domain_xlate_twocell,
+};
+
+static void stm32mp_exti_check_rif(struct stm32mp_exti_host_data *host_data)
+{
+	u32 cid, cidcfgr, hwcfgr1;
+	unsigned int bank, i, event;
+
+	/* quit on CID not supported */
+	hwcfgr1 = readl_relaxed(host_data->base + EXTI_HWCFGR1);
+	if ((hwcfgr1 & EXTI_HWCFGR1_CIDWIDTH_MASK) == 0)
+		return;
+
+	for (bank = 0; bank < host_data->drv_data->bank_nr; bank++) {
+		for (i = 0; i < IRQS_PER_BANK; i++) {
+			event = bank * IRQS_PER_BANK + i;
+			cidcfgr = readl_relaxed(host_data->base + EXTI_EnCIDCFGR(event));
+			cid = (cidcfgr & EXTI_CIDCFGR_CID_MASK) >> EXTI_CIDCFGR_CID_SHIFT;
+			if ((cidcfgr & EXTI_CIDCFGR_CFEN_MASK) && cid != EXTI_CID1)
+				host_data->chips_data[bank].event_reserved |= BIT(i);
+		}
+	}
+}
+
+static void stm32mp_exti_remove_irq(void *data)
+{
+	struct irq_domain *domain = data;
+	struct fwnode_handle *fwnode = domain->fwnode;
+
+	irq_domain_remove(domain);
+
+	if (is_fwnode_irqchip(fwnode))
+		irq_domain_free_fwnode(fwnode);
+}
+
+static int stm32mp_exti_probe(struct platform_device *pdev)
+{
+	int ret, i;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node, *wakeup_np;
+	struct irq_domain *parent_domain, *domain, *wakeup_domain;
+	struct fwnode_handle *fwnode;
+	struct stm32mp_exti_host_data *host_data;
+	const struct stm32mp_exti_drv_data *drv_data;
+	char *name;
+
+	host_data = devm_kzalloc(dev, sizeof(*host_data), GFP_KERNEL);
+	if (!host_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, host_data);
+	host_data->dev = dev;
+	raw_spin_lock_init(&host_data->gpio_mux_lock);
+
+	if (of_device_is_compatible(np, "syscon"))
+		host_data->has_syscon = true;
+
+	/* check for optional hwspinlock which may be not available yet */
+	ret = of_hwspin_lock_get_id(np, 0);
+	if (ret == -EPROBE_DEFER)
+		/* hwspinlock framework not yet ready */
+		return ret;
+
+	if (ret >= 0) {
+		host_data->hwlock = devm_hwspin_lock_request_specific(dev, ret);
+		if (!host_data->hwlock) {
+			dev_err(dev, "Failed to request hwspinlock\n");
+			return -EINVAL;
+		}
+	} else if (ret != -ENOENT) {
+		/* note: ENOENT is a valid case (means 'no hwspinlock') */
+		dev_err(dev, "Failed to get hwspinlock\n");
+		return ret;
+	}
+
+	/* initialize host_data */
+	drv_data = of_device_get_match_data(dev);
+	if (!drv_data) {
+		dev_err(dev, "no of match data\n");
+		return -ENODEV;
+	}
+	host_data->drv_data = drv_data;
+
+	host_data->chips_data = devm_kcalloc(dev, drv_data->bank_nr,
+					     sizeof(*host_data->chips_data),
+					     GFP_KERNEL);
+	if (!host_data->chips_data)
+		return -ENOMEM;
+
+	host_data->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(host_data->base))
+		return PTR_ERR(host_data->base);
+
+	for (i = 0; i < drv_data->bank_nr; i++)
+		stm32mp_exti_chip_init(host_data, i, np);
+
+	stm32mp_exti_check_rif(host_data);
+
+	parent_domain = irq_find_host(of_irq_find_parent(np));
+	if (!parent_domain) {
+		dev_err(dev, "GIC interrupt-parent not found\n");
+		return -EINVAL;
+	}
+
+	domain = irq_domain_add_hierarchy(parent_domain, 0,
+					  drv_data->bank_nr * IRQS_PER_BANK,
+					  np, &stm32mp_exti_domain_ops,
+					  host_data);
+
+	if (!domain) {
+		dev_err(dev, "Could not register exti domain\n");
+		return -ENOMEM;
+	}
+
+	ret = devm_add_action_or_reset(dev, stm32mp_exti_remove_irq, domain);
+	if (ret)
+		return ret;
+
+	if (of_property_read_bool(np, "interrupts-extended"))
+		host_data->dt_has_irqs_desc = true;
+
+	wakeup_np = of_parse_phandle(np, "wakeup-parent", 0);
+	if (wakeup_np && !host_data->dt_has_irqs_desc) {
+		dev_warn(dev, "wakeup-parent ignored due to missing interrupts-extended");
+		of_node_put(wakeup_np);
+		wakeup_np = NULL;
+	}
+	if (wakeup_np) {
+		wakeup_domain = irq_find_host(wakeup_np);
+		of_node_put(wakeup_np);
+		if (!wakeup_domain)
+			return -EPROBE_DEFER;
+
+		/* as in __irq_domain_add() */
+		name = kasprintf(GFP_KERNEL, "%pOF-wakeup", np);
+		if (!name)
+			return -ENOMEM;
+		strreplace(name, '/', ':');
+
+		fwnode = irq_domain_alloc_named_fwnode(name);
+		kfree(name);
+		if (!fwnode)
+			return -ENOMEM;
+
+		domain = irq_domain_create_hierarchy(wakeup_domain, 0,
+						     drv_data->bank_nr * IRQS_PER_BANK,
+						     fwnode, &stm32mp_exti_domain_ops,
+						     host_data);
+		if (!domain) {
+			dev_err(dev, "Could not register exti domain\n");
+			irq_domain_free_fwnode(fwnode);
+			return -ENOMEM;
+		}
+
+		ret = devm_add_action_or_reset(dev, stm32mp_exti_remove_irq, domain);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id stm32mp_exti_ids[] = {
+	{ .compatible = "st,stm32mp1-exti", .data = &stm32mp1_drv_data},
+	{ .compatible = "st,stm32mp13-exti", .data = &stm32mp13_drv_data},
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32mp_exti_ids);
+
+static const struct dev_pm_ops stm32mp_exti_dev_pm_ops = {
+	NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32mp_exti_suspend, stm32mp_exti_resume)
+};
+
+static struct platform_driver stm32mp_exti_driver = {
+	.probe		= stm32mp_exti_probe,
+	.driver		= {
+		.name	= "stm32mp_exti",
+		.of_match_table = stm32mp_exti_ids,
+		.pm = &stm32mp_exti_dev_pm_ops,
+	},
+};
+
+module_platform_driver(stm32mp_exti_driver);
+
+MODULE_AUTHOR("Maxime Coquelin <mcoquelin.stm32@gmail.com>");
+MODULE_DESCRIPTION("STM32MP EXTI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index 05d6fae80..e639c8ca4 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -232,7 +232,7 @@ config BCM_FLEXRM_MBOX
 
 config STM32_IPCC
 	tristate "STM32 IPCC Mailbox"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	  Mailbox implementation for STMicroelectonics STM32 family chips
 	  with hardware for Inter-Processor Communication Controller (IPCC)
diff --git a/drivers/mailbox/stm32-ipcc.c b/drivers/mailbox/stm32-ipcc.c
index 15d538fe2..3254abb01 100644
--- a/drivers/mailbox/stm32-ipcc.c
+++ b/drivers/mailbox/stm32-ipcc.c
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm_wakeirq.h>
+#include <linux/workqueue.h>
 
 #define IPCC_XCR		0x000
 #define XCR_RXOIE		BIT(0)
@@ -24,8 +25,17 @@
 
 #define IPCC_PROC_OFFST		0x010
 
+#define IPCC_SECCFGR(x)		(x ? 0x90 : 0x80)
+#define IPCC_PRIVCFGR(x)	(x ? 0x94 : 0x84)
+
+#define IPCC_CIDCFGR(x)		(x ? 0x98 : 0x88)
+#define IPCC_CIDCFGR_CFEN_MASK	BIT(0)
+#define IPCC_CIDCFGR_SCID_MASK	GENMASK(7, 4)
+
 #define IPCC_HWCFGR		0x3f0
 #define IPCFGR_CHAN_MASK	GENMASK(7, 0)
+#define IPCFGR_SECCTRL_MASK	GENMASK(11, 8)
+#define IPCFGR_CIDWIDTH_MASK	GENMASK(27, 24)
 
 #define IPCC_VER		0x3f4
 #define VER_MINREV_MASK		GENMASK(3, 0)
@@ -39,23 +49,39 @@
 
 #define STM32_MAX_PROCS		2
 
+#define IPCC_CORE_ID		1
+
+/* Use virtual ID by setting bit 8 of a channel ID to keep interrupt context for client */
+#define STM32_IPCC_CH_ID_MASK		GENMASK(7, 0)
+#define STM32_IPCC_CH_HIGH_PRIO_MASK	GENMASK(8, 8)
+
 enum {
 	IPCC_IRQ_RX,
 	IPCC_IRQ_TX,
 	IPCC_IRQ_NUM,
 };
 
+struct stm32_ipcc_ch {
+	struct mbox_chan   *mbox;
+	struct work_struct rx_work;
+	unsigned long      chan;
+	bool               irq_ctx;
+};
+
 struct stm32_ipcc {
 	struct mbox_controller controller;
 	void __iomem *reg_base;
 	void __iomem *reg_proc;
 	struct clk *clk;
+	struct stm32_ipcc_ch *chnl;
+	struct workqueue_struct *workqueue;
 	spinlock_t lock; /* protect access to IPCC registers */
 	int irqs[IPCC_IRQ_NUM];
 	u32 proc_id;
 	u32 n_chans;
 	u32 xcr;
 	u32 xmr;
+	u32 sec_mode;
 };
 
 static inline void stm32_ipcc_set_bits(spinlock_t *lock, void __iomem *reg,
@@ -78,10 +104,21 @@ static inline void stm32_ipcc_clr_bits(spinlock_t *lock, void __iomem *reg,
 	spin_unlock_irqrestore(lock, flags);
 }
 
+/*
+ * Message receiver(workqueue)
+ */
+static void stm32_ipcc_rx_work(struct work_struct *work)
+{
+	struct stm32_ipcc_ch *chnl = container_of(work, struct stm32_ipcc_ch, rx_work);
+
+	mbox_chan_received_data(chnl->mbox, NULL);
+};
+
 static irqreturn_t stm32_ipcc_rx_irq(int irq, void *data)
 {
 	struct stm32_ipcc *ipcc = data;
 	struct device *dev = ipcc->controller.dev;
+	struct stm32_ipcc_ch *chnl;
 	u32 status, mr, tosr, chan;
 	irqreturn_t ret = IRQ_NONE;
 	int proc_offset;
@@ -100,7 +137,17 @@ static irqreturn_t stm32_ipcc_rx_irq(int irq, void *data)
 
 		dev_dbg(dev, "%s: chan:%d rx\n", __func__, chan);
 
-		mbox_chan_received_data(&ipcc->controller.chans[chan], NULL);
+		chnl = &ipcc->chnl[chan];
+
+		/*
+		 * Depending on the DT parameter,call the client under interrupt context
+		 * or use workqueue to call the callback in normal context
+		 */
+
+		if (chnl->irq_ctx)
+			mbox_chan_received_data(chnl->mbox, NULL);
+		else
+			queue_work(ipcc->workqueue, &chnl->rx_work);
 
 		stm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XSCR,
 				    RX_BIT_CHAN(chan));
@@ -144,7 +191,8 @@ static irqreturn_t stm32_ipcc_tx_irq(int irq, void *data)
 
 static int stm32_ipcc_send_data(struct mbox_chan *link, void *data)
 {
-	unsigned long chan = (unsigned long)link->con_priv;
+	struct stm32_ipcc_ch *chnl = (struct stm32_ipcc_ch *)link->con_priv;
+	unsigned long chan = chnl->chan;
 	struct stm32_ipcc *ipcc = container_of(link->mbox, struct stm32_ipcc,
 					       controller);
 
@@ -163,7 +211,8 @@ static int stm32_ipcc_send_data(struct mbox_chan *link, void *data)
 
 static int stm32_ipcc_startup(struct mbox_chan *link)
 {
-	unsigned long chan = (unsigned long)link->con_priv;
+	struct stm32_ipcc_ch *chnl = (struct stm32_ipcc_ch *)link->con_priv;
+	unsigned long chan = chnl->chan;
 	struct stm32_ipcc *ipcc = container_of(link->mbox, struct stm32_ipcc,
 					       controller);
 	int ret;
@@ -183,7 +232,8 @@ static int stm32_ipcc_startup(struct mbox_chan *link)
 
 static void stm32_ipcc_shutdown(struct mbox_chan *link)
 {
-	unsigned long chan = (unsigned long)link->con_priv;
+	struct stm32_ipcc_ch *chnl = (struct stm32_ipcc_ch *)link->con_priv;
+	unsigned long chan = chnl->chan;
 	struct stm32_ipcc *ipcc = container_of(link->mbox, struct stm32_ipcc,
 					       controller);
 
@@ -191,25 +241,79 @@ static void stm32_ipcc_shutdown(struct mbox_chan *link)
 	stm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,
 			    RX_BIT_CHAN(chan) | TX_BIT_CHAN(chan));
 
+	if (!chnl->irq_ctx)
+		flush_work(&chnl->rx_work);
+
 	clk_disable_unprepare(ipcc->clk);
 }
 
+static int stm32_ipcc_check_rif(struct stm32_ipcc *ipcc, unsigned long chan)
+{
+	struct device *dev = ipcc->controller.dev;
+	u32 cfgr;
+
+	if (!ipcc->sec_mode)
+		return 0;
+
+	cfgr = readl_relaxed(ipcc->reg_base + IPCC_SECCFGR(ipcc->proc_id));
+	if (cfgr & BIT(chan)) {
+		dev_err(dev, "Unexpected secure configuration for chan %lu\n", chan);
+		return -EACCES;
+	}
+
+	/*
+	 * The privilege state is not checked as the client driver has privileged access right.
+	 * It is only read for debug information.
+	 */
+	cfgr = readl_relaxed(ipcc->reg_base + IPCC_PRIVCFGR(ipcc->proc_id));
+	dev_dbg(dev, "chan %lu is configured as %sprivileged\n", chan,
+		(cfgr & BIT(chan)) ? "" : "un");
+
+	return 0;
+}
+
 static const struct mbox_chan_ops stm32_ipcc_ops = {
 	.send_data	= stm32_ipcc_send_data,
 	.startup	= stm32_ipcc_startup,
 	.shutdown	= stm32_ipcc_shutdown,
 };
 
+static struct mbox_chan *stm32_ipcc_xlate(struct mbox_controller *mbox,
+					  const struct of_phandle_args *sp)
+{
+	u32 ind = sp->args[0] & STM32_IPCC_CH_ID_MASK;
+	struct stm32_ipcc *ipcc = container_of(mbox, struct stm32_ipcc, controller);
+	struct stm32_ipcc_ch *chnl;
+	int ret;
+
+	if (ind >= mbox->num_chans)
+		return ERR_PTR(-EINVAL);
+
+	chnl = (struct stm32_ipcc_ch *)mbox->chans[ind].con_priv;
+	ret = stm32_ipcc_check_rif(ipcc, ind);
+	if (ret)
+		return ERR_PTR(ret);
+
+	chnl->mbox = &mbox->chans[ind];
+	chnl->chan = ind;
+	chnl->irq_ctx = !!(sp->args[0] & STM32_IPCC_CH_HIGH_PRIO_MASK);
+
+	if (!chnl->irq_ctx)
+		INIT_WORK(&chnl->rx_work, stm32_ipcc_rx_work);
+
+	return &mbox->chans[ind];
+}
+
 static int stm32_ipcc_probe(struct platform_device *pdev)
 {
+	static const char * const irq_name[] = {"rx", "tx"};
+	irq_handler_t irq_thread[] = {stm32_ipcc_rx_irq, stm32_ipcc_tx_irq};
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 	struct stm32_ipcc *ipcc;
+	u32 ip_ver, hwcfg, cidcfgr, cid, cid_mask, cfen;
 	unsigned long i;
 	int ret;
-	u32 ip_ver;
-	static const char * const irq_name[] = {"rx", "tx"};
-	irq_handler_t irq_thread[] = {stm32_ipcc_rx_irq, stm32_ipcc_tx_irq};
 
 	if (!np) {
 		dev_err(dev, "No DT found\n");
@@ -268,7 +372,27 @@ static int stm32_ipcc_probe(struct platform_device *pdev)
 		}
 	}
 
-	/* mask and enable rx/tx irq */
+	hwcfg = readl_relaxed(ipcc->reg_base + IPCC_HWCFGR);
+	ipcc->n_chans = FIELD_GET(IPCFGR_CHAN_MASK, hwcfg);
+	ipcc->sec_mode = FIELD_GET(IPCFGR_SECCTRL_MASK, hwcfg);
+	cid_mask = FIELD_GET(IPCFGR_CIDWIDTH_MASK, hwcfg);
+
+	/* Check RIF CID*/
+	if (cid_mask) {
+		cidcfgr = readl(ipcc->reg_base + IPCC_CIDCFGR(ipcc->proc_id));
+		cid = FIELD_GET(IPCC_CIDCFGR_SCID_MASK, cidcfgr);
+		cfen = FIELD_GET(IPCC_CIDCFGR_CFEN_MASK, cidcfgr);
+		if (cfen && ((cid & cid_mask) != IPCC_CORE_ID)) {
+			dev_err(dev, "Unexpected CID%u, no access right\n", cid & cid_mask);
+			ret = -EPERM;
+			goto err_init_wkp;
+		}
+	}
+
+	/*
+	 * Mask and enable all rx/tx irq.
+	 * If CHnSEC bit is enabled, the CHnFM bit will not be updated by hardware
+	 */
 	stm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XMR,
 			    RX_BIT_MASK | TX_BIT_MASK);
 	stm32_ipcc_set_bits(&ipcc->lock, ipcc->reg_proc + IPCC_XCR,
@@ -285,13 +409,10 @@ static int stm32_ipcc_probe(struct platform_device *pdev)
 		}
 	}
 
-	/* mailbox controller */
-	ipcc->n_chans = readl_relaxed(ipcc->reg_base + IPCC_HWCFGR);
-	ipcc->n_chans &= IPCFGR_CHAN_MASK;
-
 	ipcc->controller.dev = dev;
 	ipcc->controller.txdone_irq = true;
 	ipcc->controller.ops = &stm32_ipcc_ops;
+	ipcc->controller.of_xlate = &stm32_ipcc_xlate;
 	ipcc->controller.num_chans = ipcc->n_chans;
 	ipcc->controller.chans = devm_kcalloc(dev, ipcc->controller.num_chans,
 					      sizeof(*ipcc->controller.chans),
@@ -301,13 +422,27 @@ static int stm32_ipcc_probe(struct platform_device *pdev)
 		goto err_irq_wkp;
 	}
 
+	ipcc->chnl = devm_kcalloc(dev, ipcc->controller.num_chans,
+				  sizeof(*ipcc->chnl), GFP_KERNEL);
+	if (!ipcc->chnl) {
+		ret = -ENOMEM;
+		goto err_irq_wkp;
+	}
+
 	for (i = 0; i < ipcc->controller.num_chans; i++)
-		ipcc->controller.chans[i].con_priv = (void *)i;
+		ipcc->controller.chans[i].con_priv = (void *)&ipcc->chnl[i];
 
 	ret = devm_mbox_controller_register(dev, &ipcc->controller);
 	if (ret)
 		goto err_irq_wkp;
 
+	ipcc->workqueue = create_workqueue(dev_name(dev));
+	if (!ipcc->workqueue) {
+		dev_err(dev, "cannot create workqueue\n");
+		ret = -ENOMEM;
+		goto err_irq_wkp;
+	}
+
 	platform_set_drvdata(pdev, ipcc);
 
 	ip_ver = readl_relaxed(ipcc->reg_base + IPCC_VER);
@@ -333,10 +468,13 @@ static int stm32_ipcc_probe(struct platform_device *pdev)
 static int stm32_ipcc_remove(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct stm32_ipcc *ipcc = dev_get_drvdata(dev);
 
 	if (of_property_read_bool(dev->of_node, "wakeup-source"))
 		dev_pm_clear_wake_irq(&pdev->dev);
 
+	destroy_workqueue(ipcc->workqueue);
+
 	device_set_wakeup_capable(dev, false);
 
 	return 0;
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index a34afb521..3f3e87039 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -54,6 +54,18 @@ config VIDEO_AR0521
 	  To compile this driver as a module, choose M here: the
 	  module will be called ar0521.
 
+config VIDEO_GC2145
+	tristate "GalaxyCore GC2145 sensor support"
+	depends on I2C && VIDEO_DEV
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  This is a V4L2 sensor-level driver for GalaxyCore GC2145
+	  2 Mpixel camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gc2145.
+
 config VIDEO_HI556
 	tristate "Hynix Hi-556 sensor support"
 	depends on I2C && VIDEO_DEV
@@ -83,6 +95,7 @@ config VIDEO_HI846
 config VIDEO_HI847
         tristate "Hynix Hi-847 sensor support"
         depends on I2C && VIDEO_DEV
+
         select MEDIA_CONTROLLER
         select VIDEO_V4L2_SUBDEV_API
         select V4L2_FWNODE
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 0a2933103..ecd1b2ef6 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -118,6 +118,7 @@ obj-$(CONFIG_VIDEO_SONY_BTF_MPX) += sony-btf-mpx.o
 obj-$(CONFIG_VIDEO_SR030PC30) += sr030pc30.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
 obj-$(CONFIG_VIDEO_TC358743) += tc358743.o
+obj-$(CONFIG_VIDEO_GC2145)	+= gc2145.o
 obj-$(CONFIG_VIDEO_TDA1997X) += tda1997x.o
 obj-$(CONFIG_VIDEO_TDA7432) += tda7432.o
 obj-$(CONFIG_VIDEO_TDA9840) += tda9840.o
diff --git a/drivers/media/i2c/gc2145.c b/drivers/media/i2c/gc2145.c
new file mode 100644
index 000000000..ead364f97
--- /dev/null
+++ b/drivers/media/i2c/gc2145.c
@@ -0,0 +1,1989 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * A V4L2 driver for Galaxycore GC2145 camera.
+ * Copyright (C) 2022, STMicroelectronics SA
+ *
+ * Inspired from the imx219.c driver
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/units.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-mediabus.h>
+
+/* Chip ID */
+/* Page 0 */
+#define GC2145_REG_ANALOG_MODE1	0x17
+#define GC2145_REG_OUTPUT_FMT	0x84
+#define GC2145_REG_SYNC_MODE	0x86
+#define GC2145_SYNC_MODE_COL_SWITCH	BIT(4)
+#define GC2145_SYNC_MODE_ROW_SWITCH	BIT(5)
+#define GC2145_REG_DEBUG_MODE2	0x8c
+#define GC2145_REG_DEBUG_MODE3	0x8d
+#define GC2145_REG_CHIP_ID	0xf0
+#define GC2145_REG_PAGE_SELECT	0xfe
+/* Page 3 */
+#define GC2145_REG_FIFO_FULL_LVL_LOW	0x04
+#define GC2145_REG_FIFO_FULL_LVL_HIGH	0x05
+#define GC2145_REG_MIPI_DT	0x11
+#define GC2145_REG_LWC_LOW	0x12
+#define GC2145_REG_LWC_HIGH	0x13
+#define GC2145_REG_FIFO_GATE_MODE	0x17
+
+#define GC2145_CHIP_ID		0x2145
+
+/* External clock frequency is 24.0MHz */
+#define GC2145_XCLK_FREQ	(24 * HZ_PER_MHZ)
+
+struct gc2145_reg {
+	unsigned char address;
+	unsigned char val;
+};
+
+struct gc2145_reg_list {
+	unsigned int num_of_regs;
+	const struct gc2145_reg *regs;
+};
+
+/**
+ * struct gc2145_mode - GC2145 mode description
+ * @width: frame width (in pixel)
+ * @height: frame height (in pixel)
+ * @frame_interval: interval (fractionnal) between 2 frames
+ * @reg_list: registers config sequence to enter into the mode
+ * @pixel_rate: pixel_rate associated with the mode
+ */
+struct gc2145_mode {
+	unsigned int width;
+	unsigned int height;
+	struct v4l2_fract frame_interval;
+	struct gc2145_reg_list reg_list;
+	unsigned long pixel_rate;
+};
+
+#define GC2145_640_480_PIXELRATE	(60 * HZ_PER_MHZ)
+static const struct gc2145_reg mode_640_480_regs[] = {
+	{0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfc, 0x06},
+	{0xf6, 0x00}, {0xf7, 0x1d}, {0xf8, 0x86}, {0xfa, 0x00},
+	{0xf9, 0x8e}, {0xf2, 0x00},
+	/* ISP registers */
+	{0xfe, 0x00},
+	/* Exposure */
+	{0x03, 0x04}, {0x04, 0xe2},
+	/* Offset Y */
+	{0x09, 0x00}, {0x0a, 0x00},
+	/* Offset X */
+	{0x0b, 0x00}, {0x0c, 0x00},
+	/* Windows Height */
+	{0x0d, 0x04}, {0x0e, 0xc0},
+	/* Windows Width */
+	{0x0f, 0x06}, {0x10, 0x52},
+	/* SH Delay */
+	{0x12, 0x2e},
+	/* Flip */
+	{0x17, 0x14},
+	/* Analog Mode 2 (row skip ??) */
+	{0x18, 0x22}, {0x19, 0x0e}, {0x1a, 0x01}, {0x1b, 0x4b},
+	{0x1c, 0x07}, {0x1d, 0x10}, {0x1e, 0x88}, {0x1f, 0x78},
+	{0x20, 0x03}, {0x21, 0x40}, {0x22, 0xa0}, {0x24, 0x16},
+	{0x25, 0x01}, {0x26, 0x10}, {0x2d, 0x60}, {0x30, 0x01},
+	{0x31, 0x90}, {0x33, 0x06}, {0x34, 0x01},
+	{0xfe, 0x00},
+	{0x80, 0x7f}, {0x81, 0x26}, {0x82, 0xfa}, {0x83, 0x00},
+	{0x84, 0x02}, {0x86, 0x02}, {0x88, 0x03}, {0x89, 0x03},
+	{0x85, 0x08}, {0x8a, 0x00}, {0x8b, 0x00}, {0xb0, 0x55},
+	{0xc3, 0x00}, {0xc4, 0x80}, {0xc5, 0x90}, {0xc6, 0x3b},
+	{0xc7, 0x46}, {0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60},
+	{0xef, 0x90}, {0xb6, 0x01},
+	/* Crop */
+	{0x90, 0x01},
+	{0x91, 0x00}, {0x92, 0x00},
+	{0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x04}, {0x96, 0xb0},
+	{0x97, 0x06}, {0x98, 0x40},
+	/* BLK */
+	{0xfe, 0x00},
+	{0x40, 0x42}, {0x41, 0x00}, {0x43, 0x5b}, {0x5e, 0x00},
+	{0x5f, 0x00}, {0x60, 0x00}, {0x61, 0x00}, {0x62, 0x00},
+	{0x63, 0x00}, {0x64, 0x00}, {0x65, 0x00}, {0x66, 0x20},
+	{0x67, 0x20}, {0x68, 0x20}, {0x69, 0x20}, {0x76, 0x00},
+	{0x6a, 0x08}, {0x6b, 0x08}, {0x6c, 0x08}, {0x6d, 0x08},
+	{0x6e, 0x08}, {0x6f, 0x08}, {0x70, 0x08}, {0x71, 0x08},
+	{0x76, 0x00}, {0x72, 0xf0}, {0x7e, 0x3c}, {0x7f, 0x00},
+	{0xfe, 0x02},
+	{0x48, 0x15}, {0x49, 0x00}, {0x4b, 0x0b},
+	{0xfe, 0x00},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x09, 0x00}, {0x0a, 0x82}, {0x0b, 0x11}, {0x0c, 0x10},
+	{0x11, 0x10}, {0x13, 0x7b}, {0x17, 0x00}, {0x1c, 0x11},
+	{0x1e, 0x61}, {0x1f, 0x35}, {0x20, 0x40}, {0x22, 0x40},
+	{0x23, 0x20},
+	{0xfe, 0x02},
+	{0x0f, 0x04},
+	{0xfe, 0x01},
+	{0x12, 0x35}, {0x15, 0xb0}, {0x10, 0x31}, {0x3e, 0x28},
+	{0x3f, 0xb0}, {0x40, 0x90}, {0x41, 0x0f},
+	/* INTPEE */
+	{0xfe, 0x02},
+	{0x90, 0x6c}, {0x91, 0x03}, {0x92, 0xcb}, {0x94, 0x33},
+	{0x95, 0x84}, {0x97, 0x65}, {0xa2, 0x11},
+	{0xfe, 0x00},
+	/* DNDD */
+	{0xfe, 0x02},
+	{0x80, 0xc1}, {0x81, 0x08}, {0x82, 0x05}, {0x83, 0x08},
+	{0x84, 0x0a}, {0x86, 0xf0}, {0x87, 0x50}, {0x88, 0x15},
+	{0x89, 0xb0}, {0x8a, 0x30}, {0x8b, 0x10},
+	/* ASDE */
+	{0xfe, 0x01},
+	{0x21, 0x04},
+	{0xfe, 0x02},
+	{0xa3, 0x50}, {0xa4, 0x20}, {0xa5, 0x40}, {0xa6, 0x80},
+	{0xab, 0x40}, {0xae, 0x0c}, {0xb3, 0x46}, {0xb4, 0x64},
+	{0xb6, 0x38}, {0xb7, 0x01}, {0xb9, 0x2b}, {0x3c, 0x04},
+	{0x3d, 0x15}, {0x4b, 0x06}, {0x4c, 0x20},
+	{0xfe, 0x00},
+	/* Gamma */
+	{0xfe, 0x02},
+	{0x10, 0x09}, {0x11, 0x0d}, {0x12, 0x13}, {0x13, 0x19},
+	{0x14, 0x27}, {0x15, 0x37}, {0x16, 0x45}, {0x17, 0x53},
+	{0x18, 0x69}, {0x19, 0x7d}, {0x1a, 0x8f}, {0x1b, 0x9d},
+	{0x1c, 0xa9}, {0x1d, 0xbd}, {0x1e, 0xcd}, {0x1f, 0xd9},
+	{0x20, 0xe3}, {0x21, 0xea}, {0x22, 0xef}, {0x23, 0xf5},
+	{0x24, 0xf9}, {0x25, 0xff},
+	{0xfe, 0x00},
+	{0xc6, 0x20}, {0xc7, 0x2b},
+	/* Gamma 2 */
+	{0xfe, 0x02},
+	{0x26, 0x0f}, {0x27, 0x14}, {0x28, 0x19}, {0x29, 0x1e},
+	{0x2a, 0x27}, {0x2b, 0x33}, {0x2c, 0x3b}, {0x2d, 0x45},
+	{0x2e, 0x59}, {0x2f, 0x69}, {0x30, 0x7c}, {0x31, 0x89},
+	{0x32, 0x98}, {0x33, 0xae}, {0x34, 0xc0}, {0x35, 0xcf},
+	{0x36, 0xda}, {0x37, 0xe2}, {0x38, 0xe9}, {0x39, 0xf3},
+	{0x3a, 0xf9}, {0x3b, 0xff},
+	/* YCP */
+	{0xfe, 0x02},
+	{0xd1, 0x32}, {0xd2, 0x32}, {0xd3, 0x40}, {0xd6, 0xf0},
+	{0xd7, 0x10}, {0xd8, 0xda}, {0xdd, 0x14}, {0xde, 0x86},
+	{0xed, 0x80}, {0xee, 0x00}, {0xef, 0x3f}, {0xd8, 0xd8},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	/* LSC */
+	{0xfe, 0x01},
+	{0xc2, 0x14}, {0xc3, 0x0d}, {0xc4, 0x0c}, {0xc8, 0x15},
+	{0xc9, 0x0d}, {0xca, 0x0a}, {0xbc, 0x24}, {0xbd, 0x10},
+	{0xbe, 0x0b}, {0xb6, 0x25}, {0xb7, 0x16}, {0xb8, 0x15},
+	{0xc5, 0x00}, {0xc6, 0x00}, {0xc7, 0x00}, {0xcb, 0x00},
+	{0xcc, 0x00}, {0xcd, 0x00}, {0xbf, 0x07}, {0xc0, 0x00},
+	{0xc1, 0x00}, {0xb9, 0x00}, {0xba, 0x00}, {0xbb, 0x00},
+	{0xaa, 0x01}, {0xab, 0x01}, {0xac, 0x00}, {0xad, 0x05},
+	{0xae, 0x06}, {0xaf, 0x0e}, {0xb0, 0x0b}, {0xb1, 0x07},
+	{0xb2, 0x06}, {0xb3, 0x17}, {0xb4, 0x0e}, {0xb5, 0x0e},
+	{0xd0, 0x09}, {0xd1, 0x00}, {0xd2, 0x00}, {0xd6, 0x08},
+	{0xd7, 0x00}, {0xd8, 0x00}, {0xd9, 0x00}, {0xda, 0x00},
+	{0xdb, 0x00}, {0xd3, 0x0a}, {0xd4, 0x00}, {0xd5, 0x00},
+	{0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x77}, {0xa7, 0x77},
+	{0xa8, 0x77}, {0xa9, 0x77}, {0xa1, 0x80}, {0xa2, 0x80},
+	{0xfe, 0x01},
+	{0xdf, 0x0d}, {0xdc, 0x25}, {0xdd, 0x30}, {0xe0, 0x77},
+	{0xe1, 0x80}, {0xe2, 0x77}, {0xe3, 0x90}, {0xe6, 0x90},
+	{0xe7, 0xa0}, {0xe8, 0x90}, {0xe9, 0xa0},
+	{0xfe, 0x00},
+	/* AWB */
+	{0xfe, 0x01},
+	{0x4f, 0x00}, {0x4f, 0x00}, {0x4b, 0x01}, {0x4f, 0x00},
+	{0x4c, 0x01}, {0x4d, 0x71}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x91}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x70}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x90}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xb0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x8f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xaf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xd0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xf0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xcf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xef}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xae}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xce}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xad}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcd}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xac}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcc}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcb}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xab}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xaa}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xc9}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x89}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xa9}, {0x4e, 0x04},
+	{0x4c, 0x02}, {0x4d, 0x0b}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x0a}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xeb}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xea}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x09}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x29}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x2a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x4a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x8a}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x49}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x89}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xa9}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x48}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x68}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xca}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc9}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe9}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x09}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xa7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe7}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x07}, {0x4e, 0x07},
+	{0x4f, 0x01},
+	{0x50, 0x80}, {0x51, 0xa8}, {0x52, 0x47}, {0x53, 0x38},
+	{0x54, 0xc7}, {0x56, 0x0e}, {0x58, 0x08}, {0x5b, 0x00},
+	{0x5c, 0x74}, {0x5d, 0x8b}, {0x61, 0xdb}, {0x62, 0xb8},
+	{0x63, 0x86}, {0x64, 0xc0}, {0x65, 0x04}, {0x67, 0xa8},
+	{0x68, 0xb0}, {0x69, 0x00}, {0x6a, 0xa8}, {0x6b, 0xb0},
+	{0x6c, 0xaf}, {0x6d, 0x8b}, {0x6e, 0x50}, {0x6f, 0x18},
+	{0x73, 0xf0}, {0x70, 0x0d}, {0x71, 0x60}, {0x72, 0x80},
+	{0x74, 0x01}, {0x75, 0x01}, {0x7f, 0x0c}, {0x76, 0x70},
+	{0x77, 0x58}, {0x78, 0xa0}, {0x79, 0x5e}, {0x7a, 0x54},
+	{0x7b, 0x58},
+	{0xfe, 0x00},
+	/* CC */
+	{0xfe, 0x02},
+	{0xc0, 0x01}, {0xc1, 0x44}, {0xc2, 0xfd}, {0xc3, 0x04},
+	{0xc4, 0xf0}, {0xc5, 0x48}, {0xc6, 0xfd}, {0xc7, 0x46},
+	{0xc8, 0xfd}, {0xc9, 0x02}, {0xca, 0xe0}, {0xcb, 0x45},
+	{0xcc, 0xec}, {0xcd, 0x48}, {0xce, 0xf0}, {0xcf, 0xf0},
+	{0xe3, 0x0c}, {0xe4, 0x4b}, {0xe5, 0xe0},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	{0xfe, 0x00},
+	/* Dark sun */
+	{0xfe, 0x02},
+	{0x40, 0xbf}, {0x46, 0xcf},
+	{0xfe, 0x00},
+	/* Framerate 50Hz */
+	{0xfe, 0x00},
+	{0x05, 0x01}, {0x06, 0x30}, {0x07, 0x00}, {0x08, 0x0c},
+	{0xfe, 0x01},
+	{0x25, 0x01}, {0x26, 0x75}, {0x27, 0x04}, {0x28, 0x5f},
+	{0x29, 0x04}, {0x2a, 0x5f}, {0x2b, 0x04}, {0x2c, 0x5f},
+	{0x2d, 0x04}, {0x2e, 0x5f},
+	{0xfe, 0x00},
+	/* Output */
+	{0xfe, 0x00},
+	{0xf2, 0x00},
+	/* Mipi */
+	{0xfe, 0x03},
+	{0x02, 0x22}, {0x03, 0x10},
+	{0x06, 0x88}, {0x01, 0x87}, {0x10, 0x95}, {0x11, 0x1e},
+	{0x15, 0x10}, {0x22, 0x04},
+	{0x23, 0x10}, {0x24, 0x10}, {0x25, 0x10}, {0x26, 0x05},
+	{0x21, 0x10}, {0x29, 0x03}, {0x2a, 0x0a}, {0x2b, 0x06},
+	{0xfe, 0x00},
+	{0xfe, 0x00},
+	{0xfd, 0x01}, {0xfa, 0x00},
+	/* Crop window */
+	{0xfe, 0x00},
+	{0x90, 0x01}, {0x91, 0x00}, {0x92, 0x00}, {0x93, 0x00},
+	{0x94, 0x00}, {0x95, 0x01}, {0x96, 0xe0}, {0x97, 0x02},
+	{0x98, 0x80}, {0x99, 0x55}, {0x9a, 0x06}, {0x9b, 0x01},
+	{0x9c, 0x23}, {0x9d, 0x00}, {0x9e, 0x00}, {0x9f, 0x01},
+	{0xa0, 0x23}, {0xa1, 0x00}, {0xa2, 0x00},
+	/* AWB */
+	{0xfe, 0x00},
+	{0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60}, {0xef, 0x90},
+	{0xfe, 0x01},
+	{0x74, 0x01},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x0a, 0x82},
+	{0xfe, 0x01},
+	{0x21, 0x04},
+};
+
+#define GC2145_1280_720_PIXELRATE	(96 * HZ_PER_MHZ)
+static const struct gc2145_reg mode_1280_720_regs[] = {
+	{0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfc, 0x06},
+	{0xf6, 0x00}, {0xf7, 0x1d}, {0xf8, 0x83}, {0xfa, 0x00},
+	{0xf9, 0x8e}, {0xf2, 0x00},
+	/* ISP registers */
+	{0xfe, 0x00},
+	/* Exposure */
+	{0x03, 0x04}, {0x04, 0xe2},
+	/* Offset Y */
+	{0x09, 0x00}, {0x0a, 0xf0},
+	/* Offset X */
+	{0x0b, 0x00}, {0x0c, 0xa0},
+	/* Windows Height */
+	{0x0d, 0x02}, {0x0e, 0xe0},
+	/* Windows Width */
+	{0x0f, 0x05}, {0x10, 0x10},
+	/* SH Delay */
+	{0x12, 0x2e},
+	/* Flip */
+	{0x17, 0x14},
+	/* Analog Mode 2 (row skip ??) */
+	{0x18, 0x22}, {0x19, 0x0e}, {0x1a, 0x01}, {0x1b, 0x4b},
+	{0x1c, 0x07}, {0x1d, 0x10}, {0x1e, 0x88}, {0x1f, 0x78},
+	{0x20, 0x03}, {0x21, 0x40}, {0x22, 0xa0}, {0x24, 0x3f},
+	{0x25, 0x01}, {0x26, 0x10}, {0x2d, 0x60}, {0x30, 0x01},
+	{0x31, 0x90}, {0x33, 0x06}, {0x34, 0x01},
+	{0xfe, 0x00},
+	{0x80, 0x7f}, {0x81, 0x26}, {0x82, 0xfa}, {0x83, 0x00},
+	{0x84, 0x02}, {0x86, 0x06}, {0x88, 0x03}, {0x89, 0x03},
+	{0x85, 0x08}, {0x8a, 0x00}, {0x8b, 0x00}, {0xb0, 0x55},
+	{0xc3, 0x00}, {0xc4, 0x80}, {0xc5, 0x90}, {0xc6, 0x3b},
+	{0xc7, 0x46}, {0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60},
+	{0xef, 0x90}, {0xb6, 0x01},
+	/* Crop */
+	{0x90, 0x01},
+	{0x91, 0x00}, {0x92, 0x00},
+	{0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x02}, {0x96, 0xd0},
+	{0x97, 0x05}, {0x98, 0x00},
+	/* BLK */
+	{0xfe, 0x00},
+	{0x40, 0x42}, {0x41, 0x00}, {0x43, 0x5b}, {0x5e, 0x00},
+	{0x5f, 0x00}, {0x60, 0x00}, {0x61, 0x00}, {0x62, 0x00},
+	{0x63, 0x00}, {0x64, 0x00}, {0x65, 0x00}, {0x66, 0x20},
+	{0x67, 0x20}, {0x68, 0x20}, {0x69, 0x20}, {0x76, 0x00},
+	{0x6a, 0x08}, {0x6b, 0x08}, {0x6c, 0x08}, {0x6d, 0x08},
+	{0x6e, 0x08}, {0x6f, 0x08}, {0x70, 0x08}, {0x71, 0x08},
+	{0x76, 0x00}, {0x72, 0xf0}, {0x7e, 0x3c}, {0x7f, 0x00},
+	{0xfe, 0x02},
+	{0x48, 0x15}, {0x49, 0x00}, {0x4b, 0x0b},
+	{0xfe, 0x00},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x09, 0x00}, {0x0a, 0x82}, {0x0b, 0x11}, {0x0c, 0x10},
+	{0x11, 0x10}, {0x13, 0x7b}, {0x17, 0x00}, {0x1c, 0x11},
+	{0x1e, 0x61}, {0x1f, 0x35}, {0x20, 0x40}, {0x22, 0x40},
+	{0x23, 0x20},
+	{0xfe, 0x02},
+	{0x0f, 0x04},
+	{0xfe, 0x01},
+	{0x12, 0x35}, {0x15, 0xb0}, {0x10, 0x31}, {0x3e, 0x28},
+	{0x3f, 0xb0}, {0x40, 0x90}, {0x41, 0x0f},
+	/* INTPEE */
+	{0xfe, 0x02},
+	{0x90, 0x6c}, {0x91, 0x03}, {0x92, 0xcb}, {0x94, 0x33},
+	{0x95, 0x84}, {0x97, 0x65}, {0xa2, 0x11},
+	{0xfe, 0x00},
+	/* DNDD */
+	{0xfe, 0x02},
+	{0x80, 0xc1}, {0x81, 0x08}, {0x82, 0x05}, {0x83, 0x08},
+	{0x84, 0x0a}, {0x86, 0xf0}, {0x87, 0x50}, {0x88, 0x15},
+	{0x89, 0xb0}, {0x8a, 0x30}, {0x8b, 0x10},
+	/* ASDE */
+	{0xfe, 0x01},
+	{0x21, 0x04},
+	{0xfe, 0x02},
+	{0xa3, 0x50}, {0xa4, 0x20}, {0xa5, 0x40}, {0xa6, 0x80},
+	{0xab, 0x40}, {0xae, 0x0c}, {0xb3, 0x46}, {0xb4, 0x64},
+	{0xb6, 0x38}, {0xb7, 0x01}, {0xb9, 0x2b}, {0x3c, 0x04},
+	{0x3d, 0x15}, {0x4b, 0x06}, {0x4c, 0x20},
+	{0xfe, 0x00},
+	/* Gamma */
+	{0xfe, 0x02},
+	{0x10, 0x09}, {0x11, 0x0d}, {0x12, 0x13}, {0x13, 0x19},
+	{0x14, 0x27}, {0x15, 0x37}, {0x16, 0x45}, {0x17, 0x53},
+	{0x18, 0x69}, {0x19, 0x7d}, {0x1a, 0x8f}, {0x1b, 0x9d},
+	{0x1c, 0xa9}, {0x1d, 0xbd}, {0x1e, 0xcd}, {0x1f, 0xd9},
+	{0x20, 0xe3}, {0x21, 0xea}, {0x22, 0xef}, {0x23, 0xf5},
+	{0x24, 0xf9}, {0x25, 0xff},
+	{0xfe, 0x00},
+	{0xc6, 0x20}, {0xc7, 0x2b},
+	/* Gamma 2 */
+	{0xfe, 0x02},
+	{0x26, 0x0f}, {0x27, 0x14}, {0x28, 0x19}, {0x29, 0x1e},
+	{0x2a, 0x27}, {0x2b, 0x33}, {0x2c, 0x3b}, {0x2d, 0x45},
+	{0x2e, 0x59}, {0x2f, 0x69}, {0x30, 0x7c}, {0x31, 0x89},
+	{0x32, 0x98}, {0x33, 0xae}, {0x34, 0xc0}, {0x35, 0xcf},
+	{0x36, 0xda}, {0x37, 0xe2}, {0x38, 0xe9}, {0x39, 0xf3},
+	{0x3a, 0xf9}, {0x3b, 0xff},
+	/* YCP */
+	{0xfe, 0x02},
+	{0xd1, 0x32}, {0xd2, 0x32}, {0xd3, 0x40}, {0xd6, 0xf0},
+	{0xd7, 0x10}, {0xd8, 0xda}, {0xdd, 0x14}, {0xde, 0x86},
+	{0xed, 0x80}, {0xee, 0x00}, {0xef, 0x3f}, {0xd8, 0xd8},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	/* LSC */
+	{0xfe, 0x01},
+	{0xc2, 0x14}, {0xc3, 0x0d}, {0xc4, 0x0c}, {0xc8, 0x15},
+	{0xc9, 0x0d}, {0xca, 0x0a}, {0xbc, 0x24}, {0xbd, 0x10},
+	{0xbe, 0x0b}, {0xb6, 0x25}, {0xb7, 0x16}, {0xb8, 0x15},
+	{0xc5, 0x00}, {0xc6, 0x00}, {0xc7, 0x00}, {0xcb, 0x00},
+	{0xcc, 0x00}, {0xcd, 0x00}, {0xbf, 0x07}, {0xc0, 0x00},
+	{0xc1, 0x00}, {0xb9, 0x00}, {0xba, 0x00}, {0xbb, 0x00},
+	{0xaa, 0x01}, {0xab, 0x01}, {0xac, 0x00}, {0xad, 0x05},
+	{0xae, 0x06}, {0xaf, 0x0e}, {0xb0, 0x0b}, {0xb1, 0x07},
+	{0xb2, 0x06}, {0xb3, 0x17}, {0xb4, 0x0e}, {0xb5, 0x0e},
+	{0xd0, 0x09}, {0xd1, 0x00}, {0xd2, 0x00}, {0xd6, 0x08},
+	{0xd7, 0x00}, {0xd8, 0x00}, {0xd9, 0x00}, {0xda, 0x00},
+	{0xdb, 0x00}, {0xd3, 0x0a}, {0xd4, 0x00}, {0xd5, 0x00},
+	{0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x77}, {0xa7, 0x77},
+	{0xa8, 0x77}, {0xa9, 0x77}, {0xa1, 0x80}, {0xa2, 0x80},
+	{0xfe, 0x01},
+	{0xdf, 0x0d}, {0xdc, 0x25}, {0xdd, 0x30}, {0xe0, 0x77},
+	{0xe1, 0x80}, {0xe2, 0x77}, {0xe3, 0x90}, {0xe6, 0x90},
+	{0xe7, 0xa0}, {0xe8, 0x90}, {0xe9, 0xa0},
+	{0xfe, 0x00},
+	/* AWB */
+	{0xfe, 0x01},
+	{0x4f, 0x00}, {0x4f, 0x00}, {0x4b, 0x01}, {0x4f, 0x00},
+	{0x4c, 0x01}, {0x4d, 0x71}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x91}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x70}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x90}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xb0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x8f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xaf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xd0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xf0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xcf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xef}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xae}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xce}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xad}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcd}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xac}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcc}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcb}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xab}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xaa}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xc9}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x89}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xa9}, {0x4e, 0x04},
+	{0x4c, 0x02}, {0x4d, 0x0b}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x0a}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xeb}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xea}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x09}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x29}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x2a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x4a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x8a}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x49}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x89}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xa9}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x48}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x68}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xca}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc9}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe9}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x09}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xa7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe7}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x07}, {0x4e, 0x07},
+	{0x4f, 0x01},
+	{0x50, 0x80}, {0x51, 0xa8}, {0x52, 0x47}, {0x53, 0x38},
+	{0x54, 0xc7}, {0x56, 0x0e}, {0x58, 0x08}, {0x5b, 0x00},
+	{0x5c, 0x74}, {0x5d, 0x8b}, {0x61, 0xdb}, {0x62, 0xb8},
+	{0x63, 0x86}, {0x64, 0xc0}, {0x65, 0x04}, {0x67, 0xa8},
+	{0x68, 0xb0}, {0x69, 0x00}, {0x6a, 0xa8}, {0x6b, 0xb0},
+	{0x6c, 0xaf}, {0x6d, 0x8b}, {0x6e, 0x50}, {0x6f, 0x18},
+	{0x73, 0xf0}, {0x70, 0x0d}, {0x71, 0x60}, {0x72, 0x80},
+	{0x74, 0x01}, {0x75, 0x01}, {0x7f, 0x0c}, {0x76, 0x70},
+	{0x77, 0x58}, {0x78, 0xa0}, {0x79, 0x5e}, {0x7a, 0x54},
+	{0x7b, 0x58},
+	{0xfe, 0x00},
+	/* CC */
+	{0xfe, 0x02},
+	{0xc0, 0x01}, {0xc1, 0x44}, {0xc2, 0xfd}, {0xc3, 0x04},
+	{0xc4, 0xf0}, {0xc5, 0x48}, {0xc6, 0xfd}, {0xc7, 0x46},
+	{0xc8, 0xfd}, {0xc9, 0x02}, {0xca, 0xe0}, {0xcb, 0x45},
+	{0xcc, 0xec}, {0xcd, 0x48}, {0xce, 0xf0}, {0xcf, 0xf0},
+	{0xe3, 0x0c}, {0xe4, 0x4b}, {0xe5, 0xe0},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	{0xfe, 0x00},
+	/* Dark sun */
+	{0xfe, 0x02},
+	{0x40, 0xbf}, {0x46, 0xcf},
+	{0xfe, 0x00},
+	/* Framerate 50Hz */
+	{0xfe, 0x00},
+	{0x05, 0x01}, {0x06, 0x56}, {0x07, 0x00}, {0x08, 0x11},
+	{0xfe, 0x01}, {0x25, 0x00}, {0x26, 0xe6}, {0x27, 0x02},
+	{0x28, 0xb2}, {0x29, 0x02}, {0x2a, 0xb2}, {0x2b, 0x02},
+	{0x2c, 0xb2}, {0x2d, 0x02}, {0x2e, 0xb2},
+	{0xfe, 0x00},
+	/* Output */
+	{0xfe, 0x00},
+	{0xf2, 0x00},
+	/* Mipi */
+	{0xfe, 0x03},
+	{0x01, 0x87}, {0x02, 0x22}, {0x03, 0x10},
+	{0x06, 0x88}, {0x10, 0x95}, {0x11, 0x1e},
+	{0x15, 0x12}, {0x22, 0x04},
+	{0x23, 0x10}, {0x24, 0x10}, {0x25, 0x10}, {0x26, 0x05},
+	{0x21, 0x10}, {0x29, 0x03}, {0x2a, 0x0a}, {0x2b, 0x06},
+	{0x42, 0x00}, {0x43, 0x05},
+	{0xfe, 0x00},
+};
+
+#define GC2145_1600_1200_PIXELRATE	(72 * HZ_PER_MHZ)
+static const struct gc2145_reg mode_1600_1200_regs[] = {
+	{0xfe, 0xf0}, {0xfe, 0xf0}, {0xfe, 0xf0}, {0xfc, 0x06},
+	{0xf6, 0x00}, {0xf7, 0x1d}, {0xf8, 0x84}, {0xfa, 0x00},
+	{0xf9, 0x8e}, {0xf2, 0x00},
+	/* ISP registers */
+	{0xfe, 0x00},
+	/* Exposure */
+	{0x03, 0x04}, {0x04, 0xe2},
+	/* Offset Y */
+	{0x09, 0x00}, {0x0a, 0x00},
+	/* Offset X */
+	{0x0b, 0x00}, {0x0c, 0x00},
+	/* Windows Height */
+	{0x0d, 0x04}, {0x0e, 0xc0},
+	/* Windows Width */
+	{0x0f, 0x06}, {0x10, 0x52},
+	/* SH Delay */
+	{0x12, 0x2e},
+	/* Flip */
+	{0x17, 0x14},
+	/* Analog Mode 2 (row skip ??) */
+	{0x18, 0x22}, {0x19, 0x0e}, {0x1a, 0x01}, {0x1b, 0x4b},
+	{0x1c, 0x07}, {0x1d, 0x10}, {0x1e, 0x88}, {0x1f, 0x78},
+	{0x20, 0x03}, {0x21, 0x40}, {0x22, 0xa0}, {0x24, 0x16},
+	{0x25, 0x01}, {0x26, 0x10}, {0x2d, 0x60}, {0x30, 0x01},
+	{0x31, 0x90}, {0x33, 0x06}, {0x34, 0x01},
+	{0xfe, 0x00},
+	{0x80, 0x7f}, {0x81, 0x26}, {0x82, 0xfa}, {0x83, 0x00},
+	{0x84, 0x02}, {0x86, 0x02}, {0x88, 0x03}, {0x89, 0x03},
+	{0x85, 0x08}, {0x8a, 0x00}, {0x8b, 0x00}, {0xb0, 0x55},
+	{0xc3, 0x00}, {0xc4, 0x80}, {0xc5, 0x90}, {0xc6, 0x3b},
+	{0xc7, 0x46}, {0xec, 0x06}, {0xed, 0x04}, {0xee, 0x60},
+	{0xef, 0x90}, {0xb6, 0x01},
+	/* Crop */
+	{0x90, 0x01},
+	{0x91, 0x00}, {0x92, 0x00},
+	{0x93, 0x00}, {0x94, 0x00},
+	{0x95, 0x04}, {0x96, 0xb0},
+	{0x97, 0x06}, {0x98, 0x40},
+	/* BLK */
+	{0xfe, 0x00},
+	{0x40, 0x42}, {0x41, 0x00}, {0x43, 0x5b}, {0x5e, 0x00},
+	{0x5f, 0x00}, {0x60, 0x00}, {0x61, 0x00}, {0x62, 0x00},
+	{0x63, 0x00}, {0x64, 0x00}, {0x65, 0x00}, {0x66, 0x20},
+	{0x67, 0x20}, {0x68, 0x20}, {0x69, 0x20}, {0x76, 0x00},
+	{0x6a, 0x08}, {0x6b, 0x08}, {0x6c, 0x08}, {0x6d, 0x08},
+	{0x6e, 0x08}, {0x6f, 0x08}, {0x70, 0x08}, {0x71, 0x08},
+	{0x76, 0x00}, {0x72, 0xf0}, {0x7e, 0x3c}, {0x7f, 0x00},
+	{0xfe, 0x02},
+	{0x48, 0x15}, {0x49, 0x00}, {0x4b, 0x0b},
+	{0xfe, 0x00},
+	/* AEC */
+	{0xfe, 0x01},
+	{0x01, 0x04}, {0x02, 0xc0}, {0x03, 0x04}, {0x04, 0x90},
+	{0x05, 0x30}, {0x06, 0x90}, {0x07, 0x30}, {0x08, 0x80},
+	{0x09, 0x00}, {0x0a, 0x82}, {0x0b, 0x11}, {0x0c, 0x10},
+	{0x11, 0x10}, {0x13, 0x7b}, {0x17, 0x00}, {0x1c, 0x11},
+	{0x1e, 0x61}, {0x1f, 0x35}, {0x20, 0x40}, {0x22, 0x40},
+	{0x23, 0x20},
+	{0xfe, 0x02},
+	{0x0f, 0x04},
+	{0xfe, 0x01},
+	{0x12, 0x35}, {0x15, 0xb0}, {0x10, 0x31}, {0x3e, 0x28},
+	{0x3f, 0xb0}, {0x40, 0x90}, {0x41, 0x0f},
+	/* INTPEE */
+	{0xfe, 0x02},
+	{0x90, 0x6c}, {0x91, 0x03}, {0x92, 0xcb}, {0x94, 0x33},
+	{0x95, 0x84}, {0x97, 0x65}, {0xa2, 0x11},
+	{0xfe, 0x00},
+	/* DNDD */
+	{0xfe, 0x02},
+	{0x80, 0xc1}, {0x81, 0x08}, {0x82, 0x05}, {0x83, 0x08},
+	{0x84, 0x0a}, {0x86, 0xf0}, {0x87, 0x50}, {0x88, 0x15},
+	{0x89, 0xb0}, {0x8a, 0x30}, {0x8b, 0x10},
+	/* ASDE */
+	{0xfe, 0x01},
+	{0x21, 0x04},
+	{0xfe, 0x02},
+	{0xa3, 0x50}, {0xa4, 0x20}, {0xa5, 0x40}, {0xa6, 0x80},
+	{0xab, 0x40}, {0xae, 0x0c}, {0xb3, 0x46}, {0xb4, 0x64},
+	{0xb6, 0x38}, {0xb7, 0x01}, {0xb9, 0x2b}, {0x3c, 0x04},
+	{0x3d, 0x15}, {0x4b, 0x06}, {0x4c, 0x20},
+	{0xfe, 0x00},
+	/* Gamma */
+	{0xfe, 0x02},
+	{0x10, 0x09}, {0x11, 0x0d}, {0x12, 0x13}, {0x13, 0x19},
+	{0x14, 0x27}, {0x15, 0x37}, {0x16, 0x45}, {0x17, 0x53},
+	{0x18, 0x69}, {0x19, 0x7d}, {0x1a, 0x8f}, {0x1b, 0x9d},
+	{0x1c, 0xa9}, {0x1d, 0xbd}, {0x1e, 0xcd}, {0x1f, 0xd9},
+	{0x20, 0xe3}, {0x21, 0xea}, {0x22, 0xef}, {0x23, 0xf5},
+	{0x24, 0xf9}, {0x25, 0xff},
+	{0xfe, 0x00},
+	{0xc6, 0x20}, {0xc7, 0x2b},
+	/* Gamma 2 */
+	{0xfe, 0x02},
+	{0x26, 0x0f}, {0x27, 0x14}, {0x28, 0x19}, {0x29, 0x1e},
+	{0x2a, 0x27}, {0x2b, 0x33}, {0x2c, 0x3b}, {0x2d, 0x45},
+	{0x2e, 0x59}, {0x2f, 0x69}, {0x30, 0x7c}, {0x31, 0x89},
+	{0x32, 0x98}, {0x33, 0xae}, {0x34, 0xc0}, {0x35, 0xcf},
+	{0x36, 0xda}, {0x37, 0xe2}, {0x38, 0xe9}, {0x39, 0xf3},
+	{0x3a, 0xf9}, {0x3b, 0xff},
+	/* YCP */
+	{0xfe, 0x02},
+	{0xd1, 0x32}, {0xd2, 0x32}, {0xd3, 0x40}, {0xd6, 0xf0},
+	{0xd7, 0x10}, {0xd8, 0xda}, {0xdd, 0x14}, {0xde, 0x86},
+	{0xed, 0x80}, {0xee, 0x00}, {0xef, 0x3f}, {0xd8, 0xd8},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	/* LSC */
+	{0xfe, 0x01},
+	{0xc2, 0x14}, {0xc3, 0x0d}, {0xc4, 0x0c}, {0xc8, 0x15},
+	{0xc9, 0x0d}, {0xca, 0x0a}, {0xbc, 0x24}, {0xbd, 0x10},
+	{0xbe, 0x0b}, {0xb6, 0x25}, {0xb7, 0x16}, {0xb8, 0x15},
+	{0xc5, 0x00}, {0xc6, 0x00}, {0xc7, 0x00}, {0xcb, 0x00},
+	{0xcc, 0x00}, {0xcd, 0x00}, {0xbf, 0x07}, {0xc0, 0x00},
+	{0xc1, 0x00}, {0xb9, 0x00}, {0xba, 0x00}, {0xbb, 0x00},
+	{0xaa, 0x01}, {0xab, 0x01}, {0xac, 0x00}, {0xad, 0x05},
+	{0xae, 0x06}, {0xaf, 0x0e}, {0xb0, 0x0b}, {0xb1, 0x07},
+	{0xb2, 0x06}, {0xb3, 0x17}, {0xb4, 0x0e}, {0xb5, 0x0e},
+	{0xd0, 0x09}, {0xd1, 0x00}, {0xd2, 0x00}, {0xd6, 0x08},
+	{0xd7, 0x00}, {0xd8, 0x00}, {0xd9, 0x00}, {0xda, 0x00},
+	{0xdb, 0x00}, {0xd3, 0x0a}, {0xd4, 0x00}, {0xd5, 0x00},
+	{0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x77}, {0xa7, 0x77},
+	{0xa8, 0x77}, {0xa9, 0x77}, {0xa1, 0x80}, {0xa2, 0x80},
+	{0xfe, 0x01},
+	{0xdf, 0x0d}, {0xdc, 0x25}, {0xdd, 0x30}, {0xe0, 0x77},
+	{0xe1, 0x80}, {0xe2, 0x77}, {0xe3, 0x90}, {0xe6, 0x90},
+	{0xe7, 0xa0}, {0xe8, 0x90}, {0xe9, 0xa0},
+	{0xfe, 0x00},
+	/* AWB */
+	{0xfe, 0x01},
+	{0x4f, 0x00}, {0x4f, 0x00}, {0x4b, 0x01}, {0x4f, 0x00},
+	{0x4c, 0x01}, {0x4d, 0x71}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x91}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x70}, {0x4e, 0x01},
+	{0x4c, 0x01}, {0x4d, 0x90}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xb0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x8f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6f}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xaf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xd0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xf0}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xcf}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0xef}, {0x4e, 0x02},
+	{0x4c, 0x01}, {0x4d, 0x6e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8e}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xae}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xce}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8d}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xad}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcd}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8c}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xac}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcc}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xcb}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x4b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x6b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8b}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0xab}, {0x4e, 0x03},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xaa}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xca}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xc9}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x8a}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0x89}, {0x4e, 0x04},
+	{0x4c, 0x01}, {0x4d, 0xa9}, {0x4e, 0x04},
+	{0x4c, 0x02}, {0x4d, 0x0b}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x0a}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xeb}, {0x4e, 0x05},
+	{0x4c, 0x01}, {0x4d, 0xea}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x09}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x29}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x2a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x4a}, {0x4e, 0x05},
+	{0x4c, 0x02}, {0x4d, 0x8a}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x49}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x89}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xa9}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x48}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x68}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0x69}, {0x4e, 0x06},
+	{0x4c, 0x02}, {0x4d, 0xca}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc9}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe9}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x09}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe8}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xa7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xc7}, {0x4e, 0x07},
+	{0x4c, 0x02}, {0x4d, 0xe7}, {0x4e, 0x07},
+	{0x4c, 0x03}, {0x4d, 0x07}, {0x4e, 0x07},
+	{0x4f, 0x01},
+	{0x50, 0x80}, {0x51, 0xa8}, {0x52, 0x47}, {0x53, 0x38},
+	{0x54, 0xc7}, {0x56, 0x0e}, {0x58, 0x08}, {0x5b, 0x00},
+	{0x5c, 0x74}, {0x5d, 0x8b}, {0x61, 0xdb}, {0x62, 0xb8},
+	{0x63, 0x86}, {0x64, 0xc0}, {0x65, 0x04}, {0x67, 0xa8},
+	{0x68, 0xb0}, {0x69, 0x00}, {0x6a, 0xa8}, {0x6b, 0xb0},
+	{0x6c, 0xaf}, {0x6d, 0x8b}, {0x6e, 0x50}, {0x6f, 0x18},
+	{0x73, 0xf0}, {0x70, 0x0d}, {0x71, 0x60}, {0x72, 0x80},
+	{0x74, 0x01}, {0x75, 0x01}, {0x7f, 0x0c}, {0x76, 0x70},
+	{0x77, 0x58}, {0x78, 0xa0}, {0x79, 0x5e}, {0x7a, 0x54},
+	{0x7b, 0x58},
+	{0xfe, 0x00},
+	/* CC */
+	{0xfe, 0x02},
+	{0xc0, 0x01}, {0xc1, 0x44}, {0xc2, 0xfd}, {0xc3, 0x04},
+	{0xc4, 0xf0}, {0xc5, 0x48}, {0xc6, 0xfd}, {0xc7, 0x46},
+	{0xc8, 0xfd}, {0xc9, 0x02}, {0xca, 0xe0}, {0xcb, 0x45},
+	{0xcc, 0xec}, {0xcd, 0x48}, {0xce, 0xf0}, {0xcf, 0xf0},
+	{0xe3, 0x0c}, {0xe4, 0x4b}, {0xe5, 0xe0},
+	/* ABS */
+	{0xfe, 0x01},
+	{0x9f, 0x40},
+	{0xfe, 0x00},
+	/* Dark sun */
+	{0xfe, 0x02},
+	{0x40, 0xbf}, {0x46, 0xcf},
+	{0xfe, 0x00},
+	/* Framerate 50Hz */
+	{0xfe, 0x00},
+	{0x05, 0x01}, {0x06, 0x56}, {0x07, 0x00}, {0x08, 0x10},
+	{0xfe, 0x01},
+	{0x25, 0x00}, {0x26, 0xfa}, {0x27, 0x04}, {0x28, 0xe2},
+	{0x29, 0x04}, {0x2a, 0xe2}, {0x2b, 0x04}, {0x2c, 0xe2},
+	{0x2d, 0x04}, {0x2e, 0xe2},
+	{0xfe, 0x00},
+	/* Output */
+	{0xfe, 0x00},
+	{0xf2, 0x00},
+	/* Mipi */
+	{0xfe, 0x03},
+	{0x01, 0x87}, {0x02, 0x22}, {0x03, 0x10},
+	{0x06, 0x88}, {0x10, 0x95}, {0x11, 0x1e},
+	{0x15, 0x10}, {0x22, 0x04},
+	{0x23, 0x10}, {0x24, 0x10}, {0x25, 0x10}, {0x26, 0x05},
+	{0x21, 0x10}, {0x29, 0x03}, {0x2a, 0x0a}, {0x2b, 0x06},
+	{0xfe, 0x00},
+};
+
+/* Regulators supplies */
+static const char * const gc2145_supply_name[] = {
+	"IOVDD", /* Digital I/O (1.7-3V) suppply */
+	"AVDD",  /* Analog (2.7-3V) supply */
+	"DVDD",  /* Digital Core (1.7-1.9V) supply */
+};
+
+#define GC2145_NUM_SUPPLIES ARRAY_SIZE(gc2145_supply_name)
+
+/* Mode configs */
+#define GC2145_MODE_640X480	0
+#define GC2145_MODE_1280X720	1
+#define GC2145_MODE_1600X1200	2
+static const struct gc2145_mode supported_modes[] = {
+	{
+		/* 640x480 30fps mode */
+		.width = 640,
+		.height = 480,
+		.frame_interval = {
+			.numerator = 1,
+			.denominator = 30,
+		},
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_640_480_regs),
+			.regs = mode_640_480_regs,
+		},
+		.pixel_rate = GC2145_640_480_PIXELRATE,
+	},
+	{
+		/* 1280x720 30fps mode */
+		.width = 1280,
+		.height = 720,
+		.frame_interval = {
+			.numerator = 1,
+			.denominator = 30,
+		},
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1280_720_regs),
+			.regs = mode_1280_720_regs,
+		},
+		.pixel_rate = GC2145_1280_720_PIXELRATE,
+	},
+	{
+		/* 1600x1200 20fps mode */
+		.width = 1600,
+		.height = 1200,
+		.frame_interval = {
+			.numerator = 1,
+			.denominator = 20,
+		},
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1600_1200_regs),
+			.regs = mode_1600_1200_regs,
+		},
+		.pixel_rate = GC2145_1600_1200_PIXELRATE,
+	},
+};
+
+/**
+ * struct gc2145_format - GC2145 pixel format description
+ * @code: media bus (MBUS) associated code
+ * @colorspace: V4L2 colospace
+ * @datatype: MIPI CSI2 data type
+ * @output_fmt: GC2145 output format
+ * @row_col_switch: control of GC2145 row/col switch feature
+ */
+struct gc2145_format {
+	unsigned int code;
+	unsigned int colorspace;
+	unsigned char datatype;
+	unsigned char output_fmt;
+	unsigned char row_col_switch;
+};
+
+/* All supported formats */
+#define GC2145_DEFAULT_MBUS_FORMAT	MEDIA_BUS_FMT_YUYV8_2X8
+static const struct gc2145_format supported_formats[] = {
+	{
+		.code		= MEDIA_BUS_FMT_UYVY8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x00,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_VYUY8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x01,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_YUYV8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x02,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_YVYU8_2X8,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_YUV422_8B,
+		.output_fmt	= 0x03,
+	},
+	{
+		.code		= MEDIA_BUS_FMT_RGB565_2X8_BE,
+		.colorspace	= V4L2_COLORSPACE_SRGB,
+		.datatype	= MIPI_CSI2_DT_RGB565,
+		.output_fmt	= 0x06,
+	},
+	{
+		.code           = MEDIA_BUS_FMT_SGRBG8_1X8,
+		.colorspace     = V4L2_COLORSPACE_RAW,
+		.datatype       = MIPI_CSI2_DT_RAW8,
+		.output_fmt     = 0x17,
+		.row_col_switch = GC2145_SYNC_MODE_COL_SWITCH,
+	},
+	{
+		.code           = MEDIA_BUS_FMT_SRGGB8_1X8,
+		.colorspace     = V4L2_COLORSPACE_RAW,
+		.datatype       = MIPI_CSI2_DT_RAW8,
+		.output_fmt     = 0x17,
+		.row_col_switch = GC2145_SYNC_MODE_COL_SWITCH | GC2145_SYNC_MODE_ROW_SWITCH,
+	},
+	{
+		.code           = MEDIA_BUS_FMT_SBGGR8_1X8,
+		.colorspace     = V4L2_COLORSPACE_RAW,
+		.datatype       = MIPI_CSI2_DT_RAW8,
+		.output_fmt     = 0x17,
+		.row_col_switch = 0,
+	},
+	{
+		.code           = MEDIA_BUS_FMT_SGBRG8_1X8,
+		.colorspace     = V4L2_COLORSPACE_RAW,
+		.datatype       = MIPI_CSI2_DT_RAW8,
+		.output_fmt     = 0x17,
+		.row_col_switch = GC2145_SYNC_MODE_ROW_SWITCH,
+	},
+};
+
+struct gc2145_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct gc2145 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+
+	struct v4l2_mbus_framefmt fmt;
+
+	struct clk *xclk;
+
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *powerdown_gpio;
+	struct regulator_bulk_data supplies[GC2145_NUM_SUPPLIES];
+
+	/* V4L2 controls */
+	struct gc2145_ctrls ctrls;
+
+	/* Current mode */
+	const struct gc2145_mode *mode;
+
+	/*
+	 * Mutex for serialized access:
+	 * Protect sensor module set pad format and start/stop streaming safely.
+	 */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	bool streaming;
+};
+
+static inline struct gc2145 *to_gc2145(struct v4l2_subdev *_sd)
+{
+	return container_of(_sd, struct gc2145, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct gc2145,
+			     ctrls.handler)->sd;
+}
+
+static int gc2145_read_reg(struct gc2145 *gc2145, u8 addr, u8 *data, int data_size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = &addr;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = data;
+	msg[1].len = data_size;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error %d: start_index=%x, data_size=%d\n",
+			__func__, ret, (u32)addr, data_size);
+		return ret;
+	}
+
+	dev_dbg(&client->dev, "[rd %02x] => %*ph\n", (u32)addr, data_size, data);
+
+	return 0;
+}
+
+static int gc2145_write_reg(struct gc2145 *gc2145, u8 addr, u8 data)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	struct i2c_msg msg;
+	u8 buf[] = { addr, data };
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	dev_dbg(&client->dev, "[wr %02x] <= %02xh\n", (u32)addr, data);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error %d: addr=%x, data=%02xh\n",
+			__func__, ret, (u32)addr, data);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int gc2145_mod_reg(struct gc2145 *gc2145, u16 reg, u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = gc2145_read_reg(gc2145, reg, &readval, 1);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return gc2145_write_reg(gc2145, reg, val);
+}
+
+/* Write a list of registers */
+static int gc2145_write_regs(struct gc2145 *gc2145, const struct gc2145_reg *regs, u32 len)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < len; i++) {
+		ret = gc2145_write_reg(gc2145, regs[i].address, regs[i].val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct gc2145_format *gc2145_get_format_code(struct gc2145 *gc2145, u32 code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_formats); i++)
+		if (supported_formats[i].code == code)
+			break;
+
+	if (i >= ARRAY_SIZE(supported_formats))
+		i = 0;
+
+	return &supported_formats[i];
+}
+
+static void gc2145_set_default_format(struct gc2145 *gc2145)
+{
+	struct v4l2_mbus_framefmt *fmt = &gc2145->fmt;
+
+	fmt->code = supported_formats[0].code;
+	fmt->colorspace = supported_formats[0].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, fmt->colorspace, fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = supported_modes[GC2145_MODE_640X480].width;
+	fmt->height = supported_modes[GC2145_MODE_640X480].height;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int gc2145_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	struct v4l2_mbus_framefmt *try_fmt = v4l2_subdev_get_try_format(sd, fh->state, 0);
+
+	mutex_lock(&gc2145->mutex);
+
+	/* Initialize try_fmt */
+	try_fmt->width = supported_modes[GC2145_MODE_640X480].width;
+	try_fmt->height = supported_modes[GC2145_MODE_640X480].height;
+	try_fmt->code = GC2145_DEFAULT_MBUS_FORMAT;
+	try_fmt->field = V4L2_FIELD_NONE;
+
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	if (code->index >= ARRAY_SIZE(supported_formats))
+		return -EINVAL;
+
+	mutex_lock(&gc2145->mutex);
+	code->code = supported_formats[code->index].code;
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	const struct gc2145_format *gc2145_format;
+	u32 code;
+
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	mutex_lock(&gc2145->mutex);
+
+	gc2145_format = gc2145_get_format_code(gc2145, fse->code);
+	code = gc2145_format->code;
+
+	mutex_unlock(&gc2145->mutex);
+	if (fse->code != code)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int gc2145_enum_frame_interval(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	const struct gc2145_format *gc2145_format;
+	u32 code, i;
+
+	/* The driver currently only support a unique framerate per resolution */
+	if (fie->index > 0)
+		return -EINVAL;
+
+	gc2145_format = gc2145_get_format_code(gc2145, fie->code);
+	code = gc2145_format->code;
+	if (fie->code != code)
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(supported_modes); i++)
+		if (supported_modes[i].width == fie->width &&
+		    supported_modes[i].height == fie->height)
+			break;
+
+	if (i >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	fie->interval.numerator = supported_modes[i].frame_interval.numerator;
+	fie->interval.denominator = supported_modes[i].frame_interval.denominator;
+
+	return 0;
+}
+
+static void gc2145_reset_colorspace(struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true, fmt->colorspace,
+							  fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+}
+
+static void gc2145_update_pad_format(struct gc2145 *gc2145, const struct gc2145_mode *mode,
+				     struct v4l2_subdev_format *fmt)
+{
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+	gc2145_reset_colorspace(&fmt->format);
+}
+
+static int __gc2145_get_pad_format(struct gc2145 *gc2145, struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_format *fmt)
+{
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		struct v4l2_mbus_framefmt *try_fmt =
+			v4l2_subdev_get_try_format(&gc2145->sd, sd_state, fmt->pad);
+		fmt->format = *try_fmt;
+	} else {
+		gc2145_update_pad_format(gc2145, gc2145->mode, fmt);
+		fmt->format.code = gc2145->fmt.code;
+	}
+
+	return 0;
+}
+
+static int gc2145_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	mutex_lock(&gc2145->mutex);
+	ret = __gc2145_get_pad_format(gc2145, sd_state, fmt);
+	mutex_unlock(&gc2145->mutex);
+
+	return ret;
+}
+
+static int gc2145_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	const struct gc2145_mode *mode;
+	const struct gc2145_format *gc2145_fmt;
+	struct v4l2_mbus_framefmt *framefmt;
+	struct gc2145_ctrls *ctrls = &gc2145->ctrls;
+
+	mutex_lock(&gc2145->mutex);
+
+	gc2145_fmt = gc2145_get_format_code(gc2145, fmt->format.code);
+	fmt->format.code = gc2145_fmt->code;
+
+	mode = v4l2_find_nearest_size(supported_modes, ARRAY_SIZE(supported_modes), width, height,
+				      fmt->format.width, fmt->format.height);
+
+	/* In RAW mode, VGA is not possible so use 720p instead */
+	if ((gc2145_fmt->colorspace == V4L2_COLORSPACE_RAW) &&
+	    (mode == &supported_modes[GC2145_MODE_640X480]))
+		mode = &supported_modes[GC2145_MODE_1280X720];
+
+	gc2145_update_pad_format(gc2145, mode, fmt);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
+		*framefmt = fmt->format;
+	} else if (gc2145->mode != mode || gc2145->fmt.code != fmt->format.code) {
+		gc2145->fmt = fmt->format;
+		gc2145->mode = mode;
+		/* Update pixel_rate based on the mode */
+		__v4l2_ctrl_s_ctrl_int64(ctrls->pixel_rate, mode->pixel_rate);
+	}
+
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_start_streaming(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	const struct gc2145_reg_list *reg_list;
+	const struct gc2145_format *gc2145_format;
+	uint16_t lwc, fifo_full_lvl, fifo_gate_mode;
+	u8 sync_mode;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(&client->dev);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * TODO - configuration of the sensor will have to be moved into
+	 * gc2145_set_pad_format once we have a way to configure without
+	 * starting the sensor.  In such case, only streaming start will
+	 * be done here.
+	 */
+
+	/* Apply default values of current mode */
+	reg_list = &gc2145->mode->reg_list;
+	ret = gc2145_write_regs(gc2145, reg_list->regs, reg_list->num_of_regs);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set mode\n", __func__);
+		goto err_rpm_put;
+	}
+
+	gc2145_format = gc2145_get_format_code(gc2145, gc2145->fmt.code);
+
+	/* Set the output format */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_PAGE_SELECT, 0x00);
+	if (ret)
+		return ret;
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_OUTPUT_FMT, gc2145_format->output_fmt);
+	if (ret)
+		return ret;
+
+	ret = gc2145_read_reg(gc2145, GC2145_REG_SYNC_MODE, &sync_mode, 1);
+	if (ret)
+		return ret;
+
+	sync_mode &= ~(GC2145_SYNC_MODE_COL_SWITCH | GC2145_SYNC_MODE_ROW_SWITCH);
+	sync_mode |= gc2145_format->row_col_switch;
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_SYNC_MODE, sync_mode);
+	if (ret)
+		return ret;
+
+	/* Set 3rd page access */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_PAGE_SELECT, 0x03);
+	if (ret)
+		return ret;
+
+	/*
+	 * Adjust the MIPI buffer settings.
+	 * For YUV/RGB, LWC = image width * 2
+	 * For RAW8, LWC = image width
+	 * For RAW10, LWC = image width * 1.25
+	 */
+	if (gc2145_format->colorspace != V4L2_COLORSPACE_RAW)
+		lwc = gc2145->mode->width * 2;
+	else if (gc2145_format->code == MEDIA_BUS_FMT_SGRBG8_1X8 ||
+		 gc2145_format->code == MEDIA_BUS_FMT_SRGGB8_1X8 ||
+		 gc2145_format->code == MEDIA_BUS_FMT_SBGGR8_1X8 ||
+		 gc2145_format->code == MEDIA_BUS_FMT_SGBRG8_1X8)
+		lwc = gc2145->mode->width * 1;
+	else
+		lwc = gc2145->mode->width + (gc2145->mode->width / 4);
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_LWC_HIGH, lwc >> 8);
+	if (ret)
+		return ret;
+	ret = gc2145_write_reg(gc2145, GC2145_REG_LWC_LOW, (lwc & 0xff));
+	if (ret)
+		return ret;
+
+	/*
+	 * Adjust the MIPI Fifo Full Level
+	 * 640x480 RGB: 0x0190
+	 * 1280x720 / 1600x1200 (aka no scaler) non RAW: 0x0001
+	 * 1600x1200 RAW: 0x0190
+	 */
+	if (gc2145_format->colorspace != V4L2_COLORSPACE_RAW) {
+		if (gc2145->mode->width == 1280 || gc2145->mode->width == 1600)
+			fifo_full_lvl = 0x0001;
+		else
+			fifo_full_lvl = 0x0190;
+	} else
+		fifo_full_lvl = 0x0190;
+
+	ret = gc2145_write_reg(gc2145, GC2145_REG_FIFO_FULL_LVL_HIGH,
+			       fifo_full_lvl >> 8);
+	if (ret)
+		return ret;
+	ret = gc2145_write_reg(gc2145, GC2145_REG_FIFO_FULL_LVL_LOW,
+			       fifo_full_lvl & 0xff);
+	if (ret)
+		return ret;
+
+	/* Set the fifo gate mode / MIPI wdiv set */
+	if (gc2145_format->colorspace == V4L2_COLORSPACE_RAW)
+		fifo_gate_mode = 0xf1;
+	else
+		fifo_gate_mode = 0xf0;
+	ret = gc2145_write_reg(gc2145, GC2145_REG_FIFO_GATE_MODE,
+			       fifo_gate_mode);
+	if (ret)
+		return ret;
+
+	/* Set the MIPI data type */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_MIPI_DT, gc2145_format->datatype);
+	if (ret)
+		return ret;
+
+	/* Come back on page 0 by default */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_PAGE_SELECT, 0x00);
+	if (ret)
+		return ret;
+
+	/* Apply customized values from user */
+	ret =  __v4l2_ctrl_handler_setup(&gc2145->ctrls.handler);
+	if (ret)
+		goto err_rpm_put;
+
+	return 0;
+
+err_rpm_put:
+	pm_runtime_put(&client->dev);
+	return ret;
+}
+
+static void gc2145_stop_streaming(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+
+	/*
+	 * TODO - once we have a way to turn off only streaming of the
+	 * sensor, we will have to do it here.
+	 */
+
+	pm_runtime_put(&client->dev);
+}
+
+static int gc2145_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	mutex_lock(&gc2145->mutex);
+	fi->interval = gc2145->mode->frame_interval;
+	mutex_unlock(&gc2145->mutex);
+
+	return 0;
+}
+
+static int gc2145_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret = 0;
+
+	mutex_lock(&gc2145->mutex);
+	if (gc2145->streaming == enable) {
+		mutex_unlock(&gc2145->mutex);
+		return 0;
+	}
+
+	if (enable) {
+		/*
+		 * Apply default & customized values
+		 * and then start streaming.
+		 */
+		ret = gc2145_start_streaming(gc2145);
+		if (ret)
+			goto err_unlock;
+	} else {
+		gc2145_stop_streaming(gc2145);
+	}
+
+	gc2145->streaming = enable;
+
+	mutex_unlock(&gc2145->mutex);
+
+	return ret;
+
+err_unlock:
+	mutex_unlock(&gc2145->mutex);
+
+	return ret;
+}
+
+/* Power/clock management functions */
+static int gc2145_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	ret = regulator_bulk_enable(GC2145_NUM_SUPPLIES, gc2145->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable regulators\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(gc2145->xclk);
+	if (ret) {
+		dev_err(dev, "failed to enable clock\n");
+		goto reg_off;
+	}
+
+	/* TODO - Following delays should be tuned */
+	usleep_range(10000, 12000);
+	gpiod_set_value_cansleep(gc2145->powerdown_gpio, 0);
+	usleep_range(10000, 12000);
+	gpiod_set_value_cansleep(gc2145->reset_gpio, 0);
+	usleep_range(40000, 50000);
+
+	return 0;
+
+reg_off:
+	regulator_bulk_disable(GC2145_NUM_SUPPLIES, gc2145->supplies);
+
+	return ret;
+}
+
+static int gc2145_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	gpiod_set_value_cansleep(gc2145->powerdown_gpio, 1);
+	gpiod_set_value_cansleep(gc2145->reset_gpio, 1);
+	regulator_bulk_disable(GC2145_NUM_SUPPLIES, gc2145->supplies);
+	clk_disable_unprepare(gc2145->xclk);
+
+	return 0;
+}
+
+static int __maybe_unused gc2145_suspend(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	if (gc2145->streaming)
+		gc2145_stop_streaming(gc2145);
+
+	return 0;
+}
+
+static int __maybe_unused gc2145_resume(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	if (gc2145->streaming) {
+		ret = gc2145_start_streaming(gc2145);
+		if (ret)
+			goto error;
+	}
+
+	return 0;
+
+error:
+	gc2145_stop_streaming(gc2145);
+	gc2145->streaming = false;
+
+	return ret;
+}
+
+static int gc2145_get_regulators(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	unsigned int i;
+
+	for (i = 0; i < GC2145_NUM_SUPPLIES; i++)
+		gc2145->supplies[i].supply = gc2145_supply_name[i];
+
+	return devm_regulator_bulk_get(&client->dev, GC2145_NUM_SUPPLIES, gc2145->supplies);
+}
+
+/* Verify chip ID */
+static int gc2145_identify_module(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	int ret;
+	u16 chip_id;
+
+	ret = gc2145_read_reg(gc2145, GC2145_REG_CHIP_ID, (u8 *)&chip_id, 2);
+	if (ret) {
+		dev_err(&client->dev, "failed to read chip id %x\n", GC2145_CHIP_ID);
+		return ret;
+	}
+	chip_id = be16_to_cpu(chip_id);
+
+	if (chip_id != GC2145_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x\n", GC2145_CHIP_ID, chip_id);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Colored patterns",
+	"Uniform white",
+	"Uniform yellow",
+	"Uniform cyan",
+	"Uniform green",
+	"Uniform magenta",
+	"Uniform red",
+	"Uniform black",
+};
+
+#define GC2145_TEST_PATTERN_ENABLE	BIT(0)
+#define GC2145_TEST_PATTERN_UXGA	BIT(3)
+
+#define GC2145_TEST_UNIFORM		BIT(3)
+#define GC2145_TEST_WHITE		(4 << 4)
+#define GC2145_TEST_YELLOW		(8 << 4)
+#define GC2145_TEST_CYAN		(9 << 4)
+#define GC2145_TEST_GREEN		(6 << 4)
+#define GC2145_TEST_MAGENTA		(10 << 4)
+#define GC2145_TEST_RED			(5 << 4)
+#define GC2145_TEST_BLACK		(0)
+
+static const u8 test_pattern_val[] = {
+	0,
+	GC2145_TEST_PATTERN_ENABLE,
+	GC2145_TEST_UNIFORM | GC2145_TEST_WHITE,
+	GC2145_TEST_UNIFORM | GC2145_TEST_YELLOW,
+	GC2145_TEST_UNIFORM | GC2145_TEST_CYAN,
+	GC2145_TEST_UNIFORM | GC2145_TEST_GREEN,
+	GC2145_TEST_UNIFORM | GC2145_TEST_MAGENTA,
+	GC2145_TEST_UNIFORM | GC2145_TEST_RED,
+	GC2145_TEST_UNIFORM | GC2145_TEST_BLACK,
+};
+
+static const struct v4l2_subdev_core_ops gc2145_core_ops = {
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops gc2145_video_ops = {
+	.g_frame_interval = gc2145_g_frame_interval,
+	/*
+	 * Currently frame_interval can't be changed hence s_frame_interval
+	 * does same as g_frame_interval
+	 */
+	.s_frame_interval = gc2145_g_frame_interval,
+	.s_stream = gc2145_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops gc2145_pad_ops = {
+	.enum_mbus_code = gc2145_enum_mbus_code,
+	.get_fmt = gc2145_get_pad_format,
+	.set_fmt = gc2145_set_pad_format,
+	.enum_frame_size = gc2145_enum_frame_size,
+	.enum_frame_interval = gc2145_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops gc2145_subdev_ops = {
+	.core = &gc2145_core_ops,
+	.video = &gc2145_video_ops,
+	.pad = &gc2145_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops gc2145_internal_ops = {
+	.open = gc2145_open,
+};
+
+static int gc2145_set_ctrl_test_pattern(struct gc2145 *gc2145, int value)
+{
+	int ret;
+
+	if (!value) {
+		/* Disable test pattern */
+		ret = gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE2, 0);
+		if (ret)
+			return ret;
+
+		return gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE3, 0);
+	}
+
+	/* Enable test pattern, colored or uniform */
+	ret = gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE2,
+			       GC2145_TEST_PATTERN_ENABLE |
+			       GC2145_TEST_PATTERN_UXGA);
+	if (ret)
+		return ret;
+
+	if (!(test_pattern_val[value] & GC2145_TEST_UNIFORM))
+		return gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE3, 0);
+
+	/* Uniform */
+	return gc2145_write_reg(gc2145, GC2145_REG_DEBUG_MODE3,
+				test_pattern_val[value]);
+}
+
+static int gc2145_set_ctrl_hflip(struct gc2145 *gc2145, int value)
+{
+	return gc2145_mod_reg(gc2145, GC2145_REG_ANALOG_MODE1,
+			      BIT(0), (value ? BIT(0) : 0));
+}
+
+static int gc2145_set_ctrl_vflip(struct gc2145 *gc2145, int value)
+{
+	return gc2145_mod_reg(gc2145, GC2145_REG_ANALOG_MODE1,
+			      BIT(1), (value ? BIT(1) : 0));
+}
+
+static int gc2145_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	ret = pm_runtime_resume_and_get(&client->dev);
+	if (ret < 0)
+		return ret;
+
+	switch (ctrl->id) {
+	case V4L2_CID_TEST_PATTERN:
+		ret = gc2145_set_ctrl_test_pattern(gc2145, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = gc2145_set_ctrl_hflip(gc2145, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = gc2145_set_ctrl_vflip(gc2145, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops gc2145_ctrl_ops = {
+	.s_ctrl = gc2145_s_ctrl,
+};
+
+/* Initialize control handlers */
+static int gc2145_init_controls(struct gc2145 *gc2145)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&gc2145->sd);
+	const struct v4l2_ctrl_ops *ops = &gc2145_ctrl_ops;
+	struct gc2145_ctrls *ctrls = &gc2145->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	ret = v4l2_ctrl_handler_init(hdl, 12);
+	if (ret)
+		return ret;
+
+	hdl->lock = &gc2145->mutex;
+
+	/* By default, PIXEL_RATE is read only */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+					      0, INT_MAX, 1,
+					      GC2145_640_480_PIXELRATE);
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					     ARRAY_SIZE(test_pattern_menu) - 1,
+					     0, 0, test_pattern_menu);
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					 0, 1, 1, 0);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		dev_err(&client->dev, "control init failed (%d)\n", ret);
+		goto error;
+	}
+
+	gc2145->sd.ctrl_handler = hdl;
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(hdl);
+	mutex_destroy(&gc2145->mutex);
+
+	return ret;
+}
+
+static void gc2145_free_controls(struct gc2145 *gc2145)
+{
+	v4l2_ctrl_handler_free(&gc2145->ctrls.handler);
+}
+
+static int gc2145_check_hwcfg(struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint ep_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY
+	};
+	int ret = -EINVAL;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	if (v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep_cfg)) {
+		dev_err(dev, "could not parse endpoint\n");
+		goto error_out;
+	}
+
+	/* Check the number of MIPI CSI2 data lanes */
+	if (ep_cfg.bus.mipi_csi2.num_data_lanes != 2) {
+		dev_err(dev, "only 2 data lanes are currently supported\n");
+		goto error_out;
+	}
+
+	ret = 0;
+
+error_out:
+	v4l2_fwnode_endpoint_free(&ep_cfg);
+	fwnode_handle_put(endpoint);
+
+	return ret;
+}
+
+static int gc2145_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct gc2145 *gc2145;
+	int ret;
+	unsigned int xclk_freq;
+
+	gc2145 = devm_kzalloc(&client->dev, sizeof(*gc2145), GFP_KERNEL);
+	if (!gc2145)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&gc2145->sd, client, &gc2145_subdev_ops);
+
+	/* Check the hardware configuration in device tree */
+	if (gc2145_check_hwcfg(dev))
+		return -EINVAL;
+
+	/* Get system clock (xclk) */
+	gc2145->xclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(gc2145->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(gc2145->xclk);
+	}
+
+	xclk_freq = clk_get_rate(gc2145->xclk);
+	if (xclk_freq != GC2145_XCLK_FREQ) {
+		dev_err(dev, "xclk frequency not supported: %d Hz\n", xclk_freq);
+		return -EINVAL;
+	}
+
+	ret = gc2145_get_regulators(gc2145);
+	if (ret) {
+		dev_err(dev, "failed to get regulators\n");
+		return ret;
+	}
+
+	/* Request optional enable pin */
+	gc2145->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+
+	/* Request optional enable pin */
+	gc2145->powerdown_gpio = devm_gpiod_get_optional(dev, "powerdown", GPIOD_OUT_HIGH);
+
+	/*
+	 * The sensor must be powered for gc2145_identify_module()
+	 * to be able to read the CHIP_ID register
+	 */
+	ret = gc2145_power_on(dev);
+	if (ret)
+		return ret;
+
+	mutex_init(&gc2145->mutex);
+
+	ret = gc2145_identify_module(gc2145);
+	if (ret)
+		goto error_power_off;
+
+	/* Set default mode to max resolution */
+	gc2145->mode = &supported_modes[GC2145_MODE_1600X1200];
+
+	ret = gc2145_init_controls(gc2145);
+	if (ret)
+		goto error_power_off;
+
+	/* Initialize subdev */
+	gc2145->sd.internal_ops = &gc2145_internal_ops;
+	gc2145->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	gc2145->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	/* Initialize source pad */
+	gc2145->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize default format */
+	gc2145_set_default_format(gc2145);
+
+	ret = media_entity_pads_init(&gc2145->sd.entity, 1, &gc2145->pad);
+	if (ret) {
+		dev_err(dev, "failed to init entity pads: %d\n", ret);
+		goto error_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor(&gc2145->sd);
+	if (ret < 0) {
+		dev_err(dev, "failed to register sensor sub-device: %d\n", ret);
+		goto error_media_entity;
+	}
+
+	/* Enable runtime PM and turn off the device */
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+error_media_entity:
+	media_entity_cleanup(&gc2145->sd.entity);
+
+error_handler_free:
+	gc2145_free_controls(gc2145);
+
+error_power_off:
+	gc2145_power_off(dev);
+	mutex_destroy(&gc2145->mutex);
+
+	return ret;
+}
+
+static void gc2145_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2145 *gc2145 = to_gc2145(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	gc2145_free_controls(gc2145);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		gc2145_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	mutex_destroy(&gc2145->mutex);
+
+}
+
+static const struct of_device_id gc2145_dt_ids[] = {
+	{ .compatible = "galaxycore,gc2145" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, gc2145_dt_ids);
+
+static const struct dev_pm_ops gc2145_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(gc2145_suspend, gc2145_resume)
+	SET_RUNTIME_PM_OPS(gc2145_power_off, gc2145_power_on, NULL)
+};
+
+static struct i2c_driver gc2145_i2c_driver = {
+	.driver = {
+		.name = "gc2145",
+		.of_match_table	= gc2145_dt_ids,
+		.pm = &gc2145_pm_ops,
+	},
+	.probe_new = gc2145_probe,
+	.remove = gc2145_remove,
+};
+
+module_i2c_driver(gc2145_i2c_driver);
+
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com");
+MODULE_DESCRIPTION("GalaxyCore GC2145 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/i2c/imx335.c b/drivers/media/i2c/imx335.c
index 8e91767d6..8ffc29850 100644
--- a/drivers/media/i2c/imx335.c
+++ b/drivers/media/i2c/imx335.c
@@ -50,7 +50,6 @@
 
 /* CSI2 HW configuration */
 #define IMX335_LINK_FREQ	594000000
-#define IMX335_NUM_DATA_LANES	4
 
 #define IMX335_REG_MIN		0x00
 #define IMX335_REG_MAX		0xfffff
@@ -86,7 +85,8 @@ struct imx335_reg_list {
  * @vblank_max: Maximum vertical blanking in lines
  * @pclk: Sensor pixel clock
  * @link_freq_idx: Link frequency index
- * @reg_list: Register list for sensor mode
+ * @common_regs: Register list for common settings
+ * @mode_regs: Register list for mode specific settings
  */
 struct imx335_mode {
 	u32 width;
@@ -98,7 +98,8 @@ struct imx335_mode {
 	u32 vblank_max;
 	u64 pclk;
 	u32 link_freq_idx;
-	struct imx335_reg_list reg_list;
+	struct imx335_reg_list common_regs;
+	struct imx335_reg_list mode_regs;
 };
 
 /**
@@ -108,6 +109,7 @@ struct imx335_mode {
  * @sd: V4L2 sub-device
  * @pad: Media pad. Only one pad supported
  * @reset_gpio: Sensor reset gpio
+ * @powerdown_gpio: Sensor powerdown gpio
  * @inclk: Sensor input clock
  * @ctrl_handler: V4L2 control handler
  * @link_freq_ctrl: Pointer to link frequency control
@@ -120,6 +122,7 @@ struct imx335_mode {
  * @cur_mode: Pointer to current selected sensor mode
  * @mutex: Mutex for serializing sensor controls
  * @streaming: Flag indicating streaming state
+ * @nb_lanes: Number of lanes to use
  */
 struct imx335 {
 	struct device *dev;
@@ -127,6 +130,7 @@ struct imx335 {
 	struct v4l2_subdev sd;
 	struct media_pad pad;
 	struct gpio_desc *reset_gpio;
+	struct gpio_desc *powerdown_gpio;
 	struct clk *inclk;
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_ctrl *link_freq_ctrl;
@@ -141,6 +145,7 @@ struct imx335 {
 	const struct imx335_mode *cur_mode;
 	struct mutex mutex;
 	bool streaming;
+	u32 nb_lanes;
 };
 
 static const s64 link_freq[] = {
@@ -235,8 +240,24 @@ static const struct imx335_reg mode_2592x1940_regs[] = {
 	{0x3a00, 0x01},
 };
 
+static const struct imx335_reg mode_10bits_regs[] = {
+	{0x3050, 0x00},
+	{0x319D, 0x00},
+	{0x341c, 0xff},
+	{0x341d, 0x01},
+	{0x3a01, 0x01},
+};
+
+static const struct imx335_reg mode_12bits_regs[] = {
+	{0x3050, 0x01},
+	{0x319D, 0x01},
+	{0x341c, 0x47},
+	{0x341d, 0x00},
+	{0x3a01, 0x03},
+};
+
 /* Supported sensor mode configurations */
-static const struct imx335_mode supported_mode = {
+static const struct imx335_mode supported_mode_4lanes = {
 	.width = 2592,
 	.height = 1940,
 	.hblank = 342,
@@ -246,10 +267,34 @@ static const struct imx335_mode supported_mode = {
 	.pclk = 396000000,
 	.link_freq_idx = 0,
 	.code = MEDIA_BUS_FMT_SRGGB12_1X12,
-	.reg_list = {
+	.common_regs = {
 		.num_of_regs = ARRAY_SIZE(mode_2592x1940_regs),
 		.regs = mode_2592x1940_regs,
 	},
+	.mode_regs = {
+		.num_of_regs = ARRAY_SIZE(mode_12bits_regs),
+		.regs = mode_12bits_regs,
+	},
+};
+
+static const struct imx335_mode supported_mode_2lanes = {
+	.width = 2592,
+	.height = 1940,
+	.hblank = 342,
+	.vblank = 2560,
+	.vblank_min = 2560,
+	.vblank_max = 133060,
+	.pclk = 396000000,
+	.link_freq_idx = 0,
+	.code = MEDIA_BUS_FMT_SRGGB10_1X10,
+	.common_regs = {
+		.num_of_regs = ARRAY_SIZE(mode_2592x1940_regs),
+		.regs = mode_2592x1940_regs,
+	},
+	.mode_regs = {
+		.num_of_regs = ARRAY_SIZE(mode_10bits_regs),
+		.regs = mode_10bits_regs,
+	},
 };
 
 /**
@@ -497,10 +542,12 @@ static int imx335_enum_mbus_code(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
+	struct imx335 *imx335 = to_imx335(sd);
+
 	if (code->index > 0)
 		return -EINVAL;
 
-	code->code = supported_mode.code;
+	code->code = imx335->cur_mode->code;
 
 	return 0;
 }
@@ -517,15 +564,17 @@ static int imx335_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_frame_size_enum *fsize)
 {
+	struct imx335 *imx335 = to_imx335(sd);
+
 	if (fsize->index > 0)
 		return -EINVAL;
 
-	if (fsize->code != supported_mode.code)
+	if (fsize->code != imx335->cur_mode->code)
 		return -EINVAL;
 
-	fsize->min_width = supported_mode.width;
+	fsize->min_width = imx335->cur_mode->width;
 	fsize->max_width = fsize->min_width;
-	fsize->min_height = supported_mode.height;
+	fsize->min_height = imx335->cur_mode->height;
 	fsize->max_height = fsize->min_height;
 
 	return 0;
@@ -600,7 +649,7 @@ static int imx335_set_pad_format(struct v4l2_subdev *sd,
 
 	mutex_lock(&imx335->mutex);
 
-	mode = &supported_mode;
+	mode = imx335->cur_mode;
 	imx335_fill_pad_format(imx335, mode, fmt);
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
@@ -633,7 +682,7 @@ static int imx335_init_pad_cfg(struct v4l2_subdev *sd,
 	struct v4l2_subdev_format fmt = { 0 };
 
 	fmt.which = sd_state ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
-	imx335_fill_pad_format(imx335, &supported_mode, &fmt);
+	imx335_fill_pad_format(imx335, imx335->cur_mode, &fmt);
 
 	return imx335_set_pad_format(sd, sd_state, &fmt);
 }
@@ -650,7 +699,7 @@ static int imx335_start_streaming(struct imx335 *imx335)
 	int ret;
 
 	/* Write sensor mode registers */
-	reg_list = &imx335->cur_mode->reg_list;
+	reg_list = &imx335->cur_mode->common_regs;
 	ret = imx335_write_regs(imx335, reg_list->regs,
 				reg_list->num_of_regs);
 	if (ret) {
@@ -658,6 +707,18 @@ static int imx335_start_streaming(struct imx335 *imx335)
 		return ret;
 	}
 
+	/*
+	 * Perform specific configuration depending on the number
+	 * of lanes used
+	 */
+	reg_list = &imx335->cur_mode->mode_regs;
+	ret = imx335_write_regs(imx335, reg_list->regs,
+				reg_list->num_of_regs);
+	if (ret) {
+		dev_err(imx335->dev, "fail to write mode registers");
+		return ret;
+	}
+
 	/* Setup handler will write actual exposure and gain */
 	ret =  __v4l2_ctrl_handler_setup(imx335->sd.ctrl_handler);
 	if (ret) {
@@ -790,6 +851,15 @@ static int imx335_parse_hw_config(struct imx335 *imx335)
 		return PTR_ERR(imx335->reset_gpio);
 	}
 
+	/* Request optional powerdown pin */
+	imx335->powerdown_gpio = devm_gpiod_get_optional(imx335->dev, "powerdown",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(imx335->powerdown_gpio)) {
+		dev_err(imx335->dev, "failed to get powerdown gpio %ld",
+			PTR_ERR(imx335->powerdown_gpio));
+		return PTR_ERR(imx335->powerdown_gpio);
+	}
+
 	/* Get sensor input clock */
 	imx335->inclk = devm_clk_get(imx335->dev, NULL);
 	if (IS_ERR(imx335->inclk)) {
@@ -812,7 +882,8 @@ static int imx335_parse_hw_config(struct imx335 *imx335)
 	if (ret)
 		return ret;
 
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes != IMX335_NUM_DATA_LANES) {
+	if (bus_cfg.bus.mipi_csi2.num_data_lanes != 2 &&
+	    bus_cfg.bus.mipi_csi2.num_data_lanes != 4) {
 		dev_err(imx335->dev,
 			"number of CSI2 data lanes %d is not supported",
 			bus_cfg.bus.mipi_csi2.num_data_lanes);
@@ -820,6 +891,8 @@ static int imx335_parse_hw_config(struct imx335 *imx335)
 		goto done_endpoint_free;
 	}
 
+	imx335->nb_lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;
+
 	if (!bus_cfg.nr_of_link_frequencies) {
 		dev_err(imx335->dev, "no link frequencies defined");
 		ret = -EINVAL;
@@ -868,6 +941,13 @@ static int imx335_power_on(struct device *dev)
 	struct imx335 *imx335 = to_imx335(sd);
 	int ret;
 
+	gpiod_set_value_cansleep(imx335->reset_gpio, 0);
+	gpiod_set_value_cansleep(imx335->powerdown_gpio, 1);
+	/*
+	 * Spec says that T-low (timing between power on and rise of reset)
+	 * should be at least 500ns - giving it even more time
+	 */
+	usleep_range(5000, 10000);
 	gpiod_set_value_cansleep(imx335->reset_gpio, 1);
 
 	ret = clk_prepare_enable(imx335->inclk);
@@ -876,12 +956,14 @@ static int imx335_power_on(struct device *dev)
 		goto error_reset;
 	}
 
-	usleep_range(20, 22);
+	/* Ensure that all is stable after reset */
+	usleep_range(5000, 10000);
 
 	return 0;
 
 error_reset:
 	gpiod_set_value_cansleep(imx335->reset_gpio, 0);
+	gpiod_set_value_cansleep(imx335->powerdown_gpio, 0);
 
 	return ret;
 }
@@ -898,6 +980,7 @@ static int imx335_power_off(struct device *dev)
 	struct imx335 *imx335 = to_imx335(sd);
 
 	gpiod_set_value_cansleep(imx335->reset_gpio, 0);
+	gpiod_set_value_cansleep(imx335->powerdown_gpio, 0);
 
 	clk_disable_unprepare(imx335->inclk);
 
@@ -1031,7 +1114,10 @@ static int imx335_probe(struct i2c_client *client)
 	}
 
 	/* Set default mode to max resolution */
-	imx335->cur_mode = &supported_mode;
+	if (imx335->nb_lanes == 2)
+		imx335->cur_mode = &supported_mode_2lanes;
+	else
+		imx335->cur_mode = &supported_mode_4lanes;
 	imx335->vblank = imx335->cur_mode->vblank;
 
 	ret = imx335_init_controls(imx335);
diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index e0019668a..311fd9a10 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -15,7 +15,6 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
-#include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
 #include <linux/types.h>
@@ -30,27 +29,13 @@
 #define OV5640_XCLK_MIN  6000000
 #define OV5640_XCLK_MAX 54000000
 
-#define OV5640_NATIVE_WIDTH		2624
-#define OV5640_NATIVE_HEIGHT		1964
-#define OV5640_PIXEL_ARRAY_TOP		14
-#define OV5640_PIXEL_ARRAY_LEFT		16
-#define OV5640_PIXEL_ARRAY_WIDTH	2592
-#define OV5640_PIXEL_ARRAY_HEIGHT	1944
-
-/* FIXME: not documented. */
-#define OV5640_MIN_VBLANK	24
-#define OV5640_MAX_VTS		3375
-
 #define OV5640_DEFAULT_SLAVE_ID 0x3c
 
-#define OV5640_LINK_RATE_MAX		490000000U
-
 #define OV5640_REG_SYS_RESET02		0x3002
 #define OV5640_REG_SYS_CLOCK_ENABLE02	0x3006
 #define OV5640_REG_SYS_CTRL0		0x3008
 #define OV5640_REG_SYS_CTRL0_SW_PWDN	0x42
 #define OV5640_REG_SYS_CTRL0_SW_PWUP	0x02
-#define OV5640_REG_SYS_CTRL0_SW_RST	0x82
 #define OV5640_REG_CHIP_ID		0x300a
 #define OV5640_REG_IO_MIPI_CTRL00	0x300e
 #define OV5640_REG_PAD_OUTPUT_ENABLE01	0x3017
@@ -74,18 +59,13 @@
 #define OV5640_REG_AEC_PK_MANUAL	0x3503
 #define OV5640_REG_AEC_PK_REAL_GAIN	0x350a
 #define OV5640_REG_AEC_PK_VTS		0x350c
-#define OV5640_REG_TIMING_HS		0x3800
-#define OV5640_REG_TIMING_VS		0x3802
-#define OV5640_REG_TIMING_HW		0x3804
-#define OV5640_REG_TIMING_VH		0x3806
 #define OV5640_REG_TIMING_DVPHO		0x3808
 #define OV5640_REG_TIMING_DVPVO		0x380a
 #define OV5640_REG_TIMING_HTS		0x380c
 #define OV5640_REG_TIMING_VTS		0x380e
-#define OV5640_REG_TIMING_HOFFS		0x3810
-#define OV5640_REG_TIMING_VOFFS		0x3812
 #define OV5640_REG_TIMING_TC_REG20	0x3820
 #define OV5640_REG_TIMING_TC_REG21	0x3821
+#define OV5640_REG_DVP_PCLK_DIVIDER	0x3824
 #define OV5640_REG_AEC_CTRL00		0x3a00
 #define OV5640_REG_AEC_B50_STEP		0x3a08
 #define OV5640_REG_AEC_B60_STEP		0x3a0a
@@ -133,54 +113,14 @@ enum ov5640_mode_id {
 	OV5640_NUM_MODES,
 };
 
+#define OV5640_DEFAULT_MODE OV5640_MODE_VGA_640_480
+
 enum ov5640_frame_rate {
 	OV5640_15_FPS = 0,
 	OV5640_30_FPS,
-	OV5640_60_FPS,
 	OV5640_NUM_FRAMERATES,
 };
 
-enum ov5640_pixel_rate_id {
-	OV5640_PIXEL_RATE_168M,
-	OV5640_PIXEL_RATE_148M,
-	OV5640_PIXEL_RATE_124M,
-	OV5640_PIXEL_RATE_96M,
-	OV5640_PIXEL_RATE_48M,
-	OV5640_NUM_PIXEL_RATES,
-};
-
-/*
- * The chip manual suggests 24/48/96/192 MHz pixel clocks.
- *
- * 192MHz exceeds the sysclk limits; use 168MHz as maximum pixel rate for
- * full resolution mode @15 FPS.
- */
-static const u32 ov5640_pixel_rates[] = {
-	[OV5640_PIXEL_RATE_168M] = 168000000,
-	[OV5640_PIXEL_RATE_148M] = 148000000,
-	[OV5640_PIXEL_RATE_124M] = 124000000,
-	[OV5640_PIXEL_RATE_96M] = 96000000,
-	[OV5640_PIXEL_RATE_48M] = 48000000,
-};
-
-/*
- * MIPI CSI-2 link frequencies.
- *
- * Derived from the above defined pixel rate for bpp = (8, 16, 24) and
- * data_lanes = (1, 2)
- *
- * link_freq = (pixel_rate * bpp) / (2 * data_lanes)
- */
-static const s64 ov5640_csi2_link_freqs[] = {
-	992000000, 888000000, 768000000, 744000000, 672000000, 672000000,
-	592000000, 592000000, 576000000, 576000000, 496000000, 496000000,
-	384000000, 384000000, 384000000, 336000000, 296000000, 288000000,
-	248000000, 192000000, 192000000, 192000000, 96000000,
-};
-
-/* Link freq for default mode: UYVY 16 bpp, 2 data lanes. */
-#define OV5640_DEFAULT_LINK_FREQ	13
-
 enum ov5640_format_mux {
 	OV5640_FMT_MUX_YUV422 = 0,
 	OV5640_FMT_MUX_RGB,
@@ -193,146 +133,34 @@ enum ov5640_format_mux {
 struct ov5640_pixfmt {
 	u32 code;
 	u32 colorspace;
-	u8 bpp;
-	u8 ctrl00;
-	enum ov5640_format_mux mux;
 };
 
-static const struct ov5640_pixfmt ov5640_dvp_formats[] = {
-	{
-		/* YUV422, YUYV */
-		.code		= MEDIA_BUS_FMT_JPEG_1X8,
-		.colorspace	= V4L2_COLORSPACE_JPEG,
-		.bpp		= 16,
-		.ctrl00		= 0x30,
-		.mux		= OV5640_FMT_MUX_YUV422,
-	}, {
-		/* YUV422, UYVY */
-		.code		= MEDIA_BUS_FMT_UYVY8_2X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x3f,
-		.mux		= OV5640_FMT_MUX_YUV422,
-	}, {
-		/* YUV422, YUYV */
-		.code		= MEDIA_BUS_FMT_YUYV8_2X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x30,
-		.mux		= OV5640_FMT_MUX_YUV422,
-	}, {
-		/* RGB565 {g[2:0],b[4:0]},{r[4:0],g[5:3]} */
-		.code		= MEDIA_BUS_FMT_RGB565_2X8_LE,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x6f,
-		.mux		= OV5640_FMT_MUX_RGB,
-	}, {
-		/* RGB565 {r[4:0],g[5:3]},{g[2:0],b[4:0]} */
-		.code		= MEDIA_BUS_FMT_RGB565_2X8_BE,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x61,
-		.mux		= OV5640_FMT_MUX_RGB,
-	}, {
-		/* Raw, BGBG... / GRGR... */
-		.code		= MEDIA_BUS_FMT_SBGGR8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x00,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	}, {
-		/* Raw bayer, GBGB... / RGRG... */
-		.code		= MEDIA_BUS_FMT_SGBRG8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x01,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	}, {
-		/* Raw bayer, GRGR... / BGBG... */
-		.code		= MEDIA_BUS_FMT_SGRBG8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x02,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	}, {
-		/* Raw bayer, RGRG... / GBGB... */
-		.code		= MEDIA_BUS_FMT_SRGGB8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x03,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	},
-	{ /* sentinel */ }
+static const struct ov5640_pixfmt ov5640_formats[] = {
+	{ MEDIA_BUS_FMT_JPEG_1X8, V4L2_COLORSPACE_JPEG, },
+	{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_RGB565_2X8_BE, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_COLORSPACE_SRGB, },
 };
 
-static const struct ov5640_pixfmt ov5640_csi2_formats[] = {
-	{
-		/* YUV422, YUYV */
-		.code		= MEDIA_BUS_FMT_JPEG_1X8,
-		.colorspace	= V4L2_COLORSPACE_JPEG,
-		.bpp		= 16,
-		.ctrl00		= 0x30,
-		.mux		= OV5640_FMT_MUX_YUV422,
-	}, {
-		/* YUV422, UYVY */
-		.code		= MEDIA_BUS_FMT_UYVY8_1X16,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x3f,
-		.mux		= OV5640_FMT_MUX_YUV422,
-	}, {
-		/* YUV422, YUYV */
-		.code		= MEDIA_BUS_FMT_YUYV8_1X16,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x30,
-		.mux		= OV5640_FMT_MUX_YUV422,
-	}, {
-		/* RGB565 {g[2:0],b[4:0]},{r[4:0],g[5:3]} */
-		.code		= MEDIA_BUS_FMT_RGB565_1X16,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 16,
-		.ctrl00		= 0x6f,
-		.mux		= OV5640_FMT_MUX_RGB,
-	}, {
-		/* BGR888: RGB */
-		.code		= MEDIA_BUS_FMT_BGR888_1X24,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 24,
-		.ctrl00		= 0x23,
-		.mux		= OV5640_FMT_MUX_RGB,
-	}, {
-		/* Raw, BGBG... / GRGR... */
-		.code		= MEDIA_BUS_FMT_SBGGR8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x00,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	}, {
-		/* Raw bayer, GBGB... / RGRG... */
-		.code		= MEDIA_BUS_FMT_SGBRG8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x01,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	}, {
-		/* Raw bayer, GRGR... / BGBG... */
-		.code		= MEDIA_BUS_FMT_SGRBG8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x02,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	}, {
-		/* Raw bayer, RGRG... / GBGB... */
-		.code		= MEDIA_BUS_FMT_SRGGB8_1X8,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-		.bpp		= 8,
-		.ctrl00		= 0x03,
-		.mux		= OV5640_FMT_MUX_RAW_DPC,
-	},
-	{ /* sentinel */ }
+static const s64 ov5640_link_freqs[] = {
+	 63136800, /* 1280x720@15 */
+	 83954880, /* 176x144@15, 320x240@15, 720x480@15 */
+	 92145600, /* 640x480@15, 1024x768@15 */
+	126273600, /* 1280x720@30 */
+	167909760, /* 176x144@30, 320x240@30, 720x480@30 */
+	184291200, /* 640x480@30, 1024x768@30 */
+	191116800, /* 1920x1080@15 */
+	335819520, /* 2592x1944@15 */
+	382233600, /* 1920x1080@30 */
 };
+#define OV5640_LINK_FREQS_NUM	ARRAY_SIZE(ov5640_link_freqs)
 
 /*
  * FIXME: remove this when a subdev API becomes available
@@ -346,7 +174,6 @@ MODULE_PARM_DESC(virtual_channel,
 static const int ov5640_framerates[] = {
 	[OV5640_15_FPS] = 15,
 	[OV5640_30_FPS] = 30,
-	[OV5640_60_FPS] = 60,
 };
 
 /* regulator supplies */
@@ -374,42 +201,21 @@ struct reg_value {
 	u32 delay_ms;
 };
 
-struct ov5640_timings {
-	/* Analog crop rectangle. */
-	struct v4l2_rect analog_crop;
-	/* Visibile crop: from analog crop top-left corner. */
-	struct v4l2_rect crop;
-	/* Total pixels per line: width + fixed hblank. */
-	u32 htot;
-	/* Default vertical blanking: frame height = height + vblank. */
-	u32 vblank_def;
-};
-
 struct ov5640_mode_info {
 	enum ov5640_mode_id id;
 	enum ov5640_downsize_mode dn_mode;
-	enum ov5640_pixel_rate_id pixel_rate;
-
-	unsigned int width;
-	unsigned int height;
-
-	struct ov5640_timings dvp_timings;
-	struct ov5640_timings csi2_timings;
-
+	u32 hact;
+	u32 htot;
+	u32 vact;
+	u32 vtot;
 	const struct reg_value *reg_data;
 	u32 reg_data_size;
-
-	/* Used by s_frame_interval only. */
 	u32 max_fps;
-	u32 def_fps;
 };
 
 struct ov5640_ctrls {
 	struct v4l2_ctrl_handler handler;
 	struct v4l2_ctrl *pixel_rate;
-	struct v4l2_ctrl *link_freq;
-	struct v4l2_ctrl *hblank;
-	struct v4l2_ctrl *vblank;
 	struct {
 		struct v4l2_ctrl *auto_exp;
 		struct v4l2_ctrl *exposure;
@@ -431,6 +237,7 @@ struct ov5640_ctrls {
 	struct v4l2_ctrl *test_pattern;
 	struct v4l2_ctrl *hflip;
 	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *link_freq;
 };
 
 struct ov5640_dev {
@@ -449,6 +256,8 @@ struct ov5640_dev {
 	/* lock to protect all members below */
 	struct mutex lock;
 
+	int power_count;
+
 	struct v4l2_mbus_framefmt fmt;
 	bool pending_fmt_change;
 
@@ -456,7 +265,6 @@ struct ov5640_dev {
 	const struct ov5640_mode_info *last_mode;
 	enum ov5640_frame_rate current_fr;
 	struct v4l2_fract frame_interval;
-	s64 current_link_freq;
 
 	struct ov5640_ctrls ctrls;
 
@@ -478,40 +286,6 @@ static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
 			     ctrls.handler)->sd;
 }
 
-static inline bool ov5640_is_csi2(const struct ov5640_dev *sensor)
-{
-	return sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY;
-}
-
-static inline const struct ov5640_pixfmt *
-ov5640_formats(struct ov5640_dev *sensor)
-{
-	return ov5640_is_csi2(sensor) ? ov5640_csi2_formats
-				      : ov5640_dvp_formats;
-}
-
-static const struct ov5640_pixfmt *
-ov5640_code_to_pixfmt(struct ov5640_dev *sensor, u32 code)
-{
-	const struct ov5640_pixfmt *formats = ov5640_formats(sensor);
-	unsigned int i;
-
-	for (i = 0; formats[i].code; ++i) {
-		if (formats[i].code == code)
-			return &formats[i];
-	}
-
-	return &formats[0];
-}
-
-static u32 ov5640_code_to_bpp(struct ov5640_dev *sensor, u32 code)
-{
-	const struct ov5640_pixfmt *format = ov5640_code_to_pixfmt(sensor,
-								   code);
-
-	return format->bpp;
-}
-
 /*
  * FIXME: all of these register tables are likely filled with
  * entries that set the register to their power-on default values,
@@ -520,20 +294,8 @@ static u32 ov5640_code_to_bpp(struct ov5640_dev *sensor, u32 code)
  * over i2c.
  */
 /* YUV422 UYVY VGA@30fps */
-
-static const struct v4l2_mbus_framefmt ov5640_default_fmt = {
-	.code = MEDIA_BUS_FMT_UYVY8_2X8,
-	.width = 640,
-	.height = 480,
-	.colorspace = V4L2_COLORSPACE_SRGB,
-	.ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(V4L2_COLORSPACE_SRGB),
-	.quantization = V4L2_QUANTIZATION_FULL_RANGE,
-	.xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(V4L2_COLORSPACE_SRGB),
-	.field = V4L2_FIELD_NONE,
-};
-
-static const struct reg_value ov5640_init_setting[] = {
-	{0x3103, 0x11, 0, 0},
+static const struct reg_value ov5640_init_setting_30fps_VGA[] = {
+	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 5}, {0x3008, 0x42, 0, 0},
 	{0x3103, 0x03, 0, 0}, {0x3630, 0x36, 0, 0},
 	{0x3631, 0x0e, 0, 0}, {0x3632, 0xe2, 0, 0}, {0x3633, 0x12, 0, 0},
 	{0x3621, 0xe0, 0, 0}, {0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0},
@@ -548,7 +310,11 @@ static const struct reg_value ov5640_init_setting[] = {
 	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
 	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
 	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
 	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
@@ -557,7 +323,9 @@ static const struct reg_value ov5640_init_setting[] = {
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
 	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
 	{0x302e, 0x08, 0, 0}, {0x4300, 0x3f, 0, 0},
-	{0x501f, 0x00, 0, 0}, {0x440e, 0x00, 0, 0}, {0x4837, 0x0a, 0, 0},
+	{0x501f, 0x00, 0, 0}, {0x4407, 0x04, 0, 0},
+	{0x440e, 0x00, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x4837, 0x0a, 0, 0}, {0x3824, 0x02, 0, 0},
 	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
 	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
 	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
@@ -610,57 +378,178 @@ static const struct reg_value ov5640_init_setting[] = {
 	{0x3a1f, 0x14, 0, 0}, {0x3008, 0x02, 0, 0}, {0x3c00, 0x04, 0, 300},
 };
 
-static const struct reg_value ov5640_setting_low_res[] = {
+static const struct reg_value ov5640_setting_VGA_640_480[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0},
+	{0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_XGA_1024_768[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_QVGA_320_240[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_QQVGA_160_120[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_QCIF_176_144[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_NTSC_720_480[] = {
 	{0x3c07, 0x08, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x3c, 0, 0},
 	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
 	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
 	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_PAL_720_576[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x38, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_720P_1280_720[] = {
 	{0x3c07, 0x07, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3814, 0x31, 0, 0},
-	{0x3815, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0xfa, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0}, {0x3807, 0xa9, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
 	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
 	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0},
 	{0x3a03, 0xe4, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0xbc, 0, 0},
 	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x72, 0, 0}, {0x3a0e, 0x01, 0, 0},
 	{0x3a0d, 0x02, 0, 0}, {0x3a14, 0x02, 0, 0}, {0x3a15, 0xe4, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
-	{0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x5001, 0xa3, 0, 0},
 };
 
 static const struct reg_value ov5640_setting_1080P_1920_1080[] = {
 	{0x3c07, 0x08, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3814, 0x11, 0, 0},
-	{0x3815, 0x11, 0, 0},
+	{0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x00, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9f, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
 	{0x3618, 0x04, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x21, 0, 0},
 	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x03, 0, 0},
 	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x4407, 0x04, 0, 0},
+	{0x5001, 0x83, 0, 0},
 	{0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3800, 0x01, 0, 0}, {0x3801, 0x50, 0, 0}, {0x3802, 0x01, 0, 0},
+	{0x3803, 0xb2, 0, 0}, {0x3804, 0x08, 0, 0}, {0x3805, 0xef, 0, 0},
+	{0x3806, 0x05, 0, 0}, {0x3807, 0xf1, 0, 0},
 	{0x3612, 0x2b, 0, 0}, {0x3708, 0x64, 0, 0},
 	{0x3a02, 0x04, 0, 0}, {0x3a03, 0x60, 0, 0}, {0x3a08, 0x01, 0, 0},
 	{0x3a09, 0x50, 0, 0}, {0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x18, 0, 0},
 	{0x3a0e, 0x03, 0, 0}, {0x3a0d, 0x04, 0, 0}, {0x3a14, 0x04, 0, 0},
 	{0x3a15, 0x60, 0, 0}, {0x4407, 0x04, 0, 0},
-	{0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
 	{0x4005, 0x1a, 0, 0},
 };
 
@@ -668,473 +557,152 @@ static const struct reg_value ov5640_setting_QSXGA_2592_1944[] = {
 	{0x3c07, 0x08, 0, 0},
 	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
 	{0x3814, 0x11, 0, 0},
-	{0x3815, 0x11, 0, 0},
+	{0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x00, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9f, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
 	{0x3618, 0x04, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x21, 0, 0},
 	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x03, 0, 0},
 	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
 	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
 	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},
-	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
-	{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 70},
+	{0x4407, 0x04, 0, 0},
+	{0x5001, 0x83, 0, 70},
 };
 
-static const struct ov5640_mode_info ov5640_mode_data[OV5640_NUM_MODES] = {
-	{
-		/* 160x120 */
-		.id		= OV5640_MODE_QQVGA_160_120,
-		.dn_mode	= SUBSAMPLING,
-		.pixel_rate	= OV5640_PIXEL_RATE_48M,
-		.width		= 160,
-		.height		= 120,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 6,
-				.width	= 160,
-				.height	= 120,
-			},
-			.htot		= 1896,
-			.vblank_def	= 864,
-		},
-		.csi2_timings = {
-			/* Feed the full valid pixel array to the ISP. */
-			.analog_crop = {
-				.left	= OV5640_PIXEL_ARRAY_LEFT,
-				.top	= OV5640_PIXEL_ARRAY_TOP,
-				.width	= OV5640_PIXEL_ARRAY_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			/* Maintain a minimum processing margin. */
-			.crop = {
-				.left	= 2,
-				.top	= 4,
-				.width	= 160,
-				.height	= 120,
-			},
-			.htot		= 1600,
-			.vblank_def	= 878,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 176x144 */
-		.id		= OV5640_MODE_QCIF_176_144,
-		.dn_mode	= SUBSAMPLING,
-		.pixel_rate	= OV5640_PIXEL_RATE_48M,
-		.width		= 176,
-		.height		= 144,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 6,
-				.width	= 176,
-				.height	= 144,
-			},
-			.htot		= 1896,
-			.vblank_def	= 840,
-		},
-		.csi2_timings = {
-			/* Feed the full valid pixel array to the ISP. */
-			.analog_crop = {
-				.left	= OV5640_PIXEL_ARRAY_LEFT,
-				.top	= OV5640_PIXEL_ARRAY_TOP,
-				.width	= OV5640_PIXEL_ARRAY_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			/* Maintain a minimum processing margin. */
-			.crop = {
-				.left	= 2,
-				.top	= 4,
-				.width	= 176,
-				.height	= 144,
-			},
-			.htot		= 1600,
-			.vblank_def	= 854,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 320x240 */
-		.id		= OV5640_MODE_QVGA_320_240,
-		.dn_mode	= SUBSAMPLING,
-		.width		= 320,
-		.height		= 240,
-		.pixel_rate	= OV5640_PIXEL_RATE_48M,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 6,
-				.width	= 320,
-				.height	= 240,
-			},
-			.htot		= 1896,
-			.vblank_def	= 744,
-		},
-		.csi2_timings = {
-			/* Feed the full valid pixel array to the ISP. */
-			.analog_crop = {
-				.left	= OV5640_PIXEL_ARRAY_LEFT,
-				.top	= OV5640_PIXEL_ARRAY_TOP,
-				.width	= OV5640_PIXEL_ARRAY_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			/* Maintain a minimum processing margin. */
-			.crop = {
-				.left	= 2,
-				.top	= 4,
-				.width	= 320,
-				.height	= 240,
-			},
-			.htot		= 1600,
-			.vblank_def	= 760,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 640x480 */
-		.id		= OV5640_MODE_VGA_640_480,
-		.dn_mode	= SUBSAMPLING,
-		.pixel_rate	= OV5640_PIXEL_RATE_48M,
-		.width		= 640,
-		.height		= 480,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 6,
-				.width	= 640,
-				.height	= 480,
-			},
-			.htot		= 1896,
-			.vblank_def	= 600,
-		},
-		.csi2_timings = {
-			/* Feed the full valid pixel array to the ISP. */
-			.analog_crop = {
-				.left	= OV5640_PIXEL_ARRAY_LEFT,
-				.top	= OV5640_PIXEL_ARRAY_TOP,
-				.width	= OV5640_PIXEL_ARRAY_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			/* Maintain a minimum processing margin. */
-			.crop = {
-				.left	= 2,
-				.top	= 4,
-				.width	= 640,
-				.height	= 480,
-			},
-			.htot		= 1600,
-			.vblank_def	= 520,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_60_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 720x480 */
-		.id		= OV5640_MODE_NTSC_720_480,
-		.dn_mode	= SUBSAMPLING,
-		.width		= 720,
-		.height		= 480,
-		.pixel_rate	= OV5640_PIXEL_RATE_96M,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 56,
-				.top	= 60,
-				.width	= 720,
-				.height	= 480,
-			},
-			.htot		= 1896,
-			.vblank_def	= 504,
-		},
-		.csi2_timings = {
-			/* Feed the full valid pixel array to the ISP. */
-			.analog_crop = {
-				.left	= OV5640_PIXEL_ARRAY_LEFT,
-				.top	= OV5640_PIXEL_ARRAY_TOP,
-				.width	= OV5640_PIXEL_ARRAY_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			.crop = {
-				.left	= 56,
-				.top	= 60,
-				.width	= 720,
-				.height	= 480,
-			},
-			.htot		= 1896,
-			.vblank_def	= 1206,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 720x576 */
-		.id		= OV5640_MODE_PAL_720_576,
-		.dn_mode	= SUBSAMPLING,
-		.width		= 720,
-		.height		= 576,
-		.pixel_rate	= OV5640_PIXEL_RATE_96M,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 56,
-				.top	= 6,
-				.width	= 720,
-				.height	= 576,
-			},
-			.htot		= 1896,
-			.vblank_def	= 408,
-		},
-		.csi2_timings = {
-			/* Feed the full valid pixel array to the ISP. */
-			.analog_crop = {
-				.left	= OV5640_PIXEL_ARRAY_LEFT,
-				.top	= OV5640_PIXEL_ARRAY_TOP,
-				.width	= OV5640_PIXEL_ARRAY_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			.crop = {
-				.left	= 56,
-				.top	= 6,
-				.width	= 720,
-				.height	= 576,
-			},
-			.htot		= 1896,
-			.vblank_def	= 1110,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 1024x768 */
-		.id		= OV5640_MODE_XGA_1024_768,
-		.dn_mode	= SUBSAMPLING,
-		.pixel_rate	= OV5640_PIXEL_RATE_96M,
-		.width		= 1024,
-		.height		= 768,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= 2624,
-				.height	= 1944,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 6,
-				.width	= 1024,
-				.height	= 768,
-			},
-			.htot		= 1896,
-			.vblank_def	= 312,
-		},
-		.csi2_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 4,
-				.width	= OV5640_NATIVE_WIDTH,
-				.height	= OV5640_PIXEL_ARRAY_HEIGHT,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 6,
-				.width	= 1024,
-				.height	= 768,
-			},
-			.htot		= 1896,
-			.vblank_def	= 918,
-		},
-		.reg_data	= ov5640_setting_low_res,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_low_res),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 1280x720 */
-		.id		= OV5640_MODE_720P_1280_720,
-		.dn_mode	= SUBSAMPLING,
-		.pixel_rate	= OV5640_PIXEL_RATE_124M,
-		.width		= 1280,
-		.height		= 720,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 250,
-				.width	= 2624,
-				.height	= 1456,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 4,
-				.width	= 1280,
-				.height	= 720,
-			},
-			.htot		= 1892,
-			.vblank_def	= 20,
-		},
-		.csi2_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 250,
-				.width	= 2624,
-				.height	= 1456,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 4,
-				.width	= 1280,
-				.height	= 720,
-			},
-			.htot		= 1600,
-			.vblank_def	= 560,
-		},
-		.reg_data	= ov5640_setting_720P_1280_720,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_720P_1280_720),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 1920x1080 */
-		.id		= OV5640_MODE_1080P_1920_1080,
-		.dn_mode	= SCALING,
-		.pixel_rate	= OV5640_PIXEL_RATE_148M,
-		.width		= 1920,
-		.height		= 1080,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 336,
-				.top	= 434,
-				.width	= 1952,
-				.height	= 1088,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 4,
-				.width	= 1920,
-				.height	= 1080,
-			},
-			.htot		= 2500,
-			.vblank_def	= 40,
-		},
-		.csi2_timings = {
-			/* Crop the full valid pixel array in the center. */
-			.analog_crop = {
-				.left	= 336,
-				.top	= 434,
-				.width	= 1952,
-				.height	= 1088,
-			},
-			/* Maintain a larger processing margins. */
-			.crop = {
-				.left	= 16,
-				.top	= 4,
-				.width	= 1920,
-				.height	= 1080,
-			},
-			.htot		= 2234,
-			.vblank_def	= 24,
-		},
-		.reg_data	= ov5640_setting_1080P_1920_1080,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_1080P_1920_1080),
-		.max_fps	= OV5640_30_FPS,
-		.def_fps	= OV5640_30_FPS
-	}, {
-		/* 2592x1944 */
-		.id		= OV5640_MODE_QSXGA_2592_1944,
-		.dn_mode	= SCALING,
-		.pixel_rate	= OV5640_PIXEL_RATE_168M,
-		.width		= OV5640_PIXEL_ARRAY_WIDTH,
-		.height		= OV5640_PIXEL_ARRAY_HEIGHT,
-		.dvp_timings = {
-			.analog_crop = {
-				.left	= 0,
-				.top	= 0,
-				.width	= 2624,
-				.height	= 1952,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 4,
-				.width	= 2592,
-				.height	= 1944,
-			},
-			.htot		= 2844,
-			.vblank_def	= 24,
-		},
-		.csi2_timings = {
-			/* Give more processing margin to full resolution. */
-			.analog_crop = {
-				.left	= 0,
-				.top	= 0,
-				.width	= OV5640_NATIVE_WIDTH,
-				.height	= 1952,
-			},
-			.crop = {
-				.left	= 16,
-				.top	= 4,
-				.width	= 2592,
-				.height	= 1944,
-			},
-			.htot		= 2844,
-			.vblank_def	= 24,
-		},
-		.reg_data	= ov5640_setting_QSXGA_2592_1944,
-		.reg_data_size	= ARRAY_SIZE(ov5640_setting_QSXGA_2592_1944),
-		.max_fps	= OV5640_15_FPS,
-		.def_fps	= OV5640_15_FPS
-	},
+/* power-on sensor init reg table */
+static const struct ov5640_mode_info *ov5640_mode_init_data;
+
+static const struct ov5640_mode_info ov5640_mode_init_data_dvp = {
+	0, SUBSAMPLING, 640, 1896, 480, 984,
+	ov5640_init_setting_30fps_VGA,
+	ARRAY_SIZE(ov5640_init_setting_30fps_VGA),
+	OV5640_30_FPS,
 };
 
-static const struct ov5640_timings *
-ov5640_timings(const struct ov5640_dev *sensor,
-	       const struct ov5640_mode_info *mode)
-{
-	if (ov5640_is_csi2(sensor))
-		return &mode->csi2_timings;
+static const struct ov5640_mode_info ov5640_mode_init_data_csi2 = {
+	0, SUBSAMPLING, 640, 2844, 480, 984,
+	ov5640_init_setting_30fps_VGA,
+	ARRAY_SIZE(ov5640_init_setting_30fps_VGA),
+	OV5640_30_FPS,
+};
 
-	return &mode->dvp_timings;
-}
+static const struct ov5640_mode_info *ov5640_mode_data;
+
+static const struct ov5640_mode_info
+ov5640_mode_data_dvp[OV5640_NUM_MODES] = {
+	{OV5640_MODE_QQVGA_160_120, SUBSAMPLING,
+	 160, 1896, 120, 984,
+	 ov5640_setting_QQVGA_160_120,
+	 ARRAY_SIZE(ov5640_setting_QQVGA_160_120),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QCIF_176_144, SUBSAMPLING,
+	 176, 1896, 144, 984,
+	 ov5640_setting_QCIF_176_144,
+	 ARRAY_SIZE(ov5640_setting_QCIF_176_144),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QVGA_320_240, SUBSAMPLING,
+	 320, 1896, 240, 984,
+	 ov5640_setting_QVGA_320_240,
+	 ARRAY_SIZE(ov5640_setting_QVGA_320_240),
+	 OV5640_30_FPS},
+	{OV5640_MODE_VGA_640_480, SUBSAMPLING,
+	 640, 1896, 480, 1080,
+	 ov5640_setting_VGA_640_480,
+	 ARRAY_SIZE(ov5640_setting_VGA_640_480),
+	 OV5640_30_FPS},
+	{OV5640_MODE_NTSC_720_480, SUBSAMPLING,
+	 720, 1896, 480, 984,
+	 ov5640_setting_NTSC_720_480,
+	 ARRAY_SIZE(ov5640_setting_NTSC_720_480),
+	OV5640_30_FPS},
+	{OV5640_MODE_PAL_720_576, SUBSAMPLING,
+	 720, 1896, 576, 984,
+	 ov5640_setting_PAL_720_576,
+	 ARRAY_SIZE(ov5640_setting_PAL_720_576),
+	 OV5640_30_FPS},
+	{OV5640_MODE_XGA_1024_768, SUBSAMPLING,
+	 1024, 1896, 768, 1080,
+	 ov5640_setting_XGA_1024_768,
+	 ARRAY_SIZE(ov5640_setting_XGA_1024_768),
+	 OV5640_30_FPS},
+	{OV5640_MODE_720P_1280_720, SUBSAMPLING,
+	 1280, 1892, 720, 740,
+	 ov5640_setting_720P_1280_720,
+	 ARRAY_SIZE(ov5640_setting_720P_1280_720),
+	 OV5640_30_FPS},
+	{OV5640_MODE_1080P_1920_1080, SCALING,
+	 1920, 2500, 1080, 1120,
+	 ov5640_setting_1080P_1920_1080,
+	 ARRAY_SIZE(ov5640_setting_1080P_1920_1080),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QSXGA_2592_1944, SCALING,
+	 2592, 2844, 1944, 1968,
+	 ov5640_setting_QSXGA_2592_1944,
+	 ARRAY_SIZE(ov5640_setting_QSXGA_2592_1944),
+	 OV5640_15_FPS},
+};
+
+/*
+ * When using CSI-2 interface, adjusting htot to 2844
+ * gives better result in term of framerate, 720p support
+ * and overall stability with CSI-2 receiver
+ */
+static const struct ov5640_mode_info
+ov5640_mode_data_csi2[OV5640_NUM_MODES] = {
+	{OV5640_MODE_QQVGA_160_120, SUBSAMPLING,
+	 160, 2844, 120, 984,
+	 ov5640_setting_QQVGA_160_120,
+	 ARRAY_SIZE(ov5640_setting_QQVGA_160_120),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QCIF_176_144, SUBSAMPLING,
+	 176, 2844, 144, 984,
+	 ov5640_setting_QCIF_176_144,
+	 ARRAY_SIZE(ov5640_setting_QCIF_176_144),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QVGA_320_240, SUBSAMPLING,
+	 320, 2844, 240, 984,
+	 ov5640_setting_QVGA_320_240,
+	 ARRAY_SIZE(ov5640_setting_QVGA_320_240),
+	 OV5640_30_FPS},
+	{OV5640_MODE_VGA_640_480, SUBSAMPLING,
+	 640, 2844, 480, 1080,
+	 ov5640_setting_VGA_640_480,
+	 ARRAY_SIZE(ov5640_setting_VGA_640_480),
+	 OV5640_30_FPS},
+	{OV5640_MODE_NTSC_720_480, SUBSAMPLING,
+	 720, 2844, 480, 984,
+	 ov5640_setting_NTSC_720_480,
+	 ARRAY_SIZE(ov5640_setting_NTSC_720_480),
+	OV5640_30_FPS},
+	{OV5640_MODE_PAL_720_576, SUBSAMPLING,
+	 720, 2844, 576, 984,
+	 ov5640_setting_PAL_720_576,
+	 ARRAY_SIZE(ov5640_setting_PAL_720_576),
+	 OV5640_30_FPS},
+	{OV5640_MODE_XGA_1024_768, SUBSAMPLING,
+	 1024, 2844, 768, 1080,
+	 ov5640_setting_XGA_1024_768,
+	 ARRAY_SIZE(ov5640_setting_XGA_1024_768),
+	 OV5640_30_FPS},
+	{OV5640_MODE_720P_1280_720, SUBSAMPLING,
+	 1280, 2844, 720, 740,
+	 ov5640_setting_720P_1280_720,
+	 ARRAY_SIZE(ov5640_setting_720P_1280_720),
+	 OV5640_30_FPS},
+	{OV5640_MODE_1080P_1920_1080, SCALING,
+	 1920, 2844, 1080, 1120,
+	 ov5640_setting_1080P_1920_1080,
+	 ARRAY_SIZE(ov5640_setting_1080P_1920_1080),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QSXGA_2592_1944, SCALING,
+	 2592, 2844, 1944, 1968,
+	 ov5640_setting_QSXGA_2592_1944,
+	 ARRAY_SIZE(ov5640_setting_QSXGA_2592_1944),
+	 OV5640_15_FPS},
+};
 
 static int ov5640_init_slave_id(struct ov5640_dev *sensor)
 {
@@ -1308,10 +876,20 @@ static int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,
  *                                +-----+-----+
  *                                       +------------> PCLK
  *
- * There seems to be also constraints:
+ * This is deviating from the datasheet at least for the register
+ * 0x3108, since it's said here that the PCLK would be clocked from
+ * the PLL.
+ *
+ * There seems to be also (unverified) constraints:
  *  - the PLL pre-divider output rate should be in the 4-27MHz range
  *  - the PLL multiplier output rate should be in the 500-1000MHz range
  *  - PCLK >= SCLK * 2 in YUV, >= SCLK in Raw or JPEG
+ *
+ * In the two latter cases, these constraints are met since our
+ * factors are hardcoded. If we were to change that, we would need to
+ * take this into account. The only varying parts are the PLL
+ * multiplier and the system clock divider, which are shared between
+ * all these clocks so won't cause any issue.
  */
 
 /*
@@ -1330,6 +908,13 @@ static int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,
 #define OV5640_SYSDIV_MIN	1
 #define OV5640_SYSDIV_MAX	16
 
+/*
+ * Hardcode these values for scaler and non-scaler modes.
+ * FIXME: to be re-calcualted for 1 data lanes setups
+ */
+#define OV5640_MIPI_DIV_PCLK	2
+#define OV5640_MIPI_DIV_SCLK	1
+
 /*
  * This is supposed to be ranging from 1 to 2, but the value is always
  * set to 2 in the vendor kernels.
@@ -1439,6 +1024,9 @@ static unsigned long ov5640_calc_sys_clk(struct ov5640_dev *sensor,
 /*
  * ov5640_set_mipi_pclk() - Calculate the clock tree configuration values
  *			    for the MIPI CSI-2 output.
+ *
+ * FIXME: this have been tested with 16bpp and 2 lanes setup only.
+ * above formula for setups with 1 lane or image formats with different bpp.
  */
 static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor)
 {
@@ -1447,75 +1035,74 @@ static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor)
 	unsigned long link_freq;
 	unsigned long sysclk;
 	u8 pclk_period;
-	u32 sample_rate;
-	u32 num_lanes;
 	int ret;
 
-	/* Use the link freq computed at ov5640_update_pixel_rate() time. */
-	link_freq = sensor->current_link_freq;
+	/* Get current link frequency */
+	link_freq = ov5640_link_freqs[sensor->ctrls.link_freq->val];
 
 	/*
-	 * - mipi_div - Additional divider for the MIPI lane clock.
+	 * - mipi_div - Assumptions not supported by documentation
 	 *
-	 * Higher link frequencies would make sysclk > 1GHz.
-	 * Keep the sysclk low and do not divide in the MIPI domain.
+	 *   The MIPI clock generation differs for modes that use the scaler and
+	 *   modes that do not.
 	 */
-	if (link_freq > OV5640_LINK_RATE_MAX)
+	if (sensor->current_mode->dn_mode == SCALING)
 		mipi_div = 1;
 	else
 		mipi_div = 2;
 
-	sysclk = link_freq * mipi_div;
+	sysclk = link_freq * 2 * mipi_div;
 	ov5640_calc_sys_clk(sensor, sysclk, &prediv, &mult, &sysdiv);
 
 	/*
-	 * Adjust PLL parameters to maintain the MIPI_SCLK-to-PCLK ratio.
+	 * Adjust PLL parameters to maintain the MIPI_SCLK-to-PCLK ratio;
 	 *
 	 * - root_div = 2 (fixed)
-	 * - bit_div : MIPI 8-bit = 2; MIPI 10-bit = 2.5
+	 * - bit_div : MIPI 8-bit = 2
+	 *	       MIPI 10-bit = 2,5
 	 * - pclk_div = 1 (fixed)
-	 * - p_div  = (2 lanes ? mipi_div : 2 * mipi_div)
-	 *
-	 * This results in the following MIPI_SCLK depending on the number
-	 * of lanes:
+	 * - pll_div  = (2 lanes ? mipi_div : 2 * mipi_div)
+	 *   2 lanes: MIPI_SCLK = (4 or 5) * PCLK
+	 *   1 lanes: MIPI_SCLK = (8 or 10) * PCLK
 	 *
-	 * - 2 lanes: MIPI_SCLK = (4 or 5) * PCLK
-	 * - 1 lanes: MIPI_SCLK = (8 or 10) * PCLK
+	 * TODO: support 10-bit formats
+	 * TODO: support 1 lane
 	 */
 	root_div = OV5640_PLL_CTRL3_PLL_ROOT_DIV_2;
 	bit_div =  OV5640_PLL_CTRL0_MIPI_MODE_8BIT;
-	pclk_div = ilog2(OV5640_PCLK_ROOT_DIV);
+	pclk_div = OV5640_PLL_SYS_ROOT_DIVIDER_BYPASS;
 
 	/*
 	 * Scaler clock:
 	 * - YUV: PCLK >= 2 * SCLK
 	 * - RAW or JPEG: PCLK >= SCLK
 	 * - sclk2x_div = sclk_div / 2
+	 *
+	 * TODO: add support for RAW and JPEG modes. To maintain the
+	 * SCLK to PCLK ratio, the sclk_div should probably be
+	 * adjusted.
 	 */
 	sclk_div = ilog2(OV5640_SCLK_ROOT_DIV);
 	sclk2x_div = ilog2(OV5640_SCLK2X_ROOT_DIV);
 
 	/*
-	 * Set the pixel clock period expressed in ns with 1-bit decimal
-	 * (0x01=0.5ns).
+	 * This is called pclk period, but it actually represents the
+	 * sample period expressed in ns with 1-bit decimal (0x01=0.5ns).
 	 *
-	 * The register is very briefly documented. In the OV5645 datasheet it
-	 * is described as (2 * pclk period), and from testing it seems the
-	 * actual definition is 2 * 8-bit sample period.
+	 * - pclk = link_freq * 2 * lanes / bpp
 	 *
-	 * 2 * sample_period = (mipi_clk * 2 * num_lanes / bpp) * (bpp / 8) / 2
+	 * TODO: support 1 data lane; support modes with bpp != 16.
 	 */
-	num_lanes = sensor->ep.bus.mipi_csi2.num_data_lanes;
-	sample_rate = (link_freq * mipi_div * num_lanes * 2) / 16;
-	pclk_period = 2000000000UL / sample_rate;
+	pclk_period = 2000000000UL / (link_freq / 2);
 
 	/* Program the clock tree registers. */
-	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0, 0x0f, bit_div);
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0,
+			     0x0f, bit_div);
 	if (ret)
 		return ret;
 
-	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1, 0xff,
-			     (sysdiv << 4) | mipi_div);
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1,
+			     0xff, sysdiv << 4 | mipi_div);
 	if (ret)
 		return ret;
 
@@ -1523,31 +1110,19 @@ static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor)
 	if (ret)
 		return ret;
 
-	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3, 0x1f,
-			     root_div | prediv);
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3,
+			     0x1f, root_div | prediv);
 	if (ret)
 		return ret;
 
 	ret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,
-			     (pclk_div << 4) | (sclk2x_div << 2) | sclk_div);
+			      (pclk_div << 4) | (sclk2x_div << 2) | sclk_div);
 	if (ret)
 		return ret;
 
 	return ov5640_write_reg(sensor, OV5640_REG_PCLK_PERIOD, pclk_period);
 }
 
-static u32 ov5640_calc_pixel_rate(struct ov5640_dev *sensor)
-{
-	const struct ov5640_mode_info *mode = sensor->current_mode;
-	const struct ov5640_timings *timings = &mode->dvp_timings;
-	u32 rate;
-
-	rate = timings->htot * (timings->crop.height + timings->vblank_def);
-	rate *= ov5640_framerates[sensor->current_fr];
-
-	return rate;
-}
-
 static unsigned long ov5640_calc_pclk(struct ov5640_dev *sensor,
 				      unsigned long rate,
 				      u8 *pll_prediv, u8 *pll_mult, u8 *sysdiv,
@@ -1565,15 +1140,67 @@ static unsigned long ov5640_calc_pclk(struct ov5640_dev *sensor,
 	return _rate / *pll_rdiv / *bit_div / *pclk_div;
 }
 
+static u64 ov5640_calc_pixel_rate(struct ov5640_dev *sensor)
+{
+	u64 rate;
+
+	rate = sensor->current_mode->vtot * sensor->current_mode->htot;
+	rate *= ov5640_framerates[sensor->current_fr];
+
+	return rate;
+}
+
 static int ov5640_set_dvp_pclk(struct ov5640_dev *sensor)
 {
+	const struct ov5640_mode_info *mode = sensor->current_mode;
 	u8 prediv, mult, sysdiv, pll_rdiv, bit_div, pclk_div;
-	u32 rate;
+	struct i2c_client *client = sensor->i2c_client;
+	unsigned int pclk_freq, max_pclk_freq;
+	u8 dvp_pclk_divider;
+	unsigned long rate;
 	int ret;
 
+	/* Get pixel rate */
 	rate = ov5640_calc_pixel_rate(sensor);
-	rate *= ov5640_code_to_bpp(sensor, sensor->fmt.code);
-	rate /= sensor->ep.bus.parallel.bus_width;
+
+	dev_dbg(&client->dev, "pixel_rate=%lu selected (%dx%d@%d)(%dx%d)\n",
+		rate,
+		sensor->current_mode->hact,
+		sensor->current_mode->vact,
+		ov5640_framerates[sensor->current_fr],
+		sensor->current_mode->htot,
+		sensor->current_mode->vtot);
+
+	/*
+	 * All the formats we support have 16 bits per pixel, seems to require
+	 * the same rate than YUV, so we can just use 16 bpp all the time.
+	 */
+	rate = rate * 16 / sensor->ep.bus.parallel.bus_width;
+
+	/*
+	 * 1280x720 and 1024x768 are reported to use 'SUBSAMPLING' only,
+	 * but they seems to go through the scaler before subsampling.
+	 */
+	if (mode->dn_mode == SCALING ||
+	   (mode->id == OV5640_MODE_720P_1280_720) ||
+	   (mode->id == OV5640_MODE_XGA_1024_768))
+		dvp_pclk_divider = 1;
+	else
+		dvp_pclk_divider = 2;
+
+	ret = ov5640_write_reg(sensor, OV5640_REG_DVP_PCLK_DIVIDER,
+			       dvp_pclk_divider);
+	if (ret)
+		return ret;
+	pclk_freq = rate / dvp_pclk_divider;
+	max_pclk_freq = sensor->ep.bus.parallel.pclk_max_frequency;
+
+	/* clip rate according to optional maximum pixel clock limit */
+	if (max_pclk_freq && (pclk_freq > max_pclk_freq)) {
+		rate = max_pclk_freq * dvp_pclk_divider;
+		dev_dbg(&client->dev, "DVP pixel clock too high (%d > %d Hz), reducing rate...\n",
+			pclk_freq, max_pclk_freq);
+	}
 
 	ov5640_calc_pclk(sensor, rate, &prediv, &mult, &sysdiv, &pll_rdiv,
 			 &bit_div, &pclk_div);
@@ -1609,6 +1236,7 @@ static int ov5640_set_dvp_pclk(struct ov5640_dev *sensor)
 			      (ilog2(pclk_div) << 4));
 }
 
+#if 0
 /* set JPEG framing sizes */
 static int ov5640_set_jpeg_timings(struct ov5640_dev *sensor,
 				   const struct ov5640_mode_info *mode)
@@ -1626,90 +1254,52 @@ static int ov5640_set_jpeg_timings(struct ov5640_dev *sensor,
 	if (ret < 0)
 		return ret;
 
-	ret = ov5640_write_reg16(sensor, OV5640_REG_VFIFO_HSIZE, mode->width);
+	ret = ov5640_write_reg16(sensor, OV5640_REG_VFIFO_HSIZE, mode->hact);
 	if (ret < 0)
 		return ret;
 
-	return ov5640_write_reg16(sensor, OV5640_REG_VFIFO_VSIZE, mode->height);
+	return ov5640_write_reg16(sensor, OV5640_REG_VFIFO_VSIZE, mode->vact);
 }
+#endif
 
 /* download ov5640 settings to sensor through i2c */
 static int ov5640_set_timings(struct ov5640_dev *sensor,
 			      const struct ov5640_mode_info *mode)
 {
-	const struct ov5640_timings *timings;
-	const struct v4l2_rect *analog_crop;
-	const struct v4l2_rect *crop;
 	int ret;
-
+#if 0
 	if (sensor->fmt.code == MEDIA_BUS_FMT_JPEG_1X8) {
 		ret = ov5640_set_jpeg_timings(sensor, mode);
 		if (ret < 0)
 			return ret;
 	}
-
-	timings = ov5640_timings(sensor, mode);
-	analog_crop = &timings->analog_crop;
-	crop = &timings->crop;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HS,
-				 analog_crop->left);
+#endif
+	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPHO, mode->hact);
 	if (ret < 0)
 		return ret;
 
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VS,
-				 analog_crop->top);
+	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPVO, mode->vact);
 	if (ret < 0)
 		return ret;
 
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HW,
-				 analog_crop->left + analog_crop->width - 1);
+	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HTS, mode->htot);
 	if (ret < 0)
 		return ret;
 
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VH,
-				 analog_crop->top + analog_crop->height - 1);
-	if (ret < 0)
-		return ret;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HOFFS, crop->left);
-	if (ret < 0)
-		return ret;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VOFFS, crop->top);
-	if (ret < 0)
-		return ret;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPHO, mode->width);
-	if (ret < 0)
-		return ret;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPVO, mode->height);
-	if (ret < 0)
-		return ret;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HTS, timings->htot);
-	if (ret < 0)
-		return ret;
-
-	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS,
-				 mode->height + timings->vblank_def);
-	if (ret < 0)
-		return ret;
-
-	return 0;
+	return ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS, mode->vtot);
 }
 
-static void ov5640_load_regs(struct ov5640_dev *sensor,
-			     const struct reg_value *regs, unsigned int regnum)
+static int ov5640_load_regs(struct ov5640_dev *sensor,
+			    const struct ov5640_mode_info *mode)
 {
+	const struct reg_value *regs = mode->reg_data;
 	unsigned int i;
 	u32 delay_ms;
 	u16 reg_addr;
 	u8 mask, val;
 	int ret = 0;
 
-	for (i = 0; i < regnum; ++i, ++regs) {
+	for (i = 0; i < mode->reg_data_size; ++i, ++regs) {
 		delay_ms = regs->delay_ms;
 		reg_addr = regs->reg_addr;
 		val = regs->val;
@@ -1718,7 +1308,7 @@ static void ov5640_load_regs(struct ov5640_dev *sensor,
 		/* remain in power down mode for DVP */
 		if (regs->reg_addr == OV5640_REG_SYS_CTRL0 &&
 		    val == OV5640_REG_SYS_CTRL0_SW_PWUP &&
-		    !ov5640_is_csi2(sensor))
+		    sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY)
 			continue;
 
 		if (mask)
@@ -1731,6 +1321,8 @@ static void ov5640_load_regs(struct ov5640_dev *sensor,
 		if (delay_ms)
 			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
 	}
+
+	return ov5640_set_timings(sensor, mode);
 }
 
 static int ov5640_set_autoexposure(struct ov5640_dev *sensor, bool on)
@@ -2115,17 +1707,22 @@ static int ov5640_set_virtual_channel(struct ov5640_dev *sensor)
 }
 
 static const struct ov5640_mode_info *
-ov5640_find_mode(struct ov5640_dev *sensor, int width, int height, bool nearest)
+ov5640_find_mode(struct ov5640_dev *sensor, enum ov5640_frame_rate fr,
+		 int width, int height, bool nearest)
 {
 	const struct ov5640_mode_info *mode;
 
 	mode = v4l2_find_nearest_size(ov5640_mode_data,
-				      ARRAY_SIZE(ov5640_mode_data),
-				      width, height, width, height);
+				      OV5640_NUM_MODES,
+				      hact, vact,
+				      width, height);
 
 	if (!mode ||
-	    (!nearest &&
-	     (mode->width != width || mode->height != height)))
+	    (!nearest && (mode->hact != width || mode->vact != height)))
+		return NULL;
+
+	/* Check to see if the current mode exceeds the max frame rate */
+	if (ov5640_framerates[fr] > ov5640_framerates[mode->max_fps])
 		return NULL;
 
 	return mode;
@@ -2178,8 +1775,7 @@ static int ov5640_set_mode_exposure_calc(struct ov5640_dev *sensor,
 		return ret;
 
 	/* Write capture setting */
-	ov5640_load_regs(sensor, mode->reg_data, mode->reg_data_size);
-	ret = ov5640_set_timings(sensor, mode);
+	ret = ov5640_load_regs(sensor, mode);
 	if (ret < 0)
 		return ret;
 
@@ -2303,8 +1899,7 @@ static int ov5640_set_mode_direct(struct ov5640_dev *sensor,
 		return -EINVAL;
 
 	/* Write capture setting */
-	ov5640_load_regs(sensor, mode->reg_data, mode->reg_data_size);
-	return ov5640_set_timings(sensor, mode);
+	return ov5640_load_regs(sensor, mode);
 }
 
 static int ov5640_set_mode(struct ov5640_dev *sensor)
@@ -2332,10 +1927,12 @@ static int ov5640_set_mode(struct ov5640_dev *sensor)
 			goto restore_auto_gain;
 	}
 
-	if (ov5640_is_csi2(sensor))
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
 		ret = ov5640_set_mipi_pclk(sensor);
-	else
+	} else {
 		ret = ov5640_set_dvp_pclk(sensor);
+	}
+
 	if (ret < 0)
 		return 0;
 
@@ -2402,8 +1999,10 @@ static int ov5640_restore_mode(struct ov5640_dev *sensor)
 	int ret;
 
 	/* first load the initial register values */
-	ov5640_load_regs(sensor, ov5640_init_setting,
-			 ARRAY_SIZE(ov5640_init_setting));
+	ret = ov5640_load_regs(sensor, ov5640_mode_init_data);
+	if (ret < 0)
+		return ret;
+	sensor->last_mode = ov5640_mode_init_data;
 
 	ret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,
 			     (ilog2(OV5640_SCLK2X_ROOT_DIV) << 2) |
@@ -2424,45 +2023,24 @@ static void ov5640_power(struct ov5640_dev *sensor, bool enable)
 	gpiod_set_value_cansleep(sensor->pwdn_gpio, enable ? 0 : 1);
 }
 
-/*
- * From section 2.7 power up sequence:
- * t0 + t1 + t2 >= 5ms	Delay from DOVDD stable to PWDN pull down
- * t3 >= 1ms		Delay from PWDN pull down to RESETB pull up
- * t4 >= 20ms		Delay from RESETB pull up to SCCB (i2c) stable
- *
- * Some modules don't expose RESETB/PWDN pins directly, instead providing a
- * "PWUP" GPIO which is wired through appropriate delays and inverters to the
- * pins.
- *
- * In such cases, this gpio should be mapped to pwdn_gpio in the driver, and we
- * should still toggle the pwdn_gpio below with the appropriate delays, while
- * the calls to reset_gpio will be ignored.
- */
-static void ov5640_powerup_sequence(struct ov5640_dev *sensor)
+static void ov5640_reset(struct ov5640_dev *sensor)
 {
-	if (sensor->pwdn_gpio) {
-		gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	if (!sensor->reset_gpio)
+		return;
 
-		/* camera power cycle */
-		ov5640_power(sensor, false);
-		usleep_range(5000, 10000);	/* t2 */
-		ov5640_power(sensor, true);
-		usleep_range(1000, 2000);	/* t3 */
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
 
-		gpiod_set_value_cansleep(sensor->reset_gpio, 0);
-	} else {
-		/* software reset */
-		ov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0,
-				 OV5640_REG_SYS_CTRL0_SW_RST);
-	}
-	usleep_range(20000, 25000);	/* t4 */
+	/* camera power cycle */
+	ov5640_power(sensor, false);
+	usleep_range(5000, 10000);
+	ov5640_power(sensor, true);
+	usleep_range(5000, 10000);
 
-	/*
-	 * software standby: allows registers programming;
-	 * exit at restore_mode() for CSI, s_stream(1) for DVP
-	 */
-	ov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0,
-			 OV5640_REG_SYS_CTRL0_SW_PWDN);
+	gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+	usleep_range(20000, 25000);
 }
 
 static int ov5640_set_power_on(struct ov5640_dev *sensor)
@@ -2485,7 +2063,8 @@ static int ov5640_set_power_on(struct ov5640_dev *sensor)
 		goto xclk_off;
 	}
 
-	ov5640_powerup_sequence(sensor);
+	ov5640_reset(sensor);
+	ov5640_power(sensor, true);
 
 	ret = ov5640_init_slave_id(sensor);
 	if (ret)
@@ -2528,9 +2107,9 @@ static int ov5640_set_power_mipi(struct ov5640_dev *sensor, bool on)
 	 *		  "ov5640_set_stream_mipi()")
 	 * [4] = 0	: Power up MIPI HS Tx
 	 * [3] = 0	: Power up MIPI LS Rx
-	 * [2] = 1	: MIPI interface enabled
+	 * [2] = 0	: MIPI interface disabled
 	 */
-	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x44);
+	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x40);
 	if (ret)
 		return ret;
 
@@ -2715,23 +2294,38 @@ static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
 	return ret;
 }
 
-static int ov5640_sensor_suspend(struct device *dev)
+/* --------------- Subdev Operations --------------- */
+
+static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 {
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
-	struct ov5640_dev *ov5640 = to_ov5640_dev(sd);
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	int ret = 0;
 
-	return ov5640_set_power(ov5640, false);
-}
+	mutex_lock(&sensor->lock);
 
-static int ov5640_sensor_resume(struct device *dev)
-{
-	struct v4l2_subdev *sd = dev_get_drvdata(dev);
-	struct ov5640_dev *ov5640 = to_ov5640_dev(sd);
+	/*
+	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
+	 * update the power state.
+	 */
+	if (sensor->power_count == !on) {
+		ret = ov5640_set_power(sensor, !!on);
+		if (ret)
+			goto out;
+	}
 
-	return ov5640_set_power(ov5640, true);
-}
+	/* Update the power count. */
+	sensor->power_count += on ? 1 : -1;
+	WARN_ON(sensor->power_count < 0);
+out:
+	mutex_unlock(&sensor->lock);
 
-/* --------------- Subdev Operations --------------- */
+	if (on && !ret && sensor->power_count == 1) {
+		/* restore controls */
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	}
+
+	return ret;
+}
 
 static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 				     struct v4l2_fract *fi,
@@ -2743,12 +2337,12 @@ static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 	int i;
 
 	minfps = ov5640_framerates[OV5640_15_FPS];
-	maxfps = ov5640_framerates[OV5640_60_FPS];
+	maxfps = ov5640_framerates[OV5640_30_FPS];
 
 	if (fi->numerator == 0) {
 		fi->denominator = maxfps;
 		fi->numerator = 1;
-		rate = OV5640_60_FPS;
+		rate = OV5640_30_FPS;
 		goto find_mode;
 	}
 
@@ -2769,7 +2363,7 @@ static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
 	fi->denominator = best_fps;
 
 find_mode:
-	mode = ov5640_find_mode(sensor, width, height, false);
+	mode = ov5640_find_mode(sensor, rate, width, height, false);
 	return mode ? rate : -EINVAL;
 }
 
@@ -2805,34 +2399,25 @@ static int ov5640_try_fmt_internal(struct v4l2_subdev *sd,
 {
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
 	const struct ov5640_mode_info *mode;
-	const struct ov5640_pixfmt *pixfmt;
-	unsigned int bpp;
+	int i;
 
-	mode = ov5640_find_mode(sensor, fmt->width, fmt->height, true);
+	mode = ov5640_find_mode(sensor, fr, fmt->width, fmt->height, true);
 	if (!mode)
 		return -EINVAL;
-
-	pixfmt = ov5640_code_to_pixfmt(sensor, fmt->code);
-	bpp = pixfmt->bpp;
-
-	/*
-	 * Adjust mode according to bpp:
-	 * - 8bpp modes work for resolution >= 1280x720
-	 * - 24bpp modes work resolution < 1280x720
-	 */
-	if (bpp == 8 && mode->width < 1280)
-		mode = &ov5640_mode_data[OV5640_MODE_720P_1280_720];
-	else if (bpp == 24 && mode->width > 1024)
-		mode = &ov5640_mode_data[OV5640_MODE_XGA_1024_768];
-
-	fmt->width = mode->width;
-	fmt->height = mode->height;
+	fmt->width = mode->hact;
+	fmt->height = mode->vact;
 
 	if (new_mode)
 		*new_mode = mode;
 
-	fmt->code = pixfmt->code;
-	fmt->colorspace = pixfmt->colorspace;
+	for (i = 0; i < ARRAY_SIZE(ov5640_formats); i++)
+		if (ov5640_formats[i].code == fmt->code)
+			break;
+	if (i >= ARRAY_SIZE(ov5640_formats))
+		i = 0;
+
+	fmt->code = ov5640_formats[i].code;
+	fmt->colorspace = ov5640_formats[i].colorspace;
 	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
 	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
 	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
@@ -2840,101 +2425,68 @@ static int ov5640_try_fmt_internal(struct v4l2_subdev *sd,
 	return 0;
 }
 
-static void __v4l2_ctrl_vblank_update(struct ov5640_dev *sensor, u32 vblank)
+static int ov5640_set_link_freq_ctrl(struct ov5640_dev *sensor,
+				     unsigned long rate)
 {
-	const struct ov5640_mode_info *mode = sensor->current_mode;
-
-	__v4l2_ctrl_modify_range(sensor->ctrls.vblank, OV5640_MIN_VBLANK,
-				 OV5640_MAX_VTS - mode->height, 1, vblank);
-
-	__v4l2_ctrl_s_ctrl(sensor->ctrls.vblank, vblank);
-}
+	u8 mipi_div;
+	unsigned int i;
+	unsigned int ret;
+	unsigned long link_freq;
+	unsigned int freq_index;
+	struct i2c_client *client = sensor->i2c_client;
 
-static int ov5640_update_pixel_rate(struct ov5640_dev *sensor)
-{
-	const struct ov5640_mode_info *mode = sensor->current_mode;
-	enum ov5640_pixel_rate_id pixel_rate_id = mode->pixel_rate;
-	struct v4l2_mbus_framefmt *fmt = &sensor->fmt;
-	const struct ov5640_timings *timings = ov5640_timings(sensor, mode);
-	s32 exposure_val, exposure_max;
-	unsigned int hblank;
-	unsigned int i = 0;
-	u32 pixel_rate;
-	s64 link_freq;
-	u32 num_lanes;
-	u32 vblank;
-	u32 bpp;
+	if (sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY)
+		return 0;
 
 	/*
-	 * Update the pixel rate control value.
+	 * - mipi_div - Assumptions not supported by documentation
 	 *
-	 * For DVP mode, maintain the pixel rate calculation using fixed FPS.
+	 *   The MIPI clock generation differs for modes that use the scaler and
+	 *   modes that do not.
 	 */
-	if (!ov5640_is_csi2(sensor)) {
-		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
-					 ov5640_calc_pixel_rate(sensor));
-
-		__v4l2_ctrl_vblank_update(sensor, timings->vblank_def);
-
-		return 0;
-	}
+	if (sensor->current_mode->dn_mode == SCALING)
+		mipi_div = 1;
+	else
+		mipi_div = 2;
 
 	/*
-	 * The MIPI CSI-2 link frequency should comply with the CSI-2
-	 * specification and be lower than 1GHz.
-	 *
-	 * Start from the suggested pixel_rate for the current mode and
-	 * progressively slow it down if it exceeds 1GHz.
+	 * All the formats we support have 16 bits per pixel, seems to require
+	 * the same rate than YUV, so we can just use 16 bpp all the time.
 	 */
-	num_lanes = sensor->ep.bus.mipi_csi2.num_data_lanes;
-	bpp = ov5640_code_to_bpp(sensor, fmt->code);
-	do {
-		pixel_rate = ov5640_pixel_rates[pixel_rate_id];
-		link_freq = pixel_rate * bpp / (2 * num_lanes);
-	} while (link_freq >= 1000000000U &&
-		 ++pixel_rate_id < OV5640_NUM_PIXEL_RATES);
-
-	sensor->current_link_freq = link_freq;
+	rate = rate * 16;
 
 	/*
-	 * Higher link rates require the clock tree to be programmed with
-	 * 'mipi_div' = 1; this has the effect of halving the actual output
-	 * pixel rate in the MIPI domain.
+	 * The 'rate' parameter is the bitrate = VTOT * HTOT * FPS * BPP
 	 *
-	 * Adjust the pixel rate and link frequency control value to report it
-	 * correctly to userspace.
+	 * Adjust it to represent the CSI-2 link frequency and use it to
+	 * update the associated control.
 	 */
-	if (link_freq > OV5640_LINK_RATE_MAX) {
-		pixel_rate /= 2;
-		link_freq /= 2;
-	}
+	link_freq = rate / sensor->ep.bus.mipi_csi2.num_data_lanes /
+		    2 / mipi_div;
 
-	for (i = 0; i < ARRAY_SIZE(ov5640_csi2_link_freqs); ++i) {
-		if (ov5640_csi2_link_freqs[i] == link_freq)
+	freq_index = OV5640_LINK_FREQS_NUM - 1;
+	for (i = 0; i < OV5640_LINK_FREQS_NUM; ++i) {
+		if (ov5640_link_freqs[i] == link_freq) {
+			freq_index = i;
 			break;
+		}
 	}
-	WARN_ON(i == ARRAY_SIZE(ov5640_csi2_link_freqs));
+	WARN_ONCE(i == OV5640_LINK_FREQS_NUM,
+		  "Link frequency %ld not supported", link_freq);
 
-	__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, pixel_rate);
-	__v4l2_ctrl_s_ctrl(sensor->ctrls.link_freq, i);
-
-	hblank = timings->htot - mode->width;
-	__v4l2_ctrl_modify_range(sensor->ctrls.hblank,
-				 hblank, hblank, 1, hblank);
-
-	vblank = timings->vblank_def;
-	__v4l2_ctrl_vblank_update(sensor, vblank);
-
-	exposure_max = timings->crop.height + vblank - 4;
-	exposure_val = clamp_t(s32, sensor->ctrls.exposure->val,
-			       sensor->ctrls.exposure->minimum,
-			       exposure_max);
+	ret = __v4l2_ctrl_s_ctrl(sensor->ctrls.link_freq, freq_index);
+	if (ret < 0)
+		return ret;
 
-	__v4l2_ctrl_modify_range(sensor->ctrls.exposure,
-				 sensor->ctrls.exposure->minimum,
-				 exposure_max, 1, exposure_val);
+	dev_dbg(&client->dev, "link_freq[%d]=%lld selected (%dx%d@%d)(%dx%d)\n",
+		freq_index, ov5640_link_freqs[freq_index],
+		sensor->current_mode->hact,
+		sensor->current_mode->vact,
+		ov5640_framerates[sensor->current_fr],
+		sensor->current_mode->htot,
+		sensor->current_mode->vtot);
 
-	return 0;
+	return ret;
 }
 
 static int ov5640_set_fmt(struct v4l2_subdev *sd,
@@ -2967,7 +2519,6 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 	}
 
 	if (new_mode != sensor->current_mode) {
-		sensor->current_fr = new_mode->def_fps;
 		sensor->current_mode = new_mode;
 		sensor->pending_mode_change = true;
 	}
@@ -2977,70 +2528,86 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 	/* update format even if code is unchanged, resolution might change */
 	sensor->fmt = *mbus_fmt;
 
-	ov5640_update_pixel_rate(sensor);
+	if (sensor->pending_mode_change || sensor->pending_fmt_change) {
+		unsigned long rate = ov5640_calc_pixel_rate(sensor);
 
-out:
-	mutex_unlock(&sensor->lock);
-	return ret;
-}
-
-static int ov5640_get_selection(struct v4l2_subdev *sd,
-				struct v4l2_subdev_state *sd_state,
-				struct v4l2_subdev_selection *sel)
-{
-	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	const struct ov5640_mode_info *mode = sensor->current_mode;
-	const struct ov5640_timings *timings;
-
-	switch (sel->target) {
-	case V4L2_SEL_TGT_CROP: {
-		mutex_lock(&sensor->lock);
-		timings = ov5640_timings(sensor, mode);
-		sel->r = timings->analog_crop;
-		mutex_unlock(&sensor->lock);
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, rate);
 
-		return 0;
+		ret = ov5640_set_link_freq_ctrl(sensor, rate);
 	}
 
-	case V4L2_SEL_TGT_NATIVE_SIZE:
-	case V4L2_SEL_TGT_CROP_BOUNDS:
-		sel->r.top = 0;
-		sel->r.left = 0;
-		sel->r.width = OV5640_NATIVE_WIDTH;
-		sel->r.height = OV5640_NATIVE_HEIGHT;
-
-		return 0;
-
-	case V4L2_SEL_TGT_CROP_DEFAULT:
-		sel->r.top = OV5640_PIXEL_ARRAY_TOP;
-		sel->r.left = OV5640_PIXEL_ARRAY_LEFT;
-		sel->r.width = OV5640_PIXEL_ARRAY_WIDTH;
-		sel->r.height = OV5640_PIXEL_ARRAY_HEIGHT;
-
-		return 0;
-	}
-
-	return -EINVAL;
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
 }
 
 static int ov5640_set_framefmt(struct ov5640_dev *sensor,
 			       struct v4l2_mbus_framefmt *format)
 {
-	bool is_jpeg = format->code == MEDIA_BUS_FMT_JPEG_1X8;
-	const struct ov5640_pixfmt *pixfmt;
 	int ret = 0;
+	bool is_jpeg = false;
+	u8 fmt, mux;
 
-	pixfmt = ov5640_code_to_pixfmt(sensor, format->code);
+	switch (format->code) {
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+		/* YUV422, UYVY */
+		fmt = 0x3f;
+		mux = OV5640_FMT_MUX_YUV422;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_1X16:
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+		/* YUV422, YUYV */
+		fmt = 0x30;
+		mux = OV5640_FMT_MUX_YUV422;
+		break;
+	case MEDIA_BUS_FMT_RGB565_2X8_LE:
+		/* RGB565 {g[2:0],b[4:0]},{r[4:0],g[5:3]} */
+		fmt = 0x6F;
+		mux = OV5640_FMT_MUX_RGB;
+		break;
+	case MEDIA_BUS_FMT_RGB565_2X8_BE:
+		/* RGB565 {r[4:0],g[5:3]},{g[2:0],b[4:0]} */
+		fmt = 0x61;
+		mux = OV5640_FMT_MUX_RGB;
+		break;
+	case MEDIA_BUS_FMT_JPEG_1X8:
+		/* YUV422, YUYV */
+		fmt = 0x30;
+		mux = OV5640_FMT_MUX_YUV422;
+		is_jpeg = true;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		/* Raw, BGBG... / GRGR... */
+		fmt = 0x00;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+		/* Raw bayer, GBGB... / RGRG... */
+		fmt = 0x01;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		/* Raw bayer, GRGR... / BGBG... */
+		fmt = 0x02;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		/* Raw bayer, RGRG... / GBGB... */
+		fmt = 0x03;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	default:
+		return -EINVAL;
+	}
 
 	/* FORMAT CONTROL00: YUV and RGB formatting */
-	ret = ov5640_write_reg(sensor, OV5640_REG_FORMAT_CONTROL00,
-			       pixfmt->ctrl00);
+	ret = ov5640_write_reg(sensor, OV5640_REG_FORMAT_CONTROL00, fmt);
 	if (ret)
 		return ret;
 
 	/* FORMAT MUX CONTROL: ISP YUV or RGB */
-	ret = ov5640_write_reg(sensor, OV5640_REG_ISP_FORMAT_MUX_CTRL,
-			       pixfmt->mux);
+	ret = ov5640_write_reg(sensor, OV5640_REG_ISP_FORMAT_MUX_CTRL, mux);
 	if (ret)
 		return ret;
 
@@ -3297,15 +2864,6 @@ static int ov5640_set_ctrl_vflip(struct ov5640_dev *sensor, int value)
 			      (BIT(2) | BIT(1)) : 0);
 }
 
-static int ov5640_set_ctrl_vblank(struct ov5640_dev *sensor, int value)
-{
-	const struct ov5640_mode_info *mode = sensor->current_mode;
-
-	/* Update the VTOT timing register value. */
-	return ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS,
-				  mode->height + value);
-}
-
 static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
@@ -3314,9 +2872,6 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 
 	/* v4l2_ctrl_lock() locks our own mutex */
 
-	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
-		return 0;
-
 	switch (ctrl->id) {
 	case V4L2_CID_AUTOGAIN:
 		val = ov5640_get_gain(sensor);
@@ -3332,8 +2887,6 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		break;
 	}
 
-	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
-
 	return 0;
 }
 
@@ -3341,31 +2894,16 @@ static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	const struct ov5640_mode_info *mode = sensor->current_mode;
-	const struct ov5640_timings *timings;
-	unsigned int exp_max;
 	int ret;
 
 	/* v4l2_ctrl_lock() locks our own mutex */
 
-	switch (ctrl->id) {
-	case V4L2_CID_VBLANK:
-		/* Update the exposure range to the newly programmed vblank. */
-		timings = ov5640_timings(sensor, mode);
-		exp_max = mode->height + ctrl->val - 4;
-		__v4l2_ctrl_modify_range(sensor->ctrls.exposure,
-					 sensor->ctrls.exposure->minimum,
-					 exp_max, sensor->ctrls.exposure->step,
-					 timings->vblank_def);
-		break;
-	}
-
 	/*
 	 * If the device is not powered up by the host driver do
 	 * not apply any controls to H/W at this time. Instead
-	 * the controls will be restored at start streaming time.
+	 * the controls will be restored right after power-up.
 	 */
-	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+	if (sensor->power_count == 0)
 		return 0;
 
 	switch (ctrl->id) {
@@ -3399,16 +2937,11 @@ static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_VFLIP:
 		ret = ov5640_set_ctrl_vflip(sensor, ctrl->val);
 		break;
-	case V4L2_CID_VBLANK:
-		ret = ov5640_set_ctrl_vblank(sensor, ctrl->val);
-		break;
 	default:
 		ret = -EINVAL;
 		break;
 	}
 
-	pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
-
 	return ret;
 }
 
@@ -3419,14 +2952,10 @@ static const struct v4l2_ctrl_ops ov5640_ctrl_ops = {
 
 static int ov5640_init_controls(struct ov5640_dev *sensor)
 {
-	const struct ov5640_mode_info *mode = sensor->current_mode;
 	const struct v4l2_ctrl_ops *ops = &ov5640_ctrl_ops;
 	struct ov5640_ctrls *ctrls = &sensor->ctrls;
 	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
-	struct v4l2_fwnode_device_properties props;
-	const struct ov5640_timings *timings;
-	unsigned int max_vblank;
-	unsigned int hblank;
+	unsigned long rate;
 	int ret;
 
 	v4l2_ctrl_handler_init(hdl, 32);
@@ -3435,26 +2964,22 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 	hdl->lock = &sensor->lock;
 
 	/* Clock related controls */
+	rate = ov5640_calc_pixel_rate(sensor);
 	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
-			      ov5640_pixel_rates[OV5640_NUM_PIXEL_RATES - 1],
-			      ov5640_pixel_rates[0], 1,
-			      ov5640_pixel_rates[mode->pixel_rate]);
-
-	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops,
-					V4L2_CID_LINK_FREQ,
-					ARRAY_SIZE(ov5640_csi2_link_freqs) - 1,
-					OV5640_DEFAULT_LINK_FREQ,
-					ov5640_csi2_link_freqs);
-
-	timings = ov5640_timings(sensor, mode);
-	hblank = timings->htot - mode->width;
-	ctrls->hblank = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HBLANK, hblank,
-					  hblank, 1, hblank);
-
-	max_vblank = OV5640_MAX_VTS - mode->height;
-	ctrls->vblank = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VBLANK,
-					  OV5640_MIN_VBLANK, max_vblank,
-					  1, timings->vblank_def);
+					      0, INT_MAX, 1,
+					      rate);
+
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,
+						  OV5640_LINK_FREQS_NUM - 1,
+						  0, ov5640_link_freqs);
+	if (ctrls->link_freq)
+		ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	mutex_lock(&sensor->lock);
+	ret = ov5640_set_link_freq_ctrl(sensor, rate);
+	mutex_unlock(&sensor->lock);
+	if (ret)
+		goto free_ctrls;
 
 	/* Auto/manual white balance */
 	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
@@ -3474,7 +2999,7 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 	/* Auto/manual gain */
 	ctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,
 					     0, 1, 1, 1);
-	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,
+	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
 					0, 1023, 1, 0);
 
 	ctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,
@@ -3503,20 +3028,7 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 		goto free_ctrls;
 	}
 
-	ret = v4l2_fwnode_device_parse(&sensor->i2c_client->dev, &props);
-	if (ret)
-		goto free_ctrls;
-
-	if (props.rotation == 180)
-		sensor->upside_down = true;
-
-	ret = v4l2_ctrl_new_fwnode_properties(hdl, ops, &props);
-	if (ret)
-		goto free_ctrls;
-
 	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
-	ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
-	ctrls->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 	ctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
 	ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
 
@@ -3536,29 +3048,16 @@ static int ov5640_enum_frame_size(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_state *sd_state,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
-	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	u32 bpp = ov5640_code_to_bpp(sensor, fse->code);
-	unsigned int index = fse->index;
-
 	if (fse->pad != 0)
 		return -EINVAL;
-	if (!bpp)
-		return -EINVAL;
-
-	/* Only low-resolution modes are supported for 24bpp formats. */
-	if (bpp == 24 && index >= OV5640_MODE_720P_1280_720)
-		return -EINVAL;
-
-	/* FIXME: Low resolution modes don't work in 8bpp formats. */
-	if (bpp == 8)
-		index += OV5640_MODE_720P_1280_720;
-
-	if (index >= OV5640_NUM_MODES)
+	if (fse->index >= OV5640_NUM_MODES)
 		return -EINVAL;
 
-	fse->min_width = ov5640_mode_data[index].width;
+	fse->min_width =
+		ov5640_mode_data[fse->index].hact;
 	fse->max_width = fse->min_width;
-	fse->min_height = ov5640_mode_data[index].height;
+	fse->min_height =
+		ov5640_mode_data[fse->index].vact;
 	fse->max_height = fse->min_height;
 
 	return 0;
@@ -3622,33 +3121,32 @@ static int ov5640_s_frame_interval(struct v4l2_subdev *sd,
 	mode = sensor->current_mode;
 
 	frame_rate = ov5640_try_frame_interval(sensor, &fi->interval,
-					       mode->width,
-					       mode->height);
+					       mode->hact, mode->vact);
 	if (frame_rate < 0) {
 		/* Always return a valid frame interval value */
 		fi->interval = sensor->frame_interval;
 		goto out;
 	}
 
-	mode = ov5640_find_mode(sensor, mode->width, mode->height, true);
+	mode = ov5640_find_mode(sensor, frame_rate, mode->hact,
+				mode->vact, true);
 	if (!mode) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	if (ov5640_framerates[frame_rate] > ov5640_framerates[mode->max_fps]) {
-		ret = -EINVAL;
-		goto out;
-	}
-
 	if (mode != sensor->current_mode ||
 	    frame_rate != sensor->current_fr) {
+		unsigned long rate;
+
 		sensor->current_fr = frame_rate;
 		sensor->frame_interval = fi->interval;
 		sensor->current_mode = mode;
 		sensor->pending_mode_change = true;
 
-		ov5640_update_pixel_rate(sensor);
+		rate = ov5640_calc_pixel_rate(sensor);
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, rate);
+		ret = ov5640_set_link_freq_ctrl(sensor, rate);
 	}
 out:
 	mutex_unlock(&sensor->lock);
@@ -3659,23 +3157,12 @@ static int ov5640_enum_mbus_code(struct v4l2_subdev *sd,
 				 struct v4l2_subdev_state *sd_state,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
-	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	const struct ov5640_pixfmt *formats;
-	unsigned int num_formats;
-
-	if (ov5640_is_csi2(sensor)) {
-		formats = ov5640_csi2_formats;
-		num_formats = ARRAY_SIZE(ov5640_csi2_formats) - 1;
-	} else {
-		formats = ov5640_dvp_formats;
-		num_formats = ARRAY_SIZE(ov5640_dvp_formats) - 1;
-	}
-
-	if (code->index >= num_formats)
+	if (code->pad != 0)
+		return -EINVAL;
+	if (code->index >= ARRAY_SIZE(ov5640_formats))
 		return -EINVAL;
 
-	code->code = formats[code->index].code;
-
+	code->code = ov5640_formats[code->index].code;
 	return 0;
 }
 
@@ -3684,18 +3171,6 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
 	int ret = 0;
 
-	if (enable) {
-		ret = pm_runtime_resume_and_get(&sensor->i2c_client->dev);
-		if (ret < 0)
-			return ret;
-
-		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
-		if (ret) {
-			pm_runtime_put(&sensor->i2c_client->dev);
-			return ret;
-		}
-	}
-
 	mutex_lock(&sensor->lock);
 
 	if (sensor->streaming == !enable) {
@@ -3712,7 +3187,7 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 			sensor->pending_fmt_change = false;
 		}
 
-		if (ov5640_is_csi2(sensor))
+		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
 			ret = ov5640_set_stream_mipi(sensor, enable);
 		else
 			ret = ov5640_set_stream_dvp(sensor, enable);
@@ -3720,34 +3195,13 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 		if (!ret)
 			sensor->streaming = enable;
 	}
-
 out:
 	mutex_unlock(&sensor->lock);
-
-	if (!enable || ret)
-		pm_runtime_put_autosuspend(&sensor->i2c_client->dev);
-
 	return ret;
 }
 
-static int ov5640_init_cfg(struct v4l2_subdev *sd,
-			   struct v4l2_subdev_state *state)
-{
-	struct v4l2_mbus_framefmt *fmt =
-				v4l2_subdev_get_try_format(sd, state, 0);
-	struct v4l2_rect *crop = v4l2_subdev_get_try_crop(sd, state, 0);
-
-	*fmt = ov5640_default_fmt;
-
-	crop->left = OV5640_PIXEL_ARRAY_LEFT;
-	crop->top = OV5640_PIXEL_ARRAY_TOP;
-	crop->width = OV5640_PIXEL_ARRAY_WIDTH;
-	crop->height = OV5640_PIXEL_ARRAY_HEIGHT;
-
-	return 0;
-}
-
 static const struct v4l2_subdev_core_ops ov5640_core_ops = {
+	.s_power = ov5640_s_power,
 	.log_status = v4l2_ctrl_subdev_log_status,
 	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
 	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
@@ -3760,11 +3214,9 @@ static const struct v4l2_subdev_video_ops ov5640_video_ops = {
 };
 
 static const struct v4l2_subdev_pad_ops ov5640_pad_ops = {
-	.init_cfg = ov5640_init_cfg,
 	.enum_mbus_code = ov5640_enum_mbus_code,
 	.get_fmt = ov5640_get_fmt,
 	.set_fmt = ov5640_set_fmt,
-	.get_selection = ov5640_get_selection,
 	.enum_frame_size = ov5640_enum_frame_size,
 	.enum_frame_interval = ov5640_enum_frame_interval,
 };
@@ -3793,20 +3245,26 @@ static int ov5640_check_chip_id(struct ov5640_dev *sensor)
 	int ret = 0;
 	u16 chip_id;
 
+	ret = ov5640_set_power_on(sensor);
+	if (ret)
+		return ret;
+
 	ret = ov5640_read_reg16(sensor, OV5640_REG_CHIP_ID, &chip_id);
 	if (ret) {
 		dev_err(&client->dev, "%s: failed to read chip identifier\n",
 			__func__);
-		return ret;
+		goto power_off;
 	}
 
 	if (chip_id != 0x5640) {
 		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x5640, got 0x%x\n",
 			__func__, chip_id);
-		return -ENXIO;
+		ret = -ENXIO;
 	}
 
-	return 0;
+power_off:
+	ov5640_set_power_off(sensor);
+	return ret;
 }
 
 static int ov5640_probe(struct i2c_client *client)
@@ -3814,6 +3272,8 @@ static int ov5640_probe(struct i2c_client *client)
 	struct device *dev = &client->dev;
 	struct fwnode_handle *endpoint;
 	struct ov5640_dev *sensor;
+	struct v4l2_mbus_framefmt *fmt;
+	u32 rotation;
 	int ret;
 
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
@@ -3826,18 +3286,35 @@ static int ov5640_probe(struct i2c_client *client)
 	 * default init sequence initialize sensor to
 	 * YUV422 UYVY VGA@30fps
 	 */
-	sensor->fmt = ov5640_default_fmt;
+	fmt = &sensor->fmt;
+	fmt->code = MEDIA_BUS_FMT_UYVY8_2X8;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->field = V4L2_FIELD_NONE;
 	sensor->frame_interval.numerator = 1;
 	sensor->frame_interval.denominator = ov5640_framerates[OV5640_30_FPS];
 	sensor->current_fr = OV5640_30_FPS;
-	sensor->current_mode =
-		&ov5640_mode_data[OV5640_MODE_VGA_640_480];
-	sensor->last_mode = sensor->current_mode;
-	sensor->current_link_freq =
-		ov5640_csi2_link_freqs[OV5640_DEFAULT_LINK_FREQ];
 
 	sensor->ae_target = 52;
 
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+				       &rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			sensor->upside_down = true;
+			fallthrough;
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				 rotation);
+		}
+	}
+
 	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
 						  NULL);
 	if (!endpoint) {
@@ -3859,6 +3336,20 @@ static int ov5640_probe(struct i2c_client *client)
 		return -EINVAL;
 	}
 
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		ov5640_mode_data = ov5640_mode_data_csi2;
+		ov5640_mode_init_data = &ov5640_mode_init_data_csi2;
+	} else {
+		ov5640_mode_data = ov5640_mode_data_dvp;
+		ov5640_mode_init_data = &ov5640_mode_init_data_dvp;
+	}
+
+	fmt->width = ov5640_mode_data[OV5640_DEFAULT_MODE].hact;
+	fmt->height = ov5640_mode_data[OV5640_DEFAULT_MODE].vact;
+	sensor->current_mode =
+		&ov5640_mode_data[OV5640_DEFAULT_MODE];
+	sensor->last_mode = sensor->current_mode;
+
 	/* get system clock (xclk) */
 	sensor->xclk = devm_clk_get(dev, "xclk");
 	if (IS_ERR(sensor->xclk)) {
@@ -3898,42 +3389,24 @@ static int ov5640_probe(struct i2c_client *client)
 
 	ret = ov5640_get_regulators(sensor);
 	if (ret)
-		goto entity_cleanup;
+		return ret;
 
 	mutex_init(&sensor->lock);
 
-	ret = ov5640_init_controls(sensor);
+	ret = ov5640_check_chip_id(sensor);
 	if (ret)
 		goto entity_cleanup;
 
-	ret = ov5640_sensor_resume(dev);
-	if (ret) {
-		dev_err(dev, "failed to power on\n");
-		goto free_ctrls;
-	}
-
-	pm_runtime_set_active(dev);
-	pm_runtime_get_noresume(dev);
-	pm_runtime_enable(dev);
-
-	ret = ov5640_check_chip_id(sensor);
+	ret = ov5640_init_controls(sensor);
 	if (ret)
-		goto err_pm_runtime;
+		goto entity_cleanup;
 
 	ret = v4l2_async_register_subdev_sensor(&sensor->sd);
 	if (ret)
-		goto err_pm_runtime;
-
-	pm_runtime_set_autosuspend_delay(dev, 1000);
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_put_autosuspend(dev);
+		goto free_ctrls;
 
 	return 0;
 
-err_pm_runtime:
-	pm_runtime_put_noidle(dev);
-	pm_runtime_disable(dev);
-	ov5640_sensor_suspend(dev);
 free_ctrls:
 	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
 entity_cleanup:
@@ -3946,12 +3419,6 @@ static void ov5640_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
-	struct device *dev = &client->dev;
-
-	pm_runtime_disable(dev);
-	if (!pm_runtime_status_suspended(dev))
-		ov5640_sensor_suspend(dev);
-	pm_runtime_set_suspended(dev);
 
 	v4l2_async_unregister_subdev(&sensor->sd);
 	media_entity_cleanup(&sensor->sd.entity);
@@ -3959,10 +3426,6 @@ static void ov5640_remove(struct i2c_client *client)
 	mutex_destroy(&sensor->lock);
 }
 
-static const struct dev_pm_ops ov5640_pm_ops = {
-	SET_RUNTIME_PM_OPS(ov5640_sensor_suspend, ov5640_sensor_resume, NULL)
-};
-
 static const struct i2c_device_id ov5640_id[] = {
 	{"ov5640", 0},
 	{},
@@ -3979,7 +3442,6 @@ static struct i2c_driver ov5640_i2c_driver = {
 	.driver = {
 		.name  = "ov5640",
 		.of_match_table	= ov5640_dt_ids,
-		.pm = &ov5640_pm_ops,
 	},
 	.id_table = ov5640_id,
 	.probe_new = ov5640_probe,
diff --git a/drivers/media/platform/st/stm32/Kconfig b/drivers/media/platform/st/stm32/Kconfig
index b22dd4753..3a67d0ed6 100644
--- a/drivers/media/platform/st/stm32/Kconfig
+++ b/drivers/media/platform/st/stm32/Kconfig
@@ -1,6 +1,19 @@
 # SPDX-License-Identifier: GPL-2.0-only
 
 # V4L drivers
+config VIDEO_STM32_CSI2HOST
+	tristate "STM32 Camera Serial Interface (CSI) support"
+	depends on VIDEO_DEV && OF
+	depends on ARCH_STM32 || COMPILE_TEST
+	select MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This module makes the STM32 Camera Serial Interface (CSI)
+	  available as a v4l2 device.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called stm32-csi2host.
+
 config VIDEO_STM32_DCMI
 	tristate "STM32 Digital Camera Memory Interface (DCMI) support"
 	depends on V4L_PLATFORM_DRIVERS
@@ -16,6 +29,20 @@ config VIDEO_STM32_DCMI
 	  To compile this driver as a module, choose M here: the module
 	  will be called stm32-dcmi.
 
+config VIDEO_STM32_DCMIPP
+	tristate "STM32 Digital Camera Memory Interface Pixel Processor (DCMIPP) support"
+	depends on VIDEO_DEV && OF && MEDIA_CONTROLLER
+	depends on ARCH_STM32 || COMPILE_TEST
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_VMALLOC
+	select V4L2_FWNODE
+	help
+	  This module makes the STM32 Digital Camera Memory Interface
+	  Pixel Processor (DCMIPP) available as a v4l2 device.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called stm32-dcmipp.
+
 # Mem2mem drivers
 config VIDEO_STM32_DMA2D
 	tristate "STM32 Chrom-Art Accelerator (DMA2D)"
diff --git a/drivers/media/platform/st/stm32/Makefile b/drivers/media/platform/st/stm32/Makefile
index 896ef98a7..80fdeb5c1 100644
--- a/drivers/media/platform/st/stm32/Makefile
+++ b/drivers/media/platform/st/stm32/Makefile
@@ -1,4 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_VIDEO_STM32_CSI2HOST) += stm32-csi2host.o
 obj-$(CONFIG_VIDEO_STM32_DCMI) += stm32-dcmi.o
+obj-$(CONFIG_VIDEO_STM32_DCMIPP) += stm32-dcmipp/
 stm32-dma2d-objs := dma2d/dma2d.o dma2d/dma2d-hw.o
 obj-$(CONFIG_VIDEO_STM32_DMA2D) += stm32-dma2d.o
diff --git a/drivers/media/platform/st/stm32/stm32-csi2host.c b/drivers/media/platform/st/stm32/stm32-csi2host.c
new file mode 100644
index 000000000..bb8b6ad48
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-csi2host.c
@@ -0,0 +1,1220 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for STM32 Camera Serial Interface
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Alain Volmat <alain.volmat@foss.st.com>
+ *
+ * This driver is based on cdns-csi2rx.c
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+#include <media/mipi-csi2.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+/* Uncomment the following define to show catch all CSI2HOST errors */
+/* #define CSI2HOST_ERROR_HANDLING */
+
+#define CSI_CR					0x0000
+#define CSI_CR_CSIEN				BIT(0)
+#define CSI_CR_VCxSTART(x)			BIT(2 + ((x) * 4))
+#define CSI_CR_VCxSTOP(x)			BIT(3 + ((x) * 4))
+#define CSI_PCR					0x0004
+#define CSI_PCR_DL1EN				BIT(3)
+#define CSI_PCR_DL0EN				BIT(2)
+#define CSI_PCR_CLEN				BIT(1)
+#define CSI_PCR_PWRDOWN				BIT(0)
+#define CSI_VCxCFGR1(x)				((((x) + 1) * 0x0010) + 0x0)
+#define CSI_VCxCFGR1_ALLDT			BIT(0)
+#define CSI_VCxCFGR1_DT0EN			BIT(1)
+#define CSI_VCxCFGR1_DT1EN			BIT(2)
+#define CSI_VCxCFGR1_CDTFT_SHIFT		8
+#define CSI_VCxCFGR1_DT0_SHIFT			16
+#define CSI_VCxCFGR1_DT0FT_SHIFT		24
+#define CSI_VCxCFGR2(x)				((((x) + 1) * 0x0010) + 0x4)
+#define CSI_VCxCFGR2_DT1_SHIFT			0
+#define CSI_VCxCFGR2_DT1FT_SHIFT		8
+#define CSI_VCxCFGRx_DTxFT_BPP8			2
+#define CSI_VCxCFGRx_DTxFT_BPP10		3
+#define CSI_VCxCFGRx_DTxFT_BPP12		4
+#define CSI_VCxCFGRx_DTxFT_BPP14		5
+#define CSI_LMCFGR				0x0070
+#define CSI_LMCFGR_LANENB_SHIFT			8
+#define CSI_LMCFGR_LANENB_MASK			GENMASK(10, 8)
+#define CSI_LMCFGR_DL0MAP_SHIFT			16
+#define CSI_LMCFGR_DL0MAP_MASK			GENMASK(18, 16)
+#define CSI_LMCFGR_DL1MAP_SHIFT			20
+#define CSI_LMCFGR_DL1MAP_MASK			GENMASK(22, 20)
+#define CSI_WDR					0x0078
+#define CSI_IER0				0x0080
+#define CSI_IER1				0x0084
+#define CSI_SR0					0x0090
+#define CSI_SR0_SYNCERRF			BIT(30)
+#define CSI_SR0_SPKTERRF			BIT(28)
+#define CSI_SR0_IDERRF				BIT(27)
+#define CSI_SR0_CECCERRF			BIT(26)
+#define CSI_SR0_ECCERRF				BIT(25)
+#define CSI_SR0_CRCERRF				BIT(24)
+#define CSI_SR0_CCFIFOFF			BIT(21)
+#define CSI_SR0_VCxSTATEF(x)			BIT(17 + (x))
+#define CSI_SR0_EOF3F				BIT(15)
+#define CSI_SR0_EOF2F				BIT(14)
+#define CSI_SR0_EOF1F				BIT(13)
+#define CSI_SR0_EOF0F				BIT(12)
+#define CSI_SR0_SOF3F				BIT(11)
+#define CSI_SR0_SOF2F				BIT(10)
+#define CSI_SR0_SOF1F				BIT(9)
+#define CSI_SR0_SOF0F				BIT(8)
+#define CSI_SR1					0x0094
+#define CSI_SR1_STOPCLF				BIT(28)
+#define CSI_SR1_STOPDL1F			BIT(25)
+#define CSI_SR1_STOPDL0F			BIT(19)
+#define CSI_SR1_ECTRLDL1F			BIT(12)
+#define CSI_SR1_ESYNCESCDL1F			BIT(11)
+#define CSI_SR1_EESCDL1F			BIT(10)
+#define CSI_SR1_ESOTSYNCDL1F			BIT(9)
+#define CSI_SR1_ESOTDL1F			BIT(8)
+#define CSI_SR1_ECTRLDL0F			BIT(4)
+#define CSI_SR1_ESYNCESCDL0F			BIT(3)
+#define CSI_SR1_EESCDL0F			BIT(2)
+#define CSI_SR1_ESOTSYNCDL0F			BIT(1)
+#define CSI_SR1_ESOTDL0F			BIT(0)
+#define CSI_FCR0				0x0100
+#define CSI_FCR1				0x0104
+#define CSI_SPDFR				0x0110
+#define DT_MASK	0x3f
+#define VC_MASK	0x03
+#define CSI_ERR1				0x0114
+#define CSI_ERR1_IDVCERR_SHIFT			22
+#define CSI_ERR1_IDDTERR_SHIFT			16
+#define CSI_ERR1_CECCVCERR_SHIFT		14
+#define CSI_ERR1_CECCDTERR_SHIFT		8
+#define CSI_ERR1_CRCVCERR_SHIFT			6
+#define CSI_ERR1_CRCDTERR_SHIFT			0
+#define CSI_ERR2				0x0118
+#define CSI_ERR2_SYNCVCERR_SHIFT		18
+#define CSI_ERR2_SPKTVCERR_SHIFT		6
+#define CSI_ERR2_SPKTDTERR_SHIFT		0
+#define CSI_PRCR				0x1000
+#define CSI_PRCR_PEN				BIT(1)
+#define CSI_PMCR				0x1004
+#define CSI_PFCR				0x1008
+#define CSI_PFCR_CCFR_MASK			GENMASK(5, 0)
+#define CSI_PFCR_CCFR_SHIFT			0
+#define CSI_PFCR_HSFR_MASK			GENMASK(14, 8)
+#define CSI_PFCR_HSFR_SHIFT			8
+#define CSI_PFCR_DLD				BIT(16)
+#define CSI_PTCR0				0x1010
+#define CSI_PTCR0_TCKEN				BIT(0)
+#define CSI_PTCR1				0x1014
+#define CSI_PTCR1_TWM				BIT(16)
+#define CSI_PTCR1_TDI_MASK			GENMASK(7, 0)
+#define CSI_PTCR1_TDI_SHIFT			0
+#define CSI_PTSR				0x1018
+#define CSI_HWCFGR				0x1ff0
+#define CSI_HWCFGR_LANES_MASK			GENMASK(7, 4)
+#define CSI_HWCFGR_LANES_SHIFT			4
+
+#define CSI2HOST_LANES_MAX	2
+
+#define CSI_SR0_ERRORS	(CSI_SR0_SYNCERRF | CSI_SR0_SPKTERRF | CSI_SR0_IDERRF |\
+			 CSI_SR0_CECCERRF | CSI_SR0_ECCERRF | CSI_SR0_CRCERRF |\
+			 CSI_SR0_CCFIFOFF)
+#define CSI_SR1_DL0_ERRORS	(CSI_SR1_ECTRLDL0F | CSI_SR1_ESYNCESCDL0F |\
+				 CSI_SR1_EESCDL0F | CSI_SR1_ESOTSYNCDL0F |\
+				 CSI_SR1_ESOTDL0F)
+#define CSI_SR1_DL1_ERRORS	(CSI_SR1_ECTRLDL1F | CSI_SR1_ESYNCESCDL1F |\
+				 CSI_SR1_EESCDL1F | CSI_SR1_ESOTSYNCDL1F |\
+				 CSI_SR1_ESOTDL1F)
+#define CSI_SR1_ERRORS	(CSI_SR1_DL0_ERRORS | CSI_SR1_DL1_ERRORS)
+
+enum csi2host_pads {
+	CSI2HOST_PAD_SINK,
+	CSI2HOST_PAD_SOURCE_STREAM0,
+	CSI2HOST_PAD_SOURCE_STREAM1,
+	CSI2HOST_PAD_SOURCE_STREAM2,
+	CSI2HOST_PAD_SOURCE_STREAM3,
+	CSI2HOST_PAD_SOURCE_STREAM4,
+	CSI2HOST_PAD_SOURCE_STREAM5,
+	CSI2HOST_PAD_SOURCE_STREAM6,
+	CSI2HOST_PAD_SOURCE_STREAM7,
+	CSI2HOST_PAD_MAX,
+};
+
+struct csi2host_priv {
+	struct device			*dev;
+	unsigned int			count;
+
+	/*
+	 * Used to prevent race conditions between multiple,
+	 * concurrent calls to start and stop.
+	 */
+	struct mutex			lock;
+
+	void __iomem			*base;
+	struct clk			*pclk;
+	struct clk			*txesc;
+	struct clk			*csi2phy;
+	struct regulator_bulk_data	supplies[2];
+	struct reset_control		*rstc;
+
+	u8				lanes[CSI2HOST_LANES_MAX];
+	u8				num_lanes;
+	u8				max_lanes;
+
+	struct v4l2_subdev		subdev;
+	struct v4l2_async_notifier	notifier;
+	struct media_pad		pads[CSI2HOST_PAD_MAX];
+
+	struct v4l2_mbus_framefmt	mf[CSI2HOST_PAD_MAX];
+
+	/* Remote source */
+	struct v4l2_subdev		*source_subdev;
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	/* Backup registers used within irq handlers */
+	u32 sr0;
+	u32 sr1;
+	u32 err1;
+	u32 err2;
+#endif
+};
+
+struct csi2host_fmts {
+	u32 code;
+	unsigned int datatype;
+	unsigned int datatype_fmt;
+	unsigned int bpp;
+};
+
+#define FMT_MBUS_DT_DTFMT_BPP(mbus, dt, dtfmt, byteperpixel)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.datatype = MIPI_CSI2_DT_##dt,		\
+			.datatype_fmt = CSI_VCxCFGRx_DTxFT_##dtfmt,	\
+			.bpp = byteperpixel,	\
+		}
+static const struct csi2host_fmts csi2host_formats[] = {
+	/* YUV 422 8 bit */
+	FMT_MBUS_DT_DTFMT_BPP(UYVY8_2X8, YUV422_8B, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(YUYV8_2X8, YUV422_8B, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(YVYU8_2X8, YUV422_8B, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(VYUY8_2X8, YUV422_8B, BPP8, 8),
+
+	/* Raw Bayer */
+	/* 8 bit */
+	FMT_MBUS_DT_DTFMT_BPP(SBGGR8_1X8, RAW8, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(SGBRG8_1X8, RAW8, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(SGRBG8_1X8, RAW8, BPP8, 8),
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB8_1X8, RAW8, BPP8, 8),
+	/* 10 bit */
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB10_1X10, RAW10, BPP10, 10),
+	FMT_MBUS_DT_DTFMT_BPP(SGBRG10_1X10, RAW10, BPP10, 10),
+	FMT_MBUS_DT_DTFMT_BPP(SGRBG10_1X10, RAW10, BPP10, 10),
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB10_1X10, RAW10, BPP10, 10),
+	/* 12 bit */
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB12_1X12, RAW12, BPP12, 12),
+	FMT_MBUS_DT_DTFMT_BPP(SGBRG12_1X12, RAW12, BPP12, 12),
+	FMT_MBUS_DT_DTFMT_BPP(SGRBG12_1X12, RAW12, BPP12, 12),
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB12_1X12, RAW12, BPP12, 12),
+	/* 14 bit */
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB14_1X14, RAW14, BPP14, 14),
+	FMT_MBUS_DT_DTFMT_BPP(SGBRG14_1X14, RAW14, BPP14, 14),
+	FMT_MBUS_DT_DTFMT_BPP(SGRBG14_1X14, RAW14, BPP14, 14),
+	FMT_MBUS_DT_DTFMT_BPP(SRGGB14_1X14, RAW14, BPP14, 14),
+
+	/* RGB 565 */
+	FMT_MBUS_DT_DTFMT_BPP(RGB565_2X8_LE, RGB565, BPP8, 8),
+
+	/* JPEG (datatype isn't used) */
+	FMT_MBUS_DT_DTFMT_BPP(JPEG_1X8, NULL, BPP8, 8),
+};
+
+struct csi2host_mbps_phy_reg {
+	unsigned int mbps;
+	unsigned int hsfreqrange;
+	unsigned int osc_freq_target;
+};
+
+/*
+ * Table describing configuration of the PHY depending on the
+ * intended Bit Rate. From table 5-8 Frequency Ranges and Defaults
+ * of the Synopsis DWC MIPI PHY databook
+ */
+/* FIXME - this table should be configurable and depend on the compatible */
+static const struct csi2host_mbps_phy_reg snps_stm32mp257[] = {
+	{ .mbps =   80,	.hsfreqrange = 0x00,	.osc_freq_target = 460 },
+	{ .mbps =   90, .hsfreqrange = 0x10,	.osc_freq_target = 460 },
+	{ .mbps =  100, .hsfreqrange = 0x20,	.osc_freq_target = 460 },
+	{ .mbps =  110, .hsfreqrange = 0x30,	.osc_freq_target = 460 },
+	{ .mbps =  120, .hsfreqrange = 0x01,	.osc_freq_target = 460 },
+	{ .mbps =  130, .hsfreqrange = 0x11,	.osc_freq_target = 460 },
+	{ .mbps =  140, .hsfreqrange = 0x21,	.osc_freq_target = 460 },
+	{ .mbps =  150, .hsfreqrange = 0x31,	.osc_freq_target = 460 },
+	{ .mbps =  160, .hsfreqrange = 0x02,	.osc_freq_target = 460 },
+	{ .mbps =  170, .hsfreqrange = 0x12,	.osc_freq_target = 460 },
+	{ .mbps =  180, .hsfreqrange = 0x22,	.osc_freq_target = 460 },
+	{ .mbps =  190, .hsfreqrange = 0x32,	.osc_freq_target = 460 },
+	{ .mbps =  205, .hsfreqrange = 0x03,	.osc_freq_target = 460 },
+	{ .mbps =  220, .hsfreqrange = 0x13,	.osc_freq_target = 460 },
+	{ .mbps =  235, .hsfreqrange = 0x23,	.osc_freq_target = 460 },
+	{ .mbps =  250, .hsfreqrange = 0x33,	.osc_freq_target = 460 },
+	{ .mbps =  275, .hsfreqrange = 0x04,	.osc_freq_target = 460 },
+	{ .mbps =  300, .hsfreqrange = 0x14,	.osc_freq_target = 460 },
+	{ .mbps =  325, .hsfreqrange = 0x25,	.osc_freq_target = 460 },
+	{ .mbps =  350, .hsfreqrange = 0x35,	.osc_freq_target = 460 },
+	{ .mbps =  400, .hsfreqrange = 0x05,	.osc_freq_target = 460 },
+	{ .mbps =  450, .hsfreqrange = 0x16,	.osc_freq_target = 460 },
+	{ .mbps =  500, .hsfreqrange = 0x26,	.osc_freq_target = 460 },
+	{ .mbps =  550, .hsfreqrange = 0x37,	.osc_freq_target = 460 },
+	{ .mbps =  600, .hsfreqrange = 0x07,	.osc_freq_target = 460 },
+	{ .mbps =  650, .hsfreqrange = 0x18,	.osc_freq_target = 460 },
+	{ .mbps =  700, .hsfreqrange = 0x28,	.osc_freq_target = 460 },
+	{ .mbps =  750, .hsfreqrange = 0x39,	.osc_freq_target = 460 },
+	{ .mbps =  800, .hsfreqrange = 0x09,	.osc_freq_target = 460 },
+	{ .mbps =  850, .hsfreqrange = 0x19,	.osc_freq_target = 460 },
+	{ .mbps =  900, .hsfreqrange = 0x29,	.osc_freq_target = 460 },
+	{ .mbps =  950, .hsfreqrange = 0x3a,	.osc_freq_target = 460 },
+	{ .mbps = 1000, .hsfreqrange = 0x0a,	.osc_freq_target = 460 },
+	{ .mbps = 1050, .hsfreqrange = 0x1a,	.osc_freq_target = 460 },
+	{ .mbps = 1100, .hsfreqrange = 0x2a,	.osc_freq_target = 460 },
+	{ .mbps = 1150, .hsfreqrange = 0x3b,	.osc_freq_target = 460 },
+	{ .mbps = 1200, .hsfreqrange = 0x0b,	.osc_freq_target = 460 },
+	{ .mbps = 1250, .hsfreqrange = 0x1b,	.osc_freq_target = 460 },
+	{ .mbps = 1300, .hsfreqrange = 0x2b,	.osc_freq_target = 460 },
+	{ .mbps = 1350, .hsfreqrange = 0x3c,	.osc_freq_target = 460 },
+	{ .mbps = 1400, .hsfreqrange = 0x0c,	.osc_freq_target = 460 },
+	{ .mbps = 1450, .hsfreqrange = 0x1c,	.osc_freq_target = 460 },
+	{ .mbps = 1500, .hsfreqrange = 0x2c,	.osc_freq_target = 460 },
+	{ .mbps = 1550, .hsfreqrange = 0x3d,	.osc_freq_target = 285 },
+	{ .mbps = 1600, .hsfreqrange = 0x0d,	.osc_freq_target = 295 },
+	{ .mbps = 1650, .hsfreqrange = 0x1d,	.osc_freq_target = 304 },
+	{ .mbps = 1700, .hsfreqrange = 0x2e,	.osc_freq_target = 313 },
+	{ .mbps = 1750, .hsfreqrange = 0x3e,	.osc_freq_target = 322 },
+	{ .mbps = 1800, .hsfreqrange = 0x0e,	.osc_freq_target = 331 },
+	{ .mbps = 1850, .hsfreqrange = 0x1e,	.osc_freq_target = 341 },
+	{ .mbps = 1900, .hsfreqrange = 0x2f,	.osc_freq_target = 350 },
+	{ .mbps = 1950, .hsfreqrange = 0x3f,	.osc_freq_target = 359 },
+	{ .mbps = 2000, .hsfreqrange = 0x0f,	.osc_freq_target = 368 },
+	{ .mbps = 2050, .hsfreqrange = 0x40,	.osc_freq_target = 377 },
+	{ .mbps = 2100, .hsfreqrange = 0x41,	.osc_freq_target = 387 },
+	{ .mbps = 2150, .hsfreqrange = 0x42,	.osc_freq_target = 396 },
+	{ .mbps = 2200, .hsfreqrange = 0x43,	.osc_freq_target = 405 },
+	{ .mbps = 2250, .hsfreqrange = 0x44,	.osc_freq_target = 414 },
+	{ .mbps = 2300, .hsfreqrange = 0x45,	.osc_freq_target = 423 },
+	{ .mbps = 2350, .hsfreqrange = 0x46,	.osc_freq_target = 432 },
+	{ .mbps = 2400, .hsfreqrange = 0x47,	.osc_freq_target = 442 },
+	{ .mbps = 2450, .hsfreqrange = 0x48,	.osc_freq_target = 451 },
+	{ .mbps = 2500, .hsfreqrange = 0x49,	.osc_freq_target = 460 },
+	{ /* sentinel */ },
+};
+
+static const struct csi2host_fmts *csi2host_code_to_fmt(unsigned int code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(csi2host_formats); i++)
+		if (csi2host_formats[i].code == code)
+			return &csi2host_formats[i];
+
+	return NULL;
+}
+
+static inline
+struct csi2host_priv *v4l2_subdev_to_csi2priv(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct csi2host_priv, subdev);
+}
+
+static int csi2host_setup_lane_merger(struct csi2host_priv *csi2priv)
+{
+	int i;
+	u32 lmcfgr;
+
+	lmcfgr = readl_relaxed(csi2priv->base + CSI_LMCFGR);
+	lmcfgr &= ~(CSI_LMCFGR_LANENB_MASK | CSI_LMCFGR_DL0MAP_MASK |
+		    CSI_LMCFGR_DL1MAP_MASK);
+
+	for (i = 0; i < csi2priv->num_lanes; i++) {
+		/* Check that lane ID is < max number of lane */
+		if (csi2priv->lanes[i] >= csi2priv->max_lanes) {
+			dev_err(csi2priv->dev, "Invalid lane id (%d)\n",
+				csi2priv->lanes[i]);
+			return -EINVAL;
+		}
+		lmcfgr |= ((csi2priv->lanes[i] + 1) << ((i * 4) +
+			   CSI_LMCFGR_DL0MAP_SHIFT));
+	}
+
+	lmcfgr |= (csi2priv->num_lanes << CSI_LMCFGR_LANENB_SHIFT);
+
+	writel_relaxed(lmcfgr, csi2priv->base + CSI_LMCFGR);
+
+	return 0;
+}
+
+static void csi2host_phy_reg_write(struct csi2host_priv *csi2priv, uint32_t addr, uint32_t val)
+{
+	/* Based on sequence described at section 5.2.3.2 of DesignWave document */
+	/* For writing the 4-bit testcode MSBs */
+	/* Set testen to high */
+	writel_relaxed(CSI_PTCR1_TWM, csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* Place 0x00 in testdin */
+	writel_relaxed(CSI_PTCR1_TWM, csi2priv->base + CSI_PTCR1);
+
+	/*
+	 * Set testclk to low (with the falling edge on testclk, the testdin signal content is
+	 * latched internally)
+	 */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set testen to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR1);
+
+	/* Place the 8-bit word corresponding to the testcode MSBs in testdin */
+	writel_relaxed(((addr >> 8) & CSI_PTCR1_TDI_MASK) << CSI_PTCR1_TDI_SHIFT,
+		       csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* For writing the 8-bit testcode LSBs */
+	/* Set testclk to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set testen to high */
+	writel_relaxed(CSI_PTCR1_TWM, csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* Place the 8-bit word test data in testdin */
+	writel_relaxed((addr & CSI_PTCR1_TDI_MASK) << CSI_PTCR1_TDI_SHIFT | CSI_PTCR1_TWM,
+		       csi2priv->base + CSI_PTCR1);
+
+	/*
+	 * Set testclk to low (with the falling edge on testclk, the testdin signal content is
+	 * latched internally)
+	 */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set testen to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR1);
+
+	/* For writing the data */
+	/* Place the 8-bit word corresponding to the page offset in testdin */
+	writel_relaxed((val & CSI_PTCR1_TDI_MASK) << CSI_PTCR1_TDI_SHIFT,
+		       csi2priv->base + CSI_PTCR1);
+
+	/* Set testclk to high (test data is programmed internally */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+
+	/* Finish by setting testclk to low */
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+}
+
+static int csi2host_start(struct csi2host_priv *csi2priv)
+{
+	const struct csi2host_fmts *fmt;
+	const struct csi2host_mbps_phy_reg *phy_regs;
+	int ret, i, mbps;
+	unsigned long phy_clk_frate;
+	u32 lanes_ie = 0;
+	u32 lanes_en = 0;
+	u32 lanes_stop = 0;
+	u32 ccfr;
+	s64 link_freq;
+
+	dev_dbg(csi2priv->dev, "Starting the CSI2\n");
+	/* Get format info to get BPP - FIXME, is this ok to check pad 0 ?? */
+	fmt = csi2host_code_to_fmt(csi2priv->mf[0].code);
+
+	/* Get the remote sensor link frequency */
+	if (!csi2priv->source_subdev)
+		return -EIO;
+
+	link_freq = v4l2_get_link_freq(csi2priv->source_subdev->ctrl_handler,
+				       fmt->bpp, 2 * csi2priv->num_lanes);
+	if (link_freq < 0)
+		return link_freq;
+
+	/* MBPS is expressed in Mbps, hence link_freq / 100000 * 2 */
+	mbps = link_freq / 500000;
+	dev_dbg(csi2priv->dev, "Computed Mbps: %u\n", mbps);
+
+	for (phy_regs = snps_stm32mp257; phy_regs->mbps != 0; phy_regs++)
+		if (phy_regs->mbps >= mbps)
+			break;
+
+	if (!phy_regs->mbps) {
+		dev_err(csi2priv->dev, "Unsupported PHY speed (%u Mbps)", mbps);
+		return -ERANGE;
+	}
+
+	dev_dbg(csi2priv->dev, "PHY settings: (%u Mbps, %u HS FRange, %u OSC Freq)\n",
+		phy_regs->mbps, phy_regs->hsfreqrange,
+		phy_regs->osc_freq_target);
+
+	/* Prepare lanes related configuration bits */
+	for (i = 0; i < csi2priv->num_lanes; i++) {
+		if (!csi2priv->lanes[i]) {
+			lanes_ie |= CSI_SR1_DL0_ERRORS;
+			lanes_en |= CSI_PCR_DL0EN;
+			lanes_stop |= CSI_SR1_STOPDL0F;
+		} else {
+			lanes_ie |= CSI_SR1_DL1_ERRORS;
+			lanes_en |= CSI_PCR_DL1EN;
+			lanes_stop |= CSI_SR1_STOPDL1F;
+		}
+	}
+
+	ret = pm_runtime_get_sync(csi2priv->dev);
+	if (ret < 0)
+		return ret;
+
+	/* Retrieve CSI2PHY clock rate to compute CCFR value */
+	phy_clk_frate = clk_get_rate(csi2priv->csi2phy);
+	if (!phy_clk_frate) {
+		pm_runtime_put(csi2priv->dev);
+		dev_err(csi2priv->dev, "CSI2PHY clock rate invalid (0)\n");
+		return ret;
+	}
+
+	ret = csi2host_setup_lane_merger(csi2priv);
+	if (ret) {
+		pm_runtime_put(csi2priv->dev);
+		return ret;
+	}
+
+	/* FIXME - how to set the watchdog value .. */
+	writel_relaxed(0, csi2priv->base + CSI_WDR);
+
+	/* Enable the CSI */
+	writel_relaxed(CSI_CR_CSIEN, csi2priv->base + CSI_CR);
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	/* Enable some global CSI related interrupts - bits are same as SR0 */
+	writel_relaxed(CSI_SR0_ERRORS, csi2priv->base + CSI_IER0);
+
+	/* Enable lanes related error interrupts */
+	writel_relaxed(lanes_ie, csi2priv->base + CSI_IER1);
+#endif
+
+	/* Initialization of the D-PHY */
+	/* Stop the D-PHY */
+	writel_relaxed(0, csi2priv->base + CSI_PRCR);
+
+	/* Keep the D-PHY in power down state */
+	writel_relaxed(0, csi2priv->base + CSI_PCR);
+
+	/* Enable testclr clock during 15ns */
+	writel_relaxed(CSI_PTCR0_TCKEN, csi2priv->base + CSI_PTCR0);
+	udelay(1);
+	writel_relaxed(0, csi2priv->base + CSI_PTCR0);
+
+	/* Set hsfreqrange */
+	phy_clk_frate /= 1000000;
+	ccfr = (phy_clk_frate - 17) * 4;
+	writel_relaxed((ccfr << CSI_PFCR_CCFR_SHIFT) |
+		       (phy_regs->hsfreqrange << CSI_PFCR_HSFR_SHIFT),
+		       csi2priv->base + CSI_PFCR);
+
+	/* set reg @08 deskew_polarity_rw 1'b1 */
+	csi2host_phy_reg_write(csi2priv, 0x08, 0x38);
+
+	/* set reg @0xE4 counter_for_des_en_config_if_rx 0x10 + DLL prog EN */
+	/* This is because 13<= cfgclkfreqrange[5:0]<=38 */
+	csi2host_phy_reg_write(csi2priv, 0xe4, 0x11);
+
+	/* set reg @0xe2 & reg @0xe3 value DLL target oscilation freq */
+	/* Based on the table page 77, osc_freq_target */
+	csi2host_phy_reg_write(csi2priv, 0xe2, phy_regs->osc_freq_target & 0xFF);
+	csi2host_phy_reg_write(csi2priv, 0xe3, (phy_regs->osc_freq_target >> 8) & 0x0F);
+
+	writel_relaxed(CSI_PFCR_DLD | readl_relaxed(csi2priv->base + CSI_PFCR),
+		       csi2priv->base + CSI_PFCR);
+
+	/* Enable Lanes */
+	writel_relaxed(lanes_en | CSI_PCR_CLEN, csi2priv->base + CSI_PCR);
+	writel_relaxed(lanes_en | CSI_PCR_CLEN | CSI_PCR_PWRDOWN,
+		       csi2priv->base + CSI_PCR);
+
+	writel_relaxed(CSI_PRCR_PEN, csi2priv->base + CSI_PRCR);
+
+	/* Remove the force */
+	writel_relaxed(0, csi2priv->base + CSI_PMCR);
+
+	return ret;
+}
+
+static void csi2host_stop(struct csi2host_priv *csi2priv)
+{
+	dev_dbg(csi2priv->dev, "Stopping the CSI2\n");
+
+	/* Disable the D-PHY */
+	writel_relaxed(0, csi2priv->base + CSI_PCR);
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	/* Disable ITs */
+	writel_relaxed(0, csi2priv->base + CSI_IER0);
+	writel_relaxed(0, csi2priv->base + CSI_IER1);
+#endif
+
+	/* Disable the CSI */
+	writel_relaxed(0, csi2priv->base + CSI_CR);
+
+	pm_runtime_put(csi2priv->dev);
+}
+
+static int csi2host_start_vc(struct csi2host_priv *csi2priv, uint32_t vc)
+{
+	const struct csi2host_fmts *fmt;
+	struct media_pad *rpad;
+	int ret = 0;
+	u32 cfgr1 = 0, cfgr2 = 0;
+	u32 dt0 = 0, dt1 = 0;
+	u32 status;
+
+	/* Get DT codes of the two related source pads */
+	rpad = media_pad_remote_pad_first(&csi2priv->pads[1 + (2 * vc)]);
+	if (rpad)
+		dt0 = csi2priv->mf[1 + (2 * vc)].code;
+
+	rpad = media_pad_remote_pad_first(&csi2priv->pads[1 + (2 * vc) + 1]);
+	if (rpad)
+		dt1 = csi2priv->mf[1 + (2 * vc) + 1].code;
+
+	/* If either of the two output is JPEG, don't perform filtering */
+	if (dt0 == MEDIA_BUS_FMT_JPEG_1X8 || dt1 == MEDIA_BUS_FMT_JPEG_1X8) {
+		cfgr1 |= CSI_VCxCFGR1_ALLDT;
+		cfgr1 |= (CSI_VCxCFGRx_DTxFT_BPP8 << CSI_VCxCFGR1_CDTFT_SHIFT);
+		dev_dbg(csi2priv->dev, "VC%d: enable AllDT in BPP8 mode\n", vc);
+	} else {
+		/* Configure DT0 */
+		if (dt0) {
+			fmt = csi2host_code_to_fmt(dt0);
+			cfgr1 |= fmt->datatype << CSI_VCxCFGR1_DT0_SHIFT;
+			cfgr1 |= fmt->datatype_fmt << CSI_VCxCFGR1_DT0FT_SHIFT;
+			cfgr1 |= CSI_VCxCFGR1_DT0EN;
+			dev_dbg(csi2priv->dev, "VC%d: enable DT0 (0x%x) - DT0FT (0x%x)\n",
+				vc, fmt->datatype, fmt->datatype_fmt);
+		}
+
+		/* Configure DT1 */
+		if (dt1) {
+			fmt = csi2host_code_to_fmt(dt1);
+			cfgr2 |= fmt->datatype << CSI_VCxCFGR2_DT1_SHIFT;
+			cfgr2 |= fmt->datatype_fmt << CSI_VCxCFGR2_DT1FT_SHIFT;
+			cfgr1 |= CSI_VCxCFGR1_DT1EN;
+			dev_dbg(csi2priv->dev, "VC%d: enable DT1 (0x%x) - DT1FT (0x%x)\n",
+				vc, fmt->datatype, fmt->datatype_fmt);
+			writel_relaxed(cfgr2, csi2priv->base + CSI_VCxCFGR2(vc));
+		}
+	}
+
+	writel_relaxed(cfgr1, csi2priv->base + CSI_VCxCFGR1(vc));
+
+	/* Start the Virtual Channel if necessary */
+	if (!cfgr1)
+		return 0;
+
+	writel_relaxed(readl_relaxed(csi2priv->base + CSI_CR) | CSI_CR_VCxSTART(vc),
+		       csi2priv->base + CSI_CR);
+
+	ret = readl_relaxed_poll_timeout(csi2priv->base + CSI_SR0,
+					 status,
+					 status & CSI_SR0_VCxSTATEF(vc),
+					 1000, 1000000);
+	if (ret) {
+		dev_err(csi2priv->dev, "failed to start VC(%d)\n", vc);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int csi2host_stop_vc(struct csi2host_priv *csi2priv, uint32_t vc)
+{
+	int ret = 0;
+	u32 status;
+
+	/* Stop the Virtual Channel */
+	writel_relaxed(readl_relaxed(csi2priv->base + CSI_CR) | CSI_CR_VCxSTOP(vc),
+		       csi2priv->base + CSI_CR);
+
+	/*
+	 * FIXME - timeout is probably not correct. CSI2HOST will wait
+	 * until getting an EOF before resetting the VC
+	 */
+	ret = readl_relaxed_poll_timeout(csi2priv->base + CSI_SR0,
+					 status,
+					 !(status & CSI_SR0_VCxSTATEF(vc)),
+					 1000, 1000000);
+	if (ret) {
+		dev_err(csi2priv->dev, "failed to stop VC(%d)\n", vc);
+		return ret;
+	}
+
+	/* Disable all DTs */
+	writel_relaxed(0, csi2priv->base + CSI_VCxCFGR1(vc));
+	writel_relaxed(0, csi2priv->base + CSI_VCxCFGR2(vc));
+
+	return 0;
+}
+
+static int csi2host_s_stream(struct v4l2_subdev *subdev, int enable)
+{
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(subdev);
+	int ret, i;
+
+	mutex_lock(&csi2priv->lock);
+
+	if (enable) {
+		/*
+		 * If we're not the first users, there's no need to
+		 * enable the whole controller.
+		 */
+		if (!csi2priv->count) {
+			ret = csi2host_start(csi2priv);
+			if (ret)
+				goto out;
+		}
+
+		/* Check and configure all 4 VCs */
+		for (i = 0; i < 4; i++) {
+			ret = csi2host_start_vc(csi2priv, i);
+			/* FIXME - better error handling needed here */
+			if (ret)
+				dev_err(csi2priv->dev, "Failed to start VC%d\n", i);
+		}
+
+		csi2priv->count++;
+	} else {
+		/* Stop all 4 VCs */
+		for (i = 0; i < 4; i++) {
+			ret = csi2host_stop_vc(csi2priv, i);
+			if (ret) {
+				dev_err(csi2priv->dev, "Failed to stop VC%d, turning off CSI to recover\n",
+					i);
+				csi2host_stop(csi2priv);
+			}
+		}
+
+		csi2priv->count--;
+
+		/*
+		 * Let the last user turn off the lights.
+		 */
+		if (!csi2priv->count)
+			csi2host_stop(csi2priv);
+	}
+
+out:
+	mutex_unlock(&csi2priv->lock);
+	return ret;
+}
+
+static int csi2host_enum_mbus_code(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= ARRAY_SIZE(csi2host_formats))
+		return -EINVAL;
+
+	code->code = csi2host_formats[code->index].code;
+	return 0;
+}
+
+static int csi2host_set_pad_format(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_format *format)
+{
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(sd);
+	const struct csi2host_fmts *fmt;
+
+	struct v4l2_mbus_framefmt *framefmt;
+
+	fmt = csi2host_code_to_fmt(format->format.code);
+	if (!fmt) {
+		dev_dbg(csi2priv->dev, "Unsupported code %d, use default\n",
+			format->format.code);
+		format->format.code = csi2host_formats[0].code;
+	}
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		csi2priv->mf[format->pad] = format->format;
+		/* Same format is exposed to the source pad as well */
+		if (format->pad == CSI2HOST_PAD_SINK)
+			csi2priv->mf[CSI2HOST_PAD_SOURCE_STREAM0] =
+					format->format;
+	} else {
+		framefmt = v4l2_subdev_get_try_format(sd, state, format->pad);
+		*framefmt = format->format;
+		if (format->pad == CSI2HOST_PAD_SINK) {
+			framefmt = v4l2_subdev_get_try_format(sd, state,
+							      CSI2HOST_PAD_SOURCE_STREAM0);
+			*framefmt = format->format;
+		}
+	}
+
+	return 0;
+}
+
+static int csi2host_get_pad_format(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_format *format)
+{
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(sd);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		format->format = csi2priv->mf[format->pad];
+	else
+		format->format =
+			*v4l2_subdev_get_try_format(sd, state, format->pad);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops csi2host_video_ops = {
+	.s_stream	= csi2host_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops csi2host_pad_ops = {
+	.enum_mbus_code	= csi2host_enum_mbus_code,
+	.set_fmt	= csi2host_set_pad_format,
+	.get_fmt	= csi2host_get_pad_format,
+};
+
+static const struct v4l2_subdev_ops csi2host_subdev_ops = {
+	.video		= &csi2host_video_ops,
+	.pad		= &csi2host_pad_ops,
+};
+
+static int csi2host_async_bound(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *s_subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct v4l2_subdev *subdev = notifier->sd;
+	struct csi2host_priv *csi2priv = v4l2_subdev_to_csi2priv(subdev);
+	int remote_pad;
+
+	remote_pad = media_entity_get_fwnode_pad(&s_subdev->entity,
+						 s_subdev->fwnode,
+						 MEDIA_PAD_FL_SOURCE);
+	if (remote_pad < 0) {
+		dev_err(csi2priv->dev, "Couldn't find output pad for subdev %s\n",
+			s_subdev->name);
+		return remote_pad;
+	}
+
+	csi2priv->source_subdev = s_subdev;
+
+	return media_create_pad_link(&csi2priv->source_subdev->entity,
+				     remote_pad, &csi2priv->subdev.entity, 0,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static const struct v4l2_async_notifier_operations csi2host_notifier_ops = {
+	.bound		= csi2host_async_bound,
+};
+
+#ifdef CSI2HOST_ERROR_HANDLING
+static irqreturn_t csi2host_irq_thread(int irq, void *arg)
+{
+	struct csi2host_priv *csi2priv = arg;
+
+	if (csi2priv->sr0 & CSI_SR0_SYNCERRF)
+		dev_dbg(csi2priv->dev, "Invalid synchronization error VC(%d)\n",
+			(csi2priv->err2 >> CSI_ERR2_SYNCVCERR_SHIFT) & VC_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_SPKTERRF)
+		dev_dbg(csi2priv->dev, "Short packet error VC(%d)/DT(%d)\n",
+			(csi2priv->err2 >> CSI_ERR2_SPKTVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err2 >> CSI_ERR2_SPKTDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_IDERRF)
+		dev_dbg(csi2priv->dev, "Data type ID error VC(%d)/DT(%d)\n",
+			(csi2priv->err1 >> CSI_ERR1_IDVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err1 >> CSI_ERR1_IDDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_CECCERRF)
+		dev_dbg(csi2priv->dev, "Corrected ECC error VC(%d)/DT(%d)\n",
+			(csi2priv->err1 >> CSI_ERR1_CECCVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err1 >> CSI_ERR1_CECCDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_ECCERRF)
+		dev_dbg(csi2priv->dev, "ECC error\n");
+
+	if (csi2priv->sr0 & CSI_SR0_CRCERRF)
+		dev_dbg(csi2priv->dev, "CRC error VC(%d)/DT(%d)\n",
+			(csi2priv->err1 >> CSI_ERR1_CRCVCERR_SHIFT) & VC_MASK,
+			(csi2priv->err1 >> CSI_ERR1_CRCDTERR_SHIFT) & DT_MASK);
+
+	if (csi2priv->sr0 & CSI_SR0_CCFIFOFF)
+		dev_dbg(csi2priv->dev, "Clock changer FIFO full error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ECTRLDL1F)
+		dev_dbg(csi2priv->dev, "L1: D-PHY_RX lane 1 control error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESYNCESCDL1F)
+		dev_dbg(csi2priv->dev, "L1: D-PHY_RX lane 1 low power data transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_EESCDL1F)
+		dev_dbg(csi2priv->dev, "L1: D-PHY_RX lane 1 escape entry error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTSYNCDL1F)
+		dev_dbg(csi2priv->dev, "L1: Start of transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTDL1F)
+		dev_dbg(csi2priv->dev, "L1: Start of transmission error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ECTRLDL0F)
+		dev_dbg(csi2priv->dev, "L0: D-PHY_RX lane 0 control error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESYNCESCDL0F)
+		dev_dbg(csi2priv->dev, "L0: D-PHY_RX lane 0 low power data transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_EESCDL0F)
+		dev_dbg(csi2priv->dev, "L0: D-PHY_RX lane 0 escape entry error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTSYNCDL0F)
+		dev_dbg(csi2priv->dev, "L0: Start of transmission synchronization error\n");
+
+	if (csi2priv->sr1 & CSI_SR1_ESOTDL0F)
+		dev_dbg(csi2priv->dev, "L0: Start of transmission error\n");
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t csi2host_irq_callback(int irq, void *arg)
+{
+	struct csi2host_priv *csi2priv = arg;
+
+	csi2priv->sr0 = readl_relaxed(csi2priv->base + CSI_SR0);
+	csi2priv->sr1 = readl_relaxed(csi2priv->base + CSI_SR1);
+	csi2priv->err1 = readl_relaxed(csi2priv->base + CSI_ERR1);
+	csi2priv->err2 = readl_relaxed(csi2priv->base + CSI_ERR2);
+
+	/* Clear interrupt */
+	writel_relaxed(csi2priv->sr0 & CSI_SR0_ERRORS, csi2priv->base + CSI_FCR0);
+	writel_relaxed(csi2priv->sr1 & CSI_SR1_ERRORS, csi2priv->base + CSI_FCR1);
+
+	return IRQ_WAKE_THREAD;
+}
+#endif
+
+static int csi2host_get_resources(struct csi2host_priv *csi2priv,
+				  struct platform_device *pdev)
+{
+	struct resource *res;
+#ifdef CSI2HOST_ERROR_HANDLING
+	int irq;
+#endif
+	int ret;
+	u32 dev_cfg;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	csi2priv->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(csi2priv->base))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->base),
+				     "Failed to ioremap resource\n");
+
+	csi2priv->pclk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(csi2priv->pclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->pclk),
+				     "Couldn't get pclk\n");
+
+	csi2priv->txesc = devm_clk_get(&pdev->dev, "txesc");
+	if (IS_ERR(csi2priv->txesc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->txesc),
+				     "Couldn't get txesc\n");
+
+	csi2priv->csi2phy = devm_clk_get(&pdev->dev, "csi2phy");
+	if (IS_ERR(csi2priv->csi2phy))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->csi2phy),
+				     "Couldn't get csi2phy\n");
+
+	csi2priv->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(csi2priv->rstc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(csi2priv->rstc),
+				     "Couldn't get reset control\n");
+
+	csi2priv->supplies[0].supply = "vdd";
+	csi2priv->supplies[1].supply = "vdda18";
+	ret = devm_regulator_bulk_get(&pdev->dev, ARRAY_SIZE(csi2priv->supplies),
+				      csi2priv->supplies);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "Failed to request regulator vdd\n");
+
+#ifdef CSI2HOST_ERROR_HANDLING
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0)
+		return irq ? irq : -ENXIO;
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, csi2host_irq_callback,
+					csi2host_irq_thread, IRQF_ONESHOT,
+					dev_name(&pdev->dev), csi2priv);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "Unable to request irq");
+#endif
+
+	clk_prepare_enable(csi2priv->pclk);
+	dev_cfg = readl_relaxed(csi2priv->base + CSI_HWCFGR);
+	clk_disable_unprepare(csi2priv->pclk);
+
+	csi2priv->max_lanes = (dev_cfg & CSI_HWCFGR_LANES_MASK)
+				>> CSI_HWCFGR_LANES_SHIFT;
+	if (csi2priv->max_lanes > CSI2HOST_LANES_MAX) {
+		dev_err(&pdev->dev, "Invalid number of lanes: %u\n",
+			csi2priv->max_lanes);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int csi2host_parse_dt(struct csi2host_priv *csi2priv)
+{
+	struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct v4l2_async_subdev *asd;
+	struct fwnode_handle *fwh;
+	struct device_node *ep;
+	int ret;
+
+	ep = of_graph_get_endpoint_by_regs(csi2priv->dev->of_node, 0, 0);
+	if (!ep)
+		return -EINVAL;
+
+	fwh = of_fwnode_handle(ep);
+	ret = v4l2_fwnode_endpoint_parse(fwh, &v4l2_ep);
+	if (ret) {
+		dev_err(csi2priv->dev, "Could not parse v4l2 endpoint\n");
+		of_node_put(ep);
+		return ret;
+	}
+	of_node_put(ep);
+
+	csi2priv->num_lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+	if (csi2priv->num_lanes > csi2priv->max_lanes) {
+		dev_err(csi2priv->dev, "Unsupported number of data-lanes: %d\n",
+			csi2priv->num_lanes);
+		of_node_put(ep);
+		return -EINVAL;
+	}
+
+	memcpy(csi2priv->lanes, v4l2_ep.bus.mipi_csi2.data_lanes,
+	       sizeof(csi2priv->lanes));
+
+	ep = of_graph_get_next_endpoint(csi2priv->dev->of_node, NULL);
+	if (!ep) {
+		dev_err(csi2priv->dev, "Failed to get next endpoint\n");
+		return -EINVAL;
+	}
+
+	v4l2_async_nf_init(&csi2priv->notifier);
+
+	asd = v4l2_async_nf_add_fwnode_remote(&csi2priv->notifier, of_fwnode_handle(ep),
+					      struct v4l2_async_subdev);
+
+	of_node_put(ep);
+
+	if (IS_ERR(asd)) {
+		dev_err(csi2priv->dev, "Failed to add fwnode remote subdev\n");
+		return PTR_ERR(asd);
+	}
+
+	csi2priv->notifier.ops = &csi2host_notifier_ops;
+
+	ret = v4l2_async_subdev_nf_register(&csi2priv->subdev, &csi2priv->notifier);
+	if (ret)
+		v4l2_async_nf_cleanup(&csi2priv->notifier);
+
+	return ret;
+}
+
+static int csi2host_probe(struct platform_device *pdev)
+{
+	struct csi2host_priv *csi2priv;
+	unsigned int i;
+	int ret;
+
+	csi2priv = devm_kzalloc(&pdev->dev, sizeof(*csi2priv), GFP_KERNEL);
+	if (!csi2priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, csi2priv);
+	csi2priv->dev = &pdev->dev;
+	mutex_init(&csi2priv->lock);
+
+	ret = csi2host_get_resources(csi2priv, pdev);
+	if (ret)
+		goto err_free_priv;
+
+	ret = csi2host_parse_dt(csi2priv);
+	if (ret)
+		goto err_free_priv;
+
+	csi2priv->subdev.owner = THIS_MODULE;
+	csi2priv->subdev.dev = &pdev->dev;
+	v4l2_subdev_init(&csi2priv->subdev, &csi2host_subdev_ops);
+	v4l2_set_subdevdata(&csi2priv->subdev, &pdev->dev);
+	snprintf(csi2priv->subdev.name, V4L2_SUBDEV_NAME_SIZE, "%s.%s",
+		 KBUILD_MODNAME, dev_name(&pdev->dev));
+
+	/* Create our media pads */
+	csi2priv->subdev.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	csi2priv->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	csi2priv->pads[CSI2HOST_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	csi2priv->mf[CSI2HOST_PAD_SINK].code = MEDIA_BUS_FMT_UYVY8_2X8;
+	for (i = CSI2HOST_PAD_SOURCE_STREAM0; i < CSI2HOST_PAD_MAX; i++) {
+		csi2priv->pads[i].flags = MEDIA_PAD_FL_SOURCE;
+		csi2priv->mf[i].code = MEDIA_BUS_FMT_UYVY8_2X8;
+	}
+
+	ret = media_entity_pads_init(&csi2priv->subdev.entity, CSI2HOST_PAD_MAX,
+				     csi2priv->pads);
+	if (ret)
+		goto err_cleanup;
+
+	ret = v4l2_async_register_subdev(&csi2priv->subdev);
+	if (ret < 0)
+		goto err_cleanup;
+
+	/* Reset device */
+	ret = reset_control_assert(csi2priv->rstc);
+	if (ret) {
+		ret = dev_err_probe(&pdev->dev, ret,
+				    "Failed to assert the reset line\n");
+		goto err_cleanup;
+	}
+
+	usleep_range(3000, 5000);
+
+	ret = reset_control_deassert(csi2priv->rstc);
+	if (ret) {
+		ret = dev_err_probe(&pdev->dev, ret,
+				    "Failed to deassert the reset line\n");
+		goto err_cleanup;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	dev_info(&pdev->dev,
+		 "Probed CSI2HOST with %u lanes\n", csi2priv->num_lanes);
+
+	return 0;
+
+err_cleanup:
+	v4l2_async_nf_cleanup(&csi2priv->notifier);
+err_free_priv:
+	return ret;
+}
+
+static int csi2host_remove(struct platform_device *pdev)
+{
+	struct csi2host_priv *csi2priv = platform_get_drvdata(pdev);
+
+	v4l2_async_unregister_subdev(&csi2priv->subdev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static int __maybe_unused csi2host_runtime_suspend(struct device *dev)
+{
+	struct csi2host_priv *csi2priv = dev_get_drvdata(dev);
+	int ret;
+
+	clk_disable_unprepare(csi2priv->csi2phy);
+	clk_disable_unprepare(csi2priv->txesc);
+	clk_disable_unprepare(csi2priv->pclk);
+
+	ret = regulator_bulk_disable(ARRAY_SIZE(csi2priv->supplies), csi2priv->supplies);
+	if (ret < 0)
+		dev_err(dev, "cannot disable regulators %d\n", ret);
+
+	return 0;
+}
+
+static int __maybe_unused csi2host_runtime_resume(struct device *dev)
+{
+	struct csi2host_priv *csi2priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(csi2priv->supplies), csi2priv->supplies);
+	if (ret)
+		goto error_out;
+
+	ret = clk_prepare_enable(csi2priv->pclk);
+	if (ret)
+		goto error_disable_supplies;
+
+	ret = clk_prepare_enable(csi2priv->txesc);
+	if (ret)
+		goto error_disable_pclk;
+
+	ret = clk_prepare_enable(csi2priv->csi2phy);
+	if (ret)
+		goto error_disable_txesc;
+
+	return 0;
+
+error_disable_txesc:
+	clk_disable_unprepare(csi2priv->txesc);
+error_disable_pclk:
+	clk_disable_unprepare(csi2priv->pclk);
+error_disable_supplies:
+	ret = regulator_bulk_disable(ARRAY_SIZE(csi2priv->supplies), csi2priv->supplies);
+	if (ret < 0)
+		dev_err(dev, "cannot disable regulators %d\n", ret);
+error_out:
+	dev_err(csi2priv->dev, "Failed to resume: %d\n", ret);
+
+	return ret;
+}
+
+static const struct of_device_id csi2host_of_table[] = {
+	{ .compatible = "st,stm32-csi2host" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, csi2host_of_table);
+
+static const struct dev_pm_ops csi2host_pm_ops = {
+	SET_RUNTIME_PM_OPS(csi2host_runtime_suspend, csi2host_runtime_resume, NULL)
+};
+
+static struct platform_driver csi2host_driver = {
+	.probe	= csi2host_probe,
+	.remove	= csi2host_remove,
+
+	.driver	= {
+		.name		= "stm32-csi2host",
+		.of_match_table	= csi2host_of_table,
+		.pm		= &csi2host_pm_ops,
+	},
+};
+module_platform_driver(csi2host_driver);
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STM32 CSI controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/st/stm32/stm32-dcmi.c b/drivers/media/platform/st/stm32/stm32-dcmi.c
index 37458d4d9..ffd470f4f 100644
--- a/drivers/media/platform/st/stm32/stm32-dcmi.c
+++ b/drivers/media/platform/st/stm32/stm32-dcmi.c
@@ -15,6 +15,7 @@
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/dmaengine.h>
+#include <linux/genalloc.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
@@ -114,6 +115,9 @@ struct dcmi_buf {
 	struct vb2_v4l2_buffer	vb;
 	bool			prepared;
 	struct sg_table		sgt;
+	struct sg_table		sgt_mdma;
+	struct dma_async_tx_descriptor *dma_desc;
+	struct dma_async_tx_descriptor *mdma_desc;
 	size_t			size;
 	struct list_head	list;
 };
@@ -158,14 +162,20 @@ struct stm32_dcmi {
 	struct dma_chan			*dma_chan;
 	dma_cookie_t			dma_cookie;
 	u32				dma_max_burst;
+
+	/* Elements for the MDMA - DMA chaining */
+	struct gen_pool			*sram_pool;
+	struct dma_chan			*mdma_chan;
+	void				*sram_buf;
+	u32				sram_buf_size;
+	dma_addr_t			sram_dma_buf;
+	dma_cookie_t			mdma_cookie;
+
 	u32				misr;
 	int				errors_count;
 	int				overrun_count;
 	int				buffers_count;
 
-	/* Ensure DMA operations atomicity */
-	struct mutex			dma_lock;
-
 	struct media_device		mdev;
 	struct media_pad		vid_cap_pad;
 	struct media_pipeline		pipeline;
@@ -229,127 +239,42 @@ static int dcmi_restart_capture(struct stm32_dcmi *dcmi)
 {
 	struct dcmi_buf *buf;
 
-	spin_lock_irq(&dcmi->irqlock);
-
-	if (dcmi->state != RUNNING) {
-		spin_unlock_irq(&dcmi->irqlock);
-		return -EINVAL;
-	}
+	/* Nothing to do if we are not running */
+	if (dcmi->state != RUNNING)
+		return 0;
 
 	/* Restart a new DMA transfer with next buffer */
 	if (list_empty(&dcmi->buffers)) {
 		dev_dbg(dcmi->dev, "Capture restart is deferred to next buffer queueing\n");
 		dcmi->state = WAIT_FOR_BUFFER;
-		spin_unlock_irq(&dcmi->irqlock);
 		return 0;
 	}
 	buf = list_entry(dcmi->buffers.next, struct dcmi_buf, list);
 	dcmi->active = buf;
 
-	spin_unlock_irq(&dcmi->irqlock);
-
 	return dcmi_start_capture(dcmi, buf);
 }
 
-static void dcmi_dma_callback(void *param)
-{
-	struct stm32_dcmi *dcmi = (struct stm32_dcmi *)param;
-	struct dma_tx_state state;
-	enum dma_status status;
-	struct dcmi_buf *buf = dcmi->active;
-
-	spin_lock_irq(&dcmi->irqlock);
-
-	/* Check DMA status */
-	status = dmaengine_tx_status(dcmi->dma_chan, dcmi->dma_cookie, &state);
-
-	switch (status) {
-	case DMA_IN_PROGRESS:
-		dev_dbg(dcmi->dev, "%s: Received DMA_IN_PROGRESS\n", __func__);
-		break;
-	case DMA_PAUSED:
-		dev_err(dcmi->dev, "%s: Received DMA_PAUSED\n", __func__);
-		break;
-	case DMA_ERROR:
-		dev_err(dcmi->dev, "%s: Received DMA_ERROR\n", __func__);
-
-		/* Return buffer to V4L2 in error state */
-		dcmi_buffer_done(dcmi, buf, 0, -EIO);
-		break;
-	case DMA_COMPLETE:
-		dev_dbg(dcmi->dev, "%s: Received DMA_COMPLETE\n", __func__);
-
-		/* Return buffer to V4L2 */
-		dcmi_buffer_done(dcmi, buf, buf->size, 0);
-
-		spin_unlock_irq(&dcmi->irqlock);
-
-		/* Restart capture */
-		if (dcmi_restart_capture(dcmi))
-			dev_err(dcmi->dev, "%s: Cannot restart capture on DMA complete\n",
-				__func__);
-		return;
-	default:
-		dev_err(dcmi->dev, "%s: Received unknown status\n", __func__);
-		break;
-	}
-
-	spin_unlock_irq(&dcmi->irqlock);
-}
-
 static int dcmi_start_dma(struct stm32_dcmi *dcmi,
 			  struct dcmi_buf *buf)
 {
-	struct dma_async_tx_descriptor *desc = NULL;
-	struct dma_slave_config config;
-	int ret;
-
-	memset(&config, 0, sizeof(config));
-
-	config.src_addr = (dma_addr_t)dcmi->res->start + DCMI_DR;
-	config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	config.dst_maxburst = 4;
-
-	/* Configure DMA channel */
-	ret = dmaengine_slave_config(dcmi->dma_chan, &config);
-	if (ret < 0) {
-		dev_err(dcmi->dev, "%s: DMA channel config failed (%d)\n",
-			__func__, ret);
-		return ret;
-	}
-
-	/*
-	 * Avoid call of dmaengine_terminate_sync() between
-	 * dmaengine_prep_slave_single() and dmaengine_submit()
-	 * by locking the whole DMA submission sequence
-	 */
-	mutex_lock(&dcmi->dma_lock);
-
-	/* Prepare a DMA transaction */
-	desc = dmaengine_prep_slave_sg(dcmi->dma_chan, buf->sgt.sgl, buf->sgt.nents,
-				       DMA_DEV_TO_MEM,
-				       DMA_PREP_INTERRUPT);
-	if (!desc) {
-		dev_err(dcmi->dev, "%s: DMA dmaengine_prep_slave_sg failed\n", __func__);
-		mutex_unlock(&dcmi->dma_lock);
-		return -EINVAL;
+	/* Push current DMA transaction in the pending queue */
+	if (dcmi->mdma_chan) {
+		dcmi->mdma_cookie = dmaengine_submit(buf->mdma_desc);
+		if (dma_submit_error(dcmi->mdma_cookie)) {
+			dev_err(dcmi->dev, "%s: MDMA submission failed\n", __func__);
+			return -ENXIO;
+		}
 	}
 
-	/* Set completion callback routine for notification */
-	desc->callback = dcmi_dma_callback;
-	desc->callback_param = dcmi;
-
-	/* Push current DMA transaction in the pending queue */
-	dcmi->dma_cookie = dmaengine_submit(desc);
+	dcmi->dma_cookie = dmaengine_submit(buf->dma_desc);
 	if (dma_submit_error(dcmi->dma_cookie)) {
 		dev_err(dcmi->dev, "%s: DMA submission failed\n", __func__);
-		mutex_unlock(&dcmi->dma_lock);
 		return -ENXIO;
 	}
 
-	mutex_unlock(&dcmi->dma_lock);
-
+	if (dcmi->mdma_chan)
+		dma_async_issue_pending(dcmi->mdma_chan);
 	dma_async_issue_pending(dcmi->dma_chan);
 
 	return 0;
@@ -396,9 +321,11 @@ static void dcmi_set_crop(struct stm32_dcmi *dcmi)
 	reg_set(dcmi->regs, DCMI_CR, CR_CROP);
 }
 
-static void dcmi_process_jpeg(struct stm32_dcmi *dcmi)
+static void dcmi_process_frame(struct stm32_dcmi *dcmi)
 {
-	struct dma_tx_state state;
+	struct dma_tx_state state, state_dma;
+	size_t bytes_used;
+
 	enum dma_status status;
 	struct dcmi_buf *buf = dcmi->active;
 
@@ -406,38 +333,50 @@ static void dcmi_process_jpeg(struct stm32_dcmi *dcmi)
 		return;
 
 	/*
-	 * Because of variable JPEG buffer size sent by sensor,
-	 * DMA transfer never completes due to transfer size never reached.
-	 * In order to ensure that all the JPEG data are transferred
-	 * in active buffer memory, DMA is drained.
-	 * Then DMA tx status gives the amount of data transferred
-	 * to memory, which is then returned to V4L2 through the active
-	 * buffer payload.
+	 * Pause the DMA transfer, leading to trigger of the MDMA channel read while
+	 * keeping a valid residue value on the dma channel
 	 */
+	if (dcmi->mdma_chan) {
+		spin_unlock_irq(&dcmi->irqlock);
+		dmaengine_pause(dcmi->dma_chan);
+		spin_lock_irq(&dcmi->irqlock);
+
+		do {
+			status = dmaengine_tx_status(dcmi->mdma_chan, dcmi->mdma_cookie, &state);
+			cpu_relax();
+		} while (status != DMA_ERROR && status != DMA_COMPLETE &&
+			 state.residue && state.in_flight_bytes);
+	} else {
+		status = dmaengine_tx_status(dcmi->dma_chan, dcmi->dma_cookie, &state);
+	}
 
-	/* Drain DMA */
-	dmaengine_synchronize(dcmi->dma_chan);
-
-	/* Get DMA residue to get JPEG size */
-	status = dmaengine_tx_status(dcmi->dma_chan, dcmi->dma_cookie, &state);
 	if (status != DMA_ERROR && state.residue < buf->size) {
-		/* Return JPEG buffer to V4L2 with received JPEG buffer size */
-		dcmi_buffer_done(dcmi, buf, buf->size - state.residue, 0);
+		bytes_used = buf->size - state.residue;
+
+		if (state.residue && dcmi->mdma_chan) {
+			dmaengine_tx_status(dcmi->dma_chan, dcmi->dma_cookie, &state_dma);
+			/* Getting full size residue equal to no residue */
+			if (state_dma.residue == dcmi->sram_buf_size)
+				state_dma.residue = 0;
+			bytes_used -= state_dma.residue;
+		}
+
+		/* Return buffer to V4L2 with received data size */
+		dcmi_buffer_done(dcmi, buf, bytes_used, 0);
 	} else {
 		dcmi->errors_count++;
-		dev_err(dcmi->dev, "%s: Cannot get JPEG size from DMA\n",
-			__func__);
-		/* Return JPEG buffer to V4L2 in ERROR state */
+		dev_err(dcmi->dev, "%s: DMA error. status: 0x%x, residue: %d\n",
+			__func__, status, state.residue);
+		/* Return buffer to V4L2 in ERROR state */
 		dcmi_buffer_done(dcmi, buf, 0, -EIO);
 	}
 
+	spin_unlock_irq(&dcmi->irqlock);
 	/* Abort DMA operation */
 	dmaengine_terminate_sync(dcmi->dma_chan);
-
-	/* Restart capture */
-	if (dcmi_restart_capture(dcmi))
-		dev_err(dcmi->dev, "%s: Cannot restart capture on JPEG received\n",
-			__func__);
+	if (dcmi->mdma_chan)
+		dmaengine_terminate_sync(dcmi->mdma_chan);
+	spin_lock_irq(&dcmi->irqlock);
 }
 
 static irqreturn_t dcmi_irq_thread(int irq, void *arg)
@@ -447,19 +386,33 @@ static irqreturn_t dcmi_irq_thread(int irq, void *arg)
 	spin_lock_irq(&dcmi->irqlock);
 
 	if (dcmi->misr & IT_OVR) {
+		/* Disable capture */
+		reg_clear(dcmi->regs, DCMI_CR, CR_CAPTURE);
+
 		dcmi->overrun_count++;
+
 		if (dcmi->overrun_count > OVERRUN_ERROR_THRESHOLD)
 			dcmi->errors_count++;
+
+		spin_unlock_irq(&dcmi->irqlock);
+		dmaengine_terminate_sync(dcmi->dma_chan);
+		if (dcmi->mdma_chan)
+			dmaengine_terminate_sync(dcmi->mdma_chan);
+
+		spin_lock_irq(&dcmi->irqlock);
+		if (dcmi_restart_capture(dcmi))
+			dev_err(dcmi->dev, "%s: Cannot restart capture\n", __func__);
+		spin_unlock_irq(&dcmi->irqlock);
+		return IRQ_HANDLED;
 	}
+
 	if (dcmi->misr & IT_ERR)
 		dcmi->errors_count++;
 
-	if (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG &&
-	    dcmi->misr & IT_FRAME) {
-		/* JPEG received */
-		spin_unlock_irq(&dcmi->irqlock);
-		dcmi_process_jpeg(dcmi);
-		return IRQ_HANDLED;
+	if (dcmi->misr & IT_FRAME) {
+		dcmi_process_frame(dcmi);
+		if (dcmi_restart_capture(dcmi))
+			dev_err(dcmi->dev, "%s: Cannot restart capture\n", __func__);
 	}
 
 	spin_unlock_irq(&dcmi->irqlock);
@@ -539,31 +492,132 @@ static int dcmi_buf_prepare(struct vb2_buffer *vb)
 	vb2_set_plane_payload(vb, 0, size);
 
 	if (!buf->prepared) {
+		u32 max_size = dcmi->dma_max_burst;
+		unsigned int dma_nents;
+
 		/* Get memory addresses */
 		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
-		if (buf->size > dcmi->dma_max_burst)
-			num_sgs = DIV_ROUND_UP(buf->size, dcmi->dma_max_burst);
+		if (dcmi->mdma_chan)
+			max_size = dcmi->sram_buf_size / 2;
+
+		if (buf->size > max_size)
+			num_sgs = DIV_ROUND_UP(buf->size, max_size);
+
+		/*
+		 * If we use MDMA chaining, DMA is used in cyclic mode and the scatterlist
+		 * maximum size is thus 2
+		 */
+		dma_nents = num_sgs;
+		if (dcmi->mdma_chan)
+			dma_nents = min_t(unsigned int, num_sgs, 2);
 
-		ret = sg_alloc_table(&buf->sgt, num_sgs, GFP_ATOMIC);
+		ret = sg_alloc_table(&buf->sgt, dma_nents, GFP_ATOMIC);
 		if (ret) {
-			dev_err(dcmi->dev, "sg table alloc failed\n");
+			dev_err(dcmi->dev, "sg table alloc failed for DMA\n");
 			return ret;
 		}
 
+		if (dcmi->mdma_chan) {
+			ret = sg_alloc_table(&buf->sgt_mdma, num_sgs, GFP_ATOMIC);
+			if (ret) {
+				dev_err(dcmi->dev, "sg table alloc failed for MDMA\n");
+				return ret;
+			}
+		}
+
 		dma_buf = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
 
 		dev_dbg(dcmi->dev, "buffer[%d] phy=%pad size=%zu\n",
 			vb->index, &dma_buf, buf->size);
 
-		for_each_sg(buf->sgt.sgl, sg, num_sgs, i) {
-			size_t bytes = min_t(size_t, size, dcmi->dma_max_burst);
+		for_each_sg(buf->sgt.sgl, sg, dma_nents, i) {
+			size_t bytes = min_t(size_t, size, max_size);
+
+			if (!dcmi->mdma_chan) {
+				sg_dma_address(sg) = dma_buf;
+				dma_buf += bytes;
+			} else {
+				/* Targets the beginning = first half of the sram_buf */
+				sg_dma_address(sg) = dcmi->sram_dma_buf;
+				/*
+				 * Targets the second half of the sram_bubf
+				 * for odd indexes of the item of the sg_list
+				 */
+				if (i & 1)
+					sg->dma_address += (dcmi->sram_buf_size / 2);
+			}
+			/*
+			 * In case of DMA-MDMA chaining, since the DMA is working in cyclic mode,
+			 * we need to provide two linked-list node of same size in order to have
+			 * a correct residue value computed.
+			 */
+			if (!dcmi->mdma_chan)
+				sg_dma_len(sg) = bytes;
+			else
+				sg_dma_len(sg) = dcmi->sram_buf_size / 2;
 
-			sg_dma_address(sg) = dma_buf;
-			sg_dma_len(sg) = bytes;
-			dma_buf += bytes;
 			size -= bytes;
 		}
 
+		/* Prepare a DMA transaction */
+		buf->dma_desc = dmaengine_prep_slave_sg(dcmi->dma_chan, buf->sgt.sgl,
+							buf->sgt.nents, DMA_DEV_TO_MEM,
+							DMA_PREP_INTERRUPT);
+		if (!buf->dma_desc) {
+			dev_err(dcmi->dev, "%s: DMA dmaengine_prep_slave_sg failed\n", __func__);
+			if (dcmi->mdma_chan)
+				sg_free_table(&buf->sgt_mdma);
+			sg_free_table(&buf->sgt);
+			return -EIO;
+		}
+
+		/* Mark the descriptor as reusable to avoid having to prepare it */
+		ret = dmaengine_desc_set_reuse(buf->dma_desc);
+		if (ret) {
+			dev_err(dcmi->dev, "%s: DMA dmaengine_desc_set_reuse failed\n", __func__);
+			dmaengine_desc_free(buf->dma_desc);
+			if (dcmi->mdma_chan)
+				sg_free_table(&buf->sgt_mdma);
+			sg_free_table(&buf->sgt);
+			return -EIO;
+		}
+
+		if (dcmi->mdma_chan) {
+			size = dcmi->fmt.fmt.pix.sizeimage;
+			for_each_sg(buf->sgt_mdma.sgl, sg, num_sgs, i) {
+				size_t bytes = min_t(size_t, size, max_size);
+
+				sg_dma_address(sg) = dma_buf;
+				sg_dma_len(sg) = bytes;
+				dma_buf += bytes;
+				size -= bytes;
+			}
+
+			buf->mdma_desc = dmaengine_prep_slave_sg(dcmi->mdma_chan, buf->sgt_mdma.sgl,
+								 buf->sgt_mdma.nents,
+								 DMA_DEV_TO_MEM,
+								 DMA_PREP_INTERRUPT);
+			if (!buf->mdma_desc) {
+				dev_err(dcmi->dev, "%s: failed dmaengine_prep_slave_sg for MDMA\n",
+					__func__);
+				dmaengine_desc_free(buf->dma_desc);
+				sg_free_table(&buf->sgt_mdma);
+				sg_free_table(&buf->sgt);
+				return -EIO;
+			}
+
+			ret = dmaengine_desc_set_reuse(buf->mdma_desc);
+			if (ret) {
+				dev_err(dcmi->dev, "%s: failed to set reuse for mdma desc\n",
+					__func__);
+				dmaengine_desc_free(buf->mdma_desc);
+				dmaengine_desc_free(buf->dma_desc);
+				sg_free_table(&buf->sgt_mdma);
+				sg_free_table(&buf->sgt);
+				return -EIO;
+			}
+		}
+
 		buf->prepared = true;
 
 		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
@@ -572,6 +626,31 @@ static int dcmi_buf_prepare(struct vb2_buffer *vb)
 	return 0;
 }
 
+static void dcmi_buf_cleanup(struct vb2_buffer *vb)
+{
+	struct stm32_dcmi *dcmi =  vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmi_buf *buf = container_of(vbuf, struct dcmi_buf, vb);
+	int ret;
+
+	if (!buf->prepared)
+		return;
+
+	if (dcmi->mdma_chan) {
+		ret = dmaengine_desc_free(buf->mdma_desc);
+		if (ret)
+			dev_err(dcmi->dev, "%s: Failed to free the mdma descriptor (0x%x)\n",
+				__func__, ret);
+		sg_free_table(&buf->sgt_mdma);
+	}
+
+	ret = dmaengine_desc_free(buf->dma_desc);
+	if (ret)
+		dev_err(dcmi->dev, "%s: Failed to free the mdma descriptor (0x%x)\n",
+			__func__, ret);
+	sg_free_table(&buf->sgt);
+}
+
 static void dcmi_buf_queue(struct vb2_buffer *vb)
 {
 	struct stm32_dcmi *dcmi =  vb2_get_drv_priv(vb->vb2_queue);
@@ -590,11 +669,9 @@ static void dcmi_buf_queue(struct vb2_buffer *vb)
 		dev_dbg(dcmi->dev, "Starting capture on buffer[%d] queued\n",
 			buf->vb.vb2_buf.index);
 
-		spin_unlock_irq(&dcmi->irqlock);
 		if (dcmi_start_capture(dcmi, buf))
 			dev_err(dcmi->dev, "%s: Cannot restart capture on overflow or error\n",
 				__func__);
-		return;
 	}
 
 	spin_unlock_irq(&dcmi->irqlock);
@@ -815,10 +892,6 @@ static int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)
 	if (dcmi->do_crop)
 		dcmi_set_crop(dcmi);
 
-	/* Enable jpeg capture */
-	if (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG)
-		reg_set(dcmi->regs, DCMI_CR, CR_CM);/* Snapshot mode */
-
 	/* Enable dcmi */
 	reg_set(dcmi->regs, DCMI_CR, CR_ENABLE);
 
@@ -845,19 +918,18 @@ static int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)
 
 	dev_dbg(dcmi->dev, "Start streaming, starting capture\n");
 
-	spin_unlock_irq(&dcmi->irqlock);
 	ret = dcmi_start_capture(dcmi, buf);
 	if (ret) {
 		dev_err(dcmi->dev, "%s: Start streaming failed, cannot start capture\n",
 			__func__);
+		spin_unlock_irq(&dcmi->irqlock);
 		goto err_pipeline_stop;
 	}
 
 	/* Enable interruptions */
-	if (dcmi->sd_format->fourcc == V4L2_PIX_FMT_JPEG)
-		reg_set(dcmi->regs, DCMI_IER, IT_FRAME | IT_OVR | IT_ERR);
-	else
-		reg_set(dcmi->regs, DCMI_IER, IT_OVR | IT_ERR);
+	reg_set(dcmi->regs, DCMI_IER, IT_FRAME | IT_OVR | IT_ERR);
+
+	spin_unlock_irq(&dcmi->irqlock);
 
 	return 0;
 
@@ -914,9 +986,9 @@ static void dcmi_stop_streaming(struct vb2_queue *vq)
 	spin_unlock_irq(&dcmi->irqlock);
 
 	/* Stop all pending DMA operations */
-	mutex_lock(&dcmi->dma_lock);
 	dmaengine_terminate_sync(dcmi->dma_chan);
-	mutex_unlock(&dcmi->dma_lock);
+	if (dcmi->mdma_chan)
+		dmaengine_terminate_sync(dcmi->mdma_chan);
 
 	pm_runtime_put(dcmi->dev);
 
@@ -933,6 +1005,7 @@ static const struct vb2_ops dcmi_video_qops = {
 	.queue_setup		= dcmi_queue_setup,
 	.buf_init		= dcmi_buf_init,
 	.buf_prepare		= dcmi_buf_prepare,
+	.buf_cleanup		= dcmi_buf_cleanup,
 	.buf_queue		= dcmi_buf_queue,
 	.start_streaming	= dcmi_start_streaming,
 	.stop_streaming		= dcmi_stop_streaming,
@@ -1857,6 +1930,15 @@ static int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
 
 	dev_dbg(dcmi->dev, "Subdev \"%s\" bound\n", subdev->name);
 
+	ret = video_register_device(dcmi->vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dcmi->dev, "Failed to register video device\n");
+		return ret;
+	}
+
+	dev_dbg(dcmi->dev, "Device registered as %s\n",
+		video_device_node_name(dcmi->vdev));
+
 	/*
 	 * Link this sub-device to DCMI, it could be
 	 * a parallel camera sensor or a bridge
@@ -1869,10 +1951,11 @@ static int dcmi_graph_notify_bound(struct v4l2_async_notifier *notifier,
 				    &dcmi->vdev->entity, 0,
 				    MEDIA_LNK_FL_IMMUTABLE |
 				    MEDIA_LNK_FL_ENABLED);
-	if (ret)
+	if (ret) {
 		dev_err(dcmi->dev, "Failed to create media pad link with subdev \"%s\"\n",
 			subdev->name);
-	else
+		video_unregister_device(dcmi->vdev);
+	} else
 		dev_dbg(dcmi->dev, "DCMI is now linked to \"%s\"\n",
 			subdev->name);
 
@@ -1929,8 +2012,9 @@ static int dcmi_probe(struct platform_device *pdev)
 	struct v4l2_fwnode_endpoint ep = { .bus_type = 0 };
 	struct stm32_dcmi *dcmi;
 	struct vb2_queue *q;
-	struct dma_chan *chan;
+	struct dma_chan *chan, *mdma_chan;
 	struct dma_slave_caps caps;
+	struct dma_slave_config dma_config, mdma_config;
 	struct clk *mclk;
 	int irq;
 	int ret = 0;
@@ -1946,12 +2030,9 @@ static int dcmi_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	dcmi->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
-	if (IS_ERR(dcmi->rstc)) {
-		if (PTR_ERR(dcmi->rstc) != -EPROBE_DEFER)
-			dev_err(&pdev->dev, "Could not get reset control\n");
-
-		return PTR_ERR(dcmi->rstc);
-	}
+	if (IS_ERR(dcmi->rstc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(dcmi->rstc),
+				     "Could not get reset control\n");
 
 	/* Get bus characteristics from devicetree */
 	np = of_graph_get_next_endpoint(np, NULL);
@@ -2003,29 +2084,80 @@ static int dcmi_probe(struct platform_device *pdev)
 	}
 
 	mclk = devm_clk_get(&pdev->dev, "mclk");
-	if (IS_ERR(mclk)) {
-		if (PTR_ERR(mclk) != -EPROBE_DEFER)
-			dev_err(&pdev->dev, "Unable to get mclk\n");
-		return PTR_ERR(mclk);
-	}
+	if (IS_ERR(mclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(mclk), "Unable to get mclk\n");
 
 	chan = dma_request_chan(&pdev->dev, "tx");
-	if (IS_ERR(chan)) {
-		ret = PTR_ERR(chan);
-		if (ret != -EPROBE_DEFER)
-			dev_err(&pdev->dev,
-				"Failed to request DMA channel: %d\n", ret);
-		return ret;
+	if (IS_ERR(chan))
+		return dev_err_probe(&pdev->dev, PTR_ERR(chan), "Failed to request DMA channel\n");
+
+	mdma_chan = dma_request_chan(&pdev->dev, "mdma_tx");
+	if (IS_ERR(mdma_chan)) {
+		ret = PTR_ERR(mdma_chan);
+		if (ret != -ENODEV)
+			return dev_err_probe(&pdev->dev, ret, "Failed to request MDMA channel\n");
+		mdma_chan = NULL;
+	}
+
+	/* Configure the DMA channel */
+	memset(&dma_config, 0, sizeof(dma_config));
+
+	dma_config.src_addr = (dma_addr_t)dcmi->res->start + DCMI_DR;
+	dma_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	if (mdma_chan)
+		dma_config.peripheral_size = 1; /* Indicates chaining */
+
+	/* Configure DMA channel */
+	ret = dmaengine_slave_config(chan, &dma_config);
+	if (ret < 0) {
+		dev_err(dcmi->dev, "%s: DMA channel config failed (%d)\n",
+			__func__, ret);
+		goto err_dma_slave_config;
+	}
+
+	/* If we want MDMA, we also need a sram pool */
+	if (mdma_chan) {
+		dcmi->sram_pool = of_gen_pool_get(pdev->dev.of_node, "sram", 0);
+		if (!dcmi->sram_pool) {
+			dev_info(&pdev->dev, "No SRAM pool, can't use MDMA chaining\n");
+			goto err_dma_slave_config;
+		}
+
+		dev_info(&pdev->dev, "SRAM pool: %zu KiB for DMA/MDMA chaining\n",
+			 gen_pool_size(dcmi->sram_pool) / 1024);
+
+		dcmi->sram_buf_size = gen_pool_size(dcmi->sram_pool);
+		dcmi->sram_buf = gen_pool_dma_zalloc(dcmi->sram_pool, dcmi->sram_buf_size,
+						     &dcmi->sram_dma_buf);
+		if (!dcmi->sram_buf) {
+			dev_err(dcmi->dev, "Failed to allocate from SRAM\n");
+			goto err_dma_slave_config;
+		}
+
+		/* Configure the MDMA Channel */
+		memset(&mdma_config, 0, sizeof(mdma_config));
+		mdma_config.direction = DMA_DEV_TO_MEM;
+		mdma_config.src_addr = dcmi->sram_dma_buf;
+		mdma_config.peripheral_size = dma_config.peripheral_size;
+		mdma_config.peripheral_config = dma_config.peripheral_config;
+		ret = dmaengine_slave_config(mdma_chan, &mdma_config);
+		if (ret < 0) {
+			dev_err(dcmi->dev, "%s: MDMA channel config failed (%d)\n",
+				__func__, ret);
+			goto err_mdma_slave_config;
+		}
 	}
 
 	dcmi->dma_max_burst = UINT_MAX;
-	ret = dma_get_slave_caps(chan, &caps);
-	if (!ret && caps.max_sg_burst)
-		dcmi->dma_max_burst = caps.max_sg_burst	* DMA_SLAVE_BUSWIDTH_4_BYTES;
+	/* In case of using DMA-MDMA chaining we consider the maximum infini */
+	if (!mdma_chan) {
+		ret = dma_get_slave_caps(chan, &caps);
+		if (!ret && caps.max_sg_burst)
+			dcmi->dma_max_burst = caps.max_sg_burst * DMA_SLAVE_BUSWIDTH_4_BYTES;
+	}
 
 	spin_lock_init(&dcmi->irqlock);
 	mutex_init(&dcmi->lock);
-	mutex_init(&dcmi->dma_lock);
 	init_completion(&dcmi->complete);
 	INIT_LIST_HEAD(&dcmi->buffers);
 
@@ -2033,6 +2165,7 @@ static int dcmi_probe(struct platform_device *pdev)
 	dcmi->mclk = mclk;
 	dcmi->state = STOPPED;
 	dcmi->dma_chan = chan;
+	dcmi->mdma_chan = mdma_chan;
 
 	q = &dcmi->queue;
 
@@ -2076,15 +2209,6 @@ static int dcmi_probe(struct platform_device *pdev)
 	}
 	dcmi->vdev->entity.flags |= MEDIA_ENT_FL_DEFAULT;
 
-	ret = video_register_device(dcmi->vdev, VFL_TYPE_VIDEO, -1);
-	if (ret) {
-		dev_err(dcmi->dev, "Failed to register video device\n");
-		goto err_media_entity_cleanup;
-	}
-
-	dev_dbg(dcmi->dev, "Device registered as %s\n",
-		video_device_node_name(dcmi->vdev));
-
 	/* Buffer queue */
 	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
@@ -2140,7 +2264,13 @@ static int dcmi_probe(struct platform_device *pdev)
 	v4l2_device_unregister(&dcmi->v4l2_dev);
 err_media_device_cleanup:
 	media_device_cleanup(&dcmi->mdev);
+err_mdma_slave_config:
+	if (dcmi->mdma_chan)
+		gen_pool_free(dcmi->sram_pool, (unsigned long)dcmi->sram_buf, dcmi->sram_buf_size);
+err_dma_slave_config:
 	dma_release_channel(dcmi->dma_chan);
+	if (dcmi->mdma_chan)
+		dma_release_channel(mdma_chan);
 
 	return ret;
 }
@@ -2158,11 +2288,15 @@ static int dcmi_remove(struct platform_device *pdev)
 	media_device_cleanup(&dcmi->mdev);
 
 	dma_release_channel(dcmi->dma_chan);
+	if (dcmi->mdma_chan) {
+		gen_pool_free(dcmi->sram_pool, (unsigned long)dcmi->sram_buf, dcmi->sram_buf_size);
+		dma_release_channel(dcmi->mdma_chan);
+	}
 
 	return 0;
 }
 
-static __maybe_unused int dcmi_runtime_suspend(struct device *dev)
+static int dcmi_runtime_suspend(struct device *dev)
 {
 	struct stm32_dcmi *dcmi = dev_get_drvdata(dev);
 
@@ -2171,7 +2305,7 @@ static __maybe_unused int dcmi_runtime_suspend(struct device *dev)
 	return 0;
 }
 
-static __maybe_unused int dcmi_runtime_resume(struct device *dev)
+static int dcmi_runtime_resume(struct device *dev)
 {
 	struct stm32_dcmi *dcmi = dev_get_drvdata(dev);
 	int ret;
@@ -2183,7 +2317,7 @@ static __maybe_unused int dcmi_runtime_resume(struct device *dev)
 	return ret;
 }
 
-static __maybe_unused int dcmi_suspend(struct device *dev)
+static int dcmi_suspend(struct device *dev)
 {
 	/* disable clock */
 	pm_runtime_force_suspend(dev);
@@ -2194,7 +2328,7 @@ static __maybe_unused int dcmi_suspend(struct device *dev)
 	return 0;
 }
 
-static __maybe_unused int dcmi_resume(struct device *dev)
+static int dcmi_resume(struct device *dev)
 {
 	/* restore pinctl default state */
 	pinctrl_pm_select_default_state(dev);
@@ -2217,7 +2351,7 @@ static struct platform_driver stm32_dcmi_driver = {
 	.driver		= {
 		.name = DRV_NAME,
 		.of_match_table = of_match_ptr(stm32_dcmi_of_match),
-		.pm = &dcmi_pm_ops,
+		.pm = pm_sleep_ptr(&dcmi_pm_ops),
 	},
 };
 
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/Makefile b/drivers/media/platform/st/stm32/stm32-dcmipp/Makefile
new file mode 100644
index 000000000..cb5d819f2
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+stm32-dcmipp-y := dcmipp-core.o dcmipp-common.o dcmipp-input.o dcmipp-byteproc.o dcmipp-bytecap.o
+stm32-dcmipp-y += dcmipp-isp.o dcmipp-colorconv.o dcmipp-pixelproc.o dcmipp-pixelcap.o dcmipp-statcap.o
+stm32-dcmipp-y += dcmipp-isp-params.o
+
+obj-$(CONFIG_VIDEO_STM32_DCMIPP) += stm32-dcmipp.o
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-bytecap.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-bytecap.c
new file mode 100644
index 000000000..decc1fcc7
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-bytecap.c
@@ -0,0 +1,1068 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_BYTECAP_DRV_NAME "dcmipp-bytecap"
+
+#define DCMIPP_PRSR (0x1F8)
+#define DCMIPP_CMIER (0x3F0)
+#define DCMIPP_CMIER_P0FRAMEIE BIT(9)
+#define DCMIPP_CMIER_P0VSYNCIE BIT(10)
+#define DCMIPP_CMIER_P0OVRIE BIT(15)
+#define DCMIPP_CMIER_P0ALL (DCMIPP_CMIER_P0VSYNCIE |\
+			    DCMIPP_CMIER_P0FRAMEIE |\
+			    DCMIPP_CMIER_P0OVRIE)
+#define DCMIPP_CMSR1 (0x3F4)
+#define DCMIPP_CMSR2 (0x3F8)
+#define DCMIPP_CMSR2_P0FRAMEF BIT(9)
+#define DCMIPP_CMSR2_P0VSYNCF BIT(10)
+#define DCMIPP_CMSR2_P0OVRF BIT(15)
+#define DCMIPP_CMFCR (0x3FC)
+#define DCMIPP_P0FSCR (0x404)
+#define DCMIPP_P0FSCR_PIPEN BIT(31)
+#define DCMIPP_P0FCTCR (0x500)
+#define DCMIPP_P0FCTCR_CPTREQ BIT(3)
+#define DCMIPP_P0DCCNTR (0x5B0)
+#define DCMIPP_P0DCLMTR (0x5B4)
+#define DCMIPP_P0DCLMTR_ENABLE BIT(31)
+#define DCMIPP_P0DCLMTR_LIMIT_MASK GENMASK(23, 0)
+#define DCMIPP_P0PPM0AR1 (0x5C4)
+#define DCMIPP_P0SR (0x5F8)
+#define DCMIPP_P0SR_CPTACT BIT(23)
+
+struct dcmipp_bytecap_pix_map {
+	unsigned int code;
+	u32 pixelformat;
+};
+
+#define PIXMAP_MBUS_PFMT(mbus, fmt)				\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.pixelformat = V4L2_PIX_FMT_##fmt	\
+		}
+
+static const struct dcmipp_bytecap_pix_map dcmipp_bytecap_pix_map_list[] = {
+	PIXMAP_MBUS_PFMT(RGB565_2X8_LE, RGB565),
+	PIXMAP_MBUS_PFMT(YUYV8_2X8, YUYV),
+	PIXMAP_MBUS_PFMT(YVYU8_2X8, YVYU),
+	PIXMAP_MBUS_PFMT(UYVY8_2X8, UYVY),
+	PIXMAP_MBUS_PFMT(VYUY8_2X8, VYUY),
+	PIXMAP_MBUS_PFMT(Y8_1X8, GREY),
+	PIXMAP_MBUS_PFMT(SBGGR8_1X8, SBGGR8),
+	PIXMAP_MBUS_PFMT(SGBRG8_1X8, SGBRG8),
+	PIXMAP_MBUS_PFMT(SGRBG8_1X8, SGRBG8),
+	PIXMAP_MBUS_PFMT(SRGGB8_1X8, SRGGB8),
+	PIXMAP_MBUS_PFMT(SBGGR10_1X10, SBGGR10),
+	PIXMAP_MBUS_PFMT(SGBRG10_1X10, SGBRG10),
+	PIXMAP_MBUS_PFMT(SGRBG10_1X10, SGRBG10),
+	PIXMAP_MBUS_PFMT(SRGGB10_1X10, SRGGB10),
+	PIXMAP_MBUS_PFMT(SBGGR12_1X12, SBGGR12),
+	PIXMAP_MBUS_PFMT(SGBRG12_1X12, SGBRG12),
+	PIXMAP_MBUS_PFMT(SGRBG12_1X12, SGRBG12),
+	PIXMAP_MBUS_PFMT(SRGGB12_1X12, SRGGB12),
+	PIXMAP_MBUS_PFMT(SBGGR14_1X14, SBGGR14),
+	PIXMAP_MBUS_PFMT(SGBRG14_1X14, SGBRG14),
+	PIXMAP_MBUS_PFMT(SGRBG14_1X14, SGRBG14),
+	PIXMAP_MBUS_PFMT(SRGGB14_1X14, SRGGB14),
+	PIXMAP_MBUS_PFMT(JPEG_1X8, JPEG),
+};
+
+static const struct dcmipp_bytecap_pix_map *dcmipp_bytecap_pix_map_by_pixelformat
+						(u32 pixelformat)
+{
+	const struct dcmipp_bytecap_pix_map *l = dcmipp_bytecap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_bytecap_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].pixelformat == pixelformat)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+static const struct dcmipp_bytecap_pix_map *dcmipp_bytecap_pix_map_by_index(unsigned int i)
+{
+	const struct dcmipp_bytecap_pix_map *l = dcmipp_bytecap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_bytecap_pix_map_list);
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	bool			prepared;
+	dma_addr_t		paddr;
+	size_t			size;
+	struct list_head	list;
+};
+
+enum state {
+	STOPPED = 0,
+	WAIT_FOR_BUFFER,
+	RUNNING,
+};
+
+struct dcmipp_bytecap_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct v4l2_pix_format format;
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+
+	enum state state;
+
+	/*
+	 * DCMIPP driver is handling 2 buffers
+	 * active: buffer into which DCMIPP is currently writing into
+	 * next: buffer given to the DCMIPP and which will become
+	 *       automatically active on next VSYNC
+	 */
+	struct dcmipp_buf *active, *next;
+
+	void __iomem *regs;
+
+	u32 cmier;
+	u32 cmsr2;
+
+	int errors_count;
+	int limit_count;
+	int overrun_count;
+	int buffers_count;
+	int vsync_count;
+	int frame_count;
+	int it_count;
+	int underrun_count;
+	int nactive_count;
+};
+
+static const struct v4l2_pix_format fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.pixelformat = V4L2_PIX_FMT_RGB565,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = DCMIPP_COLORSPACE_DEFAULT,
+	.ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT,
+	.quantization = DCMIPP_QUANTIZATION_DEFAULT,
+	.xfer_func = DCMIPP_XFER_FUNC_DEFAULT,
+};
+
+static inline int hdw_pixel_alignment(u32 format)
+{
+	/* 16 bytes alignment required by hardware */
+	switch (format) {
+	case V4L2_PIX_FMT_SBGGR8:
+	case V4L2_PIX_FMT_SGBRG8:
+	case V4L2_PIX_FMT_SGRBG8:
+	case V4L2_PIX_FMT_SRGGB8:
+	case V4L2_PIX_FMT_GREY:
+	case V4L2_PIX_FMT_JPEG:
+		return 4;/* 2^4 = 16 pixels = 16 bytes */
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		return 3;/* 2^3  = 8 pixels = 16 bytes */
+	default:
+		return 0;
+	}
+}
+
+static int dcmipp_bytecap_querycap(struct file *file, void *priv,
+				   struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static void dcmipp_bytecap_get_format(struct dcmipp_ent_device *ved,
+				      struct v4l2_pix_format *fmt)
+{
+	struct dcmipp_bytecap_device *vcap = container_of(ved, struct dcmipp_bytecap_device,
+						    ved);
+
+	*fmt = vcap->format;
+}
+
+static int dcmipp_bytecap_g_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+
+	f->fmt.pix = vcap->format;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_try_fmt_vid_cap(struct file *file, void *priv,
+					  struct v4l2_format *f)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+	struct v4l2_pix_format *format = &f->fmt.pix;
+	const struct dcmipp_bytecap_pix_map *vpix;
+	u32 in_w, in_h;
+
+	/* Don't accept a pixelformat that is not on the table */
+	vpix = dcmipp_bytecap_pix_map_by_pixelformat(format->pixelformat);
+	if (!vpix)
+		format->pixelformat = fmt_default.pixelformat;
+
+	/* Adjust width & height */
+	in_w = format->width;
+	in_h = format->height;
+	v4l_bound_align_image(&format->width,
+			      DCMIPP_FRAME_MIN_WIDTH, DCMIPP_FRAME_MAX_WIDTH,
+			      hdw_pixel_alignment(format->pixelformat),
+			      &format->height,
+			      DCMIPP_FRAME_MIN_HEIGHT, DCMIPP_FRAME_MAX_HEIGHT,
+			      hdw_pixel_alignment(format->pixelformat),
+			      0);
+	if (format->width != in_w || format->height != in_h)
+		dev_dbg(vcap->dev,
+			"resolution updated: %dx%d -> %dx%d\n",
+			in_w, in_h, format->width, format->height);
+
+	if (format->pixelformat == V4L2_PIX_FMT_JPEG) {
+		format->bytesperline = format->width;
+		format->sizeimage = format->bytesperline * format->height;
+	} else {
+		v4l2_fill_pixfmt(format, format->pixelformat,
+				 format->width, format->height);
+	}
+
+	if (format->field == V4L2_FIELD_ANY)
+		format->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(format);
+
+	return 0;
+}
+
+static int dcmipp_bytecap_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+	int ret;
+
+	/* Do not change the format while stream is on */
+	if (vb2_is_busy(&vcap->queue))
+		return -EBUSY;
+
+	ret = dcmipp_bytecap_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	dev_dbg(vcap->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		vcap->vdev.name,
+		/* old */
+		vcap->format.width, vcap->format.height,
+		vcap->format.pixelformat, vcap->format.colorspace,
+		vcap->format.quantization, vcap->format.xfer_func,
+		vcap->format.ycbcr_enc,
+		/* new */
+		f->fmt.pix.width, f->fmt.pix.height,
+		f->fmt.pix.pixelformat, f->fmt.pix.colorspace,
+		f->fmt.pix.quantization, f->fmt.pix.xfer_func,
+		f->fmt.pix.ycbcr_enc);
+
+	vcap->format = f->fmt.pix;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_enum_fmt_vid_cap(struct file *file, void *priv,
+					   struct v4l2_fmtdesc *f)
+{
+	const struct dcmipp_bytecap_pix_map *vpix = dcmipp_bytecap_pix_map_by_index(f->index);
+
+	if (!vpix)
+		return -EINVAL;
+
+	f->pixelformat = vpix->pixelformat;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_enum_framesizes(struct file *file, void *fh,
+					  struct v4l2_frmsizeenum *fsize)
+{
+	const struct dcmipp_bytecap_pix_map *vpix;
+
+	if (fsize->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_bytecap_pix_map_by_pixelformat(fsize->pixel_format);
+	if (!vpix)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+	fsize->stepwise.min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fsize->stepwise.max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fsize->stepwise.min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fsize->stepwise.max_height = DCMIPP_FRAME_MAX_HEIGHT;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
+static int dcmipp_bytecap_open(struct file *file)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+	int ret;
+
+	ret = mutex_lock_interruptible(&vcap->lock);
+	if (ret)
+		return ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto err_unlock;
+
+	ret = v4l2_pipeline_pm_get(&vcap->vdev.entity);
+	if (ret)
+		goto err_close;
+
+	mutex_unlock(&vcap->lock);
+
+	return 0;
+
+err_close:
+	v4l2_fh_release(file);
+err_unlock:
+	mutex_unlock(&vcap->lock);
+
+	return ret;
+}
+
+static int dcmipp_bytecap_close(struct file *file)
+{
+	struct dcmipp_bytecap_device *vcap = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	v4l2_pipeline_pm_put(&vcap->vdev.entity);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations dcmipp_bytecap_fops = {
+	.owner		= THIS_MODULE,
+	.open		= dcmipp_bytecap_open,
+	.release	= dcmipp_bytecap_close,
+	.read           = vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops dcmipp_bytecap_ioctl_ops = {
+	.vidioc_querycap = dcmipp_bytecap_querycap,
+
+	.vidioc_g_fmt_vid_cap = dcmipp_bytecap_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = dcmipp_bytecap_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap = dcmipp_bytecap_try_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = dcmipp_bytecap_enum_fmt_vid_cap,
+	.vidioc_enum_framesizes = dcmipp_bytecap_enum_framesizes,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+static int dcmipp_pipeline_s_stream(struct dcmipp_bytecap_device *vcap,
+				    int state)
+{
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_pad_remote_pad_first(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		if (state) {
+			/* Increment stream_count to indicate that entity is streamon */
+			entity->stream_count++;
+
+			/*
+			 * Do not streamon entities already started and streamon
+			 * by another capture pipeline
+			 */
+			if (entity->stream_count > 1)
+				continue;
+		} else {
+			/* Decrement stream_count to indicate that entity is streamoff. */
+			entity->stream_count--;
+
+			/*
+			 * Only streamoff if entity is not owned anymore
+			 * by other pipelines
+			 */
+			if (entity->stream_count > 0)
+				continue;
+		}
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(vcap->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+
+			goto out;
+		}
+
+		dev_dbg(vcap->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+out:
+	mutex_unlock(&mdev->graph_mutex);
+
+	return 0;
+}
+
+static void dcmipp_start_capture(struct dcmipp_bytecap_device *vcap,
+				 struct dcmipp_buf *buf)
+{
+	/* Set buffer address */
+	reg_write(vcap, DCMIPP_P0PPM0AR1, buf->paddr);
+	dev_dbg(vcap->dev, "Write [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	/* Set buffer size */
+	reg_write(vcap, DCMIPP_P0DCLMTR, DCMIPP_P0DCLMTR_ENABLE |
+		  ((buf->size / 4) & DCMIPP_P0DCLMTR_LIMIT_MASK));
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
+}
+
+static int dcmipp_bytecap_start_streaming(struct vb2_queue *vq,
+					  unsigned int count)
+{
+	struct dcmipp_bytecap_device *vcap = vb2_get_drv_priv(vq);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_pipeline *pipe;
+	struct dcmipp_buf *buf, *node;
+	int ret;
+
+	vcap->sequence = 0;
+	vcap->errors_count = 0;
+	vcap->limit_count = 0;
+	vcap->overrun_count = 0;
+	vcap->buffers_count = 0;
+	vcap->vsync_count = 0;
+	vcap->frame_count = 0;
+	vcap->it_count = 0;
+	vcap->underrun_count = 0;
+	vcap->nactive_count = 0;
+
+	ret = pm_runtime_get_sync(vcap->dev);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/*
+	 * Start the media pipeline
+	 *
+	 * Pipeline is shared between all elements of the pipeline
+	 * including video capture nodes.
+	 * Instead of creating a common media_pipeline struct
+	 * global variable, use the one of the first capture
+	 * node. All the elements of the pipeline -including
+	 * other capture nodes- will be then assigned to this
+	 * pipeline (entity->pipe) in __media_pipeline_start().
+	 */
+	mutex_lock(&mdev->graph_mutex);
+	pipe = entity->pads[0].pipe ? : &vcap->pipe;
+	ret = __video_device_pipeline_start(&vcap->vdev, pipe);
+	mutex_unlock(&mdev->graph_mutex);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, media pipeline start error (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start all the elements within pipeline */
+	ret = dcmipp_pipeline_s_stream(vcap, 1);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Enable pipe at the end of programming */
+	reg_set(vcap, DCMIPP_P0FSCR, DCMIPP_P0FSCR_PIPEN);
+
+	/*
+	 * Start capture if at least one buffer has been queued,
+	 * otherwise start is deferred at next buffer queueing
+	 */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Start streaming is deferred to next buffer queueing\n");
+		vcap->next = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		spin_unlock_irq(&vcap->irqlock);
+		return 0;
+	}
+	vcap->next = buf;
+	dev_dbg(vcap->dev, "Start with next [%d] %p phy=%pad\n",
+		buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	/* Start capture */
+	dcmipp_start_capture(vcap, buf);
+
+	/* Enable interruptions */
+	vcap->cmier |= DCMIPP_CMIER_P0ALL;
+	spin_lock(&vcap->vdev.v4l2_dev->lock);
+	reg_set(vcap, DCMIPP_CMIER, vcap->cmier);
+	spin_unlock(&vcap->vdev.v4l2_dev->lock);
+
+	vcap->state = RUNNING;
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	return 0;
+
+err_media_pipeline_stop:
+	media_pipeline_stop(entity->pads);
+err_pm_put:
+	pm_runtime_put(vcap->dev);
+	spin_lock_irq(&vcap->irqlock);
+	/*
+	 * Return all buffers to vb2 in QUEUED state.
+	 * This will give ownership back to userspace
+	 */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	vcap->active = NULL;
+	spin_unlock_irq(&vcap->irqlock);
+
+	return ret;
+}
+
+static void dcmipp_dump_status(struct dcmipp_bytecap_device *vcap)
+{
+	struct device *dev = vcap->dev;
+
+	dev_dbg(dev, "[DCMIPP_PRSR]  =%#10.8x\n", reg_read(vcap, DCMIPP_PRSR));
+	dev_dbg(dev, "[DCMIPP_P0SR] =%#10.8x\n", reg_read(vcap, DCMIPP_P0SR));
+	dev_dbg(dev, "[DCMIPP_P0DCCNTR]=%#10.8x\n",
+		reg_read(vcap, DCMIPP_P0DCCNTR));
+	dev_dbg(dev, "[DCMIPP_CMSR1] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR1));
+	dev_dbg(dev, "[DCMIPP_CMSR2] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR2));
+}
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_bytecap_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_bytecap_device *vcap = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+	int ret;
+	u32 status;
+
+	dcmipp_pipeline_s_stream(vcap, 0);
+
+	/* Stop the media pipeline */
+	media_pipeline_stop(vcap->vdev.entity.pads);
+
+	/* Disable interruptions */
+	spin_lock(&vcap->vdev.v4l2_dev->lock);
+	reg_clear(vcap, DCMIPP_CMIER, vcap->cmier);
+	spin_unlock(&vcap->vdev.v4l2_dev->lock);
+
+	/* Stop capture */
+	reg_clear(vcap, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
+
+	/* Wait until CPTACT become 0 */
+	ret = readl_relaxed_poll_timeout(vcap->regs + DCMIPP_P0SR,
+					 status,
+					 !(status & DCMIPP_P0SR_CPTACT),
+					 20, 1000);
+	if (ret)
+		dev_warn(vcap->dev, "Timeout when stopping\n");
+
+	/* Disable pipe */
+	reg_clear(vcap, DCMIPP_P0FSCR, DCMIPP_P0FSCR_PIPEN);
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vcap->buffers);
+
+	vcap->active = NULL;
+	vcap->state = STOPPED;
+
+	dcmipp_dump_status(vcap);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	pm_runtime_put(vcap->dev);
+
+	if (vcap->errors_count)
+		dev_warn(vcap->dev, "Some errors found while streaming: errors=%d (overrun=%d, limit=%d, nactive=%d), underrun=%d, buffers=%d\n",
+			 vcap->errors_count, vcap->overrun_count, vcap->limit_count,
+			 vcap->nactive_count, vcap->underrun_count, vcap->buffers_count);
+	dev_dbg(vcap->dev, "Stop streaming, errors=%d (overrun=%d, limit=%d, nactive=%d), underrun=%d, vsync=%d, frame=%d, buffers=%d, it=%d\n",
+		vcap->errors_count, vcap->overrun_count, vcap->limit_count,
+		vcap->nactive_count, vcap->underrun_count, vcap->vsync_count,
+		vcap->frame_count, vcap->buffers_count, vcap->it_count);
+}
+
+static int dcmipp_bytecap_buf_prepare(struct vb2_buffer *vb)
+{
+	struct dcmipp_bytecap_device *vcap =  vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+	unsigned long size;
+
+	size = vcap->format.sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(vcap->dev, "%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	if (!buf->prepared) {
+		/* Get memory addresses */
+		buf->paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+		buf->prepared = true;
+
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+
+		dev_dbg(vcap->dev, "Setup [%d] phy=%pad size=%zu\n",
+			vb->index, &buf->paddr, buf->size);
+	}
+
+	return 0;
+}
+
+static void dcmipp_bytecap_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_bytecap_device *vcap =
+		vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vcap->irqlock);
+	list_add_tail(&buf->list, &vcap->buffers);
+
+	dev_dbg(vcap->dev, "Queue [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	if (vcap->state == WAIT_FOR_BUFFER) {
+		vcap->next = buf;
+		dev_dbg(vcap->dev, "Restart with next [%d] %p phy=%pad\n",
+			buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+		dcmipp_start_capture(vcap, buf);
+
+		vcap->state = RUNNING;
+
+		spin_unlock_irq(&vcap->irqlock);
+
+		return;
+	}
+
+	spin_unlock_irq(&vcap->irqlock);
+}
+
+static int dcmipp_bytecap_queue_setup(struct vb2_queue *vq,
+				      unsigned int *nbuffers,
+				      unsigned int *nplanes,
+				      unsigned int sizes[],
+				      struct device *alloc_devs[])
+{
+	struct dcmipp_bytecap_device *vcap = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	size = vcap->format.sizeimage;
+
+	/* Make sure the image size is large enough */
+	if (*nplanes)
+		return sizes[0] < vcap->format.sizeimage ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = vcap->format.sizeimage;
+
+	dev_dbg(vcap->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int dcmipp_bytecap_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_bytecap_qops = {
+	.start_streaming	= dcmipp_bytecap_start_streaming,
+	.stop_streaming		= dcmipp_bytecap_stop_streaming,
+	.buf_init		= dcmipp_bytecap_buf_init,
+	.buf_prepare		= dcmipp_bytecap_buf_prepare,
+	.buf_queue		= dcmipp_bytecap_buf_queue,
+	.queue_setup		= dcmipp_bytecap_queue_setup,
+	/*
+	 * Since q->lock is set we can use the standard
+	 * vb2_ops_wait_prepare/finish helper functions.
+	 */
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_bytecap_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static void dcmipp_bytecap_release(struct video_device *vdev)
+{
+	struct dcmipp_bytecap_device *vcap =
+		container_of(vdev, struct dcmipp_bytecap_device, vdev);
+
+	dcmipp_pads_cleanup(vcap->ved.pads);
+	kfree(vcap);
+}
+
+void dcmipp_bytecap_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_bytecap_device *vcap =
+		container_of(ved, struct dcmipp_bytecap_device, ved);
+
+	mutex_destroy(&vcap->lock);
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vcap->vdev);
+}
+
+static void dcmipp_buffer_done(struct dcmipp_bytecap_device *vcap,
+			       struct dcmipp_buf *buf,
+			       size_t bytesused,
+			       int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	list_del_init(&buf->list);
+
+	vbuf = &buf->vb;
+
+	vbuf->sequence = vcap->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+	dev_dbg(vcap->dev, "Done  [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+	vcap->buffers_count++;
+}
+
+/* irqlock must be held */
+static void dcmipp_bytecap_set_next_frame_or_stop(struct dcmipp_bytecap_device *vcap)
+{
+	if (!vcap->next && list_is_singular(&vcap->buffers)) {
+		/*
+		 * If there is no available buffer (none or a single one in the list while two
+		 * are expected), stop the capture (effective for next frame). On-going frame
+		 * capture will continue till FRAME END but no further capture will be done.
+		 */
+		reg_clear(vcap, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
+
+		dev_dbg(vcap->dev, "Capture restart is deferred to next buffer queueing\n");
+		vcap->next = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return;
+	}
+
+	/* If we don't have buffer yet, pick the one after active */
+	if (!vcap->next)
+		vcap->next = list_next_entry(vcap->active, list);
+
+	/*
+	 * Set buffer address
+	 * This register is shadowed and will be taken into
+	 * account on next VSYNC (start of next frame)
+	 */
+	reg_write(vcap, DCMIPP_P0PPM0AR1, vcap->next->paddr);
+	dev_dbg(vcap->dev, "Write [%d] %p phy=%pad\n",
+		vcap->next->vb.vb2_buf.index, vcap->next, &vcap->next->paddr);
+}
+
+/* irqlock must be held */
+static void dcmipp_bytecap_process_frame(struct dcmipp_bytecap_device *vcap,
+					 size_t bytesused)
+{
+	int err = 0;
+	struct dcmipp_buf *buf = vcap->active;
+
+	if (!buf) {
+		vcap->nactive_count++;
+		vcap->errors_count++;
+		return;
+	}
+
+	if (bytesused > buf->size) {
+		dev_dbg(vcap->dev, "frame larger than expected (%zu > %zu)\n",
+			bytesused, buf->size);
+		/* Clip to buffer size and return buffer to V4L2 in error */
+		bytesused = buf->size;
+		vcap->limit_count++;
+		vcap->errors_count++;
+		err = -EOVERFLOW;
+	}
+
+	dcmipp_buffer_done(vcap, buf, bytesused, err);
+	vcap->active = NULL;
+}
+
+static irqreturn_t dcmipp_bytecap_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_bytecap_device *vcap =
+			container_of(arg, struct dcmipp_bytecap_device, ved);
+	size_t bytesused = 0;
+	u32 cmsr2;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	cmsr2 = vcap->cmsr2 & vcap->cmier;
+
+	/*
+	 * If we have an overrun, a frame-end will probably not be generated, in that
+	 * case the active buffer will be recycled as next buffer by the VSYNC handler
+	 */
+	if (cmsr2 & DCMIPP_CMSR2_P0OVRF) {
+		vcap->errors_count++;
+		vcap->overrun_count++;
+	}
+
+	if (cmsr2 & DCMIPP_CMSR2_P0FRAMEF) {
+		vcap->frame_count++;
+
+		/* Read captured buffer size */
+		bytesused = reg_read(vcap, DCMIPP_P0DCCNTR);
+		dcmipp_bytecap_process_frame(vcap, bytesused);
+	}
+
+	if (cmsr2 & DCMIPP_CMSR2_P0VSYNCF) {
+		vcap->vsync_count++;
+		if (vcap->state == WAIT_FOR_BUFFER) {
+			vcap->underrun_count++;
+			goto out;
+		}
+
+		/*
+		 * On VSYNC, the previously set next buffer is going to become active thanks to
+		 * the shadowing mechanism of the DCMIPP. In most of the cases, since a FRAMEEND
+		 * has already come, pointer next is NULL since active is reset during the
+		 * FRAMEEND handling. However, in case of framerate adjustment, there are more
+		 * VSYNC than FRAMEEND. Thus we recycle the active (but not used) buffer and put it
+		 * back into next.
+		 */
+		swap(vcap->active, vcap->next);
+		dcmipp_bytecap_set_next_frame_or_stop(vcap);
+	}
+
+out:
+	spin_unlock_irq(&vcap->irqlock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_bytecap_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_bytecap_device *vcap =
+			container_of(arg, struct dcmipp_bytecap_device, ved);
+	struct dcmipp_ent_device *ved = arg;
+
+	/* Store interrupt status register */
+	vcap->cmsr2 = ved->cmsr2 & vcap->cmier;
+	vcap->it_count++;
+
+	/* Clear interrupt */
+	reg_write(vcap, DCMIPP_CMFCR, vcap->cmsr2);
+
+	return IRQ_WAKE_THREAD;
+}
+
+struct dcmipp_ent_device *dcmipp_bytecap_ent_init(struct device *dev,
+						  const char *entity_name,
+						  struct v4l2_device *v4l2_dev,
+						  void __iomem *regs)
+{
+	struct dcmipp_bytecap_device *vcap;
+	struct v4l2_pix_format *format;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	/* Allocate the dcmipp_bytecap_device struct */
+	vcap = kzalloc(sizeof(*vcap), GFP_KERNEL);
+	if (!vcap)
+		return ERR_PTR(-ENOMEM);
+
+	/* Allocate the pads */
+	vcap->ved.pads =
+		dcmipp_pads_init(1,
+				 (const unsigned long[1]) {MEDIA_PAD_FL_SINK});
+	if (IS_ERR(vcap->ved.pads)) {
+		ret = PTR_ERR(vcap->ved.pads);
+		goto err_free_vcap;
+	}
+
+	/* Initialize the media entity */
+	vcap->vdev.entity.name = entity_name;
+	vcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vcap->vdev.entity,
+				     1, vcap->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vcap->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vcap->queue;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	q->lock = &vcap->lock;
+	q->drv_priv = vcap;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_bytecap_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = dev;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s: vb2 queue init failed (err=%d)\n",
+			entity_name, ret);
+		goto err_mutex_destroy;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vcap->buffers);
+	spin_lock_init(&vcap->irqlock);
+
+	/* Set default frame format */
+	vcap->format = fmt_default;
+	format = &vcap->format;
+	v4l2_fill_pixfmt(format, format->pixelformat, format->width,
+			 format->height);
+
+	/* Fill the dcmipp_ent_device struct */
+	vcap->ved.ent = &vcap->vdev.entity;
+	vcap->ved.vdev_get_format = dcmipp_bytecap_get_format;
+	vcap->ved.handler = dcmipp_bytecap_irq_callback;
+	vcap->ved.thread_fn = dcmipp_bytecap_irq_thread;
+	vcap->dev = dev;
+	vcap->regs = regs;
+
+	/* Initialize the video_device struct */
+	vdev = &vcap->vdev;
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+			    V4L2_CAP_IO_MC;
+	vdev->entity.ops = &dcmipp_bytecap_mops;
+	vdev->release = dcmipp_bytecap_release;
+	vdev->fops = &dcmipp_bytecap_fops;
+	vdev->ioctl_ops = &dcmipp_bytecap_ioctl_ops;
+	vdev->lock = &vcap->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = v4l2_dev;
+	strscpy(vdev->name, entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vcap->ved);
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dev, "%s: video register failed (err=%d)\n",
+			vcap->vdev.name, ret);
+		goto err_mutex_destroy;
+	}
+
+	return &vcap->ved;
+
+err_mutex_destroy:
+	mutex_destroy(&vcap->lock);
+	media_entity_cleanup(&vcap->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vcap->ved.pads);
+err_free_vcap:
+	kfree(vcap);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-byteproc.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-byteproc.c
new file mode 100644
index 000000000..10b68ff92
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-byteproc.c
@@ -0,0 +1,760 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_BYTEPROC_DRV_NAME "dcmipp-byteproc"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P0FCTCR (0x500)
+#define DCMIPP_P0FCTCR_FRATE_MASK GENMASK(1, 0)
+#define DCMIPP_P0SCSTR (0x504)
+#define DCMIPP_P0SCSTR_HSTART_SHIFT	0
+#define DCMIPP_P0SCSTR_VSTART_SHIFT	16
+#define DCMIPP_P0SCSZR (0x508)
+#define DCMIPP_P0SCSZR_ENABLE BIT(31)
+#define DCMIPP_P0SCSZR_HSIZE_SHIFT	0
+#define DCMIPP_P0SCSZR_VSIZE_SHIFT	16
+#define DCMIPP_P0PPCR (0x5C0)
+#define DCMIPP_P0PPCR_BSM_1_2 0x1
+#define DCMIPP_P0PPCR_BSM_1_4 0x2
+#define DCMIPP_P0PPCR_BSM_2_4 0x3
+#define DCMIPP_P0PPCR_BSM_MASK GENMASK(8, 7)
+#define DCMIPP_P0PPCR_BSM_SHIFT 0x7
+#define DCMIPP_P0PPCR_LSM BIT(10)
+#define DCMIPP_P0PPCR_OELS BIT(11)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define BYTEPROC_MEDIA_BUS_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+
+struct dcmipp_byteproc_pix_map {
+	unsigned int code;
+	unsigned int bpp;
+};
+
+#define PIXMAP_MBUS_BPP(mbus, byteperpixel)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.bpp = byteperpixel,	\
+		}
+static const struct dcmipp_byteproc_pix_map dcmipp_byteproc_pix_map_list[] = {
+	PIXMAP_MBUS_BPP(RGB565_2X8_LE, 2),
+	PIXMAP_MBUS_BPP(YUYV8_2X8, 2),
+	PIXMAP_MBUS_BPP(YVYU8_2X8, 2),
+	PIXMAP_MBUS_BPP(UYVY8_2X8, 2),
+	PIXMAP_MBUS_BPP(VYUY8_2X8, 2),
+	PIXMAP_MBUS_BPP(Y8_1X8, 1),
+	PIXMAP_MBUS_BPP(SBGGR8_1X8, 1),
+	PIXMAP_MBUS_BPP(SGBRG8_1X8, 1),
+	PIXMAP_MBUS_BPP(SGRBG8_1X8, 1),
+	PIXMAP_MBUS_BPP(SRGGB8_1X8, 1),
+	PIXMAP_MBUS_BPP(SBGGR10_1X10, 2),
+	PIXMAP_MBUS_BPP(SGBRG10_1X10, 2),
+	PIXMAP_MBUS_BPP(SGRBG10_1X10, 2),
+	PIXMAP_MBUS_BPP(SRGGB10_1X10, 2),
+	PIXMAP_MBUS_BPP(SBGGR12_1X12, 2),
+	PIXMAP_MBUS_BPP(SGBRG12_1X12, 2),
+	PIXMAP_MBUS_BPP(SGRBG12_1X12, 2),
+	PIXMAP_MBUS_BPP(SRGGB12_1X12, 2),
+	PIXMAP_MBUS_BPP(SBGGR14_1X14, 2),
+	PIXMAP_MBUS_BPP(SGBRG14_1X14, 2),
+	PIXMAP_MBUS_BPP(SGRBG14_1X14, 2),
+	PIXMAP_MBUS_BPP(SRGGB14_1X14, 2),
+	PIXMAP_MBUS_BPP(JPEG_1X8, 1),
+};
+
+static const struct dcmipp_byteproc_pix_map *dcmipp_byteproc_pix_map_by_code(u32 code)
+{
+	const struct dcmipp_byteproc_pix_map *l = dcmipp_byteproc_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_byteproc_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_byteproc_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+
+	struct v4l2_fract sink_interval;
+	struct v4l2_fract src_interval;
+	unsigned int frate;
+	u32 src_code;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = BYTEPROC_MEDIA_BUS_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = DCMIPP_COLORSPACE_DEFAULT,
+	.ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT,
+	.quantization = DCMIPP_QUANTIZATION_DEFAULT,
+	.xfer_func = DCMIPP_XFER_FUNC_DEFAULT,
+};
+
+static const struct v4l2_rect crop_min = {
+	.width = DCMIPP_FRAME_MIN_WIDTH,
+	.height = DCMIPP_FRAME_MIN_HEIGHT,
+	.top = 0,
+	.left = 0,
+};
+
+static struct v4l2_rect
+dcmipp_byteproc_get_compose_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+
+	return r;
+}
+
+static void dcmipp_byteproc_adjust_crop(struct v4l2_rect *r, struct v4l2_rect *compose)
+{
+	/* Disallow rectangles smaller than the minimal one. */
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, compose);
+}
+
+static void dcmipp_byteproc_adjust_compose(struct v4l2_rect *r,
+					   const struct v4l2_mbus_framefmt *fmt)
+{
+	r->top = 0;
+	r->left = 0;
+
+	/* Compose is not possible for JPEG or Bayer formats */
+	if ((fmt->code == MEDIA_BUS_FMT_JPEG_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB8_1X8) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB10_1X10) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB12_1X12) ||
+	    (fmt->code == MEDIA_BUS_FMT_SBGGR14_1X14) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGBRG14_1X14) ||
+	    (fmt->code == MEDIA_BUS_FMT_SGRBG14_1X14) ||
+	    (fmt->code == MEDIA_BUS_FMT_SRGGB14_1X14)) {
+		r->width = fmt->width;
+		r->height = fmt->height;
+		return;
+	}
+
+	/* Adjust height - we can only perform 1/2 decimation */
+	if (r->height <= (fmt->height / 2))
+		r->height = fmt->height / 2;
+	else
+		r->height = fmt->height;
+
+	/* Adjust width - /2 or /4 for 8bits formats and /2 for 16bits formats */
+	if (fmt->code == MEDIA_BUS_FMT_Y8_1X8 && r->width <= (fmt->width / 4))
+		r->width = fmt->width / 4;
+	else if (r->width <= (fmt->width / 2))
+		r->width = fmt->width / 2;
+	else
+		r->width = fmt->width;
+}
+
+static void dcmipp_byteproc_adjust_fmt(struct v4l2_mbus_framefmt *fmt)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_byteproc_pix_map_by_code(fmt->code);
+	if (!vpix)
+		fmt->code = fmt_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT) & ~1;
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_byteproc_init_cfg(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *sd_state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+		struct v4l2_rect *r;
+
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = fmt_default;
+
+		if (IS_SINK(i))
+			r = v4l2_subdev_get_try_compose(sd, sd_state, i);
+		else
+			r = v4l2_subdev_get_try_crop(sd, sd_state, i);
+
+		r->top = 0;
+		r->left = 0;
+		r->width = DCMIPP_FMT_WIDTH_DEFAULT;
+		r->height = DCMIPP_FMT_HEIGHT_DEFAULT;
+	}
+
+	return 0;
+}
+
+static int dcmipp_byteproc_enum_mbus_code(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *sd_state,
+					  struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	const struct dcmipp_byteproc_pix_map *vpix;
+	struct v4l2_mbus_framefmt *sink_fmt;
+
+	if (IS_SINK(code->pad)) {
+		if (code->index >= ARRAY_SIZE(dcmipp_byteproc_pix_map_list))
+			return -EINVAL;
+		vpix = &dcmipp_byteproc_pix_map_list[code->index];
+		code->code = vpix->code;
+	} else {
+		/* byteproc doesn't support transformation on format */
+		if (code->index > 0)
+			return -EINVAL;
+
+		if (code->which == V4L2_SUBDEV_FORMAT_TRY)
+			sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		else
+			sink_fmt = &byteproc->sink_fmt;
+		code->code = sink_fmt->code;
+	}
+
+	return 0;
+}
+
+static int dcmipp_byteproc_enum_frame_size(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *sd_state,
+					   struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_byteproc_pix_map_by_code(fse->code);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_byteproc_get_fmt(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_rect *crop_rect;
+
+	mutex_lock(&byteproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		fmt->format = *v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop_rect = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+	} else {
+		fmt->format = byteproc->sink_fmt;
+		crop_rect = &byteproc->crop;
+	}
+
+	if (IS_SRC(fmt->pad)) {
+		fmt->format.width = crop_rect->width;
+		fmt->format.height = crop_rect->height;
+	}
+
+	mutex_unlock(&byteproc->lock);
+
+	return 0;
+}
+
+static int dcmipp_byteproc_set_fmt(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *sd_state,
+				   struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+	int ret = 0;
+
+	mutex_lock(&byteproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (byteproc->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		sink_fmt = &byteproc->sink_fmt;
+		crop = &byteproc->crop;
+		compose = &byteproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+		compose = v4l2_subdev_get_try_compose(sd, sd_state, 0);
+	}
+
+	if (IS_SRC(fmt->pad)) {
+		fmt->format = *sink_fmt;
+		fmt->format.width = crop->width;
+		fmt->format.height = crop->height;
+	} else {
+		dcmipp_byteproc_adjust_fmt(&fmt->format);
+		crop->top = 0;
+		crop->left = 0;
+		crop->width = fmt->format.width;
+		crop->height = fmt->format.height;
+		*compose = *crop;
+		*sink_fmt = fmt->format;
+	}
+
+out:
+	mutex_unlock(&byteproc->lock);
+
+	return ret;
+}
+
+static int dcmipp_byteproc_get_selection(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	/*
+	 * In the HW, the decimation block is located prior to the crop hence:
+	 * Compose is done on the sink pad
+	 * Crop is done on the src pad
+	 */
+	if ((s->target == V4L2_SEL_TGT_CROP ||
+	     s->target == V4L2_SEL_TGT_CROP_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_CROP_DEFAULT) && IS_SINK(s->pad))
+		return -EINVAL;
+
+	if ((s->target == V4L2_SEL_TGT_COMPOSE ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_DEFAULT) && IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &byteproc->sink_fmt;
+		crop = &byteproc->crop;
+		compose = &byteproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+		compose = v4l2_subdev_get_try_compose(sd, sd_state, 0);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = *compose;
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		s->r = dcmipp_byteproc_get_compose_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		s->r.top = 0;
+		s->r.left = 0;
+		s->r.width = sink_fmt->width;
+		s->r.height = sink_fmt->height;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_byteproc_set_selection(struct v4l2_subdev *sd,
+					 struct v4l2_subdev_state *sd_state,
+					 struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	/*
+	 * In the HW, the decimation block is located prior to the crop hence:
+	 * Compose is done on the sink pad
+	 * Crop is done on the src pad
+	 */
+	if ((s->target == V4L2_SEL_TGT_CROP ||
+	     s->target == V4L2_SEL_TGT_CROP_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_CROP_DEFAULT) && IS_SINK(s->pad))
+		return -EINVAL;
+
+	if ((s->target == V4L2_SEL_TGT_COMPOSE ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_BOUNDS ||
+	     s->target == V4L2_SEL_TGT_COMPOSE_DEFAULT) && IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &byteproc->sink_fmt;
+		crop = &byteproc->crop;
+		compose = &byteproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, sd_state, 0);
+		crop = v4l2_subdev_get_try_crop(sd, sd_state, 1);
+		compose = v4l2_subdev_get_try_compose(sd, sd_state, 0);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_byteproc_adjust_crop(&s->r, compose);
+
+		*crop = s->r;
+
+		dev_dbg(byteproc->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		dcmipp_byteproc_adjust_compose(&s->r, sink_fmt);
+		*compose = s->r;
+		*crop = s->r;
+
+		dev_dbg(byteproc->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			compose->width, compose->height, compose->left, compose->top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const unsigned int dcmipp_frates[] = {1, 2, 4, 8};
+
+static int dcmipp_byteproc_enum_frame_interval
+				(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state,
+				 struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	struct v4l2_fract *sink_interval = &byteproc->sink_interval;
+	unsigned int ratio;
+	int ret = 0;
+
+	if (fie->pad > 1 ||
+	    fie->index >= (IS_SRC(fie->pad) ? ARRAY_SIZE(dcmipp_frates) : 1) ||
+	    fie->width > DCMIPP_FRAME_MAX_WIDTH ||
+	    fie->height > DCMIPP_FRAME_MAX_HEIGHT)
+		return -EINVAL;
+
+	mutex_lock(&byteproc->lock);
+
+	if (IS_SINK(fie->pad)) {
+		fie->interval = *sink_interval;
+		goto out;
+	}
+
+	ratio = dcmipp_frates[fie->index];
+
+	fie->interval.numerator = sink_interval->numerator * ratio;
+	fie->interval.denominator = sink_interval->denominator;
+
+out:
+	mutex_unlock(&byteproc->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_byteproc_pad_ops = {
+	.init_cfg		= dcmipp_byteproc_init_cfg,
+	.enum_mbus_code		= dcmipp_byteproc_enum_mbus_code,
+	.enum_frame_size	= dcmipp_byteproc_enum_frame_size,
+	.enum_frame_interval	= dcmipp_byteproc_enum_frame_interval,
+	.get_fmt		= dcmipp_byteproc_get_fmt,
+	.set_fmt		= dcmipp_byteproc_set_fmt,
+	.get_selection		= dcmipp_byteproc_get_selection,
+	.set_selection		= dcmipp_byteproc_set_selection,
+};
+
+static int dcmipp_byteproc_configure_scale_crop
+			(struct dcmipp_byteproc_device *byteproc)
+{
+	const struct dcmipp_byteproc_pix_map *vpix;
+	u32 hprediv, vprediv;
+	struct v4l2_rect *crop = &byteproc->crop;
+	u32 val = 0;
+
+	/* find output format bpp */
+	vpix = dcmipp_byteproc_pix_map_by_code(byteproc->sink_fmt.code);
+	if (!vpix)
+		return -EINVAL;
+
+	/* clear decimation/crop */
+	reg_clear(byteproc, DCMIPP_P0PPCR, DCMIPP_P0PPCR_BSM_MASK);
+	reg_clear(byteproc, DCMIPP_P0PPCR, DCMIPP_P0PPCR_LSM);
+	reg_write(byteproc, DCMIPP_P0SCSTR, 0);
+	reg_write(byteproc, DCMIPP_P0SCSZR, 0);
+
+	/* Ignore decimation/crop with JPEG */
+	if (vpix->code == MEDIA_BUS_FMT_JPEG_1X8)
+		return 0;
+
+	/* decimation */
+	hprediv = byteproc->sink_fmt.width / byteproc->compose.width;
+	if (hprediv == 4)
+		val |= DCMIPP_P0PPCR_BSM_1_4 << DCMIPP_P0PPCR_BSM_SHIFT;
+	else if ((vpix->code == MEDIA_BUS_FMT_Y8_1X8) && (hprediv == 2))
+		val |= DCMIPP_P0PPCR_BSM_1_2 << DCMIPP_P0PPCR_BSM_SHIFT;
+	else if (hprediv == 2)
+		val |= DCMIPP_P0PPCR_BSM_2_4 << DCMIPP_P0PPCR_BSM_SHIFT;
+
+	vprediv = byteproc->sink_fmt.height / byteproc->compose.height;
+	if (vprediv == 2)
+		val |= DCMIPP_P0PPCR_LSM | DCMIPP_P0PPCR_OELS;
+
+	/* decimate using bytes and lines skipping */
+	if (val) {
+		reg_set(byteproc, DCMIPP_P0PPCR, val);
+
+		dev_dbg(byteproc->dev, "decimate to %dx%d [prediv=%dx%d]\n",
+			byteproc->compose.width, byteproc->compose.height, hprediv, vprediv);
+	}
+
+	dev_dbg(byteproc->dev, "crop to %dx%d\n", crop->width, crop->height);
+
+	/* expressed in 32-bits words on X axis, lines on Y axis */
+	reg_write(byteproc, DCMIPP_P0SCSTR,
+		  (((crop->left * vpix->bpp) / 4) << DCMIPP_P0SCSTR_HSTART_SHIFT) |
+		  (crop->top << DCMIPP_P0SCSTR_VSTART_SHIFT));
+	reg_write(byteproc, DCMIPP_P0SCSZR,
+		  DCMIPP_P0SCSZR_ENABLE |
+		  (((crop->width * vpix->bpp) / 4) << DCMIPP_P0SCSZR_HSIZE_SHIFT) |
+		  (crop->height << DCMIPP_P0SCSZR_VSIZE_SHIFT));
+
+	return 0;
+}
+
+static void dcmipp_byteproc_configure_framerate
+			(struct dcmipp_byteproc_device *byteproc)
+{
+	/* Frame skipping */
+	reg_clear(byteproc, DCMIPP_P0FCTCR, DCMIPP_P0FCTCR_FRATE_MASK);
+	reg_set(byteproc, DCMIPP_P0FCTCR, byteproc->frate);
+}
+
+static int dcmipp_byteproc_g_frame_interval(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_frame_interval *fi)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+
+	if (IS_SINK(fi->pad))
+		fi->interval = byteproc->sink_interval;
+	else
+		fi->interval = byteproc->src_interval;
+
+	return 0;
+}
+
+static int dcmipp_byteproc_s_frame_interval(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_frame_interval *fi)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&byteproc->lock);
+
+	if (byteproc->streaming) {
+		mutex_unlock(&byteproc->lock);
+		return -EBUSY;
+	}
+
+	if (fi->interval.numerator == 0 || fi->interval.denominator == 0)
+		fi->interval = byteproc->sink_interval;
+
+	if (IS_SINK(fi->pad)) {
+		/*
+		 * Setting sink frame interval resets frame skipping.
+		 * Sink frame interval is propagated to src.
+		 */
+		byteproc->frate = 0;
+		byteproc->sink_interval = fi->interval;
+		byteproc->src_interval = byteproc->sink_interval;
+	} else {
+		unsigned int ratio;
+
+		/* Normalize ratio */
+		ratio = (byteproc->sink_interval.denominator *
+			 fi->interval.numerator) /
+			(byteproc->sink_interval.numerator *
+			 fi->interval.denominator);
+
+		/* Hardware can skip 1 frame over 2, 4 or 8 */
+		byteproc->frate = ratio >= 8 ? 3 :
+				  ratio >= 4 ? 2 :
+				  ratio >= 2 ? 1 : 0;
+
+		ratio = dcmipp_frates[byteproc->frate];
+
+		/* Adjust src frame interval to what hardware can really do */
+		byteproc->src_interval.numerator =
+			byteproc->sink_interval.numerator * ratio;
+		byteproc->src_interval.denominator =
+			byteproc->sink_interval.denominator;
+	}
+
+	mutex_unlock(&byteproc->lock);
+
+	return 0;
+}
+
+#define STOP_TIMEOUT_US 1000
+#define POLL_INTERVAL_US  50
+static int dcmipp_byteproc_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_byteproc_device *byteproc = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&byteproc->lock);
+	if (enable) {
+		dcmipp_byteproc_configure_framerate(byteproc);
+
+		ret = dcmipp_byteproc_configure_scale_crop(byteproc);
+	}
+	mutex_unlock(&byteproc->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_byteproc_video_ops = {
+	.g_frame_interval = dcmipp_byteproc_g_frame_interval,
+	.s_frame_interval = dcmipp_byteproc_s_frame_interval,
+	.s_stream = dcmipp_byteproc_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_byteproc_ops = {
+	.pad = &dcmipp_byteproc_pad_ops,
+	.video = &dcmipp_byteproc_video_ops,
+};
+
+void dcmipp_byteproc_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_byteproc_device *byteproc =
+			container_of(ved, struct dcmipp_byteproc_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &byteproc->sd);
+	mutex_destroy(&byteproc->lock);
+	kfree(byteproc);
+}
+
+struct dcmipp_ent_device *
+dcmipp_byteproc_ent_init(struct device *dev, const char *entity_name,
+			 struct v4l2_device *v4l2_dev, void __iomem *regs)
+{
+	struct dcmipp_byteproc_device *byteproc;
+	struct v4l2_rect r = {
+		.top = 0,
+		.left = 0,
+		.width = DCMIPP_FMT_WIDTH_DEFAULT,
+		.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	};
+	struct v4l2_fract interval = {
+		.numerator = 1,
+		.denominator = 30,
+	};
+	int ret;
+
+	/* Allocate the byteproc struct */
+	byteproc = kzalloc(sizeof(*byteproc), GFP_KERNEL);
+	if (!byteproc)
+		return ERR_PTR(-ENOMEM);
+
+	byteproc->regs = regs;
+
+	/* Initialize the lock */
+	mutex_init(&byteproc->lock);
+
+	/* Initialize the frame format */
+	byteproc->sink_fmt = fmt_default;
+	byteproc->crop = r;
+	byteproc->compose = r;
+	byteproc->src_interval = interval;
+	byteproc->sink_interval = interval;
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&byteproc->ved, &byteproc->sd,
+				     v4l2_dev,
+				     entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 2,
+				     (const unsigned long[2]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     NULL,
+				     &dcmipp_byteproc_ops,
+				     NULL, NULL);
+	if (ret) {
+		mutex_destroy(&byteproc->lock);
+		kfree(byteproc);
+		return ERR_PTR(ret);
+	}
+
+	byteproc->dev = dev;
+
+	return &byteproc->ved;
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.c
new file mode 100644
index 000000000..77f483abd
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.c
@@ -0,0 +1,361 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-colorconv.h"
+
+/* Macro for negative coefficient, 11 bits coded */
+#define N11(val) (((val) ^ 0x7FF) + 1)
+/* Macro for added value, 10 bits coded */
+#define N10(val) (((val) ^ 0x3FF) + 1)
+
+/* Macro to convert row matrix to DCMIPP PxCCCyy register value */
+#define ROW(c1, c2, c3, add) ((c2) << 16 | (c1)), ((add) << 16 | (c3))
+
+static const u32 rgbfull_to_yuv601full[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(110),	N11(21),	128),
+/*  Y */ ROW(77,	150,		29,		0),
+/* Cb */ ROW(N11(44),	N11(87),	131,		128),
+};
+
+static const u32 rgbfull_to_yuv601lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(112,	N11(94),	N11(18),	128),
+/*  Y */ ROW(66,	129,		25,		16),
+/* Cb */ ROW(N11(38),	N11(74),	112,		128),
+};
+
+static const u32 rgbfull_to_yuv709full[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(119),	N11(12),	128),
+/*  Y */ ROW(55,	183,		18,		0),
+/* Cb */ ROW(N11(30),	N11(101),	131,		128),
+};
+
+static const u32 rgbfull_to_yuv709lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(112,	N11(102),	N11(10),	128),
+/*  Y */ ROW(47,	157,		16,		16),
+/* Cb */ ROW(N11(26),	N11(87),	112,		128),
+};
+
+static const u32 rgblim_to_yuv601lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(110),	N11(21),	128),
+/*  Y */ ROW(77,	150,		29,		0),
+/* Cb */ ROW(N11(44),	N11(87),	131,		128),
+};
+
+static const u32 rgblim_to_yuv709lim[] = {
+/*	     R		G		B		Add */
+/* Cr */ ROW(131,	N11(119),	N11(12),	128),
+/*  Y */ ROW(55,	183,		18,		0),
+/* Cb */ ROW(N11(30),	N11(101),	131,		128),
+};
+
+static const u32 yuv601full_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(351,	256,		0,		N10(175)),
+/* G */  ROW(N11(179),	256,		N11(86),	132),
+/* B */  ROW(0,		256,		443,		N10(222)),
+};
+
+static const u32 yuv601lim_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(409,	298,		0,		N10(223)),
+/* G */  ROW(N11(208),	298,		N11(100),	135),
+/* B */  ROW(0,		298,		517,		N10(277)),
+};
+
+static const u32 yuv601lim_to_rgblim[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(351,	256,		0,		N10(175)),
+/* G */  ROW(N11(179),	256,		N11(86),	132),
+/* B */  ROW(0,		256,		443,		N10(222)),
+};
+
+static const u32 yuv709full_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(394,	256,		0,		N10(197)),
+/* G */  ROW(N11(118),	256,		N11(47),	82),
+/* B */  ROW(0,		256,		456,		N10(232)),
+};
+
+static const u32 yuv709lim_to_rgbfull[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(459,	298,		0,		N10(248)),
+/* G */  ROW(N11(137),	298,		N11(55),	77),
+/* B */  ROW(0,		298,		541,		N10(289)),
+};
+
+static const u32 yuv709lim_to_rgblim[] = {
+/*	     Cr		Y		Cb		Add */
+/* R */  ROW(394,	256,		0,		N10(197)),
+/* G */  ROW(N11(118),	256,		N11(47),	82),
+/* B */  ROW(0,		256,		465,		N10(232)),
+};
+
+/* cconv_matrices[src_fmt][src_range][sink_fmt][sink_range] */
+static const u32 *cconv_matrices[3][2][3][2] = {
+	/* RGB */
+	{
+		/* RGB full range */
+		{
+			/* RGB full range => RGB */
+			{
+				/* RGB full range => RGB full range */
+				NULL,
+				/* RGB full range => RGB limited range */
+				NULL,
+			},
+			/* RGB full range => YUV601 */
+			{
+				/* RGB full range => YUV601 full range */
+				rgbfull_to_yuv601full,
+				/* RGB full range => YUV601 limited range */
+				rgbfull_to_yuv601lim,
+			},
+			/* RGB full range => YUV709 */
+			{
+				/* RGB full range => YUV709 full range */
+				rgbfull_to_yuv709full,
+				/* RGB full range => YUV709 limited range */
+				rgbfull_to_yuv709lim,
+			},
+		},
+		/* RGB limited range */
+		{
+			/* RGB limited range => RGB */
+			{
+				/* RGB limited range => RGB full range */
+				NULL,
+				/* RGB limited range => RGB limited range */
+				NULL,
+			},
+			/* RGB limited range => YUV601 */
+			{
+				/* RGB limited range => YUV601 full range */
+				NULL,
+				/* RGB limited range => YUV601 limited range */
+				rgblim_to_yuv601lim,
+			},
+			/* RGB limited range => YUV709 */
+			{
+				/* RGB limited range => YUV709 full range */
+				NULL,
+				/* RGB limited range => YUV709 limited range */
+				rgblim_to_yuv709lim,
+			},
+		},
+	},
+	/* YUV601 */
+	{
+		/* YUV601 full range */
+		{
+			/* YUV601 full range => RGB */
+			{
+				/* YUV601 full range => RGB full range */
+				yuv601full_to_rgbfull,
+				/* YUV601 full range => RGB limited range */
+				NULL,
+			},
+			/* YUV601 full range => YUV601 */
+			{
+				/* YUV601 full range => YUV601 full range */
+				NULL,
+				/* YUV601 full range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV601 full range => YUV709 */
+			{
+				/* YUV601 full range => YUV709 full range */
+				NULL,
+				/* YUV601 full range => YUV709 limited range */
+				NULL,
+			},
+		},
+		/* YUV601 limited range */
+		{
+			/* YUV601 limited range => RGB */
+			{
+				/* YUV601 limited range => RGB full range */
+				yuv601lim_to_rgbfull,
+				/* YUV601 limited range => RGB limited range */
+				yuv601lim_to_rgblim,
+			},
+			/* YUV601 limited range => YUV601 */
+			{
+				/* YUV601 limited range => YUV601 full range */
+				NULL,
+				/* YUV601 limited range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV601 limited range => YUV709 */
+			{
+				/* YUV601 limited range => YUV709 full range */
+				NULL,
+				/* YUV601 limited range => YUV709 limited range */
+				NULL,
+			},
+		},
+	},
+	/* YUV709 */
+	{
+		/* YUV709 full range */
+		{
+			/* YUV709 full range => RGB */
+			{
+				/* YUV709 full range => RGB full range */
+				yuv709full_to_rgbfull,
+				/* YUV709 full range => RGB limited range */
+				NULL,
+			},
+			/* YUV709 full range => YUV601 */
+			{
+				/* YUV709 full range => YUV601 full range */
+				NULL,
+				/* YUV709 full range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV709 full range => YUV709 */
+			{
+				/* YUV709 full range => YUV709 full range */
+				NULL,
+				/* YUV709 full range => YUV709 limited range */
+				NULL,
+			},
+		},
+		/* YUV709 limited range */
+		{
+			/* YUV709 limited range => RGB */
+			{
+				/* YUV709 limited range => RGB full range */
+				yuv709lim_to_rgbfull,
+				/* YUV709 limited range => RGB limited range */
+				yuv709lim_to_rgblim,
+			},
+			/* YUV709 limited range => YUV601 */
+			{
+				/* YUV709 limited range => YUV601 full range */
+				NULL,
+				/* YUV709 limited range => YUV601 limited range */
+				NULL,
+			},
+			/* YUV709 limited range => YUV709 */
+			{
+				/* YUV709 limited range => YUV709 full range */
+				NULL,
+				/* YUV709 limited range => YUV709 limited range */
+				NULL,
+			},
+		},
+	},
+};
+
+enum cconv_fmt {
+	FMT_RGB = 0,
+	FMT_YUV601,
+	FMT_YUV709
+};
+
+static inline enum cconv_fmt to_cconv_fmt(struct v4l2_mbus_framefmt *fmt)
+{
+	/* YUV format codes are within the 0x2xxx */
+	if (fmt->code >= MEDIA_BUS_FMT_Y8_1X8 &&
+	    fmt->code < MEDIA_BUS_FMT_SBGGR8_1X8) {
+		if (fmt->ycbcr_enc == V4L2_YCBCR_ENC_709)
+			return FMT_YUV709;
+		else
+			return FMT_YUV601;
+	}
+
+	/* All other formats are referred as RGB, indeed, demosaicing bloc
+	 * generate RGB format
+	 */
+	return FMT_RGB;
+};
+
+#define FMT_STR(f) ({					\
+	typeof(f) __f = (f);				\
+	(__f) == FMT_RGB ? "RGB" :			\
+	(__f) == FMT_YUV601 ? "YUV601" :		\
+	(__f) == FMT_YUV709 ? "YUV709" : "?"; })
+
+enum cconv_range {
+	RANGE_FULL = 0,
+	RANGE_LIMITED,
+};
+
+static inline enum cconv_range to_cconv_range(struct v4l2_mbus_framefmt *fmt)
+{
+	if (fmt->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+		return RANGE_FULL;
+
+	return RANGE_LIMITED;
+};
+
+#define RANGE_STR(range) ((range) == RANGE_FULL ? "full" : "limited")
+
+int dcmipp_colorconv_configure(struct device *dev,
+			       struct v4l2_mbus_framefmt *sink,
+			       struct v4l2_mbus_framefmt *src,
+			       struct dcmipp_colorconv_config *cfg)
+{
+	const u32 *cconv_matrix;
+	enum cconv_fmt sink_fmt;
+	enum cconv_range sink_range;
+	enum cconv_fmt src_fmt;
+	enum cconv_range src_range;
+	int i;
+
+	sink_fmt = to_cconv_fmt(sink);
+	sink_range = to_cconv_range(sink);
+	src_fmt = to_cconv_fmt(src);
+	src_range = to_cconv_range(src);
+
+	if (sink_fmt == src_fmt &&
+	    sink_range == src_range) {
+		cfg->enable = false;
+		return 0;
+	}
+
+	/* color conversion */
+	cconv_matrix = cconv_matrices[sink_fmt][sink_range][src_fmt][src_range];
+
+	dev_dbg(dev, "cconv_matrices[%d][%d][%d][%d]=%p\n",
+		sink_fmt, sink_range, src_fmt, src_range, cconv_matrix);
+	if (!cconv_matrix) {
+		dev_err(dev, "Unsupported color conversion %s-%s => %s-%s\n",
+			FMT_STR(sink_fmt), RANGE_STR(sink_range),
+			FMT_STR(src_fmt), RANGE_STR(src_range));
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "color conversion %s-%s => %s-%s\n",
+		FMT_STR(sink_fmt), RANGE_STR(sink_range),
+		FMT_STR(src_fmt), RANGE_STR(src_range));
+
+	if (src_range == RANGE_LIMITED) {
+		cfg->clamping = true;
+		if (src->code >= MEDIA_BUS_FMT_Y8_1X8 && src->code < MEDIA_BUS_FMT_SBGGR8_1X8)
+			cfg->clamping_as_rgb = false;
+		else
+			cfg->clamping_as_rgb = true;
+	}
+
+	cfg->enable = true;
+
+	for (i = 0; i < ARRAY_SIZE(cfg->conv_matrix); i++)
+		cfg->conv_matrix[i] = cconv_matrix[i];
+
+	return 0;
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.h b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.h
new file mode 100644
index 000000000..a7205733b
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-colorconv.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#ifndef _DCMIPP_COLORCONV_H_
+#define _DCMIPP_COLORCONV_H_
+
+struct dcmipp_colorconv_config {
+	unsigned int conv_matrix[6];
+	bool clamping;
+	bool clamping_as_rgb;
+	bool enable;
+};
+
+int dcmipp_colorconv_configure(struct device *dev,
+			       struct v4l2_mbus_framefmt *sink,
+			       struct v4l2_mbus_framefmt *src,
+			       struct dcmipp_colorconv_config *cfg);
+
+#endif
+
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.c
new file mode 100644
index 000000000..45995563c
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.c
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include "dcmipp-common.h"
+
+/* Helper function to allocate and initialize pads */
+struct media_pad *dcmipp_pads_init(u16 num_pads, const unsigned long *pads_flag)
+{
+	struct media_pad *pads;
+	unsigned int i;
+
+	/* Allocate memory for the pads */
+	pads = kcalloc(num_pads, sizeof(*pads), GFP_KERNEL);
+	if (!pads)
+		return ERR_PTR(-ENOMEM);
+
+	/* Initialize the pads */
+	for (i = 0; i < num_pads; i++) {
+		pads[i].index = i;
+		pads[i].flags = pads_flag[i];
+	}
+
+	return pads;
+}
+
+int dcmipp_link_validate(struct media_link *link)
+{
+	/* TODO */
+	return 0;
+}
+
+static const struct media_entity_operations dcmipp_ent_sd_mops = {
+	.link_validate = dcmipp_link_validate,
+};
+
+int dcmipp_ent_sd_register(struct dcmipp_ent_device *ved,
+			   struct v4l2_subdev *sd,
+			   struct v4l2_device *v4l2_dev,
+			   const char *const name,
+			   u32 function,
+			   u16 num_pads,
+			   const unsigned long *pads_flag,
+			   const struct v4l2_subdev_internal_ops *sd_int_ops,
+			   const struct v4l2_subdev_ops *sd_ops,
+			   irq_handler_t handler,
+			   irq_handler_t thread_fn)
+{
+	int ret;
+
+	/* Allocate the pads. Should be released from the sd_int_op release */
+	ved->pads = dcmipp_pads_init(num_pads, pads_flag);
+	if (IS_ERR(ved->pads))
+		return PTR_ERR(ved->pads);
+
+	/* Fill the dcmipp_ent_device struct */
+	ved->ent = &sd->entity;
+
+	/* Initialize the subdev */
+	v4l2_subdev_init(sd, sd_ops);
+	sd->internal_ops = sd_int_ops;
+	sd->entity.function = function;
+	sd->entity.ops = &dcmipp_ent_sd_mops;
+	sd->owner = THIS_MODULE;
+	strscpy(sd->name, name, sizeof(sd->name));
+	v4l2_set_subdevdata(sd, ved);
+
+	/* Expose this subdev to user space */
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	if (sd->ctrl_handler)
+		sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	/* Initialize the media entity */
+	ret = media_entity_pads_init(&sd->entity, num_pads, ved->pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Register the subdev with the v4l2 and the media framework */
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret) {
+		dev_err(v4l2_dev->dev,
+			"%s: subdev register failed (err=%d)\n",
+			name, ret);
+		goto err_clean_m_ent;
+	}
+
+	ved->handler = handler;
+	ved->thread_fn = thread_fn;
+
+	return 0;
+
+err_clean_m_ent:
+	media_entity_cleanup(&sd->entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(ved->pads);
+	return ret;
+}
+
+void dcmipp_ent_sd_unregister(struct dcmipp_ent_device *ved, struct v4l2_subdev *sd)
+{
+	media_entity_cleanup(ved->ent);
+	v4l2_device_unregister_subdev(sd);
+	dcmipp_pads_cleanup(ved->pads);
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.h b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.h
new file mode 100644
index 000000000..5bcd8c79a
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-common.h
@@ -0,0 +1,257 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#ifndef _DCMIPP_COMMON_H_
+#define _DCMIPP_COMMON_H_
+
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <media/media-device.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define DCMIPP_PDEV_NAME "dcmipp"
+
+/* DCMIPP-specific controls */
+#define DCMIPP_CID_DCMIPP_BASE		(0x00f00000 | 0xf000)
+#define DCMIPP_CID_DCMIPP_CLASS		(0x00f00000 | 1)
+#define DCMIPP_CID_TEST_PATTERN		(DCMIPP_CID_DCMIPP_BASE + 0)
+
+#define DCMIPP_FRAME_MAX_WIDTH 4096
+#define DCMIPP_FRAME_MAX_HEIGHT 2160
+#define DCMIPP_FRAME_MIN_WIDTH 16
+#define DCMIPP_FRAME_MIN_HEIGHT 16
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_FRAME_INDEX(lin, col, width, bpp) \
+	(((lin) * (width) + (col)) * (bpp))
+
+#define DCMIPP_COLORSPACE_DEFAULT	V4L2_COLORSPACE_REC709
+#define DCMIPP_YCBCR_ENC_DEFAULT	V4L2_YCBCR_ENC_DEFAULT
+#define DCMIPP_QUANTIZATION_DEFAULT	V4L2_QUANTIZATION_DEFAULT
+#define DCMIPP_XFER_FUNC_DEFAULT	V4L2_XFER_FUNC_DEFAULT
+
+/**
+ * struct dcmipp_colorimetry_clamp - Adjust colorimetry parameters
+ *
+ * @fmt:		the pointer to struct v4l2_pix_format or
+ *			struct v4l2_mbus_framefmt
+ *
+ * Entities must check if colorimetry given by the userspace is valid, if not
+ * then set them as DEFAULT
+ */
+#define dcmipp_colorimetry_clamp(fmt)					\
+do {									\
+	if ((fmt)->colorspace == V4L2_COLORSPACE_DEFAULT ||		\
+	    (fmt)->colorspace > V4L2_COLORSPACE_DCI_P3) {		\
+		(fmt)->colorspace = DCMIPP_COLORSPACE_DEFAULT;		\
+		(fmt)->ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT;		\
+		(fmt)->quantization = DCMIPP_QUANTIZATION_DEFAULT;	\
+		(fmt)->xfer_func = DCMIPP_XFER_FUNC_DEFAULT;		\
+	}								\
+	if ((fmt)->ycbcr_enc > V4L2_YCBCR_ENC_SMPTE240M)		\
+		(fmt)->ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT;		\
+	if ((fmt)->quantization > V4L2_QUANTIZATION_LIM_RANGE)		\
+		(fmt)->quantization = DCMIPP_QUANTIZATION_DEFAULT;	\
+	if ((fmt)->xfer_func > V4L2_XFER_FUNC_SMPTE2084)		\
+		(fmt)->xfer_func = DCMIPP_XFER_FUNC_DEFAULT;		\
+} while (0)
+
+/**
+ * struct dcmipp_ent_device - core struct that represents a node in the topology
+ *
+ * @ent:		the pointer to struct media_entity for the node
+ * @pads:		the list of pads of the node
+ * @process_frame:	callback send a frame to that node
+ * @vdev_get_format:	callback that returns the current format a pad, used
+ *			only when is_media_entity_v4l2_video_device(ent) returns
+ *			true
+ *
+ * Each node of the topology must create a dcmipp_ent_device struct. Depending on
+ * the node it will be of an instance of v4l2_subdev or video_device struct
+ * where both contains a struct media_entity.
+ * Those structures should embedded the dcmipp_ent_device struct through
+ * v4l2_set_subdevdata() and video_set_drvdata() respectivaly, allowing the
+ * dcmipp_ent_device struct to be retrieved from the corresponding struct
+ * media_entity
+ */
+struct dcmipp_ent_device {
+	struct media_entity *ent;
+	struct media_pad *pads;
+	void * (*process_frame)(struct dcmipp_ent_device *ved,
+				const void *frame);
+	void (*vdev_get_format)(struct dcmipp_ent_device *ved,
+				struct v4l2_pix_format *fmt);
+
+	/* Parallel input device */
+	struct v4l2_mbus_config_parallel	bus;
+	enum v4l2_mbus_type		bus_type;
+	irq_handler_t handler;
+	irqreturn_t handler_ret;
+	u32 cmsr2;
+	irq_handler_t thread_fn;
+};
+
+/**
+ * dcmipp_pads_init - initialize pads
+ *
+ * @num_pads:	number of pads to initialize
+ * @pads_flags:	flags to use in each pad
+ *
+ * Helper functions to allocate/initialize pads
+ */
+struct media_pad *dcmipp_pads_init(u16 num_pads,
+				   const unsigned long *pads_flag);
+
+/**
+ * dcmipp_pads_cleanup - free pads
+ *
+ * @pads: pointer to the pads
+ *
+ * Helper function to free the pads initialized with dcmipp_pads_init
+ */
+static inline void dcmipp_pads_cleanup(struct media_pad *pads)
+{
+	kfree(pads);
+}
+
+/**
+ * dcmipp_ent_sd_register - initialize and register a subdev node
+ *
+ * @ved:	the dcmipp_ent_device struct to be initialize
+ * @sd:		the v4l2_subdev struct to be initialize and registered
+ * @v4l2_dev:	the v4l2 device to register the v4l2_subdev
+ * @name:	name of the sub-device. Please notice that the name must be
+ *		unique.
+ * @function:	media entity function defined by MEDIA_ENT_F_* macros
+ * @num_pads:	number of pads to initialize
+ * @pads_flag:	flags to use in each pad
+ * @sd_int_ops:	pointer to &struct v4l2_subdev_internal_ops
+ * @sd_ops:	pointer to &struct v4l2_subdev_ops.
+ *
+ * Helper function initialize and register the struct dcmipp_ent_device and struct
+ * v4l2_subdev which represents a subdev node in the topology
+ */
+int dcmipp_ent_sd_register(struct dcmipp_ent_device *ved,
+			   struct v4l2_subdev *sd,
+			   struct v4l2_device *v4l2_dev,
+			   const char *const name,
+			   u32 function,
+			   u16 num_pads,
+			   const unsigned long *pads_flag,
+			   const struct v4l2_subdev_internal_ops *sd_int_ops,
+			   const struct v4l2_subdev_ops *sd_ops,
+			   irq_handler_t handler,
+			   irq_handler_t thread_fn);
+
+/**
+ * dcmipp_ent_sd_unregister - cleanup and unregister a subdev node
+ *
+ * @ved:	the dcmipp_ent_device struct to be cleaned up
+ * @sd:		the v4l2_subdev struct to be unregistered
+ *
+ * Helper function cleanup and unregister the struct dcmipp_ent_device and struct
+ * v4l2_subdev which represents a subdev node in the topology
+ */
+void dcmipp_ent_sd_unregister(struct dcmipp_ent_device *ved,
+			      struct v4l2_subdev *sd);
+
+/**
+ * dcmipp_link_validate - validates a media link
+ *
+ * @link: pointer to &struct media_link
+ *
+ * This function call validates if a media link is valid for streaming.
+ */
+int dcmipp_link_validate(struct media_link *link);
+
+#define reg_write(device, reg, val) \
+	(reg_write_dbg((device)->dev, #reg, (device)->regs, (reg), (val)))
+#define reg_read(device, reg) \
+	 (reg_read_dbg((device)->dev, #reg, (device)->regs, (reg)))
+#define reg_set(device, reg, mask) \
+	 (reg_set_dbg((device)->dev, #reg, (device)->regs, (reg), (mask)))
+#define reg_clear(device, reg, mask) \
+	 (reg_clear_dbg((device)->dev, #reg, (device)->regs, (reg), (mask)))
+
+static inline u32 reg_read_dbg(struct device *dev, const char *regname,
+			       void __iomem *base, u32 reg)
+{
+	u32 val = readl_relaxed(base + reg);
+
+	dev_dbg(dev, "RD  %s %#10.8x\n", regname, val);
+	return val;
+}
+
+static inline void reg_write_dbg(struct device *dev, const char *regname,
+				 void __iomem *base, u32 reg, u32 val)
+{
+	dev_dbg(dev, "WR  %s %#10.8x\n", regname, val);
+	writel_relaxed(val, base + reg);
+}
+
+static inline void reg_set_dbg(struct device *dev, const char *regname,
+			       void __iomem *base, u32 reg, u32 mask)
+{
+	dev_dbg(dev, "SET %s %#10.8x\n", regname, mask);
+	reg_write_dbg(dev, regname, base, reg, readl_relaxed(base + reg) | mask);
+}
+
+static inline void reg_clear_dbg(struct device *dev, const char *regname,
+				 void __iomem *base, u32 reg, u32 mask)
+{
+	dev_dbg(dev, "CLR %s %#10.8x\n", regname, mask);
+	reg_write_dbg(dev, regname, base, reg, readl_relaxed(base + reg) & ~mask);
+}
+
+/* DCMIPP subdev init / release entry points */
+struct dcmipp_ent_device *dcmipp_inp_ent_init(struct device *dev,
+					      const char *entity_name,
+					      struct v4l2_device *v4l2_dev,
+					      void __iomem *regs);
+void dcmipp_inp_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *
+dcmipp_byteproc_ent_init(struct device *dev, const char *entity_name,
+			 struct v4l2_device *v4l2_dev, void __iomem *regs);
+void dcmipp_byteproc_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *dcmipp_bytecap_ent_init(struct device *dev,
+						  const char *entity_name,
+						  struct v4l2_device *v4l2_dev,
+						  void __iomem *regs);
+void dcmipp_bytecap_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *dcmipp_isp_ent_init(struct device *dev,
+					      const char *entity_name,
+					      struct v4l2_device *v4l2_dev,
+					      void __iomem *regs);
+void dcmipp_isp_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *dcmipp_pixelproc_ent_init(struct device *dev,
+						    const char *entity_name,
+						    struct v4l2_device *v4l2_dev,
+						    void __iomem *regs);
+void dcmipp_pixelproc_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *dcmipp_pixelcap_ent_init(struct device *dev,
+						   const char *entity_name,
+						   struct v4l2_device *v4l2_dev,
+						   void __iomem *regs);
+void dcmipp_pixelcap_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *dcmipp_statcap_ent_init(struct device *dev,
+						  const char *entity_name,
+						  struct v4l2_device *v4l2_dev,
+						  void __iomem *regs);
+void dcmipp_statcap_ent_release(struct dcmipp_ent_device *ved);
+struct dcmipp_ent_device *dcmipp_isp_params_ent_init(struct device *dev,
+						     const char *entity_name,
+						     struct v4l2_device *v4l2_dev,
+						     void __iomem *regs);
+void dcmipp_isp_params_ent_release(struct dcmipp_ent_device *ved);
+
+#endif
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
new file mode 100644
index 000000000..b6c316f47
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-core.c
@@ -0,0 +1,693 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/media-device.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-mc.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_MDEV_MODEL_NAME "DCMIPP MDEV"
+
+#define DCMIPP_ENT_LINK(src, srcpad, sink, sinkpad, link_flags) {	\
+	.src_ent = src,						\
+	.src_pad = srcpad,					\
+	.sink_ent = sink,					\
+	.sink_pad = sinkpad,					\
+	.flags = link_flags,					\
+}
+
+#define DCMIPP_CMHWCFGR (0x200)
+#define DCMIPP_CMSR2 (0x3F8)
+#define DCMIPP_P0HWCFGR (0x400)
+#define DCMIPP_VERR (0xFF4)
+
+struct dcmipp_device {
+	/* The platform device */
+	struct platform_device		pdev;
+	struct device			*dev;
+
+	/* Hardware resources */
+	struct reset_control		*rstc;
+	void __iomem			*regs;
+	struct clk			*mclk;
+	struct clk			*kclk;
+
+	/* The pipeline configuration */
+	const struct dcmipp_pipeline_config	*pipe_cfg;
+
+	/* The Associated media_device parent */
+	struct media_device		mdev;
+
+	/* Internal v4l2 parent device*/
+	struct v4l2_device		v4l2_dev;
+
+	/* Entities */
+	struct dcmipp_ent_device	**entity;
+
+	struct v4l2_async_notifier	notifier;
+};
+
+static inline struct dcmipp_device *notifier_to_dcmipp(struct v4l2_async_notifier *n)
+{
+	return container_of(n, struct dcmipp_device, notifier);
+}
+
+/* Structure which describes individual configuration for each entity */
+struct dcmipp_ent_config {
+	const char *name;
+	struct dcmipp_ent_device *(*init)
+		(struct device *dev, const char *entity_name,
+		 struct v4l2_device *v4l2_dev, void __iomem *regs);
+	void (*release)(struct dcmipp_ent_device *ved);
+};
+
+/* Structure which describes links between entities */
+struct dcmipp_ent_link {
+	unsigned int src_ent;
+	u16 src_pad;
+	unsigned int sink_ent;
+	u16 sink_pad;
+	u32 flags;
+};
+
+/* Structure which describes the whole topology */
+struct dcmipp_pipeline_config {
+	const struct dcmipp_ent_config *ents;
+	size_t num_ents;
+	const struct dcmipp_ent_link *links;
+	size_t num_links;
+	u32 hw_revision;
+};
+
+/* --------------------------------------------------------------------------
+ * Topology Configuration
+ */
+
+static const struct dcmipp_ent_config stm32mp13_ent_config[] = {
+	{
+		.name = "dcmipp_input",
+		.init = dcmipp_inp_ent_init,
+		.release = dcmipp_inp_ent_release,
+	},
+	{
+		.name = "dcmipp_dump_postproc",
+		.init = dcmipp_byteproc_ent_init,
+		.release = dcmipp_byteproc_ent_release,
+	},
+	{
+		.name = "dcmipp_dump_capture",
+		.init = dcmipp_bytecap_ent_init,
+		.release = dcmipp_bytecap_ent_release,
+	},
+};
+
+#define ID_INPUT 0
+#define ID_DUMP_BYTEPROC 1
+#define ID_DUMP_CAPTURE 2
+
+static const struct dcmipp_ent_link stm32mp13_ent_links[] = {
+	DCMIPP_ENT_LINK(ID_INPUT,	  1, ID_DUMP_BYTEPROC, 0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_DUMP_BYTEPROC, 1, ID_DUMP_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+};
+
+#define DCMIPP_STM32MP13_VERR	0x10
+static const struct dcmipp_pipeline_config stm32mp13_pipe_cfg = {
+	.ents		= stm32mp13_ent_config,
+	.num_ents	= ARRAY_SIZE(stm32mp13_ent_config),
+	.links		= stm32mp13_ent_links,
+	.num_links	= ARRAY_SIZE(stm32mp13_ent_links),
+	.hw_revision	= DCMIPP_STM32MP13_VERR
+};
+
+#define	ID_MAIN_ISP 3
+#define	ID_MAIN_POSTPROC 4
+#define	ID_MAIN_CAPTURE	5
+#define	ID_AUX_POSTPROC 6
+#define	ID_AUX_CAPTURE 7
+#define	ID_ISP_STAT_CAPTURE 8
+#define	ID_ISP_PARAMS_OUTPUT 9
+static const struct dcmipp_ent_config stm32mp25_ent_config[] = {
+	{
+		.name = "dcmipp_input",
+		.init = dcmipp_inp_ent_init,
+		.release = dcmipp_inp_ent_release,
+	},
+	{
+		.name = "dcmipp_dump_postproc",
+		.init = dcmipp_byteproc_ent_init,
+		.release = dcmipp_byteproc_ent_release,
+	},
+	{
+		.name = "dcmipp_dump_capture",
+		.init = dcmipp_bytecap_ent_init,
+		.release = dcmipp_bytecap_ent_release,
+	},
+	{
+		.name = "dcmipp_main_isp",
+		.init = dcmipp_isp_ent_init,
+		.release = dcmipp_isp_ent_release,
+	},
+	{
+		.name = "dcmipp_main_postproc",
+		.init = dcmipp_pixelproc_ent_init,
+		.release = dcmipp_pixelproc_ent_release,
+	},
+	{
+		.name = "dcmipp_main_capture",
+		.init = dcmipp_pixelcap_ent_init,
+		.release = dcmipp_pixelcap_ent_release,
+	},
+	{
+		.name = "dcmipp_aux_postproc",
+		.init = dcmipp_pixelproc_ent_init,
+		.release = dcmipp_pixelproc_ent_release,
+	},
+	{
+		.name = "dcmipp_aux_capture",
+		.init = dcmipp_pixelcap_ent_init,
+		.release = dcmipp_pixelcap_ent_release,
+	},
+	{
+		.name = "dcmipp_main_isp_stat_capture",
+		.init = dcmipp_statcap_ent_init,
+		.release = dcmipp_statcap_ent_release,
+	},
+	{
+		.name = "dcmipp_main_isp_params_output",
+		.init = dcmipp_isp_params_ent_init,
+		.release = dcmipp_isp_params_ent_release,
+	},
+};
+
+static const struct dcmipp_ent_link stm32mp25_ent_links[] = {
+	DCMIPP_ENT_LINK(ID_INPUT,	  1, ID_DUMP_BYTEPROC, 0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_DUMP_BYTEPROC, 1, ID_DUMP_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_INPUT,	2, ID_MAIN_ISP,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	1, ID_MAIN_POSTPROC,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	1, ID_AUX_POSTPROC,  0, 0),
+	DCMIPP_ENT_LINK(ID_MAIN_POSTPROC,	1, ID_MAIN_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_INPUT,	3, ID_AUX_POSTPROC,  0, 0),
+	DCMIPP_ENT_LINK(ID_AUX_POSTPROC,	1, ID_AUX_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_ISP_PARAMS_OUTPUT,	0, ID_MAIN_ISP,	2,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+	DCMIPP_ENT_LINK(ID_MAIN_ISP,	3, ID_ISP_STAT_CAPTURE,  0,
+			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE),
+};
+
+#define DCMIPP_STM32MP25_VERR	0x30
+static const struct dcmipp_pipeline_config stm32mp25_pipe_cfg = {
+	.ents		= stm32mp25_ent_config,
+	.num_ents	= ARRAY_SIZE(stm32mp25_ent_config),
+	.links		= stm32mp25_ent_links,
+	.num_links	= ARRAY_SIZE(stm32mp25_ent_links),
+	.hw_revision	= DCMIPP_STM32MP25_VERR
+};
+
+/* -------------------------------------------------------------------------- */
+#define LINK_FLAG_TO_STR(f) ((f) == 0 ? "" :\
+			     (f) == MEDIA_LNK_FL_ENABLED ? "ENABLED" :\
+			     (f) == MEDIA_LNK_FL_IMMUTABLE ? "IMMUTABLE" :\
+			     (f) == (MEDIA_LNK_FL_ENABLED |\
+				     MEDIA_LNK_FL_IMMUTABLE) ?\
+					"ENABLED, IMMUTABLE" :\
+			     "UNKNOWN")
+
+static int dcmipp_create_links(struct dcmipp_device *dcmipp)
+{
+	unsigned int i;
+	int ret;
+
+	/* Initialize the links between entities */
+	for (i = 0; i < dcmipp->pipe_cfg->num_links; i++) {
+		const struct dcmipp_ent_link *link =
+			&dcmipp->pipe_cfg->links[i];
+		struct dcmipp_ent_device *ved_src =
+			dcmipp->entity[link->src_ent];
+		struct dcmipp_ent_device *ved_sink =
+			dcmipp->entity[link->sink_ent];
+
+		dev_dbg(dcmipp->dev, "Create link \"%s\":%d -> %d:\"%s\" [%s]\n",
+			dcmipp->pipe_cfg->ents[link->src_ent].name,
+			link->src_pad, link->sink_pad,
+			dcmipp->pipe_cfg->ents[link->sink_ent].name,
+			LINK_FLAG_TO_STR(link->flags));
+
+		ret = media_create_pad_link(ved_src->ent, link->src_pad,
+					    ved_sink->ent, link->sink_pad,
+					    link->flags);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int dcmipp_graph_init(struct dcmipp_device *dcmipp);
+
+static int dcmipp_create_subdevs(struct dcmipp_device *dcmipp)
+{
+	int ret, i;
+
+	/* Call all subdev inits */
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++) {
+		const char *name = dcmipp->pipe_cfg->ents[i].name;
+
+		dev_dbg(dcmipp->dev, "add subdev %s\n", name);
+		dcmipp->entity[i] =
+			dcmipp->pipe_cfg->ents[i].init(dcmipp->dev, name,
+						       &dcmipp->v4l2_dev,
+						       dcmipp->regs);
+		if (IS_ERR(dcmipp->entity[i])) {
+			dev_err(dcmipp->dev, "failed to init subdev %s\n",
+				name);
+			ret = PTR_ERR(dcmipp->entity[i]);
+			goto err_init_entity;
+		}
+	}
+
+	/* Initialize links */
+	ret = dcmipp_create_links(dcmipp);
+	if (ret)
+		goto err_init_entity;
+
+	ret = dcmipp_graph_init(dcmipp);
+	if (ret < 0)
+		goto err_init_entity;
+
+	return 0;
+
+err_init_entity:
+	while (i-- > 0)
+		dcmipp->pipe_cfg->ents[i - 1].release(dcmipp->entity[i - 1]);
+	return ret;
+}
+
+static const struct of_device_id dcmipp_of_match[] = {
+	{ .compatible = "st,stm32mp13-dcmipp", .data = &stm32mp13_pipe_cfg},
+	{ .compatible = "st,stm32mp25-dcmipp", .data = &stm32mp25_pipe_cfg},
+	{ /* end node */ },
+};
+MODULE_DEVICE_TABLE(of, dcmipp_of_match);
+
+static int dcmipp_graph_notify_complete(struct v4l2_async_notifier *notifier)
+{
+	struct dcmipp_device *dcmipp = notifier_to_dcmipp(notifier);
+	int ret;
+
+	/* Register the media device */
+	ret = media_device_register(&dcmipp->mdev);
+	if (ret) {
+		dev_err(dcmipp->mdev.dev,
+			"media device register failed (err=%d)\n", ret);
+		return ret;
+	}
+
+	/* Expose all subdev's nodes*/
+	ret = v4l2_device_register_subdev_nodes(&dcmipp->v4l2_dev);
+	if (ret) {
+		dev_err(dcmipp->mdev.dev,
+			"dcmipp subdev nodes registration failed (err=%d)\n",
+			ret);
+		media_device_unregister(&dcmipp->mdev);
+		return ret;
+	}
+
+	dev_dbg(dcmipp->dev, "Notify complete !\n");
+
+	return 0;
+}
+
+static void dcmipp_graph_notify_unbind(struct v4l2_async_notifier *notifier,
+				       struct v4l2_subdev *sd,
+				       struct v4l2_async_subdev *asd)
+{
+	struct dcmipp_device *dcmipp = notifier_to_dcmipp(notifier);
+
+	dev_dbg(dcmipp->dev, "Removing %s\n", sd->name);
+}
+
+static irqreturn_t dcmipp_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_device *dcmipp = arg;
+	struct dcmipp_ent_device *ved;
+	unsigned int i;
+
+	/* Call irq thread of each entities of pipeline */
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++) {
+		ved = dcmipp->entity[i];
+		if (ved->thread_fn && ved->handler_ret == IRQ_WAKE_THREAD)
+			ved->thread_fn(irq, ved);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_device *dcmipp = arg;
+	struct dcmipp_ent_device *ved;
+	irqreturn_t ret = IRQ_HANDLED;
+	unsigned int i;
+	u32 cmsr2;
+
+	/* Centralized read of CMSR2 */
+	cmsr2 = reg_read(dcmipp, DCMIPP_CMSR2);
+
+	/* Call irq handler of each entities of pipeline */
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++) {
+		ved = dcmipp->entity[i];
+		ved->cmsr2 = cmsr2;
+		if (ved->handler)
+			ved->handler_ret = ved->handler(irq, ved);
+		else if (ved->thread_fn)
+			ved->handler_ret = IRQ_WAKE_THREAD;
+		else
+			ved->handler_ret = IRQ_HANDLED;
+		if (ved->handler_ret != IRQ_HANDLED)
+			ret = ved->handler_ret;
+	}
+
+	return ret;
+}
+
+static int dcmipp_graph_notify_bound(struct v4l2_async_notifier *notifier,
+				     struct v4l2_subdev *subdev,
+				     struct v4l2_async_subdev *asd)
+{
+	struct dcmipp_device *dcmipp = notifier_to_dcmipp(notifier);
+	unsigned int ret;
+	int src_pad;
+
+	dev_dbg(dcmipp->dev, "Subdev \"%s\" bound\n", subdev->name);
+
+	/* Link this sub-device to DCMIPP input subdev */
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity,
+					      subdev->fwnode,
+					      MEDIA_PAD_FL_SOURCE);
+
+	ret = media_create_pad_link(&subdev->entity, src_pad,
+				    dcmipp->entity[ID_INPUT]->ent, 0,
+				    MEDIA_LNK_FL_IMMUTABLE |
+				    MEDIA_LNK_FL_ENABLED);
+	if (ret)
+		dev_err(dcmipp->dev, "Failed to create media pad link with subdev \"%s\"\n",
+			subdev->name);
+	else
+		dev_dbg(dcmipp->dev, "DCMIPP is now linked to \"%s\"\n",
+			subdev->name);
+
+	return 0;
+}
+
+static const struct v4l2_async_notifier_operations dcmipp_graph_notify_ops = {
+	.bound = dcmipp_graph_notify_bound,
+	.unbind = dcmipp_graph_notify_unbind,
+	.complete = dcmipp_graph_notify_complete,
+};
+
+static int dcmipp_graph_init(struct dcmipp_device *dcmipp)
+{
+	struct v4l2_async_subdev *asd;
+	struct device_node *ep;
+	int ret;
+
+	ep = of_graph_get_next_endpoint(dcmipp->dev->of_node, NULL);
+	if (!ep) {
+		dev_err(dcmipp->dev, "Failed to get next endpoint\n");
+		return -EINVAL;
+	}
+
+	v4l2_async_nf_init(&dcmipp->notifier);
+
+	asd = v4l2_async_nf_add_fwnode_remote
+		(&dcmipp->notifier, of_fwnode_handle(ep),
+		 struct v4l2_async_subdev);
+
+	of_node_put(ep);
+
+	if (IS_ERR(asd)) {
+		dev_err(dcmipp->dev, "Failed to add fwnode remote subdev\n");
+		return PTR_ERR(asd);
+	}
+
+	dcmipp->notifier.ops = &dcmipp_graph_notify_ops;
+
+	ret = v4l2_async_nf_register(&dcmipp->v4l2_dev, &dcmipp->notifier);
+	if (ret < 0) {
+		dev_err(dcmipp->dev, "Failed to register notifier\n");
+		v4l2_async_nf_cleanup(&dcmipp->notifier);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct media_device_ops dcmipp_media_ops = {
+	.link_notify = v4l2_pipeline_link_notify,
+};
+
+static int dcmipp_probe(struct platform_device *pdev)
+{
+	struct dcmipp_device *dcmipp;
+	struct resource *res;
+	struct clk *kclk, *mclk;
+	const struct dcmipp_pipeline_config *pipe_cfg;
+	int irq;
+	int ret;
+
+	dcmipp = devm_kzalloc(&pdev->dev, sizeof(struct dcmipp_device), GFP_KERNEL);
+	if (!dcmipp)
+		return -ENOMEM;
+
+	dcmipp->dev = &pdev->dev;
+
+	pipe_cfg = of_device_get_match_data(&pdev->dev);
+	if (!pipe_cfg) {
+		dev_err(&pdev->dev, "Can't get device data\n");
+		return -ENODEV;
+	}
+	dcmipp->pipe_cfg = pipe_cfg;
+
+	platform_set_drvdata(pdev, dcmipp);
+
+	/* Get hardware resources from devicetree */
+	dcmipp->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(dcmipp->rstc))
+		return dev_err_probe(&pdev->dev, PTR_ERR(dcmipp->rstc),
+				     "Could not get reset control\n");
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		if (irq != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Could not get irq\n");
+		return irq ? irq : -ENXIO;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Could not get resource\n");
+		return -ENODEV;
+	}
+
+	dcmipp->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dcmipp->regs)) {
+		dev_err(&pdev->dev, "Could not map registers\n");
+		return PTR_ERR(dcmipp->regs);
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, dcmipp_irq_callback,
+					dcmipp_irq_thread, IRQF_ONESHOT,
+					dev_name(&pdev->dev), dcmipp);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to request irq %d\n", irq);
+		return ret;
+	}
+
+	/* Reset device */
+	ret = reset_control_assert(dcmipp->rstc);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to assert the reset line\n");
+		return ret;
+	}
+
+	usleep_range(3000, 5000);
+
+	ret = reset_control_deassert(dcmipp->rstc);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to deassert the reset line\n");
+		return ret;
+	}
+
+	kclk = devm_clk_get(&pdev->dev, "kclk");
+	if (IS_ERR(kclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(kclk),
+				     "Unable to get kclk\n");
+	dcmipp->kclk = kclk;
+
+	if (!of_device_is_compatible(pdev->dev.of_node, "st,stm32mp13-dcmipp")) {
+		mclk = devm_clk_get(&pdev->dev, "mclk");
+		if (IS_ERR(mclk))
+			return dev_err_probe(&pdev->dev, PTR_ERR(mclk),
+					     "Unable to get mclk\n");
+		dcmipp->mclk = mclk;
+	}
+
+	dcmipp->entity = devm_kcalloc(&pdev->dev, dcmipp->pipe_cfg->num_ents,
+				      sizeof(*dcmipp->entity), GFP_KERNEL);
+	if (!dcmipp->entity)
+		return -ENOMEM;
+
+	/* Register the v4l2 struct */
+	ret = v4l2_device_register(&pdev->dev, &dcmipp->v4l2_dev);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"v4l2 device register failed (err=%d)\n", ret);
+		return ret;
+	}
+
+	/* Link the media device within the v4l2_device */
+	dcmipp->v4l2_dev.mdev = &dcmipp->mdev;
+
+	/* Initialize media device */
+	strscpy(dcmipp->mdev.model, DCMIPP_MDEV_MODEL_NAME,
+		sizeof(dcmipp->mdev.model));
+	snprintf(dcmipp->mdev.bus_info, sizeof(dcmipp->mdev.bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+	dcmipp->mdev.hw_revision = pipe_cfg->hw_revision;
+	dcmipp->mdev.dev = &pdev->dev;
+	dcmipp->mdev.ops = &dcmipp_media_ops;
+	media_device_init(&dcmipp->mdev);
+
+	pm_runtime_enable(dcmipp->dev);
+
+	/* Initialize subdevs */
+	ret = dcmipp_create_subdevs(dcmipp);
+	if (ret) {
+		media_device_cleanup(&dcmipp->mdev);
+		v4l2_device_unregister(&dcmipp->v4l2_dev);
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "Probe done");
+
+	return 0;
+}
+
+static int dcmipp_remove(struct platform_device *pdev)
+{
+	struct dcmipp_device *dcmipp = platform_get_drvdata(pdev);
+	unsigned int i;
+
+	pm_runtime_disable(&pdev->dev);
+
+	v4l2_async_nf_unregister(&dcmipp->notifier);
+	v4l2_async_nf_cleanup(&dcmipp->notifier);
+
+	for (i = 0; i < dcmipp->pipe_cfg->num_ents; i++)
+		dcmipp->pipe_cfg->ents[i].release(dcmipp->entity[i]);
+
+	media_device_unregister(&dcmipp->mdev);
+	media_device_cleanup(&dcmipp->mdev);
+
+	v4l2_device_unregister(&dcmipp->v4l2_dev);
+
+	return 0;
+}
+
+static __maybe_unused int dcmipp_runtime_suspend(struct device *dev)
+{
+	struct dcmipp_device *dcmipp = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(dcmipp->kclk);
+	clk_disable_unprepare(dcmipp->mclk);
+
+	return 0;
+}
+
+static __maybe_unused int dcmipp_runtime_resume(struct device *dev)
+{
+	struct dcmipp_device *dcmipp = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(dcmipp->mclk);
+	if (ret)
+		dev_err(dev, "%s: Failed to prepare_enable clock\n", __func__);
+
+	ret = clk_prepare_enable(dcmipp->kclk);
+	if (ret)
+		dev_err(dev, "%s: Failed to prepare_enable k clock\n", __func__);
+
+	return ret;
+}
+
+static __maybe_unused int dcmipp_suspend(struct device *dev)
+{
+	/* disable clock */
+	pm_runtime_force_suspend(dev);
+
+	/* change pinctrl state */
+	pinctrl_pm_select_sleep_state(dev);
+
+	return 0;
+}
+
+static __maybe_unused int dcmipp_resume(struct device *dev)
+{
+	/* restore pinctl default state */
+	pinctrl_pm_select_default_state(dev);
+
+	/* clock enable */
+	pm_runtime_force_resume(dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops dcmipp_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dcmipp_suspend, dcmipp_resume)
+	SET_RUNTIME_PM_OPS(dcmipp_runtime_suspend,
+			   dcmipp_runtime_resume, NULL)
+};
+
+static struct platform_driver dcmipp_pdrv = {
+	.probe		= dcmipp_probe,
+	.remove		= dcmipp_remove,
+	.driver		= {
+		.name	= DCMIPP_PDEV_NAME,
+		.of_match_table = of_match_ptr(dcmipp_of_match),
+		.pm = &dcmipp_pm_ops,
+	},
+};
+
+module_platform_driver(dcmipp_pdrv);
+
+MODULE_AUTHOR("Hugues Fruchet <hugues.fruchet@foss.st.com>");
+MODULE_AUTHOR("Alain Volmat <alain.volmat@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Digital Camera Memory Interface with Pixel Processor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-input.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-input.c
new file mode 100644
index 000000000..61e56d72f
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-input.c
@@ -0,0 +1,613 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/vmalloc.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_INP_DRV_NAME "dcmipp-input"
+
+#define DCMIPP_PRCR (0x104)
+#define DCMIPP_PRCR_FORMAT_SHIFT 16
+#define DCMIPP_PRCR_FORMAT_YUV422 0x1E
+#define DCMIPP_PRCR_FORMAT_RGB565 0x22
+#define DCMIPP_PRCR_FORMAT_RAW8 0x2A
+#define DCMIPP_PRCR_FORMAT_RAW10 0x2B
+#define DCMIPP_PRCR_FORMAT_RAW12 0x2C
+#define DCMIPP_PRCR_FORMAT_RAW14 0x2D
+#define DCMIPP_PRCR_FORMAT_G8 0x4A
+#define DCMIPP_PRCR_FORMAT_BYTE_STREAM 0x5A
+#define DCMIPP_PRCR_ESS BIT(4)
+#define DCMIPP_PRCR_PCKPOL BIT(5)
+#define DCMIPP_PRCR_HSPOL BIT(6)
+#define DCMIPP_PRCR_VSPOL BIT(7)
+#define DCMIPP_PRCR_ENABLE BIT(14)
+#define DCMIPP_PRCR_SWAPCYCLES BIT(25)
+#define DCMIPP_PRCR_SWAPBITS BIT(26)
+
+#define DCMIPP_PRESCR (0x108)
+#define DCMIPP_PRESUR (0x10c)
+
+#define DCMIPP_CMCR (0x204)
+#define DCMIPP_CMCR_INSEL BIT(0)
+
+#define DCMIPP_P0FSCR (0x404)
+#define DCMIPP_P0FSCR_DTMODE_MASK GENMASK(17, 16)
+#define DCMIPP_P0FSCR_DTMODE_SHIFT 16
+#define DCMIPP_P0FSCR_DTMODE_DTIDA	0x00
+#define DCMIPP_P0FSCR_DTMODE_ALLDT	0x03
+#define DCMIPP_P0FSCR_DTIDA_MASK GENMASK(5, 0)
+#define DCMIPP_P0FSCR_DTIDA_SHIFT 0
+
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P2FSCR (0xC04)
+#define DCMIPP_PxFSCR_DTIDA_MASK GENMASK(5, 0)
+#define DCMIPP_PxFSCR_DTIDA_SHIFT 0
+#define DCMIPP_PxFSCR(id) (((id) == 1) ? DCMIPP_P1FSCR :\
+			   DCMIPP_P2FSCR)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+
+#define PAR_MEDIA_BUS_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+
+struct dcmipp_inp_pix_map {
+	unsigned int code_sink;
+	unsigned int code_src;
+	/* Parallel related information */
+	u8 prcr_format;
+	u8 prcr_swapbits;
+	u8 prcr_swapcycles;
+	/* CSI related information */
+	unsigned int dt;
+};
+
+#define PIXMAP_SINK_SRC_PRCR_SWAP(sink, src, prcr, swap, data_type)	\
+		{						\
+			.code_sink = MEDIA_BUS_FMT_##sink,		\
+			.code_src = MEDIA_BUS_FMT_##src,		\
+			.prcr_format = DCMIPP_PRCR_FORMAT_##prcr,	\
+			.prcr_swapcycles = swap,		\
+			.dt = data_type,			\
+		}
+static const struct dcmipp_inp_pix_map dcmipp_inp_pix_map_list[] = {
+	/* RGB565 */
+	PIXMAP_SINK_SRC_PRCR_SWAP(RGB565_2X8_LE, RGB565_2X8_LE, RGB565, 1, MIPI_CSI2_DT_RGB565),
+	PIXMAP_SINK_SRC_PRCR_SWAP(RGB565_2X8_BE, RGB565_2X8_LE, RGB565, 0, MIPI_CSI2_DT_RGB565),
+	/* YUV422 */
+	PIXMAP_SINK_SRC_PRCR_SWAP(YUYV8_2X8, YUYV8_2X8, YUV422, 1, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_SINK_SRC_PRCR_SWAP(YUYV8_2X8, UYVY8_2X8, YUV422, 0, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_SINK_SRC_PRCR_SWAP(UYVY8_2X8, UYVY8_2X8, YUV422, 1, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_SINK_SRC_PRCR_SWAP(UYVY8_2X8, YUYV8_2X8, YUV422, 0, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_SINK_SRC_PRCR_SWAP(YVYU8_2X8, YVYU8_2X8, YUV422, 1, MIPI_CSI2_DT_YUV422_8B),
+	PIXMAP_SINK_SRC_PRCR_SWAP(VYUY8_2X8, VYUY8_2X8, YUV422, 1, MIPI_CSI2_DT_YUV422_8B),
+	/* GREY */
+	PIXMAP_SINK_SRC_PRCR_SWAP(Y8_1X8, Y8_1X8, G8, 0, MIPI_CSI2_DT_RAW8),
+	/* Raw Bayer */
+	PIXMAP_SINK_SRC_PRCR_SWAP(SBGGR8_1X8, SBGGR8_1X8, RAW8, 0, MIPI_CSI2_DT_RAW8),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGBRG8_1X8, SGBRG8_1X8, RAW8, 0, MIPI_CSI2_DT_RAW8),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGRBG8_1X8, SGRBG8_1X8, RAW8, 0, MIPI_CSI2_DT_RAW8),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SRGGB8_1X8, SRGGB8_1X8, RAW8, 0, MIPI_CSI2_DT_RAW8),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SBGGR10_1X10, SBGGR10_1X10, RAW10, 0, MIPI_CSI2_DT_RAW10),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGBRG10_1X10, SGBRG10_1X10, RAW10, 0, MIPI_CSI2_DT_RAW10),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGRBG10_1X10, SGRBG10_1X10, RAW10, 0, MIPI_CSI2_DT_RAW10),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SRGGB10_1X10, SRGGB10_1X10, RAW10, 0, MIPI_CSI2_DT_RAW10),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SBGGR12_1X12, SBGGR12_1X12, RAW12, 0, MIPI_CSI2_DT_RAW12),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGBRG12_1X12, SGBRG12_1X12, RAW12, 0, MIPI_CSI2_DT_RAW12),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGRBG12_1X12, SGRBG12_1X12, RAW12, 0, MIPI_CSI2_DT_RAW12),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SRGGB12_1X12, SRGGB12_1X12, RAW12, 0, MIPI_CSI2_DT_RAW12),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SBGGR14_1X14, SBGGR14_1X14, RAW14, 0, MIPI_CSI2_DT_RAW14),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGBRG14_1X14, SGBRG14_1X14, RAW14, 0, MIPI_CSI2_DT_RAW14),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SGRBG14_1X14, SGRBG14_1X14, RAW14, 0, MIPI_CSI2_DT_RAW14),
+	PIXMAP_SINK_SRC_PRCR_SWAP(SRGGB14_1X14, SRGGB14_1X14, RAW14, 0, MIPI_CSI2_DT_RAW14),
+	/* JPEG */
+	PIXMAP_SINK_SRC_PRCR_SWAP(JPEG_1X8, JPEG_1X8, BYTE_STREAM, 0, 0),
+};
+
+/*
+ * Search through the pix_map table, skipping two consecutive entry with the
+ * same code
+ */
+static inline const struct dcmipp_inp_pix_map *dcmipp_inp_pix_map_by_index
+						(unsigned int index,
+						 unsigned int pad)
+{
+	const struct dcmipp_inp_pix_map *l = dcmipp_inp_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_inp_pix_map_list);
+	unsigned int i = 0;
+	u32 prev_code = 0, cur_code;
+
+	while (i < size) {
+		if (IS_SRC(pad))
+			cur_code = l[i].code_src;
+		else
+			cur_code = l[i].code_sink;
+
+		if (cur_code == prev_code) {
+			i++;
+			continue;
+		} else {
+			prev_code = cur_code;
+		}
+
+		if (index == 0)
+			break;
+		i++;
+		index--;
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static inline const struct dcmipp_inp_pix_map *dcmipp_inp_pix_map_by_code
+					(u32 code_sink, u32 code_src)
+{
+	const struct dcmipp_inp_pix_map *l = dcmipp_inp_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_inp_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if ((l[i].code_sink == code_sink && l[i].code_src == code_src) ||
+		    (l[i].code_sink == code_src && l[i].code_src == code_sink) ||
+		    (l[i].code_sink == code_sink && code_src == 0) ||
+		    (code_sink == 0 && l[i].code_src == code_src))
+			return &l[i];
+	}
+	return NULL;
+}
+
+struct dcmipp_inp_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	/* The active format */
+	struct v4l2_mbus_framefmt sink_format;
+	struct v4l2_mbus_framefmt src_format;
+	bool streaming;
+	void __iomem			*regs;
+};
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PAR_MEDIA_BUS_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = DCMIPP_COLORSPACE_DEFAULT,
+	.ycbcr_enc = DCMIPP_YCBCR_ENC_DEFAULT,
+	.quantization = DCMIPP_QUANTIZATION_DEFAULT,
+	.xfer_func = DCMIPP_XFER_FUNC_DEFAULT,
+};
+
+static int dcmipp_inp_init_cfg(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *sd_state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, sd_state, i);
+		*mf = fmt_default;
+	}
+
+	return 0;
+}
+
+static int dcmipp_inp_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *sd_state,
+				     struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_inp_pix_map *vpix =
+		dcmipp_inp_pix_map_by_index(code->index, code->pad);
+
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = IS_SRC(code->pad) ? vpix->code_src : vpix->code_sink;
+
+	return 0;
+}
+
+static int dcmipp_inp_enum_frame_size(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *sd_state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_inp_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_inp_pix_map_by_code(IS_SINK(fse->pad) ? fse->code : 0,
+					  IS_SRC(fse->pad) ? fse->code : 0);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_inp_get_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_inp_device *par =
+				container_of(sd, struct dcmipp_inp_device, sd);
+
+	fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+		      *v4l2_subdev_get_try_format(sd, sd_state, fmt->pad) :
+		      (IS_SRC(fmt->pad) ? par->src_format : par->sink_format);
+
+	return 0;
+}
+
+static void dcmipp_inp_adjust_fmt(struct dcmipp_inp_device *par,
+				  struct v4l2_mbus_framefmt *fmt, __u32 pad)
+{
+	const struct dcmipp_inp_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_inp_pix_map_by_code(IS_SINK(pad) ? fmt->code : 0,
+					  IS_SRC(pad) ? fmt->code : 0);
+	if (!vpix)
+		fmt->code = fmt_default.code;
+
+	/* Exclude JPEG if BT656 bus is selected */
+	if (vpix && vpix->code_sink == MEDIA_BUS_FMT_JPEG_1X8 &&
+	    par->ved.bus_type == V4L2_MBUS_BT656)
+		fmt->code = fmt_default.code;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT) & ~1;
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_inp_set_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *sd_state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_inp_device *par = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *mf;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* Do not change the format while stream is on */
+		if (par->streaming)
+			return -EBUSY;
+
+		mf = IS_SRC(fmt->pad) ? &par->src_format : &par->sink_format;
+	} else {
+		mf = v4l2_subdev_get_try_format(sd, sd_state, fmt->pad);
+	}
+
+	/* Set the new format */
+	dcmipp_inp_adjust_fmt(par, &fmt->format, fmt->pad);
+
+	dev_dbg(par->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		par->sd.name,
+		/* old */
+		mf->width, mf->height, mf->code,
+		mf->colorspace,	mf->quantization,
+		mf->xfer_func, mf->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*mf = fmt->format;
+
+	/* When setting the sink format, report that format on the src pad as well */
+	if (IS_SINK(fmt->pad))
+		par->src_format = fmt->format;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_inp_pad_ops = {
+	.init_cfg		= dcmipp_inp_init_cfg,
+	.enum_mbus_code		= dcmipp_inp_enum_mbus_code,
+	.enum_frame_size	= dcmipp_inp_enum_frame_size,
+	.get_fmt		= dcmipp_inp_get_fmt,
+	.set_fmt		= dcmipp_inp_set_fmt,
+};
+
+static int dcmipp_inp_configure_parallel(struct dcmipp_inp_device *par,
+					 int enable)
+{
+	u32 val = 0;
+	const struct dcmipp_inp_pix_map *vpix;
+
+	if (!enable) {
+		/* Disable parallel interface */
+		reg_clear(par, DCMIPP_PRCR, DCMIPP_PRCR_ENABLE);
+
+		return 0;
+	}
+
+	/* Set vertical synchronization polarity */
+	if (par->ved.bus.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+		val |= DCMIPP_PRCR_VSPOL;
+
+	/* Set horizontal synchronization polarity */
+	if (par->ved.bus.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+		val |= DCMIPP_PRCR_HSPOL;
+
+	/* Set pixel clock polarity */
+	if (par->ved.bus.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)
+		val |= DCMIPP_PRCR_PCKPOL;
+
+	/*
+	 * BT656 embedded synchronisation bus mode.
+	 *
+	 * Default SAV/EAV mode is supported here with default codes
+	 * SAV=0xff000080 & EAV=0xff00009d.
+	 * With DCMIPP this means LSC=SAV=0x80 & LEC=EAV=0x9d.
+	 */
+	if (par->ved.bus_type == V4L2_MBUS_BT656) {
+		val |= DCMIPP_PRCR_ESS;
+
+		/* Unmask all codes */
+		reg_write(par, DCMIPP_PRESUR, 0xffffffff);/* FEC:LEC:LSC:FSC */
+
+		/* Trig on LSC=0x80 & LEC=0x9d codes, ignore FSC and FEC */
+		reg_write(par, DCMIPP_PRESCR, 0xff9d80ff);/* FEC:LEC:LSC:FSC */
+	}
+
+	/* Set format */
+	vpix = dcmipp_inp_pix_map_by_code(par->sink_format.code,
+					  par->src_format.code);
+	if (!vpix) {
+		dev_err(par->dev, "Invalid sink/src format configuration\n");
+		return -EINVAL;
+	}
+
+	val |= vpix->prcr_format << DCMIPP_PRCR_FORMAT_SHIFT;
+
+	/* swap LSB vs MSB within one cycle */
+	if (vpix->prcr_swapbits)
+		val |= DCMIPP_PRCR_SWAPBITS;
+
+	/* swap cycles */
+	if (vpix->prcr_swapcycles)
+		val |= DCMIPP_PRCR_SWAPCYCLES;
+
+	reg_write(par, DCMIPP_PRCR, val);
+
+	/* Select the DCMIPP parallel interface */
+	reg_write(par, DCMIPP_CMCR, 0);
+
+	/* Enable parallel interface */
+	reg_set(par, DCMIPP_PRCR, DCMIPP_PRCR_ENABLE);
+
+	return 0;
+}
+
+static int dcmipp_inp_configure_csi(struct dcmipp_inp_device *par, int enable)
+{
+	const struct dcmipp_inp_pix_map *vpix;
+
+	if (!enable)
+		return 0;
+
+	/* Get format information */
+	vpix = dcmipp_inp_pix_map_by_code(par->sink_format.code,
+					  par->src_format.code);
+	if (!vpix) {
+		dev_err(par->dev, "Invalid sink/src format configuration\n");
+		return -EINVAL;
+	}
+
+	/* Apply configuration on each input pipe */
+	/* Pipe #0 */
+	reg_clear(par, DCMIPP_P0FSCR,
+		  DCMIPP_P0FSCR_DTMODE_MASK | DCMIPP_P0FSCR_DTIDA_MASK);
+
+	/* If DT is unknown (such as for JPEG) we allow all data */
+	if (!vpix->dt)
+		reg_set(par, DCMIPP_P0FSCR,
+			DCMIPP_P0FSCR_DTMODE_ALLDT << DCMIPP_P0FSCR_DTMODE_SHIFT);
+	else
+		reg_set(par, DCMIPP_P0FSCR,
+			vpix->dt << DCMIPP_P0FSCR_DTIDA_SHIFT |
+			DCMIPP_P0FSCR_DTMODE_DTIDA);
+
+	if (of_device_is_compatible(par->dev->of_node, "st,stm32mp25-dcmipp")) {
+		/* Pipe #1 */
+		reg_clear(par, DCMIPP_P1FSCR, DCMIPP_PxFSCR_DTIDA_MASK);
+		reg_set(par, DCMIPP_P1FSCR,
+			vpix->dt << DCMIPP_PxFSCR_DTIDA_SHIFT);
+
+		/* Only configure Pipe #2 input if is enabled */
+		if (media_pad_remote_pad_first(&par->ved.pads[3])) {
+			reg_clear(par, DCMIPP_P2FSCR, DCMIPP_PxFSCR_DTIDA_MASK);
+			reg_set(par, DCMIPP_P2FSCR,
+				vpix->dt << DCMIPP_PxFSCR_DTIDA_SHIFT);
+		}
+	}
+
+	/* Select the DCMIPP CSI interface */
+	reg_write(par, DCMIPP_CMCR, DCMIPP_CMCR_INSEL);
+
+	return 0;
+}
+
+static int dcmipp_inp_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_inp_device *par =
+				container_of(sd, struct dcmipp_inp_device, sd);
+	int ret = 0;
+
+	if (par->ved.bus_type == V4L2_MBUS_PARALLEL ||
+	    par->ved.bus_type == V4L2_MBUS_BT656) {
+		ret = dcmipp_inp_configure_parallel(par, enable);
+	} else if (par->ved.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		ret = dcmipp_inp_configure_csi(par, enable);
+	} else {
+		dev_err(par->dev, "Invalid bus_type: 0x%x, aborted\n",
+			par->ved.bus_type);
+		return -EINVAL;
+	}
+
+	if (!ret)
+		par->streaming = enable;
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_inp_video_ops = {
+	.s_stream = dcmipp_inp_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_inp_ops = {
+	.pad = &dcmipp_inp_pad_ops,
+	.video = &dcmipp_inp_video_ops,
+};
+
+static void dcmipp_inp_release(struct v4l2_subdev *sd)
+{
+	struct dcmipp_inp_device *par =
+				container_of(sd, struct dcmipp_inp_device, sd);
+
+	kfree(par);
+}
+
+static const struct v4l2_subdev_internal_ops dcmipp_inp_int_ops = {
+	.release = dcmipp_inp_release,
+};
+
+void dcmipp_inp_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_inp_device *par =
+			container_of(ved, struct dcmipp_inp_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &par->sd);
+}
+
+static int dcmipp_inp_get_input_bus_type(struct dcmipp_inp_device *par)
+{
+	struct device_node *np = par->dev->of_node;
+	struct v4l2_fwnode_endpoint ep = { .bus_type = 0 };
+	int ret;
+
+	/* Get bus characteristics from devicetree */
+	np = of_graph_get_next_endpoint(np, NULL);
+	if (!np) {
+		dev_err(par->dev, "Could not find the endpoint\n");
+		of_node_put(np);
+		return -ENODEV;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(np), &ep);
+	of_node_put(np);
+	if (ret) {
+		dev_err(par->dev, "Could not parse the endpoint\n");
+		return ret;
+	}
+
+	if ((ep.bus_type == V4L2_MBUS_PARALLEL ||
+	     ep.bus_type == V4L2_MBUS_BT656) &&
+	     ep.bus.parallel.bus_width > 0) {
+		/* Only 8 bits bus width supported with BT656 bus */
+		if (ep.bus_type == V4L2_MBUS_BT656 &&
+		    ep.bus.parallel.bus_width != 8) {
+			dev_err(par->dev, "BT656 bus conflicts with %u bits bus width (8 bits required)\n",
+				ep.bus.parallel.bus_width);
+			return -ENODEV;
+		}
+
+		par->ved.bus.flags = ep.bus.parallel.flags;
+		par->ved.bus.bus_width = ep.bus.parallel.bus_width;
+		par->ved.bus.data_shift = ep.bus.parallel.data_shift;
+	}
+
+	dev_dbg(par->dev, "DCMIPP input bus-type is: 0x%x\n", ep.bus_type);
+	par->ved.bus_type = ep.bus_type;
+
+	return 0;
+}
+
+#define DCMIPP_INP_SINK_PAD_NB_MP13	1
+#define DCMIPP_INP_SINK_PAD_NB_MP25	3
+struct dcmipp_ent_device *dcmipp_inp_ent_init(struct device *dev,
+					      const char *entity_name,
+					      struct v4l2_device *v4l2_dev,
+					      void __iomem *regs)
+{
+	struct dcmipp_inp_device *par;
+	const unsigned long pads_stm32mp25[DCMIPP_INP_SINK_PAD_NB_MP25 + 1] = {
+		MEDIA_PAD_FL_SINK, MEDIA_PAD_FL_SOURCE,
+		MEDIA_PAD_FL_SOURCE, MEDIA_PAD_FL_SOURCE,
+	};
+	u16 pads_nb = DCMIPP_INP_SINK_PAD_NB_MP25 + 1;
+	int ret;
+
+	if (of_device_is_compatible(dev->of_node, "st,stm32mp13-dcmipp"))
+		pads_nb = DCMIPP_INP_SINK_PAD_NB_MP13 + 1;
+	else if (of_device_is_compatible(dev->of_node, "st,stm32mp25-dcmipp"))
+		pads_nb = DCMIPP_INP_SINK_PAD_NB_MP25 + 1;
+
+	/* Allocate the par struct */
+	par = kzalloc(sizeof(*par), GFP_KERNEL);
+	if (!par)
+		return ERR_PTR(-ENOMEM);
+
+	par->regs = regs;
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register
+		(&par->ved, &par->sd, v4l2_dev,
+		 entity_name,
+		 MEDIA_ENT_F_VID_IF_BRIDGE, pads_nb,
+		 pads_stm32mp25,
+		 &dcmipp_inp_int_ops, &dcmipp_inp_ops,
+		 NULL, NULL);
+	if (ret)
+		goto err_free_hdl;
+
+	par->dev = dev;
+
+	/* Retrieve and store the bus-type within the ent structure */
+	ret = dcmipp_inp_get_input_bus_type(par);
+	if (ret)
+		goto err_free_hdl;
+
+	/* Initialize the frame format */
+	par->sink_format = fmt_default;
+	par->src_format = fmt_default;
+
+	return &par->ved;
+
+err_free_hdl:
+	kfree(par);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp-params.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp-params.c
new file mode 100644
index 000000000..623403c6c
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp-params.c
@@ -0,0 +1,657 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2023
+ * Authors: Alain Volmat <alain.volmat@foss.st.com>
+ *          Fabien Dessenne <fabien.dessenne@foss.st.com>
+ *          Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-vmalloc.h>
+#include <uapi/linux/stm32-dcmipp-config.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_ISP_PARAMS_DRV_NAME "dcmipp-isp-params"
+
+#define DCMIPP_CMSR2_P1VSYNCF BIT(18)
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	struct list_head	list;
+};
+
+struct dcmipp_isp_params_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+
+	void __iomem *regs;
+};
+
+static int dcmipp_isp_params_querycap(struct file *file, void *priv,
+				      struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static int dcmipp_isp_params_g_fmt_meta_out(struct file *file, void *priv,
+					    struct v4l2_format *f)
+{
+	struct v4l2_meta_format *meta = &f->fmt.meta;
+
+	if (f->type != V4L2_BUF_TYPE_META_OUTPUT)
+		return -EINVAL;
+
+	meta->dataformat = V4L2_META_FMT_ST_DCMIPP_ISP_PARAMS;
+	meta->buffersize = sizeof(struct stm32_dcmipp_params_cfg);
+
+	return 0;
+}
+
+static int dcmipp_isp_params_enum_fmt_meta_out(struct file *file, void *priv,
+					       struct v4l2_fmtdesc *f)
+{
+	if (f->index > 0 || f->type != V4L2_BUF_TYPE_META_OUTPUT)
+		return -EINVAL;
+
+	f->type = V4L2_BUF_TYPE_META_OUTPUT;
+	f->pixelformat = V4L2_META_FMT_ST_DCMIPP_ISP_PARAMS;
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops dcmipp_isp_params_ioctl_ops = {
+	.vidioc_querycap = dcmipp_isp_params_querycap,
+
+	.vidioc_enum_fmt_meta_out = dcmipp_isp_params_enum_fmt_meta_out,
+	.vidioc_g_fmt_meta_out = dcmipp_isp_params_g_fmt_meta_out,
+	.vidioc_s_fmt_meta_out = dcmipp_isp_params_g_fmt_meta_out,
+	.vidioc_try_fmt_meta_out = dcmipp_isp_params_g_fmt_meta_out,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_isp_params_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_isp_params_device *vout = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+
+	spin_lock_irq(&vout->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vout->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vout->buffers);
+
+	spin_unlock_irq(&vout->irqlock);
+}
+
+static int dcmipp_isp_params_validate(struct stm32_dcmipp_params_cfg *params);
+static int dcmipp_isp_params_buf_prepare(struct vb2_buffer *vb)
+{
+	unsigned long size = sizeof(struct stm32_dcmipp_params_cfg);
+	struct stm32_dcmipp_params_cfg *params;
+
+	if (vb2_plane_size(vb, 0) < size)
+		return -EINVAL;
+
+	params = (struct stm32_dcmipp_params_cfg *)vb2_plane_vaddr(vb, 0);
+	if (dcmipp_isp_params_validate(params) < 0)
+		return -EINVAL;
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	return 0;
+}
+
+static void dcmipp_isp_params_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_isp_params_device *vout =
+		vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vout->irqlock);
+	list_add_tail(&buf->list, &vout->buffers);
+	spin_unlock_irq(&vout->irqlock);
+}
+
+static int dcmipp_isp_params_queue_setup(struct vb2_queue *vq,
+					 unsigned int *nbuffers,
+					 unsigned int *nplanes,
+					 unsigned int sizes[],
+					 struct device *alloc_devs[])
+{
+	unsigned int size = sizeof(struct stm32_dcmipp_params_cfg);
+
+	if (*nplanes) {
+		if (sizes[0] < size)
+			return -EINVAL;
+	} else {
+		sizes[0] = size;
+	}
+
+	if (vq->num_buffers + *nbuffers < 2)
+		*nbuffers = 2 - vq->num_buffers;
+
+	*nplanes = 1;
+	return 0;
+}
+
+static int dcmipp_isp_params_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_isp_params_qops = {
+	.stop_streaming		= dcmipp_isp_params_stop_streaming,
+	.buf_init		= dcmipp_isp_params_buf_init,
+	.buf_prepare		= dcmipp_isp_params_buf_prepare,
+	.buf_queue		= dcmipp_isp_params_buf_queue,
+
+	.queue_setup		= dcmipp_isp_params_queue_setup,
+
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_isp_params_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static void dcmipp_isp_params_release(struct video_device *vdev)
+{
+	struct dcmipp_isp_params_device *vout =
+		container_of(vdev, struct dcmipp_isp_params_device, vdev);
+
+	dcmipp_pads_cleanup(vout->ved.pads);
+	kfree(vout);
+}
+
+void dcmipp_isp_params_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_isp_params_device *vout =
+		container_of(ved, struct dcmipp_isp_params_device, ved);
+
+	mutex_destroy(&vout->lock);
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vout->vdev);
+}
+
+#define DCMIPP_P1BPRCR (0x824)
+#define DCMIPP_P1BPRCR_ENABLE BIT(0)
+#define DCMIPP_P1BPRCR_STRENGTH_SHIFT 1
+#define DCMIPP_P1BPRCR_STRENGTH_MASK 0x07
+static inline int
+dcmipp_isp_params_valid_bpr(struct stm32_dcmipp_isp_bpr_cfg *cfg)
+{
+	if (cfg->strength & ~DCMIPP_P1BPRCR_STRENGTH_MASK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static inline void
+dcmipp_isp_params_apply_bpr(struct dcmipp_isp_params_device *vout,
+			    struct stm32_dcmipp_isp_bpr_cfg *cfg)
+{
+	reg_write(vout, DCMIPP_P1BPRCR,
+		  (cfg->en ? DCMIPP_P1BPRCR_ENABLE : 0) |
+		  cfg->strength << DCMIPP_P1BPRCR_STRENGTH_SHIFT);
+}
+
+#define DCMIPP_P1BLCCR (0x840)
+#define DCMIPP_P1BLCCR_ENABLE BIT(0)
+#define DCMIPP_P1BLCCR_BLCB_SHIFT 8
+#define DCMIPP_P1BLCCR_BLCG_SHIFT 16
+#define DCMIPP_P1BLCCR_BLCR_SHIFT 24
+static inline void
+dcmipp_isp_params_apply_blc(struct dcmipp_isp_params_device *vout,
+			    struct stm32_dcmipp_isp_blc_cfg *cfg)
+{
+	reg_write(vout, DCMIPP_P1BLCCR,
+		  (cfg->en ? DCMIPP_P1BLCCR_ENABLE : 0) |
+		  cfg->blc_r << DCMIPP_P1BLCCR_BLCR_SHIFT |
+		  cfg->blc_g << DCMIPP_P1BLCCR_BLCG_SHIFT |
+		  cfg->blc_b << DCMIPP_P1BLCCR_BLCB_SHIFT);
+}
+
+#define DCMIPP_P1EXCR1 (0x844)
+#define DCMIPP_P1EXCR1_ENABLE BIT(0)
+#define DCMIPP_P1EXCR1_MULTR_SHIFT 20
+#define DCMIPP_P1EXCR1_SHFR_SHIFT 28
+#define DCMIPP_P1EXCR1_SHFR_MASK 0x07
+
+#define DCMIPP_P1EXCR2 (0x848)
+#define DCMIPP_P1EXCR2_MULTB_SHIFT 4
+#define DCMIPP_P1EXCR2_SHFB_SHIFT 12
+#define DCMIPP_P1EXCR2_MULTG_SHIFT 20
+#define DCMIPP_P1EXCR2_SHFG_SHIFT 28
+static inline int
+dcmipp_isp_params_valid_ex(struct stm32_dcmipp_isp_ex_cfg *cfg)
+{
+	if (cfg->shift_r & ~DCMIPP_P1EXCR1_SHFR_MASK ||
+	    cfg->shift_g & ~DCMIPP_P1EXCR1_SHFR_MASK ||
+	    cfg->shift_b & ~DCMIPP_P1EXCR1_SHFR_MASK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static inline void
+dcmipp_isp_params_apply_ex(struct dcmipp_isp_params_device *vout,
+			   struct stm32_dcmipp_isp_ex_cfg *cfg)
+{
+	reg_write(vout, DCMIPP_P1EXCR1,
+		  (cfg->en ? DCMIPP_P1EXCR1_ENABLE : 0) |
+		  cfg->mult_r << DCMIPP_P1EXCR1_MULTR_SHIFT |
+		  cfg->shift_r << DCMIPP_P1EXCR1_SHFR_SHIFT);
+
+	reg_write(vout, DCMIPP_P1EXCR2,
+		  cfg->mult_b << DCMIPP_P1EXCR2_MULTB_SHIFT |
+		  cfg->shift_b << DCMIPP_P1EXCR2_SHFB_SHIFT |
+		  cfg->mult_g << DCMIPP_P1EXCR2_MULTG_SHIFT |
+		  cfg->shift_g << DCMIPP_P1EXCR2_SHFG_SHIFT);
+}
+
+#define DCMIPP_P1DMCR (0x870)
+#define DCMIPP_P1DMCR_PEAK_SHIFT 16
+#define DCMIPP_P1DMCR_PEAK_MASK 0x07
+#define DCMIPP_P1DMCR_LINEV_SHIFT 20
+#define DCMIPP_P1DMCR_LINEV_MASK 0x07
+#define DCMIPP_P1DMCR_LINEH_SHIFT 24
+#define DCMIPP_P1DMCR_LINEH_MASK 0x07
+#define DCMIPP_P1DMCR_EDGE_SHIFT 28
+#define DCMIPP_P1DMCR_EDGE_MASK 0x07
+static inline int
+dcmipp_isp_params_valid_dm(struct stm32_dcmipp_isp_dm_cfg *cfg)
+{
+	if (cfg->edge & ~DCMIPP_P1DMCR_EDGE_MASK ||
+	    cfg->lineh & ~DCMIPP_P1DMCR_LINEH_MASK ||
+	    cfg->linev & ~DCMIPP_P1DMCR_LINEV_MASK ||
+	    cfg->peak & ~DCMIPP_P1DMCR_PEAK_MASK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static inline void
+dcmipp_isp_params_apply_dm(struct dcmipp_isp_params_device *vout,
+			   struct stm32_dcmipp_isp_dm_cfg *cfg)
+{
+	u32 dmcr, mask;
+
+	mask = DCMIPP_P1DMCR_PEAK_MASK << DCMIPP_P1DMCR_PEAK_SHIFT |
+	       DCMIPP_P1DMCR_LINEV_MASK << DCMIPP_P1DMCR_LINEV_SHIFT |
+	       DCMIPP_P1DMCR_LINEH_MASK << DCMIPP_P1DMCR_LINEH_SHIFT |
+	       DCMIPP_P1DMCR_EDGE_MASK << DCMIPP_P1DMCR_EDGE_SHIFT;
+
+	dmcr = reg_read(vout, DCMIPP_P1DMCR) & ~mask;
+	reg_write(vout, DCMIPP_P1DMCR, dmcr |
+		  cfg->peak << DCMIPP_P1DMCR_PEAK_SHIFT |
+		  cfg->lineh << DCMIPP_P1DMCR_LINEH_SHIFT |
+		  cfg->linev << DCMIPP_P1DMCR_LINEV_SHIFT |
+		  cfg->edge << DCMIPP_P1DMCR_EDGE_SHIFT);
+}
+
+#define DCMIPP_P1CCCR (0x880)
+#define DCMIPP_P1CCCR_ENABLE BIT(0)
+#define DCMIPP_P1CCCR_TYPE_YUV 0
+#define DCMIPP_P1CCCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1CCCR_CLAMP BIT(2)
+#define DCMIPP_P1CCRR_RGB_MASK	0x7ff
+#define DCMIPP_P1CCRR_A_MASK	0x3ff
+#define DCMIPP_P1CCRR1 (0x884)
+#define DCMIPP_P1CCRR1_RG_SHIFT	16
+#define DCMIPP_P1CCRR1_RR_SHIFT	0
+#define DCMIPP_P1CCRR2 (0x888)
+#define DCMIPP_P1CCRR2_RA_SHIFT	16
+#define DCMIPP_P1CCRR2_RB_SHIFT	0
+#define DCMIPP_P1CCGR1 (0x88C)
+#define DCMIPP_P1CCGR1_GG_SHIFT	16
+#define DCMIPP_P1CCGR1_GR_SHIFT	0
+#define DCMIPP_P1CCGR2 (0x890)
+#define DCMIPP_P1CCGR2_GA_SHIFT	16
+#define DCMIPP_P1CCGR2_GB_SHIFT	0
+#define DCMIPP_P1CCBR1 (0x894)
+#define DCMIPP_P1CCBR1_BG_SHIFT	16
+#define DCMIPP_P1CCBR1_BR_SHIFT	0
+#define DCMIPP_P1CCBR2 (0x898)
+#define DCMIPP_P1CCBR2_BA_SHIFT	16
+#define DCMIPP_P1CCBR2_BB_SHIFT	0
+static inline int
+dcmipp_isp_params_valid_cc(struct stm32_dcmipp_isp_cc_cfg *cfg)
+{
+	if (cfg->rr & ~DCMIPP_P1CCRR_RGB_MASK || cfg->rg & ~DCMIPP_P1CCRR_RGB_MASK ||
+	    cfg->rb & ~DCMIPP_P1CCRR_RGB_MASK || cfg->gr & ~DCMIPP_P1CCRR_RGB_MASK ||
+	    cfg->gg & ~DCMIPP_P1CCRR_RGB_MASK || cfg->gb & ~DCMIPP_P1CCRR_RGB_MASK ||
+	    cfg->br & ~DCMIPP_P1CCRR_RGB_MASK || cfg->bg & ~DCMIPP_P1CCRR_RGB_MASK ||
+	    cfg->bb & ~DCMIPP_P1CCRR_RGB_MASK || cfg->ra & ~DCMIPP_P1CCRR_A_MASK ||
+	    cfg->ga & ~DCMIPP_P1CCRR_A_MASK || cfg->ba & ~DCMIPP_P1CCRR_A_MASK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static inline void
+dcmipp_isp_params_apply_cc(struct dcmipp_isp_params_device *vout,
+			   struct stm32_dcmipp_isp_cc_cfg *cfg)
+{
+	u32 cccr = cfg->en ? DCMIPP_P1CCCR_ENABLE : 0;
+
+	if (cfg->clamp != STM32_DCMIPP_ISP_CC_CLAMP_DISABLED) {
+		cccr |= DCMIPP_P1CCCR_CLAMP;
+		cccr |= cfg->clamp == STM32_DCMIPP_ISP_CC_CLAMP_YUV235 ?
+			DCMIPP_P1CCCR_TYPE_YUV : DCMIPP_P1CCCR_TYPE_RGB;
+	}
+
+	reg_write(vout, DCMIPP_P1CCCR, cccr);
+	reg_write(vout, DCMIPP_P1CCRR1,
+		  cfg->rr << DCMIPP_P1CCRR1_RR_SHIFT |
+		  cfg->rg << DCMIPP_P1CCRR1_RG_SHIFT);
+	reg_write(vout, DCMIPP_P1CCRR2,
+		  cfg->ra << DCMIPP_P1CCRR2_RA_SHIFT |
+		  cfg->rb << DCMIPP_P1CCRR2_RB_SHIFT);
+	reg_write(vout, DCMIPP_P1CCGR1,
+		  cfg->gr << DCMIPP_P1CCGR1_GR_SHIFT |
+		  cfg->gg << DCMIPP_P1CCGR1_GG_SHIFT);
+	reg_write(vout, DCMIPP_P1CCGR2,
+		  cfg->gb << DCMIPP_P1CCGR2_GB_SHIFT |
+		  cfg->ga << DCMIPP_P1CCGR2_GA_SHIFT);
+	reg_write(vout, DCMIPP_P1CCBR1,
+		  cfg->br << DCMIPP_P1CCBR1_BR_SHIFT |
+		  cfg->bg << DCMIPP_P1CCBR1_BG_SHIFT);
+	reg_write(vout, DCMIPP_P1CCBR2,
+		  cfg->bb << DCMIPP_P1CCBR2_BB_SHIFT |
+		  cfg->ba << DCMIPP_P1CCBR2_BA_SHIFT);
+}
+
+#define DCMIPP_P1CTCR1 (0x8a0)
+#define DCMIPP_P1CTCR1_ENABLE BIT(0)
+#define DCMIPP_P1CTCR_LUM_MASK 0x3f
+#define DCMIPP_P1CTCR1_LUM0_SHIFT 9
+
+#define DCMIPP_P1CTCR2 (0x8a4)
+#define DCMIPP_P1CTCR2_LUM4_SHIFT 1
+#define DCMIPP_P1CTCR2_LUM3_SHIFT 9
+#define DCMIPP_P1CTCR2_LUM2_SHIFT 17
+#define DCMIPP_P1CTCR2_LUM1_SHIFT 25
+
+#define DCMIPP_P1CTCR3 (0x8a8)
+#define DCMIPP_P1CTCR3_LUM8_SHIFT 1
+#define DCMIPP_P1CTCR3_LUM7_SHIFT 9
+#define DCMIPP_P1CTCR3_LUM6_SHIFT 17
+#define DCMIPP_P1CTCR3_LUM5_SHIFT 25
+static inline int
+dcmipp_isp_params_valid_ce(struct stm32_dcmipp_isp_ce_cfg *cfg)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(cfg->lum); i++)
+		if (cfg->lum[i] & ~DCMIPP_P1CTCR_LUM_MASK)
+			return -EINVAL;
+
+	return 0;
+}
+
+static inline void
+dcmipp_isp_params_apply_ce(struct dcmipp_isp_params_device *vout,
+			   struct stm32_dcmipp_isp_ce_cfg *cfg)
+{
+	reg_write(vout, DCMIPP_P1CTCR1,
+		  (cfg->en ? DCMIPP_P1CTCR1_ENABLE : 0) |
+		  cfg->lum[0] << DCMIPP_P1CTCR1_LUM0_SHIFT);
+	reg_write(vout, DCMIPP_P1CTCR2,
+		  cfg->lum[1] << DCMIPP_P1CTCR2_LUM1_SHIFT |
+		  cfg->lum[2] << DCMIPP_P1CTCR2_LUM2_SHIFT |
+		  cfg->lum[3] << DCMIPP_P1CTCR2_LUM3_SHIFT |
+		  cfg->lum[4] << DCMIPP_P1CTCR2_LUM4_SHIFT);
+	reg_write(vout, DCMIPP_P1CTCR3,
+		  cfg->lum[5] << DCMIPP_P1CTCR3_LUM5_SHIFT |
+		  cfg->lum[6] << DCMIPP_P1CTCR3_LUM6_SHIFT |
+		  cfg->lum[7] << DCMIPP_P1CTCR3_LUM7_SHIFT |
+		  cfg->lum[8] << DCMIPP_P1CTCR3_LUM8_SHIFT);
+}
+
+#define DCMIPP_MODULE_CFG_MASK	(STM32_DCMIPP_ISP_BPR | STM32_DCMIPP_ISP_BLC | \
+				 STM32_DCMIPP_ISP_EX | STM32_DCMIPP_ISP_DM | \
+				 STM32_DCMIPP_ISP_CC | STM32_DCMIPP_ISP_CE)
+static int dcmipp_isp_params_validate(struct stm32_dcmipp_params_cfg *params)
+{
+	int ret;
+
+	if (params->module_cfg_update & ~DCMIPP_MODULE_CFG_MASK)
+		return -EINVAL;
+	if (params->module_cfg_update & STM32_DCMIPP_ISP_BPR) {
+		ret = dcmipp_isp_params_valid_bpr(&params->ctrls.bpr_cfg);
+		if (ret)
+			return ret;
+	}
+	if (params->module_cfg_update & STM32_DCMIPP_ISP_EX) {
+		ret = dcmipp_isp_params_valid_ex(&params->ctrls.ex_cfg);
+		if (ret)
+			return ret;
+	}
+	if (params->module_cfg_update & STM32_DCMIPP_ISP_DM) {
+		ret = dcmipp_isp_params_valid_dm(&params->ctrls.dm_cfg);
+		if (ret)
+			return ret;
+	}
+	if (params->module_cfg_update & STM32_DCMIPP_ISP_CC) {
+		ret = dcmipp_isp_params_valid_cc(&params->ctrls.cc_cfg);
+		if (ret)
+			return ret;
+	}
+	if (params->module_cfg_update & STM32_DCMIPP_ISP_CE) {
+		ret = dcmipp_isp_params_valid_ce(&params->ctrls.ce_cfg);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static inline void
+dcmipp_isp_params_apply(struct dcmipp_isp_params_device *vout,
+			struct stm32_dcmipp_params_cfg *buf)
+{
+	if (buf->module_cfg_update & STM32_DCMIPP_ISP_BPR)
+		dcmipp_isp_params_apply_bpr(vout, &buf->ctrls.bpr_cfg);
+	if (buf->module_cfg_update & STM32_DCMIPP_ISP_BLC)
+		dcmipp_isp_params_apply_blc(vout, &buf->ctrls.blc_cfg);
+	if (buf->module_cfg_update & STM32_DCMIPP_ISP_EX)
+		dcmipp_isp_params_apply_ex(vout, &buf->ctrls.ex_cfg);
+	if (buf->module_cfg_update & STM32_DCMIPP_ISP_DM)
+		dcmipp_isp_params_apply_dm(vout, &buf->ctrls.dm_cfg);
+	if (buf->module_cfg_update & STM32_DCMIPP_ISP_CC)
+		dcmipp_isp_params_apply_cc(vout, &buf->ctrls.cc_cfg);
+	if (buf->module_cfg_update & STM32_DCMIPP_ISP_CE)
+		dcmipp_isp_params_apply_ce(vout, &buf->ctrls.ce_cfg);
+}
+
+static irqreturn_t dcmipp_isp_params_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_isp_params_device *vout =
+			container_of(arg, struct dcmipp_isp_params_device, ved);
+	struct dcmipp_ent_device *ved = arg;
+	struct stm32_dcmipp_params_cfg *params_cfg;
+	struct dcmipp_buf *cur_buf = NULL;
+
+	/* We are only interested in VSYNC interrupts */
+	if (!(ved->cmsr2 & DCMIPP_CMSR2_P1VSYNCF))
+		return IRQ_HANDLED;
+
+	spin_lock_irq(&vout->irqlock);
+
+	/* Get an available buffer */
+	if (list_empty(&vout->buffers))
+		goto out;
+
+	cur_buf = list_first_entry(&vout->buffers, struct dcmipp_buf, list);
+	list_del(&cur_buf->list);
+	params_cfg =
+		(struct stm32_dcmipp_params_cfg *)vb2_plane_vaddr(&cur_buf->vb.vb2_buf, 0);
+
+	/* Handle the params configuration */
+	dcmipp_isp_params_apply(vout, params_cfg);
+
+	/* TODO - we need to set a proper sequence number */
+	cur_buf->vb.sequence = 0;
+	cur_buf->vb.vb2_buf.timestamp = ktime_get_ns();
+	vb2_buffer_done(&cur_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+
+out:
+	spin_unlock_irq(&vout->irqlock);
+
+	return IRQ_HANDLED;
+}
+
+static const struct v4l2_file_operations dcmipp_isp_params_fops = {
+	.open		= v4l2_fh_open,
+	.release	= vb2_fop_release,
+	.mmap           = vb2_fop_mmap,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+};
+
+struct dcmipp_ent_device *
+dcmipp_isp_params_ent_init(struct device *dev, const char *entity_name,
+			   struct v4l2_device *v4l2_dev, void __iomem *regs)
+{
+	struct dcmipp_isp_params_device *vout;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	/* Allocate the dcmipp_cap_device struct */
+	vout = kzalloc(sizeof(*vout), GFP_KERNEL);
+	if (!vout)
+		return ERR_PTR(-ENOMEM);
+
+	/* Allocate the pad */
+	vout->ved.pads =
+		dcmipp_pads_init(1, (const unsigned long[1]) {MEDIA_PAD_FL_SOURCE});
+	if (IS_ERR(vout->ved.pads)) {
+		ret = PTR_ERR(vout->ved.pads);
+		goto err_free_vout;
+	}
+
+	/* Initialize the media entity */
+	vout->vdev.entity.name = entity_name;
+	vout->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vout->vdev.entity, 1, vout->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vout->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vout->queue;
+	q->type = V4L2_BUF_TYPE_META_OUTPUT;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	q->lock = &vout->lock;
+	q->drv_priv = vout;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_isp_params_qops;
+	q->mem_ops = &vb2_vmalloc_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = dev;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s: vb2 queue init failed (err=%d)\n",
+			entity_name, ret);
+		goto err_mutex_destroy;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vout->buffers);
+	spin_lock_init(&vout->irqlock);
+
+	/* Fill the dcmipp_ent_device struct */
+	vout->ved.ent = &vout->vdev.entity;
+	vout->ved.handler = NULL;
+	vout->ved.thread_fn = dcmipp_isp_params_irq_thread;
+	vout->dev = dev;
+	vout->regs = regs;
+
+	/* Initialize the video_device struct */
+	vdev = &vout->vdev;
+	vdev->device_caps = V4L2_CAP_META_OUTPUT | V4L2_CAP_STREAMING;
+	vdev->vfl_dir = VFL_DIR_TX;
+	vdev->entity.ops = &dcmipp_isp_params_mops;
+	vdev->release = dcmipp_isp_params_release;
+	vdev->fops = &dcmipp_isp_params_fops;
+	vdev->ioctl_ops = &dcmipp_isp_params_ioctl_ops;
+	vdev->lock = &vout->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = v4l2_dev;
+	strscpy(vdev->name, entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vout->ved);
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dev, "%s: video register failed (err=%d)\n",
+			vout->vdev.name, ret);
+		goto err_mutex_destroy;
+	}
+
+	return &vout->ved;
+
+err_mutex_destroy:
+	mutex_destroy(&vout->lock);
+	media_entity_cleanup(&vout->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vout->ved.pads);
+err_free_vout:
+	kfree(vout);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp.c
new file mode 100644
index 000000000..96ca41a8d
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-isp.c
@@ -0,0 +1,729 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/mipi-csi2.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+#include "dcmipp-colorconv.h"
+
+#define DCMIPP_ISP_DRV_NAME "dcmipp-isp"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_CMSR2_P1VSYNCF BIT(18)
+
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P1FSCR_PIPEDIFF BIT(18)
+
+#define DCMIPP_P1SRCR (0x820)
+#define DCMIPP_P1SRCR_LASTLINE_SHIFT 0
+#define DCMIPP_P1SRCR_LASTLINE_MASK GENMASK(11, 0)
+#define DCMIPP_P1SRCR_FIRSTLINEDEL_SHIFT 12
+#define DCMIPP_P1SRCR_FIRSTLINEDEL_MASK GENMASK(14, 12)
+#define DCMIPP_P1SRCR_CROPEN BIT(15)
+
+#define DCMIPP_P1DECR (0x830)
+#define DCMIPP_P1DECR_ENABLE BIT(0)
+#define DCMIPP_P1DECR_HDEC_SHIFT 1
+#define DCMIPP_P1DECR_HDEC_MASK GENMASK(2, 1)
+#define DCMIPP_P1DECR_VDEC_SHIFT 3
+#define DCMIPP_P1DECR_VDEC_MASK GENMASK(4, 3)
+
+#define DCMIPP_P1DMCR (0x870)
+#define DCMIPP_P1DMCR_ENABLE BIT(0)
+#define DCMIPP_P1DMCR_TYPE_SHIFT 1
+#define DCMIPP_P1DMCR_TYPE_MASK GENMASK(2, 1)
+#define DCMIPP_P1DMCR_TYPE_RGGB 0x0
+#define DCMIPP_P1DMCR_TYPE_GRBG 0x1
+#define DCMIPP_P1DMCR_TYPE_GBRG 0x2
+#define DCMIPP_P1DMCR_TYPE_BGGR 0x3
+
+#define DCMIPP_P1CCCR (0x880)
+#define DCMIPP_P1CCCR_ENABLE BIT(0)
+#define DCMIPP_P1CCCR_TYPE_YUV 0
+#define DCMIPP_P1CCCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1CCCR_CLAMP BIT(2)
+#define DCMIPP_P1CCRR1 (0x884)
+#define DCMIPP_P1CCRR2 (0x888)
+#define DCMIPP_P1CCGR1 (0x88C)
+#define DCMIPP_P1CCGR2 (0x890)
+#define DCMIPP_P1CCBR1 (0x894)
+#define DCMIPP_P1CCBR2 (0x898)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define ISP_MEDIA_BUS_SINK_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+#define ISP_MEDIA_BUS_SRC_FMT_DEFAULT MEDIA_BUS_FMT_RGB888_1X24
+
+static const unsigned int dcmipp_isp_sink_pix_map_list[] = {
+	/* RGB565 */
+	MEDIA_BUS_FMT_RGB565_2X8_LE,
+	/* YUV422 */
+	MEDIA_BUS_FMT_YUYV8_2X8,
+	MEDIA_BUS_FMT_UYVY8_2X8,
+	MEDIA_BUS_FMT_YVYU8_2X8,
+	MEDIA_BUS_FMT_VYUY8_2X8,
+	/* GREY */
+	MEDIA_BUS_FMT_Y8_1X8,
+	/* Raw Bayer */
+	/* Raw 8 */
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	/* Raw 10 */
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	/* Raw 12 */
+	MEDIA_BUS_FMT_SBGGR12_1X12,
+	MEDIA_BUS_FMT_SGBRG12_1X12,
+	MEDIA_BUS_FMT_SGRBG12_1X12,
+	MEDIA_BUS_FMT_SRGGB12_1X12,
+	/* Raw 14 */
+	MEDIA_BUS_FMT_SBGGR14_1X14,
+	MEDIA_BUS_FMT_SGBRG14_1X14,
+	MEDIA_BUS_FMT_SGRBG14_1X14,
+	MEDIA_BUS_FMT_SRGGB14_1X14,
+};
+
+static const unsigned int dcmipp_isp_src_pix_map_list[] = {
+	MEDIA_BUS_FMT_RGB888_1X24,
+	MEDIA_BUS_FMT_YUV8_1X24,
+};
+
+static unsigned int
+dcmipp_isp_pix_map_by_index(unsigned int i, unsigned int pad)
+{
+	const unsigned int *l;
+	unsigned int size;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_isp_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_src_pix_map_list);
+	} else {
+		l = dcmipp_isp_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_sink_pix_map_list);
+	}
+
+	if (i >= size)
+		return 0;
+
+	return l[i];
+}
+
+static unsigned int
+dcmipp_isp_pix_map_by_code(u32 code, unsigned int pad)
+{
+	const unsigned int *l;
+	unsigned int size;
+	unsigned int i;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_isp_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_src_pix_map_list);
+	} else {
+		l = dcmipp_isp_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_isp_sink_pix_map_list);
+	}
+
+	for (i = 0; i < size; i++) {
+		if (l[i] == code)
+			return code;
+	}
+
+	return 0;
+}
+
+struct dcmipp_isp_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct v4l2_mbus_framefmt src_fmt;
+	unsigned int decimation;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+};
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = ISP_MEDIA_BUS_SINK_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_REC709,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+static inline unsigned int dcmipp_isp_compute_decimation(unsigned int orig,
+							 unsigned int req)
+{
+	unsigned int i;
+
+	for (i = 0; i < 4; i++) {
+		if (req >= (orig / (1 << i)))
+			return i;
+	}
+
+	return (i - 1);
+}
+
+static void dcmipp_isp_adjust_fmt(struct v4l2_mbus_framefmt *fmt, u32 pad)
+{
+	/* Only accept code in the pix map table */
+	if (!dcmipp_isp_pix_map_by_code(fmt->code, pad))
+		fmt->code = IS_SRC(pad) ? ISP_MEDIA_BUS_SRC_FMT_DEFAULT :
+					  ISP_MEDIA_BUS_SINK_FMT_DEFAULT;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH) & ~1;
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT);
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = V4L2_FIELD_NONE;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_isp_init_cfg(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, state, i);
+		*mf = fmt_default;
+		mf->code = IS_SRC(i) ? ISP_MEDIA_BUS_SRC_FMT_DEFAULT :
+				       ISP_MEDIA_BUS_SINK_FMT_DEFAULT;
+	}
+
+	return 0;
+}
+
+static int dcmipp_isp_enum_mbus_code(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state,
+				     struct v4l2_subdev_mbus_code_enum *code)
+{
+	unsigned int pix_code;
+
+	pix_code = dcmipp_isp_pix_map_by_index(code->index, code->pad);
+	if (!pix_code)
+		return -EINVAL;
+
+	code->code = pix_code;
+
+	return 0;
+}
+
+static int dcmipp_isp_enum_frame_size(struct v4l2_subdev *sd,
+				      struct v4l2_subdev_state *state,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	if (!dcmipp_isp_pix_map_by_code(fse->code, fse->pad))
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_isp_get_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&isp->lock);
+
+	if (IS_SINK(fmt->pad))
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, fmt->pad) :
+			      isp->sink_fmt;
+	else
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, fmt->pad) :
+			      isp->src_fmt;
+
+	mutex_unlock(&isp->lock);
+
+	return 0;
+}
+
+static int dcmipp_isp_set_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_subdev_state *state,
+			      struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *pad_fmt;
+	int ret = 0;
+
+	mutex_lock(&isp->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (isp->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (IS_SINK(fmt->pad))
+			pad_fmt = &isp->sink_fmt;
+		else
+			pad_fmt = &isp->src_fmt;
+
+	} else {
+		pad_fmt = v4l2_subdev_get_try_format(sd, state, fmt->pad);
+	}
+
+	dcmipp_isp_adjust_fmt(&fmt->format, fmt->pad);
+
+	/* When setting sink format, we have to update the src format */
+	if (IS_SINK(fmt->pad)) {
+		struct v4l2_mbus_framefmt *src_pad_fmt;
+
+		if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+			src_pad_fmt = &isp->src_fmt;
+		else
+			src_pad_fmt = v4l2_subdev_get_try_format(sd, state, 1);
+
+		*src_pad_fmt = fmt->format;
+		if (fmt->format.code >= MEDIA_BUS_FMT_Y8_1X8 &&
+		    fmt->format.code < MEDIA_BUS_FMT_SBGGR8_1X8)
+			src_pad_fmt->code = MEDIA_BUS_FMT_YUV8_1X24;
+		else
+			src_pad_fmt->code = MEDIA_BUS_FMT_RGB888_1X24;
+
+		dev_dbg(isp->dev, "%s: source format update: new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+			isp->sd.name,
+			src_pad_fmt->width, src_pad_fmt->height,
+			src_pad_fmt->code, src_pad_fmt->colorspace,
+			src_pad_fmt->quantization,
+			src_pad_fmt->xfer_func, src_pad_fmt->ycbcr_enc);
+	}
+
+	dev_dbg(isp->dev, "%s: %s format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		isp->sd.name,
+		PAD_STR(fmt->pad),
+		/* old */
+		pad_fmt->width, pad_fmt->height, pad_fmt->code,
+		pad_fmt->colorspace, pad_fmt->quantization,
+		pad_fmt->xfer_func, pad_fmt->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*pad_fmt = fmt->format;
+
+	/* Update sink pad crop */
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		isp->crop.top = 0;
+		isp->crop.left = 0;
+		isp->crop.width = fmt->format.width;
+		isp->crop.height = fmt->format.height;
+
+		isp->compose.top = 0;
+		isp->compose.left = 0;
+		isp->compose.width = fmt->format.width;
+		isp->compose.height = fmt->format.height;
+		isp->decimation = 0;
+	}
+
+out:
+	mutex_unlock(&isp->lock);
+
+	return ret;
+}
+
+static struct v4l2_rect
+dcmipp_isp_get_crop_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+	return r;
+}
+
+static void dcmipp_isp_adjust_crop(struct v4l2_rect *r,
+				   const struct v4l2_mbus_framefmt *fmt,
+				   unsigned int fmt_width)
+{
+	const struct v4l2_rect src_rect =
+		dcmipp_isp_get_crop_bound(fmt);
+	static struct v4l2_rect crop_min = {
+		.width = DCMIPP_FMT_WIDTH_DEFAULT,
+		.height = 1,
+		.top = 8,
+		.left = 0,
+	};
+
+	/* Disallow rectangles smaller than the minimal one. */
+	crop_min.width = fmt_width;
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, &src_rect);
+}
+
+static int dcmipp_isp_get_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &isp->sink_fmt;
+		crop = &isp->crop;
+		compose = &isp->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = dcmipp_isp_get_crop_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_isp_set_selection(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt, *src_fmt;
+	struct v4l2_rect *crop, *compose;
+	unsigned int dec;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &isp->sink_fmt;
+		src_fmt = &isp->src_fmt;
+		crop = &isp->crop;
+		compose = &isp->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		src_fmt = v4l2_subdev_get_try_format(sd, state, 1);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_isp_adjust_crop(&s->r, sink_fmt, isp->sink_fmt.width);
+
+		*crop = s->r;
+
+		/* When we set the crop, this impact as well the compose */
+		*compose = s->r;
+
+		src_fmt->width = s->r.width;
+		src_fmt->height = s->r.height;
+
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+			isp->decimation = 0;
+
+		dev_dbg(isp->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r.top = 0;
+		s->r.left = 0;
+		if (s->r.width > crop->width)
+			s->r.width = crop->width;
+		if (s->r.height > crop->height)
+			s->r.height = crop->height;
+		dec = dcmipp_isp_compute_decimation(crop->width, s->r.width);
+		s->r.width = crop->width / (1 << dec);
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->decimation = 0;
+			isp->decimation |= (dec << DCMIPP_P1DECR_HDEC_SHIFT);
+		}
+		dec = dcmipp_isp_compute_decimation(crop->height, s->r.height);
+		s->r.height = crop->height / (1 << dec);
+		if (crop->height % (1 << dec))
+			s->r.height += 1;
+		if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+			isp->decimation |= (dec << DCMIPP_P1DECR_VDEC_SHIFT);
+			if (isp->decimation)
+				isp->decimation |= DCMIPP_P1DECR_ENABLE;
+		}
+
+		*compose = s->r;
+
+		src_fmt->width = s->r.width;
+		src_fmt->height = s->r.height;
+
+		dev_dbg(isp->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			s->r.width, s->r.height, s->r.left, s->r.top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_isp_pad_ops = {
+	.init_cfg		= dcmipp_isp_init_cfg,
+	.enum_mbus_code		= dcmipp_isp_enum_mbus_code,
+	.enum_frame_size	= dcmipp_isp_enum_frame_size,
+	.get_fmt		= dcmipp_isp_get_fmt,
+	.set_fmt		= dcmipp_isp_set_fmt,
+	.get_selection		= dcmipp_isp_get_selection,
+	.set_selection		= dcmipp_isp_set_selection,
+};
+
+static void dcmipp_isp_config_demosaicing(struct dcmipp_isp_device *isp)
+{
+	unsigned int pix_code = isp->sink_fmt.code, val = 0;
+
+	/* Disable demosaicing */
+	reg_clear(isp, DCMIPP_P1DMCR, DCMIPP_P1DMCR_ENABLE | DCMIPP_P1DMCR_TYPE_MASK);
+
+	if (pix_code >= 0x3000 && pix_code < 0x4000) {
+		dev_dbg(isp->dev, "Input is RawBayer, enable Demosaicing\n");
+
+		if (pix_code == MEDIA_BUS_FMT_SBGGR8_1X8 ||
+		    pix_code == MEDIA_BUS_FMT_SBGGR10_1X10 ||
+		    pix_code == MEDIA_BUS_FMT_SBGGR12_1X12 ||
+		    pix_code == MEDIA_BUS_FMT_SBGGR14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_BGGR << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (pix_code == MEDIA_BUS_FMT_SGBRG8_1X8 ||
+			 pix_code == MEDIA_BUS_FMT_SGBRG10_1X10 ||
+			 pix_code == MEDIA_BUS_FMT_SGBRG12_1X12 ||
+			 pix_code == MEDIA_BUS_FMT_SGBRG14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_GBRG << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (pix_code == MEDIA_BUS_FMT_SGRBG8_1X8 ||
+			 pix_code == MEDIA_BUS_FMT_SGRBG10_1X10 ||
+			 pix_code == MEDIA_BUS_FMT_SGRBG12_1X12 ||
+			 pix_code == MEDIA_BUS_FMT_SGRBG14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_GRBG << DCMIPP_P1DMCR_TYPE_SHIFT;
+		else if (pix_code == MEDIA_BUS_FMT_SRGGB8_1X8 ||
+			 pix_code == MEDIA_BUS_FMT_SRGGB10_1X10 ||
+			 pix_code == MEDIA_BUS_FMT_SRGGB12_1X12 ||
+			 pix_code == MEDIA_BUS_FMT_SRGGB14_1X14)
+			val = DCMIPP_P1DMCR_TYPE_RGGB << DCMIPP_P1DMCR_TYPE_SHIFT;
+
+		val |= DCMIPP_P1DMCR_ENABLE;
+	}
+
+	if (val)
+		reg_set(isp, DCMIPP_P1DMCR, val);
+}
+
+static int dcmipp_isp_colorconv_set(struct dcmipp_isp_device *isp,
+				    struct dcmipp_colorconv_config *ccconf)
+{
+	u32 val = 0;
+	int i;
+
+	for (i = 0; i < 6; i++)
+		reg_write(isp, DCMIPP_P1CCRR1 + (4 * i), ccconf->conv_matrix[i]);
+
+	if (ccconf->clamping)
+		val |= DCMIPP_P1CCCR_CLAMP;
+	if (ccconf->clamping_as_rgb)
+		val |= DCMIPP_P1CCCR_TYPE_RGB;
+	if (ccconf->enable)
+		val |= DCMIPP_P1CCCR_ENABLE;
+
+	reg_write(isp, DCMIPP_P1CCCR, val);
+
+	return 0;
+}
+
+static int dcmipp_isp_colorconv_auto(struct dcmipp_isp_device *isp)
+{
+	struct dcmipp_colorconv_config ccconf;
+	int ret;
+
+	/* Get the "src to sink" color conversion matrix */
+	ret = dcmipp_colorconv_configure(isp->dev, &isp->sink_fmt, &isp->src_fmt, &ccconf);
+	if (ret)
+		return ret;
+
+	return dcmipp_isp_colorconv_set(isp, &ccconf);
+}
+
+static bool dcmipp_isp_is_aux_output_enabled(struct dcmipp_isp_device *isp)
+{
+	struct media_link *link;
+
+	for_each_media_entity_data_link(isp->ved.ent, link) {
+		if (link->source != &isp->ved.pads[1])
+			continue;
+
+		if (!(link->flags & MEDIA_LNK_FL_ENABLED))
+			continue;
+
+		if (!strcmp(link->sink->entity->name, "dcmipp_aux_postproc"))
+			return true;
+	}
+
+	return false;
+}
+
+static int dcmipp_isp_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_isp_device *isp = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&isp->lock);
+	if (enable) {
+		/* Check if link between ISP & Pipe2 postproc is enabled */
+		if (dcmipp_isp_is_aux_output_enabled(isp))
+			reg_clear(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
+		else
+			reg_set(isp, DCMIPP_P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
+
+		/* Configure Statistic Removal */
+		reg_write(isp, DCMIPP_P1SRCR,
+			  ((isp->crop.top << DCMIPP_P1SRCR_FIRSTLINEDEL_SHIFT) |
+			   (isp->crop.height << DCMIPP_P1SRCR_LASTLINE_SHIFT) |
+			   DCMIPP_P1SRCR_CROPEN));
+
+		/* Configure Decimation */
+		reg_write(isp, DCMIPP_P1DECR, isp->decimation);
+
+		/* Configure Demosaicing */
+		dcmipp_isp_config_demosaicing(isp);
+
+		/* Configure ColorConversion */
+		ret = dcmipp_isp_colorconv_auto(isp);
+		if (ret)
+			goto out;
+	}
+
+	isp->streaming = enable;
+
+out:
+	mutex_unlock(&isp->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops dcmipp_isp_video_ops = {
+	.s_stream = dcmipp_isp_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_isp_ops = {
+	.pad = &dcmipp_isp_pad_ops,
+	.video = &dcmipp_isp_video_ops,
+};
+
+void dcmipp_isp_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_isp_device *isp =
+			container_of(ved, struct dcmipp_isp_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &isp->sd);
+	mutex_destroy(&isp->lock);
+	kfree(isp);
+}
+
+struct dcmipp_ent_device *dcmipp_isp_ent_init(struct device *dev,
+					      const char *entity_name,
+					      struct v4l2_device *v4l2_dev,
+					      void __iomem *regs)
+{
+	struct dcmipp_isp_device *isp;
+	int ret;
+
+	/* Allocate the isp struct */
+	isp = kzalloc(sizeof(*isp), GFP_KERNEL);
+	if (!isp)
+		return ERR_PTR(-ENOMEM);
+
+	isp->regs = regs;
+	isp->dev = dev;
+
+	/* Initialize the lock */
+	mutex_init(&isp->lock);
+
+	/* Initialize the frame format */
+	isp->sink_fmt = fmt_default;
+	isp->sink_fmt.code = ISP_MEDIA_BUS_SINK_FMT_DEFAULT;
+	isp->src_fmt = fmt_default;
+	isp->src_fmt.code = ISP_MEDIA_BUS_SRC_FMT_DEFAULT;
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&isp->ved, &isp->sd,
+				     v4l2_dev,
+				     entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 4,
+				     (const unsigned long[4]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     NULL, &dcmipp_isp_ops,
+				     NULL, NULL);
+	if (ret) {
+		mutex_destroy(&isp->lock);
+		kfree(isp);
+		return ERR_PTR(ret);
+	}
+
+	return &isp->ved;
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelcap.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelcap.c
new file mode 100644
index 000000000..b5bb3009a
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelcap.c
@@ -0,0 +1,1187 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_PIXELCAP_DRV_NAME "dcmipp-pixelcap"
+
+#define DCMIPP_PRSR (0x1F8)
+#define DCMIPP_CMIER (0x3F0)
+#define DCMIPP_CMIER_P1FRAMEIE BIT(17)
+#define DCMIPP_CMIER_P1VSYNCIE BIT(18)
+#define DCMIPP_CMIER_P1OVRIE BIT(23)
+#define DCMIPP_CMIER_P2FRAMEIE BIT(25)
+#define DCMIPP_CMIER_P2VSYNCIE BIT(26)
+#define DCMIPP_CMIER_P2OVRIE BIT(31)
+#define DCMIPP_CMIER_PxALL(id) (((id) == 1) ? (DCMIPP_CMIER_P1VSYNCIE |\
+					       DCMIPP_CMIER_P1FRAMEIE |\
+					       DCMIPP_CMIER_P1OVRIE) :\
+					      (DCMIPP_CMIER_P2VSYNCIE |\
+					       DCMIPP_CMIER_P2FRAMEIE |\
+					       DCMIPP_CMIER_P2OVRIE))
+#define DCMIPP_CMSR1 (0x3F4)
+#define DCMIPP_CMSR2 (0x3F8)
+#define DCMIPP_CMSR2_P1FRAMEF BIT(17)
+#define DCMIPP_CMSR2_P1VSYNCF BIT(18)
+#define DCMIPP_CMSR2_P1OVRF BIT(23)
+#define DCMIPP_CMSR2_P2FRAMEF BIT(25)
+#define DCMIPP_CMSR2_P2VSYNCF BIT(26)
+#define DCMIPP_CMSR2_P2OVRF BIT(31)
+#define DCMIPP_CMSR2_PxFRAMEF(id) (((id) == 1) ? DCMIPP_CMSR2_P1FRAMEF :\
+						 DCMIPP_CMSR2_P2FRAMEF)
+#define DCMIPP_CMSR2_PxVSYNCF(id) (((id) == 1) ? DCMIPP_CMSR2_P1VSYNCF :\
+						 DCMIPP_CMSR2_P2VSYNCF)
+#define DCMIPP_CMSR2_PxOVRF(id) (((id) == 1) ? DCMIPP_CMSR2_P1OVRF :\
+					       DCMIPP_CMSR2_P2OVRF)
+#define DCMIPP_CMFCR (0x3FC)
+#define DCMIPP_P1FSCR (0x804)
+#define DCMIPP_P2FSCR (0xC04)
+#define DCMIPP_PxFSCR(id) (((id) == 1) ? DCMIPP_P1FSCR :\
+					 DCMIPP_P2FSCR)
+#define DCMIPP_PxFSCR_PIPEN BIT(31)
+#define DCMIPP_P1FCTCR (0x900)
+#define DCMIPP_P2FCTCR (0xD00)
+#define DCMIPP_PxFCTCR(id) (((id) == 1) ? DCMIPP_P1FCTCR :\
+					  DCMIPP_P2FCTCR)
+#define DCMIPP_PxFCTCR_CPTMODE BIT(2)
+#define DCMIPP_PxFCTCR_CPTREQ BIT(3)
+#define DCMIPP_P1PPM0AR1 (0x9C4)
+#define DCMIPP_P2PPM0AR1 (0xDC4)
+#define DCMIPP_PxPPM0AR1(id) (((id) == 1) ? DCMIPP_P1PPM0AR1 :\
+					    DCMIPP_P2PPM0AR1)
+#define DCMIPP_P1PPM0PR (0x9CC)
+#define DCMIPP_P2PPM0PR (0xDCC)
+#define DCMIPP_PxPPM0PR(id) (((id) == 1) ? DCMIPP_P1PPM0PR :\
+					   DCMIPP_P2PPM0PR)
+#define DCMIPP_P1PPM1AR1 (0x9D4)
+#define DCMIPP_P1PPM1PR (0x9DC)
+#define DCMIPP_P1PPM2AR1 (0x9E4)
+
+#define DCMIPP_P1SR (0x9F8)
+#define DCMIPP_P2SR (0xDF8)
+#define DCMIPP_PxSR(id) (((id) == 1) ? DCMIPP_P1SR :\
+				       DCMIPP_P2SR)
+#define DCMIPP_PxSR_CPTACT BIT(23)
+
+struct dcmipp_pixelcap_pix_map {
+	unsigned int code;
+	u32 pixelformat;
+	u32 plane_nb;
+};
+
+#define PIXMAP_MBUS_PFMT(mbus, fmt, nb_plane)			\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.pixelformat = V4L2_PIX_FMT_##fmt,	\
+			.plane_nb = nb_plane,			\
+		}
+
+static const struct dcmipp_pixelcap_pix_map dcmipp_pixelcap_pix_map_list[] = {
+	/* Coplanar formats are supported on main & aux pipe */
+	PIXMAP_MBUS_PFMT(RGB565_2X8_LE, RGB565, 1),
+	PIXMAP_MBUS_PFMT(YUYV8_2X8, YUYV, 1),
+	PIXMAP_MBUS_PFMT(YVYU8_2X8, YVYU, 1),
+	PIXMAP_MBUS_PFMT(UYVY8_2X8, UYVY, 1),
+	PIXMAP_MBUS_PFMT(VYUY8_2X8, VYUY, 1),
+	PIXMAP_MBUS_PFMT(Y8_1X8, GREY, 1),
+	PIXMAP_MBUS_PFMT(RGB888_1X24, RGB24, 1),
+	PIXMAP_MBUS_PFMT(BGR888_1X24, BGR24, 1),
+	PIXMAP_MBUS_PFMT(ARGB8888_1X32, ARGB32, 1),
+	PIXMAP_MBUS_PFMT(AYUV8_1X32, AYUV32, 1),
+
+	/* Semiplanar & planar formats (plane_nb > 1) are only supported on main pipe */
+	PIXMAP_MBUS_PFMT(YUYV8_1_5X8, NV12, 2),   /* FIXME no mbus code for NV12 */
+	PIXMAP_MBUS_PFMT(YVYU8_1_5X8, NV21, 2),   /* FIXME no mbus code for NV21 */
+	PIXMAP_MBUS_PFMT(YUYV8_1X16, NV16, 2),    /* FIXME no mbus code for NV16 */
+	PIXMAP_MBUS_PFMT(YVYU8_1X16, NV61, 2),    /* FIXME no mbus code for NV61 */
+	PIXMAP_MBUS_PFMT(UYVY8_1_5X8, YUV420, 3), /* FIXME no mbus code for YUV420 */
+	PIXMAP_MBUS_PFMT(VYUY8_1_5X8, YVU420, 3), /* FIXME no mbus code for YVU420 */
+};
+
+static const struct dcmipp_pixelcap_pix_map *dcmipp_pixelcap_pix_map_by_pixelformat
+						(u32 pixelformat)
+{
+	const struct dcmipp_pixelcap_pix_map *l = dcmipp_pixelcap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_pixelcap_pix_map_list);
+	unsigned int i;
+
+	for (i = 0; i < size; i++) {
+		if (l[i].pixelformat == pixelformat)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+static const struct dcmipp_pixelcap_pix_map *dcmipp_pixelcap_pix_map_by_index(unsigned int i)
+{
+	const struct dcmipp_pixelcap_pix_map *l = dcmipp_pixelcap_pix_map_list;
+	unsigned int size = ARRAY_SIZE(dcmipp_pixelcap_pix_map_list);
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	bool			prepared;
+	dma_addr_t		paddr;
+	size_t			size;
+	dma_addr_t		paddrs[3];
+	u32			strides[3];
+	u64			sizes[3];
+	struct list_head	list;
+};
+
+enum state {
+	STOPPED = 0,
+	WAIT_FOR_BUFFER,
+	RUNNING,
+};
+
+struct dcmipp_pixelcap_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct v4l2_pix_format format;
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+
+	enum state state;
+
+	/*
+	 * DCMIPP driver is handling 2 buffers
+	 * active: buffer into which DCMIPP is currently writing into
+	 * next: buffer given to the DCMIPP and which will become
+	 *       automatically active on next VSYNC
+	 */
+	struct dcmipp_buf *active, *next;
+
+	void __iomem *regs;
+
+	u32 pipe_id;
+
+	u32 cmier;
+	u32 cmsr2;
+
+	int errors_count;
+	int overrun_count;
+	int buffers_count;
+	int vsync_count;
+	int frame_count;
+	int it_count;
+	int underrun_count;
+	int nactive_count;
+};
+
+static const struct v4l2_pix_format fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.pixelformat = V4L2_PIX_FMT_RGB565,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_REC709,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+struct dcmipp_pixelcap_buffer {
+	/*
+	 * struct vb2_v4l2_buffer must be the first element
+	 * the videobuf2 framework will allocate this struct based on
+	 * buf_struct_size and use the first sizeof(struct vb2_buffer) bytes of
+	 * memory as a vb2_buffer
+	 */
+	struct vb2_v4l2_buffer vb2;
+	struct list_head list;
+};
+
+static inline int hdw_pixel_alignment(u32 format)
+{
+	/* 16 bytes alignment required by hardware */
+	switch (format) {
+	case V4L2_PIX_FMT_NV12:
+	case V4L2_PIX_FMT_NV21:
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	case V4L2_PIX_FMT_NV16:
+	case V4L2_PIX_FMT_NV61:
+	case V4L2_PIX_FMT_GREY:
+		return 4;/* 2^4 = 16 pixels = 16 bytes */
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_VYUY:
+		return 3;/* 2^3  = 8 pixels = 16 bytes */
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+		return 4;/* 2^4 = 16 pixels = 48 bytes */
+	case V4L2_PIX_FMT_ARGB32:
+		return 2;/* 2^2  = 4 pixels = 16 bytes */
+	default:
+		return 0;
+	}
+}
+
+static inline int frame_planes(dma_addr_t base_addr, dma_addr_t addrs[],
+			       u32 strides[], u64 sizes[],
+			       u32 width, u32 height, u32 format)
+{
+	const struct v4l2_format_info *info;
+
+	info = v4l2_format_info(format);
+	if (!info)
+		return -EINVAL;
+
+	/* Fill-in each plane information */
+	addrs[0] = base_addr;
+	strides[0] = width * info->bpp[0];
+	sizes[0] = strides[0] * height;
+
+	if (info->comp_planes > 1) {
+		addrs[1] = addrs[0] + sizes[0];
+		strides[1] = width * info->bpp[1] / info->hdiv;
+		sizes[1] = strides[1] * height / info->vdiv;
+	}
+
+	if (info->comp_planes > 2) {
+		addrs[2] = addrs[1] + sizes[1];
+		strides[2] = width * info->bpp[2] / info->hdiv;
+		sizes[2] = strides[2] * height / info->vdiv;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_querycap(struct file *file, void *priv,
+				    struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static void dcmipp_pixelcap_get_format(struct dcmipp_ent_device *ved,
+				       struct v4l2_pix_format *fmt)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(ved, struct dcmipp_pixelcap_device, ved);
+
+	*fmt = vcap->format;
+}
+
+static int dcmipp_pixelcap_g_fmt_vid_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	f->fmt.pix = vcap->format;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_try_fmt_vid_cap(struct file *file, void *priv,
+					   struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	struct v4l2_pix_format *format = &f->fmt.pix;
+	const struct dcmipp_pixelcap_pix_map *vpix;
+	u32 in_w, in_h;
+
+	/* Don't accept a pixelformat that is not on the table */
+	vpix = dcmipp_pixelcap_pix_map_by_pixelformat(format->pixelformat);
+	if (!vpix) {
+		format->pixelformat = fmt_default.pixelformat;
+		vpix = dcmipp_pixelcap_pix_map_by_pixelformat(format->pixelformat);
+	}
+
+	/* Semiplanar & planar formats are only supported on main pipe */
+	if (vpix->plane_nb > 1 && vcap->pipe_id != 1)
+		format->pixelformat = fmt_default.pixelformat;
+
+	/* Adjust width & height */
+	in_w = format->width;
+	in_h = format->height;
+	format->width = clamp_t(u32, format->width, DCMIPP_FRAME_MIN_WIDTH,
+				DCMIPP_FRAME_MAX_WIDTH);
+	format->width = round_up(format->width,
+				 1 << hdw_pixel_alignment(format->pixelformat));
+	format->height = clamp_t(u32, format->height,
+				 DCMIPP_FRAME_MIN_HEIGHT,
+				 DCMIPP_FRAME_MAX_HEIGHT);
+	if (format->width != in_w || format->height != in_h)
+		dev_dbg(vcap->dev,
+			"resolution updated: %dx%d -> %dx%d\n",
+			in_w, in_h, format->width, format->height);
+
+	v4l2_fill_pixfmt(format, format->pixelformat,
+			 format->width, format->height);
+
+	if (format->field == V4L2_FIELD_ANY)
+		format->field = fmt_default.field;
+
+	dcmipp_colorimetry_clamp(format);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_s_fmt_vid_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	/* Do not change the format while stream is on */
+	if (vb2_is_busy(&vcap->queue))
+		return -EBUSY;
+
+	ret = dcmipp_pixelcap_try_fmt_vid_cap(file, priv, f);
+	if (ret)
+		return ret;
+
+	dev_dbg(vcap->dev, "%s: format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		vcap->vdev.name,
+		/* old */
+		vcap->format.width, vcap->format.height,
+		vcap->format.pixelformat, vcap->format.colorspace,
+		vcap->format.quantization, vcap->format.xfer_func,
+		vcap->format.ycbcr_enc,
+		/* new */
+		f->fmt.pix.width, f->fmt.pix.height,
+		f->fmt.pix.pixelformat, f->fmt.pix.colorspace,
+		f->fmt.pix.quantization, f->fmt.pix.xfer_func,
+		f->fmt.pix.ycbcr_enc);
+
+	vcap->format = f->fmt.pix;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_enum_fmt_vid_cap(struct file *file, void *priv,
+					    struct v4l2_fmtdesc *f)
+{
+	const struct dcmipp_pixelcap_pix_map *vpix = dcmipp_pixelcap_pix_map_by_index(f->index);
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	vpix = dcmipp_pixelcap_pix_map_by_index(f->index);
+	if (!vpix)
+		return -EINVAL;
+
+	/* Semiplanar & planar formats are only supported on main pipe */
+	if (vpix->plane_nb > 1 && vcap->pipe_id != 1)
+		return -EINVAL;
+
+	f->pixelformat = vpix->pixelformat;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_enum_framesizes(struct file *file, void *fh,
+					   struct v4l2_frmsizeenum *fsize)
+{
+	const struct dcmipp_pixelcap_pix_map *vpix;
+
+	if (fsize->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelcap_pix_map_by_pixelformat(fsize->pixel_format);
+	if (!vpix)
+		return -EINVAL;
+
+	/* TODO - need to differentiate here format of MAIN vs AUX */
+
+	fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+	fsize->stepwise.min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fsize->stepwise.max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fsize->stepwise.min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fsize->stepwise.max_height = DCMIPP_FRAME_MAX_HEIGHT;
+	fsize->stepwise.step_width = 1;
+	fsize->stepwise.step_height = 1;
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_open(struct file *file)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	ret = mutex_lock_interruptible(&vcap->lock);
+	if (ret)
+		return ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto err_unlock;
+
+	ret = v4l2_pipeline_pm_get(&vcap->vdev.entity);
+	if (ret)
+		goto err_close;
+
+	mutex_unlock(&vcap->lock);
+
+	return 0;
+
+err_close:
+	v4l2_fh_release(file);
+err_unlock:
+	mutex_unlock(&vcap->lock);
+
+	return ret;
+}
+
+static int dcmipp_pixelcap_close(struct file *file)
+{
+	struct dcmipp_pixelcap_device *vcap = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	v4l2_pipeline_pm_put(&vcap->vdev.entity);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations dcmipp_pixelcap_fops = {
+	.owner		= THIS_MODULE,
+	.open		= dcmipp_pixelcap_open,
+	.release	= dcmipp_pixelcap_close,
+	.read           = vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops dcmipp_pixelcap_ioctl_ops = {
+	.vidioc_querycap = dcmipp_pixelcap_querycap,
+
+	.vidioc_g_fmt_vid_cap = dcmipp_pixelcap_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap = dcmipp_pixelcap_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap = dcmipp_pixelcap_try_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = dcmipp_pixelcap_enum_fmt_vid_cap,
+	.vidioc_enum_framesizes = dcmipp_pixelcap_enum_framesizes,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+static int dcmipp_pipeline_s_stream(struct dcmipp_pixelcap_device *vcap,
+				    int state)
+{
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_pad_remote_pad_first(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		if (state) {
+			/* Increment stream_count to indicate that entity is streamon */
+			entity->stream_count++;
+
+			/*
+			 * Do not streamon entities already started and streamon
+			 * by another capture pipeline
+			 */
+			if (entity->stream_count > 1)
+				continue;
+		} else {
+			/* Decrement stream_count to indicate that entity is streamoff. */
+			entity->stream_count--;
+
+			/*
+			 * Only streamoff if entity is not owned anymore
+			 * by other pipelines
+			 */
+			if (entity->stream_count > 0)
+				continue;
+		}
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(vcap->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+
+			goto out;
+		}
+
+		dev_dbg(vcap->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+out:
+	mutex_unlock(&mdev->graph_mutex);
+
+	return ret;
+}
+
+static int dcmipp_start_capture(struct dcmipp_pixelcap_device *vcap,
+				struct dcmipp_buf *buf)
+{
+	/*
+	 * Set frame addresses
+	 * Those registers are taken into account immediately
+	 */
+	if (buf->paddrs[0]) {
+		reg_write(vcap, DCMIPP_PxPPM0AR1(vcap->pipe_id), buf->paddrs[0]);
+		reg_write(vcap, DCMIPP_PxPPM0PR(vcap->pipe_id), buf->strides[0]);
+	}
+
+	if (buf->paddrs[1]) {
+		reg_write(vcap, DCMIPP_P1PPM1AR1, buf->paddrs[1]);
+		reg_write(vcap, DCMIPP_P1PPM1PR, buf->strides[1]);
+	}
+
+	if (buf->paddrs[2])
+		reg_write(vcap, DCMIPP_P1PPM2AR1, buf->paddrs[2]);
+
+	/* Capture request */
+	reg_set(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_start_streaming(struct vb2_queue *vq,
+					   unsigned int count)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_pipeline *pipe;
+	struct dcmipp_buf *buf, *node;
+	int ret;
+
+	vcap->sequence = 0;
+	vcap->errors_count = 0;
+	vcap->overrun_count = 0;
+	vcap->buffers_count = 0;
+	vcap->vsync_count = 0;
+	vcap->frame_count = 0;
+	vcap->it_count = 0;
+	vcap->underrun_count = 0;
+	vcap->nactive_count = 0;
+
+	ret = pm_runtime_get_sync(vcap->dev);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/*
+	 * Start the media pipeline
+	 *
+	 * Pipeline is shared between all elements of the pipeline
+	 * including video capture nodes.
+	 * Instead of creating a common media_pipeline struct
+	 * global variable, use the one of the first capture
+	 * node. All the elements of the pipeline -including
+	 * other capture nodes- will be then assigned to this
+	 * pipeline (entity->pipe) in __media_pipeline_start().
+	 */
+	mutex_lock(&mdev->graph_mutex);
+	pipe = entity->pads[0].pipe ? : &vcap->pipe;
+	ret = __video_device_pipeline_start(&vcap->vdev, pipe);
+	mutex_unlock(&mdev->graph_mutex);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, media pipeline start error (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start all the elements within pipeline */
+	ret = dcmipp_pipeline_s_stream(vcap, 1);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	/* Enable interruptions */
+	vcap->cmier |= DCMIPP_CMIER_PxALL(vcap->pipe_id);
+	spin_lock(&vcap->vdev.v4l2_dev->lock);
+	reg_set(vcap, DCMIPP_CMIER, vcap->cmier);
+	spin_unlock(&vcap->vdev.v4l2_dev->lock);
+
+	/* Enable pipe at the end of programming */
+	reg_set(vcap, DCMIPP_PxFSCR(vcap->pipe_id), DCMIPP_PxFSCR_PIPEN);
+
+	/*
+	 * Start capture if at least one buffer has been queued,
+	 * otherwise start is deferred at next buffer queueing
+	 */
+	buf = list_first_entry_or_null(&vcap->buffers, typeof(*buf), list);
+	if (!buf) {
+		dev_dbg(vcap->dev, "Start streaming is deferred to next buffer queueing\n");
+		vcap->next = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return 0;
+	}
+	vcap->next = buf;
+	dev_dbg(vcap->dev, "Start with next [%d] %p phy=%pad\n",
+		buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	vcap->state = RUNNING;
+
+	/* Start capture */
+	ret = dcmipp_start_capture(vcap, buf);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	return 0;
+
+err_media_pipeline_stop:
+	media_pipeline_stop(entity->pads);
+err_pm_put:
+	pm_runtime_put(vcap->dev);
+	spin_lock_irq(&vcap->irqlock);
+	/*
+	 * Return all buffers to vb2 in QUEUED state.
+	 * This will give ownership back to userspace
+	 */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	vcap->active = NULL;
+	spin_unlock_irq(&vcap->irqlock);
+
+	return ret;
+}
+
+static void dcmipp_dump_status(struct dcmipp_pixelcap_device *vcap)
+{
+	struct device *dev = vcap->dev;
+
+	dev_dbg(dev, "[DCMIPP_PRSR]  =%#10.8x\n", reg_read(vcap, DCMIPP_PRSR));
+	dev_dbg(dev, "[DCMIPP_PxSR] =%#10.8x\n", reg_read(vcap, DCMIPP_PxSR(vcap->pipe_id)));
+	dev_dbg(dev, "[DCMIPP_CMSR1] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR1));
+	dev_dbg(dev, "[DCMIPP_CMSR2] =%#10.8x\n", reg_read(vcap, DCMIPP_CMSR2));
+}
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_pixelcap_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+	int ret;
+	u32 status;
+
+	dcmipp_pipeline_s_stream(vcap, 0);
+
+	/* Stop the media pipeline */
+	media_pipeline_stop(vcap->vdev.entity.pads);
+
+	/* Disable interruptions */
+	spin_lock(&vcap->vdev.v4l2_dev->lock);
+	reg_clear(vcap, DCMIPP_CMIER, vcap->cmier);
+	spin_unlock(&vcap->vdev.v4l2_dev->lock);
+
+	/* Stop capture */
+	reg_clear(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+	/* Wait until CPTACT become 0 */
+	ret = readl_relaxed_poll_timeout(vcap->regs + DCMIPP_PxSR(vcap->pipe_id),
+					 status,
+					 !(status & DCMIPP_PxSR_CPTACT),
+					 20, 1000);
+	if (ret)
+		dev_warn(vcap->dev, "Timeout when stopping\n");
+
+	/* Disable pipe */
+	reg_clear(vcap, DCMIPP_PxFSCR(vcap->pipe_id), DCMIPP_PxFSCR_PIPEN);
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vcap->buffers);
+
+	vcap->active = NULL;
+	vcap->state = STOPPED;
+
+	dcmipp_dump_status(vcap);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	pm_runtime_put(vcap->dev);
+
+	if (vcap->errors_count)
+		dev_warn(vcap->dev, "Some errors found while streaming: errors=%d (overrun=%d, nactive=%d), underrun=%d, buffers=%d\n",
+			 vcap->errors_count, vcap->overrun_count, vcap->nactive_count,
+			 vcap->underrun_count, vcap->buffers_count);
+	dev_dbg(vcap->dev, "Stop streaming, errors=%d (overrun=%d, nactive=%d), underrun=%d, vsync=%d, frame=%d, buffers=%d, it=%d\n",
+		vcap->errors_count, vcap->overrun_count, vcap->nactive_count,
+		vcap->underrun_count, vcap->vsync_count,
+		vcap->frame_count, vcap->buffers_count,
+		vcap->it_count);
+}
+
+static int dcmipp_pixelcap_buf_prepare(struct vb2_buffer *vb)
+{
+	struct dcmipp_pixelcap_device *vcap =  vb2_get_drv_priv(vb->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+	struct v4l2_pix_format *format = &vcap->format;
+	unsigned long size;
+	int ret;
+
+	size = format->sizeimage;
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(vcap->dev, "%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	if (!buf->prepared) {
+		/* Get memory addresses */
+		buf->paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		buf->size = vb2_plane_size(&buf->vb.vb2_buf, 0);
+
+		ret = frame_planes(buf->paddr,
+				   buf->paddrs, buf->strides, buf->sizes,
+				   format->width, format->height,
+				   format->pixelformat);
+		if (ret) {
+			dev_err(vcap->dev, "%s: Unsupported pixel format (%x)\n",
+				__func__, format->pixelformat);
+			return ret;
+		}
+
+		/* Check for 16 bytes alignment required by hardware */
+		WARN_ON(buf->paddrs[0] & 15);
+		WARN_ON(buf->strides[0] & 15);
+		WARN_ON(buf->paddrs[1] & 15);
+		WARN_ON(buf->strides[1] & 15);
+		WARN_ON(buf->paddrs[2] & 15);
+
+		buf->prepared = true;
+
+		vb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);
+
+		dev_dbg(vcap->dev, "buffer[%d] phy=%pad size=%zu\n",
+			vb->index, &buf->paddr, buf->size);
+	}
+
+	return 0;
+}
+
+static void dcmipp_pixelcap_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vcap->irqlock);
+	list_add_tail(&buf->list, &vcap->buffers);
+
+	dev_dbg(vcap->dev, "Queue [%d] %p phy=%pad\n", buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+	if (vcap->state == WAIT_FOR_BUFFER) {
+		vcap->next = buf;
+		dev_dbg(vcap->dev, "Restart with next [%d] %p phy=%pad\n",
+			buf->vb.vb2_buf.index, buf, &buf->paddr);
+
+		dcmipp_start_capture(vcap, buf);
+
+		vcap->state = RUNNING;
+
+		spin_unlock_irq(&vcap->irqlock);
+
+		return;
+	}
+
+	spin_unlock_irq(&vcap->irqlock);
+}
+
+static int dcmipp_pixelcap_queue_setup(struct vb2_queue *vq,
+				       unsigned int *nbuffers,
+				       unsigned int *nplanes,
+				       unsigned int sizes[],
+				       struct device *alloc_devs[])
+{
+	struct dcmipp_pixelcap_device *vcap = vb2_get_drv_priv(vq);
+	unsigned int size;
+
+	size = vcap->format.sizeimage;
+
+	/* Make sure the image size is large enough */
+	if (*nplanes)
+		return sizes[0] < vcap->format.sizeimage ? -EINVAL : 0;
+
+	*nplanes = 1;
+	sizes[0] = vcap->format.sizeimage;
+
+	dev_dbg(vcap->dev, "Setup queue, count=%d, size=%d\n",
+		*nbuffers, size);
+
+	return 0;
+}
+
+static int dcmipp_pixelcap_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_pixelcap_qops = {
+	.start_streaming	= dcmipp_pixelcap_start_streaming,
+	.stop_streaming		= dcmipp_pixelcap_stop_streaming,
+	.buf_init		= dcmipp_pixelcap_buf_init,
+	.buf_prepare		= dcmipp_pixelcap_buf_prepare,
+	.buf_queue		= dcmipp_pixelcap_buf_queue,
+	.queue_setup		= dcmipp_pixelcap_queue_setup,
+	/*
+	 * Since q->lock is set we can use the standard
+	 * vb2_ops_wait_prepare/finish helper functions.
+	 */
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_pixelcap_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static void dcmipp_pixelcap_release(struct video_device *vdev)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(vdev, struct dcmipp_pixelcap_device, vdev);
+
+	dcmipp_pads_cleanup(vcap->ved.pads);
+	kfree(vcap);
+}
+
+void dcmipp_pixelcap_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_pixelcap_device *vcap =
+		container_of(ved, struct dcmipp_pixelcap_device, ved);
+
+	mutex_destroy(&vcap->lock);
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vcap->vdev);
+}
+
+static void dcmipp_buffer_done(struct dcmipp_pixelcap_device *vcap,
+			       struct dcmipp_buf *buf,
+			       size_t bytesused,
+			       int err)
+{
+	struct vb2_v4l2_buffer *vbuf;
+
+	list_del_init(&buf->list);
+
+	vbuf = &buf->vb;
+
+	vbuf->sequence = vcap->sequence++;
+	vbuf->field = V4L2_FIELD_NONE;
+	vbuf->vb2_buf.timestamp = ktime_get_ns();
+	vb2_set_plane_payload(&vbuf->vb2_buf, 0, bytesused);
+	vb2_buffer_done(&vbuf->vb2_buf,
+			err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);
+
+	vcap->buffers_count++;
+}
+
+/* irqlock must be held */
+static void dcmipp_pixelcap_set_next_frame_or_stop(struct dcmipp_pixelcap_device *vcap)
+{
+	if (!vcap->next && list_is_singular(&vcap->buffers)) {
+		/*
+		 * If there is no available buffer (none or a single one in the list while two
+		 * are expected), stop the capture (effective for next frame). On-going frame
+		 * capture will continue till FRAME END but no further capture will be done.
+		 */
+		reg_clear(vcap, DCMIPP_PxFCTCR(vcap->pipe_id), DCMIPP_PxFCTCR_CPTREQ);
+
+		dev_dbg(vcap->dev, "Capture restart is deferred to next buffer queueing\n");
+		vcap->next = NULL;
+		vcap->state = WAIT_FOR_BUFFER;
+		return;
+	}
+
+	/* If we don't have buffer yet, pick the one after active */
+	if (!vcap->next)
+		vcap->next = list_next_entry(vcap->active, list);
+
+	/*
+	 * Set buffer address
+	 * This register is shadowed and will be taken into
+	 * account on next VSYNC (start of next frame)
+	 */
+	reg_write(vcap, DCMIPP_PxPPM0AR1(vcap->pipe_id), vcap->next->paddrs[0]);
+	if (vcap->next->paddrs[1])
+		reg_write(vcap, DCMIPP_P1PPM1AR1, vcap->next->paddrs[1]);
+	if (vcap->next->paddrs[2])
+		reg_write(vcap, DCMIPP_P1PPM2AR1, vcap->next->paddrs[2]);
+	dev_dbg(vcap->dev, "Write [%d] %p phy=%pad\n",
+		vcap->next->vb.vb2_buf.index, vcap->next, &vcap->next->paddr);
+}
+
+/* irqlock must be held */
+static void dcmipp_pixelcap_process_frame(struct dcmipp_pixelcap_device *vcap)
+{
+	int err = 0;
+	struct dcmipp_buf *buf = vcap->active;
+
+	if (!buf) {
+		vcap->nactive_count++;
+		vcap->errors_count++;
+		return;
+	}
+
+	dcmipp_buffer_done(vcap, buf, vcap->format.sizeimage, err);
+	vcap->active = NULL;
+}
+
+static irqreturn_t dcmipp_pixelcap_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_pixelcap_device *vcap =
+			container_of(arg, struct dcmipp_pixelcap_device, ved);
+	u32 cmsr2_pxframef;
+	u32 cmsr2_pxvsyncf;
+	u32 cmsr2_pxovrf;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	cmsr2_pxovrf = DCMIPP_CMSR2_PxOVRF(vcap->pipe_id);
+	cmsr2_pxvsyncf = DCMIPP_CMSR2_PxVSYNCF(vcap->pipe_id);
+	cmsr2_pxframef = DCMIPP_CMSR2_PxFRAMEF(vcap->pipe_id);
+
+	if (vcap->cmsr2 & cmsr2_pxovrf) {
+		vcap->errors_count++;
+		vcap->overrun_count++;
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxframef) {
+		vcap->frame_count++;
+
+		dcmipp_pixelcap_process_frame(vcap);
+	}
+
+	if (vcap->cmsr2 & cmsr2_pxvsyncf) {
+		vcap->vsync_count++;
+		if (vcap->state == WAIT_FOR_BUFFER) {
+			vcap->underrun_count++;
+			goto out;
+		}
+
+		/*
+		 * On VSYNC, the previously set next buffer is going to become active thanks to
+		 * the shadowing mechanism of the DCMIPP. In most of the cases, since a FRAMEEND
+		 * has already come, pointer next is NULL since active is reset during the
+		 * FRAMEEND handling. However, in case of framerate adjustment, there are more
+		 * VSYNC than FRAMEEND. Thus we recycle the active (but not used) buffer and put it
+		 * back into next.
+		 */
+		swap(vcap->active, vcap->next);
+		dcmipp_pixelcap_set_next_frame_or_stop(vcap);
+	}
+
+out:
+	spin_unlock_irq(&vcap->irqlock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dcmipp_pixelcap_irq_callback(int irq, void *arg)
+{
+	struct dcmipp_pixelcap_device *vcap =
+			container_of(arg, struct dcmipp_pixelcap_device, ved);
+	struct dcmipp_ent_device *ved = arg;
+
+	vcap->cmsr2 = ved->cmsr2 & vcap->cmier;
+
+	vcap->it_count++;
+
+	/* Clear interrupt */
+	reg_write(vcap, DCMIPP_CMFCR, vcap->cmsr2);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static int dcmipp_name_to_pipe_id(const char *name)
+{
+	if (strstr(name, "main"))
+		return 1;
+	else if (strstr(name, "aux"))
+		return 2;
+	else
+		return -EINVAL;
+}
+
+struct dcmipp_ent_device *
+dcmipp_pixelcap_ent_init(struct device *dev, const char *entity_name,
+			 struct v4l2_device *v4l2_dev, void __iomem *regs)
+{
+	struct dcmipp_pixelcap_device *vcap;
+	struct v4l2_pix_format *format;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret = 0;
+
+	/* Allocate the dcmipp_cap_device struct */
+	vcap = kzalloc(sizeof(*vcap), GFP_KERNEL);
+	if (!vcap)
+		return ERR_PTR(-ENOMEM);
+
+	/* Retrieve the pipe_id */
+	vcap->pipe_id = dcmipp_name_to_pipe_id(entity_name);
+	if (vcap->pipe_id != 1 && vcap->pipe_id != 2) {
+		dev_err(dev, "failed to retrieve pipe_id\n");
+		goto err_free_vcap;
+	}
+	/* Allocate the pads */
+	vcap->ved.pads =
+		dcmipp_pads_init(1, (const unsigned long[1]) {MEDIA_PAD_FL_SINK});
+	if (IS_ERR(vcap->ved.pads)) {
+		ret = PTR_ERR(vcap->ved.pads);
+		goto err_free_vcap;
+	}
+
+	/* Initialize the media entity */
+	vcap->vdev.entity.name = entity_name;
+	vcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vcap->vdev.entity,
+				     1, vcap->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vcap->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vcap->queue;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	q->lock = &vcap->lock;
+	q->drv_priv = vcap;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_pixelcap_qops;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = dev;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s: vb2 queue init failed (err=%d)\n",
+			entity_name, ret);
+		goto err_mutex_destroy;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vcap->buffers);
+	spin_lock_init(&vcap->irqlock);
+
+	/* Set default frame format */
+	vcap->format = fmt_default;
+	format = &vcap->format;
+	v4l2_fill_pixfmt(format, format->pixelformat,
+			 format->width, format->height);
+
+	/* Fill the dcmipp_ent_device struct */
+	vcap->ved.ent = &vcap->vdev.entity;
+	vcap->ved.vdev_get_format = dcmipp_pixelcap_get_format;
+	vcap->ved.handler = dcmipp_pixelcap_irq_callback;
+	vcap->ved.thread_fn = dcmipp_pixelcap_irq_thread;
+	vcap->dev = dev;
+	vcap->regs = regs;
+
+	/* Initialize the video_device struct */
+	vdev = &vcap->vdev;
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+			    V4L2_CAP_IO_MC;
+	vdev->entity.ops = &dcmipp_pixelcap_mops;
+	vdev->release = dcmipp_pixelcap_release;
+	vdev->fops = &dcmipp_pixelcap_fops;
+	vdev->ioctl_ops = &dcmipp_pixelcap_ioctl_ops;
+	vdev->lock = &vcap->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = v4l2_dev;
+	strscpy(vdev->name, entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vcap->ved);
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dev, "%s: video register failed (err=%d)\n",
+			vcap->vdev.name, ret);
+		goto err_mutex_destroy;
+	}
+
+	return &vcap->ved;
+
+err_mutex_destroy:
+	mutex_destroy(&vcap->lock);
+	media_entity_cleanup(&vcap->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vcap->ved.pads);
+err_free_vcap:
+	kfree(vcap);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelproc.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelproc.c
new file mode 100644
index 000000000..d120f69f0
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-pixelproc.c
@@ -0,0 +1,1006 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2021
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          Alain Volmat <alain.volmat@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/vmalloc.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-rect.h>
+#include <media/v4l2-subdev.h>
+
+#include "dcmipp-common.h"
+#include "dcmipp-colorconv.h"
+
+#define DCMIPP_PIXELPROC_DRV_NAME "dcmipp-pixelproc"
+
+#define DCMIPP_FMT_WIDTH_DEFAULT  640
+#define DCMIPP_FMT_HEIGHT_DEFAULT 480
+
+#define DCMIPP_P1FCTCR (0x900)
+#define DCMIPP_P2FCTCR (0xD00)
+#define DCMIPP_PxFCTCR(id) (((id) == 1) ? DCMIPP_P1FCTCR :\
+			   DCMIPP_P2FCTCR)
+#define DCMIPP_PxFCTCR_FRATE_MASK GENMASK(1, 0)
+#define DCMIPP_P1CRSTR (0x904)
+#define DCMIPP_P2CRSTR (0xD04)
+#define DCMIPP_PxCRSTR(id) (((id) == 1) ? DCMIPP_P1CRSTR :\
+			   DCMIPP_P2CRSTR)
+#define DCMIPP_PxCRSTR_HSTART_SHIFT	0
+#define DCMIPP_PxCRSTR_VSTART_SHIFT	16
+#define DCMIPP_P1CRSZR (0x908)
+#define DCMIPP_P2CRSZR (0xD08)
+#define DCMIPP_PxCRSZR(id) (((id) == 1) ? DCMIPP_P1CRSZR :\
+			   DCMIPP_P2CRSZR)
+#define DCMIPP_PxCRSZR_ENABLE BIT(31)
+#define DCMIPP_PxCRSZR_HSIZE_SHIFT	0
+#define DCMIPP_PxCRSZR_VSIZE_SHIFT	16
+
+#define DCMIPP_P1DCCR (0x90C)
+#define DCMIPP_P2DCCR (0xD0C)
+#define DCMIPP_PxDCCR(id) (((id) == 1) ? DCMIPP_P1DCCR :\
+			   DCMIPP_P2DCCR)
+#define DCMIPP_PxDCCR_ENABLE BIT(0)
+#define DCMIPP_PxDCCR_HDEC_SHIFT 1
+#define DCMIPP_PxDCCR_VDEC_SHIFT 3
+
+#define DCMIPP_P1DSCR (0x910)
+#define DCMIPP_P2DSCR (0xD10)
+#define DCMIPP_PxDSCR(id) (((id) == 1) ? DCMIPP_P1DSCR :\
+			   DCMIPP_P2DSCR)
+#define DCMIPP_PxDSCR_HDIV_SHIFT 0
+#define DCMIPP_PxDSCR_HDIV_MASK GENMASK(9, 0)
+#define DCMIPP_PxDSCR_VDIV_SHIFT 16
+#define DCMIPP_PxDSCR_VDIV_MASK GENMASK(25, 16)
+#define DCMIPP_PxDSCR_ENABLE BIT(31)
+
+#define DCMIPP_P1DSRTIOR (0x914)
+#define DCMIPP_P2DSRTIOR (0xD14)
+#define DCMIPP_PxDSRTIOR(id) (((id) == 1) ? DCMIPP_P1DSRTIOR :\
+			   DCMIPP_P2DSRTIOR)
+#define DCMIPP_PxDSRTIOR_HRATIO_SHIFT 0
+#define DCMIPP_PxDSRTIOR_HRATIO_MASK GENMASK(15, 0)
+#define DCMIPP_PxDSRTIOR_VRATIO_SHIFT 16
+#define DCMIPP_PxDSRTIOR_VRATIO_MASK GENMASK(31, 16)
+
+#define DCMIPP_P1DSSZR (0x918)
+#define DCMIPP_P2DSSZR (0xD18)
+#define DCMIPP_PxDSSZR(id) (((id) == 1) ? DCMIPP_P1DSSZR :\
+			   DCMIPP_P2DSSZR)
+#define DCMIPP_PxDSSZR_HSIZE_SHIFT 0
+#define DCMIPP_PxDSSZR_HSIZE_MASK GENMASK(11, 0)
+#define DCMIPP_PxDSSZR_VSIZE_SHIFT 16
+#define DCMIPP_PxDSSZR_VSIZE_MASK GENMASK(27, 16)
+
+#define DCMIPP_P1GMCR (0x970)
+#define DCMIPP_P2GMCR (0xD70)
+#define DCMIPP_PxGMCR(id) (((id) == 1) ? DCMIPP_P1GMCR :\
+			   DCMIPP_P2GMCR)
+#define DCMIPP_PxGMCR_ENABLE BIT(0)
+
+#define DCMIPP_P1YUVCR (0x980)
+#define DCMIPP_P1YUVCR_ENABLE BIT(0)
+#define DCMIPP_P1YUVCR_TYPE_YUV 0
+#define DCMIPP_P1YUVCR_TYPE_RGB BIT(1)
+#define DCMIPP_P1YUVCR_CLAMP BIT(2)
+#define DCMIPP_P1YUVRR1 (0x984)
+#define DCMIPP_P1YUVRR2 (0x988)
+#define DCMIPP_P1YUVGR1 (0x98C)
+#define DCMIPP_P1YUVGR2 (0x990)
+#define DCMIPP_P1YUVBR1 (0x994)
+#define DCMIPP_P1YUVBR2 (0x998)
+
+#define DCMIPP_P1PPCR (0x9C0)
+#define DCMIPP_P2PPCR (0xDC0)
+#define DCMIPP_PxPPCR(id) (((id) == 1) ? DCMIPP_P1PPCR :\
+			   DCMIPP_P2PPCR)
+#define DCMIPP_PxPPCR_FORMAT_SHIFT 0
+#define DCMIPP_PxPPCR_FORMAT_MASK GENMASK(3, 0)
+#define DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER 0x0
+#define DCMIPP_PxPPCR_FORMAT_RGB565 0x1
+#define DCMIPP_PxPPCR_FORMAT_ARGB8888 0x2
+#define DCMIPP_PxPPCR_FORMAT_RGBA8888 0x3
+#define DCMIPP_PxPPCR_FORMAT_Y8 0x4
+#define DCMIPP_PxPPCR_FORMAT_YUV444 0x5
+#define DCMIPP_PxPPCR_FORMAT_YUYV 0x6
+#define DCMIPP_P1PPCR_FORMAT_NV61 0x7
+#define DCMIPP_P1PPCR_FORMAT_NV21 0x8
+#define DCMIPP_P1PPCR_FORMAT_YV12 0x9
+#define DCMIPP_PxPPCR_FORMAT_UYVY 0xa
+
+#define DCMIPP_PxPPCR_SWAPRB BIT(4)
+
+#define IS_SINK(pad) (!(pad))
+#define IS_SRC(pad)  ((pad))
+#define PAD_STR(pad) (IS_SRC((pad))) ? "src" : "sink"
+
+#define PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT MEDIA_BUS_FMT_RGB565_2X8_LE
+#define PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT MEDIA_BUS_FMT_RGB888_1X24
+
+struct dcmipp_pixelproc_pix_map {
+	unsigned int code;
+	unsigned int ppcr_fmt;
+	unsigned int swap_uv;
+};
+
+#define PIXMAP_MBUS_PPCR_SWAPUV(mbus, pp_code, swap)	\
+		{						\
+			.code = MEDIA_BUS_FMT_##mbus,		\
+			.ppcr_fmt = pp_code,	\
+			.swap_uv = swap,	\
+		}
+static const struct dcmipp_pixelproc_pix_map dcmipp_pixelproc_sink_pix_map_list[] = {
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB888_1X24, 0, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUV8_1X24, 0, 0),
+};
+
+static const struct dcmipp_pixelproc_pix_map dcmipp_pixelproc_src_pix_map_list[] = {
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB888_1X24, DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER, 1),
+	PIXMAP_MBUS_PPCR_SWAPUV(BGR888_1X24, DCMIPP_PxPPCR_FORMAT_RGB888_OR_YUV444_1BUFFER, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(RGB565_2X8_LE, DCMIPP_PxPPCR_FORMAT_RGB565, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_2X8, DCMIPP_PxPPCR_FORMAT_YUYV, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_2X8, DCMIPP_PxPPCR_FORMAT_YUYV, 1),
+	PIXMAP_MBUS_PPCR_SWAPUV(UYVY8_2X8, DCMIPP_PxPPCR_FORMAT_UYVY, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(VYUY8_2X8, DCMIPP_PxPPCR_FORMAT_UYVY, 1),
+	PIXMAP_MBUS_PPCR_SWAPUV(Y8_1X8, DCMIPP_PxPPCR_FORMAT_Y8, 0),
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_1_5X8, DCMIPP_P1PPCR_FORMAT_NV21, 0), /* FIXME no mbus code for semiplanar (NV12) */
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_1_5X8, DCMIPP_P1PPCR_FORMAT_NV21, 1), /* FIXME no mbus code for semiplanar (NV21) */
+	PIXMAP_MBUS_PPCR_SWAPUV(YUYV8_1X16,  DCMIPP_P1PPCR_FORMAT_NV61, 0), /* FIXME no mbus code for semiplanar (NV16)*/
+	PIXMAP_MBUS_PPCR_SWAPUV(YVYU8_1X16,  DCMIPP_P1PPCR_FORMAT_NV61, 1), /* FIXME no mbus code for semiplanar (NV61)*/
+	PIXMAP_MBUS_PPCR_SWAPUV(UYVY8_1_5X8, DCMIPP_P1PPCR_FORMAT_YV12, 0), /* FIXME no mbus code for planar (I420/YU12)*/
+	PIXMAP_MBUS_PPCR_SWAPUV(VYUY8_1_5X8, DCMIPP_P1PPCR_FORMAT_YV12, 1), /* FIXME no mbus code for planar (YV12)*/
+};
+
+static const struct dcmipp_pixelproc_pix_map *
+dcmipp_pixelproc_pix_map_by_index(unsigned int i, unsigned int pad)
+{
+	const struct dcmipp_pixelproc_pix_map *l;
+	unsigned int size;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_pixelproc_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_src_pix_map_list);
+	} else {
+		l = dcmipp_pixelproc_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_sink_pix_map_list);
+	}
+
+	if (i >= size)
+		return NULL;
+
+	return &l[i];
+}
+
+static const struct dcmipp_pixelproc_pix_map *
+dcmipp_pixelproc_pix_map_by_code(u32 code, unsigned int pad)
+{
+	const struct dcmipp_pixelproc_pix_map *l;
+	unsigned int size;
+	unsigned int i;
+
+	if (IS_SRC(pad)) {
+		l = dcmipp_pixelproc_src_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_src_pix_map_list);
+	} else {
+		l = dcmipp_pixelproc_sink_pix_map_list;
+		size = ARRAY_SIZE(dcmipp_pixelproc_sink_pix_map_list);
+	}
+
+	for (i = 0; i < size; i++) {
+		if (l[i].code == code)
+			return &l[i];
+	}
+
+	return NULL;
+}
+
+struct dcmipp_pixelproc_device {
+	struct dcmipp_ent_device ved;
+	struct v4l2_subdev sd;
+	struct device *dev;
+	struct v4l2_mbus_framefmt sink_fmt;
+	struct v4l2_mbus_framefmt src_fmt;
+	bool streaming;
+	/* Protect this data structure */
+	struct mutex lock;
+
+	void __iomem *regs;
+	struct v4l2_ctrl_handler ctrls;
+
+	u32 pipe_id;
+
+	struct v4l2_fract src_interval;
+	struct v4l2_fract sink_interval;
+	unsigned int frate;
+	u32 src_code;
+	struct v4l2_rect crop;
+	struct v4l2_rect compose;
+};
+
+static const struct v4l2_mbus_framefmt fmt_default = {
+	.width = DCMIPP_FMT_WIDTH_DEFAULT,
+	.height = DCMIPP_FMT_HEIGHT_DEFAULT,
+	.code = PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT,
+	.field = V4L2_FIELD_NONE,
+	.colorspace = V4L2_COLORSPACE_REC709,
+	.ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT,
+	.quantization = V4L2_QUANTIZATION_DEFAULT,
+	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
+};
+
+static const struct v4l2_rect crop_min = {
+	.width = DCMIPP_FRAME_MIN_WIDTH,
+	.height = DCMIPP_FRAME_MIN_HEIGHT,
+	.top = 0,
+	.left = 0,
+};
+
+/*
+ * Downscale is a combination of both decimation block (1/2/4/8)
+ * and downsize block (up to 8x) for a total of maximum downscale of 64
+ */
+#define DCMIPP_MAX_DECIMATION_RATIO	8
+#define DCMIPP_MAX_DOWNSIZE_RATIO	8
+#define DCMIPP_MAX_DOWNSCALE_RATIO	64
+
+/*
+ * Functions handling controls
+ */
+#define V4L2_CID_PIXELPROC_GAMMA_CORRECTION	(V4L2_CID_USER_BASE | 0x1001)
+
+static int dcmipp_pixelproc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_pixelproc_device *pixelproc =
+		container_of(ctrl->handler,
+			     struct dcmipp_pixelproc_device, ctrls);
+	int ret = 0;
+
+	if (pm_runtime_get_if_in_use(pixelproc->dev) == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_PIXELPROC_GAMMA_CORRECTION:
+		reg_write(pixelproc, DCMIPP_PxGMCR(pixelproc->pipe_id),
+			  (ctrl->val ? DCMIPP_PxGMCR_ENABLE : 0));
+		break;
+	}
+
+	pm_runtime_put(pixelproc->dev);
+
+	return ret;
+};
+
+static const struct v4l2_ctrl_ops dcmipp_pixelproc_ctrl_ops = {
+	.s_ctrl = dcmipp_pixelproc_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config dcmipp_pixelproc_ctrls[] = {
+	{
+		.ops		= &dcmipp_pixelproc_ctrl_ops,
+		.id		= V4L2_CID_PIXELPROC_GAMMA_CORRECTION,
+		.type		= V4L2_CTRL_TYPE_BOOLEAN,
+		.name		= "Gamma correction",
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+	}
+};
+
+static struct v4l2_rect
+dcmipp_pixelproc_get_crop_bound(const struct v4l2_mbus_framefmt *fmt)
+{
+	/* Get the crop bounds to clamp the crop rectangle correctly */
+	struct v4l2_rect r = {
+		.left = 0,
+		.top = 0,
+		.width = fmt->width,
+		.height = fmt->height,
+	};
+	return r;
+}
+
+static void dcmipp_pixelproc_adjust_crop(struct v4l2_rect *r,
+					 const struct v4l2_mbus_framefmt *fmt)
+{
+	const struct v4l2_rect src_rect =
+		dcmipp_pixelproc_get_crop_bound(fmt);
+
+	/* Disallow rectangles smaller than the minimal one. */
+	v4l2_rect_set_min_size(r, &crop_min);
+	v4l2_rect_map_inside(r, &src_rect);
+}
+
+static void dcmipp_pixelproc_adjust_fmt(struct v4l2_mbus_framefmt *fmt, u32 pad)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelproc_pix_map_by_code(fmt->code, pad);
+	if (!vpix)
+		fmt->code = IS_SRC(pad) ? PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT :
+					  PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT;
+
+	fmt->width = clamp_t(u32, fmt->width, DCMIPP_FRAME_MIN_WIDTH,
+			     DCMIPP_FRAME_MAX_WIDTH);
+	fmt->height = clamp_t(u32, fmt->height, DCMIPP_FRAME_MIN_HEIGHT,
+			      DCMIPP_FRAME_MAX_HEIGHT);
+
+	if (fmt->field == V4L2_FIELD_ANY || fmt->field == V4L2_FIELD_ALTERNATE)
+		fmt->field = V4L2_FIELD_NONE;
+
+	dcmipp_colorimetry_clamp(fmt);
+}
+
+static int dcmipp_pixelproc_init_cfg(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *state)
+{
+	unsigned int i;
+
+	for (i = 0; i < sd->entity.num_pads; i++) {
+		struct v4l2_mbus_framefmt *mf;
+
+		mf = v4l2_subdev_get_try_format(sd, state, i);
+		*mf = fmt_default;
+		mf->code = IS_SRC(i) ? PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT :
+				       PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_enum_mbus_code(struct v4l2_subdev *sd,
+					   struct v4l2_subdev_state *state,
+					   struct v4l2_subdev_mbus_code_enum *code)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	vpix = dcmipp_pixelproc_pix_map_by_index(code->index, code->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	code->code = vpix->code;
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_enum_frame_size(struct v4l2_subdev *sd,
+					    struct v4l2_subdev_state *state,
+					    struct v4l2_subdev_frame_size_enum *fse)
+{
+	const struct dcmipp_pixelproc_pix_map *vpix;
+
+	if (fse->index)
+		return -EINVAL;
+
+	/* Only accept code in the pix map table */
+	vpix = dcmipp_pixelproc_pix_map_by_code(fse->code, fse->pad);
+	if (!vpix)
+		return -EINVAL;
+
+	fse->min_width = DCMIPP_FRAME_MIN_WIDTH;
+	fse->max_width = DCMIPP_FRAME_MAX_WIDTH;
+	fse->min_height = DCMIPP_FRAME_MIN_HEIGHT;
+	fse->max_height = DCMIPP_FRAME_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_get_fmt(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&pixelproc->lock);
+
+	if (IS_SINK(fmt->pad))
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, fmt->pad) :
+			      pixelproc->sink_fmt;
+	else
+		fmt->format = fmt->which == V4L2_SUBDEV_FORMAT_TRY ?
+			      *v4l2_subdev_get_try_format(sd, state, fmt->pad) :
+			      pixelproc->src_fmt;
+
+	mutex_unlock(&pixelproc->lock);
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_set_fmt(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_state *state,
+				    struct v4l2_subdev_format *fmt)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *pad_fmt;
+	int ret = 0;
+
+	mutex_lock(&pixelproc->lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		if (pixelproc->streaming) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (IS_SINK(fmt->pad))
+			pad_fmt = &pixelproc->sink_fmt;
+		else
+			pad_fmt = &pixelproc->src_fmt;
+
+	} else {
+		pad_fmt = v4l2_subdev_get_try_format(sd, state, fmt->pad);
+	}
+
+	dcmipp_pixelproc_adjust_fmt(&fmt->format, fmt->pad);
+
+	/* When setting sink format, we have to update the src format */
+	if (IS_SINK(fmt->pad)) {
+		struct v4l2_mbus_framefmt *src_pad_fmt;
+
+		if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+			src_pad_fmt = &pixelproc->src_fmt;
+		else
+			src_pad_fmt = v4l2_subdev_get_try_format(sd, state, 1);
+
+		*src_pad_fmt = fmt->format;
+		if (fmt->format.code >= MEDIA_BUS_FMT_Y8_1X8 &&
+		    fmt->format.code < MEDIA_BUS_FMT_SBGGR8_1X8)
+			src_pad_fmt->code = MEDIA_BUS_FMT_YUYV8_2X8;
+		else
+			src_pad_fmt->code = MEDIA_BUS_FMT_RGB565_2X8_LE;
+
+		dev_dbg(pixelproc->dev, "%s: source format update: new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+			pixelproc->sd.name,
+			src_pad_fmt->width, src_pad_fmt->height,
+			src_pad_fmt->code, src_pad_fmt->colorspace,
+			src_pad_fmt->quantization,
+			src_pad_fmt->xfer_func, src_pad_fmt->ycbcr_enc);
+	}
+
+	dev_dbg(pixelproc->dev, "%s: %s format update: old:%dx%d (0x%x, %d, %d, %d, %d) new:%dx%d (0x%x, %d, %d, %d, %d)\n",
+		pixelproc->sd.name,
+		PAD_STR(fmt->pad),
+		/* old */
+		pad_fmt->width, pad_fmt->height, pad_fmt->code,
+		pad_fmt->colorspace, pad_fmt->quantization,
+		pad_fmt->xfer_func, pad_fmt->ycbcr_enc,
+		/* new */
+		fmt->format.width, fmt->format.height, fmt->format.code,
+		fmt->format.colorspace, fmt->format.quantization,
+		fmt->format.xfer_func, fmt->format.ycbcr_enc);
+
+	*pad_fmt = fmt->format;
+
+	/* Update sink pad crop - compose */
+	if (IS_SINK(fmt->pad) && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		/* Update sink pad crop */
+		pixelproc->crop.top = 0;
+		pixelproc->crop.left = 0;
+		pixelproc->crop.width = fmt->format.width;
+		pixelproc->crop.height = fmt->format.height;
+
+		pixelproc->compose.top = 0;
+		pixelproc->compose.left = 0;
+		pixelproc->compose.width = fmt->format.width;
+		pixelproc->compose.height = fmt->format.height;
+	}
+
+out:
+	mutex_unlock(&pixelproc->lock);
+
+	return ret;
+}
+
+static int dcmipp_pixelproc_get_selection(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *state,
+					  struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &pixelproc->sink_fmt;
+		crop = &pixelproc->crop;
+		compose = &pixelproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		s->r = *crop;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		s->r = dcmipp_pixelproc_get_crop_bound(sink_fmt);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		s->r = *compose;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_set_selection(struct v4l2_subdev *sd,
+					  struct v4l2_subdev_state *state,
+					  struct v4l2_subdev_selection *s)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *sink_fmt;
+	struct v4l2_mbus_framefmt *src_fmt;
+	struct v4l2_rect *crop, *compose;
+
+	if (IS_SRC(s->pad))
+		return -EINVAL;
+
+	if (s->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
+		sink_fmt = &pixelproc->sink_fmt;
+		src_fmt = &pixelproc->src_fmt;
+		crop = &pixelproc->crop;
+		compose = &pixelproc->compose;
+	} else {
+		sink_fmt = v4l2_subdev_get_try_format(sd, state, s->pad);
+		src_fmt = v4l2_subdev_get_try_format(sd, state, 1);
+		crop = v4l2_subdev_get_try_crop(sd, state, s->pad);
+		compose = v4l2_subdev_get_try_compose(sd, state, s->pad);
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		dcmipp_pixelproc_adjust_crop(&s->r, sink_fmt);
+
+		*crop = s->r;
+
+		/* Setting the crop also set the compose identically */
+		*compose = *crop;
+
+		dev_dbg(pixelproc->dev, "s_selection: crop %ux%u@(%u,%u)\n",
+			crop->width, crop->height, crop->left, crop->top);
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		if (s->r.width > crop->width)
+			s->r.width = crop->width;
+		else if (s->r.width < (crop->width / DCMIPP_MAX_DOWNSCALE_RATIO))
+			s->r.width = crop->width / DCMIPP_MAX_DOWNSCALE_RATIO;
+
+		if (s->r.height > crop->height)
+			s->r.height = crop->height;
+		else if (s->r.height < (crop->height / DCMIPP_MAX_DOWNSCALE_RATIO))
+			s->r.height = crop->height / DCMIPP_MAX_DOWNSCALE_RATIO;
+		s->r.top = 0;
+		s->r.left = 0;
+
+		*compose = s->r;
+
+		dev_dbg(pixelproc->dev, "s_selection: compose %ux%u@(%u,%u)\n",
+			s->r.width, s->r.height, s->r.left, s->r.top);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Update the source pad size */
+	src_fmt->width = s->r.width;
+	src_fmt->height = s->r.height;
+
+	return 0;
+}
+
+static const unsigned int dcmipp_frates[] = {1, 2, 4, 8};
+
+static int
+dcmipp_pixelproc_enum_frame_interval(struct v4l2_subdev *sd,
+				     struct v4l2_subdev_state *sd_state,
+				     struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	struct v4l2_fract *sink_interval = &pixelproc->sink_interval;
+	unsigned int ratio;
+	int ret = 0;
+
+	if (fie->pad > 1 ||
+	    fie->index >= (IS_SRC(fie->pad) ? ARRAY_SIZE(dcmipp_frates) : 1) ||
+	    fie->width > DCMIPP_FRAME_MAX_WIDTH ||
+	    fie->height > DCMIPP_FRAME_MAX_HEIGHT)
+		return -EINVAL;
+
+	mutex_lock(&pixelproc->lock);
+
+	if (IS_SINK(fie->pad)) {
+		fie->interval = *sink_interval;
+		goto out;
+	}
+
+	ratio = dcmipp_frates[fie->index];
+
+	fie->interval.numerator = sink_interval->numerator * ratio;
+	fie->interval.denominator = sink_interval->denominator;
+
+out:
+	mutex_unlock(&pixelproc->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_pad_ops dcmipp_pixelproc_pad_ops = {
+	.init_cfg		= dcmipp_pixelproc_init_cfg,
+	.enum_mbus_code		= dcmipp_pixelproc_enum_mbus_code,
+	.enum_frame_size	= dcmipp_pixelproc_enum_frame_size,
+	.enum_frame_interval	= dcmipp_pixelproc_enum_frame_interval,
+	.get_fmt		= dcmipp_pixelproc_get_fmt,
+	.set_fmt		= dcmipp_pixelproc_set_fmt,
+	.get_selection		= dcmipp_pixelproc_get_selection,
+	.set_selection		= dcmipp_pixelproc_set_selection,
+};
+
+static int
+dcmipp_pixelproc_colorconv_config(struct dcmipp_pixelproc_device *pixelproc)
+{
+	struct dcmipp_colorconv_config ccconf = { 0 };
+	int i, ret = 0;
+	unsigned int val = 0;
+
+	ret = dcmipp_colorconv_configure(pixelproc->dev, &pixelproc->sink_fmt,
+					 &pixelproc->src_fmt, &ccconf);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < 6; i++)
+		reg_write(pixelproc, DCMIPP_P1YUVRR1 + (4 * i),
+			  ccconf.conv_matrix[i]);
+
+	if (ccconf.clamping)
+		val |= DCMIPP_P1YUVCR_CLAMP;
+	if (ccconf.clamping_as_rgb)
+		val |= DCMIPP_P1YUVCR_TYPE_RGB;
+	if (ccconf.enable)
+		val |= DCMIPP_P1YUVCR_ENABLE;
+
+	reg_write(pixelproc, DCMIPP_P1YUVCR, val);
+
+	return 0;
+}
+
+#define DCMIPP_PIXELPROC_HVRATIO_CONS	8192
+#define DCMIPP_PIXELPROC_HVRATIO_MAX	65535
+#define DCMIPP_PIXELPROC_HVDIV_CONS	1024
+#define DCMIPP_PIXELPROC_HVDIV_MAX	1023
+static void
+dcmipp_pixelproc_set_downscale(struct dcmipp_pixelproc_device *pixelproc)
+{
+	unsigned int hratio, vratio, hdiv, vdiv;
+	unsigned int hdec = 0, vdec = 0;
+	unsigned int h_post_dec = pixelproc->crop.width;
+	unsigned int v_post_dec = pixelproc->crop.height;
+
+	/* Compute decimation factors (HDEC/VDEC) */
+	while (pixelproc->compose.width * DCMIPP_MAX_DOWNSIZE_RATIO < h_post_dec) {
+		hdec++;
+		h_post_dec /= 2;
+	}
+	while (pixelproc->compose.height * DCMIPP_MAX_DOWNSIZE_RATIO < v_post_dec) {
+		vdec++;
+		v_post_dec /= 2;
+	}
+
+	/* Compute downsize factor */
+	hratio = h_post_dec * DCMIPP_PIXELPROC_HVRATIO_CONS /
+		 pixelproc->compose.width;
+	if (hratio > DCMIPP_PIXELPROC_HVRATIO_MAX)
+		hratio = DCMIPP_PIXELPROC_HVRATIO_MAX;
+	vratio = v_post_dec * DCMIPP_PIXELPROC_HVRATIO_CONS /
+		 pixelproc->compose.height;
+	if (vratio > DCMIPP_PIXELPROC_HVRATIO_MAX)
+		vratio = DCMIPP_PIXELPROC_HVRATIO_MAX;
+	hdiv = (DCMIPP_PIXELPROC_HVDIV_CONS * pixelproc->compose.width) /
+		h_post_dec;
+	if (hdiv > DCMIPP_PIXELPROC_HVDIV_MAX)
+		hdiv = DCMIPP_PIXELPROC_HVDIV_MAX;
+	vdiv = (DCMIPP_PIXELPROC_HVDIV_CONS * pixelproc->compose.height) /
+		v_post_dec;
+	if (vdiv > DCMIPP_PIXELPROC_HVDIV_MAX)
+		vdiv = DCMIPP_PIXELPROC_HVDIV_MAX;
+
+	dev_dbg(pixelproc->dev, "%s: decimation config: hdec: 0x%x, vdec: 0x%x\n",
+		pixelproc->sd.name,
+		hdec, vdec);
+	dev_dbg(pixelproc->dev, "%s: downsize config: hratio: 0x%x, vratio: 0x%x, hdiv: 0x%x, vdiv: 0x%x\n",
+		pixelproc->sd.name,
+		hratio, vratio,
+		hdiv, vdiv);
+
+	reg_clear(pixelproc, DCMIPP_PxDCCR(pixelproc->pipe_id),
+		  DCMIPP_PxDCCR_ENABLE);
+	if (hdec || vdec)
+		reg_write(pixelproc, DCMIPP_PxDCCR(pixelproc->pipe_id),
+			  (hdec << DCMIPP_PxDCCR_HDEC_SHIFT) |
+			  (vdec << DCMIPP_PxDCCR_VDEC_SHIFT) |
+			  DCMIPP_PxDCCR_ENABLE);
+
+	reg_clear(pixelproc, DCMIPP_PxDSCR(pixelproc->pipe_id),
+		  DCMIPP_PxDSCR_ENABLE);
+	reg_write(pixelproc, DCMIPP_PxDSRTIOR(pixelproc->pipe_id),
+		  (hratio << DCMIPP_PxDSRTIOR_HRATIO_SHIFT) |
+		  (vratio << DCMIPP_PxDSRTIOR_VRATIO_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxDSSZR(pixelproc->pipe_id),
+		  (pixelproc->compose.width << DCMIPP_PxDSSZR_HSIZE_SHIFT) |
+		  (pixelproc->compose.height << DCMIPP_PxDSSZR_VSIZE_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxDSCR(pixelproc->pipe_id),
+		  (hdiv << DCMIPP_PxDSCR_HDIV_SHIFT) |
+		  (vdiv << DCMIPP_PxDSCR_VDIV_SHIFT) |
+		  DCMIPP_PxDSCR_ENABLE);
+}
+
+static void
+dcmipp_pixelproc_configure_framerate(struct dcmipp_pixelproc_device *pixelproc)
+{
+	/* Frame skipping */
+	reg_clear(pixelproc, DCMIPP_PxFCTCR(pixelproc->pipe_id),
+		  DCMIPP_PxFCTCR_FRATE_MASK);
+	reg_set(pixelproc, DCMIPP_PxFCTCR(pixelproc->pipe_id),
+		pixelproc->frate);
+}
+
+static int
+dcmipp_pixelproc_g_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *fi)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	if (IS_SINK(fi->pad))
+		fi->interval = pixelproc->sink_interval;
+	else
+		fi->interval = pixelproc->src_interval;
+
+	return 0;
+}
+
+static int
+dcmipp_pixelproc_s_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *fi)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&pixelproc->lock);
+
+	if (pixelproc->streaming) {
+		mutex_unlock(&pixelproc->lock);
+		return -EBUSY;
+	}
+
+	if (fi->interval.numerator == 0 || fi->interval.denominator == 0)
+		fi->interval = pixelproc->sink_interval;
+
+	if (IS_SINK(fi->pad)) {
+		/*
+		 * Setting sink frame interval resets frame skipping.
+		 * Sink frame interval is propagated to src.
+		 */
+		pixelproc->frate = 0;
+		pixelproc->sink_interval = fi->interval;
+		pixelproc->src_interval = pixelproc->sink_interval;
+	} else {
+		unsigned int ratio;
+
+		/* Normalize ratio */
+		ratio = (pixelproc->sink_interval.denominator *
+			 fi->interval.numerator) /
+			(pixelproc->sink_interval.numerator *
+			 fi->interval.denominator);
+
+		/* Hardware can skip 1 frame over 2, 4 or 8 */
+		pixelproc->frate = ratio >= 8 ? 3 :
+				   ratio >= 4 ? 2 :
+				   ratio >= 2 ? 1 : 0;
+
+		ratio = dcmipp_frates[pixelproc->frate];
+
+		/* Adjust src frame interval to what hardware can really do */
+		pixelproc->src_interval.numerator =
+			pixelproc->sink_interval.numerator * ratio;
+		pixelproc->src_interval.denominator =
+			pixelproc->sink_interval.denominator;
+	}
+
+	mutex_unlock(&pixelproc->lock);
+
+	return 0;
+}
+
+static int dcmipp_pixelproc_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dcmipp_pixelproc_device *pixelproc = v4l2_get_subdevdata(sd);
+	const struct dcmipp_pixelproc_pix_map *vpix;
+	int ret = 0;
+	unsigned int val;
+
+	if (!enable)
+		return 0;
+
+	mutex_lock(&pixelproc->lock);
+
+	/* Configure framerate */
+	dcmipp_pixelproc_configure_framerate(pixelproc);
+
+	/* Configure cropping */
+	reg_write(pixelproc, DCMIPP_PxCRSTR(pixelproc->pipe_id),
+		  (pixelproc->crop.top << DCMIPP_PxCRSTR_VSTART_SHIFT) |
+		  (pixelproc->crop.left << DCMIPP_PxCRSTR_HSTART_SHIFT));
+	reg_write(pixelproc, DCMIPP_PxCRSZR(pixelproc->pipe_id),
+		  (pixelproc->crop.width << DCMIPP_PxCRSZR_HSIZE_SHIFT) |
+		  (pixelproc->crop.height << DCMIPP_PxCRSZR_VSIZE_SHIFT) |
+		  DCMIPP_PxCRSZR_ENABLE);
+
+	/* Configure downscale */
+	dcmipp_pixelproc_set_downscale(pixelproc);
+
+	/* Configure YUV Conversion (if applicable) */
+	if (pixelproc->pipe_id == 1) {
+		ret = dcmipp_pixelproc_colorconv_config(pixelproc);
+		if (ret)
+			goto out;
+	}
+
+	/* Setup the PixelPacker based on the src pad format */
+	vpix = dcmipp_pixelproc_pix_map_by_code(pixelproc->src_fmt.code, 1);
+	if (!vpix) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	val = vpix->ppcr_fmt;
+	if (vpix->swap_uv)
+		val |= DCMIPP_PxPPCR_SWAPRB;
+
+	reg_write(pixelproc, DCMIPP_PxPPCR(pixelproc->pipe_id), val);
+
+	/* Apply customized values from user when stream starts. */
+	ret = v4l2_ctrl_handler_setup(pixelproc->sd.ctrl_handler);
+
+out:
+	mutex_unlock(&pixelproc->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops dcmipp_pixelproc_core_ops = {
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops dcmipp_pixelproc_video_ops = {
+	.g_frame_interval = dcmipp_pixelproc_g_frame_interval,
+	.s_frame_interval = dcmipp_pixelproc_s_frame_interval,
+	.s_stream = dcmipp_pixelproc_s_stream,
+};
+
+static const struct v4l2_subdev_ops dcmipp_pixelproc_ops = {
+	.core = &dcmipp_pixelproc_core_ops,
+	.pad = &dcmipp_pixelproc_pad_ops,
+	.video = &dcmipp_pixelproc_video_ops,
+};
+
+void dcmipp_pixelproc_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_pixelproc_device *pixelproc =
+			container_of(ved, struct dcmipp_pixelproc_device, ved);
+
+	dcmipp_ent_sd_unregister(ved, &pixelproc->sd);
+	mutex_destroy(&pixelproc->lock);
+	kfree(pixelproc);
+}
+
+static int dcmipp_name_to_pipe_id(const char *name)
+{
+	if (strstr(name, "main"))
+		return 1;
+	else if (strstr(name, "aux"))
+		return 2;
+	else
+		return -EINVAL;
+}
+
+struct dcmipp_ent_device *
+dcmipp_pixelproc_ent_init(struct device *dev, const char *entity_name,
+			  struct v4l2_device *v4l2_dev, void __iomem *regs)
+{
+	struct dcmipp_pixelproc_device *pixelproc;
+	struct v4l2_fract interval = {
+		.numerator = 1,
+		.denominator = 30,
+	};
+	int ret, i;
+
+	/* Allocate the pixelproc struct */
+	pixelproc = kzalloc(sizeof(*pixelproc), GFP_KERNEL);
+	if (!pixelproc)
+		return ERR_PTR(-ENOMEM);
+
+	pixelproc->regs = regs;
+	pixelproc->dev = dev;
+
+	/* Initialize the lock */
+	mutex_init(&pixelproc->lock);
+
+	/* Pipe identifier */
+	pixelproc->pipe_id = dcmipp_name_to_pipe_id(entity_name);
+	if (pixelproc->pipe_id != 1 && pixelproc->pipe_id != 2) {
+		dev_err(dev, "failed to retrieve pipe_id\n");
+		mutex_destroy(&pixelproc->lock);
+		kfree(pixelproc);
+		return ERR_PTR(-EIO);
+	}
+
+	/* Initialize the frame format */
+	pixelproc->sink_fmt = fmt_default;
+	pixelproc->sink_fmt.code = PIXELPROC_MEDIA_BUS_SINK_FMT_DEFAULT;
+	pixelproc->src_fmt = fmt_default;
+	pixelproc->src_fmt.code = PIXELPROC_MEDIA_BUS_SRC_FMT_DEFAULT;
+	pixelproc->crop.top = 0;
+	pixelproc->crop.left = 0;
+	pixelproc->crop.width = DCMIPP_FMT_WIDTH_DEFAULT;
+	pixelproc->crop.height = DCMIPP_FMT_HEIGHT_DEFAULT;
+	pixelproc->compose.top = 0;
+	pixelproc->compose.left = 0;
+	pixelproc->compose.width = DCMIPP_FMT_WIDTH_DEFAULT;
+	pixelproc->compose.height = DCMIPP_FMT_HEIGHT_DEFAULT;
+	pixelproc->src_interval = interval;
+	pixelproc->sink_interval = interval;
+
+	/* Initialize controls */
+	v4l2_ctrl_handler_init(&pixelproc->ctrls,
+			       ARRAY_SIZE(dcmipp_pixelproc_ctrls));
+
+	for (i = 0; i < ARRAY_SIZE(dcmipp_pixelproc_ctrls); i++)
+		v4l2_ctrl_new_custom(&pixelproc->ctrls,
+				     &dcmipp_pixelproc_ctrls[i], NULL);
+
+	pixelproc->sd.ctrl_handler = &pixelproc->ctrls;
+	if (pixelproc->ctrls.error) {
+		ret = pixelproc->ctrls.error;
+		dev_err(pixelproc->dev, "control initialization error %d\n", ret);
+		mutex_destroy(&pixelproc->lock);
+		kfree(pixelproc);
+		return ERR_PTR(ret);
+	}
+
+	/* Initialize ved and sd */
+	ret = dcmipp_ent_sd_register(&pixelproc->ved, &pixelproc->sd,
+				     v4l2_dev,
+				     entity_name,
+				     MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER, 2,
+				     (const unsigned long[2]) {
+				     MEDIA_PAD_FL_SINK,
+				     MEDIA_PAD_FL_SOURCE,
+				     },
+				     NULL, &dcmipp_pixelproc_ops,
+				     NULL, NULL);
+	if (ret) {
+		mutex_destroy(&pixelproc->lock);
+		kfree(pixelproc);
+		return ERR_PTR(ret);
+	}
+
+	return &pixelproc->ved;
+}
diff --git a/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-statcap.c b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-statcap.c
new file mode 100644
index 000000000..a420e429f
--- /dev/null
+++ b/drivers/media/platform/st/stm32/stm32-dcmipp/dcmipp-statcap.c
@@ -0,0 +1,1006 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for STM32 Digital Camera Memory Interface Pixel Processor
+ *
+ * Copyright (C) STMicroelectronics SA 2022
+ * Authors: Alain Volmat <alain.volmat@foss.st.com>
+ *          Fabien Dessenne <fabien.dessenne@foss.st.com>
+ *          Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-vmalloc.h>
+#include <uapi/linux/stm32-dcmipp-config.h>
+
+#include "dcmipp-common.h"
+
+#define DCMIPP_STATCAP_DRV_NAME "dcmipp-statcap"
+
+#define DCMIPP_CMSR2_P1VSYNCF BIT(18)
+
+#define DCMIPP_P1BPRSR (0x828)
+#define DCMIPP_P1BPRSR_BADCNT_MASK GENMASK(11, 0)
+
+#define DCMIPP_P1STXCR(a)	(0x850 + ((a) * 0x4))
+#define DCMIPP_P1STXCR_ENABLE		BIT(0)
+#define DCMIPP_P1STXCR_BINS_SHIFT	2
+#define DCMIPP_P1STXCR_SRC_COMP_SHIFT	4
+#define DCMIPP_P1STXCR_SRC_LOC_PRE	0
+#define DCMIPP_P1STXCR_SRC_LOC_POST	1
+#define DCMIPP_P1STXCR_SRC_LOC_SHIFT	6
+#define DCMIPP_P1STXCR_MODE_AVERAGE	0
+#define DCMIPP_P1STXCR_MODE_BINS	BIT(7)
+
+#define DCMIPP_P1STSTR	(0x85C)
+#define DCMIPP_P1STSTR_HSTART_SHIFT	0
+#define DCMIPP_P1STSTR_HSTART_MASK	GENMASK(11, 0)
+#define DCMIPP_P1STSTR_VSTART_SHIFT	16
+#define DCMIPP_P1STSTR_VSTART_MASK	GENMASK(27, 16)
+
+#define DCMIPP_P1STSZR	(0x860)
+#define DCMIPP_P1STSZR_HSIZE_SHIFT	0
+#define DCMIPP_P1STSZR_HSIZE_MASK	GENMASK(11, 0)
+#define DCMIPP_P1STSZR_VSIZE_SHIFT	16
+#define DCMIPP_P1STSZR_VSIZE_MASK	GENMASK(27, 16)
+#define DCMIPP_P1STSZR_ENABLE		BIT(31)
+
+#define DCMIPP_P1STXSR(a) (0x864 + ((a) * 0x4))
+
+#define DCMIPP_NB_STAT_REGION	1
+
+struct dcmipp_buf {
+	struct vb2_v4l2_buffer	vb;
+	bool			prepared;
+	dma_addr_t		paddr;
+	size_t			size;
+	struct list_head	list;
+};
+
+/*
+ * This structure describe the state right after the VSYNC comes
+ */
+enum stat_capture_state {
+	COLD_START,		/* Shadow: AVERAGE (RGB), Physical: stopped */
+	/* Full capture profile */
+	PHY_AV_RGB_SHA_BIN_0,	/* Shadow: BIN_0, Physical: AVERAGE (RGB) */
+	PHY_BIN_0_SHA_BIN_1,	/* Shadow: BIN_1, Physical: BIN_0 */
+	PHY_BIN_1_SHA_BIN_2,	/* Shadow: BIN_2, Physical: BIN_1 */
+	PHY_BIN_2_SHA_BIN_3,	/* Shadow: BIN_3, Physical: BIN_2 */
+	PHY_BIN_3_SHA_AV_RGB,	/* Shadow: AVERAGE (RGB), Physical: BIN_3 */
+	/* Average pre-post profile */
+	PHY_AV_RGB_SHA_AV_RGB,	/* Shadow: AVERAGE (RGB), Physical: AVERAGE (RGB) */
+};
+
+enum component {
+	COMP_RED = 0,
+	COMP_GREEN,
+	COMP_BLUE,
+	COMP_MAX
+};
+
+struct dcmipp_statcap_device {
+	struct dcmipp_ent_device ved;
+	struct video_device vdev;
+	struct device *dev;
+	struct v4l2_ctrl_handler ctrls;
+	/* Protect ctrls */
+	struct vb2_queue queue;
+	struct list_head buffers;
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	/* Protect this data structure */
+	struct mutex lock;
+	u32 sequence;
+	struct media_pipeline pipe;
+	u32 frame_format;
+	struct v4l2_rect stat_region;
+	enum v4l2_isp_stat_avg_filter avg_filter;
+	enum v4l2_isp_stat_bin_comp bin_comp;
+	enum v4l2_isp_stat_profile stat_profile;
+	struct v4l2_subdev *s_subdev;
+
+	/*
+	 * indicate the current state of the capture stat machine,
+	 * must be updated at the end of the VSYNC processing
+	 */
+	enum stat_capture_state capture_state;
+	/*
+	 * indicate the previous state of the capture stat machine,
+	 * must be updated at the end of the VSYNC processing
+	 * this is useful only for startup cases since, in case of startup
+	 * we cannot capture BIN_3 at stage PHY_AV_RGB_SHA_BIN_0 since we
+	 * have just started.
+	 */
+	enum stat_capture_state prev_capture_state;
+
+	void __iomem *regs;
+
+	struct stm32_dcmipp_stat_buf local_buf;
+};
+
+static int dcmipp_statcap_querycap(struct file *file, void *priv,
+				   struct v4l2_capability *cap)
+{
+	strscpy(cap->driver, DCMIPP_PDEV_NAME, sizeof(cap->driver));
+	strscpy(cap->card, KBUILD_MODNAME, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:%s", DCMIPP_PDEV_NAME);
+
+	return 0;
+}
+
+static int dcmipp_statcap_g_fmt_meta_cap(struct file *file, void *priv,
+					 struct v4l2_format *f)
+{
+	struct v4l2_meta_format *meta = &f->fmt.meta;
+
+	meta->dataformat = V4L2_META_FMT_ST_DCMIPP_ISP_STAT;
+	meta->buffersize = sizeof(struct stm32_dcmipp_stat_buf);
+
+	return 0;
+}
+
+static int dcmipp_statcap_enum_fmt_meta_cap(struct file *file, void *priv,
+					    struct v4l2_fmtdesc *f)
+{
+	if (f->index > 0)
+		return -EINVAL;
+
+	f->type = V4L2_BUF_TYPE_META_CAPTURE;
+	f->pixelformat = V4L2_META_FMT_ST_DCMIPP_ISP_STAT;
+
+	return 0;
+}
+
+static int dcmipp_statcap_open(struct file *file)
+{
+	struct dcmipp_statcap_device *vcap = video_drvdata(file);
+	int ret;
+
+	ret = mutex_lock_interruptible(&vcap->lock);
+	if (ret)
+		return ret;
+
+	ret = v4l2_fh_open(file);
+	if (ret)
+		goto err_unlock;
+
+	ret = v4l2_pipeline_pm_get(&vcap->vdev.entity);
+	if (ret)
+		goto err_close;
+
+	mutex_unlock(&vcap->lock);
+
+	return 0;
+
+err_close:
+	v4l2_fh_release(file);
+err_unlock:
+	mutex_unlock(&vcap->lock);
+
+	return ret;
+}
+
+static int dcmipp_statcap_close(struct file *file)
+{
+	struct dcmipp_statcap_device *vcap = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	v4l2_pipeline_pm_put(&vcap->vdev.entity);
+
+	return 0;
+}
+
+static const struct v4l2_file_operations dcmipp_statcap_fops = {
+	.owner		= THIS_MODULE,
+	.open		= dcmipp_statcap_open,
+	.release	= dcmipp_statcap_close,
+	.read           = vb2_fop_read,
+	.poll		= vb2_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap           = vb2_fop_mmap,
+};
+
+static const struct v4l2_ioctl_ops dcmipp_statcap_ioctl_ops = {
+	.vidioc_querycap = dcmipp_statcap_querycap,
+
+	.vidioc_enum_fmt_meta_cap = dcmipp_statcap_enum_fmt_meta_cap,
+	.vidioc_g_fmt_meta_cap = dcmipp_statcap_g_fmt_meta_cap,
+	.vidioc_s_fmt_meta_cap = dcmipp_statcap_g_fmt_meta_cap,
+	.vidioc_try_fmt_meta_cap = dcmipp_statcap_g_fmt_meta_cap,
+
+	.vidioc_reqbufs = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf = vb2_ioctl_prepare_buf,
+	.vidioc_querybuf = vb2_ioctl_querybuf,
+	.vidioc_qbuf = vb2_ioctl_qbuf,
+	.vidioc_dqbuf = vb2_ioctl_dqbuf,
+	.vidioc_expbuf = vb2_ioctl_expbuf,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
+};
+
+static int dcmipp_pipeline_s_stream(struct dcmipp_statcap_device *vcap,
+				    int state)
+{
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	/* Start/stop all entities within pipeline */
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_pad_remote_pad_first(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		if (state) {
+			/* Increment stream_count to indicate that entity is streamon */
+			entity->stream_count++;
+
+			/*
+			 * Do not streamon entities already started and streamon
+			 * by another capture pipeline
+			 */
+			if (entity->stream_count > 1)
+				continue;
+		} else {
+			/* Decrement stream_count to indicate that entity is streamoff. */
+			entity->stream_count--;
+
+			/*
+			 * Only streamoff if entity is not owned anymore
+			 * by other pipelines
+			 */
+			if (entity->stream_count > 0)
+				continue;
+		}
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, state);
+		if (ret < 0 && ret != -ENOIOCTLCMD) {
+			dev_err(vcap->dev, "%s: \"%s\" failed to %s streaming (%d)\n",
+				__func__, subdev->name,
+				state ? "start" : "stop", ret);
+
+			goto out;
+		}
+
+		dev_dbg(vcap->dev, "\"%s\" is %s\n",
+			subdev->name, state ? "started" : "stopped");
+	}
+
+out:
+	mutex_unlock(&mdev->graph_mutex);
+
+	return ret;
+}
+
+static int dcmipp_statcap_start_streaming(struct vb2_queue *vq,
+					  unsigned int count)
+{
+	struct dcmipp_statcap_device *vcap = vb2_get_drv_priv(vq);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct media_device *mdev = entity->graph_obj.mdev;
+	struct media_pipeline *pipe;
+	struct dcmipp_buf *buf, *node;
+	struct v4l2_subdev_format fmt;
+	struct media_pad *pad;
+	int ret;
+
+	vcap->sequence = 0;
+
+	ret = pm_runtime_get_sync(vcap->dev);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/*
+	 * Start the media pipeline
+	 *
+	 * Pipeline is shared between all elements of the pipeline
+	 * including video capture nodes.
+	 * Instead of creating a common media_pipeline struct
+	 * global variable, use the one of the first capture
+	 * node. All the elements of the pipeline -including
+	 * other capture nodes- will be then assigned to this
+	 * pipeline (entity->pipe) in __media_pipeline_start().
+	 */
+	mutex_lock(&mdev->graph_mutex);
+	pipe = entity->pads[0].pipe ? : &vcap->pipe;
+	ret = __video_device_pipeline_start(&vcap->vdev, pipe);
+	mutex_unlock(&mdev->graph_mutex);
+	if (ret) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, media pipeline start error (%d)\n",
+			__func__, ret);
+		goto err_pm_put;
+	}
+
+	/* Start all the elements within pipeline */
+	ret = dcmipp_pipeline_s_stream(vcap, 1);
+	if (ret)
+		goto err_media_pipeline_stop;
+
+	/* Get pointer to the source subdev (if case of not yet set */
+	if (!vcap->s_subdev) {
+		pad = media_pad_remote_pad_first(&entity->pads[0]);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity)) {
+			dev_err(vcap->dev, "%s: Failed to start streaming, can't find remote entity\n",
+				__func__);
+			ret = -EIO;
+			goto err_media_pipeline_stop;
+		}
+		vcap->s_subdev = media_entity_to_v4l2_subdev(pad->entity);
+	}
+
+	/* Get frame format info from ISP sink pad */
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	fmt.pad = 0;
+	ret = v4l2_subdev_call(vcap->s_subdev, pad, get_fmt, NULL, &fmt);
+	if (ret < 0) {
+		dev_err(vcap->dev, "%s: Failed to start streaming, can't get format (%d)\n",
+			__func__, ret);
+		goto err_media_pipeline_stop;
+	}
+	vcap->frame_format = fmt.format.code;
+
+	/* Apply controls if not yet done */
+	ret = v4l2_ctrl_handler_setup(&vcap->ctrls);
+	if (ret < 0) {
+		dev_err(vcap->dev, "Failed to set up control handlers (%d)\n", ret);
+		goto err_media_pipeline_stop;
+	}
+
+	return 0;
+
+err_media_pipeline_stop:
+	media_pipeline_stop(entity->pads);
+err_pm_put:
+	pm_runtime_put(vcap->dev);
+	spin_lock_irq(&vcap->irqlock);
+	/*
+	 * Return all buffers to vb2 in QUEUED state.
+	 * This will give ownership back to userspace
+	 */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	spin_unlock_irq(&vcap->irqlock);
+
+	return ret;
+}
+
+/*
+ * Stop the stream engine. Any remaining buffers in the stream queue are
+ * dequeued and passed on to the vb2 framework marked as STATE_ERROR.
+ */
+static void dcmipp_statcap_stop_streaming(struct vb2_queue *vq)
+{
+	struct dcmipp_statcap_device *vcap = vb2_get_drv_priv(vq);
+	struct dcmipp_buf *buf, *node;
+
+	/* Reset the capture state machine */
+	vcap->capture_state = COLD_START;
+
+	dcmipp_pipeline_s_stream(vcap, 0);
+
+	/* Stop the media pipeline */
+	media_pipeline_stop(vcap->vdev.entity.pads);
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Return all queued buffers to vb2 in ERROR state */
+	list_for_each_entry_safe(buf, node, &vcap->buffers, list) {
+		list_del_init(&buf->list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+	INIT_LIST_HEAD(&vcap->buffers);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	pm_runtime_put(vcap->dev);
+}
+
+static int dcmipp_statcap_buf_prepare(struct vb2_buffer *vb)
+{
+	struct dcmipp_statcap_device *vcap =  vb2_get_drv_priv(vb->vb2_queue);
+	unsigned long size = sizeof(struct stm32_dcmipp_stat_buf);
+
+	if (vb2_plane_size(vb, 0) < size) {
+		dev_err(vcap->dev, "%s data will not fit into plane (%lu < %lu)\n",
+			__func__, vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+
+	vb2_set_plane_payload(vb, 0, size);
+
+	return 0;
+}
+
+static void dcmipp_statcap_buf_queue(struct vb2_buffer *vb2_buf)
+{
+	struct dcmipp_statcap_device *vcap = vb2_get_drv_priv(vb2_buf->vb2_queue);
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb2_buf);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	spin_lock_irq(&vcap->irqlock);
+	list_add_tail(&buf->list, &vcap->buffers);
+	spin_unlock_irq(&vcap->irqlock);
+}
+
+static int dcmipp_statcap_queue_setup(struct vb2_queue *vq,
+				      unsigned int *nbuffers,
+				      unsigned int *nplanes,
+				      unsigned int sizes[],
+				      struct device *alloc_devs[])
+{
+	unsigned int size = sizeof(struct stm32_dcmipp_stat_buf);
+
+	if (*nplanes) {
+		if (sizes[0] < size)
+			return -EINVAL;
+	} else {
+		sizes[0] = size;
+	}
+
+	if (vq->num_buffers + *nbuffers < 2)
+		*nbuffers = 2 - vq->num_buffers;
+
+	*nplanes = 1;
+	return 0;
+}
+
+static int dcmipp_statcap_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct dcmipp_buf *buf = container_of(vbuf, struct dcmipp_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+
+	return 0;
+}
+
+static const struct vb2_ops dcmipp_statcap_qops = {
+	.start_streaming	= dcmipp_statcap_start_streaming,
+	.stop_streaming		= dcmipp_statcap_stop_streaming,
+	.buf_init		= dcmipp_statcap_buf_init,
+	.buf_prepare		= dcmipp_statcap_buf_prepare,
+	.buf_queue		= dcmipp_statcap_buf_queue,
+
+	.queue_setup		= dcmipp_statcap_queue_setup,
+	/*
+	 * Since q->lock is set we can use the standard
+	 * vb2_ops_wait_prepare/finish helper functions.
+	 */
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+};
+
+static const struct media_entity_operations dcmipp_statcap_mops = {
+	.link_validate		= dcmipp_link_validate,
+};
+
+static int dcmipp_statcap_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct dcmipp_statcap_device *vcap =
+			container_of(ctrl->handler, struct dcmipp_statcap_device, ctrls);
+	struct media_entity *entity = &vcap->vdev.entity;
+	struct v4l2_ctrl_isp_stat_region *region;
+	struct v4l2_subdev_selection sel;
+	struct media_pad *pad;
+	int ret = 0;
+
+	dev_dbg(vcap->dev, ">> %s: ctrl->id = 0x%x\n", __func__, ctrl->id);
+
+	if (pm_runtime_get_if_in_use(vcap->dev) == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ISP_STAT_REGION:
+		/* Get pointer to the source subdev (if case of not yet set */
+		if (!vcap->s_subdev) {
+			pad = media_pad_remote_pad_first(&entity->pads[0]);
+			if (!pad || !is_media_entity_v4l2_subdev(pad->entity)) {
+				ret = -EIO;
+				goto out;
+			}
+			vcap->s_subdev = media_entity_to_v4l2_subdev(pad->entity);
+		}
+
+		region = (struct v4l2_ctrl_isp_stat_region *)ctrl->p_new.p;
+		if (region->nb_regions > DCMIPP_NB_STAT_REGION) {
+			dev_dbg(vcap->dev, "Unsupported number of stat region: %d vs max=%d\n",
+				region->nb_regions, DCMIPP_NB_STAT_REGION);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* Get frame information */
+		sel.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		sel.pad = 0;
+		sel.target = V4L2_SEL_TGT_COMPOSE;
+		ret = v4l2_subdev_call(vcap->s_subdev, pad, get_selection, NULL, &sel);
+		if (ret < 0) {
+			dev_err(vcap->dev, "Failed to get frame size\n");
+			goto out;
+		}
+
+		if (!region->nb_regions ||
+		    (!region->width[0] && !region->height[0] &&
+		     !region->left[0] && !region->top[0])) {
+			spin_lock_irq(&vcap->irqlock);
+			vcap->stat_region.width = sel.r.width;
+			vcap->stat_region.height = sel.r.width;
+			reg_clear(vcap, DCMIPP_P1STSZR, DCMIPP_P1STSZR_ENABLE);
+			spin_unlock_irq(&vcap->irqlock);
+			break;
+		} else if (!region->width[0] || !region->height[0] ||
+			   (region->left[0] + region->width[0]) > sel.r.width ||
+			   (region->top[0] + region->height[0]) > sel.r.height) {
+			dev_err(vcap->dev, "Invalid or stat region not fitting into frame\n");
+			ret = -EINVAL;
+			goto out;
+		}
+
+		spin_lock_irq(&vcap->irqlock);
+		vcap->stat_region.width = region->width[0];
+		vcap->stat_region.height = region->height[0];
+		vcap->stat_region.left = region->left[0];
+		vcap->stat_region.top = region->top[0];
+
+		/* Update window size and start */
+		reg_clear(vcap, DCMIPP_P1STSTR,
+			  DCMIPP_P1STSTR_HSTART_MASK | DCMIPP_P1STSTR_VSTART_MASK);
+		reg_set(vcap, DCMIPP_P1STSTR,
+			(region->left[0] << DCMIPP_P1STSTR_HSTART_SHIFT) |
+			(region->top[0] << DCMIPP_P1STSTR_VSTART_SHIFT));
+
+		reg_clear(vcap, DCMIPP_P1STSZR,
+			  DCMIPP_P1STSZR_HSIZE_MASK | DCMIPP_P1STSZR_VSIZE_MASK);
+		reg_set(vcap, DCMIPP_P1STSZR,
+			(region->width[0] << DCMIPP_P1STSZR_HSIZE_SHIFT) |
+			(region->height[0] << DCMIPP_P1STSZR_VSIZE_SHIFT) |
+			DCMIPP_P1STSZR_ENABLE);
+		spin_unlock_irq(&vcap->irqlock);
+		break;
+	case V4L2_CID_ISP_STAT_AVG_FILTER:
+		vcap->avg_filter = ctrl->val;
+		break;
+	case V4L2_CID_ISP_STAT_BIN_COMP:
+		vcap->bin_comp = ctrl->val;
+		break;
+	case V4L2_CID_ISP_STAT_PROFILE:
+		vcap->stat_profile = ctrl->val;
+		break;
+	}
+
+out:
+	pm_runtime_put(vcap->dev);
+
+	return ret;
+};
+
+static const struct v4l2_ctrl_ops dcmipp_statcap_ctrl_ops = {
+	.s_ctrl = dcmipp_statcap_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config dcmipp_statcap_ctrls[] = {
+	{
+		.ops	= &dcmipp_statcap_ctrl_ops,
+		.id	= V4L2_CID_ISP_STAT_REGION,
+		.type	= V4L2_CTRL_TYPE_ISP_STAT_REGION,
+		.name	= "ISP stat region control",
+	}, {
+		.ops	= &dcmipp_statcap_ctrl_ops,
+		.id	= V4L2_CID_ISP_STAT_AVG_FILTER,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "ISP stat average filter control",
+		.min	= 0,
+		.max	= V4L2_STAT_AVG_FILTER_EXCL64,
+		.step	= 1,
+		.def	= 0,
+		.flags	= 0,
+	}, {
+		.ops	= &dcmipp_statcap_ctrl_ops,
+		.id	= V4L2_CID_ISP_STAT_BIN_COMP,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "ISP stat bin component control",
+		.min	= 0,
+		.max	= V4L2_STAT_BIN_COMP_L,
+		.step	= 1,
+		.def	= 0,
+		.flags	= 0,
+	}, {
+		.ops	= &dcmipp_statcap_ctrl_ops,
+		.id	= V4L2_CID_ISP_STAT_PROFILE,
+		.type	= V4L2_CTRL_TYPE_INTEGER,
+		.name	= "ISP stat profile control",
+		.min	= 0,
+		.max	= V4L2_STAT_PROFILE_AVERAGE_POST,
+		.step	= 1,
+		.def	= 0,
+		.flags	= 0,
+	}
+};
+
+static void dcmipp_statcap_release(struct video_device *vdev)
+{
+	struct dcmipp_statcap_device *vcap =
+		container_of(vdev, struct dcmipp_statcap_device, vdev);
+
+	dcmipp_pads_cleanup(vcap->ved.pads);
+	kfree(vcap);
+}
+
+void dcmipp_statcap_ent_release(struct dcmipp_ent_device *ved)
+{
+	struct dcmipp_statcap_device *vcap =
+		container_of(ved, struct dcmipp_statcap_device, ved);
+
+	mutex_destroy(&vcap->lock);
+	media_entity_cleanup(ved->ent);
+	vb2_video_unregister_device(&vcap->vdev);
+}
+
+static void dcmipp_statcap_buffer_done(struct dcmipp_statcap_device *vcap)
+{
+	struct stm32_dcmipp_stat_buf *stat_buf;
+	struct dcmipp_buf *cur_buf = NULL;
+
+	/* Get an available buffer */
+	if (!list_empty(&vcap->buffers)) {
+		cur_buf = list_first_entry(&vcap->buffers, struct dcmipp_buf, list);
+		list_del(&cur_buf->list);
+	}
+	if (!cur_buf)
+		return;
+
+	stat_buf = (struct stm32_dcmipp_stat_buf *)vb2_plane_vaddr(&cur_buf->vb.vb2_buf, 0);
+	*stat_buf = vcap->local_buf;
+
+	/* Send buffer */
+	vb2_set_plane_payload(&cur_buf->vb.vb2_buf, 0,
+			      sizeof(struct stm32_dcmipp_stat_buf));
+	cur_buf->vb.sequence = vcap->sequence++;
+	cur_buf->vb.vb2_buf.timestamp = ktime_get_ns();
+	vb2_buffer_done(&cur_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+}
+
+static u32 dcmipp_statcap_get_src(u32 location,
+				  enum v4l2_isp_stat_bin_comp comp)
+{
+	return (location << DCMIPP_P1STXCR_SRC_LOC_SHIFT) | (comp << DCMIPP_P1STXCR_SRC_COMP_SHIFT);
+}
+
+static void dcmipp_statcap_read_avg_stats(struct dcmipp_statcap_device *vcap,
+					  u32 location)
+{
+	struct stm32_dcmipp_stat_avr_bins *avr_bins =
+		location == DCMIPP_P1STXCR_SRC_LOC_PRE ? &vcap->local_buf.pre :
+							 &vcap->local_buf.post;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vcap->local_buf.pre.average_RGB); i++) {
+		avr_bins->average_RGB[i] = reg_read(vcap, DCMIPP_P1STXSR(i));
+		/* Normalize values */
+		avr_bins->average_RGB[i] <<= 8;
+
+		/* Depending on the position & component, need to adjust in case of Bayer */
+		if (location == DCMIPP_P1STXCR_SRC_LOC_PRE &&
+		    vcap->frame_format >= MEDIA_BUS_FMT_SBGGR8_1X8 &&
+		    vcap->frame_format <= MEDIA_BUS_FMT_SRGGB16_1X16) {
+			/* raw bayer: RGB component not present for all pixels */
+			if (i == COMP_RED || i == COMP_BLUE)
+				avr_bins->average_RGB[i] *= 4;
+			else if (i == COMP_GREEN)
+				avr_bins->average_RGB[i] *= 2;
+		}
+
+		/* Divide by number of pixels */
+		avr_bins->average_RGB[i] /= (vcap->stat_region.width * vcap->stat_region.height);
+	}
+}
+
+static irqreturn_t dcmipp_statcap_irq_thread(int irq, void *arg)
+{
+	struct dcmipp_statcap_device *vcap =
+			container_of(arg, struct dcmipp_statcap_device, ved);
+	struct dcmipp_ent_device *ved = arg;
+	static u32 location = DCMIPP_P1STXCR_SRC_LOC_PRE;
+	struct stm32_dcmipp_stat_avr_bins *avr_bins =
+		location == DCMIPP_P1STXCR_SRC_LOC_PRE ? &vcap->local_buf.pre :
+							 &vcap->local_buf.post;
+	static bool stat_ready;
+	int i;
+
+	/* We only to do things if we are streaming */
+	if (!vb2_is_streaming(&vcap->queue))
+		return IRQ_HANDLED;
+
+	/* We are only interested in VSYNC interrupts */
+	if (!(ved->cmsr2 & DCMIPP_CMSR2_P1VSYNCF))
+		return IRQ_HANDLED;
+
+	spin_lock_irq(&vcap->irqlock);
+
+	/* Read the bad pixel count stat and store it locally */
+	vcap->local_buf.bad_pixel_count = reg_read(vcap, DCMIPP_P1BPRSR) &
+						DCMIPP_P1BPRSR_BADCNT_MASK;
+
+	/*
+	 * This is the core function for statistic extraction, within the
+	 * irq thread, on EACH VSYNC we update the shadow registers to
+	 * read accumulators values, (except on first few frames), store
+	 * them into the internal structure, and update the shadow registers
+	 * to be able to get new values 2 VSYNCs after (the values read at
+	 * the next VSYNC being already based on the configuration that has
+	 * just been written on the previous VSYNC
+	 */
+	switch (vcap->capture_state) {
+	case COLD_START:
+		stat_ready = false;
+		/*
+		 * All stats profile starts from the PRE statistics, except the
+		 * AVERAGE POST
+		 */
+		if (vcap->stat_profile == V4L2_STAT_PROFILE_AVERAGE_POST)
+			location = DCMIPP_P1STXCR_SRC_LOC_POST;
+		else
+			location = DCMIPP_P1STXCR_SRC_LOC_PRE;
+		/*
+		 * We've just started, set control registers to capture
+		 * AVERAGES (RGB) and leave
+		 */
+		for (i = 0; i < 3; i++)
+			reg_write(vcap, DCMIPP_P1STXCR(i),
+				  DCMIPP_P1STXCR_MODE_AVERAGE |
+				  dcmipp_statcap_get_src(location, i) |
+				  vcap->avg_filter << DCMIPP_P1STXCR_BINS_SHIFT |
+				  DCMIPP_P1STXCR_ENABLE);
+		break;
+
+	case PHY_AV_RGB_SHA_BIN_0:
+		/* Set control registers to capture the 1st set of BINS */
+		for (i = 0; i < 3; i++)
+			reg_write(vcap, DCMIPP_P1STXCR(i),
+				  DCMIPP_P1STXCR_MODE_BINS |
+				  dcmipp_statcap_get_src(location, vcap->bin_comp) |
+				  0 << DCMIPP_P1STXCR_BINS_SHIFT |
+				  DCMIPP_P1STXCR_ENABLE);
+
+		if (vcap->prev_capture_state == PHY_BIN_3_SHA_AV_RGB) {
+			/* Accumulators contains the 4th set of BINS */
+			for (i = 0; i < 3; i++)
+				avr_bins->bins[i + 9] = reg_read(vcap, DCMIPP_P1STXSR(i));
+		}
+		break;
+
+	case PHY_BIN_0_SHA_BIN_1:
+		/* Set control registers to capture the 2nd set of BINS */
+		for (i = 0; i < 3; i++)
+			reg_write(vcap, DCMIPP_P1STXCR(i),
+				  DCMIPP_P1STXCR_MODE_BINS |
+				  dcmipp_statcap_get_src(location, vcap->bin_comp) |
+				  1 << DCMIPP_P1STXCR_BINS_SHIFT |
+				  DCMIPP_P1STXCR_ENABLE);
+
+		/* Accumulators contains the AVERAGES (RGB) */
+		dcmipp_statcap_read_avg_stats(vcap, location);
+		break;
+
+	case PHY_BIN_1_SHA_BIN_2:
+		/* Set control registers to capture the 3rd set of BINS */
+		for (i = 0; i < 3; i++)
+			reg_write(vcap, DCMIPP_P1STXCR(i),
+				  DCMIPP_P1STXCR_MODE_BINS |
+				  dcmipp_statcap_get_src(location, vcap->bin_comp) |
+				  2 << DCMIPP_P1STXCR_BINS_SHIFT |
+				  DCMIPP_P1STXCR_ENABLE);
+
+		/* Accumulators contains the 1st set of BINS */
+		for (i = 0; i < 3; i++)
+			avr_bins->bins[i] = reg_read(vcap, DCMIPP_P1STXSR(i));
+		break;
+
+	case PHY_BIN_2_SHA_BIN_3:
+		/* Set control registers to capture the 4th set of BINS */
+		for (i = 0; i < 3; i++)
+			reg_write(vcap, DCMIPP_P1STXCR(i),
+				  DCMIPP_P1STXCR_MODE_BINS |
+				  dcmipp_statcap_get_src(location, vcap->bin_comp) |
+				  3 << DCMIPP_P1STXCR_BINS_SHIFT |
+				  DCMIPP_P1STXCR_ENABLE);
+
+		/* Accumulators contains the 2nd set of BINS */
+		for (i = 0; i < 3; i++)
+			avr_bins->bins[i + 3] = reg_read(vcap, DCMIPP_P1STXSR(i));
+		break;
+
+	case PHY_BIN_3_SHA_AV_RGB:
+		/* Set control registers to capture the AVERAGES (RGB) */
+		for (i = 0; i < 3; i++)
+			/* Usage of !location is on purpose to switch to the other location */
+			reg_write(vcap, DCMIPP_P1STXCR(i),
+				  DCMIPP_P1STXCR_MODE_AVERAGE |
+				  dcmipp_statcap_get_src(!location, i) |
+				  vcap->avg_filter << DCMIPP_P1STXCR_BINS_SHIFT |
+				  DCMIPP_P1STXCR_ENABLE);
+
+		/* Accumulators contains the 3rd set of BINS */
+		for (i = 0; i < 3; i++)
+			avr_bins->bins[i + 6] = reg_read(vcap, DCMIPP_P1STXSR(i));
+		break;
+
+	case PHY_AV_RGB_SHA_AV_RGB:
+		/* State used for the AVERAGE PRE capture mode */
+		dcmipp_statcap_read_avg_stats(vcap, location);
+		break;
+	}
+
+	/* If a full capture cycle has been done, output data to a buffer */
+	if (stat_ready)
+		dcmipp_statcap_buffer_done(vcap);
+
+	spin_unlock_irq(&vcap->irqlock);
+
+	/* Update the capture_state & prev_capture_state */
+	switch (vcap->stat_profile) {
+	case V4L2_STAT_PROFILE_FULL:
+		vcap->prev_capture_state = vcap->capture_state;
+		if (vcap->capture_state < PHY_BIN_3_SHA_AV_RGB) {
+			vcap->capture_state++;
+		} else {
+			if (location == DCMIPP_P1STXCR_SRC_LOC_POST)
+				stat_ready = true;
+			location = !location;
+			vcap->capture_state = PHY_AV_RGB_SHA_BIN_0;
+		}
+		break;
+
+	case V4L2_STAT_PROFILE_AVERAGE_PRE:
+	case V4L2_STAT_PROFILE_AVERAGE_POST:
+		if (vcap->capture_state == COLD_START) {
+			vcap->capture_state = PHY_AV_RGB_SHA_AV_RGB;
+			stat_ready = true;
+		}
+		break;
+	}
+
+	return IRQ_HANDLED;
+}
+
+struct dcmipp_ent_device *
+dcmipp_statcap_ent_init(struct device *dev, const char *entity_name,
+			struct v4l2_device *v4l2_dev, void __iomem *regs)
+{
+	struct dcmipp_statcap_device *vcap;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int i, ret = 0;
+
+	/* Allocate the dcmipp_cap_device struct */
+	vcap = kzalloc(sizeof(*vcap), GFP_KERNEL);
+	if (!vcap)
+		return ERR_PTR(-ENOMEM);
+
+	/* Allocate the pad */
+	vcap->ved.pads =
+		dcmipp_pads_init(1, (const unsigned long[1]) {MEDIA_PAD_FL_SINK});
+	if (IS_ERR(vcap->ved.pads)) {
+		ret = PTR_ERR(vcap->ved.pads);
+		goto err_free_vcap;
+	}
+
+	/* Initialize the media entity */
+	vcap->vdev.entity.name = entity_name;
+	vcap->vdev.entity.function = MEDIA_ENT_F_IO_V4L;
+	ret = media_entity_pads_init(&vcap->vdev.entity,
+				     1, vcap->ved.pads);
+	if (ret)
+		goto err_clean_pads;
+
+	/* Initialize the lock */
+	mutex_init(&vcap->lock);
+
+	/* Initialize the vb2 queue */
+	q = &vcap->queue;
+	q->type = V4L2_BUF_TYPE_META_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;
+	q->lock = &vcap->lock;
+	q->drv_priv = vcap;
+	q->buf_struct_size = sizeof(struct dcmipp_buf);
+	q->ops = &dcmipp_statcap_qops;
+	q->mem_ops = &vb2_vmalloc_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->min_buffers_needed = 1;
+	q->dev = dev;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s: vb2 queue init failed (err=%d)\n",
+			entity_name, ret);
+		goto err_clean_m_ent;
+	}
+
+	/* Initialize buffer list and its lock */
+	INIT_LIST_HEAD(&vcap->buffers);
+	spin_lock_init(&vcap->irqlock);
+
+	/* Fill the dcmipp_ent_device struct */
+	vcap->ved.ent = &vcap->vdev.entity;
+	vcap->ved.handler = NULL;
+	vcap->ved.thread_fn = dcmipp_statcap_irq_thread;
+	vcap->dev = dev;
+	vcap->regs = regs;
+
+	/* Initialize the video_device struct */
+	vdev = &vcap->vdev;
+	vdev->device_caps = V4L2_CAP_META_CAPTURE | V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
+	vdev->entity.ops = &dcmipp_statcap_mops;
+	vdev->release = dcmipp_statcap_release;
+	vdev->fops = &dcmipp_statcap_fops;
+	vdev->ioctl_ops = &dcmipp_statcap_ioctl_ops;
+	vdev->lock = &vcap->lock;
+	vdev->queue = q;
+	vdev->v4l2_dev = v4l2_dev;
+	strscpy(vdev->name, entity_name, sizeof(vdev->name));
+	video_set_drvdata(vdev, &vcap->ved);
+
+	/* Add controls */
+	v4l2_ctrl_handler_init(&vcap->ctrls, ARRAY_SIZE(dcmipp_statcap_ctrls));
+
+	for (i = 0; i < ARRAY_SIZE(dcmipp_statcap_ctrls); i++) {
+		v4l2_ctrl_new_custom(&vcap->ctrls, &dcmipp_statcap_ctrls[i], NULL);
+		ret = vcap->ctrls.error;
+		if (ret < 0) {
+			dev_err(vcap->dev, "Control initialization error %d\n",	ret);
+			goto err_clean_ctrl_hdl;
+		}
+	}
+	vcap->vdev.ctrl_handler = &vcap->ctrls;
+
+	/* Register the video_device with the v4l2 and the media framework */
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		dev_err(dev, "%s: video register failed (err=%d)\n",
+			vcap->vdev.name, ret);
+		goto err_clean_ctrl_hdl;
+	}
+
+	return &vcap->ved;
+
+err_clean_ctrl_hdl:
+	v4l2_ctrl_handler_free(&vcap->ctrls);
+err_clean_m_ent:
+	media_entity_cleanup(&vcap->vdev.entity);
+err_clean_pads:
+	dcmipp_pads_cleanup(vcap->ved.pads);
+err_free_vcap:
+	kfree(vcap);
+
+	return ERR_PTR(ret);
+}
diff --git a/drivers/media/platform/verisilicon/Kconfig b/drivers/media/platform/verisilicon/Kconfig
index e65b836b9..57f52d715 100644
--- a/drivers/media/platform/verisilicon/Kconfig
+++ b/drivers/media/platform/verisilicon/Kconfig
@@ -4,7 +4,7 @@ comment "Verisilicon media platform drivers"
 
 config VIDEO_HANTRO
 	tristate "Hantro VPU driver"
-	depends on ARCH_MXC || ARCH_ROCKCHIP || ARCH_AT91 || ARCH_SUNXI || COMPILE_TEST
+	depends on ARCH_MXC || ARCH_ROCKCHIP || ARCH_AT91 || ARCH_SUNXI || ARCH_STM32 || COMPILE_TEST
 	depends on V4L_MEM2MEM_DRIVERS
 	depends on VIDEO_DEV
 	select MEDIA_CONTROLLER
@@ -16,8 +16,8 @@ config VIDEO_HANTRO
 	select V4L2_VP9
 	help
 	  Support for the Hantro IP based Video Processing Units present on
-	  Rockchip and NXP i.MX8M SoCs, which accelerate video and image
-	  encoding and decoding.
+	  Rockchip, NXP i.MX8M and STMicroelectronics STM32MP25 SoCs,
+	  which accelerate video and image encoding and decoding.
 	  To compile this driver as a module, choose M here: the module
 	  will be called hantro-vpu.
 
@@ -52,3 +52,11 @@ config VIDEO_HANTRO_SUNXI
 	default y
 	help
 	  Enable support for H6 SoC.
+
+config VIDEO_HANTRO_STM32MP25
+	bool "Hantro STM32MP25 support"
+	depends on VIDEO_HANTRO
+	depends on ARCH_STM32 || COMPILE_TEST
+	default y
+	help
+	  Enable support for STM32MP25 SoCs.
diff --git a/drivers/media/platform/verisilicon/Makefile b/drivers/media/platform/verisilicon/Makefile
index ebd5ede7b..ad9351af8 100644
--- a/drivers/media/platform/verisilicon/Makefile
+++ b/drivers/media/platform/verisilicon/Makefile
@@ -6,7 +6,11 @@ hantro-vpu-y += \
 		hantro_drv.o \
 		hantro_v4l2.o \
 		hantro_postproc.o \
+		hantro_boolenc.o \
+		hantro_h1.o \
 		hantro_h1_jpeg_enc.o \
+		hantro_h1_vp8_enc.o \
+		hantro_h1_h264_enc.o \
 		hantro_g1.o \
 		hantro_g1_h264_dec.o \
 		hantro_g1_mpeg2_dec.o \
@@ -18,6 +22,7 @@ hantro-vpu-y += \
 		rockchip_vpu2_hw_h264_dec.o \
 		rockchip_vpu2_hw_mpeg2_dec.o \
 		rockchip_vpu2_hw_vp8_dec.o \
+		rockchip_vpu2_hw_vp8_enc.o \
 		hantro_jpeg.o \
 		hantro_h264.o \
 		hantro_hevc.o \
@@ -36,3 +41,7 @@ hantro-vpu-$(CONFIG_VIDEO_HANTRO_ROCKCHIP) += \
 
 hantro-vpu-$(CONFIG_VIDEO_HANTRO_SUNXI) += \
 		sunxi_vpu_hw.o
+
+hantro-vpu-$(CONFIG_VIDEO_HANTRO_STM32MP25) += \
+		stm32mp25_vdec_hw.o \
+		stm32mp25_venc_hw.o
diff --git a/drivers/media/platform/verisilicon/hantro.h b/drivers/media/platform/verisilicon/hantro.h
index 2989ebc63..4ec404441 100644
--- a/drivers/media/platform/verisilicon/hantro.h
+++ b/drivers/media/platform/verisilicon/hantro.h
@@ -32,6 +32,8 @@ struct hantro_codec_ops;
 struct hantro_postproc_ops;
 
 #define HANTRO_JPEG_ENCODER	BIT(0)
+#define HANTRO_VP8_ENCODER	BIT(1)
+#define HANTRO_H264_ENCODER	BIT(2)
 #define HANTRO_ENCODERS		0x0000ffff
 #define HANTRO_MPEG2_DECODER	BIT(16)
 #define HANTRO_VP8_DECODER	BIT(17)
@@ -111,6 +113,7 @@ struct hantro_variant {
  * @HANTRO_MODE_VP8_DEC: VP8 decoder.
  * @HANTRO_MODE_HEVC_DEC: HEVC decoder.
  * @HANTRO_MODE_VP9_DEC: VP9 decoder.
+ * @HANTRO_MODE_VP8_ENC: VP8 encoder.
  */
 enum hantro_codec_mode {
 	HANTRO_MODE_NONE = -1,
@@ -120,6 +123,8 @@ enum hantro_codec_mode {
 	HANTRO_MODE_VP8_DEC,
 	HANTRO_MODE_HEVC_DEC,
 	HANTRO_MODE_VP9_DEC,
+	HANTRO_MODE_VP8_ENC,
+	HANTRO_MODE_H264_ENC,
 };
 
 /*
@@ -203,6 +208,7 @@ struct hantro_dev {
 	void __iomem *enc_base;
 	void __iomem *dec_base;
 	void __iomem *ctrl_base;
+	u32 max_burst_length;
 
 	struct mutex vpu_mutex;	/* video_device lock */
 	spinlock_t irqlock;
@@ -217,6 +223,8 @@ struct hantro_dev {
  * @fh:			V4L2 file handler.
  * @is_encoder:		Decoder or encoder context?
  *
+ * @str:		Placeholder for debug string
+ *
  * @sequence_cap:       Sequence counter for capture queue
  * @sequence_out:       Sequence counter for output queue
  *
@@ -228,6 +236,7 @@ struct hantro_dev {
  * @ctrl_handler:	Control handler used to register controls.
  * @jpeg_quality:	User-specified JPEG compression quality.
  * @bit_depth:		Bit depth of current frame
+ * @rotation:		Image clockwise rotation in degrees
  *
  * @codec_ops:		Set of operations related to codec mode.
  * @postproc:		Post-processing context.
@@ -243,6 +252,8 @@ struct hantro_ctx {
 	struct v4l2_fh fh;
 	bool is_encoder;
 
+	char str[400];
+
 	u32 sequence_cap;
 	u32 sequence_out;
 
@@ -254,6 +265,7 @@ struct hantro_ctx {
 	struct v4l2_ctrl_handler ctrl_handler;
 	int jpeg_quality;
 	int bit_depth;
+	int rotation;
 
 	const struct hantro_codec_ops *codec_ops;
 	struct hantro_postproc_ctx postproc;
@@ -265,6 +277,8 @@ struct hantro_ctx {
 		struct hantro_vp8_dec_hw_ctx vp8_dec;
 		struct hantro_hevc_dec_hw_ctx hevc_dec;
 		struct hantro_vp9_dec_hw_ctx vp9_dec;
+		struct hantro_vp8_enc_hw_ctx vp8_enc;
+		struct hantro_h264_enc_hw_ctx h264_enc;
 	};
 };
 
@@ -361,6 +375,12 @@ extern int hantro_debug;
 #define vpu_err(fmt, args...)					\
 	pr_err("%s:%d: " fmt, __func__, __LINE__, ##args)
 
+static inline unsigned int hantro_rounded_luma_size(unsigned int w,
+						    unsigned int h)
+{
+	return round_up(w, MB_DIM) * round_up(h, MB_DIM);
+}
+
 /* Structure access helpers. */
 static inline struct hantro_ctx *fh_to_ctx(struct v4l2_fh *fh)
 {
@@ -482,4 +502,9 @@ int hantro_postproc_alloc(struct hantro_ctx *ctx);
 int hanto_postproc_enum_framesizes(struct hantro_ctx *ctx,
 				   struct v4l2_frmsizeenum *fsize);
 
+void hantro_h1_set_axi_ctrl(struct hantro_dev *vpu, struct hantro_ctx *ctx);
+void hantro_h1_set_color_conv(struct hantro_dev *vpu, struct hantro_ctx *ctx);
+void hantro_h1_set_src_img_ctrl(struct hantro_dev *vpu, struct hantro_ctx *ctx);
+
+
 #endif /* HANTRO_H_ */
diff --git a/drivers/media/platform/verisilicon/hantro_boolenc.c b/drivers/media/platform/verisilicon/hantro_boolenc.c
new file mode 100644
index 000000000..88a1c1c16
--- /dev/null
+++ b/drivers/media/platform/verisilicon/hantro_boolenc.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/bug.h>
+
+#include "hantro_boolenc.h"
+
+void hantro_boolenc_init(struct hantro_boolenc *e, uint8_t *output)
+{
+	e->output = output;
+	e->range = 255;
+	e->bottom = 0;
+	e->bit_count = 24;
+	e->bytes_written = 0;
+}
+
+/*
+ * Add one to a number stored in bytes preceding *q.
+ * There's exactly bytes_written such bytes.
+ *
+ * The spec guarantees that the backward search won't go beyond
+ * the start of the buffer, so if we detect such condition we can
+ * BUG_ON() - this should never happen anyway.
+ */
+static void add_one_to_output(uint8_t *q, int bytes_written)
+{
+	/*
+	 * originally:
+	 * while (*--q == 0xff)
+	 *       *q = 0;
+	 */
+	for (;;) {
+		BUG_ON(bytes_written-- <= 0); /* check if we're allowed to go back one byte */
+
+		if (*--q == 0xff)	      /* adding a 1 overflows *--q? */
+			*q = 0;		      /* yes, so zero *q */
+		else
+			break;		      /* no, we're good to add 1 */
+	}
+
+	++*q;				      /* add 1 */
+}
+
+void hantro_boolenc_write_bool(struct hantro_boolenc *e, uint32_t prob, bool bool_value)
+{
+	uint32_t split = 1 + (((e->range - 1) * prob) >> 8);
+
+	if (bool_value) {
+		e->bottom += split;
+		e->range -= split;
+	} else {
+		e->range = split;
+	}
+
+	while (e->range < 128) {
+		e->range <<= 1;
+
+		if (e->bottom & (1 << 31))
+			add_one_to_output(e->output, e->bytes_written);
+
+		e->bottom <<= 1;
+
+		if (!--e->bit_count) {
+			*e->output++ = (uint8_t)(e->bottom >> 24);
+			++e->bytes_written;
+			e->bottom &= (1 << 24) - 1;
+			e->bit_count = 8;
+		}
+	}
+}
diff --git a/drivers/media/platform/verisilicon/hantro_boolenc.h b/drivers/media/platform/verisilicon/hantro_boolenc.h
new file mode 100644
index 000000000..80ec686d5
--- /dev/null
+++ b/drivers/media/platform/verisilicon/hantro_boolenc.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <linux/types.h>
+
+struct hantro_boolenc {
+	uint8_t *output;	/* next byte pointer */
+	uint32_t range;
+	uint32_t bottom;	/* 4 LSB of leftmost end of the range, MSB alread in output  */
+	int bit_count;		/* how many shifts until next encoded byte available */
+	int bytes_written;
+};
+
+void hantro_boolenc_init(struct hantro_boolenc *e, uint8_t *output);
+
+void hantro_boolenc_write_bool(struct hantro_boolenc *e, uint32_t prob, bool bool_value);
+
+static inline void hantro_boolenc_write_lit(struct hantro_boolenc *e, uint32_t val, uint8_t n)
+{
+	while (n--)
+		hantro_boolenc_write_bool(e, 128, (val >> n) & 0x1);
+}
diff --git a/drivers/media/platform/verisilicon/hantro_drv.c b/drivers/media/platform/verisilicon/hantro_drv.c
index 69a2442f3..afc7bcdda 100644
--- a/drivers/media/platform/verisilicon/hantro_drv.c
+++ b/drivers/media/platform/verisilicon/hantro_drv.c
@@ -161,7 +161,6 @@ void hantro_end_prepare_run(struct hantro_ctx *ctx)
 	src_buf = hantro_get_src_buf(ctx);
 	v4l2_ctrl_request_complete(src_buf->vb2_buf.req_obj.req,
 				   &ctx->ctrl_handler);
-
 	/* Kick the watchdog. */
 	schedule_delayed_work(&ctx->dev->watchdog_work,
 			      msecs_to_jiffies(2000));
@@ -186,6 +185,8 @@ static void device_run(void *priv)
 
 	v4l2_m2m_buf_copy_metadata(src, dst, true);
 
+	ctx->codec_ops->reset(ctx);
+
 	if (ctx->codec_ops->run(ctx))
 		goto err_cancel_job;
 
@@ -284,6 +285,38 @@ static int hantro_try_ctrl(struct v4l2_ctrl *ctrl)
 		if (dec_params->profile != 0)
 			return -EINVAL;
 	}
+
+	return 0;
+}
+
+static int hantro_enc_try_ctrl(struct v4l2_ctrl *ctrl)
+{
+	if (ctrl->id == V4L2_CID_ROTATE) {
+		/* Only 90 and 270 degrees rotation are supported */
+		if (ctrl->val != 0 && ctrl->val != 90 && ctrl->val != 270)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int hantro_enc_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct hantro_ctx *ctx;
+
+	ctx = container_of(ctrl->handler,
+			   struct hantro_ctx, ctrl_handler);
+
+	vpu_debug(1, "s_ctrl: id = %d, val = %d\n", ctrl->id, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_ROTATE:
+		ctx->rotation = ctrl->val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
@@ -337,6 +370,11 @@ static const struct v4l2_ctrl_ops hantro_vp9_ctrl_ops = {
 	.s_ctrl = hantro_vp9_s_ctrl,
 };
 
+static const struct v4l2_ctrl_ops hantro_enc_ctrl_ops = {
+	.try_ctrl = hantro_enc_try_ctrl,
+	.s_ctrl = hantro_enc_s_ctrl,
+};
+
 #define HANTRO_JPEG_ACTIVE_MARKERS	(V4L2_JPEG_ACTIVE_MARKER_APP0 | \
 					 V4L2_JPEG_ACTIVE_MARKER_COM | \
 					 V4L2_JPEG_ACTIVE_MARKER_DQT | \
@@ -374,6 +412,20 @@ static const struct hantro_ctrl controls[] = {
 		.cfg = {
 			.id = V4L2_CID_STATELESS_MPEG2_SEQUENCE,
 		},
+	}, {
+		.codec = HANTRO_VP8_ENCODER,
+		.cfg = {
+			.id = V4L2_CID_STATELESS_VP8_ENCODE_PARAMS,
+		},
+	}, {
+		.codec = HANTRO_VP8_ENCODER,
+		.cfg = {
+			.id = V4L2_CID_STATELESS_VP8_ENCODE_QP,
+			.min = 0,
+			.max = 127,
+			.step = 1,
+			.def = 0,
+		},
 	}, {
 		.codec = HANTRO_MPEG2_DECODER,
 		.cfg = {
@@ -499,6 +551,16 @@ static const struct hantro_ctrl controls[] = {
 		.cfg = {
 			.id = V4L2_CID_STATELESS_VP9_COMPRESSED_HDR,
 		},
+	}, {
+		.codec = HANTRO_H264_ENCODER,
+		.cfg = {
+			.id = V4L2_CID_STATELESS_H264_ENCODE_PARAMS,
+		},
+	}, {
+		.codec = HANTRO_H264_ENCODER,
+		.cfg = {
+			.id = V4L2_CID_STATELESS_H264_ENCODE_RC,
+		},
 	},
 };
 
@@ -508,7 +570,11 @@ static int hantro_ctrls_setup(struct hantro_dev *vpu,
 {
 	int i, num_ctrls = ARRAY_SIZE(controls);
 
-	v4l2_ctrl_handler_init(&ctx->ctrl_handler, num_ctrls);
+	v4l2_ctrl_handler_init(&ctx->ctrl_handler, 1 + num_ctrls);
+
+	if (ctx->is_encoder)
+		v4l2_ctrl_new_std(&ctx->ctrl_handler, &hantro_enc_ctrl_ops,
+				  V4L2_CID_ROTATE, 0, 270, 90, 0);
 
 	for (i = 0; i < num_ctrls; i++) {
 		if (!(allowed_codecs & controls[i].codec))
@@ -523,6 +589,7 @@ static int hantro_ctrls_setup(struct hantro_dev *vpu,
 			v4l2_ctrl_handler_free(&ctx->ctrl_handler);
 			return ctx->ctrl_handler.error;
 		}
+
 	}
 	return v4l2_ctrl_handler_setup(&ctx->ctrl_handler);
 }
@@ -642,6 +709,10 @@ static const struct of_device_id of_hantro_match[] = {
 #endif
 #ifdef CONFIG_VIDEO_HANTRO_SUNXI
 	{ .compatible = "allwinner,sun50i-h6-vpu-g2", .data = &sunxi_vpu_variant, },
+#endif
+#ifdef CONFIG_VIDEO_HANTRO_STM32MP25
+	{ .compatible = "st,stm32mp25-vdec", .data = &stm32mp25_vdec_variant, },
+	{ .compatible = "st,stm32mp25-venc", .data = &stm32mp25_venc_variant, },
 #endif
 	{ /* sentinel */ }
 };
@@ -899,13 +970,15 @@ static int hantro_probe(struct platform_device *pdev)
 	const struct of_device_id *match;
 	struct hantro_dev *vpu;
 	struct resource *res;
+	struct device_node *np;
 	int num_bases;
-	int i, ret;
+	int i, ret, mbl;
 
 	vpu = devm_kzalloc(&pdev->dev, sizeof(*vpu), GFP_KERNEL);
 	if (!vpu)
 		return -ENOMEM;
 
+	np = pdev->dev.of_node;
 	vpu->dev = &pdev->dev;
 	vpu->pdev = pdev;
 	mutex_init(&vpu->vpu_mutex);
@@ -982,6 +1055,14 @@ static int hantro_probe(struct platform_device *pdev)
 	}
 	vb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));
 
+	/* get max burst length */
+	ret = of_property_read_u32(np, "maxburstlen", &mbl);
+	if (ret)
+		/* Set to max value if not DT properties */
+		mbl = 64;
+
+	vpu->max_burst_length = mbl / 8;
+
 	for (i = 0; i < vpu->variant->num_irqs; i++) {
 		const char *irq_name;
 		int irq;
diff --git a/drivers/media/platform/verisilicon/hantro_g1.c b/drivers/media/platform/verisilicon/hantro_g1.c
index 0ab1cee62..50715f353 100644
--- a/drivers/media/platform/verisilicon/hantro_g1.c
+++ b/drivers/media/platform/verisilicon/hantro_g1.c
@@ -11,6 +11,23 @@
 #include "hantro.h"
 #include "hantro_g1_regs.h"
 
+void hantro_g1_check_idle(struct hantro_dev *vpu)
+{
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		u32 status;
+
+		/* Make sure the VPU is idle */
+		status = vdpu_read(vpu, G1_REG_INTERRUPT);
+		if (status & G1_REG_INTERRUPT_DEC_E) {
+			dev_warn(vpu->dev, "device still running, aborting");
+			status |= G1_REG_INTERRUPT_DEC_ABORT_E | G1_REG_INTERRUPT_DEC_IRQ_DIS;
+			vdpu_write(vpu, status, G1_REG_INTERRUPT);
+		}
+	}
+}
+
 irqreturn_t hantro_g1_irq(int irq, void *dev_id)
 {
 	struct hantro_dev *vpu = dev_id;
diff --git a/drivers/media/platform/verisilicon/hantro_g1_h264_dec.c b/drivers/media/platform/verisilicon/hantro_g1_h264_dec.c
index 9de7f05ef..3e14525e8 100644
--- a/drivers/media/platform/verisilicon/hantro_g1_h264_dec.c
+++ b/drivers/media/platform/verisilicon/hantro_g1_h264_dec.c
@@ -253,6 +253,8 @@ int hantro_g1_h264_dec_run(struct hantro_ctx *ctx)
 	struct vb2_v4l2_buffer *src_buf;
 	int ret;
 
+	hantro_g1_check_idle(vpu);
+
 	/* Prepare the H264 decoder context. */
 	ret = hantro_h264_dec_prepare_run(ctx);
 	if (ret)
@@ -269,14 +271,15 @@ int hantro_g1_h264_dec_run(struct hantro_ctx *ctx)
 	/* Start decoding! */
 	vdpu_write_relaxed(vpu,
 			   G1_REG_CONFIG_DEC_AXI_RD_ID(0xffu) |
-			   G1_REG_CONFIG_DEC_TIMEOUT_E |
 			   G1_REG_CONFIG_DEC_OUT_ENDIAN |
 			   G1_REG_CONFIG_DEC_STRENDIAN_E |
-			   G1_REG_CONFIG_DEC_MAX_BURST(16) |
+			   G1_REG_CONFIG_DEC_2CHAN_DIS |
+			   G1_REG_CONFIG_DEC_MAX_BURST(vpu->max_burst_length) |
 			   G1_REG_CONFIG_DEC_OUTSWAP32_E |
 			   G1_REG_CONFIG_DEC_INSWAP32_E |
 			   G1_REG_CONFIG_DEC_STRSWAP32_E |
-			   G1_REG_CONFIG_DEC_CLK_GATE_E,
+			   G1_REG_CONFIG_DEC_SCMD_DIS |
+			   G1_REG_CONFIG_DEC_ADV_PRE_DIS,
 			   G1_REG_CONFIG);
 	vdpu_write(vpu, G1_REG_INTERRUPT_DEC_E, G1_REG_INTERRUPT);
 
diff --git a/drivers/media/platform/verisilicon/hantro_g1_mpeg2_dec.c b/drivers/media/platform/verisilicon/hantro_g1_mpeg2_dec.c
index 9aea331e1..bcaf350aa 100644
--- a/drivers/media/platform/verisilicon/hantro_g1_mpeg2_dec.c
+++ b/drivers/media/platform/verisilicon/hantro_g1_mpeg2_dec.c
@@ -156,6 +156,8 @@ int hantro_g1_mpeg2_dec_run(struct hantro_ctx *ctx)
 	src_buf = hantro_get_src_buf(ctx);
 	dst_buf = hantro_get_dst_buf(ctx);
 
+	hantro_g1_check_idle(vpu);
+
 	/* Apply request controls if any */
 	hantro_start_prepare_run(ctx);
 
@@ -165,7 +167,6 @@ int hantro_g1_mpeg2_dec_run(struct hantro_ctx *ctx)
 			      V4L2_CID_STATELESS_MPEG2_PICTURE);
 
 	reg = G1_REG_DEC_AXI_RD_ID(0) |
-	      G1_REG_DEC_TIMEOUT_E(1) |
 	      G1_REG_DEC_STRSWAP32_E(1) |
 	      G1_REG_DEC_STRENDIAN_E(1) |
 	      G1_REG_DEC_INSWAP32_E(1) |
@@ -177,7 +178,7 @@ int hantro_g1_mpeg2_dec_run(struct hantro_ctx *ctx)
 	      G1_REG_DEC_OUT_ENDIAN(1) |
 	      G1_REG_DEC_ADV_PRE_DIS(0) |
 	      G1_REG_DEC_SCMD_DIS(0) |
-	      G1_REG_DEC_MAX_BURST(16);
+	      G1_REG_DEC_MAX_BURST(vpu->max_burst_length);
 	vdpu_write_relaxed(vpu, reg, G1_SWREG(2));
 
 	reg = G1_REG_DEC_MODE(5) |
diff --git a/drivers/media/platform/verisilicon/hantro_g1_regs.h b/drivers/media/platform/verisilicon/hantro_g1_regs.h
index c623b3b0b..e322fe932 100644
--- a/drivers/media/platform/verisilicon/hantro_g1_regs.h
+++ b/drivers/media/platform/verisilicon/hantro_g1_regs.h
@@ -22,6 +22,7 @@
 #define     G1_REG_INTERRUPT_DEC_BUS_INT		BIT(13)
 #define     G1_REG_INTERRUPT_DEC_RDY_INT		BIT(12)
 #define     G1_REG_INTERRUPT_DEC_IRQ			BIT(8)
+#define     G1_REG_INTERRUPT_DEC_ABORT_E		BIT(5)
 #define     G1_REG_INTERRUPT_DEC_IRQ_DIS		BIT(4)
 #define     G1_REG_INTERRUPT_DEC_E			BIT(0)
 #define G1_REG_CONFIG					0x008
@@ -32,6 +33,7 @@
 #define     G1_REG_CONFIG_DEC_INSWAP32_E		BIT(20)
 #define     G1_REG_CONFIG_DEC_OUTSWAP32_E		BIT(19)
 #define     G1_REG_CONFIG_DEC_DATA_DISC_E		BIT(18)
+#define     G1_REG_CONFIG_DEC_2CHAN_DIS			BIT(18)
 #define     G1_REG_CONFIG_TILED_MODE_MSB		BIT(17)
 #define     G1_REG_CONFIG_DEC_OUT_TILED_E		BIT(17)
 #define     G1_REG_CONFIG_DEC_LATENCY(x)		(((x) & 0x3f) << 11)
diff --git a/drivers/media/platform/verisilicon/hantro_g1_vp8_dec.c b/drivers/media/platform/verisilicon/hantro_g1_vp8_dec.c
index 851eb67f1..4bfae8696 100644
--- a/drivers/media/platform/verisilicon/hantro_g1_vp8_dec.c
+++ b/drivers/media/platform/verisilicon/hantro_g1_vp8_dec.c
@@ -439,6 +439,8 @@ int hantro_g1_vp8_dec_run(struct hantro_ctx *ctx)
 	u32 mb_width, mb_height;
 	u32 reg;
 
+	hantro_g1_check_idle(vpu);
+
 	hantro_start_prepare_run(ctx);
 
 	hdr = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_VP8_FRAME);
@@ -452,15 +454,16 @@ int hantro_g1_vp8_dec_run(struct hantro_ctx *ctx)
 
 	hantro_vp8_prob_update(ctx, hdr);
 
-	reg = G1_REG_CONFIG_DEC_TIMEOUT_E |
-	      G1_REG_CONFIG_DEC_STRENDIAN_E |
+	reg = G1_REG_CONFIG_DEC_STRENDIAN_E |
 	      G1_REG_CONFIG_DEC_INSWAP32_E |
 	      G1_REG_CONFIG_DEC_STRSWAP32_E |
 	      G1_REG_CONFIG_DEC_OUTSWAP32_E |
-	      G1_REG_CONFIG_DEC_CLK_GATE_E |
 	      G1_REG_CONFIG_DEC_IN_ENDIAN |
 	      G1_REG_CONFIG_DEC_OUT_ENDIAN |
-	      G1_REG_CONFIG_DEC_MAX_BURST(16);
+	      G1_REG_CONFIG_DEC_2CHAN_DIS |
+	      G1_REG_CONFIG_DEC_SCMD_DIS |
+	      G1_REG_CONFIG_DEC_ADV_PRE_DIS |
+	      G1_REG_CONFIG_DEC_MAX_BURST(vpu->max_burst_length);
 	vdpu_write_relaxed(vpu, reg, G1_REG_CONFIG);
 
 	reg = G1_REG_DEC_CTRL0_DEC_MODE(10) |
diff --git a/drivers/media/platform/verisilicon/hantro_h1.c b/drivers/media/platform/verisilicon/hantro_h1.c
new file mode 100644
index 000000000..ec445d52e
--- /dev/null
+++ b/drivers/media/platform/verisilicon/hantro_h1.c
@@ -0,0 +1,382 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics SA 2023
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ */
+
+#include "hantro.h"
+#include "hantro_hw.h"
+#include "hantro_h1_regs.h"
+
+enum cconv_fmt {
+	FMT_RGB = 0,
+	FMT_YUV601,
+	FMT_YUV709
+};
+
+#define FMT_STR(f) ({					\
+	typeof(f) __f = (f);				\
+	(__f) == FMT_RGB ? "RGB" :			\
+	(__f) == FMT_YUV601 ? "YUV601" :		\
+	(__f) == FMT_YUV709 ? "YUV709" : "?"; })
+
+enum cconv_range {
+	RANGE_FULL = 0,
+	RANGE_LIMITED,
+};
+
+#define RANGE_STR(range) ((range) == RANGE_FULL ? "full" : "limited")
+
+/*
+ * Color conversion based on coefficient a,b,c,e,f:
+ *
+ * Y  = (a * R + b * G + c * B) / 65536
+ * Cb = (e * (B - Y)) / 65536 + 128
+ * Cr = (f * (R - Y)) / 65536 + 128
+ *
+ * alternatively Cb=f(R,G,B), Cr=f(R,G,B):
+ *
+ * Y  = (  a                     *R  + b               *G  + c                    *B) / 65536
+ * Cb = ( -(a * e / 65536)       *R  - (b * e / 65536) *G  + (e - (c * e / 65536))*B) / 65536 + 128
+ * Cr = (  (f - (a * f / 65536)) *R  - (b * f / 65536) *G  - (c * f / 65536)      *B) / 65536 + 128
+ *
+ */
+
+/*
+ *  RGB full range => YUV601 full range
+ *
+ *  Y  =  0.2989 * R + 0.5866 * G + 0.1145 * B
+ *  Cb = -0.1688 * R - 0.3312 * G + 0.5000 * B
+ *  Cr =  0.5000 * R - 0.4184 * G - 0.0817 * B
+ */
+/*                                              a      b     c      e      f */
+static const u32 rgbfull_to_yuv601full[] = {19589, 38443, 7504, 37008, 46740};
+
+/*
+ *  RGB full range => YUV709 full range
+ *
+ *  Y  =  0.2126 * R + 0.7152 * G + 0.0722 * B
+ *  Cb = -0.1146 * R - 0.3854 * G + 0.4999 * B
+ *  Cr =  0.4999 * R - 0.4541 * G - 0.0458 * B
+ */
+/*                                              a      b     c      e      f */
+static const u32 rgbfull_to_yuv709full[] = {13933, 46871, 4732, 35317, 41615};
+
+/*
+ *  RGB limited range => YUV601 limited range
+ *
+ *  Y  =  0.2989 * R + 0.5866 * G + 0.1145 * B
+ *  Cb = -0.1720 * R - 0.3375 * G + 0.5095 * B
+ *  Cr =  0.5110 * R - 0.4275 * G - 0.0835 * B
+ */
+/*                                            a      b     c      e      f */
+static const u32 rgblim_to_yuv601lim[] = {19589, 38443, 7504, 37712, 47767};
+
+/*
+ *  RGB limited range => YUV709 limited range
+ *
+ *  Y  =  0.2126 * R + 0.7152 * G + 0.0722 * B
+ *  Cb = -0.1171 * R - 0.3940 * G + 0.5111 * B
+ *  Cr =  0.5112 * R - 0.4643 * G - 0.0469 * B
+ */
+/*                                            a      b     c      e      f */
+static const u32 rgblim_to_yuv709lim[] = {13933, 46871, 4732, 36100, 42550};
+
+static const u32 *cconv_coeffss[2][3][2] = {
+	/* RGB full range */
+	{
+		/* RGB full range => RGB */
+		{
+			/* RGB full range => RGB full range */
+			NULL,
+			/* RGB full range => RGB limited range */
+			NULL,
+		},
+		/* RGB full range => YUV601 */
+		{
+			/* RGB full range => YUV601 full range */
+			rgbfull_to_yuv601full,
+			/* RGB full range => YUV601 limited range */
+			NULL,
+		},
+		/* RGB full range => YUV709 */
+		{
+			/* RGB full range => YUV709 full range */
+			rgbfull_to_yuv709full,
+			/* RGB full range => YUV709 limited range */
+			NULL,
+		},
+	},
+	/* RGB limited range */
+	{
+		/* RGB limited range => RGB */
+		{
+			/* RGB limited range => RGB full range */
+			NULL,
+			/* RGB limited range => RGB limited range */
+			NULL,
+		},
+		/* RGB limited range => YUV601 */
+		{
+			/* RGB limited range => YUV601 full range */
+			NULL,
+			/* RGB limited range => YUV601 limited range */
+			rgblim_to_yuv601lim,
+		},
+		/* RGB limited range => YUV709 */
+		{
+			/* RGB limited range => YUV709 full range */
+			NULL,
+			/* RGB limited range => YUV709 limited range */
+			rgblim_to_yuv709lim,
+		},
+	},
+};
+
+static inline bool is_rgb16(struct v4l2_pix_format_mplane *fmt)
+{
+	return (fmt->pixelformat == V4L2_PIX_FMT_RGB565);
+};
+
+static inline bool is_rgb32(struct v4l2_pix_format_mplane *fmt)
+{
+	return ((fmt->pixelformat == V4L2_PIX_FMT_XBGR32) ||
+		(fmt->pixelformat == V4L2_PIX_FMT_BGR32) ||
+		(fmt->pixelformat == V4L2_PIX_FMT_RGBX32) ||
+		(fmt->pixelformat == V4L2_PIX_FMT_BGRX32) ||
+		(fmt->pixelformat == V4L2_PIX_FMT_XRGB32) ||
+		(fmt->pixelformat == V4L2_PIX_FMT_RGB32));
+};
+
+static inline enum cconv_fmt to_cconv_fmt(struct v4l2_pix_format_mplane *fmt)
+{
+	if (is_rgb16(fmt) || is_rgb32(fmt))
+		return FMT_RGB;
+
+	/* All other formats are treated as YUV */
+
+	if (fmt->colorspace == V4L2_COLORSPACE_SMPTE170M)
+		return FMT_YUV601;
+	else
+		return FMT_YUV709;
+};
+
+static inline enum cconv_range to_cconv_range(struct v4l2_pix_format_mplane *fmt)
+{
+	if (fmt->quantization == V4L2_QUANTIZATION_FULL_RANGE)
+		return RANGE_FULL;
+
+	return RANGE_LIMITED;
+};
+
+static inline u32 to_cconv_mask(struct v4l2_pix_format_mplane *fmt)
+{
+	u32 r_mask_msb, g_mask_msb, b_mask_msb;
+
+	/*
+	 * ! see hantro_h1_set_axi_ctrl() for input swap
+	 * of RGB 16 and 32 bits formats
+	 */
+
+	switch (fmt->pixelformat) {
+	case V4L2_PIX_FMT_RGB565:
+		/*
+		 * <MSB>      <LSB>
+		 * RRRRRGGGGGGBBBBB
+		 * |    |     |
+		 * |    |      \___ bit  4 <MSB of B>
+		 * |     \_________ bit 10 <MSB of G>
+		 * \_______________ bit 15 <MSB of R>
+		 */
+		r_mask_msb = 15;
+		g_mask_msb = 10;
+		b_mask_msb =  4;
+		break;
+
+	case V4L2_PIX_FMT_XBGR32:
+	case V4L2_PIX_FMT_BGR32:
+		/*
+		 * <MSB>                      <LSB>
+		 * XXXXXXXXRRRRRRRRGGGGGGGGBBBBBBBB
+		 *         |       |       |
+		 *         |       |       \__ bit  7 <MSB of B>
+		 *         |        \_________ bit 15 <MSB of G>
+		 *         \__________________ bit 23 <MSB of R>
+		 */
+		r_mask_msb = 23;
+		g_mask_msb = 15;
+		b_mask_msb =  7;
+		break;
+
+	case V4L2_PIX_FMT_RGBX32:
+		/*
+		 * <MSB>                      <LSB>
+		 * XXXXXXXXBBBBBBBBGGGGGGGGRRRRRRRR
+		 *         |       |       |
+		 *         |       |       \__ bit  7 <MSB of R>
+		 *         |        \_________ bit 15 <MSB of G>
+		 *         \__________________ bit 23 <MSB of B>
+		 */
+		r_mask_msb = 7;
+		g_mask_msb = 15;
+		b_mask_msb = 23;
+		break;
+
+	case V4L2_PIX_FMT_BGRX32:
+		/*
+		 * <MSB>                      <LSB>
+		 * RRRRRRRRGGGGGGGGBBBBBBBBXXXXXXXX
+		 * |       |       |
+		 * |       |       \__ bit 15 <MSB of B>
+		 * |        \_________ bit 23 <MSB of G>
+		 * \__________________ bit 31 <MSB of R>
+		 */
+		r_mask_msb = 31;
+		g_mask_msb = 23;
+		b_mask_msb = 15;
+		break;
+
+	case V4L2_PIX_FMT_XRGB32:
+	case V4L2_PIX_FMT_RGB32:
+		/*
+		 * <MSB>                      <LSB>
+		 * BBBBBBBBGGGGGGGGRRRRRRRRXXXXXXXX
+		 * |       |       |
+		 * |       |       \__ bit 15 <MSB of R>
+		 * |        \_________ bit 23 <MSB of G>
+		 * \__________________ bit 31 <MSB of B>
+		 */
+		r_mask_msb = 15;
+		g_mask_msb = 23;
+		b_mask_msb = 31;
+		break;
+
+	default:
+		r_mask_msb = 0;
+		g_mask_msb = 0;
+		b_mask_msb = 0;
+		break;
+	}
+
+	return (H1_REG_RGB_YUV_R_MASK_MSB(r_mask_msb) |
+		H1_REG_RGB_YUV_G_MASK_MSB(g_mask_msb) |
+		H1_REG_RGB_YUV_B_MASK_MSB(b_mask_msb));
+};
+
+void hantro_h1_set_color_conv(struct hantro_dev *vpu, struct hantro_ctx *ctx)
+{
+	const u32 *cconv_coeffs;
+	enum cconv_fmt dst_fmt;
+	enum cconv_range dst_range;
+	enum cconv_fmt src_fmt;
+	enum cconv_range src_range;
+
+	dst_fmt = to_cconv_fmt(&ctx->dst_fmt);
+	dst_range = to_cconv_range(&ctx->dst_fmt);
+	src_fmt = to_cconv_fmt(&ctx->src_fmt);
+	src_range = to_cconv_range(&ctx->src_fmt);
+
+	if (src_fmt != FMT_RGB)
+		return;
+
+	if (dst_fmt == src_fmt &&
+	    dst_range == src_range)
+		return;
+
+	/* color conversion */
+	cconv_coeffs = cconv_coeffss[src_range][dst_fmt][dst_range];
+	if (!cconv_coeffs) {
+		vpu_debug(0, "Unsupported color conversion %s-%s => %s-%s\n",
+			  FMT_STR(src_fmt), RANGE_STR(src_range),
+			  FMT_STR(dst_fmt), RANGE_STR(dst_range));
+		return;
+	}
+
+	vpu_debug(4, "color conversion %s-%s => %s-%s\n",
+		  FMT_STR(src_fmt), RANGE_STR(src_range),
+		  FMT_STR(dst_fmt), RANGE_STR(dst_range));
+
+	vepu_write_relaxed(vpu, H1_REG_RGB_YUV_COEFF_A(cconv_coeffs[0]) |
+				H1_REG_RGB_YUV_COEFF_B(cconv_coeffs[1]),
+			   H1_REG_RGB_YUV_COEFF_AB);
+	vepu_write_relaxed(vpu, H1_REG_RGB_YUV_COEFF_C(cconv_coeffs[2]) |
+				H1_REG_RGB_YUV_COEFF_E(cconv_coeffs[3]),
+			   H1_REG_RGB_YUV_COEFF_CE);
+	vepu_write_relaxed(vpu, H1_REG_RGB_YUV_COEFF_F(cconv_coeffs[4]) |
+				to_cconv_mask(&ctx->src_fmt),
+			   H1_REG_RGB_YUV_COEFF_F_MASK);
+}
+
+void hantro_h1_set_axi_ctrl(struct hantro_dev *vpu, struct hantro_ctx *ctx)
+{
+	bool input_swap8, input_swap16, input_swap32;
+	u32 reg;
+	u32 max_burst_length = vpu->max_burst_length;
+
+	if (is_rgb32(&ctx->src_fmt)) {
+		input_swap32 = 0;
+		input_swap16 = 0;
+		input_swap8  = 0;
+	} else if (is_rgb16(&ctx->src_fmt)) {
+		input_swap32 = 1;
+		input_swap16 = 1;
+		input_swap8  = 0;
+	} else {
+		/* YUV */
+		input_swap32 = 1;
+		input_swap16 = 1;
+		input_swap8  = 1;
+	}
+
+	if (ctx->vpu_dst_fmt->codec_mode == HANTRO_MODE_H264_ENC)
+		max_burst_length = 16;
+
+	reg =     H1_REG_AXI_CTRL_OUTPUT_SWAP16
+		| (input_swap16 ? H1_REG_AXI_CTRL_INPUT_SWAP16 : 0)
+		| H1_REG_AXI_CTRL_BURST_LEN(max_burst_length)
+		| H1_REG_AXI_CTRL_OUTPUT_SWAP32
+		| (input_swap32 ? H1_REG_AXI_CTRL_INPUT_SWAP32 : 0)
+		| H1_REG_AXI_CTRL_OUTPUT_SWAP8
+		| (input_swap8 ? H1_REG_AXI_CTRL_INPUT_SWAP8 : 0);
+
+	vepu_write(vpu, reg, H1_REG_AXI_CTRL);
+}
+
+static inline unsigned int hantro_rotation(int rotation)
+{
+	if (rotation == 90)
+		return 1;
+	else if (rotation == 270)
+		return 2;
+
+	return 0;
+}
+
+void hantro_h1_set_src_img_ctrl(struct hantro_dev *vpu, struct hantro_ctx *ctx)
+{
+	u32 overfill_r, overfill_b;
+	u32 reg;
+
+	/*
+	 * The format width and height are already macroblock aligned
+	 * by .vidioc_s_fmt_vid_cap_mplane() callback. Destination
+	 * format width and height can be further modified by
+	 * .vidioc_s_selection(), and the width is 4-aligned.
+	 */
+	if (!ctx->rotation) {
+		overfill_r = ctx->src_fmt.width - ctx->dst_fmt.width;
+		overfill_b = ctx->src_fmt.height - ctx->dst_fmt.height;
+	} else {
+		/* FIXME Overfilled lines are seen when rotating image */
+		overfill_r = 0;
+		overfill_b = 0;
+	}
+
+	reg = H1_REG_IN_IMG_CTRL_ROW_LEN(ctx->src_fmt.width)
+		| H1_REG_IN_IMG_CTRL_OVRFLR_D4(overfill_r / 4)
+		| H1_REG_IN_IMG_CTRL_OVRFLB(overfill_b)
+		| H1_REG_IN_IMG_CTRL_FMT(ctx->vpu_src_fmt->enc_fmt)
+		| H1_REG_IN_IMG_CTRL_ROTATION(hantro_rotation(ctx->rotation));
+	vepu_write_relaxed(vpu, reg, H1_REG_IN_IMG_CTRL);
+}
diff --git a/drivers/media/platform/verisilicon/hantro_h1_h264_enc.c b/drivers/media/platform/verisilicon/hantro_h1_h264_enc.c
new file mode 100644
index 000000000..d919553d8
--- /dev/null
+++ b/drivers/media/platform/verisilicon/hantro_h1_h264_enc.c
@@ -0,0 +1,443 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics SA 2023
+ * Authors:
+ *	Andrzej Pietrasiewicz <andrzej.p@collabora.com>
+ *
+ * Some portions of code are derived from
+ * https://chromium.googlesource.com/chromiumos/third_party/kernel/+/refs/heads/chromeos-5.10/
+ * drivers/staging/media/hantro/rk3399_vpu_hw_h264_enc.c
+ *
+ * which is licensed GPL-2.0
+ *
+ * Rockchip rk3399 VPU codec driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd.
+ *	Alpha Lin <Alpha.Lin@rock-chips.com>
+ *	Jung Zhao <jung.zhao@rock-chips.com>
+ */
+#include "hantro.h"
+#include "hantro_hw.h"
+#include "hantro_h1_regs.h"
+
+/* threshold of MBs count to disable quarter pixel mv for encode speed, e.g. 1920x1080 */
+#define MAX_MB_COUNT_TO_DISABLE_QUARTER_PIXEL_MV	8160
+
+/* threshold of MBs count to disable multi mv in one macro block, e.g. 1920x1080 */
+#define MAX_MB_COUNT_TO_DISABLE_SPLIT_MV		8160
+
+#define HANTRO_H264_QP_NUM				52
+
+#define ZERO_16x16_MV_FAVOR_DIV2			10
+
+/* H.264 motion estimation parameters */
+static const u32 h264_prev_mode_favor[HANTRO_H264_QP_NUM] = {
+	7, 7, 8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18,
+	19, 20, 21, 22, 24, 25, 27, 29, 30, 32, 34, 36, 38, 41, 43, 46,
+	49, 51, 55, 58, 61, 65, 69, 73, 78, 82, 87, 93, 98, 104, 110,
+	117, 124, 132, 140
+};
+
+/* sqrt(2^((qp-12)/3))*8 */
+static const u32 h264_diff_mv_penalty[HANTRO_H264_QP_NUM] = {
+	2, 2, 3, 3, 3, 4, 4, 4, 5, 6,
+	6, 7, 8, 9, 10, 11, 13, 14, 16, 18,
+	20, 23, 26, 29, 32, 36, 40, 45, 51, 57,
+	64, 72, 81, 91, 102, 114, 128, 144, 161, 181,
+	203, 228, 256, 287, 323, 362, 406, 456, 512, 575,
+	645, 724
+};
+
+/* 31*sqrt(2^((qp-12)/3))/4 */
+static const u32 h264_diff_mv_penalty4p[HANTRO_H264_QP_NUM] = {
+	2, 2, 2, 3, 3, 3, 4, 4, 5, 5,
+	6, 7, 8, 9, 10, 11, 12, 14, 16, 17,
+	20, 22, 25, 28, 31, 35, 39, 44, 49, 55,
+	62, 70, 78, 88, 98, 110, 124, 139, 156, 175,
+	197, 221, 248, 278, 312, 351, 394, 442, 496, 557,
+	625, 701
+};
+
+static const u32 h264_intra16_favor[HANTRO_H264_QP_NUM] = {
+	24, 24, 24, 26, 27, 30, 32, 35, 39, 43, 48, 53, 58, 64, 71, 78,
+	85, 93, 102, 111, 121, 131, 142, 154, 167, 180, 195, 211, 229,
+	248, 271, 296, 326, 361, 404, 457, 523, 607, 714, 852, 1034,
+	1272, 1588, 2008, 2568, 3318, 4323, 5672, 7486, 9928, 13216,
+	17648
+};
+
+static const u32 h264_inter_favor[HANTRO_H264_QP_NUM] = {
+	40, 40, 41, 42, 43, 44, 45, 48, 51, 53, 55, 60, 62, 67, 69, 72,
+	78, 84, 90, 96, 110, 120, 135, 152, 170, 189, 210, 235, 265,
+	297, 335, 376, 420, 470, 522, 572, 620, 670, 724, 770, 820,
+	867, 915, 970, 1020, 1076, 1132, 1180, 1230, 1275, 1320, 1370
+};
+
+static const u32 h264_skip_sad_penalty[HANTRO_H264_QP_NUM] = {
+	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 233, 205, 182, 163,
+	146, 132, 120, 109, 100,  92,  84,  78,  71,  66,  61,  56,  52,  48,
+	44,  41,  38,  35,  32,  30,  27,  25,  23,  21,  19,  17,  15,  14,
+	12,  11,   9,   8,   7,   5,   4,   3,   2,   1
+};
+
+static const s32 h264_dmv_penalty[128] = { /* 4*sqrt(i*4*6) */
+	0,   19,   27,   33,   39,   43,   48,   51,   55,   58,
+	61,   64,   67,   70,   73,   75,   78,   80,   83,   85,
+	87,   89,   91,   93,   96,   97,   99,  101,  103,  105,
+	107,  109,  110,  112,  114,  115,  117,  119,  120,  122,
+	123,  125,  126,  128,  129,  131,  132,  134,  135,  137,
+	138,  139,  141,  142,  144,  145,  146,  147,  149,  150,
+	151,  153,  154,  155,  156,  157,  159,  160,  161,  162,
+	163,  165,  166,  167,  168,  169,  170,  171,  173,  174,
+	175,  176,  177,  178,  179,  180,  181,  182,  183,  184,
+	185,  186,  187,  188,  189,  190,  192,  192,  193,  194,
+	195,  196,  197,  198,  199,  200,  201,  202,  203,  204,
+	205,  206,  207,  208,  209,  210,  211,  211,  212,  213,
+	214,  215,  216,  217,  218,  219,  219,  220
+};
+
+static s32 exp_golomb_signed(s32 val)
+{
+	s32 tmp = 0;
+
+	if (val > 0)
+		val = 2 * val;
+	else
+		val = -2 * val + 1;
+	while (val >> ++tmp)
+		;
+	return tmp * 2 - 1;
+}
+
+static void hantro_h1_h264_enc_set_params(struct hantro_dev *vpu, struct hantro_ctx *ctx,
+					  struct v4l2_ctrl_h264_encode_params *params, int qp)
+{
+	unsigned int mb_width = MB_WIDTH(ctx->src_fmt.width);
+	unsigned int mb_height = MB_HEIGHT(ctx->src_fmt.height);
+	u32 prev_mode_favor = h264_prev_mode_favor[qp];
+	s32 scaler;
+	u32 skip_penalty;
+	u8 dmv_qpel_penalty[128];
+	u32 reg;
+	int i;
+
+	reg = H1_REG_ENC_CTRL0_INIT_QP(params->pic_init_qp_minus26 + 26)
+		| H1_REG_ENC_CTRL0_SLICE_ALPHA(params->slice_alpha_c0_offset_div2)
+		| H1_REG_ENC_CTRL0_SLICE_BETA(params->slice_beta_offset_div2)
+		| H1_REG_ENC_CTRL0_CHROMA_QP_OFFSET(params->chroma_qp_index_offset)
+		| H1_REG_ENC_CTRL0_IDR_PICID(params->idr_pic_id);
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL0);
+
+	reg = H1_REG_ENC_CTRL1_PPS_ID(params->pic_parameter_set_id)
+		| H1_REG_ENC_CTRL1_INTRA_PRED_MODE(prev_mode_favor)
+		| H1_REG_ENC_CTRL1_FRAME_NUM(params->frame_num);
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL1);
+
+	reg = 0;
+	if (mb_width * mb_height > MAX_MB_COUNT_TO_DISABLE_QUARTER_PIXEL_MV)
+		reg = H1_REG_ENC_CTRL2_DISABLE_QUARTER_PIXMV;
+	reg |= H1_REG_ENC_CTRL2_DEBLOCKING_FILTER_MODE(params->disable_deblocking_filter_idc)
+		| H1_REG_ENC_CTRL2_H264_SLICE_SIZE(0)
+		| H1_REG_ENC_CTRL2_CABAC_INIT_IDC(params->cabac_init_idc)
+		| H1_REG_ENC_CTRL2_H264_INTER4X4_MODE
+		| H1_REG_ENC_CTRL2_INTRA16X16_MODE(h264_intra16_favor[qp]);
+	if (params->flags & V4L2_H264_ENCODE_FLAG_ENTROPY_CABAC)
+		reg |= H1_REG_ENC_CTRL2_ENTROPY_CABAC;
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL2);
+
+	reg = H1_REG_ENC_CTRL3_MV_PENALTY_1P(h264_diff_mv_penalty[qp])
+		| H1_REG_ENC_CTRL3_MV_PENALTY_1_4P(h264_diff_mv_penalty[qp])
+		| H1_REG_ENC_CTRL3_MV_PENALTY_4P(h264_diff_mv_penalty4p[qp]);
+	if (mb_width * mb_height <= MAX_MB_COUNT_TO_DISABLE_SPLIT_MV)
+		reg |= H1_REG_ENC_CTRL3_MUTIMV_EN;
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL3);
+
+	scaler = max(1U, 200 / (mb_width + mb_height));
+	skip_penalty = min(255U, h264_skip_sad_penalty[qp] * scaler);
+	reg = H1_REG_ENC_CTRL5_MACROBLOCK_PENALTY(skip_penalty)
+		| H1_REG_ENC_CTRL5_COMPLETE_SLICES(0)
+		| H1_REG_ENC_CTRL5_INTER_MODE(h264_inter_favor[qp]);
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL5);
+
+	/*
+	 * The hardware only writes at 64-bit aligned addresses. If there's
+	 * a header generated with the CPU in the destination (encoded) buffer
+	 * then potentially up to 7 bytes will be overwritten by the hardware.
+	 * To preserve them, they are passed to the hardware via
+	 * H1_REG_STR_HDR_REM_MSB/LSB and the first free bit to be used by the hw
+	 * is passed via H1_REG_RLC_CTRL. This driver does not generate any headers,
+	 * so there's no bytes to pass to the hw and the hw-generated data
+	 * may be written at offset 0.
+	 */
+	vepu_write_relaxed(vpu, 0, H1_REG_STR_HDR_REM_MSB);
+	vepu_write_relaxed(vpu, 0, H1_REG_STR_HDR_REM_LSB);
+	vepu_write_relaxed(vpu, 0, H1_REG_RLC_CTRL);
+
+	/* Don't use MAD */
+	reg = H1_REG_MAD_CTRL_QP_ADJUST(0)
+		| H1_REG_MAD_CTRL_MAD_THRESHOLD(0)
+		| H1_REG_MAD_CTRL_QP_SUM_DIV2(0);
+	vepu_write_relaxed(vpu, reg, H1_REG_MAD_CTRL);
+
+	reg = H1_REG_QP_VAL_LUM(qp)
+		| H1_REG_QP_VAL_MAX(51)
+		| H1_REG_QP_VAL_MIN(0)
+		| H1_REG_QP_VAL_CHECKPOINT_DISTAN(0);
+	vepu_write_relaxed(vpu, reg, H1_REG_QP_VAL);
+
+	/* Don't use ROI */
+	vepu_write_relaxed(vpu, 0, H1_REG_FIRST_ROI_AREA);
+	vepu_write_relaxed(vpu, 0, H1_REG_SECOND_ROI_AREA);
+
+	/* Don't use stabilization */
+	vepu_write_relaxed(vpu, 0, H1_REG_STABILIZATION_OUTPUT);
+
+	/* Disable CIR */
+	vepu_write_relaxed(vpu, 0, H1_REG_CIR_INTRA_CTRL);
+
+	/* Disable intra area */
+	vepu_write_relaxed(vpu, 0, H1_REG_INTRA_AREA_CTRL);
+
+	reg = H1_REG_ZERO_MV_FAVOR_D2(ZERO_16x16_MV_FAVOR_DIV2)
+		| H1_REG_PENALTY_4X4MV(0);
+	vepu_write_relaxed(vpu, reg, H1_REG_QP_MV_MVC_CTRL);
+
+	for (i = 0; i < 128; i++)
+		dmv_qpel_penalty[i] = min(255, exp_golomb_signed(i));
+
+	/* See rk3399_vpu_hw_h264_enc.c mentioned in the copyright section */
+	for (i = 0; i < 128; i += 4) {
+		reg = H1_REG_DMV_4P_1P_PENALTY_BIT((h264_dmv_penalty[i] + 1) / 2, 3)
+			| H1_REG_DMV_4P_1P_PENALTY_BIT((h264_dmv_penalty[i + 1] + 1) / 2, 2)
+			| H1_REG_DMV_4P_1P_PENALTY_BIT((h264_dmv_penalty[i + 2] + 1) / 2, 1)
+			| H1_REG_DMV_4P_1P_PENALTY_BIT((h264_dmv_penalty[i + 3] + 1) / 2, 0);
+		vepu_write_relaxed(vpu, reg, H1_REG_DMV_4P_1P_PENALTY(i / 4));
+
+		reg = H1_REG_DMV_QPEL_PENALTY_BIT(dmv_qpel_penalty[i], 3)
+			| H1_REG_DMV_QPEL_PENALTY_BIT(dmv_qpel_penalty[i + 1], 2)
+			| H1_REG_DMV_QPEL_PENALTY_BIT(dmv_qpel_penalty[i + 2], 1)
+			| H1_REG_DMV_QPEL_PENALTY_BIT(dmv_qpel_penalty[i + 3], 0);
+		vepu_write_relaxed(vpu, reg, H1_REG_DMV_QPEL_PENALTY(i / 4));
+	}
+}
+
+static void hantro_h1_h264_enc_set_buffers(struct hantro_dev *vpu, struct hantro_ctx *ctx,
+					   struct v4l2_ctrl_h264_encode_params *params)
+{
+	const u32 src_addr_regs[] = { H1_REG_ADDR_IN_PLANE_0,
+				      H1_REG_ADDR_IN_PLANE_1,
+				      H1_REG_ADDR_IN_PLANE_2 };
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct v4l2_pix_format_mplane *src_fmt = &ctx->src_fmt;
+	size_t luma_size;
+	dma_addr_t dst_dma;
+	size_t dst_size;
+	int i;
+
+	src_buf = hantro_get_src_buf(ctx);
+	dst_buf = hantro_get_dst_buf(ctx);
+
+	luma_size = hantro_rounded_luma_size(ctx->src_fmt.width,
+					     ctx->src_fmt.height);
+
+	dst_dma = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);
+	dst_size = vb2_plane_size(&dst_buf->vb2_buf, 0);
+
+	/* Destination buffer */
+	vepu_write_relaxed(vpu, dst_dma, H1_REG_ADDR_OUTPUT_STREAM);
+	vepu_write_relaxed(vpu, dst_size, H1_REG_STR_BUF_LIMIT);
+
+	/* Auxiliary buffers */
+	memset(ctx->h264_enc.nal_table.cpu, 0, ctx->h264_enc.nal_table.size);
+	vepu_write_relaxed(vpu, ctx->h264_enc.nal_table.dma, H1_REG_ADDR_OUTPUT_CTRL);
+
+	vepu_write_relaxed(vpu, ctx->h264_enc.mv_buf.dma, H1_REG_ADDR_MV_OUT);
+
+	vepu_write_relaxed(vpu, ctx->h264_enc.cabac_ctx[params->cabac_init_idc].dma,
+			   H1_REG_ADDR_CABAC_TBL);
+
+	/* remember current frame timestamp */
+	ctx->h264_enc.reference_ts[ctx->h264_enc.reconstr_idx] = src_buf->vb2_buf.timestamp;
+
+	/* reference buffers */
+	if (params->slice_type) {
+		/* intra */
+		if (params->flags & V4L2_H264_ENCODE_FLAG_MARK_LONGTERM) {
+			ctx->h264_enc.ltr_idx = ctx->h264_enc.reconstr_idx;
+			vepu_write_relaxed(vpu, H1_REG_H264_MARK_LONGTRERM,
+					   H1_REG_H264_REFERENCE_CTRL);
+		}
+	} else {
+		/* inter */
+		if (params->reference_ts == ctx->h264_enc.reference_ts[ctx->h264_enc.last_idx]) {
+			i = ctx->h264_enc.last_idx;
+			vepu_write_relaxed(vpu, H1_REG_H264_MV_REF_IDX(0),
+					   H1_REG_H264_REFERENCE_IDX);
+		} else {
+			i = ctx->h264_enc.ltr_idx;
+			vepu_write_relaxed(vpu, H1_REG_H264_MV_REF_IDX(1),
+					   H1_REG_H264_REFERENCE_IDX);
+		}
+
+		vepu_write_relaxed(vpu, ctx->h264_enc.luma_internal[i].dma,
+				   H1_REG_ADDR_REF_LUMA);
+		vepu_write_relaxed(vpu, ctx->h264_enc.chroma_internal[i].dma,
+				   H1_REG_ADDR_REF_CHROMA);
+	}
+
+	/* Reconstruction buffers */
+	i = ctx->h264_enc.reconstr_idx;
+	vepu_write_relaxed(vpu, ctx->h264_enc.luma_internal[i].dma, H1_REG_ADDR_REC_LUMA);
+	vepu_write_relaxed(vpu, ctx->h264_enc.chroma_internal[i].dma, H1_REG_ADDR_REC_CHROMA);
+
+	/* Source buffer */
+	vepu_write_relaxed(vpu,
+			   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+			   src_buf->vb2_buf.planes[0].data_offset,
+			   src_addr_regs[0]);
+	vepu_write_relaxed(vpu,
+			   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+			   src_buf->vb2_buf.planes[0].data_offset +
+			   luma_size,
+			   src_addr_regs[1]);
+
+	for (i = 1; i < src_fmt->num_planes; ++i)
+		/* Multiplanes */
+		vepu_write_relaxed(vpu,
+				   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, i) +
+				   src_buf->vb2_buf.planes[i].data_offset,
+				   src_addr_regs[i]);
+}
+
+static int hantro_h1_validate_references(struct hantro_ctx *ctx,
+					 struct v4l2_ctrl_h264_encode_params *params)
+{
+	u64 last_ts, ltr_ts, ref_ts;
+
+	/* last_idx exists no matter what because we're a P frame */
+	last_ts = ctx->h264_enc.reference_ts[ctx->h264_enc.last_idx];
+	ref_ts = params->reference_ts;
+
+	/* last frame is OK as reference */
+	if (ref_ts == last_ts)
+		return 0;
+
+	/* if long term reference exists then maybe it is requested? */
+	if (ctx->h264_enc.ltr_idx >= 0) {
+		ltr_ts = ctx->h264_enc.reference_ts[ctx->h264_enc.ltr_idx];
+		/* long term reference is OK */
+		if (ref_ts == ltr_ts)
+			return 0;
+	}
+
+	return -EINVAL;
+}
+
+int hantro_h1_h264_enc_run(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	struct v4l2_ctrl_h264_encode_params *params;
+	struct v4l2_ctrl_h264_encode_rc *rc;
+	u32 reg;
+
+	hantro_start_prepare_run(ctx);
+
+	params = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_H264_ENCODE_PARAMS);
+	if (WARN_ON(!params))
+		return -EINVAL;
+
+	/* This driver only supports I and P slices */
+	if (params->slice_type != V4L2_H264_SLICE_TYPE_I &&
+	    params->slice_type != V4L2_H264_SLICE_TYPE_P)
+		return -EINVAL;
+
+	/* This driver only supports NALU type 5 for I slices */
+	if (params->slice_type == V4L2_H264_SLICE_TYPE_I &&
+	    params->nalu_type != V4L2_H264_NAL_CODED_SLICE_IDR_PIC)
+		return -EINVAL;
+
+	/* This driver only supports NALU type 1 for P slices */
+	if (params->slice_type == V4L2_H264_SLICE_TYPE_P &&
+	    params->nalu_type != V4L2_H264_NAL_CODED_SLICE_NON_IDR_PIC)
+		return -EINVAL;
+
+	rc = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_H264_ENCODE_RC);
+	if (WARN_ON(!rc))
+		return -EINVAL;
+
+	if (params->slice_type == V4L2_H264_SLICE_TYPE_P &&
+	    hantro_h1_validate_references(ctx, params))
+		return -EINVAL;
+
+	/* Program the hardware */
+	vepu_write_relaxed(vpu, H1_REG_ENC_CTRL_ENC_MODE_H264, H1_REG_ENC_CTRL);
+
+	hantro_h1_h264_enc_set_params(vpu, ctx, params, rc->qp);
+	hantro_h1_set_src_img_ctrl(vpu, ctx);
+	hantro_h1_h264_enc_set_buffers(vpu, ctx, params);
+
+	hantro_h1_set_color_conv(vpu, ctx);
+
+	reg = H1_REG_DEVICE_CTRL_SCALE_OUTPUT_SWAP8
+		| H1_REG_DEVICE_CTRL_SCALE_OUTPUT_SWAP16
+		| H1_REG_DEVICE_CTRL_SCALE_OUTPUT_SWAP32
+		| H1_REG_DEVICE_CTRL_MV_OUTPUT_SWAP8
+		| H1_REG_DEVICE_CTRL_MV_OUTPUT_SWAP16
+		| H1_REG_DEVICE_CTRL_MV_OUTPUT_SWAP32;
+	vepu_write(vpu, reg, H1_REG_DEVICE_CTRL);
+
+	/* Make sure that all registers are written at this point. */
+	hantro_h1_set_axi_ctrl(vpu, ctx);
+
+	/* Start the hardware */
+	reg = H1_REG_ENC_CTRL_TIMEOUT_EN
+		| H1_REG_ENC_CTRL_MV_WRITE
+		| H1_REG_ENC_CTRL_NAL_MODE_BIT
+		| H1_REG_ENC_CTRL_WIDTH(MB_WIDTH(ctx->src_fmt.width))
+		| H1_REG_ENC_CTRL_HEIGHT(MB_HEIGHT(ctx->src_fmt.height))
+		| H1_REG_ENC_CTRL_ENC_MODE_H264
+		| H1_REG_ENC_CTRL_EN_BIT;
+	if (params->slice_type) {
+		struct vb2_v4l2_buffer *dst_buf;
+
+		reg |= H1_REG_ENC_PIC_INTRA;
+		dst_buf = hantro_get_dst_buf(ctx);
+		dst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+	} else {
+		reg |= H1_REG_ENC_PIC_INTER;
+	}
+
+	/* Kick the watchdog and start encoding */
+	hantro_end_prepare_run(ctx);
+
+	/* Start the hardware */
+	vepu_write(vpu, reg, H1_REG_ENC_CTRL);
+
+	return 0;
+}
+
+static inline void hantro_h1_bump_reconstr_idx(struct hantro_ctx *ctx)
+{
+	ctx->h264_enc.reconstr_idx++;
+	ctx->h264_enc.reconstr_idx %= HANTRO_H264_NUM_INTERNAL_FRAMES;
+}
+
+void hantro_h1_h264_enc_done(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	struct vb2_v4l2_buffer *dst_buf;
+	u32 encoded_size;
+
+	dst_buf = hantro_get_dst_buf(ctx);
+
+	encoded_size = vepu_read(vpu, H1_REG_STR_BUF_LIMIT) / 8;
+
+	vb2_set_plane_payload(&dst_buf->vb2_buf, 0, encoded_size);
+
+	ctx->h264_enc.last_prev_idx = ctx->h264_enc.last_idx;
+	ctx->h264_enc.last_idx = ctx->h264_enc.reconstr_idx;
+
+	hantro_h1_bump_reconstr_idx(ctx);
+	if (ctx->h264_enc.reconstr_idx == ctx->h264_enc.ltr_idx)
+		hantro_h1_bump_reconstr_idx(ctx);
+}
diff --git a/drivers/media/platform/verisilicon/hantro_h1_jpeg_enc.c b/drivers/media/platform/verisilicon/hantro_h1_jpeg_enc.c
index 12d69503d..3ae5dace2 100644
--- a/drivers/media/platform/verisilicon/hantro_h1_jpeg_enc.c
+++ b/drivers/media/platform/verisilicon/hantro_h1_jpeg_enc.c
@@ -15,36 +15,18 @@
 
 #define H1_JPEG_QUANT_TABLE_COUNT 16
 
-static void hantro_h1_set_src_img_ctrl(struct hantro_dev *vpu,
-				       struct hantro_ctx *ctx)
-{
-	u32 overfill_r, overfill_b;
-	u32 reg;
-
-	/*
-	 * The format width and height are already macroblock aligned
-	 * by .vidioc_s_fmt_vid_cap_mplane() callback. Destination
-	 * format width and height can be further modified by
-	 * .vidioc_s_selection(), and the width is 4-aligned.
-	 */
-	overfill_r = ctx->src_fmt.width - ctx->dst_fmt.width;
-	overfill_b = ctx->src_fmt.height - ctx->dst_fmt.height;
-
-	reg = H1_REG_IN_IMG_CTRL_ROW_LEN(ctx->src_fmt.width)
-		| H1_REG_IN_IMG_CTRL_OVRFLR_D4(overfill_r / 4)
-		| H1_REG_IN_IMG_CTRL_OVRFLB(overfill_b)
-		| H1_REG_IN_IMG_CTRL_FMT(ctx->vpu_src_fmt->enc_fmt);
-	vepu_write_relaxed(vpu, reg, H1_REG_IN_IMG_CTRL);
-}
-
 static void hantro_h1_jpeg_enc_set_buffers(struct hantro_dev *vpu,
 					   struct hantro_ctx *ctx,
 					   struct vb2_buffer *src_buf,
 					   struct vb2_buffer *dst_buf)
 {
+	const u32 src_addr_regs[] = { H1_REG_ADDR_IN_PLANE_0,
+				      H1_REG_ADDR_IN_PLANE_1,
+				      H1_REG_ADDR_IN_PLANE_2 };
 	struct v4l2_pix_format_mplane *pix_fmt = &ctx->src_fmt;
-	dma_addr_t src[3];
+	size_t luma_size;
 	u32 size_left;
+	int i;
 
 	size_left = vb2_plane_size(dst_buf, 0) - ctx->vpu_dst_fmt->header_size;
 	if (WARN_ON(vb2_plane_size(dst_buf, 0) < ctx->vpu_dst_fmt->header_size))
@@ -57,23 +39,25 @@ static void hantro_h1_jpeg_enc_set_buffers(struct hantro_dev *vpu,
 			   H1_REG_ADDR_OUTPUT_STREAM);
 	vepu_write_relaxed(vpu, size_left, H1_REG_STR_BUF_LIMIT);
 
-	if (pix_fmt->num_planes == 1) {
-		src[0] = vb2_dma_contig_plane_dma_addr(src_buf, 0);
-		/* single plane formats we supported are all interlaced */
-		vepu_write_relaxed(vpu, src[0], H1_REG_ADDR_IN_PLANE_0);
-	} else if (pix_fmt->num_planes == 2) {
-		src[0] = vb2_dma_contig_plane_dma_addr(src_buf, 0);
-		src[1] = vb2_dma_contig_plane_dma_addr(src_buf, 1);
-		vepu_write_relaxed(vpu, src[0], H1_REG_ADDR_IN_PLANE_0);
-		vepu_write_relaxed(vpu, src[1], H1_REG_ADDR_IN_PLANE_1);
-	} else {
-		src[0] = vb2_dma_contig_plane_dma_addr(src_buf, 0);
-		src[1] = vb2_dma_contig_plane_dma_addr(src_buf, 1);
-		src[2] = vb2_dma_contig_plane_dma_addr(src_buf, 2);
-		vepu_write_relaxed(vpu, src[0], H1_REG_ADDR_IN_PLANE_0);
-		vepu_write_relaxed(vpu, src[1], H1_REG_ADDR_IN_PLANE_1);
-		vepu_write_relaxed(vpu, src[2], H1_REG_ADDR_IN_PLANE_2);
-	}
+	luma_size = hantro_rounded_luma_size(ctx->src_fmt.width,
+					     ctx->src_fmt.height);
+
+	vepu_write_relaxed(vpu,
+			   vb2_dma_contig_plane_dma_addr(src_buf, 0) +
+			   src_buf->planes[0].data_offset,
+			   src_addr_regs[0]);
+	vepu_write_relaxed(vpu,
+			   vb2_dma_contig_plane_dma_addr(src_buf, 0) +
+			   src_buf->planes[0].data_offset +
+			   luma_size,
+			   src_addr_regs[1]);
+
+	for (i = 1; i < pix_fmt->num_planes; ++i)
+		/* Multiplanes. */
+		vepu_write_relaxed(vpu,
+				   vb2_dma_contig_plane_dma_addr(src_buf, i) +
+				   src_buf->planes[i].data_offset,
+				   src_addr_regs[i]);
 }
 
 static void
@@ -132,15 +116,10 @@ int hantro_h1_jpeg_enc_run(struct hantro_ctx *ctx)
 	hantro_h1_jpeg_enc_set_qtable(vpu, jpeg_ctx.hw_luma_qtable,
 				      jpeg_ctx.hw_chroma_qtable);
 
-	reg = H1_REG_AXI_CTRL_OUTPUT_SWAP16
-		| H1_REG_AXI_CTRL_INPUT_SWAP16
-		| H1_REG_AXI_CTRL_BURST_LEN(16)
-		| H1_REG_AXI_CTRL_OUTPUT_SWAP32
-		| H1_REG_AXI_CTRL_INPUT_SWAP32
-		| H1_REG_AXI_CTRL_OUTPUT_SWAP8
-		| H1_REG_AXI_CTRL_INPUT_SWAP8;
+	hantro_h1_set_color_conv(vpu, ctx);
+
 	/* Make sure that all registers are written at this point. */
-	vepu_write(vpu, reg, H1_REG_AXI_CTRL);
+	hantro_h1_set_axi_ctrl(vpu, ctx);
 
 	reg = H1_REG_ENC_CTRL_WIDTH(MB_WIDTH(ctx->src_fmt.width))
 		| H1_REG_ENC_CTRL_HEIGHT(MB_HEIGHT(ctx->src_fmt.height))
diff --git a/drivers/media/platform/verisilicon/hantro_h1_regs.h b/drivers/media/platform/verisilicon/hantro_h1_regs.h
index 30e7e7b92..2a75c0afd 100644
--- a/drivers/media/platform/verisilicon/hantro_h1_regs.h
+++ b/drivers/media/platform/verisilicon/hantro_h1_regs.h
@@ -23,6 +23,15 @@
 #define     H1_REG_AXI_CTRL_INPUT_SWAP32		BIT(2)
 #define     H1_REG_AXI_CTRL_OUTPUT_SWAP8		BIT(1)
 #define     H1_REG_AXI_CTRL_INPUT_SWAP8			BIT(0)
+#define H1_REG_DEVICE_CTRL				0x00c
+#define     H1_REG_DEVICE_CTRL_SCALE_OUTPUT_SWAP8	BIT(27)
+#define     H1_REG_DEVICE_CTRL_SCALE_OUTPUT_SWAP16	BIT(26)
+#define     H1_REG_DEVICE_CTRL_SCALE_OUTPUT_SWAP32	BIT(25)
+#define     H1_REG_DEVICE_CTRL_MV_OUTPUT_SWAP8		BIT(24)
+#define     H1_REG_DEVICE_CTRL_MV_OUTPUT_SWAP16		BIT(23)
+#define     H1_REG_DEVICE_CTRL_MV_OUTPUT_SWAP32		BIT(22)
+#define     H1_REG_DEVICE_CTRL_INPUT_READ_1MB		BIT(21)
+#define     H1_REG_DEVICE_CTRL_AXI_DUAL_CHANNEL		BIT(20)
 #define H1_REG_ADDR_OUTPUT_STREAM			0x014
 #define H1_REG_ADDR_OUTPUT_CTRL				0x018
 #define H1_REG_ADDR_REF_LUMA				0x01c
@@ -34,9 +43,12 @@
 #define H1_REG_ADDR_IN_PLANE_2				0x034
 #define H1_REG_ENC_CTRL					0x038
 #define     H1_REG_ENC_CTRL_TIMEOUT_EN			BIT(31)
+#define     H1_REG_ENC_CTRL_MV_WRITE			BIT(30)
 #define     H1_REG_ENC_CTRL_NAL_MODE_BIT		BIT(29)
 #define     H1_REG_ENC_CTRL_WIDTH(w)			((w) << 19)
 #define     H1_REG_ENC_CTRL_HEIGHT(h)			((h) << 10)
+#define     H1_REG_ENC_REC_WRITE_BUFFER_4MB		BIT(7)
+#define     H1_REG_ENC_REC_WRITE_DISABLE		BIT(6)
 #define     H1_REG_ENC_PIC_INTER			(0x0 << 3)
 #define     H1_REG_ENC_PIC_INTRA			(0x1 << 3)
 #define     H1_REG_ENC_PIC_MVCINTER			(0x2 << 3)
@@ -49,6 +61,7 @@
 #define     H1_REG_IN_IMG_CTRL_OVRFLR_D4(x)		((x) << 10)
 #define     H1_REG_IN_IMG_CTRL_OVRFLB(x)		((x) << 6)
 #define     H1_REG_IN_IMG_CTRL_FMT(x)			((x) << 2)
+#define     H1_REG_IN_IMG_CTRL_ROTATION(x)		((x))
 #define H1_REG_ENC_CTRL0				0x040
 #define    H1_REG_ENC_CTRL0_INIT_QP(x)			((x) << 26)
 #define    H1_REG_ENC_CTRL0_SLICE_ALPHA(x)		((x) << 22)
@@ -62,12 +75,13 @@
 #define    H1_REG_ENC_CTRL1_INTRA_PRED_MODE(x)		((x) << 16)
 #define    H1_REG_ENC_CTRL1_FRAME_NUM(x)		((x))
 #define H1_REG_ENC_CTRL2				0x048
-#define    H1_REG_ENC_CTRL2_DEBLOCKING_FILETER_MODE(x)	((x) << 30)
+#define    H1_REG_ENC_CTRL2_DEBLOCKING_FILTER_MODE(x)	((x) << 30)
 #define    H1_REG_ENC_CTRL2_H264_SLICE_SIZE(x)		((x) << 23)
 #define    H1_REG_ENC_CTRL2_DISABLE_QUARTER_PIXMV	BIT(22)
 #define    H1_REG_ENC_CTRL2_TRANS8X8_MODE_EN		BIT(21)
 #define    H1_REG_ENC_CTRL2_CABAC_INIT_IDC(x)		((x) << 19)
-#define    H1_REG_ENC_CTRL2_ENTROPY_CODING_MODE		BIT(18)
+#define    H1_REG_ENC_CTRL2_VP8_BOOLENC_ENABLE		BIT(18)
+#define    H1_REG_ENC_CTRL2_ENTROPY_CABAC		BIT(18)
 #define    H1_REG_ENC_CTRL2_H264_INTER4X4_MODE		BIT(17)
 #define    H1_REG_ENC_CTRL2_H264_STREAM_MODE		BIT(16)
 #define    H1_REG_ENC_CTRL2_INTRA16X16_MODE(x)		((x))
@@ -89,7 +103,7 @@
 #define H1_REG_STR_BUF_LIMIT				0x060
 #define H1_REG_MAD_CTRL					0x064
 #define    H1_REG_MAD_CTRL_QP_ADJUST(x)			((x) << 28)
-#define    H1_REG_MAD_CTRL_MAD_THREDHOLD(x)		((x) << 22)
+#define    H1_REG_MAD_CTRL_MAD_THRESHOLD(x)		((x) << 22)
 #define    H1_REG_MAD_CTRL_QP_SUM_DIV2(x)		((x))
 #define H1_REG_ADDR_VP8_PROB_CNT			0x068
 #define H1_REG_QP_VAL					0x06c
@@ -98,15 +112,56 @@
 #define    H1_REG_QP_VAL_MIN(x)				((x) << 14)
 #define    H1_REG_QP_VAL_CHECKPOINT_DISTAN(x)		((x))
 #define H1_REG_VP8_QP_VAL(i)				(0x06c + ((i) * 0x4))
+#define H1_REG_VP8_SEG0_QUANT_DC_Y1			0x06c
+#define     H1_REG_VP8_SEG0_RND_DC_Y1(x)		(((x) & 0xff) << 23)
+#define     H1_REG_VP8_SEG0_ZBIN_DC_Y1(x)		(((x) & 0x1ff) << 14)
+#define     H1_REG_VP8_SEG0_QUT_DC_Y1(x)		(((x) & 0x3fff) << 0)
 #define H1_REG_CHECKPOINT(i)				(0x070 + ((i) * 0x4))
 #define     H1_REG_CHECKPOINT_CHECK0(x)			(((x) & 0xffff))
 #define     H1_REG_CHECKPOINT_CHECK1(x)			(((x) & 0xffff) << 16)
 #define     H1_REG_CHECKPOINT_RESULT(x)			((((x) >> (16 - 16 \
 							 * (i & 1))) & 0xffff) \
 							 * 32)
+#define H1_REG_VP8_SEG0_QUANT_AC_Y1			0x070
+#define     H1_REG_VP8_SEG0_RND_AC_Y1(x)		(((x) & 0xff) << 23)
+#define     H1_REG_VP8_SEG0_ZBIN_AC_Y1(x)		(((x) & 0x1ff) << 14)
+#define     H1_REG_VP8_SEG0_QUT_AC_Y1(x)		(((x) & 0x3fff) << 0)
+#define H1_REG_VP8_SEG0_QUANT_DC_Y2			0x074
+#define     H1_REG_VP8_SEG0_RND_DC_Y2(x)		(((x) & 0xff) << 23)
+#define     H1_REG_VP8_SEG0_ZBIN_DC_Y2(x)		(((x) & 0x1ff) << 14)
+#define     H1_REG_VP8_SEG0_QUT_DC_Y2(x)		(((x) & 0x3fff) << 0)
+#define H1_REG_VP8_SEG0_QUANT_AC_Y2			0x078
+#define     H1_REG_VP8_SEG0_RND_AC_Y2(x)		(((x) & 0xff) << 23)
+#define     H1_REG_VP8_SEG0_ZBIN_AC_Y2(x)		(((x) & 0x1ff) << 14)
+#define     H1_REG_VP8_SEG0_QUT_AC_Y2(x)		(((x) & 0x3fff) << 0)
+#define H1_REG_VP8_SEG0_QUANT_DC_CHR			0x07c
+#define     H1_REG_VP8_SEG0_RND_DC_CHR(x)		(((x) & 0xff) << 23)
+#define     H1_REG_VP8_SEG0_ZBIN_DC_CHR(x)		(((x) & 0x1ff) << 14)
+#define     H1_REG_VP8_SEG0_QUT_DC_CHR(x)		(((x) & 0x3fff) << 0)
+#define H1_REG_VP8_SEG0_QUANT_AC_CHR			0x080
+#define     H1_REG_VP8_SEG0_RND_AC_CHR(x)		(((x) & 0xff) << 23)
+#define     H1_REG_VP8_SEG0_ZBIN_AC_CHR(x)		(((x) & 0x1ff) << 14)
+#define     H1_REG_VP8_SEG0_QUT_AC_CHR(x)		(((x) & 0x3fff) << 0)
 #define H1_REG_CHKPT_WORD_ERR(i)			(0x084 + ((i) * 0x4))
 #define     H1_REG_CHKPT_WORD_ERR_CHK0(x)		(((x) & 0xffff))
 #define     H1_REG_CHKPT_WORD_ERR_CHK1(x)		(((x) & 0xffff) << 16)
+#define H1_REG_VP8_SEG0_QUANT_DQUT			0x084
+#define     H1_REG_VP8_MV_REF_IDX1(x)			(((x) & 0x03) << 26)
+#define     H1_REG_VP8_SEG0_DQUT_DC_Y2(x)		(((x) & 0x1ff) << 17)
+#define     H1_REG_VP8_SEG0_DQUT_AC_Y1(x)		(((x) & 0x1ff) << 8)
+#define     H1_REG_VP8_SEG0_DQUT_DC_Y1(x)		(((x) & 0xff) << 0)
+#define H1_REG_H264_REFERENCE_IDX			0x084
+#define     H1_REG_H264_MV_REF_IDX(x)			(((x) & 0x03) << 26)
+#define H1_REG_VP8_SEG0_QUANT_DQUT_1			0x088
+#define     H1_REG_VP8_SEGMENT_MAP_UPDATE		BIT(30)
+#define     H1_REG_VP8_SEGMENT_EN			BIT(29)
+#define     H1_REG_VP8_MV_REF_IDX2_EN			BIT(28)
+#define     H1_REG_VP8_MV_REF_IDX2(x)			(((x) & 0x03) << 26)
+#define     H1_REG_VP8_SEG0_DQUT_AC_CHR(x)		(((x) & 0x1ff) << 17)
+#define     H1_REG_VP8_SEG0_DQUT_DC_CHR(x)		(((x) & 0xff) << 9)
+#define     H1_REG_VP8_SEG0_DQUT_AC_Y2(x)		(((x) & 0x1ff) << 0)
+#define H1_REG_H264_REFERENCE_CTRL			0x088
+#define     H1_REG_H264_MARK_LONGTRERM			BIT(26)
 #define H1_REG_VP8_BOOL_ENC				0x08c
 #define H1_REG_CHKPT_DELTA_QP				0x090
 #define     H1_REG_CHKPT_DELTA_QP_CHK0(x)		(((x) & 0x0f) << 0)
@@ -116,7 +171,13 @@
 #define     H1_REG_CHKPT_DELTA_QP_CHK4(x)		(((x) & 0x0f) << 16)
 #define     H1_REG_CHKPT_DELTA_QP_CHK5(x)		(((x) & 0x0f) << 20)
 #define     H1_REG_CHKPT_DELTA_QP_CHK6(x)		(((x) & 0x0f) << 24)
-#define H1_REG_VP8_CTRL0				0x090
+#define H1_REG_VP8_PENALTY_FILTER			0x090
+#define     H1_REG_VP8_ZERO_MV_PENALTY_FOR_REF2(x)	(((x) & 0xff) << 24)
+#define     H1_REG_VP8_FILTER_SHARPNESS(x)		(((x) & 0x07) << 21)
+#define     H1_REG_VP8_FILTER_LEVEL(x)		(((x) & 0x3f) << 15)
+#define     H1_REG_VP8_DCT_PARTITION_CNT(x)		(((x) & 0x03) << 13)
+#define     H1_REG_VP8_BOOL_ENC_VALUE_BITS(x)		(((x) & 0x1f) << 8)
+#define     H1_REG_VP8_BOOL_ENC_RANGE(x)		(((x) & 0xff) << 0)
 #define H1_REG_RLC_CTRL					0x094
 #define     H1_REG_RLC_CTRL_STR_OFFS_SHIFT		23
 #define     H1_REG_RLC_CTRL_STR_OFFS_MASK		(0x3f << 23)
@@ -130,17 +191,32 @@
 #define H1_REG_STABILIZATION_OUTPUT			0x0A0
 #define H1_REG_ADDR_CABAC_TBL				0x0cc
 #define H1_REG_ADDR_MV_OUT				0x0d0
-#define H1_REG_RGB_YUV_COEFF(i)				(0x0d4 + ((i) * 0x4))
-#define H1_REG_RGB_MASK_MSB				0x0dc
+#define H1_REG_RGB_YUV_COEFF_AB				0x0d4
+#define   H1_REG_RGB_YUV_COEFF_A(x)			(((x) & 0xffff) << 0)
+#define   H1_REG_RGB_YUV_COEFF_B(x)			(((x) & 0xffff) << 16)
+#define H1_REG_RGB_YUV_COEFF_CE				0x0d8
+#define   H1_REG_RGB_YUV_COEFF_C(x)			(((x) & 0xffff) << 0)
+#define   H1_REG_RGB_YUV_COEFF_E(x)			(((x) & 0xffff) << 16)
+#define H1_REG_RGB_YUV_COEFF_F_MASK			0x0dc
+#define   H1_REG_RGB_YUV_COEFF_F(x)			(((x) & 0xffff) << 0)
+#define   H1_REG_RGB_YUV_R_MASK_MSB(x)			(((x) & 0x1f) << 16)
+#define   H1_REG_RGB_YUV_G_MASK_MSB(x)			(((x) & 0x1f) << 21)
+#define   H1_REG_RGB_YUV_B_MASK_MSB(x)			(((x) & 0x1f) << 26)
 #define H1_REG_INTRA_AREA_CTRL				0x0e0
 #define H1_REG_CIR_INTRA_CTRL				0x0e4
 #define H1_REG_INTRA_SLICE_BITMAP(i)			(0x0e8 + ((i) * 0x4))
 #define H1_REG_ADDR_VP8_DCT_PART(i)			(0x0e8 + ((i) * 0x4))
 #define H1_REG_FIRST_ROI_AREA				0x0f0
 #define H1_REG_SECOND_ROI_AREA				0x0f4
-#define H1_REG_MVC_CTRL					0x0f8
-#define	H1_REG_MVC_CTRL_MV16X16_FAVOR(x)		((x) << 28)
-#define H1_REG_VP8_INTRA_PENALTY(i)			(0x100 + ((i) * 0x4))
+#define H1_REG_QP_MV_MVC_CTRL				0x0f8
+#define     H1_REG_ZERO_MV_FAVOR_D2(x)			(((x) & 0xf) << 28)
+#define     H1_REG_PENALTY_4X4MV(x)			(((x) & 0x1ff) << 19)
+#define H1_REG_VP8_INTRA_16X16_PENALTY(i)		(0x100 + ((i) * 0x4))
+#define     H1_REG_VP8_INTRA_16X16_PENALTY_0(x)	(((x) & 0x3ff) << 0)
+#define     HI_REG_VP8_INTRA_16X16_PENALTY_1(x)	(((x) & 0x3ff) << 10)
+#define H1_REG_VP8_INTRA_4X4_PENALTY(i)			(0x108 + ((i) * 0x4))
+#define     H1_REG_VP8_INTRA_4X4_PENALTY_0(x)		(((x) & 0x3ff) << 0)
+#define     HI_REG_VP8_INTRA_4X4_PENALTY_1(x)		(((x) & 0x3ff) << 10)
 #define H1_REG_ADDR_VP8_SEG_MAP				0x11c
 #define H1_REG_VP8_SEG_QP(i)				(0x120 + ((i) * 0x4))
 #define H1_REG_DMV_4P_1P_PENALTY(i)			(0x180 + ((i) * 0x4))
@@ -149,6 +225,15 @@
 #define     H1_REG_DMV_QPEL_PENALTY_BIT(x, i)		((x) << (i) * 8)
 #define H1_REG_VP8_CTRL1				0x280
 #define H1_REG_VP8_BIT_COST_GOLDEN			0x284
-#define H1_REG_VP8_LOOP_FLT_DELTA(i)			(0x288 + ((i) * 0x4))
+#define H1_REG_VP8_LOOP_FILTER_REF_DELTA		0x288
+#define     H1_REG_VP8_LF_REF_DELTA_ALT_REF(x)		(((x) & 0x7f) << 21)
+#define     H1_REG_VP8_LF_REF_DELTA_GOLDEN(x)		(((x) & 0x7f) << 14)
+#define     H1_REG_VP8_LF_REF_DELTA_LAST_REF(x)		(((x) & 0x7f) << 7)
+#define     H1_REG_VP8_LF_REF_DELTA_INTRA_MB(x)		(((x) & 0x7f) << 0)
+#define H1_REG_VP8_LOOP_FILTER_MODE_DELTA		0x28c
+#define     H1_REG_VP8_LF_MODE_DELTA_SPLITMV(x)		(((x) & 0x7f) << 21)
+#define     H1_REG_VP8_LF_MODE_DELTA_NEWMV(x)		(((x) & 0x7f) << 14)
+#define     H1_REG_VP8_LF_MODE_DELTA_ZEROMV(x)		(((x) & 0x7f) << 7)
+#define     H1_REG_VP8_LF_MODE_DELTA_BPRED(x)		(((x) & 0x7f) << 0)
 
 #endif /* HANTRO_H1_REGS_H_ */
diff --git a/drivers/media/platform/verisilicon/hantro_h1_vp8_enc.c b/drivers/media/platform/verisilicon/hantro_h1_vp8_enc.c
new file mode 100644
index 000000000..5161f6412
--- /dev/null
+++ b/drivers/media/platform/verisilicon/hantro_h1_vp8_enc.c
@@ -0,0 +1,1609 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics SA 2023
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ *
+ * Copyright (C) 2023 Collabora Ltd.
+ *	Andrzej Pietrasiewicz <andrzej.p@collabora.com>
+ *
+ * This work is derived from:
+ *
+ * https://chromium.googlesource.com/chromiumos/third_party/kernel/+/refs/heads/chromeos-5.10/
+ * drivers/media/platform/verisilicon/rk3399_vpu_hw_vp8_enc.c
+ *
+ * which is:
+ *
+ * Rockchip VPU codec driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd.
+ *	Alpha Lin <Alpha.Lin@rock-chips.com>
+ *
+ * Substantial portions are based on MIT-licensed code
+ *
+ * https://github.com/rockchip-linux/mpp/blob/develop/mpp/hal/vpu/vp8e/hal_vp8e_entropy.{c|h}
+ * https://github.com/rockchip-linux/mpp/blob/develop/mpp/hal/vpu/vp8e/hal_vp8e_table.{c|h}
+ *
+ * which is:
+ *
+ * Copyright (c) 2017 Rockchip Electronics Co., Ltd.
+ *
+ */
+#include <linux/minmax.h>
+
+#include "hantro.h"
+#include "hantro_hw.h"
+#include "hantro_h1_regs.h"
+
+/* threshold of MBs count to disable quarter pixel mv for encode speed */
+#define MAX_MB_COUNT_TO_DISABLE_QUARTER_PIXEL_MV	3600
+
+/* threshold of MBs count to disable multi mv in one macro block */
+#define MAX_MB_COUNT_TO_DISABLE_SPLIT_MV		1584
+
+#define QINDEX_RANGE 128
+#define VP8_PROB_COUNT_MV_OFFSET 222
+
+#define MODE_DELTA_BPRED	0
+#define MODE_DELTA_ZEROMV	1
+#define MODE_DELTA_NEWMV	2
+#define MODE_DELTA_SPLITMV	3
+
+#define REF_DELTA_INTRA_MB	0
+#define REF_DELTA_LAST_REF	1
+#define REF_DELTA_GOLDEN	2
+#define REF_DELTA_ALT_REF	3
+
+/* experimentally fitted, 24.893*exp(0.02545*qp) */
+static const s32 split_penalty[QINDEX_RANGE] = {
+	24, 25, 26, 26, 27, 28, 29, 29,
+	30, 31, 32, 32, 33, 34, 35, 36,
+	37, 38, 39, 40, 41, 42, 43, 44,
+	45, 47, 48, 49, 50, 52, 53, 54,
+	56, 57, 59, 60, 62, 63, 65, 67,
+	68, 70, 72, 74, 76, 78, 80, 82,
+	84, 86, 88, 91, 93, 95, 98, 100,
+	103, 106, 108, 111, 114, 117, 120, 123,
+	126, 130, 133, 136, 140, 144, 147, 151,
+	155, 159, 163, 167, 172, 176, 181, 185,
+	190, 195, 200, 205, 211, 216, 222, 227,
+	233, 239, 245, 252, 258, 265, 272, 279,
+	286, 293, 301, 309, 317, 325, 333, 342,
+	351, 360, 369, 379, 388, 398, 409, 419,
+	430, 441, 453, 464, 476, 488, 501, 514,
+	527, 541, 555, 569, 584, 599, 614, 630
+};
+
+static const int dc_q_lookup[QINDEX_RANGE] = {
+	4,   5,   6,   7,   8,   9,   10,  10,  11,  12,
+	13,  14,  15,  16,  17,  17,  18,  19,  20,  20,
+	21,  21,  22,  22,  23,  23,  24,  25,  25,  26,
+	27,  28,  29,  30,  31,  32,  33,  34,  35,  36,
+	37,  37,  38,  39,  40,  41,  42,  43,  44,  45,
+	46,  46,  47,  48,  49,  50,  51,  52,  53,  54,
+	55,  56,  57,  58,  59,  60,  61,  62,  63,  64,
+	65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
+	75,  76,  76,  77,  78,  79,  80,  81,  82,  83,
+	84,  85,  86,  87,  88,  89,  91,  93,  95,  96,
+	98,  100, 101, 102, 104, 106, 108, 110, 112, 114,
+	116, 118, 122, 124, 126, 128, 130, 132, 134, 136,
+	138, 140, 143, 145, 148, 151, 154, 157
+};
+
+static const int ac_q_lookup[QINDEX_RANGE] = {
+	4,   5,   6,   7,   8,   9,   10,  11,  12,  13,
+	14,  15,  16,  17,  18,  19,  20,  21,  22,  23,
+	24,  25,  26,  27,  28,  29,  30,  31,  32,  33,
+	34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
+	44,  45,  46,  47,  48,  49,  50,  51,  52,  53,
+	54,  55,  56,  57,  58,  60,  62,  64,  66,  68,
+	70,  72,  74,  76,  78,  80,  82,  84,  86,  88,
+	90,  92,  94,  96,  98,  100, 102, 104, 106, 108,
+	110, 112, 114, 116, 119, 122, 125, 128, 131, 134,
+	137, 140, 143, 146, 149, 152, 155, 158, 161, 164,
+	167, 170, 173, 177, 181, 185, 189, 193, 197, 201,
+	205, 209, 213, 217, 221, 225, 229, 234, 239, 245,
+	249, 254, 259, 264, 269, 274, 279, 284
+};
+
+static const s32 qrounding_factors[QINDEX_RANGE] = {
+	56, 56, 56, 56, 56, 56, 56, 56, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48
+};
+
+static const s32 qzbin_factors[QINDEX_RANGE] = {
+	64, 64, 64, 64, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80
+};
+
+/* Intra 16x16 mode tree penalty values */
+static s32 intra_16_tree_penalty[] = {
+	305, 841, 914, 1082
+};
+
+/* Intra 4x4 mode tree penalty values */
+static s32 intra_4_tree_penalty[] = {
+	280, 622, 832, 1177, 1240, 1341, 1085, 1259, 1357, 1495
+};
+
+
+static int32_t const offset_tbl[] = {
+	-1, -1, -1,  0,  1,  2, -1,  3,  4, -1,  5,  6, -1,  7,  8, -1,
+	9, 10, -1, 11, 12, 13, 14, 15, -1, 16, 17, -1, 18, 19, -1, 20,
+	21, -1, 22, 23, -1, 24, 25, -1, 26, 27, 28, 29, 30, -1, 31, 32,
+	-1, 33, 34, -1, 35, 36, -1, 37, 38, -1, 39, 40, -1, 41, 42, 43,
+	44, 45, -1, 46, 47, -1, 48, 49, -1, 50, 51, -1, 52, 53, -1, 54,
+	55, -1, 56, 57, -1, -1, -1, 58, 59, 60, 61, 62, 63, 64, 65, 66,
+	67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
+	83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
+	99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
+	115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
+	131, 132, 133, 134, 135, 136, 137, 138, -1, -1, -1, 139, 140, 141, 142, 143,
+	144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
+	192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
+	208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219
+};
+
+/* ~round((2*(2+exp((x+22)/39)) + (2+exp((x+15)/32)))/3) */
+static s32 weight[QINDEX_RANGE] = {
+	4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
+	4,  4,  4,  4,  4,  5,  5,  5,  5,  5,
+	5,  5,  5,  5,  5,  5,  5,  6,  6,  6,
+	6,  6,  6,  6,  6,  6,  6,  7,  7,  7,
+	7,  7,  7,  7,  7,  8,  8,  8,  8,  8,
+	8,  8,  9,  9,  9,  9,  9, 10, 10, 10,
+	10, 11, 11, 11, 12, 12, 13, 13, 13, 13,
+	14, 14, 14, 14, 15, 15, 15, 16, 16, 17,
+	17, 18, 18, 19, 19, 20, 20, 20, 21, 22,
+	23, 23, 24, 24, 25, 25, 26, 27, 28, 28,
+	29, 30, 31, 32, 32, 33, 34, 35, 36, 37,
+	38, 39, 40, 41, 42, 44, 44, 46, 47, 48,
+	50, 51, 52, 54, 55, 57, 58, 61
+};
+
+struct tree {
+	s32 value;       /* Bits describe the bool tree  */
+	s32 number;      /* Number, valid bit count in above tree */
+	s32 index[9];    /* Probability table index */
+};
+
+/* Motion vector tree */
+static struct tree mv_tree[] = {
+	{ 0, 3, { 0, 1, 2 } },        /* mv_0 000 */
+	{ 1, 3, { 0, 1, 2 } },        /* mv_1 001 */
+	{ 2, 3, { 0, 1, 3 } },        /* mv_2 010 */
+	{ 3, 3, { 0, 1, 3 } },        /* mv_3 011 */
+	{ 4, 3, { 0, 4, 5 } },        /* mv_4 100 */
+	{ 5, 3, { 0, 4, 5 } },        /* mv_5 101 */
+	{ 6, 3, { 0, 4, 6 } },        /* mv_6 110 */
+	{ 7, 3, { 0, 4, 6 } },        /* mv_7 111 */
+};
+
+/* If probability being zero is p, then average number of bits used to encode 0
+ * is log2(1/p), to encode 1 is log2(1/(1-p)).
+ *
+ * For example, if the probability of being zero is 0.5
+ * bin = 0 -> average bits used is log2(1/0.5)      = 1 bits/bin
+ * bin = 1 -> average bits used is log2(1/(1 - 0.5) = 1 bits/bin
+ *
+ * For example, if the probability of being zero is 0.95
+ * bin = 0 -> average bits used is log2(1/0.95)      = 0.074 bits/bin
+ * bin = 1 -> average bits used is log2(1/(1 - 0.95) = 4.321 bits/bin
+ *
+ * The cost[p] is average number of bits used to encode 0 if the probability is
+ * p / 256, scaled by a magic number 256,
+ * i.e., cost[p] = round(log2(256 / p) * 256).
+ */
+static const s32 vp8_prob_cost[] = {
+	2048, 2048, 1792, 1642, 1536, 1454, 1386, 1329, 1280, 1236,
+	1198, 1162, 1130, 1101, 1073, 1048, 1024, 1002,  980,  961,
+	942,  924,  906,  890,  874,  859,  845,  831,  817,  804,
+	792,  780,  768,  757,  746,  735,  724,  714,  705,  695,
+	686,  676,  668,  659,  650,  642,  634,  626,  618,  611,
+	603,  596,  589,  582,  575,  568,  561,  555,  548,  542,
+	536,  530,  524,  518,  512,  506,  501,  495,  490,  484,
+	479,  474,  468,  463,  458,  453,  449,  444,  439,  434,
+	430,  425,  420,  416,  412,  407,  403,  399,  394,  390,
+	386,  382,  378,  374,  370,  366,  362,  358,  355,  351,
+	347,  343,  340,  336,  333,  329,  326,  322,  319,  315,
+	312,  309,  305,  302,  299,  296,  292,  289,  286,  283,
+	280,  277,  274,  271,  268,  265,  262,  259,  256,  253,
+	250,  247,  245,  242,  239,  236,  234,  231,  228,  226,
+	223,  220,  218,  215,  212,  210,  207,  205,  202,  200,
+	197,  195,  193,  190,  188,  185,  183,  181,  178,  176,
+	174,  171,  169,  167,  164,  162,  160,  158,  156,  153,
+	151,  149,  147,  145,  143,  140,  138,  136,  134,  132,
+	130,  128,  126,  124,  122,  120,  118,  116,  114,  112,
+	110,  108,  106,  104,  102,  101,   99,   97,   95,   93,
+	91,   89,   87,   86,   84,   82,   80,   78,   77,   75,
+	73,   71,   70,   68,   66,   64,   63,   61,   59,   58,
+	56,   54,   53,   51,   49,   48,   46,   44,   43,   41,
+	40,   38,   36,   35,   33,   32,   30,   28,   27,   25,
+	24,   22,   21,   19,   18,   16,   15,   13,   12,   10,
+	9,    7,    6,    4,    3,    1
+};
+
+/* Approximate bit cost of bin at given probability prob */
+#define COST_BOOL(prob, bin)	vp8_prob_cost[(bin) ? 255 - (prob) : (prob)]
+
+static uint32_t const coeff_update_prob[4][8][3][11] = {
+	{
+		{
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},
+			{249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},
+			{234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
+			{250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	}, {
+		{
+			{217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
+			{234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255},
+		}, {
+			{255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	}, {
+		{
+			{186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},
+			{234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},
+			{251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255},
+		}, {
+			{255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	}, {
+		{
+			{248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},
+			{248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},
+			{248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	},
+};
+
+static uint32_t const mv_update_prob[2][19] = {
+	{
+		237, 246, 253, 253, 254, 254, 254, 254, 254, 254,
+		254, 254, 254, 254, 250, 250, 252, 254, 254
+	}, {
+		231, 243, 245, 253, 254, 254, 254, 254, 254, 254,
+		254, 254, 254, 254, 251, 251, 254, 254, 254
+	}
+};
+
+static uint8_t const default_prob_skip_false[128] = {
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	251, 248, 244, 240, 236, 232, 229, 225,
+	221, 217, 213, 208, 204, 199, 194, 190,
+	187, 183, 179, 175, 172, 168, 164, 160,
+	157, 153, 149, 145, 142, 138, 134, 130,
+	127, 124, 120, 117, 114, 110, 107, 104,
+	101, 98,  95,  92,  89,  86,  83, 80,
+	77,  74,  71,  68,  65,  62,  59, 56,
+	53,  50,  47,  44,  41,  38,  35, 32,
+	30,  28,  26,  24,  22,  20,  18, 16,
+};
+
+static int32_t const y_mode_prob[4] = {
+	112, 86, 140, 37
+};
+
+static int32_t const uv_mode_prob[3] = {
+	162, 101, 204
+};
+
+static uint32_t const default_prob_coeff[4][8][3][11] = {
+	{
+		{
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
+			{189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
+			{106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128},
+		}, {
+			{  1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
+			{181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
+			{ 78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128},
+		}, {
+			{  1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
+			{184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
+			{ 77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
+			{170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
+			{ 37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128},
+		}, {
+			{  1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
+			{207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
+			{102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
+			{177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
+			{ 80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128},
+		}, {
+			{  1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+		},
+	}, {
+		{
+			{198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
+			{131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
+			{ 68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128},
+		}, {
+			{  1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
+			{184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
+			{ 81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128},
+		}, {
+			{  1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
+			{ 99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
+			{ 23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128},
+		}, {
+			{  1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
+			{109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
+			{ 44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128},
+		}, {
+			{  1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
+			{ 94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
+			{ 22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128},
+		}, {
+			{  1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
+			{124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
+			{ 35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128},
+		}, {
+			{  1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
+			{121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
+			{ 45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128},
+		}, {
+			{  1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
+			{203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
+			{137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128},
+		},
+	}, {
+		{
+			{253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
+			{175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
+			{ 73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128},
+		}, {
+			{  1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
+			{239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
+			{155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128},
+		}, {
+			{  1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
+			{201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
+			{ 69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128},
+		}, {
+			{  1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
+			{223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
+			{141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128},
+		}, {
+			{  1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
+			{190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
+			{149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
+			{213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
+			{ 55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+		},
+	}, {
+		{
+			{202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
+			{126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
+			{ 61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128},
+		}, {
+			{  1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
+			{166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
+			{ 39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128},
+		}, {
+			{  1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
+			{124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
+			{ 24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128},
+		}, {
+			{  1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
+			{149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
+			{ 28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128},
+		}, {
+			{  1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
+			{123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
+			{ 20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128},
+		}, {
+			{  1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
+			{168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
+			{ 47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128},
+		}, {
+			{  1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
+			{141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
+			{ 42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128},
+		}, {
+			{  1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		},
+	}
+};
+
+static uint32_t const default_prob_mv[2][19] = {
+	{
+		162, 128, 225, 146, 172, 147, 214,  39, 156, 128,
+		129, 132,  75, 145, 178, 206, 239, 254, 254,
+	}, {
+		164, 128, 204, 170, 119, 235, 140, 230, 228, 128,
+		130, 130,  74, 148, 180, 203, 236, 254, 254,
+	},
+};
+
+struct hantro_vp8_enc_ctrl_buf {
+	u32 hw_hdr_size;
+	u32 dct_size;
+	u8 reserved[1016];
+};
+
+static inline bool is_intra(struct hantro_ctx *ctx)
+{
+	return ctx->vp8_enc.is_intra;
+}
+
+static inline size_t frame_tag_size(struct hantro_ctx *ctx)
+{
+	return is_intra(ctx) ? 10 : 3;
+}
+
+static void hantro_h1_vp8_enc_write_coeff_prob(struct hantro_ctx *ctx)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+
+	int i, j, k, l;
+	uint32_t prob, new, old;
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 8; j++) {
+			for (k = 0; k < 3; k++) {
+				for (l = 0; l < 11; l++) {
+					prob = coeff_update_prob[i][j][k][l];
+
+					old = entropy->coeff_prob_old[i][j][k][l];
+					new = entropy->coeff_prob[i][j][k][l];
+
+					if (new == old) {
+						hantro_boolenc_write_bool(e, prob, 0);
+					} else {
+						hantro_boolenc_write_bool(e, prob, 1);
+						hantro_boolenc_write_lit(e, new, 8);
+					}
+				}
+			}
+		}
+	}
+}
+
+static void hantro_h1_vp8_enc_write_mv_prob(struct hantro_ctx *ctx)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+
+	int i, j;
+	uint32_t prob, new, old;
+
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 19; j++) {
+			prob = mv_update_prob[i][j];
+			old = entropy->mv_prob_old[i][j];
+			new = entropy->mv_prob[i][j];
+
+			if (new == old) {
+				hantro_boolenc_write_bool(e, prob, 0);
+			} else {
+				hantro_boolenc_write_bool(e, prob, 1);
+				hantro_boolenc_write_lit(e, new >> 1, 7);
+			}
+		}
+	}
+}
+
+static void hantro_h1_vp8_enc_write_filter_level_delta(struct hantro_ctx *ctx)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	int32_t i, tmp;
+	uint8_t  update = 0;
+	int32_t mode_update[4];
+	int32_t ref_update[4];
+
+	if (is_intra(ctx)) {
+		memset(ctx->vp8_enc.old_mode_delta, 0, sizeof(ctx->vp8_enc.old_mode_delta));
+		memset(ctx->vp8_enc.old_ref_delta, 0, sizeof(ctx->vp8_enc.old_ref_delta));
+	}
+
+	for (i = 0; i < 4; i++) {
+		mode_update[i] = ctx->vp8_enc.mode_delta[i] != ctx->vp8_enc.old_mode_delta[i];
+		ref_update[i] = ctx->vp8_enc.ref_delta[i] != ctx->vp8_enc.old_ref_delta[i];
+		if (mode_update[i] || ref_update[i])
+			update = 1;
+	}
+
+	if (!ctx->vp8_enc.refresh_entropy_probs)
+		update = 1;
+
+	hantro_boolenc_write_lit(e, update, 1);
+	if (!update)
+		return;
+
+	for (i = 0; i < 4; i++) {
+		hantro_boolenc_write_lit(e, ref_update[i], 1);
+		if (ref_update[i]) {
+			tmp = ctx->vp8_enc.ref_delta[i];
+			hantro_boolenc_write_lit(e, abs(tmp), 6);
+			hantro_boolenc_write_lit(e, tmp < 0, 1);
+		}
+	}
+
+	for (i = 0; i < 4; i++) {
+		hantro_boolenc_write_lit(e, mode_update[i], 1);
+		if (mode_update[i]) {
+			tmp = ctx->vp8_enc.mode_delta[i];
+			hantro_boolenc_write_lit(e, abs(tmp), 6);
+			hantro_boolenc_write_lit(e, tmp < 0, 1);
+		}
+	}
+
+	memcpy(ctx->vp8_enc.old_mode_delta, ctx->vp8_enc.mode_delta,
+	       sizeof(ctx->vp8_enc.old_mode_delta));
+	memcpy(ctx->vp8_enc.old_ref_delta, ctx->vp8_enc.ref_delta,
+	       sizeof(ctx->vp8_enc.old_ref_delta));
+}
+
+static void hantro_h1_vp8_enc_write_header(struct hantro_ctx *ctx, u32 qp,
+					       struct v4l2_ctrl_vp8_encode_params *params)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	struct vb2_v4l2_buffer *dst_buf = hantro_get_dst_buf(ctx);
+	void *vaddr = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);
+
+	ctx->vp8_enc.frame_tag = vaddr;
+	memset(ctx->vp8_enc.frame_tag, 0, sizeof(*ctx->vp8_enc.frame_tag));
+	ctx->vp8_enc.frame_tag->tag[0] |= (1 << 1);	/* version 1 */
+	if (ctx->vp8_enc.show_frame)
+		ctx->vp8_enc.frame_tag->tag[0] |= (1 << 4);
+	/* first partition size is known only after encoding */
+
+	if (is_intra(ctx)) {
+		ctx->vp8_enc.frame_tag->magic[0] = 0x9d;
+		ctx->vp8_enc.frame_tag->magic[1] = 0x01;
+		ctx->vp8_enc.frame_tag->magic[2] = 0x2a;
+
+		ctx->vp8_enc.frame_tag->width[0] = ctx->dst_fmt.width & 0xff;
+		ctx->vp8_enc.frame_tag->width[1] = (ctx->dst_fmt.width >> 8) & 0xff;
+
+		ctx->vp8_enc.frame_tag->height[0] = ctx->dst_fmt.height & 0xff;
+		ctx->vp8_enc.frame_tag->height[1] = (ctx->dst_fmt.height >> 8) & 0xff;
+	} else {
+		ctx->vp8_enc.frame_tag->tag[0] |= 0x1;
+	}
+
+	hantro_boolenc_init(e, vaddr + frame_tag_size(ctx));
+
+	if (is_intra(ctx)) {
+		hantro_boolenc_write_lit(e, params->color_space, 1);
+		hantro_boolenc_write_lit(e, params->clamping_type, 1);
+	}
+
+	hantro_boolenc_write_lit(e, !!(params->flags & V4L2_VP8_FRAME_FLAG_SEGMENT_ENABLED), 1);
+
+	hantro_boolenc_write_lit(e, params->loop_filter_type, 1);
+	hantro_boolenc_write_lit(e, params->loop_filter_level, 6);
+	hantro_boolenc_write_lit(e, params->sharpness_level, 3);
+	hantro_boolenc_write_lit(e, !!(params->flags & V4L2_VP8_FRAME_FLAG_LOOP_FILTER_ADJ_ENABLED),
+				 1);
+	if (params->flags & V4L2_VP8_FRAME_FLAG_LOOP_FILTER_ADJ_ENABLED)
+		hantro_h1_vp8_enc_write_filter_level_delta(ctx);
+
+	hantro_boolenc_write_lit(e, params->log2_nbr_of_dct_partitions, 2);
+
+	hantro_boolenc_write_lit(e, qp, 7);
+
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+
+	if (!is_intra(ctx)) {
+		hantro_boolenc_write_lit(e, 0, 1); /* refresh golden */
+		hantro_boolenc_write_lit(e, 0, 1); /* refresh alt */
+		hantro_boolenc_write_lit(e, 0, 2); /* copy to golden */
+		hantro_boolenc_write_lit(e, 0, 2); /* copy to alt */
+		hantro_boolenc_write_lit(e, 0, 1); /* sign bias golden */
+		hantro_boolenc_write_lit(e, 0, 1); /* sign bias alt */
+		hantro_boolenc_write_lit(e, ctx->vp8_enc.refresh_entropy_probs, 1);
+		hantro_boolenc_write_lit(e, 1, 1);
+	} else {
+		hantro_boolenc_write_lit(e, ctx->vp8_enc.refresh_entropy_probs, 1);
+	}
+
+	hantro_h1_vp8_enc_write_coeff_prob(ctx);
+
+	hantro_boolenc_write_lit(e, 1, 1);
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_skip_false, 8);
+
+	if (is_intra(ctx))
+		return;
+
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_intra, 8);
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_last, 8);
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_gf, 8);
+	hantro_boolenc_write_lit(e, 0, 1); /* intra 16x16 prob update flag */
+	hantro_boolenc_write_lit(e, 0, 1); /* intra chroma prob update flag */
+
+	hantro_h1_vp8_enc_write_mv_prob(ctx);
+}
+
+static uint32_t calc_mvprob(uint32_t left, uint32_t right, uint32_t prob)
+{
+	uint32_t p;
+
+	if (left + right) {
+		p = (left * 255) / (left + right);
+		p &= -2;
+		if (!p)
+			p = 1;
+	} else {
+		p = prob;
+	}
+
+	return p;
+}
+
+static uint32_t update_prob(uint32_t prob, uint32_t left, uint32_t right,
+			    uint32_t old_prob, uint32_t new_prob, uint32_t fixed)
+{
+	int32_t u, s;
+
+	u = (int32_t)fixed + ((vp8_prob_cost[255 - prob] - vp8_prob_cost[prob]) >> 8);
+	s = ((int32_t)left * (vp8_prob_cost[old_prob] - vp8_prob_cost[new_prob]) +
+		(int32_t)right *
+		(vp8_prob_cost[255 - old_prob] - vp8_prob_cost[255 - new_prob])) >> 8;
+
+	return (s > u);
+}
+
+static void hantro_h1_vp8_enc_update_entropy(struct hantro_ctx *ctx)
+{
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+	uint16_t *p_cnt = (uint16_t *)ctx->vp8_enc.priv_dst.cpu;
+
+	int32_t i, j, k, l;
+
+	uint32_t p, left, right;
+	uint32_t old_p, upd_p = 0;
+
+	uint32_t type;
+	uint32_t branch_cnt[2];
+	uint16_t *p_tmp = NULL;
+
+	if (!ctx->vp8_enc.refresh_entropy_probs || is_intra(ctx)) {
+		memcpy(entropy->coeff_prob, default_prob_coeff, sizeof(default_prob_coeff));
+		memcpy(entropy->mv_prob, default_prob_mv, sizeof(default_prob_mv));
+	}
+
+	memcpy(entropy->coeff_prob_old, entropy->coeff_prob, sizeof(entropy->coeff_prob));
+	if (ctx->vp8_enc.frame_counter == 0 || !ctx->vp8_enc.last_intra)
+		memcpy(entropy->mv_prob_old, entropy->mv_prob, sizeof(entropy->mv_prob));
+
+	if (!ctx->vp8_enc.frame_counter)
+		return;
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 7; j++) {
+			for (k = 0; k < 3; k++) {
+				int32_t tmp, ii;
+
+				tmp = i * 7 * 3 + j * 3 + k;
+				tmp += 2 * 4 * 7 * 3;
+				ii = offset_tbl[tmp];
+
+				right = ii >= 0 ? p_cnt[ii] : 0;
+
+				for (l = 2; l--;) {
+					old_p = entropy->coeff_prob[i][j][k][l];
+					old_p = coeff_update_prob[i][j][k][l];
+
+					tmp -= 4 * 7 * 3;
+					ii = offset_tbl[tmp];
+					left = ii >= 0 ? p_cnt[ii] : 0;
+					if (left + right) {
+						p = ((left * 256) + ((left + right) >> 1)) /
+						    (left + right);
+						if (p > 255)
+							p = 255;
+					} else {
+						p = old_p;
+					}
+
+					if (update_prob(upd_p, left, right, old_p, p, 8))
+						entropy->coeff_prob[i][j][k][l] = p;
+
+					right += left;
+				}
+			}
+		}
+	}
+
+	p_tmp = p_cnt + VP8_PROB_COUNT_MV_OFFSET;
+	for (i = 0; i < 2; i++) {
+		left  = *p_tmp++;
+		right = *p_tmp++;
+
+		p = calc_mvprob(left, right, entropy->mv_prob_old[i][0]);
+
+		if (update_prob(mv_update_prob[i][0], left, right,
+				entropy->mv_prob_old[i][0], p, 6))
+			entropy->mv_prob[i][0] = p;
+
+		right += left;
+		left = *p_tmp++;
+		right -= left - p_tmp[0];
+
+		p = calc_mvprob(left, right, entropy->mv_prob_old[i][1]);
+		if (update_prob(mv_update_prob[i][1], left, right,
+				entropy->mv_prob_old[i][1], p, 6))
+			entropy->mv_prob[i][1] = p;
+
+		for (j = 0; j < 2; j++) {
+			left = *p_tmp++;
+			right = *p_tmp++;
+			p = calc_mvprob(left, right, entropy->mv_prob_old[i][4 + j]);
+			if (update_prob(mv_update_prob[i][4 + j], left, right,
+					entropy->mv_prob_old[i][4 + j], p, 6))
+				entropy->mv_prob[i][4 + j] = p;
+			branch_cnt[j] = left + right;
+		}
+
+		p = calc_mvprob(branch_cnt[0], branch_cnt[1], entropy->mv_prob_old[i][3]);
+		if (update_prob(mv_update_prob[i][3], branch_cnt[0], branch_cnt[1],
+				entropy->mv_prob_old[i][3], p, 6))
+			entropy->mv_prob[i][3] = p;
+
+		type = branch_cnt[0] + branch_cnt[1];
+
+		for (j = 0; j < 2; j++) {
+			left = *p_tmp++;
+			right = *p_tmp++;
+			p = calc_mvprob(left, right, entropy->mv_prob_old[i][7 + j]);
+			if (update_prob(mv_update_prob[i][7 + j], left, right,
+					entropy->mv_prob_old[i][7 + j], p, 6))
+				entropy->mv_prob[i][7 + j] = p;
+			branch_cnt[j] = left + right;
+		}
+
+		p = calc_mvprob(branch_cnt[0], branch_cnt[1], entropy->mv_prob_old[i][6]);
+		if (update_prob(mv_update_prob[i][6], branch_cnt[0], branch_cnt[1],
+				entropy->mv_prob_old[i][6], p, 6))
+			entropy->mv_prob[i][6] = p;
+
+		p = calc_mvprob(type, branch_cnt[0] + branch_cnt[1],
+				entropy->mv_prob_old[i][2]);
+		if (update_prob(mv_update_prob[i][2], type, branch_cnt[0] + branch_cnt[1],
+				entropy->mv_prob_old[i][2], p, 6))
+			entropy->mv_prob[i][2] = p;
+	}
+
+	memcpy(entropy->y_mode_prob, y_mode_prob, sizeof(y_mode_prob));
+	memcpy(entropy->uv_mode_prob, uv_mode_prob, sizeof(uv_mode_prob));
+}
+
+static inline int coeff_prob_idx(int index)
+{
+	return (index / 8) * 8 + 7 - (index % 8);
+}
+
+static void hantro_h1_vp8_enc_write_entropy(struct hantro_ctx *ctx)
+{
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+	uint8_t *entropy_table = ctx->vp8_enc.priv_src.cpu;
+	int index, i, j, k, l;
+
+	memset(entropy_table, 0, 56);
+	entropy_table[7] = ctx->vp8_enc.prob_skip_false;
+	entropy_table[6] = ctx->vp8_enc.prob_intra;
+	entropy_table[5] = ctx->vp8_enc.prob_last;
+	entropy_table[4] = ctx->vp8_enc.prob_gf;
+	entropy_table[3] = 0; /* segment_prob[0]; */
+	entropy_table[2] = 0; /* segment_prob[1]; */
+	entropy_table[1] = 0; /* segment_prob[2]; */
+
+	entropy_table[15] = entropy->y_mode_prob[0];
+	entropy_table[14] = entropy->y_mode_prob[1];
+	entropy_table[13] = entropy->y_mode_prob[2];
+	entropy_table[12] = entropy->y_mode_prob[3];
+	entropy_table[11] = entropy->uv_mode_prob[0];
+	entropy_table[10] = entropy->uv_mode_prob[1];
+	entropy_table[9] = entropy->uv_mode_prob[2];
+
+	entropy_table[23] = entropy->mv_prob[1][0];
+	entropy_table[22] = entropy->mv_prob[0][0];
+	entropy_table[21] = entropy->mv_prob[1][1];
+	entropy_table[20] = entropy->mv_prob[0][1];
+	entropy_table[19] = entropy->mv_prob[1][17];
+	entropy_table[18] = entropy->mv_prob[1][18];
+	entropy_table[17] = entropy->mv_prob[0][17];
+	entropy_table[16] = entropy->mv_prob[0][18];
+
+	for (i = 0; i < 8; ++i)
+		entropy_table[24 + 7 - i] = entropy->mv_prob[1][9 + i];
+
+	for (i = 0; i < 8; ++i)
+		entropy_table[32 + 7 - i] = entropy->mv_prob[0][9 + i];
+
+	for (i = 0; i < 7; ++i)
+		entropy_table[40 + 7 - i] = entropy->mv_prob[1][2 + i];
+
+	for (i = 0; i < 7; ++i)
+		entropy_table[48 + 7 - i] = entropy->mv_prob[0][2 + i];
+
+	index = 56;
+
+	for (i = 0; i < 4; ++i)
+		for (j = 0; j < 8; ++j)
+			for (k = 0; k < 3; ++k) {
+				for (l = 0; l < 3; ++l)
+					entropy_table[coeff_prob_idx(index++)] =
+						entropy->coeff_prob[i][j][k][l];
+				entropy_table[coeff_prob_idx(index++)] = 0;
+			}
+
+	for (i = 0; i < 4; ++i)
+		for (j = 0; j < 8; ++j)
+			for (k = 0; k < 3; ++k) {
+				for (l = 4; l < 11; ++l)
+					entropy_table[coeff_prob_idx(index++)] =
+						entropy->coeff_prob[i][j][k][l];
+				entropy_table[coeff_prob_idx(index++)] =
+					entropy->coeff_prob[i][j][k][3];
+			}
+}
+
+static inline size_t sw_hdr_size(struct hantro_ctx *ctx)
+{
+	return ctx->vp8_enc.boolenc.bytes_written + frame_tag_size(ctx);
+}
+
+static void
+hantro_h1_vp8_enc_set_buffers(struct hantro_dev *vpu, struct hantro_ctx *ctx, u32 qp,
+				  struct v4l2_ctrl_vp8_encode_params *params)
+{
+	const u32 src_addr_regs[] = { H1_REG_ADDR_IN_PLANE_0,
+				      H1_REG_ADDR_IN_PLANE_1,
+				      H1_REG_ADDR_IN_PLANE_2 };
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct v4l2_pix_format_mplane *src_fmt = &ctx->src_fmt;
+	size_t luma_size;
+	dma_addr_t dst_dma;
+	size_t dst_size;
+	int i, ref_idx;
+
+	src_buf = hantro_get_src_buf(ctx);
+	dst_buf = hantro_get_dst_buf(ctx);
+
+	luma_size = hantro_rounded_luma_size(ctx->src_fmt.width,
+					     ctx->src_fmt.height);
+
+	dst_dma = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);
+	dst_size = vb2_plane_size(&dst_buf->vb2_buf, 0);
+
+	/*
+	 * We assume here that 1/10 of the buffer is enough for headers.
+	 * DCT partition will be placed in remaining 9/10 of the buffer.
+	 */
+	ctx->vp8_enc.estimated_hdr_size = round_up(dst_size / 10, 8);
+
+	/* Destination buffer. */
+	/*
+	 * We "abused" the first portion of this 1/10 of the buffer when generating
+	 * the frame tag and compressed header, so TODO: verify that the 1/10 can hold both the
+	 * compressed header and the "extended header" generated in hw.
+	 */
+	vepu_write_relaxed(vpu, dst_dma + round_up(sw_hdr_size(ctx), 8),
+			   H1_REG_ADDR_OUTPUT_STREAM);
+	vepu_write_relaxed(vpu, dst_dma + ctx->vp8_enc.estimated_hdr_size,
+			   H1_REG_ADDR_VP8_DCT_PART(0));
+	vepu_write_relaxed(vpu, dst_size - ctx->vp8_enc.estimated_hdr_size,
+			   H1_REG_STR_BUF_LIMIT);
+
+	/* Auxiliary buffers. */
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ctrl_buf.dma,
+			   H1_REG_ADDR_OUTPUT_CTRL);
+	memset(ctx->vp8_enc.ctrl_buf.cpu, 0, ctx->vp8_enc.ctrl_buf.size);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.mv_buf.dma,
+			   H1_REG_ADDR_MV_OUT);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.priv_dst.dma,
+			   H1_REG_ADDR_VP8_PROB_CNT);
+	memset(ctx->vp8_enc.priv_dst.cpu, 0, ctx->vp8_enc.priv_dst.size);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.priv_src.dma,
+			   H1_REG_ADDR_CABAC_TBL);
+
+	hantro_h1_vp8_enc_write_entropy(ctx);
+
+	vepu_write_relaxed(vpu, ctx->vp8_enc.priv_src.dma + 151 * 8,
+			   H1_REG_ADDR_VP8_SEG_MAP);
+
+	/* Reference buffers. */
+	switch (params->reference_type) {
+	case V4L2_VP8_FRAME_REF_LAST:
+		ref_idx = ctx->vp8_enc.last_ref;
+		break;
+	case V4L2_VP8_FRAME_REF_GOLDEN:
+		ref_idx = ctx->vp8_enc.golden_ref;
+		break;
+	case V4L2_VP8_FRAME_REF_ALT:
+		ref_idx = ctx->vp8_enc.alt_ref;
+		break;
+	}
+	if (ref_idx < 0)
+		ref_idx = 0;
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ref_idx].dma, H1_REG_ADDR_REF_LUMA);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ref_idx].dma + luma_size,
+			   H1_REG_ADDR_REF_CHROMA);
+
+	/* Reconstruction buffers. */
+	ctx->vp8_enc.reconstructed =  ctx->vp8_enc.first_free;
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ctx->vp8_enc.reconstructed].dma,
+			   H1_REG_ADDR_REC_LUMA);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ctx->vp8_enc.reconstructed].dma + luma_size,
+			   H1_REG_ADDR_REC_CHROMA);
+
+	/* Source buffer. */
+	vepu_write_relaxed(vpu,
+			   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+			   src_buf->vb2_buf.planes[0].data_offset,
+			   src_addr_regs[0]);
+	vepu_write_relaxed(vpu,
+			   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 0) +
+			   src_buf->vb2_buf.planes[0].data_offset +
+			   luma_size,
+			   src_addr_regs[1]);
+
+	for (i = 1; i < src_fmt->num_planes; ++i)
+		/* Multiplanes. */
+		vepu_write_relaxed(vpu,
+				   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, i) +
+				   src_buf->vb2_buf.planes[i].data_offset,
+				   src_addr_regs[i]);
+}
+
+static inline uint32_t compute_filter_level(int32_t qp)
+{
+	return clamp((qp * 64) / 128 + 8, 0, 63);
+}
+
+static s32 cost_tree(struct tree *tree, const s32 *prob)
+{
+	s32 value = tree->value;
+	s32 number = tree->number;
+	s32 *index = tree->index;
+	s32 bit_cost = 0;
+
+	while (number--)
+		bit_cost += COST_BOOL(prob[*index++], (value >> number) & 1);
+
+	return bit_cost;
+}
+
+static s32 cost_mv(s32 mvd, const s32 *mv_prob)
+{
+	s32 i, tmp, bit_cost = 0;
+
+	tmp = abs(mvd >> 1);
+
+	/* Short Tree */
+	if (tmp < 8) {
+		bit_cost += COST_BOOL(mv_prob[0], 0);
+		bit_cost += cost_tree(&mv_tree[tmp], mv_prob + 2);
+		if (!tmp)
+			return bit_cost;
+
+		/* Sign */
+		bit_cost += COST_BOOL(mv_prob[1], mvd < 0);
+		return bit_cost;
+	}
+
+	/* Long Tree */
+	bit_cost += COST_BOOL(mv_prob[0], 1);
+
+	/* Bits 0, 1, 2 */
+	for (i = 0; i < 3; i++)
+		bit_cost += COST_BOOL(mv_prob[9 + i], (tmp >> i) & 1);
+
+	/* Bits 9, 8, 7, 6, 5, 4 */
+	for (i = 9; i > 3; i--)
+		bit_cost += COST_BOOL(mv_prob[9 + i], (tmp >> i) & 1);
+
+	/*
+	 * Bit 3: if ABS(mvd) < 8, it is coded with short tree, so if here
+	 * ABS(mvd) <= 15, bit 3 must be one (because here we code values
+	 * 8,...,15) and is not explicitly coded.
+	 */
+	if (tmp > 15)
+		bit_cost += COST_BOOL(mv_prob[9 + 3], (tmp >> 3) & 1);
+
+	/* Sign */
+	bit_cost += COST_BOOL(mv_prob[1], mvd < 0);
+
+	return bit_cost;
+}
+
+static void hantro_h1_vp8_enc_set_params(struct hantro_dev *vpu, struct hantro_ctx *ctx, u32 qp,
+					     struct v4l2_ctrl_vp8_encode_params *params)
+{
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+	int i;
+	unsigned int mb_width = MB_WIDTH(ctx->src_fmt.width);
+	unsigned int mb_height = MB_HEIGHT(ctx->src_fmt.height);
+	u32 deq;
+	u32 tmp;
+	u32 reg;
+	s16 inter_favor;
+
+	vepu_write_relaxed(vpu, 0, H1_REG_STR_HDR_REM_MSB);
+	vepu_write_relaxed(vpu, 0, H1_REG_STR_HDR_REM_LSB);
+
+	reg = 0;
+	if (mb_width * mb_height > MAX_MB_COUNT_TO_DISABLE_QUARTER_PIXEL_MV)
+		reg = H1_REG_ENC_CTRL2_DISABLE_QUARTER_PIXMV;
+	reg |= H1_REG_ENC_CTRL2_VP8_BOOLENC_ENABLE;
+
+	inter_favor = 128 - ctx->vp8_enc.prob_intra;
+	if (inter_favor >= 0)
+		/*
+		 * It seems that hardware expects a negative s16 non-0 value
+		 * for inter_favor otherwise P frames have pink artefacts...
+		 */
+		/*inter_favor = max(0, (int32_t)(qp * 2 - 40));*/
+		inter_favor = -max(1, (int32_t)(qp * 2 - 40));
+
+	reg |= H1_REG_ENC_CTRL2_INTRA16X16_MODE(qp * 1024 / 128);
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL2);//in VEPU_REG_INTRA_INTER_MODE
+
+	reg = H1_REG_ENC_CTRL5_INTER_MODE(inter_favor);//FIXME replace VEPU_REG_INTER_MODE(inter_favor of VEPU_REG_INTRA_INTER_MODE
+	reg |= H1_REG_ENC_CTRL5_MACROBLOCK_PENALTY(qp >= 100 ? (3 * qp / 4) : 0);//FIXME, guess !!
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL5);//in VEPU_REG_INTRA_INTER_MODE
+
+	reg = H1_REG_ENC_CTRL3_MV_PENALTY_1P(60 / 2 * 32)
+		| H1_REG_ENC_CTRL3_MV_PENALTY_1_4P(8)
+		| H1_REG_ENC_CTRL3_MV_PENALTY_4P(64 / 2);
+	if (mb_width * mb_height < MAX_MB_COUNT_TO_DISABLE_SPLIT_MV)
+		reg |= H1_REG_ENC_CTRL3_MUTIMV_EN;
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL3);
+
+	reg = H1_REG_ENC_CTRL4_MV_PENALTY_16X8_8X16(
+			min(1023, split_penalty[qp] / 2))
+		| H1_REG_ENC_CTRL4_MV_PENALTY_8X8(
+			min(1023, (2 * split_penalty[qp] + 40) / 4))
+		| H1_REG_ENC_CTRL4_8X4_4X8(0x3ff);
+	/* no 8x4 or 4x8 block define in vp8 */
+	vepu_write_relaxed(vpu, reg, H1_REG_ENC_CTRL4);
+
+	reg = H1_REG_PENALTY_4X4MV(min(511,
+				       (8 * split_penalty[qp] + 500) / 16))
+		| H1_REG_ZERO_MV_FAVOR_D2(0);
+	vepu_write_relaxed(vpu, reg, H1_REG_QP_MV_MVC_CTRL);
+
+	/* initialize quant table for segment0 */
+	deq = dc_q_lookup[qp];
+	reg = H1_REG_VP8_SEG0_QUT_DC_Y1(min((1 << 16) / deq, 0x3FFFu));
+	reg |= H1_REG_VP8_SEG0_ZBIN_DC_Y1(((qzbin_factors[qp] * deq) + 64) >>
+					    7);
+	reg |= H1_REG_VP8_SEG0_RND_DC_Y1((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_DC_Y1);
+
+	deq = ac_q_lookup[qp];
+	reg = H1_REG_VP8_SEG0_QUT_AC_Y1(min((1 << 16) / deq, 0x3FFFu));
+	reg |= H1_REG_VP8_SEG0_ZBIN_AC_Y1(((qzbin_factors[qp] * deq) + 64) >>
+					    7);
+	reg |= H1_REG_VP8_SEG0_RND_AC_Y1((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_AC_Y1);
+
+	deq = dc_q_lookup[qp] * 2;
+	reg = H1_REG_VP8_SEG0_QUT_DC_Y2(min((1 << 16) / deq, 0x3FFFu));
+	reg |= H1_REG_VP8_SEG0_ZBIN_DC_Y2((qzbin_factors[qp] * deq + 64) >>
+					    7);
+	reg |= H1_REG_VP8_SEG0_RND_DC_Y2((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_DC_Y2);
+
+	deq = max(ac_q_lookup[qp] * 155 / 100, 8);
+	reg = H1_REG_VP8_SEG0_QUT_AC_Y2(min((1 << 16) / deq, 0x3FFFu));
+	reg |= H1_REG_VP8_SEG0_ZBIN_AC_Y2((qzbin_factors[qp] * deq + 64) >>
+					    7);
+	reg |= H1_REG_VP8_SEG0_RND_AC_Y2((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_AC_Y2);
+
+	deq = min(dc_q_lookup[qp], 132);
+	reg = H1_REG_VP8_SEG0_QUT_DC_CHR(min((1 << 16) / deq, 0x3FFFu));
+	reg |= H1_REG_VP8_SEG0_ZBIN_DC_CHR((qzbin_factors[qp] * deq + 64) >>
+					     7);
+	reg |= H1_REG_VP8_SEG0_RND_DC_CHR((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_DC_CHR);
+
+	deq = ac_q_lookup[qp];
+	reg = H1_REG_VP8_SEG0_QUT_AC_CHR(min((1 << 16) / deq, 0x3FFFu));
+	reg |= H1_REG_VP8_SEG0_ZBIN_AC_CHR((qzbin_factors[qp] * deq + 64) >>
+					     7);
+	reg |= H1_REG_VP8_SEG0_RND_AC_CHR((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_AC_CHR);
+
+	reg = H1_REG_VP8_MV_REF_IDX1(params->reference_type);
+	reg |= H1_REG_VP8_SEG0_DQUT_DC_Y1(dc_q_lookup[qp]);
+	reg |= H1_REG_VP8_SEG0_DQUT_AC_Y1(ac_q_lookup[qp]);
+	reg |= H1_REG_VP8_SEG0_DQUT_DC_Y2(dc_q_lookup[qp] * 2);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_DQUT);
+
+	reg = H1_REG_VP8_MV_REF_IDX2(0);
+	reg |= H1_REG_VP8_SEG0_DQUT_DC_CHR(min(dc_q_lookup[qp], 132));
+	reg |= H1_REG_VP8_SEG0_DQUT_AC_CHR(ac_q_lookup[qp]);
+	reg |= H1_REG_VP8_SEG0_DQUT_AC_Y2(max(ac_q_lookup[qp] * 155 / 100, 8));
+	if (is_intra(ctx))
+		reg |= H1_REG_VP8_SEGMENT_MAP_UPDATE;
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_SEG0_QUANT_DQUT_1);
+
+	vepu_write_relaxed(vpu, ctx->vp8_enc.boolenc.bottom,
+			   H1_REG_VP8_BOOL_ENC);
+
+	reg = H1_REG_VP8_DCT_PARTITION_CNT(0);
+	reg |= H1_REG_VP8_FILTER_LEVEL(compute_filter_level(qp));
+	reg |= H1_REG_VP8_FILTER_SHARPNESS(params->sharpness_level);
+	reg |= H1_REG_VP8_ZERO_MV_PENALTY_FOR_REF2(0);
+	reg |= H1_REG_VP8_BOOL_ENC_VALUE_BITS(24 - ctx->vp8_enc.boolenc.bit_count);
+	reg |= H1_REG_VP8_BOOL_ENC_RANGE(ctx->vp8_enc.boolenc.range);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_PENALTY_FILTER);
+
+	vepu_write_relaxed(vpu, 0xffffffff, H1_REG_FIRST_ROI_AREA);
+	vepu_write_relaxed(vpu, 0xffffffff, H1_REG_SECOND_ROI_AREA);
+	vepu_write_relaxed(vpu, 0, H1_REG_STABILIZATION_OUTPUT);
+	vepu_write_relaxed(vpu, 0, H1_REG_CIR_INTRA_CTRL);
+	vepu_write_relaxed(vpu, 0xffffffff, H1_REG_INTRA_AREA_CTRL);
+
+	/* Intra 4x4 mode */
+	//FIXME VEPU=12bits (0xfff) + 16bits align ? while H1=10bits in regmap & 10bits aligned
+	tmp = qp * 2 + 8;
+	for (i = 0; i < 5; i++) {
+		reg = H1_REG_VP8_INTRA_4X4_PENALTY_0
+			((intra_4_tree_penalty[i * 2] * tmp) >> 8);
+		reg |= HI_REG_VP8_INTRA_4X4_PENALTY_1
+			((intra_4_tree_penalty[i * 2 + 1] * tmp) >> 8);
+		vepu_write_relaxed(vpu, reg,
+				   H1_REG_VP8_INTRA_4X4_PENALTY(i));
+	}
+
+	/* Intra 16x16 mode */
+	//FIXME VEPU=12bits (0xfff) + 16bits align ? while H1=10bits in regmap & 10bits aligned
+	tmp = qp * 2 + 64;
+	for (i = 0; i < 2; i++) {
+		reg = H1_REG_VP8_INTRA_16X16_PENALTY_0
+			((intra_16_tree_penalty[2 * i] * tmp) >> 8);
+		reg |= HI_REG_VP8_INTRA_16X16_PENALTY_1
+			((intra_16_tree_penalty[2 * i + 1] * tmp) >> 8);
+		vepu_write_relaxed(vpu, reg,
+				   H1_REG_VP8_INTRA_16X16_PENALTY(i));//VEPU_REG_VP8_INTRA_16X16_PENALTY
+	}
+
+	//FIXME H1 slightly different...
+	reg = H1_REG_VP8_LF_REF_DELTA_INTRA_MB(ctx->vp8_enc.ref_delta[REF_DELTA_INTRA_MB])
+		| H1_REG_VP8_LF_REF_DELTA_LAST_REF(ctx->vp8_enc.ref_delta[REF_DELTA_LAST_REF])
+		| H1_REG_VP8_LF_REF_DELTA_GOLDEN(ctx->vp8_enc.ref_delta[REF_DELTA_GOLDEN])
+		| H1_REG_VP8_LF_REF_DELTA_ALT_REF(ctx->vp8_enc.ref_delta[REF_DELTA_ALT_REF]);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_LOOP_FILTER_REF_DELTA);
+
+	reg = H1_REG_VP8_LF_MODE_DELTA_BPRED(ctx->vp8_enc.mode_delta[MODE_DELTA_BPRED])
+		| H1_REG_VP8_LF_MODE_DELTA_ZEROMV(ctx->vp8_enc.mode_delta[MODE_DELTA_ZEROMV])
+		| H1_REG_VP8_LF_MODE_DELTA_NEWMV(ctx->vp8_enc.mode_delta[MODE_DELTA_NEWMV])
+		| H1_REG_VP8_LF_MODE_DELTA_SPLITMV(ctx->vp8_enc.mode_delta[MODE_DELTA_SPLITMV]);
+	vepu_write_relaxed(vpu, reg, H1_REG_VP8_LOOP_FILTER_MODE_DELTA);
+
+	//HFR no match for VEPU_REG_VP8_INTER_TYPE_BIT_COST, but put to 0...
+
+
+	for (i = 0; i < 128; i += 4) {
+		u32 x;
+		u32 y;
+
+		reg = H1_REG_DMV_4P_1P_PENALTY_BIT(i * 2, 3);
+		reg |= H1_REG_DMV_4P_1P_PENALTY_BIT((i + 1) * 2, 2);
+		reg |= H1_REG_DMV_4P_1P_PENALTY_BIT((i + 2) * 2, 1);
+		reg |= H1_REG_DMV_4P_1P_PENALTY_BIT((i + 3) * 2, 0);
+		vepu_write_relaxed(vpu, reg, H1_REG_DMV_4P_1P_PENALTY(i / 4));
+
+		y = cost_mv(i * 2, entropy->mv_prob[0]);	/* mv y */
+		x = cost_mv(i * 2, entropy->mv_prob[1]);	/* mv x */
+
+		reg = H1_REG_DMV_QPEL_PENALTY_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 3);
+
+		y = cost_mv((i + 1) * 2, entropy->mv_prob[0]); /* mv y */
+		x = cost_mv((i + 1) * 2, entropy->mv_prob[1]); /* mv x */
+		reg |= H1_REG_DMV_QPEL_PENALTY_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 2);
+
+		y = cost_mv((i + 2) * 2, entropy->mv_prob[0]); /* mv y */
+		x = cost_mv((i + 2) * 2, entropy->mv_prob[1]); /* mv x */
+		reg |= H1_REG_DMV_QPEL_PENALTY_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 1);
+
+		y = cost_mv((i + 3) * 2, entropy->mv_prob[0]); /* mv y */
+		x = cost_mv((i + 3) * 2, entropy->mv_prob[1]); /* mv x */
+		reg |= H1_REG_DMV_QPEL_PENALTY_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 0);
+
+		vepu_write_relaxed(vpu, reg,
+				   H1_REG_DMV_QPEL_PENALTY(i / 4));
+	}
+}
+
+static char *encode_params_str(struct v4l2_ctrl_vp8_encode_params *p,
+			       char *str,
+			       unsigned int len)
+{
+	if (!p)
+		return NULL;
+
+	snprintf(str, len,
+		 "v4l2_ctrl_vp8_encode_params\n"
+		 " flags:\t\t\t %s %s %s %s %s %s\n"
+		 " frame_type:\t\t%s\n"
+		 " color_space:\t\t%s\n"
+		 " clamping_type:\t\t%s\n"
+		 " loop_filter_type:\t%s\n"
+		 " loop_filter_level:\t%d\n"
+		 " sharpness_level:\t%d\n"
+		 " log2_nbr_of_dct_parts:\t%s\n"
+		 " prob_intra:\t\t%d\n"
+		 " prob_last:\t\t%d\n"
+		 " prob_gf:\t\t%d\n"
+		 " copy_to_golden:\t\t%d\n"
+		 " copy_to_alternate:\t%d\n"
+		 " reference_type:\t\t%s\n",
+		 (p->flags & V4L2_VP8_FRAME_FLAG_SHOWFRAME) ? "SHOW" : "",
+		 (p->flags & V4L2_VP8_FRAME_FLAG_GOLDEN_REFRESH) ? "GOLDEN" : "",
+		 (p->flags & V4L2_VP8_FRAME_FLAG_ALTREF_REFRESH) ? "ALTREF" : "",
+		 (p->flags & V4L2_VP8_FRAME_FLAG_SEGMENT_ENABLED) ? "SEGMENT" : "",
+		 (p->flags & V4L2_VP8_FRAME_FLAG_LOOP_FILTER_ADJ_ENABLED) ? "LOOPFILTER" : "",
+		 (p->flags & V4L2_VP8_FRAME_FLAG_REFRESH_ENTROPY_PROBS) ? "REFRESH_ENTROPY" : "",
+		 (p->frame_type == V4L2_VP8_FRAME_TYPE_KEYFRAME) ? "KEYFRAME" : "INTER",
+		 (p->color_space == V4L2_VP8_FRAME_COLOR_SPACE_YUV) ? "YUV" : "RESERVED",
+		 (p->clamping_type == V4L2_VP8_FRAME_CLAMPING_REQUIRED) ? "REQ" : "NO",
+		 (p->loop_filter_type == V4L2_VP8_FRAME_FILTER_TYPE_NORMAL) ? "NORMAL" : "SIMPLE",
+		 p->loop_filter_level,
+		 p->sharpness_level,
+		 (p->log2_nbr_of_dct_partitions == V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_1) ? "1" :
+		 (p->log2_nbr_of_dct_partitions == V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_2) ? "2" :
+		 (p->log2_nbr_of_dct_partitions == V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_4) ? "4" : "8",
+		 p->prob_intra,
+		 p->prob_last,
+		 p->prob_gf,
+		 p->copy_buffer_to_golden,
+		 p->copy_buffer_to_alternate,
+		 (p->reference_type == V4L2_VP8_FRAME_REF_LAST) ? "LAST" :
+		 (p->reference_type == V4L2_VP8_FRAME_REF_GOLDEN) ? "GOLDEN" : "ALT");
+
+	return str;
+}
+
+int hantro_h1_vp8_enc_run(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	struct v4l2_ctrl_vp8_encode_params *params;
+	struct v4l2_ctrl *ctrl;
+	u32 reg, qp;
+	int i;
+
+	hantro_start_prepare_run(ctx);
+
+	params = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_VP8_ENCODE_PARAMS);
+	if (WARN_ON(!params))
+		return -EINVAL;
+
+	vpu_debug(1, "%s\n", encode_params_str(params, ctx->str, sizeof(ctx->str)));
+
+	if (params->flags & V4L2_VP8_FRAME_FLAG_SEGMENT_ENABLED)
+		return -EINVAL;
+
+	ctx->vp8_enc.is_intra = params->frame_type == V4L2_VP8_FRAME_TYPE_KEYFRAME;
+
+	if (is_intra(ctx)) {
+		if (params->loop_filter_level != 26)
+			return -EINVAL;
+	} else {
+		if (params->loop_filter_level != 12)
+			return -EINVAL;
+	}
+
+	ctrl = v4l2_ctrl_find(&ctx->ctrl_handler, V4L2_CID_STATELESS_VP8_ENCODE_QP);
+	if (WARN_ON(!ctrl))
+		return -EINVAL;
+
+	ctx->vp8_enc.show_frame = params->flags & V4L2_VP8_FRAME_FLAG_SHOWFRAME;
+	ctx->vp8_enc.refresh_golden_frame = params->flags & V4L2_VP8_FRAME_FLAG_GOLDEN_REFRESH;
+	ctx->vp8_enc.refresh_alternate_frame = params->flags & V4L2_VP8_FRAME_FLAG_ALTREF_REFRESH;
+	ctx->vp8_enc.refresh_entropy_probs =
+		params->flags & V4L2_VP8_FRAME_FLAG_REFRESH_ENTROPY_PROBS;
+	ctx->vp8_enc.copy_buffer_to_golden = params->copy_buffer_to_golden;
+	ctx->vp8_enc.copy_buffer_to_alternate = params->copy_buffer_to_alternate;
+	ctx->vp8_enc.prob_intra = params->prob_intra;
+	ctx->vp8_enc.prob_last = params->prob_last;
+	ctx->vp8_enc.prob_gf = params->prob_gf;
+
+	hantro_h1_vp8_enc_update_entropy(ctx);
+
+	qp = *ctrl->p_cur.p_s32;
+	ctx->vp8_enc.prob_skip_false = default_prob_skip_false[qp];
+	hantro_h1_vp8_enc_write_header(ctx, qp, params);
+
+	/*
+	 * Program the hardware.
+	 */
+	vepu_write_relaxed(vpu, H1_REG_ENC_CTRL_ENC_MODE_VP8, H1_REG_ENC_CTRL);
+
+	hantro_h1_vp8_enc_set_params(vpu, ctx, qp, params);
+	hantro_h1_set_src_img_ctrl(vpu, ctx);
+	hantro_h1_vp8_enc_set_buffers(vpu, ctx, qp, params);
+
+	hantro_h1_set_color_conv(vpu, ctx);
+
+	/* Make sure that all registers are written at this point. */
+	hantro_h1_set_axi_ctrl(vpu, ctx);
+
+	/* Start the hardware. */
+	reg =     H1_REG_ENC_CTRL_TIMEOUT_EN
+		| H1_REG_ENC_CTRL_MV_WRITE //for VEPU_REG_MV_WRITE_EN in VEPU_REG_INTERRUPT
+		| H1_REG_ENC_CTRL_WIDTH(MB_WIDTH(ctx->src_fmt.width))
+		| H1_REG_ENC_CTRL_HEIGHT(MB_HEIGHT(ctx->src_fmt.height))
+		| H1_REG_ENC_CTRL_ENC_MODE_VP8
+		| H1_REG_ENC_CTRL_EN_BIT;
+
+	if (is_intra(ctx))
+		reg |= H1_REG_ENC_PIC_INTRA;
+	else
+		reg |= H1_REG_ENC_PIC_INTER;
+
+	/* Kick the watchdog and start encoding */
+	hantro_end_prepare_run(ctx);
+
+	for (i = 0; i < 184; ++i)
+		vepu_read(vpu, i * 4);
+
+	vepu_write(vpu, reg, H1_REG_ENC_CTRL);
+
+	return 0;
+}
+
+void hantro_h1_vp8_enc_done(struct hantro_ctx *ctx)
+{
+	struct vb2_v4l2_buffer *dst_buf;
+	struct hantro_vp8_enc_ctrl_buf *ctrl_buf = ctx->vp8_enc.ctrl_buf.cpu;
+	int part1_sz = ctx->vp8_enc.boolenc.bytes_written + ctrl_buf->hw_hdr_size;
+	void *dst = ctx->vp8_enc.frame_tag;
+	int old_g = ctx->vp8_enc.golden_ref, old_a = ctx->vp8_enc.alt_ref;
+	int i;
+
+	ctx->vp8_enc.frame_tag->tag[0] |= ((part1_sz << 5) & 0xff);
+	ctx->vp8_enc.frame_tag->tag[1] = ((part1_sz << 5) >> 8) & 0xff;
+	ctx->vp8_enc.frame_tag->tag[2] = ((part1_sz << 5) >> 16) & 0xff;
+
+	dst_buf = hantro_get_dst_buf(ctx);
+
+	/* assemble dst frame */
+	vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+			      sw_hdr_size(ctx) + ctrl_buf->hw_hdr_size + ctrl_buf->dct_size);
+
+	memmove(dst + sw_hdr_size(ctx), dst + round_up(sw_hdr_size(ctx), 8), ctrl_buf->hw_hdr_size);
+	memmove(dst + sw_hdr_size(ctx) + ctrl_buf->hw_hdr_size,
+		dst + ctx->vp8_enc.estimated_hdr_size, ctrl_buf->dct_size);
+
+	/* currently reconstructed frame becames last ref */
+	hantro_vp8_clr_bit(&ctx->vp8_enc, VP8_BIT_LAST, ctx->vp8_enc.last_ref);
+	ctx->vp8_enc.last_ref = ctx->vp8_enc.reconstructed;
+	hantro_vp8_set_bit(&ctx->vp8_enc, VP8_BIT_LAST, ctx->vp8_enc.last_ref);
+
+	/* after update (potentially) new slots will be used */
+	hantro_vp8_clr_bit(&ctx->vp8_enc, VP8_BIT_GOLDEN, old_g);
+	hantro_vp8_clr_bit(&ctx->vp8_enc, VP8_BIT_ALT, old_a);
+
+	/* VP8 spec, section 9.7. Refresh Golden Frame and Altref Frame */
+	if (is_intra(ctx)) {
+		ctx->vp8_enc.golden_ref = ctx->vp8_enc.last_ref;
+		ctx->vp8_enc.alt_ref = ctx->vp8_enc.last_ref;
+	} else {
+		if (ctx->vp8_enc.refresh_golden_frame) {
+			ctx->vp8_enc.golden_ref = ctx->vp8_enc.last_ref;
+		} else if (ctx->vp8_enc.copy_buffer_to_golden) {
+			switch (ctx->vp8_enc.copy_buffer_to_golden) {
+			case V4L2_VP8_FRAME_GOLDEN_KEEP:
+				break;
+			case V4L2_VP8_FRAME_GOLDEN_LASTFRAME:
+				ctx->vp8_enc.golden_ref = ctx->vp8_enc.last_ref;
+				break;
+			case V4L2_VP8_FRAME_GOLDEN_ALTREF:
+				ctx->vp8_enc.golden_ref = old_a;
+				break;
+			}
+		}
+
+		if (ctx->vp8_enc.refresh_alternate_frame) {
+			ctx->vp8_enc.alt_ref = ctx->vp8_enc.last_ref;
+		} else if (ctx->vp8_enc.copy_buffer_to_alternate) {
+			switch (ctx->vp8_enc.copy_buffer_to_alternate) {
+			case V4L2_VP8_FRAME_ALTREF_KEEP:
+				break;
+			case V4L2_VP8_FRAME_ALTREF_LASTFRAME:
+				ctx->vp8_enc.alt_ref = ctx->vp8_enc.last_ref;
+				break;
+			case V4L2_VP8_FRAME_ALTREF_GOLDEN:
+				ctx->vp8_enc.alt_ref = old_g;
+				break;
+			}
+		}
+	}
+
+	/* mark updated golden and alt slots used */
+	hantro_vp8_set_bit(&ctx->vp8_enc, VP8_BIT_GOLDEN, ctx->vp8_enc.golden_ref);
+	hantro_vp8_set_bit(&ctx->vp8_enc, VP8_BIT_ALT, ctx->vp8_enc.alt_ref);
+
+	/* find first free slot after updates */
+	for (i = 0; i < ARRAY_SIZE(ctx->vp8_enc.ref_bitmaps); ++i)
+		if (!ctx->vp8_enc.ref_bitmaps[i]) {
+			ctx->vp8_enc.first_free = i;
+			break;
+		}
+	WARN_ON(i >= 4);
+
+	ctx->vp8_enc.last_intra = is_intra(ctx);
+	++ctx->vp8_enc.frame_counter;
+
+	if (is_intra(ctx))
+		dst_buf->flags |= V4L2_BUF_FLAG_KEYFRAME;
+	else
+		dst_buf->flags |= V4L2_BUF_FLAG_PFRAME;
+}
diff --git a/drivers/media/platform/verisilicon/hantro_h264.c b/drivers/media/platform/verisilicon/hantro_h264.c
index 4e9a0ecf5..7d38e599a 100644
--- a/drivers/media/platform/verisilicon/hantro_h264.c
+++ b/drivers/media/platform/verisilicon/hantro_h264.c
@@ -198,6 +198,586 @@ static const u32 h264_cabac_table[] = {
 	0x1f0c2517, 0x1f261440
 };
 
+/*
+ * CABAC tables for the encoder.
+ * From drivers/staging/media/hantro/rk3399_vpu_hw_h264_enc.c
+ * in https://chromium.googlesource.com/chromiumos/third_party/kernel,
+ * chromeos-5.10 branch.
+ */
+static const s32 h264_context_init_intra[HANTRO_H264_CABAC_CV_NUM][2] = {
+	/* 0 -> 10 */
+	{ 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
+	{ 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
+	{ -6, 53 }, { -1, 54 }, { 7, 51 },
+	/* 11 -> 23 unused for I */
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 },
+	/* 24 -> 39 */
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	/* 40 -> 53 */
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 },
+	/* 54 -> 59 */
+	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 },
+	{ 0, 0 }, { 0, 0 },
+	/* 60 -> 69 */
+	{ 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
+	{ -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
+	{ 13, 41 }, { 3, 62 },
+	/* 70 -> 87 */
+	{ 0, 11 }, { 1, 55 }, { 0, 69 }, { -17, 127 },
+	{ -13, 102 }, { 0, 82 }, { -7, 74 }, { -21, 107 },
+	{ -27, 127 }, { -31, 127 }, { -24, 127 }, { -18, 95 },
+	{ -27, 127 }, { -21, 114 }, { -30, 127 }, { -17, 123 },
+	{ -12, 115 }, { -16, 122 },
+	/* 88 -> 104 */
+	{ -11, 115 }, { -12, 63 }, { -2, 68 }, { -15, 84 },
+	{ -13, 104 }, { -3, 70 }, { -8, 93 }, { -10, 90 },
+	{ -30, 127 }, { -1, 74 }, { -6, 97 }, { -7, 91 },
+	{ -20, 127 }, { -4, 56 }, { -5, 82 }, { -7, 76 },
+	{ -22, 125 },
+	/* 105 -> 135 */
+	{ -7, 93 }, { -11, 87 }, { -3, 77 }, { -5, 71 },
+	{ -4, 63 }, { -4, 68 }, { -12, 84 }, { -7, 62 },
+	{ -7, 65 }, { 8, 61 }, { 5, 56 }, { -2, 66 },
+	{ 1, 64 }, { 0, 61 }, { -2, 78 }, { 1, 50 },
+	{ 7, 52 }, { 10, 35 }, { 0, 44 }, { 11, 38 },
+	{ 1, 45 }, { 0, 46 }, { 5, 44 }, { 31, 17 },
+	{ 1, 51 }, { 7, 50 }, { 28, 19 }, { 16, 33 },
+	{ 14, 62 }, { -13, 108 }, { -15, 100 },
+	/* 136 -> 165 */
+	{ -13, 101 }, { -13, 91 }, { -12, 94 }, { -10, 88 },
+	{ -16, 84 }, { -10, 86 }, { -7, 83 }, { -13, 87 },
+	{ -19, 94 }, { 1, 70 }, { 0, 72 }, { -5, 74 },
+	{ 18, 59 }, { -8, 102 }, { -15, 100 }, { 0, 95 },
+	{ -4, 75 }, { 2, 72 }, { -11, 75 }, { -3, 71 },
+	{ 15, 46 }, { -13, 69 }, { 0, 62 }, { 0, 65 },
+	{ 21, 37 }, { -15, 72 }, { 9, 57 }, { 16, 54 },
+	{ 0, 62 }, { 12, 72 },
+	/* 166 -> 196 */
+	{ 24, 0 }, { 15, 9 }, { 8, 25 }, { 13, 18 },
+	{ 15, 9 }, { 13, 19 }, { 10, 37 }, { 12, 18 },
+	{ 6, 29 }, { 20, 33 }, { 15, 30 }, { 4, 45 },
+	{ 1, 58 }, { 0, 62 }, { 7, 61 }, { 12, 38 },
+	{ 11, 45 }, { 15, 39 }, { 11, 42 }, { 13, 44 },
+	{ 16, 45 }, { 12, 41 }, { 10, 49 }, { 30, 34 },
+	{ 18, 42 }, { 10, 55 }, { 17, 51 }, { 17, 46 },
+	{ 0, 89 }, { 26, -19 }, { 22, -17 },
+	/* 197 -> 226 */
+	{ 26, -17 }, { 30, -25 }, { 28, -20 }, { 33, -23 },
+	{ 37, -27 }, { 33, -23 }, { 40, -28 }, { 38, -17 },
+	{ 33, -11 }, { 40, -15 }, { 41, -6 }, { 38, 1 },
+	{ 41, 17 }, { 30, -6 }, { 27, 3 }, { 26, 22 },
+	{ 37, -16 }, { 35, -4 }, { 38, -8 }, { 38, -3 },
+	{ 37, 3 }, { 38, 5 }, { 42, 0 }, { 35, 16 },
+	{ 39, 22 }, { 14, 48 }, { 27, 37 }, { 21, 60 },
+	{ 12, 68 }, { 2, 97 },
+	/* 227 -> 251 */
+	{ -3, 71 }, { -6, 42 }, { -5, 50 }, { -3, 54 },
+	{ -2, 62 }, { 0, 58 }, { 1, 63 }, { -2, 72 },
+	{ -1, 74 }, { -9, 91 }, { -5, 67 }, { -5, 27 },
+	{ -3, 39 }, { -2, 44 }, { 0, 46 }, { -16, 64 },
+	{ -8, 68 }, { -10, 78 }, { -6, 77 }, { -10, 86 },
+	{ -12, 92 }, { -15, 55 }, { -10, 60 }, { -6, 62 },
+	{ -4, 65 },
+	/* 252 -> 275 */
+	{ -12, 73 }, { -8, 76 }, { -7, 80 }, { -9, 88 },
+	{ -17, 110 }, { -11, 97 }, { -20, 84 }, { -11, 79 },
+	{ -6, 73 }, { -4, 74 }, { -13, 86 }, { -13, 96 },
+	{ -11, 97 }, { -19, 117 }, { -8, 78 }, { -5, 33 },
+	{ -4, 48 }, { -2, 53 }, { -3, 62 }, { -13, 71 },
+	{ -10, 79 }, { -12, 86 }, { -13, 90 }, { -14, 97 },
+	/* 276 special case, bypass used */
+	{ 0, 0 },
+	/* 277 -> 307 */
+	{ -6, 93 }, { -6, 84 }, { -8, 79 }, { 0, 66 },
+	{ -1, 71 }, { 0, 62 }, { -2, 60 }, { -2, 59 },
+	{ -5, 75 }, { -3, 62 }, { -4, 58 }, { -9, 66 },
+	{ -1, 79 }, { 0, 71 }, { 3, 68 }, { 10, 44 },
+	{ -7, 62 }, { 15, 36 }, { 14, 40 }, { 16, 27 },
+	{ 12, 29 }, { 1, 44 }, { 20, 36 }, { 18, 32 },
+	{ 5, 42 }, { 1, 48 }, { 10, 62 }, { 17, 46 },
+	{ 9, 64 }, { -12, 104 }, { -11, 97 },
+	/* 308 -> 337 */
+	{ -16, 96 }, { -7, 88 }, { -8, 85 }, { -7, 85 },
+	{ -9, 85 }, { -13, 88 }, { 4, 66 }, { -3, 77 },
+	{ -3, 76 }, { -6, 76 }, { 10, 58 }, { -1, 76 },
+	{ -1, 83 }, { -7, 99 }, { -14, 95 }, { 2, 95 },
+	{ 0, 76 }, { -5, 74 }, { 0, 70 }, { -11, 75 },
+	{ 1, 68 }, { 0, 65 }, { -14, 73 }, { 3, 62 },
+	{ 4, 62 }, { -1, 68 }, { -13, 75 }, { 11, 55 },
+	{ 5, 64 }, { 12, 70 },
+	/* 338 -> 368 */
+	{ 15, 6 }, { 6, 19 }, { 7, 16 }, { 12, 14 },
+	{ 18, 13 }, { 13, 11 }, { 13, 15 }, { 15, 16 },
+	{ 12, 23 }, { 13, 23 }, { 15, 20 }, { 14, 26 },
+	{ 14, 44 }, { 17, 40 }, { 17, 47 }, { 24, 17 },
+	{ 21, 21 }, { 25, 22 }, { 31, 27 }, { 22, 29 },
+	{ 19, 35 }, { 14, 50 }, { 10, 57 }, { 7, 63 },
+	{ -2, 77 }, { -4, 82 }, { -3, 94 }, { 9, 69 },
+	{ -12, 109 }, { 36, -35 }, { 36, -34 },
+	/* 369 -> 398 */
+	{ 32, -26 }, { 37, -30 }, { 44, -32 }, { 34, -18 },
+	{ 34, -15 }, { 40, -15 }, { 33, -7 }, { 35, -5 },
+	{ 33, 0 }, { 38, 2 }, { 33, 13 }, { 23, 35 },
+	{ 13, 58 }, { 29, -3 }, { 26, 0 }, { 22, 30 },
+	{ 31, -7 }, { 35, -15 }, { 34, -3 }, { 34, 3 },
+	{ 36, -1 }, { 34, 5 }, { 32, 11 }, { 35, 5 },
+	{ 34, 12 }, { 39, 11 }, { 30, 29 }, { 34, 26 },
+	{ 29, 39 }, { 19, 66 },
+	/* 399 -> 435 */
+	{ 31, 21 }, { 31, 31 }, { 25, 50 },
+	{ -17, 120 }, { -20, 112 }, { -18, 114 }, { -11, 85 },
+	{ -15, 92 }, { -14, 89 }, { -26, 71 }, { -15, 81 },
+	{ -14, 80 }, { 0, 68 }, { -14, 70 }, { -24, 56 },
+	{ -23, 68 }, { -24, 50 }, { -11, 74 }, { 23, -13 },
+	{ 26, -13 }, { 40, -15 }, { 49, -14 }, { 44, 3 },
+	{ 45, 6 }, { 44, 34 }, { 33, 54 }, { 19, 82 },
+	{ -3, 75 }, { -1, 23 }, { 1, 34 }, { 1, 43 },
+	{ 0, 54 }, { -2, 55 }, { 0, 61 }, { 1, 64 },
+	{ 0, 68 }, { -9, 92 },
+	/* 436 -> 459 */
+	{ -14, 106 }, { -13, 97 }, { -15, 90 }, { -12, 90 },
+	{ -18, 88 }, { -10, 73 }, { -9, 79 }, { -14, 86 },
+	{ -10, 73 }, { -10, 70 }, { -10, 69 }, { -5, 66 },
+	{ -9, 64 }, { -5, 58 }, { 2, 59 }, { 21, -10 },
+	{ 24, -11 }, { 28, -8 }, { 28, -1 }, { 29, 3 },
+	{ 29, 9 }, { 35, 20 }, { 29, 36 }, { 14, 67 }
+};
+
+static const s32 h264_context_init[HANTRO_H264_CABAC_IDC_NUM][HANTRO_H264_CABAC_CV_NUM][2] = {
+	/* cabac_init_idc == 0 */
+	{
+		/* 0 -> 10 */
+		{ 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
+		{ 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
+		{ -6, 53 }, { -1, 54 }, { 7, 51 },
+		/* 11 -> 23 */
+		{ 23, 33 }, { 23, 2 }, { 21, 0 }, { 1, 9 },
+		{ 0, 49 }, { -37, 118 }, { 5, 57 }, { -13, 78 },
+		{ -11, 65 }, { 1, 62 }, { 12, 49 }, { -4, 73 },
+		{ 17, 50 },
+		/* 24 -> 39 */
+		{ 18, 64 }, { 9, 43 }, { 29, 0 }, { 26, 67 },
+		{ 16, 90 }, { 9, 104 }, { -46, 127 }, { -20, 104 },
+		{ 1, 67 }, { -13, 78 }, { -11, 65 }, { 1, 62 },
+		{ -6, 86 }, { -17, 95 }, { -6, 61 }, { 9, 45 },
+		/* 40 -> 53 */
+		{ -3, 69 }, { -6, 81 }, { -11, 96 }, { 6, 55 },
+		{ 7, 67 }, { -5, 86 }, { 2, 88 }, { 0, 58 },
+		{ -3, 76 }, { -10, 94 }, { 5, 54 }, { 4, 69 },
+		{ -3, 81 }, { 0, 88 },
+		/* 54 -> 59 */
+		{ -7, 67 }, { -5, 74 }, { -4, 74 }, { -5, 80 },
+		{ -7, 72 }, { 1, 58 },
+		/* 60 -> 69 */
+		{ 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
+		{ -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
+		{ 13, 41 }, { 3, 62 },
+		/* 70 -> 87 */
+		{ 0, 45 }, { -4, 78 }, { -3, 96 }, { -27, 126 },
+		{ -28, 98 }, { -25, 101 }, { -23, 67 }, { -28, 82 },
+		{ -20, 94 }, { -16, 83 }, { -22, 110 }, { -21, 91 },
+		{ -18, 102 }, { -13, 93 }, { -29, 127 }, { -7, 92 },
+		{ -5, 89 }, { -7, 96 }, { -13, 108 }, { -3, 46 },
+		{ -1, 65 }, { -1, 57 }, { -9, 93 }, { -3, 74 },
+		{ -9, 92 }, { -8, 87 }, { -23, 126 }, { 5, 54 },
+		{ 6, 60 }, { 6, 59 }, { 6, 69 }, { -1, 48 },
+		{ 0, 68 }, { -4, 69 }, { -8, 88 },
+		/* 105 -> 165 */
+		{ -2, 85 }, { -6, 78 }, { -1, 75 }, { -7, 77 },
+		{ 2, 54 }, { 5, 50 }, { -3, 68 }, { 1, 50 },
+		{ 6, 42 }, { -4, 81 }, { 1, 63 }, { -4, 70 },
+		{ 0, 67 }, { 2, 57 }, { -2, 76 }, { 11, 35 },
+		{ 4, 64 }, { 1, 61 }, { 11, 35 }, { 18, 25 },
+		{ 12, 24 }, { 13, 29 }, { 13, 36 }, { -10, 93 },
+		{ -7, 73 }, { -2, 73 }, { 13, 46 }, { 9, 49 },
+		{ -7, 100 }, { 9, 53 }, { 2, 53 }, { 5, 53 },
+		{ -2, 61 }, { 0, 56 }, { 0, 56 }, { -13, 63 },
+		{ -5, 60 }, { -1, 62 }, { 4, 57 }, { -6, 69 },
+		{ 4, 57 }, { 14, 39 }, { 4, 51 }, { 13, 68 },
+		{ 3, 64 }, { 1, 61 }, { 9, 63 }, { 7, 50 },
+		{ 16, 39 }, { 5, 44 }, { 4, 52 }, { 11, 48 },
+		{ -5, 60 }, { -1, 59 }, { 0, 59 }, { 22, 33 },
+		{ 5, 44 }, { 14, 43 }, { -1, 78 }, { 0, 60 },
+		{ 9, 69 },
+		/* 166 -> 226 */
+		{ 11, 28 }, { 2, 40 }, { 3, 44 }, { 0, 49 },
+		{ 0, 46 }, { 2, 44 }, { 2, 51 }, { 0, 47 },
+		{ 4, 39 }, { 2, 62 }, { 6, 46 }, { 0, 54 },
+		{ 3, 54 }, { 2, 58 }, { 4, 63 }, { 6, 51 },
+		{ 6, 57 }, { 7, 53 }, { 6, 52 }, { 6, 55 },
+		{ 11, 45 }, { 14, 36 }, { 8, 53 }, { -1, 82 },
+		{ 7, 55 }, { -3, 78 }, { 15, 46 }, { 22, 31 },
+		{ -1, 84 }, { 25, 7 }, { 30, -7 }, { 28, 3 },
+		{ 28, 4 }, { 32, 0 }, { 34, -1 }, { 30, 6 },
+		{ 30, 6 }, { 32, 9 }, { 31, 19 }, { 26, 27 },
+		{ 26, 30 }, { 37, 20 }, { 28, 34 }, { 17, 70 },
+		{ 1, 67 }, { 5, 59 }, { 9, 67 }, { 16, 30 },
+		{ 18, 32 }, { 18, 35 }, { 22, 29 }, { 24, 31 },
+		{ 23, 38 }, { 18, 43 }, { 20, 41 }, { 11, 63 },
+		{ 9, 59 }, { 9, 64 }, { -1, 94 }, { -2, 89 },
+		{ -9, 108 },
+		/* 227 -> 275 */
+		{ -6, 76 }, { -2, 44 }, { 0, 45 }, { 0, 52 },
+		{ -3, 64 }, { -2, 59 }, { -4, 70 }, { -4, 75 },
+		{ -8, 82 }, { -17, 102 }, { -9, 77 }, { 3, 24 },
+		{ 0, 42 }, { 0, 48 }, { 0, 55 }, { -6, 59 },
+		{ -7, 71 }, { -12, 83 }, { -11, 87 }, { -30, 119 },
+		{ 1, 58 }, { -3, 29 }, { -1, 36 }, { 1, 38 },
+		{ 2, 43 }, { -6, 55 }, { 0, 58 }, { 0, 64 },
+		{ -3, 74 }, { -10, 90 }, { 0, 70 }, { -4, 29 },
+		{ 5, 31 }, { 7, 42 }, { 1, 59 }, { -2, 58 },
+		{ -3, 72 }, { -3, 81 }, { -11, 97 }, { 0, 58 },
+		{ 8, 5 }, { 10, 14 }, { 14, 18 }, { 13, 27 },
+		{ 2, 40 }, { 0, 58 }, { -3, 70 }, { -6, 79 },
+		{ -8, 85 },
+		/* 276 special case, bypass used */
+		{ 0, 0 },
+		/* 277 -> 337 */
+		{ -13, 106 }, { -16, 106 }, { -10, 87 }, { -21, 114 },
+		{ -18, 110 }, { -14, 98 }, { -22, 110 }, { -21, 106 },
+		{ -18, 103 }, { -21, 107 }, { -23, 108 }, { -26, 112 },
+		{ -10, 96 }, { -12, 95 }, { -5, 91 }, { -9, 93 },
+		{ -22, 94 }, { -5, 86 }, { 9, 67 }, { -4, 80 },
+		{ -10, 85 }, { -1, 70 }, { 7, 60 }, { 9, 58 },
+		{ 5, 61 }, { 12, 50 }, { 15, 50 }, { 18, 49 },
+		{ 17, 54 }, { 10, 41 }, { 7, 46 }, { -1, 51 },
+		{ 7, 49 }, { 8, 52 }, { 9, 41 }, { 6, 47 },
+		{ 2, 55 }, { 13, 41 }, { 10, 44 }, { 6, 50 },
+		{ 5, 53 }, { 13, 49 }, { 4, 63 }, { 6, 64 },
+		{ -2, 69 }, { -2, 59 }, { 6, 70 }, { 10, 44 },
+		{ 9, 31 }, { 12, 43 }, { 3, 53 }, { 14, 34 },
+		{ 10, 38 }, { -3, 52 }, { 13, 40 }, { 17, 32 },
+		{ 7, 44 }, { 7, 38 }, { 13, 50 }, { 10, 57 },
+		{ 26, 43 },
+		/* 338 -> 398 */
+		{ 14, 11 }, { 11, 14 }, { 9, 11 }, { 18, 11 },
+		{ 21, 9 }, { 23, -2 }, { 32, -15 }, { 32, -15 },
+		{ 34, -21 }, { 39, -23 }, { 42, -33 }, { 41, -31 },
+		{ 46, -28 }, { 38, -12 }, { 21, 29 }, { 45, -24 },
+		{ 53, -45 }, { 48, -26 }, { 65, -43 }, { 43, -19 },
+		{ 39, -10 }, { 30, 9 }, { 18, 26 }, { 20, 27 },
+		{ 0, 57 }, { -14, 82 }, { -5, 75 }, { -19, 97 },
+		{ -35, 125 }, { 27, 0 }, { 28, 0 }, { 31, -4 },
+		{ 27, 6 }, { 34, 8 }, { 30, 10 }, { 24, 22 },
+		{ 33, 19 }, { 22, 32 }, { 26, 31 }, { 21, 41 },
+		{ 26, 44 }, { 23, 47 }, { 16, 65 }, { 14, 71 },
+		{ 8, 60 }, { 6, 63 }, { 17, 65 }, { 21, 24 },
+		{ 23, 20 }, { 26, 23 }, { 27, 32 }, { 28, 23 },
+		{ 28, 24 }, { 23, 40 }, { 24, 32 }, { 28, 29 },
+		{ 23, 42 }, { 19, 57 }, { 22, 53 }, { 22, 61 },
+		{ 11, 86 },
+		/* 399 -> 435 */
+		{ 12, 40 }, { 11, 51 }, { 14, 59 },
+		{ -4, 79 }, { -7, 71 }, { -5, 69 }, { -9, 70 },
+		{ -8, 66 }, { -10, 68 }, { -19, 73 }, { -12, 69 },
+		{ -16, 70 }, { -15, 67 }, { -20, 62 }, { -19, 70 },
+		{ -16, 66 }, { -22, 65 }, { -20, 63 }, { 9, -2 },
+		{ 26, -9 }, { 33, -9 }, { 39, -7 }, { 41, -2 },
+		{ 45, 3 }, { 49, 9 }, { 45, 27 }, { 36, 59 },
+		{ -6, 66 }, { -7, 35 }, { -7, 42 }, { -8, 45 },
+		{ -5, 48 }, { -12, 56 }, { -6, 60 }, { -5, 62 },
+		{ -8, 66 }, { -8, 76 },
+		/* 436 -> 459 */
+		{ -5, 85 }, { -6, 81 }, { -10, 77 }, { -7, 81 },
+		{ -17, 80 }, { -18, 73 }, { -4, 74 }, { -10, 83 },
+		{ -9, 71 }, { -9, 67 }, { -1, 61 }, { -8, 66 },
+		{ -14, 66 }, { 0, 59 }, { 2, 59 }, { 21, -13 },
+		{ 33, -14 }, { 39, -7 }, { 46, -2 }, { 51, 2 },
+		{ 60, 6 }, { 61, 17 }, { 55, 34 }, { 42, 62 },
+	},
+	/* cabac_init_idc == 1 */
+	{
+		/* 0 -> 10 */
+		{ 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
+		{ 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
+		{ -6, 53 }, { -1, 54 }, { 7, 51 },
+		/* 11 -> 23 */
+		{ 22, 25 }, { 34, 0 }, { 16, 0 }, { -2, 9 },
+		{ 4, 41 }, { -29, 118 }, { 2, 65 }, { -6, 71 },
+		{ -13, 79 }, { 5, 52 }, { 9, 50 }, { -3, 70 },
+		{ 10, 54 },
+		/* 24 -> 39 */
+		{ 26, 34 }, { 19, 22 }, { 40, 0 }, { 57, 2 },
+		{ 41, 36 }, { 26, 69 }, { -45, 127 }, { -15, 101 },
+		{ -4, 76 }, { -6, 71 }, { -13, 79 }, { 5, 52 },
+		{ 6, 69 }, { -13, 90 }, { 0, 52 }, { 8, 43 },
+		/* 40 -> 53 */
+		{ -2, 69 }, { -5, 82 }, { -10, 96 }, { 2, 59 },
+		{ 2, 75 }, { -3, 87 }, { -3, 100 }, { 1, 56 },
+		{ -3, 74 }, { -6, 85 }, { 0, 59 }, { -3, 81 },
+		{ -7, 86 }, { -5, 95 },
+		/* 54 -> 59 */
+		{ -1, 66 }, { -1, 77 }, { 1, 70 }, { -2, 86 },
+		{ -5, 72 }, { 0, 61 },
+		/* 60 -> 69 */
+		{ 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
+		{ -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
+		{ 13, 41 }, { 3, 62 },
+		/* 70 -> 104 */
+		{ 13, 15 }, { 7, 51 }, { 2, 80 }, { -39, 127 },
+		{ -18, 91 }, { -17, 96 }, { -26, 81 }, { -35, 98 },
+		{ -24, 102 }, { -23, 97 }, { -27, 119 }, { -24, 99 },
+		{ -21, 110 }, { -18, 102 }, { -36, 127 }, { 0, 80 },
+		{ -5, 89 }, { -7, 94 }, { -4, 92 }, { 0, 39 },
+		{ 0, 65 }, { -15, 84 }, { -35, 127 }, { -2, 73 },
+		{ -12, 104 }, { -9, 91 }, { -31, 127 }, { 3, 55 },
+		{ 7, 56 }, { 7, 55 }, { 8, 61 }, { -3, 53 },
+		{ 0, 68 }, { -7, 74 }, { -9, 88 },
+		/* 105 -> 165 */
+		{ -13, 103 }, { -13, 91 }, { -9, 89 }, { -14, 92 },
+		{ -8, 76 }, { -12, 87 }, { -23, 110 }, { -24, 105 },
+		{ -10, 78 }, { -20, 112 }, { -17, 99 }, { -78, 127 },
+		{ -70, 127 }, { -50, 127 }, { -46, 127 }, { -4, 66 },
+		{ -5, 78 }, { -4, 71 }, { -8, 72 }, { 2, 59 },
+		{ -1, 55 }, { -7, 70 }, { -6, 75 }, { -8, 89 },
+		{ -34, 119 }, { -3, 75 }, { 32, 20 }, { 30, 22 },
+		{ -44, 127 }, { 0, 54 }, { -5, 61 }, { 0, 58 },
+		{ -1, 60 }, { -3, 61 }, { -8, 67 }, { -25, 84 },
+		{ -14, 74 }, { -5, 65 }, { 5, 52 }, { 2, 57 },
+		{ 0, 61 }, { -9, 69 }, { -11, 70 }, { 18, 55 },
+		{ -4, 71 }, { 0, 58 }, { 7, 61 }, { 9, 41 },
+		{ 18, 25 }, { 9, 32 }, { 5, 43 }, { 9, 47 },
+		{ 0, 44 }, { 0, 51 }, { 2, 46 }, { 19, 38 },
+		{ -4, 66 }, { 15, 38 }, { 12, 42 }, { 9, 34 },
+		{ 0, 89 },
+		/* 166 -> 226 */
+		{ 4, 45 }, { 10, 28 }, { 10, 31 }, { 33, -11 },
+		{ 52, -43 }, { 18, 15 }, { 28, 0 }, { 35, -22 },
+		{ 38, -25 }, { 34, 0 }, { 39, -18 }, { 32, -12 },
+		{ 102, -94 }, { 0, 0 }, { 56, -15 }, { 33, -4 },
+		{ 29, 10 }, { 37, -5 }, { 51, -29 }, { 39, -9 },
+		{ 52, -34 }, { 69, -58 }, { 67, -63 }, { 44, -5 },
+		{ 32, 7 }, { 55, -29 }, { 32, 1 }, { 0, 0 },
+		{ 27, 36 }, { 33, -25 }, { 34, -30 }, { 36, -28 },
+		{ 38, -28 }, { 38, -27 }, { 34, -18 }, { 35, -16 },
+		{ 34, -14 }, { 32, -8 }, { 37, -6 }, { 35, 0 },
+		{ 30, 10 }, { 28, 18 }, { 26, 25 }, { 29, 41 },
+		{ 0, 75 }, { 2, 72 }, { 8, 77 }, { 14, 35 },
+		{ 18, 31 }, { 17, 35 }, { 21, 30 }, { 17, 45 },
+		{ 20, 42 }, { 18, 45 }, { 27, 26 }, { 16, 54 },
+		{ 7, 66 }, { 16, 56 }, { 11, 73 }, { 10, 67 },
+		{ -10, 116 },
+		/* 227 -> 275 */
+		{ -23, 112 }, { -15, 71 }, { -7, 61 }, { 0, 53 },
+		{ -5, 66 }, { -11, 77 }, { -9, 80 }, { -9, 84 },
+		{ -10, 87 }, { -34, 127 }, { -21, 101 }, { -3, 39 },
+		{ -5, 53 }, { -7, 61 }, { -11, 75 }, { -15, 77 },
+		{ -17, 91 }, { -25, 107 }, { -25, 111 }, { -28, 122 },
+		{ -11, 76 }, { -10, 44 }, { -10, 52 }, { -10, 57 },
+		{ -9, 58 }, { -16, 72 }, { -7, 69 }, { -4, 69 },
+		{ -5, 74 }, { -9, 86 }, { 2, 66 }, { -9, 34 },
+		{ 1, 32 }, { 11, 31 }, { 5, 52 }, { -2, 55 },
+		{ -2, 67 }, { 0, 73 }, { -8, 89 }, { 3, 52 },
+		{ 7, 4 }, { 10, 8 }, { 17, 8 }, { 16, 19 },
+		{ 3, 37 }, { -1, 61 }, { -5, 73 }, { -1, 70 },
+		{ -4, 78 },
+		/* 276 special case, bypass used */
+		{ 0, 0 },
+		/* 277 -> 337 */
+		{ -21, 126 }, { -23, 124 }, { -20, 110 }, { -26, 126 },
+		{ -25, 124 }, { -17, 105 }, { -27, 121 }, { -27, 117 },
+		{ -17, 102 }, { -26, 117 }, { -27, 116 }, { -33, 122 },
+		{ -10, 95 }, { -14, 100 }, { -8, 95 }, { -17, 111 },
+		{ -28, 114 }, { -6, 89 }, { -2, 80 }, { -4, 82 },
+		{ -9, 85 }, { -8, 81 }, { -1, 72 }, { 5, 64 },
+		{ 1, 67 }, { 9, 56 }, { 0, 69 }, { 1, 69 },
+		{ 7, 69 }, { -7, 69 }, { -6, 67 }, { -16, 77 },
+		{ -2, 64 }, { 2, 61 }, { -6, 67 }, { -3, 64 },
+		{ 2, 57 }, { -3, 65 }, { -3, 66 }, { 0, 62 },
+		{ 9, 51 }, { -1, 66 }, { -2, 71 }, { -2, 75 },
+		{ -1, 70 }, { -9, 72 }, { 14, 60 }, { 16, 37 },
+		{ 0, 47 }, { 18, 35 }, { 11, 37 }, { 12, 41 },
+		{ 10, 41 }, { 2, 48 }, { 12, 41 }, { 13, 41 },
+		{ 0, 59 }, { 3, 50 }, { 19, 40 }, { 3, 66 },
+		{ 18, 50 },
+		/* 338 -> 398 */
+		{ 19, -6 }, { 18, -6 }, { 14, 0 }, { 26, -12 },
+		{ 31, -16 }, { 33, -25 }, { 33, -22 }, { 37, -28 },
+		{ 39, -30 }, { 42, -30 }, { 47, -42 }, { 45, -36 },
+		{ 49, -34 }, { 41, -17 }, { 32, 9 }, { 69, -71 },
+		{ 63, -63 }, { 66, -64 }, { 77, -74 }, { 54, -39 },
+		{ 52, -35 }, { 41, -10 }, { 36, 0 }, { 40, -1 },
+		{ 30, 14 }, { 28, 26 }, { 23, 37 }, { 12, 55 },
+		{ 11, 65 }, { 37, -33 }, { 39, -36 }, { 40, -37 },
+		{ 38, -30 }, { 46, -33 }, { 42, -30 }, { 40, -24 },
+		{ 49, -29 }, { 38, -12 }, { 40, -10 }, { 38, -3 },
+		{ 46, -5 }, { 31, 20 }, { 29, 30 }, { 25, 44 },
+		{ 12, 48 }, { 11, 49 }, { 26, 45 }, { 22, 22 },
+		{ 23, 22 }, { 27, 21 }, { 33, 20 }, { 26, 28 },
+		{ 30, 24 }, { 27, 34 }, { 18, 42 }, { 25, 39 },
+		{ 18, 50 }, { 12, 70 }, { 21, 54 }, { 14, 71 },
+		{ 11, 83 },
+		/* 399 -> 435 */
+		{ 25, 32 }, { 21, 49 }, { 21, 54 },
+		{ -5, 85 }, { -6, 81 }, { -10, 77 }, { -7, 81 },
+		{ -17, 80 }, { -18, 73 }, { -4, 74 }, { -10, 83 },
+		{ -9, 71 }, { -9, 67 }, { -1, 61 }, { -8, 66 },
+		{ -14, 66 }, { 0, 59 }, { 2, 59 }, { 17, -10 },
+		{ 32, -13 }, { 42, -9 }, { 49, -5 }, { 53, 0 },
+		{ 64, 3 }, { 68, 10 }, { 66, 27 }, { 47, 57 },
+		{ -5, 71 }, { 0, 24 }, { -1, 36 }, { -2, 42 },
+		{ -2, 52 }, { -9, 57 }, { -6, 63 }, { -4, 65 },
+		{ -4, 67 }, { -7, 82 },
+		/* 436 -> 459 */
+		{ -3, 81 }, { -3, 76 }, { -7, 72 }, { -6, 78 },
+		{ -12, 72 }, { -14, 68 }, { -3, 70 }, { -6, 76 },
+		{ -5, 66 }, { -5, 62 }, { 0, 57 }, { -4, 61 },
+		{ -9, 60 }, { 1, 54 }, { 2, 58 }, { 17, -10 },
+		{ 32, -13 }, { 42, -9 }, { 49, -5 }, { 53, 0 },
+		{ 64, 3 }, { 68, 10 }, { 66, 27 }, { 47, 57 },
+	},
+	/* cabac_init_idc == 2 */
+	{
+		/* 0 -> 10 */
+		{ 20, -15 }, { 2, 54 }, { 3, 74 }, { 20, -15 },
+		{ 2, 54 }, { 3, 74 }, { -28, 127 }, { -23, 104 },
+		{ -6, 53 }, { -1, 54 }, { 7, 51 },
+		/* 11 -> 23 */
+		{ 29, 16 }, { 25, 0 }, { 14, 0 }, { -10, 51 },
+		{ -3, 62 }, { -27, 99 }, { 26, 16 }, { -4, 85 },
+		{ -24, 102 }, { 5, 57 }, { 6, 57 }, { -17, 73 },
+		{ 14, 57 },
+		/* 24 -> 39 */
+		{ 20, 40 }, { 20, 10 }, { 29, 0 }, { 54, 0 },
+		{ 37, 42 }, { 12, 97 }, { -32, 127 }, { -22, 117 },
+		{ -2, 74 }, { -4, 85 }, { -24, 102 }, { 5, 57 },
+		{ -6, 93 }, { -14, 88 }, { -6, 44 }, { 4, 55 },
+		/* 40 -> 53 */
+		{ -11, 89 }, { -15, 103 }, { -21, 116 }, { 19, 57 },
+		{ 20, 58 }, { 4, 84 }, { 6, 96 }, { 1, 63 },
+		{ -5, 85 }, { -13, 106 }, { 5, 63 }, { 6, 75 },
+		{ -3, 90 }, { -1, 101 },
+		/* 54 -> 59 */
+		{ 3, 55 }, { -4, 79 }, { -2, 75 }, { -12, 97 },
+		{ -7, 50 }, { 1, 60 },
+		/* 60 -> 69 */
+		{ 0, 41 }, { 0, 63 }, { 0, 63 }, { 0, 63 },
+		{ -9, 83 }, { 4, 86 }, { 0, 97 }, { -7, 72 },
+		{ 13, 41 }, { 3, 62 },
+		/* 70 -> 104 */
+		{ 7, 34 }, { -9, 88 }, { -20, 127 }, { -36, 127 },
+		{ -17, 91 }, { -14, 95 }, { -25, 84 }, { -25, 86 },
+		{ -12, 89 }, { -17, 91 }, { -31, 127 }, { -14, 76 },
+		{ -18, 103 }, { -13, 90 }, { -37, 127 }, { 11, 80 },
+		{ 5, 76 }, { 2, 84 }, { 5, 78 }, { -6, 55 },
+		{ 4, 61 }, { -14, 83 }, { -37, 127 }, { -5, 79 },
+		{ -11, 104 }, { -11, 91 }, { -30, 127 }, { 0, 65 },
+		{ -2, 79 }, { 0, 72 }, { -4, 92 }, { -6, 56 },
+		{ 3, 68 }, { -8, 71 }, { -13, 98 },
+		/* 105 -> 165 */
+		{ -4, 86 }, { -12, 88 }, { -5, 82 }, { -3, 72 },
+		{ -4, 67 }, { -8, 72 }, { -16, 89 }, { -9, 69 },
+		{ -1, 59 }, { 5, 66 }, { 4, 57 }, { -4, 71 },
+		{ -2, 71 }, { 2, 58 }, { -1, 74 }, { -4, 44 },
+		{ -1, 69 }, { 0, 62 }, { -7, 51 }, { -4, 47 },
+		{ -6, 42 }, { -3, 41 }, { -6, 53 }, { 8, 76 },
+		{ -9, 78 }, { -11, 83 }, { 9, 52 }, { 0, 67 },
+		{ -5, 90 }, { 1, 67 }, { -15, 72 }, { -5, 75 },
+		{ -8, 80 }, { -21, 83 }, { -21, 64 }, { -13, 31 },
+		{ -25, 64 }, { -29, 94 }, { 9, 75 }, { 17, 63 },
+		{ -8, 74 }, { -5, 35 }, { -2, 27 }, { 13, 91 },
+		{ 3, 65 }, { -7, 69 }, { 8, 77 }, { -10, 66 },
+		{ 3, 62 }, { -3, 68 }, { -20, 81 }, { 0, 30 },
+		{ 1, 7 }, { -3, 23 }, { -21, 74 }, { 16, 66 },
+		{ -23, 124 }, { 17, 37 }, { 44, -18 }, { 50, -34 },
+		{ -22, 127 },
+		/* 166 -> 226 */
+		{ 4, 39 }, { 0, 42 }, { 7, 34 }, { 11, 29 },
+		{ 8, 31 }, { 6, 37 }, { 7, 42 }, { 3, 40 },
+		{ 8, 33 }, { 13, 43 }, { 13, 36 }, { 4, 47 },
+		{ 3, 55 }, { 2, 58 }, { 6, 60 }, { 8, 44 },
+		{ 11, 44 }, { 14, 42 }, { 7, 48 }, { 4, 56 },
+		{ 4, 52 }, { 13, 37 }, { 9, 49 }, { 19, 58 },
+		{ 10, 48 }, { 12, 45 }, { 0, 69 }, { 20, 33 },
+		{ 8, 63 }, { 35, -18 }, { 33, -25 }, { 28, -3 },
+		{ 24, 10 }, { 27, 0 }, { 34, -14 }, { 52, -44 },
+		{ 39, -24 }, { 19, 17 }, { 31, 25 }, { 36, 29 },
+		{ 24, 33 }, { 34, 15 }, { 30, 20 }, { 22, 73 },
+		{ 20, 34 }, { 19, 31 }, { 27, 44 }, { 19, 16 },
+		{ 15, 36 }, { 15, 36 }, { 21, 28 }, { 25, 21 },
+		{ 30, 20 }, { 31, 12 }, { 27, 16 }, { 24, 42 },
+		{ 0, 93 }, { 14, 56 }, { 15, 57 }, { 26, 38 },
+		{ -24, 127 },
+		/* 227 -> 275 */
+		{ -24, 115 }, { -22, 82 }, { -9, 62 }, { 0, 53 },
+		{ 0, 59 }, { -14, 85 }, { -13, 89 }, { -13, 94 },
+		{ -11, 92 }, { -29, 127 }, { -21, 100 }, { -14, 57 },
+		{ -12, 67 }, { -11, 71 }, { -10, 77 }, { -21, 85 },
+		{ -16, 88 }, { -23, 104 }, { -15, 98 }, { -37, 127 },
+		{ -10, 82 }, { -8, 48 }, { -8, 61 }, { -8, 66 },
+		{ -7, 70 }, { -14, 75 }, { -10, 79 }, { -9, 83 },
+		{ -12, 92 }, { -18, 108 }, { -4, 79 }, { -22, 69 },
+		{ -16, 75 }, { -2, 58 }, { 1, 58 }, { -13, 78 },
+		{ -9, 83 }, { -4, 81 }, { -13, 99 }, { -13, 81 },
+		{ -6, 38 }, { -13, 62 }, { -6, 58 }, { -2, 59 },
+		{ -16, 73 }, { -10, 76 }, { -13, 86 }, { -9, 83 },
+		{ -10, 87 },
+		/* 276 special case, bypass used */
+		{ 0, 0 },
+		/* 277 -> 337 */
+		{ -22, 127 }, { -25, 127 }, { -25, 120 }, { -27, 127 },
+		{ -19, 114 }, { -23, 117 }, { -25, 118 }, { -26, 117 },
+		{ -24, 113 }, { -28, 118 }, { -31, 120 }, { -37, 124 },
+		{ -10, 94 }, { -15, 102 }, { -10, 99 }, { -13, 106 },
+		{ -50, 127 }, { -5, 92 }, { 17, 57 }, { -5, 86 },
+		{ -13, 94 }, { -12, 91 }, { -2, 77 }, { 0, 71 },
+		{ -1, 73 }, { 4, 64 }, { -7, 81 }, { 5, 64 },
+		{ 15, 57 }, { 1, 67 }, { 0, 68 }, { -10, 67 },
+		{ 1, 68 }, { 0, 77 }, { 2, 64 }, { 0, 68 },
+		{ -5, 78 }, { 7, 55 }, { 5, 59 }, { 2, 65 },
+		{ 14, 54 }, { 15, 44 }, { 5, 60 }, { 2, 70 },
+		{ -2, 76 }, { -18, 86 }, { 12, 70 }, { 5, 64 },
+		{ -12, 70 }, { 11, 55 }, { 5, 56 }, { 0, 69 },
+		{ 2, 65 }, { -6, 74 }, { 5, 54 }, { 7, 54 },
+		{ -6, 76 }, { -11, 82 }, { -2, 77 }, { -2, 77 },
+		{ 25, 42 },
+		/* 338 -> 398 */
+		{ 17, -13 }, { 16, -9 }, { 17, -12 }, { 27, -21 },
+		{ 37, -30 }, { 41, -40 }, { 42, -41 }, { 48, -47 },
+		{ 39, -32 }, { 46, -40 }, { 52, -51 }, { 46, -41 },
+		{ 52, -39 }, { 43, -19 }, { 32, 11 }, { 61, -55 },
+		{ 56, -46 }, { 62, -50 }, { 81, -67 }, { 45, -20 },
+		{ 35, -2 }, { 28, 15 }, { 34, 1 }, { 39, 1 },
+		{ 30, 17 }, { 20, 38 }, { 18, 45 }, { 15, 54 },
+		{ 0, 79 }, { 36, -16 }, { 37, -14 }, { 37, -17 },
+		{ 32, 1 }, { 34, 15 }, { 29, 15 }, { 24, 25 },
+		{ 34, 22 }, { 31, 16 }, { 35, 18 }, { 31, 28 },
+		{ 33, 41 }, { 36, 28 }, { 27, 47 }, { 21, 62 },
+		{ 18, 31 }, { 19, 26 }, { 36, 24 }, { 24, 23 },
+		{ 27, 16 }, { 24, 30 }, { 31, 29 }, { 22, 41 },
+		{ 22, 42 }, { 16, 60 }, { 15, 52 }, { 14, 60 },
+		{ 3, 78 }, { -16, 123 }, { 21, 53 }, { 22, 56 },
+		{ 25, 61 },
+		/* 399 -> 435 */
+		{ 21, 33 }, { 19, 50 }, { 17, 61 },
+		{ -3, 78 }, { -8, 74 }, { -9, 72 }, { -10, 72 },
+		{ -18, 75 }, { -12, 71 }, { -11, 63 }, { -5, 70 },
+		{ -17, 75 }, { -14, 72 }, { -16, 67 }, { -8, 53 },
+		{ -14, 59 }, { -9, 52 }, { -11, 68 }, { 9, -2 },
+		{ 30, -10 }, { 31, -4 }, { 33, -1 }, { 33, 7 },
+		{ 31, 12 }, { 37, 23 }, { 31, 38 }, { 20, 64 },
+		{ -9, 71 }, { -7, 37 }, { -8, 44 }, { -11, 49 },
+		{ -10, 56 }, { -12, 59 }, { -8, 63 }, { -9, 67 },
+		{ -6, 68 }, { -10, 79 },
+		/* 436 -> 459 */
+		{ -3, 78 }, { -8, 74 }, { -9, 72 }, { -10, 72 },
+		{ -18, 75 }, { -12, 71 }, { -11, 63 }, { -5, 70 },
+		{ -17, 75 }, { -14, 72 }, { -16, 67 }, { -8, 53 },
+		{ -14, 59 }, { -9, 52 }, { -11, 68 }, { 9, -2 },
+		{ 30, -10 }, { 31, -4 }, { 33, -1 }, { 33, 7 },
+		{ 31, 12 }, { 37, 23 }, { 31, 38 }, { 20, 64 },
+	}
+};
+
 static void
 assemble_scaling_list(struct hantro_ctx *ctx)
 {
@@ -519,3 +1099,202 @@ int hantro_h264_dec_init(struct hantro_ctx *ctx)
 
 	return 0;
 }
+
+void hantro_h264_enc_exit(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	int i;
+
+	dma_free_coherent(vpu->dev, ctx->h264_enc.segment_map.size,
+			  ctx->h264_enc.segment_map.cpu,
+			  ctx->h264_enc.segment_map.dma);
+
+	dma_free_coherent(vpu->dev, ctx->h264_enc.mv_buf.size,
+			  ctx->h264_enc.mv_buf.cpu,
+			  ctx->h264_enc.mv_buf.dma);
+
+	i = HANTRO_H264_CABAC_IDC_NUM;
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->h264_enc.cabac_ctx[i].size,
+				  ctx->h264_enc.cabac_ctx[i].cpu,
+				  ctx->h264_enc.cabac_ctx[i].dma);
+
+	dma_free_coherent(vpu->dev, ctx->h264_enc.nal_table.size,
+			  ctx->h264_enc.nal_table.cpu,
+			  ctx->h264_enc.nal_table.dma);
+
+	i = HANTRO_H264_NUM_INTERNAL_FRAMES;
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->h264_enc.chroma_internal[i].size,
+				  ctx->h264_enc.chroma_internal[i].cpu,
+				  ctx->h264_enc.chroma_internal[i].dma);
+	i = HANTRO_H264_NUM_INTERNAL_FRAMES;
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->h264_enc.luma_internal[i].size,
+				  ctx->h264_enc.luma_internal[i].cpu,
+				  ctx->h264_enc.luma_internal[i].dma);
+}
+
+#define LUMA_MB_BYTES_W 16
+#define LUMA_MB_BYTES_H 16
+#define LUMA_MB_BYTES (LUMA_MB_BYTES_W * LUMA_MB_BYTES_H)
+#define CHROMA_MB_BYTES_W 8
+#define CHROMA_MB_BYTES_H 8
+#define CHROMA_MB_BYTES (CHROMA_MB_BYTES_W * CHROMA_MB_BYTES_H)
+#define N_CHROMA_PLANES 2
+#define NAL_ENTRY_BYTES 4
+#define N_QPS 52
+#define CABAC_CTX_TABLE_BYTES 464
+#define MB_MV_BYTES 56
+#define MB_SEGMENTATION_BITS 4
+
+static void buffer_cpu_to_be64(u64 *buf, u32 size)
+{
+	u32 i;
+
+	for (i = 0; i < size; ++i)
+		buf[i] = cpu_to_be64(buf[i]);
+}
+
+static void h264_enc_init_cabac_table(struct hantro_ctx *ctx)
+{
+	u8 *table;
+	const s32(*context)[HANTRO_H264_CABAC_CV_NUM][2];
+	s32 i, j, k, qp;
+
+	for (k = 0; k < HANTRO_H264_CABAC_IDC_NUM; k++) {
+		table = (u8 *)ctx->h264_enc.cabac_ctx[k].cpu;
+
+		for (qp = 0; qp < N_QPS; qp++) { /* All QP values */
+			for (j = 0; j < 2; j++) { /* Intra/Inter */
+				context = (j == 0) ?
+					&h264_context_init_intra :
+					&h264_context_init[k];
+				for (i = 0; i < HANTRO_H264_CABAC_CV_NUM; i++) {
+					s32 m = (s32)(*context)[i][0];
+					s32 n = (s32)(*context)[i][1];
+					s32 pre_ctx_st = clamp(((m * qp) >> 4) + n, 1, 126);
+					int idx = qp * 464 * 2 + j * 464 + i;
+
+					if (pre_ctx_st <= 63)
+						table[idx] = (u8)((63 - pre_ctx_st) << 1);
+					else
+						table[idx] = (u8)(((pre_ctx_st - 64) << 1) | 1);
+				}
+			}
+		}
+
+		buffer_cpu_to_be64((u64 *)table, 2 * N_QPS * CABAC_CTX_TABLE_BYTES / sizeof(u64));
+	}
+}
+
+int hantro_h264_enc_init(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	struct hantro_aux_buf *aux_buf;
+	unsigned int mb_width, mb_height, mb_total;
+	int ret, i;
+
+	mb_width = DIV_ROUND_UP(ctx->src_fmt.width, 16);
+	mb_height = DIV_ROUND_UP(ctx->src_fmt.height, 16);
+	mb_total = mb_width * mb_height;
+
+	for (i = 0; i < HANTRO_H264_NUM_INTERNAL_FRAMES; ++i) {
+		aux_buf = &ctx->h264_enc.luma_internal[i];
+		aux_buf->size = mb_total * LUMA_MB_BYTES;
+		aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+						  &aux_buf->dma, GFP_KERNEL);
+		if (!aux_buf->cpu) {
+			ret = -ENOMEM;
+			goto err_free_luma_internal;
+		}
+	}
+
+	for (i = 0; i < HANTRO_H264_NUM_INTERNAL_FRAMES; ++i) {
+		aux_buf = &ctx->h264_enc.chroma_internal[i];
+		aux_buf->size = N_CHROMA_PLANES * mb_total * CHROMA_MB_BYTES;
+		aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+						  &aux_buf->dma, GFP_KERNEL);
+		if (!aux_buf->cpu) {
+			ret = -ENOMEM;
+			goto err_free_chroma_internal;
+		}
+	}
+
+	aux_buf = &ctx->h264_enc.nal_table;
+	aux_buf->size = round_up(NAL_ENTRY_BYTES * (mb_height + 4), 8);
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+					  &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_chroma_internal;
+	}
+
+	for (i = 0; i < HANTRO_H264_CABAC_IDC_NUM; ++i) {
+		aux_buf = &ctx->h264_enc.cabac_ctx[i];
+		aux_buf->size = 2 * N_QPS * CABAC_CTX_TABLE_BYTES; /* 2: intra + inter */
+		aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+						  &aux_buf->dma, GFP_KERNEL);
+		if (!aux_buf->cpu) {
+			ret = -ENOMEM;
+			goto err_free_cabac_ctx;
+		}
+	}
+
+	aux_buf = &ctx->h264_enc.mv_buf;
+	aux_buf->size = mb_total * MB_MV_BYTES;
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+					  &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_cabac_ctx;
+	}
+
+	aux_buf = &ctx->h264_enc.segment_map;
+	aux_buf->size = round_up(mb_total * MB_SEGMENTATION_BITS, 64) * 8;
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+					  &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_mv_buf;
+	}
+
+	h264_enc_init_cabac_table(ctx);
+
+	ctx->h264_enc.last_prev_idx = -1;
+	ctx->h264_enc.last_idx = -1;
+	ctx->h264_enc.ltr_idx = -1;
+
+	return 0;
+
+err_free_mv_buf:
+	dma_free_coherent(vpu->dev, ctx->h264_enc.mv_buf.size,
+			  ctx->h264_enc.mv_buf.cpu,
+			  ctx->h264_enc.mv_buf.dma);
+
+err_free_cabac_ctx:
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->h264_enc.cabac_ctx[i].size,
+				  ctx->h264_enc.cabac_ctx[i].cpu,
+				  ctx->h264_enc.cabac_ctx[i].dma);
+
+	dma_free_coherent(vpu->dev, ctx->h264_enc.nal_table.size,
+			  ctx->h264_enc.nal_table.cpu,
+			  ctx->h264_enc.nal_table.dma);
+	i = HANTRO_H264_NUM_INTERNAL_FRAMES;
+
+err_free_chroma_internal:
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->h264_enc.chroma_internal[i].size,
+				  ctx->h264_enc.chroma_internal[i].cpu,
+				  ctx->h264_enc.chroma_internal[i].dma);
+	i = HANTRO_H264_NUM_INTERNAL_FRAMES;
+
+err_free_luma_internal:
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->h264_enc.luma_internal[i].size,
+				  ctx->h264_enc.luma_internal[i].cpu,
+				  ctx->h264_enc.luma_internal[i].dma);
+
+	return ret;
+}
diff --git a/drivers/media/platform/verisilicon/hantro_hw.h b/drivers/media/platform/verisilicon/hantro_hw.h
index e83f0c523..6aea756be 100644
--- a/drivers/media/platform/verisilicon/hantro_hw.h
+++ b/drivers/media/platform/verisilicon/hantro_hw.h
@@ -15,6 +15,8 @@
 #include <media/v4l2-vp9.h>
 #include <media/videobuf2-core.h>
 
+#include "hantro_boolenc.h"
+
 #define DEC_8190_ALIGN_MASK	0x07U
 
 #define MB_DIM			16
@@ -271,6 +273,85 @@ struct hantro_postproc_ops {
 	int (*enum_framesizes)(struct hantro_ctx *ctx, struct v4l2_frmsizeenum *fsize);
 };
 
+struct hantro_vp8_entropy {
+	/* TODO: int32_t? */
+	int32_t coeff_prob[4][8][3][11];
+	int32_t coeff_prob_old[4][8][3][11];
+	int32_t mv_prob[2][19];
+	int32_t mv_prob_old[2][19];
+	int32_t y_mode_prob[4];
+	int32_t uv_mode_prob[3];
+};
+
+#define VP8_BIT_LAST	0
+#define VP8_BIT_GOLDEN	1
+#define VP8_BIT_ALT	2
+
+struct hantro_vp8_enc_hw_ctx {
+	struct hantro_aux_buf ref_frames[4];	/* recreated and reference images */
+	struct hantro_aux_buf priv_src;	/* cabac table, segment map */
+	struct hantro_aux_buf mv_buf;	/* motion vector */
+	struct hantro_aux_buf priv_dst;	/* prob count */
+	struct hantro_aux_buf ctrl_buf;	/* size table */
+	struct hantro_boolenc boolenc;
+	struct hantro_vp8_entropy entropy;
+	size_t header_size;
+	size_t estimated_hdr_size;
+	size_t frame_counter;
+	int last_ref;
+	int golden_ref;
+	int alt_ref;
+	int first_free;
+	int reconstructed;
+	char ref_bitmaps[4];
+
+	int32_t mode_delta[4];
+	int32_t old_mode_delta[4];
+	int32_t ref_delta[4];
+	int32_t old_ref_delta[4];
+
+	struct {
+		uint8_t tag[3];
+
+		/* the following three only used for inter frames */
+		uint8_t magic[3];	/* 0x9d012a */
+		uint8_t width[2];	/* (scale << 14) | width */
+		uint8_t height[2];	/* (scale << 14) | height */
+	} __packed *frame_tag;
+
+	u8 is_intra:1;
+	u8 last_intra:1;
+	u8 show_frame:1;
+	u8 refresh_golden_frame:1;
+	u8 refresh_alternate_frame:1;
+	u8 refresh_entropy_probs:1;
+
+	u8 prob_skip_false;
+	u8 prob_intra;
+	u8 prob_last;
+	u8 prob_gf;
+	u8 copy_buffer_to_golden;
+	u8 copy_buffer_to_alternate;
+};
+
+#define HANTRO_H264_NUM_INTERNAL_FRAMES 4
+#define HANTRO_H264_CABAC_IDC_NUM	3
+#define HANTRO_H264_CABAC_CV_NUM	460
+
+struct hantro_h264_enc_hw_ctx {
+	struct hantro_aux_buf luma_internal[HANTRO_H264_NUM_INTERNAL_FRAMES];
+	struct hantro_aux_buf chroma_internal[HANTRO_H264_NUM_INTERNAL_FRAMES];
+	u64 reference_ts[HANTRO_H264_NUM_INTERNAL_FRAMES];
+	int last_idx;
+	int last_prev_idx;
+	int reconstr_idx;
+	int ltr_idx;
+	struct hantro_aux_buf nal_table;
+	struct hantro_aux_buf cabac_ctx[HANTRO_H264_CABAC_IDC_NUM];
+	struct hantro_aux_buf mv_buf;
+	struct hantro_aux_buf segment_map;
+};
+
 /**
  * struct hantro_codec_ops - codec mode specific operations
  *
@@ -300,12 +381,16 @@ struct hantro_codec_ops {
  * @ROCKCHIP_VPU_ENC_FMT_YUV420SP: Y/CbCr 4:2:0 semi-planar format
  * @ROCKCHIP_VPU_ENC_FMT_YUYV422: YUV 4:2:2 packed format (YUYV)
  * @ROCKCHIP_VPU_ENC_FMT_UYVY422: YUV 4:2:2 packed format (UYVY)
+ * @ROCKCHIP_VPU_ENC_FMT_RGB565:  RGB565 16 bits format
+ * @ROCKCHIP_VPU_ENC_FMT_RGB888:  RGB888 32 bits format
  */
 enum hantro_enc_fmt {
 	ROCKCHIP_VPU_ENC_FMT_YUV420P = 0,
 	ROCKCHIP_VPU_ENC_FMT_YUV420SP = 1,
 	ROCKCHIP_VPU_ENC_FMT_YUYV422 = 2,
 	ROCKCHIP_VPU_ENC_FMT_UYVY422 = 3,
+	ROCKCHIP_VPU_ENC_FMT_RGB565 = 4,
+	ROCKCHIP_VPU_ENC_FMT_RGB888 = 7,
 };
 
 extern const struct hantro_variant imx8mm_vpu_g1_variant;
@@ -322,6 +407,8 @@ extern const struct hantro_variant rk3568_vepu_variant;
 extern const struct hantro_variant rk3568_vpu_variant;
 extern const struct hantro_variant sama5d4_vdec_variant;
 extern const struct hantro_variant sunxi_vpu_variant;
+extern const struct hantro_variant stm32mp25_vdec_variant;
+extern const struct hantro_variant stm32mp25_venc_variant;
 
 extern const struct hantro_postproc_ops hantro_g1_postproc_ops;
 extern const struct hantro_postproc_ops hantro_g2_postproc_ops;
@@ -335,6 +422,7 @@ void hantro_irq_done(struct hantro_dev *vpu,
 void hantro_start_prepare_run(struct hantro_ctx *ctx);
 void hantro_end_prepare_run(struct hantro_ctx *ctx);
 
+void hantro_g1_check_idle(struct hantro_dev *vpu);
 irqreturn_t hantro_g1_irq(int irq, void *dev_id);
 void hantro_g1_reset(struct hantro_ctx *ctx);
 
@@ -417,6 +505,28 @@ hantro_hevc_mv_size(unsigned int width, unsigned int height)
 	return width * height / 16;
 }
 
+static inline void hantro_vp8_set_bit(struct hantro_vp8_enc_hw_ctx *vp8_enc, char bit, int idx)
+{
+	if (idx < 0)
+		return;
+
+	if (bit != VP8_BIT_LAST && bit != VP8_BIT_GOLDEN && bit != VP8_BIT_ALT)
+		return;
+
+	vp8_enc->ref_bitmaps[idx] |= (1 << bit);
+}
+
+static inline void hantro_vp8_clr_bit(struct hantro_vp8_enc_hw_ctx *vp8_enc, char bit, int idx)
+{
+	if (idx < 0)
+		return;
+
+	if (bit != VP8_BIT_LAST && bit != VP8_BIT_GOLDEN && bit != VP8_BIT_ALT)
+		return;
+
+	vp8_enc->ref_bitmaps[idx] &= ~(1 << bit);
+}
+
 int hantro_g1_mpeg2_dec_run(struct hantro_ctx *ctx);
 int rockchip_vpu2_mpeg2_dec_run(struct hantro_ctx *ctx);
 void hantro_mpeg2_dec_copy_qtable(u8 *qtable,
@@ -438,4 +548,17 @@ void hantro_vp9_dec_exit(struct hantro_ctx *ctx);
 void hantro_g2_check_idle(struct hantro_dev *vpu);
 irqreturn_t hantro_g2_irq(int irq, void *dev_id);
 
+int rockchip_vpu2_vp8_enc_run(struct hantro_ctx *ctx);
+int hantro_vp8_enc_init(struct hantro_ctx *ctx);
+void rockchip_vpu2_vp8_enc_done(struct hantro_ctx *ctx);
+void hantro_vp8_enc_exit(struct hantro_ctx *ctx);
+
+int hantro_h1_vp8_enc_run(struct hantro_ctx *ctx);
+void hantro_h1_vp8_enc_done(struct hantro_ctx *ctx);
+
+int hantro_h1_h264_enc_run(struct hantro_ctx *ctx);
+int hantro_h264_enc_init(struct hantro_ctx *ctx);
+void hantro_h1_h264_enc_done(struct hantro_ctx *ctx);
+void hantro_h264_enc_exit(struct hantro_ctx *ctx);
+
 #endif /* HANTRO_HW_H_ */
diff --git a/drivers/media/platform/verisilicon/hantro_v4l2.c b/drivers/media/platform/verisilicon/hantro_v4l2.c
index b2da48936..5c1fce012 100644
--- a/drivers/media/platform/verisilicon/hantro_v4l2.c
+++ b/drivers/media/platform/verisilicon/hantro_v4l2.c
@@ -315,8 +315,9 @@ static int hantro_try_fmt(const struct hantro_ctx *ctx,
 
 	pix_mp->field = V4L2_FIELD_NONE;
 
-	v4l2_apply_frmsize_constraints(&pix_mp->width, &pix_mp->height,
-				       &vpu_fmt->frmsize);
+	if (!capture || !ctx->is_encoder)
+		v4l2_apply_frmsize_constraints(&pix_mp->width, &pix_mp->height,
+					       &vpu_fmt->frmsize);
 
 	if (!coded) {
 		/* Fill remaining fields */
diff --git a/drivers/media/platform/verisilicon/hantro_vp8.c b/drivers/media/platform/verisilicon/hantro_vp8.c
index 381bc1d3b..63e026055 100644
--- a/drivers/media/platform/verisilicon/hantro_vp8.c
+++ b/drivers/media/platform/verisilicon/hantro_vp8.c
@@ -199,3 +199,121 @@ void hantro_vp8_dec_exit(struct hantro_ctx *ctx)
 	dma_free_coherent(vpu->dev, vp8_dec->prob_tbl.size,
 			  vp8_dec->prob_tbl.cpu, vp8_dec->prob_tbl.dma);
 }
+
+int hantro_vp8_enc_init(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	struct hantro_aux_buf *aux_buf;
+	unsigned int mb_width, mb_height;
+	size_t luma_size, segment_map_size;
+	static int32_t mode_delta[4] = { 4, -2, 2, 4 };
+	static int32_t ref_delta[4] = { 2, 0, -2, -2 };
+	int ret, i;
+
+	memcpy(ctx->vp8_enc.mode_delta, mode_delta, sizeof(mode_delta));
+	memcpy(ctx->vp8_enc.ref_delta, ref_delta, sizeof(ref_delta));
+
+	mb_width = DIV_ROUND_UP(ctx->src_fmt.width, 16);
+	mb_height = DIV_ROUND_UP(ctx->src_fmt.height, 16);
+	luma_size = mb_width * mb_height * 16 * 16;
+	segment_map_size = round_up(DIV_ROUND_UP(mb_width * mb_height, 4), 64);
+
+	for (i = 0; i < ARRAY_SIZE(ctx->vp8_enc.ref_frames); ++i) {
+		aux_buf = &ctx->vp8_enc.ref_frames[i];
+		aux_buf->size = luma_size * 3 / 2;
+		aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size,
+						  &aux_buf->dma, GFP_KERNEL);
+		if (!aux_buf->cpu) {
+			ret = -ENOMEM;
+			goto err_free_ref_frames;
+		}
+		ctx->vp8_enc.ref_bitmaps[i] = 0;
+	}
+	ctx->vp8_enc.last_ref = ctx->vp8_enc.golden_ref = ctx->vp8_enc.alt_ref = -1;
+	ctx->vp8_enc.first_free = 0;
+
+	aux_buf = &ctx->vp8_enc.priv_src;
+	aux_buf->size = 1208 + segment_map_size + PAGE_SIZE; /* TODO: eliminate one page overhead */
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size, &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_ref_frames;
+	}
+
+	aux_buf = &ctx->vp8_enc.mv_buf;
+	aux_buf->size = mb_width * mb_height * 4;
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size, &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_priv_src;
+	}
+
+	aux_buf = &ctx->vp8_enc.priv_dst;
+	aux_buf->size = PAGE_SIZE; /* TODO: use correct size */
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size, &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_mv_buf;
+	}
+
+	aux_buf = &ctx->vp8_enc.ctrl_buf;
+	aux_buf->size = PAGE_SIZE; /* TODO: use correct size */
+	aux_buf->cpu = dma_alloc_coherent(vpu->dev, aux_buf->size, &aux_buf->dma, GFP_KERNEL);
+	if (!aux_buf->cpu) {
+		ret = -ENOMEM;
+		goto err_free_priv_dst;
+	}
+
+	return 0;
+
+err_free_priv_dst:
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.priv_dst.size,
+			  ctx->vp8_enc.priv_dst.cpu,
+			  ctx->vp8_enc.priv_dst.dma);
+
+err_free_mv_buf:
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.mv_buf.size,
+			  ctx->vp8_enc.mv_buf.cpu,
+			  ctx->vp8_enc.mv_buf.dma);
+
+err_free_priv_src:
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.priv_src.size,
+			  ctx->vp8_enc.priv_src.cpu,
+			  ctx->vp8_enc.priv_src.dma);
+
+err_free_ref_frames:
+	while (--i >= 0)
+		dma_free_coherent(vpu->dev, ctx->vp8_enc.ref_frames[i].size,
+				  ctx->vp8_enc.ref_frames[i].cpu,
+				  ctx->vp8_enc.ref_frames[i].dma);
+
+	return ret;
+}
+
+void hantro_vp8_enc_exit(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	int i;
+
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.ctrl_buf.size,
+			  ctx->vp8_enc.ctrl_buf.cpu,
+			  ctx->vp8_enc.ctrl_buf.dma);
+
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.priv_dst.size,
+			  ctx->vp8_enc.priv_dst.cpu,
+			  ctx->vp8_enc.priv_dst.dma);
+
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.mv_buf.size,
+			  ctx->vp8_enc.mv_buf.cpu,
+			  ctx->vp8_enc.mv_buf.dma);
+
+	dma_free_coherent(vpu->dev, ctx->vp8_enc.priv_src.size,
+			  ctx->vp8_enc.priv_src.cpu,
+			  ctx->vp8_enc.priv_src.dma);
+
+	for (i = 0; i < ARRAY_SIZE(ctx->vp8_enc.ref_frames); ++i)
+		dma_free_coherent(vpu->dev, ctx->vp8_enc.ref_frames[i].size,
+				  ctx->vp8_enc.ref_frames[i].cpu,
+				  ctx->vp8_enc.ref_frames[i].dma);
+
+}
diff --git a/drivers/media/platform/verisilicon/rockchip_vpu2_hw_vp8_enc.c b/drivers/media/platform/verisilicon/rockchip_vpu2_hw_vp8_enc.c
new file mode 100644
index 000000000..95b14e3a8
--- /dev/null
+++ b/drivers/media/platform/verisilicon/rockchip_vpu2_hw_vp8_enc.c
@@ -0,0 +1,1574 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023 Collabora Ltd.
+ *	Andrzej Pietrasiewicz <andrzej.p@collabora.com>
+ *
+ * This work is derived from:
+ *
+ * https://chromium.googlesource.com/chromiumos/third_party/kernel/+/refs/heads/chromeos-5.10/
+ * drivers/media/platform/verisilicon/rk3399_vpu_hw_vp8_enc.c
+ *
+ * which is:
+ *
+ * Rockchip VPU codec driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd.
+ *	Alpha Lin <Alpha.Lin@rock-chips.com>
+ *
+ * Substantial portions are based on MIT-licensed code
+ *
+ * https://github.com/rockchip-linux/mpp/blob/develop/mpp/hal/vpu/vp8e/hal_vp8e_entropy.{c|h}
+ * https://github.com/rockchip-linux/mpp/blob/develop/mpp/hal/vpu/vp8e/hal_vp8e_table.{c|h}
+ *
+ * which is:
+ *
+ * Copyright (c) 2017 Rockchip Electronics Co., Ltd.
+ *
+ */
+#include <linux/minmax.h>
+
+#include "hantro.h"
+#include "hantro_hw.h"
+#include "rockchip_vpu2_regs.h"
+
+/* threshold of MBs count to disable quarter pixel mv for encode speed */
+#define MAX_MB_COUNT_TO_DISABLE_QUARTER_PIXEL_MV	3600
+
+/* threshold of MBs count to disable multi mv in one macro block */
+#define MAX_MB_COUNT_TO_DISABLE_SPLIT_MV		1584
+
+#define QINDEX_RANGE 128
+#define VP8_PROB_COUNT_MV_OFFSET 222
+
+#define MODE_DELTA_BPRED	0
+#define MODE_DELTA_ZEROMV	1
+#define MODE_DELTA_NEWMV	2
+#define MODE_DELTA_SPLITMV	3
+
+#define REF_DELTA_INTRA_MB	0
+#define REF_DELTA_LAST_REF	1
+#define REF_DELTA_GOLDEN	2
+#define REF_DELTA_ALT_REF	3
+
+/* experimentally fitted, 24.893*exp(0.02545*qp) */
+static const s32 split_penalty[QINDEX_RANGE] = {
+	24, 25, 26, 26, 27, 28, 29, 29,
+	30, 31, 32, 32, 33, 34, 35, 36,
+	37, 38, 39, 40, 41, 42, 43, 44,
+	45, 47, 48, 49, 50, 52, 53, 54,
+	56, 57, 59, 60, 62, 63, 65, 67,
+	68, 70, 72, 74, 76, 78, 80, 82,
+	84, 86, 88, 91, 93, 95, 98, 100,
+	103, 106, 108, 111, 114, 117, 120, 123,
+	126, 130, 133, 136, 140, 144, 147, 151,
+	155, 159, 163, 167, 172, 176, 181, 185,
+	190, 195, 200, 205, 211, 216, 222, 227,
+	233, 239, 245, 252, 258, 265, 272, 279,
+	286, 293, 301, 309, 317, 325, 333, 342,
+	351, 360, 369, 379, 388, 398, 409, 419,
+	430, 441, 453, 464, 476, 488, 501, 514,
+	527, 541, 555, 569, 584, 599, 614, 630
+};
+
+static const int dc_q_lookup[QINDEX_RANGE] = {
+	4,   5,   6,   7,   8,   9,   10,  10,  11,  12,
+	13,  14,  15,  16,  17,  17,  18,  19,  20,  20,
+	21,  21,  22,  22,  23,  23,  24,  25,  25,  26,
+	27,  28,  29,  30,  31,  32,  33,  34,  35,  36,
+	37,  37,  38,  39,  40,  41,  42,  43,  44,  45,
+	46,  46,  47,  48,  49,  50,  51,  52,  53,  54,
+	55,  56,  57,  58,  59,  60,  61,  62,  63,  64,
+	65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
+	75,  76,  76,  77,  78,  79,  80,  81,  82,  83,
+	84,  85,  86,  87,  88,  89,  91,  93,  95,  96,
+	98,  100, 101, 102, 104, 106, 108, 110, 112, 114,
+	116, 118, 122, 124, 126, 128, 130, 132, 134, 136,
+	138, 140, 143, 145, 148, 151, 154, 157
+};
+
+static const int ac_q_lookup[QINDEX_RANGE] = {
+	4,   5,   6,   7,   8,   9,   10,  11,  12,  13,
+	14,  15,  16,  17,  18,  19,  20,  21,  22,  23,
+	24,  25,  26,  27,  28,  29,  30,  31,  32,  33,
+	34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
+	44,  45,  46,  47,  48,  49,  50,  51,  52,  53,
+	54,  55,  56,  57,  58,  60,  62,  64,  66,  68,
+	70,  72,  74,  76,  78,  80,  82,  84,  86,  88,
+	90,  92,  94,  96,  98,  100, 102, 104, 106, 108,
+	110, 112, 114, 116, 119, 122, 125, 128, 131, 134,
+	137, 140, 143, 146, 149, 152, 155, 158, 161, 164,
+	167, 170, 173, 177, 181, 185, 189, 193, 197, 201,
+	205, 209, 213, 217, 221, 225, 229, 234, 239, 245,
+	249, 254, 259, 264, 269, 274, 279, 284
+};
+
+static const s32 qrounding_factors[QINDEX_RANGE] = {
+	56, 56, 56, 56, 56, 56, 56, 56, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
+	48, 48, 48, 48, 48, 48, 48, 48
+};
+
+static const s32 qzbin_factors[QINDEX_RANGE] = {
+	64, 64, 64, 64, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80, 80, 80,
+	80, 80, 80, 80, 80, 80, 80, 80
+};
+
+/* Intra 16x16 mode tree penalty values */
+static s32 intra_16_tree_penalty[] = {
+	305, 841, 914, 1082
+};
+
+/* Intra 4x4 mode tree penalty values */
+static s32 intra_4_tree_penalty[] = {
+	280, 622, 832, 1177, 1240, 1341, 1085, 1259, 1357, 1495
+};
+
+
+int32_t const offset_tbl[] = {
+	-1, -1, -1,  0,  1,  2, -1,  3,  4, -1,  5,  6, -1,  7,  8, -1,
+	9, 10, -1, 11, 12, 13, 14, 15, -1, 16, 17, -1, 18, 19, -1, 20,
+	21, -1, 22, 23, -1, 24, 25, -1, 26, 27, 28, 29, 30, -1, 31, 32,
+	-1, 33, 34, -1, 35, 36, -1, 37, 38, -1, 39, 40, -1, 41, 42, 43,
+	44, 45, -1, 46, 47, -1, 48, 49, -1, 50, 51, -1, 52, 53, -1, 54,
+	55, -1, 56, 57, -1, -1, -1, 58, 59, 60, 61, 62, 63, 64, 65, 66,
+	67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,
+	83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,
+	99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
+	115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
+	131, 132, 133, 134, 135, 136, 137, 138, -1, -1, -1, 139, 140, 141, 142, 143,
+	144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
+	160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
+	176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
+	192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
+	208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219
+};
+
+/* ~round((2*(2+exp((x+22)/39)) + (2+exp((x+15)/32)))/3) */
+static s32 weight[QINDEX_RANGE] = {
+	4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
+	4,  4,  4,  4,  4,  5,  5,  5,  5,  5,
+	5,  5,  5,  5,  5,  5,  5,  6,  6,  6,
+	6,  6,  6,  6,  6,  6,  6,  7,  7,  7,
+	7,  7,  7,  7,  7,  8,  8,  8,  8,  8,
+	8,  8,  9,  9,  9,  9,  9, 10, 10, 10,
+	10, 11, 11, 11, 12, 12, 13, 13, 13, 13,
+	14, 14, 14, 14, 15, 15, 15, 16, 16, 17,
+	17, 18, 18, 19, 19, 20, 20, 20, 21, 22,
+	23, 23, 24, 24, 25, 25, 26, 27, 28, 28,
+	29, 30, 31, 32, 32, 33, 34, 35, 36, 37,
+	38, 39, 40, 41, 42, 44, 44, 46, 47, 48,
+	50, 51, 52, 54, 55, 57, 58, 61
+};
+
+struct tree {
+	s32 value;       /* Bits describe the bool tree  */
+	s32 number;      /* Number, valid bit count in above tree */
+	s32 index[9];    /* Probability table index */
+};
+
+/* Motion vector tree */
+static struct tree mv_tree[] = {
+	{ 0, 3, { 0, 1, 2 } },        /* mv_0 000 */
+	{ 1, 3, { 0, 1, 2 } },        /* mv_1 001 */
+	{ 2, 3, { 0, 1, 3 } },        /* mv_2 010 */
+	{ 3, 3, { 0, 1, 3 } },        /* mv_3 011 */
+	{ 4, 3, { 0, 4, 5 } },        /* mv_4 100 */
+	{ 5, 3, { 0, 4, 5 } },        /* mv_5 101 */
+	{ 6, 3, { 0, 4, 6 } },        /* mv_6 110 */
+	{ 7, 3, { 0, 4, 6 } },        /* mv_7 111 */
+};
+
+/* If probability being zero is p, then average number of bits used to encode 0
+ * is log2(1/p), to encode 1 is log2(1/(1-p)).
+ *
+ * For example, if the probability of being zero is 0.5
+ * bin = 0 -> average bits used is log2(1/0.5)      = 1 bits/bin
+ * bin = 1 -> average bits used is log2(1/(1 - 0.5) = 1 bits/bin
+ *
+ * For example, if the probability of being zero is 0.95
+ * bin = 0 -> average bits used is log2(1/0.95)      = 0.074 bits/bin
+ * bin = 1 -> average bits used is log2(1/(1 - 0.95) = 4.321 bits/bin
+ *
+ * The cost[p] is average number of bits used to encode 0 if the probability is
+ * p / 256, scaled by a magic number 256,
+ * i.e., cost[p] = round(log2(256 / p) * 256).
+ */
+static const s32 vp8_prob_cost[] = {
+	2048, 2048, 1792, 1642, 1536, 1454, 1386, 1329, 1280, 1236,
+	1198, 1162, 1130, 1101, 1073, 1048, 1024, 1002,  980,  961,
+	942,  924,  906,  890,  874,  859,  845,  831,  817,  804,
+	792,  780,  768,  757,  746,  735,  724,  714,  705,  695,
+	686,  676,  668,  659,  650,  642,  634,  626,  618,  611,
+	603,  596,  589,  582,  575,  568,  561,  555,  548,  542,
+	536,  530,  524,  518,  512,  506,  501,  495,  490,  484,
+	479,  474,  468,  463,  458,  453,  449,  444,  439,  434,
+	430,  425,  420,  416,  412,  407,  403,  399,  394,  390,
+	386,  382,  378,  374,  370,  366,  362,  358,  355,  351,
+	347,  343,  340,  336,  333,  329,  326,  322,  319,  315,
+	312,  309,  305,  302,  299,  296,  292,  289,  286,  283,
+	280,  277,  274,  271,  268,  265,  262,  259,  256,  253,
+	250,  247,  245,  242,  239,  236,  234,  231,  228,  226,
+	223,  220,  218,  215,  212,  210,  207,  205,  202,  200,
+	197,  195,  193,  190,  188,  185,  183,  181,  178,  176,
+	174,  171,  169,  167,  164,  162,  160,  158,  156,  153,
+	151,  149,  147,  145,  143,  140,  138,  136,  134,  132,
+	130,  128,  126,  124,  122,  120,  118,  116,  114,  112,
+	110,  108,  106,  104,  102,  101,   99,   97,   95,   93,
+	91,   89,   87,   86,   84,   82,   80,   78,   77,   75,
+	73,   71,   70,   68,   66,   64,   63,   61,   59,   58,
+	56,   54,   53,   51,   49,   48,   46,   44,   43,   41,
+	40,   38,   36,   35,   33,   32,   30,   28,   27,   25,
+	24,   22,   21,   19,   18,   16,   15,   13,   12,   10,
+	9,    7,    6,    4,    3,    1
+};
+
+/* Approximate bit cost of bin at given probability prob */
+#define COST_BOOL(prob, bin)	vp8_prob_cost[(bin) ? 255 - (prob) : (prob)]
+
+uint32_t const coeff_update_prob[4][8][3][11] = {
+	{
+		{
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},
+			{249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},
+			{234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
+			{250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	}, {
+		{
+			{217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
+			{234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255},
+		}, {
+			{255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	}, {
+		{
+			{186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},
+			{234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},
+			{251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255},
+		}, {
+			{255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	}, {
+		{
+			{248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},
+			{248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},
+			{248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},
+			{250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		}, {
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+			{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
+		},
+	},
+};
+
+uint32_t const mv_update_prob[2][19] = {
+	{
+		237, 246, 253, 253, 254, 254, 254, 254, 254, 254,
+		254, 254, 254, 254, 250, 250, 252, 254, 254
+	}, {
+		231, 243, 245, 253, 254, 254, 254, 254, 254, 254,
+		254, 254, 254, 254, 251, 251, 254, 254, 254
+	}
+};
+
+uint8_t const default_prob_skip_false[128] = {
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	255, 255, 255, 255, 255, 255, 255, 255,
+	251, 248, 244, 240, 236, 232, 229, 225,
+	221, 217, 213, 208, 204, 199, 194, 190,
+	187, 183, 179, 175, 172, 168, 164, 160,
+	157, 153, 149, 145, 142, 138, 134, 130,
+	127, 124, 120, 117, 114, 110, 107, 104,
+	101, 98,  95,  92,  89,  86,  83, 80,
+	77,  74,  71,  68,  65,  62,  59, 56,
+	53,  50,  47,  44,  41,  38,  35, 32,
+	30,  28,  26,  24,  22,  20,  18, 16,
+};
+
+int32_t const y_mode_prob[4] = {
+	112, 86, 140, 37
+};
+
+int32_t const uv_mode_prob[3] = {
+	162, 101, 204
+};
+
+uint32_t const default_prob_coeff[4][8][3][11] = {
+	{
+		{
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
+			{189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
+			{106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128},
+		}, {
+			{  1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
+			{181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
+			{ 78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128},
+		}, {
+			{  1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
+			{184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
+			{ 77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
+			{170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
+			{ 37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128},
+		}, {
+			{  1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
+			{207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
+			{102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
+			{177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
+			{ 80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128},
+		}, {
+			{  1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+		},
+	}, {
+		{
+			{198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
+			{131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
+			{ 68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128},
+		}, {
+			{  1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
+			{184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
+			{ 81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128},
+		}, {
+			{  1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
+			{ 99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
+			{ 23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128},
+		}, {
+			{  1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
+			{109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
+			{ 44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128},
+		}, {
+			{  1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
+			{ 94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
+			{ 22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128},
+		}, {
+			{  1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
+			{124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
+			{ 35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128},
+		}, {
+			{  1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
+			{121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
+			{ 45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128},
+		}, {
+			{  1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
+			{203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
+			{137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128},
+		},
+	}, {
+		{
+			{253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
+			{175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
+			{ 73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128},
+		}, {
+			{  1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
+			{239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
+			{155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128},
+		}, {
+			{  1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
+			{201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
+			{ 69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128},
+		}, {
+			{  1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
+			{223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
+			{141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128},
+		}, {
+			{  1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
+			{190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
+			{149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{  1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
+			{213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
+			{ 55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		}, {
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+			{128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
+		},
+	}, {
+		{
+			{202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
+			{126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
+			{ 61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128},
+		}, {
+			{  1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
+			{166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
+			{ 39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128},
+		}, {
+			{  1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
+			{124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
+			{ 24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128},
+		}, {
+			{  1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
+			{149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
+			{ 28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128},
+		}, {
+			{  1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
+			{123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
+			{ 20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128},
+		}, {
+			{  1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
+			{168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
+			{ 47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128},
+		}, {
+			{  1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
+			{141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
+			{ 42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128},
+		}, {
+			{  1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+			{238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
+		},
+	}
+};
+
+uint32_t const default_prob_mv[2][19] = {
+	{
+		162, 128, 225, 146, 172, 147, 214,  39, 156, 128,
+		129, 132,  75, 145, 178, 206, 239, 254, 254,
+	}, {
+		164, 128, 204, 170, 119, 235, 140, 230, 228, 128,
+		130, 130,  74, 148, 180, 203, 236, 254, 254,
+	},
+};
+
+struct hantro_vp8_enc_ctrl_buf {
+	u32 hw_hdr_size;
+	u32 dct_size;
+	u8 reserved[1016];
+};
+
+static inline bool is_intra(struct hantro_ctx *ctx)
+{
+	return ctx->vp8_enc.is_intra;
+}
+
+static inline size_t frame_tag_size(struct hantro_ctx *ctx)
+{
+	return is_intra(ctx) ? 10 : 3;
+}
+
+static void rockchip_vpu2_vp8_enc_write_coeff_prob(struct hantro_ctx *ctx)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+
+	int i, j, k, l;
+	uint32_t prob, new, old;
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 8; j++) {
+			for (k = 0; k < 3; k++) {
+				for (l = 0; l < 11; l++) {
+					prob = coeff_update_prob[i][j][k][l];
+
+					old = entropy->coeff_prob_old[i][j][k][l];
+					new = entropy->coeff_prob[i][j][k][l];
+
+					if (new == old) {
+						hantro_boolenc_write_bool(e, prob, 0);
+					} else {
+						hantro_boolenc_write_bool(e, prob, 1);
+						hantro_boolenc_write_lit(e, new, 8);
+					}
+				}
+			}
+		}
+	}
+}
+
+static void rockchip_vpu2_vp8_enc_write_mv_prob(struct hantro_ctx *ctx)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+
+	int i, j;
+	uint32_t prob, new, old;
+
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 19; j++) {
+			prob = mv_update_prob[i][j];
+			old = entropy->mv_prob_old[i][j];
+			new = entropy->mv_prob[i][j];
+
+			if (new == old) {
+				hantro_boolenc_write_bool(e, prob, 0);
+			} else {
+				hantro_boolenc_write_bool(e, prob, 1);
+				hantro_boolenc_write_lit(e, new >> 1, 7);
+			}
+		}
+	}
+}
+
+static void rockchip_vpu2_vp8_enc_write_filter_level_delta(struct hantro_ctx *ctx)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	int32_t i, tmp;
+	uint8_t  update = 0;
+	int32_t mode_update[4];
+	int32_t ref_update[4];
+
+	if (is_intra(ctx)) {
+		memset(ctx->vp8_enc.old_mode_delta, 0, sizeof(ctx->vp8_enc.old_mode_delta));
+		memset(ctx->vp8_enc.old_ref_delta, 0, sizeof(ctx->vp8_enc.old_ref_delta));
+	}
+
+	for (i = 0; i < 4; i++) {
+		mode_update[i] = ctx->vp8_enc.mode_delta[i] != ctx->vp8_enc.old_mode_delta[i];
+		ref_update[i] = ctx->vp8_enc.ref_delta[i] != ctx->vp8_enc.old_ref_delta[i];
+		if (mode_update[i] || ref_update[i])
+			update = 1;
+	}
+
+	if (!ctx->vp8_enc.refresh_entropy_probs)
+		update = 1;
+
+	hantro_boolenc_write_lit(e, update, 1);
+	if (!update)
+		return;
+
+	for (i = 0; i < 4; i++) {
+		hantro_boolenc_write_lit(e, ref_update[i], 1);
+		if (ref_update[i]) {
+			tmp = ctx->vp8_enc.ref_delta[i];
+			hantro_boolenc_write_lit(e, abs(tmp), 6);
+			hantro_boolenc_write_lit(e, tmp < 0, 1);
+		}
+	}
+
+	for (i = 0; i < 4; i++) {
+		hantro_boolenc_write_lit(e, mode_update[i], 1);
+		if (mode_update[i]) {
+			tmp = ctx->vp8_enc.mode_delta[i];
+			hantro_boolenc_write_lit(e, abs(tmp), 6);
+			hantro_boolenc_write_lit(e, tmp < 0, 1);
+		}
+	}
+
+	memcpy(ctx->vp8_enc.old_mode_delta, ctx->vp8_enc.mode_delta,
+	       sizeof(ctx->vp8_enc.old_mode_delta));
+	memcpy(ctx->vp8_enc.old_ref_delta, ctx->vp8_enc.ref_delta,
+	       sizeof(ctx->vp8_enc.old_ref_delta));
+}
+
+static void rockchip_vpu2_vp8_enc_write_header(struct hantro_ctx *ctx, u32 qp,
+					       struct v4l2_ctrl_vp8_encode_params *params)
+{
+	struct hantro_boolenc *e = &ctx->vp8_enc.boolenc;
+	struct vb2_v4l2_buffer *dst_buf = hantro_get_dst_buf(ctx);
+	void *vaddr = vb2_plane_vaddr(&dst_buf->vb2_buf, 0);
+
+	ctx->vp8_enc.frame_tag = vaddr;
+	memset(ctx->vp8_enc.frame_tag, 0, sizeof(*ctx->vp8_enc.frame_tag));
+	ctx->vp8_enc.frame_tag->tag[0] |= (1 << 1);	/* version 1 */
+	if (ctx->vp8_enc.show_frame)
+		ctx->vp8_enc.frame_tag->tag[0] |= (1 << 4);
+	/* first partition size is known only after encoding */
+
+	if (is_intra(ctx)) {
+		ctx->vp8_enc.frame_tag->magic[0] = 0x9d;
+		ctx->vp8_enc.frame_tag->magic[1] = 0x01;
+		ctx->vp8_enc.frame_tag->magic[2] = 0x2a;
+
+		ctx->vp8_enc.frame_tag->width[0] = ctx->src_fmt.width & 0xff;
+		ctx->vp8_enc.frame_tag->width[1] = (ctx->src_fmt.width >> 8) & 0xff;
+
+		ctx->vp8_enc.frame_tag->height[0] = ctx->src_fmt.height & 0xff;
+		ctx->vp8_enc.frame_tag->height[1] = (ctx->src_fmt.height >> 8) & 0xff;
+	} else {
+		ctx->vp8_enc.frame_tag->tag[0] |= 0x1;
+	}
+
+	hantro_boolenc_init(e, vaddr + frame_tag_size(ctx));
+
+	if (is_intra(ctx)) {
+		hantro_boolenc_write_lit(e, params->color_space, 1);
+		hantro_boolenc_write_lit(e, params->clamping_type, 1);
+	}
+
+	hantro_boolenc_write_lit(e, !!(params->flags & V4L2_VP8_FRAME_FLAG_SEGMENT_ENABLED), 1);
+
+	hantro_boolenc_write_lit(e, params->loop_filter_type, 1);
+	hantro_boolenc_write_lit(e, params->loop_filter_level, 6);
+	hantro_boolenc_write_lit(e, params->sharpness_level, 3);
+	hantro_boolenc_write_lit(e, !!(params->flags & V4L2_VP8_FRAME_FLAG_LOOP_FILTER_ADJ_ENABLED),
+				 1);
+	if (params->flags & V4L2_VP8_FRAME_FLAG_LOOP_FILTER_ADJ_ENABLED)
+		rockchip_vpu2_vp8_enc_write_filter_level_delta(ctx);
+
+	hantro_boolenc_write_lit(e, params->log2_nbr_of_dct_partitions, 2);
+
+	hantro_boolenc_write_lit(e, qp, 7);
+
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+	hantro_boolenc_write_lit(e, 0, 1);
+
+	if (!is_intra(ctx)) {
+		hantro_boolenc_write_lit(e, 0, 1); /* refresh golden */
+		hantro_boolenc_write_lit(e, 0, 1); /* refresh alt */
+		hantro_boolenc_write_lit(e, 0, 2); /* copy to golden */
+		hantro_boolenc_write_lit(e, 0, 2); /* copy to alt */
+		hantro_boolenc_write_lit(e, 0, 1); /* sign bias golden */
+		hantro_boolenc_write_lit(e, 0, 1); /* sign bias alt */
+		hantro_boolenc_write_lit(e, ctx->vp8_enc.refresh_entropy_probs, 1);
+		hantro_boolenc_write_lit(e, 1, 1);
+	} else {
+		hantro_boolenc_write_lit(e, ctx->vp8_enc.refresh_entropy_probs, 1);
+	}
+
+	rockchip_vpu2_vp8_enc_write_coeff_prob(ctx);
+
+	hantro_boolenc_write_lit(e, 1, 1);
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_skip_false, 8);
+
+	if (is_intra(ctx))
+		return;
+
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_intra, 8);
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_last, 8);
+	hantro_boolenc_write_lit(e, ctx->vp8_enc.prob_gf, 8);
+	hantro_boolenc_write_lit(e, 0, 1); /* intra 16x16 prob update flag */
+	hantro_boolenc_write_lit(e, 0, 1); /* intra chroma prob update flag */
+
+	rockchip_vpu2_vp8_enc_write_mv_prob(ctx);
+}
+
+static uint32_t calc_mvprob(uint32_t left, uint32_t right, uint32_t prob)
+{
+	uint32_t p;
+
+	if (left + right) {
+		p = (left * 255) / (left + right);
+		p &= -2;
+		if (!p)
+			p = 1;
+	} else {
+		p = prob;
+	}
+
+	return p;
+}
+
+static uint32_t update_prob(uint32_t prob, uint32_t left, uint32_t right,
+			    uint32_t old_prob, uint32_t new_prob, uint32_t fixed)
+{
+	int32_t u, s;
+
+	u = (int32_t)fixed + ((vp8_prob_cost[255 - prob] - vp8_prob_cost[prob]) >> 8);
+	s = ((int32_t)left * (vp8_prob_cost[old_prob] - vp8_prob_cost[new_prob]) +
+		(int32_t)right *
+		(vp8_prob_cost[255 - old_prob] - vp8_prob_cost[255 - new_prob])) >> 8;
+
+	return (s > u);
+}
+
+static void rockchip_vpu2_vp8_enc_update_entropy(struct hantro_ctx *ctx)
+{
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+	uint16_t *p_cnt = (uint16_t *)ctx->vp8_enc.priv_dst.cpu;
+
+	int32_t i, j, k, l;
+
+	uint32_t p, left, right;
+	uint32_t old_p, upd_p = 0;
+
+	uint32_t type;
+	uint32_t branch_cnt[2];
+	uint16_t *p_tmp = NULL;
+
+	if (!ctx->vp8_enc.refresh_entropy_probs || is_intra(ctx)) {
+		memcpy(entropy->coeff_prob, default_prob_coeff, sizeof(default_prob_coeff));
+		memcpy(entropy->mv_prob, default_prob_mv, sizeof(default_prob_mv));
+	}
+
+	memcpy(entropy->coeff_prob_old, entropy->coeff_prob, sizeof(entropy->coeff_prob));
+	if (ctx->vp8_enc.frame_counter == 0 || !ctx->vp8_enc.last_intra)
+		memcpy(entropy->mv_prob_old, entropy->mv_prob, sizeof(entropy->mv_prob));
+
+	if (!ctx->vp8_enc.frame_counter)
+		return;
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 7; j++) {
+			for (k = 0; k < 3; k++) {
+				int32_t tmp, ii;
+
+				tmp = i * 7 * 3 + j * 3 + k;
+				tmp += 2 * 4 * 7 * 3;
+				ii = offset_tbl[tmp];
+
+				right = ii >= 0 ? p_cnt[ii] : 0;
+
+				for (l = 2; l--;) {
+					old_p = entropy->coeff_prob[i][j][k][l];
+					old_p = coeff_update_prob[i][j][k][l];
+
+					tmp -= 4 * 7 * 3;
+					ii = offset_tbl[tmp];
+					left = ii >= 0 ? p_cnt[ii] : 0;
+					if (left + right) {
+						p = ((left * 256) + ((left + right) >> 1)) /
+						    (left + right);
+						if (p > 255)
+							p = 255;
+					} else {
+						p = old_p;
+					}
+
+					if (update_prob(upd_p, left, right, old_p, p, 8))
+						entropy->coeff_prob[i][j][k][l] = p;
+
+					right += left;
+				}
+			}
+		}
+	}
+
+	p_tmp = p_cnt + VP8_PROB_COUNT_MV_OFFSET;
+	for (i = 0; i < 2; i++) {
+		left  = *p_tmp++;
+		right = *p_tmp++;
+
+		p = calc_mvprob(left, right, entropy->mv_prob_old[i][0]);
+
+		if (update_prob(mv_update_prob[i][0], left, right,
+				entropy->mv_prob_old[i][0], p, 6))
+			entropy->mv_prob[i][0] = p;
+
+		right += left;
+		left = *p_tmp++;
+		right -= left - p_tmp[0];
+
+		p = calc_mvprob(left, right, entropy->mv_prob_old[i][1]);
+		if (update_prob(mv_update_prob[i][1], left, right,
+				entropy->mv_prob_old[i][1], p, 6))
+			entropy->mv_prob[i][1] = p;
+
+		for (j = 0; j < 2; j++) {
+			left = *p_tmp++;
+			right = *p_tmp++;
+			p = calc_mvprob(left, right, entropy->mv_prob_old[i][4 + j]);
+			if (update_prob(mv_update_prob[i][4 + j], left, right,
+					entropy->mv_prob_old[i][4 + j], p, 6))
+				entropy->mv_prob[i][4 + j] = p;
+			branch_cnt[j] = left + right;
+		}
+
+		p = calc_mvprob(branch_cnt[0], branch_cnt[1], entropy->mv_prob_old[i][3]);
+		if (update_prob(mv_update_prob[i][3], branch_cnt[0], branch_cnt[1],
+				entropy->mv_prob_old[i][3], p, 6))
+			entropy->mv_prob[i][3] = p;
+
+		type = branch_cnt[0] + branch_cnt[1];
+
+		for (j = 0; j < 2; j++) {
+			left = *p_tmp++;
+			right = *p_tmp++;
+			p = calc_mvprob(left, right, entropy->mv_prob_old[i][7 + j]);
+			if (update_prob(mv_update_prob[i][7 + j], left, right,
+					entropy->mv_prob_old[i][7 + j], p, 6))
+				entropy->mv_prob[i][7 + j] = p;
+			branch_cnt[j] = left + right;
+		}
+
+		p = calc_mvprob(branch_cnt[0], branch_cnt[1], entropy->mv_prob_old[i][6]);
+		if (update_prob(mv_update_prob[i][6], branch_cnt[0], branch_cnt[1],
+				entropy->mv_prob_old[i][6], p, 6))
+			entropy->mv_prob[i][6] = p;
+
+		p = calc_mvprob(type, branch_cnt[0] + branch_cnt[1],
+				entropy->mv_prob_old[i][2]);
+		if (update_prob(mv_update_prob[i][2], type, branch_cnt[0] + branch_cnt[1],
+				entropy->mv_prob_old[i][2], p, 6))
+			entropy->mv_prob[i][2] = p;
+	}
+
+	memcpy(entropy->y_mode_prob, y_mode_prob, sizeof(y_mode_prob));
+	memcpy(entropy->uv_mode_prob, uv_mode_prob, sizeof(uv_mode_prob));
+}
+
+static inline int coeff_prob_idx(int index)
+{
+	return (index / 8) * 8 + 7 - (index % 8);
+}
+
+static void rockchip_vpu2_vp8_enc_write_entropy(struct hantro_ctx *ctx)
+{
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+	uint8_t *entropy_table = ctx->vp8_enc.priv_src.cpu;
+	int index, i, j, k, l;
+
+	memset(entropy_table, 0, 56);
+	entropy_table[7] = ctx->vp8_enc.prob_skip_false;
+	entropy_table[6] = ctx->vp8_enc.prob_intra;
+	entropy_table[5] = ctx->vp8_enc.prob_last;
+	entropy_table[4] = ctx->vp8_enc.prob_gf;
+	entropy_table[3] = 0; /* segment_prob[0]; */
+	entropy_table[2] = 0; /* segment_prob[1]; */
+	entropy_table[1] = 0; /* segment_prob[2]; */
+
+	entropy_table[15] = entropy->y_mode_prob[0];
+	entropy_table[14] = entropy->y_mode_prob[1];
+	entropy_table[13] = entropy->y_mode_prob[2];
+	entropy_table[12] = entropy->y_mode_prob[3];
+	entropy_table[11] = entropy->uv_mode_prob[0];
+	entropy_table[10] = entropy->uv_mode_prob[1];
+	entropy_table[9] = entropy->uv_mode_prob[2];
+
+	entropy_table[23] = entropy->mv_prob[1][0];
+	entropy_table[22] = entropy->mv_prob[0][0];
+	entropy_table[21] = entropy->mv_prob[1][1];
+	entropy_table[20] = entropy->mv_prob[0][1];
+	entropy_table[19] = entropy->mv_prob[1][17];
+	entropy_table[18] = entropy->mv_prob[1][18];
+	entropy_table[17] = entropy->mv_prob[0][17];
+	entropy_table[16] = entropy->mv_prob[0][18];
+
+	for (i = 0; i < 8; ++i)
+		entropy_table[24 + 7 - i] = entropy->mv_prob[1][9 + i];
+
+	for (i = 0; i < 8; ++i)
+		entropy_table[32 + 7 - i] = entropy->mv_prob[0][9 + i];
+
+	for (i = 0; i < 7; ++i)
+		entropy_table[40 + 7 - i] = entropy->mv_prob[1][2 + i];
+
+	for (i = 0; i < 7; ++i)
+		entropy_table[48 + 7 - i] = entropy->mv_prob[0][2 + i];
+
+	index = 56;
+
+	for (i = 0; i < 4; ++i)
+		for (j = 0; j < 8; ++j)
+			for (k = 0; k < 3; ++k) {
+				for (l = 0; l < 3; ++l)
+					entropy_table[coeff_prob_idx(index++)] =
+						entropy->coeff_prob[i][j][k][l];
+				entropy_table[coeff_prob_idx(index++)] = 0;
+			}
+
+	for (i = 0; i < 4; ++i)
+		for (j = 0; j < 8; ++j)
+			for (k = 0; k < 3; ++k) {
+				for (l = 4; l < 11; ++l)
+					entropy_table[coeff_prob_idx(index++)] =
+						entropy->coeff_prob[i][j][k][l];
+				entropy_table[coeff_prob_idx(index++)] =
+					entropy->coeff_prob[i][j][k][3];
+			}
+}
+
+static inline size_t sw_hdr_size(struct hantro_ctx *ctx)
+{
+	return ctx->vp8_enc.boolenc.bytes_written + frame_tag_size(ctx);
+}
+
+static inline u32 enc_in_img_ctrl(struct hantro_ctx *ctx, u32 qp)
+{
+	unsigned int overfill_r, overfill_b;
+
+	/*
+	 * The hardware needs only the value for luma plane, because
+	 * values of other planes are calculated internally based on
+	 * format setting.
+	 */
+	overfill_r = ctx->src_fmt.width - ctx->dst_fmt.width;
+	overfill_b = ctx->src_fmt.height - ctx->dst_fmt.height;
+
+	return VEPU_REG_STREAM_START_OFFSET(0) |
+		VEPU_REG_IN_IMG_CTRL_OVRFLR_D4(overfill_r / 4) |
+		VEPU_REG_IN_IMG_CTRL_OVRFLB(overfill_b) |
+		VEPU_REG_SKIP_MACROBLOCK_PENALTY(qp >= 100 ? (3 * qp / 4) : 0);
+}
+
+static void
+rockchip_vpu2_vp8_enc_set_buffers(struct hantro_dev *vpu, struct hantro_ctx *ctx, u32 qp,
+				  struct v4l2_ctrl_vp8_encode_params *params)
+{
+	const u32 src_addr_regs[] = { VEPU_REG_ADDR_IN_PLANE_0,
+				      VEPU_REG_ADDR_IN_PLANE_1,
+				      VEPU_REG_ADDR_IN_PLANE_2 };
+	struct vb2_v4l2_buffer *src_buf, *dst_buf;
+	struct v4l2_pix_format_mplane *src_fmt = &ctx->src_fmt;
+	size_t luma_size;
+	dma_addr_t dst_dma;
+	size_t dst_size;
+	int i, ref_idx;
+
+	src_buf = hantro_get_src_buf(ctx);
+	dst_buf = hantro_get_dst_buf(ctx);
+
+	luma_size = hantro_rounded_luma_size(ctx->src_fmt.width,
+					     ctx->src_fmt.height);
+
+	dst_dma = vb2_dma_contig_plane_dma_addr(&dst_buf->vb2_buf, 0);
+	dst_size = vb2_plane_size(&dst_buf->vb2_buf, 0);
+
+	/*
+	 * We assume here that 1/10 of the buffer is enough for headers.
+	 * DCT partition will be placed in remaining 9/10 of the buffer.
+	 */
+	ctx->vp8_enc.estimated_hdr_size = round_up(dst_size / 10, 8);
+
+	/* Destination buffer. */
+	/*
+	 * We "abused" the first portion of this 1/10 of the buffer when generating
+	 * the frame tag and compressed header, so TODO: verify that the 1/10 can hold both the
+	 * compressed header and the "extended header" generated in hw.
+	 */
+	vepu_write_relaxed(vpu, dst_dma + round_up(sw_hdr_size(ctx), 8),
+			   VEPU_REG_ADDR_OUTPUT_STREAM);
+	vepu_write_relaxed(vpu, dst_dma + ctx->vp8_enc.estimated_hdr_size,
+			   VEPU_REG_ADDR_VP8_DCT_PART(0));
+	vepu_write_relaxed(vpu, dst_size - ctx->vp8_enc.estimated_hdr_size,
+			   VEPU_REG_STR_BUF_LIMIT);
+
+	/* Auxiliary buffers. */
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ctrl_buf.dma,
+			   VEPU_REG_ADDR_OUTPUT_CTRL);
+	memset(ctx->vp8_enc.ctrl_buf.cpu, 0, ctx->vp8_enc.ctrl_buf.size);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.mv_buf.dma,
+			   VEPU_REG_ADDR_MV_OUT);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.priv_dst.dma,
+			   VEPU_REG_ADDR_VP8_PROB_CNT);
+	memset(ctx->vp8_enc.priv_dst.cpu, 0, ctx->vp8_enc.priv_dst.size);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.priv_src.dma,
+			   VEPU_REG_ADDR_CABAC_TBL);
+
+	rockchip_vpu2_vp8_enc_write_entropy(ctx);
+
+	vepu_write_relaxed(vpu, ctx->vp8_enc.priv_src.dma + 151 * 8,
+			   VEPU_REG_ADDR_VP8_SEG_MAP);
+
+	/* Reference buffers. */
+	switch (params->reference_type) {
+	case V4L2_VP8_FRAME_REF_LAST:
+		ref_idx = ctx->vp8_enc.last_ref;
+		break;
+	case V4L2_VP8_FRAME_REF_GOLDEN:
+		ref_idx = ctx->vp8_enc.golden_ref;
+		break;
+	case V4L2_VP8_FRAME_REF_ALT:
+		ref_idx = ctx->vp8_enc.alt_ref;
+		break;
+	}
+	if (ref_idx < 0)
+		ref_idx = 0;
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ref_idx].dma, VEPU_REG_ADDR_REF_LUMA);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ref_idx].dma + luma_size,
+			   VEPU_REG_ADDR_REF_CHROMA);
+
+	/* Reconstruction buffers. */
+	ctx->vp8_enc.reconstructed =  ctx->vp8_enc.first_free;
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ctx->vp8_enc.reconstructed].dma,
+			   VEPU_REG_ADDR_REC_LUMA);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.ref_frames[ctx->vp8_enc.reconstructed].dma + luma_size,
+			   VEPU_REG_ADDR_REC_CHROMA);
+
+	/* Source buffer. */
+	for (i = 0; i < src_fmt->num_planes; ++i)
+		vepu_write_relaxed(vpu,
+				   vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, i) +
+				   src_buf->vb2_buf.planes[i].data_offset,
+				   src_addr_regs[i]);
+
+	/* Source parameters. */
+	vepu_write_relaxed(vpu, enc_in_img_ctrl(ctx, qp),
+			   VEPU_REG_ENC_OVER_FILL_STRM_OFFSET);
+}
+
+static inline uint32_t compute_filter_level(int32_t qp)
+{
+	return clamp((qp * 64) / 128 + 8, 0, 63);
+}
+
+static s32 cost_tree(struct tree *tree, const s32 *prob)
+{
+	s32 value = tree->value;
+	s32 number = tree->number;
+	s32 *index = tree->index;
+	s32 bit_cost = 0;
+
+	while (number--)
+		bit_cost += COST_BOOL(prob[*index++], (value >> number) & 1);
+
+	return bit_cost;
+}
+
+static s32 cost_mv(s32 mvd, const s32 *mv_prob)
+{
+	s32 i, tmp, bit_cost = 0;
+
+	tmp = abs(mvd >> 1);
+
+	/* Short Tree */
+	if (tmp < 8) {
+		bit_cost += COST_BOOL(mv_prob[0], 0);
+		bit_cost += cost_tree(&mv_tree[tmp], mv_prob + 2);
+		if (!tmp)
+			return bit_cost;
+
+		/* Sign */
+		bit_cost += COST_BOOL(mv_prob[1], mvd < 0);
+		return bit_cost;
+	}
+
+	/* Long Tree */
+	bit_cost += COST_BOOL(mv_prob[0], 1);
+
+	/* Bits 0, 1, 2 */
+	for (i = 0; i < 3; i++)
+		bit_cost += COST_BOOL(mv_prob[9 + i], (tmp >> i) & 1);
+
+	/* Bits 9, 8, 7, 6, 5, 4 */
+	for (i = 9; i > 3; i--)
+		bit_cost += COST_BOOL(mv_prob[9 + i], (tmp >> i) & 1);
+
+	/*
+	 * Bit 3: if ABS(mvd) < 8, it is coded with short tree, so if here
+	 * ABS(mvd) <= 15, bit 3 must be one (because here we code values
+	 * 8,...,15) and is not explicitly coded.
+	 */
+	if (tmp > 15)
+		bit_cost += COST_BOOL(mv_prob[9 + 3], (tmp >> 3) & 1);
+
+	/* Sign */
+	bit_cost += COST_BOOL(mv_prob[1], mvd < 0);
+
+	return bit_cost;
+}
+
+static void rockchip_vpu2_vp8_enc_set_params(struct hantro_dev *vpu, struct hantro_ctx *ctx, u32 qp,
+					     struct v4l2_ctrl_vp8_encode_params *params)
+{
+	struct hantro_vp8_entropy *entropy = &ctx->vp8_enc.entropy;
+	int i;
+	unsigned int mb_width = MB_WIDTH(ctx->src_fmt.width);
+	unsigned int mb_height = MB_HEIGHT(ctx->src_fmt.height);
+	u32 deq;
+	u32 tmp;
+	u32 reg;
+	s32 inter_favor;
+
+	reg = VEPU_REG_OUTPUT_SWAP32
+		| VEPU_REG_OUTPUT_SWAP16
+		| VEPU_REG_OUTPUT_SWAP8
+		| VEPU_REG_INPUT_SWAP8
+		| VEPU_REG_INPUT_SWAP16
+		| VEPU_REG_INPUT_SWAP32;
+	vepu_write_relaxed(vpu, reg, VEPU_REG_DATA_ENDIAN);
+
+	reg = VEPU_REG_SIZE_TABLE_PRESENT
+		| VEPU_REG_IN_IMG_CTRL_FMT(ctx->vpu_src_fmt->enc_fmt)
+		| VEPU_REG_IN_IMG_ROTATE_MODE(0);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_ENC_CTRL1);
+
+	reg = VEPU_REG_INTERRUPT_TIMEOUT_EN
+		| VEPU_REG_MV_WRITE_EN;
+	vepu_write_relaxed(vpu, reg, VEPU_REG_INTERRUPT);
+
+	reg = VEPU_REG_IN_IMG_CHROMA_OFFSET(0)
+		| VEPU_REG_IN_IMG_LUMA_OFFSET(0)
+		| VEPU_REG_IN_IMG_CTRL_ROW_LEN(mb_width * 16);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_INPUT_LUMA_INFO);
+
+	vepu_write_relaxed(vpu, 0, VEPU_REG_STR_HDR_REM_MSB);
+	vepu_write_relaxed(vpu, 0, VEPU_REG_STR_HDR_REM_LSB);
+
+	reg = 0;
+	if (mb_width * mb_height > MAX_MB_COUNT_TO_DISABLE_QUARTER_PIXEL_MV)
+		reg = VEPU_REG_DISABLE_QUARTER_PIXEL_MV;
+	reg |= VEPU_REG_ENTROPY_CODING_MODE;
+	vepu_write_relaxed(vpu, reg, VEPU_REG_ENC_CTRL0);
+
+	inter_favor = 128 - ctx->vp8_enc.prob_intra;
+	if (inter_favor >= 0)
+		inter_favor = max(0, (int32_t)(qp * 2 - 40));
+
+	reg = VEPU_REG_INTRA16X16_MODE(qp * 1024 / 128)
+		| VEPU_REG_INTER_MODE(inter_favor);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_INTRA_INTER_MODE);
+
+	reg = VEPU_REG_1MV_PENALTY(60 / 2 * 32)
+		| VEPU_REG_QMV_PENALTY(8)
+		| VEPU_REG_4MV_PENALTY(64 / 2);
+	if (mb_width * mb_height < MAX_MB_COUNT_TO_DISABLE_SPLIT_MV)
+		reg |= VEPU_REG_SPLIT_MV_MODE_EN;
+	vepu_write_relaxed(vpu, reg, VEPU_REG_MV_PENALTY);
+
+	reg = VEPU_REG_MV_PENALTY_16X8_8X16(
+			min(1023, split_penalty[qp] / 2))
+		| VEPU_REG_MV_PENALTY_8X8(
+			min(1023, (2 * split_penalty[qp] + 40) / 4))
+		| VEPU_REG_MV_PENALTY_8X4_4X8(0x3ff);
+	/* no 8x4 or 4x8 block define in vp8 */
+	vepu_write_relaxed(vpu, reg, VEPU_REG_ENC_CTRL4);
+
+	reg = VEPU_REG_PENALTY_4X4MV(min(511,
+					 (8 * split_penalty[qp] + 500) / 16))
+		| VEPU_REG_ZERO_MV_FAVOR_D2(0);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_MVC_RELATE);
+
+	/* initialize quant table for segment0 */
+	deq = dc_q_lookup[qp];
+	reg = VEPU_REG_VP8_SEG0_QUT_DC_Y1(min((1 << 16) / deq, 0x3FFFu));
+	reg |= VEPU_REG_VP8_SEG0_ZBIN_DC_Y1(((qzbin_factors[qp] * deq) + 64) >>
+					    7);
+	reg |= VEPU_REG_VP8_SEG0_RND_DC_Y1((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_DC_Y1);
+
+	deq = ac_q_lookup[qp];
+	reg = VEPU_REG_VP8_SEG0_QUT_AC_Y1(min((1 << 16) / deq, 0x3FFFu));
+	reg |= VEPU_REG_VP8_SEG0_ZBIN_AC_Y1(((qzbin_factors[qp] * deq) + 64) >>
+					    7);
+	reg |= VEPU_REG_VP8_SEG0_RND_AC_Y1((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_AC_Y1);
+
+	deq = dc_q_lookup[qp] * 2;
+	reg = VEPU_REG_VP8_SEG0_QUT_DC_Y2(min((1 << 16) / deq, 0x3FFFu));
+	reg |= VEPU_REG_VP8_SEG0_ZBIN_DC_Y2((qzbin_factors[qp] * deq + 64) >>
+					    7);
+	reg |= VEPU_REG_VP8_SEG0_RND_DC_Y2((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_DC_Y2);
+
+	deq = max(ac_q_lookup[qp] * 155 / 100, 8);
+	reg = VEPU_REG_VP8_SEG0_QUT_AC_Y2(min((1 << 16) / deq, 0x3FFFu));
+	reg |= VEPU_REG_VP8_SEG0_ZBIN_AC_Y2((qzbin_factors[qp] * deq + 64) >>
+					    7);
+	reg |= VEPU_REG_VP8_SEG0_RND_AC_Y2((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_AC_Y2);
+
+	deq = min(dc_q_lookup[qp], 132);
+	reg = VEPU_REG_VP8_SEG0_QUT_DC_CHR(min((1 << 16) / deq, 0x3FFFu));
+	reg |= VEPU_REG_VP8_SEG0_ZBIN_DC_CHR((qzbin_factors[qp] * deq + 64) >>
+					     7);
+	reg |= VEPU_REG_VP8_SEG0_RND_DC_CHR((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_DC_CHR);
+
+	deq = ac_q_lookup[qp];
+	reg = VEPU_REG_VP8_SEG0_QUT_AC_CHR(min((1 << 16) / deq, 0x3FFFu));
+	reg |= VEPU_REG_VP8_SEG0_ZBIN_AC_CHR((qzbin_factors[qp] * deq + 64) >>
+					     7);
+	reg |= VEPU_REG_VP8_SEG0_RND_AC_CHR((qrounding_factors[qp] * deq) >> 7);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_AC_CHR);
+
+	reg = VEPU_REG_VP8_MV_REF_IDX1(params->reference_type);
+	reg |= VEPU_REG_VP8_SEG0_DQUT_DC_Y1(dc_q_lookup[qp]);
+	reg |= VEPU_REG_VP8_SEG0_DQUT_AC_Y1(ac_q_lookup[qp]);
+	reg |= VEPU_REG_VP8_SEG0_DQUT_DC_Y2(dc_q_lookup[qp] * 2);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_DQUT);
+
+	reg = VEPU_REG_VP8_MV_REF_IDX2(0);
+	reg |= VEPU_REG_VP8_SEG0_DQUT_DC_CHR(min(dc_q_lookup[qp], 132));
+	reg |= VEPU_REG_VP8_SEG0_DQUT_AC_CHR(ac_q_lookup[qp]);
+	reg |= VEPU_REG_VP8_SEG0_DQUT_AC_Y2(max(ac_q_lookup[qp] * 155 / 100, 8));
+	if (is_intra(ctx))
+		reg |= VEPU_REG_VP8_SEGMENT_MAP_UPDATE;
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_SEG0_QUANT_DQUT_1);
+	vepu_write_relaxed(vpu, ctx->vp8_enc.boolenc.bottom,
+			   VEPU_REG_VP8_BOOL_ENC_VALUE);
+
+	reg = VEPU_REG_VP8_DCT_PARTITION_CNT(0);
+	reg |= VEPU_REG_VP8_FILTER_LEVEL(compute_filter_level(qp));
+	reg |= VEPU_REG_VP8_FILTER_SHARPNESS(params->sharpness_level);
+	reg |= VEPU_REG_VP8_ZERO_MV_PENALTY_FOR_REF2(0);
+	reg |= VEPU_REG_VP8_BOOL_ENC_VALUE_BITS(24 - ctx->vp8_enc.boolenc.bit_count);
+	reg |= VEPU_REG_VP8_BOOL_ENC_RANGE(ctx->vp8_enc.boolenc.range);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_ENC_CTRL2);
+
+	vepu_write_relaxed(vpu, 0xffffffff, VEPU_REG_ROI1);
+	vepu_write_relaxed(vpu, 0xffffffff, VEPU_REG_ROI2);
+	vepu_write_relaxed(vpu, 0, VEPU_REG_STABILIZATION_OUTPUT);
+	vepu_write_relaxed(vpu, 0x962b4c85, VEPU_REG_RGB2YUV_CONVERSION_COEF1);
+	vepu_write_relaxed(vpu, 0x90901d50, VEPU_REG_RGB2YUV_CONVERSION_COEF2);
+	vepu_write_relaxed(vpu, 0x0000b694, VEPU_REG_RGB2YUV_CONVERSION_COEF3);
+	vepu_write_relaxed(vpu, 0, VEPU_REG_RGB_MASK_MSB);
+	vepu_write_relaxed(vpu, 0, VEPU_REG_CIR_INTRA_CTRL);
+	vepu_write_relaxed(vpu, 0xffffffff, VEPU_REG_INTRA_AREA_CTRL);
+
+	/* Intra 4x4 mode */
+	tmp = qp * 2 + 8;
+	for (i = 0; i < 5; i++) {
+		reg = VEPU_REG_VP8_INTRA_4X4_PENALTY_0
+			((intra_4_tree_penalty[i * 2] * tmp) >> 8);
+		reg |= VEPU_REG_VP8_INTRA_4x4_PENALTY_1
+			((intra_4_tree_penalty[i * 2 + 1] * tmp) >> 8);
+		vepu_write_relaxed(vpu, reg,
+				   VEPU_REG_VP8_INTRA_4X4_PENALTY(i));
+	}
+
+	/* Intra 16x16 mode */
+	tmp = qp * 2 + 64;
+	for (i = 0; i < 2; i++) {
+		reg = VEPU_REG_VP8_INTRA_16X16_PENALTY_0
+			((intra_16_tree_penalty[2 * i] * tmp) >> 8);
+		reg |= VEPU_REG_VP8_INTRA_16X16_PENALTY_1
+			((intra_16_tree_penalty[2 * i + 1] * tmp) >> 8);
+		vepu_write_relaxed(vpu, reg,
+				   VEPU_REG_VP8_INTRA_16X16_PENALTY(i));
+	}
+
+	reg = VEPU_REG_VP8_LF_REF_DELTA_INTRA_MB(ctx->vp8_enc.ref_delta[REF_DELTA_INTRA_MB]);
+	reg |= VEPU_REG_VP8_LF_MODE_DELTA_BPRED(ctx->vp8_enc.mode_delta[MODE_DELTA_BPRED]);
+	reg |= VEPU_REG_VP8_INTER_TYPE_BIT_COST(0);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_CONTROL);
+
+	reg = VEPU_REG_VP8_LF_REF_DELTA_ALT_REF(ctx->vp8_enc.ref_delta[REF_DELTA_ALT_REF])
+		| VEPU_REG_VP8_LF_REF_DELTA_LAST_REF(ctx->vp8_enc.ref_delta[REF_DELTA_LAST_REF])
+		| VEPU_REG_VP8_LF_REF_DELTA_GOLDEN(ctx->vp8_enc.ref_delta[REF_DELTA_GOLDEN]);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_LOOP_FILTER_REF_DELTA);
+
+	reg = VEPU_REG_VP8_LF_MODE_DELTA_SPLITMV(ctx->vp8_enc.mode_delta[MODE_DELTA_SPLITMV])
+		| VEPU_REG_VP8_LF_MODE_DELTA_ZEROMV(ctx->vp8_enc.mode_delta[MODE_DELTA_ZEROMV])
+		| VEPU_REG_VP8_LF_MODE_DELTA_NEWMV(ctx->vp8_enc.mode_delta[MODE_DELTA_NEWMV]);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_VP8_LOOP_FILTER_MODE_DELTA);
+
+	for (i = 0; i < 128; i += 4) {
+		u32 x;
+		u32 y;
+
+		reg = VEPU_REG_DMV_PENALTY_TABLE_BIT(i * 2, 3);
+		reg |= VEPU_REG_DMV_PENALTY_TABLE_BIT((i + 1) * 2, 2);
+		reg |= VEPU_REG_DMV_PENALTY_TABLE_BIT((i + 2) * 2, 1);
+		reg |= VEPU_REG_DMV_PENALTY_TABLE_BIT((i + 3) * 2, 0);
+		vepu_write_relaxed(vpu, reg, VEPU_REG_DMV_PENALTY_TBL(i / 4));
+
+		y = cost_mv(i * 2, entropy->mv_prob[0]);	/* mv y */
+		x = cost_mv(i * 2, entropy->mv_prob[1]);	/* mv x */
+
+		reg = VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 3);
+
+		y = cost_mv((i + 1) * 2, entropy->mv_prob[0]); /* mv y */
+		x = cost_mv((i + 1) * 2, entropy->mv_prob[1]); /* mv x */
+		reg |= VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 2);
+
+		y = cost_mv((i + 2) * 2, entropy->mv_prob[0]); /* mv y */
+		x = cost_mv((i + 2) * 2, entropy->mv_prob[1]); /* mv x */
+		reg |= VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 1);
+
+		y = cost_mv((i + 3) * 2, entropy->mv_prob[0]); /* mv y */
+		x = cost_mv((i + 3) * 2, entropy->mv_prob[1]); /* mv x */
+		reg |= VEPU_REG_DMV_Q_PIXEL_PENALTY_TABLE_BIT(
+			min(255u, (y + x + 1) / 2 * weight[qp] >> 8), 0);
+
+		vepu_write_relaxed(vpu, reg,
+				   VEPU_REG_DMV_Q_PIXEL_PENALTY_TBL(i / 4));
+	}
+}
+
+int rockchip_vpu2_vp8_enc_run(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+	struct v4l2_ctrl_vp8_encode_params *params;
+	struct v4l2_ctrl *ctrl;
+	u32 reg, qp;
+	int i;
+
+	hantro_start_prepare_run(ctx);
+
+	params = hantro_get_ctrl(ctx, V4L2_CID_STATELESS_VP8_ENCODE_PARAMS);
+	if (WARN_ON(!params))
+		return -EINVAL;
+
+	if (params->flags & V4L2_VP8_FRAME_FLAG_SEGMENT_ENABLED)
+		return -EINVAL;
+
+	ctx->vp8_enc.is_intra = params->frame_type == V4L2_VP8_FRAME_TYPE_KEYFRAME;
+
+	if (is_intra(ctx)) {
+		if (params->loop_filter_level != 26)
+			return -EINVAL;
+	} else {
+		if (params->loop_filter_level != 12)
+			return -EINVAL;
+	}
+
+	ctrl = v4l2_ctrl_find(&ctx->ctrl_handler, V4L2_CID_STATELESS_VP8_ENCODE_QP);
+	if (WARN_ON(!ctrl))
+		return -EINVAL;
+
+	ctx->vp8_enc.show_frame = params->flags & V4L2_VP8_FRAME_FLAG_SHOWFRAME;
+	ctx->vp8_enc.refresh_golden_frame = params->flags & V4L2_VP8_FRAME_FLAG_GOLDEN_REFRESH;
+	ctx->vp8_enc.refresh_alternate_frame = params->flags & V4L2_VP8_FRAME_FLAG_ALTREF_REFRESH;
+	ctx->vp8_enc.refresh_entropy_probs =
+		params->flags & V4L2_VP8_FRAME_FLAG_REFRESH_ENTROPY_PROBS;
+	ctx->vp8_enc.copy_buffer_to_golden = params->copy_buffer_to_golden;
+	ctx->vp8_enc.copy_buffer_to_alternate = params->copy_buffer_to_alternate;
+	ctx->vp8_enc.prob_intra = params->prob_intra;
+	ctx->vp8_enc.prob_last = params->prob_last;
+	ctx->vp8_enc.prob_gf = params->prob_gf;
+
+	rockchip_vpu2_vp8_enc_update_entropy(ctx);
+
+	qp = *ctrl->p_cur.p_s32;
+	ctx->vp8_enc.prob_skip_false = default_prob_skip_false[qp];
+	rockchip_vpu2_vp8_enc_write_header(ctx, qp, params);
+
+	/*
+	 * Program the hardware.
+	 */
+	vepu_write_relaxed(vpu, VEPU_REG_ENCODE_FORMAT_VP8, VEPU_REG_ENCODE_START);
+
+	rockchip_vpu2_vp8_enc_set_params(vpu, ctx, qp, params);
+	rockchip_vpu2_vp8_enc_set_buffers(vpu, ctx, qp, params);
+
+	reg = VEPU_REG_AXI_CTRL_READ_ID(0)
+		| VEPU_REG_AXI_CTRL_WRITE_ID(0)
+		| VEPU_REG_AXI_CTRL_BURST_LEN(16)
+		| VEPU_REG_AXI_CTRL_INCREMENT_MODE(0)
+		| VEPU_REG_AXI_CTRL_BIRST_DISCARD(0);
+	vepu_write_relaxed(vpu, reg, VEPU_REG_AXI_CTRL);
+
+	/* Start the hardware. */
+	reg = VEPU_REG_MB_HEIGHT(MB_HEIGHT(ctx->src_fmt.height))
+		| VEPU_REG_MB_WIDTH(MB_WIDTH(ctx->src_fmt.width))
+		| VEPU_REG_ENCODE_FORMAT_VP8
+		| VEPU_REG_ENCODE_ENABLE;
+
+	if (is_intra(ctx))
+		reg |= VEPU_REG_FRAME_TYPE_INTRA;
+	else
+		reg |= VEPU_REG_FRAME_TYPE_INTER;
+
+	/* Kick the watchdog and start encoding */
+	hantro_end_prepare_run(ctx);
+
+	for (i = 0; i < 184; ++i)
+		vepu_read(vpu, i * 4);
+
+	vepu_write(vpu, reg, VEPU_REG_ENCODE_START);
+
+	return 0;
+}
+
+void rockchip_vpu2_vp8_enc_done(struct hantro_ctx *ctx)
+{
+	struct vb2_v4l2_buffer *dst_buf;
+	struct hantro_vp8_enc_ctrl_buf *ctrl_buf = ctx->vp8_enc.ctrl_buf.cpu;
+	int part1_sz = ctx->vp8_enc.boolenc.bytes_written + ctrl_buf->hw_hdr_size;
+	void *dst = ctx->vp8_enc.frame_tag;
+	int old_g = ctx->vp8_enc.golden_ref, old_a = ctx->vp8_enc.alt_ref;
+	int i;
+
+	ctx->vp8_enc.frame_tag->tag[0] |= ((part1_sz << 5) & 0xff);
+	ctx->vp8_enc.frame_tag->tag[1] = ((part1_sz << 5) >> 8) & 0xff;
+	ctx->vp8_enc.frame_tag->tag[2] = ((part1_sz << 5) >> 16) & 0xff;
+
+	dst_buf = hantro_get_dst_buf(ctx);
+
+	/* assemble dst frame */
+	vb2_set_plane_payload(&dst_buf->vb2_buf, 0,
+			      sw_hdr_size(ctx) + ctrl_buf->hw_hdr_size + ctrl_buf->dct_size);
+
+	memmove(dst + sw_hdr_size(ctx), dst + round_up(sw_hdr_size(ctx), 8), ctrl_buf->hw_hdr_size);
+	memmove(dst + sw_hdr_size(ctx) + ctrl_buf->hw_hdr_size,
+		dst + ctx->vp8_enc.estimated_hdr_size, ctrl_buf->dct_size);
+
+	/* currently reconstructed frame becames last ref */
+	hantro_vp8_clr_bit(&ctx->vp8_enc, VP8_BIT_LAST, ctx->vp8_enc.last_ref);
+	ctx->vp8_enc.last_ref = ctx->vp8_enc.reconstructed;
+	hantro_vp8_set_bit(&ctx->vp8_enc, VP8_BIT_LAST, ctx->vp8_enc.last_ref);
+
+	/* after update (potentially) new slots will be used */
+	hantro_vp8_clr_bit(&ctx->vp8_enc, VP8_BIT_GOLDEN, old_g);
+	hantro_vp8_clr_bit(&ctx->vp8_enc, VP8_BIT_ALT, old_a);
+
+	/* VP8 spec, section 9.7. Refresh Golden Frame and Altref Frame */
+	if (is_intra(ctx)) {
+		ctx->vp8_enc.golden_ref = ctx->vp8_enc.last_ref;
+		ctx->vp8_enc.alt_ref = ctx->vp8_enc.last_ref;
+	} else {
+		if (ctx->vp8_enc.refresh_golden_frame) {
+			ctx->vp8_enc.golden_ref = ctx->vp8_enc.last_ref;
+		} else if (ctx->vp8_enc.copy_buffer_to_golden) {
+			switch (ctx->vp8_enc.copy_buffer_to_golden) {
+			case V4L2_VP8_FRAME_GOLDEN_KEEP:
+				break;
+			case V4L2_VP8_FRAME_GOLDEN_LASTFRAME:
+				ctx->vp8_enc.golden_ref = ctx->vp8_enc.last_ref;
+				break;
+			case V4L2_VP8_FRAME_GOLDEN_ALTREF:
+				ctx->vp8_enc.golden_ref = old_a;
+				break;
+			}
+		}
+
+		if (ctx->vp8_enc.refresh_alternate_frame) {
+			ctx->vp8_enc.alt_ref = ctx->vp8_enc.last_ref;
+		} else if (ctx->vp8_enc.copy_buffer_to_alternate) {
+			switch (ctx->vp8_enc.copy_buffer_to_alternate) {
+			case V4L2_VP8_FRAME_ALTREF_KEEP:
+				break;
+			case V4L2_VP8_FRAME_ALTREF_LASTFRAME:
+				ctx->vp8_enc.alt_ref = ctx->vp8_enc.last_ref;
+				break;
+			case V4L2_VP8_FRAME_ALTREF_GOLDEN:
+				ctx->vp8_enc.alt_ref = old_g;
+				break;
+			}
+		}
+	}
+
+	/* mark updated golden and alt slots used */
+	hantro_vp8_set_bit(&ctx->vp8_enc, VP8_BIT_GOLDEN, ctx->vp8_enc.golden_ref);
+	hantro_vp8_set_bit(&ctx->vp8_enc, VP8_BIT_ALT, ctx->vp8_enc.alt_ref);
+
+	/* find first free slot after updates */
+	for (i = 0; i < ARRAY_SIZE(ctx->vp8_enc.ref_bitmaps); ++i)
+		if (!ctx->vp8_enc.ref_bitmaps[i]) {
+			ctx->vp8_enc.first_free = i;
+			break;
+		}
+	WARN_ON(i >= 4);
+
+	ctx->vp8_enc.last_intra = is_intra(ctx);
+	++ctx->vp8_enc.frame_counter;
+}
diff --git a/drivers/media/platform/verisilicon/rockchip_vpu2_regs.h b/drivers/media/platform/verisilicon/rockchip_vpu2_regs.h
index 49e408895..b68882965 100644
--- a/drivers/media/platform/verisilicon/rockchip_vpu2_regs.h
+++ b/drivers/media/platform/verisilicon/rockchip_vpu2_regs.h
@@ -258,6 +258,7 @@
 #define     VEPU_REG_FRAME_TYPE_INTER			(0x0 << 6)
 #define     VEPU_REG_FRAME_TYPE_INTRA			(0x1 << 6)
 #define     VEPU_REG_FRAME_TYPE_MVCINTER		(0x2 << 6)
+#define     VEPU_REG_ENCODE_FORMAT_VP8			(0x1 << 4)	/* undocumented */
 #define     VEPU_REG_ENCODE_FORMAT_JPEG			(0x2 << 4)
 #define     VEPU_REG_ENCODE_FORMAT_H264			(0x3 << 4)
 #define     VEPU_REG_ENCODE_ENABLE			BIT(0)
diff --git a/drivers/media/platform/verisilicon/rockchip_vpu_hw.c b/drivers/media/platform/verisilicon/rockchip_vpu_hw.c
index 8de6fd2e8..0671f1609 100644
--- a/drivers/media/platform/verisilicon/rockchip_vpu_hw.c
+++ b/drivers/media/platform/verisilicon/rockchip_vpu_hw.c
@@ -56,6 +56,19 @@ static const struct hantro_fmt rockchip_vpu_enc_fmts[] = {
 			.step_height = MB_DIM,
 		},
 	},
+	{
+		.fourcc = V4L2_PIX_FMT_VP8_FRAME,
+		.codec_mode = HANTRO_MODE_VP8_ENC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 1920,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 1088,
+			.step_height = MB_DIM,
+		},
+	},
 };
 
 static const struct hantro_fmt rockchip_vpu1_postproc_fmts[] = {
@@ -350,6 +363,7 @@ static int rockchip_vpu_hw_init(struct hantro_dev *vpu)
 {
 	/* Bump ACLK to max. possible freq. to improve performance. */
 	clk_set_rate(vpu->clocks[0].clk, RK3288_ACLK_MAX_FREQ);
+
 	return 0;
 }
 
@@ -488,6 +502,13 @@ static const struct hantro_codec_ops rk3399_vpu_codec_ops[] = {
 		.init = hantro_vp8_dec_init,
 		.exit = hantro_vp8_dec_exit,
 	},
+	[HANTRO_MODE_VP8_ENC] = {
+		.run = rockchip_vpu2_vp8_enc_run,
+		.reset = rockchip_vpu2_enc_reset,
+		.init = hantro_vp8_enc_init,
+		.done = rockchip_vpu2_vp8_enc_done,
+		.exit = hantro_vp8_enc_exit,
+	},
 };
 
 static const struct hantro_codec_ops rk3568_vepu_codec_ops[] = {
@@ -626,7 +647,7 @@ const struct hantro_variant rk3399_vpu_variant = {
 	.dec_fmts = rk3399_vpu_dec_fmts,
 	.num_dec_fmts = ARRAY_SIZE(rk3399_vpu_dec_fmts),
 	.codec = HANTRO_JPEG_ENCODER | HANTRO_MPEG2_DECODER |
-		 HANTRO_VP8_DECODER,
+		 HANTRO_VP8_DECODER | HANTRO_VP8_ENCODER,
 	.codec_ops = rk3399_vpu_codec_ops,
 	.irqs = rockchip_vpu2_irqs,
 	.num_irqs = ARRAY_SIZE(rockchip_vpu2_irqs),
diff --git a/drivers/media/platform/verisilicon/stm32mp25_vdec_hw.c b/drivers/media/platform/verisilicon/stm32mp25_vdec_hw.c
new file mode 100644
index 000000000..c9f107bc0
--- /dev/null
+++ b/drivers/media/platform/verisilicon/stm32mp25_vdec_hw.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STM32MP25 VDEC video decoder driver
+ *
+ * Copyright (C) STMicroelectronics SA 2022
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ *
+ */
+
+#include "hantro.h"
+
+/*
+ * Supported formats.
+ */
+
+static const struct hantro_fmt stm32mp25_vdec_fmts[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.codec_mode = HANTRO_MODE_NONE,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_VP8_FRAME,
+		.codec_mode = HANTRO_MODE_VP8_DEC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_H264_SLICE,
+		.codec_mode = HANTRO_MODE_H264_DEC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+};
+
+/*
+ * Supported codec ops.
+ */
+
+static const struct hantro_codec_ops stm32mp25_vdec_codec_ops[] = {
+	[HANTRO_MODE_VP8_DEC] = {
+		.run = hantro_g1_vp8_dec_run,
+		.reset = hantro_g1_reset,
+		.init = hantro_vp8_dec_init,
+		.exit = hantro_vp8_dec_exit,
+	},
+	[HANTRO_MODE_H264_DEC] = {
+		.run = hantro_g1_h264_dec_run,
+		.reset = hantro_g1_reset,
+		.init = hantro_h264_dec_init,
+		.exit = hantro_h264_dec_exit,
+	},
+};
+
+static const struct hantro_irq stm32mp25_irqs[] = {
+	{ "vdec", hantro_g1_irq },
+};
+
+static const char * const stm32mp25_clk_names[] = { "vdec-clk" };
+
+const struct hantro_variant stm32mp25_vdec_variant = {
+	.dec_fmts = stm32mp25_vdec_fmts,
+	.num_dec_fmts = ARRAY_SIZE(stm32mp25_vdec_fmts),
+	.codec = HANTRO_VP8_DECODER | HANTRO_H264_DECODER,
+	.codec_ops = stm32mp25_vdec_codec_ops,
+	.irqs = stm32mp25_irqs,
+	.num_irqs = ARRAY_SIZE(stm32mp25_irqs),
+	.clk_names = stm32mp25_clk_names,
+	.num_clocks = ARRAY_SIZE(stm32mp25_clk_names),
+};
diff --git a/drivers/media/platform/verisilicon/stm32mp25_venc_hw.c b/drivers/media/platform/verisilicon/stm32mp25_venc_hw.c
new file mode 100644
index 000000000..c390a2d68
--- /dev/null
+++ b/drivers/media/platform/verisilicon/stm32mp25_venc_hw.c
@@ -0,0 +1,294 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STM32MP25 VENC video encoder driver
+ *
+ * Copyright (C) STMicroelectronics SA 2022
+ * Authors: Hugues Fruchet <hugues.fruchet@foss.st.com>
+ *          for STMicroelectronics.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+
+#include "hantro.h"
+#include "hantro_jpeg.h"
+#include "hantro_h1_regs.h"
+
+/*
+ * Supported formats.
+ */
+
+static const struct hantro_fmt stm32mp25_venc_fmts[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUV420SP,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420M,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUV420P,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_NV12M,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUV420SP,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUYV,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_YUYV422,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_UYVY,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_UYVY422,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_RGB565,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB565,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_XBGR32,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB888,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_BGR32,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB888,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_RGBX32,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB888,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_BGRX32,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB888,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_XRGB32,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB888,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_RGB32,
+		.codec_mode = HANTRO_MODE_NONE,
+		.enc_fmt = ROCKCHIP_VPU_ENC_FMT_RGB888,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_JPEG,
+		.codec_mode = HANTRO_MODE_JPEG_ENC,
+		.max_depth = 2,
+		.header_size = JPEG_HEADER_SIZE,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 8176,
+			.step_width = MB_DIM,
+			.min_height = 32,
+			.max_height = 8176,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_VP8_FRAME,
+		.codec_mode = HANTRO_MODE_VP8_ENC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_H264_SLICE,
+		.codec_mode = HANTRO_MODE_H264_ENC,
+		.max_depth = 2,
+		.frmsize = {
+			.min_width = 96,
+			.max_width = 4080,
+			.step_width = MB_DIM,
+			.min_height = 96,
+			.max_height = 4080,
+			.step_height = MB_DIM,
+		},
+	},
+};
+
+static irqreturn_t stm32mp25_venc_irq(int irq, void *dev_id)
+{
+	struct hantro_dev *vpu = dev_id;
+	enum vb2_buffer_state state;
+	u32 status;
+
+	status = vepu_read(vpu, H1_REG_INTERRUPT);
+	state = (status & H1_REG_INTERRUPT_FRAME_RDY) ?
+		VB2_BUF_STATE_DONE : VB2_BUF_STATE_ERROR;
+
+	vepu_write(vpu, H1_REG_INTERRUPT_BIT, H1_REG_INTERRUPT);
+
+	hantro_irq_done(vpu, state);
+
+	return IRQ_HANDLED;
+}
+
+static void stm32mp25_venc_reset(struct hantro_ctx *ctx)
+{
+	struct hantro_dev *vpu = ctx->dev;
+
+	reset_control_reset(vpu->resets);
+}
+
+/*
+ * Supported codec ops.
+ */
+
+static const struct hantro_codec_ops stm32mp25_venc_codec_ops[] = {
+	[HANTRO_MODE_JPEG_ENC] = {
+		.run = hantro_h1_jpeg_enc_run,
+		.reset = stm32mp25_venc_reset,
+		.done = hantro_h1_jpeg_enc_done,
+	},
+	[HANTRO_MODE_VP8_ENC] = {
+		.run = hantro_h1_vp8_enc_run,
+		.reset = stm32mp25_venc_reset,
+		.init = hantro_vp8_enc_init,
+		.done = hantro_h1_vp8_enc_done,
+		.exit = hantro_vp8_enc_exit,
+	},
+	[HANTRO_MODE_H264_ENC] = {
+		.run = hantro_h1_h264_enc_run,
+		.reset = stm32mp25_venc_reset,
+		.init = hantro_h264_enc_init,
+		.done = hantro_h1_h264_enc_done,
+		.exit = hantro_h264_enc_exit,
+	},
+};
+
+/*
+ * Variants.
+ */
+
+static const struct hantro_irq stm32mp25_venc_irqs[] = {
+	{ "venc", stm32mp25_venc_irq },
+};
+
+static const char * const stm32mp25_venc_clk_names[] = {
+	"venc-clk"
+};
+
+const struct hantro_variant stm32mp25_venc_variant = {
+	.enc_fmts = stm32mp25_venc_fmts,
+	.num_enc_fmts = ARRAY_SIZE(stm32mp25_venc_fmts),
+	.codec = HANTRO_JPEG_ENCODER | HANTRO_VP8_ENCODER | HANTRO_H264_ENCODER,
+	.codec_ops = stm32mp25_venc_codec_ops,
+	.irqs = stm32mp25_venc_irqs,
+	.num_irqs = ARRAY_SIZE(stm32mp25_venc_irqs),
+	.clk_names = stm32mp25_venc_clk_names,
+	.num_clocks = ARRAY_SIZE(stm32mp25_venc_clk_names)
+};
+
diff --git a/drivers/media/v4l2-core/v4l2-ctrls-core.c b/drivers/media/v4l2-core/v4l2-ctrls-core.c
index 291691708..afd76a2ff 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls-core.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls-core.c
@@ -350,6 +350,9 @@ void v4l2_ctrl_type_op_log(const struct v4l2_ctrl *ctrl)
 	case V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS:
 		pr_cont("HEVC_DECODE_PARAMS");
 		break;
+	case V4L2_CTRL_TYPE_ISP_STAT_REGION:
+		pr_cont("ISP_STAT_REGION");
+		break;
 	default:
 		pr_cont("unknown type %d", ctrl->type);
 		break;
@@ -547,6 +550,48 @@ validate_vp9_frame(struct v4l2_ctrl_vp9_frame *frame)
 	return 0;
 }
 
+static int
+validate_h264_encode_params(struct v4l2_ctrl_h264_encode_params *encode_params)
+{
+	/* Make sure we're not passed invalid flags. */
+	if (encode_params->flags & ~(V4L2_H264_ENCODE_FLAG_ENTROPY_CABAC |
+		V4L2_H264_ENCODE_FLAG_TRANSFORM_8X8_MODE |
+		V4L2_H264_ENCODE_FLAG_CONSTRAINED_INTRA_PRED |
+		V4L2_H264_ENCODE_FLAG_MARK_LONGTERM))
+		return -EINVAL;
+
+	if (encode_params->slice_type != V4L2_H264_SLICE_TYPE_I &&
+	    encode_params->slice_type != V4L2_H264_SLICE_TYPE_P &&
+	    encode_params->slice_type != V4L2_H264_SLICE_TYPE_B &&
+	    encode_params->slice_type != V4L2_H264_SLICE_TYPE_SI &&
+		encode_params->slice_type != V4L2_H264_SLICE_TYPE_SP)
+		return -EINVAL;
+
+	if (encode_params->cabac_init_idc > 2)
+		return -EINVAL;
+
+	if (encode_params->nalu_type != V4L2_H264_NAL_CODED_SLICE_NON_IDR_PIC &&
+	    encode_params->nalu_type != V4L2_H264_NAL_CODED_SLICE_IDR_PIC)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+validate_h264_encode_rc(struct v4l2_ctrl_h264_encode_rc *encode_rc)
+{
+	if (encode_rc->qp > 51)
+		return -EINVAL;
+
+	if (encode_rc->qp_min > 51 || encode_rc->qp_max > 51)
+		return -EINVAL;
+
+	if (encode_rc->qp_min > encode_rc->qp_max)
+		return -EINVAL;
+
+	return 0;
+}
+
 /*
  * Compound controls validation requires setting unused fields/flags to zero
  * in order to properly detect unchanged controls with v4l2_ctrl_type_op_equal's
@@ -568,6 +613,7 @@ static int std_validate_compound(const struct v4l2_ctrl *ctrl, u32 idx,
 	struct v4l2_ctrl_hevc_pps *p_hevc_pps;
 	struct v4l2_ctrl_hdr10_mastering_display *p_hdr10_mastering;
 	struct v4l2_ctrl_hevc_decode_params *p_hevc_decode_params;
+	struct v4l2_ctrl_vp8_encode_params *p_vp8_encode_params;
 	struct v4l2_area *area;
 	void *p = ptr.p + idx * ctrl->elem_size;
 	unsigned int i;
@@ -804,6 +850,15 @@ static int std_validate_compound(const struct v4l2_ctrl *ctrl, u32 idx,
 		zero_padding(p_vp8_frame->coder_state);
 		break;
 
+	case V4L2_CTRL_TYPE_VP8_ENCODE_PARAMS:
+		p_vp8_encode_params = p;
+		if (p_vp8_encode_params->loop_filter_level > 63)
+			return -EINVAL;
+
+		if (p_vp8_encode_params->sharpness_level > 7)
+			return -EINVAL;
+		break;
+
 	case V4L2_CTRL_TYPE_HEVC_SPS:
 		p_hevc_sps = p;
 
@@ -918,6 +973,15 @@ static int std_validate_compound(const struct v4l2_ctrl *ctrl, u32 idx,
 			return -EINVAL;
 		break;
 
+	case V4L2_CTRL_TYPE_ISP_STAT_REGION:
+		break;
+
+	case V4L2_CTRL_TYPE_H264_ENCODE_PARAMS:
+		return validate_h264_encode_params(p);
+
+	case V4L2_CTRL_TYPE_H264_ENCODE_RC:
+		return validate_h264_encode_rc(p);
+
 	default:
 		return -EINVAL;
 	}
@@ -1602,9 +1666,21 @@ static struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,
 	case V4L2_CTRL_TYPE_VP9_FRAME:
 		elem_size = sizeof(struct v4l2_ctrl_vp9_frame);
 		break;
+	case V4L2_CTRL_TYPE_ISP_STAT_REGION:
+		elem_size = sizeof(struct v4l2_ctrl_isp_stat_region);
+		break;
 	case V4L2_CTRL_TYPE_AREA:
 		elem_size = sizeof(struct v4l2_area);
 		break;
+	case V4L2_CTRL_TYPE_VP8_ENCODE_PARAMS:
+		elem_size = sizeof(struct v4l2_ctrl_vp8_encode_params);
+		break;
+	case V4L2_CTRL_TYPE_H264_ENCODE_PARAMS:
+		elem_size = sizeof(struct v4l2_ctrl_h264_encode_params);
+		break;
+	case V4L2_CTRL_TYPE_H264_ENCODE_RC:
+		elem_size = sizeof(struct v4l2_ctrl_h264_encode_rc);
+		break;
 	default:
 		if (type < V4L2_CTRL_COMPOUND_TYPES)
 			elem_size = sizeof(s32);
diff --git a/drivers/media/v4l2-core/v4l2-ctrls-defs.c b/drivers/media/v4l2-core/v4l2-ctrls-defs.c
index e22921e7e..d4afb01ef 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls-defs.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls-defs.c
@@ -1120,6 +1120,10 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_TEST_PATTERN:		return "Test Pattern";
 	case V4L2_CID_DEINTERLACING_MODE:	return "Deinterlacing Mode";
 	case V4L2_CID_DIGITAL_GAIN:		return "Digital Gain";
+	case V4L2_CID_ISP_STAT_REGION:		return "ISP Stat Region";
+	case V4L2_CID_ISP_STAT_AVG_FILTER:	return "ISP Stat Average Filter";
+	case V4L2_CID_ISP_STAT_BIN_COMP:	return "ISP Stat Bin Component";
+	case V4L2_CID_ISP_STAT_PROFILE:		return "ISP Stat Profile";
 
 	/* DV controls */
 	/* Keep the order of the 'case's the same as in v4l2-controls.h! */
@@ -1190,6 +1194,12 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_STATELESS_HEVC_START_CODE:		return "HEVC Start Code";
 	case V4L2_CID_STATELESS_HEVC_ENTRY_POINT_OFFSETS:	return "HEVC Entry Point Offsets";
 
+	case V4L2_CID_STATELESS_VP8_ENCODE_PARAMS:		return "VP8 Encode Parameters";
+	case V4L2_CID_STATELESS_VP8_ENCODE_QP:			return "VP8 Encode QP";
+
+	case V4L2_CID_STATELESS_H264_ENCODE_PARAMS:             return "H264 Encode Parameters";
+	case V4L2_CID_STATELESS_H264_ENCODE_RC:                 return "H264 Encode Rate-Control";
+
 	/* Colorimetry controls */
 	/* Keep the order of the 'case's the same as in v4l2-controls.h! */
 	case V4L2_CID_COLORIMETRY_CLASS:	return "Colorimetry Controls";
@@ -1529,6 +1539,9 @@ void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,
 	case V4L2_CID_STATELESS_VP9_FRAME:
 		*type = V4L2_CTRL_TYPE_VP9_FRAME;
 		break;
+	case V4L2_CID_STATELESS_VP8_ENCODE_PARAMS:
+		*type = V4L2_CTRL_TYPE_VP8_ENCODE_PARAMS;
+		break;
 	case V4L2_CID_UNIT_CELL_SIZE:
 		*type = V4L2_CTRL_TYPE_AREA;
 		*flags |= V4L2_CTRL_FLAG_READ_ONLY;
@@ -1539,6 +1552,15 @@ void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,
 	case V4L2_CID_COLORIMETRY_HDR10_MASTERING_DISPLAY:
 		*type = V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY;
 		break;
+	case V4L2_CID_ISP_STAT_REGION:
+		*type = V4L2_CTRL_TYPE_ISP_STAT_REGION;
+		break;
+	case V4L2_CID_STATELESS_H264_ENCODE_PARAMS:
+		*type = V4L2_CTRL_TYPE_H264_ENCODE_PARAMS;
+		break;
+	case V4L2_CID_STATELESS_H264_ENCODE_RC:
+		*type = V4L2_CTRL_TYPE_H264_ENCODE_RC;
+		break;
 	default:
 		*type = V4L2_CTRL_TYPE_INTEGER;
 		break;
diff --git a/drivers/media/v4l2-core/v4l2-fwnode.c b/drivers/media/v4l2-core/v4l2-fwnode.c
index 69c8b3b65..25ca8557b 100644
--- a/drivers/media/v4l2-core/v4l2-fwnode.c
+++ b/drivers/media/v4l2-core/v4l2-fwnode.c
@@ -347,6 +347,9 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 		pr_debug("data-enable-active %s\n", v ? "high" : "low");
 	}
 
+	if (!fwnode_property_read_u32(fwnode, "pclk-max-frequency", &v))
+		bus->pclk_max_frequency = v;
+
 	switch (bus_type) {
 	default:
 		bus->flags = flags;
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 6876ec25b..ababbcc89 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1446,6 +1446,8 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 	case V4L2_META_FMT_RK_ISP1_STAT_3A:	descr = "Rockchip ISP1 3A Statistics"; break;
 	case V4L2_PIX_FMT_NV12M_8L128:	descr = "NV12M (8x128 Linear)"; break;
 	case V4L2_PIX_FMT_NV12M_10BE_8L128:	descr = "10-bit NV12M (8x128 Linear, BE)"; break;
+	case V4L2_META_FMT_ST_DCMIPP_ISP_PARAMS: descr = "STM32 DCMIPP ISP Parameters"; break;
+	case V4L2_META_FMT_ST_DCMIPP_ISP_STAT: descr = "STM32 DCMIPP ISP Statistics"; break;
 
 	default:
 		/* Compressed formats */
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index fac290e48..bb77bb054 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -228,7 +228,7 @@ config RENESAS_RPCIF
 
 config STM32_FMC2_EBI
 	tristate "Support for FMC2 External Bus Interface on STM32MP SoCs"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	select MFD_SYSCON
 	help
 	  Select this option to enable the STM32 FMC2 External Bus Interface
@@ -236,6 +236,14 @@ config STM32_FMC2_EBI
 	  devices (like SRAM, ethernet adapters, FPGAs, LCD displays, ...) on
 	  SOCs containing the FMC2 External Bus Interface.
 
+config STM32_OMI
+	tristate "Support for OSPI Memory Interface on STM32MP SoCs"
+	depends on ARCH_STM32 || COMPILE_TEST
+	help
+	  Select this option to enable the STM32 OSPI Memory Interface controller
+	  (OMI) which provides either SPI or HyperBus support. This allows to support
+	  sNOR, sNAND or HyperFlash devices.
+
 source "drivers/memory/samsung/Kconfig"
 source "drivers/memory/tegra/Kconfig"
 
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index e148f636c..2653b5994 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_DA8XX_DDRCTL)	+= da8xx-ddrctl.o
 obj-$(CONFIG_PL353_SMC)		+= pl353-smc.o
 obj-$(CONFIG_RENESAS_RPCIF)	+= renesas-rpc-if.o
 obj-$(CONFIG_STM32_FMC2_EBI)	+= stm32-fmc2-ebi.o
+obj-$(CONFIG_STM32_OMI)		+= stm32-omi.o
 
 obj-$(CONFIG_SAMSUNG_MC)	+= samsung/
 obj-$(CONFIG_TEGRA_MC)		+= tegra/
diff --git a/drivers/memory/stm32-fmc2-ebi.c b/drivers/memory/stm32-fmc2-ebi.c
index ffec26a99..f317b8c80 100644
--- a/drivers/memory/stm32-fmc2-ebi.c
+++ b/drivers/memory/stm32-fmc2-ebi.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 
@@ -18,8 +19,15 @@
 #define FMC2_BCR(x)			((x) * 0x8 + FMC2_BCR1)
 #define FMC2_BTR(x)			((x) * 0x8 + FMC2_BTR1)
 #define FMC2_PCSCNTR			0x20
+#define FMC2_CFGR			0x20
+#define FMC2_SR				0x84
 #define FMC2_BWTR1			0x104
 #define FMC2_BWTR(x)			((x) * 0x8 + FMC2_BWTR1)
+#define FMC2_SECCFGR			0x300
+#define FMC2_CIDCFGR0			0x30c
+#define FMC2_CIDCFGR(x)			((x) * 0x8 + FMC2_CIDCFGR0)
+#define FMC2_SEMCR0			0x310
+#define FMC2_SEMCR(x)			((x) * 0x8 + FMC2_SEMCR0)
 
 /* Register: FMC2_BCR1 */
 #define FMC2_BCR1_CCLKEN		BIT(20)
@@ -40,6 +48,7 @@
 #define FMC2_BCR_ASYNCWAIT		BIT(15)
 #define FMC2_BCR_CPSIZE			GENMASK(18, 16)
 #define FMC2_BCR_CBURSTRW		BIT(19)
+#define FMC2_BCR_CSCOUNT		GENMASK(21, 20)
 #define FMC2_BCR_NBLSET			GENMASK(23, 22)
 
 /* Register: FMC2_BTRx/FMC2_BWTRx */
@@ -56,8 +65,28 @@
 #define FMC2_PCSCNTR_CSCOUNT		GENMASK(15, 0)
 #define FMC2_PCSCNTR_CNTBEN(x)		BIT((x) + 16)
 
+/* Register: FMC2_CFGR */
+#define FMC2_CFGR_CLKDIV		GENMASK(19, 16)
+#define FMC2_CFGR_CCLKEN		BIT(20)
+#define FMC2_CFGR_FMC2EN		BIT(31)
+
+/* Register: FMC2_SR */
+#define FMC2_SR_ISOST			GENMASK(1, 0)
+
+/* Register: FMC2_CIDCFGR */
+#define FMC2_CIDCFGR_CFEN		BIT(0)
+#define FMC2_CIDCFGR_SEMEN		BIT(1)
+#define FMC2_CIDCFGR_SCID		GENMASK(6, 4)
+#define FMC2_CIDCFGR_SEMWLC1		BIT(17)
+
+/* Register: FMC2_SEMCR */
+#define FMC2_SEMCR_SEM_MUTEX		BIT(0)
+#define FMC2_SEMCR_SEMCID		GENMASK(6, 4)
+
 #define FMC2_MAX_EBI_CE			4
 #define FMC2_MAX_BANKS			5
+#define FMC2_MAX_RESOURCES		6
+#define FMC2_CID1			1
 
 #define FMC2_BCR_CPSIZE_0		0x0
 #define FMC2_BCR_CPSIZE_128		0x1
@@ -72,6 +101,11 @@
 #define FMC2_BCR_MTYP_PSRAM		0x1
 #define FMC2_BCR_MTYP_NOR		0x2
 
+#define FMC2_BCR_CSCOUNT_0		0x0
+#define FMC2_BCR_CSCOUNT_1		0x1
+#define FMC2_BCR_CSCOUNT_64		0x2
+#define FMC2_BCR_CSCOUNT_256		0x3
+
 #define FMC2_BXTR_EXTMOD_A		0x0
 #define FMC2_BXTR_EXTMOD_B		0x1
 #define FMC2_BXTR_EXTMOD_C		0x2
@@ -86,6 +120,7 @@
 #define FMC2_BTR_CLKDIV_MAX		0xf
 #define FMC2_BTR_DATLAT_MAX		0xf
 #define FMC2_PCSCNTR_CSCOUNT_MAX	0xff
+#define FMC2_CFGR_CLKDIV_MAX		0xf
 
 enum stm32_fmc2_ebi_bank {
 	FMC2_EBI1 = 0,
@@ -99,7 +134,8 @@ enum stm32_fmc2_ebi_register_type {
 	FMC2_REG_BCR = 1,
 	FMC2_REG_BTR,
 	FMC2_REG_BWTR,
-	FMC2_REG_PCSCNTR
+	FMC2_REG_PCSCNTR,
+	FMC2_REG_CFGR
 };
 
 enum stm32_fmc2_ebi_transaction_type {
@@ -130,16 +166,42 @@ enum stm32_fmc2_ebi_cpsize {
 	FMC2_CPSIZE_1024 = 1024
 };
 
+enum stm32_fmc2_ebi_cscount {
+	FMC2_CSCOUNT_0 = 0,
+	FMC2_CSCOUNT_1 = 1,
+	FMC2_CSCOUNT_64 = 64,
+	FMC2_CSCOUNT_256 = 256
+};
+
+struct stm32_fmc2_ebi;
+
+struct stm32_fmc2_ebi_data {
+	const struct stm32_fmc2_prop *child_props;
+	unsigned int nb_child_props;
+	u32 fmc2_enable_reg;
+	u32 fmc2_enable_bit;
+	int (*nwait_used_by_ctrls)(struct stm32_fmc2_ebi *ebi);
+	void (*set_setup)(struct stm32_fmc2_ebi *ebi);
+	int (*save_setup)(struct stm32_fmc2_ebi *ebi);
+	int (*check_rif)(struct stm32_fmc2_ebi *ebi, u32 resource);
+	void (*put_sems)(struct stm32_fmc2_ebi *ebi);
+	void (*get_sems)(struct stm32_fmc2_ebi *ebi);
+};
+
 struct stm32_fmc2_ebi {
 	struct device *dev;
 	struct clk *clk;
 	struct regmap *regmap;
+	const struct stm32_fmc2_ebi_data *data;
 	u8 bank_assigned;
+	u8 sem_taken;
+	bool access_granted;
 
 	u32 bcr[FMC2_MAX_EBI_CE];
 	u32 btr[FMC2_MAX_EBI_CE];
 	u32 bwtr[FMC2_MAX_EBI_CE];
 	u32 pcscntr;
+	u32 cfgr;
 };
 
 /*
@@ -179,8 +241,11 @@ static int stm32_fmc2_ebi_check_mux(struct stm32_fmc2_ebi *ebi,
 				    int cs)
 {
 	u32 bcr;
+	int ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
 
 	if (bcr & FMC2_BCR_MTYP)
 		return 0;
@@ -193,8 +258,11 @@ static int stm32_fmc2_ebi_check_waitcfg(struct stm32_fmc2_ebi *ebi,
 					int cs)
 {
 	u32 bcr, val = FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_NOR);
+	int ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
 
 	if ((bcr & FMC2_BCR_MTYP) == val && bcr & FMC2_BCR_BURSTEN)
 		return 0;
@@ -207,8 +275,11 @@ static int stm32_fmc2_ebi_check_sync_trans(struct stm32_fmc2_ebi *ebi,
 					   int cs)
 {
 	u32 bcr;
+	int ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
 
 	if (bcr & FMC2_BCR_BURSTEN)
 		return 0;
@@ -216,13 +287,43 @@ static int stm32_fmc2_ebi_check_sync_trans(struct stm32_fmc2_ebi *ebi,
 	return -EINVAL;
 }
 
+static int stm32_fmc2_ebi_mp25_check_cclk(struct stm32_fmc2_ebi *ebi,
+					  const struct stm32_fmc2_prop *prop,
+					  int cs)
+{
+	if (!ebi->access_granted)
+		return -EACCES;
+
+	return stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);
+}
+
+static int stm32_fmc2_ebi_mp25_check_clk_period(struct stm32_fmc2_ebi *ebi,
+						const struct stm32_fmc2_prop *prop,
+						int cs)
+{
+	u32 cfgr;
+	int ret;
+
+	ret = regmap_read(ebi->regmap, FMC2_CFGR, &cfgr);
+	if (ret)
+		return ret;
+
+	if (cfgr & FMC2_CFGR_CCLKEN && !ebi->access_granted)
+		return -EACCES;
+
+	return stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);
+}
+
 static int stm32_fmc2_ebi_check_async_trans(struct stm32_fmc2_ebi *ebi,
 					    const struct stm32_fmc2_prop *prop,
 					    int cs)
 {
 	u32 bcr;
+	int ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
 
 	if (!(bcr & FMC2_BCR_BURSTEN) || !(bcr & FMC2_BCR_CBURSTRW))
 		return 0;
@@ -235,8 +336,11 @@ static int stm32_fmc2_ebi_check_cpsize(struct stm32_fmc2_ebi *ebi,
 				       int cs)
 {
 	u32 bcr, val = FIELD_PREP(FMC2_BCR_MTYP, FMC2_BCR_MTYP_PSRAM);
+	int ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
 
 	if ((bcr & FMC2_BCR_MTYP) == val && bcr & FMC2_BCR_BURSTEN)
 		return 0;
@@ -249,12 +353,18 @@ static int stm32_fmc2_ebi_check_address_hold(struct stm32_fmc2_ebi *ebi,
 					     int cs)
 {
 	u32 bcr, bxtr, val = FIELD_PREP(FMC2_BXTR_ACCMOD, FMC2_BXTR_EXTMOD_D);
+	int ret;
+
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
 	if (prop->reg_type == FMC2_REG_BWTR)
-		regmap_read(ebi->regmap, FMC2_BWTR(cs), &bxtr);
+		ret = regmap_read(ebi->regmap, FMC2_BWTR(cs), &bxtr);
 	else
-		regmap_read(ebi->regmap, FMC2_BTR(cs), &bxtr);
+		ret = regmap_read(ebi->regmap, FMC2_BTR(cs), &bxtr);
+	if (ret)
+		return ret;
 
 	if ((!(bcr & FMC2_BCR_BURSTEN) || !(bcr & FMC2_BCR_CBURSTRW)) &&
 	    ((bxtr & FMC2_BXTR_ACCMOD) == val || bcr & FMC2_BCR_MUXEN))
@@ -268,12 +378,19 @@ static int stm32_fmc2_ebi_check_clk_period(struct stm32_fmc2_ebi *ebi,
 					   int cs)
 {
 	u32 bcr, bcr1;
+	int ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
-	if (cs)
-		regmap_read(ebi->regmap, FMC2_BCR1, &bcr1);
-	else
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
+
+	if (cs) {
+		ret = regmap_read(ebi->regmap, FMC2_BCR1, &bcr1);
+		if (ret)
+			return ret;
+	} else {
 		bcr1 = bcr;
+	}
 
 	if (bcr & FMC2_BCR_BURSTEN && (!cs || !(bcr1 & FMC2_BCR1_CCLKEN)))
 		return 0;
@@ -305,18 +422,48 @@ static u32 stm32_fmc2_ebi_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
 {
 	u32 nb_clk_cycles = stm32_fmc2_ebi_ns_to_clock_cycles(ebi, cs, setup);
 	u32 bcr, btr, clk_period;
+	int ret;
+
+	ret = regmap_read(ebi->regmap, FMC2_BCR1, &bcr);
+	if (ret)
+		return ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR1, &bcr);
 	if (bcr & FMC2_BCR1_CCLKEN || !cs)
-		regmap_read(ebi->regmap, FMC2_BTR1, &btr);
+		ret = regmap_read(ebi->regmap, FMC2_BTR1, &btr);
 	else
-		regmap_read(ebi->regmap, FMC2_BTR(cs), &btr);
+		ret = regmap_read(ebi->regmap, FMC2_BTR(cs), &btr);
+	if (ret)
+		return ret;
 
 	clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
 
 	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
 }
 
+static u32 stm32_fmc2_ebi_mp25_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
+						int cs, u32 setup)
+{
+	u32 nb_clk_cycles = stm32_fmc2_ebi_ns_to_clock_cycles(ebi, cs, setup);
+	u32 cfgr, btr, clk_period;
+	int ret;
+
+	ret = regmap_read(ebi->regmap, FMC2_CFGR, &cfgr);
+	if (ret)
+		return ret;
+
+	if (cfgr & FMC2_CFGR_CCLKEN) {
+		clk_period = FIELD_GET(FMC2_CFGR_CLKDIV, cfgr) + 1;
+	} else {
+		ret = regmap_read(ebi->regmap, FMC2_BTR(cs), &btr);
+		if (ret)
+			return ret;
+
+		clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
+	}
+
+	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
+}
+
 static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 {
 	switch (reg_type) {
@@ -332,6 +479,9 @@ static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 	case FMC2_REG_PCSCNTR:
 		*reg = FMC2_PCSCNTR;
 		break;
+	case FMC2_REG_CFGR:
+		*reg = FMC2_CFGR;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -569,11 +719,16 @@ static int stm32_fmc2_ebi_set_address_setup(struct stm32_fmc2_ebi *ebi,
 	if (ret)
 		return ret;
 
-	regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+	if (ret)
+		return ret;
+
 	if (prop->reg_type == FMC2_REG_BWTR)
-		regmap_read(ebi->regmap, FMC2_BWTR(cs), &bxtr);
+		ret = regmap_read(ebi->regmap, FMC2_BWTR(cs), &bxtr);
 	else
-		regmap_read(ebi->regmap, FMC2_BTR(cs), &bxtr);
+		ret = regmap_read(ebi->regmap, FMC2_BTR(cs), &bxtr);
+	if (ret)
+		return ret;
 
 	if ((bxtr & FMC2_BXTR_ACCMOD) == val || bcr & FMC2_BCR_MUXEN)
 		val = clamp_val(setup, 1, FMC2_BXTR_ADDSET_MAX);
@@ -673,6 +828,30 @@ static int stm32_fmc2_ebi_set_clk_period(struct stm32_fmc2_ebi *ebi,
 	return 0;
 }
 
+static int stm32_fmc2_ebi_mp25_set_clk_period(struct stm32_fmc2_ebi *ebi,
+					      const struct stm32_fmc2_prop *prop,
+					      int cs, u32 setup)
+{
+	u32 val, cfgr;
+	int ret;
+
+	ret = regmap_read(ebi->regmap, FMC2_CFGR, &cfgr);
+	if (ret)
+		return ret;
+
+	if (cfgr & FMC2_CFGR_CCLKEN) {
+		val = setup ? clamp_val(setup - 1, 1, FMC2_CFGR_CLKDIV_MAX) : 1;
+		val = FIELD_PREP(FMC2_CFGR_CLKDIV, val);
+		regmap_update_bits(ebi->regmap, FMC2_CFGR, FMC2_CFGR_CLKDIV, val);
+	} else {
+		val = setup ? clamp_val(setup - 1, 1, FMC2_BTR_CLKDIV_MAX) : 1;
+		val = FIELD_PREP(FMC2_BTR_CLKDIV, val);
+		regmap_update_bits(ebi->regmap, FMC2_BTR(cs), FMC2_BTR_CLKDIV, val);
+	}
+
+	return 0;
+}
+
 static int stm32_fmc2_ebi_set_data_latency(struct stm32_fmc2_ebi *ebi,
 					   const struct stm32_fmc2_prop *prop,
 					   int cs, u32 setup)
@@ -691,11 +870,14 @@ static int stm32_fmc2_ebi_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
 					    int cs, u32 setup)
 {
 	u32 old_val, new_val, pcscntr;
+	int ret;
 
 	if (setup < 1)
 		return 0;
 
-	regmap_read(ebi->regmap, FMC2_PCSCNTR, &pcscntr);
+	ret = regmap_read(ebi->regmap, FMC2_PCSCNTR, &pcscntr);
+	if (ret)
+		return ret;
 
 	/* Enable counter for the bank */
 	regmap_update_bits(ebi->regmap, FMC2_PCSCNTR,
@@ -715,6 +897,27 @@ static int stm32_fmc2_ebi_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
 	return 0;
 }
 
+static int stm32_fmc2_ebi_mp25_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
+						 const struct stm32_fmc2_prop *prop,
+						 int cs, u32 setup)
+{
+	u32 val;
+
+	if (setup == FMC2_CSCOUNT_0)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_0);
+	else if (setup == FMC2_CSCOUNT_1)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_1);
+	else if (setup <= FMC2_CSCOUNT_64)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_64);
+	else
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_256);
+
+	regmap_update_bits(ebi->regmap, FMC2_BCR(cs),
+			   FMC2_BCR_CSCOUNT, val);
+
+	return 0;
+}
+
 static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	/* st,fmc2-ebi-cs-trans-type must be the first property */
 	{
@@ -880,6 +1083,275 @@ static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	},
 };
 
+static const struct stm32_fmc2_prop stm32_fmc2_mp25_child_props[] = {
+	/* st,fmc2-ebi-cs-trans-type must be the first property */
+	{
+		.name = "st,fmc2-ebi-cs-transaction-type",
+		.mprop = true,
+		.set = stm32_fmc2_ebi_set_trans_type,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-cclk-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_CFGR,
+		.reg_mask = FMC2_CFGR_CCLKEN,
+		.check = stm32_fmc2_ebi_mp25_check_cclk,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-mux-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_MUXEN,
+		.check = stm32_fmc2_ebi_check_mux,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-buswidth",
+		.reset_val = FMC2_BUSWIDTH_16,
+		.set = stm32_fmc2_ebi_set_buswidth,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-waitpol-high",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITPOL,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-waitcfg-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITCFG,
+		.check = stm32_fmc2_ebi_check_waitcfg,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-wait-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITEN,
+		.check = stm32_fmc2_ebi_check_sync_trans,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-asyncwait-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_ASYNCWAIT,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-cpsize",
+		.check = stm32_fmc2_ebi_check_cpsize,
+		.set = stm32_fmc2_ebi_set_cpsize,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-byte-lane-setup-ns",
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bl_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-address-setup-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_ADDSET_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-address-hold-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_ADDHLD_MAX,
+		.check = stm32_fmc2_ebi_check_address_hold,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-setup-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_DATAST_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-bus-turnaround-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bus_turnaround,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-hold-ns",
+		.reg_type = FMC2_REG_BTR,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-clk-period-ns",
+		.reset_val = FMC2_CFGR_CLKDIV_MAX + 1,
+		.check = stm32_fmc2_ebi_mp25_check_clk_period,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_mp25_set_clk_period,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-latency-ns",
+		.check = stm32_fmc2_ebi_check_sync_trans,
+		.calculate = stm32_fmc2_ebi_mp25_ns_to_clk_period,
+		.set = stm32_fmc2_ebi_set_data_latency,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-address-setup-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_ADDSET_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-address-hold-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_ADDHLD_MAX,
+		.check = stm32_fmc2_ebi_check_address_hold,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-data-setup-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_DATAST_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-bus-turnaround-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bus_turnaround,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-data-hold-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-max-low-pulse-ns",
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_mp25_set_max_low_pulse,
+	},
+};
+
+static int stm32_fmc2_ebi_mp25_check_rif(struct stm32_fmc2_ebi *ebi, u32 resource)
+{
+	u32 seccfgr, cidcfgr, semcr;
+	int cid, ret;
+
+	if (resource >= FMC2_MAX_RESOURCES)
+		return -EINVAL;
+
+	ret = regmap_read(ebi->regmap, FMC2_SECCFGR, &seccfgr);
+	if (ret)
+		return ret;
+
+	if (seccfgr & BIT(resource)) {
+		if (resource)
+			dev_err(ebi->dev, "resource %d is configured as secure\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	ret = regmap_read(ebi->regmap, FMC2_CIDCFGR(resource), &cidcfgr);
+	if (ret)
+		return ret;
+
+	if (!(cidcfgr & FMC2_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMEN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(FMC2_CIDCFGR_SCID, cidcfgr);
+		if (cid != FMC2_CID1) {
+			if (resource)
+				dev_err(ebi->dev, "static CID%d set for resource %d\n",
+					cid, resource);
+
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMWLC1)) {
+		if (resource)
+			dev_err(ebi->dev, "CID1 is block-listed for resource %d\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	ret = regmap_read(ebi->regmap, FMC2_SEMCR(resource), &semcr);
+	if (ret)
+		return ret;
+
+	if (!(semcr & FMC2_SEMCR_SEM_MUTEX)) {
+		regmap_update_bits(ebi->regmap, FMC2_SEMCR(resource),
+				   FMC2_SEMCR_SEM_MUTEX, FMC2_SEMCR_SEM_MUTEX);
+
+		ret = regmap_read(ebi->regmap, FMC2_SEMCR(resource), &semcr);
+		if (ret)
+			return ret;
+	}
+
+	cid = FIELD_GET(FMC2_SEMCR_SEMCID, semcr);
+	if (cid != FMC2_CID1) {
+		if (resource)
+			dev_err(ebi->dev, "resource %d is already used by CID%d\n",
+				resource, cid);
+
+		return -EACCES;
+	}
+
+	ebi->sem_taken |= BIT(resource);
+
+	return 0;
+}
+
+static void stm32_fmc2_ebi_mp25_put_sems(struct stm32_fmc2_ebi *ebi)
+{
+	unsigned int resource;
+
+	for (resource = 0; resource < FMC2_MAX_RESOURCES; resource++) {
+		if (!(ebi->sem_taken & BIT(resource)))
+			continue;
+
+		regmap_update_bits(ebi->regmap, FMC2_SEMCR(resource),
+				   FMC2_SEMCR_SEM_MUTEX, 0);
+	}
+}
+
+static void stm32_fmc2_ebi_mp25_get_sems(struct stm32_fmc2_ebi *ebi)
+{
+	unsigned int resource;
+
+	for (resource = 0; resource < FMC2_MAX_RESOURCES; resource++) {
+		if (!(ebi->sem_taken & BIT(resource)))
+			continue;
+
+		regmap_update_bits(ebi->regmap, FMC2_SEMCR(resource),
+				   FMC2_SEMCR_SEM_MUTEX, FMC2_SEMCR_SEM_MUTEX);
+	}
+}
+
 static int stm32_fmc2_ebi_parse_prop(struct stm32_fmc2_ebi *ebi,
 				     struct device_node *dev_node,
 				     const struct stm32_fmc2_prop *prop,
@@ -942,17 +1414,48 @@ static void stm32_fmc2_ebi_disable_bank(struct stm32_fmc2_ebi *ebi, int cs)
 	regmap_update_bits(ebi->regmap, FMC2_BCR(cs), FMC2_BCR_MBKEN, 0);
 }
 
-static void stm32_fmc2_ebi_save_setup(struct stm32_fmc2_ebi *ebi)
+static int stm32_fmc2_ebi_save_setup(struct stm32_fmc2_ebi *ebi)
 {
 	unsigned int cs;
+	int ret;
 
 	for (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {
-		regmap_read(ebi->regmap, FMC2_BCR(cs), &ebi->bcr[cs]);
-		regmap_read(ebi->regmap, FMC2_BTR(cs), &ebi->btr[cs]);
-		regmap_read(ebi->regmap, FMC2_BWTR(cs), &ebi->bwtr[cs]);
+		if (!(ebi->bank_assigned & BIT(cs)))
+			continue;
+
+		ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &ebi->bcr[cs]);
+		ret |= regmap_read(ebi->regmap, FMC2_BTR(cs), &ebi->btr[cs]);
+		ret |= regmap_read(ebi->regmap, FMC2_BWTR(cs), &ebi->bwtr[cs]);
+		if (ret)
+			return ret;
 	}
 
-	regmap_read(ebi->regmap, FMC2_PCSCNTR, &ebi->pcscntr);
+	return 0;
+}
+
+static int stm32_fmc2_ebi_mp1_save_setup(struct stm32_fmc2_ebi *ebi)
+{
+	int ret;
+
+	ret = stm32_fmc2_ebi_save_setup(ebi);
+	if (ret)
+		return ret;
+
+	return regmap_read(ebi->regmap, FMC2_PCSCNTR, &ebi->pcscntr);
+}
+
+static int stm32_fmc2_ebi_mp25_save_setup(struct stm32_fmc2_ebi *ebi)
+{
+	int ret;
+
+	ret = stm32_fmc2_ebi_save_setup(ebi);
+	if (ret)
+		return ret;
+
+	if (ebi->access_granted)
+		ret = regmap_read(ebi->regmap, FMC2_CFGR, &ebi->cfgr);
+
+	return ret;
 }
 
 static void stm32_fmc2_ebi_set_setup(struct stm32_fmc2_ebi *ebi)
@@ -960,14 +1463,29 @@ static void stm32_fmc2_ebi_set_setup(struct stm32_fmc2_ebi *ebi)
 	unsigned int cs;
 
 	for (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {
+		if (!(ebi->bank_assigned & BIT(cs)))
+			continue;
+
 		regmap_write(ebi->regmap, FMC2_BCR(cs), ebi->bcr[cs]);
 		regmap_write(ebi->regmap, FMC2_BTR(cs), ebi->btr[cs]);
 		regmap_write(ebi->regmap, FMC2_BWTR(cs), ebi->bwtr[cs]);
 	}
+}
 
+static void stm32_fmc2_ebi_mp1_set_setup(struct stm32_fmc2_ebi *ebi)
+{
+	stm32_fmc2_ebi_set_setup(ebi);
 	regmap_write(ebi->regmap, FMC2_PCSCNTR, ebi->pcscntr);
 }
 
+static void stm32_fmc2_ebi_mp25_set_setup(struct stm32_fmc2_ebi *ebi)
+{
+	stm32_fmc2_ebi_set_setup(ebi);
+
+	if (ebi->access_granted)
+		regmap_write(ebi->regmap, FMC2_CFGR, ebi->cfgr);
+}
+
 static void stm32_fmc2_ebi_disable_banks(struct stm32_fmc2_ebi *ebi)
 {
 	unsigned int cs;
@@ -981,33 +1499,48 @@ static void stm32_fmc2_ebi_disable_banks(struct stm32_fmc2_ebi *ebi)
 }
 
 /* NWAIT signal can not be connected to EBI controller and NAND controller */
-static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
+static int stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 {
+	struct device *dev = ebi->dev;
 	unsigned int cs;
 	u32 bcr;
+	int ret;
 
 	for (cs = 0; cs < FMC2_MAX_EBI_CE; cs++) {
 		if (!(ebi->bank_assigned & BIT(cs)))
 			continue;
 
-		regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+		ret = regmap_read(ebi->regmap, FMC2_BCR(cs), &bcr);
+		if (ret)
+			return ret;
+
 		if ((bcr & FMC2_BCR_WAITEN || bcr & FMC2_BCR_ASYNCWAIT) &&
-		    ebi->bank_assigned & BIT(FMC2_NAND))
-			return true;
+		    ebi->bank_assigned & BIT(FMC2_NAND)) {
+			dev_err(dev, "NWAIT signal connected to EBI and NAND controllers\n");
+			return -EINVAL;
+		}
 	}
 
-	return false;
+	return 0;
 }
 
 static void stm32_fmc2_ebi_enable(struct stm32_fmc2_ebi *ebi)
 {
-	regmap_update_bits(ebi->regmap, FMC2_BCR1,
-			   FMC2_BCR1_FMC2EN, FMC2_BCR1_FMC2EN);
+	if (!ebi->access_granted)
+		return;
+
+	regmap_update_bits(ebi->regmap, ebi->data->fmc2_enable_reg,
+			   ebi->data->fmc2_enable_bit,
+			   ebi->data->fmc2_enable_bit);
 }
 
 static void stm32_fmc2_ebi_disable(struct stm32_fmc2_ebi *ebi)
 {
-	regmap_update_bits(ebi->regmap, FMC2_BCR1, FMC2_BCR1_FMC2EN, 0);
+	if (!ebi->access_granted)
+		return;
+
+	regmap_update_bits(ebi->regmap, ebi->data->fmc2_enable_reg,
+			   ebi->data->fmc2_enable_bit, 0);
 }
 
 static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
@@ -1019,8 +1552,8 @@ static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
 
 	stm32_fmc2_ebi_disable_bank(ebi, cs);
 
-	for (i = 0; i < ARRAY_SIZE(stm32_fmc2_child_props); i++) {
-		const struct stm32_fmc2_prop *p = &stm32_fmc2_child_props[i];
+	for (i = 0; i < ebi->data->nb_child_props; i++) {
+		const struct stm32_fmc2_prop *p = &ebi->data->child_props[i];
 
 		ret = stm32_fmc2_ebi_parse_prop(ebi, dev_node, p, cs);
 		if (ret) {
@@ -1064,6 +1597,15 @@ static int stm32_fmc2_ebi_parse_dt(struct stm32_fmc2_ebi *ebi)
 			return -EINVAL;
 		}
 
+		if (ebi->data->check_rif) {
+			ret = ebi->data->check_rif(ebi, bank + 1);
+			if (ret) {
+				dev_err(dev, "bank access failed: %d\n", bank);
+				of_node_put(child);
+				return ret;
+			}
+		}
+
 		if (bank < FMC2_MAX_EBI_CE) {
 			ret = stm32_fmc2_ebi_setup_cs(ebi, child, bank);
 			if (ret) {
@@ -1083,9 +1625,10 @@ static int stm32_fmc2_ebi_parse_dt(struct stm32_fmc2_ebi *ebi)
 		return -ENODEV;
 	}
 
-	if (stm32_fmc2_ebi_nwait_used_by_ctrls(ebi)) {
-		dev_err(dev, "NWAIT signal connected to EBI and NAND controllers\n");
-		return -EINVAL;
+	if (ebi->data->nwait_used_by_ctrls) {
+		ret = ebi->data->nwait_used_by_ctrls(ebi);
+		if (ret)
+			return ret;
 	}
 
 	stm32_fmc2_ebi_enable(ebi);
@@ -1105,6 +1648,11 @@ static int stm32_fmc2_ebi_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	ebi->dev = dev;
+	platform_set_drvdata(pdev, ebi);
+
+	ebi->data = of_device_get_match_data(dev);
+	if (!ebi->data)
+		return -EINVAL;
 
 	ebi->regmap = device_node_to_regmap(dev->of_node);
 	if (IS_ERR(ebi->regmap))
@@ -1118,28 +1666,57 @@ static int stm32_fmc2_ebi_probe(struct platform_device *pdev)
 	if (PTR_ERR(rstc) == -EPROBE_DEFER)
 		return -EPROBE_DEFER;
 
-	ret = clk_prepare_enable(ebi->clk);
+	ret = devm_pm_runtime_enable(dev);
 	if (ret)
 		return ret;
 
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
 	if (!IS_ERR(rstc)) {
 		reset_control_assert(rstc);
 		reset_control_deassert(rstc);
 	}
 
+	/* Check if CFGR register can be modified */
+	ebi->access_granted = true;
+	if (ebi->data->check_rif) {
+		ret = ebi->data->check_rif(ebi, 0);
+		if (ret) {
+			u32 sr;
+
+			ebi->access_granted = false;
+
+			ret = regmap_read(ebi->regmap, FMC2_SR, &sr);
+			if (ret)
+				goto err_release;
+
+			/* In case of CFGR is secure, just check that the FMC2 is enabled */
+			if (sr & FMC2_SR_ISOST) {
+				dev_err(dev, "FMC2 is not ready to be used.\n");
+				ret = -EACCES;
+				goto err_release;
+			}
+		}
+	}
+
 	ret = stm32_fmc2_ebi_parse_dt(ebi);
 	if (ret)
 		goto err_release;
 
-	stm32_fmc2_ebi_save_setup(ebi);
-	platform_set_drvdata(pdev, ebi);
+	ret = ebi->data->save_setup(ebi);
+	if (ret)
+		goto err_release;
 
 	return 0;
 
 err_release:
 	stm32_fmc2_ebi_disable_banks(ebi);
 	stm32_fmc2_ebi_disable(ebi);
-	clk_disable_unprepare(ebi->clk);
+	if (ebi->data->put_sems)
+		ebi->data->put_sems(ebi);
+	pm_runtime_put_sync_suspend(dev);
 
 	return ret;
 }
@@ -1151,17 +1728,37 @@ static int stm32_fmc2_ebi_remove(struct platform_device *pdev)
 	of_platform_depopulate(&pdev->dev);
 	stm32_fmc2_ebi_disable_banks(ebi);
 	stm32_fmc2_ebi_disable(ebi);
+	if (ebi->data->put_sems)
+		ebi->data->put_sems(ebi);
+	pm_runtime_put_sync_suspend(&pdev->dev);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_fmc2_ebi_runtime_suspend(struct device *dev)
+{
+	struct stm32_fmc2_ebi *ebi = dev_get_drvdata(dev);
+
 	clk_disable_unprepare(ebi->clk);
 
 	return 0;
 }
 
+static int __maybe_unused stm32_fmc2_ebi_runtime_resume(struct device *dev)
+{
+	struct stm32_fmc2_ebi *ebi = dev_get_drvdata(dev);
+
+	return clk_prepare_enable(ebi->clk);
+}
+
 static int __maybe_unused stm32_fmc2_ebi_suspend(struct device *dev)
 {
 	struct stm32_fmc2_ebi *ebi = dev_get_drvdata(dev);
 
 	stm32_fmc2_ebi_disable(ebi);
-	clk_disable_unprepare(ebi->clk);
+	if (ebi->data->put_sems)
+		ebi->data->put_sems(ebi);
+	pm_runtime_put_sync_suspend(dev);
 	pinctrl_pm_select_sleep_state(dev);
 
 	return 0;
@@ -1174,21 +1771,55 @@ static int __maybe_unused stm32_fmc2_ebi_resume(struct device *dev)
 
 	pinctrl_pm_select_default_state(dev);
 
-	ret = clk_prepare_enable(ebi->clk);
-	if (ret)
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
 		return ret;
 
-	stm32_fmc2_ebi_set_setup(ebi);
+	if (ebi->data->get_sems)
+		ebi->data->get_sems(ebi);
+	ebi->data->set_setup(ebi);
 	stm32_fmc2_ebi_enable(ebi);
 
 	return 0;
 }
 
-static SIMPLE_DEV_PM_OPS(stm32_fmc2_ebi_pm_ops, stm32_fmc2_ebi_suspend,
-			 stm32_fmc2_ebi_resume);
+static const struct dev_pm_ops stm32_fmc2_ebi_pm_ops = {
+	SET_RUNTIME_PM_OPS(stm32_fmc2_ebi_runtime_suspend,
+			   stm32_fmc2_ebi_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_fmc2_ebi_suspend, stm32_fmc2_ebi_resume)
+};
+
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp1_data = {
+	.child_props = stm32_fmc2_child_props,
+	.nb_child_props = ARRAY_SIZE(stm32_fmc2_child_props),
+	.fmc2_enable_reg = FMC2_BCR1,
+	.fmc2_enable_bit = FMC2_BCR1_FMC2EN,
+	.nwait_used_by_ctrls = stm32_fmc2_ebi_nwait_used_by_ctrls,
+	.set_setup = stm32_fmc2_ebi_mp1_set_setup,
+	.save_setup = stm32_fmc2_ebi_mp1_save_setup,
+};
+
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp25_data = {
+	.child_props = stm32_fmc2_mp25_child_props,
+	.nb_child_props = ARRAY_SIZE(stm32_fmc2_mp25_child_props),
+	.fmc2_enable_reg = FMC2_CFGR,
+	.fmc2_enable_bit = FMC2_CFGR_FMC2EN,
+	.set_setup = stm32_fmc2_ebi_mp25_set_setup,
+	.save_setup = stm32_fmc2_ebi_mp25_save_setup,
+	.check_rif = stm32_fmc2_ebi_mp25_check_rif,
+	.put_sems = stm32_fmc2_ebi_mp25_put_sems,
+	.get_sems = stm32_fmc2_ebi_mp25_get_sems,
+};
 
 static const struct of_device_id stm32_fmc2_ebi_match[] = {
-	{.compatible = "st,stm32mp1-fmc2-ebi"},
+	{
+		.compatible = "st,stm32mp1-fmc2-ebi",
+		.data = &stm32_fmc2_ebi_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-ebi",
+		.data = &stm32_fmc2_ebi_mp25_data,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, stm32_fmc2_ebi_match);
diff --git a/drivers/memory/stm32-omi.c b/drivers/memory/stm32-omi.c
new file mode 100644
index 000000000..ea052290f
--- /dev/null
+++ b/drivers/memory/stm32-omi.c
@@ -0,0 +1,664 @@
+// SPDX-License-Identifier: GPL
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <memory/stm32-omi.h>
+
+static void stm32_omi_read_fifo(u8 *val, void __iomem *addr)
+{
+	*val = readb_relaxed(addr);
+}
+
+static void stm32_omi_write_fifo(u8 *val, void __iomem *addr)
+{
+	writeb_relaxed(*val, addr);
+}
+
+int stm32_omi_abort(struct stm32_omi *omi)
+{
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+	int timeout;
+
+	cr = readl_relaxed(regs_base + OSPI_CR) | CR_ABORT;
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	/* wait clear of abort bit by hw */
+	timeout = readl_relaxed_poll_timeout_atomic(regs_base + OSPI_CR,
+						    cr, !(cr & CR_ABORT), 1,
+						    STM32_ABT_TIMEOUT_US);
+
+	if (timeout && !omi->calibration)
+		dev_err(omi->dev, "%s abort timeout:%d\n", __func__, timeout);
+
+	return timeout;
+}
+EXPORT_SYMBOL(stm32_omi_abort);
+
+int stm32_omi_tx_poll(struct stm32_omi *omi, u8 *buf, u32 len, bool read)
+{
+	void __iomem *regs_base = omi->regs_base;
+	void (*tx_fifo)(u8 *val, void __iomem *addr);
+	u32 sr;
+	int ret;
+
+	if (read)
+		tx_fifo = stm32_omi_read_fifo;
+	else
+		tx_fifo = stm32_omi_write_fifo;
+
+	while (len--) {
+		ret = readl_relaxed_poll_timeout_atomic(regs_base + OSPI_SR,
+							sr, sr & SR_FTF, 1,
+							STM32_FIFO_TIMEOUT_US);
+		if (ret) {
+			if (!omi->calibration)
+				dev_err(omi->dev,
+					"fifo timeout (len:%d stat:%#x)\n",
+					len, sr);
+			return ret;
+		}
+		tx_fifo(buf++, regs_base + OSPI_DR);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(stm32_omi_tx_poll);
+
+int stm32_omi_wait_nobusy(struct stm32_omi *omi)
+{
+	u32 sr;
+
+	return readl_relaxed_poll_timeout_atomic(omi->regs_base + OSPI_SR,
+						 sr, !(sr & SR_BUSY), 1,
+						 STM32_BUSY_TIMEOUT_US);
+}
+EXPORT_SYMBOL(stm32_omi_wait_nobusy);
+
+int stm32_omi_wait_cmd(struct stm32_omi *omi)
+{
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr, sr;
+	int err = 0;
+
+	if ((readl_relaxed(regs_base + OSPI_SR) & SR_TCF) ||
+	    omi->fmode == CR_FMODE_APM)
+		goto out;
+
+	reinit_completion(&omi->data_completion);
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	writel_relaxed(cr | CR_TCIE | CR_TEIE, regs_base + OSPI_CR);
+
+	if (!wait_for_completion_timeout(&omi->data_completion,
+				msecs_to_jiffies(STM32_COMP_TIMEOUT_MS))) {
+		err = -ETIMEDOUT;
+	} else {
+		sr = readl_relaxed(regs_base + OSPI_SR);
+		if (sr & SR_TEF)
+			err = -EIO;
+	}
+
+out:
+	/* clear flags */
+	writel_relaxed(FCR_CTCF | FCR_CTEF, regs_base + OSPI_FCR);
+
+	if (!err)
+		err = stm32_omi_wait_nobusy(omi);
+
+	return err;
+}
+EXPORT_SYMBOL(stm32_omi_wait_cmd);
+
+void stm32_omi_dma_callback(void *arg)
+{
+	struct completion *dma_completion = arg;
+
+	complete(dma_completion);
+}
+EXPORT_SYMBOL(stm32_omi_dma_callback);
+
+static irqreturn_t stm32_omi_irq(int irq, void *dev_id)
+{
+	struct stm32_omi *omi = (struct stm32_omi *)dev_id;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr, sr;
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	sr = readl_relaxed(regs_base + OSPI_SR);
+
+	if (cr & CR_SMIE && sr & SR_SMF) {
+		/* disable irq */
+		cr &= ~CR_SMIE;
+		writel_relaxed(cr, regs_base + OSPI_CR);
+		complete(&omi->match_completion);
+
+		return IRQ_HANDLED;
+	}
+
+	if (sr & (SR_TEF | SR_TCF)) {
+		/* disable irq */
+		cr = readl_relaxed(regs_base + OSPI_CR);
+		cr &= ~CR_TCIE & ~CR_TEIE;
+		writel_relaxed(cr, regs_base + OSPI_CR);
+		complete(&omi->data_completion);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void stm32_omi_dma_setup(struct stm32_omi *omi,
+			 struct dma_slave_config *dma_cfg)
+{
+	if (dma_cfg && omi->dma_chrx) {
+		if (dmaengine_slave_config(omi->dma_chrx, dma_cfg)) {
+			dev_err(omi->dev, "dma rx config failed\n");
+			dma_release_channel(omi->dma_chrx);
+			omi->dma_chrx = NULL;
+		}
+	}
+
+	if (dma_cfg && omi->dma_chtx) {
+		if (dmaengine_slave_config(omi->dma_chtx, dma_cfg)) {
+			dev_err(omi->dev, "dma tx config failed\n");
+			dma_release_channel(omi->dma_chtx);
+			omi->dma_chtx = NULL;
+		}
+	}
+
+	init_completion(&omi->dma_completion);
+}
+EXPORT_SYMBOL(stm32_omi_dma_setup);
+
+static int stm32_omi_dlyb_set_tap(struct stm32_omi *omi, u8 tap, bool rx_tap)
+{
+	u32 sr, mask, ack;
+	int ret;
+	u8 shift;
+
+	if (rx_tap) {
+		mask = DLYBOS_CR_RXTAPSEL_MASK;
+		shift = DLYBOS_CR_RXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_RXTAPSEL_ACK;
+	} else {
+		mask = DLYBOS_CR_TXTAPSEL_MASK;
+		shift = DLYBOS_CR_TXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_TXTAPSEL_ACK;
+	}
+
+	regmap_update_bits(omi->regmap,
+			   omi->dlyb_base + SYSCFG_DLYBOS_CR,
+			   mask, mask & (tap << shift));
+
+	ret = regmap_read_poll_timeout(omi->regmap,
+				       omi->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & ack, 1,
+				       1000 * STM32_DLYBOS_TIMEOUT_MS);
+	if (ret)
+		dev_err(omi->dev, "%s delay Block phase configuration timeout\n",
+			rx_tap ? "RX" : "TX");
+
+	return ret;
+}
+
+int stm32_omi_dlyb_find_tap(struct stm32_omi *omi, bool rx_only, u8 *window_len)
+{
+	struct stm32_tap_window rx_tap_w[DLYBOS_TAPSEL_NB];
+	int ret = 0;
+	u8 rx_len, rx_window_len = 0, rx_window_end = 0;
+	u8 tx_len, tx_window_len, tx_window_end;
+	u8 rx_tap, tx_tap, tx_tap_max, tx_tap_min, best_tx_tap = 0;
+	u8 score, score_max;
+
+	tx_len = 0;
+	tx_window_len = 0;
+	tx_window_end = 0;
+
+	for (tx_tap = 0;
+	     tx_tap < (rx_only ? 1 : DLYBOS_TAPSEL_NB);
+	     tx_tap++) {
+		ret = stm32_omi_dlyb_set_tap(omi, tx_tap, false);
+		if (ret)
+			return ret;
+
+		rx_len = 0;
+		rx_window_len = 0;
+		rx_window_end = 0;
+
+		for (rx_tap = 0; rx_tap < DLYBOS_TAPSEL_NB; rx_tap++) {
+			ret = stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+			if (ret)
+				return ret;
+
+			omi->calibration = true;
+			ret = omi->check_transfer(omi);
+			omi->calibration = false;
+			if (ret) {
+				if ((!rx_only && ret == -ETIMEDOUT) ||
+				    ret == -EOPNOTSUPP)
+					break;
+
+				rx_len = 0;
+			} else {
+				rx_len++;
+				if (rx_len > rx_window_len) {
+					rx_window_len = rx_len;
+					rx_window_end = rx_tap;
+				}
+			}
+		}
+
+		if (ret == -EOPNOTSUPP)
+			break;
+
+		rx_tap_w[tx_tap].end = rx_window_end;
+		rx_tap_w[tx_tap].length = rx_window_len;
+
+		if (!rx_window_len) {
+			tx_len = 0;
+		} else {
+			tx_len++;
+			if (tx_len > tx_window_len) {
+				tx_window_len = tx_len;
+				tx_window_end = tx_tap;
+			}
+		}
+		dev_dbg(omi->dev, "rx_tap_w[%02d].end = %d rx_tap_w[%02d].length = %d\n",
+			tx_tap, rx_tap_w[tx_tap].end, tx_tap, rx_tap_w[tx_tap].length);
+	}
+
+	if (ret == -EOPNOTSUPP) {
+		dev_err(omi->dev, "Calibration can not be done on this device\n");
+		return ret;
+	}
+
+	if (rx_only) {
+		if (!rx_window_len) {
+			dev_err(omi->dev, "Can't find RX phase settings\n");
+			return -EIO;
+		}
+
+		rx_tap = rx_window_end - rx_window_len / 2;
+		*window_len = rx_window_len;
+		dev_dbg(omi->dev, "RX_TAP_SEL set to %d\n", rx_tap);
+
+		return stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+	}
+
+	/* find the best duet TX/RX TAP */
+	tx_tap_min = tx_window_end - tx_window_len + 1;
+	tx_tap_max = tx_window_end;
+	score_max = 0;
+	for (tx_tap = tx_tap_min; tx_tap <= tx_tap_max; tx_tap++) {
+		score = min_t(u8, tx_tap - tx_tap_min, tx_tap_max - tx_tap) +
+			rx_tap_w[tx_tap].length;
+		if (score > score_max) {
+			score_max = score;
+			best_tx_tap = tx_tap;
+		}
+	}
+
+	rx_tap = rx_tap_w[best_tx_tap].end - rx_tap_w[best_tx_tap].length / 2;
+
+	dev_dbg(omi->dev, "RX_TAP_SEL set to %d\n", rx_tap);
+	ret = stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+	if (ret)
+		return ret;
+
+	dev_dbg(omi->dev, "TX_TAP_SEL set to %d\n", best_tx_tap);
+
+	return stm32_omi_dlyb_set_tap(omi, best_tx_tap, false);
+}
+EXPORT_SYMBOL(stm32_omi_dlyb_find_tap);
+
+int stm32_omi_dlyb_set_cr(struct stm32_omi *omi, u32 dlyb_cr)
+{
+	bool bypass_mode = false;
+	int ret;
+	u16 period_ps;
+	u8 rx_tap, tx_tap;
+
+	period_ps = FIELD_GET(DLYBOS_BYP_CMD_MASK, dlyb_cr);
+	if ((dlyb_cr & DLYBOS_BYP_EN) == DLYBOS_BYP_EN)
+		bypass_mode = true;
+
+	ret = stm32_omi_dlyb_init(omi, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	/* restore Rx and TX tap */
+	rx_tap = FIELD_GET(DLYBOS_CR_RXTAPSEL_MASK, dlyb_cr);
+	ret = stm32_omi_dlyb_set_tap(omi, rx_tap, true);
+	if (ret)
+		return ret;
+
+	tx_tap = FIELD_GET(DLYBOS_CR_TXTAPSEL_MASK, dlyb_cr);
+	return stm32_omi_dlyb_set_tap(omi, tx_tap, false);
+}
+EXPORT_SYMBOL(stm32_omi_dlyb_set_cr);
+
+void stm32_omi_dlyb_get_cr(struct stm32_omi *omi, u32 *dlyb_cr)
+{
+	regmap_read(omi->regmap, omi->dlyb_base + SYSCFG_DLYBOS_CR, dlyb_cr);
+}
+EXPORT_SYMBOL(stm32_omi_dlyb_get_cr);
+
+/*  memory clock period in pico second */
+static const u16 dlybos_delay_ps[STM32_DLYBOS_DELAY_NB] = {
+2816, 4672, 6272, 7872, 9472, 11104, 12704, 14304, 15904, 17536, 19136, 20736,
+22336, 23968, 25568, 27168, 28768, 30400, 32000, 33600, 35232, 36832, 38432, 40032
+};
+
+static u32 stm32_omi_find_byp_cmd(u16 period_ps)
+{
+	u16 half_period_ps = period_ps / 2;
+	u8 max = STM32_DLYBOS_DELAY_NB - 1;
+	u8 i, min = 0;
+
+	/* find closest value in dlybos_delay_ps[] with half_period_ps*/
+	if (half_period_ps < dlybos_delay_ps[0])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, 1);
+
+	if (half_period_ps > dlybos_delay_ps[max])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, STM32_DLYBOS_DELAY_NB);
+
+	while (max - min > 1) {
+		i = DIV_ROUND_UP(min + max, 2);
+		if (half_period_ps > dlybos_delay_ps[i])
+			min = i;
+		else
+			max = i;
+	}
+
+	if ((dlybos_delay_ps[max] - half_period_ps) >
+	    (half_period_ps - dlybos_delay_ps[min]))
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, min + 1);
+	else
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, max + 1);
+}
+
+void stm32_omi_dlyb_stop(struct stm32_omi *omi)
+{
+	/* disable delay block */
+	regmap_write(omi->regmap, omi->dlyb_base + SYSCFG_DLYBOS_CR, 0x0);
+}
+EXPORT_SYMBOL(stm32_omi_dlyb_stop);
+
+int stm32_omi_dlyb_init(struct stm32_omi *omi, bool bypass_mode,
+			u16 period_ps)
+{
+	u32 sr, val, mask;
+	int ret;
+
+	if (bypass_mode) {
+		val = DLYBOS_BYP_EN;
+		val |= stm32_omi_find_byp_cmd(period_ps);
+		mask = DLYBOS_BYP_CMD_MASK | DLYBOS_BYP_EN;
+	} else {
+		val = DLYBOS_CR_EN;
+		mask = DLYBOS_CR_EN;
+	}
+
+	/* enable Delay Block */
+	regmap_update_bits(omi->regmap, omi->dlyb_base + SYSCFG_DLYBOS_CR,
+			   mask, val);
+
+	if (bypass_mode)
+		return 0;
+
+	/* in lock mode, wait for lock status bit */
+	ret = regmap_read_poll_timeout(omi->regmap,
+				       omi->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & DLYBOS_SR_LOCK, 1,
+				       1000 * STM32_DLYBOS_TIMEOUT_MS);
+	if (ret) {
+		dev_err(omi->dev, "Delay Block lock timeout\n");
+		stm32_omi_dlyb_stop(omi);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(stm32_omi_dlyb_init);
+
+static int stm32_omi_probe(struct platform_device *pdev)
+{
+	struct platform_device *vdev;
+	struct device *dev = &pdev->dev;
+	struct device_node *child;
+	struct stm32_omi *omi;
+	struct resource *res;
+	struct reserved_mem *rmem = NULL;
+	struct device_node *node;
+	const char *name;
+	u8 hyperflash_count = 0;
+	u8 spi_flash_count = 0;
+	u8 child_count = 0;
+	int ret;
+	bool jedec_flash = false;
+
+	/*
+	 * Flash subnodes sanity check:
+	 *        2 spi-nand/spi-nor flashes			=> supported
+	 *        1 HyperFlash					=> supported
+	 *	  All other flash node configuration		=> not supported
+	 */
+	for_each_available_child_of_node(dev->of_node, child) {
+		if (of_device_is_compatible(child, "cfi-flash"))
+			hyperflash_count++;
+
+		if (of_device_is_compatible(child, "jedec-flash")) {
+			hyperflash_count++;
+			jedec_flash = true;
+		}
+
+		if (of_device_is_compatible(child, "jedec,spi-nor") ||
+		    of_device_is_compatible(child, "spi-nand") ||
+		    of_device_is_compatible(child, "st,octal-bus"))
+			spi_flash_count++;
+
+		child_count++;
+	}
+
+	if (!child_count) {
+		dev_err(dev, "Missing flash node\n");
+		return -ENODEV;
+	}
+
+	if ((!hyperflash_count && !spi_flash_count) ||
+	    child_count != (hyperflash_count + spi_flash_count)) {
+		dev_err(dev, "Unknown flash type\n");
+		return -ENODEV;
+	}
+
+	if ((hyperflash_count && spi_flash_count) ||
+	     hyperflash_count > 1) {
+		dev_err(dev, "Flash node configuration not supported\n");
+		return -EINVAL;
+	}
+
+	if (spi_flash_count)
+		name = "stm32-ospi";
+	else
+		name = "stm32-hyperflash";
+
+	omi = devm_kzalloc(dev, sizeof(*omi), GFP_KERNEL);
+	if (!omi)
+		return -ENOMEM;
+
+	omi->jedec_flash = jedec_flash;
+	omi->regs_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(omi->regs_base))
+		return PTR_ERR(omi->regs_base);
+
+	omi->regs_phys_base = res->start;
+
+	omi->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(omi->clk))
+		return dev_err_probe(dev, PTR_ERR(omi->clk),
+				     "Can't get clock\n");
+
+	omi->clk_rate = clk_get_rate(omi->clk);
+	if (!omi->clk_rate) {
+		dev_err(dev, "Invalid clock rate\n");
+		return -EINVAL;
+	}
+
+	omi->irq = platform_get_irq(pdev, 0);
+	if (omi->irq < 0) {
+		dev_err(dev, "Can't get irq %d\n", omi->irq);
+		return omi->irq;
+	}
+
+	ret = devm_request_irq(dev, omi->irq, stm32_omi_irq, 0,
+			       dev_name(dev), omi);
+	if (ret) {
+		dev_err(dev, "Failed to request irq\n");
+		return ret;
+	}
+
+	omi->rstc = devm_reset_control_array_get(dev, false, true);
+	if (IS_ERR(omi->rstc))
+		return dev_err_probe(dev, PTR_ERR(omi->rstc),
+				     "Can't get reset\n");
+
+	omi->regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+						      "st,syscfg-dlyb");
+	if (IS_ERR(omi->regmap)) {
+		dev_err(dev, "Can't find st,syscfg-dlyb property\n");
+		return PTR_ERR(omi->regmap);
+	} else {
+		ret = of_property_read_u32_index(dev->of_node, "st,syscfg-dlyb",
+						 1, &omi->dlyb_base);
+		if (ret) {
+			dev_err(dev, "Can't read delay block base address\n");
+			return ret;
+		}
+	}
+
+	omi->dma_chrx = dma_request_chan(dev, "rx");
+	if (IS_ERR(omi->dma_chrx)) {
+		ret = PTR_ERR(omi->dma_chrx);
+		omi->dma_chrx = NULL;
+		if (ret == -EPROBE_DEFER)
+			goto err_dma;
+	}
+
+	omi->dma_chtx = dma_request_chan(dev, "tx");
+	if (IS_ERR(omi->dma_chtx)) {
+		ret = PTR_ERR(omi->dma_chtx);
+		omi->dma_chtx = NULL;
+		if (ret == -EPROBE_DEFER)
+			goto err_dma;
+	}
+
+	node = of_parse_phandle(dev->of_node, "memory-region", 0);
+	if (node)
+		rmem = of_reserved_mem_lookup(node);
+	of_node_put(node);
+
+	if (rmem) {
+		omi->mm_size = rmem->size;
+		omi->mm_base = devm_ioremap(dev, rmem->base, rmem->size);
+		if (IS_ERR(omi->mm_base)) {
+			dev_err(dev, "unable to map memory region: %pa+%pa\n",
+				&rmem->base, &rmem->size);
+			ret = PTR_ERR(omi->mm_base);
+			goto err_dma;
+		}
+
+		if (omi->mm_size > STM32_OMI_MAX_MMAP_SZ) {
+			dev_err(dev, "Memory map size outsize bounds\n");
+			ret = -EINVAL;
+			goto err_dma;
+		}
+	} else {
+		dev_info(dev, "No memory-map region found\n");
+	}
+
+	init_completion(&omi->data_completion);
+	init_completion(&omi->match_completion);
+
+	vdev = platform_device_alloc(name, PLATFORM_DEVID_AUTO);
+	if (!vdev) {
+		ret = -ENOMEM;
+		goto err_dma;
+	}
+
+	vdev->dev.parent = dev;
+
+	omi->dev = dev;
+	omi->vdev = vdev;
+	platform_set_drvdata(pdev, omi);
+
+	ret = platform_device_add(vdev);
+	if (ret) {
+		platform_device_put(vdev);
+		goto err_dma;
+	}
+
+	return 0;
+
+err_dma:
+	if (omi->dma_chtx)
+		dma_release_channel(omi->dma_chtx);
+	if (omi->dma_chrx)
+		dma_release_channel(omi->dma_chrx);
+
+	return ret;
+}
+
+static int stm32_omi_remove(struct platform_device *pdev)
+{
+	struct stm32_omi *omi = platform_get_drvdata(pdev);
+
+	platform_device_unregister(omi->vdev);
+
+	if (omi->dma_chtx)
+		dma_release_channel(omi->dma_chtx);
+	if (omi->dma_chrx)
+		dma_release_channel(omi->dma_chrx);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_omi_runtime_suspend(struct device *dev)
+{
+	struct stm32_omi *omi = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(omi->clk);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_omi_runtime_resume(struct device *dev)
+{
+	struct stm32_omi *omi = dev_get_drvdata(dev);
+
+	return clk_prepare_enable(omi->clk);
+}
+
+static const struct dev_pm_ops stm32_omi_pm_ops = {
+	SET_RUNTIME_PM_OPS(stm32_omi_runtime_suspend,
+			   stm32_omi_runtime_resume, NULL)
+};
+
+static const struct of_device_id stm32_omi_of_match[] = {
+	{ .compatible = "st,stm32mp25-omi", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_omi_of_match);
+
+static struct platform_driver stm32_omi_driver = {
+	.probe	= stm32_omi_probe,
+	.remove	= stm32_omi_remove,
+	.driver = {
+		.name =	"stm32-omi",
+		.of_match_table = stm32_omi_of_match,
+		.pm = &stm32_omi_pm_ops,
+	},
+};
+module_platform_driver(stm32_omi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics STM32 OSPI Memory Interface driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 43cb511fd..d097a8dde 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -2077,6 +2077,16 @@ config MFD_STPMIC1
 	  To compile this driver as a module, choose M here: the
 	  module will be called stpmic1.
 
+config MFD_STM32MP1_PWR
+	bool "STM32MP1 wake-up pins"
+	depends on MACH_STM32MP157
+	default y
+	help
+	  Select this option to enable STM32 PWR Wake-up pins driver.
+
+	  This driver provides interruptions that can be used to wake-up from
+	  suspend.
+
 config MFD_STMFX
 	tristate "Support for STMicroelectronics Multi-Function eXpander (STMFX)"
 	depends on I2C
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 7ed3ef4a6..3315f9cd5 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -258,6 +258,7 @@ obj-$(CONFIG_MFD_SUN4I_GPADC)	+= sun4i-gpadc.o
 
 obj-$(CONFIG_MFD_STM32_LPTIMER)	+= stm32-lptimer.o
 obj-$(CONFIG_MFD_STM32_TIMERS) 	+= stm32-timers.o
+obj-$(CONFIG_MFD_STM32MP1_PWR)	+= stm32-pwr.o
 obj-$(CONFIG_MFD_MXS_LRADC)     += mxs-lradc.o
 obj-$(CONFIG_MFD_SC27XX_PMIC)	+= sprd-sc27xx-spi.o
 obj-$(CONFIG_RAVE_SP_CORE)	+= rave-sp.o
diff --git a/drivers/mfd/stm32-lptimer.c b/drivers/mfd/stm32-lptimer.c
index 746e51a17..a11474f38 100644
--- a/drivers/mfd/stm32-lptimer.c
+++ b/drivers/mfd/stm32-lptimer.c
@@ -6,6 +6,7 @@
  * Inspired by Benjamin Gaignard's stm32-timers driver
  */
 
+#include <linux/bitfield.h>
 #include <linux/mfd/stm32-lptimer.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
@@ -48,6 +49,40 @@ static int stm32_lptimer_detect_encoder(struct stm32_lptimer *ddata)
 	return 0;
 }
 
+static int stm32_lptimer_detect_hwcfgr(struct device *dev, struct stm32_lptimer *ddata)
+{
+	u32 val;
+	int ret;
+
+	/* Try to guess parameters from HWCFGR: e.g. encodrer mode (STM32MP15) */
+	ret = regmap_read(ddata->regmap, STM32MP15_LPTIM_HWCFGR, &val);
+	if (ret)
+		return ret;
+
+	/* Fall back to legacy init if HWCFGR isn't present */
+	if (!val)
+		return stm32_lptimer_detect_encoder(ddata);
+
+	ddata->has_encoder = FIELD_GET(STM32MP15_LPTIM_HWCFGR_ENCODER, val);
+
+	ret = regmap_read(ddata->regmap, STM32MP15_LPTIM_VERR, &val);
+	if (ret)
+		return ret;
+
+	dev_dbg(dev, "LPTIM version: %lu.%lu\n",
+		FIELD_GET(STM32MP15_MAJREV_MASK, val),
+		FIELD_GET(STM32MP15_MINREV_MASK, val));
+
+	ret = regmap_read(ddata->regmap, STM32MP25_LPTIM_HWCFGR2, &val);
+	if (ret)
+		return ret;
+
+	/* Number of capture/compare channels */
+	ddata->num_cc_chans = FIELD_GET(STM32MP25_LPTIM_HWCFGR2_CHAN_NUM, val);
+
+	return 0;
+}
+
 static int stm32_lptimer_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -74,7 +109,7 @@ static int stm32_lptimer_probe(struct platform_device *pdev)
 	if (IS_ERR(ddata->clk))
 		return PTR_ERR(ddata->clk);
 
-	ret = stm32_lptimer_detect_encoder(ddata);
+	ret = stm32_lptimer_detect_hwcfgr(dev, ddata);
 	if (ret)
 		return ret;
 
@@ -85,6 +120,7 @@ static int stm32_lptimer_probe(struct platform_device *pdev)
 
 static const struct of_device_id stm32_lptimer_of_match[] = {
 	{ .compatible = "st,stm32-lptimer", },
+	{ .compatible = "st,stm32mp25-lptimer", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_lptimer_of_match);
diff --git a/drivers/mfd/stm32-pwr.c b/drivers/mfd/stm32-pwr.c
new file mode 100644
index 000000000..612be8079
--- /dev/null
+++ b/drivers/mfd/stm32-pwr.c
@@ -0,0 +1,414 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
+ * Author: Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <asm/exception.h>
+
+#define NB_WAKEUPPINS 6
+
+#define STM32_SVC_PWR 0x82001001
+#define STM32_WRITE 0x1
+#define STM32_SET_BITS 0x2
+#define STM32_CLEAR_BITS 0x3
+
+#define PWR_WKUP_OFFSET 0x20
+// PWR Registers
+#define WKUPCR 0x0
+#define WKUPFR 0x4
+#define MPUWKUPENR 0x8
+
+#define WKUP_FLAGS_MASK GENMASK(5, 0)
+
+// WKUPCR bits definition
+#define WKUP_EDGE_SHIFT 8
+#define WKUP_PULL_SHIFT 16
+#define WKUP_PULL_MASK GENMASK(1, 0)
+
+enum wkup_pull_setting {
+	WKUP_NO_PULL = 0,
+	WKUP_PULL_UP,
+	WKUP_PULL_DOWN,
+	WKUP_PULL_RESERVED
+};
+
+#define SMC(class, op, offset, val) do {				\
+	struct arm_smccc_res res;					\
+	arm_smccc_smc(class, op, PWR_WKUP_OFFSET + (offset), val,	\
+		      0, 0, 0, 0, &res);				\
+} while (0)								\
+
+struct stm32_pwr_data {
+	struct device *dev;
+	void __iomem *base;		/* IO Memory base address */
+	struct irq_domain *domain;	/* Domain for this controller */
+	int irq;			/* Parent interrupt */
+	u32 masked;			/* IRQ is masked */
+	u32 wake;			/* IRQ is wake on */
+	u32 pending;			/* IRQ has been received while wake on*/
+	int gpio[NB_WAKEUPPINS];
+};
+
+static void stm32_pwr_irq_ack(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	SMC(STM32_SVC_PWR, STM32_SET_BITS, WKUPCR, BIT(d->hwirq));
+}
+
+static void stm32_pwr_irq_set_state(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+
+	/* enable is not masker or wake enabled */
+	if (!(priv->masked & BIT(d->hwirq)) || (priv->wake & BIT(d->hwirq)))
+		SMC(STM32_SVC_PWR, STM32_SET_BITS, MPUWKUPENR, BIT(d->hwirq));
+	else
+		SMC(STM32_SVC_PWR, STM32_CLEAR_BITS, MPUWKUPENR, BIT(d->hwirq));
+}
+
+static void stm32_pwr_irq_mask(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	priv->masked |= BIT(d->hwirq);
+	stm32_pwr_irq_set_state(d);
+}
+
+static void stm32_pwr_irq_unmask(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	priv->masked &= ~BIT(d->hwirq);
+	stm32_pwr_irq_set_state(d);
+}
+
+static int stm32_pwr_irq_set_wake(struct irq_data *d, unsigned int on)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+	struct irq_data *parent = irq_get_irq_data(priv->irq);
+
+	dev_dbg(priv->dev, "irq:%lu on:%d\n", d->hwirq, on);
+	if (on) {
+		priv->wake |= BIT(d->hwirq);
+	} else {
+		priv->wake &= ~BIT(d->hwirq);
+		priv->pending &= ~BIT(d->hwirq);
+	}
+	stm32_pwr_irq_set_state(d);
+
+	if (parent->chip && parent->chip->irq_set_wake)
+		return parent->chip->irq_set_wake(parent, on);
+
+	return 0;
+}
+
+static int stm32_pwr_irq_set_type(struct irq_data *d, unsigned int flow_type)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+	int pin_id = d->hwirq;
+	u32 wkupcr;
+	int en;
+
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+
+	en = readl_relaxed(priv->base + MPUWKUPENR) & BIT(pin_id);
+	/* reference manual request to disable the wakeup pin while
+	 * changing the edge detection setting
+	 */
+	if (en)
+		stm32_pwr_irq_mask(d);
+
+	wkupcr = readl_relaxed(priv->base + WKUPCR);
+	switch (flow_type & IRQ_TYPE_SENSE_MASK) {
+	case IRQF_TRIGGER_FALLING:
+		wkupcr |= (1 << (WKUP_EDGE_SHIFT + pin_id));
+		break;
+	case IRQF_TRIGGER_RISING:
+		wkupcr &= ~(1 << (WKUP_EDGE_SHIFT + pin_id));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	SMC(STM32_SVC_PWR, STM32_WRITE, WKUPCR, wkupcr);
+
+	if (en)
+		stm32_pwr_irq_unmask(d);
+
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+static int stm32_pwr_set_affinity_parent(struct irq_data *data,
+					 const struct cpumask *dest, bool force)
+{
+	struct stm32_pwr_data *priv = data->domain->host_data;
+	struct irq_data *parent = irq_get_irq_data(priv->irq);
+
+	irq_data_update_effective_affinity(data, dest);
+
+	if (parent->chip && parent->chip->irq_set_affinity)
+		return parent->chip->irq_set_affinity(parent, dest, force);
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+#endif
+
+static int stm32_pwr_irq_request_resources(struct irq_data *d)
+{
+	struct stm32_pwr_data *priv = d->domain->host_data;
+	struct device_node *dn = priv->dev->of_node;
+	int gpio;
+	int ret;
+
+	if (!dn) {
+		dev_err(priv->dev, "No platform data\n");
+		return -ENODEV;
+	}
+
+	/* Get GPIO from device tree */
+	dev_dbg(priv->dev, "irq:%lu\n", d->hwirq);
+	gpio = of_get_named_gpio(dn, "st,wakeup-pins", d->hwirq);
+
+	if (gpio < 0) {
+		dev_err(priv->dev, "Failed to get wakeup gpio: %d", gpio);
+		return gpio;
+	}
+
+	/* GPIO request and configuration */
+	ret = devm_gpio_request_one(priv->dev, gpio, GPIOF_DIR_IN,
+				    "wake-up pin");
+	if (ret) {
+		dev_err(priv->dev, "Failed to request wake-up pin\n");
+		return -ENODEV;
+	}
+
+	priv->gpio[d->hwirq] = gpio;
+
+	return 0;
+}
+
+static struct irq_chip stm32_pwr_irq_chip = {
+	.name = "stm32-pwr-irq",
+	.irq_ack = stm32_pwr_irq_ack,
+	.irq_mask = stm32_pwr_irq_mask,
+	.irq_unmask = stm32_pwr_irq_unmask,
+	.irq_set_type = stm32_pwr_irq_set_type,
+	.irq_set_wake = stm32_pwr_irq_set_wake,
+	.irq_request_resources = stm32_pwr_irq_request_resources,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = stm32_pwr_set_affinity_parent,
+#endif
+};
+
+static int stm32_pwr_irq_set_pull_config(struct irq_domain *d, int pin_id,
+					 enum wkup_pull_setting config)
+{
+	struct stm32_pwr_data *priv = d->host_data;
+	u32 wkupcr;
+
+	dev_dbg(priv->dev, "irq:%d pull config:0x%x\n", pin_id, config);
+
+	if (config >= WKUP_PULL_RESERVED) {
+		pr_err("%s: bad irq pull config\n", __func__);
+		return -EINVAL;
+	}
+
+	wkupcr = readl_relaxed(priv->base + WKUPCR);
+	wkupcr &= ~((WKUP_PULL_MASK) << (WKUP_PULL_SHIFT + pin_id * 2));
+	wkupcr |= (config & WKUP_PULL_MASK) << (WKUP_PULL_SHIFT + pin_id * 2);
+
+	SMC(STM32_SVC_PWR, STM32_WRITE, WKUPCR, wkupcr);
+
+	return 0;
+}
+
+static int stm32_pwr_xlate(struct irq_domain *d, struct device_node *ctrlr,
+			   const u32 *intspec, unsigned int intsize,
+			   irq_hw_number_t *out_hwirq, unsigned int *out_type)
+{
+	if (WARN_ON(intsize < 3)) {
+		pr_err("%s: bad irq config parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	*out_hwirq = intspec[0];
+	*out_type = intspec[1] & (IRQ_TYPE_SENSE_MASK);
+
+	return stm32_pwr_irq_set_pull_config(d, intspec[0], intspec[2]);
+}
+
+static int stm32_pwr_alloc(struct irq_domain *d, unsigned int virq,
+			   unsigned int nr_irqs, void *data)
+{
+	struct irq_fwspec *fwspec = data;
+	irq_hw_number_t hwirq;
+
+	hwirq = fwspec->param[0];
+	irq_domain_set_info(d, virq, hwirq, &stm32_pwr_irq_chip, d->host_data,
+			    handle_edge_irq, NULL, NULL);
+
+	return 0;
+}
+
+static const struct irq_domain_ops stm32_pwr_irq_domain_ops = {
+	.alloc = stm32_pwr_alloc,
+	.xlate = stm32_pwr_xlate,
+	.free = irq_domain_free_irqs_common,
+};
+
+/*
+ * Handler for the cascaded IRQ.
+ */
+static void stm32_pwr_handle_irq(struct irq_desc *desc)
+{
+	struct stm32_pwr_data  *priv = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	u32 wkupfr, wkupenr, i;
+
+	chained_irq_enter(chip, desc);
+
+	wkupfr = readl_relaxed(priv->base + WKUPFR);
+	wkupenr = readl_relaxed(priv->base + MPUWKUPENR);
+
+	for (i = 0; i < NB_WAKEUPPINS; i++) {
+		if ((wkupfr & BIT(i)) && (wkupenr & BIT(i))) {
+			struct irq_desc *d;
+
+			d = irq_to_desc(irq_find_mapping(priv->domain, i));
+
+			if (priv->wake & BIT(i)) {
+				dev_dbg(priv->dev,
+					"irq %d while wake enabled\n", i);
+				priv->pending |= BIT(i);
+			}
+
+			dev_dbg(priv->dev, "handle wkup irq:%d\n", i);
+			handle_edge_irq(d);
+		}
+	}
+	chained_irq_exit(chip, desc);
+}
+
+static int __maybe_unused stm32_pwr_suspend(struct device *dev)
+{
+	struct stm32_pwr_data *priv = dev_get_drvdata(dev);
+
+	pr_debug("suspend");
+	if (priv->pending != 0)
+		return -EBUSY;
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_pwr_pm = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_pwr_suspend, NULL)
+};
+
+static int stm32_pwr_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_pwr_data *priv;
+	struct device_node *np = dev->of_node;
+	struct resource *res;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	priv->dev = dev;
+	dev_set_drvdata(dev, priv);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->base)) {
+		dev_err(dev, "Unable to map registers\n");
+		return PTR_ERR(priv->base);
+	}
+
+	/* Disable all wake-up pins */
+	SMC(STM32_SVC_PWR, STM32_WRITE, MPUWKUPENR, 0);
+	/* Clear all interrupts flags */
+	SMC(STM32_SVC_PWR, STM32_SET_BITS, WKUPCR, WKUP_FLAGS_MASK);
+
+	priv->domain = irq_domain_add_linear(np, NB_WAKEUPPINS,
+					     &stm32_pwr_irq_domain_ops, priv);
+	if (!priv->domain) {
+		dev_err(dev, "%s: Unable to add irq domain!\n", __func__);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = irq_of_parse_and_map(np, 0);
+	if (ret < 0) {
+		dev_err(dev, "failed to get PWR IRQ\n");
+		ret = priv->irq;
+		goto out_domain;
+	}
+
+	priv->irq = ret;
+	irq_set_chained_handler_and_data(priv->irq, stm32_pwr_handle_irq, priv);
+
+	of_node_clear_flag(np, OF_POPULATED);
+
+	return 0;
+
+out_domain:
+	irq_domain_remove(priv->domain);
+out:
+	return ret;
+}
+
+static int stm32_pwr_remove(struct platform_device *pdev)
+{
+	struct stm32_pwr_data *priv = dev_get_drvdata(&pdev->dev);
+
+	irq_domain_remove(priv->domain);
+	return 0;
+}
+
+static const struct of_device_id stm32_pwr_ids[] = {
+	{ .compatible = "st,stm32mp1-pwr", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_pwr_ids);
+
+static struct platform_driver stm32_pwr_driver = {
+	.probe		= stm32_pwr_probe,
+	.remove		= stm32_pwr_remove,
+	.driver		= {
+		.name	= "stm32_pwr",
+		.of_match_table = stm32_pwr_ids,
+		.pm = &stm32_pwr_pm,
+	},
+};
+
+static int __init stm32_pwr_init(void)
+{
+	return platform_driver_register(&stm32_pwr_driver);
+}
+
+static void __exit stm32_pwr_exit(void)
+{
+	return platform_driver_unregister(&stm32_pwr_driver);
+}
+
+arch_initcall(stm32_pwr_init);
+module_exit(stm32_pwr_exit);
diff --git a/drivers/mfd/stm32-timers.c b/drivers/mfd/stm32-timers.c
index 44ed2fce0..c888cbe46 100644
--- a/drivers/mfd/stm32-timers.c
+++ b/drivers/mfd/stm32-timers.c
@@ -172,6 +172,32 @@ static void stm32_timers_get_arr_size(struct stm32_timers *ddata)
 	regmap_write(ddata->regmap, TIM_ARR, arr);
 }
 
+static int stm32_timers_probe_hwcfgr(struct device *dev, struct stm32_timers *ddata)
+{
+	u32 val;
+
+	ddata->ipidr = (uintptr_t)device_get_match_data(dev);
+	if (!ddata->ipidr) {
+		/* fallback to legacy method for probing counter width */
+		stm32_timers_get_arr_size(ddata);
+		return 0;
+	}
+
+	regmap_read(ddata->regmap, TIM_IPIDR, &val);
+	/* Sanity check on IP identification register */
+	if (val != ddata->ipidr) {
+		dev_err(dev, "Unexpected identification: %u\n", val);
+		return -EINVAL;
+	}
+
+	regmap_read(ddata->regmap, TIM_HWCFGR2, &val);
+	/* Counter width in bits, max reload value is BIT(width) - 1 */
+	ddata->max_arr = BIT(FIELD_GET(TIM_HWCFGR2_CNT_WIDTH, val)) - 1;
+	dev_dbg(dev, "TIM width: %ld\n", FIELD_GET(TIM_HWCFGR2_CNT_WIDTH, val));
+
+	return 0;
+}
+
 static int stm32_timers_dma_probe(struct device *dev,
 				   struct stm32_timers *ddata)
 {
@@ -214,6 +240,48 @@ static void stm32_timers_dma_remove(struct device *dev,
 			dma_release_channel(ddata->dma.chans[i]);
 }
 
+static const char * const stm32_timers_irq_name[STM32_TIMERS_MAX_IRQS] = {
+	"brk", "up", "trg-com", "cc"
+};
+
+static int stm32_timers_irq_probe(struct platform_device *pdev,
+				  struct stm32_timers *ddata)
+{
+	int i, ret;
+
+	/*
+	 * STM32 Timer may have either:
+	 * - a unique global interrupt line
+	 * - four dedicated interrupt lines that may be handled separately.
+	 * Optionally get them here, to be used by child devices.
+	 */
+	ret = platform_get_irq_byname_optional(pdev, "global");
+	if (ret < 0 && ret != -ENXIO) {
+		return ret;
+	} else if (ret != -ENXIO) {
+		ddata->irq[STM32_TIMERS_IRQ_GLOBAL_BRK] = ret;
+		ddata->nr_irqs = 1;
+		return 0;
+	}
+
+	for (i = 0; i < STM32_TIMERS_MAX_IRQS; i++) {
+		ret = platform_get_irq_byname_optional(pdev, stm32_timers_irq_name[i]);
+		if (ret < 0 && ret != -ENXIO) {
+			return ret;
+		} else if (ret != -ENXIO) {
+			ddata->irq[i] = ret;
+			ddata->nr_irqs++;
+		}
+	}
+
+	if (ddata->nr_irqs && ddata->nr_irqs != STM32_TIMERS_MAX_IRQS) {
+		dev_err(&pdev->dev, "Invalid number of IRQs %d\n", ddata->nr_irqs);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int stm32_timers_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -243,7 +311,13 @@ static int stm32_timers_probe(struct platform_device *pdev)
 	if (IS_ERR(ddata->clk))
 		return PTR_ERR(ddata->clk);
 
-	stm32_timers_get_arr_size(ddata);
+	ret = stm32_timers_probe_hwcfgr(dev, ddata);
+	if (ret)
+		return ret;
+
+	ret = stm32_timers_irq_probe(pdev, ddata);
+	if (ret)
+		return ret;
 
 	ret = stm32_timers_dma_probe(dev, ddata);
 	if (ret) {
@@ -276,6 +350,7 @@ static int stm32_timers_remove(struct platform_device *pdev)
 
 static const struct of_device_id stm32_timers_of_match[] = {
 	{ .compatible = "st,stm32-timers", },
+	{ .compatible = "st,stm32mp25-timers", .data = (void *)STM32MP25_TIM_IPIDR },
 	{ /* end node */ },
 };
 MODULE_DEVICE_TABLE(of, stm32_timers_of_match);
diff --git a/drivers/mfd/stmfx.c b/drivers/mfd/stmfx.c
index b1ecd85ad..405b58646 100644
--- a/drivers/mfd/stmfx.c
+++ b/drivers/mfd/stmfx.c
@@ -81,13 +81,11 @@ static struct mfd_cell stmfx_cells[] = {
 		.num_resources = ARRAY_SIZE(stmfx_pinctrl_resources),
 	},
 	{
-		.of_compatible = "st,stmfx-0300-idd",
 		.name = "stmfx-idd",
 		.resources = stmfx_idd_resources,
 		.num_resources = ARRAY_SIZE(stmfx_idd_resources),
 	},
 	{
-		.of_compatible = "st,stmfx-0300-ts",
 		.name = "stmfx-ts",
 		.resources = stmfx_ts_resources,
 		.num_resources = ARRAY_SIZE(stmfx_ts_resources),
@@ -193,12 +191,28 @@ static void stmfx_irq_unmask(struct irq_data *data)
 	stmfx->irq_src |= BIT(data->hwirq % 8);
 }
 
+static int stmfx_irq_set_affinity(struct irq_data *d, const struct cpumask *dest, bool force)
+{
+	struct stmfx *stmfx = irq_data_get_irq_chip_data(d);
+	struct i2c_client *client = to_i2c_client(stmfx->dev);
+	static DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL * 10, 1);
+
+	if (__ratelimit(&rs))
+		dev_notice(stmfx->dev,
+			   "Can't set the affinity, set it for irq %d instead\n", client->irq);
+	if (force)
+		return -EINVAL;
+
+	return 0;
+}
+
 static struct irq_chip stmfx_irq_chip = {
 	.name			= "stmfx-core",
 	.irq_bus_lock		= stmfx_irq_bus_lock,
 	.irq_bus_sync_unlock	= stmfx_irq_bus_sync_unlock,
 	.irq_mask		= stmfx_irq_mask,
 	.irq_unmask		= stmfx_irq_unmask,
+	.irq_set_affinity	= IS_ENABLED(CONFIG_SMP) ? stmfx_irq_set_affinity : NULL,
 };
 
 static irqreturn_t stmfx_irq_handler(int irq, void *data)
@@ -306,6 +320,21 @@ static int stmfx_irq_init(struct i2c_client *client)
 	return ret;
 }
 
+static int stmfx_chip_wait_boot(struct stmfx *stmfx)
+{
+	unsigned long timeout_ms = 0;
+	unsigned int val;
+	int ret;
+
+	while (1) {
+		ret = regmap_read(stmfx->map, STMFX_REG_FW_VERSION_MSB, &val);
+		if (ret != -ENXIO || timeout_ms > STMFX_BOOT_TIME_MS)
+			return ret;
+		mdelay(1);
+		timeout_ms++;
+	}
+}
+
 static int stmfx_chip_reset(struct stmfx *stmfx)
 {
 	int ret;
@@ -342,6 +371,11 @@ static int stmfx_chip_init(struct i2c_client *client)
 			return ret;
 		}
 	}
+	ret = stmfx_chip_wait_boot(stmfx);
+	if (ret) {
+		dev_err(stmfx->dev, "Boot chip failed: %d\n", ret);
+		return ret;
+	}
 
 	ret = regmap_read(stmfx->map, STMFX_REG_CHIP_ID, &id);
 	if (ret) {
@@ -450,6 +484,10 @@ static int stmfx_probe(struct i2c_client *client,
 	if (ret)
 		goto err_chip_exit;
 
+	/* Parent I2C controller could use DMA, STMFX and child devices do not */
+	dev->coherent_dma_mask = 0;
+	dev->dma_mask = &dev->coherent_dma_mask;
+
 	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,
 				   stmfx_cells, ARRAY_SIZE(stmfx_cells), NULL,
 				   0, stmfx->irq_domain);
@@ -511,6 +549,11 @@ static int stmfx_resume(struct device *dev)
 			return ret;
 		}
 	}
+	ret = stmfx_chip_wait_boot(stmfx);
+	if (ret) {
+		dev_err(stmfx->dev, "Boot chip failed: %d\n", ret);
+		return ret;
+	}
 
 	/* Reset STMFX - supply has been stopped during suspend */
 	ret = stmfx_chip_reset(stmfx);
diff --git a/drivers/mfd/stpmic1.c b/drivers/mfd/stpmic1.c
index eb3da558c..7ff37a742 100644
--- a/drivers/mfd/stpmic1.c
+++ b/drivers/mfd/stpmic1.c
@@ -108,8 +108,9 @@ static const struct regmap_irq stpmic1_irqs[] = {
 static const struct regmap_irq_chip stpmic1_regmap_irq_chip = {
 	.name = "pmic_irq",
 	.status_base = INT_PENDING_R1,
-	.mask_base = INT_CLEAR_MASK_R1,
-	.unmask_base = INT_SET_MASK_R1,
+	.mask_base = INT_SET_MASK_R1,
+	.unmask_base = INT_CLEAR_MASK_R1,
+	.mask_unmask_non_inverted = true,
 	.ack_base = INT_CLEAR_R1,
 	.num_regs = STPMIC1_PMIC_NUM_IRQ_REGS,
 	.irqs = stpmic1_irqs,
@@ -170,6 +171,9 @@ static int stpmic1_suspend(struct device *dev)
 
 	disable_irq(pmic_dev->irq);
 
+	if (device_may_wakeup(dev))
+		enable_irq_wake(pmic_dev->irq);
+
 	return 0;
 }
 
@@ -183,6 +187,9 @@ static int stpmic1_resume(struct device *dev)
 	if (ret)
 		return ret;
 
+	if (device_may_wakeup(dev))
+		disable_irq_wake(pmic_dev->irq);
+
 	enable_irq(pmic_dev->irq);
 
 	return 0;
diff --git a/drivers/mfd/wm8994-core.c b/drivers/mfd/wm8994-core.c
index 7e88f5b0a..93449c2a6 100644
--- a/drivers/mfd/wm8994-core.c
+++ b/drivers/mfd/wm8994-core.c
@@ -185,6 +185,12 @@ static int wm8994_resume(struct device *dev)
 	if (!wm8994->suspended)
 		return 0;
 
+	/*
+	 * LDO1/2 minimum cycle time is 36ms according to codec specification
+	 * Wait before enabling regulator to make sure we fit this requirement
+	 */
+	msleep(40);
+
 	ret = regulator_bulk_enable(wm8994->num_supplies,
 				    wm8994->supplies);
 	if (ret != 0) {
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 0cef98319..e95bf0d60 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -436,6 +436,23 @@ config DW_XDATA_PCIE
 
 	  If unsure, say N.
 
+config STM32_OMM
+	bool "STM32 Octo Memory Manager"
+	depends on SPI_STM32_OSPI || TEST_COMPILE
+	help
+	  This driver manages the muxing between the 2 OSPI busses and
+	  the 2 output ports. There are 4 possible muxing configurations:
+	  - direct mode (no multiplexing): OSPI1 output is on port 1 and OSPI2
+	       output is on port 2
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 1
+	  - swapped mode (no multiplexing), OSPI1 output is on port 2,
+	       OSPI2 output is on port 1
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 2
+	  It also manages :
+	    - the split of the memory area shared between the 2 OSPI instances.
+	    - chip select selection override.
+	    - the time between 2 transactions in multiplexed mode.
+
 config PCI_ENDPOINT_TEST
 	depends on PCI
 	select CRC32
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index ac9b3e757..b5c255d92 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -62,3 +62,4 @@ obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
 obj-$(CONFIG_OPEN_DICE)		+= open-dice.o
 obj-$(CONFIG_GP_PCI1XXXX)	+= mchp_pci1xxxx/
 obj-$(CONFIG_VCPU_STALL_DETECTOR)	+= vcpu_stall_detector.o
+obj-$(CONFIG_STM32_OMM)	 	+= stm32_omm.o
diff --git a/drivers/misc/stm32_omm.c b/drivers/misc/stm32_omm.c
new file mode 100644
index 000000000..ed8f33078
--- /dev/null
+++ b/drivers/misc/stm32_omm.c
@@ -0,0 +1,519 @@
+// SPDX-License-Identifier: GPL
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <memory/stm32-omi.h>
+
+/* Temporary */
+#include "../bus/stm32_sys_bus.h"
+
+#define OMM_CR			0
+#define CR_MUXEN		BIT(0)
+#define CR_MUXENMODE_MASK	GENMASK(1, 0)
+#define CR_CSSEL_OVR_EN		BIT(4)
+#define CR_CSSEL_OVR_MASK	GENMASK(6, 5)
+#define CR_REQ2ACK_MASK		GENMASK(23, 16)
+
+#define OMM_CHILD_NB		2
+
+struct stm32_omm {
+	struct device_node *child_node[OMM_CHILD_NB];
+	struct device *child_dev[OMM_CHILD_NB];
+	struct clk *child_clk[OMM_CHILD_NB];
+	struct resource *mm_res;
+	struct clk *clk;
+	void __iomem *io_base;
+	u32 cr;
+	u8 nb_child;
+	bool restore_omm;
+};
+
+static int stm32_omm_set_amcr(struct device *dev, bool set)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+	struct regmap *syscfg_regmap;
+	struct device_node *node;
+	struct resource res, res1;
+	resource_size_t mm_ospi2_size = 0;
+	static const char * const mm_name[] = { "mm_ospi1", "mm_ospi2" };
+	u32 amcr_base, amcr_mask;
+	int ret, i, idx;
+	unsigned int amcr, read_amcr;
+
+	for (i = 0; i < omm->nb_child; i++) {
+		idx = of_property_match_string(dev->of_node,
+					       "memory-region-names",
+					       mm_name[i]);
+		if (idx < 0)
+			continue;
+
+		/* res1 only used on second loop iteration */
+		res1.start = res.start;
+		res1.end = res.end;
+
+		node = of_parse_phandle(dev->of_node, "memory-region", idx);
+		ret = of_address_to_resource(node, 0, &res);
+		if (ret) {
+			dev_err(dev, "unable to resolve memory region\n");
+			return ret;
+		}
+
+		/* check that memory region fits inside OMM memory map area */
+		if (!resource_contains(omm->mm_res, &res)) {
+			dev_err(dev, "%s doesn't fit inside OMM memory map area\n",
+				mm_name[i]);
+			dev_err(dev, "[0x%llx-0x%llx] doesn't fit inside [0x%llx-0x%llx]\n",
+				res.start, res.end,
+				omm->mm_res->start, omm->mm_res->end);
+
+			return -EFAULT;
+		}
+
+		if (i == 1) {
+			mm_ospi2_size = resource_size(&res);
+
+			/* check that OMM memory region 1 doesn't overlap memory region 2 */
+			if (resource_overlaps(&res, &res1)) {
+				dev_err(dev, "OMM memory-region %s overlaps memory region %s\n",
+					mm_name[0], mm_name[1]);
+				dev_err(dev, "[0x%llx-0x%llx] overlaps [0x%llx-0x%llx]\n",
+					res1.start, res1.end, res.start, res.end);
+
+				return -EFAULT;
+			}
+		}
+	}
+
+	syscfg_regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "st,syscfg-amcr");
+	if (IS_ERR(syscfg_regmap)) {
+		dev_err(dev, "Failed to get st,syscfg-amcr property\n");
+		return PTR_ERR(syscfg_regmap);
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "st,syscfg-amcr", 1,
+					 &amcr_base);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32_index(dev->of_node, "st,syscfg-amcr", 2,
+					 &amcr_mask);
+	if (ret)
+		return ret;
+
+	amcr = mm_ospi2_size / SZ_64M;
+
+	if (set)
+		regmap_update_bits(syscfg_regmap, amcr_base, amcr_mask, amcr);
+
+	/* read AMCR and check coherency with memory-map areas defined in DT */
+	regmap_read(syscfg_regmap, amcr_base, &read_amcr);
+	read_amcr = read_amcr >> (ffs(amcr_mask) - 1);
+
+	if (amcr != read_amcr) {
+		dev_err(dev, "AMCR value not coherent with DT memory-map areas\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int stm32_omm_enable_child_clock(struct device *dev, bool enable)
+{
+	/* As there is only 2 children, remember first child in case of error */
+	struct clk *first_child_clk = NULL;
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+	u8 i;
+	int ret;
+
+	for (i = 0; i < omm->nb_child; i++) {
+		if (enable) {
+			ret = clk_prepare_enable(omm->child_clk[i]);
+			if (ret) {
+				if (first_child_clk)
+					clk_disable_unprepare(first_child_clk);
+
+				dev_err(dev, "Can not enable clock\n");
+				return ret;
+			}
+		} else {
+			clk_disable_unprepare(omm->child_clk[i]);
+		}
+
+		first_child_clk = omm->child_clk[i];
+	}
+
+	return 0;
+}
+
+static int stm32_omm_configure(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+	struct reset_control *rstc;
+	unsigned long clk_rate, clk_rate_max = 0;
+	int ret;
+	u8 i;
+	u32 mux = 0;
+	u32 cssel_ovr = 0;
+	u32 req2ack = 0;
+
+	omm->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(omm->clk)) {
+		dev_err(dev, "Failed to get OMM clock (%ld)\n",
+			PTR_ERR(omm->clk));
+
+		return PTR_ERR(omm->clk);
+	}
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
+	/* parse children's clock */
+	for (i = 0; i < omm->nb_child; i++) {
+		clk_rate = clk_get_rate(omm->child_clk[i]);
+		if (!clk_rate) {
+			dev_err(dev, "Invalid clock rate\n");
+			goto err_clk_disable;
+		}
+
+		if (clk_rate > clk_rate_max)
+			clk_rate_max = clk_rate;
+	}
+
+	rstc = devm_reset_control_get_optional(dev, NULL);
+	if (IS_ERR(rstc)) {
+		ret = dev_err_probe(dev, PTR_ERR(rstc), "reset get failed\n");
+		goto err_clk_disable;
+	}
+
+	reset_control_assert(rstc);
+	udelay(2);
+	reset_control_deassert(rstc);
+
+	omm->cr = readl_relaxed(omm->io_base + OMM_CR);
+	/* optional */
+	ret = of_property_read_u32(dev->of_node, "st,omm-mux", &mux);
+	if (!ret) {
+		if (mux & CR_MUXEN) {
+			ret = of_property_read_u32(dev->of_node, "st,omm-req2ack-ns",
+						  &req2ack);
+			if (!ret && !req2ack) {
+				req2ack = DIV_ROUND_UP(req2ack, NSEC_PER_SEC / clk_rate_max) - 1;
+
+				if (req2ack > 256)
+					req2ack = 256;
+			}
+
+			req2ack = FIELD_PREP(CR_REQ2ACK_MASK, req2ack);
+
+			omm->cr &= ~CR_REQ2ACK_MASK;
+			omm->cr |= FIELD_PREP(CR_REQ2ACK_MASK, req2ack);
+
+			/*
+			 * If the mux is enabled, the 2 OSPI clocks have to be
+			 * always enabled
+			 */
+			ret = stm32_omm_enable_child_clock(dev, true);
+			if (ret)
+				goto err_clk_disable;
+		}
+
+		omm->cr &= ~CR_MUXENMODE_MASK;
+		omm->cr |= FIELD_PREP(CR_MUXENMODE_MASK, mux);
+	}
+
+	/* optional */
+	ret = of_property_read_u32(dev->of_node, "st,omm-cssel-ovr", &cssel_ovr);
+	if (!ret) {
+		omm->cr &= ~CR_CSSEL_OVR_MASK;
+		omm->cr |= FIELD_PREP(CR_CSSEL_OVR_MASK, cssel_ovr);
+		omm->cr |= CR_CSSEL_OVR_EN;
+	}
+
+	omm->restore_omm = true;
+	writel_relaxed(omm->cr, omm->io_base + OMM_CR);
+
+	ret = stm32_omm_set_amcr(dev, true);
+
+err_clk_disable:
+	pm_runtime_put_sync_suspend(dev);
+
+	return ret;
+}
+
+static int stm32_omm_check_access(struct device *dev, struct device_node *np)
+{
+	int err;
+	u32 feature_domain_cell[2];
+	u32 id_bus;
+
+	/* Get reg from device node */
+	err = of_property_read_u32_array(np, "feature-domains", feature_domain_cell, 2);
+	if (err) {
+		dev_err(dev, "Unable to find feature-domains property\n");
+		return -ENODEV;
+	}
+
+	id_bus = feature_domain_cell[1];
+
+	return stm32_rifsc_get_access_by_id(id_bus);
+}
+
+static int stm32_omm_disable_child(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+	struct regmap *omi_regmap;
+	u8 i;
+	int ret;
+
+	for (i = 0; i < omm->nb_child; i++) {
+		ret = clk_prepare_enable(omm->child_clk[i]);
+		if (ret) {
+			dev_err(dev, "Can not enable clock\n");
+			return ret;
+		}
+
+		omi_regmap = device_node_to_regmap(omm->child_node[i]);
+		if (IS_ERR(omi_regmap)) {
+			dev_err(dev, "failed to get OMI regmap for %s (%ld)",
+				omm->child_node[i]->full_name, PTR_ERR(omi_regmap));
+			return PTR_ERR(omi_regmap);
+		}
+
+		regmap_clear_bits(omi_regmap, OSPI_CR, CR_EN);
+		clk_disable_unprepare(omm->child_clk[i]);
+	}
+
+	return 0;
+}
+
+static int stm32_omm_probe(struct platform_device *pdev)
+{
+	struct platform_device *vdev;
+	struct device *dev = &pdev->dev;
+	struct device_node *child;
+	struct stm32_omm *omm;
+	int ret;
+	u8 child_access_granted = 0;
+	u8 i, j;
+	bool child_access[OMM_CHILD_NB];
+
+	omm = devm_kzalloc(dev, sizeof(*omm), GFP_KERNEL);
+	if (!omm)
+		return -ENOMEM;
+
+	omm->io_base = devm_platform_ioremap_resource_byname(pdev, "omm");
+	if (IS_ERR(omm->io_base))
+		return PTR_ERR(omm->io_base);
+
+	omm->mm_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "omm_mm");
+
+	/* check child's access */
+	for_each_child_of_node(dev->of_node, child) {
+		if (omm->nb_child >= OMM_CHILD_NB) {
+			dev_err(dev, "Bad DT, found too much children\n");
+			of_node_put(child);
+			ret = -E2BIG;
+			goto err_clk_release;
+		}
+
+		if (!of_device_is_compatible(child, "st,stm32mp25-omi")) {
+			ret = -EINVAL;
+			of_node_put(child);
+			goto err_clk_release;
+		}
+
+		ret = stm32_omm_check_access(dev, child);
+		if (ret < 0 && ret != -EACCES) {
+			of_node_put(child);
+			goto err_clk_release;
+		}
+
+		child_access[omm->nb_child] = false;
+		if (!ret) {
+			child_access_granted++;
+			child_access[omm->nb_child] = true;
+		}
+
+		omm->child_node[omm->nb_child] = child;
+		omm->child_clk[omm->nb_child] = of_clk_get(child, 0);
+		omm->nb_child++;
+	}
+
+	if (omm->nb_child != OMM_CHILD_NB) {
+		ret = -EINVAL;
+		goto err_clk_release;
+	}
+
+	platform_set_drvdata(pdev, omm);
+
+	pm_runtime_enable(dev);
+
+	/* check if OMM's resource access is granted */
+	ret = stm32_omm_check_access(dev, dev->of_node);
+	if (ret < 0 && ret != -EACCES)
+		goto err_clk_release;
+
+	if (!ret && child_access_granted == OMM_CHILD_NB) {
+		/* Ensure both OSPI instance are disabled before configuring OMM */
+		ret = stm32_omm_disable_child(dev);
+		if (ret)
+			goto err_clk_release;
+
+		ret = stm32_omm_configure(dev);
+		if (ret)
+			goto err_clk_release;
+	} else {
+		dev_dbg(dev, "Octo Memory Manager resource's access not granted\n");
+		/*
+		 * AMCR can't be set, so check if current value is coherent
+		 * with memory-map areas defined in DT
+		 */
+		ret = stm32_omm_set_amcr(dev, false);
+		if (ret)
+			goto err_clk_release;
+	}
+
+	/* for each child, if resource access is granted and status "okay", probe it */
+	for (i = 0; i < omm->nb_child; i++) {
+		if (!child_access[i] || !of_device_is_available(omm->child_node[i]))
+			continue;
+
+		vdev = of_platform_device_create(omm->child_node[i], NULL, NULL);
+		if (!vdev) {
+			dev_err(dev, "Failed to create Octo Memory Manager child\n");
+			for (j = i; j > 0; --j) {
+				if (omm->child_dev[j])
+					of_platform_device_destroy(omm->child_dev[j], NULL);
+			}
+
+			ret = -EINVAL;
+			goto err_clk_release;
+		}
+		omm->child_dev[i] = &vdev->dev;
+	}
+
+	return 0;
+
+err_clk_release:
+	for (i = 0; i < omm->nb_child; i++)
+		clk_put(omm->child_clk[i]);
+
+	return ret;
+}
+
+static int stm32_omm_remove(struct platform_device *pdev)
+{
+	struct stm32_omm *omm = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < omm->nb_child; i++)
+		if (omm->child_dev[i])
+			of_platform_device_destroy(omm->child_dev[i], NULL);
+
+	if (omm->cr & CR_MUXEN)
+		stm32_omm_enable_child_clock(&pdev->dev, false);
+
+	for (i = 0; i < omm->nb_child; i++)
+		clk_put(omm->child_clk[i]);
+
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static const struct of_device_id stm32_omm_of_match[] = {
+	{ .compatible = "st,stm32mp25-omm", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, stm32_omm_of_match);
+
+static int __maybe_unused stm32_omm_runtime_suspend(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(omm->clk);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_omm_runtime_resume(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+
+	return clk_prepare_enable(omm->clk);
+}
+
+static int __maybe_unused stm32_omm_suspend(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+
+	if (omm->restore_omm && omm->cr & CR_MUXEN)
+		stm32_omm_enable_child_clock(dev, false);
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_omm_resume(struct device *dev)
+{
+	struct stm32_omm *omm = dev_get_drvdata(dev);
+	int ret;
+
+	pinctrl_pm_select_default_state(dev);
+
+	if (!omm->restore_omm)
+		return 0;
+
+	/* Ensure both OSPI instance are disabled before configuring OMM */
+	ret = stm32_omm_disable_child(dev);
+	if (ret)
+		return ret;
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
+	writel_relaxed(omm->cr, omm->io_base + OMM_CR);
+	ret = stm32_omm_set_amcr(dev, true);
+	pm_runtime_put_sync_suspend(dev);
+	if (ret)
+		return ret;
+
+	if (omm->cr & CR_MUXEN)
+		ret = stm32_omm_enable_child_clock(dev, true);
+
+	return ret;
+}
+
+static const struct dev_pm_ops stm32_omm_pm_ops = {
+	SET_RUNTIME_PM_OPS(stm32_omm_runtime_suspend,
+			   stm32_omm_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_omm_suspend, stm32_omm_resume)
+};
+
+static struct platform_driver stm32_omm_driver = {
+	.probe	= stm32_omm_probe,
+	.remove = stm32_omm_remove,
+	.driver	= {
+		.name = "stm32-omm",
+		.of_match_table = stm32_omm_of_match,
+		.pm = &stm32_omm_pm_ops,
+	},
+};
+module_platform_driver(stm32_omm_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics Octo Memory Manager driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 9728b093f..ab673ae67 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -270,6 +270,8 @@ static struct variant_data variant_stm32_sdmmc = {
 	.datactrl_any_blocksz	= true,
 	.datactrl_mask_sdio	= MCI_DPSM_ST_SDIOEN,
 	.stm32_idmabsize_mask	= GENMASK(12, 5),
+	.stm32_idmabsize_align	= BIT(5),
+	.supports_sdio_irq	= true,
 	.busy_timeout		= true,
 	.busy_detect		= true,
 	.busy_detect_flag	= MCI_STM32_BUSYD0,
@@ -296,6 +298,37 @@ static struct variant_data variant_stm32_sdmmcv2 = {
 	.datactrl_any_blocksz	= true,
 	.datactrl_mask_sdio	= MCI_DPSM_ST_SDIOEN,
 	.stm32_idmabsize_mask	= GENMASK(16, 5),
+	.stm32_idmabsize_align	= BIT(5),
+	.supports_sdio_irq	= true,
+	.dma_lli		= true,
+	.busy_timeout		= true,
+	.busy_detect		= true,
+	.busy_detect_flag	= MCI_STM32_BUSYD0,
+	.busy_detect_mask	= MCI_STM32_BUSYD0ENDMASK,
+	.init			= sdmmc_variant_init,
+};
+
+static struct variant_data variant_stm32_sdmmcv3 = {
+	.fifosize		= 256 * 4,
+	.fifohalfsize		= 128 * 4,
+	.f_max			= 267000000,
+	.stm32_clkdiv		= true,
+	.cmdreg_cpsm_enable	= MCI_CPSM_STM32_ENABLE,
+	.cmdreg_lrsp_crc	= MCI_CPSM_STM32_LRSP_CRC,
+	.cmdreg_srsp_crc	= MCI_CPSM_STM32_SRSP_CRC,
+	.cmdreg_srsp		= MCI_CPSM_STM32_SRSP,
+	.cmdreg_stop		= MCI_CPSM_STM32_CMDSTOP,
+	.data_cmd_enable	= MCI_CPSM_STM32_CMDTRANS,
+	.irq_pio_mask		= MCI_IRQ_PIO_STM32_MASK,
+	.datactrl_first		= true,
+	.datacnt_useless	= true,
+	.datalength_bits	= 25,
+	.datactrl_blocksz	= 14,
+	.datactrl_any_blocksz	= true,
+	.datactrl_mask_sdio	= MCI_DPSM_ST_SDIOEN,
+	.stm32_idmabsize_mask	= GENMASK(16, 6),
+	.stm32_idmabsize_align	= BIT(6),
+	.supports_sdio_irq	= true,
 	.dma_lli		= true,
 	.busy_timeout		= true,
 	.busy_detect		= true,
@@ -389,8 +422,9 @@ void mmci_write_pwrreg(struct mmci_host *host, u32 pwr)
  */
 static void mmci_write_datactrlreg(struct mmci_host *host, u32 datactrl)
 {
-	/* Keep busy mode in DPSM if enabled */
-	datactrl |= host->datactrl_reg & host->variant->busy_dpsm_flag;
+	/* Keep busy mode in DPSM and SDIO mask if enabled */
+	datactrl |= host->datactrl_reg & (host->variant->busy_dpsm_flag |
+					  host->variant->datactrl_mask_sdio);
 
 	if (host->datactrl_reg != datactrl) {
 		host->datactrl_reg = datactrl;
@@ -1606,6 +1640,25 @@ static irqreturn_t mmci_pio_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static void mmci_write_sdio_irq_bit(struct mmci_host *host, int enable)
+{
+	void __iomem *base = host->base;
+	u32 mask = readl_relaxed(base + MMCIMASK0);
+
+	if (enable)
+		writel_relaxed(mask | MCI_ST_SDIOITMASK, base + MMCIMASK0);
+	else
+		writel_relaxed(mask & ~MCI_ST_SDIOITMASK, base + MMCIMASK0);
+}
+
+static void mmci_signal_sdio_irq(struct mmci_host *host, u32 status)
+{
+	if (status & MCI_ST_SDIOIT) {
+		mmci_write_sdio_irq_bit(host, 0);
+		sdio_signal_irq(host->mmc);
+	}
+}
+
 /*
  * Handle completion of command and data transfers.
  */
@@ -1650,6 +1703,9 @@ static irqreturn_t mmci_irq(int irq, void *dev_id)
 			mmci_data_irq(host, host->data, status);
 		}
 
+		if (host->variant->supports_sdio_irq)
+			mmci_signal_sdio_irq(host, status);
+
 		/*
 		 * Busy detection has been handled by mmci_cmd_irq() above.
 		 * Clear the status bit to prevent polling in IRQ context.
@@ -1886,6 +1942,35 @@ static int mmci_sig_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)
 	return ret;
 }
 
+static void mmci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct mmci_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	if (enable)
+		/* Keep the SDIO mode bit if SDIO irqs are enabled */
+		pm_runtime_get_sync(mmc_dev(mmc));
+
+	spin_lock_irqsave(&host->lock, flags);
+	mmci_write_sdio_irq_bit(host, enable);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (!enable) {
+		pm_runtime_mark_last_busy(mmc_dev(mmc));
+		pm_runtime_put_autosuspend(mmc_dev(mmc));
+	}
+}
+
+static void mmci_ack_sdio_irq(struct mmc_host *mmc)
+{
+	struct mmci_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	mmci_write_sdio_irq_bit(host, 1);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
 static struct mmc_host_ops mmci_ops = {
 	.request	= mmci_request,
 	.pre_req	= mmci_pre_request,
@@ -2161,6 +2246,16 @@ static int mmci_probe(struct amba_device *dev,
 		mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;
 	}
 
+	if (variant->supports_sdio_irq && host->mmc->caps & MMC_CAP_SDIO_IRQ) {
+		mmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
+
+		mmci_ops.enable_sdio_irq = mmci_enable_sdio_irq;
+		mmci_ops.ack_sdio_irq	= mmci_ack_sdio_irq;
+
+		mmci_write_datactrlreg(host,
+				       host->variant->datactrl_mask_sdio);
+	}
+
 	/* Variants with mandatory busy timeout in HW needs R1B responses. */
 	if (variant->busy_timeout)
 		mmc->caps |= MMC_CAP_NEED_RSP_BUSY;
@@ -2441,6 +2536,11 @@ static const struct amba_id mmci_ids[] = {
 		.mask	= 0xf0ffffff,
 		.data	= &variant_stm32_sdmmcv2,
 	},
+	{
+		.id     = 0x00353180,
+		.mask	= 0xf0ffffff,
+		.data	= &variant_stm32_sdmmcv3,
+	},
 	/* Qualcomm variants */
 	{
 		.id     = 0x00051180,
diff --git a/drivers/mmc/host/mmci.h b/drivers/mmc/host/mmci.h
index e1a9b96a3..02f702d70 100644
--- a/drivers/mmc/host/mmci.h
+++ b/drivers/mmc/host/mmci.h
@@ -218,6 +218,11 @@
 #define MCI_STM32_BUSYD0ENDMASK	BIT(21)
 
 #define MMCIMASK1		0x040
+
+/* STM32 sdmmc data FIFO threshold register */
+#define MMCI_STM32_FIFOTHRR	0x044
+#define MMCI_STM32_THR_MASK	GENMASK(3, 0)
+
 #define MMCIFIFOCNT		0x048
 #define MMCIFIFO		0x080 /* to 0x0bc */
 
@@ -227,8 +232,6 @@
 #define MMCI_STM32_IDMALLIEN	BIT(1)
 
 #define MMCI_STM32_IDMABSIZER		0x054
-#define MMCI_STM32_IDMABNDT_SHIFT	5
-#define MMCI_STM32_IDMABNDT_MASK	GENMASK(12, 5)
 
 #define MMCI_STM32_IDMABASE0R	0x058
 
@@ -315,6 +318,7 @@ struct mmci_host;
  *	       register.
  * @opendrain: bitmask identifying the OPENDRAIN bit inside MMCIPOWER register
  * @dma_lli: true if variant has dma link list feature.
+ * @supports_sdio_irq: allow SD I/O card to interrupt the host
  * @stm32_idmabsize_mask: stm32 sdmmc idma buffer size.
  */
 struct variant_data {
@@ -360,7 +364,9 @@ struct variant_data {
 	u32			start_err;
 	u32			opendrain;
 	u8			dma_lli:1;
+	bool			supports_sdio_irq;
 	u32			stm32_idmabsize_mask;
+	u32			stm32_idmabsize_align;
 	void (*init)(struct mmci_host *host);
 };
 
diff --git a/drivers/mmc/host/mmci_stm32_sdmmc.c b/drivers/mmc/host/mmci_stm32_sdmmc.c
index 0511583ff..d18e50e2e 100644
--- a/drivers/mmc/host/mmci_stm32_sdmmc.c
+++ b/drivers/mmc/host/mmci_stm32_sdmmc.c
@@ -15,7 +15,6 @@
 #include "mmci.h"
 
 #define SDMMC_LLI_BUF_LEN	PAGE_SIZE
-#define SDMMC_IDMA_BURST	BIT(MMCI_STM32_IDMABNDT_SHIFT)
 
 #define DLYB_CR			0x0
 #define DLYB_CR_DEN		BIT(0)
@@ -34,6 +33,20 @@
 #define DLYB_LNG_TIMEOUT_US	1000
 #define SDMMC_VSWEND_TIMEOUT_US 10000
 
+#define SYSCFG_DLYBSD_CR	0x0
+#define DLYBSD_CR_EN		BIT(0)
+#define DLYBSD_CR_RXTAPSEL_MASK	GENMASK(6, 1)
+#define DLYBSD_TAPSEL_NB	32
+#define DLYBSD_BYP_EN		BIT(16)
+#define DLYBSD_BYP_CMD		GENMASK(21, 17)
+#define DLYBSD_ANTIGLITCH_EN	BIT(22)
+
+#define SYSCFG_DLYBSD_SR	0x4
+#define DLYBSD_SR_LOCK		BIT(0)
+#define DLYBSD_SR_RXTAPSEL_ACK	BIT(1)
+
+#define DLYBSD_TIMEOUT_1S_IN_US	1000000
+
 struct sdmmc_lli_desc {
 	u32 idmalar;
 	u32 idmabase;
@@ -48,10 +61,21 @@ struct sdmmc_idma {
 	bool use_bounce_buffer;
 };
 
+struct sdmmc_dlyb;
+
+struct sdmmc_tuning_ops {
+	int (*dlyb_enable)(struct sdmmc_dlyb *dlyb);
+	void (*set_input_ck)(struct sdmmc_dlyb *dlyb);
+	int (*tuning_prepare)(struct mmci_host *host);
+	int (*set_cfg)(struct sdmmc_dlyb *dlyb, int unit __maybe_unused,
+		       int phase, bool sampler __maybe_unused);
+};
+
 struct sdmmc_dlyb {
 	void __iomem *base;
 	u32 unit;
 	u32 max;
+	struct sdmmc_tuning_ops *ops;
 };
 
 static int sdmmc_idma_validate_data(struct mmci_host *host,
@@ -69,7 +93,8 @@ static int sdmmc_idma_validate_data(struct mmci_host *host,
 	idma->use_bounce_buffer = false;
 	for_each_sg(data->sg, sg, data->sg_len - 1, i) {
 		if (!IS_ALIGNED(sg->offset, sizeof(u32)) ||
-		    !IS_ALIGNED(sg->length, SDMMC_IDMA_BURST)) {
+		    !IS_ALIGNED(sg->length,
+				host->variant->stm32_idmabsize_align)) {
 			dev_dbg(mmc_dev(host->mmc),
 				"unaligned scatterlist: ofst:%x length:%d\n",
 				data->sg->offset, data->sg->length);
@@ -316,23 +341,13 @@ static void mmci_sdmmc_set_clkreg(struct mmci_host *host, unsigned int desired)
 	clk |= host->clk_reg_add;
 	clk |= ddr;
 
-	/*
-	 * SDMMC_FBCK is selected when an external Delay Block is needed
-	 * with SDR104 or HS200.
-	 */
-	if (host->mmc->ios.timing >= MMC_TIMING_UHS_SDR50) {
+	if (host->mmc->ios.timing >= MMC_TIMING_UHS_SDR50)
 		clk |= MCI_STM32_CLK_BUSSPEED;
-		if (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104 ||
-		    host->mmc->ios.timing == MMC_TIMING_MMC_HS200) {
-			clk &= ~MCI_STM32_CLK_SEL_MSK;
-			clk |= MCI_STM32_CLK_SELFBCK;
-		}
-	}
 
 	mmci_write_clkreg(host, clk);
 }
 
-static void sdmmc_dlyb_input_ck(struct sdmmc_dlyb *dlyb)
+static void sdmmc_dlyb_mp15_input_ck(struct sdmmc_dlyb *dlyb)
 {
 	if (!dlyb || !dlyb->base)
 		return;
@@ -349,7 +364,8 @@ static void mmci_sdmmc_set_pwrreg(struct mmci_host *host, unsigned int pwr)
 	/* adds OF options */
 	pwr = host->pwr_reg_add;
 
-	sdmmc_dlyb_input_ck(dlyb);
+	if (dlyb && dlyb->ops->set_input_ck)
+		dlyb->ops->set_input_ck(dlyb);
 
 	if (ios.power_mode == MMC_POWER_OFF) {
 		/* Only a reset could power-off sdmmc */
@@ -394,6 +410,19 @@ static u32 sdmmc_get_dctrl_cfg(struct mmci_host *host)
 
 	datactrl = mmci_dctrl_blksz(host);
 
+	if (host->hw_revision >= 3) {
+		u32 thr = 0;
+
+		if (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104 ||
+		    host->mmc->ios.timing == MMC_TIMING_MMC_HS200) {
+			thr = ffs(min_t(unsigned int, host->data->blksz,
+					host->variant->fifosize));
+			thr = min_t(u32, thr, MMCI_STM32_THR_MASK);
+		}
+
+		writel_relaxed(thr, host->base + MMCI_STM32_FIFOTHRR);
+	}
+
 	if (host->mmc->card && mmc_card_sdio(host->mmc->card) &&
 	    host->data->blocks == 1)
 		datactrl |= MCI_DPSM_STM32_MODE_SDIO;
@@ -446,8 +475,15 @@ static bool sdmmc_busy_complete(struct mmci_host *host, u32 status, u32 err_msk)
 	return true;
 }
 
-static void sdmmc_dlyb_set_cfgr(struct sdmmc_dlyb *dlyb,
-				int unit, int phase, bool sampler)
+static int sdmmc_dlyb_mp15_enable(struct sdmmc_dlyb *dlyb)
+{
+	writel_relaxed(DLYB_CR_DEN, dlyb->base + DLYB_CR);
+
+	return 0;
+}
+
+static int sdmmc_dlyb_mp15_set_cfg(struct sdmmc_dlyb *dlyb,
+				   int unit, int phase, bool sampler)
 {
 	u32 cfgr;
 
@@ -459,16 +495,18 @@ static void sdmmc_dlyb_set_cfgr(struct sdmmc_dlyb *dlyb,
 
 	if (!sampler)
 		writel_relaxed(DLYB_CR_DEN, dlyb->base + DLYB_CR);
+
+	return 0;
 }
 
-static int sdmmc_dlyb_lng_tuning(struct mmci_host *host)
+static int sdmmc_dlyb_mp15_prepare(struct mmci_host *host)
 {
 	struct sdmmc_dlyb *dlyb = host->variant_priv;
 	u32 cfgr;
 	int i, lng, ret;
 
 	for (i = 0; i <= DLYB_CFGR_UNIT_MAX; i++) {
-		sdmmc_dlyb_set_cfgr(dlyb, i, DLYB_CFGR_SEL_MAX, true);
+		dlyb->ops->set_cfg(dlyb, i, DLYB_CFGR_SEL_MAX, true);
 
 		ret = readl_relaxed_poll_timeout(dlyb->base + DLYB_CFGR, cfgr,
 						 (cfgr & DLYB_CFGR_LNGF),
@@ -494,14 +532,58 @@ static int sdmmc_dlyb_lng_tuning(struct mmci_host *host)
 	return 0;
 }
 
+static int sdmmc_dlyb_mp25_enable(struct sdmmc_dlyb *dlyb)
+{
+	u32 cr, sr;
+
+	cr = readl_relaxed(dlyb->base + SYSCFG_DLYBSD_CR);
+	cr |= DLYBSD_CR_EN;
+
+	writel_relaxed(cr, dlyb->base + SYSCFG_DLYBSD_CR);
+
+	return readl_relaxed_poll_timeout(dlyb->base + SYSCFG_DLYBSD_SR,
+					   sr, sr & DLYBSD_SR_LOCK, 1,
+					   DLYBSD_TIMEOUT_1S_IN_US);
+}
+
+static int sdmmc_dlyb_mp25_set_cfg(struct sdmmc_dlyb *dlyb,
+				   int unit __maybe_unused, int phase,
+				   bool sampler __maybe_unused)
+{
+	u32 cr, sr;
+
+	cr = readl_relaxed(dlyb->base + SYSCFG_DLYBSD_CR);
+	cr &= ~DLYBSD_CR_RXTAPSEL_MASK;
+	cr |= FIELD_PREP(DLYBSD_CR_RXTAPSEL_MASK, phase);
+
+	writel_relaxed(cr, dlyb->base + SYSCFG_DLYBSD_CR);
+
+	return readl_relaxed_poll_timeout(dlyb->base + SYSCFG_DLYBSD_SR,
+					  sr, sr & DLYBSD_SR_RXTAPSEL_ACK, 1,
+					  DLYBSD_TIMEOUT_1S_IN_US);
+}
+
+static int sdmmc_dlyb_mp25_prepare(struct mmci_host *host)
+{
+	struct sdmmc_dlyb *dlyb = host->variant_priv;
+
+	dlyb->max = DLYBSD_TAPSEL_NB;
+
+	return 0;
+}
+
 static int sdmmc_dlyb_phase_tuning(struct mmci_host *host, u32 opcode)
 {
 	struct sdmmc_dlyb *dlyb = host->variant_priv;
 	int cur_len = 0, max_len = 0, end_of_len = 0;
-	int phase;
+	int phase, ret;
 
 	for (phase = 0; phase <= dlyb->max; phase++) {
-		sdmmc_dlyb_set_cfgr(dlyb, dlyb->unit, phase, false);
+		ret = dlyb->ops->set_cfg(dlyb, dlyb->unit, phase, false);
+		if (ret) {
+			dev_err(mmc_dev(host->mmc), "tuning config failed\n");
+			return ret;
+		}
 
 		if (mmc_send_tuning(host->mmc, opcode, NULL)) {
 			cur_len = 0;
@@ -519,10 +601,15 @@ static int sdmmc_dlyb_phase_tuning(struct mmci_host *host, u32 opcode)
 		return -EINVAL;
 	}
 
-	writel_relaxed(0, dlyb->base + DLYB_CR);
+	if (dlyb->ops->set_input_ck)
+		dlyb->ops->set_input_ck(dlyb);
 
 	phase = end_of_len - max_len / 2;
-	sdmmc_dlyb_set_cfgr(dlyb, dlyb->unit, phase, false);
+	ret = dlyb->ops->set_cfg(dlyb, dlyb->unit, phase, false);
+	if (ret) {
+		dev_err(mmc_dev(host->mmc), "tuning reconfig failed\n");
+		return ret;
+	}
 
 	dev_dbg(mmc_dev(host->mmc), "unit:%d max_dly:%d phase:%d\n",
 		dlyb->unit, dlyb->max, phase);
@@ -534,12 +621,33 @@ static int sdmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)
 {
 	struct mmci_host *host = mmc_priv(mmc);
 	struct sdmmc_dlyb *dlyb = host->variant_priv;
+	u32 clk;
+	int ret;
+
+	if ((host->mmc->ios.timing != MMC_TIMING_UHS_SDR104 &&
+	     host->mmc->ios.timing != MMC_TIMING_MMC_HS200) ||
+	    host->mmc->actual_clock <= 50000000)
+		return 0;
 
 	if (!dlyb || !dlyb->base)
 		return -EINVAL;
 
-	if (sdmmc_dlyb_lng_tuning(host))
-		return -EINVAL;
+	ret = dlyb->ops->dlyb_enable(dlyb);
+	if (ret)
+		return ret;
+
+	/*
+	 * SDMMC_FBCK is selected when an external Delay Block is needed
+	 * with SDR104 or HS200.
+	 */
+	clk = host->clk_reg;
+	clk &= ~MCI_STM32_CLK_SEL_MSK;
+	clk |= MCI_STM32_CLK_SELFBCK;
+	mmci_write_clkreg(host, clk);
+
+	ret = dlyb->ops->tuning_prepare(host);
+	if (ret)
+		return ret;
 
 	return sdmmc_dlyb_phase_tuning(host, opcode);
 }
@@ -598,6 +706,19 @@ static struct mmci_host_ops sdmmc_variant_ops = {
 	.post_sig_volt_switch = sdmmc_post_sig_volt_switch,
 };
 
+static struct sdmmc_tuning_ops dlyb_tuning_mp15_ops = {
+	.dlyb_enable = sdmmc_dlyb_mp15_enable,
+	.set_input_ck = sdmmc_dlyb_mp15_input_ck,
+	.tuning_prepare = sdmmc_dlyb_mp15_prepare,
+	.set_cfg = sdmmc_dlyb_mp15_set_cfg,
+};
+
+static struct sdmmc_tuning_ops dlyb_tuning_mp25_ops = {
+	.dlyb_enable = sdmmc_dlyb_mp25_enable,
+	.tuning_prepare = sdmmc_dlyb_mp25_prepare,
+	.set_cfg = sdmmc_dlyb_mp25_set_cfg,
+};
+
 void sdmmc_variant_init(struct mmci_host *host)
 {
 	struct device_node *np = host->mmc->parent->of_node;
@@ -616,6 +737,11 @@ void sdmmc_variant_init(struct mmci_host *host)
 		return;
 
 	dlyb->base = base_dlyb;
+	if (of_device_is_compatible(np, "st,stm32mp25-sdmmc2"))
+		dlyb->ops = &dlyb_tuning_mp25_ops;
+	else
+		dlyb->ops = &dlyb_tuning_mp15_ops;
+
 	host->variant_priv = dlyb;
 	host->mmc_ops->execute_tuning = sdmmc_execute_tuning;
 }
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 67453f59c..b4e1b0d51 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -124,6 +124,10 @@ static int cfi_use_status_reg(struct cfi_private *cfi)
 	struct cfi_pri_amdstd *extp = cfi->cmdset_priv;
 	u8 poll_mask = CFI_POLL_STATUS_REG | CFI_POLL_DQ;
 
+	/* DQ polling is not supported in Cypress chips (S26Hx) */
+	if (cfi->mfr == CFI_MFR_CYPRESS)
+		return 1;
+
 	return extp && extp->MinorVersion >= '5' &&
 		(extp->SoftwareFeatures & poll_mask) == CFI_POLL_STATUS_REG;
 }
@@ -450,6 +454,23 @@ static void fixup_quirks(struct mtd_info *mtd)
 		cfi->quirks |= CFI_QUIRK_DQ_TRUE_DATA;
 }
 
+static void fixup_s26hx_writesize(struct mtd_info *mtd)
+{
+	/*
+	 * Programming is supported only in 16-byte ECC data unit granularity.
+	 * Byte(word)-programming, bit-walking, or multiple program operations
+	 * to the same ECC data unit without an erase are not allowed.
+	 */
+	mtd->writesize = 16;
+	mtd->_write = cfi_amdstd_write_buffers;
+
+	/*
+	 * Unset MTD_BIT_WRITEABLE to activate JFFS2 write buffer for ECC'd NOR
+	 * flash.
+	 */
+	mtd->flags = MTD_CAP_NORFLASH & ~MTD_BIT_WRITEABLE;
+}
+
 /* Used to fix CFI-Tables of chips without Extended Query Tables */
 static struct cfi_fixup cfi_nopri_fixup_table[] = {
 	{ CFI_MFR_SST, 0x234a, fixup_sst39vf }, /* SST39VF1602 */
@@ -460,6 +481,10 @@ static struct cfi_fixup cfi_nopri_fixup_table[] = {
 	{ CFI_MFR_SST, 0x235d, fixup_sst39vf_rev_b }, /* SST39VF3201B */
 	{ CFI_MFR_SST, 0x236c, fixup_sst39vf_rev_b }, /* SST39VF6402B */
 	{ CFI_MFR_SST, 0x236d, fixup_sst39vf_rev_b }, /* SST39VF6401B */
+	{ CFI_MFR_CYPRESS, 0x6a1a, fixup_s26hx_writesize }, /* S26HL512T */
+	{ CFI_MFR_CYPRESS, 0x6a1b, fixup_s26hx_writesize }, /* S26HL01GT */
+	{ CFI_MFR_CYPRESS, 0x7b1a, fixup_s26hx_writesize }, /* S26HS512T */
+	{ CFI_MFR_CYPRESS, 0x7b1b, fixup_s26hx_writesize }, /* S26HS01GT */
 	{ 0, 0, NULL }
 };
 
diff --git a/drivers/mtd/hyperbus/Kconfig b/drivers/mtd/hyperbus/Kconfig
index 30ffc4c16..822e1da73 100644
--- a/drivers/mtd/hyperbus/Kconfig
+++ b/drivers/mtd/hyperbus/Kconfig
@@ -29,4 +29,10 @@ config RPCIF_HYPERBUS
 	help
 	  This option includes Renesas RPC-IF HyperBus support.
 
+config STM32_HYPERBUS
+	tristate "STM32 HyperBus driver"
+	depends on STM32_OMI || COMPILE_TEST
+	help
+	 This is the driver for HyperBus controller on STM32 MP2 SoC family.
+
 endif # MTD_HYPERBUS
diff --git a/drivers/mtd/hyperbus/Makefile b/drivers/mtd/hyperbus/Makefile
index 5fc2b5124..6f0daf064 100644
--- a/drivers/mtd/hyperbus/Makefile
+++ b/drivers/mtd/hyperbus/Makefile
@@ -1,5 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 
-obj-$(CONFIG_MTD_HYPERBUS)	+= hyperbus-core.o
+obj-$(CONFIG_MTD_HYPERBUS)	+= hyperbus.o
 obj-$(CONFIG_HBMC_AM654)	+= hbmc-am654.o
 obj-$(CONFIG_RPCIF_HYPERBUS)	+= rpc-if.o
+obj-$(CONFIG_STM32_HYPERBUS)	+= hyperbus-stm32.o
+
+hyperbus-objs	:= hyperbus-core.o hyperbus-sfdp.o
diff --git a/drivers/mtd/hyperbus/hyperbus-core.c b/drivers/mtd/hyperbus/hyperbus-core.c
index 4d8047d43..473c8f544 100644
--- a/drivers/mtd/hyperbus/hyperbus-core.c
+++ b/drivers/mtd/hyperbus/hyperbus-core.c
@@ -9,9 +9,21 @@
 #include <linux/mtd/hyperbus.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/sfdp.h>
 #include <linux/of.h>
 #include <linux/types.h>
 
+static struct mtd_info *hyperbus_map_probe(struct map_info *map)
+{
+	struct mtd_info *mtd;
+
+	mtd = do_map_probe("cfi_probe", map);
+	if (!mtd)
+		mtd = hyperbus_sfdp_probe(map);
+
+	return mtd;
+}
+
 static struct hyperbus_device *map_to_hbdev(struct map_info *map)
 {
 	return container_of(map, struct hyperbus_device, map);
@@ -106,7 +118,7 @@ int hyperbus_register_device(struct hyperbus_device *hbdev)
 		}
 	}
 
-	hbdev->mtd = do_map_probe("cfi_probe", map);
+	hbdev->mtd = hyperbus_map_probe(map);
 	if (!hbdev->mtd) {
 		dev_err(dev, "probing of hyperbus device failed\n");
 		return -ENODEV;
diff --git a/drivers/mtd/hyperbus/hyperbus-sfdp.c b/drivers/mtd/hyperbus/hyperbus-sfdp.c
new file mode 100644
index 000000000..d6d6f75f1
--- /dev/null
+++ b/drivers/mtd/hyperbus/hyperbus-sfdp.c
@@ -0,0 +1,314 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2023, Infineon Technologies.
+ */
+#include <linux/mtd/sfdp.h>
+#include <linux/mtd/xip.h>
+#include <linux/mtd/gen_probe.h>
+
+/* HyperBus Commands */
+#define HYPERBUS_ADDR_UNLOCK1	0x555
+#define HYPERBUS_ADDR_UNLOCK2	0x2AA
+#define HYPERBUS_CMD_UNLOCK1	0xAA
+#define HYPERBUS_CMD_UNLOCK2	0x55
+#define HYPERBUS_CMD_RDSFDP	0x90
+#define HYPERBUS_CMD_RDVCR1	0xC7
+#define HYPERBUS_CMD_RDVCR2	0xC9
+#define HYPERBUS_CMD_ASOEXT	0xF0
+#define HYPERBUS_CMD_ERSCTR	0x30
+
+/* For Infineon S26Hx family */
+#define S26HX_ADDR_MFR_ID	0x800
+#define S26HX_ADDR_DEV_ID1	0x801
+#define S26HX_ADDR_DEV_ID2	0x802
+#define S26HX_DEV_ID1_3V0	0x006A
+#define S26HX_DEV_ID1_1V8	0x007B
+#define S26HX_DEV_ID2_512	0x001A
+#define S26HX_DEV_ID2_01G	0x001B
+#define S26HX_CFR1_UNIFORM	BIT(9)
+#define S26HX_CFR1_TP4KBS	BIT(8)
+#define S26HX_CFR2_SP4KBS	BIT(2)
+#define ERASEINFO(s, b)		(((s) << 8) | ((b) - 1))
+
+static inline u16 hyperbus_read(u32 addr, struct map_info *map,
+				struct cfi_private *cfi)
+{
+	return cfi_read_query16(map, addr * cfi->interleave * cfi->device_type);
+}
+
+static inline void hyperbus_write(u8 cmd, u32 addr, struct map_info *map,
+				  struct cfi_private *cfi)
+{
+	cfi_send_gen_cmd(cmd, addr, 0, map, cfi, cfi->device_type, NULL);
+}
+
+static int __xipram hyperbus_sfdp_present(struct map_info *map, __u32 base,
+					  struct cfi_private *cfi)
+{
+	int osf = cfi->interleave * cfi->device_type; /* scale factor */
+	map_word val[2];
+	map_word sfdp[2];
+
+	sfdp[0] = cfi_build_cmd(0x4653, map, cfi); /* "SF" */
+	sfdp[1] = cfi_build_cmd(0x5044, map, cfi); /* "DP" */
+
+	val[0] = map_read(map, base + osf * 0x0);
+	val[1] = map_read(map, base + osf * 0x1);
+
+	if (!map_word_equal(map, sfdp[0], val[0]))
+		return 0;
+
+	if (!map_word_equal(map, sfdp[1], val[1]))
+		return 0;
+
+	return 1; /* "SFDP" found */
+}
+
+int __xipram hyperbus_sfdp_mode_on(u32 base, struct map_info *map,
+					  struct cfi_private *cfi)
+{
+	hyperbus_write(HYPERBUS_CMD_ASOEXT, 0, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_UNLOCK1, HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_UNLOCK2, HYPERBUS_ADDR_UNLOCK2, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_RDSFDP, HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	return hyperbus_sfdp_present(map, 0, cfi);
+}
+EXPORT_SYMBOL_GPL(hyperbus_sfdp_mode_on);
+
+void __xipram hyperbus_sfdp_mode_off(u32 base, struct map_info *map,
+					    struct cfi_private *cfi)
+{
+	hyperbus_write(HYPERBUS_CMD_ASOEXT, 0, map, cfi);
+}
+EXPORT_SYMBOL_GPL(hyperbus_sfdp_mode_off);
+
+static u16 __xipram hyperbus_s26hx_rdvcr1(struct map_info *map,
+					  struct cfi_private *cfi)
+{
+	hyperbus_write(HYPERBUS_CMD_UNLOCK1, HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_UNLOCK2, HYPERBUS_ADDR_UNLOCK2, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_RDVCR1, HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	return hyperbus_read(0, map, cfi);
+}
+
+static u16 __xipram hyperbus_s26hx_rdvcr2(struct map_info *map,
+					  struct cfi_private *cfi)
+{
+	hyperbus_write(HYPERBUS_CMD_UNLOCK1, HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_UNLOCK2, HYPERBUS_ADDR_UNLOCK2, map, cfi);
+	hyperbus_write(HYPERBUS_CMD_RDVCR2, HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	return hyperbus_read(0, map, cfi);
+}
+
+static int __xipram hyperbus_s26hx_chip_setup(struct map_info *map,
+					      struct cfi_private *cfi)
+{
+	u16 mfr_id, dev_id1, dev_id2, cfr1v, cfr2v;
+	u8 nregions, nbtm4ks, ntop4ks;
+	u16 n256ks;
+	u32 *erase;
+
+	/* Read manufacturer and Device ID */
+	mfr_id = hyperbus_read(S26HX_ADDR_MFR_ID, map, cfi);
+	dev_id1 = hyperbus_read(S26HX_ADDR_DEV_ID1, map, cfi);
+	dev_id2 = hyperbus_read(S26HX_ADDR_DEV_ID2, map, cfi);
+
+	if (mfr_id != CFI_MFR_CYPRESS ||
+	    (dev_id1 != S26HX_DEV_ID1_3V0 && dev_id1 != S26HX_DEV_ID1_1V8) ||
+	    (dev_id2 != S26HX_DEV_ID2_512 && dev_id2 != S26HX_DEV_ID2_01G))
+		return 0;
+
+	/* Exit SFDP ASO then read CFR1V and CFR2V */
+	hyperbus_sfdp_mode_off(0, map, cfi);
+	cfr1v = hyperbus_s26hx_rdvcr1(map, cfi);
+	cfr2v = hyperbus_s26hx_rdvcr2(map, cfi);
+
+	/*
+	 * Determine number of regions (nregions), number of bottom 4KB sectors
+	 * (nbtm4ks), and number of top 4KB sectors (ntop4ks)
+	 */
+	if (cfr1v & S26HX_CFR1_UNIFORM) {
+		nregions = 1;
+		nbtm4ks = 0;
+		ntop4ks = 0;
+	} else if (cfr2v & S26HX_CFR2_SP4KBS) {
+		nregions = 5;
+		nbtm4ks = 16;
+		ntop4ks = 16;
+	} else if (cfr1v & S26HX_CFR1_TP4KBS) {
+		nregions = 3;
+		nbtm4ks = 0;
+		ntop4ks = 32;
+	} else {
+		nregions = 3;
+		nbtm4ks = 32;
+		ntop4ks = 0;
+	}
+
+	cfi->cfiq = kmalloc(sizeof(*cfi->cfiq) + nregions * sizeof(u32),
+			    GFP_KERNEL);
+	if (!cfi->cfiq)
+		return 0;
+
+	memset(cfi->cfiq, 0, sizeof(struct cfi_ident));
+
+	cfi->mfr = mfr_id;
+	cfi->id = dev_id1 << 8 | dev_id2;
+	cfi->cfi_mode = CFI_MODE_CFI;
+	cfi->addr_unlock1 = HYPERBUS_ADDR_UNLOCK1;
+	cfi->addr_unlock2 = HYPERBUS_ADDR_UNLOCK2;
+	cfi->sector_erase_cmd = CMD(HYPERBUS_CMD_ERSCTR);
+
+	cfi->cfiq->P_ID = P_ID_AMD_STD;
+	cfi->cfiq->DevSize = dev_id2; /* dev_id2 indicates size in 2^N */
+	cfi->cfiq->MaxBufWriteSize = 9; /* 2^9 = 512 */
+
+	/*
+	 * cfi_cmdset_0002 uses fixed timeout for word write (1ms + 1 jiffies)
+	 * and sector erase (20s) that should be enough for s26hx. For buffer
+	 * write, 2000us is used if cfiq->BufWriteTimeoutXXX is 0. The typical
+	 * and maximum 512B page programming times are 680us and 2175us
+	 * respectively. Specify proper values here to extend buffer write
+	 * timeout.
+	 */
+	cfi->cfiq->BufWriteTimeoutTyp = 10; /* 2^10 = 1024 */
+	cfi->cfiq->BufWriteTimeoutMax = 2; /* 1024 x 2^2 = 4096 */
+
+	/* Setup erase region info */
+	cfi->cfiq->NumEraseRegions = nregions;
+	erase = cfi->cfiq->EraseRegionInfo;
+
+	/* Bottom 4KB sectors and remaining portion */
+	if (nbtm4ks) {
+		*erase++ = ERASEINFO(SZ_4K, nbtm4ks);
+		*erase++ = ERASEINFO(SZ_256K - (SZ_4K * nbtm4ks), 1);
+	}
+
+	/*
+	 * The number of uniform 256KB sectors is obtained by dividing 'device
+	 * size' by 256K(=2^18). Deduct overlaid sector(s) from uniform number
+	 * if top and/or bottom 4KB sectors exist.
+	 */
+	n256ks = (1 << (cfi->cfiq->DevSize - 18)) - !!(nbtm4ks) - !!(ntop4ks);
+	*erase++ = ERASEINFO(SZ_256K, n256ks);
+
+	/* Top 4KB sectors and remaining portion */
+	if (ntop4ks) {
+		*erase++ = ERASEINFO(SZ_256K - (SZ_4K * ntop4ks), 1);
+		*erase = ERASEINFO(SZ_4K, ntop4ks);
+	}
+
+	return 1;
+}
+
+static int __xipram hyperbus_sfdp_chip_setup(struct map_info *map,
+					     struct cfi_private *cfi)
+{
+	/*
+	 * Just call setup for S26Hx since it is only chip supported.
+	 * Once other devices come up, we will implement vendor/chip specific
+	 * detection and setup flow here.
+	 */
+	return hyperbus_s26hx_chip_setup(map, cfi);
+}
+
+static int __xipram hyperbus_sfdp_probe_chip(struct map_info *map, __u32 base,
+					     unsigned long *chip_map,
+					     struct cfi_private *cfi)
+{
+	u32 probe_addr;
+	int i;
+
+	if (base >= map->size) {
+		pr_notice("Probe at base(0x%08x) past the end of the map(0x%08lx)\n",
+			  base, map->size - 1);
+		return 0;
+	}
+
+	probe_addr = base + cfi_build_cmd_addr(HYPERBUS_ADDR_UNLOCK1, map, cfi);
+	if (probe_addr >= map->size) {
+		pr_notice("Probe at base[unlock](0x%08x) past the end of the map(0x%08lx)\n",
+			  probe_addr, map->size - 1);
+		return 0;
+	}
+
+	if (!hyperbus_sfdp_mode_on(base, map, cfi))
+		return 0;
+
+	/*
+	 * This is the first time we're called. Set up the CFI stuff accordingly
+	 * and return
+	 */
+	if (!cfi->numchips)
+		return hyperbus_sfdp_chip_setup(map, cfi);
+
+	/* Check each previous chip to see if it's an alias */
+	for (i = 0; i < (base >> cfi->chipshift); i++) {
+		unsigned long start;
+
+		/* Skip location; no valid chip at this address */
+		if (!test_bit(i, chip_map))
+			continue;
+
+		start = i << cfi->chipshift;
+
+		/*
+		 * This chip should be in read mode if it's one we've already
+		 * touched.
+		 */
+		if (hyperbus_sfdp_present(map, start, cfi)) {
+			/*
+			 * Eep. This chip also had the SFDP signature. Is it an
+			 * alias or the new one?
+			 */
+			hyperbus_sfdp_mode_off(start, map, cfi);
+
+			/* If the SFDP signature goes away, it's an alias */
+			if (!hyperbus_sfdp_present(map, start, cfi)) {
+				pr_debug("%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+					 map->name, base, start);
+				return 0;
+			}
+
+			/*
+			 * Yes, it's actually got SFDP for data. Most
+			 * unfortunate. Stick the new chip in read mode too and
+			 * if it's the same, assume it's an alias.
+			 * FIXME: Use other modes to do a proper check
+			 */
+			hyperbus_sfdp_mode_off(base, map, cfi);
+
+			if (hyperbus_sfdp_present(map, base, cfi)) {
+				pr_debug("%s: Found an alias at 0x%x for the chip at 0x%lx\n",
+					 map->name, base, start);
+				return 0;
+			}
+		}
+	}
+
+	/*
+	 * OK, if we got to here, then none of the previous chips appear to
+	 * be aliases for the current one.
+	 */
+	set_bit((base >> cfi->chipshift), chip_map);  /* Update chip map */
+	cfi->numchips++;
+
+	/* Put it back into Read Mode */
+	hyperbus_sfdp_mode_off(base, map, cfi);
+
+	pr_info("%s: Found %d x%d devices at 0x%x in %d-bit bank\n",
+		map->name, cfi->interleave, cfi->device_type * 8, base,
+		map->bankwidth * 8);
+
+	return 1;
+}
+
+static struct chip_probe hyperbus_sfdp_chip_probe = {
+	.name		= "SFDP",
+	.probe_chip	= hyperbus_sfdp_probe_chip
+};
+
+struct mtd_info *hyperbus_sfdp_probe(struct map_info *map)
+{
+	return mtd_do_chip_probe(map, &hyperbus_sfdp_chip_probe);
+}
diff --git a/drivers/mtd/hyperbus/hyperbus-stm32.c b/drivers/mtd/hyperbus/hyperbus-stm32.c
new file mode 100644
index 000000000..5a5617501
--- /dev/null
+++ b/drivers/mtd/hyperbus/hyperbus-stm32.c
@@ -0,0 +1,428 @@
+// SPDX-License-Identifier: GPL
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@st.com> for STMicroelectronics.
+ */
+
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/sfdp.h>
+#include <memory/stm32-omi.h>
+
+#define STM32_AUTOSUSPEND_DELAY -1
+
+struct stm32_hyperbus {
+	struct device *dev;
+	struct hyperbus_ctlr ctlr;
+	struct hyperbus_device hbdev;
+	struct stm32_omi *omi;
+	u32 flash_freq;		/* flash max supported frequency */
+	u32 real_flash_freq;	/* real flash freq = bus_freq x prescaler */
+	u32 tacc;
+	u32 cs;
+	u32 dlyb_cr;
+	bool wzl;
+};
+
+static void stm32_hyperbus_copy_from(struct hyperbus_device *hbdev, void *to,
+				     unsigned long from, ssize_t len)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	struct stm32_omi *omi = hyperbus->omi;
+
+	pm_runtime_resume_and_get(omi->dev);
+
+	memcpy_fromio(to, omi->mm_base + from, len);
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+}
+
+static void stm32_hyperbus_set_mode(struct stm32_hyperbus *hyperbus, u8 mode)
+{
+	struct stm32_omi *omi = hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+
+	if (omi->fmode == mode)
+		return;
+
+	if (omi->fmode == CR_FMODE_MM)
+		stm32_omi_abort(omi);
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	cr &= ~CR_FMODE_MASK;
+	cr |= FIELD_PREP(CR_FMODE_MASK, mode);
+	writel_relaxed(cr, regs_base + OSPI_CR);
+	omi->fmode = mode;
+}
+
+static u16 stm32_hyperbus_read16(struct hyperbus_device *hbdev, unsigned long addr)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	struct stm32_omi *omi = hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u16 data;
+
+	pm_runtime_resume_and_get(omi->dev);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_INDR);
+	writel(addr, regs_base + OSPI_AR);
+	stm32_omi_tx_poll(omi, (u8 *)&data, 2, true);
+
+	/* Wait end of tx in indirect mode */
+	stm32_omi_wait_cmd(omi);
+
+	dev_dbg(hyperbus->dev, "%s: read 0x%x @ 0x%lx\n",
+		__func__, data, addr >> 1);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_MM);
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return data;
+}
+
+static void stm32_hyperbus_write16(struct hyperbus_device *hbdev,
+				  unsigned long addr, u16 data)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	struct stm32_omi *omi = hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+
+	pm_runtime_resume_and_get(omi->dev);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_INDW);
+	writel(addr, regs_base + OSPI_AR);
+	stm32_omi_tx_poll(omi, (u8 *)&data, 2, false);
+
+	/* Wait end of tx in indirect mode */
+	stm32_omi_wait_cmd(omi);
+
+	dev_dbg(hyperbus->dev, "%s: write 0x%x @ 0x%lx\n",
+		__func__, data, addr >> 1);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_MM);
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+}
+
+static int stm32_hyperbus_check_transfert(struct stm32_omi *omi)
+{
+	struct stm32_hyperbus *hyperbus = platform_get_drvdata(omi->vdev);
+	struct map_info *map = &hyperbus->hbdev.map;
+	struct cfi_private cfi;
+	int ret;
+
+	cfi.interleave = 1;
+	cfi.device_type = CFI_DEVICETYPE_X16;
+
+	if (omi->jedec_flash) {
+		ret = hyperbus_sfdp_mode_on(0, map, &cfi);
+		hyperbus_sfdp_mode_off(0, map, &cfi);
+	} else {
+		ret = cfi_qry_mode_on(0, map, &cfi);
+		cfi_qry_mode_off(0, map, &cfi);
+	}
+
+	return !ret;
+}
+
+static int stm32_hyperbus_calibrate(struct hyperbus_device *hbdev)
+{
+	struct stm32_hyperbus *hyperbus =
+		container_of(hbdev, struct stm32_hyperbus, hbdev);
+	struct stm32_omi *omi = hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 prescaler;
+	u16 period_ps = 0;
+	u8 window_len = 0;
+	int ret;
+	bool bypass_mode = false;
+
+	prescaler = FIELD_GET(DCR2_PRESC_MASK,
+			      readl(regs_base + OSPI_DCR2));
+
+	if (hyperbus->real_flash_freq <= STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (hyperbus->real_flash_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_init(omi, bypass_mode, period_ps);
+	if (ret) {
+		dev_err(hyperbus->dev, "Can't enable delay block\n");
+		return 0;
+	}
+
+	if (bypass_mode || prescaler)
+		/* perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(omi, true, &window_len);
+	else
+		/* perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(omi, false, &window_len);
+
+	if (ret) {
+		dev_err(omi->dev, "Calibration failed\n");
+		if (!bypass_mode)
+			/* stop delay block when configured in lock mode */
+			stm32_omi_dlyb_stop(omi);
+	}
+
+	return ret ? 0 : 1;
+}
+
+static const struct hyperbus_ops stm32_hyperbus_ops = {
+	.read16 = stm32_hyperbus_read16,
+	.write16 = stm32_hyperbus_write16,
+	.copy_from = stm32_hyperbus_copy_from,
+	.calibrate = stm32_hyperbus_calibrate,
+};
+
+static void stm32_hyperbus_init(struct stm32_hyperbus *hyperbus)
+{
+	struct stm32_omi *omi = hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	unsigned long period;
+	u32 cr, dcr1, hlcr, ccr;
+	u32 prescaler;
+
+	cr = CR_EN;
+	cr |= FIELD_PREP(CR_CSSEL, hyperbus->cs);
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	/* set MTYP to HyperBus memory-map mode */
+	dcr1 = FIELD_PREP(DCR1_MTYP_MASK, DCR1_MTYP_HP_MEMMODE);
+	/* set DEVSIZE to memory map size */
+	dcr1 |= FIELD_PREP(DCR1_DEVSIZE_MASK, ffs(omi->mm_size) - 1);
+	writel_relaxed(dcr1, regs_base + OSPI_DCR1);
+
+	prescaler = DIV_ROUND_UP(omi->clk_rate, hyperbus->flash_freq) - 1;
+	if (prescaler > 255)
+		prescaler = 255;
+
+	if (prescaler)
+		writel_relaxed(TCR_DHQC, regs_base + OSPI_TCR);
+
+	writel_relaxed(FIELD_PREP(DCR2_PRESC_MASK, prescaler), regs_base + OSPI_DCR2);
+	hyperbus->real_flash_freq = omi->clk_rate / (prescaler + 1);
+
+	writel_relaxed(1, regs_base + OSPI_DLR);
+
+	/* set access time latency */
+	period = NSEC_PER_SEC / hyperbus->real_flash_freq;
+	hlcr = FIELD_PREP(HLCR_TACC_MASK, DIV_ROUND_UP(hyperbus->tacc, period));
+	if (hyperbus->wzl)
+		hlcr |= HLCR_WZL;
+
+	writel_relaxed(hlcr, regs_base + OSPI_HLCR);
+
+	ccr = CCR_DQSE | CCR_DDTR | CCR_ADDTR;
+	ccr |= FIELD_PREP(CCR_DMODE_MASK, CCR_DMODE_8LINES);
+	ccr |= FIELD_PREP(CCR_ADSIZE_MASK, CCR_ADSIZE_32BITS);
+	ccr |= FIELD_PREP(CCR_ADMODE_MASK, CCR_ADMODE_8LINES);
+	writel(ccr, regs_base + OSPI_CCR);
+
+	stm32_hyperbus_set_mode(hyperbus, CR_FMODE_MM);
+}
+
+static int __maybe_unused stm32_hyperbus_suspend(struct device *dev)
+{
+	struct stm32_hyperbus *hyperbus = dev_get_drvdata(dev);
+	struct stm32_omi *omi = hyperbus->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	/* save DLYB configuration */
+	stm32_omi_dlyb_get_cr(omi, &hyperbus->dlyb_cr);
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	cr &= ~CR_EN;
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	pm_runtime_put_sync_suspend(omi->dev);
+
+	pinctrl_pm_select_sleep_state(dev);
+
+	return pm_runtime_force_suspend(omi->dev);
+}
+
+static int __maybe_unused stm32_hyperbus_resume(struct device *dev)
+{
+	struct stm32_hyperbus *hyperbus = dev_get_drvdata(dev);
+	struct stm32_omi *omi = hyperbus->omi;
+	int ret;
+
+	ret = pm_runtime_force_resume(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	pinctrl_pm_select_default_state(dev);
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	/* dlyb may be restarted by bootloarder stage, so ensure it's stopped */
+	stm32_omi_dlyb_stop(omi);
+
+	stm32_hyperbus_init(hyperbus);
+
+	/* restore DLYB configuration */
+	ret = stm32_omi_dlyb_set_cr(omi, hyperbus->dlyb_cr);
+	if (ret)
+		return ret;
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_hyperbus_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_hyperbus_suspend, stm32_hyperbus_resume)
+};
+
+static int stm32_hyperbus_probe(struct platform_device *pdev)
+{
+	struct device *parent = pdev->dev.parent;
+	struct device *dev = &pdev->dev;
+	struct stm32_hyperbus *hyperbus;
+	struct stm32_omi *omi = dev_get_drvdata(parent);
+	struct device_node *flash;
+	u32 value;
+	int ret;
+
+	hyperbus = devm_kzalloc(dev, sizeof(*hyperbus), GFP_KERNEL);
+	if (!hyperbus)
+		return -ENOMEM;
+
+	hyperbus->omi = omi;
+	hyperbus->dev = dev;
+	platform_set_drvdata(pdev, hyperbus);
+
+	omi->check_transfer = stm32_hyperbus_check_transfert;
+
+	/* mandatory for HyperFlash */
+	if (!omi->mm_size) {
+		dev_err(dev, "Memory-map region not found\n");
+		return -EINVAL;
+	}
+
+	/* mandatory for HyperFlash */
+	if (!omi->dlyb_base) {
+		dev_err(dev, "Incorrect delay block base address\n");
+		return -EINVAL;
+	}
+
+	pm_runtime_enable(omi->dev);
+	pm_runtime_set_autosuspend_delay(omi->dev, STM32_AUTOSUSPEND_DELAY);
+	pm_runtime_use_autosuspend(omi->dev);
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		goto err_pm_disable;
+
+	if (omi->rstc) {
+		reset_control_assert(omi->rstc);
+		udelay(2);
+		reset_control_deassert(omi->rstc);
+	}
+
+	flash = of_get_next_child(parent->of_node, NULL);
+	if (!flash) {
+		dev_warn(&pdev->dev, "No flash node found\n");
+		goto err_pm_resume;
+	}
+
+	ret = of_property_read_u32(flash, "reg", &hyperbus->cs);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't find reg property\n");
+		goto err_pm_resume;
+	}
+
+	ret = of_property_read_u32(flash, "st,max-frequency", &value);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't find st,max-frequency property\n");
+		goto err_pm_resume;
+	}
+	hyperbus->flash_freq = value;
+
+	/* optional */
+	ret = of_property_read_u32(flash, "st,tacc-ns", &hyperbus->tacc);
+	if (ret)
+		hyperbus->tacc = 0;
+
+	hyperbus->wzl = of_property_read_bool(flash, "st,wzl");
+
+	hyperbus->hbdev.map.size = omi->mm_size;
+	hyperbus->hbdev.map.virt = omi->mm_base;
+
+	hyperbus->ctlr.dev = dev;
+	hyperbus->ctlr.ops = &stm32_hyperbus_ops;
+	hyperbus->hbdev.ctlr = &hyperbus->ctlr;
+	hyperbus->hbdev.np = of_get_next_child(parent->of_node, NULL);
+
+	stm32_hyperbus_init(hyperbus);
+
+	ret = hyperbus_register_device(&hyperbus->hbdev);
+	if (ret) {
+		/* disable ospi */
+		writel_relaxed(0, omi->regs_base + OSPI_CR);
+		goto err_pm_resume;
+	}
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return ret;
+
+err_pm_resume:
+	pm_runtime_put_sync_suspend(omi->dev);
+
+err_pm_disable:
+	pm_runtime_force_suspend(omi->dev);
+
+	return ret;
+}
+
+static int stm32_hyperbus_remove(struct platform_device *pdev)
+{
+	struct stm32_hyperbus *hyperbus = platform_get_drvdata(pdev);
+	struct stm32_omi *omi = hyperbus->omi;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	hyperbus_unregister_device(&hyperbus->hbdev);
+	writel_relaxed(0, &omi->regs_base + OSPI_CR);
+	stm32_omi_dlyb_stop(omi);
+
+	pm_runtime_put_sync_suspend(omi->dev);
+	pm_runtime_force_suspend(omi->dev);
+
+	return 0;
+}
+
+static struct platform_driver stm32_hyperbus_driver = {
+	.probe	= stm32_hyperbus_probe,
+	.remove	= stm32_hyperbus_remove,
+	.driver	= {
+		.name = "stm32-hyperflash",
+		.pm = &stm32_hyperbus_pm_ops,
+	},
+};
+module_platform_driver(stm32_hyperbus_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics STM32 HyperBus driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index 4cd40af36..8a0cf132a 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -380,7 +380,7 @@ config MTD_NAND_TEGRA
 
 config MTD_NAND_STM32_FMC2
 	tristate "Support for NAND controller on STM32MP SoCs"
-	depends on MACH_STM32MP157 || COMPILE_TEST
+	depends on ARCH_STM32 || COMPILE_TEST
 	select MFD_SYSCON
 	help
 	  Enables support for NAND Flash chips on SoCs containing the FMC2
diff --git a/drivers/mtd/nand/raw/stm32_fmc2_nand.c b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
index 9e74bcd90..fb9f6f90d 100644
--- a/drivers/mtd/nand/raw/stm32_fmc2_nand.c
+++ b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/mtd/rawnand.h>
 #include <linux/of_address.h>
+#include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
@@ -37,7 +38,7 @@
 #define FMC2_MAX_SG			16
 
 /* Max chip enable */
-#define FMC2_MAX_CE			2
+#define FMC2_MAX_CE			4
 
 /* Max ECC buffer length */
 #define FMC2_MAX_ECC_BUF_LEN		(FMC2_BCHDSRS_LEN * FMC2_MAX_SG)
@@ -243,6 +244,13 @@ static inline struct stm32_fmc2_nand *to_fmc2_nand(struct nand_chip *chip)
 	return container_of(chip, struct stm32_fmc2_nand, chip);
 }
 
+struct stm32_fmc2_nfc;
+
+struct stm32_fmc2_nfc_data {
+	int max_ncs;
+	int (*set_cdev)(struct stm32_fmc2_nfc *nfc);
+};
+
 struct stm32_fmc2_nfc {
 	struct nand_controller base;
 	struct stm32_fmc2_nand nand;
@@ -256,6 +264,7 @@ struct stm32_fmc2_nfc {
 	phys_addr_t data_phys_addr[FMC2_MAX_CE];
 	struct clk *clk;
 	u8 irq_state;
+	const struct stm32_fmc2_nfc_data *data;
 
 	struct dma_chan *dma_tx_ch;
 	struct dma_chan *dma_rx_ch;
@@ -264,6 +273,8 @@ struct stm32_fmc2_nfc {
 	struct sg_table dma_ecc_sg;
 	u8 *ecc_buf;
 	int dma_ecc_len;
+	u32 tx_dma_max_burst;
+	u32 rx_dma_max_burst;
 
 	struct completion complete;
 	struct completion dma_data_complete;
@@ -347,20 +358,26 @@ static int stm32_fmc2_nfc_select_chip(struct nand_chip *chip, int chipnr)
 	stm32_fmc2_nfc_setup(chip);
 	stm32_fmc2_nfc_timings_init(chip);
 
-	if (nfc->dma_tx_ch && nfc->dma_rx_ch) {
+	if (nfc->dma_tx_ch) {
 		memset(&dma_cfg, 0, sizeof(dma_cfg));
-		dma_cfg.src_addr = nfc->data_phys_addr[nfc->cs_sel];
 		dma_cfg.dst_addr = nfc->data_phys_addr[nfc->cs_sel];
-		dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		dma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		dma_cfg.src_maxburst = 32;
-		dma_cfg.dst_maxburst = 32;
+		dma_cfg.dst_maxburst = nfc->tx_dma_max_burst /
+				       dma_cfg.dst_addr_width;
 
 		ret = dmaengine_slave_config(nfc->dma_tx_ch, &dma_cfg);
 		if (ret) {
 			dev_err(nfc->dev, "tx DMA engine slave config failed\n");
 			return ret;
 		}
+	}
+
+	if (nfc->dma_rx_ch) {
+		memset(&dma_cfg, 0, sizeof(dma_cfg));
+		dma_cfg.src_addr = nfc->data_phys_addr[nfc->cs_sel];
+		dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		dma_cfg.src_maxburst = nfc->rx_dma_max_burst /
+				       dma_cfg.src_addr_width;
 
 		ret = dmaengine_slave_config(nfc->dma_rx_ch, &dma_cfg);
 		if (ret) {
@@ -1545,6 +1562,7 @@ static int stm32_fmc2_nfc_setup_interface(struct nand_chip *chip, int chipnr,
 
 static int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)
 {
+	struct dma_slave_caps caps;
 	int ret = 0;
 
 	nfc->dma_tx_ch = dma_request_chan(nfc->dev, "tx");
@@ -1557,6 +1575,11 @@ static int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)
 		goto err_dma;
 	}
 
+	ret = dma_get_slave_caps(nfc->dma_tx_ch, &caps);
+	if (ret)
+		return ret;
+	nfc->tx_dma_max_burst = caps.max_burst;
+
 	nfc->dma_rx_ch = dma_request_chan(nfc->dev, "rx");
 	if (IS_ERR(nfc->dma_rx_ch)) {
 		ret = PTR_ERR(nfc->dma_rx_ch);
@@ -1567,6 +1590,11 @@ static int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)
 		goto err_dma;
 	}
 
+	ret = dma_get_slave_caps(nfc->dma_rx_ch, &caps);
+	if (ret)
+		return ret;
+	nfc->rx_dma_max_burst = caps.max_burst;
+
 	nfc->dma_ecc_ch = dma_request_chan(nfc->dev, "ecc");
 	if (IS_ERR(nfc->dma_ecc_ch)) {
 		ret = PTR_ERR(nfc->dma_ecc_ch);
@@ -1790,7 +1818,7 @@ static int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc,
 			return ret;
 		}
 
-		if (cs >= FMC2_MAX_CE) {
+		if (cs >= nfc->data->max_ncs) {
 			dev_err(nfc->dev, "invalid reg value: %d\n", cs);
 			return -EINVAL;
 		}
@@ -1896,9 +1924,17 @@ static int stm32_fmc2_nfc_probe(struct platform_device *pdev)
 	nand_controller_init(&nfc->base);
 	nfc->base.ops = &stm32_fmc2_nfc_controller_ops;
 
-	ret = stm32_fmc2_nfc_set_cdev(nfc);
-	if (ret)
-		return ret;
+	nfc->data = of_device_get_match_data(dev);
+	if (!nfc->data)
+		return -EINVAL;
+
+	if (nfc->data->set_cdev) {
+		ret = nfc->data->set_cdev(nfc);
+		if (ret)
+			return ret;
+	} else {
+		nfc->cdev = dev->parent;
+	}
 
 	ret = stm32_fmc2_nfc_parse_dt(nfc);
 	if (ret)
@@ -1917,7 +1953,7 @@ static int stm32_fmc2_nfc_probe(struct platform_device *pdev)
 	if (nfc->dev == nfc->cdev)
 		start_region = 1;
 
-	for (chip_cs = 0, mem_region = start_region; chip_cs < FMC2_MAX_CE;
+	for (chip_cs = 0, mem_region = start_region; chip_cs < nfc->data->max_ncs;
 	     chip_cs++, mem_region += 3) {
 		if (!(nfc->cs_assigned & BIT(chip_cs)))
 			continue;
@@ -2084,7 +2120,7 @@ static int __maybe_unused stm32_fmc2_nfc_resume(struct device *dev)
 
 	stm32_fmc2_nfc_wp_disable(nand);
 
-	for (chip_cs = 0; chip_cs < FMC2_MAX_CE; chip_cs++) {
+	for (chip_cs = 0; chip_cs < nfc->data->max_ncs; chip_cs++) {
 		if (!(nfc->cs_assigned & BIT(chip_cs)))
 			continue;
 
@@ -2097,9 +2133,28 @@ static int __maybe_unused stm32_fmc2_nfc_resume(struct device *dev)
 static SIMPLE_DEV_PM_OPS(stm32_fmc2_nfc_pm_ops, stm32_fmc2_nfc_suspend,
 			 stm32_fmc2_nfc_resume);
 
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp1_data = {
+	.max_ncs = 2,
+	.set_cdev = stm32_fmc2_nfc_set_cdev,
+};
+
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp25_data = {
+	.max_ncs = 4,
+};
+
 static const struct of_device_id stm32_fmc2_nfc_match[] = {
-	{.compatible = "st,stm32mp15-fmc2"},
-	{.compatible = "st,stm32mp1-fmc2-nfc"},
+	{
+		.compatible = "st,stm32mp15-fmc2",
+		.data = &stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp1-fmc2-nfc",
+		.data = &stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-nfc",
+		.data = &stm32_fmc2_nfc_mp25_data,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, stm32_fmc2_nfc_match);
diff --git a/drivers/mtd/spi-nor/core.c b/drivers/mtd/spi-nor/core.c
index a9000b0eb..c3bb57392 100644
--- a/drivers/mtd/spi-nor/core.c
+++ b/drivers/mtd/spi-nor/core.c
@@ -71,6 +71,13 @@ static u8 spi_nor_get_cmd_ext(const struct spi_nor *nor,
 	}
 }
 
+static inline bool spi_nor_is_octal_dtr_swab16(const struct spi_nor *nor,
+					       enum spi_nor_protocol proto)
+{
+	return (proto == SNOR_PROTO_8_8_8_DTR) &&
+		(nor->flags & SNOR_F_DTR_SWAB16);
+}
+
 /**
  * spi_nor_spimem_setup_op() - Set up common properties of a spi-mem op.
  * @nor:		pointer to a 'struct spi_nor'
@@ -106,6 +113,7 @@ void spi_nor_spimem_setup_op(const struct spi_nor *nor,
 		op->addr.dtr = true;
 		op->dummy.dtr = true;
 		op->data.dtr = true;
+		op->data.dtr_swab16 = spi_nor_is_octal_dtr_swab16(nor, proto);
 
 		/* 2 bytes per clock cycle in DTR mode. */
 		op->dummy.nbytes *= 2;
@@ -409,7 +417,7 @@ int spi_nor_write_disable(struct spi_nor *nor)
 }
 
 /**
- * spi_nor_read_id() - Read the JEDEC ID.
+ * spi_nor_default_read_id() - Read the JEDEC ID.
  * @nor:	pointer to 'struct spi_nor'.
  * @naddr:	number of address bytes to send. Can be zero if the operation
  *		does not need to send an address.
@@ -421,8 +429,8 @@ int spi_nor_write_disable(struct spi_nor *nor)
  *
  * Return: 0 on success, -errno otherwise.
  */
-int spi_nor_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
-		    enum spi_nor_protocol proto)
+int spi_nor_default_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
+			    enum spi_nor_protocol proto)
 {
 	int ret;
 
@@ -439,6 +447,32 @@ int spi_nor_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
 	return ret;
 }
 
+/**
+ * spi_nor_read_id() - Read ID by manufacturer read id function.
+ * @nor:	pointer to 'struct spi_nor'.
+ * @naddr:	number of address bytes to send. Can be zero if the operation
+ *		does not need to send an address.
+ * @ndummy:	number of dummy bytes to send after an opcode or address. Can
+ *		be zero if the operation does not require dummy bytes.
+ * @id:		pointer to a DMA-able buffer where the value of the JEDEC ID
+ *		will be written.
+ * @proto:	the SPI protocol for register operation.
+ *
+ * Return: 0 on success, -errno otherwise.
+ */
+int spi_nor_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
+		    enum spi_nor_protocol proto)
+{
+	int ret;
+
+	if (nor->manufacturer && nor->manufacturer->fixups && nor->manufacturer->fixups->read_id)
+		ret = nor->manufacturer->fixups->read_id(nor, naddr, ndummy, id, proto);
+	else
+		ret = spi_nor_default_read_id(nor, naddr, ndummy, id, proto);
+
+	return ret;
+}
+
 /**
  * spi_nor_read_sr() - Read the Status Register.
  * @nor:	pointer to 'struct spi_nor'.
diff --git a/drivers/mtd/spi-nor/core.h b/drivers/mtd/spi-nor/core.h
index 290613fd6..e3c660eac 100644
--- a/drivers/mtd/spi-nor/core.h
+++ b/drivers/mtd/spi-nor/core.h
@@ -132,6 +132,7 @@ enum spi_nor_option_flags {
 	SNOR_F_SWP_IS_VOLATILE	= BIT(13),
 	SNOR_F_RWW		= BIT(14),
 	SNOR_F_ECC		= BIT(15),
+	SNOR_F_DTR_SWAB16       = BIT(16),
 };
 
 struct spi_nor_read_command {
@@ -415,6 +416,8 @@ struct spi_nor_flash_parameter {
  * @late_init: used to initialize flash parameters that are not declared in the
  *             JESD216 SFDP standard, or where SFDP tables not defined at all.
  *             Will replace the default_init() hook.
+ * @read_id:   used to read id which may change format after enter into
+	       octal dtr mode.
  *
  * Those hooks can be used to tweak the SPI NOR configuration when the SFDP
  * table is broken or not available.
@@ -426,6 +429,8 @@ struct spi_nor_fixups {
 			 const struct sfdp_bfpt *bfpt);
 	void (*post_sfdp)(struct spi_nor *nor);
 	void (*late_init)(struct spi_nor *nor);
+	int (*read_id)(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
+		       enum spi_nor_protocol reg_proto);
 };
 
 /**
@@ -649,6 +654,8 @@ void spi_nor_unlock_and_unprep(struct spi_nor *nor);
 int spi_nor_sr1_bit6_quad_enable(struct spi_nor *nor);
 int spi_nor_sr2_bit1_quad_enable(struct spi_nor *nor);
 int spi_nor_sr2_bit7_quad_enable(struct spi_nor *nor);
+int spi_nor_default_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
+			    enum spi_nor_protocol reg_proto);
 int spi_nor_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
 		    enum spi_nor_protocol reg_proto);
 int spi_nor_read_sr(struct spi_nor *nor, u8 *sr);
diff --git a/drivers/mtd/spi-nor/macronix.c b/drivers/mtd/spi-nor/macronix.c
index d81a4cb28..9ff289dd8 100644
--- a/drivers/mtd/spi-nor/macronix.c
+++ b/drivers/mtd/spi-nor/macronix.c
@@ -8,6 +8,24 @@
 
 #include "core.h"
 
+#define SPINOR_OP_MXIC_RD_ANY_REG	0x71	     /* Read volatile configuration register 2 */
+#define SPINOR_OP_MXIC_WR_ANY_REG	0x72	     /* Write volatile configuration register 2 */
+#define SPINOR_REG_MXIC_CR2_MODE	0x00000000   /* CR2 address for setting octal DTR mode */
+#define SPINOR_REG_MXIC_CR2_DC		0x00000300   /* CR2 address for setting dummy cycles */
+#define SPINOR_REG_MXIC_OPI_DTR_EN	0x2	     /* Enable Octal DTR */
+#define SPINOR_REG_MXIC_SPI_EN		0x0	     /* Enable SPI */
+#define SPINOR_REG_MXIC_ADDR_BYTES	4	     /* Fixed R/W volatile address bytes to 4 */
+/* Convert dummy cycles to bit pattern */
+#define SPINOR_REG_MXIC_DC(p) \
+		((20 - (p)) / 2)
+
+/* Macronix SPI NOR flash operations. */
+#define MXIC_NOR_WR_ANY_REG_OP(naddr, addr, ndata, buf)			\
+	SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_MXIC_WR_ANY_REG, 0),	\
+		   SPI_MEM_OP_ADDR(naddr, addr, 0),			\
+		   SPI_MEM_OP_NO_DUMMY,					\
+		   SPI_MEM_OP_DATA_OUT(ndata, buf, 0))
+
 static int
 mx25l25635_post_bfpt_fixups(struct spi_nor *nor,
 			    const struct sfdp_parameter_header *bfpt_header,
@@ -100,16 +118,152 @@ static const struct flash_info macronix_nor_parts[] = {
 	{ "mx66u2g45g",	 INFO(0xc2253c, 0, 64 * 1024, 4096)
 		NO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
 		FIXUP_FLAGS(SPI_NOR_4B_OPCODES) },
+	{ "mx66uw2g345gx0", INFO(0xc2943c, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx66lm1g45g", INFO(0xc2853b, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25lm51245g", INFO(0xc2853a, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25lw51245g", INFO(0xc2863a, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25lm25645g", INFO(0xc28539, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx66uw2g345g", INFO(0xc2843c, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx66um1g45g", INFO(0xc2803b, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx66uw1g45g", INFO(0xc2813b, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw51345g", INFO(0xc2843a, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25um25645g", INFO(0xc28039, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw25645g", INFO(0xc28139, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25um25345g", INFO(0xc28339, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw25345g", INFO(0xc28439, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw12845g", INFO(0xc28138, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw12345g", INFO(0xc28438, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw6445g", INFO(0xc28137, 0, 0, 0)
+		PARSE_SFDP },
+	{ "mx25uw6345g", INFO(0xc28437, 0, 0, 0)
+		PARSE_SFDP },
 };
 
+static int macronix_nor_octal_dtr_en(struct spi_nor *nor)
+{
+	struct spi_mem_op op;
+	u8 *buf = nor->bouncebuf;
+	int ret;
+
+	/* Use dummy cycles which is parse by SFDP and convert to bit pattern. */
+	buf[0] = SPINOR_REG_MXIC_DC(nor->params->reads[SNOR_CMD_READ_8_8_8_DTR].num_wait_states);
+	op = (struct spi_mem_op)
+		MXIC_NOR_WR_ANY_REG_OP(SPINOR_REG_MXIC_ADDR_BYTES,
+				       SPINOR_REG_MXIC_CR2_DC, 1, buf);
+
+	ret = spi_nor_write_any_volatile_reg(nor, &op, nor->reg_proto);
+	if (ret)
+		return ret;
+
+	/* Set the octal and DTR enable bits. */
+	buf[0] = SPINOR_REG_MXIC_OPI_DTR_EN;
+	op = (struct spi_mem_op)
+		MXIC_NOR_WR_ANY_REG_OP(SPINOR_REG_MXIC_ADDR_BYTES,
+				       SPINOR_REG_MXIC_CR2_MODE, 1, buf);
+	ret = spi_nor_write_any_volatile_reg(nor, &op, nor->reg_proto);
+	if (ret)
+		return ret;
+
+	/* Read flash ID to make sure the switch was successful. */
+	ret = spi_nor_read_id(nor, 4, 4, buf, SNOR_PROTO_8_8_8_DTR);
+	if (ret) {
+		dev_dbg(nor->dev, "error %d reading JEDEC ID after enabling 8D-8D-8D mode\n", ret);
+		return ret;
+	}
+
+	if (memcmp(buf, nor->info->id, nor->info->id_len))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int macronix_nor_octal_dtr_dis(struct spi_nor *nor)
+{
+	struct spi_mem_op op;
+	u8 *buf = nor->bouncebuf;
+	int ret;
+
+	/*
+	 * The register is 1-byte wide, but 1-byte transactions are not
+	 * allowed in 8D-8D-8D mode. Since there is no register at the
+	 * next location, just initialize the value to 0 and let the
+	 * transaction go on.
+	 */
+	buf[0] = SPINOR_REG_MXIC_SPI_EN;
+	buf[1] = 0x0;
+	op = (struct spi_mem_op)
+		MXIC_NOR_WR_ANY_REG_OP(SPINOR_REG_MXIC_ADDR_BYTES,
+				       SPINOR_REG_MXIC_CR2_MODE, 2, buf);
+	ret = spi_nor_write_any_volatile_reg(nor, &op, SNOR_PROTO_8_8_8_DTR);
+	if (ret)
+		return ret;
+
+	/* Read flash ID to make sure the switch was successful. */
+	ret = spi_nor_read_id(nor, 0, 0, buf, SNOR_PROTO_1_1_1);
+	if (ret) {
+		dev_dbg(nor->dev, "error %d reading JEDEC ID after disabling 8D-8D-8D mode\n", ret);
+		return ret;
+	}
+
+	if (memcmp(buf, nor->info->id, nor->info->id_len))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int macronix_nor_set_octal_dtr(struct spi_nor *nor, bool enable)
+{
+	return enable ? macronix_nor_octal_dtr_en(nor) :
+			macronix_nor_octal_dtr_dis(nor);
+}
+
 static void macronix_nor_default_init(struct spi_nor *nor)
 {
 	nor->params->quad_enable = spi_nor_sr1_bit6_quad_enable;
+}
+
+static void macronix_nor_late_init(struct spi_nor *nor)
+{
 	nor->params->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode;
+	nor->params->octal_dtr_enable = macronix_nor_set_octal_dtr;
+}
+
+static int macronix_nor_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,
+				enum spi_nor_protocol proto)
+{
+	int i, ret;
+
+	ret = spi_nor_default_read_id(nor, naddr, ndummy, id, proto);
+	/* Retrieve odd array and re-sort id because of read id format will be A-A-B-B-C-C
+	 * after enter into octal dtr mode for Macronix flashes.
+	 */
+	if (proto == SNOR_PROTO_8_8_8_DTR) {
+		for (i = 0; i < nor->info->id_len; i++)
+			id[i] = id[i * 2];
+	}
+
+	return ret;
 }
 
 static const struct spi_nor_fixups macronix_nor_fixups = {
 	.default_init = macronix_nor_default_init,
+	.late_init = macronix_nor_late_init,
+	.read_id = macronix_nor_read_id,
 };
 
 const struct spi_nor_manufacturer spi_nor_macronix = {
diff --git a/drivers/mtd/spi-nor/sfdp.c b/drivers/mtd/spi-nor/sfdp.c
index 78110387b..da4632095 100644
--- a/drivers/mtd/spi-nor/sfdp.c
+++ b/drivers/mtd/spi-nor/sfdp.c
@@ -635,6 +635,10 @@ static int spi_nor_parse_bfpt(struct spi_nor *nor,
 		return -EOPNOTSUPP;
 	}
 
+	/* Byte order in 8D-8D-8D mode */
+	if (bfpt.dwords[BFPT_DWORD(18)] & BFPT_DWORD18_BYTE_ORDER_SWAPPED)
+		nor->flags |= SNOR_F_DTR_SWAB16;
+
 	return spi_nor_post_bfpt_fixups(nor, bfpt_header, &bfpt);
 }
 
@@ -1183,10 +1187,17 @@ static int spi_nor_parse_profile1(struct spi_nor *nor,
 	dummy = round_up(dummy, 2);
 
 	/* Update the fast read settings. */
+	nor->params->hwcaps.mask |= SNOR_HWCAPS_READ_8_8_8_DTR;
 	spi_nor_set_read_settings(&nor->params->reads[SNOR_CMD_READ_8_8_8_DTR],
 				  0, dummy, opcode,
 				  SNOR_PROTO_8_8_8_DTR);
 
+	/*
+	 * Page Program is "Required Command" in the xSPI Profile 1.0. Update
+	 * the params->hwcaps.mask here.
+	 */
+	nor->params->hwcaps.mask |= SNOR_HWCAPS_PP_8_8_8_DTR;
+
 out:
 	kfree(dwords);
 	return ret;
diff --git a/drivers/mtd/spi-nor/sfdp.h b/drivers/mtd/spi-nor/sfdp.h
index bbf80d299..b39f101b1 100644
--- a/drivers/mtd/spi-nor/sfdp.h
+++ b/drivers/mtd/spi-nor/sfdp.h
@@ -97,6 +97,7 @@ struct sfdp_bfpt {
 #define BFPT_DWORD18_CMD_EXT_INV		(0x1UL << 29) /* Invert */
 #define BFPT_DWORD18_CMD_EXT_RES		(0x2UL << 29) /* Reserved */
 #define BFPT_DWORD18_CMD_EXT_16B		(0x3UL << 29) /* 16-bit opcode */
+#define BFPT_DWORD18_BYTE_ORDER_SWAPPED		BIT(31) /* Byte order of 16-bit words in 8D-8D-8D */
 
 struct sfdp_parameter_header {
 	u8		id_lsb;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
index 533f5245a..ba4cb4ccd 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-stm32.c
@@ -15,6 +15,7 @@
 #include <linux/of_net.h>
 #include <linux/phy.h>
 #include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
 #include <linux/pm_wakeirq.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
@@ -22,13 +23,6 @@
 
 #include "stmmac_platform.h"
 
-#define SYSCFG_MCU_ETH_MASK		BIT(23)
-#define SYSCFG_MP1_ETH_MASK		GENMASK(23, 16)
-#define SYSCFG_PMCCLRR_OFFSET		0x40
-
-#define SYSCFG_PMCR_ETH_CLK_SEL		BIT(16)
-#define SYSCFG_PMCR_ETH_REF_CLK_SEL	BIT(17)
-
 /* CLOCK feed to PHY*/
 #define ETH_CK_F_25M	25000000
 #define ETH_CK_F_50M	50000000
@@ -47,14 +41,27 @@
  * RMII  |   1	 |   0	  |   0	   |  n/a  |
  *------------------------------------------
  */
-#define SYSCFG_PMCR_ETH_SEL_MII		BIT(20)
-#define SYSCFG_PMCR_ETH_SEL_RGMII	BIT(21)
-#define SYSCFG_PMCR_ETH_SEL_RMII	BIT(23)
+
+/* STM32MP1 register definitions */
+#define SYSCFG_MCU_ETH_MASK		BIT(23)
+#define SYSCFG_MP1_ETH_MASK		GENMASK(23, 16)
+
 #define SYSCFG_PMCR_ETH_SEL_GMII	0
 #define SYSCFG_MCU_ETH_SEL_MII		0
 #define SYSCFG_MCU_ETH_SEL_RMII		1
 
-/* STM32MP1 register definitions
+/* STM32MP2 register definitions */
+#define SYSCFG_MP2_ETH_MASK		GENMASK(31, 0)
+
+#define SYSCFG_ETHCR_ETH_PTP_CLK_SEL	BIT(2)
+#define SYSCFG_ETHCR_ETH_CLK_SEL	BIT(1)
+#define SYSCFG_ETHCR_ETH_REF_CLK_SEL	BIT(0)
+
+#define SYSCFG_ETHCR_ETH_SEL_MII	0
+#define SYSCFG_ETHCR_ETH_SEL_RGMII	BIT(4)
+#define SYSCFG_ETHCR_ETH_SEL_RMII	BIT(6)
+
+/* STM32MPx register definitions
  *
  * Below table summarizes the clock requirement and clock sources for
  * supported phy interface modes.
@@ -63,17 +70,17 @@
  *|         |        |      25MHz    |        50MHz       |                  |
  * ---------------------------------------------------------------------------
  *|  MII    |	 -   |     eth-ck    |	      n/a	  |	  n/a        |
- *|         |        | st,ext-phyclk |                    |		     |
+ *|         |        |	             |                    |		     |
  * ---------------------------------------------------------------------------
  *|  GMII   |	 -   |     eth-ck    |	      n/a	  |	  n/a        |
- *|         |        | st,ext-phyclk |                    |		     |
+ *|         |        |               |                    |		     |
  * ---------------------------------------------------------------------------
  *| RGMII   |	 -   |     eth-ck    |	      n/a	  |      eth-ck      |
- *|         |        | st,ext-phyclk |                    | st,eth-clk-sel or|
+ *|         |        |               |                    | st,eth-clk-sel or|
  *|         |        |               |                    | st,ext-phyclk    |
  * ---------------------------------------------------------------------------
  *| RMII    |	 -   |     eth-ck    |	    eth-ck        |	  n/a        |
- *|         |        | st,ext-phyclk | st,eth-ref-clk-sel |		     |
+ *|         |        |               | st,eth-ref-clk-sel |		     |
  *|         |        |               | or st,ext-phyclk   |		     |
  * ---------------------------------------------------------------------------
  *
@@ -88,15 +95,29 @@ struct stm32_dwmac {
 	int ext_phyclk;
 	int enable_eth_ck;
 	int eth_clk_sel_reg;
+	int eth_ptp_sel_reg;
 	int eth_ref_clk_sel_reg;
-	int irq_pwr_wakeup;
 	u32 mode_reg;		 /* MAC glue-logic mode register */
+	u32 mode_mask;
 	struct regmap *regmap;
+	struct regulator *regulator;
 	u32 speed;
 	const struct stm32_ops *ops;
 	struct device *dev;
 };
 
+struct stm32_syscfg_pmcsetr {
+	u32 eth1_clk_sel;
+	u32 eth1_ref_clk_sel;
+	u32 eth1_selmii;
+	u32 eth1_sel_rgmii;
+	u32 eth1_sel_rmii;
+	u32 eth2_clk_sel;
+	u32 eth2_ref_clk_sel;
+	u32 eth2_sel_rgmii;
+	u32 eth2_sel_rmii;
+};
+
 struct stm32_ops {
 	int (*set_mode)(struct plat_stmmacenet_data *plat_dat);
 	int (*clk_prepare)(struct stm32_dwmac *dwmac, bool prepare);
@@ -104,7 +125,9 @@ struct stm32_ops {
 	void (*resume)(struct stm32_dwmac *dwmac);
 	int (*parse_data)(struct stm32_dwmac *dwmac,
 			  struct device *dev);
+	u32 syscfg_clr_off;
 	u32 syscfg_eth_mask;
+	struct stm32_syscfg_pmcsetr pmcsetr;
 	bool clk_rx_enable_in_suspend;
 };
 
@@ -176,26 +199,26 @@ static int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)
 	dwmac->enable_eth_ck = false;
 	switch (plat_dat->interface) {
 	case PHY_INTERFACE_MODE_MII:
-		if (clk_rate == ETH_CK_F_25M && dwmac->ext_phyclk)
+		if (clk_rate == ETH_CK_F_25M)
 			dwmac->enable_eth_ck = true;
-		val = SYSCFG_PMCR_ETH_SEL_MII;
+		val = dwmac->ops->pmcsetr.eth1_selmii;
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_MII\n");
 		break;
 	case PHY_INTERFACE_MODE_GMII:
 		val = SYSCFG_PMCR_ETH_SEL_GMII;
-		if (clk_rate == ETH_CK_F_25M &&
-		    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {
+		if (clk_rate == ETH_CK_F_25M)
 			dwmac->enable_eth_ck = true;
-			val |= SYSCFG_PMCR_ETH_CLK_SEL;
-		}
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_GMII\n");
 		break;
 	case PHY_INTERFACE_MODE_RMII:
-		val = SYSCFG_PMCR_ETH_SEL_RMII;
-		if ((clk_rate == ETH_CK_F_25M || clk_rate == ETH_CK_F_50M) &&
+		val = dwmac->ops->pmcsetr.eth1_sel_rmii | dwmac->ops->pmcsetr.eth2_sel_rmii;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_50M) &&
 		    (dwmac->eth_ref_clk_sel_reg || dwmac->ext_phyclk)) {
 			dwmac->enable_eth_ck = true;
-			val |= SYSCFG_PMCR_ETH_REF_CLK_SEL;
+			val |= dwmac->ops->pmcsetr.eth1_ref_clk_sel;
+			val |= dwmac->ops->pmcsetr.eth2_ref_clk_sel;
 		}
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_RMII\n");
 		break;
@@ -203,11 +226,14 @@ static int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_RGMII_RXID:
 	case PHY_INTERFACE_MODE_RGMII_TXID:
-		val = SYSCFG_PMCR_ETH_SEL_RGMII;
-		if ((clk_rate == ETH_CK_F_25M || clk_rate == ETH_CK_F_125M) &&
+		val = dwmac->ops->pmcsetr.eth1_sel_rgmii | dwmac->ops->pmcsetr.eth2_sel_rgmii;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_125M) &&
 		    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {
 			dwmac->enable_eth_ck = true;
-			val |= SYSCFG_PMCR_ETH_CLK_SEL;
+			val |= dwmac->ops->pmcsetr.eth1_clk_sel;
+			val |= dwmac->ops->pmcsetr.eth2_clk_sel;
 		}
 		pr_debug("SYSCFG init : PHY_INTERFACE_MODE_RGMII\n");
 		break;
@@ -219,12 +245,74 @@ static int stm32mp1_set_mode(struct plat_stmmacenet_data *plat_dat)
 	}
 
 	/* Need to update PMCCLRR (clear register) */
-	regmap_write(dwmac->regmap, reg + SYSCFG_PMCCLRR_OFFSET,
-		     dwmac->ops->syscfg_eth_mask);
+	regmap_write(dwmac->regmap, dwmac->ops->syscfg_clr_off,
+		     dwmac->mode_mask);
 
 	/* Update PMCSETR (set register) */
 	return regmap_update_bits(dwmac->regmap, reg,
-				 dwmac->ops->syscfg_eth_mask, val);
+				  dwmac->mode_mask, val);
+}
+
+static int stm32mp2_set_mode(struct plat_stmmacenet_data *plat_dat)
+{
+	struct stm32_dwmac *dwmac = plat_dat->bsp_priv;
+	u32 reg = dwmac->mode_reg, clk_rate;
+	int val = 0;
+
+	clk_rate = clk_get_rate(dwmac->clk_eth_ck);
+	dwmac->enable_eth_ck = false;
+	switch (plat_dat->interface) {
+	case PHY_INTERFACE_MODE_MII:
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		val = SYSCFG_ETHCR_ETH_SEL_MII;
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_MII val =%d\n", val);
+		break;
+	case PHY_INTERFACE_MODE_GMII:
+		if (clk_rate == ETH_CK_F_25M) {
+			dwmac->enable_eth_ck = true;
+			val = SYSCFG_ETHCR_ETH_CLK_SEL;
+		}
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_GMII\n");
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		val = SYSCFG_ETHCR_ETH_SEL_RMII;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_50M) &&
+		    (dwmac->eth_ref_clk_sel_reg || dwmac->ext_phyclk)) {
+			dwmac->enable_eth_ck = true;
+			val |= SYSCFG_ETHCR_ETH_REF_CLK_SEL;
+		}
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_RMII\n");
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		val = SYSCFG_ETHCR_ETH_SEL_RGMII;
+		if (clk_rate == ETH_CK_F_25M)
+			dwmac->enable_eth_ck = true;
+		if ((clk_rate == ETH_CK_F_125M) &&
+		    (dwmac->eth_clk_sel_reg || dwmac->ext_phyclk)) {
+			dwmac->enable_eth_ck = true;
+			val |= SYSCFG_ETHCR_ETH_CLK_SEL;
+		}
+		dev_dbg(dwmac->dev, "SYSCFG init : PHY_INTERFACE_MODE_RGMII\n");
+		break;
+	default:
+		dev_err(dwmac->dev, "SYSCFG init :  Do not manage %d interface\n",
+			 plat_dat->interface);
+		/* Do not manage others interfaces */
+		return -EINVAL;
+	}
+
+	if (dwmac->eth_ptp_sel_reg)
+		val |= SYSCFG_ETHCR_ETH_PTP_CLK_SEL;
+
+	/* Update ETHCR (set register) */
+	return regmap_update_bits(dwmac->regmap, reg,
+				  dwmac->ops->syscfg_eth_mask, val);
 }
 
 static int stm32mcu_set_mode(struct plat_stmmacenet_data *plat_dat)
@@ -250,7 +338,7 @@ static int stm32mcu_set_mode(struct plat_stmmacenet_data *plat_dat)
 	}
 
 	return regmap_update_bits(dwmac->regmap, reg,
-				 dwmac->ops->syscfg_eth_mask, val << 23);
+				 SYSCFG_MCU_ETH_MASK, val << 23);
 }
 
 static void stm32_dwmac_clk_disable(struct stm32_dwmac *dwmac)
@@ -293,22 +381,40 @@ static int stm32_dwmac_parse_data(struct stm32_dwmac *dwmac,
 		return PTR_ERR(dwmac->regmap);
 
 	err = of_property_read_u32_index(np, "st,syscon", 1, &dwmac->mode_reg);
+	if (err) {
+		dev_err(dev, "Can't get sysconfig register offset (%d)\n", err);
+		return err;
+	}
+
+	dwmac->mode_mask = SYSCFG_MP1_ETH_MASK;
+	err = of_property_read_u32_index(np, "st,syscon", 2, &dwmac->mode_mask);
 	if (err)
-		dev_err(dev, "Can't get sysconfig mode offset (%d)\n", err);
+		pr_debug("Warning sysconfig register mask not set\n");
 
-	return err;
+	dwmac->regulator = devm_regulator_get_optional(dev, "phy");
+	if (IS_ERR(dwmac->regulator)) {
+		if (PTR_ERR(dwmac->regulator) == -EPROBE_DEFER) {
+			dev_dbg(dev, "phy regulator is not available yet, deferred probing\n");
+			return -EPROBE_DEFER;
+		}
+		dev_dbg(dev, "no regulator found\n");
+		dwmac->regulator = NULL;
+	}
+
+	return 0;
 }
 
 static int stm32mp1_parse_data(struct stm32_dwmac *dwmac,
 			       struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *np = dev->of_node;
-	int err = 0;
 
 	/* Ethernet PHY have no crystal */
 	dwmac->ext_phyclk = of_property_read_bool(np, "st,ext-phyclk");
 
+	/* PTP (IEEE1588) clock selection */
+	dwmac->eth_ptp_sel_reg = of_property_read_bool(np, "st,eth-ptp-from-rcc");
+
 	/* Gigabit Ethernet 125MHz clock selection. */
 	dwmac->eth_clk_sel_reg = of_property_read_bool(np, "st,eth-clk-sel");
 
@@ -319,7 +425,7 @@ static int stm32mp1_parse_data(struct stm32_dwmac *dwmac,
 	/*  Get ETH_CLK clocks */
 	dwmac->clk_eth_ck = devm_clk_get(dev, "eth-ck");
 	if (IS_ERR(dwmac->clk_eth_ck)) {
-		dev_info(dev, "No phy clock provided...\n");
+		dev_dbg(dev, "No phy clock provided...\n");
 		dwmac->clk_eth_ck = NULL;
 	}
 
@@ -336,29 +442,45 @@ static int stm32mp1_parse_data(struct stm32_dwmac *dwmac,
 	if (IS_ERR(dwmac->syscfg_clk))
 		dwmac->syscfg_clk = NULL;
 
-	/* Get IRQ information early to have an ability to ask for deferred
-	 * probe if needed before we went too far with resource allocation.
-	 */
-	dwmac->irq_pwr_wakeup = platform_get_irq_byname_optional(pdev,
-							"stm32_pwr_wakeup");
-	if (dwmac->irq_pwr_wakeup == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-
-	if (!dwmac->clk_eth_ck && dwmac->irq_pwr_wakeup >= 0) {
-		err = device_init_wakeup(&pdev->dev, true);
-		if (err) {
-			dev_err(&pdev->dev, "Failed to init wake up irq\n");
-			return err;
-		}
-		err = dev_pm_set_dedicated_wake_irq(&pdev->dev,
-						    dwmac->irq_pwr_wakeup);
-		if (err) {
-			dev_err(&pdev->dev, "Failed to set wake up irq\n");
-			device_init_wakeup(&pdev->dev, false);
-		}
-		device_set_wakeup_enable(&pdev->dev, false);
+	return 0;
+}
+
+static int stm32_dwmac_wake_init(struct device *dev,
+				 struct stmmac_resources *stmmac_res)
+{
+	int err;
+
+	device_set_wakeup_capable(dev, true);
+
+	err = dev_pm_set_wake_irq(dev, stmmac_res->wol_irq);
+	if (err) {
+		dev_err(dev, "Failed to set wake up irq\n");
+		device_set_wakeup_capable(dev, false);
+		return err;
+	}
+
+	return 0;
+}
+
+static int phy_power_on(struct stm32_dwmac *bsp_priv, bool enable)
+{
+	int ret;
+	struct device *dev = bsp_priv->dev;
+
+	if (!bsp_priv->regulator)
+		return 0;
+
+	if (enable) {
+		ret = regulator_enable(bsp_priv->regulator);
+		if (ret)
+			dev_err(dev, "fail to enable phy-supply\n");
+	} else {
+		ret = regulator_disable(bsp_priv->regulator);
+		if (ret)
+			dev_err(dev, "fail to disable phy-supply\n");
 	}
-	return err;
+
+	return 0;
 }
 
 static int stm32_dwmac_probe(struct platform_device *pdev)
@@ -399,23 +521,39 @@ static int stm32_dwmac_probe(struct platform_device *pdev)
 		goto err_remove_config_dt;
 	}
 
+	if (stmmac_res.wol_irq && !dwmac->clk_eth_ck) {
+		ret = stm32_dwmac_wake_init(&pdev->dev, &stmmac_res);
+		if (ret)
+			goto err_wake_init_disable;
+	}
+
 	plat_dat->bsp_priv = dwmac;
 
 	ret = stm32_dwmac_init(plat_dat);
 	if (ret)
-		goto err_remove_config_dt;
+		goto err_wake_init_disable;
 
-	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	ret = phy_power_on(plat_dat->bsp_priv, true);
 	if (ret)
 		goto err_clk_disable;
 
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		goto err_gmac_powerdown;
+
 	return 0;
 
+err_gmac_powerdown:
+	phy_power_on(plat_dat->bsp_priv, false);
 err_clk_disable:
 	stm32_dwmac_clk_disable(dwmac);
+err_wake_init_disable:
+	if (stmmac_res.wol_irq && !dwmac->clk_eth_ck) {
+		dev_pm_clear_wake_irq(&pdev->dev);
+		device_set_wakeup_capable(&pdev->dev, false);
+	}
 err_remove_config_dt:
 	stmmac_remove_config_dt(pdev, plat_dat);
-
 	return ret;
 }
 
@@ -424,14 +562,16 @@ static int stm32_dwmac_remove(struct platform_device *pdev)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct stmmac_priv *priv = netdev_priv(ndev);
 	int ret = stmmac_dvr_remove(&pdev->dev);
-	struct stm32_dwmac *dwmac = priv->plat->bsp_priv;
+
+	if (ret)
+		return ret;
 
 	stm32_dwmac_clk_disable(priv->plat->bsp_priv);
 
-	if (dwmac->irq_pwr_wakeup >= 0) {
-		dev_pm_clear_wake_irq(&pdev->dev);
-		device_init_wakeup(&pdev->dev, false);
-	}
+	dev_pm_clear_wake_irq(&pdev->dev);
+	ret = device_init_wakeup(&pdev->dev, false);
+
+	phy_power_on(priv->plat->bsp_priv, false);
 
 	return ret;
 }
@@ -449,12 +589,20 @@ static int stm32mp1_suspend(struct stm32_dwmac *dwmac)
 	if (dwmac->enable_eth_ck)
 		clk_disable_unprepare(dwmac->clk_eth_ck);
 
+	/* Keep the PHY up if we use Wake-on-Lan. */
+	if (!device_may_wakeup(dwmac->dev))
+		phy_power_on(dwmac, false);
+
 	return ret;
 }
 
 static void stm32mp1_resume(struct stm32_dwmac *dwmac)
 {
 	clk_disable_unprepare(dwmac->clk_ethstp);
+
+	/* The PHY was up for Wake-on-Lan. */
+	if (!device_may_wakeup(dwmac->dev))
+		phy_power_on(dwmac, true);
 }
 
 static int stm32mcu_suspend(struct stm32_dwmac *dwmac)
@@ -500,15 +648,14 @@ static int stm32_dwmac_resume(struct device *dev)
 
 	return ret;
 }
-#endif /* CONFIG_PM_SLEEP */
 
 static SIMPLE_DEV_PM_OPS(stm32_dwmac_pm_ops,
 	stm32_dwmac_suspend, stm32_dwmac_resume);
+#endif /* CONFIG_PM_SLEEP */
 
 static struct stm32_ops stm32mcu_dwmac_data = {
 	.set_mode = stm32mcu_set_mode,
 	.suspend = stm32mcu_suspend,
-	.syscfg_eth_mask = SYSCFG_MCU_ETH_MASK
 };
 
 static struct stm32_ops stm32mp1_dwmac_data = {
@@ -517,13 +664,57 @@ static struct stm32_ops stm32mp1_dwmac_data = {
 	.suspend = stm32mp1_suspend,
 	.resume = stm32mp1_resume,
 	.parse_data = stm32mp1_parse_data,
-	.syscfg_eth_mask = SYSCFG_MP1_ETH_MASK,
-	.clk_rx_enable_in_suspend = true
+	.syscfg_clr_off = 0x44,
+	.clk_rx_enable_in_suspend = true,
+	.pmcsetr = {
+		.eth1_clk_sel		= BIT(16),
+		.eth1_ref_clk_sel	= BIT(17),
+		.eth1_selmii		= BIT(20),
+		.eth1_sel_rgmii		= BIT(21),
+		.eth1_sel_rmii		= BIT(23),
+		.eth2_clk_sel		= 0,
+		.eth2_ref_clk_sel	= 0,
+		.eth2_sel_rgmii		= 0,
+		.eth2_sel_rmii		= 0
+	}
+};
+
+static struct stm32_ops stm32mp13_dwmac_data = {
+	.set_mode = stm32mp1_set_mode,
+	.clk_prepare = stm32mp1_clk_prepare,
+	.suspend = stm32mp1_suspend,
+	.resume = stm32mp1_resume,
+	.parse_data = stm32mp1_parse_data,
+	.syscfg_clr_off = 0x08,
+	.clk_rx_enable_in_suspend = true,
+	.pmcsetr = {
+		.eth1_clk_sel		= BIT(16),
+		.eth1_ref_clk_sel	= BIT(17),
+		.eth1_selmii		= 0,
+		.eth1_sel_rgmii		= BIT(21),
+		.eth1_sel_rmii		= BIT(23),
+		.eth2_clk_sel		= BIT(24),
+		.eth2_ref_clk_sel	= BIT(25),
+		.eth2_sel_rgmii		= BIT(29),
+		.eth2_sel_rmii		= BIT(31)
+	}
+};
+
+static struct stm32_ops stm32mp25_dwmac_data = {
+	.set_mode = stm32mp2_set_mode,
+	.clk_prepare = stm32mp1_clk_prepare,
+	.suspend = stm32mp1_suspend,
+	.resume = stm32mp1_resume,
+	.parse_data = stm32mp1_parse_data,
+	.clk_rx_enable_in_suspend = true,
+	.syscfg_eth_mask = SYSCFG_MP2_ETH_MASK
 };
 
 static const struct of_device_id stm32_dwmac_match[] = {
 	{ .compatible = "st,stm32-dwmac", .data = &stm32mcu_dwmac_data},
 	{ .compatible = "st,stm32mp1-dwmac", .data = &stm32mp1_dwmac_data},
+	{ .compatible = "st,stm32mp13-dwmac", .data = &stm32mp13_dwmac_data},
+	{ .compatible = "st,stm32mp25-dwmac", .data = &stm32mp25_dwmac_data},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, stm32_dwmac_match);
@@ -533,7 +724,9 @@ static struct platform_driver stm32_dwmac_driver = {
 	.remove = stm32_dwmac_remove,
 	.driver = {
 		.name           = "stm32-dwmac",
+#ifdef CONFIG_PM_SLEEP
 		.pm		= &stm32_dwmac_pm_ops,
+#endif /* CONFIG_PM_SLEEP */
 		.of_match_table = stm32_dwmac_match,
 	},
 };
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
index d99fa028c..e9766725e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.c
@@ -77,6 +77,12 @@ static void dwmac4_dma_init_rx_chan(void __iomem *ioaddr,
 
 	value = readl(ioaddr + DMA_CHAN_RX_CONTROL(chan));
 	value = value | (rxpbl << DMA_BUS_MODE_RPBL_SHIFT);
+
+	/* Set Receive QOS */
+	value &= ~DMA_CONTROL_RQOS;
+	value |= (dma_cfg->rxqos & DMA_CONTROL_XQOS_MAX) <<
+		 DMA_CONTROL_RQOS_SHIFT;
+
 	writel(value, ioaddr + DMA_CHAN_RX_CONTROL(chan));
 
 	if (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) && likely(dma_cfg->eame))
@@ -99,6 +105,11 @@ static void dwmac4_dma_init_tx_chan(void __iomem *ioaddr,
 	/* Enable OSP to get best performance */
 	value |= DMA_CONTROL_OSP;
 
+	/* Set Transmit QOS */
+	value &= ~DMA_CONTROL_TQOS;
+	value |= (dma_cfg->txqos & DMA_CONTROL_XQOS_MAX) <<
+		 DMA_CONTROL_TQOS_SHIFT;
+
 	writel(value, ioaddr + DMA_CHAN_TX_CONTROL(chan));
 
 	if (IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) && likely(dma_cfg->eame))
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
index 9321879b5..fe3cdc844 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_dma.h
@@ -125,11 +125,16 @@
 
 /* DMA Tx Channel X Control register defines */
 #define DMA_CONTROL_EDSE		BIT(28)
+#define DMA_CONTROL_TQOS		GENMASK(27, 24)
+#define DMA_CONTROL_TQOS_SHIFT		24
+#define DMA_CONTROL_XQOS_MAX		0xf
 #define DMA_CONTROL_TSE			BIT(12)
 #define DMA_CONTROL_OSP			BIT(4)
 #define DMA_CONTROL_ST			BIT(0)
 
 /* DMA Rx Channel X Control register defines */
+#define DMA_CONTROL_RQOS		GENMASK(27, 24)
+#define DMA_CONTROL_RQOS_SHIFT		24
 #define DMA_CONTROL_SR			BIT(0)
 #define DMA_RBSZ_MASK			GENMASK(14, 1)
 #define DMA_RBSZ_SHIFT			1
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index 46944c02b..bdbf86cb1 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -247,7 +247,6 @@ struct stmmac_priv {
 	u32 msg_enable;
 	int wolopts;
 	int wol_irq;
-	bool wol_irq_disabled;
 	int clk_csr;
 	struct timer_list eee_ctrl_timer;
 	int lpi_irq;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index f03aa8a0b..35c8dd92d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -761,16 +761,10 @@ static int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 	if (wol->wolopts) {
 		pr_info("stmmac: wakeup enable\n");
 		device_set_wakeup_enable(priv->device, 1);
-		/* Avoid unbalanced enable_irq_wake calls */
-		if (priv->wol_irq_disabled)
-			enable_irq_wake(priv->wol_irq);
-		priv->wol_irq_disabled = false;
+		enable_irq_wake(priv->wol_irq);
 	} else {
 		device_set_wakeup_enable(priv->device, 0);
-		/* Avoid unbalanced disable_irq_wake calls */
-		if (!priv->wol_irq_disabled)
-			disable_irq_wake(priv->wol_irq);
-		priv->wol_irq_disabled = true;
+		disable_irq_wake(priv->wol_irq);
 	}
 
 	mutex_lock(&priv->lock);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index e2d51014a..79bf81923 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -882,12 +882,16 @@ EXPORT_SYMBOL_GPL(stmmac_init_tstamp_counter);
 static int stmmac_init_ptp(struct stmmac_priv *priv)
 {
 	bool xmac = priv->plat->has_gmac4 || priv->plat->has_xgmac;
+	u32 hwts_active = STMMAC_HWTS_ACTIVE;
 	int ret;
 
 	if (priv->plat->ptp_clk_freq_config)
 		priv->plat->ptp_clk_freq_config(priv);
 
-	ret = stmmac_init_tstamp_counter(priv, STMMAC_HWTS_ACTIVE);
+	if (priv->plat->ext_systime)
+		hwts_active |= PTP_TCR_ESTI;
+
+	ret = stmmac_init_tstamp_counter(priv, hwts_active);
 	if (ret)
 		return ret;
 
@@ -1239,7 +1243,7 @@ static int stmmac_phy_setup(struct stmmac_priv *priv)
 	if (priv->plat->tx_queues_to_use > 1)
 		priv->phylink_config.mac_capabilities &=
 			~(MAC_10HD | MAC_100HD | MAC_1000HD);
-	priv->phylink_config.mac_managed_pm = true;
+	priv->phylink_config.mac_managed_pm = false;
 
 	phylink = phylink_create(&priv->phylink_config, fwnode,
 				 mode, &stmmac_phylink_mac_ops);
@@ -3519,7 +3523,6 @@ static int stmmac_request_irq_multi_msi(struct net_device *dev)
 	/* Request the Wake IRQ in case of another line
 	 * is used for WoL
 	 */
-	priv->wol_irq_disabled = true;
 	if (priv->wol_irq > 0 && priv->wol_irq != dev->irq) {
 		int_name = priv->int_name_wol;
 		sprintf(int_name, "%s:%s", dev->name, "wol");
@@ -7416,8 +7419,11 @@ int stmmac_suspend(struct device *dev)
 	struct stmmac_priv *priv = netdev_priv(ndev);
 	u32 chan;
 
-	if (!ndev || !netif_running(ndev))
+	if (!ndev || !netif_running(ndev)) {
+		/* Select sleep pin state */
+		pinctrl_pm_select_sleep_state(dev);
 		return 0;
+	}
 
 	mutex_lock(&priv->lock);
 
@@ -7524,8 +7530,11 @@ int stmmac_resume(struct device *dev)
 	struct stmmac_priv *priv = netdev_priv(ndev);
 	int ret;
 
-	if (!netif_running(ndev))
+	if (!netif_running(ndev)) {
+		/* Select default pin state */
+		pinctrl_pm_select_default_state(priv->device);
 		return 0;
+	}
 
 	/* Power Down bit, into the PM register, is cleared
 	 * automatically as soon as a magic packet or a Wake-up frame
@@ -7554,16 +7563,8 @@ int stmmac_resume(struct device *dev)
 	}
 
 	rtnl_lock();
-	if (device_may_wakeup(priv->device) && priv->plat->pmt) {
-		phylink_resume(priv->phylink);
-	} else {
-		phylink_resume(priv->phylink);
-		if (device_may_wakeup(priv->device))
-			phylink_speed_up(priv->phylink);
-	}
-	rtnl_unlock();
+	phylink_phy_resume(priv->phylink);
 
-	rtnl_lock();
 	mutex_lock(&priv->lock);
 
 	stmmac_reset_queues_param(priv);
@@ -7581,6 +7582,11 @@ int stmmac_resume(struct device *dev)
 	stmmac_enable_all_dma_irq(priv);
 
 	mutex_unlock(&priv->lock);
+
+	phylink_resume(priv->phylink);
+	if (device_may_wakeup(priv->device) && !priv->plat->pmt)
+		phylink_speed_up(priv->phylink);
+
 	rtnl_unlock();
 
 	netif_device_attach(ndev);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index 0046a4ee6..ff4cad535 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -434,6 +434,10 @@ stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 	of_property_read_u32(np, "max-speed", &plat->max_speed);
 
 	plat->bus_id = of_alias_get_id(np, "ethernet");
+
+	/* Get external system time state from device tree */
+	plat->ext_systime = of_property_read_bool(np, "snps,ext-systime");
+
 	if (plat->bus_id < 0)
 		plat->bus_id = 0;
 
@@ -553,6 +557,8 @@ stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 	of_property_read_u32(np, "snps,txpbl", &dma_cfg->txpbl);
 	of_property_read_u32(np, "snps,rxpbl", &dma_cfg->rxpbl);
 	dma_cfg->pblx8 = !of_property_read_bool(np, "snps,no-pbl-x8");
+	of_property_read_u32(np, "snps,txqos", &dma_cfg->txqos);
+	of_property_read_u32(np, "snps,rxqos", &dma_cfg->rxqos);
 
 	dma_cfg->aal = of_property_read_bool(np, "snps,aal");
 	dma_cfg->fixed_burst = of_property_read_bool(np, "snps,fixed-burst");
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
index bf619295d..a0b4a3e72 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
@@ -52,6 +52,8 @@
 #define	PTP_TCR_TSEVNTENA	BIT(14)
 /* Enable Snapshot for Messages Relevant to Master */
 #define	PTP_TCR_TSMSTRENA	BIT(15)
+/* Enable External System Time input */
+#define	PTP_TCR_ESTI		BIT(20)
 /* Select PTP packets for Taking Snapshots
  * On gmac4 specifically:
  * Enable SYNC, Pdelay_Req, Pdelay_Resp when TSEVNTENA is enabled.
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 944f76e6f..650745a0a 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -323,9 +323,9 @@ static __maybe_unused int mdio_bus_phy_resume(struct device *dev)
 	 * that something went wrong and we should most likely be using
 	 * MAC managed PM, but we are not.
 	 */
-	WARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY &&
+/*	WARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY &&
 		phydev->state != PHY_UP);
-
+*/
 	ret = phy_init_hw(phydev);
 	if (ret < 0)
 		return ret;
diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
index fc58e4afb..2d6ad8193 100644
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@ -80,6 +80,7 @@ struct phylink {
 	DECLARE_PHY_INTERFACE_MASK(sfp_interfaces);
 	__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);
 	u8 sfp_port;
+	bool mac_resume_phy_separately;
 };
 
 #define phylink_printk(level, pl, fmt, ...) \
@@ -1487,6 +1488,7 @@ struct phylink *phylink_create(struct phylink_config *config,
 		return ERR_PTR(-EINVAL);
 	}
 
+	pl->mac_resume_phy_separately = false;
 	pl->using_mac_select_pcs = using_mac_select_pcs;
 	pl->phy_state.interface = iface;
 	pl->link_interface = iface;
@@ -1939,8 +1941,12 @@ void phylink_start(struct phylink *pl)
 	}
 	if (poll)
 		mod_timer(&pl->link_poll, jiffies + HZ);
-	if (pl->phydev)
-		phy_start(pl->phydev);
+	if (pl->phydev) {
+		if (!pl->mac_resume_phy_separately)
+			phy_start(pl->phydev);
+		else
+			pl->mac_resume_phy_separately = false;
+	}
 	if (pl->sfp_bus)
 		sfp_upstream_start(pl->sfp_bus);
 }
@@ -2020,6 +2026,27 @@ void phylink_suspend(struct phylink *pl, bool mac_wol)
 }
 EXPORT_SYMBOL_GPL(phylink_suspend);
 
+/**
+ * phylink_phy_resume() - resume phy alone
+ * @pl: a pointer to a &struct phylink returned from phylink_create()
+ *
+ * In the MAC driver using phylink, if the MAC needs the clock of the phy
+ * when it resumes, can call this function to resume the phy separately.
+ * Then proceed to MAC resume operations.
+ */
+void phylink_phy_resume(struct phylink *pl)
+{
+	ASSERT_RTNL();
+
+	if (!test_bit(PHYLINK_DISABLE_MAC_WOL, &pl->phylink_disable_state)
+	    && pl->phydev) {
+		phy_start(pl->phydev);
+		pl->mac_resume_phy_separately = true;
+	}
+
+}
+EXPORT_SYMBOL_GPL(phylink_phy_resume);
+
 /**
  * phylink_resume() - handle a network device resume event
  * @pl: a pointer to a &struct phylink returned from phylink_create()
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 70e52d270..7832b1b4a 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -342,6 +342,11 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	u16 val_txdly, val_rxdly;
 	int ret;
 
+	/* Set green LED for Link, yellow LED for Active */
+	phy_write(phydev, RTL821x_PAGE_SELECT, 0xd04);
+	phy_write(phydev, 0x10, 0x617f);
+	phy_write(phydev, RTL821x_PAGE_SELECT, 0x0);
+
 	ret = phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1,
 				       RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF,
 				       priv->phycr1);
@@ -406,6 +411,16 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 			val_rxdly ? "enabled" : "disabled");
 	}
 
+	if (of_property_read_bool(dev->of_node, "realtek,eee-disable")) {
+		rtl821x_write_page(phydev, 0xa4b);
+		phy_write(phydev, 0x11, 0x1110);
+		rtl821x_write_page(phydev, 0);
+		phy_write(phydev, 0xd,7);
+		phy_write(phydev, 0xe,0x3c);
+		phy_write(phydev, 0xd,0x4007);
+		phy_write(phydev, 0xe,0x0);
+	}
+
 	if (priv->has_phycr2) {
 		ret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,
 				       RTL8211F_CLKOUT_EN, priv->phycr2);
diff --git a/drivers/net/phy/smsc.c b/drivers/net/phy/smsc.c
index df2c5435c..0d08f1739 100644
--- a/drivers/net/phy/smsc.c
+++ b/drivers/net/phy/smsc.c
@@ -44,7 +44,9 @@ static struct smsc_hw_stat smsc_hw_stats[] = {
 };
 
 struct smsc_phy_priv {
+ 	u16 intmask;
 	bool energy_enable;
+	bool wakeup_enable;
 };
 
 static int smsc_phy_ack_interrupt(struct phy_device *phydev)
@@ -56,6 +58,7 @@ static int smsc_phy_ack_interrupt(struct phy_device *phydev)
 
 static int smsc_phy_config_intr(struct phy_device *phydev)
 {
+	struct smsc_phy_priv *priv = phydev->priv;
 	int rc;
 
 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED) {
@@ -63,9 +66,12 @@ static int smsc_phy_config_intr(struct phy_device *phydev)
 		if (rc)
 			return rc;
 
-		rc = phy_write(phydev, MII_LAN83C185_IM,
-			       MII_LAN83C185_ISF_INT_PHYLIB_EVENTS);
+		if (priv->wakeup_enable)
+			priv->intmask |= MII_LAN83C185_ISF_INT8;
+		rc = phy_write(phydev, MII_LAN83C185_IM, priv->intmask);
 	} else {
+		priv->intmask = 0;
+
 		rc = phy_write(phydev, MII_LAN83C185_IM, 0);
 		if (rc)
 			return rc;
@@ -78,6 +84,7 @@ static int smsc_phy_config_intr(struct phy_device *phydev)
 
 static irqreturn_t smsc_phy_handle_interrupt(struct phy_device *phydev)
 {
+	struct smsc_phy_priv *priv = phydev->priv;
 	int irq_status;
 
 	irq_status = phy_read(phydev, MII_LAN83C185_ISF);
@@ -88,7 +95,7 @@ static irqreturn_t smsc_phy_handle_interrupt(struct phy_device *phydev)
 		return IRQ_NONE;
 	}
 
-	if (!(irq_status & MII_LAN83C185_ISF_INT_PHYLIB_EVENTS))
+	if (!(irq_status &  priv->intmask))
 		return IRQ_NONE;
 
 	phy_trigger_machine(phydev);
@@ -96,11 +103,55 @@ static irqreturn_t smsc_phy_handle_interrupt(struct phy_device *phydev)
 	return IRQ_HANDLED;
 }
 
+static int smsc_phy_config_wol(struct phy_device *phydev)
+{
+	int i, wol_ctrl, wol_filter;
+	u16 pwd[3] = {0, 0, 0};
+
+	if (!phydev->attached_dev)
+		return -ENODEV;
+
+	/* Write @MAC in LAN8742_MMD3_MAC_ADDRA/B/C registers */
+	const u8 *mac_addr = phydev->attached_dev->dev_addr;
+	/* Store the device address for the magic packet */
+	for (i = 0; i < ARRAY_SIZE(pwd); i++)
+		pwd[i] = mac_addr[5 - i * 2] << 8 | mac_addr[5 - (i * 2 + 1)];
+
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_MAC_ADDRA,
+		      pwd[0]);
+
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_MAC_ADDRB,
+		      pwd[1]);
+
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_MAC_ADDRC,
+		      pwd[2]);
+
+	/* Configure WoL */
+	wol_ctrl = phy_read_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL);
+
+	/* Configure LED2 functions as nPME, WoL Configured, Magic Packet Enable */
+	wol_ctrl |= (LAN8742_MMD3_WUCSR_LED2_AS_NPME | LAN8742_MMD3_WUCSR_WOL | LAN8742_MMD3_WUCSR_MPEN);
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL,
+		      wol_ctrl);
+
+	wol_filter = phy_read_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_FILTER);
+
+	/* Configure Filter enabled, Address Match Enable */
+	wol_filter |= (LAN8742_MMD3_WUF_CFGA_FE | LAN8742_MMD3_WUF_CFGA_AME);
+	phy_write_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_FILTER,
+		      wol_filter);
+
+	return 0;
+}
+
 static int smsc_phy_config_init(struct phy_device *phydev)
 {
 	struct smsc_phy_priv *priv = phydev->priv;
 	int rc;
 
+	if (priv->wakeup_enable)
+		smsc_phy_config_wol(phydev);
+
 	if (!priv->energy_enable || phydev->irq != PHY_POLL)
 		return 0;
 
@@ -134,6 +185,17 @@ static int smsc_phy_reset(struct phy_device *phydev)
 	return genphy_soft_reset(phydev);
 }
 
+static int smsc_phy_suspend(struct phy_device *phydev)
+{
+	struct device *dev = &phydev->mdio.dev;
+
+	/* do not power down PHY when PHY enable power/wakeup */
+	if (!device_may_wakeup(dev))
+		return genphy_suspend(phydev);
+
+	return 0;
+}
+
 static int lan87xx_config_aneg(struct phy_device *phydev)
 {
 	int rc;
@@ -237,6 +299,20 @@ static int lan87xx_read_status(struct phy_device *phydev)
 			return rc;
 	}
 
+	if (priv->wakeup_enable) {
+		/* Check status of WUCSR bits 7:4 : Perfect DA Frame, Remote Wakeup
+		 * Frame, Magic Packet, Broadcast Frame Received, if one of these bits
+		 * are 1, clearing them*/
+		int wol_ctrl = phy_read_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL);
+
+		if ((wol_ctrl & (LAN8742_MMD3_WUCSR_PFDA_FR | LAN8742_MMD3_WUCSR_WUFR |
+				 LAN8742_MMD3_WUCSR_MPR | LAN8742_MMD3_WUCSR_BCAST_FR)) > 0) {
+			wol_ctrl |= (LAN8742_MMD3_WUCSR_PFDA_FR | LAN8742_MMD3_WUCSR_WUFR |
+				     LAN8742_MMD3_WUCSR_MPR | LAN8742_MMD3_WUCSR_BCAST_FR);
+			phy_write_mmd(phydev, 3, LAN8742_MMD3_WAKEUP_CTRL,
+				      wol_ctrl);
+		}
+	}
 	return err;
 }
 
@@ -291,10 +367,16 @@ static int smsc_phy_probe(struct phy_device *phydev)
 		return -ENOMEM;
 
 	priv->energy_enable = true;
+	priv->wakeup_enable = false;
 
 	if (of_property_read_bool(of_node, "smsc,disable-energy-detect"))
 		priv->energy_enable = false;
 
+	if (of_property_read_bool(of_node, "wakeup-source")) {
+		device_set_wakeup_capable(dev, true);
+		priv->wakeup_enable = true;
+	}
+
 	phydev->priv = priv;
 
 	/* Make clk optional to keep DTB backward compatibility. */
@@ -477,7 +559,7 @@ static struct phy_driver smsc_phy_driver[] = {
 	.get_strings	= smsc_get_strings,
 	.get_stats	= smsc_get_stats,
 
-	.suspend	= genphy_suspend,
+	.suspend	= smsc_phy_suspend,
 	.resume		= genphy_resume,
 } };
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
index e300278ea..02b7d0a63 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
@@ -962,6 +962,9 @@ int brcmf_sdiod_probe(struct brcmf_sdio_dev *sdiodev)
 #define BRCMF_SDIO_DEVICE(dev_id)	\
 	{SDIO_DEVICE(SDIO_VENDOR_ID_BROADCOM, dev_id)}
 
+#define CYW_SDIO_DEVICE(dev_id)	\
+	{SDIO_DEVICE(SDIO_VENDOR_ID_CYPRESS, dev_id)}
+
 /* devices we support, null terminated */
 static const struct sdio_device_id brcmf_sdmmc_ids[] = {
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43143),
@@ -983,9 +986,10 @@ static const struct sdio_device_id brcmf_sdmmc_ids[] = {
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4359),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_4373),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43012),
-	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43439),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43752),
 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_89359),
+	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43439),
+	CYW_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_CYPRESS_43439),
 	{ /* end: all zeroes */ }
 };
 MODULE_DEVICE_TABLE(sdio, brcmf_sdmmc_ids);
diff --git a/drivers/nvmem/Kconfig b/drivers/nvmem/Kconfig
index ec8a49c04..37574c8f5 100644
--- a/drivers/nvmem/Kconfig
+++ b/drivers/nvmem/Kconfig
@@ -290,9 +290,19 @@ config NVMEM_SPRD_EFUSE
 	  This driver can also be built as a module. If so, the module
 	  will be called nvmem-sprd-efuse.
 
+config NVMEM_STM32_BSEC_OPTEE_TA
+	def_bool NVMEM_STM32_ROMEM && OPTEE
+	help
+	  Say y here to enable the accesses to STM32MP SoC OTPs by the OP-TEE
+	  trusted application STM32MP BSEC.
+
+	  This library is a used by stm32-romem driver or included in the module
+	  called nvmem-stm32-romem.
+
 config NVMEM_STM32_ROMEM
 	tristate "STMicroelectronics STM32 factory-programmed memory support"
 	depends on ARCH_STM32 || COMPILE_TEST
+	depends on OPTEE || !OPTEE
 	help
 	  Say y here to enable read-only access for STMicroelectronics STM32
 	  factory-programmed memory area.
@@ -300,6 +310,16 @@ config NVMEM_STM32_ROMEM
 	  This driver can also be built as a module. If so, the module
 	  will be called nvmem-stm32-romem.
 
+config NVMEM_STM32_TAMP
+	tristate "STMicroelectronics STM32 TAMP backup registers support"
+	depends on ARCH_STM32 || COMPILE_TEST
+	help
+	  Say y here to enable access for STMicroelectronics STM32
+	  TAMP backup registers.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called nvmem_stm32-tamp_bkpregs
+
 config NVMEM_SUNPLUS_OCOTP
 	tristate "Sunplus SoC OTP support"
 	depends on SOC_SP7021 || COMPILE_TEST
diff --git a/drivers/nvmem/Makefile b/drivers/nvmem/Makefile
index fa80fe17e..38ac2e0cd 100644
--- a/drivers/nvmem/Makefile
+++ b/drivers/nvmem/Makefile
@@ -61,6 +61,9 @@ obj-$(CONFIG_NVMEM_SPRD_EFUSE)		+= nvmem_sprd_efuse.o
 nvmem_sprd_efuse-y			:= sprd-efuse.o
 obj-$(CONFIG_NVMEM_STM32_ROMEM)		+= nvmem_stm32_romem.o
 nvmem_stm32_romem-y 			:= stm32-romem.o
+nvmem_stm32_romem-$(CONFIG_NVMEM_STM32_BSEC_OPTEE_TA) += stm32-bsec-optee-ta.o
+obj-$(CONFIG_NVMEM_STM32_TAMP)		+= nvmem_stm32_tamp_nvram.o
+nvmem_stm32_tamp_nvram-y 		:= stm32-tamp-nvram.o
 obj-$(CONFIG_NVMEM_SUNPLUS_OCOTP)	+= nvmem_sunplus_ocotp.o
 nvmem_sunplus_ocotp-y			:= sunplus-ocotp.o
 obj-$(CONFIG_NVMEM_SUNXI_SID)		+= nvmem_sunxi_sid.o
diff --git a/drivers/nvmem/stm32-bsec-optee-ta.c b/drivers/nvmem/stm32-bsec-optee-ta.c
new file mode 100644
index 000000000..089233ada
--- /dev/null
+++ b/drivers/nvmem/stm32-bsec-optee-ta.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * OP-TEE STM32MP BSEC PTA interface, used by STM32 ROMEM driver
+ *
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <linux/tee_drv.h>
+
+#include "stm32-bsec-optee-ta.h"
+
+/*
+ * Read OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0:shadow, 1:fuse, 2:lock)
+ * [out]	memref[1].buffer	Output buffer to store read values
+ * [out]	memref[1].size		Size of OTP to be read
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_ACCESS_DENIED - OTP not accessible by caller
+ */
+#define PTA_BSEC_READ_MEM		0x0
+
+/*
+ * Write OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0:shadow, 1:fuse, 2:lock)
+ * [in]		memref[1].buffer	Input buffer to read values
+ * [in]		memref[1].size		Size of OTP to be written
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_ACCESS_DENIED - OTP not accessible by caller
+ */
+#define PTA_BSEC_WRITE_MEM		0x1
+
+/* value of PTA_BSEC access type = value[in] b */
+#define SHADOW_ACCESS	0
+#define FUSE_ACCESS	1
+#define LOCK_ACCESS	2
+
+/* Bitfield definition for LOCK status */
+#define LOCK_PERM			BIT(30)
+
+/* OP-TEE STM32MP BSEC TA UUID */
+static const uuid_t stm32mp_bsec_ta_uuid =
+	UUID_INIT(0x94cf71ad, 0x80e6, 0x40b5,
+		  0xa7, 0xc6, 0x3d, 0xc5, 0x01, 0xeb, 0x28, 0x03);
+
+/*
+ * Check whether this driver supports the BSEC TA in the TEE instance
+ * represented by the params (ver/data) to this function.
+ */
+static int stm32_bsec_optee_ta_match(struct tee_ioctl_version_data *ver,
+				     const void *data)
+{
+	/* Currently this driver only supports GP compliant, OP-TEE based TA */
+	if ((ver->impl_id == TEE_IMPL_ID_OPTEE) &&
+	    (ver->gen_caps & TEE_GEN_CAP_GP))
+		return 1;
+	else
+		return 0;
+}
+
+/* Open a session to OP-TEE for STM32MP BSEC TA */
+static int stm32_bsec_ta_open_session(struct tee_context *ctx, u32 *id)
+{
+	struct tee_ioctl_open_session_arg sess_arg;
+	int rc;
+
+	memset(&sess_arg, 0, sizeof(sess_arg));
+	export_uuid(sess_arg.uuid, &stm32mp_bsec_ta_uuid);
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;
+	sess_arg.num_params = 0;
+
+	rc = tee_client_open_session(ctx, &sess_arg, NULL);
+	if ((rc < 0) || (sess_arg.ret != 0)) {
+		pr_err("%s: tee_client_open_session failed err:%#x, ret:%#x\n",
+		       __func__, sess_arg.ret, rc);
+		if (!rc)
+			rc = -EINVAL;
+	} else {
+		*id = sess_arg.session;
+	}
+
+	return rc;
+}
+
+/* close a session to OP-TEE for STM32MP BSEC TA */
+static void stm32_bsec_ta_close_session(void *ctx, u32 id)
+{
+	tee_client_close_session(ctx, id);
+}
+
+/* stm32_bsec_optee_ta_open() - initialize the STM32MP BSEC TA */
+int stm32_bsec_optee_ta_open(struct tee_context **ctx)
+{
+	struct tee_context *tee_ctx;
+	u32 session_id;
+	int rc;
+
+	/* Open context with TEE driver */
+	tee_ctx = tee_client_open_context(NULL, stm32_bsec_optee_ta_match, NULL, NULL);
+	if (IS_ERR(tee_ctx)) {
+		rc = PTR_ERR(tee_ctx);
+		if (rc == -ENOENT)
+			return -EPROBE_DEFER;
+		pr_err("%s: tee_client_open_context failed (%d)\n", __func__, rc);
+
+		return rc;
+	}
+
+	/* Check STM32MP BSEC TA presence */
+	rc = stm32_bsec_ta_open_session(tee_ctx, &session_id);
+	if (rc) {
+		tee_client_close_context(tee_ctx);
+		return rc;
+	}
+
+	stm32_bsec_ta_close_session(tee_ctx, session_id);
+
+	*ctx = tee_ctx;
+
+	return 0;
+}
+
+/* stm32_bsec_optee_ta_open() - release the PTA STM32MP BSEC TA */
+void stm32_bsec_optee_ta_close(void *ctx)
+{
+	tee_client_close_context(ctx);
+}
+
+/* stm32_bsec_optee_ta_read() - nvmem read access using PTA client driver */
+int stm32_bsec_optee_ta_read(struct tee_context *ctx, unsigned int offset,
+			     void *buf, size_t bytes)
+{
+	struct tee_shm *shm;
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[2];
+	u8 *shm_buf;
+	u32 start, num_bytes;
+	int ret;
+	u32 session_id;
+
+	ret = stm32_bsec_ta_open_session(ctx, &session_id);
+	if (ret)
+		return ret;
+
+	memset(&arg, 0, sizeof(arg));
+	memset(&param, 0, sizeof(param));
+
+	arg.func = PTA_BSEC_READ_MEM;
+	arg.session = session_id;
+	arg.num_params = 2;
+
+	/* align access on 32bits */
+	start = ALIGN_DOWN(offset, 4);
+	num_bytes = round_up(offset + bytes - start, 4);
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = start;
+	param[0].u.value.b = SHADOW_ACCESS;
+
+	shm = tee_shm_alloc_kernel_buf(ctx, num_bytes);
+	if (IS_ERR(shm)) {
+		ret = PTR_ERR(shm);
+		goto out_tee_session;
+	}
+
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	param[1].u.memref.shm = shm;
+	param[1].u.memref.size = num_bytes;
+
+	ret = tee_client_invoke_func(ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		pr_err("TA_BSEC invoke failed TEE err:%#x, ret:%#x\n",
+		       arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+	if (!ret) {
+		shm_buf = tee_shm_get_va(shm, 0);
+		if (IS_ERR(shm_buf)) {
+			ret = PTR_ERR(shm_buf);
+			pr_err("tee_shm_get_va failed for transmit (%d)\n", ret);
+		} else {
+			/* read data from 32 bits aligned buffer */
+			memcpy(buf, &shm_buf[offset % 4], bytes);
+		}
+	}
+
+	tee_shm_free(shm);
+
+out_tee_session:
+	stm32_bsec_ta_close_session(ctx, session_id);
+
+	return ret;
+}
+
+/* stm32_bsec_optee_ta_write() - nvmem write access using PTA client driver */
+int stm32_bsec_optee_ta_write(struct tee_context *ctx, unsigned int lower,
+			      unsigned int offset, void *buf, size_t bytes)
+{	struct tee_shm *shm;
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[2];
+	u8 *shm_buf;
+	int ret;
+	u32 session_id;
+
+	ret = stm32_bsec_ta_open_session(ctx, &session_id);
+	if (ret)
+		return ret;
+
+	/* Allow only writing complete 32-bits aligned words */
+	if ((bytes % 4) || (offset % 4))
+		return -EINVAL;
+
+	memset(&arg, 0, sizeof(arg));
+	memset(&param, 0, sizeof(param));
+
+	arg.func = PTA_BSEC_WRITE_MEM;
+	arg.session = session_id;
+	arg.num_params = 2;
+
+	param[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = offset;
+	param[0].u.value.b = FUSE_ACCESS;
+
+	shm = tee_shm_alloc_kernel_buf(ctx, bytes);
+	if (IS_ERR(shm)) {
+		ret = PTR_ERR(shm);
+		goto out_tee_session;
+	}
+
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	param[1].u.memref.shm = shm;
+	param[1].u.memref.size = bytes;
+
+	shm_buf = tee_shm_get_va(shm, 0);
+	if (IS_ERR(shm_buf)) {
+		ret = PTR_ERR(shm_buf);
+		pr_err("tee_shm_get_va failed for transmit (%d)\n", ret);
+		tee_shm_free(shm);
+
+		goto out_tee_session;
+	}
+
+	memcpy(shm_buf, buf, bytes);
+
+	ret = tee_client_invoke_func(ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		pr_err("TA_BSEC invoke failed TEE err:%#x, ret:%#x\n", arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+	pr_debug("Write OTPs %d to %zu, ret=%d\n", offset / 4, (offset + bytes) / 4, ret);
+
+	/* Lock the upper OTPs with ECC protection, word programming only */
+	if (!ret && ((offset + bytes) >= (lower * 4))) {
+		u32 start, nb_lock;
+		u32 *lock = (u32 *)shm_buf;
+		int i;
+
+		/*
+		 * don't lock the lower OTPs, no ECC protection and incremental
+		 * bit programming, a second write is allowed
+		 */
+		start = max_t(u32, offset, lower * 4);
+		nb_lock = (offset + bytes - start) / 4;
+
+		param[0].u.value.a = start;
+		param[0].u.value.b = LOCK_ACCESS;
+		param[1].u.memref.size = nb_lock * 4;
+
+		for (i = 0; i < nb_lock; i++)
+			lock[i] = LOCK_PERM;
+
+		ret = tee_client_invoke_func(ctx, &arg, param);
+		if (ret < 0 || arg.ret != 0) {
+			pr_err("TA_BSEC invoke failed TEE err:%#x, ret:%#x\n", arg.ret, ret);
+			if (!ret)
+				ret = -EIO;
+		}
+		pr_debug("Lock upper OTPs %d to %d, ret=%d\n",
+			 start / 4, start / 4 + nb_lock, ret);
+	}
+
+	tee_shm_free(shm);
+
+out_tee_session:
+	stm32_bsec_ta_close_session(ctx, session_id);
+
+	return ret;
+}
diff --git a/drivers/nvmem/stm32-bsec-optee-ta.h b/drivers/nvmem/stm32-bsec-optee-ta.h
new file mode 100644
index 000000000..3966a0535
--- /dev/null
+++ b/drivers/nvmem/stm32-bsec-optee-ta.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * OP-TEE STM32MP BSEC PTA interface, used by STM32 ROMEM driver
+ *
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#if IS_ENABLED(CONFIG_NVMEM_STM32_BSEC_OPTEE_TA)
+/**
+ * stm32_bsec_optee_ta_open() - initialize the STM32 BSEC TA
+ * @ctx: the OP-TEE context on success
+ *
+ * Return:
+ *	On success, 0. On failure, -errno.
+ */
+int stm32_bsec_optee_ta_open(struct tee_context **ctx);
+
+/**
+ * stm32_bsec_optee_ta_close() - release the STM32 BSEC TA
+ * @ctx: the OP-TEE context
+ *
+ * This function used to clean the OP-TEE resources initialized in
+ * stm32_bsec_optee_ta_open(); it can be used as callback to
+ * devm_add_action_or_reset()
+ */
+void stm32_bsec_optee_ta_close(void *ctx);
+
+/**
+ * stm32_bsec_optee_ta_read() - nvmem read access using TA client driver
+ * @ctx: the OP-TEE context provided by stm32_bsec_optee_ta_open
+ * @offset: nvmem offset
+ * @buf: buffer to fill with nvem values
+ * @bytes: number of bytes to read
+ *
+ * Return:
+ *	On success, 0. On failure, -errno.
+ */
+int stm32_bsec_optee_ta_read(struct tee_context *ctx, unsigned int offset,
+			     void *buf, size_t bytes);
+
+/**
+ * stm32_bsec_optee_ta_write() - nvmem write access using TA client driver
+ * @ctx: the OP-TEE context provided by stm32_bsec_optee_ta_open
+ * @lower: number of lower OTP, not protected by ECC
+ * @offset: nvmem offset
+ * @buf: buffer with nvem values
+ * @bytes: number of bytes to write
+ *
+ * Return:
+ *	On success, 0. On failure, -errno.
+ */
+int stm32_bsec_optee_ta_write(struct tee_context *ctx, unsigned int lower,
+			      unsigned int offset, void *buf, size_t bytes);
+
+#else
+
+static inline int stm32_bsec_optee_ta_open(struct tee_context **ctx)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void stm32_bsec_optee_ta_close(void *ctx)
+{
+}
+
+static inline int stm32_bsec_optee_ta_read(struct tee_context *ctx,
+					   unsigned int offset, void *buf,
+					   size_t bytes)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int stm32_bsec_optee_ta_write(struct tee_context *ctx,
+					    unsigned int lower,
+					    unsigned int offset, void *buf,
+					    size_t bytes)
+{
+	return -EOPNOTSUPP;
+}
+#endif /* CONFIG_NVMEM_STM32_BSEC_OPTEE_TA */
diff --git a/drivers/nvmem/stm32-romem.c b/drivers/nvmem/stm32-romem.c
index 354be5268..06f932f04 100644
--- a/drivers/nvmem/stm32-romem.c
+++ b/drivers/nvmem/stm32-romem.c
@@ -11,6 +11,9 @@
 #include <linux/module.h>
 #include <linux/nvmem-provider.h>
 #include <linux/of_device.h>
+#include <linux/tee_drv.h>
+
+#include "stm32-bsec-optee-ta.h"
 
 /* BSEC secure service access from non-secure */
 #define STM32_SMC_BSEC			0x82001003
@@ -19,19 +22,20 @@
 #define STM32_SMC_WRITE_SHADOW		0x03
 #define STM32_SMC_READ_OTP		0x04
 
-/* shadow registers offest */
+/* shadow registers offset */
 #define STM32MP15_BSEC_DATA0		0x200
 
-/* 32 (x 32-bits) lower shadow registers */
-#define STM32MP15_BSEC_NUM_LOWER	32
-
 struct stm32_romem_cfg {
 	int size;
+	u8 lower;
+	bool ta;
 };
 
 struct stm32_romem_priv {
 	void __iomem *base;
 	struct nvmem_config cfg;
+	u8 lower;
+	struct tee_context *ctx;
 };
 
 static int stm32_romem_read(void *context, unsigned int offset, void *buf,
@@ -85,7 +89,7 @@ static int stm32_bsec_read(void *context, unsigned int offset, void *buf,
 	for (i = roffset; (i < roffset + rbytes); i += 4) {
 		u32 otp = i >> 2;
 
-		if (otp < STM32MP15_BSEC_NUM_LOWER) {
+		if (otp < priv->lower) {
 			/* read lower data from shadow registers */
 			val = readl_relaxed(
 				priv->base + STM32MP15_BSEC_DATA0 + i);
@@ -133,15 +137,60 @@ static int stm32_bsec_write(void *context, unsigned int offset, void *buf,
 		}
 	}
 
+	if (offset + bytes >= priv->lower * 4)
+		dev_warn(dev, "Update of upper OTPs with ECC protection (word programming, only once)\n");
+
 	return 0;
 }
 
+static int stm32_bsec_pta_read(void *context, unsigned int offset, void *buf,
+			       size_t bytes)
+{
+	struct stm32_romem_priv *priv = context;
+
+	return stm32_bsec_optee_ta_read(priv->ctx, offset, buf, bytes);
+}
+
+static int stm32_bsec_pta_write(void *context, unsigned int offset, void *buf,
+				size_t bytes)
+{
+	struct stm32_romem_priv *priv = context;
+
+	return stm32_bsec_optee_ta_write(priv->ctx, priv->lower, offset, buf, bytes);
+}
+
+static bool stm32_bsec_smc_check(void)
+{
+	u32 val;
+	int ret;
+
+	/* check that the OP-TEE support the BSEC SMC (legacy mode) */
+	ret = stm32_bsec_smc(STM32_SMC_READ_SHADOW, 0, 0, &val);
+
+	return !ret;
+}
+
+static bool optee_presence_check(void)
+{
+	struct device_node *np;
+	bool tee_detected = false;
+
+	/* check that the OP-TEE node is present and available. */
+	np = of_find_compatible_node(NULL, NULL, "linaro,optee-tz");
+	if (np && of_device_is_available(np))
+		tee_detected = true;
+	of_node_put(np);
+
+	return tee_detected;
+}
+
 static int stm32_romem_probe(struct platform_device *pdev)
 {
 	const struct stm32_romem_cfg *cfg;
 	struct device *dev = &pdev->dev;
 	struct stm32_romem_priv *priv;
 	struct resource *res;
+	int rc;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -158,6 +207,9 @@ static int stm32_romem_probe(struct platform_device *pdev)
 	priv->cfg.dev = dev;
 	priv->cfg.priv = priv;
 	priv->cfg.owner = THIS_MODULE;
+	priv->cfg.type = NVMEM_TYPE_OTP;
+
+	priv->lower = 0;
 
 	cfg = (const struct stm32_romem_cfg *)
 		of_match_device(dev->driver->of_match_table, dev)->data;
@@ -167,23 +219,81 @@ static int stm32_romem_probe(struct platform_device *pdev)
 		priv->cfg.reg_read = stm32_romem_read;
 	} else {
 		priv->cfg.size = cfg->size;
-		priv->cfg.reg_read = stm32_bsec_read;
-		priv->cfg.reg_write = stm32_bsec_write;
+		priv->lower = cfg->lower;
+		if (cfg->ta || optee_presence_check()) {
+			rc = stm32_bsec_optee_ta_open(&priv->ctx);
+			if (rc) {
+				/* wait for OP-TEE client driver to be up and ready */
+				if (rc == -EPROBE_DEFER)
+					return -EPROBE_DEFER;
+				/* BSEC PTA is required or SMC not supported */
+				if (cfg->ta || !stm32_bsec_smc_check())
+					return rc;
+			}
+		}
+		if (priv->ctx) {
+			rc = devm_add_action_or_reset(dev, stm32_bsec_optee_ta_close, priv->ctx);
+			if (rc) {
+				dev_err(dev, "devm_add_action_or_reset() failed (%d)\n", rc);
+				return rc;
+			}
+			priv->cfg.reg_read = stm32_bsec_pta_read;
+			priv->cfg.reg_write = stm32_bsec_pta_write;
+		} else {
+			priv->cfg.reg_read = stm32_bsec_read;
+			priv->cfg.reg_write = stm32_bsec_write;
+		}
 	}
 
 	return PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &priv->cfg));
 }
 
+/*
+ * STM32MP15/13 BSEC OTP regions: 4096 OTP bits (with 3072 effective bits)
+ * => 96 x 32-bits data words
+ * - Lower: 1K bits, 2:1 redundancy, incremental bit programming
+ *   => 32 (x 32-bits) lower shadow registers = words 0 to 31
+ * - Upper: 2K bits, ECC protection, word programming only
+ *   => 64 (x 32-bits) = words 32 to 95
+ */
+
 static const struct stm32_romem_cfg stm32mp15_bsec_cfg = {
-	.size = 384, /* 96 x 32-bits data words */
+	.size = 384,
+	.lower = 32,
+	.ta = false,
 };
 
-static const struct of_device_id stm32_romem_of_match[] = {
+static const struct stm32_romem_cfg stm32mp13_bsec_cfg = {
+	.size = 384,
+	.lower = 32,
+	.ta = true,
+};
+
+/*
+ * STM32MP25 BSEC OTP: 3 regions of 32-bits data words
+ *   lower OTP (OTP0 to OTP127), bitwise (1-bit) programmable
+ *   mid OTP (OTP128 to OTP255), bulk (32-bit) programmable
+ *   upper OTP (OTP256 to OTP383), bulk (32-bit) programmable
+ *              but no access to HWKEY and ECIES key: limited at 367
+ */
+static const struct stm32_romem_cfg stm32mp25_bsec_cfg = {
+	.size = 368 * 4,
+	.lower = 127,
+	.ta = true,
+};
+
+static const struct of_device_id stm32_romem_of_match[] __maybe_unused = {
 	{ .compatible = "st,stm32f4-otp", }, {
 		.compatible = "st,stm32mp15-bsec",
 		.data = (void *)&stm32mp15_bsec_cfg,
 	}, {
+		.compatible = "st,stm32mp13-bsec",
+		.data = (void *)&stm32mp13_bsec_cfg,
+	}, {
+		.compatible = "st,stm32mp25-bsec",
+		.data = (void *)&stm32mp25_bsec_cfg,
 	},
+	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, stm32_romem_of_match);
 
diff --git a/drivers/nvmem/stm32-tamp-nvram.c b/drivers/nvmem/stm32-tamp-nvram.c
new file mode 100644
index 000000000..fcada8d1c
--- /dev/null
+++ b/drivers/nvmem/stm32-tamp-nvram.c
@@ -0,0 +1,669 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STM32 Tamp backup registers access driver
+ *
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ * Author: Simeon Marijon <simeon.marijon@foss.st.com> for STMicroelectronics.
+ */
+
+#include <linux/align.h>
+#include <linux/bits.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/nvmem-provider.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#define RIF_CID1			0x1
+#define CURRENT_CID			RIF_CID1
+#define NB_ZONES_STM32MP1		3
+#define NB_ZONES_STM32MP2		7
+#define NB_REGS_STM32MP1		32
+#define NB_REGS_STM32MP2		128
+
+#define _TAMP_SECCFGR			0x20U
+#define _TAMP_BKPRIFR(x)		(0x70U + 0x4U * ((x) - 1))
+#define _TAMP_RXCIDCFGR(x)		(0x80U + 0x4U * ((x)))
+
+#define BKPREG_PROTECTION_ZONE_1	0
+#define BKPREG_PROTECTION_ZONE_2	1
+#define BKPREG_PROTECTION_ZONE_3	2
+
+#define BKPREG_PROTECTION_ZONE_1_RIF1	0
+#define BKPREG_PROTECTION_ZONE_1_RIF2	1
+#define BKPREG_PROTECTION_ZONE_2_RIF1	2
+#define BKPREG_PROTECTION_ZONE_2_RIF2	3
+#define BKPREG_PROTECTION_ZONE_3_RIF1	4
+#define BKPREG_PROTECTION_ZONE_3_RIF0	5
+#define BKPREG_PROTECTION_ZONE_3_RIF2	6
+#define NB_COMPARTMENT_STM32MP2		3
+
+enum stm32_tamp_bkpreg_access {
+	BKP_READ_WRITE,
+	BKP_READ,
+	BKP_NO
+};
+
+struct stm32_tamp_nvram_priv {
+	struct nvmem_config cfg;
+	const struct stm32_tamp_nvram_plat *data;
+	int *idx_bkpreg_zones_end;
+	struct device *dev;
+	struct regmap *config_regmap;
+	struct regmap *bkpregs_regmap;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+};
+
+struct stm32_tamp_nvram_plat {
+	const unsigned int nb_zones;
+	const unsigned int nb_regs;
+	const struct regmap_config *bkpregs_regmap_cfg;
+	const struct reg_field *config_reg_fields;
+};
+
+static const struct regmap_config stm32mp_tamp_nvram_regmap_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+
+};
+
+static const struct reg_field stm32mp1_tamp_nvram_zone_cfg_fields[NB_ZONES_STM32MP1 - 1] = {
+	[BKPREG_PROTECTION_ZONE_1] = REG_FIELD(_TAMP_SECCFGR, 0, 7),
+	[BKPREG_PROTECTION_ZONE_2] = REG_FIELD(_TAMP_SECCFGR, 16, 23),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_zone_cfg_fields[NB_ZONES_STM32MP2 - 1] = {
+	[BKPREG_PROTECTION_ZONE_1_RIF1] = REG_FIELD(_TAMP_BKPRIFR(1), 0,  7),
+	[BKPREG_PROTECTION_ZONE_1_RIF2] = REG_FIELD(_TAMP_SECCFGR,    0,  7),
+	[BKPREG_PROTECTION_ZONE_2_RIF1] = REG_FIELD(_TAMP_BKPRIFR(2), 0,  7),
+	[BKPREG_PROTECTION_ZONE_2_RIF2] = REG_FIELD(_TAMP_SECCFGR,   16, 23),
+	[BKPREG_PROTECTION_ZONE_3_RIF1] = REG_FIELD(_TAMP_BKPRIFR(3), 0,  7),
+	[BKPREG_PROTECTION_ZONE_3_RIF0] = REG_FIELD(_TAMP_BKPRIFR(3), 16, 23),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_rxcidcfg_cfen_fields[NB_COMPARTMENT_STM32MP2] = {
+	REG_FIELD(_TAMP_RXCIDCFGR(0), 0, 0),
+	REG_FIELD(_TAMP_RXCIDCFGR(1), 0, 0),
+	REG_FIELD(_TAMP_RXCIDCFGR(2), 0, 0),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_rxcidcfg_fields[NB_COMPARTMENT_STM32MP2] = {
+	REG_FIELD(_TAMP_RXCIDCFGR(0), 4, 6),
+	REG_FIELD(_TAMP_RXCIDCFGR(1), 4, 6),
+	REG_FIELD(_TAMP_RXCIDCFGR(2), 4, 6),
+};
+
+static enum stm32_tamp_bkpreg_access stm32mp1_tamp_bkpreg_access[NB_ZONES_STM32MP1] = {
+	[BKPREG_PROTECTION_ZONE_1] = BKP_NO,
+	[BKPREG_PROTECTION_ZONE_2] = BKP_READ,
+	[BKPREG_PROTECTION_ZONE_3] = BKP_READ_WRITE,
+};
+
+static const struct stm32_tamp_nvram_plat stm32mp1_tamp_nvram = {
+	.nb_zones = NB_ZONES_STM32MP1,
+	.nb_regs = NB_REGS_STM32MP1,
+	.bkpregs_regmap_cfg = &stm32mp_tamp_nvram_regmap_cfg,
+	.config_reg_fields = stm32mp1_tamp_nvram_zone_cfg_fields,
+};
+
+static const struct stm32_tamp_nvram_plat stm32mp25_tamp_nvram = {
+	.nb_zones = NB_ZONES_STM32MP2,
+	.nb_regs = NB_REGS_STM32MP2,
+	.bkpregs_regmap_cfg = &stm32mp_tamp_nvram_regmap_cfg,
+	.config_reg_fields = stm32mp25_tamp_nvram_zone_cfg_fields,
+};
+
+static int stm32_tamp_is_compartment_isolation_enabled_mp2X(struct stm32_tamp_nvram_priv *priv)
+{
+	int nb_compartment_enabled = 0;
+	struct device *dev = priv->dev;
+	u32 cfen;
+	struct regmap_field *cfen_field;
+
+	for (int i = 0; i < NB_COMPARTMENT_STM32MP2; i++) {
+		cfen_field = devm_regmap_field_alloc(dev,
+						     priv->config_regmap,
+						     stm32mp25_tamp_nvram_rxcidcfg_cfen_fields[i]);
+		if (IS_ERR_OR_NULL(cfen_field)) {
+			dev_err(dev, "Can't allocate field for reading configuration\n");
+			return -ENOMEM;
+		}
+		if (regmap_field_read(cfen_field, &cfen)) {
+			dev_err(dev, "Can't read field for registers zones\n");
+			devm_regmap_field_free(dev, cfen_field);
+			return -EINVAL;
+		}
+		nb_compartment_enabled += cfen;
+		devm_regmap_field_free(dev, cfen_field);
+	}
+
+	if (!nb_compartment_enabled)
+		return 0;
+	else if (nb_compartment_enabled == NB_COMPARTMENT_STM32MP2)
+		return 1;
+	else
+		return -EINVAL;
+}
+
+static bool *stm32_tamp_get_compartment_owner_mp2X(struct stm32_tamp_nvram_priv *priv)
+{
+	struct device *dev = priv->dev;
+	struct regmap_field *cid_field;
+	u32 cid_per_zone;
+	int isolation_enabled;
+	bool *compartment_owner;
+
+	isolation_enabled = stm32_tamp_is_compartment_isolation_enabled_mp2X(priv);
+	if (isolation_enabled < 0)
+		return NULL;
+
+	compartment_owner = devm_kcalloc(dev,
+					 NB_COMPARTMENT_STM32MP2,
+					 sizeof(*compartment_owner),
+					 GFP_KERNEL);
+	if (!compartment_owner)
+		return ERR_PTR(-ENOMEM);
+
+	for (int i = 0; i < NB_COMPARTMENT_STM32MP2; i++) {
+		if (isolation_enabled) {
+			cid_field = devm_regmap_field_alloc(dev,
+							    priv->config_regmap,
+							    stm32mp25_tamp_nvram_rxcidcfg_fields[i]
+							    );
+
+			if (regmap_field_read(cid_field, &cid_per_zone)) {
+				dev_err(dev, "Can't read field for registers zones\n");
+				devm_regmap_field_free(dev, cid_field);
+				devm_kfree(dev, compartment_owner);
+				return ERR_PTR(-EINVAL);
+			}
+			if (cid_per_zone == CURRENT_CID)
+				compartment_owner[i] = true;
+			else
+				compartment_owner[i] = false;
+
+			devm_regmap_field_free(dev, cid_field);
+		} else {
+			compartment_owner[i] = true;
+		}
+	}
+
+	return compartment_owner;
+}
+
+static enum stm32_tamp_bkpreg_access *stm32_tamp_get_access_rights_mp2X(struct stm32_tamp_nvram_priv
+									*priv)
+{
+	struct device *dev = priv->dev;
+	unsigned int nb_zones = priv->data->nb_zones;
+	bool *compartment_owner;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+
+	compartment_owner = stm32_tamp_get_compartment_owner_mp2X(priv);
+	if (IS_ERR(compartment_owner))
+		return ERR_PTR(-ENODEV);
+
+	bkpreg_access = devm_kcalloc(dev,
+				     NB_ZONES_STM32MP2,
+				     sizeof(*bkpreg_access),
+				     GFP_KERNEL);
+
+	for (int protection_zone_idx = 0; protection_zone_idx < nb_zones;
+	     protection_zone_idx++) {
+		switch (protection_zone_idx) {
+		case BKPREG_PROTECTION_ZONE_1_RIF1:
+			bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_1_RIF2:
+			bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_2_RIF1:
+			if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_2_RIF2:
+			if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF1:
+			if (compartment_owner[1])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[0] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF0:
+			if (compartment_owner[0])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF2:
+			if (compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[0] || compartment_owner[1])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		default:
+			devm_kfree(dev, bkpreg_access);
+			return ERR_PTR(-ENODEV);
+		}
+	}
+
+	return bkpreg_access;
+}
+
+static int stm32_tamp_nvram_bkpreg_get_zone(struct stm32_tamp_nvram_priv *priv, int reg)
+{
+	int *idx_bkpreg_zones_end = priv->idx_bkpreg_zones_end;
+	int nb_zones = priv->data->nb_zones;
+	int protection_zone_idx;
+
+	if (reg < 0)
+		return -1; // negative reg is the boundary of an empty zone
+
+	for (protection_zone_idx = 0; protection_zone_idx < nb_zones; protection_zone_idx++) {
+		if (reg <= idx_bkpreg_zones_end[protection_zone_idx])
+			break;
+	}
+
+	if (protection_zone_idx >= nb_zones)
+		return -1; // the reg is not a part of any zone
+
+	return protection_zone_idx;
+}
+
+static bool stm32_tamp_nvram_rights(struct stm32_tamp_nvram_priv *priv, int reg, bool read_only)
+{
+	struct device *dev = priv->dev;
+	int protection_zone_idx = stm32_tamp_nvram_bkpreg_get_zone(priv, reg);
+
+	if (protection_zone_idx < 0)
+		return false;
+
+	switch (priv->bkpreg_access[protection_zone_idx]) {
+	case BKP_READ_WRITE:
+		return true;
+	case BKP_READ:
+		return read_only;
+	case BKP_NO:
+		return false;
+	default:
+		dev_err(dev, "Can't get access rights for the zone\n");
+		return false;
+	}
+
+	return false;
+}
+
+static int stm32_tamp_nvram_write_byte(struct stm32_tamp_nvram_priv *priv, u32 offset, u8 byte)
+{
+	int offset_aligned = ALIGN_DOWN(offset, sizeof(u32));
+	int byte_in_word = offset - offset_aligned;
+	u32 read_value, to_be_writen_value;
+	u32 reg_idx = offset_aligned / sizeof(u32);
+
+	if (!stm32_tamp_nvram_rights(priv, reg_idx, false))
+		return -EIO;
+
+	regmap_read(priv->bkpregs_regmap, offset_aligned, &read_value);
+	to_be_writen_value = read_value & ~(0xFFUL << byte_in_word * 8);
+	to_be_writen_value |=  (u32)byte << (byte_in_word * 8);
+
+	return regmap_write(priv->bkpregs_regmap, offset_aligned, to_be_writen_value);
+}
+
+static int stm32_tamp_nvram_read_byte(struct stm32_tamp_nvram_priv *priv, u32 offset, u8 *byte)
+{
+	int offset_aligned = ALIGN_DOWN(offset, sizeof(u32));
+	int byte_in_word = offset - offset_aligned;
+	u32 read_value;
+	u32 reg_idx = offset_aligned / sizeof(u32);
+
+	if (!stm32_tamp_nvram_rights(priv, reg_idx, true))
+		return -EIO;
+
+	regmap_read(priv->bkpregs_regmap, offset_aligned, &read_value);
+	*byte = (read_value >> (byte_in_word * 8)) & 0xFF;
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_read(void *context, unsigned int offset, void *buf, size_t bytes)
+{
+	struct stm32_tamp_nvram_priv *priv = context;
+	struct device *dev = priv->dev;
+	u8 byte;
+	u8 *buf_u8 = buf;
+	u32 temp_u32;
+	int i, ret;
+	size_t total = offset + bytes;
+	u32 reg_idx;
+
+	i = offset;
+	while (i < total)  {
+		reg_idx = i / sizeof(u32);
+		if (i + sizeof(u32) <= total && IS_ALIGNED(i, sizeof(u32))) {
+			if (!stm32_tamp_nvram_rights(priv, reg_idx, true)) {
+				dev_dbg(dev, "Backup register %u is not allowed to be read\n",
+					reg_idx);
+				temp_u32 = 0;
+			} else {
+				regmap_read(priv->bkpregs_regmap, i, &temp_u32);
+			}
+			memcpy(buf_u8, &temp_u32, sizeof(u32));
+			buf_u8 += sizeof(u32);
+			i += sizeof(u32);
+		} else {
+			ret = stm32_tamp_nvram_read_byte(priv, i, &byte);
+			if (ret) {
+				dev_dbg(dev, "Backup register %u is not allowed to be read\n",
+					reg_idx);
+				byte = 0;
+			}
+			*buf_u8 = byte;
+			i++;
+			buf_u8++;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_write(void *context, unsigned int offset, void *buf, size_t bytes)
+{
+	struct stm32_tamp_nvram_priv *priv = context;
+	struct device *dev = priv->dev;
+	u8 *buf_u8 = (u8 *)buf;
+	u32 temp_u32;
+	size_t total = offset + bytes;
+	int i, ret;
+	u32 reg_idx;
+
+	i = offset;
+	while (i < total)  {
+		reg_idx = i / sizeof(u32);
+		if (i + sizeof(u32) <= total && IS_ALIGNED(i, sizeof(u32))) {
+			if (stm32_tamp_nvram_rights(priv, reg_idx, false)) {
+				memcpy(&temp_u32, buf_u8, sizeof(u32));
+				regmap_write(priv->bkpregs_regmap, i, temp_u32);
+			} else {
+				dev_dbg(dev, "Backup register %u is not allowed to be written",
+					reg_idx);
+			}
+			buf_u8 += sizeof(u32);
+			i += sizeof(u32);
+		} else {
+			ret = stm32_tamp_nvram_write_byte(priv, i, *buf_u8);
+			if (ret)
+				dev_dbg(dev, "Backup register %u is not allowed to be written",
+					reg_idx);
+			i++;
+			buf_u8++;
+		}
+	}
+
+	return 0;
+}
+
+static int *stm32_tamp_nvram_get_backup_zones(struct stm32_tamp_nvram_priv *priv)
+{
+	struct device *dev = priv->dev;
+	int nb_zones = priv->data->nb_zones;
+	int zone_idx;
+	u32 *idx_bkpreg_zones_end;
+	struct regmap *tamp_regmap = priv->config_regmap;
+	u32 offset_field;
+
+	idx_bkpreg_zones_end = devm_kcalloc(dev,
+					    sizeof(*idx_bkpreg_zones_end),
+					    nb_zones,
+					    GFP_KERNEL);
+	if (!idx_bkpreg_zones_end) {
+		dev_err(dev, "Can't allocate registers zones\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	//Get the n-1 frontiers of zone within the tamp configuration registers
+	for (zone_idx = 0; zone_idx < nb_zones - 1; zone_idx++) {
+		const struct reg_field reg_field = priv->data->config_reg_fields[zone_idx];
+		struct regmap_field *field = devm_regmap_field_alloc(dev,
+								     tamp_regmap,
+								     reg_field);
+
+		if (IS_ERR_OR_NULL(field)) {
+			dev_err(dev, "Can't allocate registers zones\n");
+			devm_kfree(dev, idx_bkpreg_zones_end);
+			return ERR_PTR(-ENOMEM);
+		}
+		if (regmap_field_read(field, &offset_field)) {
+			dev_err(dev, "Can't read field for registers zones\n");
+			devm_kfree(dev, idx_bkpreg_zones_end);
+			return ERR_PTR(-EIO);
+		}
+
+		idx_bkpreg_zones_end[zone_idx] = offset_field - 1;
+	}
+
+	//The last zone end is defined by the number of registers in TAMP
+	idx_bkpreg_zones_end[zone_idx] = priv->data->nb_regs - 1;
+
+	return idx_bkpreg_zones_end;
+}
+
+static const struct of_device_id stm32_tamp_nvram_of_match[] = {
+	{ .compatible = "st,stm32mp15-tamp-nvram",
+	  .data = &stm32mp1_tamp_nvram },
+	{ .compatible = "st,stm32mp25-tamp-nvram",
+	  .data = &stm32mp25_tamp_nvram },
+	{},
+};
+
+static int stm32_tamp_nvram_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_tamp_nvram_priv *priv;
+	struct resource *res;
+	struct device_node *of_node;
+	const struct of_device_id *of_id;
+	void __iomem *base_addr;
+	unsigned int *zones_end;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &pdev->dev;
+
+	of_node = dev_of_node(dev);
+	if (!of_node) {
+		dev_err(dev, "Can't get of node of the device\n");
+		return -ENODEV;
+	}
+	of_id = of_match_node(stm32_tamp_nvram_of_match, of_node);
+	if (IS_ERR_OR_NULL(of_id)) {
+		dev_err(dev, "Can't get of_id of the device\n");
+		return -ENODEV;
+	}
+	priv->data = (struct stm32_tamp_nvram_plat *)of_id->data;
+	if (IS_ERR_OR_NULL(priv->data)) {
+		dev_err(dev, "Can't get platform data of the node\n");
+		return -ENODEV;
+	}
+
+	priv->config_regmap = syscon_node_to_regmap(dev->parent->of_node);
+	if (IS_ERR_OR_NULL(priv->config_regmap)) {
+		dev_dbg(dev, "Deferring till parent probed\n");
+		return -EPROBE_DEFER;
+	}
+
+	priv->idx_bkpreg_zones_end = stm32_tamp_nvram_get_backup_zones(priv);
+	if (IS_ERR_OR_NULL(priv->idx_bkpreg_zones_end)) {
+		dev_dbg(dev, "Can't determine protection zone\n");
+		return -ENODEV;
+	}
+	zones_end = priv->idx_bkpreg_zones_end;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Can't get resource\n");
+		return -ENODEV;
+	}
+	base_addr = devm_ioremap_resource(dev, res);
+	if (IS_ERR_OR_NULL(base_addr)) {
+		dev_err(dev, "Can't remap resource\n");
+		return PTR_ERR(base_addr);
+	}
+	priv->bkpregs_regmap = devm_regmap_init_mmio(dev,
+						     base_addr,
+						     priv->data->bkpregs_regmap_cfg);
+	priv->cfg.name = "stm32-tamp-nvram";
+	priv->cfg.word_size = 1;
+	priv->cfg.stride = 1;
+	priv->cfg.dev = dev;
+	priv->cfg.priv = priv;
+	priv->cfg.owner = THIS_MODULE;
+	priv->cfg.type = NVMEM_TYPE_BATTERY_BACKED;
+	priv->cfg.size = resource_size(res);
+	priv->cfg.reg_read = stm32_tamp_nvram_read;
+	priv->cfg.reg_write = stm32_tamp_nvram_write;
+
+	if (of_device_is_compatible(pdev->dev.of_node,
+				    "st,stm32mp25-tamp-nvram")) {
+		priv->bkpreg_access = stm32_tamp_get_access_rights_mp2X(priv);
+		if (IS_ERR_OR_NULL(priv->bkpreg_access))
+			return -ENODEV;
+
+		dev_dbg(dev, "\n"
+			"Zone 1-RIF1 %3d - %3d %c%c\n"
+			"Zone 1-RIF2 %3d - %3d %c%c\n"
+			"Zone 2-RIF1 %3d - %3d %c%c\n"
+			"Zone 2-RIF2 %3d - %3d %c%c\n"
+			"Zone 3-RIF1 %3d - %3d %c%c\n"
+			"Zone 3-RIF0 %3d - %3d %c%c\n"
+			"Zone 3-RIF2 %3d - %3d %c%c\n",
+			0,
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF0] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+						false) ? 'W' : '-'
+				);
+	} else if (of_device_is_compatible(pdev->dev.of_node, "st,stm32mp15-tamp-nvram")) {
+		priv->bkpreg_access = stm32mp1_tamp_bkpreg_access;
+
+		dev_dbg(dev, "\n"
+			"Zone 1 %3d - %3d %c%c\n"
+			"Zone 2 %3d - %3d %c%c\n"
+			"Zone 3 %3d - %3d %c%c\n",
+			0,
+			zones_end[BKPREG_PROTECTION_ZONE_1],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_1],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_1],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_2],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_2],
+						false) ? 'W' : '-',
+			zones_end[BKPREG_PROTECTION_ZONE_2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3],
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3],
+						true) ? 'R' : '-',
+			stm32_tamp_nvram_rights(priv,
+						zones_end[BKPREG_PROTECTION_ZONE_3],
+						false) ? 'W' : '-');
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	return PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &priv->cfg));
+}
+
+MODULE_DEVICE_TABLE(of, stm32_tamp_nvram_of_match);
+
+static struct platform_driver stm32_tamp_nvram_driver = {
+	.probe = stm32_tamp_nvram_probe,
+	.driver = {
+		.name = "stm32-tamp-nvram",
+		.of_match_table = of_match_ptr(stm32_tamp_nvram_of_match),
+	},
+};
+
+module_platform_driver(stm32_tamp_nvram_driver)
+MODULE_AUTHOR("Simeon Marijon <simeon.marijon@foss.st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 NVMEM TAMP Backup registeristers");
+MODULE_ALIAS("platform:nvmem-stm32-tamp-nvram");
+MODULE_LICENSE("GPL");
diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index ae9d083c4..af934a78a 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -385,4 +385,27 @@ config PCIE_FU740
 	  Say Y here if you want PCIe controller support for the SiFive
 	  FU740.
 
+config PCIE_STM32
+	tristate "STMicroelectronics PCIe Controller Host Mode for STM32 MP25"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on PCI_MSI_IRQ_DOMAIN
+	select PCIE_DW_HOST
+	help
+	  Enables support for the DesignWare core based PCIe host controller
+	  found in STM32 MP25 Soc.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called pcie-stm32.
+
+config PCIE_STM32_EP
+	tristate "ST-Microelectronics PCIe Controller Endpoint Mode for STM32 MP25"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on PCI_ENDPOINT
+	select PCIE_DW_EP
+	help
+	  Enables support for DesignWare core based PCIe EP controller found
+	  in STM32 MP25 Soc.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called pcie-stm32-ep.
 endmenu
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index 8ba7b67f5..082cfff48 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -25,6 +25,8 @@ obj-$(CONFIG_PCIE_TEGRA194) += pcie-tegra194.o
 obj-$(CONFIG_PCIE_UNIPHIER) += pcie-uniphier.o
 obj-$(CONFIG_PCIE_UNIPHIER_EP) += pcie-uniphier-ep.o
 obj-$(CONFIG_PCIE_VISCONTI_HOST) += pcie-visconti.o
+obj-$(CONFIG_PCIE_STM32) += pcie-stm32.o
+obj-$(CONFIG_PCIE_STM32_EP) += pcie-stm32-ep.o
 
 # The following drivers are for devices that use the generic ACPI
 # pci_root.c driver but don't support standard ECAM config access.
diff --git a/drivers/pci/controller/dwc/pcie-designware-ep.c b/drivers/pci/controller/dwc/pcie-designware-ep.c
index 4086a7818..1326eb7aa 100644
--- a/drivers/pci/controller/dwc/pcie-designware-ep.c
+++ b/drivers/pci/controller/dwc/pcie-designware-ep.c
@@ -623,6 +623,7 @@ void dw_pcie_ep_exit(struct dw_pcie_ep *ep)
 
 	pci_epc_mem_exit(epc);
 }
+EXPORT_SYMBOL_GPL(dw_pcie_ep_exit);
 
 static unsigned int dw_pcie_ep_find_ext_capability(struct dw_pcie *pci, int cap)
 {
diff --git a/drivers/pci/controller/dwc/pcie-stm32-ep.c b/drivers/pci/controller/dwc/pcie-stm32-ep.c
new file mode 100644
index 000000000..53a5acf83
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-stm32-ep.c
@@ -0,0 +1,431 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ST PCIe Endpoint driver for STM32-MP25 SoC
+ *
+ * Copyright (C) 2023 ST Microelectronics - All Rights Reserved
+ * Author: Christian Bruel <christian.bruel@foss.st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/phy/phy.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include "pcie-designware.h"
+#include "pcie-stm32.h"
+
+enum stm32_pcie_ep_link_status {
+	STM32_PCIE_EP_LINK_DISABLED,
+	STM32_PCIE_EP_LINK_ENABLED,
+};
+
+struct stm32_pcie {
+	struct dw_pcie *pci;
+	struct regmap *regmap;
+	struct reset_control *rst;
+	struct phy *phy;
+	struct clk *clk;
+	struct gpio_desc *reset_gpio;
+	enum stm32_pcie_ep_link_status link_status;
+	unsigned int perst_irq;
+};
+
+static const struct of_device_id stm32_pcie_ep_of_match[] = {
+	{ .compatible = "st,stm32mp25-pcie-ep" },
+	{},
+};
+
+static void stm32_pcie_ep_init(struct dw_pcie_ep *ep)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	enum pci_barno bar;
+
+	for (bar = BAR_0; bar <= PCI_STD_NUM_BARS; bar++)
+		dw_pcie_ep_reset_bar(pci, bar);
+
+	/* Defer Completion Requests until link started */
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+			   STM32MP25_PCIECR_REQ_RETRY_EN,
+			   STM32MP25_PCIECR_REQ_RETRY_EN);
+}
+
+static int stm32_pcie_enable_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	int ret;
+
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+			   STM32MP25_PCIECR_LTSSM_EN,
+			   STM32MP25_PCIECR_LTSSM_EN);
+
+	ret = dw_pcie_wait_for_link(pci);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+			   STM32MP25_PCIECR_REQ_RETRY_EN,
+			   0);
+
+	return 0;
+}
+
+static void stm32_pcie_disable_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+			   STM32MP25_PCIECR_REQ_RETRY_EN,
+			   STM32MP25_PCIECR_REQ_RETRY_EN);
+
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR, STM32MP25_PCIECR_LTSSM_EN, 0);
+}
+
+static int stm32_pcie_start_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	int ret;
+
+	if (stm32_pcie->link_status == STM32_PCIE_EP_LINK_ENABLED) {
+		dev_dbg(pci->dev, "Link is already enabled\n");
+		return 0;
+	}
+
+	ret = stm32_pcie_enable_link(pci);
+	if (ret) {
+		dev_err(pci->dev, "PCIe cannot establish link: %d\n", ret);
+		return ret;
+	}
+
+	stm32_pcie->link_status = STM32_PCIE_EP_LINK_ENABLED;
+
+	enable_irq(stm32_pcie->perst_irq);
+
+	return 0;
+}
+
+static void stm32_pcie_stop_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+
+	if (stm32_pcie->link_status == STM32_PCIE_EP_LINK_DISABLED) {
+		dev_dbg(pci->dev, "Link is already disabled\n");
+		return;
+	}
+
+	disable_irq(stm32_pcie->perst_irq);
+
+	stm32_pcie_disable_link(pci);
+
+	stm32_pcie->link_status = STM32_PCIE_EP_LINK_DISABLED;
+}
+
+static int stm32_pcie_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
+				enum pci_epc_irq_type type, u16 interrupt_num)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+
+	switch (type) {
+	case PCI_EPC_IRQ_LEGACY:
+		return dw_pcie_ep_raise_legacy_irq(ep, func_no);
+	case PCI_EPC_IRQ_MSI:
+		return dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);
+	default:
+		dev_err(pci->dev, "UNKNOWN IRQ type\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct pci_epc_features stm32_pcie_epc_features = {
+	.force_core_init = true,
+	.core_init_notifier = true,
+	.msi_capable = true,
+	.align = 1 << 16,
+};
+
+static const struct pci_epc_features*
+stm32_pcie_get_features(struct dw_pcie_ep *ep)
+{
+	return &stm32_pcie_epc_features;
+}
+
+static const struct dw_pcie_ep_ops stm32_pcie_ep_ops = {
+	.ep_init = stm32_pcie_ep_init,
+	.raise_irq = stm32_pcie_raise_irq,
+	.get_features = stm32_pcie_get_features,
+};
+
+static const struct dw_pcie_ops dw_pcie_ops = {
+	.start_link = stm32_pcie_start_link,
+	.stop_link = stm32_pcie_stop_link,
+};
+
+static int stm32_pcie_enable_resources(struct stm32_pcie *stm32_pcie)
+{
+	int ret;
+
+	ret = phy_init(stm32_pcie->phy);
+	if (ret)
+		return ret;
+
+	ret = clk_prepare_enable(stm32_pcie->clk);
+	if (ret)
+		phy_exit(stm32_pcie->phy);
+
+	return ret;
+}
+
+static void stm32_pcie_disable_resources(struct stm32_pcie *stm32_pcie)
+{
+	clk_disable_unprepare(stm32_pcie->clk);
+
+	phy_exit(stm32_pcie->phy);
+}
+
+static void stm32_pcie_perst_assert(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	struct device *dev = pci->dev;
+
+	dev_dbg(dev, "PERST asserted by host. Shutting down the PCIe link\n");
+
+	/*
+	 * Do not try to release resources if the PERST# is
+	 * asserted before the link is started.
+	 */
+	if (stm32_pcie->link_status == STM32_PCIE_EP_LINK_DISABLED) {
+		dev_dbg(pci->dev, "Link is already disabled\n");
+		return;
+	}
+
+	stm32_pcie_disable_link(pci);
+
+	stm32_pcie_disable_resources(stm32_pcie);
+
+	pm_runtime_put_sync(dev);
+
+	stm32_pcie->link_status = STM32_PCIE_EP_LINK_DISABLED;
+}
+
+static void stm32_pcie_perst_deassert(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	struct device *dev = pci->dev;
+	struct dw_pcie_ep *ep = &pci->ep;
+	int ret;
+
+	if (stm32_pcie->link_status == STM32_PCIE_EP_LINK_ENABLED) {
+		dev_dbg(pci->dev, "Link is already enabled\n");
+		return;
+	}
+
+	dev_dbg(dev, "PERST de-asserted by host. Starting link training\n");
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0) {
+		dev_err(dev, "pm runtime resume failed: %d\n", ret);
+		return;
+	}
+
+	ret = stm32_pcie_enable_resources(stm32_pcie);
+	if (ret) {
+		dev_err(dev, "Failed to enable resources: %d\n", ret);
+		pm_runtime_put_sync(dev);
+		return;
+	}
+
+	ret = stm32_pcie_enable_link(pci);
+	if (ret) {
+		dev_err(dev, "PCIe Cannot establish link: %d\n", ret);
+		stm32_pcie_disable_resources(stm32_pcie);
+		pm_runtime_put_sync(dev);
+		return;
+	}
+
+	ret = dw_pcie_ep_init_complete(ep);
+	if (ret) {
+		dev_err(dev, "Failed to complete initialization: %d\n", ret);
+		stm32_pcie_disable_link(pci);
+		stm32_pcie_disable_resources(stm32_pcie);
+		pm_runtime_put_sync(dev);
+		return;
+	}
+
+	dw_pcie_ep_init_notify(ep);
+
+	stm32_pcie->link_status = STM32_PCIE_EP_LINK_ENABLED;
+}
+
+static irqreturn_t stm32_pcie_ep_perst_irq_thread(int irq, void *data)
+{
+	struct stm32_pcie *stm32_pcie = data;
+	struct dw_pcie *pci = stm32_pcie->pci;
+	u32 perst;
+
+	perst = gpiod_get_value(stm32_pcie->reset_gpio);
+	if (perst)
+		stm32_pcie_perst_assert(pci);
+	else
+		stm32_pcie_perst_deassert(pci);
+
+	return IRQ_HANDLED;
+}
+
+static int stm32_add_pcie_ep(struct stm32_pcie *stm32_pcie,
+			     struct platform_device *pdev)
+{
+	struct dw_pcie *pci = stm32_pcie->pci;
+	struct dw_pcie_ep *ep = &pci->ep;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	ret = regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+				 STM32MP25_PCIECR_TYPE_MASK,
+				 STM32MP25_PCIECR_EP);
+	if (ret)
+		return ret;
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0) {
+		dev_err(dev, "pm runtime resume failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = reset_control_reset(stm32_pcie->rst);
+	if (ret) {
+		dev_err(dev, "reset_control_reset failed %d\n", ret);
+		pm_runtime_put_sync(dev);
+		return ret;
+	}
+
+	ep->ops = &stm32_pcie_ep_ops;
+
+	ret = stm32_pcie_enable_resources(stm32_pcie);
+	if (ret) {
+		dev_err(dev, "failed to enable resources: %d\n", ret);
+		pm_runtime_put_sync(dev);
+		return ret;
+	}
+
+	ret = dw_pcie_ep_init(ep);
+	if (ret) {
+		dev_err(dev, "failed to initialize ep: %d\n", ret);
+		stm32_pcie_disable_resources(stm32_pcie);
+		pm_runtime_put_sync(dev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_pcie_probe(struct platform_device *pdev)
+{
+	struct stm32_pcie *stm32_pcie;
+	struct dw_pcie *dw;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	stm32_pcie = devm_kzalloc(dev, sizeof(*stm32_pcie), GFP_KERNEL);
+	if (!stm32_pcie)
+		return -ENOMEM;
+
+	dw = devm_kzalloc(dev, sizeof(*dw), GFP_KERNEL);
+	if (!dw)
+		return -ENOMEM;
+	stm32_pcie->pci = dw;
+
+	dw->dev = dev;
+	dw->ops = &dw_pcie_ops;
+
+	/* regmap registers for PCIe IP configuration */
+	stm32_pcie->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(stm32_pcie->regmap))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->regmap),
+				     "No syscfg phandle specified\n");
+
+	stm32_pcie->phy = devm_phy_get(dev, "pcie-phy");
+	if (IS_ERR(stm32_pcie->phy))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->phy),
+				     "failed to get pcie-phy\n");
+
+	stm32_pcie->clk = devm_clk_get(dev, "core");
+	if (IS_ERR(stm32_pcie->clk))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->clk),
+				     "Failed to get PCIe clock source\n");
+
+	stm32_pcie->rst = devm_reset_control_get(dev, "pcie");
+	if (IS_ERR(stm32_pcie->rst))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->rst),
+				     "Failed to get PCIe reset\n");
+
+	stm32_pcie->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_IN);
+	if (IS_ERR(stm32_pcie->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->reset_gpio),
+				     "Failed to get reset GPIO\n");
+
+	ret = phy_set_mode(stm32_pcie->phy, PHY_MODE_PCIE);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, stm32_pcie);
+
+	ret = devm_pm_runtime_enable(dev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable pm runtime %d\n", ret);
+		return ret;
+	}
+
+	stm32_pcie->perst_irq = gpiod_to_irq(stm32_pcie->reset_gpio);
+
+	/* Will be enabled in start_link when device is initialized. */
+	irq_set_status_flags(stm32_pcie->perst_irq, IRQ_NOAUTOEN);
+
+	ret = devm_request_threaded_irq(dev, stm32_pcie->perst_irq, NULL,
+					stm32_pcie_ep_perst_irq_thread,
+					IRQF_TRIGGER_RISING |
+					IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					"perst_irq", stm32_pcie);
+	if (ret) {
+		dev_err(dev, "Failed to request PERST IRQ: %d\n", ret);
+		return ret;
+	}
+
+	return stm32_add_pcie_ep(stm32_pcie, pdev);
+}
+
+static int stm32_pcie_remove(struct platform_device *pdev)
+{
+	struct stm32_pcie *stm32_pcie = platform_get_drvdata(pdev);
+	struct dw_pcie_ep *ep = &stm32_pcie->pci->ep;
+
+	disable_irq(stm32_pcie->perst_irq);
+
+	dw_pcie_ep_exit(ep);
+
+	stm32_pcie_disable_resources(stm32_pcie);
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver stm32_pcie_ep_driver = {
+	.probe = stm32_pcie_probe,
+	.remove	= stm32_pcie_remove,
+	.driver = {
+		.name = "stm32-ep-pcie",
+		.of_match_table = stm32_pcie_ep_of_match,
+	},
+};
+
+module_platform_driver(stm32_pcie_ep_driver);
+MODULE_DESCRIPTION("STM32MP25 PCIe Endpoint Controller driver");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(of, stm32_pcie_ep_of_match);
diff --git a/drivers/pci/controller/dwc/pcie-stm32.c b/drivers/pci/controller/dwc/pcie-stm32.c
new file mode 100644
index 000000000..51c9b922e
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-stm32.c
@@ -0,0 +1,590 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ST PCIe driver for STM32-MP25 SoC
+ *
+ * Copyright (C) 2023 ST Microelectronics - All Rights Reserved
+ * Author: Christian Bruel <christian.bruel@foss.st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/phy/phy.h>
+#include <linux/msi.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include "pcie-designware.h"
+#include "pcie-stm32.h"
+
+struct stm32_pcie {
+	struct dw_pcie *pci;
+	struct regmap *regmap;
+	struct reset_control *rst;
+	struct phy *phy;
+	struct clk *clk;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *wake_gpio;
+	unsigned int wake_irq;
+	int aer_irq;
+	int pme_irq;
+	u32 max_payload;
+	bool limit_downstream_mrrs;
+};
+
+static const struct of_device_id stm32_pcie_of_match[] = {
+	{ .compatible = "st,stm32mp25-pcie-rc" },
+	{},
+};
+
+static int stm32_pcie_set_max_payload(struct dw_pcie *pci, int mps)
+{
+	int ret;
+	struct device *dev = pci->dev;
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	if (mps != 128 && mps != 256) {
+		dev_err(dev, "Unexpected payload size %d\n", mps);
+		return -EINVAL;
+	}
+
+	ret = pcie_set_mps(pdev, mps);
+	if (ret)
+		dev_err(dev, "failed to set mps %d, error %d\n", mps, ret);
+
+	return ret;
+}
+
+static int stm32_pcie_host_init(struct dw_pcie_rp *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+
+	if (stm32_pcie->max_payload)
+		return stm32_pcie_set_max_payload(pci, stm32_pcie->max_payload);
+
+	return 0;
+}
+
+static int stm32_pcie_start_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	u32 ret;
+
+	if (stm32_pcie->reset_gpio) {
+		/* Make sure PERST# is asserted. */
+		gpiod_set_value(stm32_pcie->reset_gpio, 1);
+
+		/* Deassert PERST# after 100us */
+		usleep_range(100, 200);
+		gpiod_set_value(stm32_pcie->reset_gpio, 0);
+	}
+
+	ret = regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+				 STM32MP25_PCIECR_LTSSM_EN,
+				 STM32MP25_PCIECR_LTSSM_EN);
+
+	/*
+	 * PCIe specification states that you should not issue any config
+	 * requests until 100ms after asserting reset, so we enforce that here
+	 */
+	if (stm32_pcie->reset_gpio)
+		msleep(100);
+
+	return ret;
+}
+
+static void stm32_pcie_stop_link(struct dw_pcie *pci)
+{
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+
+	regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR, STM32MP25_PCIECR_LTSSM_EN, 0);
+
+	/* Assert PERST# */
+	if (stm32_pcie->reset_gpio)
+		gpiod_set_value(stm32_pcie->reset_gpio, 1);
+}
+
+static int stm32_pcie_suspend(struct device *dev)
+{
+	struct stm32_pcie *stm32_pcie = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		enable_irq_wake(stm32_pcie->wake_irq);
+
+	return 0;
+}
+
+static int stm32_pcie_resume(struct device *dev)
+{
+	struct stm32_pcie *stm32_pcie = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(stm32_pcie->wake_irq);
+
+	return 0;
+}
+
+static int stm32_pcie_suspend_noirq(struct device *dev)
+{
+	struct stm32_pcie *stm32_pcie = dev_get_drvdata(dev);
+
+	stm32_pcie_stop_link(stm32_pcie->pci);
+	clk_disable_unprepare(stm32_pcie->clk);
+
+	if (!device_may_wakeup(dev) && !device_wakeup_path(dev))
+		phy_exit(stm32_pcie->phy);
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int stm32_pcie_resume_noirq(struct device *dev)
+{
+	struct stm32_pcie *stm32_pcie = dev_get_drvdata(dev);
+	struct dw_pcie *pci = stm32_pcie->pci;
+	struct dw_pcie_rp *pp = &pci->pp;
+	int ret;
+
+	/* init_state was set in pinctrl_bind_pins() before probe */
+	if (!IS_ERR(dev->pins->init_state))
+		ret = pinctrl_select_state(dev->pins->p, dev->pins->init_state);
+	else
+		ret = pinctrl_pm_select_default_state(dev);
+
+	if (ret) {
+		dev_err(dev, "Failed to activate pinctrl pm state: %d\n", ret);
+		return ret;
+	}
+
+	if (!device_may_wakeup(dev) && !device_wakeup_path(dev)) {
+		ret = phy_init(stm32_pcie->phy);
+		if (ret) {
+			pinctrl_pm_select_default_state(dev);
+			return ret;
+		}
+	}
+
+	ret = clk_prepare_enable(stm32_pcie->clk);
+	if (ret)
+		goto clk_err;
+
+	ret = stm32_pcie_host_init(pp);
+	if (ret)
+		goto host_err;
+
+	ret = dw_pcie_setup_rc(pp);
+	if (ret)
+		goto pcie_err;
+
+	ret = stm32_pcie_start_link(stm32_pcie->pci);
+	if (ret)
+		goto pcie_err;
+
+	/* Ignore errors, the link may come up later */
+	dw_pcie_wait_for_link(stm32_pcie->pci);
+
+	pinctrl_pm_select_default_state(dev);
+
+	return 0;
+
+pcie_err:
+	dw_pcie_host_deinit(pp);
+host_err:
+	clk_disable_unprepare(stm32_pcie->clk);
+clk_err:
+	phy_exit(stm32_pcie->phy);
+	pinctrl_pm_select_default_state(dev);
+
+	return ret;
+}
+
+static const struct dev_pm_ops stm32_pcie_pm_ops = {
+	NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_pcie_suspend_noirq,
+				  stm32_pcie_resume_noirq)
+	SYSTEM_SLEEP_PM_OPS(stm32_pcie_suspend, stm32_pcie_resume)
+};
+
+static const struct dw_pcie_host_ops stm32_pcie_host_ops = {
+	.host_init = stm32_pcie_host_init
+};
+
+static const struct dw_pcie_ops dw_pcie_ops = {
+	.start_link = stm32_pcie_start_link,
+	.stop_link = stm32_pcie_stop_link
+};
+
+/*
+ * PME/AER platform irq in this driver only re-initialises the platform IRQ glue logic.
+ * The handling is done by the generic pci drivers (trough platform IRQ hook), through shared IRQ
+ */
+static irqreturn_t stm32_pcie_pme_msi_irq_handler(int irq, void *priv)
+{
+	struct stm32_pcie *stm32_pcie = priv;
+
+	regmap_write(stm32_pcie->regmap, SYSCFG_PCIEPMEMSICR, 1);
+	regmap_write(stm32_pcie->regmap, SYSCFG_PCIEPMEMSICR, 0);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stm32_pcie_aer_msi_irq_handler(int irq, void *priv)
+{
+	struct stm32_pcie *stm32_pcie = priv;
+
+	regmap_write(stm32_pcie->regmap, SYSCFG_PCIEAERRCMSICR, 1);
+	regmap_write(stm32_pcie->regmap, SYSCFG_PCIEAERRCMSICR, 0);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stm32_pcie_wake_irq_handler(int irq, void *priv)
+{
+	struct stm32_pcie *stm32_pcie = priv;
+	struct device *dev = stm32_pcie->pci->dev;
+
+	dev_dbg(dev, "PCIE host wakeup by EP");
+
+	/* Notify PM core we are wakeup source */
+	pm_wakeup_event(dev, 0);
+	pm_system_wakeup();
+
+	return IRQ_HANDLED;
+}
+
+static int stm32_pcie_port_irqs(struct pci_dev *pci_dev, u32 *pme, u32 *aer, u32 *dpc)
+{
+	struct dw_pcie_rp *pp = pci_dev->bus->sysdata;
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct stm32_pcie *stm32_pcie = to_stm32_pcie(pci);
+	int nirqs = 0;
+
+	if (aer && stm32_pcie->aer_irq)
+		nirqs++;
+	if (pme && stm32_pcie->pme_irq)
+		nirqs++;
+
+	nirqs = pci_alloc_irq_vectors(pci_dev, nirqs, nirqs, PCI_IRQ_MSI);
+	if (nirqs < 0)
+		return nirqs;
+
+	if (aer && stm32_pcie->aer_irq)
+		*aer = stm32_pcie->aer_irq;
+	if (pme && stm32_pcie->pme_irq)
+		*pme = stm32_pcie->pme_irq;
+
+	return 0;
+}
+
+static int stm32_add_pcie_port(struct stm32_pcie *stm32_pcie,
+			       struct platform_device *pdev)
+{
+	struct dw_pcie *pci = stm32_pcie->pci;
+	struct device *dev = pci->dev;
+	struct dw_pcie_rp *pp = &pci->pp;
+	int ret;
+
+	/* Use generic AER driver if we can register the port_drv */
+	if (pci_aer_available()) {
+		stm32_pcie->aer_irq = platform_get_irq_byname_optional(pdev, "aer_msi");
+		if (stm32_pcie->aer_irq < 0) {
+			if (stm32_pcie->aer_irq != -ENXIO)
+				return dev_err_probe(dev, stm32_pcie->aer_irq,
+						     "failed to get AER IRQ\n");
+			stm32_pcie->aer_irq = 0;
+		}
+
+		if (stm32_pcie->aer_irq) {
+			ret = devm_request_irq(dev, stm32_pcie->aer_irq,
+					       stm32_pcie_aer_msi_irq_handler,
+					       IRQF_SHARED, "stm32-aer-msi", stm32_pcie);
+			if (ret < 0) {
+				dev_err(dev, "failed to request AER MSI IRQ %d\n",
+					stm32_pcie->aer_irq);
+				return ret;
+			}
+		}
+	}
+
+	stm32_pcie->pme_irq = platform_get_irq_byname_optional(pdev, "pme_msi");
+	if (stm32_pcie->pme_irq < 0) {
+		if (stm32_pcie->pme_irq != -ENXIO)
+			return dev_err_probe(dev, stm32_pcie->pme_irq,
+					     "failed to get PME MSI IRQ\n");
+		stm32_pcie->pme_irq = 0;
+	}
+
+	if (stm32_pcie->pme_irq) {
+		ret = devm_request_irq(dev, stm32_pcie->pme_irq,
+				       stm32_pcie_pme_msi_irq_handler,
+				       IRQF_SHARED, "stm32-pme-msi", stm32_pcie);
+		if (ret < 0) {
+			dev_err(dev, "failed to request PME MSI IRQ %d\n",
+				stm32_pcie->pme_irq);
+			return ret;
+		}
+	}
+
+	/* Register AER/PME pordrv hook */
+	if (stm32_pcie->pme_irq || stm32_pcie->aer_irq)
+		pcie_port_irqs_hook = stm32_pcie_port_irqs;
+
+	ret = phy_set_mode(stm32_pcie->phy, PHY_MODE_PCIE);
+	if (ret)
+		return ret;
+
+	ret = phy_init(stm32_pcie->phy);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(stm32_pcie->regmap, SYSCFG_PCIECR,
+				 STM32MP25_PCIECR_TYPE_MASK, STM32MP25_PCIECR_RC);
+	if (ret)
+		goto phy_disable;
+
+	ret = reset_control_reset(stm32_pcie->rst);
+	if (ret) {
+		dev_err(dev, "Core reset failed %d\n", ret);
+		goto phy_disable;
+	}
+
+	ret = clk_prepare_enable(stm32_pcie->clk);
+	if (ret) {
+		dev_err(dev, "Core clock enable failed %d\n", ret);
+		goto phy_disable;
+	}
+
+	pp->ops = &stm32_pcie_host_ops;
+	ret = dw_pcie_host_init(pp);
+	if (ret) {
+		dev_err(dev, "failed to initialize host: %d\n", ret);
+		clk_disable_unprepare(stm32_pcie->clk);
+		goto phy_disable;
+	}
+
+	return 0;
+
+phy_disable:
+	phy_exit(stm32_pcie->phy);
+
+	return ret;
+}
+
+static int stm32_pcie_probe(struct platform_device *pdev)
+{
+	struct stm32_pcie *stm32_pcie;
+	struct dw_pcie *dw;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	stm32_pcie = devm_kzalloc(dev, sizeof(*stm32_pcie), GFP_KERNEL);
+	if (!stm32_pcie)
+		return -ENOMEM;
+
+	dw = devm_kzalloc(dev, sizeof(*dw), GFP_KERNEL);
+	if (!dw)
+		return -ENOMEM;
+	stm32_pcie->pci = dw;
+
+	dw->dev = dev;
+	dw->ops = &dw_pcie_ops;
+
+	/* regmap registers for PCIe IP configuration */
+	stm32_pcie->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(stm32_pcie->regmap))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->regmap),
+				     "No syscfg phandle specified\n");
+
+	stm32_pcie->phy = devm_phy_get(dev, "pcie-phy");
+	if (IS_ERR(stm32_pcie->phy))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->phy),
+				     "failed to get pcie-phy\n");
+
+	stm32_pcie->clk = devm_clk_get(dev, "core");
+	if (IS_ERR(stm32_pcie->clk))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->clk),
+				     "Failed to get PCIe clock source\n");
+
+	stm32_pcie->rst = devm_reset_control_get(dev, "pcie");
+	if (IS_ERR(stm32_pcie->rst))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->rst),
+				     "Failed to get PCIe reset\n");
+
+	/* Optionally limit payload */
+	ret = of_property_read_u32(np, "max-payload-size", &stm32_pcie->max_payload);
+	if (ret && ret != -EINVAL)
+		return dev_err_probe(dev, ret, "Error reading max-payload value\n");
+
+	if (of_property_read_bool(np, "st,limit_mrrs"))
+		stm32_pcie->limit_downstream_mrrs = true;
+
+	stm32_pcie->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(stm32_pcie->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(stm32_pcie->reset_gpio),
+				     "Failed to get reset GPIO\n");
+
+	platform_set_drvdata(pdev, stm32_pcie);
+
+	if (device_property_read_bool(dev, "wakeup-source")) {
+		stm32_pcie->wake_gpio = devm_gpiod_get_optional(dev, "wake", GPIOD_IN);
+		if (IS_ERR(stm32_pcie->wake_gpio))
+			return dev_err_probe(dev, PTR_ERR(stm32_pcie->wake_gpio),
+					     "Failed to get wake GPIO\n");
+	}
+
+	if (stm32_pcie->wake_gpio) {
+		stm32_pcie->wake_irq = gpiod_to_irq(stm32_pcie->wake_gpio);
+
+		ret = devm_request_threaded_irq(&pdev->dev, stm32_pcie->wake_irq, NULL,
+						stm32_pcie_wake_irq_handler,
+						IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+						"wake_irq", stm32_pcie);
+
+		if (ret)
+			return dev_err_probe(dev, ret, "Failed to request WAKE IRQ: %d\n", ret);
+	}
+
+	ret = devm_pm_runtime_enable(dev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable pm runtime %d\n", ret);
+		return ret;
+	}
+
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0) {
+		dev_err(dev, "pm runtime resume failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = stm32_add_pcie_port(stm32_pcie, pdev);
+	if (ret)  {
+		pm_runtime_put_sync(&pdev->dev);
+		return ret;
+	}
+
+	if (stm32_pcie->wake_gpio)
+		device_set_wakeup_capable(dev, true);
+
+	return 0;
+}
+
+static int stm32_pcie_remove(struct platform_device *pdev)
+{
+	struct stm32_pcie *stm32_pcie = platform_get_drvdata(pdev);
+	struct dw_pcie_rp *pp = &stm32_pcie->pci->pp;
+
+	if (stm32_pcie->wake_gpio)
+		device_init_wakeup(&pdev->dev, false);
+
+	dw_pcie_host_deinit(pp);
+	clk_disable_unprepare(stm32_pcie->clk);
+	pcie_port_irqs_hook = NULL;
+
+	phy_exit(stm32_pcie->phy);
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver stm32_pcie_driver = {
+	.probe = stm32_pcie_probe,
+	.remove	= stm32_pcie_remove,
+	.driver = {
+		.name = "stm32-pcie",
+		.of_match_table = stm32_pcie_of_match,
+		.pm		= &stm32_pcie_pm_ops,
+	},
+};
+
+static bool is_stm32_pcie_driver(struct device *dev)
+{
+	/* PCI bridge */
+	dev = get_device(dev);
+
+	/* Platform driver */
+	dev = get_device(dev->parent);
+
+	return (dev->driver == &stm32_pcie_driver.driver);
+}
+
+static bool apply_mrrs_quirk(struct pci_dev *root_port)
+{
+	struct dw_pcie_rp *pp;
+	struct dw_pcie *dw_pci;
+	struct stm32_pcie *stm32_pcie;
+
+	if (WARN_ON(!root_port) || !is_stm32_pcie_driver(root_port->dev.parent))
+		return false;
+
+	pp = root_port->bus->sysdata;
+	dw_pci = to_dw_pcie_from_pp(pp);
+	stm32_pcie = to_stm32_pcie(dw_pci);
+
+	if (!stm32_pcie->limit_downstream_mrrs)
+		return false;
+
+	return true;
+}
+
+static void quirk_stm32_pcie_limit_mrrs(struct pci_dev *pci)
+{
+	struct pci_dev *root_port;
+	struct pci_bus *bus = pci->bus;
+	int readrq;
+	int mps;
+
+	if (pci_is_root_bus(bus))
+		return;
+
+	root_port = pcie_find_root_port(pci);
+
+	if (!apply_mrrs_quirk(root_port))
+		return;
+
+	mps = pcie_get_mps(root_port);
+
+	/*
+	 * STM32 PCI controller has a h/w performance limitation on the AXI DDR requests.
+	 * Limit the maximum read request size to 256B on all downstream devices.
+	 */
+	readrq = pcie_get_readrq(pci);
+	if (readrq > 256) {
+		int mrrs = min(mps, 256);
+
+		pcie_set_readrq(pci, mrrs);
+
+		pci_info(pci, "Max Read Rq set to %4d (was %4d)\n", mrrs, readrq);
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID,
+			 quirk_stm32_pcie_limit_mrrs);
+
+static int stm32_dma_limit(struct pci_dev *pdev, void *data)
+{
+	dev_dbg(&pdev->dev, "set bus_dma_limit");
+
+	pdev->dev.bus_dma_limit = DMA_BIT_MASK(32);
+
+	return 0;
+}
+
+static void quirk_stm32_dma_mask(struct pci_dev *pci)
+{
+	struct pci_dev *root_port;
+
+	root_port = pcie_find_root_port(pci);
+
+	if (root_port && is_stm32_pcie_driver(root_port->dev.parent))
+		pci_walk_bus(pci->bus, stm32_dma_limit, NULL);
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SYNOPSYS, 0x0550, quirk_stm32_dma_mask);
+
+module_platform_driver(stm32_pcie_driver);
+MODULE_DESCRIPTION("STM32MP25 PCIe Controller driver");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(of, stm32_pcie_of_match);
diff --git a/drivers/pci/controller/dwc/pcie-stm32.h b/drivers/pci/controller/dwc/pcie-stm32.h
new file mode 100644
index 000000000..f23e931f9
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-stm32.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * ST PCIe driver definitions for STM32-MP25 SoC
+ *
+ * Copyright (C) 2023 ST Microelectronics - All Rights Reserved
+ * Author: Christian Bruel <christian.bruel@foss.st.com>
+ */
+
+#define to_stm32_pcie(x)	dev_get_drvdata((x)->dev)
+
+#define STM32MP25_PCIECR_TYPE_MASK	GENMASK(11, 8)
+#define STM32MP25_PCIECR_EP		0
+#define STM32MP25_PCIECR_RC		BIT(10)
+#define STM32MP25_PCIECR_REQ_RETRY_EN	BIT(3)
+#define STM32MP25_PCIECR_LTSSM_EN	BIT(2)
+
+#define SYSCFG_PCIECR			0x6000
+#define SYSCFG_PCIEPMEMSICR		0x6004
+#define SYSCFG_PCIEAERRCMSICR		0x6008
+#define SYSCFG_PCIESR1			0x6100
+#define SYSCFG_PCIESR2			0x6104
+
+#define PCIE_CAP_MAX_PAYLOAD_SIZE(x)	((x) << 5)
+#define PCIE_CAP_MAX_READ_REQ_SIZE(x)	((x) << 12)
diff --git a/drivers/pci/endpoint/functions/pci-epf-test.c b/drivers/pci/endpoint/functions/pci-epf-test.c
index 2e8a4de2a..0cd96ce0b 100644
--- a/drivers/pci/endpoint/functions/pci-epf-test.c
+++ b/drivers/pci/endpoint/functions/pci-epf-test.c
@@ -959,6 +959,7 @@ static int pci_epf_test_bind(struct pci_epf *epf)
 	struct pci_epc *epc = epf->epc;
 	bool linkup_notifier = false;
 	bool core_init_notifier = false;
+	bool force_core_init = false;
 
 	if (WARN_ON_ONCE(!epc))
 		return -EINVAL;
@@ -971,6 +972,7 @@ static int pci_epf_test_bind(struct pci_epf *epf)
 
 	linkup_notifier = epc_features->linkup_notifier;
 	core_init_notifier = epc_features->core_init_notifier;
+	force_core_init = epc_features->force_core_init;
 	test_reg_bar = pci_epc_get_first_free_bar(epc_features);
 	if (test_reg_bar < 0)
 		return -EINVAL;
@@ -983,7 +985,7 @@ static int pci_epf_test_bind(struct pci_epf *epf)
 	if (ret)
 		return ret;
 
-	if (!core_init_notifier) {
+	if (!core_init_notifier || force_core_init) {
 		ret = pci_epf_test_core_init(epf);
 		if (ret)
 			return ret;
diff --git a/drivers/pci/pcie/aer.c b/drivers/pci/pcie/aer.c
index 5426f450c..825a4d49c 100644
--- a/drivers/pci/pcie/aer.c
+++ b/drivers/pci/pcie/aer.c
@@ -118,6 +118,7 @@ bool pci_aer_available(void)
 {
 	return !pcie_aer_disable && pci_msi_enabled();
 }
+EXPORT_SYMBOL_GPL(pci_aer_available);
 
 #ifdef CONFIG_PCIE_ECRC
 
diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 1ac7fec47..be5e8b5ca 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -39,10 +39,10 @@ static void release_pcie_device(struct device *dev)
 
 /*
  * Fill in *pme, *aer, *dpc with the relevant Interrupt Message Numbers if
- * services are enabled in "mask".  Return the number of MSI/MSI-X vectors
+ * services are enabled".  Return the number of MSI/MSI-X vectors
  * required to accommodate the largest Message Number.
  */
-static int pcie_message_numbers(struct pci_dev *dev, int mask,
+static int pcie_message_numbers(struct pci_dev *dev,
 				u32 *pme, u32 *aer, u32 *dpc)
 {
 	u32 nvec = 0, pos;
@@ -55,15 +55,14 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
 	 * 7.8.2, 7.10.10, 7.31.2.
 	 */
 
-	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP |
-		    PCIE_PORT_SERVICE_BWNOTIF)) {
+	if (pme) {
 		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
 		*pme = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
 		nvec = *pme + 1;
 	}
 
 #ifdef CONFIG_PCIEAER
-	if (mask & PCIE_PORT_SERVICE_AER) {
+	if (aer) {
 		u32 reg32;
 
 		pos = dev->aer_cap;
@@ -76,7 +75,7 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
 	}
 #endif
 
-	if (mask & PCIE_PORT_SERVICE_DPC) {
+	if (dpc) {
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
 		if (pos) {
 			pci_read_config_word(dev, pos + PCI_EXP_DPC_CAP,
@@ -90,18 +89,15 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
 }
 
 /**
- * pcie_port_enable_irq_vec - try to set up MSI-X or MSI as interrupt mode
+ * pcie_port_irqs - try to set up MSI-X or MSI as interrupt mode
  * for given port
- * @dev: PCI Express port to handle
- * @irqs: Array of interrupt vectors to populate
- * @mask: Bitmask of port capabilities returned by get_port_device_capability()
  *
+
  * Return value: 0 on success, error code on failure
  */
-static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
+static int pcie_port_irqs(struct pci_dev *dev, u32 *pme, u32 *aer, u32 *dpc)
 {
-	int nr_entries, nvec, pcie_irq;
-	u32 pme = 0, aer = 0, dpc = 0;
+	int nr_entries, nvec;
 
 	/* Allocate the maximum possible number of MSI/MSI-X vectors */
 	nr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSI_ENTRIES,
@@ -110,7 +106,7 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 		return nr_entries;
 
 	/* See how many and which Interrupt Message Numbers we actually use */
-	nvec = pcie_message_numbers(dev, mask, &pme, &aer, &dpc);
+	nvec = pcie_message_numbers(dev, pme, aer, dpc);
 	if (nvec > nr_entries) {
 		pci_free_irq_vectors(dev);
 		return -EIO;
@@ -136,20 +132,72 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 			return nr_entries;
 	}
 
-	/* PME, hotplug and bandwidth notification share an MSI/MSI-X vector */
+	if (aer)
+		*aer = pci_irq_vector(dev, *aer);
+	if (pme)
+		*pme = pci_irq_vector(dev, *pme);
+	if (dpc)
+		*dpc = pci_irq_vector(dev, *dpc);
+
+	return 0;
+}
+
+/*
+ * If non-NULL, this gets called instead of pcie_port_irqs to use
+ * plaform irqs instead of MSI-X or MSI.
+ */
+int (*pcie_port_irqs_hook)(struct pci_dev *, u32 *, u32 *, u32 *);
+EXPORT_SYMBOL(pcie_port_irqs_hook);
+
+/**
+ * pcie_port_enable_irqs - Get interrupt service irqs for given port
+ * @dev: PCI Express port to handle
+ * @irqs: Array of interrupt vectors to populate
+ * @mask: Bitmask of port capabilities returned by get_port_device_capability()
+ *
+ * Return value: 0 on success, error code on failure
+ */
+static int pcie_port_enable_irqs(struct pci_dev *dev, int *irqs, int mask)
+{
+	u32 pme = 0, aer = 0, dpc = 0;
+	u32 *ppme = NULL, *paer = NULL, *pdpc = NULL;
+	int ret;
+
 	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP |
 		    PCIE_PORT_SERVICE_BWNOTIF)) {
-		pcie_irq = pci_irq_vector(dev, pme);
-		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pcie_irq;
-		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pcie_irq;
-		irqs[PCIE_PORT_SERVICE_BWNOTIF_SHIFT] = pcie_irq;
+		ppme = &pme;
 	}
-
+#ifdef CONFIG_PCIEAER
 	if (mask & PCIE_PORT_SERVICE_AER)
-		irqs[PCIE_PORT_SERVICE_AER_SHIFT] = pci_irq_vector(dev, aer);
-
+		paer = &aer;
+#endif
 	if (mask & PCIE_PORT_SERVICE_DPC)
-		irqs[PCIE_PORT_SERVICE_DPC_SHIFT] = pci_irq_vector(dev, dpc);
+		pdpc = &dpc;
+
+	/*
+	 *  Try to use MSI-X or MSI if supported.
+	 *  if the platform doesn't have other interrupt mapping.ppp
+	 */
+	if (pcie_port_irqs_hook)
+		ret = pcie_port_irqs_hook(dev, ppme, paer, pdpc);
+	else
+		ret = pcie_port_irqs(dev, ppme, paer, pdpc);
+
+	if (ret)
+		return ret;
+
+	/* PME, hotplug and bandwidth notification share an MSI/MSI-X vector */
+	if (pme) {
+		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pme;
+		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pme;
+		irqs[PCIE_PORT_SERVICE_BWNOTIF_SHIFT] = pme;
+	}
+
+	if (aer)
+		irqs[PCIE_PORT_SERVICE_AER_SHIFT] = aer;
+
+	if (dpc)
+		irqs[PCIE_PORT_SERVICE_DPC_SHIFT] = dpc;
 
 	return 0;
 }
@@ -178,7 +226,7 @@ static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 		goto legacy_irq;
 
 	/* Try to use MSI-X or MSI if supported */
-	if (pcie_port_enable_irq_vec(dev, irqs, mask) == 0)
+	if (pcie_port_enable_irqs(dev, irqs, mask) == 0)
 		return 0;
 
 legacy_irq:
diff --git a/drivers/perf/Kconfig b/drivers/perf/Kconfig
index 341010f20..2c908b014 100644
--- a/drivers/perf/Kconfig
+++ b/drivers/perf/Kconfig
@@ -137,6 +137,13 @@ config QCOM_L3_PMU
 	   Adds the L3 cache PMU into the perf events subsystem for
 	   monitoring L3 cache events.
 
+config STM32_DDR_PMU
+	tristate "STM32 DDR PMU"
+	depends on ARCH_STM32
+	default m
+	help
+	  Support for STM32 DDR performance monitor (DDRPERFM).
+
 config THUNDERX2_PMU
 	tristate "Cavium ThunderX2 SoC PMU UNCORE"
 	depends on ARCH_THUNDER2 || COMPILE_TEST
diff --git a/drivers/perf/Makefile b/drivers/perf/Makefile
index 050d04ee1..595e8b488 100644
--- a/drivers/perf/Makefile
+++ b/drivers/perf/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_QCOM_L3_PMU) += qcom_l3_pmu.o
 obj-$(CONFIG_RISCV_PMU) += riscv_pmu.o
 obj-$(CONFIG_RISCV_PMU_LEGACY) += riscv_pmu_legacy.o
 obj-$(CONFIG_RISCV_PMU_SBI) += riscv_pmu_sbi.o
+obj-$(CONFIG_STM32_DDR_PMU) += stm32_ddr_pmu.o
 obj-$(CONFIG_THUNDERX2_PMU) += thunderx2_pmu.o
 obj-$(CONFIG_XGENE_PMU) += xgene_pmu.o
 obj-$(CONFIG_ARM_SPE_PMU) += arm_spe_pmu.o
diff --git a/drivers/perf/stm32_ddr_pmu.c b/drivers/perf/stm32_ddr_pmu.c
new file mode 100644
index 000000000..c0082109a
--- /dev/null
+++ b/drivers/perf/stm32_ddr_pmu.c
@@ -0,0 +1,439 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This file is the STM32 DDR performance monitor (DDRPERFM) driver
+ *
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ * Author: Gerald Baeza <gerald.baeza@st.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/perf_event.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+/*
+ * The PMU is able to freeze all counters and generate an interrupt when there
+ * is a counter overflow. But, relying on this means that we lose all the
+ * events that occur between the freeze and the interrupt handler execution.
+ * So we use a polling mechanism to avoid this lose of information.
+ * The fastest counter can overflow in ~8s @533MHz (that is the maximum DDR
+ * frequency supported on STM32MP157), so we poll in 4s intervals to ensure
+ * we don't reach this limit.
+ */
+#define POLL_MS		4000
+
+#define DDRPERFM_CTL	0x000
+#define DDRPERFM_CFG	0x004
+#define DDRPERFM_STATUS 0x008
+#define DDRPERFM_CCR	0x00C
+#define DDRPERFM_TCNT	0x020
+#define DDRPERFM_CNT(X)	(0x030 + 8 * (X))
+#define DDRPERFM_VER	0x3F4
+#define DDRPERFM_ID	0x3F8
+
+#define CTL_START	0x00000001
+#define CTL_STOP	0x00000002
+#define CCR_CLEAR_ALL	0x8000000F
+
+enum {
+	READ_CNT,
+	WRITE_CNT,
+	ACTIVATE_CNT,
+	IDLE_CNT,
+	TIME_CNT,
+	PMU_NR_COUNTERS
+};
+
+struct stm32_ddr_pmu {
+	struct pmu pmu;
+	void __iomem *membase;
+	struct device *dev;
+	struct clk *clk;
+	struct hrtimer hrtimer;
+	cpumask_t pmu_cpu;
+	ktime_t poll_period;
+	struct perf_event *events[PMU_NR_COUNTERS];
+	u64 events_cnt[PMU_NR_COUNTERS];
+};
+
+static inline struct stm32_ddr_pmu *pmu_to_stm32_ddr_pmu(struct pmu *p)
+{
+	return container_of(p, struct stm32_ddr_pmu, pmu);
+}
+
+static inline struct stm32_ddr_pmu *hrtimer_to_stm32_ddr_pmu(struct hrtimer *h)
+{
+	return container_of(h, struct stm32_ddr_pmu, hrtimer);
+}
+
+static void stm32_ddr_pmu_event_configure(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	u32 val;
+
+	writel_relaxed(CTL_STOP, stm32_ddr_pmu->membase + DDRPERFM_CTL);
+
+	if (config_base < TIME_CNT) {
+		val = readl_relaxed(stm32_ddr_pmu->membase + DDRPERFM_CFG);
+		val |= BIT(config_base);
+		writel_relaxed(val, stm32_ddr_pmu->membase + DDRPERFM_CFG);
+	}
+}
+
+static void stm32_ddr_pmu_event_update(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	struct hw_perf_event *hw = &event->hw;
+	u64 prev_count, new_count, mask;
+	u32 val, offset, bit;
+
+	writel_relaxed(CTL_STOP, stm32_ddr_pmu->membase + DDRPERFM_CTL);
+
+	if (config_base == TIME_CNT) {
+		offset = DDRPERFM_TCNT;
+		bit = BIT(31);
+	} else {
+		offset = DDRPERFM_CNT(config_base);
+		bit = BIT(config_base);
+	}
+	val = readl_relaxed(stm32_ddr_pmu->membase + DDRPERFM_STATUS);
+	if (val & bit)
+		dev_warn(stm32_ddr_pmu->dev, "hardware counter overflow\n");
+	val = readl_relaxed(stm32_ddr_pmu->membase + offset);
+	writel_relaxed(bit, stm32_ddr_pmu->membase + DDRPERFM_CCR);
+	writel_relaxed(CTL_START, stm32_ddr_pmu->membase + DDRPERFM_CTL);
+
+	do {
+		prev_count = local64_read(&hw->prev_count);
+		new_count = prev_count + val;
+	} while (local64_xchg(&hw->prev_count, new_count) != prev_count);
+
+	mask = GENMASK_ULL(31, 0);
+	local64_add(val & mask, &event->count);
+}
+
+static void stm32_ddr_pmu_event_read(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+
+	hrtimer_start(&stm32_ddr_pmu->hrtimer, stm32_ddr_pmu->poll_period,
+		      HRTIMER_MODE_REL_PINNED);
+
+	stm32_ddr_pmu_event_update(event);
+}
+
+static void stm32_ddr_pmu_event_start(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	struct hw_perf_event *hw = &event->hw;
+
+	if (WARN_ON_ONCE(!(hw->state & PERF_HES_STOPPED)))
+		return;
+
+	if (flags & PERF_EF_RELOAD)
+		WARN_ON_ONCE(!(hw->state & PERF_HES_UPTODATE));
+
+	stm32_ddr_pmu_event_configure(event);
+
+	/* Clear all counters to synchronize them, then start */
+	writel_relaxed(CCR_CLEAR_ALL, stm32_ddr_pmu->membase + DDRPERFM_CCR);
+	writel_relaxed(CTL_START, stm32_ddr_pmu->membase + DDRPERFM_CTL);
+	local64_set(&hw->prev_count, 0);
+	hw->state = 0;
+}
+
+static void stm32_ddr_pmu_event_stop(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	struct hw_perf_event *hw = &event->hw;
+	u32 val, bit;
+
+	if (WARN_ON_ONCE(hw->state & PERF_HES_STOPPED))
+		return;
+
+	writel_relaxed(CTL_STOP, stm32_ddr_pmu->membase + DDRPERFM_CTL);
+	if (config_base == TIME_CNT)
+		bit = BIT(31);
+	else
+		bit = BIT(config_base);
+	writel_relaxed(bit, stm32_ddr_pmu->membase + DDRPERFM_CCR);
+	if (config_base < TIME_CNT) {
+		val = readl_relaxed(stm32_ddr_pmu->membase + DDRPERFM_CFG);
+		val &= ~bit;
+		writel_relaxed(val, stm32_ddr_pmu->membase + DDRPERFM_CFG);
+	}
+
+	hw->state |= PERF_HES_STOPPED;
+
+	if (flags & PERF_EF_UPDATE) {
+		stm32_ddr_pmu_event_update(event);
+		hw->state |= PERF_HES_UPTODATE;
+	}
+}
+
+static int stm32_ddr_pmu_event_add(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	struct hw_perf_event *hw = &event->hw;
+
+	stm32_ddr_pmu->events_cnt[config_base] = 0;
+	stm32_ddr_pmu->events[config_base] = event;
+
+	clk_enable(stm32_ddr_pmu->clk);
+	/*
+	 * Pin the timer, so that the overflows are handled by the chosen
+	 * event->cpu (this is the same one as presented in "cpumask"
+	 * attribute).
+	 */
+	hrtimer_start(&stm32_ddr_pmu->hrtimer, stm32_ddr_pmu->poll_period,
+		      HRTIMER_MODE_REL_PINNED);
+
+	stm32_ddr_pmu_event_configure(event);
+
+	hw->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;
+
+	if (flags & PERF_EF_START)
+		stm32_ddr_pmu_event_start(event, 0);
+
+	return 0;
+}
+
+static void stm32_ddr_pmu_event_del(struct perf_event *event, int flags)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	unsigned long config_base = event->hw.config_base;
+	int i;
+
+	stm32_ddr_pmu_event_stop(event, PERF_EF_UPDATE);
+
+	stm32_ddr_pmu->events_cnt[config_base] += local64_read(&event->count);
+	stm32_ddr_pmu->events[config_base] = NULL;
+
+	for (i = 0; i < PMU_NR_COUNTERS; i++)
+		if (stm32_ddr_pmu->events[i])
+			break;
+
+	if (i == PMU_NR_COUNTERS)
+		hrtimer_cancel(&stm32_ddr_pmu->hrtimer);
+
+	clk_disable(stm32_ddr_pmu->clk);
+}
+
+static int stm32_ddr_pmu_event_init(struct perf_event *event)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = pmu_to_stm32_ddr_pmu(event->pmu);
+	struct hw_perf_event *hw = &event->hw;
+
+	if (event->attr.type != event->pmu->type)
+		return -ENOENT;
+
+	if (event->attr.config >= PMU_NR_COUNTERS)
+		return -ENOENT;
+
+	if (is_sampling_event(event))
+		return -EINVAL;
+
+	if (event->attach_state & PERF_ATTACH_TASK)
+		return -EINVAL;
+
+	if (event->attr.exclude_user   ||
+	    event->attr.exclude_kernel ||
+	    event->attr.exclude_hv     ||
+	    event->attr.exclude_idle   ||
+	    event->attr.exclude_host   ||
+	    event->attr.exclude_guest)
+		return -EINVAL;
+
+	if (event->cpu < 0)
+		return -EINVAL;
+
+	hw->config_base = event->attr.config;
+	event->cpu = cpumask_first(&stm32_ddr_pmu->pmu_cpu);
+
+	return 0;
+}
+
+static enum hrtimer_restart stm32_ddr_pmu_poll(struct hrtimer *hrtimer)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = hrtimer_to_stm32_ddr_pmu(hrtimer);
+	int i;
+
+	for (i = 0; i < PMU_NR_COUNTERS; i++)
+		if (stm32_ddr_pmu->events[i])
+			stm32_ddr_pmu_event_update(stm32_ddr_pmu->events[i]);
+
+	hrtimer_forward_now(hrtimer, stm32_ddr_pmu->poll_period);
+
+	return HRTIMER_RESTART;
+}
+
+static ssize_t stm32_ddr_pmu_sysfs_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct dev_ext_attribute *eattr = container_of(attr, struct dev_ext_attribute, attr);
+	unsigned long cnt_id = (unsigned long)eattr->var;
+
+	return sprintf(buf, "config=%ld\n", cnt_id);
+}
+
+#define STM32_DDR_PMU_ATTR(_name, _func, _config)			\
+	(&((struct dev_ext_attribute[]) {				\
+		{ __ATTR(_name, 0444, _func, NULL), (void *)_config }   \
+	})[0].attr.attr)
+
+#define STM32_DDR_PMU_EVENT_ATTR(_name, _config)		\
+	STM32_DDR_PMU_ATTR(_name, stm32_ddr_pmu_sysfs_show,	\
+			   (unsigned long)_config)
+
+static struct attribute *stm32_ddr_pmu_event_attrs[] = {
+	STM32_DDR_PMU_EVENT_ATTR(read_cnt, READ_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(write_cnt, WRITE_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(activate_cnt, ACTIVATE_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(idle_cnt, IDLE_CNT),
+	STM32_DDR_PMU_EVENT_ATTR(time_cnt, TIME_CNT),
+	NULL
+};
+
+static struct attribute_group stm32_ddr_pmu_event_attrs_group = {
+	.name = "events",
+	.attrs = stm32_ddr_pmu_event_attrs,
+};
+
+static const struct attribute_group *stm32_ddr_pmu_attr_groups[] = {
+	&stm32_ddr_pmu_event_attrs_group,
+	NULL,
+};
+
+static int stm32_ddr_pmu_device_probe(struct platform_device *pdev)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu;
+	struct reset_control *rst;
+	struct resource *res;
+	int i, ret;
+
+	stm32_ddr_pmu = devm_kzalloc(&pdev->dev, sizeof(struct stm32_ddr_pmu),
+				     GFP_KERNEL);
+	if (!stm32_ddr_pmu)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, stm32_ddr_pmu);
+	stm32_ddr_pmu->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	stm32_ddr_pmu->membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(stm32_ddr_pmu->membase)) {
+		dev_err(&pdev->dev, "Unable to get membase\n");
+		return PTR_ERR(stm32_ddr_pmu->membase);
+	}
+
+	stm32_ddr_pmu->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(stm32_ddr_pmu->clk)) {
+		dev_err(&pdev->dev, "unable to get the clock\n");
+		return PTR_ERR(stm32_ddr_pmu->clk);
+	}
+
+	ret = clk_prepare_enable(stm32_ddr_pmu->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to prepare the clock\n");
+		return ret;
+	}
+
+	stm32_ddr_pmu->poll_period = ms_to_ktime(POLL_MS);
+	hrtimer_init(&stm32_ddr_pmu->hrtimer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	stm32_ddr_pmu->hrtimer.function = stm32_ddr_pmu_poll;
+
+	/*
+	 * The PMU is assigned to the cpu0 and there is no need to manage cpu
+	 * hot plug migration because cpu0 is always the first/last active cpu
+	 * during low power transitions.
+	 */
+	cpumask_set_cpu(0, &stm32_ddr_pmu->pmu_cpu);
+
+	for (i = 0; i < PMU_NR_COUNTERS; i++) {
+		stm32_ddr_pmu->events[i] = NULL;
+		stm32_ddr_pmu->events_cnt[i] = 0;
+	}
+
+	stm32_ddr_pmu->pmu = (struct pmu) {
+		.task_ctx_nr = perf_invalid_context,
+		.start = stm32_ddr_pmu_event_start,
+		.stop = stm32_ddr_pmu_event_stop,
+		.add = stm32_ddr_pmu_event_add,
+		.del = stm32_ddr_pmu_event_del,
+		.read = stm32_ddr_pmu_event_read,
+		.event_init = stm32_ddr_pmu_event_init,
+		.attr_groups = stm32_ddr_pmu_attr_groups,
+	};
+	ret = perf_pmu_register(&stm32_ddr_pmu->pmu, "stm32_ddr_pmu", -1);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register the pmu\n");
+		goto err_pmu_register;
+	}
+
+	rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(rst)) {
+		dev_err(&pdev->dev, "unable to get the reset\n");
+		ret = -ENOENT;
+		goto err_get_reset;
+	}
+	reset_control_assert(rst);
+	udelay(2);
+	reset_control_deassert(rst);
+
+	dev_info(&pdev->dev, "probed (DDRPERFM ID=0x%08x VER=0x%08x)\n",
+		 readl_relaxed(stm32_ddr_pmu->membase + DDRPERFM_ID),
+		 readl_relaxed(stm32_ddr_pmu->membase + DDRPERFM_VER));
+
+	clk_disable(stm32_ddr_pmu->clk);
+
+	return 0;
+
+err_get_reset:
+	perf_pmu_unregister(&stm32_ddr_pmu->pmu);
+err_pmu_register:
+	clk_disable_unprepare(stm32_ddr_pmu->clk);
+	return ret;
+}
+
+static int stm32_ddr_pmu_device_remove(struct platform_device *pdev)
+{
+	struct stm32_ddr_pmu *stm32_ddr_pmu = platform_get_drvdata(pdev);
+
+	perf_pmu_unregister(&stm32_ddr_pmu->pmu);
+
+	clk_unprepare(stm32_ddr_pmu->clk);
+
+	return 0;
+}
+
+static const struct of_device_id stm32_ddr_pmu_of_match[] = {
+	{ .compatible = "st,stm32-ddr-pmu" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, stm32_ddr_pmu_of_match);
+
+static struct platform_driver stm32_ddr_pmu_driver = {
+	.driver = {
+		.name	= "stm32-ddr-pmu",
+		.of_match_table = of_match_ptr(stm32_ddr_pmu_of_match),
+	},
+	.probe = stm32_ddr_pmu_device_probe,
+	.remove = stm32_ddr_pmu_device_remove,
+};
+
+module_platform_driver(stm32_ddr_pmu_driver);
+
+MODULE_DESCRIPTION("Perf driver for STM32 DDR performance monitor");
+MODULE_AUTHOR("Gerald Baeza <gerald.baeza@st.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/st/Kconfig b/drivers/phy/st/Kconfig
index 3fc3d0781..3f8169dfc 100644
--- a/drivers/phy/st/Kconfig
+++ b/drivers/phy/st/Kconfig
@@ -33,6 +33,15 @@ config PHY_STIH407_USB
 	  Enable this support to enable the picoPHY device used by USB2
 	  and USB3 controllers on STMicroelectronics STiH407 SoC families.
 
+config PHY_STM32_COMBOPHY
+	tristate "STMicroelectronics ComboPHY driver for STM32 MP25"
+	depends on RESET_CONTROLLER
+	depends on ARCH_STM32 || COMPILE_TEST
+	select GENERIC_PHY
+	help
+	  Enable this to support the ComboPHY device used by USB3 or PCIe
+	  controllers on STMicroelectronics STM32MP25 SoC.
+
 config PHY_STM32_USBPHYC
 	tristate "STMicroelectronics STM32 USB HS PHY Controller driver"
 	depends on ARCH_STM32 || COMPILE_TEST
@@ -47,3 +56,13 @@ config PHY_STM32_USBPHYC
 	  used by an HS USB Host controller, and the second one is shared
 	  between an HS USB OTG controller and an HS USB Host controller,
 	  selected by a USB switch.
+
+config PHY_STM32_USB2PHY
+	tristate "STMicroelectronics STM32 USB2 PHY Controller driver"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on COMMON_CLK
+	select GENERIC_PHY
+	help
+	  Enable this to support the High-Speed USB2 transceivers that are part
+	  of some STMicroelectronics STM32 SoCs. The PHY integrated is from
+	  synopsys, and called FEMTO-PHY
diff --git a/drivers/phy/st/Makefile b/drivers/phy/st/Makefile
index c862dd937..4945df5ed 100644
--- a/drivers/phy/st/Makefile
+++ b/drivers/phy/st/Makefile
@@ -3,4 +3,6 @@ obj-$(CONFIG_PHY_MIPHY28LP) 		+= phy-miphy28lp.o
 obj-$(CONFIG_PHY_ST_SPEAR1310_MIPHY)	+= phy-spear1310-miphy.o
 obj-$(CONFIG_PHY_ST_SPEAR1340_MIPHY)	+= phy-spear1340-miphy.o
 obj-$(CONFIG_PHY_STIH407_USB)		+= phy-stih407-usb.o
+obj-$(CONFIG_PHY_STM32_COMBOPHY)	+= phy-stm32-combophy.o
 obj-$(CONFIG_PHY_STM32_USBPHYC) 	+= phy-stm32-usbphyc.o
+obj-$(CONFIG_PHY_STM32_USB2PHY) 	+= phy-stm32-usb2phy.o
diff --git a/drivers/phy/st/phy-stm32-combophy.c b/drivers/phy/st/phy-stm32-combophy.c
new file mode 100644
index 000000000..7f2566a78
--- /dev/null
+++ b/drivers/phy/st/phy-stm32-combophy.c
@@ -0,0 +1,594 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics ComboPHY STM32MP25 Controller driver.
+ *
+ * Copyright (C) 2022 ST Microelectronics
+ * Author: Christian Bruel <christian.bruel@foss.st.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <dt-bindings/phy/phy.h>
+
+#define SYSCFG_COMBOPHY_CR1 0x4C00
+#define SYSCFG_COMBOPHY_CR2 0x4C04
+#define SYSCFG_COMBOPHY_CR4 0x4C0C
+#define SYSCFG_COMBOPHY_CR5 0x4C10
+#define SYSCFG_COMBOPHY_SR  0x4C14
+#define SYSCFG_PCIEPRGCR    0x6080
+
+/* SYSCFG PCIEPRGCR */
+#define STM32MP25_PCIEPRGCR_EN	  BIT(0)
+#define STM32MP25_PCIEPRG_IMPCTRL_OHM     GENMASK(3, 1)
+#define STM32MP25_PCIEPRG_IMPCTRL_VSWING  GENMASK(5, 4)
+
+/* SYSCFG SYSCFG_COMBOPHY_SR */
+#define STM32MP25_PIPE0_PHYSTATUS BIT(1)
+
+/* SYSCFG CR1 */
+#define SYSCFG_COMBOPHY_CR1_REFUSEPAD BIT(0)
+#define SYSCFG_COMBOPHY_CR1_MPLLMULT GENMASK(7, 1)
+#define SYSCFG_COMBOPHY_CR1_REFCLKSEL GENMASK(16, 8)
+#define SYSCFG_COMBOPHY_CR1_REFCLKDIV2 BIT(17)
+#define SYSCFG_COMBOPHY_CR1_REFSSPEN BIT(18)
+#define SYSCFG_COMBOPHY_CR1_SSCEN BIT(19)
+
+/* SYSCFG CR4 */
+#define SYSCFG_COMBOPHY_CR4_RX0_EQ GENMASK(2, 0)
+
+#define MPLLMULT_19_2 (0x02u << 1)
+#define MPLLMULT_20   (0x7Du << 1)
+#define MPLLMULT_24   (0x68u << 1)
+#define MPLLMULT_25   (0x64u << 1)
+#define MPLLMULT_26   (0x60u << 1)
+#define MPLLMULT_38_4 (0x41u << 1)
+#define MPLLMULT_48   (0x6Cu << 1)
+#define MPLLMULT_50   (0x32u << 1)
+#define MPLLMULT_52   (0x30u << 1)
+#define MPLLMULT_100  (0x19u << 1)
+
+#define REFCLKSEL_0   0
+#define REFCLKSEL_1   (0x108u << 8)
+
+#define REFCLDIV_0    0
+
+/* SYSCFG CR2 */
+#define SYSCFG_COMBOPHY_CR2_MODESEL GENMASK(1, 0)
+#define SYSCFG_COMBOPHY_CR2_ISO_DIS BIT(15)
+
+#define COMBOPHY_MODESEL_PCIE 0
+#define COMBOPHY_MODESEL_USB  3
+
+/* SYSCFG CR5 */
+#define SYSCFG_COMBOPHY_CR5_COMMON_CLOCKS BIT(12)
+
+#define COMBOPHY_SUP_ANA_MPLL_LOOP_CTL 0xC0
+#define COMBOPHY_PROP_CNTRL GENMASK(7, 4)
+
+struct stm32_combophy {
+	struct phy *phy;
+	struct regmap *regmap;
+	struct device *dev;
+	void __iomem *base;
+	struct reset_control *phy_reset;
+	struct clk *phy_clk;
+	struct clk *pad_clk;
+	struct clk *ker_clk;
+	unsigned int type;
+	bool is_init;
+	int irq_wakeup;
+};
+
+struct clk_impedance  {
+	u32 microohm;
+	u32 vswing[4];
+};
+
+/*
+ * lookup table to hold the settings needed for a ref clock frequency
+ * impedance, the offset is used to set the IMP_CTL and DE_EMP bit of the
+ * PRG_IMP_CTRL register
+ */
+static const struct clk_impedance imp_lookup[] = {
+	{ 6090000, { 442000, 564000, 684000, 802000 } },
+	{ 5662000, { 528000, 621000, 712000, 803000 } },
+	{ 5292000, { 491000, 596000, 700000, 802000 } },
+	{ 4968000, { 558000, 640000, 722000, 803000 } },
+	{ 4684000, { 468000, 581000, 692000, 802000 } },
+	{ 4429000, { 554000, 613000, 717000, 803000 } },
+	{ 4204000, { 511000, 609000, 706000, 802000 } },
+	{ 3999000, { 571000, 648000, 726000, 803000 } }
+};
+
+static int stm32_impedance_tune(struct stm32_combophy *combophy)
+{
+	u8 imp_size = ARRAY_SIZE(imp_lookup);
+	u8 vswing_size = ARRAY_SIZE(imp_lookup[0].vswing);
+	u8 imp_of, vswing_of;
+	u32 max_imp = imp_lookup[0].microohm;
+	u32 min_imp = imp_lookup[imp_size - 1].microohm;
+	u32 max_vswing = imp_lookup[imp_size - 1].vswing[vswing_size - 1];
+	u32 min_vswing = imp_lookup[0].vswing[0];
+	u32 val;
+
+	if (!of_property_read_u32(combophy->dev->of_node, "st,output-micro-ohms", &val)) {
+		if (val < min_imp || val > max_imp) {
+			dev_err(combophy->dev, "Invalid value %u for output ohm\n", val);
+			return -EINVAL;
+		}
+
+		for (imp_of = 0 ; imp_of < ARRAY_SIZE(imp_lookup); imp_of++)
+			if (imp_lookup[imp_of].microohm <= val)
+				break;
+
+		dev_dbg(combophy->dev, "Set %u micro-ohms output impedance\n",
+			imp_lookup[imp_of].microohm);
+
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRG_IMPCTRL_OHM,
+				   FIELD_PREP(STM32MP25_PCIEPRG_IMPCTRL_OHM, imp_of));
+	} else {
+		regmap_read(combophy->regmap, SYSCFG_PCIEPRGCR, &val);
+		imp_of = FIELD_GET(STM32MP25_PCIEPRG_IMPCTRL_OHM, val);
+	}
+
+	if (!of_property_read_u32(combophy->dev->of_node, "st,output-vswing-microvolt", &val)) {
+		if (val < min_vswing || val > max_vswing) {
+			dev_err(combophy->dev, "Invalid value %u for output vswing\n", val);
+			return -EINVAL;
+		}
+
+		for (vswing_of = 0 ; vswing_of < ARRAY_SIZE(imp_lookup[imp_of].vswing); vswing_of++)
+			if (imp_lookup[imp_of].vswing[vswing_of] >= val)
+				break;
+
+		dev_dbg(combophy->dev, "Set %u microvolt swing\n",
+			 imp_lookup[imp_of].vswing[vswing_of]);
+
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRG_IMPCTRL_VSWING,
+				   FIELD_PREP(STM32MP25_PCIEPRG_IMPCTRL_VSWING, vswing_of));
+	}
+
+	return 0;
+}
+
+static int stm32_combophy_pll_init(struct stm32_combophy *combophy)
+{
+	int ret;
+	u32 refclksel, pllmult, propcntrl, val;
+	u32 clk_rate;
+
+	if (combophy->pad_clk)
+		clk_rate = clk_get_rate(combophy->pad_clk);
+	else
+		clk_rate = clk_get_rate(combophy->ker_clk);
+
+	reset_control_assert(combophy->phy_reset);
+
+	dev_dbg(combophy->dev, "%s pll init rate %d\n",
+		combophy->pad_clk ? "External" : "Ker", clk_rate);
+
+	/*
+	 * vddcombophy is interconnected with vddcore. Isolation bit should be unset
+	 * before using the ComboPHY.
+	 */
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+			   SYSCFG_COMBOPHY_CR2_ISO_DIS, SYSCFG_COMBOPHY_CR2_ISO_DIS);
+
+	if (combophy->type != PHY_TYPE_PCIE)
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFSSPEN, SYSCFG_COMBOPHY_CR1_REFSSPEN);
+
+	if (combophy->type == PHY_TYPE_PCIE && !combophy->pad_clk)
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRGCR_EN, STM32MP25_PCIEPRGCR_EN);
+
+	if (of_property_read_bool(combophy->dev->of_node, "st,ssc-on")) {
+		dev_dbg(combophy->dev, "Enabling clock with SSC\n");
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_SSCEN, SYSCFG_COMBOPHY_CR1_SSCEN);
+	}
+
+	if (!of_property_read_u32(combophy->dev->of_node, "st,rx_equalizer", &val)) {
+		dev_dbg(combophy->dev, "Set RX equalizer %u\n", val);
+		if (val > SYSCFG_COMBOPHY_CR4_RX0_EQ) {
+			dev_err(combophy->dev, "Invalid value %u for rx0 equalizer\n", val);
+			return -EINVAL;
+		}
+
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR4,
+			   SYSCFG_COMBOPHY_CR4_RX0_EQ, val);
+	}
+
+	if (combophy->type == PHY_TYPE_PCIE) {
+		ret = stm32_impedance_tune(combophy);
+		if (ret) {
+			reset_control_deassert(combophy->phy_reset);
+			goto out;
+		}
+
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFUSEPAD,
+				   combophy->pad_clk ? SYSCFG_COMBOPHY_CR1_REFUSEPAD : 0);
+	}
+
+	switch (clk_rate) {
+	case 100000000:
+		pllmult = MPLLMULT_100;
+		refclksel = REFCLKSEL_0;
+		propcntrl = 0x8u << 4;
+		break;
+	case 19200000:
+		pllmult = MPLLMULT_19_2;
+		refclksel = REFCLKSEL_1;
+		propcntrl = 0x8u << 4;
+		break;
+	case 25000000:
+		pllmult = MPLLMULT_25;
+		refclksel = REFCLKSEL_0;
+		propcntrl = 0xEu << 4;
+		break;
+	case 24000000:
+		pllmult = MPLLMULT_24;
+		refclksel = REFCLKSEL_1;
+		propcntrl = 0xEu << 4;
+		break;
+	case 20000000:
+		pllmult = MPLLMULT_20;
+		refclksel = REFCLKSEL_0;
+		propcntrl = 0xEu << 4;
+		break;
+	default:
+		dev_err(combophy->dev, "Invalid rate 0x%x\n", clk_rate);
+		reset_control_deassert(combophy->phy_reset);
+		ret = -EINVAL;
+		goto out;
+	};
+
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+			   SYSCFG_COMBOPHY_CR1_REFCLKDIV2, REFCLDIV_0);
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+			   SYSCFG_COMBOPHY_CR1_REFCLKSEL, refclksel);
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+			   SYSCFG_COMBOPHY_CR1_MPLLMULT, pllmult);
+
+	/*
+	 * Force elasticity buffer to be tuned for the reference clock as
+	 * the separated clock model is not supported
+	 */
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR5,
+			   SYSCFG_COMBOPHY_CR5_COMMON_CLOCKS, SYSCFG_COMBOPHY_CR5_COMMON_CLOCKS);
+
+	reset_control_deassert(combophy->phy_reset);
+
+	ret = regmap_read_poll_timeout(combophy->regmap, SYSCFG_COMBOPHY_SR, val,
+				       !(val & STM32MP25_PIPE0_PHYSTATUS),
+				       10, 1000);
+	if (ret) {
+		dev_err(combophy->dev, "timeout, cannot lock PLL\n");
+		goto out;
+	}
+
+	if (combophy->type == PHY_TYPE_PCIE) {
+		val = readl_relaxed(combophy->base + COMBOPHY_SUP_ANA_MPLL_LOOP_CTL);
+		val &= ~COMBOPHY_PROP_CNTRL;
+		val |= propcntrl;
+		writel_relaxed(val, combophy->base + COMBOPHY_SUP_ANA_MPLL_LOOP_CTL);
+	}
+
+	return 0;
+
+out:
+	if (combophy->type == PHY_TYPE_PCIE && !combophy->pad_clk)
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRGCR_EN, 0);
+
+	if (combophy->type != PHY_TYPE_PCIE)
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFSSPEN, 0);
+
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+			   SYSCFG_COMBOPHY_CR2_ISO_DIS, 0);
+
+	return ret;
+}
+
+static struct phy *stm32_combophy_xlate(struct device *dev,
+				   struct of_phandle_args *args)
+{
+	struct stm32_combophy *combophy = dev_get_drvdata(dev);
+	unsigned int type;
+
+	if (args->args_count != 1) {
+		dev_err(dev, "invalid number of cells in 'phy' property\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	type = args->args[0];
+	if (type != PHY_TYPE_USB3 && type != PHY_TYPE_PCIE) {
+		dev_err(dev, "unsupported device type: %d\n", type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (combophy->pad_clk && type != PHY_TYPE_PCIE) {
+		dev_err(dev, "Invalid use of clk_pad for USB3 mode\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	combophy->type = type;
+
+	return combophy->phy;
+}
+
+static int stm32_combophy_set_mode(struct stm32_combophy *combophy)
+{
+	int type = combophy->type;
+	u32 val;
+
+	switch (type) {
+	case PHY_TYPE_PCIE:
+		dev_dbg(combophy->dev, "setting PCIe ComboPHY\n");
+		val = COMBOPHY_MODESEL_PCIE;
+		break;
+	case PHY_TYPE_USB3:
+		dev_dbg(combophy->dev, "setting USB3 ComboPHY\n");
+		val = COMBOPHY_MODESEL_USB;
+		break;
+	default:
+		dev_err(combophy->dev, "Invalid PHY mode %d\n", type);
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+				  SYSCFG_COMBOPHY_CR2_MODESEL, val);
+}
+
+static int stm32_combophy_enable_clocks(struct stm32_combophy *combophy)
+{
+	int ret;
+
+	ret = clk_prepare_enable(combophy->phy_clk);
+	if (ret) {
+		dev_err(combophy->dev, "Core clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(combophy->ker_clk);
+	if (ret) {
+		dev_err(combophy->dev, "ker_usb3pcie clock enable failed %d\n", ret);
+		clk_disable_unprepare(combophy->phy_clk);
+		return ret;
+	}
+
+	if (combophy->pad_clk) {
+		ret = clk_prepare_enable(combophy->pad_clk);
+		if (ret) {
+			dev_err(combophy->dev, "External clock enable failed %d\n", ret);
+			clk_disable_unprepare(combophy->ker_clk);
+			clk_disable_unprepare(combophy->phy_clk);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void stm32_combophy_disable_clocks(struct stm32_combophy *combophy)
+{
+	if (combophy->pad_clk)
+		clk_disable_unprepare(combophy->pad_clk);
+	clk_disable_unprepare(combophy->ker_clk);
+	clk_disable_unprepare(combophy->phy_clk);
+}
+
+static int stm32_combophy_suspend_noirq(struct device *dev)
+{
+	struct stm32_combophy *combophy = dev_get_drvdata(dev);
+
+	/*
+	 * Clocks should be turned off since it is not needed for
+	 * wakeup capability. In case usb-remote wakeup is not enabled,
+	 * combo-phy is already turned off by HCD driver using exit callback
+	 */
+	if (combophy->is_init) {
+		stm32_combophy_disable_clocks(combophy);
+
+		/* since wakeup is enabled for ctrl */
+		enable_irq_wake(combophy->irq_wakeup);
+	}
+
+	return 0;
+}
+
+static int stm32_combophy_resume_noirq(struct device *dev)
+{
+	struct stm32_combophy *combophy = dev_get_drvdata(dev);
+	int ret;
+
+	/*
+	 * If clocks was turned off by suspend call for wakeup then needs
+	 * to be turned back ON in resume. In case usb-remote wakeup is not
+	 * enabled, clocks already turned ON by HCD driver using init callback
+	 */
+	if (combophy->is_init) {
+		/* since wakeup was enabled for ctrl */
+		disable_irq_wake(combophy->irq_wakeup);
+
+		ret = stm32_combophy_enable_clocks(combophy);
+		if (ret) {
+			dev_err(dev, "can't enable clocks (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_combophy_exit(struct phy *phy)
+{
+	struct stm32_combophy *combophy = phy_get_drvdata(phy);
+
+	combophy->is_init = false;
+
+	if (combophy->type == PHY_TYPE_PCIE && !combophy->pad_clk)
+		regmap_update_bits(combophy->regmap, SYSCFG_PCIEPRGCR,
+				   STM32MP25_PCIEPRGCR_EN, 0);
+
+	if (combophy->type != PHY_TYPE_PCIE)
+		regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR1,
+				   SYSCFG_COMBOPHY_CR1_REFSSPEN, 0);
+
+	regmap_update_bits(combophy->regmap, SYSCFG_COMBOPHY_CR2,
+			   SYSCFG_COMBOPHY_CR2_ISO_DIS, 0);
+
+	stm32_combophy_disable_clocks(combophy);
+
+	return 0;
+}
+
+static int stm32_combophy_init(struct phy *phy)
+{
+	struct stm32_combophy *combophy = phy_get_drvdata(phy);
+	int ret;
+
+	ret = stm32_combophy_enable_clocks(combophy);
+	if (ret) {
+		dev_err(combophy->dev, "Clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	ret = stm32_combophy_set_mode(combophy);
+	if (ret) {
+		dev_err(combophy->dev, "combophy mode not set\n");
+		stm32_combophy_disable_clocks(combophy);
+		return ret;
+	}
+
+	ret = stm32_combophy_pll_init(combophy);
+	if (ret) {
+		stm32_combophy_disable_clocks(combophy);
+		return ret;
+	}
+
+	combophy->is_init = true;
+
+	return ret;
+}
+
+static const struct phy_ops stm32_combophy_phy_data = {
+	.init = stm32_combophy_init,
+	.exit = stm32_combophy_exit,
+	.owner = THIS_MODULE
+};
+
+static irqreturn_t stm32_combophy_irq_wakeup_handler(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int stm32_combophy_probe(struct platform_device *pdev)
+{
+	struct stm32_combophy *combophy;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct phy_provider *phy_provider;
+	int ret, irq;
+
+	combophy = devm_kzalloc(dev, sizeof(*combophy), GFP_KERNEL);
+	if (!combophy)
+		return -ENOMEM;
+
+	combophy->dev = dev;
+
+	dev_set_drvdata(dev, combophy);
+
+	combophy->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(combophy->base))
+		return PTR_ERR(combophy->base);
+
+	combophy->phy_clk = devm_clk_get(dev, "apb-clk");
+	if (IS_ERR(combophy->phy_clk))
+		return dev_err_probe(dev, PTR_ERR(combophy->phy_clk),
+				     "Failed to get PHY clock source\n");
+
+	combophy->ker_clk = devm_clk_get(dev, "ker-clk");
+	if (IS_ERR(combophy->ker_clk))
+		return dev_err_probe(dev, PTR_ERR(combophy->ker_clk),
+				     "Failed to get PHY internal clock source\n");
+
+	combophy->pad_clk = devm_clk_get_optional(dev, "pad-clk");
+	if (IS_ERR(combophy->pad_clk))
+		return dev_err_probe(dev, PTR_ERR(combophy->pad_clk),
+				     "Failed to get PHY external clock source\n");
+
+	combophy->phy_reset = devm_reset_control_get(dev, "phy-rst");
+	if (IS_ERR(combophy->phy_reset))
+		return dev_err_probe(dev, PTR_ERR(combophy->phy_reset),
+				     "Failed to get PHY reset\n");
+
+	combophy->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(combophy->regmap))
+		return dev_err_probe(dev, PTR_ERR(combophy->regmap),
+				     "No syscfg phandle specified\n");
+
+	combophy->phy = devm_phy_create(dev, NULL, &stm32_combophy_phy_data);
+	if (IS_ERR(combophy->phy))
+		return dev_err_probe(dev, PTR_ERR(combophy->phy),
+				     "failed to create PCIe/USB3 ComboPHY\n");
+
+	if (device_property_read_bool(dev, "wakeup-source")) {
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0)
+			return dev_err_probe(dev, irq, "failed to get IRQ\n");
+		combophy->irq_wakeup = irq;
+
+		ret = devm_request_threaded_irq(dev, combophy->irq_wakeup, NULL,
+						stm32_combophy_irq_wakeup_handler, IRQF_ONESHOT,
+						NULL, NULL);
+		if (ret)
+			return dev_err_probe(dev, ret, "unable to request wake IRQ %d\n",
+						 combophy->irq_wakeup);
+	}
+
+	phy_set_drvdata(combophy->phy, combophy);
+
+	phy_provider = devm_of_phy_provider_register(dev, stm32_combophy_xlate);
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static const struct dev_pm_ops stm32_combophy_pm_ops = {
+	NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_combophy_suspend_noirq,
+				  stm32_combophy_resume_noirq)
+};
+
+static const struct of_device_id stm32_combophy_of_match[] = {
+	{ .compatible = "st,stm32mp25-combophy", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, stm32_combophy_of_match);
+
+static struct platform_driver stm32_combophy_driver = {
+	.probe = stm32_combophy_probe,
+	.driver = {
+		   .name = "stm32-combophy",
+		   .of_match_table = stm32_combophy_of_match,
+		   .pm = pm_sleep_ptr(&stm32_combophy_pm_ops)
+	}
+};
+
+module_platform_driver(stm32_combophy_driver);
+
+MODULE_AUTHOR("Christian Bruel <christian.bruel@foss.st.com>");
+MODULE_DESCRIPTION("STM32MP25 Combophy USB3/PCIe controller driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/phy/st/phy-stm32-usb2phy.c b/drivers/phy/st/phy-stm32-usb2phy.c
new file mode 100644
index 000000000..375253531
--- /dev/null
+++ b/drivers/phy/st/phy-stm32-usb2phy.c
@@ -0,0 +1,785 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics STM32 USB2 PHY Controller driver
+ * Currently Only supported for STM32MP25
+ *
+ * Copyright (C) 2022 STMicroelectronics
+ * Author(s): Pankaj Dev <pankaj.dev@st.com>.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/usb/role.h>
+#include <linux/mfd/syscon.h>
+
+#define PHY1CR_OFFSET		0x2400
+#define PHY1TRIM1_OFFSET	0x240C
+#define PHY1TRIM2_OFFSET	0x2410
+#define PHY2CR_OFFSET		0x2800
+#define PHY2TRIM1_OFFSET	0x2808
+#define PHY2TRIM2_OFFSET	0x280C
+
+#define PHYCR_REG      1
+
+/* Retention mode enable (active low) */
+#define SYSCFG_USB2PHY2CR_RETENABLEN2_MASK		BIT(0)
+/*
+ * Auto-resume mode enable. Enables auto-resume logic in USB2PHY so that the PHY automatically
+ * responds to a remote wake-up without initial involvement of the Host controller.
+ */
+#define SYSCFG_USB2PHY2CR_AUTORSMENB2_MASK		BIT(1)
+/* Controls the power down of analog blocks during Suspend and Sleep. */
+#define SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK		BIT(2)
+/* Controls vbus valid input of USB3 DRD controller when in Host mode */
+#define SYSCFG_USB2PHY2CR_VBUSVALID_MASK		BIT(4)
+/* Selects VBUS valid comparator that is used when USB3 DRD controller is in Device mode */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK		BIT(5)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK		BIT(6)
+/*
+ * 0: internal debounce logic is enabled (default).
+ * Bit0: applies to utmiotg_vbusvalid,
+ * Bit1: applies to pipe3_PowerPresent,
+ * Bit2: applies to utmisrp_bvalid,
+ * Bit3: applies to utmiotg_iddig]. (default)
+ */
+#define SYSCFG_USB2PHY2CR_FILTER_BYPASS_MASK		GENMASK(10, 7)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_OTGDISABLE0_MASK		BIT(16)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_DRVVBUS0_MASK			BIT(17)
+
+#define SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK		GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK		GENMASK(5, 2)
+#define SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK		GENMASK(8, 6)
+#define SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK		GENMASK(11, 9)
+#define SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK		GENMASK(13, 12)
+#define SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK		GENMASK(16, 14)
+#define SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK		GENMASK(18, 17)
+#define SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK		GENMASK(22, 19)
+#define SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK		GENMASK(26, 23)
+#define SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK		GENMASK(28, 27)
+#define SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK		GENMASK(30, 29)
+
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK	GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK	BIT(2)
+
+struct stm32_usb2phy {
+	struct phy *phy;
+	struct regmap *regmap;
+	struct device *dev;
+	struct reset_control *rstc;
+	struct clk *phyref;
+	struct regulator *vdd33, *vdda18;
+	enum phy_mode mode;
+	u32 mask_trim1, value_trim1, mask_trim2, value_trim2;
+	bool is_init;
+	struct clk_hw clk48_hw;
+	atomic_t en_refcnt;
+	const struct stm32mp2_usb2phy_hw_data *hw_data;
+};
+
+enum stm32_usb2phy_mode {
+	USB2_MODE_HOST_ONLY,
+	USB2_MODE_DRD,
+};
+
+struct stm32mp2_usb2phy_hw_data {
+	u32 phyrefsel_mask, phyrefsel_bitpos, cr_offset, trim1_offset, trim2_offset;
+	enum stm32_usb2phy_mode valid_mode;
+};
+
+static const struct stm32mp2_usb2phy_hw_data stm32mp2_usb2phy_hwdata[] = {
+	{
+		.cr_offset = PHY1CR_OFFSET,
+		.trim1_offset = PHY1TRIM1_OFFSET,
+		.trim2_offset = PHY1TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_HOST_ONLY,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 4,
+	},
+	{
+		.cr_offset = PHY2CR_OFFSET,
+		.trim1_offset = PHY2TRIM1_OFFSET,
+		.trim2_offset = PHY2TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_DRD,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 12,
+	}
+};
+
+/*
+ * Two phy instances are found in mp25, and some bitfields are a bit different (shift...)
+ * depending on the instance. So identify the instance by using CR offset to report
+ * the correct bitfields & modes to use
+ */
+static const struct stm32mp2_usb2phy_hw_data *stm32_usb2phy_get_hwdata(unsigned long offset)
+{
+	int i;
+
+	for (i = 0; i < sizeof(stm32mp2_usb2phy_hwdata); i++)
+		if (stm32mp2_usb2phy_hwdata[i].cr_offset == offset)
+			break;
+
+	if (i < sizeof(stm32mp2_usb2phy_hwdata))
+		return &stm32mp2_usb2phy_hwdata[i];
+
+	return NULL;
+}
+
+static int stm32_usb2phy_getrefsel(unsigned long rate)
+{
+	switch (rate) {
+	case 19200000:
+		return 0;
+	case 20000000:
+		return 1;
+	case 24000000:
+		return 2;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_usb2phy_regulators_enable(struct stm32_usb2phy *phy_dev)
+{
+	int ret;
+
+	ret = regulator_enable(phy_dev->vdd33);
+	if (ret)
+		return ret;
+
+	if (phy_dev->vdda18) {
+		ret = regulator_enable(phy_dev->vdda18);
+		if (ret)
+			goto vdd33_disable;
+	}
+
+	return 0;
+
+vdd33_disable:
+	regulator_disable(phy_dev->vdd33);
+
+	return ret;
+}
+
+static int stm32_usb2phy_regulators_disable(struct stm32_usb2phy *phy_dev)
+{
+	int ret;
+
+	if (phy_dev->vdda18) {
+		ret = regulator_disable(phy_dev->vdda18);
+		if (ret)
+			return ret;
+	}
+
+	ret = regulator_disable(phy_dev->vdd33);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stm32_usb2phy_enable(struct stm32_usb2phy *phy_dev)
+{
+	int ret;
+	struct device *dev = phy_dev->dev;
+	unsigned long phyref_rate;
+	u32 phyrefsel;
+	const struct stm32mp2_usb2phy_hw_data *phy_data = phy_dev->hw_data;
+
+	/* Check if a phy is already init or clk48 in use */
+	if (atomic_inc_return(&phy_dev->en_refcnt) > 1)
+		return 0;
+
+	phyref_rate = clk_get_rate(phy_dev->phyref);
+
+	ret = stm32_usb2phy_getrefsel(phyref_rate);
+	if (ret < 0) {
+		dev_err(dev, "invalid phyref clk rate: %d\n", ret);
+		return ret;
+	}
+	phyrefsel = (u32)ret;
+	dev_dbg(dev, "phyrefsel value (%d)\n", phyrefsel);
+
+	ret = regmap_update_bits(phy_dev->regmap,
+				 phy_data->cr_offset,
+				 phy_data->phyrefsel_mask << phy_data->phyrefsel_bitpos,
+				 phyrefsel << phy_data->phyrefsel_bitpos);
+	if (ret) {
+		dev_err(dev, "can't set phyrefclksel (%d)\n", ret);
+		return ret;
+	}
+
+	if (phy_dev->mask_trim1) {
+		ret = regmap_update_bits(phy_dev->regmap, phy_dev->hw_data->trim1_offset,
+					 phy_dev->mask_trim1, phy_dev->value_trim1);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim1 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim1 mask = %x value = %x\n", phy_dev->mask_trim1,
+			phy_dev->value_trim1);
+	}
+
+	if (phy_dev->mask_trim2) {
+		ret = regmap_update_bits(phy_dev->regmap, phy_dev->hw_data->trim2_offset,
+					 phy_dev->mask_trim2, phy_dev->value_trim2);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim2 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim2 mask = %x value = %x\n", phy_dev->mask_trim2,
+			phy_dev->value_trim2);
+	}
+
+	ret = stm32_usb2phy_regulators_enable(phy_dev);
+	if (ret) {
+		dev_err(dev, "can't enable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(phy_dev->phyref);
+	if (ret) {
+		dev_err(dev, "could not enable optional phyref: %d\n", ret);
+		goto error_regdis;
+	}
+
+	ret = reset_control_deassert(phy_dev->rstc);
+	if (ret) {
+		dev_err(dev, "can't release reset (%d)\n", ret);
+		goto error_clkdis;
+	}
+
+	return 0;
+
+error_clkdis:
+	clk_disable_unprepare(phy_dev->phyref);
+error_regdis:
+	stm32_usb2phy_regulators_disable(phy_dev);
+
+	return ret;
+}
+
+static int stm32_usb2phy_disable(struct stm32_usb2phy *phy_dev)
+{
+	int ret;
+
+	/* Check if a phy is still init or clk48 in use */
+	if (atomic_dec_return(&phy_dev->en_refcnt) > 0)
+		return 0;
+
+	ret = reset_control_assert(phy_dev->rstc);
+	if (ret) {
+		dev_err(phy_dev->dev, "can't force reset (%d)\n", ret);
+		return ret;
+	}
+
+	clk_disable_unprepare(phy_dev->phyref);
+
+	ret = stm32_usb2phy_regulators_disable(phy_dev);
+	if (ret) {
+		dev_err(phy_dev->dev, "can't disable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_suspend(struct device *dev)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_drvdata(dev);
+	int ret;
+
+	/*
+	 * Fempto-phy should be turned off since it is not needed for
+	 * wakeup capability. In case usb-remote wakeup is not enabled,
+	 * usb2-phy is already turned off by HCD driver using exit callback
+	 */
+	if (phy_dev->is_init) {
+		ret = stm32_usb2phy_disable(phy_dev);
+		if (ret) {
+			dev_err(dev, "can't disable usb2phy (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_resume(struct device *dev)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_drvdata(dev);
+	int ret;
+
+	/*
+	 * If fempto-phy was turned off by suspend call for wakeup then needs
+	 * to be turned back ON in resume. In case usb-remote wakeup is not
+	 * enabled, usb2-phy is already turned ON by HCD driver using init callback
+	 */
+	if (phy_dev->is_init) {
+		ret = stm32_usb2phy_enable(phy_dev);
+		if (ret) {
+			dev_err(dev, "can't enable usb2phy (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = phy_get_drvdata(phy);
+	const struct stm32mp2_usb2phy_hw_data *phy_data = phy_dev->hw_data;
+	struct device *dev = &phy->dev;
+
+	switch (mode) {
+	case PHY_MODE_USB_HOST:
+		if (phy_data->valid_mode == USB2_MODE_HOST_ONLY)
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK,
+						 0);
+		else {
+			if (submode == USB_ROLE_NONE) {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK, 0);
+			} else {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK);
+			}
+		}
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	case PHY_MODE_USB_DEVICE:
+		if (submode == USB_ROLE_NONE) {
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK);
+		} else {
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK);
+		}
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	phy_dev->mode = mode;
+
+	return 0;
+}
+
+static int stm32_usb2phy_init(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = phy_get_drvdata(phy);
+	struct device *dev = &phy->dev;
+
+	ret = stm32_usb2phy_enable(phy_dev);
+	if (ret) {
+		dev_err(dev, "can't enable usb2phy (%d)\n", ret);
+		return ret;
+	}
+
+	if (phy_dev->mode != PHY_MODE_INVALID) {
+		ret = stm32_usb2phy_set_mode(phy, phy_dev->mode, USB_ROLE_NONE);
+		if (ret) {
+			dev_err(dev, "can't set phy mode (%d)\n", ret);
+			goto error_disable;
+		}
+	}
+
+	phy_dev->is_init = true;
+
+	return 0;
+
+error_disable:
+	stm32_usb2phy_disable(phy_dev);
+
+	return ret;
+}
+
+static int stm32_usb2phy_exit(struct phy *phy)
+{
+	struct stm32_usb2phy *phy_dev = phy_get_drvdata(phy);
+	int ret;
+
+	ret = stm32_usb2phy_disable(phy_dev);
+	if (ret) {
+		dev_err(phy_dev->dev, "can't disable usb2phy (%d)\n", ret);
+		return ret;
+	}
+
+	phy_dev->is_init = false;
+
+	return 0;
+}
+
+static const struct phy_ops stm32_usb2phy_data = {
+	.init = stm32_usb2phy_init,
+	.exit = stm32_usb2phy_exit,
+	.set_mode = stm32_usb2phy_set_mode,
+	.owner = THIS_MODULE,
+};
+
+static int stm32_usb2phy_clk48_prepare(struct clk_hw *hw)
+{
+	struct stm32_usb2phy *phy_dev = container_of(hw, struct stm32_usb2phy,
+							   clk48_hw);
+
+	return stm32_usb2phy_enable(phy_dev);
+}
+
+static void stm32_usb2phy_clk48_unprepare(struct clk_hw *hw)
+{
+	struct stm32_usb2phy *phy_dev = container_of(hw, struct stm32_usb2phy,
+							   clk48_hw);
+
+	stm32_usb2phy_disable(phy_dev);
+}
+
+static unsigned long stm32_usb2phy_clk48_recalc_rate(struct clk_hw *hw,
+							   unsigned long parent_rate)
+{
+	return 48000000;
+}
+
+static const struct clk_ops stm32_usb2phy_clk48_ops = {
+	.prepare = stm32_usb2phy_clk48_prepare,
+	.unprepare = stm32_usb2phy_clk48_unprepare,
+	.recalc_rate = stm32_usb2phy_clk48_recalc_rate,
+};
+
+static int stm32_usb2phy_clk48_register(struct stm32_usb2phy *phy_dev)
+{
+	struct clk_init_data init = { };
+	int ret = 0;
+	char name[20];
+
+	snprintf(name, sizeof(name), "ck_usb2phy%x_48m", phy_dev->hw_data->cr_offset);
+	init.name = name;
+	init.ops = &stm32_usb2phy_clk48_ops;
+
+	phy_dev->clk48_hw.init = &init;
+
+	ret = devm_clk_hw_register(phy_dev->dev, &phy_dev->clk48_hw);
+	if (ret) {
+		dev_err(phy_dev->dev, "failed to register 48m clk\n");
+		return ret;
+	}
+
+	ret = devm_of_clk_add_hw_provider(phy_dev->dev, of_clk_hw_simple_get, &phy_dev->clk48_hw);
+	if (ret)
+		dev_err(phy_dev->dev, "adding clk provider 48m failed\n");
+
+	return ret;
+}
+
+static int stm32_usb2phy_tuning(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = phy_get_drvdata(phy);
+	struct device *dev = &phy->dev;
+	struct device_node *np = dev->of_node;
+	u8 val;
+
+	ret = of_property_read_u8(np, "st,pll-ipath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ipath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,pll-ppath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ppath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,comp-dis-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting comp-dis-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,sqrx-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting sqrx-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,vdatref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting vdatref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,otg-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting otg-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txhsxv-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting txhsxv-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txfsls-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting txfsls-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txvref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting txvref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txrise-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting txrise-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txres-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK, val)) {
+			phy_dev->mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK;
+			phy_dev->value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting txres-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txpreempamp-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK, val)) {
+			phy_dev->mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK;
+			phy_dev->value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK,
+							   val);
+		} else {
+			dev_err(dev, "Error getting txpreempamp-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = of_property_read_u8(np, "st,txpreemppulse-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK, val)) {
+			phy_dev->mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK;
+			phy_dev->value_trim2 |= FIELD_PREP(
+						SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK,
+						val);
+		} else {
+			dev_err(dev, "Error getting txpreemppulse-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	of_node_put(np);
+
+	return 0;
+}
+
+static int stm32_usb2phy_probe(struct platform_device *pdev)
+{
+	struct stm32_usb2phy *phy_dev;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct phy_provider *phy_provider;
+	struct phy *phy;
+	int ret;
+	u32 phycr;
+
+	phy_dev = devm_kzalloc(dev, sizeof(*phy_dev), GFP_KERNEL);
+	if (!phy_dev)
+		return -ENOMEM;
+
+	phy_dev->dev = dev;
+	dev_set_drvdata(dev, phy_dev);
+
+	phy_dev->rstc = devm_reset_control_get(dev, NULL);
+	if (IS_ERR(phy_dev->rstc))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->rstc), "failed to get USB2PHY reset\n");
+
+	phy_dev->phyref = devm_clk_get(dev, NULL);
+	if (IS_ERR(phy_dev->phyref))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->phyref), "failed to get phyref clk\n");
+
+	phy_dev->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(phy_dev->regmap))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->regmap),
+				     "No syscfg phandle specified\n");
+
+	ret = of_property_read_u32_index(np, "st,syscfg", PHYCR_REG, &phycr);
+	if (ret)
+		return dev_err_probe(dev, ret, "can't get phycr offset\n");
+
+	phy_dev->vdd33 = devm_regulator_get_optional(dev, "vdd33");
+	if (IS_ERR(phy_dev->vdd33))
+		return dev_err_probe(dev, PTR_ERR(phy_dev->vdd33),
+				     "failed to get vdda3v3 supply\n");
+
+	phy_dev->vdda18 = devm_regulator_get_optional(dev, "vdda18");
+	if (IS_ERR(phy_dev->vdda18)) {
+		ret = PTR_ERR(phy_dev->vdda18);
+		if (ret != -ENODEV)
+			return dev_err_probe(dev, ret, "failed to get vdda1v8 supply\n");
+		phy_dev->vdda18 = NULL;
+	}
+
+	phy_dev->hw_data = stm32_usb2phy_get_hwdata(phycr);
+	if (!phy_dev->hw_data) {
+		dev_err(dev, "can't get matching stm32mp2_usb2_of_data\n");
+		return -EINVAL;
+	}
+
+	phy = devm_phy_create(dev, NULL, &stm32_usb2phy_data);
+	if (IS_ERR(phy))
+		return dev_err_probe(dev, PTR_ERR(phy), "failed to create USB2-PHY\n");
+
+	phy_dev->phy = phy;
+	phy_set_drvdata(phy, phy_dev);
+
+	/* Configure phy tuning */
+	ret = stm32_usb2phy_tuning(phy);
+	if (ret)
+		return dev_err_probe(dev, ret, "can't set tuning parameters\n");
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	if (IS_ERR(phy_provider))
+		return PTR_ERR(phy_provider);
+
+	ret = stm32_usb2phy_clk48_register(phy_dev);
+	if (ret) {
+		dev_err_probe(dev, ret, "failed to register ck_usb2phy%x_48m clock: %d\n",
+			      phy_dev->hw_data->cr_offset, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static DEFINE_SIMPLE_DEV_PM_OPS(stm32_usb2phy_pm_ops, stm32_usb2phy_suspend,
+				stm32_usb2phy_resume);
+
+static const struct of_device_id stm32_usb2phy_of_match[] = {
+	{ .compatible = "st,stm32mp25-usb2phy" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, stm32_usb2phy_of_match);
+
+static struct platform_driver stm32_usb2phy_driver = {
+	.probe = stm32_usb2phy_probe,
+	.driver = {
+		.name = "stm32-usb2phy",
+		.of_match_table = stm32_usb2phy_of_match,
+		.pm = pm_sleep_ptr(&stm32_usb2phy_pm_ops)
+	}
+};
+
+module_platform_driver(stm32_usb2phy_driver);
+
+MODULE_AUTHOR("Pankaj Dev <pankaj.dev@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics Generic USB2PHY driver for stm32");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/phy/st/phy-stm32-usbphyc.c b/drivers/phy/st/phy-stm32-usbphyc.c
index 5bb9647b0..6115f9b21 100644
--- a/drivers/phy/st/phy-stm32-usbphyc.c
+++ b/drivers/phy/st/phy-stm32-usbphyc.c
@@ -12,6 +12,7 @@
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
 #include <linux/reset.h>
@@ -136,6 +137,7 @@ struct stm32_usbphyc_phy {
 	struct phy *phy;
 	struct stm32_usbphyc *usbphyc;
 	struct regulator *vbus;
+	int wakeirq;
 	u32 index;
 	bool active;
 	u32 tune;
@@ -376,6 +378,12 @@ static int stm32_usbphyc_phy_exit(struct phy *phy)
 static int stm32_usbphyc_phy_power_on(struct phy *phy)
 {
 	struct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);
+	struct stm32_usbphyc *usbphyc = usbphyc_phy->usbphyc;
+
+	if (usbphyc_phy->wakeirq > 0)
+		if (enable_irq_wake(usbphyc_phy->wakeirq))
+			dev_warn(usbphyc->dev,
+				 "Wake irq for phy%d not enabled\n", usbphyc_phy->index);
 
 	if (usbphyc_phy->vbus)
 		return regulator_enable(usbphyc_phy->vbus);
@@ -386,6 +394,12 @@ static int stm32_usbphyc_phy_power_on(struct phy *phy)
 static int stm32_usbphyc_phy_power_off(struct phy *phy)
 {
 	struct stm32_usbphyc_phy *usbphyc_phy = phy_get_drvdata(phy);
+	struct stm32_usbphyc *usbphyc = usbphyc_phy->usbphyc;
+
+	if (usbphyc_phy->wakeirq > 0)
+		if (disable_irq_wake(usbphyc_phy->wakeirq))
+			dev_warn(usbphyc->dev,
+				 "Wake irq for phy%d not disabled\n", usbphyc_phy->index);
 
 	if (usbphyc_phy->vbus)
 		return regulator_disable(usbphyc_phy->vbus);
@@ -732,6 +746,12 @@ static int stm32_usbphyc_probe(struct platform_device *pdev)
 			usbphyc->phys[port]->vbus = NULL;
 		}
 
+		/* Get optional wakeup interrupt */
+		ret = of_irq_get(child, 0);
+		if (ret == -EPROBE_DEFER)
+			goto put_child;
+		usbphyc->phys[port]->wakeirq = ret;
+
 		/* Configure phy tuning */
 		stm32_usbphyc_phy_tuning(usbphyc, child, index);
 
diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 6e0a40962..80a881a7a 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -143,10 +143,14 @@ static int dt_to_map_one_config(struct pinctrl *p,
 		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);
 		if (pctldev)
 			break;
-		/* Do not defer probing of hogs (circular loop) */
+		/*
+		 * Do not defer probing of hogs (circular loop)
+		 *
+		 * Return 1 to let the caller catch the case.
+		 */
 		if (np_pctldev == p->dev->of_node) {
 			of_node_put(np_pctldev);
-			return -ENODEV;
+			return 1;
 		}
 	}
 	of_node_put(np_pctldev);
@@ -263,6 +267,8 @@ int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
 			ret = dt_to_map_one_config(p, pctldev, statename,
 						   np_config);
 			of_node_put(np_config);
+			if (ret == 1)
+				continue;
 			if (ret < 0)
 				goto err;
 		}
diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index ab4dde40d..b3166235a 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -6,6 +6,7 @@
  * Author(s): Amelie Delaunay <amelie.delaunay@st.com>.
  */
 #include <linux/gpio/driver.h>
+#include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/mfd/stmfx.h>
 #include <linux/module.h>
@@ -425,6 +426,7 @@ static void stmfx_pinctrl_irq_mask(struct irq_data *data)
 	u32 mask = get_mask(data->hwirq);
 
 	pctl->irq_gpi_src[reg] &= ~mask;
+	gpiochip_disable_irq(gpio_chip, data->hwirq);
 }
 
 static void stmfx_pinctrl_irq_unmask(struct irq_data *data)
@@ -434,6 +436,7 @@ static void stmfx_pinctrl_irq_unmask(struct irq_data *data)
 	u32 reg = get_reg(data->hwirq);
 	u32 mask = get_mask(data->hwirq);
 
+	gpiochip_enable_irq(gpio_chip, data->hwirq);
 	pctl->irq_gpi_src[reg] |= mask;
 }
 
@@ -613,13 +616,31 @@ static int stmfx_pinctrl_gpio_function_enable(struct stmfx_pinctrl *pctl)
 	return stmfx_function_enable(pctl->stmfx, func);
 }
 
+static int stmfx_pinctrl_irq_set_affinity(struct irq_data *d, const struct cpumask *dest,
+					  bool force)
+{
+	struct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(d);
+	struct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);
+	struct i2c_client *client = to_i2c_client(pctl->stmfx->dev);
+	static DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL * 10, 1);
+
+	if (__ratelimit(&rs))
+		dev_notice(pctl->dev,
+			   "Can't set the affinity, set it for irq %d instead\n", client->irq);
+	if (force)
+		return -EINVAL;
+
+	return 0;
+}
+
 static int stmfx_pinctrl_probe(struct platform_device *pdev)
 {
 	struct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);
 	struct device_node *np = pdev->dev.of_node;
 	struct stmfx_pinctrl *pctl;
 	struct gpio_irq_chip *girq;
-	int irq, ret;
+	int irq, i, ret;
+	const char **names;
 
 	pctl = devm_kzalloc(stmfx->dev, sizeof(*pctl), GFP_KERNEL);
 	if (!pctl)
@@ -676,6 +697,14 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->gpio_chip.ngpio = pctl->pctl_desc.npins;
 	pctl->gpio_chip.can_sleep = true;
 
+	names = devm_kcalloc(pctl->dev, ARRAY_SIZE(stmfx_pins), sizeof(char *), GFP_KERNEL);
+	if (names) {
+		for (i = 0; i < ARRAY_SIZE(stmfx_pins); i++)
+			names[i] = stmfx_pins[i].name;
+
+		pctl->gpio_chip.names = names;
+	}
+
 	pctl->irq_chip.name = dev_name(pctl->dev);
 	pctl->irq_chip.irq_mask = stmfx_pinctrl_irq_mask;
 	pctl->irq_chip.irq_unmask = stmfx_pinctrl_irq_unmask;
@@ -684,9 +713,12 @@ static int stmfx_pinctrl_probe(struct platform_device *pdev)
 	pctl->irq_chip.irq_bus_sync_unlock = stmfx_pinctrl_irq_bus_sync_unlock;
 	pctl->irq_chip.irq_request_resources = stmfx_gpio_irq_request_resources;
 	pctl->irq_chip.irq_release_resources = stmfx_gpio_irq_release_resources;
+	pctl->irq_chip.flags = IRQCHIP_IMMUTABLE;
+	pctl->irq_chip.irq_set_affinity = IS_ENABLED(CONFIG_SMP) ? stmfx_pinctrl_irq_set_affinity :
+								   NULL;
 
 	girq = &pctl->gpio_chip.irq;
-	girq->chip = &pctl->irq_chip;
+	gpio_irq_chip_set_chip(girq, &pctl->irq_chip);
 	/* This will let us handle the parent IRQ in the driver */
 	girq->parent_handler = NULL;
 	girq->num_parents = 0;
diff --git a/drivers/pinctrl/stm32/Kconfig b/drivers/pinctrl/stm32/Kconfig
index d532f3c6f..7884e9a6f 100644
--- a/drivers/pinctrl/stm32/Kconfig
+++ b/drivers/pinctrl/stm32/Kconfig
@@ -2,7 +2,7 @@
 if ARCH_STM32 || COMPILE_TEST
 
 config PINCTRL_STM32
-	bool
+	tristate
 	depends on OF
 	select PINMUX
 	select GENERIC_PINCONF
@@ -51,4 +51,24 @@ config PINCTRL_STM32MP157
 	depends on OF && HAS_IOMEM
 	default MACH_STM32MP157
 	select PINCTRL_STM32
+
+config PINCTRL_STM32MP257
+	tristate "STMicroelectronics STM32MP257 pin control"
+	depends on OF && HAS_IOMEM
+	default MACH_STM32MP25 || ARM64
+	select PINCTRL_STM32
+
+config PINCTRL_STM32_HDP
+	tristate "STMicroelectronics STM32 Hardware Debug Port (HDP) pin control"
+	depends on OF && HAS_IOMEM
+	default MACH_STM32MP157 || MACH_STM32MP13 || MACH_STM32MP25 || ARM64
+	select PINMUX
+	select GENERIC_PINCONF
+	select GPIOLIB
+	help
+	  The Hardware Debug Port allows the observation of internal signals.
+	  It uses configurable multiplexer to route signals in a dedicated observation register.
+	  This driver also permits the observation of signals on external SoC pins.
+	  It permits the observation of up to 16 signals per HDP line.
+
 endif
diff --git a/drivers/pinctrl/stm32/Makefile b/drivers/pinctrl/stm32/Makefile
index 619629ee9..98a1bbc7e 100644
--- a/drivers/pinctrl/stm32/Makefile
+++ b/drivers/pinctrl/stm32/Makefile
@@ -10,3 +10,5 @@ obj-$(CONFIG_PINCTRL_STM32F769)	+= pinctrl-stm32f769.o
 obj-$(CONFIG_PINCTRL_STM32H743)	+= pinctrl-stm32h743.o
 obj-$(CONFIG_PINCTRL_STM32MP135) += pinctrl-stm32mp135.o
 obj-$(CONFIG_PINCTRL_STM32MP157) += pinctrl-stm32mp157.o
+obj-$(CONFIG_PINCTRL_STM32MP257) += pinctrl-stm32mp257.o
+obj-$(CONFIG_PINCTRL_STM32_HDP) += pinctrl-stm32-hdp.o
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32-hdp.c b/drivers/pinctrl/stm32/pinctrl-stm32-hdp.c
new file mode 100644
index 000000000..d5d65f0d8
--- /dev/null
+++ b/drivers/pinctrl/stm32/pinctrl-stm32-hdp.c
@@ -0,0 +1,310 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clment Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/gpio/driver.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+#include "../core.h"
+#include "../../gpio/gpiolib.h"
+
+#define DRIVER_NAME		"stm32_hdp"
+#define HDP_CTRL_ENABLE		1
+#define HDP_CTRL_DISABLE	0
+#define NB_FUNCTIONS		16
+
+#define HDP_CTRL		0x000
+#define HDP_MUX			0x004
+#define HDP_VAL			0x010
+#define HDP_GPOSET		0x014
+#define HDP_GPOCLR		0x018
+#define HDP_GPOVAL		0x01C
+#define HDP_VERR		0x3F4
+#define HDP_IPIDR		0x3F8
+#define HDP_SIDR		0x3FC
+
+#define HDP_MUX_SHIFT(n)	((n) * 4)
+#define HDP_MUX_MASK(n)		(GENMASK(3, 0) << HDP_MUX_SHIFT(n))
+#define HDP_MUX_GPOVAL(n)	(0xF << HDP_MUX_SHIFT(n))
+
+struct stm32_hdp {
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk;
+	struct pinctrl_dev *pctl_dev;
+	struct gpio_chip gpio_chip;
+	u32 mux_conf;
+	u32 gposet_conf;
+};
+
+static const struct pinctrl_pin_desc stm32_hdp_pins[] = {
+	PINCTRL_PIN(0, "hdp0"),
+	PINCTRL_PIN(1, "hdp1"),
+	PINCTRL_PIN(2, "hdp2"),
+	PINCTRL_PIN(3, "hdp3"),
+	PINCTRL_PIN(4, "hdp4"),
+	PINCTRL_PIN(5, "hdp5"),
+	PINCTRL_PIN(6, "hdp6"),
+	PINCTRL_PIN(7, "hdp7"),
+};
+
+static const char * const func_name[] = {
+	"0", "1", "2", "3",
+	"4", "5", "6", "7",
+	"8", "9", "10", "11",
+	"12", "13", "14", "15",
+};
+
+static const char * const stm32_hdp_pins_group[] = {
+	"hdp0",
+	"hdp1",
+	"hdp2",
+	"hdp3",
+	"hdp4",
+	"hdp5",
+	"hdp6",
+	"hdp7"
+};
+
+static int stm32_hdp_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
+{
+	return GPIO_LINE_DIRECTION_OUT;
+}
+
+static int stm32_hdp_gpio_get(struct gpio_chip *gc, unsigned int offset)
+{
+	struct stm32_hdp *hdp = gpiochip_get_data(gc);
+
+	if (((hdp->mux_conf & HDP_MUX_MASK(offset))) == HDP_MUX_GPOVAL(offset))
+		return !!(readl_relaxed(hdp->base + HDP_GPOVAL) & BIT(offset));
+	else
+		return !!(readl_relaxed(hdp->base + HDP_VAL) & BIT(offset));
+}
+
+static void stm32_hdp_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)
+{
+	struct stm32_hdp *hdp = gpiochip_get_data(gc);
+
+	if (value)
+		writel_relaxed(BIT(offset), hdp->base + HDP_GPOSET);
+	else
+		writel_relaxed(BIT(offset), hdp->base + HDP_GPOCLR);
+}
+
+static int stm32_hdp_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(stm32_hdp_pins);
+}
+
+static const char *stm32_hdp_pinctrl_get_group_name(struct pinctrl_dev *pctldev,
+						    unsigned int selector)
+{
+	return stm32_hdp_pins[selector].name;
+}
+
+static int stm32_hdp_pinctrl_get_group_pins(struct pinctrl_dev *pctldev, unsigned int selector,
+					    const unsigned int **pins, unsigned int *num_pins)
+{
+	*pins = &stm32_hdp_pins[selector].number;
+	*num_pins = 1;
+
+	return 0;
+}
+
+static const struct pinctrl_ops stm32_hdp_pinctrl_ops = {
+	.get_groups_count = stm32_hdp_pinctrl_get_groups_count,
+	.get_group_name	  = stm32_hdp_pinctrl_get_group_name,
+	.get_group_pins	  = stm32_hdp_pinctrl_get_group_pins,
+	.dt_node_to_map	  = pinconf_generic_dt_node_to_map_all,
+	.dt_free_map	  = pinconf_generic_dt_free_map,
+};
+
+static int stm32_hdp_pinmux_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	return NB_FUNCTIONS;
+}
+
+static const char *stm32_hdp_pinmux_get_function_name(struct pinctrl_dev *pctldev,
+						      unsigned int selector)
+{
+	return func_name[selector];
+}
+
+static int stm32_hdp_pinmux_get_function_groups(struct pinctrl_dev *pctldev, unsigned int selector,
+						const char *const **groups,
+						unsigned int *num_groups)
+{
+	*groups = stm32_hdp_pins_group;
+	*num_groups = ARRAY_SIZE(stm32_hdp_pins_group);
+
+	return 0;
+}
+
+static int stm32_hdp_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,
+				    unsigned int group_selector)
+{
+	struct stm32_hdp *hdp = pinctrl_dev_get_drvdata(pctldev);
+	unsigned int pin = stm32_hdp_pins[group_selector].number;
+	u32 mux;
+
+	mux = readl_relaxed(hdp->base + HDP_MUX);
+	mux &= ~HDP_MUX_MASK(pin);
+	mux |= func_selector << HDP_MUX_SHIFT(pin);
+
+	writel_relaxed(mux, hdp->base + HDP_MUX);
+	hdp->mux_conf = mux;
+
+	return 0;
+}
+
+static const struct pinmux_ops stm32_hdp_pinmux_ops = {
+	.get_functions_count = stm32_hdp_pinmux_get_functions_count,
+	.get_function_name   = stm32_hdp_pinmux_get_function_name,
+	.get_function_groups = stm32_hdp_pinmux_get_function_groups,
+	.set_mux	     = stm32_hdp_pinmux_set_mux,
+	.gpio_set_direction  = NULL,
+};
+
+static struct pinctrl_desc stm32_hdp_pdesc = {
+	.name	 = DRIVER_NAME,
+	.pins	 = stm32_hdp_pins,
+	.npins	 = ARRAY_SIZE(stm32_hdp_pins),
+	.pctlops = &stm32_hdp_pinctrl_ops,
+	.pmxops	 = &stm32_hdp_pinmux_ops,
+	.owner	 = THIS_MODULE,
+};
+
+static const struct of_device_id stm32_hdp_of_match[] = {
+	{
+		.compatible = "st,stm32mp-hdp",
+	},
+	{}
+};
+
+static int stm32_hdp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct stm32_hdp *hdp;
+	u8 version;
+	int err;
+
+	hdp = devm_kzalloc(dev, sizeof(*hdp), GFP_KERNEL);
+	if (!hdp)
+		return -ENOMEM;
+	hdp->dev = dev;
+
+	platform_set_drvdata(pdev, hdp);
+
+	hdp->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(hdp->base))
+		return PTR_ERR(hdp->base);
+
+	hdp->clk = devm_clk_get_enabled(dev, NULL);
+	if (IS_ERR(hdp->clk))
+		return dev_err_probe(dev, PTR_ERR(hdp->clk), "No HDP clock provided\n");
+
+	err = devm_pinctrl_register_and_init(dev, &stm32_hdp_pdesc, hdp, &hdp->pctl_dev);
+	if (err) {
+		dev_err(dev, "pinctrl register failed\n");
+		return err;
+	}
+
+	err = pinctrl_enable(hdp->pctl_dev);
+	if (err) {
+		dev_err(dev, "pinctrl enable failed\n");
+		return err;
+	}
+
+	hdp->gpio_chip.label	     = "stm32-hdp";
+	hdp->gpio_chip.parent	     = dev;
+	hdp->gpio_chip.get_direction = stm32_hdp_gpio_get_direction;
+	hdp->gpio_chip.get	     = stm32_hdp_gpio_get;
+	hdp->gpio_chip.set	     = stm32_hdp_gpio_set;
+	hdp->gpio_chip.base	     = -1;
+	hdp->gpio_chip.ngpio	     = ARRAY_SIZE(stm32_hdp_pins);
+	hdp->gpio_chip.can_sleep     = true;
+	hdp->gpio_chip.names	     = stm32_hdp_pins_group;
+
+	err = devm_gpiochip_add_data(dev, &hdp->gpio_chip, hdp);
+	if (err) {
+		dev_err(dev, "Failed to add gpiochip\n");
+		return err;
+	}
+
+	writel_relaxed(HDP_CTRL_ENABLE, hdp->base + HDP_CTRL);
+
+	version = readl_relaxed(hdp->base + HDP_VERR);
+	dev_dbg(dev, "STM32 HDP version %u.%u initialized\n", version >> 4, version & 0x0F);
+
+	return 0;
+}
+
+static int stm32_hdp_remove(struct platform_device *pdev)
+{
+	struct stm32_hdp *hdp = platform_get_drvdata(pdev);
+
+	writel_relaxed(HDP_CTRL_DISABLE, hdp->base + HDP_CTRL);
+
+	return 0;
+}
+
+static int stm32_hdp_suspend(struct device *dev)
+{
+	struct stm32_hdp *hdp = dev_get_drvdata(dev);
+
+	hdp->gposet_conf = readl_relaxed(hdp->base + HDP_GPOSET);
+
+	pinctrl_pm_select_sleep_state(dev);
+
+	clk_disable_unprepare(hdp->clk);
+
+	return 0;
+}
+
+static int stm32_hdp_resume(struct device *dev)
+{
+	struct stm32_hdp *hdp = dev_get_drvdata(dev);
+	int err;
+
+	err = clk_prepare_enable(hdp->clk);
+	if (err) {
+		dev_err(hdp->dev, "failed to prepare_enable clk (%d)\n", err);
+		return err;
+	}
+	writel_relaxed(HDP_CTRL_ENABLE, hdp->base + HDP_CTRL);
+	writel_relaxed(hdp->gposet_conf, hdp->base + HDP_GPOSET);
+	writel_relaxed(hdp->mux_conf, hdp->base + HDP_MUX);
+
+	pinctrl_pm_select_default_state(dev);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_DEV_PM_OPS(stm32_hdp_pm_ops, stm32_hdp_suspend, stm32_hdp_resume);
+
+static struct platform_driver stm32_hdp_driver = {
+	.probe = stm32_hdp_probe,
+	.remove = stm32_hdp_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.pm = pm_sleep_ptr(&stm32_hdp_pm_ops),
+		.of_match_table = stm32_hdp_of_match,
+	}
+};
+
+module_platform_driver(stm32_hdp_driver);
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_AUTHOR("Clment Le Goffic");
+MODULE_DESCRIPTION("STMicroelectronics STM32 Hardware Debug Port driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32.c b/drivers/pinctrl/stm32/pinctrl-stm32.c
index e198233c1..09a8702e8 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32.c
@@ -6,6 +6,7 @@
  *
  * Heavily based on Mediatek's pinctrl driver
  */
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/gpio/driver.h>
 #include <linux/hwspinlock.h>
@@ -34,6 +35,8 @@
 #include "../pinctrl-utils.h"
 #include "pinctrl-stm32.h"
 
+#define STM32_GPIO_CID1		1
+
 #define STM32_GPIO_MODER	0x00
 #define STM32_GPIO_TYPER	0x04
 #define STM32_GPIO_SPEEDR	0x08
@@ -45,6 +48,23 @@
 #define STM32_GPIO_AFRL		0x20
 #define STM32_GPIO_AFRH		0x24
 #define STM32_GPIO_SECCFGR	0x30
+#define STM32_GPIO_DELAYRL	0x40
+#define STM32_GPIO_ADVCFGRL	0x48
+#define STM32_GPIO_CIDCFGR(x)	(0x50 + (0x8 * (x)))
+#define STM32_GPIO_SEMCR(x)	(0x54 + (0x8 * (x)))
+
+#define STM32_GPIO_ADVCFGR_DLYPATH_POS		0
+#define STM32_GPIO_ADVCFGR_DE_POS		1
+#define STM32_GPIO_ADVCFGR_INVCLK_POS		2
+#define STM32_GPIO_ADVCFGR_RET_POS		3
+
+#define STM32_GPIO_CIDCFGR_CFEN		BIT(0)
+#define STM32_GPIO_CIDCFGR_SEMEN	BIT(1)
+#define STM32_GPIO_CIDCFGR_SCID_MASK	GENMASK(5, 4)
+#define STM32_GPIO_CIDCFGR_SEMWL_CID1	BIT(16 + STM32_GPIO_CID1)
+
+#define STM32_GPIO_SEMCR_SEM_MUTEX	BIT(0)
+#define STM32_GPIO_SEMCR_SEMCID_MASK	GENMASK(5, 4)
 
 /* custom bitfield to backup pin status */
 #define STM32_GPIO_BKP_MODE_SHIFT	0
@@ -57,12 +77,26 @@
 #define STM32_GPIO_BKP_PUPD_MASK	GENMASK(9, 8)
 #define STM32_GPIO_BKP_TYPE		10
 #define STM32_GPIO_BKP_VAL		11
+#define STM32_GPIO_BKP_ADVCFG_SHIFT	12
+#define STM32_GPIO_BKP_ADVCFG_MASK	GENMASK(15, 12)
+#define STM32_GPIO_BKP_DELAY_SHIFT	16
+#define STM32_GPIO_BKP_DELAY_MASK	GENMASK(19, 16)
+
+#define STM32_GPIO_PINS_PER_BANK	16
+#define STM32_GPIO_IRQ_LINE		16
 
-#define STM32_GPIO_PINS_PER_BANK 16
-#define STM32_GPIO_IRQ_LINE	 16
+/* to pass bank_ioport_nr to EXTI in struct irq_fwspec::param[1] */
+#define STM32_GPIO_BANK_MASK		GENMASK(23, 16)
 
 #define SYSCFG_IRQMUX_MASK GENMASK(3, 0)
 
+/* Vendor specific pin configurations */
+#define STM32_GPIO_PIN_CONFIG_DELAY_PATH	(PIN_CONFIG_END + 1)
+#define STM32_GPIO_PIN_CONFIG_CLK_EDGE		(PIN_CONFIG_END + 2)
+#define STM32_GPIO_PIN_CONFIG_CLK_TYPE		(PIN_CONFIG_END + 3)
+#define STM32_GPIO_PIN_CONFIG_RETIME		(PIN_CONFIG_END + 4)
+#define STM32_GPIO_PIN_CONFIG_DELAY		(PIN_CONFIG_END + 5)
+
 #define gpio_range_to_bank(chip) \
 		container_of(chip, struct stm32_gpio_bank, range)
 
@@ -75,6 +109,15 @@ static const char * const stm32_gpio_functions[] = {
 	"af8", "af9", "af10",
 	"af11", "af12", "af13",
 	"af14", "af15", "analog",
+	"reserved",
+};
+
+static const struct pinconf_generic_params stm32_gpio_bindings[] = {
+	{"st,io-delay-path",	STM32_GPIO_PIN_CONFIG_DELAY_PATH,	0},
+	{"st,io-clk-edge",	STM32_GPIO_PIN_CONFIG_CLK_EDGE,		0},
+	{"st,io-clk-type",	STM32_GPIO_PIN_CONFIG_CLK_TYPE,		0},
+	{"st,io-retime",	STM32_GPIO_PIN_CONFIG_RETIME,		0},
+	{"st,io-delay",		STM32_GPIO_PIN_CONFIG_DELAY,		0},
 };
 
 struct stm32_pinctrl_group {
@@ -90,13 +133,14 @@ struct stm32_gpio_bank {
 	spinlock_t lock;
 	struct gpio_chip gpio_chip;
 	struct pinctrl_gpio_range range;
-	struct fwnode_handle *fwnode;
-	struct irq_domain *domain;
 	u32 bank_nr;
 	u32 bank_ioport_nr;
 	u32 pin_backup[STM32_GPIO_PINS_PER_BANK];
 	u8 irq_type[STM32_GPIO_PINS_PER_BANK];
+	int virq[STM32_GPIO_PINS_PER_BANK];
 	bool secure_control;
+	bool io_sync_control;
+	bool rif_control;
 };
 
 struct stm32_pinctrl {
@@ -117,9 +161,15 @@ struct stm32_pinctrl {
 	u32 npins;
 	u32 pkg;
 	u16 irqmux_map;
+	bool has_irq_extended;
 	spinlock_t irqmux_lock;
 };
 
+static inline bool stm32_pctl_uses_syscfg(struct stm32_pinctrl *pctl)
+{
+	return pctl->regmap;
+}
+
 static inline int stm32_gpio_pin(int gpio)
 {
 	return gpio % STM32_GPIO_PINS_PER_BANK;
@@ -190,6 +240,92 @@ static void stm32_gpio_backup_bias(struct stm32_gpio_bank *bank, u32 offset,
 	bank->pin_backup[offset] |= bias << STM32_GPIO_BKP_PUPD_SHIFT;
 }
 
+static void stm32_gpio_backup_advcfg(struct stm32_gpio_bank *bank, u32 offset, u32 bpos, u32 bval)
+{
+	bank->pin_backup[offset] &= ~BIT(STM32_GPIO_BKP_ADVCFG_SHIFT + bpos);
+	bank->pin_backup[offset] |= bval << (STM32_GPIO_BKP_ADVCFG_SHIFT + bpos);
+}
+
+static void stm32_gpio_backup_delay(struct stm32_gpio_bank *bank, u32 offset, u32 delay)
+{
+	bank->pin_backup[offset] &= ~STM32_GPIO_BKP_DELAY_MASK;
+	bank->pin_backup[offset] |= delay << STM32_GPIO_BKP_DELAY_SHIFT;
+}
+
+/* RIF functions */
+
+static bool stm32_gpio_rif_valid(struct stm32_gpio_bank *bank, unsigned int gpio_nr)
+{
+	u32 cid;
+
+	cid = readl_relaxed(bank->base + STM32_GPIO_CIDCFGR(gpio_nr));
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return true;
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMEN)) {
+		if (FIELD_GET(STM32_GPIO_CIDCFGR_SCID_MASK, cid) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	if (cid & STM32_GPIO_CIDCFGR_SEMWL_CID1)
+		return true;
+
+	return false;
+}
+
+static bool stm32_gpio_rif_acquire_semaphore(struct stm32_gpio_bank *bank, unsigned int gpio_nr)
+{
+	u32 cid, sem;
+
+	cid = readl_relaxed(bank->base + STM32_GPIO_CIDCFGR(gpio_nr));
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return true;
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMEN)) {
+		if (FIELD_GET(STM32_GPIO_CIDCFGR_SCID_MASK, cid) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMWL_CID1))
+		return false;
+
+	sem = readl_relaxed(bank->base + STM32_GPIO_SEMCR(gpio_nr));
+	if (sem & STM32_GPIO_SEMCR_SEM_MUTEX) {
+		if (FIELD_GET(STM32_GPIO_SEMCR_SEMCID_MASK, sem) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	writel_relaxed(STM32_GPIO_SEMCR_SEM_MUTEX, bank->base + STM32_GPIO_SEMCR(gpio_nr));
+
+	sem = readl_relaxed(bank->base + STM32_GPIO_SEMCR(gpio_nr));
+	if (sem & STM32_GPIO_SEMCR_SEM_MUTEX &&
+	    FIELD_GET(STM32_GPIO_SEMCR_SEMCID_MASK, sem) == STM32_GPIO_CID1)
+		return true;
+
+	return false;
+}
+
+static void stm32_gpio_rif_release_semaphore(struct stm32_gpio_bank *bank, unsigned int gpio_nr)
+{
+	u32 cid;
+
+	cid = readl_relaxed(bank->base + STM32_GPIO_CIDCFGR(gpio_nr));
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return;
+
+	if (cid & STM32_GPIO_CIDCFGR_SEMEN)
+		writel_relaxed(0, bank->base + STM32_GPIO_SEMCR(gpio_nr));
+}
+
 /* GPIO functions */
 
 static inline void __stm32_gpio_set(struct stm32_gpio_bank *bank,
@@ -216,12 +352,33 @@ static int stm32_gpio_request(struct gpio_chip *chip, unsigned offset)
 		return -EINVAL;
 	}
 
+	if (bank->rif_control) {
+		if (!stm32_gpio_rif_acquire_semaphore(bank, offset)) {
+			dev_err(pctl->dev, "pin %d not available.\n", pin);
+			return -EINVAL;
+		}
+	}
+
 	return pinctrl_gpio_request(chip->base + offset);
 }
 
 static void stm32_gpio_free(struct gpio_chip *chip, unsigned offset)
 {
+	struct stm32_gpio_bank *bank = gpiochip_get_data(chip);
+	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	unsigned int virq;
+
 	pinctrl_gpio_free(chip->base + offset);
+
+	if (bank->rif_control)
+		stm32_gpio_rif_release_semaphore(bank, offset);
+
+	virq = bank->virq[offset];
+	if (virq)
+		irq_dispose_mapping(virq);
+
+	if (bank->virq[offset])
+		dev_err(pctl->dev, "ERROR: IRQ not freed\n");
 }
 
 static int stm32_gpio_get(struct gpio_chip *chip, unsigned offset)
@@ -260,7 +417,10 @@ static int stm32_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)
 	struct stm32_gpio_bank *bank = gpiochip_get_data(chip);
 	struct irq_fwspec fwspec;
 
-	fwspec.fwnode = bank->fwnode;
+	if (bank->virq[offset])
+		return bank->virq[offset];
+
+	fwspec.fwnode = bank->gpio_chip.fwnode;
 	fwspec.param_count = 2;
 	fwspec.param[0] = offset;
 	fwspec.param[1] = IRQ_TYPE_NONE;
@@ -310,6 +470,19 @@ static int stm32_gpio_init_valid_mask(struct gpio_chip *chip,
 		}
 	}
 
+	if (bank->rif_control) {
+		for (i = 0; i < ngpios; i++) {
+			if (!test_bit(i, valid_mask))
+				continue;
+
+			if (stm32_gpio_rif_valid(bank, i))
+				continue;
+
+			dev_dbg(pctl->dev, "RIF semaphore ownership conflict, GPIO %u", i);
+			clear_bit(i, valid_mask);
+		}
+	}
+
 	return 0;
 }
 
@@ -326,9 +499,21 @@ static const struct gpio_chip stm32_gpio_template = {
 	.init_valid_mask	= stm32_gpio_init_valid_mask,
 };
 
+static struct stm32_gpio_bank *stm32_pctrl_fwnode_to_bank(struct stm32_pinctrl *pctl,
+							  struct fwnode_handle *fwnode)
+{
+	unsigned int i;
+
+	for (i = 0; i < pctl->nbanks; i++)
+		if (fwnode == pctl->banks[i].gpio_chip.fwnode)
+			return &pctl->banks[i];
+
+	return NULL;
+}
+
 static void stm32_gpio_irq_trigger(struct irq_data *d)
 {
-	struct stm32_gpio_bank *bank = d->domain->host_data;
+	struct stm32_gpio_bank *bank = d->chip_data;
 	int level;
 
 	/* Do not access the GPIO if this is not LEVEL triggered IRQ. */
@@ -350,7 +535,7 @@ static void stm32_gpio_irq_eoi(struct irq_data *d)
 
 static int stm32_gpio_set_type(struct irq_data *d, unsigned int type)
 {
-	struct stm32_gpio_bank *bank = d->domain->host_data;
+	struct stm32_gpio_bank *bank = d->chip_data;
 	u32 parent_type;
 
 	switch (type) {
@@ -376,8 +561,8 @@ static int stm32_gpio_set_type(struct irq_data *d, unsigned int type)
 
 static int stm32_gpio_irq_request_resources(struct irq_data *irq_data)
 {
-	struct stm32_gpio_bank *bank = irq_data->domain->host_data;
-	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	struct stm32_gpio_bank *bank = irq_data->chip_data;
+	struct stm32_pinctrl *pctl = irq_data->domain->host_data;
 	int ret;
 
 	ret = stm32_gpio_direction_input(&bank->gpio_chip, irq_data->hwirq);
@@ -396,7 +581,7 @@ static int stm32_gpio_irq_request_resources(struct irq_data *irq_data)
 
 static void stm32_gpio_irq_release_resources(struct irq_data *irq_data)
 {
-	struct stm32_gpio_bank *bank = irq_data->domain->host_data;
+	struct stm32_gpio_bank *bank = irq_data->chip_data;
 
 	gpiochip_unlock_as_irq(&bank->gpio_chip, irq_data->hwirq);
 }
@@ -417,8 +602,58 @@ static struct irq_chip stm32_gpio_irq_chip = {
 	.irq_set_wake	= irq_chip_set_wake_parent,
 	.irq_request_resources = stm32_gpio_irq_request_resources,
 	.irq_release_resources = stm32_gpio_irq_release_resources,
+	.irq_set_affinity = IS_ENABLED(CONFIG_SMP) ? irq_chip_set_affinity_parent : NULL,
+
 };
 
+static int stm32_gpio_domain_select(struct irq_domain *dm,
+				    struct irq_fwspec *fwspec,
+				    enum irq_domain_bus_token bus_token)
+{
+	struct fwnode_handle *fwnode = fwspec->fwnode;
+	struct stm32_pinctrl *pctl = dm->host_data;
+	struct irq_fwspec parent_fwspec;
+	struct stm32_gpio_bank *bank;
+
+	if (!fwnode ||
+	    (bus_token != DOMAIN_BUS_ANY && dm->bus_token != bus_token))
+		return 0;
+
+	bank = stm32_pctrl_fwnode_to_bank(pctl, fwnode);
+	if (!bank)
+		return 0;
+
+	if (!pctl->has_irq_extended)
+		return 1;
+
+	if (!dm->parent->ops->select)
+		return 0;
+
+	parent_fwspec.fwnode = dm->parent->fwnode;
+	parent_fwspec.param_count = 2;
+	parent_fwspec.param[0] = fwspec->param[0];
+	parent_fwspec.param[1] = (fwspec->param[1] & IRQ_TYPE_SENSE_MASK) |
+				 FIELD_PREP(STM32_GPIO_BANK_MASK, bank->bank_ioport_nr);
+
+	return dm->parent->ops->select(dm->parent, &parent_fwspec, bus_token);
+}
+
+static int stm32_gpio_domain_match(struct irq_domain *dm,
+				   struct device_node *node,
+				   enum irq_domain_bus_token bus_token)
+{
+	struct stm32_pinctrl *pctl = dm->host_data;
+
+	if (!node ||
+	    (bus_token != DOMAIN_BUS_ANY && dm->bus_token != bus_token))
+		return 0;
+
+	if (stm32_pctrl_fwnode_to_bank(pctl, of_node_to_fwnode(node)))
+		return 1;
+
+	return 0;
+}
+
 static int stm32_gpio_domain_translate(struct irq_domain *d,
 				       struct irq_fwspec *fwspec,
 				       unsigned long *hwirq,
@@ -436,9 +671,12 @@ static int stm32_gpio_domain_translate(struct irq_domain *d,
 static int stm32_gpio_domain_activate(struct irq_domain *d,
 				      struct irq_data *irq_data, bool reserve)
 {
-	struct stm32_gpio_bank *bank = d->host_data;
-	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
-	int ret = 0;
+	struct stm32_pinctrl *pctl = d->host_data;
+	struct stm32_gpio_bank *bank = irq_data->chip_data;
+	int ret;
+
+	if (!stm32_pctl_uses_syscfg(pctl))
+		return 0;
 
 	if (pctl->hwlock) {
 		ret = hwspin_lock_timeout_in_atomic(pctl->hwlock,
@@ -454,65 +692,85 @@ static int stm32_gpio_domain_activate(struct irq_domain *d,
 	if (pctl->hwlock)
 		hwspin_unlock_in_atomic(pctl->hwlock);
 
-	return ret;
+	return 0;
 }
 
 static int stm32_gpio_domain_alloc(struct irq_domain *d,
 				   unsigned int virq,
 				   unsigned int nr_irqs, void *data)
 {
-	struct stm32_gpio_bank *bank = d->host_data;
+	struct stm32_pinctrl *pctl = d->host_data;
 	struct irq_fwspec *fwspec = data;
 	struct irq_fwspec parent_fwspec;
-	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	struct stm32_gpio_bank *bank;
 	irq_hw_number_t hwirq = fwspec->param[0];
 	unsigned long flags;
 	int ret = 0;
 
-	/*
-	 * Check first that the IRQ MUX of that line is free.
-	 * gpio irq mux is shared between several banks, protect with a lock
-	 */
-	spin_lock_irqsave(&pctl->irqmux_lock, flags);
+	bank = stm32_pctrl_fwnode_to_bank(pctl, fwspec->fwnode);
 
-	if (pctl->irqmux_map & BIT(hwirq)) {
-		dev_err(pctl->dev, "irq line %ld already requested.\n", hwirq);
-		ret = -EBUSY;
-	} else {
-		pctl->irqmux_map |= BIT(hwirq);
-	}
+	if (bank->virq[hwirq])
+		return -EBUSY;
 
-	spin_unlock_irqrestore(&pctl->irqmux_lock, flags);
-	if (ret)
-		return ret;
+	if (stm32_pctl_uses_syscfg(pctl)) {
+		/*
+		 * Check first that the IRQ MUX of that line is free.
+		 * gpio irq mux is shared between several banks, protect with a lock
+		 */
+		spin_lock_irqsave(&pctl->irqmux_lock, flags);
+
+		if (pctl->irqmux_map & BIT(hwirq)) {
+			dev_err(pctl->dev, "irq line %ld already requested.\n", hwirq);
+			ret = -EBUSY;
+		} else {
+			pctl->irqmux_map |= BIT(hwirq);
+		}
+
+		spin_unlock_irqrestore(&pctl->irqmux_lock, flags);
+		if (ret)
+			return ret;
+	}
 
 	parent_fwspec.fwnode = d->parent->fwnode;
 	parent_fwspec.param_count = 2;
 	parent_fwspec.param[0] = fwspec->param[0];
-	parent_fwspec.param[1] = fwspec->param[1];
+	parent_fwspec.param[1] = (fwspec->param[1] & IRQ_TYPE_SENSE_MASK) |
+				 FIELD_PREP(STM32_GPIO_BANK_MASK, bank->bank_ioport_nr);
 
 	irq_domain_set_hwirq_and_chip(d, virq, hwirq, &stm32_gpio_irq_chip,
 				      bank);
 
-	return irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &parent_fwspec);
+	ret = irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &parent_fwspec);
+	if (ret)
+		return ret;
+
+	bank->virq[hwirq] = virq;
+
+	return 0;
 }
 
 static void stm32_gpio_domain_free(struct irq_domain *d, unsigned int virq,
 				   unsigned int nr_irqs)
 {
-	struct stm32_gpio_bank *bank = d->host_data;
-	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	struct stm32_pinctrl *pctl = d->host_data;
 	struct irq_data *irq_data = irq_domain_get_irq_data(d, virq);
+	struct stm32_gpio_bank *bank = irq_data->chip_data;
 	unsigned long flags, hwirq = irq_data->hwirq;
 
 	irq_domain_free_irqs_common(d, virq, nr_irqs);
 
-	spin_lock_irqsave(&pctl->irqmux_lock, flags);
-	pctl->irqmux_map &= ~BIT(hwirq);
-	spin_unlock_irqrestore(&pctl->irqmux_lock, flags);
+	if (stm32_pctl_uses_syscfg(pctl)) {
+		spin_lock_irqsave(&pctl->irqmux_lock, flags);
+		pctl->irqmux_map &= ~BIT(hwirq);
+		spin_unlock_irqrestore(&pctl->irqmux_lock, flags);
+	}
+
+	bank->virq[hwirq] = 0;
 }
 
 static const struct irq_domain_ops stm32_gpio_domain_ops = {
+	.select		= stm32_gpio_domain_select,
+	.match		= stm32_gpio_domain_match,
 	.translate	= stm32_gpio_domain_translate,
 	.alloc		= stm32_gpio_domain_alloc,
 	.free		= stm32_gpio_domain_free,
@@ -547,6 +805,9 @@ static bool stm32_pctrl_is_function_valid(struct stm32_pinctrl *pctl,
 		if (pin->pin.number != pin_num)
 			continue;
 
+		if (fnum == STM32_PIN_RSVD)
+			return true;
+
 		for (k = 0; k < STM32_CONFIG_NUM; k++) {
 			if (func->num == fnum)
 				return true;
@@ -849,6 +1110,11 @@ static int stm32_pmx_set_mux(struct pinctrl_dev *pctldev,
 		return -EINVAL;
 	}
 
+	if (function == STM32_PIN_RSVD) {
+		dev_dbg(pctl->dev, "Reserved pins, skipping HW update.\n");
+		return 0;
+	}
+
 	bank = gpiochip_get_data(range->gc);
 	pin = stm32_gpio_pin(g->pin);
 
@@ -1052,6 +1318,114 @@ static u32 stm32_pconf_get_bias(struct stm32_gpio_bank *bank,
 	return (val >> (offset * 2));
 }
 
+static int stm32_pconf_set_advcfgr(struct stm32_gpio_bank *bank, int offset, u32 bpos, u32 bval)
+{
+	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	int advcfgr_offset = STM32_GPIO_ADVCFGRL + (offset / 8) * 4;
+	int advcfgr_bit = bpos + (offset % 8) * 4;
+	unsigned long flags;
+	int err = 0;
+	u32 val;
+
+	if (!bank->io_sync_control)
+		return -ENOTSUPP;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	if (pctl->hwlock) {
+		err = hwspin_lock_timeout_in_atomic(pctl->hwlock, HWSPNLCK_TIMEOUT);
+		if (err) {
+			dev_err(pctl->dev, "Can't get hwspinlock\n");
+			goto unlock;
+		}
+	}
+
+	val = readl_relaxed(bank->base + advcfgr_offset);
+	val &= ~BIT(advcfgr_bit);
+	val |= bval << advcfgr_bit;
+	writel_relaxed(val, bank->base + advcfgr_offset);
+
+	if (pctl->hwlock)
+		hwspin_unlock_in_atomic(pctl->hwlock);
+
+	stm32_gpio_backup_advcfg(bank, offset, bpos, bval);
+
+unlock:
+	spin_unlock_irqrestore(&bank->lock, flags);
+
+	return err;
+}
+
+static u32 stm32_pconf_get_advcfgr(struct stm32_gpio_bank *bank, int offset, u32 bpos)
+{
+	int advcfgr_offset = STM32_GPIO_ADVCFGRL + (offset / 8) * 4;
+	int advcfgr_bit = bpos + (offset % 8) * 4;
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	val = readl_relaxed(bank->base + advcfgr_offset);
+	val &= BIT(advcfgr_bit);
+
+	spin_unlock_irqrestore(&bank->lock, flags);
+	return (val >> advcfgr_bit);
+}
+
+static int stm32_pconf_set_delay(struct stm32_gpio_bank *bank, int offset, u32 delay)
+{
+	struct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);
+	int delay_offset = STM32_GPIO_DELAYRL + (offset / 8) * 4;
+	int delay_shift = (offset % 8) * 4;
+	unsigned long flags;
+	int err = 0;
+	u32 val;
+
+	if (!bank->io_sync_control)
+		return -ENOTSUPP;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	if (pctl->hwlock) {
+		err = hwspin_lock_timeout_in_atomic(pctl->hwlock, HWSPNLCK_TIMEOUT);
+		if (err) {
+			dev_err(pctl->dev, "Can't get hwspinlock\n");
+			goto unlock;
+		}
+	}
+
+	val = readl_relaxed(bank->base + delay_offset);
+	val &= ~GENMASK(delay_shift + 3, delay_shift);
+	val |= (delay << delay_shift);
+	writel_relaxed(val, bank->base + delay_offset);
+
+	if (pctl->hwlock)
+		hwspin_unlock_in_atomic(pctl->hwlock);
+
+	stm32_gpio_backup_delay(bank, offset, delay);
+
+unlock:
+	spin_unlock_irqrestore(&bank->lock, flags);
+
+	return err;
+}
+
+static u32 stm32_pconf_get_delay(struct stm32_gpio_bank *bank, int offset)
+{
+	int delay_offset = STM32_GPIO_DELAYRL + (offset / 8) * 4;
+	int delay_shift = (offset % 8) * 4;
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&bank->lock, flags);
+
+	val = readl_relaxed(bank->base + delay_offset);
+	val &= GENMASK(delay_shift + 3, delay_shift);
+
+	spin_unlock_irqrestore(&bank->lock, flags);
+	return (val >> delay_shift);
+}
+
 static bool stm32_pconf_get(struct stm32_gpio_bank *bank,
 	unsigned int offset, bool dir)
 {
@@ -1095,7 +1469,7 @@ static int stm32_pconf_parse_conf(struct pinctrl_dev *pctldev,
 		return -EACCES;
 	}
 
-	switch (param) {
+	switch ((unsigned int)param) {
 	case PIN_CONFIG_DRIVE_PUSH_PULL:
 		ret = stm32_pconf_set_driving(bank, offset, 0);
 		break;
@@ -1118,6 +1492,25 @@ static int stm32_pconf_parse_conf(struct pinctrl_dev *pctldev,
 		__stm32_gpio_set(bank, offset, arg);
 		ret = stm32_pmx_gpio_set_direction(pctldev, range, pin, false);
 		break;
+	case STM32_GPIO_PIN_CONFIG_DELAY_PATH:
+		ret = stm32_pconf_set_advcfgr(bank, offset,
+					      STM32_GPIO_ADVCFGR_DLYPATH_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_CLK_EDGE:
+		ret = stm32_pconf_set_advcfgr(bank, offset,
+					      STM32_GPIO_ADVCFGR_DE_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_CLK_TYPE:
+		ret = stm32_pconf_set_advcfgr(bank, offset,
+					      STM32_GPIO_ADVCFGR_INVCLK_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_RETIME:
+		ret = stm32_pconf_set_advcfgr(bank, offset,
+					      STM32_GPIO_ADVCFGR_RET_POS, arg);
+		break;
+	case STM32_GPIO_PIN_CONFIG_DELAY:
+		ret = stm32_pconf_set_delay(bank, offset, arg);
+		break;
 	default:
 		ret = -ENOTSUPP;
 	}
@@ -1264,6 +1657,26 @@ static void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,
 	case 3:
 		break;
 	}
+
+	if (bank->io_sync_control) {
+		u32 retime, clk_type, clk_edge, delay_path, delay;
+
+		retime = stm32_pconf_get_advcfgr(bank, offset,
+						 STM32_GPIO_ADVCFGR_RET_POS);
+		clk_type = stm32_pconf_get_advcfgr(bank, offset,
+						   STM32_GPIO_ADVCFGR_INVCLK_POS);
+		clk_edge = stm32_pconf_get_advcfgr(bank, offset,
+						   STM32_GPIO_ADVCFGR_DE_POS);
+		delay_path = stm32_pconf_get_advcfgr(bank, offset,
+						     STM32_GPIO_ADVCFGR_DLYPATH_POS);
+		delay = stm32_pconf_get_delay(bank, offset);
+
+		if (retime || clk_type || clk_edge || delay_path || delay)
+			seq_printf(s, " - Retime:%d InvClk:%d DblEdge:%d DelayIn:%d",
+				   retime, clk_type, clk_edge, delay_path);
+		if (delay)
+			seq_printf(s, " - Delay: %d (%d ps)", delay, delay * 250);
+	}
 }
 
 static const struct pinconf_ops stm32_pconf_ops = {
@@ -1273,6 +1686,30 @@ static const struct pinconf_ops stm32_pconf_ops = {
 	.pin_config_dbg_show	= stm32_pconf_dbg_show,
 };
 
+static struct stm32_desc_pin *stm32_pctrl_get_desc_pin_from_gpio(struct stm32_pinctrl *pctl,
+								 struct stm32_gpio_bank *bank,
+								 unsigned int offset)
+{
+	unsigned int stm32_pin_nb = bank->bank_nr * STM32_GPIO_PINS_PER_BANK + offset;
+	struct stm32_desc_pin *pin_desc;
+	int i;
+
+	/* With few exceptions (e.g. bank 'Z'), pin number matches with pin index in array */
+	if (stm32_pin_nb < pctl->npins) {
+		pin_desc = pctl->pins + stm32_pin_nb;
+		if (pin_desc->pin.number == stm32_pin_nb)
+			return pin_desc;
+	}
+
+	/* Otherwise, loop all array to find the pin with the right number */
+	for (i = 0; i < pctl->npins; i++) {
+		pin_desc = pctl->pins + i;
+		if (pin_desc->pin.number == stm32_pin_nb)
+			return pin_desc;
+	}
+	return NULL;
+}
+
 static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl, struct fwnode_handle *fwnode)
 {
 	struct stm32_gpio_bank *bank = &pctl->banks[pctl->nbanks];
@@ -1283,6 +1720,8 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl, struct fwnode
 	struct resource res;
 	int npins = STM32_GPIO_PINS_PER_BANK;
 	int bank_nr, err, i = 0;
+	struct stm32_desc_pin *stm32_pin;
+	char **names;
 
 	if (!IS_ERR(bank->rstc))
 		reset_control_deassert(bank->rstc);
@@ -1336,22 +1775,21 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl, struct fwnode
 	bank->bank_nr = bank_nr;
 	bank->bank_ioport_nr = bank_ioport_nr;
 	bank->secure_control = pctl->match_data->secure_control;
+	bank->io_sync_control = pctl->match_data->io_sync_control;
+	bank->rif_control = pctl->match_data->rif_control;
 	spin_lock_init(&bank->lock);
 
-	if (pctl->domain) {
-		/* create irq hierarchical domain */
-		bank->fwnode = fwnode;
-
-		bank->domain = irq_domain_create_hierarchy(pctl->domain, 0, STM32_GPIO_IRQ_LINE,
-							   bank->fwnode, &stm32_gpio_domain_ops,
-							   bank);
-
-		if (!bank->domain) {
-			err = -ENODEV;
-			goto err_clk;
-		}
+	names = devm_kcalloc(dev, npins, sizeof(char *), GFP_KERNEL);
+	for (i = 0; i < npins; i++) {
+		stm32_pin = stm32_pctrl_get_desc_pin_from_gpio(pctl, bank, i);
+		if (stm32_pin && stm32_pin->pin.name)
+			names[i] = devm_kasprintf(dev, GFP_KERNEL, "%s", stm32_pin->pin.name);
+		else
+			names[i] = NULL;
 	}
 
+	bank->gpio_chip.names = (const char * const *)names;
+
 	err = gpiochip_add_data(&bank->gpio_chip, bank);
 	if (err) {
 		dev_err(dev, "Failed to add gpiochip(%d)!\n", bank_nr);
@@ -1366,11 +1804,79 @@ static int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl, struct fwnode
 	return err;
 }
 
-static struct irq_domain *stm32_pctrl_get_irq_domain(struct platform_device *pdev)
+static void stm32_pctrl_remove_irq(void *data)
 {
-	struct device_node *np = pdev->dev.of_node;
+	struct irq_domain *domain = data;
+	struct fwnode_handle *fwnode = domain->fwnode;
+
+	irq_domain_remove(domain);
+
+	if (is_fwnode_irqchip(fwnode))
+		irq_domain_free_fwnode(fwnode);
+}
+
+static struct irq_domain *stm32_pctrl_get_irq_domain(struct stm32_pinctrl *pctl)
+{
+	struct device_node *np = pctl->dev->of_node;
 	struct device_node *parent;
-	struct irq_domain *domain;
+	struct irq_domain *parent_domain, *domain;
+	struct of_phandle_args out_irq;
+	struct fwnode_handle *fwnode;
+	char *name;
+	int ret, i;
+
+	if (of_find_property(np, "interrupts-extended", &i)) {
+		if (i < 3) {
+			dev_err(pctl->dev, "incorrect interrupts-extended property\n");
+			return ERR_PTR(-EINVAL);
+		}
+
+		/*
+		 * Only check the first entry every 16.
+		 * Each entry has 3 values: <&phandle 0 0>
+		 */
+		i = DIV_ROUND_UP(i, 3 * STM32_GPIO_IRQ_LINE * sizeof(u32));
+
+		while (i--) {
+			ret = of_irq_parse_one(np, i * STM32_GPIO_IRQ_LINE, &out_irq);
+			if (ret)
+				return ERR_PTR(ret);
+
+			parent_domain = irq_find_host(out_irq.np);
+			of_node_put(out_irq.np);
+			if (!parent_domain)
+				return ERR_PTR(-EPROBE_DEFER);
+
+			/* as in __irq_domain_create() */
+			name = kasprintf(GFP_KERNEL, "%pOF-%d", np, i);
+			if (!name)
+				return ERR_PTR(-ENOMEM);
+			strreplace(name, '/', ':');
+
+			fwnode = irq_domain_alloc_named_fwnode(name);
+			kfree(name);
+			if (!fwnode)
+				return ERR_PTR(-ENOMEM);
+
+			domain = irq_domain_create_hierarchy(parent_domain, 0, STM32_GPIO_IRQ_LINE,
+							     fwnode, &stm32_gpio_domain_ops, pctl);
+			if (!domain) {
+				dev_err(pctl->dev, "Could not register pinctrl domain\n");
+				irq_domain_free_fwnode(fwnode);
+				return ERR_PTR(-ENXIO);
+			}
+
+			ret = devm_add_action_or_reset(pctl->dev, stm32_pctrl_remove_irq, domain);
+			if (ret) {
+				irq_domain_remove(domain);
+				irq_domain_free_fwnode(fwnode);
+				return ERR_PTR(ret);
+			}
+		}
+
+		pctl->has_irq_extended = true;
+		return domain;
+	}
 
 	if (!of_find_property(np, "interrupt-parent", NULL))
 		return NULL;
@@ -1379,12 +1885,25 @@ static struct irq_domain *stm32_pctrl_get_irq_domain(struct platform_device *pde
 	if (!parent)
 		return ERR_PTR(-ENXIO);
 
-	domain = irq_find_host(parent);
+	parent_domain = irq_find_host(parent);
 	of_node_put(parent);
-	if (!domain)
+	if (!parent_domain)
 		/* domain not registered yet */
 		return ERR_PTR(-EPROBE_DEFER);
 
+	domain = irq_domain_add_hierarchy(parent_domain, 0, STM32_GPIO_IRQ_LINE,
+					  np, &stm32_gpio_domain_ops, pctl);
+	if (!domain) {
+		dev_err(pctl->dev, "Could not register pinctrl domain\n");
+		return ERR_PTR(-ENXIO);
+	}
+
+	ret = devm_add_action_or_reset(pctl->dev, stm32_pctrl_remove_irq, domain);
+	if (ret) {
+		irq_domain_remove(domain);
+		return ERR_PTR(ret);
+	}
+
 	return domain;
 }
 
@@ -1509,8 +2028,10 @@ int stm32_pctl_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, pctl);
 
+	pctl->dev = dev;
+
 	/* check for IRQ controller (may require deferred probe) */
-	pctl->domain = stm32_pctrl_get_irq_domain(pdev);
+	pctl->domain = stm32_pctrl_get_irq_domain(pctl);
 	if (IS_ERR(pctl->domain))
 		return PTR_ERR(pctl->domain);
 	if (!pctl->domain)
@@ -1527,7 +2048,6 @@ int stm32_pctl_probe(struct platform_device *pdev)
 
 	spin_lock_init(&pctl->irqmux_lock);
 
-	pctl->dev = dev;
 	pctl->match_data = match_data;
 
 	/*  get optional package information */
@@ -1551,8 +2071,13 @@ int stm32_pctl_probe(struct platform_device *pdev)
 
 	if (pctl->domain) {
 		ret = stm32_pctrl_dt_setup_irq(pdev, pctl);
-		if (ret)
+		if (ret == -EPROBE_DEFER)
+			return ret;
+		if (ret && match_data->need_syscon)
 			return ret;
+		/* work without syscon, no legacy mode */
+		if (ret)
+			pctl->regmap = NULL;
 	}
 
 	pins = devm_kcalloc(&pdev->dev, pctl->npins, sizeof(*pins),
@@ -1571,6 +2096,8 @@ int stm32_pctl_probe(struct platform_device *pdev)
 	pctl->pctl_desc.confops = &stm32_pconf_ops;
 	pctl->pctl_desc.pctlops = &stm32_pctrl_ops;
 	pctl->pctl_desc.pmxops = &stm32_pmx_ops;
+	pctl->pctl_desc.num_custom_params = ARRAY_SIZE(stm32_gpio_bindings);
+	pctl->pctl_desc.custom_params = stm32_gpio_bindings;
 	pctl->dev = &pdev->dev;
 
 	pctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->pctl_desc,
@@ -1629,6 +2156,17 @@ int stm32_pctl_probe(struct platform_device *pdev)
 
 	return 0;
 }
+EXPORT_SYMBOL(stm32_pctl_probe);
+
+static int __maybe_unused stm32_pinctrl_restore_advcfgr(struct stm32_gpio_bank *bank,
+							int offset, u32 bpos)
+{
+	u32 val;
+
+	val = bank->pin_backup[offset] & BIT(STM32_GPIO_BKP_ADVCFG_SHIFT + bpos);
+	val >>= (STM32_GPIO_BKP_ADVCFG_SHIFT + bpos);
+	return stm32_pconf_set_advcfgr(bank, offset, bpos, val);
+}
 
 static int __maybe_unused stm32_pinctrl_restore_gpio_regs(
 					struct stm32_pinctrl *pctl, u32 pin)
@@ -1687,7 +2225,35 @@ static int __maybe_unused stm32_pinctrl_restore_gpio_regs(
 	if (ret)
 		return ret;
 
-	if (pin_is_irq)
+	if (bank->io_sync_control) {
+		ret = stm32_pinctrl_restore_advcfgr(bank, offset,
+						    STM32_GPIO_ADVCFGR_DLYPATH_POS);
+		if (ret)
+			return ret;
+
+		ret = stm32_pinctrl_restore_advcfgr(bank, offset,
+						    STM32_GPIO_ADVCFGR_DE_POS);
+		if (ret)
+			return ret;
+
+		ret = stm32_pinctrl_restore_advcfgr(bank, offset,
+						    STM32_GPIO_ADVCFGR_INVCLK_POS);
+		if (ret)
+			return ret;
+
+		ret = stm32_pinctrl_restore_advcfgr(bank, offset,
+						    STM32_GPIO_ADVCFGR_RET_POS);
+		if (ret)
+			return ret;
+
+		val = bank->pin_backup[offset] & STM32_GPIO_BKP_DELAY_MASK;
+		val >>= STM32_GPIO_BKP_DELAY_SHIFT;
+		ret = stm32_pconf_set_delay(bank, offset, val);
+		if (ret)
+			return ret;
+	}
+
+	if (stm32_pctl_uses_syscfg(pctl) && pin_is_irq)
 		regmap_field_write(pctl->irqmux[offset], bank->bank_ioport_nr);
 
 	return 0;
@@ -1703,6 +2269,7 @@ int __maybe_unused stm32_pinctrl_suspend(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL(stm32_pinctrl_suspend);
 
 int __maybe_unused stm32_pinctrl_resume(struct device *dev)
 {
@@ -1718,3 +2285,7 @@ int __maybe_unused stm32_pinctrl_resume(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL(stm32_pinctrl_resume);
+
+MODULE_DESCRIPTION("STM32 core pinctrl driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32.h b/drivers/pinctrl/stm32/pinctrl-stm32.h
index e0c31c4c8..26aba7c82 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32.h
+++ b/drivers/pinctrl/stm32/pinctrl-stm32.h
@@ -17,13 +17,17 @@
 #define STM32_PIN_GPIO		0
 #define STM32_PIN_AF(x)		((x) + 1)
 #define STM32_PIN_ANALOG	(STM32_PIN_AF(15) + 1)
-#define STM32_CONFIG_NUM	(STM32_PIN_ANALOG + 1)
+#define STM32_PIN_RSVD		(STM32_PIN_ANALOG + 1)
+#define STM32_CONFIG_NUM	(STM32_PIN_RSVD + 1)
 
 /*  package information */
 #define STM32MP_PKG_AA		BIT(0)
 #define STM32MP_PKG_AB		BIT(1)
 #define STM32MP_PKG_AC		BIT(2)
 #define STM32MP_PKG_AD		BIT(3)
+#define STM32MP_PKG_AI		BIT(8)
+#define STM32MP_PKG_AK		BIT(10)
+#define STM32MP_PKG_AL		BIT(11)
 
 struct stm32_desc_function {
 	const char *name;
@@ -60,6 +64,9 @@ struct stm32_pinctrl_match_data {
 	const struct stm32_desc_pin *pins;
 	const unsigned int npins;
 	bool secure_control;
+	bool io_sync_control;
+	bool rif_control;
+	bool need_syscon;
 };
 
 struct stm32_gpio_bank;
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32f429.c b/drivers/pinctrl/stm32/pinctrl-stm32f429.c
index 663a97113..4f3f78c97 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32f429.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32f429.c
@@ -1567,6 +1567,7 @@ static const struct stm32_desc_pin stm32f429_pins[] = {
 static struct stm32_pinctrl_match_data stm32f429_match_data = {
 	.pins = stm32f429_pins,
 	.npins = ARRAY_SIZE(stm32f429_pins),
+	.need_syscon = true,
 };
 
 static const struct of_device_id stm32f429_pctrl_match[] = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32f469.c b/drivers/pinctrl/stm32/pinctrl-stm32f469.c
index ed5397f6d..2def428eb 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32f469.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32f469.c
@@ -1553,6 +1553,7 @@ static const struct stm32_desc_pin stm32f469_pins[] = {
 static struct stm32_pinctrl_match_data stm32f469_match_data = {
 	.pins = stm32f469_pins,
 	.npins = ARRAY_SIZE(stm32f469_pins),
+	.need_syscon = true,
 };
 
 static const struct of_device_id stm32f469_pctrl_match[] = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32f746.c b/drivers/pinctrl/stm32/pinctrl-stm32f746.c
index d832aab7e..c2319f927 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32f746.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32f746.c
@@ -1662,6 +1662,7 @@ static const struct stm32_desc_pin stm32f746_pins[] = {
 static struct stm32_pinctrl_match_data stm32f746_match_data = {
 	.pins = stm32f746_pins,
 	.npins = ARRAY_SIZE(stm32f746_pins),
+	.need_syscon = true,
 };
 
 static const struct of_device_id stm32f746_pctrl_match[] = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32f769.c b/drivers/pinctrl/stm32/pinctrl-stm32f769.c
index f81c51c5a..756494fcc 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32f769.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32f769.c
@@ -1802,6 +1802,7 @@ static const struct stm32_desc_pin stm32f769_pins[] = {
 static struct stm32_pinctrl_match_data stm32f769_match_data = {
 	.pins = stm32f769_pins,
 	.npins = ARRAY_SIZE(stm32f769_pins),
+	.need_syscon = true,
 };
 
 static const struct of_device_id stm32f769_pctrl_match[] = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32h743.c b/drivers/pinctrl/stm32/pinctrl-stm32h743.c
index ffe7b5271..f18907d1c 100644
--- a/drivers/pinctrl/stm32/pinctrl-stm32h743.c
+++ b/drivers/pinctrl/stm32/pinctrl-stm32h743.c
@@ -1959,6 +1959,7 @@ static const struct stm32_desc_pin stm32h743_pins[] = {
 static struct stm32_pinctrl_match_data stm32h743_match_data = {
 	.pins = stm32h743_pins,
 	.npins = ARRAY_SIZE(stm32h743_pins),
+	.need_syscon = true,
 };
 
 static const struct of_device_id stm32h743_pctrl_match[] = {
diff --git a/drivers/pinctrl/stm32/pinctrl-stm32mp257.c b/drivers/pinctrl/stm32/pinctrl-stm32mp257.c
new file mode 100644
index 000000000..588fb5249
--- /dev/null
+++ b/drivers/pinctrl/stm32/pinctrl-stm32mp257.c
@@ -0,0 +1,2588 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#include "pinctrl-stm32.h"
+
+static const struct stm32_desc_pin stm32mp257_pins[] = {
+	STM32_PIN_PKG(
+		PINCTRL_PIN(0, "PA0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA0"),
+		STM32_FUNCTION(2, "LPTIM1_CH2"),
+		STM32_FUNCTION(3, "SPI5_RDY"),
+		STM32_FUNCTION(4, "UART8_CTS"),
+		STM32_FUNCTION(5, "SAI2_MCLK_B"),
+		STM32_FUNCTION(6, "UART5_TX"),
+		STM32_FUNCTION(7, "USART3_TX"),
+		STM32_FUNCTION(8, "TIM3_ETR"),
+		STM32_FUNCTION(9, "TIM5_CH2"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD2 ETH2_RGMII_RXD2"),
+		STM32_FUNCTION(13, "FMC_NL"),
+		STM32_FUNCTION(15, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(1, "PA1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA1"),
+		STM32_FUNCTION(3, "SPI6_MISO"),
+		STM32_FUNCTION(5, "SAI3_SD_A"),
+		STM32_FUNCTION(6, "USART1_RTS"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(8, "TIM4_CH2"),
+		STM32_FUNCTION(9, "I2C4_SDA"),
+		STM32_FUNCTION(10, "I2C6_SDA"),
+		STM32_FUNCTION(12, "LCD_R3"),
+		STM32_FUNCTION(14, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(15, "ETH3_PHY_INTN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(2, "PA2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA2"),
+		STM32_FUNCTION(2, "LPTIM2_IN1"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(6, "MDF1_SDI7"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(9, "I3C1_SDA"),
+		STM32_FUNCTION(11, "I2C1_SDA"),
+		STM32_FUNCTION(12, "LCD_B0"),
+		STM32_FUNCTION(14, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RX_CTL ETH3_RMII_CRS_DV"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(3, "PA3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA3"),
+		STM32_FUNCTION(2, "LPTIM2_ETR"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(6, "MDF1_CKI7"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(9, "I3C1_SCL"),
+		STM32_FUNCTION(10, "I2C7_SMBA"),
+		STM32_FUNCTION(11, "I2C1_SCL"),
+		STM32_FUNCTION(12, "LCD_B1"),
+		STM32_FUNCTION(14, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TX_CTL ETH3_RMII_TX_EN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(4, "PA4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA4"),
+		STM32_FUNCTION(7, "USART2_TX"),
+		STM32_FUNCTION(8, "FDCAN2_TX"),
+		STM32_FUNCTION(9, "TIM2_CH1"),
+		STM32_FUNCTION(11, "LCD_R1"),
+		STM32_FUNCTION(14, "ETH1_PTP_AUX_TS"),
+		STM32_FUNCTION(15, "ETH3_PPS_OUT"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(5, "PA5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA5"),
+		STM32_FUNCTION(4, "SPI4_MOSI"),
+		STM32_FUNCTION(5, "SAI2_MCLK_B"),
+		STM32_FUNCTION(6, "SAI2_SD_B"),
+		STM32_FUNCTION(7, "USART2_RTS"),
+		STM32_FUNCTION(8, "FDCAN2_RX"),
+		STM32_FUNCTION(9, "TIM2_CH4"),
+		STM32_FUNCTION(11, "LCD_G0"),
+		STM32_FUNCTION(13, "FMC_A0"),
+		STM32_FUNCTION(14, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RX_CLK ETH3_RMII_REF_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(6, "PA6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA6"),
+		STM32_FUNCTION(4, "SPI4_SCK"),
+		STM32_FUNCTION(5, "SAI2_FS_B"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(7, "USART2_CK"),
+		STM32_FUNCTION(8, "TIM13_CH1"),
+		STM32_FUNCTION(9, "TIM2_ETR"),
+		STM32_FUNCTION(11, "LCD_G4"),
+		STM32_FUNCTION(13, "FMC_NE1"),
+		STM32_FUNCTION(14, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD0 ETH3_RMII_TXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(7, "PA7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA7"),
+		STM32_FUNCTION(3, "AUDIOCLK"),
+		STM32_FUNCTION(4, "SPI6_RDY"),
+		STM32_FUNCTION(5, "PCIE_CLKREQN"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(8, "TIM4_ETR"),
+		STM32_FUNCTION(9, "I2C2_SMBA"),
+		STM32_FUNCTION(10, "I2C6_SMBA"),
+		STM32_FUNCTION(11, "LCD_B5"),
+		STM32_FUNCTION(12, "I2C3_SMBA"),
+		STM32_FUNCTION(13, "I2C4_SMBA"),
+		STM32_FUNCTION(14, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD1 ETH3_RMII_TXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(8, "PA8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA8"),
+		STM32_FUNCTION(2, "LPTIM2_CH2"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(5, "SAI1_FS_B"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(9, "USART2_RX"),
+		STM32_FUNCTION(10, "I2C5_SCL"),
+		STM32_FUNCTION(13, "LCD_B2"),
+		STM32_FUNCTION(14, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(9, "PA9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA9"),
+		STM32_FUNCTION(4, "SPI4_NSS"),
+		STM32_FUNCTION(5, "SAI2_SCK_B"),
+		STM32_FUNCTION(7, "USART2_CTS"),
+		STM32_FUNCTION(8, "LPTIM5_ETR"),
+		STM32_FUNCTION(9, "TIM2_CH3"),
+		STM32_FUNCTION(11, "ETH1_MDC"),
+		STM32_FUNCTION(13, "LCD_G7"),
+		STM32_FUNCTION(14, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD0 ETH3_RMII_RXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(10, "PA10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA10"),
+		STM32_FUNCTION(4, "SPI4_MISO"),
+		STM32_FUNCTION(5, "SAI2_SD_B"),
+		STM32_FUNCTION(7, "USART2_RX"),
+		STM32_FUNCTION(8, "LPTIM5_IN1"),
+		STM32_FUNCTION(9, "TIM2_CH2"),
+		STM32_FUNCTION(11, "ETH1_MDIO"),
+		STM32_FUNCTION(13, "LCD_R6"),
+		STM32_FUNCTION(14, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD1 ETH3_RMII_RXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(11, "PA11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA11"),
+		STM32_FUNCTION(2, "SPI8_SCK"),
+		STM32_FUNCTION(3, "LPTIM2_CH1"),
+		STM32_FUNCTION(5, "SAI4_SD_B"),
+		STM32_FUNCTION(6, "MDF1_SDI4"),
+		STM32_FUNCTION(11, "ETH1_MII_RX_DV ETH1_RGMII_RX_CTL ETH1_RMII_CRS_DV"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(12, "PA12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA12"),
+		STM32_FUNCTION(3, "SPI6_MOSI"),
+		STM32_FUNCTION(5, "SAI3_FS_A"),
+		STM32_FUNCTION(8, "TIM4_CH1"),
+		STM32_FUNCTION(9, "I2C4_SCL"),
+		STM32_FUNCTION(10, "I2C6_SCL"),
+		STM32_FUNCTION(11, "ETH1_PHY_INTN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(13, "PA13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA13"),
+		STM32_FUNCTION(2, "SPI8_RDY"),
+		STM32_FUNCTION(3, "I2S3_MCK"),
+		STM32_FUNCTION(4, "LPTIM2_ETR"),
+		STM32_FUNCTION(6, "MDF1_CKI3"),
+		STM32_FUNCTION(7, "USART2_CTS"),
+		STM32_FUNCTION(10, "I2C7_SMBA"),
+		STM32_FUNCTION(11, "ETH1_MII_TX_EN ETH1_RGMII_TX_CTL ETH1_RMII_TX_EN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(14, "PA14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA14"),
+		STM32_FUNCTION(2, "SPI8_NSS"),
+		STM32_FUNCTION(3, "LPTIM2_CH2"),
+		STM32_FUNCTION(5, "SAI4_FS_B"),
+		STM32_FUNCTION(6, "MDF1_CCK1"),
+		STM32_FUNCTION(11, "ETH1_MII_RX_CLK ETH1_RGMII_RX_CLK ETH1_RMII_REF_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(15, "PA15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOA15"),
+		STM32_FUNCTION(3, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(7, "USART2_RX"),
+		STM32_FUNCTION(10, "I2C7_SDA"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD0 ETH1_RGMII_TXD0 ETH1_RMII_TXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(16, "PB0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB0"),
+		STM32_FUNCTION(3, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(8, "TIM16_CH1"),
+		STM32_FUNCTION(9, "TIM20_CH4N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(17, "PB1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB1"),
+		STM32_FUNCTION(2, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(8, "TIM16_CH1N"),
+		STM32_FUNCTION(9, "TIM20_CH3N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO1"),
+		STM32_FUNCTION(13, "FMC_NCE4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(18, "PB2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB2"),
+		STM32_FUNCTION(3, "SPI2_MOSI I2S2_SDO"),
+		STM32_FUNCTION(6, "MDF1_CKI3"),
+		STM32_FUNCTION(7, "TIM17_BKIN"),
+		STM32_FUNCTION(8, "TIM16_BKIN"),
+		STM32_FUNCTION(9, "TIM20_CH2N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(19, "PB3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB3"),
+		STM32_FUNCTION(3, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_SDI3"),
+		STM32_FUNCTION(9, "TIM20_CH3"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO3"),
+		STM32_FUNCTION(13, "FMC_NCE3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(20, "PB4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB4"),
+		STM32_FUNCTION(3, "SPI2_RDY"),
+		STM32_FUNCTION(4, "UART4_CTS"),
+		STM32_FUNCTION(5, "SAI4_FS_B"),
+		STM32_FUNCTION(6, "MDF1_SDI4"),
+		STM32_FUNCTION(7, "TIM14_CH1"),
+		STM32_FUNCTION(9, "TIM20_CH2"),
+		STM32_FUNCTION(10, "I2C2_SDA"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO4"),
+		STM32_FUNCTION(14, "I3C2_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(21, "PB5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB5"),
+		STM32_FUNCTION(3, "I2S2_MCK"),
+		STM32_FUNCTION(4, "UART4_RTS"),
+		STM32_FUNCTION(5, "SAI4_SD_B"),
+		STM32_FUNCTION(6, "MDF1_CKI4"),
+		STM32_FUNCTION(9, "TIM20_CH1"),
+		STM32_FUNCTION(10, "I2C2_SCL"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO5"),
+		STM32_FUNCTION(13, "FMC_AD8 FMC_D8"),
+		STM32_FUNCTION(14, "I3C2_SCL"),
+		STM32_FUNCTION(15, "SDMMC3_D123DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(22, "PB6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB6"),
+		STM32_FUNCTION(3, "SPI2_MISO I2S2_SDI"),
+		STM32_FUNCTION(4, "UART4_RX"),
+		STM32_FUNCTION(5, "SAI4_SCK_B"),
+		STM32_FUNCTION(9, "TIM20_CH1N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO6"),
+		STM32_FUNCTION(13, "FMC_AD9 FMC_D9"),
+		STM32_FUNCTION(15, "SDMMC3_D0DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(23, "PB7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB7"),
+		STM32_FUNCTION(2, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(4, "UART4_TX"),
+		STM32_FUNCTION(5, "SAI4_MCLK_B"),
+		STM32_FUNCTION(9, "TIM20_ETR"),
+		STM32_FUNCTION(10, "TIM12_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_IO7"),
+		STM32_FUNCTION(13, "FMC_AD10 FMC_D10"),
+		STM32_FUNCTION(15, "SDMMC3_CDIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(24, "PB8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB8"),
+		STM32_FUNCTION(2, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(5, "PCIE_CLKREQN"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(8, "TIM17_CH1"),
+		STM32_FUNCTION(9, "TIM20_CH4"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_NCS1"),
+		STM32_FUNCTION(13, "FMC_AD12 FMC_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(25, "PB9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB9"),
+		STM32_FUNCTION(2, "SPI3_RDY"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM20_BKIN"),
+		STM32_FUNCTION(10, "TIM10_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_DQS"),
+		STM32_FUNCTION(12, "OCTOSPIM_P2_NCS2"),
+		STM32_FUNCTION(13, "FMC_AD13 FMC_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(26, "PB10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB10"),
+		STM32_FUNCTION(2, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(8, "TIM17_CH1N"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_CLK"),
+		STM32_FUNCTION(13, "FMC_AD15 FMC_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(27, "PB11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB11"),
+		STM32_FUNCTION(2, "I2S3_MCK"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM20_BKIN2"),
+		STM32_FUNCTION(10, "TIM12_CH2"),
+		STM32_FUNCTION(11, "OCTOSPIM_P2_NCLK"),
+		STM32_FUNCTION(12, "OCTOSPIM_P2_NCS2"),
+		STM32_FUNCTION(13, "FMC_AD14 FMC_D14"),
+		STM32_FUNCTION(14, "OCTOSPIM_P1_NCS2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(28, "PB12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB12"),
+		STM32_FUNCTION(6, "UART8_CTS"),
+		STM32_FUNCTION(8, "TIM13_CH1"),
+		STM32_FUNCTION(10, "DSI_TE"),
+		STM32_FUNCTION(11, "SDMMC3_D2"),
+		STM32_FUNCTION(12, "FMC_NWAIT"),
+		STM32_FUNCTION(15, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(29, "PB13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB13"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(5, "SAI1_SD_B"),
+		STM32_FUNCTION(6, "UART8_RX"),
+		STM32_FUNCTION(11, "SDMMC3_CK"),
+		STM32_FUNCTION(12, "FMC_AD5 FMC_D5"),
+		STM32_FUNCTION(13, "FMC_AD0 FMC_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(30, "PB14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB14"),
+		STM32_FUNCTION(3, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(6, "MDF1_CKI7"),
+		STM32_FUNCTION(7, "UART9_RX"),
+		STM32_FUNCTION(10, "TIM4_CH2"),
+		STM32_FUNCTION(11, "SDMMC3_D0"),
+		STM32_FUNCTION(12, "FMC_AD7 FMC_D7"),
+		STM32_FUNCTION(13, "FMC_AD2 FMC_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(31, "PB15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOB15"),
+		STM32_FUNCTION(2, "LPTIM1_IN2"),
+		STM32_FUNCTION(3, "SPI5_SCK"),
+		STM32_FUNCTION(4, "UART8_RTS"),
+		STM32_FUNCTION(5, "SAI2_SD_B"),
+		STM32_FUNCTION(6, "UART5_RX"),
+		STM32_FUNCTION(8, "TIM3_CH2"),
+		STM32_FUNCTION(9, "TIM5_CH1"),
+		STM32_FUNCTION(11, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(13, "FMC_A18"),
+		STM32_FUNCTION(14, "LCD_R4"),
+		STM32_FUNCTION(15, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(32, "PC0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC0"),
+		STM32_FUNCTION(2, "LPTIM1_CH1"),
+		STM32_FUNCTION(4, "SPI6_SCK"),
+		STM32_FUNCTION(5, "SAI3_MCLK_B"),
+		STM32_FUNCTION(6, "USART6_TX"),
+		STM32_FUNCTION(10, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_CLK ETH2_RGMII_RX_CLK ETH2_RMII_REF_CLK"),
+		STM32_FUNCTION(12, "ETH1_MII_TX_CLK"),
+		STM32_FUNCTION(13, "ETH1_RGMII_GTX_CLK"),
+		STM32_FUNCTION(14, "LCD_G7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(33, "PC1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC1"),
+		STM32_FUNCTION(3, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(7, "USART2_TX"),
+		STM32_FUNCTION(10, "I2C7_SCL"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD1 ETH1_RGMII_TXD1 ETH1_RMII_TXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(34, "PC2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC2"),
+		STM32_FUNCTION(2, "SPI8_MOSI"),
+		STM32_FUNCTION(3, "LPTIM2_IN1"),
+		STM32_FUNCTION(5, "SAI4_MCLK_B"),
+		STM32_FUNCTION(6, "MDF1_SDI3"),
+		STM32_FUNCTION(7, "USART2_RTS"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD1 ETH1_RGMII_RXD1 ETH1_RMII_RXD1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(35, "PC3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC3"),
+		STM32_FUNCTION(2, "LPTIM1_IN2"),
+		STM32_FUNCTION(3, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(4, "SPI6_RDY"),
+		STM32_FUNCTION(7, "USART6_RTS"),
+		STM32_FUNCTION(8, "FDCAN2_TX"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_DV ETH2_RGMII_RX_CTL ETH2_RMII_CRS_DV"),
+		STM32_FUNCTION(12, "ETH1_MII_RX_ER"),
+		STM32_FUNCTION(14, "LCD_G6"),
+		STM32_FUNCTION(15, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(36, "PC4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC4"),
+		STM32_FUNCTION(4, "SPI6_MISO"),
+		STM32_FUNCTION(5, "SAI3_FS_B"),
+		STM32_FUNCTION(11, "ETH2_MII_TX_EN ETH2_RGMII_TX_CTL ETH2_RMII_TX_EN"),
+		STM32_FUNCTION(13, "ETH1_RGMII_CLK125"),
+		STM32_FUNCTION(14, "LCD_R0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(37, "PC5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC5"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN1"),
+		STM32_FUNCTION(6, "MDF1_SDI1"),
+		STM32_FUNCTION(9, "TIM8_CH1N"),
+		STM32_FUNCTION(10, "I2C4_SDA"),
+		STM32_FUNCTION(11, "ETH2_MDIO"),
+		STM32_FUNCTION(12, "ETH1_MII_COL"),
+		STM32_FUNCTION(13, "FMC_A25"),
+		STM32_FUNCTION(14, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(15, "LCD_DE"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(38, "PC6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC6"),
+		STM32_FUNCTION(2, "RTC_REFIN"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN0"),
+		STM32_FUNCTION(6, "MDF1_CKI1"),
+		STM32_FUNCTION(9, "TIM8_CH1"),
+		STM32_FUNCTION(10, "I2C4_SCL"),
+		STM32_FUNCTION(11, "ETH2_MDC"),
+		STM32_FUNCTION(12, "ETH1_MII_CRS"),
+		STM32_FUNCTION(13, "FMC_A24"),
+		STM32_FUNCTION(14, "ETH1_PHY_INTN"),
+		STM32_FUNCTION(15, "LCD_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(39, "PC7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC7"),
+		STM32_FUNCTION(4, "SPI6_MOSI"),
+		STM32_FUNCTION(5, "SAI3_SD_B"),
+		STM32_FUNCTION(9, "TIM8_CH2N"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD0 ETH2_RGMII_TXD0 ETH2_RMII_TXD0"),
+		STM32_FUNCTION(12, "ETH1_MII_TXD2 ETH1_RGMII_TXD2"),
+		STM32_FUNCTION(14, "LCD_B4"),
+		STM32_FUNCTION(15, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(40, "PC8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC8"),
+		STM32_FUNCTION(2, "LPTIM1_ETR"),
+		STM32_FUNCTION(4, "SPI6_NSS"),
+		STM32_FUNCTION(5, "SAI3_SCK_B"),
+		STM32_FUNCTION(7, "USART6_CTS"),
+		STM32_FUNCTION(9, "TIM8_CH2"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD1 ETH2_RGMII_TXD1 ETH2_RMII_TXD1"),
+		STM32_FUNCTION(12, "ETH1_MII_TXD3 ETH1_RGMII_TXD3"),
+		STM32_FUNCTION(14, "LCD_B3"),
+		STM32_FUNCTION(15, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(41, "PC9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC9"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(3, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(5, "SAI2_SCK_A"),
+		STM32_FUNCTION(8, "TIM13_CH1"),
+		STM32_FUNCTION(9, "TIM8_CH4N"),
+		STM32_FUNCTION(10, "USBH_HS_OVRCUR"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD2 ETH2_RGMII_TXD2"),
+		STM32_FUNCTION(12, "USB3DR_OVRCUR"),
+		STM32_FUNCTION(13, "FMC_A22"),
+		STM32_FUNCTION(14, "LCD_G2"),
+		STM32_FUNCTION(15, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(42, "PC10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC10"),
+		STM32_FUNCTION(3, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(8, "LPTIM4_ETR"),
+		STM32_FUNCTION(9, "TIM8_CH4"),
+		STM32_FUNCTION(10, "USBH_HS_VBUSEN"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD3 ETH2_RGMII_TXD3"),
+		STM32_FUNCTION(12, "USB3DR_VBUSEN"),
+		STM32_FUNCTION(13, "FMC_A23"),
+		STM32_FUNCTION(14, "LCD_G3"),
+		STM32_FUNCTION(15, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(43, "PC11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC11"),
+		STM32_FUNCTION(2, "LPTIM1_CH1"),
+		STM32_FUNCTION(3, "SPI5_NSS"),
+		STM32_FUNCTION(5, "SAI2_MCLK_A"),
+		STM32_FUNCTION(6, "UART5_RTS"),
+		STM32_FUNCTION(7, "USART3_RTS"),
+		STM32_FUNCTION(8, "TIM3_CH1"),
+		STM32_FUNCTION(9, "TIM5_ETR"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD3 ETH2_RGMII_RXD3"),
+		STM32_FUNCTION(13, "FMC_NBL1"),
+		STM32_FUNCTION(14, "LCD_R2"),
+		STM32_FUNCTION(15, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(44, "PC12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC12"),
+		STM32_FUNCTION(2, "LPTIM1_CH2"),
+		STM32_FUNCTION(4, "I3C3_SCL"),
+		STM32_FUNCTION(6, "MDF1_CKI2"),
+		STM32_FUNCTION(9, "TIM8_CH3"),
+		STM32_FUNCTION(10, "I2C3_SCL"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD1 ETH2_RGMII_RXD1 ETH2_RMII_RXD1"),
+		STM32_FUNCTION(12, "ETH1_MII_RXD3 ETH1_RGMII_RXD3"),
+		STM32_FUNCTION(14, "LCD_G1"),
+		STM32_FUNCTION(15, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(45, "PC13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOC13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(48, "PD0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD0"),
+		STM32_FUNCTION(1, "TRACECLK"),
+		STM32_FUNCTION(2, "HDP0"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(4, "SAI1_D2"),
+		STM32_FUNCTION(6, "SAI4_FS_A"),
+		STM32_FUNCTION(7, "UART7_RX"),
+		STM32_FUNCTION(8, "TIM15_CH2"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_CLK"),
+		STM32_FUNCTION(14, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(49, "PD1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD1"),
+		STM32_FUNCTION(2, "HDP1"),
+		STM32_FUNCTION(3, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(4, "SAI1_CK2"),
+		STM32_FUNCTION(6, "SAI4_SD_A"),
+		STM32_FUNCTION(7, "UART7_RTS"),
+		STM32_FUNCTION(8, "TIM15_CH1"),
+		STM32_FUNCTION(9, "TIM1_BKIN"),
+		STM32_FUNCTION(10, "FDCAN3_RX"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_NCLK"),
+		STM32_FUNCTION(12, "OCTOSPIM_P1_NCS2"),
+		STM32_FUNCTION(13, "OCTOSPIM_P2_NCS2"),
+		STM32_FUNCTION(14, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(50, "PD2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD2"),
+		STM32_FUNCTION(2, "HDP2"),
+		STM32_FUNCTION(3, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(4, "SAI1_CK1"),
+		STM32_FUNCTION(6, "SAI4_SCK_A"),
+		STM32_FUNCTION(7, "UART7_CTS"),
+		STM32_FUNCTION(8, "TIM15_BKIN"),
+		STM32_FUNCTION(9, "TIM1_ETR"),
+		STM32_FUNCTION(10, "FDCAN3_TX"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_DQS"),
+		STM32_FUNCTION(12, "OCTOSPIM_P1_NCS2"),
+		STM32_FUNCTION(14, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(51, "PD3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD3"),
+		STM32_FUNCTION(2, "SAI1_MCLK_A"),
+		STM32_FUNCTION(3, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(4, "SAI1_D1"),
+		STM32_FUNCTION(6, "SAI4_MCLK_A"),
+		STM32_FUNCTION(7, "UART7_TX"),
+		STM32_FUNCTION(8, "TIM15_CH1N"),
+		STM32_FUNCTION(9, "TIM1_BKIN2"),
+		STM32_FUNCTION(10, "SDVSEL2"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_NCS1"),
+		STM32_FUNCTION(14, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(52, "PD4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD4"),
+		STM32_FUNCTION(1, "TRACED0"),
+		STM32_FUNCTION(2, "SPI4_MISO"),
+		STM32_FUNCTION(3, "HDP3"),
+		STM32_FUNCTION(4, "SAI1_D3"),
+		STM32_FUNCTION(5, "SAI1_SD_B"),
+		STM32_FUNCTION(9, "TIM1_CH4N"),
+		STM32_FUNCTION(10, "TIM4_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO0"),
+		STM32_FUNCTION(14, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(53, "PD5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD5"),
+		STM32_FUNCTION(1, "TRACED1"),
+		STM32_FUNCTION(2, "SPI4_NSS"),
+		STM32_FUNCTION(3, "HDP4"),
+		STM32_FUNCTION(4, "SAI1_D4"),
+		STM32_FUNCTION(5, "SAI1_FS_B"),
+		STM32_FUNCTION(9, "TIM1_CH3N"),
+		STM32_FUNCTION(10, "TIM4_CH2"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO1"),
+		STM32_FUNCTION(14, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(54, "PD6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD6"),
+		STM32_FUNCTION(1, "TRACED2"),
+		STM32_FUNCTION(2, "SPI4_MOSI"),
+		STM32_FUNCTION(3, "HDP5"),
+		STM32_FUNCTION(5, "SAI1_SCK_B"),
+		STM32_FUNCTION(6, "MDF1_SDI2"),
+		STM32_FUNCTION(9, "TIM1_CH2N"),
+		STM32_FUNCTION(10, "TIM4_CH3"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO2"),
+		STM32_FUNCTION(14, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(55, "PD7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD7"),
+		STM32_FUNCTION(1, "TRACED3"),
+		STM32_FUNCTION(2, "SPI4_SCK"),
+		STM32_FUNCTION(3, "SPI1_RDY"),
+		STM32_FUNCTION(5, "SAI1_MCLK_B"),
+		STM32_FUNCTION(6, "MDF1_CKI2"),
+		STM32_FUNCTION(9, "TIM1_CH1N"),
+		STM32_FUNCTION(10, "TIM4_CH4"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO3"),
+		STM32_FUNCTION(14, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(56, "PD8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD8"),
+		STM32_FUNCTION(1, "TRACED4"),
+		STM32_FUNCTION(2, "SPI4_RDY"),
+		STM32_FUNCTION(3, "I2S1_MCK"),
+		STM32_FUNCTION(4, "SAI1_FS_A"),
+		STM32_FUNCTION(5, "UART4_CTS"),
+		STM32_FUNCTION(6, "MDF1_SDI1"),
+		STM32_FUNCTION(9, "TIM1_CH4"),
+		STM32_FUNCTION(10, "TIM4_ETR"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO4"),
+		STM32_FUNCTION(12, "SDMMC1_D7"),
+		STM32_FUNCTION(13, "SDMMC1_D123DIR"),
+		STM32_FUNCTION(14, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(57, "PD9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD9"),
+		STM32_FUNCTION(1, "TRACED5"),
+		STM32_FUNCTION(2, "HDP6"),
+		STM32_FUNCTION(3, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(4, "SAI1_SD_A"),
+		STM32_FUNCTION(5, "UART4_RTS"),
+		STM32_FUNCTION(6, "MDF1_CKI1"),
+		STM32_FUNCTION(9, "TIM1_CH3"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO5"),
+		STM32_FUNCTION(12, "SDMMC1_D6"),
+		STM32_FUNCTION(13, "SDMMC1_D0DIR"),
+		STM32_FUNCTION(14, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(58, "PD10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD10"),
+		STM32_FUNCTION(1, "TRACED6"),
+		STM32_FUNCTION(2, "HDP7"),
+		STM32_FUNCTION(4, "SAI1_SCK_A"),
+		STM32_FUNCTION(5, "UART4_RX"),
+		STM32_FUNCTION(6, "MDF1_SDI0"),
+		STM32_FUNCTION(7, "I2C4_SDA"),
+		STM32_FUNCTION(9, "TIM1_CH2"),
+		STM32_FUNCTION(10, "TIM14_CH1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO6"),
+		STM32_FUNCTION(12, "SDMMC1_D5"),
+		STM32_FUNCTION(13, "SDMMC1_CDIR"),
+		STM32_FUNCTION(14, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(59, "PD11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD11"),
+		STM32_FUNCTION(1, "TRACED7"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SAI1_MCLK_A"),
+		STM32_FUNCTION(5, "UART4_TX"),
+		STM32_FUNCTION(6, "MDF1_CKI0"),
+		STM32_FUNCTION(7, "I2C4_SCL"),
+		STM32_FUNCTION(9, "TIM1_CH1"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(11, "OCTOSPIM_P1_IO7"),
+		STM32_FUNCTION(12, "SDMMC1_D4"),
+		STM32_FUNCTION(13, "SDMMC1_CKIN"),
+		STM32_FUNCTION(14, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(60, "PD12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD12"),
+		STM32_FUNCTION(2, "SPI7_MISO"),
+		STM32_FUNCTION(3, "SPI2_MISO I2S2_SDI"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN2"),
+		STM32_FUNCTION(6, "UART8_RTS"),
+		STM32_FUNCTION(10, "TIM4_ETR"),
+		STM32_FUNCTION(11, "SDMMC3_CMD"),
+		STM32_FUNCTION(12, "FMC_AD6 FMC_D6"),
+		STM32_FUNCTION(13, "FMC_AD1 FMC_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(61, "PD13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD13"),
+		STM32_FUNCTION(3, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_SDI7"),
+		STM32_FUNCTION(7, "UART9_TX"),
+		STM32_FUNCTION(10, "TIM4_CH4"),
+		STM32_FUNCTION(11, "SDMMC3_D1"),
+		STM32_FUNCTION(12, "FMC_AD11 FMC_D11"),
+		STM32_FUNCTION(13, "FMC_NWE"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(62, "PD14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD14"),
+		STM32_FUNCTION(3, "I2S1_MCK"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(11, "I2C7_SDA"),
+		STM32_FUNCTION(12, "FMC_AD4 FMC_D4"),
+		STM32_FUNCTION(13, "SDMMC3_D3"),
+		STM32_FUNCTION(14, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(63, "PD15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOD15"),
+		STM32_FUNCTION(2, "SPI1_RDY"),
+		STM32_FUNCTION(6, "DSI_TE"),
+		STM32_FUNCTION(7, "I2C5_SDA"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM1_BKIN2"),
+		STM32_FUNCTION(10, "TIM5_ETR"),
+		STM32_FUNCTION(11, "I2C7_SCL"),
+		STM32_FUNCTION(12, "FMC_AD3 FMC_D3"),
+		STM32_FUNCTION(13, "SDMMC3_CKIN"),
+		STM32_FUNCTION(14, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(64, "PE0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE0"),
+		STM32_FUNCTION(1, "TRACED2"),
+		STM32_FUNCTION(2, "LPTIM2_CH1"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SPI3_RDY"),
+		STM32_FUNCTION(7, "USART3_CK"),
+		STM32_FUNCTION(11, "SDMMC1_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(65, "PE1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE1"),
+		STM32_FUNCTION(1, "TRACED3"),
+		STM32_FUNCTION(2, "LPTIM2_CH2"),
+		STM32_FUNCTION(3, "I2S1_MCK"),
+		STM32_FUNCTION(4, "I2S3_MCK"),
+		STM32_FUNCTION(7, "USART3_RX"),
+		STM32_FUNCTION(11, "SDMMC1_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(66, "PE2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE2"),
+		STM32_FUNCTION(2, "LPTIM2_ETR"),
+		STM32_FUNCTION(3, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(4, "SPI3_MOSI I2S3_SDO"),
+		STM32_FUNCTION(5, "SAI1_SCK_B"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(11, "SDMMC1_CMD"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(67, "PE3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE3"),
+		STM32_FUNCTION(1, "TRACECLK"),
+		STM32_FUNCTION(3, "SPI1_RDY"),
+		STM32_FUNCTION(4, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(5, "SAI1_MCLK_B"),
+		STM32_FUNCTION(7, "USART3_TX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(11, "SDMMC1_CK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(68, "PE4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE4"),
+		STM32_FUNCTION(1, "TRACED0"),
+		STM32_FUNCTION(2, "LPTIM2_IN1"),
+		STM32_FUNCTION(3, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(4, "SPI3_MISO I2S3_SDI"),
+		STM32_FUNCTION(5, "SAI1_SD_B"),
+		STM32_FUNCTION(7, "USART3_CTS"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(11, "SDMMC1_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(69, "PE5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE5"),
+		STM32_FUNCTION(1, "TRACED1"),
+		STM32_FUNCTION(2, "LPTIM2_IN2"),
+		STM32_FUNCTION(3, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(4, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(5, "SAI1_FS_B"),
+		STM32_FUNCTION(7, "USART3_RTS"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(11, "SDMMC1_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(70, "PE6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE6"),
+		STM32_FUNCTION(2, "SPI4_RDY"),
+		STM32_FUNCTION(5, "SPDIFRX1_IN2"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(9, "TIM1_ETR"),
+		STM32_FUNCTION(12, "FMC_AD1 FMC_D1"),
+		STM32_FUNCTION(13, "SDMMC2_D6"),
+		STM32_FUNCTION(14, "SDMMC2_D0DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(71, "PE7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE7"),
+		STM32_FUNCTION(4, "SAI4_D4"),
+		STM32_FUNCTION(5, "SPDIFRX1_IN3"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(9, "TIM1_CH4N"),
+		STM32_FUNCTION(11, "TIM14_CH1"),
+		STM32_FUNCTION(12, "FMC_AD2 FMC_D2"),
+		STM32_FUNCTION(13, "SDMMC2_D7"),
+		STM32_FUNCTION(14, "SDMMC2_D123DIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(72, "PE8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE8"),
+		STM32_FUNCTION(2, "SPI4_MOSI"),
+		STM32_FUNCTION(4, "SAI4_CK1"),
+		STM32_FUNCTION(5, "SAI4_MCLK_A"),
+		STM32_FUNCTION(6, "MDF1_CKI0"),
+		STM32_FUNCTION(9, "TIM1_CH1"),
+		STM32_FUNCTION(12, "FMC_A17 FMC_ALE"),
+		STM32_FUNCTION(13, "SDMMC2_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(73, "PE9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE9"),
+		STM32_FUNCTION(2, "SPI4_MISO"),
+		STM32_FUNCTION(4, "SAI4_D2"),
+		STM32_FUNCTION(5, "SAI4_FS_A"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(9, "TIM1_CH4"),
+		STM32_FUNCTION(12, "FMC_AD0 FMC_D0"),
+		STM32_FUNCTION(13, "SDMMC2_D5"),
+		STM32_FUNCTION(14, "SDMMC2_CDIR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(74, "PE10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE10"),
+		STM32_FUNCTION(2, "SPI4_SCK"),
+		STM32_FUNCTION(4, "SAI4_D1"),
+		STM32_FUNCTION(5, "SAI4_SD_A"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(9, "TIM1_CH3"),
+		STM32_FUNCTION(11, "FMC_NE3"),
+		STM32_FUNCTION(12, "FMC_NCE2"),
+		STM32_FUNCTION(13, "SDMMC2_D4"),
+		STM32_FUNCTION(14, "SDMMC2_CKIN"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(75, "PE11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE11"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(4, "SAI4_D3"),
+		STM32_FUNCTION(5, "SAI1_FS_A"),
+		STM32_FUNCTION(8, "TIM15_CH2"),
+		STM32_FUNCTION(9, "TIM1_CH3N"),
+		STM32_FUNCTION(12, "FMC_A16 FMC_CLE"),
+		STM32_FUNCTION(13, "SDMMC2_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(76, "PE12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE12"),
+		STM32_FUNCTION(2, "SPI4_NSS"),
+		STM32_FUNCTION(4, "SAI4_CK2"),
+		STM32_FUNCTION(5, "SAI4_SCK_A"),
+		STM32_FUNCTION(6, "MDF1_SDI0"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(9, "TIM1_CH2"),
+		STM32_FUNCTION(11, "FMC_NE2"),
+		STM32_FUNCTION(12, "FMC_NCE1"),
+		STM32_FUNCTION(13, "SDMMC2_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(77, "PE13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE13"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(5, "SAI1_SD_A"),
+		STM32_FUNCTION(8, "TIM15_CH1"),
+		STM32_FUNCTION(9, "TIM1_CH2N"),
+		STM32_FUNCTION(12, "FMC_RNB"),
+		STM32_FUNCTION(13, "SDMMC2_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(78, "PE14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE14"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(5, "SAI1_MCLK_A"),
+		STM32_FUNCTION(6, "MDF1_CKI6"),
+		STM32_FUNCTION(8, "TIM15_BKIN"),
+		STM32_FUNCTION(9, "TIM1_BKIN"),
+		STM32_FUNCTION(12, "FMC_NWE"),
+		STM32_FUNCTION(13, "SDMMC2_CK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(79, "PE15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOE15"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(5, "SAI1_SCK_A"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(8, "TIM15_CH1N"),
+		STM32_FUNCTION(9, "TIM1_CH1N"),
+		STM32_FUNCTION(12, "FMC_NOE"),
+		STM32_FUNCTION(13, "SDMMC2_CMD"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(80, "PF0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF0"),
+		STM32_FUNCTION(3, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(8, "FDCAN2_RX"),
+		STM32_FUNCTION(9, "TIM12_CH2"),
+		STM32_FUNCTION(10, "I2C2_SDA"),
+		STM32_FUNCTION(11, "ETH1_MDC"),
+		STM32_FUNCTION(12, "ETH2_MII_CRS"),
+		STM32_FUNCTION(14, "I3C2_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(81, "PF1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF1"),
+		STM32_FUNCTION(2, "SPI8_MISO"),
+		STM32_FUNCTION(3, "LPTIM2_IN2"),
+		STM32_FUNCTION(5, "SAI4_SCK_B"),
+		STM32_FUNCTION(6, "MDF1_CKI4"),
+		STM32_FUNCTION(7, "USART2_CK"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD0 ETH1_RGMII_RXD0 ETH1_RMII_RXD0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(82, "PF2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF2"),
+		STM32_FUNCTION(3, "SPI3_RDY"),
+		STM32_FUNCTION(7, "I2C4_SMBA"),
+		STM32_FUNCTION(9, "TIM12_CH1"),
+		STM32_FUNCTION(10, "I2C2_SCL"),
+		STM32_FUNCTION(11, "ETH1_MDIO"),
+		STM32_FUNCTION(12, "ETH2_MII_COL"),
+		STM32_FUNCTION(13, "FMC_NE4"),
+		STM32_FUNCTION(14, "I3C2_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(83, "PF3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF3"),
+		STM32_FUNCTION(4, "UART8_RX"),
+		STM32_FUNCTION(5, "SAI2_SCK_B"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(8, "TIM3_CH4"),
+		STM32_FUNCTION(9, "TIM8_BKIN2"),
+		STM32_FUNCTION(10, "ETH1_CLK"),
+		STM32_FUNCTION(11, "ETH2_PPS_OUT"),
+		STM32_FUNCTION(13, "FMC_A20"),
+		STM32_FUNCTION(14, "LCD_R6"),
+		STM32_FUNCTION(15, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(84, "PF4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF4"),
+		STM32_FUNCTION(2, "RTC_OUT2"),
+		STM32_FUNCTION(3, "SPI6_NSS"),
+		STM32_FUNCTION(5, "SAI3_SCK_A"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(8, "TIM4_CH4"),
+		STM32_FUNCTION(9, "ETH1_MDC"),
+		STM32_FUNCTION(10, "ETH2_CLK"),
+		STM32_FUNCTION(11, "ETH2_PPS_OUT"),
+		STM32_FUNCTION(12, "ETH1_PPS_OUT"),
+		STM32_FUNCTION(14, "LCD_B7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(85, "PF5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF5"),
+		STM32_FUNCTION(3, "SPI6_SCK"),
+		STM32_FUNCTION(5, "SAI3_MCLK_A"),
+		STM32_FUNCTION(7, "USART6_TX"),
+		STM32_FUNCTION(8, "TIM4_CH3"),
+		STM32_FUNCTION(9, "ETH1_MDIO"),
+		STM32_FUNCTION(10, "ETH1_CLK"),
+		STM32_FUNCTION(11, "ETH2_PHY_INTN"),
+		STM32_FUNCTION(12, "ETH1_PHY_INTN"),
+		STM32_FUNCTION(14, "LCD_B6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(86, "PF6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF6"),
+		STM32_FUNCTION(2, "RTC_OUT2"),
+		STM32_FUNCTION(4, "SAI3_MCLK_B"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(8, "TIM12_CH1"),
+		STM32_FUNCTION(10, "I2C3_SMBA"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_CLK ETH2_RGMII_RX_CLK ETH2_RMII_REF_CLK"),
+		STM32_FUNCTION(14, "LCD_B0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(87, "PF7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF7"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN1"),
+		STM32_FUNCTION(4, "SPI6_SCK"),
+		STM32_FUNCTION(5, "SAI3_SD_A"),
+		STM32_FUNCTION(8, "TIM2_ETR"),
+		STM32_FUNCTION(11, "ETH2_RGMII_GTX_CLK"),
+		STM32_FUNCTION(12, "ETH2_MII_TX_CLK"),
+		STM32_FUNCTION(14, "LCD_R1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(88, "PF8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF8"),
+		STM32_FUNCTION(2, "RTC_REFIN"),
+		STM32_FUNCTION(4, "SAI3_SCK_B"),
+		STM32_FUNCTION(7, "USART3_RX"),
+		STM32_FUNCTION(8, "TIM12_CH2"),
+		STM32_FUNCTION(10, "ETH1_CLK"),
+		STM32_FUNCTION(11, "ETH2_RGMII_CLK125"),
+		STM32_FUNCTION(12, "ETH2_MII_RX_ER"),
+		STM32_FUNCTION(13, "ETH2_MII_RX_DV ETH2_RGMII_RX_CTL ETH2_RMII_CRS_DV"),
+		STM32_FUNCTION(14, "LCD_G0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(89, "PF9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF9"),
+		STM32_FUNCTION(4, "SAI3_SD_B"),
+		STM32_FUNCTION(5, "SAI2_SD_A"),
+		STM32_FUNCTION(6, "MDF1_SDI5"),
+		STM32_FUNCTION(7, "UART8_RTS"),
+		STM32_FUNCTION(8, "TIM2_CH2"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD2 ETH2_RGMII_RXD2"),
+		STM32_FUNCTION(12, "ETH2_MDIO"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(90, "PF10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF10"),
+		STM32_FUNCTION(2, "MCO2"),
+		STM32_FUNCTION(3, "SPI3_RDY"),
+		STM32_FUNCTION(5, "SAI2_MCLK_A"),
+		STM32_FUNCTION(6, "MDF1_CKI6"),
+		STM32_FUNCTION(7, "UART8_TX"),
+		STM32_FUNCTION(8, "TIM2_CH3"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD2 ETH2_RGMII_TXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(91, "PF11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF11"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(3, "SPDIFRX1_IN0"),
+		STM32_FUNCTION(4, "SPI6_RDY"),
+		STM32_FUNCTION(5, "SAI2_SCK_A"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(7, "UART8_RX"),
+		STM32_FUNCTION(8, "TIM2_CH4"),
+		STM32_FUNCTION(11, "ETH2_MII_TXD3 ETH2_RGMII_TXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(92, "PF12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF12"),
+		STM32_FUNCTION(1, "TRACECLK"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(4, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(7, "UART9_RTS"),
+		STM32_FUNCTION(9, "TIM5_CH1"),
+		STM32_FUNCTION(14, "LCD_CLK"),
+		STM32_FUNCTION(15, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(93, "PF13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF13"),
+		STM32_FUNCTION(1, "TRACED0"),
+		STM32_FUNCTION(2, "HDP0"),
+		STM32_FUNCTION(3, "AUDIOCLK"),
+		STM32_FUNCTION(4, "USART6_TX"),
+		STM32_FUNCTION(5, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_CKI7"),
+		STM32_FUNCTION(7, "USART3_CTS"),
+		STM32_FUNCTION(8, "FDCAN3_TX"),
+		STM32_FUNCTION(9, "TIM3_CH3"),
+		STM32_FUNCTION(14, "LCD_R2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(94, "PF14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF14"),
+		STM32_FUNCTION(1, "TRACED1"),
+		STM32_FUNCTION(2, "HDP1"),
+		STM32_FUNCTION(4, "USART6_RX"),
+		STM32_FUNCTION(6, "MDF1_SDI7"),
+		STM32_FUNCTION(7, "USART3_RTS"),
+		STM32_FUNCTION(8, "FDCAN3_RX"),
+		STM32_FUNCTION(9, "TIM3_CH4"),
+		STM32_FUNCTION(14, "LCD_R3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(95, "PF15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOF15"),
+		STM32_FUNCTION(1, "TRACED2"),
+		STM32_FUNCTION(2, "HDP2"),
+		STM32_FUNCTION(3, "SPI2_RDY"),
+		STM32_FUNCTION(4, "USART6_CTS"),
+		STM32_FUNCTION(5, "SPI2_SCK I2S2_CK"),
+		STM32_FUNCTION(7, "USART3_CK"),
+		STM32_FUNCTION(8, "TIM2_CH2"),
+		STM32_FUNCTION(9, "TIM3_ETR"),
+		STM32_FUNCTION(10, "I2C6_SMBA"),
+		STM32_FUNCTION(14, "LCD_R4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(96, "PG0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG0"),
+		STM32_FUNCTION(2, "LPTIM1_IN1"),
+		STM32_FUNCTION(4, "I3C3_SDA"),
+		STM32_FUNCTION(6, "MDF1_SDI2"),
+		STM32_FUNCTION(9, "TIM8_CH3N"),
+		STM32_FUNCTION(10, "I2C3_SDA"),
+		STM32_FUNCTION(11, "ETH2_MII_RXD0 ETH2_RGMII_RXD0 ETH2_RMII_RXD0"),
+		STM32_FUNCTION(12, "ETH1_MII_RXD2 ETH1_RGMII_RXD2"),
+		STM32_FUNCTION(14, "LCD_G5"),
+		STM32_FUNCTION(15, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(97, "PG1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG1"),
+		STM32_FUNCTION(2, "LPTIM1_IN1"),
+		STM32_FUNCTION(3, "I2S3_MCK"),
+		STM32_FUNCTION(4, "I3C3_SCL"),
+		STM32_FUNCTION(5, "SAI2_SD_A"),
+		STM32_FUNCTION(6, "UART5_CTS"),
+		STM32_FUNCTION(7, "USART3_CTS"),
+		STM32_FUNCTION(9, "TIM5_CH4"),
+		STM32_FUNCTION(10, "I2C3_SCL"),
+		STM32_FUNCTION(11, "ETH2_MII_RX_ER"),
+		STM32_FUNCTION(12, "ETH2_MII_RXD3 ETH2_RGMII_RXD3"),
+		STM32_FUNCTION(13, "FMC_NBL0"),
+		STM32_FUNCTION(14, "LCD_VSYNC"),
+		STM32_FUNCTION(15, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(98, "PG2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG2"),
+		STM32_FUNCTION(2, "RTC_REFIN"),
+		STM32_FUNCTION(3, "I2S3_MCK"),
+		STM32_FUNCTION(4, "I3C3_SDA"),
+		STM32_FUNCTION(5, "SAI2_FS_A"),
+		STM32_FUNCTION(7, "USART3_CK"),
+		STM32_FUNCTION(9, "TIM5_CH3"),
+		STM32_FUNCTION(10, "I2C3_SDA"),
+		STM32_FUNCTION(11, "ETH2_MII_TX_CLK"),
+		STM32_FUNCTION(12, "ETH2_RGMII_CLK125"),
+		STM32_FUNCTION(13, "FMC_CLK"),
+		STM32_FUNCTION(14, "LCD_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(99, "PG3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG3"),
+		STM32_FUNCTION(2, "LPTIM1_ETR"),
+		STM32_FUNCTION(3, "SPI5_MOSI"),
+		STM32_FUNCTION(4, "UART8_TX"),
+		STM32_FUNCTION(5, "SAI2_FS_B"),
+		STM32_FUNCTION(8, "TIM3_CH3"),
+		STM32_FUNCTION(9, "TIM8_ETR"),
+		STM32_FUNCTION(10, "ETH2_CLK"),
+		STM32_FUNCTION(11, "ETH2_PHY_INTN"),
+		STM32_FUNCTION(13, "FMC_A19"),
+		STM32_FUNCTION(14, "LCD_R5"),
+		STM32_FUNCTION(15, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(100, "PG4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG4"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(4, "SAI3_FS_B"),
+		STM32_FUNCTION(8, "LPTIM4_IN1"),
+		STM32_FUNCTION(9, "TIM8_BKIN"),
+		STM32_FUNCTION(11, "ETH2_PPS_OUT"),
+		STM32_FUNCTION(12, "ETH2_MDC"),
+		STM32_FUNCTION(13, "FMC_A21"),
+		STM32_FUNCTION(14, "LCD_R7"),
+		STM32_FUNCTION(15, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(101, "PG5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG5"),
+		STM32_FUNCTION(1, "TRACED3"),
+		STM32_FUNCTION(2, "HDP3"),
+		STM32_FUNCTION(4, "USART6_RTS"),
+		STM32_FUNCTION(8, "TIM2_CH3"),
+		STM32_FUNCTION(10, "I2C6_SDA"),
+		STM32_FUNCTION(14, "LCD_R5"),
+		STM32_FUNCTION(15, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(102, "PG6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG6"),
+		STM32_FUNCTION(1, "TRACED4"),
+		STM32_FUNCTION(2, "HDP4"),
+		STM32_FUNCTION(3, "SPI5_SCK"),
+		STM32_FUNCTION(4, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(8, "TIM2_CH4"),
+		STM32_FUNCTION(10, "I2C6_SCL"),
+		STM32_FUNCTION(14, "LCD_R6"),
+		STM32_FUNCTION(15, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(103, "PG7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG7"),
+		STM32_FUNCTION(1, "TRACED5"),
+		STM32_FUNCTION(2, "HDP5"),
+		STM32_FUNCTION(3, "SPI5_NSS"),
+		STM32_FUNCTION(4, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(7, "UART9_CTS"),
+		STM32_FUNCTION(9, "TIM5_ETR"),
+		STM32_FUNCTION(14, "LCD_R7"),
+		STM32_FUNCTION(15, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(104, "PG8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG8"),
+		STM32_FUNCTION(1, "TRACED6"),
+		STM32_FUNCTION(2, "HDP6"),
+		STM32_FUNCTION(3, "SPI5_RDY"),
+		STM32_FUNCTION(4, "SPI1_RDY"),
+		STM32_FUNCTION(5, "USART6_CK"),
+		STM32_FUNCTION(6, "UART5_RTS"),
+		STM32_FUNCTION(7, "UART9_TX"),
+		STM32_FUNCTION(9, "TIM5_CH3"),
+		STM32_FUNCTION(14, "LCD_G2"),
+		STM32_FUNCTION(15, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(105, "PG9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG9"),
+		STM32_FUNCTION(1, "TRACED7"),
+		STM32_FUNCTION(6, "UART5_TX"),
+		STM32_FUNCTION(9, "TIM5_CH4"),
+		STM32_FUNCTION(14, "LCD_G3"),
+		STM32_FUNCTION(15, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(106, "PG10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG10"),
+		STM32_FUNCTION(1, "TRACED8"),
+		STM32_FUNCTION(2, "HDP0"),
+		STM32_FUNCTION(6, "UART5_RX"),
+		STM32_FUNCTION(9, "TIM8_CH4N"),
+		STM32_FUNCTION(14, "LCD_G4"),
+		STM32_FUNCTION(15, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(107, "PG11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG11"),
+		STM32_FUNCTION(1, "TRACED9"),
+		STM32_FUNCTION(2, "HDP1"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM8_CH4"),
+		STM32_FUNCTION(14, "LCD_G5"),
+		STM32_FUNCTION(15, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(108, "PG12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG12"),
+		STM32_FUNCTION(1, "TRACED10"),
+		STM32_FUNCTION(2, "HDP2"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM8_CH1N"),
+		STM32_FUNCTION(14, "LCD_G6"),
+		STM32_FUNCTION(15, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(109, "PG13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG13"),
+		STM32_FUNCTION(1, "TRACED11"),
+		STM32_FUNCTION(2, "HDP3"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(6, "MDF1_CKI6"),
+		STM32_FUNCTION(9, "TIM8_CH2N"),
+		STM32_FUNCTION(10, "I2C1_SCL"),
+		STM32_FUNCTION(11, "I3C1_SCL"),
+		STM32_FUNCTION(14, "LCD_G7"),
+		STM32_FUNCTION(15, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(110, "PG14"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG14"),
+		STM32_FUNCTION(1, "TRACED12"),
+		STM32_FUNCTION(2, "HDP4"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(6, "MDF1_CKI5"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(9, "TIM8_BKIN2"),
+		STM32_FUNCTION(14, "LCD_B1"),
+		STM32_FUNCTION(15, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(111, "PG15"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOG15"),
+		STM32_FUNCTION(1, "TRACED13"),
+		STM32_FUNCTION(2, "HDP5"),
+		STM32_FUNCTION(4, "LPTIM1_CH2"),
+		STM32_FUNCTION(6, "MDF1_SDI5"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(9, "TIM8_ETR"),
+		STM32_FUNCTION(14, "LCD_B2"),
+		STM32_FUNCTION(15, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(114, "PH2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH2"),
+		STM32_FUNCTION(2, "LPTIM2_CH1"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN3"),
+		STM32_FUNCTION(5, "SAI1_SCK_B"),
+		STM32_FUNCTION(6, "I3C3_SDA"),
+		STM32_FUNCTION(8, "TIM16_CH1"),
+		STM32_FUNCTION(9, "I2C5_SDA"),
+		STM32_FUNCTION(10, "I2C3_SDA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_GTX_CLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(115, "PH3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH3"),
+		STM32_FUNCTION(3, "SPI1_NSS I2S1_WS"),
+		STM32_FUNCTION(7, "UART7_RX"),
+		STM32_FUNCTION(8, "TIM17_CH1N"),
+		STM32_FUNCTION(10, "TIM5_CH3"),
+		STM32_FUNCTION(11, "I2C7_SCL"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(116, "PH4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH4"),
+		STM32_FUNCTION(7, "UART7_TX"),
+		STM32_FUNCTION(8, "TIM17_BKIN"),
+		STM32_FUNCTION(10, "TIM5_CH2"),
+		STM32_FUNCTION(11, "LCD_R0"),
+		STM32_FUNCTION(12, "USB3DR_OVRCUR"),
+		STM32_FUNCTION(13, "USBH_HS_OVRCUR"),
+		STM32_FUNCTION(14, "ETH1_PTP_AUX_TS"),
+		STM32_FUNCTION(15, "ETH3_PPS_OUT"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(117, "PH5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH5"),
+		STM32_FUNCTION(5, "SAI2_FS_A"),
+		STM32_FUNCTION(7, "UART8_CTS"),
+		STM32_FUNCTION(8, "TIM2_CH1"),
+		STM32_FUNCTION(9, "UART7_RX"),
+		STM32_FUNCTION(11, "LCD_G1"),
+		STM32_FUNCTION(12, "USB3DR_VBUSEN"),
+		STM32_FUNCTION(13, "USBH_HS_VBUSEN"),
+		STM32_FUNCTION(14, "ETH2_PTP_AUX_TS"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(118, "PH6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH6"),
+		STM32_FUNCTION(2, "LPTIM2_IN2"),
+		STM32_FUNCTION(5, "SAI1_MCLK_B"),
+		STM32_FUNCTION(6, "I3C3_SCL"),
+		STM32_FUNCTION(8, "TIM16_CH1N"),
+		STM32_FUNCTION(9, "I2C5_SCL"),
+		STM32_FUNCTION(10, "I2C3_SCL"),
+		STM32_FUNCTION(11, "I2C1_SMBA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_TXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(119, "PH7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH7"),
+		STM32_FUNCTION(3, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(5, "UART4_TX"),
+		STM32_FUNCTION(7, "UART7_RTS"),
+		STM32_FUNCTION(8, "TIM17_CH1"),
+		STM32_FUNCTION(10, "TIM5_CH4"),
+		STM32_FUNCTION(11, "I2C7_SDA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(120, "PH8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH8"),
+		STM32_FUNCTION(3, "SPI1_MISO I2S1_SDI"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN3"),
+		STM32_FUNCTION(5, "UART4_RX"),
+		STM32_FUNCTION(7, "UART7_CTS"),
+		STM32_FUNCTION(10, "TIM5_CH1"),
+		STM32_FUNCTION(11, "I2C3_SMBA"),
+		STM32_FUNCTION(12, "I2C5_SMBA"),
+		STM32_FUNCTION(15, "ETH3_RGMII_RXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(121, "PH9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH9"),
+		STM32_FUNCTION(4, "SPI6_NSS"),
+		STM32_FUNCTION(5, "SAI3_MCLK_A"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(8, "TIM15_CH1N"),
+		STM32_FUNCTION(11, "ETH1_RGMII_CLK125"),
+		STM32_FUNCTION(12, "ETH1_MII_RX_ER"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(122, "PH10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH10"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SPI6_MOSI"),
+		STM32_FUNCTION(5, "SAI3_SCK_A"),
+		STM32_FUNCTION(8, "TIM15_CH1"),
+		STM32_FUNCTION(10, "ETH2_MDC"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD2 ETH1_RGMII_TXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(123, "PH11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH11"),
+		STM32_FUNCTION(4, "SPI6_MISO"),
+		STM32_FUNCTION(5, "SAI3_FS_A"),
+		STM32_FUNCTION(8, "TIM15_CH2"),
+		STM32_FUNCTION(10, "ETH2_MDIO"),
+		STM32_FUNCTION(11, "ETH1_MII_TXD3 ETH1_RGMII_TXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(124, "PH12"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH12"),
+		STM32_FUNCTION(3, "SPI3_NSS I2S3_WS"),
+		STM32_FUNCTION(4, "SPI6_MISO"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD2 ETH1_RGMII_RXD2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(125, "PH13"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOH13"),
+		STM32_FUNCTION(3, "SPI3_SCK I2S3_CK"),
+		STM32_FUNCTION(4, "SPI6_MOSI"),
+		STM32_FUNCTION(8, "TIM15_BKIN"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(11, "ETH1_MII_RXD3 ETH1_RGMII_RXD3"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(128, "PI0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI0"),
+		STM32_FUNCTION(1, "TRACED14"),
+		STM32_FUNCTION(2, "HDP6"),
+		STM32_FUNCTION(4, "LPTIM1_IN1"),
+		STM32_FUNCTION(5, "SAI4_MCLK_B"),
+		STM32_FUNCTION(7, "USART1_CK"),
+		STM32_FUNCTION(9, "TIM8_BKIN"),
+		STM32_FUNCTION(14, "LCD_B3"),
+		STM32_FUNCTION(15, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(129, "PI1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI1"),
+		STM32_FUNCTION(1, "TRACED15"),
+		STM32_FUNCTION(2, "HDP7"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(6, "MDF1_SDI6"),
+		STM32_FUNCTION(9, "TIM8_CH3N"),
+		STM32_FUNCTION(10, "I2C1_SDA"),
+		STM32_FUNCTION(11, "I3C1_SDA"),
+		STM32_FUNCTION(14, "LCD_B4"),
+		STM32_FUNCTION(15, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(130, "PI2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI2"),
+		STM32_FUNCTION(4, "LPTIM1_ETR"),
+		STM32_FUNCTION(5, "SAI4_SCK_B"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(9, "TIM8_CH1"),
+		STM32_FUNCTION(14, "LCD_B5"),
+		STM32_FUNCTION(15, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(131, "PI3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI3"),
+		STM32_FUNCTION(4, "LPTIM1_IN2"),
+		STM32_FUNCTION(5, "SAI4_SD_B"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(9, "TIM8_CH2"),
+		STM32_FUNCTION(14, "LCD_B6"),
+		STM32_FUNCTION(15, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(132, "PI4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI4"),
+		STM32_FUNCTION(4, "LPTIM1_CH1"),
+		STM32_FUNCTION(5, "SAI4_FS_B"),
+		STM32_FUNCTION(9, "TIM8_CH3"),
+		STM32_FUNCTION(14, "LCD_B7"),
+		STM32_FUNCTION(15, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(133, "PI5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI5"),
+		STM32_FUNCTION(3, "SPI5_MOSI"),
+		STM32_FUNCTION(4, "SPI1_MOSI I2S1_SDO"),
+		STM32_FUNCTION(6, "UART5_CTS"),
+		STM32_FUNCTION(7, "UART9_RX"),
+		STM32_FUNCTION(9, "TIM5_CH2"),
+		STM32_FUNCTION(14, "LCD_DE"),
+		STM32_FUNCTION(15, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(134, "PI6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI6"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(7, "USART3_TX"),
+		STM32_FUNCTION(8, "TIM2_ETR"),
+		STM32_FUNCTION(9, "TIM3_CH1"),
+		STM32_FUNCTION(14, "LCD_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(135, "PI7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI7"),
+		STM32_FUNCTION(7, "USART3_RX"),
+		STM32_FUNCTION(8, "TIM2_CH1"),
+		STM32_FUNCTION(9, "TIM3_CH2"),
+		STM32_FUNCTION(14, "LCD_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(136, "PI8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(137, "PI9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI9"),
+		STM32_FUNCTION(2, "SPI7_MOSI"),
+		STM32_FUNCTION(3, "SPI2_MOSI I2S2_SDO"),
+		STM32_FUNCTION(5, "FDCAN2_TX"),
+		STM32_FUNCTION(7, "UART9_CTS"),
+		STM32_FUNCTION(9, "TIM16_BKIN"),
+		STM32_FUNCTION(10, "SDVSEL2"),
+		STM32_FUNCTION(11, "FMC_NWAIT"),
+		STM32_FUNCTION(13, "DSI_TE"),
+		STM32_FUNCTION(14, "LCD_B0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(138, "PI10"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI10"),
+		STM32_FUNCTION(2, "SAI1_SCK_A"),
+		STM32_FUNCTION(3, "SPI1_SCK I2S1_CK"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN0"),
+		STM32_FUNCTION(5, "FDCAN2_RX"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(9, "TIM4_CH1"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(13, "FMC_AD12 FMC_D12"),
+		STM32_FUNCTION(14, "DSI_TE"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(139, "PI11"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOI11"),
+		STM32_FUNCTION(3, "I2S2_MCK"),
+		STM32_FUNCTION(6, "UART8_TX"),
+		STM32_FUNCTION(7, "UART9_RTS"),
+		STM32_FUNCTION(10, "TIM4_CH3"),
+		STM32_FUNCTION(11, "SDMMC3_D3"),
+		STM32_FUNCTION(12, "FMC_AD15 FMC_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(140, "PI12"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI12"),
+		STM32_FUNCTION(3, "SPI4_NSS"),
+		STM32_FUNCTION(8, "FDCAN3_RX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(13, "FMC_A2"),
+		STM32_FUNCTION(14, "LCD_G0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(141, "PI13"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI13"),
+		STM32_FUNCTION(3, "SPI4_MOSI"),
+		STM32_FUNCTION(5, "FDCAN2_RX"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(13, "FMC_A3"),
+		STM32_FUNCTION(14, "LCD_G1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(142, "PI14"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI14"),
+		STM32_FUNCTION(3, "SPI2_NSS I2S2_WS"),
+		STM32_FUNCTION(6, "MDF1_SDI1"),
+		STM32_FUNCTION(8, "TIM20_CH3"),
+		STM32_FUNCTION(9, "TIM1_CH3N"),
+		STM32_FUNCTION(11, "FMC_NWAIT"),
+		STM32_FUNCTION(13, "FMC_AD10 FMC_D10"),
+		STM32_FUNCTION(14, "DCMI_D4 PSSI_D4 DCMIPP_D4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(143, "PI15"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOI15"),
+		STM32_FUNCTION(3, "I2S2_MCK"),
+		STM32_FUNCTION(4, "UART4_RX"),
+		STM32_FUNCTION(6, "MDF1_CKI2"),
+		STM32_FUNCTION(8, "TIM20_BKIN2"),
+		STM32_FUNCTION(9, "TIM1_BKIN2"),
+		STM32_FUNCTION(10, "SDVSEL1"),
+		STM32_FUNCTION(11, "SDMMC3_CDIR"),
+		STM32_FUNCTION(14, "DCMI_D9 PSSI_D9 DCMIPP_D9"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(144, "PJ0"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ0"),
+		STM32_FUNCTION(3, "SPI5_MOSI"),
+		STM32_FUNCTION(5, "PCIE_CLKREQN"),
+		STM32_FUNCTION(6, "SAI4_D2"),
+		STM32_FUNCTION(7, "USART6_CTS"),
+		STM32_FUNCTION(10, "USBH_HS_VBUSEN"),
+		STM32_FUNCTION(12, "ETH2_PTP_AUX_TS"),
+		STM32_FUNCTION(13, "FMC_A11"),
+		STM32_FUNCTION(14, "ETH3_PPS_OUT"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(145, "PJ1"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ1"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(9, "TIM8_CH1N"),
+		STM32_FUNCTION(10, "I2C1_SCL"),
+		STM32_FUNCTION(11, "I3C1_SCL"),
+		STM32_FUNCTION(13, "FMC_A7"),
+		STM32_FUNCTION(15, "DCMI_VSYNC PSSI_RDY DCMIPP_VSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(146, "PJ2"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ2"),
+		STM32_FUNCTION(5, "SAI2_SD_B"),
+		STM32_FUNCTION(7, "UART9_RTS"),
+		STM32_FUNCTION(9, "TIM8_CH4N"),
+		STM32_FUNCTION(10, "USBH_HS_OVRCUR"),
+		STM32_FUNCTION(13, "FMC_A14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(147, "PJ3"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ3"),
+		STM32_FUNCTION(3, "SPI5_NSS"),
+		STM32_FUNCTION(4, "SAI2_FS_A"),
+		STM32_FUNCTION(6, "SAI4_D1"),
+		STM32_FUNCTION(7, "USART6_RTS"),
+		STM32_FUNCTION(9, "TIM8_CH3"),
+		STM32_FUNCTION(13, "FMC_A10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(148, "PJ4"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ4"),
+		STM32_FUNCTION(4, "SAI2_FS_B"),
+		STM32_FUNCTION(6, "MDF1_CCK1"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(9, "TIM8_CH4"),
+		STM32_FUNCTION(10, "I2C2_SMBA"),
+		STM32_FUNCTION(11, "I2C5_SMBA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(149, "PJ5"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ5"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(4, "SAI2_SCK_B"),
+		STM32_FUNCTION(6, "SAI4_CK1"),
+		STM32_FUNCTION(7, "USART6_TX"),
+		STM32_FUNCTION(9, "TIM8_CH1"),
+		STM32_FUNCTION(13, "FMC_A8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(150, "PJ6"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ6"),
+		STM32_FUNCTION(3, "SPI7_MOSI"),
+		STM32_FUNCTION(5, "SAI4_SD_A"),
+		STM32_FUNCTION(7, "USART2_CK"),
+		STM32_FUNCTION(8, "TIM20_CH1N"),
+		STM32_FUNCTION(9, "TIM1_CH1"),
+		STM32_FUNCTION(10, "I2C6_SMBA"),
+		STM32_FUNCTION(14, "DCMI_D7 PSSI_D7 DCMIPP_D7"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(151, "PJ7"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ7"),
+		STM32_FUNCTION(3, "SPI5_MISO"),
+		STM32_FUNCTION(5, "SAI2_MCLK_B"),
+		STM32_FUNCTION(6, "SAI4_D3"),
+		STM32_FUNCTION(7, "USART6_CK"),
+		STM32_FUNCTION(9, "TIM8_CH2N"),
+		STM32_FUNCTION(10, "I2C1_SMBA"),
+		STM32_FUNCTION(13, "FMC_A12"),
+		STM32_FUNCTION(15, "DCMI_D0 PSSI_D0 DCMIPP_D0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(152, "PJ8"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ8"),
+		STM32_FUNCTION(3, "SPI5_SCK"),
+		STM32_FUNCTION(6, "SAI4_CK2"),
+		STM32_FUNCTION(7, "USART6_RX"),
+		STM32_FUNCTION(9, "TIM8_CH2"),
+		STM32_FUNCTION(13, "FMC_A9"),
+		STM32_FUNCTION(15, "PSSI_D14 DCMIPP_D14"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(153, "PJ9"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ9"),
+		STM32_FUNCTION(3, "SPI4_RDY"),
+		STM32_FUNCTION(8, "TIM12_CH1"),
+		STM32_FUNCTION(9, "TIM8_BKIN"),
+		STM32_FUNCTION(13, "FMC_A5"),
+		STM32_FUNCTION(15, "DCMI_PIXCLK PSSI_PDCK DCMIPP_PIXCLK"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(154, "PJ10"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ10"),
+		STM32_FUNCTION(8, "TIM12_CH2"),
+		STM32_FUNCTION(9, "TIM8_ETR"),
+		STM32_FUNCTION(10, "I2C1_SDA"),
+		STM32_FUNCTION(11, "I3C1_SDA"),
+		STM32_FUNCTION(13, "FMC_A6"),
+		STM32_FUNCTION(15, "DCMI_HSYNC PSSI_DE DCMIPP_HSYNC"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(155, "PJ11"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ11"),
+		STM32_FUNCTION(3, "SPI5_RDY"),
+		STM32_FUNCTION(4, "SAI2_SCK_A"),
+		STM32_FUNCTION(6, "SAI4_D4"),
+		STM32_FUNCTION(7, "UART9_CTS"),
+		STM32_FUNCTION(9, "TIM8_CH3N"),
+		STM32_FUNCTION(13, "FMC_A13"),
+		STM32_FUNCTION(15, "DCMI_D12 PSSI_D12 DCMIPP_D12"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(156, "PJ12"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ12"),
+		STM32_FUNCTION(4, "SAI2_SD_A"),
+		STM32_FUNCTION(7, "UART9_RX"),
+		STM32_FUNCTION(8, "FDCAN1_TX"),
+		STM32_FUNCTION(9, "TIM8_BKIN2"),
+		STM32_FUNCTION(10, "I2C2_SCL"),
+		STM32_FUNCTION(11, "I3C2_SCL"),
+		STM32_FUNCTION(13, "FMC_A15"),
+		STM32_FUNCTION(15, "DCMI_D13 PSSI_D13 DCMIPP_D13"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(157, "PJ13"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ13"),
+		STM32_FUNCTION(4, "SAI2_MCLK_A"),
+		STM32_FUNCTION(7, "UART9_TX"),
+		STM32_FUNCTION(8, "FDCAN1_RX"),
+		STM32_FUNCTION(9, "TIM10_CH1"),
+		STM32_FUNCTION(10, "I2C2_SDA"),
+		STM32_FUNCTION(11, "I3C2_SDA"),
+		STM32_FUNCTION(15, "PSSI_D15 DCMIPP_D15"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(158, "PJ14"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ14"),
+		STM32_FUNCTION(3, "SPI4_SCK"),
+		STM32_FUNCTION(8, "FDCAN3_TX"),
+		STM32_FUNCTION(13, "FMC_A1"),
+		STM32_FUNCTION(14, "LCD_R0"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(159, "PJ15"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOJ15"),
+		STM32_FUNCTION(1, "TRACED7"),
+		STM32_FUNCTION(2, "HDP7"),
+		STM32_FUNCTION(3, "SPI4_MISO"),
+		STM32_FUNCTION(5, "FDCAN2_TX"),
+		STM32_FUNCTION(9, "TIM11_CH1"),
+		STM32_FUNCTION(13, "FMC_A4"),
+		STM32_FUNCTION(14, "LCD_R1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(160, "PK0"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK0"),
+		STM32_FUNCTION(3, "SPI2_MISO I2S2_SDI"),
+		STM32_FUNCTION(4, "SPDIFRX1_IN2"),
+		STM32_FUNCTION(6, "MDF1_CCK0"),
+		STM32_FUNCTION(8, "TIM20_ETR"),
+		STM32_FUNCTION(9, "TIM1_ETR"),
+		STM32_FUNCTION(11, "SDMMC3_D123DIR"),
+		STM32_FUNCTION(13, "FMC_AD11 FMC_D11"),
+		STM32_FUNCTION(14, "DCMI_D11 PSSI_D11 DCMIPP_D11"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(161, "PK1"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK1"),
+		STM32_FUNCTION(3, "SPI2_MOSI I2S2_SDO"),
+		STM32_FUNCTION(6, "MDF1_SDI2"),
+		STM32_FUNCTION(8, "TIM20_BKIN"),
+		STM32_FUNCTION(9, "TIM1_BKIN"),
+		STM32_FUNCTION(10, "SDVSEL2"),
+		STM32_FUNCTION(11, "SDMMC3_D0DIR"),
+		STM32_FUNCTION(13, "FMC_AD13 FMC_D13"),
+		STM32_FUNCTION(14, "DCMI_D10 PSSI_D10 DCMIPP_D10"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(162, "PK2"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK2"),
+		STM32_FUNCTION(3, "SPI7_NSS"),
+		STM32_FUNCTION(5, "SAI4_SCK_A"),
+		STM32_FUNCTION(7, "USART1_RTS"),
+		STM32_FUNCTION(8, "TIM20_CH2"),
+		STM32_FUNCTION(9, "TIM1_CH2N"),
+		STM32_FUNCTION(10, "I2C6_SDA"),
+		STM32_FUNCTION(13, "FMC_NCE3"),
+		STM32_FUNCTION(14, "DCMI_D6 PSSI_D6 DCMIPP_D6"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(163, "PK3"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK3"),
+		STM32_FUNCTION(3, "SPI7_RDY"),
+		STM32_FUNCTION(6, "MDF1_CKI1"),
+		STM32_FUNCTION(8, "TIM20_CH3N"),
+		STM32_FUNCTION(9, "TIM1_CH3"),
+		STM32_FUNCTION(13, "FMC_AD8 FMC_D8"),
+		STM32_FUNCTION(14, "DCMI_D3 PSSI_D3 DCMIPP_D3"),
+		STM32_FUNCTION(15, "FMC_NCE4"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(164, "PK4"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK4"),
+		STM32_FUNCTION(3, "SPI7_MISO"),
+		STM32_FUNCTION(4, "UART4_TX"),
+		STM32_FUNCTION(5, "SAI4_FS_A"),
+		STM32_FUNCTION(8, "TIM20_CH1"),
+		STM32_FUNCTION(9, "TIM1_CH1N"),
+		STM32_FUNCTION(11, "SDMMC3_CKIN"),
+		STM32_FUNCTION(13, "FMC_AD9 FMC_D9"),
+		STM32_FUNCTION(14, "DCMI_D8 PSSI_D8 DCMIPP_D8"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(165, "PK5"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK5"),
+		STM32_FUNCTION(3, "SPI2_RDY"),
+		STM32_FUNCTION(6, "MDF1_CKI0"),
+		STM32_FUNCTION(7, "USART1_TX"),
+		STM32_FUNCTION(8, "TIM20_CH4N"),
+		STM32_FUNCTION(9, "TIM1_CH4"),
+		STM32_FUNCTION(11, "I2C5_SCL"),
+		STM32_FUNCTION(13, "FMC_AD5 FMC_D5"),
+		STM32_FUNCTION(14, "DCMI_D1 PSSI_D1 DCMIPP_D1"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(166, "PK6"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK6"),
+		STM32_FUNCTION(3, "SPI7_SCK"),
+		STM32_FUNCTION(5, "SAI4_MCLK_A"),
+		STM32_FUNCTION(7, "USART1_CTS"),
+		STM32_FUNCTION(8, "TIM20_CH2N"),
+		STM32_FUNCTION(9, "TIM1_CH2"),
+		STM32_FUNCTION(10, "I2C6_SCL"),
+		STM32_FUNCTION(12, "FMC_AD14 FMC_D14"),
+		STM32_FUNCTION(13, "FMC_AD7 FMC_D7"),
+		STM32_FUNCTION(14, "DCMI_D5 PSSI_D5 DCMIPP_D5"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(167, "PK7"),
+		STM32MP_PKG_AI,
+		STM32_FUNCTION(0, "GPIOK7"),
+		STM32_FUNCTION(6, "MDF1_SDI0"),
+		STM32_FUNCTION(7, "USART1_RX"),
+		STM32_FUNCTION(8, "TIM20_CH4"),
+		STM32_FUNCTION(9, "TIM1_CH4N"),
+		STM32_FUNCTION(11, "I2C5_SDA"),
+		STM32_FUNCTION(12, "FMC_NCE4"),
+		STM32_FUNCTION(13, "FMC_AD6 FMC_D6"),
+		STM32_FUNCTION(14, "DCMI_D2 PSSI_D2 DCMIPP_D2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+};
+
+static const struct stm32_desc_pin stm32mp257_z_pins[] = {
+	STM32_PIN_PKG(
+		PINCTRL_PIN(400, "PZ0"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ0"),
+		STM32_FUNCTION(3, "LPTIM3_IN1"),
+		STM32_FUNCTION(4, "SPI8_MOSI"),
+		STM32_FUNCTION(5, "TIM8_CH1"),
+		STM32_FUNCTION(7, "LPUART1_TX"),
+		STM32_FUNCTION(8, "LPTIM5_OUT"),
+		STM32_FUNCTION(9, "I2C8_SDA"),
+		STM32_FUNCTION(11, "LPTIM3_CH2"),
+		STM32_FUNCTION(12, "I3C4_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(401, "PZ1"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ1"),
+		STM32_FUNCTION(3, "LPTIM3_CH1"),
+		STM32_FUNCTION(4, "SPI8_MISO"),
+		STM32_FUNCTION(5, "TIM8_CH2"),
+		STM32_FUNCTION(7, "LPUART1_RX"),
+		STM32_FUNCTION(8, "LPTIM5_ETR"),
+		STM32_FUNCTION(9, "I2C8_SCL"),
+		STM32_FUNCTION(10, "I2C8_SMBA"),
+		STM32_FUNCTION(12, "I3C4_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(402, "PZ2"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ2"),
+		STM32_FUNCTION(3, "LPTIM3_CH1"),
+		STM32_FUNCTION(4, "SPI8_SCK"),
+		STM32_FUNCTION(6, "ADF1_CCK0"),
+		STM32_FUNCTION(7, "LPUART1_RTS"),
+		STM32_FUNCTION(8, "LPTIM4_ETR"),
+		STM32_FUNCTION(9, "I2C8_SCL"),
+		STM32_FUNCTION(12, "I3C4_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(403, "PZ3"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ3"),
+		STM32_FUNCTION(1, "DBTRGI"),
+		STM32_FUNCTION(2, "DBTRGO"),
+		STM32_FUNCTION(3, "LPTIM3_ETR"),
+		STM32_FUNCTION(4, "SPI8_NSS"),
+		STM32_FUNCTION(5, "MDF1_SDI5"),
+		STM32_FUNCTION(6, "ADF1_SDI0"),
+		STM32_FUNCTION(7, "LPUART1_CTS"),
+		STM32_FUNCTION(8, "LPTIM4_IN1"),
+		STM32_FUNCTION(9, "I2C8_SDA"),
+		STM32_FUNCTION(11, "LPTIM4_CH2"),
+		STM32_FUNCTION(12, "I3C4_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(404, "PZ4"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ4"),
+		STM32_FUNCTION(1, "DBTRGI"),
+		STM32_FUNCTION(2, "DBTRGO"),
+		STM32_FUNCTION(3, "MCO2"),
+		STM32_FUNCTION(4, "SPI8_RDY"),
+		STM32_FUNCTION(5, "MDF1_CCK1"),
+		STM32_FUNCTION(6, "ADF1_CCK1"),
+		STM32_FUNCTION(7, "LPUART1_RX"),
+		STM32_FUNCTION(8, "LPTIM4_CH1"),
+		STM32_FUNCTION(9, "I2C8_SCL"),
+		STM32_FUNCTION(12, "I3C4_SCL"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(405, "PZ5"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ5"),
+		STM32_FUNCTION(2, "MCO1"),
+		STM32_FUNCTION(3, "LPTIM3_ETR"),
+		STM32_FUNCTION(4, "SPI8_SCK"),
+		STM32_FUNCTION(6, "ADF1_CCK0"),
+		STM32_FUNCTION(7, "LPUART1_RTS"),
+		STM32_FUNCTION(8, "LPTIM5_IN1"),
+		STM32_FUNCTION(11, "LPTIM4_CH2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(406, "PZ6"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ6"),
+		STM32_FUNCTION(1, "DBTRGI"),
+		STM32_FUNCTION(2, "DBTRGO"),
+		STM32_FUNCTION(4, "SPI8_NSS"),
+		STM32_FUNCTION(5, "TIM8_CH3"),
+		STM32_FUNCTION(6, "ADF1_SDI0"),
+		STM32_FUNCTION(7, "LPUART1_CTS"),
+		STM32_FUNCTION(8, "LPTIM5_OUT"),
+		STM32_FUNCTION(11, "LPTIM4_CH2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(407, "PZ7"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ7"),
+		STM32_FUNCTION(4, "SPI8_MOSI"),
+		STM32_FUNCTION(5, "MDF1_CCK1"),
+		STM32_FUNCTION(6, "ADF1_CCK1"),
+		STM32_FUNCTION(7, "LPUART1_TX"),
+		STM32_FUNCTION(8, "LPTIM5_IN1"),
+		STM32_FUNCTION(11, "LPTIM3_CH2"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(408, "PZ8"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ8"),
+		STM32_FUNCTION(3, "LPTIM3_IN1"),
+		STM32_FUNCTION(4, "SPI8_MISO"),
+		STM32_FUNCTION(5, "MDF1_SDI5"),
+		STM32_FUNCTION(6, "ADF1_SDI0"),
+		STM32_FUNCTION(7, "LPUART1_RX"),
+		STM32_FUNCTION(8, "LPTIM4_CH1"),
+		STM32_FUNCTION(9, "I2C8_SMBA"),
+		STM32_FUNCTION(10, "LPTIM5_ETR"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+	STM32_PIN_PKG(
+		PINCTRL_PIN(409, "PZ9"),
+		STM32MP_PKG_AI | STM32MP_PKG_AK | STM32MP_PKG_AL,
+		STM32_FUNCTION(0, "GPIOZ9"),
+		STM32_FUNCTION(2, "MCO2"),
+		STM32_FUNCTION(4, "SPI8_RDY"),
+		STM32_FUNCTION(5, "MDF1_CKI5"),
+		STM32_FUNCTION(7, "LPUART1_TX"),
+		STM32_FUNCTION(8, "LPTIM4_ETR"),
+		STM32_FUNCTION(9, "I2C8_SDA"),
+		STM32_FUNCTION(11, "LPTIM3_CH2"),
+		STM32_FUNCTION(12, "I3C4_SDA"),
+		STM32_FUNCTION(16, "EVENTOUT"),
+		STM32_FUNCTION(17, "ANALOG")
+	),
+};
+
+static struct stm32_pinctrl_match_data stm32mp257_match_data = {
+	.pins = stm32mp257_pins,
+	.npins = ARRAY_SIZE(stm32mp257_pins),
+	.io_sync_control = true,
+	.secure_control = true,
+	.rif_control = true,
+};
+
+static struct stm32_pinctrl_match_data stm32mp257_z_match_data = {
+	.pins = stm32mp257_z_pins,
+	.npins = ARRAY_SIZE(stm32mp257_z_pins),
+	.io_sync_control = true,
+	.secure_control = true,
+	.rif_control = true,
+};
+
+static const struct of_device_id stm32mp257_pctrl_match[] = {
+	{
+		.compatible = "st,stm32mp257-pinctrl",
+		.data = &stm32mp257_match_data,
+	},
+	{
+		.compatible = "st,stm32mp257-z-pinctrl",
+		.data = &stm32mp257_z_match_data,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, stm32mp257_pctrl_match);
+
+static const struct dev_pm_ops stm32_pinctrl_dev_pm_ops = {
+	 NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_pinctrl_suspend, stm32_pinctrl_resume)
+};
+
+static struct platform_driver stm32mp257_pinctrl_driver = {
+	.probe = stm32_pctl_probe,
+	.driver = {
+		.name = "stm32mp257-pinctrl",
+		.of_match_table = stm32mp257_pctrl_match,
+		.pm = &stm32_pinctrl_dev_pm_ops,
+	},
+};
+module_platform_driver(stm32mp257_pinctrl_driver);
+
+MODULE_AUTHOR("Alexandre Torgue <alexandre.torgue@foss.st.com>");
+MODULE_DESCRIPTION("STM32MP257 pinctrl driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/ptp/ptp_chardev.c b/drivers/ptp/ptp_chardev.c
index 9311f3d09..421bfac59 100644
--- a/drivers/ptp/ptp_chardev.c
+++ b/drivers/ptp/ptp_chardev.c
@@ -111,6 +111,8 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 	struct ptp_clock *ptp = container_of(pc, struct ptp_clock, clock);
 	struct ptp_sys_offset_extended *extoff = NULL;
 	struct ptp_sys_offset_precise precise_offset;
+	struct ptp_ptp_offset_precise ptp_precise_offset;
+	struct device_device_crosststamp devxtstamp;
 	struct system_device_crosststamp xtstamp;
 	struct ptp_clock_info *ops = ptp->info;
 	struct ptp_sys_offset *sysoff = NULL;
@@ -137,6 +139,7 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 		caps.n_pins = ptp->info->n_pins;
 		caps.cross_timestamping = ptp->info->getcrosststamp != NULL;
 		caps.adjust_phase = ptp->info->adjphase != NULL;
+		caps.peer_cross_timestamping = (ptp->info->getphcxtstamp != NULL) && (ptp->peer);
 		if (copy_to_user((void __user *)arg, &caps, sizeof(caps)))
 			err = -EFAULT;
 		break;
@@ -321,6 +324,26 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 			err = -EFAULT;
 		break;
 
+	case PTP_PTP_OFFSET_PRECISE:
+		if ((!ptp->info->getphcxtstamp) || (!ptp->peer)) {
+			err = -EOPNOTSUPP;
+			break;
+		}
+		err = ptp->info->getphcxtstamp(ptp->info, ptp->peer->info,
+									   &devxtstamp);
+		if (err)
+			break;
+		ts = ktime_to_timespec64(devxtstamp.device);
+		ptp_precise_offset.device.sec = ts.tv_sec;
+		ptp_precise_offset.device.nsec = ts.tv_nsec;
+		ts = ktime_to_timespec64(devxtstamp.peer_device);
+		ptp_precise_offset.peer.sec = ts.tv_sec;
+		ptp_precise_offset.peer.nsec = ts.tv_nsec;
+		if (copy_to_user((void __user *)arg, &ptp_precise_offset,
+			sizeof(ptp_precise_offset)))
+			err = -EFAULT;
+		break;
+
 	case PTP_SYS_OFFSET:
 	case PTP_SYS_OFFSET2:
 		sysoff = memdup_user((void __user *)arg, sizeof(*sysoff));
diff --git a/drivers/ptp/ptp_clock.c b/drivers/ptp/ptp_clock.c
index 3c3e4fbef..8eedaefea 100644
--- a/drivers/ptp/ptp_clock.c
+++ b/drivers/ptp/ptp_clock.c
@@ -226,6 +226,7 @@ struct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,
 
 	ptp->clock.ops = ptp_clock_ops;
 	ptp->info = info;
+	ptp->peer = NULL;
 	ptp->devid = MKDEV(major, index);
 	ptp->index = index;
 	spin_lock_init(&ptp->tsevq.lock);
@@ -349,6 +350,25 @@ static int unregister_vclock(struct device *dev, void *data)
 	return 0;
 }
 
+int ptp_clock_set_peer(struct ptp_clock *ptp, struct ptp_clock *peer)
+{
+	/* remove existing peer assignments */
+	if (ptp && ptp->peer)
+		ptp->peer->peer = NULL;
+	if (peer && peer->peer)
+		peer->peer->peer = NULL;
+
+	/* pair up the two clocks */
+	if (ptp)
+		ptp->peer = peer;
+	if (peer)
+		peer->peer = ptp;
+
+	return 0;
+}
+
+EXPORT_SYMBOL(ptp_clock_set_peer);
+
 int ptp_clock_unregister(struct ptp_clock *ptp)
 {
 	if (ptp_vclock_in_use(ptp)) {
diff --git a/drivers/ptp/ptp_private.h b/drivers/ptp/ptp_private.h
index b8d4f61f1..be4d7033e 100644
--- a/drivers/ptp/ptp_private.h
+++ b/drivers/ptp/ptp_private.h
@@ -27,10 +27,13 @@ struct timestamp_event_queue {
 	spinlock_t lock;
 };
 
+struct ptp_clock;
+
 struct ptp_clock {
 	struct posix_clock clock;
 	struct device dev;
 	struct ptp_clock_info *info;
+	struct ptp_clock *peer;
 	dev_t devid;
 	int index; /* index into clocks.map */
 	struct pps_device *pps_source;
diff --git a/drivers/pwm/pwm-stm32-lp.c b/drivers/pwm/pwm-stm32-lp.c
index 31a185c6b..5092357e2 100644
--- a/drivers/pwm/pwm-stm32-lp.c
+++ b/drivers/pwm/pwm-stm32-lp.c
@@ -21,6 +21,7 @@ struct stm32_pwm_lp {
 	struct pwm_chip chip;
 	struct clk *clk;
 	struct regmap *regmap;
+	unsigned int num_cc_chans;
 };
 
 static inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)
@@ -31,13 +32,101 @@ static inline struct stm32_pwm_lp *to_stm32_pwm_lp(struct pwm_chip *chip)
 /* STM32 Low-Power Timer is preceded by a configurable power-of-2 prescaler */
 #define STM32_LPTIM_MAX_PRESCALER	128
 
+static int stm32_pwm_lp_update_allowed(struct stm32_pwm_lp *priv, int channel)
+{
+	int ret;
+	u32 ccmr1;
+	unsigned long ccmr;
+
+	/* Only one PWM on this LPTIMER: enable, prescaler and reload value can be changed */
+	if (!priv->num_cc_chans)
+		return true;
+
+	ret = regmap_read(priv->regmap, STM32MP25_LPTIM_CCMR1, &ccmr1);
+	if (ret)
+		return ret;
+	ccmr = ccmr1 & (STM32MP25_LPTIM_CC1E | STM32MP25_LPTIM_CC2E);
+
+	/* More than one channel enabled: enable, prescaler or ARR value can't be changed */
+	if (bitmap_weight(&ccmr, sizeof(u32) * BITS_PER_BYTE) > 1)
+		return false;
+
+	/*
+	 * Only one channel is enabled (or none): check status on the other channel, to
+	 * report if enable, prescaler or ARR value can be changed.
+	 */
+	if (channel)
+		return !(ccmr1 & STM32MP25_LPTIM_CC1E);
+	else
+		return !(ccmr1 & STM32MP25_LPTIM_CC2E);
+}
+
+static int stm32_pwm_lp_compare_channel_apply(struct stm32_pwm_lp *priv, int channel,
+					      bool enable, enum pwm_polarity polarity)
+{
+	u32 ccmr1, val, mask;
+	bool reenable;
+	int ret;
+
+	/* No dedicated CC channel: nothing to do */
+	if (!priv->num_cc_chans)
+		return 0;
+
+	ret = regmap_read(priv->regmap, STM32MP25_LPTIM_CCMR1, &ccmr1);
+	if (ret)
+		return ret;
+
+	if (channel) {
+		/* Must disable CC channel (CCxE) to modify polarity (CCxP), then reenable */
+		reenable = (enable && FIELD_GET(STM32MP25_LPTIM_CC2E, ccmr1)) &&
+			(polarity != FIELD_GET(STM32MP25_LPTIM_CC2P, ccmr1));
+
+		mask = STM32MP25_LPTIM_CC2SEL | STM32MP25_LPTIM_CC2E | STM32MP25_LPTIM_CC2P;
+		val = FIELD_PREP(STM32MP25_LPTIM_CC2P, polarity);
+		val |= FIELD_PREP(STM32MP25_LPTIM_CC2E, enable);
+	} else {
+		reenable = (enable && FIELD_GET(STM32MP25_LPTIM_CC1E, ccmr1)) &&
+			(polarity != FIELD_GET(STM32MP25_LPTIM_CC1P, ccmr1));
+
+		mask = STM32MP25_LPTIM_CC1SEL | STM32MP25_LPTIM_CC1E | STM32MP25_LPTIM_CC1P;
+		val = FIELD_PREP(STM32MP25_LPTIM_CC1P, polarity);
+		val |= FIELD_PREP(STM32MP25_LPTIM_CC1E, enable);
+	}
+
+	if (reenable) {
+		u32 cfgr, presc;
+		unsigned long rate;
+		unsigned int delay_us;
+
+		ret = regmap_update_bits(priv->regmap, STM32MP25_LPTIM_CCMR1,
+					 channel ? STM32MP25_LPTIM_CC2E : STM32MP25_LPTIM_CC1E, 0);
+		if (ret)
+			return ret;
+		/*
+		 * After a write to the LPTIM_CCMRx register, a new write operation can only be
+		 * performed after a delay of at least (PRESC  3) clock cycles
+		 */
+		ret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);
+		if (ret)
+			return ret;
+		presc = FIELD_GET(STM32_LPTIM_PRESC, cfgr);
+		rate = clk_get_rate(priv->clk) >> presc;
+		if (!rate)
+			return -EINVAL;
+		delay_us = 3 * DIV_ROUND_UP(USEC_PER_SEC, rate);
+		usleep_range(delay_us, delay_us * 2);
+	}
+
+	return regmap_update_bits(priv->regmap, STM32MP25_LPTIM_CCMR1, mask, val);
+}
+
 static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			      const struct pwm_state *state)
 {
 	struct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);
 	unsigned long long prd, div, dty;
 	struct pwm_state cstate;
-	u32 val, mask, cfgr, presc = 0;
+	u32 arr, val, mask, cfgr, presc = 0;
 	bool reenable;
 	int ret;
 
@@ -46,10 +135,28 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	if (!state->enabled) {
 		if (cstate.enabled) {
-			/* Disable LP timer */
-			ret = regmap_write(priv->regmap, STM32_LPTIM_CR, 0);
+			/* Disable CC channel if any */
+			ret = stm32_pwm_lp_compare_channel_apply(priv, pwm->hwpwm, false,
+								 state->polarity);
 			if (ret)
 				return ret;
+			ret = regmap_write(priv->regmap, pwm->hwpwm ?
+					   STM32MP25_LPTIM_CCR2 : STM32_LPTIM_CMP, 0);
+			if (ret)
+				return ret;
+
+			/* Check if the timer can be disabled */
+			ret = stm32_pwm_lp_update_allowed(priv, pwm->hwpwm);
+			if (ret < 0)
+				return ret;
+
+			if (ret) {
+				/* Disable LP timer */
+				ret = regmap_write(priv->regmap, STM32_LPTIM_CR, 0);
+				if (ret)
+					return ret;
+			}
+
 			/* disable clock to PWM counter */
 			clk_disable(priv->clk);
 		}
@@ -58,7 +165,7 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	/* Calculate the period and prescaler value */
 	div = (unsigned long long)clk_get_rate(priv->clk) * state->period;
-	do_div(div, NSEC_PER_SEC);
+	div = DIV_ROUND_CLOSEST_ULL(div, NSEC_PER_SEC);
 	if (!div) {
 		/* Clock is too slow to achieve requested period. */
 		dev_dbg(priv->chip.dev, "Can't reach %llu ns\n", state->period);
@@ -78,7 +185,24 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 
 	/* Calculate the duty cycle */
 	dty = prd * state->duty_cycle;
-	do_div(dty, state->period);
+	dty = DIV_ROUND_CLOSEST_ULL(dty, state->period);
+
+	ret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);
+	if (ret)
+		return ret;
+
+	/*
+	 * When there are several channels, they share the same prescaler and reload value.
+	 * Check if this can be changed, or the values are the same for all channels.
+	 */
+	if (!stm32_pwm_lp_update_allowed(priv, pwm->hwpwm)) {
+		ret = regmap_read(priv->regmap, STM32_LPTIM_ARR, &arr);
+		if (ret)
+			return ret;
+
+		if ((FIELD_GET(STM32_LPTIM_PRESC, cfgr) != presc) || (arr != prd - 1))
+			return -EBUSY;
+	}
 
 	if (!cstate.enabled) {
 		/* enable clock to drive PWM counter */
@@ -87,15 +211,20 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			return ret;
 	}
 
-	ret = regmap_read(priv->regmap, STM32_LPTIM_CFGR, &cfgr);
-	if (ret)
-		goto err;
-
 	if ((FIELD_GET(STM32_LPTIM_PRESC, cfgr) != presc) ||
-	    (FIELD_GET(STM32_LPTIM_WAVPOL, cfgr) != state->polarity)) {
+	    ((FIELD_GET(STM32_LPTIM_WAVPOL, cfgr) != state->polarity) && !priv->num_cc_chans)) {
 		val = FIELD_PREP(STM32_LPTIM_PRESC, presc);
-		val |= FIELD_PREP(STM32_LPTIM_WAVPOL, state->polarity);
-		mask = STM32_LPTIM_PRESC | STM32_LPTIM_WAVPOL;
+		mask = STM32_LPTIM_PRESC;
+
+		if (!priv->num_cc_chans) {
+			/*
+			 * WAVPOL bit is only available when no capature compare channel is used,
+			 * e.g. on LPTIMER instances that have only one output channel. CCMR1 is
+			 * used otherwise.
+			 */
+			val |= FIELD_PREP(STM32_LPTIM_WAVPOL, state->polarity);
+			mask |= STM32_LPTIM_WAVPOL;
+		}
 
 		/* Must disable LP timer to modify CFGR */
 		reenable = true;
@@ -121,20 +250,27 @@ static int stm32_pwm_lp_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 	if (ret)
 		goto err;
 
-	ret = regmap_write(priv->regmap, STM32_LPTIM_CMP, prd - (1 + dty));
+	/* Write CMP/CCRx register and ensure it's been properly written */
+	ret = regmap_write(priv->regmap, pwm->hwpwm ? STM32MP25_LPTIM_CCR2 : STM32_LPTIM_CMP,
+			   prd - (1 + dty));
 	if (ret)
 		goto err;
 
-	/* ensure CMP & ARR registers are properly written */
-	ret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val,
+	/* ensure ARR and CMP/CCRx registers are properly written */
+	ret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val, pwm->hwpwm ?
+				       (val & STM32_LPTIM_CMP2_ARROK) == STM32_LPTIM_CMP2_ARROK :
 				       (val & STM32_LPTIM_CMPOK_ARROK) == STM32_LPTIM_CMPOK_ARROK,
 				       100, 1000);
 	if (ret) {
 		dev_err(priv->chip.dev, "ARR/CMP registers write issue\n");
 		goto err;
 	}
-	ret = regmap_write(priv->regmap, STM32_LPTIM_ICR,
-			   STM32_LPTIM_CMPOKCF_ARROKCF);
+	ret = regmap_write(priv->regmap, STM32_LPTIM_ICR, pwm->hwpwm ?
+			   STM32_LPTIM_CMP2OKCF_ARROKCF : STM32_LPTIM_CMPOKCF_ARROKCF);
+	if (ret)
+		goto err;
+
+	ret = stm32_pwm_lp_compare_channel_apply(priv, pwm->hwpwm, true, state->polarity);
 	if (ret)
 		goto err;
 
@@ -163,25 +299,43 @@ static int stm32_pwm_lp_get_state(struct pwm_chip *chip,
 {
 	struct stm32_pwm_lp *priv = to_stm32_pwm_lp(chip);
 	unsigned long rate = clk_get_rate(priv->clk);
-	u32 val, presc, prd;
+	u32 val, presc, prd, ccmr1;
+	bool enabled;
 	u64 tmp;
 
 	regmap_read(priv->regmap, STM32_LPTIM_CR, &val);
-	state->enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);
+	enabled = !!FIELD_GET(STM32_LPTIM_ENABLE, val);
+	if (priv->num_cc_chans) {
+		/* There's a CC chan, need to also check if it's enabled */
+		regmap_read(priv->regmap, STM32MP25_LPTIM_CCMR1, &ccmr1);
+		if (pwm->hwpwm)
+			enabled &= !!FIELD_GET(STM32MP25_LPTIM_CC2E, ccmr1);
+		else
+			enabled &= !!FIELD_GET(STM32MP25_LPTIM_CC1E, ccmr1);
+	}
+	state->enabled = enabled;
+
 	/* Keep PWM counter clock refcount in sync with PWM initial state */
 	if (state->enabled)
 		clk_enable(priv->clk);
 
 	regmap_read(priv->regmap, STM32_LPTIM_CFGR, &val);
 	presc = FIELD_GET(STM32_LPTIM_PRESC, val);
-	state->polarity = FIELD_GET(STM32_LPTIM_WAVPOL, val);
+	if (priv->num_cc_chans) {
+		if (pwm->hwpwm)
+			state->polarity = FIELD_GET(STM32MP25_LPTIM_CC2P, ccmr1);
+		else
+			state->polarity = FIELD_GET(STM32MP25_LPTIM_CC1P, ccmr1);
+	} else {
+		state->polarity = FIELD_GET(STM32_LPTIM_WAVPOL, val);
+	}
 
 	regmap_read(priv->regmap, STM32_LPTIM_ARR, &prd);
 	tmp = prd + 1;
 	tmp = (tmp << presc) * NSEC_PER_SEC;
 	state->period = DIV_ROUND_CLOSEST_ULL(tmp, rate);
 
-	regmap_read(priv->regmap, STM32_LPTIM_CMP, &val);
+	regmap_read(priv->regmap, pwm->hwpwm ? STM32MP25_LPTIM_CCR2 : STM32_LPTIM_CMP, &val);
 	tmp = prd - val;
 	tmp = (tmp << presc) * NSEC_PER_SEC;
 	state->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, rate);
@@ -208,8 +362,15 @@ static int stm32_pwm_lp_probe(struct platform_device *pdev)
 	priv->regmap = ddata->regmap;
 	priv->clk = ddata->clk;
 	priv->chip.dev = &pdev->dev;
+	priv->num_cc_chans = ddata->num_cc_chans;
 	priv->chip.ops = &stm32_pwm_lp_ops;
-	priv->chip.npwm = 1;
+	if (!ddata->num_cc_chans) {
+		/* No dedicated CC channel, so there's only one PWM channel */
+		priv->chip.npwm = 1;
+	} else {
+		/* There are dedicated CC channels, each with one PWM output */
+		priv->chip.npwm = ddata->num_cc_chans;
+	}
 
 	ret = devm_pwmchip_add(&pdev->dev, &priv->chip);
 	if (ret < 0)
@@ -224,12 +385,15 @@ static int __maybe_unused stm32_pwm_lp_suspend(struct device *dev)
 {
 	struct stm32_pwm_lp *priv = dev_get_drvdata(dev);
 	struct pwm_state state;
-
-	pwm_get_state(&priv->chip.pwms[0], &state);
-	if (state.enabled) {
-		dev_err(dev, "The consumer didn't stop us (%s)\n",
-			priv->chip.pwms[0].label);
-		return -EBUSY;
+	unsigned int i;
+
+	for (i = 0; i < priv->chip.npwm; i++) {
+		pwm_get_state(&priv->chip.pwms[i], &state);
+		if (state.enabled) {
+			dev_err(dev, "The consumer didn't stop us (%s)\n",
+				priv->chip.pwms[i].label);
+			return -EBUSY;
+		}
 	}
 
 	return pinctrl_pm_select_sleep_state(dev);
@@ -245,6 +409,7 @@ static SIMPLE_DEV_PM_OPS(stm32_pwm_lp_pm_ops, stm32_pwm_lp_suspend,
 
 static const struct of_device_id stm32_pwm_lp_of_match[] = {
 	{ .compatible = "st,stm32-pwm-lp", },
+	{ .compatible = "st,stm32mp25-pwm-lp", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_pwm_lp_of_match);
diff --git a/drivers/pwm/pwm-stm32.c b/drivers/pwm/pwm-stm32.c
index bdcdb7f38..a4c5c6649 100644
--- a/drivers/pwm/pwm-stm32.c
+++ b/drivers/pwm/pwm-stm32.c
@@ -19,6 +19,7 @@
 #define CCMR_CHANNEL_SHIFT 8
 #define CCMR_CHANNEL_MASK  0xFF
 #define MAX_BREAKINPUT 2
+#define MAX_PWM_OUTPUT 4
 
 struct stm32_breakinput {
 	u32 index;
@@ -207,6 +208,10 @@ static int stm32_pwm_capture(struct pwm_chip *chip, struct pwm_device *pwm,
 	regmap_write(priv->regmap, TIM_ARR, priv->max_arr);
 	regmap_write(priv->regmap, TIM_PSC, psc);
 
+	/* Reset input selector to its default input and disable slave mode */
+	regmap_write(priv->regmap, TIM_TISEL, 0x0);
+	regmap_write(priv->regmap, TIM_SMCR, 0x0);
+
 	/* Map TI1 or TI2 PWM input to IC1 & IC2 (or TI3/4 to IC3 & IC4) */
 	regmap_update_bits(priv->regmap,
 			   pwm->hwpwm < 2 ? TIM_CCMR1 : TIM_CCMR2,
@@ -560,9 +565,16 @@ static int stm32_pwm_probe_breakinputs(struct stm32_pwm *priv,
 	return stm32_pwm_apply_breakinputs(priv);
 }
 
-static void stm32_pwm_detect_complementary(struct stm32_pwm *priv)
+static void stm32_pwm_detect_complementary(struct stm32_pwm *priv, struct stm32_timers *ddata)
 {
-	u32 ccer;
+	u32 ccer, val;
+
+	if (ddata->ipidr) {
+		/* Simply read from HWCFGR the number of complementary outputs (MP25). */
+		regmap_read(priv->regmap, TIM_HWCFGR1, &val);
+		priv->have_complementary_output = !!FIELD_GET(TIM_HWCFGR1_NB_OF_DT, val);
+		return;
+	}
 
 	/*
 	 * If complementary bit doesn't exist writing 1 will have no
@@ -575,10 +587,23 @@ static void stm32_pwm_detect_complementary(struct stm32_pwm *priv)
 	priv->have_complementary_output = (ccer != 0);
 }
 
-static unsigned int stm32_pwm_detect_channels(struct stm32_pwm *priv,
+static unsigned int stm32_pwm_detect_channels(struct stm32_pwm *priv, struct stm32_timers *ddata,
 					      unsigned int *num_enabled)
 {
-	u32 ccer, ccer_backup;
+	u32 ccer, ccer_backup, val;
+	int npwm = 0;
+
+	if (ddata->ipidr) {
+		/* Simply deduce from HWCFGR the number of outputs (MP25). */
+		regmap_read(priv->regmap, TIM_HWCFGR1, &val);
+		/*
+		 * Timers may have more capture/compare channels than the
+		 * actual number of PWM channel outputs (e.g. TIM_CH[1..4]).
+		 */
+		npwm = FIELD_GET(TIM_HWCFGR1_NB_OF_CC, val);
+
+		return npwm < MAX_PWM_OUTPUT ? npwm : MAX_PWM_OUTPUT;
+	}
 
 	/*
 	 * If channels enable bits don't exist writing 1 will have no
@@ -620,11 +645,11 @@ static int stm32_pwm_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	stm32_pwm_detect_complementary(priv);
+	stm32_pwm_detect_complementary(priv, ddata);
 
 	priv->chip.dev = dev;
 	priv->chip.ops = &stm32pwm_ops;
-	priv->chip.npwm = stm32_pwm_detect_channels(priv, &num_enabled);
+	priv->chip.npwm = stm32_pwm_detect_channels(priv, ddata, &num_enabled);
 
 	/* Initialize clock refcount to number of enabled PWM channels. */
 	for (i = 0; i < num_enabled; i++)
@@ -690,6 +715,7 @@ static SIMPLE_DEV_PM_OPS(stm32_pwm_pm_ops, stm32_pwm_suspend, stm32_pwm_resume);
 
 static const struct of_device_id stm32_pwm_of_match[] = {
 	{ .compatible = "st,stm32-pwm",	},
+	{ .compatible = "st,stm32mp25-pwm", },
 	{ /* end node */ },
 };
 MODULE_DEVICE_TABLE(of, stm32_pwm_of_match);
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 070e4403c..b618e6638 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -37,6 +37,17 @@ config REGULATOR_FIXED_VOLTAGE
 	  useful for systems which use a combination of software
 	  managed regulators and simple non-configurable regulators.
 
+config REGULATOR_PROTECTION_CONSUMER
+	tristate "Regulator protection consumer"
+	depends on OF
+	help
+	  This driver handles regulator over-current detection in order to
+	  protect regulators from crashing. In case of over-current event
+	  or any IRQ, the protection consumer forces disable the regulator
+	  that was declared as supply.
+
+	  If unsure, say no.
+
 config REGULATOR_VIRTUAL_CONSUMER
 	tristate "Virtual regulator consumer support"
 	help
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 5962307e1..c7f394231 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -7,6 +7,7 @@
 obj-$(CONFIG_REGULATOR) += core.o dummy.o fixed-helper.o helpers.o devres.o irq_helpers.o
 obj-$(CONFIG_OF) += of_regulator.o
 obj-$(CONFIG_REGULATOR_FIXED_VOLTAGE) += fixed.o
+obj-$(CONFIG_REGULATOR_PROTECTION_CONSUMER) += protection-consumer.o
 obj-$(CONFIG_REGULATOR_VIRTUAL_CONSUMER) += virtual.o
 obj-$(CONFIG_REGULATOR_USERSPACE_CONSUMER) += userspace-consumer.o
 
diff --git a/drivers/regulator/protection-consumer.c b/drivers/regulator/protection-consumer.c
new file mode 100644
index 000000000..a4d299f85
--- /dev/null
+++ b/drivers/regulator/protection-consumer.c
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) STMicroelectronics 2021
+// Author: Pascal Paillet <p.paillet@foss.st.com> for STMicroelectronics.
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+/**
+ * struct protection_data - regulator driver data
+ * @reg: regulator consumer structure
+ * @nb: notifier_block structure
+ * @dev: device driver
+ */
+struct protection_data {
+	struct regulator *reg;
+	struct notifier_block nb;
+	struct device *dev;
+};
+
+/**
+ * protection_irq_handler() - irq handler
+ * @irq: irq number
+ * @dev: struct protection_data
+ *
+ * force disable the regulator
+ */
+static irqreturn_t protection_irq_handler(int irq, void *dev)
+{
+	struct protection_data *protection = (struct protection_data *)dev;
+
+	dev_warn(protection->dev, "Interrupt received on regulator\n");
+	if (regulator_is_enabled(protection->reg))
+		regulator_force_disable(protection->reg);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * regulator_event() - regulator framework callback
+ * @nb: notifier_block
+ * @event: regulator framework event
+ * @data: struct protection_data
+ *
+ * force disable the regulator in case of regulator event
+ *
+ * Return: 0 for successful probe else appropriate error
+ */
+static int regulator_event(struct notifier_block *nb, unsigned long event,
+			   void *data)
+{
+	struct protection_data *protection =
+	    container_of(nb, struct protection_data, nb);
+
+	if ((event & REGULATOR_EVENT_OVER_CURRENT) ||
+	    (event & REGULATOR_EVENT_OVER_TEMP)) {
+		dev_warn(protection->dev, "Event received on regulator\n");
+		if (regulator_is_enabled(protection->reg))
+			regulator_force_disable(protection->reg);
+	}
+
+	return 0;
+}
+
+/**
+ * protection_probe() - probe
+ * @pdev: platform_device
+ *
+ * Return: 0 for successful probe else appropriate error
+ */
+static int protection_probe(struct platform_device *pdev)
+{
+	struct protection_data *protection;
+	int irq, ret;
+
+	protection = devm_kzalloc(&pdev->dev, sizeof(struct protection_data),  GFP_KERNEL);
+	if (!protection)
+		return -ENOMEM;
+
+	protection->dev = &pdev->dev;
+
+	protection->reg = devm_regulator_get(&pdev->dev, "protection");
+	if (IS_ERR(protection->reg))
+		return PTR_ERR(protection->reg);
+
+	protection->nb.notifier_call = regulator_event;
+	ret = devm_regulator_register_notifier(protection->reg, &protection->nb);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "Failed to register regulator notifier: %d\n", ret);
+		return ret;
+	}
+
+	/* irq is optional, the driver can be used with regulator events */
+	irq = platform_get_irq_optional(pdev, 0);
+	if (irq <= 0 && (irq != -ENXIO))
+		return irq ? : -ENOENT;
+
+	if (irq > 0) {
+		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+						protection_irq_handler,
+						IRQF_ONESHOT | IRQF_SHARED,
+						pdev->name, protection);
+		if (ret) {
+			dev_err(&pdev->dev, "Request IRQ failed\n");
+			return ret;
+		}
+	}
+	platform_set_drvdata(pdev, protection);
+	dev_dbg(&pdev->dev, "protection probed\n");
+
+	return 0;
+}
+
+static const struct of_device_id protection_dt_match[] = {
+	{ .compatible = "protection-consumer" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, protection_dt_match);
+
+static struct platform_driver protection_driver = {
+	.driver = {
+		   .name = "protection-consumer",
+		   .owner = THIS_MODULE,
+		   .of_match_table = protection_dt_match,
+		   },
+	.probe = protection_probe,
+};
+
+module_platform_driver(protection_driver);
+
+MODULE_AUTHOR("<p.paillet@foss.st.com>");
+MODULE_DESCRIPTION("protection consumer driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/stm32-pwr.c b/drivers/regulator/stm32-pwr.c
index e5dd4db64..87f160d2b 100644
--- a/drivers/regulator/stm32-pwr.c
+++ b/drivers/regulator/stm32-pwr.c
@@ -3,12 +3,15 @@
 // Authors: Gabriel Fernandez <gabriel.fernandez@st.com>
 //          Pascal Paillet <p.paillet@st.com>.
 
+#include <linux/arm-smccc.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/regmap.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/of_regulator.h>
 
@@ -24,6 +27,11 @@
 #define REG_1_1_EN BIT(30)
 #define REG_1_1_RDY BIT(31)
 
+#define STM32_SMC_PWR		0x82001001
+#define STM32_WRITE		0x1
+#define STM32_SMC_REG_SET	0x2
+#define STM32_SMC_REG_CLEAR	0x3
+
 /* list of supported regulators */
 enum {
 	PWR_REG11,
@@ -39,10 +47,18 @@ static u32 ready_mask_table[STM32PWR_REG_NUM_REGS] = {
 };
 
 struct stm32_pwr_reg {
+	int tzen;
 	void __iomem *base;
 	u32 ready_mask;
 };
 
+#define SMC(class, op, address, val)\
+	({\
+	struct arm_smccc_res res;\
+	arm_smccc_smc(class, op, address, val,\
+			0, 0, 0, 0, &res);\
+	})
+
 static int stm32_pwr_reg_is_ready(struct regulator_dev *rdev)
 {
 	struct stm32_pwr_reg *priv = rdev_get_drvdata(rdev);
@@ -69,9 +85,15 @@ static int stm32_pwr_reg_enable(struct regulator_dev *rdev)
 	int ret;
 	u32 val;
 
-	val = readl_relaxed(priv->base + REG_PWR_CR3);
-	val |= rdev->desc->enable_mask;
-	writel_relaxed(val, priv->base + REG_PWR_CR3);
+	if (priv->tzen) {
+		SMC(STM32_SMC_PWR, STM32_SMC_REG_SET, REG_PWR_CR3,
+		    rdev->desc->enable_mask);
+	} else {
+		val = readl_relaxed(priv->base + REG_PWR_CR3);
+		val |= rdev->desc->enable_mask;
+		writel_relaxed(val, priv->base + REG_PWR_CR3);
+	}
+
 
 	/* use an arbitrary timeout of 20ms */
 	ret = readx_poll_timeout(stm32_pwr_reg_is_ready, rdev, val, val,
@@ -88,9 +110,14 @@ static int stm32_pwr_reg_disable(struct regulator_dev *rdev)
 	int ret;
 	u32 val;
 
-	val = readl_relaxed(priv->base + REG_PWR_CR3);
-	val &= ~rdev->desc->enable_mask;
-	writel_relaxed(val, priv->base + REG_PWR_CR3);
+	if (priv->tzen) {
+		SMC(STM32_SMC_PWR, STM32_SMC_REG_CLEAR, REG_PWR_CR3,
+		    rdev->desc->enable_mask);
+	} else {
+		val = readl_relaxed(priv->base + REG_PWR_CR3);
+		val &= ~rdev->desc->enable_mask;
+		writel_relaxed(val, priv->base + REG_PWR_CR3);
+	}
 
 	/* use an arbitrary timeout of 20ms */
 	ret = readx_poll_timeout(stm32_pwr_reg_is_ready, rdev, val, !val,
@@ -121,12 +148,50 @@ static const struct regulator_ops stm32_pwr_reg_ops = {
 		.supply_name = _supply, \
 	} \
 
-static const struct regulator_desc stm32_pwr_desc[] = {
+static struct regulator_desc stm32_pwr_desc[] = {
 	PWR_REG(PWR_REG11, "reg11", 1100000, REG_1_1_EN, "vdd"),
 	PWR_REG(PWR_REG18, "reg18", 1800000, REG_1_8_EN, "vdd"),
 	PWR_REG(PWR_USB33, "usb33", 3300000, USB_3_3_EN, "vdd_3v3_usbfs"),
 };
 
+static int is_stm32_soc_secured(struct platform_device *pdev, int *val)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct regmap *syscon;
+	u32 reg, mask;
+	int tzc_val = 0;
+	int err;
+
+	syscon = syscon_regmap_lookup_by_phandle(np, "st,tzcr");
+	if (IS_ERR(syscon)) {
+		if (PTR_ERR(syscon) != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "tzcr syscon required\n");
+		return PTR_ERR(syscon);
+	}
+
+	err = of_property_read_u32_index(np, "st,tzcr", 1, &reg);
+	if (err) {
+		dev_err(&pdev->dev, "tzcr offset required !\n");
+		return err;
+	}
+
+	err = of_property_read_u32_index(np, "st,tzcr", 2, &mask);
+	if (err) {
+		dev_err(&pdev->dev, "tzcr mask required !\n");
+		return err;
+	}
+
+	err = regmap_read(syscon, reg, &tzc_val);
+	if (err) {
+		dev_err(&pdev->dev, "failed to read tzcr status !\n");
+		return err;
+	}
+
+	*val = tzc_val & mask;
+
+	return 0;
+}
+
 static int stm32_pwr_regulator_probe(struct platform_device *pdev)
 {
 	struct stm32_pwr_reg *priv;
@@ -134,6 +199,11 @@ static int stm32_pwr_regulator_probe(struct platform_device *pdev)
 	struct regulator_dev *rdev;
 	struct regulator_config config = { };
 	int i, ret = 0;
+	int tzen = 0;
+
+	ret = is_stm32_soc_secured(pdev, &tzen);
+	if (ret)
+		return ret;
 
 	base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(base)) {
@@ -148,6 +218,7 @@ static int stm32_pwr_regulator_probe(struct platform_device *pdev)
 				    GFP_KERNEL);
 		if (!priv)
 			return -ENOMEM;
+		priv->tzen = tzen;
 		priv->base = base;
 		priv->ready_mask = ready_mask_table[i];
 		config.driver_data = priv;
diff --git a/drivers/regulator/stpmic1_regulator.c b/drivers/regulator/stpmic1_regulator.c
index 2d7597c76..ff397c5eb 100644
--- a/drivers/regulator/stpmic1_regulator.c
+++ b/drivers/regulator/stpmic1_regulator.c
@@ -2,7 +2,9 @@
 // Copyright (C) STMicroelectronics 2018
 // Author: Pascal Paillet <p.paillet@st.com> for STMicroelectronics.
 
+#include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/ktime.h>
 #include <linux/mfd/stpmic1.h>
 #include <linux/module.h>
 #include <linux/of_irq.h>
@@ -30,11 +32,27 @@ struct stpmic1_regulator_cfg {
 	u8 icc_mask;
 };
 
+/**
+ * struct boost_data - this structure is used as driver data for the usb boost
+ * @boost_rdev: device for boost regulator
+ * @vbus_otg_rdev: device for vbus_otg regulator
+ * @sw_out_rdev: device for sw_out regulator
+ * @occ_timeout: overcurrent detection timeout
+ */
+struct boost_data {
+	struct regulator_dev *boost_rdev;
+	struct regulator_dev *vbus_otg_rdev;
+	struct regulator_dev *sw_out_rdev;
+	ktime_t occ_timeout;
+};
+
 static int stpmic1_set_mode(struct regulator_dev *rdev, unsigned int mode);
 static unsigned int stpmic1_get_mode(struct regulator_dev *rdev);
 static int stpmic1_set_icc(struct regulator_dev *rdev, int lim, int severity,
 			   bool enable);
 static unsigned int stpmic1_map_mode(unsigned int mode);
+static int regulator_enable_boost(struct regulator_dev *rdev);
+static int regulator_disable_boost(struct regulator_dev *rdev);
 
 enum {
 	STPMIC1_BUCK1 = 0,
@@ -182,8 +200,8 @@ static const struct regulator_ops stpmic1_vref_ddr_ops = {
 
 static const struct regulator_ops stpmic1_boost_regul_ops = {
 	.is_enabled = regulator_is_enabled_regmap,
-	.enable = regulator_enable_regmap,
-	.disable = regulator_disable_regmap,
+	.enable = regulator_enable_boost,
+	.disable = regulator_disable_boost,
 	.set_over_current_protection = stpmic1_set_icc,
 };
 
@@ -529,32 +547,109 @@ static irqreturn_t stpmic1_curlim_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static int regulator_enable_boost(struct regulator_dev *rdev)
+{
+	struct boost_data *usb_data = rdev_get_drvdata(rdev);
+
+	usb_data->occ_timeout = ktime_add_us(ktime_get(), 100000);
+
+	return regulator_enable_regmap(rdev);
+}
+
+static int regulator_disable_boost(struct regulator_dev *rdev)
+{
+	struct boost_data *usb_data = rdev_get_drvdata(rdev);
+
+	usb_data->occ_timeout = 0;
+
+	return regulator_disable_regmap(rdev);
+}
+
+static void stpmic1_reset_boost(struct boost_data *usb_data)
+{
+	int otg_on = 0;
+	int sw_out_on = 0;
+
+	dev_dbg(rdev_get_dev(usb_data->boost_rdev), "reset usb boost\n");
+
+	/* the boost was actually disabled by the over-current protection */
+	regulator_disable_regmap(usb_data->boost_rdev);
+
+	if (usb_data->vbus_otg_rdev)
+		otg_on = regulator_is_enabled_regmap(usb_data->vbus_otg_rdev);
+	if (otg_on)
+		regulator_disable_regmap(usb_data->vbus_otg_rdev);
+
+	if (usb_data->sw_out_rdev)
+		sw_out_on = regulator_is_enabled_regmap(usb_data->sw_out_rdev);
+	if (sw_out_on)
+		regulator_disable_regmap(usb_data->sw_out_rdev);
+
+	regulator_enable_regmap(usb_data->boost_rdev);
+
+	/* sleep at least 5ms */
+	usleep_range(5000, 10000);
+
+	if (otg_on)
+		regulator_enable_regmap(usb_data->vbus_otg_rdev);
+
+	if (sw_out_on)
+		regulator_enable_regmap(usb_data->sw_out_rdev);
+
+}
+
+static irqreturn_t stpmic1_boost_irq_handler(int irq, void *data)
+{
+	struct boost_data *usb_data = (struct boost_data *)data;
+
+	dev_dbg(rdev_get_dev(usb_data->boost_rdev), "usb boost irq handler\n");
+
+	/* overcurrent detected on boost after timeout */
+	if (usb_data->occ_timeout != 0 &&
+	    ktime_compare(ktime_get(), usb_data->occ_timeout) > 0) {
+		/* reset usb boost and usb power switches */
+		stpmic1_reset_boost(usb_data);
+		return IRQ_HANDLED;
+	}
+
+	/* Send an overcurrent notification */
+	regulator_notifier_call_chain(usb_data->boost_rdev,
+				      REGULATOR_EVENT_OVER_CURRENT,
+				      NULL);
+
+	return IRQ_HANDLED;
+}
+
 #define MATCH(_name, _id) \
-	[STPMIC1_##_id] = { \
-		.name = #_name, \
+	{ \
+		.name = _name, \
 		.desc = &stpmic1_regulator_cfgs[STPMIC1_##_id].desc, \
 	}
 
 static struct of_regulator_match stpmic1_matches[] = {
-	MATCH(buck1, BUCK1),
-	MATCH(buck2, BUCK2),
-	MATCH(buck3, BUCK3),
-	MATCH(buck4, BUCK4),
-	MATCH(ldo1, LDO1),
-	MATCH(ldo2, LDO2),
-	MATCH(ldo3, LDO3),
-	MATCH(ldo4, LDO4),
-	MATCH(ldo5, LDO5),
-	MATCH(ldo6, LDO6),
-	MATCH(vref_ddr, VREF_DDR),
-	MATCH(boost, BOOST),
-	MATCH(pwr_sw1, VBUS_OTG),
-	MATCH(pwr_sw2, SW_OUT),
+	MATCH("buck1", BUCK1),
+	MATCH("buck2", BUCK2),
+	MATCH("buck3", BUCK3),
+	MATCH("buck4", BUCK4),
+	MATCH("ldo1", LDO1),
+	MATCH("ldo2", LDO2),
+	MATCH("ldo3", LDO3),
+	MATCH("ldo4", LDO4),
+	MATCH("ldo5", LDO5),
+	MATCH("ldo6", LDO6),
+	MATCH("vref_ddr", VREF_DDR),
+	MATCH("vref-ddr", VREF_DDR),
+	MATCH("boost", BOOST),
+	MATCH("pwr_sw1", VBUS_OTG),
+	MATCH("pwr-sw1", VBUS_OTG),
+	MATCH("pwr_sw2", SW_OUT),
+	MATCH("pwr-sw2", SW_OUT),
 };
 
-static int stpmic1_regulator_register(struct platform_device *pdev, int id,
-				      struct of_regulator_match *match,
-				      const struct stpmic1_regulator_cfg *cfg)
+static struct regulator_dev *
+stpmic1_regulator_register(struct platform_device *pdev, int id,
+			   struct of_regulator_match *match,
+			   const struct stpmic1_regulator_cfg *cfg)
 {
 	struct stpmic1 *pmic_dev = dev_get_drvdata(pdev->dev.parent);
 	struct regulator_dev *rdev;
@@ -572,7 +667,7 @@ static int stpmic1_regulator_register(struct platform_device *pdev, int id,
 	if (IS_ERR(rdev)) {
 		dev_err(&pdev->dev, "failed to register %s regulator\n",
 			cfg->desc.name);
-		return PTR_ERR(rdev);
+		return rdev;
 	}
 
 	/* set mask reset */
@@ -584,7 +679,7 @@ static int stpmic1_regulator_register(struct platform_device *pdev, int id,
 					 cfg->mask_reset_mask);
 		if (ret) {
 			dev_err(&pdev->dev, "set mask reset failed\n");
-			return ret;
+			return ERR_PTR(ret);
 		}
 	}
 
@@ -598,15 +693,60 @@ static int stpmic1_regulator_register(struct platform_device *pdev, int id,
 						pdev->name, rdev);
 		if (ret) {
 			dev_err(&pdev->dev, "Request IRQ failed\n");
-			return ret;
+			return ERR_PTR(ret);
 		}
 	}
-	return 0;
+
+	return rdev;
+}
+
+static struct regulator_dev *
+stpmic1_boost_register(struct platform_device *pdev, int id,
+		       struct of_regulator_match *match,
+		       const struct stpmic1_regulator_cfg *cfg,
+		       struct boost_data *usb_data)
+{
+	struct stpmic1 *pmic_dev = dev_get_drvdata(pdev->dev.parent);
+	struct regulator_dev *rdev;
+	struct regulator_config config = {};
+	int ret = 0;
+	int irq;
+
+	config.dev = &pdev->dev;
+	config.init_data = match->init_data;
+	config.of_node = match->of_node;
+	config.regmap = pmic_dev->regmap;
+	config.driver_data = (void *)usb_data;
+
+	rdev = devm_regulator_register(&pdev->dev, &cfg->desc, &config);
+	if (IS_ERR(rdev)) {
+		dev_err(&pdev->dev, "failed to register %s regulator\n",
+			cfg->desc.name);
+		return rdev;
+	}
+
+	/* setup an irq handler for over-current detection */
+	irq = of_irq_get(config.of_node, 0);
+	if (irq > 0) {
+		ret = devm_request_threaded_irq(&pdev->dev,
+						irq, NULL,
+						stpmic1_boost_irq_handler,
+						IRQF_ONESHOT, pdev->name,
+						usb_data);
+		if (ret) {
+			dev_err(&pdev->dev, "Request IRQ failed\n");
+			return ERR_PTR(ret);
+		}
+	}
+
+	return rdev;
 }
 
 static int stpmic1_regulator_probe(struct platform_device *pdev)
 {
 	int i, ret;
+	struct boost_data *usb_data;
+	struct regulator_dev *rdev;
 
 	ret = of_regulator_match(&pdev->dev, pdev->dev.of_node, stpmic1_matches,
 				 ARRAY_SIZE(stpmic1_matches));
@@ -616,11 +756,35 @@ static int stpmic1_regulator_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(stpmic1_regulator_cfgs); i++) {
-		ret = stpmic1_regulator_register(pdev, i, &stpmic1_matches[i],
-						 &stpmic1_regulator_cfgs[i]);
-		if (ret < 0)
-			return ret;
+	usb_data = devm_kzalloc(&pdev->dev, sizeof(*usb_data), GFP_KERNEL);
+	if (!usb_data)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(stpmic1_matches); i++) {
+		int id = stpmic1_matches[i].desc->id;
+
+		if (!stpmic1_matches[i].init_data)
+			continue;
+
+		if (id == STPMIC1_BOOST) {
+			rdev =
+			stpmic1_boost_register(pdev, id, &stpmic1_matches[i],
+					       &stpmic1_regulator_cfgs[id],
+					       usb_data);
+
+			usb_data->boost_rdev = rdev;
+		} else {
+			rdev =
+			stpmic1_regulator_register(pdev, id, &stpmic1_matches[i],
+						   &stpmic1_regulator_cfgs[id]);
+
+			if (id == STPMIC1_VBUS_OTG)
+				usb_data->vbus_otg_rdev = rdev;
+			else if (id == STPMIC1_SW_OUT)
+				usb_data->sw_out_rdev = rdev;
+		}
+		if (IS_ERR(rdev))
+			return PTR_ERR(rdev);
 	}
 
 	dev_dbg(&pdev->dev, "stpmic1_regulator driver probed\n");
diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index 166019786..3de9b97e3 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -23,6 +23,25 @@ config REMOTEPROC_CDEV
 
 	  It's safe to say N if you don't want to use this interface.
 
+config REMOTEPROC_SRM_CORE
+	tristate "Remoteproc System Resource Manager core"
+	depends on RPMSG
+	help
+	  Say y here to enable the core driver of the remoteproc System Resource
+	  Manager (SRM).
+	  The SRM handles resources allocated to remote processors.
+	  The core part is in charge of controlling the device children.
+
+config REMOTEPROC_SRM_DEV
+	tristate "Remoteproc System Resource Manager device"
+	depends on REMOTEPROC_SRM_CORE
+	help
+	  Say y here to enable the device driver of the remoteproc System
+	  Resource Manager (SRM).
+	  The SRM handles resources allocated to remote processors.
+	  The device part is in charge of reserving and initializing resources
+	  for a peripheral assigned to a coprocessor.
+
 config IMX_REMOTEPROC
 	tristate "i.MX remoteproc support"
 	depends on ARCH_MXC
@@ -313,9 +332,10 @@ config ST_SLIM_REMOTEPROC
 
 config STM32_RPROC
 	tristate "STM32 remoteproc support"
-	depends on ARCH_STM32
+	depends on ARCH_STM32 || COMPILE_TEST
 	depends on REMOTEPROC
 	select MAILBOX
+	select TEE_REMOTEPROC
 	help
 	  Say y here to support STM32 MCU processors via the
 	  remote processor framework.
@@ -352,6 +372,15 @@ config TI_K3_R5_REMOTEPROC
 	  It's safe to say N here if you're not interested in utilizing
 	  a slave processor.
 
+
+config TEE_REMOTEPROC
+	tristate "trusted firmware support by a trusted application"
+	depends on OPTEE
+	help
+	  Support for trusted remote processors firmware. The firmware
+	  authentication and/or decryption are managed by a trusted application.
+	  This can be either built-in or a loadable module.
+
 endif # REMOTEPROC
 
 endmenu
diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
index 5478c7cb9..a759e6996 100644
--- a/drivers/remoteproc/Makefile
+++ b/drivers/remoteproc/Makefile
@@ -11,6 +11,9 @@ remoteproc-y				+= remoteproc_sysfs.o
 remoteproc-y				+= remoteproc_virtio.o
 remoteproc-y				+= remoteproc_elf_loader.o
 obj-$(CONFIG_REMOTEPROC_CDEV)		+= remoteproc_cdev.o
+obj-$(CONFIG_REMOTEPROC_SRM_CORE)	+= rproc_srm_core.o
+obj-$(CONFIG_REMOTEPROC_SRM_DEV)	+= rproc_srm_dev.o
+obj-$(CONFIG_TEE_REMOTEPROC)		+= tee_remoteproc.o
 obj-$(CONFIG_IMX_REMOTEPROC)		+= imx_rproc.o
 obj-$(CONFIG_IMX_DSP_REMOTEPROC)	+= imx_dsp_rproc.o
 obj-$(CONFIG_INGENIC_VPU_RPROC)		+= ingenic_rproc.o
diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index c3f194d93..ddcd5efbc 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -36,6 +36,7 @@
 #include <linux/of_reserved_mem.h>
 #include <linux/virtio_ids.h>
 #include <linux/virtio_ring.h>
+#include <linux/of_platform.h>
 #include <asm/byteorder.h>
 #include <linux/platform_device.h>
 
@@ -2290,6 +2291,11 @@ int rproc_add(struct rproc *rproc)
 	/* create debugfs entries */
 	rproc_create_debug_dir(rproc);
 
+	/* add resource manager device */
+	ret = devm_of_platform_populate(dev->parent);
+	if (ret < 0)
+		return ret;
+
 	/* if rproc is marked always-on, request it to boot */
 	if (rproc->auto_boot) {
 		ret = rproc_trigger_auto_boot(rproc);
@@ -2571,6 +2577,8 @@ int rproc_del(struct rproc *rproc)
 	list_del_rcu(&rproc->node);
 	mutex_unlock(&rproc_list_mutex);
 
+	of_platform_depopulate(rproc->dev.parent);
+
 	/* Ensure that no readers of rproc_list are still active */
 	synchronize_rcu();
 
diff --git a/drivers/remoteproc/remoteproc_sysfs.c b/drivers/remoteproc/remoteproc_sysfs.c
index 8c7ea8922..f356614f2 100644
--- a/drivers/remoteproc/remoteproc_sysfs.c
+++ b/drivers/remoteproc/remoteproc_sysfs.c
@@ -174,6 +174,17 @@ static const char * const rproc_state_string[] = {
 	[RPROC_LAST]		= "invalid",
 };
 
+/*
+ * A firmware-format-to-string lookup table, for exposing a human readable
+ * supported firmware format via sysfs. Always keep in sync with enum
+ * rproc_fw_format.
+ */
+static const char * const rproc_format_string[] = {
+	[RPROC_FW_ELF]		= "ELF",
+	[RPROC_FW_TEE]		= "TEE",
+	[RPROC_FW_LAST]		= "invalid",
+};
+
 /* Expose the state of the remote processor via sysfs */
 static ssize_t state_show(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -235,12 +246,23 @@ static umode_t rproc_is_visible(struct kobject *kobj, struct attribute *attr,
 	return mode;
 }
 
+/* Expose the format of the remote processor binary firmware via sysfs */
+static ssize_t fw_format_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct rproc *rproc = to_rproc(dev);
+	unsigned int fw_format;
+	fw_format = rproc->fw_format > RPROC_FW_LAST ? RPROC_FW_LAST : rproc->fw_format;
+	return sprintf(buf, "%s\n", rproc_format_string[fw_format]);
+}
+static DEVICE_ATTR_RO(fw_format);
 static struct attribute *rproc_attrs[] = {
 	&dev_attr_coredump.attr,
 	&dev_attr_recovery.attr,
 	&dev_attr_firmware.attr,
 	&dev_attr_state.attr,
 	&dev_attr_name.attr,
+	&dev_attr_fw_format.attr,
 	NULL
 };
 
diff --git a/drivers/remoteproc/rproc_srm_core.c b/drivers/remoteproc/rproc_srm_core.c
new file mode 100644
index 000000000..b1251cd4f
--- /dev/null
+++ b/drivers/remoteproc/rproc_srm_core.c
@@ -0,0 +1,292 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+#include <linux/component.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/remoteproc.h>
+#include <linux/rpmsg.h>
+
+#include "rproc_srm_core.h"
+
+#define BIND_TIMEOUT 10000
+
+struct rproc_srm_core {
+	struct device *dev;
+	struct completion all_bound;
+	int bind_status;
+	atomic_t prepared;
+	struct rproc_subdev subdev;
+	struct rpmsg_driver rpdrv;
+	struct blocking_notifier_head notifier;
+};
+
+#define to_rproc_srm_core(s) container_of(s, struct rproc_srm_core, subdev)
+
+static struct rproc_srm_core *rpmsg_srm_to_core(struct rpmsg_device *rpdev)
+{
+	struct rpmsg_driver *rpdrv;
+	struct rproc_srm_core *core;
+
+	rpdrv = container_of(rpdev->dev.driver, struct rpmsg_driver, drv);
+	core = container_of(rpdrv, struct rproc_srm_core, rpdrv);
+
+	return core;
+}
+
+int rpmsg_srm_send(struct rpmsg_endpoint *ept, struct rpmsg_srm_msg *msg)
+{
+	int ret;
+
+	ret = rpmsg_send(ept, (void *)msg, sizeof(*msg));
+	if (ret)
+		dev_err(&ept->rpdev->dev, "rpmsg_send failed: %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(rpmsg_srm_send);
+
+static int rpmsg_srm_cb(struct rpmsg_device *rpdev, void *data, int len,
+			void *priv, u32 src)
+{
+	struct rproc_srm_core *core = rpmsg_srm_to_core(rpdev);
+	struct rpmsg_srm_msg_desc desc;
+	int ret;
+
+	desc.ept = rpdev->ept;
+	desc.msg = data;
+
+	ret = blocking_notifier_call_chain(&core->notifier, 0, &desc);
+
+	if (!(ret & NOTIFY_STOP_MASK)) {
+		dev_warn(&rpdev->dev, "unknown device\n");
+		desc.msg->message_type = RPROC_SRM_MSG_ERROR;
+		rpmsg_srm_send(desc.ept, desc.msg);
+	}
+
+	return 0;
+}
+
+static int rpmsg_srm_probe(struct rpmsg_device *rpdev)
+{
+	int ret;
+
+	/* Send an empty message to complete the initialization */
+	ret = rpmsg_send(rpdev->ept, NULL, 0);
+	if (ret)
+		dev_err(&rpdev->dev, "failed to send init message\n");
+
+	return ret;
+}
+
+static void rpmsg_srm_remove(struct rpmsg_device *rpdev)
+{
+	/* Note : the remove ops is mandatory */
+}
+
+static struct rpmsg_device_id rpmsg_srm_id_table[] = {
+	{ .name	= "rproc-srm" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_srm_id_table);
+
+static struct rpmsg_driver rpmsg_srm_drv = {
+	.drv.name	= "rpmsg_srm",
+	.id_table	= rpmsg_srm_id_table,
+	.probe		= rpmsg_srm_probe,
+	.callback	= rpmsg_srm_cb,
+	.remove		= rpmsg_srm_remove,
+};
+
+int rproc_srm_core_register_notifier(struct rproc_srm_core *core,
+				     struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&core->notifier, nb);
+}
+EXPORT_SYMBOL(rproc_srm_core_register_notifier);
+
+int rproc_srm_core_unregister_notifier(struct rproc_srm_core *core,
+				       struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&core->notifier, nb);
+}
+EXPORT_SYMBOL(rproc_srm_core_unregister_notifier);
+
+static int compare_of(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+static void release_of(struct device *dev, void *data)
+{
+	of_node_put(data);
+}
+
+static void rproc_srm_core_unbind(struct device *dev)
+{
+	component_unbind_all(dev, NULL);
+}
+
+static int rproc_srm_core_bind(struct device *dev)
+{
+	struct rproc_srm_core *rproc_srm_core = dev_get_drvdata(dev);
+
+	rproc_srm_core->bind_status = component_bind_all(dev, NULL);
+	complete(&rproc_srm_core->all_bound);
+
+	return rproc_srm_core->bind_status;
+}
+
+static const struct component_master_ops srm_comp_ops = {
+	.bind = rproc_srm_core_bind,
+	.unbind = rproc_srm_core_unbind,
+};
+
+static int rproc_srm_core_prepare(struct rproc_subdev *subdev)
+{
+	struct rproc_srm_core *rproc_srm_core = to_rproc_srm_core(subdev);
+	struct device *dev = rproc_srm_core->dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *child_np;
+	struct component_match *match = NULL;
+	int ret;
+
+	init_completion(&rproc_srm_core->all_bound);
+
+	ret = devm_of_platform_populate(dev);
+	if (ret) {
+		dev_err(dev, "cannot populate node (%d)\n", ret);
+		return ret;
+	}
+
+	child_np = of_get_next_available_child(node, NULL);
+
+	while (child_np) {
+		of_node_get(child_np);
+		component_match_add_release(dev, &match, release_of, compare_of,
+					    child_np);
+		child_np = of_get_next_available_child(node, child_np);
+	}
+
+	if (!match) {
+		dev_dbg(dev, "No available child\n");
+		goto done;
+	}
+
+	ret = component_master_add_with_match(dev, &srm_comp_ops, match);
+	if (ret)
+		goto depopulate;
+
+	/* Wait for every child to be bound */
+	if (!wait_for_completion_timeout(&rproc_srm_core->all_bound,
+					 msecs_to_jiffies(BIND_TIMEOUT))) {
+		dev_err(dev, "failed to bind one or more system resource device(s)\n");
+		ret = -ETIMEDOUT;
+		goto master;
+	}
+
+	ret = rproc_srm_core->bind_status;
+	if (ret) {
+		dev_err(dev, "failed to bind\n");
+		goto master;
+	}
+
+	/* Register rpmsg driver for dynamic management */
+	rproc_srm_core->rpdrv = rpmsg_srm_drv;
+	ret = register_rpmsg_driver(&rproc_srm_core->rpdrv);
+	if (ret) {
+		dev_err(dev, "failed to register rpmsg drv\n");
+		goto master;
+	}
+
+done:
+	atomic_inc(&rproc_srm_core->prepared);
+
+	return 0;
+
+master:
+	component_master_del(dev, &srm_comp_ops);
+depopulate:
+	devm_of_platform_depopulate(dev);
+	return ret;
+}
+
+static void rproc_srm_core_unprepare(struct rproc_subdev *subdev)
+{
+	struct rproc_srm_core *rproc_srm_core = to_rproc_srm_core(subdev);
+	struct device *dev = rproc_srm_core->dev;
+
+	if (!atomic_read(&rproc_srm_core->prepared))
+		return;
+
+	atomic_dec(&rproc_srm_core->prepared);
+
+	unregister_rpmsg_driver(&rproc_srm_core->rpdrv);
+
+	component_master_del(dev, &srm_comp_ops);
+	devm_of_platform_depopulate(dev);
+}
+
+static int rproc_srm_core_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc *rproc = dev_get_drvdata(dev->parent);
+	struct rproc_srm_core *rproc_srm_core;
+
+	rproc_srm_core = devm_kzalloc(dev, sizeof(struct rproc_srm_core),
+				      GFP_KERNEL);
+	if (!rproc_srm_core)
+		return -ENOMEM;
+
+	rproc_srm_core->dev = dev;
+	BLOCKING_INIT_NOTIFIER_HEAD(&rproc_srm_core->notifier);
+
+	/* Register rproc subdevice with (un)prepare ops */
+	rproc_srm_core->subdev.prepare = rproc_srm_core_prepare;
+	rproc_srm_core->subdev.unprepare = rproc_srm_core_unprepare;
+	rproc_add_subdev(rproc, &rproc_srm_core->subdev);
+
+	dev_set_drvdata(dev, rproc_srm_core);
+
+	return 0;
+}
+
+static int rproc_srm_core_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc_srm_core *rproc_srm_core = dev_get_drvdata(dev);
+	struct rproc *rproc = dev_get_drvdata(dev->parent);
+
+	if (atomic_read(&rproc->power) > 0)
+		dev_warn(dev, "Releasing resources while firmware running!\n");
+
+	rproc_srm_core_unprepare(&rproc_srm_core->subdev);
+
+	return 0;
+}
+
+static const struct of_device_id rproc_srm_core_match[] = {
+	{ .compatible = "rproc-srm-core", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rproc_srm_core_match);
+
+static struct platform_driver rproc_srm_core_driver = {
+	.probe = rproc_srm_core_probe,
+	.remove = rproc_srm_core_remove,
+	.driver = {
+		.name = "rproc-srm-core",
+		.of_match_table = of_match_ptr(rproc_srm_core_match),
+	},
+};
+
+module_platform_driver(rproc_srm_core_driver);
+
+MODULE_AUTHOR("Fabien Dessenne <fabien.dessenne@st.com>");
+MODULE_DESCRIPTION("Remoteproc System Resource Manager driver - core");
+MODULE_LICENSE("GPL");
diff --git a/drivers/remoteproc/rproc_srm_core.h b/drivers/remoteproc/rproc_srm_core.h
new file mode 100644
index 000000000..7dffdb38f
--- /dev/null
+++ b/drivers/remoteproc/rproc_srm_core.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+#ifndef _RPROC_SRM_CORE_H_
+#define _RPROC_SRM_CORE_H_
+
+/**
+ * Message type used in resource manager rpmsg:
+ *  RPROC_SRM_MSG_GETCONFIG:    Request to get the configuration of a resource
+ *  RPROC_SRM_MSG_SETCONFIG:    Request to set the configuration of a resource
+ *  RPROC_SRM_MSG_ERROR:        Error when processing a request
+ */
+#define RPROC_SRM_MSG_GETCONFIG 0x00
+#define RPROC_SRM_MSG_SETCONFIG 0x01
+#define RPROC_SRM_MSG_ERROR     0xFF
+
+/**
+ * Resource type used in resource manager rpmsg:
+ *  RPROC_SRM_RSC_CLOCK:        clock resource
+ *  RPROC_SRM_RSC_REGU:         regulator resource
+ */
+#define RPROC_SRM_RSC_CLOCK     0x00
+#define RPROC_SRM_RSC_REGU      0x01
+
+/**
+ * struct clock_cfg - clock configuration used in resource manager rpmsg
+ * @index:      clock index
+ * @name:       clock name
+ * @rate:       clock rate request (in SetConfig message) or current status (in
+ *              GetConfig message)
+ */
+struct clock_cfg {
+	u32 index;
+	u8 name[16];
+	u32 rate;
+};
+
+/**
+ * struct regu_cfg - regu configuration used in resource manager rpmsg
+ * @index:      regulator index
+ * @name:       regulator name
+ * @enable:     regulator enable/disable request (in SetConfig message) or
+ *              current status (in GetConfig message)
+ * @curr_voltage_mv: current regulator voltage in mV (meaningful in
+ *                   SetConfig message)
+ * @min_voltage_mv:  regulator min voltage request in mV (meaningful in
+ *                   SetConfig message)
+ * @max_voltage_mv:  regulator max voltage request in mV (meaningful in
+ *                   SetConfig message)
+ */
+struct regu_cfg {
+	u32 index;
+	u8 name[16];
+	u32 enable;
+	u32 curr_voltage_mv;
+	u32 min_voltage_mv;
+	u32 max_voltage_mv;
+};
+
+/**
+ * struct rpmsg_srm_msg - message structure used between processors to
+ *                        dynamically update resources configuration
+ * @message_type: type of the message: see RPROC_SRM_MSG*
+ * @device_id:  an identifier specifying the device owning the resources.
+ *              This is implementation dependent. As example it may be the
+ *              device name or the device address.
+ * @rsc_type:   the type of the resource for which the configuration applies:
+ *              see RPROC_SRM_RSC*
+ * @clock_cfg:  clock config - relevant if &rsc_type is RPROC_SRM_RSC_CLOCK
+ * @regu_cfg:   regulator config - relevant if &rsc_type is RPROC_SRM_RSC_REGU
+ */
+struct rpmsg_srm_msg {
+	u32 message_type;
+	u8 device_id[32];
+	u32 rsc_type;
+	union {
+		struct clock_cfg clock_cfg;
+		struct regu_cfg regu_cfg;
+	};
+};
+
+struct rpmsg_srm_msg_desc {
+	struct rpmsg_endpoint *ept;
+	struct rpmsg_srm_msg *msg;
+};
+
+struct rproc_srm_core;
+
+int rproc_srm_core_register_notifier(struct rproc_srm_core *core,
+				     struct notifier_block *nb);
+int rproc_srm_core_unregister_notifier(struct rproc_srm_core *core,
+				       struct notifier_block *nb);
+int rpmsg_srm_send(struct rpmsg_endpoint *ept, struct rpmsg_srm_msg *msg);
+
+#endif
diff --git a/drivers/remoteproc/rproc_srm_dev.c b/drivers/remoteproc/rproc_srm_dev.c
new file mode 100644
index 000000000..f8145f174
--- /dev/null
+++ b/drivers/remoteproc/rproc_srm_dev.c
@@ -0,0 +1,736 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/component.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/remoteproc.h>
+
+#include "rproc_srm_core.h"
+
+struct rproc_srm_clk_info {
+	struct list_head list;
+	unsigned int index;
+	struct clk *clk;
+	const char *name;
+	bool parent_enabled;
+};
+
+struct rproc_srm_regu_info {
+	struct list_head list;
+	unsigned int index;
+	struct regulator *regu;
+	const char *name;
+	bool enabled;
+};
+
+struct rproc_srm_irq_info {
+	struct list_head list;
+	unsigned int index;
+	char *name;
+	int irq;
+	bool enabled;
+};
+
+struct rproc_srm_dev {
+	struct device *dev;
+	struct rproc_srm_core *core;
+	struct notifier_block nb;
+	bool early_boot;
+
+	struct list_head clk_list_head;
+	struct list_head regu_list_head;
+	struct list_head irq_list_head;
+};
+
+/* Irqs */
+static void rproc_srm_dev_irqs_put(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct rproc_srm_irq_info *i, *tmp;
+
+	list_for_each_entry_safe(i, tmp, &rproc_srm_dev->irq_list_head, list) {
+		devm_free_irq(dev, i->irq, NULL);
+		dev_dbg(dev, "Put irq %d (%s)\n", i->irq, i->name);
+		list_del(&i->list);
+	}
+}
+
+static irqreturn_t rproc_srm_dev_irq_handler(int irq, void *dev)
+{
+	dev_warn(dev, "Spurious interrupt\n");
+	return IRQ_HANDLED;
+}
+
+static int rproc_srm_dev_irqs_get(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct device_node *np = dev->of_node;
+	struct rproc_srm_irq_info *info;
+	const char *name;
+	int nr, ret, irq;
+	unsigned int i;
+
+	if (!np)
+		return 0;
+
+	nr = platform_irq_count(pdev);
+	if (!nr)
+		return 0;
+
+	if (rproc_srm_dev->early_boot)
+		/*
+		 * Do not overwrite the irq configuration.
+		 * No need to parse irq from DT since the resource manager does
+		 * not offer any service to update the irq config.
+		 */
+		return 0;
+
+	for (i = 0; i < nr; i++) {
+		info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
+		if (!info) {
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		irq = platform_get_irq(pdev, i);
+		if (irq <= 0) {
+			ret = irq;
+			dev_err(dev, "Failed to get irq (%d)\n", ret);
+			goto err;
+		}
+
+		info->irq = irq;
+
+		/* Register a dummy irq handleras not used by Linux */
+		ret = devm_request_irq(dev, info->irq,
+				       rproc_srm_dev_irq_handler, 0,
+				       dev_name(dev), NULL);
+		if (ret) {
+			dev_err(dev, "Failed to request irq (%d)\n", ret);
+			goto err;
+		}
+
+		/*
+		 * Disable IRQ. Since it is used by the remote processor we
+		 * must not use the 'irq lazy disable' optimization
+		 */
+		irq_set_status_flags(info->irq, IRQ_DISABLE_UNLAZY);
+		disable_irq(info->irq);
+
+		/* Note: "interrupt-names" is optional */
+		if (!of_property_read_string_index(np, "interrupt-names", i,
+						   &name))
+			info->name = devm_kstrdup(dev, name, GFP_KERNEL);
+		else
+			info->name = devm_kstrdup(dev, "", GFP_KERNEL);
+
+		info->index = i;
+
+		list_add_tail(&info->list, &rproc_srm_dev->irq_list_head);
+		dev_dbg(dev, "Got irq %d (%s)\n", info->irq, info->name);
+	}
+
+	return 0;
+
+err:
+	rproc_srm_dev_irqs_put(rproc_srm_dev);
+
+	return ret;
+}
+
+/* Clocks */
+static void rproc_srm_dev_clocks_unsetup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_clk_info *c;
+
+	list_for_each_entry(c, &rproc_srm_dev->clk_list_head, list) {
+		if (!c->parent_enabled)
+			continue;
+
+		clk_disable_unprepare(clk_get_parent(c->clk));
+		c->parent_enabled = false;
+		dev_dbg(rproc_srm_dev->dev, "clk %d (%s) unsetup\n",
+			c->index, c->name);
+	}
+}
+
+static int rproc_srm_dev_clocks_setup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_clk_info *c;
+	int ret;
+
+	/*
+	 * Prepare and enable the parent clocks.
+	 * Since the clock tree is under the exclusive control of the master
+	 * processor, we need to configure the clock tree of the targeted clock.
+	 * We do not want to enable the clock itself, which is under the
+	 * responsibility of the remote processor.
+	 * Hence we prepare and enable the parent clock.
+	 */
+
+	list_for_each_entry(c, &rproc_srm_dev->clk_list_head, list) {
+		if (c->parent_enabled)
+			continue;
+
+		ret = clk_prepare_enable(clk_get_parent(c->clk));
+		if (ret) {
+			dev_err(rproc_srm_dev->dev,
+				"clk %d (%s) parent enable failed\n",
+				c->index, c->name);
+			rproc_srm_dev_clocks_unsetup(rproc_srm_dev);
+			return ret;
+		}
+		c->parent_enabled = true;
+		dev_dbg(rproc_srm_dev->dev, "clk %d (%s) parent enabled\n",
+			c->index, c->name);
+	}
+
+	return 0;
+}
+
+static struct rproc_srm_clk_info
+	*rproc_srm_dev_clock_find(struct rproc_srm_dev *rproc_srm_dev,
+				  struct clock_cfg *cfg)
+{
+	struct rproc_srm_clk_info *ci;
+
+	/* Search by index (if valid value) otherwise search by name */
+	list_for_each_entry(ci, &rproc_srm_dev->clk_list_head, list) {
+		if (cfg->index != U32_MAX) {
+			if (ci->index == cfg->index)
+				return ci;
+		} else {
+			if (!strcmp(ci->name, cfg->name))
+				return ci;
+		}
+	}
+
+	return NULL;
+}
+
+static int rproc_srm_dev_clock_set_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				       struct clock_cfg *cfg)
+{
+	struct rproc_srm_clk_info *c;
+	struct device *dev = rproc_srm_dev->dev;
+	int ret;
+
+	c = rproc_srm_dev_clock_find(rproc_srm_dev, cfg);
+
+	if (!c) {
+		dev_err(dev, "unknown clock (id %d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	if (cfg->rate && clk_get_rate(c->clk) != cfg->rate) {
+		ret = clk_set_rate(c->clk, cfg->rate);
+		if (ret) {
+			dev_err(dev, "clk set rate failed\n");
+			return ret;
+		}
+
+		dev_dbg(dev, "clk %d (%s) rate = %d\n", c->index, c->name,
+			cfg->rate);
+	}
+
+	return 0;
+}
+
+static int rproc_srm_dev_clock_get_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				       struct clock_cfg *cfg)
+{
+	struct rproc_srm_clk_info *c;
+
+	c = rproc_srm_dev_clock_find(rproc_srm_dev, cfg);
+	if (!c) {
+		dev_err(rproc_srm_dev->dev, "unknown clock (%d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	strscpy(cfg->name, c->name, sizeof(cfg->name));
+	cfg->index = c->index;
+	cfg->rate = (u32)clk_get_rate(c->clk);
+
+	return 0;
+}
+
+static void rproc_srm_dev_clocks_put(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct rproc_srm_clk_info *c, *tmp;
+
+	list_for_each_entry_safe(c, tmp, &rproc_srm_dev->clk_list_head, list) {
+		clk_put(c->clk);
+		dev_dbg(dev, "put clock %d (%s)\n", c->index, c->name);
+		list_del(&c->list);
+	}
+}
+
+static int rproc_srm_dev_clocks_get(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct rproc_srm_clk_info *c;
+	const char *name;
+	int nb_c, ret;
+	unsigned int i;
+
+	if (!np)
+		return 0;
+
+	nb_c = of_clk_get_parent_count(np);
+	if (!nb_c)
+		return 0;
+
+	for (i = 0; i < nb_c; i++) {
+		c = devm_kzalloc(dev, sizeof(*c), GFP_KERNEL);
+		if (!c) {
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		c->clk = of_clk_get(np, i);
+		if (IS_ERR(c->clk)) {
+			dev_err(dev, "clock %d KO (%ld)\n", i,
+				PTR_ERR(c->clk));
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		/* Note: "clock-names" is optional */
+		if (!of_property_read_string_index(np, "clock-names", i,
+						   &name))
+			c->name = devm_kstrdup(dev, name, GFP_KERNEL);
+		else
+			c->name = devm_kstrdup(dev, "", GFP_KERNEL);
+
+		c->index = i;
+
+		list_add_tail(&c->list, &rproc_srm_dev->clk_list_head);
+		dev_dbg(dev, "got clock %d (%s)\n", c->index, c->name);
+	}
+
+	return 0;
+
+err:
+	rproc_srm_dev_clocks_put(rproc_srm_dev);
+	return ret;
+}
+
+/* Regulators */
+static void rproc_srm_dev_regus_unsetup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_regu_info *r;
+	struct device *dev = rproc_srm_dev->dev;
+
+	list_for_each_entry(r, &rproc_srm_dev->regu_list_head, list) {
+		if (!r->enabled)
+			continue;
+
+		if (regulator_disable(r->regu)) {
+			dev_warn(dev, "regu %d disabled failed\n", r->index);
+			continue;
+		}
+
+		r->enabled = false;
+		dev_dbg(dev, "regu %d (%s) disabled\n", r->index, r->name);
+	}
+}
+
+static int rproc_srm_dev_regus_setup(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct rproc_srm_regu_info *r;
+	int ret;
+
+	/* Enable all the regulators */
+	list_for_each_entry(r, &rproc_srm_dev->regu_list_head, list) {
+		if (r->enabled)
+			continue;
+
+		/* in early_boot mode sync on hw */
+		if (rproc_srm_dev->early_boot && !regulator_is_enabled(r->regu))
+			continue;
+
+		ret = regulator_enable(r->regu);
+		if (ret) {
+			dev_err(rproc_srm_dev->dev, "regu %d (%s) failed\n",
+				r->index, r->name);
+			rproc_srm_dev_regus_unsetup(rproc_srm_dev);
+			return ret;
+		}
+		r->enabled = true;
+		dev_dbg(rproc_srm_dev->dev, "regu %d (%s) enabled\n",
+			r->index, r->name);
+	}
+
+	return 0;
+}
+
+static struct rproc_srm_regu_info
+	*rproc_srm_dev_regu_find(struct rproc_srm_dev *rproc_srm_dev,
+				 struct regu_cfg *cfg)
+{
+	struct rproc_srm_regu_info *ri;
+
+	list_for_each_entry(ri, &rproc_srm_dev->regu_list_head, list) {
+		if (cfg->index != U32_MAX) {
+			if (ri->index == cfg->index)
+				return ri;
+		} else {
+			if (!strcmp(ri->name, cfg->name))
+				return ri;
+		}
+	}
+
+	return NULL;
+}
+
+static int rproc_srm_dev_regu_set_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				      struct regu_cfg *cfg)
+{
+	struct rproc_srm_regu_info *r;
+	struct device *dev = rproc_srm_dev->dev;
+	int ret;
+
+	r = rproc_srm_dev_regu_find(rproc_srm_dev, cfg);
+	if (!r) {
+		dev_err(dev, "unknown regu (%d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	if (!r->enabled && cfg->enable) {
+		ret = regulator_enable(r->regu);
+		if (ret) {
+			dev_err(dev, "regu %d enable failed\n", r->index);
+			return ret;
+		}
+		r->enabled = true;
+		dev_dbg(dev, "regu %d (%s) enabled\n", r->index, r->name);
+	} else if (r->enabled && !cfg->enable) {
+		ret = regulator_disable(r->regu);
+		if (ret) {
+			dev_err(dev, "regu %d disable failed\n", r->index);
+			return ret;
+		}
+		r->enabled = false;
+		dev_dbg(dev, "regu %d (%s) disabled\n", r->index, r->name);
+	}
+
+	if (cfg->min_voltage_mv || cfg->max_voltage_mv) {
+		ret = regulator_set_voltage(r->regu, cfg->min_voltage_mv * 1000,
+					    cfg->max_voltage_mv * 1000);
+		if (ret) {
+			dev_err(dev, "regu %d set voltage failed\n", r->index);
+			return ret;
+		}
+
+		dev_dbg(dev, "regu %d (%s) voltage = [%d - %d] mv\n", r->index,
+			r->name, cfg->min_voltage_mv, cfg->max_voltage_mv);
+	}
+
+	return 0;
+}
+
+static int rproc_srm_dev_regu_get_cfg(struct rproc_srm_dev *rproc_srm_dev,
+				      struct regu_cfg *cfg)
+{
+	struct rproc_srm_regu_info *r;
+	struct device *dev = rproc_srm_dev->dev;
+	int v;
+
+	r = rproc_srm_dev_regu_find(rproc_srm_dev, cfg);
+	if (!r) {
+		dev_err(dev, "unknown regu (%d)\n", cfg->index);
+		return -EINVAL;
+	}
+
+	strscpy(cfg->name, r->name, sizeof(cfg->name));
+	cfg->index = r->index;
+	cfg->enable = r->enabled;
+	cfg->min_voltage_mv = 0;
+	cfg->max_voltage_mv = 0;
+
+	v = regulator_get_voltage(r->regu);
+	if (v < 0) {
+		dev_warn(dev, "cannot get %s voltage\n", r->name);
+		cfg->curr_voltage_mv = 0;
+	} else {
+		cfg->curr_voltage_mv = v / 1000;
+	}
+
+	return 0;
+}
+
+static void rproc_srm_dev_regus_put(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct rproc_srm_regu_info *r, *tmp;
+
+	list_for_each_entry_safe(r, tmp, &rproc_srm_dev->regu_list_head, list) {
+		devm_regulator_put(r->regu);
+		dev_dbg(dev, "put regu %d (%s)\n", r->index, r->name);
+		list_del(&r->list);
+	}
+}
+
+static int rproc_srm_dev_regus_get(struct rproc_srm_dev *rproc_srm_dev)
+{
+	struct device *dev = rproc_srm_dev->dev;
+	struct device_node *np = dev->of_node;
+	struct property *p;
+	const char *n;
+	char *name;
+	struct rproc_srm_regu_info *r;
+	int ret, nb_s = 0;
+
+	if (!np)
+		return 0;
+
+	for_each_property_of_node(np, p) {
+		n = strstr(p->name, "-supply");
+		if (!n || n == p->name)
+			continue;
+
+		r = devm_kzalloc(dev, sizeof(*r), GFP_KERNEL);
+		if (!r) {
+			ret = -ENOMEM;
+			goto err_list;
+		}
+
+		name = devm_kstrdup(dev, p->name, GFP_KERNEL);
+		name[strlen(p->name) - strlen("-supply")] = '\0';
+		r->name = name;
+
+		r->regu = devm_regulator_get(dev, r->name);
+		if (IS_ERR(r->regu)) {
+			dev_err(dev, "cannot get regu %s\n", r->name);
+			ret = -EINVAL;
+			goto err_list;
+		}
+
+		r->index = nb_s++;
+
+		list_add_tail(&r->list, &rproc_srm_dev->regu_list_head);
+		dev_dbg(dev, "got regu %d (%s)\n", r->index, r->name);
+	}
+
+	return 0;
+
+err_list:
+	rproc_srm_dev_regus_put(rproc_srm_dev);
+	return ret;
+}
+
+/* Core */
+static int rproc_srm_dev_notify_cb(struct notifier_block *nb, unsigned long evt,
+				   void *data)
+{
+	struct rproc_srm_dev *rproc_srm_dev =
+			container_of(nb, struct rproc_srm_dev, nb);
+	struct device *dev = rproc_srm_dev->dev;
+	struct rpmsg_srm_msg_desc *desc;
+	struct rpmsg_srm_msg *i, o;
+	int ret = 0;
+
+	desc = (struct rpmsg_srm_msg_desc *)data;
+	i = desc->msg;
+	o = *i;
+
+	/* Check if 'device_id' (name / addr ) matches this device */
+	if (!strstr(dev_name(dev), i->device_id))
+		return NOTIFY_DONE;
+
+	switch (i->message_type) {
+	case RPROC_SRM_MSG_SETCONFIG:
+		switch (i->rsc_type) {
+		case RPROC_SRM_RSC_CLOCK:
+			ret = rproc_srm_dev_clock_set_cfg(rproc_srm_dev,
+							  &i->clock_cfg);
+			if (!ret)
+				ret = rproc_srm_dev_clock_get_cfg(rproc_srm_dev,
+								  &o.clock_cfg);
+			break;
+		case RPROC_SRM_RSC_REGU:
+			ret = rproc_srm_dev_regu_set_cfg(rproc_srm_dev,
+							 &i->regu_cfg);
+			if (!ret)
+				ret = rproc_srm_dev_regu_get_cfg(rproc_srm_dev,
+								 &o.regu_cfg);
+			break;
+		default:
+			dev_warn(dev, "bad rsc type (%d)\n", i->rsc_type);
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	case RPROC_SRM_MSG_GETCONFIG:
+		switch (i->rsc_type) {
+		case RPROC_SRM_RSC_CLOCK:
+			ret = rproc_srm_dev_clock_get_cfg(rproc_srm_dev,
+							  &o.clock_cfg);
+			break;
+		case RPROC_SRM_RSC_REGU:
+			ret = rproc_srm_dev_regu_get_cfg(rproc_srm_dev,
+							 &o.regu_cfg);
+			break;
+		default:
+			dev_warn(dev, "bad rsc type (%d)\n", i->rsc_type);
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	default:
+		dev_warn(dev, "bad msg type (%d)\n", i->message_type);
+		ret = -EINVAL;
+		break;
+	}
+
+	/* Send return msg */
+	if (ret)
+		o.message_type = RPROC_SRM_MSG_ERROR;
+
+	ret = rpmsg_srm_send(desc->ept, &o);
+
+	return ret ? NOTIFY_BAD : NOTIFY_STOP;
+}
+
+static void
+rproc_srm_dev_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct rproc_srm_dev *rproc_srm_dev = dev_get_drvdata(dev);
+
+	rproc_srm_dev_regus_unsetup(rproc_srm_dev);
+	rproc_srm_dev_clocks_unsetup(rproc_srm_dev);
+
+	/* For IRQs: nothing to unsetup */
+}
+
+static int
+rproc_srm_dev_bind(struct device *dev, struct device *master, void *data)
+{
+	struct rproc_srm_dev *rproc_srm_dev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = rproc_srm_dev_clocks_setup(rproc_srm_dev);
+	if (ret)
+		return ret;
+
+	ret = rproc_srm_dev_regus_setup(rproc_srm_dev);
+	if (ret)
+		return ret;
+
+	/* For IRQs: nothing to setup */
+	return 0;
+}
+
+static const struct component_ops rproc_srm_dev_ops = {
+	.bind = rproc_srm_dev_bind,
+	.unbind = rproc_srm_dev_unbind,
+};
+
+static int rproc_srm_dev_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc_srm_dev *rproc_srm_dev;
+	struct rproc *rproc;
+	int ret;
+
+	dev_dbg(dev, "%s for node %s\n", __func__, dev->of_node->name);
+
+	rproc_srm_dev = devm_kzalloc(dev, sizeof(struct rproc_srm_dev),
+				     GFP_KERNEL);
+	if (!rproc_srm_dev)
+		return -ENOMEM;
+
+	rproc_srm_dev->dev = dev;
+	rproc = (struct rproc *)dev_get_drvdata(dev->parent->parent);
+	rproc_srm_dev->early_boot = (rproc->state == RPROC_DETACHED);
+	rproc_srm_dev->core = dev_get_drvdata(dev->parent);
+
+	INIT_LIST_HEAD(&rproc_srm_dev->clk_list_head);
+	INIT_LIST_HEAD(&rproc_srm_dev->regu_list_head);
+	INIT_LIST_HEAD(&rproc_srm_dev->irq_list_head);
+
+	/* Get clocks, regu and irqs */
+	ret = rproc_srm_dev_clocks_get(rproc_srm_dev);
+	if (ret)
+		return ret;
+
+	ret = rproc_srm_dev_regus_get(rproc_srm_dev);
+	if (ret)
+		goto err_get;
+
+	ret = rproc_srm_dev_irqs_get(rproc_srm_dev);
+	if (ret)
+		goto err_get;
+
+	rproc_srm_dev->nb.notifier_call = rproc_srm_dev_notify_cb;
+	ret = rproc_srm_core_register_notifier(rproc_srm_dev->core,
+					       &rproc_srm_dev->nb);
+	if (ret)
+		goto err_register;
+
+	dev_set_drvdata(dev, rproc_srm_dev);
+
+	return component_add(dev, &rproc_srm_dev_ops);
+
+err_register:
+	rproc_srm_core_unregister_notifier(rproc_srm_dev->core,
+					   &rproc_srm_dev->nb);
+err_get:
+	rproc_srm_dev_irqs_put(rproc_srm_dev);
+	rproc_srm_dev_regus_put(rproc_srm_dev);
+	rproc_srm_dev_clocks_put(rproc_srm_dev);
+	return ret;
+}
+
+static int rproc_srm_dev_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rproc_srm_dev *rproc_srm_dev = dev_get_drvdata(dev);
+
+	component_del(dev, &rproc_srm_dev_ops);
+
+	rproc_srm_core_unregister_notifier(rproc_srm_dev->core,
+					   &rproc_srm_dev->nb);
+
+	rproc_srm_dev_irqs_put(rproc_srm_dev);
+	rproc_srm_dev_regus_put(rproc_srm_dev);
+	rproc_srm_dev_clocks_put(rproc_srm_dev);
+
+	return 0;
+}
+
+static const struct of_device_id rproc_srm_dev_match[] = {
+	{ .compatible = "rproc-srm-dev", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rproc_srm_dev_match);
+
+static struct platform_driver rproc_srm_dev_driver = {
+	.probe = rproc_srm_dev_probe,
+	.remove = rproc_srm_dev_remove,
+	.driver = {
+		.name = "rproc-srm-dev",
+		.of_match_table = of_match_ptr(rproc_srm_dev_match),
+	},
+};
+
+module_platform_driver(rproc_srm_dev_driver);
+
+MODULE_AUTHOR("Fabien Dessenne <fabien.dessenne@st.com>");
+MODULE_DESCRIPTION("Remoteproc System Resource Manager driver - dev");
+MODULE_LICENSE("GPL");
diff --git a/drivers/remoteproc/stm32_rproc.c b/drivers/remoteproc/stm32_rproc.c
index 8746cbb1f..6c040f9a2 100644
--- a/drivers/remoteproc/stm32_rproc.c
+++ b/drivers/remoteproc/stm32_rproc.c
@@ -12,6 +12,7 @@
 #include <linux/mailbox_client.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/of_reserved_mem.h>
@@ -20,9 +21,10 @@
 #include <linux/remoteproc.h>
 #include <linux/reset.h>
 #include <linux/slab.h>
-#include <linux/workqueue.h>
+#include <linux/tee_remoteproc.h>
 
 #include "remoteproc_internal.h"
+#include "remoteproc_elf_helpers.h"
 
 #define HOLD_BOOT		0
 #define RELEASE_BOOT		1
@@ -34,20 +36,37 @@
 #define STM32_SMC_REG_WRITE	0x1
 
 #define STM32_MBX_VQ0		"vq0"
-#define STM32_MBX_VQ0_ID	0
 #define STM32_MBX_VQ1		"vq1"
-#define STM32_MBX_VQ1_ID	1
 #define STM32_MBX_SHUTDOWN	"shutdown"
 #define STM32_MBX_DETACH	"detach"
 
 #define RSC_TBL_SIZE		1024
 
-#define M4_STATE_OFF		0
-#define M4_STATE_INI		1
-#define M4_STATE_CRUN		2
-#define M4_STATE_CSTOP		3
-#define M4_STATE_STANDBY	4
-#define M4_STATE_CRASH		5
+#define CM_STATE_OFF		0
+#define CM_STATE_INI		1
+#define CM_STATE_CRUN		2
+#define CM_STATE_CSTOP		3
+#define CM_STATE_STANDBY	4
+#define CM_STATE_CRASH		5
+
+/* PWR_CPU2D2SR register definitions */
+#define M33_STATE_FIELD_SHIFT   2
+#define M33_STATE_FIELD_MASK    0x3
+
+#define M33_STATE_OFF		0
+#define M33_STATE_CRUN		1
+#define M33_STATE_CSLEEP	2
+#define M33_STATE_CSTOP		3
+
+/*
+ * Define a default index in future may come a global list of
+ * firmwares which list platforms and associated firmware(s)
+ */
+
+#define STM32_MP1_PROC_ID    0
+#define STM32_MP2_PROC_ID    1
+
+struct stm32_rproc;
 
 struct stm32_syscon {
 	struct regmap *map;
@@ -63,35 +82,89 @@ struct stm32_rproc_mem {
 	size_t size;
 };
 
-struct stm32_rproc_mem_ranges {
-	u32 dev_addr;
-	u32 bus_addr;
-	u32 size;
+struct stm32_rproc_data {
+	int proc_id;
+	int (*get_info)(struct rproc *rproc);
+	bool signed_fw;
 };
 
 struct stm32_mbox {
 	const unsigned char name[10];
 	struct mbox_chan *chan;
 	struct mbox_client client;
-	struct work_struct vq_work;
 	int vq_id;
 };
 
 struct stm32_rproc {
 	struct reset_control *rst;
+	struct reset_control *hold_boot_rst;
 	struct stm32_syscon hold_boot;
 	struct stm32_syscon pdds;
-	struct stm32_syscon m4_state;
+	struct stm32_syscon cm_state;
 	struct stm32_syscon rsctbl;
+	struct stm32_syscon boot_vec;
 	int wdg_irq;
 	u32 nb_rmems;
 	struct stm32_rproc_mem *rmems;
 	struct stm32_mbox mb[MBOX_NB_MBX];
-	struct workqueue_struct *workqueue;
-	bool secured_soc;
+	bool hold_boot_smc;
+	bool fw_loaded;
+	struct tee_rproc *trproc;
+	const struct stm32_rproc_data *desc;
 	void __iomem *rsc_va;
+	size_t rsc_sz;
 };
 
+static u64 stm32_rproc_get_vect_table(struct rproc *rproc, const struct firmware *fw)
+{
+	struct device *dev = rproc->dev.parent;
+	struct stm32_rproc *ddata = rproc->priv;
+	const void *shdr, *name_table_shdr;
+	const char *name_table;
+	const u8 *elf_data = (void *)fw->data;
+	const void *ehdr = elf_data;
+	size_t fw_size = fw->size;
+	int i;
+	u8 class = fw_elf_get_class(fw);
+	u32 elf_shdr_get_size = elf_size_of_shdr(class);
+	u16 shnum = elf_hdr_get_e_shnum(class, ehdr);
+	u16 shstrndx = elf_hdr_get_e_shstrndx(class, ehdr);
+
+	/*
+	 * If the platform does not support the boot address configuration set
+	 * the boot address to default value 0.
+	 */
+	if (!ddata->boot_vec.map)
+		return 0;
+
+	/* Look for the vector table  in the ELF image*/
+	/* First, get the section header according to the elf class */
+	shdr = elf_data + elf_hdr_get_e_shoff(class, ehdr);
+	/* Compute name table section header entry in shdr array */
+	name_table_shdr = shdr + (shstrndx * elf_shdr_get_size);
+	/* Finally, compute the name table section address in elf */
+	name_table = elf_data + elf_shdr_get_sh_offset(class, name_table_shdr);
+
+	for (i = 0; i < shnum; i++, shdr += elf_shdr_get_size) {
+		u64 size = elf_shdr_get_sh_size(class, shdr);
+		u64 offset = elf_shdr_get_sh_offset(class, shdr);
+		u32 name = elf_shdr_get_sh_name(class, shdr);
+
+		if (strcmp(name_table + name, ".isr_vectors"))
+			continue;
+
+		/* make sure we have the entire table */
+		if (offset + size > fw_size || offset + size < size) {
+			dev_err(dev, "vector table truncated\n");
+			return 0;
+		}
+
+		return elf_shdr_get_sh_addr(class, shdr);
+	}
+
+	return 0;
+}
+
 static int stm32_rproc_pa_to_da(struct rproc *rproc, phys_addr_t pa, u64 *da)
 {
 	unsigned int i;
@@ -118,10 +191,10 @@ static int stm32_rproc_mem_alloc(struct rproc *rproc,
 	struct device *dev = rproc->dev.parent;
 	void *va;
 
-	dev_dbg(dev, "map memory: %pa+%x\n", &mem->dma, mem->len);
+	dev_dbg(dev, "map memory: %pad+%zx\n", &mem->dma, mem->len);
 	va = ioremap_wc(mem->dma, mem->len);
 	if (IS_ERR_OR_NULL(va)) {
-		dev_err(dev, "Unable to map memory region: %pa+%x\n",
+		dev_err(dev, "Unable to map memory region: %pad+0x%zx\n",
 			&mem->dma, mem->len);
 		return -ENOMEM;
 	}
@@ -141,20 +214,40 @@ static int stm32_rproc_mem_release(struct rproc *rproc,
 	return 0;
 }
 
+static int read_dma_range(struct stm32_rproc_mem *p_mem, const u32 *cell)
+{
+	int is_64 = sizeof(phys_addr_t) / sizeof(u64);
+	int nb_cell = 0;
+
+	p_mem->dev_addr = cell[nb_cell++];
+	p_mem->bus_addr = cell[nb_cell++];
+	if (is_64) /* 32-bit*/
+		p_mem->bus_addr = ((u64)p_mem->bus_addr << 32) | cell[nb_cell++];
+	p_mem->size = cell[nb_cell++];
+
+	return nb_cell;
+}
+
 static int stm32_rproc_of_memory_translations(struct platform_device *pdev,
 					      struct stm32_rproc *ddata)
 {
 	struct device *parent, *dev = &pdev->dev;
 	struct device_node *np;
 	struct stm32_rproc_mem *p_mems;
-	struct stm32_rproc_mem_ranges *mem_range;
-	int cnt, array_size, i, ret = 0;
+	const u32 *mem_range;
+	int cnt, array_size, elt_size, i, j, ret = 0;
 
 	parent = dev->parent;
 	np = parent->of_node;
 
-	cnt = of_property_count_elems_of_size(np, "dma-ranges",
-					      sizeof(*mem_range));
+	/* A dma-ranges element is construct with:
+	 *  - the 32-bit remote processor address
+	 *  - the cpu address which depends on the cup arch (32-bit or 64-bit)
+	 *  - the 32-bit remote processor memory mapping size
+	 */
+	elt_size = sizeof(p_mems->dev_addr) + sizeof(p_mems->bus_addr) + sizeof(u32);
+
+	cnt = of_property_count_elems_of_size(np, "dma-ranges", elt_size);
 	if (cnt <= 0) {
 		dev_err(dev, "%s: dma-ranges property not defined\n", __func__);
 		return -EINVAL;
@@ -163,11 +256,11 @@ static int stm32_rproc_of_memory_translations(struct platform_device *pdev,
 	p_mems = devm_kcalloc(dev, cnt, sizeof(*p_mems), GFP_KERNEL);
 	if (!p_mems)
 		return -ENOMEM;
-	mem_range = kcalloc(cnt, sizeof(*mem_range), GFP_KERNEL);
+	mem_range = kcalloc(cnt, elt_size, GFP_KERNEL);
 	if (!mem_range)
 		return -ENOMEM;
 
-	array_size = cnt * sizeof(struct stm32_rproc_mem_ranges) / sizeof(u32);
+	array_size = cnt * elt_size / sizeof(u32);
 
 	ret = of_property_read_u32_array(np, "dma-ranges",
 					 (u32 *)mem_range, array_size);
@@ -176,10 +269,8 @@ static int stm32_rproc_of_memory_translations(struct platform_device *pdev,
 		goto free_mem;
 	}
 
-	for (i = 0; i < cnt; i++) {
-		p_mems[i].bus_addr = mem_range[i].bus_addr;
-		p_mems[i].dev_addr = mem_range[i].dev_addr;
-		p_mems[i].size     = mem_range[i].size;
+	for (i = 0, j = 0; i < cnt; i++) {
+		j += read_dma_range(&p_mems[i], &mem_range[j]);
 
 		dev_dbg(dev, "memory range[%i]: da %#x, pa %pa, size %#zx:\n",
 			i, p_mems[i].dev_addr, &p_mems[i].bus_addr,
@@ -208,6 +299,139 @@ static int stm32_rproc_mbox_idx(struct rproc *rproc, const unsigned char *name)
 	return -EINVAL;
 }
 
+static void stm32_rproc_request_shutdown(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	int err, dummy_data, idx;
+
+	/* Request shutdown of the remote processor */
+	if (rproc->state != RPROC_OFFLINE && rproc->state != RPROC_CRASHED) {
+		idx = stm32_rproc_mbox_idx(rproc, STM32_MBX_SHUTDOWN);
+		if (idx >= 0 && ddata->mb[idx].chan) {
+			/* A dummy data is sent to allow to block on transmit. */
+			err = mbox_send_message(ddata->mb[idx].chan,
+						&dummy_data);
+			if (err < 0)
+				dev_warn(&rproc->dev, "warning: remote FW shutdown without ack\n");
+		}
+	}
+}
+
+static int stm32_rproc_release(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	unsigned int err = 0;
+
+	/* To allow platform Standby power mode, set remote proc Deep Sleep. */
+	if (ddata->pdds.map) {
+		err = regmap_update_bits(ddata->pdds.map, ddata->pdds.reg,
+					 ddata->pdds.mask, 1);
+		if (err) {
+			dev_err(&rproc->dev, "failed to set pdds\n");
+			return err;
+		}
+	}
+
+	/* Update coprocessor state to OFF if available. */
+	if (ddata->desc->proc_id == STM32_MP1_PROC_ID && ddata->cm_state.map) {
+		err = regmap_update_bits(ddata->cm_state.map,
+					 ddata->cm_state.reg,
+					 ddata->cm_state.mask,
+					 CM_STATE_OFF);
+		if (err) {
+			dev_err(&rproc->dev, "failed to set copro state\n");
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static int stm32_rproc_tee_elf_sanity_check(struct rproc *rproc,
+					    const struct firmware *fw)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	unsigned int ret = 0;
+
+	if (rproc->state == RPROC_DETACHED)
+		return 0;
+
+	ret = tee_rproc_load_fw(ddata->trproc, fw);
+	if (!ret)
+		ddata->fw_loaded = true;
+
+	return ret;
+}
+
+static int stm32_rproc_tee_elf_load(struct rproc *rproc,
+				    const struct firmware *fw)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	unsigned int ret;
+
+	/*
+	 * This function can be called by remote proc for recovery
+	 * without the sanity check. In this case we need to load the firmware
+	 * else nothing done here as the firmware has been preloaded for the
+	 * sanity check to be able to parse it for the resource table
+	 */
+	if (ddata->fw_loaded)
+		return 0;
+
+	ret = tee_rproc_load_fw(ddata->trproc, fw);
+	if (ret)
+		return ret;
+	ddata->fw_loaded = true;
+
+	/* update the resource table parameters */
+	if (rproc_tee_get_rsc_table(ddata->trproc)) {
+		/* no resource table: reset the related fields */
+		rproc->cached_table = NULL;
+		rproc->table_ptr = NULL;
+		rproc->table_sz = 0;
+	}
+
+	return 0;
+}
+
+static struct resource_table *
+stm32_rproc_tee_elf_find_loaded_rsc_table(struct rproc *rproc,
+					  const struct firmware *fw)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+
+	return tee_rproc_get_loaded_rsc_table(ddata->trproc);
+}
+
+static int stm32_rproc_tee_start(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+
+	return tee_rproc_start(ddata->trproc);
+}
+
+static int stm32_rproc_tee_attach(struct rproc *rproc)
+{
+	/* Nothing to do, remote proc already started by the secured context */
+	return 0;
+}
+
+static int stm32_rproc_tee_stop(struct rproc *rproc)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+	int err;
+
+	stm32_rproc_request_shutdown(rproc);
+
+	err = tee_rproc_stop(ddata->trproc);
+	if (err)
+		return err;
+
+	ddata->fw_loaded = false;
+
+	return stm32_rproc_release(rproc);
+}
+
 static int stm32_rproc_prepare(struct rproc *rproc)
 {
 	struct device *dev = rproc->dev.parent;
@@ -270,7 +494,14 @@ static int stm32_rproc_prepare(struct rproc *rproc)
 
 static int stm32_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)
 {
-	if (rproc_elf_load_rsc_table(rproc, fw))
+	struct stm32_rproc *ddata = rproc->priv;
+	int ret;
+
+	if (ddata->trproc)
+		ret = rproc_tee_get_rsc_table(ddata->trproc);
+	else
+		ret = rproc_elf_load_rsc_table(rproc, fw);
+	if (ret)
 		dev_warn(&rproc->dev, "no resource table found for this firmware\n");
 
 	return 0;
@@ -286,30 +517,13 @@ static irqreturn_t stm32_rproc_wdg(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static void stm32_rproc_mb_vq_work(struct work_struct *work)
-{
-	struct stm32_mbox *mb = container_of(work, struct stm32_mbox, vq_work);
-	struct rproc *rproc = dev_get_drvdata(mb->client.dev);
-
-	mutex_lock(&rproc->lock);
-
-	if (rproc->state != RPROC_RUNNING)
-		goto unlock_mutex;
-
-	if (rproc_vq_interrupt(rproc, mb->vq_id) == IRQ_NONE)
-		dev_dbg(&rproc->dev, "no message found in vq%d\n", mb->vq_id);
-
-unlock_mutex:
-	mutex_unlock(&rproc->lock);
-}
-
 static void stm32_rproc_mb_callback(struct mbox_client *cl, void *data)
 {
 	struct rproc *rproc = dev_get_drvdata(cl->dev);
 	struct stm32_mbox *mb = container_of(cl, struct stm32_mbox, client);
-	struct stm32_rproc *ddata = rproc->priv;
 
-	queue_work(ddata->workqueue, &mb->vq_work);
+	if (rproc_vq_interrupt(rproc, mb->vq_id) == IRQ_NONE)
+		dev_dbg(&rproc->dev, "no message found in vq%d\n", mb->vq_id);
 }
 
 static void stm32_rproc_free_mbox(struct rproc *rproc)
@@ -327,7 +541,7 @@ static void stm32_rproc_free_mbox(struct rproc *rproc)
 static const struct stm32_mbox stm32_rproc_mbox[MBOX_NB_MBX] = {
 	{
 		.name = STM32_MBX_VQ0,
-		.vq_id = STM32_MBX_VQ0_ID,
+		.vq_id = 0,
 		.client = {
 			.rx_callback = stm32_rproc_mb_callback,
 			.tx_block = false,
@@ -335,7 +549,7 @@ static const struct stm32_mbox stm32_rproc_mbox[MBOX_NB_MBX] = {
 	},
 	{
 		.name = STM32_MBX_VQ1,
-		.vq_id = STM32_MBX_VQ1_ID,
+		.vq_id = 1,
 		.client = {
 			.rx_callback = stm32_rproc_mb_callback,
 			.tx_block = false,
@@ -391,10 +605,6 @@ static int stm32_rproc_request_mbox(struct rproc *rproc)
 			dev_warn(dev, "cannot get %s mbox\n", name);
 			ddata->mb[i].chan = NULL;
 		}
-		if (ddata->mb[i].vq_id >= 0) {
-			INIT_WORK(&ddata->mb[i].vq_work,
-				  stm32_rproc_mb_vq_work);
-		}
 	}
 
 	return 0;
@@ -413,13 +623,28 @@ static int stm32_rproc_set_hold_boot(struct rproc *rproc, bool hold)
 	struct arm_smccc_res smc_res;
 	int val, err;
 
+	/*
+	 * Three ways to manage the hold boot
+	 * - using SCMI: the hold boot is managed as a reset,
+	 * - using Linux(no SCMI): the hold boot is managed as a syscon register
+	 * - using SMC call (deprecated): use SMC reset interface
+	 */
+
 	val = hold ? HOLD_BOOT : RELEASE_BOOT;
 
-	if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC) && ddata->secured_soc) {
+	if (ddata->hold_boot_rst) {
+		/* Use the SCMI reset controller */
+		if (!hold)
+			err = reset_control_deassert(ddata->hold_boot_rst);
+		else
+			err =  reset_control_assert(ddata->hold_boot_rst);
+	} else if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC) && ddata->hold_boot_smc) {
+		/* Use the SMC call */
 		arm_smccc_smc(STM32_SMC_RCC, STM32_SMC_REG_WRITE,
 			      hold_boot.reg, val, 0, 0, 0, 0, &smc_res);
 		err = smc_res.a0;
 	} else {
+		/* Use syscon */
 		err = regmap_update_bits(hold_boot.map, hold_boot.reg,
 					 hold_boot.mask, val);
 	}
@@ -469,6 +694,22 @@ static int stm32_rproc_start(struct rproc *rproc)
 		}
 	}
 
+	/* Configure the boot vector register with the vector table address read in the ELF. */
+	if (ddata->boot_vec.map) {
+		if (rproc->bootaddr & ~ddata->boot_vec.mask) {
+			dev_err(&rproc->dev, "Boot address is %#llx no aligned on mask %#x\n",
+				rproc->bootaddr, ddata->boot_vec.mask);
+			return err;
+		}
+		dev_dbg(&rproc->dev, "boot vector address = %#llx", rproc->bootaddr);
+		err = regmap_update_bits(ddata->boot_vec.map, ddata->boot_vec.reg,
+					 ddata->boot_vec.mask, rproc->bootaddr);
+		if (err) {
+			dev_err(&rproc->dev, "failed to set boot_vec\n");
+			return err;
+		}
+	}
+
 	err = stm32_rproc_set_hold_boot(rproc, false);
 	if (err)
 		return err;
@@ -503,17 +744,9 @@ static int stm32_rproc_detach(struct rproc *rproc)
 static int stm32_rproc_stop(struct rproc *rproc)
 {
 	struct stm32_rproc *ddata = rproc->priv;
-	int err, idx;
+	int err;
 
-	/* request shutdown of the remote processor */
-	if (rproc->state != RPROC_OFFLINE && rproc->state != RPROC_CRASHED) {
-		idx = stm32_rproc_mbox_idx(rproc, STM32_MBX_SHUTDOWN);
-		if (idx >= 0 && ddata->mb[idx].chan) {
-			err = mbox_send_message(ddata->mb[idx].chan, "detach");
-			if (err < 0)
-				dev_warn(&rproc->dev, "warning: remote FW shutdown without ack\n");
-		}
-	}
+	stm32_rproc_request_shutdown(rproc);
 
 	err = stm32_rproc_set_hold_boot(rproc, true);
 	if (err)
@@ -525,29 +758,8 @@ static int stm32_rproc_stop(struct rproc *rproc)
 		return err;
 	}
 
-	/* to allow platform Standby power mode, set remote proc Deep Sleep */
-	if (ddata->pdds.map) {
-		err = regmap_update_bits(ddata->pdds.map, ddata->pdds.reg,
-					 ddata->pdds.mask, 1);
-		if (err) {
-			dev_err(&rproc->dev, "failed to set pdds\n");
-			return err;
-		}
-	}
-
-	/* update coprocessor state to OFF if available */
-	if (ddata->m4_state.map) {
-		err = regmap_update_bits(ddata->m4_state.map,
-					 ddata->m4_state.reg,
-					 ddata->m4_state.mask,
-					 M4_STATE_OFF);
-		if (err) {
-			dev_err(&rproc->dev, "failed to set copro state\n");
-			return err;
-		}
-	}
 
-	return 0;
+	return stm32_rproc_release(rproc);
 }
 
 static void stm32_rproc_kick(struct rproc *rproc, int vqid)
@@ -572,95 +784,187 @@ static void stm32_rproc_kick(struct rproc *rproc, int vqid)
 	}
 }
 
-static int stm32_rproc_da_to_pa(struct rproc *rproc,
-				u64 da, phys_addr_t *pa)
+static struct resource_table *
+stm32_rproc_get_loaded_rsc_table(struct rproc *rproc, size_t *table_sz)
+{
+	struct stm32_rproc *ddata = rproc->priv;
+
+	*table_sz = ddata->rsc_sz;
+	return (struct resource_table *)ddata->rsc_va;
+}
+
+static const struct rproc_ops st_rproc_ops = {
+	.prepare	= stm32_rproc_prepare,
+	.start		= stm32_rproc_start,
+	.stop		= stm32_rproc_stop,
+	.attach		= stm32_rproc_attach,
+	.detach		= stm32_rproc_detach,
+	.kick		= stm32_rproc_kick,
+	.load		= rproc_elf_load_segments,
+	.parse_fw	= stm32_rproc_parse_fw,
+	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
+	.get_loaded_rsc_table = stm32_rproc_get_loaded_rsc_table,
+	.sanity_check	= rproc_elf_sanity_check,
+	.get_boot_addr = stm32_rproc_get_vect_table,
+};
+
+static const struct rproc_ops st_rproc_tee_ops = {
+	.prepare	= stm32_rproc_prepare,
+	.start		= stm32_rproc_tee_start,
+	.stop		= stm32_rproc_tee_stop,
+	.attach		= stm32_rproc_tee_attach,
+	.kick		= stm32_rproc_kick,
+	.parse_fw	= stm32_rproc_parse_fw,
+	.find_loaded_rsc_table = stm32_rproc_tee_elf_find_loaded_rsc_table,
+	.get_loaded_rsc_table = stm32_rproc_get_loaded_rsc_table,
+	.sanity_check	= stm32_rproc_tee_elf_sanity_check,
+	.load		= stm32_rproc_tee_elf_load,
+};
+
+static int stm32_rproc_get_m4_info(struct rproc *rproc)
 {
 	struct stm32_rproc *ddata = rproc->priv;
 	struct device *dev = rproc->dev.parent;
-	struct stm32_rproc_mem *p_mem;
-	unsigned int i;
+	u32 rsc_pa;
+	unsigned int state;
+	int ret;
 
-	for (i = 0; i < ddata->nb_rmems; i++) {
-		p_mem = &ddata->rmems[i];
+	rproc->state = CM_STATE_OFF;
+	ddata->rsc_va = NULL;
+	ddata->rsc_sz = 0;
 
-		if (da < p_mem->dev_addr ||
-		    da >= p_mem->dev_addr + p_mem->size)
-			continue;
+	/* check the Cortex-M state */
+	if (!ddata->cm_state.map)
+		 /* We couldn't get the coprocessor's state, assume it is not running */
+		return 0;
+
+	ret = regmap_read(ddata->cm_state.map, ddata->cm_state.reg, &state);
+	if (ret)
+		return ret;
+
+	if (state == CM_STATE_OFF)
+		return 0;
+
+	rproc->state = RPROC_DETACHED;
 
-		*pa = da - p_mem->dev_addr + p_mem->bus_addr;
-		dev_dbg(dev, "da %llx to pa %pap\n", da, pa);
+	/* Get the resource table information */
+	ret = regmap_read(ddata->rsctbl.map, ddata->rsctbl.reg, &rsc_pa);
+	if (ret) {
+		dev_err(dev, "failed to read rsc tbl addr\n");
+		return -EINVAL;
+	}
 
+	if (!rsc_pa)
+		/* no rsc table */
 		return 0;
+
+	ddata->rsc_va = devm_ioremap_wc(dev, rsc_pa, RSC_TBL_SIZE);
+	if (IS_ERR_OR_NULL(ddata->rsc_va)) {
+		dev_err(dev, "Unable to map memory region: %pa+%x\n", &rsc_pa, RSC_TBL_SIZE);
+		return -ENOMEM;
 	}
 
-	dev_err(dev, "can't translate da %llx\n", da);
+	/*
+	 * Assuming the resource table fits in 1kB is fair.
+	 * Notice for the detach, that this 1 kB memory area has to be reserved in the coprocessor
+	 * firmware for the resource table. On detach, the remoteproc core re-initializes this
+	 * entire area by overwriting it with the initial values stored in rproc->clean_table.
+	 */
+	ddata->rsc_sz = RSC_TBL_SIZE;
 
-	return -EINVAL;
+	return 0;
 }
 
-static struct resource_table *
-stm32_rproc_get_loaded_rsc_table(struct rproc *rproc, size_t *table_sz)
+static int stm32_rproc_get_m33_info(struct rproc *rproc)
 {
 	struct stm32_rproc *ddata = rproc->priv;
 	struct device *dev = rproc->dev.parent;
-	phys_addr_t rsc_pa;
-	u32 rsc_da;
-	int err;
+	unsigned int cm_state;
+	u32 rsc_pa;
+	u32 size;
+	int ret;
 
-	/* The resource table has already been mapped, nothing to do */
-	if (ddata->rsc_va)
-		goto done;
+	rproc->state = CM_STATE_OFF;
+	ddata->rsc_va = NULL;
+	ddata->rsc_sz = 0;
 
-	err = regmap_read(ddata->rsctbl.map, ddata->rsctbl.reg, &rsc_da);
-	if (err) {
+	if (!ddata->cm_state.map) {
+		/* We couldn't get the coprocessor's state, assume it is not running */
+		return 0;
+	}
+
+	ret = regmap_read(ddata->cm_state.map, ddata->cm_state.reg, &cm_state);
+	if (ret)
+		return ret;
+
+	switch ((cm_state >> M33_STATE_FIELD_SHIFT) & M33_STATE_FIELD_MASK) {
+	case M33_STATE_OFF:
+		break;
+	case M33_STATE_CRUN:
+	case M33_STATE_CSLEEP:
+	case M33_STATE_CSTOP:
+		rproc->state = RPROC_DETACHED;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Get the resource table information */
+	ret = nvmem_cell_read_u32(dev, "rsc-tbl-addr", &rsc_pa);
+	if (ret) {
 		dev_err(dev, "failed to read rsc tbl addr\n");
-		return ERR_PTR(-EINVAL);
+		return -EINVAL;
 	}
 
-	if (!rsc_da)
+	if (!rsc_pa)
 		/* no rsc table */
-		return ERR_PTR(-ENOENT);
-
-	err = stm32_rproc_da_to_pa(rproc, rsc_da, &rsc_pa);
-	if (err)
-		return ERR_PTR(err);
+		return 0;
 
 	ddata->rsc_va = devm_ioremap_wc(dev, rsc_pa, RSC_TBL_SIZE);
 	if (IS_ERR_OR_NULL(ddata->rsc_va)) {
-		dev_err(dev, "Unable to map memory region: %pa+%zx\n",
-			&rsc_pa, RSC_TBL_SIZE);
-		ddata->rsc_va = NULL;
-		return ERR_PTR(-ENOMEM);
+		dev_err(dev, "Unable to map memory region: %pa+%x\n", &rsc_pa, RSC_TBL_SIZE);
+		return -ENOMEM;
 	}
 
-done:
-	/*
-	 * Assuming the resource table fits in 1kB is fair.
-	 * Notice for the detach, that this 1 kB memory area has to be reserved in the coprocessor
-	 * firmware for the resource table. On detach, the remoteproc core re-initializes this
-	 * entire area by overwriting it with the initial values stored in rproc->clean_table.
-	 */
-	*table_sz = RSC_TBL_SIZE;
-	return (struct resource_table *)ddata->rsc_va;
+	ret = nvmem_cell_read_u32(dev, "rsc-tbl-size", &size);
+	if (ret) {
+		dev_err(dev, "failed to read rsc tbl size\n");
+		return -EINVAL;
+	}
+	ddata->rsc_sz = size;
+
+	return 0;
 }
 
-static const struct rproc_ops st_rproc_ops = {
-	.prepare	= stm32_rproc_prepare,
-	.start		= stm32_rproc_start,
-	.stop		= stm32_rproc_stop,
-	.attach		= stm32_rproc_attach,
-	.detach		= stm32_rproc_detach,
-	.kick		= stm32_rproc_kick,
-	.load		= rproc_elf_load_segments,
-	.parse_fw	= stm32_rproc_parse_fw,
-	.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,
-	.get_loaded_rsc_table = stm32_rproc_get_loaded_rsc_table,
-	.sanity_check	= rproc_elf_sanity_check,
-	.get_boot_addr	= rproc_elf_get_boot_addr,
+static const struct stm32_rproc_data stm32_rproc_stm32pm15 = {
+	.proc_id = STM32_MP1_PROC_ID,
+	.get_info = stm32_rproc_get_m4_info,
+	.signed_fw = false,
+};
+
+static const struct stm32_rproc_data stm32_rproc_stm32pm15_tee = {
+	.proc_id = STM32_MP1_PROC_ID,
+	.get_info = stm32_rproc_get_m4_info,
+	.signed_fw = true,
+};
+
+static const struct stm32_rproc_data stm32_rproc_stm32pm25 = {
+	.proc_id = STM32_MP2_PROC_ID,
+	.get_info = stm32_rproc_get_m33_info,
+	.signed_fw = false,
+};
+
+static const struct stm32_rproc_data stm32_rproc_stm32pm25_tee = {
+	.proc_id = STM32_MP2_PROC_ID,
+	.get_info = stm32_rproc_get_m33_info,
+	.signed_fw = true,
 };
 
 static const struct of_device_id stm32_rproc_match[] = {
-	{ .compatible = "st,stm32mp1-m4" },
+	{.compatible = "st,stm32mp1-m4", .data = &stm32_rproc_stm32pm15},
+	{.compatible = "st,stm32mp1-m4-tee", .data = &stm32_rproc_stm32pm15_tee},
+	{.compatible = "st,stm32mp2-m33", .data = &stm32_rproc_stm32pm25},
+	{.compatible = "st,stm32mp2-m33-tee", .data = &stm32_rproc_stm32pm25_tee},
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_rproc_match);
@@ -717,39 +1021,57 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 		dev_info(dev, "wdg irq registered\n");
 	}
 
-	ddata->rst = devm_reset_control_get_by_index(dev, 0);
+	ddata->rst = devm_reset_control_get_optional(dev, "mcu_rst");
+	if (!ddata->rst) {
+		/* Try legacy fallback method: get it by index */
+		ddata->rst = devm_reset_control_get_by_index(dev, 0);
+	}
 	if (IS_ERR(ddata->rst))
 		return dev_err_probe(dev, PTR_ERR(ddata->rst),
 				     "failed to get mcu_reset\n");
 
 	/*
-	 * if platform is secured the hold boot bit must be written by
-	 * smc call and read normally.
-	 * if not secure the hold boot bit could be read/write normally
+	 * Three ways to manage the hold boot
+	 * - using SCMI: the hold boot is managed as a reset
+	 *    The DT "reset-mames" property should be defined with 2 items:
+	 *        reset-names = "mcu_rst", "hold_boot";
+	 * - using SMC call (deprecated): use SMC reset interface
+	 *    The DT "reset-mames" property is optional, "st,syscfg-tz" is required
+	 * - default(no SCMI, no SMC): the hold boot is managed as a syscon register
+	 *    The DT "reset-mames" property is optional, "st,syscfg-holdboot" is required
 	 */
-	err = stm32_rproc_get_syscon(np, "st,syscfg-tz", &tz);
-	if (err) {
-		dev_err(dev, "failed to get tz syscfg\n");
-		return err;
-	}
 
-	err = regmap_read(tz.map, tz.reg, &tzen);
-	if (err) {
-		dev_err(dev, "failed to read tzen\n");
-		return err;
+	ddata->hold_boot_rst = devm_reset_control_get_optional(dev, "hold_boot");
+	if (IS_ERR(ddata->hold_boot_rst))
+		return dev_err_probe(dev, PTR_ERR(ddata->hold_boot_rst),
+				     "failed to get hold_boot reset\n");
+
+	if (!ddata->hold_boot_rst && IS_ENABLED(CONFIG_HAVE_ARM_SMCCC)) {
+		/* Manage the MCU_BOOT using SMC call */
+		err = stm32_rproc_get_syscon(np, "st,syscfg-tz", &tz);
+		if (!err) {
+			err = regmap_read(tz.map, tz.reg, &tzen);
+			if (err) {
+				dev_err(dev, "failed to read tzen\n");
+				return err;
+			}
+			ddata->hold_boot_smc = tzen & tz.mask;
+		}
 	}
-	ddata->secured_soc = tzen & tz.mask;
 
-	err = stm32_rproc_get_syscon(np, "st,syscfg-holdboot",
-				     &ddata->hold_boot);
-	if (err) {
-		dev_err(dev, "failed to get hold boot\n");
-		return err;
+	if (!ddata->hold_boot_rst && !ddata->hold_boot_smc) {
+		/* Default: hold boot manage it through the syscon controller */
+		err = stm32_rproc_get_syscon(np, "st,syscfg-holdboot",
+					     &ddata->hold_boot);
+		if (err) {
+			dev_err(dev, "failed to get hold boot\n");
+			return err;
+		}
 	}
 
 	err = stm32_rproc_get_syscon(np, "st,syscfg-pdds", &ddata->pdds);
 	if (err)
-		dev_info(dev, "failed to get pdds\n");
+		dev_info(dev, "pdds sys config not defined\n");
 
 	*auto_boot = of_property_read_bool(np, "st,auto-boot");
 
@@ -757,11 +1079,11 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 	 * See if we can check the M4 status, i.e if it was started
 	 * from the boot loader or not.
 	 */
-	err = stm32_rproc_get_syscon(np, "st,syscfg-m4-state",
-				     &ddata->m4_state);
+	err = stm32_rproc_get_syscon(np, "st,syscfg-cm-state",
+				     &ddata->cm_state);
 	if (err) {
 		/* remember this */
-		ddata->m4_state.map = NULL;
+		ddata->cm_state.map = NULL;
 		/* no coprocessor state syscon (optional) */
 		dev_warn(dev, "m4 state not supported\n");
 
@@ -777,23 +1099,12 @@ static int stm32_rproc_parse_dt(struct platform_device *pdev,
 		dev_warn(dev, "rsc tbl syscon not supported\n");
 	}
 
-	return 0;
-}
-
-static int stm32_rproc_get_m4_status(struct stm32_rproc *ddata,
-				     unsigned int *state)
-{
-	/* See stm32_rproc_parse_dt() */
-	if (!ddata->m4_state.map) {
-		/*
-		 * We couldn't get the coprocessor's state, assume
-		 * it is not running.
-		 */
-		*state = M4_STATE_OFF;
-		return 0;
-	}
+	/* See if we can get the optional non secure boot address register */
+	err = stm32_rproc_get_syscon(np, "st,syscfg-nsvtor", &ddata->boot_vec);
+	if (err)
+		dev_dbg(dev, "nsvector sys config not defined\n");
 
-	return regmap_read(ddata->m4_state.map, ddata->m4_state.reg, state);
+	return 0;
 }
 
 static int stm32_rproc_probe(struct platform_device *pdev)
@@ -801,50 +1112,75 @@ static int stm32_rproc_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct stm32_rproc *ddata;
 	struct device_node *np = dev->of_node;
+	const struct stm32_rproc_data *desc;
+	struct tee_rproc *trproc = NULL;
 	struct rproc *rproc;
-	unsigned int state;
 	int ret;
 
+	desc = device_get_match_data(&pdev->dev);
+
 	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
 	if (ret)
 		return ret;
 
-	rproc = rproc_alloc(dev, np->name, &st_rproc_ops, NULL, sizeof(*ddata));
-	if (!rproc)
-		return -ENOMEM;
+	if (desc->signed_fw) {
+		trproc = tee_rproc_register(dev, desc->proc_id);
+		if (IS_ERR_OR_NULL(trproc)) {
+			return PTR_ERR(trproc);
+		/*
+		 * Delegate the firmware management to the secure context.
+		 * The firmware loaded has to be signed.
+		 */
+		dev_info(dev, "Support of signed firmware only\n");
+		}
+	}
 
-	ddata = rproc->priv;
+	rproc = rproc_alloc(dev, np->name,
+			    trproc ? &st_rproc_tee_ops : &st_rproc_ops,
+			    NULL, sizeof(*ddata));
+	if (!rproc) {
+		ret = -ENOMEM;
+		goto free_tee;
+	}
 
-	rproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);
+	ddata = rproc->priv;
+	ddata->desc = desc;
+	ddata->trproc = trproc;
 
 	ret = stm32_rproc_parse_dt(pdev, ddata, &rproc->auto_boot);
 	if (ret)
 		goto free_rproc;
 
+	if (trproc) {
+		/*
+		 * Delegate the firmware management to the secure context. The
+		 * firmware loaded has to be signed.
+		 */
+		dev_info(dev, "Support of signed firmware only\n");
+		rproc->fw_format = RPROC_FW_TEE;
+		trproc->rproc = rproc;
+	} else {
+		rproc->fw_format = RPROC_FW_ELF;
+	}
+
+	rproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);
+
 	ret = stm32_rproc_of_memory_translations(pdev, ddata);
 	if (ret)
 		goto free_rproc;
 
-	ret = stm32_rproc_get_m4_status(ddata, &state);
+	ret = ddata->desc->get_info(rproc);
 	if (ret)
 		goto free_rproc;
 
-	if (state == M4_STATE_CRUN)
-		rproc->state = RPROC_DETACHED;
 
 	rproc->has_iommu = false;
-	ddata->workqueue = create_workqueue(dev_name(dev));
-	if (!ddata->workqueue) {
-		dev_err(dev, "cannot create workqueue\n");
-		ret = -ENOMEM;
-		goto free_resources;
-	}
 
 	platform_set_drvdata(pdev, rproc);
 
 	ret = stm32_rproc_request_mbox(rproc);
 	if (ret)
-		goto free_wkq;
+		goto free_resources;
 
 	ret = rproc_add(rproc);
 	if (ret)
@@ -854,8 +1190,6 @@ static int stm32_rproc_probe(struct platform_device *pdev)
 
 free_mb:
 	stm32_rproc_free_mbox(rproc);
-free_wkq:
-	destroy_workqueue(ddata->workqueue);
 free_resources:
 	rproc_resource_cleanup(rproc);
 free_rproc:
@@ -864,6 +1198,10 @@ static int stm32_rproc_probe(struct platform_device *pdev)
 		device_init_wakeup(dev, false);
 	}
 	rproc_free(rproc);
+free_tee:
+	if (trproc)
+		tee_rproc_unregister(trproc);
+
 	return ret;
 }
 
@@ -878,18 +1216,28 @@ static int stm32_rproc_remove(struct platform_device *pdev)
 
 	rproc_del(rproc);
 	stm32_rproc_free_mbox(rproc);
-	destroy_workqueue(ddata->workqueue);
 
 	if (device_may_wakeup(dev)) {
 		dev_pm_clear_wake_irq(dev);
 		device_init_wakeup(dev, false);
 	}
 	rproc_free(rproc);
+	if (ddata->trproc)
+		tee_rproc_unregister(ddata->trproc);
 
 	return 0;
 }
 
-static int __maybe_unused stm32_rproc_suspend(struct device *dev)
+static void stm32_rproc_shutdown(struct platform_device *pdev)
+{
+	struct rproc *rproc = platform_get_drvdata(pdev);
+
+	if (atomic_read(&rproc->power) > 0)
+		dev_warn(&pdev->dev,
+			 "Warning: remote fw is still running with possible side effect!!!\n");
+}
+
+static int stm32_rproc_suspend(struct device *dev)
 {
 	struct rproc *rproc = dev_get_drvdata(dev);
 	struct stm32_rproc *ddata = rproc->priv;
@@ -900,7 +1248,7 @@ static int __maybe_unused stm32_rproc_suspend(struct device *dev)
 	return 0;
 }
 
-static int __maybe_unused stm32_rproc_resume(struct device *dev)
+static int stm32_rproc_resume(struct device *dev)
 {
 	struct rproc *rproc = dev_get_drvdata(dev);
 	struct stm32_rproc *ddata = rproc->priv;
@@ -911,16 +1259,17 @@ static int __maybe_unused stm32_rproc_resume(struct device *dev)
 	return 0;
 }
 
-static SIMPLE_DEV_PM_OPS(stm32_rproc_pm_ops,
-			 stm32_rproc_suspend, stm32_rproc_resume);
+static DEFINE_SIMPLE_DEV_PM_OPS(stm32_rproc_pm_ops,
+				stm32_rproc_suspend, stm32_rproc_resume);
 
 static struct platform_driver stm32_rproc_driver = {
 	.probe = stm32_rproc_probe,
 	.remove = stm32_rproc_remove,
+	.shutdown = stm32_rproc_shutdown,
 	.driver = {
 		.name = "stm32-rproc",
-		.pm = &stm32_rproc_pm_ops,
-		.of_match_table = of_match_ptr(stm32_rproc_match),
+		.pm = pm_ptr(&stm32_rproc_pm_ops),
+		.of_match_table = stm32_rproc_match,
 	},
 };
 module_platform_driver(stm32_rproc_driver);
diff --git a/drivers/remoteproc/tee_remoteproc.c b/drivers/remoteproc/tee_remoteproc.c
new file mode 100644
index 000000000..1aeb0df0a
--- /dev/null
+++ b/drivers/remoteproc/tee_remoteproc.c
@@ -0,0 +1,403 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
+ */
+
+#include <linux/firmware.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/remoteproc.h>
+#include <linux/slab.h>
+#include <linux/tee_drv.h>
+#include <linux/tee_remoteproc.h>
+
+#include "remoteproc_internal.h"
+
+#define MAX_TEE_PARAM_ARRY_MEMBER	4
+
+/*
+ * Authentication of the firmware and load in the remote processor memory
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [in]	 params[1].memref:	buffer containing the image of the buffer
+ */
+#define TA_RPROC_FW_CMD_LOAD_FW		1
+
+/*
+ * start the remote processor
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_START_FW	2
+
+/*
+ * stop the remote processor
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_STOP_FW		3
+
+/*
+ * return the address of the resource table, or 0 if not found
+ * No check is done to verify that the address returned is accessible by
+ * the non secure context. If the resource table is loaded in a protected
+ * memory the access by the non secure context will lead to a data abort.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out]  params[1].value.a:	32bit LSB resource table memory address
+ * [out]  params[1].value.b:	32bit MSB resource table memory address
+ * [out]  params[2].value.a:	32bit LSB resource table memory size
+ * [out]  params[2].value.b:	32bit MSB resource table memory size
+ */
+#define TA_RPROC_FW_CMD_GET_RSC_TABLE	4
+
+/*
+ * return the address of the core dump
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out] params[1].memref:	address of the core dump image if exist,
+ *				else return Null
+ */
+#define TA_RPROC_FW_CMD_GET_COREDUMP	5
+
+struct tee_rproc_mem {
+	char name[20];
+	void __iomem *cpu_addr;
+	phys_addr_t bus_addr;
+	u32 dev_addr;
+	size_t size;
+};
+
+struct tee_rproc_context {
+	struct list_head sessions;
+	struct tee_context *tee_ctx;
+	struct device *dev;
+};
+
+struct tee_rproc_context *tee_rproc_ctx;
+
+static void prepare_args(struct tee_rproc *trproc, int cmd, struct tee_ioctl_invoke_arg *arg,
+			 struct tee_param *param, unsigned int num_params)
+{
+	memset(arg, 0, sizeof(*arg));
+	memset(param, 0, MAX_TEE_PARAM_ARRY_MEMBER * sizeof(*param));
+
+	arg->func = cmd;
+	arg->session = trproc->session_id;
+	arg->num_params = num_params + 1;
+
+	param[0] = (struct tee_param) {
+		.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+		.u.value.a = trproc->rproc_id,
+	};
+}
+
+int tee_rproc_load_fw(struct tee_rproc *trproc, const struct firmware *fw)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	struct tee_shm *fw_shm;
+	int ret;
+
+	fw_shm = tee_shm_register_kernel_buf(tee_rproc_ctx->tee_ctx, (void *)fw->data, fw->size);
+	if (IS_ERR(fw_shm)) {
+		dev_err(tee_rproc_ctx->dev, "Failed to register kernel buffer in tee: %ld\n",
+			PTR_ERR(fw_shm));
+		return PTR_ERR(fw_shm);
+	}
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_LOAD_FW, &arg, param, 1);
+
+	/* provide the address of the firmware image */
+	param[1] = (struct tee_param) {
+		.attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT,
+		.u.memref = {
+			.shm = fw_shm,
+			.size = fw->size,
+			.shm_offs = 0,
+		},
+	};
+
+	ret = tee_client_invoke_func(tee_rproc_ctx->tee_ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(tee_rproc_ctx->dev,
+			"TA_RPROC_FW_CMD_LOAD_FW invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+
+	tee_shm_free(fw_shm);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tee_rproc_load_fw);
+
+int rproc_tee_get_rsc_table(struct tee_rproc *trproc)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	struct rproc *rproc = trproc->rproc;
+	size_t rsc_size;
+	int ret;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_GET_RSC_TABLE, &arg, param, 2);
+
+	param[1].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+	param[2].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+
+	ret = tee_client_invoke_func(tee_rproc_ctx->tee_ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(tee_rproc_ctx->dev,
+			"TA_RPROC_FW_CMD_GET_RSC_TABLE invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		return -EIO;
+	}
+
+	rsc_size = param[2].u.value.a;
+
+	/* If the size is null no resource table defined in the image */
+	if (!rsc_size)
+		return 0;
+
+	/*
+	 * Store the resource table address that would be updated by the remote
+	 * core and the virtio.
+	 */
+	trproc->rsc_va = ioremap_wc(param[1].u.value.a, rsc_size);
+	if (IS_ERR_OR_NULL(trproc->rsc_va)) {
+		dev_err(tee_rproc_ctx->dev, "Unable to map memory region: %lld+%zx\n",
+			param[1].u.value.a, rsc_size);
+		trproc->rsc_va = NULL;
+		return -ENOMEM;
+	}
+
+	/*
+	 * A cached table is requested as the physical address is not mapped yet
+	 * but remoteproc need to parse the table for resources.
+	 */
+	rproc->cached_table = kmemdup(trproc->rsc_va, rsc_size, GFP_KERNEL);
+	if (!rproc->cached_table)
+		return -ENOMEM;
+
+	rproc->table_ptr = rproc->cached_table;
+	rproc->table_sz = rsc_size;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rproc_tee_get_rsc_table);
+
+struct resource_table *tee_rproc_get_loaded_rsc_table(struct tee_rproc *trproc)
+{
+	return (struct resource_table *)trproc->rsc_va;
+}
+EXPORT_SYMBOL_GPL(tee_rproc_get_loaded_rsc_table);
+
+int tee_rproc_start(struct tee_rproc *trproc)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	int ret;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_START_FW, &arg, param, 0);
+
+	ret = tee_client_invoke_func(tee_rproc_ctx->tee_ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(tee_rproc_ctx->dev,
+			"TA_RPROC_FW_CMD_START_FW invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tee_rproc_start);
+
+int tee_rproc_stop(struct tee_rproc *trproc)
+{
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	int ret;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_STOP_FW, &arg, param, 0);
+
+	ret = tee_client_invoke_func(tee_rproc_ctx->tee_ctx, &arg, param);
+	if (ret < 0 || arg.ret != 0) {
+		dev_err(tee_rproc_ctx->dev,
+			"TA_RPROC_FW_CMD_STOP_FW invoke failed TEE err: %x, ret:%x\n",
+			arg.ret, ret);
+		if (!ret)
+			ret = -EIO;
+	}
+	if (trproc->rsc_va)
+		iounmap(trproc->rsc_va);
+	trproc->rsc_va = NULL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tee_rproc_stop);
+
+static const struct tee_client_device_id stm32_tee_rproc_id_table[] = {
+	{UUID_INIT(0x80a4c275, 0x0a47, 0x4905,
+		   0x82, 0x85, 0x14, 0x86, 0xa9, 0x77, 0x1a, 0x08)},
+	{}
+};
+
+struct tee_rproc *tee_rproc_register(struct device *dev, unsigned int rproc_id)
+{
+	struct tee_client_device *rproc_tee_device;
+	struct tee_ioctl_open_session_arg sess_arg;
+	struct tee_param param[MAX_TEE_PARAM_ARRY_MEMBER];
+	struct tee_rproc *trproc;
+	int ret;
+
+	/*
+	 * The device is not probed by the TEE bus. We ignore the reason (bus could be not yet
+	 * probed or service not available in the secure firmware)
+	 * Assumption here is that the TEE bus is not probed.
+	 */
+	if (!tee_rproc_ctx)
+		return ERR_PTR(-EPROBE_DEFER);
+
+	trproc =  devm_kzalloc(dev, sizeof(*trproc), GFP_KERNEL);
+	if (!trproc)
+		return ERR_PTR(-ENOMEM);
+
+	rproc_tee_device = to_tee_client_device(tee_rproc_ctx->dev);
+	memset(&sess_arg, 0, sizeof(sess_arg));
+
+	/* Open session with rproc_tee load Trusted App */
+	memcpy(sess_arg.uuid, rproc_tee_device->id.uuid.b, TEE_IOCTL_UUID_LEN);
+
+	/*
+	 * TODO: should we replace TEE_IOCTL_LOGIN_PUBLIC by
+	 * TEE_IOCTL_LOGIN_REE_KERNEL?
+	 */
+	sess_arg.clnt_login = TEE_IOCTL_LOGIN_REE_KERNEL;
+	sess_arg.num_params = 1;
+
+	param[0] = (struct tee_param) {
+		.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT,
+		.u.value.a = rproc_id,
+	};
+
+	ret = tee_client_open_session(tee_rproc_ctx->tee_ctx, &sess_arg, param);
+	if (ret < 0 || sess_arg.ret != 0) {
+		dev_err(dev, "tee_client_open_session failed, err: %x\n", sess_arg.ret);
+		return ERR_PTR(-EINVAL);
+	}
+
+	trproc->parent =  dev;
+	trproc->rproc_id = rproc_id;
+	trproc->session_id = sess_arg.session;
+
+	list_add_tail(&trproc->node, &tee_rproc_ctx->sessions);
+
+	return trproc;
+}
+EXPORT_SYMBOL_GPL(tee_rproc_register);
+
+int tee_rproc_unregister(struct tee_rproc *trproc)
+{
+	int ret;
+
+	if (!tee_rproc_ctx)
+		return -ENODEV;
+
+	ret = tee_client_close_session(tee_rproc_ctx->tee_ctx, trproc->session_id);
+	if (ret < 0)
+		dev_err(trproc->parent,	"tee_client_close_session failed, err: %x\n", ret);
+
+	list_del(&trproc->node);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tee_rproc_unregister);
+
+static int tee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)
+{
+	/* Today we support only the OP-TEE, could be extend to other tees */
+	return (ver->impl_id == TEE_IMPL_ID_OPTEE);
+}
+
+static int tee_rproc_probe(struct device *dev)
+{
+	struct tee_context *tee_ctx;
+	int ret;
+
+	/* Only one RPROC OP-TEE device allowed */
+	if (tee_rproc_ctx) {
+		dev_err(dev, "An RPROC OP-TEE device was already initialized: only one allowed\n");
+		return -EBUSY;
+	}
+
+	/* Open context with TEE driver */
+	tee_ctx = tee_client_open_context(NULL, tee_ctx_match, NULL, NULL);
+	if (IS_ERR(tee_ctx))
+		return PTR_ERR(tee_ctx);
+
+	tee_rproc_ctx = devm_kzalloc(dev, sizeof(*tee_rproc_ctx), GFP_KERNEL);
+	if (!tee_rproc_ctx) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	tee_rproc_ctx->dev = dev;
+	tee_rproc_ctx->tee_ctx = tee_ctx;
+	INIT_LIST_HEAD(&tee_rproc_ctx->sessions);
+
+	return 0;
+err:
+	tee_client_close_context(tee_ctx);
+
+	return ret;
+}
+
+static int tee_rproc_remove(struct device *dev)
+{
+	struct tee_rproc *entry, *tmp;
+
+	list_for_each_entry_safe(entry, tmp, &tee_rproc_ctx->sessions, node) {
+		tee_client_close_session(tee_rproc_ctx->tee_ctx, entry->session_id);
+		list_del(&entry->node);
+		kfree(entry);
+	}
+
+	tee_client_close_context(tee_rproc_ctx->tee_ctx);
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(tee, stm32_tee_rproc_id_table);
+
+static struct tee_client_driver tee_rproc_fw_driver = {
+	.id_table	= stm32_tee_rproc_id_table,
+	.driver		= {
+		.name		= KBUILD_MODNAME,
+		.bus		= &tee_bus_type,
+		.probe		= tee_rproc_probe,
+		.remove		= tee_rproc_remove,
+	},
+};
+
+static int __init tee_rproc_fw_mod_init(void)
+{
+	return driver_register(&tee_rproc_fw_driver.driver);
+}
+
+static void __exit tee_rproc_fw_mod_exit(void)
+{
+	driver_unregister(&tee_rproc_fw_driver.driver);
+}
+
+module_init(tee_rproc_fw_mod_init);
+module_exit(tee_rproc_fw_mod_exit);
+
+MODULE_DESCRIPTION("secure remote processor control driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/rpmsg/virtio_rpmsg_bus.c b/drivers/rpmsg/virtio_rpmsg_bus.c
index f1af0f674..24ab0e9dc 100644
--- a/drivers/rpmsg/virtio_rpmsg_bus.c
+++ b/drivers/rpmsg/virtio_rpmsg_bus.c
@@ -709,6 +709,7 @@ static ssize_t virtio_rpmsg_get_mtu(struct rpmsg_endpoint *ept)
 static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 			     struct rpmsg_hdr *msg, unsigned int len)
 {
+	struct rpmsg_device *rpdev;
 	struct rpmsg_endpoint *ept;
 	struct scatterlist sg;
 	bool little_endian = virtio_is_little_endian(vrp->vdev);
@@ -741,12 +742,22 @@ static int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,
 	ept = idr_find(&vrp->endpoints, __rpmsg32_to_cpu(little_endian, msg->dst));
 
 	/* let's make sure no one deallocates ept while we use it */
-	if (ept)
+	if (ept) {
 		kref_get(&ept->refcount);
+		rpdev = ept->rpdev;
+	}
 
 	mutex_unlock(&vrp->endpoints_lock);
 
 	if (ept) {
+		if (rpdev->ept == ept && rpdev->dst == RPMSG_ADDR_ANY) {
+			/*
+			 * First message received from the remote side,
+			 * update channel destination address.
+			 */
+			rpdev->dst = msg->src;
+		}
+
 		/* make sure ept->cb doesn't go away while we use it */
 		mutex_lock(&ept->cb_lock);
 
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index bb63edb50..b3a7a6317 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1896,6 +1896,7 @@ config RTC_DRV_R7301
 config RTC_DRV_STM32
 	tristate "STM32 RTC"
 	select REGMAP_MMIO
+	depends on COMMON_CLK
 	depends on ARCH_STM32 || COMPILE_TEST
 	help
 	   If you say yes here you get support for the STM32 On-Chip
diff --git a/drivers/rtc/rtc-stm32.c b/drivers/rtc/rtc-stm32.c
index ac9e228b5..fdeea65e3 100644
--- a/drivers/rtc/rtc-stm32.c
+++ b/drivers/rtc/rtc-stm32.c
@@ -5,7 +5,10 @@
  */
 
 #include <linux/bcd.h>
+#include <linux/bitfield.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/errno.h>
 #include <linux/iopoll.h>
 #include <linux/ioport.h>
 #include <linux/mfd/syscon.h>
@@ -15,6 +18,8 @@
 #include <linux/regmap.h>
 #include <linux/rtc.h>
 
+#include <dt-bindings/rtc/rtc-stm32.h>
+
 #define DRIVER_NAME "stm32_rtc"
 
 /* STM32_RTC_TR bit fields  */
@@ -39,6 +44,13 @@
 #define STM32_RTC_CR_FMT		BIT(6)
 #define STM32_RTC_CR_ALRAE		BIT(8)
 #define STM32_RTC_CR_ALRAIE		BIT(12)
+#define STM32_RTC_CR_COSEL		BIT(19)
+#define STM32_RTC_CR_OSEL		GENMASK(22, 21)
+#define STM32_RTC_CR_OSEL_ALARM_A	FIELD_PREP(STM32_RTC_CR_OSEL, 0x01)
+#define STM32_RTC_CR_COE		BIT(23)
+#define STM32_RTC_CR_TAMPOE		BIT(26)
+#define STM32_RTC_CR_TAMPALRM_TYPE	BIT(30)
+#define STM32_RTC_CR_OUT2EN		BIT(31)
 
 /* STM32_RTC_ISR/STM32_RTC_ICSR bit fields */
 #define STM32_RTC_ISR_ALRAWF		BIT(0)
@@ -75,12 +87,30 @@
 /* STM32_RTC_SR/_SCR bit fields */
 #define STM32_RTC_SR_ALRA		BIT(0)
 
+/* STM32_RTC_CFGR bit fields */
+#define STM32_RTC_CFGR_OUT2_RMP		BIT(0)
+#define STM32_RTC_CFGR_LSCOEN		GENMASK(2, 1)
+#define STM32_RTC_CFGR_LSCOEN_OUT1	1
+#define STM32_RTC_CFGR_LSCOEN_OUT2_RMP	2
+
 /* STM32_RTC_VERR bit fields */
 #define STM32_RTC_VERR_MINREV_SHIFT	0
 #define STM32_RTC_VERR_MINREV		GENMASK(3, 0)
 #define STM32_RTC_VERR_MAJREV_SHIFT	4
 #define STM32_RTC_VERR_MAJREV		GENMASK(7, 4)
 
+/* STM32_RTC_SECCFGR bit fields */
+#define STM32_RTC_SECCFGR		0x20
+#define STM32_RTC_SECCFGR_ALRA_SEC	BIT(0)
+#define STM32_RTC_SECCFGR_INIT_SEC	BIT(14)
+#define STM32_RTC_SECCFGR_SEC		BIT(15)
+
+/* STM32_RTC_RXCIDCFGR bit fields */
+#define STM32_RTC_RXCIDCFGR(x)		(0x80 + 0x4 * (x))
+#define STM32_RTC_RXCIDCFGR_CFEN	BIT(0)
+#define STM32_RTC_RXCIDCFGR_CID		GENMASK(6, 4)
+#define STM32_RTC_RXCIDCFGR_CID1	1
+
 /* STM32_RTC_WPR key constants */
 #define RTC_WPR_1ST_KEY			0xCA
 #define RTC_WPR_2ND_KEY			0x53
@@ -89,6 +119,9 @@
 /* Max STM32 RTC register offset is 0x3FC */
 #define UNDEF_REG			0xFFFF
 
+/* STM32 RTC driver time helpers */
+#define SEC_PER_DAY		(24 * 60 * 60)
+
 struct stm32_rtc;
 
 struct stm32_rtc_registers {
@@ -101,6 +134,7 @@ struct stm32_rtc_registers {
 	u16 wpr;
 	u16 sr;
 	u16 scr;
+	u16 cfgr;
 	u16 verr;
 };
 
@@ -114,7 +148,10 @@ struct stm32_rtc_data {
 	void (*clear_events)(struct stm32_rtc *rtc, unsigned int flags);
 	bool has_pclk;
 	bool need_dbp;
-	bool has_wakeirq;
+	bool need_accuracy;
+	bool has_lsco;
+	bool has_alarm_out;
+	bool rif_protected;
 };
 
 struct stm32_rtc {
@@ -127,9 +164,96 @@ struct stm32_rtc {
 	struct clk *rtc_ck;
 	const struct stm32_rtc_data *data;
 	int irq_alarm;
-	int wakeirq_alarm;
+	int lsco;
+	struct clk *clk_lsco;
+	int out_alarm;
 };
 
+struct stm32_rtc_rif_resource {
+	unsigned int num;
+	u32 bit;
+};
+
+static const struct stm32_rtc_rif_resource STM32_RTC_RES_ALRA = {0, STM32_RTC_SECCFGR_ALRA_SEC};
+static const struct stm32_rtc_rif_resource STM32_RTC_RES_INIT = {5, STM32_RTC_SECCFGR_INIT_SEC};
+
+/*
+ *  -------------------------------------------------------------------------
+ * | TAMPOE | OSEL[1:0] | COE | OUT2EN |     RTC_OUT1     |     RTC_OUT2     |
+ * |	    |           |     |        |                  | or RTC_OUT2_RMP  |
+ * |-------------------------------------------------------------------------|
+ * |    0   |     00    |  0  | 0 or 1 |         -        |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * |    0   |     00    |  1  |    0   |      CALIB       |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  0  |    0   |     TAMPALRM     |         -        |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * |    0   |     00    |  1  |    1   |         -        |      CALIB       |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  0  |    1   |         -        |     TAMPALRM     |
+ * |--------|-----------|-----|--------|------------------|------------------|
+ * | 0 or 1 |    !=00   |  1  |    1   |     TAMPALRM     |      CALIB       |
+ *  -------------------------------------------------------------------------
+ */
+static int stm32_rtc_clk_lsco_check_availability(struct stm32_rtc *rtc)
+{
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+	unsigned int calib = STM32_RTC_CR_COE;
+	unsigned int tampalrm = STM32_RTC_CR_TAMPOE | STM32_RTC_CR_OSEL;
+
+	switch (rtc->lsco) {
+	case RTC_OUT1:
+		if ((!(cr & STM32_RTC_CR_OUT2EN) &&
+		     ((cr & calib) || cr & tampalrm)) ||
+		     ((cr & calib) && (cr & tampalrm)))
+			return -EBUSY;
+		break;
+	case RTC_OUT2_RMP:
+		if ((cr & STM32_RTC_CR_OUT2EN) &&
+		    (cfgr & STM32_RTC_CFGR_OUT2_RMP) &&
+		    ((cr & calib) || (cr & tampalrm)))
+			return -EBUSY;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (clk_get_rate(rtc->rtc_ck) != 32768)
+		return -ERANGE;
+
+	return 0;
+}
+
+static int stm32_rtc_clk_lsco_register(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	u8 lscoen;
+	int ret;
+
+	ret = stm32_rtc_clk_lsco_check_availability(rtc);
+	if (ret)
+		return ret;
+
+	lscoen = (rtc->lsco == RTC_OUT1) ? STM32_RTC_CFGR_LSCOEN_OUT1 :
+					   STM32_RTC_CFGR_LSCOEN_OUT2_RMP;
+
+	rtc->clk_lsco = clk_register_gate(&pdev->dev, "rtc_lsco",
+					  __clk_get_name(rtc->rtc_ck),
+					  CLK_IGNORE_UNUSED | CLK_IS_CRITICAL,
+					  rtc->base + regs.cfgr, lscoen,
+					  0, NULL);
+	if (IS_ERR(rtc->clk_lsco))
+		return PTR_ERR(rtc->clk_lsco);
+
+	of_clk_add_provider(pdev->dev.of_node,
+			    of_clk_src_simple_get, rtc->clk_lsco);
+
+	return 0;
+}
+
 static void stm32_rtc_wpr_unlock(struct stm32_rtc *rtc)
 {
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
@@ -145,6 +269,73 @@ static void stm32_rtc_wpr_lock(struct stm32_rtc *rtc)
 	writel_relaxed(RTC_WPR_WRONG_KEY, rtc->base + regs->wpr);
 }
 
+static void stm32_rtc_clk_lsco_disable(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+
+	writel_relaxed(cfgr &= ~STM32_RTC_CFGR_LSCOEN, rtc->base + regs.cfgr);
+}
+
+static int stm32_rtc_out_alarm_config(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+
+	cr &= ~STM32_RTC_CR_OSEL;
+	cr |= STM32_RTC_CR_OSEL_ALARM_A;
+	cr &= ~STM32_RTC_CR_TAMPOE;
+	cr &= ~STM32_RTC_CR_COE;
+	cr &= ~STM32_RTC_CR_TAMPALRM_TYPE;
+
+	switch (rtc->out_alarm) {
+	case RTC_OUT1:
+		cr &= ~STM32_RTC_CR_OUT2EN;
+		cfgr &= ~STM32_RTC_CFGR_OUT2_RMP;
+		break;
+	case RTC_OUT2:
+		cr |= STM32_RTC_CR_OUT2EN;
+		cfgr &= ~STM32_RTC_CFGR_OUT2_RMP;
+		break;
+	case RTC_OUT2_RMP:
+		cr |= STM32_RTC_CR_OUT2EN;
+		cfgr |= STM32_RTC_CFGR_OUT2_RMP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	stm32_rtc_wpr_unlock(rtc);
+	writel_relaxed(cr, rtc->base + regs.cr);
+	writel_relaxed(cfgr, rtc->base + regs.cfgr);
+	stm32_rtc_wpr_lock(rtc);
+
+	return 0;
+}
+
+static void stm32_rtc_out_alarm_disable(struct platform_device *pdev)
+{
+	struct stm32_rtc *rtc = platform_get_drvdata(pdev);
+	struct stm32_rtc_registers regs = rtc->data->regs;
+	unsigned int cr = readl_relaxed(rtc->base + regs.cr);
+	unsigned int cfgr = readl_relaxed(rtc->base + regs.cfgr);
+
+	cr &= ~STM32_RTC_CR_OSEL;
+	cr &= ~STM32_RTC_CR_TAMPOE;
+	cr &= ~STM32_RTC_CR_COE;
+	cr &= ~STM32_RTC_CR_TAMPALRM_TYPE;
+	cr &= ~STM32_RTC_CR_OUT2EN;
+	cfgr &= ~STM32_RTC_CFGR_OUT2_RMP;
+
+	stm32_rtc_wpr_unlock(rtc);
+	writel_relaxed(cr, rtc->base + regs.cr);
+	writel_relaxed(cfgr, rtc->base + regs.cfgr);
+	stm32_rtc_wpr_lock(rtc);
+}
+
 static int stm32_rtc_enter_init_mode(struct stm32_rtc *rtc)
 {
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
@@ -160,10 +351,9 @@ static int stm32_rtc_enter_init_mode(struct stm32_rtc *rtc)
 		 * slowest rtc_ck frequency may be 32kHz and highest should be
 		 * 1MHz, we poll every 10 us with a timeout of 100ms.
 		 */
-		return readl_relaxed_poll_timeout_atomic(
-					rtc->base + regs->isr,
-					isr, (isr & STM32_RTC_ISR_INITF),
-					10, 100000);
+		return readl_relaxed_poll_timeout_atomic(rtc->base + regs->isr, isr,
+							 (isr & STM32_RTC_ISR_INITF),
+							 10, 100000);
 	}
 
 	return 0;
@@ -427,40 +617,42 @@ static int stm32_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
 	return 0;
 }
 
-static int stm32_rtc_valid_alrm(struct stm32_rtc *rtc, struct rtc_time *tm)
+static int stm32_rtc_valid_alrm(struct device *dev, struct rtc_time *tm)
 {
-	const struct stm32_rtc_registers *regs = &rtc->data->regs;
-	int cur_day, cur_mon, cur_year, cur_hour, cur_min, cur_sec;
-	unsigned int dr = readl_relaxed(rtc->base + regs->dr);
-	unsigned int tr = readl_relaxed(rtc->base + regs->tr);
-
-	cur_day = (dr & STM32_RTC_DR_DATE) >> STM32_RTC_DR_DATE_SHIFT;
-	cur_mon = (dr & STM32_RTC_DR_MONTH) >> STM32_RTC_DR_MONTH_SHIFT;
-	cur_year = (dr & STM32_RTC_DR_YEAR) >> STM32_RTC_DR_YEAR_SHIFT;
-	cur_sec = (tr & STM32_RTC_TR_SEC) >> STM32_RTC_TR_SEC_SHIFT;
-	cur_min = (tr & STM32_RTC_TR_MIN) >> STM32_RTC_TR_MIN_SHIFT;
-	cur_hour = (tr & STM32_RTC_TR_HOUR) >> STM32_RTC_TR_HOUR_SHIFT;
+	static struct rtc_time now;
+	time64_t max_alarm_time64;
+	int max_day_forward;
+	int next_month;
+	int next_year;
 
 	/*
 	 * Assuming current date is M-D-Y H:M:S.
 	 * RTC alarm can't be set on a specific month and year.
 	 * So the valid alarm range is:
 	 *	M-D-Y H:M:S < alarm <= (M+1)-D-Y H:M:S
-	 * with a specific case for December...
 	 */
-	if ((((tm->tm_year > cur_year) &&
-	      (tm->tm_mon == 0x1) && (cur_mon == 0x12)) ||
-	     ((tm->tm_year == cur_year) &&
-	      (tm->tm_mon <= cur_mon + 1))) &&
-	    ((tm->tm_mday > cur_day) ||
-	     ((tm->tm_mday == cur_day) &&
-	     ((tm->tm_hour > cur_hour) ||
-	      ((tm->tm_hour == cur_hour) && (tm->tm_min > cur_min)) ||
-	      ((tm->tm_hour == cur_hour) && (tm->tm_min == cur_min) &&
-	       (tm->tm_sec >= cur_sec))))))
-		return 0;
+	stm32_rtc_read_time(dev, &now);
 
-	return -EINVAL;
+	/*
+	 * Find the next month and the year of the next month.
+	 * Note: tm_mon and next_month are from 0 to 11
+	 */
+	next_month = now.tm_mon + 1;
+	if (next_month == 12) {
+		next_month = 0;
+		next_year = now.tm_year + 1;
+	} else {
+		next_year = now.tm_year;
+	}
+
+	/* Find the maximum limit of alarm in days. */
+	max_day_forward = rtc_month_days(now.tm_mon, now.tm_year)
+			 - now.tm_mday
+			 + min(rtc_month_days(next_month, next_year), now.tm_mday);
+
+	/* Convert to timestamp and compare the alarm time and its upper limit */
+	max_alarm_time64 = rtc_tm_to_time64(&now) + max_day_forward * SEC_PER_DAY;
+	return rtc_tm_to_time64(tm) <= max_alarm_time64 ? 0 : -EINVAL;
 }
 
 static int stm32_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
@@ -471,17 +663,17 @@ static int stm32_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	unsigned int cr, isr, alrmar;
 	int ret = 0;
 
-	tm2bcd(tm);
-
 	/*
 	 * RTC alarm can't be set on a specific date, unless this date is
 	 * up to the same day of month next month.
 	 */
-	if (stm32_rtc_valid_alrm(rtc, tm) < 0) {
+	if (stm32_rtc_valid_alrm(dev, tm) < 0) {
 		dev_err(dev, "Alarm can be set only on upcoming month.\n");
 		return -EINVAL;
 	}
 
+	tm2bcd(tm);
+
 	alrmar = 0;
 	/* tm_year and tm_mon are not used because not supported by RTC */
 	alrmar |= (tm->tm_mday << STM32_RTC_ALRMXR_DATE_SHIFT) &
@@ -547,7 +739,10 @@ static void stm32_rtc_clear_events(struct stm32_rtc *rtc,
 static const struct stm32_rtc_data stm32_rtc_data = {
 	.has_pclk = false,
 	.need_dbp = true,
-	.has_wakeirq = false,
+	.need_accuracy = false,
+	.has_lsco = false,
+	.has_alarm_out = false,
+	.rif_protected = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -558,6 +753,7 @@ static const struct stm32_rtc_data stm32_rtc_data = {
 		.wpr = 0x24,
 		.sr = 0x0C, /* set to ISR offset to ease alarm management */
 		.scr = UNDEF_REG,
+		.cfgr = UNDEF_REG,
 		.verr = UNDEF_REG,
 	},
 	.events = {
@@ -569,7 +765,10 @@ static const struct stm32_rtc_data stm32_rtc_data = {
 static const struct stm32_rtc_data stm32h7_rtc_data = {
 	.has_pclk = true,
 	.need_dbp = true,
-	.has_wakeirq = false,
+	.need_accuracy = false,
+	.has_lsco = false,
+	.has_alarm_out = false,
+	.rif_protected = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -580,6 +779,7 @@ static const struct stm32_rtc_data stm32h7_rtc_data = {
 		.wpr = 0x24,
 		.sr = 0x0C, /* set to ISR offset to ease alarm management */
 		.scr = UNDEF_REG,
+		.cfgr = UNDEF_REG,
 		.verr = UNDEF_REG,
 	},
 	.events = {
@@ -600,7 +800,10 @@ static void stm32mp1_rtc_clear_events(struct stm32_rtc *rtc,
 static const struct stm32_rtc_data stm32mp1_data = {
 	.has_pclk = true,
 	.need_dbp = false,
-	.has_wakeirq = true,
+	.need_accuracy = true,
+	.has_lsco = true,
+	.has_alarm_out = true,
+	.rif_protected = false,
 	.regs = {
 		.tr = 0x00,
 		.dr = 0x04,
@@ -611,6 +814,33 @@ static const struct stm32_rtc_data stm32mp1_data = {
 		.wpr = 0x24,
 		.sr = 0x50,
 		.scr = 0x5C,
+		.cfgr = 0x60,
+		.verr = 0x3F4,
+	},
+	.events = {
+		.alra = STM32_RTC_SR_ALRA,
+	},
+	.clear_events = stm32mp1_rtc_clear_events,
+};
+
+static const struct stm32_rtc_data stm32mp25_data = {
+	.has_pclk = true,
+	.need_dbp = false,
+	.need_accuracy = true,
+	.has_lsco = true,
+	.has_alarm_out = true,
+	.rif_protected = true,
+	.regs = {
+		.tr = 0x00,
+		.dr = 0x04,
+		.cr = 0x18,
+		.isr = 0x0C, /* named RTC_ICSR on stm32mp25 */
+		.prer = 0x10,
+		.alrmar = 0x40,
+		.wpr = 0x24,
+		.sr = 0x50,
+		.scr = 0x5C,
+		.cfgr = 0x60,
 		.verr = 0x3F4,
 	},
 	.events = {
@@ -623,17 +853,37 @@ static const struct of_device_id stm32_rtc_of_match[] = {
 	{ .compatible = "st,stm32-rtc", .data = &stm32_rtc_data },
 	{ .compatible = "st,stm32h7-rtc", .data = &stm32h7_rtc_data },
 	{ .compatible = "st,stm32mp1-rtc", .data = &stm32mp1_data },
+	{ .compatible = "st,stm32mp25-rtc", .data = &stm32mp25_data },
 	{}
 };
 MODULE_DEVICE_TABLE(of, stm32_rtc_of_match);
 
+static int stm32_rtc_check_rif(struct stm32_rtc *stm32_rtc,
+			       struct stm32_rtc_rif_resource res)
+{
+	u32 rxcidcfgr = readl_relaxed(stm32_rtc->base + STM32_RTC_RXCIDCFGR(res.num));
+	u32 seccfgr;
+
+	/* Check if RTC available for our CID */
+	if ((rxcidcfgr & STM32_RTC_RXCIDCFGR_CFEN) &&
+	    (FIELD_GET(STM32_RTC_RXCIDCFGR_CID, rxcidcfgr) != STM32_RTC_RXCIDCFGR_CID1))
+		return -EACCES;
+
+	/* Check if RTC available for insecure world */
+	seccfgr = readl_relaxed(stm32_rtc->base + STM32_RTC_SECCFGR);
+	if ((seccfgr & STM32_RTC_SECCFGR_SEC) | (seccfgr & res.bit))
+		return -EACCES;
+
+	return 0;
+}
+
 static int stm32_rtc_init(struct platform_device *pdev,
 			  struct stm32_rtc *rtc)
 {
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
 	unsigned int prer, pred_a, pred_s, pred_a_max, pred_s_max, cr;
 	unsigned int rate;
-	int ret = 0;
+	int ret;
 
 	rate = clk_get_rate(rtc->rtc_ck);
 
@@ -641,18 +891,32 @@ static int stm32_rtc_init(struct platform_device *pdev,
 	pred_a_max = STM32_RTC_PRER_PRED_A >> STM32_RTC_PRER_PRED_A_SHIFT;
 	pred_s_max = STM32_RTC_PRER_PRED_S >> STM32_RTC_PRER_PRED_S_SHIFT;
 
-	for (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {
-		pred_s = (rate / (pred_a + 1)) - 1;
+	if (rate > (pred_a_max + 1) * (pred_s_max + 1)) {
+		dev_err(&pdev->dev, "rtc_ck rate is too high: %dHz\n", rate);
+		return -EINVAL;
+	}
+
+	if (rtc->data->need_accuracy) {
+		for (pred_a = 0; pred_a <= pred_a_max; pred_a++) {
+			pred_s = (rate / (pred_a + 1)) - 1;
+
+			if (pred_s <= pred_s_max && ((pred_s + 1) * (pred_a + 1)) == rate)
+				break;
+		}
+	} else {
+		for (pred_a = pred_a_max; pred_a + 1 > 0; pred_a--) {
+			pred_s = (rate / (pred_a + 1)) - 1;
 
-		if (((pred_s + 1) * (pred_a + 1)) == rate)
-			break;
+			if (((pred_s + 1) * (pred_a + 1)) == rate)
+				break;
+		}
 	}
 
 	/*
 	 * Can't find a 1Hz, so give priority to RTC power consumption
 	 * by choosing the higher possible value for prediv_a
 	 */
-	if ((pred_s > pred_s_max) || (pred_a > pred_a_max)) {
+	if (pred_s > pred_s_max || pred_a > pred_a_max) {
 		pred_a = pred_a_max;
 		pred_s = (rate / (pred_a + 1)) - 1;
 
@@ -661,6 +925,20 @@ static int stm32_rtc_init(struct platform_device *pdev,
 			 "fast" : "slow");
 	}
 
+	cr = readl_relaxed(rtc->base + regs->cr);
+
+	prer = readl_relaxed(rtc->base + regs->prer);
+	prer &= STM32_RTC_PRER_PRED_S | STM32_RTC_PRER_PRED_A;
+
+	pred_s = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) &
+		 STM32_RTC_PRER_PRED_S;
+	pred_a = (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) &
+		 STM32_RTC_PRER_PRED_A;
+
+	/* quit if there is nothing to initialize */
+	if ((cr & STM32_RTC_CR_FMT) == 0 && prer == (pred_s | pred_a))
+		return 0;
+
 	stm32_rtc_wpr_unlock(rtc);
 
 	ret = stm32_rtc_enter_init_mode(rtc);
@@ -670,13 +948,10 @@ static int stm32_rtc_init(struct platform_device *pdev,
 		goto end;
 	}
 
-	prer = (pred_s << STM32_RTC_PRER_PRED_S_SHIFT) & STM32_RTC_PRER_PRED_S;
-	writel_relaxed(prer, rtc->base + regs->prer);
-	prer |= (pred_a << STM32_RTC_PRER_PRED_A_SHIFT) & STM32_RTC_PRER_PRED_A;
-	writel_relaxed(prer, rtc->base + regs->prer);
+	writel_relaxed(pred_s, rtc->base + regs->prer);
+	writel_relaxed(pred_a | pred_s, rtc->base + regs->prer);
 
 	/* Force 24h time format */
-	cr = readl_relaxed(rtc->base + regs->cr);
 	cr &= ~STM32_RTC_CR_FMT;
 	writel_relaxed(cr, rtc->base + regs->cr);
 
@@ -735,16 +1010,13 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 		rtc->rtc_ck = devm_clk_get(&pdev->dev, NULL);
 	} else {
 		rtc->pclk = devm_clk_get(&pdev->dev, "pclk");
-		if (IS_ERR(rtc->pclk)) {
-			dev_err(&pdev->dev, "no pclk clock");
-			return PTR_ERR(rtc->pclk);
-		}
+		if (IS_ERR(rtc->pclk))
+			return dev_err_probe(&pdev->dev, PTR_ERR(rtc->pclk), "no pclk clock");
+
 		rtc->rtc_ck = devm_clk_get(&pdev->dev, "rtc_ck");
 	}
-	if (IS_ERR(rtc->rtc_ck)) {
-		dev_err(&pdev->dev, "no rtc_ck clock");
-		return PTR_ERR(rtc->rtc_ck);
-	}
+	if (IS_ERR(rtc->rtc_ck))
+		return dev_err_probe(&pdev->dev, PTR_ERR(rtc->rtc_ck), "no rtc_ck clock");
 
 	if (rtc->data->has_pclk) {
 		ret = clk_prepare_enable(rtc->pclk);
@@ -760,6 +1032,16 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 		regmap_update_bits(rtc->dbp, rtc->dbp_reg,
 				   rtc->dbp_mask, rtc->dbp_mask);
 
+	if (rtc->data->rif_protected) {
+		ret = stm32_rtc_check_rif(rtc, STM32_RTC_RES_INIT);
+		if (!ret)
+			ret = stm32_rtc_check_rif(rtc, STM32_RTC_RES_ALRA);
+		if (ret) {
+			dev_err(&pdev->dev, "Failed to probe RTC due to RIF configuration\n");
+			goto err;
+		}
+	}
+
 	/*
 	 * After a system reset, RTC_ISR.INITS flag can be read to check if
 	 * the calendar has been initialized or not. INITS flag is reset by a
@@ -779,19 +1061,12 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 	}
 
 	ret = device_init_wakeup(&pdev->dev, true);
-	if (rtc->data->has_wakeirq) {
-		rtc->wakeirq_alarm = platform_get_irq(pdev, 1);
-		if (rtc->wakeirq_alarm > 0) {
-			ret = dev_pm_set_dedicated_wake_irq(&pdev->dev,
-							    rtc->wakeirq_alarm);
-		} else {
-			ret = rtc->wakeirq_alarm;
-			if (rtc->wakeirq_alarm == -EPROBE_DEFER)
-				goto err;
-		}
-	}
 	if (ret)
-		dev_warn(&pdev->dev, "alarm can't wake up the system: %d", ret);
+		goto err;
+
+	ret = dev_pm_set_wake_irq(&pdev->dev, rtc->irq_alarm);
+	if (ret)
+		goto err;
 
 	platform_set_drvdata(pdev, rtc);
 
@@ -804,6 +1079,9 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	rtc->rtc_dev->range_min = RTC_TIMESTAMP_BEGIN_2000;
+	rtc->rtc_dev->range_max = RTC_TIMESTAMP_END_2099;
+
 	/* Handle RTC alarm interrupts */
 	ret = devm_request_threaded_irq(&pdev->dev, rtc->irq_alarm, NULL,
 					stm32_rtc_alarm_irq, IRQF_ONESHOT,
@@ -814,6 +1092,33 @@ static int stm32_rtc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	if (rtc->data->has_alarm_out) {
+		ret = of_property_read_s32(pdev->dev.of_node, "st,alarm", &rtc->out_alarm);
+		if (!ret) {
+			ret = stm32_rtc_out_alarm_config(pdev);
+		} else {
+			stm32_rtc_out_alarm_disable(pdev);
+			rtc->out_alarm = ret;
+			dev_dbg(&pdev->dev, "No alarm out: %d\n", ret);
+		}
+	}
+
+	if (rtc->data->has_lsco) {
+		ret = of_property_read_s32(pdev->dev.of_node,
+					   "st,lsco", &rtc->lsco);
+		if (!ret) {
+			ret = stm32_rtc_clk_lsco_register(pdev);
+			if (ret)
+				dev_warn(&pdev->dev,
+					 "LSCO clock registration failed: %d\n",
+					 ret);
+		} else {
+			stm32_rtc_clk_lsco_disable(pdev);
+			rtc->lsco = ret;
+			dev_dbg(&pdev->dev, "No LSCO clock: %d\n", ret);
+		}
+	}
+
 	/*
 	 * If INITS flag is reset (calendar year field set to 0x00), calendar
 	 * must be initialized
@@ -852,6 +1157,9 @@ static int stm32_rtc_remove(struct platform_device *pdev)
 	const struct stm32_rtc_registers *regs = &rtc->data->regs;
 	unsigned int cr;
 
+	if (!IS_ERR_OR_NULL(rtc->clk_lsco))
+		clk_unregister_gate(rtc->clk_lsco);
+
 	/* Disable interrupts */
 	stm32_rtc_wpr_unlock(rtc);
 	cr = readl_relaxed(rtc->base + regs->cr);
@@ -873,7 +1181,6 @@ static int stm32_rtc_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
 static int stm32_rtc_suspend(struct device *dev)
 {
 	struct stm32_rtc *rtc = dev_get_drvdata(dev);
@@ -881,9 +1188,6 @@ static int stm32_rtc_suspend(struct device *dev)
 	if (rtc->data->has_pclk)
 		clk_disable_unprepare(rtc->pclk);
 
-	if (device_may_wakeup(dev))
-		return enable_irq_wake(rtc->irq_alarm);
-
 	return 0;
 }
 
@@ -905,15 +1209,12 @@ static int stm32_rtc_resume(struct device *dev)
 		return ret;
 	}
 
-	if (device_may_wakeup(dev))
-		return disable_irq_wake(rtc->irq_alarm);
-
 	return ret;
 }
-#endif
 
-static SIMPLE_DEV_PM_OPS(stm32_rtc_pm_ops,
-			 stm32_rtc_suspend, stm32_rtc_resume);
+static const struct dev_pm_ops stm32_rtc_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(stm32_rtc_suspend, stm32_rtc_resume)
+};
 
 static struct platform_driver stm32_rtc_driver = {
 	.probe		= stm32_rtc_probe,
diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index e461c0711..6070bbb78 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -21,6 +21,7 @@ source "drivers/soc/renesas/Kconfig"
 source "drivers/soc/rockchip/Kconfig"
 source "drivers/soc/samsung/Kconfig"
 source "drivers/soc/sifive/Kconfig"
+source "drivers/soc/st/Kconfig"
 source "drivers/soc/sunxi/Kconfig"
 source "drivers/soc/tegra/Kconfig"
 source "drivers/soc/ti/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 69ba6508c..145368ffd 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -27,6 +27,7 @@ obj-y				+= renesas/
 obj-y				+= rockchip/
 obj-$(CONFIG_SOC_SAMSUNG)	+= samsung/
 obj-$(CONFIG_SOC_SIFIVE)	+= sifive/
+obj-$(CONFIG_ARCH_STM32)	+= st/
 obj-y				+= sunxi/
 obj-$(CONFIG_ARCH_TEGRA)	+= tegra/
 obj-y				+= ti/
diff --git a/drivers/soc/st/Kconfig b/drivers/soc/st/Kconfig
new file mode 100644
index 000000000..5500c81ec
--- /dev/null
+++ b/drivers/soc/st/Kconfig
@@ -0,0 +1,19 @@
+if ARCH_STM32
+
+config STM32_PM_DOMAINS
+	bool "STM32 PM domains"
+	depends on MACH_STM32MP157
+	select PM_GENERIC_DOMAINS
+	default y if MACH_STM32MP157
+
+config STM32_RISAF
+	tristate "STM32 RISAF"
+	depends on ARM64 && DEBUG_FS
+	default y
+	help
+	  Say y to enable RISAF dump debug helper driver. This creates an entry
+	  in the debugfs to dump RISAF memory regions configurations and
+	  topology. It implicitly requires that the RISAF is clocked by a
+	  capable software component.
+
+endif # ARCH_STM32
diff --git a/drivers/soc/st/Makefile b/drivers/soc/st/Makefile
new file mode 100644
index 000000000..ac8d969a6
--- /dev/null
+++ b/drivers/soc/st/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_STM32_PM_DOMAINS) += stm32_pm_domain.o
+obj-$(CONFIG_STM32_RISAF) += stm32_risaf.o
diff --git a/drivers/soc/st/stm32_pm_domain.c b/drivers/soc/st/stm32_pm_domain.c
new file mode 100644
index 000000000..0386624c2
--- /dev/null
+++ b/drivers/soc/st/stm32_pm_domain.c
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ * Author: Olivier Bideau <olivier.bideau@st.com> for STMicroelectronics.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pm_domain.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+
+#define SMC(domain, state)				\
+{							\
+	struct arm_smccc_res res;			\
+	arm_smccc_smc(0x82001008, domain, state, 0,	\
+		      0, 0, 0, 0, &res);		\
+}
+
+#define STM32_SMC_PD_DOMAIN_ON	0
+#define STM32_SMC_PD_DOMAIN_OFF	1
+
+struct stm32_pm_domain {
+	struct device *dev;
+	struct generic_pm_domain genpd;
+	int id;
+};
+
+static int stm32_pd_power_off(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+
+	SMC(priv->id, STM32_SMC_PD_DOMAIN_OFF);
+
+	dev_dbg(priv->dev, "%s OFF\n", domain->name);
+
+	return 0;
+}
+
+static int stm32_pd_power_on(struct generic_pm_domain *domain)
+{
+	struct stm32_pm_domain *priv = container_of(domain,
+						    struct stm32_pm_domain,
+						    genpd);
+
+	SMC(priv->id, STM32_SMC_PD_DOMAIN_ON);
+
+	dev_dbg(priv->dev, "%s ON\n", domain->name);
+
+	return 0;
+}
+
+static void stm32_pm_domain_remove(struct stm32_pm_domain *domain)
+{
+	int ret;
+
+	ret = pm_genpd_remove(&domain->genpd);
+	if (ret)
+		dev_err(domain->dev, "failed to remove PM domain %s: %d\n",
+			domain->genpd.name, ret);
+}
+
+static int stm32_pm_domain_add(struct stm32_pm_domain *domain,
+			       struct device *dev,
+			       struct device_node *np)
+{
+	int ret;
+
+	domain->dev = dev;
+	domain->genpd.name = np->name;
+	domain->genpd.power_off = stm32_pd_power_off;
+	domain->genpd.power_on = stm32_pd_power_on;
+	domain->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
+
+	ret = of_property_read_u32(np, "reg", &domain->id);
+	if (ret) {
+		dev_err(domain->dev, "no domain ID\n");
+		return ret;
+	}
+
+	ret = pm_genpd_init(&domain->genpd, NULL, 0);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to initialise PM domain %s: %d\n",
+			np->name, ret);
+		return ret;
+	}
+
+	ret = of_genpd_add_provider_simple(np, &domain->genpd);
+	if (ret < 0) {
+		dev_err(domain->dev, "failed to register PM domain %s: %d\n",
+			np->name, ret);
+		stm32_pm_domain_remove(domain);
+		return ret;
+	}
+
+	dev_info(domain->dev, "domain %s registered\n", np->name);
+
+	return 0;
+}
+
+static void stm32_pm_subdomain_add(struct stm32_pm_domain *domain,
+				   struct device *dev,
+				   struct device_node *np)
+{
+	struct device_node *np_child;
+	int ret;
+
+	for_each_child_of_node(np, np_child) {
+		struct stm32_pm_domain *sub_domain;
+
+		sub_domain = devm_kzalloc(dev, sizeof(*sub_domain), GFP_KERNEL);
+		if (!sub_domain)
+			continue;
+
+		sub_domain->dev = dev;
+		sub_domain->genpd.name = np_child->name;
+		sub_domain->genpd.power_off = stm32_pd_power_off;
+		sub_domain->genpd.power_on = stm32_pd_power_on;
+		sub_domain->genpd.flags |= GENPD_FLAG_ACTIVE_WAKEUP;
+
+		ret = of_property_read_u32(np_child, "reg", &sub_domain->id);
+		if (ret) {
+			dev_err(sub_domain->dev, "no domain ID\n");
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		ret = pm_genpd_init(&sub_domain->genpd, NULL, 0);
+		if (ret < 0) {
+			dev_err(sub_domain->dev, "failed to initialise PM domain %s: %d\n"
+				, np_child->name, ret);
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		ret = of_genpd_add_provider_simple(np_child,
+						   &sub_domain->genpd);
+		if (ret < 0) {
+			dev_err(sub_domain->dev, "failed to register PM domain %s: %d\n"
+				, np_child->name, ret);
+			stm32_pm_domain_remove(sub_domain);
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		ret = pm_genpd_add_subdomain(&domain->genpd,
+					     &sub_domain->genpd);
+
+		if (ret < 0) {
+			dev_err(sub_domain->dev, "failed to add Sub PM domain %s: %d\n"
+				, np_child->name, ret);
+			stm32_pm_domain_remove(sub_domain);
+			devm_kfree(dev, sub_domain);
+			continue;
+		}
+
+		dev_info(sub_domain->dev, "subdomain %s registered\n",
+			 np_child->name);
+	}
+}
+
+static int stm32_pm_domain_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node, *child_np;
+	int ret;
+
+	for_each_child_of_node(np, child_np) {
+		struct stm32_pm_domain *domain;
+
+		domain = devm_kzalloc(dev, sizeof(*domain), GFP_KERNEL);
+		if (!domain)
+			continue;
+
+		ret = stm32_pm_domain_add(domain, dev, child_np);
+		if (ret) {
+			devm_kfree(dev, domain);
+			continue;
+		}
+
+		stm32_pm_subdomain_add(domain, dev, child_np);
+	}
+
+	dev_info(dev, "domains probed\n");
+
+	return 0;
+}
+
+static const struct of_device_id stm32_pm_domain_matches[] = {
+	{ .compatible = "st,stm32mp157c-pd", },
+	{ },
+};
+
+static struct platform_driver stm32_pm_domains_driver = {
+	.probe = stm32_pm_domain_probe,
+	.driver = {
+		.name   = "stm32-pm-domain",
+		.of_match_table = stm32_pm_domain_matches,
+	},
+};
+
+static int __init stm32_pm_domains_init(void)
+{
+	return platform_driver_register(&stm32_pm_domains_driver);
+}
+core_initcall(stm32_pm_domains_init);
diff --git a/drivers/soc/st/stm32_risaf.c b/drivers/soc/st/stm32_risaf.c
new file mode 100644
index 000000000..58bf2ba3f
--- /dev/null
+++ b/drivers/soc/st/stm32_risaf.c
@@ -0,0 +1,257 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2024, STMicroelectronics - All Rights Reserved
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+/*
+ * RISAF registers
+ */
+#define _RISAF_REG_CFGR(x)		(0x40 + 0x40 * ((x) - 1))
+#define _RISAF_REG_STARTR(x)		(0x44 + 0x40 * ((x) - 1))
+#define _RISAF_REG_ENDR(x)		(0x48 + 0x40 * ((x) - 1))
+#define _RISAF_REG_CIDCFGR(x)		(0x4c + 0x40 * ((x) - 1))
+#define _RISAF_HWCFGR			0xFF0
+
+/*
+ * _RISAF_REG_CFGR register
+ */
+#define _RISAF_REG_CFGR_BREN_SHIFT	0
+#define _RISAF_REG_CFGR_BREN		BIT(_RISAF_REG_CFGR_BREN_SHIFT)
+#define _RISAF_REG_CFGR_SEC_SHIFT	8
+#define _RISAF_REG_CFGR_SEC		BIT(_RISAF_REG_CFGR_SEC_SHIFT)
+#define _RISAF_REG_CFGR_ENC_SHIFT	15
+#define _RISAF_REG_CFGR_ENC		BIT(_RISAF_REG_CFGR_ENC_SHIFT)
+#define _RISAF_REG_CFGR_PRIVC_SHIFT	16
+#define _RISAF_REG_CFGR_PRIVC_MASK	GENMASK(23, 16)
+
+/*
+ * _RISAF_REG_CIDCFGR register
+ */
+#define _RISAF_REG_CIDCFGR_RDENC_SHIFT	0
+#define _RISAF_REG_CIDCFGR_RDENC_MASK	GENMASK(7, 0)
+#define _RISAF_REG_CIDCFGR_WRENC_SHIFT	16
+#define _RISAF_REG_CIDCFGR_WRENC_MASK	GENMASK(23, 16)
+
+/*
+ * _RISAF_HWCFGR register
+ */
+#define _RISAF_HWCFGR_CFG1		GENMASK(7, 0)
+
+#define NB_CID_SUPPORTED		8
+#define CID_STRING_LENGTH		20
+#define SEPARATOR_STRING_LENGTH		145
+
+struct risaf_debug_data {
+	uint reg_id;
+	phys_addr_t reg_base;
+	phys_addr_t reg_end;
+	uint cid_priv_list;
+	uint cid_r_list;
+	uint cid_w_list;
+	bool encrypted;
+	bool enabled;
+	bool sec;
+};
+
+struct risaf_pdata {
+	void __iomem *base;
+	struct device *dev;
+	struct dentry *dbg_entry;
+	phys_addr_t risaf_map_base;
+	uint nb_reg;
+};
+
+static void stm32_risaf_fill_dev_dbg_entry(struct risaf_pdata *pdata,
+					   struct risaf_debug_data *dbg_entry,
+					   uint i)
+{
+	u32 cfgr, cidcfgr;
+
+	dbg_entry->reg_id = i;
+
+	cfgr = readl_relaxed(pdata->base + _RISAF_REG_CFGR(i));
+	dbg_entry->encrypted = cfgr & _RISAF_REG_CFGR_ENC;
+	dbg_entry->enabled = cfgr & _RISAF_REG_CFGR_BREN;
+	dbg_entry->sec = cfgr & _RISAF_REG_CFGR_SEC;
+	dbg_entry->cid_priv_list = (cfgr & _RISAF_REG_CFGR_PRIVC_MASK) >>
+				   _RISAF_REG_CFGR_PRIVC_SHIFT;
+
+	dbg_entry->reg_base = readl_relaxed(pdata->base + _RISAF_REG_STARTR(i));
+	dbg_entry->reg_end = readl_relaxed(pdata->base + _RISAF_REG_ENDR(i));
+
+	cidcfgr = readl_relaxed(pdata->base + _RISAF_REG_CIDCFGR(i));
+	dbg_entry->cid_r_list = cidcfgr & _RISAF_REG_CIDCFGR_RDENC_MASK;
+	dbg_entry->cid_w_list = (cidcfgr & _RISAF_REG_CIDCFGR_WRENC_MASK) >>
+				_RISAF_REG_CIDCFGR_WRENC_SHIFT;
+}
+
+static void stm32_risaf_build_cid_bf_string(uint bf_list, char *string, size_t len)
+{
+	bool first_occurence = true;
+	char i_as_char[3];
+	uint i;
+
+	memset(string, 0, strlen(string));
+
+	if (!bf_list)
+		return;
+
+	snprintf(string, len, "CID");
+	for (i = 0; i < NB_CID_SUPPORTED; i++) {
+		if (bf_list & BIT(i)) {
+			if (first_occurence) {
+				sprintf(i_as_char, "%u", i);
+				first_occurence = false;
+			} else {
+				sprintf(i_as_char, ",%u", i);
+			}
+			strncat(string, i_as_char, len);
+		}
+	}
+}
+
+static int stm32_risaf_conf_dump_show(struct seq_file *s, void *data)
+{
+	struct risaf_pdata *pdata = (struct risaf_pdata *)s->private;
+	char cid_string[CID_STRING_LENGTH] = {0};
+	char separator[SEPARATOR_STRING_LENGTH];
+	uint i;
+
+	pdata->nb_reg = readl_relaxed(pdata->base + _RISAF_HWCFGR) & _RISAF_HWCFGR_CFG1;
+	memset(separator, '-', sizeof(separator) - 1);
+	memset(separator + sizeof(separator) - 1, '\0', 1);
+
+
+	seq_printf(s, "\n%s\n", separator);
+	seq_puts(s, "| Region ID |");
+	seq_puts(s, "| Region base addr |");
+	seq_puts(s, "| Region end addr |");
+	seq_puts(s, "| Enabled |");
+	seq_puts(s, "| Encrypted |");
+	seq_puts(s, "| N/SECURE |");
+	seq_puts(s, "| CID PRIV-only list |");
+	seq_puts(s, "| CID read list |");
+	seq_puts(s, "| CID write list |");
+	seq_printf(s, "\n%s\n", separator);
+
+	/* Region 0 is the immutable and implicit RISAF TDCID-only base region, skip index 0 */
+	for (i = 1; i <= pdata->nb_reg; i++) {
+		struct risaf_debug_data d_dbg_entry;
+
+		stm32_risaf_fill_dev_dbg_entry(pdata, &d_dbg_entry, i);
+		seq_printf(s, "| Region %-2u |", d_dbg_entry.reg_id);
+		seq_printf(s, "| %#-16llx |", pdata->risaf_map_base + d_dbg_entry.reg_base);
+		seq_printf(s, "| %#-15llx |", pdata->risaf_map_base + d_dbg_entry.reg_end);
+		seq_printf(s, "| %-7s |", d_dbg_entry.enabled ? "ENABLED" : "");
+		seq_printf(s, "| %-9s |", d_dbg_entry.encrypted ? "YES" : "");
+		seq_printf(s, "| %-8s |", d_dbg_entry.sec ? "SEC" : "NSEC");
+
+		/* CID PRIV-only list */
+		stm32_risaf_build_cid_bf_string(d_dbg_entry.cid_priv_list, cid_string,
+						sizeof(cid_string));
+		seq_printf(s, "| %-18s |", cid_string);
+
+		/* CID read list */
+		stm32_risaf_build_cid_bf_string(d_dbg_entry.cid_r_list, cid_string,
+						sizeof(cid_string));
+		seq_printf(s, "| %-13s |", cid_string);
+
+		/* CID write list */
+		stm32_risaf_build_cid_bf_string(d_dbg_entry.cid_w_list, cid_string,
+						sizeof(cid_string));
+		seq_printf(s, "| %-14s |\n", cid_string);
+
+		seq_printf(s, "%s\n", separator);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(stm32_risaf_conf_dump);
+
+static int stm32_risaf_register_debugfs(struct risaf_pdata *pdata)
+{
+	struct dentry *root = NULL;
+
+	root = debugfs_lookup("stm32_firewall", NULL);
+	if (!root)
+		root = debugfs_create_dir("stm32_firewall", NULL);
+
+	if (IS_ERR(root))
+		return PTR_ERR(root);
+
+	pdata->dbg_entry = debugfs_create_file(pdata->dev->of_node->full_name, 0444, root, pdata,
+					       &stm32_risaf_conf_dump_fops);
+
+	return 0;
+}
+
+static void stm32_risaf_remove(struct platform_device *pdev)
+{
+	struct risaf_pdata *pdata = platform_get_drvdata(pdev);
+
+	debugfs_remove(pdata->dbg_entry);
+}
+
+static int stm32_risaf_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct risaf_pdata *pdata;
+	void __iomem *mmio;
+	int err;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	mmio =  devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(mmio))
+		return PTR_ERR(mmio);
+
+	pdata->base = mmio;
+	pdata->dev = &pdev->dev;
+
+	err = of_property_read_u64_index(np, "st,mem-map", 0, &pdata->risaf_map_base);
+	if (err) {
+		pr_err("Couldn't read st,mem-map property");
+		return err;
+	}
+
+	platform_set_drvdata(pdev, pdata);
+
+	stm32_risaf_register_debugfs(pdata);
+
+	/* Populate all available nodes */
+	return of_platform_populate(np, NULL, NULL, &pdev->dev);
+}
+
+static const struct of_device_id stm32_risaf_match[] = {
+	{ .compatible = "st,stm32mp25-risaf", },
+	{ .compatible = "st,stm32mp25-risaf-enc", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_risaf_match);
+
+static struct platform_driver stm32_risaf_driver = {
+	.probe  = stm32_risaf_probe,
+	.remove_new = stm32_risaf_remove,
+	.driver = {
+		.name = "stm32-risaf",
+		.of_match_table = stm32_risaf_match,
+	},
+};
+module_platform_driver(stm32_risaf_driver);
+MODULE_AUTHOR("Gatien Chevallier <gatien.chevallier@foss.st.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 15ea11ebc..f9f8ec8c5 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -912,6 +912,7 @@ config SPI_SPRD_ADI
 config SPI_STM32
 	tristate "STMicroelectronics STM32 SPI controller"
 	depends on ARCH_STM32 || COMPILE_TEST
+	select SPI_SLAVE
 	help
 	  SPI driver for STMicroelectronics STM32 SoCs.
 
@@ -919,6 +920,17 @@ config SPI_STM32
 	  is not available, the driver automatically falls back to
 	  PIO mode.
 
+config SPI_STM32_OSPI
+	tristate "STMicroelectronics STM32 OCTO SPI controller"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on OF
+	depends on SPI_MEM
+	depends on STM32_OMI
+	help
+	  This enables support for the Octo SPI controller in master mode.
+	  This driver does not support generic SPI. The implementation only
+	  supports spi-mem interface.
+
 config SPI_STM32_QSPI
 	tristate "STMicroelectronics STM32 QUAD SPI controller"
 	depends on ARCH_STM32 || COMPILE_TEST
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 4b34e855c..18a7e48ce 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -124,6 +124,7 @@ obj-$(CONFIG_SPI_SPRD)			+= spi-sprd.o
 obj-$(CONFIG_SPI_SPRD_ADI)		+= spi-sprd-adi.o
 obj-$(CONFIG_SPI_STM32) 		+= spi-stm32.o
 obj-$(CONFIG_SPI_STM32_QSPI) 		+= spi-stm32-qspi.o
+obj-$(CONFIG_SPI_STM32_OSPI) 		+= spi-stm32-ospi.o
 obj-$(CONFIG_SPI_ST_SSC4)		+= spi-st-ssc4.o
 obj-$(CONFIG_SPI_SUN4I)			+= spi-sun4i.o
 obj-$(CONFIG_SPI_SUN6I)			+= spi-sun6i.o
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index 0c79193d9..4b7c6ee0e 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -172,6 +172,10 @@ bool spi_mem_default_supports_op(struct spi_mem *mem,
 		if (!spi_mem_controller_is_capable(ctlr, dtr))
 			return false;
 
+		if (op->data.dtr_swab16 &&
+		    !(spi_mem_controller_is_capable(ctlr, dtr_swab16)))
+			return false;
+
 		if (op->cmd.nbytes != 2)
 			return false;
 	} else {
diff --git a/drivers/spi/spi-stm32-ospi.c b/drivers/spi/spi-stm32-ospi.c
new file mode 100644
index 000000000..8a759c694
--- /dev/null
+++ b/drivers/spi/spi-stm32-ospi.c
@@ -0,0 +1,1210 @@
+// SPDX-License-Identifier: GPL
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#include <memory/stm32-omi.h>
+
+#define STM32_AUTOSUSPEND_DELAY -1
+
+#define MACRONIX_ID		0xc2
+
+struct stm32_ospi_flash {
+	struct spi_device *spi;
+	u32 presc;
+	u32 dlyb_cr_str;
+	u32 dlyb_cr_dtr;
+	u32 dcr_reg;
+	u64 str_idcode;
+	u64 dtr_idcode;
+	bool is_spi_nor;
+	bool octal_dtr;
+	bool is_str_calibration;
+	bool dtr_calibration_done_once;
+	bool sample_later;
+	bool str_sample_later;
+	bool is_octal_bus;
+	bool dtr_mode;
+};
+
+struct stm32_ospi {
+	struct device *dev;
+	struct spi_controller *ctrl;
+	struct stm32_omi *omi;
+	struct stm32_ospi_flash flash[STM32_OMI_MAX_NORCHIP];
+
+	u32 cr_reg;
+	u64 id_buf;
+	int last_cs;
+	unsigned long status_timeout;
+
+	/*
+	 * To protect device configuration, could be different between
+	 * 2 flash access
+	 */
+	struct mutex lock;
+};
+
+static int stm32_ospi_tx_mm(struct stm32_ospi *ospi,
+			    const struct spi_mem_op *op)
+{
+	struct stm32_omi *omi = ospi->omi;
+
+	memcpy_fromio(op->data.buf.in, omi->mm_base + op->addr.val,
+		      op->data.nbytes);
+	return 0;
+}
+
+static int stm32_ospi_tx_dma(struct stm32_ospi *ospi,
+			     const struct spi_mem_op *op)
+{
+	struct dma_async_tx_descriptor *desc;
+	struct stm32_omi *omi = ospi->omi;
+	struct stm32_ospi_flash *flash = &ospi->flash[ospi->last_cs];
+	void __iomem *regs_base = omi->regs_base;
+	enum dma_transfer_direction dma_dir;
+	struct dma_chan *dma_ch;
+	struct sg_table sgt;
+	dma_cookie_t cookie;
+	u32 cr, t_out;
+	u8 dummy = 0xff;
+	int err, ret;
+
+	if (op->data.dir == SPI_MEM_DATA_IN) {
+		dma_dir = DMA_DEV_TO_MEM;
+		dma_ch = omi->dma_chrx;
+	} else {
+		dma_dir = DMA_MEM_TO_DEV;
+		dma_ch = omi->dma_chtx;
+	}
+
+	if (flash->octal_dtr && op->addr.val % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * Spi_map_buf return -EINVAL if the buffer is not DMA-able
+	 * (DMA-able: in vmalloc | kmap | virt_addr_valid)
+	 */
+	err = spi_controller_dma_map_mem_op_data(ospi->ctrl, op, &sgt);
+	if (err)
+		return err;
+
+	desc = dmaengine_prep_slave_sg(dma_ch, sgt.sgl, sgt.nents,
+				       dma_dir, DMA_PREP_INTERRUPT);
+	if (!desc) {
+		err = -ENOMEM;
+		goto out_unmap;
+	}
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+
+	reinit_completion(&omi->dma_completion);
+	desc->callback = stm32_omi_dma_callback;
+	desc->callback_param = &omi->dma_completion;
+	cookie = dmaengine_submit(desc);
+	err = dma_submit_error(cookie);
+	if (err)
+		goto out;
+
+	dma_async_issue_pending(dma_ch);
+
+	writel_relaxed(cr | CR_DMAEN, regs_base + OSPI_CR);
+
+	t_out = sgt.nents * STM32_COMP_TIMEOUT_MS;
+	if (!wait_for_completion_timeout(&omi->dma_completion,
+					 msecs_to_jiffies(t_out)))
+		err = -ETIMEDOUT;
+
+	if (err)
+		dmaengine_terminate_all(dma_ch);
+
+out:
+	writel_relaxed(cr & ~CR_DMAEN, regs_base + OSPI_CR);
+out_unmap:
+	spi_controller_dma_unmap_mem_op_data(ospi->ctrl, op, &sgt);
+
+	if (flash->octal_dtr && !err && (op->addr.val + op->data.nbytes) % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	return err;
+}
+
+static int stm32_ospi_tx(struct stm32_ospi *ospi, const struct spi_mem_op *op)
+{
+	struct stm32_omi *omi = ospi->omi;
+	struct stm32_ospi_flash *flash = &ospi->flash[ospi->last_cs];
+	u8 *buf;
+	u8 dummy = 0xff;
+	int ret;
+
+	if (!op->data.nbytes)
+		return 0;
+
+	if (omi->fmode == CR_FMODE_MM)
+		return stm32_ospi_tx_mm(ospi, op);
+	else if (((op->data.dir == SPI_MEM_DATA_IN && omi->dma_chrx) ||
+		 (op->data.dir == SPI_MEM_DATA_OUT && omi->dma_chtx)) &&
+		  op->data.nbytes > 8)
+		if (!stm32_ospi_tx_dma(ospi, op))
+			return 0;
+
+	if (op->data.dir == SPI_MEM_DATA_IN)
+		buf = op->data.buf.in;
+	else
+		buf = (u8 *)op->data.buf.out;
+
+	if (flash->octal_dtr && op->addr.val % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	ret = stm32_omi_tx_poll(omi, buf, op->data.nbytes,
+				op->data.dir == SPI_MEM_DATA_IN);
+	if (ret)
+		return ret;
+
+	if (flash->octal_dtr && (op->addr.val + op->data.nbytes) % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_wait_poll_status(struct stm32_ospi *ospi,
+				       const struct spi_mem_op *op)
+{
+	struct stm32_omi *omi = ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 cr;
+
+	reinit_completion(&omi->match_completion);
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	writel_relaxed(cr | CR_SMIE, regs_base + OSPI_CR);
+
+	if (!wait_for_completion_timeout(&omi->match_completion,
+					 msecs_to_jiffies(ospi->status_timeout)))
+		return -ETIMEDOUT;
+
+	writel_relaxed(FCR_CSMF, regs_base + OSPI_FCR);
+
+	return 0;
+}
+
+static int stm32_ospi_get_mode(u8 buswidth)
+{
+	switch (buswidth) {
+	case 8:
+		return CCR_BUSWIDTH_8;
+	case 4:
+		return CCR_BUSWIDTH_4;
+	default:
+		return buswidth;
+	}
+}
+
+static void stm32_ospi_set_prescaler(struct stm32_ospi *ospi, u32 presc)
+{
+	struct stm32_omi *omi = ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 dcr2;
+
+	/* Set prescaler */
+	dcr2 = readl_relaxed(regs_base + OSPI_DCR2);
+	dcr2 &= ~DCR2_PRESC_MASK;
+	dcr2 |= FIELD_PREP(DCR2_PRESC_MASK, presc);
+	writel_relaxed(dcr2, regs_base + OSPI_DCR2);
+}
+
+static int stm32_ospi_send(struct spi_device *spi, const struct spi_mem_op *op)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(spi->master);
+	struct stm32_ospi_flash *flash = &ospi->flash[spi->chip_select];
+	struct stm32_omi *omi = ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 ccr, cr, tcr = 0;
+	u64 addr = op->addr.val;
+	unsigned int nbytes = op->data.nbytes;
+	int timeout, err = 0, err_poll_status = 0;
+
+	dev_dbg(ospi->dev, "cmd:%#x dtr:%d mode:%d.%d.%d.%d addr:%#llx len:%#x\n",
+		op->cmd.opcode, op->cmd.dtr, op->cmd.buswidth,
+		op->addr.buswidth, op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	cr = readl_relaxed(regs_base + OSPI_CR);
+	cr &= ~CR_CSSEL;
+	cr |= FIELD_PREP(CR_CSSEL, spi->chip_select);
+	cr &= ~CR_FMODE_MASK;
+	cr |= FIELD_PREP(CR_FMODE_MASK, omi->fmode);
+	writel_relaxed(cr, regs_base + OSPI_CR);
+
+	/*
+	 * When DTR mode and indirect read/write mode are set, there is a
+	 * constraint on the address and the number of bytes read or write
+	 * that should be even.
+	 */
+	if (flash->octal_dtr && omi->fmode != CR_FMODE_MM && op->data.nbytes) {
+		if (op->addr.val % 2) {
+			addr--;
+			nbytes++;
+		}
+
+		if ((op->addr.val + op->data.nbytes) % 2)
+			nbytes++;
+	}
+
+	writel_relaxed(flash->dcr_reg, regs_base + OSPI_DCR1);
+
+	if (op->data.nbytes && omi->fmode != CR_FMODE_MM)
+		writel_relaxed(nbytes - 1, regs_base + OSPI_DLR);
+
+	ccr = FIELD_PREP(CCR_IMODE_MASK, stm32_ospi_get_mode(op->cmd.buswidth));
+	ccr |= FIELD_PREP(CCR_ISIZE_MASK, op->cmd.nbytes - 1);
+
+	if (op->cmd.dtr) {
+		ccr |= CCR_IDTR;
+		ccr |= CCR_DQSE;
+	}
+
+	if (op->addr.dtr)
+		ccr |= CCR_ADDTR;
+
+	if (op->data.dtr)
+		ccr |= CCR_DDTR;
+
+	if (op->data.dtr_swab16)
+		writel_relaxed(flash->dcr_reg |
+			       FIELD_PREP(DCR1_MTYP_MASK, DCR1_MTYP_MX_MODE),
+			       regs_base + OSPI_DCR1);
+
+	if (op->addr.nbytes) {
+		ccr |= FIELD_PREP(CCR_ADMODE_MASK,
+				  stm32_ospi_get_mode(op->addr.buswidth));
+		ccr |= FIELD_PREP(CCR_ADSIZE_MASK, op->addr.nbytes - 1);
+	}
+
+	if (flash->sample_later)
+		tcr |= TCR_SSHIFT;
+
+	if (op->dummy.buswidth && op->dummy.nbytes) {
+		u8 dcyc = op->dummy.nbytes * 8 / op->dummy.buswidth;
+
+		if (op->dummy.dtr)
+			dcyc /= 2;
+
+		tcr |= FIELD_PREP(TCR_DCYC_MASK, dcyc);
+	}
+
+	writel_relaxed(tcr, regs_base + OSPI_TCR);
+
+	if (op->data.nbytes)
+		ccr |= FIELD_PREP(CCR_DMODE_MASK,
+				  stm32_ospi_get_mode(op->data.buswidth));
+
+	writel_relaxed(ccr, regs_base + OSPI_CCR);
+
+	writel_relaxed(op->cmd.opcode, regs_base + OSPI_IR);
+
+	if (op->addr.nbytes && omi->fmode != CR_FMODE_MM)
+		writel_relaxed(addr, regs_base + OSPI_AR);
+
+	if (omi->fmode == CR_FMODE_APM)
+		err_poll_status = stm32_ospi_wait_poll_status(ospi, op);
+
+	err = stm32_ospi_tx(ospi, op);
+
+	/*
+	 * Abort in:
+	 * -error case
+	 * -read memory map: prefetching must be stopped if we read the last
+	 *  byte of device (device size - fifo size). like device size is not
+	 *  knows, the prefetching is always stop.
+	 */
+	if (err || err_poll_status || omi->fmode == CR_FMODE_MM)
+		goto abort;
+
+	/* Wait end of tx in indirect mode */
+	err = stm32_omi_wait_cmd(omi);
+	if (err)
+		goto abort;
+
+	return 0;
+
+abort:
+	timeout = stm32_omi_abort(omi);
+	writel_relaxed(FCR_CTCF | FCR_CSMF, regs_base + OSPI_FCR);
+
+	if (!omi->calibration && (err || err_poll_status || timeout))
+		dev_err(ospi->dev, "%s err:%d err_poll_status:%d abort timeout:%d\n",
+			__func__, err, err_poll_status, timeout);
+
+	return err;
+}
+
+static int stm32_ospi_readid(struct stm32_omi *omi)
+{
+	struct stm32_ospi *ospi = platform_get_drvdata(omi->vdev);
+	struct stm32_ospi_flash *flash = &ospi->flash[ospi->last_cs];
+	struct spi_device *spi = flash->spi;
+	u64 *rx_buf = &ospi->id_buf;
+	struct spi_mem_op readid_op;
+	int ret;
+
+	omi->fmode = CR_FMODE_INDR;
+
+	if (flash->is_str_calibration) {
+		u8 nb_dummy_bytes = flash->is_spi_nor ? 0 : 1;
+
+		readid_op = (struct spi_mem_op)
+			    SPI_MEM_OP(SPI_MEM_OP_CMD(0x9f, 1),
+				       SPI_MEM_OP_NO_ADDR,
+				       SPI_MEM_OP_DUMMY(nb_dummy_bytes, 1),
+				       SPI_MEM_OP_DATA_IN(sizeof(*rx_buf),
+							  (u8 *)rx_buf, 1));
+	} else {
+		if (flash->octal_dtr && flash->is_spi_nor) {
+			u16 opcode;
+			u8 nb_addr_bytes;
+			u8 nb_dummy_bytes;
+
+			if ((flash->dtr_idcode & 0xff) == MACRONIX_ID) {
+				opcode = 0x9f60;
+				nb_addr_bytes = 4;
+				nb_dummy_bytes = 8;
+			} else {
+				/*
+				 * All memory providers are not currently
+				 * supported, feel free to add them
+				 */
+				return -EOPNOTSUPP;
+			}
+
+			readid_op = (struct spi_mem_op)
+				    SPI_MEM_OP(SPI_MEM_OP_CMD(opcode, 8),
+					       SPI_MEM_OP_ADDR(nb_addr_bytes, 0, 8),
+					       SPI_MEM_OP_DUMMY(nb_dummy_bytes, 8),
+					       SPI_MEM_OP_DATA_IN(sizeof(*rx_buf),
+								  (u8 *)rx_buf, 8));
+			readid_op.cmd.dtr = true;
+			readid_op.addr.dtr = true;
+			readid_op.dummy.dtr = true;
+			readid_op.data.dtr = true;
+			readid_op.cmd.nbytes = 2;
+		} else {
+			/*
+			 * Only OCTAL DTR calibration on SPI NOR devices
+			 * is currently supported
+			 */
+			return -EOPNOTSUPP;
+		}
+	}
+
+	if (spi->cs_gpiod)
+		gpiod_set_value_cansleep(spi->cs_gpiod, true);
+
+	ret = stm32_ospi_send(spi, &readid_op);
+
+	if (spi->cs_gpiod)
+		gpiod_set_value_cansleep(spi->cs_gpiod, false);
+
+	if (ret)
+		return ret;
+
+	dev_dbg(ospi->dev, "Flash ID 0x%08llx\n", *rx_buf);
+
+	if (flash->is_str_calibration) {
+		/*
+		 * On stm32_ospi_readid() first execution, save the golden
+		 * read id
+		 */
+		if (!flash->str_idcode) {
+			flash->str_idcode = *rx_buf;
+
+			if (flash->is_spi_nor) {
+				/* Build DTR id code */
+				if ((*rx_buf & 0xff) == MACRONIX_ID) {
+					/*
+					 * Retrieve odd array and re-sort id
+					 * because of read id format will be
+					 * A-A-B-B-C-C after enter into octal
+					 * dtr mode for Macronix flashes.
+					 */
+					flash->dtr_idcode = *rx_buf & 0xff;
+					flash->dtr_idcode |= (*rx_buf & 0xff) << 8;
+					flash->dtr_idcode |= (*rx_buf & 0xff00) << 8;
+					flash->dtr_idcode |= (*rx_buf & 0xff00) << 16;
+					flash->dtr_idcode |= (*rx_buf & 0xff0000) << 16;
+					flash->dtr_idcode |= (*rx_buf & 0xff0000) << 24;
+					flash->dtr_idcode |= (*rx_buf & 0xff000000) << 24;
+					flash->dtr_idcode |= (*rx_buf & 0xff000000) << 32;
+				} else {
+					flash->dtr_idcode = *rx_buf;
+				}
+			}
+		}
+
+		if (*rx_buf == flash->str_idcode)
+			return 0;
+	} else if (*rx_buf == flash->dtr_idcode) {
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static int stm32_ospi_str_calibration(struct stm32_ospi *ospi)
+{
+	struct stm32_omi *omi = ospi->omi;
+	struct stm32_ospi_flash *flash = &ospi->flash[ospi->last_cs];
+	struct spi_device *spi = flash->spi;
+	void __iomem *regs_base = omi->regs_base;
+	u32 bus_freq;
+	u8 window_len_tcr0 = 0, window_len_tcr1 = 0;
+	int ret, ret_tcr0, ret_tcr1;
+
+	/*
+	 * Set memory device at low frequency (50MHz) and sent
+	 * READID (0x9F) command, save the answer as golden answer
+	 */
+	flash->presc = DIV_ROUND_UP(omi->clk_rate,
+				    STM32_DLYB_FREQ_THRESHOLD) - 1;
+	stm32_ospi_set_prescaler(ospi, flash->presc);
+
+	ret = stm32_ospi_readid(omi);
+	if (ret)
+		return ret;
+
+	/*
+	 * Set memory device at expected frequency read from DT
+	 * prescaler should be set before locking the DLL
+	 */
+	flash->presc = DIV_ROUND_UP(omi->clk_rate, spi->max_speed_hz) - 1;
+	stm32_ospi_set_prescaler(ospi, flash->presc);
+	bus_freq = DIV_ROUND_UP(omi->clk_rate, flash->presc + 1);
+
+	/* Calibration needed above 50MHz */
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD)
+		return 0;
+
+	flash->dcr_reg &= ~DCR1_DLYBYP;
+	writel_relaxed(flash->dcr_reg, regs_base + OSPI_DCR1);
+
+	ret = stm32_omi_dlyb_init(omi, false, 0);
+	if (ret)
+		return ret;
+
+	/*
+	 * Perform only Rx TAP selection
+	 * When DTR support will be added, Rx/Tx TAP selection will have to
+	 * be performed
+	 */
+	ret_tcr0 = stm32_omi_dlyb_find_tap(omi, true, &window_len_tcr0);
+	if (!ret_tcr0)
+		/*
+		 * Save flash delay block configuration, will be restored
+		 * each time this flash is addressed
+		 */
+		stm32_omi_dlyb_get_cr(omi, &flash->dlyb_cr_str);
+
+	stm32_omi_dlyb_stop(omi);
+	ret = stm32_omi_dlyb_init(omi, false, 0);
+	if (ret)
+		return ret;
+
+	flash->sample_later = true;
+	ret_tcr1 = stm32_omi_dlyb_find_tap(omi, true, &window_len_tcr1);
+	if (ret_tcr0 && ret_tcr1) {
+		dev_info(ospi->dev, "Calibration phase failed\n");
+		return ret_tcr0;
+	}
+
+	if (window_len_tcr0 >= window_len_tcr1) {
+		flash->sample_later = false;
+		stm32_omi_dlyb_stop(omi);
+
+		ret = stm32_omi_dlyb_set_cr(omi, flash->dlyb_cr_str);
+		if (ret)
+			return ret;
+	} else {
+		stm32_omi_dlyb_get_cr(omi, &flash->dlyb_cr_str);
+	}
+
+	flash->str_sample_later = flash->sample_later;
+
+	return 0;
+}
+
+static int stm32_ospi_dtr_calibration(struct stm32_ospi *ospi)
+{
+	struct stm32_omi *omi = ospi->omi;
+	struct stm32_ospi_flash *flash = &ospi->flash[ospi->last_cs];
+	void __iomem *regs_base = omi->regs_base;
+	u32 prescaler, bus_freq;
+	u16 period_ps = 0;
+	u8 window_len = 0;
+	int ret;
+	bool bypass_mode = false;
+
+	flash->dcr_reg &= ~DCR1_DLYBYP;
+	writel_relaxed(flash->dcr_reg, regs_base + OSPI_DCR1);
+
+	prescaler = FIELD_GET(DCR2_PRESC_MASK,
+			      readl(regs_base + OSPI_DCR2));
+	bus_freq = DIV_ROUND_UP(omi->clk_rate, prescaler + 1);
+
+	if (prescaler)
+		writel_relaxed(TCR_DHQC, regs_base + OSPI_TCR);
+
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (bus_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_init(omi, bypass_mode, period_ps);
+	if (ret) {
+		dev_err(ospi->dev, "Can't enable delay block\n");
+		return 0;
+	}
+
+	if (bypass_mode || prescaler)
+		/* Perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(omi, true, &window_len);
+	else
+		/* Perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(omi, false, &window_len);
+
+	if (ret) {
+		dev_err(ospi->dev, "Calibration failed\n");
+		if (!bypass_mode)
+			/* Stop delay block when configured in lock mode */
+			stm32_omi_dlyb_stop(omi);
+	} else {
+		stm32_omi_dlyb_get_cr(omi, &flash->dlyb_cr_dtr);
+		flash->dtr_calibration_done_once = true;
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_prepare_to_send(struct spi_device *spi,
+				      const struct spi_mem_op *op)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(spi->master);
+	struct stm32_ospi_flash *flash = &ospi->flash[spi->chip_select];
+	struct stm32_omi *omi = ospi->omi;
+	int ret = 0;
+	bool set_dlyb = false;
+
+	if (ospi->last_cs != spi->chip_select) {
+		ospi->last_cs = spi->chip_select;
+
+		stm32_omi_dlyb_stop(omi);
+		stm32_ospi_set_prescaler(ospi, flash->presc);
+		set_dlyb = true;
+	};
+
+	if (op->cmd.dtr && !flash->dtr_calibration_done_once) {
+		stm32_omi_dlyb_stop(omi);
+		flash->sample_later = false;
+		flash->octal_dtr = (op->cmd.nbytes == 2);
+
+		ret = stm32_ospi_dtr_calibration(ospi);
+		if (ret)
+			return ret;
+
+		flash->dtr_mode = true;
+	}
+
+	/*
+	 * if flash is switched from DTR to STR or from STR to DTR
+	 * restore the correct calibration value
+	 */
+	if ((flash->dtr_mode && !op->cmd.dtr) ||
+	    (!flash->dtr_mode && op->cmd.dtr)) {
+		flash->dtr_mode = !flash->dtr_mode;
+		stm32_omi_dlyb_stop(omi);
+		set_dlyb = true;
+	}
+
+	/*
+	 * restore DLYB CR register depending on simple or
+	 * double transfer rate
+	 */
+	if (set_dlyb) {
+		if (op->cmd.dtr) {
+			ret = stm32_omi_dlyb_set_cr(omi, flash->dlyb_cr_dtr);
+			flash->sample_later = false;
+			flash->octal_dtr = (op->cmd.nbytes == 2);
+		} else {
+			ret = stm32_omi_dlyb_set_cr(omi, flash->dlyb_cr_str);
+			flash->sample_later = flash->str_sample_later;
+			flash->octal_dtr = false;
+		}
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_poll_status(struct spi_mem *mem,
+				  const struct spi_mem_op *op,
+				  u16 mask, u16 match,
+				  unsigned long initial_delay_us,
+				  unsigned long polling_rate_us,
+				  unsigned long timeout_ms)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(mem->spi->master);
+	struct stm32_omi *omi = ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&ospi->lock);
+	writel_relaxed(mask, regs_base + OSPI_PSMKR);
+	writel_relaxed(match, regs_base + OSPI_PSMAR);
+	omi->fmode = CR_FMODE_APM;
+	ospi->status_timeout = timeout_ms;
+
+	ret = stm32_ospi_prepare_to_send(mem->spi, op);
+	if (!ret)
+		ret = stm32_ospi_send(mem->spi, op);
+
+	mutex_unlock(&ospi->lock);
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return ret;
+}
+
+static int stm32_ospi_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(mem->spi->master);
+	struct stm32_omi *omi = ospi->omi;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&ospi->lock);
+	if (op->data.dir == SPI_MEM_DATA_IN && op->data.nbytes)
+		omi->fmode = CR_FMODE_INDR;
+	else
+		omi->fmode = CR_FMODE_INDW;
+
+	ret = stm32_ospi_prepare_to_send(mem->spi, op);
+	if (!ret)
+		ret = stm32_ospi_send(mem->spi, op);
+
+	mutex_unlock(&ospi->lock);
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return ret;
+}
+
+static int stm32_ospi_dirmap_create(struct spi_mem_dirmap_desc *desc)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(desc->mem->spi->master);
+	struct stm32_omi *omi = ospi->omi;
+
+	if (desc->info.op_tmpl.data.dir == SPI_MEM_DATA_OUT)
+		return -EOPNOTSUPP;
+
+	/* Should never happen, as mm_base == null is an error probe exit condition */
+	if (!omi->mm_base && desc->info.op_tmpl.data.dir == SPI_MEM_DATA_IN)
+		return -EOPNOTSUPP;
+
+	if (!omi->mm_size)
+		return -EOPNOTSUPP;
+
+	return 0;
+}
+
+static ssize_t stm32_ospi_dirmap_read(struct spi_mem_dirmap_desc *desc,
+				      u64 offs, size_t len, void *buf)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(desc->mem->spi->master);
+	struct stm32_omi *omi = ospi->omi;
+	struct spi_mem_op op;
+	u32 addr_max;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&ospi->lock);
+	/*
+	 * Make a local copy of desc op_tmpl and complete dirmap rdesc
+	 * spi_mem_op template with offs, len and *buf in  order to get
+	 * all needed transfer information into struct spi_mem_op
+	 */
+	memcpy(&op, &desc->info.op_tmpl, sizeof(struct spi_mem_op));
+	dev_dbg(ospi->dev, "%s len = 0x%zx offs = 0x%llx buf = 0x%p\n", __func__, len, offs, buf);
+
+	op.data.nbytes = len;
+	op.addr.val = desc->info.offset + offs;
+	op.data.buf.in = buf;
+
+	addr_max = op.addr.val + op.data.nbytes + 1;
+	if (addr_max < omi->mm_size && op.addr.buswidth)
+		omi->fmode = CR_FMODE_MM;
+	else
+		omi->fmode = CR_FMODE_INDR;
+
+	ret = stm32_ospi_prepare_to_send(desc->mem->spi, &op);
+	if (!ret)
+		ret = stm32_ospi_send(desc->mem->spi, &op);
+
+	mutex_unlock(&ospi->lock);
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return ret ?: len;
+}
+
+static int stm32_ospi_transfer_one_message(struct spi_controller *ctrl,
+					   struct spi_message *msg)
+{
+	struct stm32_ospi *ospi = spi_controller_get_devdata(ctrl);
+	struct stm32_omi *omi = ospi->omi;
+	struct spi_transfer *transfer;
+	struct spi_device *spi = msg->spi;
+	struct spi_mem_op op;
+	int ret = 0;
+
+	if (!spi->cs_gpiod)
+		return -EOPNOTSUPP;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&ospi->lock);
+
+	gpiod_set_value_cansleep(spi->cs_gpiod, true);
+
+	list_for_each_entry(transfer, &msg->transfers, transfer_list) {
+		u8 dummy_bytes = 0;
+
+		memset(&op, 0, sizeof(op));
+
+		dev_dbg(ospi->dev, "tx_buf:%p tx_nbits:%d rx_buf:%p rx_nbits:%d len:%d dummy_data:%d\n",
+			transfer->tx_buf, transfer->tx_nbits,
+			transfer->rx_buf, transfer->rx_nbits,
+			transfer->len, transfer->dummy_data);
+
+		/*
+		 * OSPI hardware supports dummy bytes transfer.
+		 * If current transfer is dummy byte, merge it with the next
+		 * transfer in order to take into account OSPI block constraint
+		 */
+		if (transfer->dummy_data) {
+			op.dummy.buswidth = transfer->tx_nbits;
+			op.dummy.nbytes = transfer->len;
+			dummy_bytes = transfer->len;
+
+			/* If happens, means that message is not correctly built */
+			if (list_is_last(&transfer->transfer_list, &msg->transfers)) {
+				ret = -EINVAL;
+				goto end_of_transfer;
+			}
+
+			transfer = list_next_entry(transfer, transfer_list);
+		}
+
+		op.data.nbytes = transfer->len;
+
+		if (transfer->rx_buf) {
+			omi->fmode = CR_FMODE_INDR;
+			op.data.buswidth = transfer->rx_nbits;
+			op.data.dir = SPI_MEM_DATA_IN;
+			op.data.buf.in = transfer->rx_buf;
+		} else {
+			omi->fmode = CR_FMODE_INDW;
+			op.data.buswidth = transfer->tx_nbits;
+			op.data.dir = SPI_MEM_DATA_OUT;
+			op.data.buf.out = transfer->tx_buf;
+		}
+
+		ret = stm32_ospi_prepare_to_send(spi, &op);
+		if (ret)
+			goto end_of_transfer;
+
+		ret = stm32_ospi_send(spi, &op);
+		if (ret)
+			goto end_of_transfer;
+
+		msg->actual_length += transfer->len + dummy_bytes;
+	}
+
+end_of_transfer:
+	gpiod_set_value_cansleep(spi->cs_gpiod, false);
+
+	mutex_unlock(&ospi->lock);
+
+	msg->status = ret;
+	spi_finalize_current_message(ctrl);
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return ret;
+}
+
+static int stm32_ospi_setup(struct spi_device *spi)
+{
+	struct spi_controller *ctrl = spi->master;
+	struct stm32_ospi *ospi = spi_controller_get_devdata(ctrl);
+	struct stm32_omi *omi = ospi->omi;
+	struct stm32_ospi_flash *flash;
+	void __iomem *regs_base = omi->regs_base;
+	u32 bus_freq;
+	int ret;
+
+	if (ctrl->busy)
+		return -EBUSY;
+
+	if (!spi->max_speed_hz)
+		return -EINVAL;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	flash = &ospi->flash[spi->chip_select];
+	flash->presc = DIV_ROUND_UP(omi->clk_rate, spi->max_speed_hz) - 1;
+	flash->spi = spi;
+
+	mutex_lock(&ospi->lock);
+
+	ospi->cr_reg = CR_APMS | 3 << CR_FTHRES_SHIFT | CR_EN;
+	writel_relaxed(ospi->cr_reg, regs_base + OSPI_CR);
+
+	/* Stop the DLL */
+	stm32_omi_dlyb_stop(omi);
+
+	/* Set dcr fsize to max address */
+	flash->dcr_reg = DCR1_DEVSIZE_MASK | DCR1_DLYBYP;
+	writel_relaxed(flash->dcr_reg, regs_base + OSPI_DCR1);
+
+	stm32_ospi_set_prescaler(ospi, flash->presc);
+
+	ospi->last_cs = spi->chip_select;
+	if (flash->is_octal_bus) {
+		if (gpiod_count(omi->dev, "cs") == -ENOENT) {
+			dev_err(omi->dev, "Can't find cs-gpio property in DT\n");
+
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		bus_freq = DIV_ROUND_UP(omi->clk_rate, flash->presc + 1);
+		if (bus_freq > STM32_DLYB_FREQ_THRESHOLD) {
+			dev_err(ospi->dev, "Octal bus mode not supported above %d Hz)\n",
+				STM32_DLYB_FREQ_THRESHOLD);
+
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		flash->is_str_calibration = true;
+
+		ret = stm32_ospi_str_calibration(ospi);
+		if (ret) {
+			ret = 0;
+
+			dev_info(ospi->dev, "Set flash frequency to a safe value (%d Hz)\n",
+				 STM32_DLYB_FREQ_THRESHOLD);
+
+			/* Stop the DLL */
+			stm32_omi_dlyb_stop(omi);
+			flash->sample_later = false;
+
+			flash->presc = DIV_ROUND_UP(omi->clk_rate,
+						    STM32_DLYB_FREQ_THRESHOLD) - 1;
+			stm32_ospi_set_prescaler(ospi, flash->presc);
+
+			flash->dcr_reg |= DCR1_DLYBYP;
+			writel_relaxed(flash->dcr_reg, regs_base + OSPI_DCR1);
+		}
+
+		flash->is_str_calibration = false;
+	}
+
+exit:
+	mutex_unlock(&ospi->lock);
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return ret;
+}
+
+static bool stm32_ospi_supports_mem_op(struct spi_mem *mem,
+				       const struct spi_mem_op *op)
+{
+	bool all_true, all_false;
+
+	/*
+	 * Op->dummy.dtr is required for converting nbytes into ncycles.
+	 * Also, don't check the dtr field of the op phase having zero nbytes.
+	 */
+	all_true = op->cmd.dtr &&
+		   (!op->addr.nbytes || op->addr.dtr) &&
+		   (!op->dummy.nbytes || op->dummy.dtr) &&
+		   (!op->data.nbytes || op->data.dtr);
+
+	all_false = !op->cmd.dtr && !op->addr.dtr && !op->dummy.dtr &&
+		    !op->data.dtr;
+
+	if (all_true) {
+		/* Right now we only support 8-8-8 DTR mode. */
+		if (op->cmd.nbytes && op->cmd.buswidth != 8)
+			return false;
+		if (op->addr.nbytes && op->addr.buswidth != 8)
+			return false;
+		if (op->data.nbytes && op->data.buswidth != 8)
+			return false;
+	} else if (!all_false) {
+		/* Mixed DTR modes are not supported. */
+		return false;
+	}
+
+	if (op->data.buswidth > 8 || op->addr.buswidth > 8 ||
+	    op->dummy.buswidth > 8 || op->cmd.buswidth > 8)
+		return false;
+
+	if (op->cmd.nbytes > 4 || op->addr.nbytes > 4)
+		return false;
+
+	if ((!op->dummy.dtr && op->dummy.nbytes > 32) ||
+	    (op->dummy.dtr && op->dummy.nbytes > 64))
+		return false;
+
+	return spi_mem_default_supports_op(mem, op);
+}
+
+/*
+ * No special host constraint, so use default spi_mem_default_supports_op
+ * to check supported mode.
+ */
+static const struct spi_controller_mem_ops stm32_ospi_mem_ops = {
+	.exec_op = stm32_ospi_exec_op,
+	.dirmap_create = stm32_ospi_dirmap_create,
+	.dirmap_read = stm32_ospi_dirmap_read,
+	.poll_status = stm32_ospi_poll_status,
+	.supports_op = stm32_ospi_supports_mem_op,
+};
+
+static const struct spi_controller_mem_caps stm32_ospi_mem_caps = {
+	.dtr = true,
+	.dtr_swab16 = true,
+};
+
+static int stm32_ospi_probe(struct platform_device *pdev)
+{
+	struct device *parent = pdev->dev.parent;
+	struct device *dev = &pdev->dev;
+	struct spi_controller *ctrl;
+	struct stm32_ospi *ospi;
+	struct stm32_omi *omi = dev_get_drvdata(parent);
+	struct dma_slave_config dma_cfg;
+	struct device_node *child;
+	int ret;
+
+	ctrl = devm_spi_alloc_master(dev, sizeof(*ospi));
+	if (!ctrl)
+		return -ENOMEM;
+
+	ospi = spi_controller_get_devdata(ctrl);
+	ospi->ctrl = ctrl;
+	ospi->omi = omi;
+	omi->check_transfer = stm32_ospi_readid;
+
+	ospi->dev = &pdev->dev;
+	platform_set_drvdata(pdev, ospi);
+
+	memset(&dma_cfg, 0, sizeof(dma_cfg));
+	dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	dma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	dma_cfg.src_addr = omi->regs_phys_base + OSPI_DR;
+	dma_cfg.dst_addr = omi->regs_phys_base + OSPI_DR;
+	dma_cfg.src_maxburst = 4;
+	dma_cfg.dst_maxburst = 4;
+	stm32_omi_dma_setup(omi, &dma_cfg);
+
+	mutex_init(&ospi->lock);
+
+	ctrl->mode_bits = SPI_RX_DUAL | SPI_RX_QUAD |
+			  SPI_TX_DUAL | SPI_TX_QUAD |
+			  SPI_TX_OCTAL | SPI_RX_OCTAL;
+	ctrl->setup = stm32_ospi_setup;
+	ctrl->bus_num = -1;
+	ctrl->mem_ops = &stm32_ospi_mem_ops;
+	ctrl->mem_caps = &stm32_ospi_mem_caps;
+	ctrl->use_gpio_descriptors = true;
+	ctrl->transfer_one_message = stm32_ospi_transfer_one_message;
+	ctrl->num_chipselect = STM32_OMI_MAX_NORCHIP;
+	ctrl->dev.of_node = parent->of_node;
+
+	pm_runtime_enable(omi->dev);
+	pm_runtime_set_autosuspend_delay(omi->dev, STM32_AUTOSUSPEND_DELAY);
+	pm_runtime_use_autosuspend(omi->dev);
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		goto err_pm_enable;
+
+	if (omi->rstc) {
+		reset_control_assert(omi->rstc);
+		udelay(2);
+		reset_control_deassert(omi->rstc);
+	}
+
+	/* Find memory model on each child node (SPI NOR or SPI NAND) */
+	for_each_available_child_of_node(omi->dev->of_node, child) {
+		u32 cs;
+
+		ret = of_property_read_u32(child, "reg", &cs);
+		if (ret) {
+			dev_err(ospi->dev, "could not retrieve reg property: %d\n",
+				ret);
+			of_node_put(child);
+			goto err_pm_resume;
+		}
+
+		if (cs >= STM32_OMI_MAX_NORCHIP) {
+			dev_err(ospi->dev, "invalid reg value: %d\n", cs);
+			of_node_put(child);
+			ret = -EINVAL;
+			goto err_pm_resume;
+		}
+
+		if (of_device_is_compatible(child, "jedec,spi-nor")) {
+			struct stm32_ospi_flash *flash = &ospi->flash[cs];
+
+			flash->is_spi_nor = true;
+		}
+
+		if (of_device_is_compatible(child, "st,octal-bus")) {
+			struct stm32_ospi_flash *flash = &ospi->flash[cs];
+
+			flash->is_octal_bus = true;
+		}
+	}
+
+	ret = spi_register_master(ctrl);
+	if (ret) {
+		/* Disable ospi */
+		writel_relaxed(0, omi->regs_base + OSPI_CR);
+		goto err_pm_resume;
+	}
+
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return 0;
+
+err_pm_resume:
+	pm_runtime_put_sync_suspend(omi->dev);
+
+err_pm_enable:
+	pm_runtime_force_suspend(omi->dev);
+	mutex_destroy(&ospi->lock);
+
+	return ret;
+}
+
+static int stm32_ospi_remove(struct platform_device *pdev)
+{
+	struct stm32_ospi *ospi = platform_get_drvdata(pdev);
+	struct stm32_omi *omi = ospi->omi;
+	int ret;
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	spi_unregister_master(ospi->ctrl);
+	/* Disable ospi */
+	writel_relaxed(0, omi->regs_base + OSPI_CR);
+	stm32_omi_dlyb_stop(omi);
+	mutex_destroy(&ospi->lock);
+	pm_runtime_put_sync_suspend(omi->dev);
+	pm_runtime_force_suspend(omi->dev);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_ospi_suspend(struct device *dev)
+{
+	struct stm32_ospi *ospi = dev_get_drvdata(dev);
+	struct stm32_omi *omi = ospi->omi;
+
+	pinctrl_pm_select_sleep_state(dev);
+
+	return pm_runtime_force_suspend(omi->dev);
+}
+
+static int __maybe_unused stm32_ospi_resume(struct device *dev)
+{
+	struct stm32_ospi *ospi = dev_get_drvdata(dev);
+	struct stm32_omi *omi = ospi->omi;
+	void __iomem *regs_base = omi->regs_base;
+	int ret;
+
+	ret = pm_runtime_force_resume(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	pinctrl_pm_select_default_state(dev);
+
+	ret = pm_runtime_resume_and_get(omi->dev);
+	if (ret < 0)
+		return ret;
+
+	writel_relaxed(ospi->cr_reg, regs_base + OSPI_CR);
+	ospi->last_cs = -1;
+	pm_runtime_mark_last_busy(omi->dev);
+	pm_runtime_put_autosuspend(omi->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops stm32_ospi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stm32_ospi_suspend, stm32_ospi_resume)
+};
+
+static struct platform_driver stm32_ospi_driver = {
+	.probe	= stm32_ospi_probe,
+	.remove	= stm32_ospi_remove,
+	.driver	= {
+		.name = "stm32-ospi",
+		.pm = &stm32_ospi_pm_ops,
+	},
+};
+module_platform_driver(stm32_ospi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics STM32 OCTO SPI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-stm32.c b/drivers/spi/spi-stm32.c
index 122418155..df80c39d2 100644
--- a/drivers/spi/spi-stm32.c
+++ b/drivers/spi/spi-stm32.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 //
-// STMicroelectronics STM32 SPI Controller driver (master mode only)
+// STMicroelectronics STM32 SPI Controller driver
 //
 // Copyright (C) 2017, STMicroelectronics - All Rights Reserved
 // Author(s): Amelie Delaunay <amelie.delaunay@st.com> for STMicroelectronics.
@@ -18,6 +18,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/reset.h>
 #include <linux/spi/spi.h>
+#include <dt-bindings/spi/spi-stm32.h>
 
 #define DRIVER_NAME "spi_stm32"
 
@@ -84,6 +85,7 @@
 #define STM32H7_SPI_IFCR		0x18
 #define STM32H7_SPI_TXDR		0x20
 #define STM32H7_SPI_RXDR		0x30
+#define STM32H7_SPI_UDRDR		0x4C
 #define STM32H7_SPI_I2SCFGR		0x50
 
 /* STM32H7_SPI_CR1 bit fields */
@@ -101,6 +103,14 @@
 /* STM32H7_SPI_CFG1 bit fields */
 #define STM32H7_SPI_CFG1_DSIZE		GENMASK(4, 0)
 #define STM32H7_SPI_CFG1_FTHLV		GENMASK(8, 5)
+#define STM32H7_SPI_CFG1_UDRDET		GENMASK(12, 11)
+#define STM32H7_SPI_CFG1_UDRDET_BEGIN	0
+#define STM32H7_SPI_CFG1_UDRDET_LAST	1
+#define STM32H7_SPI_CFG1_UDRDET_SS	2
+#define STM32H7_SPI_CFG1_UDRCFG		GENMASK(10, 9)
+#define STM32H7_SPI_CFG1_UDRCFG_PTRN	0
+#define STM32H7_SPI_CFG1_UDRCFG_LAST_R	1
+#define STM32H7_SPI_CFG1_UDRCFG_LAST_T	2
 #define STM32H7_SPI_CFG1_RXDMAEN	BIT(14)
 #define STM32H7_SPI_CFG1_TXDMAEN	BIT(15)
 #define STM32H7_SPI_CFG1_MBR		GENMASK(30, 28)
@@ -117,6 +127,7 @@
 #define STM32H7_SPI_CFG2_CPHA		BIT(24)
 #define STM32H7_SPI_CFG2_CPOL		BIT(25)
 #define STM32H7_SPI_CFG2_SSM		BIT(26)
+#define STM32H7_SPI_CFG2_SSIOP		BIT(28)
 #define STM32H7_SPI_CFG2_AFCNTR		BIT(31)
 
 /* STM32H7_SPI_IER bit fields */
@@ -125,6 +136,7 @@
 #define STM32H7_SPI_IER_DXPIE		BIT(2)
 #define STM32H7_SPI_IER_EOTIE		BIT(3)
 #define STM32H7_SPI_IER_TXTFIE		BIT(4)
+#define STM32H7_SPI_IER_UDRIE		BIT(5)
 #define STM32H7_SPI_IER_OVRIE		BIT(6)
 #define STM32H7_SPI_IER_MODFIE		BIT(9)
 #define STM32H7_SPI_IER_ALL		GENMASK(10, 0)
@@ -133,6 +145,7 @@
 #define STM32H7_SPI_SR_RXP		BIT(0)
 #define STM32H7_SPI_SR_TXP		BIT(1)
 #define STM32H7_SPI_SR_EOT		BIT(3)
+#define STM32H7_SPI_SR_UDR		BIT(5)
 #define STM32H7_SPI_SR_OVR		BIT(6)
 #define STM32H7_SPI_SR_MODF		BIT(9)
 #define STM32H7_SPI_SR_SUSP		BIT(11)
@@ -145,6 +158,23 @@
 /* STM32H7_SPI_I2SCFGR bit fields */
 #define STM32H7_SPI_I2SCFGR_I2SMOD	BIT(0)
 
+/* STM32MP25_SPICFG2 bit fields */
+#define STM32MP25_SPI_CFG2_RDIOM	BIT(13)
+
+/* STM32MP25 SPI registers bit fields */
+#define STM32MP25_SPI_HWCFGR1			0x3F0
+
+/* STM32MP25_SPI_CR2 bit fields */
+#define STM32MP25_SPI_TSIZE_MAX_LIMITED		GENMASK(9, 0)
+
+/* STM32MP25_SPI_HWCFGR1 */
+#define STM32MP25_SPI_HWCFGR1_FULLCFG		GENMASK(27, 24)
+#define STM32MP25_SPI_HWCFGR1_FULLCFG_LIMITED	0x0
+#define STM32MP25_SPI_HWCFGR1_FULLCFG_FULL	0x1
+#define STM32MP25_SPI_HWCFGR1_DSCFG		GENMASK(19, 16)
+#define STM32MP25_SPI_HWCFGR1_DSCFG_16_B	0x0
+#define STM32MP25_SPI_HWCFGR1_DSCFG_32_B	0x1
+
 /* STM32H7 SPI Master Baud Rate min/max divisor */
 #define STM32H7_SPI_MBR_DIV_MIN		(2 << STM32H7_SPI_CFG1_MBR_MIN)
 #define STM32H7_SPI_MBR_DIV_MAX		(2 << STM32H7_SPI_CFG1_MBR_MAX)
@@ -170,6 +200,14 @@
  */
 #define SPI_DMA_MIN_BYTES	16
 
+/* STM32 SPI driver helpers */
+#define STM32_SPI_MASTER_MODE(stm32_spi) (!(stm32_spi)->slave_mode)
+#define STM32_SPI_SLAVE_MODE(stm32_spi) ((stm32_spi)->slave_mode)
+
+static unsigned int polling_limit_us = 30;
+module_param(polling_limit_us, uint, 0664);
+MODULE_PARM_DESC(polling_limit_us, "maximum time in us to run a transfer in polling mode\n");
+
 /**
  * struct stm32_spi_reg - stm32 SPI register & bitfield desc
  * @reg:		register offset
@@ -190,9 +228,12 @@ struct stm32_spi_reg {
  * @cpol: clock polarity register and polarity bit
  * @cpha: clock phase register and phase bit
  * @lsb_first: LSB transmitted first register and bit
+ * @cs_high: chips select active value
  * @br: baud rate register and bitfields
  * @rx: SPI RX data register
  * @tx: SPI TX data register
+ * @fullcfg: SPI full or limited feature set register
+ * @rdy_en: SPI ready feature register
  */
 struct stm32_spi_regspec {
 	const struct stm32_spi_reg en;
@@ -201,9 +242,12 @@ struct stm32_spi_regspec {
 	const struct stm32_spi_reg cpol;
 	const struct stm32_spi_reg cpha;
 	const struct stm32_spi_reg lsb_first;
+	const struct stm32_spi_reg cs_high;
 	const struct stm32_spi_reg br;
 	const struct stm32_spi_reg rx;
 	const struct stm32_spi_reg tx;
+	const struct stm32_spi_reg fullcfg;
+	const struct stm32_spi_reg rdy_en;
 };
 
 struct stm32_spi;
@@ -226,12 +270,16 @@ struct stm32_spi;
  * @dma_rx_cb: routine to call after DMA RX channel operation is complete
  * @dma_tx_cb: routine to call after DMA TX channel operation is complete
  * @transfer_one_irq: routine to configure interrupts for driver
+ * @transfer_one_poll: routine to perform a transfer via register polling
  * @irq_handler_event: Interrupt handler for SPI controller events
  * @irq_handler_thread: thread of interrupt handler for SPI controller
  * @baud_rate_div_min: minimum baud rate divisor
  * @baud_rate_div_max: maximum baud rate divisor
  * @has_fifo: boolean to know if fifo is used for driver
  * @flags: compatible specific SPI controller flags used at registration time
+ * @set_slave_udr: routine to configure registers to desired slave underrun
+ * behavior (if driver has this functionality)
+ * @prevent_dma_burst: boolean to indicate to prevent DMA burst
  */
 struct stm32_spi_cfg {
 	const struct stm32_spi_regspec *regs;
@@ -247,18 +295,21 @@ struct stm32_spi_cfg {
 	void (*dma_rx_cb)(void *data);
 	void (*dma_tx_cb)(void *data);
 	int (*transfer_one_irq)(struct stm32_spi *spi);
+	int (*transfer_one_poll)(struct stm32_spi *spi);
 	irqreturn_t (*irq_handler_event)(int irq, void *dev_id);
 	irqreturn_t (*irq_handler_thread)(int irq, void *dev_id);
 	unsigned int baud_rate_div_min;
 	unsigned int baud_rate_div_max;
 	bool has_fifo;
 	u16 flags;
+	void (*set_slave_udr)(struct stm32_spi *spi);
+	bool prevent_dma_burst;
 };
 
 /**
  * struct stm32_spi - private data of the SPI controller
  * @dev: driver model representation of the controller
- * @master: controller master interface
+ * @ctrl: controller interface
  * @cfg: compatible configuration data
  * @base: virtual memory area
  * @clk: hw kernel clock feeding the SPI clock generator
@@ -266,6 +317,8 @@ struct stm32_spi_cfg {
  * @lock: prevent I/O concurrent access
  * @irq: SPI controller interrupt line
  * @fifo_size: size of the embedded fifo in bytes
+ * @t_size_max: maximum number of data of one transfer
+ * @feature_set: SPI full or limited feature set
  * @cur_midi: master inter-data idleness in ns
  * @cur_speed: speed configured in Hz
  * @cur_half_period: time of a half bit in us
@@ -281,10 +334,13 @@ struct stm32_spi_cfg {
  * @dma_tx: dma channel for TX transfer
  * @dma_rx: dma channel for RX transfer
  * @phys_addr: SPI registers physical base address
+ * @slave_mode: the controller is configured as SPI slave
+ * @slave_udr_mode: slave underrun behavior
+ * @slave_udr_pattern: slave underrun pattern parameter
  */
 struct stm32_spi {
 	struct device *dev;
-	struct spi_master *master;
+	struct spi_controller *ctrl;
 	const struct stm32_spi_cfg *cfg;
 	void __iomem *base;
 	struct clk *clk;
@@ -292,6 +348,10 @@ struct stm32_spi {
 	spinlock_t lock; /* prevent I/O concurrent access */
 	int irq;
 	unsigned int fifo_size;
+	unsigned int t_size_max;
+	unsigned int feature_set;
+#define STM32_SPI_FEATURE_LIMITED	STM32MP25_SPI_HWCFGR1_FULLCFG_LIMITED	/* 0x0 */
+#define STM32_SPI_FEATURE_FULL		STM32MP25_SPI_HWCFGR1_FULLCFG_FULL	/* 0x1 */
 
 	unsigned int cur_midi;
 	unsigned int cur_speed;
@@ -309,6 +369,10 @@ struct stm32_spi {
 	struct dma_chan *dma_tx;
 	struct dma_chan *dma_rx;
 	dma_addr_t phys_addr;
+
+	bool slave_mode;
+	u32 slave_udr_mode;
+	u32 slave_udr_pattern;
 };
 
 static const struct stm32_spi_regspec stm32f4_spi_regspec = {
@@ -320,10 +384,15 @@ static const struct stm32_spi_regspec stm32f4_spi_regspec = {
 	.cpol = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_CPOL },
 	.cpha = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_CPHA },
 	.lsb_first = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_LSBFRST },
+	.cs_high = {},
 	.br = { STM32F4_SPI_CR1, STM32F4_SPI_CR1_BR, STM32F4_SPI_CR1_BR_SHIFT },
 
 	.rx = { STM32F4_SPI_DR },
 	.tx = { STM32F4_SPI_DR },
+
+	.fullcfg = {},
+
+	.rdy_en = {},
 };
 
 static const struct stm32_spi_regspec stm32h7_spi_regspec = {
@@ -338,11 +407,40 @@ static const struct stm32_spi_regspec stm32h7_spi_regspec = {
 	.cpol = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPOL },
 	.cpha = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPHA },
 	.lsb_first = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_LSBFRST },
+	.cs_high = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_SSIOP },
 	.br = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_MBR,
 		STM32H7_SPI_CFG1_MBR_SHIFT },
 
 	.rx = { STM32H7_SPI_RXDR },
 	.tx = { STM32H7_SPI_TXDR },
+
+	.fullcfg = {},
+
+	.rdy_en = {},
+};
+
+static const struct stm32_spi_regspec stm32mp25_spi_regspec = {
+	/* SPI data transfer is enabled but spi_ker_ck is idle.
+	 * CFG1 and CFG2 registers are write protected when SPE is enabled.
+	 */
+	.en = { STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE },
+
+	.dma_rx_en = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_RXDMAEN },
+	.dma_tx_en = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_TXDMAEN },
+
+	.cpol = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPOL },
+	.cpha = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_CPHA },
+	.lsb_first = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_LSBFRST },
+	.cs_high = { STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_SSIOP },
+	.br = { STM32H7_SPI_CFG1, STM32H7_SPI_CFG1_MBR,
+		STM32H7_SPI_CFG1_MBR_SHIFT },
+
+	.rx = { STM32H7_SPI_RXDR },
+	.tx = { STM32H7_SPI_TXDR },
+
+	.fullcfg = { STM32MP25_SPI_HWCFGR1, STM32MP25_SPI_HWCFGR1_FULLCFG },
+
+	.rdy_en = { STM32H7_SPI_CFG2, STM32MP25_SPI_CFG2_RDIOM },
 };
 
 static inline void stm32_spi_set_bits(struct stm32_spi *spi,
@@ -421,6 +519,28 @@ static int stm32h7_spi_get_bpw_mask(struct stm32_spi *spi)
 	return SPI_BPW_RANGE_MASK(4, max_bpw);
 }
 
+/**
+ * stm32mp25_spi_get_bpw_mask - Return bits per word mask
+ * @spi: pointer to the spi controller data structure
+ */
+static int stm32mp25_spi_get_bpw_mask(struct stm32_spi *spi)
+{
+	u32 dscfg, max_bpw;
+
+	if (spi->feature_set == STM32_SPI_FEATURE_LIMITED) {
+		dev_dbg(spi->dev, "8-bit or 16-bit data frame supported\n");
+		return SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
+	}
+
+	dscfg = FIELD_GET(STM32MP25_SPI_HWCFGR1_DSCFG,
+			  readl_relaxed(spi->base + STM32MP25_SPI_HWCFGR1));
+	max_bpw = 16;
+	if (dscfg == STM32MP25_SPI_HWCFGR1_DSCFG_32_B)
+		max_bpw = 32;
+	dev_dbg(spi->dev, "%d-bit maximum data frame\n", max_bpw);
+	return SPI_BPW_RANGE_MASK(4, max_bpw);
+}
+
 /**
  * stm32_spi_prepare_mbr - Determine baud rate divisor value
  * @spi: pointer to the spi controller data structure
@@ -439,9 +559,9 @@ static int stm32_spi_prepare_mbr(struct stm32_spi *spi, u32 speed_hz,
 	div = DIV_ROUND_CLOSEST(spi->clk_rate & ~0x1, speed_hz);
 
 	/*
-	 * SPI framework set xfer->speed_hz to master->max_speed_hz if
-	 * xfer->speed_hz is greater than master->max_speed_hz, and it returns
-	 * an error when xfer->speed_hz is lower than master->min_speed_hz, so
+	 * SPI framework set xfer->speed_hz to ctrl->max_speed_hz if
+	 * xfer->speed_hz is greater than ctrl->max_speed_hz, and it returns
+	 * an error when xfer->speed_hz is lower than ctrl->min_speed_hz, so
 	 * no need to check it there.
 	 * However, we need to ensure the following calculations.
 	 */
@@ -661,9 +781,9 @@ static void stm32f4_spi_disable(struct stm32_spi *spi)
 	}
 
 	if (spi->cur_usedma && spi->dma_tx)
-		dmaengine_terminate_all(spi->dma_tx);
+		dmaengine_terminate_async(spi->dma_tx);
 	if (spi->cur_usedma && spi->dma_rx)
-		dmaengine_terminate_all(spi->dma_rx);
+		dmaengine_terminate_async(spi->dma_rx);
 
 	stm32_spi_clr_bits(spi, STM32F4_SPI_CR1, STM32F4_SPI_CR1_SPE);
 
@@ -704,9 +824,9 @@ static void stm32h7_spi_disable(struct stm32_spi *spi)
 		udelay(spi->cur_half_period);
 
 	if (spi->cur_usedma && spi->dma_tx)
-		dmaengine_terminate_all(spi->dma_tx);
+		dmaengine_terminate_async(spi->dma_tx);
 	if (spi->cur_usedma && spi->dma_rx)
-		dmaengine_terminate_all(spi->dma_rx);
+		dmaengine_terminate_async(spi->dma_rx);
 
 	stm32_spi_clr_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SPE);
 
@@ -722,19 +842,19 @@ static void stm32h7_spi_disable(struct stm32_spi *spi)
 
 /**
  * stm32_spi_can_dma - Determine if the transfer is eligible for DMA use
- * @master: controller master interface
+ * @ctrl: controller interface
  * @spi_dev: pointer to the spi device
  * @transfer: pointer to spi transfer
  *
  * If driver has fifo and the current transfer size is greater than fifo size,
  * use DMA. Otherwise use DMA for transfer longer than defined DMA min bytes.
  */
-static bool stm32_spi_can_dma(struct spi_master *master,
+static bool stm32_spi_can_dma(struct spi_controller *ctrl,
 			      struct spi_device *spi_dev,
 			      struct spi_transfer *transfer)
 {
 	unsigned int dma_size;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	if (spi->cfg->has_fifo)
 		dma_size = spi->fifo_size;
@@ -750,12 +870,12 @@ static bool stm32_spi_can_dma(struct spi_master *master,
 /**
  * stm32f4_spi_irq_event - Interrupt handler for SPI controller events
  * @irq: interrupt line
- * @dev_id: SPI controller master interface
+ * @dev_id: SPI controller ctrl interface
  */
 static irqreturn_t stm32f4_spi_irq_event(int irq, void *dev_id)
 {
-	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_id;
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	u32 sr, mask = 0;
 	bool end = false;
 
@@ -838,14 +958,14 @@ static irqreturn_t stm32f4_spi_irq_event(int irq, void *dev_id)
 /**
  * stm32f4_spi_irq_thread - Thread of interrupt handler for SPI controller
  * @irq: interrupt line
- * @dev_id: SPI controller master interface
+ * @dev_id: SPI controller interface
  */
 static irqreturn_t stm32f4_spi_irq_thread(int irq, void *dev_id)
 {
-	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_id;
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
-	spi_finalize_current_transfer(master);
+	spi_finalize_current_transfer(ctrl);
 	stm32f4_spi_disable(spi);
 
 	return IRQ_HANDLED;
@@ -854,12 +974,12 @@ static irqreturn_t stm32f4_spi_irq_thread(int irq, void *dev_id)
 /**
  * stm32h7_spi_irq_thread - Thread of interrupt handler for SPI controller
  * @irq: interrupt line
- * @dev_id: SPI controller master interface
+ * @dev_id: SPI controller interface
  */
 static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 {
-	struct spi_master *master = dev_id;
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_id;
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	u32 sr, ier, mask;
 	unsigned long flags;
 	bool end = false;
@@ -917,6 +1037,14 @@ static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 		end = true;
 	}
 
+	if (sr & STM32H7_SPI_SR_UDR) {
+		static DEFINE_RATELIMIT_STATE(rs,
+					      DEFAULT_RATELIMIT_INTERVAL * 10,
+					      1);
+		if (__ratelimit(&rs))
+			dev_dbg_ratelimited(spi->dev, "Underrun detected\n");
+	}
+
 	if (sr & STM32H7_SPI_SR_EOT) {
 		if (!spi->cur_usedma && (spi->rx_buf && (spi->rx_len > 0)))
 			stm32h7_spi_read_rxfifo(spi);
@@ -939,7 +1067,7 @@ static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 
 	if (end) {
 		stm32h7_spi_disable(spi);
-		spi_finalize_current_transfer(master);
+		spi_finalize_current_transfer(ctrl);
 	}
 
 	return IRQ_HANDLED;
@@ -947,13 +1075,13 @@ static irqreturn_t stm32h7_spi_irq_thread(int irq, void *dev_id)
 
 /**
  * stm32_spi_prepare_msg - set up the controller to transfer a single message
- * @master: controller master interface
+ * @ctrl: controller interface
  * @msg: pointer to spi message
  */
-static int stm32_spi_prepare_msg(struct spi_master *master,
+static int stm32_spi_prepare_msg(struct spi_controller *ctrl,
 				 struct spi_message *msg)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	struct spi_device *spi_dev = msg->spi;
 	struct device_node *np = spi_dev->dev.of_node;
 	unsigned long flags;
@@ -979,11 +1107,22 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 	else
 		clrb |= spi->cfg->regs->lsb_first.mask;
 
-	dev_dbg(spi->dev, "cpol=%d cpha=%d lsb_first=%d cs_high=%d\n",
+	if (STM32_SPI_SLAVE_MODE(spi) && spi_dev->mode & SPI_CS_HIGH)
+		setb |= spi->cfg->regs->cs_high.mask;
+	else
+		clrb |= spi->cfg->regs->cs_high.mask;
+
+	if (spi_dev->mode & SPI_READY)
+		setb |= spi->cfg->regs->rdy_en.mask;
+	else
+		clrb |= spi->cfg->regs->rdy_en.mask;
+
+	dev_dbg(spi->dev, "cpol=%d cpha=%d lsb_first=%d cs_high=%d rdy=%d\n",
 		!!(spi_dev->mode & SPI_CPOL),
 		!!(spi_dev->mode & SPI_CPHA),
 		!!(spi_dev->mode & SPI_LSB_FIRST),
-		!!(spi_dev->mode & SPI_CS_HIGH));
+		!!(spi_dev->mode & SPI_CS_HIGH),
+		!!(spi_dev->mode & SPI_READY));
 
 	/* On STM32H7, messages should not exceed a maximum size setted
 	 * afterward via the set_number_of_data function. In order to
@@ -992,16 +1131,16 @@ static int stm32_spi_prepare_msg(struct spi_master *master,
 	if (spi->cfg->set_number_of_data) {
 		int ret;
 
-		ret = spi_split_transfers_maxsize(master, msg,
-						  STM32H7_SPI_TSIZE_MAX,
-						  GFP_KERNEL | GFP_DMA);
+		ret = spi_split_transfers_maxwords(ctrl, msg,
+						   spi->t_size_max,
+						   GFP_KERNEL | GFP_DMA);
 		if (ret)
 			return ret;
 	}
 
 	spin_lock_irqsave(&spi->lock, flags);
 
-	/* CPOL, CPHA and LSB FIRST bits have common register */
+	/* CPOL, CPHA, LSB FIRST, CS_HIGH and RDY_EN bits have common register */
 	if (clrb || setb)
 		writel_relaxed(
 			(readl_relaxed(spi->base + spi->cfg->regs->cpol.reg) &
@@ -1024,7 +1163,7 @@ static void stm32f4_spi_dma_tx_cb(void *data)
 	struct stm32_spi *spi = data;
 
 	if (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX) {
-		spi_finalize_current_transfer(spi->master);
+		spi_finalize_current_transfer(spi->ctrl);
 		stm32f4_spi_disable(spi);
 	}
 }
@@ -1039,7 +1178,7 @@ static void stm32_spi_dma_rx_cb(void *data)
 {
 	struct stm32_spi *spi = data;
 
-	spi_finalize_current_transfer(spi->master);
+	spi_finalize_current_transfer(spi->ctrl);
 	spi->cfg->disable(spi);
 }
 
@@ -1047,15 +1186,19 @@ static void stm32_spi_dma_rx_cb(void *data)
  * stm32_spi_dma_config - configure dma slave channel depending on current
  *			  transfer bits_per_word.
  * @spi: pointer to the spi controller data structure
+ * @dma_chan: pointer to the DMA channel
  * @dma_conf: pointer to the dma_slave_config structure
  * @dir: direction of the dma transfer
  */
 static void stm32_spi_dma_config(struct stm32_spi *spi,
+				 struct dma_chan *dma_chan,
 				 struct dma_slave_config *dma_conf,
 				 enum dma_transfer_direction dir)
 {
 	enum dma_slave_buswidth buswidth;
-	u32 maxburst;
+	struct dma_slave_caps caps;
+	u32 maxburst = 1;
+	int ret;
 
 	if (spi->cur_bpw <= 8)
 		buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
@@ -1064,15 +1207,14 @@ static void stm32_spi_dma_config(struct stm32_spi *spi,
 	else
 		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
 
-	if (spi->cfg->has_fifo) {
-		/* Valid for DMA Half or Full Fifo threshold */
-		if (spi->cur_fthlv == 2)
-			maxburst = 1;
-		else
-			maxburst = spi->cur_fthlv;
-	} else {
-		maxburst = 1;
-	}
+	/* Valid for DMA Half or Full Fifo threshold */
+	if (!spi->cfg->prevent_dma_burst && spi->cfg->has_fifo && spi->cur_fthlv != 2)
+		maxburst = spi->cur_fthlv;
+
+	/* Get the DMA channel caps, and adjust maxburst if possible */
+	ret = dma_get_slave_caps(dma_chan, &caps);
+	if (!ret)
+		maxburst = min(maxburst, caps.max_burst);
 
 	memset(dma_conf, 0, sizeof(struct dma_slave_config));
 	dma_conf->direction = dir;
@@ -1136,6 +1278,54 @@ static int stm32f4_spi_transfer_one_irq(struct stm32_spi *spi)
 	return 1;
 }
 
+/**
+ * stm32h7_spi_transfer_one_poll - transfer a single spi_transfer by direct
+ *				   register access without interrupt usage
+ * @spi: pointer to the spi controller data structure
+ *
+ * It must returns 0 if the transfer is finished or 1 if the transfer is still
+ * in progress.
+ */
+static int stm32h7_spi_transfer_one_poll(struct stm32_spi *spi)
+{
+	unsigned long flags;
+	u32 sr;
+
+	spin_lock_irqsave(&spi->lock, flags);
+
+	stm32_spi_enable(spi);
+
+	/* Be sure to have data in fifo before starting data transfer */
+	if (spi->tx_buf)
+		stm32h7_spi_write_txfifo(spi);
+
+	if (STM32_SPI_MASTER_MODE(spi))
+		stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
+
+	sr = readl_relaxed(spi->base + STM32H7_SPI_SR);
+	/* Keep writing / reading while waiting for the end of transfer */
+	while (spi->tx_len || spi->rx_len || !(sr & STM32H7_SPI_SR_EOT)) {
+		if (spi->rx_len && (sr & (STM32H7_SPI_SR_RXP | STM32H7_SPI_SR_RXWNE)))
+			stm32h7_spi_read_rxfifo(spi);
+
+		if (spi->tx_len && (sr & STM32H7_SPI_SR_TXP))
+			stm32h7_spi_write_txfifo(spi);
+
+		sr = readl_relaxed(spi->base + STM32H7_SPI_SR);
+
+		/* Clear suspension bit if necessary */
+		if (sr & STM32H7_SPI_SR_SUSP)
+			writel_relaxed(sr & STM32H7_SPI_SR_SUSP, spi->base + STM32H7_SPI_IFCR);
+	}
+
+	spin_unlock_irqrestore(&spi->lock, flags);
+
+	stm32h7_spi_disable(spi);
+	spi_finalize_current_transfer(spi->ctrl);
+
+	return 0;
+}
+
 /**
  * stm32h7_spi_transfer_one_irq - transfer a single spi_transfer using
  *				  interrupts
@@ -1169,7 +1359,11 @@ static int stm32h7_spi_transfer_one_irq(struct stm32_spi *spi)
 	if (spi->tx_buf)
 		stm32h7_spi_write_txfifo(spi);
 
-	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
+	if (STM32_SPI_SLAVE_MODE(spi) && spi->slave_udr_mode != SPI_NO_ACTION)
+		ier |= STM32H7_SPI_IER_UDRIE;
+
+	if (STM32_SPI_MASTER_MODE(spi))
+		stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
 
 	writel_relaxed(ier, spi->base + STM32H7_SPI_IER);
 
@@ -1212,11 +1406,15 @@ static void stm32h7_spi_transfer_one_dma_start(struct stm32_spi *spi)
 	if (spi->cur_comm == SPI_SIMPLEX_TX || spi->cur_comm == SPI_3WIRE_TX)
 		ier |= STM32H7_SPI_IER_EOTIE | STM32H7_SPI_IER_TXTFIE;
 
+	if (STM32_SPI_SLAVE_MODE(spi) && spi->slave_udr_mode != SPI_NO_ACTION)
+		ier |= STM32H7_SPI_IER_UDRIE;
+
 	stm32_spi_set_bits(spi, STM32H7_SPI_IER, ier);
 
 	stm32_spi_enable(spi);
 
-	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
+	if (STM32_SPI_MASTER_MODE(spi))
+		stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_CSTART);
 }
 
 /**
@@ -1238,7 +1436,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 	rx_dma_desc = NULL;
 	if (spi->rx_buf && spi->dma_rx) {
-		stm32_spi_dma_config(spi, &rx_dma_conf, DMA_DEV_TO_MEM);
+		stm32_spi_dma_config(spi, spi->dma_rx, &rx_dma_conf, DMA_DEV_TO_MEM);
 		dmaengine_slave_config(spi->dma_rx, &rx_dma_conf);
 
 		/* Enable Rx DMA request */
@@ -1254,7 +1452,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 	tx_dma_desc = NULL;
 	if (spi->tx_buf && spi->dma_tx) {
-		stm32_spi_dma_config(spi, &tx_dma_conf, DMA_MEM_TO_DEV);
+		stm32_spi_dma_config(spi, spi->dma_tx, &tx_dma_conf, DMA_MEM_TO_DEV);
 		dmaengine_slave_config(spi->dma_tx, &tx_dma_conf);
 
 		tx_dma_desc = dmaengine_prep_slave_sg(
@@ -1310,7 +1508,7 @@ static int stm32_spi_transfer_one_dma(struct stm32_spi *spi,
 
 dma_submit_error:
 	if (spi->dma_rx)
-		dmaengine_terminate_all(spi->dma_rx);
+		dmaengine_terminate_sync(spi->dma_rx);
 
 dma_desc_error:
 	stm32_spi_clr_bits(spi, spi->cfg->regs->dma_rx_en.reg,
@@ -1486,11 +1684,12 @@ static void stm32h7_spi_data_idleness(struct stm32_spi *spi, u32 len)
 	cfg2_clrb |= STM32H7_SPI_CFG2_MIDI;
 	if ((len > 1) && (spi->cur_midi > 0)) {
 		u32 sck_period_ns = DIV_ROUND_UP(NSEC_PER_SEC, spi->cur_speed);
-		u32 midi = min_t(u32,
-				 DIV_ROUND_UP(spi->cur_midi, sck_period_ns),
-				 FIELD_GET(STM32H7_SPI_CFG2_MIDI,
-				 STM32H7_SPI_CFG2_MIDI));
+		u32 midi = DIV_ROUND_UP(spi->cur_midi, sck_period_ns);
+
+		if ((spi->cur_bpw + midi) < 8)
+			midi = 8 - spi->cur_bpw;
 
+		midi = min_t(u32, midi, FIELD_MAX(STM32H7_SPI_CFG2_MIDI));
 
 		dev_dbg(spi->dev, "period=%dns, midi=%d(=%dns)\n",
 			sck_period_ns, midi, midi * sck_period_ns);
@@ -1509,7 +1708,7 @@ static void stm32h7_spi_data_idleness(struct stm32_spi *spi, u32 len)
  */
 static int stm32h7_spi_number_of_data(struct stm32_spi *spi, u32 nb_words)
 {
-	if (nb_words <= STM32H7_SPI_TSIZE_MAX) {
+	if (nb_words <= spi->t_size_max) {
 		writel_relaxed(FIELD_PREP(STM32H7_SPI_CR2_TSIZE, nb_words),
 			       spi->base + STM32H7_SPI_CR2);
 	} else {
@@ -1519,6 +1718,53 @@ static int stm32h7_spi_number_of_data(struct stm32_spi *spi, u32 nb_words)
 	return 0;
 }
 
+/**
+ * stm32h7_spi_set_slave_udr - configure slave underrun detection and reaction
+ * @spi: pointer to the spi controller data structure
+ */
+static void stm32h7_spi_set_slave_udr(struct stm32_spi *spi)
+{
+	u32 max_udr_ptrn, udr_ptrn, cfg1_setb = 0;
+
+	if (spi->slave_udr_mode == SPI_NO_ACTION)
+		return;
+
+	switch (spi->slave_udr_mode) {
+	case SPI_SEND_PATTERN:
+		max_udr_ptrn = (1 << spi->cur_bpw) - 1;
+		if (spi->slave_udr_pattern > max_udr_ptrn) {
+			udr_ptrn = spi->slave_udr_pattern & max_udr_ptrn;
+			dev_warn(spi->dev,
+				 "force slave underrun pattern to data width (> 0x%x, set 0x%x)\n",
+				 max_udr_ptrn, udr_ptrn);
+		} else {
+			udr_ptrn = spi->slave_udr_pattern;
+			dev_dbg(spi->dev, "spi slave underrun: send pattern (0x%x)\n",
+				spi->slave_udr_pattern);
+		}
+		writel_relaxed(udr_ptrn, spi->base + STM32H7_SPI_UDRDR);
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRCFG, STM32H7_SPI_CFG1_UDRCFG_PTRN);
+		break;
+	case SPI_REPEAT_LAST_RECEIVED_DATA:
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRCFG, STM32H7_SPI_CFG1_UDRCFG_LAST_R);
+		dev_dbg(spi->dev, "spi slave underrun: repeat received data\n");
+		break;
+	case SPI_REPEAT_LAST_TRANSMITTED_DATA:
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRCFG, STM32H7_SPI_CFG1_UDRCFG_LAST_T);
+		dev_dbg(spi->dev, "spi slave underrun: repeat transmitted data\n");
+		break;
+	default:
+		dev_warn(spi->dev, "slave underrun detection disabled\n");
+		spi->slave_udr_mode = SPI_NO_ACTION;
+	}
+
+	if (spi->slave_udr_mode != SPI_NO_ACTION) {
+		cfg1_setb |= FIELD_PREP(STM32H7_SPI_CFG1_UDRDET, STM32H7_SPI_CFG1_UDRDET_LAST);
+
+		stm32_spi_set_bits(spi,  STM32H7_SPI_CFG1, cfg1_setb);
+	}
+}
+
 /**
  * stm32_spi_transfer_one_setup - common setup to transfer a single
  *				  spi_transfer either using DMA or
@@ -1543,17 +1789,26 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 	spi->cur_bpw = transfer->bits_per_word;
 	spi->cfg->set_bpw(spi);
 
-	/* Update spi->cur_speed with real clock speed */
-	mbr = stm32_spi_prepare_mbr(spi, transfer->speed_hz,
-				    spi->cfg->baud_rate_div_min,
-				    spi->cfg->baud_rate_div_max);
-	if (mbr < 0) {
-		ret = mbr;
-		goto out;
+	if (spi_dev->mode & SPI_READY && spi->cur_bpw < 8) {
+		writel_relaxed(readl_relaxed(spi->base + spi->cfg->regs->rdy_en.reg) &
+				~spi->cfg->regs->rdy_en.mask,
+					spi->base + spi->cfg->regs->rdy_en.reg);
+		dev_dbg(spi->dev, "RDY logic disabled as bits per word < 8\n");
 	}
 
-	transfer->speed_hz = spi->cur_speed;
-	stm32_spi_set_mbr(spi, mbr);
+	/* Update spi->cur_speed with real clock speed */
+	if (STM32_SPI_MASTER_MODE(spi)) {
+		mbr = stm32_spi_prepare_mbr(spi, transfer->speed_hz,
+					    spi->cfg->baud_rate_div_min,
+					    spi->cfg->baud_rate_div_max);
+		if (mbr < 0) {
+			ret = mbr;
+			goto out;
+		}
+
+		transfer->speed_hz = spi->cur_speed;
+		stm32_spi_set_mbr(spi, mbr);
+	}
 
 	comm_type = stm32_spi_communication_type(spi_dev, transfer);
 	ret = spi->cfg->set_mode(spi, comm_type);
@@ -1562,7 +1817,7 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 
 	spi->cur_comm = comm_type;
 
-	if (spi->cfg->set_data_idleness)
+	if (STM32_SPI_MASTER_MODE(spi) && spi->cfg->set_data_idleness)
 		spi->cfg->set_data_idleness(spi, transfer->len);
 
 	if (spi->cur_bpw <= 8)
@@ -1578,12 +1833,16 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 			goto out;
 	}
 
+	if (STM32_SPI_SLAVE_MODE(spi) && spi->cfg->set_slave_udr)
+		spi->cfg->set_slave_udr(spi);
+
 	dev_dbg(spi->dev, "transfer communication mode set to %d\n",
 		spi->cur_comm);
 	dev_dbg(spi->dev,
 		"data frame of %d-bit, data packet of %d data frames\n",
 		spi->cur_bpw, spi->cur_fthlv);
-	dev_dbg(spi->dev, "speed set to %dHz\n", spi->cur_speed);
+	if (STM32_SPI_MASTER_MODE(spi))
+		dev_dbg(spi->dev, "speed set to %dHz\n", spi->cur_speed);
 	dev_dbg(spi->dev, "transfer of %d bytes (%d data frames)\n",
 		spi->cur_xferlen, nb_words);
 	dev_dbg(spi->dev, "dma %s\n",
@@ -1595,20 +1854,38 @@ static int stm32_spi_transfer_one_setup(struct stm32_spi *spi,
 	return ret;
 }
 
+/**
+ * stm32_spi_can_poll - detect if poll based transfer is appropriate
+ * @spi: pointer to the spi controller data structure
+ *
+ * Returns true is poll is more appropriate, false otherwise.
+ */
+static bool stm32_spi_can_poll(struct stm32_spi *spi)
+{
+	unsigned long hz_per_byte, byte_limit;
+
+	/* Evaluate the transfer time and use polling if applicable */
+	hz_per_byte = polling_limit_us ?
+		      DIV_ROUND_UP(8 * USEC_PER_SEC, polling_limit_us) : 0;
+	byte_limit = hz_per_byte ? spi->cur_speed / hz_per_byte : 1;
+
+	return (spi->cur_xferlen < byte_limit) ? true : false;
+}
+
 /**
  * stm32_spi_transfer_one - transfer a single spi_transfer
- * @master: controller master interface
+ * @ctrl: controller interface
  * @spi_dev: pointer to the spi device
  * @transfer: pointer to spi transfer
  *
  * It must return 0 if the transfer is finished or 1 if the transfer is still
  * in progress.
  */
-static int stm32_spi_transfer_one(struct spi_master *master,
+static int stm32_spi_transfer_one(struct spi_controller *ctrl,
 				  struct spi_device *spi_dev,
 				  struct spi_transfer *transfer)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	int ret;
 
 	spi->tx_buf = transfer->tx_buf;
@@ -1616,8 +1893,8 @@ static int stm32_spi_transfer_one(struct spi_master *master,
 	spi->tx_len = spi->tx_buf ? transfer->len : 0;
 	spi->rx_len = spi->rx_buf ? transfer->len : 0;
 
-	spi->cur_usedma = (master->can_dma &&
-			   master->can_dma(master, spi_dev, transfer));
+	spi->cur_usedma = (ctrl->can_dma &&
+			   ctrl->can_dma(ctrl, spi_dev, transfer));
 
 	ret = stm32_spi_transfer_one_setup(spi, spi_dev, transfer);
 	if (ret) {
@@ -1627,19 +1904,21 @@ static int stm32_spi_transfer_one(struct spi_master *master,
 
 	if (spi->cur_usedma)
 		return stm32_spi_transfer_one_dma(spi, transfer);
+	else if (spi->cfg->transfer_one_poll && stm32_spi_can_poll(spi))
+		return spi->cfg->transfer_one_poll(spi);
 	else
 		return spi->cfg->transfer_one_irq(spi);
 }
 
 /**
  * stm32_spi_unprepare_msg - relax the hardware
- * @master: controller master interface
+ * @ctrl: controller interface
  * @msg: pointer to the spi message
  */
-static int stm32_spi_unprepare_msg(struct spi_master *master,
+static int stm32_spi_unprepare_msg(struct spi_controller *ctrl,
 				   struct spi_message *msg)
 {
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	spi->cfg->disable(spi);
 
@@ -1678,12 +1957,13 @@ static int stm32f4_spi_config(struct stm32_spi *spi)
 }
 
 /**
- * stm32h7_spi_config - Configure SPI controller as SPI master
+ * stm32h7_spi_config - Configure SPI controller
  * @spi: pointer to the spi controller data structure
  */
 static int stm32h7_spi_config(struct stm32_spi *spi)
 {
 	unsigned long flags;
+	u32 cr1 = 0, cfg2 = 0;
 
 	spin_lock_irqsave(&spi->lock, flags);
 
@@ -1691,24 +1971,28 @@ static int stm32h7_spi_config(struct stm32_spi *spi)
 	stm32_spi_clr_bits(spi, STM32H7_SPI_I2SCFGR,
 			   STM32H7_SPI_I2SCFGR_I2SMOD);
 
-	/*
-	 * - SS input value high
-	 * - transmitter half duplex direction
-	 * - automatic communication suspend when RX-Fifo is full
-	 */
-	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, STM32H7_SPI_CR1_SSI |
-						 STM32H7_SPI_CR1_HDDIR |
-						 STM32H7_SPI_CR1_MASRX);
+	if (STM32_SPI_SLAVE_MODE(spi)) {
+		/* Use native slave select */
+		cfg2 &= ~STM32H7_SPI_CFG2_SSM;
+	} else {
+		/*
+		 * - Transmitter half duplex direction
+		 * - Automatic communication suspend when RX-Fifo is full
+		 * - SS input value high
+		 */
+		cr1 |= STM32H7_SPI_CR1_HDDIR | STM32H7_SPI_CR1_MASRX | STM32H7_SPI_CR1_SSI;
 
-	/*
-	 * - Set the master mode (default Motorola mode)
-	 * - Consider 1 master/n slaves configuration and
-	 *   SS input value is determined by the SSI bit
-	 * - keep control of all associated GPIOs
-	 */
-	stm32_spi_set_bits(spi, STM32H7_SPI_CFG2, STM32H7_SPI_CFG2_MASTER |
-						  STM32H7_SPI_CFG2_SSM |
-						  STM32H7_SPI_CFG2_AFCNTR);
+		/*
+		 * - Set the master mode (default Motorola mode)
+		 * - Consider 1 master/n slaves configuration and
+		 *   SS input value is determined by the SSI bit
+		 * - keep control of all associated GPIOs
+		 */
+		cfg2 |= STM32H7_SPI_CFG2_MASTER | STM32H7_SPI_CFG2_SSM | STM32H7_SPI_CFG2_AFCNTR;
+	}
+
+	stm32_spi_set_bits(spi, STM32H7_SPI_CR1, cr1);
+	stm32_spi_set_bits(spi, STM32H7_SPI_CFG2, cfg2);
 
 	spin_unlock_irqrestore(&spi->lock, flags);
 
@@ -1751,37 +2035,110 @@ static const struct stm32_spi_cfg stm32h7_spi_cfg = {
 	 * SPI access hence handling is performed within the SPI interrupt
 	 */
 	.transfer_one_irq = stm32h7_spi_transfer_one_irq,
+	.transfer_one_poll = stm32h7_spi_transfer_one_poll,
+	.irq_handler_thread = stm32h7_spi_irq_thread,
+	.baud_rate_div_min = STM32H7_SPI_MBR_DIV_MIN,
+	.baud_rate_div_max = STM32H7_SPI_MBR_DIV_MAX,
+	.has_fifo = true,
+	.set_slave_udr = stm32h7_spi_set_slave_udr,
+};
+
+/*
+ * STM32MP2 is compatible with the STM32H7 except:
+ * - enforce the DMA maxburst value to 1
+ * - spi8 have limited feature set (TSIZE_MAX = 1024, BPW of 8 OR 16)
+ */
+static const struct stm32_spi_cfg stm32mp25_spi_cfg = {
+	.regs = &stm32mp25_spi_regspec,
+	.get_fifo_size = stm32h7_spi_get_fifo_size,
+	.get_bpw_mask = stm32mp25_spi_get_bpw_mask,
+	.disable = stm32h7_spi_disable,
+	.config = stm32h7_spi_config,
+	.set_bpw = stm32h7_spi_set_bpw,
+	.set_mode = stm32h7_spi_set_mode,
+	.set_data_idleness = stm32h7_spi_data_idleness,
+	.set_number_of_data = stm32h7_spi_number_of_data,
+	.transfer_one_dma_start = stm32h7_spi_transfer_one_dma_start,
+	.dma_rx_cb = stm32_spi_dma_rx_cb,
+	/*
+	 * dma_tx_cb is not necessary since in case of TX, dma is followed by
+	 * SPI access hence handling is performed within the SPI interrupt
+	 */
+	.transfer_one_irq = stm32h7_spi_transfer_one_irq,
+	.transfer_one_poll = stm32h7_spi_transfer_one_poll,
 	.irq_handler_thread = stm32h7_spi_irq_thread,
 	.baud_rate_div_min = STM32H7_SPI_MBR_DIV_MIN,
 	.baud_rate_div_max = STM32H7_SPI_MBR_DIV_MAX,
 	.has_fifo = true,
+	.prevent_dma_burst = true,
 };
 
 static const struct of_device_id stm32_spi_of_match[] = {
+	{ .compatible = "st,stm32mp25-spi", .data = (void *)&stm32mp25_spi_cfg },
 	{ .compatible = "st,stm32h7-spi", .data = (void *)&stm32h7_spi_cfg },
 	{ .compatible = "st,stm32f4-spi", .data = (void *)&stm32f4_spi_cfg },
 	{},
 };
 MODULE_DEVICE_TABLE(of, stm32_spi_of_match);
 
+static int stm32h7_spi_slave_abort(struct spi_controller *ctrl)
+{
+	spi_finalize_current_transfer(ctrl);
+
+	return 0;
+}
+
+static void stm32h7_spi_parse_slave_config(struct stm32_spi *spi, struct device_node *np)
+{
+	u32 udr_configs[2] = { 0, 0 };
+	int count, ret;
+
+	count = of_property_count_elems_of_size(np, "st,spi-slave-underrun", sizeof(u32));
+	if (count <= 0) {
+		if (count != -EINVAL)
+			dev_err(spi->dev, "Invalid st,spi-slave-underrun property\n");
+		return;
+	}
+
+	ret = of_property_read_u32_array(np, "st,spi-slave-underrun", udr_configs, count);
+	if (ret)
+		return;
+
+	spi->slave_udr_mode = udr_configs[0];
+	if (spi->slave_udr_mode == SPI_SEND_PATTERN) {
+		if (count > 1)
+			spi->slave_udr_pattern = udr_configs[1];
+		else
+			dev_warn(spi->dev, "Missing pattern in st,spi-slave-underrun property\n");
+	}
+}
+
 static int stm32_spi_probe(struct platform_device *pdev)
 {
-	struct spi_master *master;
+	struct spi_controller *ctrl;
 	struct stm32_spi *spi;
 	struct resource *res;
 	struct reset_control *rst;
+	struct device_node *np = pdev->dev.of_node;
+	bool slave_mode;
 	int ret;
 
-	master = devm_spi_alloc_master(&pdev->dev, sizeof(struct stm32_spi));
-	if (!master) {
-		dev_err(&pdev->dev, "spi master allocation failed\n");
+	slave_mode = of_property_read_bool(np, "spi-slave");
+
+	if (slave_mode)
+		ctrl = devm_spi_alloc_slave(&pdev->dev, sizeof(struct stm32_spi));
+	else
+		ctrl = devm_spi_alloc_master(&pdev->dev, sizeof(struct stm32_spi));
+	if (!ctrl) {
+		dev_err(&pdev->dev, "spi controller allocation failed\n");
 		return -ENOMEM;
 	}
-	platform_set_drvdata(pdev, master);
+	platform_set_drvdata(pdev, ctrl);
 
-	spi = spi_master_get_devdata(master);
+	spi = spi_controller_get_devdata(ctrl);
 	spi->dev = &pdev->dev;
-	spi->master = master;
+	spi->ctrl = ctrl;
+	spi->slave_mode = slave_mode;
 	spin_lock_init(&spi->lock);
 
 	spi->cfg = (const struct stm32_spi_cfg *)
@@ -1803,13 +2160,16 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	ret = devm_request_threaded_irq(&pdev->dev, spi->irq,
 					spi->cfg->irq_handler_event,
 					spi->cfg->irq_handler_thread,
-					IRQF_ONESHOT, pdev->name, master);
+					IRQF_ONESHOT, pdev->name, ctrl);
 	if (ret) {
 		dev_err(&pdev->dev, "irq%d request failed: %d\n", spi->irq,
 			ret);
 		return ret;
 	}
 
+	if (STM32_SPI_SLAVE_MODE(spi))
+		stm32h7_spi_parse_slave_config(spi, np);
+
 	spi->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(spi->clk)) {
 		ret = PTR_ERR(spi->clk);
@@ -1845,6 +2205,22 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	if (spi->cfg->has_fifo)
 		spi->fifo_size = spi->cfg->get_fifo_size(spi);
 
+	spi->feature_set = STM32_SPI_FEATURE_FULL;
+	if (spi->cfg->regs->fullcfg.reg) {
+		spi->feature_set =
+			FIELD_GET(STM32MP25_SPI_HWCFGR1_FULLCFG,
+				  readl_relaxed(spi->base + spi->cfg->regs->fullcfg.reg));
+
+		dev_dbg(spi->dev, "%s feature set\n",
+			spi->feature_set == STM32_SPI_FEATURE_FULL ? "full" : "limited");
+	}
+
+	/* Only for STM32H7 and after */
+	spi->t_size_max = spi->feature_set == STM32_SPI_FEATURE_FULL ?
+				STM32H7_SPI_TSIZE_MAX :
+				STM32MP25_SPI_TSIZE_MAX_LIMITED;
+	dev_dbg(spi->dev, "one message max size %d\n", spi->t_size_max);
+
 	ret = spi->cfg->config(spi);
 	if (ret) {
 		dev_err(&pdev->dev, "controller configuration failed: %d\n",
@@ -1852,19 +2228,21 @@ static int stm32_spi_probe(struct platform_device *pdev)
 		goto err_clk_disable;
 	}
 
-	master->dev.of_node = pdev->dev.of_node;
-	master->auto_runtime_pm = true;
-	master->bus_num = pdev->id;
-	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST |
-			    SPI_3WIRE;
-	master->bits_per_word_mask = spi->cfg->get_bpw_mask(spi);
-	master->max_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_min;
-	master->min_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_max;
-	master->use_gpio_descriptors = true;
-	master->prepare_message = stm32_spi_prepare_msg;
-	master->transfer_one = stm32_spi_transfer_one;
-	master->unprepare_message = stm32_spi_unprepare_msg;
-	master->flags = spi->cfg->flags;
+	ctrl->dev.of_node = pdev->dev.of_node;
+	ctrl->auto_runtime_pm = true;
+	ctrl->bus_num = pdev->id;
+	ctrl->mode_bits = SPI_CPHA | SPI_CPOL | SPI_CS_HIGH | SPI_LSB_FIRST |
+			  SPI_3WIRE | SPI_READY;
+	ctrl->bits_per_word_mask = spi->cfg->get_bpw_mask(spi);
+	ctrl->max_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_min;
+	ctrl->min_speed_hz = spi->clk_rate / spi->cfg->baud_rate_div_max;
+	ctrl->use_gpio_descriptors = true;
+	ctrl->prepare_message = stm32_spi_prepare_msg;
+	ctrl->transfer_one = stm32_spi_transfer_one;
+	ctrl->unprepare_message = stm32_spi_unprepare_msg;
+	ctrl->flags = spi->cfg->flags;
+	if (STM32_SPI_SLAVE_MODE(spi))
+		ctrl->slave_abort = stm32h7_spi_slave_abort;
 
 	spi->dma_tx = dma_request_chan(spi->dev, "tx");
 	if (IS_ERR(spi->dma_tx)) {
@@ -1875,7 +2253,7 @@ static int stm32_spi_probe(struct platform_device *pdev)
 
 		dev_warn(&pdev->dev, "failed to request tx dma channel\n");
 	} else {
-		master->dma_tx = spi->dma_tx;
+		ctrl->dma_tx = spi->dma_tx;
 	}
 
 	spi->dma_rx = dma_request_chan(spi->dev, "rx");
@@ -1887,11 +2265,11 @@ static int stm32_spi_probe(struct platform_device *pdev)
 
 		dev_warn(&pdev->dev, "failed to request rx dma channel\n");
 	} else {
-		master->dma_rx = spi->dma_rx;
+		ctrl->dma_rx = spi->dma_rx;
 	}
 
 	if (spi->dma_tx || spi->dma_rx)
-		master->can_dma = stm32_spi_can_dma;
+		ctrl->can_dma = stm32_spi_can_dma;
 
 	pm_runtime_set_autosuspend_delay(&pdev->dev,
 					 STM32_SPI_AUTOSUSPEND_DELAY);
@@ -1900,9 +2278,9 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	pm_runtime_get_noresume(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 
-	ret = spi_register_master(master);
+	ret = spi_register_controller(ctrl);
 	if (ret) {
-		dev_err(&pdev->dev, "spi master registration failed: %d\n",
+		dev_err(&pdev->dev, "spi controller registration failed: %d\n",
 			ret);
 		goto err_pm_disable;
 	}
@@ -1910,7 +2288,8 @@ static int stm32_spi_probe(struct platform_device *pdev)
 	pm_runtime_mark_last_busy(&pdev->dev);
 	pm_runtime_put_autosuspend(&pdev->dev);
 
-	dev_info(&pdev->dev, "driver initialized\n");
+	dev_info(&pdev->dev, "driver initialized (%s mode)\n",
+		 STM32_SPI_MASTER_MODE(spi) ? "master" : "slave");
 
 	return 0;
 
@@ -1932,12 +2311,12 @@ static int stm32_spi_probe(struct platform_device *pdev)
 
 static int stm32_spi_remove(struct platform_device *pdev)
 {
-	struct spi_master *master = platform_get_drvdata(pdev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = platform_get_drvdata(pdev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	pm_runtime_get_sync(&pdev->dev);
 
-	spi_unregister_master(master);
+	spi_unregister_controller(ctrl);
 	spi->cfg->disable(spi);
 
 	pm_runtime_disable(&pdev->dev);
@@ -1945,10 +2324,10 @@ static int stm32_spi_remove(struct platform_device *pdev)
 	pm_runtime_set_suspended(&pdev->dev);
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
 
-	if (master->dma_tx)
-		dma_release_channel(master->dma_tx);
-	if (master->dma_rx)
-		dma_release_channel(master->dma_rx);
+	if (ctrl->dma_tx)
+		dma_release_channel(ctrl->dma_tx);
+	if (ctrl->dma_rx)
+		dma_release_channel(ctrl->dma_rx);
 
 	clk_disable_unprepare(spi->clk);
 
@@ -1960,8 +2339,8 @@ static int stm32_spi_remove(struct platform_device *pdev)
 
 static int __maybe_unused stm32_spi_runtime_suspend(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 
 	clk_disable_unprepare(spi->clk);
 
@@ -1970,8 +2349,8 @@ static int __maybe_unused stm32_spi_runtime_suspend(struct device *dev)
 
 static int __maybe_unused stm32_spi_runtime_resume(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	int ret;
 
 	ret = pinctrl_pm_select_default_state(dev);
@@ -1983,10 +2362,10 @@ static int __maybe_unused stm32_spi_runtime_resume(struct device *dev)
 
 static int __maybe_unused stm32_spi_suspend(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
 	int ret;
 
-	ret = spi_master_suspend(master);
+	ret = spi_controller_suspend(ctrl);
 	if (ret)
 		return ret;
 
@@ -1995,15 +2374,15 @@ static int __maybe_unused stm32_spi_suspend(struct device *dev)
 
 static int __maybe_unused stm32_spi_resume(struct device *dev)
 {
-	struct spi_master *master = dev_get_drvdata(dev);
-	struct stm32_spi *spi = spi_master_get_devdata(master);
+	struct spi_controller *ctrl = dev_get_drvdata(dev);
+	struct stm32_spi *spi = spi_controller_get_devdata(ctrl);
 	int ret;
 
 	ret = pm_runtime_force_resume(dev);
 	if (ret)
 		return ret;
 
-	ret = spi_master_resume(master);
+	ret = spi_controller_resume(ctrl);
 	if (ret) {
 		clk_disable_unprepare(spi->clk);
 		return ret;
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 19688f333..f14445608 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3606,6 +3606,55 @@ int spi_split_transfers_maxsize(struct spi_controller *ctlr,
 }
 EXPORT_SYMBOL_GPL(spi_split_transfers_maxsize);
 
+
+/**
+ * spi_split_transfers_maxwords - split spi transfers into multiple transfers
+ *                                when an individual transfer exceeds a
+ *                                certain number of SPI words
+ * @ctlr:     the @spi_controller for this transfer
+ * @msg:      the @spi_message to transform
+ * @maxwords: the number of words to limit each transfer to
+ * @gfp:      GFP allocation flags
+ *
+ * Return: status of transformation
+ */
+int spi_split_transfers_maxwords(struct spi_controller *ctlr,
+				 struct spi_message *msg,
+				 size_t maxwords,
+				 gfp_t gfp)
+{
+	struct spi_transfer *xfer;
+
+	/*
+	 * Iterate over the transfer_list,
+	 * but note that xfer is advanced to the last transfer inserted
+	 * to avoid checking sizes again unnecessarily (also xfer does
+	 * potentially belong to a different list by the time the
+	 * replacement has happened).
+	 */
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		size_t maxsize;
+		int ret;
+
+		if (xfer->bits_per_word <= 8)
+			maxsize = maxwords;
+		else if (xfer->bits_per_word <= 16)
+			maxsize = 2 * maxwords;
+		else
+			maxsize = 4 * maxwords;
+
+		if (xfer->len > maxsize) {
+			ret = __spi_split_transfer_maxsize(ctlr, msg, &xfer,
+							   maxsize, gfp);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_split_transfers_maxwords);
+
 /*-------------------------------------------------------------------------*/
 
 /* Core methods for SPI controller protocol drivers.  Some of the
diff --git a/drivers/tee/optee/call.c b/drivers/tee/optee/call.c
index 290b1bb0e..b4db5af83 100644
--- a/drivers/tee/optee/call.c
+++ b/drivers/tee/optee/call.c
@@ -120,8 +120,8 @@ void optee_cq_wait_final(struct optee_call_queue *cq,
 }
 
 /* Requires the filpstate mutex to be held */
-static struct optee_session *find_session(struct optee_context_data *ctxdata,
-					  u32 session_id)
+struct optee_session *optee_find_session(struct optee_context_data *ctxdata,
+					 u32 session_id)
 {
 	struct optee_session *sess;
 
@@ -328,7 +328,7 @@ int optee_open_session(struct tee_context *ctx,
 		goto out;
 	}
 
-	if (optee->ops->do_call_with_arg(ctx, shm, offs)) {
+	if (optee->ops->do_call_with_arg(ctx, shm, offs, NULL)) {
 		msg_arg->ret = TEEC_ERROR_COMMUNICATION;
 		msg_arg->ret_origin = TEEC_ORIGIN_COMMS;
 	}
@@ -360,21 +360,30 @@ int optee_open_session(struct tee_context *ctx,
 	return rc;
 }
 
-int optee_close_session_helper(struct tee_context *ctx, u32 session)
+int optee_close_session_helper(struct tee_context *ctx,
+			       struct optee_session *sess)
 {
 	struct optee *optee = tee_get_drvdata(ctx->teedev);
 	struct optee_shm_arg_entry *entry;
+	struct optee_call_extra call_ctx;
 	struct optee_msg_arg *msg_arg;
 	struct tee_shm *shm;
 	u_int offs;
 
+	if (WARN_ONCE(sess->ocall_ctx.thread_p1, "Can't close, on going Ocall\n"))
+		return -EINVAL;
+
 	msg_arg = optee_get_msg_arg(ctx, 0, &entry, &shm, &offs);
 	if (IS_ERR(msg_arg))
 		return PTR_ERR(msg_arg);
 
 	msg_arg->cmd = OPTEE_MSG_CMD_CLOSE_SESSION;
-	msg_arg->session = session;
-	optee->ops->do_call_with_arg(ctx, shm, offs);
+	msg_arg->session = sess->session_id;
+
+	memset(&call_ctx, 0, sizeof(call_ctx));
+	call_ctx.system = sess->system;
+
+	optee->ops->do_call_with_arg(ctx, shm, offs, &call_ctx);
 
 	optee_free_msg_arg(ctx, entry, offs);
 
@@ -385,43 +394,88 @@ int optee_close_session(struct tee_context *ctx, u32 session)
 {
 	struct optee_context_data *ctxdata = ctx->data;
 	struct optee_session *sess;
+	int rc;
 
 	/* Check that the session is valid and remove it from the list */
 	mutex_lock(&ctxdata->mutex);
-	sess = find_session(ctxdata, session);
-	if (sess)
+	sess = optee_find_session(ctxdata, session);
+	if (sess && !sess->ocall_ctx.thread_p1)
 		list_del(&sess->list_node);
 	mutex_unlock(&ctxdata->mutex);
 	if (!sess)
 		return -EINVAL;
+	if (WARN_ONCE(sess->ocall_ctx.thread_p1, "Can't close, on going Ocall\n"))
+		return -EINVAL;
+
+	rc = optee_close_session_helper(ctx, sess);
 	kfree(sess);
 
-	return optee_close_session_helper(ctx, session);
+	return rc;
 }
 
 int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
 		      struct tee_param *param)
+{
+	return optee_invoke_func_helper(ctx, arg, param, NULL);
+}
+
+int optee_invoke_func_helper(struct tee_context *ctx,
+			     struct tee_ioctl_invoke_arg *arg,
+			     struct tee_param *param,
+			     struct tee_ocall2_arg *ocall_arg)
 {
 	struct optee *optee = tee_get_drvdata(ctx->teedev);
 	struct optee_context_data *ctxdata = ctx->data;
 	struct optee_shm_arg_entry *entry;
+	struct optee_call_extra call_extra;
 	struct optee_msg_arg *msg_arg;
 	struct optee_session *sess;
 	struct tee_shm *shm;
 	u_int offs;
 	int rc;
+	u32 session_id;
+
+	if (tee_ocall_in_progress(ocall_arg))
+		session_id = ocall_arg->session;
+	else
+		session_id = arg->session;
 
 	/* Check that the session is valid */
 	mutex_lock(&ctxdata->mutex);
-	sess = find_session(ctxdata, arg->session);
+	sess = optee_find_session(ctxdata, session_id);
 	mutex_unlock(&ctxdata->mutex);
 	if (!sess)
 		return -EINVAL;
+	if (tee_ocall_in_progress(ocall_arg) && !sess->ocall_ctx.thread_p1) {
+		pr_err("Unexpected return from Ocall for the session\n");
+		return -EINVAL;
+	}
+	if (!tee_ocall_is_used(ocall_arg) && sess->ocall_ctx.thread_p1) {
+		pr_err("Session is busy with an on-going Ocall\n");
+		return -EINVAL;
+	}
+
+	/* Setup TEE call extra data  */
+	memset(&call_extra, 0, sizeof(call_extra));
+	call_extra.system = sess->system;
 
+	if (tee_ocall_is_used(ocall_arg)) {
+		call_extra.ocall_arg = ocall_arg;
+		call_extra.ocall_call_waiter = &sess->ocall_ctx.call_waiter;
+	}
+
+	if (tee_ocall_in_progress(ocall_arg)) {
+		call_extra.tee_thread_id = sess->ocall_ctx.thread_p1 - 1;
+		/* Skip shared memory buffer part, not needed with ocall2 */
+		goto do_call;
+	}
+
+	/* Get a shared memory buffer for the message */
 	msg_arg = optee_get_msg_arg(ctx, arg->num_params,
 				    &entry, &shm, &offs);
 	if (IS_ERR(msg_arg))
 		return PTR_ERR(msg_arg);
+
 	msg_arg->cmd = OPTEE_MSG_CMD_INVOKE_COMMAND;
 	msg_arg->func = arg->func;
 	msg_arg->session = arg->session;
@@ -432,7 +486,55 @@ int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
 	if (rc)
 		goto out;
 
-	if (optee->ops->do_call_with_arg(ctx, shm, offs)) {
+	if (tee_ocall_is_used(ocall_arg)) {
+		/* Save initial call context in ocall context */
+		memcpy(&sess->ocall_ctx.call_arg, arg, sizeof(*arg));
+		sess->ocall_ctx.msg_arg = msg_arg;
+		sess->ocall_ctx.msg_entry = entry;
+		sess->ocall_ctx.msg_offs = offs;
+	}
+
+do_call:
+	rc = optee->ops->do_call_with_arg(ctx, shm, offs, &call_extra);
+
+	if (rc == -EAGAIN) {
+		/* We are executing an Ocall request from TEE */
+		if (tee_ocall_in_progress(ocall_arg)) {
+			mutex_lock(&ctxdata->mutex);
+			ocall_arg->session = session_id;
+			sess->ocall_ctx.thread_p1 = call_extra.tee_thread_id + 1;
+			mutex_unlock(&ctxdata->mutex);
+
+			return 0;
+		}
+		WARN_ONCE(1, "optee: unexpected ocall\n");
+	}
+
+	/* Session may be leaving an Ocall */
+	mutex_lock(&ctxdata->mutex);
+	sess->ocall_ctx.thread_p1 = 0;
+
+	if (tee_ocall_is_used(ocall_arg)) {
+		/* We are returning from initial call, get initial call msg */
+		msg_arg = sess->ocall_ctx.msg_arg;
+		entry = sess->ocall_ctx.msg_entry;
+		offs = sess->ocall_ctx.msg_offs;
+		if (arg) {
+			unsigned int num_params = arg->num_params;
+
+			memcpy(arg, &sess->ocall_ctx.call_arg, sizeof(*arg));
+			if (num_params < sess->ocall_ctx.call_arg.num_params) {
+				arg->num_params = 0;
+				rc = -EINVAL;
+			}
+		}
+
+		/* Wipe Ocall context deprecated information */
+		memset(&sess->ocall_ctx, 0, sizeof(sess->ocall_ctx));
+	}
+	mutex_unlock(&ctxdata->mutex);
+
+	if (rc) {
 		msg_arg->ret = TEEC_ERROR_COMMUNICATION;
 		msg_arg->ret_origin = TEEC_ORIGIN_COMMS;
 	}
@@ -462,10 +564,12 @@ int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)
 
 	/* Check that the session is valid */
 	mutex_lock(&ctxdata->mutex);
-	sess = find_session(ctxdata, session);
+	sess = optee_find_session(ctxdata, session);
 	mutex_unlock(&ctxdata->mutex);
 	if (!sess)
 		return -EINVAL;
+	if (WARN_ONCE(sess->ocall_ctx.thread_p1, "Can't cancel, on going Ocall\n"))
+		return -EINVAL;
 
 	msg_arg = optee_get_msg_arg(ctx, 0, &entry, &shm, &offs);
 	if (IS_ERR(msg_arg))
@@ -474,7 +578,7 @@ int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session)
 	msg_arg->cmd = OPTEE_MSG_CMD_CANCEL;
 	msg_arg->session = session;
 	msg_arg->cancel_id = cancel_id;
-	optee->ops->do_call_with_arg(ctx, shm, offs);
+	optee->ops->do_call_with_arg(ctx, shm, offs, NULL);
 
 	optee_free_msg_arg(ctx, entry, offs);
 	return 0;
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index daf07737c..49d6bb0d1 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -129,7 +129,7 @@ int optee_open(struct tee_context *ctx, bool cap_memref_null)
 
 static void optee_release_helper(struct tee_context *ctx,
 				 int (*close_session)(struct tee_context *ctx,
-						      u32 session))
+						      struct optee_session *s))
 {
 	struct optee_context_data *ctxdata = ctx->data;
 	struct optee_session *sess;
@@ -141,7 +141,7 @@ static void optee_release_helper(struct tee_context *ctx,
 	list_for_each_entry_safe(sess, sess_tmp, &ctxdata->sess_list,
 				 list_node) {
 		list_del(&sess->list_node);
-		close_session(ctx, sess->session_id);
+		close_session(ctx, sess);
 		kfree(sess);
 	}
 	kfree(ctxdata);
diff --git a/drivers/tee/optee/ffa_abi.c b/drivers/tee/optee/ffa_abi.c
index 0828240f2..7ffc5a596 100644
--- a/drivers/tee/optee/ffa_abi.c
+++ b/drivers/tee/optee/ffa_abi.c
@@ -612,7 +612,8 @@ static int optee_ffa_yielding_call(struct tee_context *ctx,
  */
 
 static int optee_ffa_do_call_with_arg(struct tee_context *ctx,
-				      struct tee_shm *shm, u_int offs)
+				      struct tee_shm *shm, u_int offs,
+				      struct optee_call_extra *call_extra)
 {
 	struct ffa_send_direct_data data = {
 		.data0 = OPTEE_FFA_YIELDING_CALL_WITH_ARG,
diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index 04ae58892..fa5037766 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -9,6 +9,7 @@
 #include <linux/arm-smccc.h>
 #include <linux/rhashtable.h>
 #include <linux/semaphore.h>
+#include <linux/spinlock.h>
 #include <linux/tee_drv.h>
 #include <linux/types.h>
 #include "optee_msg.h"
@@ -35,6 +36,9 @@
  */
 #define OPTEE_DEFAULT_MAX_NOTIF_VALUE	255
 
+/* This value should be larger than max interrupt ID notified by secure world */
+#define OPTEE_MAX_IT 32
+
 typedef void (optee_invoke_fn)(unsigned long, unsigned long, unsigned long,
 				unsigned long, unsigned long, unsigned long,
 				unsigned long, unsigned long,
@@ -94,11 +98,37 @@ struct optee_supp {
 	struct completion reqs_c;
 };
 
+/*
+ * struct optee_pcpu - per cpu notif private struct passed to work functions
+ * @optee		optee device reference
+ */
+struct optee_pcpu {
+	struct optee *optee;
+};
+
+/*
+ * struct optee_smc - optee smc communication struct
+ * @invoke_fn		handler function to invoke secure monitor
+ * @memremaped_shm	virtual address of memory in shared memory pool
+ * @sec_caps:		secure world capabilities defined by
+ *			OPTEE_SMC_SEC_CAP_* in optee_smc.h
+ * @notif_irq		interrupt used as async notification by OP-TEE or 0
+ * @optee_pcpu		per_cpu optee instance for per cpu work or NULL
+ * @notif_pcpu_wq	workqueue for per cpu aynchronous notification or NULL
+ * @notif_pcpu_work	work for per cpu asynchronous notification
+ * @notif_cpuhp_state   CPU hotplug state assigned for pcpu interrupt management
+ * @domain		interrupt domain registered by OP-TEE driver
+ */
 struct optee_smc {
 	optee_invoke_fn *invoke_fn;
 	void *memremaped_shm;
 	u32 sec_caps;
 	unsigned int notif_irq;
+	struct optee_pcpu __percpu *optee_pcpu;
+	struct workqueue_struct *notif_pcpu_wq;
+	struct work_struct notif_pcpu_work;
+	unsigned int notif_cpuhp_state;
+	struct irq_domain *domain;
 };
 
 /**
@@ -118,6 +148,20 @@ struct optee_ffa {
 
 struct optee;
 
+/**
+ * struct optee_call_extra - Extra data used by calling TEE
+ * @system: True when call context relates to a system session
+ * @ocall_arg: OCall arguments related to the call or NULL
+ * @tee_thread_id: TEE thread ID to use to return from an OCall, or NUL
+ * @ocall_call_waiter: Reference to the waiter that tracks TEE entry
+ */
+struct optee_call_extra {
+	bool system;
+	struct tee_ocall2_arg *ocall_arg;
+	u32 tee_thread_id;
+	struct optee_call_waiter *ocall_call_waiter;
+};
+
 /**
  * struct optee_ops - OP-TEE driver internal operations
  * @do_call_with_arg:	enters OP-TEE in secure world
@@ -130,7 +174,8 @@ struct optee;
  */
 struct optee_ops {
 	int (*do_call_with_arg)(struct tee_context *ctx,
-				struct tee_shm *shm_arg, u_int offs);
+				struct tee_shm *shm_arg, u_int offs,
+				struct optee_call_extra *extra);
 	int (*to_msg_param)(struct optee *optee,
 			    struct optee_msg_param *msg_params,
 			    size_t num_params, const struct tee_param *params);
@@ -139,6 +184,15 @@ struct optee_ops {
 			      const struct optee_msg_param *msg_params);
 };
 
+struct optee_thread {
+	spinlock_t lock;
+	size_t thread_cnt;
+	size_t thread_free_cnt;
+	size_t system_thread_cnt;
+	size_t system_thread_free_cnt;
+	bool best_effort;
+};
+
 /**
  * struct optee - main service struct
  * @supp_teedev:	supplicant device
@@ -175,11 +229,44 @@ struct optee {
 	bool   scan_bus_done;
 	struct workqueue_struct *scan_bus_wq;
 	struct work_struct scan_bus_work;
+	struct optee_thread thread;
 };
 
+/**
+ * struct tee_session_ocall - Ocall context of a session
+ * @thread_p1:    TEE thread ID plus 1 (0 means no suspended TEE thread)
+ * @call_arg:     Invocation argument from initial call that issued the Ocall
+ * @msg_arg:      Reference to optee msg used at initial call
+ * @msg_entry:    Reference to optee msg allocation entry
+ * @msg_offs:     Reference to optee msg allocation offset
+ * @call_waiter:  Waiter for the call entry completed at Ocall return entry
+ */
+struct tee_session_ocall {
+	u32 thread_p1;
+	struct optee_call_waiter call_waiter;
+	struct tee_ioctl_invoke_arg call_arg;
+	struct optee_msg_arg *msg_arg;
+	struct optee_shm_arg_entry *msg_entry;
+	u_int msg_offs;
+};
+
+/**
+ * struct tee_session - Session between a client and a TEE service (TA)
+ * @list_node: User list for the session
+ * @session_id:        Session identifeir provided by the TEE
+ * @system:            Session has system attribute
+ * @ocall_thread_p1:   TEE thread ID the OCall is bound to, plus 1
+ * @ocall_invoke_arg:  Invocation argument used at TEE initial entry
+ * @ocall_msg_arg:     Reference to msg buffer used at TEE initial entry
+ * @ocall_msg_entry:   Entry reference of allocated msg buffer
+ * @ocall_msg_offs:    Offset reference of allocated msg buffer
+ * @ocall_call_waiter: Waiter that tracks TEE entry on Ocall cases
+ */
 struct optee_session {
 	struct list_head list_node;
 	u32 session_id;
+	bool system;
+	struct tee_session_ocall ocall_ctx;
 };
 
 struct optee_context_data {
@@ -228,12 +315,18 @@ int optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params,
 int optee_open_session(struct tee_context *ctx,
 		       struct tee_ioctl_open_session_arg *arg,
 		       struct tee_param *param);
-int optee_close_session_helper(struct tee_context *ctx, u32 session);
+int optee_close_session_helper(struct tee_context *ctx,
+			       struct optee_session *sess);
 int optee_close_session(struct tee_context *ctx, u32 session);
 int optee_invoke_func(struct tee_context *ctx, struct tee_ioctl_invoke_arg *arg,
 		      struct tee_param *param);
 int optee_cancel_req(struct tee_context *ctx, u32 cancel_id, u32 session);
 
+int optee_invoke_func_helper(struct tee_context *ctx,
+			     struct tee_ioctl_invoke_arg *arg,
+			     struct tee_param *param,
+			     struct tee_ocall2_arg *ocall_arg);
+
 #define PTA_CMD_GET_DEVICES		0x0
 #define PTA_CMD_GET_DEVICES_SUPP	0x1
 int optee_enumerate_devices(u32 func);
@@ -301,6 +394,10 @@ void optee_rpc_cmd_free_suppl(struct tee_context *ctx, struct tee_shm *shm);
 void optee_rpc_cmd(struct tee_context *ctx, struct optee *optee,
 		   struct optee_msg_arg *arg);
 
+/* Find a session held in optee context */
+struct optee_session *optee_find_session(struct optee_context_data *ctxdata,
+					 u32 session_id);
+
 /*
  * Small helpers
  */
diff --git a/drivers/tee/optee/optee_smc.h b/drivers/tee/optee/optee_smc.h
index 73b5e7760..c7ec2f8f3 100644
--- a/drivers/tee/optee/optee_smc.h
+++ b/drivers/tee/optee/optee_smc.h
@@ -420,6 +420,22 @@ struct optee_smc_disable_shm_cache_result {
 #define OPTEE_SMC_GET_ASYNC_NOTIF_VALUE \
 	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_ASYNC_NOTIF_VALUE)
 
+#define OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_IT		1
+
+#define OPTEE_SMC_IT_NOTIF_VALUE_VALID		BIT(0)
+#define OPTEE_SMC_IT_NOTIF_VALUE_PENDING		BIT(1)
+
+/*
+ * Notification that OP-TEE generates and interruption.
+ */
+#define OPTEE_SMC_FUNCID_GET_IT_NOTIF_VALUE	53		// Update will likely change to 20
+#define OPTEE_SMC_GET_IT_NOTIF_VALUE \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_GET_IT_NOTIF_VALUE)
+
+#define OPTEE_SMC_FUNCID_SET_IT_NOTIF_MASK	54		// Update will likely change to 21
+#define OPTEE_SMC_SET_IT_NOTIF_MASK \
+	OPTEE_SMC_FAST_CALL_VAL(OPTEE_SMC_FUNCID_SET_IT_NOTIF_MASK)
+
 /* See OPTEE_SMC_CALL_WITH_RPC_ARG above */
 #define OPTEE_SMC_FUNCID_CALL_WITH_RPC_ARG	18
 
@@ -555,6 +571,29 @@ struct optee_smc_disable_shm_cache_result {
 #define OPTEE_SMC_RETURN_RPC_CMD \
 	OPTEE_SMC_RPC_VAL(OPTEE_SMC_RPC_FUNC_CMD)
 
+/*
+ * Do an OCall RPC request to caller client. The Ocall request ABI is very
+ * minimal: 2 input arguments and 2 output arguments. 1st output argument
+ * value 0 is reserved to error management requesting OCall termination.
+ * When 1st output argument is 0, 2nd output argument is either 0 or can
+ * carry a TEEC_Result like error code.
+ *
+ * "Call" register usage:
+ * a0	OPTEE_SMC_RETURN_RPC_OCALL2
+ * a1	OCall input argument 1 (32 bit)
+ * a2	OCall input argument 2 (32 bit)
+ * a3-7	Resume information, must be preserved
+ *
+ * "Return" register usage:
+ * a0	SMC Function ID, OPTEE_SMC_CALL_RETURN_FROM_RPC.
+ * a1	OCall output argument 1 (32 bit), value 0 upon error
+ * a2	OCall output argument 2 (32 bit), TEEC_Result error if @a1 is 0
+ * a3-7	Preserved
+ */
+#define OPTEE_SMC_RPC_FUNC_OCALL2		2048
+#define OPTEE_SMC_RETURN_RPC_OCALL2 \
+	OPTEE_SMC_RPC_VAL(OPTEE_SMC_RPC_FUNC_OCALL2)
+
 /* Returned in a0 */
 #define OPTEE_SMC_RETURN_UNKNOWN_FUNCTION 0xFFFFFFFF
 
diff --git a/drivers/tee/optee/smc_abi.c b/drivers/tee/optee/smc_abi.c
index e6e0428f8..f19692ea6 100644
--- a/drivers/tee/optee/smc_abi.c
+++ b/drivers/tee/optee/smc_abi.c
@@ -52,6 +52,23 @@
  */
 #define OPTEE_MIN_STATIC_POOL_ALIGN    9 /* 512 bytes aligned */
 
+/* SMC ABI considers at most a single TEE firmware */
+static unsigned int pcpu_irq_num;
+
+static int optee_cpuhp_enable_pcpu_irq(unsigned int cpu)
+{
+	enable_percpu_irq(pcpu_irq_num, IRQ_TYPE_NONE);
+
+	return 0;
+}
+
+static int optee_cpuhp_disable_pcpu_irq(unsigned int cpu)
+{
+	disable_percpu_irq(pcpu_irq_num);
+
+	return 0;
+}
+
 /*
  * 1. Convert between struct tee_param and struct optee_msg_param
  *
@@ -487,7 +504,7 @@ static int optee_shm_register(struct tee_context *ctx, struct tee_shm *shm,
 	msg_arg->params->u.tmem.buf_ptr = virt_to_phys(pages_list) |
 	  (tee_shm_get_page_offset(shm) & (OPTEE_MSG_NONCONTIG_PAGE_SIZE - 1));
 
-	if (optee->ops->do_call_with_arg(ctx, shm_arg, 0) ||
+	if (optee->ops->do_call_with_arg(ctx, shm_arg, 0, NULL) ||
 	    msg_arg->ret != TEEC_SUCCESS)
 		rc = -EINVAL;
 
@@ -530,7 +547,7 @@ static int optee_shm_unregister(struct tee_context *ctx, struct tee_shm *shm)
 	msg_arg->params[0].attr = OPTEE_MSG_ATTR_TYPE_RMEM_INPUT;
 	msg_arg->params[0].u.rmem.shm_ref = (unsigned long)shm;
 
-	if (optee->ops->do_call_with_arg(ctx, shm_arg, 0) ||
+	if (optee->ops->do_call_with_arg(ctx, shm_arg, 0, NULL) ||
 	    msg_arg->ret != TEEC_SUCCESS)
 		rc = -EINVAL;
 out:
@@ -853,6 +870,93 @@ static void optee_handle_rpc(struct tee_context *ctx,
 	param->a0 = OPTEE_SMC_CALL_RETURN_FROM_RPC;
 }
 
+static bool call_shall_wait(struct tee_context *ctx, bool *system_call)
+{
+	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct optee_thread *thd = &optee->thread;
+
+	bool wait = false;
+	unsigned long flags;
+
+	if (thd->best_effort)
+		return false;
+
+	spin_lock_irqsave(&thd->lock, flags);
+
+	if (*system_call && thd->system_thread_free_cnt) {
+		thd->system_thread_free_cnt--;
+		thd->thread_free_cnt--;
+	} else if (thd->thread_free_cnt > thd->system_thread_free_cnt) {
+		thd->thread_free_cnt--;
+		*system_call = false;
+	} else {
+		wait = true;
+	}
+
+	spin_unlock_irqrestore(&thd->lock, flags);
+
+	return wait;
+}
+
+static void call_completed(struct tee_context *ctx, bool system_call)
+{
+	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct optee_thread *thd = &optee->thread;
+	unsigned long flags;
+
+	if (thd->best_effort)
+		return;
+
+	spin_lock_irqsave(&thd->lock, flags);
+
+	thd->thread_free_cnt++;
+	if (system_call)
+		thd->system_thread_free_cnt++;
+
+	spin_unlock_irqrestore(&thd->lock, flags);
+}
+
+static void call_out_of_thread(struct tee_context *ctx, bool system_call)
+{
+	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct optee_thread *thd = &optee->thread;
+	unsigned long flags;
+
+	pr_warn("optee: unexpected thread limit reached\n");
+
+	spin_lock_irqsave(&thd->lock, flags);
+
+	/* Increment back counters since we did not use a thread */
+	thd->thread_free_cnt++;
+	if (system_call)
+		thd->system_thread_free_cnt++;
+
+	if (thd->thread_cnt <= 1) {
+		/* 1 thread in TEE, we can't do much: switch to best effort */
+		thd->best_effort = true;
+	} else {
+		/*
+		 * Expected free thread is missing: it has been lost by TEE's
+		 * previous client hence decrement thread count.
+		 */
+		thd->thread_cnt--;
+		thd->thread_free_cnt--;
+		pr_warn("optee: decrement max thread to %zu\n", thd->thread_cnt);
+
+		/*
+		 * If no enough thread to satisfy already provisioned system
+		 * threads, we can't do much about it: switch to best effort
+		 */
+		if (thd->system_thread_cnt > (thd->thread_cnt - 1))
+			thd->best_effort = true;
+	}
+
+	spin_unlock_irqrestore(&thd->lock, flags);
+
+	if (thd->best_effort)
+		pr_warn("optee: wrong thread count, switch to best effort\n");
+}
+
 /**
  * optee_smc_do_call_with_arg() - Do an SMC to OP-TEE in secure world
  * @ctx:	calling context
@@ -865,15 +969,32 @@ static void optee_handle_rpc(struct tee_context *ctx,
  * Returns return code from secure world, 0 is OK
  */
 static int optee_smc_do_call_with_arg(struct tee_context *ctx,
-				      struct tee_shm *shm, u_int offs)
+				      struct tee_shm *shm, u_int offs,
+				      struct optee_call_extra *extra)
 {
 	struct optee *optee = tee_get_drvdata(ctx->teedev);
-	struct optee_call_waiter w;
+	struct optee_call_waiter waiter;
+	struct optee_call_waiter *w = &waiter;
 	struct optee_rpc_param param = { };
 	struct optee_call_ctx call_ctx = { };
 	struct optee_msg_arg *rpc_arg = NULL;
+	bool do_system_call = extra && extra->system;
 	int rc;
 
+	if (extra) {
+		if (tee_ocall_is_used(extra->ocall_arg))
+			w = extra->ocall_call_waiter;
+
+		if (tee_ocall_in_progress(extra->ocall_arg)) {
+			/* We are returning to TEE from an Ocall in REE */
+			param.a0 = OPTEE_SMC_CALL_RETURN_FROM_RPC;
+			param.a1 = extra->ocall_arg->out_param1;
+			param.a2 = extra->ocall_arg->out_param2;
+			param.a3 = extra->tee_thread_id;
+			goto call_optee;
+		}
+	}
+
 	if (optee->rpc_param_count) {
 		struct optee_msg_arg *arg;
 		unsigned int rpc_arg_offs;
@@ -906,7 +1027,14 @@ static int optee_smc_do_call_with_arg(struct tee_context *ctx,
 		reg_pair_from_64(&param.a1, &param.a2, parg);
 	}
 	/* Initialize waiter */
-	optee_cq_wait_init(&optee->call_queue, &w);
+	optee_cq_wait_init(&optee->call_queue, w);
+
+	/* May wait for a thread to become available in secure world */
+	if (!optee->thread.best_effort)
+		while (call_shall_wait(ctx, &do_system_call))
+			optee_cq_wait_for_completion(&optee->call_queue, w);
+
+call_optee:
 	while (true) {
 		struct arm_smccc_res res;
 
@@ -917,13 +1045,42 @@ static int optee_smc_do_call_with_arg(struct tee_context *ctx,
 		trace_optee_invoke_fn_end(&param, &res);
 
 		if (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) {
+			if (optee->thread.best_effort) {
+				optee_cq_wait_for_completion(&optee->call_queue, w);
+			} else {
+				call_out_of_thread(ctx, do_system_call);
+
+				while (call_shall_wait(ctx, &do_system_call))
+					optee_cq_wait_for_completion(
+							&optee->call_queue, w);
+			}
+
 			/*
 			 * Out of threads in secure world, wait for a thread
 			 * become available.
 			 */
-			optee_cq_wait_for_completion(&optee->call_queue, &w);
+			while (call_shall_wait(ctx, &do_system_call))
+				optee_cq_wait_for_completion(&optee->call_queue, w);
+		} else if (res.a0 == OPTEE_SMC_RETURN_RPC_OCALL2) {
+			cond_resched();
+			if (extra && tee_ocall_is_used(extra->ocall_arg)) {
+				extra->ocall_arg->state = TEE_OCALL2_IN_PROGRESS;
+				extra->ocall_arg->in_param1 = res.a1;
+				extra->ocall_arg->in_param2 = res.a2;
+				extra->ocall_arg->out_param1 = TEE_OCALL2_OUT_PARAM1_ERROR;
+				extra->ocall_arg->out_param2 = 0;
+				extra->tee_thread_id = res.a3;
+
+				return -EAGAIN;
+			}
+
+			WARN_ONCE(1, "optee unexpected Ocall2\n");
+			param.a0 = OPTEE_SMC_CALL_RETURN_FROM_RPC;
+			param.a1 = TEE_OCALL2_OUT_PARAM1_ERROR;
+			param.a2 = 0;
 		} else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) {
 			cond_resched();
+
 			param.a0 = res.a0;
 			param.a1 = res.a1;
 			param.a2 = res.a2;
@@ -935,12 +1092,21 @@ static int optee_smc_do_call_with_arg(struct tee_context *ctx,
 		}
 	}
 
+	if (extra && tee_ocall_is_used(extra->ocall_arg)) {
+		w = extra->ocall_call_waiter;
+		extra->ocall_arg->state = TEE_OCALL2_IDLE;
+		extra->tee_thread_id = 0;
+	}
+
 	optee_rpc_finalize_call(&call_ctx);
+
+	call_completed(ctx, do_system_call);
+
 	/*
 	 * We're done with our thread in secure world, if there's any
 	 * thread waiters wake up one.
 	 */
-	optee_cq_wait_final(&optee->call_queue, &w);
+	optee_cq_wait_final(&optee->call_queue, w);
 
 	return rc;
 }
@@ -951,13 +1117,16 @@ static int simple_call_with_arg(struct tee_context *ctx, u32 cmd)
 	struct optee_msg_arg *msg_arg;
 	struct tee_shm *shm;
 	u_int offs;
+	int rc;
 
 	msg_arg = optee_get_msg_arg(ctx, 0, &entry, &shm, &offs);
 	if (IS_ERR(msg_arg))
 		return PTR_ERR(msg_arg);
 
 	msg_arg->cmd = cmd;
-	optee_smc_do_call_with_arg(ctx, shm, offs);
+
+	rc = optee_smc_do_call_with_arg(ctx, shm, offs, NULL);
+	WARN_ONCE(rc, "optee unexpected call error %d\n", rc);
 
 	optee_free_msg_arg(ctx, entry, offs);
 	return 0;
@@ -977,6 +1146,118 @@ static int optee_smc_stop_async_notif(struct tee_context *ctx)
  * 5. Asynchronous notification
  */
 
+static u32 get_it_value(optee_invoke_fn *invoke_fn, bool *value_valid,
+			bool *value_pending)
+{
+	struct arm_smccc_res res;
+
+	invoke_fn(OPTEE_SMC_GET_IT_NOTIF_VALUE, 0, 0, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0)
+		return 0;
+
+	*value_valid = res.a2 & OPTEE_SMC_IT_NOTIF_VALUE_VALID;
+	*value_pending = res.a2 & OPTEE_SMC_IT_NOTIF_VALUE_PENDING;
+	return res.a1;
+}
+
+static u32 set_it_mask(optee_invoke_fn *invoke_fn, u32 it_value, bool mask)
+{
+	struct arm_smccc_res res;
+
+	invoke_fn(OPTEE_SMC_SET_IT_NOTIF_MASK, it_value, mask, 0, 0, 0, 0, 0, &res);
+
+	if (res.a0)
+		return 0;
+
+	return res.a1;
+}
+
+static int handle_optee_it(struct optee *optee)
+{
+	bool value_valid;
+	bool value_pending;
+	u32 it;
+
+	do {
+		struct irq_desc *desc;
+
+		it = get_it_value(optee->smc.invoke_fn, &value_valid, &value_pending);
+		if (!value_valid)
+			break;
+
+		desc = irq_to_desc(irq_find_mapping(optee->smc.domain, it));
+		if (!desc) {
+			pr_err("no desc for optee IT:%d\n", it);
+			return -EIO;
+		}
+
+		handle_simple_irq(desc);
+
+	} while (value_pending);
+
+	return 0;
+}
+
+static void optee_it_irq_mask(struct irq_data *d)
+{
+	struct optee *optee = d->domain->host_data;
+
+	set_it_mask(optee->smc.invoke_fn, d->hwirq, true);
+}
+
+static void optee_it_irq_unmask(struct irq_data *d)
+{
+	struct optee *optee = d->domain->host_data;
+
+	set_it_mask(optee->smc.invoke_fn, d->hwirq, false);
+}
+
+static struct irq_chip optee_it_irq_chip = {
+	.name = "optee-it",
+	.irq_disable = optee_it_irq_mask,
+	.irq_enable = optee_it_irq_unmask,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static int optee_it_alloc(struct irq_domain *d, unsigned int virq,
+			  unsigned int nr_irqs, void *data)
+{
+	struct irq_fwspec *fwspec = data;
+	irq_hw_number_t hwirq;
+
+	hwirq = fwspec->param[0];
+
+	irq_domain_set_hwirq_and_chip(d, virq, hwirq, &optee_it_irq_chip, d->host_data);
+
+	return 0;
+}
+
+static const struct irq_domain_ops optee_it_irq_domain_ops = {
+	.alloc = optee_it_alloc,
+	.free = irq_domain_free_irqs_common,
+};
+
+static int optee_irq_domain_init(struct platform_device *pdev, struct optee *optee)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+
+	optee->smc.domain = irq_domain_add_linear(np, OPTEE_MAX_IT,
+						  &optee_it_irq_domain_ops, optee);
+	if (!optee->smc.domain) {
+		dev_err(dev, "Unable to add irq domain\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void optee_irq_domain_uninit(struct optee *optee)
+{
+	irq_domain_remove(optee->smc.domain);
+}
+
 static u32 get_async_notif_value(optee_invoke_fn *invoke_fn, bool *value_valid,
 				 bool *value_pending)
 {
@@ -993,22 +1274,22 @@ static u32 get_async_notif_value(optee_invoke_fn *invoke_fn, bool *value_valid,
 	return res.a1;
 }
 
-static irqreturn_t notif_irq_handler(int irq, void *dev_id)
+static irqreturn_t irq_handler(struct optee *optee)
 {
-	struct optee *optee = dev_id;
 	bool do_bottom_half = false;
 	bool value_valid;
 	bool value_pending;
 	u32 value;
 
 	do {
-		value = get_async_notif_value(optee->smc.invoke_fn,
-					      &value_valid, &value_pending);
+		value = get_async_notif_value(optee->smc.invoke_fn, &value_valid, &value_pending);
 		if (!value_valid)
 			break;
 
 		if (value == OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_BOTTOM_HALF)
 			do_bottom_half = true;
+		else if (value == OPTEE_SMC_ASYNC_NOTIF_VALUE_DO_IT)
+			handle_optee_it(optee);
 		else
 			optee_notif_send(optee, value);
 	} while (value_pending);
@@ -1018,6 +1299,13 @@ static irqreturn_t notif_irq_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t notif_irq_handler(int irq, void *dev_id)
+{
+	struct optee *optee = dev_id;
+
+	return irq_handler(optee);
+}
+
 static irqreturn_t notif_irq_thread_fn(int irq, void *dev_id)
 {
 	struct optee *optee = dev_id;
@@ -1027,7 +1315,7 @@ static irqreturn_t notif_irq_thread_fn(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int optee_smc_notif_init_irq(struct optee *optee, u_int irq)
+static int init_irq(struct optee *optee, u_int irq)
 {
 	int rc;
 
@@ -1042,12 +1330,103 @@ static int optee_smc_notif_init_irq(struct optee *optee, u_int irq)
 	return 0;
 }
 
+static irqreturn_t notif_pcpu_irq_handler(int irq, void *dev_id)
+{
+	struct optee_pcpu *pcpu = dev_id;
+	struct optee *optee = pcpu->optee;
+
+	if (irq_handler(optee) == IRQ_WAKE_THREAD)
+		queue_work(optee->smc.notif_pcpu_wq,
+			   &optee->smc.notif_pcpu_work);
+
+	return IRQ_HANDLED;
+}
+
+static void notif_pcpu_irq_work_fn(struct work_struct *work)
+{
+	struct optee_smc *optee_smc = container_of(work, struct optee_smc,
+						   notif_pcpu_work);
+	struct optee *optee = container_of(optee_smc, struct optee, smc);
+
+	optee_smc_do_bottom_half(optee->ctx);
+}
+
+static int init_pcpu_irq(struct optee *optee, u_int irq)
+{
+	struct optee_pcpu __percpu *optee_pcpu;
+	int cpu, rc;
+
+	optee_pcpu = alloc_percpu(struct optee_pcpu);
+	if (!optee_pcpu)
+		return -ENOMEM;
+
+	for_each_present_cpu(cpu)
+		per_cpu_ptr(optee_pcpu, cpu)->optee = optee;
+
+	rc = request_percpu_irq(irq, notif_pcpu_irq_handler,
+				"optee_pcpu_notification", optee_pcpu);
+	if (rc)
+		goto err_free_pcpu;
+
+	INIT_WORK(&optee->smc.notif_pcpu_work, notif_pcpu_irq_work_fn);
+	optee->smc.notif_pcpu_wq = create_workqueue("optee_pcpu_notification");
+	if (!optee->smc.notif_pcpu_wq) {
+		rc = -EINVAL;
+		goto err_free_pcpu_irq;
+	}
+
+	optee->smc.optee_pcpu = optee_pcpu;
+	optee->smc.notif_irq = irq;
+
+	pcpu_irq_num = irq;
+	rc = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "optee/pcpu-notif:starting",
+			       optee_cpuhp_enable_pcpu_irq,
+			       optee_cpuhp_disable_pcpu_irq);
+	if (!rc)
+		rc = -EINVAL;
+	if (rc < 0)
+		goto err_free_pcpu_irq;
+
+	optee->smc.notif_cpuhp_state = rc;
+
+	return 0;
+
+err_free_pcpu_irq:
+	free_percpu_irq(irq, optee_pcpu);
+err_free_pcpu:
+	free_percpu(optee_pcpu);
+
+	return rc;
+}
+
+static int optee_smc_notif_init_irq(struct optee *optee, u_int irq)
+{
+	if (irq_is_percpu_devid(irq))
+		return init_pcpu_irq(optee, irq);
+	else
+		return init_irq(optee, irq);
+}
+
+static void uninit_pcpu_irq(struct optee *optee)
+{
+	cpuhp_remove_state(optee->smc.notif_cpuhp_state);
+
+	destroy_workqueue(optee->smc.notif_pcpu_wq);
+
+	free_percpu_irq(optee->smc.notif_irq, optee->smc.optee_pcpu);
+	free_percpu(optee->smc.optee_pcpu);
+}
+
 static void optee_smc_notif_uninit_irq(struct optee *optee)
 {
 	if (optee->smc.sec_caps & OPTEE_SMC_SEC_CAP_ASYNC_NOTIF) {
 		optee_smc_stop_async_notif(optee->ctx);
 		if (optee->smc.notif_irq) {
-			free_irq(optee->smc.notif_irq, optee);
+			if (irq_is_percpu_devid(optee->smc.notif_irq))
+				uninit_pcpu_irq(optee);
+			else
+				free_irq(optee->smc.notif_irq, optee);
+
 			irq_dispose_mapping(optee->smc.notif_irq);
 		}
 	}
@@ -1079,12 +1458,109 @@ static void optee_get_version(struct tee_device *teedev,
 	*vers = v;
 }
 
+static void optee_get_thread_info(struct tee_context *ctx)
+{
+	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct optee_thread *thd = &optee->thread;
+	struct arm_smccc_res res;
+	unsigned long flags;
+
+	spin_lock_irqsave(&thd->lock, flags);
+	if (!thd->thread_cnt) {
+		optee->smc.invoke_fn(OPTEE_SMC_GET_THREAD_COUNT,
+				     0, 0, 0, 0, 0, 0, 0, &res);
+		if (!res.a0) {
+			thd->thread_cnt = res.a1;
+			thd->thread_free_cnt = res.a1;
+			thd->system_thread_cnt = 0;
+			thd->system_thread_free_cnt = 0;
+		}
+	}
+	spin_unlock_irqrestore(&thd->lock, flags);
+}
+
 static int optee_smc_open(struct tee_context *ctx)
 {
 	struct optee *optee = tee_get_drvdata(ctx->teedev);
 	u32 sec_caps = optee->smc.sec_caps;
+	int rc;
+
+	rc = optee_open(ctx, sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL);
+	if (!rc)
+		optee_get_thread_info(ctx);
+
+	return rc;
+}
+
+int optee_smc_close_session(struct tee_context *ctx, u32 session)
+{
+	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct optee_context_data *ctxdata = ctx->data;
+	struct optee_thread *thd = &optee->thread;
+	struct optee_session *sess;
+	bool system_session;
+	int rc;
+
+	mutex_lock(&ctxdata->mutex);
+	sess = optee_find_session(ctxdata, session);
+	mutex_unlock(&ctxdata->mutex);
+
+	if (!sess)
+		return -EINVAL;
+
+	system_session = (sess && sess->system);
+
+	rc = optee_close_session(ctx, session);
+
+	if (!rc && system_session && !thd->best_effort) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&thd->lock, flags);
+		thd->system_thread_cnt--;
+		thd->system_thread_free_cnt--;
+		spin_unlock_irqrestore(&thd->lock, flags);
+	}
+
+	return rc;
+}
+
+int optee_smc_system_session(struct tee_context *ctx, u32 session)
+{
+	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct optee_context_data *ctxdata = ctx->data;
+	struct optee_thread *thd = &optee->thread;
+	struct optee_session *sess;
+	int rc = -EINVAL;
+	unsigned long flags;
+
+	if (thd->best_effort)
+		return -EINVAL;
+
+	mutex_lock(&ctxdata->mutex);
+	sess = optee_find_session(ctxdata, session);
+
+	spin_lock_irqsave(&thd->lock, flags);
+	/* Leave at least 1 regular (non-system) thread context */
+	if (sess && !sess->system &&
+	    thd->system_thread_cnt < (thd->thread_cnt - 1)) {
+		thd->system_thread_cnt++;
+		thd->system_thread_free_cnt++;
+		sess->system = true;
+		rc = 0;
+	}
+	spin_unlock_irqrestore(&thd->lock, flags);
+
+	mutex_unlock(&ctxdata->mutex);
+
+	return rc;
+}
 
-	return optee_open(ctx, sec_caps & OPTEE_SMC_SEC_CAP_MEMREF_NULL);
+int optee_invoke_func_ocall2(struct tee_context *ctx,
+			     struct tee_ioctl_invoke_arg *arg,
+			     struct tee_param *param,
+			     struct tee_ocall2_arg *ocall_arg)
+{
+	return optee_invoke_func_helper(ctx, arg, param, ocall_arg);
 }
 
 static const struct tee_driver_ops optee_clnt_ops = {
@@ -1092,8 +1568,10 @@ static const struct tee_driver_ops optee_clnt_ops = {
 	.open = optee_smc_open,
 	.release = optee_release,
 	.open_session = optee_open_session,
-	.close_session = optee_close_session,
+	.close_session = optee_smc_close_session,
+	.system_session = optee_smc_system_session,
 	.invoke_func = optee_invoke_func,
+	.invoke_func_ocall2 = optee_invoke_func_ocall2,
 	.cancel_req = optee_cancel_req,
 	.shm_register = optee_shm_register,
 	.shm_unregister = optee_shm_unregister,
@@ -1331,6 +1809,8 @@ static int optee_smc_remove(struct platform_device *pdev)
 
 	optee_smc_notif_uninit_irq(optee);
 
+	optee_irq_domain_uninit(optee);
+
 	optee_remove_common(optee);
 
 	if (optee->smc.memremaped_shm)
@@ -1452,6 +1932,7 @@ static int optee_probe(struct platform_device *pdev)
 	optee->smc.invoke_fn = invoke_fn;
 	optee->smc.sec_caps = sec_caps;
 	optee->rpc_param_count = rpc_param_count;
+	spin_lock_init(&optee->thread.lock);
 
 	teedev = tee_device_alloc(&optee_clnt_desc, NULL, pool, optee);
 	if (IS_ERR(teedev)) {
@@ -1508,6 +1989,18 @@ static int optee_probe(struct platform_device *pdev)
 			irq_dispose_mapping(irq);
 			goto err_notif_uninit;
 		}
+
+		rc = optee_irq_domain_init(pdev, optee);
+		if (rc) {
+			if (irq_is_percpu_devid(optee->smc.notif_irq))
+				uninit_pcpu_irq(optee);
+			else
+				free_irq(optee->smc.notif_irq, optee);
+
+			irq_dispose_mapping(irq);
+			goto err_notif_uninit;
+		}
+
 		enable_async_notif(optee->smc.invoke_fn);
 		pr_info("Asynchronous notifications enabled\n");
 	}
diff --git a/drivers/tee/tee_core.c b/drivers/tee/tee_core.c
index 98da206cd..f1ef4267a 100644
--- a/drivers/tee/tee_core.c
+++ b/drivers/tee/tee_core.c
@@ -1170,6 +1170,13 @@ int tee_client_close_session(struct tee_context *ctx, u32 session)
 }
 EXPORT_SYMBOL_GPL(tee_client_close_session);
 
+int tee_client_system_session(struct tee_context *ctx, unsigned int session)
+{
+	if (!ctx->teedev->desc->ops->system_session)
+		return -EINVAL;
+	return ctx->teedev->desc->ops->system_session(ctx, session);
+}
+
 int tee_client_invoke_func(struct tee_context *ctx,
 			   struct tee_ioctl_invoke_arg *arg,
 			   struct tee_param *param)
@@ -1180,6 +1187,18 @@ int tee_client_invoke_func(struct tee_context *ctx,
 }
 EXPORT_SYMBOL_GPL(tee_client_invoke_func);
 
+int tee_client_invoke_func_ocall2(struct tee_context *ctx,
+				  struct tee_ioctl_invoke_arg *arg,
+				  struct tee_param *param,
+				  struct tee_ocall2_arg *ocall_arg)
+{
+	if (!ctx->teedev->desc->ops->invoke_func_ocall2)
+		return -EINVAL;
+	return ctx->teedev->desc->ops->invoke_func_ocall2(ctx, arg, param,
+							  ocall_arg);
+}
+EXPORT_SYMBOL_GPL(tee_client_invoke_func_ocall2);
+
 int tee_client_cancel_req(struct tee_context *ctx,
 			  struct tee_ioctl_cancel_arg *arg)
 {
diff --git a/drivers/thermal/st/stm_thermal.c b/drivers/thermal/st/stm_thermal.c
index 78feb802a..6554e5eea 100644
--- a/drivers/thermal/st/stm_thermal.c
+++ b/drivers/thermal/st/stm_thermal.c
@@ -82,8 +82,7 @@
 #define ONE_MHZ			1000000
 #define POLL_TIMEOUT		5000
 #define STARTUP_TIME		40
-#define TS1_T0_VAL0		30000  /* 30 celsius */
-#define TS1_T0_VAL1		130000 /* 130 celsius */
+#define T0			30000  /* 30 celsius */
 #define NO_HW_TRIG		0
 #define SAMPLING_TIME		15
 
@@ -96,7 +95,7 @@ struct stm_thermal_sensor {
 	unsigned int high_temp_enabled;
 	int irq;
 	void __iomem *base;
-	int t0, fmt0, ramp_coeff;
+	int fmt0, ramp_coeff;
 };
 
 static int stm_enable_irq(struct stm_thermal_sensor *sensor)
@@ -243,14 +242,6 @@ static int stm_thermal_calibration(struct stm_thermal_sensor *sensor)
 /* Fill in DTS structure with factory sensor values */
 static int stm_thermal_read_factory_settings(struct stm_thermal_sensor *sensor)
 {
-	/* Retrieve engineering calibration temperature */
-	sensor->t0 = readl_relaxed(sensor->base + DTS_T0VALR1_OFFSET) &
-					TS1_T0_MASK;
-	if (!sensor->t0)
-		sensor->t0 = TS1_T0_VAL0;
-	else
-		sensor->t0 = TS1_T0_VAL1;
-
 	/* Retrieve fmt0 and put it on Hz */
 	sensor->fmt0 = ADJUST * (readl_relaxed(sensor->base +
 				 DTS_T0VALR1_OFFSET) & TS1_FMT0_MASK);
@@ -264,8 +255,8 @@ static int stm_thermal_read_factory_settings(struct stm_thermal_sensor *sensor)
 		return -EINVAL;
 	}
 
-	dev_dbg(sensor->dev, "%s: T0 = %doC, FMT0 = %dHz, RAMP_COEFF = %dHz/oC",
-		__func__, sensor->t0, sensor->fmt0, sensor->ramp_coeff);
+	dev_dbg(sensor->dev, "%s: FMT0 = %dHz, RAMP_COEFF = %dHz/oC",
+		__func__, sensor->fmt0, sensor->ramp_coeff);
 
 	return 0;
 }
@@ -276,8 +267,7 @@ static int stm_thermal_calculate_threshold(struct stm_thermal_sensor *sensor,
 	int freqM;
 
 	/* Figure out the CLK_PTAT frequency for a given temperature */
-	freqM = ((temp - sensor->t0) * sensor->ramp_coeff) / 1000 +
-		sensor->fmt0;
+	freqM = ((temp - T0) * sensor->ramp_coeff) / 1000 + sensor->fmt0;
 
 	/* Figure out the threshold sample number */
 	*th = clk_get_rate(sensor->clk) * SAMPLING_TIME / freqM;
@@ -372,7 +362,7 @@ static int stm_thermal_get_temp(struct thermal_zone_device *tz, int *temp)
 		return -EINVAL;
 
 	/* Figure out the temperature in mili celsius */
-	*temp = (freqM - sensor->fmt0) * 1000 / sensor->ramp_coeff + sensor->t0;
+	*temp = (freqM - sensor->fmt0) * 1000 / sensor->ramp_coeff + T0;
 
 	return 0;
 }
@@ -515,11 +505,9 @@ static int stm_thermal_probe(struct platform_device *pdev)
 	sensor->base = base;
 
 	sensor->clk = devm_clk_get(&pdev->dev, "pclk");
-	if (IS_ERR(sensor->clk)) {
-		dev_err(&pdev->dev, "%s: failed to fetch PCLK clock\n",
-			__func__);
-		return PTR_ERR(sensor->clk);
-	}
+	if (IS_ERR(sensor->clk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(sensor->clk),
+				     "Failed to get PCLK clock\n");
 
 	stm_disable_irq(sensor);
 
diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 4dff2f34e..f79e3eceb 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -118,9 +118,6 @@ struct n_tty_data {
 	size_t read_tail;
 	size_t line_start;
 
-	/* # of chars looked ahead (to find software flow control chars) */
-	size_t lookahead_count;
-
 	/* protected by output lock */
 	unsigned int column;
 	unsigned int canon_column;
@@ -336,8 +333,6 @@ static void reset_buffer_flags(struct n_tty_data *ldata)
 	ldata->erasing = 0;
 	bitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);
 	ldata->push = 0;
-
-	ldata->lookahead_count = 0;
 }
 
 static void n_tty_packet_mode_flush(struct tty_struct *tty)
@@ -1230,30 +1225,12 @@ static bool n_tty_is_char_flow_ctrl(struct tty_struct *tty, unsigned char c)
 	return c == START_CHAR(tty) || c == STOP_CHAR(tty);
 }
 
-/**
- * n_tty_receive_char_flow_ctrl - receive flow control chars
- * @tty: terminal device
- * @c: character
- * @lookahead_done: lookahead has processed this character already
- *
- * Receive and process flow control character actions.
- *
- * In case lookahead for flow control chars already handled the character in
- * advance to the normal receive, the actions are skipped during normal
- * receive.
- *
- * Returns true if @c is consumed as flow-control character, the character
- * must not be treated as normal character.
- */
-static bool n_tty_receive_char_flow_ctrl(struct tty_struct *tty, unsigned char c,
-					 bool lookahead_done)
+/* Returns true if c is consumed as flow-control character */
+static bool n_tty_receive_char_flow_ctrl(struct tty_struct *tty, unsigned char c)
 {
 	if (!n_tty_is_char_flow_ctrl(tty, c))
 		return false;
 
-	if (lookahead_done)
-		return true;
-
 	if (c == START_CHAR(tty)) {
 		start_tty(tty);
 		process_echoes(tty);
@@ -1265,12 +1242,11 @@ static bool n_tty_receive_char_flow_ctrl(struct tty_struct *tty, unsigned char c
 	return true;
 }
 
-static void n_tty_receive_char_special(struct tty_struct *tty, unsigned char c,
-				       bool lookahead_done)
+static void n_tty_receive_char_special(struct tty_struct *tty, unsigned char c)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
-	if (I_IXON(tty) && n_tty_receive_char_flow_ctrl(tty, c, lookahead_done))
+	if (I_IXON(tty) && n_tty_receive_char_flow_ctrl(tty, c))
 		return;
 
 	if (L_ISIG(tty)) {
@@ -1425,8 +1401,7 @@ static void n_tty_receive_char(struct tty_struct *tty, unsigned char c)
 	put_tty_queue(c, ldata);
 }
 
-static void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c,
-				       bool lookahead_done)
+static void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c)
 {
 	if (I_ISTRIP(tty))
 		c &= 0x7f;
@@ -1434,10 +1409,12 @@ static void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c,
 		c = tolower(c);
 
 	if (I_IXON(tty)) {
-		if (!n_tty_receive_char_flow_ctrl(tty, c, lookahead_done) &&
-		    tty->flow.stopped && !tty->flow.tco_stopped && I_IXANY(tty) &&
-		    c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&
-		    c != SUSP_CHAR(tty)) {
+		if (c == STOP_CHAR(tty))
+			stop_tty(tty);
+		else if (c == START_CHAR(tty) ||
+			 (tty->flow.stopped && !tty->flow.tco_stopped && I_IXANY(tty) &&
+			  c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&
+			  c != SUSP_CHAR(tty))) {
 			start_tty(tty);
 			process_echoes(tty);
 		}
@@ -1480,27 +1457,6 @@ n_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)
 		n_tty_receive_char_flagged(tty, c, flag);
 }
 
-/* Caller must ensure count > 0 */
-static void n_tty_lookahead_flow_ctrl(struct tty_struct *tty, const unsigned char *cp,
-				      const unsigned char *fp, unsigned int count)
-{
-	struct n_tty_data *ldata = tty->disc_data;
-	unsigned char flag = TTY_NORMAL;
-
-	ldata->lookahead_count += count;
-
-	if (!I_IXON(tty))
-		return;
-
-	while (count--) {
-		if (fp)
-			flag = *fp++;
-		if (likely(flag == TTY_NORMAL))
-			n_tty_receive_char_flow_ctrl(tty, *cp, false);
-		cp++;
-	}
-}
-
 static void
 n_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,
 			   const char *fp, int count)
@@ -1540,7 +1496,7 @@ n_tty_receive_buf_raw(struct tty_struct *tty, const unsigned char *cp,
 
 static void
 n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
-			  const char *fp, int count, bool lookahead_done)
+			  const char *fp, int count)
 {
 	char flag = TTY_NORMAL;
 
@@ -1548,12 +1504,12 @@ n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
 		if (fp)
 			flag = *fp++;
 		if (likely(flag == TTY_NORMAL))
-			n_tty_receive_char_closing(tty, *cp++, lookahead_done);
+			n_tty_receive_char_closing(tty, *cp++);
 	}
 }
 
 static void n_tty_receive_buf_standard(struct tty_struct *tty,
-		const unsigned char *cp, const char *fp, int count, bool lookahead_done)
+		const unsigned char *cp, const char *fp, int count)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 	char flag = TTY_NORMAL;
@@ -1584,7 +1540,7 @@ static void n_tty_receive_buf_standard(struct tty_struct *tty,
 		}
 
 		if (test_bit(c, ldata->char_map))
-			n_tty_receive_char_special(tty, c, lookahead_done);
+			n_tty_receive_char_special(tty, c);
 		else
 			n_tty_receive_char(tty, c);
 	}
@@ -1595,30 +1551,21 @@ static void __receive_buf(struct tty_struct *tty, const unsigned char *cp,
 {
 	struct n_tty_data *ldata = tty->disc_data;
 	bool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));
-	size_t la_count = min_t(size_t, ldata->lookahead_count, count);
 
 	if (ldata->real_raw)
 		n_tty_receive_buf_real_raw(tty, cp, fp, count);
 	else if (ldata->raw || (L_EXTPROC(tty) && !preops))
 		n_tty_receive_buf_raw(tty, cp, fp, count);
-	else if (tty->closing && !L_EXTPROC(tty)) {
-		if (la_count > 0)
-			n_tty_receive_buf_closing(tty, cp, fp, la_count, true);
-		if (count > la_count)
-			n_tty_receive_buf_closing(tty, cp, fp, count - la_count, false);
-	} else {
-		if (la_count > 0)
-			n_tty_receive_buf_standard(tty, cp, fp, la_count, true);
-		if (count > la_count)
-			n_tty_receive_buf_standard(tty, cp, fp, count - la_count, false);
+	else if (tty->closing && !L_EXTPROC(tty))
+		n_tty_receive_buf_closing(tty, cp, fp, count);
+	else {
+		n_tty_receive_buf_standard(tty, cp, fp, count);
 
 		flush_echoes(tty);
 		if (tty->ops->flush_chars)
 			tty->ops->flush_chars(tty);
 	}
 
-	ldata->lookahead_count -= la_count;
-
 	if (ldata->icanon && !L_EXTPROC(tty))
 		return;
 
@@ -2516,7 +2463,6 @@ static struct tty_ldisc_ops n_tty_ops = {
 	.receive_buf     = n_tty_receive_buf,
 	.write_wakeup    = n_tty_write_wakeup,
 	.receive_buf2	 = n_tty_receive_buf2,
-	.lookahead_buf	 = n_tty_lookahead_flow_ctrl,
 };
 
 /**
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 12f685168..71951b543 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1410,7 +1410,7 @@ config SERIAL_STM32
 
 config SERIAL_STM32_CONSOLE
 	bool "Support for console on STM32"
-	depends on SERIAL_STM32=y
+	depends on SERIAL_STM32
 	select SERIAL_CORE_CONSOLE
 	select SERIAL_EARLYCON
 
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index f0ed30d0a..e307a7f5e 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -3431,6 +3431,16 @@ int uart_get_rs485_mode(struct uart_port *port)
 	if (!(port->rs485_supported.flags & SER_RS485_ENABLED))
 		return 0;
 
+	ret = device_property_read_u32_array(dev, "rs485-rts-delay-ns",
+					     rs485_delay, 2);
+	if (!ret) {
+		rs485conf->delay_rts_before_send_ns = rs485_delay[0];
+		rs485conf->delay_rts_after_send_ns = rs485_delay[1];
+	} else {
+		rs485conf->delay_rts_before_send_ns = 0;
+		rs485conf->delay_rts_after_send_ns = 0;
+	}
+
 	ret = device_property_read_u32_array(dev, "rs485-rts-delay",
 					     rs485_delay, 2);
 	if (!ret) {
@@ -3484,10 +3494,10 @@ EXPORT_SYMBOL_GPL(uart_get_rs485_mode);
 
 /* Compile-time assertions for serial_rs485 layout */
 static_assert(offsetof(struct serial_rs485, padding) ==
-              (offsetof(struct serial_rs485, delay_rts_after_send) + sizeof(__u32)));
+	      (offsetof(struct serial_rs485, delay_rts_after_send_ns) + sizeof(__u32)));
 static_assert(offsetof(struct serial_rs485, padding1) ==
 	      offsetof(struct serial_rs485, padding[1]));
-static_assert((offsetof(struct serial_rs485, padding[4]) + sizeof(__u32)) ==
+static_assert((offsetof(struct serial_rs485, padding[2]) + sizeof(__u32)) ==
 	      sizeof(struct serial_rs485));
 
 MODULE_DESCRIPTION("Serial driver core");
diff --git a/drivers/tty/serial/stm32-usart.c b/drivers/tty/serial/stm32-usart.c
index 2a9c40588..625a14efb 100644
--- a/drivers/tty/serial/stm32-usart.c
+++ b/drivers/tty/serial/stm32-usart.c
@@ -9,6 +9,7 @@
  * Inspired by st-asc.c from STMicroelectronics (c)
  */
 
+#include <linux/bitfield.h>
 #include <linux/clk.h>
 #include <linux/console.h>
 #include <linux/delay.h>
@@ -29,6 +30,7 @@
 #include <linux/serial.h>
 #include <linux/spinlock.h>
 #include <linux/sysrq.h>
+#include <linux/timer.h>
 #include <linux/tty_flip.h>
 #include <linux/tty.h>
 
@@ -39,60 +41,64 @@
 /* Register offsets */
 static struct stm32_usart_info __maybe_unused stm32f4_info = {
 	.ofs = {
-		.isr	= 0x00,
-		.rdr	= 0x04,
-		.tdr	= 0x04,
-		.brr	= 0x08,
-		.cr1	= 0x0c,
-		.cr2	= 0x10,
-		.cr3	= 0x14,
-		.gtpr	= 0x18,
-		.rtor	= UNDEF_REG,
-		.rqr	= UNDEF_REG,
-		.icr	= UNDEF_REG,
+		.isr		= 0x00,
+		.rdr		= 0x04,
+		.tdr		= 0x04,
+		.brr		= 0x08,
+		.cr1		= 0x0c,
+		.cr2		= 0x10,
+		.cr3		= 0x14,
+		.gtpr		= 0x18,
+		.rtor		= UNDEF_REG,
+		.rqr		= UNDEF_REG,
+		.icr		= UNDEF_REG,
+		.presc		= UNDEF_REG,
+		.hwcfgr1	= UNDEF_REG,
 	},
 	.cfg = {
 		.uart_enable_bit = 13,
 		.has_7bits_data = false,
-		.fifosize = 1,
 	}
 };
 
 static struct stm32_usart_info __maybe_unused stm32f7_info = {
 	.ofs = {
-		.cr1	= 0x00,
-		.cr2	= 0x04,
-		.cr3	= 0x08,
-		.brr	= 0x0c,
-		.gtpr	= 0x10,
-		.rtor	= 0x14,
-		.rqr	= 0x18,
-		.isr	= 0x1c,
-		.icr	= 0x20,
-		.rdr	= 0x24,
-		.tdr	= 0x28,
+		.cr1		= 0x00,
+		.cr2		= 0x04,
+		.cr3		= 0x08,
+		.brr		= 0x0c,
+		.gtpr		= 0x10,
+		.rtor		= 0x14,
+		.rqr		= 0x18,
+		.isr		= 0x1c,
+		.icr		= 0x20,
+		.rdr		= 0x24,
+		.tdr		= 0x28,
+		.presc		= UNDEF_REG,
+		.hwcfgr1	= UNDEF_REG,
 	},
 	.cfg = {
 		.uart_enable_bit = 0,
 		.has_7bits_data = true,
 		.has_swap = true,
-		.fifosize = 1,
 	}
 };
 
 static struct stm32_usart_info __maybe_unused stm32h7_info = {
 	.ofs = {
-		.cr1	= 0x00,
-		.cr2	= 0x04,
-		.cr3	= 0x08,
-		.brr	= 0x0c,
-		.gtpr	= 0x10,
-		.rtor	= 0x14,
-		.rqr	= 0x18,
-		.isr	= 0x1c,
-		.icr	= 0x20,
-		.rdr	= 0x24,
-		.tdr	= 0x28,
+		.cr1		= 0x00,
+		.cr2		= 0x04,
+		.cr3		= 0x08,
+		.brr		= 0x0c,
+		.gtpr		= 0x10,
+		.rtor		= 0x14,
+		.rqr		= 0x18,
+		.isr		= 0x1c,
+		.icr		= 0x20,
+		.rdr		= 0x24,
+		.tdr		= 0x28,
+		.presc		= 0x2c,
+		.hwcfgr1	= 0x3f0,
 	},
 	.cfg = {
 		.uart_enable_bit = 0,
@@ -100,7 +106,6 @@ static struct stm32_usart_info __maybe_unused stm32h7_info = {
 		.has_swap = true,
 		.has_wakeup = true,
 		.has_fifo = true,
-		.fifosize = 16,
 	}
 };
 
@@ -178,40 +183,67 @@ static void stm32_usart_rs485_rts_disable(struct uart_port *port)
 	}
 }
 
-static void stm32_usart_config_reg_rs485(u32 *cr1, u32 *cr3, u32 delay_ADE,
-					 u32 delay_DDE, u32 baud)
+static u32 stm32_usart_config_delay_rs485(u32 *cr1, u32 delay, u32 baud,
+					  bool over8, u32 rs485_deat_dedt_max,
+					  struct serial_rs485 *rs485conf)
 {
-	u32 rs485_deat_dedt;
+	u64 tmp;
+
+	/*
+	 * Compute (de)assertion time by using the delay (in ns), the baud rate
+	 * (in bits/s) and the oversampling (in 1/8 or 1/16 bit)
+	 */
+	tmp = (u64)delay * (u64)baud * 8ULL;
+
+	/* Handle oversampling 16 */
+	if (!over8)
+		tmp = tmp * 2ULL;
+
+	tmp = DIV_ROUND_CLOSEST_ULL(tmp, NSEC_PER_SEC);
+
+	/* Set delay to max value if result is higher than max value */
+	tmp = tmp > rs485_deat_dedt_max ? rs485_deat_dedt_max : tmp;
+
+	return tmp;
+}
+
+static void stm32_usart_config_reg_rs485(u32 *cr1, u32 *cr3,  u32 baud,
+					 struct serial_rs485 *rs485conf)
+{
+	u32 delay_ADE, delay_DDE, rs485_deat_dedt;
 	u32 rs485_deat_dedt_max = (USART_CR1_DEAT_MASK >> USART_CR1_DEAT_SHIFT);
 	bool over8;
+	u32 tmp;
+
+	/*
+	 * Assertion and deassertion delays (in ns) are computed by the
+	 * selection of rs485-rts-delay-ns (in ns) or rs485-rts-delay (in ms)
+	 * provided by device tree
+	 */
+	if (rs485conf->delay_rts_before_send_ns != 0 ||
+	    rs485conf->delay_rts_after_send_ns != 0) {
+		delay_ADE = rs485conf->delay_rts_before_send_ns;
+		delay_DDE = rs485conf->delay_rts_after_send_ns;
+	} else {
+		delay_ADE = rs485conf->delay_rts_before_send * NSEC_PER_MSEC;
+		delay_DDE = rs485conf->delay_rts_after_send * NSEC_PER_MSEC;
+	}
 
 	*cr3 |= USART_CR3_DEM;
 	over8 = *cr1 & USART_CR1_OVER8;
 
 	*cr1 &= ~(USART_CR1_DEDT_MASK | USART_CR1_DEAT_MASK);
 
-	if (over8)
-		rs485_deat_dedt = delay_ADE * baud * 8;
-	else
-		rs485_deat_dedt = delay_ADE * baud * 16;
-
-	rs485_deat_dedt = DIV_ROUND_CLOSEST(rs485_deat_dedt, 1000);
-	rs485_deat_dedt = rs485_deat_dedt > rs485_deat_dedt_max ?
-			  rs485_deat_dedt_max : rs485_deat_dedt;
-	rs485_deat_dedt = (rs485_deat_dedt << USART_CR1_DEAT_SHIFT) &
-			   USART_CR1_DEAT_MASK;
+	/* Assertion time */
+	tmp = stm32_usart_config_delay_rs485(cr1, delay_ADE, baud, over8,
+					     rs485_deat_dedt_max, rs485conf);
+	rs485_deat_dedt = (tmp << USART_CR1_DEAT_SHIFT) & USART_CR1_DEAT_MASK;
 	*cr1 |= rs485_deat_dedt;
 
-	if (over8)
-		rs485_deat_dedt = delay_DDE * baud * 8;
-	else
-		rs485_deat_dedt = delay_DDE * baud * 16;
-
-	rs485_deat_dedt = DIV_ROUND_CLOSEST(rs485_deat_dedt, 1000);
-	rs485_deat_dedt = rs485_deat_dedt > rs485_deat_dedt_max ?
-			  rs485_deat_dedt_max : rs485_deat_dedt;
-	rs485_deat_dedt = (rs485_deat_dedt << USART_CR1_DEDT_SHIFT) &
-			   USART_CR1_DEDT_MASK;
+	/* Deassertion time */
+	tmp = stm32_usart_config_delay_rs485(cr1, delay_DDE, baud, over8,
+					     rs485_deat_dedt_max, rs485conf);
+	rs485_deat_dedt = (tmp << USART_CR1_DEDT_SHIFT) & USART_CR1_DEDT_MASK;
 	*cr1 |= rs485_deat_dedt;
 }
 
@@ -240,10 +272,7 @@ static int stm32_usart_config_rs485(struct uart_port *port, struct ktermios *ter
 				   << USART_BRR_04_R_SHIFT;
 
 		baud = DIV_ROUND_CLOSEST(port->uartclk, usartdiv);
-		stm32_usart_config_reg_rs485(&cr1, &cr3,
-					     rs485conf->delay_rts_before_send,
-					     rs485conf->delay_rts_after_send,
-					     baud);
+		stm32_usart_config_reg_rs485(&cr1, &cr3, baud, rs485conf);
 
 		if (rs485conf->flags & SER_RS485_RTS_ON_SEND)
 			cr3 &= ~USART_CR3_DEP;
@@ -285,15 +314,215 @@ static int stm32_usart_init_rs485(struct uart_port *port,
 	return uart_get_rs485_mode(port);
 }
 
-static bool stm32_usart_rx_dma_enabled(struct uart_port *port)
+static int stm32_usart_config_iso7816(struct uart_port *port, struct serial_iso7816 *iso7816)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	const struct stm32_usart_config *cfg = &stm32_port->info->cfg;
+	struct stm32_backup_regs *bkp_regs = &stm32_port->bkp_regs;
+	struct stm32_backup_regs regs;
+	u32 isr, max_sclk, sclk, baud, usartdiv;
+	u8 psc;
+	int ret = 0;
 
-	if (!stm32_port->rx_ch)
-		return false;
+	ret = readl_relaxed_poll_timeout_atomic(port->membase + ofs->isr, isr, (isr & USART_SR_TC),
+						10, 100000);
+	if (ret)
+		dev_err(port->dev, "Transmission is not complete\n");
+
+	stm32_usart_clr_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));
+
+	regs.cr1 = readl_relaxed(port->membase + ofs->cr1);
+	regs.cr2 = readl_relaxed(port->membase + ofs->cr2);
+	regs.cr3 = readl_relaxed(port->membase + ofs->cr3);
+	regs.gtpr = readl_relaxed(port->membase + ofs->gtpr);
+	regs.brr = readl_relaxed(port->membase + ofs->brr);
+
+	if (!(port->iso7816.flags & SER_ISO7816_ENABLED)) {
+		memcpy(bkp_regs, &regs, sizeof(struct stm32_backup_regs));
+		goto deinit_iso7816_config;
+	}
+
+	if (stm32_port->tx_ch || stm32_port->rx_ch) {
+		dev_err(port->dev, "DMA should be disabled before enabling smart-card.\n");
+		ret = -EACCES;
+		goto deinit_iso7816_config;
+	}
 
-	return !!(readl_relaxed(port->membase + ofs->cr3) & USART_CR3_DMAR);
+	/* Configure USART in smartcard mode */
+	regs.cr3 |= USART_CR3_SCEN;
+	regs.cr3 &= ~USART_CR3_HDSEL;
+	regs.cr3 &= ~USART_CR3_IREN;
+	regs.cr2 &= ~USART_CR2_LINEN;
+
+	/* 8 bit word and 1.5 stop bits */
+	regs.cr1 &= ~USART_CR1_M1;
+	regs.cr1 |= USART_CR1_M0;
+	regs.cr1 |= USART_CR1_PCE;
+	regs.cr1 &= ~USART_CR1_OVER8;
+	regs.cr2 |= USART_CR2_STOP_MASK;
+
+	/* Auto-retry count = 3 */
+	regs.cr3 &= ~USART_CR3_SCARCNT_MASK;
+	regs.cr3 |= FIELD_PREP(USART_CR3_SCARCNT_MASK, 3);
+
+	/* Guard time set-up */
+	if (FIELD_FIT(USART_GTPR_GT_MASK, iso7816->tg)) {
+		regs.gtpr &= ~USART_GTPR_GT_MASK;
+		regs.gtpr |= FIELD_PREP(USART_GTPR_GT_MASK, iso7816->tg);
+		dev_dbg(port->dev, "iso7816: gtpr=0x%X\n", regs.gtpr);
+	} else {
+		dev_err(port->dev, "Guard time value is too high.\n");
+		ret = -ERANGE;
+		goto deinit_iso7816_config;
+	}
+
+	/* Smartcard clock setup */
+	if (iso7816->clk == 0) {
+		dev_err(port->dev, "iso7816: invalid clock.\n");
+		ret = -EINVAL;
+		goto deinit_iso7816_config;
+	}
+	max_sclk = DIV_ROUND_CLOSEST(port->uartclk, 2);
+	if (iso7816->clk > max_sclk)
+		sclk = max_sclk;
+	else
+		sclk = iso7816->clk;
+
+	psc = DIV_ROUND_CLOSEST(port->uartclk, (sclk * 2));
+	if (psc > USART_GTPR_PSC_SMART_MASK) {
+		psc = USART_GTPR_PSC_SMART_MASK;
+		sclk = DIV_ROUND_CLOSEST(port->uartclk, (psc * 2));
+	}
+	sclk = DIV_ROUND_CLOSEST(port->uartclk, (psc * 2));
+	if (sclk > iso7816->clk)
+		psc += 1;
+	sclk = DIV_ROUND_CLOSEST(port->uartclk, (psc * 2));
+	iso7816->clk = sclk;
+	regs.gtpr |= FIELD_PREP(USART_GTPR_PSC_SMART_MASK, psc);
+	regs.cr2 |= USART_CR2_CLKEN;
+
+	dev_dbg(port->dev, "iso7816: psc=0x%X\n", psc);
+	dev_dbg(port->dev, "iso7816: sclk=%u\n", sclk);
+
+	/* Uart baudrate setup */
+	if (iso7816->sc_fi == 0) {
+		dev_err(port->dev, "iso7816: invalid Fi.\n");
+		ret = -ERANGE;
+		goto deinit_iso7816_config;
+	}
+	baud = DIV_ROUND_CLOSEST(iso7816->clk * iso7816->sc_di, iso7816->sc_fi);
+	usartdiv = DIV_ROUND_CLOSEST(port->uartclk, baud);
+	if (FIELD_FIT(USART_BRR_MASK, usartdiv)) {
+		regs.brr = FIELD_PREP(USART_BRR_MASK, usartdiv);
+	} else {
+		dev_err(port->dev, "iso7816: Di Fi ratio value is too low.\n");
+		ret = -ERANGE;
+		goto deinit_iso7816_config;
+	}
+
+	dev_dbg(port->dev, "iso7816: baud=%u\n", baud);
+	dev_dbg(port->dev, "iso7816: brr=0x%X\n", regs.brr);
+
+	if ((iso7816->flags & SER_ISO7816_T_PARAM) == SER_ISO7816_T(0)) {
+		/* Enable NACK */
+		regs.cr3 |= USART_CR3_NACK;
+	} else if ((iso7816->flags & SER_ISO7816_T_PARAM) == SER_ISO7816_T(1)) {
+		/* Disable NACK */
+		regs.cr3 &= ~USART_CR3_SCARCNT_MASK;
+		regs.cr3 &= ~USART_CR3_NACK;
+	} else {
+		dev_err(port->dev, "iso7816: invalid T.\n");
+		ret = -EINVAL;
+		goto deinit_iso7816_config;
+	}
+
+	writel_relaxed(regs.gtpr, port->membase + ofs->gtpr);
+	writel_relaxed(regs.brr, port->membase + ofs->brr);
+	writel_relaxed(regs.cr3, port->membase + ofs->cr3);
+	writel_relaxed(regs.cr2, port->membase + ofs->cr2);
+	writel_relaxed(regs.cr1, port->membase + ofs->cr1);
+
+deinit_iso7816_config:
+	if ((!(iso7816->flags & SER_ISO7816_ENABLED) || ret) &&
+	    (port->iso7816.flags & SER_ISO7816_ENABLED)) {
+		writel_relaxed(bkp_regs->cr1, port->membase + ofs->cr1);
+		writel_relaxed(bkp_regs->cr2, port->membase + ofs->cr2);
+		writel_relaxed(bkp_regs->cr3, port->membase + ofs->cr3);
+		writel_relaxed(bkp_regs->gtpr, port->membase + ofs->gtpr);
+		writel_relaxed(bkp_regs->brr, port->membase + ofs->brr);
+		memset(bkp_regs, 0, sizeof(struct stm32_backup_regs));
+		memset(iso7816, 0, sizeof(struct serial_iso7816));
+		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_TCBGTIE);
+	}
+
+	port->iso7816 = *iso7816;
+	stm32_usart_set_bits(port, ofs->cr1, BIT(cfg->uart_enable_bit));
+
+	return ret;
+}
+
+static bool stm32_usart_iso7816_enabled(struct stm32_port *stm32_port)
+{
+	return stm32_port->port.iso7816.flags &&
+		(stm32_port->port.iso7816.flags & SER_ISO7816_ENABLED);
+}
+
+static bool stm32_usart_rx_dma_started(struct stm32_port *stm32_port)
+{
+	return stm32_port->rx_ch ? stm32_port->rx_dma_busy : false;
+}
+
+static void stm32_usart_rx_dma_terminate(struct stm32_port *stm32_port)
+{
+	dmaengine_terminate_async(stm32_port->rx_ch);
+	stm32_port->rx_dma_busy = false;
+	if (!stm32_port->has_rtor)
+		del_timer(&stm32_port->rx_dma_timer);
+}
+
+static int stm32_usart_dma_pause_resume(struct stm32_port *stm32_port,
+					struct dma_chan *chan,
+					enum dma_status expected_status,
+					int (*dma_action)(struct dma_chan *chan),
+					bool (*dma_started)(struct stm32_port *stm32_port),
+					void (*dma_terminate)(struct stm32_port *stm32_port))
+{
+	struct uart_port *port = &stm32_port->port;
+	enum dma_status dma_status;
+	int ret;
+
+	if (!(*dma_started)(stm32_port))
+		return -EPERM;
+
+	dma_status = dmaengine_tx_status(chan, chan->cookie, NULL);
+	if (dma_status != expected_status)
+		return -EAGAIN;
+
+	ret = (*dma_action)(chan);
+	if (ret) {
+		dev_err(port->dev, "DMA failed with error code: %d\n", ret);
+		(*dma_terminate)(stm32_port);
+	}
+	return ret;
+}
+
+static int stm32_usart_rx_dma_pause(struct stm32_port *stm32_port)
+{
+	if (!stm32_port->has_rtor)
+		del_timer(&stm32_port->rx_dma_timer);
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->rx_ch,
+					    DMA_IN_PROGRESS, dmaengine_pause,
+					    stm32_usart_rx_dma_started,
+					    stm32_usart_rx_dma_terminate);
+}
+
+static int stm32_usart_rx_dma_resume(struct stm32_port *stm32_port)
+{
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->rx_ch,
+					    DMA_PAUSED, dmaengine_resume,
+					    stm32_usart_rx_dma_started,
+					    stm32_usart_rx_dma_terminate);
 }
 
 /* Return true when data is pending (in pio mode), and false when no data is pending. */
@@ -306,7 +535,7 @@ static bool stm32_usart_pending_rx_pio(struct uart_port *port, u32 *sr)
 	/* Get pending characters in RDR or FIFO */
 	if (*sr & USART_SR_RXNE) {
 		/* Get all pending characters from the RDR or the FIFO when using interrupts */
-		if (!stm32_usart_rx_dma_enabled(port))
+		if (!stm32_usart_rx_dma_started(stm32_port))
 			return true;
 
 		/* Handle only RX data errors when using DMA */
@@ -452,11 +681,12 @@ static unsigned int stm32_usart_receive_chars(struct uart_port *port, bool force
 	u32 sr;
 	unsigned int size = 0;
 
-	if (stm32_usart_rx_dma_enabled(port) || force_dma_flush) {
+	if (stm32_usart_rx_dma_started(stm32_port) || force_dma_flush) {
 		rx_dma_status = dmaengine_tx_status(stm32_port->rx_ch,
 						    stm32_port->rx_ch->cookie,
 						    &stm32_port->rx_dma_state);
-		if (rx_dma_status == DMA_IN_PROGRESS) {
+		if (rx_dma_status == DMA_IN_PROGRESS ||
+		    rx_dma_status == DMA_PAUSED) {
 			/* Empty DMA buffer */
 			size = stm32_usart_receive_chars_dma(port);
 			sr = readl_relaxed(port->membase + ofs->isr);
@@ -472,8 +702,7 @@ static unsigned int stm32_usart_receive_chars(struct uart_port *port, bool force
 			}
 		} else {
 			/* Disable RX DMA */
-			dmaengine_terminate_async(stm32_port->rx_ch);
-			stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);
+			stm32_usart_rx_dma_terminate(stm32_port);
 			/* Fall back to interrupt mode */
 			dev_dbg(port->dev, "DMA error, fallback to irq mode\n");
 			size = stm32_usart_receive_chars_pio(port);
@@ -485,6 +714,91 @@ static unsigned int stm32_usart_receive_chars(struct uart_port *port, bool force
 	return size;
 }
 
+static void stm32_usart_rx_dma_complete(void *arg)
+{
+	struct uart_port *port = arg;
+	struct stm32_port *stm32port = to_stm32_port(port);
+	struct tty_port *tport = &port->state->port;
+	unsigned int size;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+	size = stm32_usart_receive_chars(port, false);
+	uart_unlock_and_check_sysrq_irqrestore(port, flags);
+	if (size)
+		tty_flip_buffer_push(tport);
+	if (!stm32port->has_rtor)
+		mod_timer(&stm32port->rx_dma_timer,
+			  jiffies + msecs_to_jiffies(LPUART_RECEIVE_TIMEOUT_MS));
+}
+
+static void stm32_usart_rx_dma_timer_callback(struct timer_list *timer)
+{
+	struct stm32_port *stm32port = from_timer(stm32port, timer, rx_dma_timer);
+
+	stm32_usart_rx_dma_complete(&stm32port->port);
+}
+
+static int stm32_usart_rx_dma_start_or_resume(struct uart_port *port)
+{
+	struct stm32_port *stm32_port = to_stm32_port(port);
+	struct dma_async_tx_descriptor *desc;
+	enum dma_status rx_dma_status;
+	int ret;
+
+	if (stm32_port->throttled)
+		return 0;
+
+	if (stm32_port->rx_dma_busy) {
+		rx_dma_status = dmaengine_tx_status(stm32_port->rx_ch,
+						    stm32_port->rx_ch->cookie,
+						    NULL);
+		if (rx_dma_status == DMA_IN_PROGRESS)
+			return 0;
+
+		if (rx_dma_status == DMA_PAUSED && !stm32_usart_rx_dma_resume(stm32_port))
+			return 0;
+
+		dev_err(port->dev, "DMA failed : status error.\n");
+		stm32_usart_rx_dma_terminate(stm32_port);
+	}
+
+	stm32_port->rx_dma_busy = true;
+
+	stm32_port->last_res = RX_BUF_L;
+	/* Prepare a DMA cyclic transaction */
+	desc = dmaengine_prep_dma_cyclic(stm32_port->rx_ch,
+					 stm32_port->rx_dma_buf,
+					 RX_BUF_L, RX_BUF_P,
+					 DMA_DEV_TO_MEM,
+					 DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(port->dev, "rx dma prep cyclic failed\n");
+		stm32_port->rx_dma_busy = false;
+		return -ENODEV;
+	}
+
+	desc->callback = stm32_usart_rx_dma_complete;
+	desc->callback_param = port;
+
+	/* Push current DMA transaction in the pending queue */
+	ret = dma_submit_error(dmaengine_submit(desc));
+	if (ret) {
+		dmaengine_terminate_sync(stm32_port->rx_ch);
+		stm32_port->rx_dma_busy = false;
+		return ret;
+	}
+
+	if (!stm32_port->has_rtor)
+		mod_timer(&stm32_port->rx_dma_timer,
+			  jiffies + msecs_to_jiffies(LPUART_RECEIVE_TIMEOUT_MS));
+
+	/* Issue pending DMA requests */
+	dma_async_issue_pending(stm32_port->rx_ch);
+
+	return 0;
+}
+
 static void stm32_usart_tx_dma_terminate(struct stm32_port *stm32_port)
 {
 	dmaengine_terminate_async(stm32_port->tx_ch);
@@ -503,21 +817,28 @@ static bool stm32_usart_tx_dma_started(struct stm32_port *stm32_port)
 	return stm32_port->tx_dma_busy;
 }
 
-static bool stm32_usart_tx_dma_enabled(struct stm32_port *stm32_port)
+static int stm32_usart_tx_dma_pause(struct stm32_port *stm32_port)
 {
-	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->tx_ch,
+					    DMA_IN_PROGRESS, dmaengine_pause,
+					    stm32_usart_tx_dma_started,
+					    stm32_usart_tx_dma_terminate);
+}
 
-	return !!(readl_relaxed(stm32_port->port.membase + ofs->cr3) & USART_CR3_DMAT);
+static int stm32_usart_tx_dma_resume(struct stm32_port *stm32_port)
+{
+	return stm32_usart_dma_pause_resume(stm32_port, stm32_port->tx_ch,
+					    DMA_PAUSED, dmaengine_resume,
+					    stm32_usart_tx_dma_started,
+					    stm32_usart_tx_dma_terminate);
 }
 
 static void stm32_usart_tx_dma_complete(void *arg)
 {
 	struct uart_port *port = arg;
 	struct stm32_port *stm32port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
 	unsigned long flags;
 
-	stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
 	stm32_usart_tx_dma_terminate(stm32port);
 
 	/* Let's see if we have pending data to send */
@@ -549,20 +870,6 @@ static void stm32_usart_tc_interrupt_enable(struct uart_port *port)
 	stm32_usart_set_bits(port, ofs->cr1, USART_CR1_TCIE);
 }
 
-static void stm32_usart_rx_dma_complete(void *arg)
-{
-	struct uart_port *port = arg;
-	struct tty_port *tport = &port->state->port;
-	unsigned int size;
-	unsigned long flags;
-
-	spin_lock_irqsave(&port->lock, flags);
-	size = stm32_usart_receive_chars(port, false);
-	uart_unlock_and_check_sysrq_irqrestore(port, flags);
-	if (size)
-		tty_flip_buffer_push(tport);
-}
-
 static void stm32_usart_tx_interrupt_disable(struct uart_port *port)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
@@ -588,8 +895,8 @@ static void stm32_usart_transmit_chars_pio(struct uart_port *port)
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	struct circ_buf *xmit = &port->state->xmit;
 
-	if (stm32_usart_tx_dma_enabled(stm32_port))
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+	if (!uart_circ_empty(xmit) && stm32_usart_iso7816_enabled(stm32_port))
+		stm32_usart_set_bits(port, ofs->cr3, USART_CR3_TCBGTIE);
 
 	while (!uart_circ_empty(xmit)) {
 		/* Check that TDR is empty before filling FIFO */
@@ -610,14 +917,15 @@ static void stm32_usart_transmit_chars_pio(struct uart_port *port)
 static void stm32_usart_transmit_chars_dma(struct uart_port *port)
 {
 	struct stm32_port *stm32port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
 	struct circ_buf *xmit = &port->state->xmit;
 	struct dma_async_tx_descriptor *desc = NULL;
 	unsigned int count;
+	int ret;
 
 	if (stm32_usart_tx_dma_started(stm32port)) {
-		if (!stm32_usart_tx_dma_enabled(stm32port))
-			stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAT);
+		ret = stm32_usart_tx_dma_resume(stm32port);
+		if (ret < 0 && ret != -EAGAIN)
+			goto fallback_err;
 		return;
 	}
 
@@ -662,8 +970,10 @@ static void stm32_usart_transmit_chars_dma(struct uart_port *port)
 	desc->callback_param = port;
 
 	/* Push current DMA TX transaction in the pending queue */
-	if (dma_submit_error(dmaengine_submit(desc))) {
-		/* dma no yet started, safe to free resources */
+	/* DMA no yet started, safe to free resources */
+	ret = dma_submit_error(dmaengine_submit(desc));
+	if (ret) {
+		dev_err(port->dev, "DMA failed with error code: %d\n", ret);
 		stm32_usart_tx_dma_terminate(stm32port);
 		goto fallback_err;
 	}
@@ -671,8 +981,6 @@ static void stm32_usart_transmit_chars_dma(struct uart_port *port)
 	/* Issue pending DMA TX requests */
 	dma_async_issue_pending(stm32port->tx_ch);
 
-	stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAT);
-
 	xmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);
 	port->icount.tx += count;
 	return;
@@ -698,9 +1006,8 @@ static void stm32_usart_transmit_chars(struct uart_port *port)
 	}
 
 	if (port->x_char) {
-		if (stm32_usart_tx_dma_started(stm32_port) &&
-		    stm32_usart_tx_dma_enabled(stm32_port))
-			stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+		/* dma terminate may have been called in case of dma pause failure */
+		stm32_usart_tx_dma_pause(stm32_port);
 
 		/* Check that TDR is empty before filling FIFO */
 		ret =
@@ -714,8 +1021,9 @@ static void stm32_usart_transmit_chars(struct uart_port *port)
 		writel_relaxed(port->x_char, port->membase + ofs->tdr);
 		port->x_char = 0;
 		port->icount.tx++;
-		if (stm32_usart_tx_dma_started(stm32_port))
-			stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAT);
+
+		/* dma terminate may have been called in case of dma resume failure */
+		stm32_usart_tx_dma_resume(stm32_port);
 		return;
 	}
 
@@ -753,10 +1061,12 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 	struct tty_port *tport = &port->state->port;
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
-	u32 sr;
+	u32 sr, cr1, cr3;
 	unsigned int size;
 
 	sr = readl_relaxed(port->membase + ofs->isr);
+	cr1 = readl_relaxed(port->membase + ofs->cr1);
+	cr3 = readl_relaxed(port->membase + ofs->cr3);
 
 	if (!stm32_port->hw_flow_control &&
 	    port->rs485.flags & SER_RS485_ENABLED &&
@@ -769,27 +1079,34 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 		writel_relaxed(USART_ICR_RTOCF,
 			       port->membase + ofs->icr);
 
-	if ((sr & USART_SR_WUF) && ofs->icr != UNDEF_REG) {
-		/* Clear wake up flag and disable wake up interrupt */
-		writel_relaxed(USART_ICR_WUCF,
-			       port->membase + ofs->icr);
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_WUFIE);
-		if (irqd_is_wakeup_set(irq_get_irq_data(port->irq)))
-			pm_wakeup_event(tport->tty->dev, 0);
+	if (irqd_is_wakeup_set(irq_get_irq_data(port->irq)) &&
+	    (cr1 & USART_CR1_RXNEIE) && (sr & USART_SR_RXNE)) {
+		stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_RXNEIE);
+		pm_wakeup_event(tport->tty->dev, 0);
 	}
 
-	/*
-	 * rx errors in dma mode has to be handled ASAP to avoid overrun as the DMA request
-	 * line has been masked by HW and rx data are stacking in FIFO.
-	 */
-	if (!stm32_port->throttled) {
-		if (((sr & USART_SR_RXNE) && !stm32_usart_rx_dma_enabled(port)) ||
-		    ((sr & USART_SR_ERR_MASK) && stm32_usart_rx_dma_enabled(port))) {
-			spin_lock(&port->lock);
-			size = stm32_usart_receive_chars(port, false);
-			uart_unlock_and_check_sysrq(port);
-			if (size)
-				tty_flip_buffer_push(tport);
+	/* Don't process rx in iso7816 mode while tx is in progress */
+	if (stm32_usart_iso7816_enabled(stm32_port) && (cr3 & USART_CR3_TCBGTIE)) {
+		if ((sr & USART_SR_TCBGT) && ofs->icr != UNDEF_REG) {
+			writel_relaxed(USART_ICR_TCBGTCF, port->membase + ofs->icr);
+			stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_TCBGTIE);
+		}
+		/* Discard rx which contains tx echo */
+		stm32_usart_set_bits(port, ofs->rqr, USART_RQR_RXFRQ);
+	} else {
+		/*
+		 * rx errors in dma mode has to be handled ASAP to avoid overrun as the DMA request
+		 * line has been masked by HW and rx data are stacking in FIFO.
+		 */
+		if (!stm32_port->throttled) {
+			if (((sr & USART_SR_RXNE) && !stm32_usart_rx_dma_started(stm32_port)) ||
+			    ((sr & USART_SR_ERR_MASK) && stm32_usart_rx_dma_started(stm32_port))) {
+				spin_lock(&port->lock);
+				size = stm32_usart_receive_chars(port, false);
+				uart_unlock_and_check_sysrq(port);
+				if (size)
+					tty_flip_buffer_push(tport);
+			}
 		}
 	}
 
@@ -800,7 +1117,7 @@ static irqreturn_t stm32_usart_interrupt(int irq, void *ptr)
 	}
 
 	/* Receiver timeout irq for DMA RX */
-	if (stm32_usart_rx_dma_enabled(port) && !stm32_port->throttled) {
+	if (stm32_usart_rx_dma_started(stm32_port) && !stm32_port->throttled) {
 		spin_lock(&port->lock);
 		size = stm32_usart_receive_chars(port, false);
 		uart_unlock_and_check_sysrq(port);
@@ -849,11 +1166,11 @@ static void stm32_usart_disable_ms(struct uart_port *port)
 static void stm32_usart_stop_tx(struct uart_port *port)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 
 	stm32_usart_tx_interrupt_disable(port);
-	if (stm32_usart_tx_dma_started(stm32_port) && stm32_usart_tx_dma_enabled(stm32_port))
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+
+	/* dma terminate may have been called in case of dma pause failure */
+	stm32_usart_tx_dma_pause(stm32_port);
 
 	stm32_usart_rs485_rts_disable(port);
 }
@@ -877,12 +1194,9 @@ static void stm32_usart_start_tx(struct uart_port *port)
 static void stm32_usart_flush_buffer(struct uart_port *port)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
-	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 
-	if (stm32_port->tx_ch) {
+	if (stm32_port->tx_ch)
 		stm32_usart_tx_dma_terminate(stm32_port);
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
-	}
 }
 
 /* Throttle the remote when input buffer is about to overflow. */
@@ -895,11 +1209,10 @@ static void stm32_usart_throttle(struct uart_port *port)
 	spin_lock_irqsave(&port->lock, flags);
 
 	/*
-	 * Disable DMA request line if enabled, so the RX data gets queued into the FIFO.
+	 * Pause DMA transfer, so the RX data gets queued into the FIFO.
 	 * Hardware flow control is triggered when RX FIFO is full.
 	 */
-	if (stm32_usart_rx_dma_enabled(port))
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);
+	stm32_usart_rx_dma_pause(stm32_port);
 
 	stm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);
 	if (stm32_port->cr3_irq)
@@ -921,14 +1234,15 @@ static void stm32_usart_unthrottle(struct uart_port *port)
 	if (stm32_port->cr3_irq)
 		stm32_usart_set_bits(port, ofs->cr3, stm32_port->cr3_irq);
 
+	stm32_port->throttled = false;
+
 	/*
-	 * Switch back to DMA mode (re-enable DMA request line).
+	 * Switch back to DMA mode (resume DMA).
 	 * Hardware flow control is stopped when FIFO is not full any more.
 	 */
 	if (stm32_port->rx_ch)
-		stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAR);
+		stm32_usart_rx_dma_start_or_resume(port);
 
-	stm32_port->throttled = false;
 	spin_unlock_irqrestore(&port->lock, flags);
 }
 
@@ -939,59 +1253,27 @@ static void stm32_usart_stop_rx(struct uart_port *port)
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 
 	/* Disable DMA request line. */
-	if (stm32_port->rx_ch)
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);
+	stm32_usart_rx_dma_pause(stm32_port);
 
 	stm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);
 	if (stm32_port->cr3_irq)
 		stm32_usart_clr_bits(port, ofs->cr3, stm32_port->cr3_irq);
 }
 
-/* Handle breaks - ignored by us */
 static void stm32_usart_break_ctl(struct uart_port *port, int break_state)
-{
-}
-
-static int stm32_usart_start_rx_dma_cyclic(struct uart_port *port)
 {
 	struct stm32_port *stm32_port = to_stm32_port(port);
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
-	struct dma_async_tx_descriptor *desc;
-	int ret;
-
-	stm32_port->last_res = RX_BUF_L;
-	/* Prepare a DMA cyclic transaction */
-	desc = dmaengine_prep_dma_cyclic(stm32_port->rx_ch,
-					 stm32_port->rx_dma_buf,
-					 RX_BUF_L, RX_BUF_P,
-					 DMA_DEV_TO_MEM,
-					 DMA_PREP_INTERRUPT);
-	if (!desc) {
-		dev_err(port->dev, "rx dma prep cyclic failed\n");
-		return -ENODEV;
-	}
-
-	desc->callback = stm32_usart_rx_dma_complete;
-	desc->callback_param = port;
-
-	/* Push current DMA transaction in the pending queue */
-	ret = dma_submit_error(dmaengine_submit(desc));
-	if (ret) {
-		dmaengine_terminate_sync(stm32_port->rx_ch);
-		return ret;
-	}
+	unsigned long flags;
 
-	/* Issue pending DMA requests */
-	dma_async_issue_pending(stm32_port->rx_ch);
+	spin_lock_irqsave(&port->lock, flags);
 
-	/*
-	 * DMA request line not re-enabled at resume when port is throttled.
-	 * It will be re-enabled by unthrottle ops.
-	 */
-	if (!stm32_port->throttled)
-		stm32_usart_set_bits(port, ofs->cr3, USART_CR3_DMAR);
+	if (break_state)
+		stm32_usart_set_bits(port, ofs->rqr, USART_RQR_SBKRQ);
+	else
+		stm32_usart_clr_bits(port, ofs->rqr, USART_RQR_SBKRQ);
 
-	return 0;
+	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static int stm32_usart_startup(struct uart_port *port)
@@ -1019,7 +1301,7 @@ static int stm32_usart_startup(struct uart_port *port)
 		writel_relaxed(USART_RQR_RXFRQ, port->membase + ofs->rqr);
 
 	if (stm32_port->rx_ch) {
-		ret = stm32_usart_start_rx_dma_cyclic(port);
+		ret = stm32_usart_rx_dma_start_or_resume(port);
 		if (ret) {
 			free_irq(port->irq, port);
 			return ret;
@@ -1041,12 +1323,12 @@ static void stm32_usart_shutdown(struct uart_port *port)
 	u32 val, isr;
 	int ret;
 
-	if (stm32_usart_tx_dma_enabled(stm32_port))
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
-
 	if (stm32_usart_tx_dma_started(stm32_port))
 		stm32_usart_tx_dma_terminate(stm32_port);
 
+	if (stm32_port->tx_ch)
+		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+
 	/* Disable modem control interrupts */
 	stm32_usart_disable_ms(port);
 
@@ -1065,8 +1347,10 @@ static void stm32_usart_shutdown(struct uart_port *port)
 		dev_err(port->dev, "Transmission is not complete\n");
 
 	/* Disable RX DMA. */
-	if (stm32_port->rx_ch)
-		dmaengine_terminate_async(stm32_port->rx_ch);
+	if (stm32_port->rx_ch) {
+		stm32_usart_rx_dma_terminate(stm32_port);
+		dmaengine_synchronize(stm32_port->rx_ch);
+	}
 
 	/* flush RX & TX FIFO */
 	if (ofs->rqr != UNDEF_REG)
@@ -1086,17 +1370,17 @@ static void stm32_usart_set_termios(struct uart_port *port,
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	const struct stm32_usart_config *cfg = &stm32_port->info->cfg;
 	struct serial_rs485 *rs485conf = &port->rs485;
-	unsigned int baud, bits;
+	unsigned int bits, uart_clk, uart_clk_pres, baud = 0;
 	u32 usartdiv, mantissa, fraction, oversampling;
 	tcflag_t cflag = termios->c_cflag;
-	u32 cr1, cr2, cr3, isr;
+	u32 cr1, cr2, cr3, isr, presc, brr = 0;
 	unsigned long flags;
-	int ret;
+	int brr_fit = 0, ret;
 
 	if (!stm32_port->hw_flow_control)
 		cflag &= ~CRTSCTS;
 
-	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 8);
+	uart_clk = clk_get_rate(stm32_port->clk);
 
 	spin_lock_irqsave(&port->lock, flags);
 
@@ -1166,24 +1450,25 @@ static void stm32_usart_set_termios(struct uart_port *port,
 			cr1 |= USART_CR1_M0;
 		}
 	}
-
-	if (ofs->rtor != UNDEF_REG && (stm32_port->rx_ch ||
-				       (stm32_port->fifoen &&
-					stm32_port->rxftcfg >= 0))) {
-		if (cflag & CSTOPB)
-			bits = bits + 3; /* 1 start bit + 2 stop bits */
-		else
-			bits = bits + 2; /* 1 start bit + 1 stop bit */
-
-		/* RX timeout irq to occur after last stop bit + bits */
-		stm32_port->cr1_irq = USART_CR1_RTOIE;
-		writel_relaxed(bits, port->membase + ofs->rtor);
-		cr2 |= USART_CR2_RTOEN;
-		/*
-		 * Enable fifo threshold irq in two cases, either when there is no DMA, or when
-		 * wake up over usart, from low power until the DMA gets re-enabled by resume.
-		 */
-		stm32_port->cr3_irq =  USART_CR3_RXFTIE;
+	if ((stm32_port->rx_ch || (stm32_port->fifoen && stm32_port->rxftcfg >= 0))) {
+		if (stm32_port->has_rtor) {
+			if (cflag & CSTOPB)
+				bits = bits + 3; /* 1 start bit + 2 stop bits */
+			else
+				bits = bits + 2; /* 1 start bit + 1 stop bit */
+			/* RX timeout irq to occur after last stop bit + bits */
+			stm32_port->cr1_irq = USART_CR1_RTOIE;
+			writel_relaxed(bits, port->membase + ofs->rtor);
+			cr2 |= USART_CR2_RTOEN;
+			/*
+			 * Enable fifo threshold irq in two cases, either when
+			 * there is no DMA, or when wake up over usart, from low
+			 * power until the DMA gets re-enabled by resume.
+			 */
+			stm32_port->cr3_irq = USART_CR3_RXFTIE;
+		} else if (!stm32_port->rx_ch) {
+			stm32_port->cr1_irq = USART_CR1_RXNEIE;
+		}
 	}
 
 	cr1 |= stm32_port->cr1_irq;
@@ -1198,27 +1483,61 @@ static void stm32_usart_set_termios(struct uart_port *port,
 		cr3 |= USART_CR3_CTSE | USART_CR3_RTSE;
 	}
 
-	usartdiv = DIV_ROUND_CLOSEST(port->uartclk, baud);
+	for (presc = 0; presc <= USART_PRESC_MAX; presc++) {
+		uart_clk_pres = DIV_ROUND_CLOSEST(uart_clk, STM32_USART_PRESC_VAL[presc]);
+		if (stm32_port->baudgen == UART_BAUDGEN) {
+			baud = uart_get_baud_rate(port, termios, old, 0, uart_clk / 8);
+			usartdiv = DIV_ROUND_CLOSEST(uart_clk_pres, baud);
+			/*
+			 * The USART supports 16 or 8 times oversampling.
+			 * By default we prefer 16 times oversampling, so that the receiver
+			 * has a better tolerance to clock deviations.
+			 * 8 times oversampling is only used to achieve higher speeds.
+			 */
+			if (usartdiv < 16) {
+				oversampling = 8;
+				cr1 |= USART_CR1_OVER8;
+				stm32_usart_set_bits(port, ofs->cr1, USART_CR1_OVER8);
+			} else {
+				oversampling = 16;
+				cr1 &= ~USART_CR1_OVER8;
+				stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_OVER8);
+			}
 
-	/*
-	 * The USART supports 16 or 8 times oversampling.
-	 * By default we prefer 16 times oversampling, so that the receiver
-	 * has a better tolerance to clock deviations.
-	 * 8 times oversampling is only used to achieve higher speeds.
-	 */
-	if (usartdiv < 16) {
-		oversampling = 8;
-		cr1 |= USART_CR1_OVER8;
-		stm32_usart_set_bits(port, ofs->cr1, USART_CR1_OVER8);
-	} else {
-		oversampling = 16;
-		cr1 &= ~USART_CR1_OVER8;
-		stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_OVER8);
+			mantissa = (usartdiv / oversampling) << USART_BRR_DIV_M_SHIFT;
+			fraction = usartdiv % oversampling;
+			brr = mantissa | fraction;
+			brr_fit = FIELD_FIT(USART_BRR_MASK, brr);
+		} else if (stm32_port->baudgen == LPUART_BAUDGEN) {
+			baud = uart_get_baud_rate(port, termios, old, 0,
+						  DIV_ROUND_CLOSEST(uart_clk, 3));
+			brr = DIV_ROUND_CLOSEST_ULL((u64)256 * uart_clk_pres, baud);
+			if (brr < LPUART_BRR_MIN_VALUE) {
+				brr = LPUART_BRR_MIN_VALUE;
+				dev_err(port->dev,
+					"unable to set baudrate, input clock is too low\n");
+				break;
+			}
+			brr_fit = FIELD_FIT(LPUART_BRR_MASK, brr);
+		}
+		if (brr_fit) {
+			if (ofs->presc != UNDEF_REG) {
+				port->uartclk = uart_clk_pres;
+				writel_relaxed(presc, port->membase + ofs->presc);
+			} else if (presc) {
+				/* We need a prescaler but we don't have it (STM32F4, STM32F7) */
+				dev_err(port->dev,
+					"unable to set baudrate, input clock is too high\n");
+			}
+			break;
+		} else if (presc == USART_PRESC_MAX) {
+			/* Even with prescaler and brr at max value we can't set baudrate */
+			dev_err(port->dev, "unable to set baudrate, input clock is too high\n");
+			break;
+		}
 	}
 
-	mantissa = (usartdiv / oversampling) << USART_BRR_DIV_M_SHIFT;
-	fraction = usartdiv % oversampling;
-	writel_relaxed(mantissa | fraction, port->membase + ofs->brr);
+	writel_relaxed(brr, port->membase + ofs->brr);
 
 	uart_update_timeout(port, cflag, baud);
 
@@ -1257,11 +1576,11 @@ static void stm32_usart_set_termios(struct uart_port *port,
 		cr3 |= USART_CR3_DDRE;
 	}
 
+	if (stm32_port->tx_ch)
+		cr3 |= USART_CR3_DMAT;
+
 	if (rs485conf->flags & SER_RS485_ENABLED) {
-		stm32_usart_config_reg_rs485(&cr1, &cr3,
-					     rs485conf->delay_rts_before_send,
-					     rs485conf->delay_rts_after_send,
-					     baud);
+		stm32_usart_config_reg_rs485(&cr1, &cr3, baud, rs485conf);
 		if (rs485conf->flags & SER_RS485_RTS_ON_SEND) {
 			cr3 &= ~USART_CR3_DEP;
 			rs485conf->flags &= ~SER_RS485_RTS_AFTER_SEND;
@@ -1275,12 +1594,6 @@ static void stm32_usart_set_termios(struct uart_port *port,
 		cr1 &= ~(USART_CR1_DEDT_MASK | USART_CR1_DEAT_MASK);
 	}
 
-	/* Configure wake up from low power on start bit detection */
-	if (stm32_port->wakeup_src) {
-		cr3 &= ~USART_CR3_WUS_MASK;
-		cr3 |= USART_CR3_WUS_START_BIT;
-	}
-
 	writel_relaxed(cr3, port->membase + ofs->cr3);
 	writel_relaxed(cr2, port->membase + ofs->cr2);
 	writel_relaxed(cr1, port->membase + ofs->cr1);
@@ -1399,37 +1712,57 @@ static const struct uart_ops stm32_uart_ops = {
 #endif /* CONFIG_CONSOLE_POLL */
 };
 
-/*
- * STM32H7 RX & TX FIFO threshold configuration (CR3 RXFTCFG / TXFTCFG)
- * Note: 1 isn't a valid value in RXFTCFG / TXFTCFG. In this case,
- * RXNEIE / TXEIE can be used instead of threshold irqs: RXFTIE / TXFTIE.
- * So, RXFTCFG / TXFTCFG bitfields values are encoded as array index + 1.
- */
-static const u32 stm32h7_usart_fifo_thresh_cfg[] = { 1, 2, 4, 8, 12, 14, 16 };
+struct stm32_usart_thresh_ratio {
+	int mul;
+	int div;
+};
+
+static const struct stm32_usart_thresh_ratio stm32h7_usart_fifo_thresh_cfg[] = {
+	{1, 8}, {1, 4}, {1, 2}, {3, 4}, {7, 8}, {1, 1} };
+
+static int stm32_usart_get_thresh_value(u32 fifo_size, int index)
+{
+	return fifo_size * stm32h7_usart_fifo_thresh_cfg[index].mul /
+		stm32h7_usart_fifo_thresh_cfg[index].div;
+}
 
-static void stm32_usart_get_ftcfg(struct platform_device *pdev, const char *p,
-				  int *ftcfg)
+static int stm32_usart_get_ftcfg(struct platform_device *pdev, struct stm32_port *stm32port,
+				 const char *p, int *ftcfg)
 {
-	u32 bytes, i;
+	const struct stm32_usart_offsets *ofs = &stm32port->info->ofs;
+	u32 bytes, i, cfg8;
+	int fifo_size;
+
+	if (WARN_ON(ofs->hwcfgr1 == UNDEF_REG))
+		return 1;
+
+	cfg8 = FIELD_GET(USART_HWCFCR1_CFG8,
+			 readl_relaxed(stm32port->port.membase + ofs->hwcfgr1));
+
+	/* On STM32H7, hwcfgr is not present, so returned value will be 0 */
+	fifo_size = cfg8 ? 1 << cfg8 : STM32H7_USART_FIFO_SIZE;
 
-	/* DT option to get RX & TX FIFO threshold (default to 8 bytes) */
+	/* DT option to get RX & TX FIFO threshold (default to half fifo size) */
 	if (of_property_read_u32(pdev->dev.of_node, p, &bytes))
-		bytes = 8;
+		bytes = fifo_size / 2;
 
-	for (i = 0; i < ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg); i++)
-		if (stm32h7_usart_fifo_thresh_cfg[i] >= bytes)
+	if (bytes < stm32_usart_get_thresh_value(fifo_size, 0)) {
+		*ftcfg = -EINVAL;
+		return fifo_size;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg); i++) {
+		if (stm32_usart_get_thresh_value(fifo_size, i) >= bytes)
 			break;
+	}
 	if (i >= ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg))
 		i = ARRAY_SIZE(stm32h7_usart_fifo_thresh_cfg) - 1;
 
-	dev_dbg(&pdev->dev, "%s set to %d bytes\n", p,
-		stm32h7_usart_fifo_thresh_cfg[i]);
+	dev_dbg(&pdev->dev, "%s set to %d/%d bytes\n", p,
+		stm32_usart_get_thresh_value(fifo_size, i), fifo_size);
 
-	/* Provide FIFO threshold ftcfg (1 is invalid: threshold irq unused) */
-	if (i)
-		*ftcfg = i - 1;
-	else
-		*ftcfg = -EINVAL;
+	*ftcfg = i;
+	return fifo_size;
 }
 
 static void stm32_usart_deinit_port(struct stm32_port *stm32port)
@@ -1459,11 +1792,12 @@ static int stm32_usart_init_port(struct stm32_port *stm32port,
 	port->flags	= UPF_BOOT_AUTOCONF;
 	port->ops	= &stm32_uart_ops;
 	port->dev	= &pdev->dev;
-	port->fifosize	= stm32port->info->cfg.fifosize;
 	port->has_sysrq = IS_ENABLED(CONFIG_SERIAL_STM32_CONSOLE);
 	port->irq = irq;
 	port->rs485_config = stm32_usart_config_rs485;
 	port->rs485_supported = stm32_rs485_supported;
+	if (stm32port->has_smartcard)
+		port->iso7816_config = stm32_usart_config_iso7816;
 
 	ret = stm32_usart_init_rs485(port, pdev);
 	if (ret)
@@ -1475,14 +1809,6 @@ static int stm32_usart_init_port(struct stm32_port *stm32port,
 	stm32port->swap = stm32port->info->cfg.has_swap &&
 		of_property_read_bool(pdev->dev.of_node, "rx-tx-swap");
 
-	stm32port->fifoen = stm32port->info->cfg.has_fifo;
-	if (stm32port->fifoen) {
-		stm32_usart_get_ftcfg(pdev, "rx-threshold",
-				      &stm32port->rxftcfg);
-		stm32_usart_get_ftcfg(pdev, "tx-threshold",
-				      &stm32port->txftcfg);
-	}
-
 	port->membase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(port->membase))
 		return PTR_ERR(port->membase);
@@ -1505,6 +1831,15 @@ static int stm32_usart_init_port(struct stm32_port *stm32port,
 		goto err_clk;
 	}
 
+	stm32port->fifoen = stm32port->info->cfg.has_fifo;
+	if (stm32port->fifoen) {
+		stm32_usart_get_ftcfg(pdev, stm32port, "rx-threshold", &stm32port->rxftcfg);
+		port->fifosize = stm32_usart_get_ftcfg(pdev, stm32port, "tx-threshold",
+						       &stm32port->txftcfg);
+	} else {
+		port->fifosize = 1;
+	}
+
 	stm32port->gpios = mctrl_gpio_init(&stm32port->port, 0);
 	if (IS_ERR(stm32port->gpios)) {
 		ret = PTR_ERR(stm32port->gpios);
@@ -1576,6 +1911,8 @@ static void stm32_usart_of_dma_rx_remove(struct stm32_port *stm32port,
 	if (stm32port->rx_buf)
 		dma_free_coherent(&pdev->dev, RX_BUF_L, stm32port->rx_buf,
 				  stm32port->rx_dma_buf);
+	if (!stm32port->has_rtor)
+		del_timer(&stm32port->rx_dma_timer);
 }
 
 static int stm32_usart_of_dma_rx_probe(struct stm32_port *stm32port,
@@ -1604,6 +1941,8 @@ static int stm32_usart_of_dma_rx_probe(struct stm32_port *stm32port,
 		stm32_usart_of_dma_rx_remove(stm32port, pdev);
 		return ret;
 	}
+	if (!stm32port->has_rtor)
+		timer_setup(&stm32port->rx_dma_timer, stm32_usart_rx_dma_timer_callback, 0);
 
 	return 0;
 }
@@ -1704,6 +2043,35 @@ static int stm32_usart_serial_probe(struct platform_device *pdev)
 	if (!stm32port->tx_ch)
 		dev_info(&pdev->dev, "interrupt mode for tx (no dma)\n");
 
+	stm32port->baudgen = UART_BAUDGEN;
+	stm32port->has_rtor = true;
+	stm32port->has_smartcard = true;
+
+	if (stm32port->info->ofs.hwcfgr1 != UNDEF_REG) {
+		u32 hwcfgr1 = readl_relaxed(stm32port->port.membase + stm32port->info->ofs.hwcfgr1);
+
+		if (FIELD_GET(USART_HWCFCR1_CFG7, hwcfgr1))
+			stm32port->baudgen = LPUART_BAUDGEN;
+
+		if (!FIELD_GET(USART_HWCFCR1_CFG4, hwcfgr1))
+			stm32port->has_smartcard = false;
+
+		/*
+		 * As STM32H7 and STM32MPx share the same compatible but HWCFGR1 is not
+		 * defined on STM32H7, HWCFGR1_CFG5 will return a wrong value for has_rtor on
+		 * STM32H7. If the baudgen is LPUART type, we consider that this usart hasn't
+		 * got a RTOR.
+		 */
+		if (stm32port->baudgen == LPUART_BAUDGEN)
+			stm32port->has_rtor = false;
+	}
+
+	if (stm32port->has_rtor && stm32port->info->ofs.rtor == UNDEF_REG) {
+		dev_err(&pdev->dev, "The device has no RTOR register\n");
+		ret = -EINVAL;
+		goto err_rtor;
+	}
+
 	platform_set_drvdata(pdev, &stm32port->port);
 
 	pm_runtime_get_noresume(&pdev->dev);
@@ -1723,6 +2091,7 @@ static int stm32_usart_serial_probe(struct platform_device *pdev)
 	pm_runtime_set_suspended(&pdev->dev);
 	pm_runtime_put_noidle(&pdev->dev);
 
+err_rtor:
 	if (stm32port->tx_ch)
 		stm32_usart_of_dma_tx_remove(stm32port, pdev);
 	if (stm32port->rx_ch)
@@ -1763,11 +2132,6 @@ static int stm32_usart_serial_remove(struct platform_device *pdev)
 	pm_runtime_put_noidle(&pdev->dev);
 
 	stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_PEIE);
-	cr3 = readl_relaxed(port->membase + ofs->cr3);
-	cr3 &= ~USART_CR3_EIE;
-	cr3 &= ~USART_CR3_DMAR;
-	cr3 &= ~USART_CR3_DDRE;
-	writel_relaxed(cr3, port->membase + ofs->cr3);
 
 	if (stm32_port->tx_ch) {
 		stm32_usart_of_dma_tx_remove(stm32_port, pdev);
@@ -1779,7 +2143,12 @@ static int stm32_usart_serial_remove(struct platform_device *pdev)
 		dma_release_channel(stm32_port->rx_ch);
 	}
 
-	stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAT);
+	cr3 = readl_relaxed(port->membase + ofs->cr3);
+	cr3 &= ~USART_CR3_EIE;
+	cr3 &= ~USART_CR3_DMAR;
+	cr3 &= ~USART_CR3_DMAT;
+	cr3 &= ~USART_CR3_DDRE;
+	writel_relaxed(cr3, port->membase + ofs->cr3);
 
 	if (stm32_port->wakeup_src) {
 		dev_pm_clear_wake_irq(&pdev->dev);
@@ -1951,19 +2320,21 @@ static int __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,
 	const struct stm32_usart_offsets *ofs = &stm32_port->info->ofs;
 	struct tty_port *tport = &port->state->port;
 	int ret;
-	unsigned int size;
+	unsigned int size = 0;
 	unsigned long flags;
 
 	if (!stm32_port->wakeup_src || !tty_port_initialized(tport))
 		return 0;
 
 	/*
-	 * Enable low-power wake-up and wake-up irq if argument is set to
-	 * "enable", disable low-power wake-up and wake-up irq otherwise
+	 * Enable low-power wake-up and irq on any character received if argument
+	 * is set to "enable", disable low-power wake-up and irq otherwise.
 	 */
 	if (enable) {
-		stm32_usart_set_bits(port, ofs->cr1, USART_CR1_UESM);
-		stm32_usart_set_bits(port, ofs->cr3, USART_CR3_WUFIE);
+		stm32_usart_clr_bits(port, ofs->cr1, stm32_port->cr1_irq);
+		if (stm32_port->cr3_irq)
+			stm32_usart_clr_bits(port, ofs->cr3, stm32_port->cr3_irq);
+		stm32_usart_set_bits(port, ofs->cr1, USART_CR1_UESM | USART_CR1_RXNEIE);
 		mctrl_gpio_enable_irq_wake(stm32_port->gpios);
 
 		/*
@@ -1973,11 +2344,10 @@ static int __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,
 		 */
 		if (stm32_port->rx_ch) {
 			spin_lock_irqsave(&port->lock, flags);
-			/* Avoid race with RX IRQ when DMAR is cleared */
-			stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_DMAR);
 			/* Poll data from DMA RX buffer if any */
-			size = stm32_usart_receive_chars(port, true);
-			dmaengine_terminate_async(stm32_port->rx_ch);
+			if (!stm32_usart_rx_dma_pause(stm32_port))
+				size += stm32_usart_receive_chars(port, true);
+			stm32_usart_rx_dma_terminate(stm32_port);
 			uart_unlock_and_check_sysrq_irqrestore(port, flags);
 			if (size)
 				tty_flip_buffer_push(tport);
@@ -1987,13 +2357,15 @@ static int __maybe_unused stm32_usart_serial_en_wakeup(struct uart_port *port,
 		stm32_usart_receive_chars(port, false);
 	} else {
 		if (stm32_port->rx_ch) {
-			ret = stm32_usart_start_rx_dma_cyclic(port);
+			ret = stm32_usart_rx_dma_start_or_resume(port);
 			if (ret)
 				return ret;
 		}
 		mctrl_gpio_disable_irq_wake(stm32_port->gpios);
-		stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_UESM);
-		stm32_usart_clr_bits(port, ofs->cr3, USART_CR3_WUFIE);
+		stm32_usart_clr_bits(port, ofs->cr1, USART_CR1_UESM | USART_CR1_RXNEIE);
+		stm32_usart_set_bits(port, ofs->cr1, stm32_port->cr1_irq);
+		if (stm32_port->cr3_irq)
+			stm32_usart_set_bits(port, ofs->cr3, stm32_port->cr3_irq);
 	}
 
 	return 0;
diff --git a/drivers/tty/serial/stm32-usart.h b/drivers/tty/serial/stm32-usart.h
index 0ec41a732..4db061996 100644
--- a/drivers/tty/serial/stm32-usart.h
+++ b/drivers/tty/serial/stm32-usart.h
@@ -8,18 +8,33 @@
 
 #define DRIVER_NAME "stm32-usart"
 
+enum stm32_baudgen_type {
+	UART_BAUDGEN = 0,
+	LPUART_BAUDGEN = 1
+};
+
 struct stm32_usart_offsets {
-	u8 cr1;
-	u8 cr2;
-	u8 cr3;
-	u8 brr;
-	u8 gtpr;
-	u8 rtor;
-	u8 rqr;
-	u8 isr;
-	u8 icr;
-	u8 rdr;
-	u8 tdr;
+	u16 cr1;
+	u16 cr2;
+	u16 cr3;
+	u16 brr;
+	u16 gtpr;
+	u16 rtor;
+	u16 rqr;
+	u16 isr;
+	u16 icr;
+	u16 rdr;
+	u16 tdr;
+	u16 presc;
+	u16 hwcfgr1;
+};
+
+struct stm32_backup_regs {
+	u32 cr1;
+	u32 cr2;
+	u32 cr3;
+	u32 gtpr;
+	u32 brr;
 };
 
 struct stm32_usart_config {
@@ -28,7 +43,6 @@ struct stm32_usart_config {
 	bool has_swap;
 	bool has_wakeup;
 	bool has_fifo;
-	int fifosize;
 };
 
 struct stm32_usart_info {
@@ -36,7 +50,7 @@ struct stm32_usart_info {
 	struct stm32_usart_config cfg;
 };
 
-#define UNDEF_REG 0xff
+#define UNDEF_REG 0xfff
 
 /* USART_SR (F4) / USART_ISR (F7) */
 #define USART_SR_PE		BIT(0)
@@ -60,6 +74,7 @@ struct stm32_usart_info {
 #define USART_SR_TEACK		BIT(21)		/* F7 */
 #define USART_SR_ERR_MASK	(USART_SR_ORE | USART_SR_NE | USART_SR_FE |\
 				 USART_SR_PE)
+#define USART_SR_TCBGT		BIT(25)		/* F7 */
 /* Dummy bits */
 #define USART_SR_DUMMY_RX	BIT(16)
 
@@ -71,6 +86,11 @@ struct stm32_usart_info {
 #define USART_BRR_DIV_M_MASK	GENMASK(15, 4)
 #define USART_BRR_DIV_M_SHIFT	4
 #define USART_BRR_04_R_SHIFT	1
+#define USART_BRR_MASK		(USART_BRR_DIV_M_MASK | USART_BRR_DIV_F_MASK)
+
+/* LPUART_BRR */
+#define LPUART_BRR_MASK		GENMASK(19, 0)
+#define LPUART_BRR_MIN_VALUE	0x300
 
 /* USART_CR1 */
 #define USART_CR1_SBK		BIT(0)
@@ -150,6 +170,7 @@ struct stm32_usart_info {
 #define USART_CR3_TXFTCFG_SHIFT	29		/* H7 */
 
 /* USART_GTPR */
+#define USART_GTPR_PSC_SMART_MASK	GENMASK(4, 0)
 #define USART_GTPR_PSC_MASK	GENMASK(7, 0)
 #define USART_GTPR_GT_MASK	GENMASK(15, 8)
 
@@ -170,14 +191,26 @@ struct stm32_usart_info {
 #define USART_ICR_ORECF		BIT(3)		/* F7 */
 #define USART_ICR_IDLECF	BIT(4)		/* F7 */
 #define USART_ICR_TCCF		BIT(6)		/* F7 */
+#define USART_ICR_TCBGTCF	BIT(7)		/* F7 */
 #define USART_ICR_CTSCF		BIT(9)		/* F7 */
 #define USART_ICR_RTOCF		BIT(11)		/* F7 */
 #define USART_ICR_EOBCF		BIT(12)		/* F7 */
 #define USART_ICR_CMCF		BIT(17)		/* F7 */
 #define USART_ICR_WUCF		BIT(20)		/* H7 */
 
+/* USART_PRESC */
+#define USART_PRESC		GENMASK(3, 0)	/* H7 */
+#define USART_PRESC_MAX		0b1011
+static const unsigned int STM32_USART_PRESC_VAL[] = {1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256};
+
+/* USART_HWCFCR1 */
+#define USART_HWCFCR1_CFG4	GENMASK(15, 12)	/* MP1 */
+#define USART_HWCFCR1_CFG7	GENMASK(27, 24)	/* MP1 */
+#define USART_HWCFCR1_CFG8	GENMASK(31, 28)	/* MP1 */
+
 #define STM32_SERIAL_NAME "ttySTM"
-#define STM32_MAX_PORTS 8
+#define STM32_MAX_PORTS 9
+#define STM32H7_USART_FIFO_SIZE 16
 
 #define RX_BUF_L 4096		 /* dma rx buffer length     */
 #define RX_BUF_P (RX_BUF_L / 2)	 /* dma rx buffer period     */
@@ -185,6 +218,8 @@ struct stm32_usart_info {
 
 #define STM32_USART_TIMEOUT_USEC USEC_PER_SEC /* 1s timeout in s */
 
+#define LPUART_RECEIVE_TIMEOUT_MS 1000
+
 struct stm32_port {
 	struct uart_port port;
 	struct clk *clk;
@@ -199,17 +234,23 @@ struct stm32_port {
 	u32 cr3_irq;		 /* USART_CR3_RXFTIE */
 	int last_res;
 	bool tx_dma_busy;	 /* dma tx transaction in progress */
+	bool rx_dma_busy;	 /* dma rx transaction in progress */
 	bool throttled;		 /* port throttled            */
 	bool hw_flow_control;
 	bool swap;		 /* swap RX & TX pins */
 	bool fifoen;
 	bool txdone;
+	bool has_rtor;
+	bool has_smartcard;
 	int rxftcfg;		/* RX FIFO threshold CFG      */
 	int txftcfg;		/* TX FIFO threshold CFG      */
 	bool wakeup_src;
 	int rdr_mask;		/* receive data register mask */
 	struct mctrl_gpios *gpios; /* modem control gpios */
 	struct dma_tx_state rx_dma_state;
+	struct stm32_backup_regs bkp_regs;
+	enum stm32_baudgen_type baudgen;
+	struct timer_list rx_dma_timer; /* Only used for LPUART */
 };
 
 static struct stm32_port stm32_ports[STM32_MAX_PORTS];
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 5e287dedc..595d8b49c 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -5,7 +5,6 @@
 
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/minmax.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
@@ -105,7 +104,6 @@ static void tty_buffer_reset(struct tty_buffer *p, size_t size)
 	p->size = size;
 	p->next = NULL;
 	p->commit = 0;
-	p->lookahead = 0;
 	p->read = 0;
 	p->flags = 0;
 }
@@ -236,7 +234,6 @@ void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)
 		buf->head = next;
 	}
 	buf->head->read = buf->head->commit;
-	buf->head->lookahead = buf->head->read;
 
 	if (ld && ld->ops->flush_buffer)
 		ld->ops->flush_buffer(tty);
@@ -279,15 +276,13 @@ static int __tty_buffer_request_room(struct tty_port *port, size_t size,
 		if (n != NULL) {
 			n->flags = flags;
 			buf->tail = n;
-			/*
-			 * Paired w/ acquire in flush_to_ldisc() and lookahead_bufs()
-			 * ensures they see all buffer data.
+			/* paired w/ acquire in flush_to_ldisc(); ensures
+			 * flush_to_ldisc() sees buffer data.
 			 */
 			smp_store_release(&b->commit, b->used);
-			/*
-			 * Paired w/ acquire in flush_to_ldisc() and lookahead_bufs()
-			 * ensures the latest commit value can be read before the head
-			 * is advanced to the next buffer.
+			/* paired w/ acquire in flush_to_ldisc(); ensures the
+			 * latest commit value can be read before the head is
+			 * advanced to the next buffer
 			 */
 			smp_store_release(&b->next, n);
 		} else if (change)
@@ -464,44 +459,6 @@ int tty_ldisc_receive_buf(struct tty_ldisc *ld, const unsigned char *p,
 }
 EXPORT_SYMBOL_GPL(tty_ldisc_receive_buf);
 
-static void lookahead_bufs(struct tty_port *port, struct tty_buffer *head)
-{
-	head->lookahead = max(head->lookahead, head->read);
-
-	while (head) {
-		struct tty_buffer *next;
-		unsigned int count;
-
-		/*
-		 * Paired w/ release in __tty_buffer_request_room();
-		 * ensures commit value read is not stale if the head
-		 * is advancing to the next buffer.
-		 */
-		next = smp_load_acquire(&head->next);
-		/*
-		 * Paired w/ release in __tty_buffer_request_room() or in
-		 * tty_buffer_flush(); ensures we see the committed buffer data.
-		 */
-		count = smp_load_acquire(&head->commit) - head->lookahead;
-		if (!count) {
-			head = next;
-			continue;
-		}
-
-		if (port->client_ops->lookahead_buf) {
-			unsigned char *p, *f = NULL;
-
-			p = char_buf_ptr(head, head->lookahead);
-			if (~head->flags & TTYB_NORMAL)
-				f = flag_buf_ptr(head, head->lookahead);
-
-			port->client_ops->lookahead_buf(port, p, f, count);
-		}
-
-		head->lookahead += count;
-	}
-}
-
 static int
 receive_buf(struct tty_port *port, struct tty_buffer *head, int count)
 {
@@ -539,7 +496,7 @@ static void flush_to_ldisc(struct work_struct *work)
 	while (1) {
 		struct tty_buffer *head = buf->head;
 		struct tty_buffer *next;
-		int count, rcvd;
+		int count;
 
 		/* Ldisc or user is trying to gain exclusive access */
 		if (atomic_read(&buf->priority))
@@ -562,12 +519,10 @@ static void flush_to_ldisc(struct work_struct *work)
 			continue;
 		}
 
-		rcvd = receive_buf(port, head, count);
-		head->read += rcvd;
-		if (rcvd < count)
-			lookahead_bufs(port, head);
-		if (!rcvd)
+		count = receive_buf(port, head, count);
+		if (!count)
 			break;
+		head->read += count;
 
 		if (need_resched())
 			cond_resched();
diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c
index dce08a6d7..880608a65 100644
--- a/drivers/tty/tty_port.c
+++ b/drivers/tty/tty_port.c
@@ -43,26 +43,6 @@ static int tty_port_default_receive_buf(struct tty_port *port,
 	return ret;
 }
 
-static void tty_port_default_lookahead_buf(struct tty_port *port, const unsigned char *p,
-					   const unsigned char *f, unsigned int count)
-{
-	struct tty_struct *tty;
-	struct tty_ldisc *disc;
-
-	tty = READ_ONCE(port->itty);
-	if (!tty)
-		return;
-
-	disc = tty_ldisc_ref(tty);
-	if (!disc)
-		return;
-
-	if (disc->ops->lookahead_buf)
-		disc->ops->lookahead_buf(disc->tty, p, f, count);
-
-	tty_ldisc_deref(disc);
-}
-
 static void tty_port_default_wakeup(struct tty_port *port)
 {
 	struct tty_struct *tty = tty_port_tty_get(port);
@@ -75,7 +55,6 @@ static void tty_port_default_wakeup(struct tty_port *port)
 
 const struct tty_port_client_operations tty_port_default_client_ops = {
 	.receive_buf = tty_port_default_receive_buf,
-	.lookahead_buf = tty_port_default_lookahead_buf,
 	.write_wakeup = tty_port_default_wakeup,
 };
 EXPORT_SYMBOL_GPL(tty_port_default_client_ops);
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 6af0a31ff..5a4c6adad 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2293,7 +2293,8 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 
 		if (!PMSG_IS_AUTO(msg))
 			usb_phy_roothub_suspend(hcd->self.sysdev,
-						hcd->phy_roothub);
+						hcd->phy_roothub,
+						usb_wakeup_enabled_descendants(rhdev));
 
 		/* Did we race with a root-hub wakeup event? */
 		if (rhdev->do_remote_wakeup) {
@@ -2334,7 +2335,8 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	if (!PMSG_IS_AUTO(msg)) {
 		status = usb_phy_roothub_resume(hcd->self.sysdev,
-						hcd->phy_roothub);
+						hcd->phy_roothub,
+						usb_wakeup_enabled_descendants(rhdev));
 		if (status)
 			return status;
 	}
@@ -2379,7 +2381,8 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 		}
 	} else {
 		hcd->state = old_state;
-		usb_phy_roothub_suspend(hcd->self.sysdev, hcd->phy_roothub);
+		usb_phy_roothub_suspend(hcd->self.sysdev, hcd->phy_roothub,
+					usb_wakeup_enabled_descendants(rhdev));
 		dev_dbg(&rhdev->dev, "bus %s fail, err %d\n",
 				"resume", status);
 		if (status != -ESHUTDOWN)
diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index fb1588e7c..746615aa1 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -212,34 +212,36 @@ void usb_phy_roothub_power_off(struct usb_phy_roothub *phy_roothub)
 EXPORT_SYMBOL_GPL(usb_phy_roothub_power_off);
 
 int usb_phy_roothub_suspend(struct device *controller_dev,
-			    struct usb_phy_roothub *phy_roothub)
+			    struct usb_phy_roothub *phy_roothub,
+			    unsigned wakeup_enabled_descendants)
 {
-	usb_phy_roothub_power_off(phy_roothub);
-
 	/* keep the PHYs initialized so the device can wake up the system */
-	if (device_may_wakeup(controller_dev))
+	if (device_may_wakeup(controller_dev) || wakeup_enabled_descendants)
 		return 0;
 
+	usb_phy_roothub_power_off(phy_roothub);
+
 	return usb_phy_roothub_exit(phy_roothub);
 }
 EXPORT_SYMBOL_GPL(usb_phy_roothub_suspend);
 
 int usb_phy_roothub_resume(struct device *controller_dev,
-			   struct usb_phy_roothub *phy_roothub)
+			   struct usb_phy_roothub *phy_roothub,
+			   unsigned wakeup_enabled_descendants)
 {
-	int err;
+	int err = 0;
 
 	/* if the device can't wake up the system _exit was called */
-	if (!device_may_wakeup(controller_dev)) {
+	if (!device_may_wakeup(controller_dev) && !wakeup_enabled_descendants) {
 		err = usb_phy_roothub_init(phy_roothub);
 		if (err)
 			return err;
-	}
 
-	err = usb_phy_roothub_power_on(phy_roothub);
+		err = usb_phy_roothub_power_on(phy_roothub);
+	}
 
 	/* undo _init if _power_on failed */
-	if (err && !device_may_wakeup(controller_dev))
+	if (err && !device_may_wakeup(controller_dev) && !wakeup_enabled_descendants)
 		usb_phy_roothub_exit(phy_roothub);
 
 	return err;
diff --git a/drivers/usb/core/phy.h b/drivers/usb/core/phy.h
index 20a267cd9..3df4ddbb6 100644
--- a/drivers/usb/core/phy.h
+++ b/drivers/usb/core/phy.h
@@ -23,8 +23,10 @@ int usb_phy_roothub_power_on(struct usb_phy_roothub *phy_roothub);
 void usb_phy_roothub_power_off(struct usb_phy_roothub *phy_roothub);
 
 int usb_phy_roothub_suspend(struct device *controller_dev,
-			    struct usb_phy_roothub *phy_roothub);
+			    struct usb_phy_roothub *phy_roothub,
+			    unsigned wakeup_enabled_descendants);
 int usb_phy_roothub_resume(struct device *controller_dev,
-			   struct usb_phy_roothub *phy_roothub);
+			   struct usb_phy_roothub *phy_roothub,
+			   unsigned wakeup_enabled_descendants);
 
 #endif /* __USB_CORE_PHY_H_ */
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index 40cf2880d..0bb4c0c84 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -1003,6 +1003,7 @@ struct dwc2_hregs_backup {
  * @ctrl_out_desc:	EP0 OUT data phase desc chain pointer
  * @irq:		Interrupt request line number
  * @clk:		Pointer to otg clock
+ * @utmi_clk:		Pointer to utmi_clk clock
  * @reset:		Pointer to dwc2 reset controller
  * @reset_ecc:          Pointer to dwc2 optional reset controller in Stratix10.
  * @regset:		A pointer to a struct debugfs_regset32, which contains
@@ -1065,6 +1066,7 @@ struct dwc2_hsotg {
 	void *priv;
 	int     irq;
 	struct clk *clk;
+	struct clk *utmi_clk;
 	struct reset_control *reset;
 	struct reset_control *reset_ecc;
 
diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index 158ede753..6f778e4ca 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -403,13 +403,14 @@ static void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg)
 				if (ret)
 					dev_err(hsotg->dev,
 						"exit partial_power_down failed\n");
-				call_gadget(hsotg, resume);
 			}
 
 			/* Exit gadget mode clock gating. */
 			if (hsotg->params.power_down ==
 			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
 				dwc2_gadget_exit_clock_gating(hsotg, 0);
+
+			call_gadget(hsotg, resume);
 		} else {
 			/* Change to L0 state */
 			hsotg->lx_state = DWC2_L0;
diff --git a/drivers/usb/dwc2/drd.c b/drivers/usb/dwc2/drd.c
index a8605b021..70181edd5 100644
--- a/drivers/usb/dwc2/drd.c
+++ b/drivers/usb/dwc2/drd.c
@@ -44,8 +44,8 @@ static int dwc2_ovr_avalid(struct dwc2_hsotg *hsotg, bool valid)
 	u32 gotgctl = dwc2_readl(hsotg, GOTGCTL);
 
 	/* Check if A-Session is already in the right state */
-	if ((valid && (gotgctl & GOTGCTL_ASESVLD)) ||
-	    (!valid && !(gotgctl & GOTGCTL_ASESVLD)))
+	if ((valid && (gotgctl & GOTGCTL_AVALOVAL) && (gotgctl & GOTGCTL_VBVALOVAL)) ||
+	    (!valid && !(gotgctl & (GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL))))
 		return -EALREADY;
 
 	/* Always enable overrides to handle the resume case */
@@ -66,8 +66,8 @@ static int dwc2_ovr_bvalid(struct dwc2_hsotg *hsotg, bool valid)
 	u32 gotgctl = dwc2_readl(hsotg, GOTGCTL);
 
 	/* Check if B-Session is already in the right state */
-	if ((valid && (gotgctl & GOTGCTL_BSESVLD)) ||
-	    (!valid && !(gotgctl & GOTGCTL_BSESVLD)))
+	if ((valid && (gotgctl & GOTGCTL_BVALOVAL) && (gotgctl & GOTGCTL_VBVALOVAL)) ||
+	    (!valid && !(gotgctl & (GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL))))
 		return -EALREADY;
 
 	/* Always enable overrides to handle the resume case */
@@ -147,9 +147,18 @@ static int dwc2_drd_role_sw_set(struct usb_role_switch *sw, enum usb_role role)
 
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
-	if (!already && hsotg->dr_mode == USB_DR_MODE_OTG)
+	if (!already && hsotg->dr_mode == USB_DR_MODE_OTG) {
+		/*
+		 * The bus may have been suspended (typically in hcd), need to resume as the HW
+		 * may not be HW accessible. Schedule work to call dwc2_conn_id_status_change
+		 * to handle the port resume before switching mode.
+		 */
+		if (hsotg->bus_suspended && hsotg->wq_otg)
+			queue_work(hsotg->wq_otg, &hsotg->wf_otg);
+
 		/* This will raise a Connector ID Status Change Interrupt */
 		dwc2_force_mode(hsotg, role == USB_ROLE_HOST);
+	}
 
 	if (!hsotg->ll_hw_enabled && hsotg->clk)
 		clk_disable_unprepare(hsotg->clk);
diff --git a/drivers/usb/dwc2/gadget.c b/drivers/usb/dwc2/gadget.c
index 8b15742d9..870ac2886 100644
--- a/drivers/usb/dwc2/gadget.c
+++ b/drivers/usb/dwc2/gadget.c
@@ -5671,7 +5671,6 @@ void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)
 	}
 
 	/* Change to L0 state */
-	call_gadget(hsotg, resume);
 	hsotg->lx_state = DWC2_L0;
 	hsotg->bus_suspended = false;
 }
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 35c7a4df8..1d2b8276c 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -1701,7 +1701,8 @@ static void dwc2_hcd_cleanup_channels(struct dwc2_hsotg *hsotg)
 		 * release_channel_ddma(), which is called from ep_disable when
 		 * device disconnects
 		 */
-		channel->qh = NULL;
+		if (hsotg->params.host_dma && hsotg->params.dma_desc_enable)
+			channel->qh = NULL;
 	}
 	/* All channels have been freed, mark them available */
 	if (hsotg->params.uframe_sched) {
@@ -3614,7 +3615,8 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 		if (wvalue != USB_PORT_FEAT_TEST && (!windex || windex > 1))
 			goto error;
 
-		if (!hsotg->flags.b.port_connect_status) {
+		if (!hsotg->flags.b.port_connect_status &&
+		    !dwc2_is_host_mode(hsotg)) {
 			/*
 			 * The port is disconnected, which means the core is
 			 * either in device mode or it soon will be. Just
@@ -3716,6 +3718,7 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 			hprt0 &= ~HPRT0_TSTCTL_MASK;
 			hprt0 |= (windex >> 8) << HPRT0_TSTCTL_SHIFT;
 			dwc2_writel(hsotg, hprt0, HPRT0);
+			hsotg->test_mode = windex >> 8;
 			break;
 
 		default:
@@ -4260,9 +4263,11 @@ static int _dwc2_hcd_start(struct usb_hcd *hcd)
 		return 0;	/* why 0 ?? */
 	}
 
+	hprt0 = dwc2_read_hprt0(hsotg);
+
 	dwc2_hcd_reinit(hsotg);
 
-	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 ^= dwc2_read_hprt0(hsotg);
 	/* Has vbus power been turned on in dwc2_core_host_init ? */
 	if (hprt0 & HPRT0_PWR) {
 		/* Enable external vbus supply before resuming root hub */
@@ -4371,6 +4376,7 @@ static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
 		 * clock gating is used to save power.
 		 */
 		if (!hsotg->params.no_clock_gating) {
+			dwc2_disable_global_interrupts(hsotg);
 			dwc2_host_enter_clock_gating(hsotg);
 
 			/* After entering suspend, hardware is not accessible */
@@ -4381,10 +4387,6 @@ static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
 		goto skip_power_saving;
 	}
 
-	spin_unlock_irqrestore(&hsotg->lock, flags);
-	dwc2_vbus_supply_exit(hsotg);
-	spin_lock_irqsave(&hsotg->lock, flags);
-
 	/* Ask phy to be suspended */
 	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -4415,20 +4417,20 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 	if (hsotg->lx_state != DWC2_L2)
 		goto unlock;
 
-	hprt0 = dwc2_read_hprt0(hsotg);
-
-	/*
-	 * Added port connection status checking which prevents exiting from
-	 * Partial Power Down mode from _dwc2_hcd_resume() if not in Partial
-	 * Power Down mode.
-	 */
-	if (hprt0 & HPRT0_CONNSTS) {
-		hsotg->lx_state = DWC2_L0;
-		goto unlock;
-	}
-
 	switch (hsotg->params.power_down) {
 	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		hprt0 = dwc2_read_hprt0(hsotg);
+
+		/*
+		 * Added port connection status checking which prevents exiting from
+		 * Partial Power Down mode from _dwc2_hcd_resume() if not in Partial
+		 * Power Down mode.
+		 */
+		if (hprt0 & HPRT0_CONNSTS) {
+			hsotg->lx_state = DWC2_L0;
+			goto unlock;
+		}
+
 		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
 		if (ret)
 			dev_err(hsotg->dev,
@@ -4463,7 +4465,6 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 		 * the global interrupts are disabled.
 		 */
 		dwc2_core_init(hsotg, false);
-		dwc2_enable_global_interrupts(hsotg);
 		dwc2_hcd_reinit(hsotg);
 		spin_lock_irqsave(&hsotg->lock, flags);
 
@@ -4472,15 +4473,14 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 		 * since an interrupt may rise.
 		 */
 		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		dwc2_enable_global_interrupts(hsotg);
+
 		break;
 	default:
 		hsotg->lx_state = DWC2_L0;
 		goto unlock;
 	}
 
-	/* Change Root port status, as port status change occurred after resume.*/
-	hsotg->flags.b.port_suspend_change = 1;
-
 	/*
 	 * Enable power if not already done.
 	 * This must not be spinlocked since duration
@@ -4492,10 +4492,7 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 		spin_lock_irqsave(&hsotg->lock, flags);
 	}
 
-	/* Enable external vbus supply after resuming the port. */
 	spin_unlock_irqrestore(&hsotg->lock, flags);
-	dwc2_vbus_supply_init(hsotg);
-
 	/* Wait for controller to correctly update D+/D- level */
 	usleep_range(3000, 5000);
 	spin_lock_irqsave(&hsotg->lock, flags);
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 58f53faab..4fd1bfb1c 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -101,10 +101,16 @@ static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 	if (ret)
 		return ret;
 
+	if (hsotg->utmi_clk) {
+		ret = clk_prepare_enable(hsotg->utmi_clk);
+		if (ret)
+			goto err_dis_reg;
+	}
+
 	if (hsotg->clk) {
 		ret = clk_prepare_enable(hsotg->clk);
 		if (ret)
-			return ret;
+			goto err_dis_utmi_clk;
 	}
 
 	if (hsotg->uphy) {
@@ -113,10 +119,29 @@ static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 		ret = hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);
 	} else {
 		ret = phy_init(hsotg->phy);
-		if (ret == 0)
+		if (ret == 0) {
 			ret = phy_power_on(hsotg->phy);
+			if (ret)
+				phy_exit(hsotg->phy);
+		}
 	}
 
+	if (ret)
+		goto err_dis_clk;
+
+	return 0;
+
+err_dis_clk:
+	if (hsotg->clk)
+		clk_disable_unprepare(hsotg->clk);
+
+err_dis_utmi_clk:
+	if (hsotg->utmi_clk)
+		clk_disable_unprepare(hsotg->utmi_clk);
+
+err_dis_reg:
+	regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
+
 	return ret;
 }
 
@@ -156,6 +181,9 @@ static int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)
 	if (hsotg->clk)
 		clk_disable_unprepare(hsotg->clk);
 
+	if (hsotg->utmi_clk)
+		clk_disable_unprepare(hsotg->utmi_clk);
+
 	return regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
 }
 
@@ -245,6 +273,11 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	if (IS_ERR(hsotg->clk))
 		return dev_err_probe(hsotg->dev, PTR_ERR(hsotg->clk), "cannot get otg clock\n");
 
+	hsotg->utmi_clk = devm_clk_get_optional(hsotg->dev, "utmi");
+	if (IS_ERR(hsotg->utmi_clk))
+		return dev_err_probe(hsotg->dev, PTR_ERR(hsotg->utmi_clk),
+				     "cannot get utmi clock\n");
+
 	/* Regulators */
 	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
 		hsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];
@@ -616,8 +649,19 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 	bool is_device_mode = dwc2_is_device_mode(dwc2);
 	int ret = 0;
 
-	if (is_device_mode)
+	if (is_device_mode) {
+		/*
+		 * Handle the case when bus has been suspended prior to platform suspend.
+		 * As the lx_state is DWC2_L2, dwc2_hsotg_suspend() is then a no-op.
+		 * So need to exit clock gating first, so the gadget can be suspended and
+		 * resumed later on.
+		 */
+		if (dwc2->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&
+		    dwc2->bus_suspended)
+			dwc2_gadget_exit_clock_gating(dwc2, 0);
+
 		dwc2_hsotg_suspend(dwc2);
+	}
 
 	dwc2_drd_suspend(dwc2);
 
@@ -658,6 +702,9 @@ static int __maybe_unused dwc2_suspend(struct device *dev)
 		dwc2->phy_off_for_suspend = true;
 	}
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		enable_irq_wake(dwc2->irq);
+
 	return ret;
 }
 
@@ -666,6 +713,9 @@ static int __maybe_unused dwc2_resume(struct device *dev)
 	struct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);
 	int ret = 0;
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(dwc2->irq);
+
 	if (dwc2->phy_off_for_suspend && dwc2->ll_hw_enabled) {
 		ret = __dwc2_lowlevel_hw_enable(dwc2);
 		if (ret)
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index 864fef540..e42fdf0a5 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -127,6 +127,17 @@ config USB_DWC3_ST
 	  inside (i.e. STiH407).
 	  Say 'Y' or 'M' if you have one such device.
 
+config USB_DWC3_STM32
+        tristate "STM32 DWC3 support"
+        depends on (ARCH_STM32 || COMPILE_TEST) && OF
+        default USB_DWC3
+        help
+          Support for DesignWare Core USB3 controller on STM32 SOCs.
+
+          This selects STM32 SoC glue layer support for the DWC3
+          device driver. This driver is used on for the STM32 series
+          SOCs DWC3 USB controller.
+
 config USB_DWC3_QCOM
 	tristate "Qualcomm Platform"
 	depends on ARCH_QCOM || COMPILE_TEST
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 9f66bd82b..27ad540eb 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_USB_DWC3_KEYSTONE)		+= dwc3-keystone.o
 obj-$(CONFIG_USB_DWC3_MESON_G12A)	+= dwc3-meson-g12a.o
 obj-$(CONFIG_USB_DWC3_OF_SIMPLE)	+= dwc3-of-simple.o
 obj-$(CONFIG_USB_DWC3_ST)		+= dwc3-st.o
+obj-$(CONFIG_USB_DWC3_STM32)		+= dwc3-stm32.o
 obj-$(CONFIG_USB_DWC3_QCOM)		+= dwc3-qcom.o
 obj-$(CONFIG_USB_DWC3_IMX8MP)		+= dwc3-imx8mp.o
 obj-$(CONFIG_USB_DWC3_XILINX)		+= dwc3-xilinx.o
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 011a3909f..dbf74a735 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -104,6 +104,27 @@ static int dwc3_get_dr_mode(struct dwc3 *dwc)
 	return 0;
 }
 
+void dwc3_enable_susphy(struct dwc3 *dwc, bool enable)
+{
+	u32 reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
+	if (enable && !dwc->dis_u3_susphy_quirk)
+		reg |= DWC3_GUSB3PIPECTL_SUSPHY;
+	else
+		reg &= ~DWC3_GUSB3PIPECTL_SUSPHY;
+
+	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);
+
+	reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
+	if (enable && !dwc->dis_u2_susphy_quirk)
+		reg |= DWC3_GUSB2PHYCFG_SUSPHY;
+	else
+		reg &= ~DWC3_GUSB2PHYCFG_SUSPHY;
+
+	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
+}
+
 void dwc3_set_prtcap(struct dwc3 *dwc, u32 mode)
 {
 	u32 reg;
@@ -137,12 +158,27 @@ static void __dwc3_set_mode(struct work_struct *work)
 	if (!desired_dr_role)
 		goto out;
 
-	if (desired_dr_role == dwc->current_dr_role)
+	if (desired_dr_role == dwc->current_dr_role) {
+		switch (dwc->current_dr_role) {
+		case DWC3_GCTL_PRTCAP_HOST:
+			phy_set_mode_ext(dwc->usb2_generic_phy, PHY_MODE_USB_HOST, dwc->submode);
+			phy_set_mode_ext(dwc->usb3_generic_phy, PHY_MODE_USB_HOST, dwc->submode);
+			break;
+		case DWC3_GCTL_PRTCAP_DEVICE:
+			phy_set_mode_ext(dwc->usb2_generic_phy, PHY_MODE_USB_DEVICE, dwc->submode);
+			phy_set_mode_ext(dwc->usb3_generic_phy, PHY_MODE_USB_DEVICE, dwc->submode);
+			break;
+		default:
+			break;
+		}
 		goto out;
+	}
 
 	if (desired_dr_role == DWC3_GCTL_PRTCAP_OTG && dwc->edev)
 		goto out;
 
+	dwc3_enable_susphy(dwc, false);
+
 	switch (dwc->current_dr_role) {
 	case DWC3_GCTL_PRTCAP_HOST:
 		dwc3_host_exit(dwc);
@@ -200,8 +236,8 @@ static void __dwc3_set_mode(struct work_struct *work)
 		} else {
 			if (dwc->usb2_phy)
 				otg_set_vbus(dwc->usb2_phy->otg, true);
-			phy_set_mode(dwc->usb2_generic_phy, PHY_MODE_USB_HOST);
-			phy_set_mode(dwc->usb3_generic_phy, PHY_MODE_USB_HOST);
+			phy_set_mode_ext(dwc->usb2_generic_phy, PHY_MODE_USB_HOST, dwc->submode);
+			phy_set_mode_ext(dwc->usb3_generic_phy, PHY_MODE_USB_HOST, dwc->submode);
 			if (dwc->dis_split_quirk) {
 				reg = dwc3_readl(dwc->regs, DWC3_GUCTL3);
 				reg |= DWC3_GUCTL3_SPLITDISABLE;
@@ -216,8 +252,8 @@ static void __dwc3_set_mode(struct work_struct *work)
 
 		if (dwc->usb2_phy)
 			otg_set_vbus(dwc->usb2_phy->otg, false);
-		phy_set_mode(dwc->usb2_generic_phy, PHY_MODE_USB_DEVICE);
-		phy_set_mode(dwc->usb3_generic_phy, PHY_MODE_USB_DEVICE);
+		phy_set_mode_ext(dwc->usb2_generic_phy, PHY_MODE_USB_DEVICE, dwc->submode);
+		phy_set_mode_ext(dwc->usb3_generic_phy, PHY_MODE_USB_DEVICE, dwc->submode);
 
 		ret = dwc3_gadget_init(dwc);
 		if (ret)
@@ -237,7 +273,7 @@ static void __dwc3_set_mode(struct work_struct *work)
 	mutex_unlock(&dwc->mutex);
 }
 
-void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
+void dwc3_set_mode_ext(struct dwc3 *dwc, u32 mode, int submode)
 {
 	unsigned long flags;
 
@@ -246,6 +282,7 @@ void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
 
 	spin_lock_irqsave(&dwc->lock, flags);
 	dwc->desired_dr_role = mode;
+	dwc->submode = submode;
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	queue_work(system_freezable_wq, &dwc->drd_work);
@@ -1238,21 +1275,6 @@ static int dwc3_core_init(struct dwc3 *dwc)
 	if (ret)
 		goto err1;
 
-	if (hw_mode == DWC3_GHWPARAMS0_MODE_DRD &&
-	    !DWC3_VER_IS_WITHIN(DWC3, ANY, 194A)) {
-		if (!dwc->dis_u3_susphy_quirk) {
-			reg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
-			reg |= DWC3_GUSB3PIPECTL_SUSPHY;
-			dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);
-		}
-
-		if (!dwc->dis_u2_susphy_quirk) {
-			reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
-			reg |= DWC3_GUSB2PHYCFG_SUSPHY;
-			dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);
-		}
-	}
-
 	dwc3_core_setup_global_control(dwc);
 	dwc3_core_num_eps(dwc);
 
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 889c122da..f199fb28c 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -978,6 +978,7 @@ struct dwc3_scratchpad_array {
  * @ep0_usb_req: dummy req used while handling STD USB requests
  * @scratch_addr: dma address of scratchbuf
  * @ep0_in_setup: one control transfer is completed and enter setup phase
+ * @xhci_plat_data: private data for xhci callback
  * @lock: for synchronizing
  * @mutex: for mode switching
  * @dev: pointer to our struct device
@@ -1138,6 +1139,8 @@ struct dwc3 {
 	struct dwc3_request	ep0_usb_req;
 	struct completion	ep0_in_setup;
 
+	void			*xhci_plat_data;
+
 	/* device lock */
 	spinlock_t		lock;
 
@@ -1179,6 +1182,7 @@ struct dwc3 {
 	enum usb_dr_mode	dr_mode;
 	u32			current_dr_role;
 	u32			desired_dr_role;
+	int			submode;
 	struct extcon_dev	*edev;
 	struct notifier_block	edev_nb;
 	enum usb_phy_interface	hsphy_mode;
@@ -1511,7 +1515,9 @@ struct dwc3_gadget_ep_cmd_params {
 
 /* prototypes */
 void dwc3_set_prtcap(struct dwc3 *dwc, u32 mode);
-void dwc3_set_mode(struct dwc3 *dwc, u32 mode);
+#define dwc3_set_mode(dwc3, mode) \
+	dwc3_set_mode_ext(dwc3, mode, USB_ROLE_NONE)
+void dwc3_set_mode_ext(struct dwc3 *dwc, u32 mode, int submode);
 u32 dwc3_core_fifo_space(struct dwc3_ep *dep, u8 type);
 
 #define DWC3_IP_IS(_ip)							\
@@ -1558,6 +1564,7 @@ int dwc3_event_buffers_setup(struct dwc3 *dwc);
 void dwc3_event_buffers_cleanup(struct dwc3 *dwc);
 
 int dwc3_core_soft_reset(struct dwc3 *dwc);
+void dwc3_enable_susphy(struct dwc3 *dwc, bool enable);
 
 #if IS_ENABLED(CONFIG_USB_DWC3_HOST) || IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE)
 int dwc3_host_init(struct dwc3 *dwc);
diff --git a/drivers/usb/dwc3/drd.c b/drivers/usb/dwc3/drd.c
index 57ddd2e43..ef733ecc5 100644
--- a/drivers/usb/dwc3/drd.c
+++ b/drivers/usb/dwc3/drd.c
@@ -440,6 +440,7 @@ static int dwc3_drd_notifier(struct notifier_block *nb,
 
 #if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 #define ROLE_SWITCH 1
+static enum usb_role dwc3_usb_role_switch_get(struct usb_role_switch *sw);
 static int dwc3_usb_role_switch_set(struct usb_role_switch *sw,
 				    enum usb_role role)
 {
@@ -461,7 +462,8 @@ static int dwc3_usb_role_switch_set(struct usb_role_switch *sw,
 		break;
 	}
 
-	dwc3_set_mode(dwc, mode);
+	dwc3_set_mode_ext(dwc, mode, role);
+
 	return 0;
 }
 
@@ -497,15 +499,19 @@ static int dwc3_setup_role_switch(struct dwc3 *dwc)
 {
 	struct usb_role_switch_desc dwc3_role_switch = {NULL};
 	u32 mode;
+	int submode = USB_ROLE_NONE;
 
 	dwc->role_switch_default_mode = usb_get_role_switch_default_mode(dwc->dev);
 	if (dwc->role_switch_default_mode == USB_DR_MODE_HOST) {
 		mode = DWC3_GCTL_PRTCAP_HOST;
+		submode = USB_ROLE_HOST;
 	} else {
+		if (dwc->role_switch_default_mode == USB_DR_MODE_PERIPHERAL)
+			submode = USB_ROLE_DEVICE;
 		dwc->role_switch_default_mode = USB_DR_MODE_PERIPHERAL;
 		mode = DWC3_GCTL_PRTCAP_DEVICE;
 	}
-	dwc3_set_mode(dwc, mode);
+	dwc3_set_mode_ext(dwc, mode, submode);
 
 	dwc3_role_switch.fwnode = dev_fwnode(dwc->dev);
 	dwc3_role_switch.set = dwc3_usb_role_switch_set;
diff --git a/drivers/usb/dwc3/dwc3-stm32.c b/drivers/usb/dwc3/dwc3-stm32.c
new file mode 100644
index 000000000..6861e13f0
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-stm32.c
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * dwc3-stm32.c - DWC3 Specific Glue layer for STM32
+ *
+ * Copyright (C) 2022 STMicroelectronics  All Rights Reserved
+ *
+ * Author: Pankaj Dev <pankaj.dev@st.com> for STMicroelectronics.
+ *
+ * Inspired by dwc3-st.c
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/usb/of.h>
+
+#include "core.h"
+#include "io.h"
+
+#define SYSCFG_USB3DRCR_HOST_PORT_POWER_CONTROL_PRESENT_MASK     BIT(0)
+#define SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK     BIT(1)
+#define SYSCFG_USB3DRCR_VBUSEN_POLARITY_MASK     BIT(2)
+#define SYSCFG_USB3DRCR_USB2ONLYH_MASK           BIT(3)             // USB2-only Mode for Host
+#define SYSCFG_USB3DRCR_USB2ONLYD_MASK           BIT(4)             // USB2-only Mode for Device
+
+/**
+ * struct stm32_dwc3 - dwc3-stm32 driver private structure
+ * @dev:			device pointer
+ * @regmap:			regmap pointer for getting syscfg
+ * @syscfg_usb3drcr_reg_off:	usb3drcr syscfg control offset
+ * @dr_mode:			drd static host/device config
+ * @usb2only_conf:		If only usb2-phy is present
+ * @vbusen_polarity_low:	vbusen signal polarity
+ * @ovrcur_polarity_low:	ovrcur signal polarity
+ * @prt_pwr_ctrl:		enable port power control
+ * @irq_wakeup:			wakeup irq
+ */
+struct stm32_dwc3 {
+	struct device *dev;
+	struct regmap *regmap;
+	int syscfg_usb3drcr_reg_off;
+	bool usb2only_conf;
+	bool vbusen_polarity_low;
+	bool ovrcur_polarity_low;
+	bool prt_pwr_ctrl;
+	int irq_wakeup;
+};
+
+/**
+ * stm32_dwc3_init: init the controller via glue logic
+ * @dwc3_data: driver private structure
+ */
+static int stm32_dwc3_init(struct stm32_dwc3 *dwc3_data)
+{
+	return regmap_update_bits(dwc3_data->regmap, dwc3_data->syscfg_usb3drcr_reg_off,
+				  SYSCFG_USB3DRCR_HOST_PORT_POWER_CONTROL_PRESENT_MASK |
+				  SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK |
+				  SYSCFG_USB3DRCR_VBUSEN_POLARITY_MASK |
+				  SYSCFG_USB3DRCR_USB2ONLYD_MASK |
+				  SYSCFG_USB3DRCR_USB2ONLYH_MASK,
+				  FIELD_PREP(SYSCFG_USB3DRCR_HOST_PORT_POWER_CONTROL_PRESENT_MASK,
+					     dwc3_data->prt_pwr_ctrl) |
+				  FIELD_PREP(SYSCFG_USB3DRCR_OVRCUR_POLARITY_MASK,
+					     dwc3_data->ovrcur_polarity_low) |
+				  FIELD_PREP(SYSCFG_USB3DRCR_VBUSEN_POLARITY_MASK,
+					     dwc3_data->vbusen_polarity_low) |
+				  FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYD_MASK,
+					    dwc3_data->usb2only_conf ? 1 : 0) |
+				  FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYH_MASK,
+					    dwc3_data->usb2only_conf ? 1 : 0));
+
+}
+
+static irqreturn_t stm32_dwc3_irq_wakeup_handler(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int stm32_dwc3_set_wakeup_capable(struct device *dev, void *data)
+{
+	device_set_wakeup_capable(dev, true);
+
+	return 0;
+}
+
+static int stm32_dwc3_probe(struct platform_device *pdev)
+{
+	struct stm32_dwc3 *dwc3_data;
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node, *child;
+	struct regmap *regmap;
+	int ret, irq;
+	bool wakeup_source;
+	struct reset_control *reset;
+
+	dwc3_data = devm_kzalloc(dev, sizeof(*dwc3_data), GFP_KERNEL);
+	if (!dwc3_data)
+		return -ENOMEM;
+
+	regmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	ret = of_property_read_u32_index(node, "st,syscfg", 1,
+					 &dwc3_data->syscfg_usb3drcr_reg_off);
+	if (ret) {
+		dev_err(dev, "can't get usb3drcr offset (%d)\n", ret);
+		return ret;
+	}
+	dev_vdbg(&pdev->dev, "syscfg-usb3drcr-reg offset 0x%x\n",
+		 dwc3_data->syscfg_usb3drcr_reg_off);
+
+	dwc3_data->dev = dev;
+	dwc3_data->regmap = regmap;
+
+	if (device_property_read_bool(dev, "st,vbusen-active-low"))
+		dwc3_data->vbusen_polarity_low = true;
+	if (device_property_read_bool(dev, "st,ovrcur-active-low"))
+		dwc3_data->ovrcur_polarity_low = true;
+
+	if (device_property_read_bool(dev, "st,enable-port-power-control"))
+		dwc3_data->prt_pwr_ctrl = true;
+
+	child = of_get_child_by_name(node, "usb");
+	if (!child)
+		return dev_err_probe(dev, -ENODEV, "failed to find dwc3 core node\n");
+
+	/*
+	 * Reset DWC3 IP required to clear the usb2only settings inside the ctrl
+	 * since if any other module (loaded before linux) uses dwc3 in usb2only mode
+	 * then there is an issue inside ctrl unless reset is asserted. Dwc3 core
+	 * deasserts the reset line during probe which is not enough since if reset
+	 * is already deasserted by some bootloader module then no reset is performed
+	 * on dwc3 ctrl, hence here we forcefully assert the ctrl reset line
+	 */
+	reset = of_reset_control_array_get_exclusive(child);
+	if (IS_ERR(reset))
+		return dev_err_probe(dev, PTR_ERR(reset), "failed to get reset handle\n");
+
+	ret = reset_control_assert(reset);
+	reset_control_put(reset);
+	if (ret) {
+		dev_err(dev, "failed to assert reset (%d)\n", ret);
+		return ret;
+	}
+
+	/* check if usb3-phy present, means NO usb2only mode */
+	dwc3_data->usb2only_conf = true;
+	if (of_count_phandle_with_args(child, "usb-phy", NULL) == 2) {
+		dwc3_data->usb2only_conf = false;
+	} else {
+		if (of_property_match_string(child, "phy-names", "usb3-phy") >= 0)
+			dwc3_data->usb2only_conf = false;
+	}
+	dev_info(&pdev->dev, "configured in %s mode\n", dwc3_data->usb2only_conf ? "usb2" : "usb3");
+
+	of_node_put(child);
+
+	/* ST glue logic init */
+	ret = stm32_dwc3_init(dwc3_data);
+	if (ret)
+		return dev_err_probe(dev, ret, "dwc3 glue init failed\n");
+
+	wakeup_source = device_property_read_bool(dev, "wakeup-source");
+	if (wakeup_source) {
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0)
+			return dev_err_probe(&pdev->dev, irq, "failed to get IRQ\n");
+		dwc3_data->irq_wakeup = irq;
+
+		ret = devm_request_threaded_irq(dev, dwc3_data->irq_wakeup, NULL,
+						stm32_dwc3_irq_wakeup_handler, IRQF_ONESHOT,
+						NULL, NULL);
+		if (ret)
+			return dev_err_probe(dev, ret, "unable to request wake IRQ %d\n",
+					     dwc3_data->irq_wakeup);
+
+		device_set_wakeup_capable(dev, true);
+	}
+
+	/* Allocate and initialize the core */
+	ret = devm_of_platform_populate(dev);
+	if (ret)
+		return dev_err_probe(dev, ret, "failed to add dwc3 core\n");
+
+	platform_set_drvdata(pdev, dwc3_data);
+
+	if (wakeup_source)
+		device_for_each_child(dev, NULL, stm32_dwc3_set_wakeup_capable);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_dwc3_suspend(struct device *dev)
+{
+	struct stm32_dwc3 *dwc3_data = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev)) {
+		enable_irq_wake(dwc3_data->irq_wakeup);
+		return 0;
+	}
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_dwc3_resume(struct device *dev)
+{
+	struct stm32_dwc3 *dwc3_data = dev_get_drvdata(dev);
+	int ret;
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev)) {
+		disable_irq_wake(dwc3_data->irq_wakeup);
+		return 0;
+	}
+
+	ret = pinctrl_pm_select_default_state(dev);
+	if (ret) {
+		dev_err(dev, "pinctrl select during resume (%d)\n", ret);
+		return ret;
+	}
+
+	/* ST glue logic init */
+	ret = stm32_dwc3_init(dwc3_data);
+	if (ret) {
+		dev_err(dev, "err setting syscfg_usb3drcr_reg (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(stm32_dwc3_dev_pm_ops, stm32_dwc3_suspend, stm32_dwc3_resume);
+
+static const struct of_device_id stm32_dwc3_match[] = {
+	{ .compatible = "st,stm32mp25-dwc3" },
+	{ /* sentinel */ },
+};
+
+MODULE_DEVICE_TABLE(of, stm32_dwc3_match);
+
+static struct platform_driver stm32_dwc3_driver = {
+	.probe = stm32_dwc3_probe,
+	.driver = {
+		.name = "usb-stm32-dwc3",
+		.of_match_table = stm32_dwc3_match,
+		.pm = &stm32_dwc3_dev_pm_ops,
+	},
+};
+
+module_platform_driver(stm32_dwc3_driver);
+
+MODULE_AUTHOR("Pankaj Dev <pankaj.dev@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 DWC3 Specific Glue layer");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index b134110cc..a4180a791 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -2831,6 +2831,7 @@ static int __dwc3_gadget_start(struct dwc3 *dwc)
 	dwc3_ep0_out_start(dwc);
 
 	dwc3_gadget_enable_irq(dwc);
+	dwc3_enable_susphy(dwc, true);
 
 	return 0;
 
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index f4d8e80c4..f0b22b1aa 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -11,8 +11,32 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 
+#include "../host/xhci-plat.h"
+
+#include "io.h"
 #include "core.h"
 
+static void dwc3_xhci_post_plat_start(struct usb_hcd *hcd)
+{
+	struct platform_device *pdev;
+	struct xhci_plat_priv *priv;
+	struct dwc3 *dwc;
+
+	if (!usb_hcd_is_primary_hcd(hcd))
+		return;
+
+	pdev = to_platform_device(hcd->self.controller);
+	priv = dev_get_platdata(&pdev->dev);
+
+	dwc = priv->data;
+
+	/* Only apply to DRD mode */
+	if (DWC3_GHWPARAMS0_MODE(dwc->hwparams.hwparams0) != DWC3_GHWPARAMS0_MODE_DRD)
+		return;
+
+	dwc3_enable_susphy(dwc, true);
+}
+
 static void dwc3_host_fill_xhci_irq_res(struct dwc3 *dwc,
 					int irq, char *name)
 {
@@ -68,6 +92,8 @@ int dwc3_host_init(struct dwc3 *dwc)
 {
 	struct property_entry	props[5];
 	struct platform_device	*xhci;
+	struct xhci_plat_priv dwc3_xhci_plat_data = { 0 };
+
 	int			ret, irq;
 	int			prop_idx = 0;
 
@@ -122,9 +148,18 @@ int dwc3_host_init(struct dwc3 *dwc)
 		}
 	}
 
+	dwc3_xhci_plat_data.post_plat_start = dwc3_xhci_post_plat_start;
+	dwc3_xhci_plat_data.data = dwc;
+
+	ret = platform_device_add_data(xhci, &dwc3_xhci_plat_data,
+				       sizeof(struct xhci_plat_priv));
+	if (ret)
+		goto err;
+
 	ret = platform_device_add(xhci);
 	if (ret) {
 		dev_err(dwc->dev, "failed to register xHCI device\n");
+		kfree(dwc->xhci_plat_data);
 		goto err;
 	}
 
diff --git a/drivers/usb/gadget/function/f_ncm.c b/drivers/usb/gadget/function/f_ncm.c
index 5e78fcc63..460c9bbe3 100644
--- a/drivers/usb/gadget/function/f_ncm.c
+++ b/drivers/usb/gadget/function/f_ncm.c
@@ -1620,10 +1620,7 @@ static void ncm_free_inst(struct usb_function_instance *f)
 	struct f_ncm_opts *opts;
 
 	opts = container_of(f, struct f_ncm_opts, func_inst);
-	if (opts->bound)
-		gether_cleanup(netdev_priv(opts->net));
-	else
-		free_netdev(opts->net);
+	free_netdev(opts->net);
 	kfree(opts->ncm_interf_group);
 	kfree(opts);
 }
@@ -1682,6 +1679,7 @@ static void ncm_free(struct usb_function *f)
 static void ncm_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_ncm *ncm = func_to_ncm(f);
+	struct f_ncm_opts *opts = container_of(f->fi, struct f_ncm_opts, func_inst);
 
 	DBG(c->cdev, "ncm unbind\n");
 
@@ -1700,6 +1698,9 @@ static void ncm_unbind(struct usb_configuration *c, struct usb_function *f)
 
 	kfree(ncm->notify_req->buf);
 	usb_ep_free_request(ncm->notify, ncm->notify_req);
+
+	if (opts->bound)
+		gether_unregister_netdev(netdev_priv(opts->net));
 }
 
 static struct usb_function *ncm_alloc(struct usb_function_instance *fi)
diff --git a/drivers/usb/gadget/function/u_ether.c b/drivers/usb/gadget/function/u_ether.c
index 1f420ff8f..32c05a45e 100644
--- a/drivers/usb/gadget/function/u_ether.c
+++ b/drivers/usb/gadget/function/u_ether.c
@@ -1053,6 +1053,22 @@ int gether_set_ifname(struct net_device *net, const char *name, int len)
 }
 EXPORT_SYMBOL_GPL(gether_set_ifname);
 
+/*
+ * gether_unregister_netdev - unregister Ethernet-over-USB device
+ * Context: may sleep
+ *
+ * This is called to unregister all resources allocated by @gether_register_netdev().
+ */
+void gether_unregister_netdev(struct eth_dev *dev)
+{
+	if (!dev)
+		return;
+
+	unregister_netdev(dev->net);
+	flush_work(&dev->work);
+}
+EXPORT_SYMBOL_GPL(gether_unregister_netdev);
+
 /*
  * gether_cleanup - remove Ethernet-over-USB device
  * Context: may sleep
@@ -1064,8 +1080,7 @@ void gether_cleanup(struct eth_dev *dev)
 	if (!dev)
 		return;
 
-	unregister_netdev(dev->net);
-	flush_work(&dev->work);
+	gether_unregister_netdev(dev);
 	free_netdev(dev->net);
 }
 EXPORT_SYMBOL_GPL(gether_cleanup);
diff --git a/drivers/usb/gadget/function/u_ether.h b/drivers/usb/gadget/function/u_ether.h
index 40144546d..44d549806 100644
--- a/drivers/usb/gadget/function/u_ether.h
+++ b/drivers/usb/gadget/function/u_ether.h
@@ -257,6 +257,7 @@ int gether_get_ifname(struct net_device *net, char *name, int len);
 int gether_set_ifname(struct net_device *net, const char *name, int len);
 
 void gether_cleanup(struct eth_dev *dev);
+void gether_unregister_netdev(struct eth_dev *dev);
 
 /* connect/disconnect is handled by individual functions */
 struct net_device *gether_connect(struct gether *);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 247568bc1..10a53cb5e 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -126,6 +126,19 @@ config USB_BRCMSTB
 	  Disabling this will keep the controllers and corresponding
 	  PHYs powered down.
 
+config USB_STM32_USBH
+	tristate "STM32 USB2 Host Glue support"
+	depends on ARCH_STM32 || COMPILE_TEST
+	select USB_OHCI_HCD_PLATFORM if USB_OHCI_HCD
+	select USB_EHCI_HCD_PLATFORM if USB_EHCI_HCD
+	help
+	  Enables support for USB2 Host controller on STM32MP25, configures
+	  glue logic around EHCI and OHCI host controller handled via
+          ehci-platform.o and ohci-platform.o
+
+	  Disabling this will keep the controllers and corresponding
+	  PHYs powered down.
+
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on HAS_DMA && HAS_IOMEM
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 2c8a61be7..5afa021d4 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -87,3 +87,4 @@ obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
 obj-$(CONFIG_USB_XEN_HCD)	+= xen-hcd.o
+obj-$(CONFIG_USB_STM32_USBH)	+= usbh-stm32.o
diff --git a/drivers/usb/host/ehci-platform.c b/drivers/usb/host/ehci-platform.c
index fe497c876..124225744 100644
--- a/drivers/usb/host/ehci-platform.c
+++ b/drivers/usb/host/ehci-platform.c
@@ -35,6 +35,7 @@
 #include <linux/usb/hcd.h>
 #include <linux/usb/ehci_pdriver.h>
 #include <linux/usb/of.h>
+#include <linux/pm_wakeirq.h>
 
 #include "ehci.h"
 
@@ -374,7 +375,9 @@ static int ehci_platform_probe(struct platform_device *dev)
 	if (err)
 		goto err_power;
 
-	device_wakeup_enable(hcd->self.controller);
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, true);
+
 	device_enable_async_suspend(hcd->self.controller);
 	platform_set_drvdata(dev, hcd);
 
@@ -410,6 +413,9 @@ static int ehci_platform_remove(struct platform_device *dev)
 	if (priv->quirk_poll)
 		quirk_poll_end(priv);
 
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, false);
+
 	usb_remove_hcd(hcd);
 
 	if (pdata->power_off)
@@ -434,7 +440,7 @@ static int __maybe_unused ehci_platform_suspend(struct device *dev)
 	struct usb_ehci_pdata *pdata = dev_get_platdata(dev);
 	struct platform_device *pdev = to_platform_device(dev);
 	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
-	bool do_wakeup = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev) || device_wakeup_path(dev);
 	int ret;
 
 	if (priv->quirk_poll)
@@ -447,6 +453,9 @@ static int __maybe_unused ehci_platform_suspend(struct device *dev)
 	if (pdata->power_suspend)
 		pdata->power_suspend(pdev);
 
+	if (do_wakeup)
+		enable_irq_wake(hcd->irq);
+
 	return ret;
 }
 
@@ -458,6 +467,9 @@ static int __maybe_unused ehci_platform_resume(struct device *dev)
 	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
 	struct device *companion_dev;
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(hcd->irq);
+
 	if (pdata->power_on) {
 		int err = pdata->power_on(pdev);
 		if (err < 0)
diff --git a/drivers/usb/host/ohci-platform.c b/drivers/usb/host/ohci-platform.c
index a84305091..6ee4075dc 100644
--- a/drivers/usb/host/ohci-platform.c
+++ b/drivers/usb/host/ohci-platform.c
@@ -215,7 +215,8 @@ static int ohci_platform_probe(struct platform_device *dev)
 	if (err)
 		goto err_power;
 
-	device_wakeup_enable(hcd->self.controller);
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, true);
 
 	platform_set_drvdata(dev, hcd);
 
@@ -246,6 +247,9 @@ static int ohci_platform_remove(struct platform_device *dev)
 	struct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);
 	int clk;
 
+	if (of_property_read_bool(dev->dev.of_node, "wakeup-source"))
+		device_set_wakeup_capable(hcd->self.controller, false);
+
 	pm_runtime_get_sync(&dev->dev);
 	usb_remove_hcd(hcd);
 
@@ -274,7 +278,7 @@ static int ohci_platform_suspend(struct device *dev)
 	struct usb_hcd *hcd = dev_get_drvdata(dev);
 	struct usb_ohci_pdata *pdata = dev->platform_data;
 	struct platform_device *pdev = to_platform_device(dev);
-	bool do_wakeup = device_may_wakeup(dev);
+	bool do_wakeup = device_may_wakeup(dev) || device_wakeup_path(dev);
 	int ret;
 
 	ret = ohci_suspend(hcd, do_wakeup);
@@ -284,6 +288,9 @@ static int ohci_platform_suspend(struct device *dev)
 	if (pdata->power_suspend)
 		pdata->power_suspend(pdev);
 
+	if (do_wakeup)
+		enable_irq_wake(hcd->irq);
+
 	return ret;
 }
 
@@ -293,6 +300,9 @@ static int ohci_platform_resume_common(struct device *dev, bool hibernated)
 	struct usb_ohci_pdata *pdata = dev_get_platdata(dev);
 	struct platform_device *pdev = to_platform_device(dev);
 
+	if (device_may_wakeup(dev) || device_wakeup_path(dev))
+		disable_irq_wake(hcd->irq);
+
 	if (pdata->power_on) {
 		int err = pdata->power_on(pdev);
 		if (err < 0)
diff --git a/drivers/usb/host/usbh-stm32.c b/drivers/usb/host/usbh-stm32.c
new file mode 100644
index 000000000..75fa1b06a
--- /dev/null
+++ b/drivers/usb/host/usbh-stm32.c
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STM32 USB2 EHCI/OHCI (USBH) controller glue driver
+ *
+ * Copyright (C) 2022 STMicroelectronics  All Rights Reserved
+ *
+ * Author: Pankaj Dev <pankaj.dev@st.com>
+ */
+
+#include <linux/usb.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+
+#define SYSCFG_USBHCR_OVRCUR_POLARITY_MASK      BIT(0)
+#define SYSCFG_USBHCR_VBUSEN_POLARITY_MASK      BIT(1)
+
+/**
+ * struct stm32_usbh - usbh-stm32 driver private structure
+ * @dev:			device pointer
+ * @regmap:			regmap pointer for getting syscfg
+ * @syscfg_usbhcr_reg_off:	usbhcr syscfg control offset
+ * @vbusen_polarity_low:	vbusen signal polarity
+ * @ovrcur_polarity_low:	ovrcur signal polarity
+ * @irq_wakeup:			wakeup irq
+ */
+struct stm32_usbh {
+	struct device *dev;
+	struct regmap *regmap;
+	int syscfg_usbhcr_reg_off;
+	bool vbusen_polarity_low;
+	bool ovrcur_polarity_low;
+	int irq_wakeup;
+};
+
+/**
+ * stm32_usbh_init: init the controller via glue logic
+ * @usbh_data: driver private structure
+ */
+static int stm32_usbh_init(struct stm32_usbh *usbh_data)
+{
+	return regmap_update_bits(usbh_data->regmap, usbh_data->syscfg_usbhcr_reg_off,
+				  SYSCFG_USBHCR_OVRCUR_POLARITY_MASK |
+				  SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+				  FIELD_PREP(SYSCFG_USBHCR_OVRCUR_POLARITY_MASK,
+					     usbh_data->ovrcur_polarity_low) |
+				  FIELD_PREP(SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+					     usbh_data->vbusen_polarity_low));
+}
+
+static irqreturn_t stm32_usbh_irq_wakeup_handler(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int stm32_usbh_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct regmap *regmap;
+	struct stm32_usbh *usbh_data;
+	int ret, irq;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	usbh_data = devm_kzalloc(dev, sizeof(*usbh_data), GFP_KERNEL);
+	if (!usbh_data)
+		return -ENOMEM;
+
+	regmap = syscon_regmap_lookup_by_phandle(node, "st,syscfg");
+	if (IS_ERR(regmap))
+		return dev_err_probe(&pdev->dev, PTR_ERR(regmap), "no st,syscfg node found\n");
+
+	ret = of_property_read_u32_index(node, "st,syscfg", 1, &usbh_data->syscfg_usbhcr_reg_off);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "can't get usbhcr offset\n");
+
+	dev_vdbg(&pdev->dev, "syscfg-usbhcr-reg offset 0x%x\n", usbh_data->syscfg_usbhcr_reg_off);
+
+	usbh_data->dev = dev;
+	usbh_data->regmap = regmap;
+
+	if (device_property_read_bool(dev, "st,vbusen-active-low"))
+		usbh_data->vbusen_polarity_low = true;
+	if (device_property_read_bool(dev, "st,ovrcur-active-low"))
+		usbh_data->ovrcur_polarity_low = true;
+
+	/* ST USBH glue logic init */
+	ret = stm32_usbh_init(usbh_data);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "err setting syscfg_usbhcr_reg\n");
+
+	if (device_property_read_bool(dev, "wakeup-source")) {
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0)
+			return dev_err_probe(dev, irq, "failed to get IRQ\n");
+		usbh_data->irq_wakeup = irq;
+
+		ret = devm_request_threaded_irq(dev, usbh_data->irq_wakeup, NULL,
+						stm32_usbh_irq_wakeup_handler, IRQF_ONESHOT,
+						NULL, NULL);
+		if (ret)
+			return dev_err_probe(dev, ret, "unable to request wake IRQ %d\n",
+					     usbh_data->irq_wakeup);
+
+		device_set_wakeup_capable(dev, true);
+	}
+
+	/* Populate the ehci and ohci child nodes */
+	ret = devm_of_platform_populate(dev);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to add ehci/ohci devices\n");
+
+	platform_set_drvdata(pdev, usbh_data);
+
+	return 0;
+}
+
+static int __maybe_unused stm32_usbh_suspend(struct device *dev)
+{
+	struct stm32_usbh *usbh_data = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev)) {
+		enable_irq_wake(usbh_data->irq_wakeup);
+		return 0;
+	}
+
+	return pinctrl_pm_select_sleep_state(dev);
+}
+
+static int __maybe_unused stm32_usbh_resume(struct device *dev)
+{
+	struct stm32_usbh *usbh_data = dev_get_drvdata(dev);
+	int err;
+
+	if (device_may_wakeup(dev) || device_wakeup_path(dev)) {
+		disable_irq_wake(usbh_data->irq_wakeup);
+		return 0;
+	}
+
+	err = pinctrl_pm_select_default_state(dev);
+	if (err) {
+		dev_err(dev, "pinctrl select during resume error:%d\n", err);
+		return err;
+	}
+
+	/* ST USBH glue logic init */
+	err = stm32_usbh_init(usbh_data);
+	if (err) {
+		dev_err(dev, "err setting syscfg_usbhcr_reg (%d)\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(stm32_usbh_pm_ops, stm32_usbh_suspend, stm32_usbh_resume);
+
+static const struct of_device_id stm32_usbh_match[] = {
+	{ .compatible = "st,stm32mp25-usbh" },
+	{ /* sentinel */ },
+};
+
+MODULE_DEVICE_TABLE(of, stm32_usbh_match);
+
+static struct platform_driver stm32_usbh_driver = {
+	.probe = stm32_usbh_probe,
+	.driver = {
+		.name = "stm32-usbh",
+		.of_match_table = stm32_usbh_match,
+		.pm = &stm32_usbh_pm_ops,
+	},
+};
+
+module_platform_driver(stm32_usbh_driver);
+
+MODULE_AUTHOR("Pankaj Dev <pankaj.dev@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics STM32 EHCI/OHCI Specific Glue layer");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index b387d39bf..0f48be40c 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -44,6 +44,14 @@ static void xhci_priv_plat_start(struct usb_hcd *hcd)
 		priv->plat_start(hcd);
 }
 
+static void xhci_priv_post_plat_start(struct usb_hcd *hcd)
+{
+	struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
+
+	if (priv->post_plat_start)
+		priv->post_plat_start(hcd);
+}
+
 static int xhci_priv_init_quirk(struct usb_hcd *hcd)
 {
 	struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
@@ -101,8 +109,16 @@ static int xhci_plat_setup(struct usb_hcd *hcd)
 
 static int xhci_plat_start(struct usb_hcd *hcd)
 {
+	int ret;
+
 	xhci_priv_plat_start(hcd);
-	return xhci_run(hcd);
+	ret = xhci_run(hcd);
+	if (ret)
+		return ret;
+
+	xhci_priv_post_plat_start(hcd);
+
+	return 0;
 }
 
 #ifdef CONFIG_OF
diff --git a/drivers/usb/host/xhci-plat.h b/drivers/usb/host/xhci-plat.h
index 1fb149d1f..df6705a1e 100644
--- a/drivers/usb/host/xhci-plat.h
+++ b/drivers/usb/host/xhci-plat.h
@@ -14,9 +14,11 @@ struct xhci_plat_priv {
 	const char *firmware_name;
 	unsigned long long quirks;
 	void (*plat_start)(struct usb_hcd *);
+	void (*post_plat_start)(struct usb_hcd *);
 	int (*init_quirk)(struct usb_hcd *);
 	int (*suspend_quirk)(struct usb_hcd *);
 	int (*resume_quirk)(struct usb_hcd *);
+	void *data;
 };
 
 #define hcd_to_xhci_priv(h) ((struct xhci_plat_priv *)hcd_to_xhci(h)->priv)
diff --git a/drivers/usb/misc/onboard_usb_hub.c b/drivers/usb/misc/onboard_usb_hub.c
index 8edd0375e..7671c281b 100644
--- a/drivers/usb/misc/onboard_usb_hub.c
+++ b/drivers/usb/misc/onboard_usb_hub.c
@@ -98,13 +98,12 @@ static int __maybe_unused onboard_hub_suspend(struct device *dev)
 	mutex_lock(&hub->lock);
 
 	list_for_each_entry(node, &hub->udev_list, list) {
-		if (!device_may_wakeup(node->udev->bus->controller))
+		if (!device_may_wakeup(node->udev->bus->controller) &&
+		    !usb_wakeup_enabled_descendants(node->udev))
 			continue;
 
-		if (usb_wakeup_enabled_descendants(node->udev)) {
-			power_off = false;
-			break;
-		}
+		power_off = false;
+		break;
 	}
 
 	mutex_unlock(&hub->lock);
diff --git a/drivers/usb/typec/ucsi/ucsi.c b/drivers/usb/typec/ucsi/ucsi.c
index 0695ee54f..81dfe8901 100644
--- a/drivers/usb/typec/ucsi/ucsi.c
+++ b/drivers/usb/typec/ucsi/ucsi.c
@@ -1319,11 +1319,13 @@ static void ucsi_init_work(struct work_struct *work)
 
 	ret = ucsi_init(ucsi);
 	if (ret)
-		dev_err(ucsi->dev, "PPM init failed (%d)\n", ret);
+		dev_err_probe(ucsi->dev, ret, "PPM init failed\n");
 
 	if (ret == -EPROBE_DEFER) {
-		if (ucsi->work_count++ > UCSI_ROLE_SWITCH_WAIT_COUNT)
+		if (ucsi->work_count++ > UCSI_ROLE_SWITCH_WAIT_COUNT) {
+			dev_err(ucsi->dev, "PPM init failed, stop trying\n");
 			return;
+		}
 
 		queue_delayed_work(system_long_wq, &ucsi->work,
 				   UCSI_ROLE_SWITCH_INTERVAL);
diff --git a/drivers/usb/typec/ucsi/ucsi_stm32g0.c b/drivers/usb/typec/ucsi/ucsi_stm32g0.c
index 7b92f0c8d..58597dcdf 100644
--- a/drivers/usb/typec/ucsi/ucsi_stm32g0.c
+++ b/drivers/usb/typec/ucsi/ucsi_stm32g0.c
@@ -50,6 +50,9 @@
 #define STM32G0_FW_RSTGOBL	0x21	/* Reset and go to bootloader */
 #define STM32G0_FW_KEYWORD	0xa56959a6
 
+/* STM32MP25 specifics */
+#define STM32MP25_UCSI_USE_WQ	1
+
 /* ucsi_stm32g0_fw_info located at the end of the firmware */
 struct ucsi_stm32g0_fw_info {
 	u32 version;
@@ -68,6 +71,8 @@ struct ucsi_stm32g0 {
 	struct ucsi *ucsi;
 	bool suspended;
 	bool wakeup_event;
+	struct work_struct irq_work;
+	struct workqueue_struct *wq;
 };
 
 /*
@@ -395,9 +400,13 @@ static int ucsi_stm32g0_sync_write(struct ucsi *ucsi, unsigned int offset, const
 				   size_t len)
 {
 	struct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);
+	bool ack = UCSI_COMMAND(*(u64 *)val) == UCSI_ACK_CC_CI;
 	int ret;
 
-	set_bit(COMMAND_PENDING, &g0->flags);
+	if (ack)
+		set_bit(ACK_PENDING, &g0->flags);
+	else
+		set_bit(COMMAND_PENDING, &g0->flags);
 
 	ret = ucsi_stm32g0_async_write(ucsi, offset, val, len);
 	if (ret)
@@ -405,32 +414,48 @@ static int ucsi_stm32g0_sync_write(struct ucsi *ucsi, unsigned int offset, const
 
 	if (!wait_for_completion_timeout(&g0->complete, msecs_to_jiffies(5000)))
 		ret = -ETIMEDOUT;
+	else
+		return 0;
 
 out_clear_bit:
-	clear_bit(COMMAND_PENDING, &g0->flags);
+	if (ack)
+		clear_bit(ACK_PENDING, &g0->flags);
+	else
+		clear_bit(COMMAND_PENDING, &g0->flags);
 
 	return ret;
 }
 
-static irqreturn_t ucsi_stm32g0_irq_handler(int irq, void *data)
+static void ucsi_stm32g0_irq_work(struct work_struct *irq_work)
 {
-	struct ucsi_stm32g0 *g0 = data;
+	struct ucsi_stm32g0 *g0 = container_of(irq_work, struct ucsi_stm32g0, irq_work);
 	u32 cci;
 	int ret;
 
-	if (g0->suspended)
-		g0->wakeup_event = true;
-
 	ret = ucsi_stm32g0_read(g0->ucsi, UCSI_CCI, &cci, sizeof(cci));
 	if (ret)
-		return IRQ_NONE;
+		return;
 
 	if (UCSI_CCI_CONNECTOR(cci))
 		ucsi_connector_change(g0->ucsi, UCSI_CCI_CONNECTOR(cci));
 
-	if (test_bit(COMMAND_PENDING, &g0->flags) &&
-	    cci & (UCSI_CCI_ACK_COMPLETE | UCSI_CCI_COMMAND_COMPLETE))
+	if (cci & UCSI_CCI_ACK_COMPLETE && test_and_clear_bit(ACK_PENDING, &g0->flags))
+		complete(&g0->complete);
+	if (cci & UCSI_CCI_COMMAND_COMPLETE && test_and_clear_bit(COMMAND_PENDING, &g0->flags))
 		complete(&g0->complete);
+}
+
+static irqreturn_t ucsi_stm32g0_irq_handler(int irq, void *data)
+{
+	struct ucsi_stm32g0 *g0 = data;
+
+	if (g0->suspended)
+		g0->wakeup_event = true;
+
+	if (g0->wq)
+		queue_work(g0->wq, &g0->irq_work);
+	else
+		ucsi_stm32g0_irq_work(&g0->irq_work);
 
 	return IRQ_HANDLED;
 }
@@ -630,6 +655,7 @@ static int ucsi_stm32g0_probe(struct i2c_client *client, const struct i2c_device
 {
 	struct device *dev = &client->dev;
 	struct ucsi_stm32g0 *g0;
+	u32 use_wq;
 	int ret;
 
 	g0 = devm_kzalloc(dev, sizeof(*g0), GFP_KERNEL);
@@ -641,9 +667,23 @@ static int ucsi_stm32g0_probe(struct i2c_client *client, const struct i2c_device
 	init_completion(&g0->complete);
 	i2c_set_clientdata(client, g0);
 
+	use_wq = (uintptr_t)device_get_match_data(dev);
+	if (use_wq) {
+		/*
+		 * When using remoteproc (on MP25), I2C access for IRQ thread lead to deadlock.
+		 * Rather rely on dedicated workqueue to notify UCSI upper layer.
+		 */
+		g0->wq = alloc_ordered_workqueue("stm32-ucsi", 0);
+		if(!g0->wq)
+			return -ENOMEM;
+		INIT_WORK(&g0->irq_work, ucsi_stm32g0_irq_work);
+	}
+
 	g0->ucsi = ucsi_create(dev, &ucsi_stm32g0_ops);
-	if (IS_ERR(g0->ucsi))
-		return PTR_ERR(g0->ucsi);
+	if (IS_ERR(g0->ucsi)) {
+		ret = PTR_ERR(g0->ucsi);
+		goto free_wq;
+	}
 
 	ucsi_set_drvdata(g0->ucsi, g0);
 
@@ -684,6 +724,9 @@ static int ucsi_stm32g0_probe(struct i2c_client *client, const struct i2c_device
 		i2c_unregister_device(g0->i2c_bl);
 destroy:
 	ucsi_destroy(g0->ucsi);
+free_wq:
+	if (g0->wq)
+		destroy_workqueue(g0->wq);
 
 	return ret;
 }
@@ -697,6 +740,8 @@ static void ucsi_stm32g0_remove(struct i2c_client *client)
 	if (g0->fw_name)
 		i2c_unregister_device(g0->i2c_bl);
 	ucsi_destroy(g0->ucsi);
+	if (g0->wq)
+		destroy_workqueue(g0->wq);
 }
 
 static int ucsi_stm32g0_suspend(struct device *dev)
@@ -747,6 +792,7 @@ static DEFINE_SIMPLE_DEV_PM_OPS(ucsi_stm32g0_pm_ops, ucsi_stm32g0_suspend, ucsi_
 
 static const struct of_device_id __maybe_unused ucsi_stm32g0_typec_of_match[] = {
 	{ .compatible = "st,stm32g0-typec" },
+	{ .compatible = "st,stm32mp25-typec", .data = (void *)STM32MP25_UCSI_USE_WQ },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ucsi_stm32g0_typec_of_match);
diff --git a/drivers/video/backlight/gpio_backlight.c b/drivers/video/backlight/gpio_backlight.c
index 30ec5b684..7897f6f90 100644
--- a/drivers/video/backlight/gpio_backlight.c
+++ b/drivers/video/backlight/gpio_backlight.c
@@ -53,6 +53,7 @@ static int gpio_backlight_probe(struct platform_device *pdev)
 	struct backlight_device *bl;
 	struct gpio_backlight *gbl;
 	int ret, init_brightness, def_value;
+	u32 value;
 
 	gbl = devm_kzalloc(dev, sizeof(*gbl), GFP_KERNEL);
 	if (gbl == NULL)
@@ -92,7 +93,11 @@ static int gpio_backlight_probe(struct platform_device *pdev)
 	else
 		bl->props.power = FB_BLANK_UNBLANK;
 
-	bl->props.brightness = 1;
+	ret = device_property_read_u32(dev, "default-brightness-level", &value);
+	if (!ret && value <= props.max_brightness)
+		bl->props.brightness = value;
+	else
+		bl->props.brightness = 1;
 
 	init_brightness = backlight_get_brightness(bl);
 	ret = gpiod_direction_output(gbl->gpiod, init_brightness);
diff --git a/drivers/watchdog/arm_smc_wdt.c b/drivers/watchdog/arm_smc_wdt.c
index 8f3d0c3a0..f1268f433 100644
--- a/drivers/watchdog/arm_smc_wdt.c
+++ b/drivers/watchdog/arm_smc_wdt.c
@@ -46,6 +46,8 @@ static int smcwd_call(struct watchdog_device *wdd, enum smcwd_call call,
 		return -ENODEV;
 	if (res->a0 == PSCI_RET_INVALID_PARAMS)
 		return -EINVAL;
+	if (res->a0 == PSCI_RET_DISABLED)
+		return -ENODATA;
 	if (res->a0 != PSCI_RET_SUCCESS)
 		return -EIO;
 	return 0;
@@ -131,10 +133,20 @@ static int smcwd_probe(struct platform_device *pdev)
 
 	wdd->info = &smcwd_info;
 	/* get_timeleft is optional */
-	if (smcwd_call(wdd, SMCWD_GET_TIMELEFT, 0, NULL))
-		wdd->ops = &smcwd_ops;
-	else
+	err = smcwd_call(wdd, SMCWD_GET_TIMELEFT, 0, NULL);
+	switch (err) {
+	case 0:
+		if (IS_ENABLED(CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED))
+			set_bit(WDOG_HW_RUNNING, &wdd->status);
+		fallthrough;
+	case -ENODATA:
 		wdd->ops = &smcwd_timeleft_ops;
+		break;
+	default:
+		wdd->ops = &smcwd_ops;
+		break;
+	}
+
 	wdd->timeout = res.a2;
 	wdd->max_timeout = res.a2;
 	wdd->min_timeout = res.a1;
diff --git a/drivers/watchdog/stm32_iwdg.c b/drivers/watchdog/stm32_iwdg.c
index 570a71509..235595591 100644
--- a/drivers/watchdog/stm32_iwdg.c
+++ b/drivers/watchdog/stm32_iwdg.c
@@ -27,6 +27,7 @@
 #define IWDG_RLR	0x08 /* ReLoad Register */
 #define IWDG_SR		0x0C /* Status Register */
 #define IWDG_WINR	0x10 /* Windows Register */
+#define IWDG_VERR	0x3F4 /* Version Register */
 
 /* IWDG_KR register bit mask */
 #define KR_KEY_RELOAD	0xAAAA /* reload counter enable */
@@ -45,6 +46,13 @@
 /* IWDG_SR register bit mask */
 #define SR_PVU	BIT(0) /* Watchdog prescaler value update */
 #define SR_RVU	BIT(1) /* Watchdog counter reload value update */
+#define SR_ONF	BIT(8) /* Watchdog enable status bit */
+
+/* IWDG Compatibility */
+#define ONF_MIN_VER	0x31
+
+/* IWDG_VERR register mask */
+#define VERR_MASK	GENMASK(7, 0)
 
 /* set timeout to 100000 us */
 #define TIMEOUT_US	100000
@@ -72,6 +80,7 @@ struct stm32_iwdg {
 	struct clk		*clk_lsi;
 	struct clk		*clk_pclk;
 	unsigned int		rate;
+	unsigned int		hw_version;
 };
 
 static inline u32 reg_read(void __iomem *base, u32 reg)
@@ -199,6 +208,31 @@ static int stm32_iwdg_clk_init(struct platform_device *pdev,
 	return 0;
 }
 
+static bool stm32_iwdg_is_running(struct stm32_iwdg *wdt)
+{
+	bool running;
+	u32 rlr, sr;
+	int ret;
+
+	if (wdt->hw_version >= ONF_MIN_VER)
+		return (reg_read(wdt->regs, IWDG_SR) & SR_ONF) != 0;
+
+	/*
+	 * Workaround for old versions without IWDG_SR_ONF bit:
+	 * - write in IWDG_RLR_OFFSET
+	 * - wait for sync
+	 * - if sync succeeds, then iwdg is running
+	 */
+	reg_write(wdt->regs, IWDG_KR, KR_KEY_EWA);
+	rlr = reg_read(wdt->regs, IWDG_RLR);
+	reg_write(wdt->regs, IWDG_RLR, rlr);
+	ret = readl_poll_timeout(wdt->regs + IWDG_SR, sr, sr & SR_RVU, SLEEP_US, TIMEOUT_US);
+	running = ret ? false : true;
+	reg_write(wdt->regs, IWDG_KR, KR_KEY_DWA);
+
+	return running;
+}
+
 static const struct watchdog_info stm32_iwdg_info = {
 	.options	= WDIOF_SETTIMEOUT |
 			  WDIOF_MAGICCLOSE |
@@ -253,27 +287,15 @@ static int stm32_iwdg_probe(struct platform_device *pdev)
 	wdd->max_hw_heartbeat_ms = ((RLR_MAX + 1) * wdt->data->max_prescaler *
 				    1000) / wdt->rate;
 
+	wdt->hw_version = reg_read(wdt->regs, IWDG_VERR) & VERR_MASK;
+
 	watchdog_set_drvdata(wdd, wdt);
 	watchdog_set_nowayout(wdd, WATCHDOG_NOWAYOUT);
 	watchdog_init_timeout(wdd, 0, dev);
 
-	/*
-	 * In case of CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED is set
-	 * (Means U-Boot/bootloaders leaves the watchdog running)
-	 * When we get here we should make a decision to prevent
-	 * any side effects before user space daemon will take care of it.
-	 * The best option, taking into consideration that there is no
-	 * way to read values back from hardware, is to enforce watchdog
-	 * being run with deterministic values.
-	 */
-	if (IS_ENABLED(CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED)) {
-		ret = stm32_iwdg_start(wdd);
-		if (ret)
-			return ret;
-
+	if (IS_ENABLED(CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED) && stm32_iwdg_is_running(wdt))
 		/* Make sure the watchdog is serviced */
 		set_bit(WDOG_HW_RUNNING, &wdd->status);
-	}
 
 	ret = devm_watchdog_register_device(dev, wdd);
 	if (ret)
diff --git a/include/crypto/hash.h b/include/crypto/hash.h
index f5841992d..cb1f8d53b 100644
--- a/include/crypto/hash.h
+++ b/include/crypto/hash.h
@@ -160,8 +160,6 @@ struct shash_desc {
  */
 #define HASH_MAX_DESCSIZE	(sizeof(struct shash_desc) + 360)
 
-#define HASH_MAX_STATESIZE	512
-
 #define SHASH_DESC_ON_STACK(shash, ctx)					     \
 	char __##shash##_desc[sizeof(struct shash_desc) + HASH_MAX_DESCSIZE] \
 		__aligned(__alignof__(struct shash_desc));		     \
diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index 4d830fc55..aff22a4ea 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -815,6 +815,12 @@ struct drm_connector_state {
 	 */
 	unsigned int scaling_mode;
 
+	/**
+	 * @dithering: Connector property to control the
+	 * dithering.
+	 */
+	unsigned int dithering;
+
 	/**
 	 * @content_protection: Connector property to request content
 	 * protection. This is most commonly used for HDCP.
@@ -1463,6 +1469,12 @@ struct drm_connector {
 	 */
 	struct drm_property *scaling_mode_property;
 
+	/**
+	 * @dithering_property: Optional atomic property to control the
+	 * dithering.
+	 */
+	struct drm_property *dithering_property;
+
 	/**
 	 * @vrr_capable_property: Optional property to help userspace
 	 * query hardware support for variable refresh rate on a connector.
@@ -1811,6 +1823,8 @@ int drm_mode_create_scaling_mode_property(struct drm_device *dev);
 int drm_connector_attach_content_type_property(struct drm_connector *dev);
 int drm_connector_attach_scaling_mode_property(struct drm_connector *connector,
 					       u32 scaling_mode_mask);
+int drm_connector_attach_dithering_property(struct drm_connector *connector,
+					    u32 dithering_mask);
 int drm_connector_attach_vrr_capable_property(
 		struct drm_connector *connector);
 int drm_connector_attach_colorspace_property(struct drm_connector *connector);
diff --git a/include/dt-bindings/bus/stm32mp13_sys_bus.h b/include/dt-bindings/bus/stm32mp13_sys_bus.h
new file mode 100644
index 000000000..1160de87b
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp13_sys_bus.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H
+
+/* ETZPC IDs */
+#define STM32MP1_ETZPC_VREFBUF_ID	0
+#define STM32MP1_ETZPC_LPTIM2_ID	1
+#define STM32MP1_ETZPC_LPTIM3_ID	2
+#define STM32MP1_ETZPC_LTDC_ID		3
+#define STM32MP1_ETZPC_DCMIPP_ID	4
+#define STM32MP1_ETZPC_USBPHYCTRL_ID	5
+#define STM32MP1_ETZPC_DDRCTRLPHY_ID	6
+/* IDs 7-11 reserved */
+#define STM32MP1_ETZPC_IWDG1_ID		12
+#define STM32MP1_ETZPC_STGENC_ID	13
+/* IDs 14-15 reserved */
+#define STM32MP1_ETZPC_USART1_ID	16
+#define STM32MP1_ETZPC_USART2_ID	17
+#define STM32MP1_ETZPC_SPI4_ID		18
+#define STM32MP1_ETZPC_SPI5_ID		19
+#define STM32MP1_ETZPC_I2C3_ID		20
+#define STM32MP1_ETZPC_I2C4_ID		21
+#define STM32MP1_ETZPC_I2C5_ID		22
+#define STM32MP1_ETZPC_TIM12_ID		23
+#define STM32MP1_ETZPC_TIM13_ID		24
+#define STM32MP1_ETZPC_TIM14_ID		25
+#define STM32MP1_ETZPC_TIM15_ID		26
+#define STM32MP1_ETZPC_TIM16_ID		27
+#define STM32MP1_ETZPC_TIM17_ID		28
+/* IDs 29-31 reserved */
+#define STM32MP1_ETZPC_ADC1_ID		32
+#define STM32MP1_ETZPC_ADC2_ID		33
+#define STM32MP1_ETZPC_OTG_ID		34
+/* IDs 35-39 reserved */
+#define STM32MP1_ETZPC_TSC_ID		37
+#define STM32MP1_ETZPC_RNG_ID		40
+#define STM32MP1_ETZPC_HASH_ID		41
+#define STM32MP1_ETZPC_CRYP_ID		42
+#define STM32MP1_ETZPC_SAES_ID		43
+#define STM32MP1_ETZPC_PKA_ID		44
+#define STM32MP1_ETZPC_BKPSRAM_ID	45
+/* IDs 46-47 reserved */
+#define STM32MP1_ETZPC_ETH1_ID		48
+#define STM32MP1_ETZPC_ETH2_ID		49
+#define STM32MP1_ETZPC_SDMMC1_ID	50
+#define STM32MP1_ETZPC_SDMMC2_ID	51
+/* ID 52 reserved */
+#define STM32MP1_ETZPC_MCE_ID		53
+#define STM32MP1_ETZPC_FMC_ID		54
+#define STM32MP1_ETZPC_QSPI_ID		55
+/* IDs 56-59 reserved */
+#define STM32MP1_ETZPC_SRAM1_ID		60
+#define STM32MP1_ETZPC_SRAM2_ID		61
+#define STM32MP1_ETZPC_SRAM3_ID		62
+/* ID 63 reserved */
+
+#endif /* _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H */
diff --git a/include/dt-bindings/bus/stm32mp15_sys_bus.h b/include/dt-bindings/bus/stm32mp15_sys_bus.h
new file mode 100644
index 000000000..97eacc7b5
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp15_sys_bus.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H
+
+/* ETZPC IDs */
+#define STM32MP1_ETZPC_STGENC_ID	0
+#define STM32MP1_ETZPC_BKPSRAM_ID	1
+#define STM32MP1_ETZPC_IWDG1_ID		2
+#define STM32MP1_ETZPC_USART1_ID	3
+#define STM32MP1_ETZPC_SPI6_ID		4
+#define STM32MP1_ETZPC_I2C4_ID		5
+/* ID 6 reserved */
+#define STM32MP1_ETZPC_RNG1_ID		7
+#define STM32MP1_ETZPC_HASH1_ID		8
+#define STM32MP1_ETZPC_CRYP1_ID		9
+#define STM32MP1_ETZPC_DDRCTRL_ID	10
+#define STM32MP1_ETZPC_DDRPHYC_ID	11
+#define STM32MP1_ETZPC_I2C6_ID		12
+/* IDs 13-15 reserved */
+#define STM32MP1_ETZPC_TIM2_ID		16
+#define STM32MP1_ETZPC_TIM3_ID		17
+#define STM32MP1_ETZPC_TIM4_ID		18
+#define STM32MP1_ETZPC_TIM5_ID		19
+#define STM32MP1_ETZPC_TIM6_ID		20
+#define STM32MP1_ETZPC_TIM7_ID		21
+#define STM32MP1_ETZPC_TIM12_ID		22
+#define STM32MP1_ETZPC_TIM13_ID		23
+#define STM32MP1_ETZPC_TIM14_ID		24
+#define STM32MP1_ETZPC_LPTIM1_ID	25
+#define STM32MP1_ETZPC_WWDG1_ID		26
+#define STM32MP1_ETZPC_SPI2_ID		27
+#define STM32MP1_ETZPC_SPI3_ID		28
+#define STM32MP1_ETZPC_SPDIFRX_ID	29
+#define STM32MP1_ETZPC_USART2_ID	30
+#define STM32MP1_ETZPC_USART3_ID	31
+#define STM32MP1_ETZPC_UART4_ID		32
+#define STM32MP1_ETZPC_UART5_ID		33
+#define STM32MP1_ETZPC_I2C1_ID		34
+#define STM32MP1_ETZPC_I2C2_ID		35
+#define STM32MP1_ETZPC_I2C3_ID		36
+#define STM32MP1_ETZPC_I2C5_ID		37
+#define STM32MP1_ETZPC_CEC_ID		38
+#define STM32MP1_ETZPC_DAC_ID		39
+#define STM32MP1_ETZPC_UART7_ID		40
+#define STM32MP1_ETZPC_UART8_ID		41
+/* IDs 42-43 reserved */
+#define STM32MP1_ETZPC_MDIOS_ID		44
+/* IDs 45-47 reserved */
+#define STM32MP1_ETZPC_TIM1_ID		48
+#define STM32MP1_ETZPC_TIM8_ID		49
+/* ID 50 reserved */
+#define STM32MP1_ETZPC_USART6_ID	51
+#define STM32MP1_ETZPC_SPI1_ID		52
+#define STM32MP1_ETZPC_SPI4_ID		53
+#define STM32MP1_ETZPC_TIM15_ID		54
+#define STM32MP1_ETZPC_TIM16_ID		55
+#define STM32MP1_ETZPC_TIM17_ID		56
+#define STM32MP1_ETZPC_SPI5_ID		57
+#define STM32MP1_ETZPC_SAI1_ID		58
+#define STM32MP1_ETZPC_SAI2_ID		59
+#define STM32MP1_ETZPC_SAI3_ID		60
+#define STM32MP1_ETZPC_DFSDM_ID		61
+#define STM32MP1_ETZPC_TT_FDCAN_ID	62
+/* IDs 63 reserved */
+#define STM32MP1_ETZPC_LPTIM2_ID	64
+#define STM32MP1_ETZPC_LPTIM3_ID	65
+#define STM32MP1_ETZPC_LPTIM4_ID	66
+#define STM32MP1_ETZPC_LPTIM5_ID	67
+#define STM32MP1_ETZPC_SAI4_ID		68
+#define STM32MP1_ETZPC_VREFBUF_ID	69
+#define STM32MP1_ETZPC_DCMI_ID		70
+#define STM32MP1_ETZPC_CRC2_ID		71
+#define STM32MP1_ETZPC_ADC_ID		72
+#define STM32MP1_ETZPC_HASH2_ID		73
+#define STM32MP1_ETZPC_RNG2_ID		74
+#define STM32MP1_ETZPC_CRYP2_ID		75
+/* IDs 76-79 reserved */
+#define STM32MP1_ETZPC_SRAM1_ID		80
+#define STM32MP1_ETZPC_SRAM2_ID		81
+#define STM32MP1_ETZPC_SRAM3_ID		82
+#define STM32MP1_ETZPC_SRAM4_ID		83
+#define STM32MP1_ETZPC_RETRAM_ID	84
+#define STM32MP1_ETZPC_OTG_ID		85
+#define STM32MP1_ETZPC_SDMMC3_ID	86
+#define STM32MP1_ETZPC_DLYBSD3_ID	87
+#define STM32MP1_ETZPC_DMA1_ID		88
+#define STM32MP1_ETZPC_DMA2_ID		89
+#define STM32MP1_ETZPC_DMAMUX_ID	90
+#define STM32MP1_ETZPC_FMC_ID		91
+#define STM32MP1_ETZPC_QSPI_ID		92
+#define STM32MP1_ETZPC_DLYBQ_ID		93
+#define STM32MP1_ETZPC_ETH_ID		94
+/* ID 95 reserved */
+
+#endif /* _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H */
diff --git a/include/dt-bindings/bus/stm32mp25_sys_bus.h b/include/dt-bindings/bus/stm32mp25_sys_bus.h
new file mode 100644
index 000000000..76ad05cfb
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp25_sys_bus.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP25_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP25_SYS_BUS_H
+
+/* RIFSC ID */
+#define STM32MP25_RIFSC_TIM1_ID			0
+#define STM32MP25_RIFSC_TIM2_ID			1
+#define STM32MP25_RIFSC_TIM3_ID			2
+#define STM32MP25_RIFSC_TIM4_ID			3
+#define STM32MP25_RIFSC_TIM5_ID			4
+#define STM32MP25_RIFSC_TIM6_ID			5
+#define STM32MP25_RIFSC_TIM7_ID			6
+#define STM32MP25_RIFSC_TIM8_ID			7
+#define STM32MP25_RIFSC_TIM10_ID		8
+#define STM32MP25_RIFSC_TIM11_ID		9
+#define STM32MP25_RIFSC_TIM12_ID		10
+#define STM32MP25_RIFSC_TIM13_ID		11
+#define STM32MP25_RIFSC_TIM14_ID		12
+#define STM32MP25_RIFSC_TIM15_ID		13
+#define STM32MP25_RIFSC_TIM16_ID		14
+#define STM32MP25_RIFSC_TIM17_ID		15
+#define STM32MP25_RIFSC_TIM20_ID		16
+#define STM32MP25_RIFSC_LPTIM1_ID		17
+#define STM32MP25_RIFSC_LPTIM2_ID		18
+#define STM32MP25_RIFSC_LPTIM3_ID		19
+#define STM32MP25_RIFSC_LPTIM4_ID		20
+#define STM32MP25_RIFSC_LPTIM5_ID		21
+#define STM32MP25_RIFSC_SPI1_ID			22
+#define STM32MP25_RIFSC_SPI2_ID			23
+#define STM32MP25_RIFSC_SPI3_ID			24
+#define STM32MP25_RIFSC_SPI4_ID			25
+#define STM32MP25_RIFSC_SPI5_ID			26
+#define STM32MP25_RIFSC_SPI6_ID			27
+#define STM32MP25_RIFSC_SPI7_ID			28
+#define STM32MP25_RIFSC_SPI8_ID			29
+#define STM32MP25_RIFSC_SPDIFRX_ID		30
+#define STM32MP25_RIFSC_USART1_ID		31
+#define STM32MP25_RIFSC_USART2_ID		32
+#define STM32MP25_RIFSC_USART3_ID		33
+#define STM32MP25_RIFSC_UART4_ID		34
+#define STM32MP25_RIFSC_UART5_ID		35
+#define STM32MP25_RIFSC_USART6_ID		36
+#define STM32MP25_RIFSC_UART7_ID		37
+#define STM32MP25_RIFSC_UART8_ID		38
+#define STM32MP25_RIFSC_UART9_ID		39
+#define STM32MP25_RIFSC_LPUART1_ID		40
+#define STM32MP25_RIFSC_I2C1_ID			41
+#define STM32MP25_RIFSC_I2C2_ID			42
+#define STM32MP25_RIFSC_I2C3_ID			43
+#define STM32MP25_RIFSC_I2C4_ID			44
+#define STM32MP25_RIFSC_I2C5_ID			45
+#define STM32MP25_RIFSC_I2C6_ID			46
+#define STM32MP25_RIFSC_I2C7_ID			47
+#define STM32MP25_RIFSC_I2C8_ID			48
+#define STM32MP25_RIFSC_SAI1_ID			49
+#define STM32MP25_RIFSC_SAI2_ID			50
+#define STM32MP25_RIFSC_SAI3_ID			51
+#define STM32MP25_RIFSC_SAI4_ID			52
+#define STM32MP25_RIFSC_MDF1_ID			54
+#define STM32MP25_RIFSC_ADF1_ID			55
+#define STM32MP25_RIFSC_FDCAN_ID		56
+#define STM32MP25_RIFSC_HDP_ID			57
+#define STM32MP25_RIFSC_ADC12_ID		58
+#define STM32MP25_RIFSC_ADC3_ID			59
+#define STM32MP25_RIFSC_ETH1_ID			60
+#define STM32MP25_RIFSC_ETH2_ID			61
+#define STM32MP25_RIFSC_USBH_ID			63
+#define STM32MP25_RIFSC_USB3DR_ID		66
+#define STM32MP25_RIFSC_COMBOPHY_ID		67
+#define STM32MP25_RIFSC_PCIE_ID			68
+#define STM32MP25_RIFSC_UCPD1_ID		69
+#define STM32MP25_RIFSC_ETHSW_DEIP_ID		70
+#define STM32MP25_RIFSC_ETHSW_ACM_CFG_ID	71
+#define STM32MP25_RIFSC_ETHSW_ACM_MSGBUF_ID	72
+#define STM32MP25_RIFSC_STGEN_ID		73
+#define STM32MP25_RIFSC_OCTOSPI1_ID		74
+#define STM32MP25_RIFSC_OCTOSPI2_ID		75
+#define STM32MP25_RIFSC_SDMMC1_ID		76
+#define STM32MP25_RIFSC_SDMMC2_ID		77
+#define STM32MP25_RIFSC_SDMMC3_ID		78
+#define STM32MP25_RIFSC_GPU_ID			79
+#define STM32MP25_RIFSC_LTDC_CMN_ID		80
+#define STM32MP25_RIFSC_DSI_CMN_ID		81
+#define STM32MP25_RIFSC_LVDS_ID			84
+#define STM32MP25_RIFSC_CSI_ID			86
+#define STM32MP25_RIFSC_DCMIPP_ID		87
+#define STM32MP25_RIFSC_DCMI_PSSI_ID		88
+#define STM32MP25_RIFSC_VDEC_ID			89
+#define STM32MP25_RIFSC_VENC_ID			90
+#define STM32MP25_RIFSC_RNG_ID			92
+#define STM32MP25_RIFSC_PKA_ID			93
+#define STM32MP25_RIFSC_SAES_ID			94
+#define STM32MP25_RIFSC_HASH_ID			95
+#define STM32MP25_RIFSC_CRYP1_ID		96
+#define STM32MP25_RIFSC_CRYP2_ID		97
+#define STM32MP25_RIFSC_IWDG1_ID		98
+#define STM32MP25_RIFSC_IWDG2_ID		99
+#define STM32MP25_RIFSC_IWDG3_ID		100
+#define STM32MP25_RIFSC_IWDG4_ID		101
+#define STM32MP25_RIFSC_IWDG5_ID		102
+#define STM32MP25_RIFSC_WWDG1_ID		103
+#define STM32MP25_RIFSC_WWDG2_ID		104
+#define STM32MP25_RIFSC_VREFBUF_ID		106
+#define STM32MP25_RIFSC_DTS_ID			107
+#define STM32MP25_RIFSC_RAMCFG_ID		108
+#define STM32MP25_RIFSC_CRC_ID			109
+#define STM32MP25_RIFSC_SERC_ID			110
+#define STM32MP25_RIFSC_OCTOSPIM_ID		111
+#define STM32MP25_RIFSC_GICV2M_ID		112
+#define STM32MP25_RIFSC_I3C1_ID			114
+#define STM32MP25_RIFSC_I3C2_ID			115
+#define STM32MP25_RIFSC_I3C3_ID			116
+#define STM32MP25_RIFSC_I3C4_ID			117
+#define STM32MP25_RIFSC_ICACHE_DCACHE_ID	118
+#define STM32MP25_RIFSC_LTDC_L0L1_ID		119
+#define STM32MP25_RIFSC_LTDC_L2_ID		120
+#define STM32MP25_RIFSC_LTDC_ROT_ID		121
+#define STM32MP25_RIFSC_DSI_TRIG_ID		122
+#define STM32MP25_RIFSC_DSI_RDFIFO_ID		123
+#define STM32MP25_RIFSC_OTFDEC1_ID		125
+#define STM32MP25_RIFSC_OTFDEC2_ID		126
+#define STM32MP25_RIFSC_IAC_ID			127
+
+#endif /* _DT_BINDINGS_BUS_STM32MP25_SYS_BUS_H */
diff --git a/include/dt-bindings/clock/stm32mp1-clks.h b/include/dt-bindings/clock/stm32mp1-clks.h
index 25e8cfd43..2e23e0384 100644
--- a/include/dt-bindings/clock/stm32mp1-clks.h
+++ b/include/dt-bindings/clock/stm32mp1-clks.h
@@ -179,6 +179,12 @@
 #define DAC12_K		168
 #define ETHPTP_K	169
 
+#define PCLK1		170
+#define PCLK2		171
+#define PCLK3		172
+#define PCLK4		173
+#define PCLK5		174
+
 /* PLL */
 #define PLL1		176
 #define PLL2		177
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
index 02befd25e..2a110340f 100644
--- a/include/dt-bindings/clock/stm32mp13-clks.h
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -193,7 +193,13 @@
 #define SAI1		160
 #define SAI2		161
 
-#define STM32MP1_LAST_CLK 162
+#define SPI1		162
+#define SPI2		163
+#define SPI3		164
+#define SPI4		165
+#define SPI5		166
+
+#define STM32MP1_LAST_CLK 167
 
 /* SCMI clock identifiers */
 #define CK_SCMI_HSE		0
diff --git a/include/dt-bindings/clock/stm32mp25-clks.h b/include/dt-bindings/clock/stm32mp25-clks.h
new file mode 100644
index 000000000..a8d28b325
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp25-clks.h
@@ -0,0 +1,496 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_CLKS_H_
+#define _DT_BINDINGS_STM32MP25_CLKS_H_
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL3_CK			10
+#define PLL4_CK			11
+#define PLL5_CK			12
+#define PLL6_CK			13
+#define PLL7_CK			14
+#define PLL8_CK			15
+
+#define CK_CPU1			16
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		17
+#define CK_ICN_APB2		18
+#define CK_ICN_APB3		19
+#define CK_ICN_APB4		20
+#define CK_ICN_APBDBG		21
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		22
+#define TIMG2_CK		23
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		24
+#define CK_ICN_SDMMC		25
+#define CK_ICN_DDR		26
+#define CK_ICN_DISPLAY		27
+#define CK_ICN_HSL		28
+#define CK_ICN_NIC		29
+#define CK_ICN_VID		30
+#define CK_FLEXGEN_07		31
+#define CK_FLEXGEN_08		32
+#define CK_FLEXGEN_09		33
+#define CK_FLEXGEN_10		34
+#define CK_FLEXGEN_11		35
+#define CK_FLEXGEN_12		36
+#define CK_FLEXGEN_13		37
+#define CK_FLEXGEN_14		38
+#define CK_FLEXGEN_15		39
+#define CK_FLEXGEN_16		40
+#define CK_FLEXGEN_17		41
+#define CK_FLEXGEN_18		42
+#define CK_FLEXGEN_19		43
+#define CK_FLEXGEN_20		44
+#define CK_FLEXGEN_21		45
+#define CK_FLEXGEN_22		46
+#define CK_FLEXGEN_23		47
+#define CK_FLEXGEN_24		48
+#define CK_FLEXGEN_25		49
+#define CK_FLEXGEN_26		50
+#define CK_FLEXGEN_27		51
+#define CK_FLEXGEN_28		52
+#define CK_FLEXGEN_29		53
+#define CK_FLEXGEN_30		54
+#define CK_FLEXGEN_31		55
+#define CK_FLEXGEN_32		56
+#define CK_FLEXGEN_33		57
+#define CK_FLEXGEN_34		58
+#define CK_FLEXGEN_35		59
+#define CK_FLEXGEN_36		60
+#define CK_FLEXGEN_37		61
+#define CK_FLEXGEN_38		62
+#define CK_FLEXGEN_39		63
+#define CK_FLEXGEN_40		64
+#define CK_FLEXGEN_41		65
+#define CK_FLEXGEN_42		66
+#define CK_FLEXGEN_43		67
+#define CK_FLEXGEN_44		68
+#define CK_FLEXGEN_45		69
+#define CK_FLEXGEN_46		70
+#define CK_FLEXGEN_47		71
+#define CK_FLEXGEN_48		72
+#define CK_FLEXGEN_49		73
+#define CK_FLEXGEN_50		74
+#define CK_FLEXGEN_51		75
+#define CK_FLEXGEN_52		76
+#define CK_FLEXGEN_53		77
+#define CK_FLEXGEN_54		78
+#define CK_FLEXGEN_55		79
+#define CK_FLEXGEN_56		80
+#define CK_FLEXGEN_57		81
+#define CK_FLEXGEN_58		82
+#define CK_FLEXGEN_59		83
+#define CK_FLEXGEN_60		84
+#define CK_FLEXGEN_61		85
+#define CK_FLEXGEN_62		86
+#define CK_FLEXGEN_63		87
+
+/* LOW SPEED MCU CLOCK */
+#define CK_ICN_LS_MCU		88
+
+#define CK_BUS_STM		89
+#define CK_BUS_FMC		90
+#define CK_BUS_GPU		91
+#define CK_BUS_ETH1		92
+#define CK_BUS_ETH2		93
+#define CK_BUS_PCIE		94
+#define CK_BUS_DDRPHYC		95
+#define CK_BUS_SYSCPU1		96
+#define CK_BUS_ETHSW		97
+#define CK_BUS_HPDMA1		98
+#define CK_BUS_HPDMA2		99
+#define CK_BUS_HPDMA3		100
+#define CK_BUS_ADC12		101
+#define CK_BUS_ADC3		102
+#define CK_BUS_IPCC1		103
+#define CK_BUS_CCI		104
+#define CK_BUS_CRC		105
+#define CK_BUS_MDF1		106
+#define CK_BUS_OSPIIOM		107
+#define CK_BUS_BKPSRAM		108
+#define CK_BUS_HASH		109
+#define CK_BUS_RNG		110
+#define CK_BUS_CRYP1		111
+#define CK_BUS_CRYP2		112
+#define CK_BUS_SAES		113
+#define CK_BUS_PKA		114
+#define CK_BUS_GPIOA		115
+#define CK_BUS_GPIOB		116
+#define CK_BUS_GPIOC		117
+#define CK_BUS_GPIOD		118
+#define CK_BUS_GPIOE		119
+#define CK_BUS_GPIOF		120
+#define CK_BUS_GPIOG		121
+#define CK_BUS_GPIOH		122
+#define CK_BUS_GPIOI		123
+#define CK_BUS_GPIOJ		124
+#define CK_BUS_GPIOK		125
+#define CK_BUS_LPSRAM1		126
+#define CK_BUS_LPSRAM2		127
+#define CK_BUS_LPSRAM3		128
+#define CK_BUS_GPIOZ		129
+#define CK_BUS_LPDMA		130
+#define CK_BUS_HSEM		131
+#define CK_BUS_IPCC2		132
+#define CK_BUS_RTC		133
+#define CK_BUS_SPI8		134
+#define CK_BUS_LPUART1		135
+#define CK_BUS_I2C8		136
+#define CK_BUS_LPTIM3		137
+#define CK_BUS_LPTIM4		138
+#define CK_BUS_LPTIM5		139
+#define CK_BUS_IWDG5		140
+#define CK_BUS_WWDG2		141
+#define CK_BUS_I3C4		142
+#define CK_BUS_TIM2		143
+#define CK_BUS_TIM3		144
+#define CK_BUS_TIM4		145
+#define CK_BUS_TIM5		146
+#define CK_BUS_TIM6		147
+#define CK_BUS_TIM7		148
+#define CK_BUS_TIM10		149
+#define CK_BUS_TIM11		150
+#define CK_BUS_TIM12		151
+#define CK_BUS_TIM13		152
+#define CK_BUS_TIM14		153
+#define CK_BUS_LPTIM1		154
+#define CK_BUS_LPTIM2		155
+#define CK_BUS_SPI2		156
+#define CK_BUS_SPI3		157
+#define CK_BUS_SPDIFRX		158
+#define CK_BUS_USART2		159
+#define CK_BUS_USART3		160
+#define CK_BUS_UART4		161
+#define CK_BUS_UART5		162
+#define CK_BUS_I2C1		163
+#define CK_BUS_I2C2		164
+#define CK_BUS_I2C3		165
+#define CK_BUS_I2C4		166
+#define CK_BUS_I2C5		167
+#define CK_BUS_I2C6		168
+#define CK_BUS_I2C7		169
+#define CK_BUS_I3C1		170
+#define CK_BUS_I3C2		171
+#define CK_BUS_I3C3		172
+#define CK_BUS_TIM1		173
+#define CK_BUS_TIM8		174
+#define CK_BUS_TIM15		175
+#define CK_BUS_TIM16		176
+#define CK_BUS_TIM17		177
+#define CK_BUS_TIM20		178
+#define CK_BUS_SAI1		179
+#define CK_BUS_SAI2		180
+#define CK_BUS_SAI3		181
+#define CK_BUS_SAI4		182
+#define CK_BUS_USART1		183
+#define CK_BUS_USART6		184
+#define CK_BUS_UART7		185
+#define CK_BUS_UART8		186
+#define CK_BUS_UART9		187
+#define CK_BUS_FDCAN		188
+#define CK_BUS_SPI1		189
+#define CK_BUS_SPI4		190
+#define CK_BUS_SPI5		191
+#define CK_BUS_SPI6		192
+#define CK_BUS_SPI7		193
+#define CK_BUS_BSEC		194
+#define CK_BUS_IWDG1		195
+#define CK_BUS_IWDG2		196
+#define CK_BUS_IWDG3		197
+#define CK_BUS_IWDG4		198
+#define CK_BUS_WWDG1		199
+#define CK_BUS_VREF		200
+#define CK_BUS_DTS		201
+#define CK_BUS_SERC		202
+#define CK_BUS_HDP		203
+#define CK_BUS_IS2M		204
+#define CK_BUS_DSI		205
+#define CK_BUS_LTDC		206
+#define CK_BUS_CSI		207
+#define CK_BUS_DCMIPP		208
+#define CK_BUS_DDRC		209
+#define CK_BUS_DDRCFG		210
+#define CK_BUS_GICV2M		211
+#define CK_BUS_USBTC		212
+#define CK_BUS_USB3PCIEPHY	214
+#define CK_BUS_STGEN		215
+#define CK_BUS_VDEC		216
+#define CK_BUS_VENC		217
+#define CK_SYSDBG		218
+#define CK_KER_TIM2		219
+#define CK_KER_TIM3		220
+#define CK_KER_TIM4		221
+#define CK_KER_TIM5		222
+#define CK_KER_TIM6		223
+#define CK_KER_TIM7		224
+#define CK_KER_TIM10		225
+#define CK_KER_TIM11		226
+#define CK_KER_TIM12		227
+#define CK_KER_TIM13		228
+#define CK_KER_TIM14		229
+#define CK_KER_TIM1		230
+#define CK_KER_TIM8		231
+#define CK_KER_TIM15		232
+#define CK_KER_TIM16		233
+#define CK_KER_TIM17		234
+#define CK_KER_TIM20		235
+#define CK_BUS_SYSRAM		236
+#define CK_BUS_VDERAM		237
+#define CK_BUS_RETRAM		238
+#define CK_BUS_OSPI1		239
+#define CK_BUS_OSPI2		240
+#define CK_BUS_OTFD1		241
+#define CK_BUS_OTFD2		242
+#define CK_BUS_SRAM1		243
+#define CK_BUS_SRAM2		244
+#define CK_BUS_SDMMC1		245
+#define CK_BUS_SDMMC2		246
+#define CK_BUS_SDMMC3		247
+#define CK_BUS_DDR		248
+#define CK_BUS_RISAF4		249
+#define CK_BUS_USB2OHCI		250
+#define CK_BUS_USB2EHCI		251
+#define CK_BUS_USB3DR		252
+#define CK_KER_LPTIM1		253
+#define CK_KER_LPTIM2		254
+#define CK_KER_USART2		255
+#define CK_KER_UART4		256
+#define CK_KER_USART3		257
+#define CK_KER_UART5		258
+#define CK_KER_SPI2		259
+#define CK_KER_SPI3		260
+#define CK_KER_SPDIFRX		261
+#define CK_KER_I2C1		262
+#define CK_KER_I2C2		263
+#define CK_KER_I3C1		264
+#define CK_KER_I3C2		265
+#define CK_KER_I2C3		266
+#define CK_KER_I2C5		267
+#define CK_KER_I3C3		268
+#define CK_KER_I2C4		269
+#define CK_KER_I2C6		270
+#define CK_KER_I2C7		271
+#define CK_KER_SPI1		272
+#define CK_KER_SPI4		273
+#define CK_KER_SPI5		274
+#define CK_KER_SPI6		275
+#define CK_KER_SPI7		276
+#define CK_KER_USART1		277
+#define CK_KER_USART6		278
+#define CK_KER_UART7		279
+#define CK_KER_UART8		280
+#define CK_KER_UART9		281
+#define CK_KER_MDF1		282
+#define CK_KER_SAI1		283
+#define CK_KER_SAI2		284
+#define CK_KER_SAI3		285
+#define CK_KER_SAI4		286
+#define CK_KER_FDCAN		287
+#define CK_KER_DSIBLANE		288
+#define CK_KER_DSIPHY		289
+#define CK_KER_CSI		290
+#define CK_KER_CSITXESC		291
+#define CK_KER_CSIPHY		292
+#define CK_KER_LVDSPHY		293
+#define CK_KER_STGEN		294
+#define CK_KER_USB3PCIEPHY	295
+#define CK_KER_USB2PHY2EN	296
+#define CK_KER_I3C4		297
+#define CK_KER_SPI8		298
+#define CK_KER_I2C8		299
+#define CK_KER_LPUART1		300
+#define CK_KER_LPTIM3		301
+#define CK_KER_LPTIM4		302
+#define CK_KER_LPTIM5		303
+#define CK_KER_TSDBG		304
+#define CK_KER_TPIU		305
+#define CK_BUS_ETR		306
+#define CK_BUS_SYSATB		307
+#define CK_KER_ADC12		308
+#define CK_KER_ADC3		309
+#define CK_KER_OSPI1		310
+#define CK_KER_OSPI2		311
+#define CK_KER_FMC		312
+#define CK_KER_SDMMC1		313
+#define CK_KER_SDMMC2		314
+#define CK_KER_SDMMC3		315
+#define CK_KER_ETH1		316
+#define CK_KER_ETH2		317
+#define CK_KER_ETH1PTP		318
+#define CK_KER_ETH2PTP		319
+#define CK_KER_USB2PHY1		320
+#define CK_KER_USB2PHY2		321
+#define CK_KER_ETHSW		322
+#define CK_KER_ETHSWREF		323
+#define CK_MCO1			324
+#define CK_MCO2			325
+#define CK_KER_DTS		326
+#define CK_ETH1_RX		327
+#define CK_ETH1_TX		328
+#define CK_ETH1_MAC		329
+#define CK_ETH2_RX		330
+#define CK_ETH2_TX		331
+#define CK_ETH2_MAC		332
+#define CK_ETH1_STP		333
+#define CK_ETH2_STP		334
+#define CK_KER_USBTC		335
+#define CK_BUS_ADF1		336
+#define CK_KER_ADF1		337
+#define CK_BUS_LVDS		338
+#define CK_KER_LTDC		339
+#define CK_KER_GPU		340
+#define CK_BUS_ETHSWACMCFG	341
+#define CK_BUS_ETHSWACMMSG	342
+#define HSE_DIV2_CK		343
+#define CK_KER_ETR		344
+#define CK_KER_STM		345
+
+#define STM32MP25_LAST_CLK	346
+
+#define CK_SCMI_ICN_HS_MCU	0
+#define CK_SCMI_ICN_SDMMC	1
+#define CK_SCMI_ICN_DDR		2
+#define CK_SCMI_ICN_DISPLAY	3
+#define CK_SCMI_ICN_HSL		4
+#define CK_SCMI_ICN_NIC		5
+#define CK_SCMI_ICN_VID		6
+#define CK_SCMI_FLEXGEN_07	7
+#define CK_SCMI_FLEXGEN_08	8
+#define CK_SCMI_FLEXGEN_09	9
+#define CK_SCMI_FLEXGEN_10	10
+#define CK_SCMI_FLEXGEN_11	11
+#define CK_SCMI_FLEXGEN_12	12
+#define CK_SCMI_FLEXGEN_13	13
+#define CK_SCMI_FLEXGEN_14	14
+#define CK_SCMI_FLEXGEN_15	15
+#define CK_SCMI_FLEXGEN_16	16
+#define CK_SCMI_FLEXGEN_17	17
+#define CK_SCMI_FLEXGEN_18	18
+#define CK_SCMI_FLEXGEN_19	19
+#define CK_SCMI_FLEXGEN_20	20
+#define CK_SCMI_FLEXGEN_21	21
+#define CK_SCMI_FLEXGEN_22	22
+#define CK_SCMI_FLEXGEN_23	23
+#define CK_SCMI_FLEXGEN_24	24
+#define CK_SCMI_FLEXGEN_25	25
+#define CK_SCMI_FLEXGEN_26	26
+#define CK_SCMI_FLEXGEN_27	27
+#define CK_SCMI_FLEXGEN_28	28
+#define CK_SCMI_FLEXGEN_29	29
+#define CK_SCMI_FLEXGEN_30	30
+#define CK_SCMI_FLEXGEN_31	31
+#define CK_SCMI_FLEXGEN_32	32
+#define CK_SCMI_FLEXGEN_33	33
+#define CK_SCMI_FLEXGEN_34	34
+#define CK_SCMI_FLEXGEN_35	35
+#define CK_SCMI_FLEXGEN_36	36
+#define CK_SCMI_FLEXGEN_37	37
+#define CK_SCMI_FLEXGEN_38	38
+#define CK_SCMI_FLEXGEN_39	39
+#define CK_SCMI_FLEXGEN_40	40
+#define CK_SCMI_FLEXGEN_41	41
+#define CK_SCMI_FLEXGEN_42	42
+#define CK_SCMI_FLEXGEN_43	43
+#define CK_SCMI_FLEXGEN_44	44
+#define CK_SCMI_FLEXGEN_45	45
+#define CK_SCMI_FLEXGEN_46	46
+#define CK_SCMI_FLEXGEN_47	47
+#define CK_SCMI_FLEXGEN_48	48
+#define CK_SCMI_FLEXGEN_49	49
+#define CK_SCMI_FLEXGEN_50	50
+#define CK_SCMI_FLEXGEN_51	51
+#define CK_SCMI_FLEXGEN_52	52
+#define CK_SCMI_FLEXGEN_53	53
+#define CK_SCMI_FLEXGEN_54	54
+#define CK_SCMI_FLEXGEN_55	55
+#define CK_SCMI_FLEXGEN_56	56
+#define CK_SCMI_FLEXGEN_57	57
+#define CK_SCMI_FLEXGEN_58	58
+#define CK_SCMI_FLEXGEN_59	59
+#define CK_SCMI_FLEXGEN_60	60
+#define CK_SCMI_FLEXGEN_61	61
+#define CK_SCMI_FLEXGEN_62	62
+#define CK_SCMI_FLEXGEN_63	63
+#define CK_SCMI_ICN_LS_MCU	64
+#define CK_SCMI_HSE		65
+#define CK_SCMI_LSE		66
+#define CK_SCMI_HSI		67
+#define CK_SCMI_LSI		68
+#define CK_SCMI_MSI		69
+#define CK_SCMI_HSE_DIV2	70
+#define CK_SCMI_CPU1		71
+#define CK_SCMI_SYSCPU1		72
+#define CK_SCMI_PLL2		73
+#define CK_SCMI_PLL3		74
+#define CK_SCMI_RTC		75
+#define CK_SCMI_RTCCK		76
+#define CK_SCMI_ICN_APB1	77
+#define CK_SCMI_ICN_APB2	78
+#define CK_SCMI_ICN_APB3	79
+#define CK_SCMI_ICN_APB4	80
+#define CK_SCMI_ICN_APBDBG	81
+#define CK_SCMI_TIMG1		82
+#define CK_SCMI_TIMG2		83
+#define CK_SCMI_BKPSRAM		84
+#define CK_SCMI_BSEC		85
+#define CK_SCMI_BUS_ETR		87
+#define CK_SCMI_FMC		88
+#define CK_SCMI_GPIOA		89
+#define CK_SCMI_GPIOB		90
+#define CK_SCMI_GPIOC		91
+#define CK_SCMI_GPIOD		92
+#define CK_SCMI_GPIOE		93
+#define CK_SCMI_GPIOF		94
+#define CK_SCMI_GPIOG		95
+#define CK_SCMI_GPIOH		96
+#define CK_SCMI_GPIOI		97
+#define CK_SCMI_GPIOJ		98
+#define CK_SCMI_GPIOK		99
+#define CK_SCMI_GPIOZ		100
+#define CK_SCMI_HPDMA1		101
+#define CK_SCMI_HPDMA2		102
+#define CK_SCMI_HPDMA3		103
+#define CK_SCMI_HSEM		104
+#define CK_SCMI_IPCC1		105
+#define CK_SCMI_IPCC2		106
+#define CK_SCMI_LPDMA		107
+#define CK_SCMI_RETRAM		108
+#define CK_SCMI_SRAM1		109
+#define CK_SCMI_SRAM2		110
+#define CK_SCMI_LPSRAM1		111
+#define CK_SCMI_LPSRAM2		112
+#define CK_SCMI_LPSRAM3		113
+#define CK_SCMI_VDERAM		114
+#define CK_SCMI_SYSRAM		115
+#define CK_SCMI_OSPI1		116
+#define CK_SCMI_OSPI2		117
+#define CK_SCMI_TPIU		118
+#define CK_SCMI_SYSDBG		119
+#define CK_SCMI_SYSATB		120
+#define CK_SCMI_TSDBG		121
+#define CK_SCMI_BUS_STM		122
+#define CK_SCMI_KER_STM		123
+#define CK_SCMI_KER_ETR		124
+
+#endif /* _DT_BINDINGS_STM32MP25_CLKS_H_ */
diff --git a/include/dt-bindings/pinctrl/stm32-pinfunc.h b/include/dt-bindings/pinctrl/stm32-pinfunc.h
index e6fb8ada3..af3fd3883 100644
--- a/include/dt-bindings/pinctrl/stm32-pinfunc.h
+++ b/include/dt-bindings/pinctrl/stm32-pinfunc.h
@@ -26,6 +26,7 @@
 #define AF14	0xf
 #define AF15	0x10
 #define ANALOG	0x11
+#define RSVD	0x12
 
 /* define Pins number*/
 #define PIN_NO(port, line)	(((port) - 'A') * 0x10 + (line))
@@ -37,6 +38,9 @@
 #define STM32MP_PKG_AB	0x2
 #define STM32MP_PKG_AC	0x4
 #define STM32MP_PKG_AD	0x8
+#define STM32MP_PKG_AI	0x100
+#define STM32MP_PKG_AK	0x400
+#define STM32MP_PKG_AL	0x800
 
 #endif /* _DT_BINDINGS_STM32_PINFUNC_H */
 
diff --git a/include/dt-bindings/pinctrl/stm32mp13-hdp.h b/include/dt-bindings/pinctrl/stm32mp13-hdp.h
new file mode 100644
index 000000000..4d233da8e
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp13-hdp.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clment Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_HDP_H
+#define _DT_BINDINGS_STM32MP13_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			 "0"
+#define HDP0_PWR_STOP_FORBIDDEN			 "1"
+#define HDP0_PWR_STDBY_WAKEUP			 "2"
+#define HDP0_PWR_ENCOMP_VDDCORE			 "3"
+#define HDP0_BSEC_OUT_SEC_NIDEN			 "4"
+#define HDP0_AIEC_SYS_WAKEUP			 "5"
+#define HDP0_DDRCTRL_LP_REQ			 "8"
+#define HDP0_PWR_DDR_RET_ENABLE_N		 "9"
+#define HDP0_DTS_CLK_PTAT			 "10"
+#define HDP0_SRAM3CTRL_TAMP_ERASE_ACT		 "12"
+#define HDP0_GPOVAL_0				 "15"
+
+#define HDP1_PWR_SEL_VTH_VDDCPU			 "0"
+#define HDP1_PWR_MPU_RAM_LOWSPEED		 "1"
+#define HDP1_CA7_NAXIERRIRQ			 "2"
+#define HDP1_PWR_OKIN_MR			 "3"
+#define HDP1_BSEC_OUT_SEC_DBGEN			 "4"
+#define HDP1_AIEC_C1_WAKEUP			 "5"
+#define HDP1_RCC_PWRDS_MPU			 "6"
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		 "8"
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		 "9"
+#define HDP1_SRAM3CTRL_HW_ERASE_ACT		 "12"
+#define HDP1_NIC400_S0_BREADY			 "13"
+#define HDP1_GPOVAL_1				 "15"
+
+#define HDP2_PWR_PWRWAKE_MPU			 "0"
+#define HDP2_PWR_MPU_CLOCK_DISABLE_ACK		 "1"
+#define HDP2_CA7_NDBGRESET_I			 "2"
+#define HDP2_BSEC_IN_RSTCORE_N			 "4"
+#define HDP2_BSEC_OUT_SEC_BSC_DIS		 "5"
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		 "8"
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		 "9"
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		 "10"
+#define HDP2_SRAM3CTRL_SW_ERASE_ACT		 "12"
+#define HDP2_NIC400_S0_BVALID			 "13"
+#define HDP2_GPOVAL_2				 "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCORE		 "0"
+#define HDP3_PWR_MPU_CLOCK_DISABLE_REQ		 "1"
+#define HDP3_CA7_NPMUIRQ0			 "2"
+#define HDP3_CA7_NFIQOUT0			 "3"
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		 "4"
+#define HDP3_BSEC_OUT_SEC_JTAG_DIS		 "5"
+#define HDP3_RCC_PWRDS_SYS			 "6"
+#define HDP3_SRAM3CTRL_TAMP_ERASE_REQ		 "7"
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE0 "8"
+#define HDP3_DTS_VALOBUS1_0			 "10"
+#define HDP3_DTS_VALOBUS2_0			 "11"
+#define HDP3_TAMP_POTENTIAL_TAMP_ERFCFG		 "12"
+#define HDP3_NIC400_S0_WREADY			 "13"
+#define HDP3_NIC400_S0_RREADY			 "14"
+#define HDP3_GPOVAL_3				 "15"
+
+#define HDP4_PWR_STOP2_ACTIVE			 "1"
+#define HDP4_CA7_NL2RESET_I			 "2"
+#define HDP4_CA7_NPORESET_VARM_I		 "3"
+#define HDP4_BSEC_OUT_SEC_DFTEN			 "4"
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		 "5"
+#define HDP4_ETH1_OUT_PMT_INTR_O		 "6"
+#define HDP4_ETH2_OUT_PMT_INTR_O		 "7"
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE1 "8"
+#define HDP4_DDRCTRL_CACTIVE_0			 "9"
+#define HDP4_DTS_VALOBUS1_1			 "10"
+#define HDP4_DTS_VALOBUS2_1			 "11"
+#define HDP4_TAMP_NRESET_SRAM_ERCFG		 "12"
+#define HDP4_NIC400_S0_WLAST			 "13"
+#define HDP4_NIC400_S0_RLAST			 "14"
+#define HDP4_GPOVAL_4				 "15"
+
+#define HDP5_CA7_STANDBYWFIL2			 "0"
+#define HDP5_PWR_VTH_VDDCORE_ACK		 "1"
+#define HDP5_CA7_NCORERESET_I			 "2"
+#define HDP5_CA7_NIRQOUT0			 "3"
+#define HDP5_BSEC_IN_PWROK			 "4"
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		 "5"
+#define HDP5_ETH1_OUT_LPI_INTR_O		 "6"
+#define HDP5_ETH2_OUT_LPI_INTR_O		 "7"
+#define HDP5_DDRCTRL_CACTIVE_DDRC		 "8"
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		 "9"
+#define HDP5_DTS_VALOBUS1_2			 "10"
+#define HDP5_DTS_VALOBUS2_2			 "11"
+#define HDP5_PKA_PKA_ITAMP_OUT			 "12"
+#define HDP5_NIC400_S0_WVALID			 "13"
+#define HDP5_NIC400_S0_RVALID			 "14"
+#define HDP5_GPOVAL_5				 "15"
+
+#define HDP6_CA7_STANDBYWFE0			 "0"
+#define HDP6_PWR_VTH_VDDCPU_ACK			 "1"
+#define HDP6_CA7_EVENTO				 "2"
+#define HDP6_BSEC_IN_TAMPER_DET			 "4"
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		 "5"
+#define HDP6_ETH1_OUT_MAC_SPEED_O1		 "6"
+#define HDP6_ETH2_OUT_MAC_SPEED_O1		 "7"
+#define HDP6_DDRCTRL_CSYSACK_DDRC		 "8"
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		 "9"
+#define HDP6_DTS_VALOBUS1_3			 "10"
+#define HDP6_DTS_VALOBUS2_3			 "11"
+#define HDP6_SAES_TAMPER_OUT			 "12"
+#define HDP6_NIC400_S0_AWREADY			 "13"
+#define HDP6_NIC400_S0_ARREADY			 "14"
+#define HDP6_GPOVAL_6				 "15"
+
+#define HDP7_CA7_STANDBYWFI0			 "0"
+#define HDP7_PWR_RCC_VCPU_RDY			 "1"
+#define HDP7_CA7_EVENTI				 "2"
+#define HDP7_CA7_DBGACK0			 "3"
+#define HDP7_BSEC_OUT_FUSE_OK			 "4"
+#define HDP7_BSEC_OUT_SEC_SPIDEN		 "5"
+#define HDP7_ETH1_OUT_MAC_SPEED_O0		 "6"
+#define HDP7_ETH2_OUT_MAC_SPEED_O0		 "7"
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		 "8"
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		 "9"
+#define HDP7_DTS_VALOBUS1_4			 "10"
+#define HDP7_DTS_VALOBUS2_4			 "11"
+#define HDP7_RNG_TAMPER_OUT			 "12"
+#define HDP7_NIC400_S0_AWAVALID			 "13"
+#define HDP7_NIC400_S0_ARAVALID			 "14"
+#define HDP7_GPOVAL_7				 "15"
+
+#endif /* _DT_BINDINGS_STM32MP13_HDP_H */
diff --git a/include/dt-bindings/pinctrl/stm32mp15-hdp.h b/include/dt-bindings/pinctrl/stm32mp15-hdp.h
new file mode 100644
index 000000000..b761cd66b
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp15-hdp.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clment Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP15_HDP_H
+#define _DT_BINDINGS_STM32MP15_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			 "0"
+#define HDP0_CM4_SLEEPDEEP			 "1"
+#define HDP0_PWR_STDBY_WKUP			 "2"
+#define HDP0_PWR_ENCOMP_VDDCORE			 "3"
+#define HDP0_BSEC_OUT_SEC_NIDEN			 "4"
+#define HDP0_RCC_CM4_SLEEPDEEP			 "6"
+#define HDP0_GPU_DBG7				 "7"
+#define HDP0_DDRCTRL_LP_REQ			 "8"
+#define HDP0_PWR_DDR_RET_ENABLE_N		 "9"
+#define HDP0_DTS_CLK_PTAT			 "10"
+#define HDP0_GPOVAL_0				 "15"
+
+#define HDP1_PWR_PWRWAKE_MCU			 "0"
+#define HDP1_CM4_HALTED				 "1"
+#define HDP1_CA7_NAXIERRIRQ			 "2"
+#define HDP1_PWR_OKIN_MR			 "3"
+#define HDP1_BSEC_OUT_SEC_DBGEN			 "4"
+#define HDP1_EXTI_SYS_WAKEUP			 "5"
+#define HDP1_RCC_PWRDS_MPU			 "6"
+#define HDP1_GPU_DBG6				 "7"
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		 "8"
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		 "9"
+#define HDP1_GPOVAL_1				 "15"
+
+#define HDP2_PWR_PWRWAKE_MPU			 "0"
+#define HDP2_CM4_RXEV				 "1"
+#define HDP2_CA7_NPMUIRQ1			 "2"
+#define HDP2_CA7_NFIQOUT1			 "3"
+#define HDP2_BSEC_IN_RSTCORE_N			 "4"
+#define HDP2_EXTI_C2_WAKEUP			 "5"
+#define HDP2_RCC_PWRDS_MCU			 "6"
+#define HDP2_GPU_DBG5				 "7"
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		 "8"
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		 "9"
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		 "10"
+#define HDP2_GPOVAL_2				 "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCORE		 "0"
+#define HDP3_CM4_TXEV				 "1"
+#define HDP3_CA7_NPMUIRQ0			 "2"
+#define HDP3_CA7_NFIQOUT0			 "3"
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		 "4"
+#define HDP3_EXTI_C1_WAKEUP			 "5"
+#define HDP3_RCC_PWRDS_SYS			 "6"
+#define HDP3_GPU_DBG4				 "7"
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE0 "8"
+#define HDP3_DDRCTRL_CACTIVE_1			 "9"
+#define HDP3_DTS_VALOBUS1_0			 "10"
+#define HDP3_DTS_VALOBUS2_0			 "11"
+#define HDP3_GPOVAL_3				 "15"
+
+#define HDP4_PWR_PDDS_NOT_CSTBYDIS		 "0"
+#define HDP4_CM4_SLEEPING			 "1"
+#define HDP4_CA7_NRESET1			 "2"
+#define HDP4_CA7_NIRQOUT1			 "3"
+#define HDP4_BSEC_OUT_SEC_DFTEN			 "4"
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		 "5"
+#define HDP4_ETH_OUT_PMT_INTR_O			 "6"
+#define HDP4_GPU_DBG3				 "7"
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE1 "8"
+#define HDP4_DDRCTRL_CACTIVE_0			 "9"
+#define HDP4_DTS_VALOBUS1_1			 "10"
+#define HDP4_DTS_VALOBUS2_1			 "11"
+#define HDP4_GPOVAL_4				 "15"
+
+#define HDP5_CA7_STANDBYWFIL2			 "0"
+#define HDP5_PWR_VTH_VDDCORE_ACK		 "1"
+#define HDP5_CA7_NRESET0			 "2"
+#define HDP5_CA7_NIRQOUT0			 "3"
+#define HDP5_BSEC_IN_PWROK			 "4"
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		 "5"
+#define HDP5_ETH_OUT_LPI_INTR_O			 "6"
+#define HDP5_GPU_DBG2				 "7"
+#define HDP5_DDRCTRL_CACTIVE_DDRC		 "8"
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		 "9"
+#define HDP5_DTS_VALOBUS1_2			 "10"
+#define HDP5_DTS_VALOBUS2_2			 "11"
+#define HDP5_GPOVAL_5				 "15"
+
+#define HDP6_CA7_STANDBYWFI1			 "0"
+#define HDP6_CA7_STANDBYWFE1			 "1"
+#define HDP6_CA7_EVENTO				 "2"
+#define HDP6_CA7_DBGACK1			 "3"
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		 "5"
+#define HDP6_ETH_OUT_MAC_SPEED_O1		 "6"
+#define HDP6_GPU_DBG1				 "7"
+#define HDP6_DDRCTRL_CSYSACK_DDRC		 "8"
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		 "9"
+#define HDP6_DTS_VALOBUS1_3			 "10"
+#define HDP6_DTS_VALOBUS2_3			 "11"
+#define HDP6_GPOVAL_6				 "15"
+
+#define HDP7_CA7_STANDBYWFI0			 "0"
+#define HDP7_CA7_STANDBYWFE0			 "1"
+#define HDP7_CA7_DBGACK0			 "3"
+#define HDP7_BSEC_OUT_FUSE_OK			 "4"
+#define HDP7_BSEC_OUT_SEC_SPIDEN		 "5"
+#define HDP7_ETH_OUT_MAC_SPEED_O0		 "6"
+#define HDP7_GPU_DBG0				 "7"
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		 "8"
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		 "9"
+#define HDP7_DTS_VALOBUS1_4			 "10"
+#define HDP7_DTS_VALOBUS2_4			 "11"
+#define HDP7_GPOVAL_7				 "15"
+
+#endif /* _DT_BINDINGS_STM32MP15_HDP_H */
diff --git a/include/dt-bindings/pinctrl/stm32mp25-hdp.h b/include/dt-bindings/pinctrl/stm32mp25-hdp.h
new file mode 100644
index 000000000..3f1bbb6bc
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp25-hdp.h
@@ -0,0 +1,144 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clment Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_HDP_H
+#define _DT_BINDINGS_STM32MP25_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			     "0"
+#define HDP0_CPU2_SLEEP_DEEP			     "1"
+#define HDP0_BSEC_OUT_TST_SDR_UNLOCK_OR_DISABLE_SCAN "2"
+#define HDP0_BSEC_OUT_NIDENM			     "3"
+#define HDP0_BSEC_OUT_NIDENA			     "4"
+#define HDP0_CPU2_STATE_0			     "5"
+#define HDP0_RCC_PWRDS_SYS			     "6"
+#define HDP0_GPU_DBG7				     "7"
+#define HDP0_DDRSS_CSYSREQ_DDRC			     "8"
+#define HDP0_DDRSS_DFI_PHYUPD_REQ		     "9"
+#define HDP0_CPU3_SLEEP_DEEP			     "10"
+#define HDP0_D2_GBL_PER_CLK_BUS_REQ		     "11"
+#define HDP0_PCIE_USB_CXPL_DEBUG_INFO_EI_0	     "12"
+#define HDP0_PCIE_USB_CXPL_DEBUG_INFO_EI_8	     "13"
+#define HDP0_D3_STATE_0				     "14"
+#define HDP0_GPOVAL_0				     "15"
+
+#define HDP1_PWR_PWRWAKE_CPU2			     "0"
+#define HDP1_CPU2_HALTED			     "1"
+#define HDP1_CPU2_STATE_1			     "2"
+#define HDP1_BSEC_OUT_DBGENM			     "3"
+#define HDP1_BSEC_OUT_DBGENA			     "4"
+#define HDP1_EXTI1_SYS_WAKEUP			     "5"
+#define HDP1_RCC_PWRDS_CPU2			     "6"
+#define HDP1_GPU_DBG6				     "7"
+#define HDP1_DDRSS_CSYSACK_DDRC			     "8"
+#define HDP1_DDRSS_DFI_PHYMSTR_REQ		     "9"
+#define HDP1_CPU3_HALTED			     "10"
+#define HDP1_D2_GBL_PER_DMA_REQ			     "11"
+#define HDP1_PCIE_USB_CXPL_DEBUG_INFO_EI_1	     "12"
+#define HDP1_PCIE_USB_CXPL_DEBUG_INFO_EI_9	     "13"
+#define HDP1_D3_STATE_1				     "14"
+#define HDP1_GPOVAL_1				     "15"
+
+#define HDP2_PWR_PWRWAKE_CPU1			     "0"
+#define HDP2_CPU2_RXEV				     "1"
+#define HDP2_CPU1_NPMUIRQ1			     "2"
+#define HDP2_CPU1_NFIQOUT1			     "3"
+#define HDP2_BSEC_OUT_SHDBGEN			     "4"
+#define HDP2_EXTI1_CPU2_WAKEUP			     "5"
+#define HDP2_RCC_PWRDS_CPU1			     "6"
+#define HDP2_GPU_DBG5				     "7"
+#define HDP2_DDRSS_CACTIVE_DDRC			     "8"
+#define HDP2_DDRSS_DFI_LP_REQ			     "9"
+#define HDP2_CPU3_RXEV				     "10"
+#define HDP2_HPDMA1_CLK_BUS_REQ			     "11"
+#define HDP2_PCIE_USB_CXPL_DEBUG_INFO_EI_2	     "12"
+#define HDP2_PCIE_USB_CXPL_DEBUG_INFO_EI_10	     "13"
+#define HDP2_D3_STATE_2				     "14"
+#define HDP2_GPOVAL_2				     "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCPU			     "0"
+#define HDP3_CPU2_TXEV				     "1"
+#define HDP3_CPU1_NPMUIRQ0			     "2"
+#define HDP3_CPU1_NFIQOUT0			     "3"
+#define HDP3_BSEC_OUT_DDBGEN			     "4"
+#define HDP3_EXTI1_CPU1_WAKEUP			     "5"
+#define HDP3_CPU3_STATE_0			     "6"
+#define HDP3_GPU_DBG4				     "7"
+#define HDP3_DDRSS_MCDCG_EN			     "8"
+#define HDP3_DDRSS_DFI_FREQ_0			     "9"
+#define HDP3_CPU3_TXEV				     "10"
+#define HDP3_HPDMA2_CLK_BUS_REQ			     "11"
+#define HDP3_PCIE_USB_CXPL_DEBUG_INFO_EI_3	     "12"
+#define HDP3_PCIE_USB_CXPL_DEBUG_INFO_EI_11	     "13"
+#define HDP3_D1_STATE_0				     "14"
+#define HDP3_GPOVAL_3				     "15"
+
+#define HDP4_PWR_SEL_VTH_VDDCORE		     "0"
+#define HDP4_CPU2_SLEEPING			     "1"
+#define HDP4_CPU1_EVENTO			     "2"
+#define HDP4_CPU1_NIRQOUT1			     "3"
+#define HDP4_BSEC_OUT_SPNIDENA			     "4"
+#define HDP4_EXTI2_D3_WAKEUP			     "5"
+#define HDP4_ETH1_OUT_PMT_INTR_O		     "6"
+#define HDP4_GPU_DBG3				     "7"
+#define HDP4_DDRSS_DPHYCG_EN			     "8"
+#define HDP4_DDRSS_OBSP0			     "9"
+#define HDP4_CPU3_SLEEPING			     "10"
+#define HDP4_HPDMA3_CLK_BUS_REQ			     "11"
+#define HDP4_PCIE_USB_CXPL_DEBUG_INFO_EI_4	     "12"
+#define HDP4_PCIE_USB_CXPL_DEBUG_INFO_EI_12	     "13"
+#define HDP4_D1_STATE_1				     "14"
+#define HDP4_GPOVAL_4				     "15"
+
+#define HDP5_CPU1_STANDBY_WFIL2			     "0"
+#define HDP5_CPU1_NIRQOUT0			     "3"
+#define HDP5_BSEC_OUT_SPIDENA			     "4"
+#define HDP5_EXTI2_CPU3_WAKEUP			     "5"
+#define HDP5_ETH1_OUT_LPI_INTR_O		     "6"
+#define HDP5_GPU_DBG2				     "7"
+#define HDP5_DDRCTRL_DFI_INIT_START		     "8"
+#define HDP5_DDRSS_OBSP1			     "9"
+#define HDP5_CPU3_STATE_1			     "10"
+#define HDP5_D3_GBL_PER_CLK_BUS_REQ		     "11"
+#define HDP5_PCIE_USB_CXPL_DEBUG_INFO_EI_5	     "12"
+#define HDP5_PCIE_USB_CXPL_DEBUG_INFO_EI_13	     "13"
+#define HDP5_D1_STATE_2				     "14"
+#define HDP5_GPOVAL_5				     "15"
+
+#define HDP6_CPU1_STANDBY_WFI1			     "0"
+#define HDP6_CPU1_STANDBY_WFE1			     "1"
+#define HDP6_CPU1_HALTED1			     "2"
+#define HDP6_CPU1_NAXIERRIRQ			     "3"
+#define HDP6_BSEC_OUT_SPNIDENM			     "4"
+#define HDP6_EXTI2_CPU2_WAKEUP			     "5"
+#define HDP6_ETH2_OUT_PMT_INTR_O		     "6"
+#define HDP6_GPU_DBG1				     "7"
+#define HDP6_DDRSS_DFI_INIT_COMPLETE		     "8"
+#define HDP6_DDRSS_OBSP2			     "9"
+#define HDP6_D2_STATE_0				     "10"
+#define HDP6_D3_GBL_PER_DMA_REQ			     "11"
+#define HDP6_PCIE_USB_CXPL_DEBUG_INFO_EI_6	     "12"
+#define HDP6_PCIE_USB_CXPL_DEBUG_INFO_EI_14	     "13"
+#define HDP6_CPU1_STATE_0			     "14"
+#define HDP6_GPOVAL_6				     "15"
+
+#define HDP7_CPU1_STANDBY_WFI0			     "0"
+#define HDP7_CPU1_STANDBY_WFE0			     "1"
+#define HDP7_CPU1_HALTED0			     "2"
+#define HDP7_BSEC_OUT_SPIDENM			     "4"
+#define HDP7_EXTI2_CPU1__WAKEUP			     "5"
+#define HDP7_ETH2_OUT_LPI_INTR_O		     "6"
+#define HDP7_GPU_DBG0				     "7"
+#define HDP7_DDRSS_DFI_CTRLUPD_REQ		     "8"
+#define HDP7_DDRSS_OBSP3			     "9"
+#define HDP7_D2_STATE_1				     "10"
+#define HDP7_LPDMA1_CLK_BUS_REQ			     "11"
+#define HDP7_PCIE_USB_CXPL_DEBUG_INFO_EI_7	     "12"
+#define HDP7_PCIE_USB_CXPL_DEBUG_INFO_EI_15	     "13"
+#define HDP7_CPU1_STATE_1			     "14"
+#define HDP7_GPOVAL_7				     "15"
+
+#endif /* _DT_BINDINGS_STM32MP25_HDP_H */
diff --git a/include/dt-bindings/power/stm32mp25-power-domains.h b/include/dt-bindings/power/stm32mp25-power-domains.h
new file mode 100644
index 000000000..fe5d9f40c
--- /dev/null
+++ b/include/dt-bindings/power/stm32mp25-power-domains.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_
+#define _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_
+
+#define PD_SCMI_GPU             0
+
+#endif /* _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_ */
diff --git a/include/dt-bindings/regulator/st,stm32mp13-regulator.h b/include/dt-bindings/regulator/st,stm32mp13-regulator.h
new file mode 100644
index 000000000..b3a974dfc
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp13-regulator.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_REG11		0
+#define VOLTD_SCMI_REG18		1
+#define VOLTD_SCMI_USB33		2
+#define VOLTD_SCMI_SDMMC1_IO		3
+#define VOLTD_SCMI_SDMMC2_IO		4
+#define VOLTD_SCMI_VREFBUF		5
+
+/* STPMIC1 regulators */
+#define VOLTD_SCMI_STPMIC1_BUCK1	6
+#define VOLTD_SCMI_STPMIC1_BUCK2	7
+#define VOLTD_SCMI_STPMIC1_BUCK3	8
+#define VOLTD_SCMI_STPMIC1_BUCK4	9
+#define VOLTD_SCMI_STPMIC1_LDO1	        10
+#define VOLTD_SCMI_STPMIC1_LDO2	        11
+#define VOLTD_SCMI_STPMIC1_LDO3	        12
+#define VOLTD_SCMI_STPMIC1_LDO4	        13
+#define VOLTD_SCMI_STPMIC1_LDO5	        14
+#define VOLTD_SCMI_STPMIC1_LDO6	        15
+#define VOLTD_SCMI_STPMIC1_VREFDDR	16
+#define VOLTD_SCMI_STPMIC1_BOOST	17
+#define VOLTD_SCMI_STPMIC1_PWR_SW1	18
+#define VOLTD_SCMI_STPMIC1_PWR_SW2	19
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		20
+#define VOLTD_SCMI_REGU1		21
+#define VOLTD_SCMI_REGU2		22
+#define VOLTD_SCMI_REGU3		23
+#define VOLTD_SCMI_REGU4		24
+
+#endif /*__DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H */
diff --git a/include/dt-bindings/regulator/st,stm32mp25-regulator.h b/include/dt-bindings/regulator/st,stm32mp25-regulator.h
new file mode 100644
index 000000000..10a893892
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp25-regulator.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_VDDIO1		0
+#define VOLTD_SCMI_VDDIO2		1
+#define VOLTD_SCMI_VDDIO3		2
+#define VOLTD_SCMI_VDDIO4		3
+#define VOLTD_SCMI_VDDIO		4
+#define VOLTD_SCMI_UCPD			5
+#define VOLTD_SCMI_USB33		6
+#define VOLTD_SCMI_ADC			7
+#define VOLTD_SCMI_GPU			8
+#define VOLTD_SCMI_VREFBUF		9
+
+/* STPMIC2 regulators */
+#define VOLTD_SCMI_STPMIC2_BUCK1	10
+#define VOLTD_SCMI_STPMIC2_BUCK2	11
+#define VOLTD_SCMI_STPMIC2_BUCK3	12
+#define VOLTD_SCMI_STPMIC2_BUCK4	13
+#define VOLTD_SCMI_STPMIC2_BUCK5	14
+#define VOLTD_SCMI_STPMIC2_BUCK6	15
+#define VOLTD_SCMI_STPMIC2_BUCK7	16
+#define VOLTD_SCMI_STPMIC2_LDO1		17
+#define VOLTD_SCMI_STPMIC2_LDO2		18
+#define VOLTD_SCMI_STPMIC2_LDO3		19
+#define VOLTD_SCMI_STPMIC2_LDO4		20
+#define VOLTD_SCMI_STPMIC2_LDO5		21
+#define VOLTD_SCMI_STPMIC2_LDO6		22
+#define VOLTD_SCMI_STPMIC2_LDO7		23
+#define VOLTD_SCMI_STPMIC2_LDO8		24
+#define VOLTD_SCMI_STPMIC2_REFDDR	25
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		26
+#define VOLTD_SCMI_REGU1		27
+#define VOLTD_SCMI_REGU2		28
+#define VOLTD_SCMI_REGU3		29
+#define VOLTD_SCMI_REGU4		30
+
+#endif /*__DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H */
diff --git a/include/dt-bindings/reset/stm32mp25-resets.h b/include/dt-bindings/reset/stm32mp25-resets.h
new file mode 100644
index 000000000..9e4d44df5
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp25-resets.h
@@ -0,0 +1,166 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RESET_H_
+#define _DT_BINDINGS_STM32MP25_RESET_H_
+
+#define SYS_R		8192
+#define C1_R		8224
+#define C1P1POR_R	8256
+#define C1P1_R		8257
+#define C2_R		8288
+#define C2_HOLDBOOT_R	8608
+#define C1_HOLDBOOT_R	8609
+#define VSW_R		8735
+#define C1MS_R		8840
+#define IWDG2_KER_R	9106
+#define IWDG4_KER_R	9234
+#define C3_R		9344
+#define DDRCP_R		9888
+#define DDRCAPB_R	9920
+#define DDRPHYCAPB_R	9952
+#define DDRCFG_R	10016
+#define DDR_R		10048
+#define OSPI1_R		10400
+#define OSPI1DLL_R	10416
+#define OSPI2_R		10432
+#define OSPI2DLL_R	10448
+#define FMC_R		10464
+#define DBG_R		10508
+#define GPIOA_R		10592
+#define GPIOB_R		10624
+#define GPIOC_R		10656
+#define GPIOD_R		10688
+#define GPIOE_R		10720
+#define GPIOF_R		10752
+#define GPIOG_R		10784
+#define GPIOH_R		10816
+#define GPIOI_R		10848
+#define GPIOJ_R		10880
+#define GPIOK_R		10912
+#define GPIOZ_R		10944
+#define HPDMA1_R	10976
+#define HPDMA2_R	11008
+#define HPDMA3_R	11040
+#define LPDMA_R		11072
+#define HSEM_R		11104
+#define IPCC1_R		11136
+#define IPCC2_R		11168
+#define IS2M_R		11360
+#define SSMOD_R		11392
+#define TIM1_R		14336
+#define TIM2_R		14368
+#define TIM3_R		14400
+#define TIM4_R		14432
+#define TIM5_R		14464
+#define TIM6_R		14496
+#define TIM7_R		14528
+#define TIM8_R		14560
+#define TIM10_R		14592
+#define TIM11_R		14624
+#define TIM12_R		14656
+#define TIM13_R		14688
+#define TIM14_R		14720
+#define TIM15_R		14752
+#define TIM16_R		14784
+#define TIM17_R		14816
+#define TIM20_R		14848
+#define LPTIM1_R	14880
+#define LPTIM2_R	14912
+#define LPTIM3_R	14944
+#define LPTIM4_R	14976
+#define LPTIM5_R	15008
+#define SPI1_R		15040
+#define SPI2_R		15072
+#define SPI3_R		15104
+#define SPI4_R		15136
+#define SPI5_R		15168
+#define SPI6_R		15200
+#define SPI7_R		15232
+#define SPI8_R		15264
+#define SPDIFRX_R	15296
+#define USART1_R	15328
+#define USART2_R	15360
+#define USART3_R	15392
+#define UART4_R		15424
+#define UART5_R		15456
+#define USART6_R	15488
+#define UART7_R		15520
+#define UART8_R		15552
+#define UART9_R		15584
+#define LPUART1_R	15616
+#define I2C1_R		15648
+#define I2C2_R		15680
+#define I2C3_R		15712
+#define I2C4_R		15744
+#define I2C5_R		15776
+#define I2C6_R		15808
+#define I2C7_R		15840
+#define I2C8_R		15872
+#define SAI1_R		15904
+#define SAI2_R		15936
+#define SAI3_R		15968
+#define SAI4_R		16000
+#define MDF1_R		16064
+#define MDF2_R		16096
+#define FDCAN_R		16128
+#define HDP_R		16160
+#define ADC12_R		16192
+#define ADC3_R		16224
+#define ETH1_R		16256
+#define ETH2_R		16288
+#define USB2_R		16352
+#define USB2PHY1_R	16384
+#define USB2PHY2_R	16416
+#define USB3DR_R	16448
+#define USB3PCIEPHY_R	16480
+#define PCIE_R		16512
+#define USBTC_R		16544
+#define ETHSW_R		16576
+#define SDMMC1_R	16768
+#define SDMMC1DLL_R	16784
+#define SDMMC2_R	16800
+#define SDMMC2DLL_R	16816
+#define SDMMC3_R	16832
+#define SDMMC3DLL_R	16848
+#define GPU_R		16864
+#define LTDC_R		16896
+#define DSI_R		16928
+#define LVDS_R		17024
+#define CSI_R		17088
+#define DCMIPP_R	17120
+#define CCI_R		17152
+#define VDEC_R		17184
+#define VENC_R		17216
+#define RNG_R		17280
+#define PKA_R		17312
+#define SAES_R		17344
+#define HASH_R		17376
+#define CRYP1_R		17408
+#define CRYP2_R		17440
+#define WWDG1_R		17632
+#define WWDG2_R		17664
+#define VREF_R		17728
+#define DTS_R		17760
+#define CRC_R		17824
+#define SERC_R		17856
+#define OSPIIOM_R	17888
+#define I3C1_R		17984
+#define I3C2_R		18016
+#define I3C3_R		18048
+#define I3C4_R		18080
+
+#define RST_SCMI_C1_R		0
+#define RST_SCMI_C2_R		1
+#define RST_SCMI_C1_HOLDBOOT_R	2
+#define RST_SCMI_C2_HOLDBOOT_R	3
+#define RST_SCMI_FMC		4
+#define RST_SCMI_OSPI1		5
+#define RST_SCMI_OSPI1DLL	6
+#define RST_SCMI_OSPI2		7
+#define RST_SCMI_OSPI2DLL	8
+
+#endif /* _DT_BINDINGS_STM32MP25_RESET_H_ */
diff --git a/include/dt-bindings/rtc/rtc-stm32.h b/include/dt-bindings/rtc/rtc-stm32.h
new file mode 100644
index 000000000..2fd78c2e6
--- /dev/null
+++ b/include/dt-bindings/rtc/rtc-stm32.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for STM32_RTC bindings.
+ */
+
+#ifndef _DT_BINDINGS_RTC_RTC_STM32_H
+#define _DT_BINDINGS_RTC_RTC_STM32_H
+
+#define RTC_NO_OUT	0
+#define RTC_OUT1	1
+#define RTC_OUT2	2
+#define RTC_OUT2_RMP	3
+
+#endif
diff --git a/include/dt-bindings/spi/spi-stm32.h b/include/dt-bindings/spi/spi-stm32.h
new file mode 100644
index 000000000..7c818a399
--- /dev/null
+++ b/include/dt-bindings/spi/spi-stm32.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * This header provides constants for STM32_SPI bindings.
+ */
+
+#ifndef _DT_BINDINGS_SPI_SPI_STM32_H
+#define _DT_BINDINGS_SPI_SPI_STM32_H
+
+/* st,spi-slave-underrun first parameter */
+#define SPI_NO_ACTION			        0
+#define SPI_SEND_PATTERN		        1
+#define SPI_REPEAT_LAST_RECEIVED_DATA	        2
+#define SPI_REPEAT_LAST_TRANSMITTED_DATA        3
+
+#endif
diff --git a/include/linux/clk-regmap.h b/include/linux/clk-regmap.h
new file mode 100644
index 000000000..0666c747f
--- /dev/null
+++ b/include/linux/clk-regmap.h
@@ -0,0 +1,117 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2018 BayLibre, SAS.
+ * Author: Jerome Brunet <jbrunet@baylibre.com>
+ */
+
+#ifndef __CLK_REGMAP_H
+#define __CLK_REGMAP_H
+
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+
+/**
+ * struct clk_regmap - regmap backed clock
+ *
+ * @hw:		handle between common and hardware-specific interfaces
+ * @map:	pointer to the regmap structure controlling the clock
+ * @data:	data specific to the clock type
+ *
+ * Clock which is controlled by regmap backed registers. The actual type
+ * of the clock is controlled by the clock_ops and data.
+ */
+struct clk_regmap {
+	struct clk_hw	hw;
+	struct regmap	*map;
+	void		*data;
+};
+
+static inline struct clk_regmap *to_clk_regmap(struct clk_hw *hw)
+{
+	return container_of(hw, struct clk_regmap, hw);
+}
+
+/**
+ * struct clk_regmap_gate_data - regmap backed gate specific data
+ *
+ * @offset:	offset of the register controlling gate
+ * @bit_idx:	single bit controlling gate
+ * @flags:	hardware-specific flags
+ *
+ * Flags:
+ * Same as clk_gate except CLK_GATE_HIWORD_MASK which is ignored
+ */
+struct clk_regmap_gate_data {
+	unsigned int	offset;
+	u8		bit_idx;
+	u8		flags;
+};
+
+static inline struct clk_regmap_gate_data *
+clk_get_regmap_gate_data(struct clk_regmap *clk)
+{
+	return (struct clk_regmap_gate_data *)clk->data;
+}
+
+extern const struct clk_ops clk_regmap_gate_ops;
+extern const struct clk_ops clk_regmap_gate_ro_ops;
+
+/**
+ * struct clk_regmap_div_data - regmap backed adjustable divider specific data
+ *
+ * @offset:	offset of the register controlling the divider
+ * @shift:	shift to the divider bit field
+ * @width:	width of the divider bit field
+ * @table:	array of value/divider pairs, last entry should have div = 0
+ *
+ * Flags:
+ * Same as clk_divider except CLK_DIVIDER_HIWORD_MASK which is ignored
+ */
+struct clk_regmap_div_data {
+	unsigned int	offset;
+	u8		shift;
+	u8		width;
+	u8		flags;
+	const struct clk_div_table	*table;
+};
+
+static inline struct clk_regmap_div_data *
+clk_get_regmap_div_data(struct clk_regmap *clk)
+{
+	return (struct clk_regmap_div_data *)clk->data;
+}
+
+extern const struct clk_ops clk_regmap_divider_ops;
+extern const struct clk_ops clk_regmap_divider_ro_ops;
+
+/**
+ * struct clk_regmap_mux_data - regmap backed multiplexer clock specific data
+ *
+ * @hw:		handle between common and hardware-specific interfaces
+ * @offset:	offset of theregister controlling multiplexer
+ * @table:	array of parent indexed register values
+ * @shift:	shift to multiplexer bit field
+ * @mask:	mask of mutliplexer bit field
+ * @flags:	hardware-specific flags
+ *
+ * Flags:
+ * Same as clk_divider except CLK_MUX_HIWORD_MASK which is ignored
+ */
+struct clk_regmap_mux_data {
+	unsigned int	offset;
+	u32		*table;
+	u32		mask;
+	u8		shift;
+	u8		flags;
+};
+
+static inline struct clk_regmap_mux_data *
+clk_get_regmap_mux_data(struct clk_regmap *clk)
+{
+	return (struct clk_regmap_mux_data *)clk->data;
+}
+
+extern const struct clk_ops clk_regmap_mux_ops;
+extern const struct clk_ops clk_regmap_mux_ro_ops;
+
+#endif /* __CLK_REGMAP_H */
diff --git a/include/linux/counter.h b/include/linux/counter.h
index b63746637..9e378c98b 100644
--- a/include/linux/counter.h
+++ b/include/linux/counter.h
@@ -602,6 +602,9 @@ struct counter_array {
 #define COUNTER_COMP_FLOOR(_read, _write) \
 	COUNTER_COMP_COUNT_U64("floor", _read, _write)
 
+#define COUNTER_COMP_FREQUENCY(_read) \
+	COUNTER_COMP_SIGNAL_U64("frequency", _read, NULL)
+
 #define COUNTER_COMP_POLARITY(_read, _write, _available) \
 { \
 	.type = COUNTER_COMP_SIGNAL_POLARITY, \
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index 3576c6e89..2cdbeb9f8 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -1576,7 +1576,8 @@ int dma_async_device_register(struct dma_device *device);
 int dmaenginem_async_device_register(struct dma_device *device);
 void dma_async_device_unregister(struct dma_device *device);
 int dma_async_device_channel_register(struct dma_device *device,
-				      struct dma_chan *chan);
+				      struct dma_chan *chan,
+				      const char *name);
 void dma_async_device_channel_unregister(struct dma_device *device,
 					 struct dma_chan *chan);
 void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
diff --git a/include/linux/iio/adc/stm32-mdf-adc.h b/include/linux/iio/adc/stm32-mdf-adc.h
new file mode 100644
index 000000000..b4b4d078a
--- /dev/null
+++ b/include/linux/iio/adc/stm32-mdf-adc.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * This file discribe the STM32 MDF IIO driver API for audio part
+ *
+ * Copyright (C) 2023, STMicroelectronics.
+ * Author(s): Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#ifndef STM32_MDF_ADC_H
+#define STM32_MDF_ADC_H
+
+#include <linux/iio/iio.h>
+
+int stm32_mdf_get_buff_cb(struct iio_dev *iio_dev,
+			  int (*cb)(const void *data, size_t size, void *private), void *private);
+int stm32_mdf_release_buff_cb(struct iio_dev *iio_dev);
+
+#endif
diff --git a/include/linux/iio/timer/stm32-lptim-trigger.h b/include/linux/iio/timer/stm32-lptim-trigger.h
index a34dcf6a6..ce3cf0add 100644
--- a/include/linux/iio/timer/stm32-lptim-trigger.h
+++ b/include/linux/iio/timer/stm32-lptim-trigger.h
@@ -14,6 +14,15 @@
 #define LPTIM1_OUT	"lptim1_out"
 #define LPTIM2_OUT	"lptim2_out"
 #define LPTIM3_OUT	"lptim3_out"
+#define LPTIM4_OUT	"lptim4_out"
+#define LPTIM5_OUT	"lptim5_out"
+
+#define LPTIM1_CH1	"lptim1_ch1"
+#define LPTIM1_CH2	"lptim1_ch2"
+#define LPTIM2_CH1	"lptim2_ch1"
+#define LPTIM2_CH2	"lptim2_ch2"
+#define LPTIM3_CH1	"lptim3_ch1"
+#define LPTIM4_CH1	"lptim4_ch1"
 
 #if IS_REACHABLE(CONFIG_IIO_STM32_LPTIMER_TRIGGER)
 bool is_stm32_lptim_trigger(struct iio_trigger *trig);
diff --git a/include/linux/iio/timer/stm32-timer-trigger.h b/include/linux/iio/timer/stm32-timer-trigger.h
index 37572e4dc..1ee237b56 100644
--- a/include/linux/iio/timer/stm32-timer-trigger.h
+++ b/include/linux/iio/timer/stm32-timer-trigger.h
@@ -72,6 +72,12 @@
 
 #define TIM17_OC1	"tim17_oc1"
 
+#define TIM20_OC1	"tim20_oc1"
+#define TIM20_OC2	"tim20_oc2"
+#define TIM20_OC3	"tim20_oc3"
+#define TIM20_TRGO	"tim20_trgo"
+#define TIM20_TRGO2	"tim20_trgo2"
+
 #if IS_REACHABLE(CONFIG_IIO_STM32_TIMER_TRIGGER)
 bool is_stm32_timer_trigger(struct iio_trigger *trig);
 #else
diff --git a/include/linux/mfd/stm32-lptimer.h b/include/linux/mfd/stm32-lptimer.h
index 06d3f11dc..a73dff0cb 100644
--- a/include/linux/mfd/stm32-lptimer.h
+++ b/include/linux/mfd/stm32-lptimer.h
@@ -17,18 +17,26 @@
 #define STM32_LPTIM_IER		0x08	/* Interrupt Enable Reg      */
 #define STM32_LPTIM_CFGR	0x0C	/* Configuration Reg         */
 #define STM32_LPTIM_CR		0x10	/* Control Reg               */
-#define STM32_LPTIM_CMP		0x14	/* Compare Reg               */
+#define STM32_LPTIM_CMP		0x14	/* Compare Reg (CCR1 on mp25)*/
 #define STM32_LPTIM_ARR		0x18	/* Autoreload Reg            */
 #define STM32_LPTIM_CNT		0x1C	/* Counter Reg               */
+#define STM32MP25_LPTIM_CCMR1	0x2C	/* Capture/Compare Mode Reg  */
+#define STM32MP25_LPTIM_CCR2	0x34	/* Compare Reg2              */
+
+#define STM32MP25_LPTIM_HWCFGR2	0x3EC	/* Hardware configuration register 2 */
+#define STM32MP15_LPTIM_HWCFGR	0x3F0	/* Hardware configuration register 1 */
+#define STM32MP15_LPTIM_VERR	0x3F4	/* Version identification register   */
 
 /* STM32_LPTIM_ISR - bit fields */
+#define STM32_LPTIM_CMP2_ARROK		(BIT(19) | BIT(4))
 #define STM32_LPTIM_CMPOK_ARROK		GENMASK(4, 3)
 #define STM32_LPTIM_ARROK		BIT(4)
 #define STM32_LPTIM_CMPOK		BIT(3)
 
 /* STM32_LPTIM_ICR - bit fields */
-#define STM32_LPTIM_ARRMCF		BIT(1)
+#define STM32_LPTIM_CMP2OKCF_ARROKCF	(BIT(19) | BIT(4))
 #define STM32_LPTIM_CMPOKCF_ARROKCF	GENMASK(4, 3)
+#define STM32_LPTIM_ARRMCF		BIT(1)
 
 /* STM32_LPTIM_IER - bit flieds */
 #define STM32_LPTIM_ARRMIE	BIT(1)
@@ -53,16 +61,36 @@
 /* STM32_LPTIM_ARR */
 #define STM32_LPTIM_MAX_ARR	0xFFFF
 
+/* STM32MP25_LPTIM_CCMR1 */
+#define STM32MP25_LPTIM_CC2P	GENMASK(19, 18)
+#define STM32MP25_LPTIM_CC2E	BIT(17)
+#define STM32MP25_LPTIM_CC2SEL	BIT(16)
+#define STM32MP25_LPTIM_CC1P	GENMASK(3, 2)
+#define STM32MP25_LPTIM_CC1E	BIT(1)
+#define STM32MP25_LPTIM_CC1SEL	BIT(0)
+
+/* STM32MP15_LPTIM_HWCFGR */
+#define STM32MP15_LPTIM_HWCFGR_ENCODER	BIT(16)
+
+/* STM32MP25_LPTIM_HWCFGR2 */
+#define STM32MP25_LPTIM_HWCFGR2_CHAN_NUM	GENMASK(3, 0)
+
+/* STM32MP15_LPTIM_VERR */
+#define STM32MP15_MINREV_MASK		GENMASK(3, 0)
+#define STM32MP15_MAJREV_MASK		GENMASK(7, 4)
+
 /**
  * struct stm32_lptimer - STM32 Low-Power Timer data assigned by parent device
  * @clk: clock reference for this instance
  * @regmap: register map reference for this instance
  * @has_encoder: indicates this Low-Power Timer supports encoder mode
+ * @num_cc_chans: indicates the number of capture/compare channels
  */
 struct stm32_lptimer {
 	struct clk *clk;
 	struct regmap *regmap;
 	bool has_encoder;
+	unsigned int num_cc_chans;
 };
 
 #endif
diff --git a/include/linux/mfd/stm32-timers.h b/include/linux/mfd/stm32-timers.h
index 5f5c43fd6..1a8c05cab 100644
--- a/include/linux/mfd/stm32-timers.h
+++ b/include/linux/mfd/stm32-timers.h
@@ -31,6 +31,11 @@
 #define TIM_BDTR	0x44	/* Break and Dead-Time Reg */
 #define TIM_DCR		0x48	/* DMA control register    */
 #define TIM_DMAR	0x4C	/* DMA register for transfer */
+#define TIM_TISEL	0x68	/* Input Selection         */
+
+#define TIM_HWCFGR2	0x3EC	/* hardware configuration 2 Reg (MP25)	*/
+#define TIM_HWCFGR1	0x3F0	/* hardware configuration 1 Reg (MP25)	*/
+#define TIM_IPIDR	0x3F8	/* IP identification Reg (MP25)		*/
 
 #define TIM_CR1_CEN	BIT(0)	/* Counter Enable	   */
 #define TIM_CR1_DIR	BIT(4)  /* Counter Direction	   */
@@ -40,6 +45,11 @@
 #define TIM_SMCR_SMS	(BIT(0) | BIT(1) | BIT(2)) /* Slave mode selection */
 #define TIM_SMCR_TS	(BIT(4) | BIT(5) | BIT(6)) /* Trigger selection */
 #define TIM_DIER_UIE	BIT(0)	/* Update interrupt	   */
+#define TIM_DIER_CC1IE	BIT(1)  /* CC1 Interrupt Enable    */
+#define TIM_DIER_CC2IE	BIT(2)  /* CC2 Interrupt Enable    */
+#define TIM_DIER_CC3IE	BIT(3)  /* CC3 Interrupt Enable    */
+#define TIM_DIER_CC4IE	BIT(4)  /* CC4 Interrupt Enable    */
+#define TIM_DIER_CC_IE(x)	BIT((x) + 1) /* CC1, CC2, CC3, CC4 interrupt enable */
 #define TIM_DIER_UDE	BIT(8)  /* Update DMA request Enable */
 #define TIM_DIER_CC1DE	BIT(9)  /* CC1 DMA request Enable  */
 #define TIM_DIER_CC2DE	BIT(10) /* CC2 DMA request Enable  */
@@ -48,6 +58,7 @@
 #define TIM_DIER_COMDE	BIT(13) /* COM DMA request Enable  */
 #define TIM_DIER_TDE	BIT(14) /* Trigger DMA request Enable */
 #define TIM_SR_UIF	BIT(0)	/* Update interrupt flag   */
+#define TIM_SR_CC_IF(x)	BIT((x) + 1) /* CC1, CC2, CC3, CC4 interrupt flag */
 #define TIM_EGR_UG	BIT(0)	/* Update Generation       */
 #define TIM_CCMR_PE	BIT(3)	/* Channel Preload Enable  */
 #define TIM_CCMR_M1	(BIT(6) | BIT(5))  /* Channel PWM Mode 1 */
@@ -59,16 +70,23 @@
 #define TIM_CCMR_CC1S_TI2	BIT(1)	/* IC1/IC3 selects TI2/TI4 */
 #define TIM_CCMR_CC2S_TI2	BIT(8)	/* IC2/IC4 selects TI2/TI4 */
 #define TIM_CCMR_CC2S_TI1	BIT(9)	/* IC2/IC4 selects TI1/TI3 */
+#define TIM_CCMR_CC3S		(BIT(0) | BIT(1)) /* Capture/compare 3 sel */
+#define TIM_CCMR_CC4S		(BIT(8) | BIT(9)) /* Capture/compare 4 sel */
+#define TIM_CCMR_CC3S_TI3	BIT(0)	/* IC3 selects TI3 */
+#define TIM_CCMR_CC4S_TI4	BIT(8)	/* IC4 selects TI4 */
 #define TIM_CCER_CC1E	BIT(0)	/* Capt/Comp 1  out Ena    */
 #define TIM_CCER_CC1P	BIT(1)	/* Capt/Comp 1  Polarity   */
 #define TIM_CCER_CC1NE	BIT(2)	/* Capt/Comp 1N out Ena    */
 #define TIM_CCER_CC1NP	BIT(3)	/* Capt/Comp 1N Polarity   */
 #define TIM_CCER_CC2E	BIT(4)	/* Capt/Comp 2  out Ena    */
 #define TIM_CCER_CC2P	BIT(5)	/* Capt/Comp 2  Polarity   */
+#define TIM_CCER_CC2NP	BIT(7)	/* Capt/Comp 2N Polarity   */
 #define TIM_CCER_CC3E	BIT(8)	/* Capt/Comp 3  out Ena    */
 #define TIM_CCER_CC3P	BIT(9)	/* Capt/Comp 3  Polarity   */
+#define TIM_CCER_CC3NP	BIT(11)	/* Capt/Comp 3N Polarity   */
 #define TIM_CCER_CC4E	BIT(12)	/* Capt/Comp 4  out Ena    */
 #define TIM_CCER_CC4P	BIT(13)	/* Capt/Comp 4  Polarity   */
+#define TIM_CCER_CC4NP	BIT(15)	/* Capt/Comp 4N Polarity   */
 #define TIM_CCER_CCXE	(BIT(0) | BIT(4) | BIT(8) | BIT(12))
 #define TIM_BDTR_BKE(x)	BIT(12 + (x) * 12) /* Break input enable */
 #define TIM_BDTR_BKP(x)	BIT(13 + (x) * 12) /* Break input polarity */
@@ -77,6 +95,9 @@
 #define TIM_BDTR_BKF(x)	(0xf << (16 + (x) * 4))
 #define TIM_DCR_DBA	GENMASK(4, 0)	/* DMA base addr */
 #define TIM_DCR_DBL	GENMASK(12, 8)	/* DMA burst len */
+#define TIM_HWCFGR1_NB_OF_CC	GENMASK(3, 0)	/* Capture/compare channels */
+#define TIM_HWCFGR1_NB_OF_DT	GENMASK(7, 4)	/* Complementary outputs & dead-time generators */
+#define TIM_HWCFGR2_CNT_WIDTH	GENMASK(15, 8)	/* Counter width */
 
 #define MAX_TIM_PSC		0xFFFF
 #define MAX_TIM_ICPSC		0x3
@@ -90,6 +111,8 @@
 #define TIM_BDTR_BKF_MASK	0xF
 #define TIM_BDTR_BKF_SHIFT(x)	(16 + (x) * 4)
 
+#define STM32MP25_TIM_IPIDR	0x00120002
+
 enum stm32_timers_dmas {
 	STM32_TIMERS_DMA_CH1,
 	STM32_TIMERS_DMA_CH2,
@@ -101,6 +124,15 @@ enum stm32_timers_dmas {
 	STM32_TIMERS_MAX_DMAS,
 };
 
+/* STM32 Timer may have either a unique global interrupt or 4 interrupt lines */
+enum stm32_timers_irqs {
+	STM32_TIMERS_IRQ_GLOBAL_BRK, /* global or brk IRQ */
+	STM32_TIMERS_IRQ_UP,
+	STM32_TIMERS_IRQ_TRG_COM,
+	STM32_TIMERS_IRQ_CC,
+	STM32_TIMERS_MAX_IRQS,
+};
+
 /**
  * struct stm32_timers_dma - STM32 timer DMA handling.
  * @completion:		end of DMA transfer completion
@@ -119,9 +151,12 @@ struct stm32_timers_dma {
 
 struct stm32_timers {
 	struct clk *clk;
+	u32 ipidr;
 	struct regmap *regmap;
 	u32 max_arr;
 	struct stm32_timers_dma dma; /* Only to be used by the parent */
+	unsigned int nr_irqs;
+	int irq[STM32_TIMERS_MAX_IRQS];
 };
 
 #if IS_REACHABLE(CONFIG_MFD_STM32_TIMERS)
diff --git a/include/linux/mmc/sdio_ids.h b/include/linux/mmc/sdio_ids.h
index 0e4ef9c51..bf3c95d8e 100644
--- a/include/linux/mmc/sdio_ids.h
+++ b/include/linux/mmc/sdio_ids.h
@@ -74,10 +74,13 @@
 #define SDIO_DEVICE_ID_BROADCOM_43362		0xa962
 #define SDIO_DEVICE_ID_BROADCOM_43364		0xa9a4
 #define SDIO_DEVICE_ID_BROADCOM_43430		0xa9a6
-#define SDIO_DEVICE_ID_BROADCOM_CYPRESS_43439	0xa9af
+#define SDIO_DEVICE_ID_BROADCOM_43439		0xa9af
 #define SDIO_DEVICE_ID_BROADCOM_43455		0xa9bf
 #define SDIO_DEVICE_ID_BROADCOM_CYPRESS_43752	0xaae8
 
+#define SDIO_VENDOR_ID_CYPRESS			0x04b4
+#define SDIO_DEVICE_ID_BROADCOM_CYPRESS_43439	0xbd3d
+
 #define SDIO_VENDOR_ID_MARVELL			0x02df
 #define SDIO_DEVICE_ID_MARVELL_LIBERTAS		0x9103
 #define SDIO_DEVICE_ID_MARVELL_8688_WLAN	0x9104
diff --git a/include/linux/msi.h b/include/linux/msi.h
index e5dfb9cf3..9b73847c9 100644
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@ -300,6 +300,12 @@ static inline void msi_device_destroy_sysfs(struct device *dev) { }
  */
 bool arch_restore_msi_irqs(struct pci_dev *dev);
 
+/*
+ * Hook for the platform to provide alternative IRQs
+ * than MSI or legacy
+ */
+extern int (*pcie_port_irqs_hook)(struct pci_dev *dev, u32 *pme, u32 *aer, u32 *dpc);
+
 #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
 
 #include <linux/irqhandler.h>
diff --git a/include/linux/mtd/cfi.h b/include/linux/mtd/cfi.h
index d88bb56c1..29668241b 100644
--- a/include/linux/mtd/cfi.h
+++ b/include/linux/mtd/cfi.h
@@ -374,6 +374,7 @@ struct cfi_fixup {
 #define CFI_MFR_MICRON		0x002C /* Micron */
 #define CFI_MFR_TOSHIBA		0x0098
 #define CFI_MFR_WINBOND		0x00DA
+#define CFI_MFR_CYPRESS		0x0034
 
 void cfi_fixup(struct mtd_info *mtd, struct cfi_fixup* fixups);
 
diff --git a/include/linux/mtd/sfdp.h b/include/linux/mtd/sfdp.h
new file mode 100644
index 000000000..8f33c356a
--- /dev/null
+++ b/include/linux/mtd/sfdp.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef __MTD_SFDP_H__
+#define __MTD_SFDP_H__
+#include <linux/mtd/gen_probe.h>
+
+struct mtd_info *hyperbus_sfdp_probe(struct map_info *map);
+int __xipram hyperbus_sfdp_mode_on(u32 base, struct map_info *map,
+				   struct cfi_private *cfi);
+void __xipram hyperbus_sfdp_mode_off(u32 base, struct map_info *map,
+				     struct cfi_private *cfi);
+#endif /* __MTD_SFDP_H__ */
diff --git a/include/linux/pci-epc.h b/include/linux/pci-epc.h
index a48778e1a..ebf54a619 100644
--- a/include/linux/pci-epc.h
+++ b/include/linux/pci-epc.h
@@ -154,6 +154,7 @@ struct pci_epc {
 
 /**
  * struct pci_epc_features - features supported by a EPC device per function
+ * @force_core_init: indicate if the EPC device can initialize when binding
  * @linkup_notifier: indicate if the EPC device can notify EPF driver on link up
  * @core_init_notifier: indicate cores that can notify about their availability
  *			for initialization
@@ -165,6 +166,7 @@ struct pci_epc {
  * @align: alignment size required for BAR buffer allocation
  */
 struct pci_epc_features {
+	unsigned int	force_core_init : 1;
 	unsigned int	linkup_notifier : 1;
 	unsigned int	core_init_notifier : 1;
 	unsigned int	msi_capable : 1;
diff --git a/include/linux/phylink.h b/include/linux/phylink.h
index 6d62c9ea2..7a095bd89 100644
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@ -582,6 +582,7 @@ void phylink_stop(struct phylink *);
 
 void phylink_suspend(struct phylink *pl, bool mac_wol);
 void phylink_resume(struct phylink *pl);
+void phylink_phy_resume(struct phylink *pl);
 
 void phylink_ethtool_get_wol(struct phylink *, struct ethtool_wolinfo *);
 int phylink_ethtool_set_wol(struct phylink *, struct ethtool_wolinfo *);
diff --git a/include/linux/pm_domain.h b/include/linux/pm_domain.h
index ebc351698..4c753ca6d 100644
--- a/include/linux/pm_domain.h
+++ b/include/linux/pm_domain.h
@@ -18,6 +18,33 @@
 #include <linux/spinlock.h>
 #include <linux/cpumask.h>
 
+/*
+ * Flags to control the behaviour when attaching a device to its PM domains.
+ *
+ * PD_FLAG_NO_DEV_LINK:		As the default behaviour creates a device-link
+ *				for every PM domain that gets attached, this
+ *				flag can be used to skip that.
+ *
+ * PD_FLAG_DEV_LINK_ON:		Add the DL_FLAG_RPM_ACTIVE to power-on the
+ *				supplier and its PM domain when creating the
+ *				device-links.
+ *
+ */
+#define PD_FLAG_NO_DEV_LINK		BIT(0)
+#define PD_FLAG_DEV_LINK_ON		BIT(1)
+
+struct dev_pm_domain_attach_data {
+	const char * const *pd_names;
+	const u32 num_pd_names;
+	const u32 pd_flags;
+};
+
+struct dev_pm_domain_list {
+	struct device **pd_devs;
+	struct device_link **pd_links;
+	u32 num_pds;
+};
+
 /*
  * Flags to control the behaviour of a genpd.
  *
@@ -415,7 +442,11 @@ struct device *dev_pm_domain_attach_by_id(struct device *dev,
 					  unsigned int index);
 struct device *dev_pm_domain_attach_by_name(struct device *dev,
 					    const char *name);
+int dev_pm_domain_attach_list(struct device *dev,
+			      const struct dev_pm_domain_attach_data *data,
+			      struct dev_pm_domain_list **list);
 void dev_pm_domain_detach(struct device *dev, bool power_off);
+void dev_pm_domain_detach_list(struct dev_pm_domain_list *list);
 int dev_pm_domain_start(struct device *dev);
 void dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd);
 #else
@@ -433,7 +464,14 @@ static inline struct device *dev_pm_domain_attach_by_name(struct device *dev,
 {
 	return NULL;
 }
+static inline int dev_pm_domain_attach_list(struct device *dev,
+				const struct dev_pm_domain_attach_data *data,
+				struct dev_pm_domain_list **list)
+{
+	return 0;
+}
 static inline void dev_pm_domain_detach(struct device *dev, bool power_off) {}
+static inline void dev_pm_domain_detach_list(struct dev_pm_domain_list *list) {}
 static inline int dev_pm_domain_start(struct device *dev)
 {
 	return 0;
diff --git a/include/linux/ptp_clock_kernel.h b/include/linux/ptp_clock_kernel.h
index 92b441614..8ed4796b8 100644
--- a/include/linux/ptp_clock_kernel.h
+++ b/include/linux/ptp_clock_kernel.h
@@ -191,6 +191,9 @@ struct ptp_clock_info {
 	int (*verify)(struct ptp_clock_info *ptp, unsigned int pin,
 		      enum ptp_pin_function func, unsigned int chan);
 	long (*do_aux_work)(struct ptp_clock_info *ptp);
+	int (*getphcxtstamp)(struct ptp_clock_info *ptp,
+						 struct ptp_clock_info *ptp_peer,
+						 struct device_device_crosststamp *cts);
 };
 
 struct ptp_clock;
@@ -263,6 +266,8 @@ static inline long scaled_ppm_to_ppb(long ppm)
 extern struct ptp_clock *ptp_clock_register(struct ptp_clock_info *info,
 					    struct device *parent);
 
+extern int ptp_clock_set_peer(struct ptp_clock *ptp, struct ptp_clock *peer);
+
 /**
  * ptp_clock_unregister() - unregister a PTP hardware clock driver
  *
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index fe8978eb6..2e0826cfe 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -467,6 +467,18 @@ enum rproc_dump_mechanism {
 	RPROC_COREDUMP_INLINE,
 };
 
+/**
+ * enum rproc_fw_format - firmware image format supported
+ * @RPROC_FW_ELF:    the firmware image must be in ELF format
+ * @RPROC_FW_TEE:    the firmware image must be in format that will be treated by the TEE
+ * @RPROC_FW_LAST:   just keep this one at the end
+ */
+enum rproc_fw_format {
+	RPROC_FW_ELF,
+	RPROC_FW_TEE,
+	RPROC_FW_LAST,
+};
+
 /**
  * struct rproc_dump_segment - segment info from ELF header
  * @node:	list node related to the rproc segment list
@@ -585,6 +597,7 @@ struct rproc {
 	u16 elf_machine;
 	struct cdev cdev;
 	bool cdev_put_on_release;
+	unsigned int fw_format;
 	DECLARE_BITMAP(features, RPROC_MAX_FEATURES);
 };
 
diff --git a/include/linux/scmi_protocol.h b/include/linux/scmi_protocol.h
index 4f765bc78..380e8ff98 100644
--- a/include/linux/scmi_protocol.h
+++ b/include/linux/scmi_protocol.h
@@ -95,6 +95,10 @@ struct scmi_clk_proto_ops {
 	int (*enable_atomic)(const struct scmi_protocol_handle *ph, u32 clk_id);
 	int (*disable_atomic)(const struct scmi_protocol_handle *ph,
 			      u32 clk_id);
+	int (*get_duty_cycle)(const struct scmi_protocol_handle *ph,
+			      u32 clk_id, int *num, int *den);
+	int (*round_rate_get)(const struct scmi_protocol_handle *ph,
+			      u32 clk_id, u64 *rate);
 };
 
 /**
diff --git a/include/linux/smscphy.h b/include/linux/smscphy.h
index 1a136271b..00884908e 100644
--- a/include/linux/smscphy.h
+++ b/include/linux/smscphy.h
@@ -14,6 +14,7 @@
 #define MII_LAN83C185_ISF_INT5 (1<<5) /* Remote Fault Detected */
 #define MII_LAN83C185_ISF_INT6 (1<<6) /* Auto-Negotiation complete */
 #define MII_LAN83C185_ISF_INT7 (1<<7) /* ENERGYON */
+#define MII_LAN83C185_ISF_INT8 (1<<8) /* Wake on LAN */
 
 #define MII_LAN83C185_ISF_INT_ALL (0x0e)
 
@@ -28,4 +29,23 @@
 #define MII_LAN83C185_MODE_POWERDOWN 0xC0 /* Power Down mode */
 #define MII_LAN83C185_MODE_ALL       0xE0 /* All capable mode */
 
+/* MMD 3 Registers */
+#define	LAN8742_MMD3_WAKEUP_CTRL	(32784)
+#define	LAN8742_MMD3_WUCSR_LED2_AS_NPME BIT(12)
+#define	LAN8742_MMD3_WUCSR_WOL		BIT(8)
+#define	LAN8742_MMD3_WUCSR_PFDA_FR	BIT(7)
+#define	LAN8742_MMD3_WUCSR_WUFR		BIT(6)
+#define	LAN8742_MMD3_WUCSR_MPR		BIT(5)
+#define	LAN8742_MMD3_WUCSR_BCAST_FR	BIT(4)
+#define	LAN8742_MMD3_WUCSR_MPEN		BIT(1)
+
+#define	LAN8742_MMD3_WAKEUP_FILTER	(32785)
+#define	LAN8742_MMD3_WUF_CFGA_FE	BIT(15)
+#define	LAN8742_MMD3_WUF_CFGA_AME	BIT(10)
+
+#define	LAN8742_MMD3_MAC_ADDRA		(32865)
+#define	LAN8742_MMD3_MAC_ADDRB		(32866)
+#define	LAN8742_MMD3_MAC_ADDRC		(32867)
+#define	LAN8742_MMD3_PME_ASSERT_DELAY	(32868)
+
 #endif /* __LINUX_SMSCPHY_H__ */
diff --git a/include/linux/spi/spi-mem.h b/include/linux/spi/spi-mem.h
index 8e984d75f..72cc79c86 100644
--- a/include/linux/spi/spi-mem.h
+++ b/include/linux/spi/spi-mem.h
@@ -87,6 +87,8 @@ enum spi_mem_data_dir {
  *		  be zero if the operation does not require dummy bytes
  * @dummy.buswidth: number of IO lanes used to transmit the dummy bytes
  * @dummy.dtr: whether the dummy bytes should be sent in DTR mode or not
+ * @data.dtr_swab16: whether the byte order of 16-bit words is swapped when read
+ *		     or written in Octal DTR mode compared to STR mode.
  * @data.buswidth: number of IO lanes used to send/receive the data
  * @data.dtr: whether the data should be sent in DTR mode or not
  * @data.ecc: whether error correction is required or not
@@ -120,6 +122,7 @@ struct spi_mem_op {
 	struct {
 		u8 buswidth;
 		u8 dtr : 1;
+		u8 dtr_swab16 : 1;
 		u8 ecc : 1;
 		enum spi_mem_data_dir dir;
 		unsigned int nbytes;
@@ -290,10 +293,13 @@ struct spi_controller_mem_ops {
 /**
  * struct spi_controller_mem_caps - SPI memory controller capabilities
  * @dtr: Supports DTR operations
+ * @dtr_swab16: Supports swapping bytes on a 16 bit boundary when configured in
+ *		Octal DTR
  * @ecc: Supports operations with error correction
  */
 struct spi_controller_mem_caps {
 	bool dtr;
+	bool dtr_swab16;
 	bool ecc;
 };
 
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 8e9054d9f..4034838be 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -1251,6 +1251,10 @@ extern int spi_split_transfers_maxsize(struct spi_controller *ctlr,
 				       struct spi_message *msg,
 				       size_t maxsize,
 				       gfp_t gfp);
+extern int spi_split_transfers_maxwords(struct spi_controller *ctlr,
+					struct spi_message *msg,
+					size_t maxwords,
+					gfp_t gfp);
 
 /*---------------------------------------------------------------------------*/
 
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index 9f4a4f702..468419578 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -91,6 +91,8 @@ struct stmmac_dma_cfg {
 	int pbl;
 	int txpbl;
 	int rxpbl;
+	int txqos;
+	int rxqos;
 	bool pblx8;
 	int fixed_burst;
 	int mixed_burst;
@@ -216,6 +218,7 @@ struct plat_stmmacenet_data {
 	int unicast_filter_entries;
 	int tx_fifo_size;
 	int rx_fifo_size;
+	int ext_systime;
 	u32 host_dma_width;
 	u32 rx_queues_to_use;
 	u32 tx_queues_to_use;
diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index 17eb1c520..613c511a2 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -77,6 +77,36 @@ struct tee_param {
 	} u;
 };
 
+/* State an Ocall context for argument passed with struct tee_ocall2_arg */
+enum tee_ocall2_state {
+	TEE_OCALL2_IDLE,
+	TEE_OCALL2_IN_PROGRESS,
+};
+
+/*
+ * struct tee_ocall2_arg - Ocall context argument passed by caller
+ *
+ * @state: Ocall unused, ready, in-progress
+ * @session; Session the Ocall relates to
+ * @in_commnad: Ocall command 32bit ID from the TEE service
+ * @in_param: Ocall 32bit input parameter value from the TEE service
+ * @out_result: Ocall 32bit result ID. Value 0 indicates an error.
+ * @out_param: Ocall 32bit output parameter. TEEC_ERROR_* when @out_result is 0.
+ */
+struct tee_ocall2_arg {
+	enum tee_ocall2_state state;
+	u32 session;
+	u32 in_param1;
+	u32 in_param2;
+	u32 out_param1;
+	u32 out_param2;
+};
+
+#define TEE_OCALL2_OUT_PARAM1_ERROR	0
+
+#define TEE_OCALL2_ARG_INIT \
+		((struct tee_ocall2_arg){ .state = TEE_OCALL2_IDLE })
+
 /**
  * struct tee_driver_ops - driver operations vtable
  * @get_version:	returns version of driver
@@ -84,6 +114,7 @@ struct tee_param {
  * @release:		release this open file
  * @open_session:	open a new session
  * @close_session:	close a session
+ * @system_session:	declare session as a system session
  * @invoke_func:	invoke a trusted function
  * @cancel_req:		request cancel of an ongoing invoke or open
  * @supp_recv:		called for supplicant to get a command
@@ -100,9 +131,14 @@ struct tee_driver_ops {
 			    struct tee_ioctl_open_session_arg *arg,
 			    struct tee_param *param);
 	int (*close_session)(struct tee_context *ctx, u32 session);
+	int (*system_session)(struct tee_context *ctx, u32 session);
 	int (*invoke_func)(struct tee_context *ctx,
 			   struct tee_ioctl_invoke_arg *arg,
 			   struct tee_param *param);
+	int (*invoke_func_ocall2)(struct tee_context *ctx,
+				  struct tee_ioctl_invoke_arg *arg,
+				  struct tee_param *param,
+				  struct tee_ocall2_arg *ocall_arg);
 	int (*cancel_req)(struct tee_context *ctx, u32 cancel_id, u32 session);
 	int (*supp_recv)(struct tee_context *ctx, u32 *func, u32 *num_params,
 			 struct tee_param *param);
@@ -429,6 +465,20 @@ int tee_client_open_session(struct tee_context *ctx,
  */
 int tee_client_close_session(struct tee_context *ctx, u32 session);
 
+/**
+ * tee_client_system_session() - Declare session as a system session
+ * @ctx:	TEE Context
+ * @session:	Session id
+ *
+ * This function requests TEE to provision an entry context ready to use for
+ * that session only. The provisioned entry context is used for command
+ * invocation and session closure, not for command cancelling requests.
+ * TEE releases the provisioned context upon session closure.
+ *
+ * Return < 0 on error else 0 if an entry context has been provisioned.
+ */
+int tee_client_system_session(struct tee_context *ctx, u32 session);
+
 /**
  * tee_client_invoke_func() - Invoke a function in a Trusted Application
  * @ctx:	TEE Context
@@ -507,4 +557,42 @@ struct tee_context *teedev_open(struct tee_device *teedev);
  */
 void teedev_close_context(struct tee_context *ctx);
 
+/* Ocall2 helper macros & functions */
+#define TEE_OCALL2_PARAM1_ERROR		0
+
+static inline bool tee_ocall_is_used(struct tee_ocall2_arg *arg)
+{
+	return arg;
+}
+
+static inline bool tee_ocall_in_progress(struct tee_ocall2_arg *arg)
+{
+	return arg && arg->state == TEE_OCALL2_IN_PROGRESS;
+}
+
+static inline void tee_ocall_failure(struct tee_ocall2_arg *arg)
+{
+	arg->out_param1 = TEE_OCALL2_PARAM1_ERROR;
+	arg->out_param2 = 0;
+}
+
+/**
+ * tee_client_invoke_func_ocall2() - Invoke a TEE service with Ocall2 support
+ * @ctx:        TEE Context
+ * @arg:        Invoke arguments, see description of struct tee_ioctl_invoke_arg
+ * @param:      Parameters passed to the Trusted Application
+ * @ocall_arg:  Input/output arguments for the Ocall or NULL
+ *
+ * Returns < 0 on error else see @arg->ret for result.
+ * On successful return, use tee_ocall_in_progress() to distinguish between
+ * a regular invocation return and an Ocall command from TEE.
+ *
+ * In order to return from an Ocall, call tee_client_invoke_with_ocall2()
+ * with the same @context, @ocall_arg arguments and allocated @arg and
+ * @param memory areas.
+ */
+int tee_client_invoke_func_ocall2(struct tee_context *ctx,
+				  struct tee_ioctl_invoke_arg *arg,
+				  struct tee_param *param,
+				  struct tee_ocall2_arg *ocall_arg);
 #endif /*__TEE_DRV_H*/
diff --git a/include/linux/tee_remoteproc.h b/include/linux/tee_remoteproc.h
new file mode 100644
index 000000000..7e8db04a8
--- /dev/null
+++ b/include/linux/tee_remoteproc.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright(c) 2023 STMicroelectronics
+ */
+
+#ifndef TEE_REMOTEPROC_H
+#define TEE_REMOTEPROC_H
+
+#include <linux/remoteproc.h>
+#include <linux/tee_drv.h>
+
+/**
+ * struct tee_rproc - TEE remoteproc structure
+ * @node:		Reference in list
+ * @rproc:		Remoteproc reference
+ * @parent:		Parent device
+ * @rproc_id:		Identifier of the remote processor
+ * @session_id:		TEE session identifier
+ * @rsc_va:		Resource table virtual address.
+ */
+struct tee_rproc {
+	struct list_head node;
+
+	struct rproc *rproc;
+	struct device *parent;
+	u32 rproc_id;
+	u32 session_id;
+	void *rsc_va;
+};
+
+#if IS_ENABLED(CONFIG_TEE_REMOTEPROC)
+
+struct tee_rproc *tee_rproc_register(struct device *dev, unsigned int rproc_id);
+int tee_rproc_unregister(struct tee_rproc *trproc);
+
+int tee_rproc_load_fw(struct tee_rproc *trproc, const struct firmware *fw);
+int rproc_tee_get_rsc_table(struct tee_rproc *trproc);
+struct resource_table *tee_rproc_get_loaded_rsc_table(struct tee_rproc *trproc);
+int tee_rproc_start(struct tee_rproc *trproc);
+int tee_rproc_stop(struct tee_rproc *trproc);
+
+#else
+
+static inline struct tee_rproc *tee_rproc_register(struct device *dev, unsigned int rproc_id)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline int tee_rproc_unregister(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int tee_rproc_load_fw(struct tee_rproc *trproc, const struct firmware *fw)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int tee_rproc_start(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int tee_rproc_stop(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline int rproc_tee_get_rsc_table(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline struct resource_table *
+	tee_rproc_get_loaded_rsc_table(struct tee_rproc *trproc)
+{
+	/* This shouldn't be possible */
+	WARN_ON(1);
+
+	return NULL;
+}
+
+#endif /* CONFIG_TEE_REMOTEPROC */
+#endif /* TEE_REMOTEPROC_H */
diff --git a/include/linux/timekeeping.h b/include/linux/timekeeping.h
index fe1e467ba..f03dfe10b 100644
--- a/include/linux/timekeeping.h
+++ b/include/linux/timekeeping.h
@@ -266,6 +266,11 @@ struct system_device_crosststamp {
 	ktime_t sys_monoraw;
 };
 
+struct device_device_crosststamp {
+	ktime_t device;
+	ktime_t peer_device;
+};
+
 /**
  * struct system_counterval_t - system counter value with the pointer to the
  *				corresponding clocksource
diff --git a/include/linux/tty_buffer.h b/include/linux/tty_buffer.h
index 1796648c2..3b9d77604 100644
--- a/include/linux/tty_buffer.h
+++ b/include/linux/tty_buffer.h
@@ -15,7 +15,6 @@ struct tty_buffer {
 	int used;
 	int size;
 	int commit;
-	int lookahead;		/* Lazy update on recv, can become less than "read" */
 	int read;
 	int flags;
 	/* Data points here */
diff --git a/include/linux/tty_ldisc.h b/include/linux/tty_ldisc.h
index dcb61ec11..7b49b2251 100644
--- a/include/linux/tty_ldisc.h
+++ b/include/linux/tty_ldisc.h
@@ -186,18 +186,6 @@ int ldsem_down_write_nested(struct ld_semaphore *sem, int subclass,
  *	indicate all data received is %TTY_NORMAL. If assigned, prefer this
  *	function for automatic flow control.
  *
- * @lookahead_buf: [DRV] ``void ()(struct tty_struct *tty,
- *			const unsigned char *cp, const char *fp, int count)``
- *
- *	This function is called by the low-level tty driver for characters
- *	not eaten by ->receive_buf() or ->receive_buf2(). It is useful for
- *	processing high-priority characters such as software flow-control
- *	characters that could otherwise get stuck into the intermediate
- *	buffer until tty has room to receive them. Ldisc must be able to
- *	handle later a ->receive_buf() or ->receive_buf2() call for the
- *	same characters (e.g. by skipping the actions for high-priority
- *	characters already handled by ->lookahead_buf()).
- *
  * @owner: module containting this ldisc (for reference counting)
  *
  * This structure defines the interface between the tty line discipline
@@ -241,8 +229,6 @@ struct tty_ldisc_ops {
 	void	(*dcd_change)(struct tty_struct *tty, unsigned int status);
 	int	(*receive_buf2)(struct tty_struct *tty, const unsigned char *cp,
 				const char *fp, int count);
-	void	(*lookahead_buf)(struct tty_struct *tty, const unsigned char *cp,
-				 const unsigned char *fp, unsigned int count);
 
 	struct  module *owner;
 };
diff --git a/include/linux/tty_port.h b/include/linux/tty_port.h
index fa3c3bdaa..58e961911 100644
--- a/include/linux/tty_port.h
+++ b/include/linux/tty_port.h
@@ -40,8 +40,6 @@ struct tty_port_operations {
 
 struct tty_port_client_operations {
 	int (*receive_buf)(struct tty_port *port, const unsigned char *, const unsigned char *, size_t);
-	void (*lookahead_buf)(struct tty_port *port, const unsigned char *cp,
-			      const unsigned char *fp, unsigned int count);
 	void (*write_wakeup)(struct tty_port *port);
 };
 
diff --git a/include/media/media-entity.h b/include/media/media-entity.h
index 28c9de8a1..11829757d 100644
--- a/include/media/media-entity.h
+++ b/include/media/media-entity.h
@@ -345,6 +345,12 @@ struct media_entity {
 
 	int use_count;
 
+	/* Temporarily put back to allow handling the multi-pipe on DCMIPP MP25
+	 * This is being incremented when performing start_streaming in order to
+	 * know if an entity needs to be s_streamed (on or off) or not
+	 */
+	u32 stream_count;
+
 	union {
 		struct {
 			u32 major;
diff --git a/include/media/v4l2-ctrls.h b/include/media/v4l2-ctrls.h
index e59d9a234..2c4d5d293 100644
--- a/include/media/v4l2-ctrls.h
+++ b/include/media/v4l2-ctrls.h
@@ -81,6 +81,7 @@ union v4l2_ctrl_ptr {
 	struct v4l2_ctrl_hdr10_cll_info *p_hdr10_cll;
 	struct v4l2_ctrl_hdr10_mastering_display *p_hdr10_mastering;
 	struct v4l2_area *p_area;
+	struct v4l2_ctrl_vp8_encode_params *p_vp8_encode_params;
 	void *p;
 	const void *p_const;
 };
diff --git a/include/media/v4l2-mediabus.h b/include/media/v4l2-mediabus.h
index f67a74daf..806be2d23 100644
--- a/include/media/v4l2-mediabus.h
+++ b/include/media/v4l2-mediabus.h
@@ -94,11 +94,13 @@ struct v4l2_mbus_config_mipi_csi2 {
  * @flags: media bus (V4L2_MBUS_*) flags
  * @bus_width: bus width in bits
  * @data_shift: data shift in bits
+ * @pclk_max_frequency: maximum pixel clock in hertz
  */
 struct v4l2_mbus_config_parallel {
 	unsigned int flags;
 	unsigned char bus_width;
 	unsigned char data_shift;
+	unsigned int pclk_max_frequency;
 };
 
 /**
diff --git a/include/memory/stm32-omi.h b/include/memory/stm32-omi.h
new file mode 100644
index 000000000..bd182567a
--- /dev/null
+++ b/include/memory/stm32-omi.h
@@ -0,0 +1,202 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author(s): Patrice Chotard <patrice.chotard@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef __STM32_OMI_H
+#define __STM32_OMI_H
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/mtd/hyperbus.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/sizes.h>
+#include <linux/spi/spi-mem.h>
+#include <linux/types.h>
+
+#define OSPI_CR			0x00
+#define CR_EN			BIT(0)
+#define CR_ABORT		BIT(1)
+#define CR_DMAEN		BIT(2)
+#define CR_TCEN			BIT(3)
+#define CR_FTHRES_SHIFT		8
+#define CR_TEIE			BIT(16)
+#define CR_TCIE			BIT(17)
+#define CR_SMIE			BIT(19)
+#define CR_APMS			BIT(22)
+#define CR_CSSEL		BIT(24)
+#define CR_FMODE_MASK		GENMASK(29, 28)
+#define CR_FMODE_INDW		(0U)
+#define CR_FMODE_INDR		(1U)
+#define CR_FMODE_APM		(2U)
+#define CR_FMODE_MM		(3U)
+
+#define OSPI_DCR1		0x08
+#define DCR1_FRCK		BIT(1)
+#define DCR1_DLYBYP		BIT(3)
+#define DCR1_DEVSIZE_MASK	GENMASK(20, 16)
+#define DCR1_MTYP_MASK		GENMASK(26, 24)
+#define DCR1_MTYP_MX_MODE	1
+#define DCR1_MTYP_HP_MEMMODE	4
+
+#define OSPI_DCR2		0x0c
+#define DCR2_PRESC_MASK		GENMASK(7, 0)
+
+#define OSPI_SR			0x20
+#define SR_TEF			BIT(0)
+#define SR_TCF			BIT(1)
+#define SR_FTF			BIT(2)
+#define SR_SMF			BIT(3)
+#define SR_BUSY			BIT(5)
+
+#define OSPI_FCR		0x24
+#define FCR_CTEF		BIT(0)
+#define FCR_CTCF		BIT(1)
+#define FCR_CSMF		BIT(3)
+
+#define OSPI_DLR		0x40
+#define OSPI_AR			0x48
+#define OSPI_DR			0x50
+#define OSPI_PSMKR		0x80
+#define OSPI_PSMAR		0x88
+
+#define OSPI_CCR		0x100
+#define CCR_IMODE_MASK		GENMASK(2, 0)
+#define CCR_IDTR		BIT(3)
+#define CCR_ISIZE_MASK		GENMASK(5, 4)
+#define CCR_ADMODE_MASK		GENMASK(10, 8)
+#define CCR_ADMODE_8LINES	4
+#define CCR_ADDTR		BIT(11)
+#define CCR_ADSIZE_MASK		GENMASK(13, 12)
+#define CCR_ADSIZE_32BITS	3
+#define CCR_DMODE_MASK		GENMASK(26, 24)
+#define CCR_DMODE_8LINES	4
+#define CCR_DQSE		BIT(29)
+#define CCR_DDTR		BIT(27)
+#define CCR_BUSWIDTH_0		0x0
+#define CCR_BUSWIDTH_1		0x1
+#define CCR_BUSWIDTH_2		0x2
+#define CCR_BUSWIDTH_4		0x3
+#define CCR_BUSWIDTH_8		0x4
+
+#define OSPI_TCR		0x108
+#define TCR_DCYC_MASK		GENMASK(4, 0)
+#define TCR_DHQC		BIT(28)
+#define TCR_SSHIFT		BIT(30)
+
+#define OSPI_IR			0x110
+
+#define OSPI_LPTR		0x130
+#define LPTR_TIMEOUT_MASK	GENMASK(15, 0)
+
+#define OSPI_WCCR		0x180
+#define WCCR_DQSE		BIT(29)
+#define WCCR_DDTR		BIT(27)
+#define WCCR_DMODE_MASK		GENMASK(26, 24)
+#define WCCR_DMODE_8LINES	4
+#define WCCR_ADSIZE_MASK	GENMASK(13, 12)
+#define WCCR_ADSIZE_32BITS	3
+#define WCCR_ADDTR		BIT(11)
+#define WCCR_ADMODE_MASK	GENMASK(10, 8)
+#define WCCR_ADMODE_8LINES	4
+
+#define OSPI_HLCR		0x200
+#define HLCR_WZL		BIT(1)
+#define HLCR_TACC_MASK		GENMASK(15, 8)
+
+#define SYSCFG_DLYBOS_CR		0
+#define DLYBOS_CR_EN			BIT(0)
+#define DLYBOS_CR_RXTAPSEL_SHIFT	1
+#define DLYBOS_CR_RXTAPSEL_MASK		GENMASK(6, 1)
+#define DLYBOS_CR_TXTAPSEL_SHIFT	7
+#define DLYBOS_CR_TXTAPSEL_MASK		GENMASK(12, 7)
+#define DLYBOS_TAPSEL_NB		33
+#define DLYBOS_BYP_EN			BIT(16)
+#define DLYBOS_BYP_CMD_MASK		GENMASK(21, 17)
+
+#define SYSCFG_DLYBOS_SR	4
+#define DLYBOS_SR_LOCK		BIT(0)
+#define DLYBOS_SR_RXTAPSEL_ACK	BIT(1)
+#define DLYBOS_SR_TXTAPSEL_ACK	BIT(2)
+
+#define STM32_OMI_MAX_MMAP_SZ	SZ_256M
+#define STM32_OMI_MAX_NORCHIP	2
+
+#define STM32_FIFO_TIMEOUT_US		30000
+#define STM32_ABT_TIMEOUT_US		100000
+#define STM32_COMP_TIMEOUT_MS		5000
+#define STM32_BUSY_TIMEOUT_US		100000
+#define STM32_DLYB_FREQ_THRESHOLD	50000000
+#define STM32_DLYBOS_TIMEOUT_MS		1000
+#define STM32_DLYBOS_DELAY_NB		24
+
+struct stm32_omi {
+	struct device *dev;
+	struct platform_device *vdev;
+	struct clk *clk;
+	struct reset_control *rstc;
+	struct regmap *regmap;
+
+	struct completion data_completion;
+	struct completion match_completion;
+
+	struct dma_chan *dma_chtx;
+	struct dma_chan *dma_chrx;
+	struct completion dma_completion;
+
+	void __iomem *regs_base;
+	void __iomem *mm_base;
+	phys_addr_t regs_phys_base;
+	resource_size_t mm_size;
+	u32 clk_rate;
+	u32 fmode;
+	u32 dlyb_base;
+	int irq;
+	bool calibration;
+	bool jedec_flash;
+
+	int (*check_transfer)(struct stm32_omi *omi);
+};
+
+struct stm32_tap_window {
+	u8 end;
+	u8 length;
+};
+
+int stm32_omi_abort(struct stm32_omi *omi);
+int stm32_omi_dlyb_init(struct stm32_omi *omi, bool bypass_mode,
+			u16 period_ps);
+int stm32_omi_dlyb_find_tap(struct stm32_omi *omi, bool rx_only,
+			    u8 *window_len);
+int stm32_omi_dlyb_set_cr(struct stm32_omi *omi, u32 dlyb_cr);
+void stm32_omi_dlyb_get_cr(struct stm32_omi *omi, u32 *dlyb_cr);
+void stm32_omi_dlyb_stop(struct stm32_omi *omi);
+void stm32_omi_dma_callback(void *arg);
+void stm32_omi_dma_setup(struct stm32_omi *omi,
+			 struct dma_slave_config *dma_cfg);
+int stm32_omi_tx_poll(struct stm32_omi *omi, u8 *buf, u32 len, bool read);
+int stm32_omi_wait_cmd(struct stm32_omi *omi);
+int stm32_omi_wait_nobusy(struct stm32_omi *omi);
+
+#endif /* __STM32_OMI_H */
diff --git a/include/sound/hdmi-codec.h b/include/sound/hdmi-codec.h
index 48ad33aba..498d21dfd 100644
--- a/include/sound/hdmi-codec.h
+++ b/include/sound/hdmi-codec.h
@@ -123,8 +123,13 @@ struct hdmi_codec_ops {
 /* HDMI codec initalization data */
 struct hdmi_codec_pdata {
 	const struct hdmi_codec_ops *ops;
+	u64 i2s_formats;
 	uint i2s:1;
+	uint no_i2s_playback:1;
+	uint no_i2s_capture:1;
 	uint spdif:1;
+	uint no_spdif_playback:1;
+	uint no_spdif_capture:1;
 	int max_i2s_channels;
 	void *data;
 };
diff --git a/include/uapi/linux/counter.h b/include/uapi/linux/counter.h
index 8ab12d731..a1e2fee92 100644
--- a/include/uapi/linux/counter.h
+++ b/include/uapi/linux/counter.h
@@ -38,7 +38,7 @@ enum counter_scope {
  *
  * For example, if the Count 2 ceiling extension of Counter device 4 is desired,
  * set type equal to COUNTER_COMPONENT_EXTENSION, scope equal to
- * COUNTER_COUNT_SCOPE, parent equal to 2, and id equal to the value provided by
+ * COUNTER_SCOPE_COUNT, parent equal to 2, and id equal to the value provided by
  * the respective /sys/bus/counter/devices/counter4/count2/ceiling_component_id
  * sysfs attribute.
  */
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index dc2aa3d75..6838a7e19 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -1415,7 +1415,9 @@ struct ethtool_ts_info {
 	__u32	tx_types;
 	__u32	tx_reserved[3];
 	__u32	rx_filters;
-	__u32	rx_reserved[3];
+	__s32   phc_index_2nd;
+	__s32   phc_worker;
+	__s32   phc_timestamper;
 };
 
 /*
@@ -2153,4 +2155,10 @@ struct ethtool_link_settings {
 	 * __u32 map_lp_advertising[link_mode_masks_nwords];
 	 */
 };
+
+struct ethtool_clock {
+	__u32   cmd;
+	__s32   phc_index;
+};
+
 #endif /* _UAPI_LINUX_ETHTOOL_H */
diff --git a/include/uapi/linux/ptp_clock.h b/include/uapi/linux/ptp_clock.h
index 1d108d597..bc03da16d 100644
--- a/include/uapi/linux/ptp_clock.h
+++ b/include/uapi/linux/ptp_clock.h
@@ -95,7 +95,9 @@ struct ptp_clock_caps {
 	int cross_timestamping;
 	/* Whether the clock supports adjust phase */
 	int adjust_phase;
-	int rsv[12];   /* Reserved for future use. */
+	/* Whether the clock supports precise cross timestamps with peer clock */
+	int peer_cross_timestamping;
+	int rsv[11];   /* Reserved for future use. */
 };
 
 struct ptp_extts_request {
@@ -104,6 +106,12 @@ struct ptp_extts_request {
 	unsigned int rsv[2]; /* Reserved for future use. */
 };
 
+struct ptp_ptp_offset_precise {
+	struct ptp_clock_time device;
+	struct ptp_clock_time peer;
+	unsigned int rsv[4];    /* Reserved for future use. */
+};
+
 struct ptp_perout_request {
 	union {
 		/*
@@ -223,6 +231,8 @@ struct ptp_pin_desc {
 	_IOWR(PTP_CLK_MAGIC, 17, struct ptp_sys_offset_precise)
 #define PTP_SYS_OFFSET_EXTENDED2 \
 	_IOWR(PTP_CLK_MAGIC, 18, struct ptp_sys_offset_extended)
+#define PTP_PTP_OFFSET_PRECISE \
+	_IOWR(PTP_CLK_MAGIC, 19, struct ptp_ptp_offset_precise)
 
 struct ptp_extts_event {
 	struct ptp_clock_time t; /* Time event occured. */
diff --git a/include/uapi/linux/serial.h b/include/uapi/linux/serial.h
index cea06924b..faa8828ef 100644
--- a/include/uapi/linux/serial.h
+++ b/include/uapi/linux/serial.h
@@ -134,16 +134,18 @@ struct serial_rs485 {
 
 	__u32	delay_rts_before_send;	/* Delay before send (milliseconds) */
 	__u32	delay_rts_after_send;	/* Delay after send (milliseconds) */
+	__u32	delay_rts_before_send_ns;	/* Delay before send (nanoseconds) */
+	__u32	delay_rts_after_send_ns;	/* Delay after send (nanoseconds) */
 
 	/* The fields below are defined by flags */
 	union {
-		__u32	padding[5];		/* Memory is cheap, new structs are a pain */
+		__u32	padding[3];		/* Memory is cheap, new structs are a pain */
 
 		struct {
 			__u8	addr_recv;
 			__u8	addr_dest;
 			__u8	padding0[2];
-			__u32	padding1[4];
+			__u32	padding1[2];
 		};
 	};
 };
diff --git a/include/uapi/linux/stm32-dcmipp-config.h b/include/uapi/linux/stm32-dcmipp-config.h
new file mode 100644
index 000000000..af80b3b3a
--- /dev/null
+++ b/include/uapi/linux/stm32-dcmipp-config.h
@@ -0,0 +1,194 @@
+/* SPDX-License-Identifier: ((GPL-2.0+ WITH Linux-syscall-note) OR MIT) */
+/*
+ * STM32 DCMIPP ISP userspace API
+ * Copyright (C) STMicroelectronics SA 2023
+ */
+
+#ifndef _UAPI_STM32_DCMIPP_CONFIG_H
+#define _UAPI_STM32_DCMIPP_CONFIG_H
+
+#include <linux/types.h>
+
+/* Bad Pixel Removal */
+#define STM32_DCMIPP_ISP_BPR		(1U << 0)
+/* Black Level Correction */
+#define STM32_DCMIPP_ISP_BLC		(1U << 1)
+/* Exposure Control */
+#define STM32_DCMIPP_ISP_EX		(1U << 2)
+/* Demosaicing filters */
+#define STM32_DCMIPP_ISP_DM		(1U << 3)
+/* Color conversion Control */
+#define STM32_DCMIPP_ISP_CC		(1U << 4)
+/* Contrast Enhancement */
+#define STM32_DCMIPP_ISP_CE		(1U << 5)
+
+/**
+ * struct stm32_dcmipp_isp_bpr_cfg - STM32 DCMIPP ISP bad pixel removal
+ *
+ * @en: enable / disable the bad pixel removal block
+ * @strength: strength (aggressiveness) of the bad pixel detection
+ */
+struct stm32_dcmipp_isp_bpr_cfg {
+	__u32 en;
+	__u32 strength;
+};
+
+/**
+ * struct stm32_dcmipp_isp_blc_cfg - STM32 DCMIPP ISP black level correction
+ *
+ * @en: enable / disable the black level correction block
+ * @blc_r: Correction on the red component
+ * @blc_g: Correction on the green component
+ * @blc_b: Correction on the blue component
+ */
+struct stm32_dcmipp_isp_blc_cfg {
+	__u32 en;
+	__u8 blc_r;
+	__u8 blc_g;
+	__u8 blc_b;
+};
+
+/**
+ * struct stm32_dcmipp_isp_ex_cfg - STM32 DCMIPP ISP exposure control
+ *
+ * @en: enable / disable the exposure control block
+ * @shift_r: red component exposure shift
+ * @mult_r: red component exposure multiplier
+ * @shift_g: green component exposure shift
+ * @mult_g: green component exposure multiplier
+ * @shift_b: blue component exposure shift
+ * @mult_b: blue component exposure multiplier
+ */
+struct stm32_dcmipp_isp_ex_cfg {
+	__u32 en;
+	__u8 shift_r;
+	__u8 mult_r;
+	__u8 shift_g;
+	__u8 mult_g;
+	__u8 shift_b;
+	__u8 mult_b;
+};
+
+/**
+ * struct stm32_dcmipp_isp_dm_cfg - STM32 DCMIPP ISP demosaicing filters
+ *
+ * @edge: strength of the edge detection
+ * @lineh: strength of the horizontal line detection
+ * @linev: strength of the vertical line detection
+ * @peak: strength of the peak detection
+ */
+struct stm32_dcmipp_isp_dm_cfg {
+	__u8 edge;
+	__u8 lineh;
+	__u8 linev;
+	__u8 peak;
+};
+
+enum stm32_dcmipp_isp_cc_clamp {
+	STM32_DCMIPP_ISP_CC_CLAMP_DISABLED,
+	STM32_DCMIPP_ISP_CC_CLAMP_Y235_U240_V240,
+	STM32_DCMIPP_ISP_CC_CLAMP_YUV235,
+};
+
+/**
+ * struct stm32_dcmipp_isp_cc_cfg - STM32 DCMIPP ISP color conversion
+ *
+ * @en: enable / disable the color conversion block
+ * @clamp: clamp configuration (from enum stm32_dcmipp_isp_cc_clamp)
+ * @rr: row 1 col 1 value of the matrix
+ * @rg: row 1 col 2 value of the matrix
+ * @rb: row 1 col 3 value of the matrix
+ * @ra: row 1 added value of the matrix
+ * @gr: row 2 col 1 value of the matrix
+ * @gg: row 2 col 2 value of the matrix
+ * @gb: row 2 col 3 value of the matrix
+ * @ga: row 2 added value of the matrix
+ * @br: row 3 col 1 value of the matrix
+ * @bg: row 3 col 2 value of the matrix
+ * @bb: row 3 col 3 value of the matrix
+ * @ba: row 3 added value of the matrix
+ */
+struct stm32_dcmipp_isp_cc_cfg {
+	__u32 en;
+	__u32 clamp;
+	__u16 rr;
+	__u16 rg;
+	__u16 rb;
+	__u16 ra;
+	__u16 gr;
+	__u16 gg;
+	__u16 gb;
+	__u16 ga;
+	__u16 br;
+	__u16 bg;
+	__u16 bb;
+	__u16 ba;
+};
+
+/**
+ * struct stm32_dcmipp_isp_ce_cfg - STM32 DCMIPP ISP contrast enhancement
+ *
+ * @en: enable / disable the contrast enhancement block
+ * @lum: 9 elements table of luminance enhancement (value 16 is neutral)
+ */
+struct stm32_dcmipp_isp_ce_cfg {
+	__u32 en;
+	__u8 lum[9];
+};
+
+/**
+ * struct stm32_dcmipp_isp_ctrls_cfg - STM32 DCMIPP ISP Controls
+ *
+ * @bpr_cfg: configuration of the bad pixel removal block
+ * @blc_cfg: configuration of the black level correction block
+ * @ex_cfg: configuration of the exposure block
+ * @dm_cfg: configuration of the demosaicing filters block
+ * @cc_cfg: configuration of the color conversion block
+ * @ce_cfg: configuration of the contrast enhancement block
+ */
+struct stm32_dcmipp_isp_ctrls_cfg {
+	struct stm32_dcmipp_isp_bpr_cfg bpr_cfg;
+	struct stm32_dcmipp_isp_blc_cfg blc_cfg;
+	struct stm32_dcmipp_isp_ex_cfg ex_cfg;
+	struct stm32_dcmipp_isp_dm_cfg dm_cfg;
+	struct stm32_dcmipp_isp_cc_cfg cc_cfg;
+	struct stm32_dcmipp_isp_ce_cfg ce_cfg;
+};
+
+/**
+ * struct stm32_dcmipp_params_cfg - STM32 DCMIPP ISP Input Parameters Meta Data
+ *
+ * @module_cfg_update: mask the config bits of which module should be updated
+ * @ctrls: configuration of other ISP blocks
+ */
+struct stm32_dcmipp_params_cfg {
+	__u32 module_cfg_update;
+
+	struct stm32_dcmipp_isp_ctrls_cfg ctrls;
+};
+
+/**
+ * struct stm32_dcmipp_stat_avr_bins - average & bins statistics
+ *
+ * @average_rgb[3]: average value of R/G/B components
+ * @bins[12]: 12 values histogram
+ */
+struct stm32_dcmipp_stat_avr_bins {
+	__u32 average_RGB[3];
+	__u32 bins[12];
+};
+
+/**
+ * struct stm32_dcmipp_stat_buf - statistics buffer
+ *
+ * @pre: average & bins statistics at pre-demosaicing location
+ * @post: average & bins statistics at post-demosaicing location
+ * @bad_pixel_count: number of bad pixels detected in the frame
+ */
+struct stm32_dcmipp_stat_buf {
+	struct stm32_dcmipp_stat_avr_bins pre;
+	struct stm32_dcmipp_stat_avr_bins post;
+	__u32 bad_pixel_count;
+};
+
+#endif
diff --git a/include/uapi/linux/v4l2-controls.h b/include/uapi/linux/v4l2-controls.h
index d4a4e3cab..6d8c3103b 100644
--- a/include/uapi/linux/v4l2-controls.h
+++ b/include/uapi/linux/v4l2-controls.h
@@ -1156,6 +1156,47 @@ enum v4l2_jpeg_chroma_subsampling {
 #define V4L2_CID_DEINTERLACING_MODE		(V4L2_CID_IMAGE_PROC_CLASS_BASE + 4)
 #define V4L2_CID_DIGITAL_GAIN			(V4L2_CID_IMAGE_PROC_CLASS_BASE + 5)
 
+#define V4L2_CID_ISP_STAT_REGION		(V4L2_CID_IMAGE_PROC_CLASS_BASE + 10)
+/**
+ * struct v4l2_ctrl_isp_stat_region - Region where ISP statistics are collected
+ *
+ * @nb_regions: number of regions
+ * @top: top coordinate of a region
+ * @left: left coordinate of a region
+ * @width: width of a region
+ * @height: height of a region
+ */
+struct v4l2_ctrl_isp_stat_region {
+	__u8 nb_regions;
+	__u32 top[25];
+	__u32 left[25];
+	__u32 width[25];
+	__u32 height[25];
+};
+
+#define V4L2_CID_ISP_STAT_AVG_FILTER		(V4L2_CID_IMAGE_PROC_CLASS_BASE + 12)
+enum v4l2_isp_stat_avg_filter {
+	V4L2_STAT_AVG_FILTER_NONE	= 0,
+	V4L2_STAT_AVG_FILTER_EXCL16	= 1,
+	V4L2_STAT_AVG_FILTER_EXCL32	= 2,
+	V4L2_STAT_AVG_FILTER_EXCL64	= 3,
+};
+
+#define V4L2_CID_ISP_STAT_BIN_COMP		(V4L2_CID_IMAGE_PROC_CLASS_BASE + 13)
+enum v4l2_isp_stat_bin_comp {
+	V4L2_STAT_BIN_COMP_R		= 0,
+	V4L2_STAT_BIN_COMP_G		= 1,
+	V4L2_STAT_BIN_COMP_B		= 2,
+	V4L2_STAT_BIN_COMP_L		= 3,
+};
+
+#define V4L2_CID_ISP_STAT_PROFILE		(V4L2_CID_IMAGE_PROC_CLASS_BASE + 14)
+enum v4l2_isp_stat_profile {
+	V4L2_STAT_PROFILE_FULL		= 0,
+	V4L2_STAT_PROFILE_AVERAGE_PRE	= 1,
+	V4L2_STAT_PROFILE_AVERAGE_POST	= 2,
+};
+
 /*  DV-class control IDs defined by V4L2 */
 #define V4L2_CID_DV_CLASS_BASE			(V4L2_CTRL_CLASS_DV | 0x900)
 #define V4L2_CID_DV_CLASS			(V4L2_CTRL_CLASS_DV | 1)
@@ -1624,6 +1665,91 @@ struct v4l2_ctrl_h264_decode_params {
 	__u32 flags;
 };
 
+#define V4L2_H264_NAL_CODED_SLICE_NON_IDR_PIC	1
+#define V4L2_H264_NAL_CODED_SLICE_IDR_PIC	5
+
+#define V4L2_CID_STATELESS_H264_ENCODE_PARAMS  (V4L2_CID_CODEC_STATELESS_BASE + 8)
+
+/**
+ * struct v4l2_ctrl_h264_encode_params
+ * @slice_type: selects slice type. Set to one of V4L2_H264_SLICE_TYPE_{}
+ * @pic_parameter_set_id: identifies the picture parameter set that is referred to
+ * in the slice header. The value shall be in the range of 0 to 255, inclusive.
+ * @frame_num: an identifier for pictures.
+ * @idr_pic_id: identifies an IDR picture.
+ * @cabac_init_idc: index for determining the initialization table used in the
+ * initialization process for context variables. The value of cabac_init_idc
+ * shall be in the range of 0 to 2, inclusive.
+ * @disable_deblocking_filter_idc: specifies whether the operation of the
+ * deblocking filter shall be disabled across some block edges of the slice and
+ * specifies for which edges the filtering is disabled.
+ * @slice_alpha_c0_offset_div2: offset used in accessing the alpha and tC0
+ * deblocking filter tables for filtering operations controlled by the macroblocks
+ * within the slice.
+ * @slice_beta_offset_div2: offset used in accessing the beta deblocking filter
+ * table for filtering operations controlled by the macroblocks within the slice.
+ * @slice_size_mb_rows: number of macroblock rows in a slice.
+ * @pic_init_qp_minus26: initial value minus 26 of luma qp for each slice.
+ * @chroma_qp_index_offset: offset that shall be added to qp luma for addressing the
+ * table of qp chroma values for the Cb chroma component.
+ * @flags: combination of V4L2_H264_SLICE_FLAG_{} flags.
+ */
+struct v4l2_ctrl_h264_encode_params {
+	/* Slice parameters */
+
+	__u8 slice_type;
+	__u8 pic_parameter_set_id;
+	__u16 frame_num;
+	__u16 idr_pic_id;
+	__u8 cabac_init_idc;
+	__u8 disable_deblocking_filter_idc;
+	__s8 slice_alpha_c0_offset_div2;
+	__s8 slice_beta_offset_div2;
+
+	__s32 slice_size_mb_rows;
+
+	/* PPS parameters */
+
+	__s8 pic_init_qp_minus26;
+	__s8 chroma_qp_index_offset;
+
+	__u32 flags; /* V4L2_H264_ENCODE_FLAG_ */
+
+	/* Nal parameters */
+	__u8 nal_reference_idc; // 2 bit
+	__u8 nalu_type; // 5 bit
+
+	/* Reference */
+
+	__u64 reference_ts;
+};
+
+#define V4L2_H264_ENCODE_FLAG_ENTROPY_CABAC	       0x01
+#define V4L2_H264_ENCODE_FLAG_TRANSFORM_8X8_MODE       0x02
+#define V4L2_H264_ENCODE_FLAG_CONSTRAINED_INTRA_PRED   0x04
+#define V4L2_H264_ENCODE_FLAG_MARK_LONGTERM            0x08
+
+#define V4L2_CID_STATELESS_H264_ENCODE_RC      (V4L2_CID_CODEC_STATELESS_BASE + 9)
+
+/**
+ * struct v4l2_ctrl_h264_encode_rc
+ *
+ * @qp: quantization parameter for the currently encoded slice
+ *
+ * TODO: other fields likely not needed
+ */
+struct v4l2_ctrl_h264_encode_rc {
+	__u32 qp;
+	__u32 qp_min;
+	__u32 qp_max;
+	__s32 mad_qp_delta;
+	__u32 mad_threshold;
+
+	__u32 cp_distance_mbs;
+	__u32 cp_target[10];
+	__s32 cp_target_error[6];
+	__s32 cp_qp_delta[7];
+};
 
 /* Stateless FWHT control, used by the vicodec driver */
 
@@ -2784,6 +2910,97 @@ struct v4l2_ctrl_vp9_compressed_hdr {
 	struct v4l2_vp9_mv_probs mv;
 };
 
+#define V4L2_CID_STATELESS_VP8_ENCODE_PARAMS	(V4L2_CID_CODEC_STATELESS_BASE + 501)
+
+#define V4L2_VP8_FRAME_FLAG_SHOWFRAME			0x1
+#define V4L2_VP8_FRAME_FLAG_GOLDEN_REFRESH		0x2
+#define V4L2_VP8_FRAME_FLAG_ALTREF_REFRESH		0x4
+#define V4L2_VP8_FRAME_FLAG_SEGMENT_ENABLED		0x8
+#define V4L2_VP8_FRAME_FLAG_LOOP_FILTER_ADJ_ENABLED	0x10
+#define V4L2_VP8_FRAME_FLAG_REFRESH_ENTROPY_PROBS	0x20
+
+#define V4L2_VP8_FRAME_TYPE_KEYFRAME	0
+#define V4L2_VP8_FRAME_TYPE_INTER	1
+
+#define V4L2_VP8_FRAME_COLOR_SPACE_YUV		0
+#define V4L2_VP8_FRAME_COLOR_SPACE_RESERVED	1
+
+#define V4L2_VP8_FRAME_CLAMPING_REQUIRED	0
+#define V4L2_VP8_FRAME_CLAMPING_NO		1
+
+#define V4L2_VP8_FRAME_FILTER_TYPE_NORMAL	0
+#define V4L2_VP8_FRAME_FILTER_TYPE_SIMPLE	1
+
+#define V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_1	0
+#define V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_2	1
+#define V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_4	2
+#define V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_8	3
+
+#define V4L2_VP8_FRAME_GOLDEN_KEEP		0
+#define V4L2_VP8_FRAME_GOLDEN_LASTFRAME		1
+#define V4L2_VP8_FRAME_GOLDEN_ALTREF		2
+
+#define V4L2_VP8_FRAME_ALTREF_KEEP		0
+#define V4L2_VP8_FRAME_ALTREF_LASTFRAME		1
+#define V4L2_VP8_FRAME_ALTREF_GOLDEN		2
+
+#define V4L2_VP8_FRAME_REF_LAST		0
+#define V4L2_VP8_FRAME_REF_GOLDEN	1
+#define V4L2_VP8_FRAME_REF_ALT		2
+
+/**
+ * struct v4l2_ctrl_vp8_encode_params - VP8 encode parameters
+ * @flags: combination of V4L2_VP8_FRAME_FLAG_{} flags.
+ * @frame_type: specifies the frame type (key or inter).
+ *		Set to one of V4L2_VP8_FRAME_TYPE_{}.
+ * @color_space: defines the YUV color space of the sequence.
+ *		 V4L2_VP8_FRAME_TYPE_INTER frames shall set this field to zero.
+ *		 Set to one of V4L2_VP8_FRAME_COLOR_SPACE_{}.
+ * @clamping_type: defines pixel value clamping type.
+ *		   V4L2_VP8_FRAME_TYPE_INTER frames shall set this field to zero.
+ *		   Set to one of V4L2_VP8_FRAME_CLAMPING_{}.
+ * @loop_filter_type: selects the type of loop filter applied.
+ *		      Set to one of V4L2_VP8_FRAME_FILTER_TYPE_{}.
+ * @loop_filter_level: sets the strength of the applied loop filter.
+ *		       Set to a value from the rage 0..63.
+ * @sharpness_level: sets the sharpness of the applied loop filter.
+ *		     Set to a value from the range 0..7.
+ * @log2_nbr_of_dct_partitions: determines the number of separate partitions
+ *				containing the DCT coefficients of macroblocks.
+ *				Set to one of V4L2_VP8_FRAME_NBR_DCT_PARTITIONS_{}.
+ * @prob_intra: indicates the probability of an intra macroblock.
+ *		Set to a value from the range 0..255.
+ * @prob_last: indicates the probability that the last reference frame is used for inter-prediction.
+ *	       Set to a value from the range 0..255.
+ * @prob_gf: indicates the probability that the golden reference frame is used for inter-prediction.
+ *	     Set to a value from the range 0..255.
+ * @copy_buffer_to_golden: specifies the golden frame refresh strategy.
+ *			   Set to one of V4L2_VP8_FRAME_FLAG_GOLDEN_{}.
+ * @copy_buffer_to_alternate: specifies the atlref frame refresh strategy.
+ *			      Set to one of V4L2_VP8_FRAME_FLAG_ALTREF_{}.
+ * @reference_type: specifies what kind of reference to use for current inter frame.
+ *		    V4L2_VP8_FRAME_TYPE_KEYFRAME shall set this field to zero.
+ *		    Set to one of V4L2_VP8_FRAME_REF_{}.
+ */
+struct v4l2_ctrl_vp8_encode_params {
+	__u32 flags;
+	__u8 frame_type;
+	__u8 color_space;
+	__u8 clamping_type;
+	__u8 loop_filter_type;
+	__u8 loop_filter_level;
+	__u8 sharpness_level;
+	__u8 log2_nbr_of_dct_partitions;
+	__u8 prob_intra;
+	__u8 prob_last;
+	__u8 prob_gf;
+	__u8 copy_buffer_to_golden;
+	__u8 copy_buffer_to_alternate;
+	__u8 reference_type;
+};
+
+#define V4L2_CID_STATELESS_VP8_ENCODE_QP	(V4L2_CID_CODEC_STATELESS_BASE + 502)
+
 /* MPEG-compression definitions kept for backwards compatibility */
 #ifndef __KERNEL__
 #define V4L2_CTRL_CLASS_MPEG            V4L2_CTRL_CLASS_CODEC
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index 45fa03882..52eb7ad52 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -809,6 +809,10 @@ struct v4l2_pix_format {
 #define V4L2_META_FMT_RK_ISP1_PARAMS	v4l2_fourcc('R', 'K', '1', 'P') /* Rockchip ISP1 3A Parameters */
 #define V4L2_META_FMT_RK_ISP1_STAT_3A	v4l2_fourcc('R', 'K', '1', 'S') /* Rockchip ISP1 3A Statistics */
 
+/* Vendor specific - used for STM32_DCMIPP camera sub-system */
+#define V4L2_META_FMT_ST_DCMIPP_ISP_PARAMS	v4l2_fourcc('S', 'T', 'I', 'P') /* STM32 DCMIPP ISP Parameters */
+#define V4L2_META_FMT_ST_DCMIPP_ISP_STAT	v4l2_fourcc('S', 'T', 'I', 'S') /* STM32 DCMIPP ISP Statistics */
+
 /* priv field value to indicates that subsequent fields are valid. */
 #define V4L2_PIX_FMT_PRIV_MAGIC		0xfeedcafe
 
@@ -1799,6 +1803,7 @@ struct v4l2_ext_control {
 		struct v4l2_ctrl_hevc_slice_params __user *p_hevc_slice_params;
 		struct v4l2_ctrl_hevc_scaling_matrix __user *p_hevc_scaling_matrix;
 		struct v4l2_ctrl_hevc_decode_params __user *p_hevc_decode_params;
+		struct v4l2_ctrl_vp8_encode_params __user *p_vp8_encode_params;
 		void __user *ptr;
 	};
 } __attribute__ ((packed));
@@ -1855,9 +1860,10 @@ enum v4l2_ctrl_type {
 	V4L2_CTRL_TYPE_H264_SLICE_PARAMS    = 0x0203,
 	V4L2_CTRL_TYPE_H264_DECODE_PARAMS   = 0x0204,
 	V4L2_CTRL_TYPE_H264_PRED_WEIGHTS    = 0x0205,
+	V4L2_CTRL_TYPE_H264_ENCODE_PARAMS   = 0x0210,
+	V4L2_CTRL_TYPE_H264_ENCODE_RC       = 0x0211,
 
 	V4L2_CTRL_TYPE_FWHT_PARAMS	    = 0x0220,
-
 	V4L2_CTRL_TYPE_VP8_FRAME            = 0x0240,
 
 	V4L2_CTRL_TYPE_MPEG2_QUANTISATION   = 0x0250,
@@ -1872,6 +1878,10 @@ enum v4l2_ctrl_type {
 	V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS	= 0x0272,
 	V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX	= 0x0273,
 	V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS	= 0x0274,
+
+	V4L2_CTRL_TYPE_VP8_ENCODE_PARAMS	= 0x0280,
+
+	V4L2_CTRL_TYPE_ISP_STAT_REGION     = 0x0310,
 };
 
 /*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index fa3bf161d..844789e34 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -34,7 +34,6 @@
 #include "power.h"
 
 const char * const pm_labels[] = {
-	[PM_SUSPEND_TO_IDLE] = "freeze",
 	[PM_SUSPEND_STANDBY] = "standby",
 	[PM_SUSPEND_MEM] = "mem",
 };
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index 566adf85e..7fca28502 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -547,6 +547,10 @@ int __ethtool_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)
 
 	memset(info, 0, sizeof(*info));
 	info->cmd = ETHTOOL_GET_TS_INFO;
+	info->phc_index       = -1;
+	info->phc_index_2nd   = -1;
+	info->phc_worker      = -1;
+	info->phc_timestamper = -1;
 
 	if (phy_has_tsinfo(phydev))
 		return phy_ts_info(phydev, info);
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 3aa384cec..f9425aa85 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -245,7 +245,7 @@ ld_flags       = $(KBUILD_LDFLAGS) $(ldflags-y) $(LDFLAGS_$(@F))
 DTC_INCLUDE    := $(srctree)/scripts/dtc/include-prefixes
 
 dtc_cpp_flags  = -Wp,-MMD,$(depfile).pre.tmp -nostdinc                    \
-		 $(addprefix -I,$(DTC_INCLUDE))                          \
+		 $(addprefix -I,$(DTC_INCLUDE) $(DTS_INCLUDE))            \
 		 -undef -D__DTS__
 
 ifdef CONFIG_OBJTOOL
@@ -334,7 +334,8 @@ quiet_cmd_gzip = GZIP    $@
 # DTC
 # ---------------------------------------------------------------------------
 DTC ?= $(objtree)/scripts/dtc/dtc
-DTC_FLAGS += -Wno-interrupt_provider
+DTC_FLAGS += -Wno-interrupt_provider \
+	-Wno-unique_unit_address
 
 # Disable noisy checks by default
 ifeq ($(findstring 1,$(KBUILD_EXTRA_WARN)),)
@@ -342,14 +343,17 @@ DTC_FLAGS += -Wno-unit_address_vs_reg \
 	-Wno-avoid_unnecessary_addr_size \
 	-Wno-alias_paths \
 	-Wno-graph_child_address \
-	-Wno-simple_bus_reg \
-	-Wno-unique_unit_address
+	-Wno-simple_bus_reg
+else
+DTC_FLAGS += \
+        -Wunique_unit_address_if_enabled
 endif
 
 ifneq ($(findstring 2,$(KBUILD_EXTRA_WARN)),)
 DTC_FLAGS += -Wnode_name_chars_strict \
 	-Wproperty_name_chars_strict \
-	-Winterrupt_provider
+	-Winterrupt_provider \
+	-Wunique_unit_address
 endif
 
 DTC_FLAGS += $(DTC_FLAGS_$(basetarget))
@@ -375,6 +379,10 @@ cmd_dt_S_dtb=						\
 $(obj)/%.dtb.S: $(obj)/%.dtb FORCE
 	$(call if_changed,dt_S_dtb)
 
+ifeq ($(CONFIG_OF_OVERLAY),y)
+DTC_FLAGS += -@
+endif
+
 quiet_cmd_dtc = DTC     $@
 cmd_dtc = $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
 	$(DTC) -o $@ -b 0 \
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index ecf4250b0..b8fded247 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -3405,9 +3405,10 @@ sub process {
 # Check for various typo / spelling mistakes
 		if (defined($misspellings) &&
 		    ($in_commit_log || $line =~ /^(?:\+|Subject:)/i)) {
-			while ($rawline =~ /(?:^|[^\w\-'`])($misspellings)(?:[^\w\-'`]|$)/gi) {
+			my $rawline_utf8 = decode("utf8", $rawline);
+			while ($rawline_utf8 =~ /(?:^|[^\w\-'`])($misspellings)(?:[^\w\-'`]|$)/gi) {
 				my $typo = $1;
-				my $blank = copy_spacing($rawline);
+				my $blank = copy_spacing($rawline_utf8);
 				my $ptr = substr($blank, 0, $-[1]) . "^" x length($typo);
 				my $hereptr = "$hereline$ptr\n";
 				my $typo_fix = $spelling_fix{lc($typo)};
@@ -3693,7 +3694,7 @@ sub process {
 						     "'$spdx_license' is not supported in LICENSES/...\n" . $herecurr);
 					}
 					if ($realfile =~ m@^Documentation/devicetree/bindings/@ &&
-					    not $spdx_license =~ /GPL-2\.0.*BSD-2-Clause/) {
+					    $spdx_license !~ /GPL-2\.0(?:-only)? OR BSD-2-Clause/) {
 						my $msg_level = \&WARN;
 						$msg_level = \&CHK if ($file);
 						if (&{$msg_level}("SPDX_LICENSE_TAG",
@@ -3703,6 +3704,11 @@ sub process {
 							$fixed[$fixlinenr] =~ s/SPDX-License-Identifier: .*/SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)/;
 						}
 					}
+					if ($realfile =~ m@^include/dt-bindings/@ &&
+					    $spdx_license !~ /GPL-2\.0(?:-only)? OR \S+/) {
+						WARN("SPDX_LICENSE_TAG",
+						     "DT binding headers should be licensed (GPL-2.0-only OR .*)\n" . $herecurr);
+					}
 				}
 			}
 		}
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 0904827e2..496dddac6 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -1981,7 +1981,7 @@ config SND_SOC_WM8993
 	depends on I2C
 
 config SND_SOC_WM8994
-	tristate
+	tristate "Wolfson Microelectronics WM8994 codec"
 
 config SND_SOC_WM8995
 	tristate
diff --git a/sound/soc/codecs/hdmi-codec.c b/sound/soc/codecs/hdmi-codec.c
index d8259afc6..5c9c8c3f7 100644
--- a/sound/soc/codecs/hdmi-codec.c
+++ b/sound/soc/codecs/hdmi-codec.c
@@ -428,8 +428,13 @@ static int hdmi_codec_startup(struct snd_pcm_substream *substream,
 {
 	struct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	bool has_capture = !hcp->hcd.no_i2s_capture;
+	bool has_playback = !hcp->hcd.no_i2s_playback;
 	int ret = 0;
 
+	if (!((has_playback && tx) || (has_capture && !tx)))
+		return 0;
+
 	mutex_lock(&hcp->lock);
 	if (hcp->busy) {
 		dev_err(dai->dev, "Only one simultaneous stream supported!\n");
@@ -468,6 +473,12 @@ static void hdmi_codec_shutdown(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
 	struct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);
+	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	bool has_capture = !hcp->hcd.no_i2s_capture;
+	bool has_playback = !hcp->hcd.no_i2s_playback;
+
+	if (!((has_playback && tx) || (has_capture && !tx)))
+		return;
 
 	hcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;
 	hcp->hcd.ops->audio_shutdown(dai->dev->parent, hcp->hcd.data);
@@ -816,12 +827,19 @@ static int hdmi_dai_probe(struct snd_soc_dai *dai)
 			.source = "RX",
 		},
 	};
-	int ret;
+	int ret, i;
 
 	dapm = snd_soc_component_get_dapm(dai->component);
-	ret = snd_soc_dapm_add_routes(dapm, route, 2);
-	if (ret)
-		return ret;
+
+	/* One of the directions might be omitted for unidirectional DAIs */
+	for (i = 0; i < ARRAY_SIZE(route); i++) {
+		if (!route[i].source || !route[i].sink)
+			continue;
+
+		ret = snd_soc_dapm_add_routes(dapm, &route[i], 1);
+		if (ret)
+			return ret;
+	}
 
 	daifmt = devm_kzalloc(dai->dev, sizeof(*daifmt), GFP_KERNEL);
 	if (!daifmt)
@@ -1028,11 +1046,28 @@ static int hdmi_codec_probe(struct platform_device *pdev)
 	if (hcd->i2s) {
 		daidrv[i] = hdmi_i2s_dai;
 		daidrv[i].playback.channels_max = hcd->max_i2s_channels;
+		if (hcd->i2s_formats) {
+			daidrv[i].playback.formats = hcd->i2s_formats;
+			daidrv[i].capture.formats = hcd->i2s_formats;
+		}
+		if (hcd->no_i2s_playback)
+			memset(&daidrv[i].playback, 0,
+			       sizeof(daidrv[i].playback));
+		if (hcd->no_i2s_capture)
+			memset(&daidrv[i].capture, 0,
+			       sizeof(daidrv[i].capture));
 		i++;
 	}
 
-	if (hcd->spdif)
+	if (hcd->spdif) {
 		daidrv[i] = hdmi_spdif_dai;
+		if (hcd->no_spdif_playback)
+			memset(&daidrv[i].playback, 0,
+			       sizeof(daidrv[i].playback));
+		if (hcd->no_spdif_capture)
+			memset(&daidrv[i].capture, 0,
+			       sizeof(daidrv[i].capture));
+	}
 
 	dev_set_drvdata(dev, hcp);
 
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 8fe9a75d1..07eb1377a 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -7,6 +7,7 @@
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  */
 
+#include <linux/clk.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -838,6 +839,37 @@ static int clk_sys_event(struct snd_soc_dapm_widget *w,
 	return 0;
 }
 
+static int mclk_event(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);
+	struct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(comp);
+	int ret, mclk_id = 0;
+
+	if (!strncmp(w->name, "MCLK2", 5))
+		mclk_id = 1;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		dev_dbg(comp->dev, "Enable master clock %s\n",
+			mclk_id ? "MCLK2" : "MCLK1");
+
+		ret = clk_prepare_enable(wm8994->mclk[mclk_id].clk);
+		if (ret < 0) {
+			dev_err(comp->dev, "Failed to enable clock: %d\n", ret);
+			return ret;
+		}
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		dev_dbg(comp->dev, "Disable master clock %s\n",
+			mclk_id ? "MCLK2" : "MCLK1");
+		clk_disable_unprepare(wm8994->mclk[mclk_id].clk);
+		break;
+	}
+
+	return 0;
+}
+
 static void vmid_reference(struct snd_soc_component *component)
 {
 	struct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);
@@ -1225,7 +1257,6 @@ static int aif2clk_ev(struct snd_soc_dapm_widget *w,
 		else
 			adc = WM8994_AIF2ADCL_ENA | WM8994_AIF2ADCR_ENA;
 
-
 		val = snd_soc_component_read(component, WM8994_AIF2_CONTROL_2);
 		if ((val & WM8994_AIF2DACL_SRC) &&
 		    (val & WM8994_AIF2DACR_SRC))
@@ -1847,6 +1878,16 @@ static const struct snd_soc_dapm_widget wm8994_specific_dapm_widgets[] = {
 SND_SOC_DAPM_MUX("AIF3ADC Mux", SND_SOC_NOPM, 0, 0, &wm8994_aif3adc_mux),
 };
 
+static const struct snd_soc_dapm_widget wm8994_mclk1_dapm_widgets[] = {
+SND_SOC_DAPM_SUPPLY("MCLK1", SND_SOC_NOPM, 0, 0, mclk_event,
+		    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_widget wm8994_mclk2_dapm_widgets[] = {
+SND_SOC_DAPM_SUPPLY("MCLK2", SND_SOC_NOPM, 0, 0, mclk_event,
+		    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
 static const struct snd_soc_dapm_widget wm8958_dapm_widgets[] = {
 SND_SOC_DAPM_SUPPLY("AIF3", WM8994_POWER_MANAGEMENT_6, 5, 1, NULL, 0),
 SND_SOC_DAPM_MUX("Mono PCM Out Mux", SND_SOC_NOPM, 0, 0, &mono_pcm_out_mux),
@@ -2071,10 +2112,10 @@ static const struct snd_soc_dapm_route wm8994_lateclk_intercon[] = {
 };
 
 static const struct snd_soc_dapm_route wm8994_revd_intercon[] = {
-	{ "AIF1DACDAT", NULL, "AIF2DACDAT" },
-	{ "AIF2DACDAT", NULL, "AIF1DACDAT" },
-	{ "AIF1ADCDAT", NULL, "AIF2ADCDAT" },
-	{ "AIF2ADCDAT", NULL, "AIF1ADCDAT" },
+//	{ "AIF1DACDAT", NULL, "AIF2DACDAT" },
+//	{ "AIF2DACDAT", NULL, "AIF1DACDAT" },
+//	{ "AIF1ADCDAT", NULL, "AIF2ADCDAT" },
+//	{ "AIF2ADCDAT", NULL, "AIF1ADCDAT" },
 	{ "MICBIAS1", NULL, "CLK_SYS" },
 	{ "MICBIAS1", NULL, "MICBIAS Supply" },
 	{ "MICBIAS2", NULL, "CLK_SYS" },
@@ -2506,11 +2547,24 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 {
 	struct snd_soc_component *component = dai->component;
 	struct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);
-	int ret, i;
+	int i, ret;
 
+	/*
+	 * Simple card provides unconditionnaly clock_id = 0.
+	 * Workaround to select master clock for aif1/2
+	 */
 	switch (dai->id) {
 	case 1:
+		if (wm8994->mclk[0].clk)
+			clk_id = WM8994_SYSCLK_MCLK1;
+		else if (wm8994->mclk[1].clk)
+			clk_id = WM8994_SYSCLK_MCLK2;
+		break;
 	case 2:
+		if (wm8994->mclk[1].clk)
+			clk_id = WM8994_SYSCLK_MCLK2;
+		else if (wm8994->mclk[0].clk)
+			clk_id = WM8994_SYSCLK_MCLK1;
 		break;
 
 	default:
@@ -2522,6 +2576,10 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 	case WM8994_SYSCLK_MCLK1:
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK1;
 
+		/* Avoid busy error on exclusive rate change request */
+		if (!freq)
+			break;
+
 		ret = wm8994_set_mclk_rate(wm8994, dai->id - 1, &freq);
 		if (ret < 0)
 			return ret;
@@ -2535,6 +2593,9 @@ static int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,
 		/* TODO: Set GPIO AF */
 		wm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK2;
 
+		if (!freq)
+			break;
+
 		ret = wm8994_set_mclk_rate(wm8994, dai->id - 1, &freq);
 		if (ret < 0)
 			return ret;
@@ -4443,6 +4504,14 @@ static int wm8994_component_probe(struct snd_soc_component *component)
 					       ARRAY_SIZE(wm8994_snd_controls));
 		snd_soc_dapm_new_controls(dapm, wm8994_specific_dapm_widgets,
 					  ARRAY_SIZE(wm8994_specific_dapm_widgets));
+		if (wm8994->mclk[0].clk)
+			snd_soc_dapm_new_controls(dapm, wm8994_mclk1_dapm_widgets,
+						  ARRAY_SIZE(wm8994_mclk1_dapm_widgets));
+
+		if (wm8994->mclk[1].clk)
+			snd_soc_dapm_new_controls(dapm, wm8994_mclk2_dapm_widgets,
+						  ARRAY_SIZE(wm8994_mclk2_dapm_widgets));
+
 		if (control->revision < 4) {
 			snd_soc_dapm_new_controls(dapm, wm8994_lateclk_revd_widgets,
 						  ARRAY_SIZE(wm8994_lateclk_revd_widgets));
diff --git a/sound/soc/stm/Kconfig b/sound/soc/stm/Kconfig
index da1f7a166..28436fcb5 100644
--- a/sound/soc/stm/Kconfig
+++ b/sound/soc/stm/Kconfig
@@ -44,4 +44,17 @@ config SND_SOC_STM32_DFSDM
 	  Select this option to enable the STM32 Digital Filter
 	  for Sigma Delta Modulators (DFSDM) driver used
 	  in various STM32 series for digital microphone capture.
+
+config SND_SOC_STM32_MDF
+	tristate "SoC Audio support for STM32 MDF"
+	depends on ARCH_STM32 || COMPILE_TEST
+	depends on SND_SOC
+	depends on STM32_MDF_ADC
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select SND_SOC_DMIC
+	select IIO_BUFFER_CB
+	help
+	  Select this option to enable the STM32 Multi-function
+	  Digital Filter (MDF) driver used in STM32MP2 series for
+	  digital microphone capture.
 endmenu
diff --git a/sound/soc/stm/Makefile b/sound/soc/stm/Makefile
index 3143c0b47..9ab9c9b42 100644
--- a/sound/soc/stm/Makefile
+++ b/sound/soc/stm/Makefile
@@ -16,3 +16,6 @@ obj-$(CONFIG_SND_SOC_STM32_SPDIFRX) += snd-soc-stm32-spdifrx.o
 
 #DFSDM
 obj-$(CONFIG_SND_SOC_STM32_DFSDM) += stm32_adfsdm.o
+
+#MDF
+obj-$(CONFIG_SND_SOC_STM32_MDF) += stm32_amdf.o
diff --git a/sound/soc/stm/stm32_amdf.c b/sound/soc/stm/stm32_amdf.c
new file mode 100644
index 000000000..ea94014a6
--- /dev/null
+++ b/sound/soc/stm/stm32_amdf.c
@@ -0,0 +1,386 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * This file is part of STM32 MDF ASoC DAI driver
+ *
+ * Copyright (C) 2023, STMicroelectronics.
+ * Author: Olivier Moysan <olivier.moysan@foss.st.com>.
+ */
+
+#include <linux/clk.h>
+#include <linux/iio/adc/stm32-mdf-adc.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/iio.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+
+#include <sound/pcm.h>
+#include <sound/soc.h>
+
+#define STM32_AMDF_DRV_NAME "stm32-amdf"
+
+#define MDF_MAX_PERIOD_SIZE	(PAGE_SIZE / 2)
+#define MDF_MAX_PERIODS	6
+
+struct stm32_amdf_priv {
+	struct snd_soc_dai_driver dai_drv;
+	struct snd_pcm_substream *substream;
+	struct device *dev;
+
+	/* IIO */
+	struct iio_channel *iio_ch;
+	struct iio_cb_buffer *iio_cb;
+	bool iio_active;
+
+	/* PCM buffer */
+	unsigned char *pcm_buff;
+	unsigned int pos;
+
+	struct mutex lock; /* protect against race condition on iio state */
+};
+
+static const struct snd_pcm_hardware stm32_amdf_pcm_hw = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_PAUSE,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,
+
+	.channels_min = 1,
+	.channels_max = 1,
+
+	.periods_min = 2,
+	.periods_max = MDF_MAX_PERIODS,
+
+	.period_bytes_max = MDF_MAX_PERIOD_SIZE,
+	.buffer_bytes_max = MDF_MAX_PERIODS * MDF_MAX_PERIOD_SIZE
+};
+
+static void stm32_amdf_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct stm32_amdf_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+	mutex_lock(&priv->lock);
+	if (priv->iio_active) {
+		iio_channel_stop_all_cb(priv->iio_cb);
+		priv->iio_active = false;
+	}
+	mutex_unlock(&priv->lock);
+}
+
+static int stm32_amdf_dai_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct stm32_amdf_priv *priv = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	mutex_lock(&priv->lock);
+	if (priv->iio_active) {
+		iio_channel_stop_all_cb(priv->iio_cb);
+		priv->iio_active = false;
+	}
+
+	ret = iio_write_channel_attribute(priv->iio_ch,
+					  substream->runtime->rate, 0,
+					  IIO_CHAN_INFO_SAMP_FREQ);
+	if (ret < 0) {
+		dev_err(dai->dev, "%s: Failed to set %d sampling rate\n",
+			__func__, substream->runtime->rate);
+		goto out;
+	}
+
+	if (!priv->iio_active) {
+		ret = iio_channel_start_all_cb(priv->iio_cb);
+		if (!ret)
+			priv->iio_active = true;
+		else
+			dev_err(dai->dev, "%s: IIO channel start failed (%d)\n",
+				__func__, ret);
+	}
+
+out:
+	mutex_unlock(&priv->lock);
+
+	return ret;
+}
+
+static const struct snd_soc_dai_ops stm32_amdf_dai_ops = {
+	.shutdown = stm32_amdf_shutdown,
+	.prepare = stm32_amdf_dai_prepare,
+};
+
+static const struct snd_soc_dai_driver stm32_amdf_dai = {
+	.capture = {
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .formats = SNDRV_PCM_FMTBIT_S16_LE |
+			       SNDRV_PCM_FMTBIT_S32_LE,
+		    .rates = SNDRV_PCM_RATE_CONTINUOUS,
+		    .rate_min = 8000,
+		    .rate_max = 48000,
+		    },
+	.ops = &stm32_amdf_dai_ops,
+};
+
+static const struct snd_soc_component_driver stm32_amdf_dai_component = {
+	.name = "stm32_mdf_audio",
+};
+
+static void stm32_memcpy_32to16(void *dest, const void *src, size_t n)
+{
+	unsigned int i = 0;
+	u16 *d = (u16 *)dest, *s = (u16 *)src;
+
+	s++;
+	for (i = n >> 1; i > 0; i--) {
+		*d++ = *s++;
+		s++;
+	}
+}
+
+static int stm32_afsdm_pcm_cb(const void *data, size_t size, void *private)
+{
+	struct stm32_amdf_priv *priv = private;
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(priv->substream);
+	u8 *pcm_buff = priv->pcm_buff;
+	u8 *src_buff = (u8 *)data;
+	unsigned int old_pos = priv->pos;
+	size_t buff_size = snd_pcm_lib_buffer_bytes(priv->substream);
+	size_t period_size = snd_pcm_lib_period_bytes(priv->substream);
+	size_t cur_size, src_size = size;
+	snd_pcm_format_t format = priv->substream->runtime->format;
+
+	if (format == SNDRV_PCM_FORMAT_S16_LE)
+		src_size >>= 1;
+	cur_size = src_size;
+
+	dev_dbg(rtd->dev, "%s: buff_add :%pK, pos = %d, size = %zu\n",
+		__func__, &pcm_buff[priv->pos], priv->pos, src_size);
+
+	if ((priv->pos + src_size) > buff_size) {
+		if (format == SNDRV_PCM_FORMAT_S16_LE)
+			stm32_memcpy_32to16(&pcm_buff[priv->pos], src_buff, buff_size - priv->pos);
+		else
+			memcpy(&pcm_buff[priv->pos], src_buff, buff_size - priv->pos);
+		cur_size -= buff_size - priv->pos;
+		priv->pos = 0;
+	}
+
+	if (format == SNDRV_PCM_FORMAT_S16_LE)
+		stm32_memcpy_32to16(&pcm_buff[priv->pos], &src_buff[src_size - cur_size], cur_size);
+	else
+		memcpy(&pcm_buff[priv->pos], &src_buff[src_size - cur_size], cur_size);
+
+	priv->pos = (priv->pos + cur_size) % buff_size;
+
+	if (cur_size != src_size || (old_pos && (old_pos % period_size < size)))
+		snd_pcm_period_elapsed(priv->substream);
+
+	return 0;
+}
+
+static int stm32_amdf_trigger(struct snd_soc_component *component,
+			      struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct stm32_amdf_priv *priv =
+		snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		priv->pos = 0;
+		return stm32_mdf_get_buff_cb(priv->iio_ch->indio_dev, stm32_afsdm_pcm_cb, priv);
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+		return stm32_mdf_release_buff_cb(priv->iio_ch->indio_dev);
+	}
+
+	return -EINVAL;
+}
+
+static int stm32_amdf_pcm_open(struct snd_soc_component *component,
+			       struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct stm32_amdf_priv *priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+	int ret;
+
+	ret =  snd_soc_set_runtime_hwparams(substream, &stm32_amdf_pcm_hw);
+	if (!ret)
+		priv->substream = substream;
+
+	return ret;
+}
+
+static int stm32_amdf_pcm_close(struct snd_soc_component *component,
+				struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct stm32_amdf_priv *priv =
+		snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+
+	priv->substream = NULL;
+
+	return 0;
+}
+
+static snd_pcm_uframes_t stm32_amdf_pcm_pointer(struct snd_soc_component *component,
+						struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct stm32_amdf_priv *priv =
+		snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+
+	return bytes_to_frames(substream->runtime, priv->pos);
+}
+
+static int stm32_amdf_pcm_hw_params(struct snd_soc_component *component,
+				    struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct stm32_amdf_priv *priv =
+		snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+
+	priv->pcm_buff = substream->runtime->dma_area;
+
+	return iio_channel_cb_set_buffer_watermark(priv->iio_cb,
+						   params_period_size(params));
+}
+
+static int stm32_amdf_pcm_new(struct snd_soc_component *component,
+			      struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_pcm *pcm = rtd->pcm;
+	struct stm32_amdf_priv *priv =
+		snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+	unsigned int size = MDF_MAX_PERIODS * MDF_MAX_PERIOD_SIZE;
+
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
+				       priv->dev, size, size);
+
+	return 0;
+}
+
+static int stm32_amdf_dummy_cb(const void *data, void *private)
+{
+	/*
+	 * This dummy callback is requested by iio_channel_get_all_cb() API,
+	 * but the stm32_mdf_get_buff_cb() API is used instead, to optimize
+	 * DMA transfers.
+	 */
+	return 0;
+}
+
+static void stm32_amdf_cleanup(void *data)
+{
+	iio_channel_release_all_cb(data);
+}
+
+static const struct snd_soc_component_driver stm32_amdf_soc_platform = {
+	.open		= stm32_amdf_pcm_open,
+	.close		= stm32_amdf_pcm_close,
+	.hw_params	= stm32_amdf_pcm_hw_params,
+	.trigger	= stm32_amdf_trigger,
+	.pointer	= stm32_amdf_pcm_pointer,
+	.pcm_construct	= stm32_amdf_pcm_new,
+};
+
+static const struct of_device_id stm32_amdf_of_match[] = {
+	{.compatible = "st,stm32mp25-mdf-dai"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, stm32_amdf_of_match);
+
+static int stm32_amdf_probe(struct platform_device *pdev)
+{
+	struct stm32_amdf_priv *priv;
+	struct snd_soc_component *component;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &pdev->dev;
+	priv->dai_drv = stm32_amdf_dai;
+	priv->dai_drv.name = dev_name(&pdev->dev);
+	mutex_init(&priv->lock);
+
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &stm32_amdf_dai_component,
+					      &priv->dai_drv, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register %s\n", stm32_amdf_dai_component.name);
+		return ret;
+	}
+
+	/* Associate iio channel */
+	priv->iio_ch  = devm_iio_channel_get_all(&pdev->dev);
+	if (IS_ERR(priv->iio_ch)) {
+		dev_err(&pdev->dev, "Failed to get IIO channels %ld\n", PTR_ERR(priv->iio_ch));
+		return PTR_ERR(priv->iio_ch);
+	}
+
+	priv->iio_cb = iio_channel_get_all_cb(&pdev->dev, &stm32_amdf_dummy_cb, NULL);
+	if (IS_ERR(priv->iio_cb)) {
+		dev_err(&pdev->dev, "Failed to get IIO callbacks %ld\n", PTR_ERR(priv->iio_cb));
+		return PTR_ERR(priv->iio_cb);
+	}
+
+	ret = devm_add_action_or_reset(&pdev->dev, stm32_amdf_cleanup, priv->iio_cb);
+	if (ret < 0)  {
+		dev_err(&pdev->dev, "Unable to add action\n");
+		return ret;
+	}
+
+	component = devm_kzalloc(&pdev->dev, sizeof(*component), GFP_KERNEL);
+	if (!component)
+		return -ENOMEM;
+
+	ret = snd_soc_component_initialize(component, &stm32_amdf_soc_platform, &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to initialize mdf component %d\n", ret);
+		return ret;
+	}
+#ifdef CONFIG_DEBUG_FS
+	component->debugfs_prefix = "pcm";
+#endif
+
+	ret = snd_soc_add_component(component, NULL, 0);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register PCM platform\n");
+		return ret;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	return ret;
+}
+
+static int stm32_amdf_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver stm32_amdf_driver = {
+	.driver = {
+		   .name = STM32_AMDF_DRV_NAME,
+		   .of_match_table = stm32_amdf_of_match,
+		   },
+	.probe = stm32_amdf_probe,
+	.remove = stm32_amdf_remove,
+};
+
+module_platform_driver(stm32_amdf_driver);
+
+MODULE_DESCRIPTION("stm32 MDF DAI driver");
+MODULE_AUTHOR("Olivier Moysan <olivier.moysan@foss.st.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" STM32_AMDF_DRV_NAME);
diff --git a/sound/soc/stm/stm32_i2s.c b/sound/soc/stm/stm32_i2s.c
index f3dd9f8e6..a69c305cf 100644
--- a/sound/soc/stm/stm32_i2s.c
+++ b/sound/soc/stm/stm32_i2s.c
@@ -200,10 +200,13 @@ enum i2s_datlen {
 
 #define STM32_I2S_NAME_LEN		32
 #define STM32_I2S_RATE_11K		11025
+#define STM32_I2S_MAX_SAMPLE_RATE_8K	192000
+#define STM32_I2S_MAX_SAMPLE_RATE_11K	176400
+#define STM32_I2S_CLK_RATE_TOLERANCE	1000 /* ppm */
 
 /**
  * struct stm32_i2s_data - private data of I2S
- * @regmap_conf: I2S register map configuration pointer
+ * @conf: I2S configuration pointer
  * @regmap: I2S register map pointer
  * @pdev: device data pointer
  * @dai_drv: DAI driver pointer
@@ -224,11 +227,15 @@ enum i2s_datlen {
  * @divider: prescaler division ratio
  * @div: prescaler div field
  * @odd: prescaler odd field
+ * @i2s_clk_flg: flag set while exclusivity on I2S kernel clock is active
  * @refcount: keep count of opened streams on I2S
  * @ms_flg: master mode flag.
+ * @set_i2sclk_rate: set I2S kernel clock rate
+ * @set_i2s_clk_rate: set I2S kernel clock rate
+ * @put_i2s_clk_rate: put I2S kernel clock rate
  */
 struct stm32_i2s_data {
-	const struct regmap_config *regmap_conf;
+	struct stm32_i2s_conf *conf;
 	struct regmap *regmap;
 	struct platform_device *pdev;
 	struct snd_soc_dai_driver *dai_drv;
@@ -249,8 +256,21 @@ struct stm32_i2s_data {
 	unsigned int divider;
 	unsigned int div;
 	bool odd;
+	bool i2s_clk_flg;
 	int refcount;
 	int ms_flg;
+	int (*set_i2s_clk_rate)(struct stm32_i2s_data *i2s, unsigned int rate);
+	void (*put_i2s_clk_rate)(struct stm32_i2s_data *i2s);
+};
+
+/**
+ * struct stm32_i2s_conf - I2S configuration
+ * @regmap_conf: regmap configuration pointer
+ * @get_i2s_clk_parent: get parent clock of I2S kernel clock
+ */
+struct stm32_i2s_conf {
+	const struct regmap_config *regmap_conf;
+	int (*get_i2s_clk_parent)(struct stm32_i2s_data *i2s);
 };
 
 struct stm32_i2smclk_data {
@@ -261,6 +281,8 @@ struct stm32_i2smclk_data {
 
 #define to_mclk_data(_hw) container_of(_hw, struct stm32_i2smclk_data, hw)
 
+static int stm32_i2s_get_parent_clk(struct stm32_i2s_data *i2s);
+
 static int stm32_i2s_calc_clk_div(struct stm32_i2s_data *i2s,
 				  unsigned long input_rate,
 				  unsigned long output_rate)
@@ -312,6 +334,33 @@ static int stm32_i2s_set_clk_div(struct stm32_i2s_data *i2s)
 				  cgfr_mask, cgfr);
 }
 
+static bool stm32_i2s_rate_accurate(struct stm32_i2s_data *i2s,
+				    unsigned int max_rate, unsigned int rate)
+{
+	struct platform_device *pdev = i2s->pdev;
+	u64 delta, dividend;
+	int ratio;
+
+	if (!rate) {
+		dev_err(&pdev->dev, "Unexpected null rate\n");
+		return false;
+	}
+
+	ratio = DIV_ROUND_CLOSEST(max_rate, rate);
+	if (!ratio)
+		return false;
+
+	dividend = mul_u32_u32(1000000, abs(max_rate - (ratio * rate)));
+	delta = div_u64(dividend, max_rate);
+
+	if (delta <= STM32_I2S_CLK_RATE_TOLERANCE)
+		return true;
+
+	dev_dbg(&pdev->dev, "Rate [%u] not accurate\n", rate);
+
+	return false;
+}
+
 static int stm32_i2s_set_parent_clock(struct stm32_i2s_data *i2s,
 				      unsigned int rate)
 {
@@ -326,12 +375,92 @@ static int stm32_i2s_set_parent_clock(struct stm32_i2s_data *i2s,
 
 	ret = clk_set_parent(i2s->i2sclk, parent_clk);
 	if (ret)
-		dev_err(&pdev->dev,
-			"Error %d setting i2sclk parent clock\n", ret);
+		dev_err(&pdev->dev, "Error %d setting i2sclk parent clock\n", ret);
 
 	return ret;
 }
 
+static void stm32_i2s_put_parent_rate(struct stm32_i2s_data *i2s)
+{
+	if (i2s->i2s_clk_flg) {
+		i2s->i2s_clk_flg = false;
+		clk_rate_exclusive_put(i2s->i2sclk);
+	}
+}
+
+static int stm32_i2s_set_parent_rate(struct stm32_i2s_data *i2s,
+				     unsigned int rate)
+{
+	struct platform_device *pdev = i2s->pdev;
+	unsigned int i2s_clk_rate, i2s_clk_max_rate, i2s_curr_rate, i2s_new_rate;
+	int ret, div;
+
+	/*
+	 * Set maximum expected kernel clock frequency
+	 * - mclk on:
+	 *   f_i2s_ck = MCKDIV * mclk-fs * fs
+	 *   Here typical 256 ratio is assumed for mclk-fs
+	 * - mclk off:
+	 *   f_i2s_ck = MCKDIV * FRL * fs
+	 *   Where FRL=[16,32], MCKDIV=[1..256]
+	 *   f_i2s_ck = i2s_clk_max_rate * 32 / 256
+	 */
+	if (!(rate % STM32_I2S_RATE_11K))
+		i2s_clk_max_rate = STM32_I2S_MAX_SAMPLE_RATE_11K * 256;
+	else
+		i2s_clk_max_rate = STM32_I2S_MAX_SAMPLE_RATE_8K * 256;
+
+	if (!i2s->i2smclk)
+		i2s_clk_max_rate /= 8;
+
+	/* Request exclusivity, as the clock may be shared by I2S instances */
+	clk_rate_exclusive_get(i2s->i2sclk);
+	i2s->i2s_clk_flg = true;
+
+	/*
+	 * Check current kernel clock rate. If it gives the expected accuracy
+	 * return immediately.
+	 */
+	i2s_curr_rate = clk_get_rate(i2s->i2sclk);
+	if (stm32_i2s_rate_accurate(i2s, i2s_clk_max_rate, i2s_curr_rate))
+		return 0;
+
+	/*
+	 * Otherwise try to set the maximum rate and check the new actual rate.
+	 * If the new rate does not give the expected accuracy, try to set
+	 * lower rates for the kernel clock.
+	 */
+	i2s_clk_rate = i2s_clk_max_rate;
+	div = 1;
+	do {
+		/* Check new rate accuracy. Return if ok */
+		i2s_new_rate = clk_round_rate(i2s->i2sclk, i2s_clk_rate);
+		if (stm32_i2s_rate_accurate(i2s, i2s_clk_rate, i2s_new_rate)) {
+			ret = clk_set_rate(i2s->i2sclk, i2s_clk_rate);
+			if (ret) {
+				dev_err(&pdev->dev, "Error %d setting i2s_clk_rate rate. %s",
+					ret, ret == -EBUSY ?
+					"Active stream rates may be in conflict\n" : "\n");
+				goto err;
+			}
+
+			return 0;
+		}
+
+		/* Try a lower frequency */
+		div++;
+		i2s_clk_rate = i2s_clk_max_rate / div;
+	} while (i2s_clk_rate > rate);
+
+	/* no accurate rate found */
+	dev_err(&pdev->dev, "Failed to find an accurate rate");
+
+err:
+	stm32_i2s_put_parent_rate(i2s);
+
+	return -EINVAL;
+}
+
 static long stm32_i2smclk_round_rate(struct clk_hw *hw, unsigned long rate,
 				     unsigned long *prate)
 {
@@ -635,14 +764,20 @@ static int stm32_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
 				clk_rate_exclusive_put(i2s->i2smclk);
 				i2s->mclk_rate = 0;
 			}
+
+			if (i2s->put_i2s_clk_rate)
+				i2s->put_i2s_clk_rate(i2s);
+
 			return regmap_update_bits(i2s->regmap,
 						  STM32_I2S_CGFR_REG,
 						  I2S_CGFR_MCKOE, 0);
 		}
+
 		/* If master clock is used, set parent clock now */
-		ret = stm32_i2s_set_parent_clock(i2s, freq);
+		ret = i2s->set_i2s_clk_rate(i2s, freq);
 		if (ret)
 			return ret;
+
 		ret = clk_set_rate_exclusive(i2s->i2smclk, freq);
 		if (ret) {
 			dev_err(cpu_dai->dev, "Could not set mclk rate\n");
@@ -667,10 +802,11 @@ static int stm32_i2s_configure_clock(struct snd_soc_dai *cpu_dai,
 	u32 cgfr;
 	int ret;
 
-	if (!(rate % 11025))
-		clk_set_parent(i2s->i2sclk, i2s->x11kclk);
-	else
-		clk_set_parent(i2s->i2sclk, i2s->x8kclk);
+	if (!i2s->mclk_rate) {
+		ret = i2s->set_i2s_clk_rate(i2s, rate);
+		if (ret)
+			return ret;
+	}
 	i2s_clock_rate = clk_get_rate(i2s->i2sclk);
 
 	/*
@@ -915,6 +1051,14 @@ static void stm32_i2s_shutdown(struct snd_pcm_substream *substream,
 
 	clk_disable_unprepare(i2s->i2sclk);
 
+	/*
+	 * Release kernel clock if following conditions are fulfilled
+	 * - Master clock is not used. Kernel clock won't be released trough sysclk
+	 * - Put handler is defined. Involve that clock is managed exclusively
+	 */
+	if (!i2s->i2smclk && i2s->put_i2s_clk_rate)
+		i2s->put_i2s_clk_rate(i2s);
+
 	spin_lock_irqsave(&i2s->irq_lock, flags);
 	i2s->substream = NULL;
 	spin_unlock_irqrestore(&i2s->irq_lock, flags);
@@ -1012,14 +1156,36 @@ static int stm32_i2s_dais_init(struct platform_device *pdev,
 	return 0;
 }
 
+static const struct stm32_i2s_conf stm32_i2s_conf_h7 = {
+	.regmap_conf = &stm32_h7_i2s_regmap_conf,
+	.get_i2s_clk_parent = stm32_i2s_get_parent_clk,
+};
+
+static const struct stm32_i2s_conf stm32_i2s_conf_mp25 = {
+	.regmap_conf = &stm32_h7_i2s_regmap_conf
+};
+
 static const struct of_device_id stm32_i2s_ids[] = {
-	{
-		.compatible = "st,stm32h7-i2s",
-		.data = &stm32_h7_i2s_regmap_conf
-	},
+	{ .compatible = "st,stm32h7-i2s", .data = &stm32_i2s_conf_h7 },
+	{ .compatible = "st,stm32mp25-i2s", .data = &stm32_i2s_conf_mp25 },
 	{},
 };
 
+static int stm32_i2s_get_parent_clk(struct stm32_i2s_data *i2s)
+{
+	struct device *dev = &i2s->pdev->dev;
+
+	i2s->x8kclk = devm_clk_get(dev, "x8k");
+	if (IS_ERR(i2s->x8kclk))
+		return dev_err_probe(dev, PTR_ERR(i2s->x8kclk), "Cannot get x8k parent clock\n");
+
+	i2s->x11kclk = devm_clk_get(dev, "x11k");
+	if (IS_ERR(i2s->x11kclk))
+		return dev_err_probe(dev, PTR_ERR(i2s->x11kclk), "Cannot get x11k parent clock\n");
+
+	return 0;
+}
+
 static int stm32_i2s_parse_dt(struct platform_device *pdev,
 			      struct stm32_i2s_data *i2s)
 {
@@ -1034,7 +1200,7 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 
 	of_id = of_match_device(stm32_i2s_ids, &pdev->dev);
 	if (of_id)
-		i2s->regmap_conf = (const struct regmap_config *)of_id->data;
+		i2s->conf = (struct stm32_i2s_conf *)of_id->data;
 	else
 		return -EINVAL;
 
@@ -1055,15 +1221,18 @@ static int stm32_i2s_parse_dt(struct platform_device *pdev,
 		return dev_err_probe(&pdev->dev, PTR_ERR(i2s->i2sclk),
 				     "Could not get i2sclk\n");
 
-	i2s->x8kclk = devm_clk_get(&pdev->dev, "x8k");
-	if (IS_ERR(i2s->x8kclk))
-		return dev_err_probe(&pdev->dev, PTR_ERR(i2s->x8kclk),
-				     "Could not get x8k parent clock\n");
+	if (i2s->conf->get_i2s_clk_parent) {
+		i2s->set_i2s_clk_rate = stm32_i2s_set_parent_clock;
+	} else {
+		i2s->set_i2s_clk_rate = stm32_i2s_set_parent_rate;
+		i2s->put_i2s_clk_rate = stm32_i2s_put_parent_rate;
+	}
 
-	i2s->x11kclk = devm_clk_get(&pdev->dev, "x11k");
-	if (IS_ERR(i2s->x11kclk))
-		return dev_err_probe(&pdev->dev, PTR_ERR(i2s->x11kclk),
-				     "Could not get x11k parent clock\n");
+	if (i2s->conf->get_i2s_clk_parent) {
+		ret = i2s->conf->get_i2s_clk_parent(i2s);
+		if (ret)
+			return ret;
+	}
 
 	/* Register mclk provider if requested */
 	if (of_find_property(np, "#clock-cells", NULL)) {
@@ -1131,7 +1300,7 @@ static int stm32_i2s_probe(struct platform_device *pdev)
 		return ret;
 
 	i2s->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "pclk",
-						i2s->base, i2s->regmap_conf);
+						i2s->base, i2s->conf->regmap_conf);
 	if (IS_ERR(i2s->regmap))
 		return dev_err_probe(&pdev->dev, PTR_ERR(i2s->regmap),
 				     "Regmap init error\n");
diff --git a/sound/soc/stm/stm32_sai.c b/sound/soc/stm/stm32_sai.c
index 8e21e6f88..fa1131b2c 100644
--- a/sound/soc/stm/stm32_sai.c
+++ b/sound/soc/stm/stm32_sai.c
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/pm_runtime.h>
 #include <linux/reset.h>
 
 #include <sound/dmaengine_pcm.h>
@@ -19,26 +20,42 @@
 
 #include "stm32_sai.h"
 
+static int stm32_sai_get_parent_clk(struct stm32_sai_data *sai);
+
 static const struct stm32_sai_conf stm32_sai_conf_f4 = {
 	.version = STM_SAI_STM32F4,
 	.fifo_size = 8,
 	.has_spdif_pdm = false,
+	.get_sai_ck_parent = stm32_sai_get_parent_clk,
 };
 
 /*
- * Default settings for stm32 H7 socs and next.
+ * Default settings for STM32H7x socs and STM32MP1x.
  * These default settings will be overridden if the soc provides
  * support of hardware configuration registers.
+ * - STM32H7: rely on default settings
+ * - STM32MP1: retrieve settings from registers
  */
 static const struct stm32_sai_conf stm32_sai_conf_h7 = {
 	.version = STM_SAI_STM32H7,
 	.fifo_size = 8,
 	.has_spdif_pdm = true,
+	.get_sai_ck_parent = stm32_sai_get_parent_clk,
+};
+
+/*
+ * STM32MP25:
+ * - do not use SAI parent clock source selection
+ * - do not use DMA burst mode
+ */
+static const struct stm32_sai_conf stm32_sai_conf_mp25 = {
+	.no_dma_burst = true,
 };
 
 static const struct of_device_id stm32_sai_ids[] = {
 	{ .compatible = "st,stm32f4-sai", .data = (void *)&stm32_sai_conf_f4 },
 	{ .compatible = "st,stm32h7-sai", .data = (void *)&stm32_sai_conf_h7 },
+	{ .compatible = "st,stm32mp25-sai", .data = (void *)&stm32_sai_conf_mp25 },
 	{}
 };
 
@@ -148,6 +165,29 @@ static int stm32_sai_set_sync(struct stm32_sai_data *sai_client,
 	return ret;
 }
 
+static int stm32_sai_get_parent_clk(struct stm32_sai_data *sai)
+{
+	struct device *dev = &sai->pdev->dev;
+
+	sai->clk_x8k = devm_clk_get(dev, "x8k");
+	if (IS_ERR(sai->clk_x8k)) {
+		if (PTR_ERR(sai->clk_x8k) != -EPROBE_DEFER)
+			dev_err(dev, "missing x8k parent clock: %ld\n",
+				PTR_ERR(sai->clk_x8k));
+		return PTR_ERR(sai->clk_x8k);
+	}
+
+	sai->clk_x11k = devm_clk_get(dev, "x11k");
+	if (IS_ERR(sai->clk_x11k)) {
+		if (PTR_ERR(sai->clk_x11k) != -EPROBE_DEFER)
+			dev_err(dev, "missing x11k parent clock: %ld\n",
+				PTR_ERR(sai->clk_x11k));
+		return PTR_ERR(sai->clk_x11k);
+	}
+
+	return 0;
+}
+
 static int stm32_sai_probe(struct platform_device *pdev)
 {
 	struct stm32_sai_data *sai;
@@ -160,6 +200,8 @@ static int stm32_sai_probe(struct platform_device *pdev)
 	if (!sai)
 		return -ENOMEM;
 
+	sai->pdev = pdev;
+
 	sai->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(sai->base))
 		return PTR_ERR(sai->base);
@@ -178,15 +220,11 @@ static int stm32_sai_probe(struct platform_device *pdev)
 					     "missing bus clock pclk\n");
 	}
 
-	sai->clk_x8k = devm_clk_get(&pdev->dev, "x8k");
-	if (IS_ERR(sai->clk_x8k))
-		return dev_err_probe(&pdev->dev, PTR_ERR(sai->clk_x8k),
-				     "missing x8k parent clock\n");
-
-	sai->clk_x11k = devm_clk_get(&pdev->dev, "x11k");
-	if (IS_ERR(sai->clk_x11k))
-		return dev_err_probe(&pdev->dev, PTR_ERR(sai->clk_x11k),
-				     "missing x11k parent clock\n");
+	if (sai->conf.get_sai_ck_parent) {
+		ret = sai->conf.get_sai_ck_parent(sai);
+		if (ret)
+			return ret;
+	}
 
 	/* init irqs */
 	sai->irq = platform_get_irq(pdev, 0);
@@ -227,10 +265,11 @@ static int stm32_sai_probe(struct platform_device *pdev)
 	}
 	clk_disable_unprepare(sai->pclk);
 
-	sai->pdev = pdev;
 	sai->set_sync = &stm32_sai_set_sync;
 	platform_set_drvdata(pdev, sai);
 
+	pm_runtime_enable(&pdev->dev);
+
 	return devm_of_platform_populate(&pdev->dev);
 }
 
diff --git a/sound/soc/stm/stm32_sai.h b/sound/soc/stm/stm32_sai.h
index 33e4bff8c..07b71133d 100644
--- a/sound/soc/stm/stm32_sai.h
+++ b/sound/soc/stm/stm32_sai.h
@@ -264,16 +264,22 @@ enum stm32_sai_syncout {
 	STM_SAI_SYNC_OUT_B,
 };
 
+struct stm32_sai_data;
+
 /**
  * struct stm32_sai_conf - SAI configuration
+ * @get_sai_ck_parent: get parent clock of SAI kernel clock
  * @version: SAI version
  * @fifo_size: SAI fifo size as words number
  * @has_spdif_pdm: SAI S/PDIF and PDM features support flag
+ * @no_dma_burst: Support only DMA single transfers if set
  */
 struct stm32_sai_conf {
+	int (*get_sai_ck_parent)(struct stm32_sai_data *sai);
 	u32 version;
 	u32 fifo_size;
 	bool has_spdif_pdm;
+	bool no_dma_burst;
 };
 
 /**
diff --git a/sound/soc/stm/stm32_sai_sub.c b/sound/soc/stm/stm32_sai_sub.c
index eb31b49e6..68f326dff 100644
--- a/sound/soc/stm/stm32_sai_sub.c
+++ b/sound/soc/stm/stm32_sai_sub.c
@@ -60,6 +60,9 @@
 
 #define SAI_MCLK_NAME_LEN		32
 #define SAI_RATE_11K			11025
+#define SAI_MAX_SAMPLE_RATE_8K		192000
+#define SAI_MAX_SAMPLE_RATE_11K		176400
+#define SAI_CK_RATE_TOLERANCE		1000 /* ppm */
 
 /**
  * struct stm32_sai_sub_data - private data of SAI sub block (block A or B)
@@ -80,6 +83,7 @@
  * @dir: SAI block direction (playback or capture). set at init
  * @master: SAI block mode flag. (true=master, false=slave) set at init
  * @spdif: SAI S/PDIF iec60958 mode flag. set at init
+ * @sai_ck_used: flag set while exclusivity on SAI kernel clock is active
  * @fmt: SAI block format. relevant only for custom protocols. set at init
  * @sync: SAI block synchronization mode. (none, internal or external)
  * @synco: SAI block ext sync source (provider setting). (none, sub-block A/B)
@@ -93,6 +97,8 @@
  * @iec958: iec958 data
  * @ctrl_lock: control lock
  * @irq_lock: prevent race condition with IRQ
+ * @set_sai_ck_rate: set SAI kernel clock rate
+ * @put_sai_ck_rate: put SAI kernel clock rate
  */
 struct stm32_sai_sub_data {
 	struct platform_device *pdev;
@@ -112,6 +118,7 @@ struct stm32_sai_sub_data {
 	int dir;
 	bool master;
 	bool spdif;
+	bool sai_ck_used;
 	int fmt;
 	int sync;
 	int synco;
@@ -125,6 +132,8 @@ struct stm32_sai_sub_data {
 	struct snd_aes_iec958 iec958;
 	struct mutex ctrl_lock; /* protect resources accessed by controls */
 	spinlock_t irq_lock; /* used to prevent race condition with IRQ */
+	int (*set_sai_ck_rate)(struct stm32_sai_sub_data *sai, unsigned int rate);
+	void (*put_sai_ck_rate)(struct stm32_sai_sub_data *sai);
 };
 
 enum stm32_sai_fifo_th {
@@ -351,8 +360,26 @@ static int stm32_sai_set_clk_div(struct stm32_sai_sub_data *sai,
 	return ret;
 }
 
-static int stm32_sai_set_parent_clock(struct stm32_sai_sub_data *sai,
-				      unsigned int rate)
+static bool stm32_sai_rate_accurate(unsigned int max_rate, unsigned int rate)
+{
+	u64 delta, dividend;
+	int ratio;
+
+	ratio = DIV_ROUND_CLOSEST(max_rate, rate);
+	if (!ratio)
+		return false;
+
+	dividend = mul_u32_u32(1000000, abs(max_rate - (ratio * rate)));
+	delta = div_u64(dividend, max_rate);
+
+	if (delta <= SAI_CK_RATE_TOLERANCE)
+		return true;
+
+	return false;
+}
+
+static int stm32_sai_set_parent_clk(struct stm32_sai_sub_data *sai,
+				    unsigned int rate)
 {
 	struct platform_device *pdev = sai->pdev;
 	struct clk *parent_clk = sai->pdata->clk_x8k;
@@ -370,6 +397,92 @@ static int stm32_sai_set_parent_clock(struct stm32_sai_sub_data *sai,
 	return ret;
 }
 
+static void stm32_sai_put_parent_rate(struct stm32_sai_sub_data *sai)
+{
+	if (sai->sai_ck_used) {
+		sai->sai_ck_used = false;
+		clk_rate_exclusive_put(sai->sai_ck);
+	}
+}
+
+static int stm32_sai_set_parent_rate(struct stm32_sai_sub_data *sai,
+				     unsigned int rate)
+{
+	struct platform_device *pdev = sai->pdev;
+	unsigned int sai_ck_rate, sai_ck_max_rate, sai_curr_rate, sai_new_rate;
+	int div, ret;
+
+	/*
+	 * Set maximum expected kernel clock frequency
+	 * - mclk on or spdif:
+	 *   f_sai_ck = MCKDIV * mclk-fs * fs
+	 *   Here typical 256 ratio is assumed for mclk-fs
+	 * - mclk off:
+	 *   f_sai_ck = MCKDIV * FRL * fs
+	 *   Where FRL=[8..256], MCKDIV=[1..n] (n depends on SAI version)
+	 *   Set constraint MCKDIV * FRL <= 256, to ensure MCKDIV is in available range
+	 *   f_sai_ck = sai_ck_max_rate * pow_of_two(FRL) / 256
+	 */
+	if (!(rate % SAI_RATE_11K))
+		sai_ck_max_rate = SAI_MAX_SAMPLE_RATE_11K * 256;
+	else
+		sai_ck_max_rate = SAI_MAX_SAMPLE_RATE_8K * 256;
+
+	if (!sai->sai_mclk && !STM_SAI_PROTOCOL_IS_SPDIF(sai))
+		sai_ck_max_rate /= DIV_ROUND_CLOSEST(256, roundup_pow_of_two(sai->fs_length));
+
+	/*
+	 * Request exclusivity, as the clock is shared by SAI sub-blocks and by
+	 * some SAI instances. This allows to ensure that the rate cannot be
+	 * changed while one or more SAIs are using the clock.
+	 */
+	clk_rate_exclusive_get(sai->sai_ck);
+	sai->sai_ck_used = true;
+
+	/*
+	 * Check current kernel clock rate. If it gives the expected accuracy
+	 * return immediately.
+	 */
+	sai_curr_rate = clk_get_rate(sai->sai_ck);
+	if (stm32_sai_rate_accurate(sai_ck_max_rate, sai_curr_rate))
+		return 0;
+
+	/*
+	 * Otherwise try to set the maximum rate and check the new actual rate.
+	 * If the new rate does not give the expected accuracy, try to set
+	 * lower rates for the kernel clock.
+	 */
+	sai_ck_rate = sai_ck_max_rate;
+	div = 1;
+	do {
+		/* Check new rate accuracy. Return if ok */
+		sai_new_rate = clk_round_rate(sai->sai_ck, sai_ck_rate);
+		if (stm32_sai_rate_accurate(sai_ck_rate, sai_new_rate)) {
+			ret = clk_set_rate(sai->sai_ck, sai_ck_rate);
+			if (ret) {
+				dev_err(&pdev->dev, "Error %d setting sai_ck rate. %s",
+					ret, ret == -EBUSY ?
+					"Active stream rates may be in conflict\n" : "\n");
+				goto err;
+			}
+
+			return 0;
+		}
+
+		/* Try a lower frequency */
+		div++;
+		sai_ck_rate = sai_ck_max_rate / div;
+	} while (sai_ck_rate > rate);
+
+	/* No accurate rate found */
+	dev_err(&pdev->dev, "Failed to find an accurate rate");
+
+err:
+	stm32_sai_put_parent_rate(sai);
+
+	return -EINVAL;
+}
+
 static long stm32_sai_mclk_round_rate(struct clk_hw *hw, unsigned long rate,
 				      unsigned long *prate)
 {
@@ -565,11 +678,15 @@ static int stm32_sai_set_sysclk(struct snd_soc_dai *cpu_dai,
 				clk_rate_exclusive_put(sai->sai_mclk);
 				sai->mclk_rate = 0;
 			}
+
+			if (sai->put_sai_ck_rate)
+				sai->put_sai_ck_rate(sai);
+
 			return 0;
 		}
 
-		/* If master clock is used, set parent clock now */
-		ret = stm32_sai_set_parent_clock(sai, freq);
+		/* If master clock is used, configure SAI kernel clock now */
+		ret = sai->set_sai_ck_rate(sai, freq);
 		if (ret)
 			return ret;
 
@@ -993,7 +1110,7 @@ static int stm32_sai_configure_clock(struct snd_soc_dai *cpu_dai,
 	int ret;
 
 	if (!sai->sai_mclk) {
-		ret = stm32_sai_set_parent_clock(sai, rate);
+		ret = sai->set_sai_ck_rate(sai, rate);
 		if (ret)
 			return ret;
 	}
@@ -1154,6 +1271,14 @@ static void stm32_sai_shutdown(struct snd_pcm_substream *substream,
 
 	clk_disable_unprepare(sai->sai_ck);
 
+	/*
+	 * Release kernel clock if following conditions are fulfilled
+	 * - Master clock is not used. Kernel clock won't be released trough sysclk
+	 * - Put handler is defined. Involve that clock is managed exclusively
+	 */
+	if (!sai->sai_mclk && sai->put_sai_ck_rate)
+		sai->put_sai_ck_rate(sai);
+
 	spin_lock_irqsave(&sai->irq_lock, flags);
 	sai->substream = NULL;
 	spin_unlock_irqrestore(&sai->irq_lock, flags);
@@ -1188,7 +1313,7 @@ static int stm32_sai_dai_probe(struct snd_soc_dai *cpu_dai)
 	 * constraints).
 	 */
 	sai->dma_params.maxburst = 4;
-	if (sai->pdata->conf.fifo_size < 8)
+	if (sai->pdata->conf.fifo_size < 8 || sai->pdata->conf.no_dma_burst)
 		sai->dma_params.maxburst = 1;
 	/* Buswidth will be set by framework at runtime */
 	sai->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
@@ -1523,6 +1648,13 @@ static int stm32_sai_sub_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	if (sai->pdata->conf.get_sai_ck_parent) {
+		sai->set_sai_ck_rate = stm32_sai_set_parent_clk;
+	} else {
+		sai->set_sai_ck_rate = stm32_sai_set_parent_rate;
+		sai->put_sai_ck_rate = stm32_sai_put_parent_rate;
+	}
+
 	ret = stm32_sai_sub_parse_of(pdev, sai);
 	if (ret)
 		return ret;
diff --git a/sound/soc/stm/stm32_spdifrx.c b/sound/soc/stm/stm32_spdifrx.c
index d399c906b..e66382680 100644
--- a/sound/soc/stm/stm32_spdifrx.c
+++ b/sound/soc/stm/stm32_spdifrx.c
@@ -943,7 +943,7 @@ static int stm32_spdifrx_remove(struct platform_device *pdev)
 {
 	struct stm32_spdifrx_data *spdifrx = platform_get_drvdata(pdev);
 
-	if (spdifrx->ctrl_chan)
+	if (!IS_ERR(spdifrx->ctrl_chan))
 		dma_release_channel(spdifrx->ctrl_chan);
 
 	if (spdifrx->dmab)
diff --git a/tools/counter/Build b/tools/counter/Build
index 33f4a51d7..4bbadb7ec 100644
--- a/tools/counter/Build
+++ b/tools/counter/Build
@@ -1 +1,2 @@
 counter_example-y += counter_example.o
+counter_watch_events-y += counter_watch_events.o
diff --git a/tools/counter/Makefile b/tools/counter/Makefile
index 8843f0fa6..09b1d28d5 100644
--- a/tools/counter/Makefile
+++ b/tools/counter/Makefile
@@ -12,9 +12,10 @@ endif
 # (this improves performance and avoids hard-to-debug behaviour);
 MAKEFLAGS += -r
 
-override CFLAGS += -O2 -Wall -g -D_GNU_SOURCE -I$(OUTPUT)include
+override CFLAGS += -O2 -Wall -g -D_GNU_SOURCE -I$(OUTPUT)include \
+	 -I$(srctree)/tools/include
 
-ALL_TARGETS := counter_example
+ALL_TARGETS := counter_example counter_watch_events
 ALL_PROGRAMS := $(patsubst %,$(OUTPUT)%,$(ALL_TARGETS))
 
 all: $(ALL_PROGRAMS)
@@ -37,10 +38,17 @@ $(COUNTER_EXAMPLE): prepare FORCE
 $(OUTPUT)counter_example: $(COUNTER_EXAMPLE)
 	$(QUIET_LINK)$(CC) $(CFLAGS) $(LDFLAGS) $< -o $@
 
+COUNTER_WATCH_EVENTS := $(OUTPUT)counter_watch_events.o
+$(COUNTER_WATCH_EVENTS): prepare FORCE
+	$(Q)$(MAKE) $(build)=counter_watch_events
+$(OUTPUT)counter_watch_events: $(COUNTER_WATCH_EVENTS)
+	$(QUIET_LINK)$(CC) $(CFLAGS) $(LDFLAGS) $< -o $@
+
 clean:
 	rm -f $(ALL_PROGRAMS)
 	rm -rf $(OUTPUT)include/linux/counter.h
 	find $(or $(OUTPUT),.) -name '*.o' -delete -o -name '\.*.d' -delete
+	find $(or $(OUTPUT),.) -name '\.*.o.cmd' -delete
 
 install: $(ALL_PROGRAMS)
 	install -d -m 755 $(DESTDIR)$(bindir);		\
diff --git a/tools/counter/counter_watch_events.c b/tools/counter/counter_watch_events.c
new file mode 100644
index 000000000..107631e0f
--- /dev/null
+++ b/tools/counter/counter_watch_events.c
@@ -0,0 +1,406 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Counter Watch Events - Test various counter watch events in a userspace application
+ *
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Fabrice Gasnier <fabrice.gasnier@foss.st.com>.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <linux/counter.h>
+#include <linux/kernel.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+static struct counter_watch simple_watch[] = {
+	{
+		/* Component data: Count 0 count */
+		.component.type = COUNTER_COMPONENT_COUNT,
+		.component.scope = COUNTER_SCOPE_COUNT,
+		.component.parent = 0,
+		/* Event type: overflow or underflow */
+		.event = COUNTER_EVENT_OVERFLOW_UNDERFLOW,
+		/* Device event channel 0 */
+		.channel = 0,
+	},
+};
+
+static const char * const counter_event_type_name[] = {
+	"COUNTER_EVENT_OVERFLOW",
+	"COUNTER_EVENT_UNDERFLOW",
+	"COUNTER_EVENT_OVERFLOW_UNDERFLOW",
+	"COUNTER_EVENT_THRESHOLD",
+	"COUNTER_EVENT_INDEX",
+	"COUNTER_EVENT_CHANGE_OF_STATE",
+	"COUNTER_EVENT_CAPTURE",
+};
+
+static const char * const counter_component_type_name[] = {
+	"COUNTER_COMPONENT_NONE",
+	"COUNTER_COMPONENT_SIGNAL",
+	"COUNTER_COMPONENT_COUNT",
+	"COUNTER_COMPONENT_FUNCTION",
+	"COUNTER_COMPONENT_SYNAPSE_ACTION",
+	"COUNTER_COMPONENT_EXTENSION",
+};
+
+static const char * const counter_scope_name[] = {
+	"COUNTER_SCOPE_DEVICE",
+	"COUNTER_SCOPE_SIGNAL",
+	"COUNTER_SCOPE_COUNT",
+};
+
+static void print_watch(struct counter_watch *watch, int nwatch)
+{
+	int i;
+
+	/* prints the watch array in C-like structure */
+	printf("watch[%d] = {\n", nwatch);
+	for (i = 0; i < nwatch; i++) {
+		printf(" [%d] =\t{\n"
+		       "\t\t.component.type = %s\n"
+		       "\t\t.component.scope = %s\n"
+		       "\t\t.component.parent = %d\n"
+		       "\t\t.component.id = %d\n"
+		       "\t\t.event = %s\n"
+		       "\t\t.channel = %d\n"
+		       "\t},\n",
+		       i,
+		       counter_component_type_name[watch[i].component.type],
+		       counter_scope_name[watch[i].component.scope],
+		       watch[i].component.parent,
+		       watch[i].component.id,
+		       counter_event_type_name[watch[i].event],
+		       watch[i].channel);
+	}
+	printf("};\n");
+}
+
+static void print_usage(void)
+{
+	fprintf(stderr, "Usage:\n\n"
+		"counter_watch_events [options] [-w <watchoptions>]\n"
+		"counter_watch_events [options] [-w <watch1 options>] [-w <watch2 options>]...\n"
+		"\n"
+		"When no --watch option has been provided, simple watch example is used:\n"
+		"counter_watch_events [options] -w comp_count,scope_count,evt_ovf_udf\n"
+		"\n"
+		"Test various watch events for given counter device.\n"
+		"\n"
+		"Options:\n"
+		"  -d, --debug                Prints debug information\n"
+		"  -h, --help                 Prints usage\n"
+		"  -n, --device-num <n>       Use /dev/counter<n> [default: /dev/counter0]\n"
+		"  -l, --loop <n>             Loop for <n> events [default: 0 (forever)]\n"
+		"  -w, --watch <watchoptions> comma-separated list of watch options\n"
+		"\n"
+		"Watch options:\n"
+		"  scope_device               (COUNTER_SCOPE_DEVICE) [default: scope_device]\n"
+		"  scope_signal               (COUNTER_SCOPE_SIGNAL)\n"
+		"  scope_count                (COUNTER_SCOPE_COUNT)\n"
+		"\n"
+		"  comp_none                  (COUNTER_COMPONENT_NONE) [default: comp_none]\n"
+		"  comp_signal                (COUNTER_COMPONENT_SIGNAL)\n"
+		"  comp_count                 (COUNTER_COMPONENT_COUNT)\n"
+		"  comp_function              (COUNTER_COMPONENT_FUNCTION)\n"
+		"  comp_synapse_action        (COUNTER_COMPONENT_SYNAPSE_ACTION)\n"
+		"  comp_extension             (COUNTER_COMPONENT_EXTENSION)\n"
+		"\n"
+		"  evt_ovf                    (COUNTER_EVENT_OVERFLOW) [default: evt_ovf]\n"
+		"  evt_udf                    (COUNTER_EVENT_UNDERFLOW)\n"
+		"  evt_ovf_udf                (COUNTER_EVENT_OVERFLOW_UNDERFLOW)\n"
+		"  evt_threshold              (COUNTER_EVENT_THRESHOLD)\n"
+		"  evt_index                  (COUNTER_EVENT_INDEX)\n"
+		"  evt_change_of_state        (COUNTER_EVENT_CHANGE_OF_STATE)\n"
+		"  evt_capture                (COUNTER_EVENT_CAPTURE)\n"
+		"\n"
+		"  chan=<n>                   channel <n> for this watch [default: 0]\n"
+		"  id=<n>                     component id <n> for this watch [default: 0]\n"
+		"  parent=<n>                 component parent <n> for this watch [default: 0]\n"
+		"\n"
+		"Example with two watched events:\n\n"
+		"counter_watch_events -d \\\n"
+		"\t-w comp_count,scope_count,evt_ovf_udf \\\n"
+		"\t-w comp_extension,scope_count,evt_capture,id=7,chan=3\n"
+		);
+}
+
+static const struct option longopts[] = {
+	{ "debug",		no_argument,       0, 'd' },
+	{ "help",		no_argument,       0, 'h' },
+	{ "device-num",		required_argument, 0, 'n' },
+	{ "loop",		required_argument, 0, 'l' },
+	{ "watch",		required_argument, 0, 'w' },
+	{ },
+};
+
+/* counter watch subopts */
+enum {
+	WATCH_SCOPE_DEVICE,
+	WATCH_SCOPE_SIGNAL,
+	WATCH_SCOPE_COUNT,
+	WATCH_COMPONENT_NONE,
+	WATCH_COMPONENT_SIGNAL,
+	WATCH_COMPONENT_COUNT,
+	WATCH_COMPONENT_FUNCTION,
+	WATCH_COMPONENT_SYNAPSE_ACTION,
+	WATCH_COMPONENT_EXTENSION,
+	WATCH_EVENT_OVERFLOW,
+	WATCH_EVENT_UNDERFLOW,
+	WATCH_EVENT_OVERFLOW_UNDERFLOW,
+	WATCH_EVENT_THRESHOLD,
+	WATCH_EVENT_INDEX,
+	WATCH_EVENT_CHANGE_OF_STATE,
+	WATCH_EVENT_CAPTURE,
+	WATCH_CHANNEL,
+	WATCH_ID,
+	WATCH_PARENT,
+	WATCH_SUBOPTS_MAX,
+};
+
+static char * const counter_watch_subopts[WATCH_SUBOPTS_MAX + 1] = {
+	/* component.scope */
+	[WATCH_SCOPE_DEVICE] = "scope_device",
+	[WATCH_SCOPE_SIGNAL] = "scope_signal",
+	[WATCH_SCOPE_COUNT] = "scope_count",
+	/* component.type */
+	[WATCH_COMPONENT_NONE] = "comp_none",
+	[WATCH_COMPONENT_SIGNAL] = "comp_signal",
+	[WATCH_COMPONENT_COUNT] = "comp_count",
+	[WATCH_COMPONENT_FUNCTION] = "comp_function",
+	[WATCH_COMPONENT_SYNAPSE_ACTION] = "comp_synapse_action",
+	[WATCH_COMPONENT_EXTENSION] = "comp_extension",
+	/* event */
+	[WATCH_EVENT_OVERFLOW] = "evt_ovf",
+	[WATCH_EVENT_UNDERFLOW] = "evt_udf",
+	[WATCH_EVENT_OVERFLOW_UNDERFLOW] = "evt_ovf_udf",
+	[WATCH_EVENT_THRESHOLD] = "evt_threshold",
+	[WATCH_EVENT_INDEX] = "evt_index",
+	[WATCH_EVENT_CHANGE_OF_STATE] = "evt_change_of_state",
+	[WATCH_EVENT_CAPTURE] = "evt_capture",
+	/* channel, id, parent */
+	[WATCH_CHANNEL] = "chan",
+	[WATCH_ID] = "id",
+	[WATCH_PARENT] = "parent",
+	/* Empty entry ends the opts array */
+	NULL
+};
+
+int main(int argc, char **argv)
+{
+	int c, fd, i, ret, rc = 0, debug = 0, loop = 0, dev_num = 0, nwatch = 0;
+	struct counter_event event_data;
+	char *device_name = NULL, *subopts, *value;
+	struct counter_watch *watches;
+
+	/*
+	 * 1st pass:
+	 * - list watch events number to allocate the watch array.
+	 * - parse normal options (other than watch options)
+	 */
+	while ((c = getopt_long(argc, argv, "dhn:l:w:", longopts, NULL)) != -1) {
+		switch (c) {
+		case 'd':
+			debug = 1;
+			break;
+		case 'h':
+			print_usage();
+			return EXIT_SUCCESS;
+		case 'n':
+			dev_num = strtoul(optarg, NULL, 10);
+			if (errno) {
+				perror("strtol failed: --device-num <n>\n");
+				return EXIT_FAILURE;
+			}
+			break;
+		case 'l':
+			loop = strtol(optarg, NULL, 10);
+			if (errno) {
+				perror("strtol failed: --loop <n>\n");
+				return EXIT_FAILURE;
+			}
+			break;
+		case 'w':
+			nwatch++;
+			break;
+		default:
+			return EXIT_FAILURE;
+		}
+	}
+
+	if (nwatch) {
+		watches = calloc(nwatch, sizeof(*watches));
+		if (!watches) {
+			perror("Error allocating watches\n");
+			return EXIT_FAILURE;
+		}
+	} else {
+		/* default to simple watch example */
+		watches = simple_watch;
+		nwatch = ARRAY_SIZE(simple_watch);
+	}
+
+	/* 2nd pass: parse watch sub-options to fill in watch array */
+	optind = 1;
+	i = 0;
+	while ((c = getopt_long(argc, argv, "dhn:l:w:", longopts, NULL)) != -1) {
+		switch (c) {
+		case 'w':
+			subopts = optarg;
+			while (*subopts != '\0') {
+				ret = getsubopt(&subopts, counter_watch_subopts, &value);
+				switch (ret) {
+				case WATCH_SCOPE_DEVICE:
+				case WATCH_SCOPE_SIGNAL:
+				case WATCH_SCOPE_COUNT:
+					/* match with counter_scope */
+					watches[i].component.scope = ret;
+					break;
+				case WATCH_COMPONENT_NONE:
+				case WATCH_COMPONENT_SIGNAL:
+				case WATCH_COMPONENT_COUNT:
+				case WATCH_COMPONENT_FUNCTION:
+				case WATCH_COMPONENT_SYNAPSE_ACTION:
+				case WATCH_COMPONENT_EXTENSION:
+					/* match counter_component_type: subtract enum value */
+					ret -= WATCH_COMPONENT_NONE;
+					watches[i].component.type = ret;
+					break;
+				case WATCH_EVENT_OVERFLOW:
+				case WATCH_EVENT_UNDERFLOW:
+				case WATCH_EVENT_OVERFLOW_UNDERFLOW:
+				case WATCH_EVENT_THRESHOLD:
+				case WATCH_EVENT_INDEX:
+				case WATCH_EVENT_CHANGE_OF_STATE:
+				case WATCH_EVENT_CAPTURE:
+					/* match counter_event_type: subtract enum value */
+					ret -= WATCH_EVENT_OVERFLOW;
+					watches[i].event = ret;
+					break;
+				case WATCH_CHANNEL:
+					if (!value) {
+						fprintf(stderr, "Invalid chan=<number>\n");
+						rc = EXIT_FAILURE;
+						goto err_free_watches;
+					}
+					watches[i].channel = strtoul(value, NULL, 10);
+					if (errno) {
+						perror("strtoul failed: chan=<number>\n");
+						rc = EXIT_FAILURE;
+						goto err_free_watches;
+					}
+					break;
+				case WATCH_ID:
+					if (!value) {
+						fprintf(stderr, "Invalid id=<number>\n");
+						rc = EXIT_FAILURE;
+						goto err_free_watches;
+					}
+					watches[i].component.id = strtoul(value, NULL, 10);
+					if (errno) {
+						perror("strtoul failed: id=<number>\n");
+						rc = EXIT_FAILURE;
+						goto err_free_watches;
+					}
+					break;
+				case WATCH_PARENT:
+					if (!value) {
+						fprintf(stderr, "Invalid parent=<number>\n");
+						rc = EXIT_FAILURE;
+						goto err_free_watches;
+					}
+					watches[i].component.parent = strtoul(value, NULL, 10);
+					if (errno) {
+						perror("strtoul failed: parent=<number>\n");
+						rc = EXIT_FAILURE;
+						goto err_free_watches;
+					}
+					break;
+				default:
+					fprintf(stderr, "Unknown suboption '%s'\n", value);
+					rc = EXIT_FAILURE;
+					goto err_free_watches;
+				}
+			}
+			i++;
+			break;
+		}
+	}
+
+	if (debug)
+		print_watch(watches, nwatch);
+
+	ret = asprintf(&device_name, "/dev/counter%d", dev_num);
+	if (ret < 0) {
+		fprintf(stderr, "asprintf failed\n");
+		rc = EXIT_FAILURE;
+		goto err_free_watches;
+	}
+
+	if (debug)
+		printf("Opening %s\n", device_name);
+
+	fd = open(device_name, O_RDWR);
+	if (fd == -1) {
+		fprintf(stderr, "Unable to open %s: %s\n", device_name, strerror(errno));
+		free(device_name);
+		rc = EXIT_FAILURE;
+		goto err_free_watches;
+	}
+	free(device_name);
+
+	for (i = 0; i < nwatch; i++) {
+		ret = ioctl(fd, COUNTER_ADD_WATCH_IOCTL, watches + i);
+		if (ret == -1) {
+			fprintf(stderr, "Error adding watches[%d]: %s\n", i,
+				strerror(errno));
+			rc = EXIT_FAILURE;
+			goto err_close;
+		}
+	}
+
+	ret = ioctl(fd, COUNTER_ENABLE_EVENTS_IOCTL);
+	if (ret == -1) {
+		perror("Error enabling events");
+		rc = EXIT_FAILURE;
+		goto err_close;
+	}
+
+	for (i = 0; loop <= 0 || i < loop; i++) {
+		ret = read(fd, &event_data, sizeof(event_data));
+		if (ret == -1) {
+			perror("Failed to read event data");
+			rc = EXIT_FAILURE;
+			goto err_close;
+		}
+
+		if (ret != sizeof(event_data)) {
+			fprintf(stderr, "Failed to read event data (got: %d)\n", ret);
+			rc = EXIT_FAILURE;
+			goto err_close;
+		}
+
+		printf("Timestamp: %llu\tData: %llu\t event: %s\tch: %d\n",
+		       event_data.timestamp, event_data.value,
+		       counter_event_type_name[event_data.watch.event],
+		       event_data.watch.channel);
+
+		if (event_data.status) {
+			fprintf(stderr, "Error %d: %s\n", event_data.status,
+				strerror(event_data.status));
+		}
+	}
+
+err_close:
+	close(fd);
+err_free_watches:
+	if (watches != simple_watch)
+		free(watches);
+
+	return rc;
+}
-- 
2.34.1


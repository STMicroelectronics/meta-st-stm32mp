From d63dbd59a7056259e6c7dd9dc8c2d7539688ed64 Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Fri, 7 Jun 2024 16:01:08 +0200
Subject: [PATCH] v2.8-stm32mp-r2

---
 .gitignore                                    |    2 +
 CODE_OF_CONDUCT.md                            |   73 +
 CONTRIBUTING.md                               |   30 +
 Makefile                                      |   64 +-
 SECURITY.md                                   |    8 +
 bl2/bl2_main.c                                |    4 +-
 changelog.yaml                                |   30 +-
 common/aarch32/debug.S                        |   12 +-
 common/bl_common.c                            |    8 +-
 common/fdt_wrappers.c                         |   15 +-
 docs/Makefile                                 |   10 +-
 docs/about/maintainers.rst                    |    1 +
 docs/components/firmware-update.rst           |    2 +-
 docs/design_documents/index.rst               |    1 +
 docs/design_documents/psci_osi_mode.rst       |  718 ++
 docs/devicetree/bindings/arm/secure.txt       |   53 +
 .../bindings/clock/st,stm32mp1-rcc.txt        |  525 ++
 .../bindings/clock/st,stm32mp13-rcc.txt       |  640 ++
 docs/devicetree/bindings/i2c/i2c-stm32.txt    |   54 +
 .../memory-controllers/st,stm32mp1-ddr.txt    |  289 +
 .../memory-controllers/st,stm32mp2-ddr.txt    |  543 ++
 docs/devicetree/bindings/mmc/mmci.txt         |   72 +
 .../bindings/mmc/st,stm32-sdmmc2.txt          |   22 +
 .../bindings/power/st,stm32mp1-pwr.txt        |   43 +
 .../bindings/power/st,stm32mp25-pwr.txt       |   60 +
 docs/devicetree/bindings/power/st,stpmic1.txt |   94 +
 .../bindings/reset/st,stm32mp1-rcc.txt        |    6 +
 docs/devicetree/bindings/rng/st,stm32-rng.txt |   23 +
 .../bindings/serial/st,stm32-usart.txt        |   88 +
 .../bindings/soc/st,stm32-etzpc.txt           |   54 +
 .../bindings/soc/st,stm32-romem.txt           |   52 +
 .../bindings/soc/st,stm32-stgen.txt           |   18 +
 .../devicetree/bindings/soc/st,stm32-tamp.txt |   20 +
 .../bindings/watchdog/st,stm32-iwdg.txt       |   27 +
 docs/getting_started/build-options.rst        |   75 +-
 docs/getting_started/porting-guide.rst        |   52 +-
 docs/index.rst                                |    2 +-
 docs/plat/index.rst                           |    4 +-
 docs/plat/st/index.rst                        |   14 +
 docs/plat/st/stm32mp1.rst                     |  218 +
 docs/plat/st/stm32mp2.rst                     |  207 +
 docs/plat/st/stm32mpus.rst                    |   82 +
 docs/plat/stm32mp1.rst                        |  285 +-
 docs/process/security-hardening.rst           |   35 +-
 drivers/arm/gic/v2/gicv2.mk                   |   10 +-
 drivers/arm/gic/v2/gicv2_main.c               |   91 +
 drivers/auth/auth_mod.c                       |   10 +-
 drivers/brcm/emmc/emmc_csl_sdcard.c           |    5 +-
 drivers/brcm/emmc/emmc_pboot_hal_memory_drv.c |   40 +-
 drivers/fwu/fwu.c                             |  139 +-
 drivers/imx/usdhc/imx_usdhc.c                 |    6 +-
 drivers/io/io_mtd.c                           |   14 +
 drivers/mmc/mmc.c                             |   12 +-
 drivers/mtd/hyperflash/hyperflash.c           |   49 +
 drivers/mtd/nand/raw_nand.c                   |   36 +-
 drivers/mtd/nand/spi_nand.c                   |   10 +-
 drivers/mtd/nor/spi_nor.c                     |  135 +-
 drivers/mtd/spi-mem/spi_mem.c                 |  126 +-
 drivers/nxp/ddr/nxp-ddr/ddr.c                 |    2 +-
 drivers/nxp/ddr/phy-gen2/messages.h           |    4 +-
 drivers/partition/gpt.c                       |    6 +-
 drivers/partition/partition.c                 |   16 +-
 drivers/renesas/common/emmc/emmc_cmd.c        |    5 +-
 drivers/renesas/common/rom/rom_api.c          |    4 +-
 drivers/renesas/common/rom/rom_api.h          |    2 +-
 drivers/st/bsec/bsec2.c                       |  362 +-
 drivers/st/bsec/bsec3.c                       |  546 ++
 drivers/st/clk/clk-stm32-core.c               |  101 +-
 drivers/st/clk/clk-stm32-core.h               |   73 +-
 drivers/st/clk/clk-stm32mp13.c                |  343 +-
 drivers/st/clk/clk-stm32mp2.c                 | 2396 ++++++
 drivers/st/clk/stm32mp1_clk.c                 | 1044 ++-
 drivers/st/clk/stm32mp_clkfunc.c              |   61 +-
 drivers/st/crypto/stm32_hash.c                |   57 +-
 drivers/st/crypto/stm32_pka.c                 |   27 +-
 drivers/st/crypto/stm32_rng.c                 |    4 +
 drivers/st/crypto/stm32_saes.c                |   17 +-
 .../firmware/include/mnpmusrammsgblock_ddr3.h |  934 +++
 .../firmware/include/mnpmusrammsgblock_ddr4.h | 2202 ++++++
 .../include/mnpmusrammsgblock_lpddr4.h        |  924 +++
 .../phyinit/include/ddrphy_csr_all_cdefines.h | 6945 +++++++++++++++++
 .../ddr/phy/phyinit/include/ddrphy_phyinit.h  |   37 +
 .../phyinit/include/ddrphy_phyinit_struct.h   |  787 ++
 .../include/ddrphy_phyinit_usercustom.h       |  118 +
 .../ddr/phy/phyinit/include/ddrphy_wrapper.h  |   20 +
 .../src/ddrphy_phyinit_c_initphyconfig.c      | 1142 +++
 .../phy/phyinit/src/ddrphy_phyinit_calcmb.c   |  214 +
 .../phyinit/src/ddrphy_phyinit_d_loadimem.c   |   46 +
 .../phyinit/src/ddrphy_phyinit_f_loaddmem.c   |   74 +
 .../phy/phyinit/src/ddrphy_phyinit_g_execfw.c |   69 +
 .../src/ddrphy_phyinit_i_loadpieimage.c       |  397 +
 .../phyinit/src/ddrphy_phyinit_initstruct.c   |  264 +
 .../src/ddrphy_phyinit_isdbytedisabled.c      |   88 +
 .../src/ddrphy_phyinit_loadpieprodcode.c      |  188 +
 .../phyinit/src/ddrphy_phyinit_mapdrvstren.c  |  282 +
 .../src/ddrphy_phyinit_progcsrskiptrain.c     |  897 +++
 .../phyinit/src/ddrphy_phyinit_reginterface.c |  169 +
 .../src/ddrphy_phyinit_restore_sequence.c     |   81 +
 .../phy/phyinit/src/ddrphy_phyinit_sequence.c |  125 +
 .../phyinit/src/ddrphy_phyinit_softsetmb.c    |  100 +
 .../phyinit/src/ddrphy_phyinit_writeoutmem.c  |   79 +
 ...ddrphy_phyinit_usercustom_custompretrain.c |   93 +
 .../ddrphy_phyinit_usercustom_g_waitfwdone.c  |  184 +
 .../ddrphy_phyinit_usercustom_saveretregs.c   |  402 +
 drivers/st/ddr/stm32mp1_ddr.c                 |  183 +-
 drivers/st/ddr/stm32mp1_ddr_helpers.c         |  513 ++
 drivers/st/ddr/stm32mp1_ram.c                 |   80 +-
 drivers/st/ddr/stm32mp2_ddr.c                 |  497 ++
 drivers/st/ddr/stm32mp2_ddr_helpers.c         |  556 ++
 drivers/st/ddr/stm32mp2_ram.c                 |  209 +
 drivers/st/ddr/stm32mp_ddr.c                  |  208 +-
 drivers/st/ddr/stm32mp_ddr_test.c             |  109 +-
 drivers/st/ddr/stm32mp_ram.c                  |    6 +-
 drivers/st/fmc/stm32_fmc2_nand.c              |  138 +-
 drivers/st/gpio/stm32_gpio.c                  |   80 +-
 drivers/st/i2c/stm32_i2c.c                    |  447 +-
 drivers/st/iwdg/stm32_iwdg.c                  |   45 +-
 drivers/st/mce/stm32_mce.c                    |  428 +
 drivers/st/mmc/stm32_sdmmc2.c                 |   16 +-
 drivers/st/nvmem/nvmem.c                      |  133 +
 drivers/st/nvmem/stm32mp_tamp_nvram_core.c    |  414 +
 drivers/st/nvmem/stm32mp_tamp_nvram_mp1.c     |   43 +
 drivers/st/nvmem/stm32mp_tamp_nvram_mp2.c     |  232 +
 drivers/st/pmic/stm32mp_pmic.c                |  150 +-
 drivers/st/pmic/stm32mp_pmic2.c               |  511 ++
 drivers/st/pmic/stpmic2.c                     |  474 ++
 drivers/st/regulator/regulator_core.c         |   34 +-
 drivers/st/regulator/regulator_fixed.c        |    9 +-
 drivers/st/regulator/regulator_gpio.c         |  166 +
 drivers/st/reset/stm32mp1_reset.c             |   15 +-
 drivers/st/reset/stm32mp2_reset.c             |   76 +
 drivers/st/rif/stm32_rifsc.c                  |   68 +
 drivers/st/rif/stm32mp2_risaf.c               |  675 ++
 drivers/st/spi/stm32_ospi.c                   | 1320 ++++
 drivers/st/uart/aarch32/stm32_console.S       |   30 +-
 drivers/st/uart/aarch64/stm32_console.S       |  254 +
 drivers/st/usb/stm32mp1_usb.c                 |   11 +-
 drivers/st/usb_dwc3/usb_dwc3.c                | 2414 ++++++
 drivers/st/usb_dwc3/usb_dwc3_regs.h           | 1225 +++
 drivers/usb/usb_device.c                      |   21 +-
 fdts/stm32mp13-bl2.dtsi                       |   16 +-
 fdts/stm32mp13-fw-config-mem-encrypt.dtsi     |   13 +
 fdts/stm32mp13-ssp-bl2.dtsi                   |   53 +
 fdts/stm32mp131.dtsi                          |   35 +-
 fdts/stm32mp135f-dk-fw-config.dts             |    1 +
 fdts/stm32mp135f-dk.dts                       |   65 +-
 fdts/stm32mp15-bl2.dtsi                       |   57 +-
 fdts/stm32mp15-bl32.dtsi                      |   50 +-
 fdts/stm32mp15-fw-config.dtsi                 |   21 +-
 fdts/stm32mp15-pinctrl.dtsi                   |    2 +-
 fdts/stm32mp15-ssp-bl2.dtsi                   |   81 +
 fdts/stm32mp151.dtsi                          |   51 +-
 fdts/stm32mp157a-avenger96.dts                |   83 +-
 fdts/stm32mp157a-dk1.dts                      |    1 +
 fdts/stm32mp157a-ed1.dts                      |  347 +
 fdts/stm32mp157a-ev1.dts                      |   63 +
 fdts/stm32mp157c-ed1.dts                      |  107 +-
 fdts/stm32mp157c-odyssey-som.dtsi             |   83 +-
 fdts/stm32mp157d-dk1.dts                      |   28 +
 fdts/stm32mp157d-ed1.dts                      |  347 +
 fdts/stm32mp157d-ev1.dts                      |   63 +
 fdts/stm32mp157f-dk2.dts                      |   33 +
 fdts/stm32mp157f-ed1.dts                      |  351 +
 fdts/stm32mp157f-ev1.dts                      |   63 +
 fdts/stm32mp15xa.dtsi                         |    5 +
 fdts/stm32mp15xc.dtsi                         |    2 +
 fdts/stm32mp15xd.dtsi                         |    5 +
 fdts/stm32mp15xf.dtsi                         |   20 +
 fdts/stm32mp15xx-dhcom-som.dtsi               |   83 +-
 fdts/stm32mp15xx-dhcor-som.dtsi               |   86 +-
 fdts/stm32mp15xx-dkx.dtsi                     |   90 +-
 fdts/stm32mp15xx-osd32.dtsi                   |   83 +-
 fdts/stm32mp2-cot-descriptors.dtsi            |  194 +
 fdts/stm32mp25-bl2.dtsi                       |   88 +
 fdts/stm32mp25-bl31.dtsi                      |   24 +
 fdts/stm32mp25-ddr.dtsi                       |  253 +
 ...2mp25-ddr4-2x16Gbits-2x16bits-1200MHz.dtsi |  249 +
 fdts/stm32mp25-fw-config.dtsi                 |   48 +
 ...p25-lpddr4-1x32Gbits-1x32bits-1200MHz.dtsi |  250 +
 fdts/stm32mp25-pinctrl.dtsi                   |  111 +
 fdts/stm32mp251.dtsi                          |  675 ++
 fdts/stm32mp253.dtsi                          |    6 +
 fdts/stm32mp255.dtsi                          |    9 +
 fdts/stm32mp257.dtsi                          |    9 +
 fdts/stm32mp257f-dk-ca35tdcid-fw-config.dtsi  |   34 +
 fdts/stm32mp257f-dk-ca35tdcid-rcc.dtsi        |   97 +
 fdts/stm32mp257f-dk-fw-config.dts             |    7 +
 fdts/stm32mp257f-dk.dts                       |  227 +
 fdts/stm32mp257f-ev1-ca35tdcid-fw-config.dtsi |   34 +
 fdts/stm32mp257f-ev1-ca35tdcid-rcc.dtsi       |   97 +
 fdts/stm32mp257f-ev1-fw-config.dts            |    7 +
 fdts/stm32mp257f-ev1.dts                      |  251 +
 fdts/stm32mp25xc.dtsi                         |   41 +
 fdts/stm32mp25xf.dtsi                         |   41 +
 fdts/stm32mp25xxai-pinctrl.dtsi               |   81 +
 fdts/stm32mp25xxak-pinctrl.dtsi               |   69 +
 fdts/stm32mp25xxal-pinctrl.dtsi               |   69 +
 include/common/bl_common.ld.h                 |    3 +-
 include/common/fdt_wrappers.h                 |    4 +-
 include/drivers/arm/gicv2.h                   |   29 +
 include/drivers/fwu/fwu.h                     |    9 +-
 include/drivers/fwu/fwu_metadata.h            |   64 +-
 include/drivers/hyperflash.h                  |   38 +
 include/drivers/io/io_mtd.h                   |    7 +
 include/drivers/partition/efi.h               |   11 +-
 include/drivers/partition/partition.h         |    6 +-
 include/drivers/spi_mem.h                     |   38 +-
 include/drivers/spi_nand.h                    |    4 +
 include/drivers/spi_nor.h                     |   53 +-
 include/drivers/st/bsec.h                     |  104 +-
 include/drivers/st/bsec2_reg.h                |   15 +-
 include/drivers/st/bsec3_reg.h                |  103 +
 include/drivers/st/nvmem.h                    |   45 +
 include/drivers/st/regulator_gpio.h           |   12 +
 include/drivers/st/stm32_gpio.h               |   12 +-
 include/drivers/st/stm32_i2c.h                |   43 +-
 include/drivers/st/stm32_iwdg.h               |    2 -
 include/drivers/st/stm32_mce.h                |   46 +
 include/drivers/st/stm32_ospi.h               |   12 +
 include/drivers/st/stm32_pka.h                |   15 +-
 include/drivers/st/stm32_rifsc.h              |   17 +
 include/drivers/st/stm32mp1_clk.h             |    4 +-
 include/drivers/st/stm32mp1_ddr.h             |    3 +-
 include/drivers/st/stm32mp1_ddr_helpers.h     |   16 +-
 include/drivers/st/stm32mp1_ddr_regs.h        |    2 +
 include/drivers/st/stm32mp1_ram.h             |    3 +-
 include/drivers/st/stm32mp2_clk.h             |   44 +
 include/drivers/st/stm32mp2_ddr.h             |  147 +
 include/drivers/st/stm32mp2_ddr_helpers.h     |   38 +
 include/drivers/st/stm32mp2_ddr_regs.h        |   38 +
 include/drivers/st/stm32mp2_pwr.h             |  481 ++
 include/drivers/st/stm32mp2_ram.h             |   13 +
 include/drivers/st/stm32mp2_rcc.h             | 4982 ++++++++++++
 include/drivers/st/stm32mp2_risaf.h           |   15 +
 include/drivers/st/stm32mp_clkfunc.h          |    4 +-
 include/drivers/st/stm32mp_ddr.h              |   25 +-
 include/drivers/st/stm32mp_ddr_test.h         |   10 +-
 include/drivers/st/stm32mp_ddrctrl_regs.h     |   33 +-
 include/drivers/st/stm32mp_pmic.h             |   10 +-
 include/drivers/st/stm32mp_pmic2.h            |   51 +
 include/drivers/st/stm32mp_reset.h            |    7 +-
 include/drivers/st/stm32mp_rifsc_regs.h       |   35 +
 include/drivers/st/stm32mp_risab_regs.h       |  271 +
 include/drivers/st/stm32mp_tamp_nvram.h       |   83 +
 include/drivers/st/stpmic2.h                  |  310 +
 include/drivers/st/usb_dwc3.h                 |  241 +
 include/drivers/usb_device.h                  |   11 +
 include/dt-bindings/clock/stm32mp13-clks.h    |    8 +-
 include/dt-bindings/clock/stm32mp15-clksrc.h  |  658 +-
 include/dt-bindings/clock/stm32mp25-clks.h    |  492 ++
 include/dt-bindings/clock/stm32mp25-clksrc.h  |  226 +
 include/dt-bindings/gpio/stm32-gpio.h         |   41 +
 include/dt-bindings/power/stm32mp1-power.h    |   20 +
 include/dt-bindings/reset/stm32mp25-resets.h  |  167 +
 include/dt-bindings/soc/rif.h                 |   95 +
 include/dt-bindings/soc/stm32mp13-mce.h       |   12 +
 include/dt-bindings/soc/stm32mp25-rif.h       |  132 +
 include/lib/fconf/fconf.h                     |    4 +-
 include/lib/psci/psci.h                       |   44 +-
 include/lib/psci/psci_lib.h                   |    1 +
 include/lib/utils_def.h                       |   16 +-
 include/plat/arm/common/plat_arm.h            |    6 +
 include/plat/common/platform.h                |    2 +
 lib/libc/snprintf.c                           |    1 +
 lib/psci/aarch32/psci_helpers.S               |    5 +-
 lib/psci/aarch64/psci_helpers.S               |    5 +-
 lib/{cpus => psci}/aarch64/runtime_errata.S   |    0
 lib/psci/psci_common.c                        |  255 +-
 lib/psci/psci_lib.mk                          |    2 +-
 lib/psci/psci_main.c                          |  110 +-
 lib/psci/psci_off.c                           |   17 +
 lib/psci/psci_on.c                            |    7 -
 lib/psci/psci_private.h                       |   35 +-
 lib/psci/psci_setup.c                         |    3 +
 lib/psci/psci_suspend.c                       |   77 +-
 make_helpers/build_macros.mk                  |   13 +-
 make_helpers/defaults.mk                      |   11 +
 plat/arm/board/fvp/fvp_pm.c                   |    2 +
 plat/arm/board/fvp/include/platform_def.h     |    4 +
 plat/arm/board/fvp/platform.mk                |    2 +
 plat/arm/board/tc/platform.mk                 |    2 +-
 plat/arm/common/arm_io_storage.c              |    7 +-
 plat/arm/common/arm_pm.c                      |   12 +-
 plat/common/plat_bl_common.c                  |    8 +-
 plat/imx/common/imx_sip_handler.c             |    2 +-
 plat/imx/imx8qm/imx8qm_bl31_setup.c           |    2 +-
 plat/imx/imx8qm/imx8qm_psci.c                 |    2 +-
 plat/imx/imx8qx/imx8qx_psci.c                 |    2 +-
 plat/mediatek/common/mtk_smc_handlers.c       |    1 +
 plat/nvidia/tegra/soc/t186/plat_memctrl.c     |    6 +-
 .../common/fip_handler/ddr_fip/ddr_fip_io.mk  |    3 +-
 plat/nxp/common/fip_handler/fuse_fip/fuse.mk  |    3 +-
 plat/nxp/common/psci/plat_psci.c              |    6 +-
 plat/qti/common/src/qti_pm.c                  |   18 +-
 plat/qti/sc7280/platform.mk                   |    1 +
 plat/st/common/bl2_io_storage.c               |  396 +-
 plat/st/common/common.mk                      |  292 +
 plat/st/common/common_rules.mk                |   85 +
 plat/st/common/default_metadata.json          |   37 +
 .../include/plat_def_fip_uuid.h               |    6 +-
 plat/st/common/include/stm32cubeprogrammer.h  |   18 +-
 plat/st/common/include/stm32mp_common.h       |   91 +-
 plat/st/common/include/stm32mp_dt.h           |    8 +-
 plat/st/common/include/stm32mp_efi.h          |    5 +-
 plat/st/common/include/stm32mp_io_storage.h   |   66 +-
 .../include/stm32mp_mbedtls_config.h}         |    2 +-
 plat/st/common/include/stm32mp_svc_setup.h    |   35 +
 plat/st/common/stm32cubeprogrammer_uart.c     |  168 +-
 plat/st/common/stm32cubeprogrammer_usb.c      |  100 +-
 plat/st/common/stm32mp_common.c               |  383 +-
 plat/st/common/stm32mp_crypto_lib.c           |   40 +-
 plat/st/common/stm32mp_dt.c                   |  108 +-
 plat/st/common/stm32mp_fconf_fuse.c           |  103 +
 plat/st/common/stm32mp_fconf_io.c             |   50 +-
 .../stm32mp1_gic.c => common/stm32mp_gic.c}   |   73 +-
 plat/st/common/stm32mp_svc_setup.c            |   81 +
 plat/st/common/stm32mp_trusted_boot.c         |   18 +-
 plat/st/stm32mp1/bl2_plat_setup.c             |  370 +-
 plat/st/stm32mp1/cert_create_tbbr.mk          |    3 +-
 plat/st/stm32mp1/include/boot_api.h           |  569 +-
 plat/st/stm32mp1/include/platform_def.h       |    6 +-
 plat/st/stm32mp1/include/stm32mp1_context.h   |   28 +
 .../stm32mp1/include/stm32mp1_critic_power.h  |   16 +
 plat/st/stm32mp1/include/stm32mp1_private.h   |   54 +-
 plat/st/stm32mp1/include/stm32mp1_smc.h       |   16 -
 plat/st/stm32mp1/plat_bl2_mem_params_desc.c   |    4 +
 plat/st/stm32mp1/plat_ddr.c                   |  135 +
 plat/st/stm32mp1/plat_image_load.c            |    1 +
 plat/st/stm32mp1/platform.mk                  |  367 +-
 plat/st/stm32mp1/services/bsec_svc.c          |    9 +-
 .../st/stm32mp1/services/stm32mp1_svc_setup.c |   72 +-
 plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk    |    5 +-
 plat/st/stm32mp1/sp_min/sp_min_setup.c        |   10 +-
 plat/st/stm32mp1/stm32mp1_boot_device.c       |    3 +
 plat/st/stm32mp1/stm32mp1_context.c           |  279 +
 plat/st/stm32mp1/stm32mp1_critic_power.c      |  126 +
 .../stm32mp1/stm32mp1_critic_power_wrapper.S  |  127 +
 plat/st/stm32mp1/stm32mp1_def.h               |  125 +-
 plat/st/stm32mp1/stm32mp1_fconf_firewall.c    |   20 +-
 plat/st/stm32mp1/stm32mp1_fip_def.h           |   43 +-
 plat/st/stm32mp1/stm32mp1_pm.c                |   36 +-
 plat/st/stm32mp1/stm32mp1_private.c           |  273 +-
 plat/st/stm32mp1/stm32mp1_ssp.c               | 1048 +++
 plat/st/stm32mp1/stm32mp1_ssp.mk              |  102 +
 plat/st/stm32mp1/stm32mp1_syscfg.c            |   26 +-
 plat/st/stm32mp1/stm32mp1_tbb_cert.c          |   11 +-
 plat/st/stm32mp1/stm32mp1_usb_dfu.c           |   31 +-
 plat/st/stm32mp2/aarch64/stm32mp2.S           |   11 +
 plat/st/stm32mp2/aarch64/stm32mp2.ld.S        |   71 +
 plat/st/stm32mp2/aarch64/stm32mp2_helper.S    |  241 +
 plat/st/stm32mp2/bl2_plat_setup.c             |  785 ++
 plat/st/stm32mp2/bl31_plat_setup.c            |  181 +
 plat/st/stm32mp2/cert_create_tbbr.mk          |   20 +
 plat/st/stm32mp2/include/boot_api.h           |  406 +
 plat/st/stm32mp2/include/plat_def_fip_uuid.h  |   18 +
 plat/st/stm32mp2/include/plat_macros.S        |   13 +
 plat/st/stm32mp2/include/plat_tbbr_img_def.h  |   55 +
 plat/st/stm32mp2/include/platform_def.h       |  182 +
 plat/st/stm32mp2/include/platform_oid.h       |    7 +
 plat/st/stm32mp2/include/stm32mp2_context.h   |   22 +
 plat/st/stm32mp2/include/stm32mp2_private.h   |  104 +
 plat/st/stm32mp2/include/stm32mp2_smc.h       |   22 +
 .../stm32mp2/include/tbbr/stm32mp2_tbb_cert.h |   25 +
 plat/st/stm32mp2/plat_bl2_mem_params_desc.c   |  151 +
 plat/st/stm32mp2/plat_ddr.c                   |  215 +
 .../plat_def_uuid_config.c                    |   16 +-
 .../st/{stm32mp1 => stm32mp2}/plat_fiptool.mk |    2 +-
 plat/st/stm32mp2/plat_image_load.c            |   38 +
 plat/st/stm32mp2/platform.mk                  |  391 +
 plat/st/stm32mp2/services/stgen_svc.c         |   40 +
 plat/st/stm32mp2/services/stgen_svc.h         |   12 +
 .../st/stm32mp2/services/stm32mp2_svc_setup.c |   46 +
 plat/st/stm32mp2/stm32mp2_boot_device.c       |  184 +
 plat/st/stm32mp2/stm32mp2_context.c           |  184 +
 plat/st/stm32mp2/stm32mp2_def.h               |  608 ++
 plat/st/stm32mp2/stm32mp2_otp.c               |   42 +
 plat/st/stm32mp2/stm32mp2_pm.c                | 1135 +++
 plat/st/stm32mp2/stm32mp2_private.c           |  571 ++
 plat/st/stm32mp2/stm32mp2_pwr.c               |  179 +
 plat/st/stm32mp2/stm32mp2_syscfg.c            |  535 ++
 plat/st/stm32mp2/stm32mp2_tbb_cert.c          |   55 +
 plat/st/stm32mp2/stm32mp2_topology.c          |   59 +
 plat/st/stm32mp2/stm32mp2_usb_dfu.c           |  374 +
 plat/xilinx/common/ipi.c                      |    2 +-
 plat/xilinx/zynqmp/pm_service/pm_svc_main.c   |   26 +-
 plat/xilinx/zynqmp/zynqmp_ipi.c               |    2 +-
 services/spd/opteed/opteed_main.c             |   55 +-
 services/spd/opteed/opteed_private.h          |    3 +
 services/std_svc/spmd/spmd_main.c             |    6 +-
 tools/fiptool/Makefile                        |    9 +-
 .../plat_fiptool/arm/board/tc/plat_fiptool.mk |   12 +
 .../plat_fiptool/nxp}/plat_def_uuid_config.c  |    0
 .../plat_fiptool/st/plat_def_uuid_config.c    |   30 +
 tools/fiptool/plat_fiptool/st/plat_fiptool.mk |   25 +
 tools/fwu_gen_metadata/README.md              |   87 +
 tools/fwu_gen_metadata/fwumd_tool.py          |  181 +
 tools/fwu_gen_metadata/src/metadata.py        |  102 +
 tools/fwu_gen_metadata/src/structs.py         |  262 +
 tools/fwu_gen_metadata/src/utils.py           |   69 +
 tools/fwu_gen_metadata/src/uuid_t.py          |   79 +
 tools/fwu_gen_metadata/tests/testall.sh       |   21 +
 .../fwu_gen_metadata/tests/validate_stable.sh |    8 +
 tools/nxp/plat_fiptool/plat_fiptool.mk        |   33 -
 403 files changed, 65113 insertions(+), 3494 deletions(-)
 create mode 100644 CODE_OF_CONDUCT.md
 create mode 100644 CONTRIBUTING.md
 create mode 100644 SECURITY.md
 create mode 100644 docs/design_documents/psci_osi_mode.rst
 create mode 100644 docs/devicetree/bindings/arm/secure.txt
 create mode 100644 docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt
 create mode 100644 docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt
 create mode 100644 docs/devicetree/bindings/i2c/i2c-stm32.txt
 create mode 100644 docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt
 create mode 100644 docs/devicetree/bindings/memory-controllers/st,stm32mp2-ddr.txt
 create mode 100644 docs/devicetree/bindings/mmc/mmci.txt
 create mode 100644 docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt
 create mode 100644 docs/devicetree/bindings/power/st,stm32mp1-pwr.txt
 create mode 100644 docs/devicetree/bindings/power/st,stm32mp25-pwr.txt
 create mode 100644 docs/devicetree/bindings/power/st,stpmic1.txt
 create mode 100644 docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt
 create mode 100644 docs/devicetree/bindings/rng/st,stm32-rng.txt
 create mode 100644 docs/devicetree/bindings/serial/st,stm32-usart.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-etzpc.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-romem.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-stgen.txt
 create mode 100644 docs/devicetree/bindings/soc/st,stm32-tamp.txt
 create mode 100644 docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt
 create mode 100644 docs/plat/st/index.rst
 create mode 100644 docs/plat/st/stm32mp1.rst
 create mode 100644 docs/plat/st/stm32mp2.rst
 create mode 100644 docs/plat/st/stm32mpus.rst
 create mode 100644 drivers/mtd/hyperflash/hyperflash.c
 create mode 100644 drivers/st/bsec/bsec3.c
 create mode 100644 drivers/st/clk/clk-stm32mp2.c
 create mode 100644 drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h
 create mode 100644 drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h
 create mode 100644 drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h
 create mode 100644 drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c
 create mode 100644 drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
 create mode 100644 drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
 create mode 100644 drivers/st/ddr/stm32mp2_ddr.c
 create mode 100644 drivers/st/ddr/stm32mp2_ddr_helpers.c
 create mode 100644 drivers/st/ddr/stm32mp2_ram.c
 create mode 100644 drivers/st/mce/stm32_mce.c
 create mode 100644 drivers/st/nvmem/nvmem.c
 create mode 100644 drivers/st/nvmem/stm32mp_tamp_nvram_core.c
 create mode 100644 drivers/st/nvmem/stm32mp_tamp_nvram_mp1.c
 create mode 100644 drivers/st/nvmem/stm32mp_tamp_nvram_mp2.c
 create mode 100644 drivers/st/pmic/stm32mp_pmic2.c
 create mode 100644 drivers/st/pmic/stpmic2.c
 create mode 100644 drivers/st/regulator/regulator_gpio.c
 create mode 100644 drivers/st/reset/stm32mp2_reset.c
 create mode 100644 drivers/st/rif/stm32_rifsc.c
 create mode 100644 drivers/st/rif/stm32mp2_risaf.c
 create mode 100644 drivers/st/spi/stm32_ospi.c
 create mode 100644 drivers/st/uart/aarch64/stm32_console.S
 create mode 100644 drivers/st/usb_dwc3/usb_dwc3.c
 create mode 100644 drivers/st/usb_dwc3/usb_dwc3_regs.h
 create mode 100644 fdts/stm32mp13-fw-config-mem-encrypt.dtsi
 create mode 100644 fdts/stm32mp13-ssp-bl2.dtsi
 create mode 100644 fdts/stm32mp15-ssp-bl2.dtsi
 create mode 100644 fdts/stm32mp157a-ed1.dts
 create mode 100644 fdts/stm32mp157a-ev1.dts
 create mode 100644 fdts/stm32mp157d-dk1.dts
 create mode 100644 fdts/stm32mp157d-ed1.dts
 create mode 100644 fdts/stm32mp157d-ev1.dts
 create mode 100644 fdts/stm32mp157f-dk2.dts
 create mode 100644 fdts/stm32mp157f-ed1.dts
 create mode 100644 fdts/stm32mp157f-ev1.dts
 create mode 100644 fdts/stm32mp15xa.dtsi
 create mode 100644 fdts/stm32mp15xd.dtsi
 create mode 100644 fdts/stm32mp15xf.dtsi
 create mode 100644 fdts/stm32mp2-cot-descriptors.dtsi
 create mode 100644 fdts/stm32mp25-bl2.dtsi
 create mode 100644 fdts/stm32mp25-bl31.dtsi
 create mode 100644 fdts/stm32mp25-ddr.dtsi
 create mode 100644 fdts/stm32mp25-ddr4-2x16Gbits-2x16bits-1200MHz.dtsi
 create mode 100644 fdts/stm32mp25-fw-config.dtsi
 create mode 100644 fdts/stm32mp25-lpddr4-1x32Gbits-1x32bits-1200MHz.dtsi
 create mode 100644 fdts/stm32mp25-pinctrl.dtsi
 create mode 100644 fdts/stm32mp251.dtsi
 create mode 100644 fdts/stm32mp253.dtsi
 create mode 100644 fdts/stm32mp255.dtsi
 create mode 100644 fdts/stm32mp257.dtsi
 create mode 100644 fdts/stm32mp257f-dk-ca35tdcid-fw-config.dtsi
 create mode 100644 fdts/stm32mp257f-dk-ca35tdcid-rcc.dtsi
 create mode 100644 fdts/stm32mp257f-dk-fw-config.dts
 create mode 100644 fdts/stm32mp257f-dk.dts
 create mode 100644 fdts/stm32mp257f-ev1-ca35tdcid-fw-config.dtsi
 create mode 100644 fdts/stm32mp257f-ev1-ca35tdcid-rcc.dtsi
 create mode 100644 fdts/stm32mp257f-ev1-fw-config.dts
 create mode 100644 fdts/stm32mp257f-ev1.dts
 create mode 100644 fdts/stm32mp25xc.dtsi
 create mode 100644 fdts/stm32mp25xf.dtsi
 create mode 100644 fdts/stm32mp25xxai-pinctrl.dtsi
 create mode 100644 fdts/stm32mp25xxak-pinctrl.dtsi
 create mode 100644 fdts/stm32mp25xxal-pinctrl.dtsi
 create mode 100644 include/drivers/hyperflash.h
 create mode 100644 include/drivers/st/bsec3_reg.h
 create mode 100644 include/drivers/st/nvmem.h
 create mode 100644 include/drivers/st/regulator_gpio.h
 create mode 100644 include/drivers/st/stm32_mce.h
 create mode 100644 include/drivers/st/stm32_ospi.h
 create mode 100644 include/drivers/st/stm32_rifsc.h
 create mode 100644 include/drivers/st/stm32mp2_clk.h
 create mode 100644 include/drivers/st/stm32mp2_ddr.h
 create mode 100644 include/drivers/st/stm32mp2_ddr_helpers.h
 create mode 100644 include/drivers/st/stm32mp2_ddr_regs.h
 create mode 100644 include/drivers/st/stm32mp2_pwr.h
 create mode 100644 include/drivers/st/stm32mp2_ram.h
 create mode 100644 include/drivers/st/stm32mp2_rcc.h
 create mode 100644 include/drivers/st/stm32mp2_risaf.h
 create mode 100644 include/drivers/st/stm32mp_pmic2.h
 create mode 100644 include/drivers/st/stm32mp_rifsc_regs.h
 create mode 100644 include/drivers/st/stm32mp_risab_regs.h
 create mode 100644 include/drivers/st/stm32mp_tamp_nvram.h
 create mode 100644 include/drivers/st/stpmic2.h
 create mode 100644 include/drivers/st/usb_dwc3.h
 create mode 100644 include/dt-bindings/clock/stm32mp25-clks.h
 create mode 100644 include/dt-bindings/clock/stm32mp25-clksrc.h
 create mode 100644 include/dt-bindings/gpio/stm32-gpio.h
 create mode 100644 include/dt-bindings/power/stm32mp1-power.h
 create mode 100644 include/dt-bindings/reset/stm32mp25-resets.h
 create mode 100644 include/dt-bindings/soc/rif.h
 create mode 100644 include/dt-bindings/soc/stm32mp13-mce.h
 create mode 100644 include/dt-bindings/soc/stm32mp25-rif.h
 rename lib/{cpus => psci}/aarch64/runtime_errata.S (100%)
 create mode 100644 plat/st/common/common.mk
 create mode 100644 plat/st/common/common_rules.mk
 create mode 100644 plat/st/common/default_metadata.json
 rename plat/st/{stm32mp1 => common}/include/plat_def_fip_uuid.h (59%)
 rename plat/st/{stm32mp1/include/stm32mp1_mbedtls_config.h => common/include/stm32mp_mbedtls_config.h} (97%)
 create mode 100644 plat/st/common/include/stm32mp_svc_setup.h
 create mode 100644 plat/st/common/stm32mp_fconf_fuse.c
 rename plat/st/{stm32mp1/stm32mp1_gic.c => common/stm32mp_gic.c} (51%)
 create mode 100644 plat/st/common/stm32mp_svc_setup.c
 create mode 100644 plat/st/stm32mp1/include/stm32mp1_context.h
 create mode 100644 plat/st/stm32mp1/include/stm32mp1_critic_power.h
 create mode 100644 plat/st/stm32mp1/plat_ddr.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_context.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_critic_power.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
 create mode 100644 plat/st/stm32mp1/stm32mp1_ssp.c
 create mode 100644 plat/st/stm32mp1/stm32mp1_ssp.mk
 create mode 100644 plat/st/stm32mp2/aarch64/stm32mp2.S
 create mode 100644 plat/st/stm32mp2/aarch64/stm32mp2.ld.S
 create mode 100644 plat/st/stm32mp2/aarch64/stm32mp2_helper.S
 create mode 100644 plat/st/stm32mp2/bl2_plat_setup.c
 create mode 100644 plat/st/stm32mp2/bl31_plat_setup.c
 create mode 100644 plat/st/stm32mp2/cert_create_tbbr.mk
 create mode 100644 plat/st/stm32mp2/include/boot_api.h
 create mode 100644 plat/st/stm32mp2/include/plat_def_fip_uuid.h
 create mode 100644 plat/st/stm32mp2/include/plat_macros.S
 create mode 100644 plat/st/stm32mp2/include/plat_tbbr_img_def.h
 create mode 100644 plat/st/stm32mp2/include/platform_def.h
 create mode 100644 plat/st/stm32mp2/include/platform_oid.h
 create mode 100644 plat/st/stm32mp2/include/stm32mp2_context.h
 create mode 100644 plat/st/stm32mp2/include/stm32mp2_private.h
 create mode 100644 plat/st/stm32mp2/include/stm32mp2_smc.h
 create mode 100644 plat/st/stm32mp2/include/tbbr/stm32mp2_tbb_cert.h
 create mode 100644 plat/st/stm32mp2/plat_bl2_mem_params_desc.c
 create mode 100644 plat/st/stm32mp2/plat_ddr.c
 rename plat/st/{stm32mp1 => stm32mp2}/plat_def_uuid_config.c (54%)
 rename plat/st/{stm32mp1 => stm32mp2}/plat_fiptool.mk (89%)
 create mode 100644 plat/st/stm32mp2/plat_image_load.c
 create mode 100644 plat/st/stm32mp2/platform.mk
 create mode 100644 plat/st/stm32mp2/services/stgen_svc.c
 create mode 100644 plat/st/stm32mp2/services/stgen_svc.h
 create mode 100644 plat/st/stm32mp2/services/stm32mp2_svc_setup.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_boot_device.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_context.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_def.h
 create mode 100644 plat/st/stm32mp2/stm32mp2_otp.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_pm.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_private.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_pwr.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_syscfg.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_tbb_cert.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_topology.c
 create mode 100644 plat/st/stm32mp2/stm32mp2_usb_dfu.c
 create mode 100644 tools/fiptool/plat_fiptool/arm/board/tc/plat_fiptool.mk
 rename tools/{nxp/plat_fiptool => fiptool/plat_fiptool/nxp}/plat_def_uuid_config.c (100%)
 create mode 100644 tools/fiptool/plat_fiptool/st/plat_def_uuid_config.c
 create mode 100644 tools/fiptool/plat_fiptool/st/plat_fiptool.mk
 create mode 100644 tools/fwu_gen_metadata/README.md
 create mode 100755 tools/fwu_gen_metadata/fwumd_tool.py
 create mode 100644 tools/fwu_gen_metadata/src/metadata.py
 create mode 100644 tools/fwu_gen_metadata/src/structs.py
 create mode 100644 tools/fwu_gen_metadata/src/utils.py
 create mode 100644 tools/fwu_gen_metadata/src/uuid_t.py
 create mode 100755 tools/fwu_gen_metadata/tests/testall.sh
 create mode 100755 tools/fwu_gen_metadata/tests/validate_stable.sh
 delete mode 100644 tools/nxp/plat_fiptool/plat_fiptool.mk

diff --git a/.gitignore b/.gitignore
index 1f4efb65af..ab2c0c44fc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -31,6 +31,8 @@ tools/stm32image/*.o
 tools/stm32image/stm32image
 tools/stm32image/stm32image.exe
 tools/sptool/__pycache__/
+tools/encrypt_fw/encrypt_fw
+tools/encrypt_fw/encrypt_fw.exe
 
 # GNU GLOBAL files
 GPATH
diff --git a/CODE_OF_CONDUCT.md b/CODE_OF_CONDUCT.md
new file mode 100644
index 0000000000..bf0ca35d95
--- /dev/null
+++ b/CODE_OF_CONDUCT.md
@@ -0,0 +1,73 @@
+# Contributor Covenant Code of Conduct
+
+## Our Pledge
+
+In the interest of fostering an open and welcoming environment, we as
+contributors and maintainers pledge to making participation in our project and
+our community a harassment-free experience for everyone, regardless of age, body
+size, disability, ethnicity, sex characteristics, gender identity and expression,
+level of experience, education, socio-economic status, nationality, personal
+appearance, race, religion, or sexual identity and orientation.
+
+## Our Standards
+
+Examples of behavior that contributes to creating a positive environment
+include:
+
+* Using welcoming and inclusive language
+* Being respectful of differing viewpoints and experiences
+* Gracefully accepting constructive criticism
+* Focusing on what is best for the community
+* Showing empathy towards other community members
+
+Examples of unacceptable behavior by participants include:
+
+* The use of sexualized language or imagery and unwelcome sexual attention or
+ advances
+* Trolling, insulting/derogatory comments, and personal or political attacks
+* Public or private harassment
+* Publishing others' private information, such as a physical or electronic
+ address, without explicit permission
+* Other conduct which could reasonably be considered inappropriate in a
+ professional setting
+
+## Our Responsibilities
+
+Project maintainers are responsible for clarifying the standards of acceptable
+behavior and are expected to take appropriate and fair corrective action in
+response to any instances of unacceptable behavior.
+
+Project maintainers have the right and responsibility to remove, edit, or
+reject comments, commits, code, wiki edits, issues, and other contributions
+that are not aligned to this Code of Conduct, or to ban temporarily or
+permanently any contributor for other behaviors that they deem inappropriate,
+threatening, offensive, or harmful.
+
+## Scope
+
+This Code of Conduct applies both within project spaces and in public spaces
+when an individual is representing the project or its community. Examples of
+representing a project or community include using an official project e-mail
+address, posting via an official social media account, or acting as an appointed
+representative at an online or offline event. Representation of a project may be
+further defined and clarified by project maintainers.
+
+## Enforcement
+
+Instances of abusive, harassing, or otherwise unacceptable behavior may be
+reported by contacting the project team via this [link](https://www.st.com/content/st_com/en/contact-us.html).
+All complaints will be reviewed and investigated and will result in a response that
+is deemed necessary and appropriate to the circumstances. The project team is
+obligated to maintain confidentiality with regard to the reporter of an incident.
+Further details of specific enforcement policies may be posted separately.
+
+Project maintainers who do not follow or enforce the Code of Conduct in good
+faith may face temporary or permanent repercussions as determined by other
+members of the project's leadership.
+
+## Attribution
+
+This Code of Conduct is adapted from the [Contributor Covenant](https://www.contributor-covenant.org), version 1.4,
+available [here](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html).
+
+For answers to common questions about this code of conduct, refer to the FAQ section [here](https://www.contributor-covenant.org/faq).
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000000..3d1bacd78a
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+﻿# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/Makefile b/Makefile
index bfd6aaf359..8556593f65 100644
--- a/Makefile
+++ b/Makefile
@@ -176,6 +176,11 @@ FIP_DEPS += enctool
 FWU_FIP_DEPS += enctool
 endif
 
+ifeq (${PSA_FWU_SUPPORT},1)
+FWUMD_ARGS += --nb-fw-imgs ${NR_OF_FW_BANKS}
+FWUMD_ARGS += --nb-banks ${NR_OF_IMAGES_IN_FW_BANK}
+endif
+
 ################################################################################
 # Toolchain
 ################################################################################
@@ -347,27 +352,53 @@ ASFLAGS_aarch64		=	$(march64-directive)
 # General warnings
 WARNINGS		:=	-Wall -Wmissing-include-dirs -Wunused	\
 				-Wdisabled-optimization -Wvla -Wshadow	\
-				-Wno-unused-parameter -Wredundant-decls
+				-Wredundant-decls
+# stricter warnings
+WARNINGS		+=	-Wextra -Wno-trigraphs
+# too verbose for generic build
+WARNINGS		+=	-Wno-missing-field-initializers \
+				-Wno-type-limits -Wno-sign-compare \
+# on clang this flag gets reset if -Wextra is set after it. No difference on gcc
+WARNINGS		+=	-Wno-unused-parameter
 
 # Additional warnings
-# Level 1
-WARNING1 := -Wextra
-WARNING1 += -Wmissing-format-attribute
-WARNING1 += -Wmissing-prototypes
-WARNING1 += -Wold-style-definition
-
-# Level 2
-WARNING2 := -Waggregate-return
-WARNING2 += -Wcast-align
-WARNING2 += -Wnested-externs
-
+# Level 1 - infrequent warnings we should have none of
+# full -Wextra
+WARNING1 += -Wsign-compare
+WARNING1 += -Wtype-limits
+WARNING1 += -Wmissing-field-initializers
+
+# Level 2 - problematic warnings that we want
+# zlib, compiler-rt, coreboot, and mbdedtls blow up with these
+# TODO: disable just for them and move into default build
+WARNING2 += -Wold-style-definition
+WARNING2 += -Wmissing-prototypes
+WARNING2 += -Wmissing-format-attribute
+# TF-A aims to comply with this eventually. Effort too large at present
+WARNING2 += -Wundef
+# currently very involved and many platforms set this off
+WARNING2 += -Wunused-const-variable=2
+
+# Level 3 - very pedantic, frequently ignored
 WARNING3 := -Wbad-function-cast
+WARNING3 += -Waggregate-return
+WARNING3 += -Wnested-externs
+WARNING3 += -Wcast-align
 WARNING3 += -Wcast-qual
 WARNING3 += -Wconversion
 WARNING3 += -Wpacked
 WARNING3 += -Wpointer-arith
 WARNING3 += -Wswitch-default
 
+# Setting W is quite verbose and most warnings will be pre-existing issues
+# outside of the contributor's control. Don't fail the build on them so warnings
+# can be seen and hopefully addressed
+ifdef W
+ifneq (${W},0)
+E	 ?= 0
+endif
+endif
+
 ifeq (${W},1)
 WARNINGS += $(WARNING1)
 else ifeq (${W},2)
@@ -976,6 +1007,10 @@ ENCTOOL			?=	${ENCTOOLPATH}/encrypt_fw${BIN_EXT}
 FIPTOOLPATH		?=	tools/fiptool
 FIPTOOL			?=	${FIPTOOLPATH}/fiptool${BIN_EXT}
 
+# Variables for use with Firmware Update Metadata
+FWUMDTOOLPATH		?=	tools/fwu_gen_metadata/
+FWUMDTOOL		?=	${FWUMDTOOLPATH}/fwumd_tool.py
+
 # Variables for use with sptool
 SPTOOLPATH		?=	tools/sptool
 SPTOOL			?=	${SPTOOLPATH}/sptool.py
@@ -990,6 +1025,7 @@ PYTHON			?=	python3
 # Variables for use with PRINT_MEMORY_MAP
 PRINT_MEMORY_MAP_PATH		?=	tools/memory
 PRINT_MEMORY_MAP		?=	${PRINT_MEMORY_MAP_PATH}/print_memory_map.py
+INVERTED_MEMMAP			?=	0
 
 # Variables for use with documentation build using Sphinx tool
 DOCS_PATH		?=	docs
@@ -1064,6 +1100,7 @@ $(eval $(call assert_booleans,\
         PLAT_RSS_NOT_SUPPORTED \
         PROGRAMMABLE_RESET_ADDRESS \
         PSCI_EXTENDED_STATE_ID \
+        PSCI_OS_INIT_MODE \
         RESET_TO_BL31 \
         RESET_TO_BL31_WITH_PARAMS \
         SAVE_KEYS \
@@ -1094,6 +1131,7 @@ $(eval $(call assert_booleans,\
         COT_DESC_IN_DTB \
         USE_SP804_TIMER \
         PSA_FWU_SUPPORT \
+	PSA_FWU_METADATA_FW_STORE_DESC \
         ENABLE_SYS_REG_TRACE_FOR_NS \
         ENABLE_MPMM \
         ENABLE_MPMM_FCONF \
@@ -1207,6 +1245,7 @@ $(eval $(call add_defines,\
         PLAT_RSS_NOT_SUPPORTED \
         PROGRAMMABLE_RESET_ADDRESS \
         PSCI_EXTENDED_STATE_ID \
+        PSCI_OS_INIT_MODE \
         RAS_EXTENSION \
         RESET_TO_BL31 \
         RESET_TO_BL31_WITH_PARAMS \
@@ -1247,6 +1286,7 @@ $(eval $(call add_defines,\
         NR_OF_FW_BANKS \
         NR_OF_IMAGES_IN_FW_BANK \
         PSA_FWU_SUPPORT \
+	PSA_FWU_METADATA_FW_STORE_DESC \
         ENABLE_BRBE_FOR_NS \
         ENABLE_TRBE_FOR_NS \
         ENABLE_SYS_REG_TRACE_FOR_NS \
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 0000000000..4b3e4e6ba5
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,8 @@
+# Report potential product security vulnerabilities
+ST places a high priority on security, and our Product Security Incident Response Team (PSIRT) is committed to rapidly addressing potential security vulnerabilities affecting our products. PSIRT's long history and vast experience in security allows ST to perform clear analyses and provide appropriate guidance on mitigations  and solutions when applicable.
+If you wish to report potential security vulnerabilities regarding our products, **please do not report them through public GitHub issues.** Instead, we encourage you to report them to our ST PSIRT following the process described at: **https://www.st.com/content/st_com/en/security/report-vulnerabilities.html**
+
+### IMPORTANT - READ CAREFULLY:
+STMicroelectronics International N.V., on behalf of itself, its affiliates and  subsidiaries, (collectively “ST”) takes all potential security vulnerability reports or other related communications (“Report(s)”)  seriously. In order to review Your Report (the terms “You” and “Yours”  include your employer, and all affiliates, subsidiaries and related  persons or entities) and take actions as deemed appropriate, ST requires that we have the rights and Your permission to do so.
+As such, by submitting Your Report to ST, You agree that You have the right to do so, and You grant to ST the rights to use the Report for purposes related to security vulnerability analysis, testing, correction, patching, reporting and any other related purpose or function.
+By submitting Your Report, You agree that ST’s [Privacy Policy](https://www.st.com/content/st_com/en/common/privacy-portal.html) applies to all related communications.
diff --git a/bl2/bl2_main.c b/bl2/bl2_main.c
index 5da8037954..a2f6ccfaec 100644
--- a/bl2/bl2_main.c
+++ b/bl2/bl2_main.c
@@ -87,7 +87,9 @@ void bl2_main(void)
 	bl2_arch_setup();
 
 #if PSA_FWU_SUPPORT
-	fwu_init();
+	if (plat_fwu_is_enabled()) {
+		fwu_init();
+	}
 #endif /* PSA_FWU_SUPPORT */
 
 	crypto_mod_init();
diff --git a/changelog.yaml b/changelog.yaml
index 433346427e..fc90560398 100644
--- a/changelog.yaml
+++ b/changelog.yaml
@@ -537,6 +537,9 @@ subsections:
               - title: STM32MP15
                 scope: stm32mp15
 
+          - title: STM32MP2
+            scope: stm32mp2
+
       - title: Texas Instruments
         scope: ti
 
@@ -1044,12 +1047,27 @@ subsections:
           - title: GPIO
             scope: st-gpio
 
+          - title: NVMEM
+            scope: st-nvmem
+
+          - title: Regulator
+            scope: st-regulator
+
+          - title: Reset
+            scope: st-reset
+
+          - title: Resource Isolation Framework
+            scope: st-rif
+
           - title: SDMMC2
             scope: st-sdmmc2
 
             deprecated:
               - stm32_sdmmc2
 
+          - title: SPI
+            scope: st-spi
+
           - title: ST PMIC
             scope: st-pmic
 
@@ -1059,15 +1077,6 @@ subsections:
           - title: STPMIC1
             scope: stpmic1
 
-          - title: Regulator
-            scope: st-regulator
-
-          - title: Reset
-            scope: st-reset
-
-          - title: SPI
-            scope: st-spi
-
           - title: UART
             scope: st-uart
 
@@ -1154,6 +1163,9 @@ subsections:
               - title: STM32MP15
                 scope: stm32mp15-fdts
 
+          - title: STM32MP2
+            scope: stm32mp2-fdts
+
       - title: PIE
         scope: pie
 
diff --git a/common/aarch32/debug.S b/common/aarch32/debug.S
index ae0bb7ac7f..34f636372a 100644
--- a/common/aarch32/debug.S
+++ b/common/aarch32/debug.S
@@ -115,10 +115,10 @@ endfunc asm_assert
 
 /*
  * This function prints a string from address in r4
- * Clobber: lr, r0 - r4
+ * Clobber: lr, r0 - r4, r7
  */
 func asm_print_str
-	mov	r3, lr
+	mov	r7, lr
 1:
 	ldrb	r0, [r4], #0x1
 	cmp	r0, #0
@@ -126,20 +126,20 @@ func asm_print_str
 	bl	plat_crash_console_putc
 	b	1b
 2:
-	bx	r3
+	bx	r7
 endfunc asm_print_str
 
 /*
  * This function prints a hexadecimal number in r4.
  * In: r4 = the hexadecimal to print.
- * Clobber: lr, r0 - r3, r5
+ * Clobber: lr, r0 - r3, r5, r7
  */
 func asm_print_hex
 	mov	r5, #32  /* No of bits to convert to ascii */
 
 	/* Convert to ascii number of bits in r5 */
 asm_print_hex_bits:
-	mov	r3, lr
+	mov	r7, lr
 1:
 	sub	r5, r5, #4
 	lsr	r0, r4, r5
@@ -155,7 +155,7 @@ asm_print_hex_bits:
 	bl	plat_crash_console_putc
 	cmp	r5, #0
 	bne	1b
-	bx	r3
+	bx	r7
 endfunc asm_print_hex
 
 	/***********************************************************
diff --git a/common/bl_common.c b/common/bl_common.c
index 8fce02fbad..901e0bdf6e 100644
--- a/common/bl_common.c
+++ b/common/bl_common.c
@@ -216,11 +216,15 @@ int load_auth_image(unsigned int image_id, image_info_t *image_data)
  * when PSA FWU is enabled.
  */
 #if PSA_FWU_SUPPORT
-	err = load_auth_image_internal(image_id, image_data);
+	do {
+		err = load_auth_image_internal(image_id, image_data);
+	} while ((err != 0) && (plat_try_backup_partitions(image_id) != 0));
 #else
 	do {
 		err = load_auth_image_internal(image_id, image_data);
-	} while ((err != 0) && (plat_try_next_boot_source() != 0));
+	} while (((err != 0) && ((plat_try_next_boot_source() != 0) ||
+				 (plat_try_backup_partitions(image_id) != 0))));
+
 #endif /* PSA_FWU_SUPPORT */
 
 	if (err == 0) {
diff --git a/common/fdt_wrappers.c b/common/fdt_wrappers.c
index 1b065b1e2c..88265c54db 100644
--- a/common/fdt_wrappers.c
+++ b/common/fdt_wrappers.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2023, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -88,6 +88,19 @@ int fdt_read_uint64(const void *dtb, int node, const char *prop_name,
 	return 0;
 }
 
+uint64_t fdt_read_uint64_default(const void *dtb, int node,
+				 const char *prop_name, uint64_t dflt_value)
+{
+	uint64_t ret = dflt_value;
+	int err = fdt_read_uint64(dtb, node, prop_name, &ret);
+
+	if (err < 0) {
+		return dflt_value;
+	}
+
+	return ret;
+}
+
 /*
  * Read bytes from a given property of the given node. Any number of
  * bytes of the property can be read. The fdt pointer is updated.
diff --git a/docs/Makefile b/docs/Makefile
index 3dd7ebc4db..9a8f5422a8 100644
--- a/docs/Makefile
+++ b/docs/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2019-2020, ARM Limited. All rights reserved.
+# Copyright (c) 2019-2023, ARM Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -13,13 +13,17 @@ SPHINXPROJ    = TrustedFirmware-A
 SOURCEDIR     = .
 BUILDDIR      = build
 
+ifndef Q
+	Q:=@
+endif
+
 # Put it first so that "make" without argument is like "make help".
 help:
-	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
+	${Q}$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
 
 .PHONY: help Makefile
 
 # Catch-all target: route all unknown targets to Sphinx using the new
 # "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
 %: Makefile
-	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
+	${Q}$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
diff --git a/docs/about/maintainers.rst b/docs/about/maintainers.rst
index 9a2ae73e73..3356d79b83 100644
--- a/docs/about/maintainers.rst
+++ b/docs/about/maintainers.rst
@@ -733,6 +733,7 @@ STM32MP1 platform port
 ^^^^^^^^^^^^^^^^^^^^^^
 :|M|: Yann Gautier <yann.gautier@st.com>
 :|G|: `Yann-lms`_
+:|F|: docs/plat/st/*
 :|F|: docs/plat/stm32mp1.rst
 :|F|: drivers/st/
 :|F|: fdts/stm32\*
diff --git a/docs/components/firmware-update.rst b/docs/components/firmware-update.rst
index 1ba1e1c6ee..eda78525a9 100644
--- a/docs/components/firmware-update.rst
+++ b/docs/components/firmware-update.rst
@@ -494,4 +494,4 @@ This is only allowed if the image is not being executed.
 .. _Universally Unique Identifier: https://tools.ietf.org/rfc/rfc4122.txt
 .. |Flow Diagram| image:: ../resources/diagrams/fwu_flow.png
 .. |FWU state machine| image:: ../resources/diagrams/fwu_states.png
-.. _PSA FW update specification: https://developer.arm.com/documentation/den0118/a/
+.. _PSA FW update specification: https://developer.arm.com/documentation/den0118/latest/
diff --git a/docs/design_documents/index.rst b/docs/design_documents/index.rst
index 3e20c07ca4..ac8d56d919 100644
--- a/docs/design_documents/index.rst
+++ b/docs/design_documents/index.rst
@@ -9,6 +9,7 @@ Design Documents
    context_mgmt_rework
    measured_boot_poc
    drtm_poc
+   psci_osi_mode
 
 --------------
 
diff --git a/docs/design_documents/psci_osi_mode.rst b/docs/design_documents/psci_osi_mode.rst
new file mode 100644
index 0000000000..a6e1bdf0ef
--- /dev/null
+++ b/docs/design_documents/psci_osi_mode.rst
@@ -0,0 +1,718 @@
+PSCI OS-initiated mode
+======================
+
+:Author: Maulik Shah & Wing Li
+:Organization: Qualcomm Innovation Center, Inc. & Google LLC
+:Contact: Maulik Shah <quic_mkshah@quicinc.com> & Wing Li <wingers@google.com>
+:Status: Accepted
+
+.. contents:: Table of Contents
+
+Introduction
+------------
+
+Power state coordination
+^^^^^^^^^^^^^^^^^^^^^^^^
+
+A power domain topology is a logical hierarchy of power domains in a system that
+arises from the physical dependencies between power domains.
+
+Local power states describe power states for an individual node, and composite
+power states describe the combined power states for an individual node and its
+parent node(s).
+
+Entry into low-power states for a topology node above the core level requires
+coordinating its children nodes. For example, in a system with a power domain
+that encompasses a shared cache, and a separate power domain for each core that
+uses the shared cache, the core power domains must be powered down before the
+shared cache power domain can be powered down.
+
+PSCI supports two modes of power state coordination: platform-coordinated and
+OS-initiated.
+
+Platform-coordinated
+~~~~~~~~~~~~~~~~~~~~
+
+Platform-coordinated mode is the default mode of power state coordination, and
+is currently the only supported mode in TF-A.
+
+In platform-coordinated mode, the platform is responsible for coordinating power
+states, and chooses the deepest power state for a topology node that can be
+tolerated by its children.
+
+OS-initiated
+~~~~~~~~~~~~
+
+OS-initiated mode is optional.
+
+In OS-initiated mode, the calling OS is responsible for coordinating power
+states, and may request for a topology node to enter a low-power state when
+its last child enters the low-power state.
+
+Motivation
+----------
+
+There are two reasons why OS-initiated mode might be a more suitable option than
+platform-coordinated mode for a platform.
+
+Scalability
+^^^^^^^^^^^
+
+In platform-coordinated mode, each core independently selects their own local
+power states, and doesn't account for composite power states that are shared
+between cores.
+
+In OS-initiated mode, the OS has knowledge of the next wakeup event for each
+core, and can have more precise control over the entry, exit, and wakeup
+latencies when deciding if a composite power state (e.g. for a cluster) is
+appropriate. This is especially important for multi-cluster SMP systems and
+heterogeneous systems like big.LITTLE, where different processor types can have
+different power efficiencies.
+
+Simplicity
+^^^^^^^^^^
+
+In platform-coordinated mode, the OS doesn't have visibility when the last core
+at a power level enters a low-power state. If the OS wants to perform last man
+activity (e.g. powering off a shared resource when it is no longer needed), it
+would have to communicate with an API side channel to know when it can do so.
+This could result in a design smell where the platform is using
+platform-coordinated mode when it should be using OS-initiated mode instead.
+
+In OS-initiated mode, the OS can perform last man activity if it selects a
+composite power state when the last core enters a low-power state. This
+eliminates the need for a side channel, and uses the well documented API between
+the OS and the platform.
+
+Current vendor implementations and workarounds
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+* STMicroelectronics
+
+  * For their ARM32 platforms, they're using OS-initiated mode implemented in
+    OP-TEE.
+  * For their future ARM64 platforms, they are interested in using OS-initiated
+    mode in TF-A.
+
+* Qualcomm
+
+  * For their mobile platforms, they're using OS-initiated mode implemented in
+    their own custom secure monitor firmware.
+  * For their Chrome OS platforms, they're using platform-coordinated mode in
+    TF-A with custom driver logic to perform last man activity.
+
+* Google
+
+  * They're using platform-coordinated mode in TF-A with custom driver logic to
+    perform last man activity.
+
+Both Qualcomm and Google would like to be able to use OS-initiated mode in TF-A
+in order to simplify custom driver logic.
+
+Requirements
+------------
+
+PSCI_FEATURES
+^^^^^^^^^^^^^
+
+PSCI_FEATURES is for checking whether or not a PSCI function is implemented and
+what its properties are.
+
+.. c:macro:: PSCI_FEATURES
+
+   :param func_id: 0x8400_000A.
+   :param psci_func_id: the function ID of a PSCI function.
+   :retval NOT_SUPPORTED: if the function is not implemented.
+   :retval feature flags associated with the function: if the function is
+       implemented.
+
+CPU_SUSPEND feature flags
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+* Reserved, bits[31:2]
+* Power state parameter format, bit[1]
+
+  * A value of 0 indicates the original format is used.
+  * A value of 1 indicates the extended format is used.
+
+* OS-initiated mode, bit[0]
+
+  * A value of 0 indicates OS-initiated mode is not supported.
+  * A value of 1 indicates OS-initiated mode is supported.
+
+See sections 5.1.14 and 5.15 of the PSCI spec (DEN0022D.b) for more details.
+
+PSCI_SET_SUSPEND_MODE
+^^^^^^^^^^^^^^^^^^^^^
+
+PSCI_SET_SUSPEND_MODE is for switching between the two different modes of power
+state coordination.
+
+.. c:macro:: PSCI_SET_SUSPEND_MODE
+
+   :param func_id: 0x8400_000F.
+   :param mode: 0 indicates platform-coordinated mode, 1 indicates OS-initiated
+       mode.
+   :retval SUCCESS: if the request is successful.
+   :retval NOT_SUPPORTED: if OS-initiated mode is not supported.
+   :retval INVALID_PARAMETERS: if the requested mode is not a valid value (0 or
+       1).
+   :retval DENIED: if the cores are not in the correct state.
+
+Switching from platform-coordinated to OS-initiated is only allowed if the
+following conditions are met:
+
+* All cores are in one of the following states:
+
+  * Running.
+  * Off, through a call to CPU_OFF or not yet booted.
+  * Suspended, through a call to CPU_DEFAULT_SUSPEND.
+
+* None of the cores has called CPU_SUSPEND since the last change of mode or
+  boot.
+
+Switching from OS-initiated to platform-coordinated is only allowed if all cores
+other than the calling core are off, either through a call to CPU_OFF or not yet
+booted.
+
+If these conditions are not met, the PSCI implementation must return DENIED.
+
+See sections 5.1.19 and 5.20 of the PSCI spec (DEN0022D.b) for more details.
+
+CPU_SUSPEND
+^^^^^^^^^^^
+
+CPU_SUSPEND is for moving a topology node into a low-power state.
+
+.. c:macro:: CPU_SUSPEND
+
+   :param func_id: 0xC400_0001.
+   :param power_state: the requested low-power state to enter.
+   :param entry_point_address: the address at which the core must resume
+       execution following wakeup from a powerdown state.
+   :param context_id: this field specifies a pointer to the saved context that
+       must be restored on a core following wakeup from a powerdown state.
+   :retval SUCCESS: if the request is successful.
+   :retval INVALID_PARAMETERS: in OS-initiated mode, this error is returned when
+       a low-power state is requested for a topology node above the core level,
+       and at least one of the node's children is in a local low-power state
+       that is incompatible with the request.
+   :retval INVALID_ADDRESS: if the entry_point_address argument is invalid.
+   :retval DENIED: only in OS-initiated mode; this error is returned when a
+       low-power state is requested for a topology node above the core level,
+       and at least one of the node's children is running, i.e. not in a
+       low-power state.
+
+In platform-coordinated mode, the PSCI implementation coordinates requests from
+all cores to determine the deepest power state to enter.
+
+In OS-initiated mode, the calling OS is making an explicit request for a
+specific power state, as opposed to expressing a vote. The PSCI implementation
+must comply with the request, unless the request is not consistent with the
+implementation's view of the system's state, in which case, the implementation
+must return INVALID_PARAMETERS or DENIED.
+
+See sections 5.1.2 and 5.4 of the PSCI spec (DEN0022D.b) for more details.
+
+Power state formats
+~~~~~~~~~~~~~~~~~~~
+
+Original format
+
+* Power Level, bits[25:24]
+
+  * The requested level in the power domain topology to enter a low-power
+    state.
+
+* State Type, bit[16]
+
+  * A value of 0 indicates a standby or retention state.
+  * A value of 1 indicates a powerdown state.
+
+* State ID, bits[15:0]
+
+  * Field to specify the requested composite power state.
+  * The state ID encodings must uniquely describe every possible composite
+    power state.
+  * In OS-initiated mode, the state ID encoding must allow expressing the
+    power level at which the calling core is the last to enter a powerdown
+    state.
+
+Extended format
+
+* State Type, bit[30]
+* State ID, bits[27:0]
+
+Races in OS-initiated mode
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+In OS-initiated mode, there are race windows where the OS's view and
+implementation's view of the system's state differ. It is possible for the OS to
+make requests that are invalid given the implementation's view of the system's
+state. For example, the OS might request a powerdown state for a node from one
+core, while at the same time, the implementation observes that another core in
+that node is powering up.
+
+To address potential race conditions in power state requests:
+
+* The calling OS must specify in each CPU_SUSPEND request the deepest power
+  level for which it sees the calling core as the last running core (last man).
+  This is required even if the OS doesn't want the node at that power level to
+  enter a low-power state.
+* The implementation must validate that the requested power states in the
+  CPU_SUSPEND request are consistent with the system's state, and that the
+  calling core is the last core running at the requested power level, or deny
+  the request otherwise.
+
+See sections 4.2.3.2, 6.2, and 6.3 of the PSCI spec (DEN0022D.b) for more
+details.
+
+Caveats
+-------
+
+CPU_OFF
+^^^^^^^
+
+CPU_OFF is always platform-coordinated, regardless of whether the power state
+coordination mode for suspend is platform-coordinated or OS-initiated. If all
+cores in a topology node call CPU_OFF, the last core will power down the node.
+
+In OS-initiated mode, if a subset of the cores in a topology node has called
+CPU_OFF, the last running core may call CPU_SUSPEND to request a powerdown state
+at or above that node's power level.
+
+See section 5.5.2 of the PSCI spec (DEN0022D.b) for more details.
+
+Implementation
+--------------
+
+Current implementation of platform-coordinated mode
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+Platform-coordinated is currently the only supported power state coordination
+mode in TF-A.
+
+The functions of interest in the ``psci_cpu_suspend`` call stack are as follows:
+
+* ``psci_validate_power_state``
+
+  * This function calls a platform specific ``validate_power_state`` handler,
+    which takes the ``power_state`` parameter, and updates the ``state_info``
+    object with the requested states for each power level.
+
+* ``psci_find_target_suspend_lvl``
+
+  * This function takes the ``state_info`` object containing the requested power
+    states for each power level, and returns the deepest power level that was
+    requested to enter a low power state, i.e. the target power level.
+
+* ``psci_do_state_coordination``
+
+  * This function takes the target power level and the ``state_info`` object
+    containing the requested power states for each power level, and updates the
+    ``state_info`` object with the coordinated target power state for each
+    level.
+
+* ``pwr_domain_suspend``
+
+  * This is a platform specific handler that takes the ``state_info`` object
+    containing the target power states for each power level, and transitions
+    each power level to the specified power state.
+
+Proposed implementation of OS-initiated mode
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+To add support for OS-initiated mode, the following changes are proposed:
+
+* Add a boolean build option ``PSCI_OS_INIT_MODE`` for a platform to enable
+  optional support for PSCI OS-initiated mode. This build option defaults to 0.
+
+.. note::
+
+   If ``PSCI_OS_INIT_MODE=0``, the following changes will not be compiled into
+   the build.
+
+* Update ``psci_features`` to return 1 in bit[0] to indicate support for
+  OS-initiated mode for CPU_SUSPEND.
+* Define a ``suspend_mode`` enum: ``PLAT_COORD`` and ``OS_INIT``.
+* Define a ``psci_suspend_mode`` global variable with a default value of
+  ``PLAT_COORD``.
+* Implement a new function handler ``psci_set_suspend_mode`` for
+  PSCI_SET_SUSPEND_MODE.
+* Since ``psci_validate_power_state`` calls a platform specific
+  ``validate_power_state`` handler, the platform implementation should populate
+  the ``state_info`` object based on the state ID from the given ``power_state``
+  parameter.
+* ``psci_find_target_suspend_lvl`` remains unchanged.
+* Implement a new function ``psci_validate_state_coordination`` that ensures the
+  request satisfies the following conditions, and denies any requests
+  that don't:
+
+  * The requested power states for each power level are consistent with the
+    system's state
+  * The calling core is the last core running at the requested power level
+
+  This function differs from ``psci_do_state_coordination`` in that:
+
+  * The ``psci_req_local_pwr_states`` map is not modified if the request were to
+    be denied
+  * The ``state_info`` argument is never modified since it contains the power
+    states requested by the calling OS
+
+* Update ``psci_cpu_suspend_start`` to do the following:
+
+  * If ``PSCI_SUSPEND_MODE`` is ``PLAT_COORD``, call
+    ``psci_do_state_coordination``.
+  * If ``PSCI_SUSPEND_MODE`` is ``OS_INIT``, call
+    ``psci_validate_state_coordination``. If validation fails, propagate the
+    error up the call stack.
+
+* Add a new optional member ``pwr_domain_validate_suspend`` to
+  ``plat_psci_ops_t`` to allow the platform to optionally perform validations
+  based on hardware states.
+
+* The platform specific ``pwr_domain_suspend`` handler remains unchanged.
+
+.. image:: ../resources/diagrams/psci-osi-mode.png
+
+Testing
+-------
+
+The proposed patches can be found at
+https://review.trustedfirmware.org/q/topic:psci-osi.
+
+Testing on FVP and Google platforms
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The proposed patches add a new CPU Suspend in OSI mode test suite to TF-A Tests.
+This has been enabled and verified on the FVP_Base_RevC-2xAEMvA platform and
+Google platforms, and excluded from all other platforms via the build option
+``PLAT_TESTS_SKIP_LIST``.
+
+Testing on STM32MP15
+^^^^^^^^^^^^^^^^^^^^
+
+The proposed patches have been tested and verified on the STM32MP15 platform,
+which has a single cluster with 2 CPUs, by Gabriel Fernandez
+<gabriel.fernandez@st.com> from STMicroelectronics with this device tree
+configuration:
+
+.. code-block:: devicetree
+
+   cpus {
+           #address-cells = <1>;
+           #size-cells = <0>;
+
+           cpu0: cpu@0 {
+                   device_type = "cpu";
+                   compatible = "arm,cortex-a7";
+                   reg = <0>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD0>;
+                   power-domain-names = "psci";
+           };
+           cpu1: cpu@1 {
+                   device_type = "cpu";
+                   compatible = "arm,cortex-a7";
+                   reg = <1>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD1>;
+                   power-domain-names = "psci";
+           };
+
+           idle-states {
+                   cpu_retention: cpu-retention {
+                           compatible = "arm,idle-state";
+                           arm,psci-suspend-param = <0x00000001>;
+                           entry-latency-us = <130>;
+                           exit-latency-us = <620>;
+                           min-residency-us = <700>;
+                           local-timer-stop;
+                   };
+           };
+
+           domain-idle-states {
+                   CLUSTER_STOP: core-power-domain {
+                           compatible = "domain-idle-state";
+                           arm,psci-suspend-param = <0x01000001>;
+                           entry-latency-us = <230>;
+                           exit-latency-us = <720>;
+                           min-residency-us = <2000>;
+                           local-timer-stop;
+                   };
+           };
+   };
+
+   psci {
+           compatible = "arm,psci-1.0";
+           method = "smc";
+
+           CPU_PD0: power-domain-cpu0 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&pd_core>;
+                   domain-idle-states = <&cpu_retention>;
+           };
+
+           CPU_PD1: power-domain-cpu1 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&pd_core>;
+                   domain-idle-states = <&cpu_retention>;
+           };
+
+           pd_core: power-domain-cluster {
+                   #power-domain-cells = <0>;
+                   domain-idle-states = <&CLUSTER_STOP>;
+           };
+   };
+
+Testing on Qualcomm SC7280
+^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The proposed patches have been tested and verified on the SC7280 platform by
+Maulik Shah <quic_mkshah@quicinc.com> from Qualcomm with this device tree
+configuration:
+
+.. code-block:: devicetree
+
+   cpus {
+           #address-cells = <2>;
+           #size-cells = <0>;
+
+           CPU0: cpu@0 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x0>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD0>;
+                   power-domain-names = "psci";
+           };
+
+           CPU1: cpu@100 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x100>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD1>;
+                   power-domain-names = "psci";
+           };
+
+           CPU2: cpu@200 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x200>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD2>;
+                   power-domain-names = "psci";
+           };
+
+           CPU3: cpu@300 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x300>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD3>;
+                   power-domain-names = "psci";
+           }
+
+           CPU4: cpu@400 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x400>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD4>;
+                   power-domain-names = "psci";
+           };
+
+           CPU5: cpu@500 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x500>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD5>;
+                   power-domain-names = "psci";
+           };
+
+           CPU6: cpu@600 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x600>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD6>;
+                   power-domain-names = "psci";
+           };
+
+           CPU7: cpu@700 {
+                   device_type = "cpu";
+                   compatible = "arm,kryo";
+                   reg = <0x0 0x700>;
+                   enable-method = "psci";
+                   power-domains = <&CPU_PD7>;
+                   power-domain-names = "psci";
+           };
+
+           idle-states {
+                   entry-method = "psci";
+
+                   LITTLE_CPU_SLEEP_0: cpu-sleep-0-0 {
+                           compatible = "arm,idle-state";
+                           idle-state-name = "little-power-down";
+                           arm,psci-suspend-param = <0x40000003>;
+                           entry-latency-us = <549>;
+                           exit-latency-us = <901>;
+                           min-residency-us = <1774>;
+                           local-timer-stop;
+                   };
+
+                   LITTLE_CPU_SLEEP_1: cpu-sleep-0-1 {
+                           compatible = "arm,idle-state";
+                           idle-state-name = "little-rail-power-down";
+                           arm,psci-suspend-param = <0x40000004>;
+                           entry-latency-us = <702>;
+                           exit-latency-us = <915>;
+                           min-residency-us = <4001>;
+                           local-timer-stop;
+                   };
+
+                   BIG_CPU_SLEEP_0: cpu-sleep-1-0 {
+                           compatible = "arm,idle-state";
+                           idle-state-name = "big-power-down";
+                           arm,psci-suspend-param = <0x40000003>;
+                           entry-latency-us = <523>;
+                           exit-latency-us = <1244>;
+                           min-residency-us = <2207>;
+                           local-timer-stop;
+                   };
+
+                   BIG_CPU_SLEEP_1: cpu-sleep-1-1 {
+                           compatible = "arm,idle-state";
+                           idle-state-name = "big-rail-power-down";
+                           arm,psci-suspend-param = <0x40000004>;
+                           entry-latency-us = <526>;
+                           exit-latency-us = <1854>;
+                           min-residency-us = <5555>;
+                           local-timer-stop;
+                   };
+           };
+
+           domain-idle-states {
+                   CLUSTER_SLEEP_0: cluster-sleep-0 {
+                           compatible = "arm,idle-state";
+                           idle-state-name = "cluster-power-down";
+                           arm,psci-suspend-param = <0x40003444>;
+                           entry-latency-us = <3263>;
+                           exit-latency-us = <6562>;
+                           min-residency-us = <9926>;
+                           local-timer-stop;
+                   };
+           };
+   };
+
+   psci {
+           compatible = "arm,psci-1.0";
+           method = "smc";
+
+           CPU_PD0: cpu0 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&LITTLE_CPU_SLEEP_0 &LITTLE_CPU_SLEEP_1>;
+           };
+
+           CPU_PD1: cpu1 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&LITTLE_CPU_SLEEP_0 &LITTLE_CPU_SLEEP_1>;
+           };
+
+           CPU_PD2: cpu2 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&LITTLE_CPU_SLEEP_0 &LITTLE_CPU_SLEEP_1>;
+           };
+
+           CPU_PD3: cpu3 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&LITTLE_CPU_SLEEP_0 &LITTLE_CPU_SLEEP_1>;
+           };
+
+           CPU_PD4: cpu4 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&BIG_CPU_SLEEP_0 &BIG_CPU_SLEEP_1>;
+           };
+
+           CPU_PD5: cpu5 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&BIG_CPU_SLEEP_0 &BIG_CPU_SLEEP_1>;
+           };
+
+           CPU_PD6: cpu6 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&BIG_CPU_SLEEP_0 &BIG_CPU_SLEEP_1>;
+           };
+
+           CPU_PD7: cpu7 {
+                   #power-domain-cells = <0>;
+                   power-domains = <&CLUSTER_PD>;
+                   domain-idle-states = <&BIG_CPU_SLEEP_0 &BIG_CPU_SLEEP_1>;
+           };
+
+           CLUSTER_PD: cpu-cluster0 {
+                   #power-domain-cells = <0>;
+                   domain-idle-states = <&CLUSTER_SLEEP_0>;
+           };
+   };
+
+Comparisons on Qualcomm SC7280
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+CPUIdle states
+~~~~~~~~~~~~~~
+
+* 8 CPUs, 1 L3 cache
+* Platform-coordinated mode
+
+  * CPUIdle states
+
+    * State0 - WFI
+    * State1 - Core collapse
+    * State2 - Rail collapse
+    * State3 - L3 cache off and system resources voted off
+
+* OS-initiated mode
+
+  * CPUIdle states
+
+    * State0 - WFI
+    * State1 - Core collapse
+    * State2 - Rail collapse
+
+  * Cluster domain idle state
+
+    * State3 - L3 cache off and system resources voted off
+
+.. image:: ../resources/diagrams/psci-flattened-vs-hierarchical-idle-states.png
+
+Results
+~~~~~~~
+
+* The following stats have been captured with fixed CPU frequencies from the use
+  case of 10 seconds of device idle with the display turned on and Wi-Fi and
+  modem turned off.
+* Count refers to the number of times a CPU or cluster entered power collapse.
+* Residency refers to the time in seconds a CPU or cluster stayed in power
+  collapse.
+* The results are an average of 3 iterations of actual counts and residencies.
+
+.. image:: ../resources/diagrams/psci-pc-mode-vs-osi-mode.png
+
+OS-initiated mode was able to scale better than platform-coordinated mode for
+multiple CPUs. The count and residency results for state3 (i.e. a cluster domain
+idle state) in OS-initiated mode for multiple CPUs were much closer to the
+results for a single CPU than in platform-coordinated mode.
+
+--------------
+
+*Copyright (c) 2023, Arm Limited and Contributors. All rights reserved.*
diff --git a/docs/devicetree/bindings/arm/secure.txt b/docs/devicetree/bindings/arm/secure.txt
new file mode 100644
index 0000000000..e31303fb23
--- /dev/null
+++ b/docs/devicetree/bindings/arm/secure.txt
@@ -0,0 +1,53 @@
+* ARM Secure world bindings
+
+ARM CPUs with TrustZone support have two distinct address spaces,
+"Normal" and "Secure". Most devicetree consumers (including the Linux
+kernel) are not TrustZone aware and run entirely in either the Normal
+world or the Secure world. However some devicetree consumers are
+TrustZone aware and need to be able to determine whether devices are
+visible only in the Secure address space, only in the Normal address
+space, or visible in both. (One example of that situation would be a
+virtual machine which boots Secure firmware and wants to tell the
+firmware about the layout of the machine via devicetree.)
+
+The general principle of the naming scheme for Secure world bindings
+is that any property that needs a different value in the Secure world
+can be supported by prefixing the property name with "secure-". So for
+instance "secure-foo" would override "foo". For property names with
+a vendor prefix, the Secure variant of "vendor,foo" would be
+"vendor,secure-foo". If there is no "secure-" property then the Secure
+world value is the same as specified for the Normal world by the
+non-prefixed property. However, only the properties listed below may
+validly have "secure-" versions; this list will be enlarged on a
+case-by-case basis.
+
+Defining the bindings in this way means that a device tree which has
+been annotated to indicate the presence of Secure-only devices can
+still be processed unmodified by existing Non-secure software (and in
+particular by the kernel).
+
+Note that it is still valid for bindings intended for purely Secure
+world consumers (like kernels that run entirely in Secure) to simply
+describe the view of Secure world using the standard bindings. These
+secure- bindings only need to be used where both the Secure and Normal
+world views need to be described in a single device tree.
+
+Valid Secure world properties:
+
+- secure-status : specifies whether the device is present and usable
+  in the secure world. The combination of this with "status" allows
+  the various possible combinations of device visibility to be
+  specified. If "secure-status" is not specified it defaults to the
+  same value as "status"; if "status" is not specified either then
+  both default to "okay". This means the following combinations are
+  possible:
+
+   /* Neither specified: default to visible in both S and NS */
+   secure-status = "okay";                          /* visible in both */
+   status = "okay";                                 /* visible in both */
+   status = "okay"; secure-status = "okay";         /* visible in both */
+   secure-status = "disabled";                      /* NS-only */
+   status = "okay"; secure-status = "disabled";     /* NS-only */
+   status = "disabled"; secure-status = "okay";     /* S-only */
+   status = "disabled";                             /* disabled in both */
+   status = "disabled"; secure-status = "disabled"; /* disabled in both */
diff --git a/docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt b/docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt
new file mode 100644
index 0000000000..e268733513
--- /dev/null
+++ b/docs/devicetree/bindings/clock/st,stm32mp1-rcc.txt
@@ -0,0 +1,525 @@
+STMicroelectronics STM32 Peripheral Reset Clock Controller
+==========================================================
+
+The RCC IP is both a reset and a clock controller.
+
+RCC makes also power management (resume/supend and wakeup interrupt).
+
+Please also refer to reset.txt for common reset controller binding usage.
+
+Please also refer to clock-bindings.txt for common clock controller
+binding usage.
+
+
+Required properties:
+- compatible: "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon"
+  Adding "st,stm32mp1-rcc-secure" in the compatible list restricts
+  RCC access through RCC TZ_ENABLE bit.
+- reg: should be register base and length as documented in the datasheet
+- #clock-cells: 1, device nodes should specify the clock in their
+  "clocks" property, containing a phandle to the clock device node,
+  an index specifying the clock to use.
+- #reset-cells: Shall be 1
+- interrupts: Should contain a general interrupt line.
+- secure-interrupts: Should contain a interrupt line to the wake-up of
+                     processor (CSTOP).
+
+Example:
+	rcc: rcc@50000000 {
+		compatible = "st,stm32mp1-rcc", "syscon";
+		reg = <0x50000000 0x1000>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+		interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+Specifying clocks
+=================
+
+All available clocks are defined as preprocessor macros in
+dt-bindings/clock/stm32mp1-clks.h header and can be used in device
+tree sources.
+
+Specifying softreset control of devices
+=======================================
+
+Device nodes should specify the reset channel required in their "resets"
+property, containing a phandle to the reset device node and an index specifying
+which channel to use.
+The index is the bit number within the RCC registers bank, starting from RCC
+base address.
+It is calculated as: index = register_offset / 4 * 32 + bit_offset.
+Where bit_offset is the bit offset within the register.
+
+For example on STM32MP1, for LTDC reset:
+ ltdc = APB4_RSTSETR_offset / 4 * 32 + LTDC_bit_offset
+      = 0x180 / 4 * 32 + 0 = 3072
+
+The list of valid indices for STM32MP1 is available in:
+include/dt-bindings/reset-controller/stm32mp1-resets.h
+
+This file implements defines like:
+#define LTDC_R	3072
+
+
+Defining clock source distribution with property st,clksrc
+==========================================================
+
+- st,clksrc : used to configure the peripherals kernel clock selection.
+
+  The property is a list of peripheral kernel clock source identifiers defined
+  by macros CLK_<KERNEL-CLOCK>_<PARENT-CLOCK> as defined by header file
+  dt-bindings/clock/stm32mp13-clksrc.h.
+
+  st,clksrc may not list all the kernel clocks and has no ordering requirements.
+
+  Property can be used to configure the clock distribution tree.
+
+  Example:
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_CKPER_HSE
+		CLK_FMC_ACLK
+		CLK_QSPI_ACLK
+		CLK_ETH_DISABLED
+		CLK_SDMMC12_PLL4P
+	>;
+
+Defining clock dividers with property st,clkdiv
+===============================================
+
+- st,clkdiv : The property is a list of dividers defined
+              by macros DIV(DIV_<DIV-CLOCK>, value) as defined by header file
+	      dt-bindings/clock/stm32mp15-clksrc.h.
+
+  Property can be used to configure the clock main dividers value.
+
+  For the STM32MP15x family there are 11 dividers values expected.
+		MPU AXI MCU APB1 APB2 APB3 APB4 APB5 RTC MCO1 MCO2
+
+  Each divider value uses the DIV coding defined in RCC associated
+  register RCC_xxxDIVR. In most cases, it is:
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 4
+		0x3: division by 8
+		...
+
+  Note that the coding is different for:
+
+  DIV_RTC DIV_MCO1 DIV_MCO2
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+
+  DIV_MPU
+		0x0: no clock generated
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+		0xf: division by 16
+
+  Example:
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+Defining peripheral PLL frequencies
+========================================================
+
+- children for a PLL static configuration with "st,stm32mp1-pll" compatible
+
+  Each PLL children node for PLL1 to PLL4 (see ref manual for details)
+  are listed with associated reg 0 to 3.
+
+  PLL2, PLL3 or PLL4 are off when their associated nodes are absent or
+  deactivated.
+
+  The configuration of PLL1, the source clock of Cortex-A7 core, with st,pll@0
+  node, is optional as TF-A automatically selects the most suitable operating
+  point for the platform.
+  The node st,pll@0 node should be absent; it is only used if you want to
+  override the PLL1 properties computed by TF-A (clock spreading for example).
+
+      Here are the available properties for each PLL node:
+    - compatible: should be "st,stm32mp1-pll"
+
+    - reg: index of the pll instance
+
+    - st,pll: Phandle of the default PLL configuration.
+              A PLL can have several configuration (5 max) and should be described in a subnode
+              just below.
+
+    - pllx_cfgx node: The PLL configuration node is composed of 2 mandatory parameters:
+        - st,pll_vco: Phandle of PLL VCO configuration.
+	              See description of 'st,pll_vco' node.
+
+        - st,pll_div_pqr: The parameters for PLL configuration in the following order:
+                          DIVP DIVQ DIVR Output.
+
+			  DIVx values are defined as in RCC spec:
+			  0x0: bypass (division by 1)
+			  0x1: division by 2
+			  0x2: division by 3
+			  0x3: division by 4
+			  ...
+  Note that in the next stage (e.g. OP-TEE) the phandle of the default PLL configuration
+  ('st,pll') is optional (the configuration of TF-A will be kept).
+
+- st,pll_vco node: This node will contain all VCO configuration of all PLLs in subnodes.
+                   We will find theses parameters in each subnode.
+
+	   -src: Clock source configuration values are defined by macros CLK_<NAME>_<SOURCE>
+                 from dt-bindings/clock/stm32mp13-clksrc.h.
+
+	   -divmn: The parameters for PLL divider (DIVM) and multiplication factor (DIVN)
+	           configuration.
+
+	   - frac: Fractional part of the multiplication factor
+                   (optional, PLL is in integer mode when absent).
+
+	   - csg: Clock Spreading Generator (optional) with parameters in the
+	          following order: MOD_PER INC_STEP SSCG_MODE.
+
+	          MOD_PER: Modulation Period Adjustment
+		  INC_STEP: Modulation Depth Adjustment
+		  SSCG_MODE: Spread spectrum clock generator mode, with associated
+			     defined from stm32mp13-clksrc.h:
+		               - SSCG_MODE_CENTER_SPREAD = 0
+			       - SSCG_MODE_DOWN_SPREAD = 1
+
+    Example:
+	st,pll_vco {
+		pll1_vco_1300Mhz: pll1-vco-1300Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 80>;
+			frac = <0x800>;
+		};
+		...
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+			csg = <10 20 1>;
+		};
+		...
+	};
+
+	pll1: st,pll@0 {
+		compatible = "st,stm32mp1-pll";
+		reg = <0>;
+
+		st,pll = <&pll1_cfg1>;
+
+		pll1_cfg1: pll1_cfg1 {
+			st,pll_vco = <&pll1_vco_1300Mhz>;
+			st,pll_div_pqr = <0 0 0>;
+		};
+	};
+
+	st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 1>;
+		};
+	};
+
+  Note: PLL1 and PLL2 have same source clock, if source clock is different
+  between PLL1 and PLL2 a panic will be generated.
+
+Fixed clocks description
+========================
+
+The clock tree is also based on 5 fixed-clock in clocks node
+used to define the state of associated ST32MP1 oscillators:
+  - clk-lsi
+  - clk-lse
+  - clk-hsi
+  - clk-hse
+  - clk-csi
+
+At boot the clock tree initialization will
+  - enable oscillators present in device tree and not disabled
+    (node with status="disabled"),
+  - disable HSI oscillator if the node is absent (always activated by bootrom)
+    or disabled (node with status="disabled").
+
+Optional properties :
+
+a) for external oscillator: "clk-lse", "clk-hse"
+
+  4 optional fields are managed
+  - "st,bypass" configures the oscillator bypass mode (HSEBYP, LSEBYP)
+  - "st,digbypass" configures the bypass mode as full-swing digital
+    signal (DIGBYP)
+  - "st,css" activates the clock security system (HSECSSON, LSECSSON)
+  - "st,drive" (only for LSE) contains the value of the drive for the
+     oscillator (see LSEDRV_ defined in the file
+     dt-bindings/clock/stm32mp1-clksrc.h)
+
+  Example board file:
+	/ {
+		clocks {
+			clk_hse: clk-hse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <24000000>;
+				st,bypass;
+			};
+
+			clk_lse: clk-lse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32768>;
+				st,css;
+				st,drive = <LSEDRV_LOWEST>;
+			};
+	};
+
+b) for internal oscillator: "clk-hsi"
+
+  Internally HSI clock is fixed to 64MHz for STM32MP157 SoC.
+  In device tree, clk-hsi is the clock after HSIDIV (clk_hsi in RCC
+  doc). So this clock frequency is used to compute the expected HSI_DIV
+  for the clock tree initialization.
+
+  Example with HSIDIV = /1:
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <64000000>;
+			};
+	};
+
+  Example with HSIDIV = /2
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32000000>;
+			};
+	};
+
+HSI & CSI calibration
+========================
+
+Calibration is an optional feature that may be enabled from device tree. It
+allows to request calibration of the HSI or the CSI clocks from several means:
+	- SiP SMC service
+	- Periodic calibration every X seconds
+	- Interrupt raised by the MCU
+
+This feature requires that a HW timer is assigned to the calibration sequence.
+
+Dedicated secure interrupt must be defined using "mcu_sev" name to start a
+calibration on detection of an interrupt raised by MCU.
+
+- st,hsi-cal: used to enable HSI clock calibration feature.
+
+- st,csi-cal: used to enable CSI clock calibration feature.
+
+- st,cal-sec: used to enable periodic calibration every specified seconds from
+  secure monitor. Time must be given in seconds. If not specified, calibration
+  is processed for each incoming request.
+
+Example:
+	&rcc {
+		st,hsi-cal;
+		st,csi-cal;
+		st,cal-sec = <15>;
+		secure-interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupt-names = "mcu_sev", "wakeup";
+	};
+
+
+Example of clock tree initialization
+====================================
+
+/ {
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			st,digbypass;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+	};
+
+	soc {
+
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp1-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupt-names = "wakeup";
+
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_RTC_LSE
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+		CLK_CKPER_HSE
+		CLK_FMC_ACLK
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_PLL4P
+		CLK_DSI_DSIPLL
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_PLL3Q
+		CLK_SPI2S23_PLL3Q
+		CLK_SPI45_HSI
+		CLK_SPI6_HSI
+		CLK_I2C46_HSI
+		CLK_SDMMC3_PLL4P
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_LSE
+		CLK_I2C12_HSI
+		CLK_I2C35_HSI
+		CLK_UART1_HSI
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_HSI
+		CLK_UART78_HSI
+		CLK_SPDIF_PLL4P
+		CLK_FDCAN_PLL4R
+		CLK_SAI1_PLL3Q
+		CLK_SAI2_PLL3Q
+		CLK_SAI3_PLL3Q
+		CLK_SAI4_PLL3Q
+		CLK_RNG1_CSI
+		CLK_RNG2_LSI
+		CLK_LPTIM1_PCLK1
+		CLK_LPTIM23_PCLK3
+		CLK_LPTIM45_LSE
+	>;
+
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll2-vco-417_8Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll2-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
+	};
+
+	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
+	pll2: st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
+	};
+
+	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+	pll3: st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
+	};
+
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
+	pll4: st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt b/docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt
new file mode 100644
index 0000000000..4a444beb5c
--- /dev/null
+++ b/docs/devicetree/bindings/clock/st,stm32mp13-rcc.txt
@@ -0,0 +1,640 @@
+STMicroelectronics STM32 Peripheral Reset Clock Controller
+==========================================================
+
+The RCC IP is both a reset and a clock controller.
+
+RCC makes also power management (resume/supend and wakeup interrupt).
+
+Please also refer to reset.txt for common reset controller binding usage.
+
+Please also refer to clock-bindings.txt for common clock controller
+binding usage.
+
+
+Required properties:
+- compatible: "st,stm32mp13-rcc", "syscon"
+- reg: should be register base and length as documented in the datasheet
+- #clock-cells: 1, device nodes should specify the clock in their
+  "clocks" property, containing a phandle to the clock device node,
+  an index specifying the clock to use.
+- #reset-cells: Shall be 1
+- interrupts: Should contain a general interrupt line.
+- secure-interrupts: Should contain an interrupt line to the wake-up of
+                     processor (CSTOP).
+
+Example:
+	rcc: rcc@50000000 {
+		compatible = "st,stm32mp13-rcc", "syscon";
+		reg = <0x50000000 0x1000>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+		interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+Specifying clocks
+=================
+
+All available clocks are defined as preprocessor macros in
+dt-bindings/clock/stm32mp13-clks.h header and can be used in device
+tree sources.
+
+Specifying softreset control of devices
+=======================================
+
+Device nodes should specify the reset channel required in their "resets"
+property, containing a phandle to the reset device node and an index specifying
+which channel to use.
+The index is the bit number within the RCC registers bank, starting from RCC
+base address.
+It is calculated as: index = register_offset / 4 * 32 + bit_offset.
+Where bit_offset is the bit offset within the register.
+
+For example on STM32MP13, for I2C2 reset:
+ i2c2 = APB1_RSTSETR_offset / 4 * 32 + I2C2_bit_offset
+      = 0x6A0 / 4 * 32 + 22 = 13590
+
+The list of valid indices for STM32MP13 is available in:
+include/dt-bindings/reset/stm32mp13-resets.h
+
+This file implements defines like:
+#define I2C2_R	13590
+
+
+Defining clock source distribution with property st,clksrc
+==========================================================
+
+- st,clksrc : used to configure the peripherals kernel clock selection.
+
+  The property is a list of peripheral kernel clock source identifiers defined
+  by macros CLK_<KERNEL-CLOCK>_<PARENT-CLOCK> as defined by header file
+  dt-bindings/clock/stm32mp13-clksrc.h.
+
+  st,clksrc may not list all the kernel clocks and has no ordering requirements.
+
+  Property can be used to configure the clock distribution tree.
+
+  Example:
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MLAHBS_PLL3
+		CLK_RTC_LSE
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+		CLK_ETH1_PLL4P
+		CLK_ETH2_PLL4P
+		CLK_SDMMC1_PLL4P
+		CLK_SDMMC2_PLL4P
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_I2C4_HSI
+	>;
+
+Defining clock dividers with property st,clkdiv
+===============================================
+
+- st,clkdiv : The property is a list of dividers defined
+              by macros DIV(DIV_<DIV-CLOCK>, value) as defined by header file
+	      dt-bindings/clock/stm32mp13-clksrc.h.
+
+  Property can be used to configure the clock main dividers value.
+
+  For the STM32MP13 family there are 12 dividers values expected.
+		MPU AXI MLAHB APB1 APB2 APB3 APB4 APB5 APB6 RTC MCO1 MCO2
+
+  Each divider value uses the DIV coding defined in RCC associated
+  register RCC_xxxDIVR. In most cases, it is:
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 4
+		0x3: division by 8
+		...
+
+  Note that the coding is different for:
+
+  RTC MCO1 MCO2
+		0x0: not divided
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+
+  DIV_MPU
+		0x0: no clock generated
+		0x1: division by 2
+		0x2: division by 3
+		0x3: division by 4
+		...
+		0xf: division by 16
+
+  Example:
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MLAHB, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_APB6, 1)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+Defining peripheral PLL frequencies
+========================================================
+
+- children for a PLL static configuration with "st,stm32mp1-pll" compatible
+
+  Each PLL children node for PLL1 to PLL4 (see ref manual for details)
+  are listed with associated reg 0 to 3.
+
+  PLL2, PLL3 or PLL4 are off when their associated nodes are absent or
+  deactivated.
+
+  The configuration of PLL1, the source clock of Cortex-A7 core, is mandatory
+  for TF-A.
+
+      Here are the available properties for each PLL node:
+    - compatible: should be "st,stm32mp1-pll"
+
+    - reg: index of the pll instance
+
+    - st,pll: Phandle of the default pll configuration.
+              A pll could have several configuration (5 max) and shoud be described in a subnode
+              just below.
+
+    - pllx_cfgx node: The PLL configuration node is composed of 2 mandatory parameters:
+        - st,pll_vco: Phandle of pll vco configuration.
+	              See description of 'st,pll_vco' node.
+
+        - st,pll_div_pqr: The parameters for PLL configuration in the following order:
+                          DIVP DIVQ DIVR Output.
+
+			  DIVx values are defined as in RCC spec:
+			  0x0: bypass (division by 1)
+			  0x1: division by 2
+			  0x2: division by 3
+			  0x3: division by 4
+			  ...
+  Note that in the next stage (e.g. OPTEE) the phandle of the default pll configuration
+  ('st,pll') could be optional (the configuration of TF-A will be kept).
+  The DVFS could apllied configuration at run-time from pllx_cfgx node.
+
+- st,pll_vco node: This node will contain all vco configuration of all PLLs in subnodes.
+                   We will found theses parameters in each subnodes.
+
+	   -src: Clock source configuration values are defined by macros CLK_<NAME>_<SOURCE>
+                 from dt-bindings/clock/stm32mp13-clksrc.h.
+
+	   -divmn: The parameters for PLL divider (DIVM) and multiplication factor (DIVN)
+	           configuration.
+
+	   - frac: Fractional part of the multiplication factor
+                   (optional, PLL is in integer mode when absent).
+
+	   - csg: Clock Spreading Generator (optional) with parameters in the
+	          following order: MOD_PER INC_STEP SSCG_MODE.
+
+	          MOD_PER: Modulation Period Adjustment
+		  INC_STEP: Modulation Depth Adjustment
+		  SSCG_MODE: Spread spectrum clock generator mode, with associated
+			     defined from stm32mp13-clksrc.h:
+		               - SSCG_MODE_CENTER_SPREAD = 0
+			       - SSCG_MODE_DOWN_SPREAD = 1
+
+    Example:
+	st,pll_vco {
+		pll1_vco_1300Mhz: pll1-vco-1300Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 80>;
+			frac = <0x800>;
+		};
+		...
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+			csg = <10 20 1>;
+		};
+		...
+	};
+
+	pll1:st,pll@0 {
+		compatible = "st,stm32mp1-pll";
+		reg = <0>;
+
+		st,pll = <&pll1_cfg1>;
+
+		pll1_cfg1: pll1_cfg1 {
+			st,pll_vco = <&pll1_vco_1300Mhz>;
+			st,pll_div_pqr = <0 1 1>;
+		};
+	};
+
+	st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 1>;
+		};
+	};
+
+  Note: pll1 and pll2 have same source clock, if source clock is different
+  between pll1 and pll2 a panic will be generated.
+
+Fixed clocks description
+========================
+
+The clock tree is also based on 5 fixed-clock in clocks node
+used to define the state of associated ST32MP1 oscillators:
+  - clk-lsi
+  - clk-lse
+  - clk-hsi
+  - clk-hse
+  - clk-csi
+
+At boot the clock tree initialization will
+  - enable oscillators present in device tree and not disabled
+    (node with status="disabled"),
+  - disable HSI oscillator if the node is absent (always activated by bootrom)
+    or disabled (node with status="disabled").
+
+Optional properties :
+
+a) for external oscillator: "clk-lse", "clk-hse"
+
+  4 optional fields are managed
+  - "st,bypass" configures the oscillator bypass mode (HSEBYP, LSEBYP)
+  - "st,digbypass" configures the bypass mode as full-swing digital
+    signal (DIGBYP)
+  - "st,css" activates the clock security system (HSECSSON, LSECSSON)
+  - "st,drive" (only for LSE) contains the value of the drive for the
+     oscillator (see LSEDRV_ defined in the file
+     dt-bindings/clock/stm32mp13-clksrc.h)
+
+  Example board file:
+	/ {
+		clocks {
+			clk_hse: clk-hse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <24000000>;
+				st,bypass;
+			};
+
+			clk_lse: clk-lse {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32768>;
+				st,css;
+				st,drive = <LSEDRV_LOWEST>;
+			};
+	};
+
+b) for internal oscillator: "clk-hsi"
+
+  Internally HSI clock is fixed to 64MHz for STM32MP13 SoC.
+  In device tree, clk-hsi is the clock after HSIDIV (clk_hsi in RCC
+  doc). So this clock frequency is used to compute the expected HSI_DIV
+  for the clock tree initialization.
+
+  Example with HSIDIV = /1:
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <64000000>;
+			};
+	};
+
+  Example with HSIDIV = /2
+	/ {
+		clocks {
+			clk_hsi: clk-hsi {
+				#clock-cells = <0>;
+				compatible = "fixed-clock";
+				clock-frequency = <32000000>;
+			};
+	};
+
+HSI & CSI calibration
+========================
+
+Calibration is an optional feature that may be enabled from device tree. It
+allows to request calibration of the HSI or the CSI clocks from several means:
+	- SiP SMC service
+	- Periodic calibration every X seconds
+
+This feature requires that a HW timer is assigned to the calibration sequence.
+
+- st,hsi-cal: used to enable HSI clock calibration feature.
+
+- st,csi-cal: used to enable CSI clock calibration feature.
+
+- st,cal-sec: used to enable periodic calibration every specified seconds from
+  secure monitor. Time must be given in seconds. If not specified, calibration
+  is processed for each incoming request.
+
+Example:
+	&rcc {
+		st,hsi-cal;
+		st,csi-cal;
+		st,cal-sec = <15>;
+		secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+		secure-interrupt-names = "wakeup";
+	};
+
+
+Clocks and Operating Performance Points
+=======================================
+
+- st,clk_opp node: This node will contain all operating point configurations.
+		   We can have 3 operating points:
+		     - st,ck_mpu
+		     - st,ck_axi
+		     - ck_mlahbs
+		   These nodes are not mandatory, but we have to respect the naming.
+
+                   Each node will contain a list of operating point configurations (cfg_1, cfg_2...)
+
+                   These configuration subnodes contain these properties:
+
+		   mandatory parameters:
+		     -hz: Operating point frequency in hertz
+
+		     -st,clksrc: The clock source (same syntax of 'st,clksrc' property below)
+
+		   optional parameters:
+		     -st,clkdiv: The clock divider value (same syntax of 'st,clkdiv' property below)
+
+                     -st,pll: Phandle of the pll configuration (See description of 'pllx_cfgx' node)
+
+  Note that this OPP configuration will be apllied at the run-time and will override the clock tree
+  configuration.
+
+  Example:
+			st,clk_opp {
+				st,ck_mpu {
+					cfg_1 {
+						hz = <900000000>;
+						st,clksrc = <CLK_MPU_PLL1P>;
+						st,pll = <&pll1_cfg1>;
+					};
+
+					cfg_2 {
+						hz = <650000000>;
+						st,clksrc = <CLK_MPU_PLL1P>;
+						st,pll = <&pll1_cfg2>;
+					}
+
+
+Example of clock tree initialization and Operating Points Performance
+=====================================================================
+
+/ {
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			st,digbypass;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+	};
+
+	soc {
+
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+			secure-interrupt-names = "wakeup";
+
+			st,clksrc = <
+				CLK_MPU_PLL1P
+				CLK_AXI_PLL2P
+				CLK_MLAHBS_PLL3
+				CLK_RTC_LSE
+				CLK_MCO1_DISABLED
+				CLK_MCO2_DISABLED
+				CLK_CKPER_HSE
+				CLK_ETH1_PLL4P
+				CLK_ETH2_PLL4P
+				CLK_SDMMC1_PLL4P
+				CLK_SDMMC2_PLL4P
+				CLK_STGEN_HSE
+				CLK_USBPHY_HSE
+				CLK_I2C4_HSI
+				CLK_USBO_USBPHY
+				CLK_ADC2_CKPER
+				CLK_I2C12_HSI
+				CLK_UART2_HSI
+				CLK_UART4_HSI
+				CLK_SAES_AXI
+				CLK_DCMIPP_PLL2Q
+				CLK_LPTIM3_PCLK3
+			>;
+
+			st,clkdiv = <
+				DIV(DIV_MPU, 1)
+				DIV(DIV_AXI, 0)
+				DIV(DIV_MLAHB, 0)
+				DIV(DIV_APB1, 1)
+				DIV(DIV_APB2, 1)
+				DIV(DIV_APB3, 1)
+				DIV(DIV_APB4, 1)
+				DIV(DIV_APB5, 2)
+				DIV(DIV_APB6, 1)
+				DIV(DIV_RTC, 0)
+				DIV(DIV_MCO1, 0)
+				DIV(DIV_MCO2, 0)
+			>;
+
+			st,pll_vco {
+				pll1_vco_1800Mhz: pll1-vco-1800Mhz {
+					src = <CLK_PLL12_HSE>;
+					divmn = <1 74>;
+				};
+
+				pll1_vco_1300Mhz: pll1-vco-1300Mhz {
+					src = <CLK_PLL12_HSE>;
+					divmn = <2 80>;
+					frac = <0x800>;
+				};
+
+				pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+					src = <CLK_PLL12_HSE>;
+					divmn = <2 65>;
+					frac = <0x1400>;
+				};
+
+				pll3_vco_417Mhz: pll3-vco-417Mhz {
+					src = <CLK_PLL3_HSE>;
+					divmn = <1 33>;
+					frac = <0x1a04>;
+				};
+
+				pll4_vco_600Mhz: pll4-vco-600Mhz {
+					src = <CLK_PLL4_HSE>;
+					divmn = <1 49>;
+				};
+			};
+
+			/* VCO = 1300.0 MHz => P = 650 (CPU) */
+			pll1:st,pll@0 {
+				compatible = "st,stm32mp1-pll";
+				reg = <0>;
+
+				st,pll = <&pll1_cfg1>;
+
+				pll1_cfg1: pll1_cfg1 {
+					st,pll_vco = <&pll1_vco_1300Mhz>;
+					st,pll_div_pqr = <0 1 1>;
+				};
+
+				pll1_cfg2: pll2_cfg1 {
+					st,pll_vco = <&pll1_vco_1800Mhz>;
+					st,pll_div_pqr = <0 1 1>;
+				};
+			};
+
+			/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 266, R = 533 (DDR) */
+			pll2:st,pll@1 {
+				compatible = "st,stm32mp1-pll";
+				reg = <1>;
+
+				st,pll = <&pll2_cfg1>;
+
+				pll2_cfg1: pll2_cfg1 {
+					st,pll_vco = <&pll2_vco_1066Mhz>;
+					st,pll_div_pqr = <1 0 1>;
+				};
+			};
+
+			/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+			pll3:st,pll@2 {
+				compatible = "st,stm32mp1-pll";
+				reg = <2>;
+
+				st,pll = <&pll3_cfg1>;
+
+				pll3_cfg1: pll3_cfg1 {
+					st,pll_vco = <&pll3_vco_417Mhz>;
+					st,pll_div_pqr = <1 16 1>;
+				};
+			};
+
+			/* VCO = 600.0 MHz => P = 50, Q = 10, R = 100 */
+			pll4:st,pll@3 {
+				compatible = "st,stm32mp1-pll";
+				reg = <3>;
+				st,pll = <&pll4_cfg1>;
+
+				pll4_cfg1: pll4_cfg1 {
+					st,pll_vco = <&pll4_vco_600Mhz>;
+					st,pll_div_pqr = <11 59 5>;
+				};
+			};
+
+			st,clk_opp {
+				st,ck_mpu {
+					cfg_1 {
+						hz = <900000000>;
+						st,clksrc = <CLK_MPU_PLL1P>;
+						st,pll = <&pll1_cfg1>;
+					};
+
+					cfg_2 {
+						hz = <650000000>;
+						st,clksrc = <CLK_MPU_PLL1P>;
+						st,pll = <&pll1_cfg2>;
+					};
+
+					cfg_3 {
+						hz = <450000000>;
+						st,clksrc = <CLK_MPU_PLL1P_DIV>;
+						st,clkdiv = <DIV(DIV_MPU, 1)>;
+						st,pll = <&pll1_cfg1>;
+					};
+
+					cfg_4 {
+						hz = <64000000>;
+						st,clksrc = <CLK_MPU_HSI>;
+					};
+
+					cfg_5 {
+						hz = <24000000>;
+						st,clksrc = <CLK_MPU_HSE>;
+					};
+				};
+
+				st,ck_axi {
+					cfg_1 {
+						hz = <266500000>;
+						st,clksrc = <CLK_AXI_PLL2P>;
+						st,clkdiv = <DIV(DIV_AXI, 0)>;
+						st,pll = <&pll2_cfg1>;
+					};
+
+					cfg_2 {
+						hz = <64000000>;
+						st,clksrc = <CLK_AXI_HSI>;
+						st,clkdiv = <DIV(DIV_AXI, 0)>;
+					};
+				};
+
+				st,ck_mlahbs {
+					cfg_1 {
+						hz = <208877930>;
+						st,clksrc = <CLK_MLAHBS_PLL3>;
+						st,clkdiv = <DIV(DIV_MLAHB, 0)>;
+						st,pll = <&pll3_cfg1>;
+					};
+
+					cfg_2 {
+						hz = <12000000>;
+						st,clksrc = <CLK_MLAHBS_HSE>;
+						st,clkdiv = <DIV(DIV_MLAHB, 1)>;
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/i2c/i2c-stm32.txt b/docs/devicetree/bindings/i2c/i2c-stm32.txt
new file mode 100644
index 0000000000..68aefa6dc4
--- /dev/null
+++ b/docs/devicetree/bindings/i2c/i2c-stm32.txt
@@ -0,0 +1,54 @@
+* I2C controller embedded in STMicroelectronics STM32 I2C platform
+
+Required properties :
+- compatible : Must be one of the following
+  - "st,stm32f7-i2c"
+- reg : Offset and length of the register set for the device
+- resets: Must contain the phandle to the reset controller.
+- clocks: Must contain the input clock of the I2C instance.
+- A pinctrl state named "default" must be defined to set pins in mode of
+  operation for I2C transfer. An optional pinctrl state named "sleep" has to
+  be defined as well as to put I2C in low power mode in suspend mode.
+- #address-cells = <1>;
+- #size-cells = <0>;
+
+Optional properties :
+- clock-frequency : Desired I2C bus clock frequency in Hz. If not specified,
+  the default 100 kHz frequency will be used.
+- i2c-scl-rising-time-ns : Only for STM32F7, I2C SCL Rising time for the board
+  (default: 25)
+- i2c-scl-falling-time-ns : Only for STM32F7, I2C SCL Falling time for the board
+  (default: 10)
+  I2C Timings are derived from these 2 values
+- st,syscfg-fmp:  Only for STM32F7, use to set Fast Mode Plus bit within SYSCFG
+  whether Fast Mode Plus speed is selected by slave.
+	1st cell : phandle to syscfg
+	2nd cell : register offset within SYSCFG
+	3rd cell : register bitmask for FMP bit
+
+Example :
+
+	i2c@40005400 {
+		compatible = "st,stm32f4-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x40005400 0x400>;
+		resets = <&rcc 277>;
+		clocks = <&rcc 0 149>;
+		pinctrl-0 = <&i2c1_sda_pin>, <&i2c1_scl_pin>;
+		pinctrl-names = "default";
+	};
+
+	i2c@40005400 {
+		compatible = "st,stm32f7-i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x40005400 0x400>;
+		resets = <&rcc STM32F7_APB1_RESET(I2C1)>;
+		clocks = <&rcc 1 CLK_I2C1>;
+		pinctrl-0 = <&i2c1_sda_pin>, <&i2c1_scl_pin>;
+		pinctrl-1 =  <&i2c1_sda_pin_sleep>, <&i2c1_scl_pin_sleep>;
+		pinctrl-names = "default", "sleep";
+		st,syscfg-fmp = <&syscfg 0x4 0x1>;
+	};
+
diff --git a/docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt b/docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt
new file mode 100644
index 0000000000..ec610925b9
--- /dev/null
+++ b/docs/devicetree/bindings/memory-controllers/st,stm32mp1-ddr.txt
@@ -0,0 +1,289 @@
+ST,stm32mp1 DDR3/LPDDR2/LPDDR3 Controller (DDRCTRL and DDRPHYC)
+
+--------------------
+Required properties:
+--------------------
+- compatible	: Should be "st,stm32mp1-ddr" for STM32MP15x
+		  Should be "st,stm32mp13-ddr" for STM32MP13x
+- reg		: controleur (DDRCTRL) and phy (DDRPHYC) base address
+- clocks	: controller clocks handle
+- clock-names	: associated controller clock names
+		  the "ddrphyc" clock is used to check the DDR frequency
+		  at phy level according the expected value in "mem-speed" field
+
+the next attributes are DDR parameters, they are generated by DDR tools
+included in STM32 Cube tool
+
+info attributes:
+----------------
+- st,mem-name	: name for DDR configuration, simple string for information
+- st,mem-speed	: DDR expected speed for the setting in kHz
+- st,mem-size	: DDR mem size in byte
+
+
+controlleur attributes:
+-----------------------
+- st,ctl-reg	: controleur values depending of the DDR type
+		  (DDR3/LPDDR2/LPDDR3)
+	for STM32MP13x and STM32MP15x: 25 values are requested in this order
+		MSTR
+		MRCTRL0
+		MRCTRL1
+		DERATEEN
+		DERATEINT
+		PWRCTL
+		PWRTMG
+		HWLPCTL
+		RFSHCTL0
+		RFSHCTL3
+		CRCPARCTL0
+		ZQCTL0
+		DFITMG0
+		DFITMG1
+		DFILPCFG0
+		DFIUPD0
+		DFIUPD1
+		DFIUPD2
+		DFIPHYMSTR
+		ODTMAP
+		DBG0
+		DBG1
+		DBGCMD
+		POISONCFG
+		PCCFG
+
+- st,ctl-timing	: controleur values depending of frequency and timing parameter
+		  of DDR
+	for STM32MP13x and STM32MP15x: 12 values are requested in this order
+		RFSHTMG
+		DRAMTMG0
+		DRAMTMG1
+		DRAMTMG2
+		DRAMTMG3
+		DRAMTMG4
+		DRAMTMG5
+		DRAMTMG6
+		DRAMTMG7
+		DRAMTMG8
+		DRAMTMG14
+		ODTCFG
+
+- st,ctl-map	: controleur values depending of address mapping
+	for STM32MP13x and STM32MP15x: 9 values are requested in this order
+		ADDRMAP1
+		ADDRMAP2
+		ADDRMAP3
+		ADDRMAP4
+		ADDRMAP5
+		ADDRMAP6
+		ADDRMAP9
+		ADDRMAP10
+		ADDRMAP11
+
+- st,ctl-perf	: controleur values depending of performance and scheduling
+	for STM32MP13x: 11 values are requested in this order
+		SCHED
+		SCHED1
+		PERFHPR1
+		PERFLPR1
+		PERFWR1
+		PCFGR_0
+		PCFGW_0
+		PCFGQOS0_0
+		PCFGQOS1_0
+		PCFGWQOS0_0
+		PCFGWQOS1_0
+
+	for STM32MP15x: 17 values are requested in this order
+		SCHED
+		SCHED1
+		PERFHPR1
+		PERFLPR1
+		PERFWR1
+		PCFGR_0
+		PCFGW_0
+		PCFGQOS0_0
+		PCFGQOS1_0
+		PCFGWQOS0_0
+		PCFGWQOS1_0
+		PCFGR_1
+		PCFGW_1
+		PCFGQOS0_1
+		PCFGQOS1_1
+		PCFGWQOS0_1
+		PCFGWQOS1_1
+
+phyc attributes:
+----------------
+- st,phy-reg	: phy values depending of the DDR type (DDR3/LPDDR2/LPDDR3)
+	for STM32MP13x: 9 values are requested in this order
+		PGCR
+		ACIOCR
+		DXCCR
+		DSGCR
+		DCR
+		ODTCR
+		ZQ0CR1
+		DX0GCR
+		DX1GCR
+
+	for STM32MP15x: 11 values are requested in this order
+		PGCR
+		ACIOCR
+		DXCCR
+		DSGCR
+		DCR
+		ODTCR
+		ZQ0CR1
+		DX0GCR
+		DX1GCR
+		DX2GCR
+		DX3GCR
+
+- st,phy-timing	: phy values depending of frequency and timing parameter of DDR
+	for STM32MP13x and STM32MP15x: 10 values are requested in this order
+		PTR0
+		PTR1
+		PTR2
+		DTPR0
+		DTPR1
+		DTPR2
+		MR0
+		MR1
+		MR2
+		MR3
+
+Example:
+
+/ {
+	soc {
+		ddr: ddr@0x5A003000{
+			compatible = "st,stm32mp1-ddr";
+
+			reg = <0x5A003000 0x550
+			       0x5A004000 0x234>;
+
+			clocks = <&rcc_clk AXIDCG>,
+				 <&rcc_clk DDRC1>,
+				 <&rcc_clk DDRC2>,
+				 <&rcc_clk DDRPHYC>,
+				 <&rcc_clk DDRCAPB>,
+				 <&rcc_clk DDRPHYCAPB>;
+
+			clock-names = "axidcg",
+				      "ddrc1",
+				      "ddrc2",
+				      "ddrphyc",
+				      "ddrcapb",
+				      "ddrphycapb";
+
+			st,mem-name = "DDR3 2x4Gb 533MHz";
+			st,mem-speed = <533000>;
+			st,mem-size = <0x40000000>;
+
+			st,ctl-reg = <
+				0x00040401 /*MSTR*/
+				0x00000010 /*MRCTRL0*/
+				0x00000000 /*MRCTRL1*/
+				0x00000000 /*DERATEEN*/
+				0x00800000 /*DERATEINT*/
+				0x00000000 /*PWRCTL*/
+				0x00400010 /*PWRTMG*/
+				0x00000000 /*HWLPCTL*/
+				0x00210000 /*RFSHCTL0*/
+				0x00000000 /*RFSHCTL3*/
+				0x00000000 /*CRCPARCTL0*/
+				0xC2000040 /*ZQCTL0*/
+				0x02050105 /*DFITMG0*/
+				0x00000202 /*DFITMG1*/
+				0x07000000 /*DFILPCFG0*/
+				0xC0400003 /*DFIUPD0*/
+				0x00000000 /*DFIUPD1*/
+				0x00000000 /*DFIUPD2*/
+				0x00000000 /*DFIPHYMSTR*/
+				0x00000001 /*ODTMAP*/
+				0x00000000 /*DBG0*/
+				0x00000000 /*DBG1*/
+				0x00000000 /*DBGCMD*/
+				0x00000000 /*POISONCFG*/
+				0x00000010 /*PCCFG*/
+			>;
+
+			st,ctl-timing = <
+				0x0080008A /*RFSHTMG*/
+				0x121B2414 /*DRAMTMG0*/
+				0x000D041B /*DRAMTMG1*/
+				0x0607080E /*DRAMTMG2*/
+				0x0050400C /*DRAMTMG3*/
+				0x07040407 /*DRAMTMG4*/
+				0x06060303 /*DRAMTMG5*/
+				0x02020002 /*DRAMTMG6*/
+				0x00000202 /*DRAMTMG7*/
+				0x00001005 /*DRAMTMG8*/
+				0x000D041B /*DRAMTMG1*/4
+				0x06000600 /*ODTCFG*/
+			>;
+
+			st,ctl-map = <
+				0x00080808 /*ADDRMAP1*/
+				0x00000000 /*ADDRMAP2*/
+				0x00000000 /*ADDRMAP3*/
+				0x00001F1F /*ADDRMAP4*/
+				0x07070707 /*ADDRMAP5*/
+				0x0F070707 /*ADDRMAP6*/
+				0x00000000 /*ADDRMAP9*/
+				0x00000000 /*ADDRMAP10*/
+				0x00000000 /*ADDRMAP11*/
+			>;
+
+			st,ctl-perf = <
+				0x00001201 /*SCHED*/
+				0x00001201 /*SCHED*/1
+				0x01000001 /*PERFHPR1*/
+				0x08000200 /*PERFLPR1*/
+				0x08000400 /*PERFWR1*/
+				0x00010000 /*PCFGR_0*/
+				0x00000000 /*PCFGW_0*/
+				0x02100B03 /*PCFGQOS0_0*/
+				0x00800100 /*PCFGQOS1_0*/
+				0x01100B03 /*PCFGWQOS0_0*/
+				0x01000200 /*PCFGWQOS1_0*/
+				0x00010000 /*PCFGR_1*/
+				0x00000000 /*PCFGW_1*/
+				0x02100B03 /*PCFGQOS0_1*/
+				0x00800000 /*PCFGQOS1_1*/
+				0x01100B03 /*PCFGWQOS0_1*/
+				0x01000200 /*PCFGWQOS1_1*/
+			>;
+
+			st,phy-reg = <
+				0x01442E02 /*PGCR*/
+				0x10400812 /*ACIOCR*/
+				0x00000C40 /*DXCCR*/
+				0xF200001F /*DSGCR*/
+				0x0000000B /*DCR*/
+				0x00010000 /*ODTCR*/
+				0x0000007B /*ZQ0CR1*/
+				0x0000CE81 /*DX0GCR*/
+				0x0000CE81 /*DX1GCR*/
+				0x0000CE81 /*DX2GCR*/
+				0x0000CE81 /*DX3GCR*/
+			>;
+
+			st,phy-timing = <
+				0x0022A41B /*PTR0*/
+				0x047C0740 /*PTR1*/
+				0x042D9C80 /*PTR2*/
+				0x369477D0 /*DTPR0*/
+				0x098A00D8 /*DTPR1*/
+				0x10023600 /*DTPR2*/
+				0x00000830 /*MR0*/
+				0x00000000 /*MR1*/
+				0x00000208 /*MR2*/
+				0x00000000 /*MR3*/
+			>;
+
+			status = "okay";
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/memory-controllers/st,stm32mp2-ddr.txt b/docs/devicetree/bindings/memory-controllers/st,stm32mp2-ddr.txt
new file mode 100644
index 0000000000..6b79a7e32e
--- /dev/null
+++ b/docs/devicetree/bindings/memory-controllers/st,stm32mp2-ddr.txt
@@ -0,0 +1,543 @@
+st,stm32mp2 DDR3/DDR4/LPDDR4 controller (DDRCTRL and DDRPHYC)
+
+--------------------
+Required properties:
+--------------------
+- compatible	: Should be "st,stm32mp2-ddr"
+- reg		: controller (DDRCTRL) and phy (DDRPHYC) base address
+
+And the supply attributes are depending on the DDR type (DDR3/DDR4/LPDDR4).
+
+For DDR3:
+- vdd-supply	: phandle to the VDD/VDDQ regulator device tree node.
+- vref-supply	: phandle to the VREFCA/VREFDQ regulator device tree node.
+- vtt-supply	: phandle to the VTT regulator device tree node.
+
+For DDR4:
+- vdd-supply	: phandle to the VDD/VDDQ regulator device tree node.
+- vref-supply	: phandle to the VREFCA regulator device tree node.
+- vpp-supply	: phandle to the VPP regulator device tree node.
+- vtt-supply	: phandle to the VTT regulator device tree node.
+
+For LPDDR4:
+- vdd1-supply	: phandle to the VDD1 regulator device tree node.
+- vdd2-supply	: phandle to the VDD2/VDDCA regulator device tree node.
+- vddq-supply	: phandle to the VDDQ regulator device tree node.
+
+the next attributes are DDR parameters, they are generated by DDR tools
+included in STM32 Cube tool
+
+info attributes:
+----------------
+- st,mem-name	: name for DDR configuration, simple string for information
+- st,mem-speed	: DDR expected speed for the setting in kHz
+- st,mem-size	: DDR mem size in byte
+
+
+controller attributes:
+----------------------
+- st,ctl-reg	: controller values depending of the DDR type
+		  (DDR3/DDR4/LPDDR4)
+	48 values are requested in this order
+		MSTR
+		MRCTRL0
+		MRCTRL1
+		MRCTRL2
+		DERATEEN
+		DERATEINT
+		DERATECTL
+		PWRCTL
+		PWRTMG
+		HWLPCTL
+		RFSHCTL0
+		RFSHCTL1
+		RFSHCTL3
+		CRCPARCTL0
+		CRCPARCTL1
+		INIT0
+		INIT1
+		INIT2
+		INIT3
+		INIT4
+		INIT5
+		INIT6
+		INIT7
+		DIMMCTL
+		RANKCTL
+		RANKCTL1
+		ZQCTL0
+		ZQCTL1
+		ZQCTL2
+		DFITMG0
+		DFITMG1
+		DFILPCFG0
+		DFILPCFG1
+		DFIUPD0
+		DFIUPD1
+		DFIUPD2
+		DFIMISC
+		DFITMG2
+		DFITMG3
+		DBICTL
+		DFIPHYMSTR
+		DBG0
+		DBG1
+		DBGCMD
+		SWCTL
+		SWCTLSTATIC
+		POISONCFG
+		PCCFG
+
+- st,ctl-timing	: controller values depending of frequency and timing parameter
+		  of DDR
+	 20 values are requested in this order
+		RFSHTMG
+		RFSHTMG1
+		DRAMTMG0
+		DRAMTMG1
+		DRAMTMG2
+		DRAMTMG3
+		DRAMTMG4
+		DRAMTMG5
+		DRAMTMG6
+		DRAMTMG7
+		DRAMTMG8
+		DRAMTMG9
+		DRAMTMG10
+		DRAMTMG11
+		DRAMTMG12
+		DRAMTMG13
+		DRAMTMG14
+		DRAMTMG15
+		ODTCFG
+		ODTMAP
+
+- st,ctl-map	: controller values depending of address mapping
+	12 values are requested in this order
+		ADDRMAP0
+		ADDRMAP1
+		ADDRMAP2
+		ADDRMAP3
+		ADDRMAP4
+		ADDRMAP5
+		ADDRMAP6
+		ADDRMAP7
+		ADDRMAP8
+		ADDRMAP9
+		ADDRMAP10
+		ADDRMAP11
+
+- st,ctl-perf	: controller values depending of performance and scheduling
+	21 values are requested in this order
+		SCHED
+		SCHED1
+		PERFHPR1
+		PERFLPR1
+		PERFWR1
+		SCHED3
+		SCHED4
+		PCFGR_0
+		PCFGW_0
+		PCTRL_0
+		PCFGQOS0_0
+		PCFGQOS1_0
+		PCFGWQOS0_0
+		PCFGWQOS1_0
+		PCFGR_1
+		PCFGW_1
+		PCTRL_1
+		PCFGQOS0_1
+		PCFGQOS1_1
+		PCFGWQOS0_1
+		PCFGWQOS1_1
+
+phyc attributes:
+----------------
+- st,phy-basic	: basic entry values for the PHYINIT driver
+	19 values are requested in this order
+		UIB_DRAMTYPE
+		UIB_DIMMTYPE
+		UIB_LP4XMODE
+		UIB_NUMDBYTE
+		UIB_NUMACTIVEDBYTEDFI0
+		UIB_NUMACTIVEDBYTEDFI1
+		UIB_NUMANIB
+		UIB_NUMRANK_DFI0
+		UIB_NUMRANK_DFI1
+		UIB_DRAMDATAWIDTH
+		UIB_NUMPSTATES
+		UIB_FREQUENCY_0
+		UIB_PLLBYPASS_0
+		UIB_DFIFREQRATIO_0
+		UIB_DFI1EXISTS
+		UIB_TRAIN2D
+		UIB_HARDMACROVER
+		UIB_READDBIENABLE_0
+		UIB_DFIMODE
+
+- st,phy-advanced: advanced entry values for the PHYINIT driver
+	43 values are requested in this order
+		UIA_LP4RXPREAMBLEMODE_0
+		UIA_LP4POSTAMBLEEXT_0
+		UIA_D4RXPREAMBLELENGTH_0
+		UIA_D4TXPREAMBLELENGTH_0
+		UIA_EXTCALRESVAL
+		UIA_IS2TTIMING_0
+		UIA_ODTIMPEDANCE_0
+		UIA_TXIMPEDANCE_0
+		UIA_ATXIMPEDANCE
+		UIA_MEMALERTEN
+		UIA_MEMALERTPUIMP
+		UIA_MEMALERTVREFLEVEL
+		UIA_MEMALERTSYNCBYPASS
+		UIA_DISDYNADRTRI_0
+		UIA_PHYMSTRTRAININTERVAL_0
+		UIA_PHYMSTRMAXREQTOACK_0
+		UIA_WDQSEXT
+		UIA_CALINTERVAL
+		UIA_CALONCE
+		UIA_LP4RL_0
+		UIA_LP4WL_0
+		UIA_LP4WLS_0
+		UIA_LP4DBIRD_0
+		UIA_LP4DBIWR_0
+		UIA_LP4NWR_0
+		UIA_LP4LOWPOWERDRV
+		UIA_DRAMBYTESWAP
+		UIA_RXENBACKOFF
+		UIA_TRAINSEQUENCECTRL
+		UIA_SNPSUMCTLOPT
+		UIA_SNPSUMCTLF0RC5X_0
+		UIA_TXSLEWRISEDQ_0
+		UIA_TXSLEWFALLDQ_0
+		UIA_TXSLEWRISEAC
+		UIA_TXSLEWFALLAC
+		UIA_DISABLERETRAINING
+		UIA_DISABLEPHYUPDATE
+		UIA_ENABLEHIGHCLKSKEWFIX
+		UIA_DISABLEUNUSEDADDRLNS
+		UIA_PHYINITSEQUENCENUM
+		UIA_ENABLEDFICSPOLARITYFIX
+		UIA_PHYVREF
+		UIA_SEQUENCECTRL_0
+
+- st,phy-mr	: mode register entry values for the PHYINIT driver
+	12 values are requested in this order
+		UIM_MR0_0
+		UIM_MR1_0
+		UIM_MR2_0
+		UIM_MR3_0
+		UIM_MR4_0
+		UIM_MR5_0
+		UIM_MR6_0
+		UIM_MR11_0
+		UIM_MR12_0
+		UIM_MR13_0
+		UIM_MR14_0
+		UIM_MR22_0
+
+- st,phy-swizzle: swizzling entry values for the PHYINIT driver
+	(i.e. signal / ball multiplexing)
+	44 values are requested in this order
+		UIS_SWIZZLE_0
+		UIS_SWIZZLE_1
+		UIS_SWIZZLE_2
+		UIS_SWIZZLE_3
+		UIS_SWIZZLE_4
+		UIS_SWIZZLE_5
+		UIS_SWIZZLE_6
+		UIS_SWIZZLE_7
+		UIS_SWIZZLE_8
+		UIS_SWIZZLE_9
+		UIS_SWIZZLE_10
+		UIS_SWIZZLE_11
+		UIS_SWIZZLE_12
+		UIS_SWIZZLE_13
+		UIS_SWIZZLE_14
+		UIS_SWIZZLE_15
+		UIS_SWIZZLE_16
+		UIS_SWIZZLE_17
+		UIS_SWIZZLE_18
+		UIS_SWIZZLE_19
+		UIS_SWIZZLE_20
+		UIS_SWIZZLE_21
+		UIS_SWIZZLE_22
+		UIS_SWIZZLE_23
+		UIS_SWIZZLE_24
+		UIS_SWIZZLE_25
+		UIS_SWIZZLE_26
+		UIS_SWIZZLE_27
+		UIS_SWIZZLE_28
+		UIS_SWIZZLE_29
+		UIS_SWIZZLE_30
+		UIS_SWIZZLE_31
+		UIS_SWIZZLE_32
+		UIS_SWIZZLE_33
+		UIS_SWIZZLE_34
+		UIS_SWIZZLE_35
+		UIS_SWIZZLE_36
+		UIS_SWIZZLE_37
+		UIS_SWIZZLE_38
+		UIS_SWIZZLE_39
+		UIS_SWIZZLE_40
+		UIS_SWIZZLE_41
+		UIS_SWIZZLE_42
+		UIS_SWIZZLE_43
+
+Example:
+
+/ {
+	soc@0 {
+		ddr: ddr@48040000 {
+			compatible = "st,stm32mp2-ddr";
+
+			reg = <0x48040000 0x10000>,
+			      <0x48c00000 0x400000>;
+
+			st,mem-name = "DDR4 2x16Gbits 2x16bits 1200MHz";
+			st,mem-speed = <1200000>;
+			st,mem-size = <(0x100000000 >> 32) (0x100000000 & 0xFFFFFFFF)>;
+
+			st,ctl-reg = <
+				0x01040010
+				0x00000030
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00130001
+				0x00000002
+				0x00210010
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00001000
+				0xC0020002
+				0x00010002
+				0x00000D00
+				0x09400103
+				0x00180000
+				0x00100004
+				0x00080460
+				0x00000C0F
+				0x00000000
+				0x0000066F
+				0x01000040
+				0x2000493E
+				0x00000000
+				0x038F8209
+				0x00080303
+				0x07004111
+				0x00000000
+				0xC0300018
+				0x005700B4
+				0x80000000
+				0x00000041
+				0x00000F09
+				0x00000000
+				0x00000001
+				0x80000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+			>;
+
+			st,ctl-timing = <
+				0x0092014A
+				0x008C0000
+				0x11152815
+				0x0004051E
+				0x0609060D
+				0x0050400C
+				0x0904050A
+				0x06060403
+				0x02020005
+				0x00000202
+				0x0606100B
+				0x0002040A
+				0x001C180A
+				0x4408021C
+				0x0C020010
+				0x1C200004
+				0x000000A0
+				0x00000000
+				0x06000618
+				0x00000001
+			>;
+
+			st,ctl-map = <
+				0x0000001F
+				0x003F0909
+				0x00000000
+				0x00000000
+				0x00001F1F
+				0x070F0707
+				0x07070707
+				0x00000F07
+				0x00003F08
+				0x07070707
+				0x07070707
+				0x00000007
+			>;
+
+			st,ctl-perf = <
+				0x80001B0C
+				0x00000000
+				0x04000200
+				0x08000020
+				0x08000400
+				0x00704100
+				0x00004100
+				0x00000000
+				0x0021000C
+				0x01000080
+				0x01100C07
+				0x04000200
+				0x00704100
+				0x00004100
+				0x00000000
+				0x00100007
+				0x01000080
+				0x01100C07
+				0x04000200
+			>;
+
+			st,phy-basic = <
+				0x00000000
+				0x00000004
+				0x00000000
+				0x00000004
+				0x00000004
+				0x00000000
+				0x00000008
+				0x00000001
+				0x00000001
+				0x00000010
+				0x00000001
+				0x000004B0
+				0x00000000
+				0x00000001
+				0x00000001
+				0x00000000
+				0x00000003
+				0x00000000
+				0x00000000
+			>;
+
+			st,phy-advanced = <
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000035
+				0x00000028
+				0x00000028
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000001
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000009
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x0000000F
+				0x0000000F
+				0x0000000F
+				0x0000000F
+				0x00000001
+				0x00000000
+				0x00000000
+				0x00000001
+				0x00000000
+				0x00000000
+				0x0000005E
+				0x0000031F
+			>;
+
+			st,phy-mr = <
+				0x00000940
+				0x00000103
+				0x00000018
+				0x00000000
+				0x00000008
+				0x00000460
+				0x00000C0F
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+			>;
+
+			st,phy-swizzle = <
+				0x0000000C
+				0x00000005
+				0x00000013
+				0x0000001A
+				0x00000009
+				0x00000003
+				0x00000001
+				0x00000019
+				0x00000007
+				0x00000004
+				0x0000000A
+				0x0000000D
+				0x00000014
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000006
+				0x0000000B
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000008
+				0x00000002
+				0x00000018
+				0x1A13050C
+				0x19010309
+				0x0D0A0407
+				0x00000014
+				0x000B0600
+				0x02080000
+				0x00000018
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+				0x00000000
+			>;
+
+			status = "okay";
+		};
+	};
+};
diff --git a/docs/devicetree/bindings/mmc/mmci.txt b/docs/devicetree/bindings/mmc/mmci.txt
new file mode 100644
index 0000000000..6d3c626e01
--- /dev/null
+++ b/docs/devicetree/bindings/mmc/mmci.txt
@@ -0,0 +1,72 @@
+* ARM PrimeCell MultiMedia Card Interface (MMCI) PL180/1
+
+The ARM PrimeCell MMCI PL180 and PL181 provides an interface for
+reading and writing to MultiMedia and SD cards alike.
+
+This file documents differences between the core properties described
+by mmc.txt and the properties used by the mmci driver. Using "st" as
+the prefix for a property, indicates support by the ST Micro variant.
+
+Required properties:
+- compatible             : contains "arm,pl18x", "arm,primecell".
+- vmmc-supply            : phandle to the regulator device tree node, mentioned
+                           as the VCC/VDD supply in the eMMC/SD specs.
+
+Optional properties:
+- arm,primecell-periphid : contains the PrimeCell Peripheral ID, it overrides
+                           the ID provided by the HW
+- resets                 : phandle to internal reset line.
+			   Should be defined for sdmmc variant.
+- vqmmc-supply           : phandle to the regulator device tree node, mentioned
+                           as the VCCQ/VDD_IO supply in the eMMC/SD specs.
+specific for ux500 variant:
+- st,sig-dir-dat0        : bus signal direction pin used for DAT[0].
+- st,sig-dir-dat2        : bus signal direction pin used for DAT[2].
+- st,sig-dir-dat31       : bus signal direction pin used for DAT[3] and DAT[1].
+- st,sig-dir-dat74       : bus signal direction pin used for DAT[4] to DAT[7].
+- st,sig-dir-cmd         : cmd signal direction pin used for CMD.
+- st,sig-pin-fbclk       : feedback clock signal pin used.
+
+specific for sdmmc variant:
+- st,sig-dir             : signal direction polarity used for cmd, dat0 dat123.
+- st,neg-edge            : data & command phase relation, generated on
+                           sd clock falling edge.
+- st,use-ckin            : use ckin pin from an external driver to sample
+                           the receive data (example: with voltage
+			   switch transceiver).
+
+Deprecated properties:
+- mmc-cap-mmc-highspeed  : indicates whether MMC is high speed capable.
+- mmc-cap-sd-highspeed   : indicates whether SD is high speed capable.
+
+Example:
+
+sdi0_per1@80126000 {
+	compatible = "arm,pl18x", "arm,primecell";
+	reg = <0x80126000 0x1000>;
+	interrupts = <0 60 IRQ_TYPE_LEVEL_HIGH>;
+
+	dmas = <&dma 29 0 0x2>, /* Logical - DevToMem */
+	       <&dma 29 0 0x0>; /* Logical - MemToDev */
+	dma-names = "rx", "tx";
+
+	clocks = <&prcc_kclk 1 5>, <&prcc_pclk 1 5>;
+	clock-names = "sdi", "apb_pclk";
+
+	max-frequency = <100000000>;
+	bus-width = <4>;
+	cap-sd-highspeed;
+	cap-mmc-highspeed;
+	cd-gpios  = <&gpio2 31 0x4>; // 95
+	st,sig-dir-dat0;
+	st,sig-dir-dat2;
+	st,sig-dir-cmd;
+	st,sig-pin-fbclk;
+
+	vmmc-supply = <&ab8500_ldo_aux3_reg>;
+	vqmmc-supply = <&vmmci>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdi0_default_mode>;
+	pinctrl-1 = <&sdi0_sleep_mode>;
+};
diff --git a/docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt b/docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt
new file mode 100644
index 0000000000..51576a3844
--- /dev/null
+++ b/docs/devicetree/bindings/mmc/st,stm32-sdmmc2.txt
@@ -0,0 +1,22 @@
+* STMicroelectronics STM32 SDMMC2 controller
+
+The highspeed MMC host controller on STM32 soc family
+provides an interface for MMC, SD and SDIO types of memory cards.
+
+This file documents differences between the core properties described
+by mmci.txt and the properties used by the sdmmc2 driver.
+
+Required properties:
+ - compatible: should be one of:
+   "st,stm32-sdmmc2"
+
+Example:
+	sdmmc1: sdmmc@0x58005000 {
+		compatible = "st,stm32-sdmmc2";
+		reg = <0x58005000 0x1000>;
+		clocks = <&rcc SDMMC1_K>;
+		resets = <&rcc SDMMC1_R>;
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		status = "disabled";
+	};
diff --git a/docs/devicetree/bindings/power/st,stm32mp1-pwr.txt b/docs/devicetree/bindings/power/st,stm32mp1-pwr.txt
new file mode 100644
index 0000000000..22779b05af
--- /dev/null
+++ b/docs/devicetree/bindings/power/st,stm32mp1-pwr.txt
@@ -0,0 +1,43 @@
+STMicroelectronics STM32MP1 Power Management Controller
+=======================================================
+
+The PWR IP is responsible for handling the power related resources such as
+clocks, power supplies and resets. It provides 6 wake-up pins that are handled
+by an interrupt-controller. Wake-up pin can be used to wake-up from STANDBY SoC
+state.
+
+Required properties:
+- compatible should be: "st,stm32mp1-pwr", "st,stm32-pwr"
+- reg: should be register base and length as documented in the
+  datasheet
+
+Optional Properties:
+- Nodes corresponding to PSCI commands issued by kernel:
+  - system_suspend_supported_soc_modes: list of supported SoC modes in suspend
+  - system_off_soc_mode: SoC mode for shutdown
+  - st,retram-enabled-in-standby-ddr-sr: enable retram during standby-ddr-sr
+
+The list of SoC modes is in include/dt-bindings/power/stm32mp1-power.h:
+  - modes for system_suspend
+	1 -> STM32_PM_CSTOP_ALLOW_STOP
+	2 -> STM32_PM_CSTOP_ALLOW_LP_STOP
+	3 -> STM32_PM_CSTOP_ALLOW_LPLV_STOP
+	4 -> STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+  - modes for system_off
+	6 -> STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF
+	7 -> STM32_PM_SHUTDOWN
+
+Example:
+
+pwr: pwr@50001000 {
+	compatible = "st,stm32mp1-pwr", "st,stm32-pwr", "syscon", "simple-mfd";
+	reg = <0x50001000 0x400>;
+
+	system_suspend_supported_soc_modes = <
+		STM32_PM_CSLEEP_RUN
+		STM32_PM_CSTOP_ALLOW_LP_STOP
+		STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
+	>;
+
+	system_off_soc_mode = <STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF>;
+};
diff --git a/docs/devicetree/bindings/power/st,stm32mp25-pwr.txt b/docs/devicetree/bindings/power/st,stm32mp25-pwr.txt
new file mode 100644
index 0000000000..b7fa3fed50
--- /dev/null
+++ b/docs/devicetree/bindings/power/st,stm32mp25-pwr.txt
@@ -0,0 +1,60 @@
+STMicroelectronics STM32MP25 Power Management Controller
+=======================================================
+
+The PWR IP is responsible for handling the power related resources such as
+clocks, power supplies and resets.
+When optional properties are absent, default values are used and those
+properties should be present only to overidde those values.
+
+Required properties:
+- compatible should be: "st,stm32mp25-pwr"
+- reg: should be register base and length as documented in the
+  datasheet
+- vddio(|[1-4]): sub-node for each VDD I/O description with valid name =
+  "vddio", "vddio1", "vddio2", "vddio3" and "vddio4".
+  The definition for each of these nodes is defined using the standard binding
+  for regulators at Documentation/devicetree/bindings/regulator/regulator.txt
+  or regulator.yaml, like "regulator-name", "regulator-min-microvolt",
+  "regulator-max-microvolt", "regulator-always-on"
+  - vdd-supply: Input supply phandle (VDD) for I/Os for "vddio" node
+  - vddio[1-4]-supply: Input supply phandle (VDIO1-4) for respectively
+                       "vddio1", "vddio2", "vddio3" and "vddio4" nodes,
+                       the I/Os independent from any other supply.
+
+Optional Properties:
+- st,popl-d1-ms : PWR_CPU_ON pulse low configuration (PWR_D1CR)
+- st,podh-d2-ms : PWR_ON delay high configuration (PWR_D2CR)
+- st,popl-d2-ms : PWR_ON pulse low configuration (PWR_D2CR)
+- st,lpcfg-d2 : PWR_ON pin configuration (PWR_D2CR)
+- st,lplvdly-d2 : LPLV delay value (PWR_D2CR), 3bits and with 6xLSI cycles unit
+                  (0:187 μs... 111:1.5 ms)
+- st,lpstop1dly-us: PWR_LP delay value in us for LP-Stop1 mode
+                    (RCC_PWRLPDLYCR.PWRLP_DLY)
+
+Example:
+
+pwr: pwr@44210000 {
+	compatible = "st,stm32mp25-pwr";
+	reg = <0x44210000 0x400>;
+
+	vddio1: vddio1 {
+		regulator-name = "vddio1";
+		vddio1-supply = <&vddio_sdcard>;
+	};
+	vddio2: vddio2 {
+		regulator-name = "vddio2";
+		vddio2-supply = <&v1v8>;
+	};
+	vddio3: vddio3 {
+		regulator-name = "vddio3";
+		vddio3-supply = <&vddio_pmic>;
+	};
+	vddio4: vddio4 {
+		regulator-name = "vddio4";
+		vddio4-supply = <&vddio_pmic>;
+	};
+	vddio: vddio {
+		regulator-name = "vddio";
+		vdd-supply = <&vddio_pmic>;
+	};
+};
diff --git a/docs/devicetree/bindings/power/st,stpmic1.txt b/docs/devicetree/bindings/power/st,stpmic1.txt
new file mode 100644
index 0000000000..83307d23b4
--- /dev/null
+++ b/docs/devicetree/bindings/power/st,stpmic1.txt
@@ -0,0 +1,94 @@
+* STMicroelectronics STPMIC1 Power Management IC
+
+Required parent device properties:
+- compatible:			"st,stpmic1"
+- reg:				The I2C slave address for the STPMIC1 chip.
+- interrupts:			The interrupt lines the device is connected to.
+				The second interrupt is used for wake-up.
+- #interrupt-cells:		Should be 2.
+- interrupt-controller: 	Describes the STPMIC1 as an interrupt
+  controller (has its own domain). Interrupt number are the following:
+	/* Interrupt Register 1 (0x50 for latch) */
+	IT_SWOUT_R=0
+	IT_SWOUT_F=1
+	IT_VBUS_OTG_R=2
+	IT_VBUS_OTG_F=3
+	IT_WAKEUP_R=4
+	IT_WAKEUP_F=5
+	IT_PONKEY_R=6
+	IT_PONKEY_F=7
+	/* Interrupt Register 2 (0x51 for latch) */
+	IT_OVP_BOOST=8
+	IT_OCP_BOOST=9
+	IT_OCP_SWOUT=10
+	IT_OCP_OTG=11
+	IT_CURLIM_BUCK4=12
+	IT_CURLIM_BUCK3=13
+	IT_CURLIM_BUCK2=14
+	IT_CURLIM_BUCK1=15
+	/* Interrupt Register 3 (0x52 for latch) */
+	IT_SHORT_SWOUT=16
+	IT_SHORT_SWOTG=17
+	IT_CURLIM_LDO6=18
+	IT_CURLIM_LDO5=19
+	IT_CURLIM_LDO4=20
+	IT_CURLIM_LDO3=21
+	IT_CURLIM_LDO2=22
+	IT_CURLIM_LDO1=23
+	/* Interrupt Register 3 (0x52 for latch) */
+	IT_SWIN_R=24
+	IT_SWIN_F=25
+	IT_RESERVED_1=26
+	IT_RESERVED_2=27
+	IT_VINLOW_R=28
+	IT_VINLOW_F=29
+	IT_TWARN_R=30
+	IT_TWARN_F=31
+
+STPMIC1 consists in a varied group of sub-devices.
+Each sub-device binding is be described in own documentation file.
+
+Device			 Description
+------			------------
+st,stpmic1-onkey	: Power on key, see ../input/st,stpmic1-onkey.txt
+st,stpmic1-regulators	: Regulators, see ../regulator/st,stpmic1-regulator.txt
+st,stpmic1-wdt		: Watchdog, see ../watchdog/st,stpmic1-wdt.txt
+
+Example:
+
+pmic: pmic@33 {
+	compatible = "st,stpmic1";
+	reg = <0x33>;
+	interrupt-parent = <&gpioa>;
+	interrupts = <0 2>;
+	interrupt-controller;
+	#interrupt-cells = <2>;
+
+	onkey {
+		compatible = "st,stpmic1-onkey";
+		interrupts = <IT_PONKEY_F 0>,<IT_PONKEY_R 1>;
+		interrupt-names = "onkey-falling", "onkey-rising";
+		power-off-time-sec = <10>;
+	};
+
+	watchdog {
+		compatible = "st,stpmic1-wdt";
+	};
+
+	regulators {
+		compatible = "st,stpmic1-regulators";
+
+		vdd_core: buck1 {
+			regulator-name = "vdd_core";
+			regulator-boot-on;
+			regulator-min-microvolt = <700000>;
+			regulator-max-microvolt = <1200000>;
+		};
+		vdd: buck3 {
+			regulator-name = "vdd";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-boot-on;
+			regulator-pull-down;
+		};
+	};
diff --git a/docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt b/docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt
new file mode 100644
index 0000000000..b4edaf7c7f
--- /dev/null
+++ b/docs/devicetree/bindings/reset/st,stm32mp1-rcc.txt
@@ -0,0 +1,6 @@
+STMicroelectronics STM32MP1 Peripheral Reset Controller
+=======================================================
+
+The RCC IP is both a reset and a clock controller.
+
+Please see Documentation/devicetree/bindings/clock/st,stm32mp1-rcc.txt
diff --git a/docs/devicetree/bindings/rng/st,stm32-rng.txt b/docs/devicetree/bindings/rng/st,stm32-rng.txt
new file mode 100644
index 0000000000..3c613d7914
--- /dev/null
+++ b/docs/devicetree/bindings/rng/st,stm32-rng.txt
@@ -0,0 +1,23 @@
+STMicroelectronics STM32 HW RNG
+===============================
+
+The STM32 hardware random number generator is a simple fixed purpose IP and
+is fully separated from other crypto functions.
+
+Required properties:
+
+- compatible : Should be "st,stm32-rng"
+- reg : Should be register base and length as documented in the datasheet
+- clocks : The clock needed to enable the RNG
+
+Optional properties:
+- resets : The reset to properly start RNG
+- clock-error-detect : Enable the clock detection management
+
+Example:
+
+	rng: rng@50060800 {
+		compatible = "st,stm32-rng";
+		reg = <0x50060800 0x400>;
+		clocks = <&rcc 0 38>;
+	};
diff --git a/docs/devicetree/bindings/serial/st,stm32-usart.txt b/docs/devicetree/bindings/serial/st,stm32-usart.txt
new file mode 100644
index 0000000000..08b499045a
--- /dev/null
+++ b/docs/devicetree/bindings/serial/st,stm32-usart.txt
@@ -0,0 +1,88 @@
+* STMicroelectronics STM32 USART
+
+Required properties:
+- compatible: can be either:
+  - "st,stm32-uart",
+  - "st,stm32f7-uart",
+  - "st,stm32h7-uart".
+  depending is compatible with stm32(f4), stm32f7 or stm32h7.
+- reg: The address and length of the peripheral registers space
+- interrupts:
+  - The interrupt line for the USART instance,
+  - An optional wake-up interrupt.
+- interrupt-names: Contains "event" for the USART interrupt line.
+- clocks: The input clock of the USART instance
+
+Optional properties:
+- resets: Must contain the phandle to the reset controller.
+- pinctrl-names: Set to "default". An additional "sleep" state can be defined
+  to set pins in sleep state when in low power. In case the device is used as
+  a wakeup source, "idle" state is defined in order to keep RX pin active.
+  For a console device, an optional state "no_console_suspend" can be defined
+  to enable console messages during suspend. Typically, "no_console_suspend" and
+  "default" states can refer to the same pin configuration.
+- pinctrl-n: Phandle(s) pointing to pin configuration nodes.
+  For Pinctrl properties see ../pinctrl/pinctrl-bindings.txt
+- st,hw-flow-ctrl: bool flag to enable hardware flow control.
+- rs485-rts-delay, rs485-rx-during-tx, rs485-rts-active-low,
+  linux,rs485-enabled-at-boot-time: see rs485.txt.
+- dmas: phandle(s) to DMA controller node(s). Refer to stm32-dma.txt
+- dma-names: "rx" and/or "tx"
+- wakeup-source: bool flag to indicate this device has wakeup capabilities
+- interrupt-names : Should contain "wakeup" if optional wake-up interrupt is
+  used.
+
+Note for dma using:
+- "tx" dma can be used without any constraint since it uses single
+dma transfers.
+- "rx" dma using requires some attention:
+   1) if you cannot anticipate the length of your received packets
+   and if your usart device embeds an internal fifo, then DON'T use
+   dma mode.
+   2) if you enable dma mode WITHOUT mdma intermediate copy (cf.
+   stm32-dma.txt), then the availability of the received data will
+   depend on the dma driver policy and it may be delayed until dma
+   internal fifo is full. The usart driver will see this checking
+   the dma residue when rx interrupt (RXNE or RTO) occurs.
+   3) if you enable dma mode WITH mdma intermediate copy (cf.
+   stm32-dma.txt) then the usart driver will never see the dma
+   residue becoming smaller than RX_BUF_P but it will get its
+   rx dma complete callback called when the cyclic transfer period
+   (RX_BUF_P) is reached.
+The three possibilities above are ordered from the most cpu time
+consuming one to the least one. The counterpart of this optimisation
+is the reception granularity achievable by the usart driver, from
+one byte up to RX_BUF_P.
+
+Examples:
+usart4: serial@40004c00 {
+	compatible = "st,stm32-uart";
+	reg = <0x40004c00 0x400>;
+	interrupts = <52>;
+	clocks = <&clk_pclk1>;
+	pinctrl-names = "default", "sleep", "idle", "no_console_suspend";
+	pinctrl-0 = <&pinctrl_usart4>;
+	pinctrl-1 = <&pinctrl_usart4_sleep>;
+	pinctrl-2 = <&pinctrl_usart4_idle>;
+	pinctrl-3 = <&pinctrl_usart4>;
+};
+
+usart2: serial@40004400 {
+	compatible = "st,stm32-uart";
+	reg = <0x40004400 0x400>;
+	interrupts = <38>;
+	clocks = <&clk_pclk1>;
+	st,hw-flow-ctrl;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usart2 &pinctrl_usart2_rtscts>;
+};
+
+usart1: serial@40011000 {
+	compatible = "st,stm32-uart";
+	reg = <0x40011000 0x400>;
+	interrupts = <37>;
+	clocks = <&rcc 0 164>;
+	dmas = <&dma2 2 4 0x414 0x0>,
+	       <&dma2 7 4 0x414 0x0>;
+	dma-names = "rx", "tx";
+};
diff --git a/docs/devicetree/bindings/soc/st,stm32-etzpc.txt b/docs/devicetree/bindings/soc/st,stm32-etzpc.txt
new file mode 100644
index 0000000000..ec58557adf
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-etzpc.txt
@@ -0,0 +1,54 @@
+STM32 ETZPC
+---------------------------------
+
+Required properties:
+- compatible: should be "st,stm32-etzpc"
+- reg: physical base address and length of the registers set for the device
+- clocks: reference to the clock entry
+
+Optional property:
+- st,decprot: Configure option to properly set firewall for IPs.
+
+Examples:
+etzpc: etzpc@5C007000 {
+			compatible = "st,stm32-etzpc";
+			reg = <0x5C007000 0x400>;
+			clocks = <&rcc TZPC>;
+		};
+
+Firewall specifications
+=======================
+
+DECPROT macro must be used to properly configure IP firewalling. It must
+specify ID, domain and locking register status.
+
+The macro is defined in the binding header file [1].
+
+Example:
+	... {
+	st,decprot = <
+	DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW,	DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW,	DECPROT_UNLOCK)
+	DECPROT(STM32MP1_ETZPC_GPIOZ_ID, DECPROT_NS_RW,	DECPROT_UNLOCK)>;
+	};
+
+Specify Peripheral IDs
+=======================
+
+Each peripheral is identified with a specific ID. Each platform defines the
+identifiers relevant to that platform. Peripheral IDs are defined in [1].
+
+Specify domain
+==============
+Firewall controls peripherals in specific domains:
+
+DECPROT_S_RW		0x0  -> Read/write Secure
+DECPROT_NS_R_S_W	0x1  -> Non secure read / Read/write Secure
+DECPROT_MCU_ISOLATION	0x2  -> MCU access only
+DECPROT_NS_RW		0x3  -> Non secure read/write
+
+
+[1] include/dt-bindings/soc/st,stm32-etzpc.h
+
diff --git a/docs/devicetree/bindings/soc/st,stm32-romem.txt b/docs/devicetree/bindings/soc/st,stm32-romem.txt
new file mode 100644
index 0000000000..424e18a5cf
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-romem.txt
@@ -0,0 +1,52 @@
+STMicroelectronics STM32 Factory-programmed data device tree bindings
+
+This represents STM32 Factory-programmed read only non-volatile area: locked
+flash, OTP, read-only HW regs... This contains various information such as:
+analog calibration data for temperature sensor (e.g. TS_CAL1, TS_CAL2),
+internal vref (VREFIN_CAL), unique device ID...
+
+Required properties:
+- compatible:		Should be one of:
+			"st,stm32f4-otp"
+			"st,stm32mp13-bsec"
+			"st,stm32mp15-bsec"
+- reg:			Offset and length of factory-programmed area.
+- #address-cells:	Should be '<1>'.
+- #size-cells:		Should be '<1>'.
+
+Optional Data cells:
+- Must be child nodes as described in nvmem.txt.
+
+Optional-properties:
+- "st,non-secure-otp" specifies that the OTP can be accessed by non-secure
+  world through secure world services. Only useful for upper OTPs. This
+  property mandates 32-bit granularity of the related nvmem area, that is
+  offset and length are both multiple of 4.
+
+Example on stm32f4:
+	romem: efuse@1fff7800 {
+		compatible = "st,stm32f4-otp";
+		reg = <0x1fff7800 0x400>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		/* Data cells: ts_cal1 at 0x1fff7a2c */
+		ts_cal1: calib@22c {
+			reg = <0x22c 0x2>;
+		};
+		...
+	};
+
+Example on stm32mp15:
+	bsec: efuse@5c005000 {
+		compatible = "st,stm32mp15-bsec";
+		reg = <0x5c005000 0x400>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		mac_addr: mac_addr@e4 {
+			reg = <0xe4 0x8>;
+			st,non-secure-otp;
+		};
+		...
+	};
diff --git a/docs/devicetree/bindings/soc/st,stm32-stgen.txt b/docs/devicetree/bindings/soc/st,stm32-stgen.txt
new file mode 100644
index 0000000000..dbd962ebc4
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-stgen.txt
@@ -0,0 +1,18 @@
+STMicroelectronics STM32 STGEN
+===============================
+
+The STM32 System Generic Counter generate a time count value. This
+is a 64 bits wide counter.
+
+Required properties:
+
+- compatible : Should be "st,stm32-stgen"
+- reg : Should be register base and length as documented in the datasheet
+
+Example:
+
+	stgen: stgen@5C008000 {
+		compatible = "st,stm32-stgen";
+		reg = <0x5C008000 0x1000>;
+		status = "okay";
+	};
diff --git a/docs/devicetree/bindings/soc/st,stm32-tamp.txt b/docs/devicetree/bindings/soc/st,stm32-tamp.txt
new file mode 100644
index 0000000000..e903b466ad
--- /dev/null
+++ b/docs/devicetree/bindings/soc/st,stm32-tamp.txt
@@ -0,0 +1,20 @@
+STM32 TAMPER
+---------------------------------
+
+Required properties:
+- compatible: should be "st,stm32-tamp"
+- reg: physical base address and length of the registers set for the device
+- clocks: reference to the clock entry
+
+Optional property:
+- st,out3-pc13: Configure option register to map OUT3 on PC13
+- wakeup-source : Configure tamp as wakeup-src
+
+Examples:
+tamp: tamp@5C00A000 {
+	compatible = "st,stm32-tamp";
+	reg = <0x5C00A000 0x100>;
+	clocks = <&rcc_clk RTCAPB>;
+	st,out3-pc13;
+	wakeup-source;
+};
diff --git a/docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt b/docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt
new file mode 100644
index 0000000000..2d35e978d3
--- /dev/null
+++ b/docs/devicetree/bindings/watchdog/st,stm32-iwdg.txt
@@ -0,0 +1,27 @@
+STM32 Independent WatchDoG (IWDG)
+---------------------------------
+
+Required properties:
+- compatible: should be "st,stm32mp1-iwdg".
+- reg: physical base address and length of the registers set for the device.
+- clocks: reference to the clock entry lsi. Additional pclk clock entry.
+  is required only for st,stm32mp1-iwdg.
+- clock-names: name of the clocks used.
+  "pclk", "lsi" for st,stm32mp1-iwdg.
+
+Optional properties:
+- timeout-sec: Watchdog timeout value in seconds.
+- secure-timeout-sec: Watchdog early timeout management in seconds.
+- stm32,enable-on-stop: Keep watchdog enable during stop.
+- stm32,enable-on-standby: Keep watchdog enable durung standby.
+
+Examples:
+
+iwdg2: iwdg@5a002000 {
+	compatible = "st,stm32mp1-iwdg";
+	reg = <0x5a002000 0x400>;
+	clocks = <&rcc IWDG2>, <&clk_lsi>;
+	clock-names = "pclk", "lsi";
+	instance = <2>;
+	timeout-sec = <30>;
+};
diff --git a/docs/getting_started/build-options.rst b/docs/getting_started/build-options.rst
index d80a97f65f..8572d60971 100644
--- a/docs/getting_started/build-options.rst
+++ b/docs/getting_started/build-options.rst
@@ -219,6 +219,12 @@ Common build options
 
 -  ``E``: Boolean option to make warnings into errors. Default is 1.
 
+   When specifying higher warnings levels (``W=1`` and higher), this option
+   defaults to 0. This is done to encourage contributors to use them, as they
+   are expected to produce warnings that would otherwise fail the build. New
+   contributions are still expected to build with ``W=0`` and ``E=1`` (the
+   default).
+
 -  ``EL3_PAYLOAD_BASE``: This option enables booting an EL3 payload instead of
    the normal boot flow. It must specify the entry point address of the EL3
    payload. Please refer to the "Booting an EL3 payload" section for more
@@ -737,6 +743,9 @@ Common build options
    enabled on Arm platforms, the option ``ARM_RECOM_STATE_ID_ENC`` needs to be
    set to 1 as well.
 
+-  ``PSCI_OS_INIT_MODE``: Boolean flag to enable support for optional PSCI
+   OS-initiated mode. This option defaults to 0.
+
 -  ``RAS_EXTENSION``: Numeric value to enable Armv8.2 RAS features. RAS features
    are an optional extension for pre-Armv8.2 CPUs, but are mandatory for Armv8.2
    or later CPUs. This flag can take the values 0 to 2, to align with the
@@ -965,6 +974,43 @@ Common build options
    regrouped and put in the root Makefile. This flag can take the values 0 to 3,
    each level enabling more warning options. Default is 0.
 
+   This option is closely related to the ``E`` option, which enables
+   ``-Werror``.
+
+   - ``W=0`` (default)
+
+     Enables a wide assortment of warnings, most notably ``-Wall`` and
+     ``-Wextra``, as well as various bad practices and things that are likely to
+     result in errors. Includes some compiler specific flags. No warnings are
+     expected at this level for any build.
+
+   - ``W=1``
+
+     Enables warnings we want the generic build to include but are too time
+     consuming to fix at the moment. It re-enables warnings taken out for
+     ``W=0`` builds (a few of the ``-Wextra`` additions). This level is expected
+     to eventually be merged into ``W=0``. Some warnings are expected on some
+     builds, but new contributions should not introduce new ones.
+
+   - ``W=2`` (recommended)
+
+    Enables warnings we want the generic build to include but cannot be enabled
+    due to external libraries. This level is expected to eventually be merged
+    into ``W=0``. Lots of warnings are expected, primarily from external
+    libraries like zlib and compiler-rt, but new controbutions should not
+    introduce new ones.
+
+   - ``W=3``
+
+     Enables warnings that are informative but not necessary and generally too
+     verbose and frequently ignored. A very large number of warnings are
+     expected.
+
+   The exact set of warning flags depends on the compiler and TF-A warning
+   level, however they are all succinctly set in the top-level Makefile. Please
+   refer to the `GCC`_ or `Clang`_ documentation for more information on the
+   individual flags.
+
 -  ``WARMBOOT_ENABLE_DCACHE_EARLY`` : Boolean option to enable D-cache early on
    the CPU after warm boot. This is applicable for platforms which do not
    require interconnect programming to enable cache coherency (eg: single
@@ -1154,6 +1200,16 @@ commands can be used:
 Firmware update options
 -----------------------
 
+-  ``PSA_FWU_SUPPORT``: Enable the firmware update mechanism as per the
+   `PSA FW update specification`_. The default value is 0.
+   PSA firmware update implementation has few limitations, such as:
+
+   -  BL2 is not part of the protocol-updatable images. If BL2 needs to
+      be updated, then it should be done through another platform-defined
+      mechanism.
+
+   -  It assumes the platform's hardware supports CRC32 instructions.
+
 -  ``NR_OF_FW_BANKS``: Define the number of firmware banks. This flag is used
    in defining the firmware update metadata structure. This flag is by default
    set to '2'.
@@ -1164,18 +1220,21 @@ Firmware update options
    This flag is used in defining the firmware update metadata structure. This
    flag is by default set to '1'.
 
--  ``PSA_FWU_SUPPORT``: Enable the firmware update mechanism as per the
-   `PSA FW update specification`_. The default value is 0, and this is an
-   experimental feature.
-   PSA firmware update implementation has some limitations, such as BL2 is
-   not part of the protocol-updatable images, if BL2 needs to be updated, then
-   it should be done through another platform-defined mechanism, and it assumes
-   that the platform's hardware supports CRC32 instructions.
+- ``PSA_FWU_METADATA_FW_STORE_DESC``: To be enabled when the FWU
+   metadata contains image description. The default value is 1.
+
+   The version 2 of the FWU metadata allows for an opaque metadata
+   structure where a platform can choose to not include the firmware
+   store description in the metadata structure. This option indicates
+   if the firmware store description, which provides information on
+   the updatable images is part of the structure.
 
 --------------
 
 *Copyright (c) 2019-2022, Arm Limited. All rights reserved.*
 
 .. _DEN0115: https://developer.arm.com/docs/den0115/latest
-.. _PSA FW update specification: https://developer.arm.com/documentation/den0118/a/
+.. _PSA FW update specification: https://developer.arm.com/documentation/den0118/latest/
 .. _PSA DRTM specification: https://developer.arm.com/documentation/den0113/a
+.. _GCC: https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html
+.. _Clang: https://clang.llvm.org/docs/DiagnosticsReference.html
diff --git a/docs/getting_started/porting-guide.rst b/docs/getting_started/porting-guide.rst
index 985ad22186..26a5be8893 100644
--- a/docs/getting_started/porting-guide.rst
+++ b/docs/getting_started/porting-guide.rst
@@ -524,6 +524,15 @@ memory layout implies some image overlaying like in Arm standard platforms.
 
    Defines the maximum address that the TSP's progbits sections can occupy.
 
+If the platform supports OS-initiated mode, i.e. the build option
+``PSCI_OS_INIT_MODE`` is enabled, and if the platform's maximum power domain
+level for PSCI_CPU_SUSPEND differs from ``PLAT_MAX_PWR_LVL``, the following
+constant must be defined.
+
+-  **#define : PLAT_MAX_CPU_SUSPEND_PWR_LVL**
+
+   Defines the maximum power domain level that PSCI_CPU_SUSPEND should apply to.
+
 If the platform port uses the PL061 GPIO driver, the following constant may
 optionally be defined:
 
@@ -1174,6 +1183,18 @@ resets while booting from the active bank, the platform can then switch to boot
 from a different bank. This function then returns the bank that the platform
 should boot its images from.
 
+Function : plat_fwu_is_enabled() [when PSA_FWU_SUPPORT == 1]
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+::
+
+    Argument : void
+    Return   : bool
+
+This function is mandatory when PSA_FWU_SUPPORT is enabled. It checks at
+platform level that all conditions are met to initialize FWU process.
+
+
 Common optional modifications
 -----------------------------
 
@@ -2128,7 +2149,7 @@ CPUs. BL31 executes at EL3 and is responsible for:
 
 #. Providing runtime firmware services. Currently, BL31 only implements a
    subset of the Power State Coordination Interface (PSCI) API as a runtime
-   service. See Section 3.3 below for details of porting the PSCI
+   service. See :ref:`psci_in_bl31` below for details of porting the PSCI
    implementation.
 
 #. Optionally passing control to the BL32 image, pre-loaded at a platform-
@@ -2537,6 +2558,8 @@ Function: bool plat_get_entropy(uint64_t \*out) [mandatory]
 This function writes entropy into storage provided by the caller. If no entropy
 is available, it must return false and the storage must not be written.
 
+.. _psci_in_bl31:
+
 Power State Coordination Interface (in BL31)
 --------------------------------------------
 
@@ -2719,6 +2742,22 @@ Perform the platform specific actions to power on a CPU, specified
 by the ``MPIDR`` (first argument). The generic code expects the platform to
 return PSCI_E_SUCCESS on success or PSCI_E_INTERN_FAIL for any failure.
 
+plat_psci_ops.pwr_domain_off_early() [optional]
+...............................................
+
+This optional function performs the platform specific actions to check if
+powering off the calling CPU and its higher parent power domain levels as
+indicated by the ``target_state`` (first argument) is possible or allowed.
+
+The ``target_state`` encodes the platform coordinated target local power states
+for the CPU power domain and its parent power domain levels.
+
+For this handler, the local power state for the CPU power domain will be a
+power down state where as it could be either power down, retention or run state
+for the higher power domain levels depending on the result of state
+coordination. The generic code expects PSCI_E_DENIED return code if the
+platform thinks that CPU_OFF should not proceed on the calling CPU.
+
 plat_psci_ops.pwr_domain_off()
 ..............................
 
@@ -2736,6 +2775,17 @@ power down state where as it could be either power down, retention or run state
 for the higher power domain levels depending on the result of state
 coordination. The generic code expects the handler to succeed.
 
+plat_psci_ops.pwr_domain_validate_suspend() [optional]
+......................................................
+
+This is an optional function that is only compiled into the build if the build
+option ``PSCI_OS_INIT_MODE`` is enabled.
+
+If implemented, this function allows the platform to perform platform specific
+validations based on hardware states. The generic code expects this function to
+return PSCI_E_SUCCESS on success, or either PSCI_E_DENIED or
+PSCI_E_INVALID_PARAMS as appropriate for any invalid requests.
+
 plat_psci_ops.pwr_domain_suspend_pwrdown_early() [optional]
 ...........................................................
 
diff --git a/docs/index.rst b/docs/index.rst
index 3860199431..def7bf4916 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -93,4 +93,4 @@ have previously been raised against the software.
 .. _System Control and Management Interface (SCMI): http://infocenter.arm.com/help/topic/com.arm.doc.den0056a/DEN0056A_System_Control_and_Management_Interface.pdf
 .. _Software Delegated Exception Interface (SDEI): http://infocenter.arm.com/help/topic/com.arm.doc.den0054a/ARM_DEN0054A_Software_Delegated_Exception_Interface.pdf
 .. _SMC Calling Convention: https://developer.arm.com/docs/den0028/latest
-.. _PSA FW update specification: https://developer.arm.com/documentation/den0118/a/
+.. _PSA FW update specification: https://developer.arm.com/documentation/den0118/latest/
diff --git a/docs/plat/index.rst b/docs/plat/index.rst
index a4e2067805..3eb0b49bce 100644
--- a/docs/plat/index.rst
+++ b/docs/plat/index.rst
@@ -39,7 +39,7 @@ Platform Ports
    rockchip
    socionext-uniphier
    synquacer
-   stm32mp1
+   st/index
    ti-k3
    xilinx-versal-net
    xilinx-versal
@@ -79,4 +79,4 @@ Deprecated platforms
 
 --------------
 
-*Copyright (c) 2019-2022, Arm Limited. All rights reserved.*
+*Copyright (c) 2019-2023, Arm Limited. All rights reserved.*
diff --git a/docs/plat/st/index.rst b/docs/plat/st/index.rst
new file mode 100644
index 0000000000..95ec3d252b
--- /dev/null
+++ b/docs/plat/st/index.rst
@@ -0,0 +1,14 @@
+STMicroelectronics STM32 MPUs
+=============================
+
+.. toctree::
+   :maxdepth: 1
+   :caption: Contents
+
+   stm32mpus
+   stm32mp1
+   stm32mp2
+
+--------------
+
+*Copyright (c) 2023, STMicroelectronics - All Rights Reserved*
diff --git a/docs/plat/st/stm32mp1.rst b/docs/plat/st/stm32mp1.rst
new file mode 100644
index 0000000000..2488cd8b56
--- /dev/null
+++ b/docs/plat/st/stm32mp1.rst
@@ -0,0 +1,218 @@
+STM32MP1
+========
+
+STM32MP1 is a microprocessor designed by STMicroelectronics
+based on Arm Cortex-A7.
+It is an Armv7-A platform, using dedicated code from TF-A.
+More information can be found on `STM32MP1 Series`_ page.
+
+For TF-A common configuration of STM32 MPUs, please check
+:ref:`STM32 MPUs` page or `Github STM32 MPUs`_.
+
+STM32MP1 Versions
+-----------------
+
+There are 2 variants for STM32MP1: STM32MP13 and STM32MP15
+
+STM32MP13 Versions
+~~~~~~~~~~~~~~~~~~
+The STM32MP13 series is available in 3 different lines which are pin-to-pin compatible:
+
+- STM32MP131: Single Cortex-A7 core
+- STM32MP133: STM32MP131 + 2*CAN, ETH2(GMAC), ADC1
+- STM32MP135: STM32MP133 + DCMIPP, LTDC
+
+Each line comes with a security option (cryptography & secure boot) and a Cortex-A frequency option:
+
+- A      Cortex-A7 @ 650 MHz
+- C      Secure Boot + HW Crypto + Cortex-A7 @ 650 MHz
+- D      Cortex-A7 @ 900 MHz
+- F      Secure Boot + HW Crypto + Cortex-A7 @ 900 MHz
+
+STM32MP15 Versions
+~~~~~~~~~~~~~~~~~~
+The STM32MP15 series is available in 3 different lines which are pin-to-pin compatible:
+
+- STM32MP157: Dual Cortex-A7 cores, Cortex-M4 core @ 209 MHz, 3D GPU, DSI display interface and CAN FD
+- STM32MP153: Dual Cortex-A7 cores, Cortex-M4 core @ 209 MHz and CAN FD
+- STM32MP151: Single Cortex-A7 core, Cortex-M4 core @ 209 MHz
+
+Each line comes with a security option (cryptography & secure boot) and a Cortex-A frequency option:
+
+- A      Basic + Cortex-A7 @ 650 MHz
+- C      Secure Boot + HW Crypto + Cortex-A7 @ 650 MHz
+- D      Basic + Cortex-A7 @ 800 MHz
+- F      Secure Boot + HW Crypto + Cortex-A7 @ 800 MHz
+
+The `STM32MP1 part number codification`_ page gives more information about part numbers.
+
+Memory mapping
+--------------
+
+::
+
+    0x00000000 +-----------------+
+               |                 |   ROM
+    0x00020000 +-----------------+
+               |                 |
+               |       ...       |
+               |                 |
+    0x2FFC0000 +-----------------+ \
+               |     BL32 DTB    | |
+    0x2FFC5000 +-----------------+ |
+               |       BL32      | |
+    0x2FFDF000 +-----------------+ |
+               |       ...       | |
+    0x2FFE3000 +-----------------+ |
+               |     BL2 DTB     | | Embedded SRAM
+    0x2FFEA000 +-----------------+ |
+               |       BL2       | |
+    0x2FFFF000 +-----------------+ |
+               |  SCMI mailbox   | |
+    0x30000000 +-----------------+ /
+               |                 |
+               |       ...       |
+               |                 |
+    0x40000000 +-----------------+
+               |                 |
+               |                 |   Devices
+               |                 |
+    0xC0000000 +-----------------+ \
+               |                 | |
+    0xC0100000 +-----------------+ |
+               |       BL33      | | Non-secure RAM (DDR)
+               |       ...       | |
+               |                 | |
+    0xFFFFFFFF +-----------------+ /
+
+
+Build Instructions
+------------------
+
+STM32MP1x specific flags
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+Dedicated STM32MP1 flags:
+
+- | ``STM32_TF_VERSION``: to manage BL2 monotonic counter.
+  | Default: 0
+- | ``STM32MP13``: to select STM32MP13 variant configuration.
+  | Default: 0
+- | ``STM32MP15``: to select STM32MP15 variant configuration.
+  | Default: 1
+
+
+Boot with FIP
+~~~~~~~~~~~~~
+You need to build BL2, BL32 (SP_min or OP-TEE) and BL33 (U-Boot) before building FIP binary.
+
+U-Boot
+______
+
+.. code:: bash
+
+    cd <u-boot_directory>
+    make stm32mp15_trusted_defconfig
+    make DEVICE_TREE=stm32mp157c-ev1 all
+
+OP-TEE (optional)
+_________________
+
+.. code:: bash
+
+    cd <optee_directory>
+    make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm PLATFORM=stm32mp1 \
+        CFG_EMBED_DTB_SOURCE_FILE=stm32mp157c-ev1.dts
+
+
+TF-A BL32 (SP_min)
+__________________
+If you choose not to use OP-TEE, you can use TF-A SP_min.
+To build TF-A BL32, and its device tree file:
+
+.. code:: bash
+
+    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
+        AARCH32_SP=sp_min DTB_FILE_NAME=stm32mp157c-ev1.dtb bl32 dtbs
+
+TF-A BL2
+________
+To build TF-A BL2 with its STM32 header for SD-card boot:
+
+.. code:: bash
+
+    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
+        DTB_FILE_NAME=stm32mp157c-ev1.dtb STM32MP_SDMMC=1
+
+For other boot devices, you have to replace STM32MP_SDMMC in the previous command
+with the desired device flag.
+
+This BL2 is independent of the BL32 used (SP_min or OP-TEE)
+
+
+FIP
+___
+With BL32 SP_min:
+
+.. code:: bash
+
+    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
+        AARCH32_SP=sp_min \
+        DTB_FILE_NAME=stm32mp157c-ev1.dtb \
+        BL33=<u-boot_directory>/u-boot-nodtb.bin \
+        BL33_CFG=<u-boot_directory>/u-boot.dtb \
+        fip
+
+With OP-TEE:
+
+.. code:: bash
+
+    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
+        AARCH32_SP=optee \
+        DTB_FILE_NAME=stm32mp157c-ev1.dtb \
+        BL33=<u-boot_directory>/u-boot-nodtb.bin \
+        BL33_CFG=<u-boot_directory>/u-boot.dtb \
+        BL32=<optee_directory>/tee-header_v2.bin \
+        BL32_EXTRA1=<optee_directory>/tee-pager_v2.bin
+        BL32_EXTRA2=<optee_directory>/tee-pageable_v2.bin
+        fip
+
+Trusted Boot Board
+__________________
+
+.. code:: shell
+
+    tools/cert_create/cert_create -n --rot-key build/stm32mp1/release/rot_key.pem \
+        --tfw-nvctr 0 \
+        --ntfw-nvctr 0 \
+        --key-alg ecdsa --hash-alg sha256 \
+        --trusted-key-cert build/stm32mp1/release/trusted_key.crt \
+        --tos-fw <optee_directory>/tee-header_v2.bin \
+        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
+        --tos-fw-extra2 <optee_directory>/tee-pageable_v2.bin \
+        --tos-fw-cert build/stm32mp1/release/tos_fw_content.crt \
+        --tos-fw-key-cert build/stm32mp1/release/tos_fw_key.crt \
+        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
+        --nt-fw-cert build/stm32mp1/release/nt_fw_content.crt \
+        --nt-fw-key-cert build/stm32mp1/release/nt_fw_key.crt \
+        --hw-config <u-boot_directory>/u-boot.dtb \
+        --fw-config build/stm32mp1/release/fdts/fw-config.dtb \
+        --stm32mp-cfg-cert build/stm32mp1/release/stm32mp_cfg_cert.crt
+
+    tools/fiptool/fiptool create --tos-fw <optee_directory>/tee-header_v2.bin \
+        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
+        --tos-fw-extra2 <optee_directory>/tee-pageable_v2.bin \
+        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
+        --hw-config <u-boot_directory>/u-boot.dtb \
+        --fw-config build/stm32mp1/release/fdts/fw-config.dtb \
+        --tos-fw-cert build/stm32mp1/release/tos_fw_content.crt \
+        --tos-fw-key-cert build/stm32mp1/release/tos_fw_key.crt \
+        --nt-fw-cert build/stm32mp1/release/nt_fw_content.crt \
+        --nt-fw-key-cert build/stm32mp1/release/nt_fw_key.crt \
+        --stm32mp-cfg-cert build/stm32mp1/release/stm32mp_cfg_cert.crt \
+        build/stm32mp1/release/stm32mp1.fip
+
+
+.. _STM32MP1 Series: https://www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html
+.. _STM32MP1 part number codification: https://wiki.st.com/stm32mpu/wiki/STM32MP15_microprocessor#Part_number_codification
+.. _Github STM32 MPUs: https://github.com/STMicroelectronics/arm-trusted-firmware/tree/HEAD/docs/plat/st/stm32mpus.rst
diff --git a/docs/plat/st/stm32mp2.rst b/docs/plat/st/stm32mp2.rst
new file mode 100644
index 0000000000..a9daa2bb70
--- /dev/null
+++ b/docs/plat/st/stm32mp2.rst
@@ -0,0 +1,207 @@
+STM32MP2
+========
+
+STM32MP2 is a microprocessor designed by STMicroelectronics
+based on Arm Cortex-A35.
+
+More information can be found on `STM32MP2 Series`_ page.
+
+For TF-A common configuration of STM32 MPUs, please check
+:ref:`STM32 MPUs` page or `Github STM32 MPUs`_.
+
+STM32MP2 Versions
+-----------------
+
+The STM32MP25 series is available in 4 different lines which are pin-to-pin compatible:
+
+- STM32MP257: Dual Cortex-A35 cores, Cortex-M33 core - 3x Ethernet (2+1 switch) - 3x CAN FD – H264 - 3D GPU – AI / NN - LVDS
+- STM32MP255: Dual Cortex-A35 cores, Cortex-M33 core - 2x Ethernet – 3x CAN FD - H264 - 3D GPU – AI / NN - LVDS
+- STM32MP253: Dual Cortex-A35 cores, Cortex-M33 core - 2x Ethernet – 3x CAN FD - LVDS
+- STM32MP251: Single Cortex-A35 core, Cortex-M33 core - 1x Ethernet
+
+Each line comes with a security option (cryptography & secure boot) and a Cortex-A frequency option:
+
+- A      Basic + Cortex-A35 @ 1GHz
+- C      Secure Boot + HW Crypto + Cortex-A35 @ 1GHz
+- D      Basic + Cortex-A35 @ 1.5GHz
+- F      Secure Boot + HW Crypto + Cortex-A35 @ 1.5GHz
+
+The `STM32MP2 part number codification`_ page gives more information about part numbers.
+
+Memory mapping
+--------------
+
+::
+
+    0x00000000 +-----------------+
+               |                 |   ROM
+    0x00020000 +-----------------+
+               |                 |
+               |       ...       |
+               |                 |
+    0x0E000000 +-----------------+ \
+               |       BL31      | |
+               +-----------------+ |
+               |       ...       | |
+    0x0E012000 +-----------------+ |
+               |     BL2 DTB     | | Embedded SRAM
+    0x0E016000 +-----------------+ |
+               |       BL2       | |
+    0x0E040000 +-----------------+ /
+               |                 |
+               |       ...       |
+               |                 |
+    0x40000000 +-----------------+
+               |                 |
+               |                 |   Devices
+               |                 |
+    0x80000000 +-----------------+ \
+               |                 | |
+               |                 | | Non-secure RAM (DDR)
+               |                 | |
+    0xFFFFFFFF +-----------------+ /
+
+
+Build Instructions
+------------------
+
+STM32MP2x specific flags
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+Dedicated STM32MP2 build flags:
+
+- | ``STM32MP_DDR_FIP_IO_STORAGE``: to store DDR firmware in FIP.
+  | Default: 1
+- | ``STM32MP_M33_TDCID``: Enable this flag if Cortex-A35 does not have the Trusted Domain Compartment ID (owned by Cortex-M33)
+  | Default: 0
+- | ``STM32MP25``: to select STM32MP25 variant configuration.
+  | Default: 1
+
+To compile the correct DDR driver, one flag must be set among:
+
+- | ``STM32MP_DDR3_TYPE``: to compile DDR3 driver and DT.
+  | Default: 0
+- | ``STM32MP_DDR4_TYPE``: to compile DDR4 driver and DT.
+  | Default: 0
+- | ``STM32MP_LPDDR4_TYPE``: to compile LpDDR4 driver and DT.
+  | Default: 0
+
+
+Boot with FIP
+~~~~~~~~~~~~~
+You need to build BL2, BL31, BL32 (OP-TEE) and BL33 (U-Boot) and retrieve
+DDR PHY firmware before building FIP binary.
+
+U-Boot
+______
+
+.. code:: bash
+
+    cd <u-boot_directory>
+    make stm32mp25_defconfig
+    make DEVICE_TREE=stm32mp257f-ev1 all
+
+OP-TEE
+______
+
+.. code:: bash
+
+    cd <optee_directory>
+    make CROSS_COMPILE64=aarch64-none-elf- CROSS_COMPILE32=arm-none-eabi-
+        ARCH=arm PLATFORM=stm32mp2 \
+        CFG_EMBED_DTB_SOURCE_FILE=stm32mp257f-ev1.dts
+
+DDR PHY firmware
+________________
+DDR PHY firmware files may not be delivered inside TF-A repository, especially
+if you build directly from trustedfirmware.org repository. It then needs to be
+retrieved from `STMicroelectronics DDR PHY github`_.
+
+You can either clone the repository to the default directory:
+
+.. code:: bash
+
+    git clone https://github.com/STMicroelectronics/stm32-ddr-phy-binary.git drivers/st/ddr/phy/firmware/bin
+
+Or clone it somewhere else, and add ``STM32MP_DDR_FW_PATH=`` in your make command
+line when building FIP.
+
+TF-A BL2
+________
+To build TF-A BL2 with its STM32 header for SD-card boot:
+
+.. code:: bash
+
+    make CROSS_COMPILE=aarch64-none-elf- PLAT=stm32mp2 \
+        STM32MP_DDR4_TYPE=1 SPD=opteed \
+        DTB_FILE_NAME=stm32mp257f-ev1.dtb STM32MP_SDMMC=1
+
+For other boot devices, you have to replace STM32MP_SDMMC in the previous command
+with the desired device flag.
+
+
+FIP
+___
+
+.. code:: bash
+
+    make CROSS_COMPILE=aarch64-none-elf- PLAT=stm32mp2 \
+        STM32MP_DDR4_TYPE=1 SPD=opteed \
+        DTB_FILE_NAME=stm32mp257f-ev1.dtb \
+        BL33=<u-boot_directory>/u-boot-nodtb.bin \
+        BL33_CFG=<u-boot_directory>/u-boot.dtb \
+        BL32=<optee_directory>/tee-header_v2.bin \
+        BL32_EXTRA1=<optee_directory>/tee-pager_v2.bin
+        fip
+
+Trusted Boot Board
+__________________
+
+.. code:: shell
+
+    tools/cert_create/cert_create -n --rot-key build/stm32mp2/release/rot_key.pem \
+        --tfw-nvctr 0 \
+        --ntfw-nvctr 0 \
+        --key-alg ecdsa --hash-alg sha256 \
+        --trusted-key-cert build/stm32mp2/release/trusted_key.crt \
+        --tos-fw <optee_directory>/tee-header_v2.bin \
+        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
+        --tos-fw-cert build/stm32mp2/release/tos_fw_content.crt \
+        --tos-fw-key-cert build/stm32mp2/release/tos_fw_key.crt \
+        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
+        --nt-fw-cert build/stm32mp2/release/nt_fw_content.crt \
+        --nt-fw-key-cert build/stm32mp2/release/nt_fw_key.crt \
+        --hw-config <u-boot_directory>/u-boot.dtb \
+        --fw-config build/stm32mp2/release/fdts/stm32mp257f-ev1-fw-config.dtb \
+        --stm32mp-cfg-cert build/stm32mp2/release/stm32mp_cfg_cert.crt \
+        --soc-fw-config build/stm32mp2/release/fdts/stm32mp257f-ev1-bl31.dtb \
+        --soc-fw build/stm32mp2/release/bl31.bin \
+        --soc-fw-cert build/stm32mp2/release/soc_fw_content.crt \
+        --soc-fw-key-cert build/stm32mp2/release/soc_fw_key.crt \
+        --ddr-fw drivers/st/ddr/phy/firmware/bin/stm32mp2/ddr4_pmu_train.bin
+
+    tools/fiptool/fiptool create \
+        --tos-fw <optee_directory>/tee-header_v2.bin \
+        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
+        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
+        --hw-config <u-boot_directory>/u-boot.dtb \
+        --fw-config build/stm32mp2/release/fdts/stm32mp257f-ev1-fw-config.dtb \
+        --soc-fw-config build/stm32mp2/release/fdts/stm32mp257f-ev1-bl31.dtb \
+        --tos-fw-cert build/stm32mp2/release/tos_fw_content.crt \
+        --tos-fw-key-cert build/stm32mp2/release/tos_fw_key.crt \
+        --nt-fw-cert build/stm32mp2/release/nt_fw_content.crt \
+        --nt-fw-key-cert build/stm32mp2/release/nt_fw_key.crt \
+        --stm32mp-cfg-cert build/stm32mp2/release/stm32mp_cfg_cert.crt \
+        --ddr-fw drivers/st/ddr/phy/firmware/bin/stm32mp2/ddr4_pmu_train.bin \
+        --trusted-key-cert build/stm32mp2/release/trusted_key.crt \
+        --soc-fw-cert build/stm32mp2/release/soc_fw_content.crt \
+        --soc-fw-key-cert build/stm32mp2/release/soc_fw_key.crt \
+        --soc-fw build/stm32mp2/release/bl31.bin \
+        build/stm32mp2/release/fip.bin
+
+.. _STM32MP2 Series: https://www.st.com/en/microcontrollers-microprocessors/stm32mp2-series.html
+.. _STM32MP2 part number codification: https://wiki.st.com/stm32mpu/wiki/STM32MP25_microprocessor#Part_number_codification
+.. _Github STM32 MPUs: https://github.com/STMicroelectronics/arm-trusted-firmware/tree/HEAD/docs/plat/st/stm32mpus.rst
+.. _STMicroelectronics DDR PHY github: https://github.com/STMicroelectronics/stm32-ddr-phy-binary
+
+*Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved*
diff --git a/docs/plat/st/stm32mpus.rst b/docs/plat/st/stm32mpus.rst
new file mode 100644
index 0000000000..1a5a3ec6c6
--- /dev/null
+++ b/docs/plat/st/stm32mpus.rst
@@ -0,0 +1,82 @@
+STM32 MPUs
+==========
+
+STM32 MPUs are microprocessors designed by STMicroelectronics
+based on Arm Cortex-A. This page presents the common configuration of STM32
+MPUs, more details and dedciated configuration can be found in each STM32 MPU
+page (:ref:`STM32MP1` (`Github STM32MP1`_) or :ref:`STM32MP2` (`Github STM32MP2`_) )
+
+Design
+------
+The STM32 MPU resets in the ROM code of the Cortex-A.
+The primary boot core (core 0) executes the boot sequence while
+secondary boot core (core 1) is kept in a holding pen loop.
+The ROM code boot sequence loads the TF-A binary image from boot device
+to embedded SRAM.
+
+The TF-A image must be properly formatted with a STM32 header structure
+for ROM code is able to load this image.
+Tool stm32image can be used to prepend this header to the generated TF-A binary.
+
+Boot
+~~~~
+Only BL2 (with STM32 header) is loaded by ROM code. The other binaries are
+inside the FIP binary: BL31 (for Aarch64 platforms), BL32 (OP-TEE), U-Boot
+and their respective device tree blobs.
+
+Boot sequence
+~~~~~~~~~~~~~
+
+ROM code -> BL2 (compiled with BL2_AT_EL3) -> OP-TEE -> BL33 (U-Boot)
+
+Build Instructions
+------------------
+Boot media(s) supported by BL2 must be specified in the build command.
+Available storage medias are:
+
+- ``STM32MP_SDMMC``
+- ``STM32MP_EMMC``
+- ``STM32MP_RAW_NAND``
+- ``STM32MP_SPI_NAND``
+- ``STM32MP_SPI_NOR``
+- ``STM32MP_HYPERFLASH``
+
+Serial boot devices:
+
+- ``STM32MP_UART_PROGRAMMER``
+- ``STM32MP_USB_PROGRAMMER``
+
+
+Other configuration flags:
+
+- | ``DTB_FILE_NAME``: to precise board device-tree blob to be used.
+  | Default: STM32MP257c-ev1.dtb
+- | ``DWL_BUFFER_BASE``: the 'serial boot' load address of FIP,
+  | default location (end of the first 128MB) is used when absent
+- | ``STM32MP_EARLY_CONSOLE``: to enable early traces before clock driver is setup.
+  | Default: 0 (disabled)
+- | ``STM32MP_RECONFIGURE_CONSOLE``: to re-configure crash console (especially after BL2).
+  | Default: 0 (disabled)
+- | ``STM32MP_UART_BAUDRATE``: to select UART baud rate.
+  | Default: 115200
+
+
+Populate SD-card
+----------------
+
+Boot with FIP
+~~~~~~~~~~~~~
+The SD-card has to be formatted with GPT.
+It should contain at least those partitions:
+
+- fsbl: to copy the tf-a-STM32MP257c-ev1.stm32 binary (BL2)
+- fip: which contains the FIP binary
+
+Usually, two copies of fsbl are used (fsbl1 and fsbl2) instead of one partition fsbl.
+
+.. _Github STM32MP1: https://github.com/STMicroelectronics/arm-trusted-firmware/tree/HEAD/docs/plat/st/stm32mp1.rst
+.. _Github STM32MP2: https://github.com/STMicroelectronics/arm-trusted-firmware/tree/HEAD/docs/plat/st/stm32mp2.rst
+
+--------------
+
+*Copyright (c) 2023, STMicroelectronics - All Rights Reserved*
diff --git a/docs/plat/stm32mp1.rst b/docs/plat/stm32mp1.rst
index 23ea25aec4..ce2d3d71e2 100644
--- a/docs/plat/stm32mp1.rst
+++ b/docs/plat/stm32mp1.rst
@@ -1,280 +1,11 @@
-STMicroelectronics STM32MP1
-===========================
+:orphan:
 
-STM32MP1 is a microprocessor designed by STMicroelectronics
-based on Arm Cortex-A7.
-It is an Armv7-A platform, using dedicated code from TF-A.
-More information can be found on `STM32MP1 Series`_ page.
+STMicroelectronics STM32MP1 (old page)
+======================================
 
+Please check :ref:`STM32 MPUs` page  or `Github STM32 MPUs`_ for generic information about
+STMicroelectronics STM32 microprocessors in TF-A, and :ref:`STM32MP1` page
+or `Github STM32MP1`_ for specificities on STM32MP1x platforms.
 
-STM32MP1 Versions
------------------
-
-There are 2 variants for STM32MP1: STM32MP13 and STM32MP15
-
-STM32MP13 Versions
-~~~~~~~~~~~~~~~~~~
-The STM32MP13 series is available in 3 different lines which are pin-to-pin compatible:
-
-- STM32MP131: Single Cortex-A7 core
-- STM32MP133: STM32MP131 + 2*CAN, ETH2(GMAC), ADC1
-- STM32MP135: STM32MP133 + DCMIPP, LTDC
-
-Each line comes with a security option (cryptography & secure boot) and a Cortex-A frequency option:
-
-- A      Cortex-A7 @ 650 MHz
-- C      Secure Boot + HW Crypto + Cortex-A7 @ 650 MHz
-- D      Cortex-A7 @ 900 MHz
-- F      Secure Boot + HW Crypto + Cortex-A7 @ 900 MHz
-
-STM32MP15 Versions
-~~~~~~~~~~~~~~~~~~
-The STM32MP15 series is available in 3 different lines which are pin-to-pin compatible:
-
-- STM32MP157: Dual Cortex-A7 cores, Cortex-M4 core @ 209 MHz, 3D GPU, DSI display interface and CAN FD
-- STM32MP153: Dual Cortex-A7 cores, Cortex-M4 core @ 209 MHz and CAN FD
-- STM32MP151: Single Cortex-A7 core, Cortex-M4 core @ 209 MHz
-
-Each line comes with a security option (cryptography & secure boot) and a Cortex-A frequency option:
-
-- A      Basic + Cortex-A7 @ 650 MHz
-- C      Secure Boot + HW Crypto + Cortex-A7 @ 650 MHz
-- D      Basic + Cortex-A7 @ 800 MHz
-- F      Secure Boot + HW Crypto + Cortex-A7 @ 800 MHz
-
-The `STM32MP1 part number codification`_ page gives more information about part numbers.
-
-Design
-------
-The STM32MP1 resets in the ROM code of the Cortex-A7.
-The primary boot core (core 0) executes the boot sequence while
-secondary boot core (core 1) is kept in a holding pen loop.
-The ROM code boot sequence loads the TF-A binary image from boot device
-to embedded SRAM.
-
-The TF-A image must be properly formatted with a STM32 header structure
-for ROM code is able to load this image.
-Tool stm32image can be used to prepend this header to the generated TF-A binary.
-
-Boot with FIP
-~~~~~~~~~~~~~
-The use of FIP is now the recommended way to boot STM32MP1 platform.
-Only BL2 (with STM32 header) is loaded by ROM code. The other binaries are
-inside the FIP binary: BL32 (SP_min or OP-TEE), U-Boot and their respective
-device tree blobs.
-
-
-Memory mapping
-~~~~~~~~~~~~~~
-
-::
-
-    0x00000000 +-----------------+
-               |                 |   ROM
-    0x00020000 +-----------------+
-               |                 |
-               |       ...       |
-               |                 |
-    0x2FFC0000 +-----------------+ \
-               |     BL32 DTB    | |
-    0x2FFC5000 +-----------------+ |
-               |       BL32      | |
-    0x2FFDF000 +-----------------+ |
-               |       ...       | |
-    0x2FFE3000 +-----------------+ |
-               |     BL2 DTB     | | Embedded SRAM
-    0x2FFEA000 +-----------------+ |
-               |       BL2       | |
-    0x2FFFF000 +-----------------+ |
-               |  SCMI mailbox   | |
-    0x30000000 +-----------------+ /
-               |                 |
-               |       ...       |
-               |                 |
-    0x40000000 +-----------------+
-               |                 |
-               |                 |   Devices
-               |                 |
-    0xC0000000 +-----------------+ \
-               |                 | |
-    0xC0100000 +-----------------+ |
-               |       BL33      | | Non-secure RAM (DDR)
-               |       ...       | |
-               |                 | |
-    0xFFFFFFFF +-----------------+ /
-
-
-Boot sequence
-~~~~~~~~~~~~~
-
-ROM code -> BL2 (compiled with BL2_AT_EL3) -> BL32 (SP_min) -> BL33 (U-Boot)
-
-or if Op-TEE is used:
-
-ROM code -> BL2 (compiled with BL2_AT_EL3) -> OP-TEE -> BL33 (U-Boot)
-
-
-Build Instructions
-------------------
-Boot media(s) supported by BL2 must be specified in the build command.
-Available storage medias are:
-
-- ``STM32MP_SDMMC``
-- ``STM32MP_EMMC``
-- ``STM32MP_RAW_NAND``
-- ``STM32MP_SPI_NAND``
-- ``STM32MP_SPI_NOR``
-
-Serial boot devices:
-
-- ``STM32MP_UART_PROGRAMMER``
-- ``STM32MP_USB_PROGRAMMER``
-
-
-Other configuration flags:
-
-- | ``DTB_FILE_NAME``: to precise board device-tree blob to be used.
-  | Default: stm32mp157c-ev1.dtb
-- | ``DWL_BUFFER_BASE``: the 'serial boot' load address of FIP,
-  | default location (end of the first 128MB) is used when absent
-- | ``STM32MP_EARLY_CONSOLE``: to enable early traces before clock driver is setup.
-  | Default: 0 (disabled)
-- | ``STM32MP_RECONFIGURE_CONSOLE``: to re-configure crash console (especially after BL2).
-  | Default: 0 (disabled)
-- | ``STM32MP_UART_BAUDRATE``: to select UART baud rate.
-  | Default: 115200
-- | ``STM32_TF_VERSION``: to manage BL2 monotonic counter.
-  | Default: 0
-- | ``STM32MP13``: to select STM32MP13 variant configuration.
-  | Default: 0
-- | ``STM32MP15``: to select STM32MP15 variant configuration.
-  | Default: 1
-
-
-Boot with FIP
-~~~~~~~~~~~~~
-You need to build BL2, BL32 (SP_min or OP-TEE) and BL33 (U-Boot) before building FIP binary.
-
-U-Boot
-______
-
-.. code:: bash
-
-    cd <u-boot_directory>
-    make stm32mp15_trusted_defconfig
-    make DEVICE_TREE=stm32mp157c-ev1 all
-
-OP-TEE (optional)
-_________________
-
-.. code:: bash
-
-    cd <optee_directory>
-    make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm PLATFORM=stm32mp1 \
-        CFG_EMBED_DTB_SOURCE_FILE=stm32mp157c-ev1.dts
-
-
-TF-A BL32 (SP_min)
-__________________
-If you choose not to use OP-TEE, you can use TF-A SP_min.
-To build TF-A BL32, and its device tree file:
-
-.. code:: bash
-
-    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
-        AARCH32_SP=sp_min DTB_FILE_NAME=stm32mp157c-ev1.dtb bl32 dtbs
-
-TF-A BL2
-________
-To build TF-A BL2 with its STM32 header for SD-card boot:
-
-.. code:: bash
-
-    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
-        DTB_FILE_NAME=stm32mp157c-ev1.dtb STM32MP_SDMMC=1
-
-For other boot devices, you have to replace STM32MP_SDMMC in the previous command
-with the desired device flag.
-
-This BL2 is independent of the BL32 used (SP_min or OP-TEE)
-
-
-FIP
-___
-With BL32 SP_min:
-
-.. code:: bash
-
-    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
-        AARCH32_SP=sp_min \
-        DTB_FILE_NAME=stm32mp157c-ev1.dtb \
-        BL33=<u-boot_directory>/u-boot-nodtb.bin \
-        BL33_CFG=<u-boot_directory>/u-boot.dtb \
-        fip
-
-With OP-TEE:
-
-.. code:: bash
-
-    make CROSS_COMPILE=arm-none-eabi- PLAT=stm32mp1 ARCH=aarch32 ARM_ARCH_MAJOR=7 \
-        AARCH32_SP=optee \
-        DTB_FILE_NAME=stm32mp157c-ev1.dtb \
-        BL33=<u-boot_directory>/u-boot-nodtb.bin \
-        BL33_CFG=<u-boot_directory>/u-boot.dtb \
-        BL32=<optee_directory>/tee-header_v2.bin \
-        BL32_EXTRA1=<optee_directory>/tee-pager_v2.bin
-        BL32_EXTRA2=<optee_directory>/tee-pageable_v2.bin
-        fip
-
-Trusted Boot Board
-__________________
-
-.. code:: shell
-
-    tools/cert_create/cert_create -n --rot-key "build/stm32mp1/debug/rot_key.pem" \
-        --tfw-nvctr 0 \
-        --ntfw-nvctr 0 \
-        --key-alg ecdsa --hash-alg sha256 \
-        --trusted-key-cert build/stm32mp1/cert_images/trusted-key-cert.key-crt \
-        --tos-fw <optee_directory>/tee-header_v2.bin \
-        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
-        --tos-fw-extra2 <optee_directory>/tee-pageable_v2.bin \
-        --tos-fw-cert build/stm32mp1/cert_images/tee-header_v2.bin.crt \
-        --tos-fw-key-cert build/stm32mp1/cert_images/tee-header_v2.bin.key-crt \
-        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
-        --nt-fw-cert build/stm32mp1/cert_images/u-boot.bin.crt \
-        --nt-fw-key-cert build/stm32mp1/cert_images/u-boot.bin.key-crt \
-        --hw-config <u-boot_directory>/u-boot.dtb \
-        --fw-config build/stm32mp1/debug/fdts/fw-config.dtb \
-        --stm32mp-cfg-cert build/stm32mp1/cert_images/stm32mp_cfg_cert.crt
-
-    tools/fiptool/fiptool create --tos-fw <optee_directory>/tee-header_v2.bin \
-        --tos-fw-extra1 <optee_directory>/tee-pager_v2.bin \
-        --tos-fw-extra2 <optee_directory>/tee-pageable_v2.bin \
-        --nt-fw <u-boot_directory>/u-boot-nodtb.bin \
-        --hw-config <u-boot_directory>/u-boot.dtb \
-        --fw-config build/stm32mp1/debug/fdts/fw-config.dtb \
-        --tos-fw-cert build/stm32mp1/cert_images/tee-header_v2.bin.crt \
-        --tos-fw-key-cert build/stm32mp1/cert_images/tee-header_v2.bin.key-crt \
-        --nt-fw-cert build/stm32mp1/cert_images/u-boot.bin.crt \
-        --nt-fw-key-cert build/stm32mp1/cert_images/u-boot.bin.key-crt \
-        --stm32mp-cfg-cert build/stm32mp1/cert_images/stm32mp_cfg_cert.crt stm32mp1.fip
-
-
-
-Populate SD-card
-----------------
-
-Boot with FIP
-~~~~~~~~~~~~~
-The SD-card has to be formatted with GPT.
-It should contain at least those partitions:
-
-- fsbl: to copy the tf-a-stm32mp157c-ev1.stm32 binary (BL2)
-- fip: which contains the FIP binary
-
-Usually, two copies of fsbl are used (fsbl1 and fsbl2) instead of one partition fsbl.
-
-
-.. _STM32MP1 Series: https://www.st.com/en/microcontrollers-microprocessors/stm32mp1-series.html
-.. _STM32MP1 part number codification: https://wiki.st.com/stm32mpu/wiki/STM32MP15_microprocessor#Part_number_codification
+.. _Github STM32 MPUs: https://github.com/STMicroelectronics/arm-trusted-firmware/tree/HEAD/docs/plat/st/stm32mpus.rst
+.. _Github STM32MP1: https://github.com/STMicroelectronics/arm-trusted-firmware/tree/HEAD/docs/plat/st/stm32mp1.rst
diff --git a/docs/process/security-hardening.rst b/docs/process/security-hardening.rst
index 507046f2e1..f9618db08f 100644
--- a/docs/process/security-hardening.rst
+++ b/docs/process/security-hardening.rst
@@ -131,38 +131,9 @@ Several build options can be used to check for security issues. Refer to the
   overflows.
 
 - The ``W`` build flag can be used to enable a number of compiler warning
-  options to detect potentially incorrect code.
-
-  - W=0 (default value)
-
-    The ``Wunused`` with ``Wno-unused-parameter``, ``Wdisabled-optimization``
-    and ``Wvla`` flags are enabled.
-
-    The ``Wunused-but-set-variable``, ``Wmaybe-uninitialized`` and
-    ``Wpacked-bitfield-compat`` are GCC specific flags that are also enabled.
-
-  - W=1
-
-    Adds ``Wextra``, ``Wmissing-format-attribute``, ``Wmissing-prototypes``,
-    ``Wold-style-definition`` and ``Wunused-const-variable``.
-
-  - W=2
-
-    Adds ``Waggregate-return``, ``Wcast-align``, ``Wnested-externs``,
-    ``Wshadow``, ``Wlogical-op``.
-
-  - W=3
-
-    Adds ``Wbad-function-cast``, ``Wcast-qual``, ``Wconversion``, ``Wpacked``,
-    ``Wpointer-arith``, ``Wredundant-decls`` and
-    ``Wswitch-default``.
-
-  Refer to the GCC or Clang documentation for more information on the individual
-  options: https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html and
-  https://clang.llvm.org/docs/DiagnosticsReference.html.
-
-  NB: The ``Werror`` flag is enabled by default in TF-A and can be disabled by
-  setting the ``E`` build flag to 0.
+  options to detect potentially incorrect code. TF-A is tested with ``W=0`` but
+  it is recommended to develop against ``W=2`` (which will eventually become the
+  default).
 
 .. rubric:: References
 
diff --git a/drivers/arm/gic/v2/gicv2.mk b/drivers/arm/gic/v2/gicv2.mk
index 49996bb512..454bbde5e2 100644
--- a/drivers/arm/gic/v2/gicv2.mk
+++ b/drivers/arm/gic/v2/gicv2.mk
@@ -7,9 +7,17 @@
 # No support for extended PPI and SPI range
 GIC_EXT_INTID	:=	0
 
+# Use default number of interrupt for GICV2 context
+GICV2_INTR_NUM	?=	0
+
 GICV2_SOURCES	+=	drivers/arm/gic/v2/gicv2_main.c		\
 			drivers/arm/gic/v2/gicv2_helpers.c	\
 			drivers/arm/gic/v2/gicdv2_helpers.c
 
 # Set GICv2 build option
-$(eval $(call add_define,GIC_EXT_INTID))
\ No newline at end of file
+$(eval $(call add_defines, \
+	GIC_EXT_INTID \
+	GICV2_INTR_NUM \
+))
+
+$(eval $(call assert_numeric,GICV2_INTR_NUM))
diff --git a/drivers/arm/gic/v2/gicv2_main.c b/drivers/arm/gic/v2/gicv2_main.c
index 1925a13ac6..329a359dbb 100644
--- a/drivers/arm/gic/v2/gicv2_main.c
+++ b/drivers/arm/gic/v2/gicv2_main.c
@@ -554,3 +554,94 @@ void gicv2_interrupt_set_cfg(unsigned int id, unsigned int cfg)
 {
 	gicd_set_icfgr(driver_data->gicd_base, id, cfg);
 }
+
+/*******************************************************************************
+ * Helper function to get the maximum INTID
+ ******************************************************************************/
+static unsigned int get_nb_ints(uintptr_t gicd_base)
+{
+	unsigned int num_ints;
+
+	num_ints = gicd_read_typer(gicd_base);
+	num_ints &= TYPER_IT_LINES_NO_MASK;
+	num_ints = (num_ints + 1U) << 5U;
+
+	return num_ints;
+}
+
+/* Helper macros to save and restore GICD registers to and from the context */
+#define RESTORE_GICD_REGS(base, ctx, intr_num, reg, REG)		\
+	do {								\
+		for (unsigned int int_id = MIN_SPI_ID; int_id < (intr_num);\
+				int_id += (1U << REG##R_SHIFT)) {	\
+			gicd_write_##reg((base), int_id,		\
+				(ctx)->gicd_##reg[(int_id - MIN_SPI_ID) >> \
+							REG##R_SHIFT]);	\
+		}							\
+	} while (false)
+
+#define SAVE_GICD_REGS(base, ctx, intr_num, reg, REG)			\
+	do {								\
+		for (unsigned int int_id = MIN_SPI_ID; int_id < (intr_num);\
+				int_id += (1U << REG##R_SHIFT)) {	\
+			(ctx)->gicd_##reg[(int_id - MIN_SPI_ID) >>	\
+			REG##R_SHIFT] = gicd_read_##reg((base), int_id); \
+		}							\
+	} while (false)
+
+/*****************************************************************************
+ * Function to save the GIC Distributor register context. This function
+ * must be invoked after CPU interface disable.
+ *****************************************************************************/
+void gicv2_distif_save(gicv2_dist_ctx_t * const dist_ctx)
+{
+	uintptr_t gicd_base;
+	unsigned int num_ints;
+
+	assert(driver_data != NULL);
+	assert(driver_data->gicd_base != 0U);
+
+	gicd_base = driver_data->gicd_base;
+	num_ints = get_nb_ints(gicd_base);
+
+	/* Save the GICD_CTLR */
+	dist_ctx->gicd_ctlr = gicd_read_ctlr(gicd_base);
+
+	/* Save  GICD configuration for ALL SPI */
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, igroupr, IGROUP);
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, isenabler, ISENABLE);
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, ispendr, ISPEND);
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, isactiver, ISACTIVE);
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, ipriorityr, IPRIORITY);
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, itargetsr, ITARGETS);
+	SAVE_GICD_REGS(gicd_base, dist_ctx, num_ints, icfgr, ICFG);
+}
+
+/*****************************************************************************
+ * Function to restore the GIC Distributor register context.
+ * This function must be invoked prior to Redistributor restore and CPU
+ * interface enable.
+ *****************************************************************************/
+void gicv2_distif_restore(const gicv2_dist_ctx_t * const dist_ctx)
+{
+	uintptr_t gicd_base;
+	unsigned int num_ints;
+
+	assert(driver_data != NULL);
+	assert(driver_data->gicd_base != 0U);
+
+	gicd_base = driver_data->gicd_base;
+	num_ints = get_nb_ints(gicd_base);
+
+	/* Restore GICD configuration for ALL SPI */
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, igroupr, IGROUP);
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, isenabler, ISENABLE);
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, ispendr, ISPEND);
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, isactiver, ISACTIVE);
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, ipriorityr, IPRIORITY);
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, itargetsr, ITARGETS);
+	RESTORE_GICD_REGS(gicd_base, dist_ctx, num_ints, icfgr, ICFG);
+
+	/* Restore the GICD_CTLR */
+	gicd_write_ctlr(gicd_base, dist_ctx->gicd_ctlr);
+}
diff --git a/drivers/auth/auth_mod.c b/drivers/auth/auth_mod.c
index 1bf03d4092..69eb74abef 100644
--- a/drivers/auth/auth_mod.c
+++ b/drivers/auth/auth_mod.c
@@ -248,7 +248,6 @@ static int auth_nvctr(const auth_method_param_nv_ctr_t *param,
 	unsigned int data_len, len, i;
 	unsigned int plat_nv_ctr;
 	int rc = 0;
-	bool is_trial_run = false;
 
 	/* Get the counter value from current image. The AM expects the IPM
 	 * to return the counter value as a DER encoded integer */
@@ -300,9 +299,14 @@ static int auth_nvctr(const auth_method_param_nv_ctr_t *param,
 		return 1;
 	} else if (*cert_nv_ctr > plat_nv_ctr) {
 #if PSA_FWU_SUPPORT && IMAGE_BL2
-		is_trial_run = fwu_is_trial_run_state();
+		if (fwu_get_active_bank_state() == FWU_BANK_STATE_ACCEPTED) {
+			*need_nv_ctr_upgrade = true;
+		} else {
+			*need_nv_ctr_upgrade = false;
+		}
+#else
+		*need_nv_ctr_upgrade = true;
 #endif /* PSA_FWU_SUPPORT && IMAGE_BL2 */
-		*need_nv_ctr_upgrade = !is_trial_run;
 	}
 
 	return 0;
diff --git a/drivers/brcm/emmc/emmc_csl_sdcard.c b/drivers/brcm/emmc/emmc_csl_sdcard.c
index 9e2c618d9f..40bc4a0582 100644
--- a/drivers/brcm/emmc/emmc_csl_sdcard.c
+++ b/drivers/brcm/emmc/emmc_csl_sdcard.c
@@ -479,10 +479,11 @@ int init_mmc_card(struct sd_handle *handle)
 			handle->device->cfg.blockSize = 512;
 		}
 
-		if (handle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY)
+		if (handle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY) {
 			EMMC_TRACE("Sector addressing\n");
-		else
+		} else {
 			EMMC_TRACE("Byte addressing\n");
+		}
 
 		EMMC_TRACE("Ext_CSD_storage[162]: 0x%02X  Ext_CSD_storage[179]: 0x%02X\n",
 			   emmc_global_buf_ptr->u.Ext_CSD_storage[162],
diff --git a/drivers/brcm/emmc/emmc_pboot_hal_memory_drv.c b/drivers/brcm/emmc/emmc_pboot_hal_memory_drv.c
index 68f93e75ef..fcd499f16b 100644
--- a/drivers/brcm/emmc/emmc_pboot_hal_memory_drv.c
+++ b/drivers/brcm/emmc/emmc_pboot_hal_memory_drv.c
@@ -278,8 +278,9 @@ struct sd_handle *sdio_init(void)
 
 	SDIO_base = EMMC_CTRL_REGS_BASE_ADDR;
 
-	if (SDIO_base == SDIO0_EMMCSDXC_SYSADDR)
+	if (SDIO_base == SDIO0_EMMCSDXC_SYSADDR) {
 		EMMC_TRACE(" ---> for SDIO 0 Controller\n\n");
+	}
 
 	memset(p_sdhandle, 0, sizeof(struct sd_handle));
 
@@ -290,8 +291,9 @@ struct sd_handle *sdio_init(void)
 	memset(p_sdhandle->card, 0, sizeof(struct sd_card_info));
 
 	if (chal_sd_start((CHAL_HANDLE *) p_sdhandle->device,
-			  SD_PIO_MODE, SDIO_base, SDIO_base) != SD_OK)
+			  SD_PIO_MODE, SDIO_base, SDIO_base) != SD_OK) {
 		return NULL;
+	}
 
 	set_config(p_sdhandle, SD_NORMAL_SPEED, MAX_CMD_RETRY, SD_DMA_OFF,
 		   SD_DMA_BOUNDARY_4K, EMMC_BLOCK_SIZE, EMMC_WFE_RETRY);
@@ -330,14 +332,16 @@ uint32_t sdio_read(struct sd_handle *p_sdhandle,
 	VERBOSE("EMMC READ: dst=0x%lx, src=0x%lx, size=0x%lx\n",
 			storage_addr, mem_addr, bytes_to_read);
 
-	if (storage_size < bytes_to_read)
+	if (storage_size < bytes_to_read) {
 		/* Don't have sufficient storage to complete the operation */
 		return 0;
+	}
 
 	/* Range check non high capacity memory */
 	if ((p_sdhandle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY) == 0) {
-		if (mem_addr > 0x80000000)
+		if (mem_addr > 0x80000000) {
 			return 0;
+		}
 	}
 
 	/* High capacity card use block address mode */
@@ -384,10 +388,11 @@ uint32_t sdio_read(struct sd_handle *p_sdhandle,
 			/* Update Physical address */
 			outputBuf += manual_copy_size;
 
-			if (p_sdhandle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY)
+			if (p_sdhandle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY) {
 				blockAddr++;
-			else
+			} else {
 				blockAddr += blockSize;
+			}
 		} else {
 			return 0;
 		}
@@ -395,10 +400,11 @@ uint32_t sdio_read(struct sd_handle *p_sdhandle,
 
 	while (remSize >= blockSize) {
 
-		if (remSize >= SD_MAX_BLK_TRANSFER_LENGTH)
+		if (remSize >= SD_MAX_BLK_TRANSFER_LENGTH) {
 			readLen = SD_MAX_BLK_TRANSFER_LENGTH;
-		else
+		} else {
 			readLen = (remSize / blockSize) * blockSize;
+		}
 
 		/* Check for overflow */
 		if ((rdCount + readLen) > storage_size ||
@@ -409,10 +415,11 @@ uint32_t sdio_read(struct sd_handle *p_sdhandle,
 		}
 
 		if (!read_block(p_sdhandle, outputBuf, blockAddr, readLen)) {
-			if (p_sdhandle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY)
+			if (p_sdhandle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY) {
 				blockAddr += (readLen / blockSize);
-			else
+			} else {
 				blockAddr += readLen;
+			}
 
 			remSize -= readLen;
 			rdCount += readLen;
@@ -463,8 +470,9 @@ static uint32_t sdio_write(struct sd_handle *p_sdhandle, uintptr_t mem_addr,
 
 	/* range check non high capacity memory */
 	if ((p_sdhandle->device->ctrl.ocr & SD_CARD_HIGH_CAPACITY) == 0) {
-		if (mem_addr > 0x80000000)
+		if (mem_addr > 0x80000000) {
 			return 0;
+		}
 	}
 
 	/* the high capacity card use block address mode */
@@ -491,11 +499,12 @@ static uint32_t sdio_write(struct sd_handle *p_sdhandle, uintptr_t mem_addr,
 				blockAddr, p_sdhandle->device->cfg.blockSize)) {
 
 			if (remSize <
-			    (p_sdhandle->device->cfg.blockSize - offset))
+			    (p_sdhandle->device->cfg.blockSize - offset)) {
 				manual_copy_size = remSize;
-			else
+			} else {
 				manual_copy_size =
 				    p_sdhandle->device->cfg.blockSize - offset;
+			}
 
 			memcpy((void *)((uintptr_t)
 				(emmc_global_buf_ptr->u.tempbuf + offset)),
@@ -530,11 +539,12 @@ static uint32_t sdio_write(struct sd_handle *p_sdhandle, uintptr_t mem_addr,
 				inputBuf += manual_copy_size;
 
 				if (p_sdhandle->device->ctrl.ocr &
-				    SD_CARD_HIGH_CAPACITY)
+				    SD_CARD_HIGH_CAPACITY) {
 					blockAddr++;
-				else
+				} else {
 					blockAddr +=
 					    p_sdhandle->device->cfg.blockSize;
+				}
 			} else
 				return 0;
 		} else {
diff --git a/drivers/fwu/fwu.c b/drivers/fwu/fwu.c
index ff432be8c8..b6f06e0a7b 100644
--- a/drivers/fwu/fwu.c
+++ b/drivers/fwu/fwu.c
@@ -24,6 +24,17 @@
 CASSERT((offsetof(struct fwu_metadata, crc_32) == 0),
 	crc_32_must_be_first_member_of_structure);
 
+/*
+ * Ensure that the NR_OF_FW_BANKS selected by the platform is not
+ * zero and not greater than the maximum number of banks allowed
+ * by the specification.
+ */
+CASSERT((NR_OF_FW_BANKS > 0) && (NR_OF_FW_BANKS <= NR_OF_MAX_FW_BANKS),
+	assert_fwu_num_banks_invalid_value);
+
+#define FWU_METADATA_VERSION		2U
+#define FWU_FW_STORE_DESC_OFFSET	0x20U
+
 static struct fwu_metadata metadata;
 static bool is_metadata_initialized __unused;
 
@@ -51,16 +62,54 @@ static int fwu_metadata_crc_check(void)
 /*******************************************************************************
  * Check the sanity of FWU metadata.
  *
- * return -1 on error, otherwise 0
+ * return -EINVAL on error, otherwise 0
  ******************************************************************************/
 static int fwu_metadata_sanity_check(void)
 {
-	/* ToDo: add more conditions for sanity check */
-	if ((metadata.active_index >= NR_OF_FW_BANKS) ||
-	    (metadata.previous_active_index >= NR_OF_FW_BANKS)) {
-		return -1;
+	if (metadata.version != FWU_METADATA_VERSION) {
+		WARN("Incorrect FWU Metadata version of %u\n",
+		     metadata.version);
+		return -EINVAL;
+	}
+
+	if (metadata.active_index >= NR_OF_FW_BANKS) {
+		WARN("Active Index value(%u) greater than the configured value(%d)",
+		     metadata.active_index, NR_OF_FW_BANKS);
+		return -EINVAL;
+	}
+
+	if (metadata.previous_active_index >= NR_OF_FW_BANKS) {
+		WARN("Previous Active Index value(%u) greater than the configured value(%d)",
+		     metadata.previous_active_index, NR_OF_FW_BANKS);
+		return -EINVAL;
 	}
 
+#if PSA_FWU_METADATA_FW_STORE_DESC
+	if (metadata.fw_desc.num_banks != NR_OF_FW_BANKS) {
+		WARN("Number of Banks(%u) in FWU Metadata different from the configured value(%d)",
+		     metadata.fw_desc.num_banks, NR_OF_FW_BANKS);
+		return -EINVAL;
+	}
+
+	if (metadata.fw_desc.num_images != NR_OF_IMAGES_IN_FW_BANK) {
+		WARN("Number of Images(%u) in FWU Metadata different from the configured value(%d)",
+		     metadata.fw_desc.num_images, NR_OF_IMAGES_IN_FW_BANK);
+		return -EINVAL;
+	}
+
+	if (metadata.desc_offset != FWU_FW_STORE_DESC_OFFSET) {
+		WARN("Descriptor Offset(0x%x) in the FWU Metadata not equal to 0x20\n",
+		     metadata.desc_offset);
+		return -EINVAL;
+	}
+#else
+	if (metadata.desc_offset != 0U) {
+		WARN("Descriptor offset has non zero value of 0x%x\n",
+		     metadata.desc_offset);
+		return -EINVAL;
+	}
+#endif
+
 	return 0;
 }
 
@@ -133,28 +182,80 @@ exit:
 }
 
 /*******************************************************************************
- * The system runs in the trial run state if any of the images in the active
- * firmware bank has not been accepted yet.
+ * Check for an alternate bank for the platform to boot from. This function will
+ * mostly be called whenever the count of the number of times a platform boots
+ * in the Trial State exceeds a pre-set limit.
+ * The function first checks if the platform can boot from the previously active
+ * bank. If not, it tries to find another bank in the accepted state.
+ * And finally, if both the checks fail, as a last resort, it tries to find
+ * a valid bank.
  *
- * Returns true if the system is running in the trial state.
+ * Returns the index of a bank to boot, else returns invalid index
+ * INVALID_BOOT_IDX.
  ******************************************************************************/
-bool fwu_is_trial_run_state(void)
+uint32_t fwu_get_alternate_boot_bank(void)
 {
-	bool trial_run = false;
+	uint32_t i;
 
-	assert(is_metadata_initialized);
+	/* First check if the previously active bank can be used */
+	if (metadata.bank_state[metadata.previous_active_index] ==
+	    FWU_BANK_STATE_ACCEPTED) {
+		return metadata.previous_active_index;
+	}
+
+	/* Now check for any other bank in the accepted state */
+	for (i = 0U; i < NR_OF_FW_BANKS; i++) {
+		if (i == metadata.active_index ||
+		    i == metadata.previous_active_index) {
+			continue;
+		}
+
+		if (metadata.bank_state[i] == FWU_BANK_STATE_ACCEPTED) {
+			return i;
+		}
+	}
+
+	/*
+	 * No accepted bank found. Now try booting from a valid bank.
+	 * Give priority to the previous active bank.
+	 */
+	if (metadata.bank_state[metadata.previous_active_index] ==
+	    FWU_BANK_STATE_VALID) {
+		return metadata.previous_active_index;
+	}
 
-	for (unsigned int i = 0U; i < NR_OF_IMAGES_IN_FW_BANK; i++) {
-		struct fwu_image_entry *entry = &metadata.img_entry[i];
-		struct fwu_image_properties *img_props =
-			&entry->img_props[metadata.active_index];
-		if (img_props->accepted == 0) {
-			trial_run = true;
-			break;
+	for (i = 0U; i < NR_OF_FW_BANKS; i++) {
+		if (i == metadata.active_index ||
+		    i == metadata.previous_active_index) {
+			continue;
+		}
+
+		if (metadata.bank_state[i] == FWU_BANK_STATE_VALID) {
+			return i;
 		}
 	}
 
-	return trial_run;
+	return INVALID_BOOT_IDX;
+}
+
+/*******************************************************************************
+ * The platform can be in one of Valid, Invalid or Accepted states.
+ *
+ * Invalid - One or more images in the bank are corrupted, or partially
+ *           overwritten. The bank is not to be used for booting.
+ *
+ * Valid - All images of the bank are valid but at least one image has not
+ *         been accepted. This implies that the platform is in Trial State.
+ *
+ * Accepted - All images of the bank are valid and accepted.
+ *
+ * Returns the state of the current active bank
+ ******************************************************************************/
+uint32_t fwu_get_active_bank_state(void)
+{
+	assert(is_metadata_initialized);
+
+	return metadata.bank_state[metadata.active_index];
 }
 
 const struct fwu_metadata *fwu_get_metadata(void)
diff --git a/drivers/imx/usdhc/imx_usdhc.c b/drivers/imx/usdhc/imx_usdhc.c
index 07f55b7843..49dfc076dc 100644
--- a/drivers/imx/usdhc/imx_usdhc.c
+++ b/drivers/imx/usdhc/imx_usdhc.c
@@ -136,7 +136,8 @@ static int imx_usdhc_send_cmd(struct mmc_cmd *cmd)
 		break;
 	case MMC_CMD(18):
 		multiple = 1;
-		/* fall thru for read op */
+		/* for read op */
+		/* fallthrough */
 	case MMC_CMD(17):
 	case MMC_CMD(8):
 		mixctl |= MIXCTRL_DTDSEL;
@@ -144,7 +145,8 @@ static int imx_usdhc_send_cmd(struct mmc_cmd *cmd)
 		break;
 	case MMC_CMD(25):
 		multiple = 1;
-		/* fall thru for data op flag */
+		/* for data op flag */
+		/* fallthrough */
 	case MMC_CMD(24):
 		data = 1;
 		break;
diff --git a/drivers/io/io_mtd.c b/drivers/io/io_mtd.c
index 5d86592db9..6621d49695 100644
--- a/drivers/io/io_mtd.c
+++ b/drivers/io/io_mtd.c
@@ -271,6 +271,20 @@ static int mtd_dev_open(const uintptr_t dev_spec, io_dev_info_t **dev_info)
 
 static int mtd_dev_close(io_dev_info_t *dev_info)
 {
+	mtd_dev_state_t *cur;
+	io_mtd_ops_t *ops;
+	int result;
+
+	cur = (mtd_dev_state_t *)dev_info->info;
+	ops = &(cur->dev_spec->ops);
+
+	if (ops->reset != NULL) {
+		result = ops->reset();
+		if (result != 0) {
+			return result;
+		}
+	}
+
 	return free_dev_info(dev_info);
 }
 
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index 8e83464d5e..2b727d4e76 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -69,8 +69,7 @@ static int mmc_send_cmd(unsigned int idx, unsigned int arg,
 		int i;
 
 		for (i = 0; i < 4; i++) {
-			*r_data = cmd.resp_data[i];
-			r_data++;
+			r_data[i] = cmd.resp_data[i];
 		}
 	}
 
@@ -112,7 +111,7 @@ static int mmc_device_state(void)
 	return MMC_GET_STATE(resp_data[0]);
 }
 
-static int mmc_send_part_switch_cmd(unsigned int part_config)
+static int mmc_send_part_switch_cmd(unsigned char part_config)
 {
 	int ret;
 	unsigned int part_time = 0;
@@ -760,9 +759,9 @@ size_t mmc_erase_blocks(int lba, size_t size)
 	return size;
 }
 
-static int mmc_part_switch(unsigned int part_type)
+static int mmc_part_switch(unsigned char part_type)
 {
-	uint8_t part_config = mmc_ext_csd[CMD_EXTCSD_PARTITION_CONFIG];
+	unsigned char part_config = mmc_ext_csd[CMD_EXTCSD_PARTITION_CONFIG];
 
 	part_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;
 	part_config |= part_type;
@@ -780,8 +779,7 @@ int mmc_part_switch_current_boot(void)
 	unsigned char current_boot_part = mmc_current_boot_part();
 	int ret;
 
-	if (current_boot_part != 1U &&
-	    current_boot_part != 2U) {
+	if ((current_boot_part != 1U) && (current_boot_part != 2U)) {
 		ERROR("Got unexpected value for active boot partition, %u\n", current_boot_part);
 		return -EIO;
 	}
diff --git a/drivers/mtd/hyperflash/hyperflash.c b/drivers/mtd/hyperflash/hyperflash.c
new file mode 100644
index 0000000000..a76962987f
--- /dev/null
+++ b/drivers/mtd/hyperflash/hyperflash.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stddef.h>
+
+#include <common/debug.h>
+#include <drivers/hyperflash.h>
+#include <lib/utils.h>
+
+static struct hyperflash_device hyperflash_dev;
+
+#pragma weak plat_get_hyperflash_data
+int plat_get_hyperflash_data(struct hyperflash_device *device)
+{
+	return 0;
+}
+
+int hyperflash_read(unsigned int offset, uintptr_t buffer, size_t length,
+		    size_t *length_read)
+{
+	return hyperflash_dev.ops->read(offset, (uint8_t *)buffer, length,
+					length_read);
+}
+
+void hyperflash_ctrl_init(const struct hyperflash_ctrl_ops *ops)
+{
+	hyperflash_dev.ops = ops;
+}
+
+int hyperflash_init(unsigned long long *size, unsigned int *erase_size)
+{
+	if (hyperflash_dev.ops->read == NULL) {
+		return -ENODEV;
+	}
+
+	if (plat_get_hyperflash_data(&hyperflash_dev) != 0) {
+		return -EINVAL;
+	}
+
+	assert(hyperflash_dev.size != 0U);
+
+	*size = hyperflash_dev.size;
+
+	return 0;
+}
diff --git a/drivers/mtd/nand/raw_nand.c b/drivers/mtd/nand/raw_nand.c
index 021e30b3be..3595c21424 100644
--- a/drivers/mtd/nand/raw_nand.c
+++ b/drivers/mtd/nand/raw_nand.c
@@ -218,6 +218,18 @@ int nand_wait_ready(unsigned int delay_ms)
 	return -ETIMEDOUT;
 }
 
+static int nand_reset(void)
+{
+	int ret;
+
+	ret = nand_send_cmd(NAND_CMD_RESET, NAND_TWB_MAX);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return nand_send_wait(PSEC_TO_MSEC(NAND_TRST_MAX), 0U);
+}
+
 #if NAND_ONFI_DETECT
 static uint16_t nand_check_crc(uint16_t crc, uint8_t *data_in,
 			       unsigned int data_len)
@@ -265,18 +277,6 @@ static int nand_read_id(uint8_t addr, uint8_t *id, unsigned int size)
 	return nand_read_data(id, size, true);
 }
 
-static int nand_reset(void)
-{
-	int ret;
-
-	ret = nand_send_cmd(NAND_CMD_RESET, NAND_TWB_MAX);
-	if (ret != 0) {
-		return ret;
-	}
-
-	return nand_send_wait(PSEC_TO_MSEC(NAND_TRST_MAX), 0U);
-}
-
 static int nand_read_param_page(void)
 {
 	struct nand_param_page page;
@@ -346,11 +346,6 @@ static int detect_onfi(void)
 	int ret;
 	char id[4];
 
-	ret = nand_reset();
-	if (ret != 0) {
-		return ret;
-	}
-
 	ret = nand_read_id(ONFI_SIGNATURE_ADDR, (uint8_t *)id, sizeof(id));
 	if (ret != 0) {
 		return ret;
@@ -406,6 +401,8 @@ void nand_raw_ctrl_init(const struct nand_ctrl_ops *ops)
 
 int nand_raw_init(unsigned long long *size, unsigned int *erase_size)
 {
+	int ret;
+
 	rawnand_dev.nand_dev = get_nand_device();
 	if (rawnand_dev.nand_dev == NULL) {
 		return -EINVAL;
@@ -420,6 +417,11 @@ int nand_raw_init(unsigned long long *size, unsigned int *erase_size)
 		return -ENODEV;
 	}
 
+	ret = nand_reset();
+	if (ret != 0) {
+		return ret;
+	}
+
 #if NAND_ONFI_DETECT
 	if (detect_onfi() != 0) {
 		WARN("Detect ONFI failed\n");
diff --git a/drivers/mtd/nand/spi_nand.c b/drivers/mtd/nand/spi_nand.c
index 542b614ffe..fe1338faf2 100644
--- a/drivers/mtd/nand/spi_nand.c
+++ b/drivers/mtd/nand/spi_nand.c
@@ -17,7 +17,6 @@
 
 #define SPI_NAND_MAX_ID_LEN		4U
 #define DELAY_US_400MS			400000U
-#define MACRONIX_ID			0xC2U
 
 static struct spinand_device spinand_dev;
 
@@ -39,6 +38,7 @@ static int spi_nand_reg(bool read_reg, uint8_t reg, uint8_t *val,
 		op.cmd.opcode = SPI_NAND_OP_SET_FEATURE;
 	}
 
+	op.cmd.nbytes = 1U;
 	op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	op.addr.val = reg;
 	op.addr.nbytes = 1U;
@@ -91,7 +91,7 @@ static int spi_nand_quad_enable(uint8_t manufacturer_id)
 {
 	bool enable = false;
 
-	if (manufacturer_id != MACRONIX_ID) {
+	if ((spinand_dev.flags & SPI_NAND_HAS_QE_BIT) == 0U) {
 		return 0;
 	}
 
@@ -132,6 +132,7 @@ static int spi_nand_reset(void)
 
 	zeromem(&op, sizeof(struct spi_mem_op));
 	op.cmd.opcode = SPI_NAND_OP_RESET;
+	op.cmd.nbytes = 1U;
 	op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 
 	ret = spi_mem_exec_op(&op);
@@ -148,6 +149,7 @@ static int spi_nand_read_id(uint8_t *id)
 
 	zeromem(&op, sizeof(struct spi_mem_op));
 	op.cmd.opcode = SPI_NAND_OP_READ_ID;
+	op.cmd.nbytes = 1U;
 	op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	op.data.dir = SPI_MEM_DATA_IN;
 	op.data.nbytes = SPI_NAND_MAX_ID_LEN;
@@ -168,6 +170,7 @@ static int spi_nand_load_page(unsigned int page)
 
 	zeromem(&op, sizeof(struct spi_mem_op));
 	op.cmd.opcode = SPI_NAND_OP_LOAD_PAGE;
+	op.cmd.nbytes = 1U;
 	op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	op.addr.val = (block_nb << block_sh) | page_nb;
 	op.addr.nbytes = 3U;
@@ -193,7 +196,7 @@ static int spi_nand_read_from_cache(unsigned int page, unsigned int offset,
 	spinand_dev.spi_read_cache_op.data.buf = buffer;
 	spinand_dev.spi_read_cache_op.data.nbytes = len;
 
-	return spi_mem_exec_op(&spinand_dev.spi_read_cache_op);
+	return spi_mem_dirmap_read(&spinand_dev.spi_read_cache_op);
 }
 
 static int spi_nand_read_page(unsigned int page, unsigned int offset,
@@ -275,6 +278,7 @@ int spi_nand_init(unsigned long long *size, unsigned int *erase_size)
 	spinand_dev.nand_dev->nb_planes = 1;
 
 	spinand_dev.spi_read_cache_op.cmd.opcode = SPI_NAND_OP_READ_FROM_CACHE;
+	spinand_dev.spi_read_cache_op.cmd.nbytes = 1U;
 	spinand_dev.spi_read_cache_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	spinand_dev.spi_read_cache_op.addr.nbytes = 2U;
 	spinand_dev.spi_read_cache_op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
diff --git a/drivers/mtd/nor/spi_nor.c b/drivers/mtd/nor/spi_nor.c
index 2e343448a0..ae6c709bef 100644
--- a/drivers/mtd/nor/spi_nor.c
+++ b/drivers/mtd/nor/spi_nor.c
@@ -26,6 +26,7 @@
 #define BANK_SIZE		0x1000000U
 
 #define SPI_READY_TIMEOUT_US	40000U
+#define SPI_NOR_SRST_US		100U
 
 static struct nor_device nor_dev;
 
@@ -42,6 +43,7 @@ static int spi_nor_reg(uint8_t reg, uint8_t *buf, size_t len,
 
 	zeromem(&op, sizeof(struct spi_mem_op));
 	op.cmd.opcode = reg;
+	op.cmd.nbytes = 1U;
 	op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	op.data.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	op.data.dir = dir;
@@ -214,6 +216,47 @@ static int spi_nor_quad_enable(void)
 	return 0;
 }
 
+static int spi_nor_macronix_octal_dtr_enable(void)
+{
+	struct spi_mem_op op;
+	uint8_t buf;
+	int ret;
+
+	zeromem(&op, sizeof(struct spi_mem_op));
+	op.cmd.opcode = SPI_NOR_OP_WR_CR2;
+	op.cmd.nbytes = 1U;
+	op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	op.addr.nbytes = 4U;
+	op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	op.data.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	op.data.dir = SPI_MEM_DATA_OUT;
+	op.data.nbytes = 1U;
+	op.data.buf = &buf;
+
+	ret = spi_nor_write_en();
+	if (ret != 0) {
+		return ret;
+	}
+
+	buf = SPI_NOR_REG_MXIC_DC_20;
+	op.addr.val = SPI_NOR_REG_MXIC_CR2_DC;
+
+	ret = spi_mem_exec_op(&op);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = spi_nor_write_en();
+	if (ret != 0) {
+		return ret;
+	}
+
+	buf = SPI_NOR_REG_MXIC_OPI_DTR_EN;
+	op.addr.val = SPI_NOR_REG_MXIC_CR2_MODE;
+
+	return spi_mem_exec_op(&op);
+}
+
 static int spi_nor_clean_bar(void)
 {
 	int ret;
@@ -300,7 +343,7 @@ int spi_nor_read(unsigned int offset, uintptr_t buffer, size_t length,
 			nor_dev.read_op.data.nbytes = length;
 		}
 
-		ret = spi_mem_exec_op(&nor_dev.read_op);
+		ret = spi_mem_dirmap_read(&nor_dev.read_op);
 		if (ret != 0) {
 			spi_nor_clean_bar();
 			return ret;
@@ -329,6 +372,7 @@ int spi_nor_init(unsigned long long *size, unsigned int *erase_size)
 
 	/* Default read command used */
 	nor_dev.read_op.cmd.opcode = SPI_NOR_OP_READ;
+	nor_dev.read_op.cmd.nbytes = 1U;
 	nor_dev.read_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	nor_dev.read_op.addr.nbytes = 3U;
 	nor_dev.read_op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
@@ -341,8 +385,13 @@ int spi_nor_init(unsigned long long *size, unsigned int *erase_size)
 
 	assert(nor_dev.size != 0U);
 
-	if (nor_dev.size > BANK_SIZE) {
-		nor_dev.flags |= SPI_NOR_USE_BANK;
+	if ((nor_dev.size > BANK_SIZE) &&
+	    (nor_dev.read_op.addr.nbytes == 3U) &&
+	    ((nor_dev.flags & SPI_NOR_USE_BANK) == 0U)) {
+		WARN("%s: Only the first 16 MB of the memory are available. Please,\n", __func__);
+		WARN("%s: enable SPI_NOR_USE_BANK flag in plat_get_nor_data function\n", __func__);
+		WARN("%s: if the memory supports bank selection or use 4-bytes\n", __func__);
+		WARN("%s: address commands if the memory supports these commands.\n", __func__);
 	}
 
 	*size = nor_dev.size;
@@ -352,6 +401,24 @@ int spi_nor_init(unsigned long long *size, unsigned int *erase_size)
 		return ret;
 	}
 
+	if (nor_dev.read_op.cmd.nbytes == 2U) {
+		ret = -EOPNOTSUPP;
+
+		/* Only OCTAL DTR mode is currently supported */
+		if (nor_dev.read_op.cmd.buswidth == 8U) {
+			switch (id) {
+			case MACRONIX_ID:
+				INFO("Enable Macronix octal DTR support\n");
+				ret = spi_nor_macronix_octal_dtr_enable();
+				break;
+			default:
+				break;
+			}
+		}
+
+		return ret;
+	}
+
 	if ((nor_dev.flags & SPI_NOR_USE_BANK) != 0U) {
 		switch (id) {
 		case SPANSION_ID:
@@ -385,3 +452,65 @@ int spi_nor_init(unsigned long long *size, unsigned int *erase_size)
 
 	return ret;
 }
+
+int spi_nor_reset(void)
+{
+	struct spi_mem_op op;
+	bool repeat = false;
+	int ret;
+
+	/* Software reset to be done for octal DTR */
+	if (nor_dev.read_op.cmd.nbytes != 2U) {
+		return 0;
+	}
+
+	/* Detect if opcode is repeated or inverted */
+	if (((nor_dev.read_op.cmd.opcode & 0xFF00U) >> 8U) ==
+	    (nor_dev.read_op.cmd.opcode & 0x00FFU)) {
+		repeat = true;
+	}
+
+	zeromem(&op, sizeof(struct spi_mem_op));
+	op.cmd.nbytes = 2U;
+	op.cmd.buswidth = SPI_MEM_BUSWIDTH_8_LINE;
+	op.cmd.dtr = true;
+	op.addr.dtr = true;
+	op.dummy.dtr = true;
+	op.data.dtr = true;
+	op.data.dir = SPI_MEM_DATA_OUT;
+
+	/* Software reset enable */
+	op.cmd.opcode = (SPI_NOR_OP_SRSTEN << 8U);
+	if (repeat) {
+		op.cmd.opcode |= (SPI_NOR_OP_SRSTEN & 0xFFU);
+	} else {
+		op.cmd.opcode |= (~SPI_NOR_OP_SRSTEN & 0xFFU);
+	}
+
+	ret = spi_mem_exec_op(&op);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Software reset */
+	op.cmd.opcode = (SPI_NOR_OP_SRST << 8U);
+	if (repeat) {
+		op.cmd.opcode |= (SPI_NOR_OP_SRST & 0xFFU);
+	} else {
+		op.cmd.opcode |= (~SPI_NOR_OP_SRST & 0xFFU);
+	}
+
+	ret = spi_mem_exec_op(&op);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/*
+	 * Software Reset is not instant, and the delay varies
+	 * from flash to flash. Looking at a few flashes, most
+	 * read command range somewhere below 100 microseconds.
+	 */
+	udelay(SPI_NOR_SRST_US);
+
+	return 0;
+}
diff --git a/drivers/mtd/spi-mem/spi_mem.c b/drivers/mtd/spi-mem/spi_mem.c
index c43d5196c0..d4a81e389c 100644
--- a/drivers/mtd/spi-mem/spi_mem.c
+++ b/drivers/mtd/spi-mem/spi_mem.c
@@ -33,22 +33,31 @@ static struct spi_slave spi_slave;
 
 static bool spi_mem_check_buswidth_req(uint8_t buswidth, bool tx)
 {
+	unsigned int mode = spi_slave.mode;
+
 	switch (buswidth) {
 	case 1U:
 		return true;
 
 	case 2U:
-		if ((tx && (spi_slave.mode & (SPI_TX_DUAL | SPI_TX_QUAD)) !=
-		     0U) ||
-		    (!tx && (spi_slave.mode & (SPI_RX_DUAL | SPI_RX_QUAD)) !=
-		     0U)) {
+		if ((tx &&
+		     (mode & (SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL)) != 0U) ||
+		    (!tx &&
+		     (mode & (SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL)) != 0U)) {
 			return true;
 		}
 		break;
 
 	case 4U:
-		if ((tx && (spi_slave.mode & SPI_TX_QUAD) != 0U) ||
-		    (!tx && (spi_slave.mode & SPI_RX_QUAD) != 0U)) {
+		if ((tx && (mode & (SPI_TX_QUAD | SPI_TX_OCTAL)) != 0U) ||
+		    (!tx && (mode & (SPI_RX_QUAD | SPI_RX_OCTAL)) != 0U)) {
+			return true;
+		}
+		break;
+
+	case 8U:
+		if ((tx && (mode & SPI_TX_OCTAL) != 0U) ||
+		    (!tx && (mode & SPI_RX_OCTAL) != 0U)) {
 			return true;
 		}
 		break;
@@ -60,7 +69,7 @@ static bool spi_mem_check_buswidth_req(uint8_t buswidth, bool tx)
 	return false;
 }
 
-static bool spi_mem_supports_op(const struct spi_mem_op *op)
+static bool spi_mem_check_buswidth(const struct spi_mem_op *op)
 {
 	if (!spi_mem_check_buswidth_req(op->cmd.buswidth, true)) {
 		return false;
@@ -85,6 +94,49 @@ static bool spi_mem_supports_op(const struct spi_mem_op *op)
 	return true;
 }
 
+bool spi_mem_dtr_supports_op(const struct spi_mem_op *op)
+{
+	if ((op->cmd.buswidth == 8U) && ((op->cmd.nbytes % 2U) != 0U)) {
+		return false;
+	}
+
+	if ((op->addr.nbytes != 0U) && (op->addr.buswidth == 8U) &&
+	    ((op->addr.nbytes % 2U) != 0U)) {
+		return false;
+	}
+
+	if ((op->dummy.nbytes != 0U) && (op->dummy.buswidth == 8U) &&
+	    ((op->dummy.nbytes % 2U) != 0U)) {
+		return false;
+	}
+
+	return spi_mem_check_buswidth(op);
+}
+
+bool spi_mem_default_supports_op(const struct spi_mem_op *op)
+{
+	if (op->cmd.dtr || op->addr.dtr || op->dummy.dtr || op->data.dtr) {
+		return false;
+	}
+
+	if (op->cmd.nbytes != 1U) {
+		return false;
+	}
+
+	return spi_mem_check_buswidth(op);
+}
+
+static bool spi_mem_supports_op(const struct spi_mem_op *op)
+{
+	const struct spi_bus_ops *ops = spi_slave.ops;
+
+	if (ops->supports_op != NULL) {
+		return ops->supports_op(op);
+	}
+
+	return spi_mem_default_supports_op(op);
+}
+
 static int spi_mem_set_speed_mode(void)
 {
 	const struct spi_bus_ops *ops = spi_slave.ops;
@@ -151,9 +203,9 @@ int spi_mem_exec_op(const struct spi_mem_op *op)
 	const struct spi_bus_ops *ops = spi_slave.ops;
 	int ret;
 
-	VERBOSE("%s: cmd:%x mode:%d.%d.%d.%d addqr:%" PRIx64 " len:%x\n",
-		__func__, op->cmd.opcode, op->cmd.buswidth, op->addr.buswidth,
-		op->dummy.buswidth, op->data.buswidth,
+	VERBOSE("%s: cmd:%x dtr:%d mode:%d.%d.%d.%d addqr:%" PRIx64 " len:%x\n",
+		__func__, op->cmd.opcode, op->cmd.dtr, op->cmd.buswidth,
+		op->addr.buswidth, op->dummy.buswidth, op->data.buswidth,
 		op->addr.val, op->data.nbytes);
 
 	if (!spi_mem_supports_op(op)) {
@@ -174,6 +226,54 @@ int spi_mem_exec_op(const struct spi_mem_op *op)
 	return ret;
 }
 
+/*
+ * spi_mem_dirmap_read() - Read data through a direct mapping
+ * @op: The memory operation to execute.
+ *
+ * This function reads data from a memory device using a direct mapping.
+ *
+ * Return: 0 in case of success, a negative error code otherwise.
+ */
+int spi_mem_dirmap_read(const struct spi_mem_op *op)
+{
+	const struct spi_bus_ops *ops = spi_slave.ops;
+	int ret;
+
+	VERBOSE("%s: cmd:%x dtr:%d mode:%d.%d.%d.%d addr:%" PRIx64 " len:%x\n",
+		__func__, op->cmd.opcode, op->cmd.dtr, op->cmd.buswidth,
+		op->addr.buswidth, op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	if (op->data.dir != SPI_MEM_DATA_IN) {
+		return -EINVAL;
+	}
+
+	if (op->data.nbytes == 0U) {
+		return 0;
+	}
+
+	if (ops->dirmap_read == NULL) {
+		return spi_mem_exec_op(op);
+	}
+
+	if (!spi_mem_supports_op(op)) {
+		WARN("Error in spi_mem_support\n");
+		return -ENOTSUP;
+	}
+
+	ret = ops->claim_bus(spi_slave.cs);
+	if (ret != 0) {
+		WARN("Error claim_bus\n");
+		return ret;
+	}
+
+	ret = ops->dirmap_read(op);
+
+	ops->release_bus();
+
+	return ret;
+}
+
 /*
  * spi_mem_init_slave() - SPI slave device initialization.
  * @fdt: Pointer to the device tree blob.
@@ -256,6 +356,9 @@ int spi_mem_init_slave(void *fdt, int bus_node, const struct spi_bus_ops *ops)
 			case 4U:
 				mode |= SPI_TX_QUAD;
 				break;
+			case 8U:
+				mode |= SPI_TX_OCTAL;
+				break;
 			default:
 				WARN("spi-tx-bus-width %u not supported\n",
 				     fdt32_to_cpu(*cuint));
@@ -274,6 +377,9 @@ int spi_mem_init_slave(void *fdt, int bus_node, const struct spi_bus_ops *ops)
 			case 4U:
 				mode |= SPI_RX_QUAD;
 				break;
+			case 8U:
+				mode |= SPI_RX_OCTAL;
+				break;
 			default:
 				WARN("spi-rx-bus-width %u not supported\n",
 				     fdt32_to_cpu(*cuint));
diff --git a/drivers/nxp/ddr/nxp-ddr/ddr.c b/drivers/nxp/ddr/nxp-ddr/ddr.c
index c051b3b257..faf20e963f 100644
--- a/drivers/nxp/ddr/nxp-ddr/ddr.c
+++ b/drivers/nxp/ddr/nxp-ddr/ddr.c
@@ -269,7 +269,7 @@ static int cal_odt(const unsigned int clk,
 	unsigned int i;
 	const struct dynamic_odt *pdodt = NULL;
 
-	const static struct dynamic_odt *table[2][5] = {
+	static const struct dynamic_odt *table[2][5] = {
 		{single_S, single_D, NULL, NULL},
 		{dual_SS, dual_DD, NULL, NULL},
 	};
diff --git a/drivers/nxp/ddr/phy-gen2/messages.h b/drivers/nxp/ddr/phy-gen2/messages.h
index 7dec7df55f..a2310f23be 100644
--- a/drivers/nxp/ddr/phy-gen2/messages.h
+++ b/drivers/nxp/ddr/phy-gen2/messages.h
@@ -13,7 +13,7 @@ struct phy_msg {
 	const char *msg;
 };
 
-const static struct phy_msg messages_1d[] = {
+static const struct phy_msg messages_1d[] = {
 	{0x00000001,
 	 "PMU1:prbsGenCtl:%x\n"
 	},
@@ -1239,7 +1239,7 @@ const static struct phy_msg messages_1d[] = {
 	},
 };
 
-const static struct phy_msg messages_2d[] = {
+static const struct phy_msg messages_2d[] = {
 	{0x00000001,
 	 "PMU0: Converting %d into an MR\n"
 	},
diff --git a/drivers/partition/gpt.c b/drivers/partition/gpt.c
index 4fe832244a..8b1046d007 100644
--- a/drivers/partition/gpt.c
+++ b/drivers/partition/gpt.c
@@ -26,14 +26,16 @@ static int unicode_to_ascii(unsigned short *str_in, unsigned char *str_out)
 
 	/* check whether the unicode string is valid */
 	for (i = 1; i < (EFI_NAMELEN << 1); i += 2) {
-		if (name[i] != '\0')
+		if (name[i] != '\0') {
 			return -EINVAL;
+		}
 	}
 	/* convert the unicode string to ascii string */
 	for (i = 0; i < (EFI_NAMELEN << 1); i += 2) {
 		str_out[i >> 1] = name[i];
-		if (name[i] == '\0')
+		if (name[i] == '\0') {
 			break;
+		}
 	}
 	return 0;
 }
diff --git a/drivers/partition/partition.c b/drivers/partition/partition.c
index 1881c91b38..f6ca9ee716 100644
--- a/drivers/partition/partition.c
+++ b/drivers/partition/partition.c
@@ -266,12 +266,16 @@ const partition_entry_t *get_partition_entry(const char *name)
 	return NULL;
 }
 
-const partition_entry_t *get_partition_entry_by_type(const uuid_t *type_uuid)
+/*
+ * Try retrieving a partition table entry based on the partition type GUID.
+ */
+const partition_entry_t *get_partition_entry_by_type(
+	const struct efi_guid *type_guid)
 {
 	int i;
 
 	for (i = 0; i < list.entry_count; i++) {
-		if (guidcmp(type_uuid, &list.list[i].type_guid) == 0) {
+		if (guidcmp(type_guid, &list.list[i].type_guid) == 0) {
 			return &list.list[i];
 		}
 	}
@@ -279,12 +283,16 @@ const partition_entry_t *get_partition_entry_by_type(const uuid_t *type_uuid)
 	return NULL;
 }
 
-const partition_entry_t *get_partition_entry_by_uuid(const uuid_t *part_uuid)
+/*
+ * Try retrieving a partition table entry based on the unique partition GUID.
+ */
+const partition_entry_t *get_partition_entry_by_guid(
+	const struct efi_guid *part_guid)
 {
 	int i;
 
 	for (i = 0; i < list.entry_count; i++) {
-		if (guidcmp(part_uuid, &list.list[i].part_guid) == 0) {
+		if (guidcmp(part_guid, &list.list[i].part_guid) == 0) {
 			return &list.list[i];
 		}
 	}
diff --git a/drivers/renesas/common/emmc/emmc_cmd.c b/drivers/renesas/common/emmc/emmc_cmd.c
index d255bffc9f..02fc26bba9 100644
--- a/drivers/renesas/common/emmc/emmc_cmd.c
+++ b/drivers/renesas/common/emmc/emmc_cmd.c
@@ -254,8 +254,7 @@ EMMC_ERROR_CODE emmc_exec_cmd(uint32_t error_mask, uint32_t *response)
 				(SD_INFO2_ALL_ERR | SD_INFO2_CLEAR));
 
 			state = ESTATE_ISSUE_CMD;
-			/* through */
-
+			/* fallthrough */
 		case ESTATE_ISSUE_CMD:
 			/* ARG */
 			SETR_32(SD_ARG, mmc_drv_obj.cmd_info.arg);
@@ -454,8 +453,8 @@ EMMC_ERROR_CODE emmc_exec_cmd(uint32_t error_mask, uint32_t *response)
 				SETR_32(SD_STOP, 0x00000000U);
 				mmc_drv_obj.during_dma_transfer = FALSE;
 			}
-			/* through */
 
+			/* fallthrough */
 		case ESTATE_ERROR:
 			if (err_not_care_flag == TRUE) {
 				mmc_drv_obj.during_cmd_processing = FALSE;
diff --git a/drivers/renesas/common/rom/rom_api.c b/drivers/renesas/common/rom/rom_api.c
index fda28150e9..4eede17ce9 100644
--- a/drivers/renesas/common/rom/rom_api.c
+++ b/drivers/renesas/common/rom/rom_api.c
@@ -11,7 +11,7 @@
 #include "rcar_def.h"
 #include "rom_api.h"
 
-typedef uint32_t(*rom_secure_boot_api_f) (uint32_t *key, uint32_t *cert,
+typedef uint32_t(*rom_secure_boot_api_f) (uint32_t key, uint32_t cert,
 					  rom_read_flash_f pFuncReadFlash);
 
 typedef uint32_t(*rom_get_lcs_api_f) (uint32_t *lcs);
@@ -68,7 +68,7 @@ static uint32_t get_table_index(void)
 	return index;
 }
 
-uint32_t rcar_rom_secure_boot_api(uint32_t *key, uint32_t *cert,
+uint32_t rcar_rom_secure_boot_api(uint32_t key, uint32_t cert,
 			     rom_read_flash_f read_flash)
 {
 	static const uintptr_t rom_api_table[API_TABLE_MAX] = {
diff --git a/drivers/renesas/common/rom/rom_api.h b/drivers/renesas/common/rom/rom_api.h
index 1d5b03d7f5..4b1008032e 100644
--- a/drivers/renesas/common/rom/rom_api.h
+++ b/drivers/renesas/common/rom/rom_api.h
@@ -24,7 +24,7 @@
 #define LCS_FA					(0x7U)
 
 typedef uint32_t(*rom_read_flash_f) (uint64_t src, uint8_t *dst, uint32_t len);
-uint32_t rcar_rom_secure_boot_api(uint32_t *key, uint32_t *cert,
+uint32_t rcar_rom_secure_boot_api(uint32_t key, uint32_t cert,
 				  rom_read_flash_f f);
 uint32_t rcar_rom_get_lcs(uint32_t *lcs);
 
diff --git a/drivers/st/bsec/bsec2.c b/drivers/st/bsec/bsec2.c
index 68d3a5b896..14df63c134 100644
--- a/drivers/st/bsec/bsec2.c
+++ b/drivers/st/bsec/bsec2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -21,15 +21,26 @@
 #define BSEC_IP_VERSION_2_0	U(0x20)
 #define BSEC_IP_ID_2		U(0x100032)
 
+/*
+ * IP configuration
+ */
+#define BSEC_OTP_MASK			GENMASK(4, 0)
+#define BSEC_OTP_BANK_SHIFT		5
+#define BSEC_TIMEOUT_VALUE		U(0xFFFF)
+
 #define OTP_ACCESS_SIZE (round_up(OTP_MAX_SIZE, __WORD_BIT) / __WORD_BIT)
 
 static uint32_t otp_nsec_access[OTP_ACCESS_SIZE] __unused;
 
+static uint32_t bsec_shadow_register(uint32_t otp);
 static uint32_t bsec_power_safmem(bool power);
+static uint32_t bsec_get_version(void);
+static uint32_t bsec_get_id(void);
+static uint32_t bsec_get_status(void);
+static uint32_t bsec_read_permanent_lock(uint32_t otp, bool *value);
 
 /* BSEC access protection */
 static spinlock_t bsec_spinlock;
-static uintptr_t bsec_base;
 
 static void bsec_lock(void)
 {
@@ -47,7 +58,7 @@ static void bsec_unlock(void)
 
 static bool is_otp_invalid_mode(void)
 {
-	bool ret = ((bsec_get_status() & BSEC_MODE_INVALID) == BSEC_MODE_INVALID);
+	bool ret = ((bsec_get_status() & BSEC_OTP_STATUS_INVALID) == BSEC_OTP_STATUS_INVALID);
 
 	if (ret) {
 		ERROR("OTP mode is OTP-INVALID\n");
@@ -155,15 +166,17 @@ static void bsec_late_init(void)
 	struct dt_node_info bsec_info;
 
 	if (fdt_get_address(&fdt) == 0) {
+		EARLY_ERROR("%s: DT not found\n", __func__);
 		panic();
 	}
 
 	node = bsec_get_dt_node(&bsec_info);
 	if (node < 0) {
+		EARLY_ERROR("%s: BSEC node not found\n", __func__);
 		panic();
 	}
 
-	assert(bsec_base == bsec_info.base);
+	assert(bsec_info.base == BSEC_BASE);
 
 	bsec_dt_otp_nsec_access(fdt, node);
 }
@@ -177,6 +190,11 @@ static uint32_t otp_bank_offset(uint32_t otp)
 	       sizeof(uint32_t);
 }
 
+static uint32_t otp_bit_mask(uint32_t otp)
+{
+	return BIT(otp & BSEC_OTP_MASK);
+}
+
 /*
  * bsec_check_error: check BSEC error status.
  * otp: OTP number.
@@ -186,10 +204,10 @@ static uint32_t otp_bank_offset(uint32_t otp)
  */
 static uint32_t bsec_check_error(uint32_t otp, bool check_disturbed)
 {
-	uint32_t bit = BIT(otp & BSEC_OTP_MASK);
+	uint32_t bit = otp_bit_mask(otp);
 	uint32_t bank = otp_bank_offset(otp);
 
-	if ((mmio_read_32(bsec_base + BSEC_ERROR_OFF + bank) & bit) != 0U) {
+	if ((mmio_read_32(BSEC_BASE + BSEC_ERROR_OFF + bank) & bit) != 0U) {
 		return BSEC_ERROR;
 	}
 
@@ -197,7 +215,7 @@ static uint32_t bsec_check_error(uint32_t otp, bool check_disturbed)
 		return BSEC_OK;
 	}
 
-	if ((mmio_read_32(bsec_base + BSEC_DISTURBED_OFF + bank) & bit) != 0U) {
+	if ((mmio_read_32(BSEC_BASE + BSEC_DISTURBED_OFF + bank) & bit) != 0U) {
 		return BSEC_DISTURBED;
 	}
 
@@ -210,15 +228,21 @@ static uint32_t bsec_check_error(uint32_t otp, bool check_disturbed)
  */
 uint32_t bsec_probe(void)
 {
-	bsec_base = BSEC_BASE;
+	uint32_t version;
+	uint32_t id;
 
 	if (is_otp_invalid_mode()) {
+		EARLY_ERROR("%s: otp_invalid_mod\n", __func__);
 		return BSEC_ERROR;
 	}
 
-	if ((((bsec_get_version() & BSEC_IPVR_MSK) != BSEC_IP_VERSION_1_1) &&
-	     ((bsec_get_version() & BSEC_IPVR_MSK) != BSEC_IP_VERSION_2_0)) ||
-	    (bsec_get_id() != BSEC_IP_ID_2)) {
+	version = bsec_get_version();
+	id = bsec_get_id();
+
+	if (((version != BSEC_IP_VERSION_1_1) &&
+	     (version != BSEC_IP_VERSION_2_0)) ||
+	    (id != BSEC_IP_ID_2)) {
+		EARLY_ERROR("%s: version = 0x%x, id = 0x%x\n", __func__, version, id);
 		panic();
 	}
 
@@ -228,103 +252,12 @@ uint32_t bsec_probe(void)
 	return BSEC_OK;
 }
 
-/*
- * bsec_get_base: return BSEC base address.
- */
-uint32_t bsec_get_base(void)
-{
-	return bsec_base;
-}
-
-/*
- * bsec_set_config: enable and configure BSEC.
- * cfg: pointer to param structure used to set register.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_set_config(struct bsec_config *cfg)
-{
-	uint32_t value;
-	uint32_t result;
-
-	if (is_otp_invalid_mode()) {
-		return BSEC_ERROR;
-	}
-
-	value = ((((uint32_t)cfg->freq << BSEC_CONF_FRQ_SHIFT) &
-						BSEC_CONF_FRQ_MASK) |
-		 (((uint32_t)cfg->pulse_width << BSEC_CONF_PRG_WIDTH_SHIFT) &
-						BSEC_CONF_PRG_WIDTH_MASK) |
-		 (((uint32_t)cfg->tread << BSEC_CONF_TREAD_SHIFT) &
-						BSEC_CONF_TREAD_MASK));
-
-	bsec_lock();
-
-	mmio_write_32(bsec_base + BSEC_OTP_CONF_OFF, value);
-
-	bsec_unlock();
-
-	result = bsec_power_safmem((bool)cfg->power &
-				   BSEC_CONF_POWER_UP_MASK);
-	if (result != BSEC_OK) {
-		return result;
-	}
-
-	value = ((((uint32_t)cfg->upper_otp_lock << UPPER_OTP_LOCK_SHIFT) &
-						UPPER_OTP_LOCK_MASK) |
-		 (((uint32_t)cfg->den_lock << DENREG_LOCK_SHIFT) &
-						DENREG_LOCK_MASK) |
-		 (((uint32_t)cfg->prog_lock << GPLOCK_LOCK_SHIFT) &
-						GPLOCK_LOCK_MASK));
-
-	bsec_lock();
-
-	mmio_write_32(bsec_base + BSEC_OTP_LOCK_OFF, value);
-
-	bsec_unlock();
-
-	return BSEC_OK;
-}
-
-/*
- * bsec_get_config: return config parameters set in BSEC registers.
- * cfg: config param return.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_get_config(struct bsec_config *cfg)
-{
-	uint32_t value;
-
-	if (cfg == NULL) {
-		return BSEC_INVALID_PARAM;
-	}
-
-	value = mmio_read_32(bsec_base + BSEC_OTP_CONF_OFF);
-	cfg->power = (uint8_t)((value & BSEC_CONF_POWER_UP_MASK) >>
-						BSEC_CONF_POWER_UP_SHIFT);
-	cfg->freq = (uint8_t)((value & BSEC_CONF_FRQ_MASK) >>
-						BSEC_CONF_FRQ_SHIFT);
-	cfg->pulse_width = (uint8_t)((value & BSEC_CONF_PRG_WIDTH_MASK) >>
-						BSEC_CONF_PRG_WIDTH_SHIFT);
-	cfg->tread = (uint8_t)((value & BSEC_CONF_TREAD_MASK) >>
-						BSEC_CONF_TREAD_SHIFT);
-
-	value = mmio_read_32(bsec_base + BSEC_OTP_LOCK_OFF);
-	cfg->upper_otp_lock = (uint8_t)((value & UPPER_OTP_LOCK_MASK) >>
-						UPPER_OTP_LOCK_SHIFT);
-	cfg->den_lock = (uint8_t)((value & DENREG_LOCK_MASK) >>
-						DENREG_LOCK_SHIFT);
-	cfg->prog_lock = (uint8_t)((value & GPLOCK_LOCK_MASK) >>
-						GPLOCK_LOCK_SHIFT);
-
-	return BSEC_OK;
-}
-
 /*
  * bsec_shadow_register: copy SAFMEM OTP to BSEC data.
  * otp: OTP number.
  * return value: BSEC_OK if no error.
  */
-uint32_t bsec_shadow_register(uint32_t otp)
+static uint32_t bsec_shadow_register(uint32_t otp)
 {
 	uint32_t result;
 	bool value;
@@ -345,7 +278,7 @@ uint32_t bsec_shadow_register(uint32_t otp)
 			otp);
 	}
 
-	if ((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) {
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) {
 		result = bsec_power_safmem(true);
 
 		if (result != BSEC_OK) {
@@ -357,9 +290,9 @@ uint32_t bsec_shadow_register(uint32_t otp)
 
 	bsec_lock();
 
-	mmio_write_32(bsec_base + BSEC_OTP_CTRL_OFF, otp | BSEC_READ);
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CTRL_OFF, otp | BSEC_READ);
 
-	while ((bsec_get_status() & BSEC_MODE_BUSY_MASK) != 0U) {
+	while ((bsec_get_status() & BSEC_OTP_STATUS_BUSY) != 0U) {
 		;
 	}
 
@@ -392,7 +325,7 @@ uint32_t bsec_read_otp(uint32_t *val, uint32_t otp)
 		return BSEC_INVALID_PARAM;
 	}
 
-	*val = mmio_read_32(bsec_base + BSEC_OTP_DATA_OFF +
+	*val = mmio_read_32(BSEC_BASE + BSEC_OTP_DATA_OFF +
 			    (otp * sizeof(uint32_t)));
 
 	return BSEC_OK;
@@ -427,7 +360,7 @@ uint32_t bsec_write_otp(uint32_t val, uint32_t otp)
 	/* Ensure integrity of each register access sequence */
 	bsec_lock();
 
-	mmio_write_32(bsec_base + BSEC_OTP_DATA_OFF +
+	mmio_write_32(BSEC_BASE + BSEC_OTP_DATA_OFF +
 		      (otp * sizeof(uint32_t)), val);
 
 	bsec_unlock();
@@ -470,12 +403,11 @@ uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
 		return BSEC_PROG_FAIL;
 	}
 
-	if ((mmio_read_32(bsec_base + BSEC_OTP_LOCK_OFF) &
-	     BIT(BSEC_LOCK_PROGRAM)) != 0U) {
+	if ((mmio_read_32(BSEC_BASE + BSEC_OTP_LOCK_OFF) & GPLOCK_LOCK_MASK) != 0U) {
 		WARN("BSEC: GPLOCK activated, prog will be ignored\n");
 	}
 
-	if ((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) {
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) {
 		result = bsec_power_safmem(true);
 
 		if (result != BSEC_OK) {
@@ -487,15 +419,15 @@ uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
 
 	bsec_lock();
 
-	mmio_write_32(bsec_base + BSEC_OTP_WRDATA_OFF, val);
+	mmio_write_32(BSEC_BASE + BSEC_OTP_WRDATA_OFF, val);
 
-	mmio_write_32(bsec_base + BSEC_OTP_CTRL_OFF, otp | BSEC_WRITE);
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CTRL_OFF, otp | BSEC_WRITE);
 
-	while ((bsec_get_status() & BSEC_MODE_BUSY_MASK) != 0U) {
+	while ((bsec_get_status() & BSEC_OTP_STATUS_BUSY) != 0U) {
 		;
 	}
 
-	if ((bsec_get_status() & BSEC_MODE_PROGFAIL_MASK) != 0U) {
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PROGFAIL) != 0U) {
 		result = BSEC_PROG_FAIL;
 	} else {
 		result = bsec_check_error(otp, true);
@@ -517,6 +449,7 @@ uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
  * otp: OTP number.
  * return value: BSEC_OK if no error.
  */
+#if defined(IMAGE_BL32) || defined(STM32MP_SSP)
 uint32_t bsec_permanent_lock_otp(uint32_t otp)
 {
 	uint32_t result;
@@ -532,7 +465,7 @@ uint32_t bsec_permanent_lock_otp(uint32_t otp)
 		return BSEC_INVALID_PARAM;
 	}
 
-	if ((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) {
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) {
 		result = bsec_power_safmem(true);
 
 		if (result != BSEC_OK) {
@@ -554,16 +487,16 @@ uint32_t bsec_permanent_lock_otp(uint32_t otp)
 
 	bsec_lock();
 
-	mmio_write_32(bsec_base + BSEC_OTP_WRDATA_OFF, data);
+	mmio_write_32(BSEC_BASE + BSEC_OTP_WRDATA_OFF, data);
 
-	mmio_write_32(bsec_base + BSEC_OTP_CTRL_OFF,
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CTRL_OFF,
 		      addr | BSEC_WRITE | BSEC_LOCK);
 
-	while ((bsec_get_status() & BSEC_MODE_BUSY_MASK) != 0U) {
+	while ((bsec_get_status() & BSEC_OTP_STATUS_BUSY) != 0U) {
 		;
 	}
 
-	if ((bsec_get_status() & BSEC_MODE_PROGFAIL_MASK) != 0U) {
+	if ((bsec_get_status() & BSEC_OTP_STATUS_PROGFAIL) != 0U) {
 		result = BSEC_PROG_FAIL;
 	} else {
 		result = bsec_check_error(otp, false);
@@ -579,30 +512,14 @@ uint32_t bsec_permanent_lock_otp(uint32_t otp)
 
 	return result;
 }
-
-/*
- * bsec_write_debug_conf: write value in debug feature.
- *	to enable/disable debug service.
- * val: value to write.
- * return value: none.
- */
-void bsec_write_debug_conf(uint32_t val)
-{
-	if (is_otp_invalid_mode()) {
-		return;
-	}
-
-	bsec_lock();
-	mmio_write_32(bsec_base + BSEC_DEN_OFF, val & BSEC_DEN_ALL_MSK);
-	bsec_unlock();
-}
+#endif
 
 /*
  * bsec_read_debug_conf: return debug configuration register value.
  */
 uint32_t bsec_read_debug_conf(void)
 {
-	return mmio_read_32(bsec_base + BSEC_DEN_OFF);
+	return mmio_read_32(BSEC_BASE + BSEC_DEN_OFF);
 }
 
 /*
@@ -618,59 +535,35 @@ void bsec_write_scratch(uint32_t val)
 	}
 
 	bsec_lock();
-	mmio_write_32(bsec_base + BSEC_SCRATCH_OFF, val);
+	mmio_write_32(BSEC_BASE + BSEC_SCRATCH_OFF, val);
 	bsec_unlock();
 #else
 	mmio_write_32(BSEC_BASE + BSEC_SCRATCH_OFF, val);
 #endif
 }
 
-/*
- * bsec_read_scratch: return scratch register value.
- */
-uint32_t bsec_read_scratch(void)
-{
-	return mmio_read_32(bsec_base + BSEC_SCRATCH_OFF);
-}
-
 /*
  * bsec_get_status: return status register value.
  */
-uint32_t bsec_get_status(void)
-{
-	return mmio_read_32(bsec_base + BSEC_OTP_STATUS_OFF);
-}
-
-/*
- * bsec_get_hw_conf: return hardware configuration register value.
- */
-uint32_t bsec_get_hw_conf(void)
+static uint32_t bsec_get_status(void)
 {
-	return mmio_read_32(bsec_base + BSEC_IPHW_CFG_OFF);
+	return mmio_read_32(BSEC_BASE + BSEC_OTP_STATUS_OFF);
 }
 
 /*
  * bsec_get_version: return BSEC version register value.
  */
-uint32_t bsec_get_version(void)
+static uint32_t bsec_get_version(void)
 {
-	return mmio_read_32(bsec_base + BSEC_IPVR_OFF);
+	return mmio_read_32(BSEC_BASE + BSEC_IPVR_OFF) & BSEC_IPVR_MSK;
 }
 
 /*
  * bsec_get_id: return BSEC ID register value.
  */
-uint32_t bsec_get_id(void)
-{
-	return mmio_read_32(bsec_base + BSEC_IP_ID_OFF);
-}
-
-/*
- * bsec_get_magic_id: return BSEC magic number register value.
- */
-uint32_t bsec_get_magic_id(void)
+static uint32_t bsec_get_id(void)
 {
-	return mmio_read_32(bsec_base + BSEC_IP_MAGIC_ID_OFF);
+	return mmio_read_32(BSEC_BASE + BSEC_IP_ID_OFF);
 }
 
 /*
@@ -681,7 +574,7 @@ uint32_t bsec_get_magic_id(void)
 uint32_t bsec_set_sr_lock(uint32_t otp)
 {
 	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t otp_mask = otp_bit_mask(otp);
 
 	if (is_otp_invalid_mode()) {
 		return BSEC_ERROR;
@@ -692,7 +585,7 @@ uint32_t bsec_set_sr_lock(uint32_t otp)
 	}
 
 	bsec_lock();
-	mmio_write_32(bsec_base + BSEC_SRLOCK_OFF + bank, otp_mask);
+	mmio_write_32(BSEC_BASE + BSEC_SRLOCK_OFF + bank, otp_mask);
 	bsec_unlock();
 
 	return BSEC_OK;
@@ -707,14 +600,14 @@ uint32_t bsec_set_sr_lock(uint32_t otp)
 uint32_t bsec_read_sr_lock(uint32_t otp, bool *value)
 {
 	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t otp_mask = otp_bit_mask(otp);
 	uint32_t bank_value;
 
 	if (otp > STM32MP1_OTP_MAX_ID) {
 		return BSEC_INVALID_PARAM;
 	}
 
-	bank_value = mmio_read_32(bsec_base + BSEC_SRLOCK_OFF + bank);
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SRLOCK_OFF + bank);
 
 	*value = ((bank_value & otp_mask) != 0U);
 
@@ -729,7 +622,7 @@ uint32_t bsec_read_sr_lock(uint32_t otp, bool *value)
 uint32_t bsec_set_sw_lock(uint32_t otp)
 {
 	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t otp_mask = otp_bit_mask(otp);
 
 	if (is_otp_invalid_mode()) {
 		return BSEC_ERROR;
@@ -740,7 +633,7 @@ uint32_t bsec_set_sw_lock(uint32_t otp)
 	}
 
 	bsec_lock();
-	mmio_write_32(bsec_base + BSEC_SWLOCK_OFF + bank, otp_mask);
+	mmio_write_32(BSEC_BASE + BSEC_SWLOCK_OFF + bank, otp_mask);
 	bsec_unlock();
 
 	return BSEC_OK;
@@ -762,7 +655,7 @@ uint32_t bsec_read_sw_lock(uint32_t otp, bool *value)
 		return BSEC_INVALID_PARAM;
 	}
 
-	bank_value = mmio_read_32(bsec_base + BSEC_SWLOCK_OFF + bank);
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SWLOCK_OFF + bank);
 
 	*value = ((bank_value & otp_mask) != 0U);
 
@@ -777,7 +670,7 @@ uint32_t bsec_read_sw_lock(uint32_t otp, bool *value)
 uint32_t bsec_set_sp_lock(uint32_t otp)
 {
 	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t otp_mask = otp_bit_mask(otp);
 
 	if (is_otp_invalid_mode()) {
 		return BSEC_ERROR;
@@ -788,7 +681,7 @@ uint32_t bsec_set_sp_lock(uint32_t otp)
 	}
 
 	bsec_lock();
-	mmio_write_32(bsec_base + BSEC_SPLOCK_OFF + bank, otp_mask);
+	mmio_write_32(BSEC_BASE + BSEC_SPLOCK_OFF + bank, otp_mask);
 	bsec_unlock();
 
 	return BSEC_OK;
@@ -810,7 +703,7 @@ uint32_t bsec_read_sp_lock(uint32_t otp, bool *value)
 		return BSEC_INVALID_PARAM;
 	}
 
-	bank_value = mmio_read_32(bsec_base + BSEC_SPLOCK_OFF + bank);
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SPLOCK_OFF + bank);
 
 	*value = ((bank_value & otp_mask) != 0U);
 
@@ -823,53 +716,23 @@ uint32_t bsec_read_sp_lock(uint32_t otp, bool *value)
  * value: read value (true or false).
  * return value: BSEC_OK if no error.
  */
-uint32_t bsec_read_permanent_lock(uint32_t otp, bool *value)
+static uint32_t bsec_read_permanent_lock(uint32_t otp, bool *value)
 {
 	uint32_t bank = otp_bank_offset(otp);
-	uint32_t otp_mask = BIT(otp & BSEC_OTP_MASK);
+	uint32_t otp_mask = otp_bit_mask(otp);
 	uint32_t bank_value;
 
 	if (otp > STM32MP1_OTP_MAX_ID) {
 		return BSEC_INVALID_PARAM;
 	}
 
-	bank_value = mmio_read_32(bsec_base + BSEC_WRLOCK_OFF + bank);
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_WRLOCK_OFF + bank);
 
 	*value = ((bank_value & otp_mask) != 0U);
 
 	return BSEC_OK;
 }
 
-/*
- * bsec_otp_lock: Lock Upper OTP or Global Programming or Debug Enable.
- * service: Service to lock, see header file.
- * return value: BSEC_OK if no error.
- */
-uint32_t bsec_otp_lock(uint32_t service)
-{
-	uintptr_t reg = bsec_base + BSEC_OTP_LOCK_OFF;
-
-	if (is_otp_invalid_mode()) {
-		return BSEC_ERROR;
-	}
-
-	switch (service) {
-	case BSEC_LOCK_UPPER_OTP:
-		mmio_write_32(reg, BIT(BSEC_LOCK_UPPER_OTP));
-		break;
-	case BSEC_LOCK_DEBUG:
-		mmio_write_32(reg, BIT(BSEC_LOCK_DEBUG));
-		break;
-	case BSEC_LOCK_PROGRAM:
-		mmio_write_32(reg, BIT(BSEC_LOCK_PROGRAM));
-		break;
-	default:
-		return BSEC_INVALID_PARAM;
-	}
-
-	return BSEC_OK;
-}
-
 /*
  * bsec_power_safmem: Activate or deactivate SAFMEM power.
  * power: true to power up, false to power down.
@@ -882,7 +745,7 @@ static uint32_t bsec_power_safmem(bool power)
 
 	bsec_lock();
 
-	register_val = mmio_read_32(bsec_base + BSEC_OTP_CONF_OFF);
+	register_val = mmio_read_32(BSEC_BASE + BSEC_OTP_CONF_OFF);
 
 	if (power) {
 		register_val |= BSEC_CONF_POWER_UP_MASK;
@@ -890,15 +753,15 @@ static uint32_t bsec_power_safmem(bool power)
 		register_val &= ~BSEC_CONF_POWER_UP_MASK;
 	}
 
-	mmio_write_32(bsec_base + BSEC_OTP_CONF_OFF, register_val);
+	mmio_write_32(BSEC_BASE + BSEC_OTP_CONF_OFF, register_val);
 
 	if (power) {
-		while (((bsec_get_status() & BSEC_MODE_PWR_MASK) == 0U) &&
+		while (((bsec_get_status() & BSEC_OTP_STATUS_PWRON) == 0U) &&
 		       (timeout != 0U)) {
 			timeout--;
 		}
 	} else {
-		while (((bsec_get_status() & BSEC_MODE_PWR_MASK) != 0U) &&
+		while (((bsec_get_status() & BSEC_OTP_STATUS_PWRON) != 0U) &&
 		       (timeout != 0U)) {
 			timeout--;
 		}
@@ -915,28 +778,29 @@ static uint32_t bsec_power_safmem(bool power)
 
 /*
  * bsec_shadow_read_otp: Load OTP from SAFMEM and provide its value.
- * otp_value: read value.
- * word: OTP number.
+ * val: read value.
+ * otp: OTP number.
  * return value: BSEC_OK if no error.
  */
-uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word)
+uint32_t bsec_shadow_read_otp(uint32_t *val, uint32_t otp)
 {
 	uint32_t result;
 
-	result = bsec_shadow_register(word);
+	result = bsec_shadow_register(otp);
 	if (result != BSEC_OK) {
-		ERROR("BSEC: %u Shadowing Error %u\n", word, result);
+		ERROR("BSEC: %u Shadowing Error %u\n", otp, result);
 		return result;
 	}
 
-	result = bsec_read_otp(otp_value, word);
+	result = bsec_read_otp(val, otp);
 	if (result != BSEC_OK) {
-		ERROR("BSEC: %u Read Error %u\n", word, result);
+		ERROR("BSEC: %u Read Error %u\n", otp, result);
 	}
 
 	return result;
 }
 
+#if defined(IMAGE_BL32)
 /*
  * bsec_check_nsec_access_rights: check non-secure access rights to target OTP.
  * otp: OTP number.
@@ -944,7 +808,6 @@ uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word)
  */
 uint32_t bsec_check_nsec_access_rights(uint32_t otp)
 {
-#if defined(IMAGE_BL32)
 	if (otp > STM32MP1_OTP_MAX_ID) {
 		return BSEC_INVALID_PARAM;
 	}
@@ -954,8 +817,57 @@ uint32_t bsec_check_nsec_access_rights(uint32_t otp)
 			return BSEC_ERROR;
 		}
 	}
-#endif
 
 	return BSEC_OK;
 }
+#endif
+
+uint32_t bsec_get_secure_state(void)
+{
+	uint32_t status = bsec_get_status();
+	uint32_t result = BSEC_STATE_INVALID;
+	uint32_t otp_enc_id __unused;
+	uint32_t otp_bit_len __unused;
+	int res __unused;
 
+	if ((status & BSEC_OTP_STATUS_INVALID) != 0U) {
+		result = BSEC_STATE_INVALID;
+	} else {
+		if ((status & BSEC_OTP_STATUS_SECURE) != 0U) {
+			if (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) {
+				result = BSEC_STATE_SEC_CLOSED;
+			} else {
+				result = BSEC_STATE_SEC_OPEN;
+			}
+		} else {
+			/* OTP modes OPEN1 and OPEN2 are not supported */
+			result = BSEC_STATE_INVALID;
+		}
+	}
+
+#if STM32MP13
+	res = stm32_get_otp_index(ENCKEY_OTP, &otp_enc_id, &otp_bit_len);
+	if ((res == 0) && (otp_bit_len > 0)) {
+		uint32_t start = otp_enc_id / sizeof(uint32_t);
+		size_t otp_nb = round_up(otp_bit_len, sizeof(uint32_t)) /
+				sizeof(uint32_t);
+		size_t otp_locked_nb = 0U;
+		uint32_t idx;
+
+		for (idx = start; idx < start + otp_nb; idx++) {
+			bool locked = false;
+
+			res = bsec_read_sp_lock(idx, &locked);
+			if ((res != 0U) || (locked == 0U)) {
+				break;
+			}
+			otp_locked_nb++;
+		}
+		if (otp_locked_nb == otp_nb) {
+			result |= BSEC_HARDWARE_KEY;
+		}
+	}
+#endif
+
+	return result;
+}
diff --git a/drivers/st/bsec/bsec3.c b/drivers/st/bsec/bsec3.c
new file mode 100644
index 0000000000..fba1d82251
--- /dev/null
+++ b/drivers/st/bsec/bsec3.c
@@ -0,0 +1,546 @@
+/*
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <limits.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/bsec3_reg.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+
+#define BSEC_IP_VERSION_1_0	U(0x10)
+#define BSEC_IP_ID_3		U(0x100033)
+
+#define MAX_NB_TRIES		3U
+
+#define BSEC_DENR_KEY		0xDEB60000
+
+/*
+ * IP configuration
+ */
+#define BSEC_OTP_MASK			GENMASK(4, 0)
+#define BSEC_OTP_BANK_SHIFT		5
+#define BSEC_TIMEOUT_VALUE		0xFFFFFFFFU
+
+/* Magic use to indicated valid SHADOW = 'B' 'S' 'E' 'C' */
+#define BSEC_MAGIC			0x42534543U
+
+#define OTP_MAX_SIZE			(STM32MP2_OTP_MAX_ID + 1U)
+
+struct bsec_shadow {
+	uint32_t magic;
+	uint32_t state;
+	uint32_t value[OTP_MAX_SIZE];
+	uint32_t status[OTP_MAX_SIZE];
+};
+
+static uint32_t otp_bank(uint32_t otp)
+{
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return (otp & ~BSEC_OTP_MASK) >> BSEC_OTP_BANK_SHIFT;
+}
+
+static uint32_t otp_bit_mask(uint32_t otp)
+{
+	return BIT(otp & BSEC_OTP_MASK);
+}
+
+/*
+ * bsec_get_status: return status register value.
+ */
+static uint32_t bsec_get_status(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_OTPSR);
+}
+
+/*
+ * bsec_get_version: return BSEC version.
+ */
+static uint32_t bsec_get_version(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_VERR) & BSEC_VERR_MASK;
+}
+
+/*
+ * bsec_get_id: return BSEC ID.
+ */
+static uint32_t bsec_get_id(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_IPIDR);
+}
+
+static bool is_fuse_shadowed(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+	uint32_t bank_value;
+
+	bank_value = mmio_read_32(BSEC_BASE + BSEC_SFSR(bank));
+
+	if ((bank_value & otp_mask) != 0U) {
+		return true;
+	}
+
+	return false;
+}
+
+static void poll_otp_status_busy(void)
+{
+	int32_t timeout = BSEC_TIMEOUT_VALUE;
+
+	while (((bsec_get_status() & BSEC_OTPSR_BUSY) != 0U) && (timeout != 0U)) {
+		timeout--;
+	}
+
+	if ((bsec_get_status() & BSEC_OTPSR_BUSY) != 0U) {
+		ERROR("BSEC timeout\n");
+		panic();
+	}
+}
+
+static uint32_t check_read_error(uint32_t otp)
+{
+	uint32_t status = bsec_get_status();
+
+	if ((status & BSEC_OTPSR_SECF) != 0U) {
+		VERBOSE("BSEC read %u single error correction detected\n", otp);
+	}
+
+	if ((status & BSEC_OTPSR_PPLF) != 0U) {
+		VERBOSE("BSEC read %u permanent programming lock detected.\n", otp);
+	}
+
+	if ((status & BSEC_OTPSR_PPLMF) != 0U) {
+		ERROR("BSEC read %u error 0x%x\n", otp, status);
+		return BSEC_ERROR;
+	}
+
+	if ((status & (BSEC_OTPSR_DISTURBF | BSEC_OTPSR_DEDF | BSEC_OTPSR_AMEF)) != 0U) {
+		ERROR("BSEC read %u error 0x%x with invalid FVR\n", otp, status);
+		return BSEC_RETRY;
+	}
+
+	return BSEC_OK;
+}
+
+static uint32_t check_program_error(uint32_t otp)
+{
+	uint32_t status = bsec_get_status();
+
+	if ((status & BSEC_OTPSR_PROGFAIL) != 0U) {
+		ERROR("BSEC program %u error 0x%x\n", otp, status);
+		return BSEC_RETRY;
+	}
+
+	return BSEC_OK;
+}
+
+static void check_reset_error(void)
+{
+	uint32_t status = bsec_get_status();
+
+	/* check initial status reporting */
+	if ((status & BSEC_OTPSR_BUSY) != 0U) {
+		VERBOSE("BSEC reset and busy when OTPSR read\n");
+	}
+	if ((status & BSEC_OTPSR_HIDEUP) != 0U) {
+		VERBOSE("BSEC upper fuse are not accessible (HIDEUP)\n");
+	}
+	if ((status & BSEC_OTPSR_OTPSEC) != 0U) {
+		VERBOSE("BSEC reset single error correction detected\n");
+	}
+	if ((status & BSEC_OTPSR_OTPNVIR) == 0U) {
+		VERBOSE("BSEC reset first fuse word 0 is detected zero\n");
+	}
+	if ((status & BSEC_OTPSR_OTPERR) != 0U) {
+		ERROR("BSEC reset critical error 0x%x\n", status);
+		panic();
+	}
+	if ((status & BSEC_OTPSR_INIT_DONE) != BSEC_OTPSR_INIT_DONE) {
+		ERROR("BSEC reset critical error 0x%x\n", status);
+		panic();
+	}
+}
+
+static bool is_bsec_write_locked(void)
+{
+	return (mmio_read_32(BSEC_BASE + BSEC_LOCKR) & BSEC_LOCKR_GWLOCK_MASK) != 0U;
+}
+
+/*
+ * bsec_probe: initialize BSEC driver.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_probe(void)
+{
+	uint32_t version = bsec_get_version();
+	uint32_t id = bsec_get_id();
+
+	if ((version != BSEC_IP_VERSION_1_0) || (id != BSEC_IP_ID_3)) {
+		EARLY_ERROR("%s: version = 0x%x, id = 0x%x\n", __func__, version, id);
+		panic();
+	}
+
+	check_reset_error();
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_shadow_register: copy SAFMEM OTP to BSEC data.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+static uint32_t bsec_shadow_register(uint32_t otp)
+{
+	uint32_t result;
+	uint32_t i;
+	bool value;
+
+	result = bsec_read_sr_lock(otp, &value);
+	if (result != BSEC_OK) {
+		WARN("BSEC: %u Sticky-read bit read Error %u\n", otp, result);
+	} else if (value) {
+		VERBOSE("BSEC: OTP %u is locked and will not be refreshed\n", otp);
+	}
+
+	for (i = 0U; i < MAX_NB_TRIES; i++) {
+		mmio_write_32(BSEC_BASE + BSEC_OTPCR, otp);
+
+		poll_otp_status_busy();
+
+		result = check_read_error(otp);
+		if (result != BSEC_RETRY) {
+			break;
+		}
+	}
+
+	return result;
+}
+
+/*
+ * bsec_write_otp: write a value in shadow OTP.
+ * val: value to program.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_write_otp(uint32_t val, uint32_t otp)
+{
+	bool state;
+	uint32_t result;
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	if (!is_fuse_shadowed(otp)) {
+		return BSEC_ERROR;
+	}
+
+	if (is_bsec_write_locked()) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	result = bsec_read_sw_lock(otp, &state);
+	if (result != BSEC_OK) {
+		WARN("Shadow register is SW locked\n");
+		return result;
+	}
+
+	mmio_write_32(BSEC_BASE + BSEC_FVR(otp), val);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_program_otp: program a bit in SAFMEM after the prog.
+ *	The OTP data is not refreshed.
+ * val: value to program.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_program_otp(uint32_t val, uint32_t otp)
+{
+	uint32_t result;
+	uint32_t i;
+	bool value;
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	if (is_bsec_write_locked() == true) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	result = bsec_read_sp_lock(otp, &value);
+	if (result != BSEC_OK) {
+		WARN("BSEC: %u Sticky-prog bit read Error %u\n", otp, result);
+	} else if (value) {
+		WARN("BSEC: OTP locked, prog will be ignored\n");
+		return BSEC_WRITE_LOCKED;
+	}
+
+	mmio_write_32(BSEC_BASE + BSEC_WDR, val);
+
+	for (i = 0U; i < MAX_NB_TRIES; i++) {
+		mmio_write_32(BSEC_BASE + BSEC_OTPCR, otp | BSEC_OTPCR_PROG);
+
+		poll_otp_status_busy();
+
+		result = check_program_error(otp);
+		if (result != BSEC_RETRY) {
+			break;
+		}
+	}
+
+	return result;
+}
+
+/*
+ * bsec_read_debug_conf: read debug configuration.
+ */
+uint32_t bsec_read_debug_conf(void)
+{
+	return mmio_read_32(BSEC_BASE + BSEC_DENR);
+}
+
+static uint32_t bsec_lock_register_set(uint32_t offset, uint32_t mask)
+{
+	uint32_t value = mmio_read_32(BSEC_BASE + offset);
+
+	/* The lock is already set */
+	if ((value & mask) != 0U) {
+		return BSEC_OK;
+	}
+
+	if (is_bsec_write_locked()) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	value |= mask;
+
+	mmio_write_32(BSEC_BASE + offset, value);
+
+	return BSEC_OK;
+}
+
+static bool bsec_lock_register_get(uint32_t offset, uint32_t mask)
+{
+	uint32_t value = mmio_read_32(BSEC_BASE + offset);
+
+	return (value & mask) != 0U;
+}
+
+/*
+ * bsec_set_sr_lock: set shadow-read lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sr_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return bsec_lock_register_set(BSEC_SRLOCK(bank), otp_mask);
+}
+
+/*
+ * bsec_read_sr_lock: read shadow-read lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sr_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = bsec_lock_register_get(BSEC_SRLOCK(bank), otp_mask);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_set_sw_lock: set shadow-write lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sw_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return bsec_lock_register_set(BSEC_SWLOCK(bank), otp_mask);
+}
+
+/*
+ * bsec_read_sw_lock: read shadow-write lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sw_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = bsec_lock_register_get(BSEC_SWLOCK(bank), otp_mask);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_set_sp_lock: set shadow-program lock.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_set_sp_lock(uint32_t otp)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	return bsec_lock_register_set(BSEC_SPLOCK(bank), otp_mask);
+}
+
+/*
+ * bsec_read_sp_lock: read shadow-program lock.
+ * otp: OTP number.
+ * value: read value (true or false).
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_sp_lock(uint32_t otp, bool *value)
+{
+	uint32_t bank = otp_bank(otp);
+	uint32_t otp_mask = otp_bit_mask(otp);
+
+	assert(value != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*value = bsec_lock_register_get(BSEC_SPLOCK(bank), otp_mask);
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_get_secure_state: read state in BSEC status register.
+ * return: secure state
+ */
+uint32_t bsec_get_secure_state(void)
+{
+	uint32_t state = BSEC_STATE_INVALID;
+	uint32_t status = bsec_get_status();
+	uint32_t bsec_sr = mmio_read_32(BSEC_BASE + BSEC_SR);
+
+	if ((status & BSEC_OTPSR_INIT_DONE) == BSEC_OTPSR_INIT_DONE) {
+		/* NVSTATE is only valid if INIT_DONE */
+		uint32_t nvstates = (bsec_sr & BSEC_SR_NVSTATE_MASK) >> BSEC_SR_NVSTATE_SHIFT;
+
+		if (nvstates == BSEC_SR_NVSTATE_OPEN)
+			state = BSEC_STATE_SEC_OPEN;
+		else if (nvstates == BSEC_SR_NVSTATE_CLOSED)
+			state = BSEC_STATE_SEC_CLOSED;
+	}
+
+	if ((bsec_sr & BSEC_SR_HVALID) != 0U) {
+		state |= BSEC_HARDWARE_KEY;
+	}
+
+	return state;
+}
+
+/*
+ * bsec_shadow_read_otp: Load OTP from SAFMEM and provide its value
+ * val: read value.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_shadow_read_otp(uint32_t *val, uint32_t otp)
+{
+	assert(val != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	*val = 0U;
+
+	if (is_bsec_write_locked()) {
+		return BSEC_WRITE_LOCKED;
+	}
+
+	if (!is_fuse_shadowed(otp)) {
+		uint32_t result = bsec_shadow_register(otp);
+
+		if (result != BSEC_OK) {
+			ERROR("BSEC: %u Shadowing Error %u\n", otp, result);
+			return result;
+		}
+	}
+
+	*val = mmio_read_32(BSEC_BASE + BSEC_FVR(otp));
+
+	return BSEC_OK;
+}
+
+/*
+ * bsec_read_otp: read an OTP data value.
+ * val: read value.
+ * otp: OTP number.
+ * return value: BSEC_OK if no error.
+ */
+uint32_t bsec_read_otp(uint32_t *val, uint32_t otp)
+{
+	struct bsec_shadow *shadow = (struct bsec_shadow *)SRAM1_BASE;
+
+	assert(val != NULL);
+	if (otp > STM32MP2_OTP_MAX_ID) {
+		panic();
+	}
+
+	/* OTP already shadowed */
+	if ((shadow->magic == BSEC_MAGIC) && (shadow->state != BSEC_STATE_INVALID)) {
+		*val = shadow->value[otp];
+
+		return BSEC_OK;
+	}
+
+	return bsec_shadow_read_otp(val, otp);
+}
diff --git a/drivers/st/clk/clk-stm32-core.c b/drivers/st/clk/clk-stm32-core.c
index bb0312533b..2976b4b5c0 100644
--- a/drivers/st/clk/clk-stm32-core.c
+++ b/drivers/st/clk/clk-stm32-core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -28,7 +28,7 @@ struct stm32_clk_priv *clk_stm32_get_priv(void)
 	return stm32_clock_data;
 }
 
-static void stm32mp1_clk_lock(struct spinlock *lock)
+static void _clk_lock(struct spinlock *lock)
 {
 	if (stm32mp_lock_available()) {
 		/* Assume interrupts are masked */
@@ -36,21 +36,21 @@ static void stm32mp1_clk_lock(struct spinlock *lock)
 	}
 }
 
-static void stm32mp1_clk_unlock(struct spinlock *lock)
+static void _clk_unlock(struct spinlock *lock)
 {
 	if (stm32mp_lock_available()) {
 		spin_unlock(lock);
 	}
 }
 
-void stm32mp1_clk_rcc_regs_lock(void)
+void clk_stm32_rcc_regs_lock(void)
 {
-	stm32mp1_clk_lock(&reg_lock);
+	_clk_lock(&reg_lock);
 }
 
-void stm32mp1_clk_rcc_regs_unlock(void)
+void clk_stm32_rcc_regs_unlock(void)
 {
-	stm32mp1_clk_unlock(&reg_lock);
+	_clk_unlock(&reg_lock);
 }
 
 #define TIMEOUT_US_1S	U(1000000)
@@ -163,6 +163,8 @@ static int clk_gate_enable(struct stm32_clk_priv *priv, int id)
 
 	mmio_setbits_32(priv->base + cfg->offset, BIT(cfg->bit_idx));
 
+	dsb(); /* Make sure the clock is enabled.  */
+
 	return 0;
 }
 
@@ -171,7 +173,11 @@ static void clk_gate_disable(struct stm32_clk_priv *priv, int id)
 	const struct clk_stm32 *clk = _clk_get(priv, id);
 	struct clk_gate_cfg *cfg = clk->clock_cfg;
 
+	dsb(); /* Ensure prebious transaction are performed before stop.  */
+
 	mmio_clrbits_32(priv->base + cfg->offset, BIT(cfg->bit_idx));
+
+	dsb(); /* Make sure the clock is disabled.  */
 }
 
 static bool clk_gate_is_enabled(struct stm32_clk_priv *priv, int id)
@@ -224,6 +230,15 @@ const struct clk_stm32 *_clk_get(struct stm32_clk_priv *priv, int id)
 	return NULL;
 }
 
+static const struct stm32_clk_ops *_clk_get_ops(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+
+	assert (clk->ops != NO_OPS);
+
+	return priv->ops_array[clk->ops];
+}
+
 #define clk_div_mask(_width) GENMASK(((_width) - 1U), 0U)
 
 static unsigned int _get_table_div(const struct clk_div_table *table,
@@ -377,7 +392,7 @@ int _clk_stm32_set_parent_by_index(struct stm32_clk_priv *priv, int clk, int sel
 
 int _clk_stm32_get_parent(struct stm32_clk_priv *priv, int clk_id)
 {
-	const struct clk_stm32 *clk = _clk_get(priv, clk_id);
+	const struct stm32_clk_ops *ops = _clk_get_ops(priv, clk_id);
 	const struct parent_cfg *parent;
 	uint16_t mux_id;
 	int sel;
@@ -394,8 +409,8 @@ int _clk_stm32_get_parent(struct stm32_clk_priv *priv, int clk_id)
 	mux_id &= MUX_PARENT_MASK;
 	parent = &priv->parents[mux_id];
 
-	if (clk->ops->get_parent != NULL) {
-		sel = clk->ops->get_parent(priv, clk_id);
+	if (ops->get_parent != NULL) {
+		sel = ops->get_parent(priv, clk_id);
 	} else {
 		sel = clk_mux_get_parent(priv, mux_id);
 	}
@@ -464,12 +479,11 @@ int clk_get_index(struct stm32_clk_priv *priv, unsigned long binding_id)
 
 unsigned long _clk_stm32_get_rate(struct stm32_clk_priv *priv, int id)
 {
-	const struct clk_stm32 *clk = _clk_get(priv, id);
+	const struct stm32_clk_ops *ops = _clk_get_ops(priv, id);
 	int parent;
-	unsigned long rate = 0UL;
 
 	if ((unsigned int)id >= priv->num) {
-		return rate;
+		return 0UL;
 	}
 
 	parent = _clk_stm32_get_parent(priv, id);
@@ -477,28 +491,21 @@ unsigned long _clk_stm32_get_rate(struct stm32_clk_priv *priv, int id)
 		return 0UL;
 	}
 
-	if (clk->ops->recalc_rate != NULL) {
+	if (ops->recalc_rate != NULL) {
 		unsigned long prate = 0UL;
 
 		if (parent != CLK_IS_ROOT) {
 			prate = _clk_stm32_get_rate(priv, parent);
 		}
 
-		rate = clk->ops->recalc_rate(priv, id, prate);
-
-		return rate;
+		return ops->recalc_rate(priv, id, prate);
 	}
 
-	switch (parent) {
-	case CLK_IS_ROOT:
+	if (parent == CLK_IS_ROOT) {
 		panic();
-
-	default:
-		rate = _clk_stm32_get_rate(priv, parent);
-		break;
 	}
-	return rate;
 
+	return _clk_stm32_get_rate(priv, parent);
 }
 
 unsigned long _clk_stm32_get_parent_rate(struct stm32_clk_priv *priv, int id)
@@ -519,7 +526,7 @@ static uint8_t _stm32_clk_get_flags(struct stm32_clk_priv *priv, int id)
 
 bool _stm32_clk_is_flags(struct stm32_clk_priv *priv, int id, uint8_t flag)
 {
-	if (_stm32_clk_get_flags(priv, id) & flag) {
+	if ((_stm32_clk_get_flags(priv, id) & flag) != 0U) {
 		return true;
 	}
 
@@ -528,10 +535,10 @@ bool _stm32_clk_is_flags(struct stm32_clk_priv *priv, int id, uint8_t flag)
 
 int clk_stm32_enable_call_ops(struct stm32_clk_priv *priv, uint16_t id)
 {
-	const struct clk_stm32 *clk = _clk_get(priv, id);
+	const struct stm32_clk_ops *ops = _clk_get_ops(priv, id);
 
-	if (clk->ops->enable != NULL) {
-		clk->ops->enable(priv, id);
+	if (ops->enable != NULL) {
+		ops->enable(priv, id);
 	}
 
 	return 0;
@@ -549,7 +556,7 @@ static int _clk_stm32_enable_core(struct stm32_clk_priv *priv, int id)
 		}
 		if (parent != CLK_IS_ROOT) {
 			ret = _clk_stm32_enable_core(priv, parent);
-			if (ret) {
+			if (ret != 0) {
 				return ret;
 			}
 		}
@@ -570,19 +577,19 @@ int _clk_stm32_enable(struct stm32_clk_priv *priv, int id)
 {
 	int ret;
 
-	stm32mp1_clk_lock(&refcount_lock);
+	_clk_lock(&refcount_lock);
 	ret = _clk_stm32_enable_core(priv, id);
-	stm32mp1_clk_unlock(&refcount_lock);
+	_clk_unlock(&refcount_lock);
 
 	return ret;
 }
 
 void clk_stm32_disable_call_ops(struct stm32_clk_priv *priv, uint16_t id)
 {
-	const struct clk_stm32 *clk = _clk_get(priv, id);
+	const struct stm32_clk_ops *ops = _clk_get_ops(priv, id);
 
-	if (clk->ops->disable != NULL) {
-		clk->ops->disable(priv, id);
+	if (ops->disable != NULL) {
+		ops->disable(priv, id);
 	}
 }
 
@@ -618,19 +625,19 @@ static void _clk_stm32_disable_core(struct stm32_clk_priv *priv, int id)
 
 void _clk_stm32_disable(struct stm32_clk_priv *priv, int id)
 {
-	stm32mp1_clk_lock(&refcount_lock);
+	_clk_lock(&refcount_lock);
 
 	_clk_stm32_disable_core(priv, id);
 
-	stm32mp1_clk_unlock(&refcount_lock);
+	_clk_unlock(&refcount_lock);
 }
 
 bool _clk_stm32_is_enabled(struct stm32_clk_priv *priv, int id)
 {
-	const struct clk_stm32 *clk = _clk_get(priv, id);
+	const struct stm32_clk_ops *ops = _clk_get_ops(priv, id);
 
-	if (clk->ops->is_enabled != NULL) {
-		return clk->ops->is_enabled(priv, id);
+	if (ops->is_enabled != NULL) {
+		return ops->is_enabled(priv, id);
 	}
 
 	return priv->gate_refcounts[id];
@@ -965,6 +972,10 @@ int clk_stm32_osc_gate_enable(struct stm32_clk_priv *priv, int id)
 {
 	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
 
+	if (osc_data->frequency == 0UL) {
+		return 0;
+	}
+
 	_clk_stm32_gate_enable(priv, osc_data->gate_id);
 
 	if (_clk_stm32_gate_wait_ready(priv, osc_data->gate_rdy_id, true) != 0U) {
@@ -979,6 +990,10 @@ void clk_stm32_osc_gate_disable(struct stm32_clk_priv *priv, int id)
 {
 	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, id);
 
+	if (osc_data->frequency == 0UL) {
+		return;
+	}
+
 	_clk_stm32_gate_disable(priv, osc_data->gate_id);
 
 	if (_clk_stm32_gate_wait_ready(priv, osc_data->gate_rdy_id, false) != 0U) {
@@ -1081,12 +1096,10 @@ int clk_stm32_init(struct stm32_clk_priv *priv, uintptr_t base)
 	priv->base = base;
 
 	for (i = 0U; i < priv->num; i++) {
-		const struct clk_stm32 *clk = _clk_get(priv, i);
-
-		assert(clk->ops != NULL);
+		const struct stm32_clk_ops *ops = _clk_get_ops(priv, i);
 
-		if (clk->ops->init != NULL) {
-			clk->ops->init(priv, i);
+		if (ops->init != NULL) {
+			ops->init(priv, i);
 		}
 	}
 
diff --git a/drivers/st/clk/clk-stm32-core.h b/drivers/st/clk/clk-stm32-core.h
index 8bfb5134f4..ccf5a0728e 100644
--- a/drivers/st/clk/clk-stm32-core.h
+++ b/drivers/st/clk/clk-stm32-core.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -21,23 +21,23 @@ struct gate_cfg {
 };
 
 struct clk_div_table {
-	unsigned int val;
-	unsigned int div;
+	uint16_t val;
+	uint16_t div;
 };
 
 struct div_cfg {
+	const struct clk_div_table *table;
 	uint16_t offset;
 	uint8_t shift;
 	uint8_t width;
 	uint8_t flags;
 	uint8_t bitrdy;
-	const struct clk_div_table *table;
 };
 
 struct parent_cfg {
-	uint8_t num_parents;
 	const uint16_t *id_parents;
 	struct mux_cfg *mux;
+	uint8_t num_parents;
 };
 
 struct stm32_clk_priv;
@@ -56,9 +56,9 @@ struct stm32_clk_ops {
 struct clk_stm32 {
 	uint16_t binding;
 	uint16_t parent;
+	uint8_t ops;
 	uint8_t flags;
 	void *clock_cfg;
-	const struct stm32_clk_ops *ops;
 };
 
 struct stm32_clk_priv {
@@ -73,8 +73,9 @@ struct stm32_clk_priv {
 	const uint32_t nb_div;
 	struct clk_oscillator_data *osci_data;
 	const uint32_t nb_osci_data;
-	uint32_t *gate_refcounts;
+	uint8_t *gate_refcounts;
 	void *pdata;
+	const struct stm32_clk_ops **ops_array;
 };
 
 struct stm32_clk_bypass {
@@ -97,18 +98,14 @@ struct stm32_clk_drive {
 
 struct clk_oscillator_data {
 	const char *name;
-	uint16_t id_clk;
-	unsigned long frequency;
-	uint16_t gate_id;
-	uint16_t gate_rdy_id;
 	struct stm32_clk_bypass *bypass;
 	struct stm32_clk_css *css;
 	struct stm32_clk_drive *drive;
-};
+	unsigned long frequency;
+	uint16_t id_clk;
+	uint16_t gate_id;
+	uint16_t gate_rdy_id;
 
-struct clk_fixed_rate {
-	const char *name;
-	unsigned long fixed_rate;
 };
 
 struct clk_gate_cfg {
@@ -144,6 +141,9 @@ struct clk_gate_cfg {
 #define MASK_WIDTH_SHIFT(_width, _shift) \
 	GENMASK(((_width) + (_shift) - 1U), (_shift))
 
+void clk_stm32_rcc_regs_lock(void);
+void clk_stm32_rcc_regs_unlock(void);
+
 int clk_stm32_init(struct stm32_clk_priv *priv, uintptr_t base);
 void clk_stm32_enable_critical_clocks(void);
 
@@ -218,7 +218,7 @@ void clk_stm32_display_clock_info(void);
 #endif
 
 struct clk_stm32_div_cfg {
-	int id;
+	uint8_t id;
 };
 
 #define STM32_DIV(idx, _binding, _parent, _flags, _div_id) \
@@ -229,11 +229,11 @@ struct clk_stm32_div_cfg {
 		.clock_cfg	= &(struct clk_stm32_div_cfg){\
 			.id	= (_div_id),\
 		},\
-		.ops		= &clk_stm32_divider_ops,\
+		.ops		= STM32_DIVIDER_OPS,\
 	}
 
 struct clk_stm32_gate_cfg {
-	int id;
+	uint8_t id;
 };
 
 #define STM32_GATE(idx, _binding, _parent, _flags, _gate_id) \
@@ -244,12 +244,12 @@ struct clk_stm32_gate_cfg {
 		.clock_cfg	= &(struct clk_stm32_gate_cfg){\
 			.id	= (_gate_id),\
 		},\
-		.ops		= &clk_stm32_gate_ops,\
+		.ops		= STM32_GATE_OPS,\
 	}
 
 struct fixed_factor_cfg {
-	unsigned int mult;
-	unsigned int div;
+	uint8_t mult;
+	uint8_t div;
 };
 
 unsigned long fixed_factor_recalc_rate(struct stm32_clk_priv *priv,
@@ -263,7 +263,7 @@ unsigned long fixed_factor_recalc_rate(struct stm32_clk_priv *priv,
 			.mult	= (_mult),\
 			.div	= (_div),\
 		},\
-		.ops		= &clk_fixed_factor_ops,\
+		.ops		= FIXED_FACTOR_OPS,\
 	}
 
 #define GATE(idx, _binding, _parent, _flags, _offset, _bit_idx) \
@@ -275,7 +275,7 @@ unsigned long fixed_factor_recalc_rate(struct stm32_clk_priv *priv,
 			.offset		= (_offset),\
 			.bit_idx	= (_bit_idx),\
 		},\
-		.ops		= &clk_gate_ops,\
+		.ops		= GATE_OPS,\
 	}
 
 #define STM32_MUX(idx, _binding, _mux_id, _flags) \
@@ -284,7 +284,7 @@ unsigned long fixed_factor_recalc_rate(struct stm32_clk_priv *priv,
 		.parent		= (MUX(_mux_id)),\
 		.flags		= (_flags),\
 		.clock_cfg	= NULL,\
-		.ops		= (&clk_mux_ops),\
+		.ops		= STM32_MUX_OPS\
 	}
 
 struct clk_timer_cfg {
@@ -301,7 +301,7 @@ struct clk_timer_cfg {
 			.apbdiv = (_apbdiv),\
 			.timpre = (_timpre),\
 		},\
-		.ops		= &clk_timer_ops,\
+		.ops		= STM32_TIMER_OPS,\
 	}
 
 struct clk_stm32_fixed_rate_cfg {
@@ -315,7 +315,7 @@ struct clk_stm32_fixed_rate_cfg {
 		.clock_cfg	= &(struct clk_stm32_fixed_rate_cfg){\
 			.rate	= (_rate),\
 		},\
-		.ops		= &clk_stm32_fixed_rate_ops,\
+		.ops		= STM32_FIXED_RATE_OPS,\
 	}
 
 #define BYPASS(_offset, _bit_byp, _bit_digbyp) &(struct stm32_clk_bypass){\
@@ -355,7 +355,7 @@ int clk_stm32_osc_gate_enable(struct stm32_clk_priv *priv, int id);
 void clk_stm32_osc_gate_disable(struct stm32_clk_priv *priv, int id);
 
 struct stm32_osc_cfg {
-	int osc_id;
+	uint8_t osc_id;
 };
 
 #define CLK_OSC(idx, _idx, _parent, _osc_id) \
@@ -366,7 +366,7 @@ struct stm32_osc_cfg {
 		.clock_cfg	= &(struct stm32_osc_cfg){\
 			.osc_id = (_osc_id),\
 		},\
-		.ops		= &clk_stm32_osc_ops,\
+		.ops		= STM32_OSC_OPS,\
 	}
 
 #define CLK_OSC_FIXED(idx, _idx, _parent, _osc_id) \
@@ -377,7 +377,7 @@ struct stm32_osc_cfg {
 		.clock_cfg	= &(struct stm32_osc_cfg){\
 			.osc_id	= (_osc_id),\
 		},\
-		.ops		= &clk_stm32_osc_nogate_ops,\
+		.ops		= STM32_OSC_NOGATE_OPS,\
 	}
 
 extern const struct stm32_clk_ops clk_mux_ops;
@@ -390,4 +390,19 @@ extern const struct stm32_clk_ops clk_stm32_fixed_rate_ops;
 extern const struct stm32_clk_ops clk_stm32_osc_ops;
 extern const struct stm32_clk_ops clk_stm32_osc_nogate_ops;
 
+enum {
+	NO_OPS,
+	FIXED_FACTOR_OPS,
+	GATE_OPS,
+	STM32_MUX_OPS,
+	STM32_DIVIDER_OPS,
+	STM32_GATE_OPS,
+	STM32_TIMER_OPS,
+	STM32_FIXED_RATE_OPS,
+	STM32_OSC_OPS,
+	STM32_OSC_NOGATE_OPS,
+
+	STM32_LAST_OPS
+};
+
 #endif /* CLK_STM32_CORE_H */
diff --git a/drivers/st/clk/clk-stm32mp13.c b/drivers/st/clk/clk-stm32mp13.c
index c960928991..daf6a3802d 100644
--- a/drivers/st/clk/clk-stm32mp13.c
+++ b/drivers/st/clk/clk-stm32mp13.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -186,65 +186,7 @@ enum stm32_clock {
 	_MCE,
 	_FMC_K,
 	_QSPI_K,
-#if defined(IMAGE_BL32)
-	_LTDC,
-	_DMA1,
-	_DMA2,
-	_MDMA,
-	_ETH1MAC,
-	_USBH,
-	_TIM2,
-	_TIM3,
-	_TIM4,
-	_TIM5,
-	_TIM6,
-	_TIM7,
-	_LPTIM1_K,
-	_SPI2_K,
-	_SPI3_K,
-	_SPDIF_K,
-	_TIM1,
-	_TIM8,
-	_SPI1_K,
-	_SAI1_K,
-	_SAI2_K,
-	_DFSDM,
-	_FDCAN_K,
-	_TIM13,
-	_TIM14,
-	_TIM16,
-	_TIM17,
-	_SPI4_K,
-	_SPI5_K,
-	_I2C1_K,
-	_I2C2_K,
-	_ADFSDM,
-	_LPTIM2_K,
-	_LPTIM3_K,
-	_LPTIM4_K,
-	_LPTIM5_K,
-	_VREF,
-	_DTS,
-	_PMBCTRL,
-	_HDP,
-	_STGENRO,
-	_DCMIPP_K,
-	_DMAMUX1,
-	_DMAMUX2,
-	_DMA3,
-	_ADC1_K,
-	_ADC2_K,
-	_TSC,
-	_AXIMC,
-	_ETH1CK,
-	_ETH1TX,
-	_ETH1RX,
-	_CRC1,
-	_ETH2CK,
-	_ETH2TX,
-	_ETH2RX,
-	_ETH2MAC,
-#endif
+
 	CK_LAST
 };
 
@@ -456,7 +398,7 @@ static const uint16_t SAES_src[] = {
 	},\
 }
 
-static const struct parent_cfg parent_mp13[] = {
+static const struct parent_cfg parent_mp13[MUX_MAX] = {
 	MUX_CFG(MUX_ADC1,	ADC1_src,	RCC_ADC12CKSELR, 0, 2),
 	MUX_CFG(MUX_ADC2,	ADC2_src,	RCC_ADC12CKSELR, 2, 2),
 	MUX_RDY_CFG(MUX_AXI,	AXI_src,	RCC_ASSCKSELR, 0, 3),
@@ -841,7 +783,7 @@ static const struct clk_div_table apb_div_table[] = {
 		.bitrdy	= _bitrdy,\
 }
 
-static const struct div_cfg dividers_mp13[] = {
+static const struct div_cfg dividers_mp13[DIV_MAX] = {
 	DIV_CFG(DIV_PLL1DIVP, RCC_PLL1CFGR2, 0, 7, 0, NULL, DIV_NO_BIT_RDY),
 	DIV_CFG(DIV_PLL2DIVP, RCC_PLL2CFGR2, 0, 7, 0, NULL, DIV_NO_BIT_RDY),
 	DIV_CFG(DIV_PLL2DIVQ, RCC_PLL2CFGR2, 8, 7, 0, NULL, DIV_NO_BIT_RDY),
@@ -947,7 +889,7 @@ static bool pll4_bootrom;
 #endif
 
 /* RCC clock device driver private */
-static unsigned int refcounts_mp13[CK_LAST];
+static uint8_t refcounts_mp13[CK_LAST];
 
 static const struct stm32_clk_pll *clk_st32_pll_data(unsigned int idx);
 
@@ -1007,6 +949,11 @@ static void stm32_enable_oscillator_lse(struct stm32_clk_priv *priv)
 		return;
 	}
 
+	/* Do not reconfigure LSE if already enabled */
+	if (_clk_stm32_gate_is_enabled(priv, osc_data->gate_id)) {
+		return;
+	}
+
 	clk_oscillator_set_bypass(priv, _CK_LSE, digbyp, bypass);
 
 	clk_oscillator_set_drive(priv, _CK_LSE, drive);
@@ -1027,8 +974,8 @@ static int stm32mp1_set_hsidiv(uint8_t hsidiv)
 	timeout = timeout_init_us(HSIDIV_TIMEOUT);
 	while ((mmio_read_32(address) & RCC_OCRDYR_HSIDIVRDY) == 0U) {
 		if (timeout_elapsed(timeout)) {
-			ERROR("HSIDIV failed @ 0x%lx: 0x%x\n",
-			      address, mmio_read_32(address));
+			EARLY_ERROR("HSIDIV failed @ 0x%lx: 0x%x\n",
+				    address, mmio_read_32(address));
 			return -ETIMEDOUT;
 		}
 	}
@@ -1050,7 +997,7 @@ static int stm32mp1_hsidiv(unsigned long hsifreq)
 	}
 
 	if (hsidiv == 4U) {
-		ERROR("Invalid clk-hsi frequency\n");
+		EARLY_ERROR("Invalid clk-hsi frequency\n");
 		return -EINVAL;
 	}
 
@@ -1119,7 +1066,7 @@ static int stm32_clk_configure_clk(struct stm32_clk_priv *priv, uint32_t data)
 		return ret;
 	}
 
-	if (enable) {
+	if (enable != 0) {
 		clk_stm32_enable_call_ops(priv, clk_id);
 	} else {
 		clk_stm32_disable_call_ops(priv, clk_id);
@@ -1216,7 +1163,7 @@ static int stm32_clk_source_configure(struct stm32_clk_priv *priv)
 	 * => deactivate CKPER only after switching clock
 	 */
 	if (ckper_disabled) {
-		ret = stm32_clk_configure_mux(priv, CLK_CKPER_DISABLED & CMD_MASK);
+		ret = stm32_clk_configure_mux(priv, CLK_CKPER_DISABLED);
 		if (ret != 0) {
 			return ret;
 		}
@@ -1292,7 +1239,7 @@ static void clk_stm32_pll_config_vco(struct stm32_clk_priv *priv,
 	uint32_t value = 0;
 
 	if (clk_stm32_pll_compute_cfgr1(priv, pll, vco, &value) != 0) {
-		ERROR("Invalid Vref clock !\n");
+		EARLY_ERROR("Invalid Vref clock !\n");
 		panic();
 	}
 
@@ -1352,6 +1299,124 @@ static inline struct stm32_pll_dt_cfg *clk_stm32_pll_get_pdata(int pll_idx)
 	return &pdata->pll[pll_idx];
 }
 
+
+/* Define characteristic for PLL1 : PLL_2000 */
+#define POST_DIVM_MIN	8000000U
+#define POST_DIVM_MAX	16000000U
+#define DIVM_MIN	0U
+#define DIVM_MAX	63U
+#define DIVN_MIN	24U
+#define DIVN_MAX	99U
+#define DIVP_MIN	0U
+#define DIVP_MAX	127U
+#define FRAC_MAX	8192U
+#define VCO_MIN		992000000U
+#define VCO_MAX		2000000000U
+
+static int clk_compute_pll1_settings(uint32_t freq_khz)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	struct stm32_pll_dt_cfg *pll1 = clk_stm32_pll_get_pdata(_PLL1);
+	struct stm32_pll_dt_cfg *pll2 = clk_stm32_pll_get_pdata(_PLL2);
+	unsigned long long best_diff = ULLONG_MAX;
+	unsigned int divm;
+	unsigned long input_freq = 0UL;
+	uint32_t src =  pll2->vco.src;
+
+	/* PLL1 share the same clock source than PLL2 */
+	switch (src) {
+	case CLK_PLL12_HSI:
+		input_freq = _clk_stm32_get_rate(priv, _CK_HSI);
+		break;
+	case CLK_PLL12_HSE:
+		input_freq = _clk_stm32_get_rate(priv, _CK_HSE);
+		break;
+	default:
+		break;
+	}
+
+	if (input_freq == 0UL) {
+		panic();
+	}
+
+	/* Following parameters have always the same value */
+	pll1->output.output[PLL_CFG_Q] = 0U;
+	pll1->output.output[PLL_CFG_R] = 0U;
+
+	for (divm = (DIVM_MAX + 1U); divm != DIVM_MIN; divm--) {
+		unsigned long post_divm = input_freq / divm;
+		unsigned int divp;
+
+		if ((post_divm < POST_DIVM_MIN) || (post_divm > POST_DIVM_MAX)) {
+			continue;
+		}
+
+		for (divp = DIVP_MIN; divp <= DIVP_MAX; divp++) {
+			unsigned long long output_freq = freq_khz * 1000ULL;
+			unsigned long long freq;
+			unsigned long long divn;
+			unsigned long long frac;
+			unsigned int i;
+
+			freq = output_freq * divm * (divp + 1U);
+
+			divn = (freq / input_freq) - 1U;
+			if ((divn < DIVN_MIN) || (divn > DIVN_MAX)) {
+				continue;
+			}
+
+			frac = ((freq * FRAC_MAX) / input_freq) - ((divn + 1U) * FRAC_MAX);
+
+			/* 2 loops to refine the fractional part */
+			for (i = 2U; i != 0U; i--) {
+				unsigned long long diff;
+				unsigned long long vco;
+
+				if (frac > FRAC_MAX) {
+					break;
+				}
+
+				vco = (post_divm * (divn + 1U)) + ((post_divm * frac) / FRAC_MAX);
+
+				if ((vco < (VCO_MIN / 2U)) || (vco > (VCO_MAX / 2U))) {
+					frac++;
+					continue;
+				}
+
+				freq = vco / (divp + 1U);
+				if (output_freq < freq) {
+					diff = freq - output_freq;
+				} else {
+					diff = output_freq - freq;
+				}
+
+				if (diff < best_diff)  {
+					pll1->vco.src = src;
+					pll1->vco.status = RCC_PLLNCR_DIVPEN | RCC_PLLNCR_PLLON;
+					pll1->vco.div_mn[PLL_CFG_M] = divm - 1U;
+					pll1->vco.div_mn[PLL_CFG_N] = (uint32_t)divn;
+					pll1->vco.frac = (uint32_t)frac;
+					pll1->output.output[PLL_CFG_P] = divp;
+
+					if (diff == 0U) {
+						return 0;
+					}
+
+					best_diff = diff;
+				}
+
+				frac++;
+			}
+		}
+	}
+
+	if (best_diff == ULLONG_MAX) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static bool _clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
 {
 	uintptr_t pll_base = priv->base + pll->reg_pllxcr;
@@ -1450,7 +1515,7 @@ static int _clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx,
 
 	/* Configure PLLs source */
 	ret = stm32_clk_configure_mux(priv, pll_conf->vco.src);
-	if (ret) {
+	if (ret != 0) {
 		return ret;
 	}
 
@@ -1485,7 +1550,7 @@ static int clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx)
 {
 	struct stm32_pll_dt_cfg *pll_conf = clk_stm32_pll_get_pdata(pll_idx);
 
-	if (pll_conf->vco.status) {
+	if (pll_conf->vco.status != 0U) {
 		return _clk_stm32_pll_init(priv, pll_idx, pll_conf);
 	}
 
@@ -1497,22 +1562,22 @@ static int stm32_clk_pll_configure(struct stm32_clk_priv *priv)
 	int err = 0;
 
 	err = clk_stm32_pll_init(priv, _PLL1);
-	if (err) {
+	if (err != 0) {
 		return err;
 	}
 
 	err = clk_stm32_pll_init(priv, _PLL2);
-	if (err) {
+	if (err != 0) {
 		return err;
 	}
 
 	err = clk_stm32_pll_init(priv, _PLL3);
-	if (err) {
+	if (err != 0) {
 		return err;
 	}
 
 	err = clk_stm32_pll_init(priv, _PLL4);
-	if (err) {
+	if (err != 0) {
 		return err;
 	}
 
@@ -1629,7 +1694,7 @@ static const struct stm32_clk_pll *clk_st32_pll_data(unsigned int idx)
 }
 
 struct stm32_pll_cfg {
-	int pll_id;
+	uint8_t pll_id;
 };
 
 static unsigned long clk_stm32_pll_recalc_rate(struct stm32_clk_priv *priv,  int id,
@@ -1711,12 +1776,12 @@ static const struct stm32_clk_ops clk_stm32_pll_ops = {
 	.clock_cfg	= &(struct stm32_pll_cfg) {\
 		.pll_id = _pll_id,\
 	},\
-	.ops = &clk_stm32_pll_ops,\
+	.ops = STM32_PLL_OPS,\
 }
 
 struct clk_stm32_composite_cfg {
-	int gate_id;
-	int div_id;
+	uint8_t gate_id;
+	uint8_t div_id;
 };
 
 static unsigned long clk_stm32_composite_recalc_rate(struct stm32_clk_priv *priv,
@@ -1768,9 +1833,32 @@ static const struct stm32_clk_ops clk_stm32_composite_ops = {
 		.gate_id	= (_gate_id),\
 		.div_id	= (_div_id),\
 	},\
-	.ops = &clk_stm32_composite_ops,\
+	.ops = STM32_COMPOSITE_OPS,\
 }
 
+enum {
+	STM32_PLL_OPS = STM32_LAST_OPS,
+	STM32_COMPOSITE_OPS,
+
+	MP13_LAST_OPS
+};
+
+static const struct stm32_clk_ops *ops_array_mp13[MP13_LAST_OPS] = {
+	[NO_OPS] =  NULL,
+	[FIXED_FACTOR_OPS] = &clk_fixed_factor_ops,
+	[GATE_OPS] = &clk_gate_ops,
+	[STM32_MUX_OPS] = &clk_mux_ops,
+	[STM32_DIVIDER_OPS] = &clk_stm32_divider_ops,
+	[STM32_GATE_OPS] = &clk_stm32_gate_ops,
+	[STM32_TIMER_OPS] = &clk_timer_ops,
+	[STM32_FIXED_RATE_OPS] = &clk_stm32_fixed_rate_ops,
+	[STM32_OSC_OPS] = &clk_stm32_osc_ops,
+	[STM32_OSC_NOGATE_OPS] = &clk_stm32_osc_nogate_ops,
+
+	[STM32_PLL_OPS] = &clk_stm32_pll_ops,
+	[STM32_COMPOSITE_OPS] = &clk_stm32_composite_ops
+};
+
 static const struct clk_stm32 stm32mp13_clk[CK_LAST] = {
 	/* ROOT CLOCKS */
 	CLK_FIXED_RATE(_CK_OFF, _NO_ID, 0),
@@ -1882,7 +1970,6 @@ static const struct clk_stm32 stm32mp13_clk[CK_LAST] = {
 	STM32_GATE(_SDMMC2_K, SDMMC2_K, MUX(MUX_SDMMC2), 0, GATE_SDMMC2),
 	STM32_GATE(_DBGCK, CK_DBG, _CKAXI, 0, GATE_DBGCK),
 
-/* TODO: CHECK CLOCK FOR BL2/BL32 AND IF ONLY FOR TEST OR NOT */
 	STM32_GATE(_USART3_K, USART3_K, MUX(MUX_UART35), 0, GATE_USART3),
 	STM32_GATE(_UART4_K, UART4_K, MUX(MUX_UART4), 0, GATE_UART4),
 	STM32_GATE(_UART5_K, UART5_K, MUX(MUX_UART35), 0, GATE_UART5),
@@ -1896,61 +1983,6 @@ static const struct clk_stm32 stm32mp13_clk[CK_LAST] = {
 	STM32_COMPOSITE(_MCO1_K, CK_MCO1, MUX(MUX_MCO1), 0, GATE_MCO1, DIV_MCO1),
 	STM32_COMPOSITE(_MCO2_K, CK_MCO2, MUX(MUX_MCO2), 0, GATE_MCO2, DIV_MCO2),
 	STM32_COMPOSITE(_TRACECK, CK_TRACE, _CKAXI, 0, GATE_TRACECK, DIV_TRACE),
-
-#if defined(IMAGE_BL32)
-	STM32_GATE(_TIM2, TIM2_K, _CKTIMG1, 0, GATE_TIM2),
-	STM32_GATE(_TIM3, TIM3_K, _CKTIMG1, 0, GATE_TIM3),
-	STM32_GATE(_TIM4, TIM4_K, _CKTIMG1, 0, GATE_TIM4),
-	STM32_GATE(_TIM5, TIM5_K, _CKTIMG1, 0, GATE_TIM5),
-	STM32_GATE(_TIM6, TIM6_K, _CKTIMG1, 0, GATE_TIM6),
-	STM32_GATE(_TIM7, TIM7_K, _CKTIMG1, 0, GATE_TIM7),
-	STM32_GATE(_TIM13, TIM13_K, _CKTIMG3, 0, GATE_TIM13),
-	STM32_GATE(_TIM14, TIM14_K, _CKTIMG3, 0, GATE_TIM14),
-	STM32_GATE(_LPTIM1_K, LPTIM1_K, MUX(MUX_LPTIM1), 0, GATE_LPTIM1),
-	STM32_GATE(_SPI2_K, SPI2_K, MUX(MUX_SPI23), 0, GATE_SPI2),
-	STM32_GATE(_SPI3_K, SPI3_K, MUX(MUX_SPI23), 0, GATE_SPI3),
-	STM32_GATE(_SPDIF_K, SPDIF_K, MUX(MUX_SPDIF), 0, GATE_SPDIF),
-	STM32_GATE(_TIM1, TIM1_K, _CKTIMG2, 0, GATE_TIM1),
-	STM32_GATE(_TIM8, TIM8_K, _CKTIMG2, 0, GATE_TIM8),
-	STM32_GATE(_TIM16, TIM16_K, _CKTIMG3, 0, GATE_TIM16),
-	STM32_GATE(_TIM17, TIM17_K, _CKTIMG3, 0, GATE_TIM17),
-	STM32_GATE(_SPI1_K, SPI1_K, MUX(MUX_SPI1), 0, GATE_SPI1),
-	STM32_GATE(_SPI4_K, SPI4_K, MUX(MUX_SPI4), 0, GATE_SPI4),
-	STM32_GATE(_SPI5_K, SPI5_K, MUX(MUX_SPI5), 0, GATE_SPI5),
-	STM32_GATE(_SAI1_K, SAI1_K, MUX(MUX_SAI1), 0, GATE_SAI1),
-	STM32_GATE(_SAI2_K, SAI2_K, MUX(MUX_SAI2), 0, GATE_SAI2),
-	STM32_GATE(_DFSDM, DFSDM_K, MUX(MUX_SAI1), 0, GATE_DFSDM),
-	STM32_GATE(_FDCAN_K, FDCAN_K, MUX(MUX_FDCAN), 0, GATE_FDCAN),
-	STM32_GATE(_USBH, USBH, _CKAXI, 0, GATE_USBH),
-	STM32_GATE(_I2C1_K, I2C1_K, MUX(MUX_I2C12), 0, GATE_I2C1),
-	STM32_GATE(_I2C2_K, I2C2_K, MUX(MUX_I2C12), 0, GATE_I2C2),
-	STM32_GATE(_ADFSDM, ADFSDM_K, MUX(MUX_SAI1), 0, GATE_ADFSDM),
-	STM32_GATE(_LPTIM2_K, LPTIM2_K, MUX(MUX_LPTIM2), 0, GATE_LPTIM2),
-	STM32_GATE(_LPTIM3_K, LPTIM3_K, MUX(MUX_LPTIM3), 0, GATE_LPTIM3),
-	STM32_GATE(_LPTIM4_K, LPTIM4_K, MUX(MUX_LPTIM45), 0, GATE_LPTIM4),
-	STM32_GATE(_LPTIM5_K, LPTIM5_K, MUX(MUX_LPTIM45), 0, GATE_LPTIM5),
-	STM32_GATE(_VREF, VREF, _PCLK3, 0, GATE_VREF),
-	STM32_GATE(_DTS, TMPSENS, _PCLK3, 0, GATE_DTS),
-	STM32_GATE(_PMBCTRL, PMBCTRL, _PCLK3, 0, GATE_HDP),
-	STM32_GATE(_HDP, HDP, _PCLK3, 0, GATE_PMBCTRL),
-	STM32_GATE(_STGENRO, STGENRO, _PCLK4, 0, GATE_DCMIPP),
-	STM32_GATE(_DCMIPP_K, DCMIPP_K, MUX(MUX_DCMIPP), 0, GATE_DCMIPP),
-	STM32_GATE(_DMAMUX1, DMAMUX1, _CKAXI, 0, GATE_DMAMUX1),
-	STM32_GATE(_DMAMUX2, DMAMUX2, _CKAXI, 0, GATE_DMAMUX2),
-	STM32_GATE(_DMA3, DMA3, _CKAXI, 0, GATE_DMAMUX2),
-	STM32_GATE(_ADC1_K, ADC1_K, MUX(MUX_ADC1), 0, GATE_ADC1),
-	STM32_GATE(_ADC2_K, ADC2_K, MUX(MUX_ADC2), 0, GATE_ADC2),
-	STM32_GATE(_TSC, TSC, _CKAXI, 0, GATE_TSC),
-	STM32_GATE(_AXIMC, AXIMC, _CKAXI, 0, GATE_AXIMC),
-	STM32_GATE(_CRC1, CRC1, _CKAXI, 0, GATE_ETH1TX),
-	STM32_GATE(_ETH1CK, ETH1CK_K, MUX(MUX_ETH1), 0, GATE_ETH1CK),
-	STM32_GATE(_ETH1TX, ETH1TX, _CKAXI, 0, GATE_ETH1TX),
-	STM32_GATE(_ETH1RX, ETH1RX, _CKAXI, 0, GATE_ETH1RX),
-	STM32_GATE(_ETH2CK, ETH2CK_K, MUX(MUX_ETH2), 0, GATE_ETH2CK),
-	STM32_GATE(_ETH2TX, ETH2TX, _CKAXI, 0, GATE_ETH2TX),
-	STM32_GATE(_ETH2RX, ETH2RX, _CKAXI, 0, GATE_ETH2RX),
-	STM32_GATE(_ETH2MAC, ETH2MAC, _CKAXI, 0, GATE_ETH2MAC),
-#endif
 };
 
 static struct stm32_pll_dt_cfg mp13_pll[_PLL_NB];
@@ -1986,6 +2018,7 @@ static struct stm32_clk_priv stm32mp13_clock_data = {
 	.nb_osci_data	= ARRAY_SIZE(stm32mp13_osc_data),
 	.gate_refcounts	= refcounts_mp13,
 	.pdata		= &stm32mp13_clock_pdata,
+	.ops_array	= ops_array_mp13,
 };
 
 static int stm32mp1_init_clock_tree(void)
@@ -2241,8 +2274,9 @@ static int stm32_clk_parse_fdt_all_pll(void *fdt, int node, struct stm32_clk_pla
 {
 	size_t i = 0U;
 
-	for (i = _PLL1; i < pdata->npll; i++) {
-		struct stm32_pll_dt_cfg *pll = pdata->pll + i;
+	/* PLL1 is not configurable with device tree */
+	for (i = _PLL2; i < pdata->npll; i++) {
+		struct stm32_pll_dt_cfg *pll = &pdata->pll[i];
 		char name[RCC_PLL_NAME_SIZE];
 		int subnode = 0;
 		int err = 0;
@@ -2301,32 +2335,47 @@ static int stm32_clk_parse_fdt(struct stm32_clk_platdata *pdata)
 	return 0;
 }
 
-int stm32mp1_clk_init(void)
+void stm32mp1_clk_rcc_regs_lock(void)
 {
-	return 0;
+	clk_stm32_rcc_regs_lock();
 }
 
-int stm32mp1_clk_probe(void)
+void stm32mp1_clk_rcc_regs_unlock(void)
+{
+	clk_stm32_rcc_regs_unlock();
+}
+
+int stm32mp1_clk_init(uint32_t pll1_freq_khz)
 {
-	uintptr_t base = RCC_BASE;
 	int ret;
 
-	ret = stm32_clk_parse_fdt(&stm32mp13_clock_pdata);
+	/* compute the PLL1 sting, not read in device tree */
+	ret = clk_compute_pll1_settings(pll1_freq_khz);
 	if (ret != 0) {
 		return ret;
 	}
 
-	ret = clk_stm32_init(&stm32mp13_clock_data, base);
+	ret = stm32mp1_init_clock_tree();
 	if (ret != 0) {
 		return ret;
 	}
 
-	ret = stm32mp1_init_clock_tree();
+	clk_stm32_enable_critical_clocks();
+
+	return 0;
+}
+
+int stm32mp1_clk_probe(void)
+{
+	uintptr_t base = RCC_BASE;
+	int ret;
+
+	ret = stm32_clk_parse_fdt(&stm32mp13_clock_pdata);
 	if (ret != 0) {
 		return ret;
 	}
 
-	clk_stm32_enable_critical_clocks();
+	ret = clk_stm32_init(&stm32mp13_clock_data, base);
 
-	return 0;
+	return ret;
 }
diff --git a/drivers/st/clk/clk-stm32mp2.c b/drivers/st/clk/clk-stm32mp2.c
new file mode 100644
index 0000000000..747576dafb
--- /dev/null
+++ b/drivers/st/clk/clk-stm32mp2.c
@@ -0,0 +1,2396 @@
+/*
+ * Copyright (C) 2018-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp2_clk.h>
+#include <libfdt.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+#include <lib/utils_def.h>
+
+#include <platform_def.h>
+#include "clk-stm32-core.h"
+
+struct stm32_osci_dt_cfg {
+	unsigned long freq;
+	uint32_t drive;
+	bool bypass;
+	bool digbyp;
+	bool css;
+};
+
+struct stm32_pll_dt_cfg {
+	uint32_t src;
+	uint32_t frac;
+	uint32_t cfg[PLLCFG_NB];
+	uint32_t csg[PLLCSG_NB];
+	bool csg_enabled;
+	bool enabled;
+};
+
+struct stm32_clk_platdata {
+	uintptr_t rcc_base;
+	uint32_t nosci;
+	struct stm32_osci_dt_cfg *osci;
+	uint32_t npll;
+	struct stm32_pll_dt_cfg *pll;
+	uint32_t nflexgen;
+	uint32_t *flexgen;
+	uint32_t nbusclk;
+	uint32_t *busclk;
+	uint32_t nkernelclk;
+	uint32_t *kernelclk;
+};
+
+/* A35 Sub-System which manages its own PLL (PLL1) */
+#define A35_SS_CHGCLKREQ	0x0000
+#define A35_SS_PLL_FREQ1	0x0080
+#define A35_SS_PLL_FREQ2	0x0090
+#define A35_SS_PLL_ENABLE	0x00a0
+
+#define A35_SS_CHGCLKREQ_ARM_CHGCLKREQ		BIT(0)
+#define A35_SS_CHGCLKREQ_ARM_CHGCLKACK		BIT(1)
+
+#define A35_SS_PLL_FREQ1_FBDIV_MASK		GENMASK(11, 0)
+#define A35_SS_PLL_FREQ1_FBDIV_SHIFT		0
+#define A35_SS_PLL_FREQ1_REFDIV_MASK		GENMASK(21, 16)
+#define A35_SS_PLL_FREQ1_REFDIV_SHIFT		16
+
+#define A35_SS_PLL_FREQ2_POSTDIV1_MASK		GENMASK(2, 0)
+#define A35_SS_PLL_FREQ2_POSTDIV1_SHIFT		0
+#define A35_SS_PLL_FREQ2_POSTDIV2_MASK		GENMASK(5, 3)
+#define A35_SS_PLL_FREQ2_POSTDIV2_SHIFT		3
+
+#define A35_SS_PLL_ENABLE_PD			BIT(0)
+#define A35_SS_PLL_ENABLE_LOCKP			BIT(1)
+#define A35_SS_PLL_ENABLE_NRESET_SWPLL_FF	BIT(2)
+
+#define TIMEOUT_US_200MS	U(200000)
+#define TIMEOUT_US_1S		U(1000000)
+
+#define PLLRDY_TIMEOUT		TIMEOUT_US_200MS
+#define CLKSRC_TIMEOUT		TIMEOUT_US_200MS
+#define CLKDIV_TIMEOUT		TIMEOUT_US_200MS
+#define OSCRDY_TIMEOUT		TIMEOUT_US_1S
+
+/* PLL minimal frequencies for clock sources */
+#define PLL_REFCLK_MIN			UL(5000000)
+#define PLL_FRAC_REFCLK_MIN		UL(10000000)
+
+#define XBAR_CHANNEL_NB			64
+
+/* Warning, should be start to 1 */
+enum clock {
+	_CK_0_MHZ,
+
+	/* ROOT CLOCKS */
+	_CK_HSI,
+	_CK_HSE,
+	_CK_MSI,
+	_CK_LSI,
+	_CK_LSE,
+	_I2SCKIN,
+	_SPDIFSYMB,
+	_CK_PLL1,
+	_CK_PLL2,
+	_CK_PLL3,
+	_CK_PLL4,
+	_CK_PLL5,
+	_CK_PLL6,
+	_CK_PLL7,
+	_CK_PLL8,
+	_CK_HSE_RTC,
+	_CK_RTCCK,
+	_CK_ICN_HS_MCU,
+	_CK_ICN_SDMMC,
+	_CK_ICN_DDR,
+	_CK_ICN_HSL,
+	_CK_ICN_NIC,
+	_CK_ICN_LS_MCU,
+	_CK_FLEXGEN_07,
+	_CK_FLEXGEN_08,
+	_CK_FLEXGEN_09,
+	_CK_FLEXGEN_10,
+	_CK_FLEXGEN_11,
+	_CK_FLEXGEN_12,
+	_CK_FLEXGEN_13,
+	_CK_FLEXGEN_14,
+	_CK_FLEXGEN_15,
+	_CK_FLEXGEN_16,
+	_CK_FLEXGEN_17,
+	_CK_FLEXGEN_18,
+	_CK_FLEXGEN_19,
+	_CK_FLEXGEN_20,
+	_CK_FLEXGEN_21,
+	_CK_FLEXGEN_22,
+	_CK_FLEXGEN_23,
+	_CK_FLEXGEN_24,
+	_CK_FLEXGEN_25,
+	_CK_FLEXGEN_26,
+	_CK_FLEXGEN_27,
+	_CK_FLEXGEN_28,
+	_CK_FLEXGEN_29,
+	_CK_FLEXGEN_30,
+	_CK_FLEXGEN_31,
+	_CK_FLEXGEN_32,
+	_CK_FLEXGEN_33,
+	_CK_FLEXGEN_34,
+	_CK_FLEXGEN_35,
+	_CK_FLEXGEN_36,
+	_CK_FLEXGEN_37,
+	_CK_FLEXGEN_38,
+	_CK_FLEXGEN_39,
+	_CK_FLEXGEN_40,
+	_CK_FLEXGEN_41,
+	_CK_FLEXGEN_42,
+	_CK_FLEXGEN_43,
+	_CK_FLEXGEN_44,
+	_CK_FLEXGEN_45,
+	_CK_FLEXGEN_46,
+	_CK_FLEXGEN_47,
+	_CK_FLEXGEN_48,
+	_CK_FLEXGEN_49,
+	_CK_FLEXGEN_50,
+	_CK_FLEXGEN_51,
+	_CK_FLEXGEN_52,
+	_CK_FLEXGEN_53,
+	_CK_FLEXGEN_54,
+	_CK_FLEXGEN_55,
+	_CK_FLEXGEN_56,
+	_CK_FLEXGEN_57,
+	_CK_FLEXGEN_58,
+	_CK_FLEXGEN_59,
+	_CK_FLEXGEN_60,
+	_CK_FLEXGEN_61,
+	_CK_FLEXGEN_62,
+	_CK_FLEXGEN_63,
+	_CK_ICN_APB1,
+	_CK_ICN_APB2,
+	_CK_ICN_APB3,
+	_CK_ICN_APB4,
+	_CK_ICN_APBDBG,
+	_CK_BKPSRAM,
+	_CK_BSEC,
+	_CK_CRC,
+	_CK_CRYP1,
+	_CK_CRYP2,
+	_CK_DDR,
+	_CK_DDRCAPB,
+	_CK_DDRCP,
+	_CK_DDRPHYC,
+	_CK_FMC,
+	_CK_GPIOA,
+	_CK_GPIOB,
+	_CK_GPIOC,
+	_CK_GPIOD,
+	_CK_GPIOE,
+	_CK_GPIOF,
+	_CK_GPIOG,
+	_CK_GPIOH,
+	_CK_GPIOI,
+	_CK_GPIOJ,
+	_CK_GPIOK,
+	_CK_GPIOZ,
+	_CK_HASH,
+	_CK_I2C1,
+	_CK_I2C2,
+	_CK_I2C3,
+	_CK_I2C4,
+	_CK_I2C5,
+	_CK_I2C6,
+	_CK_I2C7,
+	_CK_I2C8,
+	_CK_IWDG1,
+	_CK_IWDG2,
+	_CK_OSPI1,
+	_CK_OSPI2,
+	_CK_OSPIIOM,
+	_CK_PKA,
+	_CK_RETRAM,
+	_CK_RNG,
+	_CK_RTC,
+	_CK_SAES,
+	_CK_SDMMC1,
+	_CK_SDMMC2,
+	_CK_SRAM1,
+	_CK_SRAM2,
+	_CK_STGEN,
+	_CK_SYSCPU1,
+	_CK_SYSRAM,
+	_CK_UART4,
+	_CK_UART5,
+	_CK_UART7,
+	_CK_UART8,
+	_CK_UART9,
+	_CK_USART1,
+	_CK_USART2,
+	_CK_USART3,
+	_CK_USART6,
+	_CK_USB2EHCI,
+	_CK_USB2OHCI,
+	_CK_USB2PHY1,
+	_CK_USB2PHY2,
+	_CK_USB3DR,
+	_CK_USB3PCIEPHY,
+	_CK_USBTC,
+
+	CK_LAST
+};
+
+static const uint16_t muxsel_src[] = {
+	_CK_HSI, _CK_HSE, _CK_MSI, _CK_0_MHZ
+};
+
+static const uint16_t xbarsel_src[] = {
+	_CK_PLL4, _CK_PLL5, _CK_PLL6, _CK_PLL7, _CK_PLL8,
+	_CK_HSI, _CK_HSE, _CK_MSI, _CK_HSI, _CK_HSE, _CK_MSI,
+	_SPDIFSYMB, _I2SCKIN, _CK_LSI, _CK_LSE
+};
+
+static const uint16_t rtc_src[] = {
+	_CK_0_MHZ, _CK_LSE, _CK_LSI, _CK_HSE_RTC
+};
+
+static const uint16_t usb2phy1_src[] = {
+	_CK_FLEXGEN_57, _CK_HSE
+};
+
+static const uint16_t usb2phy2_src[] = {
+	_CK_FLEXGEN_58, _CK_HSE
+};
+
+static const uint16_t usb3pciphy_src[] = {
+	_CK_FLEXGEN_34, _CK_HSE
+};
+
+static const uint16_t d3per_src[] = {
+	_CK_MSI, _CK_LSI, _CK_LSE
+};
+
+#undef MUX_CFG
+#define MUX_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+	.id_parents	= src,\
+	.num_parents	= ARRAY_SIZE(src),\
+	.mux		= &(struct mux_cfg) {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_witdh),\
+		.bitrdy = UINT8_MAX,\
+	},\
+}
+
+static const struct parent_cfg parent_mp25[] = {
+	MUX_CFG(MUX_MUXSEL0, muxsel_src, RCC_MUXSELCFGR, 0, 2),
+	MUX_CFG(MUX_MUXSEL1, muxsel_src, RCC_MUXSELCFGR, 4, 2),
+	MUX_CFG(MUX_MUXSEL2, muxsel_src, RCC_MUXSELCFGR, 8, 2),
+	MUX_CFG(MUX_MUXSEL3, muxsel_src, RCC_MUXSELCFGR, 12, 2),
+	MUX_CFG(MUX_MUXSEL4, muxsel_src, RCC_MUXSELCFGR, 16, 2),
+	MUX_CFG(MUX_MUXSEL5, muxsel_src, RCC_MUXSELCFGR, 20, 2),
+	MUX_CFG(MUX_MUXSEL6, muxsel_src, RCC_MUXSELCFGR, 24, 2),
+	MUX_CFG(MUX_MUXSEL7, muxsel_src, RCC_MUXSELCFGR, 28, 2),
+	MUX_CFG(MUX_XBARSEL, xbarsel_src, RCC_XBAR0CFGR, 0, 4),
+	MUX_CFG(MUX_RTC, rtc_src, RCC_BDCR, 16, 2),
+	MUX_CFG(MUX_USB2PHY1, usb2phy1_src, RCC_USB2PHY1CFGR, 15, 1),
+	MUX_CFG(MUX_USB2PHY2, usb2phy2_src, RCC_USB2PHY2CFGR, 15, 1),
+	MUX_CFG(MUX_USB3PCIEPHY, usb3pciphy_src, RCC_USB3PCIEPHYCFGR, 15, 1),
+	MUX_CFG(MUX_D3PER, d3per_src, RCC_D3DCR, 16, 2),
+};
+
+/* GATES */
+enum enum_gate_cfg {
+	GATE_ZERO, /* reserved for no gate */
+	GATE_LSE,
+	GATE_RTCCK,
+	GATE_LSI,
+	GATE_HSI,
+	GATE_MSI,
+	GATE_HSE,
+	GATE_LSI_RDY,
+	GATE_MSI_RDY,
+	GATE_LSE_RDY,
+	GATE_HSE_RDY,
+	GATE_HSI_RDY,
+	GATE_SYSRAM,
+	GATE_RETRAM,
+	GATE_SRAM1,
+	GATE_SRAM2,
+
+	GATE_DDRPHYC,
+	GATE_SYSCPU1,
+	GATE_CRC,
+	GATE_OSPIIOM,
+	GATE_BKPSRAM,
+	GATE_HASH,
+	GATE_RNG,
+	GATE_CRYP1,
+	GATE_CRYP2,
+	GATE_SAES,
+	GATE_PKA,
+
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_GPIOJ,
+	GATE_GPIOK,
+	GATE_GPIOZ,
+	GATE_RTC,
+
+	GATE_DDRCP,
+
+	/* WARNING 2 CLOCKS FOR ONE GATE */
+	GATE_USB2OHCI,
+	GATE_USB2EHCI,
+
+	GATE_USB3DR,
+
+	GATE_BSEC,
+	GATE_IWDG1,
+	GATE_IWDG2,
+
+	GATE_DDRCAPB,
+	GATE_DDR,
+
+	GATE_USART2,
+	GATE_UART4,
+	GATE_USART3,
+	GATE_UART5,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C5,
+	GATE_I2C4,
+	GATE_I2C6,
+	GATE_I2C7,
+	GATE_USART1,
+	GATE_USART6,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_UART9,
+	GATE_STGEN,
+	GATE_USB3PCIEPHY,
+	GATE_USBTC,
+	GATE_I2C8,
+	GATE_OSPI1,
+	GATE_OSPI2,
+	GATE_FMC,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_USB2PHY1,
+	GATE_USB2PHY2,
+	LAST_GATE
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)[id] = {\
+	.offset		= (_offset),\
+	.bit_idx	= (_bit_idx),\
+	.set_clr	= (_offset_clr),\
+}
+
+/* TODO : ADD MCO... ETH */
+static const struct gate_cfg gates_mp25[LAST_GATE] = {
+	GATE_CFG(GATE_LSE,		RCC_BDCR,		0,	0),
+	GATE_CFG(GATE_LSI,		RCC_BDCR,		9,	0),
+	GATE_CFG(GATE_RTCCK,		RCC_BDCR,		20,	0),
+	GATE_CFG(GATE_HSI,		RCC_OCENSETR,		0,	1),
+	GATE_CFG(GATE_HSE,		RCC_OCENSETR,		8,	1),
+	GATE_CFG(GATE_MSI,		RCC_D3DCR,		0,	0),
+
+	GATE_CFG(GATE_LSI_RDY,		RCC_BDCR,		10,	0),
+	GATE_CFG(GATE_LSE_RDY,		RCC_BDCR,		2,	0),
+	GATE_CFG(GATE_MSI_RDY,		RCC_D3DCR,		2,	0),
+	GATE_CFG(GATE_HSE_RDY,		RCC_OCRDYR,		8,	0),
+	GATE_CFG(GATE_HSI_RDY,		RCC_OCRDYR,		0,	0),
+	GATE_CFG(GATE_SYSRAM,		RCC_SYSRAMCFGR,		1,	0),
+	GATE_CFG(GATE_RETRAM,		RCC_RETRAMCFGR,		1,	0),
+	GATE_CFG(GATE_SRAM1,		RCC_SRAM1CFGR,		1,	0),
+	GATE_CFG(GATE_SRAM2,		RCC_SRAM2CFGR,		1,	0),
+	GATE_CFG(GATE_DDRPHYC,		RCC_DDRPHYCAPBCFGR,	1,	0),
+	GATE_CFG(GATE_SYSCPU1,		RCC_SYSCPU1CFGR,	1,	0),
+	GATE_CFG(GATE_CRC,		RCC_CRCCFGR,		1,	0),
+	GATE_CFG(GATE_OSPIIOM,		RCC_OSPIIOMCFGR,	1,	0),
+	GATE_CFG(GATE_BKPSRAM,		RCC_BKPSRAMCFGR,	1,	0),
+	GATE_CFG(GATE_HASH,		RCC_HASHCFGR,		1,	0),
+	GATE_CFG(GATE_RNG,		RCC_RNGCFGR,		1,	0),
+	GATE_CFG(GATE_CRYP1,		RCC_CRYP1CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP2,		RCC_CRYP2CFGR,		1,	0),
+	GATE_CFG(GATE_SAES,		RCC_SAESCFGR,		1,	0),
+	GATE_CFG(GATE_PKA,		RCC_PKACFGR,		1,	0),
+	GATE_CFG(GATE_GPIOA,		RCC_GPIOACFGR,		1,	0),
+	GATE_CFG(GATE_GPIOB,		RCC_GPIOBCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOC,		RCC_GPIOCCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOD,		RCC_GPIODCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOE,		RCC_GPIOECFGR,		1,	0),
+	GATE_CFG(GATE_GPIOF,		RCC_GPIOFCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOG,		RCC_GPIOGCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOH,		RCC_GPIOHCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOI,		RCC_GPIOICFGR,		1,	0),
+	GATE_CFG(GATE_GPIOJ,		RCC_GPIOJCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOK,		RCC_GPIOKCFGR,		1,	0),
+	GATE_CFG(GATE_GPIOZ,		RCC_GPIOZCFGR,		1,	0),
+	GATE_CFG(GATE_RTC,		RCC_RTCCFGR,		1,	0),
+	GATE_CFG(GATE_DDRCP,		RCC_DDRCPCFGR,		1,	0),
+
+	/* WARNING 2 CLOCKS FOR ONE GATE */
+	GATE_CFG(GATE_USB2OHCI,		RCC_USB2CFGR,		1,	0),
+	GATE_CFG(GATE_USB2EHCI,		RCC_USB2CFGR,		1,	0),
+	GATE_CFG(GATE_USB3DR,		RCC_USB3DRCFGR,		1,	0),
+	GATE_CFG(GATE_BSEC,		RCC_BSECCFGR,		1,	0),
+	GATE_CFG(GATE_IWDG1,		RCC_IWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG2,		RCC_IWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_DDRCAPB,		RCC_DDRCAPBCFGR,	1,	0),
+	GATE_CFG(GATE_DDR,		RCC_DDRCFGR,		1,	0),
+	GATE_CFG(GATE_USART2,		RCC_USART2CFGR,		1,	0),
+	GATE_CFG(GATE_UART4,		RCC_UART4CFGR,		1,	0),
+	GATE_CFG(GATE_USART3,		RCC_USART3CFGR,		1,	0),
+	GATE_CFG(GATE_UART5,		RCC_UART5CFGR,		1,	0),
+	GATE_CFG(GATE_I2C1,		RCC_I2C1CFGR,		1,	0),
+	GATE_CFG(GATE_I2C2,		RCC_I2C2CFGR,		1,	0),
+	GATE_CFG(GATE_I2C3,		RCC_I2C3CFGR,		1,	0),
+	GATE_CFG(GATE_I2C5,		RCC_I2C5CFGR,		1,	0),
+	GATE_CFG(GATE_I2C4,		RCC_I2C4CFGR,		1,	0),
+	GATE_CFG(GATE_I2C6,		RCC_I2C6CFGR,		1,	0),
+	GATE_CFG(GATE_I2C7,		RCC_I2C7CFGR,		1,	0),
+	GATE_CFG(GATE_USART1,		RCC_USART1CFGR,		1,	0),
+	GATE_CFG(GATE_USART6,		RCC_USART6CFGR,		1,	0),
+	GATE_CFG(GATE_UART7,		RCC_UART7CFGR,		1,	0),
+	GATE_CFG(GATE_UART8,		RCC_UART8CFGR,		1,	0),
+	GATE_CFG(GATE_UART9,		RCC_UART9CFGR,		1,	0),
+	GATE_CFG(GATE_STGEN,		RCC_STGENCFGR,		1,	0),
+	GATE_CFG(GATE_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	1,	0),
+	GATE_CFG(GATE_USBTC,		RCC_USBTCCFGR,		1,	0),
+	GATE_CFG(GATE_I2C8,		RCC_I2C8CFGR,		1,	0),
+	GATE_CFG(GATE_OSPI1,		RCC_OSPI1CFGR,		1,	0),
+	GATE_CFG(GATE_OSPI2,		RCC_OSPI2CFGR,		1,	0),
+	GATE_CFG(GATE_FMC,		RCC_FMCCFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC1,		RCC_SDMMC1CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC2,		RCC_SDMMC2CFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY1,		RCC_USB2PHY1CFGR,	1,	0),
+	GATE_CFG(GATE_USB2PHY2,		RCC_USB2PHY2CFGR,	1,	0),
+};
+
+static const struct clk_div_table apb_div_table[] = {
+	{ 0, 1 },  { 1, 2 },  { 2, 4 },  { 3, 8 }, { 4, 16 },
+	{ 5, 16 }, { 6, 16 }, { 7, 16 }, { 0 },
+};
+
+#undef DIV_CFG
+#define DIV_CFG(id, _offset, _shift, _width, _flags, _table, _bitrdy)[id] = {\
+		.offset	= _offset,\
+		.shift	= _shift,\
+		.width	= _width,\
+		.flags	= _flags,\
+		.table	= _table,\
+		.bitrdy	= _bitrdy,\
+}
+
+static const struct div_cfg dividers_mp25[] = {
+	DIV_CFG(DIV_APB1, RCC_APB1DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB2, RCC_APB2DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB3, RCC_APB3DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APB4, RCC_APB4DIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_APBDBG, RCC_APBDBGDIVR, 0, 3, 0, apb_div_table, 31),
+	DIV_CFG(DIV_LSMCU, RCC_LSMCUDIVR, 0, 1, 0, NULL, 31),
+	DIV_CFG(DIV_RTC, RCC_RTCDIVR, 0, 6, 0, NULL, 0),
+};
+
+enum stm32_osc {
+	OSC_HSI,
+	OSC_HSE,
+	OSC_MSI,
+	OSC_LSI,
+	OSC_LSE,
+	OSC_I2SCKIN,
+	OSC_SPDIFSYMB,
+	NB_OSCILLATOR
+};
+
+static struct clk_oscillator_data stm32mp25_osc_data[] = {
+	OSCILLATOR(OSC_HSI, _CK_HSI, "clk-hsi", GATE_HSI, GATE_HSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_LSI, _CK_LSI, "clk-lsi", GATE_LSI, GATE_LSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_MSI, _CK_MSI, "clk-msi", GATE_MSI, GATE_MSI_RDY,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_HSE, _CK_HSE, "clk-hse", GATE_HSE, GATE_HSE_RDY,
+		   BYPASS(RCC_OCENSETR, 10, 7),
+		   CSS(RCC_OCENSETR, 11),
+		   NULL),
+
+	OSCILLATOR(OSC_LSE, _CK_LSE, "clk-lse", GATE_LSE, GATE_LSE_RDY,
+		   BYPASS(RCC_BDCR, 1, 3),
+		   CSS(RCC_BDCR, 8),
+		   DRIVE(RCC_BDCR, 4, 2, 2)),
+
+	OSCILLATOR(OSC_I2SCKIN, _I2SCKIN, "i2s_ckin", NO_GATE, NO_GATE,
+		   NULL, NULL, NULL),
+
+	OSCILLATOR(OSC_SPDIFSYMB, _SPDIFSYMB, "spdif_symb", NO_GATE, NO_GATE,
+		   NULL, NULL, NULL),
+};
+
+#ifdef IMAGE_BL2
+static const char *clk_stm32_get_oscillator_name(enum stm32_osc id)
+{
+	if (id < NB_OSCILLATOR) {
+		return stm32mp25_osc_data[id].name;
+	}
+
+	return NULL;
+}
+#endif
+
+enum pll_id {
+	_PLL1,
+	_PLL2,
+	_PLL3,
+	_PLL4,
+	_PLL5,
+	_PLL6,
+	_PLL7,
+	_PLL8,
+	_PLL_NB
+};
+
+/* PLL configuration registers offsets from RCC_PLLxCFGR1 */
+#define RCC_OFFSET_PLLXCFGR1		0x00
+#define RCC_OFFSET_PLLXCFGR2		0x04
+#define RCC_OFFSET_PLLXCFGR3		0x08
+#define RCC_OFFSET_PLLXCFGR4		0x0C
+#define RCC_OFFSET_PLLXCFGR5		0x10
+#define RCC_OFFSET_PLLXCFGR6		0x18
+#define RCC_OFFSET_PLLXCFGR7		0x1C
+
+struct stm32_clk_pll {
+	uint16_t clk_id;
+	uint16_t reg_pllxcfgr1;
+};
+
+#define CLK_PLL_CFG(_idx, _clk_id, _reg)\
+	[(_idx)] = {\
+		.clk_id = (_clk_id),\
+		.reg_pllxcfgr1 = (_reg),\
+	}
+
+static const struct stm32_clk_pll stm32mp25_clk_pll[_PLL_NB] = {
+	CLK_PLL_CFG(_PLL1, _CK_PLL1, A35_SS_CHGCLKREQ),
+	CLK_PLL_CFG(_PLL2, _CK_PLL2, RCC_PLL2CFGR1),
+	CLK_PLL_CFG(_PLL3, _CK_PLL3, RCC_PLL3CFGR1),
+	CLK_PLL_CFG(_PLL4, _CK_PLL4, RCC_PLL4CFGR1),
+	CLK_PLL_CFG(_PLL5, _CK_PLL5, RCC_PLL5CFGR1),
+	CLK_PLL_CFG(_PLL6, _CK_PLL6, RCC_PLL6CFGR1),
+	CLK_PLL_CFG(_PLL7, _CK_PLL7, RCC_PLL7CFGR1),
+	CLK_PLL_CFG(_PLL8, _CK_PLL8, RCC_PLL8CFGR1),
+};
+
+static const struct stm32_clk_pll *clk_stm32_pll_data(unsigned int idx)
+{
+	return &stm32mp25_clk_pll[idx];
+}
+
+static unsigned long clk_get_pll_fvco(struct stm32_clk_priv *priv,
+				      const struct stm32_clk_pll *pll,
+				      unsigned long prate)
+{
+	unsigned long refclk, fvco;
+	uint32_t fracin, fbdiv, refdiv;
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr2 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR2;
+	uintptr_t pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+
+	refclk = prate;
+
+	fracin = mmio_read_32(pllxcfgr3) & RCC_PLLxCFGR3_FRACIN_MASK;
+	fbdiv = (mmio_read_32(pllxcfgr2) & RCC_PLLxCFGR2_FBDIV_MASK) >>
+		RCC_PLLxCFGR2_FBDIV_SHIFT;
+	refdiv = mmio_read_32(pllxcfgr2) & RCC_PLLxCFGR2_FREFDIV_MASK;
+
+	if (fracin != 0U) {
+		unsigned long long numerator, denominator;
+
+		numerator = ((unsigned long long)fbdiv << 24) + fracin;
+		numerator = refclk * numerator;
+		denominator = (unsigned long long)refdiv << 24;
+		fvco = (unsigned long)(numerator / denominator);
+	} else {
+		fvco = (unsigned long)(refclk * fbdiv / refdiv);
+	}
+
+	return fvco;
+}
+
+struct stm32_pll_cfg {
+	uint16_t pll_id;
+};
+
+static bool _clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+
+	return ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_PLLEN) != 0U);
+}
+
+static void _clk_stm32_pll_set_on(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+
+	mmio_setbits_32(pllxcfgr1, RCC_PLLxCFGR1_PLLEN);
+}
+
+static void _clk_stm32_pll_set_off(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+
+	/* Stop PLL */
+	mmio_clrbits_32(pllxcfgr1, RCC_PLLxCFGR1_PLLEN);
+}
+
+static int _clk_stm32_pll_wait_ready_on(struct stm32_clk_priv *priv,
+					const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	/* Wait PLL lock */
+	while ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_PLLRDY) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("CLK %d : PLL start failed @ 0x%x: 0x%x\n",
+			      pll->clk_id, pll->reg_pllxcfgr1, mmio_read_32(pllxcfgr1));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_wait_ready_off(struct stm32_clk_priv *priv,
+					 const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	/* Wait PLL stopped */
+	while ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_PLLRDY) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("PLL%d stop failed @ 0x%lx: 0x%x\n",
+			      pll->clk_id, pllxcfgr1, mmio_read_32(pllxcfgr1));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_enable(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	if (_clk_stm32_pll_is_enabled(priv, pll)) {
+		return 0;
+	}
+
+	_clk_stm32_pll_set_on(priv, pll);
+
+	return _clk_stm32_pll_wait_ready_on(priv, pll);
+}
+
+static void _clk_stm32_pll_disable(struct stm32_clk_priv *priv, const struct stm32_clk_pll *pll)
+{
+	if (!_clk_stm32_pll_is_enabled(priv, pll)) {
+		return;
+	}
+
+	_clk_stm32_pll_set_off(priv, pll);
+
+	_clk_stm32_pll_wait_ready_off(priv, pll);
+}
+
+static bool clk_stm32_pll_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+
+	return _clk_stm32_pll_is_enabled(priv, pll);
+}
+
+static int clk_stm32_pll_enable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+
+	return _clk_stm32_pll_enable(priv, pll);
+}
+
+static void clk_stm32_pll_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+
+	_clk_stm32_pll_disable(priv, pll);
+}
+
+static unsigned long clk_stm32_pll_recalc_rate(struct stm32_clk_priv *priv, int id,
+					       unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_pll_cfg *pll_cfg = clk->clock_cfg;
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_cfg->pll_id);
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	uintptr_t pllxcfgr6 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR6;
+	uintptr_t pllxcfgr7 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR7;
+	unsigned long dfout;
+	uint32_t postdiv1, postdiv2;
+
+	postdiv1 = mmio_read_32(pllxcfgr6) & RCC_PLLxCFGR6_POSTDIV1_MASK;
+	postdiv2 = mmio_read_32(pllxcfgr7) & RCC_PLLxCFGR7_POSTDIV2_MASK;
+
+	if ((mmio_read_32(pllxcfgr4) & RCC_PLLxCFGR4_BYPASS) != 0U) {
+		dfout = prate;
+	} else {
+		if ((postdiv1 == 0U) || (postdiv2 == 0U)) {
+			dfout = prate;
+		} else {
+			dfout = clk_get_pll_fvco(priv, pll, prate) / (postdiv1 * postdiv2);
+		}
+	}
+
+	return dfout;
+}
+
+static const struct stm32_clk_ops clk_stm32_pll_ops = {
+	.recalc_rate	= clk_stm32_pll_recalc_rate,
+	.enable		= clk_stm32_pll_enable,
+	.disable	= clk_stm32_pll_disable,
+	.is_enabled	= clk_stm32_pll_is_enabled,
+};
+
+#define CLK_PLL(idx, _idx, _parent, _pll_id, _flags)[idx] = {\
+	.binding	= _idx,\
+	.parent		= _parent,\
+	.flags		= (_flags),\
+	.clock_cfg	= &(struct stm32_pll_cfg) {\
+		.pll_id	= _pll_id,\
+	},\
+	.ops		= STM32_PLL_OPS,\
+}
+
+static unsigned long clk_get_pll1_fvco(unsigned long refclk)
+{
+	uintptr_t pll_freq1_reg = A35SSC_BASE + A35_SS_PLL_FREQ1;
+	uint32_t reg, fbdiv, refdiv;
+
+	reg = mmio_read_32(pll_freq1_reg);
+
+	fbdiv = (reg & A35_SS_PLL_FREQ1_FBDIV_MASK) >> A35_SS_PLL_FREQ1_FBDIV_SHIFT;
+	refdiv = (reg & A35_SS_PLL_FREQ1_REFDIV_MASK) >> A35_SS_PLL_FREQ1_REFDIV_SHIFT;
+
+	return (unsigned long)(refclk * fbdiv / refdiv);
+}
+
+static unsigned long clk_stm32_pll1_recalc_rate(struct stm32_clk_priv *priv,
+						int id, unsigned long prate)
+{
+	uintptr_t pll_freq2_reg = A35SSC_BASE + A35_SS_PLL_FREQ2;
+	uint32_t postdiv1, postdiv2;
+	unsigned long dfout;
+
+	postdiv1 = (mmio_read_32(pll_freq2_reg) & A35_SS_PLL_FREQ2_POSTDIV1_MASK) >>
+		   A35_SS_PLL_FREQ2_POSTDIV1_SHIFT;
+	postdiv2 = (mmio_read_32(pll_freq2_reg) & A35_SS_PLL_FREQ2_POSTDIV2_MASK) >>
+		   A35_SS_PLL_FREQ2_POSTDIV2_SHIFT;
+
+	if ((postdiv1 == 0U) || (postdiv2 == 0U)) {
+		dfout = prate;
+	} else {
+		dfout = clk_get_pll1_fvco(prate) / (postdiv1 * postdiv2);
+	}
+
+	return dfout;
+}
+
+static const struct stm32_clk_ops clk_stm32_pll1_ops = {
+	.recalc_rate = clk_stm32_pll1_recalc_rate,
+};
+
+#define CLK_PLL1(idx, _idx, _parent, _pll_id, _flags)[idx] = {\
+	.binding	= _idx,\
+	.parent		= _parent,\
+	.flags		= (_flags),\
+	.clock_cfg	= &(struct stm32_pll_cfg) {\
+		.pll_id	= _pll_id,\
+	},\
+	.ops		= STM32_PLL1_OPS,\
+}
+
+struct stm32_clk_flexgen_cfg {
+	uint8_t id;
+};
+
+static unsigned long clk_flexgen_recalc(struct stm32_clk_priv *priv, int idx,
+					unsigned long prate)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint32_t prediv, findiv;
+	uint8_t channel = cfg->id;
+	unsigned long freq = prate;
+
+	prediv = mmio_read_32(rcc_base + RCC_PREDIV0CFGR + (0x4U * channel)) &
+		RCC_PREDIVxCFGR_PREDIVx_MASK;
+	findiv = mmio_read_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel)) &
+		RCC_FINDIVxCFGR_FINDIVx_MASK;
+
+	if (freq == 0UL) {
+		return 0U;
+	}
+
+	switch (prediv) {
+	case 0x0:
+	case 0x1:
+	case 0x3:
+	case 0x3FF:
+		break;
+
+	default:
+		ERROR("Unsupported PREDIV value (%x)\n", prediv);
+		panic();
+		break;
+	}
+
+	freq /= (prediv + 1U);
+	freq /= (findiv + 1U);
+
+	return freq;
+}
+
+static int clk_flexgen_get_parent(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uint32_t sel;
+	uint32_t address;
+	uintptr_t rcc_base = priv->base;
+
+	address = RCC_XBAR0CFGR + (cfg->id * 4);
+
+	sel = mmio_read_32(rcc_base + address) & RCC_XBARxCFGR_XBARxSEL_MASK;
+
+	return sel;
+}
+
+static int clk_flexgen_gate_enable(struct stm32_clk_priv *priv, int idx)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, idx);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint8_t channel = cfg->id;
+
+	mmio_setbits_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel),
+			RCC_FINDIVxCFGR_FINDIVxEN);
+
+	return 0;
+}
+
+static void clk_flexgen_gate_disable(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint8_t channel = cfg->id;
+
+	mmio_clrbits_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel),
+			RCC_FINDIVxCFGR_FINDIVxEN);
+}
+
+static bool clk_flexgen_gate_is_enabled(struct stm32_clk_priv *priv, int id)
+{
+	const struct clk_stm32 *clk = _clk_get(priv, id);
+	struct stm32_clk_flexgen_cfg *cfg = clk->clock_cfg;
+	uintptr_t rcc_base = priv->base;
+	uint8_t channel = cfg->id;
+
+	return !!(mmio_read_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel)) &
+		RCC_FINDIVxCFGR_FINDIVxEN);
+}
+
+static const struct stm32_clk_ops clk_stm32_flexgen_ops = {
+	.recalc_rate = clk_flexgen_recalc,
+	.get_parent = clk_flexgen_get_parent,
+	.enable = clk_flexgen_gate_enable,
+	.disable = clk_flexgen_gate_disable,
+	.is_enabled = clk_flexgen_gate_is_enabled,
+};
+
+#define FLEXGEN(idx, _idx, _flags, _id)[idx] = {\
+	.binding = _idx,\
+	.parent =  MUX(MUX_XBARSEL),\
+	.flags = (_flags),\
+	.clock_cfg	= &(struct stm32_clk_flexgen_cfg) {\
+		.id	= _id,\
+	},\
+	.ops = STM32_FLEXGEN_OPS,\
+}
+
+#define RCC_0_MHZ	UL(0)
+#define RCC_4_MHZ	UL(4000000)
+#define RCC_16_MHZ	UL(16000000)
+
+#ifdef IMAGE_BL2
+#if !STM32MP_M33_TDCID
+static int clk_stm32_osc_msi_set_rate(struct stm32_clk_priv *priv, int id, unsigned long rate,
+				      unsigned long prate)
+{
+	uintptr_t address = priv->base + RCC_BDCR;
+	uint32_t mask = RCC_BDCR_MSIFREQSEL;
+	int ret = -1;
+
+	switch (rate) {
+	case RCC_4_MHZ:
+		mmio_clrbits_32(address, mask);
+		ret = 0;
+		break;
+
+	case RCC_16_MHZ:
+		mmio_setbits_32(address, mask);
+		ret = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+#endif
+#endif /* IMAGE_BL2 */
+
+static unsigned long clk_stm32_osc_msi_recalc_rate(struct stm32_clk_priv *priv,
+						   int id __unused,
+						   unsigned long prate __unused)
+{
+	uintptr_t address = priv->base + RCC_BDCR;
+
+	if ((mmio_read_32(address) & RCC_BDCR_MSIFREQSEL) == 0U) {
+		return RCC_4_MHZ;
+	} else {
+		return RCC_16_MHZ;
+	}
+}
+
+static const struct stm32_clk_ops clk_stm32_osc_msi_ops = {
+	.recalc_rate	= clk_stm32_osc_msi_recalc_rate,
+	.is_enabled	= clk_stm32_osc_gate_is_enabled,
+#if !STM32MP_M33_TDCID
+	.enable		= clk_stm32_osc_gate_enable,
+	.disable	= clk_stm32_osc_gate_disable,
+#endif
+	.init		= clk_stm32_osc_init,
+};
+
+#define CLK_OSC_MSI(idx, _idx, _parent, _osc_id) \
+	[(idx)] = (struct clk_stm32){ \
+		.binding	= (_idx),\
+		.parent		= (_parent),\
+		.flags		= CLK_IS_CRITICAL,\
+		.clock_cfg	= &(struct stm32_osc_cfg){\
+			.osc_id = (_osc_id),\
+		},\
+		.ops		= STM32_OSC_MSI_OPS,\
+	}
+
+static const struct stm32_clk_ops clk_stm32_rtc_ops = {
+	.enable = clk_stm32_gate_enable,
+	.disable = clk_stm32_gate_disable,
+	.is_enabled = clk_stm32_gate_is_enabled,
+};
+
+#define CLK_RTC(idx, _binding, _parent, _flags, _gate_id)[idx] = {\
+	.binding = (_binding),\
+	.parent =  (_parent),\
+	.flags = (_flags),\
+	.clock_cfg	= &(struct clk_stm32_gate_cfg) {\
+		.id	= (_gate_id),\
+	},\
+	.ops = STM32_RTC_OPS,\
+}
+
+enum {
+	STM32_PLL_OPS = STM32_LAST_OPS,
+	STM32_PLL1_OPS,
+	STM32_FLEXGEN_OPS,
+	STM32_OSC_MSI_OPS,
+	STM32_RTC_OPS,
+
+	MP25_LAST_OPS
+};
+
+static const struct stm32_clk_ops *ops_array_mp25[MP25_LAST_OPS] = {
+	[NO_OPS] =  NULL,
+	[FIXED_FACTOR_OPS] = &clk_fixed_factor_ops,
+	[GATE_OPS] = &clk_gate_ops,
+	[STM32_MUX_OPS] = &clk_mux_ops,
+	[STM32_DIVIDER_OPS] = &clk_stm32_divider_ops,
+	[STM32_GATE_OPS] = &clk_stm32_gate_ops,
+	[STM32_TIMER_OPS] = &clk_timer_ops,
+	[STM32_FIXED_RATE_OPS] = &clk_stm32_fixed_rate_ops,
+	[STM32_OSC_OPS] = &clk_stm32_osc_ops,
+	[STM32_OSC_NOGATE_OPS] = &clk_stm32_osc_nogate_ops,
+
+	[STM32_PLL_OPS] = &clk_stm32_pll_ops,
+	[STM32_PLL1_OPS] = &clk_stm32_pll1_ops,
+	[STM32_FLEXGEN_OPS] = &clk_stm32_flexgen_ops,
+	[STM32_OSC_MSI_OPS] = &clk_stm32_osc_msi_ops,
+	[STM32_RTC_OPS] = &clk_stm32_rtc_ops
+};
+
+static const struct clk_stm32 stm32mp25_clk[CK_LAST] = {
+	CLK_FIXED_RATE(_CK_0_MHZ, _NO_ID, RCC_0_MHZ),
+
+	/* ROOT CLOCKS */
+	CLK_OSC(_CK_HSE, HSE_CK, CLK_IS_ROOT, OSC_HSE),
+	CLK_OSC(_CK_LSE, LSE_CK, CLK_IS_ROOT, OSC_LSE),
+	CLK_OSC(_CK_HSI, HSI_CK, CLK_IS_ROOT, OSC_HSI),
+	CLK_OSC(_CK_LSI, LSI_CK, CLK_IS_ROOT, OSC_LSI),
+	CLK_OSC_MSI(_CK_MSI, MSI_CK, CLK_IS_ROOT, OSC_MSI),
+
+	CLK_OSC_FIXED(_I2SCKIN, _NO_ID, CLK_IS_ROOT, OSC_I2SCKIN),
+	CLK_OSC_FIXED(_SPDIFSYMB, _NO_ID, CLK_IS_ROOT, OSC_SPDIFSYMB),
+
+	STM32_DIV(_CK_HSE_RTC, _NO_ID, _CK_HSE, 0, DIV_RTC),
+
+	CLK_RTC(_CK_RTCCK, RTC_CK, MUX(MUX_RTC), 0, GATE_RTCCK),
+
+	CLK_PLL1(_CK_PLL1, PLL1_CK, MUX(MUX_MUXSEL5), _PLL1, 0),
+
+	CLK_PLL(_CK_PLL2, PLL2_CK, MUX(MUX_MUXSEL6), _PLL2, 0),
+	CLK_PLL(_CK_PLL3, PLL3_CK, MUX(MUX_MUXSEL7), _PLL3, 0),
+	CLK_PLL(_CK_PLL4, PLL4_CK, MUX(MUX_MUXSEL0), _PLL4, 0),
+	CLK_PLL(_CK_PLL5, PLL5_CK, MUX(MUX_MUXSEL1), _PLL5, 0),
+	CLK_PLL(_CK_PLL6, PLL6_CK, MUX(MUX_MUXSEL2), _PLL6, 0),
+	CLK_PLL(_CK_PLL7, PLL7_CK, MUX(MUX_MUXSEL3), _PLL7, 0),
+	CLK_PLL(_CK_PLL8, PLL8_CK, MUX(MUX_MUXSEL4), _PLL8, 0),
+
+	FLEXGEN(_CK_ICN_HS_MCU,	CK_ICN_HS_MCU, CLK_IS_CRITICAL, 0),
+	FLEXGEN(_CK_ICN_SDMMC, CK_ICN_SDMMC, CLK_IS_CRITICAL, 1),
+	FLEXGEN(_CK_ICN_DDR, CK_ICN_DDR, CLK_IS_CRITICAL, 2),
+	FLEXGEN(_CK_ICN_HSL, CK_ICN_HSL, CLK_IS_CRITICAL, 4),
+	FLEXGEN(_CK_ICN_NIC, CK_ICN_NIC, CLK_IS_CRITICAL, 5),
+
+	STM32_DIV(_CK_ICN_LS_MCU, CK_ICN_LS_MCU, _CK_ICN_HS_MCU, 0, DIV_LSMCU),
+
+	FLEXGEN(_CK_FLEXGEN_07, CK_FLEXGEN_07, 0, 7),
+	FLEXGEN(_CK_FLEXGEN_08, CK_FLEXGEN_08, 0, 8),
+	FLEXGEN(_CK_FLEXGEN_09, CK_FLEXGEN_09, 0, 9),
+	FLEXGEN(_CK_FLEXGEN_10, CK_FLEXGEN_10, 0, 10),
+	FLEXGEN(_CK_FLEXGEN_11, CK_FLEXGEN_11, 0, 11),
+	FLEXGEN(_CK_FLEXGEN_12, CK_FLEXGEN_12, 0, 12),
+	FLEXGEN(_CK_FLEXGEN_13, CK_FLEXGEN_13, 0, 13),
+	FLEXGEN(_CK_FLEXGEN_14, CK_FLEXGEN_14, 0, 14),
+	FLEXGEN(_CK_FLEXGEN_15, CK_FLEXGEN_15, 0, 15),
+	FLEXGEN(_CK_FLEXGEN_16, CK_FLEXGEN_16, 0, 16),
+	FLEXGEN(_CK_FLEXGEN_17, CK_FLEXGEN_17, 0, 17),
+	FLEXGEN(_CK_FLEXGEN_18, CK_FLEXGEN_18, 0, 18),
+	FLEXGEN(_CK_FLEXGEN_19, CK_FLEXGEN_19, 0, 19),
+	FLEXGEN(_CK_FLEXGEN_20, CK_FLEXGEN_20, 0, 20),
+	FLEXGEN(_CK_FLEXGEN_21, CK_FLEXGEN_21, 0, 21),
+	FLEXGEN(_CK_FLEXGEN_22, CK_FLEXGEN_22, 0, 22),
+	FLEXGEN(_CK_FLEXGEN_23, CK_FLEXGEN_23, 0, 23),
+	FLEXGEN(_CK_FLEXGEN_24, CK_FLEXGEN_24, 0, 24),
+	FLEXGEN(_CK_FLEXGEN_25, CK_FLEXGEN_25, 0, 25),
+	FLEXGEN(_CK_FLEXGEN_26, CK_FLEXGEN_26, 0, 26),
+	FLEXGEN(_CK_FLEXGEN_27, CK_FLEXGEN_27, 0, 27),
+	FLEXGEN(_CK_FLEXGEN_28, CK_FLEXGEN_28, 0, 28),
+	FLEXGEN(_CK_FLEXGEN_29, CK_FLEXGEN_29, 0, 29),
+	FLEXGEN(_CK_FLEXGEN_30, CK_FLEXGEN_30, 0, 30),
+	FLEXGEN(_CK_FLEXGEN_31, CK_FLEXGEN_31, 0, 31),
+	FLEXGEN(_CK_FLEXGEN_32, CK_FLEXGEN_32, 0, 32),
+	FLEXGEN(_CK_FLEXGEN_33, CK_FLEXGEN_33, 0, 33),
+	FLEXGEN(_CK_FLEXGEN_34, CK_FLEXGEN_34, 0, 34),
+	FLEXGEN(_CK_FLEXGEN_35, CK_FLEXGEN_35, 0, 35),
+	FLEXGEN(_CK_FLEXGEN_36, CK_FLEXGEN_36, 0, 36),
+	FLEXGEN(_CK_FLEXGEN_37, CK_FLEXGEN_37, 0, 37),
+	FLEXGEN(_CK_FLEXGEN_38, CK_FLEXGEN_38, 0, 38),
+	FLEXGEN(_CK_FLEXGEN_39, CK_FLEXGEN_39, 0, 39),
+	FLEXGEN(_CK_FLEXGEN_40, CK_FLEXGEN_40, 0, 40),
+	FLEXGEN(_CK_FLEXGEN_41, CK_FLEXGEN_41, 0, 41),
+	FLEXGEN(_CK_FLEXGEN_42, CK_FLEXGEN_42, 0, 42),
+	FLEXGEN(_CK_FLEXGEN_43, CK_FLEXGEN_43, 0, 43),
+	FLEXGEN(_CK_FLEXGEN_44, CK_FLEXGEN_44, 0, 44),
+	FLEXGEN(_CK_FLEXGEN_45, CK_FLEXGEN_45, 0, 45),
+	FLEXGEN(_CK_FLEXGEN_46, CK_FLEXGEN_46, 0, 46),
+	FLEXGEN(_CK_FLEXGEN_47, CK_FLEXGEN_47, 0, 47),
+	FLEXGEN(_CK_FLEXGEN_48, CK_FLEXGEN_48, 0, 48),
+	FLEXGEN(_CK_FLEXGEN_49, CK_FLEXGEN_49, 0, 49),
+	FLEXGEN(_CK_FLEXGEN_50, CK_FLEXGEN_50, 0, 50),
+	FLEXGEN(_CK_FLEXGEN_51, CK_FLEXGEN_51, 0, 51),
+	FLEXGEN(_CK_FLEXGEN_52, CK_FLEXGEN_52, 0, 52),
+	FLEXGEN(_CK_FLEXGEN_53, CK_FLEXGEN_53, 0, 53),
+	FLEXGEN(_CK_FLEXGEN_54, CK_FLEXGEN_54, 0, 54),
+	FLEXGEN(_CK_FLEXGEN_55, CK_FLEXGEN_55, 0, 55),
+	FLEXGEN(_CK_FLEXGEN_56, CK_FLEXGEN_56, 0, 56),
+	FLEXGEN(_CK_FLEXGEN_57, CK_FLEXGEN_57, 0, 57),
+	FLEXGEN(_CK_FLEXGEN_58, CK_FLEXGEN_58, 0, 58),
+	FLEXGEN(_CK_FLEXGEN_59, CK_FLEXGEN_59, 0, 59),
+	FLEXGEN(_CK_FLEXGEN_60, CK_FLEXGEN_60, 0, 60),
+	FLEXGEN(_CK_FLEXGEN_61, CK_FLEXGEN_61, 0, 61),
+	FLEXGEN(_CK_FLEXGEN_62, CK_FLEXGEN_62, 0, 62),
+	FLEXGEN(_CK_FLEXGEN_63, CK_FLEXGEN_63, 0, 63),
+
+	STM32_DIV(_CK_ICN_APB1, CK_ICN_APB1, _CK_ICN_LS_MCU, 0, DIV_APB1),
+	STM32_DIV(_CK_ICN_APB2, CK_ICN_APB2, _CK_ICN_LS_MCU, 0, DIV_APB2),
+	STM32_DIV(_CK_ICN_APB3, CK_ICN_APB3, _CK_ICN_LS_MCU, 0, DIV_APB3),
+	STM32_DIV(_CK_ICN_APB4, CK_ICN_APB4, _CK_ICN_LS_MCU, 0, DIV_APB4),
+	STM32_DIV(_CK_ICN_APBDBG, CK_ICN_APBDBG, _CK_ICN_LS_MCU, 0, DIV_APBDBG),
+
+	/* KERNEL CLOCK */
+	STM32_GATE(_CK_SYSRAM, CK_BUS_SYSRAM, _CK_ICN_HS_MCU, 0, GATE_SYSRAM),
+	STM32_GATE(_CK_RETRAM, CK_BUS_RETRAM, _CK_ICN_HS_MCU, 0, GATE_RETRAM),
+	STM32_GATE(_CK_SRAM1, CK_BUS_SRAM1, _CK_ICN_HS_MCU, CLK_IS_CRITICAL, GATE_SRAM1),
+	STM32_GATE(_CK_SRAM2, CK_BUS_SRAM2, _CK_ICN_HS_MCU, CLK_IS_CRITICAL, GATE_SRAM2),
+
+	STM32_GATE(_CK_DDRPHYC, CK_BUS_DDRPHYC, _CK_ICN_LS_MCU, 0, GATE_DDRPHYC),
+	STM32_GATE(_CK_SYSCPU1, CK_BUS_SYSCPU1, _CK_ICN_LS_MCU, 0, GATE_SYSCPU1),
+	STM32_GATE(_CK_CRC, CK_BUS_CRC, _CK_ICN_LS_MCU, 0, GATE_CRC),
+	STM32_GATE(_CK_OSPIIOM, CK_BUS_OSPIIOM, _CK_ICN_LS_MCU, 0, GATE_OSPIIOM),
+	STM32_GATE(_CK_BKPSRAM, CK_BUS_BKPSRAM, _CK_ICN_LS_MCU, 0, GATE_BKPSRAM),
+	STM32_GATE(_CK_HASH, CK_BUS_HASH, _CK_ICN_LS_MCU, 0, GATE_HASH),
+	STM32_GATE(_CK_RNG, CK_BUS_RNG, _CK_ICN_LS_MCU, 0, GATE_RNG),
+	STM32_GATE(_CK_CRYP1, CK_BUS_CRYP1, _CK_ICN_LS_MCU, 0, GATE_CRYP1),
+	STM32_GATE(_CK_CRYP2, CK_BUS_CRYP2, _CK_ICN_LS_MCU, 0, GATE_CRYP2),
+	STM32_GATE(_CK_SAES, CK_BUS_SAES, _CK_ICN_LS_MCU, 0, GATE_SAES),
+	STM32_GATE(_CK_PKA, CK_BUS_PKA, _CK_ICN_LS_MCU, 0, GATE_PKA),
+
+	STM32_GATE(_CK_GPIOA, CK_BUS_GPIOA, _CK_ICN_LS_MCU, 0, GATE_GPIOA),
+	STM32_GATE(_CK_GPIOB, CK_BUS_GPIOB, _CK_ICN_LS_MCU, 0, GATE_GPIOB),
+	STM32_GATE(_CK_GPIOC, CK_BUS_GPIOC, _CK_ICN_LS_MCU, 0, GATE_GPIOC),
+	STM32_GATE(_CK_GPIOD, CK_BUS_GPIOD, _CK_ICN_LS_MCU, 0, GATE_GPIOD),
+	STM32_GATE(_CK_GPIOE, CK_BUS_GPIOE, _CK_ICN_LS_MCU, 0, GATE_GPIOE),
+	STM32_GATE(_CK_GPIOF, CK_BUS_GPIOF, _CK_ICN_LS_MCU, 0, GATE_GPIOF),
+	STM32_GATE(_CK_GPIOG, CK_BUS_GPIOG, _CK_ICN_LS_MCU, 0, GATE_GPIOG),
+	STM32_GATE(_CK_GPIOH, CK_BUS_GPIOH, _CK_ICN_LS_MCU, 0, GATE_GPIOH),
+	STM32_GATE(_CK_GPIOI, CK_BUS_GPIOI, _CK_ICN_LS_MCU, 0, GATE_GPIOI),
+	STM32_GATE(_CK_GPIOJ, CK_BUS_GPIOJ, _CK_ICN_LS_MCU, 0, GATE_GPIOJ),
+	STM32_GATE(_CK_GPIOK, CK_BUS_GPIOK, _CK_ICN_LS_MCU, 0, GATE_GPIOK),
+	STM32_GATE(_CK_GPIOZ, CK_BUS_GPIOZ, _CK_ICN_LS_MCU, 0, GATE_GPIOZ),
+	STM32_GATE(_CK_RTC, CK_BUS_RTC, _CK_ICN_LS_MCU, 0, GATE_RTC),
+
+	STM32_GATE(_CK_DDRCP, CK_BUS_DDR, _CK_ICN_DDR, 0, GATE_DDRCP),
+
+	/* WARNING 2 CLOCKS FOR ONE GATE */
+	STM32_GATE(_CK_USB2OHCI, CK_BUS_USB2OHCI, _CK_ICN_HSL, 0, GATE_USB2OHCI),
+	STM32_GATE(_CK_USB2EHCI, CK_BUS_USB2EHCI, _CK_ICN_HSL, 0, GATE_USB2EHCI),
+
+	STM32_GATE(_CK_USB3DR, CK_BUS_USB3DR, _CK_ICN_HSL, 0, GATE_USB3DR),
+
+	STM32_GATE(_CK_BSEC, CK_BUS_BSEC, _CK_ICN_APB3, 0, GATE_BSEC),
+	STM32_GATE(_CK_IWDG1, CK_BUS_IWDG1, _CK_ICN_APB3, 0, GATE_IWDG1),
+	STM32_GATE(_CK_IWDG2, CK_BUS_IWDG2, _CK_ICN_APB3, 0, GATE_IWDG2),
+
+	STM32_GATE(_CK_DDRCAPB, CK_BUS_DDRC, _CK_ICN_APB4, 0, GATE_DDRCAPB),
+	STM32_GATE(_CK_DDR, CK_BUS_DDRCFG, _CK_ICN_APB4, 0, GATE_DDR),
+
+	STM32_GATE(_CK_USART2, CK_KER_USART2, _CK_FLEXGEN_08, 0, GATE_USART2),
+	STM32_GATE(_CK_UART4, CK_KER_UART4, _CK_FLEXGEN_08, 0, GATE_UART4),
+	STM32_GATE(_CK_USART3, CK_KER_USART3, _CK_FLEXGEN_09, 0, GATE_USART3),
+	STM32_GATE(_CK_UART5, CK_KER_UART5, _CK_FLEXGEN_09, 0, GATE_UART5),
+	STM32_GATE(_CK_I2C1, CK_KER_I2C1, _CK_FLEXGEN_12, 0, GATE_I2C1),
+	STM32_GATE(_CK_I2C2, CK_KER_I2C2, _CK_FLEXGEN_12, 0, GATE_I2C2),
+	STM32_GATE(_CK_I2C3, CK_KER_I2C3, _CK_FLEXGEN_13, 0, GATE_I2C3),
+	STM32_GATE(_CK_I2C5, CK_KER_I2C5, _CK_FLEXGEN_13, 0, GATE_I2C5),
+	STM32_GATE(_CK_I2C4, CK_KER_I2C4, _CK_FLEXGEN_14, 0, GATE_I2C4),
+	STM32_GATE(_CK_I2C6, CK_KER_I2C6, _CK_FLEXGEN_14, 0, GATE_I2C6),
+	STM32_GATE(_CK_I2C7, CK_KER_I2C7, _CK_FLEXGEN_15, 0, GATE_I2C7),
+	STM32_GATE(_CK_USART1, CK_KER_USART1, _CK_FLEXGEN_19, 0, GATE_USART1),
+	STM32_GATE(_CK_USART6, CK_KER_USART6, _CK_FLEXGEN_20, 0, GATE_USART6),
+	STM32_GATE(_CK_UART7, CK_KER_UART7, _CK_FLEXGEN_21, 0, GATE_UART7),
+	STM32_GATE(_CK_UART8, CK_KER_UART8, _CK_FLEXGEN_21, 0, GATE_UART8),
+	STM32_GATE(_CK_UART9, CK_KER_UART9, _CK_FLEXGEN_22, 0, GATE_UART9),
+	STM32_GATE(_CK_STGEN, CK_KER_STGEN, _CK_FLEXGEN_33, 0, GATE_STGEN),
+	STM32_GATE(_CK_USB3PCIEPHY, CK_KER_USB3PCIEPHY, _CK_FLEXGEN_34, 0, GATE_USB3PCIEPHY),
+	STM32_GATE(_CK_USBTC, CK_KER_USBTC, _CK_FLEXGEN_35, 0, GATE_USBTC),
+	STM32_GATE(_CK_I2C8, CK_KER_I2C8, _CK_FLEXGEN_38, 0, GATE_I2C8),
+	STM32_GATE(_CK_OSPI1, CK_KER_OSPI1, _CK_FLEXGEN_48, 0, GATE_OSPI1),
+	STM32_GATE(_CK_OSPI2, CK_KER_OSPI2, _CK_FLEXGEN_49, 0, GATE_OSPI2),
+	STM32_GATE(_CK_FMC, CK_KER_FMC, _CK_FLEXGEN_50, 0, GATE_FMC),
+	STM32_GATE(_CK_SDMMC1, CK_KER_SDMMC1, _CK_FLEXGEN_51, 0, GATE_SDMMC1),
+	STM32_GATE(_CK_SDMMC2, CK_KER_SDMMC2, _CK_FLEXGEN_52, 0, GATE_SDMMC2),
+	STM32_GATE(_CK_USB2PHY1, CK_KER_USB2PHY1, _CK_FLEXGEN_57, 0, GATE_USB2PHY1),
+	STM32_GATE(_CK_USB2PHY2, CK_KER_USB2PHY2, _CK_FLEXGEN_58, 0, GATE_USB2PHY2),
+};
+
+enum clksrc_id {
+	CLKSRC_CA35SS,
+	CLKSRC_PLL1,
+	CLKSRC_PLL2,
+	CLKSRC_PLL3,
+	CLKSRC_PLL4,
+	CLKSRC_PLL5,
+	CLKSRC_PLL6,
+	CLKSRC_PLL7,
+	CLKSRC_PLL8,
+	CLKSRC_XBAR_CHANNEL0,
+	CLKSRC_XBAR_CHANNEL1,
+	CLKSRC_XBAR_CHANNEL2,
+	CLKSRC_XBAR_CHANNEL3,
+	CLKSRC_XBAR_CHANNEL4,
+	CLKSRC_XBAR_CHANNEL5,
+	CLKSRC_XBAR_CHANNEL6,
+	CLKSRC_XBAR_CHANNEL7,
+	CLKSRC_XBAR_CHANNEL8,
+	CLKSRC_XBAR_CHANNEL9,
+	CLKSRC_XBAR_CHANNEL10,
+	CLKSRC_XBAR_CHANNEL11,
+	CLKSRC_XBAR_CHANNEL12,
+	CLKSRC_XBAR_CHANNEL13,
+	CLKSRC_XBAR_CHANNEL14,
+	CLKSRC_XBAR_CHANNEL15,
+	CLKSRC_XBAR_CHANNEL16,
+	CLKSRC_XBAR_CHANNEL17,
+	CLKSRC_XBAR_CHANNEL18,
+	CLKSRC_XBAR_CHANNEL19,
+	CLKSRC_XBAR_CHANNEL20,
+	CLKSRC_XBAR_CHANNEL21,
+	CLKSRC_XBAR_CHANNEL22,
+	CLKSRC_XBAR_CHANNEL23,
+	CLKSRC_XBAR_CHANNEL24,
+	CLKSRC_XBAR_CHANNEL25,
+	CLKSRC_XBAR_CHANNEL26,
+	CLKSRC_XBAR_CHANNEL27,
+	CLKSRC_XBAR_CHANNEL28,
+	CLKSRC_XBAR_CHANNEL29,
+	CLKSRC_XBAR_CHANNEL30,
+	CLKSRC_XBAR_CHANNEL31,
+	CLKSRC_XBAR_CHANNEL32,
+	CLKSRC_XBAR_CHANNEL33,
+	CLKSRC_XBAR_CHANNEL34,
+	CLKSRC_XBAR_CHANNEL35,
+	CLKSRC_XBAR_CHANNEL36,
+	CLKSRC_XBAR_CHANNEL37,
+	CLKSRC_XBAR_CHANNEL38,
+	CLKSRC_XBAR_CHANNEL39,
+	CLKSRC_XBAR_CHANNEL40,
+	CLKSRC_XBAR_CHANNEL41,
+	CLKSRC_XBAR_CHANNEL42,
+	CLKSRC_XBAR_CHANNEL43,
+	CLKSRC_XBAR_CHANNEL44,
+	CLKSRC_XBAR_CHANNEL45,
+	CLKSRC_XBAR_CHANNEL46,
+	CLKSRC_XBAR_CHANNEL47,
+	CLKSRC_XBAR_CHANNEL48,
+	CLKSRC_XBAR_CHANNEL49,
+	CLKSRC_XBAR_CHANNEL50,
+	CLKSRC_XBAR_CHANNEL51,
+	CLKSRC_XBAR_CHANNEL52,
+	CLKSRC_XBAR_CHANNEL53,
+	CLKSRC_XBAR_CHANNEL54,
+	CLKSRC_XBAR_CHANNEL55,
+	CLKSRC_XBAR_CHANNEL56,
+	CLKSRC_XBAR_CHANNEL57,
+	CLKSRC_XBAR_CHANNEL58,
+	CLKSRC_XBAR_CHANNEL59,
+	CLKSRC_XBAR_CHANNEL60,
+	CLKSRC_XBAR_CHANNEL61,
+	CLKSRC_XBAR_CHANNEL62,
+	CLKSRC_XBAR_CHANNEL63,
+	CLKSRC_RTC,
+	CLKSRC_MCO1,
+	CLKSRC_MCO2,
+	CLKSRC_NB
+};
+
+static void stm32mp2_a35_ss_on_hsi(void)
+{
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t chgclkreq_reg = a35_ss_address + A35_SS_CHGCLKREQ;
+	uintptr_t pll_enable_reg = a35_ss_address + A35_SS_PLL_ENABLE;
+	uint64_t timeout;
+
+	if ((mmio_read_32(chgclkreq_reg) & A35_SS_CHGCLKREQ_ARM_CHGCLKACK) ==
+	    A35_SS_CHGCLKREQ_ARM_CHGCLKACK) {
+		/* Nothing to do, clock source is already set on bypass clock */
+		return;
+	}
+
+	mmio_setbits_32(chgclkreq_reg, A35_SS_CHGCLKREQ_ARM_CHGCLKREQ);
+
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+	while ((mmio_read_32(chgclkreq_reg) & A35_SS_CHGCLKREQ_ARM_CHGCLKACK) !=
+	       A35_SS_CHGCLKREQ_ARM_CHGCLKACK) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("Cannot switch A35 to bypass clock\n");
+			panic();
+		}
+	}
+
+	mmio_clrbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_NRESET_SWPLL_FF);
+}
+
+#ifdef IMAGE_BL2
+static void stm32mp2_clk_muxsel_on_hsi(struct stm32_clk_priv *priv)
+{
+#if !STM32MP_M33_TDCID
+	mmio_clrbits_32(priv->base + RCC_MUXSELCFGR,
+			RCC_MUXSELCFGR_MUXSEL0_MASK |
+			RCC_MUXSELCFGR_MUXSEL1_MASK |
+			RCC_MUXSELCFGR_MUXSEL2_MASK |
+			RCC_MUXSELCFGR_MUXSEL3_MASK |
+			RCC_MUXSELCFGR_MUXSEL4_MASK |
+			RCC_MUXSELCFGR_MUXSEL5_MASK |
+			RCC_MUXSELCFGR_MUXSEL6_MASK |
+			RCC_MUXSELCFGR_MUXSEL7_MASK);
+#else
+	/* MUXSEL5 for PLL1 selection = CA35 clock source, always accessible */
+	mmio_clrbits_32(priv->base + RCC_MUXSELCFGR,
+			RCC_MUXSELCFGR_MUXSEL5_MASK);
+#endif
+}
+
+#if !STM32MP_M33_TDCID
+static void stm32mp2_clk_xbar_on_hsi(struct stm32_clk_priv *priv)
+{
+	uintptr_t xbar0cfgr = priv->base + RCC_XBAR0CFGR;
+	uint32_t i;
+
+	for (i = 0; i < XBAR_CHANNEL_NB; i++) {
+		mmio_clrsetbits_32(xbar0cfgr + (0x4 * i),
+				   RCC_XBAR0CFGR_XBAR0SEL_MASK,
+				   XBAR_SRC_HSI);
+	}
+}
+#endif
+
+/* TODO: MOVE THIS FUNCTION A35 ONLY */
+static int stm32mp2_a35_pll1_start(void)
+{
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t pll_enable_reg = a35_ss_address + A35_SS_PLL_ENABLE;
+	uintptr_t chgclkreq_reg = a35_ss_address + A35_SS_CHGCLKREQ;
+	uint64_t timeout = timeout_init_us(PLLRDY_TIMEOUT);
+
+	mmio_setbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_PD);
+
+	/* Wait PLL lock */
+	while ((mmio_read_32(pll_enable_reg) & A35_SS_PLL_ENABLE_LOCKP) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("PLL1 start failed @ 0x%lx: 0x%x\n",
+				    pll_enable_reg, mmio_read_32(pll_enable_reg));
+			return -ETIMEDOUT;
+		}
+	}
+
+	/* De-assert reset on PLL output clock path */
+	mmio_setbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_NRESET_SWPLL_FF);
+
+	/* Switch CPU clock to PLL clock */
+	mmio_clrbits_32(chgclkreq_reg, A35_SS_CHGCLKREQ_ARM_CHGCLKREQ);
+
+	/* Wait for clock change acknowledge */
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+	while ((mmio_read_32(chgclkreq_reg) & A35_SS_CHGCLKREQ_ARM_CHGCLKACK) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("CA35SS switch to PLL1 failed @ 0x%lx: 0x%x\n",
+				    chgclkreq_reg, mmio_read_32(chgclkreq_reg));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static void stm32mp2_a35_pll1_config(uint32_t fbdiv, uint32_t refdiv, uint32_t postdiv1,
+				     uint32_t postdiv2)
+{
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t pll_freq1_reg = a35_ss_address + A35_SS_PLL_FREQ1;
+	uintptr_t pll_freq2_reg = a35_ss_address + A35_SS_PLL_FREQ2;
+
+	mmio_clrsetbits_32(pll_freq1_reg, A35_SS_PLL_FREQ1_REFDIV_MASK,
+			   (refdiv << A35_SS_PLL_FREQ1_REFDIV_SHIFT) &
+			   A35_SS_PLL_FREQ1_REFDIV_MASK);
+
+	mmio_clrsetbits_32(pll_freq1_reg, A35_SS_PLL_FREQ1_FBDIV_MASK,
+			   (fbdiv << A35_SS_PLL_FREQ1_FBDIV_SHIFT) &
+			   A35_SS_PLL_FREQ1_FBDIV_MASK);
+
+	mmio_clrsetbits_32(pll_freq2_reg, A35_SS_PLL_FREQ2_POSTDIV1_MASK,
+			   (postdiv1 << A35_SS_PLL_FREQ2_POSTDIV1_SHIFT) &
+			   A35_SS_PLL_FREQ2_POSTDIV1_MASK);
+
+	mmio_clrsetbits_32(pll_freq2_reg, A35_SS_PLL_FREQ2_POSTDIV2_MASK,
+			   (postdiv2 << A35_SS_PLL_FREQ2_POSTDIV2_SHIFT) &
+			   A35_SS_PLL_FREQ2_POSTDIV2_MASK);
+}
+
+static int clk_stm32_pll_config_output(struct stm32_clk_priv *priv,
+				       const struct stm32_clk_pll *pll,
+				       uint32_t *pllcfg,
+				       uint32_t fracv)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr2 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR2;
+	uintptr_t pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+	uintptr_t pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	uintptr_t pllxcfgr6 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR6;
+	uintptr_t pllxcfgr7 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR7;
+	unsigned long refclk;
+
+	refclk = _clk_stm32_get_parent_rate(priv, pll->clk_id);
+
+	if (fracv == 0U) {
+		/* PLL in integer mode */
+
+		/*
+		 * No need to check max clock, as oscillator reference clocks
+		 * will always be less than 1.2GHz
+		 */
+		if (refclk < PLL_REFCLK_MIN) {
+			panic();
+		}
+
+		mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_FRACIN_MASK);
+		mmio_clrbits_32(pllxcfgr4, RCC_PLLxCFGR4_DSMEN);
+		mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_DACEN);
+		mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_SSCGDIS);
+		mmio_setbits_32(pllxcfgr1, RCC_PLLxCFGR1_SSMODRST);
+	} else {
+		/* PLL in frac mode */
+
+		/*
+		 * No need to check max clock, as oscillator reference clocks
+		 * will always be less than 1.2GHz
+		 */
+		if (refclk < PLL_FRAC_REFCLK_MIN) {
+			panic();
+		}
+
+		mmio_clrsetbits_32(pllxcfgr3, RCC_PLLxCFGR3_FRACIN_MASK,
+				   fracv & RCC_PLLxCFGR3_FRACIN_MASK);
+		mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_SSCGDIS);
+		mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_DSMEN);
+	}
+
+	assert(pllcfg[REFDIV] != 0U);
+
+	mmio_clrsetbits_32(pllxcfgr2, RCC_PLLxCFGR2_FBDIV_MASK,
+			   (pllcfg[FBDIV] << RCC_PLLxCFGR2_FBDIV_SHIFT) &
+			   RCC_PLLxCFGR2_FBDIV_MASK);
+	mmio_clrsetbits_32(pllxcfgr2, RCC_PLLxCFGR2_FREFDIV_MASK,
+			   pllcfg[REFDIV] & RCC_PLLxCFGR2_FREFDIV_MASK);
+	mmio_clrsetbits_32(pllxcfgr6, RCC_PLLxCFGR6_POSTDIV1_MASK,
+			   pllcfg[POSTDIV1] & RCC_PLLxCFGR6_POSTDIV1_MASK);
+	mmio_clrsetbits_32(pllxcfgr7, RCC_PLLxCFGR7_POSTDIV2_MASK,
+			   pllcfg[POSTDIV2] & RCC_PLLxCFGR7_POSTDIV2_MASK);
+
+	if ((pllcfg[POSTDIV1] == 0U) || (pllcfg[POSTDIV2] == 0U)) {
+		/* Bypass mode */
+		mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_BYPASS);
+		mmio_clrbits_32(pllxcfgr4, RCC_PLLxCFGR4_FOUTPOSTDIVEN);
+	} else {
+		mmio_clrbits_32(pllxcfgr4, RCC_PLLxCFGR4_BYPASS);
+		mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_FOUTPOSTDIVEN);
+	}
+
+	return 0;
+}
+
+static void clk_stm32_pll_config_csg(struct stm32_clk_priv *priv,
+				     const struct stm32_clk_pll *pll,
+				     uint32_t *csg)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uintptr_t pllxcfgr3 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR3;
+	uintptr_t pllxcfgr4 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR4;
+	uintptr_t pllxcfgr5 = pllxcfgr1 + RCC_OFFSET_PLLXCFGR5;
+
+
+	mmio_clrsetbits_32(pllxcfgr5, RCC_PLLxCFGR5_DIVVAL_MASK,
+			   csg[DIVVAL] & RCC_PLLxCFGR5_DIVVAL_MASK);
+	mmio_clrsetbits_32(pllxcfgr5, RCC_PLLxCFGR5_SPREAD_MASK,
+			   (csg[SPREAD] << RCC_PLLxCFGR5_SPREAD_SHIFT) &
+			   RCC_PLLxCFGR5_SPREAD_MASK);
+
+	if (csg[DOWNSPREAD] != 0) {
+		mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_DOWNSPREAD);
+	} else {
+		mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_DOWNSPREAD);
+	}
+
+	mmio_clrbits_32(pllxcfgr3, RCC_PLLxCFGR3_SSCGDIS);
+
+	mmio_clrbits_32(pllxcfgr1, RCC_PLLxCFGR1_PLLEN);
+	udelay(1);
+
+	mmio_setbits_32(pllxcfgr4, RCC_PLLxCFGR4_DSMEN);
+	mmio_setbits_32(pllxcfgr3, RCC_PLLxCFGR3_DACEN);
+}
+
+static int stm32_clk_configure_mux(struct stm32_clk_priv *priv, uint32_t data);
+
+static inline struct stm32_pll_dt_cfg *clk_stm32_pll_get_pdata(int pll_idx)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	struct stm32_clk_platdata *pdata = priv->pdata;
+
+	return  &pdata->pll[pll_idx];
+}
+
+static int _clk_stm32_pll1_init(struct stm32_clk_priv *priv, int pll_idx,
+				struct stm32_pll_dt_cfg *pll_conf)
+{
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_idx);
+	unsigned long refclk;
+	int ret = 0;
+
+	/*
+	 * TODO: check if pll has already good parameters or if we could make
+	    a configuration on the fly.
+	 */
+
+	stm32mp2_a35_ss_on_hsi();
+
+	ret = stm32_clk_configure_mux(priv, pll_conf->src);
+	if (ret != 0) {
+		panic();
+	}
+
+	refclk = _clk_stm32_get_parent_rate(priv, pll->clk_id);
+
+	/*
+	 * No need to check max clock, as oscillator reference clocks will
+	 * always be less than 1.2 GHz
+	 */
+	if (refclk < PLL_REFCLK_MIN) {
+		EARLY_ERROR("%s: %d\n", __func__, __LINE__);
+		panic();
+	}
+
+	stm32mp2_a35_pll1_config(pll_conf->cfg[FBDIV], pll_conf->cfg[REFDIV],
+				 pll_conf->cfg[POSTDIV1], pll_conf->cfg[POSTDIV2]);
+
+	ret = stm32mp2_a35_pll1_start();
+	if (ret != 0) {
+		panic();
+	}
+
+	return 0;
+}
+
+static int clk_stm32_pll_wait_mux_ready(struct stm32_clk_priv *priv,
+					const struct stm32_clk_pll *pll)
+{
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	uint64_t timeout = timeout_init_us(CLKSRC_TIMEOUT);
+
+	while ((mmio_read_32(pllxcfgr1) & RCC_PLLxCFGR1_CKREFST) !=
+	       RCC_PLLxCFGR1_CKREFST) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("PLL%d ref clock not started\n", pll->clk_id);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int _clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx,
+			       struct stm32_pll_dt_cfg *pll_conf)
+{
+	const struct stm32_clk_pll *pll = clk_stm32_pll_data(pll_idx);
+	uintptr_t pllxcfgr1 = priv->base + pll->reg_pllxcfgr1;
+	bool spread_spectrum = false;
+	int ret = 0;
+
+	/*
+	 * TODO: check if pll has already good parameters or if we could make
+	    a configuration on the fly.
+	 */
+
+	_clk_stm32_pll_disable(priv, pll);
+
+	ret = stm32_clk_configure_mux(priv, pll_conf->src);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = clk_stm32_pll_wait_mux_ready(priv, pll);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = clk_stm32_pll_config_output(priv, pll, pll_conf->cfg, pll_conf->frac);
+	if (ret != 0) {
+		panic();
+	}
+
+	if (pll_conf->csg_enabled) {
+		clk_stm32_pll_config_csg(priv, pll, pll_conf->csg);
+		spread_spectrum = true;
+	}
+
+	_clk_stm32_pll_enable(priv, pll);
+
+	if (spread_spectrum) {
+		mmio_clrbits_32(pllxcfgr1, RCC_PLLxCFGR1_SSMODRST);
+	}
+
+	return 0;
+}
+
+static int clk_stm32_pll_init(struct stm32_clk_priv *priv, int pll_idx)
+{
+	struct stm32_pll_dt_cfg *pll_conf = clk_stm32_pll_get_pdata(pll_idx);
+
+	if (pll_conf->enabled) {
+		if (pll_idx == _PLL1) {
+			return _clk_stm32_pll1_init(priv, pll_idx, pll_conf);
+		} else  {
+			return _clk_stm32_pll_init(priv, pll_idx, pll_conf);
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp2_clk_pll_configure(struct stm32_clk_priv *priv)
+{
+#if !STM32MP_M33_TDCID
+	enum pll_id i;
+	int err;
+
+	for (i = _PLL1; i < _PLL_NB; i++) {
+		err = clk_stm32_pll_init(priv, i);
+		if (err) {
+			return err;
+		}
+	}
+
+	return 0;
+#else
+	return clk_stm32_pll_init(priv, _PLL1);
+#endif
+}
+
+static int wait_predivsr(uint16_t channel)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+	uintptr_t previvsr;
+	uint32_t channel_bit;
+	uint64_t timeout;
+
+	if (channel < __WORD_BIT) {
+		previvsr = rcc_base + RCC_PREDIVSR1;
+		channel_bit = BIT(channel);
+	} else {
+		previvsr = rcc_base + RCC_PREDIVSR2;
+		channel_bit = BIT(channel - __WORD_BIT);
+	}
+
+	timeout = timeout_init_us(CLKDIV_TIMEOUT);
+	while ((mmio_read_32(previvsr) & channel_bit) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("Pre divider status: %x\n",
+			      mmio_read_32(previvsr));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int wait_findivsr(uint16_t channel)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+	uintptr_t finvivsr;
+	uint32_t channel_bit;
+	uint64_t timeout;
+
+	if (channel < __WORD_BIT) {
+		finvivsr = rcc_base + RCC_FINDIVSR1;
+		channel_bit = BIT(channel);
+	} else {
+		finvivsr = rcc_base + RCC_FINDIVSR2;
+		channel_bit = BIT(channel - __WORD_BIT);
+	}
+
+	timeout = timeout_init_us(CLKDIV_TIMEOUT);
+	while ((mmio_read_32(finvivsr) & channel_bit) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("Final divider status: %x\n",
+			      mmio_read_32(finvivsr));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int wait_xbar_sts(uint16_t channel)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+	uintptr_t xbar_cfgr = rcc_base + RCC_XBAR0CFGR + (0x4U * channel);
+	uint64_t timeout;
+
+	timeout = timeout_init_us(CLKDIV_TIMEOUT);
+	while ((mmio_read_32(xbar_cfgr) & RCC_XBAR0CFGR_XBAR0STS) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			EARLY_ERROR("XBAR%uCFGR: %x\n", channel,
+			      mmio_read_32(xbar_cfgr));
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static void flexclkgen_config_channel(uint16_t channel, unsigned int clk_src,
+				      unsigned int prediv, unsigned int findiv)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	uintptr_t rcc_base = priv->base;
+
+	if (wait_predivsr(channel) != 0) {
+		panic();
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_PREDIV0CFGR + (0x4U * channel),
+			   RCC_PREDIV0CFGR_PREDIV0_MASK,
+			   prediv);
+
+	if (wait_predivsr(channel) != 0) {
+		panic();
+	}
+
+	if (wait_findivsr(channel) != 0) {
+		panic();
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_FINDIV0CFGR + (0x4U * channel),
+			   RCC_FINDIV0CFGR_FINDIV0_MASK,
+			   findiv);
+
+	if (wait_findivsr(channel) != 0) {
+		panic();
+	}
+
+	if (wait_xbar_sts(channel) != 0) {
+		panic();
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_XBAR0CFGR + (0x4U * channel),
+			   RCC_XBARxCFGR_XBARxSEL_MASK,
+			   clk_src);
+	mmio_setbits_32(rcc_base + RCC_XBAR0CFGR + (0x4U * channel),
+			RCC_XBARxCFGR_XBARxEN);
+
+	if (wait_xbar_sts(channel) != 0) {
+		panic();
+	}
+}
+
+static int stm32mp2_clk_flexgen_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0U; i < pdata->nflexgen; i++) {
+		uint32_t val = pdata->flexgen[i];
+		uint32_t cmd, cmd_data;
+		unsigned int channel, clk_src, pdiv, fdiv;
+
+		cmd = (val & CMD_MASK) >> CMD_SHIFT;
+		cmd_data = val & ~CMD_MASK;
+
+		if (cmd != CMD_FLEXGEN) {
+			continue;
+		}
+
+		channel = (cmd_data & FLEX_ID_MASK) >> FLEX_ID_SHIFT;
+		clk_src = (cmd_data & FLEX_SEL_MASK) >> FLEX_SEL_SHIFT;
+		pdiv = (cmd_data & FLEX_PDIV_MASK) >> FLEX_PDIV_SHIFT;
+		fdiv = (cmd_data & FLEX_FDIV_MASK) >> FLEX_FDIV_SHIFT;
+
+		/* TODO: check if channel can be reconfigured */
+		switch (channel) {
+		case 33U: /* STGEN */
+			break;
+
+		default:
+			flexclkgen_config_channel(channel, clk_src, pdiv, fdiv);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+#if !STM32MP_M33_TDCID
+static void stm32_enable_oscillator_hse(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_HSE];
+	bool digbyp =  osci->digbyp;
+	bool bypass = osci->bypass;
+	bool css = osci->css;
+
+	if (_clk_stm32_get_rate(priv, _CK_HSE) == 0U) {
+		return;
+	}
+
+	clk_oscillator_set_bypass(priv, _CK_HSE, digbyp, bypass);
+
+	_clk_stm32_enable(priv, _CK_HSE);
+
+	clk_oscillator_set_css(priv, _CK_HSE, css);
+}
+
+static void stm32_enable_oscillator_lse(struct stm32_clk_priv *priv)
+{
+	struct clk_oscillator_data *osc_data = clk_oscillator_get_data(priv, _CK_LSE);
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_LSE];
+	bool digbyp =  osci->digbyp;
+	bool bypass = osci->bypass;
+	uint8_t drive = osci->drive;
+
+	if (_clk_stm32_get_rate(priv, _CK_LSE) == 0U) {
+		return;
+	}
+
+	/* Do not reconfigure LSE if already enabled */
+	if (_clk_stm32_gate_is_enabled(priv, osc_data->gate_id)) {
+		return;
+	}
+
+	clk_oscillator_set_bypass(priv, _CK_LSE, digbyp, bypass);
+
+	clk_oscillator_set_drive(priv, _CK_LSE, drive);
+
+	_clk_stm32_gate_enable(priv, osc_data->gate_id);
+}
+#endif
+
+static int stm32mp2_clk_switch_to_hsi(struct stm32_clk_priv *priv)
+{
+	stm32mp2_a35_ss_on_hsi();
+	stm32mp2_clk_muxsel_on_hsi(priv);
+#if !STM32MP_M33_TDCID
+	stm32mp2_clk_xbar_on_hsi(priv);
+#endif
+
+	return 0;
+}
+
+#if !STM32MP_M33_TDCID
+static int stm32_clk_oscillators_wait_lse_ready(struct stm32_clk_priv *priv)
+{
+	int ret = 0;
+
+	if (_clk_stm32_get_rate(priv, _CK_LSE) != 0U) {
+		ret = clk_oscillator_wait_ready_on(priv, _CK_LSE);
+	}
+
+	return ret;
+}
+
+static void stm32_enable_oscillator_msi(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_osci_dt_cfg *osci = &pdata->osci[OSC_MSI];
+	int err;
+
+	err = clk_stm32_osc_msi_set_rate(priv, _CK_MSI, osci->freq, 0);
+	if (err != 0) {
+		EARLY_ERROR("Invalid rate %lu MHz for MSI ! (4 or 16 only)\n",
+			    osci->freq / 1000000U);
+		panic();
+	}
+
+	_clk_stm32_enable(priv, _CK_MSI);
+}
+
+static void stm32_clk_oscillators_enable(struct stm32_clk_priv *priv)
+{
+	stm32_enable_oscillator_hse(priv);
+	stm32_enable_oscillator_lse(priv);
+	stm32_enable_oscillator_msi(priv);
+	_clk_stm32_enable(priv, _CK_LSI);
+}
+#endif
+
+static int stm32_clk_configure_div(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int div_id = (data & DIV_ID_MASK) >> DIV_ID_SHIFT;
+	int div_n = (data & DIV_DIVN_MASK) >> DIV_DIVN_SHIFT;
+
+	return clk_stm32_set_div(priv, div_id, div_n);
+}
+
+static int stm32_clk_configure_mux(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int mux_id = (data & MUX_ID_MASK) >> MUX_ID_SHIFT;
+	int sel = (data & MUX_SEL_MASK) >> MUX_SEL_SHIFT;
+
+	return clk_mux_set_parent(priv, mux_id, sel);
+}
+
+static int stm32_clk_configure_clk_get_binding_id(struct stm32_clk_priv *priv, uint32_t data)
+{
+	unsigned long binding_id = ((unsigned long)data & CLK_ID_MASK) >> CLK_ID_SHIFT;
+
+	return clk_get_index(priv, binding_id);
+}
+
+static int stm32_clk_configure_clk(struct stm32_clk_priv *priv, uint32_t data)
+{
+	int sel = (data & CLK_SEL_MASK) >> CLK_SEL_SHIFT;
+	int enable = (data & CLK_ON_MASK) >> CLK_ON_SHIFT;
+	int clk_id = 0;
+	int ret = 0;
+
+	clk_id = stm32_clk_configure_clk_get_binding_id(priv, data);
+	if (clk_id < 0) {
+		return clk_id;
+	}
+
+	if (sel != CLK_NOMUX) {
+		ret = _clk_stm32_set_parent_by_index(priv, clk_id, sel);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	if (enable) {
+		clk_stm32_enable_call_ops(priv, clk_id);
+	} else {
+		clk_stm32_disable_call_ops(priv, clk_id);
+	}
+
+	return 0;
+}
+
+static int stm32_clk_configure(struct stm32_clk_priv *priv, uint32_t val)
+{
+	uint32_t cmd = (val & CMD_MASK) >> CMD_SHIFT;
+	uint32_t cmd_data = val & ~CMD_MASK;
+	int ret = -1;
+
+	switch (cmd) {
+	case CMD_DIV:
+		ret = stm32_clk_configure_div(priv, cmd_data);
+		break;
+
+	case CMD_MUX:
+		ret = stm32_clk_configure_mux(priv, cmd_data);
+		break;
+
+	case CMD_CLK:
+		ret = stm32_clk_configure_clk(priv, cmd_data);
+		break;
+
+	default:
+		EARLY_ERROR("%s: cmd unknown ! : 0x%x\n", __func__, val);
+		break;
+	}
+
+	return ret;
+}
+
+static int stm32_clk_bus_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0; i < pdata->nbusclk; i++) {
+		int ret;
+
+		ret = stm32_clk_configure(priv, pdata->busclk[i]);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_kernel_configure(struct stm32_clk_priv *priv)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0U; i < pdata->nkernelclk; i++) {
+		int ret;
+
+		ret = stm32_clk_configure(priv, pdata->kernelclk[i]);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32mp2_init_clock_tree(void)
+{
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	int ret;
+
+	/* Set timer with STGEN without changing its clock source */
+	stm32mp_stgen_restore_rate();
+	generic_delay_timer_init();
+
+#if !STM32MP_M33_TDCID
+	stm32_clk_oscillators_enable(priv);
+#endif
+
+	/* Come back to HSI */
+	ret = stm32mp2_clk_switch_to_hsi(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32mp2_clk_pll_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+#if !STM32MP_M33_TDCID
+	/* Wait LSE ready before to use it */
+	ret = stm32_clk_oscillators_wait_lse_ready(priv);
+	if (ret != 0) {
+		panic();
+	}
+#endif
+
+	ret = stm32mp2_clk_flexgen_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32_clk_bus_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	ret = stm32_clk_kernel_configure(priv);
+	if (ret != 0) {
+		panic();
+	}
+
+	return 0;
+}
+
+static int clk_stm32_parse_oscillator_fdt(void *fdt, int node, const char *name,
+					  struct stm32_osci_dt_cfg *osci)
+{
+	int subnode = 0;
+
+	/* Default value oscillator not found, freq=0 */
+	osci->freq = 0;
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		const char *cchar = NULL;
+		const fdt32_t *cuint = NULL;
+		int ret = 0;
+
+		cchar = fdt_get_name(fdt, subnode, &ret);
+		if (cchar == NULL) {
+			return ret;
+		}
+
+		if (strncmp(cchar, name, (size_t)ret) ||
+		    fdt_get_status(subnode) == DT_DISABLED) {
+			continue;
+		}
+
+		cuint = fdt_getprop(fdt, subnode, "clock-frequency", &ret);
+		if (cuint == NULL) {
+			return ret;
+		}
+
+		osci->freq = fdt32_to_cpu(*cuint);
+
+		if (fdt_getprop(fdt, subnode, "st,bypass", NULL) != NULL) {
+			osci->bypass = true;
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,digbypass", NULL) != NULL) {
+			osci->digbyp = true;
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,css", NULL) != NULL) {
+			osci->css = true;
+		}
+
+		osci->drive = fdt_read_uint32_default(fdt, subnode, "st,drive", LSEDRV_MEDIUM_HIGH);
+
+		return 0;
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt_all_oscillator(void *fdt, struct stm32_clk_platdata *pdata)
+{
+	int fdt_err = 0;
+	uint32_t i = 0;
+	int node = 0;
+
+	node = fdt_path_offset(fdt, "/clocks");
+	if (node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	for (i = 0; i < pdata->nosci; i++) {
+		const char *name = NULL;
+
+		name = clk_stm32_get_oscillator_name((enum stm32_osc)i);
+		if (name == NULL) {
+			continue;
+		}
+
+		fdt_err = clk_stm32_parse_oscillator_fdt(fdt, node, name, &pdata->osci[i]);
+		if (fdt_err < 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+static int clk_stm32_parse_pll_fdt(void *fdt, int subnode, struct stm32_pll_dt_cfg *pll)
+{
+	const fdt32_t *cuint = NULL;
+	int subnode_pll = 0;
+	uint32_t val = 0;
+	int err = 0;
+
+	cuint = fdt_getprop(fdt, subnode, "st,pll", NULL);
+	if (!cuint) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	subnode_pll = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (subnode_pll < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	err = fdt_read_uint32_array(fdt, subnode_pll, "cfg", (int)PLLCFG_NB, pll->cfg);
+	if (err != 0) {
+		return err;
+	}
+
+	err = fdt_read_uint32_array(fdt, subnode_pll, "csg", (int)PLLCSG_NB, pll->csg);
+
+	pll->csg_enabled = (err == 0);
+
+	if (err == -FDT_ERR_NOTFOUND) {
+		err = 0;
+	}
+
+	if (err != 0) {
+		return err;
+	}
+
+	pll->enabled = true;
+
+	pll->frac = fdt_read_uint32_default(fdt, subnode_pll, "frac", 0);
+
+	pll->src = UINT32_MAX;
+
+	err = fdt_read_uint32(fdt, subnode_pll, "src", &val);
+	if  (err == 0) {
+		pll->src = val;
+	}
+
+	return 0;
+}
+
+#define RCC_PLL_NAME_SIZE 12
+
+static int stm32_clk_parse_fdt_all_pll(void *fdt, int node, struct stm32_clk_platdata *pdata)
+{
+	unsigned int i = 0;
+
+	for (i = _PLL1; i < pdata->npll; i++) {
+		struct stm32_pll_dt_cfg *pll = pdata->pll + i;
+		char name[RCC_PLL_NAME_SIZE];
+		int subnode = 0;
+		int err = 0;
+
+		snprintf(name, sizeof(name), "st,pll-%u", i + 1);
+
+		subnode = fdt_subnode_offset(fdt, node, name);
+		if (!fdt_check_node(subnode)) {
+			continue;
+		}
+
+		err = clk_stm32_parse_pll_fdt(fdt, subnode, pll);
+		if (err != 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt(struct stm32_clk_platdata *pdata)
+{
+	void *fdt = NULL;
+	int node;
+	int err;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_RCC_CLK_COMPAT);
+	if (node < 0) {
+		panic();
+	}
+
+	err = stm32_clk_parse_fdt_all_oscillator(fdt, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_all_pll(fdt, node, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,busclk", pdata->busclk, &pdata->nbusclk);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,flexgen", pdata->flexgen,
+					  &pdata->nflexgen);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,kerclk", pdata->kernelclk,
+					  &pdata->nkernelclk);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+#endif /* IMAGE_BL2 */
+
+static struct stm32_osci_dt_cfg mp25_osci[NB_OSCILLATOR];
+
+static struct stm32_pll_dt_cfg mp25_pll[_PLL_NB];
+
+#define DT_FLEXGEN_CLK_MAX	64
+static uint32_t mp25_flexgen[DT_FLEXGEN_CLK_MAX];
+
+#define DT_BUS_CLK_MAX		6
+static uint32_t mp25_busclk[DT_BUS_CLK_MAX];
+
+#define DT_KERNEL_CLK_MAX	20
+static uint32_t mp25_kernelclk[DT_KERNEL_CLK_MAX];
+
+static struct stm32_clk_platdata stm32mp25_pdata = {
+	.osci = mp25_osci,
+	.nosci = NB_OSCILLATOR,
+	.pll = mp25_pll,
+	.npll = _PLL_NB,
+	.flexgen = mp25_flexgen,
+	.nflexgen = DT_FLEXGEN_CLK_MAX,
+	.busclk	= mp25_busclk,
+	.nbusclk = DT_BUS_CLK_MAX,
+	.kernelclk = mp25_kernelclk,
+	.nkernelclk = DT_KERNEL_CLK_MAX,
+};
+
+static uint8_t refcounts_mp25[CK_LAST];
+
+static struct stm32_clk_priv stm32mp25_clock_data = {
+	.base		= RCC_BASE,
+	.num		= ARRAY_SIZE(stm32mp25_clk),
+	.clks		= stm32mp25_clk,
+	.parents	= parent_mp25,
+	.nb_parents	= ARRAY_SIZE(parent_mp25),
+	.gates		= gates_mp25,
+	.nb_gates	= ARRAY_SIZE(gates_mp25),
+	.div		= dividers_mp25,
+	.nb_div		= ARRAY_SIZE(dividers_mp25),
+	.osci_data	= stm32mp25_osc_data,
+	.nb_osci_data	= ARRAY_SIZE(stm32mp25_osc_data),
+	.gate_refcounts	= refcounts_mp25,
+	.pdata		= &stm32mp25_pdata,
+	.ops_array	= ops_array_mp25,
+};
+
+int stm32mp2_clk_init(void)
+{
+	uintptr_t base = RCC_BASE;
+	int ret;
+
+#ifdef IMAGE_BL2
+	ret = stm32_clk_parse_fdt(&stm32mp25_pdata);
+	if (ret != 0) {
+		return ret;
+	}
+#endif
+
+	ret = clk_stm32_init(&stm32mp25_clock_data, base);
+	if (ret != 0) {
+		return ret;
+	}
+
+#ifdef IMAGE_BL2
+	ret = stm32mp2_init_clock_tree();
+	if (ret != 0) {
+		return ret;
+	}
+
+	clk_stm32_enable_critical_clocks();
+#endif
+
+	return 0;
+}
+
+int stm32mp2_pll1_disable(void)
+{
+#ifdef IMAGE_BL2
+	return -EPERM;
+#else
+	uintptr_t a35_ss_address = A35SSC_BASE;
+	uintptr_t pll_enable_reg = a35_ss_address + A35_SS_PLL_ENABLE;
+
+	stm32mp2_a35_ss_on_hsi();
+
+	mmio_clrbits_32(pll_enable_reg, A35_SS_PLL_ENABLE_PD);
+
+	return 0;
+#endif
+}
diff --git a/drivers/st/clk/stm32mp1_clk.c b/drivers/st/clk/stm32mp1_clk.c
index aa5db6fc2e..e481b7d921 100644
--- a/drivers/st/clk/stm32mp1_clk.c
+++ b/drivers/st/clk/stm32mp1_clk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -27,6 +27,71 @@
 
 #include <platform_def.h>
 
+enum stm32mp1_pllcfg {
+	PLLCFG_M,
+	PLLCFG_N,
+	PLL_DIV_MN_NB,
+	PLLCFG_P = PLL_DIV_MN_NB,
+	PLLCFG_Q,
+	PLLCFG_R,
+	PLLCFG_O,
+	PLLCFG_NB
+};
+
+#define PLL_DIV_MN_NB	2
+#define PLL_DIV_PQR_NB	3
+
+enum stm32mp1_pllcsg {
+	PLLCSG_MOD_PER,
+	PLLCSG_INC_STEP,
+	PLLCSG_SSCG_MODE,
+	PLLCSG_NB
+};
+
+struct stm32_pll_dt_cfg {
+	bool status;
+	uint32_t src;
+	uint32_t cfg[PLLCFG_NB];
+	uint32_t frac;
+	bool csg_enabled;
+	uint32_t csg[PLLCSG_NB];
+};
+
+struct stm32_clk_platdata {
+	uint32_t npll;
+	struct stm32_pll_dt_cfg *pll;
+	uint32_t nclksrc;
+	uint32_t *clksrc;
+	uint32_t nclkdiv;
+	uint32_t *clkdiv;
+	bool lse_css;
+};
+
+struct stm32_clk_priv {
+	uintptr_t base;
+	const struct mux_cfg *parents;
+	const uint32_t nb_parents;
+	const struct div_cfg *div;
+	const uint32_t nb_div;
+	void *pdata;
+};
+
+static struct stm32_clk_priv *stm32_clock_data;
+
+static struct stm32_clk_priv *clk_stm32_get_priv(void)
+{
+	return stm32_clock_data;
+}
+
+static int clk_stm32_init(struct stm32_clk_priv *priv, uintptr_t base)
+{
+	stm32_clock_data = priv;
+
+	priv->base = base;
+
+	return 0;
+}
+
 #define MAX_HSI_HZ		64000000
 #define USB_PHY_48_MHZ		48000000
 
@@ -39,6 +104,199 @@
 #define HSIDIV_TIMEOUT		TIMEOUT_US_200MS
 #define OSCRDY_TIMEOUT		TIMEOUT_US_1S
 
+struct mux_cfg {
+	uint16_t offset;
+	uint8_t shift;
+	uint8_t width;
+	uint8_t bitrdy;
+};
+
+struct div_cfg {
+	uint16_t offset;
+	uint8_t shift;
+	uint8_t width;
+	uint8_t bitrdy;
+};
+
+#define DIV_NO_BIT_RDY UINT8_MAX
+
+#define DIV_CFG(_id, _offset, _shift, _width,  _bitrdy)\
+	[(_id)] = {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_width),\
+		.bitrdy	= (_bitrdy),\
+	}
+
+static const struct div_cfg dividers_mp15[] = {
+	DIV_CFG(DIV_MPU, RCC_MPCKDIVR, 0, 4, 31),
+	DIV_CFG(DIV_AXI, RCC_AXIDIVR, 0, 3, 31),
+	DIV_CFG(DIV_MCU, RCC_MCUDIVR, 0, 4, 31),
+	DIV_CFG(DIV_APB1, RCC_APB1DIVR, 0, 3, 31),
+	DIV_CFG(DIV_APB2, RCC_APB2DIVR, 0, 3, 31),
+	DIV_CFG(DIV_APB3, RCC_APB3DIVR, 0, 3, 31),
+	DIV_CFG(DIV_APB4, RCC_APB4DIVR, 0, 3, 31),
+	DIV_CFG(DIV_APB5, RCC_APB5DIVR, 0, 3, 31),
+	DIV_CFG(DIV_RTC, RCC_RTCDIVR, 0, 6, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_MCO1, RCC_MCO1CFGR, 4, 4, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_MCO2, RCC_MCO2CFGR, 4, 4, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_TRACE, RCC_DBGCFGR, 0, 3, DIV_NO_BIT_RDY),
+	DIV_CFG(DIV_ETHPTP, RCC_ETHCKSELR, 4, 4, DIV_NO_BIT_RDY),
+};
+
+/*
+ * MUX CONFIG
+ */
+
+#define MUX_NO_BIT_RDY		UINT8_MAX
+
+#define MUXRDY_CFG(_id, _offset, _shift, _width,  _bitrdy)\
+	[(_id)] = {\
+		.offset	= (_offset),\
+		.shift	= (_shift),\
+		.width	= (_width),\
+		.bitrdy = (_bitrdy),\
+	}
+
+#define MUX_CFG(_id, _offset, _shift, _width)\
+	MUXRDY_CFG(_id, _offset, _shift, _width,  MUX_NO_BIT_RDY)
+
+static const struct mux_cfg parent_mp15[MUX_NB] = {
+	MUX_CFG(MUX_PLL12,	RCC_RCK12SELR, 0, 2),
+	MUX_CFG(MUX_PLL3,	RCC_RCK3SELR, 0, 2),
+	MUX_CFG(MUX_PLL4,	RCC_RCK4SELR, 0, 2),
+	MUX_CFG(MUX_CKPER,	RCC_CPERCKSELR, 0, 2),
+	MUXRDY_CFG(MUX_MPU,	RCC_MPCKSELR, 0, 2, 31),
+	MUXRDY_CFG(MUX_AXI,	RCC_ASSCKSELR, 0, 3, 31),
+	MUXRDY_CFG(MUX_MCU,	RCC_MSSCKSELR, 0, 2, 31),
+	MUX_CFG(MUX_RTC,	RCC_BDCR, 16, 2),
+	MUX_CFG(MUX_SDMMC12,	RCC_SDMMC12CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI2S23,	RCC_SPI2S23CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI45,	RCC_SPI45CKSELR, 0, 3),
+	MUX_CFG(MUX_I2C12,	RCC_I2C12CKSELR, 0, 3),
+	MUX_CFG(MUX_I2C35,	RCC_I2C35CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM23,	RCC_LPTIM23CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM45,	RCC_LPTIM45CKSELR, 0, 3),
+	MUX_CFG(MUX_UART24,	RCC_UART24CKSELR, 0, 3),
+	MUX_CFG(MUX_UART35,	RCC_UART35CKSELR, 0, 3),
+	MUX_CFG(MUX_UART78,	RCC_UART78CKSELR, 0, 3),
+	MUX_CFG(MUX_SAI1,	RCC_SAI1CKSELR, 0, 3),
+	MUX_CFG(MUX_ETH,	RCC_ETHCKSELR, 0, 2),
+	MUX_CFG(MUX_I2C46,	RCC_I2C46CKSELR, 0, 3),
+	MUX_CFG(MUX_RNG2,	RCC_RNG2CKSELR, 0, 2),
+	MUX_CFG(MUX_SDMMC3,	RCC_SDMMC3CKSELR, 0, 3),
+	MUX_CFG(MUX_FMC,	RCC_FMCCKSELR, 0, 2),
+	MUX_CFG(MUX_QSPI,	RCC_QSPICKSELR, 0, 2),
+	MUX_CFG(MUX_USBPHY,	RCC_USBCKSELR, 0, 2),
+	MUX_CFG(MUX_USBO,	RCC_USBCKSELR, 4, 1),
+	MUX_CFG(MUX_SPDIF,	RCC_SPDIFCKSELR, 0, 2),
+	MUX_CFG(MUX_SPI2S1,	RCC_SPI2S1CKSELR, 0, 3),
+	MUX_CFG(MUX_CEC,	RCC_CECCKSELR, 0, 2),
+	MUX_CFG(MUX_LPTIM1,	RCC_LPTIM1CKSELR, 0, 3),
+	MUX_CFG(MUX_UART6,	RCC_UART6CKSELR, 0, 3),
+	MUX_CFG(MUX_FDCAN,	RCC_FDCANCKSELR, 0, 2),
+	MUX_CFG(MUX_SAI2,	RCC_SAI2CKSELR, 0, 3),
+	MUX_CFG(MUX_SAI3,	RCC_SAI3CKSELR, 0, 3),
+	MUX_CFG(MUX_SAI4,	RCC_SAI4CKSELR, 0, 3),
+	MUX_CFG(MUX_ADC,	RCC_ADCCKSELR, 0, 2),
+	MUX_CFG(MUX_DSI,	RCC_DSICKSELR, 0, 1),
+	MUX_CFG(MUX_RNG1,	RCC_RNG1CKSELR, 0, 2),
+	MUX_CFG(MUX_STGEN,	RCC_STGENCKSELR, 0, 2),
+	MUX_CFG(MUX_UART1,	RCC_UART1CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI6,	RCC_SPI6CKSELR, 0, 3),
+	MUX_CFG(MUX_MCO1,	RCC_MCO1CFGR, 0, 3),
+	MUX_CFG(MUX_MCO2,	RCC_MCO2CFGR, 0, 3),
+};
+
+#define MASK_WIDTH_SHIFT(_width, _shift) \
+	GENMASK(((_width) + (_shift) - 1U), (_shift))
+
+int clk_mux_get_parent(struct stm32_clk_priv *priv, uint32_t mux_id)
+{
+	const struct mux_cfg *mux;
+	uint32_t mask;
+
+	if (mux_id >= priv->nb_parents) {
+		panic();
+	}
+
+	mux = &priv->parents[mux_id];
+
+	mask = MASK_WIDTH_SHIFT(mux->width, mux->shift);
+
+	return (mmio_read_32(priv->base + mux->offset) & mask) >> mux->shift;
+}
+
+static int clk_mux_set_parent(struct stm32_clk_priv *priv, uint16_t pid, uint8_t sel)
+{
+	const struct mux_cfg *mux = &priv->parents[pid];
+	uintptr_t address = priv->base + mux->offset;
+	uint32_t mask;
+	uint64_t timeout;
+
+	mask = MASK_WIDTH_SHIFT(mux->width, mux->shift);
+
+	mmio_clrsetbits_32(address, mask, (sel << mux->shift) & mask);
+
+	if (mux->bitrdy == MUX_NO_BIT_RDY) {
+		return 0;
+	}
+
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+
+	mask = BIT(mux->bitrdy);
+
+	while ((mmio_read_32(address) & mask) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_configure_mux(struct stm32_clk_priv *priv, uint32_t val)
+{
+	uint32_t data = val & CMD_DATA_MASK;
+	int mux = (data & MUX_ID_MASK) >> MUX_ID_SHIFT;
+	int sel = (data & MUX_SEL_MASK) >> MUX_SEL_SHIFT;
+
+	return clk_mux_set_parent(priv, mux, sel);
+}
+
+int clk_stm32_set_div(struct stm32_clk_priv *priv, uint32_t div_id, uint32_t value)
+{
+	const struct div_cfg *divider;
+	uintptr_t address;
+	uint64_t timeout;
+	uint32_t mask;
+
+	if (div_id >= priv->nb_div) {
+		panic();
+	}
+
+	divider = &priv->div[div_id];
+	address = priv->base + divider->offset;
+
+	mask = MASK_WIDTH_SHIFT(divider->width, divider->shift);
+	mmio_clrsetbits_32(address, mask, (value << divider->shift) & mask);
+
+	if (divider->bitrdy == DIV_NO_BIT_RDY) {
+		return 0;
+	}
+
+	timeout = timeout_init_us(CLKSRC_TIMEOUT);
+	mask = BIT(divider->bitrdy);
+
+	while ((mmio_read_32(address) & mask) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
 const char *stm32mp_osc_node_label[NB_OSC] = {
 	[_LSI] = "clk-lsi",
 	[_LSE] = "clk-lse",
@@ -206,23 +464,6 @@ enum stm32mp1_clkdiv_id {
 	CLKDIV_NB
 };
 
-enum stm32mp1_pllcfg {
-	PLLCFG_M,
-	PLLCFG_N,
-	PLLCFG_P,
-	PLLCFG_Q,
-	PLLCFG_R,
-	PLLCFG_O,
-	PLLCFG_NB
-};
-
-enum stm32mp1_pllcsg {
-	PLLCSG_MOD_PER,
-	PLLCSG_INC_STEP,
-	PLLCSG_SSCG_MODE,
-	PLLCSG_NB
-};
-
 enum stm32mp1_plltype {
 	PLL_800,
 	PLL_1600,
@@ -537,7 +778,18 @@ static const struct stm32mp1_clk_sel stm32mp1_clk_sel[_PARENT_SEL_NB] = {
 };
 
 /* Define characteristic of PLL according type */
-#define DIVN_MIN	24
+#define POST_DIVM_MIN	8000000U
+#define POST_DIVM_MAX	16000000U
+#define DIVM_MIN	0U
+#define DIVM_MAX	63U
+#define DIVN_MIN	24U
+#define DIVN_MAX	99U
+#define DIVP_MIN	0U
+#define DIVP_MAX	127U
+#define FRAC_MAX	8192U
+#define VCO_MIN		800000000U
+#define VCO_MAX		1600000000U
+
 static const struct stm32mp1_pll stm32mp1_pll[PLL_TYPE_NB] = {
 	[PLL_800] = {
 		.refclk_min = 4,
@@ -1060,6 +1312,7 @@ static void __clk_enable(struct stm32mp1_clk_gate const *gate)
 	} else {
 		mmio_setbits_32(rcc_base + gate->offset, BIT(gate->bit));
 	}
+	dsb(); /* Make sure the write operation are done before continue. */
 }
 
 static void __clk_disable(struct stm32mp1_clk_gate const *gate)
@@ -1068,12 +1321,15 @@ static void __clk_disable(struct stm32mp1_clk_gate const *gate)
 
 	VERBOSE("Disable clock %u\n", gate->index);
 
+	dsb(); /* Waiting pending operation before disabling clock  */
+
 	if (gate->set_clr != 0U) {
 		mmio_write_32(rcc_base + gate->offset + RCC_MP_ENCLRR_OFFSET,
 			      BIT(gate->bit));
 	} else {
 		mmio_clrbits_32(rcc_base + gate->offset, BIT(gate->bit));
 	}
+	dsb(); /* Make sure the write operation are done before continue. */
 }
 
 static bool __clk_is_enabled(struct stm32mp1_clk_gate const *gate)
@@ -1327,6 +1583,11 @@ static void stm32mp1_lse_enable(bool bypass, bool digbyp, uint32_t lsedrv)
 	uint32_t value;
 	uintptr_t rcc_base = stm32mp_rcc_base();
 
+	/* Do not reconfigure LSE if it is already ON */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_LSEON) == RCC_BDCR_LSEON) {
+		return;
+	}
+
 	if (digbyp) {
 		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_DIGBYP);
 	}
@@ -1360,7 +1621,7 @@ static void stm32mp1_lse_enable(bool bypass, bool digbyp, uint32_t lsedrv)
 static void stm32mp1_lse_wait(void)
 {
 	if (stm32mp1_osc_wait(true, RCC_BDCR, RCC_BDCR_LSERDY) != 0) {
-		VERBOSE("%s: failed\n", __func__);
+		EARLY_ERROR("%s: failed\n", __func__);
 	}
 }
 
@@ -1369,7 +1630,7 @@ static void stm32mp1_lsi_set(bool enable)
 	stm32mp1_ls_osc_set(enable, RCC_RDLSICR, RCC_RDLSICR_LSION);
 
 	if (stm32mp1_osc_wait(enable, RCC_RDLSICR, RCC_RDLSICR_LSIRDY) != 0) {
-		VERBOSE("%s: failed\n", __func__);
+		EARLY_ERROR("%s: failed\n", __func__);
 	}
 }
 
@@ -1387,7 +1648,7 @@ static void stm32mp1_hse_enable(bool bypass, bool digbyp, bool css)
 
 	stm32mp1_hs_ocs_set(true, RCC_OCENR_HSEON);
 	if (stm32mp1_osc_wait(true, RCC_OCRDYR, RCC_OCRDYR_HSERDY) != 0) {
-		VERBOSE("%s: failed\n", __func__);
+		EARLY_ERROR("%s: failed\n", __func__);
 	}
 
 	if (css) {
@@ -1406,7 +1667,7 @@ static void stm32mp1_csi_set(bool enable)
 {
 	stm32mp1_hs_ocs_set(enable, RCC_OCENR_CSION);
 	if (stm32mp1_osc_wait(enable, RCC_OCRDYR, RCC_OCRDYR_CSIRDY) != 0) {
-		VERBOSE("%s: failed\n", __func__);
+		EARLY_ERROR("%s: failed\n", __func__);
 	}
 }
 
@@ -1414,7 +1675,7 @@ static void stm32mp1_hsi_set(bool enable)
 {
 	stm32mp1_hs_ocs_set(enable, RCC_OCENR_HSION);
 	if (stm32mp1_osc_wait(enable, RCC_OCRDYR, RCC_OCRDYR_HSIRDY) != 0) {
-		VERBOSE("%s: failed\n", __func__);
+		EARLY_ERROR("%s: failed\n", __func__);
 	}
 }
 
@@ -1454,7 +1715,7 @@ static int stm32mp1_hsidiv(unsigned long hsifreq)
 	}
 
 	if (hsidiv == 4U) {
-		ERROR("Invalid clk-hsi frequency\n");
+		EARLY_ERROR("Invalid clk-hsi frequency\n");
 		return -1;
 	}
 
@@ -1467,7 +1728,7 @@ static int stm32mp1_hsidiv(unsigned long hsifreq)
 
 static bool stm32mp1_check_pll_conf(enum stm32mp1_pll_id pll_id,
 				    unsigned int clksrc,
-				    uint32_t *pllcfg, int plloff)
+				    uint32_t *pllcfg, uint32_t fracv)
 {
 	const struct stm32mp1_clk_pll *pll = pll_ref(pll_id);
 	uintptr_t rcc_base = stm32mp_rcc_base();
@@ -1476,8 +1737,7 @@ static bool stm32mp1_check_pll_conf(enum stm32mp1_pll_id pll_id,
 	uintptr_t clksrc_address = rcc_base + (clksrc >> 4);
 	unsigned long refclk;
 	uint32_t ifrge = 0U;
-	uint32_t src, value, fracv = 0;
-	void *fdt;
+	uint32_t src, value;
 
 	/* Check PLL output */
 	if (mmio_read_32(pllxcr) != RCC_PLLNCR_PLLON) {
@@ -1516,10 +1776,6 @@ static bool stm32mp1_check_pll_conf(enum stm32mp1_pll_id pll_id,
 	}
 
 	/* Fractional configuration */
-	if (fdt_get_address(&fdt) == 1) {
-		fracv = fdt_read_uint32_default(fdt, plloff, "frac", 0);
-	}
-
 	value = fracv << RCC_PLLNFRACR_FRACV_SHIFT;
 	value |= RCC_PLLNFRACR_FRACLE;
 	if (mmio_read_32(rcc_base + pll->pllxfracr) != value) {
@@ -1561,8 +1817,8 @@ static int stm32mp1_pll_output(enum stm32mp1_pll_id pll_id, uint32_t output)
 	/* Wait PLL lock */
 	while ((mmio_read_32(pllxcr) & RCC_PLLNCR_PLLRDY) == 0U) {
 		if (timeout_elapsed(timeout)) {
-			ERROR("PLL%u start failed @ 0x%lx: 0x%x\n",
-			      pll_id, pllxcr, mmio_read_32(pllxcr));
+			EARLY_ERROR("PLL%u start failed @ 0x%lx: 0x%x\n",
+				    pll_id, pllxcr, mmio_read_32(pllxcr));
 			return -ETIMEDOUT;
 		}
 	}
@@ -1590,8 +1846,8 @@ static int stm32mp1_pll_stop(enum stm32mp1_pll_id pll_id)
 	/* Wait PLL stopped */
 	while ((mmio_read_32(pllxcr) & RCC_PLLNCR_PLLRDY) != 0U) {
 		if (timeout_elapsed(timeout)) {
-			ERROR("PLL%u stop failed @ 0x%lx: 0x%x\n",
-			      pll_id, pllxcr, mmio_read_32(pllxcr));
+			EARLY_ERROR("PLL%u stop failed @ 0x%lx: 0x%x\n",
+				    pll_id, pllxcr, mmio_read_32(pllxcr));
 			return -ETIMEDOUT;
 		}
 	}
@@ -1683,190 +1939,270 @@ static void stm32mp1_pll_csg(enum stm32mp1_pll_id pll_id, uint32_t *csg)
 			RCC_PLLNCR_SSCG_CTRL);
 }
 
-static int stm32mp1_set_clksrc(unsigned int clksrc)
+static int clk_compute_pll1_settings(unsigned long input_freq,
+				     uint32_t freq_khz,
+				     uint32_t *pllcfg, uint32_t *fracv)
 {
-	uintptr_t clksrc_address = stm32mp_rcc_base() + (clksrc >> 4);
-	uint64_t timeout;
+	unsigned long long best_diff = ULLONG_MAX;
+	unsigned int divm;
 
-	mmio_clrsetbits_32(clksrc_address, RCC_SELR_SRC_MASK,
-			   clksrc & RCC_SELR_SRC_MASK);
+	/* Following parameters have always the same value */
+	pllcfg[PLLCFG_Q] = 0U;
+	pllcfg[PLLCFG_R] = 0U;
+	pllcfg[PLLCFG_O] = PQR(1, 0, 0);
 
-	timeout = timeout_init_us(CLKSRC_TIMEOUT);
-	while ((mmio_read_32(clksrc_address) & RCC_SELR_SRCRDY) == 0U) {
-		if (timeout_elapsed(timeout)) {
-			ERROR("CLKSRC %x start failed @ 0x%lx: 0x%x\n", clksrc,
-			      clksrc_address, mmio_read_32(clksrc_address));
-			return -ETIMEDOUT;
+	for (divm = (DIVM_MAX + 1U); divm != DIVM_MIN; divm--) {
+		unsigned long post_divm = input_freq / divm;
+		unsigned int divp;
+
+		if ((post_divm < POST_DIVM_MIN) || (post_divm > POST_DIVM_MAX)) {
+			continue;
 		}
-	}
 
-	return 0;
-}
+		for (divp = DIVP_MIN; divp <= DIVP_MAX; divp++) {
+			unsigned long long output_freq = freq_khz * 1000ULL;
+			unsigned long long freq;
+			unsigned long long divn;
+			unsigned long long frac;
+			unsigned int i;
 
-static int stm32mp1_set_clkdiv(unsigned int clkdiv, uintptr_t address)
-{
-	uint64_t timeout;
+			freq = output_freq * divm * (divp + 1U);
 
-	mmio_clrsetbits_32(address, RCC_DIVR_DIV_MASK,
-			   clkdiv & RCC_DIVR_DIV_MASK);
+			divn = (freq / input_freq) - 1U;
+			if ((divn < DIVN_MIN) || (divn > DIVN_MAX)) {
+				continue;
+			}
 
-	timeout = timeout_init_us(CLKDIV_TIMEOUT);
-	while ((mmio_read_32(address) & RCC_DIVR_DIVRDY) == 0U) {
-		if (timeout_elapsed(timeout)) {
-			ERROR("CLKDIV %x start failed @ 0x%lx: 0x%x\n",
-			      clkdiv, address, mmio_read_32(address));
-			return -ETIMEDOUT;
+			frac = ((freq * FRAC_MAX) / input_freq) - ((divn + 1U) * FRAC_MAX);
+
+			/* 2 loops to refine the fractional part */
+			for (i = 2U; i != 0U; i--) {
+				unsigned long long diff;
+				unsigned long long vco;
+
+				if (frac > FRAC_MAX) {
+					break;
+				}
+
+				vco = (post_divm * (divn + 1U)) + ((post_divm * frac) / FRAC_MAX);
+
+				if ((vco < (VCO_MIN / 2U)) || (vco > (VCO_MAX / 2U))) {
+					frac++;
+					continue;
+				}
+
+				freq = vco / (divp + 1U);
+				if (output_freq < freq) {
+					diff = freq - output_freq;
+				} else {
+					diff = output_freq - freq;
+				}
+
+				if (diff < best_diff)  {
+					pllcfg[PLLCFG_M] = divm - 1U;
+					pllcfg[PLLCFG_N] = (uint32_t)divn;
+					pllcfg[PLLCFG_P] = divp;
+					*fracv = (uint32_t)frac;
+
+					if (diff == 0U) {
+						return 0;
+					}
+
+					best_diff = diff;
+				}
+
+				frac++;
+			}
 		}
 	}
 
+	if (best_diff == ULLONG_MAX) {
+		return -EINVAL;
+	}
+
 	return 0;
 }
 
-static void stm32mp1_mco_csg(uint32_t clksrc, uint32_t clkdiv)
+static int clk_get_pll1_settings(uint32_t clksrc, uint32_t freq_khz,
+				 uint32_t *pllcfg, uint32_t *fracv)
 {
-	uintptr_t clksrc_address = stm32mp_rcc_base() + (clksrc >> 4);
+	unsigned long input_freq = 0UL;
 
-	/*
-	 * Binding clksrc :
-	 *      bit15-4 offset
-	 *      bit3:   disable
-	 *      bit2-0: MCOSEL[2:0]
-	 */
-	if ((clksrc & 0x8U) != 0U) {
-		mmio_clrbits_32(clksrc_address, RCC_MCOCFG_MCOON);
-	} else {
-		mmio_clrsetbits_32(clksrc_address,
-				   RCC_MCOCFG_MCOSRC_MASK,
-				   clksrc & RCC_MCOCFG_MCOSRC_MASK);
-		mmio_clrsetbits_32(clksrc_address,
-				   RCC_MCOCFG_MCODIV_MASK,
-				   clkdiv << RCC_MCOCFG_MCODIV_SHIFT);
-		mmio_setbits_32(clksrc_address, RCC_MCOCFG_MCOON);
+	assert(pllcfg != NULL);
+	assert(fracv != NULL);
+
+	switch (clksrc) {
+	case CLK_PLL12_HSI:
+		input_freq = stm32mp_clk_get_rate(CK_HSI);
+		break;
+	case CLK_PLL12_HSE:
+		input_freq = stm32mp_clk_get_rate(CK_HSE);
+		break;
+	default:
+		break;
+	}
+
+	if (input_freq == 0UL) {
+		panic();
 	}
+
+	return clk_compute_pll1_settings(input_freq, freq_khz, pllcfg, fracv);
 }
 
-static void stm32mp1_set_rtcsrc(unsigned int clksrc, bool lse_css)
+static int stm32_clk_dividers_configure(struct stm32_clk_priv *priv)
 {
-	uintptr_t address = stm32mp_rcc_base() + RCC_BDCR;
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	uint32_t i;
+
+	for (i = 0U; i < pdata->nclkdiv; i++) {
+		uint32_t div_id, div_n;
+		uint32_t val;
+		int ret;
 
-	if (((mmio_read_32(address) & RCC_BDCR_RTCCKEN) == 0U) ||
-	    (clksrc != (uint32_t)CLK_RTC_DISABLED)) {
-		mmio_clrsetbits_32(address,
-				   RCC_BDCR_RTCSRC_MASK,
-				   (clksrc & RCC_SELR_SRC_MASK) << RCC_BDCR_RTCSRC_SHIFT);
+		val = pdata->clkdiv[i] & CMD_DATA_MASK;
+		div_id = (val & DIV_ID_MASK) >> DIV_ID_SHIFT;
+		div_n = (val & DIV_DIVN_MASK) >> DIV_DIVN_SHIFT;
 
-		mmio_setbits_32(address, RCC_BDCR_RTCCKEN);
+		ret = clk_stm32_set_div(priv, div_id, div_n);
+		if (ret != 0) {
+			return ret;
+		}
 	}
 
-	if (lse_css) {
-		mmio_setbits_32(address, RCC_BDCR_LSECSSON);
+	return 0;
+}
+
+static int stm32_clk_configure_clk(struct stm32_clk_priv *priv, uint32_t data)
+{
+	uint32_t sel = (data & CLK_SEL_MASK) >> CLK_SEL_SHIFT;
+	uint32_t enable = (data & CLK_ON_MASK) >> CLK_ON_SHIFT;
+	unsigned long binding_id = ((unsigned long)data & CLK_ID_MASK) >> CLK_ID_SHIFT;
+	struct stm32_clk_platdata *pdata = priv->pdata;
+
+	if (binding_id == RTC) {
+		uintptr_t address = stm32mp_rcc_base() + RCC_BDCR;
+
+		if (((mmio_read_32(address) & RCC_BDCR_RTCCKEN) == 0U) || (enable != 0U)) {
+			mmio_clrsetbits_32(address, RCC_BDCR_RTCSRC_MASK,
+					   (sel & RCC_SELR_SRC_MASK) << RCC_BDCR_RTCSRC_SHIFT);
+
+			mmio_setbits_32(address, RCC_BDCR_RTCCKEN);
+			/* Configure LSE CSS */
+			if (pdata->lse_css) {
+				mmio_setbits_32(priv->base + RCC_BDCR, RCC_BDCR_LSECSSON);
+			}
+		}
 	}
+
+	return 0;
 }
 
-static void stm32mp1_pkcs_config(uint32_t pkcs)
+static int stm32_clk_configure_by_addr_val(struct stm32_clk_priv *priv,
+					   uint32_t data)
 {
-	uintptr_t address = stm32mp_rcc_base() + ((pkcs >> 4) & 0xFFFU);
-	uint32_t value = pkcs & 0xFU;
-	uint32_t mask = 0xFU;
+	uint32_t addr = data >> CLK_ADDR_SHIFT;
+	uint32_t val = data & CLK_ADDR_VAL_MASK;
 
-	if ((pkcs & BIT(31)) != 0U) {
-		mask <<= 4;
-		value <<= 4;
-	}
+	mmio_setbits_32(priv->base + addr, val);
 
-	mmio_clrsetbits_32(address, mask, value);
+	return 0;
 }
 
-static int clk_get_pll_settings_from_dt(int plloff, unsigned int *pllcfg,
-					uint32_t *fracv, uint32_t *csg,
-					bool *csg_set)
+static int stm32_clk_source_configure(struct stm32_clk_priv *priv)
 {
-	void *fdt;
-	int ret;
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	bool ckper_disabled = false;
+	uint32_t i;
+
+	for (i = 0U; i < pdata->nclksrc; i++) {
+		uint32_t val = pdata->clksrc[i];
+		uint32_t cmd, cmd_data;
+		int ret;
+
+		if (val & CMD_ADDR_BIT) {
+			ret = stm32_clk_configure_by_addr_val(priv, val & ~CMD_ADDR_BIT);
+			if (ret != 0) {
+				return ret;
+			}
 
-	if (fdt_get_address(&fdt) == 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
+			continue;
+		}
 
-	ret = fdt_read_uint32_array(fdt, plloff, "cfg", (uint32_t)PLLCFG_NB,
-				    pllcfg);
-	if (ret < 0) {
-		return -FDT_ERR_NOTFOUND;
+		if (val == (uint32_t)CLK_CKPER_DISABLED) {
+			ckper_disabled = true;
+			continue;
+		}
+
+		cmd = (val & CMD_MASK) >> CMD_SHIFT;
+		cmd_data = val & ~CMD_MASK;
+
+		switch (cmd) {
+		case CMD_MUX:
+			ret = stm32_clk_configure_mux(priv, cmd_data);
+			break;
+
+		case CMD_CLK:
+			ret = stm32_clk_configure_clk(priv, cmd_data);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret != 0) {
+			return ret;
+		}
 	}
 
-	*fracv = fdt_read_uint32_default(fdt, plloff, "frac", 0);
+	/*
+	 * CKPER is source for some peripheral clocks
+	 * (FMC-NAND / QPSI-NOR) and switching source is allowed
+	 * only if previous clock is still ON
+	 * => deactivate CKPER only after switching clock
+	 */
+	if (!ckper_disabled) {
+		return 0;
+	}
 
-	ret = fdt_read_uint32_array(fdt, plloff, "csg", (uint32_t)PLLCSG_NB,
-				    csg);
+	return stm32_clk_configure_mux(priv, CLK_CKPER_DISABLED);
+}
 
-	*csg_set = (ret == 0);
+static int stm32mp1_pll_configure_src(struct stm32_clk_priv *priv, int pll_idx)
+{
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_pll_dt_cfg *pll_conf = &pdata->pll[pll_idx];
 
-	if (ret == -FDT_ERR_NOTFOUND) {
-		ret = 0;
+	if (!pll_conf->status) {
+		return 0;
 	}
 
-	return ret;
+	return stm32_clk_configure_mux(priv, pll_conf->src);
 }
 
-int stm32mp1_clk_init(void)
+int stm32mp1_clk_init(uint32_t pll1_freq_khz)
 {
-	uintptr_t rcc_base = stm32mp_rcc_base();
-	uint32_t pllfracv[_PLL_NB];
-	uint32_t pllcsg[_PLL_NB][PLLCSG_NB];
-	unsigned int clksrc[CLKSRC_NB];
-	unsigned int clkdiv[CLKDIV_NB];
-	unsigned int pllcfg[_PLL_NB][PLLCFG_NB];
-	int plloff[_PLL_NB];
-	int ret, len;
+	struct stm32_clk_priv *priv = clk_stm32_get_priv();
+	struct stm32_clk_platdata *pdata = priv->pdata;
+	struct stm32_pll_dt_cfg *pll_conf = pdata->pll;
+	int ret;
 	enum stm32mp1_pll_id i;
-	bool pllcsg_set[_PLL_NB];
-	bool pllcfg_valid[_PLL_NB];
-	bool lse_css = false;
 	bool pll3_preserve = false;
 	bool pll4_preserve = false;
 	bool pll4_bootrom = false;
-	const fdt32_t *pkcs_cell;
-	void *fdt;
 	int stgen_p = stm32mp1_clk_get_parent(STGEN_K);
 	int usbphy_p = stm32mp1_clk_get_parent(USBPHY_K);
+	uint32_t usbreg_bootrom = 0U;
 
-	if (fdt_get_address(&fdt) == 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	ret = fdt_rcc_read_uint32_array("st,clksrc", (uint32_t)CLKSRC_NB,
-					clksrc);
-	if (ret < 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	ret = fdt_rcc_read_uint32_array("st,clkdiv", (uint32_t)CLKDIV_NB,
-					clkdiv);
-	if (ret < 0) {
-		return -FDT_ERR_NOTFOUND;
-	}
-
-	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
-		char name[12];
-
-		snprintf(name, sizeof(name), "st,pll@%u", i);
-		plloff[i] = fdt_rcc_subnode_offset(name);
-
-		pllcfg_valid[i] = fdt_check_node(plloff[i]);
-		if (!pllcfg_valid[i]) {
-			continue;
-		}
-
-		ret = clk_get_pll_settings_from_dt(plloff[i], pllcfg[i],
-						   &pllfracv[i], pllcsg[i],
-						   &pllcsg_set[i]);
+	if ((!pll_conf[_PLL1].status) && (pll1_freq_khz != 0U)) {
+		ret = clk_get_pll1_settings(pll_conf[_PLL2].src, pll1_freq_khz,
+					    pll_conf[_PLL1].cfg, &pll_conf[_PLL1].frac);
 		if (ret != 0) {
 			return ret;
 		}
-	}
 
-	stm32mp1_mco_csg(clksrc[CLKSRC_MCO1], clkdiv[CLKDIV_MCO1]);
-	stm32mp1_mco_csg(clksrc[CLKSRC_MCO2], clkdiv[CLKDIV_MCO2]);
+		pll_conf[_PLL1].status = true;
+		pll_conf[_PLL1].src = pll_conf[_PLL2].src;
+	}
 
 	/*
 	 * Switch ON oscillator found in device-tree.
@@ -1882,7 +2218,7 @@ int stm32mp1_clk_init(void)
 
 		bypass = fdt_clk_read_bool(name, "st,bypass");
 		digbyp = fdt_clk_read_bool(name, "st,digbypass");
-		lse_css = fdt_clk_read_bool(name, "st,css");
+		pdata->lse_css = fdt_clk_read_bool(name, "st,css");
 		lsedrv = fdt_clk_read_uint32_default(name, "st,drive",
 						     LSEDRV_MEDIUM_HIGH);
 		stm32mp1_lse_enable(bypass, digbyp, lsedrv);
@@ -1903,36 +2239,28 @@ int stm32mp1_clk_init(void)
 	stm32mp1_csi_set(true);
 
 	/* Come back to HSI */
-	ret = stm32mp1_set_clksrc(CLK_MPU_HSI);
+	ret = stm32_clk_configure_mux(priv, CLK_MPU_HSI);
 	if (ret != 0) {
 		return ret;
 	}
-	ret = stm32mp1_set_clksrc(CLK_AXI_HSI);
+	ret = stm32_clk_configure_mux(priv, CLK_AXI_HSI);
 	if (ret != 0) {
 		return ret;
 	}
-	ret = stm32mp1_set_clksrc(CLK_MCU_HSI);
+	ret = stm32_clk_configure_mux(priv, CLK_MCU_HSI);
 	if (ret != 0) {
 		return ret;
 	}
-
-	if ((mmio_read_32(rcc_base + RCC_MP_RSTSCLRR) &
+	if ((mmio_read_32(priv->base + RCC_MP_RSTSCLRR) &
 	     RCC_MP_RSTSCLRR_MPUP0RSTF) != 0) {
-		if (pllcfg_valid[_PLL3]) {
-			pll3_preserve =
-				stm32mp1_check_pll_conf(_PLL3,
-							clksrc[CLKSRC_PLL3],
-							pllcfg[_PLL3],
-							plloff[_PLL3]);
-		}
-
-		if (pllcfg_valid[_PLL4]) {
-			pll4_preserve =
-				stm32mp1_check_pll_conf(_PLL4,
-							clksrc[CLKSRC_PLL4],
-							pllcfg[_PLL4],
-							plloff[_PLL4]);
-		}
+		pll3_preserve = stm32mp1_check_pll_conf(_PLL3,
+							pll_conf[_PLL3].src,
+							pll_conf[_PLL3].cfg,
+							pll_conf[_PLL3].frac);
+		pll4_preserve = stm32mp1_check_pll_conf(_PLL4,
+							pll_conf[_PLL4].src,
+							pll_conf[_PLL4].cfg,
+							pll_conf[_PLL4].frac);
 	}
 	/* Don't initialize PLL4, when used by BOOTROM */
 	if ((stm32mp_get_boot_itf_selected() ==
@@ -1964,58 +2292,27 @@ int stm32mp1_clk_init(void)
 		stm32mp_stgen_config(stm32mp_clk_get_rate(STGEN_K));
 	}
 
-	/* Select DIV */
-	/* No ready bit when MPUSRC != CLK_MPU_PLL1P_DIV, MPUDIV is disabled */
-	mmio_write_32(rcc_base + RCC_MPCKDIVR,
-		      clkdiv[CLKDIV_MPU] & RCC_DIVR_DIV_MASK);
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_AXI], rcc_base + RCC_AXIDIVR);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB4], rcc_base + RCC_APB4DIVR);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB5], rcc_base + RCC_APB5DIVR);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_MCU], rcc_base + RCC_MCUDIVR);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB1], rcc_base + RCC_APB1DIVR);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB2], rcc_base + RCC_APB2DIVR);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clkdiv(clkdiv[CLKDIV_APB3], rcc_base + RCC_APB3DIVR);
+	/* Configure dividers */
+	ret = stm32_clk_dividers_configure(priv);
 	if (ret != 0) {
 		return ret;
 	}
 
-	/* No ready bit for RTC */
-	mmio_write_32(rcc_base + RCC_RTCDIVR,
-		      clkdiv[CLKDIV_RTC] & RCC_DIVR_DIV_MASK);
-
 	/* Configure PLLs source */
-	ret = stm32mp1_set_clksrc(clksrc[CLKSRC_PLL12]);
+	ret = stm32mp1_pll_configure_src(priv, _PLL1);
 	if (ret != 0) {
 		return ret;
 	}
 
 	if (!pll3_preserve) {
-		ret = stm32mp1_set_clksrc(clksrc[CLKSRC_PLL3]);
+		ret = stm32mp1_pll_configure_src(priv, _PLL3);
 		if (ret != 0) {
 			return ret;
 		}
 	}
 
 	if (!pll4_preserve) {
-		ret = stm32mp1_set_clksrc(clksrc[CLKSRC_PLL4]);
+		ret = stm32mp1_pll_configure_src(priv, _PLL4);
 		if (ret != 0) {
 			return ret;
 		}
@@ -2028,34 +2325,34 @@ int stm32mp1_clk_init(void)
 			continue;
 		}
 
-		if (!pllcfg_valid[i]) {
+		if (!pll_conf[i].status) {
 			continue;
 		}
 
 		if ((i == _PLL4) && pll4_bootrom) {
 			/* Set output divider if not done by the Bootrom */
-			stm32mp1_pll_config_output(i, pllcfg[i]);
+			stm32mp1_pll_config_output(i, pll_conf[i].cfg);
 			continue;
 		}
 
-		ret = stm32mp1_pll_config(i, pllcfg[i], pllfracv[i]);
+		ret = stm32mp1_pll_config(i, pll_conf[i].cfg, pll_conf[i].frac);
 		if (ret != 0) {
 			return ret;
 		}
 
-		if (pllcsg_set[i]) {
-			stm32mp1_pll_csg(i, pllcsg[i]);
+		if (pll_conf[i].csg_enabled) {
+			stm32mp1_pll_csg(i, pll_conf[i].csg);
 		}
 
 		stm32mp1_pll_start(i);
 	}
 	/* Wait and start PLLs ouptut when ready */
 	for (i = (enum stm32mp1_pll_id)0; i < _PLL_NB; i++) {
-		if (!pllcfg_valid[i]) {
+		if (!pll_conf[i].status) {
 			continue;
 		}
 
-		ret = stm32mp1_pll_output(i, pllcfg[i][PLLCFG_O]);
+		ret = stm32mp1_pll_output(i, pll_conf[i].cfg[PLLCFG_O]);
 		if (ret != 0) {
 			return ret;
 		}
@@ -2065,69 +2362,32 @@ int stm32mp1_clk_init(void)
 		stm32mp1_lse_wait();
 	}
 
-	/* Configure with expected clock source */
-	ret = stm32mp1_set_clksrc(clksrc[CLKSRC_MPU]);
-	if (ret != 0) {
-		return ret;
-	}
-	ret = stm32mp1_set_clksrc(clksrc[CLKSRC_AXI]);
-	if (ret != 0) {
-		return ret;
+	if (pll4_bootrom) {
+		usbreg_bootrom = mmio_read_32(priv->base + RCC_USBCKSELR);
 	}
-	ret = stm32mp1_set_clksrc(clksrc[CLKSRC_MCU]);
+
+	/* Configure with expected clock source */
+	ret = stm32_clk_source_configure(priv);
 	if (ret != 0) {
-		return ret;
+		panic();
 	}
-	stm32mp1_set_rtcsrc(clksrc[CLKSRC_RTC], lse_css);
-
-	/* Configure PKCK */
-	pkcs_cell = fdt_rcc_read_prop("st,pkcs", &len);
-	if (pkcs_cell != NULL) {
-		bool ckper_disabled = false;
-		uint32_t j;
-		uint32_t usbreg_bootrom = 0U;
-
-		if (pll4_bootrom) {
-			usbreg_bootrom = mmio_read_32(rcc_base + RCC_USBCKSELR);
-		}
-
-		for (j = 0; j < ((uint32_t)len / sizeof(uint32_t)); j++) {
-			uint32_t pkcs = fdt32_to_cpu(pkcs_cell[j]);
 
-			if (pkcs == (uint32_t)CLK_CKPER_DISABLED) {
-				ckper_disabled = true;
-				continue;
-			}
-			stm32mp1_pkcs_config(pkcs);
-		}
+	if (pll4_bootrom) {
+		uint32_t usbreg_value, usbreg_mask;
+		const struct stm32mp1_clk_sel *sel;
 
-		/*
-		 * CKPER is source for some peripheral clocks
-		 * (FMC-NAND / QPSI-NOR) and switching source is allowed
-		 * only if previous clock is still ON
-		 * => deactivated CKPER only after switching clock
-		 */
-		if (ckper_disabled) {
-			stm32mp1_pkcs_config(CLK_CKPER_DISABLED);
-		}
+		sel = clk_sel_ref(_USBPHY_SEL);
+		usbreg_mask = (uint32_t)sel->msk << sel->src;
+		sel = clk_sel_ref(_USBO_SEL);
+		usbreg_mask |= (uint32_t)sel->msk << sel->src;
 
-		if (pll4_bootrom) {
-			uint32_t usbreg_value, usbreg_mask;
-			const struct stm32mp1_clk_sel *sel;
-
-			sel = clk_sel_ref(_USBPHY_SEL);
-			usbreg_mask = (uint32_t)sel->msk << sel->src;
-			sel = clk_sel_ref(_USBO_SEL);
-			usbreg_mask |= (uint32_t)sel->msk << sel->src;
-
-			usbreg_value = mmio_read_32(rcc_base + RCC_USBCKSELR) &
-				       usbreg_mask;
-			usbreg_bootrom &= usbreg_mask;
-			if (usbreg_bootrom != usbreg_value) {
-				VERBOSE("forbidden new USB clk path\n");
-				VERBOSE("vs bootrom on USB boot\n");
-				return -FDT_ERR_BADVALUE;
-			}
+		usbreg_value = mmio_read_32(priv->base + RCC_USBCKSELR) &
+			       usbreg_mask;
+		usbreg_bootrom &= usbreg_mask;
+		if (usbreg_bootrom != usbreg_value) {
+			EARLY_ERROR("forbidden new USB clk path\n");
+			EARLY_ERROR("vs bootrom on USB boot\n");
+			return -FDT_ERR_BADVALUE;
 		}
 	}
 
@@ -2139,7 +2399,7 @@ int stm32mp1_clk_init(void)
 	stm32mp_stgen_config(stm32mp_clk_get_rate(STGEN_K));
 
 	/* Software Self-Refresh mode (SSR) during DDR initilialization */
-	mmio_clrsetbits_32(rcc_base + RCC_DDRITFCR,
+	mmio_clrsetbits_32(priv->base + RCC_DDRITFCR,
 			   RCC_DDRITFCR_DDRCKMOD_MASK,
 			   RCC_DDRITFCR_DDRCKMOD_SSR <<
 			   RCC_DDRITFCR_DDRCKMOD_SHIFT);
@@ -2326,6 +2586,17 @@ void stm32mp1_register_clock_parents_secure(unsigned long clock_id)
 }
 #endif /* STM32MP_SHARED_RESOURCES */
 
+void stm32mp1_clk_mcuss_protect(bool enable)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	if (enable) {
+		mmio_setbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
+	} else {
+		mmio_clrbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
+	}
+}
+
 static void sync_earlyboot_clocks_state(void)
 {
 	unsigned int idx;
@@ -2355,8 +2626,199 @@ static const struct clk_ops stm32mp_clk_ops = {
 	.get_parent	= stm32mp1_clk_get_parent,
 };
 
+struct stm32_pll_dt_cfg mp15_pll[_PLL_NB];
+uint32_t mp15_clksrc[MUX_NB];
+uint32_t mp15_clkdiv[DIV_NB];
+
+struct stm32_clk_platdata stm32mp15_clock_pdata = {
+	.pll		= mp15_pll,
+	.npll		= _PLL_NB,
+	.clksrc		= mp15_clksrc,
+	.nclksrc	= MUX_NB,
+	.clkdiv		= mp15_clkdiv,
+	.nclkdiv	= DIV_NB,
+};
+
+static struct stm32_clk_priv stm32mp15_clock_data = {
+	.base		= RCC_BASE,
+	.parents	= parent_mp15,
+	.nb_parents	= ARRAY_SIZE(parent_mp15),
+	.div		= dividers_mp15,
+	.nb_div		= ARRAY_SIZE(dividers_mp15),
+	.pdata		= &stm32mp15_clock_pdata,
+};
+
+static int stm32_clk_parse_fdt_by_name(void *fdt, int node, const char *name,
+				       uint32_t *tab, uint32_t *nb)
+{
+	const fdt32_t *cell;
+	int len = 0;
+	uint32_t i;
+
+	cell = fdt_getprop(fdt, node, name, &len);
+	if (cell == NULL) {
+		*nb = 0U;
+		return 0;
+	}
+
+	for (i = 0U; i < ((uint32_t)len / sizeof(uint32_t)); i++) {
+		tab[i] = fdt32_to_cpu(cell[i]);
+	}
+
+	*nb = (uint32_t)len / sizeof(uint32_t);
+
+	return 0;
+}
+
+#define RCC_PLL_NAME_SIZE 12
+
+static int clk_stm32_load_vco_config(void *fdt, int subnode, struct stm32_pll_dt_cfg *pll)
+{
+	int err;
+
+	err = fdt_read_uint32_array(fdt, subnode, "divmn", (int)PLL_DIV_MN_NB, &pll->cfg[PLLCFG_M]);
+	if (err != 0) {
+		return err;
+	}
+
+	err = fdt_read_uint32_array(fdt, subnode, "csg", (int)PLLCSG_NB, pll->csg);
+	if (err == 0) {
+		pll->csg_enabled = true;
+	} else if (err == -FDT_ERR_NOTFOUND) {
+		pll->csg_enabled = false;
+	} else {
+		return err;
+	}
+
+	pll->status = true;
+
+	pll->frac = fdt_read_uint32_default(fdt, subnode, "frac", 0);
+
+	pll->src = fdt_read_uint32_default(fdt, subnode, "src", UINT32_MAX);
+
+	return 0;
+}
+
+static int clk_stm32_load_output_config(void *fdt, int subnode, struct stm32_pll_dt_cfg *pll)
+{
+	int err;
+
+	err = fdt_read_uint32_array(fdt, subnode, "st,pll_div_pqr", (int)PLL_DIV_PQR_NB,
+				    &pll->cfg[PLLCFG_P]);
+	if (err != 0) {
+		return err;
+	}
+
+	pll->cfg[PLLCFG_O] = PQR(1, 1, 1);
+
+	return 0;
+}
+
+static int clk_stm32_parse_pll_fdt(void *fdt, int subnode, struct stm32_pll_dt_cfg *pll)
+{
+	const fdt32_t *cuint;
+	int subnode_pll;
+	int subnode_vco;
+	int err;
+
+	cuint = fdt_getprop(fdt, subnode, "st,pll", NULL);
+	if (cuint == NULL) {
+		/* Case of no pll is defined */
+		return 0;
+	}
+
+	subnode_pll = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (subnode_pll < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, subnode_pll, "st,pll_vco", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	subnode_vco = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(*cuint));
+	if (subnode_vco < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	err = clk_stm32_load_vco_config(fdt, subnode_vco, pll);
+	if (err != 0) {
+		return err;
+	}
+
+	err = clk_stm32_load_output_config(fdt, subnode_pll, pll);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt_all_pll(void *fdt, int node, struct stm32_clk_platdata *pdata)
+{
+	size_t i = 0U;
+
+	for (i = _PLL1; i < pdata->npll; i++) {
+		struct stm32_pll_dt_cfg *pll = pdata->pll + i;
+		char name[RCC_PLL_NAME_SIZE];
+		int subnode;
+		int err;
+
+		snprintf(name, sizeof(name), "st,pll@%u", i);
+
+		subnode = fdt_subnode_offset(fdt, node, name);
+		if (!fdt_check_node(subnode)) {
+			continue;
+		}
+
+		err = clk_stm32_parse_pll_fdt(fdt, subnode, pll);
+		if (err != 0) {
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_clk_parse_fdt(struct stm32_clk_platdata *pdata)
+{
+	void *fdt = NULL;
+	int node;
+	uint32_t err;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_RCC_CLK_COMPAT);
+	if (node < 0) {
+		panic();
+	}
+
+	err = stm32_clk_parse_fdt_all_pll(fdt, node, pdata);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,clkdiv", pdata->clkdiv, &pdata->nclkdiv);
+	if (err != 0) {
+		return err;
+	}
+
+	err = stm32_clk_parse_fdt_by_name(fdt, node, "st,clksrc", pdata->clksrc, &pdata->nclksrc);
+	if (err != 0) {
+		return err;
+	}
+
+	return 0;
+}
+
 int stm32mp1_clk_probe(void)
 {
+	uintptr_t base = RCC_BASE;
+	int ret;
+
 #if defined(IMAGE_BL32)
 	if (!fdt_get_rcc_secure_state()) {
 		mmio_write_32(stm32mp_rcc_base() + RCC_TZCR, 0U);
@@ -2365,6 +2827,16 @@ int stm32mp1_clk_probe(void)
 
 	stm32mp1_osc_init();
 
+	ret = stm32_clk_parse_fdt(&stm32mp15_clock_pdata);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = clk_stm32_init(&stm32mp15_clock_data, base);
+	if (ret != 0) {
+		return ret;
+	}
+
 	sync_earlyboot_clocks_state();
 
 	clk_register(&stm32mp_clk_ops);
diff --git a/drivers/st/clk/stm32mp_clkfunc.c b/drivers/st/clk/stm32mp_clkfunc.c
index 01d1420cfa..54799b876e 100644
--- a/drivers/st/clk/stm32mp_clkfunc.c
+++ b/drivers/st/clk/stm32mp_clkfunc.c
@@ -248,6 +248,7 @@ const fdt32_t *fdt_rcc_read_prop(const char *prop_name, int *lenp)
 	return cuint;
 }
 
+#if STM32MP15
 /*
  * Get the secure state for rcc node in device tree.
  * @return: true if rcc is configured for secure world access, false if not.
@@ -266,6 +267,7 @@ bool fdt_get_rcc_secure_state(void)
 
 	return true;
 }
+#endif
 
 /*
  * Get the clock ID of the given node in device tree.
@@ -319,6 +321,32 @@ unsigned long fdt_get_uart_clock_freq(uintptr_t instance)
 	return clk_get_rate((unsigned long)clk_id);
 }
 
+/*******************************************************************************
+ * This function sets the STGEN counter value.
+ ******************************************************************************/
+static void stgen_set_counter(unsigned long long counter)
+{
+#ifdef __aarch64__
+	mmio_write_64(STGEN_BASE + CNTCV_OFF, counter);
+#else
+	mmio_write_32(STGEN_BASE + CNTCVL_OFF, (uint32_t)counter);
+	mmio_write_32(STGEN_BASE + CNTCVU_OFF, (uint32_t)(counter >> 32));
+#endif
+}
+
+/*******************************************************************************
+ * This function returns the STGEN counter value.
+ ******************************************************************************/
+static unsigned long long stm32mp_stgen_get_counter(void)
+{
+#ifdef __aarch64__
+	return mmio_read_64(STGEN_BASE + CNTCV_OFF);
+#else
+	return (((unsigned long long)mmio_read_32(STGEN_BASE + CNTCVU_OFF) << 32) |
+		mmio_read_32(STGEN_BASE + CNTCVL_OFF));
+#endif
+}
+
 /*******************************************************************************
  * This function configures and restores the STGEN counter depending on the
  * connected clock.
@@ -335,10 +363,11 @@ void stm32mp_stgen_config(unsigned long rate)
 	}
 
 	mmio_clrbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
-	counter = stm32mp_stgen_get_counter() * rate / cntfid0;
 
-	mmio_write_32(STGEN_BASE + CNTCVL_OFF, (uint32_t)counter);
-	mmio_write_32(STGEN_BASE + CNTCVU_OFF, (uint32_t)(counter >> 32));
+	if (cntfid0 != 0U) {
+		counter = stm32mp_stgen_get_counter() * rate / cntfid0;
+		stgen_set_counter(counter);
+	}
 	mmio_write_32(STGEN_BASE + CNTFID_OFF, rate);
 	mmio_setbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
 
@@ -349,29 +378,13 @@ void stm32mp_stgen_config(unsigned long rate)
 }
 
 /*******************************************************************************
- * This function returns the STGEN counter value.
- ******************************************************************************/
-unsigned long long stm32mp_stgen_get_counter(void)
-{
-	return (((unsigned long long)mmio_read_32(STGEN_BASE + CNTCVU_OFF) << 32) |
-		mmio_read_32(STGEN_BASE + CNTCVL_OFF));
-}
-
-/*******************************************************************************
- * This function restores the STGEN counter value.
- * It takes a first input value as a counter backup value to be restored and a
- * offset in ms to be added.
+ * This function restores CPU generic timer rate from the STGEN clock rate.
  ******************************************************************************/
-void stm32mp_stgen_restore_counter(unsigned long long value,
-				   unsigned long long offset_in_ms)
+void stm32mp_stgen_restore_rate(void)
 {
-	unsigned long long cnt;
+	unsigned long rate;
 
-	cnt = value + ((offset_in_ms *
-			mmio_read_32(STGEN_BASE + CNTFID_OFF)) / 1000U);
+	rate = mmio_read_32(STGEN_BASE + CNTFID_OFF);
 
-	mmio_clrbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
-	mmio_write_32(STGEN_BASE + CNTCVL_OFF, (uint32_t)cnt);
-	mmio_write_32(STGEN_BASE + CNTCVU_OFF, (uint32_t)(cnt >> 32));
-	mmio_setbits_32(STGEN_BASE + CNTCR_OFF, CNTCR_EN);
+	write_cntfrq_el0((u_register_t)rate);
 }
diff --git a/drivers/st/crypto/stm32_hash.c b/drivers/st/crypto/stm32_hash.c
index e92f980003..6ef7937882 100644
--- a/drivers/st/crypto/stm32_hash.c
+++ b/drivers/st/crypto/stm32_hash.c
@@ -45,13 +45,13 @@
 #endif
 #if STM32_HASH_VER == 4
 #define HASH_CR_ALGO_SHIFT		U(17)
-#define HASH_CR_ALGO_SHA1		(0x0U << HASH_CR_ALGO_SHIFT)
-#define HASH_CR_ALGO_SHA224		(0x2U << HASH_CR_ALGO_SHIFT)
-#define HASH_CR_ALGO_SHA256		(0x3U << HASH_CR_ALGO_SHIFT)
-#define HASH_CR_ALGO_SHA384		(0xCU << HASH_CR_ALGO_SHIFT)
-#define HASH_CR_ALGO_SHA512_224		(0xDU << HASH_CR_ALGO_SHIFT)
-#define HASH_CR_ALGO_SHA512_256		(0xEU << HASH_CR_ALGO_SHIFT)
-#define HASH_CR_ALGO_SHA512		(0xFU << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA1		((uint32_t)(0x0U) << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA224		((uint32_t)(0x2U) << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA256		((uint32_t)(0x3U) << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA384		((uint32_t)(0xCU) << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA512_224		((uint32_t)(0xDU) << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA512_256		((uint32_t)(0xEU) << HASH_CR_ALGO_SHIFT)
+#define HASH_CR_ALGO_SHA512		((uint32_t)(0xFU) << HASH_CR_ALGO_SHIFT)
 #endif
 
 /* Status Flags */
@@ -147,7 +147,7 @@ static void hash_hw_init(enum stm32_hash_algo_mode mode)
 {
 	uint32_t reg;
 
-	reg = HASH_CR_INIT | (HASH_DATA_8_BITS << HASH_CR_DATATYPE_SHIFT);
+	reg = HASH_CR_INIT | ((uint32_t)HASH_DATA_8_BITS << HASH_CR_DATATYPE_SHIFT);
 
 	switch (mode) {
 #if STM32_HASH_VER == 2
@@ -199,7 +199,7 @@ static int hash_get_digest(uint8_t *digest)
 	for (i = 0U; i < (stm32_hash.digest_size / sizeof(uint32_t)); i++) {
 		dsg = __builtin_bswap32(mmio_read_32(hash_base() +
 						     HASH_HREG(i)));
-		memcpy(digest + (i * sizeof(uint32_t)), &dsg, sizeof(uint32_t));
+		(void)(memcpy(&digest[i * sizeof(uint32_t)], (uint8_t *)&dsg, sizeof(uint32_t)));
 	}
 
 	/*
@@ -214,23 +214,27 @@ static int hash_get_digest(uint8_t *digest)
 int stm32_hash_update(const uint8_t *buffer, size_t length)
 {
 	size_t remain_length = length;
+	uint8_t *remain_buf = (uint8_t *)&stm32_remain.buffer;
+	const uint8_t *buf = buffer;
 	int ret = 0;
 
 	if ((length == 0U) || (buffer == NULL)) {
 		return 0;
 	}
 
-	clk_enable(stm32_hash.clock);
+	ret = clk_enable(stm32_hash.clock);
+	if (ret != 0) {
+		return ret;
+	}
 
 	if (stm32_remain.length != 0U) {
 		uint32_t copysize;
 
 		copysize = MIN((sizeof(uint32_t) - stm32_remain.length),
 			       length);
-		memcpy(((uint8_t *)&stm32_remain.buffer) + stm32_remain.length,
-		       buffer, copysize);
+		(void)(memcpy(&remain_buf[stm32_remain.length], buf, copysize));
 		remain_length -= copysize;
-		buffer += copysize;
+		buf = &buf[copysize];
 		if (stm32_remain.length == sizeof(uint32_t)) {
 			ret = hash_write_data(stm32_remain.buffer);
 			if (ret != 0) {
@@ -244,20 +248,20 @@ int stm32_hash_update(const uint8_t *buffer, size_t length)
 	while (remain_length / sizeof(uint32_t) != 0U) {
 		uint32_t tmp_buf;
 
-		memcpy(&tmp_buf, buffer, sizeof(uint32_t));
+		(void)(memcpy((uint8_t *)&tmp_buf, buf, sizeof(uint32_t)));
 		ret = hash_write_data(tmp_buf);
 		if (ret != 0) {
 			goto exit;
 		}
 
-		buffer += sizeof(uint32_t);
+		buf = &buf[sizeof(uint32_t)];
 		remain_length -= sizeof(uint32_t);
 	}
 
 	if (remain_length != 0U) {
 		assert(stm32_remain.length == 0U);
 
-		memcpy((uint8_t *)&stm32_remain.buffer, buffer, remain_length);
+		(void)(memcpy((uint8_t *)&stm32_remain.buffer, buf, remain_length));
 		stm32_remain.length = remain_length;
 	}
 
@@ -271,7 +275,10 @@ int stm32_hash_final(uint8_t *digest)
 {
 	int ret;
 
-	clk_enable(stm32_hash.clock);
+	ret = clk_enable(stm32_hash.clock);
+	if (ret != 0) {
+		return ret;
+	}
 
 	if (stm32_remain.length != 0U) {
 		ret = hash_write_data(stm32_remain.buffer);
@@ -311,7 +318,10 @@ int stm32_hash_final_update(const uint8_t *buffer, uint32_t length,
 
 void stm32_hash_init(enum stm32_hash_algo_mode mode)
 {
-	clk_enable(stm32_hash.clock);
+	if (clk_enable(stm32_hash.clock) != 0) {
+		ERROR("%s: fail to enable clock\n", __func__);
+		panic();
+	}
 
 	hash_hw_init(mode);
 
@@ -324,6 +334,12 @@ int stm32_hash_register(void)
 {
 	struct dt_node_info hash_info;
 	int node;
+	int ret;
+
+	if (stm32_hash.base != 0U) {
+	/* Driver is already initialized */
+		return 0;
+	}
 
 	for (node = dt_get_node(&hash_info, -1, DT_HASH_COMPAT);
 	     node != -FDT_ERR_NOTFOUND;
@@ -344,7 +360,10 @@ int stm32_hash_register(void)
 	stm32_hash.base = hash_info.base;
 	stm32_hash.clock = hash_info.clock;
 
-	clk_enable(stm32_hash.clock);
+	ret = clk_enable(stm32_hash.clock);
+	if (ret != 0) {
+		return ret;
+	}
 
 	if (hash_info.reset >= 0) {
 		uint32_t id = (uint32_t)hash_info.reset;
diff --git a/drivers/st/crypto/stm32_pka.c b/drivers/st/crypto/stm32_pka.c
index f8b37f375c..ed4ac51f6b 100644
--- a/drivers/st/crypto/stm32_pka.c
+++ b/drivers/st/crypto/stm32_pka.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -19,6 +19,11 @@
 
 #include <platform_def.h>
 
+#if !PKA_USE_NIST_P256 && !PKA_USE_BRAINPOOL_P256R1 && !PKA_USE_BRAINPOOL_P256T1 && \
+	!PKA_USE_NIST_P521
+#error "At least one ECDSA curve needs to be selected"
+#endif
+
 /*
  * For our comprehension in this file
  *  _len are in BITs
@@ -51,7 +56,7 @@
 #define _PKA_IPIDR			0x1FF8U
 
 /* PKA control register fields */
-#define _PKA_CR_MODE_MASK		GENMASK(13, 8)
+#define _PKA_CR_MODE_MASK		GENMASK_32(13, 8)
 #define _PKA_CR_MODE_SHIFT		8U
 #define _PKA_CR_MODE_ADD		0x9U
 #define _PKA_CR_MODE_ECDSA_VERIF	0x26U
@@ -64,7 +69,7 @@
 #define _PKA_SR_INITOK			BIT(0)
 
 /* PKA it flag fields (used in CR, SR and CLRFR) */
-#define _PKA_IT_MASK			(GENMASK(21, 19) | BIT(17))
+#define _PKA_IT_MASK			(GENMASK_32(21, 19) | BIT(17))
 #define _PKA_IT_SHIFT			17U
 #define _PKA_IT_OPERR			BIT(21)
 #define _PKA_IT_ADDRERR			BIT(20)
@@ -72,9 +77,9 @@
 #define _PKA_IT_PROCEND			BIT(17)
 
 /* PKA version register fields */
-#define _PKA_VERR_MAJREV_MASK		GENMASK(7, 4)
+#define _PKA_VERR_MAJREV_MASK		GENMASK_32(7, 4)
 #define _PKA_VERR_MAJREV_SHIFT		4U
-#define _PKA_VERR_MINREV_MASK		GENMASK(3, 0)
+#define _PKA_VERR_MINREV_MASK		GENMASK_32(3, 0)
 #define _PKA_VERR_MINREV_SHIFT		0U
 
 /* RAM magic offset */
@@ -254,13 +259,6 @@ static const struct curve_parameters curve_def[] = {
 
 static struct stm32_pka_platdata pka_pdata;
 
-#pragma weak stm32_pka_get_platdata
-
-int stm32_pka_get_platdata(struct stm32_pka_platdata *pdata)
-{
-	return -ENODEV;
-}
-
 static int stm32_pka_parse_fdt(void)
 {
 	int node;
@@ -583,10 +581,7 @@ int stm32_pka_init(void)
 
 	err = stm32_pka_parse_fdt();
 	if (err != 0) {
-		err = stm32_pka_get_platdata(&pka_pdata);
-		if (err != 0) {
-			return err;
-		}
+		return err;
 	}
 
 	clk_enable(pka_pdata.clock_id);
diff --git a/drivers/st/crypto/stm32_rng.c b/drivers/st/crypto/stm32_rng.c
index a9dc43f8da..1342fd4549 100644
--- a/drivers/st/crypto/stm32_rng.c
+++ b/drivers/st/crypto/stm32_rng.c
@@ -187,6 +187,10 @@ int stm32_rng_read(uint8_t *out, uint32_t size)
 
 		count = 4U;
 		while (len != 0U) {
+			if ((mmio_read_32(stm32_rng.base + RNG_SR) & RNG_SR_DRDY) == 0U) {
+				break;
+			}
+
 			data32 = mmio_read_32(stm32_rng.base + RNG_DR);
 			count--;
 
diff --git a/drivers/st/crypto/stm32_saes.c b/drivers/st/crypto/stm32_saes.c
index 02baf21278..fb3b13c6d9 100644
--- a/drivers/st/crypto/stm32_saes.c
+++ b/drivers/st/crypto/stm32_saes.c
@@ -139,15 +139,8 @@
 #define SET_CHAINING_MODE(mod, cr) \
 	mmio_clrsetbits_32((cr), _SAES_CR_CHMOD_MASK, _SAES_CR_CHMOD_##mod << _SAES_CR_CHMOD_SHIFT)
 
-#define pragma weak stm32_saes_get_platdata
-
 static struct stm32_saes_platdata saes_pdata;
 
-int stm32_saes_get_platdata(struct stm32_saes_platdata *pdata)
-{
-	return -ENODEV;
-}
-
 static int stm32_saes_parse_fdt(struct stm32_saes_platdata *pdata)
 {
 	int node;
@@ -387,12 +380,14 @@ int stm32_saes_driver_init(void)
 {
 	int err;
 
+	if(saes_pdata.base != 0U) {
+		/* Driver is already initialized */
+		return 0;
+	}
+
 	err = stm32_saes_parse_fdt(&saes_pdata);
 	if (err != 0) {
-		err = stm32_saes_get_platdata(&saes_pdata);
-		if (err != 0) {
-			return err;
-		}
+		return err;
 	}
 
 	clk_enable(saes_pdata.clock_id);
diff --git a/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h
new file mode 100644
index 0000000000..4644752041
--- /dev/null
+++ b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr3.h
@@ -0,0 +1,934 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MNPMUSRAMMSGBLOCK_DDR3_H
+#define MNPMUSRAMMSGBLOCK_DDR3_H
+
+/*
+ * DDR3U_1D training firmware message block structure
+ *
+ * Please refer to the Training Firmware App Note for futher information about
+ * the usage for Message Block.
+ */
+struct pmu_smb_ddr_1d {
+	uint8_t reserved00;		/*
+					 * Byte offset 0x00, CSR Addr 0x54000, Direction=In
+					 * reserved00[0:4] RFU, must be zero
+					 *
+					 * reserved00[5] = Train vrefDAC0 During Read Deskew
+					 *   0x1 = Read Deskew will begin by enabling and roughly
+					 *   training the phy's per-lane reference voltages.
+					 *   Training the vrefDACs CSRs will increase the maximum 1D
+					 *   training time by around half a millisecond, but will
+					 *   improve 1D training accuracy on systems with
+					 *   significant voltage-offsets between lane read eyes.
+					 *   0x0 = Read Deskew will assume the messageblock's
+					 *   phyVref setting will work for all lanes.
+					 *
+					 * reserved00[6] = Enable High Effort WrDQ1D
+					 *   0x1 = WrDQ1D will conditionally retry training at
+					 *   several extra RxClkDly Timings. This will increase the
+					 *   maximum 1D training time by up to 4 extra iterations of
+					 *   WrDQ1D. This is only required in systems that suffer
+					 *   from very large, asymmetric eye-collapse when receiving
+					 *   PRBS patterns.
+					 *   0x0 = WrDQ1D assume rxClkDly values found by SI
+					 *   Friendly RdDqs1D will work for receiving PRBS patterns
+					 *
+					 * reserved00[7] = Optimize for the special hard macros in
+					 * TSMC28.
+					 *   0x1 = set if the phy being trained was manufactured in
+					 *   any TSMC28 process node.
+					 *   0x0 = otherwise, when not training a TSMC28 phy, leave
+					 *   this field as 0.
+					 */
+	uint8_t msgmisc;		/*
+					 * Byte offset 0x01, CSR Addr 0x54000, Direction=In
+					 * Contains various global options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * msgmisc[0] = MTESTEnable
+					 *   0x1 = Pulse primary digital test output bump at the end
+					 *   of each major training stage. This enables observation
+					 *   of training stage completion by observing the digital
+					 *   test output.
+					 *   0x0 = Do not pulse primary digital test output bump
+					 *
+					 * msgmisc[1] = SimulationOnlyReset
+					 *   0x1 = Verilog only simulation option to shorten
+					 *   duration of DRAM reset pulse length to 1ns.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use reset pulse length specifed by JEDEC standard
+					 *
+					 * msgmisc[2] = SimulationOnlyTraining
+					 *   0x1 = Verilog only simulation option to shorten the
+					 *   duration of the training steps by performing fewer
+					 *   iterations.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use standard training duration.
+					 *
+					 * msgmisc[3] = RFU, must be zero
+					 *
+					 * msgmisc[4] = Suppress streaming messages, including
+					 * assertions, regardless of hdtctrl setting.
+					 * Stage Completion messages, as well as training completion
+					 * and error messages are still sent depending on hdtctrl
+					 * setting.
+					 *
+					 * msgmisc[5] = PerByteMaxRdLat
+					 *   0x1 = Each DBYTE will return dfi_rddata_valid at the
+					 *   lowest possible latency. This may result in unaligned
+					 *   data between bytes to be returned to the DFI.
+					 *   0x0 = Every DBYTE will return dfi_rddata_valid
+					 *   simultaneously. This will ensure that data bytes will
+					 *   return aligned accesses to the DFI.
+					 *
+					 * msgmisc[6] = PartialRank (DDR3 UDIMM and DDR4 UDIMM only,
+					 * otherwise RFU, must be zero)
+					 *   0x1 = Support rank populated with a subset of byte, but
+					 *   where even-odd pair of rank support all the byte
+					 *   0x0 = All rank populated with all the byte (tyical
+					 *   configuration)
+					 *
+					 * msgmisc[7] RFU, must be zero
+					 *
+					 * Notes:
+					 *
+					 * - SimulationOnlyReset and SimulationOnlyTraining can be
+					 *   used to speed up simulation run times, and must never
+					 *   be used in real silicon. Some VIPs may have checks on
+					 *   DRAM reset parameters that may need to be disabled when
+					 *   using SimulationOnlyReset.
+					 */
+	uint16_t pmurevision;		/*
+					 * Byte offset 0x02, CSR Addr 0x54001, Direction=Out
+					 * PMU firmware revision ID
+					 * After training is run, this address will contain the
+					 * revision ID of the firmware.
+					 * Please reference this revision ID when filing support
+					 * cases.
+					 */
+	uint8_t pstate;			/*
+					 * Byte offset 0x04, CSR Addr 0x54002, Direction=In
+					 * Must be set to the target pstate to be trained
+					 *   0x0 = pstate 0
+					 *   0x1 = pstate 1
+					 *   0x2 = pstate 2
+					 *   0x3 = pstate 3
+					 *   All other encodings are reserved
+					 */
+	uint8_t pllbypassen;		/*
+					 * Byte offset 0x05, CSR Addr 0x54002, Direction=In
+					 * Set according to whether target pstate uses PHY PLL
+					 * bypass
+					 *   0x0 = PHY PLL is enabled for target pstate
+					 *   0x1 = PHY PLL is bypassed for target pstate
+					 */
+	uint16_t dramfreq;		/*
+					 * Byte offset 0x06, CSR Addr 0x54003, Direction=In
+					 * DDR data rate for the target pstate in units of MT/s.
+					 * For example enter 0x0640 for DDR1600.
+					 */
+	uint8_t dfifreqratio;		/*
+					 * Byte offset 0x08, CSR Addr 0x54004, Direction=In
+					 * Frequency ratio betwen DfiCtlClk and SDRAM memclk.
+					 *   0x1 = 1:1
+					 *   0x2 = 1:2
+					 *   0x4 = 1:4
+					 */
+	uint8_t bpznresval;		/*
+					 * Byte offset 0x09, CSR Addr 0x54004, Direction=In
+					 * Overwrite the value of precision resistor connected to
+					 * Phy BP_ZN
+					 *   0x00 = Do not program. Use current CSR value.
+					 *   0xf0 = 240 Ohm
+					 *   0x78 = 120 Ohm
+					 *   0x28 = 40 Ohm
+					 *   All other values are reserved.
+					 * It is recommended to set this to 0x00.
+					 */
+	uint8_t phyodtimpedance;	/*
+					 * Byte offset 0x0a, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the termination impedance in ohms
+					 * used by PHY during reads.
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal termination impedance values.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must determine the correct value
+					 * through SI simulation or other methods.
+					 */
+	uint8_t phydrvimpedance;	/*
+					 * Byte offset 0x0b, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the driver impedance in ohms used
+					 * by PHY during writes for all DBYTE drivers
+					 * (DQ/DM/DBI/DQS).
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal R_on driver impedance values.
+					 *
+					 * For digital simulation, any value can be used that is not
+					 * Hi-Z. For silicon, the users must determine the correct
+					 * value through SI simulation or other methods.
+					 */
+	uint8_t phyvref;		/*
+					 * Byte offset 0x0c, CSR Addr 0x54006, Direction=In
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.75*VDDQ, set this field to
+					 * 0x60.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+	uint8_t dramtype;		/*
+					 * Byte offset 0x0d, CSR Addr 0x54006, Direction=In
+					 * Module Type:
+					 *   0x01 = DDR3 unbuffered
+					 *   0x02 = Reserved
+					 *   0x03 = Reserved
+					 *   0x04 = Reserved
+					 *   0x05 = Reserved
+					 */
+	uint8_t disableddbyte;		/*
+					 * Byte offset 0x0e, CSR Addr 0x54007, Direction=In
+					 * Bitmap to indicate which Dbyte are not connected (for
+					 * DByte 0 to 7):
+					 * Set disableddbyte[i] to 1 only to specify that DByte is
+					 * not need to be trained (DByte 8 can be disabled via
+					 * enableddqs setting)
+					 */
+	uint8_t enableddqs;		/*
+					 * Byte offset 0x0f, CSR Addr 0x54007, Direction=In
+					 * Total number of DQ bits enabled in PHY
+					 */
+	uint8_t cspresent;		/*
+					 * Byte offset 0x10, CSR Addr 0x54008, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY.
+					 * Each bit corresponds to a logical CS.
+					 *
+					 * If the bit is set to 1, the CS is connected to DRAM.
+					 * If the bit is set to 0, the CS is not connected to DRAM.
+					 *
+					 * cspresent[0] = CS0 is populated with DRAM
+					 * cspresent[1] = CS1 is populated with DRAM
+					 * cspresent[2] = CS2 is populated with DRAM
+					 * cspresent[3] = CS3 is populated with DRAM
+					 * cspresent[7:4] = Reserved (must be programmed to 0)
+					 */
+	uint8_t cspresentd0;		/*
+					 * Byte offset 0x11, CSR Addr 0x54008, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 0
+					 */
+	uint8_t cspresentd1;		/*
+					 * Byte offset 0x12, CSR Addr 0x54009, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 1
+					 */
+	uint8_t addrmirror;		/*
+					 * Byte offset 0x13, CSR Addr 0x54009, Direction=In
+					 * Corresponds to CS[3:0]
+					 *   1 = Address Mirror.
+					 *   0 = No Address Mirror.
+					 */
+	uint8_t cstestfail;		/*
+					 * Byte offset 0x14, CSR Addr 0x5400a, Direction=Out
+					 * This field will be set if training fails on any rank.
+					 *   0x0 = No failures
+					 *   non-zero = one or more ranks failed training
+					 */
+	uint8_t phycfg;			/*
+					 * Byte offset 0x15, CSR Addr 0x5400a, Direction=In
+					 * Additional mode bits.
+					 *
+					 * Bit fields:
+					 * [0] SlowAccessMode:
+					 *   1 = 2T Address Timing.
+					 *   0 = 1T Address Timing.
+					 * [7-1] RFU, must be zero
+					 *
+					 * WARNING: In case of DDR4 Geardown Mode (mr3[A3] == 1),
+					 * phycfg[0] must be 0.
+					 */
+	uint16_t sequencectrl;		/*
+					 * Byte offset 0x16, CSR Addr 0x5400b, Direction=In
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *		     initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *		     training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[10] = RFU, must be zero
+					 * sequencectrl[11] = RFU, must be zero
+					 * sequencectrl[12] = RFU, must be zero
+					 * sequencectrl[13] = RFU, must be zero
+					 * sequencectrl[15-14] = RFU, must be zero
+					 */
+	uint8_t hdtctrl;		/*
+					 * Byte offset 0x18, CSR Addr 0x5400c, Direction=In
+					 * To control the total number of debug messages, a
+					 * verbosity subfield (hdtctrl, Hardware Debug Trace
+					 * Control) exists in the message block. Every message has a
+					 * verbosity level associated with it, and as the hdtctrl
+					 * value is increased, less important s messages stop being
+					 * sent through the mailboxes. The meanings of several major
+					 * hdtctrl thresholds are explained below:
+					 *
+					 *   0x04 = Maximal debug messages (e.g., Eye contours)
+					 *   0x05 = Detailed debug messages (e.g. Eye delays)
+					 *   0x0A = Coarse debug messages (e.g. rank information)
+					 *   0xC8 = Stage completion
+					 *   0xC9 = Assertion messages
+					 *   0xFF = Firmware completion messages only
+					 */
+	uint8_t reserved19;		/* Byte offset 0x19, CSR Addr 0x5400c, Direction=N/A */
+	uint8_t reserved1a;		/* Byte offset 0x1a, CSR Addr 0x5400d, Direction=N/A */
+	uint8_t share2dvrefresult;	/*
+					 * Byte offset 0x1b, CSR Addr 0x5400d, Direction=In
+					 * Bitmap that designates the phy's vref source for every
+					 * pstate
+					 * If share2dvrefresult[x] = 0, then after 2D training,
+					 * pstate x will continue using the phyVref provided in
+					 * pstate x's 1D messageblock.
+					 * If share2dvrefresult[x] = 1, then after 2D training,
+					 * pstate x will use the per-lane VrefDAC0/1 CSRs trained by
+					 * 2d training.
+					 */
+	uint8_t reserved1c;		/* Byte offset 0x1c, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1d;		/* Byte offset 0x1d, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1e;		/*
+					 * Byte offset 0x1e, CSR Addr 0x5400f, Direction=In
+					 * Input for constraining the range of vref(DQ) values
+					 * training will collect data for, usually reducing training
+					 * time. However, too large of a voltage range may cause
+					 * longer 2D training times while too small of a voltage
+					 * range may truncate passing regions. When in doubt, leave
+					 * this field set to 0.
+					 * Used by 2D training in: Rd2D, Wr2D
+					 *
+					 * reserved1E[0-3]: Rd2D Voltage Range
+					 *   0 = Training will search all phy vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from phyVref
+					 *   2 = limit to +/-4 %VDDQ from phyVref
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from phyVref
+					 *
+					 * reserved1E[4-7]: Wr2D Voltage Range
+					 *   0 = Training will search all dram vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from mr6
+					 *   2 = limit to +/-4 %VDDQ from mr6
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from mr6
+					 */
+	uint8_t reserved1f;		/*
+					 * Byte offset 0x1f, CSR Addr 0x5400f, Direction=In
+					 * Extended training option:
+					 *
+					 * reserved1F[1:0]: Configured RxClkDly offset try during
+					 * WrDq1D high-effort (i.e., when reserved00[6] is set)
+					 *   0: -8, +8, -16, +16
+					 *   1: -4, +4, -8, +8, -12, +12, -16, +16
+					 *   2: -2, +2, -4, +4, -6, +6, -8, +8
+					 *   3: -2, +2, -4, +4, -6, +6, -8, +8, -10, +10, -12, +12,
+					 *      -14, +14, -16, +16
+					 *
+					 * reserved1F[2]: When set, execute again WrDq1D after
+					 * RdDqs1D PRBS
+					 *
+					 * reserved1F[3]: When set redo RdDeskew with PRBS after
+					 * (first) WrDqs1D
+					 *
+					 * reserved1F[7:4]: This field is reserved and must be
+					 * programmed to 0x00.
+					 */
+	uint8_t reserved20;		/*
+					 * Byte offset 0x20, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved MREP assume raising edge is found when
+					 * reserved20[3:0]+3 consecutive 1 are received during MREP
+					 * fine delay swept; reserved20[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved20[7]
+					 * is set, MREP training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint8_t reserved21;		/*
+					 * Byte offset 0x21, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved DWL assume raising edge is found when
+					 * reserved21[3:0]+3 consecutive 1 are received during DWL
+					 * fine delay swept; reserved21[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved21[7]
+					 * is set, DWL training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint16_t phyconfigoverride;	/*
+					 * Byte offset 0x22, CSR Addr 0x54011, Direction=In
+					 * Override PhyConfig csr.
+					 *   0x0: Use hardware csr value for PhyConfing
+					 *   (recommended)
+					 *   Other values: Use value for PhyConfig instead of
+					 *   Hardware value.
+					 */
+	uint8_t dfimrlmargin;		/*
+					 * Byte offset 0x24, CSR Addr 0x54012, Direction=In
+					 * Margin added to smallest passing trained DFI Max Read
+					 * Latency value, in units of DFI clocks. Recommended to be
+					 * >= 1.
+					 */
+	int8_t cdd_rr_3_2;		/*
+					 * Byte offset 0x25, CSR Addr 0x54012, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 2.
+					 */
+	int8_t cdd_rr_3_1;		/*
+					 * Byte offset 0x26, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 1.
+					 */
+	int8_t cdd_rr_3_0;		/*
+					 * Byte offset 0x27, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 0.
+					 */
+	int8_t cdd_rr_2_3;		/*
+					 * Byte offset 0x28, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 3.
+					 */
+	int8_t cdd_rr_2_1;		/*
+					 * Byte offset 0x29, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 1.
+					 */
+	int8_t cdd_rr_2_0;		/*
+					 * Byte offset 0x2a, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 0.
+					 */
+	int8_t cdd_rr_1_3;		/*
+					 * Byte offset 0x2b, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 3.
+					 */
+	int8_t cdd_rr_1_2;		/*
+					 * Byte offset 0x2c, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 2.
+					 */
+	int8_t cdd_rr_1_0;		/*
+					 * Byte offset 0x2d, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0.
+					 */
+	int8_t cdd_rr_0_3;		/*
+					 * Byte offset 0x2e, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 3.
+					 */
+	int8_t cdd_rr_0_2;		/*
+					 * Byte offset 0x2f, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 2.
+					 */
+	int8_t cdd_rr_0_1;		/*
+					 * Byte offset 0x30, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1.
+					 */
+	int8_t cdd_ww_3_2;		/*
+					 * Byte offset 0x31, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 2.
+					 */
+	int8_t cdd_ww_3_1;		/*
+					 * Byte offset 0x32, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 1.
+					 */
+	int8_t cdd_ww_3_0;		/*
+					 * Byte offset 0x33, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 0.
+					 */
+	int8_t cdd_ww_2_3;		/*
+					 * Byte offset 0x34, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 3.
+					 */
+	int8_t cdd_ww_2_1;		/*
+					 * Byte offset 0x35, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 1.
+					 */
+	int8_t cdd_ww_2_0;		/*
+					 * Byte offset 0x36, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 0.
+					 */
+	int8_t cdd_ww_1_3;		/*
+					 * Byte offset 0x37, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 3.
+					 */
+	int8_t cdd_ww_1_2;		/*
+					 * Byte offset 0x38, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 2.
+					 */
+	int8_t cdd_ww_1_0;		/*
+					 * Byte offset 0x39, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0.
+					 */
+	int8_t cdd_ww_0_3;		/*
+					 * Byte offset 0x3a, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 3.
+					 */
+	int8_t cdd_ww_0_2;		/*
+					 * Byte offset 0x3b, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 2.
+					 */
+	int8_t cdd_ww_0_1;		/*
+					 * Byte offset 0x3c, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1.
+					 */
+	int8_t cdd_rw_3_3;		/*
+					 * Byte offset 0x3d, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_3_2;		/*
+					 * Byte offset 0x3e, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_3_1;		/*
+					 * Byte offset 0x3f, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_3_0;		/*
+					 * Byte offset 0x40, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 0.
+					 */
+	int8_t cdd_rw_2_3;		/*
+					 * Byte offset 0x41, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_2_2;		/*
+					 * Byte offset 0x42, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_2_1;		/*
+					 * Byte offset 0x43, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_2_0;		/*
+					 * Byte offset 0x44, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 0.
+					 */
+	int8_t cdd_rw_1_3;		/*
+					 * Byte offset 0x45, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_1_2;		/*
+					 * Byte offset 0x46, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_1_1;		/*
+					 * Byte offset 0x47, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_1_0;		/*
+					 * Byte offset 0x48, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 0.
+					 */
+	int8_t cdd_rw_0_3;		/*
+					 * Byte offset 0x49, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_0_2;		/*
+					 * Byte offset 0x4a, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_0_1;		/*
+					 * Byte offset 0x4b, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_0_0;		/*
+					 * Byte offset 0x4c, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_3_3;		/*
+					 * Byte offset 0x4d, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_3_2;		/*
+					 * Byte offset 0x4e, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_3_1;		/*
+					 * Byte offset 0x4f, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_3_0;		/*
+					 * Byte offset 0x50, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_2_3;		/*
+					 * Byte offset 0x51, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_2_2;		/*
+					 * Byte offset 0x52, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_2_1;		/*
+					 * Byte offset 0x53, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_2_0;		/*
+					 * Byte offset 0x54, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_1_3;		/*
+					 * Byte offset 0x55, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_1_2;		/*
+					 * Byte offset 0x56, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_1_1;		/*
+					 * Byte offset 0x57, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_1_0;		/*
+					 * Byte offset 0x58, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_0_3;		/*
+					 * Byte offset 0x59, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_0_2;		/*
+					 * Byte offset 0x5a, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_0_1;		/*
+					 * Byte offset 0x5b, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_0_0;		/*
+					 * Byte offset 0x5c, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 0.
+					 */
+	uint8_t reserved5d;		/*
+					 * Byte offset 0x5d, CSR Addr 0x5402e, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for DDR4:
+					 * By default, if this parameter is 0, the offset applied at
+					 * the end of DDR4 RxEn training resulting in the trained
+					 * RxEnDly is 3/8 of the RX preamble width; if reserved5D is
+					 * non zero, this offset is used instead (in fine step).
+					 */
+	uint16_t mr0;			/*
+					 * Byte offset 0x5e, CSR Addr 0x5402f, Direction=In
+					 * Value of DDR mode register mr0 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr1;			/*
+					 * Byte offset 0x60, CSR Addr 0x54030, Direction=In
+					 * Value of DDR mode register mr1 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr2;			/*
+					 * Byte offset 0x62, CSR Addr 0x54031, Direction=In
+					 * Value of DDR mode register mr2 for all ranks for current
+					 * pstate.
+					 */
+	uint8_t reserved64;		/*
+					 * Byte offset 0x64, CSR Addr 0x54032, Direction=In
+					 * Reserved64[0] = protect memory reset
+					 *   0x0 = dfi_reset_n cannot control CP_MEMRESET_L to
+					 *	   devices after training. (Default value)
+					 *   0x1 = dfi_reset_n can control CP_MEMRESET_L to
+					 *	   devices after training.
+					 *
+					 * Reserved64[7:1] RFU, must be zero
+					 */
+	uint8_t reserved65;		/*
+					 * Byte offset 0x65, CSR Addr 0x54032, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved66;		/*
+					 * Byte offset 0x66, CSR Addr 0x54033, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved67;		/*
+					 * Byte offset 0x67, CSR Addr 0x54033, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved68;		/*
+					 * Byte offset 0x68, CSR Addr 0x54034, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved69;		/*
+					 * Byte offset 0x69, CSR Addr 0x54034, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6a;		/*
+					 * Byte offset 0x6a, CSR Addr 0x54035, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6b;		/*
+					 * Byte offset 0x6b, CSR Addr 0x54035, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6c;		/*
+					 * Byte offset 0x6c, CSR Addr 0x54036, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6d;		/*
+					 * Byte offset 0x6d, CSR Addr 0x54036, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6e;		/*
+					 * Byte offset 0x6e, CSR Addr 0x54037, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved6f;		/*
+					 * Byte offset 0x6f, CSR Addr 0x54037, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved70;		/*
+					 * Byte offset 0x70, CSR Addr 0x54038, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved71;		/*
+					 * Byte offset 0x71, CSR Addr 0x54038, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved72;		/*
+					 * Byte offset 0x72, CSR Addr 0x54039, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved73;		/*
+					 * Byte offset 0x73, CSR Addr 0x54039, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl0;		/*
+					 * Byte offset 0x74, CSR Addr 0x5403a, Direction=In
+					 * Odt pattern for accesses targeting rank 0. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl1;		/*
+					 * Byte offset 0x75, CSR Addr 0x5403a, Direction=In
+					 * Odt pattern for accesses targeting rank 1. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl2;		/*
+					 * Byte offset 0x76, CSR Addr 0x5403b, Direction=In
+					 * Odt pattern for accesses targeting rank 2. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl3;		/*
+					 * Byte offset 0x77, CSR Addr 0x5403b, Direction=In
+					 * Odt pattern for accesses targeting rank 3. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl4;		/*
+					 * Byte offset 0x78, CSR Addr 0x5403c, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl5;		/*
+					 * Byte offset 0x79, CSR Addr 0x5403c, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl6;		/*
+					 * Byte offset 0x7a, CSR Addr 0x5403d, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t acsmodtctrl7;		/*
+					 * Byte offset 0x7b, CSR Addr 0x5403d, Direction=In
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7c;		/*
+					 * Byte offset 0x7c, CSR Addr 0x5403e, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7d;		/*
+					 * Byte offset 0x7d, CSR Addr 0x5403e, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7e;		/*
+					 * Byte offset 0x7e, CSR Addr 0x5403f, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved7f;		/*
+					 * Byte offset 0x7f, CSR Addr 0x5403f, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved80;		/*
+					 * Byte offset 0x80, CSR Addr 0x54040, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved81;		/*
+					 * Byte offset 0x81, CSR Addr 0x54040, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved82;		/*
+					 * Byte offset 0x82, CSR Addr 0x54041, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved83;		/*
+					 * Byte offset 0x83, CSR Addr 0x54041, Direction=N/A
+					 * This field is reserved and must be programmed to 0x00.
+					 */
+	uint8_t reserved84;		/* Byte offset 0x84, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved85;		/* Byte offset 0x85, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved86;		/* Byte offset 0x86, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved87;		/* Byte offset 0x87, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved88;		/* Byte offset 0x88, CSR Addr 0x54044, Direction=N/A */
+	uint8_t reserved89;		/* Byte offset 0x89, CSR Addr 0x54044, Direction=N/A */
+	uint8_t reserved8a;		/* Byte offset 0x8a, CSR Addr 0x54045, Direction=N/A */
+	uint8_t reserved8b;		/* Byte offset 0x8b, CSR Addr 0x54045, Direction=N/A */
+	uint8_t reserved8c;		/* Byte offset 0x8c, CSR Addr 0x54046, Direction=N/A */
+	uint8_t reserved8d;		/* Byte offset 0x8d, CSR Addr 0x54046, Direction=N/A */
+	uint8_t reserved8e;		/* Byte offset 0x8e, CSR Addr 0x54047, Direction=N/A */
+	uint8_t reserved8f;		/* Byte offset 0x8f, CSR Addr 0x54047, Direction=N/A */
+	uint8_t reserved90;		/* Byte offset 0x90, CSR Addr 0x54048, Direction=N/A */
+	uint8_t reserved91;		/* Byte offset 0x91, CSR Addr 0x54048, Direction=N/A */
+	uint8_t reserved92;		/* Byte offset 0x92, CSR Addr 0x54049, Direction=N/A */
+	uint8_t reserved93;		/* Byte offset 0x93, CSR Addr 0x54049, Direction=N/A */
+	uint8_t reserved94;		/* Byte offset 0x94, CSR Addr 0x5404a, Direction=N/A */
+	uint8_t reserved95;		/* Byte offset 0x95, CSR Addr 0x5404a, Direction=N/A */
+	uint8_t reserved96;		/* Byte offset 0x96, CSR Addr 0x5404b, Direction=N/A */
+	uint8_t reserved97;		/* Byte offset 0x97, CSR Addr 0x5404b, Direction=N/A */
+	uint8_t reserved98;		/* Byte offset 0x98, CSR Addr 0x5404c, Direction=N/A */
+	uint8_t reserved99;		/* Byte offset 0x99, CSR Addr 0x5404c, Direction=N/A */
+	uint8_t reserved9a;		/* Byte offset 0x9a, CSR Addr 0x5404d, Direction=N/A */
+	uint8_t reserved9b;		/* Byte offset 0x9b, CSR Addr 0x5404d, Direction=N/A */
+	uint8_t reserved9c;		/* Byte offset 0x9c, CSR Addr 0x5404e, Direction=N/A */
+	uint8_t reserved9d;		/* Byte offset 0x9d, CSR Addr 0x5404e, Direction=N/A */
+	uint8_t reserved9e;		/* Byte offset 0x9e, CSR Addr 0x5404f, Direction=N/A */
+	uint8_t reserved9f;		/* Byte offset 0x9f, CSR Addr 0x5404f, Direction=N/A */
+	uint8_t reserveda0;		/* Byte offset 0xa0, CSR Addr 0x54050, Direction=N/A */
+	uint8_t reserveda1;		/* Byte offset 0xa1, CSR Addr 0x54050, Direction=N/A */
+	uint8_t reserveda2;		/* Byte offset 0xa2, CSR Addr 0x54051, Direction=N/A */
+	uint8_t reserveda3;		/* Byte offset 0xa3, CSR Addr 0x54051, Direction=N/A */
+} __attribute__ ((packed)) __attribute__ ((aligned(2)));
+
+#endif /* MNPMUSRAMMSGBLOCK_DDR3_H */
diff --git a/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h
new file mode 100644
index 0000000000..591bf9c50f
--- /dev/null
+++ b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_ddr4.h
@@ -0,0 +1,2202 @@
+/*
+ * Copyright (C) 2021-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MNPMUSRAMMSGBLOCK_DDR4_H
+#define MNPMUSRAMMSGBLOCK_DDR4_H
+
+/* DDR4U_1D training firmware message block structure
+ *
+ * Please refer to the Training Firmware App Note for futher information about
+ * the usage for Message Block.
+ */
+struct pmu_smb_ddr_1d {
+	uint8_t reserved00;		/*
+					 * Byte offset 0x00, CSR Addr 0x54000, Direction=In
+					 * reserved00[0:4] RFU, must be zero
+					 *
+					 * reserved00[5] = Train vrefDAC0 During Read Deskew
+					 *   0x1 = Read Deskew will begin by enabling and roughly
+					 *   training the phy's per-lane reference voltages.
+					 *   Training the vrefDACs CSRs will increase the maximum 1D
+					 *   training time by around half a millisecond, but will
+					 *   improve 1D training accuracy on systems with
+					 *   significant voltage-offsets between lane read eyes.
+					 *   0x0 = Read Deskew will assume the messageblock's
+					 *   phyVref setting will work for all lanes.
+					 *
+					 * reserved00[6] = Enable High Effort WrDQ1D
+					 *   0x1 = WrDQ1D will conditionally retry training at
+					 *   several extra RxClkDly Timings. This will increase the
+					 *   maximum 1D training time by up to 4 extra iterations of
+					 *   WrDQ1D. This is only required in systems that suffer
+					 *   from very large, asymmetric eye-collapse when receiving
+					 *   PRBS patterns.
+					 *   0x0 = WrDQ1D assume rxClkDly values found by SI
+					 *   Friendly RdDqs1D will work for receiving PRBS patterns
+					 *
+					 * reserved00[7] = Optimize for the special hard macros in
+					 * TSMC28.
+					 *   0x1 = set if the phy being trained was manufactured in
+					 *   any TSMC28 process node.
+					 *   0x0 = otherwise, when not training a TSMC28 phy, leave
+					 *   this field as 0.
+					 */
+	uint8_t msgmisc;		/*
+					 * Byte offset 0x01, CSR Addr 0x54000, Direction=In
+					 * Contains various global options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * msgmisc[0] = MTESTEnable
+					 *   0x1 = Pulse primary digital test output bump at the end
+					 *   of each major training stage. This enables observation
+					 *   of training stage completion by observing the digital
+					 *   test output.
+					 *   0x0 = Do not pulse primary digital test output bump
+					 *
+					 * msgmisc[1] = SimulationOnlyReset
+					 *   0x1 = Verilog only simulation option to shorten
+					 *   duration of DRAM reset pulse length to 1ns.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use reset pulse length specifed by JEDEC standard
+					 *
+					 * msgmisc[2] = SimulationOnlyTraining
+					 *   0x1 = Verilog only simulation option to shorten the
+					 *   duration of the training steps by performing fewer
+					 *   iterations.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use standard training duration.
+					 *
+					 * msgmisc[3] = RFU, must be zero
+					 *   0x1 = Program user characterized Vref DQ values per
+					 *   DDR4 DRAM device. The message block vrefdqr*nib* fields
+					 *   must be populated with the desired per device Vref DQs
+					 *   when using this option. Note: this option is not
+					 *   applicable in 2D training because these values are
+					 *   explicitly trained in 2D.
+					 *   0x0 = Program Vref DQ for all DDR4 devices with the
+					 *   single value provided in mr6 message block field
+					 *
+					 * msgmisc[4] = Suppress streaming messages, including
+					 * assertions, regardless of hdtctrl setting.
+					 * Stage Completion messages, as well as training completion
+					 * and error messages are still sent depending on hdtctrl
+					 * setting.
+					 *
+					 * msgmisc[5] = PerByteMaxRdLat
+					 *   0x1 = Each DBYTE will return dfi_rddata_valid at the
+					 *   lowest possible latency. This may result in unaligned
+					 *   data between bytes to be returned to the DFI.
+					 *   0x0 = Every DBYTE will return dfi_rddata_valid
+					 *   simultaneously. This will ensure that data bytes will
+					 *   return aligned accesses to the DFI.
+					 *
+					 * msgmisc[6] = PartialRank (DDR3 UDIMM and DDR4 UDIMM only,
+					 * otherwise RFU, must be zero)
+					 *   0x1 = Support rank populated with a subset of byte, but
+					 *   where even-odd pair of rank support all the byte
+					 *   0x0 = All rank populated with all the byte (tyical
+					 *   configuration)
+					 *
+					 * msgmisc[7] RFU, must be zero
+					 *
+					 * Notes:
+					 *
+					 * - SimulationOnlyReset and SimulationOnlyTraining can be
+					 *   used to speed up simulation run times, and must never
+					 *   be used in real silicon. Some VIPs may have checks on
+					 *   DRAM reset parameters that may need to be disabled when
+					 *   using SimulationOnlyReset.
+					 */
+	uint16_t pmurevision;		/*
+					 * Byte offset 0x02, CSR Addr 0x54001, Direction=Out
+					 * PMU firmware revision ID
+					 * After training is run, this address will contain the
+					 * revision ID of the firmware.
+					 * Please reference this revision ID when filing support
+					 * cases.
+					 */
+	uint8_t pstate;			/*
+					 * Byte offset 0x04, CSR Addr 0x54002, Direction=In
+					 * Must be set to the target pstate to be trained
+					 *   0x0 = pstate 0
+					 *   0x1 = pstate 1
+					 *   0x2 = pstate 2
+					 *   0x3 = pstate 3
+					 *   All other encodings are reserved
+					 */
+	uint8_t pllbypassen;		/*
+					 * Byte offset 0x05, CSR Addr 0x54002, Direction=In
+					 * Set according to whether target pstate uses PHY PLL
+					 * bypass
+					 *   0x0 = PHY PLL is enabled for target pstate
+					 *   0x1 = PHY PLL is bypassed for target pstate
+					 */
+	uint16_t dramfreq;		/*
+					 * Byte offset 0x06, CSR Addr 0x54003, Direction=In
+					 * DDR data rate for the target pstate in units of MT/s.
+					 * For example enter 0x0640 for DDR1600.
+					 */
+	uint8_t dfifreqratio;		/*
+					 * Byte offset 0x08, CSR Addr 0x54004, Direction=In
+					 * Frequency ratio betwen DfiCtlClk and SDRAM memclk.
+					 *   0x1 = 1:1
+					 *   0x2 = 1:2
+					 *   0x4 = 1:4
+					 */
+	uint8_t bpznresval;		/*
+					 * Byte offset 0x09, CSR Addr 0x54004, Direction=In
+					 * Overwrite the value of precision resistor connected to
+					 * Phy BP_ZN
+					 *   0x00 = Do not program. Use current CSR value.
+					 *   0xf0 = 240 Ohm
+					 *   0x78 = 120 Ohm
+					 *   0x28 = 40 Ohm
+					 *   All other values are reserved.
+					 * It is recommended to set this to 0x00.
+					 */
+	uint8_t phyodtimpedance;	/*
+					 * Byte offset 0x0a, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the termination impedance in ohms
+					 * used by PHY during reads.
+					 *
+					 * 0x0 = Firmware skips programming (must be manually
+					 * programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal termination impedance values.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must determine the correct value
+					 * through SI simulation or other methods.
+					 */
+	uint8_t phydrvimpedance;	/*
+					 * Byte offset 0x0b, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the driver impedance in ohms used
+					 * by PHY during writes for all DBYTE drivers
+					 * (DQ/DM/DBI/DQS).
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal R_on driver impedance values.
+					 *
+					 * For digital simulation, any value can be used that is not
+					 * Hi-Z. For silicon, the users must determine the correct
+					 * value through SI simulation or other methods.
+					 */
+	uint8_t phyvref;		/*
+					 * Byte offset 0x0c, CSR Addr 0x54006, Direction=In
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.75*VDDQ, set this field to
+					 * 0x60.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+	uint8_t dramtype;		/*
+					 * Byte offset 0x0d, CSR Addr 0x54006, Direction=In
+					 * Module Type:
+					 *   0x01 = Reserved
+					 *   0x02 = DDR4 unbuffered
+					 *   0x03 = Reserved
+					 *   0x04 = Reserved
+					 *   0x05 = Reserved
+					 */
+	uint8_t disableddbyte;		/*
+					 * Byte offset 0x0e, CSR Addr 0x54007, Direction=In
+					 * Bitmap to indicate which Dbyte are not connected (for
+					 * DByte 0 to 7):
+					 * Set disableddbyte[i] to 1 only to specify that DByte is
+					 * not need to be trained (DByte 8 can be disabled via
+					 * enableddqs setting)
+					 */
+	uint8_t enableddqs;		/*
+					 * Byte offset 0x0f, CSR Addr 0x54007, Direction=In
+					 * Total number of DQ bits enabled in PHY
+					 */
+	uint8_t cspresent;		/*
+					 * Byte offset 0x10, CSR Addr 0x54008, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY.
+					 * Each bit corresponds to a logical CS.
+					 *
+					 * If the bit is set to 1, the CS is connected to DRAM.
+					 * If the bit is set to 0, the CS is not connected to DRAM.
+					 *
+					 * cspresent[0] = CS0 is populated with DRAM
+					 * cspresent[1] = CS1 is populated with DRAM
+					 * cspresent[2] = CS2 is populated with DRAM
+					 * cspresent[3] = CS3 is populated with DRAM
+					 * cspresent[7:4] = Reserved (must be programmed to 0)
+					 */
+	uint8_t cspresentd0;		/*
+					 * Byte offset 0x11, CSR Addr 0x54008, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 0
+					 */
+	uint8_t cspresentd1;		/*
+					 * Byte offset 0x12, CSR Addr 0x54009, Direction=In
+					 * The CS signals from field cspresent that are routed to
+					 * DIMM connector 1
+					 */
+	uint8_t addrmirror;		/*
+					 * Byte offset 0x13, CSR Addr 0x54009, Direction=In
+					 * Corresponds to CS[3:0]
+					 *   1 = Address Mirror.
+					 *   0 = No Address Mirror.
+					 */
+	uint8_t cstestfail;		/*
+					 * Byte offset 0x14, CSR Addr 0x5400a, Direction=Out
+					 * This field will be set if training fails on any rank.
+					 *   0x0 = No failures
+					 *   non-zero = one or more ranks failed training
+					 */
+	uint8_t phycfg;			/*
+					 * Byte offset 0x15, CSR Addr 0x5400a, Direction=In
+					 * Additional mode bits.
+					 *
+					 * Bit fields:
+					 * [0] SlowAccessMode:
+					 *   1 = 2T Address Timing.
+					 *   0 = 1T Address Timing.
+					 * [7-1] RFU, must be zero
+					 *
+					 * WARNING: In case of DDR4 Geardown Mode (mr3[A3] == 1),
+					 * phycfg[0] must be 0.
+					 */
+	uint16_t sequencectrl;		/*
+					 * Byte offset 0x16, CSR Addr 0x5400b, Direction=In
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *		     initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *		     training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[10] = Run Reserved
+					 * sequencectrl[11] = Run Reserved
+					 * sequencectrl[12] = Run Reserved
+					 * sequencectrl[13] = Run Reserved
+					 * sequencectrl[15-14] = RFU, must be zero
+					 */
+	uint8_t hdtctrl;		/*
+					 * Byte offset 0x18, CSR Addr 0x5400c, Direction=In
+					 * To control the total number of debug messages, a
+					 * verbosity subfield (hdtctrl, Hardware Debug Trace
+					 * Control) exists in the message block. Every message has a
+					 * verbosity level associated with it, and as the hdtctrl
+					 * value is increased, less important s messages stop being
+					 * sent through the mailboxes. The meanings of several major
+					 * hdtctrl thresholds are explained below:
+					 *
+					 *   0x04 = Maximal debug messages (e.g., Eye contours)
+					 *   0x05 = Detailed debug messages (e.g. Eye delays)
+					 *   0x0A = Coarse debug messages (e.g. rank information)
+					 *   0xC8 = Stage completion
+					 *   0xC9 = Assertion messages
+					 *   0xFF = Firmware completion messages only
+					 */
+	uint8_t reserved19;		/* Byte offset 0x19, CSR Addr 0x5400c, Direction=N/A */
+	uint8_t reserved1a;		/* Byte offset 0x1a, CSR Addr 0x5400d, Direction=N/A */
+	uint8_t share2dvrefresult;	/*
+					 * Byte offset 0x1b, CSR Addr 0x5400d, Direction=In
+					 * Bitmap that designates the phy's vref source for every
+					 * pstate
+					 * If share2dvrefresult[x] = 0, then after 2D training,
+					 * pstate x will continue using the phyVref provided in
+					 * pstate x's 1D messageblock.
+					 * If share2dvrefresult[x] = 1, then after 2D training,
+					 * pstate x will use the per-lane VrefDAC0/1 CSRs trained by
+					 * 2d training.
+					 */
+	uint8_t reserved1c;		/* Byte offset 0x1c, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1d;		/* Byte offset 0x1d, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1e;		/*
+					 * Byte offset 0x1e, CSR Addr 0x5400f, Direction=In
+					 * Input for constraining the range of vref(DQ) values
+					 * training will collect data for, usually reducing training
+					 * time. However, too large of a voltage range may cause
+					 * longer 2D training times while too small of a voltage
+					 * range may truncate passing regions. When in doubt, leave
+					 * this field set to 0.
+					 * Used by 2D training in: Rd2D, Wr2D
+					 *
+					 * reserved1E[0-3]: Rd2D Voltage Range
+					 *   0 = Training will search all phy vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from phyVref
+					 *   2 = limit to +/-4 %VDDQ from phyVref
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from phyVref
+					 *
+					 * reserved1E[4-7]: Wr2D Voltage Range
+					 *   0 = Training will search all dram vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from mr6
+					 *   2 = limit to +/-4 %VDDQ from mr6
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from mr6
+					 */
+	uint8_t reserved1f;		/*
+					 * Byte offset 0x1f, CSR Addr 0x5400f, Direction=In
+					 * Extended training option:
+					 *
+					 * reserved1F[1:0]: Configured RxClkDly offset try during
+					 * WrDq1D high-effort (i.e., when reserved00[6] is set)
+					 *   0: -8, +8, -16, +16
+					 *   1: -4, +4, -8, +8, -12, +12, -16, +16
+					 *   2: -2, +2, -4, +4, -6, +6, -8, +8
+					 *   3: -2, +2, -4, +4, -6, +6, -8, +8, -10, +10, -12, +12,
+					 *      -14, +14, -16, +16
+					 *
+					 * reserved1F[2]: When set, execute again WrDq1D after
+					 * RdDqs1D PRBS
+					 * reserved1F[3]: When set redo RdDeskew with PRBS after
+					 * (first) WrDqs1D
+					 * reserved1F[7:4]: This field is reserved and must be
+					 * programmed to 0x00.
+					 */
+	uint8_t reserved20;		/*
+					 * Byte offset 0x20, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved MREP assume raising edge is found when
+					 * reserved20[3:0]+3 consecutive 1 are received during MREP
+					 * fine delay swept; reserved20[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved20[7]
+					 * is set, MREP training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint8_t reserved21;		/*
+					 * Byte offset 0x21, CSR Addr 0x54010, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for Reserved:
+					 * Reserved DWL assume raising edge is found when
+					 * reserved21[3:0]+3 consecutive 1 are received during DWL
+					 * fine delay swept; reserved21[6:0] thus permits to
+					 * increase tolerance for noisy system. And if reserved21[7]
+					 * is set, DWL training is failing if no raising edge is
+					 * found (otherwise the raising edge is assume close to
+					 * delay 0).
+					 */
+	uint16_t phyconfigoverride;	/*
+					 * Byte offset 0x22, CSR Addr 0x54011, Direction=In
+					 * Override PhyConfig csr.
+					 *   0x0: Use hardware csr value for PhyConfing
+					 *   (recommended)
+					 *   Other values: Use value for PhyConfig instead of
+					 *   Hardware value.
+					 */
+	uint8_t dfimrlmargin;		/*
+					 * Byte offset 0x24, CSR Addr 0x54012, Direction=In
+					 * Margin added to smallest passing trained DFI Max Read
+					 * Latency value, in units of DFI clocks. Recommended to be
+					 * >= 1.
+					 */
+	int8_t cdd_rr_3_2;		/*
+					 * Byte offset 0x25, CSR Addr 0x54012, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 2.
+					 */
+	int8_t cdd_rr_3_1;		/*
+					 * Byte offset 0x26, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 1.
+					 */
+	int8_t cdd_rr_3_0;		/*
+					 * Byte offset 0x27, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 3 to cs 0.
+					 */
+	int8_t cdd_rr_2_3;		/*
+					 * Byte offset 0x28, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 3.
+					 */
+	int8_t cdd_rr_2_1;		/*
+					 * Byte offset 0x29, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 1.
+					 */
+	int8_t cdd_rr_2_0;		/*
+					 * Byte offset 0x2a, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 2 to cs 0.
+					 */
+	int8_t cdd_rr_1_3;		/*
+					 * Byte offset 0x2b, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 3.
+					 */
+	int8_t cdd_rr_1_2;		/*
+					 * Byte offset 0x2c, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 2.
+					 */
+	int8_t cdd_rr_1_0;		/*
+					 * Byte offset 0x2d, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0.
+					 */
+	int8_t cdd_rr_0_3;		/*
+					 * Byte offset 0x2e, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 3.
+					 */
+	int8_t cdd_rr_0_2;		/*
+					 * Byte offset 0x2f, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 2.
+					 */
+	int8_t cdd_rr_0_1;		/*
+					 * Byte offset 0x30, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1.
+					 */
+	int8_t cdd_ww_3_2;		/*
+					 * Byte offset 0x31, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 2.
+					 */
+	int8_t cdd_ww_3_1;		/*
+					 * Byte offset 0x32, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 1.
+					 */
+	int8_t cdd_ww_3_0;		/*
+					 * Byte offset 0x33, CSR Addr 0x54019, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 3 to cs
+					 * 0.
+					 */
+	int8_t cdd_ww_2_3;		/*
+					 * Byte offset 0x34, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 3.
+					 */
+	int8_t cdd_ww_2_1;		/*
+					 * Byte offset 0x35, CSR Addr 0x5401a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 1.
+					 */
+	int8_t cdd_ww_2_0;		/*
+					 * Byte offset 0x36, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 2 to cs
+					 * 0.
+					 */
+	int8_t cdd_ww_1_3;		/*
+					 * Byte offset 0x37, CSR Addr 0x5401b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 3.
+					 */
+	int8_t cdd_ww_1_2;		/*
+					 * Byte offset 0x38, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 2.
+					 */
+	int8_t cdd_ww_1_0;		/*
+					 * Byte offset 0x39, CSR Addr 0x5401c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0.
+					 */
+	int8_t cdd_ww_0_3;		/*
+					 * Byte offset 0x3a, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 3.
+					 */
+	int8_t cdd_ww_0_2;		/*
+					 * Byte offset 0x3b, CSR Addr 0x5401d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 2.
+					 */
+	int8_t cdd_ww_0_1;		/*
+					 * Byte offset 0x3c, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1.
+					 */
+	int8_t cdd_rw_3_3;		/*
+					 * Byte offset 0x3d, CSR Addr 0x5401e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_3_2;		/*
+					 * Byte offset 0x3e, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_3_1;		/*
+					 * Byte offset 0x3f, CSR Addr 0x5401f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_3_0;		/*
+					 * Byte offset 0x40, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 3 to
+					 * cs 0.
+					 */
+	int8_t cdd_rw_2_3;		/*
+					 * Byte offset 0x41, CSR Addr 0x54020, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_2_2;		/*
+					 * Byte offset 0x42, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_2_1;		/*
+					 * Byte offset 0x43, CSR Addr 0x54021, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_2_0;		/*
+					 * Byte offset 0x44, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 2 to
+					 * cs 0.
+					 */
+	int8_t cdd_rw_1_3;		/*
+					 * Byte offset 0x45, CSR Addr 0x54022, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_1_2;		/*
+					 * Byte offset 0x46, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_1_1;		/*
+					 * Byte offset 0x47, CSR Addr 0x54023, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_1_0;		/*
+					 * Byte offset 0x48, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to
+					 * cs 0.
+					 */
+	int8_t cdd_rw_0_3;		/*
+					 * Byte offset 0x49, CSR Addr 0x54024, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 3.
+					 */
+	int8_t cdd_rw_0_2;		/*
+					 * Byte offset 0x4a, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 2.
+					 */
+	int8_t cdd_rw_0_1;		/*
+					 * Byte offset 0x4b, CSR Addr 0x54025, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 1.
+					 */
+	int8_t cdd_rw_0_0;		/*
+					 * Byte offset 0x4c, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_3_3;		/*
+					 * Byte offset 0x4d, CSR Addr 0x54026, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_3_2;		/*
+					 * Byte offset 0x4e, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_3_1;		/*
+					 * Byte offset 0x4f, CSR Addr 0x54027, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_3_0;		/*
+					 * Byte offset 0x50, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 3 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_2_3;		/*
+					 * Byte offset 0x51, CSR Addr 0x54028, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_2_2;		/*
+					 * Byte offset 0x52, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_2_1;		/*
+					 * Byte offset 0x53, CSR Addr 0x54029, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_2_0;		/*
+					 * Byte offset 0x54, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 2 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_1_3;		/*
+					 * Byte offset 0x55, CSR Addr 0x5402a, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_1_2;		/*
+					 * Byte offset 0x56, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_1_1;		/*
+					 * Byte offset 0x57, CSR Addr 0x5402b, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_1_0;		/*
+					 * Byte offset 0x58, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to
+					 * cs 0.
+					 */
+	int8_t cdd_wr_0_3;		/*
+					 * Byte offset 0x59, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 3.
+					 */
+	int8_t cdd_wr_0_2;		/*
+					 * Byte offset 0x5a, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 2.
+					 */
+	int8_t cdd_wr_0_1;		/*
+					 * Byte offset 0x5b, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 1.
+					 */
+	int8_t cdd_wr_0_0;		/*
+					 * Byte offset 0x5c, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to
+					 * cs 0.
+					 */
+	uint8_t reserved5d;		/*
+					 * Byte offset 0x5d, CSR Addr 0x5402e, Direction=In
+					 * This field is reserved and must be programmed to 0x00,
+					 * excepted for DDR4:
+					 * By default, if this parameter is 0, the offset applied at
+					 * the end of DDR4 RxEn training resulting in the trained
+					 * RxEnDly is 3/8 of the RX preamble width; if reserved5D is
+					 * non zero, this offset is used instead (in fine step).
+					 */
+	uint16_t mr0;			/*
+					 * Byte offset 0x5e, CSR Addr 0x5402f, Direction=In
+					 * Value of DDR mode register mr0 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr1;			/*
+					 * Byte offset 0x60, CSR Addr 0x54030, Direction=In
+					 * Value of DDR mode register mr1 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr2;			/*
+					 * Byte offset 0x62, CSR Addr 0x54031, Direction=In
+					 * Value of DDR mode register mr2 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr3;			/*
+					 * Byte offset 0x64, CSR Addr 0x54032, Direction=In
+					 * Value of DDR mode register mr3 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr4;			/*
+					 * Byte offset 0x66, CSR Addr 0x54033, Direction=In
+					 * Value of DDR mode register mr4 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr5;			/*
+					 * Byte offset 0x68, CSR Addr 0x54034, Direction=In
+					 * Value of DDR mode register mr5 for all ranks for current
+					 * pstate.
+					 */
+	uint16_t mr6;			/*
+					 * Byte offset 0x6a, CSR Addr 0x54035, Direction=In
+					 * Value of DDR mode register mr6 for all ranks for current
+					 * pstate. Note: The initial VrefDq value and range must be
+					 * set in A6:A0.
+					 */
+	uint8_t x16present;		/*
+					 * Byte offset 0x6c, CSR Addr 0x54036, Direction=In
+					 * X16 device map. Corresponds to CS[3:0].
+					 * x16present[0] = CS0 is populated with X16 devices
+					 * x16present[1] = CS1 is populated with X16 devices
+					 * x16present[2] = CS2 is populated with X16 devices
+					 * x16present[3] = CS3 is populated with X16 devices
+					 * x16present[7:4] = Reserved (must be programmed to 0)
+					 *
+					 * Ranks may not contain mixed device types.
+					 */
+	uint8_t cssetupgddec;		/*
+					 * Byte offset 0x6d, CSR Addr 0x54036, Direction=In
+					 * controls timing of chip select signals when DDR4
+					 * gear-down mode is active
+					 *   0 - Leave delay of chip select timing group signal
+					 *   the same both before and after gear-down sync occurs
+					 *   1 - Add 1UI of delay to chip select timing group
+					 *   signals when geardown-mode is active. This allows CS
+					 *   signals to have equal setup and hold time in gear-down
+					 *   mode
+					 */
+	uint16_t rtt_nom_wr_park0;	/*
+					 * Byte offset 0x6e, CSR Addr 0x54037, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 0
+					 * DRAM:
+					 * rtt_nom_wr_park0[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park0[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 0
+					 * rtt_nom_wr_park0[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 0
+					 * rtt_nom_wr_park0[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 0
+					 */
+	uint16_t rtt_nom_wr_park1;	/*
+					 * Byte offset 0x70, CSR Addr 0x54038, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 1
+					 * DRAM:
+					 * rtt_nom_wr_park1[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park1[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 1
+					 * rtt_nom_wr_park1[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 1
+					 * rtt_nom_wr_park1[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 1
+					 */
+	uint16_t rtt_nom_wr_park2;	/*
+					 * Byte offset 0x72, CSR Addr 0x54039, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 2
+					 * DRAM:
+					 * rtt_nom_wr_park2[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park2[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 2
+					 * rtt_nom_wr_park2[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 2
+					 * rtt_nom_wr_park2[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 2
+					 */
+	uint16_t rtt_nom_wr_park3;	/*
+					 * Byte offset 0x74, CSR Addr 0x5403a, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 3
+					 * DRAM:
+					 * rtt_nom_wr_park3[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park3[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 3
+					 * rtt_nom_wr_park3[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 3
+					 * rtt_nom_wr_park3[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 3
+					 */
+	uint16_t rtt_nom_wr_park4;	/*
+					 * Byte offset 0x76, CSR Addr 0x5403b, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 4
+					 * DRAM:
+					 * rtt_nom_wr_park4[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park4[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 4
+					 * rtt_nom_wr_park4[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 4
+					 * rtt_nom_wr_park4[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 4
+					 */
+	uint16_t rtt_nom_wr_park5;	/*
+					 * Byte offset 0x78, CSR Addr 0x5403c, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 5
+					 * DRAM:
+					 * rtt_nom_wr_park5[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park5[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 5
+					 * rtt_nom_wr_park5[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 5
+					 * rtt_nom_wr_park5[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 5
+					 */
+	uint16_t rtt_nom_wr_park6;	/*
+					 * Byte offset 0x7a, CSR Addr 0x5403d, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 6
+					 * DRAM:
+					 * rtt_nom_wr_park6[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park6[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 6
+					 * rtt_nom_wr_park6[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 6
+					 * rtt_nom_wr_park6[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 6
+					 */
+	uint16_t rtt_nom_wr_park7;	/*
+					 * Byte offset 0x7c, CSR Addr 0x5403e, Direction=In
+					 * Optional RTT_NOM, RTT_WR and RTT_PARK values for rank 7
+					 * DRAM:
+					 * rtt_nom_wr_park7[0] = 1: Option is enable (otherwise,
+					 * remaining bit fields are don't care)
+					 * rtt_nom_wr_park7[5:3]: Optional RTT_NOM value to be used
+					 * in mr1[10:8] for rank 7
+					 * rtt_nom_wr_park7[11:9]: Optional RTT_WR value to be used
+					 * in mr2[11:9] for rank 7
+					 * rtt_nom_wr_park7[8:6]: Optional RTT_PARK value to be used
+					 * in mr5[8:6] for rank 7
+					 */
+	uint8_t acsmodtctrl0;		/*
+					 * Byte offset 0x7e, CSR Addr 0x5403f, Direction=In
+					 * Odt pattern for accesses targeting rank 0. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl1;		/*
+					 * Byte offset 0x7f, CSR Addr 0x5403f, Direction=In
+					 * Odt pattern for accesses targeting rank 1. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl2;		/*
+					 * Byte offset 0x80, CSR Addr 0x54040, Direction=In
+					 * Odt pattern for accesses targeting rank 2. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl3;		/*
+					 * Byte offset 0x81, CSR Addr 0x54040, Direction=In
+					 * Odt pattern for accesses targeting rank 3. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl4;		/*
+					 * Byte offset 0x82, CSR Addr 0x54041, Direction=In
+					 * Odt pattern for accesses targeting rank 4. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl5;		/*
+					 * Byte offset 0x83, CSR Addr 0x54041, Direction=In
+					 * Odt pattern for accesses targeting rank 5. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl6;		/*
+					 * Byte offset 0x84, CSR Addr 0x54042, Direction=In
+					 * Odt pattern for accesses targeting rank 6. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t acsmodtctrl7;		/*
+					 * Byte offset 0x85, CSR Addr 0x54042, Direction=In
+					 * Odt pattern for accesses targeting rank 7. [3:0] is used
+					 * for write ODT [7:4] is used for read ODT
+					 */
+	uint8_t vrefdqr0nib0;		/*
+					 * Byte offset 0x86, CSR Addr 0x54043, Direction=InOut
+					 * VrefDq for rank 0 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib1;		/*
+					 * Byte offset 0x87, CSR Addr 0x54043, Direction=InOut
+					 * VrefDq for rank 0 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib2;		/*
+					 * Byte offset 0x88, CSR Addr 0x54044, Direction=InOut
+					 * VrefDq for rank 0 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib3;		/*
+					 * Byte offset 0x89, CSR Addr 0x54044, Direction=InOut
+					 * VrefDq for rank 0 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib0 for x16 devices, or
+					 * vrefdqr0nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib4;		/*
+					 * Byte offset 0x8a, CSR Addr 0x54045, Direction=InOut
+					 * VrefDq for rank 0 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib5;		/*
+					 * Byte offset 0x8b, CSR Addr 0x54045, Direction=InOut
+					 * VrefDq for rank 0 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib6;		/*
+					 * Byte offset 0x8c, CSR Addr 0x54046, Direction=InOut
+					 * VrefDq for rank 0 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib7;		/*
+					 * Byte offset 0x8d, CSR Addr 0x54046, Direction=InOut
+					 * VrefDq for rank 0 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib4 for x16 devices,
+					 * or vrefdqr0nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib8;		/*
+					 * Byte offset 0x8e, CSR Addr 0x54047, Direction=InOut
+					 * VrefDq for rank 0 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib9;		/*
+					 * Byte offset 0x8f, CSR Addr 0x54047, Direction=InOut
+					 * VrefDq for rank 0 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib10;		/*
+					 * Byte offset 0x90, CSR Addr 0x54048, Direction=InOut
+					 * VrefDq for rank 0 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib11;		/*
+					 * Byte offset 0x91, CSR Addr 0x54048, Direction=InOut
+					 * VrefDq for rank 0 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib8 for x16 devices,
+					 * or vrefdqr0nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib12;		/*
+					 * Byte offset 0x92, CSR Addr 0x54049, Direction=InOut
+					 * VrefDq for rank 0 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib13;		/*
+					 * Byte offset 0x93, CSR Addr 0x54049, Direction=InOut
+					 * VrefDq for rank 0 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib14;		/*
+					 * Byte offset 0x94, CSR Addr 0x5404a, Direction=InOut
+					 * VrefDq for rank 0 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib15;		/*
+					 * Byte offset 0x95, CSR Addr 0x5404a, Direction=InOut
+					 * VrefDq for rank 0 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib12 for x16 devices,
+					 * or vrefdqr0nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr0nib16;		/*
+					 * Byte offset 0x96, CSR Addr 0x5404b, Direction=InOut
+					 * VrefDq for rank 0 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr0nib17;		/*
+					 * Byte offset 0x97, CSR Addr 0x5404b, Direction=InOut
+					 * VrefDq for rank 0 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr0nib18;		/*
+					 * Byte offset 0x98, CSR Addr 0x5404c, Direction=InOut
+					 * VrefDq for rank 0 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr0nib19;		/*
+					 * Byte offset 0x99, CSR Addr 0x5404c, Direction=InOut
+					 * VrefDq for rank 0 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr0nib16 for x16 devices,
+					 * or vrefdqr0nib18 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib0;		/*
+					 * Byte offset 0x9a, CSR Addr 0x5404d, Direction=InOut
+					 * VrefDq for rank 1 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib1;		/*
+					 * Byte offset 0x9b, CSR Addr 0x5404d, Direction=InOut
+					 * VrefDq for rank 1 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib2;		/*
+					 * Byte offset 0x9c, CSR Addr 0x5404e, Direction=InOut
+					 * VrefDq for rank 1 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib3;		/*
+					 * Byte offset 0x9d, CSR Addr 0x5404e, Direction=InOut
+					 * VrefDq for rank 1 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib0 for x16 devices,
+					 * or vrefdqr1nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib4;		/*
+					 * Byte offset 0x9e, CSR Addr 0x5404f, Direction=InOut
+					 * VrefDq for rank 1 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib5;		/*
+					 * Byte offset 0x9f, CSR Addr 0x5404f, Direction=InOut
+					 * VrefDq for rank 1 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib6;		/*
+					 * Byte offset 0xa0, CSR Addr 0x54050, Direction=InOut
+					 * VrefDq for rank 1 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib7;		/*
+					 * Byte offset 0xa1, CSR Addr 0x54050, Direction=InOut
+					 * VrefDq for rank 1 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib4 for x16 devices,
+					 * or vrefdqr1nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib8;		/*
+					 * Byte offset 0xa2, CSR Addr 0x54051, Direction=InOut
+					 * VrefDq for rank 1 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib9;		/*
+					 * Byte offset 0xa3, CSR Addr 0x54051, Direction=InOut
+					 * VrefDq for rank 1 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib10;		/*
+					 * Byte offset 0xa4, CSR Addr 0x54052, Direction=InOut
+					 * VrefDq for rank 1 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib11;		/*
+					 * Byte offset 0xa5, CSR Addr 0x54052, Direction=InOut
+					 * VrefDq for rank 1 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib8 for x16 devices,
+					 * or vrefdqr1nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib12;		/*
+					 * Byte offset 0xa6, CSR Addr 0x54053, Direction=InOut
+					 * VrefDq for rank 1 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib13;		/*
+					 * Byte offset 0xa7, CSR Addr 0x54053, Direction=InOut
+					 * VrefDq for rank 1 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib14;		/*
+					 * Byte offset 0xa8, CSR Addr 0x54054, Direction=InOut
+					 * VrefDq for rank 1 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib15;		/*
+					 * Byte offset 0xa9, CSR Addr 0x54054, Direction=InOut
+					 * VrefDq for rank 1 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib12 for x16 devices,
+					 * or vrefdqr1nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr1nib16;		/*
+					 * Byte offset 0xaa, CSR Addr 0x54055, Direction=InOut
+					 * VrefDq for rank 1 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr1nib17;		/*
+					 * Byte offset 0xab, CSR Addr 0x54055, Direction=InOut
+					 * VrefDq for rank 1 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr1nib18;		/*
+					 * Byte offset 0xac, CSR Addr 0x54056, Direction=InOut
+					 * VrefDq for rank 1 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr1nib19;		/*
+					 * Byte offset 0xad, CSR Addr 0x54056, Direction=InOut
+					 * VrefDq for rank 1 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr1nib16 for x16 devices,
+					 * or vrefdqr1nib18 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib0;		/*
+					 * Byte offset 0xae, CSR Addr 0x54057, Direction=InOut
+					 * VrefDq for rank 2 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib1;		/*
+					 * Byte offset 0xaf, CSR Addr 0x54057, Direction=InOut
+					 * VrefDq for rank 2 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib2;		/*
+					 * Byte offset 0xb0, CSR Addr 0x54058, Direction=InOut
+					 * VrefDq for rank 2 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib3;		/*
+					 * Byte offset 0xb1, CSR Addr 0x54058, Direction=InOut
+					 * VrefDq for rank 2 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib0 for x16 devices,
+					 * or vrefdqr2nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib4;		/*
+					 * Byte offset 0xb2, CSR Addr 0x54059, Direction=InOut
+					 * VrefDq for rank 2 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib5;		/*
+					 * Byte offset 0xb3, CSR Addr 0x54059, Direction=InOut
+					 * VrefDq for rank 2 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib6;		/*
+					 * Byte offset 0xb4, CSR Addr 0x5405a, Direction=InOut
+					 * VrefDq for rank 2 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib7;		/*
+					 * Byte offset 0xb5, CSR Addr 0x5405a, Direction=InOut
+					 * VrefDq for rank 2 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib4 for x16 devices,
+					 * or vrefdqr2nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib8;		/*
+					 * Byte offset 0xb6, CSR Addr 0x5405b, Direction=InOut
+					 * VrefDq for rank 2 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib9;		/*
+					 * Byte offset 0xb7, CSR Addr 0x5405b, Direction=InOut
+					 * VrefDq for rank 2 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib10;		/*
+					 * Byte offset 0xb8, CSR Addr 0x5405c, Direction=InOut
+					 * VrefDq for rank 2 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib11;		/*
+					 * Byte offset 0xb9, CSR Addr 0x5405c, Direction=InOut
+					 * VrefDq for rank 2 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib8 for x16 devices,
+					 * or vrefdqr2nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib12;		/*
+					 * Byte offset 0xba, CSR Addr 0x5405d, Direction=InOut
+					 * VrefDq for rank 2 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib13;		/*
+					 * Byte offset 0xbb, CSR Addr 0x5405d, Direction=InOut
+					 * VrefDq for rank 2 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib14;		/*
+					 * Byte offset 0xbc, CSR Addr 0x5405e, Direction=InOut
+					 * VrefDq for rank 2 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib15;		/*
+					 * Byte offset 0xbd, CSR Addr 0x5405e, Direction=InOut
+					 * VrefDq for rank 2 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib12 for x16 devices,
+					 * or vrefdqr2nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr2nib16;		/*
+					 * Byte offset 0xbe, CSR Addr 0x5405f, Direction=InOut
+					 * VrefDq for rank 2 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr2nib17;		/*
+					 * Byte offset 0xbf, CSR Addr 0x5405f, Direction=InOut
+					 * VrefDq for rank 2 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr2nib18;		/*
+					 * Byte offset 0xc0, CSR Addr 0x54060, Direction=InOut
+					 * VrefDq for rank 2 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr2nib19;		/*
+					 * Byte offset 0xc1, CSR Addr 0x54060, Direction=InOut
+					 * VrefDq for rank 2 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr2nib16 for x16 devices,
+					 * or vrefdqr2nib18 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib0;		/*
+					 * Byte offset 0xc2, CSR Addr 0x54061, Direction=InOut
+					 * VrefDq for rank 3 nibble 0. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib1;		/*
+					 * Byte offset 0xc3, CSR Addr 0x54061, Direction=InOut
+					 * VrefDq for rank 3 nibble 1. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib0 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib2;		/*
+					 * Byte offset 0xc4, CSR Addr 0x54062, Direction=InOut
+					 * VrefDq for rank 3 nibble 2. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib0 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib3;		/*
+					 * Byte offset 0xc5, CSR Addr 0x54062, Direction=InOut
+					 * VrefDq for rank 3 nibble 3. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib0 for x16 devices,
+					 * or vrefdqr3nib2 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib4;		/*
+					 * Byte offset 0xc6, CSR Addr 0x54063, Direction=InOut
+					 * VrefDq for rank 3 nibble 4. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib5;		/*
+					 * Byte offset 0xc7, CSR Addr 0x54063, Direction=InOut
+					 * VrefDq for rank 3 nibble 5. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib4 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib6;		/*
+					 * Byte offset 0xc8, CSR Addr 0x54064, Direction=InOut
+					 * VrefDq for rank 3 nibble 6. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib4 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib7;		/*
+					 * Byte offset 0xc9, CSR Addr 0x54064, Direction=InOut
+					 * VrefDq for rank 3 nibble 7. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib4 for x16 devices,
+					 * or vrefdqr3nib6 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib8;		/*
+					 * Byte offset 0xca, CSR Addr 0x54065, Direction=InOut
+					 * VrefDq for rank 3 nibble 8. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib9;		/*
+					 * Byte offset 0xcb, CSR Addr 0x54065, Direction=InOut
+					 * VrefDq for rank 3 nibble 9. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib8 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib10;		/*
+					 * Byte offset 0xcc, CSR Addr 0x54066, Direction=InOut
+					 * VrefDq for rank 3 nibble 10. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib8 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib11;		/*
+					 * Byte offset 0xcd, CSR Addr 0x54066, Direction=InOut
+					 * VrefDq for rank 3 nibble 11. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib8 for x16 devices,
+					 * or vrefdqr3nib10 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib12;		/*
+					 * Byte offset 0xce, CSR Addr 0x54067, Direction=InOut
+					 * VrefDq for rank 3 nibble 12. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib13;		/*
+					 * Byte offset 0xcf, CSR Addr 0x54067, Direction=InOut
+					 * VrefDq for rank 3 nibble 13. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib12 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib14;		/*
+					 * Byte offset 0xd0, CSR Addr 0x54068, Direction=InOut
+					 * VrefDq for rank 3 nibble 14. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib12 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib15;		/*
+					 * Byte offset 0xd1, CSR Addr 0x54068, Direction=InOut
+					 * VrefDq for rank 3 nibble 15. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib12 for x16 devices,
+					 * or vrefdqr3nib14 for x8 devices.
+					 */
+	uint8_t vrefdqr3nib16;		/*
+					 * Byte offset 0xd2, CSR Addr 0x54069, Direction=InOut
+					 * VrefDq for rank 3 nibble 16. Specifies mr6[6:0]
+					 */
+	uint8_t vrefdqr3nib17;		/*
+					 * Byte offset 0xd3, CSR Addr 0x54069, Direction=InOut
+					 * VrefDq for rank 3 nibble 17. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib16 for x8 or x16 devices.
+					 */
+	uint8_t vrefdqr3nib18;		/*
+					 * Byte offset 0xd4, CSR Addr 0x5406a, Direction=InOut
+					 * VrefDq for rank 3 nibble 18. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib16 for x16 devices.
+					 */
+	uint8_t vrefdqr3nib19;		/*
+					 * Byte offset 0xd5, CSR Addr 0x5406a, Direction=InOut
+					 * VrefDq for rank 3 nibble 19. Specifies mr6[6:0].
+					 * Identical to vrefdqr3nib16 for x16 devices,
+					 * or vrefdqr3nib18 for x8 devices.
+					 */
+	uint8_t reservedd6;		/* Byte offset 0xd6, CSR Addr 0x5406b, Direction=N/A */
+	uint8_t reservedd7;		/* Byte offset 0xd7, CSR Addr 0x5406b, Direction=N/A */
+	uint8_t reservedd8;		/* Byte offset 0xd8, CSR Addr 0x5406c, Direction=N/A */
+	uint8_t reservedd9;		/* Byte offset 0xd9, CSR Addr 0x5406c, Direction=N/A */
+	uint8_t reservedda;		/* Byte offset 0xda, CSR Addr 0x5406d, Direction=N/A */
+	uint8_t reserveddb;		/* Byte offset 0xdb, CSR Addr 0x5406d, Direction=N/A */
+	uint8_t reserveddc;		/* Byte offset 0xdc, CSR Addr 0x5406e, Direction=N/A */
+	uint8_t reserveddd;		/* Byte offset 0xdd, CSR Addr 0x5406e, Direction=N/A */
+	uint8_t reservedde;		/* Byte offset 0xde, CSR Addr 0x5406f, Direction=N/A */
+	uint8_t reserveddf;		/* Byte offset 0xdf, CSR Addr 0x5406f, Direction=N/A */
+	uint8_t reservede0;		/* Byte offset 0xe0, CSR Addr 0x54070, Direction=N/A */
+	uint8_t reservede1;		/* Byte offset 0xe1, CSR Addr 0x54070, Direction=N/A */
+	uint8_t reservede2;		/* Byte offset 0xe2, CSR Addr 0x54071, Direction=N/A */
+	uint8_t reservede3;		/* Byte offset 0xe3, CSR Addr 0x54071, Direction=N/A */
+	uint8_t reservede4;		/* Byte offset 0xe4, CSR Addr 0x54072, Direction=N/A */
+	uint8_t reservede5;		/* Byte offset 0xe5, CSR Addr 0x54072, Direction=N/A */
+	uint8_t reservede6;		/* Byte offset 0xe6, CSR Addr 0x54073, Direction=N/A */
+	uint8_t reservede7;		/* Byte offset 0xe7, CSR Addr 0x54073, Direction=N/A */
+	uint8_t reservede8;		/* Byte offset 0xe8, CSR Addr 0x54074, Direction=N/A */
+	uint8_t reservede9;		/* Byte offset 0xe9, CSR Addr 0x54074, Direction=N/A */
+	uint8_t reservedea;		/* Byte offset 0xea, CSR Addr 0x54075, Direction=N/A */
+	uint8_t reservedeb;		/* Byte offset 0xeb, CSR Addr 0x54075, Direction=N/A */
+	uint8_t reservedec;		/* Byte offset 0xec, CSR Addr 0x54076, Direction=N/A */
+	uint8_t reserveded;		/* Byte offset 0xed, CSR Addr 0x54076, Direction=N/A */
+	uint8_t reservedee;		/* Byte offset 0xee, CSR Addr 0x54077, Direction=N/A */
+	uint8_t reservedef;		/* Byte offset 0xef, CSR Addr 0x54077, Direction=N/A */
+	uint8_t reservedf0;		/* Byte offset 0xf0, CSR Addr 0x54078, Direction=N/A */
+	uint8_t reservedf1;		/* Byte offset 0xf1, CSR Addr 0x54078, Direction=N/A */
+	uint8_t reservedf2;		/* Byte offset 0xf2, CSR Addr 0x54079, Direction=N/A */
+	uint8_t reservedf3;		/* Byte offset 0xf3, CSR Addr 0x54079, Direction=N/A */
+	uint8_t reservedf4;		/* Byte offset 0xf4, CSR Addr 0x5407a, Direction=N/A */
+	uint8_t reservedf5;		/* Byte offset 0xf5, CSR Addr 0x5407a, Direction=N/A */
+	uint8_t reservedf6;		/* Byte offset 0xf6, CSR Addr 0x5407b, Direction=N/A */
+	uint8_t reservedf7;		/* Byte offset 0xf7, CSR Addr 0x5407b, Direction=N/A */
+	uint8_t reservedf8;		/* Byte offset 0xf8, CSR Addr 0x5407c, Direction=N/A */
+	uint8_t reservedf9;		/* Byte offset 0xf9, CSR Addr 0x5407c, Direction=N/A */
+	uint8_t reservedfa;		/* Byte offset 0xfa, CSR Addr 0x5407d, Direction=N/A */
+	uint8_t reservedfb;		/* Byte offset 0xfb, CSR Addr 0x5407d, Direction=N/A */
+	uint8_t reservedfc;		/* Byte offset 0xfc, CSR Addr 0x5407e, Direction=N/A */
+	uint8_t reservedfd;		/* Byte offset 0xfd, CSR Addr 0x5407e, Direction=N/A */
+	uint8_t reservedfe;		/* Byte offset 0xfe, CSR Addr 0x5407f, Direction=N/A */
+	uint8_t reservedff;		/* Byte offset 0xff, CSR Addr 0x5407f, Direction=N/A */
+	uint8_t reserved100;		/* Byte offset 0x100, CSR Addr 0x54080, Direction=N/A */
+	uint8_t reserved101;		/* Byte offset 0x101, CSR Addr 0x54080, Direction=N/A */
+	uint8_t reserved102;		/* Byte offset 0x102, CSR Addr 0x54081, Direction=N/A */
+	uint8_t reserved103;		/* Byte offset 0x103, CSR Addr 0x54081, Direction=N/A */
+	uint8_t reserved104;		/* Byte offset 0x104, CSR Addr 0x54082, Direction=N/A */
+	uint8_t reserved105;		/* Byte offset 0x105, CSR Addr 0x54082, Direction=N/A */
+	uint8_t reserved106;		/* Byte offset 0x106, CSR Addr 0x54083, Direction=N/A */
+	uint8_t reserved107;		/* Byte offset 0x107, CSR Addr 0x54083, Direction=N/A */
+	uint8_t reserved108;		/* Byte offset 0x108, CSR Addr 0x54084, Direction=N/A */
+	uint8_t reserved109;		/* Byte offset 0x109, CSR Addr 0x54084, Direction=N/A */
+	uint8_t reserved10a;		/* Byte offset 0x10a, CSR Addr 0x54085, Direction=N/A */
+	uint8_t reserved10b;		/* Byte offset 0x10b, CSR Addr 0x54085, Direction=N/A */
+	uint8_t reserved10c;		/* Byte offset 0x10c, CSR Addr 0x54086, Direction=N/A */
+	uint8_t reserved10d;		/* Byte offset 0x10d, CSR Addr 0x54086, Direction=N/A */
+	uint8_t reserved10e;		/* Byte offset 0x10e, CSR Addr 0x54087, Direction=N/A */
+	uint8_t reserved10f;		/* Byte offset 0x10f, CSR Addr 0x54087, Direction=N/A */
+	uint8_t reserved110;		/* Byte offset 0x110, CSR Addr 0x54088, Direction=N/A */
+	uint8_t reserved111;		/* Byte offset 0x111, CSR Addr 0x54088, Direction=N/A */
+	uint8_t reserved112;		/* Byte offset 0x112, CSR Addr 0x54089, Direction=N/A */
+	uint8_t reserved113;		/* Byte offset 0x113, CSR Addr 0x54089, Direction=N/A */
+	uint8_t reserved114;		/* Byte offset 0x114, CSR Addr 0x5408a, Direction=N/A */
+	uint8_t reserved115;		/* Byte offset 0x115, CSR Addr 0x5408a, Direction=N/A */
+	uint8_t reserved116;		/* Byte offset 0x116, CSR Addr 0x5408b, Direction=N/A */
+	uint8_t reserved117;		/* Byte offset 0x117, CSR Addr 0x5408b, Direction=N/A */
+	uint8_t reserved118;		/* Byte offset 0x118, CSR Addr 0x5408c, Direction=N/A */
+	uint8_t reserved119;		/* Byte offset 0x119, CSR Addr 0x5408c, Direction=N/A */
+	uint8_t reserved11a;		/* Byte offset 0x11a, CSR Addr 0x5408d, Direction=N/A */
+	uint8_t reserved11b;		/* Byte offset 0x11b, CSR Addr 0x5408d, Direction=N/A */
+	uint8_t reserved11c;		/* Byte offset 0x11c, CSR Addr 0x5408e, Direction=N/A */
+	uint8_t reserved11d;		/* Byte offset 0x11d, CSR Addr 0x5408e, Direction=N/A */
+	uint8_t reserved11e;		/* Byte offset 0x11e, CSR Addr 0x5408f, Direction=N/A */
+	uint8_t reserved11f;		/* Byte offset 0x11f, CSR Addr 0x5408f, Direction=N/A */
+	uint8_t reserved120;		/* Byte offset 0x120, CSR Addr 0x54090, Direction=N/A */
+	uint8_t reserved121;		/* Byte offset 0x121, CSR Addr 0x54090, Direction=N/A */
+	uint8_t reserved122;		/* Byte offset 0x122, CSR Addr 0x54091, Direction=N/A */
+	uint8_t reserved123;		/* Byte offset 0x123, CSR Addr 0x54091, Direction=N/A */
+	uint8_t reserved124;		/* Byte offset 0x124, CSR Addr 0x54092, Direction=N/A */
+	uint8_t reserved125;		/* Byte offset 0x125, CSR Addr 0x54092, Direction=N/A */
+	uint8_t reserved126;		/* Byte offset 0x126, CSR Addr 0x54093, Direction=N/A */
+	uint8_t reserved127;		/* Byte offset 0x127, CSR Addr 0x54093, Direction=N/A */
+	uint8_t reserved128;		/* Byte offset 0x128, CSR Addr 0x54094, Direction=N/A */
+	uint8_t reserved129;		/* Byte offset 0x129, CSR Addr 0x54094, Direction=N/A */
+	uint8_t reserved12a;		/* Byte offset 0x12a, CSR Addr 0x54095, Direction=N/A */
+	uint8_t reserved12b;		/* Byte offset 0x12b, CSR Addr 0x54095, Direction=N/A */
+	uint8_t reserved12c;		/* Byte offset 0x12c, CSR Addr 0x54096, Direction=N/A */
+	uint8_t reserved12d;		/* Byte offset 0x12d, CSR Addr 0x54096, Direction=N/A */
+	uint8_t reserved12e;		/* Byte offset 0x12e, CSR Addr 0x54097, Direction=N/A */
+	uint8_t reserved12f;		/* Byte offset 0x12f, CSR Addr 0x54097, Direction=N/A */
+	uint8_t reserved130;		/* Byte offset 0x130, CSR Addr 0x54098, Direction=N/A */
+	uint8_t reserved131;		/* Byte offset 0x131, CSR Addr 0x54098, Direction=N/A */
+	uint8_t reserved132;		/* Byte offset 0x132, CSR Addr 0x54099, Direction=N/A */
+	uint8_t reserved133;		/* Byte offset 0x133, CSR Addr 0x54099, Direction=N/A */
+	uint8_t reserved134;		/* Byte offset 0x134, CSR Addr 0x5409a, Direction=N/A */
+	uint8_t reserved135;		/* Byte offset 0x135, CSR Addr 0x5409a, Direction=N/A */
+	uint8_t reserved136;		/* Byte offset 0x136, CSR Addr 0x5409b, Direction=N/A */
+	uint8_t reserved137;		/* Byte offset 0x137, CSR Addr 0x5409b, Direction=N/A */
+	uint8_t reserved138;		/* Byte offset 0x138, CSR Addr 0x5409c, Direction=N/A */
+	uint8_t reserved139;		/* Byte offset 0x139, CSR Addr 0x5409c, Direction=N/A */
+	uint8_t reserved13a;		/* Byte offset 0x13a, CSR Addr 0x5409d, Direction=N/A */
+	uint8_t reserved13b;		/* Byte offset 0x13b, CSR Addr 0x5409d, Direction=N/A */
+	uint8_t reserved13c;		/* Byte offset 0x13c, CSR Addr 0x5409e, Direction=N/A */
+	uint8_t reserved13d;		/* Byte offset 0x13d, CSR Addr 0x5409e, Direction=N/A */
+	uint8_t reserved13e;		/* Byte offset 0x13e, CSR Addr 0x5409f, Direction=N/A */
+	uint8_t reserved13f;		/* Byte offset 0x13f, CSR Addr 0x5409f, Direction=N/A */
+	uint8_t reserved140;		/* Byte offset 0x140, CSR Addr 0x540a0, Direction=N/A */
+	uint8_t reserved141;		/* Byte offset 0x141, CSR Addr 0x540a0, Direction=N/A */
+	uint8_t reserved142;		/* Byte offset 0x142, CSR Addr 0x540a1, Direction=N/A */
+	uint8_t reserved143;		/* Byte offset 0x143, CSR Addr 0x540a1, Direction=N/A */
+	uint8_t reserved144;		/* Byte offset 0x144, CSR Addr 0x540a2, Direction=N/A */
+	uint8_t reserved145;		/* Byte offset 0x145, CSR Addr 0x540a2, Direction=N/A */
+	uint8_t reserved146;		/* Byte offset 0x146, CSR Addr 0x540a3, Direction=N/A */
+	uint8_t reserved147;		/* Byte offset 0x147, CSR Addr 0x540a3, Direction=N/A */
+	uint8_t reserved148;		/* Byte offset 0x148, CSR Addr 0x540a4, Direction=N/A */
+	uint8_t reserved149;		/* Byte offset 0x149, CSR Addr 0x540a4, Direction=N/A */
+	uint8_t reserved14a;		/* Byte offset 0x14a, CSR Addr 0x540a5, Direction=N/A */
+	uint8_t reserved14b;		/* Byte offset 0x14b, CSR Addr 0x540a5, Direction=N/A */
+	uint8_t reserved14c;		/* Byte offset 0x14c, CSR Addr 0x540a6, Direction=N/A */
+	uint8_t reserved14d;		/* Byte offset 0x14d, CSR Addr 0x540a6, Direction=N/A */
+	uint8_t reserved14e;		/* Byte offset 0x14e, CSR Addr 0x540a7, Direction=N/A */
+	uint8_t reserved14f;		/* Byte offset 0x14f, CSR Addr 0x540a7, Direction=N/A */
+	uint8_t reserved150;		/* Byte offset 0x150, CSR Addr 0x540a8, Direction=N/A */
+	uint8_t reserved151;		/* Byte offset 0x151, CSR Addr 0x540a8, Direction=N/A */
+	uint8_t reserved152;		/* Byte offset 0x152, CSR Addr 0x540a9, Direction=N/A */
+	uint8_t reserved153;		/* Byte offset 0x153, CSR Addr 0x540a9, Direction=N/A */
+	uint8_t reserved154;		/* Byte offset 0x154, CSR Addr 0x540aa, Direction=N/A */
+	uint8_t reserved155;		/* Byte offset 0x155, CSR Addr 0x540aa, Direction=N/A */
+	uint8_t reserved156;		/* Byte offset 0x156, CSR Addr 0x540ab, Direction=N/A */
+	uint8_t reserved157;		/* Byte offset 0x157, CSR Addr 0x540ab, Direction=N/A */
+	uint8_t reserved158;		/* Byte offset 0x158, CSR Addr 0x540ac, Direction=N/A */
+	uint8_t reserved159;		/* Byte offset 0x159, CSR Addr 0x540ac, Direction=N/A */
+	uint8_t reserved15a;		/* Byte offset 0x15a, CSR Addr 0x540ad, Direction=N/A */
+	uint8_t reserved15b;		/* Byte offset 0x15b, CSR Addr 0x540ad, Direction=N/A */
+	uint8_t reserved15c;		/* Byte offset 0x15c, CSR Addr 0x540ae, Direction=N/A */
+	uint8_t reserved15d;		/* Byte offset 0x15d, CSR Addr 0x540ae, Direction=N/A */
+	uint8_t reserved15e;		/* Byte offset 0x15e, CSR Addr 0x540af, Direction=N/A */
+	uint8_t reserved15f;		/* Byte offset 0x15f, CSR Addr 0x540af, Direction=N/A */
+	uint8_t reserved160;		/* Byte offset 0x160, CSR Addr 0x540b0, Direction=N/A */
+	uint8_t reserved161;		/* Byte offset 0x161, CSR Addr 0x540b0, Direction=N/A */
+	uint8_t reserved162;		/* Byte offset 0x162, CSR Addr 0x540b1, Direction=N/A */
+	uint8_t reserved163;		/* Byte offset 0x163, CSR Addr 0x540b1, Direction=N/A */
+	uint8_t reserved164;		/* Byte offset 0x164, CSR Addr 0x540b2, Direction=N/A */
+	uint8_t reserved165;		/* Byte offset 0x165, CSR Addr 0x540b2, Direction=N/A */
+	uint8_t reserved166;		/* Byte offset 0x166, CSR Addr 0x540b3, Direction=N/A */
+	uint8_t reserved167;		/* Byte offset 0x167, CSR Addr 0x540b3, Direction=N/A */
+	uint8_t reserved168;		/* Byte offset 0x168, CSR Addr 0x540b4, Direction=N/A */
+	uint8_t reserved169;		/* Byte offset 0x169, CSR Addr 0x540b4, Direction=N/A */
+	uint8_t reserved16a;		/* Byte offset 0x16a, CSR Addr 0x540b5, Direction=N/A */
+	uint8_t reserved16b;		/* Byte offset 0x16b, CSR Addr 0x540b5, Direction=N/A */
+	uint8_t reserved16c;		/* Byte offset 0x16c, CSR Addr 0x540b6, Direction=N/A */
+	uint8_t reserved16d;		/* Byte offset 0x16d, CSR Addr 0x540b6, Direction=N/A */
+	uint8_t reserved16e;		/* Byte offset 0x16e, CSR Addr 0x540b7, Direction=N/A */
+	uint8_t reserved16f;		/* Byte offset 0x16f, CSR Addr 0x540b7, Direction=N/A */
+	uint8_t reserved170;		/* Byte offset 0x170, CSR Addr 0x540b8, Direction=N/A */
+	uint8_t reserved171;		/* Byte offset 0x171, CSR Addr 0x540b8, Direction=N/A */
+	uint8_t reserved172;		/* Byte offset 0x172, CSR Addr 0x540b9, Direction=N/A */
+	uint8_t reserved173;		/* Byte offset 0x173, CSR Addr 0x540b9, Direction=N/A */
+	uint8_t reserved174;		/* Byte offset 0x174, CSR Addr 0x540ba, Direction=N/A */
+	uint8_t reserved175;		/* Byte offset 0x175, CSR Addr 0x540ba, Direction=N/A */
+	uint8_t reserved176;		/* Byte offset 0x176, CSR Addr 0x540bb, Direction=N/A */
+	uint8_t reserved177;		/* Byte offset 0x177, CSR Addr 0x540bb, Direction=N/A */
+	uint8_t reserved178;		/* Byte offset 0x178, CSR Addr 0x540bc, Direction=N/A */
+	uint8_t reserved179;		/* Byte offset 0x179, CSR Addr 0x540bc, Direction=N/A */
+	uint8_t reserved17a;		/* Byte offset 0x17a, CSR Addr 0x540bd, Direction=N/A */
+	uint8_t reserved17b;		/* Byte offset 0x17b, CSR Addr 0x540bd, Direction=N/A */
+	uint8_t reserved17c;		/* Byte offset 0x17c, CSR Addr 0x540be, Direction=N/A */
+	uint8_t reserved17d;		/* Byte offset 0x17d, CSR Addr 0x540be, Direction=N/A */
+	uint8_t reserved17e;		/* Byte offset 0x17e, CSR Addr 0x540bf, Direction=N/A */
+	uint8_t reserved17f;		/* Byte offset 0x17f, CSR Addr 0x540bf, Direction=N/A */
+	uint8_t reserved180;		/* Byte offset 0x180, CSR Addr 0x540c0, Direction=N/A */
+	uint8_t reserved181;		/* Byte offset 0x181, CSR Addr 0x540c0, Direction=N/A */
+	uint8_t reserved182;		/* Byte offset 0x182, CSR Addr 0x540c1, Direction=N/A */
+	uint8_t reserved183;		/* Byte offset 0x183, CSR Addr 0x540c1, Direction=N/A */
+	uint8_t reserved184;		/* Byte offset 0x184, CSR Addr 0x540c2, Direction=N/A */
+	uint8_t reserved185;		/* Byte offset 0x185, CSR Addr 0x540c2, Direction=N/A */
+	uint8_t reserved186;		/* Byte offset 0x186, CSR Addr 0x540c3, Direction=N/A */
+	uint8_t reserved187;		/* Byte offset 0x187, CSR Addr 0x540c3, Direction=N/A */
+	uint8_t reserved188;		/* Byte offset 0x188, CSR Addr 0x540c4, Direction=N/A */
+	uint8_t reserved189;		/* Byte offset 0x189, CSR Addr 0x540c4, Direction=N/A */
+	uint8_t reserved18a;		/* Byte offset 0x18a, CSR Addr 0x540c5, Direction=N/A */
+	uint8_t reserved18b;		/* Byte offset 0x18b, CSR Addr 0x540c5, Direction=N/A */
+	uint8_t reserved18c;		/* Byte offset 0x18c, CSR Addr 0x540c6, Direction=N/A */
+	uint8_t reserved18d;		/* Byte offset 0x18d, CSR Addr 0x540c6, Direction=N/A */
+	uint8_t reserved18e;		/* Byte offset 0x18e, CSR Addr 0x540c7, Direction=N/A */
+	uint8_t reserved18f;		/* Byte offset 0x18f, CSR Addr 0x540c7, Direction=N/A */
+	uint8_t reserved190;		/* Byte offset 0x190, CSR Addr 0x540c8, Direction=N/A */
+	uint8_t reserved191;		/* Byte offset 0x191, CSR Addr 0x540c8, Direction=N/A */
+	uint8_t reserved192;		/* Byte offset 0x192, CSR Addr 0x540c9, Direction=N/A */
+	uint8_t reserved193;		/* Byte offset 0x193, CSR Addr 0x540c9, Direction=N/A */
+	uint8_t reserved194;		/* Byte offset 0x194, CSR Addr 0x540ca, Direction=N/A */
+	uint8_t reserved195;		/* Byte offset 0x195, CSR Addr 0x540ca, Direction=N/A */
+	uint8_t reserved196;		/* Byte offset 0x196, CSR Addr 0x540cb, Direction=N/A */
+	uint8_t reserved197;		/* Byte offset 0x197, CSR Addr 0x540cb, Direction=N/A */
+	uint8_t reserved198;		/* Byte offset 0x198, CSR Addr 0x540cc, Direction=N/A */
+	uint8_t reserved199;		/* Byte offset 0x199, CSR Addr 0x540cc, Direction=N/A */
+	uint8_t reserved19a;		/* Byte offset 0x19a, CSR Addr 0x540cd, Direction=N/A */
+	uint8_t reserved19b;		/* Byte offset 0x19b, CSR Addr 0x540cd, Direction=N/A */
+	uint8_t reserved19c;		/* Byte offset 0x19c, CSR Addr 0x540ce, Direction=N/A */
+	uint8_t reserved19d;		/* Byte offset 0x19d, CSR Addr 0x540ce, Direction=N/A */
+	uint8_t reserved19e;		/* Byte offset 0x19e, CSR Addr 0x540cf, Direction=N/A */
+	uint8_t reserved19f;		/* Byte offset 0x19f, CSR Addr 0x540cf, Direction=N/A */
+	uint8_t reserved1a0;		/* Byte offset 0x1a0, CSR Addr 0x540d0, Direction=N/A */
+	uint8_t reserved1a1;		/* Byte offset 0x1a1, CSR Addr 0x540d0, Direction=N/A */
+	uint8_t reserved1a2;		/* Byte offset 0x1a2, CSR Addr 0x540d1, Direction=N/A */
+	uint8_t reserved1a3;		/* Byte offset 0x1a3, CSR Addr 0x540d1, Direction=N/A */
+	uint8_t reserved1a4;		/* Byte offset 0x1a4, CSR Addr 0x540d2, Direction=N/A */
+	uint8_t reserved1a5;		/* Byte offset 0x1a5, CSR Addr 0x540d2, Direction=N/A */
+	uint8_t reserved1a6;		/* Byte offset 0x1a6, CSR Addr 0x540d3, Direction=N/A */
+	uint8_t reserved1a7;		/* Byte offset 0x1a7, CSR Addr 0x540d3, Direction=N/A */
+	uint8_t reserved1a8;		/* Byte offset 0x1a8, CSR Addr 0x540d4, Direction=N/A */
+	uint8_t reserved1a9;		/* Byte offset 0x1a9, CSR Addr 0x540d4, Direction=N/A */
+	uint8_t reserved1aa;		/* Byte offset 0x1aa, CSR Addr 0x540d5, Direction=N/A */
+	uint8_t reserved1ab;		/* Byte offset 0x1ab, CSR Addr 0x540d5, Direction=N/A */
+	uint8_t reserved1ac;		/* Byte offset 0x1ac, CSR Addr 0x540d6, Direction=N/A */
+	uint8_t reserved1ad;		/* Byte offset 0x1ad, CSR Addr 0x540d6, Direction=N/A */
+	uint8_t reserved1ae;		/* Byte offset 0x1ae, CSR Addr 0x540d7, Direction=N/A */
+	uint8_t reserved1af;		/* Byte offset 0x1af, CSR Addr 0x540d7, Direction=N/A */
+	uint8_t reserved1b0;		/* Byte offset 0x1b0, CSR Addr 0x540d8, Direction=N/A */
+	uint8_t reserved1b1;		/* Byte offset 0x1b1, CSR Addr 0x540d8, Direction=N/A */
+	uint8_t reserved1b2;		/* Byte offset 0x1b2, CSR Addr 0x540d9, Direction=N/A */
+	uint8_t reserved1b3;		/* Byte offset 0x1b3, CSR Addr 0x540d9, Direction=N/A */
+	uint8_t reserved1b4;		/* Byte offset 0x1b4, CSR Addr 0x540da, Direction=N/A */
+	uint8_t reserved1b5;		/* Byte offset 0x1b5, CSR Addr 0x540da, Direction=N/A */
+	uint8_t reserved1b6;		/* Byte offset 0x1b6, CSR Addr 0x540db, Direction=N/A */
+	uint8_t reserved1b7;		/* Byte offset 0x1b7, CSR Addr 0x540db, Direction=N/A */
+	uint8_t reserved1b8;		/* Byte offset 0x1b8, CSR Addr 0x540dc, Direction=N/A */
+	uint8_t reserved1b9;		/* Byte offset 0x1b9, CSR Addr 0x540dc, Direction=N/A */
+	uint8_t reserved1ba;		/* Byte offset 0x1ba, CSR Addr 0x540dd, Direction=N/A */
+	uint8_t reserved1bb;		/* Byte offset 0x1bb, CSR Addr 0x540dd, Direction=N/A */
+	uint8_t reserved1bc;		/* Byte offset 0x1bc, CSR Addr 0x540de, Direction=N/A */
+	uint8_t reserved1bd;		/* Byte offset 0x1bd, CSR Addr 0x540de, Direction=N/A */
+	uint8_t reserved1be;		/* Byte offset 0x1be, CSR Addr 0x540df, Direction=N/A */
+	uint8_t reserved1bf;		/* Byte offset 0x1bf, CSR Addr 0x540df, Direction=N/A */
+	uint8_t reserved1c0;		/* Byte offset 0x1c0, CSR Addr 0x540e0, Direction=N/A */
+	uint8_t reserved1c1;		/* Byte offset 0x1c1, CSR Addr 0x540e0, Direction=N/A */
+	uint8_t reserved1c2;		/* Byte offset 0x1c2, CSR Addr 0x540e1, Direction=N/A */
+	uint8_t reserved1c3;		/* Byte offset 0x1c3, CSR Addr 0x540e1, Direction=N/A */
+	uint8_t reserved1c4;		/* Byte offset 0x1c4, CSR Addr 0x540e2, Direction=N/A */
+	uint8_t reserved1c5;		/* Byte offset 0x1c5, CSR Addr 0x540e2, Direction=N/A */
+	uint8_t reserved1c6;		/* Byte offset 0x1c6, CSR Addr 0x540e3, Direction=N/A */
+	uint8_t reserved1c7;		/* Byte offset 0x1c7, CSR Addr 0x540e3, Direction=N/A */
+	uint8_t reserved1c8;		/* Byte offset 0x1c8, CSR Addr 0x540e4, Direction=N/A */
+	uint8_t reserved1c9;		/* Byte offset 0x1c9, CSR Addr 0x540e4, Direction=N/A */
+	uint8_t reserved1ca;		/* Byte offset 0x1ca, CSR Addr 0x540e5, Direction=N/A */
+	uint8_t reserved1cb;		/* Byte offset 0x1cb, CSR Addr 0x540e5, Direction=N/A */
+	uint8_t reserved1cc;		/* Byte offset 0x1cc, CSR Addr 0x540e6, Direction=N/A */
+	uint8_t reserved1cd;		/* Byte offset 0x1cd, CSR Addr 0x540e6, Direction=N/A */
+	uint8_t reserved1ce;		/* Byte offset 0x1ce, CSR Addr 0x540e7, Direction=N/A */
+	uint8_t reserved1cf;		/* Byte offset 0x1cf, CSR Addr 0x540e7, Direction=N/A */
+	uint8_t reserved1d0;		/* Byte offset 0x1d0, CSR Addr 0x540e8, Direction=N/A */
+	uint8_t reserved1d1;		/* Byte offset 0x1d1, CSR Addr 0x540e8, Direction=N/A */
+	uint8_t reserved1d2;		/* Byte offset 0x1d2, CSR Addr 0x540e9, Direction=N/A */
+	uint8_t reserved1d3;		/* Byte offset 0x1d3, CSR Addr 0x540e9, Direction=N/A */
+	uint8_t reserved1d4;		/* Byte offset 0x1d4, CSR Addr 0x540ea, Direction=N/A */
+	uint8_t reserved1d5;		/* Byte offset 0x1d5, CSR Addr 0x540ea, Direction=N/A */
+	uint8_t reserved1d6;		/* Byte offset 0x1d6, CSR Addr 0x540eb, Direction=N/A */
+	uint8_t reserved1d7;		/* Byte offset 0x1d7, CSR Addr 0x540eb, Direction=N/A */
+	uint8_t reserved1d8;		/* Byte offset 0x1d8, CSR Addr 0x540ec, Direction=N/A */
+	uint8_t reserved1d9;		/* Byte offset 0x1d9, CSR Addr 0x540ec, Direction=N/A */
+	uint8_t reserved1da;		/* Byte offset 0x1da, CSR Addr 0x540ed, Direction=N/A */
+	uint8_t reserved1db;		/* Byte offset 0x1db, CSR Addr 0x540ed, Direction=N/A */
+	uint8_t reserved1dc;		/* Byte offset 0x1dc, CSR Addr 0x540ee, Direction=N/A */
+	uint8_t reserved1dd;		/* Byte offset 0x1dd, CSR Addr 0x540ee, Direction=N/A */
+	uint8_t reserved1de;		/* Byte offset 0x1de, CSR Addr 0x540ef, Direction=N/A */
+	uint8_t reserved1df;		/* Byte offset 0x1df, CSR Addr 0x540ef, Direction=N/A */
+	uint8_t reserved1e0;		/* Byte offset 0x1e0, CSR Addr 0x540f0, Direction=N/A */
+	uint8_t reserved1e1;		/* Byte offset 0x1e1, CSR Addr 0x540f0, Direction=N/A */
+	uint8_t reserved1e2;		/* Byte offset 0x1e2, CSR Addr 0x540f1, Direction=N/A */
+	uint8_t reserved1e3;		/* Byte offset 0x1e3, CSR Addr 0x540f1, Direction=N/A */
+	uint8_t reserved1e4;		/* Byte offset 0x1e4, CSR Addr 0x540f2, Direction=N/A */
+	uint8_t reserved1e5;		/* Byte offset 0x1e5, CSR Addr 0x540f2, Direction=N/A */
+	uint8_t reserved1e6;		/* Byte offset 0x1e6, CSR Addr 0x540f3, Direction=N/A */
+	uint8_t reserved1e7;		/* Byte offset 0x1e7, CSR Addr 0x540f3, Direction=N/A */
+	uint8_t reserved1e8;		/* Byte offset 0x1e8, CSR Addr 0x540f4, Direction=N/A */
+	uint8_t reserved1e9;		/* Byte offset 0x1e9, CSR Addr 0x540f4, Direction=N/A */
+	uint8_t reserved1ea;		/* Byte offset 0x1ea, CSR Addr 0x540f5, Direction=N/A */
+	uint8_t reserved1eb;		/* Byte offset 0x1eb, CSR Addr 0x540f5, Direction=N/A */
+	uint8_t reserved1ec;		/* Byte offset 0x1ec, CSR Addr 0x540f6, Direction=N/A */
+	uint8_t reserved1ed;		/* Byte offset 0x1ed, CSR Addr 0x540f6, Direction=N/A */
+	uint8_t reserved1ee;		/* Byte offset 0x1ee, CSR Addr 0x540f7, Direction=N/A */
+	uint8_t reserved1ef;		/* Byte offset 0x1ef, CSR Addr 0x540f7, Direction=N/A */
+	uint8_t reserved1f0;		/* Byte offset 0x1f0, CSR Addr 0x540f8, Direction=N/A */
+	uint8_t reserved1f1;		/* Byte offset 0x1f1, CSR Addr 0x540f8, Direction=N/A */
+	uint8_t reserved1f2;		/* Byte offset 0x1f2, CSR Addr 0x540f9, Direction=N/A */
+	uint8_t reserved1f3;		/* Byte offset 0x1f3, CSR Addr 0x540f9, Direction=N/A */
+	uint8_t reserved1f4;		/* Byte offset 0x1f4, CSR Addr 0x540fa, Direction=N/A */
+	uint8_t reserved1f5;		/* Byte offset 0x1f5, CSR Addr 0x540fa, Direction=N/A */
+	uint8_t reserved1f6;		/* Byte offset 0x1f6, CSR Addr 0x540fb, Direction=N/A */
+	uint8_t reserved1f7;		/* Byte offset 0x1f7, CSR Addr 0x540fb, Direction=N/A */
+	uint8_t reserved1f8;		/* Byte offset 0x1f8, CSR Addr 0x540fc, Direction=N/A */
+	uint8_t reserved1f9;		/* Byte offset 0x1f9, CSR Addr 0x540fc, Direction=N/A */
+	uint8_t reserved1fa;		/* Byte offset 0x1fa, CSR Addr 0x540fd, Direction=N/A */
+	uint8_t reserved1fb;		/* Byte offset 0x1fb, CSR Addr 0x540fd, Direction=N/A */
+	uint8_t reserved1fc;		/* Byte offset 0x1fc, CSR Addr 0x540fe, Direction=N/A */
+	uint8_t reserved1fd;		/* Byte offset 0x1fd, CSR Addr 0x540fe, Direction=N/A */
+	uint8_t reserved1fe;		/* Byte offset 0x1fe, CSR Addr 0x540ff, Direction=N/A */
+	uint8_t reserved1ff;		/* Byte offset 0x1ff, CSR Addr 0x540ff, Direction=N/A */
+	uint8_t reserved200;		/* Byte offset 0x200, CSR Addr 0x54100, Direction=N/A */
+	uint8_t reserved201;		/* Byte offset 0x201, CSR Addr 0x54100, Direction=N/A */
+	uint8_t reserved202;		/* Byte offset 0x202, CSR Addr 0x54101, Direction=N/A */
+	uint8_t reserved203;		/* Byte offset 0x203, CSR Addr 0x54101, Direction=N/A */
+	uint8_t reserved204;		/* Byte offset 0x204, CSR Addr 0x54102, Direction=N/A */
+	uint8_t reserved205;		/* Byte offset 0x205, CSR Addr 0x54102, Direction=N/A */
+	uint8_t reserved206;		/* Byte offset 0x206, CSR Addr 0x54103, Direction=N/A */
+	uint8_t reserved207;		/* Byte offset 0x207, CSR Addr 0x54103, Direction=N/A */
+	uint8_t reserved208;		/* Byte offset 0x208, CSR Addr 0x54104, Direction=N/A */
+	uint8_t reserved209;		/* Byte offset 0x209, CSR Addr 0x54104, Direction=N/A */
+	uint8_t reserved20a;		/* Byte offset 0x20a, CSR Addr 0x54105, Direction=N/A */
+	uint8_t reserved20b;		/* Byte offset 0x20b, CSR Addr 0x54105, Direction=N/A */
+	uint8_t reserved20c;		/* Byte offset 0x20c, CSR Addr 0x54106, Direction=N/A */
+	uint8_t reserved20d;		/* Byte offset 0x20d, CSR Addr 0x54106, Direction=N/A */
+	uint8_t reserved20e;		/* Byte offset 0x20e, CSR Addr 0x54107, Direction=N/A */
+	uint8_t reserved20f;		/* Byte offset 0x20f, CSR Addr 0x54107, Direction=N/A */
+	uint8_t reserved210;		/* Byte offset 0x210, CSR Addr 0x54108, Direction=N/A */
+	uint8_t reserved211;		/* Byte offset 0x211, CSR Addr 0x54108, Direction=N/A */
+	uint8_t reserved212;		/* Byte offset 0x212, CSR Addr 0x54109, Direction=N/A */
+	uint8_t reserved213;		/* Byte offset 0x213, CSR Addr 0x54109, Direction=N/A */
+	uint8_t reserved214;		/* Byte offset 0x214, CSR Addr 0x5410a, Direction=N/A */
+	uint8_t reserved215;		/* Byte offset 0x215, CSR Addr 0x5410a, Direction=N/A */
+	uint8_t reserved216;		/* Byte offset 0x216, CSR Addr 0x5410b, Direction=N/A */
+	uint8_t reserved217;		/* Byte offset 0x217, CSR Addr 0x5410b, Direction=N/A */
+	uint8_t reserved218;		/* Byte offset 0x218, CSR Addr 0x5410c, Direction=N/A */
+	uint8_t reserved219;		/* Byte offset 0x219, CSR Addr 0x5410c, Direction=N/A */
+	uint8_t reserved21a;		/* Byte offset 0x21a, CSR Addr 0x5410d, Direction=N/A */
+	uint8_t reserved21b;		/* Byte offset 0x21b, CSR Addr 0x5410d, Direction=N/A */
+	uint8_t reserved21c;		/* Byte offset 0x21c, CSR Addr 0x5410e, Direction=N/A */
+	uint8_t reserved21d;		/* Byte offset 0x21d, CSR Addr 0x5410e, Direction=N/A */
+	uint8_t reserved21e;		/* Byte offset 0x21e, CSR Addr 0x5410f, Direction=N/A */
+	uint8_t reserved21f;		/* Byte offset 0x21f, CSR Addr 0x5410f, Direction=N/A */
+	uint8_t reserved220;		/* Byte offset 0x220, CSR Addr 0x54110, Direction=N/A */
+	uint8_t reserved221;		/* Byte offset 0x221, CSR Addr 0x54110, Direction=N/A */
+	uint8_t reserved222;		/* Byte offset 0x222, CSR Addr 0x54111, Direction=N/A */
+	uint8_t reserved223;		/* Byte offset 0x223, CSR Addr 0x54111, Direction=N/A */
+	uint8_t reserved224;		/* Byte offset 0x224, CSR Addr 0x54112, Direction=N/A */
+	uint8_t reserved225;		/* Byte offset 0x225, CSR Addr 0x54112, Direction=N/A */
+	uint8_t reserved226;		/* Byte offset 0x226, CSR Addr 0x54113, Direction=N/A */
+	uint8_t reserved227;		/* Byte offset 0x227, CSR Addr 0x54113, Direction=N/A */
+	uint8_t reserved228;		/* Byte offset 0x228, CSR Addr 0x54114, Direction=N/A */
+	uint8_t reserved229;		/* Byte offset 0x229, CSR Addr 0x54114, Direction=N/A */
+	uint8_t reserved22a;		/* Byte offset 0x22a, CSR Addr 0x54115, Direction=N/A */
+	uint8_t reserved22b;		/* Byte offset 0x22b, CSR Addr 0x54115, Direction=N/A */
+	uint8_t reserved22c;		/* Byte offset 0x22c, CSR Addr 0x54116, Direction=N/A */
+	uint8_t reserved22d;		/* Byte offset 0x22d, CSR Addr 0x54116, Direction=N/A */
+	uint8_t reserved22e;		/* Byte offset 0x22e, CSR Addr 0x54117, Direction=N/A */
+	uint8_t reserved22f;		/* Byte offset 0x22f, CSR Addr 0x54117, Direction=N/A */
+	uint8_t reserved230;		/* Byte offset 0x230, CSR Addr 0x54118, Direction=N/A */
+	uint8_t reserved231;		/* Byte offset 0x231, CSR Addr 0x54118, Direction=N/A */
+	uint8_t reserved232;		/* Byte offset 0x232, CSR Addr 0x54119, Direction=N/A */
+	uint8_t reserved233;		/* Byte offset 0x233, CSR Addr 0x54119, Direction=N/A */
+	uint8_t reserved234;		/* Byte offset 0x234, CSR Addr 0x5411a, Direction=N/A */
+	uint8_t reserved235;		/* Byte offset 0x235, CSR Addr 0x5411a, Direction=N/A */
+	uint8_t reserved236;		/* Byte offset 0x236, CSR Addr 0x5411b, Direction=N/A */
+	uint8_t reserved237;		/* Byte offset 0x237, CSR Addr 0x5411b, Direction=N/A */
+	uint8_t reserved238;		/* Byte offset 0x238, CSR Addr 0x5411c, Direction=N/A */
+	uint8_t reserved239;		/* Byte offset 0x239, CSR Addr 0x5411c, Direction=N/A */
+	uint8_t reserved23a;		/* Byte offset 0x23a, CSR Addr 0x5411d, Direction=N/A */
+	uint8_t reserved23b;		/* Byte offset 0x23b, CSR Addr 0x5411d, Direction=N/A */
+	uint8_t reserved23c;		/* Byte offset 0x23c, CSR Addr 0x5411e, Direction=N/A */
+	uint8_t reserved23d;		/* Byte offset 0x23d, CSR Addr 0x5411e, Direction=N/A */
+	uint8_t reserved23e;		/* Byte offset 0x23e, CSR Addr 0x5411f, Direction=N/A */
+	uint8_t reserved23f;		/* Byte offset 0x23f, CSR Addr 0x5411f, Direction=N/A */
+	uint8_t reserved240;		/* Byte offset 0x240, CSR Addr 0x54120, Direction=N/A */
+	uint8_t reserved241;		/* Byte offset 0x241, CSR Addr 0x54120, Direction=N/A */
+	uint8_t reserved242;		/* Byte offset 0x242, CSR Addr 0x54121, Direction=N/A */
+	uint8_t reserved243;		/* Byte offset 0x243, CSR Addr 0x54121, Direction=N/A */
+	uint8_t reserved244;		/* Byte offset 0x244, CSR Addr 0x54122, Direction=N/A */
+	uint8_t reserved245;		/* Byte offset 0x245, CSR Addr 0x54122, Direction=N/A */
+	uint8_t reserved246;		/* Byte offset 0x246, CSR Addr 0x54123, Direction=N/A */
+	uint8_t reserved247;		/* Byte offset 0x247, CSR Addr 0x54123, Direction=N/A */
+	uint8_t reserved248;		/* Byte offset 0x248, CSR Addr 0x54124, Direction=N/A */
+	uint8_t reserved249;		/* Byte offset 0x249, CSR Addr 0x54124, Direction=N/A */
+	uint8_t reserved24a;		/* Byte offset 0x24a, CSR Addr 0x54125, Direction=N/A */
+	uint8_t reserved24b;		/* Byte offset 0x24b, CSR Addr 0x54125, Direction=N/A */
+	uint8_t reserved24c;		/* Byte offset 0x24c, CSR Addr 0x54126, Direction=N/A */
+	uint8_t reserved24d;		/* Byte offset 0x24d, CSR Addr 0x54126, Direction=N/A */
+	uint8_t reserved24e;		/* Byte offset 0x24e, CSR Addr 0x54127, Direction=N/A */
+	uint8_t reserved24f;		/* Byte offset 0x24f, CSR Addr 0x54127, Direction=N/A */
+	uint8_t reserved250;		/* Byte offset 0x250, CSR Addr 0x54128, Direction=N/A */
+	uint8_t reserved251;		/* Byte offset 0x251, CSR Addr 0x54128, Direction=N/A */
+	uint8_t reserved252;		/* Byte offset 0x252, CSR Addr 0x54129, Direction=N/A */
+	uint8_t reserved253;		/* Byte offset 0x253, CSR Addr 0x54129, Direction=N/A */
+	uint8_t reserved254;		/* Byte offset 0x254, CSR Addr 0x5412a, Direction=N/A */
+	uint8_t reserved255;		/* Byte offset 0x255, CSR Addr 0x5412a, Direction=N/A */
+	uint8_t reserved256;		/* Byte offset 0x256, CSR Addr 0x5412b, Direction=N/A */
+	uint8_t reserved257;		/* Byte offset 0x257, CSR Addr 0x5412b, Direction=N/A */
+	uint8_t reserved258;		/* Byte offset 0x258, CSR Addr 0x5412c, Direction=N/A */
+	uint8_t reserved259;		/* Byte offset 0x259, CSR Addr 0x5412c, Direction=N/A */
+	uint8_t reserved25a;		/* Byte offset 0x25a, CSR Addr 0x5412d, Direction=N/A */
+	uint8_t reserved25b;		/* Byte offset 0x25b, CSR Addr 0x5412d, Direction=N/A */
+	uint8_t reserved25c;		/* Byte offset 0x25c, CSR Addr 0x5412e, Direction=N/A */
+	uint8_t reserved25d;		/* Byte offset 0x25d, CSR Addr 0x5412e, Direction=N/A */
+	uint8_t reserved25e;		/* Byte offset 0x25e, CSR Addr 0x5412f, Direction=N/A */
+	uint8_t reserved25f;		/* Byte offset 0x25f, CSR Addr 0x5412f, Direction=N/A */
+	uint8_t reserved260;		/* Byte offset 0x260, CSR Addr 0x54130, Direction=N/A */
+	uint8_t reserved261;		/* Byte offset 0x261, CSR Addr 0x54130, Direction=N/A */
+	uint8_t reserved262;		/* Byte offset 0x262, CSR Addr 0x54131, Direction=N/A */
+	uint8_t reserved263;		/* Byte offset 0x263, CSR Addr 0x54131, Direction=N/A */
+	uint8_t reserved264;		/* Byte offset 0x264, CSR Addr 0x54132, Direction=N/A */
+	uint8_t reserved265;		/* Byte offset 0x265, CSR Addr 0x54132, Direction=N/A */
+	uint8_t reserved266;		/* Byte offset 0x266, CSR Addr 0x54133, Direction=N/A */
+	uint8_t reserved267;		/* Byte offset 0x267, CSR Addr 0x54133, Direction=N/A */
+	uint8_t reserved268;		/* Byte offset 0x268, CSR Addr 0x54134, Direction=N/A */
+	uint8_t reserved269;		/* Byte offset 0x269, CSR Addr 0x54134, Direction=N/A */
+	uint8_t reserved26a;		/* Byte offset 0x26a, CSR Addr 0x54135, Direction=N/A */
+	uint8_t reserved26b;		/* Byte offset 0x26b, CSR Addr 0x54135, Direction=N/A */
+	uint8_t reserved26c;		/* Byte offset 0x26c, CSR Addr 0x54136, Direction=N/A */
+	uint8_t reserved26d;		/* Byte offset 0x26d, CSR Addr 0x54136, Direction=N/A */
+	uint8_t reserved26e;		/* Byte offset 0x26e, CSR Addr 0x54137, Direction=N/A */
+	uint8_t reserved26f;		/* Byte offset 0x26f, CSR Addr 0x54137, Direction=N/A */
+	uint8_t reserved270;		/* Byte offset 0x270, CSR Addr 0x54138, Direction=N/A */
+	uint8_t reserved271;		/* Byte offset 0x271, CSR Addr 0x54138, Direction=N/A */
+	uint8_t reserved272;		/* Byte offset 0x272, CSR Addr 0x54139, Direction=N/A */
+	uint8_t reserved273;		/* Byte offset 0x273, CSR Addr 0x54139, Direction=N/A */
+	uint8_t reserved274;		/* Byte offset 0x274, CSR Addr 0x5413a, Direction=N/A */
+	uint8_t reserved275;		/* Byte offset 0x275, CSR Addr 0x5413a, Direction=N/A */
+	uint8_t reserved276;		/* Byte offset 0x276, CSR Addr 0x5413b, Direction=N/A */
+	uint8_t reserved277;		/* Byte offset 0x277, CSR Addr 0x5413b, Direction=N/A */
+	uint8_t reserved278;		/* Byte offset 0x278, CSR Addr 0x5413c, Direction=N/A */
+	uint8_t reserved279;		/* Byte offset 0x279, CSR Addr 0x5413c, Direction=N/A */
+	uint8_t reserved27a;		/* Byte offset 0x27a, CSR Addr 0x5413d, Direction=N/A */
+	uint8_t reserved27b;		/* Byte offset 0x27b, CSR Addr 0x5413d, Direction=N/A */
+	uint8_t reserved27c;		/* Byte offset 0x27c, CSR Addr 0x5413e, Direction=N/A */
+	uint8_t reserved27d;		/* Byte offset 0x27d, CSR Addr 0x5413e, Direction=N/A */
+	uint8_t reserved27e;		/* Byte offset 0x27e, CSR Addr 0x5413f, Direction=N/A */
+	uint8_t reserved27f;		/* Byte offset 0x27f, CSR Addr 0x5413f, Direction=N/A */
+	uint8_t reserved280;		/* Byte offset 0x280, CSR Addr 0x54140, Direction=N/A */
+	uint8_t reserved281;		/* Byte offset 0x281, CSR Addr 0x54140, Direction=N/A */
+	uint8_t reserved282;		/* Byte offset 0x282, CSR Addr 0x54141, Direction=N/A */
+	uint8_t reserved283;		/* Byte offset 0x283, CSR Addr 0x54141, Direction=N/A */
+	uint8_t reserved284;		/* Byte offset 0x284, CSR Addr 0x54142, Direction=N/A */
+	uint8_t reserved285;		/* Byte offset 0x285, CSR Addr 0x54142, Direction=N/A */
+	uint8_t reserved286;		/* Byte offset 0x286, CSR Addr 0x54143, Direction=N/A */
+	uint8_t reserved287;		/* Byte offset 0x287, CSR Addr 0x54143, Direction=N/A */
+	uint8_t reserved288;		/* Byte offset 0x288, CSR Addr 0x54144, Direction=N/A */
+	uint8_t reserved289;		/* Byte offset 0x289, CSR Addr 0x54144, Direction=N/A */
+	uint8_t reserved28a;		/* Byte offset 0x28a, CSR Addr 0x54145, Direction=N/A */
+	uint8_t reserved28b;		/* Byte offset 0x28b, CSR Addr 0x54145, Direction=N/A */
+	uint8_t reserved28c;		/* Byte offset 0x28c, CSR Addr 0x54146, Direction=N/A */
+	uint8_t reserved28d;		/* Byte offset 0x28d, CSR Addr 0x54146, Direction=N/A */
+	uint8_t reserved28e;		/* Byte offset 0x28e, CSR Addr 0x54147, Direction=N/A */
+	uint8_t reserved28f;		/* Byte offset 0x28f, CSR Addr 0x54147, Direction=N/A */
+	uint8_t reserved290;		/* Byte offset 0x290, CSR Addr 0x54148, Direction=N/A */
+	uint8_t reserved291;		/* Byte offset 0x291, CSR Addr 0x54148, Direction=N/A */
+	uint8_t reserved292;		/* Byte offset 0x292, CSR Addr 0x54149, Direction=N/A */
+	uint8_t reserved293;		/* Byte offset 0x293, CSR Addr 0x54149, Direction=N/A */
+	uint8_t reserved294;		/* Byte offset 0x294, CSR Addr 0x5414a, Direction=N/A */
+	uint8_t reserved295;		/* Byte offset 0x295, CSR Addr 0x5414a, Direction=N/A */
+	uint8_t reserved296;		/* Byte offset 0x296, CSR Addr 0x5414b, Direction=N/A */
+	uint8_t reserved297;		/* Byte offset 0x297, CSR Addr 0x5414b, Direction=N/A */
+	uint8_t reserved298;		/* Byte offset 0x298, CSR Addr 0x5414c, Direction=N/A */
+	uint8_t reserved299;		/* Byte offset 0x299, CSR Addr 0x5414c, Direction=N/A */
+	uint8_t reserved29a;		/* Byte offset 0x29a, CSR Addr 0x5414d, Direction=N/A */
+	uint8_t reserved29b;		/* Byte offset 0x29b, CSR Addr 0x5414d, Direction=N/A */
+	uint8_t reserved29c;		/* Byte offset 0x29c, CSR Addr 0x5414e, Direction=N/A */
+	uint8_t reserved29d;		/* Byte offset 0x29d, CSR Addr 0x5414e, Direction=N/A */
+	uint8_t reserved29e;		/* Byte offset 0x29e, CSR Addr 0x5414f, Direction=N/A */
+	uint8_t reserved29f;		/* Byte offset 0x29f, CSR Addr 0x5414f, Direction=N/A */
+	uint8_t reserved2a0;		/* Byte offset 0x2a0, CSR Addr 0x54150, Direction=N/A */
+	uint8_t reserved2a1;		/* Byte offset 0x2a1, CSR Addr 0x54150, Direction=N/A */
+	uint8_t reserved2a2;		/* Byte offset 0x2a2, CSR Addr 0x54151, Direction=N/A */
+	uint8_t reserved2a3;		/* Byte offset 0x2a3, CSR Addr 0x54151, Direction=N/A */
+	uint8_t reserved2a4;		/* Byte offset 0x2a4, CSR Addr 0x54152, Direction=N/A */
+	uint8_t reserved2a5;		/* Byte offset 0x2a5, CSR Addr 0x54152, Direction=N/A */
+	uint8_t reserved2a6;		/* Byte offset 0x2a6, CSR Addr 0x54153, Direction=N/A */
+	uint8_t reserved2a7;		/* Byte offset 0x2a7, CSR Addr 0x54153, Direction=N/A */
+	uint8_t reserved2a8;		/* Byte offset 0x2a8, CSR Addr 0x54154, Direction=N/A */
+	uint8_t reserved2a9;		/* Byte offset 0x2a9, CSR Addr 0x54154, Direction=N/A */
+	uint8_t reserved2aa;		/* Byte offset 0x2aa, CSR Addr 0x54155, Direction=N/A */
+	uint8_t reserved2ab;		/* Byte offset 0x2ab, CSR Addr 0x54155, Direction=N/A */
+	uint8_t reserved2ac;		/* Byte offset 0x2ac, CSR Addr 0x54156, Direction=N/A */
+	uint8_t reserved2ad;		/* Byte offset 0x2ad, CSR Addr 0x54156, Direction=N/A */
+	uint8_t reserved2ae;		/* Byte offset 0x2ae, CSR Addr 0x54157, Direction=N/A */
+	uint8_t reserved2af;		/* Byte offset 0x2af, CSR Addr 0x54157, Direction=N/A */
+	uint8_t reserved2b0;		/* Byte offset 0x2b0, CSR Addr 0x54158, Direction=N/A */
+	uint8_t reserved2b1;		/* Byte offset 0x2b1, CSR Addr 0x54158, Direction=N/A */
+	uint8_t reserved2b2;		/* Byte offset 0x2b2, CSR Addr 0x54159, Direction=N/A */
+	uint8_t reserved2b3;		/* Byte offset 0x2b3, CSR Addr 0x54159, Direction=N/A */
+	uint8_t reserved2b4;		/* Byte offset 0x2b4, CSR Addr 0x5415a, Direction=N/A */
+	uint8_t reserved2b5;		/* Byte offset 0x2b5, CSR Addr 0x5415a, Direction=N/A */
+	uint8_t reserved2b6;		/* Byte offset 0x2b6, CSR Addr 0x5415b, Direction=N/A */
+	uint8_t reserved2b7;		/* Byte offset 0x2b7, CSR Addr 0x5415b, Direction=N/A */
+	uint8_t reserved2b8;		/* Byte offset 0x2b8, CSR Addr 0x5415c, Direction=N/A */
+	uint8_t reserved2b9;		/* Byte offset 0x2b9, CSR Addr 0x5415c, Direction=N/A */
+	uint8_t reserved2ba;		/* Byte offset 0x2ba, CSR Addr 0x5415d, Direction=N/A */
+	uint8_t reserved2bb;		/* Byte offset 0x2bb, CSR Addr 0x5415d, Direction=N/A */
+	uint8_t reserved2bc;		/* Byte offset 0x2bc, CSR Addr 0x5415e, Direction=N/A */
+	uint8_t reserved2bd;		/* Byte offset 0x2bd, CSR Addr 0x5415e, Direction=N/A */
+	uint8_t reserved2be;		/* Byte offset 0x2be, CSR Addr 0x5415f, Direction=N/A */
+	uint8_t reserved2bf;		/* Byte offset 0x2bf, CSR Addr 0x5415f, Direction=N/A */
+	uint8_t reserved2c0;		/* Byte offset 0x2c0, CSR Addr 0x54160, Direction=N/A */
+	uint8_t reserved2c1;		/* Byte offset 0x2c1, CSR Addr 0x54160, Direction=N/A */
+	uint8_t reserved2c2;		/* Byte offset 0x2c2, CSR Addr 0x54161, Direction=N/A */
+	uint8_t reserved2c3;		/* Byte offset 0x2c3, CSR Addr 0x54161, Direction=N/A */
+	uint8_t reserved2c4;		/* Byte offset 0x2c4, CSR Addr 0x54162, Direction=N/A */
+	uint8_t reserved2c5;		/* Byte offset 0x2c5, CSR Addr 0x54162, Direction=N/A */
+	uint8_t reserved2c6;		/* Byte offset 0x2c6, CSR Addr 0x54163, Direction=N/A */
+	uint8_t reserved2c7;		/* Byte offset 0x2c7, CSR Addr 0x54163, Direction=N/A */
+	uint8_t reserved2c8;		/* Byte offset 0x2c8, CSR Addr 0x54164, Direction=N/A */
+	uint8_t reserved2c9;		/* Byte offset 0x2c9, CSR Addr 0x54164, Direction=N/A */
+	uint8_t reserved2ca;		/* Byte offset 0x2ca, CSR Addr 0x54165, Direction=N/A */
+	uint8_t reserved2cb;		/* Byte offset 0x2cb, CSR Addr 0x54165, Direction=N/A */
+	uint8_t reserved2cc;		/* Byte offset 0x2cc, CSR Addr 0x54166, Direction=N/A */
+	uint8_t reserved2cd;		/* Byte offset 0x2cd, CSR Addr 0x54166, Direction=N/A */
+	uint8_t reserved2ce;		/* Byte offset 0x2ce, CSR Addr 0x54167, Direction=N/A */
+	uint8_t reserved2cf;		/* Byte offset 0x2cf, CSR Addr 0x54167, Direction=N/A */
+	uint8_t reserved2d0;		/* Byte offset 0x2d0, CSR Addr 0x54168, Direction=N/A */
+	uint8_t reserved2d1;		/* Byte offset 0x2d1, CSR Addr 0x54168, Direction=N/A */
+	uint8_t reserved2d2;		/* Byte offset 0x2d2, CSR Addr 0x54169, Direction=N/A */
+	uint8_t reserved2d3;		/* Byte offset 0x2d3, CSR Addr 0x54169, Direction=N/A */
+	uint8_t reserved2d4;		/* Byte offset 0x2d4, CSR Addr 0x5416a, Direction=N/A */
+	uint8_t reserved2d5;		/* Byte offset 0x2d5, CSR Addr 0x5416a, Direction=N/A */
+	uint8_t reserved2d6;		/* Byte offset 0x2d6, CSR Addr 0x5416b, Direction=N/A */
+	uint8_t reserved2d7;		/* Byte offset 0x2d7, CSR Addr 0x5416b, Direction=N/A */
+	uint8_t reserved2d8;		/* Byte offset 0x2d8, CSR Addr 0x5416c, Direction=N/A */
+	uint8_t reserved2d9;		/* Byte offset 0x2d9, CSR Addr 0x5416c, Direction=N/A */
+	uint8_t reserved2da;		/* Byte offset 0x2da, CSR Addr 0x5416d, Direction=N/A */
+	uint8_t reserved2db;		/* Byte offset 0x2db, CSR Addr 0x5416d, Direction=N/A */
+	uint8_t reserved2dc;		/* Byte offset 0x2dc, CSR Addr 0x5416e, Direction=N/A */
+	uint8_t reserved2dd;		/* Byte offset 0x2dd, CSR Addr 0x5416e, Direction=N/A */
+	uint8_t reserved2de;		/* Byte offset 0x2de, CSR Addr 0x5416f, Direction=N/A */
+	uint8_t reserved2df;		/* Byte offset 0x2df, CSR Addr 0x5416f, Direction=N/A */
+	uint8_t reserved2e0;		/* Byte offset 0x2e0, CSR Addr 0x54170, Direction=N/A */
+	uint8_t reserved2e1;		/* Byte offset 0x2e1, CSR Addr 0x54170, Direction=N/A */
+	uint8_t reserved2e2;		/* Byte offset 0x2e2, CSR Addr 0x54171, Direction=N/A */
+	uint8_t reserved2e3;		/* Byte offset 0x2e3, CSR Addr 0x54171, Direction=N/A */
+	uint8_t reserved2e4;		/* Byte offset 0x2e4, CSR Addr 0x54172, Direction=N/A */
+	uint8_t reserved2e5;		/* Byte offset 0x2e5, CSR Addr 0x54172, Direction=N/A */
+	uint8_t reserved2e6;		/* Byte offset 0x2e6, CSR Addr 0x54173, Direction=N/A */
+	uint8_t reserved2e7;		/* Byte offset 0x2e7, CSR Addr 0x54173, Direction=N/A */
+	uint8_t reserved2e8;		/* Byte offset 0x2e8, CSR Addr 0x54174, Direction=N/A */
+	uint8_t reserved2e9;		/* Byte offset 0x2e9, CSR Addr 0x54174, Direction=N/A */
+	uint8_t reserved2ea;		/* Byte offset 0x2ea, CSR Addr 0x54175, Direction=N/A */
+	uint8_t reserved2eb;		/* Byte offset 0x2eb, CSR Addr 0x54175, Direction=N/A */
+	uint8_t reserved2ec;		/* Byte offset 0x2ec, CSR Addr 0x54176, Direction=N/A */
+	uint8_t reserved2ed;		/* Byte offset 0x2ed, CSR Addr 0x54176, Direction=N/A */
+	uint8_t reserved2ee;		/* Byte offset 0x2ee, CSR Addr 0x54177, Direction=N/A */
+	uint8_t reserved2ef;		/* Byte offset 0x2ef, CSR Addr 0x54177, Direction=N/A */
+	uint8_t reserved2f0;		/* Byte offset 0x2f0, CSR Addr 0x54178, Direction=N/A */
+	uint8_t reserved2f1;		/* Byte offset 0x2f1, CSR Addr 0x54178, Direction=N/A */
+	uint8_t reserved2f2;		/* Byte offset 0x2f2, CSR Addr 0x54179, Direction=N/A */
+	uint8_t reserved2f3;		/* Byte offset 0x2f3, CSR Addr 0x54179, Direction=N/A */
+	uint8_t reserved2f4;		/* Byte offset 0x2f4, CSR Addr 0x5417a, Direction=N/A */
+	uint8_t reserved2f5;		/* Byte offset 0x2f5, CSR Addr 0x5417a, Direction=N/A */
+	uint8_t reserved2f6;		/* Byte offset 0x2f6, CSR Addr 0x5417b, Direction=N/A */
+	uint8_t reserved2f7;		/* Byte offset 0x2f7, CSR Addr 0x5417b, Direction=N/A */
+	uint8_t reserved2f8;		/* Byte offset 0x2f8, CSR Addr 0x5417c, Direction=N/A */
+	uint8_t reserved2f9;		/* Byte offset 0x2f9, CSR Addr 0x5417c, Direction=N/A */
+	uint8_t reserved2fa;		/* Byte offset 0x2fa, CSR Addr 0x5417d, Direction=N/A */
+	uint8_t reserved2fb;		/* Byte offset 0x2fb, CSR Addr 0x5417d, Direction=N/A */
+	uint8_t reserved2fc;		/* Byte offset 0x2fc, CSR Addr 0x5417e, Direction=N/A */
+	uint8_t reserved2fd;		/* Byte offset 0x2fd, CSR Addr 0x5417e, Direction=N/A */
+	uint8_t reserved2fe;		/* Byte offset 0x2fe, CSR Addr 0x5417f, Direction=N/A */
+	uint8_t reserved2ff;		/* Byte offset 0x2ff, CSR Addr 0x5417f, Direction=N/A */
+	uint8_t reserved300;		/* Byte offset 0x300, CSR Addr 0x54180, Direction=N/A */
+	uint8_t reserved301;		/* Byte offset 0x301, CSR Addr 0x54180, Direction=N/A */
+	uint8_t reserved302;		/* Byte offset 0x302, CSR Addr 0x54181, Direction=N/A */
+	uint8_t reserved303;		/* Byte offset 0x303, CSR Addr 0x54181, Direction=N/A */
+	uint8_t reserved304;		/* Byte offset 0x304, CSR Addr 0x54182, Direction=N/A */
+	uint8_t reserved305;		/* Byte offset 0x305, CSR Addr 0x54182, Direction=N/A */
+	uint8_t reserved306;		/* Byte offset 0x306, CSR Addr 0x54183, Direction=N/A */
+	uint8_t reserved307;		/* Byte offset 0x307, CSR Addr 0x54183, Direction=N/A */
+	uint8_t reserved308;		/* Byte offset 0x308, CSR Addr 0x54184, Direction=N/A */
+	uint8_t reserved309;		/* Byte offset 0x309, CSR Addr 0x54184, Direction=N/A */
+	uint8_t reserved30a;		/* Byte offset 0x30a, CSR Addr 0x54185, Direction=N/A */
+	uint8_t reserved30b;		/* Byte offset 0x30b, CSR Addr 0x54185, Direction=N/A */
+	uint8_t reserved30c;		/* Byte offset 0x30c, CSR Addr 0x54186, Direction=N/A */
+	uint8_t reserved30d;		/* Byte offset 0x30d, CSR Addr 0x54186, Direction=N/A */
+	uint8_t reserved30e;		/* Byte offset 0x30e, CSR Addr 0x54187, Direction=N/A */
+	uint8_t reserved30f;		/* Byte offset 0x30f, CSR Addr 0x54187, Direction=N/A */
+	uint8_t reserved310;		/* Byte offset 0x310, CSR Addr 0x54188, Direction=N/A */
+	uint8_t reserved311;		/* Byte offset 0x311, CSR Addr 0x54188, Direction=N/A */
+	uint8_t reserved312;		/* Byte offset 0x312, CSR Addr 0x54189, Direction=N/A */
+	uint8_t reserved313;		/* Byte offset 0x313, CSR Addr 0x54189, Direction=N/A */
+	uint8_t reserved314;		/* Byte offset 0x314, CSR Addr 0x5418a, Direction=N/A */
+	uint8_t reserved315;		/* Byte offset 0x315, CSR Addr 0x5418a, Direction=N/A */
+	uint8_t reserved316;		/* Byte offset 0x316, CSR Addr 0x5418b, Direction=N/A */
+	uint8_t reserved317;		/* Byte offset 0x317, CSR Addr 0x5418b, Direction=N/A */
+	uint8_t reserved318;		/* Byte offset 0x318, CSR Addr 0x5418c, Direction=N/A */
+	uint8_t reserved319;		/* Byte offset 0x319, CSR Addr 0x5418c, Direction=N/A */
+	uint8_t reserved31a;		/* Byte offset 0x31a, CSR Addr 0x5418d, Direction=N/A */
+	uint8_t reserved31b;		/* Byte offset 0x31b, CSR Addr 0x5418d, Direction=N/A */
+	uint8_t reserved31c;		/* Byte offset 0x31c, CSR Addr 0x5418e, Direction=N/A */
+	uint8_t reserved31d;		/* Byte offset 0x31d, CSR Addr 0x5418e, Direction=N/A */
+	uint8_t reserved31e;		/* Byte offset 0x31e, CSR Addr 0x5418f, Direction=N/A */
+	uint8_t reserved31f;		/* Byte offset 0x31f, CSR Addr 0x5418f, Direction=N/A */
+	uint8_t reserved320;		/* Byte offset 0x320, CSR Addr 0x54190, Direction=N/A */
+	uint8_t reserved321;		/* Byte offset 0x321, CSR Addr 0x54190, Direction=N/A */
+	uint8_t reserved322;		/* Byte offset 0x322, CSR Addr 0x54191, Direction=N/A */
+	uint8_t reserved323;		/* Byte offset 0x323, CSR Addr 0x54191, Direction=N/A */
+	uint8_t reserved324;		/* Byte offset 0x324, CSR Addr 0x54192, Direction=N/A */
+	uint8_t reserved325;		/* Byte offset 0x325, CSR Addr 0x54192, Direction=N/A */
+	uint8_t reserved326;		/* Byte offset 0x326, CSR Addr 0x54193, Direction=N/A */
+	uint8_t reserved327;		/* Byte offset 0x327, CSR Addr 0x54193, Direction=N/A */
+	uint8_t reserved328;		/* Byte offset 0x328, CSR Addr 0x54194, Direction=N/A */
+	uint8_t reserved329;		/* Byte offset 0x329, CSR Addr 0x54194, Direction=N/A */
+	uint8_t reserved32a;		/* Byte offset 0x32a, CSR Addr 0x54195, Direction=N/A */
+	uint8_t reserved32b;		/* Byte offset 0x32b, CSR Addr 0x54195, Direction=N/A */
+	uint8_t reserved32c;		/* Byte offset 0x32c, CSR Addr 0x54196, Direction=N/A */
+	uint8_t reserved32d;		/* Byte offset 0x32d, CSR Addr 0x54196, Direction=N/A */
+	uint8_t reserved32e;		/* Byte offset 0x32e, CSR Addr 0x54197, Direction=N/A */
+	uint8_t reserved32f;		/* Byte offset 0x32f, CSR Addr 0x54197, Direction=N/A */
+	uint8_t reserved330;		/* Byte offset 0x330, CSR Addr 0x54198, Direction=N/A */
+	uint8_t reserved331;		/* Byte offset 0x331, CSR Addr 0x54198, Direction=N/A */
+	uint8_t reserved332;		/* Byte offset 0x332, CSR Addr 0x54199, Direction=N/A */
+	uint8_t reserved333;		/* Byte offset 0x333, CSR Addr 0x54199, Direction=N/A */
+	uint8_t reserved334;		/* Byte offset 0x334, CSR Addr 0x5419a, Direction=N/A */
+	uint8_t reserved335;		/* Byte offset 0x335, CSR Addr 0x5419a, Direction=N/A */
+	uint8_t reserved336;		/* Byte offset 0x336, CSR Addr 0x5419b, Direction=N/A */
+	uint8_t reserved337;		/* Byte offset 0x337, CSR Addr 0x5419b, Direction=N/A */
+	uint8_t reserved338;		/* Byte offset 0x338, CSR Addr 0x5419c, Direction=N/A */
+	uint8_t reserved339;		/* Byte offset 0x339, CSR Addr 0x5419c, Direction=N/A */
+	uint8_t reserved33a;		/* Byte offset 0x33a, CSR Addr 0x5419d, Direction=N/A */
+	uint8_t reserved33b;		/* Byte offset 0x33b, CSR Addr 0x5419d, Direction=N/A */
+	uint8_t reserved33c;		/* Byte offset 0x33c, CSR Addr 0x5419e, Direction=N/A */
+	uint8_t reserved33d;		/* Byte offset 0x33d, CSR Addr 0x5419e, Direction=N/A */
+	uint8_t reserved33e;		/* Byte offset 0x33e, CSR Addr 0x5419f, Direction=N/A */
+	uint8_t reserved33f;		/* Byte offset 0x33f, CSR Addr 0x5419f, Direction=N/A */
+	uint8_t reserved340;		/* Byte offset 0x340, CSR Addr 0x541a0, Direction=N/A */
+	uint8_t reserved341;		/* Byte offset 0x341, CSR Addr 0x541a0, Direction=N/A */
+	uint8_t reserved342;		/* Byte offset 0x342, CSR Addr 0x541a1, Direction=N/A */
+	uint8_t reserved343;		/* Byte offset 0x343, CSR Addr 0x541a1, Direction=N/A */
+	uint8_t reserved344;		/* Byte offset 0x344, CSR Addr 0x541a2, Direction=N/A */
+	uint8_t reserved345;		/* Byte offset 0x345, CSR Addr 0x541a2, Direction=N/A */
+	uint8_t reserved346;		/* Byte offset 0x346, CSR Addr 0x541a3, Direction=N/A */
+	uint8_t reserved347;		/* Byte offset 0x347, CSR Addr 0x541a3, Direction=N/A */
+	uint8_t reserved348;		/* Byte offset 0x348, CSR Addr 0x541a4, Direction=N/A */
+	uint8_t reserved349;		/* Byte offset 0x349, CSR Addr 0x541a4, Direction=N/A */
+	uint8_t reserved34a;		/* Byte offset 0x34a, CSR Addr 0x541a5, Direction=N/A */
+	uint8_t reserved34b;		/* Byte offset 0x34b, CSR Addr 0x541a5, Direction=N/A */
+	uint8_t reserved34c;		/* Byte offset 0x34c, CSR Addr 0x541a6, Direction=N/A */
+	uint8_t reserved34d;		/* Byte offset 0x34d, CSR Addr 0x541a6, Direction=N/A */
+	uint8_t reserved34e;		/* Byte offset 0x34e, CSR Addr 0x541a7, Direction=N/A */
+	uint8_t reserved34f;		/* Byte offset 0x34f, CSR Addr 0x541a7, Direction=N/A */
+	uint8_t reserved350;		/* Byte offset 0x350, CSR Addr 0x541a8, Direction=N/A */
+	uint8_t reserved351;		/* Byte offset 0x351, CSR Addr 0x541a8, Direction=N/A */
+	uint8_t reserved352;		/* Byte offset 0x352, CSR Addr 0x541a9, Direction=N/A */
+	uint8_t reserved353;		/* Byte offset 0x353, CSR Addr 0x541a9, Direction=N/A */
+	uint8_t reserved354;		/* Byte offset 0x354, CSR Addr 0x541aa, Direction=N/A */
+	uint8_t reserved355;		/* Byte offset 0x355, CSR Addr 0x541aa, Direction=N/A */
+	uint8_t reserved356;		/* Byte offset 0x356, CSR Addr 0x541ab, Direction=N/A */
+	uint8_t reserved357;		/* Byte offset 0x357, CSR Addr 0x541ab, Direction=N/A */
+	uint8_t reserved358;		/* Byte offset 0x358, CSR Addr 0x541ac, Direction=N/A */
+	uint8_t reserved359;		/* Byte offset 0x359, CSR Addr 0x541ac, Direction=N/A */
+	uint8_t reserved35a;		/* Byte offset 0x35a, CSR Addr 0x541ad, Direction=N/A */
+	uint8_t reserved35b;		/* Byte offset 0x35b, CSR Addr 0x541ad, Direction=N/A */
+	uint8_t reserved35c;		/* Byte offset 0x35c, CSR Addr 0x541ae, Direction=N/A */
+	uint8_t reserved35d;		/* Byte offset 0x35d, CSR Addr 0x541ae, Direction=N/A */
+	uint8_t reserved35e;		/* Byte offset 0x35e, CSR Addr 0x541af, Direction=N/A */
+	uint8_t reserved35f;		/* Byte offset 0x35f, CSR Addr 0x541af, Direction=N/A */
+	uint8_t reserved360;		/* Byte offset 0x360, CSR Addr 0x541b0, Direction=N/A */
+	uint8_t reserved361;		/* Byte offset 0x361, CSR Addr 0x541b0, Direction=N/A */
+	uint8_t reserved362;		/* Byte offset 0x362, CSR Addr 0x541b1, Direction=N/A */
+	uint8_t reserved363;		/* Byte offset 0x363, CSR Addr 0x541b1, Direction=N/A */
+	uint8_t reserved364;		/* Byte offset 0x364, CSR Addr 0x541b2, Direction=N/A */
+	uint8_t reserved365;		/* Byte offset 0x365, CSR Addr 0x541b2, Direction=N/A */
+	uint8_t reserved366;		/* Byte offset 0x366, CSR Addr 0x541b3, Direction=N/A */
+	uint8_t reserved367;		/* Byte offset 0x367, CSR Addr 0x541b3, Direction=N/A */
+	uint8_t reserved368;		/* Byte offset 0x368, CSR Addr 0x541b4, Direction=N/A */
+	uint8_t reserved369;		/* Byte offset 0x369, CSR Addr 0x541b4, Direction=N/A */
+	uint8_t reserved36a;		/* Byte offset 0x36a, CSR Addr 0x541b5, Direction=N/A */
+	uint8_t reserved36b;		/* Byte offset 0x36b, CSR Addr 0x541b5, Direction=N/A */
+	uint8_t reserved36c;		/* Byte offset 0x36c, CSR Addr 0x541b6, Direction=N/A */
+	uint8_t reserved36d;		/* Byte offset 0x36d, CSR Addr 0x541b6, Direction=N/A */
+	uint8_t reserved36e;		/* Byte offset 0x36e, CSR Addr 0x541b7, Direction=N/A */
+	uint8_t reserved36f;		/* Byte offset 0x36f, CSR Addr 0x541b7, Direction=N/A */
+	uint8_t reserved370;		/* Byte offset 0x370, CSR Addr 0x541b8, Direction=N/A */
+	uint8_t reserved371;		/* Byte offset 0x371, CSR Addr 0x541b8, Direction=N/A */
+	uint8_t reserved372;		/* Byte offset 0x372, CSR Addr 0x541b9, Direction=N/A */
+	uint8_t reserved373;		/* Byte offset 0x373, CSR Addr 0x541b9, Direction=N/A */
+	uint8_t reserved374;		/* Byte offset 0x374, CSR Addr 0x541ba, Direction=N/A */
+	uint8_t reserved375;		/* Byte offset 0x375, CSR Addr 0x541ba, Direction=N/A */
+	uint8_t reserved376;		/* Byte offset 0x376, CSR Addr 0x541bb, Direction=N/A */
+	uint8_t reserved377;		/* Byte offset 0x377, CSR Addr 0x541bb, Direction=N/A */
+	uint8_t reserved378;		/* Byte offset 0x378, CSR Addr 0x541bc, Direction=N/A */
+	uint8_t reserved379;		/* Byte offset 0x379, CSR Addr 0x541bc, Direction=N/A */
+	uint8_t reserved37a;		/* Byte offset 0x37a, CSR Addr 0x541bd, Direction=N/A */
+	uint8_t reserved37b;		/* Byte offset 0x37b, CSR Addr 0x541bd, Direction=N/A */
+	uint8_t reserved37c;		/* Byte offset 0x37c, CSR Addr 0x541be, Direction=N/A */
+	uint8_t reserved37d;		/* Byte offset 0x37d, CSR Addr 0x541be, Direction=N/A */
+	uint8_t reserved37e;		/* Byte offset 0x37e, CSR Addr 0x541bf, Direction=N/A */
+	uint8_t reserved37f;		/* Byte offset 0x37f, CSR Addr 0x541bf, Direction=N/A */
+	uint8_t reserved380;		/* Byte offset 0x380, CSR Addr 0x541c0, Direction=N/A */
+	uint8_t reserved381;		/* Byte offset 0x381, CSR Addr 0x541c0, Direction=N/A */
+	uint8_t reserved382;		/* Byte offset 0x382, CSR Addr 0x541c1, Direction=N/A */
+	uint8_t reserved383;		/* Byte offset 0x383, CSR Addr 0x541c1, Direction=N/A */
+	uint8_t reserved384;		/* Byte offset 0x384, CSR Addr 0x541c2, Direction=N/A */
+	uint8_t reserved385;		/* Byte offset 0x385, CSR Addr 0x541c2, Direction=N/A */
+	uint8_t reserved386;		/* Byte offset 0x386, CSR Addr 0x541c3, Direction=N/A */
+	uint8_t reserved387;		/* Byte offset 0x387, CSR Addr 0x541c3, Direction=N/A */
+	uint8_t reserved388;		/* Byte offset 0x388, CSR Addr 0x541c4, Direction=N/A */
+	uint8_t reserved389;		/* Byte offset 0x389, CSR Addr 0x541c4, Direction=N/A */
+	uint8_t reserved38a;		/* Byte offset 0x38a, CSR Addr 0x541c5, Direction=N/A */
+	uint8_t reserved38b;		/* Byte offset 0x38b, CSR Addr 0x541c5, Direction=N/A */
+	uint8_t reserved38c;		/* Byte offset 0x38c, CSR Addr 0x541c6, Direction=N/A */
+	uint8_t reserved38d;		/* Byte offset 0x38d, CSR Addr 0x541c6, Direction=N/A */
+	uint8_t reserved38e;		/* Byte offset 0x38e, CSR Addr 0x541c7, Direction=N/A */
+	uint8_t reserved38f;		/* Byte offset 0x38f, CSR Addr 0x541c7, Direction=N/A */
+	uint8_t reserved390;		/* Byte offset 0x390, CSR Addr 0x541c8, Direction=N/A */
+	uint8_t reserved391;		/* Byte offset 0x391, CSR Addr 0x541c8, Direction=N/A */
+	uint8_t reserved392;		/* Byte offset 0x392, CSR Addr 0x541c9, Direction=N/A */
+	uint8_t reserved393;		/* Byte offset 0x393, CSR Addr 0x541c9, Direction=N/A */
+	uint8_t reserved394;		/* Byte offset 0x394, CSR Addr 0x541ca, Direction=N/A */
+	uint8_t reserved395;		/* Byte offset 0x395, CSR Addr 0x541ca, Direction=N/A */
+	uint8_t reserved396;		/* Byte offset 0x396, CSR Addr 0x541cb, Direction=N/A */
+	uint8_t reserved397;		/* Byte offset 0x397, CSR Addr 0x541cb, Direction=N/A */
+	uint8_t reserved398;		/* Byte offset 0x398, CSR Addr 0x541cc, Direction=N/A */
+	uint8_t reserved399;		/* Byte offset 0x399, CSR Addr 0x541cc, Direction=N/A */
+	uint8_t reserved39a;		/* Byte offset 0x39a, CSR Addr 0x541cd, Direction=N/A */
+	uint8_t reserved39b;		/* Byte offset 0x39b, CSR Addr 0x541cd, Direction=N/A */
+	uint8_t reserved39c;		/* Byte offset 0x39c, CSR Addr 0x541ce, Direction=N/A */
+	uint8_t reserved39d;		/* Byte offset 0x39d, CSR Addr 0x541ce, Direction=N/A */
+	uint8_t reserved39e;		/* Byte offset 0x39e, CSR Addr 0x541cf, Direction=N/A */
+	uint8_t reserved39f;		/* Byte offset 0x39f, CSR Addr 0x541cf, Direction=N/A */
+	uint8_t reserved3a0;		/* Byte offset 0x3a0, CSR Addr 0x541d0, Direction=N/A */
+	uint8_t reserved3a1;		/* Byte offset 0x3a1, CSR Addr 0x541d0, Direction=N/A */
+	uint8_t reserved3a2;		/* Byte offset 0x3a2, CSR Addr 0x541d1, Direction=N/A */
+	uint8_t reserved3a3;		/* Byte offset 0x3a3, CSR Addr 0x541d1, Direction=N/A */
+	uint8_t reserved3a4;		/* Byte offset 0x3a4, CSR Addr 0x541d2, Direction=N/A */
+	uint8_t reserved3a5;		/* Byte offset 0x3a5, CSR Addr 0x541d2, Direction=N/A */
+	uint8_t reserved3a6;		/* Byte offset 0x3a6, CSR Addr 0x541d3, Direction=N/A */
+	uint8_t reserved3a7;		/* Byte offset 0x3a7, CSR Addr 0x541d3, Direction=N/A */
+	uint8_t reserved3a8;		/* Byte offset 0x3a8, CSR Addr 0x541d4, Direction=N/A */
+	uint8_t reserved3a9;		/* Byte offset 0x3a9, CSR Addr 0x541d4, Direction=N/A */
+	uint8_t reserved3aa;		/* Byte offset 0x3aa, CSR Addr 0x541d5, Direction=N/A */
+	uint8_t reserved3ab;		/* Byte offset 0x3ab, CSR Addr 0x541d5, Direction=N/A */
+	uint8_t reserved3ac;		/* Byte offset 0x3ac, CSR Addr 0x541d6, Direction=N/A */
+	uint8_t reserved3ad;		/* Byte offset 0x3ad, CSR Addr 0x541d6, Direction=N/A */
+	uint8_t reserved3ae;		/* Byte offset 0x3ae, CSR Addr 0x541d7, Direction=N/A */
+	uint8_t reserved3af;		/* Byte offset 0x3af, CSR Addr 0x541d7, Direction=N/A */
+	uint8_t reserved3b0;		/* Byte offset 0x3b0, CSR Addr 0x541d8, Direction=N/A */
+	uint8_t reserved3b1;		/* Byte offset 0x3b1, CSR Addr 0x541d8, Direction=N/A */
+	uint8_t reserved3b2;		/* Byte offset 0x3b2, CSR Addr 0x541d9, Direction=N/A */
+	uint8_t reserved3b3;		/* Byte offset 0x3b3, CSR Addr 0x541d9, Direction=N/A */
+	uint8_t reserved3b4;		/* Byte offset 0x3b4, CSR Addr 0x541da, Direction=N/A */
+	uint8_t reserved3b5;		/* Byte offset 0x3b5, CSR Addr 0x541da, Direction=N/A */
+	uint8_t reserved3b6;		/* Byte offset 0x3b6, CSR Addr 0x541db, Direction=N/A */
+	uint8_t reserved3b7;		/* Byte offset 0x3b7, CSR Addr 0x541db, Direction=N/A */
+	uint8_t reserved3b8;		/* Byte offset 0x3b8, CSR Addr 0x541dc, Direction=N/A */
+	uint8_t reserved3b9;		/* Byte offset 0x3b9, CSR Addr 0x541dc, Direction=N/A */
+	uint8_t reserved3ba;		/* Byte offset 0x3ba, CSR Addr 0x541dd, Direction=N/A */
+	uint8_t reserved3bb;		/* Byte offset 0x3bb, CSR Addr 0x541dd, Direction=N/A */
+	uint8_t reserved3bc;		/* Byte offset 0x3bc, CSR Addr 0x541de, Direction=N/A */
+	uint8_t reserved3bd;		/* Byte offset 0x3bd, CSR Addr 0x541de, Direction=N/A */
+	uint8_t reserved3be;		/* Byte offset 0x3be, CSR Addr 0x541df, Direction=N/A */
+	uint8_t reserved3bf;		/* Byte offset 0x3bf, CSR Addr 0x541df, Direction=N/A */
+	uint8_t reserved3c0;		/* Byte offset 0x3c0, CSR Addr 0x541e0, Direction=N/A */
+	uint8_t reserved3c1;		/* Byte offset 0x3c1, CSR Addr 0x541e0, Direction=N/A */
+	uint8_t reserved3c2;		/* Byte offset 0x3c2, CSR Addr 0x541e1, Direction=N/A */
+	uint8_t reserved3c3;		/* Byte offset 0x3c3, CSR Addr 0x541e1, Direction=N/A */
+	uint8_t reserved3c4;		/* Byte offset 0x3c4, CSR Addr 0x541e2, Direction=N/A */
+	uint8_t reserved3c5;		/* Byte offset 0x3c5, CSR Addr 0x541e2, Direction=N/A */
+	uint8_t reserved3c6;		/* Byte offset 0x3c6, CSR Addr 0x541e3, Direction=N/A */
+	uint8_t reserved3c7;		/* Byte offset 0x3c7, CSR Addr 0x541e3, Direction=N/A */
+	uint8_t reserved3c8;		/* Byte offset 0x3c8, CSR Addr 0x541e4, Direction=N/A */
+	uint8_t reserved3c9;		/* Byte offset 0x3c9, CSR Addr 0x541e4, Direction=N/A */
+	uint8_t reserved3ca;		/* Byte offset 0x3ca, CSR Addr 0x541e5, Direction=N/A */
+	uint8_t reserved3cb;		/* Byte offset 0x3cb, CSR Addr 0x541e5, Direction=N/A */
+	uint8_t reserved3cc;		/* Byte offset 0x3cc, CSR Addr 0x541e6, Direction=N/A */
+	uint8_t reserved3cd;		/* Byte offset 0x3cd, CSR Addr 0x541e6, Direction=N/A */
+	uint8_t reserved3ce;		/* Byte offset 0x3ce, CSR Addr 0x541e7, Direction=N/A */
+	uint8_t reserved3cf;		/* Byte offset 0x3cf, CSR Addr 0x541e7, Direction=N/A */
+	uint8_t reserved3d0;		/* Byte offset 0x3d0, CSR Addr 0x541e8, Direction=N/A */
+	uint8_t reserved3d1;		/* Byte offset 0x3d1, CSR Addr 0x541e8, Direction=N/A */
+	uint8_t reserved3d2;		/* Byte offset 0x3d2, CSR Addr 0x541e9, Direction=N/A */
+	uint8_t reserved3d3;		/* Byte offset 0x3d3, CSR Addr 0x541e9, Direction=N/A */
+	uint8_t reserved3d4;		/* Byte offset 0x3d4, CSR Addr 0x541ea, Direction=N/A */
+	uint8_t reserved3d5;		/* Byte offset 0x3d5, CSR Addr 0x541ea, Direction=N/A */
+	uint8_t reserved3d6;		/* Byte offset 0x3d6, CSR Addr 0x541eb, Direction=N/A */
+	uint8_t reserved3d7;		/* Byte offset 0x3d7, CSR Addr 0x541eb, Direction=N/A */
+	uint8_t reserved3d8;		/* Byte offset 0x3d8, CSR Addr 0x541ec, Direction=N/A */
+	uint8_t reserved3d9;		/* Byte offset 0x3d9, CSR Addr 0x541ec, Direction=N/A */
+	uint8_t reserved3da;		/* Byte offset 0x3da, CSR Addr 0x541ed, Direction=N/A */
+	uint8_t reserved3db;		/* Byte offset 0x3db, CSR Addr 0x541ed, Direction=N/A */
+	uint8_t reserved3dc;		/* Byte offset 0x3dc, CSR Addr 0x541ee, Direction=N/A */
+	uint8_t reserved3dd;		/* Byte offset 0x3dd, CSR Addr 0x541ee, Direction=N/A */
+	uint8_t reserved3de;		/* Byte offset 0x3de, CSR Addr 0x541ef, Direction=N/A */
+	uint8_t reserved3df;		/* Byte offset 0x3df, CSR Addr 0x541ef, Direction=N/A */
+	uint8_t reserved3e0;		/* Byte offset 0x3e0, CSR Addr 0x541f0, Direction=N/A */
+	uint8_t reserved3e1;		/* Byte offset 0x3e1, CSR Addr 0x541f0, Direction=N/A */
+	uint8_t reserved3e2;		/* Byte offset 0x3e2, CSR Addr 0x541f1, Direction=N/A */
+	uint8_t reserved3e3;		/* Byte offset 0x3e3, CSR Addr 0x541f1, Direction=N/A */
+	uint8_t reserved3e4;		/* Byte offset 0x3e4, CSR Addr 0x541f2, Direction=N/A */
+	uint8_t reserved3e5;		/* Byte offset 0x3e5, CSR Addr 0x541f2, Direction=N/A */
+	uint8_t reserved3e6;		/* Byte offset 0x3e6, CSR Addr 0x541f3, Direction=N/A */
+	uint8_t reserved3e7;		/* Byte offset 0x3e7, CSR Addr 0x541f3, Direction=N/A */
+	uint8_t reserved3e8;		/* Byte offset 0x3e8, CSR Addr 0x541f4, Direction=N/A */
+	uint8_t reserved3e9;		/* Byte offset 0x3e9, CSR Addr 0x541f4, Direction=N/A */
+	uint8_t reserved3ea;		/* Byte offset 0x3ea, CSR Addr 0x541f5, Direction=N/A */
+	uint8_t reserved3eb;		/* Byte offset 0x3eb, CSR Addr 0x541f5, Direction=N/A */
+	uint8_t reserved3ec;		/* Byte offset 0x3ec, CSR Addr 0x541f6, Direction=N/A */
+	uint8_t reserved3ed;		/* Byte offset 0x3ed, CSR Addr 0x541f6, Direction=N/A */
+	uint8_t reserved3ee;		/* Byte offset 0x3ee, CSR Addr 0x541f7, Direction=N/A */
+	uint8_t reserved3ef;		/* Byte offset 0x3ef, CSR Addr 0x541f7, Direction=N/A */
+	uint8_t reserved3f0;		/* Byte offset 0x3f0, CSR Addr 0x541f8, Direction=N/A */
+	uint8_t reserved3f1;		/* Byte offset 0x3f1, CSR Addr 0x541f8, Direction=N/A */
+	uint8_t reserved3f2;		/* Byte offset 0x3f2, CSR Addr 0x541f9, Direction=N/A */
+	uint8_t reserved3f3;		/* Byte offset 0x3f3, CSR Addr 0x541f9, Direction=N/A */
+	uint8_t reserved3f4;		/* Byte offset 0x3f4, CSR Addr 0x541fa, Direction=N/A */
+	uint8_t reserved3f5;		/* Byte offset 0x3f5, CSR Addr 0x541fa, Direction=N/A */
+	uint16_t alt_cas_l;		/*
+					 * Byte offset 0x3f6, CSR Addr 0x541fb, Direction=in
+					 * This field must be populated if RdDBI is enabled
+					 * (applicable when mr5[A12] == 1).
+					 * RdDBI is dynamically disabled in certain training steps,
+					 * and so the [RdDBI disabled] CAS Latency must be provided
+					 * in this field.
+					 * The required encoding is as follows:
+					 * alt_cas_l[0] == 0: use value in mr0
+					 * alt_cas_l[0] == 1: use value in alt_cas_l, i.e.,
+					 *   mr0{A[12],A[6],A[5],A[4],A[2]} = alt_cas_l[12,6,5,4,2]
+					 * Other bits are ignored
+					 */
+	uint8_t alt_wcas_l;		/*
+					 * Byte offset 0x3f8, CSR Addr 0x541fc, Direction=In
+					 * This field must be populated if 2tCK write preambles are
+					 * enabled (applicable when mr4[A12] == 1).
+					 * 2tCK write prambles are dynamically disabled in certain
+					 * training steps, and so the [1tCK write preamble] WCAS
+					 * Latency must be provided in this field.
+					 * The required encoding is as follows:
+					 * alt_wcas_l[0] == 0: use value in mr2
+					 * alt_wcas_l[0] == 1: use value in alt_wcas_l, i.e.,
+					 *   mr2{A[5],A[4],A[3]} = alt_wcas_l[5,4,3]
+					 * Other bits are ignored
+					 */
+	uint8_t d4misc;			/*
+					 * Byte offset 0x3f9, CSR Addr 0x541fc, Direction=In
+					 * Contains various options for training DDR4 Devices.
+					 *
+					 * Bit fields:
+					 *
+					 * d4misc[7:5,2,1] RFU, must be zero
+					 *
+					 * d4misc[0] = protect memory reset
+					 *   0x1 = dfi_reset_n cannot control BP_MEMRESERT_L to
+					 *         devices after training.
+					 *   0x0 = dfi_resert_n can control BP_MEMRESERT_L to
+					 *         devices after training
+					 *
+					 * d4misc[3]: reserved
+					 *
+					 * d4misc[4]: DRAM reset mode
+					 *   0x1 = Do not reset DRAM during devinit
+					 *   0x0 = Reset DRAM during devinit
+					 */
+} __attribute__ ((packed)) __attribute__ ((aligned(2)));
+
+#endif /* MNPMUSRAMMSGBLOCK_DDR4_H */
diff --git a/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h
new file mode 100644
index 0000000000..c438b7fc70
--- /dev/null
+++ b/drivers/st/ddr/phy/firmware/include/mnpmusrammsgblock_lpddr4.h
@@ -0,0 +1,924 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MNPMUSRAMMSGBLOCK_LPDDR4_H
+#define MNPMUSRAMMSGBLOCK_LPDDR4_H
+
+/* LPDDR4_1D training firmware message block structure
+ *
+ * Please refer to the Training Firmware App Note for futher information about
+ * the usage for Message Block.
+ */
+struct pmu_smb_ddr_1d {
+	uint8_t reserved00;		/*
+					 * Byte offset 0x00, CSR Addr 0x54000, Direction=In
+					 * reserved00[0:4] RFU, must be zero
+					 *
+					 * reserved00[5] = Quick Rd2D during 1D Training
+					 *   0x1 = Read Deskew will begin by enabling and quickly
+					 *   training the phy's per-lane reference voltages.
+					 *   Training the vrefDACs CSRs will increase the maximum 1D
+					 *   training time by around half a millisecond, but will
+					 *   improve 1D training accuracy on systems with
+					 *   significant voltage-offsets between lane read eyes.
+					 *   0x0 = Read Deskew will assume the messageblock's
+					 *   phyVref setting is optimal for all lanes.
+					 *
+					 * reserved00[6] = Enable High Effort WrDQ1D
+					 *   0x1 = WrDQ1D will conditionally retry training at
+					 *   several extra RxClkDly Timings. This will increase the
+					 *   maximum 1D training time by up to 4 extra iterations of
+					 *   WrDQ1D. This is only required in systems that suffer
+					 *   from very large, asymmetric eye-collapse when receiving
+					 *   PRBS patterns.
+					 *   0x0 = WrDQ1D assume rxClkDly values found by SI
+					 *   Friendly RdDqs1D will work for receiving PRBS patterns
+					 *
+					 * reserved00[7] = Optimize for the special hard macros in
+					 * TSMC28.
+					 *   0x1 = set if the phy being trained was manufactured in
+					 *   any TSMC28 process node.
+					 *   0x0 = otherwise, when not training a TSMC28 phy, leave
+					 *   this field as 0.
+					 */
+	uint8_t msgmisc;		/*
+					 * Byte offset 0x01, CSR Addr 0x54000, Direction=In
+					 * Contains various global options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * msgmisc[0] MTESTEnable
+					 *   0x1 = Pulse primary digital test output bump at the end
+					 *   of each major training stage. This enables observation
+					 *   of training stage completion by observing the digital
+					 *   test output.
+					 *   0x0 = Do not pulse primary digital test output bump
+					 *
+					 * msgmisc[1] SimulationOnlyReset
+					 *   0x1 = Verilog only simulation option to shorten
+					 *   duration of DRAM reset pulse length to 1ns.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use reset pulse length specifed by JEDEC standard
+					 *
+					 * msgmisc[2] SimulationOnlyTraining
+					 *   0x1 = Verilog only simulation option to shorten the
+					 *   duration of the training steps by performing fewer
+					 *   iterations.
+					 *   Must never be set to 1 in silicon.
+					 *   0x0 = Use standard training duration.
+					 *
+					 * msgmisc[3] Disable Boot Clock
+					 *   0x1 = Disable boot frequency clock when initializing
+					 *   DRAM. (not recommended)
+					 *   0x0 = Use Boot Frequency Clock
+					 *
+					 * msgmisc[4] Suppress streaming messages, including
+					 * assertions, regardless of hdtctrl setting.
+					 * Stage Completion messages, as well as training completion
+					 * and error messages are still sent depending on hdtctrl
+					 * setting.
+					 *
+					 * msgmisc[5] PerByteMaxRdLat
+					 *   0x1 = Each DBYTE will return dfi_rddata_valid at the
+					 *   lowest possible latency. This may result in unaligned
+					 *   data between bytes to be returned to the DFI.
+					 *   0x0 = Every DBYTE will return dfi_rddata_valid
+					 *   simultaneously. This will ensure that data bytes will
+					 *   return aligned accesses to the DFI.
+					 *
+					 * msgmisc[7-6] RFU, must be zero
+					 *
+					 * Notes:
+					 *
+					 * - SimulationOnlyReset and SimulationOnlyTraining can be
+					 *   used to speed up simulation run times, and must never
+					 *   be used in real silicon. Some VIPs may have checks on
+					 *   DRAM reset parameters that may need to be disabled when
+					 *   using SimulationOnlyReset.
+					 */
+	uint16_t pmurevision;		/*
+					 * Byte offset 0x02, CSR Addr 0x54001, Direction=Out
+					 * PMU firmware revision ID
+					 * After training is run, this address will contain the
+					 * revision ID of the firmware
+					 */
+	uint8_t pstate;			/*
+					 * Byte offset 0x04, CSR Addr 0x54002, Direction=In
+					 * Must be set to the target pstate to be trained
+					 *   0x0 = pstate 0
+					 *   0x1 = pstate 1
+					 *   0x2 = pstate 2
+					 *   0x3 = pstate 3
+					 *   All other encodings are reserved
+					 */
+	uint8_t pllbypassen;		/*
+					 * Byte offset 0x05, CSR Addr 0x54002, Direction=In
+					 * Set according to whether target pstate uses PHY PLL
+					 * bypass
+					 *   0x0 = PHY PLL is enabled for target pstate
+					 *   0x1 = PHY PLL is bypassed for target pstate
+					 */
+	uint16_t dramfreq;		/*
+					 * Byte offset 0x06, CSR Addr 0x54003, Direction=In
+					 * DDR data rate for the target pstate in units of MT/s.
+					 * For example enter 0x0640 for DDR1600.
+					 */
+	uint8_t dfifreqratio;		/*
+					 * Byte offset 0x08, CSR Addr 0x54004, Direction=In
+					 * Frequency ratio betwen DfiCtlClk and SDRAM memclk.
+					 *   0x1 = 1:1
+					 *   0x2 = 1:2
+					 *   0x4 = 1:4
+					 */
+	uint8_t bpznresval;		/*
+					 * Byte offset 0x09, CSR Addr 0x54004, Direction=In
+					 * Overwrite the value of precision resistor connected to
+					 * Phy BP_ZN
+					 *   0x00 = Do not program. Use current CSR value.
+					 *   0xf0 = 240 Ohm
+					 *   0x78 = 120 Ohm
+					 *   0x28 = 40 Ohm
+					 *   All other values are reserved.
+					 * It is recommended to set this to 0x00.
+					 */
+	uint8_t phyodtimpedance;	/*
+					 * Byte offset 0x0a, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the termination impedance in ohms
+					 * used by PHY during reads.
+					 *
+					 * 0x0 = Firmware skips programming (must be manually
+					 * programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal termination impedance values.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must determine the correct value
+					 * through SI simulation or other methods.
+					 */
+	uint8_t phydrvimpedance;	/*
+					 * Byte offset 0x0b, CSR Addr 0x54005, Direction=In
+					 * Must be programmed to the driver impedance in ohms used
+					 * by PHY during writes for all DBYTE drivers
+					 * (DQ/DM/DBI/DQS).
+					 *
+					 *   0x0 = Firmware skips programming (must be manually
+					 *   programmed by user prior to training start)
+					 *
+					 * See PHY databook for legal R_on driver impedance values.
+					 *
+					 * For digital simulation, any value can be used that is not
+					 * Hi-Z. For silicon, the users must determine the correct
+					 * value through SI simulation or other methods.
+					 */
+	uint8_t phyvref;		/*
+					 * Byte offset 0x0c, CSR Addr 0x54006, Direction=In
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads
+					 *
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 *
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 *
+					 * For example to set Vref at 0.25*VDDQ, set this field to
+					 * 0x20.
+					 *
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+	uint8_t lp4misc;		/*
+					 * Byte offset 0x0d, CSR Addr 0x54006, Direction=In
+					 * Lp4 specific options for training.
+					 *
+					 * Bit fields:
+					 *
+					 * lp4misc[0] Enable dfi_reset_n
+					 *
+					 *   0x0 = (Recommended) PHY internal registers control
+					 *   memreset during training, and also after training.
+					 *   dfi_reset_n cannot control the PHY BP_MEMRESET_L pin.
+					 *
+					 *   0x1 = Enables dfi_reset_n to control memreset after
+					 *   training. PHY Internal registers control memreset
+					 *   during training only. To ensure that no glitches occur
+					 *   on BP_MEMRESET at the end of training, The MC must
+					 *   drive dfi_reset_n=1'b1 _prior to starting training_
+					 *
+					 * lp4misc[7-1] RFU, must be zero
+					 */
+	uint8_t reserved0e;		/*
+					 * Byte offset 0x0e, CSR Addr 0x54007, Direction=In
+					 * Bit Field for enabling optional 2D training features
+					 * that impact both Rx2D and Tx2D.
+					 *
+					 * reserved0E[0:3]: bitTimeControl
+					 * input for the amount of data bits 2D writes/reads per DQ
+					 * before deciding if any specific voltage and delay setting
+					 * passes or fails. Every time this input increases by 1,
+					 * the number of 2D data comparisons is doubled. The 2D run
+					 * time will increase proportionally to the number of bit
+					 * times requested per point.
+					 *   0 = 288 bits per point (legacy behavior)
+					 *   1 = 576 bits per point
+					 *   2 = 1.125 kilobits per point
+					 *     . . .
+					 *   15 = 9 megabits per point
+					 *
+					 * reserved0E[4]: Exhaustive2D
+					 *   0 = 2D optimization assumes the optimal trained point
+					 *   is near the 1D trained point (legacy behavior)
+					 *   1 = 2D optimization searches the entire passing region
+					 *   at the cost of run time. Recommended for optimal
+					 *   results any time the optimal trained point is expected
+					 *   to be near the edges of the eyes instead of near the 1D
+					 *   trained point.
+					 *
+					 * reserved0E[5]: Detect Vref Eye Truncation, ignored if
+					 * eyeWeight2DControl == 0.
+					 *   0 = 2D optimizes for the passing region it can measure.
+					 *   1 = For every eye, 2D checks If the legal voltage range
+					 *   truncated the eye. If the true voltage margin cannot be
+					 *   measured, 2D will optimize heavily for delay margin
+					 *   instead of using incomplete voltage margin data. Eyes
+					 *   that are not truncated will still be optimized using
+					 *   user programmed weights.
+					 *
+					 * reserved0E[6]: eyeWeight2DControl
+					 *   0 = Use 8 bit weights for Delay_Weight2D and
+					 *   Voltage_Weight2D and disable TrunkV behavior.
+					 *   1 = Use 4 bit weights for Delay_weight2D and
+					 *   Voltage_Weight2D and enable TrunkV behavior.
+					 *
+					 * reserved0E[7]: RFU, must be 0
+					 */
+	uint8_t cstestfail;		/*
+					 * Byte offset 0x0f, CSR Addr 0x54007, Direction=Out
+					 * This field will be set if training fails on any rank.
+					 *   0x0 = No failures
+					 *   non-zero = one or more ranks failed training
+					 */
+	uint16_t sequencectrl;		/*
+					 * Byte offset 0x10, CSR Addr 0x54008, Direction=In
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 *
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 *
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *                   initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *                   training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[11-10] = RFU, must be zero
+					 * sequencectrl[12] = Run LPCA - CA Training
+					 * sequencectrl[15-13] = RFU, must be zero
+					 */
+	uint8_t hdtctrl;		/*
+					 * Byte offset 0x12, CSR Addr 0x54009, Direction=In
+					 * To control the total number of debug messages, a
+					 * verbosity subfield (hdtctrl, Hardware Debug Trace
+					 * Control) exists in the message block. Every message has a
+					 * verbosity level associated with it, and as the hdtctrl
+					 * value is increased, less important s messages stop being
+					 * sent through the mailboxes. The meanings of several major
+					 * hdtctrl thresholds are explained below:
+					 *
+					 *   0x04 = Maximal debug messages (e.g., Eye contours)
+					 *   0x05 = Detailed debug messages (e.g. Eye delays)
+					 *   0x0A = Coarse debug messages (e.g. rank information)
+					 *   0xC8 = Stage completion
+					 *   0xC9 = Assertion messages
+					 *   0xFF = Firmware completion messages only
+					 */
+	uint8_t reserved13;		/*
+					 * Byte offset 0x13, CSR Addr 0x54009, Direction=In
+					 *
+					 *   0 = Default operation, unchanged.
+					 *   Others = RD DQ calibration Training steps are completed
+					 *   with user specified pattern.
+					 */
+	uint8_t reserved14;		/*
+					 * Byte offset 0x14, CSR Addr 0x5400a, Direction=In
+					 * Configure rd2D search iteration from a starting seed
+					 * point:
+					 *
+					 * reserved14[5:0]: If reserved14[6] is 0, Number of search
+					 * iterations (if 0, then default is 20); otherwise if this
+					 * value non zero, this value is used as a delta to filter
+					 * out points during the averaging: when averaging over a
+					 * dimension (delay or voltage), the points having a margin
+					 * smaller than the max of the eye in this dimension by at
+					 * least this delta value are filtered out.
+					 *
+					 * reserved14[6]: If set, instead of search, extract center
+					 * using an averaging function over the eye surface area,
+					 * where some points can be filtered out using
+					 * reserved14[5:0]
+					 *
+					 * reserved14[7]: if set, start search with large step size,
+					 * decreasing at each 4 iterations, down to 1 (do not care
+					 * if reserved14[6] is set)
+					 */
+	uint8_t reserved15;		/*
+					 * Byte offset 0x15, CSR Addr 0x5400a, Direction=In
+					 * Configure wr2D search iteration from a starting seed
+					 * point:
+					 *
+					 * reserved15[5:0]: If reserved15[6] is 0, Number of search
+					 * iterations (if 0, then default is 20); otherwise if this
+					 * value non zero, this value is used as a delta to filter
+					 * out points during the averaging: when averaging over a
+					 * dimension (delay or voltage), the points having a margin
+					 * smaller than the max of the eye in this dimension by at
+					 * least this delta value are filtered out.
+					 *
+					 * reserved15[6]: If set, instead of search, extract center
+					 * using an averaging function over the eye surface area,
+					 * where some points can be filtered out using
+					 * reserved15[5:0]
+					 *
+					 * reserved15[7]: if set, start search with large step size,
+					 * decreasing at each 4 iterations, down to 1 (do not care
+					 * if reserved15[6] is set)
+					 */
+	uint8_t dfimrlmargin;		/*
+					 * Byte offset 0x16, CSR Addr 0x5400b, Direction=In
+					 * Margin added to smallest passing trained DFI Max Read
+					 * Latency value, in units of DFI clocks. Recommended to be
+					 * >= 1.
+					 *
+					 * This margin must include the maximum positive drift
+					 * expected in tDQSCK over the target temperature and
+					 * voltage range of the users system.
+					 */
+	uint8_t reserved17;		/*
+					 * Byte offset 0x17, CSR Addr 0x5400b, Direction=In
+					 * Configure DB from which extra info is dump during 2D
+					 * training when maximal debug is set:
+					 *
+					 * reserved17[3:0]: first DB
+					 *
+					 * reserved17[7:4]: number of DB, including first DB (if 0,
+					 * no extra debug per DB is dump)
+					 */
+	uint8_t usebroadcastmr;		/*
+					 * Byte offset 0x18, CSR Addr 0x5400c, Direction=In
+					 * Training firmware can optionally set per rank mode
+					 * register values for DRAM partial array self-refresh
+					 * features if desired.
+					 *
+					 *   0x0 = Use mr<1:4, 11:14, 16:17, 22, 24>_a0 for rank 0
+					 *	   channel A
+					 *	   Use mr<1:4, 11:14, 16:17, 22, 24>_b0 for rank 0
+					 *	   channel B
+					 *	   Use mr<1:4, 11:14, 16:17, 22, 24>_a1 for rank 1
+					 *	   channel A
+					 *	   Use mr<1:4, 11:14, 16:17, 22, 24>_b1 for rank 1
+					 *	   channel B
+					 *
+					 *   0x1 = Use mr<1:4, 11:14, 16:17, 22, 24>_a0 setting for
+					 *	   all channels/ranks
+					 *
+					 * It is recommended in most LPDDR4 system configurations
+					 * to set this to 1.
+					 * It is recommended in LPDDR4x system configurations to
+					 * set this to 0.
+					 */
+	uint8_t lp4quickboot;		/*
+					 * Byte offset 0x19, CSR Addr 0x5400c, Direction=In
+					 * Enable Quickboot. It must be set to 0x0 since Quickboot
+					 * is only supported in dedicated Quickboot firmware.
+					 */
+	uint8_t reserved1a;		/*
+					 * Byte offset 0x1a, CSR Addr 0x5400d, Direction=In
+					 * Input for constraining the range of vref(DQ) values
+					 * training will collect data for, usually reducing training
+					 * time. However, too large of a voltage range may cause
+					 * longer 2D training times while too small of a voltage
+					 * range may truncate passing regions. When in doubt, leave
+					 * this field set to 0.
+					 * Used by 2D stages: Rd2D, Wr2D
+					 *
+					 * reserved1A[0-3]: Rd2D Voltage Range
+					 *   0 = Training will search all phy vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from phyVref
+					 *   2 = limit to +/-4 %VDDQ from phyVref
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from phyVref
+					 *
+					 * reserved1A[4-7]: Wr2D Voltage Range
+					 *   0 = Training will search all dram vref(DQ) settings
+					 *   1 = limit to +/-2 %VDDQ from mr14
+					 *   2 = limit to +/-4 %VDDQ from mr14
+					 *     . . .
+					 *   15 = limit to +/-30% VDDQ from mr14
+					 */
+	uint8_t catrainopt;		/*
+					 * Byte offset 0x1b, CSR Addr 0x5400d, Direction=In
+					 * CA training option bit field
+					 * [0] CA VREF Training
+					 *   1 = Enable CA VREF Training
+					 *   0 = Disable CA VREF Training
+					 *  WARNING: catrainopt[0] must be set to the same value in
+					 *  1D and 2D training.
+					 *
+					 * [1] Train terminated Rank only
+					 *   1 = Only train terminated rank in CA training
+					 *   0 = Train all ranks in CA training
+					 *
+					 * [2-7] RFU must be zero
+					 */
+	uint8_t x8mode;			/*
+					 * Byte offset 0x1c, CSR Addr 0x5400e, Direction=In
+					 * X8 mode configuration:
+					 *   0x0 = x16 configuration for all devices
+					 *   0xF = x8 configuration for all devices
+					 * All other values are RFU
+					 */
+	uint8_t reserved1d;		/* Byte offset 0x1d, CSR Addr 0x5400e, Direction=N/A */
+	uint8_t reserved1e;		/* Byte offset 0x1e, CSR Addr 0x5400f, Direction=N/A */
+	uint8_t share2dvrefresult;	/*
+					 * Byte offset 0x1f, CSR Addr 0x5400f, Direction=In
+					 * Bitmap that designates the phy's vref source for every
+					 * pstate
+					 * If share2dvrefresult[x] = 0, then after 2D training,
+					 * pstate x will continue using the phyVref provided in
+					 * pstate x's 1D messageblock.
+					 * If share2dvrefresult[x] = 1, then after 2D training,
+					 * pstate x will use the per-lane VrefDAC0/1 CSRs trained by
+					 * 2d training.
+					 */
+	uint8_t reserved20;		/* Byte offset 0x20, CSR Addr 0x54010, Direction=N/A */
+	uint8_t reserved21;		/* Byte offset 0x21, CSR Addr 0x54010, Direction=N/A */
+	uint16_t phyconfigoverride;	/*
+					 * Byte offset 0x22, CSR Addr 0x54011, Direction=In
+					 * Override PhyConfig csr.
+					 *   0x0: Use hardware csr value for PhyConfing
+					 *   (recommended)
+					 *   Other values: Use value for PhyConfig instead of
+					 *   Hardware value.
+					 *
+					 */
+	uint8_t enableddqscha;		/*
+					 * Byte offset 0x24, CSR Addr 0x54012, Direction=In
+					 * Total number of DQ bits enabled in PHY Channel A
+					 */
+	uint8_t cspresentcha;		/*
+					 * Byte offset 0x25, CSR Addr 0x54012, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY
+					 * channel A.
+					 *   0x1 = CS0 is populated with DRAM
+					 *   0x3 = CS0 and CS1 are populated with DRAM
+					 *
+					 * All other encodings are illegal
+					 */
+	int8_t cdd_cha_rr_1_0;		/*
+					 * Byte offset 0x26, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_rr_0_1;		/*
+					 * Byte offset 0x27, CSR Addr 0x54013, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_rw_1_1;		/*
+					 * Byte offset 0x28, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 1
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_rw_1_0;		/*
+					 * Byte offset 0x29, CSR Addr 0x54014, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 0
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_rw_0_1;		/*
+					 * Byte offset 0x2a, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 1
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_rw_0_0;		/*
+					 * Byte offset 0x2b, CSR Addr 0x54015, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs0 to cs 0
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_wr_1_1;		/*
+					 * Byte offset 0x2c, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 1
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_wr_1_0;		/*
+					 * Byte offset 0x2d, CSR Addr 0x54016, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 0
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_wr_0_1;		/*
+					 * Byte offset 0x2e, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 1
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_wr_0_0;		/*
+					 * Byte offset 0x2f, CSR Addr 0x54017, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 0
+					 * on Channel A.
+					 */
+	int8_t cdd_cha_ww_1_0;		/*
+					 * Byte offset 0x30, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0 on Channel A.
+					 */
+	int8_t cdd_cha_ww_0_1;		/*
+					 * Byte offset 0x31, CSR Addr 0x54018, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1 on Channel A.
+					 */
+	uint8_t mr1_a0;			/*
+					 * Byte offset 0x32, CSR Addr 0x54019, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr2_a0;			/*
+					 * Byte offset 0x33, CSR Addr 0x54019, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr3_a0;			/*
+					 * Byte offset 0x34, CSR Addr 0x5401a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr4_a0;			/*
+					 * Byte offset 0x35, CSR Addr 0x5401a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr11_a0;		/*
+					 * Byte offset 0x36, CSR Addr 0x5401b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr12_a0;		/*
+					 * Byte offset 0x37, CSR Addr 0x5401b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr13_a0;		/*
+					 * Byte offset 0x38, CSR Addr 0x5401c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr14_a0;		/*
+					 * Byte offset 0x39, CSR Addr 0x5401c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr16_a0;		/*
+					 * Byte offset 0x3a, CSR Addr 0x5401d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr17_a0;		/*
+					 * Byte offset 0x3b, CSR Addr 0x5401d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr22_a0;		/*
+					 * Byte offset 0x3c, CSR Addr 0x5401e, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr24_a0;		/*
+					 * Byte offset 0x3d, CSR Addr 0x5401e, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel A, Rank 0}
+					 */
+	uint8_t mr1_a1;			/*
+					 * Byte offset 0x3e, CSR Addr 0x5401f, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr2_a1;			/*
+					 * Byte offset 0x3f, CSR Addr 0x5401f, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr3_a1;			/*
+					 * Byte offset 0x40, CSR Addr 0x54020, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr4_a1;			/*
+					 * Byte offset 0x41, CSR Addr 0x54020, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr11_a1;		/*
+					 * Byte offset 0x42, CSR Addr 0x54021, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr12_a1;		/*
+					 * Byte offset 0x43, CSR Addr 0x54021, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr13_a1;		/*
+					 * Byte offset 0x44, CSR Addr 0x54022, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr14_a1;		/*
+					 * Byte offset 0x45, CSR Addr 0x54022, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr16_a1;		/*
+					 * Byte offset 0x46, CSR Addr 0x54023, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr17_a1;		/*
+					 * Byte offset 0x47, CSR Addr 0x54023, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr22_a1;		/*
+					 * Byte offset 0x48, CSR Addr 0x54024, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t mr24_a1;		/*
+					 * Byte offset 0x49, CSR Addr 0x54024, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel A, Rank 1}
+					 */
+	uint8_t caterminatingrankcha;	/* Byte offset 0x4a, CSR Addr 0x54025, Direction=In
+					 * Terminating Rank for CA bus on Channel A
+					 *   0x0 = Rank 0 is terminating rank
+					 *   0x1 = Rank 1 is terminating rank
+					 */
+	uint8_t reserved4b;		/* Byte offset 0x4b, CSR Addr 0x54025, Direction=N/A */
+	uint8_t reserved4c;		/* Byte offset 0x4c, CSR Addr 0x54026, Direction=N/A */
+	uint8_t reserved4d;		/* Byte offset 0x4d, CSR Addr 0x54026, Direction=N/A */
+	uint8_t reserved4e;		/* Byte offset 0x4e, CSR Addr 0x54027, Direction=N/A */
+	uint8_t reserved4f;		/* Byte offset 0x4f, CSR Addr 0x54027, Direction=N/A */
+	uint8_t reserved50;		/* Byte offset 0x50, CSR Addr 0x54028, Direction=N/A */
+	uint8_t reserved51;		/* Byte offset 0x51, CSR Addr 0x54028, Direction=N/A */
+	uint8_t reserved52;		/* Byte offset 0x52, CSR Addr 0x54029, Direction=N/A */
+	uint8_t reserved53;		/* Byte offset 0x53, CSR Addr 0x54029, Direction=N/A */
+	uint8_t reserved54;		/* Byte offset 0x54, CSR Addr 0x5402a, Direction=N/A */
+	uint8_t reserved55;		/* Byte offset 0x55, CSR Addr 0x5402a, Direction=N/A */
+	uint8_t reserved56;		/* Byte offset 0x56, CSR Addr 0x5402b, Direction=N/A */
+	uint8_t enableddqschb;		/*
+					 * Byte offset 0x57, CSR Addr 0x5402b, Direction=In
+					 * Total number of DQ bits enabled in PHY Channel B
+					 */
+	uint8_t cspresentchb;		/*
+					 * Byte offset 0x58, CSR Addr 0x5402c, Direction=In
+					 * Indicates presence of DRAM at each chip select for PHY
+					 * channel B.
+					 *   0x0 = No chip selects are populated with DRAM
+					 *   0x1 = CS0 is populated with DRAM
+					 *   0x3 = CS0 and CS1 are populated with DRAM
+					 *
+					 * All other encodings are illegal
+					 */
+	int8_t cdd_chb_rr_1_0;		/*
+					 * Byte offset 0x59, CSR Addr 0x5402c, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 1 to cs 0
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_rr_0_1;		/*
+					 * Byte offset 0x5a, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Read to read critical delay difference from cs 0 to cs 1
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_rw_1_1;		/*
+					 * Byte offset 0x5b, CSR Addr 0x5402d, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 1
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_rw_1_0;		/*
+					 * Byte offset 0x5c, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 1 to cs 0
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_rw_0_1;		/*
+					 * Byte offset 0x5d, CSR Addr 0x5402e, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs 0 to cs 1
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_rw_0_0;		/*
+					 * Byte offset 0x5e, CSR Addr 0x5402f, Direction=Out
+					 * This is a signed integer value.
+					 * Read to write critical delay difference from cs01 to cs 0
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_wr_1_1;		/*
+					 * Byte offset 0x5f, CSR Addr 0x5402f, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 1
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_wr_1_0;		/*
+					 * Byte offset 0x60, CSR Addr 0x54030, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 1 to cs 0
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_wr_0_1;		/*
+					 * Byte offset 0x61, CSR Addr 0x54030, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 1
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_wr_0_0;		/*
+					 * Byte offset 0x62, CSR Addr 0x54031, Direction=Out
+					 * This is a signed integer value.
+					 * Write to read critical delay difference from cs 0 to cs 0
+					 * on Channel B.
+					 */
+	int8_t cdd_chb_ww_1_0;		/*
+					 * Byte offset 0x63, CSR Addr 0x54031, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 1 to cs
+					 * 0 on Channel B.
+					 */
+	int8_t cdd_chb_ww_0_1;		/*
+					 * Byte offset 0x64, CSR Addr 0x54032, Direction=Out
+					 * This is a signed integer value.
+					 * Write to write critical delay difference from cs 0 to cs
+					 * 1 on Channel B.
+					 */
+	uint8_t mr1_b0;			/*
+					 * Byte offset 0x65, CSR Addr 0x54032, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr2_b0;			/*
+					 * Byte offset 0x66, CSR Addr 0x54033, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr3_b0;			/*
+					 * Byte offset 0x67, CSR Addr 0x54033, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr4_b0;			/*
+					 * Byte offset 0x68, CSR Addr 0x54034, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr11_b0;		/*
+					 * Byte offset 0x69, CSR Addr 0x54034, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr12_b0;		/*
+					 * Byte offset 0x6a, CSR Addr 0x54035, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr13_b0;		/*
+					 * Byte offset 0x6b, CSR Addr 0x54035, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr14_b0;		/*
+					 * Byte offset 0x6c, CSR Addr 0x54036, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr16_b0;		/*
+					 * Byte offset 0x6d, CSR Addr 0x54036, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr17_b0;		/*
+					 * Byte offset 0x6e, CSR Addr 0x54037, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr22_b0;		/*
+					 * Byte offset 0x6f, CSR Addr 0x54037, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr24_b0;		/*
+					 * Byte offset 0x70, CSR Addr 0x54038, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel B, Rank 0}
+					 */
+	uint8_t mr1_b1;			/*
+					 * Byte offset 0x71, CSR Addr 0x54038, Direction=In
+					 * Value to be programmed in DRAM Mode Register 1
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr2_b1;			/*
+					 * Byte offset 0x72, CSR Addr 0x54039, Direction=In
+					 * Value to be programmed in DRAM Mode Register 2
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr3_b1;			/*
+					 * Byte offset 0x73, CSR Addr 0x54039, Direction=In
+					 * Value to be programmed in DRAM Mode Register 3
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr4_b1;			/*
+					 * Byte offset 0x74, CSR Addr 0x5403a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 4
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr11_b1;		/*
+					 * Byte offset 0x75, CSR Addr 0x5403a, Direction=In
+					 * Value to be programmed in DRAM Mode Register 11
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr12_b1;		/*
+					 * Byte offset 0x76, CSR Addr 0x5403b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 12
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr13_b1;		/*
+					 * Byte offset 0x77, CSR Addr 0x5403b, Direction=In
+					 * Value to be programmed in DRAM Mode Register 13
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr14_b1;		/*
+					 * Byte offset 0x78, CSR Addr 0x5403c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 14
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr16_b1;		/*
+					 * Byte offset 0x79, CSR Addr 0x5403c, Direction=In
+					 * Value to be programmed in DRAM Mode Register 16
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr17_b1;		/*
+					 * Byte offset 0x7a, CSR Addr 0x5403d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 17
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr22_b1;		/*
+					 * Byte offset 0x7b, CSR Addr 0x5403d, Direction=In
+					 * Value to be programmed in DRAM Mode Register 22
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t mr24_b1;		/*
+					 * Byte offset 0x7c, CSR Addr 0x5403e, Direction=In
+					 * Value to be programmed in DRAM Mode Register 24
+					 * {Channel B, Rank 1}
+					 */
+	uint8_t caterminatingrankchb;	/* Byte offset 0x7d, CSR Addr 0x5403e, Direction=In
+					 * Terminating Rank for CA bus on Channel B
+					 *   0x0 = Rank 0 is terminating rank
+					 *   0x1 = Rank 1 is terminating rank
+					 */
+	uint8_t reserved7e;		/* Byte offset 0x7e, CSR Addr 0x5403f, Direction=N/A */
+	uint8_t reserved7f;		/* Byte offset 0x7f, CSR Addr 0x5403f, Direction=N/A */
+	uint8_t reserved80;		/* Byte offset 0x80, CSR Addr 0x54040, Direction=N/A */
+	uint8_t reserved81;		/* Byte offset 0x81, CSR Addr 0x54040, Direction=N/A */
+	uint8_t reserved82;		/* Byte offset 0x82, CSR Addr 0x54041, Direction=N/A */
+	uint8_t reserved83;		/* Byte offset 0x83, CSR Addr 0x54041, Direction=N/A */
+	uint8_t reserved84;		/* Byte offset 0x84, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved85;		/* Byte offset 0x85, CSR Addr 0x54042, Direction=N/A */
+	uint8_t reserved86;		/* Byte offset 0x86, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved87;		/* Byte offset 0x87, CSR Addr 0x54043, Direction=N/A */
+	uint8_t reserved88;		/* Byte offset 0x88, CSR Addr 0x54044, Direction=N/A */
+	uint8_t reserved89;		/* Byte offset 0x89, CSR Addr 0x54044, Direction=N/A */
+} __attribute__ ((packed)) __attribute__ ((aligned(2)));
+
+#endif /* MNPMUSRAMMSGBLOCK_LPDDR4_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h
new file mode 100644
index 0000000000..2bbe7d9497
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_csr_all_cdefines.h
@@ -0,0 +1,6945 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_CSR_ALL_DEFINES_H
+#define DDRPHY_PHYINIT_CSR_ALL_DEFINES_H
+
+/* ANIBx register offsets */
+#define CSR_MTESTMUXSEL_ADDR				0x1AU
+#define CSR_AFORCEDRVCONT_ADDR				0x27U
+#define CSR_AFORCETRICONT_ADDR				0x28U
+#define CSR_ATXIMPEDANCE_ADDR				0x43U
+#define CSR_ATESTPRBSERR_ADDR				0x53U
+#define CSR_ATXSLEWRATE_ADDR				0x55U
+#define CSR_ATESTPRBSERRCNT_ADDR			0x56U
+#define CSR_ATXDLY_ADDR					0x80U
+
+/* DBYTEx register offsets */
+#define CSR_DBYTEMISCMODE_ADDR				0x0U
+#define CSR_TSMBYTE0_ADDR				0x1U
+#define CSR_TRAININGPARAM_ADDR				0x2U
+#define CSR_USEDQSENREPLICA_ADDR			0x3U
+#define CSR_RXTRAINPATTERNENABLE_ADDR			0x10U
+#define CSR_TSMBYTE1_ADDR				0x11U
+#define CSR_TSMBYTE2_ADDR				0x12U
+#define CSR_TSMBYTE3_ADDR				0x13U
+#define CSR_TSMBYTE4_ADDR				0x14U
+#define CSR_TESTMODECONFIG_ADDR				0x17U
+#define CSR_TSMBYTE5_ADDR				0x18U
+/* MTESTMUXSEL already defined in ANIBx section */
+#define CSR_DTSMTRAINMODECTRL_ADDR			0x1FU
+#define CSR_DFIMRL_ADDR					0x20U
+#define CSR_ASYNCDBYTEMODE_ADDR				0x24U
+#define CSR_ASYNCDBYTETXEN_ADDR				0x26U
+#define CSR_ASYNCDBYTETXDATA_ADDR			0x28U
+#define CSR_ASYNCDBYTERXDATA_ADDR			0x2AU
+#define CSR_VREFDAC1_ADDR				0x30U
+#define CSR_TRAININGCNTR_ADDR				0x32U
+#define CSR_VREFDAC0_ADDR				0x40U
+#define CSR_TXIMPEDANCECTRL0_ADDR			0x41U
+#define CSR_DQDQSRCVCNTRL_ADDR				0x43U
+#define CSR_TXEQUALIZATIONMODE_ADDR			0x48U
+#define CSR_TXIMPEDANCECTRL1_ADDR			0x49U
+#define CSR_DQDQSRCVCNTRL1_ADDR				0x4AU
+#define CSR_TXIMPEDANCECTRL2_ADDR			0x4BU
+#define CSR_DQDQSRCVCNTRL2_ADDR				0x4CU
+#define CSR_TXODTDRVSTREN_ADDR				0x4DU
+#define CSR_RXFIFOCHECKSTATUS_ADDR			0x56U
+#define CSR_RXFIFOCHECKERRVALUES_ADDR			0x57U
+#define CSR_RXFIFOINFO_ADDR				0x58U
+#define CSR_RXFIFOVISIBILITY_ADDR			0x59U
+#define CSR_RXFIFOCONTENTSDQ3210_ADDR			0x5AU
+#define CSR_RXFIFOCONTENTSDQ7654_ADDR			0x5BU
+#define CSR_RXFIFOCONTENTSDBI_ADDR			0x5CU
+#define CSR_TXSLEWRATE_ADDR				0x5FU
+#define CSR_TRAININGINCDECDTSMEN_ADDR			0x62U
+#define CSR_RXPBDLYTG0_ADDR				0x68U
+#define CSR_RXPBDLYTG1_ADDR				0x69U
+#define CSR_RXPBDLYTG2_ADDR				0x6AU
+#define CSR_RXPBDLYTG3_ADDR				0x6BU
+#define CSR_RXENDLYTG0_ADDR				0x80U
+#define CSR_RXENDLYTG1_ADDR				0x81U
+#define CSR_RXENDLYTG2_ADDR				0x82U
+#define CSR_RXENDLYTG3_ADDR				0x83U
+#define CSR_RXCLKDLYTG0_ADDR				0x8CU
+#define CSR_RXCLKDLYTG1_ADDR				0x8DU
+#define CSR_RXCLKDLYTG2_ADDR				0x8EU
+#define CSR_RXCLKDLYTG3_ADDR				0x8FU
+#define CSR_RXCLKCDLYTG0_ADDR				0x90U
+#define CSR_RXCLKCDLYTG1_ADDR				0x91U
+#define CSR_RXCLKCDLYTG2_ADDR				0x92U
+#define CSR_RXCLKCDLYTG3_ADDR				0x93U
+#define CSR_DQ0LNSEL_ADDR				0xA0U
+#define CSR_DQ1LNSEL_ADDR				0xA1U
+#define CSR_DQ2LNSEL_ADDR				0xA2U
+#define CSR_DQ3LNSEL_ADDR				0xA3U
+#define CSR_DQ4LNSEL_ADDR				0xA4U
+#define CSR_DQ5LNSEL_ADDR				0xA5U
+#define CSR_DQ6LNSEL_ADDR				0xA6U
+#define CSR_DQ7LNSEL_ADDR				0xA7U
+#define CSR_PPTCTLSTATIC_ADDR				0xAAU
+#define CSR_PPTCTLDYN_ADDR				0xABU
+#define CSR_PPTINFO_ADDR				0xACU
+#define CSR_PPTRXENEVNT_ADDR				0xADU
+#define CSR_PPTDQSCNTINVTRNTG0_ADDR			0xAEU
+#define CSR_PPTDQSCNTINVTRNTG1_ADDR			0xAFU
+#define CSR_DTSMBLANKINGCTRL_ADDR			0xB1U
+#define CSR_TSM0_ADDR					0xB2U
+#define CSR_TSM1_ADDR					0xB3U
+#define CSR_TSM2_ADDR					0xB4U
+#define CSR_TSM3_ADDR					0xB5U
+#define CSR_TXCHKDATASELECTS_ADDR			0xB6U
+#define CSR_DTSMUPTHLDXINGIND_ADDR			0xB7U
+#define CSR_DTSMLOTHLDXINGIND_ADDR			0xB8U
+#define CSR_DBYTEALLDTSMCTRL0_ADDR			0xB9U
+#define CSR_DBYTEALLDTSMCTRL1_ADDR			0xBAU
+#define CSR_DBYTEALLDTSMCTRL2_ADDR			0xBBU
+#define CSR_TXDQDLYTG0_ADDR				0xC0U
+#define CSR_TXDQDLYTG1_ADDR				0xC1U
+#define CSR_TXDQDLYTG2_ADDR				0xC2U
+#define CSR_TXDQDLYTG3_ADDR				0xC3U
+#define CSR_TXDQSDLYTG0_ADDR				0xD0U
+#define CSR_TXDQSDLYTG1_ADDR				0xD1U
+#define CSR_TXDQSDLYTG2_ADDR				0xD2U
+#define CSR_TXDQSDLYTG3_ADDR				0xD3U
+#define CSR_DXLCDLSTATUS_ADDR				0xE4U
+
+/* MASTER0 register offsets */
+#define CSR_RXFIFOINIT_ADDR				0x0U
+#define CSR_FORCECLKDISABLE_ADDR			0x1U
+#define CSR_CLOCKINGCTRL_ADDR				0x2U
+#define CSR_FORCEINTERNALUPDATE_ADDR			0x3U
+#define CSR_PHYCONFIG_ADDR				0x4U
+#define CSR_PGCR_ADDR					0x5U
+#define CSR_TESTBUMPCNTRL1_ADDR				0x7U
+#define CSR_CALUCLKINFO_ADDR				0x8U
+#define CSR_TESTBUMPCNTRL_ADDR				0xAU
+#define CSR_SEQ0BDLY0_ADDR				0xBU
+#define CSR_SEQ0BDLY1_ADDR				0xCU
+#define CSR_SEQ0BDLY2_ADDR				0xDU
+#define CSR_SEQ0BDLY3_ADDR				0xEU
+#define CSR_PHYALERTSTATUS_ADDR				0xFU
+#define CSR_PPTTRAINSETUP_ADDR				0x10U
+#define CSR_PPTTRAINSETUP2_ADDR				0x11U
+#define CSR_ATESTMODE_ADDR				0x12U
+#define CSR_TXCALBINP_ADDR				0x14U
+#define CSR_TXCALBINN_ADDR				0x15U
+#define CSR_TXCALPOVR_ADDR				0x16U
+#define CSR_TXCALNOVR_ADDR				0x17U
+#define CSR_DFIMODE_ADDR				0x18U
+#define CSR_TRISTATEMODECA_ADDR				0x19U
+/* MTESTMUXSEL already defined in ANIBx section */
+#define CSR_MTESTPGMINFO_ADDR				0x1BU
+#define CSR_DYNPWRDNUP_ADDR				0x1CU
+#define CSR_PMIENABLE_ADDR				0x1DU
+#define CSR_PHYTID_ADDR					0x1EU
+#define CSR_HWTMRL_ADDR					0x20U
+#define CSR_DFIPHYUPD_ADDR				0x21U
+#define CSR_PDAMRSWRITEMODE_ADDR			0x22U
+#define CSR_DFIGEARDOWNCTL_ADDR				0x23U
+#define CSR_DQSPREAMBLECONTROL_ADDR			0x24U
+#define CSR_MASTERX4CONFIG_ADDR				0x25U
+#define CSR_WRLEVBITS_ADDR				0x26U
+#define CSR_ENABLECSMULTICAST_ADDR			0x27U
+#define CSR_HWTLPCSMULTICAST_ADDR			0x28U
+#define CSR_ACX4ANIBDIS_ADDR				0x2CU
+#define CSR_DMIPINPRESENT_ADDR				0x2DU
+#define CSR_ARDPTRINITVAL_ADDR				0x2EU
+#define CSR_DB0LCDLCALPHDETOUT_ADDR			0x30U
+#define CSR_DB1LCDLCALPHDETOUT_ADDR			0x31U
+#define CSR_DB2LCDLCALPHDETOUT_ADDR			0x32U
+#define CSR_DB3LCDLCALPHDETOUT_ADDR			0x33U
+#define CSR_DB4LCDLCALPHDETOUT_ADDR			0x34U
+#define CSR_DB5LCDLCALPHDETOUT_ADDR			0x35U
+#define CSR_DB6LCDLCALPHDETOUT_ADDR			0x36U
+#define CSR_DB7LCDLCALPHDETOUT_ADDR			0x37U
+#define CSR_DB8LCDLCALPHDETOUT_ADDR			0x38U
+#define CSR_DB9LCDLCALPHDETOUT_ADDR			0x39U
+#define CSR_DBYTEDLLMODECNTRL_ADDR			0x3AU
+#define CSR_DBYTERXENTRAIN_ADDR				0x3BU
+#define CSR_ANLCDLCALPHDETOUT_ADDR			0x3FU
+#define CSR_CALOFFSETS_ADDR				0x45U
+#define CSR_SARINITVALS_ADDR				0x47U
+#define CSR_CALPEXTOVR_ADDR				0x49U
+#define CSR_CALCMPR5OVR_ADDR				0x4AU
+#define CSR_CALNINTOVR_ADDR				0x4BU
+#define CSR_CALDRVSTR0_ADDR				0x50U
+#define CSR_PROCODTCTL_ADDR				0x55U
+#define CSR_PROCODTTIMECTL_ADDR				0x56U
+#define CSR_MEMALERTCONTROL_ADDR			0x5BU
+#define CSR_MEMALERTCONTROL2_ADDR			0x5CU
+#define CSR_MEMRESETL_ADDR				0x60U
+#define CSR_PUBMODE_ADDR				0x6EU
+#define CSR_MISCPHYSTATUS_ADDR				0x6FU
+#define CSR_CORELOOPBACKSEL_ADDR			0x70U
+#define CSR_DLLTRAINPARAM_ADDR				0x71U
+#define CSR_HWTLPCSENA_ADDR				0x72U
+#define CSR_HWTLPCSENB_ADDR				0x73U
+#define CSR_HWTLPCSENBYPASS_ADDR			0x74U
+#define CSR_DFICAMODE_ADDR				0x75U
+#define CSR_HWTCACTL_ADDR				0x76U
+#define CSR_HWTCAMODE_ADDR				0x77U
+#define CSR_DLLCONTROL_ADDR				0x78U
+#define CSR_PULSEDLLUPDATEPHASE_ADDR			0x79U
+#define CSR_HWTCONTROLOVR0_ADDR				0x7AU
+#define CSR_HWTCONTROLOVR1_ADDR				0x7BU
+#define CSR_DLLGAINCTL_ADDR				0x7CU
+#define CSR_DLLLOCKPARAM_ADDR				0x7DU
+#define CSR_HWTCONTROLVAL0_ADDR				0x7EU
+#define CSR_HWTCONTROLVAL1_ADDR				0x7FU
+#define CSR_ACSMGLBLSTART_ADDR				0x81U
+#define CSR_ACSMGLBLSGLSTPCTRL_ADDR			0x82U
+#define CSR_LCDLCALPHASE_ADDR				0x84U
+#define CSR_LCDLCALCTRL_ADDR				0x85U
+#define CSR_CALRATE_ADDR				0x88U
+#define CSR_CALZAP_ADDR					0x89U
+#define CSR_PSTATE_ADDR					0x8BU
+#define CSR_CALPREDRIVEROVERRIDE_ADDR			0x8CU
+#define CSR_PLLOUTGATECONTROL_ADDR			0x8DU
+#define CSR_UCMEMRESETCONTROL_ADDR			0x8FU
+#define CSR_PORCONTROL_ADDR				0x90U
+#define CSR_CALBUSY_ADDR				0x97U
+#define CSR_CALMISC2_ADDR				0x98U
+#define CSR_CALMISC_ADDR				0x9AU
+#define CSR_CALVREFS_ADDR				0x9BU
+#define CSR_CALCMPR5_ADDR				0x9CU
+#define CSR_CALNINT_ADDR				0x9DU
+#define CSR_CALPEXT_ADDR				0x9EU
+#define CSR_CALCMPINVERT_ADDR				0xA8U
+#define CSR_CALCMPANACNTRL_ADDR				0xAEU
+#define CSR_DFIRDDATACSDESTMAP_ADDR			0xB0U
+#define CSR_VREFINGLOBAL_ADDR				0xB2U
+#define CSR_DFIWRDATACSDESTMAP_ADDR			0xB4U
+#define CSR_MASUPDGOODCTR_ADDR				0xB5U
+#define CSR_PHYUPD0GOODCTR_ADDR				0xB6U
+#define CSR_PHYUPD1GOODCTR_ADDR				0xB7U
+#define CSR_CTLUPD0GOODCTR_ADDR				0xB8U
+#define CSR_CTLUPD1GOODCTR_ADDR				0xB9U
+#define CSR_MASUPDFAILCTR_ADDR				0xBAU
+#define CSR_PHYUPD0FAILCTR_ADDR				0xBBU
+#define CSR_PHYUPD1FAILCTR_ADDR				0xBCU
+#define CSR_PHYPERFCTRENABLE_ADDR			0xBDU
+#define CSR_DFIWRRDDATACSCONFIG_ADDR			0xBEU
+#define CSR_PLLPWRDN_ADDR				0xC3U
+#define CSR_PLLRESET_ADDR				0xC4U
+#define CSR_PLLCTRL2_ADDR				0xC5U
+#define CSR_PLLCTRL0_ADDR				0xC6U
+#define CSR_PLLCTRL1_ADDR				0xC7U
+#define CSR_PLLTST_ADDR					0xC8U
+#define CSR_PLLLOCKSTATUS_ADDR				0xC9U
+#define CSR_PLLTESTMODE_ADDR				0xCAU
+#define CSR_PLLCTRL3_ADDR				0xCBU
+#define CSR_PLLCTRL4_ADDR				0xCCU
+#define CSR_PLLENDOFCAL_ADDR				0xCDU
+#define CSR_PLLSTANDBYEFF_ADDR				0xCEU
+#define CSR_PLLDACVALOUT_ADDR				0xCFU
+#define CSR_DLYTESTSEQ_ADDR				0xD0U
+#define CSR_DLYTESTRINGSELDB_ADDR			0xD1U
+#define CSR_DLYTESTRINGSELAC_ADDR			0xD2U
+#define CSR_DLYTESTCNTDFICLKIV_ADDR			0xD3U
+#define CSR_DLYTESTCNTDFICLK_ADDR			0xD4U
+#define CSR_DLYTESTCNTRINGOSCDB0_ADDR			0xD5U
+#define CSR_DLYTESTCNTRINGOSCDB1_ADDR			0xD6U
+#define CSR_DLYTESTCNTRINGOSCDB2_ADDR			0xD7U
+#define CSR_DLYTESTCNTRINGOSCDB3_ADDR			0xD8U
+#define CSR_DLYTESTCNTRINGOSCDB4_ADDR			0xD9U
+#define CSR_DLYTESTCNTRINGOSCDB5_ADDR			0xDAU
+#define CSR_DLYTESTCNTRINGOSCDB6_ADDR			0xDBU
+#define CSR_DLYTESTCNTRINGOSCDB7_ADDR			0xDCU
+#define CSR_DLYTESTCNTRINGOSCDB8_ADDR			0xDDU
+#define CSR_DLYTESTCNTRINGOSCDB9_ADDR			0xDEU
+#define CSR_DLYTESTCNTRINGOSCAC_ADDR			0xDFU
+#define CSR_MSTLCDLDBGCNTL_ADDR				0xE0U
+#define CSR_MSTLCDL0DBGRES_ADDR				0xE1U
+#define CSR_MSTLCDL1DBGRES_ADDR				0xE2U
+#define CSR_LCDLDBGCNTL_ADDR				0xE3U
+#define CSR_ACLCDLSTATUS_ADDR				0xE4U
+#define CSR_CUSTPHYREV_ADDR				0xEDU
+#define CSR_PHYREV_ADDR					0xEEU
+#define CSR_LP3EXITSEQ0BSTARTVECTOR_ADDR		0xEFU
+#define CSR_DFIFREQXLAT0_ADDR				0xF0U
+#define CSR_DFIFREQXLAT1_ADDR				0xF1U
+#define CSR_DFIFREQXLAT2_ADDR				0xF2U
+#define CSR_DFIFREQXLAT3_ADDR				0xF3U
+#define CSR_DFIFREQXLAT4_ADDR				0xF4U
+#define CSR_DFIFREQXLAT5_ADDR				0xF5U
+#define CSR_DFIFREQXLAT6_ADDR				0xF6U
+#define CSR_DFIFREQXLAT7_ADDR				0xF7U
+#define CSR_TXRDPTRINIT_ADDR				0xF8U
+#define CSR_DFIINITCOMPLETE_ADDR			0xF9U
+#define CSR_DFIFREQRATIO_ADDR				0xFAU
+#define CSR_RXFIFOCHECKS_ADDR				0xFBU
+#define CSR_MTESTDTOCTRL_ADDR				0xFFU
+#define CSR_MAPCAA0TODFI_ADDR				0x100U
+#define CSR_MAPCAA1TODFI_ADDR				0x101U
+#define CSR_MAPCAA2TODFI_ADDR				0x102U
+#define CSR_MAPCAA3TODFI_ADDR				0x103U
+#define CSR_MAPCAA4TODFI_ADDR				0x104U
+#define CSR_MAPCAA5TODFI_ADDR				0x105U
+#define CSR_MAPCAA6TODFI_ADDR				0x106U
+#define CSR_MAPCAA7TODFI_ADDR				0x107U
+#define CSR_MAPCAA8TODFI_ADDR				0x108U
+#define CSR_MAPCAA9TODFI_ADDR				0x109U
+#define CSR_MAPCAB0TODFI_ADDR				0x110U
+#define CSR_MAPCAB1TODFI_ADDR				0x111U
+#define CSR_MAPCAB2TODFI_ADDR				0x112U
+#define CSR_MAPCAB3TODFI_ADDR				0x113U
+#define CSR_MAPCAB4TODFI_ADDR				0x114U
+#define CSR_MAPCAB5TODFI_ADDR				0x115U
+#define CSR_MAPCAB6TODFI_ADDR				0x116U
+#define CSR_MAPCAB7TODFI_ADDR				0x117U
+#define CSR_MAPCAB8TODFI_ADDR				0x118U
+#define CSR_MAPCAB9TODFI_ADDR				0x119U
+#define CSR_PHYINTERRUPTENABLE_ADDR			0x11BU
+#define CSR_PHYINTERRUPTFWCONTROL_ADDR			0x11CU
+#define CSR_PHYINTERRUPTMASK_ADDR			0x11DU
+#define CSR_PHYINTERRUPTCLEAR_ADDR			0x11EU
+#define CSR_PHYINTERRUPTSTATUS_ADDR			0x11FU
+#define CSR_HWTSWIZZLEHWTADDRESS0_ADDR			0x120U
+#define CSR_HWTSWIZZLEHWTADDRESS1_ADDR			0x121U
+#define CSR_HWTSWIZZLEHWTADDRESS2_ADDR			0x122U
+#define CSR_HWTSWIZZLEHWTADDRESS3_ADDR			0x123U
+#define CSR_HWTSWIZZLEHWTADDRESS4_ADDR			0x124U
+#define CSR_HWTSWIZZLEHWTADDRESS5_ADDR			0x125U
+#define CSR_HWTSWIZZLEHWTADDRESS6_ADDR			0x126U
+#define CSR_HWTSWIZZLEHWTADDRESS7_ADDR			0x127U
+#define CSR_HWTSWIZZLEHWTADDRESS8_ADDR			0x128U
+#define CSR_HWTSWIZZLEHWTADDRESS9_ADDR			0x129U
+#define CSR_HWTSWIZZLEHWTADDRESS10_ADDR			0x12AU
+#define CSR_HWTSWIZZLEHWTADDRESS11_ADDR			0x12BU
+#define CSR_HWTSWIZZLEHWTADDRESS12_ADDR			0x12CU
+#define CSR_HWTSWIZZLEHWTADDRESS13_ADDR			0x12DU
+#define CSR_HWTSWIZZLEHWTADDRESS14_ADDR			0x12EU
+#define CSR_HWTSWIZZLEHWTADDRESS15_ADDR			0x12FU
+#define CSR_HWTSWIZZLEHWTADDRESS17_ADDR			0x130U
+#define CSR_HWTSWIZZLEHWTACTN_ADDR			0x131U
+#define CSR_HWTSWIZZLEHWTBANK0_ADDR			0x132U
+#define CSR_HWTSWIZZLEHWTBANK1_ADDR			0x133U
+#define CSR_HWTSWIZZLEHWTBANK2_ADDR			0x134U
+#define CSR_HWTSWIZZLEHWTBG0_ADDR			0x135U
+#define CSR_HWTSWIZZLEHWTBG1_ADDR			0x136U
+#define CSR_HWTSWIZZLEHWTCASN_ADDR			0x137U
+#define CSR_HWTSWIZZLEHWTRASN_ADDR			0x138U
+#define CSR_HWTSWIZZLEHWTWEN_ADDR			0x139U
+#define CSR_HWTSWIZZLEHWTPARITYIN_ADDR			0x13AU
+#define CSR_DFIHANDSHAKEDELAYS0_ADDR			0x13CU
+#define CSR_DFIHANDSHAKEDELAYS1_ADDR			0x13DU
+#define CSR_REMOTEIMPCAL_ADDR				0x13EU
+#define CSR_ACLOOPBACKCTL_ADDR				0x13FU
+
+/* ACSM0 register offsets */
+#define CSR_ACSMSEQ0X0_ADDR				0x0U
+#define CSR_ACSMSEQ0X1_ADDR				0x1U
+#define CSR_ACSMSEQ0X2_ADDR				0x2U
+#define CSR_ACSMSEQ0X3_ADDR				0x3U
+#define CSR_ACSMSEQ0X4_ADDR				0x4U
+#define CSR_ACSMSEQ0X5_ADDR				0x5U
+#define CSR_ACSMSEQ0X6_ADDR				0x6U
+#define CSR_ACSMSEQ0X7_ADDR				0x7U
+#define CSR_ACSMSEQ0X8_ADDR				0x8U
+#define CSR_ACSMSEQ0X9_ADDR				0x9U
+#define CSR_ACSMSEQ0X10_ADDR				0xAU
+#define CSR_ACSMSEQ0X11_ADDR				0xBU
+#define CSR_ACSMSEQ0X12_ADDR				0xCU
+#define CSR_ACSMSEQ0X13_ADDR				0xDU
+#define CSR_ACSMSEQ0X14_ADDR				0xEU
+#define CSR_ACSMSEQ0X15_ADDR				0xFU
+#define CSR_ACSMSEQ0X16_ADDR				0x10U
+#define CSR_ACSMSEQ0X17_ADDR				0x11U
+#define CSR_ACSMSEQ0X18_ADDR				0x12U
+#define CSR_ACSMSEQ0X19_ADDR				0x13U
+#define CSR_ACSMSEQ0X20_ADDR				0x14U
+#define CSR_ACSMSEQ0X21_ADDR				0x15U
+#define CSR_ACSMSEQ0X22_ADDR				0x16U
+#define CSR_ACSMSEQ0X23_ADDR				0x17U
+#define CSR_ACSMSEQ0X24_ADDR				0x18U
+#define CSR_ACSMSEQ0X25_ADDR				0x19U
+#define CSR_ACSMSEQ0X26_ADDR				0x1AU
+#define CSR_ACSMSEQ0X27_ADDR				0x1BU
+#define CSR_ACSMSEQ0X28_ADDR				0x1CU
+#define CSR_ACSMSEQ0X29_ADDR				0x1DU
+#define CSR_ACSMSEQ0X30_ADDR				0x1EU
+#define CSR_ACSMSEQ0X31_ADDR				0x1FU
+#define CSR_ACSMSEQ1X0_ADDR				0x20U
+#define CSR_ACSMSEQ1X1_ADDR				0x21U
+#define CSR_ACSMSEQ1X2_ADDR				0x22U
+#define CSR_ACSMSEQ1X3_ADDR				0x23U
+#define CSR_ACSMSEQ1X4_ADDR				0x24U
+#define CSR_ACSMSEQ1X5_ADDR				0x25U
+#define CSR_ACSMSEQ1X6_ADDR				0x26U
+#define CSR_ACSMSEQ1X7_ADDR				0x27U
+#define CSR_ACSMSEQ1X8_ADDR				0x28U
+#define CSR_ACSMSEQ1X9_ADDR				0x29U
+#define CSR_ACSMSEQ1X10_ADDR				0x2AU
+#define CSR_ACSMSEQ1X11_ADDR				0x2BU
+#define CSR_ACSMSEQ1X12_ADDR				0x2CU
+#define CSR_ACSMSEQ1X13_ADDR				0x2DU
+#define CSR_ACSMSEQ1X14_ADDR				0x2EU
+#define CSR_ACSMSEQ1X15_ADDR				0x2FU
+#define CSR_ACSMSEQ1X16_ADDR				0x30U
+#define CSR_ACSMSEQ1X17_ADDR				0x31U
+#define CSR_ACSMSEQ1X18_ADDR				0x32U
+#define CSR_ACSMSEQ1X19_ADDR				0x33U
+#define CSR_ACSMSEQ1X20_ADDR				0x34U
+#define CSR_ACSMSEQ1X21_ADDR				0x35U
+#define CSR_ACSMSEQ1X22_ADDR				0x36U
+#define CSR_ACSMSEQ1X23_ADDR				0x37U
+#define CSR_ACSMSEQ1X24_ADDR				0x38U
+#define CSR_ACSMSEQ1X25_ADDR				0x39U
+#define CSR_ACSMSEQ1X26_ADDR				0x3AU
+#define CSR_ACSMSEQ1X27_ADDR				0x3BU
+#define CSR_ACSMSEQ1X28_ADDR				0x3CU
+#define CSR_ACSMSEQ1X29_ADDR				0x3DU
+#define CSR_ACSMSEQ1X30_ADDR				0x3EU
+#define CSR_ACSMSEQ1X31_ADDR				0x3FU
+#define CSR_ACSMSEQ2X0_ADDR				0x40U
+#define CSR_ACSMSEQ2X1_ADDR				0x41U
+#define CSR_ACSMSEQ2X2_ADDR				0x42U
+#define CSR_ACSMSEQ2X3_ADDR				0x43U
+#define CSR_ACSMSEQ2X4_ADDR				0x44U
+#define CSR_ACSMSEQ2X5_ADDR				0x45U
+#define CSR_ACSMSEQ2X6_ADDR				0x46U
+#define CSR_ACSMSEQ2X7_ADDR				0x47U
+#define CSR_ACSMSEQ2X8_ADDR				0x48U
+#define CSR_ACSMSEQ2X9_ADDR				0x49U
+#define CSR_ACSMSEQ2X10_ADDR				0x4AU
+#define CSR_ACSMSEQ2X11_ADDR				0x4BU
+#define CSR_ACSMSEQ2X12_ADDR				0x4CU
+#define CSR_ACSMSEQ2X13_ADDR				0x4DU
+#define CSR_ACSMSEQ2X14_ADDR				0x4EU
+#define CSR_ACSMSEQ2X15_ADDR				0x4FU
+#define CSR_ACSMSEQ2X16_ADDR				0x50U
+#define CSR_ACSMSEQ2X17_ADDR				0x51U
+#define CSR_ACSMSEQ2X18_ADDR				0x52U
+#define CSR_ACSMSEQ2X19_ADDR				0x53U
+#define CSR_ACSMSEQ2X20_ADDR				0x54U
+#define CSR_ACSMSEQ2X21_ADDR				0x55U
+#define CSR_ACSMSEQ2X22_ADDR				0x56U
+#define CSR_ACSMSEQ2X23_ADDR				0x57U
+#define CSR_ACSMSEQ2X24_ADDR				0x58U
+#define CSR_ACSMSEQ2X25_ADDR				0x59U
+#define CSR_ACSMSEQ2X26_ADDR				0x5AU
+#define CSR_ACSMSEQ2X27_ADDR				0x5BU
+#define CSR_ACSMSEQ2X28_ADDR				0x5CU
+#define CSR_ACSMSEQ2X29_ADDR				0x5DU
+#define CSR_ACSMSEQ2X30_ADDR				0x5EU
+#define CSR_ACSMSEQ2X31_ADDR				0x5FU
+#define CSR_ACSMSEQ3X0_ADDR				0x60U
+#define CSR_ACSMSEQ3X1_ADDR				0x61U
+#define CSR_ACSMSEQ3X2_ADDR				0x62U
+#define CSR_ACSMSEQ3X3_ADDR				0x63U
+#define CSR_ACSMSEQ3X4_ADDR				0x64U
+#define CSR_ACSMSEQ3X5_ADDR				0x65U
+#define CSR_ACSMSEQ3X6_ADDR				0x66U
+#define CSR_ACSMSEQ3X7_ADDR				0x67U
+#define CSR_ACSMSEQ3X8_ADDR				0x68U
+#define CSR_ACSMSEQ3X9_ADDR				0x69U
+#define CSR_ACSMSEQ3X10_ADDR				0x6AU
+#define CSR_ACSMSEQ3X11_ADDR				0x6BU
+#define CSR_ACSMSEQ3X12_ADDR				0x6CU
+#define CSR_ACSMSEQ3X13_ADDR				0x6DU
+#define CSR_ACSMSEQ3X14_ADDR				0x6EU
+#define CSR_ACSMSEQ3X15_ADDR				0x6FU
+#define CSR_ACSMSEQ3X16_ADDR				0x70U
+#define CSR_ACSMSEQ3X17_ADDR				0x71U
+#define CSR_ACSMSEQ3X18_ADDR				0x72U
+#define CSR_ACSMSEQ3X19_ADDR				0x73U
+#define CSR_ACSMSEQ3X20_ADDR				0x74U
+#define CSR_ACSMSEQ3X21_ADDR				0x75U
+#define CSR_ACSMSEQ3X22_ADDR				0x76U
+#define CSR_ACSMSEQ3X23_ADDR				0x77U
+#define CSR_ACSMSEQ3X24_ADDR				0x78U
+#define CSR_ACSMSEQ3X25_ADDR				0x79U
+#define CSR_ACSMSEQ3X26_ADDR				0x7AU
+#define CSR_ACSMSEQ3X27_ADDR				0x7BU
+#define CSR_ACSMSEQ3X28_ADDR				0x7CU
+#define CSR_ACSMSEQ3X29_ADDR				0x7DU
+#define CSR_ACSMSEQ3X30_ADDR				0x7EU
+#define CSR_ACSMSEQ3X31_ADDR				0x7FU
+#define CSR_ACSMPLAYBACK0X0_ADDR			0x80U
+#define CSR_ACSMPLAYBACK1X0_ADDR			0x81U
+#define CSR_ACSMPLAYBACK0X1_ADDR			0x82U
+#define CSR_ACSMPLAYBACK1X1_ADDR			0x83U
+#define CSR_ACSMPLAYBACK0X2_ADDR			0x84U
+#define CSR_ACSMPLAYBACK1X2_ADDR			0x85U
+#define CSR_ACSMPLAYBACK0X3_ADDR			0x86U
+#define CSR_ACSMPLAYBACK1X3_ADDR			0x87U
+#define CSR_ACSMPLAYBACK0X4_ADDR			0x88U
+#define CSR_ACSMPLAYBACK1X4_ADDR			0x89U
+#define CSR_ACSMPLAYBACK0X5_ADDR			0x8AU
+#define CSR_ACSMPLAYBACK1X5_ADDR			0x8BU
+#define CSR_ACSMPLAYBACK0X6_ADDR			0x8CU
+#define CSR_ACSMPLAYBACK1X6_ADDR			0x8DU
+#define CSR_ACSMPLAYBACK0X7_ADDR			0x8EU
+#define CSR_ACSMPLAYBACK1X7_ADDR			0x8FU
+#define CSR_ACSMPSTATEOVREN_ADDR			0x90U
+#define CSR_ACSMPSTATEOVRVAL_ADDR			0x91U
+#define CSR_ACSMCTRL23_ADDR				0xC0U
+#define CSR_ACSMCKEVAL_ADDR				0xC2U
+#define CSR_LOWSPEEDCLOCKDIVIDER_ADDR			0xC8U
+#define CSR_ACSMCSMAPCTRL0_ADDR				0xD0U
+#define CSR_ACSMCSMAPCTRL1_ADDR				0xD1U
+#define CSR_ACSMCSMAPCTRL2_ADDR				0xD2U
+#define CSR_ACSMCSMAPCTRL3_ADDR				0xD3U
+#define CSR_ACSMCSMAPCTRL4_ADDR				0xD4U
+#define CSR_ACSMCSMAPCTRL5_ADDR				0xD5U
+#define CSR_ACSMCSMAPCTRL6_ADDR				0xD6U
+#define CSR_ACSMCSMAPCTRL7_ADDR				0xD7U
+#define CSR_ACSMCSMAPCTRL8_ADDR				0xD8U
+#define CSR_ACSMCSMAPCTRL9_ADDR				0xD9U
+#define CSR_ACSMCSMAPCTRL10_ADDR			0xDAU
+#define CSR_ACSMCSMAPCTRL11_ADDR			0xDBU
+#define CSR_ACSMCSMAPCTRL12_ADDR			0xDCU
+#define CSR_ACSMCSMAPCTRL13_ADDR			0xDDU
+#define CSR_ACSMCSMAPCTRL14_ADDR			0xDEU
+#define CSR_ACSMCSMAPCTRL15_ADDR			0xDFU
+#define CSR_ACSMODTCTRL0_ADDR				0xE0U
+#define CSR_ACSMODTCTRL1_ADDR				0xE1U
+#define CSR_ACSMODTCTRL2_ADDR				0xE2U
+#define CSR_ACSMODTCTRL3_ADDR				0xE3U
+#define CSR_ACSMODTCTRL4_ADDR				0xE4U
+#define CSR_ACSMODTCTRL5_ADDR				0xE5U
+#define CSR_ACSMODTCTRL6_ADDR				0xE6U
+#define CSR_ACSMODTCTRL7_ADDR				0xE7U
+#define CSR_ACSMODTCTRL8_ADDR				0xE8U
+#define CSR_ACSMCTRL16_ADDR				0xE9U
+#define CSR_LOWSPEEDCLOCKSTOPVAL_ADDR			0xEAU
+#define CSR_ACSMCTRL18_ADDR				0xEBU
+#define CSR_ACSMCTRL19_ADDR				0xECU
+#define CSR_ACSMCTRL20_ADDR				0xEDU
+#define CSR_ACSMCTRL21_ADDR				0xEEU
+#define CSR_ACSMCTRL22_ADDR				0xEFU
+#define CSR_ACSMCTRL0_ADDR				0xF0U
+#define CSR_ACSMCTRL1_ADDR				0xF1U
+#define CSR_ACSMCTRL2_ADDR				0xF2U
+#define CSR_ACSMCTRL3_ADDR				0xF3U
+#define CSR_ACSMCTRL4_ADDR				0xF4U
+#define CSR_ACSMCTRL5_ADDR				0xF5U
+#define CSR_ACSMCTRL6_ADDR				0xF6U
+#define CSR_ACSMCTRL7_ADDR				0xF7U
+#define CSR_ACSMCTRL8_ADDR				0xF8U
+#define CSR_ACSMCTRL9_ADDR				0xF9U
+#define CSR_ACSMCTRL10_ADDR				0xFAU
+#define CSR_ACSMCTRL11_ADDR				0xFBU
+#define CSR_ACSMCTRL12_ADDR				0xFCU
+#define CSR_ACSMCTRL13_ADDR				0xFDU
+#define CSR_ACSMCTRL14_ADDR				0xFEU
+#define CSR_ACSMCTRL15_ADDR				0xFFU
+
+/* PPGC0 register offsets */
+#define CSR_PPGCCTRL1_ADDR				0x11U
+#define CSR_PPGCLANE2CRCINMAP0_ADDR			0x15U
+#define CSR_PPGCLANE2CRCINMAP1_ADDR			0x16U
+#define CSR_PRBSTAPDLY0_ADDR				0x24U
+#define CSR_PRBSTAPDLY1_ADDR				0x25U
+#define CSR_PRBSTAPDLY2_ADDR				0x26U
+#define CSR_PRBSTAPDLY3_ADDR				0x27U
+#define CSR_GENPRBSBYTE0_ADDR				0x30U
+#define CSR_GENPRBSBYTE1_ADDR				0x31U
+#define CSR_GENPRBSBYTE2_ADDR				0x32U
+#define CSR_GENPRBSBYTE3_ADDR				0x33U
+#define CSR_GENPRBSBYTE4_ADDR				0x34U
+#define CSR_GENPRBSBYTE5_ADDR				0x35U
+#define CSR_GENPRBSBYTE6_ADDR				0x36U
+#define CSR_GENPRBSBYTE7_ADDR				0x37U
+#define CSR_GENPRBSBYTE8_ADDR				0x38U
+#define CSR_GENPRBSBYTE9_ADDR				0x39U
+#define CSR_GENPRBSBYTE10_ADDR				0x3AU
+#define CSR_GENPRBSBYTE11_ADDR				0x3BU
+#define CSR_GENPRBSBYTE12_ADDR				0x3CU
+#define CSR_GENPRBSBYTE13_ADDR				0x3DU
+#define CSR_GENPRBSBYTE14_ADDR				0x3EU
+#define CSR_GENPRBSBYTE15_ADDR				0x3FU
+#define CSR_PRBSGENCTL_ADDR				0x60U
+#define CSR_PRBSGENSTATELO_ADDR				0x61U
+#define CSR_PRBSGENSTATEHI_ADDR				0x62U
+#define CSR_PRBSCHKSTATELO_ADDR				0x63U
+#define CSR_PRBSCHKSTATEHI_ADDR				0x64U
+#define CSR_PRBSGENCTL1_ADDR				0x65U
+#define CSR_PRBSGENCTL2_ADDR				0x66U
+
+/* INITENG0 register offsets */
+#define CSR_PRESEQUENCEREG0B0S0_ADDR			0x0U
+#define CSR_PRESEQUENCEREG0B0S1_ADDR			0x1U
+#define CSR_PRESEQUENCEREG0B0S2_ADDR			0x2U
+#define CSR_PRESEQUENCEREG0B1S0_ADDR			0x3U
+#define CSR_PRESEQUENCEREG0B1S1_ADDR			0x4U
+#define CSR_PRESEQUENCEREG0B1S2_ADDR			0x5U
+#define CSR_POSTSEQUENCEREG0B0S0_ADDR			0x6U
+#define CSR_POSTSEQUENCEREG0B0S1_ADDR			0x7U
+#define CSR_POSTSEQUENCEREG0B0S2_ADDR			0x8U
+#define CSR_POSTSEQUENCEREG0B1S0_ADDR			0x9U
+#define CSR_POSTSEQUENCEREG0B1S1_ADDR			0xAU
+#define CSR_POSTSEQUENCEREG0B1S2_ADDR			0xBU
+#define CSR_SEQ0BDISABLEFLAG0_ADDR			0xCU
+#define CSR_SEQ0BDISABLEFLAG1_ADDR			0xDU
+#define CSR_SEQ0BDISABLEFLAG2_ADDR			0xEU
+#define CSR_SEQ0BDISABLEFLAG3_ADDR			0xFU
+#define CSR_SEQ0BDISABLEFLAG4_ADDR			0x10U
+#define CSR_SEQ0BDISABLEFLAG5_ADDR			0x11U
+#define CSR_SEQ0BDISABLEFLAG6_ADDR			0x12U
+#define CSR_SEQ0BDISABLEFLAG7_ADDR			0x13U
+#define CSR_STARTVECTOR0B0_ADDR				0x17U
+#define CSR_STARTVECTOR0B1_ADDR				0x18U
+#define CSR_STARTVECTOR0B2_ADDR				0x19U
+#define CSR_STARTVECTOR0B3_ADDR				0x1AU
+#define CSR_STARTVECTOR0B4_ADDR				0x1BU
+#define CSR_STARTVECTOR0B5_ADDR				0x1CU
+#define CSR_STARTVECTOR0B6_ADDR				0x1DU
+#define CSR_STARTVECTOR0B7_ADDR				0x1EU
+#define CSR_STARTVECTOR0B8_ADDR				0x1FU
+#define CSR_STARTVECTOR0B9_ADDR				0x20U
+#define CSR_STARTVECTOR0B10_ADDR			0x21U
+#define CSR_STARTVECTOR0B11_ADDR			0x22U
+#define CSR_STARTVECTOR0B12_ADDR			0x23U
+#define CSR_STARTVECTOR0B13_ADDR			0x24U
+#define CSR_STARTVECTOR0B14_ADDR			0x25U
+#define CSR_STARTVECTOR0B15_ADDR			0x26U
+#define CSR_SEQ0BWAITCONDSEL_ADDR			0x27U
+#define CSR_PHYINLP3_ADDR				0x28U
+#define CSR_SEQUENCEREG0B0S0_ADDR			0x29U
+#define CSR_SEQUENCEREG0B0S1_ADDR			0x2AU
+#define CSR_SEQUENCEREG0B0S2_ADDR			0x2BU
+#define CSR_SEQUENCEREG0B1S0_ADDR			0x2CU
+#define CSR_SEQUENCEREG0B1S1_ADDR			0x2DU
+#define CSR_SEQUENCEREG0B1S2_ADDR			0x2EU
+#define CSR_SEQUENCEREG0B2S0_ADDR			0x2FU
+#define CSR_SEQUENCEREG0B2S1_ADDR			0x30U
+#define CSR_SEQUENCEREG0B2S2_ADDR			0x31U
+#define CSR_SEQUENCEREG0B3S0_ADDR			0x32U
+#define CSR_SEQUENCEREG0B3S1_ADDR			0x33U
+#define CSR_SEQUENCEREG0B3S2_ADDR			0x34U
+#define CSR_SEQUENCEREG0B4S0_ADDR			0x35U
+#define CSR_SEQUENCEREG0B4S1_ADDR			0x36U
+#define CSR_SEQUENCEREG0B4S2_ADDR			0x37U
+#define CSR_SEQUENCEREG0B5S0_ADDR			0x38U
+#define CSR_SEQUENCEREG0B5S1_ADDR			0x39U
+#define CSR_SEQUENCEREG0B5S2_ADDR			0x3AU
+#define CSR_SEQUENCEREG0B6S0_ADDR			0x3BU
+#define CSR_SEQUENCEREG0B6S1_ADDR			0x3CU
+#define CSR_SEQUENCEREG0B6S2_ADDR			0x3DU
+#define CSR_SEQUENCEREG0B7S0_ADDR			0x3EU
+#define CSR_SEQUENCEREG0B7S1_ADDR			0x3FU
+#define CSR_SEQUENCEREG0B7S2_ADDR			0x40U
+#define CSR_SEQUENCEREG0B8S0_ADDR			0x41U
+#define CSR_SEQUENCEREG0B8S1_ADDR			0x42U
+#define CSR_SEQUENCEREG0B8S2_ADDR			0x43U
+#define CSR_SEQUENCEREG0B9S0_ADDR			0x44U
+#define CSR_SEQUENCEREG0B9S1_ADDR			0x45U
+#define CSR_SEQUENCEREG0B9S2_ADDR			0x46U
+#define CSR_SEQUENCEREG0B10S0_ADDR			0x47U
+#define CSR_SEQUENCEREG0B10S1_ADDR			0x48U
+#define CSR_SEQUENCEREG0B10S2_ADDR			0x49U
+#define CSR_SEQUENCEREG0B11S0_ADDR			0x4AU
+#define CSR_SEQUENCEREG0B11S1_ADDR			0x4BU
+#define CSR_SEQUENCEREG0B11S2_ADDR			0x4CU
+#define CSR_SEQUENCEREG0B12S0_ADDR			0x4DU
+#define CSR_SEQUENCEREG0B12S1_ADDR			0x4EU
+#define CSR_SEQUENCEREG0B12S2_ADDR			0x4FU
+#define CSR_SEQUENCEREG0B13S0_ADDR			0x50U
+#define CSR_SEQUENCEREG0B13S1_ADDR			0x51U
+#define CSR_SEQUENCEREG0B13S2_ADDR			0x52U
+#define CSR_SEQUENCEREG0B14S0_ADDR			0x53U
+#define CSR_SEQUENCEREG0B14S1_ADDR			0x54U
+#define CSR_SEQUENCEREG0B14S2_ADDR			0x55U
+#define CSR_SEQUENCEREG0B15S0_ADDR			0x56U
+#define CSR_SEQUENCEREG0B15S1_ADDR			0x57U
+#define CSR_SEQUENCEREG0B15S2_ADDR			0x58U
+#define CSR_SEQUENCEREG0B16S0_ADDR			0x59U
+#define CSR_SEQUENCEREG0B16S1_ADDR			0x5AU
+#define CSR_SEQUENCEREG0B16S2_ADDR			0x5BU
+#define CSR_SEQUENCEREG0B17S0_ADDR			0x5CU
+#define CSR_SEQUENCEREG0B17S1_ADDR			0x5DU
+#define CSR_SEQUENCEREG0B17S2_ADDR			0x5EU
+#define CSR_SEQUENCEREG0B18S0_ADDR			0x5FU
+#define CSR_SEQUENCEREG0B18S1_ADDR			0x60U
+#define CSR_SEQUENCEREG0B18S2_ADDR			0x61U
+#define CSR_SEQUENCEREG0B19S0_ADDR			0x62U
+#define CSR_SEQUENCEREG0B19S1_ADDR			0x63U
+#define CSR_SEQUENCEREG0B19S2_ADDR			0x64U
+#define CSR_SEQUENCEREG0B20S0_ADDR			0x65U
+#define CSR_SEQUENCEREG0B20S1_ADDR			0x66U
+#define CSR_SEQUENCEREG0B20S2_ADDR			0x67U
+#define CSR_SEQUENCEREG0B21S0_ADDR			0x68U
+#define CSR_SEQUENCEREG0B21S1_ADDR			0x69U
+#define CSR_SEQUENCEREG0B21S2_ADDR			0x6AU
+#define CSR_SEQUENCEREG0B22S0_ADDR			0x6BU
+#define CSR_SEQUENCEREG0B22S1_ADDR			0x6CU
+#define CSR_SEQUENCEREG0B22S2_ADDR			0x6DU
+#define CSR_SEQUENCEREG0B23S0_ADDR			0x6EU
+#define CSR_SEQUENCEREG0B23S1_ADDR			0x6FU
+#define CSR_SEQUENCEREG0B23S2_ADDR			0x70U
+#define CSR_SEQUENCEREG0B24S0_ADDR			0x71U
+#define CSR_SEQUENCEREG0B24S1_ADDR			0x72U
+#define CSR_SEQUENCEREG0B24S2_ADDR			0x73U
+#define CSR_SEQUENCEREG0B25S0_ADDR			0x74U
+#define CSR_SEQUENCEREG0B25S1_ADDR			0x75U
+#define CSR_SEQUENCEREG0B25S2_ADDR			0x76U
+#define CSR_SEQUENCEREG0B26S0_ADDR			0x77U
+#define CSR_SEQUENCEREG0B26S1_ADDR			0x78U
+#define CSR_SEQUENCEREG0B26S2_ADDR			0x79U
+#define CSR_SEQUENCEREG0B27S0_ADDR			0x7AU
+#define CSR_SEQUENCEREG0B27S1_ADDR			0x7BU
+#define CSR_SEQUENCEREG0B27S2_ADDR			0x7CU
+#define CSR_SEQUENCEREG0B28S0_ADDR			0x7DU
+#define CSR_SEQUENCEREG0B28S1_ADDR			0x7EU
+#define CSR_SEQUENCEREG0B28S2_ADDR			0x7FU
+#define CSR_SEQUENCEREG0B29S0_ADDR			0x80U
+#define CSR_SEQUENCEREG0B29S1_ADDR			0x81U
+#define CSR_SEQUENCEREG0B29S2_ADDR			0x82U
+#define CSR_SEQUENCEREG0B30S0_ADDR			0x83U
+#define CSR_SEQUENCEREG0B30S1_ADDR			0x84U
+#define CSR_SEQUENCEREG0B30S2_ADDR			0x85U
+#define CSR_SEQUENCEREG0B31S0_ADDR			0x86U
+#define CSR_SEQUENCEREG0B31S1_ADDR			0x87U
+#define CSR_SEQUENCEREG0B31S2_ADDR			0x88U
+#define CSR_SEQUENCEREG0B32S0_ADDR			0x89U
+#define CSR_SEQUENCEREG0B32S1_ADDR			0x8AU
+#define CSR_SEQUENCEREG0B32S2_ADDR			0x8BU
+#define CSR_SEQUENCEREG0B33S0_ADDR			0x8CU
+#define CSR_SEQUENCEREG0B33S1_ADDR			0x8DU
+#define CSR_SEQUENCEREG0B33S2_ADDR			0x8EU
+#define CSR_SEQUENCEREG0B34S0_ADDR			0x8FU
+#define CSR_SEQUENCEREG0B34S1_ADDR			0x90U
+#define CSR_SEQUENCEREG0B34S2_ADDR			0x91U
+#define CSR_SEQUENCEREG0B35S0_ADDR			0x92U
+#define CSR_SEQUENCEREG0B35S1_ADDR			0x93U
+#define CSR_SEQUENCEREG0B35S2_ADDR			0x94U
+#define CSR_SEQUENCEREG0B36S0_ADDR			0x95U
+#define CSR_SEQUENCEREG0B36S1_ADDR			0x96U
+#define CSR_SEQUENCEREG0B36S2_ADDR			0x97U
+#define CSR_SEQUENCEREG0B37S0_ADDR			0x98U
+#define CSR_SEQUENCEREG0B37S1_ADDR			0x99U
+#define CSR_SEQUENCEREG0B37S2_ADDR			0x9AU
+#define CSR_SEQUENCEREG0B38S0_ADDR			0x9BU
+#define CSR_SEQUENCEREG0B38S1_ADDR			0x9CU
+#define CSR_SEQUENCEREG0B38S2_ADDR			0x9DU
+#define CSR_SEQUENCEREG0B39S0_ADDR			0x9EU
+#define CSR_SEQUENCEREG0B39S1_ADDR			0x9FU
+#define CSR_SEQUENCEREG0B39S2_ADDR			0xA0U
+#define CSR_SEQUENCEREG0B40S0_ADDR			0xA1U
+#define CSR_SEQUENCEREG0B40S1_ADDR			0xA2U
+#define CSR_SEQUENCEREG0B40S2_ADDR			0xA3U
+#define CSR_SEQUENCEREG0B41S0_ADDR			0xA4U
+#define CSR_SEQUENCEREG0B41S1_ADDR			0xA5U
+#define CSR_SEQUENCEREG0B41S2_ADDR			0xA6U
+#define CSR_SEQUENCEREG0B42S0_ADDR			0xA7U
+#define CSR_SEQUENCEREG0B42S1_ADDR			0xA8U
+#define CSR_SEQUENCEREG0B42S2_ADDR			0xA9U
+#define CSR_SEQUENCEREG0B43S0_ADDR			0xAAU
+#define CSR_SEQUENCEREG0B43S1_ADDR			0xABU
+#define CSR_SEQUENCEREG0B43S2_ADDR			0xACU
+#define CSR_SEQUENCEREG0B44S0_ADDR			0xADU
+#define CSR_SEQUENCEREG0B44S1_ADDR			0xAEU
+#define CSR_SEQUENCEREG0B44S2_ADDR			0xAFU
+#define CSR_SEQUENCEREG0B45S0_ADDR			0xB0U
+#define CSR_SEQUENCEREG0B45S1_ADDR			0xB1U
+#define CSR_SEQUENCEREG0B45S2_ADDR			0xB2U
+#define CSR_SEQUENCEREG0B46S0_ADDR			0xB3U
+#define CSR_SEQUENCEREG0B46S1_ADDR			0xB4U
+#define CSR_SEQUENCEREG0B46S2_ADDR			0xB5U
+#define CSR_SEQUENCEREG0B47S0_ADDR			0xB6U
+#define CSR_SEQUENCEREG0B47S1_ADDR			0xB7U
+#define CSR_SEQUENCEREG0B47S2_ADDR			0xB8U
+#define CSR_SEQUENCEREG0B48S0_ADDR			0xB9U
+#define CSR_SEQUENCEREG0B48S1_ADDR			0xBAU
+#define CSR_SEQUENCEREG0B48S2_ADDR			0xBBU
+#define CSR_SEQUENCEREG0B49S0_ADDR			0xBCU
+#define CSR_SEQUENCEREG0B49S1_ADDR			0xBDU
+#define CSR_SEQUENCEREG0B49S2_ADDR			0xBEU
+#define CSR_SEQUENCEREG0B50S0_ADDR			0xBFU
+#define CSR_SEQUENCEREG0B50S1_ADDR			0xC0U
+#define CSR_SEQUENCEREG0B50S2_ADDR			0xC1U
+#define CSR_SEQUENCEREG0B51S0_ADDR			0xC2U
+#define CSR_SEQUENCEREG0B51S1_ADDR			0xC3U
+#define CSR_SEQUENCEREG0B51S2_ADDR			0xC4U
+#define CSR_SEQUENCEREG0B52S0_ADDR			0xC5U
+#define CSR_SEQUENCEREG0B52S1_ADDR			0xC6U
+#define CSR_SEQUENCEREG0B52S2_ADDR			0xC7U
+#define CSR_SEQUENCEREG0B53S0_ADDR			0xC8U
+#define CSR_SEQUENCEREG0B53S1_ADDR			0xC9U
+#define CSR_SEQUENCEREG0B53S2_ADDR			0xCAU
+#define CSR_SEQUENCEREG0B54S0_ADDR			0xCBU
+#define CSR_SEQUENCEREG0B54S1_ADDR			0xCCU
+#define CSR_SEQUENCEREG0B54S2_ADDR			0xCDU
+#define CSR_SEQUENCEREG0B55S0_ADDR			0xCEU
+#define CSR_SEQUENCEREG0B55S1_ADDR			0xCFU
+#define CSR_SEQUENCEREG0B55S2_ADDR			0xD0U
+#define CSR_SEQUENCEREG0B56S0_ADDR			0xD1U
+#define CSR_SEQUENCEREG0B56S1_ADDR			0xD2U
+#define CSR_SEQUENCEREG0B56S2_ADDR			0xD3U
+#define CSR_SEQUENCEREG0B57S0_ADDR			0xD4U
+#define CSR_SEQUENCEREG0B57S1_ADDR			0xD5U
+#define CSR_SEQUENCEREG0B57S2_ADDR			0xD6U
+#define CSR_SEQUENCEREG0B58S0_ADDR			0xD7U
+#define CSR_SEQUENCEREG0B58S1_ADDR			0xD8U
+#define CSR_SEQUENCEREG0B58S2_ADDR			0xD9U
+#define CSR_SEQUENCEREG0B59S0_ADDR			0xDAU
+#define CSR_SEQUENCEREG0B59S1_ADDR			0xDBU
+#define CSR_SEQUENCEREG0B59S2_ADDR			0xDCU
+#define CSR_SEQUENCEREG0B60S0_ADDR			0xDDU
+#define CSR_SEQUENCEREG0B60S1_ADDR			0xDEU
+#define CSR_SEQUENCEREG0B60S2_ADDR			0xDFU
+#define CSR_SEQUENCEREG0B61S0_ADDR			0xE0U
+#define CSR_SEQUENCEREG0B61S1_ADDR			0xE1U
+#define CSR_SEQUENCEREG0B61S2_ADDR			0xE2U
+#define CSR_SEQUENCEREG0B62S0_ADDR			0xE3U
+#define CSR_SEQUENCEREG0B62S1_ADDR			0xE4U
+#define CSR_SEQUENCEREG0B62S2_ADDR			0xE5U
+#define CSR_SEQUENCEREG0B63S0_ADDR			0xE6U
+#define CSR_SEQUENCEREG0B63S1_ADDR			0xE7U
+#define CSR_SEQUENCEREG0B63S2_ADDR			0xE8U
+#define CSR_SEQUENCEREG0B64S0_ADDR			0xE9U
+#define CSR_SEQUENCEREG0B64S1_ADDR			0xEAU
+#define CSR_SEQUENCEREG0B64S2_ADDR			0xEBU
+#define CSR_SEQUENCEREG0B65S0_ADDR			0xECU
+#define CSR_SEQUENCEREG0B65S1_ADDR			0xEDU
+#define CSR_SEQUENCEREG0B65S2_ADDR			0xEEU
+#define CSR_SEQUENCEREG0B66S0_ADDR			0xEFU
+#define CSR_SEQUENCEREG0B66S1_ADDR			0xF0U
+#define CSR_SEQUENCEREG0B66S2_ADDR			0xF1U
+#define CSR_SEQUENCEREG0B67S0_ADDR			0xF2U
+#define CSR_SEQUENCEREG0B67S1_ADDR			0xF3U
+#define CSR_SEQUENCEREG0B67S2_ADDR			0xF4U
+#define CSR_SEQUENCEREG0B68S0_ADDR			0xF5U
+#define CSR_SEQUENCEREG0B68S1_ADDR			0xF6U
+#define CSR_SEQUENCEREG0B68S2_ADDR			0xF7U
+#define CSR_SEQUENCEREG0B69S0_ADDR			0xF8U
+#define CSR_SEQUENCEREG0B69S1_ADDR			0xF9U
+#define CSR_SEQUENCEREG0B69S2_ADDR			0xFAU
+#define CSR_SEQUENCEREG0B70S0_ADDR			0xFBU
+#define CSR_SEQUENCEREG0B70S1_ADDR			0xFCU
+#define CSR_SEQUENCEREG0B70S2_ADDR			0xFDU
+#define CSR_SEQUENCEREG0B71S0_ADDR			0xFEU
+#define CSR_SEQUENCEREG0B71S1_ADDR			0xFFU
+#define CSR_SEQUENCEREG0B71S2_ADDR			0x100U
+#define CSR_SEQUENCEREG0B72S0_ADDR			0x101U
+#define CSR_SEQUENCEREG0B72S1_ADDR			0x102U
+#define CSR_SEQUENCEREG0B72S2_ADDR			0x103U
+#define CSR_SEQUENCEREG0B73S0_ADDR			0x104U
+#define CSR_SEQUENCEREG0B73S1_ADDR			0x105U
+#define CSR_SEQUENCEREG0B73S2_ADDR			0x106U
+#define CSR_SEQUENCEREG0B74S0_ADDR			0x107U
+#define CSR_SEQUENCEREG0B74S1_ADDR			0x108U
+#define CSR_SEQUENCEREG0B74S2_ADDR			0x109U
+#define CSR_SEQUENCEREG0B75S0_ADDR			0x10AU
+#define CSR_SEQUENCEREG0B75S1_ADDR			0x10BU
+#define CSR_SEQUENCEREG0B75S2_ADDR			0x10CU
+#define CSR_SEQUENCEREG0B76S0_ADDR			0x10DU
+#define CSR_SEQUENCEREG0B76S1_ADDR			0x10EU
+#define CSR_SEQUENCEREG0B76S2_ADDR			0x10FU
+#define CSR_SEQUENCEREG0B77S0_ADDR			0x110U
+#define CSR_SEQUENCEREG0B77S1_ADDR			0x111U
+#define CSR_SEQUENCEREG0B77S2_ADDR			0x112U
+#define CSR_SEQUENCEREG0B78S0_ADDR			0x113U
+#define CSR_SEQUENCEREG0B78S1_ADDR			0x114U
+#define CSR_SEQUENCEREG0B78S2_ADDR			0x115U
+#define CSR_SEQUENCEREG0B79S0_ADDR			0x116U
+#define CSR_SEQUENCEREG0B79S1_ADDR			0x117U
+#define CSR_SEQUENCEREG0B79S2_ADDR			0x118U
+#define CSR_SEQUENCEREG0B80S0_ADDR			0x119U
+#define CSR_SEQUENCEREG0B80S1_ADDR			0x11AU
+#define CSR_SEQUENCEREG0B80S2_ADDR			0x11BU
+#define CSR_SEQUENCEREG0B81S0_ADDR			0x11CU
+#define CSR_SEQUENCEREG0B81S1_ADDR			0x11DU
+#define CSR_SEQUENCEREG0B81S2_ADDR			0x11EU
+#define CSR_SEQUENCEREG0B82S0_ADDR			0x11FU
+#define CSR_SEQUENCEREG0B82S1_ADDR			0x120U
+#define CSR_SEQUENCEREG0B82S2_ADDR			0x121U
+#define CSR_SEQUENCEREG0B83S0_ADDR			0x122U
+#define CSR_SEQUENCEREG0B83S1_ADDR			0x123U
+#define CSR_SEQUENCEREG0B83S2_ADDR			0x124U
+#define CSR_SEQUENCEREG0B84S0_ADDR			0x125U
+#define CSR_SEQUENCEREG0B84S1_ADDR			0x126U
+#define CSR_SEQUENCEREG0B84S2_ADDR			0x127U
+#define CSR_SEQUENCEREG0B85S0_ADDR			0x128U
+#define CSR_SEQUENCEREG0B85S1_ADDR			0x129U
+#define CSR_SEQUENCEREG0B85S2_ADDR			0x12AU
+#define CSR_SEQUENCEREG0B86S0_ADDR			0x12BU
+#define CSR_SEQUENCEREG0B86S1_ADDR			0x12CU
+#define CSR_SEQUENCEREG0B86S2_ADDR			0x12DU
+#define CSR_SEQUENCEREG0B87S0_ADDR			0x12EU
+#define CSR_SEQUENCEREG0B87S1_ADDR			0x12FU
+#define CSR_SEQUENCEREG0B87S2_ADDR			0x130U
+#define CSR_SEQUENCEREG0B88S0_ADDR			0x131U
+#define CSR_SEQUENCEREG0B88S1_ADDR			0x132U
+#define CSR_SEQUENCEREG0B88S2_ADDR			0x133U
+#define CSR_SEQUENCEREG0B89S0_ADDR			0x134U
+#define CSR_SEQUENCEREG0B89S1_ADDR			0x135U
+#define CSR_SEQUENCEREG0B89S2_ADDR			0x136U
+#define CSR_SEQUENCEREG0B90S0_ADDR			0x137U
+#define CSR_SEQUENCEREG0B90S1_ADDR			0x138U
+#define CSR_SEQUENCEREG0B90S2_ADDR			0x139U
+#define CSR_SEQUENCEREG0B91S0_ADDR			0x13AU
+#define CSR_SEQUENCEREG0B91S1_ADDR			0x13BU
+#define CSR_SEQUENCEREG0B91S2_ADDR			0x13CU
+#define CSR_SEQUENCEREG0B92S0_ADDR			0x13DU
+#define CSR_SEQUENCEREG0B92S1_ADDR			0x13EU
+#define CSR_SEQUENCEREG0B92S2_ADDR			0x13FU
+#define CSR_SEQUENCEREG0B93S0_ADDR			0x140U
+#define CSR_SEQUENCEREG0B93S1_ADDR			0x141U
+#define CSR_SEQUENCEREG0B93S2_ADDR			0x142U
+#define CSR_SEQUENCEREG0B94S0_ADDR			0x143U
+#define CSR_SEQUENCEREG0B94S1_ADDR			0x144U
+#define CSR_SEQUENCEREG0B94S2_ADDR			0x145U
+#define CSR_SEQUENCEREG0B95S0_ADDR			0x146U
+#define CSR_SEQUENCEREG0B95S1_ADDR			0x147U
+#define CSR_SEQUENCEREG0B95S2_ADDR			0x148U
+#define CSR_SEQUENCEREG0B96S0_ADDR			0x149U
+#define CSR_SEQUENCEREG0B96S1_ADDR			0x14AU
+#define CSR_SEQUENCEREG0B96S2_ADDR			0x14BU
+#define CSR_SEQUENCEREG0B97S0_ADDR			0x14CU
+#define CSR_SEQUENCEREG0B97S1_ADDR			0x14DU
+#define CSR_SEQUENCEREG0B97S2_ADDR			0x14EU
+#define CSR_SEQUENCEREG0B98S0_ADDR			0x14FU
+#define CSR_SEQUENCEREG0B98S1_ADDR			0x150U
+#define CSR_SEQUENCEREG0B98S2_ADDR			0x151U
+#define CSR_SEQUENCEREG0B99S0_ADDR			0x152U
+#define CSR_SEQUENCEREG0B99S1_ADDR			0x153U
+#define CSR_SEQUENCEREG0B99S2_ADDR			0x154U
+#define CSR_SEQUENCEREG0B100S0_ADDR			0x155U
+#define CSR_SEQUENCEREG0B100S1_ADDR			0x156U
+#define CSR_SEQUENCEREG0B100S2_ADDR			0x157U
+#define CSR_SEQUENCEREG0B101S0_ADDR			0x158U
+#define CSR_SEQUENCEREG0B101S1_ADDR			0x159U
+#define CSR_SEQUENCEREG0B101S2_ADDR			0x15AU
+#define CSR_SEQUENCEREG0B102S0_ADDR			0x15BU
+#define CSR_SEQUENCEREG0B102S1_ADDR			0x15CU
+#define CSR_SEQUENCEREG0B102S2_ADDR			0x15DU
+#define CSR_SEQUENCEREG0B103S0_ADDR			0x15EU
+#define CSR_SEQUENCEREG0B103S1_ADDR			0x15FU
+#define CSR_SEQUENCEREG0B103S2_ADDR			0x160U
+#define CSR_SEQUENCEREG0B104S0_ADDR			0x161U
+#define CSR_SEQUENCEREG0B104S1_ADDR			0x162U
+#define CSR_SEQUENCEREG0B104S2_ADDR			0x163U
+#define CSR_SEQUENCEREG0B105S0_ADDR			0x164U
+#define CSR_SEQUENCEREG0B105S1_ADDR			0x165U
+#define CSR_SEQUENCEREG0B105S2_ADDR			0x166U
+#define CSR_SEQUENCEREG0B106S0_ADDR			0x167U
+#define CSR_SEQUENCEREG0B106S1_ADDR			0x168U
+#define CSR_SEQUENCEREG0B106S2_ADDR			0x169U
+#define CSR_SEQUENCEREG0B107S0_ADDR			0x16AU
+#define CSR_SEQUENCEREG0B107S1_ADDR			0x16BU
+#define CSR_SEQUENCEREG0B107S2_ADDR			0x16CU
+#define CSR_SEQUENCEREG0B108S0_ADDR			0x16DU
+#define CSR_SEQUENCEREG0B108S1_ADDR			0x16EU
+#define CSR_SEQUENCEREG0B108S2_ADDR			0x16FU
+#define CSR_SEQUENCEREG0B109S0_ADDR			0x170U
+#define CSR_SEQUENCEREG0B109S1_ADDR			0x171U
+#define CSR_SEQUENCEREG0B109S2_ADDR			0x172U
+#define CSR_SEQUENCEREG0B110S0_ADDR			0x173U
+#define CSR_SEQUENCEREG0B110S1_ADDR			0x174U
+#define CSR_SEQUENCEREG0B110S2_ADDR			0x175U
+#define CSR_SEQUENCEREG0B111S0_ADDR			0x176U
+#define CSR_SEQUENCEREG0B111S1_ADDR			0x177U
+#define CSR_SEQUENCEREG0B111S2_ADDR			0x178U
+#define CSR_SEQUENCEREG0B112S0_ADDR			0x179U
+#define CSR_SEQUENCEREG0B112S1_ADDR			0x17AU
+#define CSR_SEQUENCEREG0B112S2_ADDR			0x17BU
+#define CSR_SEQUENCEREG0B113S0_ADDR			0x17CU
+#define CSR_SEQUENCEREG0B113S1_ADDR			0x17DU
+#define CSR_SEQUENCEREG0B113S2_ADDR			0x17EU
+#define CSR_SEQUENCEREG0B114S0_ADDR			0x17FU
+#define CSR_SEQUENCEREG0B114S1_ADDR			0x180U
+#define CSR_SEQUENCEREG0B114S2_ADDR			0x181U
+#define CSR_SEQUENCEREG0B115S0_ADDR			0x182U
+#define CSR_SEQUENCEREG0B115S1_ADDR			0x183U
+#define CSR_SEQUENCEREG0B115S2_ADDR			0x184U
+#define CSR_SEQUENCEREG0B116S0_ADDR			0x185U
+#define CSR_SEQUENCEREG0B116S1_ADDR			0x186U
+#define CSR_SEQUENCEREG0B116S2_ADDR			0x187U
+#define CSR_SEQUENCEREG0B117S0_ADDR			0x188U
+#define CSR_SEQUENCEREG0B117S1_ADDR			0x189U
+#define CSR_SEQUENCEREG0B117S2_ADDR			0x18AU
+#define CSR_SEQUENCEREG0B118S0_ADDR			0x18BU
+#define CSR_SEQUENCEREG0B118S1_ADDR			0x18CU
+#define CSR_SEQUENCEREG0B118S2_ADDR			0x18DU
+#define CSR_SEQUENCEREG0B119S0_ADDR			0x18EU
+#define CSR_SEQUENCEREG0B119S1_ADDR			0x18FU
+#define CSR_SEQUENCEREG0B119S2_ADDR			0x190U
+#define CSR_SEQUENCEREG0B120S0_ADDR			0x191U
+#define CSR_SEQUENCEREG0B120S1_ADDR			0x192U
+#define CSR_SEQUENCEREG0B120S2_ADDR			0x193U
+#define CSR_SEQUENCEREG0B121S0_ADDR			0x194U
+#define CSR_SEQUENCEREG0B121S1_ADDR			0x195U
+#define CSR_SEQUENCEREG0B121S2_ADDR			0x196U
+#define CSR_SEQ0BGPR1_ADDR				0x201U
+#define CSR_SEQ0BGPR2_ADDR				0x202U
+#define CSR_SEQ0BGPR3_ADDR				0x203U
+#define CSR_SEQ0BGPR4_ADDR				0x204U
+#define CSR_SEQ0BGPR5_ADDR				0x205U
+#define CSR_SEQ0BGPR6_ADDR				0x206U
+#define CSR_SEQ0BGPR7_ADDR				0x207U
+#define CSR_SEQ0BGPR8_ADDR				0x208U
+#define CSR_SEQ0BFIXEDADDRBITS_ADDR			0x2FFU
+
+/* DRTUB0 register offsets */
+#define CSR_DCTSHADOWREGS_ADDR				0x4U
+#define CSR_DCTWRITEONLYSHADOW_ADDR			0x30U
+#define CSR_UCTWRITEONLY_ADDR				0x32U
+#define CSR_UCTWRITEPROT_ADDR				0x33U
+#define CSR_UCTDATWRITEONLY_ADDR			0x34U
+#define CSR_UCTDATWRITEPROT_ADDR			0x35U
+#define CSR_UCTLERR_ADDR				0x36U
+#define CSR_UCCLKHCLKENABLES_ADDR			0x80U
+#define CSR_CURPSTATE0B_ADDR				0x81U
+#define CSR_CLRWAKEUPSTICKY_ADDR			0x95U
+#define CSR_WAKEUPMASK_ADDR				0x96U
+#define CSR_CUSTPUBREV_ADDR				0xEDU
+#define CSR_PUBREV_ADDR					0xEEU
+
+/* APBONLY0 register offsets */
+#define CSR_MICROCONTMUXSEL_ADDR			0x0U
+#define CSR_UCTSHADOWREGS_ADDR				0x4U
+#define CSR_DCTWRITEONLY_ADDR				0x30U
+#define CSR_DCTWRITEPROT_ADDR				0x31U
+#define CSR_UCTWRITEONLYSHADOW_ADDR			0x32U
+#define CSR_UCTDATWRITEONLYSHADOW_ADDR			0x34U
+#define CSR_NEVERGATECSRCLOCK_ADDR			0x35U
+#define CSR_DFICFGRDDATAVALIDTICKS_ADDR			0x37U
+#define CSR_MICRORESET_ADDR				0x99U
+#define CSR_SEQUENCEROVERRIDE_ADDR			0xE7U
+#define CSR_DFIINITCOMPLETESHADOW_ADDR			0xFAU
+
+/* ANIBx register bit fields */
+/* CSR_MTESTMUXSEL */
+#define CSR_MTESTMUXSEL_LSB				0
+#define CSR_MTESTMUXSEL_MASK				GENMASK_32(5, 0)
+/* CSR_AFORCEDRVCONT */
+#define CSR_AFORCEDRVCONT_LSB				0
+#define CSR_AFORCEDRVCONT_MASK				GENMASK_32(3, 0)
+/* CSR_AFORCETRICONT */
+#define CSR_AFORCETRICONT_LSB				0
+#define CSR_AFORCETRICONT_MASK				GENMASK_32(3, 0)
+/* CSR_ATXIMPEDANCE */
+#define CSR_ATXIMPEDANCE_LSB				0
+#define CSR_ATXIMPEDANCE_MASK				GENMASK_32(9, 0)
+#define CSR_ADRVSTRENP_LSB				0
+#define CSR_ADRVSTRENP_MASK				GENMASK_32(4, 0)
+#define CSR_ADRVSTRENN_LSB				5
+#define CSR_ADRVSTRENN_MASK				GENMASK_32(9, 5)
+/* CSR_ATESTPRBSERR */
+#define CSR_ATESTPRBSERR_LSB				0
+#define CSR_ATESTPRBSERR_MASK				GENMASK_32(3, 0)
+/* CSR_ATXSLEWRATE */
+#define CSR_ATXSLEWRATE_LSB				0
+#define CSR_ATXSLEWRATE_MASK				GENMASK_32(10, 0)
+#define CSR_ATXPREP_LSB					0
+#define CSR_ATXPREP_MASK				GENMASK_32(3, 0)
+#define CSR_ATXPREN_LSB					4
+#define CSR_ATXPREN_MASK				GENMASK_32(7, 4)
+#define CSR_ATXPREDRVMODE_LSB				8
+#define CSR_ATXPREDRVMODE_MASK				GENMASK_32(10, 8)
+/* CSR_ATESTPRBSERRCNT */
+#define CSR_ATESTPRBSERRCNT_LSB				0
+#define CSR_ATESTPRBSERRCNT_MASK			GENMASK_32(15, 0)
+/* CSR_ATXDLY */
+#define CSR_ATXDLY_LSB					0
+#define CSR_ATXDLY_MASK					GENMASK_32(6, 0)
+
+/* DBYTEx register bit fields */
+/* CSR_DBYTEMISCMODE */
+#define CSR_DBYTEMISCMODE_LSB				2
+#define CSR_DBYTEMISCMODE_MASK				BIT(2)
+#define CSR_DBYTEDISABLE_LSB				2
+#define CSR_DBYTEDISABLE_MASK				BIT(2)
+/* CSR_TSMBYTE0 */
+#define CSR_TSMBYTE0_LSB				0
+#define CSR_TSMBYTE0_MASK				GENMASK_32(15, 0)
+#define CSR_PERPHTRAINEN_LSB				0
+#define CSR_PERPHTRAINEN_MASK				BIT(0)
+#define CSR_EYEINC_LSB					1
+#define CSR_EYEINC_MASK					BIT(1)
+#define CSR_EDGEINC_LSB					2
+#define CSR_EDGEINC_MASK				BIT(2)
+#define CSR_EDGEEYEMXSEL_LSB				3
+#define CSR_EDGEEYEMXSEL_MASK				BIT(3)
+#define CSR_TSMBYTE0RSVD_LSB				4
+#define CSR_TSMBYTE0RSVD_MASK				GENMASK_32(5, 4)
+#define CSR_DIMMBROADINC_LSB				6
+#define CSR_DIMMBROADINC_MASK				BIT(6)
+#define CSR_DIMMINC_LSB					7
+#define CSR_DIMMINC_MASK				GENMASK_32(8, 7)
+#define CSR_COARSEINC_LSB				9
+#define CSR_COARSEINC_MASK				BIT(9)
+#define CSR_DELAYINC_LSB				10
+#define CSR_DELAYINC_MASK				BIT(10)
+#define CSR_RXINC_LSB					11
+#define CSR_RXINC_MASK					BIT(11)
+#define CSR_RXPERTRAIN_LSB				12
+#define CSR_RXPERTRAIN_MASK				BIT(12)
+#define CSR_TXPERTRAIN_LSB				13
+#define CSR_TXPERTRAIN_MASK				BIT(13)
+#define CSR_DMTRAIN_LSB					14
+#define CSR_DMTRAIN_MASK				BIT(14)
+#define CSR_WRLEVTRAIN_LSB				15
+#define CSR_WRLEVTRAIN_MASK				BIT(15)
+/* CSR_TRAININGPARAM */
+#define CSR_TRAININGPARAM_LSB				0
+#define CSR_TRAININGPARAM_MASK				GENMASK_32(15, 0)
+#define CSR_ENDYNRATEREDUCTION_LSB			0
+#define CSR_ENDYNRATEREDUCTION_MASK			BIT(0)
+#define CSR_TRAININGPARAM01RSVD_LSB			1
+#define CSR_TRAININGPARAM01RSVD_MASK			BIT(1)
+#define CSR_TRAINENRXCLK_LSB				2
+#define CSR_TRAINENRXCLK_MASK				BIT(2)
+#define CSR_TRAINENRXEN_LSB				3
+#define CSR_TRAINENRXEN_MASK				BIT(3)
+#define CSR_TRAINENTXDQS_LSB				4
+#define CSR_TRAINENTXDQS_MASK				BIT(4)
+#define CSR_TRAINENTXDQ_LSB				5
+#define CSR_TRAINENTXDQ_MASK				BIT(5)
+#define CSR_TRAINENVREFDAC1_LSB				6
+#define CSR_TRAINENVREFDAC1_MASK			BIT(6)
+#define CSR_TRAINENVREFDAC0_LSB				7
+#define CSR_TRAINENVREFDAC0_MASK			BIT(7)
+#define CSR_TRAINENRXPBD_LSB				8
+#define CSR_TRAINENRXPBD_MASK				BIT(8)
+#define CSR_ROLLINTOCOARSE_LSB				9
+#define CSR_ROLLINTOCOARSE_MASK				BIT(9)
+#define CSR_TRAINUSINGNATIVEDDLCNTL_LSB			10
+#define CSR_TRAINUSINGNATIVEDDLCNTL_MASK		BIT(10)
+#define CSR_TRAININGPARAM11RSVD_LSB			11
+#define CSR_TRAININGPARAM11RSVD_MASK			BIT(11)
+#define CSR_TRAININGPARAM12RSVD_LSB			12
+#define CSR_TRAININGPARAM12RSVD_MASK			BIT(12)
+#define CSR_INCDECRATE_LSB				13
+#define CSR_INCDECRATE_MASK				GENMASK_32(15, 13)
+/* CSR_USEDQSENREPLICA */
+#define CSR_USEDQSENREPLICA_LSB				0
+#define CSR_USEDQSENREPLICA_MASK			BIT(0)
+/* CSR_RXTRAINPATTERNENABLE */
+#define CSR_RXTRAINPATTERNENABLE_LSB			0
+#define CSR_RXTRAINPATTERNENABLE_MASK			BIT(0)
+/* CSR_TSMBYTE1 */
+#define CSR_TSMBYTE1_LSB				0
+#define CSR_TSMBYTE1_MASK				GENMASK_32(15, 0)
+#define CSR_DTSMBDSTP_LSB				0
+#define CSR_DTSMBDSTP_MASK				GENMASK_32(7, 0)
+#define CSR_DTSMGDSTP_LSB				8
+#define CSR_DTSMGDSTP_MASK				GENMASK_32(15, 8)
+/* CSR_TSMBYTE2 */
+#define CSR_TSMBYTE2_LSB				0
+#define CSR_TSMBYTE2_MASK				GENMASK_32(15, 0)
+#define CSR_DTSMGDBAR_LSB				0
+#define CSR_DTSMGDBAR_MASK				GENMASK_32(15, 0)
+/* CSR_TSMBYTE3 */
+#define CSR_TSMBYTE3_LSB				0
+#define CSR_TSMBYTE3_MASK				GENMASK_32(8, 0)
+#define CSR_DTSMINCDECMODE_LSB				0
+#define CSR_DTSMINCDECMODE_MASK				BIT(0)
+#define CSR_DTSMINCDECCTRL_LSB				1
+#define CSR_DTSMINCDECCTRL_MASK				BIT(1)
+#define CSR_ENBLRXSAMPFLOPS_LSB				2
+#define CSR_ENBLRXSAMPFLOPS_MASK			BIT(2)
+#define CSR_SELRXSAMPFLOPS_LSB				3
+#define CSR_SELRXSAMPFLOPS_MASK				BIT(3)
+#define CSR_SELRXBYBASS_LSB				4
+#define CSR_SELRXBYBASS_MASK				BIT(4)
+#define CSR_DTSMIGNUPDATEACK_LSB			5
+#define CSR_DTSMIGNUPDATEACK_MASK			BIT(5)
+#define CSR_ENABLERXDQASYNC_LSB				6
+#define CSR_ENABLERXDQASYNC_MASK			BIT(6)
+#define CSR_DTSMSTATICCMPR_LSB				7
+#define CSR_DTSMSTATICCMPR_MASK				BIT(7)
+#define CSR_DTSMSTATICCMPRVAL_LSB			8
+#define CSR_DTSMSTATICCMPRVAL_MASK			BIT(8)
+/* CSR_TSMBYTE4 */
+#define CSR_TSMBYTE4_LSB				0
+#define CSR_TSMBYTE4_MASK				GENMASK_32(3, 0)
+#define CSR_DTSMINCDECPW_LSB				0
+#define CSR_DTSMINCDECPW_MASK				GENMASK_32(3, 0)
+/* CSR_TESTMODECONFIG */
+#define CSR_TESTMODECONFIG_LSB				0
+#define CSR_TESTMODECONFIG_MASK				GENMASK_32(9, 0)
+#define CSR_LOOPBACKEN_LSB				0
+#define CSR_LOOPBACKEN_MASK				BIT(0)
+#define CSR_RSVDTESTDLLEN_LSB				1
+#define CSR_RSVDTESTDLLEN_MASK				BIT(1)
+#define CSR_RSVDTWOTCKTXDQSPRE_LSB			2
+#define CSR_RSVDTWOTCKTXDQSPRE_MASK			BIT(2)
+#define CSR_TESTMODERSVD_LSB				3
+#define CSR_TESTMODERSVD_MASK				GENMASK_32(7, 3)
+#define CSR_LOOPBACKDISDQSTRI_LSB			8
+#define CSR_LOOPBACKDISDQSTRI_MASK			BIT(8)
+#define CSR_RSVDDISTXDQEQPREAMBLE_LSB			9
+#define CSR_RSVDDISTXDQEQPREAMBLE_MASK			BIT(9)
+/* CSR_TSMBYTE5 */
+#define CSR_TSMBYTE5_LSB				0
+#define CSR_TSMBYTE5_MASK				GENMASK_32(15, 0)
+#define CSR_DTSMBDBAR_LSB				0
+#define CSR_DTSMBDBAR_MASK				GENMASK_32(15, 0)
+/* MTESTMUXSEL already defined in ANIBx section */
+/* CSR_DTSMTRAINMODECTRL */
+#define CSR_DTSMTRAINMODECTRL_LSB			0
+#define CSR_DTSMTRAINMODECTRL_MASK			GENMASK_32(3, 0)
+#define CSR_DTSMSOELANEMODE_LSB				0
+#define CSR_DTSMSOELANEMODE_MASK			GENMASK_32(1, 0)
+#define CSR_DTSMBYTEERRANDMODE_LSB			2
+#define CSR_DTSMBYTEERRANDMODE_MASK			BIT(2)
+#define CSR_DTSMNIBERRMODE_LSB				3
+#define CSR_DTSMNIBERRMODE_MASK				BIT(3)
+/* CSR_DFIMRL */
+#define CSR_DFIMRL_LSB					0
+#define CSR_DFIMRL_MASK					GENMASK_32(4, 0)
+/* CSR_ASYNCDBYTEMODE */
+#define CSR_ASYNCDBYTEMODE_LSB				0
+#define CSR_ASYNCDBYTEMODE_MASK				GENMASK_32(8, 0)
+/* CSR_ASYNCDBYTETXEN */
+#define CSR_ASYNCDBYTETXEN_LSB				0
+#define CSR_ASYNCDBYTETXEN_MASK				GENMASK_32(11, 0)
+/* CSR_ASYNCDBYTETXDATA */
+#define CSR_ASYNCDBYTETXDATA_LSB			0
+#define CSR_ASYNCDBYTETXDATA_MASK			GENMASK_32(11, 0)
+/* CSR_ASYNCDBYTERXDATA */
+#define CSR_ASYNCDBYTERXDATA_LSB			0
+#define CSR_ASYNCDBYTERXDATA_MASK			GENMASK_32(11, 0)
+/* CSR_VREFDAC1 */
+#define CSR_VREFDAC1_LSB				0
+#define CSR_VREFDAC1_MASK				GENMASK_32(6, 0)
+/* CSR_TRAININGCNTR */
+#define CSR_TRAININGCNTR_LSB				0
+#define CSR_TRAININGCNTR_MASK				GENMASK_32(15, 0)
+#define CSR_TRAININGCNTRFINE_LSB			0
+#define CSR_TRAININGCNTRFINE_MASK			GENMASK_32(9, 0)
+#define CSR_TRAININGCNTRCOARSE_LSB			10
+#define CSR_TRAININGCNTRCOARSE_MASK			GENMASK_32(15, 10)
+/* CSR_VREFDAC0 */
+#define CSR_VREFDAC0_LSB				0
+#define CSR_VREFDAC0_MASK				GENMASK_32(6, 0)
+/* CSR_TXIMPEDANCECTRL0 */
+#define CSR_TXIMPEDANCECTRL0_LSB			0
+#define CSR_TXIMPEDANCECTRL0_MASK			GENMASK_32(11, 0)
+#define CSR_DRVSTRENDQP_LSB				0
+#define CSR_DRVSTRENDQP_MASK				GENMASK_32(5, 0)
+#define CSR_DRVSTRENDQN_LSB				6
+#define CSR_DRVSTRENDQN_MASK				GENMASK_32(11, 6)
+/* CSR_DQDQSRCVCNTRL */
+#define CSR_DQDQSRCVCNTRL_LSB				0
+#define CSR_DQDQSRCVCNTRL_MASK				GENMASK_32(15, 0)
+#define CSR_SELANALOGVREF_LSB				0
+#define CSR_SELANALOGVREF_MASK				BIT(0)
+#define CSR_EXTVREFRANGE_LSB				1
+#define CSR_EXTVREFRANGE_MASK				BIT(1)
+#define CSR_DFECTRL_LSB					2
+#define CSR_DFECTRL_MASK				GENMASK_32(3, 2)
+#define CSR_MAJORMODEDBYTE_LSB				4
+#define CSR_MAJORMODEDBYTE_MASK				GENMASK_32(6, 4)
+#define CSR_GAINCURRADJ_LSB				7
+#define CSR_GAINCURRADJ_MASK				GENMASK_32(11, 7)
+#define CSR_RESERVED_LSB				12
+#define CSR_RESERVED_MASK				GENMASK_32(15, 12)
+/* CSR_TXEQUALIZATIONMODE */
+#define CSR_TXEQUALIZATIONMODE_LSB			0
+#define CSR_TXEQUALIZATIONMODE_MASK			GENMASK_32(1, 0)
+#define CSR_TXEQMODE_LSB				0
+#define CSR_TXEQMODE_MASK				GENMASK_32(1, 0)
+/* CSR_TXIMPEDANCECTRL1 */
+#define CSR_TXIMPEDANCECTRL1_LSB			0
+#define CSR_TXIMPEDANCECTRL1_MASK			GENMASK_32(11, 0)
+#define CSR_DRVSTRENFSDQP_LSB				0
+#define CSR_DRVSTRENFSDQP_MASK				GENMASK_32(5, 0)
+#define CSR_DRVSTRENFSDQN_LSB				6
+#define CSR_DRVSTRENFSDQN_MASK				GENMASK_32(11, 6)
+/* CSR_DQDQSRCVCNTRL1 */
+#define CSR_DQDQSRCVCNTRL1_LSB				0
+#define CSR_DQDQSRCVCNTRL1_MASK				GENMASK_32(11, 0)
+#define CSR_POWERDOWNRCVR_LSB				0
+#define CSR_POWERDOWNRCVR_MASK				GENMASK_32(8, 0)
+#define CSR_POWERDOWNRCVRDQS_LSB			9
+#define CSR_POWERDOWNRCVRDQS_MASK			BIT(9)
+#define CSR_RXPADSTANDBYEN_LSB				10
+#define CSR_RXPADSTANDBYEN_MASK				BIT(10)
+#define CSR_ENLPREQPDR_LSB				11
+#define CSR_ENLPREQPDR_MASK				BIT(11)
+/* CSR_TXIMPEDANCECTRL2 */
+#define CSR_TXIMPEDANCECTRL2_LSB			0
+#define CSR_TXIMPEDANCECTRL2_MASK			GENMASK_32(11, 0)
+#define CSR_DRVSTRENEQHIDQP_LSB				0
+#define CSR_DRVSTRENEQHIDQP_MASK			GENMASK_32(5, 0)
+#define CSR_DRVSTRENEQLODQN_LSB				6
+#define CSR_DRVSTRENEQLODQN_MASK			GENMASK_32(11, 6)
+/* CSR_DQDQSRCVCNTRL2 */
+#define CSR_DQDQSRCVCNTRL2_LSB				0
+#define CSR_DQDQSRCVCNTRL2_MASK				BIT(0)
+#define CSR_ENRXAGRESSIVEPDR_LSB			0
+#define CSR_ENRXAGRESSIVEPDR_MASK			BIT(0)
+/* CSR_TXODTDRVSTREN */
+#define CSR_TXODTDRVSTREN_LSB				0
+#define CSR_TXODTDRVSTREN_MASK				GENMASK_32(11, 0)
+#define CSR_ODTSTRENP_LSB				0
+#define CSR_ODTSTRENP_MASK				GENMASK_32(5, 0)
+#define CSR_ODTSTRENN_LSB				6
+#define CSR_ODTSTRENN_MASK				GENMASK_32(11, 6)
+/* CSR_RXFIFOCHECKSTATUS */
+#define CSR_RXFIFOCHECKSTATUS_LSB			0
+#define CSR_RXFIFOCHECKSTATUS_MASK			GENMASK_32(1, 0)
+#define CSR_RXFIFOLOCERR_LSB				0
+#define CSR_RXFIFOLOCERR_MASK				BIT(0)
+#define CSR_RXFIFOLOCUERR_LSB				1
+#define CSR_RXFIFOLOCUERR_MASK				BIT(1)
+/* CSR_RXFIFOCHECKERRVALUES */
+#define CSR_RXFIFOCHECKERRVALUES_LSB			0
+#define CSR_RXFIFOCHECKERRVALUES_MASK			GENMASK_32(15, 0)
+#define CSR_RXFIFORDLOCERRVALUE_LSB			0
+#define CSR_RXFIFORDLOCERRVALUE_MASK			GENMASK_32(3, 0)
+#define CSR_RXFIFOWRLOCERRVALUE_LSB			4
+#define CSR_RXFIFOWRLOCERRVALUE_MASK			GENMASK_32(7, 4)
+#define CSR_RXFIFORDLOCUERRVALUE_LSB			8
+#define CSR_RXFIFORDLOCUERRVALUE_MASK			GENMASK_32(11, 8)
+#define CSR_RXFIFOWRLOCUERRVALUE_LSB			12
+#define CSR_RXFIFOWRLOCUERRVALUE_MASK			GENMASK_32(15, 12)
+/* CSR_RXFIFOINFO */
+#define CSR_RXFIFOINFO_LSB				0
+#define CSR_RXFIFOINFO_MASK				GENMASK_32(15, 0)
+#define CSR_RXFIFORDLOC_LSB				0
+#define CSR_RXFIFORDLOC_MASK				GENMASK_32(3, 0)
+#define CSR_RXFIFOWRLOC_LSB				4
+#define CSR_RXFIFOWRLOC_MASK				GENMASK_32(7, 4)
+#define CSR_RXFIFORDLOCU_LSB				8
+#define CSR_RXFIFORDLOCU_MASK				GENMASK_32(11, 8)
+#define CSR_RXFIFOWRLOCU_LSB				12
+#define CSR_RXFIFOWRLOCU_MASK				GENMASK_32(15, 12)
+/* CSR_RXFIFOVISIBILITY */
+#define CSR_RXFIFOVISIBILITY_LSB			0
+#define CSR_RXFIFOVISIBILITY_MASK			GENMASK_32(4, 0)
+#define CSR_RXFIFORDPTR_LSB				0
+#define CSR_RXFIFORDPTR_MASK				GENMASK_32(2, 0)
+#define CSR_RXFIFORDPTROVR_LSB				3
+#define CSR_RXFIFORDPTROVR_MASK				BIT(3)
+#define CSR_RXFIFORDEN_LSB				4
+#define CSR_RXFIFORDEN_MASK				BIT(4)
+/* CSR_RXFIFOCONTENTSDQ3210 */
+#define CSR_RXFIFOCONTENTSDQ3210_LSB			0
+#define CSR_RXFIFOCONTENTSDQ3210_MASK			GENMASK_32(15, 0)
+/* CSR_RXFIFOCONTENTSDQ7654 */
+#define CSR_RXFIFOCONTENTSDQ7654_LSB			0
+#define CSR_RXFIFOCONTENTSDQ7654_MASK			GENMASK_32(15, 0)
+/* CSR_RXFIFOCONTENTSDBI */
+#define CSR_RXFIFOCONTENTSDBI_LSB			0
+#define CSR_RXFIFOCONTENTSDBI_MASK			GENMASK_32(3, 0)
+/* CSR_TXSLEWRATE */
+#define CSR_TXSLEWRATE_LSB				0
+#define CSR_TXSLEWRATE_MASK				GENMASK_32(10, 0)
+#define CSR_TXPREP_LSB					0
+#define CSR_TXPREP_MASK					GENMASK_32(3, 0)
+#define CSR_TXPREN_LSB					4
+#define CSR_TXPREN_MASK					GENMASK_32(7, 4)
+#define CSR_TXPREDRVMODE_LSB				8
+#define CSR_TXPREDRVMODE_MASK				GENMASK_32(10, 8)
+/* CSR_TRAININGINCDECDTSMEN */
+#define CSR_TRAININGINCDECDTSMEN_LSB			0
+#define CSR_TRAININGINCDECDTSMEN_MASK			GENMASK_32(8, 0)
+/* CSR_RXPBDLYTG0 */
+#define CSR_RXPBDLYTG0_LSB				0
+#define CSR_RXPBDLYTG0_MASK				GENMASK_32(6, 0)
+/* CSR_RXPBDLYTG1 */
+#define CSR_RXPBDLYTG1_LSB				0
+#define CSR_RXPBDLYTG1_MASK				GENMASK_32(6, 0)
+/* CSR_RXPBDLYTG2 */
+#define CSR_RXPBDLYTG2_LSB				0
+#define CSR_RXPBDLYTG2_MASK				GENMASK_32(6, 0)
+/* CSR_RXPBDLYTG3 */
+#define CSR_RXPBDLYTG3_LSB				0
+#define CSR_RXPBDLYTG3_MASK				GENMASK_32(6, 0)
+/* CSR_RXENDLYTG0 */
+#define CSR_RXENDLYTG0_LSB				0
+#define CSR_RXENDLYTG0_MASK				GENMASK_32(10, 0)
+/* CSR_RXENDLYTG1 */
+#define CSR_RXENDLYTG1_LSB				0
+#define CSR_RXENDLYTG1_MASK				GENMASK_32(10, 0)
+/* CSR_RXENDLYTG2 */
+#define CSR_RXENDLYTG2_LSB				0
+#define CSR_RXENDLYTG2_MASK				GENMASK_32(10, 0)
+/* CSR_RXENDLYTG3 */
+#define CSR_RXENDLYTG3_LSB				0
+#define CSR_RXENDLYTG3_MASK				GENMASK_32(10, 0)
+/* CSR_RXCLKDLYTG0 */
+#define CSR_RXCLKDLYTG0_LSB				0
+#define CSR_RXCLKDLYTG0_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKDLYTG1 */
+#define CSR_RXCLKDLYTG1_LSB				0
+#define CSR_RXCLKDLYTG1_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKDLYTG2 */
+#define CSR_RXCLKDLYTG2_LSB				0
+#define CSR_RXCLKDLYTG2_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKDLYTG3 */
+#define CSR_RXCLKDLYTG3_LSB				0
+#define CSR_RXCLKDLYTG3_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG0 */
+#define CSR_RXCLKCDLYTG0_LSB				0
+#define CSR_RXCLKCDLYTG0_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG1 */
+#define CSR_RXCLKCDLYTG1_LSB				0
+#define CSR_RXCLKCDLYTG1_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG2 */
+#define CSR_RXCLKCDLYTG2_LSB				0
+#define CSR_RXCLKCDLYTG2_MASK				GENMASK_32(5, 0)
+/* CSR_RXCLKCDLYTG3 */
+#define CSR_RXCLKCDLYTG3_LSB				0
+#define CSR_RXCLKCDLYTG3_MASK				GENMASK_32(5, 0)
+/* CSR_DQ0LNSEL */
+#define CSR_DQ0LNSEL_LSB				0
+#define CSR_DQ0LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ1LNSEL */
+#define CSR_DQ1LNSEL_LSB				0
+#define CSR_DQ1LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ2LNSEL */
+#define CSR_DQ2LNSEL_LSB				0
+#define CSR_DQ2LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ3LNSEL */
+#define CSR_DQ3LNSEL_LSB				0
+#define CSR_DQ3LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ4LNSEL */
+#define CSR_DQ4LNSEL_LSB				0
+#define CSR_DQ4LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ5LNSEL */
+#define CSR_DQ5LNSEL_LSB				0
+#define CSR_DQ5LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ6LNSEL */
+#define CSR_DQ6LNSEL_LSB				0
+#define CSR_DQ6LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_DQ7LNSEL */
+#define CSR_DQ7LNSEL_LSB				0
+#define CSR_DQ7LNSEL_MASK				GENMASK_32(2, 0)
+/* CSR_PPTCTLSTATIC */
+#define CSR_PPTCTLSTATIC_LSB				0
+#define CSR_PPTCTLSTATIC_MASK				GENMASK_32(11, 0)
+#define CSR_PPTENDQS2DQTG0_LSB				0
+#define CSR_PPTENDQS2DQTG0_MASK				BIT(0)
+#define CSR_PPTENDQS2DQTG1_LSB				1
+#define CSR_PPTENDQS2DQTG1_MASK				BIT(1)
+#define CSR_DOCBYTESELTG0_LSB				2
+#define CSR_DOCBYTESELTG0_MASK				BIT(2)
+#define CSR_DOCBYTESELTG1_LSB				3
+#define CSR_DOCBYTESELTG1_MASK				BIT(3)
+#define CSR_PPTINFOSEL_LSB				4
+#define CSR_PPTINFOSEL_MASK				GENMASK_32(7, 4)
+#define CSR_PPTENRXENDLYTG0_LSB				8
+#define CSR_PPTENRXENDLYTG0_MASK			BIT(8)
+#define CSR_PPTENRXENDLYTG1_LSB				9
+#define CSR_PPTENRXENDLYTG1_MASK			BIT(9)
+#define CSR_PPTENRXENBACKOFF_LSB			10
+#define CSR_PPTENRXENBACKOFF_MASK			GENMASK_32(11, 10)
+/* CSR_PPTCTLDYN */
+#define CSR_PPTCTLDYN_LSB				0
+#define CSR_PPTCTLDYN_MASK				GENMASK_32(1, 0)
+#define CSR_PPTDQS2DQACTIVE_LSB				0
+#define CSR_PPTDQS2DQACTIVE_MASK			BIT(0)
+#define CSR_PPTENRXENUSEDQSSAMPVAL_LSB			1
+#define CSR_PPTENRXENUSEDQSSAMPVAL_MASK			BIT(1)
+/* CSR_PPTINFO */
+#define CSR_PPTINFO_LSB					0
+#define CSR_PPTINFO_MASK				GENMASK_32(15, 0)
+/* CSR_PPTRXENEVNT */
+#define CSR_PPTRXENEVNT_LSB				0
+#define CSR_PPTRXENEVNT_MASK				GENMASK_32(1, 0)
+#define CSR_PPTRXENINIT_LSB				0
+#define CSR_PPTRXENINIT_MASK				BIT(0)
+#define CSR_PPTRXENMHUI_LSB				1
+#define CSR_PPTRXENMHUI_MASK				BIT(1)
+/* CSR_PPTDQSCNTINVTRNTG0 */
+#define CSR_PPTDQSCNTINVTRNTG0_LSB			0
+#define CSR_PPTDQSCNTINVTRNTG0_MASK			GENMASK_32(15, 0)
+/* CSR_PPTDQSCNTINVTRNTG1 */
+#define CSR_PPTDQSCNTINVTRNTG1_LSB			0
+#define CSR_PPTDQSCNTINVTRNTG1_MASK			GENMASK_32(15, 0)
+/* CSR_DTSMBLANKINGCTRL */
+#define CSR_DTSMBLANKINGCTRL_LSB			0
+#define CSR_DTSMBLANKINGCTRL_MASK			GENMASK_32(9, 0)
+#define CSR_DTSMBLANK_LSB				0
+#define CSR_DTSMBLANK_MASK				GENMASK_32(9, 0)
+/* CSR_TSM0 */
+#define CSR_TSM0_LSB					0
+#define CSR_TSM0_MASK					GENMASK_32(13, 0)
+#define CSR_DTSMENB_LSB					0
+#define CSR_DTSMENB_MASK				BIT(0)
+#define CSR_DTSMDIR_LSB					1
+#define CSR_DTSMDIR_MASK				BIT(1)
+#define CSR_DTSMIGNFRST_LSB				2
+#define CSR_DTSMIGNFRST_MASK				BIT(2)
+#define CSR_DTSMODDPHASE_LSB				3
+#define CSR_DTSMODDPHASE_MASK				BIT(3)
+#define CSR_DTSMFLTPRE_LSB				4
+#define CSR_DTSMFLTPRE_MASK				BIT(4)
+#define CSR_DTSMFLTCUR_LSB				5
+#define CSR_DTSMFLTCUR_MASK				BIT(5)
+#define CSR_DTSMFLTNXT_LSB				6
+#define CSR_DTSMFLTNXT_MASK				BIT(6)
+#define CSR_DTSMFLTVAL_LSB				7
+#define CSR_DTSMFLTVAL_MASK				GENMASK_32(9, 7)
+#define CSR_DTSMMSKBIT_LSB				10
+#define CSR_DTSMMSKBIT_MASK				GENMASK_32(13, 10)
+/* CSR_TSM1 */
+#define CSR_TSM1_LSB					0
+#define CSR_TSM1_MASK					GENMASK_32(15, 0)
+#define CSR_DTSMERRCNT_LSB				0
+#define CSR_DTSMERRCNT_MASK				GENMASK_32(15, 0)
+/* CSR_TSM2 */
+#define CSR_TSM2_LSB					0
+#define CSR_TSM2_MASK					BIT(0)
+#define CSR_DTSMDISERRCHK_LSB				0
+#define CSR_DTSMDISERRCHK_MASK				BIT(0)
+/* CSR_TSM3 */
+#define CSR_TSM3_LSB					0
+#define CSR_TSM3_MASK					GENMASK_32(9, 0)
+#define CSR_DTSMCLRERRCNTMSK_LSB			0
+#define CSR_DTSMCLRERRCNTMSK_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMCLRERRCNT_LSB				9
+#define CSR_DTSMCLRERRCNT_MASK				BIT(9)
+/* CSR_TXCHKDATASELECTS */
+#define CSR_TXCHKDATASELECTS_LSB			0
+#define CSR_TXCHKDATASELECTS_MASK			GENMASK_32(1, 0)
+#define CSR_SELCHKTOTX_LSB				0
+#define CSR_SELCHKTOTX_MASK				BIT(0)
+#define CSR_SELTXTOCHK_LSB				1
+#define CSR_SELTXTOCHK_MASK				BIT(1)
+/* CSR_DTSMUPTHLDXINGIND */
+#define CSR_DTSMUPTHLDXINGIND_LSB			0
+#define CSR_DTSMUPTHLDXINGIND_MASK			GENMASK_32(8, 0)
+/* CSR_DTSMLOTHLDXINGIND */
+#define CSR_DTSMLOTHLDXINGIND_LSB			0
+#define CSR_DTSMLOTHLDXINGIND_MASK			GENMASK_32(8, 0)
+/* CSR_DBYTEALLDTSMCTRL0 */
+#define CSR_DBYTEALLDTSMCTRL0_LSB			0
+#define CSR_DBYTEALLDTSMCTRL0_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMINHIBDTSM_LSB				0
+#define CSR_DTSMINHIBDTSM_MASK				GENMASK_32(8, 0)
+/* CSR_DBYTEALLDTSMCTRL1 */
+#define CSR_DBYTEALLDTSMCTRL1_LSB			0
+#define CSR_DBYTEALLDTSMCTRL1_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMGATEINC_LSB				0
+#define CSR_DTSMGATEINC_MASK				GENMASK_32(8, 0)
+/* CSR_DBYTEALLDTSMCTRL2 */
+#define CSR_DBYTEALLDTSMCTRL2_LSB			0
+#define CSR_DBYTEALLDTSMCTRL2_MASK			GENMASK_32(8, 0)
+#define CSR_DTSMGATEDEC_LSB				0
+#define CSR_DTSMGATEDEC_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG0 */
+#define CSR_TXDQDLYTG0_LSB				0
+#define CSR_TXDQDLYTG0_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG1 */
+#define CSR_TXDQDLYTG1_LSB				0
+#define CSR_TXDQDLYTG1_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG2 */
+#define CSR_TXDQDLYTG2_LSB				0
+#define CSR_TXDQDLYTG2_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQDLYTG3 */
+#define CSR_TXDQDLYTG3_LSB				0
+#define CSR_TXDQDLYTG3_MASK				GENMASK_32(8, 0)
+/* CSR_TXDQSDLYTG0 */
+#define CSR_TXDQSDLYTG0_LSB				0
+#define CSR_TXDQSDLYTG0_MASK				GENMASK_32(9, 0)
+/* CSR_TXDQSDLYTG1 */
+#define CSR_TXDQSDLYTG1_LSB				0
+#define CSR_TXDQSDLYTG1_MASK				GENMASK_32(9, 0)
+/* CSR_TXDQSDLYTG2 */
+#define CSR_TXDQSDLYTG2_LSB				0
+#define CSR_TXDQSDLYTG2_MASK				GENMASK_32(9, 0)
+/* CSR_TXDQSDLYTG3 */
+#define CSR_TXDQSDLYTG3_LSB				0
+#define CSR_TXDQSDLYTG3_MASK				GENMASK_32(9, 0)
+/* CSR_DXLCDLSTATUS_ADDR */
+#define CSR_DXLCDLSTATUS_LSB				0
+#define CSR_DXLCDLSTATUS_MASK				GENMASK_32(13, 0)
+#define CSR_DXLCDLFINESNAPVAL_LSB			0
+#define CSR_DXLCDLFINESNAPVAL_MASK			GENMASK_32(9, 0)
+#define CSR_DXLCDLPHDSNAPVAL_LSB			10
+#define CSR_DXLCDLPHDSNAPVAL_MASK			BIT(10)
+#define CSR_DXLCDLSTICKYLOCK_LSB			11
+#define CSR_DXLCDLSTICKYLOCK_MASK			BIT(11)
+#define CSR_DXLCDLSTICKYUNLOCK_LSB			12
+#define CSR_DXLCDLSTICKYUNLOCK_MASK			BIT(12)
+#define CSR_DXLCDLLIVELOCK_LSB				13
+#define CSR_DXLCDLLIVELOCK_MASK				BIT(13)
+
+/* MASTER0 register offsets */
+/* CSR_RXFIFOINIT */
+#define CSR_RXFIFOINIT_LSB				0
+#define CSR_RXFIFOINIT_MASK				GENMASK_32(1, 0)
+#define CSR_RXFIFOINITPTR_LSB				0
+#define CSR_RXFIFOINITPTR_MASK				BIT(0)
+#define CSR_INHIBITRXFIFORD_LSB				1
+#define CSR_INHIBITRXFIFORD_MASK			BIT(1)
+/* CSR_FORCECLKDISABLE */
+#define CSR_FORCECLKDISABLE_LSB				0
+#define CSR_FORCECLKDISABLE_MASK			GENMASK_32(3, 0)
+/* CSR_CLOCKINGCTRL */
+#define CSR_CLOCKINGCTRL_LSB				0
+#define CSR_CLOCKINGCTRL_MASK				GENMASK_32(1, 0)
+#define CSR_PCLKENASYNCCTRL_LSB				0
+#define CSR_PCLKENASYNCCTRL_MASK			BIT(0)
+#define CSR_DLLTRACKENCTRL_LSB				1
+#define CSR_DLLTRACKENCTRL_MASK				BIT(1)
+/* CSR_FORCEINTERNALUPDATE */
+#define CSR_FORCEINTERNALUPDATE_LSB			0
+#define CSR_FORCEINTERNALUPDATE_MASK			BIT(0)
+/* CSR_PHYCONFIG */
+#define CSR_PHYCONFIG_LSB				0
+#define CSR_PHYCONFIG_MASK				GENMASK_32(9, 0)
+#define CSR_PHYCONFIGANIBS_LSB				0
+#define CSR_PHYCONFIGANIBS_MASK				GENMASK_32(3, 0)
+#define CSR_PHYCONFIGDBYTES_LSB				4
+#define CSR_PHYCONFIGDBYTES_MASK			GENMASK_32(7, 4)
+#define CSR_PHYCONFIGDFI_LSB				8
+#define CSR_PHYCONFIGDFI_MASK				GENMASK_32(9, 8)
+/* CSR_PGCR */
+#define CSR_PGCR_LSB					0
+#define CSR_PGCR_MASK					BIT(0)
+#define CSR_RXCLKRISEFALLMODE_LSB			0
+#define CSR_RXCLKRISEFALLMODE_MASK			BIT(0)
+/* CSR_TESTBUMPCNTRL1 */
+#define CSR_TESTBUMPCNTRL1_LSB				0
+#define CSR_TESTBUMPCNTRL1_MASK				GENMASK_32(15, 0)
+#define CSR_TESTMAJORMODE_LSB				0
+#define CSR_TESTMAJORMODE_MASK				GENMASK_32(2, 0)
+#define CSR_TESTBIASBYPASSEN_LSB			3
+#define CSR_TESTBIASBYPASSEN_MASK			BIT(3)
+#define CSR_TESTANALOGOUTCTRL_LSB			4
+#define CSR_TESTANALOGOUTCTRL_MASK			GENMASK_32(7, 4)
+#define CSR_TESTGAINCURRADJ_LSB				8
+#define CSR_TESTGAINCURRADJ_MASK			GENMASK_32(12, 8)
+#define CSR_TESTSELEXTERNALVREF_LSB			13
+#define CSR_TESTSELEXTERNALVREF_MASK			BIT(13)
+#define CSR_TESTEXTVREFRANGE_LSB			14
+#define CSR_TESTEXTVREFRANGE_MASK			BIT(14)
+#define CSR_TESTPOWERGATEEN_LSB				15
+#define CSR_TESTPOWERGATEEN_MASK			BIT(15)
+/* CSR_CALUCLKINFO */
+#define CSR_CALUCLKINFO_LSB				0
+#define CSR_CALUCLKINFO_MASK				GENMASK_32(10, 0)
+#define CSR_CALUCLKTICKSPER1US_LSB			0
+#define CSR_CALUCLKTICKSPER1US_MASK			GENMASK_32(10, 0)
+/* CSR_TESTBUMPCNTRL */
+#define CSR_TESTBUMPCNTRL_LSB				0
+#define CSR_TESTBUMPCNTRL_MASK				GENMASK_32(9, 0)
+#define CSR_TESTBUMPEN_LSB				0
+#define CSR_TESTBUMPEN_MASK				GENMASK_32(1, 0)
+#define CSR_TESTBUMPTOGGLE_LSB				2
+#define CSR_TESTBUMPTOGGLE_MASK				BIT(2)
+#define CSR_TESTBUMPDATASEL_LSB				3
+#define CSR_TESTBUMPDATASEL_MASK			GENMASK_32(8, 3)
+#define CSR_FORCEMTESTONALERT_LSB			9
+#define CSR_FORCEMTESTONALERT_MASK			BIT(9)
+/* CSR_SEQ0BDLY0 */
+#define CSR_SEQ0BDLY0_LSB				0
+#define CSR_SEQ0BDLY0_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BDLY1 */
+#define CSR_SEQ0BDLY1_LSB				0
+#define CSR_SEQ0BDLY1_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BDLY2 */
+#define CSR_SEQ0BDLY2_LSB				0
+#define CSR_SEQ0BDLY2_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BDLY3 */
+#define CSR_SEQ0BDLY3_LSB				0
+#define CSR_SEQ0BDLY3_MASK				GENMASK_32(15, 0)
+/* CSR_PHYALERTSTATUS */
+#define CSR_PHYALERTSTATUS_LSB				0
+#define CSR_PHYALERTSTATUS_MASK				BIT(0)
+#define CSR_PHYALERT_LSB				0
+#define CSR_PHYALERT_MASK				BIT(0)
+/* CSR_PPTTRAINSETUP */
+#define CSR_PPTTRAINSETUP_LSB				0
+#define CSR_PPTTRAINSETUP_MASK				GENMASK_32(6, 0)
+#define CSR_PHYMSTRTRAININTERVAL_LSB			0
+#define CSR_PHYMSTRTRAININTERVAL_MASK			GENMASK_32(3, 0)
+#define CSR_PHYMSTRMAXREQTOACK_LSB			4
+#define CSR_PHYMSTRMAXREQTOACK_MASK			GENMASK_32(6, 4)
+/* CSR_PPTTRAINSETUP2 */
+#define CSR_PPTTRAINSETUP2_LSB				0
+#define CSR_PPTTRAINSETUP2_MASK				GENMASK_32(2, 0)
+#define CSR_PHYMSTRFREQOVERRIDE_LSB			0
+#define CSR_PHYMSTRFREQOVERRIDE_MASK			GENMASK_32(2, 0)
+/* CSR_ATESTMODE */
+#define CSR_ATESTMODE_LSB				0
+#define CSR_ATESTMODE_MASK				GENMASK_32(4, 0)
+#define CSR_ATESTPRBSEN_LSB				0
+#define CSR_ATESTPRBSEN_MASK				BIT(0)
+#define CSR_ATESTCLKEN_LSB				1
+#define CSR_ATESTCLKEN_MASK				BIT(1)
+#define CSR_ATESTMODESEL_LSB				2
+#define CSR_ATESTMODESEL_MASK				GENMASK_32(4, 2)
+/* CSR_TXCALBINP */
+#define CSR_TXCALBINP_LSB				0
+#define CSR_TXCALBINP_MASK				GENMASK_32(4, 0)
+/* CSR_TXCALBINN */
+#define CSR_TXCALBINN_LSB				0
+#define CSR_TXCALBINN_MASK				GENMASK_32(4, 0)
+/* CSR_TXCALPOVR */
+#define CSR_TXCALPOVR_LSB				0
+#define CSR_TXCALPOVR_MASK				GENMASK_32(5, 0)
+#define CSR_TXCALBINPOVRVAL_LSB				0
+#define CSR_TXCALBINPOVRVAL_MASK			GENMASK_32(4, 0)
+#define CSR_TXCALBINPOVREN_LSB				5
+#define CSR_TXCALBINPOVREN_MASK				BIT(5)
+/* CSR_TXCALNOVR */
+#define CSR_TXCALNOVR_LSB				0
+#define CSR_TXCALNOVR_MASK				GENMASK_32(5, 0)
+#define CSR_TXCALBINNOVRVAL_LSB				0
+#define CSR_TXCALBINNOVRVAL_MASK			GENMASK_32(4, 0)
+#define CSR_TXCALBINNOVREN_LSB				5
+#define CSR_TXCALBINNOVREN_MASK				BIT(5)
+/* CSR_DFIMODE */
+#define CSR_DFIMODE_LSB					0
+#define CSR_DFIMODE_MASK				GENMASK_32(2, 0)
+#define CSR_DFI0ENABLE_LSB				0
+#define CSR_DFI0ENABLE_MASK				BIT(0)
+#define CSR_DFI1ENABLE_LSB				1
+#define CSR_DFI1ENABLE_MASK				BIT(1)
+#define CSR_DFI1OVERRIDE_LSB				2
+#define CSR_DFI1OVERRIDE_MASK				BIT(2)
+/* CSR_TRISTATEMODECA */
+#define CSR_TRISTATEMODECA_LSB				0
+#define CSR_TRISTATEMODECA_MASK				GENMASK_32(3, 0)
+#define CSR_DISDYNADRTRI_LSB				0
+#define CSR_DISDYNADRTRI_MASK				BIT(0)
+#define CSR_DDR2TMODE_LSB				1
+#define CSR_DDR2TMODE_MASK				BIT(1)
+#define CSR_CKDISVAL_LSB				2
+#define CSR_CKDISVAL_MASK				GENMASK_32(3, 2)
+/* MTESTMUXSEL already defined in ANIBx section */
+/* CSR_MTESTPGMINFO */
+#define CSR_MTESTPGMINFO_LSB				0
+#define CSR_MTESTPGMINFO_MASK				BIT(0)
+/* CSR_DYNPWRDNUP */
+#define CSR_DYNPWRDNUP_LSB				0
+#define CSR_DYNPWRDNUP_MASK				BIT(0)
+#define CSR_DYNPOWERDOWN_LSB				0
+#define CSR_DYNPOWERDOWN_MASK				BIT(0)
+/* CSR_PMIENABLE */
+#define CSR_PMIENABLE_LSB				0
+#define CSR_PMIENABLE_MASK				BIT(0)
+/* CSR_PHYTID */
+#define CSR_PHYTID_LSB					0
+#define CSR_PHYTID_MASK					GENMASK_32(15, 0)
+/* CSR_HWTMRL */
+#define CSR_HWTMRL_LSB					0
+#define CSR_HWTMRL_MASK					GENMASK_32(4, 0)
+/* CSR_DFIPHYUPD */
+#define CSR_DFIPHYUPD_LSB				0
+#define CSR_DFIPHYUPD_MASK				GENMASK_32(15, 0)
+#define CSR_DFIPHYUPDCNT_LSB				0
+#define CSR_DFIPHYUPDCNT_MASK				GENMASK_32(3, 0)
+#define CSR_DFIPHYUPDRESP_LSB				4
+#define CSR_DFIPHYUPDRESP_MASK				GENMASK_32(6, 4)
+#define CSR_DFIPHYUPDMODE_LSB				7
+#define CSR_DFIPHYUPDMODE_MASK				BIT(7)
+#define CSR_DFIPHYUPDTHRESHOLD_LSB			8
+#define CSR_DFIPHYUPDTHRESHOLD_MASK			GENMASK_32(11, 8)
+#define CSR_DFIPHYUPDINTTHRESHOLD_LSB			12
+#define CSR_DFIPHYUPDINTTHRESHOLD_MASK			GENMASK_32(15, 12)
+/* CSR_PDAMRSWRITEMODE */
+#define CSR_PDAMRSWRITEMODE_LSB				0
+#define CSR_PDAMRSWRITEMODE_MASK			BIT(0)
+/* CSR_DFIGEARDOWNCTL */
+#define CSR_DFIGEARDOWNCTL_LSB				0
+#define CSR_DFIGEARDOWNCTL_MASK				GENMASK_32(1, 0)
+/* CSR_DQSPREAMBLECONTROL */
+#define CSR_DQSPREAMBLECONTROL_LSB			0
+#define CSR_DQSPREAMBLECONTROL_MASK			GENMASK_32(8, 0)
+#define CSR_TWOTCKRXDQSPRE_LSB				0
+#define CSR_TWOTCKRXDQSPRE_MASK				BIT(0)
+#define CSR_TWOTCKTXDQSPRE_LSB				1
+#define CSR_TWOTCKTXDQSPRE_MASK				BIT(1)
+#define CSR_POSITIONDFEINIT_LSB				2
+#define CSR_POSITIONDFEINIT_MASK			GENMASK_32(4, 2)
+#define CSR_LP4TGLTWOTCKTXDQSPRE_LSB			5
+#define CSR_LP4TGLTWOTCKTXDQSPRE_MASK			BIT(5)
+#define CSR_LP4POSTAMBLEEXT_LSB				6
+#define CSR_LP4POSTAMBLEEXT_MASK			BIT(6)
+#define CSR_LP4STTCPREBRIDGERXEN_LSB			7
+#define CSR_LP4STTCPREBRIDGERXEN_MASK			BIT(7)
+#define CSR_WDQSEXTENSION_LSB				8
+#define CSR_WDQSEXTENSION_MASK				BIT(8)
+/* CSR_MASTERX4CONFIG */
+#define CSR_MASTERX4CONFIG_LSB				0
+#define CSR_MASTERX4CONFIG_MASK				GENMASK_32(3, 0)
+#define CSR_X4TG_LSB					0
+#define CSR_X4TG_MASK					GENMASK_32(3, 0)
+/* CSR_WRLEVBITS */
+#define CSR_WRLEVBITS_LSB				0
+#define CSR_WRLEVBITS_MASK				GENMASK_32(7, 0)
+#define CSR_WRLEVFORDQSL_LSB				0
+#define CSR_WRLEVFORDQSL_MASK				GENMASK_32(3, 0)
+#define CSR_WRLEVFORDQSU_LSB				4
+#define CSR_WRLEVFORDQSU_MASK				GENMASK_32(7, 4)
+/* CSR_ENABLECSMULTICAST */
+#define CSR_ENABLECSMULTICAST_LSB			0
+#define CSR_ENABLECSMULTICAST_MASK			BIT(0)
+/* CSR_HWTLPCSMULTICAST */
+#define CSR_HWTLPCSMULTICAST_LSB			0
+#define CSR_HWTLPCSMULTICAST_MASK			BIT(0)
+/* CSR_ACX4ANIBDIS */
+#define CSR_ACX4ANIBDIS_LSB				0
+#define CSR_ACX4ANIBDIS_MASK				GENMASK_32(11, 0)
+/* CSR_DMIPINPRESENT */
+#define CSR_DMIPINPRESENT_LSB				0
+#define CSR_DMIPINPRESENT_MASK				BIT(0)
+#define CSR_RDDBIENABLED_LSB				0
+#define CSR_RDDBIENABLED_MASK				BIT(0)
+/* CSR_ARDPTRINITVAL */
+#define CSR_ARDPTRINITVAL_LSB				0
+#define CSR_ARDPTRINITVAL_MASK				GENMASK_32(3, 0)
+/* CSR_DB0LCDLCALPHDETOUT */
+#define CSR_DB0LCDLCALPHDETOUT_LSB			0
+#define CSR_DB0LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB1LCDLCALPHDETOUT */
+#define CSR_DB1LCDLCALPHDETOUT_LSB			0
+#define CSR_DB1LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB2LCDLCALPHDETOUT */
+#define CSR_DB2LCDLCALPHDETOUT_LSB			0
+#define CSR_DB2LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB3LCDLCALPHDETOUT */
+#define CSR_DB3LCDLCALPHDETOUT_LSB			0
+#define CSR_DB3LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB4LCDLCALPHDETOUT */
+#define CSR_DB4LCDLCALPHDETOUT_LSB			0
+#define CSR_DB4LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB5LCDLCALPHDETOUT */
+#define CSR_DB5LCDLCALPHDETOUT_LSB			0
+#define CSR_DB5LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB6LCDLCALPHDETOUT */
+#define CSR_DB6LCDLCALPHDETOUT_LSB			0
+#define CSR_DB6LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB7LCDLCALPHDETOUT */
+#define CSR_DB7LCDLCALPHDETOUT_LSB			0
+#define CSR_DB7LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB8LCDLCALPHDETOUT */
+#define CSR_DB8LCDLCALPHDETOUT_LSB			0
+#define CSR_DB8LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DB9LCDLCALPHDETOUT */
+#define CSR_DB9LCDLCALPHDETOUT_LSB			0
+#define CSR_DB9LCDLCALPHDETOUT_MASK			GENMASK_32(15, 0)
+/* CSR_DBYTEDLLMODECNTRL */
+#define CSR_DBYTEDLLMODECNTRL_LSB			1
+#define CSR_DBYTEDLLMODECNTRL_MASK			BIT(1)
+#define CSR_DLLRXPREAMBLEMODE_LSB			1
+#define CSR_DLLRXPREAMBLEMODE_MASK			BIT(1)
+/* CSR_DBYTERXENTRAIN */
+#define CSR_DBYTERXENTRAIN_LSB				0
+#define CSR_DBYTERXENTRAIN_MASK				BIT(0)
+#define CSR_RXENTRAIN_LSB				0
+#define CSR_RXENTRAIN_MASK				BIT(0)
+/* CSR_ANLCDLCALPHDETOUT */
+#define CSR_ANLCDLCALPHDETOUT_LSB			0
+#define CSR_ANLCDLCALPHDETOUT_MASK			GENMASK_32(11, 0)
+/* CSR_CALOFFSETS */
+#define CSR_CALOFFSETS_LSB				0
+#define CSR_CALOFFSETS_MASK				GENMASK_32(13, 0)
+#define CSR_CALCMPR5OFFSET_LSB				0
+#define CSR_CALCMPR5OFFSET_MASK				GENMASK_32(5, 0)
+#define CSR_CALDRVPDTHOFFSET_LSB			6
+#define CSR_CALDRVPDTHOFFSET_MASK			GENMASK_32(9, 6)
+#define CSR_CALDRVPUTHOFFSET_LSB			10
+#define CSR_CALDRVPUTHOFFSET_MASK			GENMASK_32(13, 10)
+/* CSR_SARINITVALS */
+#define CSR_SARINITVALS_LSB				0
+#define CSR_SARINITVALS_MASK				GENMASK_32(8, 0)
+#define CSR_SARINITOFFSET05_LSB				0
+#define CSR_SARINITOFFSET05_MASK			GENMASK_32(2, 0)
+#define CSR_SARINITNINT_LSB				3
+#define CSR_SARINITNINT_MASK				GENMASK_32(5, 3)
+#define CSR_SARINITPEXT_LSB				6
+#define CSR_SARINITPEXT_MASK				GENMASK_32(8, 6)
+/* CSR_CALPEXTOVR */
+#define CSR_CALPEXTOVR_LSB				0
+#define CSR_CALPEXTOVR_MASK				GENMASK_32(4, 0)
+/* CSR_CALCMPR5OVR */
+#define CSR_CALCMPR5OVR_LSB				0
+#define CSR_CALCMPR5OVR_MASK				GENMASK_32(7, 0)
+/* CSR_CALNINTOVR */
+#define CSR_CALNINTOVR_LSB				0
+#define CSR_CALNINTOVR_MASK				GENMASK_32(4, 0)
+/* CSR_CALDRVSTR0 */
+#define CSR_CALDRVSTR0_LSB				0
+#define CSR_CALDRVSTR0_MASK				GENMASK_32(7, 0)
+#define CSR_CALDRVSTRPD50_LSB				0
+#define CSR_CALDRVSTRPD50_MASK				GENMASK_32(3, 0)
+#define CSR_CALDRVSTRPU50_LSB				4
+#define CSR_CALDRVSTRPU50_MASK				GENMASK_32(7, 4)
+/* CSR_PROCODTCTL */
+#define CSR_PROCODTCTL_LSB				0
+#define CSR_PROCODTCTL_MASK				GENMASK_32(1, 0)
+#define CSR_PROCODTALWAYSOFF_LSB			0
+#define CSR_PROCODTALWAYSOFF_MASK			BIT(0)
+#define CSR_PROCODTALWAYSON_LSB				1
+#define CSR_PROCODTALWAYSON_MASK			BIT(1)
+/* CSR_PROCODTTIMECTL */
+#define CSR_PROCODTTIMECTL_LSB				0
+#define CSR_PROCODTTIMECTL_MASK				GENMASK_32(5, 0)
+#define CSR_PODTTAILWIDTH_LSB				0
+#define CSR_PODTTAILWIDTH_MASK				GENMASK_32(1, 0)
+#define CSR_PODTSTARTDELAY_LSB				2
+#define CSR_PODTSTARTDELAY_MASK				GENMASK_32(3, 2)
+#define CSR_PODTTAILWIDTHEXT_LSB			4
+#define CSR_PODTTAILWIDTHEXT_MASK			GENMASK_32(5, 4)
+/* CSR_MEMALERTCONTROL */
+#define CSR_MEMALERTCONTROL_LSB				0
+#define CSR_MEMALERTCONTROL_MASK			GENMASK_32(15, 0)
+#define CSR_MALERTVREFLEVEL_LSB				0
+#define CSR_MALERTVREFLEVEL_MASK			GENMASK_32(6, 0)
+#define CSR_MALERTVREFEXTEN_LSB				7
+#define CSR_MALERTVREFEXTEN_MASK			BIT(7)
+#define CSR_MALERTPUSTREN_LSB				8
+#define CSR_MALERTPUSTREN_MASK				GENMASK_32(11, 8)
+#define CSR_MALERTPUEN_LSB				12
+#define CSR_MALERTPUEN_MASK				BIT(12)
+#define CSR_MALERTRXEN_LSB				13
+#define CSR_MALERTRXEN_MASK				BIT(13)
+#define CSR_MALERTDISABLEVAL_LSB			14
+#define CSR_MALERTDISABLEVAL_MASK			BIT(14)
+#define CSR_MALERTFORCEERROR_LSB			15
+#define CSR_MALERTFORCEERROR_MASK			BIT(15)
+/* CSR_MEMALERTCONTROL2 */
+#define CSR_MEMALERTCONTROL2_LSB			0
+#define CSR_MEMALERTCONTROL2_MASK			BIT(0)
+#define CSR_MALERTSYNCBYPASS_LSB			0
+#define CSR_MALERTSYNCBYPASS_MASK			BIT(0)
+/* CSR_MEMRESETL */
+#define CSR_MEMRESETL_LSB				0
+#define CSR_MEMRESETL_MASK				GENMASK_32(1, 0)
+#define CSR_MEMRESETLVALUE_LSB				0
+#define CSR_MEMRESETLVALUE_MASK				BIT(0)
+#define CSR_PROTECTMEMRESET_LSB				1
+#define CSR_PROTECTMEMRESET_MASK			BIT(1)
+/* CSR_PUBMODE */
+#define CSR_PUBMODE_LSB					0
+#define CSR_PUBMODE_MASK				BIT(0)
+#define CSR_HWTMEMSRC_LSB				0
+#define CSR_HWTMEMSRC_MASK				BIT(0)
+/* CSR_MISCPHYSTATUS */
+#define CSR_MISCPHYSTATUS_LSB				0
+#define CSR_MISCPHYSTATUS_MASK				GENMASK_32(1, 0)
+#define CSR_DCTSANE_LSB					0
+#define CSR_DCTSANE_MASK				BIT(0)
+#define CSR_PORMEMRESET_LSB				1
+#define CSR_PORMEMRESET_MASK				BIT(1)
+/* CSR_CORELOOPBACKSEL */
+#define CSR_CORELOOPBACKSEL_LSB				0
+#define CSR_CORELOOPBACKSEL_MASK			BIT(0)
+/* CSR_DLLTRAINPARAM */
+#define CSR_DLLTRAINPARAM_LSB				0
+#define CSR_DLLTRAINPARAM_MASK				GENMASK_32(1, 0)
+#define CSR_EXTENDPHDTIME_LSB				0
+#define CSR_EXTENDPHDTIME_MASK				GENMASK_32(1, 0)
+/* CSR_HWTLPCSENA */
+#define CSR_HWTLPCSENA_LSB				0
+#define CSR_HWTLPCSENA_MASK				GENMASK_32(1, 0)
+/* CSR_HWTLPCSENB */
+#define CSR_HWTLPCSENB_LSB				0
+#define CSR_HWTLPCSENB_MASK				GENMASK_32(1, 0)
+/* CSR_HWTLPCSENBYPASS */
+#define CSR_HWTLPCSENBYPASS_LSB				0
+#define CSR_HWTLPCSENBYPASS_MASK			BIT(0)
+/* CSR_DFICAMODE */
+#define CSR_DFICAMODE_LSB				0
+#define CSR_DFICAMODE_MASK				GENMASK_32(3, 0)
+#define CSR_DFILP3CAMODE_LSB				0
+#define CSR_DFILP3CAMODE_MASK				BIT(0)
+#define CSR_DFID4CAMODE_LSB				1
+#define CSR_DFID4CAMODE_MASK				BIT(1)
+#define CSR_DFILP4CAMODE_LSB				2
+#define CSR_DFILP4CAMODE_MASK				BIT(2)
+#define CSR_DFID4ALTCAMODE_LSB				3
+#define CSR_DFID4ALTCAMODE_MASK				BIT(3)
+/* CSR_HWTCACTL */
+#define CSR_HWTCACTL_LSB				0
+#define CSR_HWTCACTL_MASK				BIT(0)
+#define CSR_HWTDISDYNADRTRI_LSB				0
+#define CSR_HWTDISDYNADRTRI_MASK			BIT(0)
+/* CSR_HWTCAMODE */
+#define CSR_HWTCAMODE_LSB				0
+#define CSR_HWTCAMODE_MASK				GENMASK_32(5, 0)
+#define CSR_HWTLP3CAMODE_LSB				0
+#define CSR_HWTLP3CAMODE_MASK				BIT(0)
+#define CSR_HWTD4CAMODE_LSB				1
+#define CSR_HWTD4CAMODE_MASK				BIT(1)
+#define CSR_HWTLP4CAMODE_LSB				2
+#define CSR_HWTLP4CAMODE_MASK				BIT(2)
+#define CSR_HWTD4ALTCAMODE_LSB				3
+#define CSR_HWTD4ALTCAMODE_MASK				BIT(3)
+#define CSR_HWTCSINVERT_LSB				4
+#define CSR_HWTCSINVERT_MASK				BIT(4)
+#define CSR_HWTDBIINVERT_LSB				5
+#define CSR_HWTDBIINVERT_MASK				BIT(5)
+/* CSR_DLLCONTROL */
+#define CSR_DLLCONTROL_LSB				0
+#define CSR_DLLCONTROL_MASK				GENMASK_32(2, 0)
+#define CSR_DLLRESETRELOCK_LSB				0
+#define CSR_DLLRESETRELOCK_MASK				BIT(0)
+#define CSR_DLLRESETSLAVE_LSB				1
+#define CSR_DLLRESETSLAVE_MASK				BIT(1)
+#define CSR_DLLRESETRSVD_LSB				2
+#define CSR_DLLRESETRSVD_MASK				BIT(2)
+/* CSR_PULSEDLLUPDATEPHASE */
+#define CSR_PULSEDLLUPDATEPHASE_LSB			0
+#define CSR_PULSEDLLUPDATEPHASE_MASK			GENMASK_32(7, 0)
+#define CSR_PULSEDBYTEDLLUPDATEPHASE_LSB		0
+#define CSR_PULSEDBYTEDLLUPDATEPHASE_MASK		BIT(0)
+#define CSR_PULSEACKDLLUPDATEPHASE_LSB			1
+#define CSR_PULSEACKDLLUPDATEPHASE_MASK			BIT(1)
+#define CSR_PULSEACADLLUPDATEPHASE_LSB			2
+#define CSR_PULSEACADLLUPDATEPHASE_MASK			BIT(2)
+#define CSR_UPDATEPHASEDESTRESERVED_LSB			3
+#define CSR_UPDATEPHASEDESTRESERVED_MASK		GENMASK_32(5, 3)
+#define CSR_TRAINUPDATEPHASEONLONGBUBBLE_LSB		6
+#define CSR_TRAINUPDATEPHASEONLONGBUBBLE_MASK		BIT(6)
+#define CSR_ALWAYSUPDATELCDLPHASE_LSB			7
+#define CSR_ALWAYSUPDATELCDLPHASE_MASK			BIT(7)
+/* CSR_HWTCONTROLOVR0 */
+#define CSR_HWTCONTROLOVR0_LSB				0
+#define CSR_HWTCONTROLOVR0_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0OVR0_LSB				0
+#define CSR_HWTCS0OVR0_MASK				BIT(0)
+#define CSR_HWTCS1OVR0_LSB				1
+#define CSR_HWTCS1OVR0_MASK				BIT(1)
+#define CSR_HWTCS2OVR0_LSB				2
+#define CSR_HWTCS2OVR0_MASK				BIT(2)
+#define CSR_HWTCS3OVR0_LSB				3
+#define CSR_HWTCS3OVR0_MASK				BIT(3)
+#define CSR_HWTCKE0OVR0_LSB				4
+#define CSR_HWTCKE0OVR0_MASK				BIT(4)
+#define CSR_HWTCKE1OVR0_LSB				5
+#define CSR_HWTCKE1OVR0_MASK				BIT(5)
+#define CSR_HWTCKE2OVR0_LSB				6
+#define CSR_HWTCKE2OVR0_MASK				BIT(6)
+#define CSR_HWTCKE3OVR0_LSB				7
+#define CSR_HWTCKE3OVR0_MASK				BIT(7)
+#define CSR_HWTODT0OVR0_LSB				8
+#define CSR_HWTODT0OVR0_MASK				BIT(8)
+#define CSR_HWTODT1OVR0_LSB				9
+#define CSR_HWTODT1OVR0_MASK				BIT(9)
+#define CSR_HWTODT2OVR0_LSB				10
+#define CSR_HWTODT2OVR0_MASK				BIT(10)
+#define CSR_HWTODT3OVR0_LSB				11
+#define CSR_HWTODT3OVR0_MASK				BIT(11)
+#define CSR_HWTPARITYOVR0_LSB				12
+#define CSR_HWTPARITYOVR0_MASK				BIT(12)
+/* CSR_HWTCONTROLOVR1 */
+#define CSR_HWTCONTROLOVR1_LSB				0
+#define CSR_HWTCONTROLOVR1_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0OVR1_LSB				0
+#define CSR_HWTCS0OVR1_MASK				BIT(0)
+#define CSR_HWTCS1OVR1_LSB				1
+#define CSR_HWTCS1OVR1_MASK				BIT(1)
+#define CSR_HWTCS2OVR1_LSB				2
+#define CSR_HWTCS2OVR1_MASK				BIT(2)
+#define CSR_HWTCS3OVR1_LSB				3
+#define CSR_HWTCS3OVR1_MASK				BIT(3)
+#define CSR_HWTCKE0OVR1_LSB				4
+#define CSR_HWTCKE0OVR1_MASK				BIT(4)
+#define CSR_HWTCKE1OVR1_LSB				5
+#define CSR_HWTCKE1OVR1_MASK				BIT(5)
+#define CSR_HWTCKE2OVR1_LSB				6
+#define CSR_HWTCKE2OVR1_MASK				BIT(6)
+#define CSR_HWTCKE3OVR1_LSB				7
+#define CSR_HWTCKE3OVR1_MASK				BIT(7)
+#define CSR_HWTODT0OVR1_LSB				8
+#define CSR_HWTODT0OVR1_MASK				BIT(8)
+#define CSR_HWTODT1OVR1_LSB				9
+#define CSR_HWTODT1OVR1_MASK				BIT(9)
+#define CSR_HWTODT2OVR1_LSB				10
+#define CSR_HWTODT2OVR1_MASK				BIT(10)
+#define CSR_HWTODT3OVR1_LSB				11
+#define CSR_HWTODT3OVR1_MASK				BIT(11)
+#define CSR_HWTPARITYOVR1_LSB				12
+#define CSR_HWTPARITYOVR1_MASK				BIT(12)
+/* CSR_DLLGAINCTL */
+#define CSR_DLLGAINCTL_LSB				0
+#define CSR_DLLGAINCTL_MASK				GENMASK_32(11, 0)
+#define CSR_DLLGAINIV_LSB				0
+#define CSR_DLLGAINIV_MASK				GENMASK_32(3, 0)
+#define CSR_DLLGAINTV_LSB				4
+#define CSR_DLLGAINTV_MASK				GENMASK_32(7, 4)
+#define CSR_DLLSEEDSEL_LSB				8
+#define CSR_DLLSEEDSEL_MASK				GENMASK_32(11, 8)
+/* CSR_DLLLOCKPARAM */
+#define CSR_DLLLOCKPARAM_LSB				0
+#define CSR_DLLLOCKPARAM_MASK				GENMASK_32(12, 0)
+#define CSR_DISDLLSEEDSEL_LSB				0
+#define CSR_DISDLLSEEDSEL_MASK				BIT(0)
+#define CSR_DISDLLGAINIVSEED_LSB			1
+#define CSR_DISDLLGAINIVSEED_MASK			BIT(1)
+#define CSR_DLLLOCKPARAMSPARE_LSB			2
+#define CSR_DLLLOCKPARAMSPARE_MASK			GENMASK_32(3, 2)
+#define CSR_LCDLSEED0_LSB				4
+#define CSR_LCDLSEED0_MASK				GENMASK_32(12, 4)
+/* CSR_HWTCONTROLVAL0 */
+#define CSR_HWTCONTROLVAL0_LSB				0
+#define CSR_HWTCONTROLVAL0_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0VAL0_LSB				0
+#define CSR_HWTCS0VAL0_MASK				BIT(0)
+#define CSR_HWTCS1VAL0_LSB				1
+#define CSR_HWTCS1VAL0_MASK				BIT(1)
+#define CSR_HWTCS2VAL0_LSB				2
+#define CSR_HWTCS2VAL0_MASK				BIT(2)
+#define CSR_HWTCS3VAL0_LSB				3
+#define CSR_HWTCS3VAL0_MASK				BIT(3)
+#define CSR_HWTCKE0VAL0_LSB				4
+#define CSR_HWTCKE0VAL0_MASK				BIT(4)
+#define CSR_HWTCKE1VAL0_LSB				5
+#define CSR_HWTCKE1VAL0_MASK				BIT(5)
+#define CSR_HWTCKE2VAL0_LSB				6
+#define CSR_HWTCKE2VAL0_MASK				BIT(6)
+#define CSR_HWTCKE3VAL0_LSB				7
+#define CSR_HWTCKE3VAL0_MASK				BIT(7)
+#define CSR_HWTODT0VAL0_LSB				8
+#define CSR_HWTODT0VAL0_MASK				BIT(8)
+#define CSR_HWTODT1VAL0_LSB				9
+#define CSR_HWTODT1VAL0_MASK				BIT(9)
+#define CSR_HWTODT2VAL0_LSB				10
+#define CSR_HWTODT2VAL0_MASK				BIT(10)
+#define CSR_HWTODT3VAL0_LSB				11
+#define CSR_HWTODT3VAL0_MASK				BIT(11)
+#define CSR_HWTPARITYVAL0_LSB				12
+#define CSR_HWTPARITYVAL0_MASK				BIT(12)
+/* CSR_HWTCONTROLVAL1 */
+#define CSR_HWTCONTROLVAL1_LSB				0
+#define CSR_HWTCONTROLVAL1_MASK				GENMASK_32(12, 0)
+#define CSR_HWTCS0VAL1_LSB				0
+#define CSR_HWTCS0VAL1_MASK				BIT(0)
+#define CSR_HWTCS1VAL1_LSB				1
+#define CSR_HWTCS1VAL1_MASK				BIT(1)
+#define CSR_HWTCS2VAL1_LSB				2
+#define CSR_HWTCS2VAL1_MASK				BIT(2)
+#define CSR_HWTCS3VAL1_LSB				3
+#define CSR_HWTCS3VAL1_MASK				BIT(3)
+#define CSR_HWTCKE0VAL1_LSB				4
+#define CSR_HWTCKE0VAL1_MASK				BIT(4)
+#define CSR_HWTCKE1VAL1_LSB				5
+#define CSR_HWTCKE1VAL1_MASK				BIT(5)
+#define CSR_HWTCKE2VAL1_LSB				6
+#define CSR_HWTCKE2VAL1_MASK				BIT(6)
+#define CSR_HWTCKE3VAL1_LSB				7
+#define CSR_HWTCKE3VAL1_MASK				BIT(7)
+#define CSR_HWTODT0VAL1_LSB				8
+#define CSR_HWTODT0VAL1_MASK				BIT(8)
+#define CSR_HWTODT1VAL1_LSB				9
+#define CSR_HWTODT1VAL1_MASK				BIT(9)
+#define CSR_HWTODT2VAL1_LSB				10
+#define CSR_HWTODT2VAL1_MASK				BIT(10)
+#define CSR_HWTODT3VAL1_LSB				11
+#define CSR_HWTODT3VAL1_MASK				BIT(11)
+#define CSR_HWTPARITYVAL1_LSB				12
+#define CSR_HWTPARITYVAL1_MASK				BIT(12)
+/* CSR_ACSMGLBLSTART */
+#define CSR_ACSMGLBLSTART_LSB				0
+#define CSR_ACSMGLBLSTART_MASK				BIT(0)
+/* CSR_ACSMGLBLSGLSTPCTRL */
+#define CSR_ACSMGLBLSGLSTPCTRL_LSB			0
+#define CSR_ACSMGLBLSGLSTPCTRL_MASK			GENMASK_32(1, 0)
+#define CSR_ACSMSGLSTPMODE_LSB				0
+#define CSR_ACSMSGLSTPMODE_MASK				BIT(0)
+#define CSR_ACSMSGLSTP_LSB				1
+#define CSR_ACSMSGLSTP_MASK				BIT(1)
+/* CSR_LCDLCALPHASE */
+#define CSR_LCDLCALPHASE_LSB				0
+#define CSR_LCDLCALPHASE_MASK				GENMASK_32(8, 0)
+/* CSR_LCDLCALCTRL */
+#define CSR_LCDLCALCTRL_LSB				0
+#define CSR_LCDLCALCTRL_MASK				GENMASK_32(6, 0)
+#define CSR_LCDLCALMODE_LSB				0
+#define CSR_LCDLCALMODE_MASK				BIT(0)
+#define CSR_LCDLCALSLOWCLKSEL_LSB			1
+#define CSR_LCDLCALSLOWCLKSEL_MASK			BIT(1)
+#define CSR_LCDLCALEN_LSB				2
+#define CSR_LCDLCALEN_MASK				BIT(2)
+#define CSR_LCDLCALPHASEUPDATE_LSB			3
+#define CSR_LCDLCALPHASEUPDATE_MASK			BIT(3)
+#define CSR_LCDLCALCLKEN_LSB				4
+#define CSR_LCDLCALCLKEN_MASK				BIT(4)
+#define CSR_LCDLCALSAMPEN_LSB				5
+#define CSR_LCDLCALSAMPEN_MASK				BIT(5)
+#define CSR_LCDLCALSLOWCLKEN_LSB			6
+#define CSR_LCDLCALSLOWCLKEN_MASK			BIT(6)
+/* CSR_CALRATE */
+#define CSR_CALRATE_LSB					0
+#define CSR_CALRATE_MASK				GENMASK_32(6, 0)
+#define CSR_CALINTERVAL_LSB				0
+#define CSR_CALINTERVAL_MASK				GENMASK_32(3, 0)
+#define CSR_CALRUN_LSB					4
+#define CSR_CALRUN_MASK					BIT(4)
+#define CSR_CALONCE_LSB					5
+#define CSR_CALONCE_MASK				BIT(5)
+#define CSR_DISABLEBACKGROUNDZQUPDATES_LSB		6
+#define CSR_DISABLEBACKGROUNDZQUPDATES_MASK		BIT(6)
+/* CSR_CALZAP */
+#define CSR_CALZAP_LSB					0
+#define CSR_CALZAP_MASK					BIT(0)
+/* CSR_PSTATE */
+#define CSR_PSTATE_LSB					0
+#define CSR_PSTATE_MASK					GENMASK_32(3, 0)
+/* CSR_CALPREDRIVEROVERRIDE */
+#define CSR_CALPREDRIVEROVERRIDE_LSB			0
+#define CSR_CALPREDRIVEROVERRIDE_MASK			GENMASK_32(7, 0)
+#define CSR_TXPREOVN_LSB				0
+#define CSR_TXPREOVN_MASK				GENMASK_32(3, 0)
+#define CSR_TXPREOVP_LSB				4
+#define CSR_TXPREOVP_MASK				GENMASK_32(7, 4)
+/* CSR_PLLOUTGATECONTROL */
+#define CSR_PLLOUTGATECONTROL_LSB			0
+#define CSR_PLLOUTGATECONTROL_MASK			GENMASK_32(1, 0)
+#define CSR_PCLKGATEEN_LSB				0
+#define CSR_PCLKGATEEN_MASK				BIT(0)
+#define CSR_RESERVED2X1_LSB				1
+#define CSR_RESERVED2X1_MASK				BIT(1)
+/* CSR_UCMEMRESETCONTROL */
+#define CSR_UCMEMRESETCONTROL_LSB			0
+#define CSR_UCMEMRESETCONTROL_MASK			BIT(0)
+#define CSR_UCDCTSANE_LSB				0
+#define CSR_UCDCTSANE_MASK				BIT(0)
+/* CSR_PORCONTROL */
+#define CSR_PORCONTROL_LSB				0
+#define CSR_PORCONTROL_MASK				BIT(0)
+#define CSR_PLLDLLLOCKDONE_LSB				0
+#define CSR_PLLDLLLOCKDONE_MASK				BIT(0)
+/* CSR_CALBUSY */
+#define CSR_CALBUSY_LSB					0
+#define CSR_CALBUSY_MASK				BIT(0)
+/* CSR_CALMISC2 */
+#define CSR_CALMISC2_LSB				0
+#define CSR_CALMISC2_MASK				GENMASK_32(15, 0)
+#define CSR_CALNUMVOTES_LSB				0
+#define CSR_CALNUMVOTES_MASK				GENMASK_32(2, 0)
+#define CSR_RESERVED10X3_LSB				3
+#define CSR_RESERVED10X3_MASK				GENMASK_32(10, 3)
+#define CSR_RESERVED11_LSB				11
+#define CSR_RESERVED11_MASK				BIT(11)
+#define CSR_CALCMPTRRESTRIM_LSB				12
+#define CSR_CALCMPTRRESTRIM_MASK			BIT(12)
+#define CSR_CALCANCELROUNDERRDIS_LSB			13
+#define CSR_CALCANCELROUNDERRDIS_MASK			BIT(13)
+#define CSR_CALSLOWCMPANA_LSB				14
+#define CSR_CALSLOWCMPANA_MASK				BIT(14)
+#define CSR_RESERVED15_LSB				15
+#define CSR_RESERVED15_MASK				BIT(15)
+/* CSR_CALMISC */
+#define CSR_CALMISC_LSB					0
+#define CSR_CALMISC_MASK				GENMASK_32(2, 0)
+#define CSR_CALCMPR5DIS_LSB				0
+#define CSR_CALCMPR5DIS_MASK				BIT(0)
+#define CSR_CALNINTDIS_LSB				1
+#define CSR_CALNINTDIS_MASK				BIT(1)
+#define CSR_CALPEXTDIS_LSB				2
+#define CSR_CALPEXTDIS_MASK				BIT(2)
+/* CSR_CALVREFS */
+#define CSR_CALVREFS_LSB				0
+#define CSR_CALVREFS_MASK				GENMASK_32(1, 0)
+/* CSR_CALCMPR5 */
+#define CSR_CALCMPR5_LSB				0
+#define CSR_CALCMPR5_MASK				GENMASK_32(7, 0)
+/* CSR_CALNINT */
+#define CSR_CALNINT_LSB					0
+#define CSR_CALNINT_MASK				GENMASK_32(4, 0)
+#define CSR_CALNINTTHB_LSB				0
+#define CSR_CALNINTTHB_MASK				GENMASK_32(4, 0)
+/* CSR_CALPEXT */
+#define CSR_CALPEXT_LSB					0
+#define CSR_CALPEXT_MASK				GENMASK_32(4, 0)
+#define CSR_CALPEXTTHB_LSB				0
+#define CSR_CALPEXTTHB_MASK				GENMASK_32(4, 0)
+/* CSR_CALCMPINVERT */
+#define CSR_CALCMPINVERT_LSB				0
+#define CSR_CALCMPINVERT_MASK				GENMASK_32(4, 0)
+#define CSR_CMPINVERTCALDAC50_LSB			0
+#define CSR_CMPINVERTCALDAC50_MASK			BIT(0)
+#define CSR_CMPINVERTCALDRVPD50_LSB			1
+#define CSR_CMPINVERTCALDRVPD50_MASK			BIT(1)
+#define CSR_CMPINVERTCALDRVPU50_LSB			2
+#define CSR_CMPINVERTCALDRVPU50_MASK			BIT(2)
+#define CSR_CMPINVERTCALODTPD_LSB			3
+#define CSR_CMPINVERTCALODTPD_MASK			BIT(3)
+#define CSR_CMPINVERTCALODTPU_LSB			4
+#define CSR_CMPINVERTCALODTPU_MASK			BIT(4)
+/* CSR_CALCMPANACNTRL */
+#define CSR_CALCMPANACNTRL_LSB				0
+#define CSR_CALCMPANACNTRL_MASK				GENMASK_32(9, 0)
+#define CSR_CMPRGAINCURRADJ_LSB				0
+#define CSR_CMPRGAINCURRADJ_MASK			GENMASK_32(7, 0)
+#define CSR_CMPRGAINRESADJ_LSB				8
+#define CSR_CMPRGAINRESADJ_MASK				BIT(8)
+#define CSR_CMPRBIASBYPASSEN_LSB			9
+#define CSR_CMPRBIASBYPASSEN_MASK			BIT(9)
+/* CSR_DFIRDDATACSDESTMAP */
+#define CSR_DFIRDDATACSDESTMAP_LSB			0
+#define CSR_DFIRDDATACSDESTMAP_MASK			GENMASK_32(7, 0)
+#define CSR_DFIRDDESTM0_LSB				0
+#define CSR_DFIRDDESTM0_MASK				GENMASK_32(1, 0)
+#define CSR_DFIRDDESTM1_LSB				2
+#define CSR_DFIRDDESTM1_MASK				GENMASK_32(3, 2)
+#define CSR_DFIRDDESTM2_LSB				4
+#define CSR_DFIRDDESTM2_MASK				GENMASK_32(5, 4)
+#define CSR_DFIRDDESTM3_LSB				6
+#define CSR_DFIRDDESTM3_MASK				GENMASK_32(7, 6)
+/* CSR_VREFINGLOBAL */
+#define CSR_VREFINGLOBAL_LSB				0
+#define CSR_VREFINGLOBAL_MASK				GENMASK_32(14, 0)
+#define CSR_GLOBALVREFINSEL_LSB				0
+#define CSR_GLOBALVREFINSEL_MASK			GENMASK_32(2, 0)
+#define CSR_GLOBALVREFINDAC_LSB				3
+#define CSR_GLOBALVREFINDAC_MASK			GENMASK_32(9, 3)
+#define CSR_GLOBALVREFINTRIM_LSB			10
+#define CSR_GLOBALVREFINTRIM_MASK			GENMASK_32(13, 10)
+#define CSR_GLOBALVREFINMODE_LSB			14
+#define CSR_GLOBALVREFINMODE_MASK			BIT(14)
+/* CSR_DFIWRDATACSDESTMAP */
+#define CSR_DFIWRDATACSDESTMAP_LSB			0
+#define CSR_DFIWRDATACSDESTMAP_MASK			GENMASK_32(7, 0)
+#define CSR_DFIWRDESTM0_LSB				0
+#define CSR_DFIWRDESTM0_MASK				GENMASK_32(1, 0)
+#define CSR_DFIWRDESTM1_LSB				2
+#define CSR_DFIWRDESTM1_MASK				GENMASK_32(3, 2)
+#define CSR_DFIWRDESTM2_LSB				4
+#define CSR_DFIWRDESTM2_MASK				GENMASK_32(5, 4)
+#define CSR_DFIWRDESTM3_LSB				6
+#define CSR_DFIWRDESTM3_MASK				GENMASK_32(7, 6)
+/* CSR_MASUPDGOODCTR */
+#define CSR_MASUPDGOODCTR_LSB				0
+#define CSR_MASUPDGOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD0GOODCTR */
+#define CSR_PHYUPD0GOODCTR_LSB				0
+#define CSR_PHYUPD0GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD1GOODCTR */
+#define CSR_PHYUPD1GOODCTR_LSB				0
+#define CSR_PHYUPD1GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_CTLUPD0GOODCTR */
+#define CSR_CTLUPD0GOODCTR_LSB				0
+#define CSR_CTLUPD0GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_CTLUPD1GOODCTR */
+#define CSR_CTLUPD1GOODCTR_LSB				0
+#define CSR_CTLUPD1GOODCTR_MASK				GENMASK_32(15, 0)
+/* CSR_MASUPDFAILCTR */
+#define CSR_MASUPDFAILCTR_LSB				0
+#define CSR_MASUPDFAILCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD0FAILCTR */
+#define CSR_PHYUPD0FAILCTR_LSB				0
+#define CSR_PHYUPD0FAILCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYUPD1FAILCTR */
+#define CSR_PHYUPD1FAILCTR_LSB				0
+#define CSR_PHYUPD1FAILCTR_MASK				GENMASK_32(15, 0)
+/* CSR_PHYPERFCTRENABLE */
+#define CSR_PHYPERFCTRENABLE_LSB			0
+#define CSR_PHYPERFCTRENABLE_MASK			GENMASK_32(7, 0)
+#define CSR_MASUPDGOODCTL_LSB				0
+#define CSR_MASUPDGOODCTL_MASK				BIT(0)
+#define CSR_PHYUPD0GOODCTL_LSB				1
+#define CSR_PHYUPD0GOODCTL_MASK				BIT(1)
+#define CSR_PHYUPD1GOODCTL_LSB				2
+#define CSR_PHYUPD1GOODCTL_MASK				BIT(2)
+#define CSR_CTLUPD0GOODCTL_LSB				3
+#define CSR_CTLUPD0GOODCTL_MASK				BIT(3)
+#define CSR_CTLUPD1GOODCTL_LSB				4
+#define CSR_CTLUPD1GOODCTL_MASK				BIT(4)
+#define CSR_MASUPDFAILCTL_LSB				5
+#define CSR_MASUPDFAILCTL_MASK				BIT(5)
+#define CSR_PHYUPD0FAILCTL_LSB				6
+#define CSR_PHYUPD0FAILCTL_MASK				BIT(6)
+#define CSR_PHYUPD1FAILCTL_LSB				7
+#define CSR_PHYUPD1FAILCTL_MASK				BIT(7)
+/* CSR_DFIWRRDDATACSCONFIG */
+#define CSR_DFIWRRDDATACSCONFIG_LSB			0
+#define CSR_DFIWRRDDATACSCONFIG_MASK			GENMASK_32(1, 0)
+#define CSR_DFIWRDATACSPOLARITY_LSB			0
+#define CSR_DFIWRDATACSPOLARITY_MASK			BIT(0)
+#define CSR_DFIRDDATACSPOLARITY_LSB			1
+#define CSR_DFIRDDATACSPOLARITY_MASK			BIT(1)
+/* CSR_PLLPWRDN */
+#define CSR_PLLPWRDN_LSB				0
+#define CSR_PLLPWRDN_MASK				BIT(0)
+/* CSR_PLLRESET */
+#define CSR_PLLRESET_LSB				0
+#define CSR_PLLRESET_MASK				BIT(0)
+/* CSR_PLLCTRL2 */
+#define CSR_PLLCTRL2_LSB				0
+#define CSR_PLLCTRL2_MASK				GENMASK_32(4, 0)
+#define CSR_PLLFREQSEL_LSB				0
+#define CSR_PLLFREQSEL_MASK				GENMASK_32(4, 0)
+/* CSR_PLLCTRL0 */
+#define CSR_PLLCTRL0_LSB				0
+#define CSR_PLLCTRL0_MASK				GENMASK_32(15, 0)
+#define CSR_PLLSTANDBY_LSB				0
+#define CSR_PLLSTANDBY_MASK				BIT(0)
+#define CSR_PLLBYPSEL_LSB				1
+#define CSR_PLLBYPSEL_MASK				BIT(1)
+#define CSR_PLLX2MODE_LSB				2
+#define CSR_PLLX2MODE_MASK				BIT(2)
+#define CSR_PLLOUTBYPEN_LSB				3
+#define CSR_PLLOUTBYPEN_MASK				BIT(3)
+#define CSR_PLLPRESET_LSB				4
+#define CSR_PLLPRESET_MASK				BIT(4)
+#define CSR_PLLBYPASSMODE_LSB				5
+#define CSR_PLLBYPASSMODE_MASK				BIT(5)
+#define CSR_PLLSELDFIFREQRATIO_LSB			6
+#define CSR_PLLSELDFIFREQRATIO_MASK			BIT(6)
+#define CSR_PLLSYNCBUSFLUSH_LSB				7
+#define CSR_PLLSYNCBUSFLUSH_MASK			BIT(7)
+#define CSR_PLLSYNCBUSBYP_LSB				8
+#define CSR_PLLSYNCBUSBYP_MASK				BIT(8)
+#define CSR_PLLRESERVED10X9_LSB				9
+#define CSR_PLLRESERVED10X9_MASK			GENMASK_32(10, 9)
+#define CSR_PLLGEARSHIFT_LSB				11
+#define CSR_PLLGEARSHIFT_MASK				BIT(11)
+#define CSR_PLLLOCKCNTSEL_LSB				12
+#define CSR_PLLLOCKCNTSEL_MASK				BIT(12)
+#define CSR_PLLLOCKPHSEL_LSB				13
+#define CSR_PLLLOCKPHSEL_MASK				GENMASK_32(14, 13)
+#define CSR_PLLSPARECTRL0_LSB				15
+#define CSR_PLLSPARECTRL0_MASK				BIT(15)
+/* CSR_PLLCTRL1 */
+#define CSR_PLLCTRL1_LSB				0
+#define CSR_PLLCTRL1_MASK				GENMASK_32(8, 0)
+#define CSR_PLLCPINTCTRL_LSB				0
+#define CSR_PLLCPINTCTRL_MASK				GENMASK_32(4, 0)
+#define CSR_PLLCPPROPCTRL_LSB				5
+#define CSR_PLLCPPROPCTRL_MASK				GENMASK_32(8, 5)
+/* CSR_PLLTST */
+#define CSR_PLLTST_LSB					0
+#define CSR_PLLTST_MASK					GENMASK_32(8, 0)
+#define CSR_PLLANATSTEN_LSB				0
+#define CSR_PLLANATSTEN_MASK				BIT(0)
+#define CSR_PLLANATSTSEL_LSB				1
+#define CSR_PLLANATSTSEL_MASK				GENMASK_32(4, 1)
+#define CSR_PLLDIGTSTSEL_LSB				5
+#define CSR_PLLDIGTSTSEL_MASK				GENMASK_32(8, 5)
+/* CSR_PLLLOCKSTATUS */
+#define CSR_PLLLOCKSTATUS_LSB				0
+#define CSR_PLLLOCKSTATUS_MASK				BIT(0)
+/* CSR_PLLTESTMODE */
+#define CSR_PLLTESTMODE_LSB				0
+#define CSR_PLLTESTMODE_MASK				GENMASK_32(15, 0)
+/* CSR_PLLCTRL3 */
+#define CSR_PLLCTRL3_LSB				0
+#define CSR_PLLCTRL3_MASK				GENMASK_32(15, 0)
+#define CSR_PLLSPARE_LSB				0
+#define CSR_PLLSPARE_MASK				GENMASK_32(3, 0)
+#define CSR_PLLMAXRANGE_LSB				4
+#define CSR_PLLMAXRANGE_MASK				GENMASK_32(8, 4)
+#define CSR_PLLDACVALIN_LSB				9
+#define CSR_PLLDACVALIN_MASK				GENMASK_32(13, 9)
+#define CSR_PLLFORCECAL_LSB				14
+#define CSR_PLLFORCECAL_MASK				BIT(14)
+#define CSR_PLLENCAL_LSB				15
+#define CSR_PLLENCAL_MASK				BIT(15)
+/* CSR_PLLCTRL4 */
+#define CSR_PLLCTRL4_LSB				0
+#define CSR_PLLCTRL4_MASK				GENMASK_32(8, 0)
+#define CSR_PLLCPINTGSCTRL_LSB				0
+#define CSR_PLLCPINTGSCTRL_MASK				GENMASK_32(4, 0)
+#define CSR_PLLCPPROPGSCTRL_LSB				5
+#define CSR_PLLCPPROPGSCTRL_MASK			GENMASK_32(8, 5)
+/* CSR_PLLENDOFCAL */
+#define CSR_PLLENDOFCAL_LSB				0
+#define CSR_PLLENDOFCAL_MASK				BIT(0)
+/* CSR_PLLSTANDBYEFF */
+#define CSR_PLLSTANDBYEFF_LSB				0
+#define CSR_PLLSTANDBYEFF_MASK				BIT(0)
+/* CSR_PLLDACVALOUT */
+#define CSR_PLLDACVALOUT_LSB				0
+#define CSR_PLLDACVALOUT_MASK				GENMASK_32(4, 0)
+/* CSR_DLYTESTSEQ */
+#define CSR_DLYTESTSEQ_LSB				0
+#define CSR_DLYTESTSEQ_MASK				GENMASK_32(5, 0)
+#define CSR_DLYTESTEN_LSB				0
+#define CSR_DLYTESTEN_MASK				BIT(0)
+#define CSR_DLYTESTCNTINIT_LSB				1
+#define CSR_DLYTESTCNTINIT_MASK				BIT(1)
+#define CSR_DLYTESTENOVERRIDE1_LSB			2
+#define CSR_DLYTESTENOVERRIDE1_MASK			BIT(2)
+#define CSR_DLYTESTENOVERRIDE2_LSB			3
+#define CSR_DLYTESTENOVERRIDE2_MASK			BIT(3)
+#define CSR_SYNCDLYMULTIPLIER_LSB			4
+#define CSR_SYNCDLYMULTIPLIER_MASK			GENMASK_32(5, 4)
+/* CSR_DLYTESTRINGSELDB */
+#define CSR_DLYTESTRINGSELDB_LSB			0
+#define CSR_DLYTESTRINGSELDB_MASK			GENMASK_32(4, 0)
+#define CSR_DLYTESTCUTDB_LSB				0
+#define CSR_DLYTESTCUTDB_MASK				GENMASK_32(4, 0)
+/* CSR_DLYTESTRINGSELAC */
+#define CSR_DLYTESTRINGSELAC_LSB			0
+#define CSR_DLYTESTRINGSELAC_MASK			GENMASK_32(4, 0)
+#define CSR_DLYTESTCUTAC_LSB				0
+#define CSR_DLYTESTCUTAC_MASK				GENMASK_32(4, 0)
+/* CSR_DLYTESTCNTDFICLKIV */
+#define CSR_DLYTESTCNTDFICLKIV_LSB			0
+#define CSR_DLYTESTCNTDFICLKIV_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTDFICLK */
+#define CSR_DLYTESTCNTDFICLK_LSB			0
+#define CSR_DLYTESTCNTDFICLK_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB0 */
+#define CSR_DLYTESTCNTRINGOSCDB0_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB0_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB1 */
+#define CSR_DLYTESTCNTRINGOSCDB1_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB1_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB2 */
+#define CSR_DLYTESTCNTRINGOSCDB2_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB2_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB3 */
+#define CSR_DLYTESTCNTRINGOSCDB3_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB3_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB4 */
+#define CSR_DLYTESTCNTRINGOSCDB4_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB4_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB5 */
+#define CSR_DLYTESTCNTRINGOSCDB5_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB5_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB6 */
+#define CSR_DLYTESTCNTRINGOSCDB6_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB6_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB7 */
+#define CSR_DLYTESTCNTRINGOSCDB7_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB7_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB8 */
+#define CSR_DLYTESTCNTRINGOSCDB8_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB8_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCDB9 */
+#define CSR_DLYTESTCNTRINGOSCDB9_LSB			0
+#define CSR_DLYTESTCNTRINGOSCDB9_MASK			GENMASK_32(15, 0)
+/* CSR_DLYTESTCNTRINGOSCAC */
+#define CSR_DLYTESTCNTRINGOSCAC_LSB			0
+#define CSR_DLYTESTCNTRINGOSCAC_MASK			GENMASK_32(15, 0)
+/* CSR_MSTLCDLDBGCNTL */
+#define CSR_MSTLCDLDBGCNTL_LSB				0
+#define CSR_MSTLCDLDBGCNTL_MASK				GENMASK_32(11, 0)
+#define CSR_MSTLCDLFINEOVRVAL_LSB			0
+#define CSR_MSTLCDLFINEOVRVAL_MASK			GENMASK_32(8, 0)
+#define CSR_MSTLCDLFINEOVR_LSB				9
+#define CSR_MSTLCDLFINEOVR_MASK				BIT(9)
+#define CSR_MSTLCDLFINESNAP_LSB				10
+#define CSR_MSTLCDLFINESNAP_MASK			BIT(10)
+#define CSR_MSTLCDLTSTENABLE_LSB			11
+#define CSR_MSTLCDLTSTENABLE_MASK			BIT(11)
+/* CSR_MSTLCDL0DBGRES */
+#define CSR_MSTLCDL0DBGRES_LSB				0
+#define CSR_MSTLCDL0DBGRES_MASK				GENMASK_32(12, 0)
+#define CSR_MSTLCDL0FINESNAPVAL_LSB			0
+#define CSR_MSTLCDL0FINESNAPVAL_MASK			GENMASK_32(8, 0)
+#define CSR_MSTLCDL0PHDSNAPVAL_LSB			9
+#define CSR_MSTLCDL0PHDSNAPVAL_MASK			BIT(9)
+#define CSR_MSTLCDL0STICKYLOCK_LSB			10
+#define CSR_MSTLCDL0STICKYLOCK_MASK			BIT(10)
+#define CSR_MSTLCDL0STICKYUNLOCK_LSB			11
+#define CSR_MSTLCDL0STICKYUNLOCK_MASK			BIT(11)
+#define CSR_MSTLCDL0LIVELOCK_LSB			12
+#define CSR_MSTLCDL0LIVELOCK_MASK			BIT(12)
+/* CSR_MSTLCDL1DBGRES */
+#define CSR_MSTLCDL1DBGRES_LSB				0
+#define CSR_MSTLCDL1DBGRES_MASK				GENMASK_32(12, 0)
+#define CSR_MSTLCDL1FINESNAPVAL_LSB			0
+#define CSR_MSTLCDL1FINESNAPVAL_MASK			GENMASK_32(8, 0)
+#define CSR_MSTLCDL1PHDSNAPVAL_LSB			9
+#define CSR_MSTLCDL1PHDSNAPVAL_MASK			BIT(9)
+#define CSR_MSTLCDL1STICKYLOCK_LSB			10
+#define CSR_MSTLCDL1STICKYLOCK_MASK			BIT(10)
+#define CSR_MSTLCDL1STICKYUNLOCK_LSB			11
+#define CSR_MSTLCDL1STICKYUNLOCK_MASK			BIT(11)
+#define CSR_MSTLCDL1LIVELOCK_LSB			12
+#define CSR_MSTLCDL1LIVELOCK_MASK			BIT(12)
+/* CSR_LCDLDBGCNTL */
+#define CSR_LCDLDBGCNTL_LSB				0
+#define CSR_LCDLDBGCNTL_MASK				GENMASK_32(15, 0)
+#define CSR_LCDLFINEOVRVAL_LSB				0
+#define CSR_LCDLFINEOVRVAL_MASK				GENMASK_32(8, 0)
+#define CSR_LCDLFINEOVR_LSB				9
+#define CSR_LCDLFINEOVR_MASK				BIT(9)
+#define CSR_LCDLFINESNAP_LSB				10
+#define CSR_LCDLFINESNAP_MASK				BIT(10)
+#define CSR_LCDLTSTENABLE_LSB				11
+#define CSR_LCDLTSTENABLE_MASK				BIT(11)
+#define CSR_LCDLSTATUSSEL_LSB				12
+#define CSR_LCDLSTATUSSEL_MASK				GENMASK_32(15, 12)
+/* CSR_ACLCDLSTATUS */
+#define CSR_ACLCDLSTATUS_LSB				0
+#define CSR_ACLCDLSTATUS_MASK				GENMASK_32(13, 0)
+#define CSR_ACLCDLFINESNAPVAL_LSB			0
+#define CSR_ACLCDLFINESNAPVAL_MASK			GENMASK_32(9, 0)
+#define CSR_ACLCDLPHDSNAPVAL_LSB			10
+#define CSR_ACLCDLPHDSNAPVAL_MASK			BIT(10)
+#define CSR_ACLCDLSTICKYLOCK_LSB			11
+#define CSR_ACLCDLSTICKYLOCK_MASK			BIT(11)
+#define CSR_ACLCDLSTICKYUNLOCK_LSB			12
+#define CSR_ACLCDLSTICKYUNLOCK_MASK			BIT(12)
+#define CSR_ACLCDLLIVELOCK_LSB				13
+#define CSR_ACLCDLLIVELOCK_MASK				BIT(13)
+/* CSR_CUSTPHYREV */
+#define CSR_CUSTPHYREV_LSB				0
+#define CSR_CUSTPHYREV_MASK				GENMASK_32(5, 0)
+/* CSR_PHYREV */
+#define CSR_PHYREV_LSB					0
+#define CSR_PHYREV_MASK					GENMASK_32(15, 0)
+#define CSR_PHYMNR_LSB					0
+#define CSR_PHYMNR_MASK					GENMASK_32(3, 0)
+#define CSR_PHYMDR_LSB					4
+#define CSR_PHYMDR_MASK					GENMASK_32(7, 4)
+#define CSR_PHYMJR_LSB					8
+#define CSR_PHYMJR_MASK					GENMASK_32(15, 8)
+/* CSR_LP3EXITSEQ0BSTARTVECTOR */
+#define CSR_LP3EXITSEQ0BSTARTVECTOR_LSB			0
+#define CSR_LP3EXITSEQ0BSTARTVECTOR_MASK		GENMASK_32(7, 0)
+#define CSR_LP3EXITSEQ0BSTARTVECPLLENABLED_LSB		0
+#define CSR_LP3EXITSEQ0BSTARTVECPLLENABLED_MASK		GENMASK_32(3, 0)
+#define CSR_LP3EXITSEQ0BSTARTVECPLLBYPASSED_LSB		4
+#define CSR_LP3EXITSEQ0BSTARTVECPLLBYPASSED_MASK	GENMASK_32(7, 4)
+/* CSR_DFIFREQXLAT0 */
+#define CSR_DFIFREQXLAT0_LSB				0
+#define CSR_DFIFREQXLAT0_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL0_LSB				0
+#define CSR_DFIFREQXLATVAL0_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL1_LSB				4
+#define CSR_DFIFREQXLATVAL1_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL2_LSB				8
+#define CSR_DFIFREQXLATVAL2_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL3_LSB				12
+#define CSR_DFIFREQXLATVAL3_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT1 */
+#define CSR_DFIFREQXLAT1_LSB				0
+#define CSR_DFIFREQXLAT1_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL4_LSB				0
+#define CSR_DFIFREQXLATVAL4_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL5_LSB				4
+#define CSR_DFIFREQXLATVAL5_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL6_LSB				8
+#define CSR_DFIFREQXLATVAL6_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL7_LSB				12
+#define CSR_DFIFREQXLATVAL7_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT2 */
+#define CSR_DFIFREQXLAT2_LSB				0
+#define CSR_DFIFREQXLAT2_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL8_LSB				0
+#define CSR_DFIFREQXLATVAL8_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL9_LSB				4
+#define CSR_DFIFREQXLATVAL9_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL10_LSB			8
+#define CSR_DFIFREQXLATVAL10_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL11_LSB			12
+#define CSR_DFIFREQXLATVAL11_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT3 */
+#define CSR_DFIFREQXLAT3_LSB				0
+#define CSR_DFIFREQXLAT3_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL12_LSB			0
+#define CSR_DFIFREQXLATVAL12_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL13_LSB			4
+#define CSR_DFIFREQXLATVAL13_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL14_LSB			8
+#define CSR_DFIFREQXLATVAL14_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL15_LSB			12
+#define CSR_DFIFREQXLATVAL15_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT4 */
+#define CSR_DFIFREQXLAT4_LSB				0
+#define CSR_DFIFREQXLAT4_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL16_LSB			0
+#define CSR_DFIFREQXLATVAL16_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL17_LSB			4
+#define CSR_DFIFREQXLATVAL17_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL18_LSB			8
+#define CSR_DFIFREQXLATVAL18_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL19_LSB			12
+#define CSR_DFIFREQXLATVAL19_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT5 */
+#define CSR_DFIFREQXLAT5_LSB				0
+#define CSR_DFIFREQXLAT5_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL20_LSB			0
+#define CSR_DFIFREQXLATVAL20_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL21_LSB			4
+#define CSR_DFIFREQXLATVAL21_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL22_LSB			8
+#define CSR_DFIFREQXLATVAL22_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL23_LSB			12
+#define CSR_DFIFREQXLATVAL23_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT6 */
+#define CSR_DFIFREQXLAT6_LSB				0
+#define CSR_DFIFREQXLAT6_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL24_LSB			0
+#define CSR_DFIFREQXLATVAL24_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL25_LSB			4
+#define CSR_DFIFREQXLATVAL25_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL26_LSB			8
+#define CSR_DFIFREQXLATVAL26_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL27_LSB			12
+#define CSR_DFIFREQXLATVAL27_MASK			GENMASK_32(15, 12)
+/* CSR_DFIFREQXLAT7 */
+#define CSR_DFIFREQXLAT7_LSB				0
+#define CSR_DFIFREQXLAT7_MASK				GENMASK_32(15, 0)
+#define CSR_DFIFREQXLATVAL28_LSB			0
+#define CSR_DFIFREQXLATVAL28_MASK			GENMASK_32(3, 0)
+#define CSR_DFIFREQXLATVAL29_LSB			4
+#define CSR_DFIFREQXLATVAL29_MASK			GENMASK_32(7, 4)
+#define CSR_DFIFREQXLATVAL30_LSB			8
+#define CSR_DFIFREQXLATVAL30_MASK			GENMASK_32(11, 8)
+#define CSR_DFIFREQXLATVAL31_LSB			12
+#define CSR_DFIFREQXLATVAL31_MASK			GENMASK_32(15, 12)
+/* CSR_TXRDPTRINIT */
+#define CSR_TXRDPTRINIT_LSB				0
+#define CSR_TXRDPTRINIT_MASK				BIT(0)
+/* CSR_DFIINITCOMPLETE */
+#define CSR_DFIINITCOMPLETE_LSB				0
+#define CSR_DFIINITCOMPLETE_MASK			BIT(0)
+/* CSR_DFIFREQRATIO */
+#define CSR_DFIFREQRATIO_LSB				0
+#define CSR_DFIFREQRATIO_MASK				GENMASK_32(1, 0)
+/* CSR_RXFIFOCHECKS */
+#define CSR_RXFIFOCHECKS_LSB				0
+#define CSR_RXFIFOCHECKS_MASK				BIT(0)
+#define CSR_DOFREQUENTRXFIFOCHECKS_LSB			0
+#define CSR_DOFREQUENTRXFIFOCHECKS_MASK			BIT(0)
+/* CSR_MTESTDTOCTRL */
+#define CSR_MTESTDTOCTRL_LSB				0
+#define CSR_MTESTDTOCTRL_MASK				BIT(0)
+#define CSR_MTESTDTOEN_LSB				0
+#define CSR_MTESTDTOEN_MASK				BIT(0)
+/* CSR_MAPCAA0TODFI */
+#define CSR_MAPCAA0TODFI_LSB				0
+#define CSR_MAPCAA0TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA1TODFI */
+#define CSR_MAPCAA1TODFI_LSB				0
+#define CSR_MAPCAA1TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA2TODFI */
+#define CSR_MAPCAA2TODFI_LSB				0
+#define CSR_MAPCAA2TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA3TODFI */
+#define CSR_MAPCAA3TODFI_LSB				0
+#define CSR_MAPCAA3TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA4TODFI */
+#define CSR_MAPCAA4TODFI_LSB				0
+#define CSR_MAPCAA4TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA5TODFI */
+#define CSR_MAPCAA5TODFI_LSB				0
+#define CSR_MAPCAA5TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA6TODFI */
+#define CSR_MAPCAA6TODFI_LSB				0
+#define CSR_MAPCAA6TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA7TODFI */
+#define CSR_MAPCAA7TODFI_LSB				0
+#define CSR_MAPCAA7TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA8TODFI */
+#define CSR_MAPCAA8TODFI_LSB				0
+#define CSR_MAPCAA8TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAA9TODFI */
+#define CSR_MAPCAA9TODFI_LSB				0
+#define CSR_MAPCAA9TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB0TODFI */
+#define CSR_MAPCAB0TODFI_LSB				0
+#define CSR_MAPCAB0TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB1TODFI */
+#define CSR_MAPCAB1TODFI_LSB				0
+#define CSR_MAPCAB1TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB2TODFI */
+#define CSR_MAPCAB2TODFI_LSB				0
+#define CSR_MAPCAB2TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB3TODFI */
+#define CSR_MAPCAB3TODFI_LSB				0
+#define CSR_MAPCAB3TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB4TODFI */
+#define CSR_MAPCAB4TODFI_LSB				0
+#define CSR_MAPCAB4TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB5TODFI */
+#define CSR_MAPCAB5TODFI_LSB				0
+#define CSR_MAPCAB5TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB6TODFI */
+#define CSR_MAPCAB6TODFI_LSB				0
+#define CSR_MAPCAB6TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB7TODFI */
+#define CSR_MAPCAB7TODFI_LSB				0
+#define CSR_MAPCAB7TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB8TODFI */
+#define CSR_MAPCAB8TODFI_LSB				0
+#define CSR_MAPCAB8TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_MAPCAB9TODFI */
+#define CSR_MAPCAB9TODFI_LSB				0
+#define CSR_MAPCAB9TODFI_MASK				GENMASK_32(3, 0)
+/* CSR_PHYINTERRUPTENABLE */
+#define CSR_PHYINTERRUPTENABLE_LSB			0
+#define CSR_PHYINTERRUPTENABLE_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLTEN_LSB				0
+#define CSR_PHYTRNGCMPLTEN_MASK				BIT(0)
+#define CSR_PHYINITCMPLTEN_LSB				1
+#define CSR_PHYINITCMPLTEN_MASK				BIT(1)
+#define CSR_PHYTRNGFAILEN_LSB				2
+#define CSR_PHYTRNGFAILEN_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDEN_LSB				3
+#define CSR_PHYFWRESERVEDEN_MASK			GENMASK_32(7, 3)
+#define CSR_PHYVTDRIFTALARMEN_LSB			8
+#define CSR_PHYVTDRIFTALARMEN_MASK			GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECKEN_LSB			10
+#define CSR_PHYRXFIFOCHECKEN_MASK			BIT(10)
+#define CSR_PHYHWRESERVEDEN_LSB				11
+#define CSR_PHYHWRESERVEDEN_MASK			GENMASK_32(15, 11)
+/* CSR_PHYINTERRUPTFWCONTROL */
+#define CSR_PHYINTERRUPTFWCONTROL_LSB			0
+#define CSR_PHYINTERRUPTFWCONTROL_MASK			GENMASK_32(7, 0)
+#define CSR_PHYTRNGCMPLTFW_LSB				0
+#define CSR_PHYTRNGCMPLTFW_MASK				BIT(0)
+#define CSR_PHYINITCMPLTFW_LSB				1
+#define CSR_PHYINITCMPLTFW_MASK				BIT(1)
+#define CSR_PHYTRNGFAILFW_LSB				2
+#define CSR_PHYTRNGFAILFW_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDFW_LSB				3
+#define CSR_PHYFWRESERVEDFW_MASK			GENMASK_32(7, 3)
+/* CSR_PHYINTERRUPTMASK */
+#define CSR_PHYINTERRUPTMASK_LSB			0
+#define CSR_PHYINTERRUPTMASK_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLTMSK_LSB				0
+#define CSR_PHYTRNGCMPLTMSK_MASK			BIT(0)
+#define CSR_PHYINITCMPLTMSK_LSB				1
+#define CSR_PHYINITCMPLTMSK_MASK			BIT(1)
+#define CSR_PHYTRNGFAILMSK_LSB				2
+#define CSR_PHYTRNGFAILMSK_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDMSK_LSB			3
+#define CSR_PHYFWRESERVEDMSK_MASK			GENMASK_32(7, 3)
+#define CSR_PHYVTDRIFTALARMMSK_LSB			8
+#define CSR_PHYVTDRIFTALARMMSK_MASK			GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECKMSK_LSB			10
+#define CSR_PHYRXFIFOCHECKMSK_MASK			BIT(10)
+#define CSR_PHYHWRESERVEDMSK_LSB			11
+#define CSR_PHYHWRESERVEDMSK_MASK			GENMASK_32(15, 11)
+/* CSR_PHYINTERRUPTCLEAR */
+#define CSR_PHYINTERRUPTCLEAR_LSB			0
+#define CSR_PHYINTERRUPTCLEAR_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLTCLR_LSB				0
+#define CSR_PHYTRNGCMPLTCLR_MASK			BIT(0)
+#define CSR_PHYINITCMPLTCLR_LSB				1
+#define CSR_PHYINITCMPLTCLR_MASK			BIT(1)
+#define CSR_PHYTRNGFAILCLR_LSB				2
+#define CSR_PHYTRNGFAILCLR_MASK				BIT(2)
+#define CSR_PHYFWRESERVEDCLR_LSB			3
+#define CSR_PHYFWRESERVEDCLR_MASK			GENMASK_32(7, 3)
+#define CSR_PHYVTDRIFTALARMCLR_LSB			8
+#define CSR_PHYVTDRIFTALARMCLR_MASK			GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECKCLR_LSB			10
+#define CSR_PHYRXFIFOCHECKCLR_MASK			BIT(10)
+#define CSR_PHYHWRESERVEDCLR_LSB			11
+#define CSR_PHYHWRESERVEDCLR_MASK			GENMASK_32(15, 11)
+/* CSR_PHYINTERRUPTSTATUS */
+#define CSR_PHYINTERRUPTSTATUS_LSB			0
+#define CSR_PHYINTERRUPTSTATUS_MASK			GENMASK_32(15, 0)
+#define CSR_PHYTRNGCMPLT_LSB				0
+#define CSR_PHYTRNGCMPLT_MASK				BIT(0)
+#define CSR_PHYINITCMPLT_LSB				1
+#define CSR_PHYINITCMPLT_MASK				BIT(1)
+#define CSR_PHYTRNGFAIL_LSB				2
+#define CSR_PHYTRNGFAIL_MASK				BIT(2)
+#define CSR_PHYFWRESERVED_LSB				3
+#define CSR_PHYFWRESERVED_MASK				GENMASK_32(7, 3)
+#define CSR_VTDRIFTALARM_LSB				8
+#define CSR_VTDRIFTALARM_MASK				GENMASK_32(9, 8)
+#define CSR_PHYRXFIFOCHECK_LSB				10
+#define CSR_PHYRXFIFOCHECK_MASK				BIT(10)
+#define CSR_PHYHWRESERVED_LSB				11
+#define CSR_PHYHWRESERVED_MASK				GENMASK_32(15, 11)
+/* CSR_HWTSWIZZLEHWTADDRESS0 */
+#define CSR_HWTSWIZZLEHWTADDRESS0_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS0_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS1 */
+#define CSR_HWTSWIZZLEHWTADDRESS1_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS1_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS2 */
+#define CSR_HWTSWIZZLEHWTADDRESS2_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS2_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS3 */
+#define CSR_HWTSWIZZLEHWTADDRESS3_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS3_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS4 */
+#define CSR_HWTSWIZZLEHWTADDRESS4_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS4_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS5 */
+#define CSR_HWTSWIZZLEHWTADDRESS5_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS5_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS6 */
+#define CSR_HWTSWIZZLEHWTADDRESS6_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS6_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS7 */
+#define CSR_HWTSWIZZLEHWTADDRESS7_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS7_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS8 */
+#define CSR_HWTSWIZZLEHWTADDRESS8_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS8_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS9 */
+#define CSR_HWTSWIZZLEHWTADDRESS9_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS9_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS10 */
+#define CSR_HWTSWIZZLEHWTADDRESS10_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS10_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS11 */
+#define CSR_HWTSWIZZLEHWTADDRESS11_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS11_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS12 */
+#define CSR_HWTSWIZZLEHWTADDRESS12_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS12_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS13 */
+#define CSR_HWTSWIZZLEHWTADDRESS13_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS13_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS14 */
+#define CSR_HWTSWIZZLEHWTADDRESS14_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS14_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS15 */
+#define CSR_HWTSWIZZLEHWTADDRESS15_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS15_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTADDRESS17 */
+#define CSR_HWTSWIZZLEHWTADDRESS17_LSB			0
+#define CSR_HWTSWIZZLEHWTADDRESS17_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTACTN */
+#define CSR_HWTSWIZZLEHWTACTN_LSB			0
+#define CSR_HWTSWIZZLEHWTACTN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBANK0 */
+#define CSR_HWTSWIZZLEHWTBANK0_LSB			0
+#define CSR_HWTSWIZZLEHWTBANK0_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBANK1 */
+#define CSR_HWTSWIZZLEHWTBANK1_LSB			0
+#define CSR_HWTSWIZZLEHWTBANK1_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBANK2 */
+#define CSR_HWTSWIZZLEHWTBANK2_LSB			0
+#define CSR_HWTSWIZZLEHWTBANK2_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBG0 */
+#define CSR_HWTSWIZZLEHWTBG0_LSB			0
+#define CSR_HWTSWIZZLEHWTBG0_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTBG1 */
+#define CSR_HWTSWIZZLEHWTBG1_LSB			0
+#define CSR_HWTSWIZZLEHWTBG1_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTCASN */
+#define CSR_HWTSWIZZLEHWTCASN_LSB			0
+#define CSR_HWTSWIZZLEHWTCASN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTRASN */
+#define CSR_HWTSWIZZLEHWTRASN_LSB			0
+#define CSR_HWTSWIZZLEHWTRASN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTWEN */
+#define CSR_HWTSWIZZLEHWTWEN_LSB			0
+#define CSR_HWTSWIZZLEHWTWEN_MASK			GENMASK_32(4, 0)
+/* CSR_HWTSWIZZLEHWTPARITYIN */
+#define CSR_HWTSWIZZLEHWTPARITYIN_LSB			0
+#define CSR_HWTSWIZZLEHWTPARITYIN_MASK			GENMASK_32(4, 0)
+/* CSR_DFIHANDSHAKEDELAYS0 */
+#define CSR_DFIHANDSHAKEDELAYS0_LSB			0
+#define CSR_DFIHANDSHAKEDELAYS0_MASK			GENMASK_32(15, 0)
+#define CSR_PHYUPDACKDELAY0_LSB				0
+#define CSR_PHYUPDACKDELAY0_MASK			GENMASK_32(3, 0)
+#define CSR_PHYUPDREQDELAY0_LSB				4
+#define CSR_PHYUPDREQDELAY0_MASK			GENMASK_32(7, 4)
+#define CSR_CTRLUPDACKDELAY0_LSB			8
+#define CSR_CTRLUPDACKDELAY0_MASK			GENMASK_32(11, 8)
+#define CSR_CTRLUPDREQDELAY0_LSB			12
+#define CSR_CTRLUPDREQDELAY0_MASK			GENMASK_32(15, 12)
+/* CSR_DFIHANDSHAKEDELAYS1 */
+#define CSR_DFIHANDSHAKEDELAYS1_LSB			0
+#define CSR_DFIHANDSHAKEDELAYS1_MASK			GENMASK_32(15, 0)
+#define CSR_PHYUPDACKDELAY1_LSB				0
+#define CSR_PHYUPDACKDELAY1_MASK			GENMASK_32(3, 0)
+#define CSR_PHYUPDREQDELAY1_LSB				4
+#define CSR_PHYUPDREQDELAY1_MASK			GENMASK_32(7, 4)
+#define CSR_CTRLUPDACKDELAY1_LSB			8
+#define CSR_CTRLUPDACKDELAY1_MASK			GENMASK_32(11, 8)
+#define CSR_CTRLUPDREQDELAY1_LSB			12
+#define CSR_CTRLUPDREQDELAY1_MASK			GENMASK_32(15, 12)
+/* CSR_REMOTEIMPCAL */
+#define CSR_REMOTEIMPCAL_LSB				0
+#define CSR_REMOTEIMPCAL_MASK				GENMASK_32(1, 0)
+#define CSR_CALIBSLAVE_LSB				0
+#define CSR_CALIBSLAVE_MASK				BIT(0)
+#define CSR_SLAVECODEUPDATED_LSB			1
+#define CSR_SLAVECODEUPDATED_MASK			BIT(1)
+/* CSR_ACLOOPBACKCTL */
+#define CSR_ACLOOPBACKCTL_LSB				0
+#define CSR_ACLOOPBACKCTL_MASK				GENMASK_32(1, 0)
+#define CSR_TERMINATION_LSB				0
+#define CSR_TERMINATION_MASK				BIT(0)
+#define CSR_NOISECANCEL_LSB				1
+#define CSR_NOISECANCEL_MASK				BIT(1)
+
+/* ACSM0 register offsets */
+/* CSR_ACSMSEQ0X0 */
+#define CSR_ACSMSEQ0X0_LSB				0
+#define CSR_ACSMSEQ0X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY0_LSB				0
+#define CSR_ACSMMCLKDLY0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE0_LSB				8
+#define CSR_ACSMDDRWE0_MASK				BIT(8)
+#define CSR_ACSMDDRCAS0_LSB				9
+#define CSR_ACSMDDRCAS0_MASK				BIT(9)
+#define CSR_ACSMDDRRAS0_LSB				10
+#define CSR_ACSMDDRRAS0_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET0_LSB				11
+#define CSR_ACSMDDRCKESET0_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR0_LSB				12
+#define CSR_ACSMDDRCKECLR0_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD0_LSB				13
+#define CSR_ACSMSEQGATECMD0_MASK			BIT(13)
+#define CSR_ACSMSEQTERM0_LSB				14
+#define CSR_ACSMSEQTERM0_MASK				BIT(14)
+#define CSR_ACSMLP3CA30_LSB				15
+#define CSR_ACSMLP3CA30_MASK				BIT(15)
+/* CSR_ACSMSEQ0X1 */
+#define CSR_ACSMSEQ0X1_LSB				0
+#define CSR_ACSMSEQ0X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY1_LSB				0
+#define CSR_ACSMMCLKDLY1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE1_LSB				8
+#define CSR_ACSMDDRWE1_MASK				BIT(8)
+#define CSR_ACSMDDRCAS1_LSB				9
+#define CSR_ACSMDDRCAS1_MASK				BIT(9)
+#define CSR_ACSMDDRRAS1_LSB				10
+#define CSR_ACSMDDRRAS1_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET1_LSB				11
+#define CSR_ACSMDDRCKESET1_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR1_LSB				12
+#define CSR_ACSMDDRCKECLR1_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD1_LSB				13
+#define CSR_ACSMSEQGATECMD1_MASK			BIT(13)
+#define CSR_ACSMSEQTERM1_LSB				14
+#define CSR_ACSMSEQTERM1_MASK				BIT(14)
+#define CSR_ACSMLP3CA31_LSB				15
+#define CSR_ACSMLP3CA31_MASK				BIT(15)
+/* CSR_ACSMSEQ0X2 */
+#define CSR_ACSMSEQ0X2_LSB				0
+#define CSR_ACSMSEQ0X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY2_LSB				0
+#define CSR_ACSMMCLKDLY2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE2_LSB				8
+#define CSR_ACSMDDRWE2_MASK				BIT(8)
+#define CSR_ACSMDDRCAS2_LSB				9
+#define CSR_ACSMDDRCAS2_MASK				BIT(9)
+#define CSR_ACSMDDRRAS2_LSB				10
+#define CSR_ACSMDDRRAS2_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET2_LSB				11
+#define CSR_ACSMDDRCKESET2_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR2_LSB				12
+#define CSR_ACSMDDRCKECLR2_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD2_LSB				13
+#define CSR_ACSMSEQGATECMD2_MASK			BIT(13)
+#define CSR_ACSMSEQTERM2_LSB				14
+#define CSR_ACSMSEQTERM2_MASK				BIT(14)
+#define CSR_ACSMLP3CA32_LSB				15
+#define CSR_ACSMLP3CA32_MASK				BIT(15)
+/* CSR_ACSMSEQ0X3 */
+#define CSR_ACSMSEQ0X3_LSB				0
+#define CSR_ACSMSEQ0X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY3_LSB				0
+#define CSR_ACSMMCLKDLY3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE3_LSB				8
+#define CSR_ACSMDDRWE3_MASK				BIT(8)
+#define CSR_ACSMDDRCAS3_LSB				9
+#define CSR_ACSMDDRCAS3_MASK				BIT(9)
+#define CSR_ACSMDDRRAS3_LSB				10
+#define CSR_ACSMDDRRAS3_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET3_LSB				11
+#define CSR_ACSMDDRCKESET3_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR3_LSB				12
+#define CSR_ACSMDDRCKECLR3_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD3_LSB				13
+#define CSR_ACSMSEQGATECMD3_MASK			BIT(13)
+#define CSR_ACSMSEQTERM3_LSB				14
+#define CSR_ACSMSEQTERM3_MASK				BIT(14)
+#define CSR_ACSMLP3CA33_LSB				15
+#define CSR_ACSMLP3CA33_MASK				BIT(15)
+/* CSR_ACSMSEQ0X4 */
+#define CSR_ACSMSEQ0X4_LSB				0
+#define CSR_ACSMSEQ0X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY4_LSB				0
+#define CSR_ACSMMCLKDLY4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE4_LSB				8
+#define CSR_ACSMDDRWE4_MASK				BIT(8)
+#define CSR_ACSMDDRCAS4_LSB				9
+#define CSR_ACSMDDRCAS4_MASK				BIT(9)
+#define CSR_ACSMDDRRAS4_LSB				10
+#define CSR_ACSMDDRRAS4_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET4_LSB				11
+#define CSR_ACSMDDRCKESET4_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR4_LSB				12
+#define CSR_ACSMDDRCKECLR4_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD4_LSB				13
+#define CSR_ACSMSEQGATECMD4_MASK			BIT(13)
+#define CSR_ACSMSEQTERM4_LSB				14
+#define CSR_ACSMSEQTERM4_MASK				BIT(14)
+#define CSR_ACSMLP3CA34_LSB				15
+#define CSR_ACSMLP3CA34_MASK				BIT(15)
+/* CSR_ACSMSEQ0X5 */
+#define CSR_ACSMSEQ0X5_LSB				0
+#define CSR_ACSMSEQ0X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY5_LSB				0
+#define CSR_ACSMMCLKDLY5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE5_LSB				8
+#define CSR_ACSMDDRWE5_MASK				BIT(8)
+#define CSR_ACSMDDRCAS5_LSB				9
+#define CSR_ACSMDDRCAS5_MASK				BIT(9)
+#define CSR_ACSMDDRRAS5_LSB				10
+#define CSR_ACSMDDRRAS5_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET5_LSB				11
+#define CSR_ACSMDDRCKESET5_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR5_LSB				12
+#define CSR_ACSMDDRCKECLR5_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD5_LSB				13
+#define CSR_ACSMSEQGATECMD5_MASK			BIT(13)
+#define CSR_ACSMSEQTERM5_LSB				14
+#define CSR_ACSMSEQTERM5_MASK				BIT(14)
+#define CSR_ACSMLP3CA35_LSB				15
+#define CSR_ACSMLP3CA35_MASK				BIT(15)
+/* CSR_ACSMSEQ0X6 */
+#define CSR_ACSMSEQ0X6_LSB				0
+#define CSR_ACSMSEQ0X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY6_LSB				0
+#define CSR_ACSMMCLKDLY6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE6_LSB				8
+#define CSR_ACSMDDRWE6_MASK				BIT(8)
+#define CSR_ACSMDDRCAS6_LSB				9
+#define CSR_ACSMDDRCAS6_MASK				BIT(9)
+#define CSR_ACSMDDRRAS6_LSB				10
+#define CSR_ACSMDDRRAS6_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET6_LSB				11
+#define CSR_ACSMDDRCKESET6_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR6_LSB				12
+#define CSR_ACSMDDRCKECLR6_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD6_LSB				13
+#define CSR_ACSMSEQGATECMD6_MASK			BIT(13)
+#define CSR_ACSMSEQTERM6_LSB				14
+#define CSR_ACSMSEQTERM6_MASK				BIT(14)
+#define CSR_ACSMLP3CA36_LSB				15
+#define CSR_ACSMLP3CA36_MASK				BIT(15)
+/* CSR_ACSMSEQ0X7 */
+#define CSR_ACSMSEQ0X7_LSB				0
+#define CSR_ACSMSEQ0X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY7_LSB				0
+#define CSR_ACSMMCLKDLY7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE7_LSB				8
+#define CSR_ACSMDDRWE7_MASK				BIT(8)
+#define CSR_ACSMDDRCAS7_LSB				9
+#define CSR_ACSMDDRCAS7_MASK				BIT(9)
+#define CSR_ACSMDDRRAS7_LSB				10
+#define CSR_ACSMDDRRAS7_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET7_LSB				11
+#define CSR_ACSMDDRCKESET7_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR7_LSB				12
+#define CSR_ACSMDDRCKECLR7_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD7_LSB				13
+#define CSR_ACSMSEQGATECMD7_MASK			BIT(13)
+#define CSR_ACSMSEQTERM7_LSB				14
+#define CSR_ACSMSEQTERM7_MASK				BIT(14)
+#define CSR_ACSMLP3CA37_LSB				15
+#define CSR_ACSMLP3CA37_MASK				BIT(15)
+/* CSR_ACSMSEQ0X8 */
+#define CSR_ACSMSEQ0X8_LSB				0
+#define CSR_ACSMSEQ0X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY8_LSB				0
+#define CSR_ACSMMCLKDLY8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE8_LSB				8
+#define CSR_ACSMDDRWE8_MASK				BIT(8)
+#define CSR_ACSMDDRCAS8_LSB				9
+#define CSR_ACSMDDRCAS8_MASK				BIT(9)
+#define CSR_ACSMDDRRAS8_LSB				10
+#define CSR_ACSMDDRRAS8_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET8_LSB				11
+#define CSR_ACSMDDRCKESET8_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR8_LSB				12
+#define CSR_ACSMDDRCKECLR8_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD8_LSB				13
+#define CSR_ACSMSEQGATECMD8_MASK			BIT(13)
+#define CSR_ACSMSEQTERM8_LSB				14
+#define CSR_ACSMSEQTERM8_MASK				BIT(14)
+#define CSR_ACSMLP3CA38_LSB				15
+#define CSR_ACSMLP3CA38_MASK				BIT(15)
+/* CSR_ACSMSEQ0X9 */
+#define CSR_ACSMSEQ0X9_LSB				0
+#define CSR_ACSMSEQ0X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY9_LSB				0
+#define CSR_ACSMMCLKDLY9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE9_LSB				8
+#define CSR_ACSMDDRWE9_MASK				BIT(8)
+#define CSR_ACSMDDRCAS9_LSB				9
+#define CSR_ACSMDDRCAS9_MASK				BIT(9)
+#define CSR_ACSMDDRRAS9_LSB				10
+#define CSR_ACSMDDRRAS9_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET9_LSB				11
+#define CSR_ACSMDDRCKESET9_MASK				BIT(11)
+#define CSR_ACSMDDRCKECLR9_LSB				12
+#define CSR_ACSMDDRCKECLR9_MASK				BIT(12)
+#define CSR_ACSMSEQGATECMD9_LSB				13
+#define CSR_ACSMSEQGATECMD9_MASK			BIT(13)
+#define CSR_ACSMSEQTERM9_LSB				14
+#define CSR_ACSMSEQTERM9_MASK				BIT(14)
+#define CSR_ACSMLP3CA39_LSB				15
+#define CSR_ACSMLP3CA39_MASK				BIT(15)
+/* CSR_ACSMSEQ0X10 */
+#define CSR_ACSMSEQ0X10_LSB				0
+#define CSR_ACSMSEQ0X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY10_LSB				0
+#define CSR_ACSMMCLKDLY10_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE10_LSB				8
+#define CSR_ACSMDDRWE10_MASK				BIT(8)
+#define CSR_ACSMDDRCAS10_LSB				9
+#define CSR_ACSMDDRCAS10_MASK				BIT(9)
+#define CSR_ACSMDDRRAS10_LSB				10
+#define CSR_ACSMDDRRAS10_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET10_LSB				11
+#define CSR_ACSMDDRCKESET10_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR10_LSB				12
+#define CSR_ACSMDDRCKECLR10_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD10_LSB			13
+#define CSR_ACSMSEQGATECMD10_MASK			BIT(13)
+#define CSR_ACSMSEQTERM10_LSB				14
+#define CSR_ACSMSEQTERM10_MASK				BIT(14)
+#define CSR_ACSMLP3CA310_LSB				15
+#define CSR_ACSMLP3CA310_MASK				BIT(15)
+/* CSR_ACSMSEQ0X11 */
+#define CSR_ACSMSEQ0X11_LSB				0
+#define CSR_ACSMSEQ0X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY11_LSB				0
+#define CSR_ACSMMCLKDLY11_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE11_LSB				8
+#define CSR_ACSMDDRWE11_MASK				BIT(8)
+#define CSR_ACSMDDRCAS11_LSB				9
+#define CSR_ACSMDDRCAS11_MASK				BIT(9)
+#define CSR_ACSMDDRRAS11_LSB				10
+#define CSR_ACSMDDRRAS11_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET11_LSB				11
+#define CSR_ACSMDDRCKESET11_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR11_LSB				12
+#define CSR_ACSMDDRCKECLR11_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD11_LSB			13
+#define CSR_ACSMSEQGATECMD11_MASK			BIT(13)
+#define CSR_ACSMSEQTERM11_LSB				14
+#define CSR_ACSMSEQTERM11_MASK				BIT(14)
+#define CSR_ACSMLP3CA311_LSB				15
+#define CSR_ACSMLP3CA311_MASK				BIT(15)
+/* CSR_ACSMSEQ0X12 */
+#define CSR_ACSMSEQ0X12_LSB				0
+#define CSR_ACSMSEQ0X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY12_LSB				0
+#define CSR_ACSMMCLKDLY12_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE12_LSB				8
+#define CSR_ACSMDDRWE12_MASK				BIT(8)
+#define CSR_ACSMDDRCAS12_LSB				9
+#define CSR_ACSMDDRCAS12_MASK				BIT(9)
+#define CSR_ACSMDDRRAS12_LSB				10
+#define CSR_ACSMDDRRAS12_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET12_LSB				11
+#define CSR_ACSMDDRCKESET12_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR12_LSB				12
+#define CSR_ACSMDDRCKECLR12_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD12_LSB			13
+#define CSR_ACSMSEQGATECMD12_MASK			BIT(13)
+#define CSR_ACSMSEQTERM12_LSB				14
+#define CSR_ACSMSEQTERM12_MASK				BIT(14)
+#define CSR_ACSMLP3CA312_LSB				15
+#define CSR_ACSMLP3CA312_MASK				BIT(15)
+/* CSR_ACSMSEQ0X13 */
+#define CSR_ACSMSEQ0X13_LSB				0
+#define CSR_ACSMSEQ0X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY13_LSB				0
+#define CSR_ACSMMCLKDLY13_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE13_LSB				8
+#define CSR_ACSMDDRWE13_MASK				BIT(8)
+#define CSR_ACSMDDRCAS13_LSB				9
+#define CSR_ACSMDDRCAS13_MASK				BIT(9)
+#define CSR_ACSMDDRRAS13_LSB				10
+#define CSR_ACSMDDRRAS13_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET13_LSB				11
+#define CSR_ACSMDDRCKESET13_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR13_LSB				12
+#define CSR_ACSMDDRCKECLR13_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD13_LSB			13
+#define CSR_ACSMSEQGATECMD13_MASK			BIT(13)
+#define CSR_ACSMSEQTERM13_LSB				14
+#define CSR_ACSMSEQTERM13_MASK				BIT(14)
+#define CSR_ACSMLP3CA313_LSB				15
+#define CSR_ACSMLP3CA313_MASK				BIT(15)
+/* CSR_ACSMSEQ0X14 */
+#define CSR_ACSMSEQ0X14_LSB				0
+#define CSR_ACSMSEQ0X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY14_LSB				0
+#define CSR_ACSMMCLKDLY14_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE14_LSB				8
+#define CSR_ACSMDDRWE14_MASK				BIT(8)
+#define CSR_ACSMDDRCAS14_LSB				9
+#define CSR_ACSMDDRCAS14_MASK				BIT(9)
+#define CSR_ACSMDDRRAS14_LSB				10
+#define CSR_ACSMDDRRAS14_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET14_LSB				11
+#define CSR_ACSMDDRCKESET14_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR14_LSB				12
+#define CSR_ACSMDDRCKECLR14_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD14_LSB			13
+#define CSR_ACSMSEQGATECMD14_MASK			BIT(13)
+#define CSR_ACSMSEQTERM14_LSB				14
+#define CSR_ACSMSEQTERM14_MASK				BIT(14)
+#define CSR_ACSMLP3CA314_LSB				15
+#define CSR_ACSMLP3CA314_MASK				BIT(15)
+/* CSR_ACSMSEQ0X15 */
+#define CSR_ACSMSEQ0X15_LSB				0
+#define CSR_ACSMSEQ0X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY15_LSB				0
+#define CSR_ACSMMCLKDLY15_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE15_LSB				8
+#define CSR_ACSMDDRWE15_MASK				BIT(8)
+#define CSR_ACSMDDRCAS15_LSB				9
+#define CSR_ACSMDDRCAS15_MASK				BIT(9)
+#define CSR_ACSMDDRRAS15_LSB				10
+#define CSR_ACSMDDRRAS15_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET15_LSB				11
+#define CSR_ACSMDDRCKESET15_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR15_LSB				12
+#define CSR_ACSMDDRCKECLR15_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD15_LSB			13
+#define CSR_ACSMSEQGATECMD15_MASK			BIT(13)
+#define CSR_ACSMSEQTERM15_LSB				14
+#define CSR_ACSMSEQTERM15_MASK				BIT(14)
+#define CSR_ACSMLP3CA315_LSB				15
+#define CSR_ACSMLP3CA315_MASK				BIT(15)
+/* CSR_ACSMSEQ0X16 */
+#define CSR_ACSMSEQ0X16_LSB				0
+#define CSR_ACSMSEQ0X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY16_LSB				0
+#define CSR_ACSMMCLKDLY16_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE16_LSB				8
+#define CSR_ACSMDDRWE16_MASK				BIT(8)
+#define CSR_ACSMDDRCAS16_LSB				9
+#define CSR_ACSMDDRCAS16_MASK				BIT(9)
+#define CSR_ACSMDDRRAS16_LSB				10
+#define CSR_ACSMDDRRAS16_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET16_LSB				11
+#define CSR_ACSMDDRCKESET16_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR16_LSB				12
+#define CSR_ACSMDDRCKECLR16_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD16_LSB			13
+#define CSR_ACSMSEQGATECMD16_MASK			BIT(13)
+#define CSR_ACSMSEQTERM16_LSB				14
+#define CSR_ACSMSEQTERM16_MASK				BIT(14)
+#define CSR_ACSMLP3CA316_LSB				15
+#define CSR_ACSMLP3CA316_MASK				BIT(15)
+/* CSR_ACSMSEQ0X17 */
+#define CSR_ACSMSEQ0X17_LSB				0
+#define CSR_ACSMSEQ0X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY17_LSB				0
+#define CSR_ACSMMCLKDLY17_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE17_LSB				8
+#define CSR_ACSMDDRWE17_MASK				BIT(8)
+#define CSR_ACSMDDRCAS17_LSB				9
+#define CSR_ACSMDDRCAS17_MASK				BIT(9)
+#define CSR_ACSMDDRRAS17_LSB				10
+#define CSR_ACSMDDRRAS17_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET17_LSB				11
+#define CSR_ACSMDDRCKESET17_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR17_LSB				12
+#define CSR_ACSMDDRCKECLR17_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD17_LSB			13
+#define CSR_ACSMSEQGATECMD17_MASK			BIT(13)
+#define CSR_ACSMSEQTERM17_LSB				14
+#define CSR_ACSMSEQTERM17_MASK				BIT(14)
+#define CSR_ACSMLP3CA317_LSB				15
+#define CSR_ACSMLP3CA317_MASK				BIT(15)
+/* CSR_ACSMSEQ0X18 */
+#define CSR_ACSMSEQ0X18_LSB				0
+#define CSR_ACSMSEQ0X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY18_LSB				0
+#define CSR_ACSMMCLKDLY18_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE18_LSB				8
+#define CSR_ACSMDDRWE18_MASK				BIT(8)
+#define CSR_ACSMDDRCAS18_LSB				9
+#define CSR_ACSMDDRCAS18_MASK				BIT(9)
+#define CSR_ACSMDDRRAS18_LSB				10
+#define CSR_ACSMDDRRAS18_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET18_LSB				11
+#define CSR_ACSMDDRCKESET18_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR18_LSB				12
+#define CSR_ACSMDDRCKECLR18_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD18_LSB			13
+#define CSR_ACSMSEQGATECMD18_MASK			BIT(13)
+#define CSR_ACSMSEQTERM18_LSB				14
+#define CSR_ACSMSEQTERM18_MASK				BIT(14)
+#define CSR_ACSMLP3CA318_LSB				15
+#define CSR_ACSMLP3CA318_MASK				BIT(15)
+/* CSR_ACSMSEQ0X19 */
+#define CSR_ACSMSEQ0X19_LSB				0
+#define CSR_ACSMSEQ0X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY19_LSB				0
+#define CSR_ACSMMCLKDLY19_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE19_LSB				8
+#define CSR_ACSMDDRWE19_MASK				BIT(8)
+#define CSR_ACSMDDRCAS19_LSB				9
+#define CSR_ACSMDDRCAS19_MASK				BIT(9)
+#define CSR_ACSMDDRRAS19_LSB				10
+#define CSR_ACSMDDRRAS19_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET19_LSB				11
+#define CSR_ACSMDDRCKESET19_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR19_LSB				12
+#define CSR_ACSMDDRCKECLR19_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD19_LSB			13
+#define CSR_ACSMSEQGATECMD19_MASK			BIT(13)
+#define CSR_ACSMSEQTERM19_LSB				14
+#define CSR_ACSMSEQTERM19_MASK				BIT(14)
+#define CSR_ACSMLP3CA319_LSB				15
+#define CSR_ACSMLP3CA319_MASK				BIT(15)
+/* CSR_ACSMSEQ0X20 */
+#define CSR_ACSMSEQ0X20_LSB				0
+#define CSR_ACSMSEQ0X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY20_LSB				0
+#define CSR_ACSMMCLKDLY20_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE20_LSB				8
+#define CSR_ACSMDDRWE20_MASK				BIT(8)
+#define CSR_ACSMDDRCAS20_LSB				9
+#define CSR_ACSMDDRCAS20_MASK				BIT(9)
+#define CSR_ACSMDDRRAS20_LSB				10
+#define CSR_ACSMDDRRAS20_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET20_LSB				11
+#define CSR_ACSMDDRCKESET20_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR20_LSB				12
+#define CSR_ACSMDDRCKECLR20_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD20_LSB			13
+#define CSR_ACSMSEQGATECMD20_MASK			BIT(13)
+#define CSR_ACSMSEQTERM20_LSB				14
+#define CSR_ACSMSEQTERM20_MASK				BIT(14)
+#define CSR_ACSMLP3CA320_LSB				15
+#define CSR_ACSMLP3CA320_MASK				BIT(15)
+/* CSR_ACSMSEQ0X21 */
+#define CSR_ACSMSEQ0X21_LSB				0
+#define CSR_ACSMSEQ0X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY21_LSB				0
+#define CSR_ACSMMCLKDLY21_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE21_LSB				8
+#define CSR_ACSMDDRWE21_MASK				BIT(8)
+#define CSR_ACSMDDRCAS21_LSB				9
+#define CSR_ACSMDDRCAS21_MASK				BIT(9)
+#define CSR_ACSMDDRRAS21_LSB				10
+#define CSR_ACSMDDRRAS21_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET21_LSB				11
+#define CSR_ACSMDDRCKESET21_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR21_LSB				12
+#define CSR_ACSMDDRCKECLR21_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD21_LSB			13
+#define CSR_ACSMSEQGATECMD21_MASK			BIT(13)
+#define CSR_ACSMSEQTERM21_LSB				14
+#define CSR_ACSMSEQTERM21_MASK				BIT(14)
+#define CSR_ACSMLP3CA321_LSB				15
+#define CSR_ACSMLP3CA321_MASK				BIT(15)
+/* CSR_ACSMSEQ0X22 */
+#define CSR_ACSMSEQ0X22_LSB				0
+#define CSR_ACSMSEQ0X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY22_LSB				0
+#define CSR_ACSMMCLKDLY22_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE22_LSB				8
+#define CSR_ACSMDDRWE22_MASK				BIT(8)
+#define CSR_ACSMDDRCAS22_LSB				9
+#define CSR_ACSMDDRCAS22_MASK				BIT(9)
+#define CSR_ACSMDDRRAS22_LSB				10
+#define CSR_ACSMDDRRAS22_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET22_LSB				11
+#define CSR_ACSMDDRCKESET22_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR22_LSB				12
+#define CSR_ACSMDDRCKECLR22_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD22_LSB			13
+#define CSR_ACSMSEQGATECMD22_MASK			BIT(13)
+#define CSR_ACSMSEQTERM22_LSB				14
+#define CSR_ACSMSEQTERM22_MASK				BIT(14)
+#define CSR_ACSMLP3CA322_LSB				15
+#define CSR_ACSMLP3CA322_MASK				BIT(15)
+/* CSR_ACSMSEQ0X23 */
+#define CSR_ACSMSEQ0X23_LSB				0
+#define CSR_ACSMSEQ0X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY23_LSB				0
+#define CSR_ACSMMCLKDLY23_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE23_LSB				8
+#define CSR_ACSMDDRWE23_MASK				BIT(8)
+#define CSR_ACSMDDRCAS23_LSB				9
+#define CSR_ACSMDDRCAS23_MASK				BIT(9)
+#define CSR_ACSMDDRRAS23_LSB				10
+#define CSR_ACSMDDRRAS23_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET23_LSB				11
+#define CSR_ACSMDDRCKESET23_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR23_LSB				12
+#define CSR_ACSMDDRCKECLR23_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD23_LSB			13
+#define CSR_ACSMSEQGATECMD23_MASK			BIT(13)
+#define CSR_ACSMSEQTERM23_LSB				14
+#define CSR_ACSMSEQTERM23_MASK				BIT(14)
+#define CSR_ACSMLP3CA323_LSB				15
+#define CSR_ACSMLP3CA323_MASK				BIT(15)
+/* CSR_ACSMSEQ0X24 */
+#define CSR_ACSMSEQ0X24_LSB				0
+#define CSR_ACSMSEQ0X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY24_LSB				0
+#define CSR_ACSMMCLKDLY24_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE24_LSB				8
+#define CSR_ACSMDDRWE24_MASK				BIT(8)
+#define CSR_ACSMDDRCAS24_LSB				9
+#define CSR_ACSMDDRCAS24_MASK				BIT(9)
+#define CSR_ACSMDDRRAS24_LSB				10
+#define CSR_ACSMDDRRAS24_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET24_LSB				11
+#define CSR_ACSMDDRCKESET24_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR24_LSB				12
+#define CSR_ACSMDDRCKECLR24_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD24_LSB			13
+#define CSR_ACSMSEQGATECMD24_MASK			BIT(13)
+#define CSR_ACSMSEQTERM24_LSB				14
+#define CSR_ACSMSEQTERM24_MASK				BIT(14)
+#define CSR_ACSMLP3CA324_LSB				15
+#define CSR_ACSMLP3CA324_MASK				BIT(15)
+/* CSR_ACSMSEQ0X25 */
+#define CSR_ACSMSEQ0X25_LSB				0
+#define CSR_ACSMSEQ0X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY25_LSB				0
+#define CSR_ACSMMCLKDLY25_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE25_LSB				8
+#define CSR_ACSMDDRWE25_MASK				BIT(8)
+#define CSR_ACSMDDRCAS25_LSB				9
+#define CSR_ACSMDDRCAS25_MASK				BIT(9)
+#define CSR_ACSMDDRRAS25_LSB				10
+#define CSR_ACSMDDRRAS25_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET25_LSB				11
+#define CSR_ACSMDDRCKESET25_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR25_LSB				12
+#define CSR_ACSMDDRCKECLR25_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD25_LSB			13
+#define CSR_ACSMSEQGATECMD25_MASK			BIT(13)
+#define CSR_ACSMSEQTERM25_LSB				14
+#define CSR_ACSMSEQTERM25_MASK				BIT(14)
+#define CSR_ACSMLP3CA325_LSB				15
+#define CSR_ACSMLP3CA325_MASK				BIT(15)
+/* CSR_ACSMSEQ0X26 */
+#define CSR_ACSMSEQ0X26_LSB				0
+#define CSR_ACSMSEQ0X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY26_LSB				0
+#define CSR_ACSMMCLKDLY26_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE26_LSB				8
+#define CSR_ACSMDDRWE26_MASK				BIT(8)
+#define CSR_ACSMDDRCAS26_LSB				9
+#define CSR_ACSMDDRCAS26_MASK				BIT(9)
+#define CSR_ACSMDDRRAS26_LSB				10
+#define CSR_ACSMDDRRAS26_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET26_LSB				11
+#define CSR_ACSMDDRCKESET26_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR26_LSB				12
+#define CSR_ACSMDDRCKECLR26_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD26_LSB			13
+#define CSR_ACSMSEQGATECMD26_MASK			BIT(13)
+#define CSR_ACSMSEQTERM26_LSB				14
+#define CSR_ACSMSEQTERM26_MASK				BIT(14)
+#define CSR_ACSMLP3CA326_LSB				15
+#define CSR_ACSMLP3CA326_MASK				BIT(15)
+/* CSR_ACSMSEQ0X27 */
+#define CSR_ACSMSEQ0X27_LSB				0
+#define CSR_ACSMSEQ0X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY27_LSB				0
+#define CSR_ACSMMCLKDLY27_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE27_LSB				8
+#define CSR_ACSMDDRWE27_MASK				BIT(8)
+#define CSR_ACSMDDRCAS27_LSB				9
+#define CSR_ACSMDDRCAS27_MASK				BIT(9)
+#define CSR_ACSMDDRRAS27_LSB				10
+#define CSR_ACSMDDRRAS27_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET27_LSB				11
+#define CSR_ACSMDDRCKESET27_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR27_LSB				12
+#define CSR_ACSMDDRCKECLR27_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD27_LSB			13
+#define CSR_ACSMSEQGATECMD27_MASK			BIT(13)
+#define CSR_ACSMSEQTERM27_LSB				14
+#define CSR_ACSMSEQTERM27_MASK				BIT(14)
+#define CSR_ACSMLP3CA327_LSB				15
+#define CSR_ACSMLP3CA327_MASK				BIT(15)
+/* CSR_ACSMSEQ0X28 */
+#define CSR_ACSMSEQ0X28_LSB				0
+#define CSR_ACSMSEQ0X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY28_LSB				0
+#define CSR_ACSMMCLKDLY28_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE28_LSB				8
+#define CSR_ACSMDDRWE28_MASK				BIT(8)
+#define CSR_ACSMDDRCAS28_LSB				9
+#define CSR_ACSMDDRCAS28_MASK				BIT(9)
+#define CSR_ACSMDDRRAS28_LSB				10
+#define CSR_ACSMDDRRAS28_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET28_LSB				11
+#define CSR_ACSMDDRCKESET28_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR28_LSB				12
+#define CSR_ACSMDDRCKECLR28_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD28_LSB			13
+#define CSR_ACSMSEQGATECMD28_MASK			BIT(13)
+#define CSR_ACSMSEQTERM28_LSB				14
+#define CSR_ACSMSEQTERM28_MASK				BIT(14)
+#define CSR_ACSMLP3CA328_LSB				15
+#define CSR_ACSMLP3CA328_MASK				BIT(15)
+/* CSR_ACSMSEQ0X29 */
+#define CSR_ACSMSEQ0X29_LSB				0
+#define CSR_ACSMSEQ0X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY29_LSB				0
+#define CSR_ACSMMCLKDLY29_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE29_LSB				8
+#define CSR_ACSMDDRWE29_MASK				BIT(8)
+#define CSR_ACSMDDRCAS29_LSB				9
+#define CSR_ACSMDDRCAS29_MASK				BIT(9)
+#define CSR_ACSMDDRRAS29_LSB				10
+#define CSR_ACSMDDRRAS29_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET29_LSB				11
+#define CSR_ACSMDDRCKESET29_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR29_LSB				12
+#define CSR_ACSMDDRCKECLR29_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD29_LSB			13
+#define CSR_ACSMSEQGATECMD29_MASK			BIT(13)
+#define CSR_ACSMSEQTERM29_LSB				14
+#define CSR_ACSMSEQTERM29_MASK				BIT(14)
+#define CSR_ACSMLP3CA329_LSB				15
+#define CSR_ACSMLP3CA329_MASK				BIT(15)
+/* CSR_ACSMSEQ0X30 */
+#define CSR_ACSMSEQ0X30_LSB				0
+#define CSR_ACSMSEQ0X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY30_LSB				0
+#define CSR_ACSMMCLKDLY30_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE30_LSB				8
+#define CSR_ACSMDDRWE30_MASK				BIT(8)
+#define CSR_ACSMDDRCAS30_LSB				9
+#define CSR_ACSMDDRCAS30_MASK				BIT(9)
+#define CSR_ACSMDDRRAS30_LSB				10
+#define CSR_ACSMDDRRAS30_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET30_LSB				11
+#define CSR_ACSMDDRCKESET30_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR30_LSB				12
+#define CSR_ACSMDDRCKECLR30_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD30_LSB			13
+#define CSR_ACSMSEQGATECMD30_MASK			BIT(13)
+#define CSR_ACSMSEQTERM30_LSB				14
+#define CSR_ACSMSEQTERM30_MASK				BIT(14)
+#define CSR_ACSMLP3CA330_LSB				15
+#define CSR_ACSMLP3CA330_MASK				BIT(15)
+/* CSR_ACSMSEQ0X31 */
+#define CSR_ACSMSEQ0X31_LSB				0
+#define CSR_ACSMSEQ0X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMMCLKDLY31_LSB				0
+#define CSR_ACSMMCLKDLY31_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDDRWE31_LSB				8
+#define CSR_ACSMDDRWE31_MASK				BIT(8)
+#define CSR_ACSMDDRCAS31_LSB				9
+#define CSR_ACSMDDRCAS31_MASK				BIT(9)
+#define CSR_ACSMDDRRAS31_LSB				10
+#define CSR_ACSMDDRRAS31_MASK				BIT(10)
+#define CSR_ACSMDDRCKESET31_LSB				11
+#define CSR_ACSMDDRCKESET31_MASK			BIT(11)
+#define CSR_ACSMDDRCKECLR31_LSB				12
+#define CSR_ACSMDDRCKECLR31_MASK			BIT(12)
+#define CSR_ACSMSEQGATECMD31_LSB			13
+#define CSR_ACSMSEQGATECMD31_MASK			BIT(13)
+#define CSR_ACSMSEQTERM31_LSB				14
+#define CSR_ACSMSEQTERM31_MASK				BIT(14)
+#define CSR_ACSMLP3CA331_LSB				15
+#define CSR_ACSMLP3CA331_MASK				BIT(15)
+/* CSR_ACSMSEQ1X0 */
+#define CSR_ACSMSEQ1X0_LSB				0
+#define CSR_ACSMSEQ1X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS0_LSB				0
+#define CSR_ACSMDDRCS0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN0_LSB				8
+#define CSR_ACSMSAVEGEN0_MASK				BIT(8)
+#define CSR_ACSMLOADCHK0_LSB				9
+#define CSR_ACSMLOADCHK0_MASK				BIT(9)
+#define CSR_ACSMNORXENB0_LSB				10
+#define CSR_ACSMNORXENB0_MASK				BIT(10)
+#define CSR_ACSMNORXVAL0_LSB				11
+#define CSR_ACSMNORXVAL0_MASK				BIT(11)
+#define CSR_ACSMDDRBNK0_LSB				12
+#define CSR_ACSMDDRBNK0_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X1 */
+#define CSR_ACSMSEQ1X1_LSB				0
+#define CSR_ACSMSEQ1X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS1_LSB				0
+#define CSR_ACSMDDRCS1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN1_LSB				8
+#define CSR_ACSMSAVEGEN1_MASK				BIT(8)
+#define CSR_ACSMLOADCHK1_LSB				9
+#define CSR_ACSMLOADCHK1_MASK				BIT(9)
+#define CSR_ACSMNORXENB1_LSB				10
+#define CSR_ACSMNORXENB1_MASK				BIT(10)
+#define CSR_ACSMNORXVAL1_LSB				11
+#define CSR_ACSMNORXVAL1_MASK				BIT(11)
+#define CSR_ACSMDDRBNK1_LSB				12
+#define CSR_ACSMDDRBNK1_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X2 */
+#define CSR_ACSMSEQ1X2_LSB				0
+#define CSR_ACSMSEQ1X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS2_LSB				0
+#define CSR_ACSMDDRCS2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN2_LSB				8
+#define CSR_ACSMSAVEGEN2_MASK				BIT(8)
+#define CSR_ACSMLOADCHK2_LSB				9
+#define CSR_ACSMLOADCHK2_MASK				BIT(9)
+#define CSR_ACSMNORXENB2_LSB				10
+#define CSR_ACSMNORXENB2_MASK				BIT(10)
+#define CSR_ACSMNORXVAL2_LSB				11
+#define CSR_ACSMNORXVAL2_MASK				BIT(11)
+#define CSR_ACSMDDRBNK2_LSB				12
+#define CSR_ACSMDDRBNK2_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X3 */
+#define CSR_ACSMSEQ1X3_LSB				0
+#define CSR_ACSMSEQ1X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS3_LSB				0
+#define CSR_ACSMDDRCS3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN3_LSB				8
+#define CSR_ACSMSAVEGEN3_MASK				BIT(8)
+#define CSR_ACSMLOADCHK3_LSB				9
+#define CSR_ACSMLOADCHK3_MASK				BIT(9)
+#define CSR_ACSMNORXENB3_LSB				10
+#define CSR_ACSMNORXENB3_MASK				BIT(10)
+#define CSR_ACSMNORXVAL3_LSB				11
+#define CSR_ACSMNORXVAL3_MASK				BIT(11)
+#define CSR_ACSMDDRBNK3_LSB				12
+#define CSR_ACSMDDRBNK3_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X4 */
+#define CSR_ACSMSEQ1X4_LSB				0
+#define CSR_ACSMSEQ1X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS4_LSB				0
+#define CSR_ACSMDDRCS4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN4_LSB				8
+#define CSR_ACSMSAVEGEN4_MASK				BIT(8)
+#define CSR_ACSMLOADCHK4_LSB				9
+#define CSR_ACSMLOADCHK4_MASK				BIT(9)
+#define CSR_ACSMNORXENB4_LSB				10
+#define CSR_ACSMNORXENB4_MASK				BIT(10)
+#define CSR_ACSMNORXVAL4_LSB				11
+#define CSR_ACSMNORXVAL4_MASK				BIT(11)
+#define CSR_ACSMDDRBNK4_LSB				12
+#define CSR_ACSMDDRBNK4_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X5 */
+#define CSR_ACSMSEQ1X5_LSB				0
+#define CSR_ACSMSEQ1X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS5_LSB				0
+#define CSR_ACSMDDRCS5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN5_LSB				8
+#define CSR_ACSMSAVEGEN5_MASK				BIT(8)
+#define CSR_ACSMLOADCHK5_LSB				9
+#define CSR_ACSMLOADCHK5_MASK				BIT(9)
+#define CSR_ACSMNORXENB5_LSB				10
+#define CSR_ACSMNORXENB5_MASK				BIT(10)
+#define CSR_ACSMNORXVAL5_LSB				11
+#define CSR_ACSMNORXVAL5_MASK				BIT(11)
+#define CSR_ACSMDDRBNK5_LSB				12
+#define CSR_ACSMDDRBNK5_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X6 */
+#define CSR_ACSMSEQ1X6_LSB				0
+#define CSR_ACSMSEQ1X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS6_LSB				0
+#define CSR_ACSMDDRCS6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN6_LSB				8
+#define CSR_ACSMSAVEGEN6_MASK				BIT(8)
+#define CSR_ACSMLOADCHK6_LSB				9
+#define CSR_ACSMLOADCHK6_MASK				BIT(9)
+#define CSR_ACSMNORXENB6_LSB				10
+#define CSR_ACSMNORXENB6_MASK				BIT(10)
+#define CSR_ACSMNORXVAL6_LSB				11
+#define CSR_ACSMNORXVAL6_MASK				BIT(11)
+#define CSR_ACSMDDRBNK6_LSB				12
+#define CSR_ACSMDDRBNK6_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X7 */
+#define CSR_ACSMSEQ1X7_LSB				0
+#define CSR_ACSMSEQ1X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS7_LSB				0
+#define CSR_ACSMDDRCS7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN7_LSB				8
+#define CSR_ACSMSAVEGEN7_MASK				BIT(8)
+#define CSR_ACSMLOADCHK7_LSB				9
+#define CSR_ACSMLOADCHK7_MASK				BIT(9)
+#define CSR_ACSMNORXENB7_LSB				10
+#define CSR_ACSMNORXENB7_MASK				BIT(10)
+#define CSR_ACSMNORXVAL7_LSB				11
+#define CSR_ACSMNORXVAL7_MASK				BIT(11)
+#define CSR_ACSMDDRBNK7_LSB				12
+#define CSR_ACSMDDRBNK7_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X8 */
+#define CSR_ACSMSEQ1X8_LSB				0
+#define CSR_ACSMSEQ1X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS8_LSB				0
+#define CSR_ACSMDDRCS8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN8_LSB				8
+#define CSR_ACSMSAVEGEN8_MASK				BIT(8)
+#define CSR_ACSMLOADCHK8_LSB				9
+#define CSR_ACSMLOADCHK8_MASK				BIT(9)
+#define CSR_ACSMNORXENB8_LSB				10
+#define CSR_ACSMNORXENB8_MASK				BIT(10)
+#define CSR_ACSMNORXVAL8_LSB				11
+#define CSR_ACSMNORXVAL8_MASK				BIT(11)
+#define CSR_ACSMDDRBNK8_LSB				12
+#define CSR_ACSMDDRBNK8_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X9 */
+#define CSR_ACSMSEQ1X9_LSB				0
+#define CSR_ACSMSEQ1X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS9_LSB				0
+#define CSR_ACSMDDRCS9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN9_LSB				8
+#define CSR_ACSMSAVEGEN9_MASK				BIT(8)
+#define CSR_ACSMLOADCHK9_LSB				9
+#define CSR_ACSMLOADCHK9_MASK				BIT(9)
+#define CSR_ACSMNORXENB9_LSB				10
+#define CSR_ACSMNORXENB9_MASK				BIT(10)
+#define CSR_ACSMNORXVAL9_LSB				11
+#define CSR_ACSMNORXVAL9_MASK				BIT(11)
+#define CSR_ACSMDDRBNK9_LSB				12
+#define CSR_ACSMDDRBNK9_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X10 */
+#define CSR_ACSMSEQ1X10_LSB				0
+#define CSR_ACSMSEQ1X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS10_LSB				0
+#define CSR_ACSMDDRCS10_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN10_LSB				8
+#define CSR_ACSMSAVEGEN10_MASK				BIT(8)
+#define CSR_ACSMLOADCHK10_LSB				9
+#define CSR_ACSMLOADCHK10_MASK				BIT(9)
+#define CSR_ACSMNORXENB10_LSB				10
+#define CSR_ACSMNORXENB10_MASK				BIT(10)
+#define CSR_ACSMNORXVAL10_LSB				11
+#define CSR_ACSMNORXVAL10_MASK				BIT(11)
+#define CSR_ACSMDDRBNK10_LSB				12
+#define CSR_ACSMDDRBNK10_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X11 */
+#define CSR_ACSMSEQ1X11_LSB				0
+#define CSR_ACSMSEQ1X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS11_LSB				0
+#define CSR_ACSMDDRCS11_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN11_LSB				8
+#define CSR_ACSMSAVEGEN11_MASK				BIT(8)
+#define CSR_ACSMLOADCHK11_LSB				9
+#define CSR_ACSMLOADCHK11_MASK				BIT(9)
+#define CSR_ACSMNORXENB11_LSB				10
+#define CSR_ACSMNORXENB11_MASK				BIT(10)
+#define CSR_ACSMNORXVAL11_LSB				11
+#define CSR_ACSMNORXVAL11_MASK				BIT(11)
+#define CSR_ACSMDDRBNK11_LSB				12
+#define CSR_ACSMDDRBNK11_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X12 */
+#define CSR_ACSMSEQ1X12_LSB				0
+#define CSR_ACSMSEQ1X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS12_LSB				0
+#define CSR_ACSMDDRCS12_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN12_LSB				8
+#define CSR_ACSMSAVEGEN12_MASK				BIT(8)
+#define CSR_ACSMLOADCHK12_LSB				9
+#define CSR_ACSMLOADCHK12_MASK				BIT(9)
+#define CSR_ACSMNORXENB12_LSB				10
+#define CSR_ACSMNORXENB12_MASK				BIT(10)
+#define CSR_ACSMNORXVAL12_LSB				11
+#define CSR_ACSMNORXVAL12_MASK				BIT(11)
+#define CSR_ACSMDDRBNK12_LSB				12
+#define CSR_ACSMDDRBNK12_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X13 */
+#define CSR_ACSMSEQ1X13_LSB				0
+#define CSR_ACSMSEQ1X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS13_LSB				0
+#define CSR_ACSMDDRCS13_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN13_LSB				8
+#define CSR_ACSMSAVEGEN13_MASK				BIT(8)
+#define CSR_ACSMLOADCHK13_LSB				9
+#define CSR_ACSMLOADCHK13_MASK				BIT(9)
+#define CSR_ACSMNORXENB13_LSB				10
+#define CSR_ACSMNORXENB13_MASK				BIT(10)
+#define CSR_ACSMNORXVAL13_LSB				11
+#define CSR_ACSMNORXVAL13_MASK				BIT(11)
+#define CSR_ACSMDDRBNK13_LSB				12
+#define CSR_ACSMDDRBNK13_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X14 */
+#define CSR_ACSMSEQ1X14_LSB				0
+#define CSR_ACSMSEQ1X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS14_LSB				0
+#define CSR_ACSMDDRCS14_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN14_LSB				8
+#define CSR_ACSMSAVEGEN14_MASK				BIT(8)
+#define CSR_ACSMLOADCHK14_LSB				9
+#define CSR_ACSMLOADCHK14_MASK				BIT(9)
+#define CSR_ACSMNORXENB14_LSB				10
+#define CSR_ACSMNORXENB14_MASK				BIT(10)
+#define CSR_ACSMNORXVAL14_LSB				11
+#define CSR_ACSMNORXVAL14_MASK				BIT(11)
+#define CSR_ACSMDDRBNK14_LSB				12
+#define CSR_ACSMDDRBNK14_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X15 */
+#define CSR_ACSMSEQ1X15_LSB				0
+#define CSR_ACSMSEQ1X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS15_LSB				0
+#define CSR_ACSMDDRCS15_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN15_LSB				8
+#define CSR_ACSMSAVEGEN15_MASK				BIT(8)
+#define CSR_ACSMLOADCHK15_LSB				9
+#define CSR_ACSMLOADCHK15_MASK				BIT(9)
+#define CSR_ACSMNORXENB15_LSB				10
+#define CSR_ACSMNORXENB15_MASK				BIT(10)
+#define CSR_ACSMNORXVAL15_LSB				11
+#define CSR_ACSMNORXVAL15_MASK				BIT(11)
+#define CSR_ACSMDDRBNK15_LSB				12
+#define CSR_ACSMDDRBNK15_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X16 */
+#define CSR_ACSMSEQ1X16_LSB				0
+#define CSR_ACSMSEQ1X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS16_LSB				0
+#define CSR_ACSMDDRCS16_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN16_LSB				8
+#define CSR_ACSMSAVEGEN16_MASK				BIT(8)
+#define CSR_ACSMLOADCHK16_LSB				9
+#define CSR_ACSMLOADCHK16_MASK				BIT(9)
+#define CSR_ACSMNORXENB16_LSB				10
+#define CSR_ACSMNORXENB16_MASK				BIT(10)
+#define CSR_ACSMNORXVAL16_LSB				11
+#define CSR_ACSMNORXVAL16_MASK				BIT(11)
+#define CSR_ACSMDDRBNK16_LSB				12
+#define CSR_ACSMDDRBNK16_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X17 */
+#define CSR_ACSMSEQ1X17_LSB				0
+#define CSR_ACSMSEQ1X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS17_LSB				0
+#define CSR_ACSMDDRCS17_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN17_LSB				8
+#define CSR_ACSMSAVEGEN17_MASK				BIT(8)
+#define CSR_ACSMLOADCHK17_LSB				9
+#define CSR_ACSMLOADCHK17_MASK				BIT(9)
+#define CSR_ACSMNORXENB17_LSB				10
+#define CSR_ACSMNORXENB17_MASK				BIT(10)
+#define CSR_ACSMNORXVAL17_LSB				11
+#define CSR_ACSMNORXVAL17_MASK				BIT(11)
+#define CSR_ACSMDDRBNK17_LSB				12
+#define CSR_ACSMDDRBNK17_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X18 */
+#define CSR_ACSMSEQ1X18_LSB				0
+#define CSR_ACSMSEQ1X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS18_LSB				0
+#define CSR_ACSMDDRCS18_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN18_LSB				8
+#define CSR_ACSMSAVEGEN18_MASK				BIT(8)
+#define CSR_ACSMLOADCHK18_LSB				9
+#define CSR_ACSMLOADCHK18_MASK				BIT(9)
+#define CSR_ACSMNORXENB18_LSB				10
+#define CSR_ACSMNORXENB18_MASK				BIT(10)
+#define CSR_ACSMNORXVAL18_LSB				11
+#define CSR_ACSMNORXVAL18_MASK				BIT(11)
+#define CSR_ACSMDDRBNK18_LSB				12
+#define CSR_ACSMDDRBNK18_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X19 */
+#define CSR_ACSMSEQ1X19_LSB				0
+#define CSR_ACSMSEQ1X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS19_LSB				0
+#define CSR_ACSMDDRCS19_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN19_LSB				8
+#define CSR_ACSMSAVEGEN19_MASK				BIT(8)
+#define CSR_ACSMLOADCHK19_LSB				9
+#define CSR_ACSMLOADCHK19_MASK				BIT(9)
+#define CSR_ACSMNORXENB19_LSB				10
+#define CSR_ACSMNORXENB19_MASK				BIT(10)
+#define CSR_ACSMNORXVAL19_LSB				11
+#define CSR_ACSMNORXVAL19_MASK				BIT(11)
+#define CSR_ACSMDDRBNK19_LSB				12
+#define CSR_ACSMDDRBNK19_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X20 */
+#define CSR_ACSMSEQ1X20_LSB				0
+#define CSR_ACSMSEQ1X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS20_LSB				0
+#define CSR_ACSMDDRCS20_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN20_LSB				8
+#define CSR_ACSMSAVEGEN20_MASK				BIT(8)
+#define CSR_ACSMLOADCHK20_LSB				9
+#define CSR_ACSMLOADCHK20_MASK				BIT(9)
+#define CSR_ACSMNORXENB20_LSB				10
+#define CSR_ACSMNORXENB20_MASK				BIT(10)
+#define CSR_ACSMNORXVAL20_LSB				11
+#define CSR_ACSMNORXVAL20_MASK				BIT(11)
+#define CSR_ACSMDDRBNK20_LSB				12
+#define CSR_ACSMDDRBNK20_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X21 */
+#define CSR_ACSMSEQ1X21_LSB				0
+#define CSR_ACSMSEQ1X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS21_LSB				0
+#define CSR_ACSMDDRCS21_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN21_LSB				8
+#define CSR_ACSMSAVEGEN21_MASK				BIT(8)
+#define CSR_ACSMLOADCHK21_LSB				9
+#define CSR_ACSMLOADCHK21_MASK				BIT(9)
+#define CSR_ACSMNORXENB21_LSB				10
+#define CSR_ACSMNORXENB21_MASK				BIT(10)
+#define CSR_ACSMNORXVAL21_LSB				11
+#define CSR_ACSMNORXVAL21_MASK				BIT(11)
+#define CSR_ACSMDDRBNK21_LSB				12
+#define CSR_ACSMDDRBNK21_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X22 */
+#define CSR_ACSMSEQ1X22_LSB				0
+#define CSR_ACSMSEQ1X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS22_LSB				0
+#define CSR_ACSMDDRCS22_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN22_LSB				8
+#define CSR_ACSMSAVEGEN22_MASK				BIT(8)
+#define CSR_ACSMLOADCHK22_LSB				9
+#define CSR_ACSMLOADCHK22_MASK				BIT(9)
+#define CSR_ACSMNORXENB22_LSB				10
+#define CSR_ACSMNORXENB22_MASK				BIT(10)
+#define CSR_ACSMNORXVAL22_LSB				11
+#define CSR_ACSMNORXVAL22_MASK				BIT(11)
+#define CSR_ACSMDDRBNK22_LSB				12
+#define CSR_ACSMDDRBNK22_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X23 */
+#define CSR_ACSMSEQ1X23_LSB				0
+#define CSR_ACSMSEQ1X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS23_LSB				0
+#define CSR_ACSMDDRCS23_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN23_LSB				8
+#define CSR_ACSMSAVEGEN23_MASK				BIT(8)
+#define CSR_ACSMLOADCHK23_LSB				9
+#define CSR_ACSMLOADCHK23_MASK				BIT(9)
+#define CSR_ACSMNORXENB23_LSB				10
+#define CSR_ACSMNORXENB23_MASK				BIT(10)
+#define CSR_ACSMNORXVAL23_LSB				11
+#define CSR_ACSMNORXVAL23_MASK				BIT(11)
+#define CSR_ACSMDDRBNK23_LSB				12
+#define CSR_ACSMDDRBNK23_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X24 */
+#define CSR_ACSMSEQ1X24_LSB				0
+#define CSR_ACSMSEQ1X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS24_LSB				0
+#define CSR_ACSMDDRCS24_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN24_LSB				8
+#define CSR_ACSMSAVEGEN24_MASK				BIT(8)
+#define CSR_ACSMLOADCHK24_LSB				9
+#define CSR_ACSMLOADCHK24_MASK				BIT(9)
+#define CSR_ACSMNORXENB24_LSB				10
+#define CSR_ACSMNORXENB24_MASK				BIT(10)
+#define CSR_ACSMNORXVAL24_LSB				11
+#define CSR_ACSMNORXVAL24_MASK				BIT(11)
+#define CSR_ACSMDDRBNK24_LSB				12
+#define CSR_ACSMDDRBNK24_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X25 */
+#define CSR_ACSMSEQ1X25_LSB				0
+#define CSR_ACSMSEQ1X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS25_LSB				0
+#define CSR_ACSMDDRCS25_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN25_LSB				8
+#define CSR_ACSMSAVEGEN25_MASK				BIT(8)
+#define CSR_ACSMLOADCHK25_LSB				9
+#define CSR_ACSMLOADCHK25_MASK				BIT(9)
+#define CSR_ACSMNORXENB25_LSB				10
+#define CSR_ACSMNORXENB25_MASK				BIT(10)
+#define CSR_ACSMNORXVAL25_LSB				11
+#define CSR_ACSMNORXVAL25_MASK				BIT(11)
+#define CSR_ACSMDDRBNK25_LSB				12
+#define CSR_ACSMDDRBNK25_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X26 */
+#define CSR_ACSMSEQ1X26_LSB				0
+#define CSR_ACSMSEQ1X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS26_LSB				0
+#define CSR_ACSMDDRCS26_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN26_LSB				8
+#define CSR_ACSMSAVEGEN26_MASK				BIT(8)
+#define CSR_ACSMLOADCHK26_LSB				9
+#define CSR_ACSMLOADCHK26_MASK				BIT(9)
+#define CSR_ACSMNORXENB26_LSB				10
+#define CSR_ACSMNORXENB26_MASK				BIT(10)
+#define CSR_ACSMNORXVAL26_LSB				11
+#define CSR_ACSMNORXVAL26_MASK				BIT(11)
+#define CSR_ACSMDDRBNK26_LSB				12
+#define CSR_ACSMDDRBNK26_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X27 */
+#define CSR_ACSMSEQ1X27_LSB				0
+#define CSR_ACSMSEQ1X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS27_LSB				0
+#define CSR_ACSMDDRCS27_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN27_LSB				8
+#define CSR_ACSMSAVEGEN27_MASK				BIT(8)
+#define CSR_ACSMLOADCHK27_LSB				9
+#define CSR_ACSMLOADCHK27_MASK				BIT(9)
+#define CSR_ACSMNORXENB27_LSB				10
+#define CSR_ACSMNORXENB27_MASK				BIT(10)
+#define CSR_ACSMNORXVAL27_LSB				11
+#define CSR_ACSMNORXVAL27_MASK				BIT(11)
+#define CSR_ACSMDDRBNK27_LSB				12
+#define CSR_ACSMDDRBNK27_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X28 */
+#define CSR_ACSMSEQ1X28_LSB				0
+#define CSR_ACSMSEQ1X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS28_LSB				0
+#define CSR_ACSMDDRCS28_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN28_LSB				8
+#define CSR_ACSMSAVEGEN28_MASK				BIT(8)
+#define CSR_ACSMLOADCHK28_LSB				9
+#define CSR_ACSMLOADCHK28_MASK				BIT(9)
+#define CSR_ACSMNORXENB28_LSB				10
+#define CSR_ACSMNORXENB28_MASK				BIT(10)
+#define CSR_ACSMNORXVAL28_LSB				11
+#define CSR_ACSMNORXVAL28_MASK				BIT(11)
+#define CSR_ACSMDDRBNK28_LSB				12
+#define CSR_ACSMDDRBNK28_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X29 */
+#define CSR_ACSMSEQ1X29_LSB				0
+#define CSR_ACSMSEQ1X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS29_LSB				0
+#define CSR_ACSMDDRCS29_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN29_LSB				8
+#define CSR_ACSMSAVEGEN29_MASK				BIT(8)
+#define CSR_ACSMLOADCHK29_LSB				9
+#define CSR_ACSMLOADCHK29_MASK				BIT(9)
+#define CSR_ACSMNORXENB29_LSB				10
+#define CSR_ACSMNORXENB29_MASK				BIT(10)
+#define CSR_ACSMNORXVAL29_LSB				11
+#define CSR_ACSMNORXVAL29_MASK				BIT(11)
+#define CSR_ACSMDDRBNK29_LSB				12
+#define CSR_ACSMDDRBNK29_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X30 */
+#define CSR_ACSMSEQ1X30_LSB				0
+#define CSR_ACSMSEQ1X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS30_LSB				0
+#define CSR_ACSMDDRCS30_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN30_LSB				8
+#define CSR_ACSMSAVEGEN30_MASK				BIT(8)
+#define CSR_ACSMLOADCHK30_LSB				9
+#define CSR_ACSMLOADCHK30_MASK				BIT(9)
+#define CSR_ACSMNORXENB30_LSB				10
+#define CSR_ACSMNORXENB30_MASK				BIT(10)
+#define CSR_ACSMNORXVAL30_LSB				11
+#define CSR_ACSMNORXVAL30_MASK				BIT(11)
+#define CSR_ACSMDDRBNK30_LSB				12
+#define CSR_ACSMDDRBNK30_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ1X31 */
+#define CSR_ACSMSEQ1X31_LSB				0
+#define CSR_ACSMSEQ1X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRCS31_LSB				0
+#define CSR_ACSMDDRCS31_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMSAVEGEN31_LSB				8
+#define CSR_ACSMSAVEGEN31_MASK				BIT(8)
+#define CSR_ACSMLOADCHK31_LSB				9
+#define CSR_ACSMLOADCHK31_MASK				BIT(9)
+#define CSR_ACSMNORXENB31_LSB				10
+#define CSR_ACSMNORXENB31_MASK				BIT(10)
+#define CSR_ACSMNORXVAL31_LSB				11
+#define CSR_ACSMNORXVAL31_MASK				BIT(11)
+#define CSR_ACSMDDRBNK31_LSB				12
+#define CSR_ACSMDDRBNK31_MASK				GENMASK_32(15, 12)
+/* CSR_ACSMSEQ2X0 */
+#define CSR_ACSMSEQ2X0_LSB				0
+#define CSR_ACSMSEQ2X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X0_LSB			0
+#define CSR_ACSMDDRADRX15X0X0_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X1 */
+#define CSR_ACSMSEQ2X1_LSB				0
+#define CSR_ACSMSEQ2X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X1_LSB			0
+#define CSR_ACSMDDRADRX15X0X1_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X2 */
+#define CSR_ACSMSEQ2X2_LSB				0
+#define CSR_ACSMSEQ2X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X2_LSB			0
+#define CSR_ACSMDDRADRX15X0X2_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X3 */
+#define CSR_ACSMSEQ2X3_LSB				0
+#define CSR_ACSMSEQ2X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X3_LSB			0
+#define CSR_ACSMDDRADRX15X0X3_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X4 */
+#define CSR_ACSMSEQ2X4_LSB				0
+#define CSR_ACSMSEQ2X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X4_LSB			0
+#define CSR_ACSMDDRADRX15X0X4_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X5 */
+#define CSR_ACSMSEQ2X5_LSB				0
+#define CSR_ACSMSEQ2X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X5_LSB			0
+#define CSR_ACSMDDRADRX15X0X5_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X6 */
+#define CSR_ACSMSEQ2X6_LSB				0
+#define CSR_ACSMSEQ2X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X6_LSB			0
+#define CSR_ACSMDDRADRX15X0X6_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X7 */
+#define CSR_ACSMSEQ2X7_LSB				0
+#define CSR_ACSMSEQ2X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X7_LSB			0
+#define CSR_ACSMDDRADRX15X0X7_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X8 */
+#define CSR_ACSMSEQ2X8_LSB				0
+#define CSR_ACSMSEQ2X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X8_LSB			0
+#define CSR_ACSMDDRADRX15X0X8_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X9 */
+#define CSR_ACSMSEQ2X9_LSB				0
+#define CSR_ACSMSEQ2X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X9_LSB			0
+#define CSR_ACSMDDRADRX15X0X9_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X10 */
+#define CSR_ACSMSEQ2X10_LSB				0
+#define CSR_ACSMSEQ2X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X10_LSB			0
+#define CSR_ACSMDDRADRX15X0X10_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X11 */
+#define CSR_ACSMSEQ2X11_LSB				0
+#define CSR_ACSMSEQ2X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X11_LSB			0
+#define CSR_ACSMDDRADRX15X0X11_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X12 */
+#define CSR_ACSMSEQ2X12_LSB				0
+#define CSR_ACSMSEQ2X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X12_LSB			0
+#define CSR_ACSMDDRADRX15X0X12_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X13 */
+#define CSR_ACSMSEQ2X13_LSB				0
+#define CSR_ACSMSEQ2X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X13_LSB			0
+#define CSR_ACSMDDRADRX15X0X13_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X14 */
+#define CSR_ACSMSEQ2X14_LSB				0
+#define CSR_ACSMSEQ2X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X14_LSB			0
+#define CSR_ACSMDDRADRX15X0X14_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X15 */
+#define CSR_ACSMSEQ2X15_LSB				0
+#define CSR_ACSMSEQ2X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X15_LSB			0
+#define CSR_ACSMDDRADRX15X0X15_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X16 */
+#define CSR_ACSMSEQ2X16_LSB				0
+#define CSR_ACSMSEQ2X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X16_LSB			0
+#define CSR_ACSMDDRADRX15X0X16_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X17 */
+#define CSR_ACSMSEQ2X17_LSB				0
+#define CSR_ACSMSEQ2X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X17_LSB			0
+#define CSR_ACSMDDRADRX15X0X17_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X18 */
+#define CSR_ACSMSEQ2X18_LSB				0
+#define CSR_ACSMSEQ2X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X18_LSB			0
+#define CSR_ACSMDDRADRX15X0X18_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X19 */
+#define CSR_ACSMSEQ2X19_LSB				0
+#define CSR_ACSMSEQ2X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X19_LSB			0
+#define CSR_ACSMDDRADRX15X0X19_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X20 */
+#define CSR_ACSMSEQ2X20_LSB				0
+#define CSR_ACSMSEQ2X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X20_LSB			0
+#define CSR_ACSMDDRADRX15X0X20_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X21 */
+#define CSR_ACSMSEQ2X21_LSB				0
+#define CSR_ACSMSEQ2X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X21_LSB			0
+#define CSR_ACSMDDRADRX15X0X21_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X22 */
+#define CSR_ACSMSEQ2X22_LSB				0
+#define CSR_ACSMSEQ2X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X22_LSB			0
+#define CSR_ACSMDDRADRX15X0X22_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X23 */
+#define CSR_ACSMSEQ2X23_LSB				0
+#define CSR_ACSMSEQ2X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X23_LSB			0
+#define CSR_ACSMDDRADRX15X0X23_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X24 */
+#define CSR_ACSMSEQ2X24_LSB				0
+#define CSR_ACSMSEQ2X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X24_LSB			0
+#define CSR_ACSMDDRADRX15X0X24_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X25 */
+#define CSR_ACSMSEQ2X25_LSB				0
+#define CSR_ACSMSEQ2X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X25_LSB			0
+#define CSR_ACSMDDRADRX15X0X25_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X26 */
+#define CSR_ACSMSEQ2X26_LSB				0
+#define CSR_ACSMSEQ2X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X26_LSB			0
+#define CSR_ACSMDDRADRX15X0X26_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X27 */
+#define CSR_ACSMSEQ2X27_LSB				0
+#define CSR_ACSMSEQ2X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X27_LSB			0
+#define CSR_ACSMDDRADRX15X0X27_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X28 */
+#define CSR_ACSMSEQ2X28_LSB				0
+#define CSR_ACSMSEQ2X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X28_LSB			0
+#define CSR_ACSMDDRADRX15X0X28_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X29 */
+#define CSR_ACSMSEQ2X29_LSB				0
+#define CSR_ACSMSEQ2X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X29_LSB			0
+#define CSR_ACSMDDRADRX15X0X29_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X30 */
+#define CSR_ACSMSEQ2X30_LSB				0
+#define CSR_ACSMSEQ2X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X30_LSB			0
+#define CSR_ACSMDDRADRX15X0X30_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ2X31 */
+#define CSR_ACSMSEQ2X31_LSB				0
+#define CSR_ACSMSEQ2X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRX15X0X31_LSB			0
+#define CSR_ACSMDDRADRX15X0X31_MASK			GENMASK_32(15, 0)
+/* CSR_ACSMSEQ3X0 */
+#define CSR_ACSMSEQ3X0_LSB				0
+#define CSR_ACSMSEQ3X0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT0_LSB				0
+#define CSR_ACSMCMDREPCNT0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV0_LSB				8
+#define CSR_ACSMADRADV0_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV0_LSB				10
+#define CSR_ACSMBNKADV0_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD0_LSB				12
+#define CSR_ACSMADRSELLOAD0_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD0_LSB				14
+#define CSR_ACSMBNKSELLOAD0_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE0_LSB				15
+#define CSR_ACSMLONGBUBBLE0_MASK			BIT(15)
+/* CSR_ACSMSEQ3X1 */
+#define CSR_ACSMSEQ3X1_LSB				0
+#define CSR_ACSMSEQ3X1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT1_LSB				0
+#define CSR_ACSMCMDREPCNT1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV1_LSB				8
+#define CSR_ACSMADRADV1_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV1_LSB				10
+#define CSR_ACSMBNKADV1_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD1_LSB				12
+#define CSR_ACSMADRSELLOAD1_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD1_LSB				14
+#define CSR_ACSMBNKSELLOAD1_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE1_LSB				15
+#define CSR_ACSMLONGBUBBLE1_MASK			BIT(15)
+/* CSR_ACSMSEQ3X2 */
+#define CSR_ACSMSEQ3X2_LSB				0
+#define CSR_ACSMSEQ3X2_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT2_LSB				0
+#define CSR_ACSMCMDREPCNT2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV2_LSB				8
+#define CSR_ACSMADRADV2_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV2_LSB				10
+#define CSR_ACSMBNKADV2_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD2_LSB				12
+#define CSR_ACSMADRSELLOAD2_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD2_LSB				14
+#define CSR_ACSMBNKSELLOAD2_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE2_LSB				15
+#define CSR_ACSMLONGBUBBLE2_MASK			BIT(15)
+/* CSR_ACSMSEQ3X3 */
+#define CSR_ACSMSEQ3X3_LSB				0
+#define CSR_ACSMSEQ3X3_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT3_LSB				0
+#define CSR_ACSMCMDREPCNT3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV3_LSB				8
+#define CSR_ACSMADRADV3_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV3_LSB				10
+#define CSR_ACSMBNKADV3_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD3_LSB				12
+#define CSR_ACSMADRSELLOAD3_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD3_LSB				14
+#define CSR_ACSMBNKSELLOAD3_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE3_LSB				15
+#define CSR_ACSMLONGBUBBLE3_MASK			BIT(15)
+/* CSR_ACSMSEQ3X4 */
+#define CSR_ACSMSEQ3X4_LSB				0
+#define CSR_ACSMSEQ3X4_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT4_LSB				0
+#define CSR_ACSMCMDREPCNT4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV4_LSB				8
+#define CSR_ACSMADRADV4_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV4_LSB				10
+#define CSR_ACSMBNKADV4_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD4_LSB				12
+#define CSR_ACSMADRSELLOAD4_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD4_LSB				14
+#define CSR_ACSMBNKSELLOAD4_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE4_LSB				15
+#define CSR_ACSMLONGBUBBLE4_MASK			BIT(15)
+/* CSR_ACSMSEQ3X5 */
+#define CSR_ACSMSEQ3X5_LSB				0
+#define CSR_ACSMSEQ3X5_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT5_LSB				0
+#define CSR_ACSMCMDREPCNT5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV5_LSB				8
+#define CSR_ACSMADRADV5_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV5_LSB				10
+#define CSR_ACSMBNKADV5_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD5_LSB				12
+#define CSR_ACSMADRSELLOAD5_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD5_LSB				14
+#define CSR_ACSMBNKSELLOAD5_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE5_LSB				15
+#define CSR_ACSMLONGBUBBLE5_MASK			BIT(15)
+/* CSR_ACSMSEQ3X6 */
+#define CSR_ACSMSEQ3X6_LSB				0
+#define CSR_ACSMSEQ3X6_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT6_LSB				0
+#define CSR_ACSMCMDREPCNT6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV6_LSB				8
+#define CSR_ACSMADRADV6_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV6_LSB				10
+#define CSR_ACSMBNKADV6_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD6_LSB				12
+#define CSR_ACSMADRSELLOAD6_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD6_LSB				14
+#define CSR_ACSMBNKSELLOAD6_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE6_LSB				15
+#define CSR_ACSMLONGBUBBLE6_MASK			BIT(15)
+/* CSR_ACSMSEQ3X7 */
+#define CSR_ACSMSEQ3X7_LSB				0
+#define CSR_ACSMSEQ3X7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT7_LSB				0
+#define CSR_ACSMCMDREPCNT7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV7_LSB				8
+#define CSR_ACSMADRADV7_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV7_LSB				10
+#define CSR_ACSMBNKADV7_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD7_LSB				12
+#define CSR_ACSMADRSELLOAD7_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD7_LSB				14
+#define CSR_ACSMBNKSELLOAD7_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE7_LSB				15
+#define CSR_ACSMLONGBUBBLE7_MASK			BIT(15)
+/* CSR_ACSMSEQ3X8 */
+#define CSR_ACSMSEQ3X8_LSB				0
+#define CSR_ACSMSEQ3X8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT8_LSB				0
+#define CSR_ACSMCMDREPCNT8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV8_LSB				8
+#define CSR_ACSMADRADV8_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV8_LSB				10
+#define CSR_ACSMBNKADV8_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD8_LSB				12
+#define CSR_ACSMADRSELLOAD8_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD8_LSB				14
+#define CSR_ACSMBNKSELLOAD8_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE8_LSB				15
+#define CSR_ACSMLONGBUBBLE8_MASK			BIT(15)
+/* CSR_ACSMSEQ3X9 */
+#define CSR_ACSMSEQ3X9_LSB				0
+#define CSR_ACSMSEQ3X9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT9_LSB				0
+#define CSR_ACSMCMDREPCNT9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMADRADV9_LSB				8
+#define CSR_ACSMADRADV9_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV9_LSB				10
+#define CSR_ACSMBNKADV9_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD9_LSB				12
+#define CSR_ACSMADRSELLOAD9_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD9_LSB				14
+#define CSR_ACSMBNKSELLOAD9_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE9_LSB				15
+#define CSR_ACSMLONGBUBBLE9_MASK			BIT(15)
+/* CSR_ACSMSEQ3X10 */
+#define CSR_ACSMSEQ3X10_LSB				0
+#define CSR_ACSMSEQ3X10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT10_LSB				0
+#define CSR_ACSMCMDREPCNT10_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV10_LSB				8
+#define CSR_ACSMADRADV10_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV10_LSB				10
+#define CSR_ACSMBNKADV10_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD10_LSB			12
+#define CSR_ACSMADRSELLOAD10_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD10_LSB			14
+#define CSR_ACSMBNKSELLOAD10_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE10_LSB			15
+#define CSR_ACSMLONGBUBBLE10_MASK			BIT(15)
+/* CSR_ACSMSEQ3X11 */
+#define CSR_ACSMSEQ3X11_LSB				0
+#define CSR_ACSMSEQ3X11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT11_LSB				0
+#define CSR_ACSMCMDREPCNT11_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV11_LSB				8
+#define CSR_ACSMADRADV11_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV11_LSB				10
+#define CSR_ACSMBNKADV11_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD11_LSB			12
+#define CSR_ACSMADRSELLOAD11_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD11_LSB			14
+#define CSR_ACSMBNKSELLOAD11_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE11_LSB			15
+#define CSR_ACSMLONGBUBBLE11_MASK			BIT(15)
+/* CSR_ACSMSEQ3X12 */
+#define CSR_ACSMSEQ3X12_LSB				0
+#define CSR_ACSMSEQ3X12_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT12_LSB				0
+#define CSR_ACSMCMDREPCNT12_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV12_LSB				8
+#define CSR_ACSMADRADV12_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV12_LSB				10
+#define CSR_ACSMBNKADV12_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD12_LSB			12
+#define CSR_ACSMADRSELLOAD12_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD12_LSB			14
+#define CSR_ACSMBNKSELLOAD12_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE12_LSB			15
+#define CSR_ACSMLONGBUBBLE12_MASK			BIT(15)
+/* CSR_ACSMSEQ3X13 */
+#define CSR_ACSMSEQ3X13_LSB				0
+#define CSR_ACSMSEQ3X13_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT13_LSB				0
+#define CSR_ACSMCMDREPCNT13_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV13_LSB				8
+#define CSR_ACSMADRADV13_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV13_LSB				10
+#define CSR_ACSMBNKADV13_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD13_LSB			12
+#define CSR_ACSMADRSELLOAD13_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD13_LSB			14
+#define CSR_ACSMBNKSELLOAD13_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE13_LSB			15
+#define CSR_ACSMLONGBUBBLE13_MASK			BIT(15)
+/* CSR_ACSMSEQ3X14 */
+#define CSR_ACSMSEQ3X14_LSB				0
+#define CSR_ACSMSEQ3X14_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT14_LSB				0
+#define CSR_ACSMCMDREPCNT14_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV14_LSB				8
+#define CSR_ACSMADRADV14_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV14_LSB				10
+#define CSR_ACSMBNKADV14_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD14_LSB			12
+#define CSR_ACSMADRSELLOAD14_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD14_LSB			14
+#define CSR_ACSMBNKSELLOAD14_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE14_LSB			15
+#define CSR_ACSMLONGBUBBLE14_MASK			BIT(15)
+/* CSR_ACSMSEQ3X15 */
+#define CSR_ACSMSEQ3X15_LSB				0
+#define CSR_ACSMSEQ3X15_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT15_LSB				0
+#define CSR_ACSMCMDREPCNT15_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV15_LSB				8
+#define CSR_ACSMADRADV15_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV15_LSB				10
+#define CSR_ACSMBNKADV15_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD15_LSB			12
+#define CSR_ACSMADRSELLOAD15_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD15_LSB			14
+#define CSR_ACSMBNKSELLOAD15_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE15_LSB			15
+#define CSR_ACSMLONGBUBBLE15_MASK			BIT(15)
+/* CSR_ACSMSEQ3X16 */
+#define CSR_ACSMSEQ3X16_LSB				0
+#define CSR_ACSMSEQ3X16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT16_LSB				0
+#define CSR_ACSMCMDREPCNT16_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV16_LSB				8
+#define CSR_ACSMADRADV16_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV16_LSB				10
+#define CSR_ACSMBNKADV16_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD16_LSB			12
+#define CSR_ACSMADRSELLOAD16_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD16_LSB			14
+#define CSR_ACSMBNKSELLOAD16_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE16_LSB			15
+#define CSR_ACSMLONGBUBBLE16_MASK			BIT(15)
+/* CSR_ACSMSEQ3X17 */
+#define CSR_ACSMSEQ3X17_LSB				0
+#define CSR_ACSMSEQ3X17_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT17_LSB				0
+#define CSR_ACSMCMDREPCNT17_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV17_LSB				8
+#define CSR_ACSMADRADV17_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV17_LSB				10
+#define CSR_ACSMBNKADV17_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD17_LSB			12
+#define CSR_ACSMADRSELLOAD17_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD17_LSB			14
+#define CSR_ACSMBNKSELLOAD17_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE17_LSB			15
+#define CSR_ACSMLONGBUBBLE17_MASK			BIT(15)
+/* CSR_ACSMSEQ3X18 */
+#define CSR_ACSMSEQ3X18_LSB				0
+#define CSR_ACSMSEQ3X18_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT18_LSB				0
+#define CSR_ACSMCMDREPCNT18_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV18_LSB				8
+#define CSR_ACSMADRADV18_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV18_LSB				10
+#define CSR_ACSMBNKADV18_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD18_LSB			12
+#define CSR_ACSMADRSELLOAD18_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD18_LSB			14
+#define CSR_ACSMBNKSELLOAD18_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE18_LSB			15
+#define CSR_ACSMLONGBUBBLE18_MASK			BIT(15)
+/* CSR_ACSMSEQ3X19 */
+#define CSR_ACSMSEQ3X19_LSB				0
+#define CSR_ACSMSEQ3X19_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT19_LSB				0
+#define CSR_ACSMCMDREPCNT19_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV19_LSB				8
+#define CSR_ACSMADRADV19_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV19_LSB				10
+#define CSR_ACSMBNKADV19_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD19_LSB			12
+#define CSR_ACSMADRSELLOAD19_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD19_LSB			14
+#define CSR_ACSMBNKSELLOAD19_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE19_LSB			15
+#define CSR_ACSMLONGBUBBLE19_MASK			BIT(15)
+/* CSR_ACSMSEQ3X20 */
+#define CSR_ACSMSEQ3X20_LSB				0
+#define CSR_ACSMSEQ3X20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT20_LSB				0
+#define CSR_ACSMCMDREPCNT20_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV20_LSB				8
+#define CSR_ACSMADRADV20_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV20_LSB				10
+#define CSR_ACSMBNKADV20_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD20_LSB			12
+#define CSR_ACSMADRSELLOAD20_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD20_LSB			14
+#define CSR_ACSMBNKSELLOAD20_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE20_LSB			15
+#define CSR_ACSMLONGBUBBLE20_MASK			BIT(15)
+/* CSR_ACSMSEQ3X21 */
+#define CSR_ACSMSEQ3X21_LSB				0
+#define CSR_ACSMSEQ3X21_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT21_LSB				0
+#define CSR_ACSMCMDREPCNT21_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV21_LSB				8
+#define CSR_ACSMADRADV21_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV21_LSB				10
+#define CSR_ACSMBNKADV21_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD21_LSB			12
+#define CSR_ACSMADRSELLOAD21_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD21_LSB			14
+#define CSR_ACSMBNKSELLOAD21_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE21_LSB			15
+#define CSR_ACSMLONGBUBBLE21_MASK			BIT(15)
+/* CSR_ACSMSEQ3X22 */
+#define CSR_ACSMSEQ3X22_LSB				0
+#define CSR_ACSMSEQ3X22_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT22_LSB				0
+#define CSR_ACSMCMDREPCNT22_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV22_LSB				8
+#define CSR_ACSMADRADV22_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV22_LSB				10
+#define CSR_ACSMBNKADV22_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD22_LSB			12
+#define CSR_ACSMADRSELLOAD22_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD22_LSB			14
+#define CSR_ACSMBNKSELLOAD22_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE22_LSB			15
+#define CSR_ACSMLONGBUBBLE22_MASK			BIT(15)
+/* CSR_ACSMSEQ3X23 */
+#define CSR_ACSMSEQ3X23_LSB				0
+#define CSR_ACSMSEQ3X23_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT23_LSB				0
+#define CSR_ACSMCMDREPCNT23_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV23_LSB				8
+#define CSR_ACSMADRADV23_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV23_LSB				10
+#define CSR_ACSMBNKADV23_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD23_LSB			12
+#define CSR_ACSMADRSELLOAD23_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD23_LSB			14
+#define CSR_ACSMBNKSELLOAD23_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE23_LSB			15
+#define CSR_ACSMLONGBUBBLE23_MASK			BIT(15)
+/* CSR_ACSMSEQ3X24 */
+#define CSR_ACSMSEQ3X24_LSB				0
+#define CSR_ACSMSEQ3X24_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT24_LSB				0
+#define CSR_ACSMCMDREPCNT24_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV24_LSB				8
+#define CSR_ACSMADRADV24_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV24_LSB				10
+#define CSR_ACSMBNKADV24_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD24_LSB			12
+#define CSR_ACSMADRSELLOAD24_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD24_LSB			14
+#define CSR_ACSMBNKSELLOAD24_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE24_LSB			15
+#define CSR_ACSMLONGBUBBLE24_MASK			BIT(15)
+/* CSR_ACSMSEQ3X25 */
+#define CSR_ACSMSEQ3X25_LSB				0
+#define CSR_ACSMSEQ3X25_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT25_LSB				0
+#define CSR_ACSMCMDREPCNT25_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV25_LSB				8
+#define CSR_ACSMADRADV25_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV25_LSB				10
+#define CSR_ACSMBNKADV25_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD25_LSB			12
+#define CSR_ACSMADRSELLOAD25_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD25_LSB			14
+#define CSR_ACSMBNKSELLOAD25_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE25_LSB			15
+#define CSR_ACSMLONGBUBBLE25_MASK			BIT(15)
+/* CSR_ACSMSEQ3X26 */
+#define CSR_ACSMSEQ3X26_LSB				0
+#define CSR_ACSMSEQ3X26_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT26_LSB				0
+#define CSR_ACSMCMDREPCNT26_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV26_LSB				8
+#define CSR_ACSMADRADV26_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV26_LSB				10
+#define CSR_ACSMBNKADV26_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD26_LSB			12
+#define CSR_ACSMADRSELLOAD26_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD26_LSB			14
+#define CSR_ACSMBNKSELLOAD26_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE26_LSB			15
+#define CSR_ACSMLONGBUBBLE26_MASK			BIT(15)
+/* CSR_ACSMSEQ3X27 */
+#define CSR_ACSMSEQ3X27_LSB				0
+#define CSR_ACSMSEQ3X27_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT27_LSB				0
+#define CSR_ACSMCMDREPCNT27_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV27_LSB				8
+#define CSR_ACSMADRADV27_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV27_LSB				10
+#define CSR_ACSMBNKADV27_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD27_LSB			12
+#define CSR_ACSMADRSELLOAD27_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD27_LSB			14
+#define CSR_ACSMBNKSELLOAD27_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE27_LSB			15
+#define CSR_ACSMLONGBUBBLE27_MASK			BIT(15)
+/* CSR_ACSMSEQ3X28 */
+#define CSR_ACSMSEQ3X28_LSB				0
+#define CSR_ACSMSEQ3X28_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT28_LSB				0
+#define CSR_ACSMCMDREPCNT28_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV28_LSB				8
+#define CSR_ACSMADRADV28_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV28_LSB				10
+#define CSR_ACSMBNKADV28_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD28_LSB			12
+#define CSR_ACSMADRSELLOAD28_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD28_LSB			14
+#define CSR_ACSMBNKSELLOAD28_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE28_LSB			15
+#define CSR_ACSMLONGBUBBLE28_MASK			BIT(15)
+/* CSR_ACSMSEQ3X29 */
+#define CSR_ACSMSEQ3X29_LSB				0
+#define CSR_ACSMSEQ3X29_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT29_LSB				0
+#define CSR_ACSMCMDREPCNT29_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV29_LSB				8
+#define CSR_ACSMADRADV29_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV29_LSB				10
+#define CSR_ACSMBNKADV29_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD29_LSB			12
+#define CSR_ACSMADRSELLOAD29_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD29_LSB			14
+#define CSR_ACSMBNKSELLOAD29_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE29_LSB			15
+#define CSR_ACSMLONGBUBBLE29_MASK			BIT(15)
+/* CSR_ACSMSEQ3X30 */
+#define CSR_ACSMSEQ3X30_LSB				0
+#define CSR_ACSMSEQ3X30_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT30_LSB				0
+#define CSR_ACSMCMDREPCNT30_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV30_LSB				8
+#define CSR_ACSMADRADV30_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV30_LSB				10
+#define CSR_ACSMBNKADV30_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD30_LSB			12
+#define CSR_ACSMADRSELLOAD30_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD30_LSB			14
+#define CSR_ACSMBNKSELLOAD30_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE30_LSB			15
+#define CSR_ACSMLONGBUBBLE30_MASK			BIT(15)
+/* CSR_ACSMSEQ3X31 */
+#define CSR_ACSMSEQ3X31_LSB				0
+#define CSR_ACSMSEQ3X31_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCMDREPCNT31_LSB				0
+#define CSR_ACSMCMDREPCNT31_MASK			GENMASK_32(7, 0)
+#define CSR_ACSMADRADV31_LSB				8
+#define CSR_ACSMADRADV31_MASK				GENMASK_32(9, 8)
+#define CSR_ACSMBNKADV31_LSB				10
+#define CSR_ACSMBNKADV31_MASK				GENMASK_32(11, 10)
+#define CSR_ACSMADRSELLOAD31_LSB			12
+#define CSR_ACSMADRSELLOAD31_MASK			GENMASK_32(13, 12)
+#define CSR_ACSMBNKSELLOAD31_LSB			14
+#define CSR_ACSMBNKSELLOAD31_MASK			BIT(14)
+#define CSR_ACSMLONGBUBBLE31_LSB			15
+#define CSR_ACSMLONGBUBBLE31_MASK			BIT(15)
+/* CSR_ACSMPLAYBACK0X0 */
+#define CSR_ACSMPLAYBACK0X0_LSB				0
+#define CSR_ACSMPLAYBACK0X0_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X0 */
+#define CSR_ACSMPLAYBACK1X0_LSB				0
+#define CSR_ACSMPLAYBACK1X0_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X1 */
+#define CSR_ACSMPLAYBACK0X1_LSB				0
+#define CSR_ACSMPLAYBACK0X1_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X1 */
+#define CSR_ACSMPLAYBACK1X1_LSB				0
+#define CSR_ACSMPLAYBACK1X1_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X2 */
+#define CSR_ACSMPLAYBACK0X2_LSB				0
+#define CSR_ACSMPLAYBACK0X2_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X2 */
+#define CSR_ACSMPLAYBACK1X2_LSB				0
+#define CSR_ACSMPLAYBACK1X2_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X3 */
+#define CSR_ACSMPLAYBACK0X3_LSB				0
+#define CSR_ACSMPLAYBACK0X3_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X3 */
+#define CSR_ACSMPLAYBACK1X3_LSB				0
+#define CSR_ACSMPLAYBACK1X3_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X4 */
+#define CSR_ACSMPLAYBACK0X4_LSB				0
+#define CSR_ACSMPLAYBACK0X4_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X4 */
+#define CSR_ACSMPLAYBACK1X4_LSB				0
+#define CSR_ACSMPLAYBACK1X4_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X5 */
+#define CSR_ACSMPLAYBACK0X5_LSB				0
+#define CSR_ACSMPLAYBACK0X5_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X5 */
+#define CSR_ACSMPLAYBACK1X5_LSB				0
+#define CSR_ACSMPLAYBACK1X5_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X6 */
+#define CSR_ACSMPLAYBACK0X6_LSB				0
+#define CSR_ACSMPLAYBACK0X6_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X6 */
+#define CSR_ACSMPLAYBACK1X6_LSB				0
+#define CSR_ACSMPLAYBACK1X6_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK0X7 */
+#define CSR_ACSMPLAYBACK0X7_LSB				0
+#define CSR_ACSMPLAYBACK0X7_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPLAYBACK1X7 */
+#define CSR_ACSMPLAYBACK1X7_LSB				0
+#define CSR_ACSMPLAYBACK1X7_MASK			GENMASK_32(11, 0)
+/* CSR_ACSMPSTATEOVREN */
+#define CSR_ACSMPSTATEOVREN_LSB				0
+#define CSR_ACSMPSTATEOVREN_MASK			BIT(0)
+/* CSR_ACSMPSTATEOVRVAL */
+#define CSR_ACSMPSTATEOVRVAL_LSB			0
+#define CSR_ACSMPSTATEOVRVAL_MASK			GENMASK_32(3, 0)
+/* CSR_ACSMCTRL23 */
+#define CSR_ACSMCTRL23_LSB				0
+#define CSR_ACSMCTRL23_MASK				GENMASK_32(12, 0)
+#define CSR_ACSMCSMASK_LSB				0
+#define CSR_ACSMCSMASK_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMCSMODE_LSB				8
+#define CSR_ACSMCSMODE_MASK				BIT(8)
+#define CSR_ACSMPARMASK_LSB				9
+#define CSR_ACSMPARMASK_MASK				GENMASK_32(12, 9)
+/* CSR_ACSMCKEVAL */
+#define CSR_ACSMCKEVAL_LSB				0
+#define CSR_ACSMCKEVAL_MASK				GENMASK_32(3, 0)
+/* CSR_LOWSPEEDCLOCKDIVIDER */
+#define CSR_LOWSPEEDCLOCKDIVIDER_LSB			0
+#define CSR_LOWSPEEDCLOCKDIVIDER_MASK			GENMASK_32(5, 0)
+/* CSR_ACSMCSMAPCTRL0 */
+#define CSR_ACSMCSMAPCTRL0_LSB				0
+#define CSR_ACSMCSMAPCTRL0_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP0_LSB				0
+#define CSR_ACSMCSMAP0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP0_LSB				8
+#define CSR_ACSMDESTMAP0_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP0_LSB				12
+#define CSR_ACSMODTMAP0_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL1 */
+#define CSR_ACSMCSMAPCTRL1_LSB				0
+#define CSR_ACSMCSMAPCTRL1_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP1_LSB				0
+#define CSR_ACSMCSMAP1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP1_LSB				8
+#define CSR_ACSMDESTMAP1_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP1_LSB				12
+#define CSR_ACSMODTMAP1_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL2 */
+#define CSR_ACSMCSMAPCTRL2_LSB				0
+#define CSR_ACSMCSMAPCTRL2_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP2_LSB				0
+#define CSR_ACSMCSMAP2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP2_LSB				8
+#define CSR_ACSMDESTMAP2_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP2_LSB				12
+#define CSR_ACSMODTMAP2_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL3 */
+#define CSR_ACSMCSMAPCTRL3_LSB				0
+#define CSR_ACSMCSMAPCTRL3_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP3_LSB				0
+#define CSR_ACSMCSMAP3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP3_LSB				8
+#define CSR_ACSMDESTMAP3_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP3_LSB				12
+#define CSR_ACSMODTMAP3_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL4 */
+#define CSR_ACSMCSMAPCTRL4_LSB				0
+#define CSR_ACSMCSMAPCTRL4_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP4_LSB				0
+#define CSR_ACSMCSMAP4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP4_LSB				8
+#define CSR_ACSMDESTMAP4_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP4_LSB				12
+#define CSR_ACSMODTMAP4_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL5 */
+#define CSR_ACSMCSMAPCTRL5_LSB				0
+#define CSR_ACSMCSMAPCTRL5_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP5_LSB				0
+#define CSR_ACSMCSMAP5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP5_LSB				8
+#define CSR_ACSMDESTMAP5_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP5_LSB				12
+#define CSR_ACSMODTMAP5_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL6 */
+#define CSR_ACSMCSMAPCTRL6_LSB				0
+#define CSR_ACSMCSMAPCTRL6_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP6_LSB				0
+#define CSR_ACSMCSMAP6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP6_LSB				8
+#define CSR_ACSMDESTMAP6_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP6_LSB				12
+#define CSR_ACSMODTMAP6_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL7 */
+#define CSR_ACSMCSMAPCTRL7_LSB				0
+#define CSR_ACSMCSMAPCTRL7_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP7_LSB				0
+#define CSR_ACSMCSMAP7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP7_LSB				8
+#define CSR_ACSMDESTMAP7_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP7_LSB				12
+#define CSR_ACSMODTMAP7_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL8 */
+#define CSR_ACSMCSMAPCTRL8_LSB				0
+#define CSR_ACSMCSMAPCTRL8_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP8_LSB				0
+#define CSR_ACSMCSMAP8_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP8_LSB				8
+#define CSR_ACSMDESTMAP8_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP8_LSB				12
+#define CSR_ACSMODTMAP8_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL9 */
+#define CSR_ACSMCSMAPCTRL9_LSB				0
+#define CSR_ACSMCSMAPCTRL9_MASK				GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP9_LSB				0
+#define CSR_ACSMCSMAP9_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP9_LSB				8
+#define CSR_ACSMDESTMAP9_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP9_LSB				12
+#define CSR_ACSMODTMAP9_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL10 */
+#define CSR_ACSMCSMAPCTRL10_LSB				0
+#define CSR_ACSMCSMAPCTRL10_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP10_LSB				0
+#define CSR_ACSMCSMAP10_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP10_LSB				8
+#define CSR_ACSMDESTMAP10_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP10_LSB				12
+#define CSR_ACSMODTMAP10_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL11 */
+#define CSR_ACSMCSMAPCTRL11_LSB				0
+#define CSR_ACSMCSMAPCTRL11_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP11_LSB				0
+#define CSR_ACSMCSMAP11_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP11_LSB				8
+#define CSR_ACSMDESTMAP11_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP11_LSB				12
+#define CSR_ACSMODTMAP11_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL12 */
+#define CSR_ACSMCSMAPCTRL12_LSB				0
+#define CSR_ACSMCSMAPCTRL12_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP12_LSB				0
+#define CSR_ACSMCSMAP12_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP12_LSB				8
+#define CSR_ACSMDESTMAP12_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP12_LSB				12
+#define CSR_ACSMODTMAP12_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL13 */
+#define CSR_ACSMCSMAPCTRL13_LSB				0
+#define CSR_ACSMCSMAPCTRL13_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP13_LSB				0
+#define CSR_ACSMCSMAP13_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP13_LSB				8
+#define CSR_ACSMDESTMAP13_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP13_LSB				12
+#define CSR_ACSMODTMAP13_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL14 */
+#define CSR_ACSMCSMAPCTRL14_LSB				0
+#define CSR_ACSMCSMAPCTRL14_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP14_LSB				0
+#define CSR_ACSMCSMAP14_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP14_LSB				8
+#define CSR_ACSMDESTMAP14_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP14_LSB				12
+#define CSR_ACSMODTMAP14_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMCSMAPCTRL15 */
+#define CSR_ACSMCSMAPCTRL15_LSB				0
+#define CSR_ACSMCSMAPCTRL15_MASK			GENMASK_32(14, 0)
+#define CSR_ACSMCSMAP15_LSB				0
+#define CSR_ACSMCSMAP15_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMDESTMAP15_LSB				8
+#define CSR_ACSMDESTMAP15_MASK				GENMASK_32(11, 8)
+#define CSR_ACSMODTMAP15_LSB				12
+#define CSR_ACSMODTMAP15_MASK				GENMASK_32(14, 12)
+/* CSR_ACSMODTCTRL0 */
+#define CSR_ACSMODTCTRL0_LSB				0
+#define CSR_ACSMODTCTRL0_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS0_LSB				0
+#define CSR_ACSMODTWRPATCS0_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS0_LSB				4
+#define CSR_ACSMODTRDPATCS0_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL1 */
+#define CSR_ACSMODTCTRL1_LSB				0
+#define CSR_ACSMODTCTRL1_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS1_LSB				0
+#define CSR_ACSMODTWRPATCS1_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS1_LSB				4
+#define CSR_ACSMODTRDPATCS1_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL2 */
+#define CSR_ACSMODTCTRL2_LSB				0
+#define CSR_ACSMODTCTRL2_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS2_LSB				0
+#define CSR_ACSMODTWRPATCS2_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS2_LSB				4
+#define CSR_ACSMODTRDPATCS2_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL3 */
+#define CSR_ACSMODTCTRL3_LSB				0
+#define CSR_ACSMODTCTRL3_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS3_LSB				0
+#define CSR_ACSMODTWRPATCS3_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS3_LSB				4
+#define CSR_ACSMODTRDPATCS3_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL4 */
+#define CSR_ACSMODTCTRL4_LSB				0
+#define CSR_ACSMODTCTRL4_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS4_LSB				0
+#define CSR_ACSMODTWRPATCS4_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS4_LSB				4
+#define CSR_ACSMODTRDPATCS4_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL5 */
+#define CSR_ACSMODTCTRL5_LSB				0
+#define CSR_ACSMODTCTRL5_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS5_LSB				0
+#define CSR_ACSMODTWRPATCS5_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS5_LSB				4
+#define CSR_ACSMODTRDPATCS5_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL6 */
+#define CSR_ACSMODTCTRL6_LSB				0
+#define CSR_ACSMODTCTRL6_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS6_LSB				0
+#define CSR_ACSMODTWRPATCS6_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS6_LSB				4
+#define CSR_ACSMODTRDPATCS6_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL7 */
+#define CSR_ACSMODTCTRL7_LSB				0
+#define CSR_ACSMODTCTRL7_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMODTWRPATCS7_LSB				0
+#define CSR_ACSMODTWRPATCS7_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDPATCS7_LSB				4
+#define CSR_ACSMODTRDPATCS7_MASK			GENMASK_32(7, 4)
+/* CSR_ACSMODTCTRL8 */
+#define CSR_ACSMODTCTRL8_LSB				0
+#define CSR_ACSMODTCTRL8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMODTWRDURCTRL_LSB			0
+#define CSR_ACSMODTWRDURCTRL_MASK			GENMASK_32(3, 0)
+#define CSR_ACSMODTRDDURCTRL_LSB			4
+#define CSR_ACSMODTRDDURCTRL_MASK			GENMASK_32(7, 4)
+#define CSR_ACSMODTWRSTRTCTRL_LSB			8
+#define CSR_ACSMODTWRSTRTCTRL_MASK			GENMASK_32(11, 8)
+#define CSR_ACSMODTRDSTRTCTRL_LSB			12
+#define CSR_ACSMODTRDSTRTCTRL_MASK			GENMASK_32(15, 12)
+/* CSR_ACSMCTRL16 */
+#define CSR_ACSMCTRL16_LSB				0
+#define CSR_ACSMCTRL16_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMDDRADRUP_LSB				0
+#define CSR_ACSMDDRADRUP_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMHIGHADDR_LSB				4
+#define CSR_ACSMHIGHADDR_MASK				BIT(4)
+#define CSR_ACSMADR13PLUGHOLE_LSB			5
+#define CSR_ACSMADR13PLUGHOLE_MASK			BIT(5)
+#define CSR_ACSMCTRL16RSVD_LSB				6
+#define CSR_ACSMCTRL16RSVD_MASK				BIT(6)
+#define CSR_ACSMWRTLVLODTCTRL_LSB			7
+#define CSR_ACSMWRTLVLODTCTRL_MASK			BIT(7)
+#define CSR_ACSMWRTLVLODT_LSB				8
+#define CSR_ACSMWRTLVLODT_MASK				GENMASK_32(11, 8)
+#define CSR_ACSM2TGRPINHIBIT_LSB			12
+#define CSR_ACSM2TGRPINHIBIT_MASK			GENMASK_32(15, 12)
+/* CSR_LOWSPEEDCLOCKSTOPVAL */
+#define CSR_LOWSPEEDCLOCKSTOPVAL_LSB			0
+#define CSR_LOWSPEEDCLOCKSTOPVAL_MASK			BIT(0)
+/* CSR_ACSMCTRL18 */
+#define CSR_ACSMCTRL18_LSB				0
+#define CSR_ACSMCTRL18_MASK				GENMASK_32(1, 0)
+#define CSR_ACSMLOCALDONE_LSB				0
+#define CSR_ACSMLOCALDONE_MASK				BIT(0)
+#define CSR_ACSMSTOPONERRASRTD_LSB			1
+#define CSR_ACSMSTOPONERRASRTD_MASK			BIT(1)
+/* CSR_ACSMCTRL19 */
+#define CSR_ACSMCTRL19_LSB				0
+#define CSR_ACSMCTRL19_MASK				GENMASK_32(2, 0)
+#define CSR_ACSMVISSEL_LSB				0
+#define CSR_ACSMVISSEL_MASK				GENMASK_32(2, 0)
+/* CSR_ACSMCTRL20 */
+#define CSR_ACSMCTRL20_LSB				0
+#define CSR_ACSMCTRL20_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMVISVAL_LSB				0
+#define CSR_ACSMVISVAL_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL21 */
+#define CSR_ACSMCTRL21_LSB				0
+#define CSR_ACSMCTRL21_MASK				GENMASK_32(11, 0)
+#define CSR_ACSMMAPDIMMCS0_LSB				0
+#define CSR_ACSMMAPDIMMCS0_MASK				GENMASK_32(2, 0)
+#define CSR_ACSMMAPDIMMCS1_LSB				3
+#define CSR_ACSMMAPDIMMCS1_MASK				GENMASK_32(5, 3)
+#define CSR_ACSMMAPDIMMCS2_LSB				6
+#define CSR_ACSMMAPDIMMCS2_MASK				GENMASK_32(8, 6)
+#define CSR_ACSMMAPDIMMCS3_LSB				9
+#define CSR_ACSMMAPDIMMCS3_MASK				GENMASK_32(11, 9)
+/* CSR_ACSMCTRL22 */
+#define CSR_ACSMCTRL22_LSB				0
+#define CSR_ACSMCTRL22_MASK				GENMASK_32(11, 0)
+#define CSR_ACSMMAPDIMMCS4_LSB				0
+#define CSR_ACSMMAPDIMMCS4_MASK				GENMASK_32(2, 0)
+#define CSR_ACSMMAPDIMMCS5_LSB				3
+#define CSR_ACSMMAPDIMMCS5_MASK				GENMASK_32(5, 3)
+#define CSR_ACSMMAPDIMMCS6_LSB				6
+#define CSR_ACSMMAPDIMMCS6_MASK				GENMASK_32(8, 6)
+#define CSR_ACSMMAPDIMMCS7_LSB				9
+#define CSR_ACSMMAPDIMMCS7_MASK				GENMASK_32(11, 9)
+/* CSR_ACSMCTRL0 */
+#define CSR_ACSMCTRL0_LSB				0
+#define CSR_ACSMCTRL0_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRSVDCTRL00_LSB				0
+#define CSR_ACSMRSVDCTRL00_MASK				BIT(0)
+#define CSR_ACSMDYNBLMODE_LSB				1
+#define CSR_ACSMDYNBLMODE_MASK				BIT(1)
+#define CSR_ACSMBURSTLEN_LSB				2
+#define CSR_ACSMBURSTLEN_MASK				BIT(2)
+#define CSR_ACSMINFLOOP_LSB				3
+#define CSR_ACSMINFLOOP_MASK				BIT(3)
+#define CSR_ACSMRXVALMODE_LSB				4
+#define CSR_ACSMRXVALMODE_MASK				BIT(4)
+#define CSR_ACSMSTPONERRMODE_LSB			5
+#define CSR_ACSMSTPONERRMODE_MASK			BIT(5)
+#define CSR_ACSM2TMODE_LSB				6
+#define CSR_ACSM2TMODE_MASK				BIT(6)
+#define CSR_ACSMTRAINSOEMODE_LSB			7
+#define CSR_ACSMTRAINSOEMODE_MASK			BIT(7)
+#define CSR_ACSMGATEDDRCMD_LSB				8
+#define CSR_ACSMGATEDDRCMD_MASK				BIT(8)
+#define CSR_ACSMGEARDOWNMODE_LSB			9
+#define CSR_ACSMGEARDOWNMODE_MASK			BIT(9)
+#define CSR_ACSMGEARDOWNPHASE_LSB			10
+#define CSR_ACSMGEARDOWNPHASE_MASK			BIT(10)
+#define CSR_ACSMGEARDOWNSYNC_LSB			11
+#define CSR_ACSMGEARDOWNSYNC_MASK			BIT(11)
+#define CSR_ACSMCAPRBSMODE_LSB				12
+#define CSR_ACSMCAPRBSMODE_MASK				BIT(12)
+#define CSR_ACSMGATERXFIFOWRITE_LSB			13
+#define CSR_ACSMGATERXFIFOWRITE_MASK			BIT(13)
+#define CSR_ACSMPARMODE_LSB				14
+#define CSR_ACSMPARMODE_MASK				BIT(14)
+#define CSR_ACSMTDSMODE_LSB				15
+#define CSR_ACSMTDSMODE_MASK				BIT(15)
+/* CSR_ACSMCTRL1 */
+#define CSR_ACSMCTRL1_LSB				0
+#define CSR_ACSMCTRL1_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMREPCNT_LSB				0
+#define CSR_ACSMREPCNT_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL2 */
+#define CSR_ACSMCTRL2_LSB				0
+#define CSR_ACSMCTRL2_MASK				GENMASK_32(4, 0)
+#define CSR_ACSMSTARTPTR_LSB				0
+#define CSR_ACSMSTARTPTR_MASK				GENMASK_32(4, 0)
+/* CSR_ACSMCTRL3 */
+#define CSR_ACSMCTRL3_LSB				0
+#define CSR_ACSMCTRL3_MASK				GENMASK_32(4, 0)
+#define CSR_ACSMLOOPPTR_LSB				0
+#define CSR_ACSMLOOPPTR_MASK				GENMASK_32(4, 0)
+/* CSR_ACSMCTRL4 */
+#define CSR_ACSMCTRL4_LSB				0
+#define CSR_ACSMCTRL4_MASK				GENMASK_32(4, 0)
+#define CSR_ACSMENDPTR_LSB				0
+#define CSR_ACSMENDPTR_MASK				GENMASK_32(4, 0)
+/* CSR_ACSMCTRL5 */
+#define CSR_ACSMCTRL5_LSB				0
+#define CSR_ACSMCTRL5_MASK				GENMASK_32(13, 0)
+#define CSR_ACSMMXRDLAT_LSB				0
+#define CSR_ACSMMXRDLAT_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMRCASLAT_LSB				8
+#define CSR_ACSMRCASLAT_MASK				GENMASK_32(13, 8)
+/* CSR_ACSMCTRL6 */
+#define CSR_ACSMCTRL6_LSB				0
+#define CSR_ACSMCTRL6_MASK				GENMASK_32(10, 0)
+#define CSR_ACSMWCASLAT_LSB				0
+#define CSR_ACSMWCASLAT_MASK				GENMASK_32(5, 0)
+#define CSR_ACSMWRRSVD_LSB				6
+#define CSR_ACSMWRRSVD_MASK				GENMASK_32(7, 6)
+#define CSR_ACSMWRDATLAT_LSB				8
+#define CSR_ACSMWRDATLAT_MASK				GENMASK_32(10, 8)
+/* CSR_ACSMCTRL7 */
+#define CSR_ACSMCTRL7_LSB				0
+#define CSR_ACSMCTRL7_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRASPCFG_LSB				0
+#define CSR_ACSMRASPCFG_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL8 */
+#define CSR_ACSMCTRL8_LSB				0
+#define CSR_ACSMCTRL8_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRASPSEED_LSB				0
+#define CSR_ACSMRASPSEED_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL9 */
+#define CSR_ACSMCTRL9_LSB				0
+#define CSR_ACSMCTRL9_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCASPCFG_LSB				0
+#define CSR_ACSMCASPCFG_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL10 */
+#define CSR_ACSMCTRL10_LSB				0
+#define CSR_ACSMCTRL10_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMCASPSEED_LSB				0
+#define CSR_ACSMCASPSEED_MASK				GENMASK_32(15, 0)
+/* CSR_ACSMCTRL11 */
+#define CSR_ACSMCTRL11_LSB				0
+#define CSR_ACSMCTRL11_MASK				GENMASK_32(15, 0)
+#define CSR_ACSMRASADRINC_LSB				0
+#define CSR_ACSMRASADRINC_MASK				GENMASK_32(7, 0)
+#define CSR_ACSMCASADRINC_LSB				8
+#define CSR_ACSMCASADRINC_MASK				GENMASK_32(15, 8)
+/* CSR_ACSMCTRL12 */
+#define CSR_ACSMCTRL12_LSB				0
+#define CSR_ACSMCTRL12_MASK				GENMASK_32(11, 0)
+#define CSR_ACSMBNKPCFG_LSB				0
+#define CSR_ACSMBNKPCFG_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMBNKPSEED_LSB				4
+#define CSR_ACSMBNKPSEED_MASK				GENMASK_32(7, 4)
+#define CSR_ACSMBNKADRINC_LSB				8
+#define CSR_ACSMBNKADRINC_MASK				GENMASK_32(11, 8)
+/* CSR_ACSMCTRL13 */
+#define CSR_ACSMCTRL13_LSB				0
+#define CSR_ACSMCTRL13_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMCKEENB_LSB				0
+#define CSR_ACSMCKEENB_MASK				GENMASK_32(3, 0)
+/* CSR_ACSMCTRL14 */
+#define CSR_ACSMCTRL14_LSB				0
+#define CSR_ACSMCTRL14_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMRASPCFGUP_LSB				0
+#define CSR_ACSMRASPCFGUP_MASK				GENMASK_32(3, 0)
+/* CSR_ACSMCTRL15 */
+#define CSR_ACSMCTRL15_LSB				0
+#define CSR_ACSMCTRL15_MASK				GENMASK_32(3, 0)
+#define CSR_ACSMRASPSEEDUP_LSB				0
+#define CSR_ACSMRASPSEEDUP_MASK				GENMASK_32(3, 0)
+
+/* PPGC0 register offsets */
+/* CSR_PPGCCTRL1 */
+#define CSR_PPGCCTRL1_LSB				1
+#define CSR_PPGCCTRL1_MASK				GENMASK_32(4, 1)
+#define CSR_HWTTXDBIEN_LSB				1
+#define CSR_HWTTXDBIEN_MASK				BIT(1)
+#define CSR_HWTRXDBIEN_LSB				2
+#define CSR_HWTRXDBIEN_MASK				BIT(2)
+#define CSR_HWTTXDMDBIVAL_LSB				3
+#define CSR_HWTTXDMDBIVAL_MASK				BIT(3)
+#define CSR_HWTTXDMDBISEL_LSB				4
+#define CSR_HWTTXDMDBISEL_MASK				BIT(4)
+/* CSR_PPGCLANE2CRCINMAP0 */
+#define CSR_PPGCLANE2CRCINMAP0_LSB			0
+#define CSR_PPGCLANE2CRCINMAP0_MASK			GENMASK_32(11, 0)
+#define CSR_PPGCCRCLANEMAP0_LSB				0
+#define CSR_PPGCCRCLANEMAP0_MASK			GENMASK_32(2, 0)
+#define CSR_PPGCCRCLANEMAP1_LSB				3
+#define CSR_PPGCCRCLANEMAP1_MASK			GENMASK_32(5, 3)
+#define CSR_PPGCCRCLANEMAP2_LSB				6
+#define CSR_PPGCCRCLANEMAP2_MASK			GENMASK_32(8, 6)
+#define CSR_PPGCCRCLANEMAP3_LSB				9
+#define CSR_PPGCCRCLANEMAP3_MASK			GENMASK_32(11, 9)
+/* CSR_PPGCLANE2CRCINMAP1 */
+#define CSR_PPGCLANE2CRCINMAP1_LSB			0
+#define CSR_PPGCLANE2CRCINMAP1_MASK			GENMASK_32(11, 0)
+#define CSR_PPGCCRCLANEMAP4_LSB				0
+#define CSR_PPGCCRCLANEMAP4_MASK			GENMASK_32(2, 0)
+#define CSR_PPGCCRCLANEMAP5_LSB				3
+#define CSR_PPGCCRCLANEMAP5_MASK			GENMASK_32(5, 3)
+#define CSR_PPGCCRCLANEMAP6_LSB				6
+#define CSR_PPGCCRCLANEMAP6_MASK			GENMASK_32(8, 6)
+#define CSR_PPGCCRCLANEMAP7_LSB				9
+#define CSR_PPGCCRCLANEMAP7_MASK			GENMASK_32(11, 9)
+/* CSR_PRBSTAPDLY0 */
+#define CSR_PRBSTAPDLY0_LSB				0
+#define CSR_PRBSTAPDLY0_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSTAPDLY1 */
+#define CSR_PRBSTAPDLY1_LSB				0
+#define CSR_PRBSTAPDLY1_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSTAPDLY2 */
+#define CSR_PRBSTAPDLY2_LSB				0
+#define CSR_PRBSTAPDLY2_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSTAPDLY3 */
+#define CSR_PRBSTAPDLY3_LSB				0
+#define CSR_PRBSTAPDLY3_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE0 */
+#define CSR_GENPRBSBYTE0_LSB				0
+#define CSR_GENPRBSBYTE0_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE1² */
+#define CSR_GENPRBSBYTE1_LSB				0
+#define CSR_GENPRBSBYTE1_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE2 */
+#define CSR_GENPRBSBYTE2_LSB				0
+#define CSR_GENPRBSBYTE2_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE3 */
+#define CSR_GENPRBSBYTE3_LSB				0
+#define CSR_GENPRBSBYTE3_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE4 */
+#define CSR_GENPRBSBYTE4_LSB				0
+#define CSR_GENPRBSBYTE4_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE5 */
+#define CSR_GENPRBSBYTE5_LSB				0
+#define CSR_GENPRBSBYTE5_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE6 */
+#define CSR_GENPRBSBYTE6_LSB				0
+#define CSR_GENPRBSBYTE6_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE7 */
+#define CSR_GENPRBSBYTE7_LSB				0
+#define CSR_GENPRBSBYTE7_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE8 */
+#define CSR_GENPRBSBYTE8_LSB				0
+#define CSR_GENPRBSBYTE8_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE9 */
+#define CSR_GENPRBSBYTE9_LSB				0
+#define CSR_GENPRBSBYTE9_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE10 */
+#define CSR_GENPRBSBYTE10_LSB				0
+#define CSR_GENPRBSBYTE10_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE11 */
+#define CSR_GENPRBSBYTE11_LSB				0
+#define CSR_GENPRBSBYTE11_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE12 */
+#define CSR_GENPRBSBYTE12_LSB				0
+#define CSR_GENPRBSBYTE12_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE13 */
+#define CSR_GENPRBSBYTE13_LSB				0
+#define CSR_GENPRBSBYTE13_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE14 */
+#define CSR_GENPRBSBYTE14_LSB				0
+#define CSR_GENPRBSBYTE14_MASK				GENMASK_32(15, 0)
+/* CSR_GENPRBSBYTE15 */
+#define CSR_GENPRBSBYTE15_LSB				0
+#define CSR_GENPRBSBYTE15_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSGENCTL */
+#define CSR_PRBSGENCTL_LSB				0
+#define CSR_PRBSGENCTL_MASK				GENMASK_32(6, 0)
+#define CSR_PPGCMODE_LSB				0
+#define CSR_PPGCMODE_MASK				BIT(0)
+#define CSR_PPGCDMMODE_LSB				1
+#define CSR_PPGCDMMODE_MASK				BIT(1)
+#define CSR_PPGCLDFFMODE_LSB				2
+#define CSR_PPGCLDFFMODE_MASK				BIT(2)
+#define CSR_PPGCSEL23BPRBS_LSB				3
+#define CSR_PPGCSEL23BPRBS_MASK				BIT(3)
+#define CSR_PPGCPATADV_LSB				4
+#define CSR_PPGCPATADV_MASK				GENMASK_32(5, 4)
+#define CSR_PPGCENBPATSTRESSMODE_LSB			6
+#define CSR_PPGCENBPATSTRESSMODE_MASK			BIT(6)
+/* CSR_PRBSGENSTATELO */
+#define CSR_PRBSGENSTATELO_LSB				0
+#define CSR_PRBSGENSTATELO_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSGENSTATEHI */
+#define CSR_PRBSGENSTATEHI_LSB				0
+#define CSR_PRBSGENSTATEHI_MASK				GENMASK_32(6, 0)
+/* CSR_PRBSCHKSTATELO */
+#define CSR_PRBSCHKSTATELO_LSB				0
+#define CSR_PRBSCHKSTATELO_MASK				GENMASK_32(15, 0)
+/* CSR_PRBSCHKSTATEHI */
+#define CSR_PRBSCHKSTATEHI_LSB				0
+#define CSR_PRBSCHKSTATEHI_MASK				GENMASK_32(6, 0)
+/* CSR_PRBSGENCTL1 */
+#define CSR_PRBSGENCTL1_LSB				0
+#define CSR_PRBSGENCTL1_MASK				GENMASK_32(8, 0)
+#define CSR_PPGCMODELANE_LSB				0
+#define CSR_PPGCMODELANE_MASK				GENMASK_32(8, 0)
+/* CSR_PRBSGENCTL2 */
+#define CSR_PRBSGENCTL2_LSB				0
+#define CSR_PRBSGENCTL2_MASK				GENMASK_32(15, 0)
+#define CSR_PPGCMSKPERIODLIM_LSB			0
+#define CSR_PPGCMSKPERIODLIM_MASK			GENMASK_32(15, 0)
+
+/* INITENG0 register offsets */
+/* CSR_PRESEQUENCEREG0B0S0 */
+#define CSR_PRESEQUENCEREG0B0S0_LSB			0
+#define CSR_PRESEQUENCEREG0B0S0_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B0S1 */
+#define CSR_PRESEQUENCEREG0B0S1_LSB			0
+#define CSR_PRESEQUENCEREG0B0S1_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B0S2 */
+#define CSR_PRESEQUENCEREG0B0S2_LSB			0
+#define CSR_PRESEQUENCEREG0B0S2_MASK			GENMASK_32(8, 0)
+/* CSR_PRESEQUENCEREG0B1S0 */
+#define CSR_PRESEQUENCEREG0B1S0_LSB			0
+#define CSR_PRESEQUENCEREG0B1S0_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B1S1 */
+#define CSR_PRESEQUENCEREG0B1S1_LSB			0
+#define CSR_PRESEQUENCEREG0B1S1_MASK			GENMASK_32(15, 0)
+/* CSR_PRESEQUENCEREG0B1S2 */
+#define CSR_PRESEQUENCEREG0B1S2_LSB			0
+#define CSR_PRESEQUENCEREG0B1S2_MASK			GENMASK_32(8, 0)
+/* CSR_POSTSEQUENCEREG0B0S0 */
+#define CSR_POSTSEQUENCEREG0B0S0_LSB			0
+#define CSR_POSTSEQUENCEREG0B0S0_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B0S1 */
+#define CSR_POSTSEQUENCEREG0B0S1_LSB			0
+#define CSR_POSTSEQUENCEREG0B0S1_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B0S2 */
+#define CSR_POSTSEQUENCEREG0B0S2_LSB			0
+#define CSR_POSTSEQUENCEREG0B0S2_MASK			GENMASK_32(8, 0)
+/* CSR_POSTSEQUENCEREG0B1S0 */
+#define CSR_POSTSEQUENCEREG0B1S0_LSB			0
+#define CSR_POSTSEQUENCEREG0B1S0_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B1S1 */
+#define CSR_POSTSEQUENCEREG0B1S1_LSB			0
+#define CSR_POSTSEQUENCEREG0B1S1_MASK			GENMASK_32(15, 0)
+/* CSR_POSTSEQUENCEREG0B1S2 */
+#define CSR_POSTSEQUENCEREG0B1S2_LSB			0
+#define CSR_POSTSEQUENCEREG0B1S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQ0BDISABLEFLAG0 */
+#define CSR_SEQ0BDISABLEFLAG0_LSB			0
+#define CSR_SEQ0BDISABLEFLAG0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG1 */
+#define CSR_SEQ0BDISABLEFLAG1_LSB			0
+#define CSR_SEQ0BDISABLEFLAG1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG2 */
+#define CSR_SEQ0BDISABLEFLAG2_LSB			0
+#define CSR_SEQ0BDISABLEFLAG2_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG3 */
+#define CSR_SEQ0BDISABLEFLAG3_LSB			0
+#define CSR_SEQ0BDISABLEFLAG3_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG4 */
+#define CSR_SEQ0BDISABLEFLAG4_LSB			0
+#define CSR_SEQ0BDISABLEFLAG4_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG5 */
+#define CSR_SEQ0BDISABLEFLAG5_LSB			0
+#define CSR_SEQ0BDISABLEFLAG5_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG6 */
+#define CSR_SEQ0BDISABLEFLAG6_LSB			0
+#define CSR_SEQ0BDISABLEFLAG6_MASK			GENMASK_32(15, 0)
+/* CSR_SEQ0BDISABLEFLAG7 */
+#define CSR_SEQ0BDISABLEFLAG7_LSB			0
+#define CSR_SEQ0BDISABLEFLAG7_MASK			GENMASK_32(15, 0)
+/* CSR_STARTVECTOR0B0 */
+#define CSR_STARTVECTOR0B0_LSB				0
+#define CSR_STARTVECTOR0B0_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC0_LSB				0
+#define CSR_SEQ0BSTARTVEC0_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B1 */
+#define CSR_STARTVECTOR0B1_LSB				0
+#define CSR_STARTVECTOR0B1_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC1_LSB				0
+#define CSR_SEQ0BSTARTVEC1_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B2 */
+#define CSR_STARTVECTOR0B2_LSB				0
+#define CSR_STARTVECTOR0B2_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC2_LSB				0
+#define CSR_SEQ0BSTARTVEC2_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B3 */
+#define CSR_STARTVECTOR0B3_LSB				0
+#define CSR_STARTVECTOR0B3_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC3_LSB				0
+#define CSR_SEQ0BSTARTVEC3_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B4 */
+#define CSR_STARTVECTOR0B4_LSB				0
+#define CSR_STARTVECTOR0B4_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC4_LSB				0
+#define CSR_SEQ0BSTARTVEC4_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B5 */
+#define CSR_STARTVECTOR0B5_LSB				0
+#define CSR_STARTVECTOR0B5_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC5_LSB				0
+#define CSR_SEQ0BSTARTVEC5_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B6 */
+#define CSR_STARTVECTOR0B6_LSB				0
+#define CSR_STARTVECTOR0B6_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC6_LSB				0
+#define CSR_SEQ0BSTARTVEC6_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B7 */
+#define CSR_STARTVECTOR0B7_LSB				0
+#define CSR_STARTVECTOR0B7_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC7_LSB				0
+#define CSR_SEQ0BSTARTVEC7_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B8 */
+#define CSR_STARTVECTOR0B8_LSB				0
+#define CSR_STARTVECTOR0B8_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC8_LSB				0
+#define CSR_SEQ0BSTARTVEC8_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B9 */
+#define CSR_STARTVECTOR0B9_LSB				0
+#define CSR_STARTVECTOR0B9_MASK				GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC9_LSB				0
+#define CSR_SEQ0BSTARTVEC9_MASK				GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B10 */
+#define CSR_STARTVECTOR0B10_LSB				0
+#define CSR_STARTVECTOR0B10_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC10_LSB				0
+#define CSR_SEQ0BSTARTVEC10_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B11 */
+#define CSR_STARTVECTOR0B11_LSB				0
+#define CSR_STARTVECTOR0B11_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC11_LSB				0
+#define CSR_SEQ0BSTARTVEC11_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B12 */
+#define CSR_STARTVECTOR0B12_LSB				0
+#define CSR_STARTVECTOR0B12_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC12_LSB				0
+#define CSR_SEQ0BSTARTVEC12_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B13 */
+#define CSR_STARTVECTOR0B13_LSB				0
+#define CSR_STARTVECTOR0B13_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC13_LSB				0
+#define CSR_SEQ0BSTARTVEC13_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B14 */
+#define CSR_STARTVECTOR0B14_LSB				0
+#define CSR_STARTVECTOR0B14_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC14_LSB				0
+#define CSR_SEQ0BSTARTVEC14_MASK			GENMASK_32(6, 0)
+/* CSR_STARTVECTOR0B15 */
+#define CSR_STARTVECTOR0B15_LSB				0
+#define CSR_STARTVECTOR0B15_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BSTARTVEC15_LSB				0
+#define CSR_SEQ0BSTARTVEC15_MASK			GENMASK_32(6, 0)
+/* CSR_SEQ0BWAITCONDSEL */
+#define CSR_SEQ0BWAITCONDSEL_LSB			0
+#define CSR_SEQ0BWAITCONDSEL_MASK			GENMASK_32(2, 0)
+/* CSR_PHYINLP3 */
+#define CSR_PHYINLP3_LSB				0
+#define CSR_PHYINLP3_MASK				BIT(0)
+/* CSR_SEQUENCEREG0B0S0 */
+#define CSR_SEQUENCEREG0B0S0_LSB			0
+#define CSR_SEQUENCEREG0B0S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B0S1 */
+#define CSR_SEQUENCEREG0B0S1_LSB			0
+#define CSR_SEQUENCEREG0B0S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B0S2 */
+#define CSR_SEQUENCEREG0B0S2_LSB			0
+#define CSR_SEQUENCEREG0B0S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B1S0 */
+#define CSR_SEQUENCEREG0B1S0_LSB			0
+#define CSR_SEQUENCEREG0B1S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B1S1 */
+#define CSR_SEQUENCEREG0B1S1_LSB			0
+#define CSR_SEQUENCEREG0B1S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B1S2 */
+#define CSR_SEQUENCEREG0B1S2_LSB			0
+#define CSR_SEQUENCEREG0B1S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B2S0 */
+#define CSR_SEQUENCEREG0B2S0_LSB			0
+#define CSR_SEQUENCEREG0B2S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B2S1 */
+#define CSR_SEQUENCEREG0B2S1_LSB			0
+#define CSR_SEQUENCEREG0B2S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B2S2 */
+#define CSR_SEQUENCEREG0B2S2_LSB			0
+#define CSR_SEQUENCEREG0B2S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B3S0 */
+#define CSR_SEQUENCEREG0B3S0_LSB			0
+#define CSR_SEQUENCEREG0B3S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B3S1 */
+#define CSR_SEQUENCEREG0B3S1_LSB			0
+#define CSR_SEQUENCEREG0B3S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B3S2 */
+#define CSR_SEQUENCEREG0B3S2_LSB			0
+#define CSR_SEQUENCEREG0B3S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B4S0 */
+#define CSR_SEQUENCEREG0B4S0_LSB			0
+#define CSR_SEQUENCEREG0B4S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B4S1 */
+#define CSR_SEQUENCEREG0B4S1_LSB			0
+#define CSR_SEQUENCEREG0B4S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B4S2 */
+#define CSR_SEQUENCEREG0B4S2_LSB			0
+#define CSR_SEQUENCEREG0B4S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B5S0 */
+#define CSR_SEQUENCEREG0B5S0_LSB			0
+#define CSR_SEQUENCEREG0B5S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B5S1 */
+#define CSR_SEQUENCEREG0B5S1_LSB			0
+#define CSR_SEQUENCEREG0B5S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B5S2 */
+#define CSR_SEQUENCEREG0B5S2_LSB			0
+#define CSR_SEQUENCEREG0B5S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B6S0 */
+#define CSR_SEQUENCEREG0B6S0_LSB			0
+#define CSR_SEQUENCEREG0B6S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B6S1 */
+#define CSR_SEQUENCEREG0B6S1_LSB			0
+#define CSR_SEQUENCEREG0B6S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B6S2 */
+#define CSR_SEQUENCEREG0B6S2_LSB			0
+#define CSR_SEQUENCEREG0B6S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B7S0 */
+#define CSR_SEQUENCEREG0B7S0_LSB			0
+#define CSR_SEQUENCEREG0B7S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B7S1 */
+#define CSR_SEQUENCEREG0B7S1_LSB			0
+#define CSR_SEQUENCEREG0B7S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B7S2 */
+#define CSR_SEQUENCEREG0B7S2_LSB			0
+#define CSR_SEQUENCEREG0B7S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B8S0 */
+#define CSR_SEQUENCEREG0B8S0_LSB			0
+#define CSR_SEQUENCEREG0B8S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B8S1 */
+#define CSR_SEQUENCEREG0B8S1_LSB			0
+#define CSR_SEQUENCEREG0B8S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B8S2 */
+#define CSR_SEQUENCEREG0B8S2_LSB			0
+#define CSR_SEQUENCEREG0B8S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B9S0 */
+#define CSR_SEQUENCEREG0B9S0_LSB			0
+#define CSR_SEQUENCEREG0B9S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B9S1 */
+#define CSR_SEQUENCEREG0B9S1_LSB			0
+#define CSR_SEQUENCEREG0B9S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B9S2 */
+#define CSR_SEQUENCEREG0B9S2_LSB			0
+#define CSR_SEQUENCEREG0B9S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B10S0 */
+#define CSR_SEQUENCEREG0B10S0_LSB			0
+#define CSR_SEQUENCEREG0B10S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B10S1 */
+#define CSR_SEQUENCEREG0B10S1_LSB			0
+#define CSR_SEQUENCEREG0B10S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B10S2 */
+#define CSR_SEQUENCEREG0B10S2_LSB			0
+#define CSR_SEQUENCEREG0B10S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B11S0 */
+#define CSR_SEQUENCEREG0B11S0_LSB			0
+#define CSR_SEQUENCEREG0B11S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B11S1 */
+#define CSR_SEQUENCEREG0B11S1_LSB			0
+#define CSR_SEQUENCEREG0B11S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B11S2 */
+#define CSR_SEQUENCEREG0B11S2_LSB			0
+#define CSR_SEQUENCEREG0B11S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B12S0 */
+#define CSR_SEQUENCEREG0B12S0_LSB			0
+#define CSR_SEQUENCEREG0B12S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B12S1 */
+#define CSR_SEQUENCEREG0B12S1_LSB			0
+#define CSR_SEQUENCEREG0B12S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B12S2 */
+#define CSR_SEQUENCEREG0B12S2_LSB			0
+#define CSR_SEQUENCEREG0B12S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B13S0 */
+#define CSR_SEQUENCEREG0B13S0_LSB			0
+#define CSR_SEQUENCEREG0B13S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B13S1 */
+#define CSR_SEQUENCEREG0B13S1_LSB			0
+#define CSR_SEQUENCEREG0B13S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B13S2 */
+#define CSR_SEQUENCEREG0B13S2_LSB			0
+#define CSR_SEQUENCEREG0B13S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B14S0 */
+#define CSR_SEQUENCEREG0B14S0_LSB			0
+#define CSR_SEQUENCEREG0B14S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B14S1 */
+#define CSR_SEQUENCEREG0B14S1_LSB			0
+#define CSR_SEQUENCEREG0B14S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B14S2 */
+#define CSR_SEQUENCEREG0B14S2_LSB			0
+#define CSR_SEQUENCEREG0B14S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B15S0 */
+#define CSR_SEQUENCEREG0B15S0_LSB			0
+#define CSR_SEQUENCEREG0B15S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B15S1 */
+#define CSR_SEQUENCEREG0B15S1_LSB			0
+#define CSR_SEQUENCEREG0B15S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B15S2 */
+#define CSR_SEQUENCEREG0B15S2_LSB			0
+#define CSR_SEQUENCEREG0B15S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B16S0 */
+#define CSR_SEQUENCEREG0B16S0_LSB			0
+#define CSR_SEQUENCEREG0B16S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B16S1 */
+#define CSR_SEQUENCEREG0B16S1_LSB			0
+#define CSR_SEQUENCEREG0B16S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B16S2 */
+#define CSR_SEQUENCEREG0B16S2_LSB			0
+#define CSR_SEQUENCEREG0B16S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B17S0 */
+#define CSR_SEQUENCEREG0B17S0_LSB			0
+#define CSR_SEQUENCEREG0B17S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B17S1 */
+#define CSR_SEQUENCEREG0B17S1_LSB			0
+#define CSR_SEQUENCEREG0B17S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B17S2 */
+#define CSR_SEQUENCEREG0B17S2_LSB			0
+#define CSR_SEQUENCEREG0B17S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B18S0 */
+#define CSR_SEQUENCEREG0B18S0_LSB			0
+#define CSR_SEQUENCEREG0B18S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B18S1 */
+#define CSR_SEQUENCEREG0B18S1_LSB			0
+#define CSR_SEQUENCEREG0B18S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B18S2 */
+#define CSR_SEQUENCEREG0B18S2_LSB			0
+#define CSR_SEQUENCEREG0B18S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B19S0 */
+#define CSR_SEQUENCEREG0B19S0_LSB			0
+#define CSR_SEQUENCEREG0B19S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B19S1 */
+#define CSR_SEQUENCEREG0B19S1_LSB			0
+#define CSR_SEQUENCEREG0B19S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B19S2 */
+#define CSR_SEQUENCEREG0B19S2_LSB			0
+#define CSR_SEQUENCEREG0B19S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B20S0 */
+#define CSR_SEQUENCEREG0B20S0_LSB			0
+#define CSR_SEQUENCEREG0B20S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B20S1 */
+#define CSR_SEQUENCEREG0B20S1_LSB			0
+#define CSR_SEQUENCEREG0B20S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B20S2 */
+#define CSR_SEQUENCEREG0B20S2_LSB			0
+#define CSR_SEQUENCEREG0B20S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B21S0 */
+#define CSR_SEQUENCEREG0B21S0_LSB			0
+#define CSR_SEQUENCEREG0B21S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B21S1 */
+#define CSR_SEQUENCEREG0B21S1_LSB			0
+#define CSR_SEQUENCEREG0B21S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B21S2 */
+#define CSR_SEQUENCEREG0B21S2_LSB			0
+#define CSR_SEQUENCEREG0B21S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B22S0 */
+#define CSR_SEQUENCEREG0B22S0_LSB			0
+#define CSR_SEQUENCEREG0B22S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B22S1 */
+#define CSR_SEQUENCEREG0B22S1_LSB			0
+#define CSR_SEQUENCEREG0B22S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B22S2 */
+#define CSR_SEQUENCEREG0B22S2_LSB			0
+#define CSR_SEQUENCEREG0B22S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B23S0 */
+#define CSR_SEQUENCEREG0B23S0_LSB			0
+#define CSR_SEQUENCEREG0B23S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B23S1 */
+#define CSR_SEQUENCEREG0B23S1_LSB			0
+#define CSR_SEQUENCEREG0B23S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B23S2 */
+#define CSR_SEQUENCEREG0B23S2_LSB			0
+#define CSR_SEQUENCEREG0B23S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B24S0 */
+#define CSR_SEQUENCEREG0B24S0_LSB			0
+#define CSR_SEQUENCEREG0B24S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B24S1 */
+#define CSR_SEQUENCEREG0B24S1_LSB			0
+#define CSR_SEQUENCEREG0B24S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B24S2 */
+#define CSR_SEQUENCEREG0B24S2_LSB			0
+#define CSR_SEQUENCEREG0B24S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B25S0 */
+#define CSR_SEQUENCEREG0B25S0_LSB			0
+#define CSR_SEQUENCEREG0B25S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B25S1 */
+#define CSR_SEQUENCEREG0B25S1_LSB			0
+#define CSR_SEQUENCEREG0B25S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B25S2 */
+#define CSR_SEQUENCEREG0B25S2_LSB			0
+#define CSR_SEQUENCEREG0B25S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B26S0 */
+#define CSR_SEQUENCEREG0B26S0_LSB			0
+#define CSR_SEQUENCEREG0B26S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B26S1 */
+#define CSR_SEQUENCEREG0B26S1_LSB			0
+#define CSR_SEQUENCEREG0B26S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B26S2 */
+#define CSR_SEQUENCEREG0B26S2_LSB			0
+#define CSR_SEQUENCEREG0B26S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B27S0 */
+#define CSR_SEQUENCEREG0B27S0_LSB			0
+#define CSR_SEQUENCEREG0B27S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B27S1 */
+#define CSR_SEQUENCEREG0B27S1_LSB			0
+#define CSR_SEQUENCEREG0B27S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B27S2 */
+#define CSR_SEQUENCEREG0B27S2_LSB			0
+#define CSR_SEQUENCEREG0B27S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B28S0 */
+#define CSR_SEQUENCEREG0B28S0_LSB			0
+#define CSR_SEQUENCEREG0B28S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B28S1 */
+#define CSR_SEQUENCEREG0B28S1_LSB			0
+#define CSR_SEQUENCEREG0B28S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B28S2 */
+#define CSR_SEQUENCEREG0B28S2_LSB			0
+#define CSR_SEQUENCEREG0B28S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B29S0 */
+#define CSR_SEQUENCEREG0B29S0_LSB			0
+#define CSR_SEQUENCEREG0B29S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B29S1 */
+#define CSR_SEQUENCEREG0B29S1_LSB			0
+#define CSR_SEQUENCEREG0B29S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B29S2 */
+#define CSR_SEQUENCEREG0B29S2_LSB			0
+#define CSR_SEQUENCEREG0B29S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B30S0 */
+#define CSR_SEQUENCEREG0B30S0_LSB			0
+#define CSR_SEQUENCEREG0B30S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B30S1 */
+#define CSR_SEQUENCEREG0B30S1_LSB			0
+#define CSR_SEQUENCEREG0B30S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B30S2 */
+#define CSR_SEQUENCEREG0B30S2_LSB			0
+#define CSR_SEQUENCEREG0B30S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B31S0 */
+#define CSR_SEQUENCEREG0B31S0_LSB			0
+#define CSR_SEQUENCEREG0B31S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B31S1 */
+#define CSR_SEQUENCEREG0B31S1_LSB			0
+#define CSR_SEQUENCEREG0B31S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B31S2 */
+#define CSR_SEQUENCEREG0B31S2_LSB			0
+#define CSR_SEQUENCEREG0B31S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B32S0 */
+#define CSR_SEQUENCEREG0B32S0_LSB			0
+#define CSR_SEQUENCEREG0B32S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B32S1 */
+#define CSR_SEQUENCEREG0B32S1_LSB			0
+#define CSR_SEQUENCEREG0B32S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B32S2 */
+#define CSR_SEQUENCEREG0B32S2_LSB			0
+#define CSR_SEQUENCEREG0B32S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B33S0 */
+#define CSR_SEQUENCEREG0B33S0_LSB			0
+#define CSR_SEQUENCEREG0B33S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B33S1 */
+#define CSR_SEQUENCEREG0B33S1_LSB			0
+#define CSR_SEQUENCEREG0B33S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B33S2 */
+#define CSR_SEQUENCEREG0B33S2_LSB			0
+#define CSR_SEQUENCEREG0B33S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B34S0 */
+#define CSR_SEQUENCEREG0B34S0_LSB			0
+#define CSR_SEQUENCEREG0B34S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B34S1 */
+#define CSR_SEQUENCEREG0B34S1_LSB			0
+#define CSR_SEQUENCEREG0B34S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B34S2 */
+#define CSR_SEQUENCEREG0B34S2_LSB			0
+#define CSR_SEQUENCEREG0B34S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B35S0 */
+#define CSR_SEQUENCEREG0B35S0_LSB			0
+#define CSR_SEQUENCEREG0B35S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B35S1 */
+#define CSR_SEQUENCEREG0B35S1_LSB			0
+#define CSR_SEQUENCEREG0B35S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B35S2 */
+#define CSR_SEQUENCEREG0B35S2_LSB			0
+#define CSR_SEQUENCEREG0B35S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B36S0 */
+#define CSR_SEQUENCEREG0B36S0_LSB			0
+#define CSR_SEQUENCEREG0B36S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B36S1 */
+#define CSR_SEQUENCEREG0B36S1_LSB			0
+#define CSR_SEQUENCEREG0B36S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B36S2 */
+#define CSR_SEQUENCEREG0B36S2_LSB			0
+#define CSR_SEQUENCEREG0B36S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B37S0 */
+#define CSR_SEQUENCEREG0B37S0_LSB			0
+#define CSR_SEQUENCEREG0B37S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B37S1 */
+#define CSR_SEQUENCEREG0B37S1_LSB			0
+#define CSR_SEQUENCEREG0B37S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B37S2 */
+#define CSR_SEQUENCEREG0B37S2_LSB			0
+#define CSR_SEQUENCEREG0B37S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B38S0 */
+#define CSR_SEQUENCEREG0B38S0_LSB			0
+#define CSR_SEQUENCEREG0B38S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B38S1 */
+#define CSR_SEQUENCEREG0B38S1_LSB			0
+#define CSR_SEQUENCEREG0B38S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B38S2 */
+#define CSR_SEQUENCEREG0B38S2_LSB			0
+#define CSR_SEQUENCEREG0B38S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B39S0 */
+#define CSR_SEQUENCEREG0B39S0_LSB			0
+#define CSR_SEQUENCEREG0B39S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B39S1 */
+#define CSR_SEQUENCEREG0B39S1_LSB			0
+#define CSR_SEQUENCEREG0B39S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B39S2 */
+#define CSR_SEQUENCEREG0B39S2_LSB			0
+#define CSR_SEQUENCEREG0B39S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B40S0 */
+#define CSR_SEQUENCEREG0B40S0_LSB			0
+#define CSR_SEQUENCEREG0B40S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B40S1 */
+#define CSR_SEQUENCEREG0B40S1_LSB			0
+#define CSR_SEQUENCEREG0B40S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B40S2 */
+#define CSR_SEQUENCEREG0B40S2_LSB			0
+#define CSR_SEQUENCEREG0B40S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B41S0 */
+#define CSR_SEQUENCEREG0B41S0_LSB			0
+#define CSR_SEQUENCEREG0B41S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B41S1 */
+#define CSR_SEQUENCEREG0B41S1_LSB			0
+#define CSR_SEQUENCEREG0B41S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B41S2 */
+#define CSR_SEQUENCEREG0B41S2_LSB			0
+#define CSR_SEQUENCEREG0B41S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B42S0 */
+#define CSR_SEQUENCEREG0B42S0_LSB			0
+#define CSR_SEQUENCEREG0B42S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B42S1 */
+#define CSR_SEQUENCEREG0B42S1_LSB			0
+#define CSR_SEQUENCEREG0B42S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B42S2 */
+#define CSR_SEQUENCEREG0B42S2_LSB			0
+#define CSR_SEQUENCEREG0B42S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B43S0 */
+#define CSR_SEQUENCEREG0B43S0_LSB			0
+#define CSR_SEQUENCEREG0B43S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B43S1 */
+#define CSR_SEQUENCEREG0B43S1_LSB			0
+#define CSR_SEQUENCEREG0B43S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B43S2 */
+#define CSR_SEQUENCEREG0B43S2_LSB			0
+#define CSR_SEQUENCEREG0B43S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B44S0 */
+#define CSR_SEQUENCEREG0B44S0_LSB			0
+#define CSR_SEQUENCEREG0B44S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B44S1 */
+#define CSR_SEQUENCEREG0B44S1_LSB			0
+#define CSR_SEQUENCEREG0B44S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B44S2 */
+#define CSR_SEQUENCEREG0B44S2_LSB			0
+#define CSR_SEQUENCEREG0B44S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B45S0 */
+#define CSR_SEQUENCEREG0B45S0_LSB			0
+#define CSR_SEQUENCEREG0B45S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B45S1 */
+#define CSR_SEQUENCEREG0B45S1_LSB			0
+#define CSR_SEQUENCEREG0B45S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B45S2 */
+#define CSR_SEQUENCEREG0B45S2_LSB			0
+#define CSR_SEQUENCEREG0B45S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B46S0 */
+#define CSR_SEQUENCEREG0B46S0_LSB			0
+#define CSR_SEQUENCEREG0B46S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B46S1 */
+#define CSR_SEQUENCEREG0B46S1_LSB			0
+#define CSR_SEQUENCEREG0B46S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B46S2 */
+#define CSR_SEQUENCEREG0B46S2_LSB			0
+#define CSR_SEQUENCEREG0B46S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B47S0 */
+#define CSR_SEQUENCEREG0B47S0_LSB			0
+#define CSR_SEQUENCEREG0B47S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B47S1 */
+#define CSR_SEQUENCEREG0B47S1_LSB			0
+#define CSR_SEQUENCEREG0B47S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B47S2 */
+#define CSR_SEQUENCEREG0B47S2_LSB			0
+#define CSR_SEQUENCEREG0B47S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B48S0 */
+#define CSR_SEQUENCEREG0B48S0_LSB			0
+#define CSR_SEQUENCEREG0B48S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B48S1 */
+#define CSR_SEQUENCEREG0B48S1_LSB			0
+#define CSR_SEQUENCEREG0B48S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B48S2 */
+#define CSR_SEQUENCEREG0B48S2_LSB			0
+#define CSR_SEQUENCEREG0B48S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B49S0 */
+#define CSR_SEQUENCEREG0B49S0_LSB			0
+#define CSR_SEQUENCEREG0B49S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B49S1 */
+#define CSR_SEQUENCEREG0B49S1_LSB			0
+#define CSR_SEQUENCEREG0B49S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B49S2 */
+#define CSR_SEQUENCEREG0B49S2_LSB			0
+#define CSR_SEQUENCEREG0B49S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B50S0 */
+#define CSR_SEQUENCEREG0B50S0_LSB			0
+#define CSR_SEQUENCEREG0B50S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B50S1 */
+#define CSR_SEQUENCEREG0B50S1_LSB			0
+#define CSR_SEQUENCEREG0B50S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B50S2 */
+#define CSR_SEQUENCEREG0B50S2_LSB			0
+#define CSR_SEQUENCEREG0B50S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B51S0 */
+#define CSR_SEQUENCEREG0B51S0_LSB			0
+#define CSR_SEQUENCEREG0B51S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B51S1 */
+#define CSR_SEQUENCEREG0B51S1_LSB			0
+#define CSR_SEQUENCEREG0B51S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B51S2 */
+#define CSR_SEQUENCEREG0B51S2_LSB			0
+#define CSR_SEQUENCEREG0B51S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B52S0 */
+#define CSR_SEQUENCEREG0B52S0_LSB			0
+#define CSR_SEQUENCEREG0B52S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B52S1 */
+#define CSR_SEQUENCEREG0B52S1_LSB			0
+#define CSR_SEQUENCEREG0B52S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B52S2 */
+#define CSR_SEQUENCEREG0B52S2_LSB			0
+#define CSR_SEQUENCEREG0B52S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B53S0 */
+#define CSR_SEQUENCEREG0B53S0_LSB			0
+#define CSR_SEQUENCEREG0B53S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B53S1 */
+#define CSR_SEQUENCEREG0B53S1_LSB			0
+#define CSR_SEQUENCEREG0B53S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B53S2 */
+#define CSR_SEQUENCEREG0B53S2_LSB			0
+#define CSR_SEQUENCEREG0B53S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B54S0 */
+#define CSR_SEQUENCEREG0B54S0_LSB			0
+#define CSR_SEQUENCEREG0B54S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B54S1 */
+#define CSR_SEQUENCEREG0B54S1_LSB			0
+#define CSR_SEQUENCEREG0B54S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B54S2 */
+#define CSR_SEQUENCEREG0B54S2_LSB			0
+#define CSR_SEQUENCEREG0B54S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B55S0 */
+#define CSR_SEQUENCEREG0B55S0_LSB			0
+#define CSR_SEQUENCEREG0B55S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B55S1 */
+#define CSR_SEQUENCEREG0B55S1_LSB			0
+#define CSR_SEQUENCEREG0B55S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B55S2 */
+#define CSR_SEQUENCEREG0B55S2_LSB			0
+#define CSR_SEQUENCEREG0B55S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B56S0 */
+#define CSR_SEQUENCEREG0B56S0_LSB			0
+#define CSR_SEQUENCEREG0B56S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B56S1 */
+#define CSR_SEQUENCEREG0B56S1_LSB			0
+#define CSR_SEQUENCEREG0B56S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B56S2 */
+#define CSR_SEQUENCEREG0B56S2_LSB			0
+#define CSR_SEQUENCEREG0B56S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B57S0 */
+#define CSR_SEQUENCEREG0B57S0_LSB			0
+#define CSR_SEQUENCEREG0B57S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B57S1 */
+#define CSR_SEQUENCEREG0B57S1_LSB			0
+#define CSR_SEQUENCEREG0B57S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B57S2 */
+#define CSR_SEQUENCEREG0B57S2_LSB			0
+#define CSR_SEQUENCEREG0B57S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B58S0 */
+#define CSR_SEQUENCEREG0B58S0_LSB			0
+#define CSR_SEQUENCEREG0B58S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B58S1 */
+#define CSR_SEQUENCEREG0B58S1_LSB			0
+#define CSR_SEQUENCEREG0B58S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B58S2 */
+#define CSR_SEQUENCEREG0B58S2_LSB			0
+#define CSR_SEQUENCEREG0B58S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B59S0 */
+#define CSR_SEQUENCEREG0B59S0_LSB			0
+#define CSR_SEQUENCEREG0B59S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B59S1 */
+#define CSR_SEQUENCEREG0B59S1_LSB			0
+#define CSR_SEQUENCEREG0B59S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B59S2 */
+#define CSR_SEQUENCEREG0B59S2_LSB			0
+#define CSR_SEQUENCEREG0B59S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B60S0 */
+#define CSR_SEQUENCEREG0B60S0_LSB			0
+#define CSR_SEQUENCEREG0B60S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B60S1 */
+#define CSR_SEQUENCEREG0B60S1_LSB			0
+#define CSR_SEQUENCEREG0B60S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B60S2 */
+#define CSR_SEQUENCEREG0B60S2_LSB			0
+#define CSR_SEQUENCEREG0B60S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B61S0 */
+#define CSR_SEQUENCEREG0B61S0_LSB			0
+#define CSR_SEQUENCEREG0B61S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B61S1 */
+#define CSR_SEQUENCEREG0B61S1_LSB			0
+#define CSR_SEQUENCEREG0B61S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B61S2 */
+#define CSR_SEQUENCEREG0B61S2_LSB			0
+#define CSR_SEQUENCEREG0B61S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B62S0 */
+#define CSR_SEQUENCEREG0B62S0_LSB			0
+#define CSR_SEQUENCEREG0B62S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B62S1 */
+#define CSR_SEQUENCEREG0B62S1_LSB			0
+#define CSR_SEQUENCEREG0B62S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B62S2 */
+#define CSR_SEQUENCEREG0B62S2_LSB			0
+#define CSR_SEQUENCEREG0B62S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B63S0 */
+#define CSR_SEQUENCEREG0B63S0_LSB			0
+#define CSR_SEQUENCEREG0B63S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B63S1 */
+#define CSR_SEQUENCEREG0B63S1_LSB			0
+#define CSR_SEQUENCEREG0B63S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B63S2 */
+#define CSR_SEQUENCEREG0B63S2_LSB			0
+#define CSR_SEQUENCEREG0B63S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B64S0 */
+#define CSR_SEQUENCEREG0B64S0_LSB			0
+#define CSR_SEQUENCEREG0B64S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B64S1 */
+#define CSR_SEQUENCEREG0B64S1_LSB			0
+#define CSR_SEQUENCEREG0B64S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B64S2 */
+#define CSR_SEQUENCEREG0B64S2_LSB			0
+#define CSR_SEQUENCEREG0B64S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B65S0 */
+#define CSR_SEQUENCEREG0B65S0_LSB			0
+#define CSR_SEQUENCEREG0B65S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B65S1 */
+#define CSR_SEQUENCEREG0B65S1_LSB			0
+#define CSR_SEQUENCEREG0B65S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B65S2 */
+#define CSR_SEQUENCEREG0B65S2_LSB			0
+#define CSR_SEQUENCEREG0B65S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B66S0 */
+#define CSR_SEQUENCEREG0B66S0_LSB			0
+#define CSR_SEQUENCEREG0B66S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B66S1 */
+#define CSR_SEQUENCEREG0B66S1_LSB			0
+#define CSR_SEQUENCEREG0B66S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B66S2 */
+#define CSR_SEQUENCEREG0B66S2_LSB			0
+#define CSR_SEQUENCEREG0B66S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B67S0 */
+#define CSR_SEQUENCEREG0B67S0_LSB			0
+#define CSR_SEQUENCEREG0B67S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B67S1 */
+#define CSR_SEQUENCEREG0B67S1_LSB			0
+#define CSR_SEQUENCEREG0B67S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B67S2 */
+#define CSR_SEQUENCEREG0B67S2_LSB			0
+#define CSR_SEQUENCEREG0B67S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B68S0 */
+#define CSR_SEQUENCEREG0B68S0_LSB			0
+#define CSR_SEQUENCEREG0B68S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B68S1 */
+#define CSR_SEQUENCEREG0B68S1_LSB			0
+#define CSR_SEQUENCEREG0B68S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B68S2 */
+#define CSR_SEQUENCEREG0B68S2_LSB			0
+#define CSR_SEQUENCEREG0B68S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B69S0 */
+#define CSR_SEQUENCEREG0B69S0_LSB			0
+#define CSR_SEQUENCEREG0B69S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B69S1 */
+#define CSR_SEQUENCEREG0B69S1_LSB			0
+#define CSR_SEQUENCEREG0B69S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B69S2 */
+#define CSR_SEQUENCEREG0B69S2_LSB			0
+#define CSR_SEQUENCEREG0B69S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B70S0 */
+#define CSR_SEQUENCEREG0B70S0_LSB			0
+#define CSR_SEQUENCEREG0B70S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B70S1 */
+#define CSR_SEQUENCEREG0B70S1_LSB			0
+#define CSR_SEQUENCEREG0B70S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B70S2 */
+#define CSR_SEQUENCEREG0B70S2_LSB			0
+#define CSR_SEQUENCEREG0B70S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B71S0 */
+#define CSR_SEQUENCEREG0B71S0_LSB			0
+#define CSR_SEQUENCEREG0B71S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B71S1 */
+#define CSR_SEQUENCEREG0B71S1_LSB			0
+#define CSR_SEQUENCEREG0B71S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B71S2 */
+#define CSR_SEQUENCEREG0B71S2_LSB			0
+#define CSR_SEQUENCEREG0B71S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B72S0 */
+#define CSR_SEQUENCEREG0B72S0_LSB			0
+#define CSR_SEQUENCEREG0B72S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B72S1 */
+#define CSR_SEQUENCEREG0B72S1_LSB			0
+#define CSR_SEQUENCEREG0B72S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B72S2 */
+#define CSR_SEQUENCEREG0B72S2_LSB			0
+#define CSR_SEQUENCEREG0B72S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B73S0 */
+#define CSR_SEQUENCEREG0B73S0_LSB			0
+#define CSR_SEQUENCEREG0B73S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B73S1 */
+#define CSR_SEQUENCEREG0B73S1_LSB			0
+#define CSR_SEQUENCEREG0B73S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B73S2 */
+#define CSR_SEQUENCEREG0B73S2_LSB			0
+#define CSR_SEQUENCEREG0B73S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B74S0 */
+#define CSR_SEQUENCEREG0B74S0_LSB			0
+#define CSR_SEQUENCEREG0B74S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B74S1 */
+#define CSR_SEQUENCEREG0B74S1_LSB			0
+#define CSR_SEQUENCEREG0B74S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B74S2 */
+#define CSR_SEQUENCEREG0B74S2_LSB			0
+#define CSR_SEQUENCEREG0B74S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B75S0 */
+#define CSR_SEQUENCEREG0B75S0_LSB			0
+#define CSR_SEQUENCEREG0B75S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B75S1 */
+#define CSR_SEQUENCEREG0B75S1_LSB			0
+#define CSR_SEQUENCEREG0B75S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B75S2 */
+#define CSR_SEQUENCEREG0B75S2_LSB			0
+#define CSR_SEQUENCEREG0B75S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B76S0 */
+#define CSR_SEQUENCEREG0B76S0_LSB			0
+#define CSR_SEQUENCEREG0B76S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B76S1 */
+#define CSR_SEQUENCEREG0B76S1_LSB			0
+#define CSR_SEQUENCEREG0B76S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B76S2 */
+#define CSR_SEQUENCEREG0B76S2_LSB			0
+#define CSR_SEQUENCEREG0B76S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B77S0 */
+#define CSR_SEQUENCEREG0B77S0_LSB			0
+#define CSR_SEQUENCEREG0B77S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B77S1 */
+#define CSR_SEQUENCEREG0B77S1_LSB			0
+#define CSR_SEQUENCEREG0B77S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B77S2 */
+#define CSR_SEQUENCEREG0B77S2_LSB			0
+#define CSR_SEQUENCEREG0B77S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B78S0 */
+#define CSR_SEQUENCEREG0B78S0_LSB			0
+#define CSR_SEQUENCEREG0B78S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B78S1 */
+#define CSR_SEQUENCEREG0B78S1_LSB			0
+#define CSR_SEQUENCEREG0B78S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B78S2 */
+#define CSR_SEQUENCEREG0B78S2_LSB			0
+#define CSR_SEQUENCEREG0B78S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B79S0 */
+#define CSR_SEQUENCEREG0B79S0_LSB			0
+#define CSR_SEQUENCEREG0B79S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B79S1 */
+#define CSR_SEQUENCEREG0B79S1_LSB			0
+#define CSR_SEQUENCEREG0B79S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B79S2 */
+#define CSR_SEQUENCEREG0B79S2_LSB			0
+#define CSR_SEQUENCEREG0B79S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B80S0 */
+#define CSR_SEQUENCEREG0B80S0_LSB			0
+#define CSR_SEQUENCEREG0B80S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B80S1 */
+#define CSR_SEQUENCEREG0B80S1_LSB			0
+#define CSR_SEQUENCEREG0B80S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B80S2 */
+#define CSR_SEQUENCEREG0B80S2_LSB			0
+#define CSR_SEQUENCEREG0B80S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B81S0 */
+#define CSR_SEQUENCEREG0B81S0_LSB			0
+#define CSR_SEQUENCEREG0B81S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B81S1 */
+#define CSR_SEQUENCEREG0B81S1_LSB			0
+#define CSR_SEQUENCEREG0B81S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B81S2 */
+#define CSR_SEQUENCEREG0B81S2_LSB			0
+#define CSR_SEQUENCEREG0B81S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B82S0 */
+#define CSR_SEQUENCEREG0B82S0_LSB			0
+#define CSR_SEQUENCEREG0B82S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B82S1 */
+#define CSR_SEQUENCEREG0B82S1_LSB			0
+#define CSR_SEQUENCEREG0B82S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B82S2 */
+#define CSR_SEQUENCEREG0B82S2_LSB			0
+#define CSR_SEQUENCEREG0B82S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B83S0 */
+#define CSR_SEQUENCEREG0B83S0_LSB			0
+#define CSR_SEQUENCEREG0B83S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B83S1 */
+#define CSR_SEQUENCEREG0B83S1_LSB			0
+#define CSR_SEQUENCEREG0B83S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B83S2 */
+#define CSR_SEQUENCEREG0B83S2_LSB			0
+#define CSR_SEQUENCEREG0B83S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B84S0 */
+#define CSR_SEQUENCEREG0B84S0_LSB			0
+#define CSR_SEQUENCEREG0B84S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B84S1 */
+#define CSR_SEQUENCEREG0B84S1_LSB			0
+#define CSR_SEQUENCEREG0B84S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B84S2 */
+#define CSR_SEQUENCEREG0B84S2_LSB			0
+#define CSR_SEQUENCEREG0B84S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B85S0 */
+#define CSR_SEQUENCEREG0B85S0_LSB			0
+#define CSR_SEQUENCEREG0B85S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B85S1 */
+#define CSR_SEQUENCEREG0B85S1_LSB			0
+#define CSR_SEQUENCEREG0B85S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B85S2 */
+#define CSR_SEQUENCEREG0B85S2_LSB			0
+#define CSR_SEQUENCEREG0B85S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B86S0 */
+#define CSR_SEQUENCEREG0B86S0_LSB			0
+#define CSR_SEQUENCEREG0B86S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B86S1 */
+#define CSR_SEQUENCEREG0B86S1_LSB			0
+#define CSR_SEQUENCEREG0B86S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B86S2 */
+#define CSR_SEQUENCEREG0B86S2_LSB			0
+#define CSR_SEQUENCEREG0B86S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B87S0 */
+#define CSR_SEQUENCEREG0B87S0_LSB			0
+#define CSR_SEQUENCEREG0B87S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B87S1 */
+#define CSR_SEQUENCEREG0B87S1_LSB			0
+#define CSR_SEQUENCEREG0B87S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B87S2 */
+#define CSR_SEQUENCEREG0B87S2_LSB			0
+#define CSR_SEQUENCEREG0B87S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B88S0 */
+#define CSR_SEQUENCEREG0B88S0_LSB			0
+#define CSR_SEQUENCEREG0B88S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B88S1 */
+#define CSR_SEQUENCEREG0B88S1_LSB			0
+#define CSR_SEQUENCEREG0B88S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B88S2 */
+#define CSR_SEQUENCEREG0B88S2_LSB			0
+#define CSR_SEQUENCEREG0B88S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B89S0 */
+#define CSR_SEQUENCEREG0B89S0_LSB			0
+#define CSR_SEQUENCEREG0B89S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B89S1 */
+#define CSR_SEQUENCEREG0B89S1_LSB			0
+#define CSR_SEQUENCEREG0B89S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B89S2 */
+#define CSR_SEQUENCEREG0B89S2_LSB			0
+#define CSR_SEQUENCEREG0B89S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B90S0 */
+#define CSR_SEQUENCEREG0B90S0_LSB			0
+#define CSR_SEQUENCEREG0B90S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B90S1 */
+#define CSR_SEQUENCEREG0B90S1_LSB			0
+#define CSR_SEQUENCEREG0B90S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B90S2 */
+#define CSR_SEQUENCEREG0B90S2_LSB			0
+#define CSR_SEQUENCEREG0B90S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B91S0 */
+#define CSR_SEQUENCEREG0B91S0_LSB			0
+#define CSR_SEQUENCEREG0B91S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B91S1 */
+#define CSR_SEQUENCEREG0B91S1_LSB			0
+#define CSR_SEQUENCEREG0B91S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B91S2 */
+#define CSR_SEQUENCEREG0B91S2_LSB			0
+#define CSR_SEQUENCEREG0B91S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B92S0 */
+#define CSR_SEQUENCEREG0B92S0_LSB			0
+#define CSR_SEQUENCEREG0B92S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B92S1 */
+#define CSR_SEQUENCEREG0B92S1_LSB			0
+#define CSR_SEQUENCEREG0B92S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B92S2 */
+#define CSR_SEQUENCEREG0B92S2_LSB			0
+#define CSR_SEQUENCEREG0B92S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B93S0 */
+#define CSR_SEQUENCEREG0B93S0_LSB			0
+#define CSR_SEQUENCEREG0B93S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B93S1 */
+#define CSR_SEQUENCEREG0B93S1_LSB			0
+#define CSR_SEQUENCEREG0B93S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B93S2 */
+#define CSR_SEQUENCEREG0B93S2_LSB			0
+#define CSR_SEQUENCEREG0B93S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B94S0 */
+#define CSR_SEQUENCEREG0B94S0_LSB			0
+#define CSR_SEQUENCEREG0B94S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B94S1 */
+#define CSR_SEQUENCEREG0B94S1_LSB			0
+#define CSR_SEQUENCEREG0B94S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B94S2 */
+#define CSR_SEQUENCEREG0B94S2_LSB			0
+#define CSR_SEQUENCEREG0B94S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B95S0 */
+#define CSR_SEQUENCEREG0B95S0_LSB			0
+#define CSR_SEQUENCEREG0B95S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B95S1 */
+#define CSR_SEQUENCEREG0B95S1_LSB			0
+#define CSR_SEQUENCEREG0B95S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B95S2 */
+#define CSR_SEQUENCEREG0B95S2_LSB			0
+#define CSR_SEQUENCEREG0B95S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B96S0 */
+#define CSR_SEQUENCEREG0B96S0_LSB			0
+#define CSR_SEQUENCEREG0B96S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B96S1 */
+#define CSR_SEQUENCEREG0B96S1_LSB			0
+#define CSR_SEQUENCEREG0B96S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B96S2 */
+#define CSR_SEQUENCEREG0B96S2_LSB			0
+#define CSR_SEQUENCEREG0B96S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B97S0 */
+#define CSR_SEQUENCEREG0B97S0_LSB			0
+#define CSR_SEQUENCEREG0B97S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B97S1 */
+#define CSR_SEQUENCEREG0B97S1_LSB			0
+#define CSR_SEQUENCEREG0B97S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B97S2 */
+#define CSR_SEQUENCEREG0B97S2_LSB			0
+#define CSR_SEQUENCEREG0B97S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B98S0 */
+#define CSR_SEQUENCEREG0B98S0_LSB			0
+#define CSR_SEQUENCEREG0B98S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B98S1 */
+#define CSR_SEQUENCEREG0B98S1_LSB			0
+#define CSR_SEQUENCEREG0B98S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B98S2 */
+#define CSR_SEQUENCEREG0B98S2_LSB			0
+#define CSR_SEQUENCEREG0B98S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B99S0 */
+#define CSR_SEQUENCEREG0B99S0_LSB			0
+#define CSR_SEQUENCEREG0B99S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B99S1 */
+#define CSR_SEQUENCEREG0B99S1_LSB			0
+#define CSR_SEQUENCEREG0B99S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B99S2 */
+#define CSR_SEQUENCEREG0B99S2_LSB			0
+#define CSR_SEQUENCEREG0B99S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B100S0 */
+#define CSR_SEQUENCEREG0B100S0_LSB			0
+#define CSR_SEQUENCEREG0B100S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B100S1 */
+#define CSR_SEQUENCEREG0B100S1_LSB			0
+#define CSR_SEQUENCEREG0B100S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B100S2 */
+#define CSR_SEQUENCEREG0B100S2_LSB			0
+#define CSR_SEQUENCEREG0B100S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B101S0 */
+#define CSR_SEQUENCEREG0B101S0_LSB			0
+#define CSR_SEQUENCEREG0B101S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B101S1 */
+#define CSR_SEQUENCEREG0B101S1_LSB			0
+#define CSR_SEQUENCEREG0B101S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B101S2 */
+#define CSR_SEQUENCEREG0B101S2_LSB			0
+#define CSR_SEQUENCEREG0B101S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B102S0 */
+#define CSR_SEQUENCEREG0B102S0_LSB			0
+#define CSR_SEQUENCEREG0B102S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B102S1 */
+#define CSR_SEQUENCEREG0B102S1_LSB			0
+#define CSR_SEQUENCEREG0B102S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B102S2 */
+#define CSR_SEQUENCEREG0B102S2_LSB			0
+#define CSR_SEQUENCEREG0B102S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B103S0 */
+#define CSR_SEQUENCEREG0B103S0_LSB			0
+#define CSR_SEQUENCEREG0B103S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B103S1 */
+#define CSR_SEQUENCEREG0B103S1_LSB			0
+#define CSR_SEQUENCEREG0B103S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B103S2 */
+#define CSR_SEQUENCEREG0B103S2_LSB			0
+#define CSR_SEQUENCEREG0B103S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B104S0 */
+#define CSR_SEQUENCEREG0B104S0_LSB			0
+#define CSR_SEQUENCEREG0B104S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B104S1 */
+#define CSR_SEQUENCEREG0B104S1_LSB			0
+#define CSR_SEQUENCEREG0B104S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B104S2 */
+#define CSR_SEQUENCEREG0B104S2_LSB			0
+#define CSR_SEQUENCEREG0B104S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B105S0 */
+#define CSR_SEQUENCEREG0B105S0_LSB			0
+#define CSR_SEQUENCEREG0B105S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B105S1 */
+#define CSR_SEQUENCEREG0B105S1_LSB			0
+#define CSR_SEQUENCEREG0B105S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B105S2 */
+#define CSR_SEQUENCEREG0B105S2_LSB			0
+#define CSR_SEQUENCEREG0B105S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B106S0 */
+#define CSR_SEQUENCEREG0B106S0_LSB			0
+#define CSR_SEQUENCEREG0B106S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B106S1 */
+#define CSR_SEQUENCEREG0B106S1_LSB			0
+#define CSR_SEQUENCEREG0B106S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B106S2 */
+#define CSR_SEQUENCEREG0B106S2_LSB			0
+#define CSR_SEQUENCEREG0B106S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B107S0 */
+#define CSR_SEQUENCEREG0B107S0_LSB			0
+#define CSR_SEQUENCEREG0B107S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B107S1 */
+#define CSR_SEQUENCEREG0B107S1_LSB			0
+#define CSR_SEQUENCEREG0B107S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B107S2 */
+#define CSR_SEQUENCEREG0B107S2_LSB			0
+#define CSR_SEQUENCEREG0B107S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B108S0 */
+#define CSR_SEQUENCEREG0B108S0_LSB			0
+#define CSR_SEQUENCEREG0B108S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B108S1 */
+#define CSR_SEQUENCEREG0B108S1_LSB			0
+#define CSR_SEQUENCEREG0B108S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B108S2 */
+#define CSR_SEQUENCEREG0B108S2_LSB			0
+#define CSR_SEQUENCEREG0B108S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B109S0 */
+#define CSR_SEQUENCEREG0B109S0_LSB			0
+#define CSR_SEQUENCEREG0B109S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B109S1 */
+#define CSR_SEQUENCEREG0B109S1_LSB			0
+#define CSR_SEQUENCEREG0B109S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B109S2 */
+#define CSR_SEQUENCEREG0B109S2_LSB			0
+#define CSR_SEQUENCEREG0B109S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B110S0 */
+#define CSR_SEQUENCEREG0B110S0_LSB			0
+#define CSR_SEQUENCEREG0B110S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B110S1 */
+#define CSR_SEQUENCEREG0B110S1_LSB			0
+#define CSR_SEQUENCEREG0B110S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B110S2 */
+#define CSR_SEQUENCEREG0B110S2_LSB			0
+#define CSR_SEQUENCEREG0B110S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B111S0 */
+#define CSR_SEQUENCEREG0B111S0_LSB			0
+#define CSR_SEQUENCEREG0B111S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B111S1 */
+#define CSR_SEQUENCEREG0B111S1_LSB			0
+#define CSR_SEQUENCEREG0B111S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B111S2 */
+#define CSR_SEQUENCEREG0B111S2_LSB			0
+#define CSR_SEQUENCEREG0B111S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B112S0 */
+#define CSR_SEQUENCEREG0B112S0_LSB			0
+#define CSR_SEQUENCEREG0B112S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B112S1 */
+#define CSR_SEQUENCEREG0B112S1_LSB			0
+#define CSR_SEQUENCEREG0B112S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B112S2 */
+#define CSR_SEQUENCEREG0B112S2_LSB			0
+#define CSR_SEQUENCEREG0B112S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B113S0 */
+#define CSR_SEQUENCEREG0B113S0_LSB			0
+#define CSR_SEQUENCEREG0B113S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B113S1 */
+#define CSR_SEQUENCEREG0B113S1_LSB			0
+#define CSR_SEQUENCEREG0B113S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B113S2 */
+#define CSR_SEQUENCEREG0B113S2_LSB			0
+#define CSR_SEQUENCEREG0B113S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B114S0 */
+#define CSR_SEQUENCEREG0B114S0_LSB			0
+#define CSR_SEQUENCEREG0B114S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B114S1 */
+#define CSR_SEQUENCEREG0B114S1_LSB			0
+#define CSR_SEQUENCEREG0B114S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B114S2 */
+#define CSR_SEQUENCEREG0B114S2_LSB			0
+#define CSR_SEQUENCEREG0B114S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B115S0 */
+#define CSR_SEQUENCEREG0B115S0_LSB			0
+#define CSR_SEQUENCEREG0B115S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B115S1 */
+#define CSR_SEQUENCEREG0B115S1_LSB			0
+#define CSR_SEQUENCEREG0B115S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B115S2 */
+#define CSR_SEQUENCEREG0B115S2_LSB			0
+#define CSR_SEQUENCEREG0B115S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B116S0 */
+#define CSR_SEQUENCEREG0B116S0_LSB			0
+#define CSR_SEQUENCEREG0B116S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B116S1 */
+#define CSR_SEQUENCEREG0B116S1_LSB			0
+#define CSR_SEQUENCEREG0B116S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B116S2 */
+#define CSR_SEQUENCEREG0B116S2_LSB			0
+#define CSR_SEQUENCEREG0B116S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B117S0 */
+#define CSR_SEQUENCEREG0B117S0_LSB			0
+#define CSR_SEQUENCEREG0B117S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B117S1 */
+#define CSR_SEQUENCEREG0B117S1_LSB			0
+#define CSR_SEQUENCEREG0B117S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B117S2 */
+#define CSR_SEQUENCEREG0B117S2_LSB			0
+#define CSR_SEQUENCEREG0B117S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B118S0 */
+#define CSR_SEQUENCEREG0B118S0_LSB			0
+#define CSR_SEQUENCEREG0B118S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B118S1 */
+#define CSR_SEQUENCEREG0B118S1_LSB			0
+#define CSR_SEQUENCEREG0B118S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B118S2 */
+#define CSR_SEQUENCEREG0B118S2_LSB			0
+#define CSR_SEQUENCEREG0B118S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B119S0 */
+#define CSR_SEQUENCEREG0B119S0_LSB			0
+#define CSR_SEQUENCEREG0B119S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B119S1 */
+#define CSR_SEQUENCEREG0B119S1_LSB			0
+#define CSR_SEQUENCEREG0B119S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B119S2 */
+#define CSR_SEQUENCEREG0B119S2_LSB			0
+#define CSR_SEQUENCEREG0B119S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B120S0 */
+#define CSR_SEQUENCEREG0B120S0_LSB			0
+#define CSR_SEQUENCEREG0B120S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B120S1 */
+#define CSR_SEQUENCEREG0B120S1_LSB			0
+#define CSR_SEQUENCEREG0B120S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B120S2 */
+#define CSR_SEQUENCEREG0B120S2_LSB			0
+#define CSR_SEQUENCEREG0B120S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQUENCEREG0B121S0 */
+#define CSR_SEQUENCEREG0B121S0_LSB			0
+#define CSR_SEQUENCEREG0B121S0_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B121S1 */
+#define CSR_SEQUENCEREG0B121S1_LSB			0
+#define CSR_SEQUENCEREG0B121S1_MASK			GENMASK_32(15, 0)
+/* CSR_SEQUENCEREG0B121S2 */
+#define CSR_SEQUENCEREG0B121S2_LSB			0
+#define CSR_SEQUENCEREG0B121S2_MASK			GENMASK_32(8, 0)
+/* CSR_SEQ0BGPR1 */
+#define CSR_SEQ0BGPR1_LSB				0
+#define CSR_SEQ0BGPR1_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR2 */
+#define CSR_SEQ0BGPR2_LSB				0
+#define CSR_SEQ0BGPR2_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR3 */
+#define CSR_SEQ0BGPR3_LSB				0
+#define CSR_SEQ0BGPR3_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR4 */
+#define CSR_SEQ0BGPR4_LSB				0
+#define CSR_SEQ0BGPR4_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR5 */
+#define CSR_SEQ0BGPR5_LSB				0
+#define CSR_SEQ0BGPR5_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR6 */
+#define CSR_SEQ0BGPR6_LSB				0
+#define CSR_SEQ0BGPR6_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR7 */
+#define CSR_SEQ0BGPR7_LSB				0
+#define CSR_SEQ0BGPR7_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BGPR8 */
+#define CSR_SEQ0BGPR8_LSB				0
+#define CSR_SEQ0BGPR8_MASK				GENMASK_32(15, 0)
+/* CSR_SEQ0BFIXEDADDRBITS */
+#define CSR_SEQ0BFIXEDADDRBITS_LSB			0
+#define CSR_SEQ0BFIXEDADDRBITS_MASK			GENMASK_32(6, 0)
+#define CSR_SEQ0BCHIPLETBITS_LSB			0
+#define CSR_SEQ0BCHIPLETBITS_MASK			GENMASK_32(3, 0)
+#define CSR_SEQ0BPSTATEBITS_LSB				4
+#define CSR_SEQ0BPSTATEBITS_MASK			GENMASK_32(6, 4)
+
+/* DRTUB0 register offsets */
+/* CSR_DCTSHADOWREGS */
+#define CSR_DCTSHADOWREGS_LSB				0
+#define CSR_DCTSHADOWREGS_MASK				BIT(0)
+#define CSR_DCTWRITEPROTSHADOW_LSB			0
+#define CSR_DCTWRITEPROTSHADOW_MASK			BIT(0)
+/* CSR_DCTWRITEONLYSHADOW */
+#define CSR_DCTWRITEONLYSHADOW_LSB			0
+#define CSR_DCTWRITEONLYSHADOW_MASK			GENMASK_32(15, 0)
+/* CSR_UCTWRITEONLY */
+#define CSR_UCTWRITEONLY_LSB				0
+#define CSR_UCTWRITEONLY_MASK				GENMASK_32(15, 0)
+/* CSR_UCTWRITEPROT */
+#define CSR_UCTWRITEPROT_LSB				0
+#define CSR_UCTWRITEPROT_MASK				BIT(0)
+/* CSR_UCTDATWRITEONLY */
+#define CSR_UCTDATWRITEONLY_LSB				0
+#define CSR_UCTDATWRITEONLY_MASK			GENMASK_32(15, 0)
+/* CSR_UCTDATWRITEPROT */
+#define CSR_UCTDATWRITEPROT_LSB				0
+#define CSR_UCTDATWRITEPROT_MASK			BIT(0)
+/* CSR_UCTLERR */
+#define CSR_UCTLERR_LSB					0
+#define CSR_UCTLERR_MASK				BIT(0)
+/* CSR_UCCLKHCLKENABLES */
+#define CSR_UCCLKHCLKENABLES_LSB			0
+#define CSR_UCCLKHCLKENABLES_MASK			GENMASK_32(1, 0)
+#define CSR_UCCLKEN_LSB					0
+#define CSR_UCCLKEN_MASK				BIT(0)
+#define CSR_HCLKEN_LSB					1
+#define CSR_HCLKEN_MASK					BIT(1)
+/* CSR_CURPSTATE0B */
+#define CSR_CURPSTATE0B_LSB				0
+#define CSR_CURPSTATE0B_MASK				GENMASK_32(3, 0)
+/* CSR_CLRWAKEUPSTICKY */
+#define CSR_CLRWAKEUPSTICKY_LSB				0
+#define CSR_CLRWAKEUPSTICKY_MASK			GENMASK_32(3, 0)
+/* CSR_WAKEUPMASK */
+#define CSR_WAKEUPMASK_LSB				0
+#define CSR_WAKEUPMASK_MASK				GENMASK_32(3, 0)
+/* CSR_CUSTPUBREV */
+#define CSR_CUSTPUBREV_LSB				0
+#define CSR_CUSTPUBREV_MASK				GENMASK_32(5, 0)
+/* CSR_PUBREV */
+#define CSR_PUBREV_LSB					0
+#define CSR_PUBREV_MASK					GENMASK_32(15, 0)
+#define CSR_RESERVEDPUBREV_LSB				0
+#define CSR_RESERVEDPUBREV_MASK				GENMASK_32(3, 0)
+#define CSR_PUBMNR_LSB					4
+#define CSR_PUBMNR_MASK					GENMASK_32(7, 4)
+#define CSR_PUBMDR_LSB					8
+#define CSR_PUBMDR_MASK					GENMASK_32(11, 8)
+#define CSR_PUBMJR_LSB					12
+#define CSR_PUBMJR_MASK					GENMASK_32(15, 12)
+
+/* APBONLY0 register offsets */
+/* CSR_MICROCONTMUXSEL */
+#define CSR_MICROCONTMUXSEL_LSB				0
+#define CSR_MICROCONTMUXSEL_MASK			BIT(0)
+/* CSR_UCTSHADOWREGS */
+#define CSR_UCTSHADOWREGS_LSB				0
+#define CSR_UCTSHADOWREGS_MASK				GENMASK_32(1, 0)
+#define CSR_UCTWRITEPROTSHADOW_LSB			0
+#define CSR_UCTWRITEPROTSHADOW_MASK			BIT(0)
+#define CSR_UCTDATWRITEPROTSHADOW_LSB			1
+#define CSR_UCTDATWRITEPROTSHADOW_MASK			BIT(1)
+/* CSR_DCTWRITEONLY */
+#define CSR_DCTWRITEONLY_LSB				0
+#define CSR_DCTWRITEONLY_MASK				GENMASK_32(15, 0)
+/* CSR_DCTWRITEPROT */
+#define CSR_DCTWRITEPROT_LSB				0
+#define CSR_DCTWRITEPROT_MASK				BIT(0)
+/* CSR_UCTWRITEONLYSHADOW */
+#define CSR_UCTWRITEONLYSHADOW_LSB			0
+#define CSR_UCTWRITEONLYSHADOW_MASK			GENMASK_32(15, 0)
+/* CSR_UCTDATWRITEONLYSHADOW */
+#define CSR_UCTDATWRITEONLYSHADOW_LSB			0
+#define CSR_UCTDATWRITEONLYSHADOW_MASK			GENMASK_32(15, 0)
+/* CSR_NEVERGATECSRCLOCK */
+#define CSR_NEVERGATECSRCLOCK_LSB			0
+#define CSR_NEVERGATECSRCLOCK_MASK			BIT(0)
+/* CSR_DFICFGRDDATAVALIDTICKS */
+#define CSR_DFICFGRDDATAVALIDTICKS_LSB			0
+#define CSR_DFICFGRDDATAVALIDTICKS_MASK			GENMASK_32(5, 0)
+/* CSR_MICRORESET */
+#define CSR_MICRORESET_LSB				0
+#define CSR_MICRORESET_MASK				GENMASK_32(3, 0)
+#define CSR_STALLTOMICRO_LSB				0
+#define CSR_STALLTOMICRO_MASK				BIT(0)
+#define CSR_TESTWAKEUP_LSB				1
+#define CSR_TESTWAKEUP_MASK				BIT(1)
+#define CSR_RSVDMICRO_LSB				2
+#define CSR_RSVDMICRO_MASK				BIT(2)
+#define CSR_RESETTOMICRO_LSB				3
+#define CSR_RESETTOMICRO_MASK				BIT(3)
+/* CSR_SEQUENCEROVERRIDE */
+#define CSR_SEQUENCEROVERRIDE_LSB			0
+#define CSR_SEQUENCEROVERRIDE_MASK			GENMASK_32(10, 0)
+#define CSR_FORCESEQ0BDFIFREQ_LSB			0
+#define CSR_FORCESEQ0BDFIFREQ_MASK			GENMASK_32(4, 0)
+#define CSR_FORCESEQ0BSTART_LSB				5
+#define CSR_FORCESEQ0BSTART_MASK			BIT(5)
+#define CSR_FORCESEQ0BSTOP_LSB				6
+#define CSR_FORCESEQ0BSTOP_MASK				BIT(6)
+#define CSR_BLOCKSEQ0BREQUESTS_LSB			7
+#define CSR_BLOCKSEQ0BREQUESTS_MASK			BIT(7)
+#define CSR_BLOCKSEQ0BACK_LSB				8
+#define CSR_BLOCKSEQ0BACK_MASK				BIT(8)
+#define CSR_DISABLETERMINATEFLAG_LSB			9
+#define CSR_DISABLETERMINATEFLAG_MASK			BIT(9)
+#define CSR_SELECTDFIFREQTOGPRMUX_LSB			10
+#define CSR_SELECTDFIFREQTOGPRMUX_MASK			BIT(10)
+/* CSR_DFIINITCOMPLETESHADOW */
+#define CSR_DFIINITCOMPLETESHADOW_LSB			0
+#define CSR_DFIINITCOMPLETESHADOW_MASK			BIT(0)
+
+
+/* Fields brought to you by the letter B */
+#define B_MIN						0U
+#define B_MAX						1U
+#define B0						0x0U
+#define B1						0x100U
+#define BBRD						0xF00U
+#define BB_MIN						0U
+#define BB_MAX						15U
+#define BB0						0x0U
+#define BB1						0x1000U
+#define BB2						0x2000U
+#define BB3						0x3000U
+#define BB4						0x4000U
+#define BB5						0x5000U
+#define BB6						0x6000U
+#define BB7						0x7000U
+#define BB8						0x8000U
+#define BB9						0x9000U
+#define BB10						0xA000U
+#define BB11						0xB000U
+#define BB12						0xC000U
+#define BB13						0xD000U
+#define BB14						0xE000U
+#define BB15						0xF000U
+#define BBBRD						0xF000U
+/* Fields brought to you by the letter C */
+#define C_MIN						0U
+#define C_MAX						15U
+#define C0						0x0U
+#define C1						0x1000U
+#define C2						0x2000U
+#define C3						0x3000U
+#define C4						0x4000U
+#define C5						0x5000U
+#define C6						0x6000U
+#define C7						0x7000U
+#define C8						0x8000U
+#define C9						0x9000U
+#define C10						0xA000U
+#define C11						0xB000U
+#define C12						0xC000U
+#define C13						0xD000U
+#define C14						0xE000U
+#define C15						0xF000U
+#define CBRD						0xF000U
+/* Fields brought to you by the letter D */
+#define D_MIN						0U
+#define D_MAX						3U
+#define D0						0x0U
+#define D1						0x100U
+#define D2						0x200U
+#define D3						0x300U
+#define DBRD						0xF00U
+/* Fields brought to you by the letter I */
+#define I_MIN						0U
+#define I_MAX						8U
+#define I0						0x0U
+#define I1						0x100U
+#define I2						0x200U
+#define I3						0x300U
+#define I4						0x400U
+#define I5						0x500U
+#define I6						0x600U
+#define I7						0x700U
+#define I8						0x800U
+#define IBRD						0xF00U
+/* Fields brought to you by the letter J */
+#define J_MIN						0U
+#define J_MAX						0U
+#define J0						0x0U
+#define JBRD						0xF00U
+/* Fields brought to you by the letter L */
+#define L_MIN						0U
+#define L_MAX						13U
+#define L0						0x0U
+#define L1						0x100U
+#define L2						0x200U
+#define L3						0x300U
+#define L4						0x400U
+#define L5						0x500U
+#define L6						0x600U
+#define L7						0x700U
+#define L8						0x800U
+#define L9						0x900U
+#define L10						0xA00U
+#define L11						0xB00U
+#define L12						0xC00U
+#define L13						0xD00U
+#define LBRD						0xF00U
+/* Fields brought to you by the letter M */
+#define M_MIN						0U
+#define M_MAX						8U
+#define M0						0x0U
+#define M1						0x100U
+#define M2						0x200U
+#define M3						0x300U
+#define M4						0x400U
+#define M5						0x500U
+#define M6						0x600U
+#define M7						0x700U
+#define M8						0x800U
+#define MBRD						0xF00U
+/* Fields brought to you by the letter N */
+#define N_MIN						0U
+#define N_MAX						15U
+#define N0						0x0U
+#define N1						0x100U
+#define N2						0x200U
+#define N3						0x300U
+#define N4						0x400U
+#define N5						0x500U
+#define N6						0x600U
+#define N7						0x700U
+#define N8						0x800U
+#define N9						0x900U
+#define N10						0xA00U
+#define N11						0xB00U
+#define N12						0xC00U
+#define N13						0xD00U
+#define N14						0xE00U
+#define N15						0xF00U
+#define NBRD						0xF00U
+/* Fields brought to you by the letter P */
+#define P_MIN						0U
+#define P_MAX						3U
+#define P0						0x0U
+#define P1						0x100000U
+#define P2						0x200000U
+#define P3						0x300000U
+#define PBRD						0x700000U
+#define PP_MIN						0U
+#define PP_MAX						3U
+#define PP0						0x0U
+#define PP1						0x100000U
+#define PP2						0x200000U
+#define PP3						0x300000U
+#define PPBRD						0x700000U
+/* Fields brought to you by the letter Q */
+#define Q_MIN						0U
+#define Q_MAX						3U
+#define Q0						0x0U
+#define Q1						0x100000U
+#define Q2						0x200000U
+#define Q3						0x300000U
+#define QBRD						0x700000U
+/* Fields brought to you by the letter R */
+#define R_MIN						0U
+#define R_MAX						8U
+#define R0						0x0U
+#define R1						0x100U
+#define R2						0x200U
+#define R3						0x300U
+#define R4						0x400U
+#define R5						0x500U
+#define R6						0x600U
+#define R7						0x700U
+#define R8						0x800U
+#define RBRD						0xF00U
+/* Fields brought to you by the letter T */
+#define T_MIN						0U
+#define T_MAX						15U
+#define T0						0x0U
+#define T1						0x10000U
+#define T2						0x20000U
+#define T3						0x30000U
+#define T4						0x40000U
+#define T5						0x50000U
+#define T6						0x60000U
+#define T7						0x70000U
+#define T8						0x80000U
+#define T9						0x90000U
+#define T10						0xA0000U
+#define T11						0xB0000U
+#define T12						0xC0000U
+#define T13						0xD0000U
+#define T14						0xE0000U
+#define T15						0xF0000U
+#define TBRD						0xF0000U
+/* Fields brought to you by the letter U */
+#define U_MIN						0U
+#define U_MAX						1U
+#define U0						0x0U
+#define U1						0x100U
+#define UBRD						0xF00U
+/* Fields brought to you by the letter Y */
+#define Y_MIN						0U
+#define Y_MAX						0U
+#define Y0						0x0U
+#define YBRD						0xF000000U
+
+#define TACSM						0x40000U
+#define TACSMBRD					0x4F000U
+#define TALL						0xF0000U
+#define TALLBRD						0xFF000U
+#define TANIB						0x0U
+#define TANIBBRD					0xF000U
+#define TAPBONLY					0xD0000U
+#define TAPBONLYBRD					0xDF000U
+#define TDBYTE						0x10000U
+#define TDBYTEBRD					0x1F000U
+#define TDRTUB						0xC0000U
+#define TDRTUBBRD					0xCF000U
+#define TINITENG					0x90000U
+#define TINITENGBRD					0x9F000U
+#define TMASTER						0x20000U
+#define TMASTERBRD					0x2F000U
+#define TPPGC						0x70000U
+#define TPPGCBRD					0x7F000U
+#define TUCTL_MEM					0x50000U
+#define TUCTL_MEMBRD					0x5F000U
+
+#define DBYTE_NUM					9U
+#define ANIB_NUM					12U
+
+#endif /* DDRPHY_PHYINIT_CSR_ALL_DEFINES_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h
new file mode 100644
index 0000000000..acd7072a42
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_H
+#define DDRPHY_PHYINIT_H
+
+#include <stdbool.h>
+
+#include <ddrphy_phyinit_usercustom.h>
+
+enum message_block_field {
+	MB_FIELD_PSTATE,
+	MB_FIELD_PLLBYPASSEN,
+	MB_FIELD_DRAMFREQ,
+	MB_FIELD_DFIFREQRATIO,
+	MB_FIELD_BPZNRESVAL,
+	MB_FIELD_PHYODTIMPEDANCE,
+	MB_FIELD_PHYDRVIMPEDANCE,
+	MB_FIELD_DRAMTYPE,
+	MB_FIELD_DISABLEDDBYTE,
+	MB_FIELD_ENABLEDDQS,
+	MB_FIELD_PHYCFG,
+	MB_FIELD_X16PRESENT,
+	MB_FIELD_ENABLEDDQSCHA,
+	MB_FIELD_CSPRESENTCHA,
+	MB_FIELD_ENABLEDDQSCHB,
+	MB_FIELD_CSPRESENTCHB,
+};
+
+/* Function definitions */
+int ddrphy_phyinit_softsetmb(struct pmu_smb_ddr_1d *mb_ddr_1d, enum message_block_field field,
+			     uint32_t value);
+void ddrphy_phyinit_initstruct(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d);
+#endif /* DDRPHY_PHYINIT_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h
new file mode 100644
index 0000000000..9c98d1f74a
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_struct.h
@@ -0,0 +1,787 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_STRUCT_H
+#define DDRPHY_PHYINIT_STRUCT_H
+
+/* This file defines the internal data structures used in PhyInit to store user configuration */
+
+/* DIMM Type definitions */
+#define DDR_DIMMTYPE_NODIMM 4U /* No DIMM (Soldered-on) */
+
+/*
+ * Structure for basic user inputs
+ *
+ * The following basic data structure must be set and completed correctly so
+ * that the PhyInit software package can accurate program PHY registers.
+ */
+struct user_input_basic {
+	uint32_t dramtype;		/*
+					 * DRAM module type.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | DDR4
+					 *   0x1 | DDR3
+					 *   0x2 | LPDDR4
+					 */
+
+	uint32_t dimmtype;		/*
+					 * DIMM type.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x4 | No DIMM (Soldered-on) (DDR_DIMMTYPE_NODIMM)
+					 */
+
+	uint32_t lp4xmode;		/*
+					 * LPDDR4X mode support.
+					 * Only used for LPDDR4, but not valid here.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | LPDDR4 mode, when dramtype is LPDDR4
+					 */
+
+	uint32_t numdbyte;		/* Number of dbytes physically instantiated */
+
+	uint32_t numactivedbytedfi0;	/* Number of active dbytes to be controlled by dfi0 */
+
+	uint32_t numactivedbytedfi1;	/*
+					 * Number of active dbytes to be controlled by dfi1.
+					 * Only used for LPDDR4.
+					 */
+
+	uint32_t numanib;		/* Number of ANIBs physically instantiated */
+
+	uint32_t numrank_dfi0;		/* Number of ranks in DFI0 channel */
+
+	uint32_t numrank_dfi1;		/* Number of ranks in DFI1 channel (if DFI1 exists) */
+
+	uint32_t dramdatawidth;		/*
+					 * Width of the DRAM device.
+					 *
+					 * Enter 4,8,16 or 32 depending on protocol and dram type
+					 * according below table.
+					 *
+					 * Protocol | Valid Options | Default
+					 * -------- | ------------- | ---
+					 * DDR3     | 4,8,16        | 8
+					 * DDR4     | 4,8,16        | 8
+					 * LPDDR4   | 8,16          | 16
+					 *
+					 * For mixed x8 and x16 width devices, set variable to x8.
+					 */
+
+	uint32_t numpstates;		/* Number of p-states used. Must be set to 1 */
+
+	uint32_t frequency;		/*
+					 * Memclk frequency for each PState.
+					 * Memclk frequency in MHz round up to next highest integer.
+					 * Enter 334 for 333.333, etc.
+					 */
+
+	uint32_t pllbypass;		/*
+					 * Indicates if PLL should be in Bypass mode.
+					 * If DDR datarate < 333, PLL must be in Bypass Mode.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x1 | Enabled
+					 *   0x0 | Disabled
+					 */
+
+	uint32_t dfifreqratio;		/*
+					 * Selected Dfi Frequency ratio.
+					 * Used to program the dfifreqratio register. This register
+					 * controls how dfi_freq_ratio input pin should be driven
+					 * inaccordance with DFI Spec.
+					 *
+					 * Binary Value | Description
+					 *        ----- | ------
+					 *        2'b01 | 1:2 DFI Frequency Ratio (default)
+					 */
+
+	uint32_t dfi1exists;		/* Indicates if the PHY configuration has Dfi1 channel */
+
+	uint32_t train2d;		/* Obsolete. Not used. */
+
+	uint32_t hardmacrover;		/*
+					 * Hard Macro Family version in use.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   3   | hardmacro family D
+					 */
+
+	uint32_t readdbienable;		/* Obsolete. Not Used. */
+
+	uint32_t dfimode;		/* Obsolete. Not Used. */
+};
+
+
+/*
+ * Structure for advanced user inputs
+ */
+struct user_input_advanced {
+	uint32_t lp4rxpreamblemode;	/*
+					 * Selects between DRAM read static vs toggle preamble.
+					 * Determine desired DRAM Read Preamble Mode based on SI
+					 * Analysis and DRAM Part in use.
+					 * The PHY training firmware will program DRAM mr1-OP[3]
+					 * after training based on setting.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x1 | toggling preamble
+					 *   0x0 | static preamble
+					 */
+
+	uint32_t lp4postambleext;	/*
+					 * Extend write postamble in LPDDR4.
+					 * Only used for LPDDR4.
+					 * This variable is used to calculate LPDDR4 mr3-OP[1] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Set value according to your SI analysis and DRAM
+					 * requirement.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | half Memclk postamble
+					 *   0x1 | 1.5 Memclk postabmle (default)
+					 */
+
+	uint32_t d4rxpreamblelength;	/*
+					 * Length of read preamble in DDR4 mode.
+					 * Only used for DDR4.
+					 * This variable is used to calculate DDR4 mr4-OP[11] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Set value according to your SI analysis and DRAM
+					 * requirement.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 |  1 Tck
+					 *   0x1 |  2 Tck (default)
+					 */
+
+	uint32_t d4txpreamblelength;	/*
+					 * Length of write preamble in DDR4 mode.
+					 * Only used for DDR4.
+					 * This variable is used to calculate DDR4 mr4-OP[12] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Set value according to your SI analysis and DRAM
+					 * requirement.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | 1 Tck (default)
+					 *   0x1 | 2 Tck
+					 */
+
+	uint32_t extcalresval;		/*
+					 * External Impedance calibration pull-down resistor value
+					 * select.
+					 * Indicates value of impedance calibration pull-down
+					 * resistor connected to BP_ZN pin of the PHY.
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | 240 ohm (default)
+					 */
+
+	uint32_t is2ttiming;		/*
+					 * Set to 1 to use 2T timing for address/command, otherwise
+					 * 1T timing will be used.
+					 * Determine 1T or 2T Timing operation mode based on SI
+					 * Analysis and DRAM Timing.
+					 *   - In 1T mode, CK, CS, CA all have the same nominal
+					 *     timing, ie. ATxDly[6:0] will have same value for all
+					 *     ANIBs.
+					 *   - In 2T mode, CK, CS,have the same nominal timing
+					 *     (e.g. AtxDly[6:0]=0x00), while CA is delayed by 1UI
+					 *     (e.g. ATxDly[6:0]=0x40)
+					 * Used to program phycfg setting in messageBlock.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | 1T Timing (default)
+					 *   0x1 | 2T Timing
+					 */
+
+	uint32_t odtimpedance;		/*
+					 * ODT impedance in ohm.
+					 * Used for programming TxOdtDrvStren registers.
+					 * Enter 0 for open/high-impedance.
+					 * Default value: 60
+					 */
+
+	uint32_t tximpedance;		/*
+					 * Tx Drive Impedance for DQ/DQS in ohm.
+					 * Used for programming TxImpedanceCtrl1 registers.
+					 * Enter 0 for open/high-impedance.
+					 * Default value: 60
+					 */
+
+	uint32_t atximpedance;		/*
+					 * Tx Drive Impedance for AC in ohm.
+					 * Used for programming ATxImpedance register.
+					 * Enter 0 for open/high-impedance
+					 * Default value: 20 (HMA,HMB,HMC,HMD), 40 (HME)
+					 */
+
+	uint32_t memalerten;		/*
+					 * Enables BP_ALERT programming of PHY registers.
+					 * Only used for DDR3 and DDR4.
+					 * Used for programming MemAlertControl and MemAlertControl2
+					 * registers.
+					 * Program if you require using BP_ALERT pin (to receive or
+					 * terminate signal) of the PHY otherwise leave at default
+					 * value to save power.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 * 0x0 | Disable BP_ALERT (default)
+					 */
+
+	uint32_t memalertpuimp;		/*
+					 * Specify MemAlert Pull-up Termination Impedance.
+					 * Programs the pull-up termination on BP_ALERT.
+					 * Not valid here (fixed 0 value).
+					 */
+
+	uint32_t memalertvreflevel;	/*
+					 * Specify the Vref level for BP_ALERT(MemAlert) Receiver.
+					 * Not valid here (fixed 0 value).
+					 */
+
+	uint32_t memalertsyncbypass;	/*
+					 * When set, this bit bypasses the DfiClk synchronizer on
+					 * dfi_alert_n.
+					 * Not valid here (fixed 0 value).
+					 */
+
+	uint32_t disdynadrtri;		/*
+					 * Disable Dynamic Per-MEMCLK Address Tristate feature.
+					 * Program this variable if you require to disable this
+					 * feature.
+					 *   - In DDR3/2T and DDR4/2T/2N modes, the dynamic tristate
+					 *     feature should be disabled if the controller cannot
+					 *     follow the 2T PHY tristate protocol.
+					 *   - In LPDDR4 mode, the dynamic tristate feature should
+					 *     be disabled.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *  0x1  | Disable Dynamic Tristate
+					 */
+
+	uint32_t phymstrtraininterval;	/*
+					 * Specifies the how frequent dfi_phymstr_req is issued by
+					 * PHY.
+					 * Only required in LPDDR4.
+					 * Based on SI analysis determine how frequent DRAM drift
+					 * compensation and re-training is required.
+					 * Determine if Memory controller supports DFI PHY Master
+					 * Interface.
+					 * Program based on desired setting for
+					 * PPTTrainSetup.PhyMstrTrainInterval register.
+					 * Default value: 0xa
+					 *
+					 * Example:
+					 * Value | Description
+					 * ----- | ------
+					 *   0xa | PPT Train Interval = 268435456 MEMCLKs (default)
+					 */
+
+	uint32_t phymstrmaxreqtoack;	/*
+					 * Max time from dfi_phymstr_req asserted to dfi_phymstr_ack
+					 * asserted.
+					 * Only required in LPDDR4.
+					 * Based on your Memory controller's(MC) specification
+					 * determine how long the PHY should wait for the assertion
+					 * of dfi_phymstr_ack once dfi_phymstr_req has been issued
+					 * by the PHY. If the MC does not ack the PHY's request, PHY
+					 * may issue dfi_error.
+					 * This value will be used to program
+					 * PPTTrainSetup.PhyMstrMaxReqToAck register.
+					 * Default value: 0x5
+					 *
+					 * Example:
+					 * Value | Description
+					 * ----- | ------
+					 *   0x5 | PPT Max. Req to Ack. = 8192 MEMCLKs (default)
+					 */
+
+	uint32_t wdqsext;		/*
+					 * Enable Write DQS Extension feature of PHY.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 *   0x0 | Disable Write DQS Extension feature. (default)
+					 *   0x1 | Enable Write DQS Extension feature.
+					 */
+
+	uint32_t calinterval;		/*
+					 * Specifies the interval between successive calibrations,
+					 * in mS.
+					 * Program variable based on desired setting for
+					 * CalRate.CalInterval register.
+					 * - Fixed 0x9 value (20mS interval)
+					 */
+
+	uint32_t calonce;		/*
+					 * This setting changes the behaviour of CalRun register.
+					 * If you desire to manually trigger impedance calibration
+					 * in mission mode set this variable to 1, and toggle CalRun
+					 * in mission mode.
+					 *
+					 * Value | Description
+					 * ----- | ------
+					 * 0x0   | Calibration will proceed at the rate determined
+					 *       | by CalInterval. This field should only be changed
+					 *       | while the calibrator is idle. ie before csr
+					 *       | CalRun is set.
+					 */
+
+	uint32_t lp4rl;			/*
+					 * LPDDR4 Dram Read Latency.
+					 * Applicable only if dramtype == LPDDR4.
+					 * This variable is used to calculate LPDDR4 mr2-OP[2:0]
+					 * set in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Please refer to JEDEC JESD209-4A (LPDDR4) Spec for
+					 * definition of MR.
+					 * Determine values based on your DRAM part's supported
+					 * speed and latency bin.
+					 * Default: calculated based on user_input_basic.frequency
+					 * and "JEDEC JESD209-4A (LPDDR4)" Table 28 "Read and Write
+					 * Latencies".
+					 * Lowest latency selected when more than one latency can be
+					 * used. For example given configuration for LPDDR4, x16,
+					 * NoDbi and DDR533, RL=10 is selected rather than 14.
+					 */
+
+	uint32_t lp4wl;			/*
+					 * LPDDR4 Dram Write Latency.
+					 * Applicable only if dramtype == LPDDR4.
+					 * This variable is used to calculate LPDDR4 mr2-OP[5:3]
+					 * set in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Please refer to JEDEC JESD209-4A (LPDDR4) Spec for
+					 * definition of MR.
+					 * Determine values based on your DRAM part's supported
+					 * speed and latency bin.
+					 * Default: calculated based on user_input_basic.frequency
+					 * and "JEDEC JESD209-4A (LPDDR4)" Table 28 "Read and Write
+					 * Latencies".
+					 * Lowest latency selected when more than one latency can be
+					 * used.
+					 */
+
+	uint32_t lp4wls;		/*
+					 * LPDDR4 Dram WL Set.
+					 * Applicable only if dramtype == LPDDR4.
+					 * This variable is used to calculate LPDDR4 mr2-OP[6] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Please refer to JEDEC JESD209-4A (LPDDR4) Spec for
+					 * definition of MR.
+					 * Determine value based on Memory controllers requirement
+					 * of DRAM State after PHY training.
+					 *
+					 * Value | Description
+					 *   --- | ---
+					 *   0x0 | WL Set "A" (default)
+					 */
+
+	uint32_t lp4dbird;		/*
+					 * LPDDR4 Dram DBI-Read Enable.
+					 * Applicable only if dramtype == LPDDR4.
+					 * Determine if you require to using DBI for the given
+					 * PState.
+					 * If Read DBI is not used PHY receivers are turned off to
+					 * save power.
+					 * This variable is used to calculate LPDDR4 mr3-OP[6] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * PHY register DMIPinPresent is programmed based on this
+					 * parameter.
+					 * Please refer to JEDEC JESD209-4A (LPDDR4) Spec for
+					 * definition of MR.
+					 *
+					 * Value | Description
+					 *   --- | ---
+					 *   0x0 | Disabled (default)
+					 *   0x1 | Enabled
+					 */
+
+	uint32_t lp4dbiwr;		/*
+					 * LPDDR4 Dram DBI-Write Enable.
+					 * Applicable only if dramtype == LPDDR4.
+					 * This variable is used to calculate LPDDR4 mr3-OP[7] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Please refer to JEDEC JESD209-4A (LPDDR4) Spec for
+					 * definition of MR.
+					 *
+					 * Value | Description
+					 *   --- | ---
+					 *   0x0 | Disabled (default)
+					 *   0x1 | Enabled
+					 */
+
+	uint32_t lp4nwr;		/*
+					 * LPDDR4 Write-Recovery for Auto- Pre-charge commands.
+					 * Applicable only if dramtype == LPDDR4.
+					 * This variable is used to calculate LPDDR4 mr1-OP[6:4] set
+					 * in the messageBlock.
+					 * The training firmware will set DRAM MR according to MR
+					 * value in the messageBlock at the end of training.
+					 * Please refer to JEDEC JESD209-4A (LPDDR4) Spec for
+					 * definition of MR.
+					 * Determine values based on your DRAM part's supported
+					 * speed and latency bin.
+					 * Default: calculated based on user_input_basic.frequency
+					 * and "JEDEC JESD209-4A (LPDDR4)" Table 28 "Read and Write
+					 * Latencies".
+					 * Lowest latency selected when more than one latency can be
+					 * used.
+					 *
+					 * Binary Value | Description
+					 * --- | ---
+					 * 000 | nWR = 6 (default)
+					 * 001 | nWR = 10
+					 * 010 | nWR = 16
+					 * 011 | nWR = 20
+					 * 100 | nWR = 24
+					 * 101 | nWR = 30
+					 * 110 | nWR = 34
+					 * 111 | nWR = 40
+					 */
+
+	uint32_t lp4lowpowerdrv;	/*
+					 * Configure output Driver in Low power mode.
+					 * Feature only supported for Hard Macro Family E (HME).
+					 * Use NMOS Pull-up for Low-Power IO.
+					 * Not valid here
+					 */
+
+	uint32_t drambyteswap;		/*
+					 * DRAM Oscillator count source mapping for skip_training.
+					 * The PHY supports swapping of DRAM oscillator count values
+					 * between paired DBytes for the purpose of tDQSDQ DRAM
+					 * Drift Compensation(DDC).
+					 * Each DByte has a register bit to control the source of
+					 * the oscillator count value used to perform tDQSDQ Drift
+					 * compensation.
+					 * On silicon the training firmware will determine the DByte
+					 * swap and program PptCtlStatic register to select
+					 * oscillator count source. When skip_train is used,
+					 * training firmware is skipped thus manual programming may
+					 * be required depending on configuration.
+					 * The default hardware configuration is for odd Dbyte
+					 * instance n to use oscillator count values from its paired
+					 * Dbyte instance n-1. So Dbyte1 will use the oscillator
+					 * count values from Dbyte0, Dbyte3 will use Dbyte2 and so
+					 * on. This is required for DRAM Data width =16.
+					 * Each bit of this field corresponds to a DBYTE:
+					 *   - bit-0 = setting for DBYTE0
+					 *   - bit-1 = setting for DBYTE1
+					 *   - bit-2 = setting for DBYTE2
+					 *   - . . .
+					 *   - bit-n = setting for DBYTEn
+					 * By setting the associated bit for each DByte to 1, PHY
+					 * will use non-default source for count value.
+					 *   - for even Dbytes, non-default source is to use the odd
+					 *     pair count value.
+					 *   - for odd Dbytes, no-default source to use data
+					 *     received directly from the DRAM.
+					 * Byte swapping must be the same across different ranks.
+					 * Default value: 0x0
+					 * If Byte mode devices are indicated via the x8mode
+					 * messageBlock parameter, this variable is ignored as PHY
+					 * only supports a limited configuration set based on Byte
+					 * mode configuration.
+					 *
+					 * Example:
+					 * DramByteSwap = 0x03 - Dbyte0: use count values from
+					 * Dbyte1, Dbyte1 uses count values received directly
+					 * received from DRAM.
+					 * Rest of Dbytes have default source for DRAM oscilator
+					 * count.
+					 */
+
+	uint32_t rxenbackoff;		/*
+					 * Determines the Placement of PHY Read Gate signal.
+					 * Only used in LPDDR4 when lp4rxpreamblemode==0 (static
+					 * preamble) for skip_train==true.
+					 * For other dramtypes or LPDDR4-toggling-preamble no
+					 * options are available and PhyInit will set position as
+					 * required. See source code in
+					 * ddrphy_phyinit_c_initphyconfig() to see how the
+					 * RxEnBackOff register is set.
+					 * For skip_train==false, FW will set the position based on
+					 * Preamble.
+					 * We recommend keeping this setting at default value.
+					 * SI analysis is required to determine if default value
+					 * needs to be changed.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x1 | Position read gate 1UI from the first valid edge
+					 *       | of DQS_t (LPDDR4 Static preamble only) (default)
+					 */
+
+	uint32_t trainsequencectrl;	/*
+					 * Firmware Training Sequence Control.
+					 * This input is used to program sequencectrl in
+					 * messageBlock.
+					 * It controls the training stages executed by firmware.
+					 * For production silicon we recommend to use default value
+					 * programmed by PhyInit.
+					 */
+
+	uint32_t snpsumctlopt;		/*
+					 * Enable Fast Frequency Change (FFC) Optimizations
+					 * specific to UMCTL2 (DDRCTRL).
+					 * Not valid for dimmtype=NODIMM.
+					 * Consult DDRCTRL documentation in Reference Manual to
+					 * ensure when optimizations can be enabled.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 * 0 | Disable FFC MRW optimization (default)
+					 */
+
+	uint32_t snpsumctlf0rc5x;	/*
+					 * F0RX5x RCD Control Word when using Fast Frequency
+					 * Change(FFC) optimizations specific to UMCTL2
+					 * Not valid for dimmtype=NODIMM.
+					 * Only valid for when SnpsUmctlOpt=1.
+					 * When UMCTL2 optimizations are enabled PHY will perform
+					 * RCD MRW during fast frequency change request.
+					 * The correct RCD control word value for each PState must
+					 * be programmed in this field.
+					 * Consult the RCD spec and UMCTL documentation to
+					 * determine the correct value based on DRAM configuration
+					 * and operating speed.
+					 */
+
+	uint32_t txslewrisedq;		/*
+					 * Pull-up slew rate control for DBYTE Tx.
+					 * Value specified here will be written to register
+					 * TxSlewRate.TxPreP by PhyInit.
+					 * See register description for more information.
+					 */
+
+	uint32_t txslewfalldq;		/*
+					 * Pull-down slew rate control for DBYTE Tx.
+					 * Value specified here will be written to
+					 * TxSlewRate.TxPreN by PhyInit.
+					 * See register description for more information.
+					 */
+
+	uint32_t txslewriseac;		/*
+					 * Pull-up slew rate control for ANIB Tx.
+					 * Value specified here will be written to
+					 * ATxSlewRate.ATxPreP.
+					 * See register description for more information.
+					 */
+
+	uint32_t txslewfallac;		/*
+					 * Pull-down slew rate control for ANIB Tx.
+					 * Value specified here will be written to
+					 * ATxSlewRate.ATxPreN.
+					 * See register description for more information.
+					 */
+
+	uint32_t disableretraining;	/*
+					 * Disable PHY DRAM Drift compensation re-training.
+					 * Only applied to LPDDR4. No retraining is required in
+					 * DDR4/3.
+					 * Disable PHY re-training during DFI frequency change
+					 * requests in LPDDR4.
+					 * The purpose of retraining is to compensate for drift in
+					 * the DRAM.
+					 * Determine based on SI analysis and DRAM datasheet if
+					 * retraining can be disabled.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x1 | Disable retraining
+					 *   0x0 | Enable retraining
+					 */
+
+	uint32_t disablephyupdate;	/*
+					 * Disable DFI PHY Update feature.
+					 * Only effects LPDDR4.
+					 * Disable DFI PHY Update feature. When set PHY will not
+					 * assert dfi0/1_phyupd_req.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x1 | Disable DFI PHY Update
+					 *   0x0 | Enable DFI PHY Update
+					 */
+
+	uint32_t enablehighclkskewfix;	/*
+					 * Enable alternative PIE program.
+					 * If enabled the PIE reinitializes the FIFO pointers a
+					 * second time due for designs with large skew between
+					 * chiplet DfiClk branches. If enabled PIE latencies in all
+					 * protocols are increased by 60 DfiClks.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x0 | Disable (default)
+					 */
+
+	uint32_t disableunusedaddrlns;  /*
+					 * Turn off or tristate Address Lanes when possible.
+					 *
+					 * When enabled, PHY will tristate unused address lanes to
+					 * save power when possible by using Acx4AnibDis and
+					 * AForceTriCont registers.
+					 * This feature is only implemented for the default PHY
+					 * Address bump mapping and Ranks must be populated in
+					 * order. ie Rank1 cannot be used if Rank0 is unpopulated.
+					 * For alternative bump mapping follow the following
+					 * guideline to achieve maximum power savings:
+					 *   - For each unused BP_A bump program AForceTriCont[4:0]
+					 *     bits based on register description.
+					 *   - if all lanes of an Anib are unused _AND_ ANIB is not
+					 *     the first or last instance set bit associated with
+					 *     the instance in Acs4AnibDis registers. see register
+					 *     description for details.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x1 | Enable
+					 */
+
+	uint32_t phyinitsequencenum;	/*
+					 * Switches between supported phyinit training sequences.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x0 | Minimizes number of Imem/Dmem loads (default)
+					 */
+
+	uint32_t enabledficspolarityfix;/*
+					 * Enable alternative PIE program.
+					 * Set to 1 if PUB_VERSION <2.43a, otherwise set to 0. If
+					 * enabled the PIE programs Dfi{Rd,Wr}DataCsDestMap CSR's
+					 * to default values 0x00E4 before running PPT.
+					 * Before exiting PPT, PIE will restore
+					 * Dfi{Rd,Wr}DataCsDestMap CSR's to 0x00E1.
+					 *
+					 * Value | Description
+					 * ----- | ---
+					 *   0x0 | Disable (default)
+					 */
+
+	uint32_t phyvref;		/*
+					 * Must be programmed with the Vref level to be used by the
+					 * PHY during reads.
+					 * The units of this field are a percentage of VDDQ
+					 * according to the following equation:
+					 * Receiver Vref = VDDQ*phyvref[6:0]/128
+					 * For example to set Vref at 0.75*VDDQ, set this field to
+					 * 0x60.
+					 * For digital simulation, any legal value can be used. For
+					 * silicon, the users must calculate the analytical Vref by
+					 * using the impedances, terminations, and series resistance
+					 * present in the system.
+					 */
+
+	uint32_t sequencectrl;		/*
+					 * Controls the training steps to be run. Each bit
+					 * corresponds to a training step.
+					 * If the bit is set to 1, the training step will run.
+					 * If the bit is set to 0, the training step will be
+					 * skipped.
+					 * Training step to bit mapping:
+					 * sequencectrl[0] = Run DevInit - Device/phy
+					 *		     initialization. Should always be set.
+					 * sequencectrl[1] = Run WrLvl - Write leveling
+					 * sequencectrl[2] = Run RxEn - Read gate training
+					 * sequencectrl[3] = Run RdDQS1D - 1d read dqs training
+					 * sequencectrl[4] = Run WrDQ1D - 1d write dq training
+					 * sequencectrl[5] = RFU, must be zero
+					 * sequencectrl[6] = RFU, must be zero
+					 * sequencectrl[7] = RFU, must be zero
+					 * sequencectrl[8] = Run RdDeskew - Per lane read dq deskew
+					 *		     training
+					 * sequencectrl[9] = Run MxRdLat - Max read latency training
+					 * sequencectrl[10] = RFU, must be zero
+					 * sequencectrl[11] = RFU, must be zero
+					 * sequencectrl[12] = RFU, must be zero
+					 * sequencectrl[13] = RFU, must be zero
+					 * sequencectrl[15-14] = RFU, must be zero
+					 */
+};
+
+/*
+ * Structure for mode register user inputs
+ *
+ * The following data structure must be set and completed correctly so that the PhyInit software
+ * package can accurate fill message block structure.
+ * Only some mrx are used per DDR type, on related width:
+ * - DDR3: mr0..2 are used (16-bits values)
+ * - DDR4: mr0..6 are used (16-bits values)
+ * - LPDDR4: mr1..4 and mr11..22 are used (8-bits values)
+ */
+struct user_input_mode_register {
+	uint32_t mr0;
+	uint32_t mr1;
+	uint32_t mr2;
+	uint32_t mr3;
+	uint32_t mr4;
+	uint32_t mr5;
+	uint32_t mr6;
+	uint32_t mr11;
+	uint32_t mr12;
+	uint32_t mr13;
+	uint32_t mr14;
+	uint32_t mr22;
+};
+
+/*
+ * Structure for swizzle user inputs
+ *
+ * The following data structure must be set and completed correctly sothat the PhyInit software
+ * package can accurate set swizzle (IO muxing) config.
+ * Only some swizzles are used per DDR type:
+ * - DDR3/DDR4: swizzle 0..32 are used
+ *   - 26 for hwtswizzle
+ *   - 7 for acswizzle
+ * - LPDDR4:  swizzle 0..43 are used
+ *   - 8 per byte for dqlnsel (total 32)
+ *   - 6 for mapcaatodfi
+ *   - 6 for mapcabtodfi
+ */
+#define NB_HWT_SWIZZLE			26U
+#define NB_AC_SWIZZLE			7U
+#define NB_DQLNSEL_SWIZZLE_PER_BYTE	8U
+#define NB_MAPCAATODFI_SWIZZLE		6U
+#define NB_MAPCABTODFI_SWIZZLE		6U
+#define NB_SWIZZLE	44
+struct user_input_swizzle {
+	uint32_t swizzle[NB_SWIZZLE];
+};
+
+#endif /* DDRPHY_PHYINIT_STRUCT_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h
new file mode 100644
index 0000000000..8b84508da7
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_phyinit_usercustom.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_PHYINIT_USERCUSTOM_H
+#define DDRPHY_PHYINIT_USERCUSTOM_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <drivers/st/stm32mp2_ddr.h>
+
+#include <ddrphy_csr_all_cdefines.h>
+
+/* Message Block Structure Definitions */
+#if STM32MP_DDR3_TYPE
+#include <mnpmusrammsgblock_ddr3.h>
+#elif STM32MP_DDR4_TYPE
+#include <mnpmusrammsgblock_ddr4.h>
+#else /* STM32MP_LPDDR4_TYPE */
+#include <mnpmusrammsgblock_lpddr4.h>
+#endif /* STM32MP_DDR3_TYPE */
+
+/*
+ * -------------------------------------------------------------
+ * Defines for Firmware Images
+ * - indicate IMEM/DMEM address, size (bytes) and offsets.
+ * -------------------------------------------------------------
+ *
+ * IMEM_SIZE max size of instruction memory.
+ * DMEM_SIZE max size of data memory.
+ *
+ * IMEM_ST_ADDR start of IMEM address in memory.
+ * DMEM_ST_ADDR start of DMEM address in memory.
+ * DMEM_BIN_OFFSET start offset in DMEM memory (message block).
+ */
+#if STM32MP_DDR3_TYPE
+#define IMEM_SIZE			0x4C28U
+#define DMEM_SIZE			0x6C8U
+#elif STM32MP_DDR4_TYPE
+#define IMEM_SIZE			0x6D24U
+#define DMEM_SIZE			0x6CCU
+#else /* STM32MP_LPDDR4_TYPE */
+#define IMEM_SIZE			0x7E50U
+#define DMEM_SIZE			0x67CU
+#endif /* STM32MP_DDR3_TYPE */
+#define IMEM_ST_ADDR			0x50000U
+#define DMEM_ST_ADDR			0x54000U
+#define DMEM_BIN_OFFSET			0x200U
+
+/*
+ * ------------------
+ * Type definitions
+ * ------------------
+ */
+
+/* A structure used to SRAM memory address space */
+enum return_offset_lastaddr {
+	RETURN_OFFSET,
+	RETURN_LASTADDR
+};
+
+/* Enumeration of instructions for PhyInit Register Interface */
+enum reginstr {
+	STARTTRACK,	/* Start register tracking */
+	STOPTRACK,	/* Stop register tracking */
+	SAVEREGS,	/* Save(read) tracked register values */
+	RESTOREREGS,	/* Restore (write) saved register values */
+} ;
+
+/* Data structure to store register address/value pairs */
+struct reg_addr_val {
+	uint32_t	address;	/* Register address */
+	uint16_t	value;		/* Register value */
+};
+
+/* Target CSR for the impedance value for ddrphy_phyinit_mapdrvstren() */
+enum drvtype {
+	DRVSTRENFSDQP,
+	DRVSTRENFSDQN,
+	ODTSTRENP,
+	ODTSTRENN,
+	ADRVSTRENP,
+	ADRVSTRENN
+};
+
+/*
+ * -------------------------------------------------------------
+ * Fixed Function prototypes
+ * -------------------------------------------------------------
+ */
+int ddrphy_phyinit_sequence(struct stm32mp_ddr_config *config, bool skip_training, bool reten);
+int ddrphy_phyinit_restore_sequence(void);
+int ddrphy_phyinit_c_initphyconfig(struct stm32mp_ddr_config *config,
+				   struct pmu_smb_ddr_1d *mb_ddr_1d, uint32_t *ardptrinitval);
+void ddrphy_phyinit_d_loadimem(void);
+void ddrphy_phyinit_progcsrskiptrain(struct stm32mp_ddr_config *config,
+				     struct pmu_smb_ddr_1d *mb_ddr_1d, uint32_t ardptrinitval);
+int ddrphy_phyinit_f_loaddmem(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d);
+int ddrphy_phyinit_g_execfw(void);
+void ddrphy_phyinit_i_loadpieimage(struct stm32mp_ddr_config *config, bool skip_training);
+void ddrphy_phyinit_loadpieprodcode(void);
+int ddrphy_phyinit_mapdrvstren(uint32_t drvstren_ohm, enum drvtype targetcsr);
+int ddrphy_phyinit_calcmb(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d);
+void ddrphy_phyinit_writeoutmem(uint32_t *mem, uint32_t mem_offset, uint32_t mem_size);
+void ddrphy_phyinit_writeoutmsgblk(uint16_t *mem, uint32_t mem_offset, uint32_t mem_size);
+int ddrphy_phyinit_isdbytedisabled(struct stm32mp_ddr_config *config,
+				   struct pmu_smb_ddr_1d *mb_ddr_1d, uint32_t dbytenumber);
+int ddrphy_phyinit_trackreg(uint32_t adr);
+int ddrphy_phyinit_reginterface(enum reginstr myreginstr, uint32_t adr, uint16_t dat);
+
+void ddrphy_phyinit_usercustom_custompretrain(struct stm32mp_ddr_config *config);
+int ddrphy_phyinit_usercustom_g_waitfwdone(void);
+int ddrphy_phyinit_usercustom_saveretregs(struct stm32mp_ddr_config *config);
+
+#endif /* DDRPHY_PHYINIT_USERCUSTOM_H */
diff --git a/drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h b/drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h
new file mode 100644
index 0000000000..165aeaed97
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/include/ddrphy_wrapper.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DDRPHY_WRAPPER_H
+#define DDRPHY_WRAPPER_H
+
+static inline long long fmodll(long long x, long long y)
+{
+	return x - ((x / y) * y);
+}
+
+static inline int fmodi(int x, int y)
+{
+	return (int)fmodll((long long)x, (long long)y);
+}
+
+#endif /* DDRPHY_WRAPPER_H */
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c
new file mode 100644
index 0000000000..580e909a87
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c
@@ -0,0 +1,1142 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <ddrphy_phyinit.h>
+#include <ddrphy_wrapper.h>
+
+#include <platform_def.h>
+
+/*
+ * Program txslewrate:
+ * - txslewrate::txpredrvmode is dependent on dramtype.
+ * - txslewrate::txprep and txslewrate::txpren are technology-specific.
+ */
+static void txslewrate_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t txpredrvmode;
+	uint32_t byte;
+	uint32_t txpren; /* Default to 0xf (max). Optimal setting is technology specific */
+	uint32_t txprep; /* Default to 0xf (max). Optimal setting is technology specific */
+	uint16_t txslewrate;
+
+#if STM32MP_DDR3_TYPE
+	txpredrvmode = 0x3U;
+#elif STM32MP_DDR4_TYPE
+	txpredrvmode = 0x2U;
+#else /* STM32MP_LPDDR4_TYPE */
+	txpredrvmode = 0x1U;
+#endif /* STM32MP_DDR3_TYPE */
+
+	txprep = config->uia.txslewrisedq;
+	txpren = config->uia.txslewfalldq;
+
+	txslewrate = (uint16_t)((txpredrvmode << CSR_TXPREDRVMODE_LSB) |
+				(txpren << CSR_TXPREN_LSB) |
+				(txprep << CSR_TXPREP_LSB));
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t lane;
+
+		c_addr = byte << 12;
+		for (lane = 0U; lane <= B_MAX; lane++) {
+			uint32_t b_addr;
+
+			b_addr = lane << 8;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDBYTE | c_addr | b_addr |
+									CSR_TXSLEWRATE_ADDR))),
+				      txslewrate);
+		}
+	}
+}
+
+/*
+ * Program atxslewrate:
+ * - atxslewrate::atxpredrvmode is dependent on dramtype and whether
+ *   the ACX4 instance is used for AC or CK.
+ * - atxslewrate::atxprep and atxslewrate::atxpren are technology-specific.
+ */
+static void atxslewrate_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t anib;
+	uint32_t atxpren; /* Default to 0xf (max). Optimal setting is technology specific */
+	uint32_t atxprep; /* Default to 0xf (max). Optimal setting is technology specific */
+	uint32_t ck_anib_inst[2];
+
+	atxprep = config->uia.txslewriseac;
+	atxpren = config->uia.txslewfallac;
+
+	/*
+	 * # of ANIBs      CK ANIB Instance
+	 * ACX8            ANIB 1
+	 */
+	if (config->uib.numanib == 8U) {
+		ck_anib_inst[0] = 1U;
+		ck_anib_inst[1] = 1U;
+	}
+
+	for (anib = 0U; anib < config->uib.numanib; anib++) {
+		uint32_t atxpredrvmode;
+		uint32_t c_addr;
+		uint16_t atxslewrate;
+
+		c_addr = anib << 12;
+
+		if ((anib == ck_anib_inst[0]) || (anib == ck_anib_inst[1])) {
+			/* CK ANIB instance */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			atxpredrvmode = 0x0U;
+#else /* STM32MP_LPDDR4_TYPE */
+			atxpredrvmode = 0x1U;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+		} else {
+			/* non-CK ANIB instance */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			atxpredrvmode = 0x3U;
+#else /* STM32MP_LPDDR4_TYPE */
+			atxpredrvmode = 0x1U;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+		}
+
+		atxslewrate = (uint16_t)((atxpredrvmode << CSR_ATXPREDRVMODE_LSB) |
+					 (atxpren << CSR_ATXPREN_LSB) |
+					 (atxprep << CSR_ATXPREP_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TANIB | c_addr |
+								CSR_ATXSLEWRATE_ADDR))),
+			      atxslewrate);
+	}
+}
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+/*
+ * Program dfirddatacsdestmap and dfiwrdatacsdestmap:
+ * - Dependencies: mb_ddr_1d->msgmisc[6] Determine Partial Rank Support.
+ */
+static void dfidatacsdestmap_program(struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	if ((mb_ddr_1d->msgmisc & 0x40U) != 0U) {
+		uint16_t dfirddatacsdestmap = 0xA0U;
+		uint16_t dfiwrdatacsdestmap = 0xA0U;
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER |
+								CSR_DFIRDDATACSDESTMAP_ADDR))),
+			      dfirddatacsdestmap);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER |
+								CSR_DFIWRDATACSDESTMAP_ADDR))),
+			      dfiwrdatacsdestmap);
+	}
+}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+/*
+ * Program pllctrl2:
+ * - Calculate PLL controls from frequency.
+ */
+static void pllctrl2_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t pllctrl2;
+	uint32_t halffreq = config->uib.frequency / 2U;
+
+	if (halffreq < 235U) {
+		pllctrl2 = 0x7U;
+	} else if (halffreq < 313U) {
+		pllctrl2 = 0x6U;
+	} else if (halffreq < 469U) {
+		pllctrl2 = 0xBU;
+	} else if (halffreq < 625U) {
+		pllctrl2 = 0xAU;
+	} else if (halffreq < 938U) {
+		pllctrl2 = 0x19U;
+	} else if (halffreq < 1067U) {
+		pllctrl2 = 0x18U;
+	} else {
+		pllctrl2 = 0x19U;
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_PLLCTRL2_ADDR))), pllctrl2);
+}
+
+/*
+ * Program ardptrinitval:
+ * - The values programmed here assume ideal properties of DfiClk and Pclk including:
+ *   - DfiClk skew
+ *   - DfiClk jitter
+ *   - DfiClk PVT variations
+ *   - Pclk skew
+ *   - Pclk jitter
+ *
+ * ardptrinitval Programmed differently based on PLL Bypass mode and frequency:
+ * - PLL Bypassed mode:
+ *   - For MemClk frequency > 933MHz, the valid range of ardptrinitval[3:0] is: 2-5
+ *   - For MemClk frequency < 933MHz, the valid range of ardptrinitval[3:0] is: 1-5
+ * - PLL Enabled mode:
+ *   - For MemClk frequency > 933MHz, the valid range of ardptrinitval[3:0] is: 1-5
+ *   - For MemClk frequency < 933MHz, the valid range of ardptrinitval[3:0] is: 0-5
+ */
+static void ardptrinitval_program(struct stm32mp_ddr_config *config, uint32_t *ardptrinitval)
+{
+	uint16_t regdata;
+
+	if (config->uib.frequency >= 933U) {
+		regdata = 0x2U;
+	} else {
+		regdata = 0x1U;
+	}
+
+	/* Add one UI for synchronizer on SyncBus when PLL is bypassed */
+	if (config->uib.pllbypass == 1U) {
+		regdata++;
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_ARDPTRINITVAL_ADDR))),
+		      regdata);
+
+	*ardptrinitval = (uint32_t)regdata;
+}
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Program ProcOdtCtl:
+ * - Sets procodtalwayson/procodtalwaysoff for LPDDR4 using the PIE register seq0bgpr4.
+ */
+static void procodtctl_program(void)
+{
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | C0 | CSR_SEQ0BGPR4_ADDR))), 0U);
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Program dbytedllmodecntrl:
+ * - dllrxpreamblemode
+ * Program dqspreamblecontrol:
+ * - Fields:
+ *   - twotckrxdqspre
+ *   - twotcktxdqspre
+ *   - positiondfeinit
+ *   - lp4tgltwotcktxdqspre
+ *   - lp4postambleext
+ *   - lp4sttcprebridgerxen
+ * - Dependencies:
+ *   - user_input_advanced.lp4rxpreamblemode (LPDDR4)
+ *   - user_input_advanced.lp4postambleext (LPDDR4)
+ *   - user_input_advanced.wdqsext (LPDDR4)
+ *   - user_input_advanced.d4rxpreamblelength (DDR4)
+ *   - user_input_advanced.d4txpreamblelength (DDR4)
+ */
+static void dbytedllmodecntrl_program(struct stm32mp_ddr_config *config, uint32_t *twotckrxdqspre)
+{
+	uint32_t disdllgainivseed = 1U;
+	uint32_t disdllseedsel = 0U;
+	uint32_t dllgainiv = 0x1U;
+	uint32_t dllgaintv = 0x6U;
+	uint32_t dllrxpreamblemode = 0U;
+	uint32_t lcdlseed0 = 0x21U;
+	uint32_t lp4postambleext = 0U;
+	uint32_t lp4sttcprebridgerxen = 0U;
+	uint32_t lp4tgltwotcktxdqspre = 0U;
+	uint32_t positiondfeinit;
+	uint32_t twotcktxdqspre = 0U;
+	uint32_t wdqsextension = 0U;
+	uint16_t dbytedllmodecntrl;
+	uint16_t dllgainctl;
+	uint16_t dlllockparam;
+	uint16_t dqspreamblecontrol;
+
+#if STM32MP_DDR3_TYPE
+	/* Same as default */
+	*twotckrxdqspre		= 0x0U;
+	lp4sttcprebridgerxen	= 0x0U;
+	dllrxpreamblemode	= 0x0U;
+	twotcktxdqspre		= 0x0U;
+	lp4tgltwotcktxdqspre	= 0x0U;
+	positiondfeinit		= 0x0U;
+	lp4postambleext		= 0x0U;
+#elif STM32MP_DDR4_TYPE
+	*twotckrxdqspre		= config->uia.d4rxpreamblelength;
+	lp4sttcprebridgerxen	= 0x0U;
+	dllrxpreamblemode	= 0x1U;
+	twotcktxdqspre		= config->uia.d4txpreamblelength;
+	lp4tgltwotcktxdqspre	= 0x0U;
+	positiondfeinit		= 0x2U;
+	lp4postambleext		= 0x0U;
+#else /* STM32MP_LPDDR4_TYPE */
+	/* Set to 1 if static Rx preamble */
+	*twotckrxdqspre		= (config->uia.lp4rxpreamblemode == 0U) ? 1U : 0U;
+	/* Set to 1 if static Rx preamble */
+	lp4sttcprebridgerxen	= (config->uia.lp4rxpreamblemode == 0U) ? 1U : 0U;
+	dllrxpreamblemode	= 0x1U;
+	/* Must be 2*Tck Tx preamble according to JEDEC (mr1.OP[2] = 1) */
+	twotcktxdqspre		= 0x1U;
+	/* Must be toggling Tx preamble */
+	lp4tgltwotcktxdqspre	= 0x1U;
+	positiondfeinit		= 0x0U;
+	lp4postambleext		= config->uia.lp4postambleext;
+	wdqsextension		= config->uia.wdqsext;
+#endif /* STM32MP_DDR3_TYPE */
+
+	dqspreamblecontrol = (uint16_t)((wdqsextension << CSR_WDQSEXTENSION_LSB) |
+					(lp4sttcprebridgerxen << CSR_LP4STTCPREBRIDGERXEN_LSB) |
+					(lp4postambleext << CSR_LP4POSTAMBLEEXT_LSB) |
+					(lp4tgltwotcktxdqspre << CSR_LP4TGLTWOTCKTXDQSPRE_LSB) |
+					(positiondfeinit << CSR_POSITIONDFEINIT_LSB) |
+					(twotcktxdqspre << CSR_TWOTCKTXDQSPRE_LSB) |
+					(*twotckrxdqspre << CSR_TWOTCKRXDQSPRE_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DQSPREAMBLECONTROL_ADDR))),
+		      dqspreamblecontrol);
+
+	dbytedllmodecntrl = (uint16_t)(dllrxpreamblemode << CSR_DLLRXPREAMBLEMODE_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DBYTEDLLMODECNTRL_ADDR))),
+		      dbytedllmodecntrl);
+
+	dllgainctl = (uint16_t)(dllgainiv | (dllgaintv << CSR_DLLGAINTV_LSB));
+	dlllockparam = (uint16_t)(disdllseedsel | (disdllgainivseed << CSR_DISDLLGAINIVSEED_LSB) |
+				  (lcdlseed0 << CSR_LCDLSEED0_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DLLLOCKPARAM_ADDR))),
+		      dlllockparam);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DLLGAINCTL_ADDR))),
+		      dllgainctl);
+}
+
+/*
+ * Program procodttimectl:
+ * - Fields:
+ *   - POdtStartDelay[3:2]
+ *   - POdtTailWidth[1:0]
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ *   - user_input_advanced.wdqsext
+ */
+static void procodttimectl_program(struct stm32mp_ddr_config *config, uint32_t twotckrxdqspre)
+{
+	uint16_t procodttimectl;
+
+	if (config->uia.wdqsext != 0U) {
+		/* POdtStartDelay = 0x0 and  POdtTailWidth  = 0x3 */
+		procodttimectl = 0x3U;
+	} else if (config->uib.frequency <= 933U) {
+		/* Memclk Freq <= 933MHz: POdtStartDelay = 0x2 and POdtTailWidth  = 0x2 */
+		procodttimectl = 0xAU;
+	} else if (config->uib.frequency <= 1200U) {
+		/* 933MHz < Memclk Freq <= 1200MHz */
+		if (twotckrxdqspre == 1U) {
+			/* POdtStartDelay = 0x0 and  POdtTailWidth  = 0x2 */
+			procodttimectl = 0x2U;
+		} else {
+			/* POdtStartDelay = 0x1 and POdtTailWidth  = 0x2 */
+			procodttimectl = 0x6U;
+		}
+	} else {
+		/* Memclk Freq > 1200MHz */
+		if (twotckrxdqspre == 1U) {
+			/* POdtStartDelay = 0x0 and POdtTailWidth  = 0x3 */
+			procodttimectl = 0x3U;
+		} else {
+			/* POdtStartDelay = 0x1 and POdtTailWidth  = 0x3 */
+			procodttimectl = 0x7U;
+		}
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_PROCODTTIMECTL_ADDR))),
+		      procodttimectl);
+}
+
+/*
+ * Program txodtdrvstren:
+ * - Fields:
+ *   - ODTStrenP_px[5:0]
+ *   - ODTStrenN_px[11:6]
+ * - Dependencies:
+ *   - user_input_basic.numdbyte
+ *   - user_input_advanced.odtimpedance
+ * \return 0 on success.
+ */
+static int txodtdrvstren_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t byte;
+	int odtstrenn_state;
+	int odtstrenp_state;
+	uint16_t txodtdrvstren;
+
+	odtstrenp_state = ddrphy_phyinit_mapdrvstren(config->uia.odtimpedance, ODTSTRENP);
+	if (odtstrenp_state < 0) {
+		return odtstrenp_state;
+	}
+
+	odtstrenn_state = ddrphy_phyinit_mapdrvstren(config->uia.odtimpedance, ODTSTRENN);
+	if (odtstrenn_state < 0) {
+		return odtstrenn_state;
+	}
+
+	txodtdrvstren = (uint16_t)((odtstrenn_state << CSR_ODTSTRENN_LSB) | odtstrenp_state);
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t lane;
+
+		c_addr = byte << 12;
+		for (lane = 0U; lane <= B_MAX; lane++) {
+			uint32_t b_addr;
+
+			b_addr = lane << 8;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDBYTE | c_addr | b_addr |
+									CSR_TXODTDRVSTREN_ADDR))),
+				      txodtdrvstren);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Program tximpedancectrl1:
+ * - Fields:
+ *   - DrvStrenFSDqP[5:0]
+ *   - DrvStrenFSDqN[11:6]
+ * - Dependencies:
+ *   - user_input_basic.numdbyte
+ *   - user_input_advanced.tximpedance
+ * \return 0 on success.
+ */
+static int tximpedancectrl1_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t byte;
+	int drvstrenfsdqn_state;
+	int drvstrenfsdqp_state;
+	uint16_t tximpedancectrl1;
+
+	drvstrenfsdqp_state = ddrphy_phyinit_mapdrvstren(config->uia.tximpedance,
+							 DRVSTRENFSDQP);
+	if (drvstrenfsdqp_state < 0) {
+		return drvstrenfsdqp_state;
+	}
+
+	drvstrenfsdqn_state = ddrphy_phyinit_mapdrvstren(config->uia.tximpedance,
+							 DRVSTRENFSDQN);
+	if (drvstrenfsdqn_state < 0) {
+		return drvstrenfsdqn_state;
+	}
+
+	tximpedancectrl1 = (uint16_t)((drvstrenfsdqn_state << CSR_DRVSTRENFSDQN_LSB) |
+				      (drvstrenfsdqp_state << CSR_DRVSTRENFSDQP_LSB));
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t lane;
+
+		c_addr = byte << 12;
+		for (lane = 0U; lane <= B_MAX; lane++) {
+			uint32_t b_addr;
+
+			b_addr = lane << 8;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U *
+								  (TDBYTE | c_addr | b_addr |
+								   CSR_TXIMPEDANCECTRL1_ADDR))),
+				      tximpedancectrl1);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Program atximpedance:
+ * - Fields:
+ *   - ADrvStrenP[4:0]
+ *   - ADrvStrenN[9:5]
+ * - Dependencies:
+ *   - user_input_basic.numanib
+ *   - user_input_advanced.atximpedance
+ * \return 0 on success.
+ */
+static int atximpedance_program(struct stm32mp_ddr_config *config)
+{
+	int adrvstrenn_state;
+	int adrvstrenp_state;
+	uint32_t anib;
+	uint16_t atximpedance;
+
+	adrvstrenp_state = ddrphy_phyinit_mapdrvstren(config->uia.atximpedance,
+						      ADRVSTRENP);
+	if (adrvstrenp_state < 0) {
+		return adrvstrenp_state;
+	}
+
+	adrvstrenn_state = ddrphy_phyinit_mapdrvstren(config->uia.atximpedance,
+						      ADRVSTRENN);
+	if (adrvstrenn_state < 0) {
+		return adrvstrenn_state;
+	}
+
+	atximpedance = (uint16_t)((adrvstrenn_state << CSR_ADRVSTRENN_LSB) |
+				  (adrvstrenp_state << CSR_ADRVSTRENP_LSB));
+
+	for (anib = 0U; anib < config->uib.numanib; anib++) {
+		uint32_t c_addr;
+
+		c_addr = anib << 12;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TANIB | c_addr |
+							        CSR_ATXIMPEDANCE_ADDR))),
+			      atximpedance);
+	}
+
+	return 0;
+}
+
+/*
+ * Program dfimode:
+ * - Dependencies:
+ *   - user_input_basic.dfi1exists
+ */
+static void dfimode_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t dfimode = 0x5U;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	if (config->uib.dfi1exists == 0U) {
+		dfimode = 0x1U; /* DFI1 does not physically exists */
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DFIMODE_ADDR))), dfimode);
+}
+
+/*
+ * Program dficamode:
+ * - Fields:
+ *   - DfiLp3CAMode
+ *   - DfiD4CAMode
+ *   - DfiLp4CAMode
+ *   - DfiD4AltCAMode
+ */
+static void dficamode_program(void)
+{
+	uint16_t dficamode;
+
+#if STM32MP_DDR3_TYPE
+	dficamode = 0U;
+#elif STM32MP_DDR4_TYPE
+	dficamode = 2U;
+#else /* STM32MP_LPDDR4_TYPE */
+	dficamode = 4U;
+#endif /* STM32MP_DDR3_TYPE */
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DFICAMODE_ADDR))), dficamode);
+}
+
+/*
+ * Program caldrvstr0:
+ * - Fields:
+ *   - caldrvstrpd50[3:0]
+ *   - caldrvstrpu50[7:4]
+ * - Dependencies:
+ *   - user_input_advanced.extcalresval
+ */
+static void caldrvstr0_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t caldrvstr0;
+	uint16_t caldrvstrp50 = (uint16_t)config->uia.extcalresval;
+
+	caldrvstr0 = (caldrvstrp50 << CSR_CALDRVSTRPU50_LSB) | caldrvstrp50;
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_CALDRVSTR0_ADDR))),
+		      caldrvstr0);
+}
+
+/*
+ * Program CalUclkInfo:
+ * - Impedance calibration CLK Counter.
+ * - Fields:
+ *   - caluclkticksper1us
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ */
+static void caluclkinfo_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t caluclkticksper1us_x10;
+	uint16_t caluclkticksper1us;
+
+	/* Number of DfiClk cycles per 1us */
+	caluclkticksper1us_x10 = (10U * config->uib.frequency) / 2U;
+	caluclkticksper1us = (uint16_t)(caluclkticksper1us_x10 / 10U);
+
+	if ((config->uib.frequency % 2U) != 0U) {
+		caluclkticksper1us++;
+	}
+
+	if (caluclkticksper1us < 24U) {
+		/* Minimum value of caluclkticksper1us = 24 */
+		caluclkticksper1us = 24U;
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_CALUCLKINFO_ADDR))),
+		      caluclkticksper1us);
+}
+
+/*
+ * Program Calibration CSRs based on user input
+ * - Fields:
+ *   - calinterval
+ *   - calonce
+ * - Dependencies:
+ *   - user_input_advanced.calinterval
+ *   - user_input_advanced.calonce
+ */
+static void calibration_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t calinterval;
+	uint32_t calonce;
+	uint16_t calrate;
+
+	calinterval = config->uia.calinterval;
+	calonce = config->uia.calonce;
+
+	calrate = (uint16_t)((calonce << CSR_CALONCE_LSB) | (calinterval << CSR_CALINTERVAL_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_CALRATE_ADDR))), calrate);
+}
+
+/*
+ * Program vrefinglobal:
+ * - dqdqsrcvcntrl and csrvrefinglobal to select Global VREF
+ *   from Master to be used in each DQ.
+ * - Fields:
+ *   - globalvrefinsel: Select Range of GlobalVref DAC. Default: set to 1.
+ *   - globalvrefindac: Vref level is set based on mb_ddr_1d->phyvref value.
+ *     The following formula is used to convert the phyvref into the register setting.
+ *       \f{eqnarray*}{
+ *           PhyVrefPrcnt &=& \frac{mb_ddr_1d->phyvref}{128} \\
+ *        if globalvrefinsel = 1 :
+ *           globalvrefindac &=& 1+\frac{PhyVrefPrcnt}{0.005} \\
+ *        if globalvrefinsel = 0 :
+ *           globalvrefindac &=& \frac{(PhyVrefPrcnt-0.345)}{0.005} \\
+ *           RxVref &=& (globalvrefindac == 0) ? Hi-Z : (PhyVrefPrcnt \times VDDQ)
+ *        \f}
+ *
+ * Program dqdqsrcvcntrl:
+ * - dqdqsrcvcntrl and csrvrefinglobal to select Global VREF
+ *   from Master to be used in each DQ
+ * - Fields:
+ *  - selanalogvref
+ *  - majormodedbyte
+ *  - ExtVrefRange
+ *  - DfeCtrl
+ *  - GainCurrAdj
+ * - Dependencies:
+ *   - user_input_basic.numdbyte
+ */
+static void vrefinglobal_program(struct stm32mp_ddr_config *config,
+				 struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	uint32_t majormodedbyte;
+	int32_t vref_percentvddq = (int32_t)mb_ddr_1d->phyvref * 1000 * 100 / 128;
+	uint8_t globalvrefindac = 0x0U;
+	uint8_t globalvrefinsel = 0x4U;
+	uint32_t byte;
+	uint32_t dfectrl_defval = 0U;
+	uint32_t extvrefrange_defval = 0U;
+	uint32_t gaincurradj_defval = 0xBU;
+	uint32_t selanalogvref = 1U; /* Use Global VREF from Master */
+	uint16_t dqdqsrcvcntrl;
+	uint16_t vrefinglobal;
+
+#if STM32MP_DDR3_TYPE
+	majormodedbyte = 0U;
+#elif STM32MP_DDR4_TYPE
+	majormodedbyte = 3U;
+#else /* STM32MP_LPDDR4_TYPE */
+	majormodedbyte = 2U;
+#endif /* STM32MP_DDR3_TYPE */
+
+	/* Check range1 first. Only use range0 if customer input maxes out range1. */
+	globalvrefindac = (uint8_t)((vref_percentvddq / 500) + 1);
+	if (globalvrefindac > 127U) {
+		/* Min value is 1 */
+		globalvrefindac = (uint8_t)(MAX((vref_percentvddq - 34500), 500) / 500);
+		globalvrefinsel = 0x0U;
+	}
+	globalvrefindac = MIN(globalvrefindac, (uint8_t)127);
+
+	vrefinglobal = (uint16_t)((globalvrefindac << CSR_GLOBALVREFINDAC_LSB) | globalvrefinsel);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_VREFINGLOBAL_ADDR))),
+		      vrefinglobal);
+
+	dqdqsrcvcntrl = (uint16_t)((gaincurradj_defval << CSR_GAINCURRADJ_LSB) |
+				   (majormodedbyte << CSR_MAJORMODEDBYTE_LSB) |
+				   (dfectrl_defval << CSR_DFECTRL_LSB) |
+				   (extvrefrange_defval << CSR_EXTVREFRANGE_LSB) |
+				   (selanalogvref << CSR_SELANALOGVREF_LSB));
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t lane;
+
+		c_addr = byte << 12;
+		for (lane = 0U; lane <= B_MAX; lane++) {
+			uint32_t b_addr;
+
+			b_addr = lane << 8;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDBYTE | c_addr | b_addr |
+								        CSR_DQDQSRCVCNTRL_ADDR))),
+				      dqdqsrcvcntrl);
+		}
+	}
+}
+
+/*
+ * Program dfifreqratio :
+ * - Dependencies:
+ *   - user_input_basic.dfifreqratio
+ */
+static void dfifreqratio_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t dfifreqratio;
+
+	dfifreqratio = (uint16_t)config->uib.dfifreqratio;
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DFIFREQRATIO_ADDR))),
+		      dfifreqratio);
+}
+
+/*
+ * Program tristatemodeca based on dramtype and 2T Timing
+ * - Fields:
+ *   - CkDisVal
+ *   - disdynadrtri
+ *   - ddr2tmode
+ * - Dependencies:
+ *   - user_input_advanced.is2ttiming
+ *   - user_input_advanced.disdynadrtri
+ */
+static void tristatemodeca_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t ckdisval_def;
+	uint32_t ddr2tmode;
+	uint32_t disdynadrtri;
+	uint16_t tristatemodeca;
+
+	/* CkDisVal depends on dramtype */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	ckdisval_def = 1U; /* {CLK_t,CLK_c} = 2'b00; */
+#else /* STM32MP_LPDDR4_TYPE */
+	ckdisval_def = 0U; /* {CLK_t,CLK_c} = 2'b01; */
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	disdynadrtri = config->uia.disdynadrtri;
+#else /* STM32MP_LPDDR4_TYPE */
+	disdynadrtri = 1U;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	ddr2tmode = config->uia.is2ttiming;
+
+	tristatemodeca = (uint16_t)((ckdisval_def << CSR_CKDISVAL_LSB) |
+				    (ddr2tmode << CSR_DDR2TMODE_LSB) |
+				    (disdynadrtri << CSR_DISDYNADRTRI_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_TRISTATEMODECA_ADDR))),
+		      tristatemodeca);
+}
+
+/*
+ * Program DfiXlat based on Pll Bypass Input
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ *   - user_input_basic.pllbypass
+ */
+static void dfixlat_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t loopvector;
+	uint16_t pllbypass_dat = 0U;
+	uint16_t skipddc_dat = 0U;	/*
+					 * Set to vector offset based on frequency to disable dram
+					 * drift compensation.
+					 */
+
+	pllbypass_dat |= (uint16_t)config->uib.pllbypass;
+
+	if (config->uib.frequency < 333U) {
+		skipddc_dat |= 0x5U;
+	}
+
+	for (loopvector = 0U; loopvector < 8U; loopvector++) {
+		uint16_t dfifreqxlat_dat;
+		uintptr_t reg = (uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TMASTER |
+								  (CSR_DFIFREQXLAT0_ADDR +
+								   loopvector))));
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		if (loopvector == 0U) {
+			/*
+			 * Relock DfiFreq = 00,01,02,03)  Use StartVec 5 (pll_enabled) or
+			 * StartVec 6 (pll_bypassed).
+			 */
+			dfifreqxlat_dat = pllbypass_dat + 0x5555U;
+
+			mmio_write_16(reg, dfifreqxlat_dat);
+		} else if (loopvector == 7U) {
+			/* LP3-entry DfiFreq = 1F */
+			mmio_write_16(reg, 0xF000U);
+		} else {
+			/*
+			 * Everything else = skip retrain  (could also map to 0000 since retrain
+			 * code is excluded, but this is cleaner).
+			 */
+			mmio_write_16(reg, 0x5555U);
+		}
+#else /* STM32MP_LPDDR4_TYPE */
+		if (loopvector == 0U) {
+			/*
+			 * Retrain & Relock DfiFreq = 00,01,02,03)  Use StartVec 0 (pll_enabled) or
+			 * StartVec 1 (pll_bypassed).
+			 */
+			dfifreqxlat_dat = pllbypass_dat + skipddc_dat;
+			mmio_write_16(reg, dfifreqxlat_dat);
+		} else if (loopvector == 2U) {
+			/*
+			 * Retrain only DfiFreq = 08,09,0A,0B)  Use StartVec 4 (1, and maybe 2,3,
+			 * used by verif).
+			 */
+			mmio_write_16(reg, 0x4444U);
+		} else if (loopvector == 3U) {
+			/* Phymstr type state change, StartVec 8 */
+			mmio_write_16(reg, 0x8888U);
+		} else if (loopvector == 4U) {
+			/*
+			 * Relock only DfiFreq = 10,11,12,13   Use StartVec 5 (pll_enabled) or
+			 * StartVec 6 (pll_bypassed).
+			 */
+			dfifreqxlat_dat = pllbypass_dat + 0x5555U;
+			mmio_write_16(reg, dfifreqxlat_dat);
+		} else if (loopvector == 7U) {
+			/* LP3-entry DfiFreq = 1F */
+			mmio_write_16(reg, 0xF000U);
+		} else {
+			/* Everything else */
+			mmio_write_16(reg, 0x0000U);
+		}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+	}
+}
+
+/*
+ * Program dqdqsrcvcntrl1 (Receiver Powerdown) and DbyteMiscMode
+ * - see function ddrphy_phyinit_isdbytedisabled() to determine
+ *   which DBytes are turned off completely based on PHY configuration.
+ * - Fields:
+ *   - DByteDisable
+ *   - PowerDownRcvr
+ *   - PowerDownRcvrDqs
+ *   - RxPadStandbyEn
+ * - Dependencies:
+ *   - user_input_basic.numdbyte
+ *   - user_input_basic.dramdatawidth (DDR3/DDR4)
+ *   - mb_ddr_1d->mr5 (DDR4)
+ *   - user_input_advanced.lp4dbird (LPDDR4)
+ */
+static void dqdqsrcvcntrl1_program(struct stm32mp_ddr_config *config,
+				   struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	uint32_t d;
+	uint16_t mr5 __unused;
+	uint16_t regdata;
+	uint16_t regdata1;
+	uint16_t regdata2; /* Turn off Rx of DBI lane */
+
+	regdata = 0x1U << CSR_DBYTEDISABLE_LSB;
+
+	regdata1 = (0x1FFU << CSR_POWERDOWNRCVR_LSB) |
+		   (0x1U << CSR_POWERDOWNRCVRDQS_LSB) |
+		   (0x1U << CSR_RXPADSTANDBYEN_LSB);
+
+	regdata2 = (0x100U << CSR_POWERDOWNRCVR_LSB) | CSR_RXPADSTANDBYEN_MASK;
+
+#if STM32MP_DDR4_TYPE
+	/* OR all mr4 masked values, to help check in next loop */
+	mr5 = (mb_ddr_1d->mr5 >> 12) & 0x1U;
+#endif /* STM32MP_DDR4_TYPE */
+
+	for (d = 0U; d < config->uib.numdbyte; d++) {
+		uint32_t c_addr;
+
+		c_addr = d * C1;
+		if (ddrphy_phyinit_isdbytedisabled(config, mb_ddr_1d, d) != 0) {
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								        CSR_DBYTEMISCMODE_ADDR))),
+				      regdata);
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								        CSR_DQDQSRCVCNTRL1_ADDR))),
+				      regdata1);
+		} else {
+			/* Disable RDBI lane if not used. */
+#if STM32MP_DDR3_TYPE
+			if (config->uib.dramdatawidth != 4U) {
+#elif STM32MP_DDR4_TYPE
+			if ((config->uib.dramdatawidth != 4U) && (mr5 == 0U)) {
+#else /* STM32MP_LPDDR4_TYPE */
+			if (config->uia.lp4dbird == 0U) {
+#endif /* STM32MP_DDR3_TYPE */
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								     CSR_DQDQSRCVCNTRL1_ADDR))),
+					      regdata2);
+			}
+		}
+	}
+}
+
+/*
+ * Program masterx4config
+ * - Fields:
+ *   - x4tg
+ *   - masterx4config
+ * - Dependencies:
+ *   - user_input_basic.dramdatawidth
+ *
+ * \note PHY does not support mixed dram device data width
+ */
+static void masterx4config_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t x4tg = 0U;
+	uint16_t masterx4config;
+
+	if (config->uib.dramdatawidth == 4U) {
+		x4tg = 0xFU;
+	}
+
+	masterx4config = (uint16_t)(x4tg << CSR_X4TG_LSB);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_MASTERX4CONFIG_ADDR))),
+		      masterx4config);
+}
+
+#if !STM32MP_DDR3_TYPE
+/*
+ * Program dmipinpresent based on dramtype and Read-DBI enable
+ * - Fields:
+ *   - RdDbiEnabled
+ * - Dependencies:
+ *   - mb_ddr_1d->mr5 (DDR4)
+ *   - user_input_advanced.lp4dbird (LPDDR4)
+ */
+static void dmipinpresent_program(struct stm32mp_ddr_config *config,
+				  struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	uint16_t dmipinpresent;
+
+#if STM32MP_DDR4_TYPE
+	/* For DDR4, Read DBI is enabled in mr5-A12 */
+	dmipinpresent = (mb_ddr_1d->mr5 >> 12) & 0x1U;
+#else /* STM32MP_LPDDR4_TYPE */
+	dmipinpresent = (uint16_t)config->uia.lp4dbird;
+#endif /* STM32MP_DDR4_TYPE */
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DMIPINPRESENT_ADDR))),
+		      dmipinpresent);
+}
+#endif /* !STM32MP_DDR3_TYPE */
+
+/*
+ * Program aforcetricont and acx4anibdis
+ * - Fields:
+ *   - aforcetricont
+ *   - acx4anibdis
+ * - Dependencies:
+ *   - user_input_basic.numrank_dfi0
+ *   - user_input_basic.numrank_dfi1
+ *   - user_input_basic.numanib
+ *   - user_input_advanced.disableunusedaddrlns
+ */
+static void aforcetricont_acx4anibdis_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t anib;
+	uint16_t acx4anibdis = 0x0U;
+
+	for (anib = 0U; (anib < config->uib.numanib) && (config->uia.disableunusedaddrlns != 0U);
+	     anib++) {
+		uint32_t c_addr;
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		uint32_t numrank = config->uib.numrank_dfi0 + config->uib.numrank_dfi1;
+#else /* STM32MP_LPDDR4_TYPE */
+		uint32_t numrank0 = config->uib.numrank_dfi0;
+		uint32_t numrank1 = config->uib.numrank_dfi1;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+		uint16_t aforcetricont = 0x0U;
+
+		c_addr = anib << 12;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+		if ((anib == 0U) && (numrank == 1U)) {
+			aforcetricont = 0x2U;
+		} else if ((anib == 1U) && (numrank == 1U)) {
+			aforcetricont = 0xCU;
+		} else if (anib == 6U) {
+			aforcetricont = 0x1U;
+		}
+#else /* STM32MP_LPDDR4_TYPE */
+		if ((anib == 0U) && (numrank0 == 0U)) {
+			aforcetricont = 0xFU;
+		} else if ((anib == 0U) && (numrank0 == 1U)) {
+			aforcetricont = 0x2U;
+		} else if ((anib == 1U) && (numrank0 == 0U)) {
+			aforcetricont = 0xFU;
+		} else if ((anib == 1U) && (numrank0 == 1U)) {
+			aforcetricont = 0x8U;
+		} else if ((anib == 2U) && (numrank0 == 0U)) {
+			aforcetricont = 0xFU;
+		} else if ((anib == 3U) && (numrank1 == 0U)) {
+			aforcetricont = 0xFU;
+		} else if ((anib == 3U) && (numrank1 == 1U)) {
+			aforcetricont = 0x2U;
+		} else if ((anib == 4U) && (numrank1 == 0U)) {
+			aforcetricont = 0xFU;
+		} else if ((anib == 4U) && (numrank1 == 1U)) {
+			aforcetricont = 0x8U;
+		} else if ((anib == 5U) && (numrank1 == 0U)) {
+			aforcetricont = 0xFU;
+		} else if (anib == 6U) {
+			aforcetricont = 0xFU;
+		} else if (anib == 7U) {
+			aforcetricont = 0xFU;
+		}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+		/*
+		 * If all the lanes can be disabled, and Anib is not the first or last disable
+		 * entire chiplet
+		 */
+		if ((aforcetricont == 0xFU) && (anib != 0U) &&
+		    (anib != (config->uib.numanib - 1U))) {
+			acx4anibdis = acx4anibdis | (0x1U << anib);
+		}
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TANIB | c_addr |
+							        CSR_AFORCETRICONT_ADDR))),
+			      aforcetricont);
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_ACX4ANIBDIS_ADDR))),
+		      acx4anibdis);
+}
+
+/*
+ * Implements Step C of initialization sequence
+ *
+ * This function programs majority of PHY configuration registers based
+ * on data input into PhyInit data structures.
+ *
+ * This function programs PHY configuration registers based on information
+ * provided in the PhyInit data structures (config->uib, config->uia).
+ * The user can overwrite the programming of this function by modifying
+ * ddrphy_phyinit_usercustom_custompretrain().  Please see
+ * ddrphy_phyinit_struct.h for PhyInit data structure definition.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_c_initphyconfig(struct stm32mp_ddr_config *config,
+				   struct pmu_smb_ddr_1d *mb_ddr_1d, uint32_t *ardptrinitval)
+{
+	uint32_t twotckrxdqspre;
+	int ret;
+
+	/*
+	 * Step (C) Initialize PHY Configuration
+	 * Load the required PHY configuration registers for the appropriate mode and memory
+	 * configuration.
+	 */
+
+	VERBOSE("%s Start\n", __func__);
+
+	txslewrate_program(config);
+
+	atxslewrate_program(config);
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	dfidatacsdestmap_program(mb_ddr_1d);
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	pllctrl2_program(config);
+
+	ardptrinitval_program(config, ardptrinitval);
+
+#if STM32MP_LPDDR4_TYPE
+	procodtctl_program();
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	dbytedllmodecntrl_program(config, &twotckrxdqspre);
+
+	procodttimectl_program(config, twotckrxdqspre);
+
+	ret = txodtdrvstren_program(config);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = tximpedancectrl1_program(config);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = atximpedance_program(config);
+	if (ret != 0) {
+		return ret;
+	}
+
+	dfimode_program(config);
+
+	dficamode_program();
+
+	caldrvstr0_program(config);
+
+	caluclkinfo_program(config);
+
+	calibration_program(config);
+
+	vrefinglobal_program(config, mb_ddr_1d);
+
+	dfifreqratio_program(config);
+
+	tristatemodeca_program(config);
+
+	dfixlat_program(config);
+
+	dqdqsrcvcntrl1_program(config, mb_ddr_1d);
+
+	masterx4config_program(config);
+
+#if !STM32MP_DDR3_TYPE
+	dmipinpresent_program(config, mb_ddr_1d);
+
+#if STM32MP_LPDDR4_TYPE
+	/*
+	 * Program DFIPHYUPD
+	 * - Fields:
+	 *   - DFIPHYUPDMODE
+	 *   - DFIPHYUPDCNT
+	 * - Dependencies:
+	 *   - user_input_advanced.disablephyupdate
+	 */
+	if (config->uia.disablephyupdate != 0U) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DFIPHYUPD_ADDR))),
+			      0x0U);
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+#endif /* !STM32MP_DDR3_TYPE */
+
+	aforcetricont_acx4anibdis_program(config);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c
new file mode 100644
index 0000000000..1d42e980e5
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Reads PhyInit inputs structures and sets relevant message block
+ * parameters.
+ *
+ * This function sets Message Block parameters based on user_input_basic and
+ * user_input_advanced. user changes in these files takes precedence
+ * over this function call.
+ *
+ * MessageBlock fields set :
+ *  - dramtype
+ *  - pstate
+ *  - dramfreq
+ *  - pllbypassen
+ *  - dfifreqratio
+ *  - phyodtimpedance
+ *  - phydrvimpedance
+ *  - bpznresval
+ *  - enableddqscha (LPDDR4)
+ *  - cspresentcha (LPDDR4)
+ *  - enableddqsChb (LPDDR4)
+ *  - cspresentchb (LPDDR4)
+ *  - enableddqs (DDR3/DDR4)
+ *  - phycfg (DDR3/DDR4)
+ *  - x16present (DDR4)
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_calcmb(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	uint32_t nad0 = config->uib.numactivedbytedfi0;
+	uint32_t nad1 = 0;
+	uint16_t mr4 __unused;
+	uint16_t disableddbyte __unused;
+	uint32_t dbyte __unused;
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+#if STM32MP_LPDDR4_TYPE
+	nad1 = config->uib.numactivedbytedfi1;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/* A few checks to make sure valid programming */
+	if ((nad0 <= 0U) || (nad1 < 0U) || (config->uib.numdbyte <= 0U)) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s numactivedbytedfi0, numactivedbytedfi0, NumByte out of range.\n",
+		      __func__);
+		return -1;
+	}
+
+	if ((nad0 + nad1) > config->uib.numdbyte) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s numactivedbytedfi0+numactivedbytedfi1 is larger than numdbyteDfi0\n",
+		      __func__);
+		return -1;
+	}
+
+	if ((config->uib.dfi1exists == 0U) && (nad1 != 0U)) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s dfi1exists==0 but numdbyteDfi0 != 0\n", __func__);
+		return -1;
+	}
+
+#if STM32MP_DDR4_TYPE
+	/* OR all mr4 masked values, to help check in next loop */
+	mr4 = mb_ddr_1d->mr4 & 0x1C0U;
+
+	/* 1D message block defaults */
+	if (mr4 != 0x0U) {
+		ERROR("mr4 != 0x0\n");
+		VERBOSE("%s Setting DRAM CAL mode is not supported by the PHY.\n", __func__);
+		VERBOSE("Memory controller may set CAL mode after PHY has entered mission\n");
+		VERBOSE("mode. Please check value programmed in mb_ddr_1d[*].mr4\n");
+		VERBOSE("and unset A8:6\n");
+		return -1;
+	}
+#endif /* STM32MP_DDR4_TYPE */
+
+#if STM32MP_DDR3_TYPE
+	if (config->uib.dimmtype == DDR_DIMMTYPE_NODIMM) {
+		ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_DRAMTYPE, 0x1U);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+#elif STM32MP_DDR4_TYPE
+	if (config->uib.dimmtype == DDR_DIMMTYPE_NODIMM) {
+		ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_DRAMTYPE, 0x2U);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+#else /* STM32MP_LPDDR4_TYPE */
+	/* Nothing to do */
+#endif /* STM32MP_DDR3_TYPE */
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_PSTATE, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_DRAMFREQ, config->uib.frequency * 2U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_PLLBYPASSEN, config->uib.pllbypass);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (config->uib.dfifreqratio == 1U) {
+		ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_DFIFREQRATIO, 0x2U);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_PHYODTIMPEDANCE, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_PHYDRVIMPEDANCE, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_BPZNRESVAL, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_ENABLEDDQS, nad0 * 8U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	disableddbyte = 0x0U;
+
+	for (dbyte = 0U; (dbyte < config->uib.numdbyte) && (dbyte < 8U); dbyte++) {
+		if (ddrphy_phyinit_isdbytedisabled(config, mb_ddr_1d, dbyte) != 0) {
+			disableddbyte |= 0x1U << dbyte;
+		}
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_DISABLEDDBYTE, disableddbyte);
+	if (ret != 0) {
+		return ret;
+	}
+
+#if STM32MP_DDR3_TYPE
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_PHYCFG, config->uia.is2ttiming);
+	if (ret != 0) {
+		return ret;
+	}
+#else /* STM32MP_DDR4_TYPE */
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_PHYCFG,
+				       ((mb_ddr_1d->mr3 & 0x8U) != 0U) ?
+				       0U : config->uia.is2ttiming);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_X16PRESENT,
+				       (0x10U == config->uib.dramdatawidth) ?
+				       mb_ddr_1d->cspresent : 0x0U);
+	if (ret != 0) {
+		return ret;
+	}
+#endif /* STM32MP_DDR3_TYPE */
+#else /* STM32MP_LPDDR4_TYPE */
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_ENABLEDDQSCHA, nad0 * 8U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_CSPRESENTCHA,
+				       (2U == config->uib.numrank_dfi0) ?
+				       0x3U : config->uib.numrank_dfi0);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_ENABLEDDQSCHB, nad1 * 8U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_softsetmb(mb_ddr_1d, MB_FIELD_CSPRESENTCHB,
+				       (2U == config->uib.numrank_dfi1) ?
+				       0x3U : config->uib.numrank_dfi1);
+	if (ret != 0) {
+		return ret;
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c
new file mode 100644
index 0000000000..f2378f2fdc
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function loads the training firmware IMEM image into the PHY.
+ *
+ * This function reads the DDR firmware source memory area to generate a
+ * set of apb writes to load IMEM image into the PHY. The exact steps in this
+ * function are as follows:
+ *
+ * -# Ensure DRAM is in reset.
+ * -# Load the microcontroller memory with the provided training firmware
+ * -# Initialize the firmware mailbox structures to be able to communicate with
+ * the firmware.
+ *
+ * \return void
+ */
+void ddrphy_phyinit_d_loadimem(void)
+{
+	uint16_t memresetl;
+	uint32_t *ptr32;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/* Set memresetl to avoid glitch on BP_MemReset_L during training */
+	memresetl = CSR_PROTECTMEMRESET_MASK;
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_MEMRESETL_ADDR))), memresetl);
+
+	ptr32 = (uint32_t *)(STM32MP_DDR_FW_BASE + STM32MP_DDR_FW_IMEM_OFFSET);
+	ddrphy_phyinit_writeoutmem(ptr32, IMEM_ST_ADDR, IMEM_SIZE);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c
new file mode 100644
index 0000000000..fc268e456c
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function loads the training firmware DMEM image and write the
+ * Message Block parameters for the training firmware into the PHY.
+ *
+ * This function performs the following tasks:
+ *
+ * -# Load the firmware DMEM segment to initialize the data structures from the
+ * DDR firmware source memory area.
+ * -# Write the Firmware Message Block with the required contents detailing the training parameters.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_f_loaddmem(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	uint32_t sizeofmsgblk;
+	uint16_t *ptr16;
+	uint32_t *ptr32;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/* Some basic checks on MessageBlock */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	if ((mb_ddr_1d->enableddqs > (8U * (uint8_t)config->uib.numactivedbytedfi0)) ||
+	    (mb_ddr_1d->enableddqs <= 0U)) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s enableddqs is Zero or greater than NumActiveDbytes for Dfi0\n",
+			__func__);
+		return -1;
+	}
+#else /* STM32MP_LPDDR4_TYPE */
+	if (((mb_ddr_1d->enableddqscha % 16U) != 0U) || ((mb_ddr_1d->enableddqschb % 16U) != 0U)) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s Lp3/Lp4 - Number of Dq's Enabled per Channel much be multipe of 16\n",
+		      __func__);
+		return -1;
+	}
+
+	if ((mb_ddr_1d->enableddqscha > (uint8_t)(8U * config->uib.numactivedbytedfi0)) ||
+	    (mb_ddr_1d->enableddqschb > (uint8_t)(8U * config->uib.numactivedbytedfi1)) ||
+	    ((mb_ddr_1d->enableddqscha == 0U) && (mb_ddr_1d->enableddqschb == 0U))) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s EnabledDqsChA/B are not set correctly./1\n", __func__);
+		return -1;
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	sizeofmsgblk = sizeof(struct pmu_smb_ddr_1d);
+
+	ptr16 = (uint16_t *)mb_ddr_1d;
+	ddrphy_phyinit_writeoutmsgblk(ptr16, DMEM_ST_ADDR, sizeofmsgblk);
+
+	ptr32 = (uint32_t *)(STM32MP_DDR_FW_BASE + STM32MP_DDR_FW_DMEM_OFFSET);
+	ddrphy_phyinit_writeoutmem(ptr32, DMEM_ST_ADDR + DMEM_BIN_OFFSET,
+				   DMEM_SIZE - STM32MP_DDR_FW_DMEM_OFFSET);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c
new file mode 100644
index 0000000000..23f19ea2f2
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * Execute the Training Firmware
+ *
+ * The training firmware is executed with the procedure:
+ *
+ * -# Reset the firmware microcontroller by writing the MicroReset register to
+ * set the StallToMicro and ResetToMicro fields to 1 (all other fields should be
+ * zero). Then rewrite the registers so that only the StallToMicro remains set
+ * (all other fields should be zero).
+ * -# Begin execution of the training firmware by setting the MicroReset
+ * register to 0.
+ * -# Wait for the training firmware to complete by following the procedure implemented in
+ * ddrphy_phyinit_usercustom_g_waitfwdone() function.
+ * -# Halt the microcontroller.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_g_execfw(void)
+{
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * 1. Reset the firmware microcontroller by writing the MicroReset CSR to set the
+	 * StallToMicro and ResetToMicro fields to 1 (all other fields should be zero).
+	 * Then rewrite the CSR so that only the StallToMicro remains set (all other fields should
+	 * be zero).
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      CSR_STALLTOMICRO_MASK);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICRORESET_ADDR))),
+		      CSR_RESETTOMICRO_MASK | CSR_STALLTOMICRO_MASK);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICRORESET_ADDR))),
+		      CSR_STALLTOMICRO_MASK);
+
+	/* 2. Begin execution of the training firmware by setting the MicroReset CSR to 0 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICRORESET_ADDR))), 0x0U);
+
+	/*
+	 * 3. Wait for the training firmware to complete by following the procedure
+	 * implemented in ddrphy_phyinit_usercustom_g_waitfwdone() function.
+	 */
+	ret = ddrphy_phyinit_usercustom_g_waitfwdone();
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* 4. Halt the microcontroller */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICRORESET_ADDR))),
+		      CSR_STALLTOMICRO_MASK);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c
new file mode 100644
index 0000000000..cac7b640a2
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c
@@ -0,0 +1,397 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Program DfiWrRdDataCsConfig
+ * - Fields:
+ *   - dfiwrdatacspolarity
+ *   - dfirddatacspolarity
+ */
+static void dfiwrrddatacsconfig_program(void)
+{
+	uint16_t dfiwrdatacspolarity;
+	uint16_t dfirddatacspolarity;
+
+	/*
+	 * DfiWrRdDataCsConfig : dfiwrdatacspolarity=0x1 and dfirddatacspolarity=0x1.
+	 * Set DataCsPolarity bits to enable active high
+	 */
+	dfiwrdatacspolarity = 0x1U;
+	dfirddatacspolarity = 0x1U;
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | C0 |
+							CSR_DFIWRRDDATACSCONFIG_ADDR))),
+		      (dfiwrdatacspolarity << CSR_DFIWRDATACSPOLARITY_LSB) |
+		      (dfirddatacspolarity << CSR_DFIRDDATACSPOLARITY_LSB));
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Registers: Seq0BDLY0, Seq0BDLY1, Seq0BDLY2, Seq0BDLY3
+ * - Program PIE instruction delays
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ */
+static void seq0bdly_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t lowfreqopt __unused;
+	uint16_t dfifrq_x10;
+	uint16_t pscount_ref;
+	uint16_t pscount[4]; /* Need delays for 0.5us, 1us, 10us, and 25us */
+
+	/*
+	 * Calculate the counts to obtain the correct delay for each frequency
+	 * Need to divide by 4 since the delay value are specified in units of
+	 * 4 clocks.
+	 */
+	dfifrq_x10 = (10U * (uint16_t)config->uib.frequency) / 2U;
+	pscount_ref = dfifrq_x10 / 4U;
+	pscount[0] = pscount_ref / (2U * 10U);
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	if (config->uib.frequency < 400U) {
+		lowfreqopt = 3U;
+	} else if (config->uib.frequency < 533U) {
+		lowfreqopt = 11U;
+	} else {
+		lowfreqopt = 0U;
+	}
+
+	pscount[1] = (pscount_ref / 10U) - lowfreqopt;
+#else /* STM32MP_LPDDR4_TYPE */
+	pscount[1] = pscount_ref / 10U;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+	pscount[2] = pscount_ref;
+
+	if (dfifrq_x10 > 2665U) {
+		pscount[3] = 44U;
+	} else if ((dfifrq_x10 <= 2665U) && (dfifrq_x10 > 2000U)) {
+		pscount[3] = 33U;
+	} else {
+		pscount[3] = 16U;
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TMASTER | CSR_SEQ0BDLY0_ADDR))),
+		      pscount[0]);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TMASTER | CSR_SEQ0BDLY1_ADDR))),
+		      pscount[1]);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TMASTER | CSR_SEQ0BDLY2_ADDR))),
+		      pscount[2]);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TMASTER | CSR_SEQ0BDLY3_ADDR))),
+		      pscount[3]);
+}
+
+/*
+ * Registers: Seq0BDisableFlag0..7
+ * - Program PIE Instruction Disable Flags
+ * - Dependencies:
+ *   - user_input_advanced.DisableRetraining (LPDDR4)
+ *   - skip_training (LPDDR4)
+ *   - user_input_basic.frequency (LPDDR4)
+ */
+static void seq0bdisableflag_program(struct stm32mp_ddr_config *config, bool skip_training)
+{
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG0_ADDR))),
+		      0x0000U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG1_ADDR))),
+		      0x0173U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG2_ADDR))),
+		      0x0060U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG3_ADDR))),
+		      0x6110U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG4_ADDR))),
+		      0x2152U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG5_ADDR))),
+		      0xDFBDU);
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG6_ADDR))),
+		      0xFFFFU);
+#else /* STM32MP_LPDDR4_TYPE */
+	if (skip_training || (config->uia.disableretraining != 0U) ||
+	    (config->uib.frequency < 333U)) {
+		/* Disabling DRAM drift compensation */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG |
+							        CSR_SEQ0BDISABLEFLAG6_ADDR))),
+			      0xFFFFU);
+	} else {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG |
+							        CSR_SEQ0BDISABLEFLAG6_ADDR))),
+			      0x2060U);
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	/*
+	 * - Register: Seq0BGPR7
+	 *   - Program active CSx for MRS7 during D4 RDIMM frequency change
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BDISABLEFLAG7_ADDR))),
+		      0x6152U);
+}
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Registers: ppttrainsetup and ppttrainsetup2
+ * - Related to DFI PHY Master Interface (PMI).
+ * - Enable DFI PMI if training firmware was run
+ * - Fields:
+ *   - PhyMstrTrainInterval
+ *   - PhyMstrMaxReqToAck
+ *   - PhyMstrFreqOverride
+ * - Dependencies:
+ *   - user_input_basic.frequency
+ *   - user_input_advanced.PhyMstrTrainInterval
+ *   - user_input_advanced.PhyMstrMaxReqToAck
+ */
+static void ppttrainsetup_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t ppttrainsetup;
+
+	/* Enabling Phy Master Interface for DRAM drift compensation */
+	if (config->uib.frequency >= 333U) {
+		ppttrainsetup =	(uint16_t)((config->uia.phymstrtraininterval <<
+					    CSR_PHYMSTRTRAININTERVAL_LSB) |
+					   (config->uia.phymstrmaxreqtoack <<
+					    CSR_PHYMSTRMAXREQTOACK_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_PPTTRAINSETUP_ADDR))),
+			      ppttrainsetup);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER |
+								CSR_PPTTRAINSETUP2_ADDR))),
+			      0x0003U);
+	}
+}
+
+/*
+ * Registers AcsmPlayback*x*
+ * - Program Address/Command Sequence Engine (ACSM) registers with
+ *   required instructions for retraining algorithm.
+ */
+static void acsmplayback_program(void)
+{
+	uint32_t vec;
+
+	for (vec = 0U; vec < 3U; vec++) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TACSM | (CSR_ACSMPLAYBACK0X0_ADDR +
+								         (vec * 2U))))),
+			      0xE0U);
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TACSM | (CSR_ACSMPLAYBACK1X0_ADDR +
+								         (vec * 2U))))),
+			      0x12U);
+	}
+}
+
+/*
+ * Program Training Hardware Registers for mission mode retraining
+ * and DRAM drift compensation algorithm.
+ */
+static void traininghwreg_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t byte;
+
+	/* Programing Training Hardware Registers for mission mode retraining */
+
+	/*
+	 * - Register: AcsmCtrl13
+	 *   - Fields: AcsmCkeEnb
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TACSM | CSR_ACSMCTRL13_ADDR))),
+		      0xFU << CSR_ACSMCKEENB_LSB);
+
+	/*
+	 * - Register: AcsmCtrl1
+	 *   - Fields: AcsmRepCnt
+	 *             Need 19 iterations @ 0.25ui increments to cover 4.5UI
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TACSM | CSR_ACSMCTRL1_ADDR))),
+		      0xEU << CSR_ACSMREPCNT_LSB);
+
+	/*
+	 * - Register: TsmByte1, TsmByte2
+	 *   - Dependencies: config->uib.numdbyte
+	 */
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t i_addr;
+		uint16_t regdata;
+		uint32_t vec;
+
+		c_addr = byte * C1;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								CSR_TSMBYTE1_ADDR))),
+			      0x1U);   /* [15:8] gstep; [7:0]bstep; */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								CSR_TSMBYTE2_ADDR))),
+			      0x1U);   /* [15:0] good_bar; */
+
+		regdata = (CSR_DTSMSTATICCMPR_MASK | CSR_DTSMSTATICCMPRVAL_MASK);
+
+		/*
+		 * - Register: TsmByte3, TsmByte5
+		 *   - Fields:
+		 *     - DtsmStaticCmpr
+		 *     - DtsmStaticCmprVal
+		 */
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								CSR_TSMBYTE3_ADDR))),
+			      regdata);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								CSR_TSMBYTE5_ADDR))),
+			      0x1U); /* [15:0] bad_bar; */
+
+		/*
+		 * - Register: TrainingParam
+		 *   - Fields:
+		 *     - EnDynRateReduction
+		 *     - RollIntoCoarse
+		 *     - IncDecRate
+		 *     - TrainEnRxEn
+		 *   - Dependencies:
+		 *     - user_input_advanced.DisableRetraining
+		 */
+		regdata = (CSR_ENDYNRATEREDUCTION_MASK | CSR_ROLLINTOCOARSE_MASK |
+			   (0x3U << CSR_INCDECRATE_LSB));
+		regdata = config->uia.disableretraining ?
+			  regdata : (regdata | CSR_TRAINENRXEN_MASK);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+							        CSR_TRAININGPARAM_ADDR))),
+			      regdata);
+
+		/*
+		 * - Register: Tsm0
+		 *   - Fields:
+		 *     - DtsmEnb
+		 */
+		regdata = (0x1U << CSR_DTSMENB_LSB);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | I0 | TDBYTE |
+							        CSR_TSM0_ADDR))),
+			      regdata);
+
+		/*
+		 * - Register: Tsm2
+		 *   - Fields:
+		 *     - DtsmDisErrChk
+		 */
+		regdata = (0x1U << CSR_DTSMDISERRCHK_LSB);
+		for (vec = 1U; vec <= I_MAX; vec++) {
+			i_addr = vec * I1;
+			mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | i_addr | TDBYTE |
+								        CSR_TSM2_ADDR))),
+				      regdata);
+		}
+	}
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * - Register: calrate
+ *   - Fields:
+ *     - calOnce
+ *     - calinterval
+ *   - Dependencies
+ *     - user_input_advanced.calinterval
+ *     - user_input_advanced.calonce
+ */
+static void calrate_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t calinterval;
+	uint32_t calonce;
+	uint16_t calrate;
+
+	calinterval = config->uia.calinterval;
+	calonce = config->uia.calonce;
+
+	calrate = (uint16_t)((0x1U << CSR_CALRUN_LSB) | (calonce << CSR_CALONCE_LSB) |
+			     (calinterval << CSR_CALINTERVAL_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_CALRATE_ADDR))), calrate);
+}
+
+/*
+ * Loads registers after training
+ *
+ * This function programs the PHY Initialization Engine (PIE) instructions and
+ * the associated registers.
+ * Training hardware registers are also programmed to for mission mode
+ * retraining. (LPDDR4)
+ *
+ * \return void
+ */
+void ddrphy_phyinit_i_loadpieimage(struct stm32mp_ddr_config *config, bool skip_training)
+{
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+	 * This allows the memory controller unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x0U);
+
+	ddrphy_phyinit_loadpieprodcode();
+
+#if STM32MP_LPDDR4_TYPE
+	/*
+	 * No user specified EnableDfiCsPolarityFix, running with new PUB with DFI CS polarity fix
+	 * so program the data polarity CSR.
+	 */
+	dfiwrrddatacsconfig_program();
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	seq0bdly_program(config);
+
+	seq0bdisableflag_program(config, skip_training);
+
+#if STM32MP_LPDDR4_TYPE
+	if (!skip_training) {
+		ppttrainsetup_program(config);
+	}
+
+	acsmplayback_program();
+
+	traininghwreg_program(config);
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/*
+	 * - Register: CalZap
+	 *   - Prepare the calibration controller for mission mode.
+	 *     Turn on calibration and hold idle until dfi_init_start is asserted sequence is
+	 *     triggered.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_CALZAP_ADDR))), 0x1U);
+
+	calrate_program(config);
+
+	/*
+	 * At the end of this function, PHY Clk gating register UcclkHclkEnables is
+	 * set for mission mode.  Additionally APB access is Isolated by setting
+	 * MicroContMuxSel.
+	 */
+	/* Disabling Ucclk (PMU) and Hclk (training hardware) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR))),
+		      0x0U);
+
+	/* Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x1U);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c
new file mode 100644
index 0000000000..57f5c14569
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * This is used to initialize the PhyInit structures before user defaults and overrides are applied.
+ *
+ * @return Void
+ */
+void ddrphy_phyinit_initstruct(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	/*
+	 * ##############################################################
+	 * Basic Message Block Variables
+	 * ##############################################################
+	 */
+
+	uint8_t msgmisc = 0x00U;	/* For fast simulation */
+	uint8_t reserved00 = 0x0U;	/*
+					 * Set reserved00[7] = 1 (If using T28 attenuated receivers)
+					 * Set reserved00[6:0] = 0 (Reserved; must be set to 0)
+					 */
+
+	uint8_t hdtctrl = 0xFFU;
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	uint8_t cspresent = 0x01U;	/*
+					 * Indicates presence of DRAM at each chip select for PHY.
+					 *
+					 * If the bit is set to 1, the CS is connected to DRAM.
+					 * If the bit is set to 0, the CS is not connected to DRAM.
+					 *
+					 * Set cspresent[0]   = 1 (if CS0 is populated with DRAM)
+					 * Set cspresent[1]   = 1 (if CS1 is populated with DRAM)
+					 * Set cspresent[2]   = 1 (if CS2 is populated with DRAM)
+					 * Set cspresent[3]   = 1 (if CS3 is populated with DRAM)
+					 * Set cspresent[7:4] = 0 (Reserved; must be set to 0)
+					 */
+	uint8_t dfimrlmargin = 0x01U;	/* 1 is typically good in DDR3 */
+#if STM32MP_DDR3_TYPE
+	uint8_t addrmirror = 0x00U;	/*
+					 * Set addrmirror if CS is mirrored.
+					 * (typically odd CS are mirroed in DIMMs)
+					 */
+#else /* STM32MP_DDR4_TYPE */
+	uint8_t addrmirror = 0xAAU;
+#endif /* STM32MP_DDR3_TYPE */
+	uint8_t wrodtpat_rank0 = 0x01U;	/*
+					 * When Writing Rank0 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t wrodtpat_rank1 = 0x02U;	/*
+					 * When Writing Rank1 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#if STM32MP_DDR3_TYPE
+	uint8_t wrodtpat_rank2 = 0x04U;	/*
+					 * When Writing Rank2 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t wrodtpat_rank3 = 0x08U;	/*
+					 * When Writing Rank3 : Bits[3:0] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#else /* STM32MP_DDR4_TYPE */
+	uint8_t wrodtpat_rank2 = 0x00U;
+	uint8_t wrodtpat_rank3 = 0x00U;
+#endif /* STM32MP_DDR3_TYPE */
+	uint8_t rdodtpat_rank0 = 0x20U;	/*
+					 * When Reading Rank0 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t rdodtpat_rank1 = 0x10U;	/*
+					 * When Reading Rank1 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#if STM32MP_DDR3_TYPE
+	uint8_t rdodtpat_rank2 = 0x80U;	/*
+					 * When Reading Rank2 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+	uint8_t rdodtpat_rank3 = 0x40U;	/*
+					 * When Reading Rank3 : Bits[7:4] should be set to the
+					 * desired setting of ODT[3:0] to the DRAM
+					 */
+#else /* STM32MP_DDR4_TYPE */
+	uint8_t rdodtpat_rank2 = 0x00U;
+	uint8_t rdodtpat_rank3 = 0x00U;
+
+	uint8_t d4misc = 0x1U;		/*
+					 * Protect memory reset:
+					 * 0x1 = dfi_reset_n cannot control BP_MEMRESERT_L to
+					 *       devices after training.
+					 * 0x0 = dfi_resert_n can control BP_MEMRESERT_L to
+					 *       devices after training.
+					 */
+#endif /* STM32MP_DDR3_TYPE */
+#else /* STM32MP_LPDDR4_TYPE */
+	uint8_t caterminatingrankcha = 0x00U; /* Usually Rank0 is terminating rank */
+	uint8_t caterminatingrankchb = 0x00U; /* Usually Rank0 is terminating rank */
+	uint8_t dfimrlmargin = 0x02U; /* This needs to be large enough for max tDQSCK variation */
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+#if STM32MP_DDR3_TYPE
+	uint8_t share2dvrefresult = 0x0U;	/*
+						 * Bitmap that controls which vref generator the
+						 * phy will use per pstate
+						 *     If share2dvrefresult[x] = 1, pstate x will
+						 *     use the per-lane VrefDAC0/1 CSRs which can be
+						 *     trained by 2d training. If 2D has not run
+						 *     yet, VrefDAC0/1 will default to pstate 0's
+						 *     1D phyVref messageBlock setting.
+						 *     If share2dvrefresult[x] = 0, pstate x will
+						 *     use the per-phy VrefInGlobal CSR, which are
+						 *     set to pstate x's 1D phyVref messageBlock
+						 *     setting.
+						 */
+#elif STM32MP_DDR4_TYPE
+	uint8_t share2dvrefresult = 0x1U;
+#else /* STM32MP_LPDDR4_TYPE */
+	uint8_t share2dvrefresult = 0x1U;
+	uint8_t usebroadcastmr = 0x00U;
+#endif /* STM32MP_DDR3_TYPE */
+
+	/* 1D message block defaults */
+	memset((void *) mb_ddr_1d, 0, sizeof(struct pmu_smb_ddr_1d));
+
+	mb_ddr_1d->pstate = 0U;
+	mb_ddr_1d->sequencectrl = (uint16_t)config->uia.sequencectrl;
+	mb_ddr_1d->phyconfigoverride = 0x0U;
+	mb_ddr_1d->hdtctrl = hdtctrl;
+	mb_ddr_1d->msgmisc = msgmisc;
+	mb_ddr_1d->reserved00 = reserved00;
+	mb_ddr_1d->dfimrlmargin = dfimrlmargin;
+	mb_ddr_1d->phyvref = (uint8_t)config->uia.phyvref;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	mb_ddr_1d->cspresent = cspresent;
+	mb_ddr_1d->cspresentd0 = cspresent;
+	/* mb_ddr_1d->cspresentd1 = 0x0U; Unused */
+	mb_ddr_1d->addrmirror = addrmirror;
+
+	mb_ddr_1d->acsmodtctrl0 = wrodtpat_rank0 | rdodtpat_rank0;
+	mb_ddr_1d->acsmodtctrl1 = wrodtpat_rank1 | rdodtpat_rank1;
+	mb_ddr_1d->acsmodtctrl2 = wrodtpat_rank2 | rdodtpat_rank2;
+	mb_ddr_1d->acsmodtctrl3 = wrodtpat_rank3 | rdodtpat_rank3;
+
+	/* mb_ddr_1d->acsmodtctrl4 = 0x0U; Unused */
+	/* mb_ddr_1d->acsmodtctrl5 = 0x0U; Unused */
+	/* mb_ddr_1d->acsmodtctrl6 = 0x0U; Unused */
+	/* mb_ddr_1d->acsmodtctrl7 = 0x0U; Unused */
+	mb_ddr_1d->enableddqs = (uint8_t)((config->uib.numactivedbytedfi0 +
+					   config->uib.numactivedbytedfi1) * 8U);
+#if STM32MP_DDR3_TYPE
+	mb_ddr_1d->phycfg = (uint8_t)config->uia.is2ttiming;
+#else /* STM32MP_DDR4_TYPE */
+	mb_ddr_1d->phycfg = ((config->uim.mr3 & 0x8U) == 0x8U) ?
+			      0U : (uint8_t)config->uia.is2ttiming;
+	mb_ddr_1d->x16present = (0x10 == config->uib.dramdatawidth) ?
+				mb_ddr_1d->cspresent : 0x0U;
+	mb_ddr_1d->d4misc = d4misc;
+	mb_ddr_1d->cssetupgddec = 0x1U;	/* If Geardown is chosen, dynamically modify CS timing */
+
+	/*
+	 * Outputs - just initialize these to zero
+	 * mb_ddr_1d->rtt_nom_wr_park<0..7>
+	 */
+#endif /* STM32MP_DDR3_TYPE */
+
+	mb_ddr_1d->mr0 = (uint16_t)config->uim.mr0;
+	mb_ddr_1d->mr1 = (uint16_t)config->uim.mr1;
+	mb_ddr_1d->mr2 = (uint16_t)config->uim.mr2;
+#if STM32MP_DDR4_TYPE
+	mb_ddr_1d->mr3 = (uint16_t)config->uim.mr3;
+	mb_ddr_1d->mr4 = (uint16_t)config->uim.mr4;
+	mb_ddr_1d->mr5 = (uint16_t)config->uim.mr5;
+	mb_ddr_1d->mr6 = (uint16_t)config->uim.mr6;
+
+	mb_ddr_1d->alt_cas_l = 0x0U;
+	mb_ddr_1d->alt_wcas_l = 0x0U;
+
+	/*
+	 * Outputs - just initialize these to zero
+	 * mb_ddr_1d->vrefdqr<0..3>nib<0..19>
+	 */
+#endif /* STM32MP_DDR4_TYPE */
+#else /* STM32MP_LPDDR4_TYPE */
+	mb_ddr_1d->enableddqscha = (uint8_t)(config->uib.numactivedbytedfi0 * 8U);
+	mb_ddr_1d->cspresentcha = (2U == config->uib.numrank_dfi0) ?
+				  0x3U : (uint8_t)config->uib.numrank_dfi0;
+	mb_ddr_1d->enableddqschb = (uint8_t)(config->uib.numactivedbytedfi1 * 8U);
+	mb_ddr_1d->cspresentchb = (2U == config->uib.numrank_dfi1) ?
+				  0x3U : (uint8_t)config->uib.numrank_dfi1;
+	mb_ddr_1d->usebroadcastmr = usebroadcastmr;
+
+	mb_ddr_1d->lp4misc = 0x00U;
+	mb_ddr_1d->caterminatingrankcha = caterminatingrankcha;
+	mb_ddr_1d->caterminatingrankchb = caterminatingrankchb;
+	mb_ddr_1d->lp4quickboot = 0x00U;
+	mb_ddr_1d->catrainopt = 0x00U;
+	mb_ddr_1d->x8mode = 0x00U;
+
+	mb_ddr_1d->mr1_a0 = (uint8_t)config->uim.mr1;
+	mb_ddr_1d->mr2_a0 = (uint8_t)config->uim.mr2;
+	mb_ddr_1d->mr3_a0 = (uint8_t)config->uim.mr3;
+	mb_ddr_1d->mr4_a0 = (uint8_t)config->uim.mr4;
+	mb_ddr_1d->mr11_a0 = (uint8_t)config->uim.mr11;
+	mb_ddr_1d->mr12_a0 = (uint8_t)config->uim.mr12;
+	mb_ddr_1d->mr13_a0 = (uint8_t)config->uim.mr13;
+	mb_ddr_1d->mr14_a0 = (uint8_t)config->uim.mr14;
+	mb_ddr_1d->mr16_a0 = 0x00U;
+	mb_ddr_1d->mr17_a0 = 0x00U;
+	mb_ddr_1d->mr22_a0 = (uint8_t)config->uim.mr22;
+	mb_ddr_1d->mr24_a0 = 0x00U;
+	mb_ddr_1d->mr1_a1 = (uint8_t)config->uim.mr1;
+	mb_ddr_1d->mr2_a1 = (uint8_t)config->uim.mr2;
+	mb_ddr_1d->mr3_a1 = (uint8_t)config->uim.mr3;
+	mb_ddr_1d->mr4_a1 = (uint8_t)config->uim.mr4;
+	mb_ddr_1d->mr11_a1 = (uint8_t)config->uim.mr11;
+	mb_ddr_1d->mr12_a1 = (uint8_t)config->uim.mr12;
+	mb_ddr_1d->mr13_a1 = (uint8_t)config->uim.mr13;
+	mb_ddr_1d->mr14_a1 = (uint8_t)config->uim.mr14;
+	mb_ddr_1d->mr16_a1 = 0x00U;
+	mb_ddr_1d->mr17_a1 = 0x00U;
+	mb_ddr_1d->mr22_a1 = (uint8_t)config->uim.mr22;
+	mb_ddr_1d->mr24_a1 = 0x00U;
+
+	mb_ddr_1d->mr1_b0 = (uint8_t)config->uim.mr1;
+	mb_ddr_1d->mr2_b0 = (uint8_t)config->uim.mr2;
+	mb_ddr_1d->mr3_b0 = (uint8_t)config->uim.mr3;
+	mb_ddr_1d->mr4_b0 = (uint8_t)config->uim.mr4;
+	mb_ddr_1d->mr11_b0 = (uint8_t)config->uim.mr11;
+	mb_ddr_1d->mr12_b0 = (uint8_t)config->uim.mr12;
+	mb_ddr_1d->mr13_b0 = (uint8_t)config->uim.mr13;
+	mb_ddr_1d->mr14_b0 = (uint8_t)config->uim.mr14;
+	mb_ddr_1d->mr16_b0 = 0x00U;
+	mb_ddr_1d->mr17_b0 = 0x00U;
+	mb_ddr_1d->mr22_b0 = (uint8_t)config->uim.mr22;
+	mb_ddr_1d->mr24_b0 = 0x00U;
+	mb_ddr_1d->mr1_b1 = (uint8_t)config->uim.mr1;
+	mb_ddr_1d->mr2_b1 = (uint8_t)config->uim.mr2;
+	mb_ddr_1d->mr3_b1 = (uint8_t)config->uim.mr3;
+	mb_ddr_1d->mr4_b1 = (uint8_t)config->uim.mr4;
+	mb_ddr_1d->mr11_b1 = (uint8_t)config->uim.mr11;
+	mb_ddr_1d->mr12_b1 = (uint8_t)config->uim.mr12;
+	mb_ddr_1d->mr13_b1 = (uint8_t)config->uim.mr13;
+	mb_ddr_1d->mr14_b1 = (uint8_t)config->uim.mr14;
+	mb_ddr_1d->mr16_b1 = 0x00U;
+	mb_ddr_1d->mr17_b1 = 0x00U;
+	mb_ddr_1d->mr22_b1 = (uint8_t)config->uim.mr22;
+	mb_ddr_1d->mr24_b1 = 0x00U;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	mb_ddr_1d->share2dvrefresult = share2dvrefresult;
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c
new file mode 100644
index 0000000000..2ad6a0608c
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+#include <ddrphy_wrapper.h>
+
+/*
+ * Helper function to determine if a given DByte is Disabled given PhyInit inputs.
+ * @return 1 if disabled, 0 if enabled.
+ */
+int ddrphy_phyinit_isdbytedisabled(struct stm32mp_ddr_config *config,
+				   struct pmu_smb_ddr_1d *mb_ddr_1d, uint32_t dbytenumber)
+{
+	int disabledbyte;
+	uint32_t nad0 __unused;
+	uint32_t nad1 __unused;
+
+	disabledbyte = 0; /* Default assume Dbyte is Enabled */
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	disabledbyte = (dbytenumber > (config->uib.numactivedbytedfi0 - 1U)) ? 1 : 0;
+#else /* STM32MP_LPDDR4_TYPE */
+	nad0 = config->uib.numactivedbytedfi0;
+	nad1 = config->uib.numactivedbytedfi1;
+
+	if ((nad0 + nad1) > config->uib.numdbyte) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s invalid PHY configuration:\n", __func__);
+		VERBOSE("numactivedbytedfi0(%u)+numactivedbytedfi1(%u)>numdbytes(%u).\n",
+			nad0, nad1, config->uib.numdbyte);
+	}
+
+	if (config->uib.dfi1exists != 0U) {
+		if (config->uib.numactivedbytedfi1 == 0U) {
+			/* Only dfi0 (ChA) is enabled, dfi1 (ChB) disabled */
+			disabledbyte = (dbytenumber > (config->uib.numactivedbytedfi0 - 1U)) ?
+				       1 : 0;
+		} else {
+			/* DFI1 enabled */
+			disabledbyte = (((config->uib.numactivedbytedfi0 - 1U) < dbytenumber) &&
+					(dbytenumber < (config->uib.numdbyte / 2U))) ?
+				       1 : (dbytenumber >
+					    ((config->uib.numdbyte / 2U) +
+					     config->uib.numactivedbytedfi1 - 1U)) ? 1 : 0;
+		}
+	} else {
+		disabledbyte = (dbytenumber > (config->uib.numactivedbytedfi0 - 1U)) ? 1 : 0;
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	/* Qualify results against MessageBlock */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	if ((mb_ddr_1d->enableddqs < 1U) ||
+	    (mb_ddr_1d->enableddqs > (uint8_t)(8U * config->uib.numactivedbytedfi0))) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s enableddqs(%u)\n", __func__, mb_ddr_1d->enableddqs);
+		VERBOSE("Value must be 0 < enableddqs < config->uib.numactivedbytedfi0 * 8.\n");
+	}
+
+	if (dbytenumber < 8) {
+		disabledbyte |= (int)mb_ddr_1d->disableddbyte & (0x1 << dbytenumber);
+	}
+#else /* STM32MP_LPDDR4_TYPE */
+	if ((mb_ddr_1d->enableddqscha < 1U) ||
+	    (mb_ddr_1d->enableddqscha > (uint8_t)(8U * config->uib.numactivedbytedfi0))) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s enableddqscha(%u)\n", __func__, mb_ddr_1d->enableddqscha);
+		VERBOSE("Value must be 0 < enableddqscha < config->uib.numactivedbytedfi0*8\n");
+	}
+
+	if ((config->uib.dfi1exists != 0U) && (config->uib.numactivedbytedfi1 > 0U) &&
+	    ((mb_ddr_1d->enableddqschb < 1U) ||
+	     (mb_ddr_1d->enableddqschb > (uint8_t)(8U * config->uib.numactivedbytedfi1)))) {
+		ERROR("%s %d\n", __func__, __LINE__);
+		VERBOSE("%s enableddqschb(%u)\n", __func__, mb_ddr_1d->enableddqschb);
+		VERBOSE("Value must be 0 < enableddqschb < config->uib.numactivedbytedfi1*8\n");
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	return disabledbyte;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c
new file mode 100644
index 0000000000..3d3688b106
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+#define PRODCODE_SIZE	177
+
+static const uint32_t prodcode_addr[PRODCODE_SIZE] = {
+	0x90000U, 0x90001U, 0x90002U, 0x90003U, 0x90004U, 0x90005U, 0x90029U, 0x9002AU, 0x9002BU,
+	0x9002CU, 0x9002DU, 0x9002EU, 0x9002FU, 0x90030U, 0x90031U, 0x90032U, 0x90033U, 0x90034U,
+	0x90035U, 0x90036U, 0x90037U, 0x90038U, 0x90039U, 0x9003AU, 0x9003BU, 0x9003CU, 0x9003DU,
+	0x9003EU, 0x9003FU, 0x90040U, 0x90041U, 0x90042U, 0x90043U, 0x90044U, 0x90045U, 0x90046U,
+	0x90047U, 0x90048U, 0x90049U, 0x9004AU, 0x9004BU, 0x9004CU, 0x9004DU, 0x9004EU, 0x9004FU,
+	0x90050U, 0x90051U, 0x90052U, 0x90053U, 0x90054U, 0x90055U, 0x90056U, 0x90057U, 0x90058U,
+	0x90059U, 0x9005AU, 0x9005BU, 0x9005CU, 0x9005DU, 0x9005EU, 0x9005FU, 0x90060U, 0x90061U,
+	0x90062U, 0x90063U, 0x90064U, 0x90065U, 0x90066U, 0x90067U, 0x90068U, 0x90069U, 0x9006AU,
+	0x9006BU, 0x9006CU, 0x9006DU, 0x9006EU, 0x9006FU, 0x90070U, 0x90071U, 0x90072U, 0x90073U,
+	0x90074U, 0x90075U, 0x90076U, 0x90077U, 0x90078U, 0x90079U, 0x9007AU, 0x9007BU, 0x9007CU,
+	0x9007DU, 0x9007EU, 0x9007FU, 0x90080U, 0x90081U, 0x90082U, 0x90083U, 0x90084U, 0x90085U,
+	0x90086U, 0x90087U, 0x90088U, 0x90089U, 0x9008AU, 0x9008BU, 0x9008CU, 0x9008DU, 0x9008EU,
+	0x9008FU, 0x90090U, 0x90091U, 0x90092U, 0x90093U, 0x90094U, 0x90095U, 0x90096U, 0x90097U,
+	0x90098U, 0x90099U, 0x9009AU, 0x9009BU, 0x9009CU, 0x9009DU, 0x9009EU, 0x9009FU, 0x900A0U,
+	0x900A1U, 0x900A2U, 0x900A3U, 0x900A4U, 0x900A5U, 0x900A6U, 0x900A7U, 0x900A8U, 0x900A9U,
+	0x900AAU, 0x900ABU, 0x900ACU, 0x900ADU, 0x900AEU, 0x900AFU, 0x900B0U, 0x900B1U, 0x900B2U,
+	0x900B3U, 0x900B4U, 0x900B5U, 0x900B6U, 0x900B7U, 0x900B8U, 0x900B9U, 0x900BAU, 0x900BBU,
+	0x900BCU, 0x900BDU, 0x900BEU, 0x900BFU, 0x900C0U, 0x900C1U, 0x900C2U, 0x900C3U, 0x900C4U,
+	0x900C5U, 0x900C6U, 0x900C7U, 0x900C8U, 0x900C9U, 0x900CAU, 0x90006U, 0x90007U, 0x90008U,
+	0x90009U, 0x9000AU, 0x9000BU, 0xD00E7U, 0x90017U, 0x90026U,
+};
+
+static const uint16_t prodcode_data[PRODCODE_SIZE] = {
+	0x0010U, 0x0400U, 0x010EU, 0x0000U, 0x0000U, 0x0008U, 0x000BU, 0x0480U, 0x0109U, 0x0008U,
+	0x0448U, 0x0139U, 0x0008U, 0x0478U, 0x0109U, 0x0002U, 0x0010U, 0x0139U, 0x000BU, 0x07C0U,
+	0x0139U, 0x0044U, 0x0633U, 0x0159U, 0x014FU, 0x0630U, 0x0159U, 0x0047U, 0x0633U, 0x0149U,
+	0x004FU, 0x0633U, 0x0179U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U, 0x07C8U, 0x0109U, 0x0000U,
+	0x0001U, 0x0008U, 0x0030U, 0x065AU, 0x0009U, 0x0000U, 0x045AU, 0x0009U, 0x0000U, 0x0448U,
+	0x0109U, 0x0040U, 0x0633U, 0x0179U, 0x0001U, 0x0618U, 0x0109U, 0x40C0U, 0x0633U, 0x0149U,
+	0x0008U, 0x0004U, 0x0048U, 0x4040U, 0x0633U, 0x0149U, 0x0000U, 0x0004U, 0x0048U, 0x0040U,
+	0x0633U, 0x0149U, 0x0000U, 0x0658U, 0x0109U, 0x0010U, 0x0004U, 0x0018U, 0x0000U, 0x0004U,
+	0x0078U, 0x0549U, 0x0633U, 0x0159U, 0x0D49U, 0x0633U, 0x0159U, 0x094AU, 0x0633U, 0x0159U,
+	0x0441U, 0x0633U, 0x0149U, 0x0042U, 0x0633U, 0x0149U, 0x0001U, 0x0633U, 0x0149U, 0x0000U,
+	0x00E0U, 0x0109U, 0x000AU, 0x0010U, 0x0109U, 0x0009U, 0x03C0U, 0x0149U, 0x0009U, 0x03C0U,
+	0x0159U, 0x0018U, 0x0010U, 0x0109U, 0x0000U, 0x03C0U, 0x0109U, 0x0018U, 0x0004U, 0x0048U,
+	0x0018U, 0x0004U, 0x0058U, 0x000BU, 0x0010U, 0x0109U, 0x0001U, 0x0010U, 0x0109U, 0x0005U,
+	0x07C0U, 0x0109U, 0x0000U, 0x8140U, 0x010CU, 0x0010U, 0x8138U, 0x0104U, 0x0008U, 0x0448U,
+	0x0109U, 0x000FU, 0x07C0U, 0x0109U, 0x0047U, 0x0630U, 0x0109U, 0x0008U, 0x0618U, 0x0109U,
+	0x0008U, 0x00E0U, 0x0109U, 0x0000U, 0x07C8U, 0x0109U, 0x0008U, 0x8140U, 0x010CU, 0x0000U,
+	0x0478U, 0x0109U, 0x0000U, 0x0001U, 0x0008U, 0x0008U, 0x0004U, 0x0000U, 0x0008U, 0x07C8U,
+	0x0109U, 0x0000U, 0x0400U, 0x0106U, 0x0400U, 0x0000U, 0x002CU,
+	};
+
+#else /* STM32MP_LPDDR4_TYPE */
+#define PRODCODE_SIZE		481
+
+static const uint32_t prodcode_addr[PRODCODE_SIZE] = {
+	0x90000U, 0x90001U, 0x90002U, 0x90003U, 0x90004U, 0x90005U, 0x90029U, 0x9002AU, 0x9002BU,
+	0x9002CU, 0x9002DU, 0x9002EU, 0x9002FU, 0x90030U, 0x90031U, 0x90032U, 0x90033U, 0x90034U,
+	0x90035U, 0x90036U, 0x90037U, 0x90038U, 0x90039U, 0x9003AU, 0x9003BU, 0x9003CU, 0x9003DU,
+	0x9003EU, 0x9003FU, 0x90040U, 0x90041U, 0x90042U, 0x90043U, 0x90044U, 0x90045U, 0x90046U,
+	0x90047U, 0x90048U, 0x90049U, 0x9004AU, 0x9004BU, 0x9004CU, 0x9004DU, 0x9004EU, 0x9004FU,
+	0x90050U, 0x90051U, 0x90052U, 0x90053U, 0x90054U, 0x90055U, 0x90056U, 0x90057U, 0x90058U,
+	0x90059U, 0x9005AU, 0x9005BU, 0x9005CU, 0x9005DU, 0x9005EU, 0x9005FU, 0x90060U, 0x90061U,
+	0x90062U, 0x90063U, 0x90064U, 0x90065U, 0x90066U, 0x90067U, 0x90068U, 0x90069U, 0x9006AU,
+	0x9006BU, 0x9006CU, 0x9006DU, 0x9006EU, 0x9006FU, 0x90070U, 0x90071U, 0x90072U, 0x90073U,
+	0x90074U, 0x90075U, 0x90076U, 0x90077U, 0x90078U, 0x90079U, 0x9007AU, 0x9007BU, 0x9007CU,
+	0x9007DU, 0x9007EU, 0x9007FU, 0x90080U, 0x90081U, 0x90082U, 0x90083U, 0x90084U, 0x90085U,
+	0x90086U, 0x90087U, 0x90088U, 0x90089U, 0x9008AU, 0x9008BU, 0x9008CU, 0x9008DU, 0x9008EU,
+	0x9008FU, 0x90090U, 0x90091U, 0x90092U, 0x90093U, 0x90094U, 0x90095U, 0x90096U, 0x90097U,
+	0x90098U, 0x90099U, 0x9009AU, 0x9009BU, 0x9009CU, 0x9009DU, 0x9009EU, 0x9009FU, 0x900A0U,
+	0x900A1U, 0x900A2U, 0x900A3U, 0x900A4U, 0x900A5U, 0x900A6U, 0x900A7U, 0x900A8U, 0x900A9U,
+	0x40000U, 0x40020U, 0x40040U, 0x40060U, 0x40001U, 0x40021U, 0x40041U, 0x40061U, 0x40002U,
+	0x40022U, 0x40042U, 0x40062U, 0x40003U, 0x40023U, 0x40043U, 0x40063U, 0x40004U, 0x40024U,
+	0x40044U, 0x40064U, 0x40005U, 0x40025U, 0x40045U, 0x40065U, 0x40006U, 0x40026U, 0x40046U,
+	0x40066U, 0x40007U, 0x40027U, 0x40047U, 0x40067U, 0x40008U, 0x40028U, 0x40048U, 0x40068U,
+	0x40009U, 0x40029U, 0x40049U, 0x40069U, 0x4000AU, 0x4002AU, 0x4004AU, 0x4006AU, 0x4000BU,
+	0x4002BU, 0x4004BU, 0x4006BU, 0x4000CU, 0x4002CU, 0x4004CU, 0x4006CU, 0x4000DU, 0x4002DU,
+	0x4004DU, 0x4006DU, 0x4000EU, 0x4002EU, 0x4004EU, 0x4006EU, 0x4000FU, 0x4002FU, 0x4004FU,
+	0x4006FU, 0x40010U, 0x40030U, 0x40050U, 0x40070U, 0x40011U, 0x40031U, 0x40051U, 0x40071U,
+	0x40012U, 0x40032U, 0x40052U, 0x40072U, 0x40013U, 0x40033U, 0x40053U, 0x40073U, 0x40014U,
+	0x40034U, 0x40054U, 0x40074U, 0x40015U, 0x40035U, 0x40055U, 0x40075U, 0x40016U, 0x40036U,
+	0x40056U, 0x40076U, 0x40017U, 0x40037U, 0x40057U, 0x40077U, 0x40018U, 0x40038U, 0x40058U,
+	0x40078U, 0x40019U, 0x40039U, 0x40059U, 0x40079U, 0x4001AU, 0x4003AU, 0x4005AU, 0x4007AU,
+	0x900AAU, 0x900ABU, 0x900ACU, 0x900ADU, 0x900AEU, 0x900AFU, 0x900B0U, 0x900B1U, 0x900B2U,
+	0x900B3U, 0x900B4U, 0x900B5U, 0x900B6U, 0x900B7U, 0x900B8U, 0x900B9U, 0x900BAU, 0x900BBU,
+	0x900BCU, 0x900BDU, 0x900BEU, 0x900BFU, 0x900C0U, 0x900C1U, 0x900C2U, 0x900C3U, 0x900C4U,
+	0x900C5U, 0x900C6U, 0x900C7U, 0x900C8U, 0x900C9U, 0x900CAU, 0x900CBU, 0x900CCU, 0x900CDU,
+	0x900CEU, 0x900CFU, 0x900D0U, 0x900D1U, 0x900D2U, 0x900D3U, 0x900D4U, 0x900D5U, 0x900D6U,
+	0x900D7U, 0x900D8U, 0x900D9U, 0x900DAU, 0x900DBU, 0x900DCU, 0x900DDU, 0x900DEU, 0x900DFU,
+	0x900E0U, 0x900E1U, 0x900E2U, 0x900E3U, 0x900E4U, 0x900E5U, 0x900E6U, 0x900E7U, 0x900E8U,
+	0x900E9U, 0x900EAU, 0x900EBU, 0x900ECU, 0x900EDU, 0x900EEU, 0x900EFU, 0x900F0U, 0x900F1U,
+	0x900F2U, 0x900F3U, 0x900F4U, 0x900F5U, 0x900F6U, 0x900F7U, 0x900F8U, 0x900F9U, 0x900FAU,
+	0x900FBU, 0x900FCU, 0x900FDU, 0x900FEU, 0x900FFU, 0x90100U, 0x90101U, 0x90102U, 0x90103U,
+	0x90104U, 0x90105U, 0x90106U, 0x90107U, 0x90108U, 0x90109U, 0x9010AU, 0x9010BU, 0x9010CU,
+	0x9010DU, 0x9010EU, 0x9010FU, 0x90110U, 0x90111U, 0x90112U, 0x90113U, 0x90114U, 0x90115U,
+	0x90116U, 0x90117U, 0x90118U, 0x90119U, 0x9011AU, 0x9011BU, 0x9011CU, 0x9011DU, 0x9011EU,
+	0x9011FU, 0x90120U, 0x90121U, 0x90122U, 0x90123U, 0x90124U, 0x90125U, 0x90126U, 0x90127U,
+	0x90128U, 0x90129U, 0x9012AU, 0x9012BU, 0x9012CU, 0x9012DU, 0x9012EU, 0x9012FU, 0x90130U,
+	0x90131U, 0x90132U, 0x90133U, 0x90134U, 0x90135U, 0x90136U, 0x90137U, 0x90138U, 0x90139U,
+	0x9013AU, 0x9013BU, 0x9013CU, 0x9013DU, 0x9013EU, 0x9013FU, 0x90140U, 0x90141U, 0x90142U,
+	0x90143U, 0x90144U, 0x90145U, 0x90146U, 0x90147U, 0x90148U, 0x90149U, 0x9014AU, 0x9014BU,
+	0x9014CU, 0x9014DU, 0x9014EU, 0x9014FU, 0x90150U, 0x90151U, 0x90152U, 0x90153U, 0x90154U,
+	0x90155U, 0x90156U, 0x90157U, 0x90158U, 0x90159U, 0x9015AU, 0x9015BU, 0x9015CU, 0x9015DU,
+	0x9015EU, 0x9015FU, 0x90160U, 0x90161U, 0x90162U, 0x90163U, 0x90164U, 0x90165U, 0x90166U,
+	0x90167U, 0x90168U, 0x90169U, 0x9016AU, 0x9016BU, 0x9016CU, 0x9016DU, 0x9016EU, 0x9016FU,
+	0x90170U, 0x90171U, 0x90172U, 0x90173U, 0x90174U, 0x90175U, 0x90176U, 0x90177U, 0x90178U,
+	0x90179U, 0x9017AU, 0x9017BU, 0x9017CU, 0x9017DU, 0x9017EU, 0x9017FU, 0x90180U, 0x90181U,
+	0x90182U, 0x90183U, 0x90184U, 0x90006U, 0x90007U, 0x90008U, 0x90009U, 0x9000AU, 0x9000BU,
+	0xD00E7U, 0x90017U, 0x9001FU, 0x90026U, 0x400D0U, 0x400D1U, 0x400D2U, 0x400D3U, 0x400D4U,
+	0x400D5U, 0x400D6U, 0x400D7U, 0x2003AU,
+	};
+
+static const uint16_t prodcode_data[PRODCODE_SIZE] = {
+	0x0010U, 0x0400U, 0x010EU, 0x0000U, 0x0000U, 0x0008U, 0x000BU, 0x0480U, 0x0109U, 0x0008U,
+	0x0448U, 0x0139U, 0x0008U, 0x0478U, 0x0109U, 0x0000U, 0x00E8U, 0x0109U, 0x0002U, 0x0010U,
+	0x0139U, 0x000BU, 0x07C0U, 0x0139U, 0x0044U, 0x0633U, 0x0159U, 0x014FU, 0x0630U, 0x0159U,
+	0x0047U, 0x0633U, 0x0149U, 0x004FU, 0x0633U, 0x0179U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U,
+	0x07C8U, 0x0109U, 0x0000U, 0x0001U, 0x0008U, 0x0030U, 0x065AU, 0x0009U, 0x0000U, 0x045AU,
+	0x0009U, 0x0000U, 0x0448U, 0x0109U, 0x0040U, 0x0633U, 0x0179U, 0x0001U, 0x0618U, 0x0109U,
+	0x40C0U, 0x0633U, 0x0149U, 0x0008U, 0x0004U, 0x0048U, 0x4040U, 0x0633U, 0x0149U, 0x0000U,
+	0x0004U, 0x0048U, 0x0040U, 0x0633U, 0x0149U, 0x0000U, 0x0658U, 0x0109U, 0x0010U, 0x0004U,
+	0x0018U, 0x0000U, 0x0004U, 0x0078U, 0x0549U, 0x0633U, 0x0159U, 0x0D49U, 0x0633U, 0x0159U,
+	0x094AU, 0x0633U, 0x0159U, 0x0441U, 0x0633U, 0x0149U, 0x0042U, 0x0633U, 0x0149U, 0x0001U,
+	0x0633U, 0x0149U, 0x0000U, 0x00E0U, 0x0109U, 0x000AU, 0x0010U, 0x0109U, 0x0009U, 0x03C0U,
+	0x0149U, 0x0009U, 0x03C0U, 0x0159U, 0x0018U, 0x0010U, 0x0109U, 0x0000U, 0x03C0U, 0x0109U,
+	0x0018U, 0x0004U, 0x0048U, 0x0018U, 0x0004U, 0x0058U, 0x000BU, 0x0010U, 0x0109U, 0x0001U,
+	0x0010U, 0x0109U, 0x0005U, 0x07C0U, 0x0109U, 0x0811U, 0x0880U, 0x0000U, 0x0000U, 0x4008U,
+	0x0083U, 0x004FU, 0x0000U, 0x4040U, 0x0083U, 0x0051U, 0x0000U, 0x0811U, 0x0880U, 0x0000U,
+	0x0000U, 0x0720U, 0x000FU, 0x1740U, 0x0000U, 0x0016U, 0x0083U, 0x004BU, 0x0000U, 0x0716U,
+	0x000FU, 0x2001U, 0x0000U, 0x0716U, 0x000FU, 0x2800U, 0x0000U, 0x0716U, 0x000FU, 0x0F00U,
+	0x0000U, 0x0720U, 0x000FU, 0x1400U, 0x0000U, 0x0E08U, 0x0C15U, 0x0000U, 0x0000U, 0x0625U,
+	0x0015U, 0x0000U, 0x0000U, 0x4028U, 0x0080U, 0x0000U, 0x0000U, 0x0E08U, 0x0C1AU, 0x0000U,
+	0x0000U, 0x0625U, 0x001AU, 0x0000U, 0x0000U, 0x4040U, 0x0080U, 0x0000U, 0x0000U, 0x2604U,
+	0x0015U, 0x0000U, 0x0000U, 0x0708U, 0x0005U, 0x0000U, 0x2002U, 0x0008U, 0x0080U, 0x0000U,
+	0x0000U, 0x2604U, 0x001AU, 0x0000U, 0x0000U, 0x0708U, 0x000AU, 0x0000U, 0x2002U, 0x4040U,
+	0x0080U, 0x0000U, 0x0000U, 0x060AU, 0x0015U, 0x1200U, 0x0000U, 0x061AU, 0x0015U, 0x1300U,
+	0x0000U, 0x060AU, 0x001AU, 0x1200U, 0x0000U, 0x0642U, 0x001AU, 0x1300U, 0x0000U, 0x4808U,
+	0x0880U, 0x0000U, 0x0000U, 0x0000U, 0x0790U, 0x011AU, 0x0008U, 0x07AAU, 0x002AU, 0x0010U,
+	0x07B2U, 0x002AU, 0x0000U, 0x07C8U, 0x0109U, 0x0010U, 0x0010U, 0x0109U, 0x0010U, 0x02A8U,
+	0x0129U, 0x0008U, 0x0370U, 0x0129U, 0x000AU, 0x03C8U, 0x01A9U, 0x000CU, 0x0408U, 0x0199U,
+	0x0014U, 0x0790U, 0x011AU, 0x0008U, 0x0004U, 0x0018U, 0x000EU, 0x0408U, 0x0199U, 0x0008U,
+	0x8568U, 0x0108U, 0x0018U, 0x0790U, 0x016AU, 0x0008U, 0x01D8U, 0x0169U, 0x0010U, 0x8558U,
+	0x0168U, 0x1FF8U, 0x85A8U, 0x01E8U, 0x0050U, 0x0798U, 0x016AU, 0x0060U, 0x07A0U, 0x016AU,
+	0x0008U, 0x8310U, 0x0168U, 0x0008U, 0xA310U, 0x0168U, 0x000AU, 0x0408U, 0x0169U, 0x006EU,
+	0x0000U, 0x0068U, 0x0000U, 0x0408U, 0x0169U, 0x0000U, 0x8310U, 0x0168U, 0x0000U, 0xA310U,
+	0x0168U, 0x1FF8U, 0x85A8U, 0x01E8U, 0x0068U, 0x0798U, 0x016AU, 0x0078U, 0x07A0U, 0x016AU,
+	0x0068U, 0x0790U, 0x016AU, 0x0008U, 0x8B10U, 0x0168U, 0x0008U, 0xAB10U, 0x0168U, 0x000AU,
+	0x0408U, 0x0169U, 0x0058U, 0x0000U, 0x0068U, 0x0000U, 0x0408U, 0x0169U, 0x0000U, 0x8B10U,
+	0x0168U, 0x0001U, 0xAB10U, 0x0168U, 0x0000U, 0x01D8U, 0x0169U, 0x0080U, 0x0790U, 0x016AU,
+	0x0018U, 0x07AAU, 0x006AU, 0x000AU, 0x0000U, 0x01E9U, 0x0008U, 0x8080U, 0x0108U, 0x000FU,
+	0x0408U, 0x0169U, 0x000CU, 0x0000U, 0x0068U, 0x0009U, 0x0000U, 0x01A9U, 0x0000U, 0x0408U,
+	0x0169U, 0x0000U, 0x8080U, 0x0108U, 0x0008U, 0x07AAU, 0x006AU, 0x0000U, 0x8568U, 0x0108U,
+	0x00B7U, 0x0790U, 0x016AU, 0x001FU, 0x0000U, 0x0068U, 0x0008U, 0x8558U, 0x0168U, 0x000FU,
+	0x0408U, 0x0169U, 0x000DU, 0x0000U, 0x0068U, 0x0000U, 0x0408U, 0x0169U, 0x0000U, 0x8558U,
+	0x0168U, 0x0008U, 0x03C8U, 0x01A9U, 0x0003U, 0x0370U, 0x0129U, 0x0020U, 0x02AAU, 0x0009U,
+	0x0008U, 0x00E8U, 0x0109U, 0x0000U, 0x8140U, 0x010CU, 0x0010U, 0x8138U, 0x0104U, 0x0008U,
+	0x0448U, 0x0109U, 0x000FU, 0x07C0U, 0x0109U, 0x0000U, 0x00E8U, 0x0109U, 0x0047U, 0x0630U,
+	0x0109U, 0x0008U, 0x0618U, 0x0109U, 0x0008U, 0x00E0U, 0x0109U, 0x0000U, 0x07C8U, 0x0109U,
+	0x0008U, 0x8140U, 0x010CU, 0x0000U, 0x0478U, 0x0109U, 0x0000U, 0x0001U, 0x0008U, 0x0008U,
+	0x0004U, 0x0000U, 0x0008U, 0x07C8U, 0x0109U, 0x0000U, 0x0400U, 0x0106U, 0x0400U, 0x0000U,
+	0x002BU, 0x0069U, 0x0000U, 0x0101U, 0x0105U, 0x0107U, 0x010FU, 0x0202U, 0x020AU, 0x020BU,
+	0x0002U,
+	};
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+/*
+ * Loads PIE instruction sequence PHY registers
+ * @returns void
+ */
+void ddrphy_phyinit_loadpieprodcode(void)
+{
+	int i;
+
+	for (i = 0; i < PRODCODE_SIZE; i++) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * prodcode_addr[i])),
+			      prodcode_data[i]);
+	}
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c
new file mode 100644
index 0000000000..413166e572
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Maps impedance values to register settings
+ *
+ * Reads the pull-up/pull-down driver impedance from drvstren_ohm input
+ * and encodes that value for the CSR field specified in targetcsr input,
+ * based on DDR protocol.
+ *
+ * @param[in] drvstren_ohm drive strenght / ODT impedance in Ohms
+ *
+ * @param[in] targetcsr Target CSR for the impedance value. on of following
+ * enum drvtype:
+ *   - DRVSTRENFSDQP
+ *   - DRVSTRENFSDQN
+ *   - ODTSTRENP
+ *   - ODTSTRENN
+ *   - ADRVSTRENP
+ *   - ADRVSTRENN
+ *
+ * \return >=0 value on success, else negative.
+ */
+int ddrphy_phyinit_mapdrvstren(uint32_t drvstren_ohm, enum drvtype targetcsr)
+{
+	int stren_setting = -1;
+
+	if ((targetcsr == DRVSTRENFSDQP) || (targetcsr == DRVSTRENFSDQN)) {
+		if (drvstren_ohm == 0U) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 29U) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 31U) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 33U) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 35U) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 38U) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 41U) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 45U) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 50U) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 56U) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 64U) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 74U) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 88U) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 108U) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 140U) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 200U) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 360U) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 481U) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+	} else if (targetcsr == ODTSTRENP) {
+#if STM32MP_DDR3_TYPE
+		/*
+		 * DDR3 - P and N has the same impedance and non-zero.
+		 * user input is half the individual pull-up and pull-down impedances values
+		 * because of parallel between them.
+		 */
+		if (drvstren_ohm == 0U) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 15U) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 16U) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 17U) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 18U) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 20U) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 21U) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 23U) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 26U) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 29U) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 33U) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 38U) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 45U) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 55U) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 71U) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 101U) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 181U) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 241U) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#elif STM32MP_DDR4_TYPE
+		/* DDR4 - P is non-zero */
+		if (drvstren_ohm == 0U) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 29U) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 31U) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 33U) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 35U) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 38U) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 41U) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 45U) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 50U) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 56U) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 64U) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 74U) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 88U) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 108U) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 140U) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 200U) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 360U) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 481U) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#else /* STM32MP_LPDDR4_TYPE */
+		/* LPDDR4 - P is high-Z */
+		stren_setting = 0x00; /* High-impedance */
+#endif /* STM32MP_DDR3_TYPE */
+	} else if (targetcsr == ODTSTRENN) {
+#if STM32MP_DDR3_TYPE
+		/*
+		 * DDR3 - P and N has the same impedance and non-zero.
+		 * Times 2 of user input because of parallel pull-up and pull-down termination.
+		 */
+		if (drvstren_ohm == 0U) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 15U) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 16U) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 17U) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 18U) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 20U) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 21U) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 23U) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 26U) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 29U) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 33U) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 38U) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 45U) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 55U) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 71U) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 101U) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 181U) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 241U) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#elif STM32MP_DDR4_TYPE
+		/* DDR4 - N is high-Z */
+		stren_setting = 0x00; /* High-impedance */
+#else /* STM32MP_LPDDR4_TYPE */
+		/* LPDDR4 - N is non-zero */
+		if (drvstren_ohm == 0U) {
+			stren_setting = 0x00; /* High-impedance */
+		} else if (drvstren_ohm < 29U) {
+			stren_setting = 0x3f;
+		} else if (drvstren_ohm < 31U) {
+			stren_setting = 0x3e;
+		} else if (drvstren_ohm < 33U) {
+			stren_setting = 0x3b;
+		} else if (drvstren_ohm < 35U) {
+			stren_setting = 0x3a;
+		} else if (drvstren_ohm < 38U) {
+			stren_setting = 0x39;
+		} else if (drvstren_ohm < 41U) {
+			stren_setting = 0x38;
+		} else if (drvstren_ohm < 45U) {
+			stren_setting = 0x1b;
+		} else if (drvstren_ohm < 50U) {
+			stren_setting = 0x1a;
+		} else if (drvstren_ohm < 56U) {
+			stren_setting = 0x19;
+		} else if (drvstren_ohm < 64U) {
+			stren_setting = 0x18;
+		} else if (drvstren_ohm < 74U) {
+			stren_setting = 0x0b;
+		} else if (drvstren_ohm < 88U) {
+			stren_setting = 0x0a;
+		} else if (drvstren_ohm < 108U) {
+			stren_setting = 0x09;
+		} else if (drvstren_ohm < 140U) {
+			stren_setting = 0x08;
+		} else if (drvstren_ohm < 200U) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm < 360U) {
+			stren_setting = 0x02;
+		} else if (drvstren_ohm < 481U) {
+			stren_setting = 0x01;
+		} else {
+			stren_setting = 0x00; /* High-impedance */
+		}
+#endif /* STM32MP_DDR3_TYPE */
+	} else {
+		/* if ((targetcsr == ADRVSTRENP) || (targetcsr == ADRVSTRENN)) */
+		if (drvstren_ohm == 120U) {
+			stren_setting = 0x00;
+		} else if (drvstren_ohm == 60U) {
+			stren_setting = 0x01;
+		} else if (drvstren_ohm == 40U) {
+			stren_setting = 0x03;
+		} else if (drvstren_ohm == 30U) {
+			stren_setting = 0x07;
+		} else if (drvstren_ohm == 24U) {
+			stren_setting = 0x0F;
+		} else if (drvstren_ohm == 20U) {
+			stren_setting = 0x1F;
+		} else {
+			ERROR("%s %d\n", __func__, __LINE__);
+			VERBOSE("%s userinputadvanced.atximpedance %u Ohms value is not valid.\n",
+			      __func__, drvstren_ohm);
+			VERBOSE("Valid values are: 20, 24, 30, 40, 60 and 120 Ohms.\n");
+		}
+	}
+
+	return stren_setting;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c
new file mode 100644
index 0000000000..a4b3c39ba1
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c
@@ -0,0 +1,897 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+#include <ddrphy_wrapper.h>
+
+#include <platform_def.h>
+
+struct phyinit_timings {
+	int tstaoff;
+	int tpdm;
+	int tcasl_add;
+};
+
+static struct phyinit_timings timings;
+
+/*
+ * Program dfimrl according to this formula:
+ *
+ *         dfimrl = ceiling( (ARdPtrinitval*UI + phy_tx_insertion_dly +
+ *                            phy_rx_insertion_dly + PHY_Rx_Fifo_dly + tDQSCK + tstaoff) /
+ *                           dficlk_period)
+ *
+ * All terms in above equation specified in ps
+ * tDQSCK - determine from memory model
+ * tstaoff - determine from memory model
+ * phy_tx_insertion_dly = 200ps
+ * phy_rx_insertion_dly = 200ps
+ * phy_rx_fifo_dly      = 200ps + 4UI
+ */
+static void dfimrl_program(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d,
+			   int ardptrinitval)
+{
+	uint32_t byte;
+	int dfimrl_in_dficlk;
+	int phy_rx_fifo_dly;
+	int phy_rx_insertion_dly = 200;
+	int phy_tx_insertion_dly = 200;
+	long long dficlk_period_x1000;
+	long long dfimrl_in_fs;
+	long long uifs;
+	uint16_t dfimrl;
+
+	uifs = (1000 * 1000000) / ((int)config->uib.frequency * 2);
+	dficlk_period_x1000 = 4 * uifs;
+
+	phy_rx_fifo_dly = (int)(((200 * 1000) + (4 * uifs)) / 1000);
+
+	dfimrl_in_fs = (ardptrinitval * uifs) +
+		       ((phy_tx_insertion_dly + phy_rx_insertion_dly + phy_rx_fifo_dly +
+			 timings.tstaoff + timings.tcasl_add + timings.tpdm) * 1000);
+
+	dfimrl_in_dficlk = (int)(dfimrl_in_fs / dficlk_period_x1000);
+	if ((dfimrl_in_fs % dficlk_period_x1000) != 0) {
+		dfimrl_in_dficlk++;
+	}
+	dfimrl = (uint16_t)(dfimrl_in_dficlk + mb_ddr_1d->dfimrlmargin);
+
+	/*
+	 * mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDBYTE | CBRD | CSR_DFIMRL_ADDR))),
+	 *               dfimrl);
+	 */
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+
+		c_addr = byte << 12;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDBYTE | c_addr |
+								CSR_DFIMRL_ADDR))),
+			      dfimrl);
+	}
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTMRL_ADDR))), dfimrl);
+}
+
+/*
+ * Program txdqsdlytg0/1[9:0]:
+ *
+ *         txdqsdlytg*[9:6] = floor( (4*UI + tstaoff) / UI)
+ *         txdqsdlytg*[5:0] = ceiling( (tstaoff%UI / UI) * 32)
+ *
+ * tstaoff and UI expressed in ps
+ *
+ * For HMD and LPDDR4X and MEMCLK <= 533 mhz:
+ *    txdqsdlytg*[9:6] = 0x5
+ *
+ * For other dimm types, leave TDqsDlyTg*[9:0] at default 0x100
+ *
+ * ppp_0001_cccc_uuuu_1101_0000
+ *
+ * if DDR3 or DDR4
+ *      num_timingroup = numrank_dfi0;
+ * else
+ *      num_timingroup = numrank_dfi0 + numrank_dfi1 * dfi1exists;
+ */
+static void txdqsdlytg_program(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d,
+			       uint16_t *txdqsdly)
+{
+	uint32_t byte;
+	int txdqsdlytg_5to0; /* Fine delay - 1/32UI per increment */
+	int txdqsdlytg_9to6; /* Coarse delay - 1UI per increment */
+	int txdqsdlytg_fine_default = 0;
+	int txdqsdlytg_coarse_default = 4;
+	long long tmp_value;
+	long long uifs;
+
+	uifs = (1000 * 1000000) / ((int)config->uib.frequency * 2);
+
+	txdqsdlytg_9to6 = (int)(((int)((txdqsdlytg_coarse_default * uifs) / 1000) +
+				 timings.tstaoff + timings.tcasl_add
+				 - timings.tpdm) / (int)(uifs / 1000));
+
+	tmp_value = fmodll(((txdqsdlytg_fine_default * uifs / 32) +
+			    ((timings.tstaoff + timings.tcasl_add) * 1000) -
+			    (timings.tpdm * 1000)),
+			   uifs);
+	txdqsdlytg_5to0 = (int)(tmp_value / uifs * 32);
+	if ((tmp_value % uifs) != 0) {
+		txdqsdlytg_5to0++;
+	}
+
+	/* Bit-5 of LCDL is no longer used, so bumping bit-5 of fine_dly up to coarse_dly */
+	if (txdqsdlytg_5to0 >= 32) {
+		txdqsdlytg_9to6 = txdqsdlytg_9to6 + 1;
+		txdqsdlytg_5to0 = txdqsdlytg_5to0 - 32;
+	}
+
+	*txdqsdly = (uint16_t)((txdqsdlytg_9to6 << 6) | txdqsdlytg_5to0);
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t nibble;
+
+		c_addr = byte << 12;
+		for (nibble = 0U; nibble < 2U; nibble++) {
+			uint32_t u_addr;
+
+			if (ddrphy_phyinit_isdbytedisabled(config, mb_ddr_1d, byte) != 0) {
+				continue;
+			}
+
+			u_addr = nibble << 8;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			if ((mb_ddr_1d->cspresent & 0x1U) != 0U) {
+#else /* STM32MP_LPDDR4_TYPE */
+			if (((mb_ddr_1d->cspresentcha & 0x1U) |
+			     (mb_ddr_1d->cspresentchb & 0x1U)) != 0U) {
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr | u_addr |
+								     CSR_TXDQSDLYTG0_ADDR))),
+					      *txdqsdly);
+			}
+
+#if STM32MP_LPDDR4_TYPE
+			if ((((mb_ddr_1d->cspresentcha & 0x2U) >> 1) |
+			     ((mb_ddr_1d->cspresentchb & 0x2U) >> 1)) != 0U) {
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr | u_addr |
+								     CSR_TXDQSDLYTG1_ADDR))),
+					      *txdqsdly);
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+	}
+}
+
+/*
+ * ##############################################################
+ *
+ * Program txdqdlyTg0/1[8:0]:
+ *
+ *     txdqdlyTg*[8:6] = floor( (txdqsdlytg*[5:0]*UI/32 + tDQS2DQ + 0.5UI) / UI)
+ *     txdqdlyTg*[5:0] = ceil( ((txdqsdlytg*[5:0]*UI/32 + tDQS2DQ + 0.5UI)%UI / UI) * 32)
+ *
+ * ##############################################################
+ */
+static void txdqdlytg_program(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d,
+			      uint16_t txdqsdly)
+{
+	uint32_t byte;
+	int txdqdly_5to0; /* Fine delay - 1/32UI per increment */
+	int txdqdly_8to6; /* Coarse delay - 1UI per increment */
+	int txdqsdlytg_5to0; /* Fine delay - 1/32UI per increment */
+	long long tmp_value;
+	long long uifs;
+	uint16_t txdqdly;
+
+	uifs = (1000 * 1000000) / ((int)config->uib.frequency * 2);
+
+	txdqsdlytg_5to0 = (int)txdqsdly & 0x3F;
+
+	txdqdly_8to6 = (int)(((txdqsdlytg_5to0 * uifs / 32) + (uifs / 2)) / uifs);
+	tmp_value = fmodll(((txdqsdlytg_5to0 * uifs / 32) + (uifs / 2)), uifs);
+	txdqdly_5to0 = (int)(((tmp_value * 32) / uifs));
+	if ((tmp_value % uifs) != 0) {
+		txdqdly_5to0++;
+	}
+
+	/* Bit-5 of LCDL is no longer used, so bumping bit-5 of fine_dly up to coarse_dly */
+	if (txdqdly_5to0 >= 32) {
+		txdqdly_8to6 = txdqdly_8to6 + 1;
+		txdqdly_5to0 = txdqdly_5to0 - 32;
+	}
+
+	txdqdly = (uint16_t)((txdqdly_8to6 << 6) | txdqdly_5to0);
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t lane;
+
+		c_addr = byte << 12;
+		for (lane = 0U; lane < 9U; lane++) {
+			uint32_t r_addr;
+
+			if (ddrphy_phyinit_isdbytedisabled(config, mb_ddr_1d, byte) != 0) {
+				continue;
+			}
+
+			r_addr = lane << 8;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			if ((mb_ddr_1d->cspresent & 0x1U) != 0U) {
+#else /* STM32MP_LPDDR4_TYPE */
+			if (((mb_ddr_1d->cspresentcha & 0x1U) |
+			     (mb_ddr_1d->cspresentchb & 0x1U)) != 0U) {
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr | r_addr |
+								     CSR_TXDQDLYTG0_ADDR))),
+					      txdqdly);
+			}
+
+#if STM32MP_LPDDR4_TYPE
+			if ((((mb_ddr_1d->cspresentcha & 0x2U) >> 1) |
+			     ((mb_ddr_1d->cspresentchb & 0x2U) >> 1)) != 0U) {
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr | r_addr |
+								     CSR_TXDQDLYTG1_ADDR))),
+					      txdqdly);
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+	}
+}
+
+/*
+ * Program rxendly0/1[10:0]:
+ *
+ *         rxendly[10:6] = floor( (4*UI + tDQSCK + tstaoff) / UI)
+ *         rxendly[5:0]  = ceil( ((tDQSCK + tstaoff) % UI) * 32)
+ *
+ * tDQSCK, tstaoff and UI expressed in ps
+ */
+static void rxendly_program(struct stm32mp_ddr_config *config, struct pmu_smb_ddr_1d *mb_ddr_1d)
+{
+	int rxendly_coarse_default = 4;
+	int rxendly_fine_default = 0;
+
+	int backoff_x1000 __unused;
+	int zerobackoff_x1000 __unused;
+	uint32_t byte;
+	int rxendly_10to6; /* Coarse delay - 1UI per increment */
+	int rxendly_5to0; /* Fine delay - 1/32UI per increment */
+	int totfinestep;
+	long long finestepfs; /* Fine steps in fs */
+	long long rxendly_offset_x1000000 = 0; /* 0 Offset is 1UI before the first DQS. */
+	long long totfs;
+	long long uifs;
+	uint16_t rxendly;
+
+	uifs = (1000 * 1000000) / ((int)config->uib.frequency * 2);
+
+#if STM32MP_LPDDR4_TYPE
+	/* Compensate for pptenrxenbackoff */
+	zerobackoff_x1000 = (1000 * 24) / 32;
+	if (config->uia.lp4rxpreamblemode == 1U) {
+		backoff_x1000 = 1000 - ((1000 * 2) / 32);
+	} else {
+		backoff_x1000 = (1000 * (int)config->uia.rxenbackoff) - ((1000 * 2) / 32);
+	}
+
+	if (config->uia.disableretraining == 0U) {
+		rxendly_offset_x1000000 = config->uib.frequency < 333U ?
+					  backoff_x1000 * uifs : zerobackoff_x1000 * uifs;
+	} else {
+		rxendly_offset_x1000000 = zerobackoff_x1000 * uifs;
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	finestepfs = uifs / 32;
+	totfs = ((32 * rxendly_coarse_default * finestepfs) +
+		 (rxendly_fine_default * finestepfs) +
+		 ((timings.tstaoff + timings.tcasl_add +
+		   timings.tpdm) * 1000) + (rxendly_offset_x1000000 / 1000));
+	totfinestep = totfs / finestepfs;
+
+	rxendly_10to6 = totfinestep / 32;
+	rxendly_5to0  = fmodi(totfinestep, 32);
+
+	/* Bit-5 of LCDL is no longer used, so bumping bit-5 of fine_dly up to coarse_dly */
+	if (rxendly_5to0 >= 32) {
+		rxendly_10to6 = rxendly_10to6 + 1;
+		rxendly_5to0 = rxendly_5to0 - 32;
+	}
+
+	rxendly = (uint16_t)((rxendly_10to6 << 6) | rxendly_5to0);
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint32_t nibble;
+
+		c_addr = byte << 12;
+		for (nibble = 0U; nibble < 2U; nibble++) {
+			uint32_t u_addr;
+
+			if (ddrphy_phyinit_isdbytedisabled(config, mb_ddr_1d, byte) != 0) {
+				continue;
+			}
+
+			u_addr = nibble << 8;
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+			if ((mb_ddr_1d->cspresent & 0x1U) != 0) {
+#else /* STM32MP_LPDDR4_TYPE */
+			if (((mb_ddr_1d->cspresentcha & 0x1U) |
+			     (mb_ddr_1d->cspresentchb & 0x1U)) != 0U) {
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr | u_addr |
+								     CSR_RXENDLYTG0_ADDR))),
+					      rxendly);
+			}
+
+#if STM32MP_LPDDR4_TYPE
+			if ((((mb_ddr_1d->cspresentcha & 0x2U) >> 1) |
+			     ((mb_ddr_1d->cspresentchb & 0x2U) >> 1)) != 0U) {
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr | u_addr |
+								     CSR_RXENDLYTG1_ADDR))),
+					      rxendly);
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+	}
+}
+
+#if STM32MP_LPDDR4_TYPE
+/*
+ * Programming Seq0BGPR1/2/3 for LPDDR4
+ */
+static void seq0bgpr_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t extradly = 3U;
+	uint32_t rl = 0U; /* Computed read latency */
+	uint32_t wl = 0U; /* Computed write latency */
+	uint16_t mr_dbi_rd; /* Extracted field from MR */
+	uint16_t mr_rl;
+	uint16_t mr_wl;
+	uint16_t mr_wls;
+	uint16_t regdata;
+
+	mr_rl = (uint16_t)config->uia.lp4rl;	/* RL[2:0] */
+	mr_wl = (uint16_t)config->uia.lp4wl;	/* WL[5:3] */
+	mr_wls = (uint16_t)config->uia.lp4wls;	/* WLS */
+	mr_dbi_rd = (uint16_t)config->uia.lp4dbird; /* DBI-RD */
+
+	switch ((mr_dbi_rd << 3) | mr_rl) {
+		/* DBI-RD Disabled */
+	case  0U:
+		rl = 6U;
+		break;
+	case  1U:
+		rl = 10U;
+		break;
+	case  2U:
+		rl = 14U;
+		break;
+	case  3U:
+		rl = 20U;
+		break;
+	case  4U:
+		rl = 24U;
+		break;
+	case  5U:
+		rl = 28U;
+		break;
+	case  6U:
+		rl = 32U;
+		break;
+	case  7U:
+		rl = 36U;
+		break;
+		/* DBI-RD Enabled */
+	case  8U:
+		rl = 6U;
+		break;
+	case  9U:
+		rl = 12U;
+		break;
+	case 10U:
+		rl = 16U;
+		break;
+	case 11U:
+		rl = 22U;
+		break;
+	case 12U:
+		rl = 28U;
+		break;
+	case 13U:
+		rl = 32U;
+		break;
+	case 14U:
+		rl = 36U;
+		break;
+	case 15U:
+		rl = 40U;
+		break;
+	default:
+		rl = 6U;
+		break;
+	}
+
+	switch ((mr_wls << 3) | mr_wl) {
+		/* DBI-RD Disabled */
+	case  0U:
+		wl = 4U;
+		break;
+	case  1U:
+		wl = 6U;
+		break;
+	case  2U:
+		wl = 8U;
+		break;
+	case  3U:
+		wl = 10U;
+		break;
+	case  4U:
+		wl = 12U;
+		break;
+	case  5U:
+		wl = 14U;
+		break;
+	case  6U:
+		wl = 16U;
+		break;
+	case  7U:
+		wl = 18U;
+		break;
+		/* DBI-RD Enabled */
+	case  8U:
+		wl = 4U;
+		break;
+	case  9U:
+		wl = 8U;
+		break;
+	case 10U:
+		wl = 12U;
+		break;
+	case 11U:
+		wl = 18U;
+		break;
+	case 12U:
+		wl = 22U;
+		break;
+	case 13U:
+		wl = 26U;
+		break;
+	case 14U:
+		wl = 30U;
+		break;
+	case 15U:
+		wl = 34U;
+		break;
+	default:
+		wl = 4U;
+		break;
+	}
+
+
+	/* Program Seq0b_GPRx */
+	regdata = (uint16_t)((rl - 5U + extradly) << CSR_ACSMRCASLAT_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (P0 | C0 | TINITENG | R2 |
+							CSR_SEQ0BGPR1_ADDR))),
+		      regdata);
+
+	regdata = (uint16_t)((wl - 5U + extradly) << CSR_ACSMWCASLAT_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (P0 | C0 | TINITENG | R2 |
+							CSR_SEQ0BGPR2_ADDR))),
+		      regdata);
+
+	regdata = (uint16_t)((rl - 5U + extradly + 4U + 8U) << CSR_ACSMRCASLAT_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (P0 | C0 | TINITENG | R2 |
+							CSR_SEQ0BGPR3_ADDR))),
+		      regdata);
+}
+
+/*
+ * Program hwtlpcsena and hwtlpcsenb based on number of ranks per channel
+ * Applicable only for LPDDR4.  These CSRs have no effect for DDR3/4.
+ *
+ * CSRs to program:
+ *      hwtlpcsena
+ *      hwtlpcsenb
+ *
+ * User input dependencies:
+ *      config->uib.numrank_dfi0
+ *      config->uib.numrank_dfi1
+ *      config->uib.dfi1exists
+ *      config->uib.numactivedbytedfi1
+ */
+static void hwtlpcsen_program(struct stm32mp_ddr_config *config)
+{
+	uint16_t hwtlpcsena;
+	uint16_t hwtlpcsenb;
+
+	/* Channel A - 1'b01 if signal-rank, 2'b11 if dual-rank */
+	hwtlpcsena = (uint16_t)config->uib.numrank_dfi0 | 0x1U;
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTLPCSENA_ADDR))),
+		      hwtlpcsena);
+
+	/*
+	 * Channel B - 1'b01 if signal-rank, 2'b11 if dual-rank
+	 * If DFI1 exists but disabled, numrank_dfi0 is used to program CsEnB
+	 */
+	if ((config->uib.dfi1exists != 0U) && (config->uib.numactivedbytedfi1 == 0U)) {
+		hwtlpcsenb = (uint16_t)config->uib.numrank_dfi0 | 0x1U;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTLPCSENB_ADDR))),
+			      hwtlpcsenb);
+	} else if ((config->uib.dfi1exists != 0U) && (config->uib.numactivedbytedfi1 > 0U)) {
+		hwtlpcsenb = (uint16_t)config->uib.numrank_dfi1 | 0x1U;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTLPCSENB_ADDR))),
+			      hwtlpcsenb);
+	} else {
+		/* Disable Channel B */
+		hwtlpcsenb = 0x0U;
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTLPCSENB_ADDR))),
+			      hwtlpcsenb);
+	}
+}
+
+/*
+ * Program pptdqscntinvtrntg0 and pptdqscntinvtrntg1
+ * Calculated based on tDQS2DQ and Frequencey
+ * Applicable to LPDDR4 only
+ *
+ * 65536*(tdqs2dq_value_rank<rank>_chan<chan>*2)/(2*2048*UI(ps)_int)
+ *
+ * CSRs to program:
+ *      pptdqscntinvtrntg0
+ *      pptdqscntinvtrntg1
+ *
+ * User input dependencies:
+ *      config->uib.numrank_dfi0
+ *      config->uib.numrank_dfi1
+ *      config->uib.dfi1exists
+ *      config->uib.numdbyte
+ */
+static void pptdqscntinvtrntg_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t numrank_total = config->uib.numrank_dfi0;
+	uint32_t rank;
+
+	/* Calculate total number of timing groups (ranks) */
+	if (config->uib.dfi1exists != 0U) {
+		numrank_total += config->uib.numrank_dfi1;
+	}
+
+	/* Set per timing group */
+	for (rank = 0U; rank < numrank_total; rank++) {
+		uint32_t byte;
+		for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+			uint32_t c_addr;
+
+			c_addr = byte << 12;
+			if (rank == 0U) {
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr |
+							       CSR_PPTDQSCNTINVTRNTG0_ADDR))),
+					      0U);
+			} else if (rank == 1U) {
+				mmio_write_16((uintptr_t)
+					      (DDRPHYC_BASE + (4U * (TDBYTE | c_addr |
+							       CSR_PPTDQSCNTINVTRNTG1_ADDR))),
+					      0U);
+			}
+		}
+	}
+}
+
+/*
+ * CSRs to program:
+ *      PptCtlStatic:: DOCByteSelTg0/1
+ *                   :: pptenrxenbackoff
+ *
+ * User input dependencies::
+ *      config->uib.numdbyte
+ *      config->uib.numrank_dfi0
+ *      config->uib.numrank_dfi1
+ *      config->uia.lp4rxpreamblemode
+ *      config->uia.rxenbackoff
+ *      config->uia.drambyteswap
+ */
+static void pptctlstatic_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t byte;
+	uint32_t pptenrxenbackoff;
+
+	/*
+	 * The customer will setup some fields in this csr so the fw needs to do a
+	 * read-modify-write here.
+	 */
+
+	if (config->uia.lp4rxpreamblemode == 1U) {
+		/* Rx-preamble mode for PS0 */
+		/* Programming PptCtlStatic detected toggling preamble */
+		pptenrxenbackoff = 0x1U; /* Toggling RD_PRE */
+	} else {
+		pptenrxenbackoff = config->uia.rxenbackoff; /* Static RD_PRE */
+	}
+
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		uint32_t c_addr;
+		uint16_t regdata;
+		uint8_t pptentg1;
+		uint32_t docbytetg0;
+		uint32_t docbytetg1;
+
+		/* Each Dbyte could have a different configuration */
+		c_addr = byte * C1;
+		if ((byte % 2) == 0) {
+			docbytetg0 = 0x1U & (config->uia.drambyteswap >> byte);
+			docbytetg1 = 0x1U & (config->uia.drambyteswap >> byte);
+		} else {
+			docbytetg0 = 0x1U & (~(config->uia.drambyteswap >> byte));
+			docbytetg1 = 0x1U & (~(config->uia.drambyteswap >> byte));
+		}
+
+		pptentg1 = ((config->uib.numrank_dfi0 == 2U) || (config->uib.numrank_dfi1 == 2U)) ?
+			   0x1U : 0x0U;
+		regdata = (uint16_t)((0x1U << CSR_PPTENDQS2DQTG0_LSB) |
+				     (pptentg1 << CSR_PPTENDQS2DQTG1_LSB) |
+				     (0x1U << CSR_PPTENRXENDLYTG0_LSB) |
+				     (pptentg1 << CSR_PPTENRXENDLYTG1_LSB) |
+				     (pptenrxenbackoff << CSR_PPTENRXENBACKOFF_LSB) |
+				     (docbytetg0 << CSR_DOCBYTESELTG0_LSB) |
+				     (docbytetg1 << CSR_DOCBYTESELTG1_LSB));
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (c_addr | TDBYTE |
+								CSR_PPTCTLSTATIC_ADDR))),
+			      regdata);
+	}
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+/*
+ * Program hwtcamode based on dram type
+ *
+ * CSRs to program:
+ *      hwtcamode::hwtlp3camode
+ *               ::hwtd4camode
+ *               ::hwtlp4camode
+ *               ::hwtd4altcamode
+ *               ::hwtcsinvert
+ *               ::hwtdbiinvert
+ */
+static void hwtcamode_program(void)
+{
+	uint32_t hwtlp3camode = 0U;
+	uint32_t hwtd4camode = 0U;
+	uint32_t hwtlp4camode = 0U;
+	uint32_t hwtd4altcamode = 0U;
+	uint32_t hwtcsinvert = 0U;
+	uint32_t hwtdbiinvert = 0U;
+	uint16_t hwtcamode;
+
+#if STM32MP_DDR4_TYPE
+	hwtd4camode = 1U;
+#elif STM32MP_LPDDR4_TYPE
+	hwtlp4camode = 1U;
+	hwtcsinvert = 1U;
+	hwtdbiinvert = 1U;
+#else /* STM32MP_DDR3_TYPE */
+	/* Nothing to declare */
+#endif /* STM32MP_DDR4_TYPE */
+
+	hwtcamode = (uint16_t)((hwtdbiinvert << CSR_HWTDBIINVERT_LSB) |
+			       (hwtcsinvert << CSR_HWTCSINVERT_LSB) |
+			       (hwtd4altcamode << CSR_HWTD4ALTCAMODE_LSB) |
+			       (hwtlp4camode << CSR_HWTLP4CAMODE_LSB) |
+			       (hwtd4camode << CSR_HWTD4CAMODE_LSB) |
+			       (hwtlp3camode << CSR_HWTLP3CAMODE_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTCAMODE_ADDR))), hwtcamode);
+}
+
+/*
+ * Program DllGainCtl and DllLockParam based on frequency
+ */
+static void dllgainctl_dlllockparam_program(struct stm32mp_ddr_config *config)
+{
+	uint32_t dllgainiv;
+	uint32_t dllgaintv;
+	uint32_t lcdlseed;
+	uint32_t memck_freq;
+	uint32_t stepsize_x10 = 47U;	/*
+					 * Nominal stepsize, in units of tenths of a ps,
+					 * if nominal=4.7ps use 47
+					 */
+	uint16_t wddllgainctl;
+	uint16_t wddlllockparam;
+
+	memck_freq = config->uib.frequency;
+
+	/*
+	 * lcdlseed = ((1000000/memck_freq)/2)/lcdl_stepsize  ...
+	 * where default lcdl_stepsize=4.7 in simulation.
+	 */
+	if (memck_freq >= 1200U) {
+		dllgainiv = 0x04U;
+		dllgaintv = 0x05U;
+	} else if (memck_freq >= 800U) {
+		dllgainiv = 0x03U;
+		dllgaintv = 0x05U;
+	} else if (memck_freq >= 532U) {
+		dllgainiv = 0x02U;
+		dllgaintv = 0x04U;
+	} else if (memck_freq >= 332U) {
+		dllgainiv = 0x01U;
+		dllgaintv = 0x03U;
+	} else {
+		dllgainiv = 0x00U;
+		dllgaintv = 0x02U;
+	}
+
+	/*
+	 * lcdlseed= (1000000/(2*memck_freq)) * (100/(120*(stepsize_nominal)));
+	 * *100/105 is to bias the seed low.
+	 */
+	lcdlseed = (1000000U * 10U * 100U) / (2U * memck_freq * stepsize_x10 * 105U);
+
+	if (lcdlseed > (511U - 32U)) {
+		lcdlseed = 511U - 32U;
+	}
+
+	if (lcdlseed < 32U) {
+		lcdlseed = 32U;
+	}
+
+	wddllgainctl = (uint16_t)((CSR_DLLGAINTV_MASK & (dllgaintv << CSR_DLLGAINTV_LSB)) |
+				  (CSR_DLLGAINIV_MASK & (dllgainiv << CSR_DLLGAINIV_LSB)));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DLLGAINCTL_ADDR))),
+		      wddllgainctl);
+
+
+	wddlllockparam = (uint16_t)((CSR_LCDLSEED0_MASK & (lcdlseed << CSR_LCDLSEED0_LSB)) |
+				    (CSR_DISDLLGAINIVSEED_MASK & 0xFFFFU));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_DLLLOCKPARAM_ADDR))),
+		      wddlllockparam);
+}
+
+/*
+ * Program AcsmCtrl23 for Fw and Ppt.
+ *
+ * CSRs to program:
+ *   AcsmCtrl23::AcsmCsMask
+ *               AcsmCsMode
+ */
+static void acsmctrl23_program(void)
+{
+	uint16_t regdata;
+
+	regdata = (0x0FU << CSR_ACSMCSMASK_LSB) | (0x1U << CSR_ACSMCSMODE_LSB);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (C0 | TACSM | CSR_ACSMCTRL23_ADDR))),
+		      regdata);
+}
+
+/*
+ * Set PllForceCal to 1 and PllDacValIn to some arbitrary value
+ */
+static void pllforcecal_plldacvalin_program(void)
+{
+	uint32_t dacval_in = 0x10U;
+	uint32_t force_cal = 0x1U;
+	uint32_t pllencal = 0x1U;
+	uint32_t maxrange = 0x1FU;
+	uint16_t pllctrl3_gpr;
+	uint16_t pllctrl3_startup;
+
+	pllctrl3_startup = (uint16_t)((dacval_in << CSR_PLLDACVALIN_LSB) |
+				      (maxrange << CSR_PLLMAXRANGE_LSB));
+	pllctrl3_gpr = pllctrl3_startup | (uint16_t)((force_cal << CSR_PLLFORCECAL_LSB) |
+						     (pllencal << CSR_PLLENCAL_LSB));
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_PLLCTRL3_ADDR))),
+		      pllctrl3_startup);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_SEQ0BGPR6_ADDR))),
+		      pllctrl3_gpr);
+}
+
+/*
+ * This function programs registers that are normally set by training
+ * firmware.
+ *
+ * This function is used in place of running 1D or 1D training steps. PhyInit
+ * calls this function when skip_train = true. In that case, PhyInit does not
+ * execute training firmware and this function is called instead to program
+ * PHY registers according to DRAM timing parameters specified in userInput
+ * data structure. See documentation of ddrphy_phyinit_struct.h file
+ * details of timing parameters available in skip training.
+ *
+ * \warning ddrphy_phyinit_progcsrskiptrain() only supports zero board
+ * delay model. If system board delays are set or randomized, full 1D or 1D
+ * initialization flow must be executed.
+ *
+ * This function replaces these steps in the PHY Initialization sequence:
+ *  - (E) Set the PHY input clocks to the desired frequency
+ *  - (F) Write the Message Block parameters for the training firmware
+ *  - (G) Execute the Training Firmware
+ *  - (H) Read the Message Block results
+ *
+ * \returns \c void
+ */
+void ddrphy_phyinit_progcsrskiptrain(struct stm32mp_ddr_config *config,
+				     struct pmu_smb_ddr_1d *mb_ddr_1d, uint32_t ardptrinitval)
+{
+	uint16_t txdqsdly;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * Program ATxDlY
+	 * For DDR4, DDR3 and LPDDR4, leave AtxDly[6:0] at default (0x0)
+	 */
+
+	dfimrl_program(config, mb_ddr_1d, ardptrinitval);
+
+	txdqsdlytg_program(config, mb_ddr_1d, &txdqsdly);
+
+	txdqdlytg_program(config, mb_ddr_1d, txdqsdly);
+
+	rxendly_program(config, mb_ddr_1d);
+
+#if STM32MP_LPDDR4_TYPE
+	seq0bgpr_program(config);
+
+	hwtlpcsen_program(config);
+
+	pptdqscntinvtrntg_program(config);
+
+	pptctlstatic_program(config);
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	hwtcamode_program();
+
+	dllgainctl_dlllockparam_program(config);
+
+	acsmctrl23_program();
+
+	pllforcecal_plldacvalin_program();
+
+	/*
+	 * ##############################################################
+	 *
+	 * Setting PhyInLP3 to 0 to cause PIE to execute LP2 sequence instead of INIT on first
+	 * dfi_init_start.
+	 * This prevents any DRAM commands before DRAM is initialized, which is the case for
+	 * skip_train.
+	 *
+	 * Moved to here from dddrphy_phyinit_I_loadPIEImage()
+	 * These should not be needed on S3-exit
+	 *
+	 * Note this executes for SkipTrain only, *not* DevInit+SkipTrain
+	 * DevInit+SkipTrain already initializes DRAM and thus don't need to avoid DRAM commands
+	 *
+	 * ##############################################################
+	 */
+
+	/*
+	 * Special skipTraining configuration to Prevent DRAM Commands on the first dfi
+	 * status interface handshake. In order to see this behavior, the first dfi_freq
+	 * should be in the range of 0x0f < dfi_freq_sel[4:0] < 0x14.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TINITENG | CSR_PHYINLP3_ADDR))), 0x0U);
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c
new file mode 100644
index 0000000000..b19af14790
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*
+ * This file provides a group of functions that are used to track PHY register
+ * writes by intercepting io_write16 function calls.  Once the registers are
+ * tracked, their value can be saved at a given time spot, and restored later
+ * as required. This implementation is useful to capture any PHY register
+ * programing in any function during PHY initialization.
+ */
+
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * MAX_NUM_RET_REGS default Max number of retention registers.
+ *
+ * This define is only used by the PhyInit Register interface to define the max
+ * amount of registered that can be saved. The user may increase this variable
+ * as desired if a larger number of registers need to be restored.
+ */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+#define MAX_NUM_RET_REGS	129
+#else /* STM32MP_LPDDR4_TYPE */
+#define MAX_NUM_RET_REGS	283
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+/*
+ * Array of Address/value pairs used to store register values for the purpose
+ * of retention restore.
+ */
+#define RETREG_AREA	(MAX_NUM_RET_REGS + 1) * sizeof(struct reg_addr_val)
+#define RETREG_BASE	RETRAM_BASE + RETRAM_SIZE - RETREG_AREA
+
+static int *retregsize = (int *)(RETREG_BASE);
+static struct reg_addr_val *retreglist = (struct reg_addr_val *)(RETREG_BASE + sizeof(int));
+
+static int numregsaved; /* Current Number of registers saved. */
+static int tracken = 1; /* Enabled tracking of registers */
+
+/*
+ * Tags a register if tracking is enabled in the register
+ * interface.
+ *
+ * During PhyInit registers writes, keeps track of address
+ * for the purpose of restoring the PHY register state during PHY
+ * retention exit process. Tracking can be turned on/off via the
+ * ddrphy_phyinit_reginterface STARTTRACK, STOPTRACK instructions. By
+ * default tracking is always turned on.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_trackreg(uint32_t adr)
+{
+	int regindx = 0;
+
+	/* Return if tracking is disabled */
+	if (tracken == 0) {
+		return 0;
+	}
+
+	/* Search register address within the array */
+	for (regindx = 0; regindx < numregsaved; regindx++) {
+		if (retreglist[regindx].address == adr) {
+			/* Register found */
+			return 0;
+		}
+	}
+
+	/* Register not found, so add it */
+	if (numregsaved > MAX_NUM_RET_REGS) {
+		ERROR("numregsaved > MAX_NUM_RET_REGS\n");
+		VERBOSE("[ddrphy_phyinit_reginterface:ddrphy_phyinit_trackreg]\n");
+		VERBOSE("Max Number of Restore Registers reached: %d.\n", numregsaved);
+		VERBOSE("Please recompile PhyInit with larger MAX_NUM_RET_REG value.\n");
+		return -1;
+	}
+
+	retreglist[regindx].address = adr;
+	numregsaved++;
+
+	return 0;
+}
+
+/*
+ * Register interface function used to track, save and restore retention registers.
+ *
+ * ### Usage
+ * Register tracking is enabled by calling:
+ *
+ *  \code
+ *  ddrphy_phyinit_reginterface(STARTTRACK,0,0);
+ *  \endcode
+ *
+ * from this point on any call to mmio_write_16() in
+ * return will be capture by the register interface via a call to
+ * ddrphy_phyinit_trackreg(). Tracking is disabled by calling:
+ *
+ *  \code
+ *  ddrphy_phyinit_reginterface(STOPTRACK,0,0);
+ *  \endcode
+ *
+ * On calling this function, register write via mmio_write_16 are no longer tracked until a
+ * STARTTRACK call is made. Once all the register write are complete, SAVEREGS
+ * command can be issue to save register values into the internal data array of
+ * the register interface. Upon retention exit RESTOREREGS are command can be
+ * used to issue register write commands to the PHY based on values stored in
+ * the array.
+ *  \code
+ *   ddrphy_phyinit_reginterface(SAVEREGS,0,0);
+ *   ddrphy_phyinit_reginterface(RESTOREREGS,0,0);
+ *  \endcode
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_reginterface(enum reginstr myreginstr, uint32_t adr, uint16_t dat)
+{
+	if (myreginstr == SAVEREGS) {
+		int regindx;
+
+		/*
+		 * Go through all the tracked registers, issue a register read and place
+		 * the result in the data structure for future recovery.
+		 */
+		for (regindx = 0; regindx < numregsaved; regindx++) {
+			uint16_t data;
+
+			data = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							(4U * retreglist[regindx].address)));
+			retreglist[regindx].value = data;
+		}
+
+		*retregsize = numregsaved;
+
+		return 0;
+	} else if (myreginstr == RESTOREREGS) {
+		int regindx;
+
+		/*
+		 * Write PHY registers based on Address, Data value pairs stores in
+		 * retreglist.
+		 */
+		for (regindx = 0; regindx < *retregsize; regindx++) {
+			mmio_write_16((uintptr_t)
+				      (DDRPHYC_BASE + (4U * retreglist[regindx].address)),
+				      retreglist[regindx].value);
+		}
+
+		return 0;
+	} else if (myreginstr == STARTTRACK) {
+		/* Enable tracking */
+		tracken = 1;
+		return 0;
+	} else if (myreginstr == STOPTRACK) {
+		/* Disable tracking */
+		tracken = 0;
+		return 0;
+	} else {
+		return -1;
+	}
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c
new file mode 100644
index 0000000000..f682cabd46
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function implements the register restore portion of S3/IO
+ * retention sequence.
+ *
+ * \note This function requiers the runtime_config.reten=1 to enable PhyInit exit retention feature.
+ * This variable can be set as in
+ * \return 0 on completion of the sequence, EXIT_FAILURE on error.
+ */
+int ddrphy_phyinit_restore_sequence(void)
+{
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * Before you call this functions perform the following:
+	 * --------------------------------------------------------------------------
+	 * -# Bring up VDD, VDDQ should already be up
+	 * -# Since the CKE* and MEMRESET pin state must be protected, special care
+	 *    must be taken to ensure that the following signals
+	 *    - atpg_mode = 1'b0
+	 *    - PwrOkIn = 1'b0
+	 *
+	 * -# The {BypassModeEn*, WRSTN} signals may be defined at VDD power-on, but
+	 *    must be driven to ZERO at least 10ns prior to the asserting edge of PwrOkIn.
+	 *
+	 * -# Start Clocks and Reset the PHY
+	 *    This step is identical to ddrphy_phyinit_usercustom_b_startclockresetphy()
+	 */
+
+	/* Write the MicroContMuxSel CSR to 0x0 to allow access to the internal CSRs */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x0U);
+
+	/*
+	 * Write the UcclkHclkEnables CSR to 0x3 to enable all the clocks so the reads can
+	 * complete.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR))),
+		      0x3U);
+
+	/*
+	 * Assert CalZap to force impedance calibration FSM to idle.
+	 * De-asserted as part of dfi_init_start/complete handshake by the PIE when DfiClk is valid.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_CALZAP_ADDR))), 0x1U);
+
+	/* Issue register writes to restore registers values */
+	ret = ddrphy_phyinit_reginterface(RESTOREREGS, 0U, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/*
+	 * Write the UcclkHclkEnables CSR to disable the appropriate clocks after all reads done.
+	 * Disabling Ucclk (PMU) and Hclk (training hardware).
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR))),
+		      0x0U);
+
+	/* Write the MicroContMuxSel CSR to 0x1 to isolate the internal CSRs during mission mode */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x1U);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c
new file mode 100644
index 0000000000..f8d0327966
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * This function implements the flow of PhyInit software to initialize the PHY.
+ *
+ * The execution sequence follows the overview figure provided in the Reference Manual.
+ *
+ * \returns 0 on completion of the sequence, EXIT_FAILURE on error.
+ */
+int ddrphy_phyinit_sequence(struct stm32mp_ddr_config *config, bool skip_training, bool reten)
+{
+	int ret;
+	uint32_t ardptrinitval;	/*
+				 * Represents the value stored in Step C into the register with the
+				 * same name. Defined as a global variable so that implementation
+				 * of ddrphy_phyinit_progcsrskiptrain() function does not require
+				 * a PHY read register implementation.
+				 */
+	struct pmu_smb_ddr_1d mb_ddr_1d; /* Firmware 1D Message Block structure */
+
+	/* Check user input pstate number consistency vs. SW capabilities */
+	if (config->uib.numpstates > 1U) {
+		return -1;
+	}
+
+	VERBOSE("%s Start\n", __func__);
+
+	/* Initialize structures */
+	ddrphy_phyinit_initstruct(config, &mb_ddr_1d);
+
+	/* Re-calculate Firmware Message Block input based on final user input */
+	ret = ddrphy_phyinit_calcmb(config, &mb_ddr_1d);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* (A) Bring up VDD, VDDQ, and VAA */
+	/* ddrphy_phyinit_usercustom_a_bringuppower(); */
+
+	/* (B) Start Clocks and Reset the PHY */
+	/* ddrphy_phyinit_usercustom_b_startclockresetphy(); */
+
+	/* (C) Initialize PHY Configuration */
+	ret = ddrphy_phyinit_c_initphyconfig(config, &mb_ddr_1d, &ardptrinitval);
+	if (ret != 0) {
+		return ret;
+	}
+	/*
+	 * Customize any register write desired; This can include any CSR not covered by PhyInit
+	 * or user wish to override values calculated in step_C.
+	 */
+	ddrphy_phyinit_usercustom_custompretrain(config);
+
+	/* Stop retention register tracking for training firmware related registers */
+	ret = ddrphy_phyinit_reginterface(STOPTRACK, 0U, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (skip_training) {
+		/* Skip running training firmware entirely */
+		ddrphy_phyinit_progcsrskiptrain(config, &mb_ddr_1d, ardptrinitval);
+	} else {
+		/* (D) Load the IMEM Memory for 1D training */
+		ddrphy_phyinit_d_loadimem();
+
+		/* (E) Set the PHY input clocks to the desired frequency */
+		/* ddrphy_phyinit_usercustom_e_setdficlk(pstate); */
+
+		/* (F) Write the Message Block parameters for the training firmware */
+		ret = ddrphy_phyinit_f_loaddmem(config, &mb_ddr_1d);
+		if (ret != 0) {
+			return ret;
+		}
+
+		/* (G) Execute the Training Firmware */
+		ret = ddrphy_phyinit_g_execfw();
+		if (ret != 0) {
+			return ret;
+		}
+
+		/* (H) Read the Message Block results */
+		/* ddrphy_phyinit_h_readmsgblock(); */
+	}
+
+	/* Start retention register tracking for training firmware related registers */
+	ret = ddrphy_phyinit_reginterface(STARTTRACK, 0U, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* (I) Load PHY Init Engine Image */
+	ddrphy_phyinit_i_loadpieimage(config, skip_training);
+
+	/*
+	 * Customize any CSR write desired to override values programmed by firmware or
+	 * ddrphy_phyinit_i_loadpieimage()
+	 */
+	/* ddrphy_phyinit_usercustom_customposttrain(); */
+
+	if (reten) {
+		/* Save value of tracked registers for retention restore sequence. */
+		ret = ddrphy_phyinit_usercustom_saveretregs(config);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	/* (J) Initialize the PHY to Mission Mode through DFI Initialization */
+	/* ddrphy_phyinit_usercustom_j_entermissionmode(); */
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c
new file mode 100644
index 0000000000..86b084d6f5
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <ddrphy_phyinit.h>
+
+/*
+ * Set messageBlock variable only if not set by user
+ *
+ * This function is used by ddrphy_phyinit_calcmb() to set calculated
+ * messageBlock variables only when the user has not directly programmed them.
+ *
+ * @param[in]   field   A string representing the messageBlock field to be programed.
+ * @param[in]   value   filed value
+ *
+ * @return 0 on success.
+ * On error  returns the following values based on error:
+ * - -1 : message block field specified by the input \c field string is not
+ * found in the message block data structure.
+ */
+int ddrphy_phyinit_softsetmb(struct pmu_smb_ddr_1d *mb_ddr_1d, enum message_block_field field,
+			     uint32_t value)
+{
+	int ret = 0;
+
+	if (field == MB_FIELD_DRAMFREQ) {
+		assert(value <= UINT16_MAX);
+	} else {
+		assert(value <= UINT8_MAX);
+	}
+
+	switch (field) {
+	case MB_FIELD_PSTATE:
+		mb_ddr_1d->pstate = (uint8_t)value;
+		break;
+	case MB_FIELD_PLLBYPASSEN:
+		mb_ddr_1d->pllbypassen = (uint8_t)value;
+		break;
+	case MB_FIELD_DRAMFREQ:
+		mb_ddr_1d->dramfreq = (uint16_t)value;
+		break;
+	case MB_FIELD_DFIFREQRATIO:
+		mb_ddr_1d->dfifreqratio = (uint8_t)value;
+		break;
+	case MB_FIELD_BPZNRESVAL:
+		mb_ddr_1d->bpznresval = (uint8_t)value;
+		break;
+	case MB_FIELD_PHYODTIMPEDANCE:
+		mb_ddr_1d->phyodtimpedance = (uint8_t)value;
+		break;
+	case MB_FIELD_PHYDRVIMPEDANCE:
+		mb_ddr_1d->phydrvimpedance = (uint8_t)value;
+		break;
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	case MB_FIELD_DRAMTYPE:
+		mb_ddr_1d->dramtype = (uint8_t)value;
+		break;
+	case MB_FIELD_DISABLEDDBYTE:
+		mb_ddr_1d->disableddbyte = (uint8_t)value;
+		break;
+	case MB_FIELD_ENABLEDDQS:
+		mb_ddr_1d->enableddqs = (uint8_t)value;
+		break;
+	case MB_FIELD_PHYCFG:
+		mb_ddr_1d->phycfg = (uint8_t)value;
+		break;
+#if STM32MP_DDR4_TYPE
+	case MB_FIELD_X16PRESENT:
+		mb_ddr_1d->x16present = (uint8_t)value;
+		break;
+#endif /* STM32MP_DDR4_TYPE */
+#else /* STM32MP_LPDDR4_TYPE */
+	case MB_FIELD_ENABLEDDQSCHA:
+		mb_ddr_1d->enableddqscha = (uint8_t)value;
+		break;
+	case MB_FIELD_CSPRESENTCHA:
+		mb_ddr_1d->cspresentcha = (uint8_t)value;
+		break;
+	case MB_FIELD_ENABLEDDQSCHB:
+		mb_ddr_1d->enableddqschb = (uint8_t)value;
+		break;
+	case MB_FIELD_CSPRESENTCHB:
+		mb_ddr_1d->cspresentchb = (uint8_t)value;
+		break;
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+	default:
+		ERROR("unknown message block field %u\n", field);
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
diff --git a/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c
new file mode 100644
index 0000000000..a6fec57607
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * Writes local memory content into the SRAM via APB interface.
+ *
+ * This function issued APB writes commands to SRAM address based on values
+ * stored in a local PhyInit array that contains consolidated IMEM and DMEM
+ * data.
+ * @param[in] mem[] Local memory array.
+ * @param[in] mem_offset offset index. if provided, skips to the offset index
+ * from the local array and issues APB commands from mem_offset to mem_size.
+ * @param[in] mem_size size of the memroy (in mem array index)
+ * @returns void
+ */
+void ddrphy_phyinit_writeoutmem(uint32_t *mem, uint32_t mem_offset, uint32_t mem_size)
+{
+	uint32_t index;
+
+	/*
+	 * 1. Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+	 *    This allows the memory controller unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x0U);
+
+	for (index = 0U; index < mem_size / sizeof(uint32_t); index++) {
+		uint32_t data = mem[index];
+
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * ((index * 2) + mem_offset))),
+			     data & 0xFFFFU);
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * ((index * 2) + 1 + mem_offset))),
+			     (data >> 16) & 0xFFFFU);
+	}
+
+	/*
+	 * 2. Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1.
+	 *    This allows the firmware unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x1U);
+}
+
+/* Similar function for message block */
+void ddrphy_phyinit_writeoutmsgblk(uint16_t *mem, uint32_t mem_offset, uint32_t mem_size)
+{
+	uint32_t index;
+
+	/*
+	 * 1. Enable access to the internal CSRs by setting the MicroContMuxSel CSR to 0.
+	 *    This allows the memory controller unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x0U);
+
+
+	for (index = 0U; index < mem_size / sizeof(uint16_t); index++) {
+		mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (index + mem_offset))), mem[index]);
+	}
+
+	/*
+	 * 2. Isolate the APB access from the internal CSRs by setting the MicroContMuxSel CSR to 1.
+	 *    This allows the firmware unrestricted access to the configuration CSRs.
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x1U);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c
new file mode 100644
index 0000000000..60a06b5aef
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/* DDRDBG registers */
+#define DDRDBG_DDR34_AC_SWIZZLE_ADD3_0		U(0x100)
+
+/*
+ * This function is called before training firmware is executed. Any
+ * register override in this function might affect the firmware training
+ * results.
+ *
+ * This function is executed before firmware execution loop. Thus this function
+ * should be used only for the following:
+ *
+ *  - Override PHY register values written by
+ *  ddrphy_phyinit_c_initphyconfig. An example use case is when this
+ *  function does not perform the exact programing desired by the user.
+ *  - Write custom PHY registers that need to take effect before training
+ *  firmware execution.
+ *
+ * User shall use mmio_write_16 to write PHY registers in order for the register
+ * to be tracked by PhyInit for retention restore.
+ *
+ * To override settings in the message block, users can assign values to the
+ * fields in the message block data structure directly.
+ *
+ * \ref examples/simple/ddrphy_phyinit_usercustom_custompretrain.c example of this function.
+ *
+ * @return Void
+ */
+void ddrphy_phyinit_usercustom_custompretrain(struct stm32mp_ddr_config *config)
+{
+	uint32_t byte __unused;
+	uint32_t i = 0U;
+	uint32_t j;
+	uintptr_t base;
+
+	VERBOSE("%s Start\n", __func__);
+
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	base = (uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_HWTSWIZZLEHWTADDRESS0_ADDR)));
+
+	for (i = 0U; i < NB_HWT_SWIZZLE; i++) {
+		mmio_write_16(base + (i * sizeof(uint32_t)),
+			      (uint16_t)config->uis.swizzle[i]);
+	}
+
+	base = (uintptr_t)(stm32_ddrdbg_get_base() + DDRDBG_DDR34_AC_SWIZZLE_ADD3_0);
+
+	for (j = 0U; j < NB_AC_SWIZZLE; j++, i++) {
+		mmio_write_32(base + (j * sizeof(uint32_t)), config->uis.swizzle[i]);
+	}
+#else /* STM32MP_LPDDR4_TYPE */
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		base = (uintptr_t)(DDRPHYC_BASE + (4U *
+						   ((byte << 12) | TDBYTE | CSR_DQ0LNSEL_ADDR)));
+
+		for (j = 0U; j < NB_DQLNSEL_SWIZZLE_PER_BYTE; j++, i++) {
+			mmio_write_16(base + (j * sizeof(uint32_t)),
+				      (uint16_t)config->uis.swizzle[i]);
+		}
+	}
+
+	base = (uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_MAPCAA0TODFI_ADDR)));
+
+	for (j = 0U; j < NB_MAPCAATODFI_SWIZZLE; j++, i++) {
+		mmio_write_16(base + (j * sizeof(uint32_t)),
+			      (uint16_t)config->uis.swizzle[i]);
+	}
+
+	base = (uintptr_t)(DDRPHYC_BASE + (4U * (TMASTER | CSR_MAPCAB0TODFI_ADDR)));
+
+	for (j = 0U; j < NB_MAPCABTODFI_SWIZZLE; j++, i++) {
+		mmio_write_16(base + (j * sizeof(uint32_t)),
+			      (uint16_t)config->uis.swizzle[i]);
+	}
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+
+	VERBOSE("%s End\n", __func__);
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
new file mode 100644
index 0000000000..59a7b73b8b
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+#include <platform_def.h>
+
+/* Firmware major messages */
+#define FW_MAJ_MSG_TRAINING_SUCCESS	0x0000007U
+#define FW_MAJ_MSG_START_STREAMING	0x0000008U
+#define FW_MAJ_MSG_TRAINING_FAILED	0x00000FFU
+
+#define PHYINIT_DELAY_1US		1U
+#define PHYINIT_DELAY_10US		10U
+#define PHYINIT_TIMEOUT_US_1S		1000000U
+
+static int wait_uctwriteprotshadow(bool state)
+{
+	uint64_t timeout;
+	uint16_t read_data;
+	uint16_t value = state ? BIT(0) : 0U;
+
+	timeout = timeout_init_us(PHYINIT_TIMEOUT_US_1S);
+
+	do {
+		read_data = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+						     (4U * (TAPBONLY | CSR_UCTSHADOWREGS_ADDR))));
+		udelay(PHYINIT_DELAY_1US);
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	} while ((read_data & BIT(0)) != value);
+
+	return 0;
+}
+
+static int ack_message_receipt(void)
+{
+	int ret;
+
+	/* Acknowledge the receipt of the message */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_DCTWRITEPROT_ADDR))), 0U);
+
+	udelay(PHYINIT_DELAY_1US);
+
+	ret = wait_uctwriteprotshadow(true);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Complete the 4-phase protocol */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_DCTWRITEPROT_ADDR))), 1U);
+
+	udelay(PHYINIT_DELAY_1US);
+
+	return 0;
+}
+
+static int get_major_message(uint32_t *msg)
+{
+	uint16_t message_number;
+	int ret;
+
+	ret = wait_uctwriteprotshadow(false);
+	if (ret != 0) {
+		return ret;
+	}
+
+	message_number = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							    (4U * (TAPBONLY |
+								   CSR_UCTWRITEONLYSHADOW_ADDR))));
+
+	ret = ack_message_receipt();
+	if (ret != 0) {
+		return ret;
+	}
+
+	*msg = (uint32_t)message_number;
+
+	return 0;
+}
+
+static int get_streaming_message(uint32_t *msg)
+{
+	uint16_t stream_word_lower_part;
+	uint16_t stream_word_upper_part;
+	int ret;
+
+	ret = wait_uctwriteprotshadow(false);
+	if (ret != 0) {
+		return ret;
+	}
+
+	stream_word_lower_part = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							  (4U * (TAPBONLY |
+								 CSR_UCTWRITEONLYSHADOW_ADDR))));
+
+	stream_word_upper_part = mmio_read_16((uintptr_t)(DDRPHYC_BASE +
+							  (4U * (TAPBONLY |
+								 CSR_UCTDATWRITEONLYSHADOW_ADDR))));
+
+	ret = ack_message_receipt();
+	if (ret != 0) {
+		return ret;
+	}
+
+	*msg = (uint32_t)stream_word_lower_part | ((uint32_t)stream_word_upper_part << 16);
+
+	return 0;
+}
+
+/*
+ * Implements the mechanism to wait for completion of training firmware execution.
+ *
+ * The purpose of user this function is to wait for firmware to finish training.
+ * The user can either implement a counter to wait or implement the polling
+ * mechanism (our choice here). The wait time is highly dependent on the training features
+ * enabled via sequencectrl input to the message block.
+ *
+ * The default behavior of this function is to print comments relating to this
+ * process. A function call of the same name will be printed in the output text
+ * file.
+ *
+ * The user can choose to leave this function as is, or implement mechanism to
+ * trigger mailbox poling event in simulation.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_usercustom_g_waitfwdone(void)
+{
+	uint32_t fw_major_message;
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	do {
+		ret = get_major_message(&fw_major_message);
+		if (ret != 0) {
+			return ret;
+		}
+
+		VERBOSE("fw_major_message = %x\n", (unsigned int)fw_major_message);
+
+		if (fw_major_message == FW_MAJ_MSG_START_STREAMING) {
+			uint32_t i;
+			uint32_t read_data;
+			uint32_t stream_len;
+
+			ret = get_streaming_message(&read_data);
+			if (ret != 0) {
+				return ret;
+			}
+
+			stream_len = read_data & 0xFFFFU;
+
+			for (i = 0U; i < stream_len; i++) {
+				ret = get_streaming_message(&read_data);
+				if (ret != 0) {
+					return ret;
+				}
+
+				VERBOSE("streaming message = %x\n", (unsigned int)read_data);
+			}
+		}
+	} while ((fw_major_message != FW_MAJ_MSG_TRAINING_SUCCESS) &&
+		 (fw_major_message != FW_MAJ_MSG_TRAINING_FAILED));
+
+	udelay(PHYINIT_DELAY_10US);
+
+	if (fw_major_message == FW_MAJ_MSG_TRAINING_FAILED) {
+		ERROR("%s Training has failed.\n", __func__);
+		return -1;
+	}
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
new file mode 100644
index 0000000000..00a75073a8
--- /dev/null
+++ b/drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
@@ -0,0 +1,402 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+/*
+ * This function can be used to implement saving of PHY registers to be
+ * restored on retention exit.
+ *
+ * The requirement of this function is to issue register reads and store the
+ * value to be recovered on retention exit. The following is an example
+ * implementation and the user may implement alternate methods that suit their
+ * specific SoC system needs.
+ *
+ * In this implementation PhyInit saves register values in an internal C array.
+ * During retention exit it restores register values from the array. The exact
+ * list of registers to save and later restore can be seen in the output txt
+ * file with an associated calls to mmio_read_16().
+ *
+ * PhyInit provides a register interface and a tracking mechanism to minimize
+ * the number registers needing restore. Refer to source code for
+ * ddrphy_phyinit_reginterface() for detailed implementation of tracking
+ * mechanism. Tracking is disabled from step D to Step H as these involve
+ * loading, executing and checking the state of training firmware execution
+ * which are not required to implement the retention exit sequence. The registers
+ * specified representing training results are also saved in addition to registers
+ * written by PhyInit during PHY initialization.
+ *
+ * \return 0 on success.
+ */
+int ddrphy_phyinit_usercustom_saveretregs(struct stm32mp_ddr_config *config)
+{
+	uint32_t anib;
+	uint32_t byte;
+	uint32_t nibble;
+	uint32_t lane;
+	uint32_t c_addr;
+	uint32_t u_addr;
+	uint32_t b_addr;
+	uint32_t r_addr;
+	int ret;
+
+	VERBOSE("%s Start\n", __func__);
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 1. Enable tracking of training firmware result registers
+	 *
+	 *    \note  The tagged registers in this step are in
+	 *    addition to what is automatically tagged during Steps C to I.
+	 *
+	 * --------------------------------------------------------------------------
+	 */
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_PLLCTRL3_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Non-PState Dbyte Registers */
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		c_addr = byte << 12;
+
+		for (lane = 0U; lane <= R_MAX; lane++) {
+			r_addr = lane << 8;
+
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | r_addr |
+						      CSR_RXPBDLYTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | r_addr |
+						      CSR_RXPBDLYTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+
+#if STM32MP_LPDDR4_TYPE
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_PPTCTLSTATIC_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_TRAININGINCDECDTSMEN_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_TSMBYTE0_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ0LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ1LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ2LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ3LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ4LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ5LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ6LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DQ7LNSEL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	}
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_VREFINGLOBAL_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Anib Registers */
+	for (anib = 0U; anib < config->uib.numanib; anib++) {
+		c_addr = anib << 12;
+
+		ret = ddrphy_phyinit_trackreg(TANIB | c_addr | CSR_ATXDLY_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	/* Dbyte Registers */
+	for (byte = 0U; byte < config->uib.numdbyte; byte++) {
+		c_addr = byte << 12;
+
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_DFIMRL_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+
+		for (nibble = 0U; nibble <= B_MAX; nibble++) {
+			b_addr = nibble << 8;
+
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | b_addr |
+						      CSR_DQDQSRCVCNTRL_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+		}
+
+		for (nibble = 0U; nibble < 2U; nibble++) {
+			u_addr = nibble << 8;
+
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | u_addr |
+						      CSR_RXENDLYTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | u_addr |
+						      CSR_RXENDLYTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | u_addr |
+						      CSR_TXDQSDLYTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | u_addr |
+						      CSR_TXDQSDLYTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | u_addr |
+						      CSR_RXCLKDLYTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | u_addr |
+						      CSR_RXCLKDLYTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+
+		for (lane = R_MIN; lane <= R_MAX; lane++) {
+			r_addr = lane << 8;
+
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | r_addr |
+						      CSR_TXDQDLYTG0_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#if STM32MP_LPDDR4_TYPE
+			ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | r_addr |
+						      CSR_TXDQDLYTG1_ADDR);
+			if (ret != 0) {
+				return ret;
+			}
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+
+#if STM32MP_LPDDR4_TYPE
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_PPTDQSCNTINVTRNTG0_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+		ret = ddrphy_phyinit_trackreg(TDBYTE | c_addr | CSR_PPTDQSCNTINVTRNTG1_ADDR);
+		if (ret != 0) {
+			return ret;
+		}
+#endif /* STM32MP_LPDDR4_TYPE */
+	}
+
+	/* PIE Registers */
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR1_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR2_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR3_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR4_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR5_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR6_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR7_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BGPR8_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Master Registers */
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_DLLGAINCTL_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_DLLLOCKPARAM_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+#if STM32MP_LPDDR4_TYPE
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTMRL_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* INITENG Registers */
+	ret = ddrphy_phyinit_trackreg(TINITENG | CSR_SEQ0BDISABLEFLAG6_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTCAMODE_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+#if STM32MP_LPDDR4_TYPE
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTLPCSENA_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TMASTER | CSR_HWTLPCSENB_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* ACSM registers */
+	ret = ddrphy_phyinit_trackreg(TACSM | CSR_ACSMCTRL13_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = ddrphy_phyinit_trackreg(TACSM | CSR_ACSMCTRL23_ADDR);
+	if (ret != 0) {
+		return ret;
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 2. Track any additional registers
+	 *    Register writes made using the any of the PhyInit functions are
+	 *    automatically tracked using the call to ddrphy_phyinit_trackreg() in
+	 *    mmio_write_16(). Use this section to track additional registers.
+	 * --------------------------------------------------------------------------
+	 */
+
+	/*
+	 * Example:
+	 * ddrphy_phyinit_trackreg(<addr>);
+	 */
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 3. Prepare for register reads
+	 *    - Write the MicroContMuxSel CSR to 0x0 to allow access to the internal CSRs
+	 *    - Write the UcclkHclkEnables CSR to 0x3 to enable all the clocks so the reads
+	 *      can complete.
+	 * --------------------------------------------------------------------------
+	 */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x0U);
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR))),
+		      0x3U);
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * / 4. Read and save all the registers
+	 * /    - The list of registers differ depending on protocol and 1D training.
+	 * --------------------------------------------------------------------------
+	 */
+
+	ret = ddrphy_phyinit_reginterface(SAVEREGS, 0U, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/*
+	 * --------------------------------------------------------------------------
+	 * 5. Prepare for mission mode
+	 *  - Write the UcclkHclkEnables CSR to disable the appropriate clocks after all reads done.
+	 *  - Write the MicroContMuxSel CSR to 0x1 to isolate the internal CSRs during mission mode.
+	 * --------------------------------------------------------------------------
+	 */
+
+	/* Disabling Ucclk (PMU) and Hclk (training hardware) */
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TDRTUB | CSR_UCCLKHCLKENABLES_ADDR))),
+		      0x0U);
+
+	mmio_write_16((uintptr_t)(DDRPHYC_BASE + (4U * (TAPBONLY | CSR_MICROCONTMUXSEL_ADDR))),
+		      0x1U);
+
+	VERBOSE("%s End\n", __func__);
+
+	return 0;
+}
diff --git a/drivers/st/ddr/stm32mp1_ddr.c b/drivers/st/ddr/stm32mp1_ddr.c
index 4719e1e686..604877d959 100644
--- a/drivers/st/ddr/stm32mp1_ddr.c
+++ b/drivers/st/ddr/stm32mp1_ddr.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2024, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -24,14 +24,12 @@
 
 #define DDRCTL_REG(x, y)					\
 	{							\
-		.name = #x,					\
 		.offset = offsetof(struct stm32mp_ddrctl, x),	\
 		.par_offset = offsetof(struct y, x)		\
 	}
 
 #define DDRPHY_REG(x, y)					\
 	{							\
-		.name = #x,					\
 		.offset = offsetof(struct stm32mp_ddrphy, x),	\
 		.par_offset = offsetof(struct y, x)		\
 	}
@@ -215,7 +213,7 @@ static void stm32mp1_ddrphy_idone_wait(struct stm32mp_ddrphy *phy)
 {
 	uint32_t pgsr;
 	int error = 0;
-	uint64_t timeout = timeout_init_us(TIMEOUT_US_1S);
+	uint64_t timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
 
 	do {
 		pgsr = mmio_read_32((uintptr_t)&phy->pgsr);
@@ -266,7 +264,7 @@ static void stm32mp1_ddrphy_init(struct stm32mp_ddrphy *phy, uint32_t pir)
 		mmio_read_32((uintptr_t)&phy->pir));
 
 	/* Need to wait 10 configuration clock before start polling */
-	udelay(10);
+	udelay(DDR_DELAY_10US);
 
 	/* Wait DRAM initialization and Gate Training Evaluation complete */
 	stm32mp1_ddrphy_idone_wait(phy);
@@ -279,7 +277,7 @@ static void stm32mp1_wait_operating_mode(struct stm32mp_ddr_priv *priv, uint32_t
 	uint32_t stat;
 	int break_loop = 0;
 
-	timeout = timeout_init_us(TIMEOUT_US_1S);
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
 	for ( ; ; ) {
 		uint32_t operating_mode;
 		uint32_t selref_type;
@@ -508,8 +506,7 @@ static void stm32mp1_ddr3_dll_off(struct stm32mp_ddr_priv *priv)
 #endif
 
 	/* 12. Exit the self-refresh state by setting PWRCTL.selfref_sw = 0. */
-	mmio_clrbits_32((uintptr_t)&priv->ctl->pwrctl,
-			DDRCTRL_PWRCTL_SELFREF_SW);
+	stm32mp_ddr_sw_selfref_exit(priv->ctl);
 	stm32mp1_wait_operating_mode(priv, DDRCTRL_STAT_OPERATING_MODE_NORMAL);
 
 	/*
@@ -524,45 +521,145 @@ static void stm32mp1_ddr3_dll_off(struct stm32mp_ddr_priv *priv)
 	 */
 
 	/* 15. Write DBG1.dis_hif = 0 to re-enable reads and writes. */
-	mmio_clrbits_32((uintptr_t)&priv->ctl->dbg1, DDRCTRL_DBG1_DIS_HIF);
-	VERBOSE("[0x%lx] dbg1 = 0x%x\n",
-		(uintptr_t)&priv->ctl->dbg1,
-		mmio_read_32((uintptr_t)&priv->ctl->dbg1));
+	stm32mp_ddr_enable_host_interface(priv->ctl);
 }
 
 static void stm32mp1_refresh_disable(struct stm32mp_ddrctl *ctl)
 {
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 * AXI ports not yet enabled, don't disable them
+	 */
+	stm32mp_ddr_disable_host_interface(ctl);
 	stm32mp_ddr_start_sw_done(ctl);
-	/* Quasi-dynamic register update*/
+
 	mmio_setbits_32((uintptr_t)&ctl->rfshctl3,
 			DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
-	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_POWERDOWN_EN);
+	stm32mp_ddr_wait_refresh_update_done_ack(ctl);
+
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_POWERDOWN_EN |
+						 DDRCTRL_PWRCTL_SELFREF_EN);
 	mmio_clrbits_32((uintptr_t)&ctl->dfimisc,
 			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
 	stm32mp_ddr_wait_sw_done_ack(ctl);
+	stm32mp_ddr_enable_host_interface(ctl);
 }
 
 static void stm32mp1_refresh_restore(struct stm32mp_ddrctl *ctl,
 				     uint32_t rfshctl3, uint32_t pwrctl)
 {
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 * AXI ports not yet enabled, don't disable them
+	 */
+	stm32mp_ddr_disable_host_interface(ctl);
 	stm32mp_ddr_start_sw_done(ctl);
+
 	if ((rfshctl3 & DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH) == 0U) {
 		mmio_clrbits_32((uintptr_t)&ctl->rfshctl3,
 				DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
+		stm32mp_ddr_wait_refresh_update_done_ack(ctl);
 	}
 	if ((pwrctl & DDRCTRL_PWRCTL_POWERDOWN_EN) != 0U) {
 		mmio_setbits_32((uintptr_t)&ctl->pwrctl,
 				DDRCTRL_PWRCTL_POWERDOWN_EN);
 	}
+	if ((pwrctl & DDRCTRL_PWRCTL_SELFREF_EN) != 0U) {
+		mmio_setbits_32((uintptr_t)&ctl->pwrctl,
+				DDRCTRL_PWRCTL_SELFREF_EN);
+	}
 	mmio_setbits_32((uintptr_t)&ctl->dfimisc,
 			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
 	stm32mp_ddr_wait_sw_done_ack(ctl);
+	stm32mp_ddr_enable_host_interface(ctl);
+}
+
+static void stm32mp1_refresh_cmd(struct stm32mp_ddrctl *ctl)
+{
+	uint32_t dbgstat;
+
+	do {
+		dbgstat = mmio_read_32((uintptr_t)&ctl->dbgstat);
+	} while ((dbgstat & DDRCTRL_DBGSTAT_RANK0_REFRESH_BUSY) != 0U);
+
+	mmio_setbits_32((uintptr_t)&ctl->dbgcmd, DDRCTRL_DBGCMD_RANK0_REFRESH);
+}
+
+/* Refresh compensation by forcing refresh command
+ * Rule1: Tref should be always < tREFW ? R x tREBW/8
+ * Rule2: refcomp = RU(Tref/tREFI)  = RU(RxTref/tREFW)
+ */
+static
+void stm32mp1_refresh_compensation(const struct stm32mp_ddr_config *config,
+				   struct stm32mp_ddrctl *ctl,
+				   uint64_t start)
+{
+	uint32_t tck_ps;
+	uint64_t time_us, tref, trefi, refcomp, i;
+
+	time_us = timeout_init_us(0) - start;
+	tck_ps = 1000000000U / config->info.speed;
+	if (tck_ps == 0U) {
+		return;
+	}
+	/* ref = refresh time in tck */
+	tref = time_us * 1000000U / tck_ps;
+	trefi = ((mmio_read_32((uintptr_t)&ctl->rfshtmg) &
+		  DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_MASK)
+		 >> DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_SHIFT) * 32U;
+	if (trefi == 0U) {
+		return;
+	}
+
+	/* div round up : number of refresh to compensate */
+	refcomp = (tref + trefi - 1U) / trefi;
+
+	for (i = 0; i < refcomp; i++) {
+		stm32mp1_refresh_cmd(ctl);
+	}
+}
+
+static void stm32mp1_self_refresh_zcal(struct stm32mp_ddr_priv *priv, uint32_t zdata)
+{
+	/* sequence for PUBL I/O Data Retention during Power-Down */
+
+	/* 10. Override ZQ calibration with previously (pre-retention)
+	 *     calibrated values. This is done by writing 1 to ZQ0CRN.ZDEN
+	 *     and the override data to ZQ0CRN.ZDATA.
+	 */
+	mmio_setbits_32((uintptr_t)&priv->phy->zq0cr0, DDRPHYC_ZQ0CRN_ZDEN);
+
+	mmio_clrsetbits_32((uintptr_t)&priv->phy->zq0cr0,
+			   DDRPHYC_ZQ0CRN_ZDATA_MASK,
+			   zdata << DDRPHYC_ZQ0CRN_ZDATA_SHIFT);
+
+	/* 11. De-assert the PHY_top data retention enable signals
+	 *     (ret_en or ret_en_i/ret_en_n_i).
+	 */
+	mmio_setbits_32((uintptr_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRSRDIS);
+	mmio_clrbits_32((uintptr_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRRETEN);
+
+	/* 12. Remove ZQ calibration override by writing 0 to ZQ0CRN.ZDEN. */
+	mmio_clrbits_32((uintptr_t)&priv->phy->zq0cr0, DDRPHYC_ZQ0CRN_ZDEN);
+
+	/* 13. Trigger ZQ calibration by writing 1 to PIR.INIT
+	 *     and '1' to PIR.ZCAL
+	 */
+	/* 14. Wait for ZQ calibration to finish by polling a 1 status
+	 * on PGSR.IDONE.
+	 */
+	stm32mp1_ddrphy_init(priv->phy, DDRPHYC_PIR_ZCAL);
 }
 
 void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 		       struct stm32mp_ddr_config *config)
 {
-	uint32_t pir;
+	uint32_t pir, ddr_reten;
+	uint64_t time;
 	int ret = -EINVAL;
 
 	if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR3) != 0U) {
@@ -582,6 +679,25 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 	VERBOSE("name = %s\n", config->info.name);
 	VERBOSE("speed = %u kHz\n", config->info.speed);
 	VERBOSE("size  = 0x%x\n", config->info.size);
+	if (config->self_refresh) {
+		VERBOSE("sel-refresh exit (zdata = 0x%x)\n", config->zdata);
+	}
+
+	/* Check DDR PHY pads retention */
+	ddr_reten = mmio_read_32((uint32_t)(priv->pwr) + PWR_CR3) &
+		    PWR_CR3_DDRRETEN;
+	if (config->self_refresh) {
+		if (ddr_reten == 0U) {
+			VERBOSE("self-refresh aborted: no retention\n");
+			config->self_refresh = false;
+		}
+	}
+
+	if (!config->self_refresh) {
+		VERBOSE("disable DDR PHY retention\n");
+		mmio_setbits_32((uint32_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRSRDIS);
+		mmio_clrbits_32((uint32_t)(priv->pwr) + PWR_CR3, PWR_CR3_DDRRETEN);
+	}
 
 	/* DDR INIT SEQUENCE */
 
@@ -614,7 +730,7 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 	mmio_clrbits_32(priv->rcc + RCC_DDRITFCR, RCC_DDRITFCR_DDRCAPBRST);
 
 	/* 1.4. wait 128 cycles to permit initialization of end logic */
-	udelay(2);
+	udelay(DDR_DELAY_2US);
 	/* For PCLK = 133MHz => 1 us is enough, 2 to allow lower frequency */
 
 	/* 1.5. initialize registers ddr_umctl2 */
@@ -642,6 +758,12 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 	stm32mp_ddr_set_reg(priv, REG_TIMING, &config->c_timing, ddr_registers);
 	stm32mp_ddr_set_reg(priv, REG_MAP, &config->c_map, ddr_registers);
 
+	/* Keep the controller in self-refresh mode */
+	if (config->self_refresh) {
+		mmio_setbits_32((uintptr_t)&priv->ctl->pwrctl,
+				DDRCTRL_PWRCTL_SELFREF_SW);
+	}
+
 	/* Skip CTRL init, SDRAM init is done by PHY PUBL */
 	mmio_clrsetbits_32((uintptr_t)&priv->ctl->init0,
 			   DDRCTRL_INIT0_SKIP_DRAM_INIT_MASK,
@@ -694,8 +816,20 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 		pir |= DDRPHYC_PIR_DRAMRST; /* Only for DDR3 */
 	}
 
+	/* Treat self-refresh exit : hot boot */
+	if (config->self_refresh) {
+		/* DDR in self refresh mode, remove zcal & reset & init */
+		pir &= ~(DDRPHYC_PIR_ZCAL & DDRPHYC_PIR_DRAMRST
+			 & DDRPHYC_PIR_DRAMINIT);
+		pir |= DDRPHYC_PIR_ZCALBYP;
+	}
+
 	stm32mp1_ddrphy_init(priv->phy, pir);
 
+	if (config->self_refresh) {
+		stm32mp1_self_refresh_zcal(priv, config->zdata);
+	}
+
 	/*
 	 *  6. SET DFIMISC.dfi_init_complete_en to 1
 	 *  Enable quasi-dynamic register programming.
@@ -716,6 +850,12 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 	 */
 
 	/* Wait uMCTL2 ready */
+
+	/* Trigger self-refresh exit */
+	if (config->self_refresh) {
+		stm32mp_ddr_sw_selfref_exit(priv->ctl);
+	}
+
 	stm32mp1_wait_operating_mode(priv, DDRCTRL_STAT_OPERATING_MODE_NORMAL);
 
 	/* Switch to DLL OFF mode */
@@ -723,7 +863,9 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 		stm32mp1_ddr3_dll_off(priv);
 	}
 
-	VERBOSE("DDR DQS training : ");
+	VERBOSE("DDR DQS training.\n");
+
+	time = timeout_init_us(0);
 
 	/*
 	 *  8. Disable Auto refresh and power down by setting
@@ -751,9 +893,14 @@ void stm32mp1_ddr_init(struct stm32mp_ddr_priv *priv,
 
 	stm32mp1_ddrphy_init(priv->phy, pir);
 
-	/* 11. monitor PUB PGSR.IDONE to poll cpmpletion of training sequence */
+	/* 11. monitor PUB PGSR.IDONE to poll completion of training sequence */
 	stm32mp1_ddrphy_idone_wait(priv->phy);
 
+	/* Refresh compensation: forcing refresh command */
+	if (config->self_refresh) {
+		stm32mp1_refresh_compensation(config, priv->ctl, time);
+	}
+
 	/*
 	 * 12. set back registers in step 8 to the orginal values if desidered
 	 */
diff --git a/drivers/st/ddr/stm32mp1_ddr_helpers.c b/drivers/st/ddr/stm32mp1_ddr_helpers.c
index e0621b5131..5adf38f0fc 100644
--- a/drivers/st/ddr/stm32mp1_ddr_helpers.c
+++ b/drivers/st/ddr/stm32mp1_ddr_helpers.c
@@ -4,8 +4,15 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp1_ddr.h>
 #include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stm32mp1_ddr_regs.h>
 #include <lib/mmio.h>
+#include <plat/common/platform.h>
 
 #include <platform_def.h>
 
@@ -24,3 +31,509 @@ void ddr_enable_clock(void)
 
 	stm32mp1_clk_rcc_regs_unlock();
 }
+
+static int ddr_sw_self_refresh_in(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+	uintptr_t ddrphyc_base = stm32mp_ddrphyc_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/* Blocks AXI ports from taking anymore transactions */
+	if (stm32mp_ddr_disable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base) != 0U) {
+		goto pstat_failed;
+	}
+
+	/* SW Self-Refresh entry */
+	if (stm32mp_ddr_sw_selfref_entry((struct stm32mp_ddrctl *)ddrctrl_base) != 0U) {
+		goto selfref_sw_failed;
+	}
+
+	/* IOs powering down (PUBL registers) */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACPDD);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACPDR);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			   DDRPHYC_ACIOCR_CKPDD_MASK,
+			   DDRPHYC_ACIOCR_CKPDD_0);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			   DDRPHYC_ACIOCR_CKPDR_MASK,
+			   DDRPHYC_ACIOCR_CKPDR_0);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			   DDRPHYC_ACIOCR_CSPDD_MASK,
+			   DDRPHYC_ACIOCR_CSPDD_0);
+
+	/* Disable command/address output driver */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACOE);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDD);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDR);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			   DDRPHYC_DSGCR_ODTPDD_MASK,
+			   DDRPHYC_DSGCR_ODTPDD_0);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_NL2PD);
+
+	mmio_clrsetbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			   DDRPHYC_DSGCR_CKEPDD_MASK,
+			   DDRPHYC_DSGCR_CKEPDD_0);
+
+	/* Disable PZQ cell (PUBL register) */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ZQ0CR0, DDRPHYC_ZQ0CRN_ZQPD);
+
+	/* Set latch */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_CKOE);
+
+	/* Additional delay to avoid early latch */
+	udelay(DDR_DELAY_10US);
+
+	/* Activate sw retention in PWRCTRL */
+	stm32mp_pwr_regs_lock();
+	mmio_setbits_32(pwr_base + PWR_CR3, PWR_CR3_DDRRETEN);
+	stm32mp_pwr_regs_unlock();
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL ref clock */
+	stm32mp1_clk_rcc_regs_lock();
+	mmio_setbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/* Disable all DLLs: GLITCH window */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLDIS);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX0DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX1DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+#if STM32MP_DDR_32BIT_INTERFACE
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX2DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DX3DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+#endif
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL output clock */
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+
+	/* Deactivate all DDR clocks */
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR,
+			RCC_DDRITFCR_DDRC1EN |
+#if STM32MP_DDR_DUAL_AXI_PORT
+			RCC_DDRITFCR_DDRC2EN |
+#endif
+			RCC_DDRITFCR_DDRCAPBEN |
+			RCC_DDRITFCR_DDRPHYCAPBEN);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	return 0;
+
+selfref_sw_failed:
+	/* Restore DDR in its previous state */
+	stm32mp_ddr_sw_selfref_exit((struct stm32mp_ddrctl *)ddrctrl_base);
+
+pstat_failed:
+	stm32mp_ddr_enable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	return -1;
+}
+
+int ddr_sw_self_refresh_exit(void)
+{
+	uint64_t timeout;
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+	uintptr_t ddrphyc_base = stm32mp_ddrphyc_base();
+
+	/* Enable all clocks */
+	ddr_enable_clock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Mask dfi_init_complete_en */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_DFIMISC,
+			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL ref clock */
+	stm32mp1_clk_rcc_regs_lock();
+	mmio_setbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/* Enable all DLLs: GLITCH window */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLDIS);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX0DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX1DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+#if STM32MP_DDR_32BIT_INTERFACE
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX2DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DX3DLLCR,
+			DDRPHYC_DXNDLLCR_DLLDIS);
+#endif
+
+	/* Additional delay to avoid early DLL clock switch */
+	udelay(DDR_DELAY_50US);
+
+	/* Switch controller clocks (uMCTL2/PUBL) to DLL ref clock */
+	stm32mp1_clk_rcc_regs_lock();
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_GSKPCTRL);
+	stm32mp1_clk_rcc_regs_unlock();
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLSRST);
+
+	udelay(DDR_DELAY_10US);
+
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACDLLCR,
+			DDRPHYC_ACDLLCR_DLLSRST);
+
+	/* PHY partial init: (DLL lock and ITM reset) */
+	mmio_write_32(ddrphyc_base + DDRPHYC_PIR,
+		      DDRPHYC_PIR_DLLSRST | DDRPHYC_PIR_DLLLOCK |
+		      DDRPHYC_PIR_ITMSRST | DDRPHYC_PIR_INIT);
+
+	/* Need to wait at least 10 clock cycles before accessing PGSR */
+	udelay(DDR_DELAY_1US);
+
+	/* Pool end of init */
+	timeout = timeout_init_us(DDR_TIMEOUT_500US);
+
+	while ((mmio_read_32(ddrphyc_base + DDRPHYC_PGSR) &
+		DDRPHYC_PGSR_IDONE) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	}
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Unmask dfi_init_complete_en to uMCTL2 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_DFIMISC,
+			DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Deactivate sw retention in PWR */
+	stm32mp_pwr_regs_lock();
+	mmio_clrbits_32(pwr_base + PWR_CR3, PWR_CR3_DDRRETEN);
+	stm32mp_pwr_regs_unlock();
+
+	/* Enable PZQ cell (PUBL register) */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ZQ0CR0, DDRPHYC_ZQ0CRN_ZQPD);
+
+	/* Enable pad drivers */
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACPDD);
+
+	/* Enable command/address output driver */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_ACIOCR, DDRPHYC_ACIOCR_ACOE);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			DDRPHYC_ACIOCR_CKPDD_MASK);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_ACIOCR,
+			DDRPHYC_ACIOCR_CSPDD_MASK);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDD);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DXCCR, DDRPHYC_DXCCR_DXPDR);
+
+	/* Release latch */
+	mmio_setbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_CKOE);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			DDRPHYC_DSGCR_ODTPDD_MASK);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR, DDRPHYC_DSGCR_NL2PD);
+
+	mmio_clrbits_32(ddrphyc_base + DDRPHYC_DSGCR,
+			DDRPHYC_DSGCR_CKEPDD_MASK);
+
+	/* Remove selfrefresh */
+	stm32mp_ddr_sw_selfref_exit((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Wait operating_mode == normal */
+	timeout = timeout_init_us(DDR_TIMEOUT_500US);
+	while ((mmio_read_32(ddrctrl_base + DDRCTRL_STAT) &
+		DDRCTRL_STAT_OPERATING_MODE_MASK) !=
+	       DDRCTRL_STAT_OPERATING_MODE_NORMAL) {
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	}
+
+	/* AXI ports are no longer blocked from taking transactions */
+	stm32mp_ddr_enable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_base + RCC_DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	return 0;
+}
+
+uint32_t ddr_get_io_calibration_val(void)
+{
+	uintptr_t ddrphyc_base = stm32mp_ddrphyc_base();
+
+	return mmio_read_32(ddrphyc_base + DDRPHYC_ZQ0CR0) &
+		DDRPHYC_ZQ0CRN_ZDATA_MASK;
+}
+
+int ddr_standby_sr_entry(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+
+	/* Put DDR in Self-Refresh */
+	if (ddr_sw_self_refresh_in() != 0) {
+		return -1;
+	}
+
+	/* Enable I/O retention mode in standby */
+	stm32mp_pwr_regs_lock();
+	mmio_setbits_32(pwr_base + PWR_CR3, PWR_CR3_DDRSREN);
+	stm32mp_pwr_regs_unlock();
+
+	return 0;
+}
+
+static void ddr_sr_mode_ssr(void)
+{
+	uintptr_t rcc_ddritfcr = stm32mp_rcc_base() + RCC_DDRITFCR;
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1LPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1EN);
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2LPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2EN);
+#endif
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCAPBLPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCAPBLPEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCAPBEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCAPBEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCEN);
+
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_AXIDCGEN);
+
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCKMOD_MASK);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 3
+	 * pwrtmg.selfref_to_x32 & powerdown_to_x32 : Group 4
+	 * Group 3 is the most restrictive, apply its conditions for all
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Disable HW LP interface of uMCTL2 */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+			DDRCTRL_HWLPCTL_HW_LP_EN);
+
+	/* Configure Automatic LP modes of uMCTL2 */
+	mmio_clrsetbits_32(ddrctrl_base + DDRCTRL_PWRTMG,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_0);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/*
+	 * Disable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	 */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+
+	/* Disable automatic Self-Refresh mode */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_SELFREF_EN);
+}
+
+static void ddr_sr_mode_asr(void)
+{
+	uintptr_t rcc_ddritfcr = stm32mp_rcc_base() + RCC_DDRITFCR;
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_AXIDCGEN);
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1LPEN);
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2LPEN);
+#endif
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCLPEN);
+
+	mmio_clrsetbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCKMOD_MASK,
+			   RCC_DDRITFCR_DDRCKMOD_ASR1);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 3
+	 * pwrtmg.selfref_to_x32 & powerdown_to_x32 : Group 4
+	 * Group 3 is the most restrictive, apply its conditions for all
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Enable HW LP interface of uMCTL2 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+			DDRCTRL_HWLPCTL_HW_LP_EN);
+
+	/* Configure Automatic LP modes of uMCTL2 */
+	mmio_clrsetbits_32(ddrctrl_base + DDRCTRL_PWRTMG,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_0);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/*
+	 * Enable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+
+	/* Enable automatic Self-Refresh for ASR mode */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_SELFREF_EN);
+}
+
+static void ddr_sr_mode_hsr(void)
+{
+	uintptr_t rcc_ddritfcr = stm32mp_rcc_base() + RCC_DDRITFCR;
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	stm32mp1_clk_rcc_regs_lock();
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_AXIDCGEN);
+
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC1LPEN);
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	mmio_clrbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRC2LPEN);
+#endif
+
+	mmio_setbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRPHYCLPEN);
+
+	mmio_clrsetbits_32(rcc_ddritfcr, RCC_DDRITFCR_DDRCKMOD_MASK,
+			   RCC_DDRITFCR_DDRCKMOD_HSR1);
+
+	stm32mp1_clk_rcc_regs_unlock();
+
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 3
+	 * pwrtmg.selfref_to_x32 & powerdown_to_x32 : Group 4
+	 * Group 3 is the most restrictive, apply its conditions for all
+	 */
+	stm32mp_ddr_set_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* Enable HW LP interface of uMCTL2 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+			DDRCTRL_HWLPCTL_HW_LP_EN);
+
+	/* Configure Automatic LP modes of uMCTL2 */
+	mmio_clrsetbits_32(ddrctrl_base + DDRCTRL_PWRTMG,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK,
+			   DDRCTRL_PWRTMG_SELFREF_TO_X32_0);
+
+	stm32mp_ddr_unset_qd3_update_conditions((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/*
+	 * Enable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	 */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL,
+			DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+}
+
+enum stm32mp1_ddr_sr_mode ddr_read_sr_mode(void)
+{
+	uint32_t pwrctl = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_PWRCTL);
+
+	switch (pwrctl & (DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE |
+			  DDRCTRL_PWRCTL_SELFREF_EN)) {
+	case 0U:
+		return DDR_SSR_MODE;
+
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE:
+		return DDR_HSR_MODE;
+
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE | DDRCTRL_PWRCTL_SELFREF_EN:
+		return DDR_ASR_MODE;
+
+	default:
+		return DDR_SR_MODE_INVALID;
+	}
+}
+
+void ddr_set_sr_mode(enum stm32mp1_ddr_sr_mode mode)
+{
+	switch (mode) {
+	case DDR_SSR_MODE:
+		ddr_sr_mode_ssr();
+		break;
+
+	case DDR_HSR_MODE:
+		ddr_sr_mode_hsr();
+		break;
+
+	case DDR_ASR_MODE:
+		ddr_sr_mode_asr();
+		break;
+
+	default:
+		ERROR("Unknown Self Refresh mode\n");
+		panic();
+	}
+}
diff --git a/drivers/st/ddr/stm32mp1_ram.c b/drivers/st/ddr/stm32mp1_ram.c
index b510c8fa27..c04f55f7d3 100644
--- a/drivers/st/ddr/stm32mp1_ram.c
+++ b/drivers/st/ddr/stm32mp1_ram.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -22,6 +22,7 @@
 #include <platform_def.h>
 
 static struct stm32mp_ddr_priv ddr_priv_data;
+static bool ddr_self_refresh;
 
 int stm32mp1_ddr_clk_enable(struct stm32mp_ddr_priv *priv, uint32_t mem_speed)
 {
@@ -56,7 +57,7 @@ static int stm32mp1_ddr_setup(void)
 	int ret;
 	struct stm32mp_ddr_config config;
 	int node;
-	uint32_t uret;
+	uintptr_t uret;
 	void *fdt;
 
 	const struct stm32mp_ddr_param param[] = {
@@ -88,6 +89,13 @@ static int stm32mp1_ddr_setup(void)
 		return ret;
 	}
 
+	config.self_refresh = false;
+
+	if (stm32mp_is_wakeup_from_standby()) {
+		config.self_refresh = true;
+		config.zdata = stm32_get_zdata_from_context();
+	}
+
 	/* Disable axidcg clock gating during init */
 	mmio_clrbits_32(priv->rcc + RCC_DDRITFCR, RCC_DDRITFCR_AXIDCGEN);
 
@@ -105,34 +113,68 @@ static int stm32mp1_ddr_setup(void)
 		panic();
 	}
 
-	uret = stm32mp_ddr_test_data_bus();
-	if (uret != 0U) {
-		ERROR("DDR data bus test: can't access memory @ 0x%x\n",
-		      uret);
-		panic();
-	}
+	if (config.self_refresh) {
+		uret = stm32mp_ddr_test_rw_access();
+		if (uret != 0UL) {
+			ERROR("DDR rw test: Can't access memory @ 0x%lx\n",
+			      uret);
+			panic();
+		}
 
-	uret = stm32mp_ddr_test_addr_bus(config.info.size);
-	if (uret != 0U) {
-		ERROR("DDR addr bus test: can't access memory @ 0x%x\n",
-		      uret);
-		panic();
+		/* Restore area overwritten by training */
+		stm32_restore_ddr_training_area();
+	} else {
+		size_t retsize;
+
+		uret = stm32mp_ddr_test_data_bus();
+		if (uret != 0UL) {
+			ERROR("DDR data bus test: can't access memory @ 0x%lx\n",
+			      uret);
+			panic();
+		}
+
+		uret = stm32mp_ddr_test_addr_bus(config.info.size);
+		if (uret != 0UL) {
+			ERROR("DDR addr bus test: can't access memory @ 0x%lx\n",
+			      uret);
+			panic();
+		}
+
+		retsize = stm32mp_ddr_check_size();
+		if (retsize < config.info.size) {
+			ERROR("DDR size: 0x%zx does not match DT config: 0x%zx\n",
+			      retsize, config.info.size);
+			panic();
+		}
+
+		INFO("Memory size = 0x%zx (%zu MB)\n", retsize, retsize / (1024U * 1024U));
 	}
 
-	uret = stm32mp_ddr_check_size();
-	if (uret < config.info.size) {
-		ERROR("DDR size: 0x%x does not match DT config: 0x%x\n",
-		      uret, config.info.size);
-		panic();
-	}
+	/*
+	 * Initialization sequence has configured DDR registers with settings.
+	 * The Self Refresh (SR) mode corresponding to these settings has now
+	 * to be set.
+	 */
+	ddr_set_sr_mode(ddr_read_sr_mode());
 
 	if (stm32mp_unmap_ddr() != 0) {
 		panic();
 	}
 
+	/* Save DDR self_refresh state */
+	ddr_self_refresh = config.self_refresh;
+
+	/* Flush the value that will be used during MMU OFF sequence */
+	flush_dcache_range((uintptr_t)&ddr_self_refresh, sizeof(ddr_self_refresh));
+
 	return 0;
 }
 
+bool stm32mp1_ddr_is_restored(void)
+{
+	return ddr_self_refresh;
+}
+
 int stm32mp1_ddr_probe(void)
 {
 	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
diff --git a/drivers/st/ddr/stm32mp2_ddr.c b/drivers/st/ddr/stm32mp2_ddr.c
new file mode 100644
index 0000000000..4d29ebd471
--- /dev/null
+++ b/drivers/st/ddr/stm32mp2_ddr.c
@@ -0,0 +1,497 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <drivers/st/stm32mp2_ddr_regs.h>
+#include <lib/mmio.h>
+
+#include <ddrphy_phyinit.h>
+
+#include <platform_def.h>
+
+#define DDRDBG_FRAC_PLL_LOCK	U(0x10)
+
+#define DDRCTL_REG(x, y, z)					\
+	{							\
+		.offset = offsetof(struct stm32mp_ddrctl, x),	\
+		.par_offset = offsetof(struct y, x),		\
+		.qd = z						\
+	}
+
+/*
+ * PARAMETERS: value get from device tree :
+ *             size / order need to be aligned with binding
+ *             modification NOT ALLOWED !!!
+ */
+#define DDRCTL_REG_REG_SIZE	48	/* st,ctl-reg */
+#define DDRCTL_REG_TIMING_SIZE	20	/* st,ctl-timing */
+#define DDRCTL_REG_MAP_SIZE	12	/* st,ctl-map */
+#if STM32MP_DDR_DUAL_AXI_PORT
+#define DDRCTL_REG_PERF_SIZE	21	/* st,ctl-perf */
+#else /* !STM32MP_DDR_DUAL_AXI_PORT */
+#define DDRCTL_REG_PERF_SIZE	14	/* st,ctl-perf */
+#endif /* STM32MP_DDR_DUAL_AXI_PORT */
+
+#define DDRPHY_REG_REG_SIZE	0	/* st,phy-reg */
+#define	DDRPHY_REG_TIMING_SIZE	0	/* st,phy-timing */
+
+#define DDRCTL_REG_REG(x, z)	DDRCTL_REG(x, stm32mp2_ddrctrl_reg, z)
+static const struct stm32mp_ddr_reg_desc ddr_reg[DDRCTL_REG_REG_SIZE] = {
+	DDRCTL_REG_REG(mstr, true),
+	DDRCTL_REG_REG(mrctrl0, false),
+	DDRCTL_REG_REG(mrctrl1, false),
+	DDRCTL_REG_REG(mrctrl2, false),
+	DDRCTL_REG_REG(derateen, true),
+	DDRCTL_REG_REG(derateint, false),
+	DDRCTL_REG_REG(deratectl, false),
+	DDRCTL_REG_REG(pwrctl, false),
+	DDRCTL_REG_REG(pwrtmg, true),
+	DDRCTL_REG_REG(hwlpctl, true),
+	DDRCTL_REG_REG(rfshctl0, false),
+	DDRCTL_REG_REG(rfshctl1, false),
+	DDRCTL_REG_REG(rfshctl3, true),
+	DDRCTL_REG_REG(crcparctl0, false),
+	DDRCTL_REG_REG(crcparctl1, false),
+	DDRCTL_REG_REG(init0, true),
+	DDRCTL_REG_REG(init1, false),
+	DDRCTL_REG_REG(init2, false),
+	DDRCTL_REG_REG(init3, true),
+	DDRCTL_REG_REG(init4, true),
+	DDRCTL_REG_REG(init5, false),
+	DDRCTL_REG_REG(init6, true),
+	DDRCTL_REG_REG(init7, true),
+	DDRCTL_REG_REG(dimmctl, false),
+	DDRCTL_REG_REG(rankctl, true),
+	DDRCTL_REG_REG(rankctl1, true),
+	DDRCTL_REG_REG(zqctl0, true),
+	DDRCTL_REG_REG(zqctl1, false),
+	DDRCTL_REG_REG(zqctl2, false),
+	DDRCTL_REG_REG(dfitmg0, true),
+	DDRCTL_REG_REG(dfitmg1, true),
+	DDRCTL_REG_REG(dfilpcfg0, false),
+	DDRCTL_REG_REG(dfilpcfg1, false),
+	DDRCTL_REG_REG(dfiupd0, true),
+	DDRCTL_REG_REG(dfiupd1, false),
+	DDRCTL_REG_REG(dfiupd2, false),
+	DDRCTL_REG_REG(dfimisc, true),
+	DDRCTL_REG_REG(dfitmg2, true),
+	DDRCTL_REG_REG(dfitmg3, false),
+	DDRCTL_REG_REG(dbictl, true),
+	DDRCTL_REG_REG(dfiphymstr, false),
+	DDRCTL_REG_REG(dbg0, false),
+	DDRCTL_REG_REG(dbg1, false),
+	DDRCTL_REG_REG(dbgcmd, false),
+	DDRCTL_REG_REG(swctl, false), /* forced qd value */
+	DDRCTL_REG_REG(swctlstatic, false),
+	DDRCTL_REG_REG(poisoncfg, false),
+	DDRCTL_REG_REG(pccfg, false),
+};
+
+#define DDRCTL_REG_TIMING(x, z)	DDRCTL_REG(x, stm32mp2_ddrctrl_timing, z)
+static const struct stm32mp_ddr_reg_desc ddr_timing[DDRCTL_REG_TIMING_SIZE] = {
+	DDRCTL_REG_TIMING(rfshtmg, false),
+	DDRCTL_REG_TIMING(rfshtmg1, false),
+	DDRCTL_REG_TIMING(dramtmg0, true),
+	DDRCTL_REG_TIMING(dramtmg1, true),
+	DDRCTL_REG_TIMING(dramtmg2, true),
+	DDRCTL_REG_TIMING(dramtmg3, true),
+	DDRCTL_REG_TIMING(dramtmg4, true),
+	DDRCTL_REG_TIMING(dramtmg5, true),
+	DDRCTL_REG_TIMING(dramtmg6, true),
+	DDRCTL_REG_TIMING(dramtmg7, true),
+	DDRCTL_REG_TIMING(dramtmg8, true),
+	DDRCTL_REG_TIMING(dramtmg9, true),
+	DDRCTL_REG_TIMING(dramtmg10, true),
+	DDRCTL_REG_TIMING(dramtmg11, true),
+	DDRCTL_REG_TIMING(dramtmg12, true),
+	DDRCTL_REG_TIMING(dramtmg13, true),
+	DDRCTL_REG_TIMING(dramtmg14, true),
+	DDRCTL_REG_TIMING(dramtmg15, true),
+	DDRCTL_REG_TIMING(odtcfg, true),
+	DDRCTL_REG_TIMING(odtmap, false),
+};
+
+#define DDRCTL_REG_MAP(x)	DDRCTL_REG(x, stm32mp2_ddrctrl_map, false)
+static const struct stm32mp_ddr_reg_desc ddr_map[DDRCTL_REG_MAP_SIZE] = {
+	DDRCTL_REG_MAP(addrmap0),
+	DDRCTL_REG_MAP(addrmap1),
+	DDRCTL_REG_MAP(addrmap2),
+	DDRCTL_REG_MAP(addrmap3),
+	DDRCTL_REG_MAP(addrmap4),
+	DDRCTL_REG_MAP(addrmap5),
+	DDRCTL_REG_MAP(addrmap6),
+	DDRCTL_REG_MAP(addrmap7),
+	DDRCTL_REG_MAP(addrmap8),
+	DDRCTL_REG_MAP(addrmap9),
+	DDRCTL_REG_MAP(addrmap10),
+	DDRCTL_REG_MAP(addrmap11),
+};
+
+#define DDRCTL_REG_PERF(x, z)	DDRCTL_REG(x, stm32mp2_ddrctrl_perf, z)
+static const struct stm32mp_ddr_reg_desc ddr_perf[DDRCTL_REG_PERF_SIZE] = {
+	DDRCTL_REG_PERF(sched, true),
+	DDRCTL_REG_PERF(sched1, false),
+	DDRCTL_REG_PERF(perfhpr1, true),
+	DDRCTL_REG_PERF(perflpr1, true),
+	DDRCTL_REG_PERF(perfwr1, true),
+	DDRCTL_REG_PERF(sched3, false),
+	DDRCTL_REG_PERF(sched4, false),
+	DDRCTL_REG_PERF(pcfgr_0, false),
+	DDRCTL_REG_PERF(pcfgw_0, false),
+	DDRCTL_REG_PERF(pctrl_0, false),
+	DDRCTL_REG_PERF(pcfgqos0_0, true),
+	DDRCTL_REG_PERF(pcfgqos1_0, true),
+	DDRCTL_REG_PERF(pcfgwqos0_0, true),
+	DDRCTL_REG_PERF(pcfgwqos1_0, true),
+#if STM32MP_DDR_DUAL_AXI_PORT
+	DDRCTL_REG_PERF(pcfgr_1, false),
+	DDRCTL_REG_PERF(pcfgw_1, false),
+	DDRCTL_REG_PERF(pctrl_1, false),
+	DDRCTL_REG_PERF(pcfgqos0_1, true),
+	DDRCTL_REG_PERF(pcfgqos1_1, true),
+	DDRCTL_REG_PERF(pcfgwqos0_1, true),
+	DDRCTL_REG_PERF(pcfgwqos1_1, true),
+#endif /* STM32MP_DDR_DUAL_AXI_PORT */
+};
+
+static const struct stm32mp_ddr_reg_desc ddrphy_reg[DDRPHY_REG_REG_SIZE] = {};
+
+static const struct stm32mp_ddr_reg_desc ddrphy_timing[DDRPHY_REG_TIMING_SIZE] = {};
+
+/*
+ * REGISTERS ARRAY: used to parse device tree and interactive mode
+ */
+static const struct stm32mp_ddr_reg_info ddr_registers[REG_TYPE_NB] __unused = {
+	[REG_REG] = {
+		.name = "static",
+		.desc = ddr_reg,
+		.size = DDRCTL_REG_REG_SIZE,
+		.base = DDR_BASE
+	},
+	[REG_TIMING] = {
+		.name = "timing",
+		.desc = ddr_timing,
+		.size = DDRCTL_REG_TIMING_SIZE,
+		.base = DDR_BASE
+	},
+	[REG_PERF] = {
+		.name = "perf",
+		.desc = ddr_perf,
+		.size = DDRCTL_REG_PERF_SIZE,
+		.base = DDR_BASE
+	},
+	[REG_MAP] = {
+		.name = "map",
+		.desc = ddr_map,
+		.size = DDRCTL_REG_MAP_SIZE,
+		.base = DDR_BASE
+	},
+	[REGPHY_REG] = {
+		.name = "static",
+		.desc = ddrphy_reg,
+		.size = DDRPHY_REG_REG_SIZE,
+		.base = DDRPHY_BASE
+	},
+	[REGPHY_TIMING] = {
+		.name = "timing",
+		.desc = ddrphy_timing,
+		.size = DDRPHY_REG_TIMING_SIZE,
+		.base = DDRPHY_BASE
+	},
+};
+
+static void ddr_reset(struct stm32mp_ddr_priv *priv)
+{
+	udelay(DDR_DELAY_1US);
+
+	mmio_setbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_write_32(priv->rcc + RCC_DDRPHYCAPBCFGR,
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN | RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN |
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST);
+	mmio_write_32(priv->rcc + RCC_DDRCAPBCFGR,
+		      RCC_DDRCAPBCFGR_DDRCAPBEN | RCC_DDRCAPBCFGR_DDRCAPBLPEN |
+		      RCC_DDRCAPBCFGR_DDRCAPBRST);
+	mmio_write_32(priv->rcc + RCC_DDRCFGR,
+		      RCC_DDRCFGR_DDRCFGEN | RCC_DDRCFGR_DDRCFGLPEN | RCC_DDRCFGR_DDRCFGRST);
+
+	udelay(DDR_DELAY_1US);
+
+	mmio_setbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_write_32(priv->rcc + RCC_DDRPHYCAPBCFGR,
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN | RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN);
+	mmio_write_32(priv->rcc + RCC_DDRCAPBCFGR,
+		      RCC_DDRCAPBCFGR_DDRCAPBEN | RCC_DDRCAPBCFGR_DDRCAPBLPEN);
+	mmio_write_32(priv->rcc + RCC_DDRCFGR, RCC_DDRCFGR_DDRCFGEN | RCC_DDRCFGR_DDRCFGLPEN);
+
+	udelay(DDR_DELAY_1US);
+}
+
+static void ddr_standby_reset(struct stm32mp_ddr_priv *priv)
+{
+	udelay(DDR_DELAY_1US);
+
+	mmio_write_32(priv->rcc + RCC_DDRCPCFGR,
+		      RCC_DDRCPCFGR_DDRCPEN | RCC_DDRCPCFGR_DDRCPLPEN | RCC_DDRCPCFGR_DDRCPRST);
+	mmio_setbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_write_32(priv->rcc + RCC_DDRPHYCAPBCFGR,
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN | RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN |
+		      RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST);
+	mmio_write_32(priv->rcc + RCC_DDRCAPBCFGR,
+		      RCC_DDRCAPBCFGR_DDRCAPBEN | RCC_DDRCAPBCFGR_DDRCAPBLPEN |
+		      RCC_DDRCAPBCFGR_DDRCAPBRST);
+
+	mmio_clrbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRPHYDLP);
+	mmio_setbits_32(priv->rcc + RCC_DDRPHYCCFGR, RCC_DDRPHYCCFGR_DDRPHYCEN);
+
+	udelay(DDR_DELAY_1US);
+}
+
+static void ddr_standby_reset_release(struct stm32mp_ddr_priv *priv)
+{
+	udelay(DDR_DELAY_1US);
+
+	mmio_write_32(priv->rcc + RCC_DDRCPCFGR, RCC_DDRCPCFGR_DDRCPEN | RCC_DDRCPCFGR_DDRCPLPEN);
+	mmio_clrbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_clrbits_32(priv->rcc + RCC_DDRPHYCAPBCFGR, RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST);
+	mmio_write_32(priv->rcc + RCC_DDRCFGR, RCC_DDRCFGR_DDRCFGEN | RCC_DDRCFGR_DDRCFGLPEN);
+
+	udelay(DDR_DELAY_1US);
+}
+
+static void ddr_sysconf_configuration(struct stm32mp_ddr_priv *priv,
+				      struct stm32mp_ddr_config *config)
+{
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_LP_DISABLE,
+		      DDRDBG_LP_DISABLE_LPI_XPI_DISABLE | DDRDBG_LP_DISABLE_LPI_DDRC_DISABLE);
+
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_BYPASS_PCLKEN,
+		      (uint32_t)config->uib.pllbypass);
+
+	mmio_write_32(priv->rcc + RCC_DDRPHYCCFGR, RCC_DDRPHYCCFGR_DDRPHYCEN);
+	mmio_setbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+
+	udelay(DDR_DELAY_1US);
+}
+
+static void set_dfi_init_complete_en(struct stm32mp_ddrctl *ctl, bool phy_init_done)
+{
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_init_complete_en : Group 3
+	 */
+	stm32mp_ddr_set_qd3_update_conditions(ctl);
+
+	udelay(DDR_DELAY_1US);
+
+	if (phy_init_done) {
+		/* Indicates to controller that PHY has completed initialization */
+		mmio_setbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+	} else {
+		/* PHY not initialized yet, wait for completion */
+		mmio_clrbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+	}
+
+	udelay(DDR_DELAY_1US);
+
+	stm32mp_ddr_unset_qd3_update_conditions(ctl);
+
+}
+
+static void disable_refresh(struct stm32mp_ddrctl *ctl)
+{
+	mmio_setbits_32((uintptr_t)&ctl->rfshctl3, DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
+
+	stm32mp_ddr_wait_refresh_update_done_ack(ctl);
+
+	udelay(DDR_DELAY_1US);
+
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl,
+			DDRCTRL_PWRCTL_POWERDOWN_EN | DDRCTRL_PWRCTL_SELFREF_EN);
+
+	udelay(DDR_DELAY_1US);
+
+	set_dfi_init_complete_en(ctl, false);
+}
+
+static void restore_refresh(struct stm32mp_ddrctl *ctl, uint32_t rfshctl3, uint32_t pwrctl)
+{
+	if ((rfshctl3 & DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH) == 0U) {
+		mmio_clrbits_32((uintptr_t)&ctl->rfshctl3, DDRCTRL_RFSHCTL3_DIS_AUTO_REFRESH);
+
+		stm32mp_ddr_wait_refresh_update_done_ack(ctl);
+
+		udelay(DDR_DELAY_1US);
+	}
+
+	if ((pwrctl & DDRCTRL_PWRCTL_SELFREF_SW) != 0U) {
+		mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+
+		udelay(DDR_DELAY_1US);
+	}
+
+	if ((pwrctl & DDRCTRL_PWRCTL_POWERDOWN_EN) != 0U) {
+		mmio_setbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_POWERDOWN_EN);
+
+		udelay(DDR_DELAY_1US);
+	}
+
+	if ((pwrctl & DDRCTRL_PWRCTL_SELFREF_EN) != 0U) {
+		mmio_setbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_EN);
+
+		udelay(DDR_DELAY_1US);
+	}
+
+	set_dfi_init_complete_en(ctl, true);
+}
+
+void stm32mp2_ddr_init(struct stm32mp_ddr_priv *priv,
+		       struct stm32mp_ddr_config *config)
+{
+	int ret = -EINVAL;
+	uint32_t ddr_retdis;
+	enum ddr_type ddr_type;
+	bool cid_filtering = is_ddr_cid_filtering_enabled();
+
+	if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR3) != 0U) {
+		ddr_type = STM32MP_DDR3;
+	} else if ((config->c_reg.mstr & DDRCTRL_MSTR_DDR4) != 0U) {
+		ddr_type = STM32MP_DDR4;
+	} else if ((config->c_reg.mstr & DDRCTRL_MSTR_LPDDR4) != 0U) {
+		ddr_type = STM32MP_LPDDR4;
+	} else {
+		ERROR("DDR type not supported\n");
+		panic();
+	}
+
+	VERBOSE("name = %s\n", config->info.name);
+	VERBOSE("speed = %u kHz\n", config->info.speed);
+	VERBOSE("size  = 0x%zx\n", config->info.size);
+	if (config->self_refresh) {
+		VERBOSE("sel-refresh exit (zdata = 0x%x)\n", config->zdata);
+	}
+
+	/* Check DDR PHY pads retention */
+	if (cid_filtering) {
+		ddr_disable_cid_filtering();
+	}
+	ddr_retdis = mmio_read_32(priv->pwr + PWR_CR11) & PWR_CR11_DDRRETDIS;
+	if (cid_filtering) {
+		ddr_enable_cid_filtering();
+	}
+
+	if (config->self_refresh) {
+		if (ddr_retdis == PWR_CR11_DDRRETDIS) {
+			VERBOSE("self-refresh aborted: no retention\n");
+			config->self_refresh = false;
+		}
+	}
+
+	if (config->self_refresh) {
+		ddr_standby_reset(priv);
+
+		VERBOSE("disable DDR PHY retention\n");
+		if (cid_filtering) {
+			ddr_disable_cid_filtering();
+		}
+		mmio_setbits_32(priv->pwr + PWR_CR11, PWR_CR11_DDRRETDIS);
+		if (cid_filtering) {
+			ddr_enable_cid_filtering();
+		}
+
+		udelay(DDR_DELAY_1US);
+
+		mmio_clrbits_32(priv->rcc + RCC_DDRCAPBCFGR, RCC_DDRCAPBCFGR_DDRCAPBRST);
+
+		udelay(DDR_DELAY_1US);
+
+	} else {
+		if (stm32mp_board_ddr_power_init(ddr_type) != 0) {
+			ERROR("DDR power init failed\n");
+			panic();
+		}
+
+		VERBOSE("disable DDR PHY retention\n");
+		if (cid_filtering) {
+			ddr_disable_cid_filtering();
+		}
+		mmio_setbits_32(priv->pwr + PWR_CR11, PWR_CR11_DDRRETDIS);
+		if (cid_filtering) {
+			ddr_enable_cid_filtering();
+		}
+
+		ddr_reset(priv);
+
+		ddr_sysconf_configuration(priv, config);
+	}
+
+#if STM32MP_LPDDR4_TYPE
+	/*
+	 * Enable PWRCTL.SELFREF_SW to ensure correct setting of PWRCTL.LPDDR4_SR_ALLOWED.
+	 * Later disabled in restore_refresh().
+	*/
+	config->c_reg.pwrctl |= DDRCTRL_PWRCTL_SELFREF_SW;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	stm32mp_ddr_set_reg(priv, REG_REG, &config->c_reg, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_TIMING, &config->c_timing, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_MAP, &config->c_map, ddr_registers);
+	stm32mp_ddr_set_reg(priv, REG_PERF, &config->c_perf, ddr_registers);
+
+	if (!config->self_refresh) {
+		/*  DDR core and PHY reset de-assert */
+		mmio_clrbits_32(priv->rcc + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+
+		disable_refresh(priv->ctl);
+	}
+
+	if (config->self_refresh) {
+		ddr_standby_reset_release(priv);
+
+		/* Initialize DDR by skipping training and disabling result saving */
+		ret = ddrphy_phyinit_sequence(config, true, false);
+
+		if (ret == 0) {
+			ret = ddrphy_phyinit_restore_sequence();
+		}
+
+		/* Poll on ddrphy_initeng0_phyinlpx.phyinlp3 = 0 */
+		ddr_wait_lp3_mode(false);
+	} else {
+		/* Initialize DDR including training and result saving */
+		ret = ddrphy_phyinit_sequence(config, false, true);
+	}
+
+	if (ret != 0) {
+		ERROR("DDR PHY init: Error %d\n", ret);
+		panic();
+	}
+
+	ddr_activate_controller(priv->ctl, false);
+
+	if (config->self_refresh) {
+		struct stm32mp_ddrctl *ctl = priv->ctl;
+
+		/* SW self refresh exit prequested */
+		mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+
+		if (ddr_sr_exit_loop() != 0) {
+			ERROR("DDR Standby exit error\n");
+			panic();
+		}
+
+		/* Re-enable DFI low-power interface */
+		mmio_clrbits_32((uintptr_t)&ctl->dfilpcfg0, DDRCTRL_DFILPCFG0_DFI_LP_EN_SR);
+	} else {
+		restore_refresh(priv->ctl, config->c_reg.rfshctl3, config->c_reg.pwrctl);
+	}
+
+	stm32mp_ddr_enable_axi_port(priv->ctl);
+}
diff --git a/drivers/st/ddr/stm32mp2_ddr_helpers.c b/drivers/st/ddr/stm32mp2_ddr_helpers.c
new file mode 100644
index 0000000000..74b6e46dc3
--- /dev/null
+++ b/drivers/st/ddr/stm32mp2_ddr_helpers.c
@@ -0,0 +1,556 @@
+/*
+ * Copyright (c) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp2_ddr.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <drivers/st/stm32mp2_ddr_regs.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+/* HW idle period (unit: Multiples of 32 DFI clock cycles) */
+#define HW_IDLE_PERIOD			0x3U
+
+static enum stm32mp2_ddr_sr_mode saved_ddr_sr_mode;
+
+#pragma weak stm32_ddrdbg_get_base
+uintptr_t stm32_ddrdbg_get_base(void)
+{
+	return 0U;
+}
+
+static void set_qd1_qd3_update_conditions(struct stm32mp_ddrctl *ctl)
+{
+	mmio_setbits_32((uintptr_t)&ctl->dbg1, DDRCTRL_DBG1_DIS_DQ);
+
+	stm32mp_ddr_set_qd3_update_conditions(ctl);
+}
+
+static void unset_qd1_qd3_update_conditions(struct stm32mp_ddrctl *ctl)
+{
+	stm32mp_ddr_unset_qd3_update_conditions(ctl);
+
+	mmio_clrbits_32((uintptr_t)&ctl->dbg1, DDRCTRL_DBG1_DIS_DQ);
+}
+
+static void wait_dfi_init_complete(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t dfistat;
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		dfistat = mmio_read_32((uintptr_t)&ctl->dfistat);
+		VERBOSE("[0x%lx] dfistat = 0x%x ", (uintptr_t)&ctl->dfistat, dfistat);
+
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+	} while ((dfistat & DDRCTRL_DFISTAT_DFI_INIT_COMPLETE) == 0U);
+
+	VERBOSE("[0x%lx] dfistat = 0x%x\n", (uintptr_t)&ctl->dfistat, dfistat);
+}
+
+static void disable_dfi_low_power_interface(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t dfistat;
+	uint32_t stat;
+
+	mmio_clrbits_32((uintptr_t)&ctl->dfilpcfg0, DDRCTRL_DFILPCFG0_DFI_LP_EN_SR);
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		dfistat = mmio_read_32((uintptr_t)&ctl->dfistat);
+		stat = mmio_read_32((uintptr_t)&ctl->stat);
+		VERBOSE("[0x%lx] dfistat = 0x%x ", (uintptr_t)&ctl->dfistat, dfistat);
+		VERBOSE("[0x%lx] stat = 0x%x ", (uintptr_t)&ctl->stat, stat);
+
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+	} while (((dfistat & DDRCTRL_DFISTAT_DFI_LP_ACK) != 0U) ||
+		 ((stat & DDRCTRL_STAT_OPERATING_MODE_MASK) == DDRCTRL_STAT_OPERATING_MODE_SR));
+
+	VERBOSE("[0x%lx] dfistat = 0x%x\n", (uintptr_t)&ctl->dfistat, dfistat);
+	VERBOSE("[0x%lx] stat = 0x%x\n", (uintptr_t)&ctl->stat, stat);
+}
+
+void ddr_activate_controller(struct stm32mp_ddrctl *ctl, bool sr_entry)
+{
+	/*
+	 * Manage quasi-dynamic registers modification
+	 * dfimisc.dfi_frequency : Group 1
+	 * dfimisc.dfi_init_complete_en and dfimisc.dfi_init_start : Group 3
+	 */
+	set_qd1_qd3_update_conditions(ctl);
+
+	if (sr_entry) {
+		mmio_setbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_FREQUENCY);
+	} else {
+		mmio_clrbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_FREQUENCY);
+	}
+
+	mmio_setbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_START);
+	mmio_clrbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_START);
+
+	wait_dfi_init_complete(ctl);
+
+	udelay(DDR_DELAY_1US);
+
+	if (sr_entry) {
+		mmio_clrbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+	} else {
+		mmio_setbits_32((uintptr_t)&ctl->dfimisc, DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN);
+	}
+
+	udelay(DDR_DELAY_1US);
+
+	unset_qd1_qd3_update_conditions(ctl);
+}
+
+#if STM32MP_LPDDR4_TYPE
+static void disable_phy_ddc(void)
+{
+	/* Enable APB access to internal CSR registers */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_APBONLY0_MICROCONTMUXSEL, 0U);
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_DRTUB0_UCCLKHCLKENABLES,
+		      DDRPHY_DRTUB0_UCCLKHCLKENABLES_UCCLKEN |
+		      DDRPHY_DRTUB0_UCCLKHCLKENABLES_HCLKEN);
+
+	/* Disable DRAM drift compensation */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_INITENG0_P0_SEQ0BDISABLEFLAG6, 0xFFFFU);
+
+	/* Disable APB access to internal CSR registers */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_DRTUB0_UCCLKHCLKENABLES,
+		      DDRPHY_DRTUB0_UCCLKHCLKENABLES_HCLKEN);
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_APBONLY0_MICROCONTMUXSEL,
+		      DDRPHY_APBONLY0_MICROCONTMUXSEL_MICROCONTMUXSEL);
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+void ddr_wait_lp3_mode(bool sr_entry)
+{
+	uint64_t timeout;
+	bool repeat_loop = false;
+
+	/* Enable APB access to internal CSR registers */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_APBONLY0_MICROCONTMUXSEL, 0U);
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_DRTUB0_UCCLKHCLKENABLES,
+		      DDRPHY_DRTUB0_UCCLKHCLKENABLES_UCCLKEN |
+		      DDRPHY_DRTUB0_UCCLKHCLKENABLES_HCLKEN);
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		uint16_t phyinlpx = mmio_read_32(stm32mp_ddrphyc_base() +
+						 DDRPHY_INITENG0_P0_PHYINLPX);
+
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+
+		if (sr_entry) {
+			repeat_loop = (phyinlpx & DDRPHY_INITENG0_P0_PHYINLPX_PHYINLP3) == 0U;
+		} else {
+			repeat_loop = (phyinlpx & DDRPHY_INITENG0_P0_PHYINLPX_PHYINLP3) != 0U;
+		}
+	} while (repeat_loop);
+
+	/* Disable APB access to internal CSR registers */
+#if STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_DRTUB0_UCCLKHCLKENABLES, 0U);
+#else /* STM32MP_LPDDR4_TYPE */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_DRTUB0_UCCLKHCLKENABLES,
+		      DDRPHY_DRTUB0_UCCLKHCLKENABLES_HCLKEN);
+#endif /* STM32MP_DDR3_TYPE || STM32MP_DDR4_TYPE */
+	mmio_write_32(stm32mp_ddrphyc_base() + DDRPHY_APBONLY0_MICROCONTMUXSEL,
+		      DDRPHY_APBONLY0_MICROCONTMUXSEL_MICROCONTMUXSEL);
+}
+
+static int sr_loop(bool is_entry)
+{
+	uint32_t type;
+	uint32_t state __maybe_unused;
+	uint64_t timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	bool repeat_loop = false;
+
+	/*
+	 * Wait for DDRCTRL to be out of or back to "normal/mission mode".
+	 * Consider also SRPD mode for LPDDR4 only.
+	 */
+	do {
+		type = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_STAT) &
+		       DDRCTRL_STAT_SELFREF_TYPE_MASK;
+#if STM32MP_LPDDR4_TYPE
+		state = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_STAT) &
+		       DDRCTRL_STAT_SELFREF_STATE_MASK;
+#endif /* STM32MP_LPDDR4_TYPE */
+
+		if (timeout_elapsed(timeout)) {
+			return -ETIMEDOUT;
+		}
+
+		if (is_entry) {
+#if STM32MP_LPDDR4_TYPE
+			repeat_loop = (type == 0x0U) || (state != DDRCTRL_STAT_SELFREF_STATE_SRPD);
+#else /* !STM32MP_LPDDR4_TYPE */
+			repeat_loop = (type == 0x0U);
+#endif /* STM32MP_LPDDR4_TYPE */
+		} else {
+#if STM32MP_LPDDR4_TYPE
+			repeat_loop = (type != 0x0U) || (state != 0x0U);
+#else /* !STM32MP_LPDDR4_TYPE */
+			repeat_loop = (type != 0x0U);
+#endif /* STM32MP_LPDDR4_TYPE */
+		}
+	} while (repeat_loop);
+
+	return 0;
+}
+
+static int sr_entry_loop(void)
+{
+	return sr_loop(true);
+}
+
+int ddr_sr_exit_loop(void)
+{
+	return sr_loop(false);
+}
+
+bool is_ddr_cid_filtering_enabled(void)
+{
+	return (mmio_read_32(stm32mp_rcc_base() + RCC_R104CIDCFGR) & RCC_R104CIDCFGR_CFEN) ==
+	       RCC_R104CIDCFGR_CFEN;
+}
+
+void ddr_enable_cid_filtering(void)
+{
+	mmio_setbits_32(stm32mp_rcc_base() + RCC_R104CIDCFGR, RCC_R104CIDCFGR_CFEN);
+}
+
+void ddr_disable_cid_filtering(void)
+{
+	mmio_clrbits_32(stm32mp_rcc_base() + RCC_R104CIDCFGR, RCC_R104CIDCFGR_CFEN);
+}
+
+static int sr_ssr_set(void)
+{
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	/*
+	 * Disable Clock disable with LP modes
+	 * (used in RUN mode for LPDDR2 with specific timing).
+	*/
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL, DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE);
+
+	/* Disable automatic Self-Refresh mode */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL, DDRCTRL_PWRCTL_SELFREF_EN);
+
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_LP_DISABLE,
+		      DDRDBG_LP_DISABLE_LPI_XPI_DISABLE | DDRDBG_LP_DISABLE_LPI_DDRC_DISABLE);
+
+	return 0;
+}
+
+static int sr_ssr_entry(bool standby)
+{
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	if (stm32mp_ddr_disable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base) != 0) {
+		panic();
+	}
+
+#if STM32MP_LPDDR4_TYPE
+	if (standby) {
+		/* Disable DRAM drift compensation */
+		disable_phy_ddc();
+	}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	disable_dfi_low_power_interface((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	/* SW self refresh entry prequested */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
+#if STM32MP_LPDDR4_TYPE
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL, DDRCTRL_PWRCTL_STAY_IN_SELFREF);
+#endif /* STM32MP_LPDDR4_TYPE */
+
+	if (sr_entry_loop() != 0) {
+		return -1;
+	}
+
+	ddr_activate_controller((struct stm32mp_ddrctl *)ddrctrl_base, true);
+
+	/* Poll on ddrphy_initeng0_phyinlpx.phyinlp3 = 1 */
+	ddr_wait_lp3_mode(true);
+
+	if (standby) {
+		bool cid_filtering = is_ddr_cid_filtering_enabled();
+
+		if (cid_filtering) {
+			ddr_disable_cid_filtering();
+		}
+		mmio_clrbits_32(stm32mp_pwr_base() + PWR_CR11, PWR_CR11_DDRRETDIS);
+		if (cid_filtering) {
+			ddr_enable_cid_filtering();
+		}
+	}
+
+	mmio_clrsetbits_32(rcc_base + RCC_DDRCPCFGR, RCC_DDRCPCFGR_DDRCPLPEN,
+			   RCC_DDRCPCFGR_DDRCPEN);
+	mmio_setbits_32(rcc_base + RCC_DDRPHYCCFGR, RCC_DDRPHYCCFGR_DDRPHYCEN);
+	mmio_setbits_32(rcc_base + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRPHYDLP);
+
+	return 0;
+}
+
+static int sr_ssr_exit(void)
+{
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	mmio_setbits_32(rcc_base + RCC_DDRCPCFGR,
+			RCC_DDRCPCFGR_DDRCPLPEN | RCC_DDRCPCFGR_DDRCPEN);
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRPHYDLP);
+	mmio_setbits_32(rcc_base + RCC_DDRPHYCCFGR, RCC_DDRPHYCCFGR_DDRPHYCEN);
+
+	udelay(DDR_DELAY_1US);
+
+	ddr_activate_controller((struct stm32mp_ddrctl *)ddrctrl_base, false);
+
+	/* Poll on ddrphy_initeng0_phyinlpx.phyinlp3 = 0 */
+	ddr_wait_lp3_mode(false);
+
+	/* SW self refresh exit prequested */
+	mmio_clrbits_32(ddrctrl_base + DDRCTRL_PWRCTL, DDRCTRL_PWRCTL_SELFREF_SW);
+
+	if (ddr_sr_exit_loop() != 0) {
+		return -1;
+	}
+
+	/* Re-enable DFI low-power interface */
+	mmio_setbits_32(ddrctrl_base + DDRCTRL_DFILPCFG0, DDRCTRL_DFILPCFG0_DFI_LP_EN_SR);
+
+	stm32mp_ddr_enable_axi_port((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	return 0;
+}
+
+static int sr_hsr_set(void)
+{
+	uintptr_t ddrctrl_base = stm32mp_ddrctrl_base();
+
+	mmio_clrsetbits_32(stm32mp_rcc_base() + RCC_DDRITFCFGR,
+			   RCC_DDRITFCFGR_DDRCKMOD_MASK, RCC_DDRITFCFGR_DDRCKMOD_HSR);
+
+	/*
+	 * manage quasi-dynamic registers modification
+	 * hwlpctl.hw_lp_en : Group 2
+	 */
+	if (stm32mp_ddr_sw_selfref_entry((struct stm32mp_ddrctl *)ddrctrl_base) != 0) {
+		panic();
+	}
+	stm32mp_ddr_start_sw_done((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	mmio_write_32(ddrctrl_base + DDRCTRL_HWLPCTL,
+		      DDRCTRL_HWLPCTL_HW_LP_EN | DDRCTRL_HWLPCTL_HW_LP_EXIT_IDLE_EN |
+		      (HW_IDLE_PERIOD << DDRCTRL_HWLPCTL_HW_LP_IDLE_X32_SHIFT));
+
+	stm32mp_ddr_wait_sw_done_ack((struct stm32mp_ddrctl *)ddrctrl_base);
+	stm32mp_ddr_sw_selfref_exit((struct stm32mp_ddrctl *)ddrctrl_base);
+
+	return 0;
+}
+
+static int sr_hsr_entry(void)
+{
+	mmio_write_32(stm32mp_rcc_base() + RCC_DDRCPCFGR, RCC_DDRCPCFGR_DDRCPLPEN);
+
+	return sr_entry_loop(); /* read_data should be equal to 0x223 */
+}
+
+static int sr_hsr_exit(void)
+{
+	mmio_write_32(stm32mp_rcc_base() + RCC_DDRCPCFGR,
+		      RCC_DDRCPCFGR_DDRCPLPEN | RCC_DDRCPCFGR_DDRCPEN);
+
+	/* TODO: check if ddr_sr_exit_loop() is needed here */
+
+	return 0;
+}
+
+static int sr_asr_set(void)
+{
+	mmio_write_32(stm32_ddrdbg_get_base() + DDRDBG_LP_DISABLE, 0U);
+
+	return 0;
+}
+
+static int sr_asr_entry(void)
+{
+	/*
+	 * Automatically enter into self refresh when there is no ddr traffic
+	 * for the delay programmed into SYSCONF_DDRC_AUTO_SR_DELAY register.
+	 * Default value is 0x20 (unit: Multiples of 32 DFI clock cycles).
+	 */
+	return sr_entry_loop();
+}
+
+static int sr_asr_exit(void)
+{
+	return ddr_sr_exit_loop();
+}
+
+uint32_t ddr_get_io_calibration_val(void)
+{
+	/* TODO create related service */
+
+	return 0U;
+}
+
+int ddr_sr_entry(bool standby)
+{
+	int ret = -EINVAL;
+
+	switch (saved_ddr_sr_mode) {
+	case DDR_SSR_MODE:
+		ret = sr_ssr_entry(standby);
+		break;
+	case DDR_HSR_MODE:
+		ret = sr_hsr_entry();
+		break;
+	case DDR_ASR_MODE:
+		ret = sr_asr_entry();
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+int ddr_sr_exit(void)
+{
+	int ret = -EINVAL;
+
+	switch (saved_ddr_sr_mode) {
+	case DDR_SSR_MODE:
+		ret = sr_ssr_exit();
+		break;
+	case DDR_HSR_MODE:
+		ret = sr_hsr_exit();
+		break;
+	case DDR_ASR_MODE:
+		ret = sr_asr_exit();
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+enum stm32mp2_ddr_sr_mode ddr_read_sr_mode(void)
+{
+	uint32_t pwrctl = mmio_read_32(stm32mp_ddrctrl_base() + DDRCTRL_PWRCTL);
+	enum stm32mp2_ddr_sr_mode mode = DDR_SR_MODE_INVALID;
+
+	switch (pwrctl & (DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE |
+			  DDRCTRL_PWRCTL_SELFREF_EN)) {
+	case 0U:
+		mode = DDR_SSR_MODE;
+		break;
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE:
+		mode = DDR_HSR_MODE;
+		break;
+	case DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE | DDRCTRL_PWRCTL_SELFREF_EN:
+		mode = DDR_ASR_MODE;
+		break;
+	default:
+		break;
+	}
+
+	return mode;
+}
+
+void ddr_set_sr_mode(enum stm32mp2_ddr_sr_mode mode)
+{
+	int ret = -EINVAL;
+
+	if (mode == saved_ddr_sr_mode) {
+		return;
+	}
+
+	switch (mode) {
+	case DDR_SSR_MODE:
+		ret = sr_ssr_set();
+		break;
+	case DDR_HSR_MODE:
+		ret = sr_hsr_set();
+		break;
+	case DDR_ASR_MODE:
+		ret = sr_asr_set();
+		break;
+	default:
+		break;
+	}
+
+	if (ret != 0) {
+		ERROR("Unknown Self Refresh mode\n");
+		panic();
+	}
+
+	saved_ddr_sr_mode = mode;
+}
+
+void ddr_save_sr_mode(void)
+{
+	saved_ddr_sr_mode = ddr_read_sr_mode();
+}
+
+void ddr_restore_sr_mode(void)
+{
+	ddr_set_sr_mode(saved_ddr_sr_mode);
+}
+
+void ddr_sub_system_clk_init(void)
+{
+	mmio_write_32(stm32mp_rcc_base() + RCC_DDRCPCFGR,
+		      RCC_DDRCPCFGR_DDRCPEN | RCC_DDRCPCFGR_DDRCPLPEN);
+}
+
+void ddr_sub_system_clk_off(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	bool cid_filtering = is_ddr_cid_filtering_enabled();
+
+	/* Clear DDR IO retention */
+	if (cid_filtering) {
+		ddr_disable_cid_filtering();
+	}
+	mmio_clrbits_32(stm32mp_pwr_base() + PWR_CR11, PWR_CR11_DDRRETDIS);
+	if (cid_filtering) {
+		ddr_enable_cid_filtering();
+	}
+
+	/* Reset DDR sub system */
+	mmio_write_32(rcc_base + RCC_DDRCPCFGR, RCC_DDRCPCFGR_DDRCPRST);
+	mmio_write_32(rcc_base + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRRST);
+	mmio_write_32(rcc_base + RCC_DDRPHYCAPBCFGR, RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST);
+	mmio_write_32(rcc_base + RCC_DDRCAPBCFGR, RCC_DDRCAPBCFGR_DDRCAPBRST);
+
+	/* Deactivate clocks and PLL2 */
+	mmio_clrbits_32(rcc_base + RCC_DDRPHYCCFGR, RCC_DDRPHYCCFGR_DDRPHYCEN);
+	mmio_clrbits_32(rcc_base + RCC_PLL2CFGR1, RCC_PLL2CFGR1_PLLEN);
+}
diff --git a/drivers/st/ddr/stm32mp2_ram.c b/drivers/st/ddr/stm32mp2_ram.c
new file mode 100644
index 0000000000..e37594d2c2
--- /dev/null
+++ b/drivers/st/ddr/stm32mp2_ram.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp_ddr_test.h>
+#include <drivers/st/stm32mp_ram.h>
+#include <drivers/st/stm32mp2_ddr.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <drivers/st/stm32mp2_ram.h>
+#include <lib/mmio.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+static struct stm32mp_ddr_priv ddr_priv_data;
+static bool ddr_self_refresh;
+
+static int ddr_dt_get_ui_param(void *fdt, int node, struct stm32mp_ddr_config *config)
+{
+	int ret;
+	uint32_t size;
+
+	size = sizeof(struct user_input_basic) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-basic", size, (uint32_t *)&config->uib);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-basic", size, ret);
+	if (ret != 0) {
+		ERROR("%s: can't read %s, error=%d\n", __func__, "st,phy-basic", ret);
+		return -EINVAL;
+	}
+
+	size = sizeof(struct user_input_advanced) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-advanced", size, (uint32_t *)&config->uia);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-advanced", size, ret);
+	if (ret != 0) {
+		ERROR("%s: can't read %s, error=%d\n", __func__, "st,phy-advanced", ret);
+		return -EINVAL;
+	}
+
+	size = sizeof(struct user_input_mode_register) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-mr", size, (uint32_t *)&config->uim);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-mr", size, ret);
+	if (ret != 0) {
+		ERROR("%s: can't read %s, error=%d\n", __func__, "st,phy-mr", ret);
+		return -EINVAL;
+	}
+
+	size = sizeof(struct user_input_swizzle) / sizeof(int);
+	ret = fdt_read_uint32_array(fdt, node, "st,phy-swizzle", size, (uint32_t *)&config->uis);
+
+	VERBOSE("%s: %s[0x%x] = %d\n", __func__, "st,phy-swizzle", size, ret);
+	if (ret != 0) {
+		ERROR("%s: can't read %s, error=%d\n", __func__, "st,phy-swizzle", ret);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32mp2_ddr_setup(void)
+{
+	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
+	int ret;
+	struct stm32mp_ddr_config config;
+	int node;
+	uintptr_t uret;
+	void *fdt;
+
+	const struct stm32mp_ddr_param param[] = {
+		CTL_PARAM(reg),
+		CTL_PARAM(timing),
+		CTL_PARAM(map),
+		CTL_PARAM(perf)
+	};
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_DDR_COMPAT);
+	if (node < 0) {
+		ERROR("%s: can't read DDR node in DT\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = stm32mp_ddr_dt_get_info(fdt, node, &config.info);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = stm32mp_ddr_dt_get_param(fdt, node, param, ARRAY_SIZE(param), (uintptr_t)&config);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = ddr_dt_get_ui_param(fdt, node, &config);
+	if (ret < 0) {
+		return ret;
+	}
+
+	config.self_refresh = false;
+
+	if (stm32mp_is_wakeup_from_standby()) {
+		config.self_refresh = true;
+	}
+
+	/*  Map dynamically RETRAM area to save or restore PHY retention registers */
+	if (stm32mp_map_retram() != 0) {
+		panic();
+	}
+
+	stm32mp2_ddr_init(priv, &config);
+
+	/*  Unmap RETRAM, no more used until next DDR initialization call */
+	if (stm32mp_unmap_retram() != 0) {
+		panic();
+	}
+
+	priv->info.size = config.info.size;
+
+	VERBOSE("%s : ram size(%lx, %lx)\n", __func__, priv->info.base, priv->info.size);
+
+	if (stm32mp_map_ddr_non_cacheable() != 0) {
+		panic();
+	}
+
+	if (config.self_refresh) {
+		uret = stm32mp_ddr_test_rw_access();
+		if (uret != 0UL) {
+			ERROR("DDR rw test: can't access memory @ 0x%lx\n", uret);
+			panic();
+		}
+
+		/* TODO Restore area overwritten by training */
+		//stm32_restore_ddr_training_area();
+	} else {
+		size_t retsize;
+
+		uret = stm32mp_ddr_test_data_bus();
+		if (uret != 0UL) {
+			ERROR("DDR data bus test: can't access memory @ 0x%lx\n", uret);
+			panic();
+		}
+
+		uret = stm32mp_ddr_test_addr_bus(config.info.size);
+		if (uret != 0UL) {
+			ERROR("DDR addr bus test: can't access memory @ 0x%lx\n", uret);
+			panic();
+		}
+
+		retsize = stm32mp_ddr_check_size();
+		if (retsize < config.info.size) {
+			ERROR("DDR size: 0x%zx does not match DT config: 0x%zx\n",
+			      retsize, config.info.size);
+			panic();
+		}
+
+		INFO("Memory size = 0x%zx (%zu MB)\n", retsize, retsize / (1024U * 1024U));
+	}
+
+	/*
+	 * Initialization sequence has configured DDR registers with settings.
+	 * The Self Refresh (SR) mode corresponding to these settings has now
+	 * to be set.
+	 */
+	ddr_set_sr_mode(ddr_read_sr_mode());
+
+	if (stm32mp_unmap_ddr() != 0) {
+		panic();
+	}
+
+	/* Save DDR self_refresh state */
+	ddr_self_refresh = config.self_refresh;
+
+	return 0;
+}
+
+bool stm32mp2_ddr_is_restored(void)
+{
+	return ddr_self_refresh;
+}
+
+int stm32mp2_ddr_probe(void)
+{
+	struct stm32mp_ddr_priv *priv = &ddr_priv_data;
+
+	VERBOSE("STM32MP DDR probe\n");
+
+	priv->ctl = (struct stm32mp_ddrctl *)stm32mp_ddrctrl_base();
+	priv->phy = (struct stm32mp_ddrphy *)stm32mp_ddrphyc_base();
+	priv->pwr = stm32mp_pwr_base();
+	priv->rcc = stm32mp_rcc_base();
+
+	priv->info.base = STM32MP_DDR_BASE;
+	priv->info.size = 0;
+
+	return stm32mp2_ddr_setup();
+}
diff --git a/drivers/st/ddr/stm32mp_ddr.c b/drivers/st/ddr/stm32mp_ddr.c
index 6776e3ba8c..8b35bda041 100644
--- a/drivers/st/ddr/stm32mp_ddr.c
+++ b/drivers/st/ddr/stm32mp_ddr.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2024, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -8,13 +8,15 @@
 #include <drivers/delay_timer.h>
 #include <drivers/st/stm32mp_ddr.h>
 #include <drivers/st/stm32mp_ddrctrl_regs.h>
-#include <drivers/st/stm32mp_pmic.h>
 #include <lib/mmio.h>
 
 #include <platform_def.h>
 
 #define INVALID_OFFSET	0xFFU
 
+static bool axi_port_reenable_request;
+static bool host_interface_reenable_request;
+
 static uintptr_t get_base_addr(const struct stm32mp_ddr_priv *priv, enum stm32mp_ddr_base_type base)
 {
 	if (base == DDRPHY_BASE) {
@@ -38,12 +40,22 @@ void stm32mp_ddr_set_reg(const struct stm32mp_ddr_priv *priv, enum stm32mp_ddr_r
 		uintptr_t ptr = base_addr + desc[i].offset;
 
 		if (desc[i].par_offset == INVALID_OFFSET) {
-			ERROR("invalid parameter offset for %s", desc[i].name);
+			ERROR("invalid parameter offset\n");
 			panic();
 		} else {
+#if STM32MP25
+			if (desc[i].qd) {
+				stm32mp_ddr_start_sw_done(priv->ctl);
+			}
+#endif
 			value = *((uint32_t *)((uintptr_t)param +
 					       desc[i].par_offset));
 			mmio_write_32(ptr, value);
+#if STM32MP25
+			if (desc[i].qd) {
+				stm32mp_ddr_wait_sw_done_ack(priv->ctl);
+			}
+#endif
 		}
 	}
 }
@@ -66,7 +78,7 @@ void stm32mp_ddr_wait_sw_done_ack(struct stm32mp_ddrctl *ctl)
 	VERBOSE("[0x%lx] swctl = 0x%x\n",
 		(uintptr_t)&ctl->swctl, mmio_read_32((uintptr_t)&ctl->swctl));
 
-	timeout = timeout_init_us(TIMEOUT_US_1S);
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
 	do {
 		swstat = mmio_read_32((uintptr_t)&ctl->swstat);
 		VERBOSE("[0x%lx] swstat = 0x%x ",
@@ -93,14 +105,194 @@ void stm32mp_ddr_enable_axi_port(struct stm32mp_ddrctl *ctl)
 	VERBOSE("[0x%lx] pctrl_1 = 0x%x\n", (uintptr_t)&ctl->pctrl_1,
 		mmio_read_32((uintptr_t)&ctl->pctrl_1));
 #endif
+}
+
+int stm32mp_ddr_disable_axi_port(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t pstat;
+
+	/* Disable uMCTL2 AXI port 0 */
+	mmio_clrbits_32((uintptr_t)&ctl->pctrl_0, DDRCTRL_PCTRL_N_PORT_EN);
+	VERBOSE("[0x%lx] pctrl_0 = 0x%x\n", (uintptr_t)&ctl->pctrl_0,
+		mmio_read_32((uintptr_t)&ctl->pctrl_0));
+
+#if STM32MP_DDR_DUAL_AXI_PORT
+	/* Disable uMCTL2 AXI port 1 */
+	mmio_clrbits_32((uintptr_t)&ctl->pctrl_1, DDRCTRL_PCTRL_N_PORT_EN);
+	VERBOSE("[0x%lx] pctrl_1 = 0x%x\n", (uintptr_t)&ctl->pctrl_1,
+		mmio_read_32((uintptr_t)&ctl->pctrl_1));
+#endif
+
+	/*
+	 * Waits until all AXI ports are idle
+	 * Poll PSTAT.rd_port_busy_n = 0
+	 * Poll PSTAT.wr_port_busy_n = 0
+	 */
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		pstat = mmio_read_32((uintptr_t)&ctl->pstat);
+		VERBOSE("[0x%lx] pstat = 0x%x ",
+			(uintptr_t)&ctl->pstat, pstat);
+		if (timeout_elapsed(timeout)) {
+			return -1;
+		}
+	} while (pstat != 0U);
+
+	return 0;
+}
+
+static bool ddr_is_axi_port_enabled(struct stm32mp_ddrctl *ctl)
+{
+	return (mmio_read_32((uintptr_t)&ctl->pctrl_0) & DDRCTRL_PCTRL_N_PORT_EN) != 0U;
+}
+
+void stm32mp_ddr_enable_host_interface(struct stm32mp_ddrctl *ctl)
+{
+	mmio_clrbits_32((uintptr_t)&ctl->dbg1, DDRCTRL_DBG1_DIS_HIF);
+	VERBOSE("[0x%lx] dbg1 = 0x%x\n",
+		(uintptr_t)&ctl->dbg1,
+		mmio_read_32((uintptr_t)&ctl->dbg1));
+}
+
+void stm32mp_ddr_disable_host_interface(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t dbgcam;
+	int count = 0;
+
+	mmio_setbits_32((uintptr_t)&ctl->dbg1, DDRCTRL_DBG1_DIS_HIF);
+	VERBOSE("[0x%lx] dbg1 = 0x%x\n",
+		(uintptr_t)&ctl->dbg1,
+		mmio_read_32((uintptr_t)&ctl->dbg1));
+
+	/*
+	 * Waits until all queues and pipelines are empty
+	 * Poll DBGCAM.dbg_wr_q_empty = 1
+	 * Poll DBGCAM.dbg_rd_q_empty = 1
+	 * Poll DBGCAM.dbg_wr_data_pipeline_empty = 1
+	 * Poll DBGCAM.dbg_rd_data_pipeline_empty = 1
+	 *
+	 * data_pipeline fields must be polled twice to ensure
+	 * value propoagation, so count is added to loop condition.
+	 */
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		dbgcam = mmio_read_32((uintptr_t)&ctl->dbgcam);
+		VERBOSE("[0x%lx] dbgcam = 0x%x ",
+			(uintptr_t)&ctl->dbgcam, dbgcam);
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+		count++;
+	} while (((dbgcam & DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) !=
+		  DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY) || (count < 2));
+}
+
+static bool ddr_is_host_interface_enabled(struct stm32mp_ddrctl *ctl)
+{
+	return (mmio_read_32((uintptr_t)&ctl->dbg1) & DDRCTRL_DBG1_DIS_HIF) == 0U;
+}
+
+int stm32mp_ddr_sw_selfref_entry(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t stat;
+	uint32_t operating_mode;
+	uint32_t selref_type;
+
+	mmio_setbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+	VERBOSE("[0x%lx] pwrctl = 0x%x\n",
+		(uintptr_t)&ctl->pwrctl,
+		mmio_read_32((uintptr_t)&ctl->pwrctl));
+
+	/*
+	 * Wait operating mode change in self-refresh mode
+	 * with STAT.operating_mode[1:0]==11.
+	 * Ensure transition to self-refresh was due to software
+	 * by checking also that STAT.selfref_type[1:0]=2.
+	 */
+	timeout = timeout_init_us(DDR_TIMEOUT_500US);
+	while (!timeout_elapsed(timeout)) {
+		stat = mmio_read_32((uintptr_t)&ctl->stat);
+		operating_mode = stat & DDRCTRL_STAT_OPERATING_MODE_MASK;
+		selref_type = stat & DDRCTRL_STAT_SELFREF_TYPE_MASK;
+
+		if ((operating_mode == DDRCTRL_STAT_OPERATING_MODE_SR) &&
+		    (selref_type == DDRCTRL_STAT_SELFREF_TYPE_SR)) {
+			return 0;
+		}
+	}
 
+	return -1;
 }
 
-int stm32mp_board_ddr_power_init(enum ddr_type ddr_type)
+void stm32mp_ddr_sw_selfref_exit(struct stm32mp_ddrctl *ctl)
 {
-	if (dt_pmic_status() > 0) {
-		return pmic_ddr_power_init(ddr_type);
+	mmio_clrbits_32((uintptr_t)&ctl->pwrctl, DDRCTRL_PWRCTL_SELFREF_SW);
+	VERBOSE("[0x%lx] pwrctl = 0x%x\n",
+		(uintptr_t)&ctl->pwrctl,
+		mmio_read_32((uintptr_t)&ctl->pwrctl));
+}
+
+void stm32mp_ddr_set_qd3_update_conditions(struct stm32mp_ddrctl *ctl)
+{
+	if (ddr_is_axi_port_enabled(ctl)) {
+		if (stm32mp_ddr_disable_axi_port(ctl) != 0) {
+			panic();
+		}
+		axi_port_reenable_request = true;
 	}
 
-	return 0;
+	if (ddr_is_host_interface_enabled(ctl)) {
+		stm32mp_ddr_disable_host_interface(ctl);
+		host_interface_reenable_request = true;
+	}
+
+	stm32mp_ddr_start_sw_done(ctl);
+}
+
+void stm32mp_ddr_unset_qd3_update_conditions(struct stm32mp_ddrctl *ctl)
+{
+	stm32mp_ddr_wait_sw_done_ack(ctl);
+
+	if (host_interface_reenable_request) {
+		stm32mp_ddr_enable_host_interface(ctl);
+		host_interface_reenable_request = false;
+	}
+
+	if (axi_port_reenable_request) {
+		stm32mp_ddr_enable_axi_port(ctl);
+		axi_port_reenable_request = false;
+	}
+}
+
+void stm32mp_ddr_wait_refresh_update_done_ack(struct stm32mp_ddrctl *ctl)
+{
+	uint64_t timeout;
+	uint32_t rfshctl3;
+	uint32_t refresh_update_level = DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL;
+
+	/* Toggle rfshctl3.refresh_update_level */
+	rfshctl3 = mmio_read_32((uintptr_t)&ctl->rfshctl3);
+	if ((rfshctl3 & refresh_update_level) == refresh_update_level) {
+		mmio_setbits_32((uintptr_t)&ctl->rfshctl3, refresh_update_level);
+	} else {
+		mmio_clrbits_32((uintptr_t)&ctl->rfshctl3, refresh_update_level);
+		refresh_update_level = 0U;
+	}
+
+	VERBOSE("[0x%lx] rfshctl3 = 0x%x\n",
+		(uintptr_t)&ctl->rfshctl3, mmio_read_32((uintptr_t)&ctl->rfshctl3));
+
+	timeout = timeout_init_us(DDR_TIMEOUT_US_1S);
+	do {
+		rfshctl3 = mmio_read_32((uintptr_t)&ctl->rfshctl3);
+		VERBOSE("[0x%lx] rfshctl3 = 0x%x ", (uintptr_t)&ctl->rfshctl3, rfshctl3);
+		if (timeout_elapsed(timeout)) {
+			panic();
+		}
+	} while ((rfshctl3 & DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL) != refresh_update_level);
+
+	VERBOSE("[0x%lx] rfshctl3 = 0x%x\n", (uintptr_t)&ctl->rfshctl3, rfshctl3);
 }
diff --git a/drivers/st/ddr/stm32mp_ddr_test.c b/drivers/st/ddr/stm32mp_ddr_test.c
index 6733cc62cc..707a6ff086 100644
--- a/drivers/st/ddr/stm32mp_ddr_test.c
+++ b/drivers/st/ddr/stm32mp_ddr_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2024, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,27 +10,50 @@
 
 #include <platform_def.h>
 
+#ifdef __aarch64__
+#define DDR_PATTERN	0xAAAAAAAAAAAAAAAAUL
+#define DDR_ANTIPATTERN	0x5555555555555555UL
+#else /* !__aarch64__ */
 #define DDR_PATTERN	0xAAAAAAAAU
 #define DDR_ANTIPATTERN	0x55555555U
+#endif /* __aarch64__ */
+
+static void mmio_write_pattern(uintptr_t addr, u_register_t value)
+{
+#ifdef __aarch64__
+	mmio_write_64(addr, (uint64_t)value);
+#else /* !__aarch64__ */
+	mmio_write_32(addr, (uint32_t)value);
+#endif /* __aarch64__ */
+}
+
+static u_register_t mmio_read_pattern(uintptr_t addr)
+{
+#ifdef __aarch64__
+	return (u_register_t)mmio_read_64(addr);
+#else /* !__aarch64__ */
+	return (u_register_t)mmio_read_32(addr);
+#endif /* __aarch64__ */
+}
 
 /*******************************************************************************
  * This function tests a simple read/write access to the DDR.
  * Note that the previous content is restored after test.
  * Returns 0 if success, and address value else.
  ******************************************************************************/
-uint32_t stm32mp_ddr_test_rw_access(void)
+uintptr_t stm32mp_ddr_test_rw_access(void)
 {
-	uint32_t saved_value = mmio_read_32(STM32MP_DDR_BASE);
+	u_register_t saved_value = mmio_read_pattern(STM32MP_DDR_BASE);
 
-	mmio_write_32(STM32MP_DDR_BASE, DDR_PATTERN);
+	mmio_write_pattern(STM32MP_DDR_BASE, DDR_PATTERN);
 
-	if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
-		return (uint32_t)STM32MP_DDR_BASE;
+	if (mmio_read_pattern(STM32MP_DDR_BASE) != DDR_PATTERN) {
+		return STM32MP_DDR_BASE;
 	}
 
-	mmio_write_32(STM32MP_DDR_BASE, saved_value);
+	mmio_write_pattern(STM32MP_DDR_BASE, saved_value);
 
-	return 0U;
+	return 0UL;
 }
 
 /*******************************************************************************
@@ -41,19 +64,19 @@ uint32_t stm32mp_ddr_test_rw_access(void)
  * File: memtest.c - This source code belongs to Public Domain.
  * Returns 0 if success, and address value else.
  ******************************************************************************/
-uint32_t stm32mp_ddr_test_data_bus(void)
+uintptr_t stm32mp_ddr_test_data_bus(void)
 {
-	uint32_t pattern;
+	u_register_t pattern;
 
 	for (pattern = 1U; pattern != 0U; pattern <<= 1U) {
-		mmio_write_32(STM32MP_DDR_BASE, pattern);
+		mmio_write_pattern(STM32MP_DDR_BASE, pattern);
 
-		if (mmio_read_32(STM32MP_DDR_BASE) != pattern) {
-			return (uint32_t)STM32MP_DDR_BASE;
+		if (mmio_read_pattern(STM32MP_DDR_BASE) != pattern) {
+			return STM32MP_DDR_BASE;
 		}
 	}
 
-	return 0;
+	return 0UL;
 }
 
 /*******************************************************************************
@@ -65,57 +88,51 @@ uint32_t stm32mp_ddr_test_data_bus(void)
  * size: size in bytes of the DDR memory device.
  * Returns 0 if success, and address value else.
  ******************************************************************************/
-uint32_t stm32mp_ddr_test_addr_bus(uint64_t size)
+uintptr_t stm32mp_ddr_test_addr_bus(size_t size)
 {
-	uint64_t addressmask = size - 1U;
-	uint64_t offset;
-	uint64_t testoffset = 0U;
+	size_t addressmask = size - 1U;
+	size_t offset;
+	size_t testoffset = 0U;
 
 	/* Write the default pattern at each of the power-of-two offsets. */
-	for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
+	for (offset = sizeof(u_register_t); (offset & addressmask) != 0U;
 	     offset <<= 1U) {
-		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)offset,
-			      DDR_PATTERN);
+		mmio_write_pattern(STM32MP_DDR_BASE + offset, DDR_PATTERN);
 	}
 
 	/* Check for address bits stuck high. */
-	mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
-		      DDR_ANTIPATTERN);
+	mmio_write_pattern(STM32MP_DDR_BASE + testoffset, DDR_ANTIPATTERN);
 
-	for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
+	for (offset = sizeof(u_register_t); (offset & addressmask) != 0U;
 	     offset <<= 1U) {
-		if (mmio_read_32(STM32MP_DDR_BASE + (uint32_t)offset) !=
-		    DDR_PATTERN) {
-			return (uint32_t)(STM32MP_DDR_BASE + offset);
+		if (mmio_read_pattern(STM32MP_DDR_BASE + offset) != DDR_PATTERN) {
+			return STM32MP_DDR_BASE + offset;
 		}
 	}
 
-	mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset, DDR_PATTERN);
+	mmio_write_pattern(STM32MP_DDR_BASE + testoffset, DDR_PATTERN);
 
 	/* Check for address bits stuck low or shorted. */
-	for (testoffset = sizeof(uint32_t); (testoffset & addressmask) != 0U;
+	for (testoffset = sizeof(u_register_t); (testoffset & addressmask) != 0U;
 	     testoffset <<= 1U) {
-		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
-			      DDR_ANTIPATTERN);
+		mmio_write_pattern(STM32MP_DDR_BASE + testoffset, DDR_ANTIPATTERN);
 
-		if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
+		if (mmio_read_pattern(STM32MP_DDR_BASE) != DDR_PATTERN) {
 			return STM32MP_DDR_BASE;
 		}
 
-		for (offset = sizeof(uint32_t); (offset & addressmask) != 0U;
-		     offset <<= 1) {
-			if ((mmio_read_32(STM32MP_DDR_BASE +
-					  (uint32_t)offset) != DDR_PATTERN) &&
+		for (offset = sizeof(u_register_t); (offset & addressmask) != 0U;
+		     offset <<= 1U) {
+			if ((mmio_read_pattern(STM32MP_DDR_BASE + offset) != DDR_PATTERN) &&
 			    (offset != testoffset)) {
-				return (uint32_t)(STM32MP_DDR_BASE + offset);
+				return STM32MP_DDR_BASE + offset;
 			}
 		}
 
-		mmio_write_32(STM32MP_DDR_BASE + (uint32_t)testoffset,
-			      DDR_PATTERN);
+		mmio_write_pattern(STM32MP_DDR_BASE + testoffset, DDR_PATTERN);
 	}
 
-	return 0U;
+	return 0UL;
 }
 
 /*******************************************************************************
@@ -125,24 +142,22 @@ uint32_t stm32mp_ddr_test_addr_bus(uint64_t size)
  * restore its content.
  * Returns DDR computed size.
  ******************************************************************************/
-uint32_t stm32mp_ddr_check_size(void)
+size_t stm32mp_ddr_check_size(void)
 {
-	uint32_t offset = sizeof(uint32_t);
+	size_t offset = sizeof(u_register_t);
 
-	mmio_write_32(STM32MP_DDR_BASE, DDR_PATTERN);
+	mmio_write_pattern(STM32MP_DDR_BASE, DDR_PATTERN);
 
 	while (offset < STM32MP_DDR_MAX_SIZE) {
-		mmio_write_32(STM32MP_DDR_BASE + offset, DDR_ANTIPATTERN);
+		mmio_write_pattern(STM32MP_DDR_BASE + offset, DDR_ANTIPATTERN);
 		dsb();
 
-		if (mmio_read_32(STM32MP_DDR_BASE) != DDR_PATTERN) {
+		if (mmio_read_pattern(STM32MP_DDR_BASE) != DDR_PATTERN) {
 			break;
 		}
 
 		offset <<= 1U;
 	}
 
-	INFO("Memory size = 0x%x (%u MB)\n", offset, offset / (1024U * 1024U));
-
 	return offset;
 }
diff --git a/drivers/st/ddr/stm32mp_ram.c b/drivers/st/ddr/stm32mp_ram.c
index 0804568886..28dc17d0ba 100644
--- a/drivers/st/ddr/stm32mp_ram.c
+++ b/drivers/st/ddr/stm32mp_ram.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -23,8 +23,8 @@ int stm32mp_ddr_dt_get_info(void *fdt, int node, struct stm32mp_ddr_info *info)
 		VERBOSE("%s: no st,mem-speed\n", __func__);
 		return -EINVAL;
 	}
-	ret = fdt_read_uint32(fdt, node, "st,mem-size", &info->size);
-	if (ret < 0) {
+	info->size = dt_get_ddr_size();
+	if (info->size == 0U) {
 		VERBOSE("%s: no st,mem-size\n", __func__);
 		return -EINVAL;
 	}
diff --git a/drivers/st/fmc/stm32_fmc2_nand.c b/drivers/st/fmc/stm32_fmc2_nand.c
index 9bdc854789..7030e1a0e0 100644
--- a/drivers/st/fmc/stm32_fmc2_nand.c
+++ b/drivers/st/fmc/stm32_fmc2_nand.c
@@ -26,13 +26,21 @@
 #define TIMEOUT_US_1_MS			1000U
 
 /* FMC2 Compatibility */
+#if STM32MP13 || STM32MP15
 #define DT_FMC2_EBI_COMPAT		"st,stm32mp1-fmc2-ebi"
 #define DT_FMC2_NFC_COMPAT		"st,stm32mp1-fmc2-nfc"
 #define MAX_CS				2U
+#endif
+#if STM32MP25
+#define DT_FMC2_EBI_COMPAT		"st,stm32mp25-fmc2-ebi"
+#define DT_FMC2_NFC_COMPAT		"st,stm32mp25-fmc2-nfc"
+#define MAX_CS				4U
+#endif
 #define MAX_BANK			5U
 
 /* FMC2 Controller Registers */
 #define FMC2_BCR1			0x00U
+#define FMC2_CFGR			0x20U
 #define FMC2_PCR			0x80U
 #define FMC2_SR				0x84U
 #define FMC2_PMEM			0x88U
@@ -45,9 +53,16 @@
 #define FMC2_BCHDSR2			0x284U
 #define FMC2_BCHDSR3			0x288U
 #define FMC2_BCHDSR4			0x28CU
+#define FMC2_SECCFGR			0x300U
+#define FMC2_CIDCFGR0			0x30CU
+#define FMC2_CIDCFGR(x)			((x) * 0x8U + FMC2_CIDCFGR0)
+#define FMC2_SEMCR0			0x310U
+#define FMC2_SEMCR(x)			((x) * 0x8U + FMC2_SEMCR0)
 
 /* FMC2_BCR1 register */
 #define FMC2_BCR1_FMC2EN		BIT(31)
+/* FMC2_CFGR register */
+#define FMC2_CFGR_FMC2EN		BIT(31)
 /* FMC2_PCR register */
 #define FMC2_PCR_PWAITEN		BIT(1)
 #define FMC2_PCR_PBKEN			BIT(2)
@@ -70,6 +85,7 @@
 #define FMC2_PCR_BCHECC			BIT(24)
 #define FMC2_PCR_WEN			BIT(25)
 /* FMC2_SR register */
+#define FMC2_SR_ISOST			GENMASK_32(1, 0)
 #define FMC2_SR_NWRF			BIT(6)
 /* FMC2_PMEM register*/
 #define FMC2_PMEM_MEMSET(x)		(((x) & GENMASK_32(7, 0)) << 0)
@@ -108,6 +124,16 @@
 #define FMC2_BCHDSR4_EBP7_MASK		GENMASK_32(12, 0)
 #define FMC2_BCHDSR4_EBP8_MASK		GENMASK_32(28, 16)
 #define FMC2_BCHDSR4_EBP8_SHIFT		16U
+/* FMC2_CIDCFGR register */
+#define FMC2_CIDCFGR_CFEN		BIT(0)
+#define FMC2_CIDCFGR_SEMEN		BIT(1)
+#define FMC2_CIDCFGR_SCID_MASK		GENMASK_32(6, 4)
+#define FMC2_CIDCFGR_SCID_SHIFT		4U
+#define FMC2_CIDCFGR_SEMWLC1		BIT(17)
+/* FMC2_SEMCR register */
+#define FMC2_SEMCR_SEM_MUTEX		BIT(0)
+#define FMC2_SEMCR_SEMCID_MASK		GENMASK_32(6, 4)
+#define FMC2_SEMCR_SEMCID_SHIFT		4U
 
 /* Timings */
 #define FMC2_THIZ			0x01U
@@ -116,6 +142,10 @@
 #define FMC2_PCR_TIMING_MASK		GENMASK_32(3, 0)
 #define FMC2_PMEM_PATT_TIMING_MASK	GENMASK_32(7, 0)
 
+#define FMC2_MAX_RESOURCES		6U
+#define FMC2_RESOURCE_CFGR		0U
+#define FMC2_RESOURCE_NAND		5U
+#define FMC2_CID1			1U
 #define FMC2_BBM_LEN			2U
 #define FMC2_MAX_ECC_BYTES		14U
 #define TIMEOUT_US_10_MS		10000U
@@ -148,7 +178,6 @@ struct stm32_fmc2_nfc {
 	uintptr_t reg_base;
 	struct stm32_fmc2_cs_reg cs[MAX_CS];
 	unsigned long clock_id;
-	unsigned int reset_id;
 	uint8_t cs_sel;
 };
 
@@ -658,10 +687,64 @@ static void stm32_fmc2_write_data(struct nand_device *nand,
 	}
 }
 
+#if STM32MP25
+static int stm32_fmc2_check_rif(unsigned int resource)
+{
+	uint32_t cidcfgr;
+	uint32_t semcr;
+	unsigned int cid;
+
+	if (resource >= FMC2_MAX_RESOURCES) {
+		return -EINVAL;
+	}
+
+	cidcfgr = mmio_read_32(fmc2_base() + FMC2_CIDCFGR(resource));
+	if ((cidcfgr & FMC2_CIDCFGR_CFEN) == 0U) {
+		/* CID filtering is turned off: access granted */
+		return 0;
+	}
+
+	if ((cidcfgr & FMC2_CIDCFGR_SEMEN) == 0U) {
+		/* Static CID mode */
+		cid = (cidcfgr & FMC2_CIDCFGR_SCID_MASK) >>
+		      FMC2_CIDCFGR_SCID_SHIFT;
+		if (cid != FMC2_CID1) {
+			ERROR("%s: static CID%u set for resource %u\n",
+			      __func__, cid, resource);
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if ((cidcfgr & FMC2_CIDCFGR_SEMWLC1) != 0U) {
+		ERROR("%s: CID1 is block-listed for resource %u\n",
+		      __func__, resource);
+		return -EACCES;
+	}
+
+	semcr = mmio_read_32(fmc2_base() + FMC2_SEMCR(resource));
+	if ((semcr & FMC2_SEMCR_SEM_MUTEX) != 0U) {
+		mmio_setbits_32(fmc2_base() + FMC2_SEMCR(resource),
+				FMC2_SEMCR_SEM_MUTEX);
+		semcr = mmio_read_32(fmc2_base() + FMC2_SEMCR(resource));
+	}
+
+	cid = (semcr & FMC2_SEMCR_SEMCID_MASK) >> FMC2_SEMCR_SEMCID_SHIFT;
+	if (cid != FMC2_CID1) {
+		ERROR("%s: resource %u is already used by CID%u\n",
+		      __func__, resource, cid);
+		return -EACCES;
+	}
+
+	return 0;
+}
+#endif
+
 static void stm32_fmc2_ctrl_init(void)
 {
 	uint32_t pcr = mmio_read_32(fmc2_base() + FMC2_PCR);
-	uint32_t bcr1 = mmio_read_32(fmc2_base() + FMC2_BCR1);
 
 	/* Enable wait feature and NAND flash memory bank */
 	pcr |= FMC2_PCR_PWAITEN;
@@ -689,9 +772,22 @@ static void stm32_fmc2_ctrl_init(void)
 	pcr |= FMC2_PCR_TAR(FMC2_PCR_TAR_DEFAULT);
 
 	/* Enable FMC2 controller */
-	bcr1 |= FMC2_BCR1_FMC2EN;
+#if STM32MP13 || STM32MP15
+	mmio_setbits_32(fmc2_base() + FMC2_BCR1, FMC2_BCR1_FMC2EN);
+#endif
+#if STM32MP25
+	if ((mmio_read_32(fmc2_base() + FMC2_SR) & FMC2_SR_ISOST) != 0U) {
+		/* FMC2 is disabled */
+		if (stm32_fmc2_check_rif(FMC2_RESOURCE_CFGR) == 0) {
+			mmio_setbits_32(fmc2_base() + FMC2_CFGR,
+					FMC2_CFGR_FMC2EN);
+		} else {
+			/* FMC2 can not be enabled */
+			panic();
+		}
+	}
+#endif
 
-	mmio_write_32(fmc2_base() + FMC2_BCR1, bcr1);
 	mmio_write_32(fmc2_base() + FMC2_PCR, pcr);
 	mmio_write_32(fmc2_base() + FMC2_PMEM, FMC2_PMEM_DEFAULT);
 	mmio_write_32(fmc2_base() + FMC2_PATT, FMC2_PATT_DEFAULT);
@@ -814,12 +910,11 @@ int stm32_fmc2_init(void)
 
 	stm32_fmc2.reg_base = info.base;
 
-	if ((info.clock < 0) || (info.reset < 0)) {
+	if (info.clock < 0) {
 		return -FDT_ERR_BADVALUE;
 	}
 
 	stm32_fmc2.clock_id = (unsigned long)info.clock;
-	stm32_fmc2.reset_id = (unsigned int)info.reset;
 
 	cuint = fdt_getprop(fdt, fmc_ebi_node, "ranges", NULL);
 	if (cuint == NULL) {
@@ -912,14 +1007,35 @@ int stm32_fmc2_init(void)
 	clk_enable(stm32_fmc2.clock_id);
 
 	/* Reset IP */
-	ret = stm32mp_reset_assert(stm32_fmc2.reset_id, TIMEOUT_US_1_MS);
-	if (ret != 0) {
-		panic();
+#if STM32MP25
+	if ((info.reset >= 0) &&
+	    (stm32_fmc2_check_rif(FMC2_RESOURCE_CFGR) != -EACCES)) {
+#else
+	if (info.reset >= 0) {
+#endif
+		unsigned int reset_id = (unsigned int)info.reset;
+
+		ret = stm32mp_reset_assert(reset_id, TIMEOUT_US_1_MS);
+		if (ret != 0) {
+			panic();
+		}
+
+		ret = stm32mp_reset_deassert(reset_id, TIMEOUT_US_1_MS);
+		if (ret != 0) {
+			panic();
+		}
 	}
-	ret = stm32mp_reset_deassert(stm32_fmc2.reset_id, TIMEOUT_US_1_MS);
-	if (ret != 0) {
+
+#if STM32MP25
+	/* Check if FMC2 NAND controller can be used */
+	if (stm32_fmc2_check_rif(FMC2_RESOURCE_NAND) == 0) {
+		/* Secure the FMC2 NAND controller */
+		mmio_setbits_32(fmc2_base() + FMC2_SECCFGR,
+				BIT(FMC2_RESOURCE_NAND));
+	} else {
 		panic();
 	}
+#endif
 
 	/* Setup default IP registers */
 	stm32_fmc2_ctrl_init();
diff --git a/drivers/st/gpio/stm32_gpio.c b/drivers/st/gpio/stm32_gpio.c
index 708989f703..63e886a78a 100644
--- a/drivers/st/gpio/stm32_gpio.c
+++ b/drivers/st/gpio/stm32_gpio.c
@@ -10,9 +10,11 @@
 
 #include <common/bl_common.h>
 #include <common/debug.h>
+#include <common/fdt_wrappers.h>
 #include <drivers/clk.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32mp_clkfunc.h>
+#include <dt-bindings/gpio/stm32-gpio.h>
 #include <lib/mmio.h>
 #include <lib/utils_def.h>
 #include <libfdt.h>
@@ -254,7 +256,7 @@ static void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t type,
 				   (uint32_t)GPIO_ALTERNATE_MASK << (pin << 2),
 				   alternate << (pin << 2));
 	} else {
-		size_t shift = (pin - GPIO_ALT_LOWER_LIMIT) << 2;
+		uint32_t shift = (pin - GPIO_ALT_LOWER_LIMIT) << 2;
 
 		mmio_clrsetbits_32(base + GPIO_AFRH_OFFSET,
 				   (uint32_t)GPIO_ALTERNATE_MASK << shift,
@@ -282,6 +284,10 @@ static void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t type,
 
 	clk_disable(clock);
 
+#if STM32MP25
+	set_gpio_secure_cfg(bank, pin, true);
+#else
+
 	if (status == DT_SECURE) {
 		stm32mp_register_secure_gpio(bank, pin);
 #if !IMAGE_BL2
@@ -294,6 +300,7 @@ static void set_gpio(uint32_t bank, uint32_t pin, uint32_t mode, uint32_t type,
 		set_gpio_secure_cfg(bank, pin, false);
 #endif
 	}
+#endif
 }
 
 void set_gpio_secure_cfg(uint32_t bank, uint32_t pin, bool secure)
@@ -321,3 +328,74 @@ void set_gpio_reset_cfg(uint32_t bank, uint32_t pin)
 		 GPIO_ALTERNATE_(0), DT_DISABLED);
 	set_gpio_secure_cfg(bank, pin, stm32_gpio_is_secure_at_reset(bank));
 }
+
+void set_gpio_level(uint32_t bank, uint32_t pin, enum gpio_level level)
+{
+	uintptr_t base = stm32_get_gpio_bank_base(bank);
+	unsigned long clock = stm32_get_gpio_bank_clock(bank);
+
+	assert(pin <= GPIO_PIN_MAX);
+
+	clk_enable(clock);
+
+	if (level == GPIO_LEVEL_HIGH) {
+		mmio_write_32(base + GPIO_BSRR_OFFSET, BIT(pin));
+	} else {
+		mmio_write_32(base + GPIO_BSRR_OFFSET, BIT(pin + 16U));
+	}
+
+	VERBOSE("GPIO %u level set to 0x%x\n", bank,
+		mmio_read_32(base + GPIO_IDR_OFFSET));
+
+	clk_disable(clock);
+}
+
+enum gpio_level get_gpio_level(uint32_t bank, uint32_t pin)
+{
+	uintptr_t base = stm32_get_gpio_bank_base(bank);
+	unsigned long clock = stm32_get_gpio_bank_clock(bank);
+	enum gpio_level level = GPIO_LEVEL_LOW;
+
+	assert(pin <= GPIO_PIN_MAX);
+
+	clk_enable(clock);
+
+	if (mmio_read_32(base + GPIO_IDR_OFFSET) & BIT(pin)) {
+		level = GPIO_LEVEL_HIGH;
+	}
+
+	VERBOSE("GPIO %u get level 0x%x\n", bank,
+		mmio_read_32(base + GPIO_IDR_OFFSET));
+
+	clk_disable(clock);
+
+	return level;
+}
+
+void set_gpio_config(uint32_t bank, uint32_t pin, uint32_t config, uint8_t status)
+{
+	uint32_t mode = GPIO_MODE_OUTPUT;
+	uint32_t od = 0U;
+	uint32_t pull = GPIO_NO_PULL;
+
+	VERBOSE("GPIO %u:%u set config to 0x%x\n", bank, pin, config);
+
+	if (config & GPIOF_DIR_IN) {
+		mode = GPIO_MODE_INPUT;
+	}
+
+	if (config & GPIOF_OUT_INIT_HIGH) {
+		od = 1U;
+	}
+
+	if (config & GPIOF_PULL_UP) {
+		pull |= GPIO_PULL_UP;
+	}
+
+	if (config & GPIOF_PULL_DOWN) {
+		pull |= GPIO_PULL_DOWN;
+	}
+
+	set_gpio(bank, pin, mode, GPIO_TYPE_PUSH_PULL, GPIO_SPEED_LOW,
+		 pull, od, GPIO_ALTERNATE_(0), status);
+}
diff --git a/drivers/st/i2c/stm32_i2c.c b/drivers/st/i2c/stm32_i2c.c
index bf6c3eeeb3..f0a46d030c 100644
--- a/drivers/st/i2c/stm32_i2c.c
+++ b/drivers/st/i2c/stm32_i2c.c
@@ -1,24 +1,25 @@
 /*
- * Copyright (c) 2016-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2016-2022, STMicroelectronics - All Rights Reserved
  *
- * SPDX-License-Identifier: BSD-3-Clause
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
 
 #include <errno.h>
+#include <limits.h>
 #include <stdbool.h>
 #include <stdlib.h>
 
-#include <libfdt.h>
-
-#include <platform_def.h>
-
 #include <common/debug.h>
+#include <common/fdt_wrappers.h>
 #include <drivers/clk.h>
 #include <drivers/delay_timer.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32_i2c.h>
 #include <lib/mmio.h>
 #include <lib/utils.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
 
 /* STM32 I2C registers offsets */
 #define I2C_CR1			0x00U
@@ -39,8 +40,87 @@
 
 #define I2C_NSEC_PER_SEC	1000000000L
 
-/* I2C Timing hard-coded value, for I2C clock source is HSI at 64MHz */
-#define I2C_TIMING			0x10D07DB5
+/*
+ * struct i2c_spec_s - Private I2C timing specifications.
+ * @rate: I2C bus speed (Hz)
+ * @fall_max: Max fall time of both SDA and SCL signals (ns)
+ * @rise_max: Max rise time of both SDA and SCL signals (ns)
+ * @hddat_min: Min data hold time (ns)
+ * @vddat_max: Max data valid time (ns)
+ * @sudat_min: Min data setup time (ns)
+ * @l_min: Min low period of the SCL clock (ns)
+ * @h_min: Min high period of the SCL clock (ns)
+ */
+struct i2c_spec_s {
+	uint32_t rate;
+	uint32_t fall_max;
+	uint32_t rise_max;
+	uint32_t hddat_min;
+	uint32_t vddat_max;
+	uint32_t sudat_min;
+	uint32_t l_min;
+	uint32_t h_min;
+};
+
+/*
+ * struct i2c_timing_s - Private I2C output parameters.
+ * @scldel: Data setup time
+ * @sdadel: Data hold time
+ * @sclh: SCL high period (master mode)
+ * @sclh: SCL low period (master mode)
+ * @is_saved: True if relating to a configuration candidate
+ */
+struct i2c_timing_s {
+	uint8_t scldel;
+	uint8_t sdadel;
+	uint8_t sclh;
+	uint8_t scll;
+	bool is_saved;
+};
+
+/*
+ * I2C specification values as per version 6.0, 4th of April 2014 [1],
+ * table 10 page 48: Characteristics of the SDA and SCL bus lines for
+ * Standard, Fast, and Fast-mode Plus I2C-bus devices.
+ *
+ * [1] https://www.i2c-bus.org/specification/
+ */
+static const struct i2c_spec_s i2c_specs[] = {
+	/* Standard - 100KHz */
+	{
+		.rate = STANDARD_RATE,
+		.fall_max = 300,
+		.rise_max = 1000,
+		.hddat_min = 0,
+		.vddat_max = 3450,
+		.sudat_min = 250,
+		.l_min = 4700,
+		.h_min = 4000,
+	},
+	/* Fast - 400KHz */
+	{
+		.rate = FAST_RATE,
+		.fall_max = 300,
+		.rise_max = 300,
+		.hddat_min = 0,
+		.vddat_max = 900,
+		.sudat_min = 100,
+		.l_min = 1300,
+		.h_min = 600,
+	},
+	/* FastPlus - 1MHz */
+	{
+		.rate = FAST_PLUS_RATE,
+		.fall_max = 100,
+		.rise_max = 120,
+		.hddat_min = 0,
+		.vddat_max = 450,
+		.sudat_min = 50,
+		.l_min = 500,
+		.h_min = 260,
+	},
+};
+
 
 static void notif_i2c_timeout(struct i2c_handle_s *hi2c)
 {
@@ -49,6 +129,298 @@ static void notif_i2c_timeout(struct i2c_handle_s *hi2c)
 	hi2c->i2c_state = I2C_STATE_READY;
 }
 
+static const struct i2c_spec_s *get_specs(uint32_t rate)
+{
+	size_t i;
+
+	for (i = 0U; i < ARRAY_SIZE(i2c_specs); i++) {
+		if (rate <= i2c_specs[i].rate) {
+			return &i2c_specs[i];
+		}
+	}
+
+	/* NOT REACHED */
+	return NULL;
+}
+
+#define RATE_MIN(rate)	(((rate) / 100U) * 80U)
+/*
+ * @brief  Compute the I2C device timings.
+ * @param  init: Ref to the initialization configuration structure
+ * @param  clock_src: I2C clock source frequency (Hz)
+ * @param  timing: Pointer to the final computed timing result
+ * @retval 0 if OK, negative value else
+ */
+static int i2c_compute_timing(struct stm32_i2c_init_s *init,
+			      uint32_t clock_src, uint32_t *timing)
+{
+	const struct i2c_spec_s *specs;
+	uint32_t speed_freq;
+	uint32_t i2cclk = udiv_round_nearest(I2C_NSEC_PER_SEC, clock_src);
+	uint32_t i2cbus;
+	uint32_t p_prev = I2C_TIMINGR_PRESC_MAX;
+	uint32_t af_delay_min;
+	uint32_t af_delay_max;
+	uint32_t dnf_delay;
+	uint32_t tsync;
+	uint32_t clk_min;
+	uint32_t clk_max;
+	int clk_error_prev;
+	uint16_t p;
+	uint16_t l;
+	uint16_t a;
+	uint16_t h;
+	int sdadel_min;
+	int sdadel_max;
+	uint32_t sdadel_min_u;
+	uint32_t sdadel_max_u;
+	uint32_t scldel_min;
+	int s = -1;
+	struct i2c_timing_s solutions[I2C_TIMINGR_PRESC_MAX];
+
+	specs = get_specs(init->bus_rate);
+	if (specs == NULL) {
+		ERROR("I2C speed out of bound {%u}\n", init->bus_rate);
+		return -EINVAL;
+	}
+
+	speed_freq = specs->rate;
+	i2cbus = udiv_round_nearest(I2C_NSEC_PER_SEC, speed_freq);
+	clk_error_prev = INT_MAX;
+
+	if ((init->rise_time > specs->rise_max) ||
+	    (init->fall_time > specs->fall_max)) {
+		ERROR(" I2C timings out of bound Rise{%u>%u}/Fall{%u>%u}\n",
+		      init->rise_time, specs->rise_max,
+		      init->fall_time, specs->fall_max);
+		return -EINVAL;
+	}
+
+	if (init->digital_filter_coef > STM32_I2C_DIGITAL_FILTER_MAX) {
+		ERROR("DNF out of bound %u/%u\n",
+		      init->digital_filter_coef, STM32_I2C_DIGITAL_FILTER_MAX);
+		return -EINVAL;
+	}
+
+	/*  Analog and Digital Filters */
+	af_delay_min = (init->analog_filter ?
+			STM32_I2C_ANALOG_FILTER_DELAY_MIN : 0);
+	af_delay_max = (init->analog_filter ?
+			STM32_I2C_ANALOG_FILTER_DELAY_MAX : 0);
+	dnf_delay = init->digital_filter_coef * i2cclk;
+
+	sdadel_min = specs->hddat_min + init->fall_time -
+		     af_delay_min - ((init->digital_filter_coef + 3) * i2cclk);
+
+	sdadel_max = specs->vddat_max - init->rise_time -
+		     af_delay_max - ((init->digital_filter_coef + 4) * i2cclk);
+
+	scldel_min = init->rise_time + specs->sudat_min;
+
+	if (sdadel_min < 0) {
+		sdadel_min_u = 0;
+	} else {
+		sdadel_min_u = (uint32_t)sdadel_min;
+	}
+
+	if (sdadel_max < 0) {
+		sdadel_max_u = 0;
+	} else {
+		sdadel_max_u = (uint32_t)sdadel_max;
+	}
+
+	VERBOSE("I2C SDADEL(min/max): %u/%u, SCLDEL(Min): %u\n",
+		sdadel_min_u, sdadel_max_u, scldel_min);
+
+	zeromem(&solutions, sizeof(solutions));
+
+	/* Compute possible values for PRESC, SCLDEL and SDADEL */
+	for (p = 0; p < I2C_TIMINGR_PRESC_MAX; p++) {
+		for (l = 0; l < I2C_TIMINGR_SCLDEL_MAX; l++) {
+			uint32_t scldel = (l + 1) * (p + 1) * i2cclk;
+
+			if (scldel < scldel_min) {
+				continue;
+			}
+
+			for (a = 0; a < I2C_TIMINGR_SDADEL_MAX; a++) {
+				uint32_t sdadel = (a * (p + 1) + 1) * i2cclk;
+
+				if ((sdadel >= sdadel_min_u) &&
+				    (sdadel <= sdadel_max_u) &&
+				    (p != p_prev)) {
+					solutions[p].scldel = l;
+					solutions[p].sdadel = a;
+					solutions[p].is_saved = true;
+					p_prev = p;
+					break;
+				}
+			}
+
+			if (p_prev == p) {
+				break;
+			}
+		}
+	}
+
+	if (p_prev == I2C_TIMINGR_PRESC_MAX) {
+		ERROR(" I2C no Prescaler solution\n");
+		return -EPERM;
+	}
+
+	tsync = af_delay_min + dnf_delay + (2 * i2cclk);
+	clk_max = I2C_NSEC_PER_SEC / RATE_MIN(specs->rate);
+	clk_min = I2C_NSEC_PER_SEC / specs->rate;
+
+	/*
+	 * Among prescaler possibilities discovered above figures out SCL Low
+	 * and High Period. Provided:
+	 * - SCL Low Period has to be higher than Low Period of the SCL Clock
+	 *   defined by I2C Specification. I2C Clock has to be lower than
+	 *   (SCL Low Period - Analog/Digital filters) / 4.
+	 * - SCL High Period has to be lower than High Period of the SCL Clock
+	 *   defined by I2C Specification.
+	 * - I2C Clock has to be lower than SCL High Period.
+	 */
+	for (p = 0; p < I2C_TIMINGR_PRESC_MAX; p++) {
+		uint32_t prescaler = (p + 1) * i2cclk;
+
+		if (!solutions[p].is_saved) {
+			continue;
+		}
+
+		for (l = 0; l < I2C_TIMINGR_SCLL_MAX; l++) {
+			uint32_t tscl_l = ((l + 1) * prescaler) + tsync;
+
+			if ((tscl_l < specs->l_min) ||
+			    (i2cclk >=
+			     ((tscl_l - af_delay_min - dnf_delay) / 4))) {
+				continue;
+			}
+
+			for (h = 0; h < I2C_TIMINGR_SCLH_MAX; h++) {
+				uint32_t tscl_h = ((h + 1) * prescaler) + tsync;
+				uint32_t tscl = tscl_l + tscl_h +
+						init->rise_time +
+						init->fall_time;
+
+				if ((tscl >= clk_min) && (tscl <= clk_max) &&
+				    (tscl_h >= specs->h_min) &&
+				    (i2cclk < tscl_h)) {
+					int clk_error = tscl - i2cbus;
+
+					if (clk_error < 0) {
+						clk_error = -clk_error;
+					}
+
+					if (clk_error < clk_error_prev) {
+						clk_error_prev = clk_error;
+						solutions[p].scll = l;
+						solutions[p].sclh = h;
+						s = p;
+					}
+				}
+			}
+		}
+	}
+
+	if (s < 0) {
+		ERROR(" I2C no solution at all\n");
+		return -EPERM;
+	}
+
+	/* Finalize timing settings */
+	*timing = I2C_SET_TIMINGR_PRESC(s) |
+		  I2C_SET_TIMINGR_SCLDEL(solutions[s].scldel) |
+		  I2C_SET_TIMINGR_SDADEL(solutions[s].sdadel) |
+		  I2C_SET_TIMINGR_SCLH(solutions[s].sclh) |
+		  I2C_SET_TIMINGR_SCLL(solutions[s].scll);
+
+	VERBOSE("I2C TIMINGR (PRESC/SCLDEL/SDADEL): %i/%i/%i\n",
+		s, solutions[s].scldel, solutions[s].sdadel);
+	VERBOSE("I2C TIMINGR (SCLH/SCLL): %i/%i\n",
+		solutions[s].sclh, solutions[s].scll);
+	VERBOSE("I2C TIMINGR: 0x%x\n", *timing);
+
+	return 0;
+}
+
+static uint32_t get_lower_rate(uint32_t rate)
+{
+	int i;
+
+	for (i = ARRAY_SIZE(i2c_specs) - 1; i >= 0; i--) {
+		if (rate > i2c_specs[i].rate) {
+			return i2c_specs[i].rate;
+		}
+	}
+
+	return i2c_specs[0].rate;
+}
+
+/*
+ * @brief  Setup the I2C device timings.
+ * @param  hi2c: Pointer to a struct i2c_handle_s structure that contains
+ *               the configuration information for the specified I2C.
+ * @param  init: Ref to the initialization configuration structure
+ * @param  timing: Pointer to the final computed timing result
+ * @retval 0 if OK, negative value else
+ */
+static int i2c_setup_timing(struct i2c_handle_s *hi2c,
+			    struct stm32_i2c_init_s *init,
+			    uint32_t *timing)
+{
+	int rc = 0;
+	uint32_t clock_src;
+
+	clock_src = (uint32_t)clk_get_rate(hi2c->clock);
+	if (clock_src == 0U) {
+		ERROR("I2C clock rate is 0\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * If the timing has already been computed, and the frequency is the
+	 * same as when it was computed, then use the saved timing.
+	 */
+	if (clock_src == hi2c->saved_frequency) {
+		*timing = hi2c->saved_timing;
+		return 0;
+	}
+
+	do {
+		rc = i2c_compute_timing(init, clock_src, timing);
+		if (rc != 0) {
+			ERROR("Failed to compute I2C timings\n");
+			if (init->bus_rate > STANDARD_RATE) {
+				init->bus_rate = get_lower_rate(init->bus_rate);
+				WARN("Downgrade I2C speed to %uHz)\n",
+				     init->bus_rate);
+			} else {
+				break;
+			}
+		}
+	} while (rc != 0);
+
+	if (rc != 0) {
+		ERROR("Impossible to compute I2C timings\n");
+		return rc;
+	}
+
+	VERBOSE("I2C Freq(%u), Clk Source(%u)\n",
+		init->bus_rate, clock_src);
+	VERBOSE("I2C Rise(%u) and Fall(%u) Time\n",
+		init->rise_time, init->fall_time);
+	VERBOSE("I2C Analog Filter(%s), DNF(%u)\n",
+		(init->analog_filter ? "On" : "Off"),
+		init->digital_filter_coef);
+
+	hi2c->saved_timing = *timing;
+	hi2c->saved_frequency = clock_src;
+
+	return 0;
+}
+
 /*
  * @brief  Configure I2C Analog noise filter.
  * @param  hi2c: Pointer to a struct i2c_handle_s structure that contains
@@ -97,41 +469,24 @@ static int i2c_config_analog_filter(struct i2c_handle_s *hi2c,
 int stm32_i2c_get_setup_from_fdt(void *fdt, int node,
 				 struct stm32_i2c_init_s *init)
 {
-	const fdt32_t *cuint;
-
-	cuint = fdt_getprop(fdt, node, "i2c-scl-rising-time-ns", NULL);
-	if (cuint == NULL) {
-		init->rise_time = STM32_I2C_RISE_TIME_DEFAULT;
-	} else {
-		init->rise_time = fdt32_to_cpu(*cuint);
-	}
-
-	cuint = fdt_getprop(fdt, node, "i2c-scl-falling-time-ns", NULL);
-	if (cuint == NULL) {
-		init->fall_time = STM32_I2C_FALL_TIME_DEFAULT;
-	} else {
-		init->fall_time = fdt32_to_cpu(*cuint);
-	}
-
-	cuint = fdt_getprop(fdt, node, "clock-frequency", NULL);
-	if (cuint == NULL) {
-		init->speed_mode = STM32_I2C_SPEED_DEFAULT;
-	} else {
-		switch (fdt32_to_cpu(*cuint)) {
-		case STANDARD_RATE:
-			init->speed_mode = I2C_SPEED_STANDARD;
-			break;
-		case FAST_RATE:
-			init->speed_mode = I2C_SPEED_FAST;
-			break;
-		case FAST_PLUS_RATE:
-			init->speed_mode = I2C_SPEED_FAST_PLUS;
-			break;
-		default:
-			init->speed_mode = STM32_I2C_SPEED_DEFAULT;
-			break;
-		}
+	uint32_t read_val;
+
+	init->rise_time = fdt_read_uint32_default(fdt, node,
+						  "i2c-scl-rising-time-ns",
+						  STM32_I2C_RISE_TIME_DEFAULT);
+
+	init->fall_time = fdt_read_uint32_default(fdt, node,
+						  "i2c-scl-falling-time-ns",
+						  STM32_I2C_FALL_TIME_DEFAULT);
+
+	read_val = fdt_read_uint32_default(fdt, node, "clock-frequency",
+					   STANDARD_RATE);
+	if (read_val > FAST_PLUS_RATE) {
+		ERROR("Invalid bus speed (%u > %u)\n", read_val,
+		      FAST_PLUS_RATE);
+		return -FDT_ERR_BADVALUE;
 	}
+	init->bus_rate = read_val;
 
 	return dt_set_pinctrl_config(node);
 }
@@ -147,7 +502,7 @@ int stm32_i2c_init(struct i2c_handle_s *hi2c,
 		   struct stm32_i2c_init_s *init_data)
 {
 	int rc = 0;
-	uint32_t timing = I2C_TIMING;
+	uint32_t timing;
 
 	if (hi2c == NULL) {
 		return -ENOENT;
@@ -159,6 +514,11 @@ int stm32_i2c_init(struct i2c_handle_s *hi2c,
 
 	hi2c->i2c_state = I2C_STATE_BUSY;
 
+	rc = i2c_setup_timing(hi2c, init_data, &timing);
+	if (rc != 0) {
+		return rc;
+	}
+
 	clk_enable(hi2c->clock);
 
 	/* Disable the selected I2C peripheral */
@@ -979,4 +1339,3 @@ bail:
 
 	return rc;
 }
-
diff --git a/drivers/st/iwdg/stm32_iwdg.c b/drivers/st/iwdg/stm32_iwdg.c
index 74451d70bc..8ec88beea3 100644
--- a/drivers/st/iwdg/stm32_iwdg.c
+++ b/drivers/st/iwdg/stm32_iwdg.c
@@ -28,11 +28,11 @@
 
 /* Registers values */
 #define IWDG_KR_RELOAD_KEY	0xAAAA
+#define IWDG_KR_ENABLE_KEY	0xCCCC
 
 struct stm32_iwdg_instance {
 	uintptr_t base;
 	unsigned long clock;
-	uint8_t flags;
 	int num_irq;
 };
 
@@ -72,6 +72,20 @@ void stm32_iwdg_refresh(void)
 	}
 }
 
+static void stm32_iwdg_start(struct stm32_iwdg_instance *iwdg)
+{
+	/* 0x00000000 is not a valid address for IWDG peripherals */
+	if (iwdg->base == 0U) {
+		panic();
+	}
+
+	clk_enable(iwdg->clock);
+
+	mmio_write_32(iwdg->base + IWDG_KR_OFFSET, IWDG_KR_ENABLE_KEY);
+
+	clk_disable(iwdg->clock);
+}
+
 int stm32_iwdg_init(void)
 {
 	int node = -1;
@@ -97,18 +111,7 @@ int stm32_iwdg_init(void)
 		iwdg->base = dt_info.base;
 		iwdg->clock = (unsigned long)dt_info.clock;
 
-		/* DT can specify low power cases */
-		if (fdt_getprop(fdt, node, "stm32,enable-on-stop", NULL) ==
-		    NULL) {
-			iwdg->flags |= IWDG_DISABLE_ON_STOP;
-		}
-
-		if (fdt_getprop(fdt, node, "stm32,enable-on-standby", NULL) ==
-		    NULL) {
-			iwdg->flags |= IWDG_DISABLE_ON_STANDBY;
-		}
-
-		/* Explicit list of supported bit flags */
+		/* Read OTP to know if IWDG is started by hardware or not */
 		hw_init = stm32_iwdg_get_otp_config(idx);
 
 		if ((hw_init & IWDG_HW_ENABLED) != 0) {
@@ -117,7 +120,6 @@ int stm32_iwdg_init(void)
 				      idx + 1U);
 				panic();
 			}
-			iwdg->flags |= IWDG_HW_ENABLED;
 		}
 
 		if (dt_info.status == DT_DISABLED) {
@@ -126,14 +128,6 @@ int stm32_iwdg_init(void)
 			continue;
 		}
 
-		if ((hw_init & IWDG_DISABLE_ON_STOP) != 0) {
-			iwdg->flags |= IWDG_DISABLE_ON_STOP;
-		}
-
-		if ((hw_init & IWDG_DISABLE_ON_STANDBY) != 0) {
-			iwdg->flags |= IWDG_DISABLE_ON_STANDBY;
-		}
-
 		VERBOSE("IWDG%u found, %ssecure\n", idx + 1U,
 			((dt_info.status & DT_NON_SECURE) != 0) ?
 			"non-" : "");
@@ -144,11 +138,10 @@ int stm32_iwdg_init(void)
 			stm32mp_register_secure_periph_iomem(iwdg->base);
 		}
 
-#if defined(IMAGE_BL2)
-		if (stm32_iwdg_shadow_update(idx, iwdg->flags) != BSEC_OK) {
-			return -1;
+		if ((hw_init & IWDG_HW_ENABLED) == 0) {
+			/* Use default timeout, ignore DT's "timeout-sec" */
+			stm32_iwdg_start(iwdg);
 		}
-#endif
 	}
 
 	VERBOSE("%u IWDG instance%s found\n", count, (count > 1U) ? "s" : "");
diff --git a/drivers/st/mce/stm32_mce.c b/drivers/st/mce/stm32_mce.c
new file mode 100644
index 0000000000..837f377bbc
--- /dev/null
+++ b/drivers/st/mce/stm32_mce.c
@@ -0,0 +1,428 @@
+/*
+ * Copyright (c) 2020-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32_mce.h>
+#include <lib/mmio.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <stm32mp_fconf_getter.h>
+
+/* MCE registers (base relative) */
+#define MCE_CR		U(0x0000) /* MCE configuration register */
+#define MCE_SR		U(0x0004) /* MCE status register */
+#define MCE_IASR	U(0x0008) /* MCE illegal access status register */
+#define MCE_IACR	U(0x000C) /* MCE illegal access clear register */
+#define MCE_IAIER	U(0x0010) /* MCE illegal access interrupt enable reg */
+#define MCE_PRIVCFGR	U(0x001C) /* MCE privileged configuration register */
+#define MCE_REGCR	U(0x0040) /* MCE region configuration register */
+#define MCE_SADDR	U(0x0044) /* MCE start address for region register */
+#define MCE_EADDR	U(0x0048) /* MCE end address for region register */
+#define MCE_MKEYR	U(0x0200) /* MCE master key register offset */
+#define MCE_HWCFGR3	U(0x03E8) /* MCE hardware configuration register 3 */
+#define MCE_HWCFGR2	U(0x03EC) /* MCE hardware configuration register 2 */
+#define MCE_HWCFGR1	U(0x03F0) /* MCE hardware configuration register 1 */
+#define MCE_VERR	U(0x03F4) /* MCE version register */
+#define MCE_IPIDR	U(0x03F8) /* MCE identification register */
+#define MCE_SIDR	U(0x03FC) /* MCE size ID register */
+
+/* MCE configuration register */
+#define MCE_CR_GLOCK			BIT(0)
+#define MCE_CR_MKLOCK			BIT(1)
+
+/* MCE status register */
+#define MCE_SR_MKVALID			BIT(0)
+#define MCE_SR_ENCDIS			BIT(4)
+
+/* MCE privileged configuration register */
+#define MCE_PRIVCFGR_PRIV		BIT(0)
+
+/* MCE region configuration register */
+#define MCE_REGCR_BREN			BIT(0)
+#define MCE_REGCR_ENC			BIT(15)
+
+/* MCE start address for region register */
+#define MCE_SADDR_BADDSTART_MASK	GENMASK(31, 16)
+
+/* MCE end address for region register */
+#define MCE_EADDR_BADDEND_MASK		GENMASK(31, 16)
+
+/* MCE version register */
+#define MCE_VERR_MINREV_MASK		GENMASK(3, 0)
+#define MCE_VERR_MINREV_SHIFT		0
+#define MCE_VERR_MAJREV_MASK		GENMASK(7, 4)
+#define MCE_VERR_MAJREV_SHIFT		4
+
+/* IP configuration */
+#define MCE_MAJREV			1U
+#define MCE_MINREV			0U
+#define MCE_IP_ID			0x00170081U
+#define MCE_SIZE_ID			0xA3C5DD01U
+#define MCE_ADDR_GRANULARITY		0x10000U
+
+/* Other definitions */
+#define MCE_TIMEOUT_1MS_IN_US		1000U
+#define DDR_BASE_EXTRA_MASK		GENMASK_32(31, 30)
+#define MCE_REGION_PARAMS		3U
+
+struct mce_version_s {
+	uint32_t major;
+	uint32_t minor;
+	uint32_t ip_id;
+	uint32_t size_id;
+};
+
+struct mce_dt_id_attr {
+	fdt32_t id_attr[MCE_IP_MAX_REGION_NB];
+};
+
+/*
+ * @brief  Configure privileged access to the MCE registers.
+ * @param  privilege: Only privileged (true) or all (false) access are granted.
+ * @retval None.
+ */
+static void configure_privilege(bool privilege)
+{
+	if (privilege) {
+		mmio_setbits_32(MCE_BASE + MCE_PRIVCFGR, MCE_PRIVCFGR_PRIV);
+	} else {
+		mmio_clrbits_32(MCE_BASE + MCE_PRIVCFGR, MCE_PRIVCFGR_PRIV);
+	}
+}
+
+/*
+ * @brief  Check consistency of region settings.
+ * @param  config: Ref to the region configuration structure.
+ * @retval 0 if OK, negative value else.
+ */
+static int check_region_settings(struct stm32_mce_region_s *config)
+{
+	uint32_t end;
+
+	if (config->encrypt_mode > MCE_ENCRYPTION_MODE_MAX) {
+		ERROR("MCE: encryption mode out of range error\n");
+		return -EINVAL;
+	}
+
+	if ((config->start_address < STM32MP_DDR_BASE) ||
+	    (config->end_address < STM32MP_DDR_BASE)) {
+		ERROR("MCE: start/end address lower than DDR base\n");
+		return -EINVAL;
+	}
+
+	end = STM32MP_DDR_BASE + dt_get_ddr_size() - 1U;
+	if ((config->start_address > end) || (config->end_address > end)) {
+		ERROR("MCE: start/end address higher than physical end\n");
+		return -EINVAL;
+	}
+
+	if (config->start_address >= config->end_address) {
+		ERROR("MCE: start address higher than or equal to end one\n");
+		return -EINVAL;
+	}
+
+	if (((config->start_address % MCE_ADDR_GRANULARITY) != 0U) ||
+	   (((config->end_address + 1U) % MCE_ADDR_GRANULARITY) != 0U)) {
+		ERROR("MCE: start/end address granularity not respected\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Configure (and enable) the MCE region.
+ * @param  index: Region index (first region is 0).
+ * @param  config: Ref to the region configuration structure.
+ * @retval 0 if OK, negative value else.
+ */
+static int stm32_mce_configure_region(uint32_t index, struct stm32_mce_region_s *config)
+{
+	int ret;
+
+	if ((index >= MCE_IP_MAX_REGION_NB) || (config == NULL)) {
+		return -EINVAL;
+	}
+
+	ret = check_region_settings(config);
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_clrbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_BREN);
+
+	mmio_clrsetbits_32(MCE_BASE + MCE_SADDR, MCE_SADDR_BADDSTART_MASK,
+			   config->start_address & MCE_SADDR_BADDSTART_MASK);
+	mmio_clrsetbits_32(MCE_BASE + MCE_EADDR, MCE_EADDR_BADDEND_MASK,
+			   config->end_address & MCE_EADDR_BADDEND_MASK);
+
+	if (config->encrypt_mode == MCE_ENCRYPT_MODE) {
+		mmio_setbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_BREN | MCE_REGCR_ENC);
+
+		if (!stm32_mce_is_hw_encryption_functional()) {
+			ERROR("MCE: encryption feature error\n");
+			return -EIO;
+		}
+	} else {
+		mmio_clrbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_ENC);
+		mmio_setbits_32(MCE_BASE + MCE_REGCR, MCE_REGCR_BREN);
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Initialize the MCE driver.
+ * @param  None.
+ * @retval None.
+ */
+void stm32_mce_init(void)
+{
+	const struct mce_version_s exp_version = {
+		.major = MCE_MAJREV,
+		.minor = MCE_MINREV,
+		.ip_id = MCE_IP_ID,
+		.size_id = MCE_SIZE_ID
+	};
+	struct mce_version_s version;
+
+	clk_enable(MCE);
+
+	version = (struct mce_version_s) {
+		.major = (mmio_read_32(MCE_BASE + MCE_VERR) &
+			  MCE_VERR_MAJREV_MASK) >> MCE_VERR_MAJREV_SHIFT,
+		.minor = (mmio_read_32(MCE_BASE + MCE_VERR) &
+			  MCE_VERR_MINREV_MASK) >> MCE_VERR_MINREV_SHIFT,
+		.ip_id = mmio_read_32(MCE_BASE + MCE_IPIDR),
+		.size_id = mmio_read_32(MCE_BASE + MCE_SIDR)
+	};
+
+	if ((version.major != exp_version.major) ||
+	    (version.minor != exp_version.minor) ||
+	    (version.ip_id != exp_version.ip_id) ||
+	    (version.size_id != exp_version.size_id)) {
+		ERROR("MCE: unexpected IP version { 0x%x, 0x%x, 0x%x, 0x%x }\n",
+		      version.major, version.minor, version.ip_id, version.size_id);
+		panic();
+	}
+
+	configure_privilege(true);
+}
+
+/*
+ * @brief  Write the MCE master key.
+ * @param  mkey: Pointer to the master key buffer.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32_mce_write_master_key(uint8_t *mkey)
+{
+	uint64_t timeout_ref;
+	uint8_t i;
+
+	if (mkey == NULL) {
+		return -EINVAL;
+	}
+
+	if ((mmio_read_32(MCE_BASE + MCE_CR) & MCE_CR_MKLOCK) == MCE_CR_MKLOCK) {
+		return -EPERM;
+	}
+
+	for (i = 0U; i < MCE_KEY_SIZE_IN_BYTES; i += sizeof(uint32_t)) {
+		uint32_t key_val = 0U;
+
+		memcpy(&key_val, mkey + i, sizeof(uint32_t));
+
+		mmio_write_32(MCE_BASE + MCE_MKEYR + i, key_val);
+	}
+
+	timeout_ref = timeout_init_us(MCE_TIMEOUT_1MS_IN_US);
+
+	while ((mmio_read_32(MCE_BASE + MCE_SR) & MCE_SR_MKVALID) != MCE_SR_MKVALID) {
+		if (timeout_elapsed(timeout_ref)) {
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Lock the MCE master key.
+ * @param  None.
+ * @retval None.
+ */
+void stm32_mce_lock_master_key(void)
+{
+	mmio_setbits_32(MCE_BASE + MCE_CR, MCE_CR_MKLOCK);
+}
+
+/*
+ * @brief  Get the MCE master key lock state.
+ * @param  None.
+ * @retval True if locked, false else.
+ */
+bool stm32_mce_is_master_key_locked(void)
+{
+	return (mmio_read_32(MCE_BASE + MCE_CR) & MCE_CR_MKLOCK) == MCE_CR_MKLOCK;
+}
+
+/*
+ * @brief  Lock the MCE IP registers.
+ * @param  None.
+ * @retval None.
+ */
+void stm32_mce_lock_global(void)
+{
+	mmio_setbits_32(MCE_BASE + MCE_CR, MCE_CR_GLOCK);
+}
+
+/*
+ * @brief  Get the MCE global lock state.
+ * @param  None.
+ * @retval True if locked, false else.
+ */
+bool stm32_mce_is_globally_locked(void)
+{
+	return (mmio_read_32(MCE_BASE + MCE_CR) & MCE_CR_GLOCK) == MCE_CR_GLOCK;
+}
+
+/*
+ * @brief  Get the MCE encryption HW feature state.
+ * @param  None.
+ * @retval True if functional, false else.
+ */
+bool stm32_mce_is_hw_encryption_functional(void)
+{
+	return (mmio_read_32(MCE_BASE + MCE_SR) & MCE_SR_ENCDIS) != MCE_SR_ENCDIS;
+}
+
+/*
+ * @brief  Get the encryption state of an address.
+ * @param  index: Memory address.
+ * @param  state: Ref to the encryption state.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32_mce_get_address_encryption_state(uint32_t address, uint32_t *state)
+{
+	struct stm32_mce_region_s config;
+
+	if ((address < STM32MP_DDR_BASE) ||
+	    (address > (STM32MP_DDR_BASE + dt_get_ddr_size() - 1U)) ||
+	    (state == NULL)) {
+		return -EINVAL;
+	}
+
+	if ((mmio_read_32(MCE_BASE + MCE_REGCR) & MCE_REGCR_ENC) != MCE_REGCR_ENC) {
+		/* No encrypted region, all DDR area is in plain text */
+		*state = MCE_BYPASS_MODE;
+		return 0;
+	}
+
+	if (!stm32_mce_is_hw_encryption_functional()) {
+		ERROR("MCE: encryption feature error\n");
+		return -EIO;
+	}
+
+	/*
+	 * When MCE_SADDR and MCE_EADDR are accessed in read, the 2 MSB bits
+	 * return zeros. So DDR base address mask has to be ORed.
+	 */
+	config.start_address = mmio_read_32(MCE_BASE + MCE_SADDR) |
+			       (STM32MP_DDR_BASE & DDR_BASE_EXTRA_MASK);
+
+	config.end_address = mmio_read_32(MCE_BASE + MCE_EADDR) |
+			     (STM32MP_DDR_BASE & DDR_BASE_EXTRA_MASK);
+
+	if ((address >= config.start_address) && (address <= config.end_address)) {
+		*state = MCE_ENCRYPT_MODE;
+	} else {
+		*state = MCE_BYPASS_MODE;
+	}
+
+	return 0;
+}
+
+void stm32_mce_reload_configuration(void)
+{
+	uint32_t idx;
+
+	for (idx = 0U; idx < MCE_IP_MAX_REGION_NB; idx++) {
+		struct stm32_mce_region_s region;
+
+		stm32mp1_pm_get_mce_region(idx, &region);
+
+		if (region.end_address == 0U) {
+			break;
+		}
+
+		VERBOSE("%s: mce cell found with value = 0x%x 0x%x 0x%x\n", __func__,
+			region.start_address, region.end_address, region.encrypt_mode);
+
+		if (stm32_mce_configure_region(idx, &region) != 0) {
+			panic();
+		}
+	}
+}
+
+static int fconf_populate_mce(uintptr_t config)
+{
+	int node, len;
+	unsigned int i;
+	const struct mce_dt_id_attr *conf_list;
+	const void *dtb = (const void *)config;
+
+	/* Check the node offset point to "st,mem-encrypt" compatible property */
+	const char *compatible_str = "st,mem-encrypt";
+
+	if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_OPEN) &&
+	    !stm32mp_is_auth_supported()) {
+		return 0;
+	}
+
+	node = fdt_node_offset_by_compatible(dtb, -1, compatible_str);
+	if (node < 0) {
+		ERROR("FCONF: Can't find %s compatible in dtb\n", compatible_str);
+		return node;
+	}
+
+	conf_list = (const struct mce_dt_id_attr *)fdt_getprop(dtb, node, "memory-ranges", &len);
+	if (conf_list == NULL) {
+		WARN("FCONF: Read cell failed for %s\n", "memory-ranges");
+		return -1;
+	}
+
+	/* Consider only complete set of values */
+	len -= len % MCE_REGION_PARAMS;
+
+	/* Locate the memory cells and read all values */
+	for (i = 0U; i < ((unsigned int)len / (sizeof(uint32_t) * MCE_REGION_PARAMS)); i++) {
+		uint32_t size;
+		struct stm32_mce_region_s region;
+
+		region.start_address = fdt32_to_cpu(conf_list->id_attr[i * MCE_REGION_PARAMS]);
+		size = fdt32_to_cpu(conf_list->id_attr[i * MCE_REGION_PARAMS + 1U]);
+		region.end_address = region.start_address + size - 1U;
+		region.encrypt_mode = fdt32_to_cpu(conf_list->id_attr[i * MCE_REGION_PARAMS + 2U]);
+
+		VERBOSE("FCONF: mce cell found with value = 0x%x 0x%x 0x%x\n",
+			region.start_address, size, region.encrypt_mode);
+
+		if (stm32_mce_configure_region(i, &region) != 0) {
+			panic();
+		}
+
+		stm32mp1_pm_save_mce_region(i, &region);
+	}
+
+	return 0;
+}
+
+FCONF_REGISTER_POPULATOR(FW_CONFIG, mce_config, fconf_populate_mce);
diff --git a/drivers/st/mmc/stm32_sdmmc2.c b/drivers/st/mmc/stm32_sdmmc2.c
index 6bdd782aea..9137583a84 100644
--- a/drivers/st/mmc/stm32_sdmmc2.c
+++ b/drivers/st/mmc/stm32_sdmmc2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -129,7 +129,18 @@
 #define DT_SDMMC2_COMPAT		"st,stm32-sdmmc2"
 #endif
 
+#if STM32MP13 || STM32MP15
 #define SDMMC_FIFO_SIZE			64U
+#endif
+#if STM32MP25
+#define SDMMC_FIFO_SIZE			1024U
+#endif
+
+#define STM32MP_MMC_INIT_FREQ			U(400000)	/*400 KHz*/
+#define STM32MP_SD_NORMAL_SPEED_MAX_FREQ	U(25000000)	/*25 MHz*/
+#define STM32MP_SD_HIGH_SPEED_MAX_FREQ		U(50000000)	/*50 MHz*/
+#define STM32MP_EMMC_NORMAL_SPEED_MAX_FREQ	U(26000000)	/*26 MHz*/
+#define STM32MP_EMMC_HIGH_SPEED_MAX_FREQ	U(52000000)	/*52 MHz*/
 
 static void stm32_sdmmc2_init(void);
 static int stm32_sdmmc2_send_cmd_req(struct mmc_cmd *cmd);
@@ -529,11 +540,12 @@ static int stm32_sdmmc2_prepare(int lba, uintptr_t buf, size_t size)
 	uint32_t arg_size;
 
 	assert(size != 0U);
+	assert(size <= UINT32_MAX);
 
 	if (size > MMC_BLOCK_SIZE) {
 		arg_size = MMC_BLOCK_SIZE;
 	} else {
-		arg_size = size;
+		arg_size = (uint32_t)size;
 	}
 
 	sdmmc2_params.use_dma = plat_sdmmc2_use_dma(base, buf);
diff --git a/drivers/st/nvmem/nvmem.c b/drivers/st/nvmem/nvmem.c
new file mode 100644
index 0000000000..00688aeb7d
--- /dev/null
+++ b/drivers/st/nvmem/nvmem.c
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <drivers/st/nvmem.h>
+#include <lib/libfdt/libfdt.h>
+#include <lib/libfdt/libfdt_env.h>
+
+#include <platform_def.h>
+
+#define for_each_nvmem_dev(nvmem_dev) \
+	for ((nvmem_dev) = nvmem_dev_array; \
+	     (nvmem_dev) <= &nvmem_dev_array[PLAT_NB_NVMEM_DEVS - 1U]; \
+	     (nvmem_dev)++)
+
+static struct nvmem_dev nvmem_dev_array[PLAT_NB_NVMEM_DEVS];
+
+int nvmem_driver_register(int nodeoffset, const struct nvmem_ops *nvmem_ops,
+			  void *drv_data)
+{
+	struct nvmem_dev *nvmem_dev = NULL;
+
+	for_each_nvmem_dev(nvmem_dev) {
+		if (nvmem_dev->drv_data == NULL) {
+			break;
+		}
+	}
+
+	if (nvmem_dev > &nvmem_dev_array[PLAT_NB_NVMEM_DEVS - 1U]) {
+		WARN("Not enough place for NVMEM dev, PLAT_NB_NVMEM_DEVS should be increased.\n");
+		return -ENOMEM;
+	}
+
+	nvmem_dev->nvmem_ops = nvmem_ops;
+	nvmem_dev->drv_data = drv_data;
+	nvmem_dev->offset = nodeoffset;
+
+	return 0;
+}
+
+static struct nvmem_dev *nvmem_get_by_node(int node_offset)
+{
+	struct nvmem_dev *nvmem_dev = NULL;
+
+	for_each_nvmem_dev(nvmem_dev) {
+		if (nvmem_dev->offset == node_offset) {
+			return nvmem_dev;
+		}
+	}
+
+	WARN("%s: node %d not found\n", __func__, node_offset);
+	return NULL;
+}
+
+int nvmem_get_cell_by_index(const void *fdt, int nodeoffset, unsigned int index,
+			    struct nvmem_cell *cell)
+{
+	int len = 0;
+	const fdt32_t *nvmem_cells_prop = NULL, *nvmem_cell_reg_prop = NULL;
+	uint32_t phandle;
+	int nvmem_cell_node;
+	int parent_node;
+	struct nvmem_dev *dev = NULL;
+
+	nvmem_cells_prop = fdt_getprop(fdt, nodeoffset, "nvmem-cells", &len);
+	if (nvmem_cells_prop == NULL) {
+		ERROR("Can't find nvmem cell");
+		return len;
+	}
+
+	phandle = fdt32_to_cpu(nvmem_cells_prop[index]);
+	nvmem_cell_node = fdt_node_offset_by_phandle(fdt, phandle);
+
+	nvmem_cell_reg_prop = fdt_getprop(fdt, nvmem_cell_node, "reg", &len);
+
+	if ((nvmem_cell_reg_prop == NULL) ||
+	    ((unsigned int)len != (sizeof(uint32_t) * U(2)))) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cell->offset = fdt32_to_cpu(nvmem_cell_reg_prop[0]);
+	cell->len = fdt32_to_cpu(nvmem_cell_reg_prop[1]);
+
+	parent_node = fdt_parent_offset(fdt, nvmem_cell_node);
+	dev = nvmem_get_by_node(parent_node);
+	if (dev == NULL) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cell->dev = dev;
+	return 0;
+}
+
+int nvmem_get_cell_by_name(const void *fdt, int nodeoffset, const char *name,
+			   struct nvmem_cell *cell)
+{
+	int index = fdt_stringlist_search(fdt, nodeoffset, "nvmem-cell-names", name);
+
+	if (index < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	return nvmem_get_cell_by_index(fdt, nodeoffset, (unsigned int)index,
+				       cell);
+};
+
+int nvmem_cell_read(struct nvmem_cell *cell, uint8_t *output_buf,
+		    size_t buf_len, size_t *read_len)
+{
+	if (cell->dev->nvmem_ops->read_cell == NULL) {
+		return -ENOTSUP;
+	}
+
+	return cell->dev->nvmem_ops->read_cell(cell, output_buf, buf_len,
+					       read_len);
+}
+
+int nvmem_cell_write(struct nvmem_cell *cell, uint8_t *input_buf,
+		     size_t buf_len)
+{
+	if (cell->dev->nvmem_ops->write_cell == NULL) {
+		return -ENOTSUP;
+	}
+
+	return cell->dev->nvmem_ops->write_cell(cell, input_buf, buf_len);
+}
diff --git a/drivers/st/nvmem/stm32mp_tamp_nvram_core.c b/drivers/st/nvmem/stm32mp_tamp_nvram_core.c
new file mode 100644
index 0000000000..3eed7d17c0
--- /dev/null
+++ b/drivers/st/nvmem/stm32mp_tamp_nvram_core.c
@@ -0,0 +1,414 @@
+/*
+ * Copyright (c) 2023, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/nvmem.h>
+#include <drivers/st/stm32mp_tamp_nvram.h>
+#include <lib/mmio.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <stm32mp_dt.h>
+
+#define DEBUG_RIGHT_MAX_SIZE 100
+
+static struct stm32_tamp_nvram_drv_data nvram_drv_data;
+
+int stm32_tamp_nvram_reg_get_zone(struct stm32_tamp_nvram_drv_data *drv_data, int reg)
+{
+	int *bkpreg_zones_end = drv_data->bkpreg_zones_end;
+	unsigned int nb_zones = drv_data->cdata->nb_zones;
+	unsigned int protection_zone_idx;
+
+	for (protection_zone_idx = 0; protection_zone_idx < nb_zones; protection_zone_idx++) {
+		if (reg <= bkpreg_zones_end[protection_zone_idx]) {
+			break;
+		}
+	}
+
+	if (protection_zone_idx >= nb_zones) {
+		return -1; /* the reg is not a part of any zone */
+	}
+
+	return protection_zone_idx;
+}
+
+static int
+stm32_tamp_nvram_read_bkp(struct stm32_tamp_nvram_drv_data *drv_data, size_t offset, uint32_t *val)
+{
+	unsigned int reg = (offset / sizeof(uint32_t));
+	int protection_zone_idx = stm32_tamp_nvram_reg_get_zone(drv_data, (int)reg);
+	int ret = -1;
+
+	if (protection_zone_idx >= 0) {
+		bool clk_should_be_toggled = !clk_is_enabled(TAMP_BKP_REG_CLK);
+
+		switch (drv_data->bkpreg_access[protection_zone_idx]) {
+		case RNSWNS:
+		case RNSWS:
+		case RONS:
+		case RSWS:
+			if (clk_should_be_toggled) {
+				clk_enable(TAMP_BKP_REG_CLK);
+			}
+			*val = mmio_read_32(drv_data->base + offset);
+			if (clk_should_be_toggled) {
+				clk_disable(TAMP_BKP_REG_CLK);
+			}
+			ret = 0;
+			break;
+		case NORNOW:
+			*val = U(0x0);
+			ret = 0;
+			break;
+		default:
+			ERROR("Wrong access rights for zone %d (%u)\n", protection_zone_idx, reg);
+		}
+	}
+
+	return ret;
+}
+
+static int
+stm32_tamp_nvram_write_bkp(struct stm32_tamp_nvram_drv_data *drv_data, size_t offset, uint32_t val)
+{
+	unsigned int reg = (offset / sizeof(uint32_t));
+	int protection_zone_idx = stm32_tamp_nvram_reg_get_zone(drv_data, (int)reg);
+	int ret = -1;
+
+	if (protection_zone_idx >= 0) {
+		bool clk_should_be_toggled = !clk_is_enabled(TAMP_BKP_REG_CLK);
+
+		switch (drv_data->bkpreg_access[protection_zone_idx]) {
+		case RNSWNS:
+		case RNSWS:
+		case RSWS:
+			if (clk_should_be_toggled) {
+				clk_enable(TAMP_BKP_REG_CLK);
+			}
+			mmio_write_32(drv_data->base + offset, val);
+			if (clk_should_be_toggled) {
+				clk_disable(TAMP_BKP_REG_CLK);
+			}
+			ret = 0;
+			break;
+		case RONS:
+		case NORNOW:
+			ret = 0;
+			break;
+		default:
+			ERROR("Wrong access rights for zone %d (%u)\n", protection_zone_idx, reg);
+		}
+	}
+
+	return ret;
+}
+
+int stm32_tamp_nvram_reg_field_read(uintptr_t base, struct stm32_tamp_nvram_reg_field field,
+				    uint32_t *val)
+{
+	uint32_t reg_val = 0;
+
+	reg_val = mmio_read_32(base + field.reg_offset);
+	reg_val &= GENMASK_32(field.highest_bit, field.lowest_bit);
+	reg_val >>= field.lowest_bit;
+	*val = reg_val;
+
+	return 0;
+}
+
+int stm32_tamp_nvram_reg_field_write(uintptr_t base, struct stm32_tamp_nvram_reg_field field,
+				     uint32_t val)
+{
+	uint32_t reg_val = 0;
+	uint32_t val_temp = val;
+	bool clk_should_be_toggled = !clk_is_enabled(TAMP_BKP_REG_CLK);
+
+	val_temp &= GENMASK_32(field.highest_bit - field.lowest_bit, 0);
+	if (clk_should_be_toggled) {
+		clk_enable(TAMP_BKP_REG_CLK);
+	}
+	reg_val = mmio_read_32(base + field.reg_offset);
+	reg_val &= ~(GENMASK_32(field.highest_bit, field.lowest_bit));
+	reg_val |= (val_temp << field.lowest_bit);
+	mmio_write_32(base + field.reg_offset, reg_val);
+	if (clk_should_be_toggled) {
+		clk_disable(TAMP_BKP_REG_CLK);
+	}
+
+	return 0;
+}
+
+static int
+stm32_tamp_nvram_write_byte(struct stm32_tamp_nvram_drv_data *drv_data, size_t offset, uint8_t byte)
+{
+	size_t offset_aligned = round_down(offset, sizeof(uint32_t));
+	size_t byte_in_word = offset - offset_aligned;
+	uint32_t read_value = 0;
+	uint32_t to_be_writen_value = 0;
+	uint32_t mask = UCHAR_MAX;
+
+	mask = ~(mask << (byte_in_word * U(8)));
+
+	stm32_tamp_nvram_read_bkp(drv_data, offset_aligned, &read_value);
+
+	to_be_writen_value = read_value & mask;
+	to_be_writen_value |= (uint32_t)byte << (byte_in_word * U(8));
+
+	return stm32_tamp_nvram_write_bkp(drv_data, offset_aligned, to_be_writen_value);
+}
+
+static int
+stm32_tamp_nvram_read_byte(struct stm32_tamp_nvram_drv_data *drv_data, size_t offset, uint8_t *byte)
+{
+	size_t offset_aligned = round_down(offset, sizeof(uint32_t));
+	size_t byte_in_word = offset - offset_aligned;
+	uint32_t read_value = 0;
+
+	stm32_tamp_nvram_read_bkp(drv_data, offset_aligned, &read_value);
+	*byte = (uint8_t)((read_value >> (byte_in_word * U(8))) & UCHAR_MAX);
+
+	return 0;
+}
+
+static int
+stm32_tamp_nvram_read(struct stm32_tamp_nvram_drv_data *drv_data, size_t offset, uint8_t *buf_u8,
+		      size_t size)
+{
+	size_t i = offset;
+	size_t total = offset + size;
+
+	while (i < total) {
+		size_t reg_idx = i / sizeof(uint32_t);
+
+		if (((i + sizeof(uint32_t)) <= total) && is_aligned(i, sizeof(uint32_t))) {
+			uint32_t tmp_u32 = 0;
+			void *mem_cpy_ret = NULL;
+
+			stm32_tamp_nvram_read_bkp(drv_data, i, &tmp_u32);
+			mem_cpy_ret = memcpy(&buf_u8[i - offset],
+					     (uint8_t *)&tmp_u32,
+					     sizeof(uint32_t));
+			if (mem_cpy_ret != &buf_u8[i - offset]) {
+				ERROR("Failed to read bkp %zu\n", reg_idx);
+
+				return -1;
+			}
+			i += sizeof(uint32_t);
+		} else {
+			uint8_t byte = 0;
+			int ret = stm32_tamp_nvram_read_byte(drv_data, i, &byte);
+
+			if (ret != 0) {
+				ERROR("BKPreg %zu is not allowed to be read\n", reg_idx);
+				byte = 0;
+			}
+			buf_u8[i] = byte;
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+static int
+stm32_tamp_nvram_write(struct stm32_tamp_nvram_drv_data *drv_data, size_t offset,
+		       const uint8_t *buf_u8, size_t size)
+{
+	size_t total = offset + size;
+	size_t i = offset;
+
+	while (i < total) {
+		int ret = 0;
+		size_t reg_idx = i / sizeof(uint32_t);
+
+		if (((i + sizeof(uint32_t)) <= total) && is_aligned(i, sizeof(uint32_t))) {
+			uint32_t tmp_u32 = 0;
+			void *mem_cpy_ret = NULL;
+
+			mem_cpy_ret = memcpy((uint8_t *)&tmp_u32,
+					     &buf_u8[i - offset],
+					     sizeof(uint32_t));
+			if (mem_cpy_ret != &tmp_u32) {
+				ERROR("Failed to read bkp %zu\n", reg_idx);
+				return -1;
+			}
+
+			ret = stm32_tamp_nvram_write_bkp(drv_data, i, tmp_u32);
+			if (ret != 0) {
+				ERROR("Failed to read bkp %zu\n", reg_idx);
+				return ret;
+			}
+			i += sizeof(uint32_t);
+		} else {
+			ret = stm32_tamp_nvram_write_byte(drv_data, i, buf_u8[i - offset]);
+			if (ret != 0) {
+				VERBOSE("BKPreg %zu is not allowed to be written\n", reg_idx);
+			}
+			i++;
+		}
+	}
+
+	return 0;
+}
+
+static int *
+stm32_tamp_nvram_get_backup_zones(struct stm32_tamp_nvram_drv_data *drv_data)
+{
+	static int static_bkpreg_zones_end[MAX_TAMP_BACKUP_REGS_ZONES];
+	unsigned int nb_zones = drv_data->cdata->nb_zones;
+	const struct stm32_tamp_nvram_cdata *cdata = drv_data->cdata;
+	unsigned int zone_idx = 0;
+	int *bkpreg_zones_end = static_bkpreg_zones_end;
+	uint32_t offset_field = 0;
+	struct stm32_tamp_nvram_reg_field zone_cfg_field = { 0 };
+
+	/* Get the n-1 frontiers of zone within the tamp configuration registers */
+	for (zone_idx = 0; zone_idx < (nb_zones - U(1)); zone_idx++) {
+		zone_cfg_field = cdata->zone_cfg[zone_idx];
+
+		if (stm32_tamp_nvram_reg_field_read(drv_data->parent_base,
+						    zone_cfg_field,
+						    &offset_field) != 0) {
+			ERROR("Can't read field for registers zones\n");
+			return NULL;
+		}
+
+		/* in order to deal with no offset for a zone we store -1 for the zone end
+		 * => the zone is empty
+		 */
+		bkpreg_zones_end[zone_idx] = ((int)offset_field) - 1;
+	}
+
+	/* The last zone end is defined by the number of registers in TAMP */
+	bkpreg_zones_end[zone_idx] = ((int)drv_data->nb_total_regs) - 1;
+
+	return bkpreg_zones_end;
+}
+
+static int
+stm32_tamp_nvram_read_cell(struct nvmem_cell *cell, uint8_t *output_buf, size_t buf_len,
+				      size_t *read_len)
+{
+	struct stm32_tamp_nvram_drv_data *drv_data =
+		(struct stm32_tamp_nvram_drv_data *)cell->dev->drv_data;
+
+	if (buf_len < cell->len) {
+		return -1;
+	}
+
+	if (read_len != NULL) {
+		*read_len = cell->len;
+	}
+
+	return stm32_tamp_nvram_read(drv_data, cell->offset, output_buf, cell->len);
+}
+
+static int stm32_tamp_nvram_write_cell(struct nvmem_cell *cell, uint8_t *input_buf, size_t len)
+{
+	struct stm32_tamp_nvram_drv_data *drv_data =
+		(struct stm32_tamp_nvram_drv_data *)cell->dev->drv_data;
+
+	if (len > cell->len) {
+		return -1;
+	}
+
+	return stm32_tamp_nvram_write(drv_data, cell->offset, input_buf, cell->len);
+}
+
+static const struct nvmem_ops stm32_tamp_nvram_nvmem_ops = {
+	.read_cell = stm32_tamp_nvram_read_cell,
+	.write_cell = stm32_tamp_nvram_write_cell,
+};
+
+int stm32_tamp_nvram_init(void)
+{
+	int node = 0;
+	int parent_node = 0;
+	void *fdt = NULL;
+	int len = 0;
+	const fdt32_t *reg_prop = NULL;
+	const fdt32_t *parent_reg_prop = NULL;
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	/* Get node and compatible data */
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_TAMP_NVRAM_COMPAT);
+	if (node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	nvram_drv_data.cdata = stm32_tamp_nvram_get_cdata();
+
+	reg_prop = fdt_getprop(fdt, node, "reg", &len);
+
+	if ((reg_prop == NULL) || ((unsigned int)len != (sizeof(uint32_t) * U(2)))) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	nvram_drv_data.base = fdt32_to_cpu(reg_prop[0]);
+	nvram_drv_data.size = fdt32_to_cpu(reg_prop[1]);
+
+	parent_node = fdt_parent_offset(fdt, node);
+	if (parent_node < 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	/* Get address of the device */
+	parent_reg_prop = fdt_getprop(fdt, parent_node, "reg", &len);
+
+	if ((parent_reg_prop == NULL) || ((unsigned int)len != (sizeof(uint32_t) * U(2)))) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	nvram_drv_data.parent_base = fdt32_to_cpu(parent_reg_prop[0]);
+	nvram_drv_data.parent_size = fdt32_to_cpu(parent_reg_prop[1]);
+
+	nvram_drv_data.nb_total_regs = nvram_drv_data.size / sizeof(uint32_t);
+
+	stm32_tamp_nvram_update_rights();
+
+
+	nvram_drv_data.node = node;
+	nvram_drv_data.tamp_fdt = fdt;
+
+	nvmem_driver_register(nvram_drv_data.node, &stm32_tamp_nvram_nvmem_ops, &nvram_drv_data);
+
+	return 0;
+}
+
+int stm32_tamp_nvram_update_rights(void)
+{
+	bool clk_should_be_toggled = !clk_is_enabled(TAMP_BKP_REG_CLK);
+
+	if (clk_should_be_toggled) {
+		clk_enable(TAMP_BKP_REG_CLK);
+	}
+	nvram_drv_data.bkpreg_zones_end = stm32_tamp_nvram_get_backup_zones(&nvram_drv_data);
+	if (nvram_drv_data.bkpreg_zones_end == NULL) {
+		NOTICE("Failed to get the backup zone from tamp regs\n\n");
+		return -ENOMEM;
+	}
+
+	nvram_drv_data.bkpreg_access = stm32_tamp_nvram_get_access_rights(&nvram_drv_data);
+	if (nvram_drv_data.bkpreg_access == NULL) {
+		ERROR("Failed to get the backup zone access rights\n\n");
+		return -ENOMEM;
+	}
+
+	if (clk_should_be_toggled) {
+		clk_disable(TAMP_BKP_REG_CLK);
+	}
+
+	return 0;
+}
diff --git a/drivers/st/nvmem/stm32mp_tamp_nvram_mp1.c b/drivers/st/nvmem/stm32mp_tamp_nvram_mp1.c
new file mode 100644
index 0000000000..5b0fa5a1f0
--- /dev/null
+++ b/drivers/st/nvmem/stm32mp_tamp_nvram_mp1.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2023, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/st/stm32mp_tamp_nvram.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+#define BKPREG_ZONE_1 U(0)
+#define BKPREG_ZONE_2 U(1)
+#define BKPREG_ZONE_3 U(2)
+
+static const struct stm32_tamp_nvram_reg_field
+	mp1_zone_cfg_fields[MAX_TAMP_BACKUP_REGS_ZONES - 1] = {
+		[BKPREG_ZONE_1] = REG_FIELD(TAMP_SECCFGR, 0, 7),
+		[BKPREG_ZONE_2] = REG_FIELD(TAMP_SECCFGR, 16, 23),
+	};
+
+static const struct stm32_tamp_nvram_cdata stm32mp1_tamp_nvram = {
+	.nb_zones = MAX_TAMP_BACKUP_REGS_ZONES,
+	.zone_cfg = mp1_zone_cfg_fields,
+};
+
+static enum stm32_tamp_bkpreg_access mp1_bkpreg_access[MAX_TAMP_BACKUP_REGS_ZONES] = {
+	[BKPREG_ZONE_1] = RSWS,
+	[BKPREG_ZONE_2] = RNSWS,
+	[BKPREG_ZONE_3] = RNSWNS,
+};
+
+const struct stm32_tamp_nvram_cdata *stm32_tamp_nvram_get_cdata(void)
+{
+	return &stm32mp1_tamp_nvram;
+}
+
+enum stm32_tamp_bkpreg_access *
+stm32_tamp_nvram_get_access_rights(struct stm32_tamp_nvram_drv_data *drv_data)
+{
+	return &mp1_bkpreg_access[0];
+}
diff --git a/drivers/st/nvmem/stm32mp_tamp_nvram_mp2.c b/drivers/st/nvmem/stm32mp_tamp_nvram_mp2.c
new file mode 100644
index 0000000000..a0df9c0ba3
--- /dev/null
+++ b/drivers/st/nvmem/stm32mp_tamp_nvram_mp2.c
@@ -0,0 +1,232 @@
+/*
+ * Copyright (c) 2023, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/st/stm32mp_tamp_nvram.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+#define BKPREG_ZONE_1_RIF1 U(0)
+#define BKPREG_ZONE_1_RIF2 U(1)
+#define BKPREG_ZONE_2_RIF1 U(2)
+#define BKPREG_ZONE_2_RIF2 U(3)
+#define BKPREG_ZONE_3_RIF1 U(4)
+#define BKPREG_ZONE_3_RIF0 U(5)
+#define BKPREG_ZONE_3_RIF2 U(6)
+#define NB_CMPT_MP2 U(3)
+
+static const struct stm32_tamp_nvram_reg_field
+	mp25_zone_cfg_fields[MAX_TAMP_BACKUP_REGS_ZONES - 1] = {
+		[BKPREG_ZONE_1_RIF1] = REG_FIELD(TAMP_BKPRIFR(1), U(0), U(7)),
+		[BKPREG_ZONE_1_RIF2] = REG_FIELD(TAMP_SECCFGR, U(0), U(7)),
+		[BKPREG_ZONE_2_RIF1] = REG_FIELD(TAMP_BKPRIFR(2), U(0), U(7)),
+		[BKPREG_ZONE_2_RIF2] = REG_FIELD(TAMP_SECCFGR, U(16), U(23)),
+		[BKPREG_ZONE_3_RIF1] = REG_FIELD(TAMP_BKPRIFR(3), U(0), U(7)),
+		[BKPREG_ZONE_3_RIF0] = REG_FIELD(TAMP_BKPRIFR(3), U(16), U(23)),
+	};
+
+static const struct stm32_tamp_nvram_reg_field
+	mp25_rxcidcfg_cfen_fields[NB_CMPT_MP2] = {
+		REG_FIELD(TAMP_RXCIDCFGR(0), U(0), U(0)),
+		REG_FIELD(TAMP_RXCIDCFGR(1), U(0), U(0)),
+		REG_FIELD(TAMP_RXCIDCFGR(2), U(0), U(0)),
+	};
+
+static const struct stm32_tamp_nvram_reg_field
+	mp25_rxcidcfg_fields[NB_CMPT_MP2] = {
+		REG_FIELD(TAMP_RXCIDCFGR(0), U(4), U(6)),
+		REG_FIELD(TAMP_RXCIDCFGR(1), U(4), U(6)),
+		REG_FIELD(TAMP_RXCIDCFGR(2), U(4), U(6)),
+	};
+
+static const struct stm32_tamp_nvram_cdata stm32mp25_tamp_nvram = {
+	.nb_zones = MAX_TAMP_BACKUP_REGS_ZONES,
+	.zone_cfg = mp25_zone_cfg_fields,
+};
+
+const struct stm32_tamp_nvram_cdata *stm32_tamp_nvram_get_cdata(void)
+{
+	return &stm32mp25_tamp_nvram;
+}
+
+static int stm32_tamp_nvram_is_isolation_en_mp2(
+	const struct stm32_tamp_nvram_drv_data *drv_data)
+{
+	unsigned int nb_compartment_enabled = 0;
+	uint32_t cfen = 0;
+	struct stm32_tamp_nvram_reg_field cfen_field = { 0 };
+	int ret = 1;
+
+	for (unsigned int i = 0; i < NB_CMPT_MP2; i++) {
+		cfen_field = mp25_rxcidcfg_cfen_fields[i];
+		if (stm32_tamp_nvram_reg_field_read(drv_data->parent_base,
+						    cfen_field, &cfen) != 0) {
+			NOTICE("TFA: Can't read field for registers zones\n");
+			nb_compartment_enabled = UINT_MAX;
+			break;
+		}
+
+		nb_compartment_enabled += cfen;
+	}
+
+	if (nb_compartment_enabled == U(0)) {
+		ret = 0;
+	} else if (nb_compartment_enabled == NB_CMPT_MP2) {
+		ret = 1;
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static bool *
+stm32_tamp_get_cmpt_owner_mp2(struct stm32_tamp_nvram_drv_data *drv_data)
+{
+	struct stm32_tamp_nvram_reg_field cid_field = { U(0) };
+	uint32_t cid_per_zone = U(0);
+	int isolation_enabled = 0;
+	static bool compartment_owner[3];
+	unsigned int i = 0;
+	bool *ret = NULL;
+
+	isolation_enabled = stm32_tamp_nvram_is_isolation_en_mp2(drv_data);
+	if (isolation_enabled >= 0) {
+		ret = compartment_owner;
+		for (i = U(0); i < NB_CMPT_MP2; i++) {
+			if (isolation_enabled != 0) {
+				cid_field = mp25_rxcidcfg_fields[i];
+
+				if (stm32_tamp_nvram_reg_field_read(drv_data->parent_base,
+						   cid_field,
+						   &cid_per_zone) != 0) {
+					NOTICE("TFA: Can't read field for registers zones\n");
+					ret = NULL;
+					break;
+				}
+
+				if (cid_per_zone == CURRENT_CID) {
+					compartment_owner[i] = true;
+				} else {
+					compartment_owner[i] = false;
+				}
+			} else {
+				compartment_owner[i] = true;
+			}
+		}
+	}
+
+	return ret;
+}
+
+enum stm32_tamp_bkpreg_access *
+stm32_tamp_nvram_get_access_rights(struct stm32_tamp_nvram_drv_data *drv_data)
+{
+	static enum stm32_tamp_bkpreg_access static_bkpreg_access[MAX_TAMP_BACKUP_REGS_ZONES];
+	unsigned int nb_zones = drv_data->cdata->nb_zones;
+	enum stm32_tamp_bkpreg_access *bkpreg_access = static_bkpreg_access;
+
+	drv_data->compartment_owner = stm32_tamp_get_cmpt_owner_mp2(drv_data);
+	if (drv_data->compartment_owner != NULL) {
+		bkpreg_access = static_bkpreg_access;
+		for (unsigned int protection_zone_idx = 0;
+		     (protection_zone_idx < nb_zones); protection_zone_idx++) {
+			switch (protection_zone_idx) {
+			case BKPREG_ZONE_1_RIF1:
+				if (drv_data->compartment_owner[U(1)]) {
+					bkpreg_access[protection_zone_idx] =
+						RSWS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			case BKPREG_ZONE_1_RIF2:
+				if (drv_data->compartment_owner[U(2)]) {
+					bkpreg_access[protection_zone_idx] =
+						RSWS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			case BKPREG_ZONE_2_RIF1:
+				if (drv_data->compartment_owner[U(1)]) {
+					bkpreg_access[protection_zone_idx] =
+						RNSWS;
+				} else if (drv_data->compartment_owner[U(2)]) {
+					bkpreg_access[protection_zone_idx] =
+						RONS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			case BKPREG_ZONE_2_RIF2:
+				if (drv_data->compartment_owner[U(2)]) {
+					bkpreg_access[protection_zone_idx] =
+						RNSWS;
+				} else if (drv_data->compartment_owner[U(1)]) {
+					bkpreg_access[protection_zone_idx] =
+						RONS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			case BKPREG_ZONE_3_RIF1:
+				if (drv_data->compartment_owner[U(1)]) {
+					bkpreg_access[protection_zone_idx] =
+						RNSWNS;
+				} else if (drv_data->compartment_owner[U(0)] ||
+					   drv_data->compartment_owner[U(2)]) {
+					bkpreg_access[protection_zone_idx] =
+						RONS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			case BKPREG_ZONE_3_RIF0:
+				if (drv_data->compartment_owner[U(0)]) {
+					bkpreg_access[protection_zone_idx] =
+						RNSWNS;
+				} else if (drv_data->compartment_owner[U(1)] ||
+					   drv_data->compartment_owner[U(2)]) {
+					bkpreg_access[protection_zone_idx] =
+						RONS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			case BKPREG_ZONE_3_RIF2:
+				if (drv_data->compartment_owner[U(2)]) {
+					bkpreg_access[protection_zone_idx] =
+						RNSWNS;
+				} else if (drv_data->compartment_owner[U(0)] ||
+					   drv_data->compartment_owner[U(1)]) {
+					bkpreg_access[protection_zone_idx] =
+						RONS;
+				} else {
+					bkpreg_access[protection_zone_idx] =
+						NORNOW;
+				}
+				break;
+			default:
+				bkpreg_access = NULL;
+				break;
+			}
+
+			if (bkpreg_access == NULL) {
+				break;
+			}
+		}
+	}
+
+	return bkpreg_access;
+}
diff --git a/drivers/st/pmic/stm32mp_pmic.c b/drivers/st/pmic/stm32mp_pmic.c
index 5b4376041b..0e774b848c 100644
--- a/drivers/st/pmic/stm32mp_pmic.c
+++ b/drivers/st/pmic/stm32mp_pmic.c
@@ -20,6 +20,7 @@
 #include <platform_def.h>
 
 #define PMIC_NODE_NOT_FOUND	1
+#define NB_REG			14U
 
 static struct i2c_handle_s i2c_handle;
 static uint32_t pmic_i2c_addr;
@@ -58,7 +59,11 @@ int dt_pmic_status(void)
 		return status;
 	}
 
+#if defined(IMAGE_BL2)
+	status = DT_SECURE;
+#else
 	status = (int)fdt_get_status(node);
+#endif
 
 	return status;
 }
@@ -116,6 +121,10 @@ static int dt_pmic_i2c_config(struct dt_node_info *i2c_info,
 		return -FDT_ERR_NOTFOUND;
 	}
 
+#if defined(IMAGE_BL2)
+	i2c_info->status = DT_SECURE;
+#endif
+
 	return stm32_i2c_get_setup_from_fdt(fdt, i2c_node, init);
 }
 
@@ -215,120 +224,6 @@ void print_pmic_info_and_debug(void)
 }
 #endif
 
-int pmic_ddr_power_init(enum ddr_type ddr_type)
-{
-	int status;
-	uint16_t buck3_min_mv;
-	struct rdev *buck2, *buck3, *vref;
-	struct rdev *ldo3 __unused;
-
-	buck2 = regulator_get_by_name("buck2");
-	if (buck2 == NULL) {
-		return -ENOENT;
-	}
-
-#if STM32MP15
-	ldo3 = regulator_get_by_name("ldo3");
-	if (ldo3 == NULL) {
-		return -ENOENT;
-	}
-#endif
-
-	vref = regulator_get_by_name("vref_ddr");
-	if (vref == NULL) {
-		return -ENOENT;
-	}
-
-	switch (ddr_type) {
-	case STM32MP_DDR3:
-#if STM32MP15
-		status = regulator_set_flag(ldo3, REGUL_SINK_SOURCE);
-		if (status != 0) {
-			return status;
-		}
-#endif
-
-		status = regulator_set_min_voltage(buck2);
-		if (status != 0) {
-			return status;
-		}
-
-		status = regulator_enable(buck2);
-		if (status != 0) {
-			return status;
-		}
-
-		status = regulator_enable(vref);
-		if (status != 0) {
-			return status;
-		}
-
-#if STM32MP15
-		status = regulator_enable(ldo3);
-		if (status != 0) {
-			return status;
-		}
-#endif
-		break;
-
-	case STM32MP_LPDDR2:
-	case STM32MP_LPDDR3:
-		/*
-		 * Set LDO3 to 1.8V
-		 * Set LDO3 to bypass mode if BUCK3 = 1.8V
-		 * Set LDO3 to normal mode if BUCK3 != 1.8V
-		 */
-		buck3 = regulator_get_by_name("buck3");
-		if (buck3 == NULL) {
-			return -ENOENT;
-		}
-
-		regulator_get_range(buck3, &buck3_min_mv, NULL);
-
-#if STM32MP15
-		if (buck3_min_mv != 1800) {
-			status = regulator_set_min_voltage(ldo3);
-			if (status != 0) {
-				return status;
-			}
-		} else {
-			status = regulator_set_flag(ldo3, REGUL_ENABLE_BYPASS);
-			if (status != 0) {
-				return status;
-			}
-		}
-#endif
-
-		status = regulator_set_min_voltage(buck2);
-		if (status != 0) {
-			return status;
-		}
-
-#if STM32MP15
-		status = regulator_enable(ldo3);
-		if (status != 0) {
-			return status;
-		}
-#endif
-
-		status = regulator_enable(buck2);
-		if (status != 0) {
-			return status;
-		}
-
-		status = regulator_enable(vref);
-		if (status != 0) {
-			return status;
-		}
-		break;
-
-	default:
-		break;
-	};
-
-	return 0;
-}
-
 int pmic_voltages_init(void)
 {
 #if STM32MP13
@@ -359,6 +254,16 @@ int pmic_voltages_init(void)
 	return 0;
 }
 
+void pmic_switch_off(void)
+{
+	if (stpmic1_switch_off() == 0) {
+		udelay(100);
+	}
+
+	/* Shouldn't be reached */
+	panic();
+}
+
 enum {
 	STPMIC1_BUCK1 = 0,
 	STPMIC1_BUCK2,
@@ -454,13 +359,13 @@ static const struct regul_ops pmic_ops = {
 };
 
 #define DEFINE_REGU(name) { \
-	.node_name = name, \
+	.node_name = (name), \
 	.ops = &pmic_ops, \
 	.driver_data = NULL, \
 	.enable_ramp_delay = 1000, \
 }
 
-static const struct regul_description pmic_regs[] = {
+static const struct regul_description pmic_regs[NB_REG] = {
 	[STPMIC1_BUCK1] = DEFINE_REGU("buck1"),
 	[STPMIC1_BUCK2] = DEFINE_REGU("buck2"),
 	[STPMIC1_BUCK3] = DEFINE_REGU("buck3"),
@@ -477,8 +382,6 @@ static const struct regul_description pmic_regs[] = {
 	[STPMIC1_SW_OUT] = DEFINE_REGU("pwr_sw2"),
 };
 
-#define NB_REG ARRAY_SIZE(pmic_regs)
-
 static int register_pmic(void)
 {
 	void *fdt;
@@ -506,7 +409,7 @@ static int register_pmic(void)
 		unsigned int i;
 		int ret;
 
-		for (i = 0; i < NB_REG; i++) {
+		for (i = 0U; i < NB_REG; i++) {
 			desc = &pmic_regs[i];
 			if (strcmp(desc->node_name, reg_name) == 0) {
 				break;
@@ -520,6 +423,15 @@ static int register_pmic(void)
 			     __LINE__, reg_name);
 			return ret;
 		}
+
+		if (fdt_getprop(fdt, subnode, "st,mask-reset", NULL)  != NULL) {
+			VERBOSE("%s: set mask-reset\n", desc->node_name);
+			ret = pmic_set_flag(desc, REGUL_MASK_RESET);
+			if (ret != 0) {
+				ERROR("set mask-reset failed\n");
+				return ret;
+			}
+		}
 	}
 
 	return 0;
diff --git a/drivers/st/pmic/stm32mp_pmic2.c b/drivers/st/pmic/stm32mp_pmic2.c
new file mode 100644
index 0000000000..9ab65ee13d
--- /dev/null
+++ b/drivers/st/pmic/stm32mp_pmic2.c
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/regulator.h>
+#include <drivers/st/stm32_i2c.h>
+#include <drivers/st/stm32mp_pmic2.h>
+#include <drivers/st/stpmic2.h>
+#include <lib/mmio.h>
+#include <lib/spinlock.h>
+#include <lib/utils_def.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#define PMIC_NODE_NOT_FOUND	1
+
+struct regul_handle_s {
+	const uint32_t id;
+	uint16_t bypass_mv;
+};
+
+static struct pmic_handle_s pmic2_handle;
+static struct i2c_handle_s i2c_handle;
+
+/* This driver is monoinstance */
+static struct pmic_handle_s *pmic2;
+
+static int dt_get_pmic_node(void *fdt)
+{
+	static int node = -FDT_ERR_BADOFFSET;
+
+	if (node == -FDT_ERR_BADOFFSET) {
+		node = fdt_node_offset_by_compatible(fdt, -1, "st,stpmic2");
+	}
+
+	return node;
+}
+
+int dt_pmic_status(void)
+{
+	static int status = -FDT_ERR_BADVALUE;
+	int node;
+	void *fdt;
+
+	if (status != -FDT_ERR_BADVALUE) {
+		return status;
+	}
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	node = dt_get_pmic_node(fdt);
+	if (node <= 0) {
+		status = -FDT_ERR_NOTFOUND;
+
+		return status;
+	}
+
+	status = DT_SECURE;
+
+	return status;
+}
+
+/*
+ * Get PMIC and its I2C bus configuration from the device tree.
+ * Return 0 on success, negative on error, 1 if no PMIC node is defined.
+ */
+static int dt_pmic2_i2c_config(struct dt_node_info *i2c_info,
+			       struct stm32_i2c_init_s *init,
+			       uint32_t *i2c_addr)
+{
+	static int i2c_node = -FDT_ERR_NOTFOUND;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	if (i2c_node == -FDT_ERR_NOTFOUND) {
+		int pmic_node;
+		const fdt32_t *cuint;
+
+		pmic_node = dt_get_pmic_node(fdt);
+		if (pmic_node < 0) {
+			return PMIC_NODE_NOT_FOUND;
+		}
+
+		cuint = fdt_getprop(fdt, pmic_node, "reg", NULL);
+		if (cuint == NULL) {
+			return -FDT_ERR_NOTFOUND;
+		}
+
+		*i2c_addr = fdt32_to_cpu(*cuint) << 1;
+		if (*i2c_addr > UINT16_MAX) {
+			return -FDT_ERR_BADVALUE;
+		}
+
+		i2c_node = fdt_parent_offset(fdt, pmic_node);
+		if (i2c_node < 0) {
+			return -FDT_ERR_NOTFOUND;
+		}
+	}
+
+	dt_fill_device_info(i2c_info, i2c_node);
+	if (i2c_info->base == 0U) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	i2c_info->status = DT_SECURE;
+
+	return stm32_i2c_get_setup_from_fdt(fdt, i2c_node, init);
+}
+
+bool initialize_pmic_i2c(void)
+{
+	int ret;
+	struct dt_node_info i2c_info;
+	struct i2c_handle_s *i2c = &i2c_handle;
+	uint32_t i2c_addr = 0U;
+	struct stm32_i2c_init_s i2c_init;
+
+	ret = dt_pmic2_i2c_config(&i2c_info, &i2c_init, &i2c_addr);
+	if (ret < 0) {
+		ERROR("I2C configuration failed %d\n", ret);
+		panic();
+	}
+
+	if (ret != 0) {
+		return false;
+	}
+
+	/* Initialize PMIC I2C */
+	i2c->i2c_base_addr		= i2c_info.base;
+	i2c->dt_status			= i2c_info.status;
+	i2c->clock			= i2c_info.clock;
+	i2c->i2c_state			= I2C_STATE_RESET;
+	i2c_init.own_address1		= i2c_addr;
+	i2c_init.addressing_mode	= I2C_ADDRESSINGMODE_7BIT;
+	i2c_init.dual_address_mode	= I2C_DUALADDRESS_DISABLE;
+	i2c_init.own_address2		= 0;
+	i2c_init.own_address2_masks	= I2C_OAR2_OA2NOMASK;
+	i2c_init.general_call_mode	= I2C_GENERALCALL_DISABLE;
+	i2c_init.no_stretch_mode	= I2C_NOSTRETCH_DISABLE;
+	i2c_init.analog_filter		= 1;
+	i2c_init.digital_filter_coef	= 0;
+
+	ret = stm32_i2c_init(i2c, &i2c_init);
+	if (ret != 0) {
+		ERROR("Cannot initialize I2C %x (%d)\n",
+		      i2c->i2c_base_addr, ret);
+		panic();
+	}
+
+	if (!stm32_i2c_is_device_ready(i2c, i2c_addr, 1,
+				       I2C_TIMEOUT_BUSY_MS)) {
+		ERROR("I2C device not ready\n");
+		panic();
+	}
+
+	pmic2 = &pmic2_handle;
+	pmic2->i2c_handle = &i2c_handle;
+	pmic2->i2c_addr = i2c_addr;
+
+	return true;
+}
+
+static int pmic2_set_state(const struct regul_description *desc, bool enable)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+
+	VERBOSE("%s: set state to %d\n", desc->node_name, enable);
+
+	return stpmic2_regulator_set_state(pmic2, regul->id, enable);
+}
+
+static int pmic2_get_state(const struct regul_description *desc)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+	bool enabled;
+
+	VERBOSE("%s: get state\n", desc->node_name);
+
+	if (stpmic2_regulator_get_state(pmic2, regul->id, &enabled) < 0) {
+		panic();
+	}
+
+	return enabled;
+}
+
+static int pmic2_get_voltage(const struct regul_description *desc)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+	uint16_t mv;
+
+	VERBOSE("%s: get volt\n", desc->node_name);
+
+	if (regul->bypass_mv != 0U) {
+		int ret;
+
+		/* If the regul is in bypass mode, return bypass value */
+		ret = stpmic2_regulator_get_prop(pmic2, regul->id, STPMIC2_BYPASS);
+		if (ret < 0) {
+			return ret;
+		}
+
+		if (ret == 1) {
+			return regul->bypass_mv;
+		}
+	};
+
+	if (stpmic2_regulator_get_voltage(pmic2, regul->id, &mv) < 0) {
+		panic();
+	}
+
+	return mv;
+}
+
+static int pmic2_set_voltage(const struct regul_description *desc, uint16_t mv)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+
+	VERBOSE("%s: set volt\n", desc->node_name);
+
+	if (regul->bypass_mv != 0U) {
+		int ret;
+
+		/* If the regul is in bypass mode, authorize bypass mV */
+		ret = stpmic2_regulator_get_prop(pmic2, regul->id, STPMIC2_BYPASS);
+		if (ret < 0) {
+			return ret;
+		}
+
+		if ((ret == 1) && (mv != regul->bypass_mv)) {
+			return -EPERM;
+		}
+	};
+
+	return stpmic2_regulator_set_voltage(pmic2, regul->id, mv);
+}
+
+static int pmic2_list_voltages(const struct regul_description *desc,
+			       const uint16_t **levels, size_t *count)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+
+	VERBOSE("%s: list volt\n", desc->node_name);
+
+	if (regul->bypass_mv != 0U) {
+		int ret;
+
+		ret = stpmic2_regulator_get_prop(pmic2, regul->id, STPMIC2_BYPASS);
+		if (ret < 0) {
+			return ret;
+		}
+
+		/* bypass is enabled, return a list with only bypass mV */
+		if (ret == 1) {
+			if (count != NULL) {
+				*count = 1U;
+			}
+			if (levels != NULL) {
+				*levels = &regul->bypass_mv;
+			}
+			return 0;
+		}
+	};
+
+	return stpmic2_regulator_levels_mv(pmic2, regul->id, levels, count);
+}
+
+static int pmic2_set_flag(const struct regul_description *desc, uint16_t flag)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+	uint32_t id = regul->id;
+	int ret = -EPERM;
+
+	VERBOSE("%s: set_flag 0x%x\n", desc->node_name, flag);
+
+	switch (flag) {
+	case REGUL_PULL_DOWN:
+		ret = stpmic2_regulator_set_prop(pmic2, id, STPMIC2_PULL_DOWN, 1U);
+		break;
+	case REGUL_OCP:
+		ret = stpmic2_regulator_set_prop(pmic2, id, STPMIC2_OCP, 1U);
+		break;
+	case REGUL_SINK_SOURCE:
+		ret = stpmic2_regulator_set_prop(pmic2, id, STPMIC2_SINK_SOURCE, 1U);
+		break;
+	case REGUL_ENABLE_BYPASS:
+		ret = stpmic2_regulator_set_prop(pmic2, id, STPMIC2_BYPASS, 1U);
+		break;
+	case REGUL_MASK_RESET:
+		ret = stpmic2_regulator_set_prop(pmic2, id, STPMIC2_MASK_RESET, 1U);
+		break;
+	default:
+		ERROR("Invalid flag %u", flag);
+		panic();
+	}
+
+	if (ret != 0) {
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+int stpmic2_set_prop(const struct regul_description *desc, uint16_t prop, uint32_t value)
+{
+	struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+	int ret;
+
+	VERBOSE("%s: set_prop 0x%x val=%u\n", desc->node_name, prop, value);
+
+	ret = stpmic2_regulator_set_prop(pmic2, regul->id, prop, value);
+	if (ret != 0)
+		return -EPERM;
+
+	return 0;
+}
+
+static struct regul_ops pmic2_ops = {
+	.set_state = pmic2_set_state,
+	.get_state = pmic2_get_state,
+	.set_voltage = pmic2_set_voltage,
+	.get_voltage = pmic2_get_voltage,
+	.list_voltages = pmic2_list_voltages,
+	.set_flag = pmic2_set_flag,
+};
+
+#define DEFINE_PMIC_REGUL_HANDLE(rid) \
+[(rid)] = { \
+	.id = (rid), \
+}
+
+static struct regul_handle_s pmic2_regul_handles[STPMIC2_NB_REG] = {
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK1),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK2),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK3),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK4),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK5),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK6),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_BUCK7),
+
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO1),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO2),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO3),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO4),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO5),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO6),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO7),
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_LDO8),
+
+	DEFINE_PMIC_REGUL_HANDLE(STPMIC2_REFDDR),
+};
+
+#define DEFINE_REGUL(rid, name) \
+[rid] = { \
+	.node_name = name, \
+	.ops = &pmic2_ops, \
+	.driver_data = &pmic2_regul_handles[rid], \
+}
+
+static const struct regul_description pmic2_descs[STPMIC2_NB_REG] = {
+	DEFINE_REGUL(STPMIC2_BUCK1, "buck1"),
+	DEFINE_REGUL(STPMIC2_BUCK2, "buck2"),
+	DEFINE_REGUL(STPMIC2_BUCK3, "buck3"),
+	DEFINE_REGUL(STPMIC2_BUCK4, "buck4"),
+	DEFINE_REGUL(STPMIC2_BUCK5, "buck5"),
+	DEFINE_REGUL(STPMIC2_BUCK6, "buck6"),
+	DEFINE_REGUL(STPMIC2_BUCK7, "buck7"),
+
+	DEFINE_REGUL(STPMIC2_LDO1, "ldo1"),
+	DEFINE_REGUL(STPMIC2_LDO2, "ldo2"),
+	DEFINE_REGUL(STPMIC2_LDO3, "ldo3"),
+	DEFINE_REGUL(STPMIC2_LDO4, "ldo4"),
+	DEFINE_REGUL(STPMIC2_LDO5, "ldo5"),
+	DEFINE_REGUL(STPMIC2_LDO6, "ldo6"),
+	DEFINE_REGUL(STPMIC2_LDO7, "ldo7"),
+	DEFINE_REGUL(STPMIC2_LDO8, "ldo8"),
+
+	DEFINE_REGUL(STPMIC2_REFDDR, "refddr"),
+};
+
+static int register_pmic2(void)
+{
+	void *fdt;
+	int pmic_node, regulators_node, subnode;
+
+	VERBOSE("Register pmic2\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	pmic_node = dt_get_pmic_node(fdt);
+	if (pmic_node < 0) {
+		return pmic_node;
+	}
+
+	regulators_node = fdt_subnode_offset(fdt, pmic_node, "regulators");
+	if (regulators_node < 0) {
+		return -ENOENT;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, regulators_node) {
+		const char *reg_name = fdt_get_name(fdt, subnode, NULL);
+		const struct regul_description *desc;
+		unsigned int i;
+		int ret;
+		const fdt32_t *cuint;
+
+		for (i = 0; i < STPMIC2_NB_REG; i++) {
+			desc = &pmic2_descs[i];
+			if (strcmp(desc->node_name, reg_name) == 0) {
+				break;
+			}
+		}
+		assert(i < STPMIC2_NB_REG);
+
+		ret = regulator_register(desc, subnode);
+		if (ret != 0) {
+			WARN("%s:%d failed to register %s\n", __func__,
+			     __LINE__, reg_name);
+			return ret;
+		}
+
+		cuint = fdt_getprop(fdt, subnode, "st,regulator-bypass-microvolt", NULL);
+		if (cuint != NULL) {
+			struct regul_handle_s *regul = (struct regul_handle_s *)desc->driver_data;
+
+			regul->bypass_mv = (uint16_t)(fdt32_to_cpu(*cuint) / 1000U);
+			VERBOSE("%s: bypass voltage=%umV\n", desc->node_name,
+				regul->bypass_mv);
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,mask-reset", NULL)  != NULL) {
+			VERBOSE("%s: set mask-reset\n", desc->node_name);
+			ret = pmic2_set_flag(desc, REGUL_MASK_RESET);
+			if (ret != 0) {
+				ERROR("set mask-reset failed\n");
+				return ret;
+			}
+		}
+
+		if (fdt_getprop(fdt, subnode, "st,regulator-sink-source", NULL) != NULL) {
+			VERBOSE("%s: set regulator-sink-source\n", desc->node_name);
+			ret = pmic2_set_flag(desc, REGUL_SINK_SOURCE);
+			if (ret != 0) {
+				ERROR("set regulator-sink-source failed\n");
+				return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void initialize_pmic(void)
+{
+	int ret;
+	uint8_t val;
+
+	ret = initialize_pmic_i2c();
+	if (!ret) {
+		VERBOSE("No PMIC2\n");
+		return;
+	}
+
+	if (stpmic2_get_version(pmic2, &val) != 0) {
+		ERROR("Failed to access PMIC\n");
+		panic();
+	}
+	INFO("PMIC2 version = 0x%02x\n", val);
+
+	if (stpmic2_get_product_id(pmic2, &val) != 0) {
+		ERROR("Failed to access PMIC\n");
+		panic();
+	}
+	INFO("PMIC2 product ID = 0x%02x\n", val);
+
+	ret = register_pmic2();
+	if (ret < 0) {
+		ERROR("Register pmic2 failed\n");
+		panic();
+	}
+
+#if EVENT_LOG_LEVEL == LOG_LEVEL_VERBOSE
+	stpmic2_dump_regulators(pmic2);
+#endif
+
+	/* set LDO5 current limit to 200mA */
+	if (stpmic2_register_read(pmic2, NVM_LDOS_IOUT_SHR, &val) != 0) {
+		panic();
+	}
+
+	val |= 2U << LDO5_ILIM_SHIFT;
+
+	if (stpmic2_register_write(pmic2, NVM_LDOS_IOUT_SHR, val) != 0) {
+		panic();
+	}
+
+}
diff --git a/drivers/st/pmic/stpmic2.c b/drivers/st/pmic/stpmic2.c
new file mode 100644
index 0000000000..075f62dcf0
--- /dev/null
+++ b/drivers/st/pmic/stpmic2.c
@@ -0,0 +1,474 @@
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#include <common/debug.h>
+#include <drivers/st/stpmic2.h>
+
+#define RET_SUCCESS			0
+#define RET_ERROR_NOT_SUPPORTED		-1
+#define RET_ERROR_GENERIC		-2
+#define RET_ERROR_BAD_PARAMETERS	-3
+
+#define I2C_TIMEOUT_MS			25
+
+#define VOLTAGE_INDEX_INVALID		((size_t)~0U)
+
+struct regul_struct {
+	const char *name;
+	const uint16_t *volt_table;
+	uint8_t volt_table_size;
+	uint8_t volt_cr;
+	uint8_t volt_shift;
+	uint8_t en_cr;
+	uint8_t alt_en_cr;
+	uint8_t msrt_reg;
+	uint8_t msrt_mask;
+	uint8_t pd_reg;
+	uint8_t pd_val;
+	uint8_t ocp_reg;
+	uint8_t ocp_mask;
+};
+
+/* Voltage tables in mV */
+static const uint16_t buck1236_volt_table[] = {
+	500U, 510U, 520U, 530U, 540U, 550U, 560U, 570U, 580U, 590U,
+	600U, 610U, 620U, 630U, 640U, 650U, 660U, 670U, 680U, 690U,
+	700U, 710U, 720U, 730U, 740U, 750U, 760U, 770U, 780U, 790U,
+	800U, 810U, 820U, 830U, 840U, 850U, 860U, 870U, 880U, 890U,
+	900U, 910U, 920U, 930U, 940U, 950U, 960U, 970U, 980U, 990U,
+	1000U, 1010U, 1020U, 1030U, 1040U, 1050U, 1060U, 1070U, 1080U, 1090U,
+	1100U, 1110U, 1120U, 1130U, 1140U, 1150U, 1160U, 1170U, 1180U, 1190U,
+	1200U, 1210U, 1220U, 1230U, 1240U, 1250U, 1260U, 1270U, 1280U, 1290U,
+	1300U, 1310U, 1320U, 1330U, 1340U, 1350U, 1360U, 1370U, 1380U, 1390U,
+	1400U, 1410U, 1420U, 1430U, 1440U, 1450U, 1460U, 1470U, 1480U, 1490U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U
+};
+
+static const uint16_t buck457_volt_table[] = {
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U, 1500U,
+	1500U, 1600U, 1700U, 1800U, 1900U, 2000U, 2100U, 2200U, 2300U, 2400U,
+	2500U, 2600U, 2700U, 2800U, 2900U, 3000U, 3100U, 3200U, 3300U, 3400U,
+	3500U, 3600U, 3700U, 3800U, 3900U, 4000U, 4100U, 4200U
+};
+
+static const uint16_t ldo235678_volt_table[] = {
+	900U, 1000U, 1100U, 1200U, 1300U, 1400U, 1500U, 1600U, 1700U, 1800U,
+	1900U, 2000U, 2100U, 2200U, 2300U, 2400U, 2500U, 2600U, 2700U, 2800U,
+	2900U, 3000U, 3100U, 3200U, 3300U, 3400U, 3500U, 3600U, 3700U, 3800U,
+	3900U, 4000U
+};
+
+static const uint16_t ldo1_volt_table[] = {
+	1800U,
+};
+
+static const uint16_t ldo4_volt_table[] = {
+	3300U,
+};
+
+static const uint16_t refddr_volt_table[] = {
+	0,
+};
+
+#define DEFINE_BUCK(regu_name, ID, pd, table) { \
+	.name			= regu_name, \
+	.volt_table		= table, \
+	.volt_table_size	= ARRAY_SIZE(table), \
+	.en_cr			= ID ## _MAIN_CR2, \
+	.volt_cr		= ID ## _MAIN_CR1, \
+	.alt_en_cr		= ID ## _ALT_CR2, \
+	.msrt_reg		= BUCKS_MRST_CR, \
+	.msrt_mask		= ID ## _MRST, \
+	.pd_reg			= pd, \
+	.pd_val			= ID ## _PD_FAST, \
+	.ocp_reg		= FS_OCP_CR1, \
+	.ocp_mask		= FS_OCP_ ## ID, \
+}
+
+#define DEFINE_LDOx(regu_name, ID, table) { \
+	.name			= regu_name, \
+	.volt_table		= table, \
+	.volt_table_size	= ARRAY_SIZE(table), \
+	.volt_shift		= LDO_VOLT_SHIFT, \
+	.en_cr			= ID ## _MAIN_CR, \
+	.volt_cr		= ID ## _MAIN_CR, \
+	.alt_en_cr		= ID ## _ALT_CR, \
+	.msrt_reg		= LDOS_MRST_CR, \
+	.msrt_mask		= ID ## _MRST, \
+	.pd_reg			= LDOS_PD_CR1, \
+	.pd_val			= ID ## _PD, \
+	.ocp_reg		= FS_OCP_CR2, \
+	.ocp_mask		= FS_OCP_ ## ID, \
+}
+
+#define DEFINE_REFDDR(regu_name, ID, table) { \
+	.name			= regu_name, \
+	.volt_table		= table, \
+	.volt_table_size	= ARRAY_SIZE(table), \
+	.en_cr			= ID ## _MAIN_CR, \
+	.volt_cr		= ID ## _MAIN_CR, \
+	.alt_en_cr		= ID ## _ALT_CR, \
+	.msrt_reg		= BUCKS_MRST_CR, \
+	.msrt_mask		= ID ## _MRST, \
+	.pd_reg			= LDOS_PD_CR2, \
+	.pd_val			= ID ## _PD, \
+	.ocp_reg		= FS_OCP_CR1, \
+	.ocp_mask		= FS_OCP_ ## ID, \
+}
+
+/* Table of Regulators in PMIC SoC */
+static const struct regul_struct regul_table[STPMIC2_NB_REG] = {
+	[STPMIC2_BUCK1] = DEFINE_BUCK("buck1", BUCK1, BUCKS_PD_CR1,
+				      buck1236_volt_table),
+	[STPMIC2_BUCK2] = DEFINE_BUCK("buck2", BUCK2, BUCKS_PD_CR1,
+				      buck1236_volt_table),
+	[STPMIC2_BUCK3] = DEFINE_BUCK("buck3", BUCK3, BUCKS_PD_CR1,
+				      buck1236_volt_table),
+	[STPMIC2_BUCK4] = DEFINE_BUCK("buck4", BUCK4, BUCKS_PD_CR1,
+				      buck457_volt_table),
+	[STPMIC2_BUCK5] = DEFINE_BUCK("buck5", BUCK5, BUCKS_PD_CR2,
+				      buck457_volt_table),
+	[STPMIC2_BUCK6] = DEFINE_BUCK("buck6", BUCK6, BUCKS_PD_CR2,
+				      buck1236_volt_table),
+	[STPMIC2_BUCK7] = DEFINE_BUCK("buck7", BUCK7, BUCKS_PD_CR2,
+				      buck457_volt_table),
+
+	[STPMIC2_REFDDR] = DEFINE_REFDDR("refddr", REFDDR, refddr_volt_table),
+
+	[STPMIC2_LDO1] = DEFINE_LDOx("ldo1", LDO1, ldo1_volt_table),
+	[STPMIC2_LDO2] = DEFINE_LDOx("ldo2", LDO2, ldo235678_volt_table),
+	[STPMIC2_LDO3] = DEFINE_LDOx("ldo3", LDO3, ldo235678_volt_table),
+	[STPMIC2_LDO4] = DEFINE_LDOx("ldo4", LDO4, ldo4_volt_table),
+	[STPMIC2_LDO5] = DEFINE_LDOx("ldo5", LDO5, ldo235678_volt_table),
+	[STPMIC2_LDO6] = DEFINE_LDOx("ldo6", LDO6, ldo235678_volt_table),
+	[STPMIC2_LDO7] = DEFINE_LDOx("ldo7", LDO7, ldo235678_volt_table),
+	[STPMIC2_LDO8] = DEFINE_LDOx("ldo8", LDO8, ldo235678_volt_table),
+
+};
+
+int stpmic2_register_read(struct pmic_handle_s *pmic,
+			  uint8_t register_id, uint8_t *value)
+{
+	int ret = stm32_i2c_mem_read(pmic->i2c_handle,
+				     pmic->i2c_addr,
+				     (uint16_t)register_id,
+				     I2C_MEMADD_SIZE_8BIT, value,
+				     1, I2C_TIMEOUT_MS);
+	if (ret != 0) {
+		ERROR("Failed to read reg:0x%x\n", register_id);
+	}
+
+	return ret;
+}
+
+int stpmic2_register_write(struct pmic_handle_s *pmic,
+			   uint8_t register_id, uint8_t value)
+{
+	uint8_t val = value;
+	int ret = stm32_i2c_mem_write(pmic->i2c_handle,
+				      pmic->i2c_addr,
+				      (uint16_t)register_id,
+				      I2C_MEMADD_SIZE_8BIT, &val,
+				      1, I2C_TIMEOUT_MS);
+	if (ret != 0) {
+		ERROR("Failed to write reg:0x%x\n", register_id);
+	}
+
+	return ret;
+}
+
+int stpmic2_register_update(struct pmic_handle_s *pmic,
+			    uint8_t register_id, uint8_t value, uint8_t mask)
+{
+	int status;
+	uint8_t val = 0U;
+
+	status = stpmic2_register_read(pmic, register_id, &val);
+	if (status != 0) {
+		return status;
+	}
+
+	val = (val & ((uint8_t)~mask)) | (value & mask);
+
+	VERBOSE("REG:0x%x v=0x%x mask=0x%x -> 0x%x\n",
+		register_id, value, mask, val);
+
+	return stpmic2_register_write(pmic, register_id, val);
+}
+
+int stpmic2_regulator_set_state(struct pmic_handle_s *pmic,
+				uint8_t id, bool enable)
+{
+	const struct regul_struct *regul = &regul_table[id];
+
+	if (enable) {
+		return stpmic2_register_update(pmic, regul->en_cr, 1U, 1U);
+	} else {
+		return stpmic2_register_update(pmic, regul->en_cr, 0, 1U);
+	}
+}
+
+int stpmic2_regulator_get_state(struct pmic_handle_s *pmic,
+				uint8_t id, bool *enabled)
+{
+	const struct regul_struct *regul = &regul_table[id];
+	uint8_t val;
+
+	if (stpmic2_register_read(pmic, regul->en_cr, &val) != 0) {
+		return RET_ERROR_GENERIC;
+	}
+
+	*enabled = (val & 1U) == 1U;
+
+	return RET_SUCCESS;
+}
+
+int stpmic2_regulator_levels_mv(struct pmic_handle_s *pmic,
+				uint8_t id, const uint16_t **levels,
+				size_t *levels_count)
+{
+	const struct regul_struct *regul = &regul_table[id];
+
+	if (regul == NULL) {
+		return RET_ERROR_BAD_PARAMETERS;
+	}
+
+	if (levels_count != NULL) {
+		*levels_count = regul->volt_table_size;
+	}
+	if (levels != NULL) {
+		*levels = regul->volt_table;
+	}
+
+	return RET_SUCCESS;
+}
+
+int stpmic2_regulator_get_voltage(struct pmic_handle_s *pmic,
+				  uint8_t id, uint16_t *val)
+{
+	const struct regul_struct *regul = &regul_table[id];
+	uint8_t value = 0U;
+	uint8_t mask;
+
+	if (regul->volt_table_size == 0U) {
+		return RET_ERROR_GENERIC;
+	}
+
+	mask = regul->volt_table_size - 1U;
+	if (mask != 0U) {
+		if (stpmic2_register_read(pmic, regul->volt_cr, &value) != 0) {
+			return RET_ERROR_GENERIC;
+		}
+
+		value = (value >> regul->volt_shift) & mask;
+	}
+
+	if (value > regul->volt_table_size) {
+		return RET_ERROR_GENERIC;
+	}
+
+	*val = regul->volt_table[value];
+
+	return RET_SUCCESS;
+}
+
+static size_t voltage_to_index(const struct regul_struct *regul,
+			       uint16_t millivolts)
+{
+	unsigned int i;
+
+	assert(regul->volt_table);
+	for (i = 0U; i < regul->volt_table_size; i++) {
+		if (regul->volt_table[i] == millivolts) {
+			return i;
+		}
+	}
+
+	return VOLTAGE_INDEX_INVALID;
+}
+
+int stpmic2_regulator_set_voltage(struct pmic_handle_s *pmic,
+				  uint8_t id, uint16_t millivolts)
+{
+	const struct regul_struct *regul = &regul_table[id];
+	size_t index;
+	uint8_t mask;
+
+	if (!regul->volt_table_size) {
+		return RET_SUCCESS;
+	}
+
+	mask = regul->volt_table_size - 1U;
+
+	index = voltage_to_index(regul, millivolts);
+	if (index == VOLTAGE_INDEX_INVALID) {
+		return RET_ERROR_GENERIC;
+	}
+
+	return stpmic2_register_update(pmic, regul->volt_cr,
+				       index << regul->volt_shift,
+				       mask << regul->volt_shift);
+}
+
+/* update both normal and alternate register */
+static int stpmic2_update_en_crs(struct pmic_handle_s *pmic, uint8_t id,
+				 uint8_t value, uint8_t mask)
+{
+	const struct regul_struct *regul = &regul_table[id];
+
+	if (stpmic2_register_update(pmic, regul->en_cr, value, mask) != 0) {
+		return RET_ERROR_GENERIC;
+	}
+
+	if (stpmic2_register_update(pmic, regul->alt_en_cr, value, mask) != 0) {
+		return RET_ERROR_GENERIC;
+	}
+
+	return RET_SUCCESS;
+}
+
+int stpmic2_regulator_get_prop(struct pmic_handle_s *pmic, uint8_t id,
+			       enum stpmic2_prop_id prop)
+{
+	const struct regul_struct *regul = &regul_table[id];
+	uint8_t val;
+
+	VERBOSE("%s: get prop 0x%x\n", regul->name, prop);
+
+	switch (prop) {
+	case STPMIC2_BYPASS:
+		if ((id <= STPMIC2_BUCK7) || (id == STPMIC2_LDO1) ||
+		    (id == STPMIC2_LDO4) || (id == STPMIC2_REFDDR)) {
+			return 0;
+		}
+
+		if (stpmic2_register_read(pmic, regul->en_cr, &val) != 0) {
+			return -EIO;
+		}
+
+		if ((val & LDO_BYPASS) != 0) {
+			return 1;
+		}
+
+		break;
+	default:
+		ERROR("Invalid prop %u\n", prop);
+		panic();
+	}
+
+	return 0;
+}
+
+int stpmic2_regulator_set_prop(struct pmic_handle_s *pmic, uint8_t id,
+			       enum stpmic2_prop_id prop, uint32_t arg)
+{
+	const struct regul_struct *regul = &regul_table[id];
+
+	VERBOSE("%s: set prop 0x%x arg=%u\n", regul->name, prop, arg);
+
+	switch (prop) {
+	case STPMIC2_PULL_DOWN:
+		return stpmic2_register_update(pmic, regul->pd_reg,
+					       regul->pd_val,
+					       regul->pd_val);
+	case STPMIC2_MASK_RESET:
+		if (!regul->msrt_mask) {
+			return RET_ERROR_NOT_SUPPORTED;
+		}
+		/* enable mask reset */
+		return stpmic2_register_update(pmic, regul->msrt_reg,
+					       regul->msrt_mask,
+					       regul->msrt_mask);
+	case STPMIC2_BYPASS:
+		if ((id <= STPMIC2_BUCK7) || (id == STPMIC2_LDO1) ||
+		    (id == STPMIC2_LDO4) || (id == STPMIC2_REFDDR)) {
+			return RET_ERROR_NOT_SUPPORTED;
+		}
+
+		/* clear sink source mode */
+		if ((id == STPMIC2_LDO3) && (arg != 0U)) {
+			if (stpmic2_update_en_crs(pmic, id, 0, LDO3_SNK_SRC) != 0) {
+				return RET_ERROR_GENERIC;
+			}
+		}
+
+		/* enable bypass mode */
+		return stpmic2_update_en_crs(pmic, id,
+					     (arg != 0U) ? LDO_BYPASS : 0,
+					     LDO_BYPASS);
+	case STPMIC2_SINK_SOURCE:
+		if (id != STPMIC2_LDO3) {
+			return RET_ERROR_NOT_SUPPORTED;
+		}
+
+		/* clear bypass mode */
+		if (stpmic2_update_en_crs(pmic, id, 0, LDO_BYPASS) != 0) {
+			return RET_ERROR_GENERIC;
+		}
+
+		return stpmic2_update_en_crs(pmic, id, LDO3_SNK_SRC,
+					     LDO3_SNK_SRC);
+	case STPMIC2_OCP:
+		return stpmic2_register_update(pmic, regul->ocp_reg,
+					       regul->ocp_mask,
+					       regul->ocp_mask);
+	default:
+		ERROR("Invalid prop %u\n", prop);
+		panic();
+	}
+
+	return -EPERM;
+}
+
+#if EVENT_LOG_LEVEL == LOG_LEVEL_VERBOSE
+void stpmic2_dump_regulators(struct pmic_handle_s *pmic)
+{
+	size_t i;
+	char const *name;
+
+	for (i = 0U; i < ARRAY_SIZE(regul_table); i++) {
+		uint16_t val;
+		bool state;
+
+		if (!regul_table[i].volt_cr) {
+			continue;
+		}
+
+		stpmic2_regulator_get_voltage(pmic, i, &val);
+		stpmic2_regulator_get_state(pmic, i, &state);
+
+		name = regul_table[i].name;
+
+		VERBOSE("PMIC regul %s: %s, %dmV\n",
+			name, state ? "EN" : "DIS", val);
+	}
+}
+#endif
+
+int stpmic2_get_version(struct pmic_handle_s *pmic, uint8_t *val)
+{
+	return stpmic2_register_read(pmic, VERSION_SR, val);
+}
+
+int stpmic2_get_product_id(struct pmic_handle_s *pmic, uint8_t *val)
+{
+	return stpmic2_register_read(pmic, PRODUCT_ID, val);
+}
diff --git a/drivers/st/regulator/regulator_core.c b/drivers/st/regulator/regulator_core.c
index 5cc832915f..b369acdbb4 100644
--- a/drivers/st/regulator/regulator_core.c
+++ b/drivers/st/regulator/regulator_core.c
@@ -17,14 +17,16 @@
 
 #define MAX_PROPERTY_LEN 64
 
+CASSERT(PLAT_NB_RDEVS >= 1U, plat_nb_rdevs_must_be_higher);
+
 static struct rdev rdev_array[PLAT_NB_RDEVS];
 
 #define for_each_rdev(rdev) \
-	for (rdev = rdev_array; rdev < (rdev_array + PLAT_NB_RDEVS); rdev++)
+	for ((rdev) = rdev_array; (rdev) <= &rdev_array[PLAT_NB_RDEVS - 1U]; (rdev)++)
 
 #define for_each_registered_rdev(rdev) \
-	for (rdev = rdev_array; \
-	     (rdev < (rdev_array + PLAT_NB_RDEVS)) && (rdev->desc != NULL); rdev++)
+	for ((rdev) = rdev_array; \
+	     ((rdev) <= &rdev_array[PLAT_NB_RDEVS - 1U]) && ((rdev)->desc != NULL); (rdev)++)
 
 static void lock_driver(const struct rdev *rdev)
 {
@@ -86,7 +88,7 @@ static int32_t get_supply_phandle(const void *fdt, int node, const char *name)
 	char prop_name[MAX_PROPERTY_LEN];
 
 	len = snprintf(prop_name, MAX_PROPERTY_LEN - 1, "%s-supply", name);
-	assert((len >= 0) && (len < MAX_PROPERTY_LEN - 1));
+	assert((len >= 0) && (len < (MAX_PROPERTY_LEN - 1)));
 
 	cuint = fdt_getprop(fdt, node, prop_name, NULL);
 	if (cuint != NULL) {
@@ -156,7 +158,7 @@ int regulator_disable(struct rdev *rdev)
 
 	assert(rdev != NULL);
 
-	if (rdev->flags & REGUL_ALWAYS_ON) {
+	if ((rdev->flags & REGUL_ALWAYS_ON) != 0U) {
 		return 0;
 	}
 
@@ -213,14 +215,18 @@ int regulator_set_voltage(struct rdev *rdev, uint16_t mvolt)
 
 	VERBOSE("%s: set mvolt\n", rdev->desc->node_name);
 
-	if (rdev->desc->ops->set_voltage == NULL) {
-		return -ENODEV;
-	}
-
 	if ((mvolt < rdev->min_mv) || (mvolt > rdev->max_mv)) {
 		return -EPERM;
 	}
 
+	if (regulator_get_voltage(rdev) == mvolt) {
+		return 0U;
+	}
+
+	if (rdev->desc->ops->set_voltage == NULL) {
+		return -ENODEV;
+	}
+
 	lock_driver(rdev);
 
 	ret = rdev->desc->ops->set_voltage(rdev->desc, mvolt);
@@ -418,6 +424,7 @@ int regulator_set_flag(struct rdev *rdev, uint16_t flag)
 
 static int parse_properties(const void *fdt, struct rdev *rdev, int node)
 {
+	const fdt32_t *cuint;
 	int ret;
 
 	if (fdt_getprop(fdt, node, "regulator-always-on", NULL) != NULL) {
@@ -428,6 +435,13 @@ static int parse_properties(const void *fdt, struct rdev *rdev, int node)
 		}
 	}
 
+	cuint = fdt_getprop(fdt, node, "regulator-enable-ramp-delay", NULL);
+	if (cuint != NULL) {
+		rdev->enable_ramp_delay = fdt32_to_cpu(*cuint);
+		VERBOSE("%s: enable_ramp_delay=%u\n", rdev->desc->node_name,
+			rdev->enable_ramp_delay);
+	}
+
 	return 0;
 }
 
@@ -525,7 +539,7 @@ int regulator_register(const struct regul_description *desc, int node)
 		}
 	}
 
-	if (rdev == rdev_array + PLAT_NB_RDEVS) {
+	if (rdev > &rdev_array[PLAT_NB_RDEVS - 1U]) {
 		WARN("Not enough place for regulators, PLAT_NB_RDEVS should be increased.\n");
 		return -ENOMEM;
 	}
diff --git a/drivers/st/regulator/regulator_fixed.c b/drivers/st/regulator/regulator_fixed.c
index f1c224e04d..e4a44910a8 100644
--- a/drivers/st/regulator/regulator_fixed.c
+++ b/drivers/st/regulator/regulator_fixed.c
@@ -13,19 +13,18 @@
 #include <drivers/st/regulator_fixed.h>
 #include <libfdt.h>
 
-#ifndef PLAT_NB_FIXED_REGS
-#error "Missing PLAT_NB_FIXED_REGS"
+#ifndef PLAT_NB_FIXED_REGUS
+#error "Missing PLAT_NB_FIXED_REGUS"
 #endif
 
 #define FIXED_NAME_LEN 32
 
 struct fixed_data {
 	char name[FIXED_NAME_LEN];
-	uint16_t volt;
 	struct regul_description desc;
 };
 
-static struct fixed_data data[PLAT_NB_FIXED_REGS];
+static struct fixed_data data[PLAT_NB_FIXED_REGUS];
 
 static int fixed_set_state(const struct regul_description *desc, bool state)
 {
@@ -79,7 +78,7 @@ int fixed_regulator_register(void)
 		}
 
 		count++;
-		assert(count <= PLAT_NB_FIXED_REGS);
+		assert(count <= PLAT_NB_FIXED_REGUS);
 
 	}
 
diff --git a/drivers/st/regulator/regulator_gpio.c b/drivers/st/regulator/regulator_gpio.c
new file mode 100644
index 0000000000..ebddb0f6eb
--- /dev/null
+++ b/drivers/st/regulator/regulator_gpio.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/st/regulator.h>
+#include <drivers/st/regulator_gpio.h>
+#include <drivers/st/stm32_gpio.h>
+#include <libfdt.h>
+
+#ifndef PLAT_NB_GPIO_REGUS
+#error "Missing PLAT_NB_GPIO_REGUS"
+#endif
+
+#define MAX_NAME_LEN 32
+
+#define REGU_DISABLED 0
+#define REGU_ENABLED 1
+
+#define GPIO_DESC_SIZE 3U
+
+struct gpio_config {
+	uint32_t bank;
+	uint32_t pin;
+	uint32_t config;
+	uint8_t status;
+};
+
+struct gpio_regu_data {
+	char name[MAX_NAME_LEN];
+	struct regul_description desc;
+	struct gpio_config en_gpio;
+	bool active_high;
+};
+
+static struct gpio_regu_data data[PLAT_NB_GPIO_REGUS];
+
+static int gpio_set_state(const struct regul_description *desc, bool state)
+{
+	struct gpio_regu_data *d = (struct gpio_regu_data *)desc->driver_data;
+	enum gpio_level level = GPIO_LEVEL_LOW;
+
+	VERBOSE("regul %s set state=%d\n", d->name, state);
+
+	if ((d->active_high && state) || (!d->active_high && !state)) {
+		level = GPIO_LEVEL_HIGH;
+	}
+
+	set_gpio_level(d->en_gpio.bank, d->en_gpio.pin, level);
+
+	return 0;
+}
+
+static int gpio_get_state(const struct regul_description *desc)
+{
+	struct gpio_regu_data *d = (struct gpio_regu_data *)desc->driver_data;
+	enum gpio_level level = get_gpio_level(d->en_gpio.bank, d->en_gpio.pin);
+
+	if ((d->active_high && level == GPIO_LEVEL_HIGH) ||
+	    (!d->active_high && level == GPIO_LEVEL_LOW)) {
+		return REGU_ENABLED;
+	}
+
+	return REGU_DISABLED;
+}
+
+static struct regul_ops gpio_regu_ops = {
+	.set_state = gpio_set_state,
+	.get_state = gpio_get_state,
+};
+
+static int read_gpio_config_from_dt(const void *fdt, int node, char *name,
+				    struct gpio_config *gpio)
+{
+	uint32_t utable[GPIO_DESC_SIZE];
+	int ret;
+
+	gpio->status = fdt_get_status(node);
+	if (gpio->status == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_read_uint32_array(fdt, node, name, GPIO_DESC_SIZE, utable);
+	if (ret != 0) {
+		ERROR("Missing gpio description\n");
+		return ret;
+	}
+
+	gpio->bank = utable[0];
+	gpio->pin = utable[1];
+	gpio->config = utable[2];
+
+	return 0;
+}
+
+int gpio_regulator_register(void)
+{
+	uint32_t count = 0U;
+	void *fdt;
+	int node = 0;
+
+	VERBOSE("gpio_regu reg init\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	do {
+		int len __unused;
+		int ret;
+		struct gpio_regu_data *d = &data[count];
+		const char *reg_name;
+
+		node = fdt_node_offset_by_compatible(fdt, node, "st,stm32-regulator-gpio");
+		if (node < 0) {
+			break;
+		}
+
+		reg_name = fdt_get_name(fdt, node, NULL);
+
+		VERBOSE("register gpio_regu reg %s\n", reg_name);
+
+		if (count == PLAT_NB_GPIO_REGUS) {
+			WARN("Not enough place for regulators, PLAT_NB_GPIO_REGUS should be increased.\n");
+			return -ENOMEM;
+		}
+
+		len = snprintf(d->name, MAX_NAME_LEN - 1, "%s", reg_name);
+		assert((len > 0) && (len < (MAX_NAME_LEN - 1)));
+
+		d->desc.node_name = d->name;
+		d->desc.driver_data = d;
+		d->desc.ops = &gpio_regu_ops;
+
+		ret = read_gpio_config_from_dt(fdt, node, "st,enable-gpios", &d->en_gpio);
+		if (ret != 0) {
+			ERROR("Incorrect gpio regul description\n");
+			return ret;
+		}
+
+		VERBOSE("%s: en_gpio bank=%u pin=%u cfg=%x\n", d->name,
+			d->en_gpio.bank, d->en_gpio.pin, d->en_gpio.config);
+
+		set_gpio_config(d->en_gpio.bank, d->en_gpio.pin, d->en_gpio.config,
+				d->en_gpio.status);
+
+		if (fdt_getprop(fdt, node, "enable-active-high", NULL))
+			d->active_high = true;
+
+		ret = regulator_register(&d->desc, node);
+		if (ret != 0) {
+			WARN("Failed to register %s\n", reg_name);
+			return ret;
+		}
+
+		count++;
+	} while (node > 0);
+
+	return 0;
+}
diff --git a/drivers/st/reset/stm32mp1_reset.c b/drivers/st/reset/stm32mp1_reset.c
index 98c8dcf710..435d6ed1ea 100644
--- a/drivers/st/reset/stm32mp1_reset.c
+++ b/drivers/st/reset/stm32mp1_reset.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -67,3 +67,16 @@ int stm32mp_reset_deassert(uint32_t id, unsigned int to_us)
 
 	return 0;
 }
+
+void __dead2 stm32mp_system_reset(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	mmio_setbits_32(rcc_base + RCC_MP_GRSTCSETR,
+			RCC_MP_GRSTCSETR_MPSYSRST);
+
+	/* Loop in case system reset is not immediately caught */
+	for ( ; ; ) {
+		;
+	}
+}
diff --git a/drivers/st/reset/stm32mp2_reset.c b/drivers/st/reset/stm32mp2_reset.c
new file mode 100644
index 0000000000..435415f1b2
--- /dev/null
+++ b/drivers/st/reset/stm32mp2_reset.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+#include <stdbool.h>
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+static uint32_t id2reg_offset(unsigned int reset_id)
+{
+	return ((reset_id & GENMASK(31, 5)) >> 5) * sizeof(uint32_t);
+}
+
+static uint8_t id2reg_bit_pos(unsigned int reset_id)
+{
+	return (uint8_t)(reset_id & GENMASK(4, 0));
+}
+
+static int reset_toggle(uint32_t id, unsigned int to_us, bool reset_status)
+{
+	uint32_t offset = id2reg_offset(id);
+	uint32_t bitmsk = BIT(id2reg_bit_pos(id));
+	uint32_t bit_check;
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	if (reset_status) {
+		mmio_setbits_32(rcc_base + offset, bitmsk);
+		bit_check = bitmsk;
+	} else {
+		mmio_clrbits_32(rcc_base + offset, bitmsk);
+		bit_check = 0U;
+	}
+
+	if (to_us != 0U) {
+		uint64_t timeout_ref = timeout_init_us(to_us);
+
+		while ((mmio_read_32(rcc_base + offset) & bitmsk) != bit_check) {
+			if (timeout_elapsed(timeout_ref)) {
+				return -ETIMEDOUT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int stm32mp_reset_assert(uint32_t id, unsigned int to_us)
+{
+	return reset_toggle(id, to_us, true);
+}
+
+int stm32mp_reset_deassert(uint32_t id, unsigned int to_us)
+{
+	return reset_toggle(id, to_us, false);
+}
+
+void __dead2 stm32mp_system_reset(void)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	mmio_setbits_32(rcc_base + RCC_GRSTCSETR, RCC_GRSTCSETR_SYSRST);
+
+	/* Loop in case system reset is not immediately caught */
+	for ( ; ; ) {
+		;
+	}
+}
diff --git a/drivers/st/rif/stm32_rifsc.c b/drivers/st/rif/stm32_rifsc.c
new file mode 100644
index 0000000000..b0430bb095
--- /dev/null
+++ b/drivers/st/rif/stm32_rifsc.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+#include <stdint.h>
+
+#include <arch_helpers.h>
+#include <drivers/st/stm32_rifsc.h>
+#include <dt-bindings/soc/rif.h>
+#include <lib/mmio.h>
+
+#include <platform_def.h>
+
+/* RIFSC general register field description */
+/* RIFSC_CIDCFGR register fields */
+#define _RIFSC_RISC_CIDCFGR(x)		(U(0x100) + U(0x8) * (x))
+#define _RIFSC_RISC_CFEN_MASK		BIT(0)
+#define _RIFSC_RISC_SEM_EN_MASK		BIT(1)
+#define _RIFSC_RISC_SEML_SHIFT		U(16)
+#define _RIFSC_RISC_SEML_MASK		GENMASK_32(23, 16)
+
+/* RIFSC_SEMCR register fields */
+#define _RIFSC_RISC_SEMCR(x)		(U(0x104) + U(0x8) * (x))
+#define _RIFSC_RISC_SEM_MUTEX		BIT(0)
+#define _RIFSC_RISC_SEMCID_SHIFT	U(4)
+#define _RIFSC_RISC_SEMCID_MASK		GENMASK_32(6, 4)
+
+static unsigned long rifsc_semaphores[] = {
+	STM32MP25_RIFSC_RNG_ID,
+	STM32MP25_RIFSC_PKA_ID,
+	STM32MP25_RIFSC_SAES_ID,
+};
+
+int stm32_rifsc_semaphore_init(void)
+{
+	unsigned long i = 0;
+
+	for (i = 0; i < ARRAY_SIZE(rifsc_semaphores); i++) {
+		uint32_t cidcfgr = mmio_read_32(RIFSC_BASE +
+						_RIFSC_RISC_CIDCFGR(rifsc_semaphores[i]));
+		uint32_t semcfgr = mmio_read_32(RIFSC_BASE +
+						_RIFSC_RISC_SEMCR(rifsc_semaphores[i]));
+
+		if (!(((cidcfgr & _RIFSC_RISC_CFEN_MASK) != 0U) &&
+		      ((cidcfgr & _RIFSC_RISC_SEM_EN_MASK) != 0U) &&
+		      ((cidcfgr & _RIFSC_RISC_SEML_MASK) >> _RIFSC_RISC_SEML_SHIFT) != RIF_CID1)) {
+			continue;
+		}
+
+		if (((semcfgr & _RIFSC_RISC_SEM_MUTEX) != 0U) &&
+		    ((semcfgr & _RIFSC_RISC_SEMCID_MASK) >> _RIFSC_RISC_SEMCID_SHIFT) != RIF_CID1) {
+			return -EACCES;
+		}
+
+		mmio_write_32(RIFSC_BASE + _RIFSC_RISC_SEMCR(rifsc_semaphores[i]),
+			      _RIFSC_RISC_SEM_MUTEX);
+
+		if (((semcfgr & _RIFSC_RISC_SEM_MUTEX) != 0U) &&
+		    ((semcfgr & _RIFSC_RISC_SEMCID_MASK) >> _RIFSC_RISC_SEMCID_SHIFT) != RIF_CID1) {
+			return -EACCES;
+		}
+	}
+
+	return 0;
+}
diff --git a/drivers/st/rif/stm32mp2_risaf.c b/drivers/st/rif/stm32mp2_risaf.c
new file mode 100644
index 0000000000..121c172b17
--- /dev/null
+++ b/drivers/st/rif/stm32mp2_risaf.c
@@ -0,0 +1,675 @@
+/*
+ * Copyright (c) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/stm32mp2_risaf.h>
+#include <dt-bindings/soc/rif.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <plat/common/platform.h>
+#include <stm32mp_fconf_getter.h>
+
+/* RISAF general registers (base relative) */
+#define _RISAF_CR			U(0x00)
+#define _RISAF_SR			U(0x04)
+#define _RISAF_KEYR			U(0x30)
+#define _RISAF_HWCFGR			U(0xFF0)
+
+/* RISAF general register field description */
+/* _RISAF_CR register fields */
+#define _RISAF_CR_GLOCK			BIT(0)
+/* _RISAF_SR register fields */
+#define _RISAF_SR_KEYVALID		BIT(0)
+#define _RISAF_SR_KEYRDY		BIT(1)
+#define _RISAF_SR_ENCDIS		BIT(2)
+/* _RISAF_HWCFGR register fields */
+#define _RISAF_HWCFGR_CFG1_SHIFT	0
+#define _RISAF_HWCFGR_CFG1_MASK		GENMASK_32(7, 0)
+#define _RISAF_HWCFGR_CFG2_SHIFT	8
+#define _RISAF_HWCFGR_CFG2_MASK		GENMASK_32(15, 8)
+#define _RISAF_HWCFGR_CFG3_SHIFT	16
+#define _RISAF_HWCFGR_CFG3_MASK		GENMASK_32(23, 16)
+#define _RISAF_HWCFGR_CFG4_SHIFT	24
+#define _RISAF_HWCFGR_CFG4_MASK		GENMASK_32(31, 24)
+
+/* RISAF region registers (base relative) */
+#define _RISAF_REG_BASE			U(0x40)
+#define _RISAF_REG_SIZE			U(0x40)
+#define _RISAF_REG(n)			(_RISAF_REG_BASE + (((n) - 1) * _RISAF_REG_SIZE))
+#define _RISAF_REG_CFGR_OFFSET		U(0x0)
+#define _RISAF_REG_CFGR(n)		(_RISAF_REG(n) + _RISAF_REG_CFGR_OFFSET)
+#define _RISAF_REG_STARTR_OFFSET	U(0x4)
+#define _RISAF_REG_STARTR(n)		(_RISAF_REG(n) + _RISAF_REG_STARTR_OFFSET)
+#define _RISAF_REG_ENDR_OFFSET		U(0x8)
+#define _RISAF_REG_ENDR(n)		(_RISAF_REG(n) + _RISAF_REG_ENDR_OFFSET)
+#define _RISAF_REG_CIDCFGR_OFFSET	U(0xC)
+#define _RISAF_REG_CIDCFGR(n)		(_RISAF_REG(n) + _RISAF_REG_CIDCFGR_OFFSET)
+
+/* RISAF region register field description */
+/* _RISAF_REG_CFGR(n) register fields */
+#define _RISAF_REG_CFGR_BREN_SHIFT	0
+#define _RISAF_REG_CFGR_BREN		BIT(_RISAF_REG_CFGR_BREN_SHIFT)
+#define _RISAF_REG_CFGR_SEC_SHIFT	8
+#define _RISAF_REG_CFGR_SEC		BIT(_RISAF_REG_CFGR_SEC_SHIFT)
+#define _RISAF_REG_CFGR_ENC_SHIFT	15
+#define _RISAF_REG_CFGR_ENC		BIT(_RISAF_REG_CFGR_ENC_SHIFT)
+#define _RISAF_REG_CFGR_PRIVC_SHIFT	16
+#define _RISAF_REG_CFGR_PRIVC_MASK	GENMASK_32(23, 16)
+#define _RISAF_REG_CFGR_ALL_MASK	(_RISAF_REG_CFGR_BREN | _RISAF_REG_CFGR_SEC | \
+					 _RISAF_REG_CFGR_ENC | _RISAF_REG_CFGR_PRIVC_MASK)
+/* _RISAF_REG_CIDCFGR(n) register fields */
+#define _RISAF_REG_CIDCFGR_RDENC_SHIFT		0
+#define _RISAF_REG_CIDCFGR_RDENC_MASK		GENMASK_32(7, 0)
+#define _RISAF_REG_CIDCFGR_WRENC_SHIFT		16
+#define _RISAF_REG_CIDCFGR_WRENC_MASK		GENMASK_32(23, 16)
+#define _RISAF_REG_CIDCFGR_ALL_MASK		(_RISAF_REG_CIDCFGR_RDENC_MASK | \
+						 _RISAF_REG_CIDCFGR_WRENC_MASK)
+
+/* Device Tree related definitions */
+#define DT_RISAF_COMPAT			"st,stm32-risaf"
+#define DT_RISAF_REG_ID_MASK		U(0xF)
+#define DT_RISAF_EN_SHIFT		4
+#define DT_RISAF_EN_MASK		BIT(DT_RISAF_EN_SHIFT)
+#define DT_RISAF_SEC_SHIFT		5
+#define DT_RISAF_SEC_MASK		BIT(DT_RISAF_SEC_SHIFT)
+#define DT_RISAF_ENC_SHIFT		6
+#define DT_RISAF_ENC_MASK		GENMASK_32(7, DT_RISAF_ENC_SHIFT)
+#define DT_RISAF_PRIV_SHIFT		8
+#define DT_RISAF_PRIV_MASK		GENMASK_32(15, 8)
+#define DT_RISAF_READ_SHIFT		16
+#define DT_RISAF_READ_MASK		GENMASK_32(23, 16)
+#define DT_RISAF_WRITE_SHIFT		24
+#define DT_RISAF_WRITE_MASK		GENMASK_32(31, 24)
+
+/* RISAF max properties */
+#define RISAF_REGION_REG_SIZE		(4 * sizeof(uint32_t))
+#define RISAF_REGION_PROTREG_SIZE	(1 * sizeof(uint32_t))
+#define RISAF_TIMEOUT_1MS_IN_US		U(1000)
+
+#pragma weak stm32_risaf_get_instance
+#pragma weak stm32_risaf_get_base
+#pragma weak stm32_risaf_get_max_region
+#pragma weak stm32_risaf_get_memory_base
+#pragma weak stm32_risaf_get_memory_size
+
+struct stm32mp2_risaf_region {
+	int instance;
+	uint32_t cfg;
+	uintptr_t addr;
+	size_t len;
+};
+
+struct stm32mp2_risaf_platdata {
+	uintptr_t *base;
+	unsigned long *clock;
+	uint32_t *granularity;
+	struct stm32mp2_risaf_region *region;
+	int nregions;
+};
+
+static struct stm32mp2_risaf_platdata stm32mp2_risaf;
+static int region_per_instance[RISAF_MAX_INSTANCE];
+
+int stm32_risaf_get_instance(uintptr_t base)
+{
+	return -ENODEV;
+}
+
+uintptr_t stm32_risaf_get_base(int instance)
+{
+	return 0U;
+}
+
+int stm32_risaf_get_max_region(int instance)
+{
+	return -ENODEV;
+}
+
+uintptr_t stm32_risaf_get_memory_base(int instance)
+{
+	return 0U;
+}
+
+size_t stm32_risaf_get_memory_size(int instance)
+{
+	return 0U;
+}
+
+#if ENABLE_ASSERTIONS
+static bool valid_protreg_id(int instance, uint32_t id)
+{
+	uint32_t max_id;
+
+	max_id = mmio_read_32(stm32mp2_risaf.base[instance] + _RISAF_HWCFGR);
+	max_id = (max_id & _RISAF_HWCFGR_CFG1_MASK) >> _RISAF_HWCFGR_CFG1_SHIFT;
+
+	return id < max_id;
+}
+
+static bool valid_instance(int instance)
+{
+	return (instance < RISAF_MAX_INSTANCE) && (stm32mp2_risaf.base[instance] != 0U);
+}
+#endif
+
+static bool risaf_is_hw_encryption_functional(int instance)
+{
+	return (mmio_read_32(stm32mp2_risaf.base[instance] + _RISAF_SR) & _RISAF_SR_ENCDIS) !=
+	       _RISAF_SR_ENCDIS;
+}
+
+static int check_region_boundaries(int instance, uintptr_t addr, size_t len)
+{
+	uintptr_t end_address;
+	uintptr_t mem_base = stm32_risaf_get_memory_base(instance);
+
+	if ((addr < mem_base) || (len == 0U)) {
+		return -EINVAL;
+	}
+
+	/* Get physical end address */
+	end_address = mem_base + stm32_risaf_get_memory_size(instance) - 1U;
+	if ((addr > end_address) || ((addr - 1U + len) > end_address)) {
+		return -EINVAL;
+	}
+
+	if ((stm32mp2_risaf.granularity[instance] == 0U) ||
+	    ((addr % stm32mp2_risaf.granularity[instance]) != 0U) ||
+	    ((len % stm32mp2_risaf.granularity[instance]) != 0U)) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static bool do_regions_overlap(uintptr_t addr1, size_t len1, uintptr_t addr2, size_t len2)
+{
+	return (((addr2 >= addr1) && (addr2 < (addr1 + len1))) ||
+		((addr2 < addr1) && (addr2 + len2) > addr1));
+}
+
+static int check_region_overlap(void)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	int i;
+	uintptr_t addr;
+	size_t length;
+	int instance;
+	int region_id;
+
+	if (pdata->nregions <= 1) {
+		/*
+		 * No region found, or first region found.
+		 * No need to check overlap with previous ones.
+		 */
+		return 0;
+	}
+
+	region_id = pdata->nregions - 1;
+	addr = pdata->region[region_id].addr;
+	length = pdata->region[region_id].len;
+	instance = pdata->region[region_id].instance;
+
+	for (i = 0; i < region_id; i++) {
+		if (pdata->region[i].instance != instance) {
+			continue;
+		}
+
+		if (do_regions_overlap(addr, length,
+				      pdata->region[i].addr, pdata->region[i].len)) {
+			ERROR("RISAF%d: Regions %d and %d overlap\n", instance + 1, region_id, i);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int risaf_configure_region(int instance, uint32_t region_id, uint32_t cfg,
+				  uint32_t cid_cfg, uintptr_t saddr, uintptr_t eaddr)
+{
+	uintptr_t base = stm32mp2_risaf.base[instance];
+	uint32_t hwcfgr;
+	uint32_t mask_lsb;
+	uint32_t mask_msb;
+	uint32_t mask;
+
+	assert(valid_instance(instance));
+	assert(valid_protreg_id(instance, region_id));
+
+	mmio_clrbits_32(base + _RISAF_REG_CFGR(region_id), _RISAF_REG_CFGR_BREN);
+
+	/* Get address mask depending on RISAF instance HW configuration */
+	hwcfgr =  mmio_read_32(base + _RISAF_HWCFGR);
+	mask_lsb = (hwcfgr & _RISAF_HWCFGR_CFG3_MASK) >> _RISAF_HWCFGR_CFG3_SHIFT;
+	mask_msb = mask_lsb + ((hwcfgr & _RISAF_HWCFGR_CFG4_MASK) >> _RISAF_HWCFGR_CFG4_SHIFT) - 1U;
+	mask = GENMASK_32(mask_msb, mask_lsb);
+
+	mmio_clrsetbits_32(base + _RISAF_REG_STARTR(region_id), mask,
+			   (saddr - stm32_risaf_get_memory_base(instance)) & mask);
+	mmio_clrsetbits_32(base + _RISAF_REG_ENDR(region_id), mask,
+			   (eaddr - stm32_risaf_get_memory_base(instance)) & mask);
+
+	mmio_clrsetbits_32(base + _RISAF_REG_CIDCFGR(region_id), _RISAF_REG_CIDCFGR_ALL_MASK,
+			   cid_cfg & _RISAF_REG_CIDCFGR_ALL_MASK);
+
+	mmio_clrsetbits_32(base + _RISAF_REG_CFGR(region_id),
+			   _RISAF_REG_CFGR_ALL_MASK, cfg & _RISAF_REG_CFGR_ALL_MASK);
+
+	if ((cfg & _RISAF_REG_CFGR_ENC) == _RISAF_REG_CFGR_ENC) {
+		if (!risaf_is_hw_encryption_functional(instance)) {
+			ERROR("RISAF%d: encryption feature error\n", instance + 1);
+			return -EIO;
+		}
+
+		if ((cfg & _RISAF_REG_CFGR_SEC) != _RISAF_REG_CFGR_SEC) {
+			ERROR("RISAF%d: encryption on non secure area error\n", instance + 1);
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static void risaf_conf_protreg(void)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	int idx;
+
+	for (idx = 0; idx < RISAF_MAX_INSTANCE; idx++) {
+		int n;
+
+		if (pdata->base[idx] == 0) {
+			continue;
+		}
+
+		clk_enable(pdata->clock[idx]);
+
+		for (n = 0; n < pdata->nregions; n++) {
+			uint32_t id;
+			uint32_t value;
+			uint32_t cfg;
+			uint32_t cid_cfg;
+			uintptr_t start_addr;
+			uintptr_t end_addr;
+
+			if (pdata->region[n].instance != idx) {
+				continue;
+			}
+
+			value = pdata->region[n].cfg;
+			id = (value & DT_RISAF_REG_ID_MASK);
+			assert(valid_protreg_id(idx, id));
+
+			cfg = (((value & DT_RISAF_EN_MASK) >> DT_RISAF_EN_SHIFT) <<
+			       _RISAF_REG_CFGR_BREN_SHIFT) |
+			      (((value & DT_RISAF_SEC_MASK) >> DT_RISAF_SEC_SHIFT) <<
+			       _RISAF_REG_CFGR_SEC_SHIFT) |
+			      (((value & DT_RISAF_ENC_MASK) >> (DT_RISAF_ENC_SHIFT + 1)) <<
+			       _RISAF_REG_CFGR_ENC_SHIFT) |
+			      (((value & DT_RISAF_PRIV_MASK) >> DT_RISAF_PRIV_SHIFT) <<
+			       _RISAF_REG_CFGR_PRIVC_SHIFT);
+
+			cid_cfg = (((value & DT_RISAF_WRITE_MASK) >> DT_RISAF_WRITE_SHIFT) <<
+				   _RISAF_REG_CIDCFGR_WRENC_SHIFT) |
+				  (((value & DT_RISAF_READ_MASK) >> DT_RISAF_READ_SHIFT) <<
+				   _RISAF_REG_CIDCFGR_RDENC_SHIFT);
+
+			start_addr = pdata->region[n].addr;
+			end_addr = (start_addr - 1U) + pdata->region[n].len;
+
+			if (risaf_configure_region(idx, id, cfg, cid_cfg,
+						   start_addr, end_addr) < 0) {
+				panic();
+			}
+		}
+
+		clk_disable(pdata->clock[idx]);
+	}
+}
+
+static int risaf_get_dt_node(struct dt_node_info *info, int offset)
+{
+	return dt_get_node(info, offset, DT_RISAF_COMPAT);
+}
+
+static int risaf_get_instance_from_region(uintptr_t address, size_t length)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	unsigned int idx;
+	int instance = -1;
+
+	for (idx = 0U; idx < RISAF_MAX_INSTANCE; idx++) {
+		if (pdata->base[idx] == 0U) {
+			continue;
+		}
+
+		if (check_region_boundaries(idx, address, length) == 0) {
+			instance = idx;
+		}
+	}
+
+	return instance;
+}
+
+/*
+ * Register region in platfoirm data structure if parameters are valid.
+ * If instance is known, related entry parameter is filled, else it is equal to -1.
+ */
+static int risaf_register_region(void *fdt, int node, int instance)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	const fdt32_t *cuint;
+	int len = 0;
+	int inst;
+	uintptr_t address;
+	size_t length;
+	uint32_t protreg;
+
+	/*  Get address and length */
+	cuint = fdt_getprop(fdt, node, "reg", &len);
+	if ((cuint == NULL) || (len != RISAF_REGION_REG_SIZE)) {
+		ERROR("RISAF: No or bad reg entry in DT\n");
+		return -EINVAL;
+	}
+
+	address = (uintptr_t)fdt32_to_cpu(cuint[0]) << 32;
+	address |= fdt32_to_cpu(cuint[1]);
+	length = (size_t)fdt32_to_cpu(cuint[2]) << 32;
+	length |= fdt32_to_cpu(cuint[3]);
+
+	/* Get instance */
+	inst = risaf_get_instance_from_region(address, length);
+	if (inst < 0) {
+		ERROR("RISAF: No instance found in DT\n");
+		return -EINVAL;
+	}
+
+	if ((instance != -1) && (inst != instance)) {
+		ERROR("RISAF%d: Region not located in expected address space\n", instance + 1);
+		return -EINVAL;
+	}
+
+	/* Get protreg configuration */
+	cuint = fdt_getprop(fdt, node, "st,protreg", &len);
+	if ((cuint == NULL) || (len != RISAF_REGION_PROTREG_SIZE)) {
+		ERROR("RISAF%d: No or bad st,protreg entry in DT\n", inst + 1);
+		return -EINVAL;
+	}
+
+	protreg = fdt32_to_cpu(*cuint);
+
+	/* Check if region max is reached for the current instance */
+	region_per_instance[inst]++;
+	if (region_per_instance[inst] > stm32_risaf_get_max_region(inst)) {
+		ERROR("RISAF%d: Too many entries in DT\n", inst + 1);
+		return -EINVAL;
+	}
+
+	if (check_region_boundaries(inst, address, length) != 0) {
+		ERROR("RISAF%d: Region %d exceeds limits\n", inst + 1, pdata->nregions);
+		return -EINVAL;
+	}
+
+	/* Register region configuration */
+	pdata->region[pdata->nregions].instance = inst;
+	pdata->region[pdata->nregions].cfg = protreg;
+	pdata->region[pdata->nregions].addr = address;
+	pdata->region[pdata->nregions].len = length;
+	pdata->nregions++;
+
+	if (check_region_overlap() != 0) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * From DT, retrieve base address, clock ID and all region information for each RISAF instance.
+ * Check boundaries for each region and overlap for each instance.
+ */
+static int risaf_parse_fdt(void)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	struct dt_node_info risaf_info;
+	int node = -1;
+	void *fdt;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -ENOENT;
+	}
+
+	for (node = risaf_get_dt_node(&risaf_info, node); node >= 0;
+	     node = risaf_get_dt_node(&risaf_info, node)) {
+		int idx;
+		int nregions;
+		int inst_maxregions;
+		int i;
+		int len = 0;
+		const fdt32_t *conf_list;
+		uint32_t granularity;
+
+		idx = stm32_risaf_get_instance(risaf_info.base);
+		if ((idx < 0) || (risaf_info.clock < 0)) {
+			continue;
+		}
+
+		pdata->base[idx] = risaf_info.base;
+		pdata->clock[idx] = (unsigned long)risaf_info.clock;
+
+		/* Get IP region granularity */
+		clk_enable(pdata->clock[idx]);
+		granularity = mmio_read_32(pdata->base[idx] + _RISAF_HWCFGR);
+		clk_disable(pdata->clock[idx]);
+		granularity = BIT((granularity & _RISAF_HWCFGR_CFG3_MASK) >>
+				  _RISAF_HWCFGR_CFG3_SHIFT);
+		pdata->granularity[idx] = granularity;
+
+		conf_list = fdt_getprop(fdt, node, "memory-region", &len);
+		if (conf_list == NULL) {
+			len = 0;
+		}
+
+		nregions = (unsigned int)len / sizeof(uint32_t);
+
+		inst_maxregions = stm32_risaf_get_max_region(idx);
+		if (inst_maxregions <= 0) {
+			continue;
+		}
+
+		if ((nregions > inst_maxregions) ||
+		    ((pdata->nregions + nregions) > RISAF_MAX_REGION)) {
+			ERROR("RISAF%d: Too many entries in DT\n", idx + 1);
+			return -EINVAL;
+		}
+
+		for (i = 0; i < nregions; i++) {
+			int pnode = 0;
+
+			pnode = fdt_node_offset_by_phandle(fdt, fdt32_to_cpu(conf_list[i]));
+			if (pnode < 0) {
+				continue;
+			}
+
+			if (risaf_register_region(fdt, pnode, idx) != 0) {
+				ERROR("RISAF%d: Region %d error\n", idx + 1, pdata->nregions);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static uintptr_t risaf_base[RISAF_MAX_INSTANCE];
+static unsigned long risaf_clock[RISAF_MAX_INSTANCE];
+static uint32_t risaf_granularity[RISAF_MAX_INSTANCE];
+static struct stm32mp2_risaf_region risaf_region[RISAF_MAX_REGION];
+
+/* Construct platform data structure */
+static int risaf_get_platdata(struct stm32mp2_risaf_platdata *pdata)
+{
+	pdata->base = risaf_base;
+	pdata->clock = risaf_clock;
+	pdata->granularity = risaf_granularity;
+	pdata->region = risaf_region;
+
+	return 0;
+}
+
+/*
+ * @brief  Write the MCE master key for a given instance.
+ * @param  instance: RISAF instance ID.
+ *         mkey: Pointer to the master key buffer.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32mp2_risaf_write_master_key(int instance, uint8_t *mkey)
+{
+	uint64_t timeout_ref;
+	uint32_t i;
+	uintptr_t base = stm32mp2_risaf.base[instance];
+
+	if (base == 0U) {
+		return -EINVAL;
+	}
+
+	if (mkey == NULL) {
+		return -EINVAL;
+	}
+
+	for (i = 0U; i < RISAF_KEY_SIZE_IN_BYTES; i += sizeof(uint32_t)) {
+		uint32_t key_val = 0U;
+
+		memcpy(&key_val, mkey + i, sizeof(uint32_t));
+
+		mmio_write_32(base + _RISAF_KEYR + i, key_val);
+	}
+
+	timeout_ref = timeout_init_us(RISAF_TIMEOUT_1MS_IN_US);
+
+	while (((mmio_read_32(base + _RISAF_SR) & _RISAF_SR_KEYVALID) != _RISAF_SR_KEYVALID) ||
+	       ((mmio_read_32(base + _RISAF_SR) & _RISAF_SR_KEYRDY) != _RISAF_SR_KEYRDY)) {
+		if (timeout_elapsed(timeout_ref)) {
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Lock the RISAF IP registers for a given instance.
+ * @param  instance: RISAF instance ID.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32mp2_risaf_lock(int instance)
+{
+	uintptr_t base = stm32mp2_risaf.base[instance];
+
+	if (base == 0U) {
+		return -EINVAL;
+	}
+
+	mmio_setbits_32(base + _RISAF_CR, _RISAF_CR_GLOCK);
+
+	return 0;
+}
+
+/*
+ * @brief  Get the RISAF lock state for a given instance.
+ * @param  instance: RISAF instance ID.
+ *         state: lock state, true if locked, false else.
+ * @retval 0 if OK, negative value else.
+ */
+int stm32mp2_risaf_is_locked(int instance, bool *state)
+{
+	uintptr_t base = stm32mp2_risaf.base[instance];
+
+	if (base == 0U) {
+		return -EINVAL;
+	}
+
+	*state = (mmio_read_32(base + _RISAF_CR) & _RISAF_CR_GLOCK) == _RISAF_CR_GLOCK;
+
+	return 0;
+}
+
+int stm32mp2_risaf_init(void)
+{
+	int err;
+
+	err = risaf_get_platdata(&stm32mp2_risaf);
+	if (err != 0) {
+		return err;
+	}
+
+	err = risaf_parse_fdt();
+	if (err != 0) {
+		return err;
+	}
+
+	risaf_conf_protreg();
+
+	return err;
+}
+
+static int risaf_parse_fwconfig(uintptr_t config)
+{
+	struct stm32mp2_risaf_platdata *pdata = &stm32mp2_risaf;
+	unsigned int i;
+	int node = -1;
+	int subnode;
+	const void *fdt = (const void *)config;
+	const char *compatible_str = "st,stm32mp2-mem-firewall";
+
+	node = fdt_node_offset_by_compatible(fdt, -1, compatible_str);
+	if (node < 0) {
+		ERROR("FCONF: Can't find %s compatible in dtb\n", compatible_str);
+		return node;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		if (risaf_register_region((void *)fdt, subnode, -1) != 0) {
+			ERROR("RISAF: Region %d error\n", pdata->nregions);
+			return -EINVAL;
+		}
+	}
+
+	for (i = 0U; i < RISAF_MAX_INSTANCE; i++) {
+		if ((region_per_instance[i] == 0) && (stm32_risaf_get_max_region(i) != 0)) {
+			INFO("RISAF%u: No configuration in DT, use default\n", i + 1);
+		}
+	}
+
+	return 0;
+}
+
+static int fconf_populate_risaf(uintptr_t config)
+{
+	int err;
+
+	err = risaf_parse_fwconfig(config);
+	if (err != 0) {
+		return err;
+	}
+
+	risaf_conf_protreg();
+
+	return err;
+}
+
+FCONF_REGISTER_POPULATOR(FW_CONFIG, risaf_config, fconf_populate_risaf);
diff --git a/drivers/st/spi/stm32_ospi.c b/drivers/st/spi/stm32_ospi.c
new file mode 100644
index 0000000000..7e5a7c5c8d
--- /dev/null
+++ b/drivers/st/spi/stm32_ospi.c
@@ -0,0 +1,1320 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#include <inttypes.h>
+
+#include <libfdt.h>
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#if STM32MP_HYPERFLASH
+#include <drivers/hyperflash.h>
+#else
+#include <drivers/spi_mem.h>
+#endif
+#include <drivers/st/stm32_gpio.h>
+#include <drivers/st/stm32_ospi.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
+#include <lib/utils.h>
+#include <lib/utils_def.h>
+
+/* Timeout for device interface reset */
+#define _TIMEOUT_US_1_MS	1000U
+
+/* OCTOSPI registers */
+#define _OSPI_CR		0x00U
+#define _OSPI_DCR1		0x08U
+#define _OSPI_DCR2		0x0CU
+#define _OSPI_SR		0x20U
+#define _OSPI_FCR		0x24U
+#define _OSPI_DLR		0x40U
+#define _OSPI_AR		0x48U
+#define _OSPI_DR		0x50U
+#define _OSPI_CCR		0x100U
+#define _OSPI_TCR		0x108U
+#define _OSPI_IR		0x110U
+#define _OSPI_ABR		0x120U
+#define _OSPI_HLCR		0x200U
+
+/* OCTOSPI control register */
+#define _OSPI_CR_EN		BIT(0)
+#define _OSPI_CR_ABORT		BIT(1)
+#define _OSPI_CR_CSSEL		BIT(24)
+#define _OSPI_CR_FMODE		GENMASK_32(29, 28)
+#define _OSPI_CR_FMODE_SHIFT	28U
+#define _OSPI_CR_FMODE_INDW	0U
+#define _OSPI_CR_FMODE_INDR	1U
+#define _OSPI_CR_FMODE_MM	3U
+
+/* OCTOSPI device configuration register 1 */
+#define _OSPI_DCR1_CKMODE	BIT(0)
+#define _OSPI_DCR1_DLYBYP	BIT(3)
+#define _OSPI_DCR1_CSHT		GENMASK_32(13, 8)
+#define _OSPI_DCR1_CSHT_SHIFT	8U
+#define _OSPI_DCR1_DEVSIZE	GENMASK_32(20, 16)
+#define _OSPI_DCR1_MTYP		GENMASK_32(26, 24)
+#define _OSPI_DCR1_MTYP_SHIFT	24U
+#define _OSPI_DCR1_MTYP_MX_MODE	1U
+#define _OSPI_DCR1_MTYP_HB_MM	4U
+
+/* OCTOSPI device configuration register 2 */
+#define _OSPI_DCR2_PRESCALER	GENMASK_32(7, 0)
+
+/* OCTOSPI status register */
+#define _OSPI_SR_TEF		BIT(0)
+#define _OSPI_SR_TCF		BIT(1)
+#define _OSPI_SR_FTF		BIT(2)
+#define _OSPI_SR_SMF		BIT(3)
+#define _OSPI_SR_BUSY		BIT(5)
+
+/* OCTOSPI flag clear register */
+#define _OSPI_FCR_CTEF		BIT(0)
+#define _OSPI_FCR_CTCF		BIT(1)
+#define _OSPI_FCR_CSMF		BIT(3)
+
+/* OCTOSPI communication configuration register */
+#define _OSPI_CCR_IMODE		GENMASK_32(2, 0)
+#define _OSPI_CCR_IDTR		BIT(3)
+#define _OSPI_CCR_ISIZE		GENMASK_32(5, 4)
+#define _OSPI_CCR_ISIZE_SHIFT	4U
+#define _OSPI_CCR_ADMODE	GENMASK_32(10, 8)
+#define _OSPI_CCR_ADMODE_SHIFT	8U
+#define _OSPI_CCR_ADMODE_8LINES 4U
+#define _OSPI_CCR_ADDTR		BIT(11)
+#define _OSPI_CCR_ADSIZE	GENMASK_32(13, 12)
+#define _OSPI_CCR_ADSIZE_SHIFT	12U
+#define _OSPI_CCR_ADSIZE_32BITS 3U
+#define _OSPI_CCR_DMODE		GENMASK_32(26, 24)
+#define _OSPI_CCR_DMODE_SHIFT	24U
+#define _OSPI_CCR_DMODE_8LINES	4U
+#define _OSPI_CCR_DDTR		BIT(27)
+#define _OSPI_CCR_DQSE		BIT(29)
+
+/* OCTOSPI timing configuration register */
+#define _OSPI_TCR_DCYC		GENMASK_32(4, 0)
+#define _OSPI_TCR_DHQC		BIT(28)
+#define _OSPI_TCR_SSHIFT	BIT(30)
+
+/* OCTOSPI hyperbus latency configuration register */
+#define _OSPI_HLCR_WZL		BIT(1)
+#define _OSPI_HLCR_TACC		GENMASK_32(15,8)
+#define _OSPI_HLCR_TACC_SHIFT	8U
+
+#define _OSPI_MAX_CHIP		2U
+#define _OSPI_MAX_RESET		2U
+
+#define _OSPI_FIFO_TIMEOUT_US	30U
+#define _OSPI_CMD_TIMEOUT_US	1000U
+#define _OSPI_BUSY_TIMEOUT_US	100U
+#define _OSPI_ABT_TIMEOUT_US	100U
+
+#define _OMM_MAX_OSPI		2U
+#define _OSPI_MAX_CS		2U
+
+#define _DT_IOM_COMPAT		"st,stm32mp25-omm"
+#define _DT_OSPI_COMPAT		"st,stm32mp25-omi"
+
+#define _FREQ_100MHZ		100000000U
+#define _DLYB_FREQ_50MHZ	50000000U
+#define _OSPI_NSEC_PER_SEC	1000000000U
+
+#define _OP_READ_ID		0x9FU
+#define _MAX_ID_LEN		8U
+
+#define _MACRONIX_ID		0xC2U
+
+#if !STM32MP_HYPERFLASH
+struct stm32_ospi_flash {
+	uint64_t str_idcode;
+	uint64_t dtr_idcode;
+	bool is_spi_nor;
+	bool str_calibration_done_once;
+	bool dtr_calibration_done_once;
+	bool octal_dtr;
+};
+#endif /* STM32MP_HYPERFLASH */
+
+struct stm32_ospi_ctrl {
+	uintptr_t reg_base;
+	uintptr_t mm_base;
+	size_t mm_size;
+	unsigned long clock_id;
+#if !STM32MP_HYPERFLASH
+	struct stm32_ospi_flash flash;
+#endif /* STM32MP_HYPERFLASH */
+	uint8_t bank;
+	bool is_calibrating;
+};
+
+static struct stm32_ospi_ctrl stm32_ospi;
+
+static uintptr_t ospi_base(void)
+{
+	return stm32_ospi.reg_base;
+}
+
+static int stm32_ospi_wait_for_not_busy(void)
+{
+	uint64_t timeout = timeout_init_us(_OSPI_BUSY_TIMEOUT_US);
+
+	while ((mmio_read_32(ospi_base() + _OSPI_SR) & _OSPI_SR_BUSY) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ERROR("%s: busy timeout\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_wait_cmd(void)
+{
+	int ret = 0;
+	uint64_t timeout;
+
+	timeout = timeout_init_us(_OSPI_CMD_TIMEOUT_US);
+	while ((mmio_read_32(ospi_base() + _OSPI_SR) & _OSPI_SR_TCF) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			ret = -ETIMEDOUT;
+			ERROR("%s: cmd timeout\n", __func__);
+			break;
+		}
+	}
+
+	if ((ret == 0) && ((mmio_read_32(ospi_base() + _OSPI_SR) &
+			   _OSPI_SR_TEF) != 0U)) {
+		ERROR("%s: transfer error\n", __func__);
+		ret = -EIO;
+	}
+
+	/* Clear flags */
+	mmio_write_32(ospi_base() + _OSPI_FCR, _OSPI_FCR_CTCF | _OSPI_FCR_CTEF);
+
+	if (ret == 0) {
+		ret = stm32_ospi_wait_for_not_busy();
+	}
+
+	return ret;
+}
+
+static void stm32_ospi_read_fifo(uint8_t *val, uintptr_t addr)
+{
+	*val = mmio_read_8(addr);
+}
+
+static void stm32_ospi_write_fifo(uint8_t *val, uintptr_t addr)
+{
+	mmio_write_8(addr, *val);
+}
+
+static int stm32_ospi_poll(uint8_t *buf, uint32_t nbytes, bool read)
+{
+	void (*fifo)(uint8_t *val, uintptr_t addr);
+	uint32_t len;
+
+	if (read) {
+		fifo = stm32_ospi_read_fifo;
+	} else {
+		fifo = stm32_ospi_write_fifo;
+	}
+
+	for (len = nbytes; len != 0U; len--) {
+		uint64_t timeout = timeout_init_us(_OSPI_FIFO_TIMEOUT_US);
+
+		while ((mmio_read_32(ospi_base() + _OSPI_SR) &
+			_OSPI_SR_FTF) == 0U) {
+			if (timeout_elapsed(timeout)) {
+				if (!stm32_ospi.is_calibrating) {
+					ERROR("%s: fifo timeout\n", __func__);
+				}
+
+				return -ETIMEDOUT;
+			}
+		}
+
+		fifo(buf++, ospi_base() + _OSPI_DR);
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_mm(uint8_t *buf, uint32_t nbytes, size_t addr)
+{
+	uintptr_t from = stm32_ospi.mm_base + addr;
+
+	while (nbytes >= sizeof(uint8_t)) {
+		*buf = mmio_read_8(from);
+		buf += sizeof(uint8_t);
+		from += sizeof(uint8_t);
+		nbytes -= sizeof(uint8_t);
+		dmbsy();
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_dtr_calibrate(uint32_t prescaler, unsigned int bus_freq,
+				    int (*check_transfer)(void))
+{
+	uint16_t period_ps = 0U;
+	uint8_t window_len = 0U;
+	int ret;
+	bool bypass_mode = false;
+
+	mmio_clrbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_DLYBYP);
+
+	if (prescaler != 0U) {
+		mmio_setbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_DHQC);
+	}
+
+	if (bus_freq <= _DLYB_FREQ_50MHZ) {
+		bypass_mode = true;
+		period_ps = _OSPI_NSEC_PER_SEC / (bus_freq / 1000U);
+	}
+
+	ret = stm32mp_syscfg_dlyb_init(stm32_ospi.bank, bypass_mode,
+					period_ps);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (bypass_mode || (prescaler != 0U)) {
+		/* perform only RX TAP selection */
+		ret = stm32mp_syscfg_dlyb_find_tap(stm32_ospi.bank,
+						    check_transfer,
+						    true, &window_len);
+	} else {
+		/* perform RX/TX TAP selection */
+		ret = stm32mp_syscfg_dlyb_find_tap(stm32_ospi.bank,
+						    check_transfer,
+						    false, &window_len);
+	}
+
+	if (ret != 0) {
+		ERROR("Calibration failed\n");
+
+		if (!bypass_mode) {
+			stm32mp_syscfg_dlyb_stop(stm32_ospi.bank);
+		}
+	}
+
+	return ret;
+}
+
+#if STM32MP_HYPERFLASH
+static int stm32_ospi_hb_read(unsigned int offset, uint8_t *buffer,
+			      size_t length, size_t *length_read)
+{
+	*length_read = length;
+
+	return stm32_ospi_mm(buffer, length, offset);
+}
+
+static int stm32_ospi_hb_xfer(unsigned int offset, uint16_t wdata,
+			      uint16_t *rdata)
+{
+	int ret;
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_FMODE,
+			   rdata != NULL ?
+			   _OSPI_CR_FMODE_INDR << _OSPI_CR_FMODE_SHIFT :
+			   _OSPI_CR_FMODE_INDW << _OSPI_CR_FMODE_SHIFT);
+	mmio_write_32(ospi_base() + _OSPI_AR, offset);
+
+	if (rdata != NULL) {
+		ret = stm32_ospi_poll((uint8_t *)rdata, 2U, true);
+	} else {
+		ret = stm32_ospi_poll((uint8_t *)&wdata, 2U, false);
+	}
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Wait end of tx in indirect mode */
+	ret = stm32_ospi_wait_cmd();
+	if (ret != 0) {
+		return ret;
+	}
+
+	VERBOSE("%s: %s 0x%x @ 0x%x\n", __func__,
+		rdata != NULL ? "read" : "write",
+		rdata != NULL ? (unsigned int)*rdata : (unsigned int)wdata,
+		offset);
+
+	return ret;
+}
+
+static uint16_t stm32_ospi_hb_read16(uint32_t offset)
+{
+	int ret;
+	uint16_t rdata = 0U;
+
+	ret = stm32_ospi_hb_xfer(offset, 0U, &rdata);
+	if (ret != 0) {
+		ERROR("%s failed, ret=%i\n", __func__, ret);
+		panic();
+	}
+
+	return rdata;
+}
+
+static void stm32_ospi_hb_write16(uint16_t value, uint32_t offset)
+{
+	int ret;
+
+	ret = stm32_ospi_hb_xfer(offset, value, NULL);
+	if (ret != 0) {
+		ERROR("%s failed, ret=%i\n", __func__, ret);
+		panic();
+	}
+};
+
+static int stm32_ospi_hb_test_cfi(void)
+{
+	int ret = -EIO;
+	uint16_t qry[3];
+
+	/* Reset/Exit from CFI */
+	stm32_ospi_hb_write16(0xF0U, 0U);
+	/* Enter in CFI */
+	stm32_ospi_hb_write16(0x98U, 0xAAU);
+
+	qry[0] = stm32_ospi_hb_read16(0x20U);
+	qry[1] = stm32_ospi_hb_read16(0x22U);
+	qry[2] = stm32_ospi_hb_read16(0x24U);
+	if ((qry[0] == 'Q') && (qry[1] == 'R') && (qry[2] == 'Y')) {
+		ret = 0;
+	}
+
+	/* Reset/Exit from CFI */
+	stm32_ospi_hb_write16(0xF0U, 0U);
+	stm32_ospi_hb_write16(0xFFU, 0U);
+
+	return ret;
+}
+
+static int stm32_ospi_hb_test_jedec(void)
+{
+	int ret = -EIO;
+	uint16_t sfdp[2];
+
+	stm32_ospi_hb_write16(0xF0U, 0U);
+	stm32_ospi_hb_write16(0xAAU, 0xAAAU);
+	stm32_ospi_hb_write16(0x55U, 0x554U);
+	stm32_ospi_hb_write16(0x90U, 0xAAAU);
+
+	sfdp[0] = stm32_ospi_hb_read16(0U);
+	sfdp[1] = stm32_ospi_hb_read16(0x2U);
+
+	/* compare with "SF" & "DP" */
+	if ((sfdp[0] == 0x4653) && (sfdp[1] == 0x5044)) {
+		ret = 0;
+	}
+
+	stm32_ospi_hb_write16(0xF0U, 0U);
+
+	return ret;
+}
+
+static int stm32_ospi_hb_init(void *fdt, int bus_node)
+{
+	int ret;
+	int nchips = 0;
+	int bus_subnode = 0;
+	const fdt32_t *cuint = NULL;
+	bool wzl = false;
+	bool jedec_flash = false;
+	unsigned int tacc = 0U;
+	unsigned int max_freq = 0U;
+	unsigned long ospi_clk = clk_get_rate(stm32_ospi.clock_id);
+	uint32_t prescaler = UINT8_MAX;
+	unsigned int bus_freq;
+	unsigned int period;
+	uint32_t ccr;
+
+	if (ospi_clk == 0U) {
+		return -EINVAL;
+	}
+
+	fdt_for_each_subnode(bus_subnode, fdt, bus_node) {
+		nchips++;
+	}
+
+	if (nchips != 1) {
+		ERROR("Only one hyperflash device is currently supported\n");
+		return -EINVAL;
+	}
+
+	fdt_for_each_subnode(bus_subnode, fdt, bus_node) {
+		cuint = fdt_getprop(fdt, bus_subnode, "st,max-frequency", NULL);
+		if (cuint == NULL) {
+			ERROR("Max frequency not set\n");
+			return -EINVAL;
+		}
+		max_freq = fdt32_to_cpu(*cuint);
+
+		cuint = fdt_getprop(fdt, bus_subnode, "st,tacc-ns", NULL);
+		if (cuint != NULL) {
+			tacc = fdt32_to_cpu(*cuint);
+		}
+
+		if ((fdt_getprop(fdt, bus_subnode, "st,wzl", NULL)) != NULL) {
+			wzl = true;
+		}
+
+		if (fdt_node_check_compatible(fdt, bus_subnode,
+					      "jedec-flash") == 0) {
+			jedec_flash = true;
+		}
+	}
+
+	/* Enable the controller */
+	mmio_setbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_EN);
+
+	/* Set MTYP to HyperBus memory-map mode */
+	mmio_clrsetbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_MTYP,
+			   _OSPI_DCR1_MTYP_HB_MM << _OSPI_DCR1_MTYP_SHIFT);
+
+	/* Set the prescaler */
+	if (max_freq > 0U) {
+		prescaler = div_round_up(ospi_clk, max_freq) - 1U;
+		if (prescaler > UINT8_MAX) {
+			prescaler = UINT8_MAX;
+		}
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_DCR2, _OSPI_DCR2_PRESCALER,
+			   prescaler);
+
+	/* Configure data length for 2 bytes read/write */
+	mmio_write_32(ospi_base() + _OSPI_DLR, 1U);
+
+	/*
+	 * Set access time latency
+	 * Set write zero latency
+	 */
+	bus_freq = div_round_up(ospi_clk, prescaler + 1U);
+	period = _OSPI_NSEC_PER_SEC / bus_freq;
+	mmio_clrsetbits_32(ospi_base() + _OSPI_HLCR,
+			   _OSPI_HLCR_TACC | _OSPI_HLCR_WZL,
+			   div_round_up(tacc, period) << _OSPI_HLCR_TACC_SHIFT);
+	if (wzl) {
+		mmio_setbits_32(ospi_base() + _OSPI_HLCR, _OSPI_HLCR_WZL);
+	}
+
+	/* Configure read access */
+	ccr = _OSPI_CCR_DQSE | _OSPI_CCR_DDTR | _OSPI_CCR_ADDTR;
+	ccr |= _OSPI_CCR_DMODE_8LINES << _OSPI_CCR_DMODE_SHIFT;
+	ccr |= _OSPI_CCR_ADSIZE_32BITS << _OSPI_CCR_ADSIZE_SHIFT;
+	ccr |= _OSPI_CCR_ADMODE_8LINES << _OSPI_CCR_ADMODE_SHIFT;
+	mmio_write_32(ospi_base() + _OSPI_CCR, ccr);
+
+	/* Calibrate the DLL */
+	if (jedec_flash) {
+		ret = stm32_ospi_dtr_calibrate(prescaler, bus_freq,
+					       stm32_ospi_hb_test_jedec);
+	} else {
+		ret = stm32_ospi_dtr_calibrate(prescaler, bus_freq,
+					       stm32_ospi_hb_test_cfi);
+	}
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Set the controller in memory map mode */
+	mmio_clrsetbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_FMODE,
+			   _OSPI_CR_FMODE_MM << _OSPI_CR_FMODE_SHIFT);
+
+	return 0;
+}
+
+static const struct hyperflash_ctrl_ops stm32_ospi_ctrl_ops = {
+	.read = stm32_ospi_hb_read,
+};
+#else /* STM32MP_HYPERFLASH */
+static int stm32_ospi_tx(const struct spi_mem_op *op, uint8_t fmode)
+{
+	struct stm32_ospi_flash *flash = &stm32_ospi.flash;
+	uint8_t dummy = 0xFFU;
+	int ret;
+
+	if (op->data.nbytes == 0U) {
+		return 0;
+	}
+
+	if (fmode == _OSPI_CR_FMODE_MM) {
+		return stm32_ospi_mm((uint8_t *)op->data.buf, op->data.nbytes,
+				     (size_t)op->addr.val);
+	}
+
+	if (flash->octal_dtr && ((op->addr.val % 2U) != 0U)) {
+		/* Read/write dummy byte */
+		ret = stm32_ospi_poll(&dummy, 1U,
+				      op->data.dir == SPI_MEM_DATA_IN);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	ret = stm32_ospi_poll((uint8_t *)op->data.buf, op->data.nbytes,
+			      op->data.dir == SPI_MEM_DATA_IN);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (flash->octal_dtr &&
+	    (((op->addr.val + op->data.nbytes) % 2U) != 0U)) {
+		/* Read/write dummy byte */
+		ret = stm32_ospi_poll(&dummy, 1U,
+				      op->data.dir == SPI_MEM_DATA_IN);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+static unsigned int stm32_ospi_get_mode(uint8_t buswidth)
+{
+	switch (buswidth) {
+	case SPI_MEM_BUSWIDTH_8_LINE:
+		return 4U;
+	case SPI_MEM_BUSWIDTH_4_LINE:
+		return 3U;
+	default:
+		return buswidth;
+	}
+}
+
+static int stm32_ospi_send(const struct spi_mem_op *op, uint8_t fmode)
+{
+	struct stm32_ospi_flash *flash = &stm32_ospi.flash;
+	uint64_t timeout;
+	uint64_t addr = op->addr.val;
+	uint32_t ccr;
+	uint32_t dcyc = 0U;
+	unsigned int nbytes = op->data.nbytes;
+	int ret;
+
+	VERBOSE("%s: cmd:%x dtr:%d mode:%d.%d.%d.%d addr:%" PRIx64 " len:%x\n",
+		__func__, op->cmd.opcode,  op->cmd.dtr, op->cmd.buswidth,
+		op->addr.buswidth, op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	ret = stm32_ospi_wait_for_not_busy();
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (flash->octal_dtr && (fmode != _OSPI_CR_FMODE_MM) &&
+	    (op->data.nbytes != 0U)) {
+		if ((op->addr.val % 2U) != 0U) {
+			addr--;
+			nbytes++;
+		}
+
+		if (((op->addr.val + op->data.nbytes) % 2U) != 0U) {
+			nbytes++;
+		}
+	}
+
+	mmio_clrbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_MTYP);
+
+	if ((op->data.nbytes != 0U) && (fmode != _OSPI_CR_FMODE_MM)) {
+		mmio_write_32(ospi_base() + _OSPI_DLR, nbytes - 1U);
+	}
+
+	if ((op->dummy.buswidth != 0U) && (op->dummy.nbytes != 0U)) {
+		dcyc = op->dummy.nbytes * 8U / op->dummy.buswidth;
+
+		if (op->dummy.dtr) {
+			dcyc /= 2U;
+		}
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_DCYC, dcyc);
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_FMODE,
+			   fmode << _OSPI_CR_FMODE_SHIFT);
+
+	if (op->data.dtr_swab16) {
+		mmio_clrsetbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_MTYP,
+				   _OSPI_DCR1_MTYP_MX_MODE <<
+				   _OSPI_DCR1_MTYP_SHIFT);
+	}
+
+	ccr = stm32_ospi_get_mode(op->cmd.buswidth);
+	ccr |= (op->cmd.nbytes - 1U) << _OSPI_CCR_ISIZE_SHIFT;
+
+	if (op->cmd.dtr) {
+		ccr |= _OSPI_CCR_IDTR;
+		ccr |= _OSPI_CCR_DQSE;
+	}
+
+	if (op->addr.dtr) {
+		ccr |= _OSPI_CCR_ADDTR;
+	}
+
+	if (op->data.dtr) {
+		ccr |= _OSPI_CCR_DDTR;
+	}
+
+	if (op->addr.nbytes != 0U) {
+		ccr |= (op->addr.nbytes - 1U) << _OSPI_CCR_ADSIZE_SHIFT;
+		ccr |= stm32_ospi_get_mode(op->addr.buswidth) <<
+		       _OSPI_CCR_ADMODE_SHIFT;
+	}
+
+	if (op->data.nbytes != 0U) {
+		ccr |= stm32_ospi_get_mode(op->data.buswidth) <<
+		       _OSPI_CCR_DMODE_SHIFT;
+	}
+
+	mmio_write_32(ospi_base() + _OSPI_CCR, ccr);
+
+	mmio_write_32(ospi_base() + _OSPI_IR, op->cmd.opcode);
+
+	if ((op->addr.nbytes != 0U) && (fmode != _OSPI_CR_FMODE_MM)) {
+		mmio_write_32(ospi_base() + _OSPI_AR, addr);
+	}
+
+	ret = stm32_ospi_tx(op, fmode);
+
+	/*
+	 * Abort in:
+	 * - Error case.
+	 * - Memory mapped read: prefetching must be stopped if we read the last
+	 *   byte of device (device size - fifo size). If device size is not
+	 *   known then prefetching is always stopped.
+	 */
+	if ((ret != 0) || (fmode == _OSPI_CR_FMODE_MM)) {
+		goto abort;
+	}
+
+	/* Wait end of TX in indirect mode */
+	ret = stm32_ospi_wait_cmd();
+	if (ret != 0) {
+		goto abort;
+	}
+
+	return 0;
+
+abort:
+	mmio_setbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_ABORT);
+
+	/* Wait clear of abort bit by hardware */
+	timeout = timeout_init_us(_OSPI_ABT_TIMEOUT_US);
+	while ((mmio_read_32(ospi_base() + _OSPI_CR) & _OSPI_CR_ABORT) != 0U) {
+		if (timeout_elapsed(timeout)) {
+			ret = -ETIMEDOUT;
+			break;
+		}
+	}
+
+	mmio_write_32(ospi_base() + _OSPI_FCR, _OSPI_FCR_CTCF);
+
+	if ((ret != 0) && !stm32_ospi.is_calibrating) {
+		ERROR("%s: exec op error\n", __func__);
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_set_speed(unsigned int hz)
+{
+	unsigned long ospi_clk = clk_get_rate(stm32_ospi.clock_id);
+	unsigned int bus_freq;
+	uint32_t prescaler = UINT8_MAX;
+	uint32_t csht;
+	int ret;
+
+	if (ospi_clk == 0U) {
+		return -EINVAL;
+	}
+
+	if (hz > 0U) {
+		prescaler = div_round_up(ospi_clk, hz) - 1U;
+		if (prescaler > UINT8_MAX) {
+			prescaler = UINT8_MAX;
+		}
+	}
+
+	csht = div_round_up((5U * ospi_clk) / (prescaler + 1U), _FREQ_100MHZ);
+	csht = ((csht - 1U) << _OSPI_DCR1_CSHT_SHIFT) & _OSPI_DCR1_CSHT;
+
+	ret = stm32_ospi_wait_for_not_busy();
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_DCR2, _OSPI_DCR2_PRESCALER,
+			   prescaler);
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_CSHT, csht);
+
+	bus_freq = div_round_up(ospi_clk, prescaler + 1U);
+	if (bus_freq <= _DLYB_FREQ_50MHZ) {
+		mmio_setbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_DLYBYP);
+	} else {
+		mmio_clrbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_DLYBYP);
+	}
+
+	VERBOSE("%s: speed=%lu\n", __func__, ospi_clk / (prescaler + 1U));
+
+	return 0;
+}
+
+static int stm32_ospi_readid(void)
+{
+	struct stm32_ospi_flash *flash = &stm32_ospi.flash;
+	uint64_t id;
+	struct spi_mem_op readid_op;
+	int ret;
+
+	if (!flash->str_calibration_done_once) {
+		uint8_t nb_dummy_bytes = flash->is_spi_nor ? 0U : 1U;
+
+		zeromem(&readid_op, sizeof(struct spi_mem_op));
+		readid_op.cmd.nbytes = 1U;
+		readid_op.cmd.opcode = _OP_READ_ID;
+		readid_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+		readid_op.dummy.nbytes = nb_dummy_bytes;
+		readid_op.dummy.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+		readid_op.data.nbytes = _MAX_ID_LEN;
+		readid_op.data.buf = &id;
+		readid_op.data.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	} else {
+		if (flash->octal_dtr && flash->is_spi_nor) {
+			uint16_t opcode;
+			uint8_t nb_addr_bytes;
+			uint8_t nb_dummy_bytes;
+
+			if ((flash->dtr_idcode & 0xffU) == _MACRONIX_ID) {
+				opcode = 0x9f60U;
+				nb_addr_bytes = 4U;
+				nb_dummy_bytes = 8U;
+			} else {
+				/*
+				 * All memory providers are not currently
+				 * supported, feel free to add them
+				 */
+				return -EOPNOTSUPP;
+			}
+
+			zeromem(&readid_op, sizeof(struct spi_mem_op));
+			readid_op.cmd.nbytes = 2U;
+			readid_op.cmd.opcode = opcode;
+			readid_op.cmd.buswidth = SPI_MEM_BUSWIDTH_8_LINE;
+			readid_op.cmd.dtr = true;
+			readid_op.addr.nbytes = nb_addr_bytes;
+			readid_op.addr.buswidth = SPI_MEM_BUSWIDTH_8_LINE;
+			readid_op.addr.dtr = true;
+			readid_op.dummy.nbytes = nb_dummy_bytes;
+			readid_op.dummy.buswidth = SPI_MEM_BUSWIDTH_8_LINE;
+			readid_op.dummy.dtr = true;
+			readid_op.data.nbytes = _MAX_ID_LEN;
+			readid_op.data.buf = &id;
+			readid_op.data.buswidth = SPI_MEM_BUSWIDTH_8_LINE;
+			readid_op.data.dtr = true;
+		} else {
+			/*
+			 * Only OCTAL DTR calibration on SPI NOR devices
+			 * is currently supported
+			 */
+			return -EOPNOTSUPP;
+		}
+	}
+
+	stm32_ospi.is_calibrating = true;
+	ret = stm32_ospi_send(&readid_op, _OSPI_CR_FMODE_INDR);
+	stm32_ospi.is_calibrating = false;
+	if (ret != 0) {
+		return ret;
+	}
+
+	VERBOSE("Flash ID 0x%08lx\n", id);
+
+	if (!flash->str_calibration_done_once) {
+		/* On stm32_ospi_readid() first execution, save the golden read id */
+		if (flash->str_idcode == 0U) {
+			flash->str_idcode = id;
+
+			if (flash->is_spi_nor) {
+				/* Build DTR id code */
+				if ((id & 0xFFU) == _MACRONIX_ID) {
+					/*
+					 * Retrieve odd array and re-sort id
+					 * because of read id format will be
+					 * A-A-B-B-C-C after enter into octal
+					 * dtr mode for Macronix flashes.
+					 */
+					flash->dtr_idcode = id & 0xFFU;
+					flash->dtr_idcode |= (id & 0xFFU) << 8U;
+					flash->dtr_idcode |= (id & 0xFF00U) << 8U;
+					flash->dtr_idcode |= (id & 0xFF00U) << 16U;
+					flash->dtr_idcode |= (id & 0xFF0000U) << 16U;
+					flash->dtr_idcode |= (id & 0xFF0000U) << 24U;
+					flash->dtr_idcode |= (id & 0xFF000000U) << 24U;
+					flash->dtr_idcode |= (id & 0xFF000000U) << 32U;
+				} else {
+					flash->dtr_idcode = id;
+				}
+			}
+		}
+
+		if (id == flash->str_idcode) {
+			return 0;
+		}
+	} else if (id == flash->dtr_idcode) {
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static int stm32_ospi_str_calibration(void)
+{
+	uint32_t dlyb_cr;
+	uint8_t window_len_tcr0 = 0U;
+	uint8_t window_len_tcr1 = 0U;
+	int ret;
+	int ret_tcr0;
+	int ret_tcr1;
+	uint32_t prescaler = mmio_read_32(ospi_base() + _OSPI_DCR2) &
+					  _OSPI_DCR2_PRESCALER;
+	unsigned int bus_freq = div_round_up(clk_get_rate(stm32_ospi.clock_id),
+					     prescaler + 1U);
+
+	/*
+	 * Set memory device at low frequency (50 MHz) and sent
+	 * READID (0x9F) command, save the answer as golden answer
+	 */
+	ret = stm32_ospi_set_speed(_DLYB_FREQ_50MHZ);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = stm32_ospi_readid();
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Set frequency at requested value */
+	ret = stm32_ospi_set_speed(bus_freq);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Calibration needed above 50MHz */
+	if (bus_freq <= _DLYB_FREQ_50MHZ) {
+		return 0;
+	}
+
+	/* Perform calibration */
+	ret = stm32mp_syscfg_dlyb_init(stm32_ospi.bank, false, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* Perform only RX TAP selection */
+	ret_tcr0 = stm32mp_syscfg_dlyb_find_tap(stm32_ospi.bank,
+						 stm32_ospi_readid,
+						 true, &window_len_tcr0);
+	if (ret_tcr0 == 0) {
+		stm32mp_syscfg_dlyb_get_cr(stm32_ospi.bank, &dlyb_cr);
+	}
+
+	stm32mp_syscfg_dlyb_stop(stm32_ospi.bank);
+
+	ret = stm32mp_syscfg_dlyb_init(stm32_ospi.bank, false, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	mmio_setbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_SSHIFT);
+
+	ret_tcr1 = stm32mp_syscfg_dlyb_find_tap(stm32_ospi.bank,
+						 stm32_ospi_readid,
+						 true, &window_len_tcr1);
+	if ((ret_tcr0 != 0) && (ret_tcr1 != 0)) {
+		WARN("Calibration phase failed\n");
+
+		return ret_tcr0;
+	}
+
+	if (window_len_tcr0 >= window_len_tcr1) {
+		mmio_clrbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_SSHIFT);
+		stm32mp_syscfg_dlyb_stop(stm32_ospi.bank);
+
+		ret = stm32mp_syscfg_dlyb_set_cr(stm32_ospi.bank, dlyb_cr);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_dtr_calibration(bool octal_dtr)
+{
+	struct stm32_ospi_flash *flash = &stm32_ospi.flash;
+	uint32_t prescaler;
+	unsigned int bus_freq;
+	int ret;
+
+	if (flash->dtr_calibration_done_once) {
+		return 0;
+	}
+
+	prescaler = mmio_read_32(ospi_base() + _OSPI_DCR2) &
+				 _OSPI_DCR2_PRESCALER;
+	bus_freq = div_round_up(clk_get_rate(stm32_ospi.clock_id),
+				prescaler + 1U);
+
+	stm32mp_syscfg_dlyb_stop(stm32_ospi.bank);
+	mmio_clrbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_SSHIFT);
+	flash->octal_dtr = octal_dtr;
+
+	ret = stm32_ospi_dtr_calibrate(prescaler, bus_freq, stm32_ospi_readid);
+	if (ret != 0) {
+		return ret;
+	}
+
+	flash->dtr_calibration_done_once = true;
+
+	return 0;
+}
+
+static int stm32_ospi_exec_op(const struct spi_mem_op *op)
+{
+	uint8_t fmode = _OSPI_CR_FMODE_INDW;
+
+	if (op->cmd.dtr) {
+		int ret = stm32_ospi_dtr_calibration(op->cmd.nbytes == 2U);
+
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	if ((op->data.dir == SPI_MEM_DATA_IN) && (op->data.nbytes != 0U)) {
+		fmode = _OSPI_CR_FMODE_INDR;
+	}
+
+	return stm32_ospi_send(op, fmode);
+}
+
+static int stm32_ospi_dirmap_read(const struct spi_mem_op *op)
+{
+	size_t addr_max;
+	uint8_t fmode = _OSPI_CR_FMODE_INDR;
+
+	if (op->cmd.dtr) {
+		int ret = stm32_ospi_dtr_calibration(op->cmd.nbytes == 2U);
+
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	addr_max = op->addr.val + op->data.nbytes + 1U;
+	if ((addr_max < stm32_ospi.mm_size) && (op->addr.buswidth != 0U)) {
+		fmode = _OSPI_CR_FMODE_MM;
+	}
+
+	return stm32_ospi_send(op, fmode);
+}
+
+static int stm32_ospi_claim_bus(unsigned int cs)
+{
+	struct stm32_ospi_flash *flash = &stm32_ospi.flash;
+	uint32_t cr;
+	int ret = 0;
+
+	if (cs >= _OSPI_MAX_CHIP) {
+		return -ENODEV;
+	}
+
+	/* Set chip select and enable the controller */
+	cr = _OSPI_CR_EN;
+	if (cs == 1U) {
+		cr |= _OSPI_CR_CSSEL;
+	}
+
+	mmio_clrsetbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_CSSEL, cr);
+
+	/* Calibration is done once */
+	if (!flash->str_calibration_done_once) {
+		stm32mp_syscfg_dlyb_stop(stm32_ospi.bank);
+		mmio_clrbits_32(ospi_base() + _OSPI_TCR, _OSPI_TCR_SSHIFT);
+
+		if (stm32_ospi_str_calibration() != 0) {
+			WARN("Set flash frequency to a safe value (%u Hz)\n",
+			     _DLYB_FREQ_50MHZ);
+
+			stm32mp_syscfg_dlyb_stop(stm32_ospi.bank);
+			mmio_clrbits_32(ospi_base() + _OSPI_TCR,
+					_OSPI_TCR_SSHIFT);
+
+			ret = stm32_ospi_set_speed(_DLYB_FREQ_50MHZ);
+		}
+
+		flash->str_calibration_done_once = true;
+	}
+
+	return ret;
+}
+
+static void stm32_ospi_release_bus(void)
+{
+	mmio_clrbits_32(ospi_base() + _OSPI_CR, _OSPI_CR_EN);
+}
+
+static int stm32_ospi_set_mode(unsigned int mode)
+{
+	int ret;
+
+	if ((mode & SPI_CS_HIGH) != 0U) {
+		return -ENODEV;
+	}
+
+	ret = stm32_ospi_wait_for_not_busy();
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (((mode & SPI_CPHA) != 0U) && ((mode & SPI_CPOL) != 0U)) {
+		mmio_setbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_CKMODE);
+	} else if (((mode & SPI_CPHA) == 0U) && ((mode & SPI_CPOL) == 0U)) {
+		mmio_clrbits_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_CKMODE);
+	} else {
+		return -ENODEV;
+	}
+
+#if DEBUG
+	VERBOSE("%s: mode=0x%x\n", __func__, mode);
+
+	if ((mode & SPI_RX_OCTAL) != 0U) {
+		VERBOSE("rx: octal\n");
+	} else if ((mode & SPI_RX_QUAD) != 0U) {
+		VERBOSE("rx: quad\n");
+	} else if ((mode & SPI_RX_DUAL) != 0U) {
+		VERBOSE("rx: dual\n");
+	} else {
+		VERBOSE("rx: single\n");
+	}
+
+	if ((mode & SPI_TX_OCTAL) != 0U) {
+		VERBOSE("tx: octal\n");
+	} else if ((mode & SPI_TX_QUAD) != 0U) {
+		VERBOSE("tx: quad\n");
+	} else if ((mode & SPI_TX_DUAL) != 0U) {
+		VERBOSE("tx: dual\n");
+	} else {
+		VERBOSE("tx: single\n");
+	}
+#endif
+
+	return 0;
+}
+
+static bool stm32_ospi_mem_supports_op(const struct spi_mem_op *op)
+{
+	if ((op->data.buswidth > 8U) || (op->addr.buswidth > 8U) ||
+	    (op->dummy.buswidth > 8U) || (op->cmd.buswidth > 8U)) {
+		return false;
+	}
+
+	if ((op->cmd.nbytes > 4U) || (op->addr.nbytes > 4U)) {
+		return false;
+	}
+
+	if ((!op->dummy.dtr && (op->dummy.nbytes > 32U)) ||
+	    (op->dummy.dtr && (op->dummy.nbytes > 64U))) {
+		return false;
+	}
+
+	if (!op->cmd.dtr && !op->addr.dtr && !op->dummy.dtr && !op->data.dtr) {
+		return spi_mem_default_supports_op(op);
+	}
+
+	return spi_mem_dtr_supports_op(op);
+}
+
+static const struct spi_bus_ops stm32_ospi_bus_ops = {
+	.claim_bus = stm32_ospi_claim_bus,
+	.release_bus = stm32_ospi_release_bus,
+	.set_speed = stm32_ospi_set_speed,
+	.set_mode = stm32_ospi_set_mode,
+	.exec_op = stm32_ospi_exec_op,
+	.dirmap_read = stm32_ospi_dirmap_read,
+	.supports_op = stm32_ospi_mem_supports_op,
+};
+#endif /* STM32MP_HYPERFLASH */
+
+int stm32_ospi_init(void)
+{
+	int iom_node;
+	int ospi_node;
+#if !STM32MP_HYPERFLASH
+	int flash_node;
+	int nflash = 0;
+#endif /* STM32MP_HYPERFLASH */
+	int ret;
+	int len;
+	const fdt32_t *cuint;
+	void *fdt = NULL;
+	unsigned int i;
+	unsigned int nb_ospi_nodes = 0U;
+	unsigned int reset_id;
+	uintptr_t bank_address[_OMM_MAX_OSPI] = { 0U, 0U };
+	uintptr_t mm_base;
+	uint8_t bank_assigned = 0U;
+	uint8_t bank;
+	size_t mm_size;
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	iom_node = fdt_node_offset_by_compatible(fdt, -1, _DT_IOM_COMPAT);
+	if (iom_node < 0) {
+		return iom_node;
+	}
+
+	if (fdt_get_status(iom_node) == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	ret = fdt_get_reg_props_by_name(fdt, iom_node, "omm_mm",
+					&mm_base, &mm_size);
+	if (ret != 0) {
+		return ret;
+	}
+
+	cuint = fdt_getprop(fdt, iom_node, "ranges", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	for (i = 0U; i < _OMM_MAX_OSPI; i++) {
+		bank = fdt32_to_cpu(*cuint);
+		if ((bank >= _OMM_MAX_OSPI) ||
+		    ((bank_assigned & BIT(bank)) != 0U)) {
+			return -FDT_ERR_BADVALUE;
+		}
+
+		bank_assigned |= BIT(bank);
+		bank_address[bank] = fdt32_to_cpu(*(cuint + 2U));
+		cuint += 4U;
+	}
+
+	if (dt_set_pinctrl_config(iom_node) != 0) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	fdt_for_each_subnode(ospi_node, fdt, iom_node) {
+		nb_ospi_nodes++;
+	}
+
+	if (nb_ospi_nodes != 1U) {
+		WARN("Only one OSPI node supported\n");
+		return -FDT_ERR_BADVALUE;
+	}
+
+	/* Parse OSPI controller node */
+	ospi_node = fdt_node_offset_by_compatible(fdt, iom_node,
+						  _DT_OSPI_COMPAT);
+	if (ospi_node < 0) {
+		return ospi_node;
+	}
+
+	if (fdt_get_status(ospi_node) == DT_DISABLED) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, ospi_node, "reg", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	bank = fdt32_to_cpu(*cuint);
+	if (bank >= _OMM_MAX_OSPI) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	stm32_ospi.reg_base = fdt32_to_cpu(*(cuint + 1U)) + bank_address[bank];
+	stm32_ospi.mm_size = stm32mp_syscfg_get_mm_size(bank);
+	stm32_ospi.mm_base = bank == 0U ?
+			     mm_base : mm_base + mm_size - stm32_ospi.mm_size;
+	stm32_ospi.bank = bank;
+
+	cuint = fdt_getprop(fdt, ospi_node, "clocks", NULL);
+	if (cuint == NULL) {
+		return -FDT_ERR_BADVALUE;
+	}
+
+	cuint++;
+	stm32_ospi.clock_id = (unsigned long)fdt32_to_cpu(*cuint);
+	clk_enable(stm32_ospi.clock_id);
+
+	cuint = fdt_getprop(fdt, ospi_node, "resets", &len);
+	if (cuint != NULL) {
+		cuint++;
+
+		/* Reset: array of <phandle, reset_id> */
+		for (i = 0U;
+		     i < ((uint32_t)len / (sizeof(uint32_t) * _OSPI_MAX_RESET));
+		     i++, cuint += _OSPI_MAX_RESET) {
+			reset_id = (unsigned int)fdt32_to_cpu(*cuint);
+
+			ret = stm32mp_reset_assert(reset_id, _TIMEOUT_US_1_MS);
+			if (ret != 0) {
+				panic();
+			}
+
+			ret = stm32mp_reset_deassert(reset_id,
+						     _TIMEOUT_US_1_MS);
+			if (ret != 0) {
+				panic();
+			}
+		}
+	}
+
+	mmio_write_32(ospi_base() + _OSPI_DCR1, _OSPI_DCR1_DEVSIZE);
+
+#if STM32MP_HYPERFLASH
+	/* Init Hyperflash framework */
+	hyperflash_ctrl_init(&stm32_ospi_ctrl_ops);
+
+	return stm32_ospi_hb_init(fdt, ospi_node);
+#else /* STM32MP_HYPERFLASH */
+	/* Find memory model on each child node (SPI NOR or SPI NAND) */
+	fdt_for_each_subnode(flash_node, fdt, ospi_node) {
+		nflash++;
+	}
+
+	if (nflash != 1) {
+		ERROR("Only one SPI device is currently supported\n");
+		return -EINVAL;
+	}
+
+	if (fdt_node_offset_by_compatible(fdt, ospi_node,
+					  "jedec,spi-nor") >= 0) {
+		struct stm32_ospi_flash *flash = &stm32_ospi.flash;
+
+		flash->is_spi_nor = true;
+	}
+
+	return spi_mem_init_slave(fdt, ospi_node, &stm32_ospi_bus_ops);
+#endif /* STM32MP_HYPERFLASH */
+};
diff --git a/drivers/st/uart/aarch32/stm32_console.S b/drivers/st/uart/aarch32/stm32_console.S
index e3e0e67d39..43039fdc71 100644
--- a/drivers/st/uart/aarch32/stm32_console.S
+++ b/drivers/st/uart/aarch32/stm32_console.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -148,17 +148,15 @@ register_fail:
 	pop	{r4, pc}
 endfunc console_stm32_register
 
-	/* ---------------------------------------------------------------
+	/* --------------------------------------------------------
 	 * int console_core_putc(int c, uintptr_t base_addr)
-	 *
-	 * Function to output a character over the console. It returns the
-	 * character printed on success or -1 on error.
-	 *
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
 	 * In : r0 - character to be printed
 	 *      r1 - console base address
 	 * Out : return -1 on error else return character.
-	 * Clobber list : r2
-	 * ---------------------------------------------------------------
+	 * Clobber list : r2, r3
+	 * --------------------------------------------------------
 	 */
 func console_stm32_core_putc
 	/* Check the input parameter */
@@ -166,13 +164,19 @@ func console_stm32_core_putc
 	beq	putc_error
 
 	/* Check Transmit Data Register Empty */
+	mov	r3, #USART_TIMEOUT
 txe_loop:
+	subs	r3, r3, #1
+	beq	putc_error
 	ldr	r2, [r1, #USART_ISR]
 	tst	r2, #USART_ISR_TXE
 	beq	txe_loop
 	str	r0, [r1, #USART_TDR]
 	/* Check transmit complete flag */
+	mov	r3, #USART_TIMEOUT
 tc_loop:
+	subs	r3, r3, #1
+	beq	putc_error
 	ldr	r2, [r1, #USART_ISR]
 	tst	r2, #USART_ISR_TC
 	beq	tc_loop
@@ -226,7 +230,7 @@ endfunc console_stm32_core_getc
 	 *
 	 * In : r0 - console base address
 	 * Out : void.
-	 * Clobber list : r0, r1
+	 * Clobber list : r0, r1, r2
 	 * ---------------------------------------------------------------
 	 */
 func console_stm32_core_flush
@@ -234,11 +238,19 @@ func console_stm32_core_flush
 	cmp	r0, #0
 	ASM_ASSERT(ne)
 #endif /* ENABLE_ASSERTIONS */
+	/* Skip flush if UART is not enabled */
+	ldr	r1, [r0, #USART_CR1]
+	tst	r1, #USART_CR1_UE
+	beq	1f
 	/* Check Transmit Data Register Empty */
+	mov	r2, #USART_TIMEOUT
 txe_loop_3:
+	subs	r2, r2, #1
+	beq	1f
 	ldr	r1, [r0, #USART_ISR]
 	tst	r1, #USART_ISR_TXE
 	beq	txe_loop_3
+1:
 	bx	lr
 endfunc console_stm32_core_flush
 
diff --git a/drivers/st/uart/aarch64/stm32_console.S b/drivers/st/uart/aarch64/stm32_console.S
new file mode 100644
index 0000000000..8902f48df3
--- /dev/null
+++ b/drivers/st/uart/aarch64/stm32_console.S
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include <asm_macros.S>
+#include <assert_macros.S>
+#include <console_macros.S>
+#include <drivers/st/stm32_console.h>
+#include <drivers/st/stm32_uart_regs.h>
+
+#define USART_TIMEOUT		0x1000
+
+	/*
+	 * "core" functions are low-level implementations that don't require
+	 * writeable memory and are thus safe to call in BL1 crash context.
+	 */
+	.globl	console_stm32_core_init
+	.globl	console_stm32_core_putc
+	.globl	console_stm32_core_getc
+	.globl	console_stm32_core_flush
+
+	.globl	console_stm32_putc
+	.globl	console_stm32_flush
+
+
+
+	/* -----------------------------------------------------------------
+	 * int console_core_init(uintptr_t base_addr,
+	 *			 unsigned int uart_clk,
+	 *			 unsigned int baud_rate)
+	 *
+	 * Function to initialize the console without a C Runtime to print
+	 * debug information. This function will be accessed by console_init
+	 * and crash reporting.
+	 *
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * Out: return 1 on success else 0 on error
+	 * Clobber list : x1, x2, x3, x4
+	 * -----------------------------------------------
+	 */
+func console_stm32_core_init
+	/* Check the input base address */
+	cbz	x0, core_init_fail
+#if !defined(IMAGE_BL2)
+#if STM32MP_RECONFIGURE_CONSOLE
+	/* UART clock rate is set to 0 in BL32, skip init in that case */
+	cbz	x1, 1f
+#else /* STM32MP_RECONFIGURE_CONSOLE */
+	/* Skip UART initialization if it is already enabled */
+	ldr	w3, [x0, #USART_CR1]
+	tst	w3, #USART_CR1_UE
+	b.ne	1f
+#endif /* STM32MP_RECONFIGURE_CONSOLE */
+#endif /* IMAGE_BL2 */
+	/* Check baud rate and uart clock for sanity */
+	cbz	w1, core_init_fail
+	cbz	w2, core_init_fail
+	/* Disable UART */
+	ldr	w3, [x0, #USART_CR1]
+	mov	w4, #USART_CR1_UE
+	bic	w3, w3, w4
+	str	w3, [x0, #USART_CR1]
+	/* Configure UART */
+	mov	w4, #(USART_CR1_TE)
+	orr	w4, w4, #(USART_CR1_FIFOEN)
+	orr	w3, w3, w4
+	str	w3, [x0, #USART_CR1]
+	ldr	w3, [x0, #USART_CR2]
+	mov	w4, #USART_CR2_STOP
+	bic	w3, w3, w4
+	str	w3, [x0, #USART_CR2]
+	/* Divisor =  (Uart clock + (baudrate / 2)) / baudrate */
+	lsr	w3, w2, #1
+	add	w3, w1, w3
+	udiv	w3, w3, w2
+	cmp	w3, #16
+	b.hi	2f
+	/* Oversampling 8 */
+	/* Divisor =  (2 * Uart clock + (baudrate / 2)) / baudrate */
+	lsr	w3, w2, #1
+	add	w3, w3, w1, lsl #1
+	udiv	w3, w3, w2
+	and	w1, w3, #USART_BRR_DIV_FRACTION
+	lsr	w1, w1, #1
+	bic	w3, w3, #USART_BRR_DIV_FRACTION
+	orr	w3, w3, w1
+	ldr	w1, [x0, #USART_CR1]
+	orr	w1, w1, #USART_CR1_OVER8
+	str	w1, [x0, #USART_CR1]
+2:
+	str	w3, [x0, #USART_BRR]
+	/* Enable UART */
+	ldr	w3, [x0, #USART_CR1]
+	mov	w4, #USART_CR1_UE
+	orr	w3, w3, w4
+	str	w3, [x0, #USART_CR1]
+	/* Check TEACK bit */
+	mov	w2, #USART_TIMEOUT
+teack_loop:
+	subs	w2, w2, #1
+	beq	core_init_fail
+	ldr	w3, [x0, #USART_ISR]
+	tst	w3, #USART_ISR_TEACK
+	beq	teack_loop
+1:
+	mov	w0, #1
+	ret
+core_init_fail:
+	mov	w0, wzr
+	ret
+endfunc console_stm32_core_init
+
+	.globl console_stm32_register
+
+	/* -------------------------------------------------------
+	 * int console_stm32_register(uintptr_t baseaddr,
+	 *     uint32_t clock, uint32_t baud,
+	 *     console_t *console);
+	 * Function to initialize and register a new STM32
+	 * console. Storage passed in for the console struct
+	 * *must* be persistent (i.e. not from the stack).
+	 * In: x0 - UART register base address
+	 *     w1 - UART clock in Hz
+	 *     w2 - Baud rate
+	 *     x3 - pointer to empty console_t struct
+	 * Out: return 1 on success, 0 on error
+	 * Clobber list : x0, x1, x2, x6, x7, x14
+	 * -------------------------------------------------------
+	 */
+func console_stm32_register
+	mov	x7, x30
+	mov	x6, x3
+	cbz	x6, register_fail
+	str	x0, [x6, #CONSOLE_T_BASE]
+
+	bl	console_stm32_core_init
+	cbz	x0, register_fail
+
+	mov	x0, x6
+	mov	x30, x7
+	finish_console_register stm32 putc=1, getc=0, flush=1
+
+register_fail:
+	ret	x7
+endfunc console_stm32_register
+
+	/* --------------------------------------------------------
+	 * int console_stm32_core_putc(int c, uintptr_t base_addr)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_stm32_core_putc
+#if ENABLE_ASSERTIONS
+	cmp	x1, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+
+	/* Check Transmit Data Register Empty */
+txe_loop:
+	ldr	w2, [x1, #USART_ISR]
+	tst	w2, #USART_ISR_TXE
+	beq	txe_loop
+	str	w0, [x1, #USART_TDR]
+	/* Check transmit complete flag */
+tc_loop:
+	ldr	w2, [x1, #USART_ISR]
+	tst	w2, #USART_ISR_TC
+	beq	tc_loop
+	ret
+endfunc console_stm32_core_putc
+
+	/* --------------------------------------------------------
+	 * int console_stm32_putc(int c, console_t *console)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - pointer to console_t structure
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_stm32_putc
+#if ENABLE_ASSERTIONS
+	cmp	x1, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+	ldr	x1, [x1, #CONSOLE_T_BASE]
+	b	console_stm32_core_putc
+endfunc console_stm32_putc
+
+	/* ---------------------------------------------
+	 * int console_stm32_core_getc(uintptr_t base_addr)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 if no character is available.
+	 * In : x0 - console base address
+	 * Out: w0 - character if available, else -1
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_stm32_core_getc
+	/* Not supported */
+	mov	w0, #-1
+	ret
+endfunc console_stm32_core_getc
+
+	/* ---------------------------------------------
+	 * int console_stm32_core_flush(uintptr_t base_addr)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - console base address
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_stm32_core_flush
+#if ENABLE_ASSERTIONS
+	cmp	x0, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+	/* Check Transmit Data Register Empty */
+txe_loop_3:
+	ldr	w1, [x0, #USART_ISR]
+	tst	w1, #USART_ISR_TXE
+	beq	txe_loop_3
+	mov	w0, #0
+	ret
+endfunc console_stm32_core_flush
+
+	/* ---------------------------------------------
+	 * int console_stm32_flush(console_t *console)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - pointer to console_t structure
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_stm32_flush
+#if ENABLE_ASSERTIONS
+	cmp	x0, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+	ldr	x0, [x0, #CONSOLE_T_BASE]
+	b	console_stm32_core_flush
+endfunc console_stm32_flush
diff --git a/drivers/st/usb/stm32mp1_usb.c b/drivers/st/usb/stm32mp1_usb.c
index 9a4969036c..78890f5eb2 100644
--- a/drivers/st/usb/stm32mp1_usb.c
+++ b/drivers/st/usb/stm32mp1_usb.c
@@ -4,6 +4,7 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <assert.h>
 #include <stdint.h>
 
 #include <arch_helpers.h>
@@ -794,7 +795,7 @@ static enum usb_action usb_dwc2_it_handler(void *handle, uint32_t *param)
 	uint32_t epint;
 	uint32_t epnum;
 	uint32_t temp;
-	enum usb_status ret;
+	enum usb_status __unused ret;
 
 	if (usb_dwc2_get_mode(handle) != USB_OTG_MODE_DEVICE) {
 		return USB_NOTHING;
@@ -947,9 +948,7 @@ static enum usb_action usb_dwc2_it_handler(void *handle, uint32_t *param)
 
 		/* Setup EP0 to receive SETUP packets */
 		ret = usb_dwc2_ep0_out_start(handle);
-		if (ret != USBD_OK) {
-			return ret;
-		}
+		assert(ret == USBD_OK);
 
 		mmio_write_32(usb_base_addr + OTG_GINTSTS, OTG_GINTSTS_USBRST);
 
@@ -959,9 +958,7 @@ static enum usb_action usb_dwc2_it_handler(void *handle, uint32_t *param)
 	/* Handle enumeration done interrupt */
 	if ((usb_dwc2_read_int(handle) & OTG_GINTSTS_ENUMDNE) != 0U) {
 		ret = usb_dwc2_activate_setup(handle);
-		if (ret != USBD_OK) {
-			return ret;
-		}
+		assert(ret == USBD_OK);
 
 		mmio_clrbits_32(usb_base_addr + OTG_GUSBCFG, OTG_GUSBCFG_TRDT);
 
diff --git a/drivers/st/usb_dwc3/usb_dwc3.c b/drivers/st/usb_dwc3/usb_dwc3.c
new file mode 100644
index 0000000000..03735658eb
--- /dev/null
+++ b/drivers/st/usb_dwc3/usb_dwc3.c
@@ -0,0 +1,2414 @@
+/*
+ * Copyright (c) 2015-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/usb_dwc3.h>
+#include <lib/mmio.h>
+#include <lib/utils.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+
+#include "usb_dwc3_regs.h"
+
+/*
+ * @brief USB EP Type
+ */
+#define EP_TYPE_CTRL	0U
+#define EP_TYPE_ISOC	1U
+#define EP_TYPE_BULK	2U
+#define EP_TYPE_INTR	3U
+#define EP_TYPE_MSK	3U
+
+#define USB_DWC3_GLOBAL_BASE	0xc100
+#define USB_DWC3_DEVICE_BASE	0xc700
+
+/* Global Registers */
+#define DWC3_GSBUSCFG0	_DWC3_GSBUSCFG0
+#define DWC3_GSBUSCFG1	_DWC3_GSBUSCFG1
+#define DWC3_GTXTHRCFG	_DWC3_GTXTHRCFG
+#define DWC3_GRXTHRCFG	_DWC3_GRXTHRCFG
+#define DWC3_GCTL	_DWC3_GCTL
+#define DWC3_GEVTEN	_DWC3_GEVTEN
+#define DWC3_GSTS	_DWC3_GSTS
+#define DWC3_GUCTL1	_DWC3_GUCTL1
+#define DWC3_GSNPSID	_DWC3_GSNPSID
+#define DWC3_GGPIO	_DWC3_GGPIO
+#define DWC3_GUID	_DWC3_GUID
+#define DWC3_GUCTL	_DWC3_GUCTL
+#define DWC3_GBUSERRADDR0	_DWC3_GBUSERRADDRLO
+#define DWC3_GBUSERRADDR1	_DWC3_GBUSERRADDRHI
+#define DWC3_GPRTBIMAP0	_DWC3_GPRTBIMAPLO
+#define DWC3_GPRTBIMAP1	_DWC3_GPRTBIMAPHI
+#define DWC3_GHWPARAMS0	_DWC3_GHWPARAMS0
+#define DWC3_GHWPARAMS1	_DWC3_GHWPARAMS1
+#define DWC3_GHWPARAMS2	_DWC3_GHWPARAMS2
+#define DWC3_GHWPARAMS3	_DWC3_GHWPARAMS3
+#define DWC3_GHWPARAMS4	_DWC3_GHWPARAMS4
+#define DWC3_GHWPARAMS5	_DWC3_GHWPARAMS5
+#define DWC3_GHWPARAMS6	_DWC3_GHWPARAMS6
+#define DWC3_GHWPARAMS7	_DWC3_GHWPARAMS7
+#define DWC3_GDBGFIFOSPACE	_DWC3_GDBGFIFOSPACE
+#define DWC3_GDBGLTSSM	_DWC3_GDBGLTSSM
+#define DWC3_GPRTBIMAP_HS0	_DWC3_GPRTBIMAP_HSLO
+#define DWC3_GPRTBIMAP_HS1	_DWC3_GPRTBIMAP_HSHI
+#define DWC3_GPRTBIMAP_FS0	_DWC3_GPRTBIMAP_FSLO
+#define DWC3_GPRTBIMAP_FS1	_DWC3_GPRTBIMAP_FSHI
+
+#define DWC3_GUSB2PHYCFG(n)	(_DWC3_GUSB2PHYCFG + (4UL * (n)))
+#define DWC3_GUSB2I2CCTL(n)	(_DWC3_GUSB2I2CCTL + (4UL * (n)))
+
+#define DWC3_GUSB2PHYACC(n)	(_DWC3_GUSB2PHYACC + (4UL * (n)))
+
+#define DWC3_GUSB3PIPECTL(n)	(_DWC3_GUSB3PIPECTL + (4UL * (n)))
+
+#define DWC3_GTXFIFOSIZ(n)	(_DWC3_GTXFIFOSIZ0 + (4UL * (n)))
+#define DWC3_GRXFIFOSIZ(n)	(_DWC3_GRXFIFOSIZ0 + (4UL * (n)))
+
+#define DWC3_GEVNTADRLO(n)	(_DWC3_GEVNTADRLO + (16UL * (n)))
+#define DWC3_GEVNTADRHI(n)	(_DWC3_GEVNTADRHI + (16UL * (n)))
+#define DWC3_GEVNTSIZ(n)	(_DWC3_GEVNTSIZ + (16UL * (n)))
+#define DWC3_GEVNTCOUNT(n)	(_DWC3_GEVNTCOUNT + (16UL * (n)))
+
+#define DWC3_GUSB2PHYACC_ADDR(n)	((n) << USB3_GUSB2PHYACC_ULPI_REGADDR_POS)
+#define DWC3_GUSB2PHYACC_EXTEND_ADDR(n)	((n) << USB3_GUSB2PHYACC_ULPI_EXTREGADDR_POS)
+#define DWC3_GUSB2PHYACC_DATA(n)	((n) & USB3_GUSB2PHYACC_ULPI_REGDATA_MSK)
+
+/* Device Registers */
+#define DWC3_DCFG	_DWC3_DCFG
+#define DWC3_DCTL	_DWC3_DCTL
+#define DWC3_DEVTEN	_DWC3_DEVTEN
+#define DWC3_DSTS	_DWC3_DSTS
+#define DWC3_DGCMDPAR	_DWC3_DGCMDPAR
+#define DWC3_DGCMD	_DWC3_DGCMD
+#define DWC3_DALEPENA	_DWC3_DALEPENA
+#define DWC3_DEPCMDPAR2(n)	(_DWC3_DEPCMDPAR2 + (16UL * (n)))
+#define DWC3_DEPCMDPAR1(n)	(_DWC3_DEPCMDPAR1 + (16UL * (n)))
+#define DWC3_DEPCMDPAR0(n)	(_DWC3_DEPCMDPAR0 + (16UL * (n)))
+#define DWC3_DEPCMD(n)	(_DWC3_DEPCMD + (16UL * (n)))
+
+/* The EP number goes 0..31 so ep0 is always out and ep1 is always in */
+#define DWC3_DALEPENA_EP(n)	(1UL << (n))
+
+/*
+ * @brief USB EP Type
+ */
+#define EP_TYPE_CTRL	0U
+#define EP_TYPE_ISOC	1U
+#define EP_TYPE_BULK	2U
+#define EP_TYPE_INTR	3U
+#define EP_TYPE_MSK	3U
+
+/* Event Size */
+#define USB_DWC3_EVENT_SIZE	4U
+
+/* USB_ExecuteDevEPCmd::USB_DWC3_EPCmd */
+#define USB_DWC3_DEPCMD_DEPSTARTCFG	(0x09UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_ENDTRANSFER	(0x08UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_UPDATETRANSFER	(0x07UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_STARTTRANSFER	(0x06UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_CLEARSTALL	(0x05UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_SETSTALL	(0x04UL << USB3_DEPCMD_CMDTYP_POS)
+/* This applies for core versions 1.94a and later */
+#define USB_DWC3_DEPCMD_GETEPSTATE	(0x03UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_SETTRANSFRESOURCE	(0x02UL << USB3_DEPCMD_CMDTYP_POS)
+#define USB_DWC3_DEPCMD_SETEPCONFIG	(0x01UL << USB3_DEPCMD_CMDTYP_POS)
+
+/* USB_ConfigureEP::action */
+#define USB_DWC3_DEPCFG_ACTION_INIT	0
+#define USB_DWC3_DEPCFG_ACTION_RESTORE	1
+#define USB_DWC3_DEPCFG_ACTION_MODIFY	2
+
+/* USB_ReadEndpointEventType @return EPEventType */
+#define USB_DWC3_DEPEVT_XFERCOMPLETE	0x01
+#define USB_DWC3_DEPEVT_XFERINPROGRESS	0x02
+#define USB_DWC3_DEPEVT_XFERNOTREADY	0x03
+#define USB_DWC3_DEPEVT_RXTXFIFOEVT	0x04
+#define USB_DWC3_DEPEVT_STREAMEVT	0x06
+#define USB_DWC3_DEPEVT_EPCMDCMPLT	0x07
+
+/* USB_ReadEndpointEventStatus @return EPEventStatus */
+#define USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA	0x01
+#define USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS	0x02
+
+/* USB_ReadDeviceEventType @return DevEventType */
+#define USB_DWC3_DEVICE_EVENT_DISCONNECT	0
+#define USB_DWC3_DEVICE_EVENT_RESET	1
+#define USB_DWC3_DEVICE_EVENT_CONNECT_DONE	2
+#define USB_DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE	3
+#define USB_DWC3_DEVICE_EVENT_WAKEUP	4
+#define USB_DWC3_DEVICE_EVENT_HIBER_REQ	5
+#define USB_DWC3_DEVICE_EVENT_EOPF	6
+#define USB_DWC3_DEVICE_EVENT_SOF	7
+#define USB_DWC3_DEVICE_EVENT_L1SUSPEND	8
+#define USB_DWC3_DEVICE_EVENT_ERRATIC_ERROR	9
+#define USB_DWC3_DEVICE_EVENT_CMD_CMPL	10
+#define USB_DWC3_DEVICE_EVENT_OVERFLOW	11
+#define USB_DWC3_DEVICE_EVENT_L1WAKEUP	14
+
+#define USB_DWC3_TRBSTS_OK	0
+#define USB_DWC3_TRBSTS_MISSED_ISOC	1
+#define USB_DWC3_TRBSTS_SETUP_PENDING	2
+#define USB_DWC3_TRBSTS_XFER_IN_PROG	4
+
+#define USB_DWC3_SPEED_SUPER	0U
+#define USB_DWC3_SPEED_HIGH	1U
+#define USB_DWC3_SPEED_FULL_48	2U
+#define USB_DWC3_SPEED_FULL	3U
+#define USB_DWC3_SPEED_LOW	4U
+#define USB_DWC3_SPEED_INVALID	15U
+
+#define DWC3_DEPCMD_TYPE_CONTROL	0
+#define DWC3_DEPCMD_TYPE_ISOC	1
+#define DWC3_DEPCMD_TYPE_BULK	2
+#define DWC3_DEPCMD_TYPE_INTR	3
+
+#define DWC3_GCTL_PRTCAP(n)	(((n) & USB3_GCTL_PRTCAPDIR_MSK) >> USB3_GCTL_PRTCAPDIR_POS)
+#define DWC3_GCTL_PRTCAPDIR(n)	((n) << USB3_GCTL_PRTCAPDIR_POS)
+#define DWC3_GCTL_PRTCAP_HOST	1
+#define DWC3_GCTL_PRTCAP_DEVICE	2
+#define DWC3_GCTL_PRTCAP_OTG	3
+
+#define DWC3_DSTS_SUPERSPEED	(4U << USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_HIGHSPEED	(0U << USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_FULLSPEED2	BIT(USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_LOWSPEED	(2U << USB3_DSTS_CONNECTSPD_POS)
+#define DWC3_DSTS_FULLSPEED1	(3U << USB3_DSTS_CONNECTSPD_POS)
+
+#define DWC3_GEVNTCOUNT_MASK	0xfffcU
+#define DWC3_GSNPSID_MASK	0xffff0000
+#define DWC3_GSNPSREV_MASK	0xffff
+
+#define DWC3_DCFG_DEVADDR(addr)	((addr) << 3)
+
+#define DWC3_EVENT_TYPE_DEV	0
+#define DWC3_EVENT_TYPE_CARKIT	3
+#define DWC3_EVENT_TYPE_I2C	4
+
+#define DWC3_DEVICE_EVENT_DISCONNECT	0
+#define DWC3_DEVICE_EVENT_RESET	1
+#define DWC3_DEVICE_EVENT_CONNECT_DONE	2
+#define DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE	3
+#define DWC3_DEVICE_EVENT_WAKEUP	4
+#define DWC3_DEVICE_EVENT_HIBER_REQ	5
+#define DWC3_DEVICE_EVENT_EOPF	6
+#define DWC3_DEVICE_EVENT_SOF	7
+#define DWC3_DEVICE_EVENT_ERRATIC_ERROR	9
+#define DWC3_DEVICE_EVENT_CMD_CMPL	10
+#define DWC3_DEVICE_EVENT_OVERFLOW	11
+
+/* DEPCFG parameter 1 */
+#define DWC3_DEPCFG_INT_NUM(n)	(((n) & 0x1f) << 0)
+#define DWC3_DEPCFG_XFER_COMPLETE_EN	BIT(8)
+#define DWC3_DEPCFG_XFER_IN_PROGRESS_EN	BIT(9)
+#define DWC3_DEPCFG_XFER_NOT_READY_EN	BIT(10)
+#define DWC3_DEPCFG_FIFO_ERROR_EN	BIT(11)
+#define DWC3_DEPCFG_STREAM_EVENT_EN	BIT(13)
+#define DWC3_DEPCFG_BINTERVAL_M1(n)	(((n) & 0xffU) << 16)
+#define DWC3_DEPCFG_STREAM_CAPABLE	BIT(24)
+#define DWC3_DEPCFG_EP_NUMBER(n)	(((n) & 0x1fUL) << 25)
+#define DWC3_DEPCFG_BULK_BASED	BIT(30)
+#define DWC3_DEPCFG_FIFO_BASED	BIT(31)
+
+/* DEPCFG parameter 0 */
+#define DWC3_DEPCFG_EP_TYPE(n)	(((n) & 0x3UL) << 1)
+#define DWC3_DEPCFG_MAX_PACKET_SIZE(n)	(((n) & 0x7ffU) << 3)
+#define DWC3_DEPCFG_FIFO_NUMBER(n)	(((n) & 0x1fUL) << 17)
+#define DWC3_DEPCFG_BURST_SIZE(n)	(((n) & 0xf) << 22)
+#define DWC3_DEPCFG_DATA_SEQ_NUM(n)	((n) << 26)
+/* DEPCFG parameter 1 */
+#define DWC3_DEPCFG_EP_INTR_NUM(n)	((n) & 0x1fUL)
+/* This applies for core versions earlier than 1.94a */
+#define DWC3_DEPCFG_IGN_SEQ_NUM	BIT(31)
+/* These apply for core versions 1.94a and later */
+#define DWC3_DEPCFG_ACTION_INIT	(0U << 30)
+#define DWC3_DEPCFG_ACTION_RESTORE	BIT(30)
+#define DWC3_DEPCFG_ACTION_MODIFY	(2U << 30)
+#define DWC3_DEPCFG_ACTION_VALUE(n)	(((n) & 0x3) << 30)
+
+/* DEPXFERCFG parameter 0 */
+#define DWC3_DEPXFERCFG_NUM_XFER_RES(n)	((n) & 0xffffU)
+
+#define DWC3_DEPCMD_GET_RSC_IDX(x)	(((x) >> USB3_DEPCMD_COMMANDPARAM_POS) & 0x7fU)
+#define DWC3_DEPCMD_STATUS(x)	(((x) & USB3_DEPCMD_CMDSTATUS_MSK) >> 12)
+#define DWC3_DGCMD_STATUS(n)	(((n) & USB3_DGCMD_CMDSTATUS_MSK) >> USB3_DGCMD_CMDSTATUS_POS)
+
+#define DWC3_DEPCMD_PARAM(x)	((x) << USB3_DEPCMD_COMMANDPARAM_POS)
+
+#define DWC3_LINK_STATE_SS_U0	0x00 /* in HS, means ON */
+#define DWC3_LINK_STATE_SS_U1	0x01
+#define DWC3_LINK_STATE_SS_U2	0x02 /* in HS, means SLEEP */
+#define DWC3_LINK_STATE_SS_U3	0x03 /* in HS, means SUSPEND */
+#define DWC3_LINK_STATE_SS_DIS	0x04 /* Default State */
+#define DWC3_LINK_STATE_SS_RX_DET	0x05 /* in HS, means Early Suspend */
+#define DWC3_LINK_STATE_SS_INACT	0x06
+#define DWC3_LINK_STATE_SS_POLL	0x07
+#define DWC3_LINK_STATE_SS_RECOV	0x08
+#define DWC3_LINK_STATE_SS_HRESET	0x09
+#define DWC3_LINK_STATE_SS_CMPLY	0x0a
+#define DWC3_LINK_STATE_SS_LPBK	0x0b
+#define DWC3_LINK_STATE_SS_RESET	0x0e
+#define DWC3_LINK_STATE_SS_RESUME	0x0f
+
+#define DWC3_LINK_STATE_ON	0x00U /* in HS, means ON */
+#define DWC3_LINK_STATE_L1	0x02U /* in HS, means SLEEP */
+#define DWC3_LINK_STATE_L2	0x03U /* in HS, means SUSPEND */
+#define DWC3_LINK_STATE_DIS	0x04U /* Default State */
+#define DWC3_LINK_STATE_EARLY_SUS	0x05U /* in HS, means Early Suspend */
+#define DWC3_LINK_STATE_RESET	0x0eU
+#define DWC3_LINK_STATE_RESUME	0x0fU
+
+#define DWC3_DCTL_ULSTCHNG_NO_ACTION	0
+#define DWC3_DCTL_ULSTCHNG_SS_DISABLED	4
+#define DWC3_DCTL_ULSTCHNG_RX_DETECT	5
+#define DWC3_DCTL_ULSTCHNG_SS_INACTIVE	6
+#define DWC3_DCTL_ULSTCHNG_RECOVERY	8
+#define DWC3_DCTL_ULSTCHNG_COMPLIANCE	10
+#define DWC3_DCTL_ULSTCHNG_LOOPBACK	11
+
+#define DWC3_DCTL_ULSTCHNGREQ(n)	(((n) << USB3_DCTL_ULSTCHNGREQ_POS) & \
+					USB3_DCTL_ULSTCHNGREQ_MSK)
+
+#define DWC3_DSTS_USBLNKST(n)	(((n) & USB3_DSTS_USBLNKST_MSK) >> USB3_DSTS_USBLNKST_POS)
+
+/* TRB Length, PCM and Status */
+#define DWC3_TRB_SIZE_MASK	(0x00ffffffU)
+#define DWC3_TRB_SIZE_LENGTH(n)	((n) & DWC3_TRB_SIZE_MASK)
+#define DWC3_TRB_SIZE_PCM1(n)	(((n) & 0x03) << 24)
+#define DWC3_TRB_SIZE_TRBSTS(n)	(((n) & (0x0fU << 28)) >> 28)
+
+#define DWC3_TRBSTS_OK	0
+#define DWC3_TRBSTS_MISSED_ISOC	1
+#define DWC3_TRBSTS_SETUP_PENDING	2
+#define DWC3_TRBSTS_XFER_IN_PROG	4
+
+/* TRB Control */
+#define DWC3_TRB_CTRL_HWO	BIT(0)
+#define DWC3_TRB_CTRL_LST	BIT(1)
+#define DWC3_TRB_CTRL_CHN	BIT(2)
+#define DWC3_TRB_CTRL_CSP	BIT(3)
+#define DWC3_TRB_CTRL_TRBCTL(n)	(((n) & 0x3fU) << 4)
+#define DWC3_TRB_CTRL_ISP_IMI	BIT(10)
+#define DWC3_TRB_CTRL_IOC	BIT(11)
+#define DWC3_TRB_CTRL_SID_SOFN(n)	(((n) & 0xffffU) << 14)
+
+#define DWC3_TRBCTL_NORMAL	DWC3_TRB_CTRL_TRBCTL(1U)
+#define DWC3_TRBCTL_CONTROL_SETUP	DWC3_TRB_CTRL_TRBCTL(2U)
+#define DWC3_TRBCTL_CONTROL_STATUS2	DWC3_TRB_CTRL_TRBCTL(3U)
+#define DWC3_TRBCTL_CONTROL_STATUS3	DWC3_TRB_CTRL_TRBCTL(4U)
+#define DWC3_TRBCTL_CONTROL_DATA	DWC3_TRB_CTRL_TRBCTL(5U)
+#define DWC3_TRBCTL_ISOCHRONOUS_FIRST	DWC3_TRB_CTRL_TRBCTL(6U)
+#define DWC3_TRBCTL_ISOCHRONOUS	DWC3_TRB_CTRL_TRBCTL(7U)
+#define DWC3_TRBCTL_LINK_TRB	DWC3_TRB_CTRL_TRBCTL(8U)
+
+#define MASK(len, pos)	GENMASK_32((len-1) + pos, pos)
+
+/* event */
+#define DWC3_EVT_TYPE_EP	0x0U
+#define DWC3_EVT_TYPE_LEN	0x1
+#define DWC3_EVT_TYPE_BITPOS	0x0
+#define DWC3_EVT_TYPE_MASK	MASK(DWC3_EVT_TYPE_LEN, DWC3_EVT_TYPE_BITPOS)
+#define DWC3_EVT_TYPE_DEVSPEC	0x1U
+#define DWC3_EVT_TYPE_NEP_TYPE_BITPOS	1
+#define DWC3_EVT_TYPE_NEP_TYPE_LEN	7
+#define DWC3_EVT_TYPE_NEP_TYPE_MASK	MASK(DWC3_EVT_TYPE_NEP_TYPE_LEN, \
+					DWC3_EVT_TYPE_NEP_TYPE_BITPOS)
+
+#define DWC3_DEPEVT_XFERCOMPLETE	0x01
+#define DWC3_DEPEVT_XFERINPROGRESS	0x02
+#define DWC3_DEPEVT_XFERNOTREADY	0x03
+#define DWC3_DEPEVT_RXTXFIFOEVT	0x04
+#define DWC3_DEPEVT_STREAMEVT	0x06
+#define DWC3_DEPEVT_EPCMDCMPLT	0x07
+
+#define DWC3_EVT_DEPEVT_TYPE_BITPOS	6
+#define DWC3_EVT_DEPEVT_TYPE_LEN	4
+#define DWC3_EVT_DEPEVT_TYPE_MASK	MASK(DWC3_EVT_DEPEVT_TYPE_LEN, DWC3_EVT_DEPEVT_TYPE_BITPOS)
+
+#define DWC3_EVT_DEPEVT_EPNUM_BITPOS	1
+#define DWC3_EVT_DEPEVT_EPNUM_LEN	5
+#define DWC3_EVT_DEPEVT_EPNUM_MASK	MASK(DWC3_EVT_DEPEVT_EPNUM_LEN, \
+					DWC3_EVT_DEPEVT_EPNUM_BITPOS)
+
+#define DWC3_EVT_DEPEVT_STATUS_BITPOS	12
+#define DWC3_EVT_DEPEVT_STATUS_LEN	4
+#define DWC3_EVT_DEPEVT_STATUS_MASK	MASK(DWC3_EVT_DEPEVT_STATUS_LEN, \
+					DWC3_EVT_DEPEVT_STATUS_BITPOS)
+
+/* Control-only Status */
+#define DWC3_EVT_DEPEVT_STATUS_CONTROL_DATA	1
+#define DWC3_EVT_DEPEVT_STATUS_CONTROL_STATUS	2
+
+#define DWC3_EVT_DEPEVT_PARAM_BITPOS	16
+#define DWC3_EVT_DEPEVT_PARAM_LEN	16
+#define DWC3_EVT_DEPEVT_PARAM_MASK	MASK(DWC3_EVT_DEPEVT_PARAM_LEN, \
+					DWC3_EVT_DEPEVT_PARAM_BITPOS)
+
+#define DWC3_EVT_DEVEVT_TYPE_BITPOS	8
+#define DWC3_EVT_DEVEVT_TYPE_LEN	4
+#define DWC3_EVT_DEVEVT_TYPE_MASK	MASK(DWC3_EVT_DEVEVT_TYPE_LEN, DWC3_EVT_DEVEVT_TYPE_BITPOS)
+
+#define DWC3_EVT_DEVEVT_LNKSTS_BITPOS	16
+#define DWC3_EVT_DEVEVT_LNKSTS_LEN	4
+#define DWC3_EVT_DEVEVT_LNKSTS_MASK	MASK(DWC3_EVT_DEVEVT_LNKSTS_LEN, \
+					DWC3_EVT_DEVEVT_LNKSTS_BITPOS)
+
+/* Bit fields for USB3_GCTL register */
+#define USB3_GCTL_CORESOFTRESET	_DWC3_GCTL_CORESOFTRESET
+#define USB3_GCTL_PRTCAPDIR_POS	_DWC3_GCTL_PRTCAPDIR_SHIFT
+#define USB3_GCTL_PRTCAPDIR_MSK	_DWC3_GCTL_PRTCAPDIR_MASK
+
+/* Bit fields for USB3_GUSB2PHYCFG register */
+#define USB3_GUSB2PHYCFG_ULPI_UTMI_SEL	_DWC3_GUSB2PHYCFG_ULPI_UTMI_SEL
+#define USB3_GUSB2PHYCFG_PHYSOFTRST	_DWC3_GUSB2PHYCFG_PHYSOFTRST
+
+/* Bit fields for USB3_GUSB3PIPECTL register */
+#define USB3_GUSB3PIPECTL_PHYSOFTRST	_DWC3_GUSB3PIPECTL_PHYSOFTRST
+
+/* Bit fields for USB3_GEVNTSIZ register */
+#define USB3_GEVNTSIZ_EVNTINTRPTMASK_MSK	_DWC3_GEVNTSIZ_EVNTINTRPTMASK
+
+/* Bit fields for USB3_DCFG register */
+#define USB3_DCFG_DEVSPD_POS	_DWC3_DCFG_DEVSPD_SHIFT
+#define USB3_DCFG_DEVSPD_MSK	_DWC3_DCFG_DEVSPD_MASK
+#define USB3_DCFG_DEVADDR_POS	_DWC3_DCFG_DEVADDR_SHIFT
+#define USB3_DCFG_DEVADDR_MSK	_DWC3_DCFG_DEVADDR_MASK
+#define USB3_DCFG_INTRNUM_POS	_DWC3_DCFG_INTRNUM_SHIFT
+#define USB3_DCFG_INTRNUM_MSK	_DWC3_DCFG_INTRNUM_MASK
+#define USB3_DCFG_NUMP_POS	_DWC3_DCFG_NUMP_SHIFT
+#define USB3_DCFG_NUMP_MSK	_DWC3_DCFG_NUMP_MASK
+#define USB3_DCFG_LPMCAP	_DWC3_DCFG_LPMCAP
+#define USB3_DCFG_IGNSTRMPP	_DWC3_DCFG_IGNSTRMPP
+
+/* Bit fields for USB3_DCTL register */
+#define USB3_DCTL_TSTCTL_POS	_DWC3_DCTL_TSTCTL_SHIFT
+#define USB3_DCTL_TSTCTL_MSK	_DWC3_DCTL_TSTCTL_MASK
+#define USB3_DCTL_ULSTCHNGREQ_POS	_DWC3_DCTL_ULSTCHNGREQ_SHIFT
+#define USB3_DCTL_ULSTCHNGREQ_MSK	_DWC3_DCTL_ULSTCHNGREQ_MASK
+#define USB3_DCTL_ACCEPTU1ENA	_DWC3_DCTL_ACCEPTU1ENA
+#define USB3_DCTL_INITU1ENA	_DWC3_DCTL_INITU1ENA
+#define USB3_DCTL_ACCEPTU2ENA	_DWC3_DCTL_ACCEPTU2ENA
+#define USB3_DCTL_INITU2ENA	_DWC3_DCTL_INITU2ENA
+#define USB3_DCTL_CSS	_DWC3_DCTL_CSS
+#define USB3_DCTL_CRS	_DWC3_DCTL_CRS
+#define USB3_DCTL_L1HIBERNATIONEN	_DWC3_DCTL_L1HIBERNATIONEN
+#define USB3_DCTL_KEEPCONNECT	_DWC3_DCTL_KEEPCONNECT
+#define USB3_DCTL_LPM_NYET_THRES_POS	_DWC3_DCTL_LPM_NYET_THRES_SHIFT
+#define USB3_DCTL_LPM_NYET_THRES_MSK	_DWC3_DCTL_LPM_NYET_THRES_MASK
+#define USB3_DCTL_HIRDTHRES_POS	_DWC3_DCTL_HIRDTHRES_SHIFT
+#define USB3_DCTL_HIRDTHRES_MSK	_DWC3_DCTL_HIRDTHRES_MASK
+#define USB3_DCTL_CSFTRST	_DWC3_DCTL_CSFTRST
+#define USB3_DCTL_RUN_STOP	_DWC3_DCTL_RUN_STOP
+
+/* Bit fields for USB3_DEVTEN register */
+#define USB3_DEVTEN_DISSCONNEVTEN	_DWC3_DEVTEN_DISSCONNEVTEN
+#define USB3_DEVTEN_USBRSTEVTEN	_DWC3_DEVTEN_USBRSTEVTEN
+#define USB3_DEVTEN_CONNECTDONEEVTEN	_DWC3_DEVTEN_CONNECTDONEEVTEN
+#define USB3_DEVTEN_ULSTCNGEN	_DWC3_DEVTEN_ULSTCNGEN
+#define USB3_DEVTEN_WKUPEVTEN	_DWC3_DEVTEN_WKUPEVTEN
+#define USB3_DEVTEN_HIBERNATIONREQEVTEN	_DWC3_DEVTEN_HIBERNATIONREQEVTEN
+#define USB3_DEVTEN_U3L2L1SUSPEN	_DWC3_DEVTEN_U3L2L1SUSPEN
+#define USB3_DEVTEN_SOFTEVTEN	_DWC3_DEVTEN_SOFTEVTEN
+#define USB3_DEVTEN_L1SUSPEN	_DWC3_DEVTEN_L1SUSPEN
+#define USB3_DEVTEN_ERRTICERREVTEN	_DWC3_DEVTEN_ERRTICERREVTEN
+#define USB3_DEVTEN_CMDCMPLTEN	_DWC3_DEVTEN_CMDCMPLTEN
+#define USB3_DEVTEN_EVNTOVERFLOWEN	_DWC3_DEVTEN_EVNTOVERFLOWEN
+#define USB3_DEVTEN_VENDEVTSTRCVDEN	_DWC3_DEVTEN_VENDEVTSTRCVDEN
+#define USB3_DEVTEN_L1WKUPEVTEN	_DWC3_DEVTEN_L1WKUPEVTEN
+#define USB3_DEVTEN_ECCERREN	_DWC3_DEVTEN_ECCERREN
+
+/* Bit fields for USB3_DSTS register */
+#define USB3_DSTS_CONNECTSPD_POS	_DWC3_DSTS_CONNECTSPD_SHIFT
+#define USB3_DSTS_CONNECTSPD_MSK	_DWC3_DSTS_CONNECTSPD_MASK
+#define USB3_DSTS_CONNECTSPD	_DWC3_DSTS_CONNECTSPD_MASK
+#define USB3_DSTS_SOFFN_POS	_DWC3_DSTS_SOFFN_SHIFT
+#define USB3_DSTS_SOFFN_MSK	_DWC3_DSTS_SOFFN_MASK
+#define USB3_DSTS_RXFIFOEMPTY	_DWC3_DSTS_RXFIFOEMPTY
+#define USB3_DSTS_USBLNKST_POS	_DWC3_DSTS_USBLNKST_SHIFT
+#define USB3_DSTS_USBLNKST_MSK	_DWC3_DSTS_USBLNKST_MASK
+#define USB3_DSTS_DEVCTRLHLT	_DWC3_DSTS_DEVCTRLHLT
+#define USB3_DSTS_COREIDLE	_DWC3_DSTS_COREIDLE
+#define USB3_DSTS_SSS	_DWC3_DSTS_SSS
+#define USB3_DSTS_RSS	_DWC3_DSTS_RSS
+#define USB3_DSTS_SRE	_DWC3_DSTS_SRE
+#define USB3_DSTS_DCNRD	_DWC3_DSTS_DCNRD
+
+/* Bit fields for USB3_DGCMD register */
+#define USB3_DGCMD_CMDTYP_POS	_DWC3_DEPCMD_CMDTYP_SHIFT
+#define USB3_DGCMD_CMDTYP_MSK	_DWC3_DEPCMD_CMDTYP_MASK
+#define USB3_DGCMD_CMDIOC	_DWC3_DGCMD_CMDIOC
+#define USB3_DGCMD_CMDACT	_DWC3_DGCMD_CMDACT
+#define USB3_DGCMD_CMDSTATUS_POS	_DWC3_DGCMD_CMDSTATUS_SHIFT
+#define USB3_DGCMD_CMDSTATUS_MSK	_DWC3_DGCMD_CMDSTATUS_MASK
+
+/* Bit fields for USB3_DEPCMD register */
+#define USB3_DEPCMD_CMDTYP_POS	_DWC3_DEPCMD_CMDTYP_SHIFT
+#define USB3_DEPCMD_CMDTYP_MSK	_DWC3_DEPCMD_CMDTYP_MASK
+#define USB3_DEPCMD_CMDTYP	_DWC3_DEPCMD_CMDTYP_MASK
+#define USB3_DEPCMD_CMDIOC	_DWC3_DEPCMD_CMDIOC
+#define USB3_DEPCMD_CMDACT	_DWC3_DEPCMD_CMDACT
+#define USB3_DEPCMD_HIPRI_FORCERM	_DWC3_DEPCMD_HIPRI_FORCERM
+#define USB3_DEPCMD_CMDSTATUS_POS	_DWC3_DEPCMD_CMDSTATUS_SHIFT
+#define USB3_DEPCMD_CMDSTATUS_MSK	_DWC3_DEPCMD_CMDSTATUS_MASK
+#define USB3_DEPCMD_COMMANDPARAM_POS	_DWC3_DEPCMD_COMMANDPARAM_SHIFT
+#define USB3_DEPCMD_COMMANDPARAM_MSK	_DWC3_DEPCMD_COMMANDPARAM_MASK
+
+/* Bit fields for USB3_DEV_IMOD register */
+#define USB3_DEV_IMOD_DEVICE_IMODI_POS	_DWC3_DEV_IMOD_DEVICE_IMODI_SHIFT
+#define USB3_DEV_IMOD_DEVICE_IMODI_MSK	_DWC3_DEV_IMOD_DEVICE_IMODI_MASK
+#define USB3_DEV_IMOD_DEVICE_IMODC_POS	_DWC3_DEV_IMOD_DEVICE_IMODC_SHIFT
+#define USB3_DEV_IMOD_DEVICE_IMODC_MSK	_DWC3_DEV_IMOD_DEVICE_IMODC_MASK
+
+#define IS_MULTIPLE(x, a)	(((x) % (a)) == 0U)
+#define ALIGN_MULTIPLE(x, a)	((a) * (((x) / (a)) + ((((x) % (a)) != 0U) ? 1U : 0U)))
+#define PAGE_ALIGN(addr, mask)	((addr) & ~(mask))
+
+#define upper_32_bits(n)	((uint32_t)(((n) >> 16) >> 16))
+#define lower_32_bits(n)	((uint32_t)(n))
+
+/* DWC3 IP Parameter */
+#define DWC3_IP_DEVICE_NUM_INT	2
+#define DWC3_IP_NUM_EPS	32U
+#define DWC3_IP_NUM_IN_EPS	16
+
+/* HAL_PCD defines */
+#define __HAL_PCD_ENABLE_INTR(__HANDLE__, intr)	usb_dwc3_enable_eventint(__HANDLE__, intr)
+#define __HAL_PCD_DISABLE_INTR(__HANDLE__, intr)	usb_dwc3_disable_eventint(__HANDLE__, intr)
+
+#define __HAL_PCD_SETUP_REQ_LEN(addr)	(((uint16_t)(*((uint8_t *)(addr) + 6))) + \
+						(((uint16_t)(*((uint8_t *)(addr) + 7))) << 8))
+
+#define __HAL_PCD_SETUP_REQ_DATA_DIR_IN(addr)	((*(uint8_t *)(addr)) & EP_DIR_IN)
+
+#define __HAL_PCD_INCR_EVENT_POS(__HANDLE__, intr, incr) \
+						(__HANDLE__)->intbuffers.evtbufferpos[intr] = \
+						((__HANDLE__)->intbuffers.evtbufferpos[intr] + \
+						 (incr)) % USB_DWC3_EVENT_BUFFER_SIZE
+#define __HAL_PCD_READ_EVENT(__HANDLE__, intr)	*(volatile uint32_t *)&((__HANDLE__)->\
+						intbuffers.evtbuffer_addr[intr][(__HANDLE__)->\
+						intbuffers.evtbufferpos[intr]])
+
+#define __HAL_PCD_EPADDR_TO_PHYEPNUM(ep_addr)	((2U * ((ep_addr) & ADDRESS_MASK)) + \
+						((((ep_addr) & EP_DIR_MASK) != 0U) ? 1U : 0U))
+#define __HAL_PCD_PHYEPNUM_TO_EPADDR(phy_epnum)	(((phy_epnum) / 2U) | \
+						((((phy_epnum) & 0x1U) != 0U) ? EP_DIR_IN : 0U))
+
+#define PCD_DEV_EVENTS_INTR	0 /* Interrupt to use for device events */
+
+#define GET_DWC3EP_FROM_USBEP(__HANDLE__, usb_ep)	*(volatile uint32_t *)&((__HANDLE__)->\
+						intbuffers.evtbuffer_addr[intr][(__HANDLE__)->\
+						intbuffers.evtbufferpos[intr]])
+
+typedef uint32_t dwc3_epcmd_t;
+typedef struct {
+	uint32_t  param2;
+	uint32_t  param1;
+	uint32_t  param0;
+} dwc3_epcmd_params_t;
+
+static uint32_t DWC3_regread(void *base, uint32_t offset)
+{
+	return mmio_read_32((uintptr_t)base + offset);
+}
+
+static void DWC3_regwrite(void *base, uint32_t offset, uint32_t value)
+{
+	mmio_write_32((uintptr_t)base + offset, value);
+}
+
+static void DWC3_regupdateset(void *base, uint32_t offset, uint32_t set_mask)
+{
+	mmio_setbits_32((uintptr_t)base + offset, set_mask);
+}
+
+static void DWC3_regupdateclr(void *base, uint32_t offset, uint32_t clr_mask)
+{
+	mmio_clrbits_32((uintptr_t)base + offset, clr_mask);
+}
+
+static void usb_dwc3_enable_eventint(dwc3_handle_t *handle, uint8_t intr_num)
+{
+	DWC3_regupdateclr(handle->usb_global, DWC3_GEVNTSIZ(intr_num),
+			  USB3_GEVNTSIZ_EVNTINTRPTMASK_MSK);
+}
+
+static void usb_dwc3_disable_eventint(dwc3_handle_t *handle, uint8_t intr_num)
+{
+	DWC3_regupdateset(handle->usb_global, DWC3_GEVNTSIZ(intr_num),
+			  USB3_GEVNTSIZ_EVNTINTRPTMASK_MSK);
+}
+
+static uintptr_t api_mapdmaaddr(uint8_t buf[], uint32_t size, uint8_t to_device)
+{
+	if (to_device) {
+		clean_dcache_range((uintptr_t)buf, size);
+	} else {
+		inv_dcache_range((uintptr_t)buf, size);
+	}
+
+	return (uintptr_t)buf;
+}
+
+static void api_unmapdmaaddr(uintptr_t dma_addr __unused, uint32_t size __unused,
+			     uint8_t to_device __unused)
+{
+}
+
+static uintptr_t api_getdmaaddr(uint8_t buf[], uint32_t size __unused, uint8_t to_device __unused)
+{
+	return (uintptr_t)buf;
+}
+
+__unused static void api_putdmaaddr(uintptr_t dma_addr __unused, uint32_t size __unused,
+				    uint8_t to_device __unused)
+{
+}
+
+static void api_memcpy(void *dest, const void *src, uint32_t n)
+{
+#ifdef AVOID_COMPILER_MEMCPY
+	uint8_t *pcdst = (uint8_t *)dest;
+	uint8_t const *pcsrc = (uint8_t const *)src;
+
+	while (n--) {
+		*pcdst++ = *pcsrc++;
+	}
+#else
+	(void)memcpy(dest, src, n);
+#endif
+}
+
+static uint32_t dwc3_get_trb_ctltype(uint32_t trb_type)
+{
+	uint32_t ret;
+
+	switch (trb_type) {
+	case USB_DWC3_TRBCTL_NORMAL:
+		ret = DWC3_TRBCTL_NORMAL;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_SETUP:
+		ret = DWC3_TRBCTL_CONTROL_SETUP;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_STATUS2:
+		ret = DWC3_TRBCTL_CONTROL_STATUS2;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_STATUS3:
+		ret = DWC3_TRBCTL_CONTROL_STATUS3;
+		break;
+	case USB_DWC3_TRBCTL_CONTROL_DATA:
+		ret = DWC3_TRBCTL_CONTROL_DATA;
+		break;
+	case USB_DWC3_TRBCTL_ISOCHRONOUS_FIRST:
+		ret = DWC3_TRBCTL_ISOCHRONOUS_FIRST;
+		break;
+	case USB_DWC3_TRBCTL_ISOCHRONOUS:
+		ret = DWC3_TRBCTL_ISOCHRONOUS;
+		break;
+	case USB_DWC3_TRBCTL_LINK_TRB:
+		ret = DWC3_TRBCTL_LINK_TRB;
+		break;
+	default:
+		ret = 0U;
+		break;
+	}
+
+	return ret;
+}
+
+static inline const char *dwc3_get_ep_cmd_str(uint32_t cmd)
+{
+	const char *ret;
+
+	switch (cmd & USB3_DEPCMD_CMDTYP_MSK) {
+	case USB_DWC3_DEPCMD_DEPSTARTCFG:
+		ret = "Start New Configuration";
+		break;
+	case USB_DWC3_DEPCMD_ENDTRANSFER:
+		ret = "End Transfer";
+		break;
+	case USB_DWC3_DEPCMD_UPDATETRANSFER:
+		ret = "Update Transfer";
+		break;
+	case USB_DWC3_DEPCMD_STARTTRANSFER:
+		ret = "Start Transfer";
+		break;
+	case USB_DWC3_DEPCMD_CLEARSTALL:
+		ret = "Clear Stall";
+		break;
+	case USB_DWC3_DEPCMD_SETSTALL:
+		ret = "Set Stall";
+		break;
+	case USB_DWC3_DEPCMD_GETEPSTATE:
+		ret = "Get Endpoint State";
+		break;
+	case USB_DWC3_DEPCMD_SETTRANSFRESOURCE:
+		ret = "Set Endpoint Transfer Resource";
+		break;
+	case USB_DWC3_DEPCMD_SETEPCONFIG:
+		ret = "Set Endpoint Configuration";
+		break;
+	default:
+		ret = "UNKNOWN command";
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_execute_dep_cmd(dwc3_handle_t *dwc3_handle, uint8_t phy_epnum,
+					    dwc3_epcmd_t cmd, dwc3_epcmd_params_t *params)
+{
+	uint32_t reg;
+	uint64_t timeout;
+
+	VERBOSE("PHYEP%d: cmd '%s' %08x params %08x %08x %08x\n", phy_epnum,
+		   dwc3_get_ep_cmd_str(cmd), (uint32_t)cmd, (uint32_t)params->param0,
+		   (uint32_t)params->param1, (uint32_t)params->param2);
+
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMDPAR0(phy_epnum), params->param0);
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMDPAR1(phy_epnum), params->param1);
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMDPAR2(phy_epnum), params->param2);
+
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DEPCMD(phy_epnum), cmd | USB3_DEPCMD_CMDACT);
+
+	timeout = timeout_init_us(500); /* usec */
+	do {
+		reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DEPCMD(phy_epnum));
+		/* "Command Complete" */
+		if ((reg & USB3_DEPCMD_CMDACT) == 0U) {
+			VERBOSE("Command Complete --> %u PHYEP%u %x\n", DWC3_DEPCMD_STATUS(reg),
+				   phy_epnum, reg);
+			if (DWC3_DEPCMD_STATUS(reg) != 0U) {
+				return USBD_FAIL;
+			}
+			return USBD_OK;
+		}
+
+		/* Can be called from interrupt context hence cannot wait for Tick */
+		if (timeout_elapsed(timeout)) {
+			ERROR("TIMEOUT Command Complete --> %u PHYEP%lu %x\n",
+				   DWC3_DEPCMD_STATUS(reg), phy_epnum, reg);
+			/* "Command Timed Out" */
+			return USBD_TIMEOUT;
+		}
+	} while (true);
+
+	return USBD_OK;
+}
+
+static bool dwc3_is_ep_enabled(dwc3_handle_t *dwc3_handle, uint8_t phy_epnum)
+{
+	if ((DWC3_regread(dwc3_handle->usb_device,
+			  DWC3_DALEPENA) & DWC3_DALEPENA_EP(phy_epnum)) != 0U) {
+		return true;
+	}
+
+	return false;
+}
+
+static enum usb_status dwc3_ep_start_xfer(dwc3_handle_t *dwc3_handle, struct usbd_ep *ep)
+{
+	enum usb_status ret;
+	dwc3_epcmd_t cmd;
+	dwc3_epcmd_params_t params;
+
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+
+	VERBOSE("%s PHYEP%d %x\n", __func__, dwc3_ep->phy_epnum, dwc3_ep->flags);
+
+	/* Wait for XferNotReady to get the uF interval to srat ISOC transfers */
+	if ((ep->type == EP_TYPE_ISOC) &&
+	    ((dwc3_ep->flags & USB_DWC3_EP_ISOC_START_PENDING) == 0U) &&
+	    ((dwc3_ep->flags & USB_DWC3_EP_ISOC_STARTED) == 0U)) {
+		dwc3_ep->flags |= USB_DWC3_EP_ISOC_START_PENDING;
+		VERBOSE("INSIDE IF\n");
+		return USBD_OK;
+	}
+
+	if ((ep->type == EP_TYPE_ISOC) &&
+	    ((dwc3_ep->flags & USB_DWC3_EP_ISOC_START_PENDING) != 0U)) {
+		dwc3_ep->flags &= ~USB_DWC3_EP_ISOC_START_PENDING;
+	}
+
+	dwc3_ep->trb_addr->bpl = lower_32_bits(dwc3_ep->dma_addr);
+	dwc3_ep->trb_addr->bph = upper_32_bits(dwc3_ep->dma_addr);
+	dwc3_ep->trb_addr->size = DWC3_TRB_SIZE_LENGTH(ep->xfer_len);
+	/* also initializes other bits to 0 */
+	dwc3_ep->trb_addr->ctrl = dwc3_get_trb_ctltype(dwc3_ep->trb_flag & USB_DWC3_TRBCTL_MASK);
+
+	dwc3_ep->trb_addr->ctrl |= ((ep->num == 0U) ? DWC3_TRB_CTRL_ISP_IMI : 0U);
+
+	dwc3_ep->trb_addr->ctrl |= DWC3_TRB_CTRL_IOC;
+
+	if ((ep->type == EP_TYPE_ISOC) && ((dwc3_ep->flags & USB_DWC3_EP_ISOC_STARTED) != 0U)) {
+		cmd = USB_DWC3_DEPCMD_UPDATETRANSFER;
+	} else {
+		cmd = USB_DWC3_DEPCMD_STARTTRANSFER;
+	}
+
+	if (ep->type != EP_TYPE_ISOC) {
+		dwc3_ep->trb_addr->ctrl |= DWC3_TRB_CTRL_LST;
+	}
+
+	dwc3_ep->trb_addr->ctrl |= DWC3_TRB_CTRL_HWO;
+
+	(void)memset(&params, 0x00, sizeof(params));
+
+	if ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER) {
+		params.param0 = upper_32_bits(dwc3_ep->trb_dma_addr);
+		params.param1 = lower_32_bits(dwc3_ep->trb_dma_addr);
+	}
+
+	dwc3_ep->flags |= USB_DWC3_EP_REQ_QUEUED;
+	if ((ep->type == EP_TYPE_ISOC) &&
+	    ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER)) {
+		dwc3_ep->flags |= USB_DWC3_EP_ISOC_STARTED;
+	}
+
+	VERBOSE("EP%d%s: trb %p:%08x:%08x:%08x:%08x length %u %d\n",
+		   ep->num, ep->is_in ? "IN" : "OUT", dwc3_ep->trb_addr,
+		   (uint32_t)dwc3_ep->trb_addr->bph, (uint32_t)dwc3_ep->trb_addr->bpl,
+		   (uint32_t)dwc3_ep->trb_addr->size, (uint32_t)dwc3_ep->trb_addr->ctrl,
+		   ep->xfer_len, dwc3_ep->flags);
+
+	ret = dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, cmd, &params);
+	if (ret != USBD_OK) {
+		dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+		if ((ep->type == EP_TYPE_ISOC) &&
+		    ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER)) {
+			dwc3_ep->flags &= ~USB_DWC3_EP_ISOC_STARTED;
+		}
+		return ret;
+	}
+
+	if ((cmd & USB3_DEPCMD_CMDTYP_MSK) == USB_DWC3_DEPCMD_STARTTRANSFER) {
+		dwc3_ep->resc_idx =
+		(uint8_t)DWC3_DEPCMD_GET_RSC_IDX(DWC3_regread(dwc3_handle->usb_device,
+							      DWC3_DEPCMD(dwc3_ep->phy_epnum)));
+	}
+
+	return ret;
+}
+
+static enum usb_status usb_dwc3_ep_start_xfer(void *handle, struct usbd_ep *ep)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+	uint32_t len = ep->xfer_len;
+
+	if (!dwc3_is_ep_enabled(dwc3_handle, dwc3_ep->phy_epnum) && ep->num != 0U) {
+		return USBD_FAIL;
+	}
+
+	if (!ep->is_in) {
+		if ((len > ep->maxpacket) && !IS_MULTIPLE(len, ep->maxpacket)) {
+			VERBOSE("Packet size > Max_packet but non-multiple, buffer should be of at least Max_packet-size multiple\n");
+		}
+
+		/*setup and start the Xfer */
+		if ((len != 0U) && (len < ep->maxpacket)) {
+			dwc3_ep->xfer_dest_buff = ep->xfer_buff;
+			dwc3_ep->xfer_dest_len = ep->xfer_len;
+			ep->xfer_buff = dwc3_ep->bounce_buf;
+			ep->xfer_len = ALIGN_MULTIPLE(len, ep->maxpacket);
+		} else {
+//			ep->xfer_buff = pBuf;
+			ep->xfer_len = ALIGN_MULTIPLE(len, ep->maxpacket);
+		}
+	}
+
+	dwc3_ep->dma_addr = ((ep->xfer_buff != 0) ?
+			     api_mapdmaaddr(ep->xfer_buff, ep->xfer_len, ep->is_in ? 1 : 0) :
+			     0x0U);
+
+	if (ep->num == 0U) {
+		/* For Status ZLP packet */
+		if (len == 0U) {
+			/* 2-stage/3-stage control transfer */
+			if (__HAL_PCD_SETUP_REQ_LEN(dwc3_handle->setup_addr) == 0U) {
+				dwc3_ep->trb_flag = USB_DWC3_TRBCTL_CONTROL_STATUS2;
+			} else {
+				dwc3_ep->trb_flag = USB_DWC3_TRBCTL_CONTROL_STATUS3;
+			}
+			//udelay(10);
+		} else {
+			dwc3_ep->trb_flag = USB_DWC3_TRBCTL_CONTROL_DATA;
+		}
+	} else {
+		if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK)) {
+			dwc3_ep->trb_flag = USB_DWC3_TRBCTL_NORMAL;
+		} else {
+			dwc3_ep->trb_flag = USB_DWC3_TRBCTL_ISOCHRONOUS_FIRST;
+		}
+	}
+
+	return dwc3_ep_start_xfer(dwc3_handle, ep);
+}
+
+static enum usb_status dwc3_ep0_out_start(dwc3_handle_t *dwc3_handle, uintptr_t setup_buf_dma_addr)
+{
+	dwc3_handle->OUT_ep[0].dma_addr = setup_buf_dma_addr;
+	dwc3_handle->pcd_handle->out_ep[0].xfer_len = 8;
+	dwc3_handle->OUT_ep[0].trb_flag = USB_DWC3_TRBCTL_CONTROL_SETUP;
+
+	return dwc3_ep_start_xfer(dwc3_handle, &dwc3_handle->pcd_handle->out_ep[0]);
+}
+
+static enum usb_status usb_dwc3_ep0_out_start(void *handle)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+
+	dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+	return dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+}
+
+static enum usb_status usb_dwc3_start_device(void *handle)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	enum usb_status ret;
+
+	if (dwc3_handle->EP0_State != HAL_PCD_EP0_SETUP_QUEUED) {
+		dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+		ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+		if (ret != USBD_OK) {
+			ERROR("%s: %d\n", __func__, __LINE__);
+			return ret;
+		}
+	}
+
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DCTL, USB3_DCTL_RUN_STOP);
+
+	return USBD_OK;
+}
+
+static inline void dwc3_ack_evt_count(dwc3_handle_t *dwc3_handle, uint8_t intr_num,
+				      uint32_t evt_count)
+{
+	DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTCOUNT(intr_num), evt_count);
+}
+
+static inline uint32_t dwc3_read_intr_count(dwc3_handle_t *dwc3_handle, uint8_t intr_num)
+{
+	return DWC3_regread(dwc3_handle->usb_global, DWC3_GEVNTCOUNT(intr_num)) &
+	       DWC3_GEVNTCOUNT_MASK;
+}
+
+static enum usb_status dwc3_ep_stop_xfer(dwc3_handle_t *dwc3_handle, struct usbd_ep *ep)
+{
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+	enum usb_status ret;
+	dwc3_epcmd_t cmd;
+	dwc3_epcmd_params_t params;
+
+	VERBOSE("%s PHYEP%d %x\n", __func__, dwc3_ep->phy_epnum, dwc3_ep->flags);
+
+	/* Reset ISOC flags */
+	if (ep->type == EP_TYPE_ISOC) {
+		dwc3_ep->flags &= ~(USB_DWC3_EP_ISOC_START_PENDING | USB_DWC3_EP_ISOC_STARTED);
+	}
+
+	if ((dwc3_ep->flags & USB_DWC3_EP_REQ_QUEUED) == 0U) {
+		return USBD_FAIL;
+	}
+
+	(void)memset(&params, 0x00, sizeof(params));
+	cmd = USB_DWC3_DEPCMD_ENDTRANSFER | USB3_DEPCMD_HIPRI_FORCERM | USB3_DEPCMD_CMDIOC |
+	      DWC3_DEPCMD_PARAM((uint32_t)dwc3_ep->resc_idx);
+
+	ret = dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, cmd, &params);
+	/* Need Delay 100us as mentioned in Linux Driver */
+	udelay(100);
+
+	ep->xfer_count = ep->xfer_len - (dwc3_ep->trb_addr->size & DWC3_TRB_SIZE_MASK);
+
+	dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+
+        if ((!ep->is_in) && (ep->num == 0U)) {
+		dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_COMPLETED;
+	}
+
+	return ret;
+}
+
+static enum usb_status usb_dwc3_stop_device(void *handle)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	uint64_t timeout;
+	uint8_t i;
+	uint32_t evtcnt;
+
+	/*
+	 * Stop transfers for all(USB_DWC3_NUM_IN_EPS) EP
+	 * except EP0IN k = USB_DWC3_NUM_IN_EP
+	 */
+	for (i = 0; i < USB_DWC3_NUM_IN_EP; i++) {
+		dwc3_ep_stop_xfer(dwc3_handle, &dwc3_handle->pcd_handle->in_ep[i]);
+	}
+
+	/* Stop transfers for all EP except EP0OUT k = USB_DWC3_NUM_OUT_EP */
+	for (i = 0; i < USB_DWC3_NUM_OUT_EP; i++) {
+		dwc3_ep_stop_xfer(dwc3_handle, &dwc3_handle->pcd_handle->out_ep[i]);
+	}
+
+	/*
+	 * In the Synopsis DesignWare Cores USB3 Databook Rev. 3.30a
+	 * Section 1.3.4, it mentions that for the DEVCTRLHLT bit, the
+	 * "software needs to acknowledge the events that are generated
+	 * (by writing to GEVNTCOUNTn) while it is waiting for this bit
+	 * to be set to '1'."
+	 */
+
+	/* Check for all Event Buffer interrupt k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		evtcnt = dwc3_read_intr_count(dwc3_handle, i);
+
+		if (!evtcnt) {
+			continue;
+		}
+
+		__HAL_PCD_INCR_EVENT_POS(dwc3_handle, i, evtcnt);
+
+		dwc3_ack_evt_count(dwc3_handle, i, evtcnt);
+	}
+
+
+	DWC3_regupdateclr(dwc3_handle->usb_device, DWC3_DCTL, USB3_DCTL_RUN_STOP);
+
+	timeout = timeout_init_us(500); /* usec */
+
+	while ((DWC3_regread(dwc3_handle->usb_device, DWC3_DSTS) &
+		     USB3_DSTS_DEVCTRLHLT) == 0U) {
+		/* Can be called from interrupt context hence cannot wait for Tick */
+		if (timeout_elapsed(timeout)) { /* "Reset Timed Out" */
+			ERROR("TIMEOUT Stop Device\n");
+			return USBD_TIMEOUT;
+		}
+	}
+
+	// "Halt Complete"
+
+	return USBD_OK;
+}
+
+static enum usb_status usb_dwc3_set_address(void *handle, uint8_t address)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+
+	VERBOSE("%s: %d\n", __func__, address);
+
+	/* set device address */
+	DWC3_regupdateclr(dwc3_handle->usb_device, DWC3_DCFG, USB3_DCFG_DEVADDR_MSK);
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DCFG, DWC3_DCFG_DEVADDR((uint32_t)address));
+
+	return USBD_OK;
+}
+
+static enum usb_status usb_dwc3_ep0_start_xfer(void *handle, struct usbd_ep *ep)
+{
+	return usb_dwc3_ep_start_xfer(handle, ep);
+}
+
+static enum usb_status dwc3_ep_set_stall(dwc3_handle_t *dwc3_handle, usb_dwc3_endpoint_t *dwc3_ep)
+{
+	dwc3_epcmd_params_t params;
+
+	(void)memset(&params, 0x00, sizeof(params));
+
+	return dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, USB_DWC3_DEPCMD_SETSTALL,
+				    &params);
+}
+
+static enum usb_status usb_dwc3_ep_set_stall(void *handle, struct usbd_ep *ep)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	usb_dwc3_endpoint_t *dwc3_ep = ((ep->is_in) ? &dwc3_handle->IN_ep[ep->num] :
+					&dwc3_handle->OUT_ep[ep->num]);
+
+	if (dwc3_ep->is_stall) {
+		return USBD_OK;
+	}
+
+	dwc3_ep->is_stall = true;
+
+	return dwc3_ep_set_stall(dwc3_handle, dwc3_ep);
+}
+
+static uint8_t dwc3_read_ep_evt_type(uint32_t event)
+{
+	uint8_t ret;
+
+	switch ((event & DWC3_EVT_DEPEVT_TYPE_MASK) >> DWC3_EVT_DEPEVT_TYPE_BITPOS) {
+	case DWC3_DEPEVT_XFERCOMPLETE:
+		ret =  USB_DWC3_DEPEVT_XFERCOMPLETE;
+		break;
+	case DWC3_DEPEVT_XFERINPROGRESS:
+		ret =  USB_DWC3_DEPEVT_XFERINPROGRESS;
+		break;
+	case DWC3_DEPEVT_XFERNOTREADY:
+		ret =  USB_DWC3_DEPEVT_XFERNOTREADY;
+		break;
+	case DWC3_DEPEVT_RXTXFIFOEVT:
+		ret =  USB_DWC3_DEPEVT_RXTXFIFOEVT;
+		break;
+	case DWC3_DEPEVT_STREAMEVT:
+		ret =  USB_DWC3_DEPEVT_STREAMEVT;
+		break;
+	case DWC3_DEPEVT_EPCMDCMPLT:
+		ret =  USB_DWC3_DEPEVT_EPCMDCMPLT;
+		break;
+	default:
+		ret = (event & DWC3_EVT_DEPEVT_TYPE_MASK) >> DWC3_EVT_DEPEVT_TYPE_BITPOS;
+		break;
+	}
+
+	return ret;
+}
+
+static uint8_t dwc3_read_ep_evt_epnum(uint32_t event)
+{
+	return (uint8_t)((event & DWC3_EVT_DEPEVT_EPNUM_MASK) >> DWC3_EVT_DEPEVT_EPNUM_BITPOS);
+}
+
+static uint8_t dwc3_read_ep_evt_status(uint32_t event)
+{
+	uint8_t ret;
+
+	switch ((event & DWC3_EVT_DEPEVT_STATUS_MASK) >> DWC3_EVT_DEPEVT_STATUS_BITPOS) {
+	case DWC3_EVT_DEPEVT_STATUS_CONTROL_DATA:
+		ret = USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA;
+		break;
+	case DWC3_EVT_DEPEVT_STATUS_CONTROL_STATUS:
+		ret = USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS;
+		break;
+	default:
+		ret = (event & DWC3_EVT_DEPEVT_STATUS_MASK) >> DWC3_EVT_DEPEVT_STATUS_BITPOS;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_epaddr_set_stall(dwc3_handle_t *dwc3_handle, uint8_t ep_addr)
+{
+	struct usbd_ep *ep;
+	enum usb_status ret;
+	usb_dwc3_endpoint_t *dwc3_ep;
+
+	if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+		ep = &dwc3_handle->pcd_handle->in_ep[ep_addr & ADDRESS_MASK];
+		dwc3_ep = &dwc3_handle->IN_ep[ep_addr & ADDRESS_MASK];
+	} else {
+		ep = &dwc3_handle->pcd_handle->out_ep[ep_addr];
+		dwc3_ep = &dwc3_handle->OUT_ep[ep_addr];
+	}
+
+	/* For control endpoints, the application issues only the Set Stall command, and only on the
+	 * OUT direction of the control endpoint. The controller automatically clears the STALL when
+	 * it receives a SETUP token for the endpoint. The application must not issue the Clear
+	 * Stall command on a control endpoint
+	 */
+	if (ep_addr == EP0_IN) {
+		return USBD_OK;
+	}
+
+	if (dwc3_ep->is_stall) {
+		return USBD_OK;
+	}
+
+	dwc3_ep->is_stall = true;
+	ep->num   = ep_addr & ADDRESS_MASK;
+	ep->is_in = ((ep_addr & EP_DIR_MASK) == EP_DIR_IN);
+
+	ret = dwc3_ep_set_stall(dwc3_handle, dwc3_ep);
+	if (ret != USBD_OK) {
+		return ret;
+	}
+
+	if ((ep_addr & ADDRESS_MASK) == 0U) {
+		dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+		ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+	}
+
+	return ret;
+}
+
+static uint32_t dwc3_get_ep_trblen(usb_dwc3_endpoint_t *ep)
+{
+	return DWC3_TRB_SIZE_LENGTH(ep->trb_addr->size);
+}
+
+static uint32_t dwc3_get_ep_trbstatus(usb_dwc3_endpoint_t *ep)
+{
+	return DWC3_TRB_SIZE_TRBSTS(ep->trb_addr->size);
+}
+
+static enum usb_action dwc3_handle_ep0_xfernotready_event(dwc3_handle_t *dwc3_handle,
+							  uint32_t event, uint32_t *param)
+{
+	enum usb_action action = USB_NOTHING;
+	uint8_t phy_epnum = dwc3_read_ep_evt_epnum(event);
+	struct pcd_handle *pcd_handle = dwc3_handle->pcd_handle;
+	uint8_t status = dwc3_read_ep_evt_status(event);
+	uint8_t ep_addr, ep_num;
+	enum usb_status ret;
+
+	ep_addr = __HAL_PCD_PHYEPNUM_TO_EPADDR(phy_epnum);
+	ep_num = ep_addr & ADDRESS_MASK;
+
+	if (__HAL_PCD_SETUP_REQ_LEN(dwc3_handle->setup_addr) == 0U) {
+		switch (status) {
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS:
+			api_memcpy(dwc3_handle->pcd_handle->setup,
+				   dwc3_handle->setup_addr,
+				   sizeof(dwc3_handle->pcd_handle->setup));
+			action = USB_SETUP;
+			break;
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA:
+			ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+			if (ret != USBD_OK) {
+				ERROR("%s: %d\n", __func__, __LINE__);
+			}
+			break;
+		default:
+			VERBOSE("Invalid Status %d: %s: %d\n", status, __func__, __LINE__);
+			break;
+		}
+	} else {
+		switch (status) {
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_STATUS:
+			if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+				*param = ep_num;
+				action = USB_DATA_OUT;
+			} else {
+				*param = ep_num;
+				action = USB_DATA_IN;
+			}
+			break;
+		case USB_DWC3_DEPEVT_XFERNOTREADY_STATUS_CTRL_DATA:
+			if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+				/* if wrong direction */
+				if (__HAL_PCD_SETUP_REQ_DATA_DIR_IN(dwc3_handle->setup_addr) ==
+				    0U) {
+					ret = dwc3_ep_stop_xfer(dwc3_handle,
+								&pcd_handle->out_ep[0]);
+					if (ret != USBD_OK) {
+						ERROR("%s: %d\n", __func__, __LINE__);
+					}
+					ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+					if (ret != USBD_OK) {
+						ERROR("%s: %d\n", __func__, __LINE__);
+					}
+				}
+				/*
+				 * last packet is MPS multiple, so send ZLP packet,
+				 * handled by USBD_core.c
+				 */
+			} else {
+				/* if wrong direction */
+				if (__HAL_PCD_SETUP_REQ_DATA_DIR_IN(dwc3_handle->setup_addr) !=
+				    0U) {
+					ret = dwc3_ep_stop_xfer(dwc3_handle,
+								&pcd_handle->in_ep[0]);
+					if (ret != USBD_OK) {
+						ERROR("%s: %d\n", __func__, __LINE__);
+					}
+					ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+					if (ret != USBD_OK) {
+						ERROR("%s: %d\n", __func__, __LINE__);
+					}
+				}
+			}
+			break;
+		default:
+			VERBOSE("Invalid Status %d: %s: %d\n", status, __func__, __LINE__);
+			break;
+		}
+	}
+
+	return action;
+}
+
+static enum usb_action dwc3_handle_ep_event(dwc3_handle_t *dwc3_handle, uint32_t event,
+					    uint32_t *param)
+{
+	enum usb_action action = USB_NOTHING;
+	uint8_t type = dwc3_read_ep_evt_type(event);
+	uint8_t phy_epnum = dwc3_read_ep_evt_epnum(event);
+	uint8_t ep_addr, ep_num;
+	struct usbd_ep *ep;
+	usb_dwc3_endpoint_t *dwc3_ep;
+	enum usb_status ret;
+
+	ep_addr = __HAL_PCD_PHYEPNUM_TO_EPADDR(phy_epnum);
+	ep_num = ep_addr & ADDRESS_MASK;
+
+	if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {
+		ep = &dwc3_handle->pcd_handle->in_ep[ep_num];
+		dwc3_ep = &dwc3_handle->IN_ep[ep_num];
+	} else {
+		ep = &dwc3_handle->pcd_handle->out_ep[ep_num];
+		dwc3_ep = &dwc3_handle->OUT_ep[ep_num];
+	}
+
+	switch (type) {
+	case USB_DWC3_DEPEVT_XFERCOMPLETE:
+		VERBOSE("EP%d%s: Transfer Complete Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", event);
+
+		if (ep->type == EP_TYPE_ISOC) {
+			VERBOSE("EP%d%s is an Isochronous endpoint\n", ep_num,
+				   ep->is_in ? "IN" : "OUT");
+			break;
+		}
+
+		/* Just forr Log, since ctrl expects sw to follow the whole control
+		 * programming sequence, as also mentioned in Linux driver
+		 */
+		if ((ep_num == 0U) &&
+		    (dwc3_get_ep_trbstatus(dwc3_ep) == USB_DWC3_TRBSTS_SETUP_PENDING)) {
+			VERBOSE("EP%d%s Setup Pending received\n", ep_num,
+				   ep->is_in ? "IN" : "OUT");
+		}
+
+		VERBOSE("EP%d%s: Transfer Complete trb %p:%08x:%08x:%08x:%08x TRB-Status %u\n",
+			   ep_num, ep->is_in ? "IN" : "OUT", dwc3_ep->trb_addr,
+			   (uint32_t)dwc3_ep->trb_addr->bph, (uint32_t)dwc3_ep->trb_addr->bpl,
+			   (uint32_t)dwc3_ep->trb_addr->size, (uint32_t)dwc3_ep->trb_addr->ctrl,
+			   dwc3_get_ep_trbstatus(dwc3_ep));
+
+		if ((ep_addr & EP_DIR_MASK) == EP_DIR_IN) {  /* IN EP */
+			ep->xfer_count = ep->xfer_len - dwc3_get_ep_trblen(dwc3_ep);
+
+			dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+
+			if (ep->xfer_buff != NULL) {
+				api_unmapdmaaddr(dwc3_ep->dma_addr, ep->xfer_len, 1);
+			}
+
+			/*
+			 * For EP0IN, if packet is not sent completely,
+			 * then error, as done in Linux driver
+			 */
+			if ((ep_num == 0U) && (ep->xfer_len != ep->xfer_count)) {
+				ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num); // OUT EP0
+				if (ret != USBD_OK) {
+					ERROR("%s: %d\n", __func__, __LINE__);
+				}
+			}
+
+			/*
+			 * if 3-stage then wait for XFERNOTREADY(control-status) before
+			 * sending data to upper layer
+			 */
+			if ((ep_num != 0U) || (ep->xfer_len == 0U)) {
+				*param = ep_num;
+				action = USB_DATA_IN;
+			}
+
+			/* For EP0, this is ZLP, so prepare EP0 for next setup */
+			if ((ep_num == 0U) && (ep->xfer_len == 0U)) {
+				/* prepare to rx more setup packets */
+				dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+				ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+				if (ret != USBD_OK) {
+					ERROR("%s: %d\n", __func__, __LINE__);
+					return action;
+				}
+			}
+		} else {
+			ep->xfer_count = ep->xfer_len - dwc3_get_ep_trblen(dwc3_ep);
+
+			dwc3_ep->flags &= ~USB_DWC3_EP_REQ_QUEUED;
+
+			/* For EP0OUT */
+			if ((ep_addr == 0U) &&
+			    (dwc3_handle->EP0_State == HAL_PCD_EP0_SETUP_QUEUED)) {
+
+				dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_COMPLETED;
+				dwc3_ep->is_stall = false;
+				VERBOSE("EP%d%s: SetupData %02x%02x%02x%02x:%02x%02x%02x%02x\n",
+					   ep_num, ep->is_in ? "IN" : "OUT",
+					   dwc3_handle->setup_addr[0], dwc3_handle->setup_addr[1],
+					   dwc3_handle->setup_addr[2], dwc3_handle->setup_addr[3],
+					   dwc3_handle->setup_addr[4], dwc3_handle->setup_addr[5],
+					   dwc3_handle->setup_addr[6], dwc3_handle->setup_addr[7]);
+
+				// if 2-stage then wait for the XFERNOTREADY(control-status)
+				if (__HAL_PCD_SETUP_REQ_LEN(dwc3_handle->setup_addr) != 0U) {
+					api_memcpy(dwc3_handle->pcd_handle->setup,
+						   dwc3_handle->setup_addr,
+						   sizeof(dwc3_handle->pcd_handle->setup));
+					action = USB_SETUP;
+				}
+			} else {
+
+				if (ep->xfer_buff != NULL) {
+					api_unmapdmaaddr(dwc3_ep->dma_addr, ep->xfer_len, 0);
+				}
+
+				if (ep->xfer_buff == dwc3_ep->bounce_buf) {
+					api_memcpy(dwc3_ep->xfer_dest_buff, ep->xfer_buff,
+						   ep->xfer_count);
+					ep->xfer_buff = dwc3_ep->xfer_dest_buff;
+				}
+
+				/*
+				 * if 3-stage then wait for XFERNOTREADY(control-status) before
+				 * sending data to upper layer
+				 */
+				if ((ep_num != 0U) || (ep->xfer_len == 0U)) {
+					*param = ep_num;
+					action = USB_DATA_OUT;
+				}
+
+				/* For EP0, this is ZLP, so prepare EP0 for next setup */
+				if ((ep_num == 0U) && (ep->xfer_len == 0U)) {
+					/* prepare to rx more setup packets */
+					dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+					ret = dwc3_ep0_out_start(dwc3_handle,
+								 dwc3_handle->setup_dma_addr);
+					if (ret != USBD_OK) {
+						ERROR("%s: %d\n", __func__, __LINE__);
+						return action;
+					}
+				}
+			}
+		}
+
+		break;
+
+	case USB_DWC3_DEPEVT_XFERINPROGRESS:
+		VERBOSE("EP%d%s: Transfer In-Progress %u Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", dwc3_handle->intbuffers.evtbufferpos[0],
+			   event);
+
+		if (ep_num == 0U) { // ***ToCheck
+			break;
+		}
+
+		/*
+		 * currently not planned to issue multiple TRB transfer, hence there shouldn't
+		 * be any event like this
+		 */
+
+		/*
+		 * But for isoc transfers we need get it since transfer started with
+		 * loop(link) trb
+		 */
+		if (ep->type != EP_TYPE_ISOC) {
+			break;
+		}
+
+		break;
+
+	case USB_DWC3_DEPEVT_XFERNOTREADY:
+		VERBOSE("EP%d%s: Transfer Not Ready Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", event);
+		/* For EP0IN or EP0OUT, currently no plan to use xfernotready interrupt */
+
+		//active = PCD_READ_DEPEVT_STATUS(event);
+
+		if (ep_num == 0U) {
+
+			if (dwc3_handle->EP0_State == HAL_PCD_EP0_SETUP_QUEUED) {
+				ret = dwc3_epaddr_set_stall(dwc3_handle, ep_num);  // OUT EP0
+				if (ret != USBD_OK) {
+					ERROR("%s: %d\n", __func__, __LINE__);
+					return action;
+				}
+			} else {
+				action = dwc3_handle_ep0_xfernotready_event(dwc3_handle, event,
+									    param);
+			}
+		}
+
+		/*
+		 * Currently we dont implement provide request queue to support On-demand transfers
+		 * for non-isoc EP, it only supports preset transfers so this event will not be
+		 * used, Section 9.2.4 "Transfer Setup Recommendations"
+		 */
+
+		/*
+		 * But for isoc transfers we need to issue the request from here using the
+		 * micro-frame number
+		 */
+		if (ep->type != EP_TYPE_ISOC) {
+			break;
+		}
+
+		break;
+
+	case USB_DWC3_DEPEVT_STREAMEVT: /* Stream event, Not used */
+		break;
+	case USB_DWC3_DEPEVT_RXTXFIFOEVT: /* FIFO Overrun */
+		break;
+	case USB_DWC3_DEPEVT_EPCMDCMPLT: /* Endpoint Command Complete */
+		VERBOSE("EP%d%s: Endpoint Command Complete Event=%x\n", ep_num,
+			   ep->is_in ? "IN" : "OUT", event);
+		break;
+	default:
+		VERBOSE("Invalid type %d: %s: %d\n", type, __func__, __LINE__);
+		break;
+	}
+
+	return action;
+}
+
+static uint8_t dwc3_read_dev_evt_type(uint32_t event)
+{
+	uint8_t ret;
+
+	switch ((event & DWC3_EVT_DEVEVT_TYPE_MASK) >> DWC3_EVT_DEVEVT_TYPE_BITPOS) {
+	case DWC3_DEVICE_EVENT_DISCONNECT:
+		ret = USB_DWC3_DEVICE_EVENT_DISCONNECT;
+		break;
+	case DWC3_DEVICE_EVENT_RESET:
+		ret = USB_DWC3_DEVICE_EVENT_RESET;
+		break;
+	case DWC3_DEVICE_EVENT_CONNECT_DONE:
+		ret = USB_DWC3_DEVICE_EVENT_CONNECT_DONE;
+		break;
+	case DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:
+		ret = USB_DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE;
+		break;
+	case DWC3_DEVICE_EVENT_WAKEUP:
+		ret = USB_DWC3_DEVICE_EVENT_WAKEUP;
+		break;
+	case DWC3_DEVICE_EVENT_HIBER_REQ:
+		ret = USB_DWC3_DEVICE_EVENT_HIBER_REQ;
+		break;
+	case DWC3_DEVICE_EVENT_EOPF:
+		ret = USB_DWC3_DEVICE_EVENT_EOPF;
+		break;
+	case DWC3_DEVICE_EVENT_SOF:
+		ret = USB_DWC3_DEVICE_EVENT_SOF;
+		break;
+	case DWC3_DEVICE_EVENT_ERRATIC_ERROR:
+		ret = USB_DWC3_DEVICE_EVENT_ERRATIC_ERROR;
+		break;
+	case DWC3_DEVICE_EVENT_CMD_CMPL:
+		ret = USB_DWC3_DEVICE_EVENT_CMD_CMPL;
+		break;
+	case DWC3_DEVICE_EVENT_OVERFLOW:
+		ret = USB_DWC3_DEVICE_EVENT_OVERFLOW;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_ep_clear_stall(dwc3_handle_t *dwc3_handle, usb_dwc3_endpoint_t *dwc3_ep)
+{
+	dwc3_epcmd_params_t params;
+
+	(void)memset(&params, 0x00, sizeof(params));
+
+	return dwc3_execute_dep_cmd(dwc3_handle, dwc3_ep->phy_epnum, USB_DWC3_DEPCMD_CLEARSTALL,
+				    &params);
+}
+
+static uint8_t dwc3_get_dev_speed(dwc3_handle_t *dwc3_handle)
+{
+	uint32_t reg;
+	uint8_t ret;
+
+	reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DSTS) & USB3_DSTS_CONNECTSPD;
+
+	switch (reg) {
+	case DWC3_DSTS_SUPERSPEED:
+		ret = USB_DWC3_SPEED_SUPER;
+		NOTICE("%s = SuperSpeed\n", __func__);
+		break;
+	case DWC3_DSTS_HIGHSPEED:
+		ret = USB_DWC3_SPEED_HIGH;
+		NOTICE("%s = HighSpeed\n", __func__);
+		break;
+	case DWC3_DSTS_FULLSPEED1:
+		ret = USB_DWC3_SPEED_FULL_48;
+		NOTICE("%s = FullSpeed_48M\n", __func__);
+		break;
+	case DWC3_DSTS_FULLSPEED2:
+		ret = USB_DWC3_SPEED_FULL;
+		NOTICE("%s = FullSpeed\n", __func__);
+		break;
+	case DWC3_DSTS_LOWSPEED:
+		ret = USB_DWC3_SPEED_LOW;
+		NOTICE("%s = LowSpeed\n", __func__);
+		break;
+	default: /* Invalid */
+		ret = USB_DWC3_SPEED_INVALID;
+		NOTICE("%s = Invalid\n", __func__);
+		break;
+	}
+
+	return ret;
+}
+
+static uint32_t dwc3_get_epcfg_action(uint8_t action)
+{
+	uint32_t ret;
+
+	switch (action) {
+	case USB_DWC3_DEPCFG_ACTION_INIT:
+		ret = DWC3_DEPCFG_ACTION_INIT;
+		break;
+	case USB_DWC3_DEPCFG_ACTION_RESTORE:
+		ret = DWC3_DEPCFG_ACTION_RESTORE;
+		break;
+	case USB_DWC3_DEPCFG_ACTION_MODIFY:
+		ret = DWC3_DEPCFG_ACTION_MODIFY;
+		break;
+	default:
+		ret = 0U;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_ep_configure(dwc3_handle_t *dwc3_handle, uint8_t epnum, bool is_in,
+					 uint8_t type, uint32_t max_packet, uint8_t tx_fifo,
+					 uint16_t binterval, uint8_t phy_epnum, uint8_t intr_num,
+					 uint8_t action)
+{
+	dwc3_epcmd_params_t params;
+
+	(void)memset(&params, 0x00, sizeof(params));
+	params.param0 = DWC3_DEPCFG_EP_TYPE(type) | DWC3_DEPCFG_MAX_PACKET_SIZE(max_packet);
+
+	/* Burst size is only needed in SuperSpeed mode */
+	//params.param0 |= DWC3_DEPCFG_BURST_SIZE(0);
+
+	params.param0 |= dwc3_get_epcfg_action(action);
+
+	params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN | DWC3_DEPCFG_XFER_NOT_READY_EN;
+	if (type == EP_TYPE_ISOC) {
+		params.param1 |= DWC3_DEPCFG_XFER_IN_PROGRESS_EN;
+	}
+
+	params.param1 |= DWC3_DEPCFG_EP_NUMBER(((uint32_t)epnum << 1) + (is_in ? 1UL : 0UL));
+
+	params.param1 |= DWC3_DEPCFG_EP_INTR_NUM(intr_num);
+
+	if (is_in) {
+		params.param0 |= DWC3_DEPCFG_FIFO_NUMBER(tx_fifo);
+	}
+
+	if (binterval != 0U) {
+		params.param1 |= DWC3_DEPCFG_BINTERVAL_M1(binterval - 1UL);
+	}
+
+	return dwc3_execute_dep_cmd(dwc3_handle, phy_epnum, USB_DWC3_DEPCMD_SETEPCONFIG, &params);
+}
+
+static inline uint8_t dwc3_read_dev_evt_linkstate(uint32_t event)
+{
+	return (uint8_t)((event & DWC3_EVT_DEVEVT_LNKSTS_MASK) >> DWC3_EVT_DEVEVT_LNKSTS_BITPOS);
+}
+
+static inline const char *dwc3_get_linkstate_str(uint8_t state)
+{
+	const char *ret;
+
+	switch (state) {
+	case DWC3_LINK_STATE_ON:
+		ret = "ON";
+		break;
+	case DWC3_LINK_STATE_L1:
+		ret = "L1";
+		break;
+	case DWC3_LINK_STATE_L2:
+		ret = "L2";
+		break;
+	case DWC3_LINK_STATE_DIS:
+		ret = "Disconnect";
+		break;
+	case DWC3_LINK_STATE_EARLY_SUS:
+		ret = "Early Suspend";
+		break;
+	case DWC3_LINK_STATE_RESET:
+		ret = "Reset";
+		break;
+	case DWC3_LINK_STATE_RESUME:
+		ret = "Resume";
+		break;
+	default:
+		ret = "UNKNOWN state";
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_action dwc3_handle_dev_event(dwc3_handle_t *dwc3_handle, uint32_t event,
+					     uint32_t *param)
+{
+	enum usb_action action = USB_NOTHING;
+	uint8_t type = dwc3_read_dev_evt_type(event);
+	uint8_t i, speed;
+	usb_dwc3_endpoint_t *ep;
+	enum usb_status ret;
+	uint32_t ep0_mps = USB3_MAX_PACKET_SIZE;
+
+	switch (type) {
+	case USB_DWC3_DEVICE_EVENT_DISCONNECT:
+		INFO("Event: Device Disconnect\n");
+		/* For SuperSpeed, set DCTL[8:5] to 5*/
+
+		action = USB_DISCONNECT;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_RESET:
+		INFO("Event: Device Reset\n");
+		/*
+		 * Spec says, Wait till EP0 finishes current transfer and reaches Setup-Stage.
+		 * But there is no wait in Linux driver which means that Host will take care while
+		 * issuing a reset. Also its tricky to implement since we can't wait here
+		 * (in interrupt context) for further control EP interrupts
+		 */
+
+		if (dwc3_handle->EP0_State != HAL_PCD_EP0_SETUP_QUEUED) {
+			ret = dwc3_ep_stop_xfer(dwc3_handle, &dwc3_handle->pcd_handle->out_ep[0]);
+			if (ret != USBD_OK) {
+				ERROR("%s: %d\n", __func__, __LINE__);
+			}
+			ret = dwc3_epaddr_set_stall(dwc3_handle, EP0_OUT); // OUT EP0
+			if (ret != USBD_OK) {
+				ERROR("%s: %d\n", __func__, __LINE__);
+			}
+		}
+
+		/*
+		 * Stop transfers for all(USB_DWC3_NUM_IN_EPS) EP
+		 * except EP0IN k = USB_DWC3_NUM_IN_EP
+		 */
+		for (i = 0; i < USB_DWC3_NUM_IN_EP; i++) {
+			dwc3_ep_stop_xfer(dwc3_handle,
+					      &dwc3_handle->pcd_handle->in_ep[i]);
+		}
+
+		/* Stop transfers for all EP except EP0OUT k = USB_DWC3_NUM_OUT_EP */
+		for (i = 1; i < USB_DWC3_NUM_OUT_EP; i++) {
+			dwc3_ep_stop_xfer(dwc3_handle,
+					      &dwc3_handle->pcd_handle->out_ep[i]);
+		}
+
+		/* Clear Stall for all EP except EP0IN k = USB_DWC3_NUM_IN_EP */
+		for (i = 1; i < USB_DWC3_NUM_IN_EP; i++) {
+			ep = &dwc3_handle->IN_ep[i];
+
+			if (!ep->is_stall) {
+				continue;
+			}
+
+			ep->is_stall = false;
+
+			ret = dwc3_ep_clear_stall(dwc3_handle, ep);
+			if (ret != USBD_OK) {
+				ERROR("%s: %d\n", __func__, __LINE__);
+				return action;
+			}
+		}
+
+		/* Clear Stall for all EP except EP0OUT k = USB_DWC3_NUM_OUT_EP */
+		for (i = 1; i < USB_DWC3_NUM_OUT_EP; i++) {
+			ep = &dwc3_handle->OUT_ep[i];
+
+			if (!ep->is_stall) {
+				continue;
+			}
+
+			ep->is_stall = false;
+			//ep->num   = ep_addr & ADDRESS_MASK;
+			//ep->is_in = ((ep_addr & 0x80) == 0x80);
+
+			ret = dwc3_ep_clear_stall(dwc3_handle, ep);
+			if (ret != USBD_OK) {
+				ERROR("%s: %d\n", __func__, __LINE__);
+				return action;
+			}
+		}
+
+		/* Reset device address to zero */
+		ret = usb_dwc3_set_address(dwc3_handle, 0);
+		if (ret != USBD_OK) {
+			ERROR("%s: %d\n", __func__, __LINE__);
+			return action;
+		}
+
+		action = USB_RESET;
+
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_CONNECT_DONE:
+		INFO("Event: Device Connection Done\n");
+
+		/*
+		 * hpcd->Init.ep0_mps = MaxPacketSize to 512 (SuperSpeed), 64 (High-Speed),
+		 * 8/16/32/64 (Full-Speed), or 8 (Low-Speed).
+		 */
+		speed = dwc3_get_dev_speed(dwc3_handle);
+		switch (speed) {
+		case USB_DWC3_SPEED_SUPER:
+			ep0_mps = 512;
+			break;
+		case USB_DWC3_SPEED_HIGH:
+			ep0_mps = 64;
+			break;
+		case USB_DWC3_SPEED_FULL_48:
+		case USB_DWC3_SPEED_FULL:
+			ep0_mps = 64;
+			break;
+		case USB_DWC3_SPEED_LOW:
+			ep0_mps = 8;
+			break;
+		default:
+			ERROR("%s: %d\n", __func__, __LINE__);
+			break;
+		}
+
+		/* Update DWC3_GCTL_RAMCLKSEL, but only for Superspeed */
+
+		/* Modify max packet size for EP 0 & 1 */
+		ret = dwc3_ep_configure(dwc3_handle, 0, false, EP_TYPE_CTRL, ep0_mps, 0, 0, 0,
+					dwc3_handle->OUT_ep[0].intr_num,
+					USB_DWC3_DEPCFG_ACTION_MODIFY);
+		if (ret != USBD_OK) {
+			ERROR("%s: %d\n", __func__, __LINE__);
+			return action;
+		}
+		ret = dwc3_ep_configure(dwc3_handle, 0, true, EP_TYPE_CTRL, ep0_mps, 0, 0, 1,
+					dwc3_handle->IN_ep[0].intr_num,
+					USB_DWC3_DEPCFG_ACTION_MODIFY);
+		if (ret != USBD_OK) {
+			ERROR("%s: %d\n", __func__, __LINE__);
+			return action;
+		}
+
+		dwc3_handle->pcd_handle->out_ep[0].maxpacket = ep0_mps;
+		dwc3_handle->pcd_handle->in_ep[0].maxpacket = ep0_mps;
+
+		/*
+		 * Depending on the connected speed, write to the other
+		 * PHY's control register to suspend it.
+		 */
+
+		/* Use default values for GTXFIFOSIZn and GRXFIFOSIZ0 */
+
+		action = USB_ENUM_DONE;
+
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:
+		INFO("Event: Link Status Change : %s(%d)\n",
+			   dwc3_get_linkstate_str(dwc3_read_dev_evt_linkstate(event)),
+			   dwc3_read_dev_evt_linkstate(event));
+		/* Handle link state changes, U0,U1,U2,U3 with suspend/resume functions */
+
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_WAKEUP:
+		INFO("Event: Wake-UP\n");
+		// resume function
+		action = USB_RESUME;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_HIBER_REQ:
+		INFO("Event: Hibernation Request\n");
+		/* hibernation function */
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_EOPF: /* End of Periodic Frame */
+		INFO("Event: Suspend\n");
+		action = USB_SUSPEND;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_SOF: /* Start of Periodic Frame */
+		INFO("Event: Start of Periodic Frame\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_L1SUSPEND:
+		INFO("Event: L1 Suspend\n");
+		action = USB_LPM;
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_ERRATIC_ERROR: /* Erratic Error */
+		INFO("Event: Erratic Error\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_CMD_CMPL: /* Command Complete */
+		INFO("Event: Command Complete\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_OVERFLOW: /* Overflow */
+		INFO("Event: Overflow\n");
+		break;
+
+	case USB_DWC3_DEVICE_EVENT_L1WAKEUP:
+		INFO("Event: L1 Wake-UP\n");
+		// resume function
+		action = USB_RESUME;
+		break;
+
+	default:  /* UNKNOWN IRQ type */
+		break;
+	}
+
+	return action;
+}
+
+static inline bool dwc3_is_ep_event(uint32_t event)
+{
+	return ((event & DWC3_EVT_TYPE_MASK) == (DWC3_EVT_TYPE_EP << DWC3_EVT_TYPE_BITPOS));
+}
+
+static inline bool dwc3_is_dev_event(uint32_t event)
+{
+	return ((event & DWC3_EVT_TYPE_MASK) == (DWC3_EVT_TYPE_DEVSPEC << DWC3_EVT_TYPE_BITPOS));
+}
+
+static enum usb_action usb_dwc3_it_handler(void *handle, uint32_t *param)
+{
+	dwc3_handle_t *dwc3_handle = (dwc3_handle_t *)handle;
+	enum usb_action action = USB_NOTHING;
+	uint32_t evtcnt, evt;
+	uint8_t i;
+
+	/* Use same handler for all the Evt-Buf IRQs */
+
+	/* Check for all Event Buffer interrupt k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		evtcnt = dwc3_read_intr_count(dwc3_handle, i);
+
+		if (!evtcnt) {
+			continue;
+		}
+
+		VERBOSE("Interrupt Count %u\n", evtcnt);
+
+		evt = __HAL_PCD_READ_EVENT(dwc3_handle, i);
+		VERBOSE("Event %08x\n", evt);
+
+		if (dwc3_is_ep_event(evt)) {   /* EP event */
+			action = dwc3_handle_ep_event(dwc3_handle, evt, param);
+		} else {     /* NON-EP event */
+			if (dwc3_is_dev_event(evt)) {  /* Device specific event */
+				action = dwc3_handle_dev_event(dwc3_handle, evt, param);
+			} else {
+			  /* Error, non supported events */
+			}
+		}
+
+		__HAL_PCD_INCR_EVENT_POS(dwc3_handle, i, USB_DWC3_EVENT_SIZE);
+
+		dwc3_ack_evt_count(dwc3_handle, i, USB_DWC3_EVENT_SIZE);
+	}
+
+	return action;
+}
+
+static enum usb_status usb_dwc3_write_packet(void *handle __unused, uint8_t *src __unused,
+					     uint8_t ch_ep_num __unused, uint16_t len __unused)
+{
+	return USBD_OK;
+}
+
+static void *usb_dwc3_read_packet(void *handle __unused, uint8_t *dest __unused,
+				  uint16_t len __unused)
+{
+	return NULL;
+}
+
+static enum usb_status usb_dwc3_write_empty_tx_fifo(void *handle __unused, uint32_t epnum,
+						    uint32_t xfer_len __unused,
+						    uint32_t *xfer_count __unused,
+						    uint32_t maxpacket __unused,
+						    uint8_t **xfer_buff __unused)
+{
+	return USBD_OK;
+}
+
+static const struct usb_driver usb_dwc3driver = {
+	.ep0_out_start = usb_dwc3_ep0_out_start,
+	.ep_start_xfer = usb_dwc3_ep_start_xfer,
+	.ep0_start_xfer = usb_dwc3_ep0_start_xfer,
+	.write_packet = usb_dwc3_write_packet,
+	.read_packet = usb_dwc3_read_packet,
+	.ep_set_stall = usb_dwc3_ep_set_stall,
+	.start_device = usb_dwc3_start_device,
+	.stop_device = usb_dwc3_stop_device,
+	.set_address = usb_dwc3_set_address,
+	.write_empty_tx_fifo = usb_dwc3_write_empty_tx_fifo,
+	.it_handler = usb_dwc3_it_handler
+};
+
+/* USB2 PHY Mask 0xf */
+#define USBPHY_ULPI	1U
+#define USBPHY_UTMI	2U
+#define USBPHY_EMBEDDED_USB2	8U
+#define USB2PHY_MASK	15U
+/* USB3 PHY Mask (0xf << 4) */
+#define USBPHY_PIPE3	16U
+#define USBPHY_EMBEDDED_USB3	128U
+#define USB3PHY_MASK	(15U << 4)
+
+static enum usb_status dwc3_soft_reset(dwc3_handle_t *dwc3_handle)
+{
+	uint64_t timeout;
+
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCTL, USB3_DCTL_CSFTRST);
+
+	timeout = timeout_init_us(500*1000); /* msec */
+
+	while (DWC3_regread(dwc3_handle->usb_device, DWC3_DCTL) & USB3_DCTL_CSFTRST) {
+
+		if (timeout_elapsed(timeout)) { /* "Reset Timed Out" */
+			return USBD_TIMEOUT;
+		}
+	}
+
+	return USBD_OK;
+}
+
+static enum usb_status dwc3_core_init(dwc3_handle_t *dwc3_handle, uint32_t phy_itface)
+{
+	enum usb_status ret;
+
+	NOTICE("Core ID %08x\n", (uint32_t)DWC3_regread(dwc3_handle->usb_global, DWC3_GSNPSID));
+
+	/* Set GUSB3PIPECTL for all USB3 ports (1-n), currently doing only for 0 */
+	if ((phy_itface & USB3PHY_MASK) != 0U) {
+		/* Relying on default value */
+	}
+
+	/* Set GUSB2PHYCFG for all USB2 ports (1-m), currently doing only for 0 */
+	if ((phy_itface & USB2PHY_MASK) != 0U) {
+		switch (phy_itface) {
+		case USBPHY_UTMI:
+			DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+					  USB3_GUSB2PHYCFG_ULPI_UTMI_SEL);
+			break;
+		case USBPHY_ULPI:
+			DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+					  USB3_GUSB2PHYCFG_ULPI_UTMI_SEL);
+			break;
+		default:
+			/* Relying on default value. */
+			break;
+		}
+	}
+
+	/* issue device SoftReset */
+	ret = dwc3_soft_reset(dwc3_handle);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Put PHYs in reset */
+	/* Before Resetting PHY, put Core in Reset */
+	DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GCTL, USB3_GCTL_CORESOFTRESET);
+
+	/* Assert USB3 PHY reset for all USB3 ports (1-n), currently doing only for 0 */
+	if ((phy_itface & USB3PHY_MASK) != 0U) {
+		DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GUSB3PIPECTL(0UL),
+				  USB3_GUSB3PIPECTL_PHYSOFTRST);
+	}
+
+	/* Assert USB2 PHY reset for all USB2 ports (1-m), currently doing only for 0 */
+	if ((phy_itface & USB2PHY_MASK) != 0U) {
+		DWC3_regupdateset(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+				  USB3_GUSB2PHYCFG_PHYSOFTRST);
+	}
+
+	// Program PHY signals - PHY specific
+
+
+	// Phy Init not needed since will be done by bootrom
+
+	/* Release PHY out of reset */
+
+	/* Clear USB3 PHY reset for all USB3 ports (1-n), currently doing only for 0 */
+	if ((phy_itface & USB3PHY_MASK) != 0U) {
+		DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GUSB3PIPECTL(0UL),
+				  USB3_GUSB3PIPECTL_PHYSOFTRST);
+	}
+
+	/* Clear USB2 PHY reset */
+	if ((phy_itface & USB2PHY_MASK) != 0U) {
+		DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GUSB2PHYCFG(0UL),
+				  USB3_GUSB2PHYCFG_PHYSOFTRST);
+	}
+
+	// delay needed for phy reset
+	mdelay(100); // 100ms
+
+	/* After PHYs are stable we can take Core out of reset state */
+	DWC3_regupdateclr(dwc3_handle->usb_global, DWC3_GCTL, USB3_GCTL_CORESOFTRESET);
+
+	/* Disable Scale down mode - check if disabled by default */
+	//DWC3_regupdateclr(USBx, DWC3_GCTL, DWC3_GCTL_SCALEDOWN_MASK); ***ToCheck
+
+	/* Alloc and Setup Scratch buffers for hibernation */
+	// ***ToCheck
+
+	// From Linux Driver
+	DWC3_regwrite(dwc3_handle->usb_global, DWC3_GSBUSCFG0, 0xe);
+	DWC3_regwrite(dwc3_handle->usb_global, DWC3_GSBUSCFG1, 0xf00);
+
+	/* Use default values for GTXFIFOSIZn and GRXFIFOSIZ0 */
+
+	return USBD_OK;
+}
+
+typedef enum {
+	USB_DWC3_DEVICE_MODE  = 0U,
+	USB_DWC3_HOST_MODE    = 1U,
+	USB_DWC3_DRD_MODE     = 2U,
+	USB_DWC3_INVALID_MODE = 0xFU
+} USB_DWC3_modetypedef;
+
+static enum usb_status dwc3_set_current_mode(dwc3_handle_t *dwc3_handle, USB_DWC3_modetypedef mode)
+{
+	uint32_t reg;
+	enum usb_status ret = USBD_OK;
+
+	reg = DWC3_regread(dwc3_handle->usb_global, DWC3_GCTL) & ~USB3_GCTL_PRTCAPDIR_MSK;
+
+	switch (mode) {
+	case USB_DWC3_DEVICE_MODE:
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GCTL, reg |
+			      DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_DEVICE));
+		break;
+	case USB_DWC3_HOST_MODE:
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GCTL, reg |
+			      DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_HOST));
+		break;
+	case USB_DWC3_DRD_MODE:
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GCTL, reg |
+			      DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_OTG));
+		break;
+	default:
+		ret = USBD_FAIL;
+		break;
+	}
+
+	return ret;
+}
+
+static enum usb_status dwc3_set_dev_speed(dwc3_handle_t *dwc3_handle, uint8_t speed)
+{
+	uint32_t reg;
+	enum usb_status ret = USBD_OK;
+
+	reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DCFG) & ~USB3_DCFG_DEVSPD_MSK;
+
+	switch (speed) {
+	case USB_DWC3_SPEED_SUPER:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg | DWC3_DSTS_SUPERSPEED);
+		INFO("%s = SuperSpeed\n", __func__);
+		break;
+	case USB_DWC3_SPEED_HIGH:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_HIGHSPEED);
+		INFO("%s = HighSpeed\n", __func__);
+		break;
+	case USB_DWC3_SPEED_FULL_48:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_FULLSPEED1);
+		INFO("%s = FullSpeed_48M\n", __func__);
+		break;
+	case USB_DWC3_SPEED_FULL:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_FULLSPEED2);
+		INFO("%s = FullSpeed\n", __func__);
+		break;
+	case USB_DWC3_SPEED_LOW:
+		DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |  DWC3_DSTS_LOWSPEED);
+		INFO("%s = LowSpeed\n", __func__);
+		break;
+	default:
+		ret = USBD_FAIL;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * @brief  USB_DevInit : Initializes the USB3 controller registers
+ *         for device mode
+ * @param  USBx  Selected device
+ * @param  cfg   pointer to a USB_DWC3_CfgTypeDef structure that contains
+ *         the configuration information for the specified USBx peripheral.
+ * @retval HAL status
+ */
+enum usb_status dwc3_dev_init(dwc3_handle_t *dwc3_handle, uint8_t speed, uint8_t intr_dev)
+{
+	uint32_t reg;
+	uint8_t i;
+	dwc3_epcmd_params_t params;
+	enum usb_status ret;
+
+	/* Setup event buffers k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTADRLO(i),
+			      lower_32_bits(dwc3_handle->intbuffers.evtbuffer_dma_addr[i]));
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTADRHI(i),
+			      upper_32_bits(dwc3_handle->intbuffers.evtbuffer_dma_addr[i]));
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTSIZ(i),
+			      USB_DWC3_EVENT_BUFFER_SIZE);
+		DWC3_regwrite(dwc3_handle->usb_global, DWC3_GEVNTCOUNT(i), 0);
+
+		/* EvtBufferPos[i] = 0;  Implicit since static done in HAL */
+	}
+
+	ret = dwc3_set_current_mode(dwc3_handle, USB_DWC3_DEVICE_MODE);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	ret = dwc3_set_dev_speed(dwc3_handle, speed);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Issue a DEPSTARTCFG command with DEPCMD0.XferRscIdx set to 0,
+	 * to initialize the transfer resource allocation
+	 */
+	zeromem(&params, sizeof(params));
+	ret = dwc3_execute_dep_cmd(dwc3_handle, 0, DWC3_DEPCMD_PARAM(0) |
+				   USB_DWC3_DEPCMD_DEPSTARTCFG, &params);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Configure Control EP 0 & 1 mapped to physical EP 0 & 1*/
+	ret = dwc3_ep_configure(dwc3_handle, 0, false, EP_TYPE_CTRL,
+				dwc3_handle->pcd_handle->out_ep[0].maxpacket, 0, 0, 0,
+				dwc3_handle->OUT_ep[0].intr_num, USB_DWC3_DEPCFG_ACTION_INIT);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+	ret = dwc3_ep_configure(dwc3_handle, 0, true, EP_TYPE_CTRL,
+				dwc3_handle->pcd_handle->in_ep[0].maxpacket, 0, 0, 1,
+				dwc3_handle->IN_ep[0].intr_num, USB_DWC3_DEPCFG_ACTION_INIT);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Transfer Resource for Control EP 0 & 1*/
+	(void)memset(&params, 0x00, sizeof(params));
+	params.param0 = DWC3_DEPXFERCFG_NUM_XFER_RES(1U);
+	/* As per databook, "Issue a DEPSTARTCFG command with DEPCMD0.XferRscIdx set to 2 to
+	 * re-initialize the transfer resource allocation on SetConfiguration or SetInterface
+	 * Request", value is 2 since the EP0 & EP1 take up the transfer resource 1 & 2, hence
+	 * further EPs will take resources 2,3,&up.. But in HAL we are not decoding the
+	 * Setup-packet requests, this should ideally come from USB-MW core.
+	 * Instead we follow the same method as Linux dwc3-gadget controller driver, All hardware
+	 * endpoints can be assigned a transfer resource and this setting will stay persistent
+	 * until either a core reset or hibernation. So whenever we do a DEPSTARTCFG(0) we can go
+	 * ahead and do DEPXFERCFG for every hardware endpoint as well.
+	 * For all k = DWC3_IP_NUM_EPS
+	 */
+	for (i = 0; i < DWC3_IP_NUM_EPS; i++) {
+		ret = dwc3_execute_dep_cmd(dwc3_handle, i, USB_DWC3_DEPCMD_SETTRANSFRESOURCE,
+					   &params);
+		if (ret != USBD_OK) {
+			ERROR("%s: %d\n", __func__, __LINE__);
+			return ret;
+		}
+	}
+
+	/* setup EP0 to receive SETUP packets */
+	ret = dwc3_ep0_out_start(dwc3_handle, dwc3_handle->setup_dma_addr);
+	if (ret != USBD_OK) {
+		ERROR("%s: %d\n", __func__, __LINE__);
+		return ret;
+	}
+
+	/* Enable EP 0 & 1 */
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DALEPENA, DWC3_DALEPENA_EP(0) |
+			  DWC3_DALEPENA_EP(1));
+
+	/*
+	 * Set interrupt/EventQ number on which non-endpoint-specific device-related
+	 * interrupts are generated
+	 */
+	reg = DWC3_regread(dwc3_handle->usb_device, DWC3_DCFG) & ~USB3_DCFG_INTRNUM_MSK;
+	DWC3_regwrite(dwc3_handle->usb_device, DWC3_DCFG, reg |
+		      ((uint32_t)intr_dev << USB3_DCFG_INTRNUM_POS));
+
+	/* Enable all events but Start and End of Frame IRQs */
+	DWC3_regupdateset(dwc3_handle->usb_device, DWC3_DEVTEN, USB3_DEVTEN_VENDEVTSTRCVDEN |
+			  USB3_DEVTEN_EVNTOVERFLOWEN | USB3_DEVTEN_CMDCMPLTEN |
+			  USB3_DEVTEN_ERRTICERREVTEN | USB3_DEVTEN_U3L2L1SUSPEN |
+			  USB3_DEVTEN_HIBERNATIONREQEVTEN | USB3_DEVTEN_WKUPEVTEN |
+			  USB3_DEVTEN_ULSTCNGEN | USB3_DEVTEN_CONNECTDONEEVTEN |
+			  USB3_DEVTEN_USBRSTEVTEN | USB3_DEVTEN_DISSCONNEVTEN |
+			  USB3_DEVTEN_L1SUSPEN | USB3_DEVTEN_L1WKUPEVTEN
+			  /* | USB3_DEVTEN_SOFTEVTEN*/);
+
+	/* Enable Event Buffer interrupt k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		__HAL_PCD_ENABLE_INTR(dwc3_handle, i);
+	}
+
+	return USBD_OK;
+}
+
+void usb_dwc3_init_driver(struct usb_handle *usb_core_handle, struct pcd_handle *pcd_handle,
+			  dwc3_handle_t *dwc3_handle, void *base_addr)
+{
+	uint32_t i = 0;
+	enum usb_status ret;
+	uintptr_t base = (uintptr_t)base_addr;
+
+	dwc3_handle->usb_global = (usb_dwc3_global_t *)
+					(base + USB_DWC3_GLOBAL_BASE);
+
+	dwc3_handle->usb_device = (usb_dwc3_device_t *)
+					(base + USB_DWC3_DEVICE_BASE);
+
+	dwc3_handle->pcd_handle = pcd_handle;
+
+	/* Check hpcd->State is HAL_PCD_STATE_RESET, otherwise error */
+	assert(dwc3_handle->State == HAL_PCD_STATE_RESET);
+
+	dwc3_handle->State = HAL_PCD_STATE_BUSY;
+
+	/* Disable the Interrupts */
+	// Not required since USB device and EP interrupts are disabled at boot, ***ToCheck
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		__HAL_PCD_DISABLE_INTR(dwc3_handle, i);
+	}
+
+	/* Init the Core (common init.) */
+	ret = dwc3_core_init(dwc3_handle, USBPHY_UTMI);
+	if (ret != USBD_OK) {
+		panic();
+	}
+
+	/* Init endpoints structures */
+	for (i = 0; i < USB_DWC3_NUM_IN_EP ; i++) {
+		/* Init ep structure */
+		pcd_handle->in_ep[i].is_in = true;
+		pcd_handle->in_ep[i].num = i;
+		dwc3_handle->IN_ep[i].tx_fifo_num = i;
+		/* Control until ep is activated */
+		pcd_handle->in_ep[i].type = EP_TYPE_CTRL;
+
+		/*
+		 * We are doing 1:1 alternate mapping for endpoints, meaning
+		 * IN Endpoint X maps to Physical Endpoint 2*X +1 and
+		 * OUT Endpoint X maps to Physical Endpoint 2*X.
+		 * So USB endpoint 0x81 is 0x03.
+		 */
+		dwc3_handle->IN_ep[i].phy_epnum = __HAL_PCD_EPADDR_TO_PHYEPNUM(i | EP_DIR_IN);
+
+		dwc3_handle->IN_ep[i].intr_num = PCD_DEV_EVENTS_INTR;
+	}
+
+	for (i = 0; i < USB_DWC3_NUM_OUT_EP ; i++) {
+		/* Init ep structure */
+		pcd_handle->out_ep[i].is_in = false;
+		pcd_handle->out_ep[i].num = i;
+		dwc3_handle->OUT_ep[i].tx_fifo_num = i;
+		/* Control until ep is activated */
+		pcd_handle->out_ep[i].type = EP_TYPE_CTRL;
+
+		/*
+		 * We are doing 1:1 alternate mapping for endpoints, meaning
+		 * IN Endpoint X maps to Physical Endpoint 2*X +1 and
+		 * OUT Endpoint X maps to Physical Endpoint 2*X.
+		 * So USB endpoint 0x81 is 0x03.
+		 */
+		dwc3_handle->OUT_ep[i].phy_epnum = __HAL_PCD_EPADDR_TO_PHYEPNUM(i);
+
+		dwc3_handle->OUT_ep[i].intr_num = PCD_DEV_EVENTS_INTR;
+
+		dwc3_handle->OUT_ep[i].bounce_buf = dwc3_handle->bounce_bufs[i].bounce_buf;
+	}
+
+#define PHYS_AREA	STM32MP_USB_DWC3_BASE
+
+#define EVTBUF_AREA_OFFSET	0U
+#define TRB_OUT_AREA_OFFSET	(EVTBUF_AREA_OFFSET + USB_DWC3_EVENT_BUFFER_SIZE)
+#define TRB_IN_AREA_OFFSET	(TRB_OUT_AREA_OFFSET + sizeof(usb_dwc3_trb_t))
+#define SETUP_AREA_OFFSET	(TRB_IN_AREA_OFFSET + sizeof(usb_dwc3_trb_t))
+
+	void *coh_area = (void *)(uintptr_t)PHYS_AREA;
+
+#define EVTBUF_AREA	(coh_area + EVTBUF_AREA_OFFSET)
+#define TRB_OUT_AREA	(coh_area + TRB_OUT_AREA_OFFSET)
+#define TRB_IN_AREA	(coh_area + TRB_IN_AREA_OFFSET)
+#define SETUP_AREA	(coh_area + SETUP_AREA_OFFSET)
+
+	dwc3_handle->setup_dma_addr = (uintptr_t)api_getdmaaddr((void *)SETUP_AREA,
+								USB_SETUP_PACKET_SIZE, 1);
+	assert(dwc3_handle->setup_dma_addr != 0U);
+
+	dwc3_handle->setup_addr = SETUP_AREA;
+	assert(dwc3_handle->setup_addr != NULL);
+
+	/* Map DMA and Coherent address for event buffers k = USB_DWC3_INT_INUSE */
+	for (i = 0; i < USB_DWC3_INT_INUSE; i++) {
+		dwc3_handle->intbuffers.evtbuffer_dma_addr[i] =
+			api_getdmaaddr((void *)EVTBUF_AREA, USB_DWC3_EVENT_BUFFER_SIZE, 1);
+		assert(dwc3_handle->intbuffers.evtbuffer_dma_addr[i] != 0U);
+
+		dwc3_handle->intbuffers.evtbuffer_addr[i] = EVTBUF_AREA;
+		assert(dwc3_handle->intbuffers.evtbuffer_addr[i] != NULL);
+
+		dwc3_handle->intbuffers.evtbufferpos[i] = 0;
+
+		INFO("EventBuffer%u: BuffArea=%lx DmaAddr=%08x CoherentMapAddr=%p\n", i,
+			   (PHYS_AREA + EVTBUF_AREA_OFFSET),
+			   (uint32_t)dwc3_handle->intbuffers.evtbuffer_dma_addr[i],
+			   dwc3_handle->intbuffers.evtbuffer_addr[i]);
+	}
+
+	/* MAP TRB Coherent and DMA address for EP0IN and EP0OUT */
+	dwc3_handle->IN_ep[0].trb_dma_addr = (uint32_t)api_getdmaaddr((void *)TRB_IN_AREA,
+								      sizeof(usb_dwc3_trb_t), 1);
+	assert(dwc3_handle->IN_ep[0].trb_dma_addr != 0U);
+
+	dwc3_handle->IN_ep[0].trb_addr = (usb_dwc3_trb_t *)TRB_IN_AREA;
+	assert(dwc3_handle->IN_ep[0].trb_addr != NULL);
+
+	dwc3_handle->OUT_ep[0].trb_dma_addr = (uint32_t)api_getdmaaddr((void *)TRB_OUT_AREA,
+								       sizeof(usb_dwc3_trb_t),
+								       1);
+	assert(dwc3_handle->OUT_ep[0].trb_dma_addr != 0U);
+
+	dwc3_handle->OUT_ep[0].trb_addr = (usb_dwc3_trb_t *)TRB_OUT_AREA;
+	assert(dwc3_handle->OUT_ep[0].trb_addr != NULL);
+
+	/* Init Device */
+	dwc3_handle->EP0_State = HAL_PCD_EP0_SETUP_QUEUED;
+
+	ret = dwc3_dev_init(dwc3_handle, USB_DWC3_SPEED_HIGH, PCD_DEV_EVENTS_INTR);
+	assert(ret == USBD_OK);
+
+	dwc3_handle->State = HAL_PCD_STATE_READY;
+
+	register_usb_driver(usb_core_handle, pcd_handle, &usb_dwc3driver,
+			    dwc3_handle);
+}
diff --git a/drivers/st/usb_dwc3/usb_dwc3_regs.h b/drivers/st/usb_dwc3/usb_dwc3_regs.h
new file mode 100644
index 0000000000..fbc4172d85
--- /dev/null
+++ b/drivers/st/usb_dwc3/usb_dwc3_regs.h
@@ -0,0 +1,1225 @@
+/*
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __USB_DWC3_REGS_H
+#define __USB_DWC3_REGS_H
+
+/*
+ * USB3 Global Register Block
+ */
+#define _DWC3_GSBUSCFG0					U(0x0)
+#define _DWC3_GSBUSCFG1					U(0x4)
+#define _DWC3_GTXTHRCFG					U(0x8)
+#define _DWC3_GRXTHRCFG					U(0xC)
+#define _DWC3_GCTL					U(0x10)
+#define _DWC3_GPMSTS					U(0x14)
+#define _DWC3_GSTS					U(0x18)
+#define _DWC3_GUCTL1					U(0x1C)
+#define _DWC3_GSNPSID					U(0x20)
+#define _DWC3_GGPIO					U(0x24)
+#define _DWC3_GUID					U(0x28)
+#define _DWC3_GUCTL					U(0x2C)
+#define _DWC3_GBUSERRADDRLO				U(0x30)
+#define _DWC3_GBUSERRADDRHI				U(0x34)
+#define _DWC3_GPRTBIMAPLO				U(0x38)
+#define _DWC3_GPRTBIMAPHI				U(0x3C)
+#define _DWC3_GHWPARAMS0				U(0x40)
+#define _DWC3_GHWPARAMS1				U(0x44)
+#define _DWC3_GHWPARAMS2				U(0x48)
+#define _DWC3_GHWPARAMS3				U(0x4C)
+#define _DWC3_GHWPARAMS4				U(0x50)
+#define _DWC3_GHWPARAMS5				U(0x54)
+#define _DWC3_GHWPARAMS6				U(0x58)
+#define _DWC3_GHWPARAMS7				U(0x5C)
+#define _DWC3_GDBGFIFOSPACE				U(0x60)
+#define _DWC3_GDBGLTSSM					U(0x64)
+#define _DWC3_GDBGLNMCC					U(0x68)
+#define _DWC3_GDBGBMU					U(0x6C)
+#define _DWC3_GDBGLSPMUX_HST				U(0x70)
+#define _DWC3_GDBGLSP					U(0x74)
+#define _DWC3_GDBGEPINFO0				U(0x78)
+#define _DWC3_GDBGEPINFO1				U(0x7C)
+#define _DWC3_GPRTBIMAP_HSLO				U(0x80)
+#define _DWC3_GPRTBIMAP_HSHI				U(0x84)
+#define _DWC3_GPRTBIMAP_FSLO				U(0x88)
+#define _DWC3_GPRTBIMAP_FSHI				U(0x8C)
+#define _DWC3_GUCTL2					U(0x9C)
+#define _DWC3_GUSB2PHYCFG				U(0x100)
+#define _DWC3_GUSB2I2CCTL				U(0x140)
+#define _DWC3_GUSB2PHYACC_ULPI				U(0x180)
+#define _DWC3_GUSB3PIPECTL				U(0x1c0)
+#define _DWC3_GTXFIFOSIZ0				U(0x200)
+#define _DWC3_GTXFIFOSIZ1				U(0x204)
+#define _DWC3_GTXFIFOSIZ2				U(0x208)
+#define _DWC3_GTXFIFOSIZ3				U(0x20c)
+#define _DWC3_GTXFIFOSIZ4				U(0x210)
+#define _DWC3_GTXFIFOSIZ5				U(0x214)
+#define _DWC3_GTXFIFOSIZ6				U(0x218)
+#define _DWC3_GTXFIFOSIZ7				U(0x21c)
+#define _DWC3_GTXFIFOSIZ8				U(0x220)
+#define _DWC3_GTXFIFOSIZ9				U(0x224)
+#define _DWC3_GTXFIFOSIZ10				U(0x228)
+#define _DWC3_GTXFIFOSIZ11				U(0x22c)
+#define _DWC3_GRXFIFOSIZ0				U(0x280)
+#define _DWC3_GRXFIFOSIZ1				U(0x284)
+#define _DWC3_GRXFIFOSIZ2				U(0x288)
+#define _DWC3_GEVNTADRLO				U(0x300)
+#define _DWC3_GEVNTADRHI				U(0x304)
+#define _DWC3_GEVNTSIZ					U(0x308)
+#define _DWC3_GEVNTCOUNT				U(0x30c)
+#define _DWC3_GHWPARAMS8				U(0x500)
+#define _DWC3_GTXFIFOPRIDEV				U(0x510)
+#define _DWC3_GTXFIFOPRIHST				U(0x518)
+#define _DWC3_GRXFIFOPRIHST				U(0x51C)
+#define _DWC3_GDMAHLRATIO				U(0x524)
+#define _DWC3_GFLADJ					U(0x530)
+
+/* _DWC3_GSBUSCFG0 register fields */
+#define _DWC3_GSBUSCFG0_INCRBRSTENA			BIT_32(0)
+#define _DWC3_GSBUSCFG0_INCR4BRSTENA			BIT_32(1)
+#define _DWC3_GSBUSCFG0_INCR8BRSTENA			BIT_32(2)
+#define _DWC3_GSBUSCFG0_INCR16BRSTENA			BIT_32(3)
+#define _DWC3_GSBUSCFG0_INCR32BRSTENA			BIT_32(4)
+#define _DWC3_GSBUSCFG0_INCR64BRSTENA			BIT_32(5)
+#define _DWC3_GSBUSCFG0_INCR128BRSTENA			BIT_32(6)
+#define _DWC3_GSBUSCFG0_INCR256BRSTENA			BIT_32(7)
+#define _DWC3_GSBUSCFG0_DESBIGEND			BIT_32(10)
+#define _DWC3_GSBUSCFG0_DATBIGEND			BIT_32(11)
+#define _DWC3_GSBUSCFG0_DESWRREQINFO_MASK		GENMASK_32(19, 16)
+#define _DWC3_GSBUSCFG0_DESWRREQINFO_SHIFT		16
+#define _DWC3_GSBUSCFG0_DATWRREQINFO_MASK		GENMASK_32(23, 20)
+#define _DWC3_GSBUSCFG0_DATWRREQINFO_SHIFT		20
+#define _DWC3_GSBUSCFG0_DESRDREQINFO_MASK		GENMASK_32(27, 24)
+#define _DWC3_GSBUSCFG0_DESRDREQINFO_SHIFT		24
+#define _DWC3_GSBUSCFG0_DATRDREQINFO_MASK		GENMASK_32(31, 28)
+#define _DWC3_GSBUSCFG0_DATRDREQINFO_SHIFT		28
+
+/* _DWC3_GSBUSCFG1 register fields */
+#define _DWC3_GSBUSCFG1_PIPETRANSLIMIT_MASK		GENMASK_32(11, 8)
+#define _DWC3_GSBUSCFG1_PIPETRANSLIMIT_SHIFT		8
+#define _DWC3_GSBUSCFG1_EN1KPAGE			BIT_32(12)
+
+/* _DWC3_GTXTHRCFG register fields */
+#define _DWC3_GTXTHRCFG_USBMAXTXBURSTSIZE_MASK		GENMASK_32(23, 16)
+#define _DWC3_GTXTHRCFG_USBMAXTXBURSTSIZE_SHIFT		16
+#define _DWC3_GTXTHRCFG_USBTXPKTCNT_MASK		GENMASK_32(27, 24)
+#define _DWC3_GTXTHRCFG_USBTXPKTCNT_SHIFT		24
+#define _DWC3_GTXTHRCFG_USBTXPKTCNTSEL			BIT_32(29)
+
+/* _DWC3_GRXTHRCFG register fields */
+#define _DWC3_GRXTHRCFG_RESVISOCOUTSPC_MASK		GENMASK_32(12, 0)
+#define _DWC3_GRXTHRCFG_RESVISOCOUTSPC_SHIFT		0
+#define _DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_MASK		GENMASK_32(23, 19)
+#define _DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_SHIFT		19
+#define _DWC3_GRXTHRCFG_USBRXPKTCNT_MASK		GENMASK_32(27, 24)
+#define _DWC3_GRXTHRCFG_USBRXPKTCNT_SHIFT		24
+#define _DWC3_GRXTHRCFG_USBRXPKTCNTSEL			BIT_32(29)
+
+/* _DWC3_GCTL register fields */
+#define _DWC3_GCTL_DSBLCLKGTNG				BIT_32(0)
+#define _DWC3_GCTL_GBLHIBERNATIONEN			BIT_32(1)
+#define _DWC3_GCTL_U2EXIT_LFPS				BIT_32(2)
+#define _DWC3_GCTL_DISSCRAMBLE				BIT_32(3)
+#define _DWC3_GCTL_SCALEDOWN_MASK			GENMASK_32(5, 4)
+#define _DWC3_GCTL_SCALEDOWN_SHIFT			4
+#define _DWC3_GCTL_RAMCLKSEL_MASK			GENMASK_32(7, 6)
+#define _DWC3_GCTL_RAMCLKSEL_SHIFT			6
+#define _DWC3_GCTL_DEBUGATTACH				BIT_32(8)
+#define _DWC3_GCTL_U1U2TIMERSCALE			BIT_32(9)
+#define _DWC3_GCTL_SOFITPSYNC				BIT_32(10)
+#define _DWC3_GCTL_CORESOFTRESET			BIT_32(11)
+#define _DWC3_GCTL_PRTCAPDIR_MASK			GENMASK_32(13, 12)
+#define _DWC3_GCTL_PRTCAPDIR_SHIFT			12
+#define _DWC3_GCTL_FRMSCLDWN_MASK			GENMASK_32(15, 14)
+#define _DWC3_GCTL_FRMSCLDWN_SHIFT			14
+#define _DWC3_GCTL_U2RSTECN				BIT_32(16)
+#define _DWC3_GCTL_BYPSSETADDR				BIT_32(17)
+#define _DWC3_GCTL_MASTERFILTBYPASS			BIT_32(18)
+#define _DWC3_GCTL_PWRDNSCALE_MASK			GENMASK_32(31, 19)
+#define _DWC3_GCTL_PWRDNSCALE_SHIFT			19
+
+/* _DWC3_GPMSTS register fields */
+#define _DWC3_GPMSTS_U2WAKEUP_MASK			GENMASK_32(9, 0)
+#define _DWC3_GPMSTS_U2WAKEUP_SHIFT			0
+#define _DWC3_GPMSTS_U3WAKEUP_MASK			GENMASK_32(16, 12)
+#define _DWC3_GPMSTS_U3WAKEUP_SHIFT			12
+#define _DWC3_GPMSTS_PORTSEL_MASK			GENMASK_32(31, 28)
+#define _DWC3_GPMSTS_PORTSEL_SHIFT			28
+
+/* _DWC3_GSTS register fields */
+#define _DWC3_GSTS_CURMOD_MASK				GENMASK_32(1, 0)
+#define _DWC3_GSTS_CURMOD_SHIFT				0
+#define _DWC3_GSTS_BUSERRADDRVLD			BIT_32(4)
+#define _DWC3_GSTS_CSRTIMEOUT				BIT_32(5)
+#define _DWC3_GSTS_DEVICE_IP				BIT_32(6)
+#define _DWC3_GSTS_HOST_IP				BIT_32(7)
+#define _DWC3_GSTS_ADP_IP				BIT_32(8)
+#define _DWC3_GSTS_BC_IP				BIT_32(9)
+#define _DWC3_GSTS_OTG_IP				BIT_32(10)
+#define _DWC3_GSTS_SSIC_IP				BIT_32(11)
+#define _DWC3_GSTS_CBELT_MASK				GENMASK_32(31, 20)
+#define _DWC3_GSTS_CBELT_SHIFT				20
+
+/* _DWC3_GUCTL1 register fields */
+#define _DWC3_GUCTL1_LOA_FILTER_EN			BIT_32(0)
+#define _DWC3_GUCTL1_OVRLD_L1_SUSP_COM			BIT_32(1)
+#define _DWC3_GUCTL1_HC_PARCHK_DISABLE			BIT_32(2)
+#define _DWC3_GUCTL1_HC_ERRATA_ENABLE			BIT_32(3)
+#define _DWC3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_MASK	GENMASK_32(7, 4)
+#define _DWC3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_SHIFT	4
+#define _DWC3_GUCTL1_L1_SUSP_THRLD_EN_FOR_HOST		BIT_32(8)
+#define _DWC3_GUCTL1_DEV_HS_NYET_BULK_SPR		BIT_32(9)
+#define _DWC3_GUCTL1_RESUME_OPMODE_HS_HOST		BIT_32(10)
+#define _DWC3_GUCTL1_PARKMODE_DISABLE_FSLS		BIT_32(15)
+#define _DWC3_GUCTL1_PARKMODE_DISABLE_HS		BIT_32(16)
+#define _DWC3_GUCTL1_PARKMODE_DISABLE_SS		BIT_32(17)
+#define _DWC3_GUCTL1_NAK_PER_ENH_HS			BIT_32(18)
+#define _DWC3_GUCTL1_NAK_PER_ENH_FS			BIT_32(19)
+#define _DWC3_GUCTL1_DEV_LSP_TAIL_LOCK_DIS		BIT_32(20)
+#define _DWC3_GUCTL1_IP_GAP_ADD_ON_MASK			GENMASK_32(23, 21)
+#define _DWC3_GUCTL1_IP_GAP_ADD_ON_SHIFT		21
+#define _DWC3_GUCTL1_DEV_L1_EXIT_BY_HW			BIT_32(24)
+#define _DWC3_GUCTL1_P3_IN_U2				BIT_32(25)
+#define _DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK	BIT_32(26)
+#define _DWC3_GUCTL1_DEV_TRB_OUT_SPR_IND		BIT_32(27)
+#define _DWC3_GUCTL1_TX_IPGAP_LINECHECK_DIS		BIT_32(28)
+#define _DWC3_GUCTL1_FILTER_SE0_FSLS_EOP		BIT_32(29)
+#define _DWC3_GUCTL1_DS_RXDET_MAX_TOUT_CTRL		BIT_32(30)
+#define _DWC3_GUCTL1_DEV_DECOUPLE_L1L2_EVT		BIT_32(31)
+
+/* _DWC3_GGPIO register fields */
+#define _DWC3_GGPIO_GPI_MASK				GENMASK_32(15, 0)
+#define _DWC3_GGPIO_GPI_SHIFT				0
+#define _DWC3_GGPIO_GPO_MASK				GENMASK_32(31, 16)
+#define _DWC3_GGPIO_GPO_SHIFT				16
+
+/* _DWC3_GUCTL register fields */
+#define _DWC3_GUCTL_DTFT_MASK				GENMASK_32(8, 0)
+#define _DWC3_GUCTL_DTFT_SHIFT				0
+#define _DWC3_GUCTL_DTCT_MASK				GENMASK_32(10, 9)
+#define _DWC3_GUCTL_DTCT_SHIFT				9
+#define _DWC3_GUCTL_INSRTEXTRFSBODI			BIT_32(11)
+#define _DWC3_GUCTL_EXTCAPSUPPTEN			BIT_32(12)
+#define _DWC3_GUCTL_ENOVERLAPCHK			BIT_32(13)
+#define _DWC3_GUCTL_USBHSTINAUTORETRYEN			BIT_32(14)
+#define _DWC3_GUCTL_RESBWHSEPS				BIT_32(16)
+#define _DWC3_GUCTL_SPRSCTRLTRANSEN			BIT_32(17)
+#define _DWC3_GUCTL_NOEXTRDL				BIT_32(21)
+#define _DWC3_GUCTL_REFCLKPER_MASK			GENMASK_32(31, 22)
+#define _DWC3_GUCTL_REFCLKPER_SHIFT			22
+
+/* _DWC3_GPRTBIMAPLO register fields */
+#define _DWC3_GPRTBIMAPLO_BINUM1_MASK			GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAPLO_BINUM1_SHIFT			0
+#define _DWC3_GPRTBIMAPLO_BINUM2_MASK			GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAPLO_BINUM2_SHIFT			4
+#define _DWC3_GPRTBIMAPLO_BINUM3_MASK			GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAPLO_BINUM3_SHIFT			8
+#define _DWC3_GPRTBIMAPLO_BINUM4_MASK			GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAPLO_BINUM4_SHIFT			12
+#define _DWC3_GPRTBIMAPLO_BINUM5_MASK			GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAPLO_BINUM5_SHIFT			16
+#define _DWC3_GPRTBIMAPLO_BINUM6_MASK			GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAPLO_BINUM6_SHIFT			20
+#define _DWC3_GPRTBIMAPLO_BINUM7_MASK			GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAPLO_BINUM7_SHIFT			24
+#define _DWC3_GPRTBIMAPLO_BINUM8_MASK			GENMASK_32(31, 28)
+#define _DWC3_GPRTBIMAPLO_BINUM8_SHIFT			28
+
+/* _DWC3_GPRTBIMAPHI register fields */
+#define _DWC3_GPRTBIMAPHI_BINUM9_MASK			GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAPHI_BINUM9_SHIFT			0
+#define _DWC3_GPRTBIMAPHI_BINUM10_MASK			GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAPHI_BINUM10_SHIFT			4
+#define _DWC3_GPRTBIMAPHI_BINUM11_MASK			GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAPHI_BINUM11_SHIFT			8
+#define _DWC3_GPRTBIMAPHI_BINUM12_MASK			GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAPHI_BINUM12_SHIFT			12
+#define _DWC3_GPRTBIMAPHI_BINUM13_MASK			GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAPHI_BINUM13_SHIFT			16
+#define _DWC3_GPRTBIMAPHI_BINUM14_MASK			GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAPHI_BINUM14_SHIFT			20
+#define _DWC3_GPRTBIMAPHI_BINUM15_MASK			GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAPHI_BINUM15_SHIFT			24
+
+/* _DWC3_GHWPARAMS0 register fields */
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_2_0_MASK		GENMASK_32(2, 0)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_2_0_SHIFT		0
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_5_3_MASK		GENMASK_32(5, 3)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_5_3_SHIFT		3
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_7_6_MASK		GENMASK_32(7, 6)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_7_6_SHIFT		6
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_15_8_MASK		GENMASK_32(15, 8)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_15_8_SHIFT		8
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_23_16_MASK		GENMASK_32(23, 16)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_23_16_SHIFT		16
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_31_24_MASK		GENMASK_32(31, 24)
+#define _DWC3_GHWPARAMS0_GHWPARAMS0_31_24_SHIFT		24
+
+/* _DWC3_GHWPARAMS1 register fields */
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_2_0_MASK		GENMASK_32(2, 0)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_2_0_SHIFT		0
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_5_3_MASK		GENMASK_32(5, 3)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_5_3_SHIFT		3
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_8_6_MASK		GENMASK_32(8, 6)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_8_6_SHIFT		6
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_11_9_MASK		GENMASK_32(11, 9)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_11_9_SHIFT		9
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_14_12_MASK		GENMASK_32(14, 12)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_14_12_SHIFT		12
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_20_15_MASK		GENMASK_32(20, 15)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_20_15_SHIFT		15
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_22_21_MASK		GENMASK_32(22, 21)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_22_21_SHIFT		21
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_23			BIT_32(23)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_25_24_MASK		GENMASK_32(25, 24)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_25_24_SHIFT		24
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_26			BIT_32(26)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_27			BIT_32(27)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_28			BIT_32(28)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_29			BIT_32(29)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_30			BIT_32(30)
+#define _DWC3_GHWPARAMS1_GHWPARAMS1_31			BIT_32(31)
+
+/* _DWC3_GHWPARAMS3 register fields */
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_1_0_MASK		GENMASK_32(1, 0)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_1_0_SHIFT		0
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_3_2_MASK		GENMASK_32(3, 2)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_3_2_SHIFT		2
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_5_4_MASK		GENMASK_32(5, 4)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_5_4_SHIFT		4
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_7_6_MASK		GENMASK_32(7, 6)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_7_6_SHIFT		6
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_9_8_MASK		GENMASK_32(9, 8)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_9_8_SHIFT		8
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_10			BIT_32(10)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_11			BIT_32(11)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_17_12_MASK		GENMASK_32(17, 12)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_17_12_SHIFT		12
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_22_18_MASK		GENMASK_32(22, 18)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_22_18_SHIFT		18
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_30_23_MASK		GENMASK_32(30, 23)
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_30_23_SHIFT		23
+#define _DWC3_GHWPARAMS3_GHWPARAMS3_31			BIT_32(31)
+
+/* _DWC3_GHWPARAMS4 register fields */
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_5_0_MASK		GENMASK_32(5, 0)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_5_0_SHIFT		0
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_6			BIT_32(6)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_8_7_MASK		GENMASK_32(8, 7)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_8_7_SHIFT		7
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_10_9_MASK		GENMASK_32(10, 9)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_10_9_SHIFT		9
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_11			BIT_32(11)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_12			BIT_32(12)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_16_13_MASK		GENMASK_32(16, 13)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_16_13_SHIFT		13
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_20_17_MASK		GENMASK_32(20, 17)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_20_17_SHIFT		17
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_21			BIT_32(21)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_22			BIT_32(22)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_23			BIT_32(23)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_27_24_MASK		GENMASK_32(27, 24)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_27_24_SHIFT		24
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_31_28_MASK		GENMASK_32(31, 28)
+#define _DWC3_GHWPARAMS4_GHWPARAMS4_31_28_SHIFT		28
+
+/* _DWC3_GHWPARAMS5 register fields */
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_3_0_MASK		GENMASK_32(3, 0)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_3_0_SHIFT		0
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_9_4_MASK		GENMASK_32(9, 4)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_9_4_SHIFT		4
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_15_10_MASK		GENMASK_32(15, 10)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_15_10_SHIFT		10
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_21_16_MASK		GENMASK_32(21, 16)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_21_16_SHIFT		16
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_27_22_MASK		GENMASK_32(27, 22)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_27_22_SHIFT		22
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_31_28_MASK		GENMASK_32(31, 28)
+#define _DWC3_GHWPARAMS5_GHWPARAMS5_31_28_SHIFT		28
+
+/* _DWC3_GHWPARAMS6 register fields */
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_5_0_MASK		GENMASK_32(5, 0)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_5_0_SHIFT		0
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_6			BIT_32(6)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_7			BIT_32(7)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_9_8_MASK		GENMASK_32(9, 8)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_9_8_SHIFT		8
+#define _DWC3_GHWPARAMS6_SRPSUPPORT			BIT_32(10)
+#define _DWC3_GHWPARAMS6_HNPSUPPORT			BIT_32(11)
+#define _DWC3_GHWPARAMS6_ADPSUPPORT			BIT_32(12)
+#define _DWC3_GHWPARAMS6_OTG_SS_SUPPORT			BIT_32(13)
+#define _DWC3_GHWPARAMS6_BCSUPPORT			BIT_32(14)
+#define _DWC3_GHWPARAMS6_BUSFLTRSSUPPORT		BIT_32(15)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_31_16_MASK		GENMASK_32(31, 16)
+#define _DWC3_GHWPARAMS6_GHWPARAMS6_31_16_SHIFT		16
+
+/* _DWC3_GHWPARAMS7 register fields */
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_15_0_MASK		GENMASK_32(15, 0)
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_15_0_SHIFT		0
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_31_16_MASK		GENMASK_32(31, 16)
+#define _DWC3_GHWPARAMS7_GHWPARAMS7_31_16_SHIFT		16
+
+/* _DWC3_GDBGFIFOSPACE register fields */
+#define _DWC3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_MASK	GENMASK_32(8, 0)
+#define _DWC3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_SHIFT	0
+#define _DWC3_GDBGFIFOSPACE_SPACE_AVAILABLE_MASK	GENMASK_32(31, 16)
+#define _DWC3_GDBGFIFOSPACE_SPACE_AVAILABLE_SHIFT	16
+
+/* _DWC3_GDBGLTSSM register fields */
+#define _DWC3_GDBGLTSSM_TXONESZEROS			BIT_32(0)
+#define _DWC3_GDBGLTSSM_RXTERMINATION			BIT_32(1)
+#define _DWC3_GDBGLTSSM_TXSWING				BIT_32(2)
+#define _DWC3_GDBGLTSSM_LTDBCLKSTATE_MASK		GENMASK_32(5, 3)
+#define _DWC3_GDBGLTSSM_LTDBCLKSTATE_SHIFT		3
+#define _DWC3_GDBGLTSSM_TXDEEMPHASIS_MASK		GENMASK_32(7, 6)
+#define _DWC3_GDBGLTSSM_TXDEEMPHASIS_SHIFT		6
+#define _DWC3_GDBGLTSSM_RXEQTRAIN			BIT_32(8)
+#define _DWC3_GDBGLTSSM_POWERDOWN_MASK			GENMASK_32(10, 9)
+#define _DWC3_GDBGLTSSM_POWERDOWN_SHIFT			9
+#define _DWC3_GDBGLTSSM_LTDBPHYCMDSTATE_MASK		GENMASK_32(13, 11)
+#define _DWC3_GDBGLTSSM_LTDBPHYCMDSTATE_SHIFT		11
+#define _DWC3_GDBGLTSSM_TXDETRXLOOPBACK			BIT_32(14)
+#define _DWC3_GDBGLTSSM_RXPOLARITY			BIT_32(15)
+#define _DWC3_GDBGLTSSM_TXELECLDLE			BIT_32(16)
+#define _DWC3_GDBGLTSSM_ELASTICBUFFERMODE		BIT_32(17)
+#define _DWC3_GDBGLTSSM_LTDBSUBSTATE_MASK		GENMASK_32(21, 18)
+#define _DWC3_GDBGLTSSM_LTDBSUBSTATE_SHIFT		18
+#define _DWC3_GDBGLTSSM_LTDBLINKSTATE_MASK		GENMASK_32(25, 22)
+#define _DWC3_GDBGLTSSM_LTDBLINKSTATE_SHIFT		22
+#define _DWC3_GDBGLTSSM_LTDBTIMEOUT			BIT_32(26)
+#define _DWC3_GDBGLTSSM_PRTDIRECTION			BIT_32(27)
+#define _DWC3_GDBGLTSSM_X3_DS_HOST_SHUTDOWN		BIT_32(28)
+#define _DWC3_GDBGLTSSM_X3_XS_SWAPPING			BIT_32(29)
+#define _DWC3_GDBGLTSSM_RXELECIDLE			BIT_32(30)
+
+/* _DWC3_GDBGLNMCC register fields */
+#define _DWC3_GDBGLNMCC_LNMCC_BERC_MASK			GENMASK_32(8, 0)
+#define _DWC3_GDBGLNMCC_LNMCC_BERC_SHIFT		0
+
+/* _DWC3_GDBGBMU register fields */
+#define _DWC3_GDBGBMU_BMU_CCU_MASK			GENMASK_32(3, 0)
+#define _DWC3_GDBGBMU_BMU_CCU_SHIFT			0
+#define _DWC3_GDBGBMU_BMU_DCU_MASK			GENMASK_32(7, 4)
+#define _DWC3_GDBGBMU_BMU_DCU_SHIFT			4
+#define _DWC3_GDBGBMU_BMU_BCU_MASK			GENMASK_32(31, 8)
+#define _DWC3_GDBGBMU_BMU_BCU_SHIFT			8
+
+/* _DWC3_GDBGLSPMUX_HST register fields */
+#define _DWC3_GDBGLSPMUX_HST_HOSTSELECT_MASK		GENMASK_32(13, 0)
+#define _DWC3_GDBGLSPMUX_HST_HOSTSELECT_SHIFT		0
+#define _DWC3_GDBGLSPMUX_HST_LOGIC_ANALYZER_TRACE_MASK	GENMASK_32(23, 16)
+#define _DWC3_GDBGLSPMUX_HST_LOGIC_ANALYZER_TRACE_SHIFT	16
+
+/* _DWC3_GPRTBIMAP_HSLO register fields */
+#define _DWC3_GPRTBIMAP_HSLO_BINUM1_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM1_SHIFT		0
+#define _DWC3_GPRTBIMAP_HSLO_BINUM2_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM2_SHIFT		4
+#define _DWC3_GPRTBIMAP_HSLO_BINUM3_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM3_SHIFT		8
+#define _DWC3_GPRTBIMAP_HSLO_BINUM4_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM4_SHIFT		12
+#define _DWC3_GPRTBIMAP_HSLO_BINUM5_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM5_SHIFT		16
+#define _DWC3_GPRTBIMAP_HSLO_BINUM6_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM6_SHIFT		20
+#define _DWC3_GPRTBIMAP_HSLO_BINUM7_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM7_SHIFT		24
+#define _DWC3_GPRTBIMAP_HSLO_BINUM8_MASK		GENMASK_32(31, 28)
+#define _DWC3_GPRTBIMAP_HSLO_BINUM8_SHIFT		28
+
+/* _DWC3_GPRTBIMAP_HSHI register fields */
+#define _DWC3_GPRTBIMAP_HSHI_BINUM9_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM9_SHIFT		0
+#define _DWC3_GPRTBIMAP_HSHI_BINUM10_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM10_SHIFT		4
+#define _DWC3_GPRTBIMAP_HSHI_BINUM11_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM11_SHIFT		8
+#define _DWC3_GPRTBIMAP_HSHI_BINUM12_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM12_SHIFT		12
+#define _DWC3_GPRTBIMAP_HSHI_BINUM13_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM13_SHIFT		16
+#define _DWC3_GPRTBIMAP_HSHI_BINUM14_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM14_SHIFT		20
+#define _DWC3_GPRTBIMAP_HSHI_BINUM15_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_HSHI_BINUM15_SHIFT		24
+
+/* _DWC3_GPRTBIMAP_FSLO register fields */
+#define _DWC3_GPRTBIMAP_FSLO_BINUM1_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM1_SHIFT		0
+#define _DWC3_GPRTBIMAP_FSLO_BINUM2_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM2_SHIFT		4
+#define _DWC3_GPRTBIMAP_FSLO_BINUM3_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM3_SHIFT		8
+#define _DWC3_GPRTBIMAP_FSLO_BINUM4_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM4_SHIFT		12
+#define _DWC3_GPRTBIMAP_FSLO_BINUM5_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM5_SHIFT		16
+#define _DWC3_GPRTBIMAP_FSLO_BINUM6_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM6_SHIFT		20
+#define _DWC3_GPRTBIMAP_FSLO_BINUM7_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM7_SHIFT		24
+#define _DWC3_GPRTBIMAP_FSLO_BINUM8_MASK		GENMASK_32(31, 28)
+#define _DWC3_GPRTBIMAP_FSLO_BINUM8_SHIFT		28
+
+/* _DWC3_GPRTBIMAP_FSHI register fields */
+#define _DWC3_GPRTBIMAP_FSHI_BINUM9_MASK		GENMASK_32(3, 0)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM9_SHIFT		0
+#define _DWC3_GPRTBIMAP_FSHI_BINUM10_MASK		GENMASK_32(7, 4)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM10_SHIFT		4
+#define _DWC3_GPRTBIMAP_FSHI_BINUM11_MASK		GENMASK_32(11, 8)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM11_SHIFT		8
+#define _DWC3_GPRTBIMAP_FSHI_BINUM12_MASK		GENMASK_32(15, 12)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM12_SHIFT		12
+#define _DWC3_GPRTBIMAP_FSHI_BINUM13_MASK		GENMASK_32(19, 16)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM13_SHIFT		16
+#define _DWC3_GPRTBIMAP_FSHI_BINUM14_MASK		GENMASK_32(23, 20)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM14_SHIFT		20
+#define _DWC3_GPRTBIMAP_FSHI_BINUM15_MASK		GENMASK_32(27, 24)
+#define _DWC3_GPRTBIMAP_FSHI_BINUM15_SHIFT		24
+
+/* _DWC3_GUCTL2 register fields */
+#define _DWC3_GUCTL2_TXPINGDURATION_MASK		GENMASK_32(4, 0)
+#define _DWC3_GUCTL2_TXPINGDURATION_SHIFT		0
+#define _DWC3_GUCTL2_RXPINGDURATION_MASK		GENMASK_32(10, 5)
+#define _DWC3_GUCTL2_RXPINGDURATION_SHIFT		5
+#define _DWC3_GUCTL2_DISABLECFC				BIT_32(11)
+#define _DWC3_GUCTL2_ENABLEEPCACHEEVICT			BIT_32(12)
+#define _DWC3_GUCTL2_RST_ACTBITLATER			BIT_32(14)
+#define _DWC3_GUCTL2_NOLOWPWRDUR_MASK			GENMASK_32(18, 15)
+#define _DWC3_GUCTL2_NOLOWPWRDUR_SHIFT			15
+#define _DWC3_GUCTL2_EN_HP_PM_TIMER_MASK		GENMASK_32(25, 19)
+#define _DWC3_GUCTL2_EN_HP_PM_TIMER_SHIFT		19
+
+/* _DWC3_GTXFIFOPRIDEV register fields */
+#define _DWC3_GTXFIFOPRIDEV_GTXFIFOPRIDEV_MASK		GENMASK_32(11, 0)
+#define _DWC3_GTXFIFOPRIDEV_GTXFIFOPRIDEV_SHIFT		0
+
+/* _DWC3_GTXFIFOPRIHST register fields */
+#define _DWC3_GTXFIFOPRIHST_GTXFIFOPRIHST_MASK		GENMASK_32(2, 0)
+#define _DWC3_GTXFIFOPRIHST_GTXFIFOPRIHST_SHIFT		0
+
+/* _DWC3_GRXFIFOPRIHST register fields */
+#define _DWC3_GRXFIFOPRIHST_GRXFIFOPRIHST_MASK		GENMASK_32(2, 0)
+#define _DWC3_GRXFIFOPRIHST_GRXFIFOPRIHST_SHIFT		0
+
+/* _DWC3_GDMAHLRATIO register fields */
+#define _DWC3_GDMAHLRATIO_HSTTXFIFO_MASK		GENMASK_32(4, 0)
+#define _DWC3_GDMAHLRATIO_HSTTXFIFO_SHIFT		0
+#define _DWC3_GDMAHLRATIO_HSTRXFIFO_MASK		GENMASK_32(12, 8)
+#define _DWC3_GDMAHLRATIO_HSTRXFIFO_SHIFT		8
+
+/* _DWC3_GFLADJ register fields */
+#define _DWC3_GFLADJ_GFLADJ_30MHZ_MASK			GENMASK_32(5, 0)
+#define _DWC3_GFLADJ_GFLADJ_30MHZ_SHIFT			0
+#define _DWC3_GFLADJ_GFLADJ_30MHZ_SDBND_SEL		BIT_32(7)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_FLADJ_MASK		GENMASK_32(21, 8)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_FLADJ_SHIFT		8
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_LPM_SEL		BIT_32(23)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_MASK	GENMASK_32(30, 24)
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_SHIFT	24
+#define _DWC3_GFLADJ_GFLADJ_REFCLK_240MHZDECR_PLS1	BIT_32(31)
+
+/* _DWC3_GUSB2PHYCFG register fields */
+#define _DWC3_GUSB2PHYCFG_TOUTCAL_MASK			GENMASK_32(2, 0)
+#define _DWC3_GUSB2PHYCFG_TOUTCAL_SHIFT			0
+#define _DWC3_GUSB2PHYCFG_PHYIF				BIT_32(3)
+#define _DWC3_GUSB2PHYCFG_ULPI_UTMI_SEL			BIT_32(4)
+#define _DWC3_GUSB2PHYCFG_FSINTF			BIT_32(5)
+#define _DWC3_GUSB2PHYCFG_SUSPENDUSB20			BIT_32(6)
+#define _DWC3_GUSB2PHYCFG_PHYSEL			BIT_32(7)
+#define _DWC3_GUSB2PHYCFG_ENBLSLPM			BIT_32(8)
+#define _DWC3_GUSB2PHYCFG_XCVRDLY			BIT_32(9)
+#define _DWC3_GUSB2PHYCFG_USBTRDTIM_MASK		GENMASK_32(13, 10)
+#define _DWC3_GUSB2PHYCFG_USBTRDTIM_SHIFT		10
+#define _DWC3_GUSB2PHYCFG_ULPIAUTORES			BIT_32(15)
+#define _DWC3_GUSB2PHYCFG_ULPIEXTVBUSDRV		BIT_32(17)
+#define _DWC3_GUSB2PHYCFG_ULPIEXTVBUSINDIACTOR		BIT_32(18)
+#define _DWC3_GUSB2PHYCFG_LSIPD_MASK			GENMASK_32(21, 19)
+#define _DWC3_GUSB2PHYCFG_LSIPD_SHIFT			19
+#define _DWC3_GUSB2PHYCFG_LSTRD_MASK			GENMASK_32(24, 22)
+#define _DWC3_GUSB2PHYCFG_LSTRD_SHIFT			22
+#define _DWC3_GUSB2PHYCFG_INV_SEL_HSIC			BIT_32(26)
+#define _DWC3_GUSB2PHYCFG_HSIC_CON_WIDTH_ADJ_MASK	GENMASK_32(28, 27)
+#define _DWC3_GUSB2PHYCFG_HSIC_CON_WIDTH_ADJ_SHIFT	27
+#define _DWC3_GUSB2PHYCFG_ULPI_LPM_WITH_OPMODE_CHK	BIT_32(29)
+#define _DWC3_GUSB2PHYCFG_U2_FREECLK_EXISTS		BIT_32(30)
+#define _DWC3_GUSB2PHYCFG_PHYSOFTRST			BIT_32(31)
+
+/* _DWC3_GUSB2PHYACC_ULPI register fields */
+#define _DWC3_GUSB2PHYACC_ULPI_REGDATA_MASK		GENMASK_32(7, 0)
+#define _DWC3_GUSB2PHYACC_ULPI_REGDATA_SHIFT		0
+#define _DWC3_GUSB2PHYACC_ULPI_EXTREGADDR_MASK		GENMASK_32(15, 8)
+#define _DWC3_GUSB2PHYACC_ULPI_EXTREGADDR_SHIFT		8
+#define _DWC3_GUSB2PHYACC_ULPI_REGADDR_MASK		GENMASK_32(21, 16)
+#define _DWC3_GUSB2PHYACC_ULPI_REGADDR_SHIFT		16
+#define _DWC3_GUSB2PHYACC_ULPI_REGWR			BIT_32(22)
+#define _DWC3_GUSB2PHYACC_ULPI_VSTSBSY			BIT_32(23)
+#define _DWC3_GUSB2PHYACC_ULPI_VSTSDONE			BIT_32(24)
+#define _DWC3_GUSB2PHYACC_ULPI_NEWREGREQ		BIT_32(25)
+#define _DWC3_GUSB2PHYACC_ULPI_DISUIPIDRVR		BIT_32(26)
+
+/* _DWC3_GUSB3PIPECTL register fields */
+#define _DWC3_GUSB3PIPECTL_ELASTIC_BUFFER_MODE		BIT_32(0)
+#define _DWC3_GUSB3PIPECTL_SS_TX_DE_EMPHASIS_MASK	GENMASK_32(2, 1)
+#define _DWC3_GUSB3PIPECTL_SS_TX_DE_EMPHASIS_SHIFT	1
+#define _DWC3_GUSB3PIPECTL_TX_MARGIN_MASK		GENMASK_32(5, 3)
+#define _DWC3_GUSB3PIPECTL_TX_MARGIN_SHIFT		3
+#define _DWC3_GUSB3PIPECTL_TX_SWING			BIT_32(6)
+#define _DWC3_GUSB3PIPECTL_SSICEN			BIT_32(7)
+#define _DWC3_GUSB3PIPECTL_RX_DETECT_TO_POLLING_LFPS_CONTROL	BIT_32(8)
+#define _DWC3_GUSB3PIPECTL_LFPSFILTER			BIT_32(9)
+#define _DWC3_GUSB3PIPECTL_P3EXSIGP2			BIT_32(10)
+#define _DWC3_GUSB3PIPECTL_P3P2TRANOK			BIT_32(11)
+#define _DWC3_GUSB3PIPECTL_LFPSP0ALGN			BIT_32(12)
+#define _DWC3_GUSB3PIPECTL_SKIPRXDET			BIT_32(13)
+#define _DWC3_GUSB3PIPECTL_ABORTRXDETINU2		BIT_32(14)
+#define _DWC3_GUSB3PIPECTL_DATWIDTH_MASK		GENMASK_32(16, 15)
+#define _DWC3_GUSB3PIPECTL_DATWIDTH_SHIFT		15
+#define _DWC3_GUSB3PIPECTL_SUSPENDENABLE		BIT_32(17)
+#define _DWC3_GUSB3PIPECTL_DELAYP1TRANS			BIT_32(18)
+#define _DWC3_GUSB3PIPECTL_DELAYP1P2P3_MASK		GENMASK_32(21, 19)
+#define _DWC3_GUSB3PIPECTL_DELAYP1P2P3_SHIFT		19
+#define _DWC3_GUSB3PIPECTL_DISRXDETU3RXDET		BIT_32(22)
+#define _DWC3_GUSB3PIPECTL_STARTRXDETU3RXDET		BIT_32(23)
+#define _DWC3_GUSB3PIPECTL_REQUEST_P1P2P3		BIT_32(24)
+#define _DWC3_GUSB3PIPECTL_U1U2EXITFAIL_TO_RECOV	BIT_32(25)
+#define _DWC3_GUSB3PIPECTL_PING_ENHANCEMENT_EN		BIT_32(26)
+#define _DWC3_GUSB3PIPECTL_UX_EXIT_IN_PX		BIT_32(27)
+#define _DWC3_GUSB3PIPECTL_DISRXDETP3			BIT_32(28)
+#define _DWC3_GUSB3PIPECTL_U2P3OK			BIT_32(29)
+#define _DWC3_GUSB3PIPECTL_HSTPRTCMPL			BIT_32(30)
+#define _DWC3_GUSB3PIPECTL_PHYSOFTRST			BIT_32(31)
+
+/* _DWC3_GTXFIFOSIZ0 register fields */
+#define _DWC3_GTXFIFOSIZ0_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ0_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ0_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ0_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ1 register fields */
+#define _DWC3_GTXFIFOSIZ1_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ1_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ1_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ1_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ2 register fields */
+#define _DWC3_GTXFIFOSIZ2_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ2_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ2_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ2_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ3 register fields */
+#define _DWC3_GTXFIFOSIZ3_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ3_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ3_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ3_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ4 register fields */
+#define _DWC3_GTXFIFOSIZ4_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ4_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ4_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ4_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ5 register fields */
+#define _DWC3_GTXFIFOSIZ5_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ5_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ5_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ5_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ6 register fields */
+#define _DWC3_GTXFIFOSIZ6_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ6_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ6_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ6_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ7 register fields */
+#define _DWC3_GTXFIFOSIZ7_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ7_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ7_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ7_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ8 register fields */
+#define _DWC3_GTXFIFOSIZ8_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ8_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ8_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ8_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ9 register fields */
+#define _DWC3_GTXFIFOSIZ9_TXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ9_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ9_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ9_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ10 register fields */
+#define _DWC3_GTXFIFOSIZ10_TXFDEP_N_MASK		GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ10_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ10_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ10_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GTXFIFOSIZ11 register fields */
+#define _DWC3_GTXFIFOSIZ11_TXFDEP_N_MASK		GENMASK_32(15, 0)
+#define _DWC3_GTXFIFOSIZ11_TXFDEP_N_SHIFT		0
+#define _DWC3_GTXFIFOSIZ11_TXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GTXFIFOSIZ11_TXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GRXFIFOSIZ0 register fields */
+#define _DWC3_GRXFIFOSIZ0_RXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GRXFIFOSIZ0_RXFDEP_N_SHIFT		0
+#define _DWC3_GRXFIFOSIZ0_RXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GRXFIFOSIZ0_RXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GRXFIFOSIZ1 register fields */
+#define _DWC3_GRXFIFOSIZ1_RXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GRXFIFOSIZ1_RXFDEP_N_SHIFT		0
+#define _DWC3_GRXFIFOSIZ1_RXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GRXFIFOSIZ1_RXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GRXFIFOSIZ2 register fields */
+#define _DWC3_GRXFIFOSIZ2_RXFDEP_N_MASK			GENMASK_32(15, 0)
+#define _DWC3_GRXFIFOSIZ2_RXFDEP_N_SHIFT		0
+#define _DWC3_GRXFIFOSIZ2_RXFSTADDR_N_MASK		GENMASK_32(31, 16)
+#define _DWC3_GRXFIFOSIZ2_RXFSTADDR_N_SHIFT		16
+
+/* _DWC3_GEVNTSIZ register fields */
+#define _DWC3_GEVNTSIZ_EVENTSIZ_MASK			GENMASK_32(15, 0)
+#define _DWC3_GEVNTSIZ_EVENTSIZ_SHIFT			0
+#define _DWC3_GEVNTSIZ_EVNTINTRPTMASK			BIT_32(31)
+
+/* _DWC3_GEVNTCOUNT register fields */
+#define _DWC3_GEVNTCOUNT_EVNTCOUNT_MASK			GENMASK_32(15, 0)
+#define _DWC3_GEVNTCOUNT_EVNTCOUNT_SHIFT		0
+#define _DWC3_GEVNTCOUNT_EVNT_HANDLER_BUSY		BIT_32(31)
+
+/*
+ * USB3 Device Register Block
+ */
+#define _DWC3_DCFG					U(0x0)
+#define _DWC3_DCTL					U(0x4)
+#define _DWC3_DEVTEN					U(0x8)
+#define _DWC3_DSTS					U(0xC)
+#define _DWC3_DGCMDPAR					U(0x10)
+#define _DWC3_DGCMD					U(0x14)
+#define _DWC3_DALEPENA					U(0x20)
+#define _DWC3_DEPCMDPAR2				U(0x100)
+#define _DWC3_DEPCMDPAR1				U(0x104)
+#define _DWC3_DEPCMDPAR0				U(0x108)
+#define _DWC3_DEPCMD					U(0x10c)
+#define _DWC3_DEV_IMOD					U(0x300)
+
+/* _DWC3_DCFG register fields */
+#define _DWC3_DCFG_DEVSPD_MASK				GENMASK_32(2, 0)
+#define _DWC3_DCFG_DEVSPD_SHIFT				0
+#define _DWC3_DCFG_DEVADDR_MASK				GENMASK_32(9, 3)
+#define _DWC3_DCFG_DEVADDR_SHIFT			3
+#define _DWC3_DCFG_INTRNUM_MASK				GENMASK_32(16, 12)
+#define _DWC3_DCFG_INTRNUM_SHIFT			12
+#define _DWC3_DCFG_NUMP_MASK				GENMASK_32(21, 17)
+#define _DWC3_DCFG_NUMP_SHIFT				17
+#define _DWC3_DCFG_LPMCAP				BIT_32(22)
+#define _DWC3_DCFG_IGNSTRMPP				BIT_32(23)
+
+/* _DWC3_DCTL register fields */
+#define _DWC3_DCTL_TSTCTL_MASK				GENMASK_32(4, 1)
+#define _DWC3_DCTL_TSTCTL_SHIFT				1
+#define _DWC3_DCTL_ULSTCHNGREQ_MASK			GENMASK_32(8, 5)
+#define _DWC3_DCTL_ULSTCHNGREQ_SHIFT			5
+#define _DWC3_DCTL_ACCEPTU1ENA				BIT_32(9)
+#define _DWC3_DCTL_INITU1ENA				BIT_32(10)
+#define _DWC3_DCTL_ACCEPTU2ENA				BIT_32(11)
+#define _DWC3_DCTL_INITU2ENA				BIT_32(12)
+#define _DWC3_DCTL_CSS					BIT_32(16)
+#define _DWC3_DCTL_CRS					BIT_32(17)
+#define _DWC3_DCTL_L1HIBERNATIONEN			BIT_32(18)
+#define _DWC3_DCTL_KEEPCONNECT				BIT_32(19)
+#define _DWC3_DCTL_LPM_NYET_THRES_MASK			GENMASK_32(23, 20)
+#define _DWC3_DCTL_LPM_NYET_THRES_SHIFT			20
+#define _DWC3_DCTL_HIRDTHRES_MASK			GENMASK_32(28, 24)
+#define _DWC3_DCTL_HIRDTHRES_SHIFT			24
+#define _DWC3_DCTL_CSFTRST				BIT_32(30)
+#define _DWC3_DCTL_RUN_STOP				BIT_32(31)
+
+/* _DWC3_DEVTEN register fields */
+#define _DWC3_DEVTEN_DISSCONNEVTEN			BIT_32(0)
+#define _DWC3_DEVTEN_USBRSTEVTEN			BIT_32(1)
+#define _DWC3_DEVTEN_CONNECTDONEEVTEN			BIT_32(2)
+#define _DWC3_DEVTEN_ULSTCNGEN				BIT_32(3)
+#define _DWC3_DEVTEN_WKUPEVTEN				BIT_32(4)
+#define _DWC3_DEVTEN_HIBERNATIONREQEVTEN		BIT_32(5)
+#define _DWC3_DEVTEN_U3L2L1SUSPEN			BIT_32(6)
+#define _DWC3_DEVTEN_SOFTEVTEN				BIT_32(7)
+#define _DWC3_DEVTEN_L1SUSPEN				BIT_32(8)
+#define _DWC3_DEVTEN_ERRTICERREVTEN			BIT_32(9)
+#define _DWC3_DEVTEN_CMDCMPLTEN				BIT_32(10)
+#define _DWC3_DEVTEN_EVNTOVERFLOWEN			BIT_32(11)
+#define _DWC3_DEVTEN_VENDEVTSTRCVDEN			BIT_32(12)
+#define _DWC3_DEVTEN_L1WKUPEVTEN			BIT_32(14)
+#define _DWC3_DEVTEN_ECCERREN				BIT_32(16)
+
+/* _DWC3_DSTS register fields */
+#define _DWC3_DSTS_CONNECTSPD_MASK			GENMASK_32(2, 0)
+#define _DWC3_DSTS_CONNECTSPD_SHIFT			0
+#define _DWC3_DSTS_SOFFN_MASK				GENMASK_32(16, 3)
+#define _DWC3_DSTS_SOFFN_SHIFT				3
+#define _DWC3_DSTS_RXFIFOEMPTY				BIT_32(17)
+#define _DWC3_DSTS_USBLNKST_MASK			GENMASK_32(21, 18)
+#define _DWC3_DSTS_USBLNKST_SHIFT			18
+#define _DWC3_DSTS_DEVCTRLHLT				BIT_32(22)
+#define _DWC3_DSTS_COREIDLE				BIT_32(23)
+#define _DWC3_DSTS_SSS					BIT_32(24)
+#define _DWC3_DSTS_RSS					BIT_32(25)
+#define _DWC3_DSTS_SRE					BIT_32(28)
+#define _DWC3_DSTS_DCNRD				BIT_32(29)
+
+/* _DWC3_DGCMD register fields */
+#define _DWC3_DGCMD_CMDTYP_MASK				GENMASK_32(7, 0)
+#define _DWC3_DGCMD_CMDTYP_SHIFT			0
+#define _DWC3_DGCMD_CMDIOC				BIT_32(8)
+#define _DWC3_DGCMD_CMDACT				BIT_32(10)
+#define _DWC3_DGCMD_CMDSTATUS_MASK			GENMASK_32(15, 12)
+#define _DWC3_DGCMD_CMDSTATUS_SHIFT			12
+
+/* _DWC3_DEPCMD register fields */
+#define _DWC3_DEPCMD_CMDTYP_MASK			GENMASK_32(3, 0)
+#define _DWC3_DEPCMD_CMDTYP_SHIFT			0
+#define _DWC3_DEPCMD_CMDIOC				BIT_32(8)
+#define _DWC3_DEPCMD_CMDACT				BIT_32(10)
+#define _DWC3_DEPCMD_HIPRI_FORCERM			BIT_32(11)
+#define _DWC3_DEPCMD_CMDSTATUS_MASK			GENMASK_32(15, 12)
+#define _DWC3_DEPCMD_CMDSTATUS_SHIFT			12
+#define _DWC3_DEPCMD_COMMANDPARAM_MASK			GENMASK_32(31, 16)
+#define _DWC3_DEPCMD_COMMANDPARAM_SHIFT			16
+
+/* _DWC3_DEV_IMOD register fields */
+#define _DWC3_DEV_IMOD_DEVICE_IMODI_MASK		GENMASK_32(15, 0)
+#define _DWC3_DEV_IMOD_DEVICE_IMODI_SHIFT		0
+#define _DWC3_DEV_IMOD_DEVICE_IMODC_MASK		GENMASK_32(31, 16)
+#define _DWC3_DEV_IMOD_DEVICE_IMODC_SHIFT		16
+
+/*
+ * USB3 BC Register Block
+ */
+#define _DWC3_BCFG					U(0x0)
+#define _DWC3_BCEVT					U(0x8)
+#define _DWC3_BCEVTEN					U(0xC)
+
+/* _DWC3_BCFG register fields */
+#define _DWC3_BCFG_CHIRP_EN				BIT_32(0)
+#define _DWC3_BCFG_IDDIG_SEL				BIT_32(1)
+
+/* _DWC3_BCEVT register fields */
+#define _DWC3_BCEVT_MULTVALIDBC_MASK			GENMASK_32(4, 0)
+#define _DWC3_BCEVT_MULTVALIDBC_SHIFT			0
+#define _DWC3_BCEVT_MV_CHNGEVNT				BIT_32(24)
+
+/* _DWC3_BCEVTEN register fields */
+#define _DWC3_BCEVTEN_MV_CHNGEVNTENA			BIT_32(24)
+
+/*
+ * USB3 eXtensible Host Controller Capability Register Block
+ */
+#define _DWC3_CAPLENGTH					U(0x0)
+#define _DWC3_HCSPARAMS1				U(0x4)
+#define _DWC3_HCSPARAMS2				U(0x8)
+#define _DWC3_HCSPARAMS3				U(0xC)
+#define _DWC3_HCCPARAMS1				U(0x10)
+#define _DWC3_DBOFF					U(0x14)
+#define _DWC3_RTSOFF					U(0x18)
+#define _DWC3_HCCPARAMS2				U(0x1C)
+
+/* _DWC3_CAPLENGTH register fields */
+#define _DWC3_CAPLENGTH_CAPLENGTH_MASK			GENMASK_32(7, 0)
+#define _DWC3_CAPLENGTH_CAPLENGTH_SHIFT			0
+#define _DWC3_CAPLENGTH_HCIVERSION_MASK			GENMASK_32(31, 16)
+#define _DWC3_CAPLENGTH_HCIVERSION_SHIFT		16
+
+/* _DWC3_HCSPARAMS1 register fields */
+#define _DWC3_HCSPARAMS1_MAXSLOTS_MASK			GENMASK_32(7, 0)
+#define _DWC3_HCSPARAMS1_MAXSLOTS_SHIFT			0
+#define _DWC3_HCSPARAMS1_MAXINTRS_MASK			GENMASK_32(18, 8)
+#define _DWC3_HCSPARAMS1_MAXINTRS_SHIFT			8
+#define _DWC3_HCSPARAMS1_MAXPORTS_MASK			GENMASK_32(31, 24)
+#define _DWC3_HCSPARAMS1_MAXPORTS_SHIFT			24
+
+/* _DWC3_HCSPARAMS2 register fields */
+#define _DWC3_HCSPARAMS2_IST_MASK			GENMASK_32(3, 0)
+#define _DWC3_HCSPARAMS2_IST_SHIFT			0
+#define _DWC3_HCSPARAMS2_ERSTMAX_MASK			GENMASK_32(7, 4)
+#define _DWC3_HCSPARAMS2_ERSTMAX_SHIFT			4
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_HI_MASK	GENMASK_32(25, 21)
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_HI_SHIFT	21
+#define _DWC3_HCSPARAMS2_SPR				BIT_32(26)
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_MASK		GENMASK_32(31, 27)
+#define _DWC3_HCSPARAMS2_MAXSCRATCHPADBUFS_SHIFT	27
+
+/* _DWC3_HCSPARAMS3 register fields */
+#define _DWC3_HCSPARAMS3_U1_DEVICE_EXIT_LAT_MASK	GENMASK_32(7, 0)
+#define _DWC3_HCSPARAMS3_U1_DEVICE_EXIT_LAT_SHIFT	0
+#define _DWC3_HCSPARAMS3_U2_DEVICE_EXIT_LAT_MASK	GENMASK_32(31, 16)
+#define _DWC3_HCSPARAMS3_U2_DEVICE_EXIT_LAT_SHIFT	16
+
+/* _DWC3_HCCPARAMS1 register fields */
+#define _DWC3_HCCPARAMS1_AC64				BIT_32(0)
+#define _DWC3_HCCPARAMS1_BNC				BIT_32(1)
+#define _DWC3_HCCPARAMS1_CSZ				BIT_32(2)
+#define _DWC3_HCCPARAMS1_PPC				BIT_32(3)
+#define _DWC3_HCCPARAMS1_PIND				BIT_32(4)
+#define _DWC3_HCCPARAMS1_LHRC				BIT_32(5)
+#define _DWC3_HCCPARAMS1_LTC				BIT_32(6)
+#define _DWC3_HCCPARAMS1_NSS				BIT_32(7)
+#define _DWC3_HCCPARAMS1_PAE				BIT_32(8)
+#define _DWC3_HCCPARAMS1_SPC				BIT_32(9)
+#define _DWC3_HCCPARAMS1_SEC				BIT_32(10)
+#define _DWC3_HCCPARAMS1_CFC				BIT_32(11)
+#define _DWC3_HCCPARAMS1_MAXPSASIZE_MASK		GENMASK_32(15, 12)
+#define _DWC3_HCCPARAMS1_MAXPSASIZE_SHIFT		12
+#define _DWC3_HCCPARAMS1_XECP_MASK			GENMASK_32(31, 16)
+#define _DWC3_HCCPARAMS1_XECP_SHIFT			16
+
+/* _DWC3_DBOFF register fields */
+#define _DWC3_DBOFF_DOORBELL_ARRAY_OFFSET_MASK		GENMASK_32(31, 2)
+#define _DWC3_DBOFF_DOORBELL_ARRAY_OFFSET_SHIFT		2
+
+/* _DWC3_RTSOFF register fields */
+#define _DWC3_RTSOFF_RUNTIME_REG_SPACE_OFFSET_MASK	GENMASK_32(31, 5)
+#define _DWC3_RTSOFF_RUNTIME_REG_SPACE_OFFSET_SHIFT	5
+
+/* _DWC3_HCCPARAMS2 register fields */
+#define _DWC3_HCCPARAMS2_U3C				BIT_32(0)
+#define _DWC3_HCCPARAMS2_CMC				BIT_32(1)
+#define _DWC3_HCCPARAMS2_FSC				BIT_32(2)
+#define _DWC3_HCCPARAMS2_CTC				BIT_32(3)
+#define _DWC3_HCCPARAMS2_LEC				BIT_32(4)
+#define _DWC3_HCCPARAMS2_CIC				BIT_32(5)
+
+/*
+ * USB3 Host Cntrl Oper Regs Block
+ */
+#define _DWC3_USBCMD					U(0x0)
+#define _DWC3_USBSTS					U(0x4)
+#define _DWC3_PAGESIZE					U(0x8)
+#define _DWC3_DNCTRL					U(0x14)
+#define _DWC3_CRCR_LO					U(0x18)
+#define _DWC3_CRCR_HI					U(0x1C)
+#define _DWC3_DCBAAP_LO					U(0x30)
+#define _DWC3_DCBAAP_HI					U(0x34)
+#define _DWC3_CONFIG					U(0x38)
+
+/* _DWC3_USBCMD register fields */
+#define _DWC3_USBCMD_R_S				BIT_32(0)
+#define _DWC3_USBCMD_HCRST				BIT_32(1)
+#define _DWC3_USBCMD_INTE				BIT_32(2)
+#define _DWC3_USBCMD_HSEE				BIT_32(3)
+#define _DWC3_USBCMD_LHCRST				BIT_32(7)
+#define _DWC3_USBCMD_CSS				BIT_32(8)
+#define _DWC3_USBCMD_CRS				BIT_32(9)
+#define _DWC3_USBCMD_EWE				BIT_32(10)
+#define _DWC3_USBCMD_EU3S				BIT_32(11)
+#define _DWC3_USBCMD_CME				BIT_32(13)
+
+/* _DWC3_USBSTS register fields */
+#define _DWC3_USBSTS_HCH				BIT_32(0)
+#define _DWC3_USBSTS_HSE				BIT_32(2)
+#define _DWC3_USBSTS_EINT				BIT_32(3)
+#define _DWC3_USBSTS_PCD				BIT_32(4)
+#define _DWC3_USBSTS_SSS				BIT_32(8)
+#define _DWC3_USBSTS_RSS				BIT_32(9)
+#define _DWC3_USBSTS_SRE				BIT_32(10)
+#define _DWC3_USBSTS_CNR				BIT_32(11)
+#define _DWC3_USBSTS_HCE				BIT_32(12)
+
+/* _DWC3_PAGESIZE register fields */
+#define _DWC3_PAGESIZE_PAGE_SIZE_MASK			GENMASK_32(15, 0)
+#define _DWC3_PAGESIZE_PAGE_SIZE_SHIFT			0
+
+/* _DWC3_DNCTRL register fields */
+#define _DWC3_DNCTRL_N0_N15_MASK			GENMASK_32(15, 0)
+#define _DWC3_DNCTRL_N0_N15_SHIFT			0
+
+/* _DWC3_CRCR_LO register fields */
+#define _DWC3_CRCR_LO_RCS				BIT_32(0)
+#define _DWC3_CRCR_LO_CS				BIT_32(1)
+#define _DWC3_CRCR_LO_CA				BIT_32(2)
+#define _DWC3_CRCR_LO_CRR				BIT_32(3)
+#define _DWC3_CRCR_LO_CMD_RING_PNTR_MASK		GENMASK_32(31, 6)
+#define _DWC3_CRCR_LO_CMD_RING_PNTR_SHIFT		6
+
+/* _DWC3_DCBAAP_LO register fields */
+#define _DWC3_DCBAAP_LO_DEVICE_CONTEXT_BAAP_MASK	GENMASK_32(31, 6)
+#define _DWC3_DCBAAP_LO_DEVICE_CONTEXT_BAAP_SHIFT	6
+
+/* _DWC3_CONFIG register fields */
+#define _DWC3_CONFIG_MAXSLOTSEN_MASK			GENMASK_32(7, 0)
+#define _DWC3_CONFIG_MAXSLOTSEN_SHIFT			0
+#define _DWC3_CONFIG_U3E				BIT_32(8)
+#define _DWC3_CONFIG_CIE				BIT_32(9)
+
+/*
+ * USB3 Host Cntrl Port Reg Set Block
+ */
+#define _DWC3_PORTSC_20					U(0x0)
+#define _DWC3_PORTPMSC_20				U(0x4)
+#define _DWC3_PORTLI_20					U(0x8)
+#define _DWC3_PORTHLPMC_20				U(0xc)
+#define _DWC3_PORTSC_30					U(0x10)
+#define _DWC3_PORTPMSC_30				U(0x14)
+#define _DWC3_PORTLI_30					U(0x18)
+#define _DWC3_PORTHLPMC_30				U(0x1c)
+
+/* _DWC3_PORTSC_20 register fields */
+#define _DWC3_PORTSC_20_CCS				BIT_32(0)
+#define _DWC3_PORTSC_20_PED				BIT_32(1)
+#define _DWC3_PORTSC_20_OCA				BIT_32(3)
+#define _DWC3_PORTSC_20_PR				BIT_32(4)
+#define _DWC3_PORTSC_20_PLS_MASK			GENMASK_32(8, 5)
+#define _DWC3_PORTSC_20_PLS_SHIFT			5
+#define _DWC3_PORTSC_20_PP				BIT_32(9)
+#define _DWC3_PORTSC_20_PORTSPEED_MASK			GENMASK_32(13, 10)
+#define _DWC3_PORTSC_20_PORTSPEED_SHIFT			10
+#define _DWC3_PORTSC_20_PIC_MASK			GENMASK_32(15, 14)
+#define _DWC3_PORTSC_20_PIC_SHIFT			14
+#define _DWC3_PORTSC_20_LWS				BIT_32(16)
+#define _DWC3_PORTSC_20_CSC				BIT_32(17)
+#define _DWC3_PORTSC_20_PEC				BIT_32(18)
+#define _DWC3_PORTSC_20_OCC				BIT_32(20)
+#define _DWC3_PORTSC_20_PRC				BIT_32(21)
+#define _DWC3_PORTSC_20_PLC				BIT_32(22)
+#define _DWC3_PORTSC_20_CAS				BIT_32(24)
+#define _DWC3_PORTSC_20_WCE				BIT_32(25)
+#define _DWC3_PORTSC_20_WDE				BIT_32(26)
+#define _DWC3_PORTSC_20_WOE				BIT_32(27)
+#define _DWC3_PORTSC_20_DR				BIT_32(30)
+
+/* _DWC3_PORTPMSC_20 register fields */
+#define _DWC3_PORTPMSC_20_L1S_MASK			GENMASK_32(2, 0)
+#define _DWC3_PORTPMSC_20_L1S_SHIFT			0
+#define _DWC3_PORTPMSC_20_RWE				BIT_32(3)
+#define _DWC3_PORTPMSC_20_HIRD_MASK			GENMASK_32(7, 4)
+#define _DWC3_PORTPMSC_20_HIRD_SHIFT			4
+#define _DWC3_PORTPMSC_20_L1DSLOT_MASK			GENMASK_32(15, 8)
+#define _DWC3_PORTPMSC_20_L1DSLOT_SHIFT			8
+#define _DWC3_PORTPMSC_20_HLE				BIT_32(16)
+#define _DWC3_PORTPMSC_20_PRTTSTCTRL_MASK		GENMASK_32(31, 28)
+#define _DWC3_PORTPMSC_20_PRTTSTCTRL_SHIFT		28
+
+/* _DWC3_PORTHLPMC_20 register fields */
+#define _DWC3_PORTHLPMC_20_HIRDM_MASK			GENMASK_32(1, 0)
+#define _DWC3_PORTHLPMC_20_HIRDM_SHIFT			0
+#define _DWC3_PORTHLPMC_20_L1_TIMEOUT_MASK		GENMASK_32(9, 2)
+#define _DWC3_PORTHLPMC_20_L1_TIMEOUT_SHIFT		2
+#define _DWC3_PORTHLPMC_20_HIRDD_MASK			GENMASK_32(13, 10)
+#define _DWC3_PORTHLPMC_20_HIRDD_SHIFT			10
+
+/* _DWC3_PORTSC_30 register fields */
+#define _DWC3_PORTSC_30_CCS				BIT_32(0)
+#define _DWC3_PORTSC_30_PED				BIT_32(1)
+#define _DWC3_PORTSC_30_OCA				BIT_32(3)
+#define _DWC3_PORTSC_30_PR				BIT_32(4)
+#define _DWC3_PORTSC_30_PLS_MASK			GENMASK_32(8, 5)
+#define _DWC3_PORTSC_30_PLS_SHIFT			5
+#define _DWC3_PORTSC_30_PP				BIT_32(9)
+#define _DWC3_PORTSC_30_PORTSPEED_MASK			GENMASK_32(13, 10)
+#define _DWC3_PORTSC_30_PORTSPEED_SHIFT			10
+#define _DWC3_PORTSC_30_PIC_MASK			GENMASK_32(15, 14)
+#define _DWC3_PORTSC_30_PIC_SHIFT			14
+#define _DWC3_PORTSC_30_LWS				BIT_32(16)
+#define _DWC3_PORTSC_30_CSC				BIT_32(17)
+#define _DWC3_PORTSC_30_PEC				BIT_32(18)
+#define _DWC3_PORTSC_30_WRC				BIT_32(19)
+#define _DWC3_PORTSC_30_OCC				BIT_32(20)
+#define _DWC3_PORTSC_30_PRC				BIT_32(21)
+#define _DWC3_PORTSC_30_PLC				BIT_32(22)
+#define _DWC3_PORTSC_30_CEC				BIT_32(23)
+#define _DWC3_PORTSC_30_CAS				BIT_32(24)
+#define _DWC3_PORTSC_30_WCE				BIT_32(25)
+#define _DWC3_PORTSC_30_WDE				BIT_32(26)
+#define _DWC3_PORTSC_30_WOE				BIT_32(27)
+#define _DWC3_PORTSC_30_DR				BIT_32(30)
+#define _DWC3_PORTSC_30_WPR				BIT_32(31)
+
+/* _DWC3_PORTPMSC_30 register fields */
+#define _DWC3_PORTPMSC_30_U1_TIMEOUT_MASK		GENMASK_32(7, 0)
+#define _DWC3_PORTPMSC_30_U1_TIMEOUT_SHIFT		0
+#define _DWC3_PORTPMSC_30_U2_TIMEOUT_MASK		GENMASK_32(15, 8)
+#define _DWC3_PORTPMSC_30_U2_TIMEOUT_SHIFT		8
+#define _DWC3_PORTPMSC_30_FLA				BIT_32(16)
+
+/* _DWC3_PORTLI_30 register fields */
+#define _DWC3_PORTLI_30_LINK_ERROR_COUNT_MASK		GENMASK_32(15, 0)
+#define _DWC3_PORTLI_30_LINK_ERROR_COUNT_SHIFT		0
+
+/*
+ * USB3 Host Cntrl Runtime Regs Block
+ */
+#define _DWC3_MFINDEX					U(0x0)
+
+/* _DWC3_MFINDEX register fields */
+#define _DWC3_MFINDEX_MICROFRAME_INDEX_MASK		GENMASK_32(13, 0)
+#define _DWC3_MFINDEX_MICROFRAME_INDEX_SHIFT		0
+
+/*
+ * USB3 Interrupter Regs Block
+ */
+#define _DWC3_IMAN					U(0x0)
+#define _DWC3_IMOD					U(0x4)
+#define _DWC3_ERSTSZ					U(0x8)
+#define _DWC3_ERSTBA_LO					U(0x10)
+#define _DWC3_ERSTBA_HI					U(0x14)
+#define _DWC3_ERDP_LO					U(0x18)
+#define _DWC3_ERDP_HI					U(0x1c)
+
+/* _DWC3_IMAN register fields */
+#define _DWC3_IMAN_IP					BIT_32(0)
+#define _DWC3_IMAN_IE					BIT_32(1)
+
+/* _DWC3_IMOD register fields */
+#define _DWC3_IMOD_IMODI_MASK				GENMASK_32(15, 0)
+#define _DWC3_IMOD_IMODI_SHIFT				0
+#define _DWC3_IMOD_IMODC_MASK				GENMASK_32(31, 16)
+#define _DWC3_IMOD_IMODC_SHIFT				16
+
+/* _DWC3_ERSTSZ register fields */
+#define _DWC3_ERSTSZ_ERS_TABLE_SIZE_MASK		GENMASK_32(15, 0)
+#define _DWC3_ERSTSZ_ERS_TABLE_SIZE_SHIFT		0
+
+/* _DWC3_ERSTBA_LO register fields */
+#define _DWC3_ERSTBA_LO_ERS_TABLE_BAR_MASK		GENMASK_32(31, 6)
+#define _DWC3_ERSTBA_LO_ERS_TABLE_BAR_SHIFT		6
+
+/* _DWC3_ERDP_LO register fields */
+#define _DWC3_ERDP_LO_DESI_MASK				GENMASK_32(2, 0)
+#define _DWC3_ERDP_LO_DESI_SHIFT			0
+#define _DWC3_ERDP_LO_EHB				BIT_32(3)
+#define _DWC3_ERDP_LO_ERD_PNTR_MASK			GENMASK_32(31, 4)
+#define _DWC3_ERDP_LO_ERD_PNTR_SHIFT			4
+
+/*
+ * USB3 Doorbell Reg Block
+ */
+#define _DWC3_DB					U(0x0)
+
+/* _DWC3_DB register fields */
+#define _DWC3_DB_DB_TARGET_MASK				GENMASK_32(7, 0)
+#define _DWC3_DB_DB_TARGET_SHIFT			0
+#define _DWC3_DB_DB_STREAM_ID_MASK			GENMASK_32(31, 16)
+#define _DWC3_DB_DB_STREAM_ID_SHIFT			16
+
+/*
+ * USB3 internal RAM0 Register Block
+
+ * For a description of this standard USB register field, see the eXtensible Host Controller
+ * Interface for Universal Serial Bus (USB) Specification 3.0.
+
+ */
+
+/*
+ * USB3 internal RAM1 Register Block
+
+ * For a description of this standard USB register field, see the eXtensible Host Controller
+ * Interface for Universal Serial Bus (USB) Specification 3.0.
+
+ */
+
+/*
+ * USB3 internal RAM2 Register Block
+ */
+
+/*
+ * USB3 HC Extended Capability Register Block
+ */
+#define _DWC3_USBLEGSUP					U(0x0)
+#define _DWC3_USBLEGCTLSTS				U(0x4)
+
+/* _DWC3_USBLEGSUP register fields */
+#define _DWC3_USBLEGSUP_CAPABILITY_ID_MASK		GENMASK_32(7, 0)
+#define _DWC3_USBLEGSUP_CAPABILITY_ID_SHIFT		0
+#define _DWC3_USBLEGSUP_NEXT_CAPABILITY_POINTER_MASK	GENMASK_32(15, 8)
+#define _DWC3_USBLEGSUP_NEXT_CAPABILITY_POINTER_SHIFT	8
+#define _DWC3_USBLEGSUP_HC_BIOS_OWNED			BIT_32(16)
+#define _DWC3_USBLEGSUP_HC_OS_OWNED			BIT_32(24)
+
+/* _DWC3_USBLEGCTLSTS register fields */
+#define _DWC3_USBLEGCTLSTS_USB_SMI_ENABLE		BIT_32(0)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_HOST_E		BIT_32(4)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_OS_E			BIT_32(13)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_PCI_E			BIT_32(14)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_BAR_E			BIT_32(15)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_EVENT			BIT_32(16)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_HOST			BIT_32(20)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_OS			BIT_32(29)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_PCI			BIT_32(30)
+#define _DWC3_USBLEGCTLSTS_SMI_ON_BAR			BIT_32(31)
+
+/*
+ * USB3 xHCI Supported Protocol Capability (USB 2.0) Block
+ */
+#define _DWC3_SUPTPRT2_DW0				U(0x0)
+#define _DWC3_SUPTPRT2_DW1				U(0x4)
+#define _DWC3_SUPTPRT2_DW2				U(0x8)
+#define _DWC3_SUPTPRT2_DW3				U(0xC)
+
+/* _DWC3_SUPTPRT2_DW0 register fields */
+#define _DWC3_SUPTPRT2_DW0_CAPABILITY_ID_MASK		GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT2_DW0_CAPABILITY_ID_SHIFT		0
+#define _DWC3_SUPTPRT2_DW0_NEXT_CAPABILITY_POINTER_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT2_DW0_NEXT_CAPABILITY_POINTER_SHIFT	8
+#define _DWC3_SUPTPRT2_DW0_MINOR_REVISION_MASK		GENMASK_32(23, 16)
+#define _DWC3_SUPTPRT2_DW0_MINOR_REVISION_SHIFT		16
+#define _DWC3_SUPTPRT2_DW0_MAJOR_REVISION_MASK		GENMASK_32(31, 24)
+#define _DWC3_SUPTPRT2_DW0_MAJOR_REVISION_SHIFT		24
+
+/* _DWC3_SUPTPRT2_DW2 register fields */
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_OFFSET_MASK	GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_OFFSET_SHIFT	0
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_COUNT_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT2_DW2_COMPATIBLE_PORT_COUNT_SHIFT	8
+#define _DWC3_SUPTPRT2_DW2_HSO				BIT_32(17)
+#define _DWC3_SUPTPRT2_DW2_IHI				BIT_32(18)
+#define _DWC3_SUPTPRT2_DW2_HLC				BIT_32(19)
+#define _DWC3_SUPTPRT2_DW2_BLC				BIT_32(20)
+#define _DWC3_SUPTPRT2_DW2_MHD_MASK			GENMASK_32(27, 25)
+#define _DWC3_SUPTPRT2_DW2_MHD_SHIFT			25
+#define _DWC3_SUPTPRT2_DW2_PSIC_MASK			GENMASK_32(31, 28)
+#define _DWC3_SUPTPRT2_DW2_PSIC_SHIFT			28
+
+/* _DWC3_SUPTPRT2_DW3 register fields */
+#define _DWC3_SUPTPRT2_DW3_PROTCL_SLT_TY_MASK		GENMASK_32(4, 0)
+#define _DWC3_SUPTPRT2_DW3_PROTCL_SLT_TY_SHIFT		0
+
+/*
+ * USB3 xHCI Supported Protocol Capability (USB 3.0) Block
+ */
+#define _DWC3_SUPTPRT3_DW0				U(0x0)
+#define _DWC3_SUPTPRT3_DW1				U(0x4)
+#define _DWC3_SUPTPRT3_DW2				U(0x8)
+#define _DWC3_SUPTPRT3_DW3				U(0xC)
+
+/* _DWC3_SUPTPRT3_DW0 register fields */
+#define _DWC3_SUPTPRT3_DW0_CAPABILITY_ID_MASK		GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT3_DW0_CAPABILITY_ID_SHIFT		0
+#define _DWC3_SUPTPRT3_DW0_NEXT_CAPABILITY_POINTER_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT3_DW0_NEXT_CAPABILITY_POINTER_SHIFT	8
+#define _DWC3_SUPTPRT3_DW0_MINOR_REVISION_MASK		GENMASK_32(23, 16)
+#define _DWC3_SUPTPRT3_DW0_MINOR_REVISION_SHIFT		16
+#define _DWC3_SUPTPRT3_DW0_MAJOR_REVISION_MASK		GENMASK_32(31, 24)
+#define _DWC3_SUPTPRT3_DW0_MAJOR_REVISION_SHIFT		24
+
+/* _DWC3_SUPTPRT3_DW2 register fields */
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_OFFSET_MASK	GENMASK_32(7, 0)
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_OFFSET_SHIFT	0
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_COUNT_MASK	GENMASK_32(15, 8)
+#define _DWC3_SUPTPRT3_DW2_COMPATIBLE_PORT_COUNT_SHIFT	8
+#define _DWC3_SUPTPRT3_DW2_MHD_MASK			GENMASK_32(27, 25)
+#define _DWC3_SUPTPRT3_DW2_MHD_SHIFT			25
+#define _DWC3_SUPTPRT3_DW2_PSIC_MASK			GENMASK_32(31, 28)
+#define _DWC3_SUPTPRT3_DW2_PSIC_SHIFT			28
+
+/* _DWC3_SUPTPRT3_DW3 register fields */
+#define _DWC3_SUPTPRT3_DW3_PROTCL_SLT_TY_MASK		GENMASK_32(4, 0)
+#define _DWC3_SUPTPRT3_DW3_PROTCL_SLT_TY_SHIFT		0
+
+#endif /* __USB_DWC3_REGS_H */
diff --git a/drivers/usb/usb_device.c b/drivers/usb/usb_device.c
index 701f301208..bf6d4e1164 100644
--- a/drivers/usb/usb_device.c
+++ b/drivers/usb/usb_device.c
@@ -10,17 +10,6 @@
 #include <common/debug.h>
 #include <drivers/usb_device.h>
 
-/* Define for EP address */
-#define EP_DIR_MASK		BIT(7)
-#define EP_DIR_IN		BIT(7)
-#define EP_NUM_MASK		GENMASK(3, 0)
-
-#define EP0_IN			(0U | EP_DIR_IN)
-#define EP0_OUT			0U
-
-/* USB address between 1 through 127 = 0x7F mask */
-#define ADDRESS_MASK		GENMASK(6, 0)
-
 /*
  * Set a STALL condition over an endpoint
  * pdev: USB handle
@@ -47,7 +36,7 @@ static enum usb_status usb_core_set_stall(struct usb_handle *pdev, uint8_t ep_ad
 	ep->num = num;
 
 	pdev->driver->ep_set_stall(hpcd->instance, ep);
-	if (num == 0U) {
+	if (ep_addr == EP0_OUT) {
 		pdev->driver->ep0_out_start(hpcd->instance);
 	}
 
@@ -711,7 +700,11 @@ enum usb_status usb_core_receive_ep0(struct usb_handle *pdev, uint8_t *buf,
 	}
 
 	pdev->ep_out[0].total_length = len;
+#ifdef USB_CORE_AVOID_PACKET_SPLIT_MPS
+	pdev->ep_out[0].rem_length = 0;
+#else
 	pdev->ep_out[0].rem_length = len;
+#endif
 
 	/* Start the transfer */
 	return usb_core_receive(pdev, 0U, buf, len);
@@ -736,7 +729,11 @@ enum usb_status usb_core_transmit_ep0(struct usb_handle *pdev, uint8_t *buf,
 	}
 
 	pdev->ep_in[0].total_length = len;
+#ifdef USB_CORE_AVOID_PACKET_SPLIT_MPS
+	pdev->ep_in[0].rem_length = 0;
+#else
 	pdev->ep_in[0].rem_length = len;
+#endif
 
 	/* Start the transfer */
 	return usb_core_transmit(pdev, 0U, buf, len);
diff --git a/fdts/stm32mp13-bl2.dtsi b/fdts/stm32mp13-bl2.dtsi
index 836e9ae4c4..8f2d4b156c 100644
--- a/fdts/stm32mp13-bl2.dtsi
+++ b/fdts/stm32mp13-bl2.dtsi
@@ -3,6 +3,15 @@
  * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
  */
 
+/omit-if-no-ref/ &i2c4_pins_a;
+/omit-if-no-ref/ &sdmmc1_b4_pins_a;
+/omit-if-no-ref/ &sdmmc1_clk_pins_a;
+/omit-if-no-ref/ &sdmmc2_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_clk_pins_a;
+/omit-if-no-ref/ &uart4_pins_a;
+/omit-if-no-ref/ &uart8_pins_a;
+/omit-if-no-ref/ &usart1_pins_a;
+
 / {
 	aliases {
 #if !STM32MP_EMMC && !STM32MP_SDMMC
@@ -32,13 +41,6 @@
 #if !STM32MP_USB_PROGRAMMER
 		/delete-node/ usbphyc@5a006000;
 #endif
-
-		pinctrl@50002000 {
-#if !STM32MP_EMMC && !STM32MP_SDMMC
-			/delete-node/ sdmmc1-b4-0;
-			/delete-node/ sdmmc2-b4-0;
-#endif
-		};
 	};
 
 	/*
diff --git a/fdts/stm32mp13-fw-config-mem-encrypt.dtsi b/fdts/stm32mp13-fw-config-mem-encrypt.dtsi
new file mode 100644
index 0000000000..89e2d2431f
--- /dev/null
+++ b/fdts/stm32mp13-fw-config-mem-encrypt.dtsi
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <dt-bindings/soc/stm32mp13-mce.h>
+
+/ {
+	st-mem-encrypt {
+		compatible = "st,mem-encrypt";
+		memory-ranges = <DDR_SEC_BASE DDR_SEC_SIZE MCE_ENCRYPT>;
+	};
+};
diff --git a/fdts/stm32mp13-ssp-bl2.dtsi b/fdts/stm32mp13-ssp-bl2.dtsi
new file mode 100644
index 0000000000..bb86c49721
--- /dev/null
+++ b/fdts/stm32mp13-ssp-bl2.dtsi
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+/ {
+	aliases {
+		/delete-property/ mmc0;
+	};
+
+	sysram: sram@2ffe0000 {
+		compatible = "mmio-sram";
+		reg = <0x2ffe0000 0x20000>;
+		vddcore-supply = <&vddcore>;
+	};
+
+	soc {
+		efuse@5c005000 {
+			cfg0_otp: cfg0_otp@0 {
+				reg = <0x0 0x2>;
+			};
+			cfg2_otp: cfg2_otp@8 {
+				reg = <0x8 0x4>;
+			};
+			ssp_otp: cfg9_otp@24 {
+				reg = <0x24 0x4>;
+			};
+			chip_otp: chip_otp@a0 {
+				reg = <0xa0 0x40>;
+			};
+			rma_otp: rma_otp@e0 {
+				reg = <0xe0 0x4>;
+			};
+			pkh_otp: pkh_otp@60 {
+				reg = <0x60 0x20>;
+			};
+		};
+
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usb-otg@49000000;
+#endif
+		/delete-node/ spi@58003000;
+		/delete-node/ mmc@58005000;
+		/delete-node/ mmc@58007000;
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usbh-ohci@5800c000;
+		/delete-node/ usbh-ehci@5800d000;
+#endif
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usbphyc@5a006000;
+#endif
+	};
+};
diff --git a/fdts/stm32mp131.dtsi b/fdts/stm32mp131.dtsi
index 543afa5c4e..c37fed9911 100644
--- a/fdts/stm32mp131.dtsi
+++ b/fdts/stm32mp131.dtsi
@@ -416,7 +416,7 @@
 		};
 
 		bsec: efuse@5c005000 {
-			compatible = "st,stm32mp15-bsec";
+			compatible = "st,stm32mp13-bsec";
 			reg = <0x5c005000 0x400>;
 			#address-cells = <1>;
 			#size-cells = <1>;
@@ -455,10 +455,41 @@
 				reg = <0xe4 0xc>;
 				st,non-secure-otp;
 			};
-			enckey_otp: enckey_otp@170 {
+			oem_enc_key: oem_enc_key@170 {
 				reg = <0x170 0x10>;
 			};
 		};
+
+		tamp: tamp@5c00a000 {
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x5c00a000 0x400>;
+			ranges;
+
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x5c00a100 0x80>;
+
+				fwu_info: tamp-bkp@28 {
+					/* see firmware update info feature */
+					reg = <0x28 0x4>;
+				};
+				boot_mode: tamp-bkp@78 {
+					/* see boot mode selection feature */
+					reg = <0x78 0x4>;
+				};
+			};
+
+			boot_info: boot-info {
+				compatible = "st,stm32mp-bootinfo";
+				nvmem-cells = <&boot_mode>, <&fwu_info>;
+				nvmem-cell-names = "boot-mode", "fwu-info";
+			};
+		};
+
 		/*
 		 * Break node order to solve dependency probe issue between
 		 * pinctrl and exti.
diff --git a/fdts/stm32mp135f-dk-fw-config.dts b/fdts/stm32mp135f-dk-fw-config.dts
index 21f82422b3..41ebf73c21 100644
--- a/fdts/stm32mp135f-dk-fw-config.dts
+++ b/fdts/stm32mp135f-dk-fw-config.dts
@@ -5,3 +5,4 @@
 
 #define DDR_SIZE	0x20000000 /* 512MB */
 #include "stm32mp13-fw-config.dtsi"
+#include "stm32mp13-fw-config-mem-encrypt.dtsi"
diff --git a/fdts/stm32mp135f-dk.dts b/fdts/stm32mp135f-dk.dts
index 0f06b671d3..fb5802ab9a 100644
--- a/fdts/stm32mp135f-dk.dts
+++ b/fdts/stm32mp135f-dk.dts
@@ -70,15 +70,13 @@
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
 	clock-frequency = <400000>;
-	status = "disabled";
-	secure-status = "okay";
+	status = "okay";
 
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
 
-		status = "disabled";
-		secure-status = "okay";
+		status = "okay";
 
 		regulators {
 			compatible = "st,stpmic1-regulators";
@@ -170,7 +168,7 @@
 	};
 };
 
-&iwdg2 {
+&iwdg1 {
 	timeout-sec = <32>;
 	status = "okay";
 };
@@ -190,7 +188,6 @@
 		CLK_AXI_PLL2P
 		CLK_MLAHBS_PLL3
 		CLK_CKPER_HSE
-		CLK_RTC_LSE
 		CLK_SDMMC1_PLL4P
 		CLK_SDMMC2_PLL4P
 		CLK_STGEN_HSE
@@ -212,44 +209,24 @@
 		DIV(DIV_APB4, 1)
 		DIV(DIV_APB5, 2)
 		DIV(DIV_APB6, 1)
-		DIV(DIV_RTC, 0)
 	>;
 
 	st,pll_vco {
-		pll1_vco_1300Mhz: pll1-vco-1300Mhz {
-			src = < CLK_PLL12_HSE >;
-			divmn = < 2 80 >;
-			frac = < 0x800 >;
-		};
-
 		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
-			src = < CLK_PLL12_HSE >;
-			divmn = < 2 65 >;
-			frac = < 0x1400 >;
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
 		};
 
-		pll3_vco_417_8Mhz: pll3-vco-417_8Mhz {
-			src = < CLK_PLL3_HSE >;
-			divmn = < 1 33 >;
-			frac = < 0x1a04 >;
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
 		};
 
 		pll4_vco_600Mhz: pll4-vco-600Mhz {
-			src = < CLK_PLL4_HSE >;
-			divmn = < 1 49 >;
-		};
-	};
-
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1:st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-
-		st,pll = < &pll1_cfg1 >;
-
-		pll1_cfg1: pll1_cfg1 {
-			st,pll_vco = < &pll1_vco_1300Mhz >;
-			st,pll_div_pqr = < 0 1 1 >;
+			src = <CLK_PLL4_HSE>;
+			divmn = <1 49>;
 		};
 	};
 
@@ -258,11 +235,11 @@
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
 
-		st,pll = < &pll2_cfg1 >;
+		st,pll = <&pll2_cfg1>;
 
 		pll2_cfg1: pll2_cfg1 {
-			st,pll_vco = < &pll2_vco_1066Mhz >;
-			st,pll_div_pqr = < 1 1 0 >;
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 1 0>;
 		};
 	};
 
@@ -271,11 +248,11 @@
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
 
-		st,pll = < &pll3_cfg1 >;
+		st,pll = <&pll3_cfg1>;
 
 		pll3_cfg1: pll3_cfg1 {
-			st,pll_vco = < &pll3_vco_417_8Mhz >;
-			st,pll_div_pqr = < 1 16 1 >;
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 1>;
 		};
 	};
 
@@ -284,11 +261,11 @@
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
 
-		st,pll = < &pll4_cfg1 >;
+		st,pll = <&pll4_cfg1>;
 
 		pll4_cfg1: pll4_cfg1 {
-			st,pll_vco = < &pll4_vco_600Mhz >;
-			st,pll_div_pqr = < 11 59 5 >;
+			st,pll_vco = <&pll4_vco_600Mhz>;
+			st,pll_div_pqr = <11 59 5>;
 		};
 	};
 };
diff --git a/fdts/stm32mp15-bl2.dtsi b/fdts/stm32mp15-bl2.dtsi
index 5489a624e5..a71fa85825 100644
--- a/fdts/stm32mp15-bl2.dtsi
+++ b/fdts/stm32mp15-bl2.dtsi
@@ -3,6 +3,38 @@
  * Copyright (C) STMicroelectronics 2020-2022 - All Rights Reserved
  */
 
+/omit-if-no-ref/ &fmc_pins_a;
+/omit-if-no-ref/ &i2c2_pins_a;
+/omit-if-no-ref/ &i2c4_pins_a;
+/omit-if-no-ref/ &i2c6;
+/omit-if-no-ref/ &qspi_bk1_pins_a;
+/omit-if-no-ref/ &qspi_bk2_pins_a;
+/omit-if-no-ref/ &qspi_clk_pins_a;
+/omit-if-no-ref/ &sdmmc1_b4_pins_a;
+/omit-if-no-ref/ &sdmmc1_dir_pins_a;
+/omit-if-no-ref/ &sdmmc1_dir_pins_b;
+/omit-if-no-ref/ &sdmmc2_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_b4_pins_b;
+/omit-if-no-ref/ &sdmmc2_d47_pins_a;
+/omit-if-no-ref/ &sdmmc2_d47_pins_b;
+/omit-if-no-ref/ &sdmmc2_d47_pins_c;
+/omit-if-no-ref/ &sdmmc2_d47_pins_d;
+/omit-if-no-ref/ &spi6;
+/omit-if-no-ref/ &uart4_pins_a;
+/omit-if-no-ref/ &uart4_pins_b;
+/omit-if-no-ref/ &uart7_pins_a;
+/omit-if-no-ref/ &uart7_pins_b;
+/omit-if-no-ref/ &uart7_pins_c;
+/omit-if-no-ref/ &uart8_pins_a;
+/omit-if-no-ref/ &usart2_pins_a;
+/omit-if-no-ref/ &usart2_pins_b;
+/omit-if-no-ref/ &usart2_pins_c;
+/omit-if-no-ref/ &usart3_pins_a;
+/omit-if-no-ref/ &usart3_pins_b;
+/omit-if-no-ref/ &usart3_pins_c;
+/omit-if-no-ref/ &usbotg_fs_dp_dm_pins_a;
+/omit-if-no-ref/ &usbotg_hs_pins_a;
+
 / {
 #if !STM32MP_EMMC && !STM32MP_SDMMC
 	aliases {
@@ -39,34 +71,9 @@
 #if !STM32MP_USB_PROGRAMMER
 		/delete-node/ usbphyc@5a006000;
 #endif
-		/delete-node/ spi@5c001000;
 		/delete-node/ rtc@5c004000;
 		/delete-node/ etzpc@5c007000;
 		/delete-node/ stgen@5c008000;
-		/delete-node/ i2c@5c009000;
-		/delete-node/ tamp@5c00a000;
-
-		pinctrl@50002000 {
-#if !STM32MP_RAW_NAND
-			/delete-node/ fmc-0;
-#endif
-#if !STM32MP_SPI_NAND && !STM32MP_SPI_NOR
-			/delete-node/ qspi-clk-0;
-			/delete-node/ qspi-bk1-0;
-			/delete-node/ qspi-bk2-0;
-#endif
-#if !STM32MP_EMMC && !STM32MP_SDMMC
-			/delete-node/ sdmmc1-b4-0;
-			/delete-node/ sdmmc1-dir-0;
-			/delete-node/ sdmmc2-b4-0;
-			/delete-node/ sdmmc2-b4-1;
-			/delete-node/ sdmmc2-d47-0;
-#endif
-#if !STM32MP_USB_PROGRAMMER
-			/delete-node/ usbotg_hs-0;
-			/delete-node/ usbotg-fs-dp-dm-0;
-#endif
-		};
 	};
 
 	/*
diff --git a/fdts/stm32mp15-bl32.dtsi b/fdts/stm32mp15-bl32.dtsi
index 31b24f647c..5f618bf572 100644
--- a/fdts/stm32mp15-bl32.dtsi
+++ b/fdts/stm32mp15-bl32.dtsi
@@ -3,6 +3,38 @@
  * Copyright (C) STMicroelectronics 2020-2021 - All Rights Reserved
  */
 
+/omit-if-no-ref/ &fmc_pins_a;
+/omit-if-no-ref/ &i2c2_pins_a;
+/omit-if-no-ref/ &i2c4_pins_a;
+/omit-if-no-ref/ &i2c6;
+/omit-if-no-ref/ &qspi_bk1_pins_a;
+/omit-if-no-ref/ &qspi_bk2_pins_a;
+/omit-if-no-ref/ &qspi_clk_pins_a;
+/omit-if-no-ref/ &sdmmc1_b4_pins_a;
+/omit-if-no-ref/ &sdmmc1_dir_pins_a;
+/omit-if-no-ref/ &sdmmc1_dir_pins_b;
+/omit-if-no-ref/ &sdmmc2_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_b4_pins_b;
+/omit-if-no-ref/ &sdmmc2_d47_pins_a;
+/omit-if-no-ref/ &sdmmc2_d47_pins_b;
+/omit-if-no-ref/ &sdmmc2_d47_pins_c;
+/omit-if-no-ref/ &sdmmc2_d47_pins_d;
+/omit-if-no-ref/ &spi6;
+/omit-if-no-ref/ &uart4_pins_a;
+/omit-if-no-ref/ &uart4_pins_b;
+/omit-if-no-ref/ &uart7_pins_a;
+/omit-if-no-ref/ &uart7_pins_b;
+/omit-if-no-ref/ &uart7_pins_c;
+/omit-if-no-ref/ &uart8_pins_a;
+/omit-if-no-ref/ &usart2_pins_a;
+/omit-if-no-ref/ &usart2_pins_b;
+/omit-if-no-ref/ &usart2_pins_c;
+/omit-if-no-ref/ &usart3_pins_a;
+/omit-if-no-ref/ &usart3_pins_b;
+/omit-if-no-ref/ &usart3_pins_c;
+/omit-if-no-ref/ &usbotg_fs_dp_dm_pins_a;
+/omit-if-no-ref/ &usbotg_hs_pins_a;
+
 / {
 	aliases {
 		/delete-property/ mmc0;
@@ -23,24 +55,6 @@
 		/delete-node/ mmc@58005000;
 		/delete-node/ mmc@58007000;
 		/delete-node/ usbphyc@5a006000;
-		/delete-node/ spi@5c001000;
 		/delete-node/ stgen@5c008000;
-		/delete-node/ i2c@5c009000;
-
-		pinctrl@50002000 {
-			/delete-node/ fmc-0;
-			/delete-node/ qspi-clk-0;
-			/delete-node/ qspi-bk1-0;
-			/delete-node/ qspi-bk2-0;
-			/delete-node/ sdmmc1-b4-0;
-			/delete-node/ sdmmc1-dir-0;
-			/delete-node/ sdmmc2-b4-0;
-			/delete-node/ sdmmc2-b4-1;
-			/delete-node/ sdmmc2-d47-0;
-			/delete-node/ sdmmc2-d47-1;
-			/delete-node/ sdmmc2-d47-3;
-			/delete-node/ usbotg_hs-0;
-			/delete-node/ usbotg-fs-dp-dm-0;
-		};
 	};
 };
diff --git a/fdts/stm32mp15-fw-config.dtsi b/fdts/stm32mp15-fw-config.dtsi
index d583672920..afc083d89f 100644
--- a/fdts/stm32mp15-fw-config.dtsi
+++ b/fdts/stm32mp15-fw-config.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
  */
 
 #include <common/tbbr/tbbr_img_def.h>
@@ -14,12 +14,9 @@
 
 #define DDR_NS_BASE	STM32MP_DDR_BASE
 #ifdef AARCH32_SP_OPTEE
-/* OP-TEE reserved shared memory: located at DDR top or null size */
-#define DDR_SHARE_SIZE	STM32MP_DDR_SHMEM_SIZE
-#define DDR_SHARE_BASE	(STM32MP_DDR_BASE + (DDR_SIZE - DDR_SHARE_SIZE))
-/* OP-TEE secure memory: located right below OP-TEE reserved shared memory */
+/* OP-TEE secure memory: located at DDR top */
 #define DDR_SEC_SIZE	STM32MP_DDR_S_SIZE
-#define DDR_SEC_BASE	(DDR_SHARE_BASE - DDR_SEC_SIZE)
+#define DDR_SEC_BASE	(STM32MP_DDR_BASE + (DDR_SIZE - DDR_SEC_SIZE))
 #define DDR_NS_SIZE	(DDR_SEC_BASE - DDR_NS_BASE)
 #else /* !AARCH32_SP_OPTEE */
 #define DDR_NS_SIZE	DDR_SIZE
@@ -44,11 +41,19 @@
 		};
 
 #ifdef AARCH32_SP_OPTEE
+#if STM32MP1_OPTEE_IN_SYSRAM
 		tos_fw {
 			load-address = <0x0 STM32MP_OPTEE_BASE>;
 			max-size = <STM32MP_OPTEE_SIZE>;
 			id = <BL32_IMAGE_ID>;
 		};
+#else
+		tos_fw {
+			load-address = <0x0 DDR_SEC_BASE>;
+			max-size = <DDR_SEC_SIZE>;
+			id = <BL32_IMAGE_ID>;
+		};
+#endif /* STM32MP1_OPTEE_IN_SYSRAM */
 #else
 		tos_fw {
 			load-address = <0x0 STM32MP_BL32_BASE>;
@@ -70,10 +75,6 @@
 		memory-ranges = <
 			DDR_NS_BASE DDR_NS_SIZE TZC_REGION_S_NONE TZC_REGION_NSEC_ALL_ACCESS_RDWR
 			DDR_SEC_BASE DDR_SEC_SIZE TZC_REGION_S_RDWR 0
-#if STM32MP15_OPTEE_RSV_SHM
-			DDR_SHARE_BASE DDR_SHARE_SIZE TZC_REGION_S_NONE
-			TZC_REGION_ACCESS_RDWR(STM32MP1_TZC_A7_ID)
-#endif
 			>;
 #else
 		memory-ranges = <
diff --git a/fdts/stm32mp15-pinctrl.dtsi b/fdts/stm32mp15-pinctrl.dtsi
index 7d2be0b833..a1be44781e 100644
--- a/fdts/stm32mp15-pinctrl.dtsi
+++ b/fdts/stm32mp15-pinctrl.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2017-2021, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2023, STMicroelectronics - All Rights Reserved
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
diff --git a/fdts/stm32mp15-ssp-bl2.dtsi b/fdts/stm32mp15-ssp-bl2.dtsi
new file mode 100644
index 0000000000..e2d5625e27
--- /dev/null
+++ b/fdts/stm32mp15-ssp-bl2.dtsi
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+/ {
+	cpus {
+		/delete-node/ cpu@1;
+	};
+
+#if STM32MP_USB_PROGRAMMER
+	aliases {
+		/delete-property/ serial1;
+		/delete-property/ serial2;
+		/delete-property/ serial3;
+	};
+#endif
+
+	/delete-node/ cpu0_opp_table;
+	/delete-node/ psci;
+
+	sysram: sram@2ffc0000 {
+		compatible = "mmio-sram";
+		reg = <0x2ffc0000 0x40000>;
+		vddcore-supply = <&vddcore>;
+	};
+
+	soc {
+		efuse@5c005000 {
+			cfg2_otp: cfg2_otp@8 {
+				reg = <0x8 0x4>;
+			};
+
+			ssp_otp: ssp_otp@20 {
+				reg = <0x20 0x4>;
+			};
+
+			chip_otp: chip_otp@a0 {
+				reg = <0xa0 0x40>;
+			};
+
+			rma_otp: rma_otp@e0 {
+				reg = <0xe0 0x4>;
+			};
+		};
+
+		/delete-node/ timer@40006000;
+#if STM32MP_USB_PROGRAMMER
+		/delete-node/ serial@4000e000;
+		/delete-node/ serial@4000f000;
+		/delete-node/ serial@40011000;
+		/delete-node/ serial@40018000;
+		/delete-node/ serial@40019000;
+		/delete-node/ serial@44003000;
+#endif
+		/delete-node/ timer@44006000;
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usb-otg@49000000;
+#endif
+		/delete-node/ pwr_mcu@50001014;
+		/delete-node/ cryp@54001000;
+		/delete-node/ rng@54003000;
+		/delete-node/ memory-controller@58002000;
+		/delete-node/ spi@58003000;
+		/delete-node/ mmc@58005000;
+		/delete-node/ mmc@58007000;
+		/delete-node/ ddr@5a003000;
+#if STM32MP_UART_PROGRAMMER
+		/delete-node/ usbphyc@5a006000;
+#endif
+#if STM32MP_USB_PROGRAMMER
+		/delete-node/ serial@5c000000;
+#endif
+		/delete-node/ spi@5c001000;
+		/delete-node/ rtc@5c004000;
+		/delete-node/ etzpc@5c007000;
+		/delete-node/ stgen@5c008000;
+		/delete-node/ i2c@5c009000;
+		/delete-node/ tamp@5c00a000;
+	};
+};
diff --git a/fdts/stm32mp151.dtsi b/fdts/stm32mp151.dtsi
index a938edc0c4..0206b69356 100644
--- a/fdts/stm32mp151.dtsi
+++ b/fdts/stm32mp151.dtsi
@@ -127,8 +127,8 @@
 			compatible = "st,stm32mp15-i2c";
 			reg = <0x40013000 0x400>;
 			interrupt-names = "event", "error";
-			interrupts = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
-				     <&intc GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+			interrupts-extended = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
+					      <&intc GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc I2C2_K>;
 			resets = <&rcc I2C2_R>;
 			#address-cells = <1>;
@@ -318,6 +318,8 @@
 			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
 			clocks = <&rcc QSPI_K>;
 			resets = <&rcc QSPI_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
 			status = "disabled";
 		};
 
@@ -490,7 +492,7 @@
 			pkh_otp: pkh_otp@60 {
 				reg = <0x60 0x20>;
 			};
-			mac_addr: mac_addr@e4 {
+			ethernet_mac_address: mac@e4 {
 				reg = <0xe4 0x8>;
 				st,non-secure-otp;
 			};
@@ -523,10 +525,47 @@
 		};
 
 		tamp: tamp@5c00a000 {
-			compatible = "st,stm32-tamp", "simple-bus", "syscon", "simple-mfd";
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
 			reg = <0x5c00a000 0x400>;
-			secure-interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc RTCAPB>;
+			ranges;
+
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x5c00a100 0x80>;
+
+				magic_number: tamp-bkp@10 {
+					/* see ddr and cpu wake up management feature */
+					reg = <0x10 0x4>;
+				};
+
+				branch_address: tamp-bkp@14 {
+					/* see ddr and cpu wake up management feature */
+					reg = <0x14 0x4>;
+				};
+
+				fwu_info: tamp-bkp@28 {
+					/* see firmware update info feature */
+					reg = <0x28 0x4>;
+				};
+
+				boot_mode: tamp-bkp@50 {
+					/* see boot mode selection feature */
+					reg = <0x50 0x4>;
+				};
+
+			};
+
+			boot_info: boot-info {
+				compatible = "st,stm32mp-bootinfo";
+				nvmem-cells = <&magic_number>, <&branch_address>,
+					      <&boot_mode>, <&fwu_info>;
+				nvmem-cell-names = "magic-number", "core1-branch-address",
+						   "boot-mode", "fwu-info";
+			};
 		};
 
 		/*
diff --git a/fdts/stm32mp157a-avenger96.dts b/fdts/stm32mp157a-avenger96.dts
index f0da350bba..73abe56071 100644
--- a/fdts/stm32mp157a-avenger96.dts
+++ b/fdts/stm32mp157a-avenger96.dts
@@ -175,29 +175,9 @@
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
 		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -235,35 +215,76 @@
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = <2 80 0 0 0 PQR(1,0,0)>;
-		frac = <0x800>;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_480Mhz: pll4-vco-480Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <1 39>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
 	/* VCO = 480.0 MHz => P = 120, Q = 40, R = 96 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <1 39 3 11 4 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_480Mhz>;
+			st,pll_div_pqr = <3 11 4>;
+		};
 	};
 };
 
diff --git a/fdts/stm32mp157a-dk1.dts b/fdts/stm32mp157a-dk1.dts
index a73bef8ee4..f415e581a6 100644
--- a/fdts/stm32mp157a-dk1.dts
+++ b/fdts/stm32mp157a-dk1.dts
@@ -7,6 +7,7 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
diff --git a/fdts/stm32mp157a-ed1.dts b/fdts/stm32mp157a-ed1.dts
new file mode 100644
index 0000000000..18334983ba
--- /dev/null
+++ b/fdts/stm32mp157a-ed1.dts
@@ -0,0 +1,347 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter";
+	compatible = "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xC0000000 0x40000000>;
+	};
+
+	aliases {
+		serial0 = &uart4;
+	};
+};
+
+&bsec {
+	board_id: board_id@ec {
+		reg = <0xec 0x4>;
+		st,non-secure-otp;
+	};
+};
+
+&clk_hse {
+	st,digbypass;
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+				st,regulator-sink-source;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				regulator-active-discharge = <1>;
+			};
+		};
+	};
+};
+
+&iwdg1 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+		CLK_CKPER_HSE
+		CLK_FMC_ACLK
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_PLL4P
+		CLK_DSI_DSIPLL
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_PLL3Q
+		CLK_SPI2S23_PLL3Q
+		CLK_SPI45_HSI
+		CLK_SPI6_HSI
+		CLK_I2C46_HSI
+		CLK_SDMMC3_PLL4P
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_LSE
+		CLK_I2C12_HSI
+		CLK_I2C35_HSI
+		CLK_UART1_HSI
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_HSI
+		CLK_UART78_HSI
+		CLK_SPDIF_PLL4P
+		CLK_FDCAN_PLL4R
+		CLK_SAI1_PLL3Q
+		CLK_SAI2_PLL3Q
+		CLK_SAI3_PLL3Q
+		CLK_SAI4_PLL3Q
+		CLK_RNG1_CSI
+		CLK_RNG2_LSI
+		CLK_LPTIM1_PCLK1
+		CLK_LPTIM23_PCLK3
+		CLK_LPTIM45_LSE
+	>;
+
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
+	};
+
+	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
+	pll2: st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
+	};
+
+	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+	pll3: st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
+	};
+
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
+	pll4: st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
+	};
+};
+
+&rng1 {
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "okay";
+};
diff --git a/fdts/stm32mp157a-ev1.dts b/fdts/stm32mp157a-ev1.dts
new file mode 100644
index 0000000000..2310022320
--- /dev/null
+++ b/fdts/stm32mp157a-ev1.dts
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157a-ed1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter on eval mother";
+	compatible = "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial1 = &usart3;
+	};
+};
+
+&fmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&fmc_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: mx66l51235l@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart3_pins_b>;
+	uart-has-rtscts;
+	status = "disabled";
+};
diff --git a/fdts/stm32mp157c-ed1.dts b/fdts/stm32mp157c-ed1.dts
index d9285638a2..709443accd 100644
--- a/fdts/stm32mp157c-ed1.dts
+++ b/fdts/stm32mp157c-ed1.dts
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2023, STMicroelectronics - All Rights Reserved
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
 /dts-v1/;
@@ -169,28 +169,17 @@
 
 			vbus_otg: pwr_sw1 {
 				regulator-name = "vbus_otg";
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr_sw2 {
 				regulator-name = "vbus_sw";
 				regulator-active-discharge = <1>;
-			 };
-		};
-
-		onkey {
-			compatible = "st,stpmic1-onkey";
-			power-off-time-sec = <10>;
-			status = "okay";
-		};
-
-		watchdog {
-			compatible = "st,stpmic1-wdt";
-			status = "disabled";
+			};
 		};
 	};
 };
 
-&iwdg2 {
+&iwdg1 {
 	timeout-sec = <32>;
 	status = "okay";
 };
@@ -201,33 +190,13 @@
 };
 
 &rcc {
+	compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
 	st,clksrc = <
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -258,42 +227,82 @@
 		CLK_SAI2_PLL3Q
 		CLK_SAI3_PLL3Q
 		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
+		CLK_RNG1_CSI
 		CLK_RNG2_LSI
 		CLK_LPTIM1_PCLK1
 		CLK_LPTIM23_PCLK3
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = <2 80 0 0 0 PQR(1,0,0)>;
-		frac = <0x800>;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
 	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <3 98 5 7 7 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
 	};
 };
 
diff --git a/fdts/stm32mp157c-odyssey-som.dtsi b/fdts/stm32mp157c-odyssey-som.dtsi
index 091e327cf7..785a73ff00 100644
--- a/fdts/stm32mp157c-odyssey-som.dtsi
+++ b/fdts/stm32mp157c-odyssey-som.dtsi
@@ -207,29 +207,9 @@
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
 		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -267,35 +247,76 @@
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = <2 80 0 0 0 PQR(1,0,0)>;
-		frac = <0x800>;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
 	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <3 98 5 7 7 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
 	};
 };
 
diff --git a/fdts/stm32mp157d-dk1.dts b/fdts/stm32mp157d-dk1.dts
new file mode 100644
index 0000000000..2b7dde544a
--- /dev/null
+++ b/fdts/stm32mp157d-dk1.dts
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 Discovery Board";
+	compatible = "st,stm32mp157d-dk1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
diff --git a/fdts/stm32mp157d-ed1.dts b/fdts/stm32mp157d-ed1.dts
new file mode 100644
index 0000000000..0693d72ab9
--- /dev/null
+++ b/fdts/stm32mp157d-ed1.dts
@@ -0,0 +1,347 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter";
+	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xC0000000 0x40000000>;
+	};
+
+	aliases {
+		serial0 = &uart4;
+	};
+};
+
+&bsec {
+	board_id: board_id@ec {
+		reg = <0xec 0x4>;
+		st,non-secure-otp;
+	};
+};
+
+&clk_hse {
+	st,digbypass;
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+				st,regulator-sink-source;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				regulator-active-discharge = <1>;
+			};
+		};
+	};
+};
+
+&iwdg1 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+		CLK_CKPER_HSE
+		CLK_FMC_ACLK
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_PLL4P
+		CLK_DSI_DSIPLL
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_PLL3Q
+		CLK_SPI2S23_PLL3Q
+		CLK_SPI45_HSI
+		CLK_SPI6_HSI
+		CLK_I2C46_HSI
+		CLK_SDMMC3_PLL4P
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_LSE
+		CLK_I2C12_HSI
+		CLK_I2C35_HSI
+		CLK_UART1_HSI
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_HSI
+		CLK_UART78_HSI
+		CLK_SPDIF_PLL4P
+		CLK_FDCAN_PLL4R
+		CLK_SAI1_PLL3Q
+		CLK_SAI2_PLL3Q
+		CLK_SAI3_PLL3Q
+		CLK_SAI4_PLL3Q
+		CLK_RNG1_CSI
+		CLK_RNG2_LSI
+		CLK_LPTIM1_PCLK1
+		CLK_LPTIM23_PCLK3
+		CLK_LPTIM45_LSE
+	>;
+
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
+	};
+
+	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
+	pll2: st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
+	};
+
+	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+	pll3: st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
+	};
+
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
+	pll4: st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
+	};
+};
+
+&rng1 {
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "okay";
+};
diff --git a/fdts/stm32mp157d-ev1.dts b/fdts/stm32mp157d-ev1.dts
new file mode 100644
index 0000000000..b392359bb6
--- /dev/null
+++ b/fdts/stm32mp157d-ev1.dts
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157d-ed1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter on eval mother";
+	compatible = "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial1 = &usart3;
+	};
+};
+
+&fmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&fmc_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: mx66l51235l@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart3_pins_b>;
+	uart-has-rtscts;
+	status = "disabled";
+};
diff --git a/fdts/stm32mp157f-dk2.dts b/fdts/stm32mp157f-dk2.dts
new file mode 100644
index 0000000000..bf88c6df12
--- /dev/null
+++ b/fdts/stm32mp157f-dk2.dts
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 Discovery Board";
+	compatible = "st,stm32mp157f-dk2", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+		serial3 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
diff --git a/fdts/stm32mp157f-ed1.dts b/fdts/stm32mp157f-ed1.dts
new file mode 100644
index 0000000000..d097e05682
--- /dev/null
+++ b/fdts/stm32mp157f-ed1.dts
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include <dt-bindings/clock/stm32mp1-clksrc.h>
+#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter";
+	compatible = "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xC0000000 0x40000000>;
+	};
+
+	aliases {
+		serial0 = &uart4;
+	};
+};
+
+&bsec {
+	board_id: board_id@ec {
+		reg = <0xec 0x4>;
+		st,non-secure-otp;
+	};
+};
+
+&clk_hse {
+	st,digbypass;
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+				st,regulator-sink-source;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				regulator-active-discharge = <1>;
+			};
+		};
+	};
+};
+
+&iwdg1 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
+	st,clksrc = <
+		CLK_MPU_PLL1P
+		CLK_AXI_PLL2P
+		CLK_MCU_PLL3P
+		CLK_MCO1_DISABLED
+		CLK_MCO2_DISABLED
+		CLK_CKPER_HSE
+		CLK_FMC_ACLK
+		CLK_QSPI_ACLK
+		CLK_ETH_PLL4P
+		CLK_SDMMC12_PLL4P
+		CLK_DSI_DSIPLL
+		CLK_STGEN_HSE
+		CLK_USBPHY_HSE
+		CLK_SPI2S1_PLL3Q
+		CLK_SPI2S23_PLL3Q
+		CLK_SPI45_HSI
+		CLK_SPI6_HSI
+		CLK_I2C46_HSI
+		CLK_SDMMC3_PLL4P
+		CLK_USBO_USBPHY
+		CLK_ADC_CKPER
+		CLK_CEC_LSE
+		CLK_I2C12_HSI
+		CLK_I2C35_HSI
+		CLK_UART1_HSI
+		CLK_UART24_HSI
+		CLK_UART35_HSI
+		CLK_UART6_HSI
+		CLK_UART78_HSI
+		CLK_SPDIF_PLL4P
+		CLK_FDCAN_PLL4R
+		CLK_SAI1_PLL3Q
+		CLK_SAI2_PLL3Q
+		CLK_SAI3_PLL3Q
+		CLK_SAI4_PLL3Q
+		CLK_RNG1_CSI
+		CLK_RNG2_LSI
+		CLK_LPTIM1_PCLK1
+		CLK_LPTIM23_PCLK3
+		CLK_LPTIM45_LSE
+	>;
+
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
+	};
+
+	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
+	pll2: st,pll@1 {
+		compatible = "st,stm32mp1-pll";
+		reg = <1>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
+	};
+
+	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
+	pll3: st,pll@2 {
+		compatible = "st,stm32mp1-pll";
+		reg = <2>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
+	};
+
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
+	pll4: st,pll@3 {
+		compatible = "st,stm32mp1-pll";
+		reg = <3>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
+	};
+};
+
+&rng1 {
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "okay";
+};
diff --git a/fdts/stm32mp157f-ev1.dts b/fdts/stm32mp157f-ev1.dts
new file mode 100644
index 0000000000..7b00408108
--- /dev/null
+++ b/fdts/stm32mp157f-ev1.dts
@@ -0,0 +1,63 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157f-ed1.dts"
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter on eval mother";
+	compatible = "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		serial1 = &usart3;
+	};
+};
+
+&fmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&fmc_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&qspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: mx66l51235l@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&usart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart3_pins_b>;
+	uart-has-rtscts;
+	status = "disabled";
+};
diff --git a/fdts/stm32mp15xa.dtsi b/fdts/stm32mp15xa.dtsi
new file mode 100644
index 0000000000..cc6456e71b
--- /dev/null
+++ b/fdts/stm32mp15xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/fdts/stm32mp15xc.dtsi b/fdts/stm32mp15xc.dtsi
index b06a55a2fa..f729b0d1bd 100644
--- a/fdts/stm32mp15xc.dtsi
+++ b/fdts/stm32mp15xc.dtsi
@@ -4,6 +4,8 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
+#include "stm32mp15xa.dtsi"
+
 / {
 	soc {
 		cryp1: cryp@54001000 {
diff --git a/fdts/stm32mp15xd.dtsi b/fdts/stm32mp15xd.dtsi
new file mode 100644
index 0000000000..cc6456e71b
--- /dev/null
+++ b/fdts/stm32mp15xd.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/fdts/stm32mp15xf.dtsi b/fdts/stm32mp15xf.dtsi
new file mode 100644
index 0000000000..ae4a14af6c
--- /dev/null
+++ b/fdts/stm32mp15xf.dtsi
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15xd.dtsi"
+
+/ {
+	soc {
+		cryp1: cryp@54001000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x54001000 0x400>;
+			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc CRYP1>;
+			resets = <&rcc CRYP1_R>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/fdts/stm32mp15xx-dhcom-som.dtsi b/fdts/stm32mp15xx-dhcom-som.dtsi
index c9f21b0e6e..7a7c4cf85e 100644
--- a/fdts/stm32mp15xx-dhcom-som.dtsi
+++ b/fdts/stm32mp15xx-dhcom-som.dtsi
@@ -190,29 +190,9 @@
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
 		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_PLL4P
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		1 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -250,35 +230,76 @@
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = <2 80 0 0 0 PQR(1,0,0)>;
-		frac = <0x800>;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 1)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_600Mhz: pll4-vco-600hz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <1 49>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
 	/* VCO = 600.0 MHz => P = 50, Q = 50, R = 50 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <1 49 5 11 11 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_600Mhz>;
+			st,pll_div_pqr = <5 11 11>;
+		};
 	};
 };
 
diff --git a/fdts/stm32mp15xx-dhcor-som.dtsi b/fdts/stm32mp15xx-dhcor-som.dtsi
index c241efc48e..c5aaef3010 100644
--- a/fdts/stm32mp15xx-dhcor-som.dtsi
+++ b/fdts/stm32mp15xx-dhcor-som.dtsi
@@ -185,29 +185,9 @@
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
 		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -245,35 +225,77 @@
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = <2 80 0 0 0 PQR(1,0,0)>;
-		frac = <0x800>;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
-	/* VCO = 600.0 MHz => P = 99, Q = 74, R = 99 */
+	/* VCO = 600.0 MHz => P = 99, Q = 74, R = 99 */ /* @TOCHECK */
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <3 98 5 7 5 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
 	};
 };
 
diff --git a/fdts/stm32mp15xx-dkx.dtsi b/fdts/stm32mp15xx-dkx.dtsi
index 52d4170fd2..18d8a89a71 100644
--- a/fdts/stm32mp15xx-dkx.dtsi
+++ b/fdts/stm32mp15xx-dkx.dtsi
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
 /*
- * Copyright (c) 2019-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2019-2023, STMicroelectronics - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
@@ -177,7 +177,7 @@
 	};
 };
 
-&iwdg2 {
+&iwdg1 {
 	timeout-sec = <32>;
 	status = "okay";
 };
@@ -188,33 +188,13 @@
 };
 
 &rcc {
+	compatible = "st,stm32mp1-rcc-secure", "st,stm32mp1-rcc", "syscon";
 	st,clksrc = <
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -245,42 +225,82 @@
 		CLK_SAI2_PLL3Q
 		CLK_SAI3_PLL3Q
 		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
+		CLK_RNG1_CSI
 		CLK_RNG2_LSI
 		CLK_LPTIM1_PCLK1
 		CLK_LPTIM23_PCLK3
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = < 2 80 0 0 0 PQR(1,0,0) >;
-		frac = < 0x800 >;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
 	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <3 98 5 7 7 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
 	};
 };
 
diff --git a/fdts/stm32mp15xx-osd32.dtsi b/fdts/stm32mp15xx-osd32.dtsi
index 52a5d380bc..c5c04f3daf 100644
--- a/fdts/stm32mp15xx-osd32.dtsi
+++ b/fdts/stm32mp15xx-osd32.dtsi
@@ -185,29 +185,9 @@
 		CLK_MPU_PLL1P
 		CLK_AXI_PLL2P
 		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
 		CLK_RTC_LSE
 		CLK_MCO1_DISABLED
 		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
 		CLK_CKPER_HSE
 		CLK_FMC_ACLK
 		CLK_QSPI_ACLK
@@ -245,34 +225,75 @@
 		CLK_LPTIM45_LSE
 	>;
 
-	/* VCO = 1300.0 MHz => P = 650 (CPU) */
-	pll1: st,pll@0 {
-		compatible = "st,stm32mp1-pll";
-		reg = <0>;
-		cfg = < 2 80 0 0 0 PQR(1,0,0) >;
-		frac = < 0x800 >;
+	st,clkdiv = <
+		DIV(DIV_MPU, 1)
+		DIV(DIV_AXI, 0)
+		DIV(DIV_MCU, 0)
+		DIV(DIV_APB1, 1)
+		DIV(DIV_APB2, 1)
+		DIV(DIV_APB3, 1)
+		DIV(DIV_APB4, 1)
+		DIV(DIV_APB5, 2)
+		DIV(DIV_RTC, 23)
+		DIV(DIV_MCO1, 0)
+		DIV(DIV_MCO2, 0)
+	>;
+
+	st,pll_vco {
+		pll2_vco_1066Mhz: pll2-vco-1066Mhz {
+			src = <CLK_PLL12_HSE>;
+			divmn = <2 65>;
+			frac = <0x1400>;
+		};
+
+		pll3_vco_417Mhz: pll3-vco-417Mhz {
+			src = <CLK_PLL3_HSE>;
+			divmn = <1 33>;
+			frac = <0x1a04>;
+		};
+
+		pll4_vco_594Mhz: pll4-vco-594Mhz {
+			src = <CLK_PLL4_HSE>;
+			divmn = <3 98>;
+		};
 	};
 
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
 		reg = <1>;
-		cfg = <2 65 1 0 0 PQR(1,1,1)>;
-		frac = <0x1400>;
+
+		st,pll = <&pll2_cfg1>;
+
+		pll2_cfg1: pll2_cfg1 {
+			st,pll_vco = <&pll2_vco_1066Mhz>;
+			st,pll_div_pqr = <1 0 0>;
+		};
 	};
 
 	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
 	pll3: st,pll@2 {
 		compatible = "st,stm32mp1-pll";
 		reg = <2>;
-		cfg = <1 33 1 16 36 PQR(1,1,1)>;
-		frac = <0x1a04>;
+
+		st,pll = <&pll3_cfg1>;
+
+		pll3_cfg1: pll3_cfg1 {
+			st,pll_vco = <&pll3_vco_417Mhz>;
+			st,pll_div_pqr = <1 16 36>;
+		};
 	};
 
 	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
-		cfg = <3 98 5 7 7 PQR(1,1,1)>;
+
+		st,pll = <&pll4_cfg1>;
+
+		pll4_cfg1: pll4_cfg1 {
+			st,pll_vco = <&pll4_vco_594Mhz>;
+			st,pll_div_pqr = <5 7 7>;
+		};
 	};
 };
diff --git a/fdts/stm32mp2-cot-descriptors.dtsi b/fdts/stm32mp2-cot-descriptors.dtsi
new file mode 100644
index 0000000000..dd74b164ad
--- /dev/null
+++ b/fdts/stm32mp2-cot-descriptors.dtsi
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2020-2023, ARM Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/nv_cntr_ids.h>
+#include <common/tbbr/tbbr_img_def.h>
+#include <tools_share/tbbr_oid.h>
+
+#include <platform_oid.h>
+
+cot {
+	manifests {
+		compatible = "arm, cert-descs";
+
+		stm32mp_cfg_cert: stm32mp_cfg_cert {
+			root-certificate;
+			image-id = <STM32MP_CONFIG_CERT_ID>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			hw_config_hash: hw_config_hash {
+				oid = HW_CONFIG_HASH_OID;
+			};
+			fw_config_hash: fw_config_hash {
+				oid = FW_CONFIG_HASH_OID;
+			};
+			ddr_fw_hash: ddr_fw_hash {
+				oid = DDR_FW_HASH_OID;
+			};
+		};
+
+		trusted_key_cert: trusted_key_cert {
+			root-certificate;
+			image-id = <TRUSTED_KEY_CERT_ID>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			trusted_world_pk: trusted_world_pk {
+				oid = TRUSTED_WORLD_PK_OID;
+			};
+			non_trusted_world_pk: non_trusted_world_pk {
+				oid = NON_TRUSTED_WORLD_PK_OID;
+			};
+		};
+
+		trusted_os_fw_key_cert: trusted_os_fw_key_cert {
+			image-id = <TRUSTED_OS_FW_KEY_CERT_ID>;
+			parent = <&trusted_key_cert>;
+			signing-key = <&trusted_world_pk>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			tos_fw_content_pk: tos_fw_content_pk {
+				oid = TRUSTED_OS_FW_CONTENT_CERT_PK_OID;
+			};
+		};
+
+		trusted_os_fw_content_cert: trusted_os_fw_content_cert {
+			image-id = <TRUSTED_OS_FW_CONTENT_CERT_ID>;
+			parent = <&trusted_os_fw_key_cert>;
+			signing-key = <&tos_fw_content_pk>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			tos_fw_hash: tos_fw_hash {
+				oid = TRUSTED_OS_FW_HASH_OID;
+			};
+			tos_fw_extra1_hash: tos_fw_extra1_hash {
+				oid = TRUSTED_OS_FW_EXTRA1_HASH_OID;
+			};
+			tos_fw_extra2_hash: tos_fw_extra2_hash {
+				oid = TRUSTED_OS_FW_EXTRA2_HASH_OID;
+			};
+		};
+
+		non_trusted_fw_key_cert: non_trusted_fw_key_cert {
+			image-id = <NON_TRUSTED_FW_KEY_CERT_ID>;
+			parent = <&trusted_key_cert>;
+			signing-key = <&non_trusted_world_pk>;
+			antirollback-counter = <&non_trusted_nv_counter>;
+
+			nt_fw_content_pk: nt_fw_content_pk {
+				oid = NON_TRUSTED_FW_CONTENT_CERT_PK_OID;
+			};
+		};
+
+		non_trusted_fw_content_cert: non_trusted_fw_content_cert {
+			image-id = <NON_TRUSTED_FW_CONTENT_CERT_ID>;
+			parent = <&non_trusted_fw_key_cert>;
+			signing-key = <&nt_fw_content_pk>;
+			antirollback-counter = <&non_trusted_nv_counter>;
+
+			nt_world_bl_hash: nt_world_bl_hash {
+				oid = NON_TRUSTED_WORLD_BOOTLOADER_HASH_OID;
+			};
+		};
+
+		soc_fw_key_cert: soc_fw_key_cert {
+			image-id = <SOC_FW_KEY_CERT_ID>;
+			parent = <&trusted_key_cert>;
+			signing-key = <&trusted_world_pk>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			soc_fw_content_pk: soc_fw_content_pk {
+				oid = SOC_FW_CONTENT_CERT_PK_OID;
+			};
+		};
+
+		soc_fw_content_cert: soc_fw_content_cert {
+			image-id = <SOC_FW_CONTENT_CERT_ID>;
+			parent = <&soc_fw_key_cert>;
+			signing-key = <&soc_fw_content_pk>;
+			antirollback-counter = <&trusted_nv_counter>;
+
+			soc_fw_hash: soc_fw_hash {
+				oid = SOC_AP_FW_HASH_OID;
+			};
+			soc_fw_config_hash: soc_fw_config_hash {
+				oid = SOC_FW_CONFIG_HASH_OID;
+			};
+		};
+	};
+
+	images {
+		compatible = "arm, img-descs";
+
+		hw_config {
+			image-id = <HW_CONFIG_ID>;
+			parent = <&stm32mp_cfg_cert>;
+			hash = <&hw_config_hash>;
+		};
+
+		fw_config {
+			image-id = <FW_CONFIG_ID>;
+			parent = <&stm32mp_cfg_cert>;
+			hash = <&fw_config_hash>;
+		};
+
+		bl31_image {
+			image-id = <BL31_IMAGE_ID>;
+			parent = <&soc_fw_content_cert>;
+			hash = <&soc_fw_hash>;
+		};
+
+		soc_fw_config {
+			image-id = <SOC_FW_CONFIG_ID>;
+			parent = <&soc_fw_content_cert>;
+			hash = <&soc_fw_config_hash>;
+		};
+
+		bl32_image {
+			image-id = <BL32_IMAGE_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_hash>;
+		};
+
+		bl32_extra1_image {
+			image-id = <BL32_EXTRA1_IMAGE_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_extra1_hash>;
+		};
+
+		bl32_extra2_image {
+			image-id = <BL32_EXTRA2_IMAGE_ID>;
+			parent = <&trusted_os_fw_content_cert>;
+			hash = <&tos_fw_extra2_hash>;
+		};
+
+		bl33_image {
+			image-id = <BL33_IMAGE_ID>;
+			parent = <&non_trusted_fw_content_cert>;
+			hash = <&nt_world_bl_hash>;
+		};
+
+		ddr_fw {
+			image-id = <DDR_FW_ID>;
+			parent = <&stm32mp_cfg_cert>;
+			hash = <&ddr_fw_hash>;
+		};
+	};
+};
+
+non_volatile_counters: non_volatile_counters {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	trusted_nv_counter: trusted_nv_counter {
+		id  = <TRUSTED_NV_CTR_ID>;
+		oid = TRUSTED_FW_NVCOUNTER_OID;
+	};
+
+	non_trusted_nv_counter: non_trusted_nv_counter {
+		id  = <NON_TRUSTED_NV_CTR_ID>;
+		oid = NON_TRUSTED_FW_NVCOUNTER_OID;
+	};
+};
diff --git a/fdts/stm32mp25-bl2.dtsi b/fdts/stm32mp25-bl2.dtsi
new file mode 100644
index 0000000000..390914dba5
--- /dev/null
+++ b/fdts/stm32mp25-bl2.dtsi
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include <platform_def.h>
+
+/omit-if-no-ref/ &i2c7_pins_a;
+/omit-if-no-ref/ &ospi_port1_clk_pins_a;
+/omit-if-no-ref/ &ospi_port1_cs0_pins_a;
+/omit-if-no-ref/ &ospi_port1_io03_pins_a;
+/omit-if-no-ref/ &sdmmc1_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_d47_pins_a;
+/omit-if-no-ref/ &usart2_pins_a;
+
+/ {
+	soc@0 {
+#if !STM32MP_SPI_NAND && !STM32MP_SPI_NOR && !STM32MP_HYPERFLASH
+		/delete-node/ ommanager@40500000;
+#else
+		ommanager@40500000 {
+#if STM32MP_HYPERFLASH
+			/delete-node/ spi@40430000;
+#endif
+			/delete-node/ spi@40440000;
+		};
+#endif
+#if !STM32MP_RAW_NAND
+		/delete-node/ memory-controller@48200000;
+#endif
+#if !STM32MP_EMMC && !STM32MP_SDMMC
+		rifsc@42080000 {
+			/delete-node/ mmc@48220000;
+			/delete-node/ mmc@48230000;
+		};
+#endif
+	};
+
+	/*
+	 * UUID's here are UUID RFC 4122 compliant meaning fieds are stored in
+	 * network order (big endian)
+	 */
+
+	st-io_policies {
+		fip-handles {
+			compatible = "st,io-fip-handle";
+#if STM32MP_DDR_FIP_IO_STORAGE
+			ddr_fw_uuid = "b11249be-92dd-4b10-867c-2c6a4b47a7fb";
+#endif
+			fw_cfg_uuid = "5807e16a-8459-47be-8ed5-648e8dddab0e";
+			bl31_uuid = "47d4086d-4cfe-9846-9b95-2950cbbd5a00";
+			bl32_uuid = "05d0e189-53dc-1347-8d2b-500a4b7a3e38";
+			bl32_extra1_uuid = "0b70c29b-2a5a-7840-9f65-0a5682738288";
+			bl32_extra2_uuid = "8ea87bb1-cfa2-3f4d-85fd-e7bba50220d9";
+			bl33_uuid = "d6d0eea7-fcea-d54b-9782-9934f234b6e4";
+			hw_cfg_uuid = "08b8f1d9-c9cf-9349-a962-6fbc6b7265cc";
+			soc_fw_cfg_uuid = "9979814b-0376-fb46-8c8e-8d267f7859e0";
+			tos_fw_cfg_uuid = "26257c1a-dbc6-7f47-8d96-c4c4b0248021";
+			nt_fw_cfg_uuid = "28da9815-93e8-7e44-ac66-1aaf801550f9";
+#if TRUSTED_BOARD_BOOT
+			stm32mp_cfg_cert_uuid = "501d8dd2-8bce-49a5-84eb-559a9f2eaeaf";
+			t_key_cert_uuid = "827ee890-f860-e411-a1b4-777a21b4f94c";
+			soc_fw_key_uuid = "8ab8becc-f960-e411-9ad0-eb4822d8dcf8";
+			tos_fw_key_cert_uuid = "9477d603-fb60-e411-85dd-b7105b8cee04";
+			nt_fw_key_cert_uuid = "8ad5832a-fb60-e411-8aaf-df30bbc49859";
+			soc_fw_content_cert_uuid = "e2b20c20-5e63-e411-9ce8-abccf92bb666";
+			tos_fw_content_cert_uuid = "a49f4411-5e63-e411-8728-3f05722af33d";
+			nt_fw_content_cert_uuid = "8ec4c1f3-5d63-e411-a7a9-87ee40b23fa7";
+#endif
+		};
+	};
+
+#if TRUSTED_BOARD_BOOT
+	tb_fw-config {
+		compatible = "arm,tb_fw";
+
+		/* Disable authentication for development */
+		disable_auth = <0x0>;
+
+		mbedtls_heap_addr = <0x0 STM32MP_MBEDTLS_HEAP_BASE>;
+		mbedtls_heap_size = <STM32MP_MBEDTLS_HEAP_SIZE>;
+	};
+
+#include "stm32mp2-cot-descriptors.dtsi"
+#endif
+
+};
diff --git a/fdts/stm32mp25-bl31.dtsi b/fdts/stm32mp25-bl31.dtsi
new file mode 100644
index 0000000000..7fc694efb4
--- /dev/null
+++ b/fdts/stm32mp25-bl31.dtsi
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ */
+
+/omit-if-no-ref/ &i2c7_pins_a;
+/omit-if-no-ref/ &ospi_port1_clk_pins_a;
+/omit-if-no-ref/ &ospi_port1_cs0_pins_a;
+/omit-if-no-ref/ &ospi_port1_io03_pins_a;
+/omit-if-no-ref/ &sdmmc1_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_b4_pins_a;
+/omit-if-no-ref/ &sdmmc2_d47_pins_a;
+/omit-if-no-ref/ &usart2_pins_a;
+
+/ {
+	soc@0 {
+		/delete-node/ ommanager@40500000;
+		/delete-node/ memory-controller@48200000;
+		rifsc@42080000 {
+			/delete-node/ mmc@48220000;
+			/delete-node/ mmc@48230000;
+		};
+	};
+};
diff --git a/fdts/stm32mp25-ddr.dtsi b/fdts/stm32mp25-ddr.dtsi
new file mode 100644
index 0000000000..2492bfb062
--- /dev/null
+++ b/fdts/stm32mp25-ddr.dtsi
@@ -0,0 +1,253 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+&ddr{
+	st,mem-name = DDR_MEM_NAME;
+	st,mem-speed = <DDR_MEM_SPEED>;
+	st,mem-size = <(DDR_MEM_SIZE >> 32) (DDR_MEM_SIZE & 0xFFFFFFFF)>;
+
+	st,ctl-reg = <
+		DDR_MSTR
+		DDR_MRCTRL0
+		DDR_MRCTRL1
+		DDR_MRCTRL2
+		DDR_DERATEEN
+		DDR_DERATEINT
+		DDR_DERATECTL
+		DDR_PWRCTL
+		DDR_PWRTMG
+		DDR_HWLPCTL
+		DDR_RFSHCTL0
+		DDR_RFSHCTL1
+		DDR_RFSHCTL3
+		DDR_CRCPARCTL0
+		DDR_CRCPARCTL1
+		DDR_INIT0
+		DDR_INIT1
+		DDR_INIT2
+		DDR_INIT3
+		DDR_INIT4
+		DDR_INIT5
+		DDR_INIT6
+		DDR_INIT7
+		DDR_DIMMCTL
+		DDR_RANKCTL
+		DDR_RANKCTL1
+		DDR_ZQCTL0
+		DDR_ZQCTL1
+		DDR_ZQCTL2
+		DDR_DFITMG0
+		DDR_DFITMG1
+		DDR_DFILPCFG0
+		DDR_DFILPCFG1
+		DDR_DFIUPD0
+		DDR_DFIUPD1
+		DDR_DFIUPD2
+		DDR_DFIMISC
+		DDR_DFITMG2
+		DDR_DFITMG3
+		DDR_DBICTL
+		DDR_DFIPHYMSTR
+		DDR_DBG0
+		DDR_DBG1
+		DDR_DBGCMD
+		DDR_SWCTL
+		DDR_SWCTLSTATIC
+		DDR_POISONCFG
+		DDR_PCCFG
+	>;
+
+	st,ctl-timing = <
+		DDR_RFSHTMG
+		DDR_RFSHTMG1
+		DDR_DRAMTMG0
+		DDR_DRAMTMG1
+		DDR_DRAMTMG2
+		DDR_DRAMTMG3
+		DDR_DRAMTMG4
+		DDR_DRAMTMG5
+		DDR_DRAMTMG6
+		DDR_DRAMTMG7
+		DDR_DRAMTMG8
+		DDR_DRAMTMG9
+		DDR_DRAMTMG10
+		DDR_DRAMTMG11
+		DDR_DRAMTMG12
+		DDR_DRAMTMG13
+		DDR_DRAMTMG14
+		DDR_DRAMTMG15
+		DDR_ODTCFG
+		DDR_ODTMAP
+	>;
+
+	st,ctl-map = <
+		DDR_ADDRMAP0
+		DDR_ADDRMAP1
+		DDR_ADDRMAP2
+		DDR_ADDRMAP3
+		DDR_ADDRMAP4
+		DDR_ADDRMAP5
+		DDR_ADDRMAP6
+		DDR_ADDRMAP7
+		DDR_ADDRMAP8
+		DDR_ADDRMAP9
+		DDR_ADDRMAP10
+		DDR_ADDRMAP11
+	>;
+
+	st,ctl-perf = <
+		DDR_SCHED
+		DDR_SCHED1
+		DDR_PERFHPR1
+		DDR_PERFLPR1
+		DDR_PERFWR1
+		DDR_SCHED3
+		DDR_SCHED4
+		DDR_PCFGR_0
+		DDR_PCFGW_0
+		DDR_PCTRL_0
+		DDR_PCFGQOS0_0
+		DDR_PCFGQOS1_0
+		DDR_PCFGWQOS0_0
+		DDR_PCFGWQOS1_0
+		DDR_PCFGR_1
+		DDR_PCFGW_1
+		DDR_PCTRL_1
+		DDR_PCFGQOS0_1
+		DDR_PCFGQOS1_1
+		DDR_PCFGWQOS0_1
+		DDR_PCFGWQOS1_1
+	>;
+
+	st,phy-basic = <
+		DDR_UIB_DRAMTYPE
+		DDR_UIB_DIMMTYPE
+		DDR_UIB_LP4XMODE
+		DDR_UIB_NUMDBYTE
+		DDR_UIB_NUMACTIVEDBYTEDFI0
+		DDR_UIB_NUMACTIVEDBYTEDFI1
+		DDR_UIB_NUMANIB
+		DDR_UIB_NUMRANK_DFI0
+		DDR_UIB_NUMRANK_DFI1
+		DDR_UIB_DRAMDATAWIDTH
+		DDR_UIB_NUMPSTATES
+		DDR_UIB_FREQUENCY_0
+		DDR_UIB_PLLBYPASS_0
+		DDR_UIB_DFIFREQRATIO_0
+		DDR_UIB_DFI1EXISTS
+		DDR_UIB_TRAIN2D
+		DDR_UIB_HARDMACROVER
+		DDR_UIB_READDBIENABLE_0
+		DDR_UIB_DFIMODE
+	>;
+
+	st,phy-advanced = <
+		DDR_UIA_LP4RXPREAMBLEMODE_0
+		DDR_UIA_LP4POSTAMBLEEXT_0
+		DDR_UIA_D4RXPREAMBLELENGTH_0
+		DDR_UIA_D4TXPREAMBLELENGTH_0
+		DDR_UIA_EXTCALRESVAL
+		DDR_UIA_IS2TTIMING_0
+		DDR_UIA_ODTIMPEDANCE_0
+		DDR_UIA_TXIMPEDANCE_0
+		DDR_UIA_ATXIMPEDANCE
+		DDR_UIA_MEMALERTEN
+		DDR_UIA_MEMALERTPUIMP
+		DDR_UIA_MEMALERTVREFLEVEL
+		DDR_UIA_MEMALERTSYNCBYPASS
+		DDR_UIA_DISDYNADRTRI_0
+		DDR_UIA_PHYMSTRTRAININTERVAL_0
+		DDR_UIA_PHYMSTRMAXREQTOACK_0
+		DDR_UIA_WDQSEXT
+		DDR_UIA_CALINTERVAL
+		DDR_UIA_CALONCE
+		DDR_UIA_LP4RL_0
+		DDR_UIA_LP4WL_0
+		DDR_UIA_LP4WLS_0
+		DDR_UIA_LP4DBIRD_0
+		DDR_UIA_LP4DBIWR_0
+		DDR_UIA_LP4NWR_0
+		DDR_UIA_LP4LOWPOWERDRV
+		DDR_UIA_DRAMBYTESWAP
+		DDR_UIA_RXENBACKOFF
+		DDR_UIA_TRAINSEQUENCECTRL
+		DDR_UIA_SNPSUMCTLOPT
+		DDR_UIA_SNPSUMCTLF0RC5X_0
+		DDR_UIA_TXSLEWRISEDQ_0
+		DDR_UIA_TXSLEWFALLDQ_0
+		DDR_UIA_TXSLEWRISEAC
+		DDR_UIA_TXSLEWFALLAC
+		DDR_UIA_DISABLERETRAINING
+		DDR_UIA_DISABLEPHYUPDATE
+		DDR_UIA_ENABLEHIGHCLKSKEWFIX
+		DDR_UIA_DISABLEUNUSEDADDRLNS
+		DDR_UIA_PHYINITSEQUENCENUM
+		DDR_UIA_ENABLEDFICSPOLARITYFIX
+		DDR_UIA_PHYVREF
+		DDR_UIA_SEQUENCECTRL_0
+	>;
+
+	st,phy-mr = <
+		DDR_UIM_MR0_0
+		DDR_UIM_MR1_0
+		DDR_UIM_MR2_0
+		DDR_UIM_MR3_0
+		DDR_UIM_MR4_0
+		DDR_UIM_MR5_0
+		DDR_UIM_MR6_0
+		DDR_UIM_MR11_0
+		DDR_UIM_MR12_0
+		DDR_UIM_MR13_0
+		DDR_UIM_MR14_0
+		DDR_UIM_MR22_0
+	>;
+
+	st,phy-swizzle = <
+		DDR_UIS_SWIZZLE_0
+		DDR_UIS_SWIZZLE_1
+		DDR_UIS_SWIZZLE_2
+		DDR_UIS_SWIZZLE_3
+		DDR_UIS_SWIZZLE_4
+		DDR_UIS_SWIZZLE_5
+		DDR_UIS_SWIZZLE_6
+		DDR_UIS_SWIZZLE_7
+		DDR_UIS_SWIZZLE_8
+		DDR_UIS_SWIZZLE_9
+		DDR_UIS_SWIZZLE_10
+		DDR_UIS_SWIZZLE_11
+		DDR_UIS_SWIZZLE_12
+		DDR_UIS_SWIZZLE_13
+		DDR_UIS_SWIZZLE_14
+		DDR_UIS_SWIZZLE_15
+		DDR_UIS_SWIZZLE_16
+		DDR_UIS_SWIZZLE_17
+		DDR_UIS_SWIZZLE_18
+		DDR_UIS_SWIZZLE_19
+		DDR_UIS_SWIZZLE_20
+		DDR_UIS_SWIZZLE_21
+		DDR_UIS_SWIZZLE_22
+		DDR_UIS_SWIZZLE_23
+		DDR_UIS_SWIZZLE_24
+		DDR_UIS_SWIZZLE_25
+		DDR_UIS_SWIZZLE_26
+		DDR_UIS_SWIZZLE_27
+		DDR_UIS_SWIZZLE_28
+		DDR_UIS_SWIZZLE_29
+		DDR_UIS_SWIZZLE_30
+		DDR_UIS_SWIZZLE_31
+		DDR_UIS_SWIZZLE_32
+		DDR_UIS_SWIZZLE_33
+		DDR_UIS_SWIZZLE_34
+		DDR_UIS_SWIZZLE_35
+		DDR_UIS_SWIZZLE_36
+		DDR_UIS_SWIZZLE_37
+		DDR_UIS_SWIZZLE_38
+		DDR_UIS_SWIZZLE_39
+		DDR_UIS_SWIZZLE_40
+		DDR_UIS_SWIZZLE_41
+		DDR_UIS_SWIZZLE_42
+		DDR_UIS_SWIZZLE_43
+	>;
+};
diff --git a/fdts/stm32mp25-ddr4-2x16Gbits-2x16bits-1200MHz.dtsi b/fdts/stm32mp25-ddr4-2x16Gbits-2x16bits-1200MHz.dtsi
new file mode 100644
index 0000000000..fc6d90ad38
--- /dev/null
+++ b/fdts/stm32mp25-ddr4-2x16Gbits-2x16bits-1200MHz.dtsi
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022-2024, STMicroelectronics - All Rights Reserved
+ */
+
+/*
+ * STM32MP25 DDR4 board configuration
+ * DDR4 2x16Gbits 2x16bits 1200MHz
+ *
+ * version     2
+ * package     1        Package selection (14x14 and 18x18)
+ * memclk      1200MHz  (2x DFI clock) + range check
+ * Speed_Bin   Worse    from JEDEC
+ * width       32       32: full width / 16: half width
+ * ranks       1        Single or Dual rank
+ * density     16Gbits  (per 16bit device)
+ * Addressing  RBC      row/bank interleaving
+ * RDBI        No       Read DBI
+ */
+
+#define DDR_MEM_NAME	"DDR4 2x16Gbits 2x16bits 1200MHz"
+#define DDR_MEM_SPEED	1200000
+#define DDR_MEM_SIZE	0x100000000
+
+#define DDR_MSTR 0x01040010
+#define DDR_MRCTRL0 0x00000030
+#define DDR_MRCTRL1 0x00000000
+#define DDR_MRCTRL2 0x00000000
+#define DDR_DERATEEN 0x00000000
+#define DDR_DERATEINT 0x00000000
+#define DDR_DERATECTL 0x00000000
+#define DDR_PWRCTL 0x00000000
+#define DDR_PWRTMG 0x00130001
+#define DDR_HWLPCTL 0x00000002
+#define DDR_RFSHCTL0 0x00210010
+#define DDR_RFSHCTL1 0x00000000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x0092014A
+#define DDR_RFSHTMG1 0x008C0000
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_CRCPARCTL1 0x00001000
+#define DDR_INIT0 0xC0020002
+#define DDR_INIT1 0x00010002
+#define DDR_INIT2 0x00000D00
+#define DDR_INIT3 0x09400103
+#define DDR_INIT4 0x00180000
+#define DDR_INIT5 0x00100004
+#define DDR_INIT6 0x00080460
+#define DDR_INIT7 0x00000C16
+#define DDR_DIMMCTL 0x00000000
+#define DDR_RANKCTL 0x0000066F
+#define DDR_RANKCTL1 0x0000000D
+#define DDR_DRAMTMG0 0x11152815
+#define DDR_DRAMTMG1 0x0004051E
+#define DDR_DRAMTMG2 0x0609060D
+#define DDR_DRAMTMG3 0x0050400C
+#define DDR_DRAMTMG4 0x0904050A
+#define DDR_DRAMTMG5 0x06060403
+#define DDR_DRAMTMG6 0x02020005
+#define DDR_DRAMTMG7 0x00000202
+#define DDR_DRAMTMG8 0x0606100B
+#define DDR_DRAMTMG9 0x0002040A
+#define DDR_DRAMTMG10 0x001C180A
+#define DDR_DRAMTMG11 0x4408021C
+#define DDR_DRAMTMG12 0x0C020010
+#define DDR_DRAMTMG13 0x1C200004
+#define DDR_DRAMTMG14 0x000000A0
+#define DDR_DRAMTMG15 0x00000000
+#define DDR_ZQCTL0 0x01000040
+#define DDR_ZQCTL1 0x2000493E
+#define DDR_ZQCTL2 0x00000000
+#define DDR_DFITMG0 0x038F8209
+#define DDR_DFITMG1 0x00080303
+#define DDR_DFILPCFG0 0x07004111
+#define DDR_DFILPCFG1 0x00000000
+#define DDR_DFIUPD0 0xC0300018
+#define DDR_DFIUPD1 0x005700B4
+#define DDR_DFIUPD2 0x80000000
+#define DDR_DFIMISC 0x00000041
+#define DDR_DFITMG2 0x00000F09
+#define DDR_DFITMG3 0x00000000
+#define DDR_DBICTL 0x00000001
+#define DDR_DFIPHYMSTR 0x80000000
+#define DDR_ADDRMAP0 0x0000001F
+#define DDR_ADDRMAP1 0x003F0909
+#define DDR_ADDRMAP2 0x00000700
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x070F0707
+#define DDR_ADDRMAP6 0x07070707
+#define DDR_ADDRMAP7 0x00000F07
+#define DDR_ADDRMAP8 0x00003F01
+#define DDR_ADDRMAP9 0x07070707
+#define DDR_ADDRMAP10 0x07070707
+#define DDR_ADDRMAP11 0x00000007
+#define DDR_ODTCFG 0x06000618
+#define DDR_ODTMAP 0x00000001
+#define DDR_SCHED 0x80001B00
+#define DDR_SCHED1 0x00000000
+#define DDR_PERFHPR1 0x04000200
+#define DDR_PERFLPR1 0x08000080
+#define DDR_PERFWR1 0x08000400
+#define DDR_SCHED3 0x04040208
+#define DDR_SCHED4 0x08400810
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_SWCTL 0x00000000
+#define DDR_SWCTLSTATIC 0x00000000
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000000
+#define DDR_PCFGR_0 0x00704100
+#define DDR_PCFGW_0 0x00004100
+#define DDR_PCTRL_0 0x00000000
+#define DDR_PCFGQOS0_0 0x0021000C
+#define DDR_PCFGQOS1_0 0x01000080
+#define DDR_PCFGWQOS0_0 0x01100C07
+#define DDR_PCFGWQOS1_0 0x04000200
+#define DDR_PCFGR_1 0x00704100
+#define DDR_PCFGW_1 0x00004100
+#define DDR_PCTRL_1 0x00000000
+#define DDR_PCFGQOS0_1 0x00100007
+#define DDR_PCFGQOS1_1 0x01000080
+#define DDR_PCFGWQOS0_1 0x01100C07
+#define DDR_PCFGWQOS1_1 0x04000200
+
+#define DDR_UIB_DRAMTYPE 0x00000000
+#define DDR_UIB_DIMMTYPE 0x00000004
+#define DDR_UIB_LP4XMODE 0x00000000
+#define DDR_UIB_NUMDBYTE 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI0 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI1 0x00000000
+#define DDR_UIB_NUMANIB 0x00000008
+#define DDR_UIB_NUMRANK_DFI0 0x00000001
+#define DDR_UIB_NUMRANK_DFI1 0x00000001
+#define DDR_UIB_DRAMDATAWIDTH 0x00000010
+#define DDR_UIB_NUMPSTATES 0x00000001
+#define DDR_UIB_FREQUENCY_0 0x000004B0
+#define DDR_UIB_PLLBYPASS_0 0x00000000
+#define DDR_UIB_DFIFREQRATIO_0 0x00000001
+#define DDR_UIB_DFI1EXISTS 0x00000001
+#define DDR_UIB_TRAIN2D 0x00000000
+#define DDR_UIB_HARDMACROVER 0x00000003
+#define DDR_UIB_READDBIENABLE_0 0x00000000
+#define DDR_UIB_DFIMODE 0x00000000
+
+#define DDR_UIA_LP4RXPREAMBLEMODE_0 0x00000000
+#define DDR_UIA_LP4POSTAMBLEEXT_0 0x00000000
+#define DDR_UIA_D4RXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_D4TXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_EXTCALRESVAL 0x00000000
+#define DDR_UIA_IS2TTIMING_0 0x00000000
+#define DDR_UIA_ODTIMPEDANCE_0 0x00000035
+#define DDR_UIA_TXIMPEDANCE_0 0x00000028
+#define DDR_UIA_ATXIMPEDANCE 0x00000028
+#define DDR_UIA_MEMALERTEN 0x00000000
+#define DDR_UIA_MEMALERTPUIMP 0x00000000
+#define DDR_UIA_MEMALERTVREFLEVEL 0x00000000
+#define DDR_UIA_MEMALERTSYNCBYPASS 0x00000000
+#define DDR_UIA_DISDYNADRTRI_0 0x00000001
+#define DDR_UIA_PHYMSTRTRAININTERVAL_0 0x00000000
+#define DDR_UIA_PHYMSTRMAXREQTOACK_0 0x00000000
+#define DDR_UIA_WDQSEXT 0x00000000
+#define DDR_UIA_CALINTERVAL 0x00000009
+#define DDR_UIA_CALONCE 0x00000000
+#define DDR_UIA_LP4RL_0 0x00000000
+#define DDR_UIA_LP4WL_0 0x00000000
+#define DDR_UIA_LP4WLS_0 0x00000000
+#define DDR_UIA_LP4DBIRD_0 0x00000000
+#define DDR_UIA_LP4DBIWR_0 0x00000000
+#define DDR_UIA_LP4NWR_0 0x00000000
+#define DDR_UIA_LP4LOWPOWERDRV 0x00000000
+#define DDR_UIA_DRAMBYTESWAP 0x00000000
+#define DDR_UIA_RXENBACKOFF 0x00000000
+#define DDR_UIA_TRAINSEQUENCECTRL 0x00000000
+#define DDR_UIA_SNPSUMCTLOPT 0x00000000
+#define DDR_UIA_SNPSUMCTLF0RC5X_0 0x00000000
+#define DDR_UIA_TXSLEWRISEDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWFALLDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWRISEAC 0x0000000F
+#define DDR_UIA_TXSLEWFALLAC 0x0000000F
+#define DDR_UIA_DISABLERETRAINING 0x00000001
+#define DDR_UIA_DISABLEPHYUPDATE 0x00000000
+#define DDR_UIA_ENABLEHIGHCLKSKEWFIX 0x00000000
+#define DDR_UIA_DISABLEUNUSEDADDRLNS 0x00000001
+#define DDR_UIA_PHYINITSEQUENCENUM 0x00000000
+#define DDR_UIA_ENABLEDFICSPOLARITYFIX 0x00000000
+#define DDR_UIA_PHYVREF 0x0000005E
+#define DDR_UIA_SEQUENCECTRL_0 0x0000031F
+
+#define DDR_UIM_MR0_0 0x00000940
+#define DDR_UIM_MR1_0 0x00000103
+#define DDR_UIM_MR2_0 0x00000018
+#define DDR_UIM_MR3_0 0x00000000
+#define DDR_UIM_MR4_0 0x00000008
+#define DDR_UIM_MR5_0 0x00000460
+#define DDR_UIM_MR6_0 0x00000C16
+#define DDR_UIM_MR11_0 0x00000000
+#define DDR_UIM_MR12_0 0x00000000
+#define DDR_UIM_MR13_0 0x00000000
+#define DDR_UIM_MR14_0 0x00000000
+#define DDR_UIM_MR22_0 0x00000000
+
+#define DDR_UIS_SWIZZLE_0 0x0000000C
+#define DDR_UIS_SWIZZLE_1 0x00000005
+#define DDR_UIS_SWIZZLE_2 0x00000013
+#define DDR_UIS_SWIZZLE_3 0x0000001A
+#define DDR_UIS_SWIZZLE_4 0x00000009
+#define DDR_UIS_SWIZZLE_5 0x00000003
+#define DDR_UIS_SWIZZLE_6 0x00000001
+#define DDR_UIS_SWIZZLE_7 0x00000019
+#define DDR_UIS_SWIZZLE_8 0x00000007
+#define DDR_UIS_SWIZZLE_9 0x00000004
+#define DDR_UIS_SWIZZLE_10 0x0000000A
+#define DDR_UIS_SWIZZLE_11 0x0000000D
+#define DDR_UIS_SWIZZLE_12 0x00000014
+#define DDR_UIS_SWIZZLE_13 0x00000000
+#define DDR_UIS_SWIZZLE_14 0x00000000
+#define DDR_UIS_SWIZZLE_15 0x00000000
+#define DDR_UIS_SWIZZLE_16 0x00000000
+#define DDR_UIS_SWIZZLE_17 0x00000000
+#define DDR_UIS_SWIZZLE_18 0x00000006
+#define DDR_UIS_SWIZZLE_19 0x0000000B
+#define DDR_UIS_SWIZZLE_20 0x00000000
+#define DDR_UIS_SWIZZLE_21 0x00000000
+#define DDR_UIS_SWIZZLE_22 0x00000000
+#define DDR_UIS_SWIZZLE_23 0x00000008
+#define DDR_UIS_SWIZZLE_24 0x00000002
+#define DDR_UIS_SWIZZLE_25 0x00000018
+#define DDR_UIS_SWIZZLE_26 0x1A13050C
+#define DDR_UIS_SWIZZLE_27 0x19010309
+#define DDR_UIS_SWIZZLE_28 0x0D0A0407
+#define DDR_UIS_SWIZZLE_29 0x00000014
+#define DDR_UIS_SWIZZLE_30 0x000B0600
+#define DDR_UIS_SWIZZLE_31 0x02080000
+#define DDR_UIS_SWIZZLE_32 0x00000018
+#define DDR_UIS_SWIZZLE_33 0x00000000
+#define DDR_UIS_SWIZZLE_34 0x00000000
+#define DDR_UIS_SWIZZLE_35 0x00000000
+#define DDR_UIS_SWIZZLE_36 0x00000000
+#define DDR_UIS_SWIZZLE_37 0x00000000
+#define DDR_UIS_SWIZZLE_38 0x00000000
+#define DDR_UIS_SWIZZLE_39 0x00000000
+#define DDR_UIS_SWIZZLE_40 0x00000000
+#define DDR_UIS_SWIZZLE_41 0x00000000
+#define DDR_UIS_SWIZZLE_42 0x00000000
+#define DDR_UIS_SWIZZLE_43 0x00000000
+
+#include "stm32mp25-ddr.dtsi"
diff --git a/fdts/stm32mp25-fw-config.dtsi b/fdts/stm32mp25-fw-config.dtsi
new file mode 100644
index 0000000000..27f20fc9e0
--- /dev/null
+++ b/fdts/stm32mp25-fw-config.dtsi
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common/tbbr/tbbr_img_def.h>
+
+#include <platform_def.h>
+
+/dts-v1/;
+
+/ {
+	dtb-registry {
+		compatible = "fconf,dyn_cfg-dtb_registry";
+
+		hw-config {
+			load-address = <0x0 STM32MP_HW_CONFIG_BASE>;
+			max-size = <STM32MP_HW_CONFIG_MAX_SIZE>;
+			id = <HW_CONFIG_ID>;
+		};
+
+		nt_fw {
+			load-address = <0x0 STM32MP_BL33_BASE>;
+			max-size = <STM32MP_BL33_MAX_SIZE>;
+			id = <BL33_IMAGE_ID>;
+		};
+
+		soc_fw {
+			load-address = <0x0 STM32MP_SYSRAM_BASE>;
+			max-size = <STM32MP_BL31_SIZE>;
+			id = <BL31_IMAGE_ID>;
+		};
+
+		soc_fw-config {
+			id = <SOC_FW_CONFIG_ID>;
+		};
+
+		tos_fw {
+			id = <BL32_IMAGE_ID>;
+		};
+	};
+
+	st-mem-firewall {
+		compatible = "st,stm32mp2-mem-firewall";
+		#address-cells = <2>;
+		#size-cells = <2>;
+	};
+};
diff --git a/fdts/stm32mp25-lpddr4-1x32Gbits-1x32bits-1200MHz.dtsi b/fdts/stm32mp25-lpddr4-1x32Gbits-1x32bits-1200MHz.dtsi
new file mode 100644
index 0000000000..62901d5b7b
--- /dev/null
+++ b/fdts/stm32mp25-lpddr4-1x32Gbits-1x32bits-1200MHz.dtsi
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022-2024, STMicroelectronics - All Rights Reserved
+ */
+
+/*
+ * STM32MP25 LPDDR4 board configuration
+ * LPDDR4 1x32Gbits 1x32bits 1200MHz
+ *
+ * version       2
+ * memclk        1200MHz  (2x DFI clock)
+ * width         32       32: full width / 16: half width
+ * ranks         1        Single or Dual rank
+ * density       16Gbits  (per 16bit channel)
+ * Addressing    RBC      row/bank interleaving
+ * DBI-RD        No       Read DBI
+ * DBI-WR        No       Write DBI
+ * RPST          1.5      Read postamble (ck)
+ * Per_bank_ref  Yes
+ */
+
+#define DDR_MEM_NAME	"LPDDR4 1x32Gbits 1x32bits 1200MHz"
+#define DDR_MEM_SPEED	1200000
+#define DDR_MEM_SIZE	0x100000000
+
+#define DDR_MSTR 0x01080020
+#define DDR_MRCTRL0 0x00000030
+#define DDR_MRCTRL1 0x00000000
+#define DDR_MRCTRL2 0x00000000
+#define DDR_DERATEEN 0x00000203
+#define DDR_DERATEINT 0x0124F800
+#define DDR_DERATECTL 0x00000000
+#define DDR_PWRCTL 0x00000100
+#define DDR_PWRTMG 0x00130001
+#define DDR_HWLPCTL 0x00000002
+#define DDR_RFSHCTL0 0x00210014
+#define DDR_RFSHCTL1 0x00000000
+#define DDR_RFSHCTL3 0x00000000
+#define DDR_RFSHTMG 0x81240072
+#define DDR_RFSHTMG1 0x00360000
+#define DDR_CRCPARCTL0 0x00000000
+#define DDR_CRCPARCTL1 0x00001000
+#define DDR_INIT0 0xC0020002
+#define DDR_INIT1 0x00010002
+#define DDR_INIT2 0x00000D00
+#define DDR_INIT3 0x00C40024
+#define DDR_INIT4 0x00310008
+#define DDR_INIT5 0x00100004
+#define DDR_INIT6 0x00660047
+#define DDR_INIT7 0x00050047
+#define DDR_DIMMCTL 0x00000000
+#define DDR_RANKCTL 0x0000066F
+#define DDR_RANKCTL1 0x00000011
+#define DDR_DRAMTMG0 0x1718141A
+#define DDR_DRAMTMG1 0x00050524
+#define DDR_DRAMTMG2 0x060C1111
+#define DDR_DRAMTMG3 0x0090900C
+#define DDR_DRAMTMG4 0x0B04060B
+#define DDR_DRAMTMG5 0x02030909
+#define DDR_DRAMTMG6 0x02020007
+#define DDR_DRAMTMG7 0x00000302
+#define DDR_DRAMTMG8 0x03034405
+#define DDR_DRAMTMG9 0x0004040D
+#define DDR_DRAMTMG10 0x001C180A
+#define DDR_DRAMTMG11 0x440C021C
+#define DDR_DRAMTMG12 0x1A020010
+#define DDR_DRAMTMG13 0x0B100002
+#define DDR_DRAMTMG14 0x000000E9
+#define DDR_DRAMTMG15 0x00000000
+#define DDR_ZQCTL0 0x02580012
+#define DDR_ZQCTL1 0x01E0493E
+#define DDR_ZQCTL2 0x00000000
+#define DDR_DFITMG0 0x0395820A
+#define DDR_DFITMG1 0x000A0303
+#define DDR_DFILPCFG0 0x07F04111
+#define DDR_DFILPCFG1 0x000000F0
+#define DDR_DFIUPD0 0x4040000C
+#define DDR_DFIUPD1 0x0040007F
+#define DDR_DFIUPD2 0x00000000
+#define DDR_DFIMISC 0x00000041
+#define DDR_DFITMG2 0x0000150A
+#define DDR_DFITMG3 0x00000000
+#define DDR_DBICTL 0x00000001
+#define DDR_DFIPHYMSTR 0x80000001
+#define DDR_ADDRMAP0 0x0000001F
+#define DDR_ADDRMAP1 0x00080808
+#define DDR_ADDRMAP2 0x00000000
+#define DDR_ADDRMAP3 0x00000000
+#define DDR_ADDRMAP4 0x00001F1F
+#define DDR_ADDRMAP5 0x070F0707
+#define DDR_ADDRMAP6 0x07070707
+#define DDR_ADDRMAP7 0x00000F07
+#define DDR_ADDRMAP8 0x00003F3F
+#define DDR_ADDRMAP9 0x07070707
+#define DDR_ADDRMAP10 0x07070707
+#define DDR_ADDRMAP11 0x00000007
+#define DDR_ODTCFG 0x04000400
+#define DDR_ODTMAP 0x00000000
+#define DDR_SCHED 0x80001B00
+#define DDR_SCHED1 0x00000000
+#define DDR_PERFHPR1 0x04000200
+#define DDR_PERFLPR1 0x08000080
+#define DDR_PERFWR1 0x08000400
+#define DDR_SCHED3 0x04040208
+#define DDR_SCHED4 0x08400810
+#define DDR_DBG0 0x00000000
+#define DDR_DBG1 0x00000000
+#define DDR_DBGCMD 0x00000000
+#define DDR_SWCTL 0x00000000
+#define DDR_SWCTLSTATIC 0x00000000
+#define DDR_POISONCFG 0x00000000
+#define DDR_PCCFG 0x00000000
+#define DDR_PCFGR_0 0x00704100
+#define DDR_PCFGW_0 0x00004100
+#define DDR_PCTRL_0 0x00000000
+#define DDR_PCFGQOS0_0 0x0021000C
+#define DDR_PCFGQOS1_0 0x01000080
+#define DDR_PCFGWQOS0_0 0x01100C07
+#define DDR_PCFGWQOS1_0 0x04000200
+#define DDR_PCFGR_1 0x00704100
+#define DDR_PCFGW_1 0x00004100
+#define DDR_PCTRL_1 0x00000000
+#define DDR_PCFGQOS0_1 0x00100007
+#define DDR_PCFGQOS1_1 0x01000080
+#define DDR_PCFGWQOS0_1 0x01100C07
+#define DDR_PCFGWQOS1_1 0x04000200
+
+#define DDR_UIB_DRAMTYPE 0x00000002
+#define DDR_UIB_DIMMTYPE 0x00000004
+#define DDR_UIB_LP4XMODE 0x00000000
+#define DDR_UIB_NUMDBYTE 0x00000004
+#define DDR_UIB_NUMACTIVEDBYTEDFI0 0x00000002
+#define DDR_UIB_NUMACTIVEDBYTEDFI1 0x00000002
+#define DDR_UIB_NUMANIB 0x00000008
+#define DDR_UIB_NUMRANK_DFI0 0x00000001
+#define DDR_UIB_NUMRANK_DFI1 0x00000001
+#define DDR_UIB_DRAMDATAWIDTH 0x00000010
+#define DDR_UIB_NUMPSTATES 0x00000001
+#define DDR_UIB_FREQUENCY_0 0x000004B0
+#define DDR_UIB_PLLBYPASS_0 0x00000000
+#define DDR_UIB_DFIFREQRATIO_0 0x00000001
+#define DDR_UIB_DFI1EXISTS 0x00000001
+#define DDR_UIB_TRAIN2D 0x00000000
+#define DDR_UIB_HARDMACROVER 0x00000003
+#define DDR_UIB_READDBIENABLE_0 0x00000000
+#define DDR_UIB_DFIMODE 0x00000000
+
+#define DDR_UIA_LP4RXPREAMBLEMODE_0 0x00000000
+#define DDR_UIA_LP4POSTAMBLEEXT_0 0x00000001
+#define DDR_UIA_D4RXPREAMBLELENGTH_0 0x00000001
+#define DDR_UIA_D4TXPREAMBLELENGTH_0 0x00000000
+#define DDR_UIA_EXTCALRESVAL 0x00000000
+#define DDR_UIA_IS2TTIMING_0 0x00000000
+#define DDR_UIA_ODTIMPEDANCE_0 0x00000035
+#define DDR_UIA_TXIMPEDANCE_0 0x00000028
+#define DDR_UIA_ATXIMPEDANCE 0x00000028
+#define DDR_UIA_MEMALERTEN 0x00000000
+#define DDR_UIA_MEMALERTPUIMP 0x00000000
+#define DDR_UIA_MEMALERTVREFLEVEL 0x00000000
+#define DDR_UIA_MEMALERTSYNCBYPASS 0x00000000
+#define DDR_UIA_DISDYNADRTRI_0 0x00000001
+#define DDR_UIA_PHYMSTRTRAININTERVAL_0 0x0000000A
+#define DDR_UIA_PHYMSTRMAXREQTOACK_0 0x00000005
+#define DDR_UIA_WDQSEXT 0x00000000
+#define DDR_UIA_CALINTERVAL 0x00000009
+#define DDR_UIA_CALONCE 0x00000000
+#define DDR_UIA_LP4RL_0 0x00000004
+#define DDR_UIA_LP4WL_0 0x00000004
+#define DDR_UIA_LP4WLS_0 0x00000000
+#define DDR_UIA_LP4DBIRD_0 0x00000000
+#define DDR_UIA_LP4DBIWR_0 0x00000000
+#define DDR_UIA_LP4NWR_0 0x00000004
+#define DDR_UIA_LP4LOWPOWERDRV 0x00000000
+#define DDR_UIA_DRAMBYTESWAP 0x00000000
+#define DDR_UIA_RXENBACKOFF 0x00000000
+#define DDR_UIA_TRAINSEQUENCECTRL 0x00000000
+#define DDR_UIA_SNPSUMCTLOPT 0x00000000
+#define DDR_UIA_SNPSUMCTLF0RC5X_0 0x00000000
+#define DDR_UIA_TXSLEWRISEDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWFALLDQ_0 0x0000000F
+#define DDR_UIA_TXSLEWRISEAC 0x0000000F
+#define DDR_UIA_TXSLEWFALLAC 0x0000000F
+#define DDR_UIA_DISABLERETRAINING 0x00000000
+#define DDR_UIA_DISABLEPHYUPDATE 0x00000001
+#define DDR_UIA_ENABLEHIGHCLKSKEWFIX 0x00000000
+#define DDR_UIA_DISABLEUNUSEDADDRLNS 0x00000001
+#define DDR_UIA_PHYINITSEQUENCENUM 0x00000000
+#define DDR_UIA_ENABLEDFICSPOLARITYFIX 0x00000000
+#define DDR_UIA_PHYVREF 0x00000014
+#define DDR_UIA_SEQUENCECTRL_0 0x0000131F
+
+#define DDR_UIM_MR0_0 0x00000000
+#define DDR_UIM_MR1_0 0x000000C4
+#define DDR_UIM_MR2_0 0x00000024
+#define DDR_UIM_MR3_0 0x00000031
+#define DDR_UIM_MR4_0 0x00000000
+#define DDR_UIM_MR5_0 0x00000000
+#define DDR_UIM_MR6_0 0x00000000
+#define DDR_UIM_MR11_0 0x00000066
+#define DDR_UIM_MR12_0 0x00000047
+#define DDR_UIM_MR13_0 0x00000008
+#define DDR_UIM_MR14_0 0x00000047
+#define DDR_UIM_MR22_0 0x00000005
+
+#define DDR_UIS_SWIZZLE_0 0x00000003
+#define DDR_UIS_SWIZZLE_1 0x00000002
+#define DDR_UIS_SWIZZLE_2 0x00000000
+#define DDR_UIS_SWIZZLE_3 0x00000001
+#define DDR_UIS_SWIZZLE_4 0x00000006
+#define DDR_UIS_SWIZZLE_5 0x00000007
+#define DDR_UIS_SWIZZLE_6 0x00000005
+#define DDR_UIS_SWIZZLE_7 0x00000004
+#define DDR_UIS_SWIZZLE_8 0x00000005
+#define DDR_UIS_SWIZZLE_9 0x00000004
+#define DDR_UIS_SWIZZLE_10 0x00000007
+#define DDR_UIS_SWIZZLE_11 0x00000006
+#define DDR_UIS_SWIZZLE_12 0x00000000
+#define DDR_UIS_SWIZZLE_13 0x00000003
+#define DDR_UIS_SWIZZLE_14 0x00000002
+#define DDR_UIS_SWIZZLE_15 0x00000001
+#define DDR_UIS_SWIZZLE_16 0x00000005
+#define DDR_UIS_SWIZZLE_17 0x00000007
+#define DDR_UIS_SWIZZLE_18 0x00000006
+#define DDR_UIS_SWIZZLE_19 0x00000004
+#define DDR_UIS_SWIZZLE_20 0x00000000
+#define DDR_UIS_SWIZZLE_21 0x00000001
+#define DDR_UIS_SWIZZLE_22 0x00000003
+#define DDR_UIS_SWIZZLE_23 0x00000002
+#define DDR_UIS_SWIZZLE_24 0x00000007
+#define DDR_UIS_SWIZZLE_25 0x00000004
+#define DDR_UIS_SWIZZLE_26 0x00000005
+#define DDR_UIS_SWIZZLE_27 0x00000006
+#define DDR_UIS_SWIZZLE_28 0x00000002
+#define DDR_UIS_SWIZZLE_29 0x00000003
+#define DDR_UIS_SWIZZLE_30 0x00000001
+#define DDR_UIS_SWIZZLE_31 0x00000000
+#define DDR_UIS_SWIZZLE_32 0x00000000
+#define DDR_UIS_SWIZZLE_33 0x00000001
+#define DDR_UIS_SWIZZLE_34 0x00000002
+#define DDR_UIS_SWIZZLE_35 0x00000003
+#define DDR_UIS_SWIZZLE_36 0x00000004
+#define DDR_UIS_SWIZZLE_37 0x00000005
+#define DDR_UIS_SWIZZLE_38 0x00000000
+#define DDR_UIS_SWIZZLE_39 0x00000001
+#define DDR_UIS_SWIZZLE_40 0x00000002
+#define DDR_UIS_SWIZZLE_41 0x00000003
+#define DDR_UIS_SWIZZLE_42 0x00000004
+#define DDR_UIS_SWIZZLE_43 0x00000005
+
+#include "stm32mp25-ddr.dtsi"
diff --git a/fdts/stm32mp25-pinctrl.dtsi b/fdts/stm32mp25-pinctrl.dtsi
new file mode 100644
index 0000000000..bd4bd8870d
--- /dev/null
+++ b/fdts/stm32mp25-pinctrl.dtsi
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	i2c7_pins_a: i2c7-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 15, AF10)>, /* I2C7_SCL */
+				 <STM32_PINMUX('D', 14, AF10)>; /* I2C7_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_clk_pins_a: ospi-port1-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, AF10)>; /* OSPI1_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	ospi_port1_cs0_pins_a: ospi-port1-cs0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, AF10)>; /* OSPI_NCS0 */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_io03_pins_a: ospi-port1-io03-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF10)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, AF10)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, AF10)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, AF10)>; /* OSPI_IO3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+};
diff --git a/fdts/stm32mp251.dtsi b/fdts/stm32mp251.dtsi
new file mode 100644
index 0000000000..ed84043897
--- /dev/null
+++ b/fdts/stm32mp251.dtsi
@@ -0,0 +1,675 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include <dt-bindings/clock/stm32mp25-clks.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/reset/stm32mp25-resets.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+		};
+
+		domain-idle-states {
+			stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000011>;
+			};
+
+			lp-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000021>;
+			};
+
+			lplv-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000211>;
+			};
+
+			stop2 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x40001333>;
+			};
+
+			lp-stop2 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x40002333>;
+			};
+
+			lplv-stop2 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x40023333>;
+			};
+
+			standby {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x40033333>;
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x0 0x4ac10000 0x0 0x1000>,
+		      <0x0 0x4ac20000 0x0 0x2000>,
+		      <0x0 0x4ac40000 0x0 0x2000>,
+		      <0x0 0x4ac60000 0x0 0x2000>;
+	};
+
+	timer: timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+		always-on;
+	};
+
+	clocks {
+		clk_hse: clk-hse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <48000000>;
+		};
+
+		clk_hsi: clk-hsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+
+		clk_lse: clk-lse {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+		};
+
+		clk_lsi: clk-lsi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32000>;
+		};
+
+		clk_msi: clk-msi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <16000000>;
+		};
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x80000000>;
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			status = "disabled";
+
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				clocks = <&rcc CK_KER_OSPI1>;
+				resets = <&rcc OSPI1_R>, <&rcc OSPI1DLL_R>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				clocks = <&rcc CK_KER_OSPI2>;
+				resets = <&rcc OSPI2_R>, <&rcc OSPI2DLL_R>;
+				status = "disabled";
+			};
+		};
+
+		rifsc: rifsc@42080000 {
+			compatible = "st,stm32mp25-rifsc", "syscon";
+			reg = <0x42080000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			usart2: serial@400e0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400e0000 0x400>;
+				clocks = <&rcc CK_KER_USART2>;
+				resets = <&rcc USART2_R>;
+				status = "disabled";
+			};
+
+			usart3: serial@400f0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400f0000 0x400>;
+				clocks = <&rcc CK_KER_USART3>;
+				resets = <&rcc USART3_R>;
+				status = "disabled";
+			};
+
+			uart4: serial@40100000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40100000 0x400>;
+				clocks = <&rcc CK_KER_UART4>;
+				resets = <&rcc UART4_R>;
+				status = "disabled";
+			};
+
+			uart5: serial@40110000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40110000 0x400>;
+				clocks = <&rcc CK_KER_UART5>;
+				resets = <&rcc UART5_R>;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40120000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40120000 0x400>;
+				clocks = <&rcc CK_KER_I2C1>;
+				resets = <&rcc I2C1_R>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40130000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40130000 0x400>;
+				clocks = <&rcc CK_KER_I2C2>;
+				resets = <&rcc I2C2_R>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40140000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40140000 0x400>;
+				clocks = <&rcc CK_KER_I2C3>;
+				resets = <&rcc I2C3_R>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@40150000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40150000 0x400>;
+				clocks = <&rcc CK_KER_I2C4>;
+				resets = <&rcc I2C4_R>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40160000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40160000 0x400>;
+				clocks = <&rcc CK_KER_I2C5>;
+				resets = <&rcc I2C5_R>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@40170000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40170000 0x400>;
+				clocks = <&rcc CK_KER_I2C6>;
+				resets = <&rcc I2C6_R>;
+				status = "disabled";
+			};
+
+			i2c7: i2c@40180000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40180000 0x400>;
+				clocks = <&rcc CK_KER_I2C7>;
+				resets = <&rcc I2C7_R>;
+				status = "disabled";
+			};
+
+			usart6: serial@40220000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40220000 0x400>;
+				clocks = <&rcc CK_KER_USART6>;
+				resets = <&rcc USART6_R>;
+				status = "disabled";
+			};
+
+			uart9: serial@402c0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x402c0000 0x400>;
+				clocks = <&rcc CK_KER_UART9>;
+				resets = <&rcc UART9_R>;
+				status = "disabled";
+			};
+
+			usart1: serial@40330000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40330000 0x400>;
+				clocks = <&rcc CK_KER_USART1>;
+				resets = <&rcc USART1_R>;
+				status = "disabled";
+			};
+
+			uart7: serial@40370000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40370000 0x400>;
+				clocks = <&rcc CK_KER_UART7>;
+				resets = <&rcc UART7_R>;
+				status = "disabled";
+			};
+
+			uart8: serial@40380000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40380000 0x400>;
+				clocks = <&rcc CK_KER_UART8>;
+				resets = <&rcc UART8_R>;
+				status = "disabled";
+			};
+
+			hash: hash@42010000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x42010000 0x400>;
+				clocks = <&rcc CK_BUS_HASH>;
+				resets = <&rcc HASH_R>;
+				status = "disabled";
+			};
+
+			rng: rng@42020000 {
+				compatible = "st,stm32mp13-rng";
+				reg = <0x42020000 0x400>;
+				clocks = <&rcc CK_BUS_RNG>;
+				resets = <&rcc RNG_R>;
+				status = "disabled";
+			};
+
+			iwdg1: watchdog@44010000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44010000 0x400>;
+				clocks = <&rcc CK_BUS_IWDG1>, <&rcc LSI_CK>;
+				clock-names = "pclk", "lsi";
+				status = "disabled";
+			};
+
+			iwdg2: watchdog@44020000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44020000 0x400>;
+				clocks = <&rcc CK_BUS_IWDG2>, <&rcc LSI_CK>;
+				clock-names = "pclk", "lsi";
+				status = "disabled";
+			};
+
+			i2c8: i2c@46040000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x46040000 0x400>;
+				clocks = <&rcc CK_KER_I2C8>;
+				resets = <&rcc I2C8_R>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@48220000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48220000 0x400>, <0x44230400 0x8>;
+				clocks = <&rcc CK_KER_SDMMC1>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@48230000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48230000 0x400>, <0x44230800 0x8>;
+				clocks = <&rcc CK_KER_SDMMC2>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				status = "disabled";
+			};
+		};
+
+		risaf2: risaf@420b0000 {
+			compatible = "st,stm32-risaf";
+			reg = <0x420b0000 0x1000>;
+			clocks = <&rcc CK_KER_OSPI1>;
+			status = "disabled";
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32-risaf";
+			reg = <0x420d0000 0x1000>;
+			clocks = <&rcc CK_BUS_RISAF4>;
+			status = "disabled";
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			uid_otp@14 {
+				reg = <0x14 0xc>;
+			};
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+			nand_otp: otp16@40 {
+				reg = <0x40 0x4>;
+			};
+			lifecycle2_otp: otp18@48 {
+				reg = <0x48 0x4>;
+			};
+			nand2_otp: otp20@50 {
+				reg = <0x50 0x4>;
+			};
+			rev_otp@198 {
+				reg = <0x198 0x4>;
+			};
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+			};
+			hconf1_otp: otp124@1f0 {
+				reg = <0x1f0 0x4>;
+			};
+			pkh_otp: otp144@240 {
+				reg = <0x240 0x20>;
+			};
+			oem_fip_enc_key: otp260@410 {
+				reg = <0x410 0x20>;
+			};
+		};
+
+		rcc: rcc@44200000 {
+			compatible = "st,stm32mp25-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		pwr: pwr@44210000 {
+			compatible = "st,stm32mp25-pwr";
+			reg = <0x44210000 0x400>;
+
+			vddio1: vddio1 {
+				regulator-name = "vddio1";
+			};
+
+			vddio2: vddio2 {
+				regulator-name = "vddio2";
+			};
+
+			vddio3: vddio3 {
+				regulator-name = "vddio3";
+			};
+
+			vddio4: vddio4 {
+				regulator-name = "vddio4";
+			};
+
+			vddio: vddio {
+				regulator-name = "vddio";
+			};
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp";
+			reg = <0x46010000 0x400>;
+			clocks = <&rcc CK_BUS_RTC>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			nvram: nvram@46010100 {
+				compatible = "st,stm32mp25-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x46010100 0x200>;
+
+				stop2_entrypoint: tamp-bkp@2c {
+					reg = <0x2c 0x4>;
+				};
+				fwu_info: tamp-bkp@c0 {
+					/* see firmware update info feature */
+					reg = <0xc0 0x4>;
+				};
+				boot_mode: tamp-bkp@180 {
+					reg = <0x180 0x4>;
+				};
+
+			};
+
+			boot_info: boot-info {
+				compatible = "st,stm32mp-bootinfo";
+				nvmem-cells = <&boot_mode>, <&fwu_info>, <&stop2_entrypoint>;
+				nvmem-cell-names = "boot-mode", "fwu-info", "stop2-entrypoint";
+			};
+		};
+
+		ddr: ddr@48040000 {
+			compatible = "st,stm32mp2-ddr";
+			reg = <0x48040000 0x10000>,
+			      <0x48c00000 0x400000>;
+			status = "okay";
+		};
+
+		fmc: memory-controller@48200000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			clocks = <&rcc CK_KER_FMC>;
+			resets = <&rcc FMC_R>;
+			status = "disabled";
+
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+
+			nand-controller@4,0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				status = "disabled";
+			};
+		};
+
+		/*
+		 * Break node order to solve dependency probe issue between
+		 * pinctrl and exti.
+		 */
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			pins-are-numbered;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc CK_BUS_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&rcc CK_BUS_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			pins-are-numbered;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&rcc CK_BUS_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+
+		};
+	};
+};
diff --git a/fdts/stm32mp253.dtsi b/fdts/stm32mp253.dtsi
new file mode 100644
index 0000000000..2033dd6677
--- /dev/null
+++ b/fdts/stm32mp253.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp251.dtsi"
diff --git a/fdts/stm32mp255.dtsi b/fdts/stm32mp255.dtsi
new file mode 100644
index 0000000000..3602b9e5b8
--- /dev/null
+++ b/fdts/stm32mp255.dtsi
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp253.dtsi"
+
+/ {
+};
diff --git a/fdts/stm32mp257.dtsi b/fdts/stm32mp257.dtsi
new file mode 100644
index 0000000000..3ab7cabfca
--- /dev/null
+++ b/fdts/stm32mp257.dtsi
@@ -0,0 +1,9 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp255.dtsi"
+
+/ {
+};
diff --git a/fdts/stm32mp257f-dk-ca35tdcid-fw-config.dtsi b/fdts/stm32mp257f-dk-ca35tdcid-fw-config.dtsi
new file mode 100644
index 0000000000..9b05f0095f
--- /dev/null
+++ b/fdts/stm32mp257f-dk-ca35tdcid-fw-config.dtsi
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+
+/*
+ * STM32MP25 tf-a firmware config
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 3/6/2024 11:20:07 AM
+ */
+
+/ {
+	dtb-registry {
+		soc_fw-config {
+			load-address = <0x0 0x81fc0000>;
+			max-size = <0x40000>;
+		};
+		tos_fw {
+			load-address = <0x0 0x82000000>;
+			max-size = <0x2000000>;
+		};
+	};
+
+	st-mem-firewall {
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			st,protreg = <RISAFPROT(RISAF_REG_ID(7), RIF_CID0_BF|RIF_CID1_BF, RIF_CID0_BF|RIF_CID1_BF, RIF_CID1_BF, RIF_SEC, RIF_ENC_EN, RIF_BREN_EN)>;
+		};
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			st,protreg = <RISAFPROT(RISAF_REG_ID(8), RIF_CID0_BF|RIF_CID1_BF, RIF_CID0_BF|RIF_CID1_BF, 0, RIF_SEC, RIF_ENC_EN, RIF_BREN_EN)>;
+		};
+	};
+};
diff --git a/fdts/stm32mp257f-dk-ca35tdcid-rcc.dtsi b/fdts/stm32mp257f-dk-ca35tdcid-rcc.dtsi
new file mode 100644
index 0000000000..837abb43f3
--- /dev/null
+++ b/fdts/stm32mp257f-dk-ca35tdcid-rcc.dtsi
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 Clock tree device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 3/6/2024 11:20:05 AM
+ */
+
+&clk_hse {
+	clock-frequency = <40000000>;
+};
+
+&clk_hsi {
+	clock-frequency = <64000000>;
+};
+
+&clk_lse {
+	clock-frequency = <32768>;
+};
+
+&clk_lsi {
+	clock-frequency = <32000>;
+};
+
+&clk_msi {
+	clock-frequency = <16000000>;
+};
+
+&rcc {
+	st,busclk = <
+		DIV_CFG(DIV_LSMCU, 1)
+		DIV_CFG(DIV_APB1, 0)
+		DIV_CFG(DIV_APB2, 0)
+		DIV_CFG(DIV_APB3, 0)
+		DIV_CFG(DIV_APB4, 0)
+		DIV_CFG(DIV_APBDBG, 0)
+	>;
+
+	st,flexgen = <
+		FLEXGEN_CFG(0, XBAR_SRC_PLL4, 0, 2)
+		FLEXGEN_CFG(1, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(2, XBAR_SRC_PLL4, 0, 1)
+		FLEXGEN_CFG(4, XBAR_SRC_PLL4, 0, 3)
+		FLEXGEN_CFG(5, XBAR_SRC_PLL4, 0, 2)
+		FLEXGEN_CFG(8, XBAR_SRC_HSI_KER, 0, 0)
+		FLEXGEN_CFG(48, XBAR_SRC_PLL5, 0, 3)
+		FLEXGEN_CFG(51, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(52, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(58, XBAR_SRC_HSE_KER, 0, 1)
+		FLEXGEN_CFG(63, XBAR_SRC_PLL4, 0, 2)
+	>;
+
+	st,kerclk = <
+		MUX_CFG(MUX_USB2PHY1, MUX_USB2PHY1_FLEX57)
+		MUX_CFG(MUX_USB2PHY2, MUX_USB2PHY2_FLEX58)
+	>;
+
+	pll1: st,pll-1 {
+		st,pll = <&pll1_cfg_1200Mhz>;
+
+		pll1_cfg_1200Mhz: pll1-cfg-1200Mhz {
+			cfg = <30 1 1 1>;
+			src = <MUX_CFG(MUX_MUXSEL5, MUXSEL_HSE)>;
+		};
+	};
+
+	pll2: st,pll-2 {
+		st,pll = <&pll2_cfg_600Mhz>;
+
+		pll2_cfg_600Mhz: pll2-cfg-600Mhz {
+			cfg = <30 1 1 2>;
+			src = <MUX_CFG(MUX_MUXSEL6, MUXSEL_HSE)>;
+		};
+	};
+
+	pll4: st,pll-4 {
+		st,pll = <&pll4_cfg_1200Mhz>;
+
+		pll4_cfg_1200Mhz: pll4-cfg-1200Mhz {
+			cfg = <30 1 1 1>;
+			src = <MUX_CFG(MUX_MUXSEL0, MUXSEL_HSE)>;
+		};
+	};
+
+	pll5: st,pll-5 {
+		st,pll = <&pll5_cfg_532Mhz>;
+
+		pll5_cfg_532Mhz: pll5-cfg-532Mhz {
+			cfg = <133 5 1 2>;
+			src = <MUX_CFG(MUX_MUXSEL1, MUXSEL_HSE)>;
+		};
+	};
+};
diff --git a/fdts/stm32mp257f-dk-fw-config.dts b/fdts/stm32mp257f-dk-fw-config.dts
new file mode 100644
index 0000000000..a992651864
--- /dev/null
+++ b/fdts/stm32mp257f-dk-fw-config.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2020-2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include "stm32mp25-fw-config.dtsi"
+#include "stm32mp257f-dk-ca35tdcid-fw-config.dtsi"
diff --git a/fdts/stm32mp257f-dk.dts b/fdts/stm32mp257f-dk.dts
new file mode 100644
index 0000000000..853674ebe9
--- /dev/null
+++ b/fdts/stm32mp257f-dk.dts
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/clock/stm32mp25-clksrc.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp257f-dk-ca35tdcid-rcc.dtsi"
+#include "stm32mp25-lpddr4-1x32Gbits-1x32bits-1200MHz.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxal-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-DK Discovery Board";
+	compatible = "st,stm32mp257f-dk", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x00000000>;
+	};
+
+	shadow-prov {
+		compatible = "st,provisioning";
+
+		hconf1_prov {
+			nvmem-cells = <&hconf1_otp>;
+			st,shadow-value = <0x00018000>;
+		};
+	};
+};
+
+&bsec {
+	board_id: board_id@3d8 {
+		reg = <0x3d8 0x4>;
+	};
+};
+
+&ddr {
+	vdd1-supply = <&vdd1_ddr>;
+	vdd2-supply = <&vdd2_ddr>;
+	vddq-supply = <&vdd2_ddr>;
+};
+
+&hash {
+	status = "okay";
+};
+
+&i2c7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pmic2: stpmic@33 {
+		compatible = "st,stpmic2";
+		reg = <0x33>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic2-regulators";
+
+			vddcpu: buck1 {
+				regulator-name = "vddcpu";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <910000>;
+				regulator-always-on;
+			};
+			vddcore: buck2 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <820000>;
+				regulator-max-microvolt = <820000>;
+				regulator-always-on;
+			};
+			vddgpu: buck3 {
+				regulator-name = "vddgpu";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <900000>;
+				regulator-always-on;
+			};
+			vddio_pmic: buck4 {
+				regulator-name = "vddio_pmic";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			v1v8: buck5 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+			vdd2_ddr: buck6 {
+				regulator-name = "vdd2_ddr";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1100000>;
+			};
+			v3v3: buck7 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vdda1v8_aon: ldo1 {
+				regulator-name = "vdda1v8_aon";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+			vdd_emmc: ldo2 {
+				regulator-name = "vdd_emmc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vdd1_ddr: ldo3 {
+				regulator-name = "vdd1_ddr";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-enable-ramp-delay = <1000>;
+			};
+			vdd3v3_usb: ldo4 {
+				regulator-name = "vdd3v3_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			v5v_hdmi: ldo5 {
+				regulator-name = "v5v_hdmi";
+				regulator-min-microvolt = <2000000>;
+				regulator-max-microvolt = <2000000>;
+			};
+			vdd_sdcard: ldo7 {
+				regulator-name = "vdd_sdcard";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vddio_sdcard: ldo8 {
+				regulator-name = "vddio_sdcard";
+				st,regulator-bypass-microvolt = <3300000>;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&iwdg1 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&pwr {
+	vddio1: vddio1 {
+		vddio1-supply = <&vddio_sdcard>;
+	};
+	vddio2: vddio2 {
+		vddio2-supply = <&v1v8>;
+	};
+	vddio3: vddio3 {
+		vddio3-supply = <&vddio_pmic>;
+	};
+	vddio4: vddio4 {
+		vddio4-supply = <&vddio_pmic>;
+	};
+	vddio: vddio {
+		vdd-supply = <&vddio_pmic>;
+	};
+};
+
+&pka {
+	status = "okay";
+};
+
+&rng {
+	status = "okay";
+};
+
+&saes {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sdcard>;
+	vqmmc-supply = <&vddio1>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&vdd_emmc>;
+	vqmmc-supply = <&vddio2>;
+	status = "okay";
+};
+
+&usart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart2_pins_a>;
+	status = "okay";
+};
diff --git a/fdts/stm32mp257f-ev1-ca35tdcid-fw-config.dtsi b/fdts/stm32mp257f-ev1-ca35tdcid-fw-config.dtsi
new file mode 100644
index 0000000000..6e55ae64ff
--- /dev/null
+++ b/fdts/stm32mp257f-ev1-ca35tdcid-fw-config.dtsi
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+
+/*
+ * STM32MP25 tf-a firmware config
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 2/27/2024 11:46:17 AM
+ */
+
+/ {
+	dtb-registry {
+		soc_fw-config {
+			load-address = <0x0 0x81fc0000>;
+			max-size = <0x40000>;
+		};
+		tos_fw {
+			load-address = <0x0 0x82000000>;
+			max-size = <0x2000000>;
+		};
+	};
+
+	st-mem-firewall {
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			st,protreg = <RISAFPROT(RISAF_REG_ID(7), RIF_CID0_BF|RIF_CID1_BF, RIF_CID0_BF|RIF_CID1_BF, 0, RIF_SEC, RIF_ENC_EN, RIF_BREN_EN)>;
+		};
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			st,protreg = <RISAFPROT(RISAF_REG_ID(8), RIF_CID0_BF|RIF_CID1_BF, RIF_CID0_BF|RIF_CID1_BF, 0, RIF_SEC, RIF_ENC_EN, RIF_BREN_EN)>;
+		};
+	};
+};
diff --git a/fdts/stm32mp257f-ev1-ca35tdcid-rcc.dtsi b/fdts/stm32mp257f-ev1-ca35tdcid-rcc.dtsi
new file mode 100644
index 0000000000..1f6ded5e01
--- /dev/null
+++ b/fdts/stm32mp257f-ev1-ca35tdcid-rcc.dtsi
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 Clock tree device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 2/27/2024 11:46:16 AM
+ */
+
+&clk_hse {
+	clock-frequency = <40000000>;
+};
+
+&clk_hsi {
+	clock-frequency = <64000000>;
+};
+
+&clk_lse {
+	clock-frequency = <32768>;
+};
+
+&clk_lsi {
+	clock-frequency = <32000>;
+};
+
+&clk_msi {
+	clock-frequency = <16000000>;
+};
+
+&rcc {
+	st,busclk = <
+		DIV_CFG(DIV_LSMCU, 1)
+		DIV_CFG(DIV_APB1, 0)
+		DIV_CFG(DIV_APB2, 0)
+		DIV_CFG(DIV_APB3, 0)
+		DIV_CFG(DIV_APB4, 0)
+		DIV_CFG(DIV_APBDBG, 0)
+	>;
+
+	st,flexgen = <
+		FLEXGEN_CFG(0, XBAR_SRC_PLL4, 0, 2)
+		FLEXGEN_CFG(1, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(2, XBAR_SRC_PLL4, 0, 1)
+		FLEXGEN_CFG(4, XBAR_SRC_PLL4, 0, 3)
+		FLEXGEN_CFG(5, XBAR_SRC_PLL4, 0, 2)
+		FLEXGEN_CFG(8, XBAR_SRC_HSI_KER, 0, 0)
+		FLEXGEN_CFG(48, XBAR_SRC_PLL5, 0, 3)
+		FLEXGEN_CFG(51, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(52, XBAR_SRC_PLL4, 0, 5)
+		FLEXGEN_CFG(58, XBAR_SRC_HSE_KER, 0, 1)
+		FLEXGEN_CFG(63, XBAR_SRC_PLL4, 0, 2)
+	>;
+
+	st,kerclk = <
+		MUX_CFG(MUX_USB2PHY1, MUX_USB2PHY1_FLEX57)
+		MUX_CFG(MUX_USB2PHY2, MUX_USB2PHY2_FLEX58)
+	>;
+
+	pll1: st,pll-1 {
+		st,pll = <&pll1_cfg_1200Mhz>;
+
+		pll1_cfg_1200Mhz: pll1-cfg-1200Mhz {
+			cfg = <30 1 1 1>;
+			src = <MUX_CFG(MUX_MUXSEL5, MUXSEL_HSE)>;
+		};
+	};
+
+	pll2: st,pll-2 {
+		st,pll = <&pll2_cfg_600Mhz>;
+
+		pll2_cfg_600Mhz: pll2-cfg-600Mhz {
+			cfg = <30 1 1 2>;
+			src = <MUX_CFG(MUX_MUXSEL6, MUXSEL_HSE)>;
+		};
+	};
+
+	pll4: st,pll-4 {
+		st,pll = <&pll4_cfg_1200Mhz>;
+
+		pll4_cfg_1200Mhz: pll4-cfg-1200Mhz {
+			cfg = <30 1 1 1>;
+			src = <MUX_CFG(MUX_MUXSEL0, MUXSEL_HSE)>;
+		};
+	};
+
+	pll5: st,pll-5 {
+		st,pll = <&pll5_cfg_532Mhz>;
+
+		pll5_cfg_532Mhz: pll5-cfg-532Mhz {
+			cfg = <133 5 1 2>;
+			src = <MUX_CFG(MUX_MUXSEL1, MUXSEL_HSE)>;
+		};
+	};
+};
diff --git a/fdts/stm32mp257f-ev1-fw-config.dts b/fdts/stm32mp257f-ev1-fw-config.dts
new file mode 100644
index 0000000000..fdc9dcfde9
--- /dev/null
+++ b/fdts/stm32mp257f-ev1-fw-config.dts
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (c) 2020-2023, STMicroelectronics - All Rights Reserved
+ */
+
+#include "stm32mp25-fw-config.dtsi"
+#include "stm32mp257f-ev1-ca35tdcid-fw-config.dtsi"
diff --git a/fdts/stm32mp257f-ev1.dts b/fdts/stm32mp257f-ev1.dts
new file mode 100644
index 0000000000..077311edd9
--- /dev/null
+++ b/fdts/stm32mp257f-ev1.dts
@@ -0,0 +1,251 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/clock/stm32mp25-clksrc.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp257f-ev1-ca35tdcid-rcc.dtsi"
+#include "stm32mp25-ddr4-2x16Gbits-2x16bits-1200MHz.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-EV1 Evaluation Board";
+	compatible = "st,stm32mp257f-ev1", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x00000000>;
+	};
+
+	shadow-prov {
+		compatible = "st,provisioning";
+
+		hconf1_prov {
+			nvmem-cells = <&hconf1_otp>;
+			st,shadow-value = <0x00018000>;
+		};
+	};
+};
+
+&bsec {
+	board_id: board_id@3d8 {
+		reg = <0x3d8 0x4>;
+	};
+};
+
+&ddr {
+	vdd-supply = <&vdd_ddr>;
+	vtt-supply = <&vtt_ddr>;
+	vpp-supply = <&vpp_ddr>;
+	vref-supply = <&vref_ddr>;
+};
+
+&hash {
+	status = "okay";
+};
+
+&i2c7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	pmic2: stpmic@33 {
+		compatible = "st,stpmic2";
+		reg = <0x33>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic2-regulators";
+
+			vddcpu: buck1 {
+				regulator-name = "vddcpu";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <910000>;
+				regulator-always-on;
+			};
+			vddcore: buck2 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <820000>;
+				regulator-max-microvolt = <820000>;
+				regulator-always-on;
+			};
+			vddgpu: buck3 {
+				regulator-name = "vddgpu";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <900000>;
+				regulator-always-on;
+			};
+			vddio_pmic: buck4 {
+				regulator-name = "vddio_pmic";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			v1v8: buck5 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+			vdd_ddr: buck6 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1200000>;
+			};
+			v3v3: buck7 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vdda1v8_aon: ldo1 {
+				regulator-name = "vdda1v8_aon";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+			vdd_emmc: ldo2 {
+				regulator-name = "vdd_emmc";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				st,regulator-sink-source;
+			};
+			vdd3v3_usb: ldo4 {
+				regulator-name = "vdd3v3_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vpp_ddr: ldo5 {
+				regulator-name = "vpp_ddr";
+				regulator-min-microvolt = <2500000>;
+				regulator-max-microvolt = <2500000>;
+				regulator-enable-ramp-delay = <1000>;
+			};
+			vdd_sdcard: ldo7 {
+				regulator-name = "vdd_sdcard";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vddio_sdcard: ldo8 {
+				regulator-name = "vddio_sdcard";
+				st,regulator-bypass-microvolt = <3300000>;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+			vref_ddr: refddr {
+				regulator-name = "vref_ddr";
+			};
+		};
+	};
+};
+
+&iwdg1 {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&ommanager {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ospi_port1_clk_pins_a
+		     &ospi_port1_io03_pins_a
+		     &ospi_port1_cs0_pins_a>;
+	status = "okay";
+
+	spi@40430000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		flash0: flash@0 {
+			compatible = "jedec,spi-nor";
+			reg = <0>;
+			spi-rx-bus-width = <4>;
+			spi-max-frequency = <133000000>;
+		};
+	};
+};
+
+&pwr {
+	vddio1: vddio1 {
+		vddio1-supply = <&vddio_sdcard>;
+	};
+	vddio2: vddio2 {
+		vddio2-supply = <&v1v8>;
+	};
+	vddio3: vddio3 {
+		vddio3-supply = <&vddio_pmic>;
+	};
+	vddio4: vddio4 {
+		vddio4-supply = <&vddio_pmic>;
+	};
+	vddio: vddio {
+		vdd-supply = <&vddio_pmic>;
+	};
+};
+
+&pka {
+	status = "okay";
+};
+
+&rng {
+	status = "okay";
+};
+
+&saes {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sdcard>;
+	vqmmc-supply = <&vddio1>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&vdd_emmc>;
+	vqmmc-supply = <&vddio2>;
+	status = "okay";
+};
+
+&usart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&usart2_pins_a>;
+	status = "okay";
+};
diff --git a/fdts/stm32mp25xc.dtsi b/fdts/stm32mp25xc.dtsi
new file mode 100644
index 0000000000..05828a1ee5
--- /dev/null
+++ b/fdts/stm32mp25xc.dtsi
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	soc@0 {
+		cryp1: cryp@42030000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x42030000 0x400>;
+			clocks = <&rcc CK_BUS_CRYP1>;
+			resets = <&rcc CRYP1_R>;
+			status = "disabled";
+		};
+
+		cryp2: cryp@42040000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x42040000 0x400>;
+			clocks = <&rcc CK_BUS_CRYP2>;
+			resets = <&rcc CRYP2_R>;
+			status = "disabled";
+		};
+
+		saes: saes@42050000 {
+			compatible = "st,stm32-saes";
+			reg = <0x42050000 0x400>;
+			clocks = <&rcc CK_BUS_SAES>;
+			resets = <&rcc SAES_R>;
+			status = "disabled";
+		};
+
+		pka: pka@42060000 {
+			compatible = "st,stm32-pka64";
+			reg = <0x42060000 0x2000>;
+			clocks = <&rcc CK_BUS_PKA>;
+			resets = <&rcc PKA_R>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/fdts/stm32mp25xf.dtsi b/fdts/stm32mp25xf.dtsi
new file mode 100644
index 0000000000..05828a1ee5
--- /dev/null
+++ b/fdts/stm32mp25xf.dtsi
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	soc@0 {
+		cryp1: cryp@42030000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x42030000 0x400>;
+			clocks = <&rcc CK_BUS_CRYP1>;
+			resets = <&rcc CRYP1_R>;
+			status = "disabled";
+		};
+
+		cryp2: cryp@42040000 {
+			compatible = "st,stm32mp1-cryp";
+			reg = <0x42040000 0x400>;
+			clocks = <&rcc CK_BUS_CRYP2>;
+			resets = <&rcc CRYP2_R>;
+			status = "disabled";
+		};
+
+		saes: saes@42050000 {
+			compatible = "st,stm32-saes";
+			reg = <0x42050000 0x400>;
+			clocks = <&rcc CK_BUS_SAES>;
+			resets = <&rcc SAES_R>;
+			status = "disabled";
+		};
+
+		pka: pka@42060000 {
+			compatible = "st,stm32-pka64";
+			reg = <0x42060000 0x2000>;
+			clocks = <&rcc CK_BUS_PKA>;
+			resets = <&rcc PKA_R>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/fdts/stm32mp25xxai-pinctrl.dtsi b/fdts/stm32mp25xxai-pinctrl.dtsi
new file mode 100644
index 0000000000..aab0888634
--- /dev/null
+++ b/fdts/stm32mp25xxai-pinctrl.dtsi
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@442d0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@442e0000 {
+		status = "okay";
+		ngpios = <8>;
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/fdts/stm32mp25xxak-pinctrl.dtsi b/fdts/stm32mp25xxak-pinctrl.dtsi
new file mode 100644
index 0000000000..e8dbe966db
--- /dev/null
+++ b/fdts/stm32mp25xxak-pinctrl.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/fdts/stm32mp25xxal-pinctrl.dtsi b/fdts/stm32mp25xxal-pinctrl.dtsi
new file mode 100644
index 0000000000..e8dbe966db
--- /dev/null
+++ b/fdts/stm32mp25xxal-pinctrl.dtsi
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/include/common/bl_common.ld.h b/include/common/bl_common.ld.h
index 080e331ed7..21f8dfa472 100644
--- a/include/common/bl_common.ld.h
+++ b/include/common/bl_common.ld.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2020-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2020-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -111,6 +111,7 @@
 	.data . : ALIGN(DATA_ALIGN) {			\
 		__DATA_START__ = .;			\
 		*(SORT_BY_ALIGNMENT(.data*))		\
+		. = ALIGN(2);				\
 		__DATA_END__ = .;			\
 	}
 
diff --git a/include/common/fdt_wrappers.h b/include/common/fdt_wrappers.h
index 2929fc23d5..585cb0c927 100644
--- a/include/common/fdt_wrappers.h
+++ b/include/common/fdt_wrappers.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2023, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -20,6 +20,8 @@ uint32_t fdt_read_uint32_default(const void *dtb, int node,
 				 const char *prop_name, uint32_t dflt_value);
 int fdt_read_uint64(const void *dtb, int node, const char *prop_name,
 		    uint64_t *value);
+uint64_t fdt_read_uint64_default(const void *dtb, int node,
+				 const char *prop_name, uint64_t dflt_value);
 int fdt_read_uint32_array(const void *dtb, int node, const char *prop_name,
 			  unsigned int cells, uint32_t *value);
 int fdtw_read_string(const void *dtb, int node, const char *prop,
diff --git a/include/drivers/arm/gicv2.h b/include/drivers/arm/gicv2.h
index cfc168d5b7..c463af269b 100644
--- a/include/drivers/arm/gicv2.h
+++ b/include/drivers/arm/gicv2.h
@@ -196,5 +196,34 @@ void gicv2_clear_interrupt_pending(unsigned int id);
 unsigned int gicv2_set_pmr(unsigned int mask);
 void gicv2_interrupt_set_cfg(unsigned int id, unsigned int cfg);
 
+/* Use GICV2_INTR_NUM to reduce the size of the GICV2 context, for value 0 use default */
+#if GICV2_INTR_NUM == 0
+#define TOTAL_SHARED_INTR_NUM TOTAL_SPI_INTR_NUM
+#else
+#define TOTAL_SHARED_INTR_NUM (GICV2_INTR_NUM - MIN_SPI_ID)
+#endif
+
+/*
+ * This macro returns the total number of GICD registers corresponding to
+ * the register name
+ */
+#define GICD_NUM_REGS(reg_name)	\
+	DIV_ROUND_UP_2EVAL(TOTAL_SHARED_INTR_NUM, (1U << reg_name##_SHIFT))
+
+typedef struct gicv2_dist_ctx {
+	/* 32 bits registers */
+	uint32_t gicd_ctlr;
+	uint32_t gicd_igroupr[GICD_NUM_REGS(IGROUPR)];
+	uint32_t gicd_isenabler[GICD_NUM_REGS(ISENABLER)];
+	uint32_t gicd_ispendr[GICD_NUM_REGS(ISPENDR)];
+	uint32_t gicd_isactiver[GICD_NUM_REGS(ISACTIVER)];
+	uint32_t gicd_ipriorityr[GICD_NUM_REGS(IPRIORITYR)];
+	uint32_t gicd_itargetsr[GICD_NUM_REGS(ITARGETSR)];
+	uint32_t gicd_icfgr[GICD_NUM_REGS(ICFGR)];
+} gicv2_dist_ctx_t;
+
+void gicv2_distif_restore(const gicv2_dist_ctx_t * const dist_ctx);
+void gicv2_distif_save(gicv2_dist_ctx_t * const dist_ctx);
+
 #endif /* __ASSEMBLER__ */
 #endif /* GICV2_H */
diff --git a/include/drivers/fwu/fwu.h b/include/drivers/fwu/fwu.h
index 9f18e221c3..18e8a31633 100644
--- a/include/drivers/fwu/fwu.h
+++ b/include/drivers/fwu/fwu.h
@@ -9,8 +9,15 @@
 
 #include <stdbool.h>
 
+#define FWU_BANK_STATE_ACCEPTED		0xFCU
+#define FWU_BANK_STATE_VALID		0xFEU
+#define FWU_BANK_STATE_INVALID		0xFFU
+
+#define INVALID_BOOT_IDX		0xFFFFFFFFU
+
 void fwu_init(void);
-bool fwu_is_trial_run_state(void);
+uint32_t fwu_get_active_bank_state(void);
+uint32_t fwu_get_alternate_boot_bank(void);
 const struct fwu_metadata *fwu_get_metadata(void);
 
 #endif /* FWU_H */
diff --git a/include/drivers/fwu/fwu_metadata.h b/include/drivers/fwu/fwu_metadata.h
index 2e88de5ec8..b441300e41 100644
--- a/include/drivers/fwu/fwu_metadata.h
+++ b/include/drivers/fwu/fwu_metadata.h
@@ -4,7 +4,7 @@
  * SPDX-License-Identifier: BSD-3-Clause
  *
  * FWU metadata information as per the specification section 4.1:
- * https://developer.arm.com/documentation/den0118/a/
+ * https://developer.arm.com/documentation/den0118/latest/
  *
  */
 
@@ -14,11 +14,13 @@
 #include <stdint.h>
 #include <tools_share/uuid.h>
 
+#define NR_OF_MAX_FW_BANKS	4
+
 /* Properties of image in a bank */
-struct fwu_image_properties {
+struct fwu_image_bank_info {
 
-	/* UUID of the image in this bank */
-	uuid_t img_uuid;
+	/* GUID of the image in this bank */
+	struct efi_guid img_guid;
 
 	/* [0]: bit describing the image acceptance status –
 	 *      1 means the image is accepted
@@ -34,14 +36,37 @@ struct fwu_image_properties {
 /* Image entry information */
 struct fwu_image_entry {
 
-	/* UUID identifying the image type */
-	uuid_t img_type_uuid;
+	/* GUID identifying the image type */
+	struct efi_guid img_type_guid;
 
-	/* UUID of the storage volume where the image is located */
-	uuid_t location_uuid;
+	/* GUID of the storage volume where the image is located */
+	struct efi_guid location_guid;
 
-	/* Properties of images with img_type_uuid in the different FW banks */
-	struct fwu_image_properties img_props[NR_OF_FW_BANKS];
+	/* Properties of images with img_type_guid in the different FW banks */
+	struct fwu_image_bank_info img_bank_info[NR_OF_FW_BANKS];
+
+} __packed;
+
+/* Firmware Image descriptor */
+struct fwu_fw_store_descriptor {
+
+	/* Number of Banks */
+	uint8_t num_banks;
+
+	/* Reserved */
+	uint8_t reserved;
+
+	/* Number of images per bank */
+	uint16_t num_images;
+
+	/* Size of image_entry(all banks) in bytes */
+	uint16_t img_entry_size;
+
+	/* Size of image bank info structure in bytes */
+	uint16_t bank_info_entry_size;
+
+	/* Array of fwu_image_entry structs */
+	struct fwu_image_entry img_entry[NR_OF_IMAGES_IN_FW_BANK];
 
 } __packed;
 
@@ -66,8 +91,25 @@ struct fwu_metadata {
 	/* Previous bank index with which device booted successfully */
 	uint32_t previous_active_index;
 
+	/* Size of the entire metadata in bytes */
+	uint32_t metadata_size;
+
+	/* Offset of the image descriptor structure */
+	uint16_t desc_offset;
+
+	/* Reserved */
+	uint16_t reserved1;
+
+	/* Bank state */
+	uint8_t bank_state[NR_OF_MAX_FW_BANKS];
+
+	/* Reserved */
+	uint32_t reserved2;
+
+#if PSA_FWU_METADATA_FW_STORE_DESC
 	/* Image entry information */
-	struct fwu_image_entry img_entry[NR_OF_IMAGES_IN_FW_BANK];
+	struct fwu_fw_store_descriptor fw_desc;
+#endif
 
 } __packed;
 
diff --git a/include/drivers/hyperflash.h b/include/drivers/hyperflash.h
new file mode 100644
index 0000000000..ab5eaf1459
--- /dev/null
+++ b/include/drivers/hyperflash.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef DRIVERS_HYPERFLASH_H
+#define DRIVERS_HYPERFLASH_H
+
+#include <errno.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+struct hyperflash_ctrl_ops {
+	int (*read)(unsigned int offset, uint8_t *buffer, size_t length,
+		    size_t *length_read);
+};
+
+struct hyperflash_device {
+	const struct hyperflash_ctrl_ops *ops;
+	uint32_t size;
+};
+
+int hyperflash_read(unsigned int offset, uintptr_t buffer, size_t length,
+		    size_t *length_read);
+int hyperflash_init(unsigned long long *size, unsigned int *erase_size);
+void hyperflash_ctrl_init(const struct hyperflash_ctrl_ops *ops);
+
+/*
+ * Platform can implement this to override default hyperflash
+ * configuration.
+ *
+ * @device: target hyperflash device.
+ * Return 0 on success, negative value otherwise.
+ */
+int plat_get_hyperflash_data(struct hyperflash_device *device);
+
+#endif	/* DRIVERS_HYPERFLASH_H */
diff --git a/include/drivers/io/io_mtd.h b/include/drivers/io/io_mtd.h
index 2b5d9b1017..18a1dc3161 100644
--- a/include/drivers/io/io_mtd.h
+++ b/include/drivers/io/io_mtd.h
@@ -54,6 +54,13 @@ typedef struct io_mtd_ops {
 	 * Return 0 on success, a negative error code otherwise.
 	 */
 	int (*seek)(uintptr_t base, unsigned int offset, size_t *extra_offset);
+
+	/*
+	 * Reset the device.
+	 *
+	 * Return 0 on success, a negative error code otherwise.
+	 */
+	int (*reset)(void);
 } io_mtd_ops_t;
 
 typedef struct io_mtd_dev_spec {
diff --git a/include/drivers/partition/efi.h b/include/drivers/partition/efi.h
index e463f96572..96c2857379 100644
--- a/include/drivers/partition/efi.h
+++ b/include/drivers/partition/efi.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2021, Linaro Limited
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -25,13 +26,13 @@ static inline void *guidcpy(void *dst, const void *src)
 }
 
 #define EFI_GUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \
-	{ (a) & 0xffffffff,		\
-	  (b) & 0xffff,			\
-	  (c) & 0xffff,			\
+	{ (a) & 0xffffffffU,		\
+	  (b) & 0xffffU,			\
+	  (c) & 0xffffU,			\
 	  { (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) } }
 
 #define NULL_GUID \
-	EFI_GUID(0x00000000, 0x0000, 0x0000, 0x00, 0x00, \
-		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
+	EFI_GUID(0x00000000U, 0x0000U, 0x0000U, 0x00U, 0x00U, \
+		 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U)
 
 #endif /* DRIVERS_PARTITION_EFI_H */
diff --git a/include/drivers/partition/partition.h b/include/drivers/partition/partition.h
index 6cb59c391b..6c20312af4 100644
--- a/include/drivers/partition/partition.h
+++ b/include/drivers/partition/partition.h
@@ -46,8 +46,10 @@ typedef struct partition_entry_list {
 
 int load_partition_table(unsigned int image_id);
 const partition_entry_t *get_partition_entry(const char *name);
-const partition_entry_t *get_partition_entry_by_type(const uuid_t *type_guid);
-const partition_entry_t *get_partition_entry_by_uuid(const uuid_t *part_uuid);
+const partition_entry_t *get_partition_entry_by_type(
+	const struct efi_guid *type_guid);
+const partition_entry_t *get_partition_entry_by_guid(
+	const struct efi_guid *part_guid);
 const partition_entry_list_t *get_partition_entry_list(void);
 void partition_init(unsigned int image_id);
 
diff --git a/include/drivers/spi_mem.h b/include/drivers/spi_mem.h
index d1953acf4c..154ea25056 100644
--- a/include/drivers/spi_mem.h
+++ b/include/drivers/spi_mem.h
@@ -14,6 +14,7 @@
 #define SPI_MEM_BUSWIDTH_1_LINE		1U
 #define SPI_MEM_BUSWIDTH_2_LINE		2U
 #define SPI_MEM_BUSWIDTH_4_LINE		4U
+#define SPI_MEM_BUSWIDTH_8_LINE		8U
 
 /*
  * enum spi_mem_data_dir - Describes the direction of a SPI memory data
@@ -29,8 +30,11 @@ enum spi_mem_data_dir {
 /*
  * struct spi_mem_op - Describes a SPI memory operation.
  *
+ * @cmd.nbytes: number of opcode bytes (only 1 or 2 are valid). The opcode is
+ *		sent MSB-first.
  * @cmd.buswidth: Number of IO lines used to transmit the command.
  * @cmd.opcode: Operation opcode.
+ * @cmd.dtr: whether the command opcode should be sent in DTR mode or not
  * @addr.nbytes: Number of address bytes to send. Can be zero if the operation
  *		 does not need to send an address.
  * @addr.buswidth: Number of IO lines used to transmit the address.
@@ -38,33 +42,44 @@ enum spi_mem_data_dir {
  *	      Note that only @addr.nbytes are taken into account in this
  *	      address value, so users should make sure the value fits in the
  *	      assigned number of bytes.
+ * @addr.dtr: whether the address should be sent in DTR mode or not
  * @dummy.nbytes: Number of dummy bytes to send after an opcode or address. Can
  *		  be zero if the operation does not require dummy bytes.
  * @dummy.buswidth: Number of IO lines used to transmit the dummy bytes.
+ * @dummy.dtr: whether the dummy bytes should be sent in DTR mode or not
  * @data.buswidth: Number of IO lines used to send/receive the data.
+ * @data.dtr: whether the data should be sent in DTR mode or not
+ * @data.dtr_swab16: whether the byte order of 16-bit words is swapped when read
+ *		     or written in Octal DTR mode compared to STR mode.
  * @data.dir: Direction of the transfer.
  * @data.nbytes: Number of data bytes to transfer.
  * @data.buf: Input or output data buffer depending on data::dir.
  */
 struct spi_mem_op {
 	struct {
+		uint8_t nbytes;
 		uint8_t buswidth;
-		uint8_t opcode;
+		bool dtr;
+		uint16_t opcode;
 	} cmd;
 
 	struct {
 		uint8_t nbytes;
 		uint8_t buswidth;
+		bool dtr;
 		uint64_t val;
 	} addr;
 
 	struct {
 		uint8_t nbytes;
 		uint8_t buswidth;
+		bool dtr;
 	} dummy;
 
 	struct {
 		uint8_t buswidth;
+		bool dtr;
+		bool dtr_swab16;
 		enum spi_mem_data_dir dir;
 		unsigned int nbytes;
 		void *buf;
@@ -82,6 +97,8 @@ struct spi_mem_op {
 #define SPI_TX_QUAD	BIT(7)			/* transmit with 4 wires */
 #define SPI_RX_DUAL	BIT(8)			/* receive with 2 wires */
 #define SPI_RX_QUAD	BIT(9)			/* receive with 4 wires */
+#define SPI_TX_OCTAL	BIT(10)			/* transmit with 8 wires */
+#define SPI_RX_OCTAL	BIT(11)			/* receive with 8 wires */
 
 struct spi_bus_ops {
 	/*
@@ -121,9 +138,28 @@ struct spi_bus_ops {
 	 * Returns: 0 on success, a negative error code otherwise.
 	 */
 	int (*exec_op)(const struct spi_mem_op *op);
+
+	/*
+	 * Read data through a direct mapping.
+	 *
+	 * @op: The memory operation to execute.
+	 * Returns: 0 on success, a negative error code otherwise.
+	 */
+	int (*dirmap_read)(const struct spi_mem_op *op);
+
+	/*
+	 * Check if an operation is supported by the controller.
+	 *
+	 * @op: The memory operation to execute.
+	 * Returns: 0 on success, a negative error code otherwise.
+	 */
+	bool (*supports_op)(const struct spi_mem_op *op);
 };
 
+bool spi_mem_dtr_supports_op(const struct spi_mem_op *op);
+bool spi_mem_default_supports_op(const struct spi_mem_op *op);
 int spi_mem_exec_op(const struct spi_mem_op *op);
+int spi_mem_dirmap_read(const struct spi_mem_op *op);
 int spi_mem_init_slave(void *fdt, int bus_node,
 		       const struct spi_bus_ops *ops);
 
diff --git a/include/drivers/spi_nand.h b/include/drivers/spi_nand.h
index 40e2063751..1eddbb6c0b 100644
--- a/include/drivers/spi_nand.h
+++ b/include/drivers/spi_nand.h
@@ -29,9 +29,13 @@
 #define SPI_NAND_STATUS_BUSY		BIT(0)
 #define SPI_NAND_STATUS_ECC_UNCOR	BIT(5)
 
+/* Flags for specific configuration */
+#define SPI_NAND_HAS_QE_BIT		BIT(0)
+
 struct spinand_device {
 	struct nand_device *nand_dev;
 	struct spi_mem_op spi_read_cache_op;
+	uint32_t flags;
 	uint8_t cfg_cache; /* Cached value of SPI NAND device register CFG */
 };
 
diff --git a/include/drivers/spi_nor.h b/include/drivers/spi_nor.h
index 72cfe5b346..a3c65adc23 100644
--- a/include/drivers/spi_nor.h
+++ b/include/drivers/spi_nor.h
@@ -10,29 +10,45 @@
 #include <drivers/spi_mem.h>
 
 /* OPCODE */
-#define SPI_NOR_OP_WREN		0x06U	/* Write enable */
-#define SPI_NOR_OP_WRSR		0x01U	/* Write status register 1 byte */
-#define SPI_NOR_OP_READ_ID	0x9FU	/* Read JEDEC ID */
-#define SPI_NOR_OP_READ_CR	0x35U	/* Read configuration register */
-#define SPI_NOR_OP_READ_SR	0x05U	/* Read status register */
-#define SPI_NOR_OP_READ_FSR	0x70U	/* Read flag status register */
-#define SPINOR_OP_RDEAR		0xC8U	/* Read Extended Address Register */
-#define SPINOR_OP_WREAR		0xC5U	/* Write Extended Address Register */
+#define SPI_NOR_OP_WREN			0x06U	/* Write enable */
+#define SPI_NOR_OP_WRSR			0x01U	/* Write status register 1 byte */
+#define SPI_NOR_OP_READ_ID		0x9FU	/* Read JEDEC ID */
+#define SPI_NOR_OP_READ_CR		0x35U	/* Read configuration register */
+#define SPI_NOR_OP_READ_SR		0x05U	/* Read status register */
+#define SPI_NOR_OP_READ_FSR		0x70U	/* Read flag status register */
+#define SPINOR_OP_RDEAR			0xC8U	/* Read Extended Address Register */
+#define SPINOR_OP_WREAR			0xC5U	/* Write Extended Address Register */
+#define SPI_NOR_OP_SRSTEN		0x66U	/* Software Reset Enable */
+#define SPI_NOR_OP_SRST			0x99U	/* Software Reset */
 
 /* Used for Spansion flashes only. */
-#define SPINOR_OP_BRWR		0x17U	/* Bank register write */
-#define SPINOR_OP_BRRD		0x16U	/* Bank register read */
+#define SPINOR_OP_BRWR			0x17U	/* Bank register write */
+#define SPINOR_OP_BRRD			0x16U	/* Bank register read */
 
-#define SPI_NOR_OP_READ		0x03U	/* Read data bytes (low frequency) */
-#define SPI_NOR_OP_READ_FAST	0x0BU	/* Read data bytes (high frequency) */
-#define SPI_NOR_OP_READ_1_1_2	0x3BU	/* Read data bytes (Dual Output SPI) */
-#define SPI_NOR_OP_READ_1_2_2	0xBBU	/* Read data bytes (Dual I/O SPI) */
-#define SPI_NOR_OP_READ_1_1_4	0x6BU	/* Read data bytes (Quad Output SPI) */
-#define SPI_NOR_OP_READ_1_4_4	0xEBU	/* Read data bytes (Quad I/O SPI) */
+#define SPI_NOR_OP_READ			0x03U	/* Read data bytes (low frequency) */
+#define SPI_NOR_OP_READ_FAST		0x0BU	/* Read data bytes (high frequency) */
+#define SPI_NOR_OP_READ_1_1_2		0x3BU	/* Read data bytes (Dual Output SPI) */
+#define SPI_NOR_OP_READ_1_2_2		0xBBU	/* Read data bytes (Dual I/O SPI) */
+#define SPI_NOR_OP_READ_1_1_4		0x6BU	/* Read data bytes (Quad Output SPI) */
+#define SPI_NOR_OP_READ_1_4_4		0xEBU	/* Read data bytes (Quad I/O SPI) */
+#define SPI_NOR_OP_READ_1_1_8		0x8BU	/* Read data bytes (Octal Output SPI) */
+#define SPI_NOR_OP_READ_1_8_8		0xCBU	/* Read data bytes (Octal I/O SPI) */
+
+/* 4-bytes address opcodes */
+#define SPI_NOR_OP_READ_4B		0x13U	/* Read data bytes (low frequency) */
+#define SPI_NOR_OP_READ_FAST_4B		0x0CU	/* Read data bytes (high frequency) */
+#define SPI_NOR_OP_DT_READ_8_8_8	0xEEU	/* Read data bytes (Octal DTR I/O SPI) */
+
+/* Used for Macronix and Winbond flashes. */
+#define SPI_NOR_OP_WR_CR2		0x72U		/* Write configuration register 2 */
+#define SPI_NOR_REG_MXIC_CR2_MODE	0x00000000U	/* For setting octal DTR mode */
+#define SPI_NOR_REG_MXIC_OPI_DTR_EN	0x2U		/* Enable Octal DTR */
+#define SPI_NOR_REG_MXIC_CR2_DC		0x00000300U	/* For setting dummy cycles */
+#define SPI_NOR_REG_MXIC_DC_20		0x0U		/* Setting dummy cycles to 20 */
 
 /* Flags for NOR specific configuration */
-#define SPI_NOR_USE_FSR		BIT(0)
-#define SPI_NOR_USE_BANK	BIT(1)
+#define SPI_NOR_USE_FSR			BIT(0)
+#define SPI_NOR_USE_BANK		BIT(1)
 
 struct nor_device {
 	struct spi_mem_op read_op;
@@ -46,6 +62,7 @@ struct nor_device {
 int spi_nor_read(unsigned int offset, uintptr_t buffer, size_t length,
 		 size_t *length_read);
 int spi_nor_init(unsigned long long *device_size, unsigned int *erase_size);
+int spi_nor_reset(void);
 
 /*
  * Platform can implement this to override default NOR instance configuration.
diff --git a/include/drivers/st/bsec.h b/include/drivers/st/bsec.h
index 60dcf3c12f..eb70c6e4aa 100644
--- a/include/drivers/st/bsec.h
+++ b/include/drivers/st/bsec.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -12,13 +12,6 @@
 
 #include <lib/utils_def.h>
 
-/*
- * IP configuration
- */
-#define BSEC_OTP_MASK			GENMASK(4, 0)
-#define BSEC_OTP_BANK_SHIFT		5
-#define BSEC_TIMEOUT_VALUE		0xFFFF
-
 /*
  * Return status
  */
@@ -32,98 +25,53 @@
 #define BSEC_RETRY			0xFFFFFFF8U
 #define BSEC_NOT_SUPPORTED		0xFFFFFFF7U
 #define BSEC_WRITE_LOCKED		0xFFFFFFF6U
-#define BSEC_ERROR_INVALID_FVR		0xFFFFFFF5U
 
 /*
- * OTP MODE
+ * get BSEC global state: result for bsec_get_secure_state()
+ * @state: global state
+ *           [1:0] BSEC state
+ *             00b: Sec Open
+ *             01b: Sec Closed
+ *             11b: Invalid
+ *           [8]: Hardware Key set = 1b
  */
-#define BSEC_MODE_OPEN1			0x00U
-#define BSEC_MODE_SECURED		0x01U
-#define BSEC_MODE_OPEN2			0x02U
-#define BSEC_MODE_INVALID		0x04U
+#define BSEC_STATE_SEC_OPEN		U(0x0)
+#define BSEC_STATE_SEC_CLOSED		U(0x1)
+#define BSEC_STATE_INVALID		U(0x3)
+#define BSEC_STATE_MASK			GENMASK_32(1, 0)
 
-/*
- * OTP Lock services definition.
- * Value must corresponding to the bit number in the register.
- * Special case: (bit number << 1) for BSEC3.
- */
-#define BSEC_LOCK_UPPER_OTP		0x00
-#define BSEC_LOCK_GWLOCK		0x01
-#define BSEC_LOCK_DEBUG			0x02
-#define BSEC_LOCK_PROGRAM		0x03
-#define BSEC_LOCK_KVLOCK		0x04
-
-/*
- * Values for struct bsec_config::freq
- */
-#define FREQ_10_20_MHZ			0x0
-#define FREQ_20_30_MHZ			0x1
-#define FREQ_30_45_MHZ			0x2
-#define FREQ_45_67_MHZ			0x3
-
-/*
- * Device info structure, providing device-specific functions and a means of
- * adding driver-specific state.
- */
-struct bsec_config {
-	uint8_t den_lock;	/*
-				 * Debug enable sticky lock
-				 * 1 debug enable is locked until next reset
-				 */
-
-	/*  BSEC2 only */
-	uint8_t tread;		/* SAFMEM Reading current level default 0 */
-	uint8_t pulse_width;	/* SAFMEM Programming pulse width default 1 */
-	uint8_t freq;		/*
-				 * SAFMEM CLOCK see freq value define
-				 * default FREQ_45_67_MHZ
-				 */
-	uint8_t power;		/* Power up SAFMEM. 1 power up, 0 power off */
-	uint8_t prog_lock;	/*
-				 * Programming Sticky lock
-				 * 1 programming is locked until next reset
-				 */
-	uint8_t upper_otp_lock;	/*
-				 * Shadowing of upper OTP sticky lock
-				 * 1 shadowing of upper OTP is locked
-				 * until next reset
-				 */
-};
+#define BSEC_HARDWARE_KEY		BIT(8)
 
 uint32_t bsec_probe(void);
-uint32_t bsec_get_base(void);
-
-uint32_t bsec_set_config(struct bsec_config *cfg);
-uint32_t bsec_get_config(struct bsec_config *cfg);
 
-uint32_t bsec_shadow_register(uint32_t otp);
 uint32_t bsec_read_otp(uint32_t *val, uint32_t otp);
+uint32_t bsec_shadow_read_otp(uint32_t *val, uint32_t otp);
 uint32_t bsec_write_otp(uint32_t val, uint32_t otp);
 uint32_t bsec_program_otp(uint32_t val, uint32_t otp);
-uint32_t bsec_permanent_lock_otp(uint32_t otp);
 
-void bsec_write_debug_conf(uint32_t val);
 uint32_t bsec_read_debug_conf(void);
 
 void bsec_write_scratch(uint32_t val);
-uint32_t bsec_read_scratch(void);
-
-uint32_t bsec_get_status(void);
-uint32_t bsec_get_hw_conf(void);
-uint32_t bsec_get_version(void);
-uint32_t bsec_get_id(void);
-uint32_t bsec_get_magic_id(void);
 
+/* Sticky lock support */
 uint32_t bsec_set_sr_lock(uint32_t otp);
 uint32_t bsec_read_sr_lock(uint32_t otp, bool *value);
 uint32_t bsec_set_sw_lock(uint32_t otp);
 uint32_t bsec_read_sw_lock(uint32_t otp, bool *value);
 uint32_t bsec_set_sp_lock(uint32_t otp);
 uint32_t bsec_read_sp_lock(uint32_t otp, bool *value);
-uint32_t bsec_read_permanent_lock(uint32_t otp, bool *value);
-uint32_t bsec_otp_lock(uint32_t service);
 
-uint32_t bsec_shadow_read_otp(uint32_t *otp_value, uint32_t word);
+uint32_t bsec_get_secure_state(void);
+static inline bool bsec_mode_is_closed_device(void)
+{
+	return (bsec_get_secure_state() & BSEC_STATE_MASK) == BSEC_STATE_SEC_CLOSED;
+}
+
+#if defined(IMAGE_BL32) || defined(STM32MP_SSP)
+uint32_t bsec_permanent_lock_otp(uint32_t otp);
+#endif
+#if defined(IMAGE_BL32)
 uint32_t bsec_check_nsec_access_rights(uint32_t otp);
+#endif
 
 #endif /* BSEC_H */
diff --git a/include/drivers/st/bsec2_reg.h b/include/drivers/st/bsec2_reg.h
index f8950205dc..c54efa5282 100644
--- a/include/drivers/st/bsec2_reg.h
+++ b/include/drivers/st/bsec2_reg.h
@@ -80,22 +80,17 @@
 #define GPLOCK_LOCK_SHIFT		4
 
 /* BSEC_OTP_STATUS Register */
-#define BSEC_MODE_STATUS_MASK		GENMASK(2, 0)
-#define BSEC_MODE_SECURE_MASK		BIT(0)
-#define BSEC_MODE_FULLDBG_MASK		BIT(1)
-#define BSEC_MODE_INVALID_MASK		BIT(2)
-#define BSEC_MODE_BUSY_MASK		BIT(3)
-#define BSEC_MODE_PROGFAIL_MASK		BIT(4)
-#define BSEC_MODE_PWR_MASK		BIT(5)
-#define BSEC_MODE_BIST1_LOCK_MASK	BIT(6)
-#define BSEC_MODE_BIST2_LOCK_MASK	BIT(7)
+#define BSEC_OTP_STATUS_SECURE		BIT(0)
+#define BSEC_OTP_STATUS_INVALID		BIT(2)
+#define BSEC_OTP_STATUS_BUSY		BIT(3)
+#define BSEC_OTP_STATUS_PROGFAIL	BIT(4)
+#define BSEC_OTP_STATUS_PWRON		BIT(5)
 
 /* BSEC_DENABLE Register */
 #define BSEC_HDPEN			BIT(4)
 #define BSEC_SPIDEN			BIT(5)
 #define BSEC_SPINDEN			BIT(6)
 #define BSEC_DBGSWGEN			BIT(10)
-#define BSEC_DEN_ALL_MSK		GENMASK(10, 0)
 
 /* BSEC_FENABLE Register */
 #define BSEC_FEN_ALL_MSK		GENMASK(14, 0)
diff --git a/include/drivers/st/bsec3_reg.h b/include/drivers/st/bsec3_reg.h
new file mode 100644
index 0000000000..684476cb6e
--- /dev/null
+++ b/include/drivers/st/bsec3_reg.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BSEC3_REG_H
+#define BSEC3_REG_H
+
+#include <lib/utils_def.h>
+
+/* BSEC REGISTER OFFSET (base relative) */
+#define BSEC_FVR(x)			(U(0x000) + 4U * (x))
+#define BSEC_SPLOCK(x)			(U(0x800) + 4U * (x))
+#define BSEC_SWLOCK(x)			(U(0x840) + 4U * (x))
+#define BSEC_SRLOCK(x)			(U(0x880) + 4U * (x))
+#define BSEC_OTPVLDR(x)			(U(0x8C0) + 4U * (x))
+#define BSEC_SFSR(x)			(U(0x940) + 4U * (x))
+#define BSEC_OTPCR			U(0xC04)
+#define BSEC_WDR			U(0xC08)
+#define BSEC_SCRATCHR0			U(0xE00)
+#define BSEC_SCRATCHR1			U(0xE04)
+#define BSEC_SCRATCHR2			U(0xE08)
+#define BSEC_SCRATCHR3			U(0xE0C)
+#define BSEC_LOCKR			U(0xE10)
+#define BSEC_JTAGINR			U(0xE14)
+#define BSEC_JTAGOUTR			U(0xE18)
+#define BSEC_DENR			U(0xE20)
+#define BSEC_UNMAPR			U(0xE24)
+#define BSEC_SR				U(0xE40)
+#define BSEC_OTPSR			U(0xE44)
+#define BSEC_WRCR			U(0xF00)
+#define BSEC_HWCFGR			U(0xFF0)
+#define BSEC_VERR			U(0xFF4)
+#define BSEC_IPIDR			U(0xFF8)
+#define BSEC_SIDR			U(0xFFC)
+
+/* BSEC_OTPCR register fields */
+#define BSEC_OTPCR_ADDR_MASK		GENMASK(8, 0)
+#define BSEC_OTPCR_ADDR_SHIFT		0
+#define BSEC_OTPCR_PROG			BIT(13)
+#define BSEC_OTPCR_PPLOCK		BIT(14)
+#define BSEC_OTPCR_LASTCID_MASK		GENMASK(21, 19)
+#define BSEC_OTPCR_LASTCID_SHIFT	19
+
+/* BSEC_LOCKR register fields */
+#define BSEC_LOCKR_GWLOCK_MASK		BIT(0)
+#define BSEC_LOCKR_GWLOCK_SHIFT		0
+#define BSEC_LOCKR_DENLOCK_MASK		BIT(1)
+#define BSEC_LOCKR_DENLOCK_SHIFT	1
+#define BSEC_LOCKR_HKLOCK_MASK		BIT(2)
+#define BSEC_LOCKR_HKLOCK_SHIFT		2
+
+/* BSEC_DENR register fields */
+#define BSEC_DENR_LPDBGEN		BIT(0)
+#define BSEC_DENR_DBGENA		BIT(1)
+#define BSEC_DENR_NIDENA		BIT(2)
+#define BSEC_DENR_DEVICEEN		BIT(3)
+#define BSEC_DENR_HDPEN			BIT(4)
+#define BSEC_DENR_SPIDENA		BIT(5)
+#define BSEC_DENR_SPNIDENA		BIT(6)
+#define BSEC_DENR_DBGSWEN		BIT(7)
+#define BSEC_DENR_DBGENM		BIT(8)
+#define BSEC_DENR_NIDENM		BIT(9)
+#define BSEC_DENR_SPIDENM		BIT(10)
+#define BSEC_DENR_SPNIDENM		BIT(11)
+#define BSEC_DENR_CFGSDIS		BIT(12)
+#define BSEC_DENR_CP15SDIS_MASK		GENMASK(14, 13)
+#define BSEC_DENR_CP15SDIS_SHIFT	13
+#define BSEC_DENR_LPDBGDIS		BIT(15)
+#define BSEC_DENR_ALL_MSK		GENMASK(15, 0)
+
+/* BSEC_SR register fields */
+#define BSEC_SR_BUSY			BIT(0)
+#define BSEC_SR_HVALID			BIT(1)
+#define BSEC_SR_RNGERR			BIT(2)
+#define BSEC_SR_HKWW_MASK		GENMASK(15, 8)
+#define BSEC_SR_HKWW_SHIFT		8
+#define BSEC_SR_NVSTATE_MASK		GENMASK(31, 26)
+#define BSEC_SR_NVSTATE_SHIFT		26
+#define BSEC_SR_NVSTATE_OPEN		U(0x16)
+#define BSEC_SR_NVSTATE_CLOSED		U(0x0D)
+#define BSEC_SR_NVSTATE_OTP_LOCKED	U(0x23)
+
+/* BSEC_OTPSR register fields */
+#define BSEC_OTPSR_BUSY			BIT(0)
+#define BSEC_OTPSR_INIT_DONE		BIT(1)
+#define BSEC_OTPSR_HIDEUP		BIT(2)
+#define BSEC_OTPSR_OTPNVIR		BIT(4)
+#define BSEC_OTPSR_OTPERR		BIT(5)
+#define BSEC_OTPSR_OTPSEC		BIT(6)
+#define BSEC_OTPSR_PROGFAIL		BIT(16)
+#define BSEC_OTPSR_DISTURBF		BIT(17)
+#define BSEC_OTPSR_DEDF			BIT(18)
+#define BSEC_OTPSR_SECF			BIT(19)
+#define BSEC_OTPSR_PPLF			BIT(20)
+#define BSEC_OTPSR_PPLMF		BIT(21)
+#define BSEC_OTPSR_AMEF			BIT(22)
+
+/* BSEC_VERR register fields */
+#define BSEC_VERR_MASK			GENMASK(7, 0)
+
+#endif /* BSEC3_REG_H */
diff --git a/include/drivers/st/nvmem.h b/include/drivers/st/nvmem.h
new file mode 100644
index 0000000000..0bc1a421a6
--- /dev/null
+++ b/include/drivers/st/nvmem.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef NVMEM_H
+#define NVMEM_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+struct nvmem_dev {
+	const struct nvmem_ops *nvmem_ops;
+	void *drv_data;
+	int offset;
+};
+
+struct nvmem_cell {
+	int offset;
+	size_t len;
+	struct nvmem_dev *dev;
+};
+
+struct nvmem_ops {
+	int (*read_cell)(struct nvmem_cell *cell, uint8_t *data, size_t buf_len,
+			 size_t *read_len);
+	int (*write_cell)(struct nvmem_cell *cell, uint8_t *data, size_t len);
+};
+
+int nvmem_driver_register(int nodeoffset, const struct nvmem_ops *nvmem_ops,
+			  void *drv_data);
+
+int nvmem_get_cell_by_index(const void *fdt, int nodeoffset, unsigned int index,
+			    struct nvmem_cell *cell);
+
+int nvmem_get_cell_by_name(const void *fdt, int nodeoffset, const char *name,
+			   struct nvmem_cell *cell);
+
+int nvmem_cell_read(struct nvmem_cell *cell, uint8_t *output_buf,
+		    size_t buf_len, size_t *read_len);
+
+int nvmem_cell_write(struct nvmem_cell *cell, uint8_t *input_buf,
+		     size_t buf_len);
+#endif
diff --git a/include/drivers/st/regulator_gpio.h b/include/drivers/st/regulator_gpio.h
new file mode 100644
index 0000000000..3362f7e248
--- /dev/null
+++ b/include/drivers/st/regulator_gpio.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef REGULATOR_GPIO_H
+#define REGULATOR_GPIO_H
+
+int gpio_regulator_register(void);
+
+#endif /* REGULATOR_GPIO_H */
diff --git a/include/drivers/st/stm32_gpio.h b/include/drivers/st/stm32_gpio.h
index eeef9da5db..255e98bb74 100644
--- a/include/drivers/st/stm32_gpio.h
+++ b/include/drivers/st/stm32_gpio.h
@@ -13,6 +13,7 @@
 #define GPIO_TYPE_OFFSET	U(0x04)
 #define GPIO_SPEED_OFFSET	U(0x08)
 #define GPIO_PUPD_OFFSET	U(0x0C)
+#define GPIO_IDR_OFFSET		U(0x10)
 #define GPIO_OD_OFFSET		U(0x14)
 #define GPIO_BSRR_OFFSET	U(0x18)
 #define GPIO_AFRL_OFFSET	U(0x20)
@@ -54,10 +55,19 @@
 
 #ifndef __ASSEMBLER__
 #include <stdint.h>
-
 int dt_set_pinctrl_config(int node);
 void set_gpio_secure_cfg(uint32_t bank, uint32_t pin, bool secure);
 void set_gpio_reset_cfg(uint32_t bank, uint32_t pin);
+
+enum gpio_level {
+	GPIO_LEVEL_LOW,
+	GPIO_LEVEL_HIGH
+};
+
+void set_gpio_level(uint32_t bank, uint32_t pin, enum gpio_level level);
+enum gpio_level get_gpio_level(uint32_t bank, uint32_t pin);
+
+void set_gpio_config(uint32_t bank, uint32_t pin, uint32_t config, uint8_t status);
 #endif /*__ASSEMBLER__*/
 
 #endif /* STM32_GPIO_H */
diff --git a/include/drivers/st/stm32_i2c.h b/include/drivers/st/stm32_i2c.h
index 170d4cf815..0c055cb6ef 100644
--- a/include/drivers/st/stm32_i2c.h
+++ b/include/drivers/st/stm32_i2c.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2016-2022, STMicroelectronics - All Rights Reserved
  *
- * SPDX-License-Identifier: BSD-3-Clause
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
 
 #ifndef STM32_I2C_H
@@ -73,6 +73,21 @@
 #define I2C_TIMINGR_SDADEL		GENMASK(19, 16)
 #define I2C_TIMINGR_SCLDEL		GENMASK(23, 20)
 #define I2C_TIMINGR_PRESC		GENMASK(31, 28)
+#define I2C_TIMINGR_SCLL_MAX		(I2C_TIMINGR_SCLL + 1)
+#define I2C_TIMINGR_SCLH_MAX		((I2C_TIMINGR_SCLH >> 8) + 1)
+#define I2C_TIMINGR_SDADEL_MAX		((I2C_TIMINGR_SDADEL >> 16) + 1)
+#define I2C_TIMINGR_SCLDEL_MAX		((I2C_TIMINGR_SCLDEL >> 20) + 1)
+#define I2C_TIMINGR_PRESC_MAX		((I2C_TIMINGR_PRESC >> 28) + 1)
+#define I2C_SET_TIMINGR_SCLL(n)		((n) & \
+					 (I2C_TIMINGR_SCLL_MAX - 1))
+#define I2C_SET_TIMINGR_SCLH(n)		(((n) & \
+					  (I2C_TIMINGR_SCLH_MAX - 1)) << 8)
+#define I2C_SET_TIMINGR_SDADEL(n)	(((n) & \
+					  (I2C_TIMINGR_SDADEL_MAX - 1)) << 16)
+#define I2C_SET_TIMINGR_SCLDEL(n)	(((n) & \
+					  (I2C_TIMINGR_SCLDEL_MAX - 1)) << 20)
+#define I2C_SET_TIMINGR_PRESC(n)	(((n) & \
+					  (I2C_TIMINGR_PRESC_MAX - 1)) << 28)
 
 /* Bit definition for I2C_TIMEOUTR register */
 #define I2C_TIMEOUTR_TIMEOUTA		GENMASK(11, 0)
@@ -111,15 +126,9 @@
 #define I2C_ICR_TIMOUTCF		BIT(12)
 #define I2C_ICR_ALERTCF			BIT(13)
 
-enum i2c_speed_e {
-	I2C_SPEED_STANDARD,	/* 100 kHz */
-	I2C_SPEED_FAST,		/* 400 kHz */
-	I2C_SPEED_FAST_PLUS,	/* 1 MHz   */
-};
-
-#define STANDARD_RATE				100000
-#define FAST_RATE				400000
-#define FAST_PLUS_RATE				1000000
+#define STANDARD_RATE			100000U
+#define FAST_RATE			400000U
+#define FAST_PLUS_RATE			1000000U
 
 struct stm32_i2c_init_s {
 	uint32_t own_address1;		/*
@@ -181,12 +190,7 @@ struct stm32_i2c_init_s {
 					 * time in nanoseconds.
 					 */
 
-	enum i2c_speed_e speed_mode;	/*
-					 * Specifies the I2C clock source
-					 * frequency mode.
-					 * This parameter can be a value of @ref
-					 * i2c_speed_mode_e.
-					 */
+	uint32_t bus_rate;		/* Specifies the I2C clock frequency */
 
 	int analog_filter;		/*
 					 * Specifies if the I2C analog noise
@@ -238,6 +242,8 @@ struct i2c_handle_s {
 	enum i2c_state_e i2c_state;		/* Communication state    */
 	enum i2c_mode_e i2c_mode;		/* Communication mode     */
 	uint32_t i2c_err;			/* Error code             */
+	uint32_t saved_timing;			/* Saved timing value     */
+	uint32_t saved_frequency;		/* Saved frequency value  */
 };
 
 #define I2C_ADDRESSINGMODE_7BIT		0x00000001U
@@ -294,10 +300,9 @@ struct i2c_handle_s {
 /* STM32 specific defines */
 #define STM32_I2C_RISE_TIME_DEFAULT		25	/* ns */
 #define STM32_I2C_FALL_TIME_DEFAULT		10	/* ns */
-#define STM32_I2C_SPEED_DEFAULT			I2C_SPEED_STANDARD
 #define STM32_I2C_ANALOG_FILTER_DELAY_MIN	50	/* ns */
 #define STM32_I2C_ANALOG_FILTER_DELAY_MAX	260	/* ns */
-#define STM32_I2C_DIGITAL_FILTER_MAX		16
+#define STM32_I2C_DIGITAL_FILTER_MAX		16U
 
 int stm32_i2c_get_setup_from_fdt(void *fdt, int node,
 				 struct stm32_i2c_init_s *init);
diff --git a/include/drivers/st/stm32_iwdg.h b/include/drivers/st/stm32_iwdg.h
index bad25244a8..a69701a764 100644
--- a/include/drivers/st/stm32_iwdg.h
+++ b/include/drivers/st/stm32_iwdg.h
@@ -10,8 +10,6 @@
 #include <stdint.h>
 
 #define IWDG_HW_ENABLED			BIT(0)
-#define IWDG_DISABLE_ON_STOP		BIT(1)
-#define IWDG_DISABLE_ON_STANDBY		BIT(2)
 
 int stm32_iwdg_init(void);
 void stm32_iwdg_refresh(void);
diff --git a/include/drivers/st/stm32_mce.h b/include/drivers/st/stm32_mce.h
new file mode 100644
index 0000000000..81c4d20d73
--- /dev/null
+++ b/include/drivers/st/stm32_mce.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2020-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32_MCE_H
+#define STM32_MCE_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <dt-bindings/soc/stm32mp13-mce.h>
+
+/* MCE encryption modes */
+#define MCE_BYPASS_MODE			MCE_PLAINTEXT
+#define MCE_ENCRYPT_MODE		MCE_ENCRYPT
+#define MCE_ENCRYPTION_MODE_MAX		MCE_ENCRYPT_MODE
+
+/* IP configuration */
+#define MCE_IP_MAX_REGION_NB		1U
+
+struct stm32_mce_region_s {
+	uint32_t encrypt_mode;	/*
+				 * Specifies the region encryption mode.
+				 * This parameter can be a value of
+				 * @ref MCE_*_MODE (in driver header file).
+				 */
+	uint32_t start_address;	/* Specifies the region start address */
+	uint32_t end_address;	/* Specifies the region end address */
+};
+
+void stm32_mce_init(void);
+
+int stm32_mce_write_master_key(uint8_t *mkey);
+void stm32_mce_lock_master_key(void);
+bool stm32_mce_is_master_key_locked(void);
+
+void stm32_mce_lock_global(void);
+bool stm32_mce_is_globally_locked(void);
+bool stm32_mce_is_hw_encryption_functional(void);
+
+int stm32_mce_get_address_encryption_state(uint32_t address, uint32_t *state);
+
+void stm32_mce_reload_configuration(void);
+#endif /* STM32_MCE_H */
diff --git a/include/drivers/st/stm32_ospi.h b/include/drivers/st/stm32_ospi.h
new file mode 100644
index 0000000000..932ebd46f9
--- /dev/null
+++ b/include/drivers/st/stm32_ospi.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32_OSPI_H
+#define STM32_OSPI_H
+
+int stm32_ospi_init(void);
+
+#endif /* STM32_OSPI_H */
diff --git a/include/drivers/st/stm32_pka.h b/include/drivers/st/stm32_pka.h
index ad4690ae50..34b3f6b5fd 100644
--- a/include/drivers/st/stm32_pka.h
+++ b/include/drivers/st/stm32_pka.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,24 +9,11 @@
 
 #include <stdint.h>
 
-#if !PKA_USE_NIST_P256 && !PKA_USE_BRAINPOOL_P256R1 && !PKA_USE_BRAINPOOL_P256T1 && \
-	!PKA_USE_NIST_P521
-#error "At least one ECDSA curve needs to be selected"
-#endif
-
 enum stm32_pka_ecdsa_curve_id {
-#if PKA_USE_NIST_P256
 	PKA_NIST_P256,
-#endif
-#if PKA_USE_BRAINPOOL_P256R1
 	PKA_BRAINPOOL_P256R1,
-#endif
-#if PKA_USE_BRAINPOOL_P256T1
 	PKA_BRAINPOOL_P256T1,
-#endif
-#if PKA_USE_NIST_P521
 	PKA_NIST_P521,
-#endif
 };
 
 struct stm32_pka_platdata {
diff --git a/include/drivers/st/stm32_rifsc.h b/include/drivers/st/stm32_rifsc.h
new file mode 100644
index 0000000000..b720eac985
--- /dev/null
+++ b/include/drivers/st/stm32_rifsc.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RIFSC_H
+#define STM32MP2_RIFSC_H
+
+/*
+ * stm32_rifsc_semaphore_init() - Takes RIFSC semaphore for some IDs
+ *
+ * Return 0 on success and -EACCES if authorized semaphore couldn't be taken
+ */
+int stm32_rifsc_semaphore_init(void);
+
+#endif /* STM32MP2_RIFSC_H */
diff --git a/include/drivers/st/stm32mp1_clk.h b/include/drivers/st/stm32mp1_clk.h
index e2395bc5cd..c9b16bf5e0 100644
--- a/include/drivers/st/stm32mp1_clk.h
+++ b/include/drivers/st/stm32mp1_clk.h
@@ -23,7 +23,7 @@ enum stm32mp_osc_id {
 extern const char *stm32mp_osc_node_label[NB_OSC];
 
 int stm32mp1_clk_probe(void);
-int stm32mp1_clk_init(void);
+int stm32mp1_clk_init(uint32_t pll1_freq_khz);
 
 bool stm32mp1_rcc_is_secure(void);
 bool stm32mp1_rcc_is_mckprot(void);
@@ -32,6 +32,8 @@ bool stm32mp1_rcc_is_mckprot(void);
 void stm32mp1_clk_rcc_regs_lock(void);
 void stm32mp1_clk_rcc_regs_unlock(void);
 
+void stm32mp1_clk_mcuss_protect(bool enable);
+
 #ifdef STM32MP_SHARED_RESOURCES
 void stm32mp1_register_clock_parents_secure(unsigned long id);
 #endif
diff --git a/include/drivers/st/stm32mp1_ddr.h b/include/drivers/st/stm32mp1_ddr.h
index df71f35b1f..cadbed5003 100644
--- a/include/drivers/st/stm32mp1_ddr.h
+++ b/include/drivers/st/stm32mp1_ddr.h
@@ -8,7 +8,6 @@
 #define STM32MP1_DDR_H
 
 #include <stdbool.h>
-#include <stdint.h>
 
 #include <drivers/st/stm32mp_ddr.h>
 
@@ -126,6 +125,8 @@ struct stm32mp_ddr_config {
 	struct stm32mp1_ddrctrl_perf c_perf;
 	struct stm32mp1_ddrphy_reg p_reg;
 	struct stm32mp1_ddrphy_timing p_timing;
+	bool self_refresh;
+	uint32_t zdata;
 };
 
 int stm32mp1_ddr_clk_enable(struct stm32mp_ddr_priv *priv, uint32_t mem_speed);
diff --git a/include/drivers/st/stm32mp1_ddr_helpers.h b/include/drivers/st/stm32mp1_ddr_helpers.h
index 38f24152a9..f8c586958a 100644
--- a/include/drivers/st/stm32mp1_ddr_helpers.h
+++ b/include/drivers/st/stm32mp1_ddr_helpers.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2018, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,20 @@
 #ifndef STM32MP1_DDR_HELPERS_H
 #define STM32MP1_DDR_HELPERS_H
 
+#include <stdint.h>
+
+enum stm32mp1_ddr_sr_mode {
+	DDR_SR_MODE_INVALID = 0,
+	DDR_SSR_MODE,
+	DDR_HSR_MODE,
+	DDR_ASR_MODE,
+};
+
 void ddr_enable_clock(void);
+int ddr_sw_self_refresh_exit(void);
+uint32_t ddr_get_io_calibration_val(void);
+int ddr_standby_sr_entry(void);
+enum stm32mp1_ddr_sr_mode ddr_read_sr_mode(void);
+void ddr_set_sr_mode(enum stm32mp1_ddr_sr_mode mode);
 
 #endif /* STM32MP1_DDR_HELPERS_H */
diff --git a/include/drivers/st/stm32mp1_ddr_regs.h b/include/drivers/st/stm32mp1_ddr_regs.h
index 2fbe1c8a58..c3ab10c161 100644
--- a/include/drivers/st/stm32mp1_ddr_regs.h
+++ b/include/drivers/st/stm32mp1_ddr_regs.h
@@ -161,6 +161,7 @@ struct stm32mp_ddrphy {
 #define DDRPHYC_PTR0_TITMSRST_OFFSET		18
 #define DDRPHYC_PTR0_TITMSRST_MASK		GENMASK(21, 18)
 
+#define DDRPHYC_ACIOCR_ACOE			BIT(1)
 #define DDRPHYC_ACIOCR_ACPDD			BIT(3)
 #define DDRPHYC_ACIOCR_ACPDR			BIT(4)
 #define DDRPHYC_ACIOCR_CKPDD_MASK		GENMASK(10, 8)
@@ -180,6 +181,7 @@ struct stm32mp_ddrphy {
 #define DDRPHYC_DSGCR_ODTPDD_MASK		GENMASK(23, 20)
 #define DDRPHYC_DSGCR_ODTPDD_0			BIT(20)
 #define DDRPHYC_DSGCR_NL2PD			BIT(24)
+#define DDRPHYC_DSGCR_CKOE			BIT(28)
 
 #define DDRPHYC_ZQ0CRN_ZDATA_MASK		GENMASK(27, 0)
 #define DDRPHYC_ZQ0CRN_ZDATA_SHIFT		0
diff --git a/include/drivers/st/stm32mp1_ram.h b/include/drivers/st/stm32mp1_ram.h
index 38360e7595..adecd409df 100644
--- a/include/drivers/st/stm32mp1_ram.h
+++ b/include/drivers/st/stm32mp1_ram.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2018, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2015-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,7 @@
 #ifndef STM32MP1_RAM_H
 #define STM32MP1_RAM_H
 
+bool stm32mp1_ddr_is_restored(void);
 int stm32mp1_ddr_probe(void);
 
 #endif /* STM32MP1_RAM_H */
diff --git a/include/drivers/st/stm32mp2_clk.h b/include/drivers/st/stm32mp2_clk.h
new file mode 100644
index 0000000000..4e2ea10acf
--- /dev/null
+++ b/include/drivers/st/stm32mp2_clk.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018-2020, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_CLK_H
+#define STM32MP2_CLK_H
+
+#include <platform_def.h>
+
+enum stm32mp_osc_id {
+	_HSI,
+	_HSE,
+	_CSI,
+	_LSI,
+	_LSE,
+	_I2S_CKIN,
+	_SPDIF_SYMB,
+	NB_OSC,
+	_UNKNOWN_OSC_ID = 0xFF
+};
+
+extern const char *stm32mp_osc_node_label[NB_OSC];
+
+enum pll_cfg {
+	FBDIV,
+	REFDIV,
+	POSTDIV1,
+	POSTDIV2,
+	PLLCFG_NB
+};
+
+enum pll_csg {
+	DIVVAL,
+	SPREAD,
+	DOWNSPREAD,
+	PLLCSG_NB
+};
+
+int stm32mp2_clk_init(void);
+int stm32mp2_pll1_disable(void);
+
+#endif /* STM32MP2_CLK_H */
diff --git a/include/drivers/st/stm32mp2_ddr.h b/include/drivers/st/stm32mp2_ddr.h
new file mode 100644
index 0000000000..283370047a
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ddr.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DDR_H
+#define STM32MP2_DDR_H
+
+#include <stdbool.h>
+
+#include <drivers/st/stm32mp_ddr.h>
+
+#include <ddrphy_phyinit_struct.h>
+
+struct stm32mp2_ddrctrl_reg {
+	uint32_t mstr;
+	uint32_t mrctrl0;
+	uint32_t mrctrl1;
+	uint32_t mrctrl2;
+	uint32_t derateen;
+	uint32_t derateint;
+	uint32_t deratectl;
+	uint32_t pwrctl;
+	uint32_t pwrtmg;
+	uint32_t hwlpctl;
+	uint32_t rfshctl0;
+	uint32_t rfshctl1;
+	uint32_t rfshctl3;
+	uint32_t crcparctl0;
+	uint32_t crcparctl1;
+	uint32_t init0;
+	uint32_t init1;
+	uint32_t init2;
+	uint32_t init3;
+	uint32_t init4;
+	uint32_t init5;
+	uint32_t init6;
+	uint32_t init7;
+	uint32_t dimmctl;
+	uint32_t rankctl;
+	uint32_t rankctl1;
+	uint32_t zqctl0;
+	uint32_t zqctl1;
+	uint32_t zqctl2;
+	uint32_t dfitmg0;
+	uint32_t dfitmg1;
+	uint32_t dfilpcfg0;
+	uint32_t dfilpcfg1;
+	uint32_t dfiupd0;
+	uint32_t dfiupd1;
+	uint32_t dfiupd2;
+	uint32_t dfimisc;
+	uint32_t dfitmg2;
+	uint32_t dfitmg3;
+	uint32_t dbictl;
+	uint32_t dfiphymstr;
+	uint32_t dbg0;
+	uint32_t dbg1;
+	uint32_t dbgcmd;
+	uint32_t swctl;
+	uint32_t swctlstatic;
+	uint32_t poisoncfg;
+	uint32_t pccfg;
+};
+
+struct stm32mp2_ddrctrl_timing {
+	uint32_t rfshtmg;
+	uint32_t rfshtmg1;
+	uint32_t dramtmg0;
+	uint32_t dramtmg1;
+	uint32_t dramtmg2;
+	uint32_t dramtmg3;
+	uint32_t dramtmg4;
+	uint32_t dramtmg5;
+	uint32_t dramtmg6;
+	uint32_t dramtmg7;
+	uint32_t dramtmg8;
+	uint32_t dramtmg9;
+	uint32_t dramtmg10;
+	uint32_t dramtmg11;
+	uint32_t dramtmg12;
+	uint32_t dramtmg13;
+	uint32_t dramtmg14;
+	uint32_t dramtmg15;
+	uint32_t odtcfg;
+	uint32_t odtmap;
+};
+
+struct stm32mp2_ddrctrl_map {
+	uint32_t addrmap0;
+	uint32_t addrmap1;
+	uint32_t addrmap2;
+	uint32_t addrmap3;
+	uint32_t addrmap4;
+	uint32_t addrmap5;
+	uint32_t addrmap6;
+	uint32_t addrmap7;
+	uint32_t addrmap8;
+	uint32_t addrmap9;
+	uint32_t addrmap10;
+	uint32_t addrmap11;
+};
+
+struct stm32mp2_ddrctrl_perf {
+	uint32_t sched;
+	uint32_t sched1;
+	uint32_t perfhpr1;
+	uint32_t perflpr1;
+	uint32_t perfwr1;
+	uint32_t sched3;
+	uint32_t sched4;
+	uint32_t pcfgr_0;
+	uint32_t pcfgw_0;
+	uint32_t pctrl_0;
+	uint32_t pcfgqos0_0;
+	uint32_t pcfgqos1_0;
+	uint32_t pcfgwqos0_0;
+	uint32_t pcfgwqos1_0;
+#if STM32MP_DDR_DUAL_AXI_PORT
+	uint32_t pcfgr_1;
+	uint32_t pcfgw_1;
+	uint32_t pctrl_1;
+	uint32_t pcfgqos0_1;
+	uint32_t pcfgqos1_1;
+	uint32_t pcfgwqos0_1;
+	uint32_t pcfgwqos1_1;
+#endif /* STM32MP_DDR_DUAL_AXI_PORT */
+};
+
+struct stm32mp_ddr_config {
+	struct stm32mp_ddr_info info;
+	struct stm32mp2_ddrctrl_reg c_reg;
+	struct stm32mp2_ddrctrl_timing c_timing;
+	struct stm32mp2_ddrctrl_map c_map;
+	struct stm32mp2_ddrctrl_perf c_perf;
+	bool self_refresh;
+	uint32_t zdata;
+	struct user_input_basic uib;
+	struct user_input_advanced uia;
+	struct user_input_mode_register uim;
+	struct user_input_swizzle uis;
+};
+
+void stm32mp2_ddr_init(struct stm32mp_ddr_priv *priv, struct stm32mp_ddr_config *config);
+
+#endif /* STM32MP2_DDR_H */
diff --git a/include/drivers/st/stm32mp2_ddr_helpers.h b/include/drivers/st/stm32mp2_ddr_helpers.h
new file mode 100644
index 0000000000..a1aa7a52d7
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ddr_helpers.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DDR_HELPERS_H
+#define STM32MP2_DDR_HELPERS_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <drivers/st/stm32mp2_ddr_regs.h>
+
+enum stm32mp2_ddr_sr_mode {
+	DDR_SR_MODE_INVALID = 0,
+	DDR_SSR_MODE,
+	DDR_HSR_MODE,
+	DDR_ASR_MODE,
+};
+
+void ddr_activate_controller(struct stm32mp_ddrctl *ctl, bool sr_entry);
+void ddr_wait_lp3_mode(bool state);
+int ddr_sr_exit_loop(void);
+bool is_ddr_cid_filtering_enabled(void);
+void ddr_enable_cid_filtering(void);
+void ddr_disable_cid_filtering(void);
+uint32_t ddr_get_io_calibration_val(void);
+int ddr_sr_entry(bool standby);
+int ddr_sr_exit(void);
+enum stm32mp2_ddr_sr_mode ddr_read_sr_mode(void);
+void ddr_set_sr_mode(enum stm32mp2_ddr_sr_mode mode);
+void ddr_save_sr_mode(void);
+void ddr_restore_sr_mode(void);
+void ddr_sub_system_clk_init(void);
+void ddr_sub_system_clk_off(void);
+
+#endif /* STM32MP2_DDR_HELPERS_H */
diff --git a/include/drivers/st/stm32mp2_ddr_regs.h b/include/drivers/st/stm32mp2_ddr_regs.h
new file mode 100644
index 0000000000..78a3e90037
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ddr_regs.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DDR_REGS_H
+#define STM32MP2_DDR_REGS_H
+
+#include <drivers/st/stm32mp_ddrctrl_regs.h>
+#include <lib/utils_def.h>
+
+/* DDR Physical Interface Control (DDRPHYC) registers*/
+struct stm32mp_ddrphy {
+	uint32_t dummy;
+} __packed;
+
+/* DDRPHY registers offsets */
+#define DDRPHY_INITENG0_P0_SEQ0BDISABLEFLAG6	U(0x240004)
+#define DDRPHY_INITENG0_P0_PHYINLPX		U(0x2400A0)
+#define DDRPHY_DRTUB0_UCCLKHCLKENABLES		U(0x300200)
+#define DDRPHY_APBONLY0_MICROCONTMUXSEL		U(0x340000)
+
+/* DDRPHY registers fields */
+#define DDRPHY_INITENG0_P0_PHYINLPX_PHYINLP3			BIT(0)
+#define DDRPHY_DRTUB0_UCCLKHCLKENABLES_UCCLKEN			BIT(0)
+#define DDRPHY_DRTUB0_UCCLKHCLKENABLES_HCLKEN			BIT(1)
+#define DDRPHY_APBONLY0_MICROCONTMUXSEL_MICROCONTMUXSEL		BIT(0)
+
+/* DDRDBG registers offsets */
+#define DDRDBG_LP_DISABLE			U(0x0)
+#define DDRDBG_BYPASS_PCLKEN			U(0x4)
+
+/* DDRDBG registers fields */
+#define DDRDBG_LP_DISABLE_LPI_XPI_DISABLE	BIT(0)
+#define DDRDBG_LP_DISABLE_LPI_DDRC_DISABLE	BIT(8)
+
+#endif /* STM32MP2_DDR_REGS_H */
diff --git a/include/drivers/st/stm32mp2_pwr.h b/include/drivers/st/stm32mp2_pwr.h
new file mode 100644
index 0000000000..2b2c401363
--- /dev/null
+++ b/include/drivers/st/stm32mp2_pwr.h
@@ -0,0 +1,481 @@
+/*
+ * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_PWR_H
+#define STM32MP2_PWR_H
+
+#include <lib/utils_def.h>
+
+#define PWR_CR1					U(0x00)
+#define PWR_CR2					U(0x04)
+#define PWR_CR3					U(0x08)
+#define PWR_CR4					U(0x0C)
+#define PWR_CR5					U(0x10)
+#define PWR_CR6					U(0x14)
+#define PWR_CR7					U(0x18)
+#define PWR_CR8					U(0x1C)
+#define PWR_CR9					U(0x20)
+#define PWR_CR10				U(0x24)
+#define PWR_CR11				U(0x28)
+#define PWR_CR12				U(0x2C)
+#define PWR_UCPDR				U(0x30)
+#define PWR_BDCR1				U(0x38)
+#define PWR_BDCR2				U(0x3C)
+#define PWR_CPU1CR				U(0x40)
+#define PWR_CPU2CR				U(0x44)
+#define PWR_CPU3CR				U(0x48)
+#define PWR_D1CR				U(0x4C)
+#define PWR_D2CR				U(0x50)
+#define PWR_D3CR				U(0x54)
+#define PWR_WKUPCR1				U(0x60)
+#define PWR_WKUPCR2				U(0x64)
+#define PWR_WKUPCR3				U(0x68)
+#define PWR_WKUPCR4				U(0x6C)
+#define PWR_WKUPCR5				U(0x70)
+#define PWR_WKUPCR6				U(0x74)
+#define PWR_D3WKUPENR				U(0x98)
+#define PWR_RSECCFGR				U(0x100)
+#define PWR_RPRIVCFGR				U(0x104)
+#define PWR_R0CIDCFGR				U(0x108)
+#define PWR_R1CIDCFGR				U(0x10C)
+#define PWR_R2CIDCFGR				U(0x110)
+#define PWR_R3CIDCFGR				U(0x114)
+#define PWR_R4CIDCFGR				U(0x118)
+#define PWR_R5CIDCFGR				U(0x11C)
+#define PWR_R6CIDCFGR				U(0x120)
+#define PWR_WIOSECCFGR				U(0x180)
+#define PWR_WIOPRIVCFGR				U(0x184)
+#define PWR_WIO1CIDCFGR				U(0x188)
+#define PWR_WIO1SEMCR				U(0x18C)
+#define PWR_WIO2CIDCFGR				U(0x190)
+#define PWR_WIO2SEMCR				U(0x194)
+#define PWR_WIO3CIDCFGR				U(0x198)
+#define PWR_WIO3SEMCR				U(0x19C)
+#define PWR_WIO4CIDCFGR				U(0x1A0)
+#define PWR_WIO4SEMCR				U(0x1A4)
+#define PWR_WIO5CIDCFGR				U(0x1A8)
+#define PWR_WIO5SEMCR				U(0x1AC)
+#define PWR_WIO6CIDCFGR				U(0x1B0)
+#define PWR_WIO6SEMCR				U(0x1B4)
+#define PWR_CPU1D1SR				U(0x200)
+#define PWR_CPU2D2SR				U(0x204)
+#define PWR_CPU3D3SR				U(0x208)
+#define PWR_DBGR				U(0x308)
+#define PWR_VERR				U(0x3F4)
+#define PWR_IPIDR				U(0x3F8)
+#define PWR_SIDR				U(0x3FC)
+
+/* PWR_CR1 register fields */
+#define PWR_CR1_VDDIO3VMEN			BIT(0)
+#define PWR_CR1_VDDIO4VMEN			BIT(1)
+#define PWR_CR1_USB33VMEN			BIT(2)
+#define PWR_CR1_UCPDVMEN			BIT(3)
+#define PWR_CR1_AVMEN				BIT(4)
+#define PWR_CR1_VDDIO3SV			BIT(8)
+#define PWR_CR1_VDDIO4SV			BIT(9)
+#define PWR_CR1_USB33SV				BIT(10)
+#define PWR_CR1_UCPDSV				BIT(11)
+#define PWR_CR1_ASV				BIT(12)
+#define PWR_CR1_VDDIO3RDY			BIT(16)
+#define PWR_CR1_VDDIO4RDY			BIT(17)
+#define PWR_CR1_USB33RDY			BIT(18)
+#define PWR_CR1_UCPDRDY				BIT(19)
+#define PWR_CR1_ARDY				BIT(20)
+#define PWR_CR1_VDDIOVRSEL			BIT(24)
+#define PWR_CR1_VDDIO3VRSEL			BIT(25)
+#define PWR_CR1_VDDIO4VRSEL			BIT(26)
+#define PWR_CR1_GPVMO				BIT(31)
+
+/* PWR_CR2 register fields */
+#define PWR_CR2_MONEN				BIT(0)
+#define PWR_CR2_VBATL				BIT(8)
+#define PWR_CR2_VBATH				BIT(9)
+#define PWR_CR2_TEMPL				BIT(10)
+#define PWR_CR2_TEMPH				BIT(11)
+
+/* PWR_CR3 register fields */
+#define PWR_CR3_PVDEN				BIT(0)
+#define PWR_CR3_PVDO				BIT(8)
+
+/* PWR_CR5 register fields */
+#define PWR_CR5_VCOREMONEN			BIT(0)
+#define PWR_CR5_VCOREL				BIT(8)
+#define PWR_CR5_VCOREH				BIT(9)
+
+/* PWR_CR6 register fields */
+#define PWR_CR6_VCPUMONEN			BIT(0)
+#define PWR_CR6_VCPULLS				BIT(4)
+#define PWR_CR6_VCPUL				BIT(8)
+#define PWR_CR6_VCPUH				BIT(9)
+
+/* PWR_CR7 register fields */
+#define PWR_CR7_VDDIO2VMEN			BIT(0)
+#define PWR_CR7_VDDIO2SV			BIT(8)
+#define PWR_CR7_VDDIO2RDY			BIT(16)
+#define PWR_CR7_VDDIO2VRSEL			BIT(24)
+#define PWR_CR7_VDDIO2VRSTBY			BIT(25)
+
+/* PWR_CR8 register fields */
+#define PWR_CR8_VDDIO1VMEN			BIT(0)
+#define PWR_CR8_VDDIO1SV			BIT(8)
+#define PWR_CR8_VDDIO1RDY			BIT(16)
+#define PWR_CR8_VDDIO1VRSEL			BIT(24)
+#define PWR_CR8_VDDIO1VRSTBY			BIT(25)
+
+/* PWR_CR9 register fields */
+#define PWR_CR9_BKPRBSEN			BIT(0)
+#define PWR_CR9_LPR1BSEN			BIT(4)
+
+/* PWR_CR10 register fields */
+#define PWR_CR10_RETRBSEN_MASK			GENMASK(1, 0)
+#define PWR_CR10_RETRBSEN_SHIFT			0
+#define PWR_CR10_RETRBSEN_DISABLE		0U
+#define PWR_CR10_RETRBSEN_STANDBY_VBAT		1U
+#define PWR_CR10_RETRBSEN_STANDBY		2U
+
+/* PWR_CR11 register fields */
+#define PWR_CR11_DDRRETDIS			BIT(0)
+
+/* PWR_CR12 register fields */
+#define PWR_CR12_GPUVMEN			BIT(0)
+#define PWR_CR12_GPULVTEN			BIT(1)
+#define PWR_CR12_GPUSV				BIT(8)
+#define PWR_CR12_VDDGPURDY			BIT(16)
+
+/* PWR_UCPDR register fields */
+#define PWR_UCPDR_UCPD_DBDIS			BIT(0)
+#define PWR_UCPDR_UCPD_STBY			BIT(1)
+
+/* PWR_BDCR1 register fields */
+#define PWR_BDCR1_DBD3P				BIT(0)
+
+/* PWR_BDCR2 register fields */
+#define PWR_BDCR2_DBP				BIT(0)
+
+/* PWR_CPU1CR register fields */
+#define PWR_CPU1CR_PDDS_D2			BIT(0)
+#define PWR_CPU1CR_PDDS_D1			BIT(1)
+#define PWR_CPU1CR_VBF				BIT(4)
+#define PWR_CPU1CR_STOPF			BIT(5)
+#define PWR_CPU1CR_SBF				BIT(6)
+#define PWR_CPU1CR_SBF_D1			BIT(7)
+#define PWR_CPU1CR_SBF_D3			BIT(8)
+#define PWR_CPU1CR_CSSF				BIT(9)
+#define PWR_CPU1CR_STANDBYWFIL2			BIT(15)
+#define PWR_CPU1CR_LPDS_D1			BIT(16)
+#define PWR_CPU1CR_LVDS_D1			BIT(17)
+
+/* PWR_CPU2CR register fields */
+#define PWR_CPU2CR_PDDS_D2			BIT(0)
+#define PWR_CPU2CR_VBF				BIT(4)
+#define PWR_CPU2CR_STOPF			BIT(5)
+#define PWR_CPU2CR_SBF				BIT(6)
+#define PWR_CPU2CR_SBF_D2			BIT(7)
+#define PWR_CPU2CR_SBF_D3			BIT(8)
+#define PWR_CPU2CR_CSSF				BIT(9)
+#define PWR_CPU2CR_DEEPSLEEP			BIT(15)
+#define PWR_CPU2CR_LPDS_D2			BIT(16)
+#define PWR_CPU2CR_LVDS_D2			BIT(17)
+
+/* PWR_CPU3CR register fields */
+#define PWR_CPU3CR_VBF				BIT(4)
+#define PWR_CPU3CR_SBF_D3			BIT(8)
+#define PWR_CPU3CR_CSSF				BIT(9)
+#define PWR_CPU3CR_DEEPSLEEP			BIT(15)
+
+/* PWR_D1CR register fields */
+#define PWR_D1CR_LPCFG_D1			BIT(0)
+#define PWR_D1CR_POPL_D1_MASK			GENMASK(12, 8)
+#define PWR_D1CR_POPL_D1_SHIFT			8
+
+/* PWR_D2CR register fields */
+#define PWR_D2CR_LPCFG_D2			BIT(0)
+#define PWR_D2CR_POPL_D2_MASK			GENMASK(12, 8)
+#define PWR_D2CR_POPL_D2_SHIFT			8
+#define PWR_D2CR_LPLVDLY_D2_MASK		GENMASK(18, 16)
+#define PWR_D2CR_LPLVDLY_D2_SHIFT		16
+#define PWR_D2CR_PODH_D2_MASK			GENMASK(27, 24)
+#define PWR_D2CR_PODH_D2_SHIFT			24
+
+/* PWR_D3CR register fields */
+#define PWR_D3CR_PDDS_D3			BIT(0)
+#define PWR_D3CR_D3RDY				BIT(31)
+
+/* PWR_WKUPCR1 register fields */
+#define PWR_WKUPCR1_WKUPC			BIT(0)
+#define PWR_WKUPCR1_WKUPP			BIT(8)
+#define PWR_WKUPCR1_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR1_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR1_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR1_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR1_WKUPF			BIT(31)
+
+/* PWR_WKUPCR2 register fields */
+#define PWR_WKUPCR2_WKUPC			BIT(0)
+#define PWR_WKUPCR2_WKUPP			BIT(8)
+#define PWR_WKUPCR2_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR2_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR2_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR2_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR2_WKUPF			BIT(31)
+
+/* PWR_WKUPCR3 register fields */
+#define PWR_WKUPCR3_WKUPC			BIT(0)
+#define PWR_WKUPCR3_WKUPP			BIT(8)
+#define PWR_WKUPCR3_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR3_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR3_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR3_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR3_WKUPF			BIT(31)
+
+/* PWR_WKUPCR4 register fields */
+#define PWR_WKUPCR4_WKUPC			BIT(0)
+#define PWR_WKUPCR4_WKUPP			BIT(8)
+#define PWR_WKUPCR4_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR4_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR4_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR4_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR4_WKUPF			BIT(31)
+
+/* PWR_WKUPCR5 register fields */
+#define PWR_WKUPCR5_WKUPC			BIT(0)
+#define PWR_WKUPCR5_WKUPP			BIT(8)
+#define PWR_WKUPCR5_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR5_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR5_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR5_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR5_WKUPF			BIT(31)
+
+/* PWR_WKUPCR6 register fields */
+#define PWR_WKUPCR6_WKUPC			BIT(0)
+#define PWR_WKUPCR6_WKUPP			BIT(8)
+#define PWR_WKUPCR6_WKUPPUPD_MASK		GENMASK(13, 12)
+#define PWR_WKUPCR6_WKUPPUPD_SHIFT		12
+#define PWR_WKUPCR6_WKUPENCPU1			BIT(16)
+#define PWR_WKUPCR6_WKUPENCPU2			BIT(17)
+#define PWR_WKUPCR6_WKUPF			BIT(31)
+
+/* PWR_D3WKUPENR register fields */
+#define PWR_D3WKUPENR_TAMP_WKUPEN_D3		BIT(0)
+
+/* PWR_RSECCFGR register fields */
+#define PWR_RSECCFGR_RSEC0			BIT(0)
+#define PWR_RSECCFGR_RSEC1			BIT(1)
+#define PWR_RSECCFGR_RSEC2			BIT(2)
+#define PWR_RSECCFGR_RSEC3			BIT(3)
+#define PWR_RSECCFGR_RSEC4			BIT(4)
+#define PWR_RSECCFGR_RSEC5			BIT(5)
+#define PWR_RSECCFGR_RSEC6			BIT(6)
+
+/* PWR_RPRIVCFGR register fields */
+#define PWR_RPRIVCFGR_RPRIV0			BIT(0)
+#define PWR_RPRIVCFGR_RPRIV1			BIT(1)
+#define PWR_RPRIVCFGR_RPRIV2			BIT(2)
+#define PWR_RPRIVCFGR_RPRIV3			BIT(3)
+#define PWR_RPRIVCFGR_RPRIV4			BIT(4)
+#define PWR_RPRIVCFGR_RPRIV5			BIT(5)
+#define PWR_RPRIVCFGR_RPRIV6			BIT(6)
+
+/* PWR_R0CIDCFGR register fields */
+#define PWR_R0CIDCFGR_CFEN			BIT(0)
+#define PWR_R0CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R0CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R1CIDCFGR register fields */
+#define PWR_R1CIDCFGR_CFEN			BIT(0)
+#define PWR_R1CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R1CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R2CIDCFGR register fields */
+#define PWR_R2CIDCFGR_CFEN			BIT(0)
+#define PWR_R2CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R2CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R3CIDCFGR register fields */
+#define PWR_R3CIDCFGR_CFEN			BIT(0)
+#define PWR_R3CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R3CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R4CIDCFGR register fields */
+#define PWR_R4CIDCFGR_CFEN			BIT(0)
+#define PWR_R4CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R4CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R5CIDCFGR register fields */
+#define PWR_R5CIDCFGR_CFEN			BIT(0)
+#define PWR_R5CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R5CIDCFGR_SCID_SHIFT		4
+
+/* PWR_R6CIDCFGR register fields */
+#define PWR_R6CIDCFGR_CFEN			BIT(0)
+#define PWR_R6CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define PWR_R6CIDCFGR_SCID_SHIFT		4
+
+/* PWR_WIOSECCFGR register fields */
+#define PWR_WIOSECCFGR_WIOSEC1			BIT(0)
+#define PWR_WIOSECCFGR_WIOSEC2			BIT(1)
+#define PWR_WIOSECCFGR_WIOSEC3			BIT(2)
+#define PWR_WIOSECCFGR_WIOSEC4			BIT(3)
+#define PWR_WIOSECCFGR_WIOSEC5			BIT(4)
+#define PWR_WIOSECCFGR_WIOSEC6			BIT(5)
+
+/* PWR_WIOPRIVCFGR register fields */
+#define PWR_WIOPRIVCFGR_WIOPRIV1		BIT(0)
+#define PWR_WIOPRIVCFGR_WIOPRIV2		BIT(1)
+#define PWR_WIOPRIVCFGR_WIOPRIV3		BIT(2)
+#define PWR_WIOPRIVCFGR_WIOPRIV4		BIT(3)
+#define PWR_WIOPRIVCFGR_WIOPRIV5		BIT(4)
+#define PWR_WIOPRIVCFGR_WIOPRIV6		BIT(5)
+
+/* PWR_WIO1CIDCFGR register fields */
+#define PWR_WIO1CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO1CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO1CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO1CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO1CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO1CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO1CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO1CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO1CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO1CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO1CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO1CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO1SEMCR register fields */
+#define PWR_WIO1SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO1SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO1SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO2CIDCFGR register fields */
+#define PWR_WIO2CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO2CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO2CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO2CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO2CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO2CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO2CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO2CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO2CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO2CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO2CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO2CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO2SEMCR register fields */
+#define PWR_WIO2SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO2SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO2SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO3CIDCFGR register fields */
+#define PWR_WIO3CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO3CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO3CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO3CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO3CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO3CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO3CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO3CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO3CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO3CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO3CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO3CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO3SEMCR register fields */
+#define PWR_WIO3SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO3SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO3SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO4CIDCFGR register fields */
+#define PWR_WIO4CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO4CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO4CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO4CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO4CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO4CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO4CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO4CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO4CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO4CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO4CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO4CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO4SEMCR register fields */
+#define PWR_WIO4SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO4SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO4SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO5CIDCFGR register fields */
+#define PWR_WIO5CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO5CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO5CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO5CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO5CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO5CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO5CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO5CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO5CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO5CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO5CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO5CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO5SEMCR register fields */
+#define PWR_WIO5SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO5SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO5SEMCR_SEMCID_SHIFT		4
+
+/* PWR_WIO6CIDCFGR register fields */
+#define PWR_WIO6CIDCFGR_CFEN			BIT(0)
+#define PWR_WIO6CIDCFGR_SEM_EN			BIT(1)
+#define PWR_WIO6CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define PWR_WIO6CIDCFGR_SCID_SHIFT		4
+#define PWR_WIO6CIDCFGR_SEMWLC0			BIT(16)
+#define PWR_WIO6CIDCFGR_SEMWLC1			BIT(17)
+#define PWR_WIO6CIDCFGR_SEMWLC2			BIT(18)
+#define PWR_WIO6CIDCFGR_SEMWLC3			BIT(19)
+#define PWR_WIO6CIDCFGR_SEMWLC4			BIT(20)
+#define PWR_WIO6CIDCFGR_SEMWLC5			BIT(21)
+#define PWR_WIO6CIDCFGR_SEMWLC6			BIT(22)
+#define PWR_WIO6CIDCFGR_SEMWLC7			BIT(23)
+
+/* PWR_WIO6SEMCR register fields */
+#define PWR_WIO6SEMCR_SEM_MUTEX			BIT(0)
+#define PWR_WIO6SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define PWR_WIO6SEMCR_SEMCID_SHIFT		4
+
+/* PWR_CPU1D1SR register fields */
+#define PWR_CPU1D1SR_HOLD_BOOT			BIT(0)
+#define PWR_CPU1D1SR_CSTATE_MASK		GENMASK(3, 2)
+#define PWR_CPU1D1SR_CSTATE_SHIFT		2
+#define PWR_CPU1D1SR_DSTATE_MASK		GENMASK(10, 8)
+#define PWR_CPU1D1SR_DSTATE_SHIFT		8
+
+/* PWR_CPU2D2SR register fields */
+#define PWR_CPU2D2SR_HOLD_BOOT			BIT(0)
+#define PWR_CPU2D2SR_WFBEN			BIT(1)
+#define PWR_CPU2D2SR_CSTATE_MASK		GENMASK(3, 2)
+#define PWR_CPU2D2SR_CSTATE_SHIFT		2
+#define PWR_CPU2D2SR_DSTATE_MASK		GENMASK(10, 8)
+#define PWR_CPU2D2SR_DSTATE_SHIFT		8
+
+/* PWR_CPU3D3SR register fields */
+#define PWR_CPU3D3SR_CSTATE_MASK		GENMASK(3, 2)
+#define PWR_CPU3D3SR_CSTATE_SHIFT		2
+#define PWR_CPU3D3SR_DSTATE_MASK		GENMASK(10, 8)
+#define PWR_CPU3D3SR_DSTATE_SHIFT		8
+
+/* PWR_DBGR register fields */
+#define PWR_DBGR_FD3S				BIT(0)
+#define PWR_DBGR_VDDIOKRETRAM			BIT(16)
+#define PWR_DBGR_VDDIOKBKPRAM			BIT(17)
+#define PWR_DBGR_VDDIOKD3			BIT(18)
+#define PWR_DBGR_VDDIOKLPSRAM1			BIT(19)
+
+/* PWR_VERR register fields */
+#define PWR_VERR_MINREV_MASK			GENMASK(3, 0)
+#define PWR_VERR_MINREV_SHIFT			0
+#define PWR_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define PWR_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP2_PWR_H */
diff --git a/include/drivers/st/stm32mp2_ram.h b/include/drivers/st/stm32mp2_ram.h
new file mode 100644
index 0000000000..7bda830608
--- /dev/null
+++ b/include/drivers/st/stm32mp2_ram.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RAM_H
+#define STM32MP2_RAM_H
+
+bool stm32mp2_ddr_is_restored(void);
+int stm32mp2_ddr_probe(void);
+
+#endif /* STM32MP2_RAM_H */
diff --git a/include/drivers/st/stm32mp2_rcc.h b/include/drivers/st/stm32mp2_rcc.h
new file mode 100644
index 0000000000..5ac8ac2593
--- /dev/null
+++ b/include/drivers/st/stm32mp2_rcc.h
@@ -0,0 +1,4982 @@
+/*
+ * Copyright (c) 2018-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RCC_H
+#define STM32MP2_RCC_H
+
+#include <lib/utils_def.h>
+
+#define RCC_SECCFGR0				U(0x0)
+#define RCC_SECCFGR1				U(0x4)
+#define RCC_SECCFGR2				U(0x8)
+#define RCC_SECCFGR3				U(0xC)
+#define RCC_PRIVCFGR0				U(0x10)
+#define RCC_PRIVCFGR1				U(0x14)
+#define RCC_PRIVCFGR2				U(0x18)
+#define RCC_PRIVCFGR3				U(0x1C)
+#define RCC_RCFGLOCKR0				U(0x20)
+#define RCC_RCFGLOCKR1				U(0x24)
+#define RCC_RCFGLOCKR2				U(0x28)
+#define RCC_RCFGLOCKR3				U(0x2C)
+#define RCC_R0CIDCFGR				U(0x30)
+#define RCC_R0SEMCR				U(0x34)
+#define RCC_R1CIDCFGR				U(0x38)
+#define RCC_R1SEMCR				U(0x3C)
+#define RCC_R2CIDCFGR				U(0x40)
+#define RCC_R2SEMCR				U(0x44)
+#define RCC_R3CIDCFGR				U(0x48)
+#define RCC_R3SEMCR				U(0x4C)
+#define RCC_R4CIDCFGR				U(0x50)
+#define RCC_R4SEMCR				U(0x54)
+#define RCC_R5CIDCFGR				U(0x58)
+#define RCC_R5SEMCR				U(0x5C)
+#define RCC_R6CIDCFGR				U(0x60)
+#define RCC_R6SEMCR				U(0x64)
+#define RCC_R7CIDCFGR				U(0x68)
+#define RCC_R7SEMCR				U(0x6C)
+#define RCC_R8CIDCFGR				U(0x70)
+#define RCC_R8SEMCR				U(0x74)
+#define RCC_R9CIDCFGR				U(0x78)
+#define RCC_R9SEMCR				U(0x7C)
+#define RCC_R10CIDCFGR				U(0x80)
+#define RCC_R10SEMCR				U(0x84)
+#define RCC_R11CIDCFGR				U(0x88)
+#define RCC_R11SEMCR				U(0x8C)
+#define RCC_R12CIDCFGR				U(0x90)
+#define RCC_R12SEMCR				U(0x94)
+#define RCC_R13CIDCFGR				U(0x98)
+#define RCC_R13SEMCR				U(0x9C)
+#define RCC_R14CIDCFGR				U(0xA0)
+#define RCC_R14SEMCR				U(0xA4)
+#define RCC_R15CIDCFGR				U(0xA8)
+#define RCC_R15SEMCR				U(0xAC)
+#define RCC_R16CIDCFGR				U(0xB0)
+#define RCC_R16SEMCR				U(0xB4)
+#define RCC_R17CIDCFGR				U(0xB8)
+#define RCC_R17SEMCR				U(0xBC)
+#define RCC_R18CIDCFGR				U(0xC0)
+#define RCC_R18SEMCR				U(0xC4)
+#define RCC_R19CIDCFGR				U(0xC8)
+#define RCC_R19SEMCR				U(0xCC)
+#define RCC_R20CIDCFGR				U(0xD0)
+#define RCC_R20SEMCR				U(0xD4)
+#define RCC_R21CIDCFGR				U(0xD8)
+#define RCC_R21SEMCR				U(0xDC)
+#define RCC_R22CIDCFGR				U(0xE0)
+#define RCC_R22SEMCR				U(0xE4)
+#define RCC_R23CIDCFGR				U(0xE8)
+#define RCC_R23SEMCR				U(0xEC)
+#define RCC_R24CIDCFGR				U(0xF0)
+#define RCC_R24SEMCR				U(0xF4)
+#define RCC_R25CIDCFGR				U(0xF8)
+#define RCC_R25SEMCR				U(0xFC)
+#define RCC_R26CIDCFGR				U(0x100)
+#define RCC_R26SEMCR				U(0x104)
+#define RCC_R27CIDCFGR				U(0x108)
+#define RCC_R27SEMCR				U(0x10C)
+#define RCC_R28CIDCFGR				U(0x110)
+#define RCC_R28SEMCR				U(0x114)
+#define RCC_R29CIDCFGR				U(0x118)
+#define RCC_R29SEMCR				U(0x11C)
+#define RCC_R30CIDCFGR				U(0x120)
+#define RCC_R30SEMCR				U(0x124)
+#define RCC_R31CIDCFGR				U(0x128)
+#define RCC_R31SEMCR				U(0x12C)
+#define RCC_R32CIDCFGR				U(0x130)
+#define RCC_R32SEMCR				U(0x134)
+#define RCC_R33CIDCFGR				U(0x138)
+#define RCC_R33SEMCR				U(0x13C)
+#define RCC_R34CIDCFGR				U(0x140)
+#define RCC_R34SEMCR				U(0x144)
+#define RCC_R35CIDCFGR				U(0x148)
+#define RCC_R35SEMCR				U(0x14C)
+#define RCC_R36CIDCFGR				U(0x150)
+#define RCC_R36SEMCR				U(0x154)
+#define RCC_R37CIDCFGR				U(0x158)
+#define RCC_R37SEMCR				U(0x15C)
+#define RCC_R38CIDCFGR				U(0x160)
+#define RCC_R38SEMCR				U(0x164)
+#define RCC_R39CIDCFGR				U(0x168)
+#define RCC_R39SEMCR				U(0x16C)
+#define RCC_R40CIDCFGR				U(0x170)
+#define RCC_R40SEMCR				U(0x174)
+#define RCC_R41CIDCFGR				U(0x178)
+#define RCC_R41SEMCR				U(0x17C)
+#define RCC_R42CIDCFGR				U(0x180)
+#define RCC_R42SEMCR				U(0x184)
+#define RCC_R43CIDCFGR				U(0x188)
+#define RCC_R43SEMCR				U(0x18C)
+#define RCC_R44CIDCFGR				U(0x190)
+#define RCC_R44SEMCR				U(0x194)
+#define RCC_R45CIDCFGR				U(0x198)
+#define RCC_R45SEMCR				U(0x19C)
+#define RCC_R46CIDCFGR				U(0x1A0)
+#define RCC_R46SEMCR				U(0x1A4)
+#define RCC_R47CIDCFGR				U(0x1A8)
+#define RCC_R47SEMCR				U(0x1AC)
+#define RCC_R48CIDCFGR				U(0x1B0)
+#define RCC_R48SEMCR				U(0x1B4)
+#define RCC_R49CIDCFGR				U(0x1B8)
+#define RCC_R49SEMCR				U(0x1BC)
+#define RCC_R50CIDCFGR				U(0x1C0)
+#define RCC_R50SEMCR				U(0x1C4)
+#define RCC_R51CIDCFGR				U(0x1C8)
+#define RCC_R51SEMCR				U(0x1CC)
+#define RCC_R52CIDCFGR				U(0x1D0)
+#define RCC_R52SEMCR				U(0x1D4)
+#define RCC_R53CIDCFGR				U(0x1D8)
+#define RCC_R53SEMCR				U(0x1DC)
+#define RCC_R54CIDCFGR				U(0x1E0)
+#define RCC_R54SEMCR				U(0x1E4)
+#define RCC_R55CIDCFGR				U(0x1E8)
+#define RCC_R55SEMCR				U(0x1EC)
+#define RCC_R56CIDCFGR				U(0x1F0)
+#define RCC_R56SEMCR				U(0x1F4)
+#define RCC_R57CIDCFGR				U(0x1F8)
+#define RCC_R57SEMCR				U(0x1FC)
+#define RCC_R58CIDCFGR				U(0x200)
+#define RCC_R58SEMCR				U(0x204)
+#define RCC_R59CIDCFGR				U(0x208)
+#define RCC_R59SEMCR				U(0x20C)
+#define RCC_R60CIDCFGR				U(0x210)
+#define RCC_R60SEMCR				U(0x214)
+#define RCC_R61CIDCFGR				U(0x218)
+#define RCC_R61SEMCR				U(0x21C)
+#define RCC_R62CIDCFGR				U(0x220)
+#define RCC_R62SEMCR				U(0x224)
+#define RCC_R63CIDCFGR				U(0x228)
+#define RCC_R63SEMCR				U(0x22C)
+#define RCC_R64CIDCFGR				U(0x230)
+#define RCC_R64SEMCR				U(0x234)
+#define RCC_R65CIDCFGR				U(0x238)
+#define RCC_R65SEMCR				U(0x23C)
+#define RCC_R66CIDCFGR				U(0x240)
+#define RCC_R66SEMCR				U(0x244)
+#define RCC_R67CIDCFGR				U(0x248)
+#define RCC_R67SEMCR				U(0x24C)
+#define RCC_R68CIDCFGR				U(0x250)
+#define RCC_R68SEMCR				U(0x254)
+#define RCC_R69CIDCFGR				U(0x258)
+#define RCC_R69SEMCR				U(0x25C)
+#define RCC_R70CIDCFGR				U(0x260)
+#define RCC_R70SEMCR				U(0x264)
+#define RCC_R71CIDCFGR				U(0x268)
+#define RCC_R71SEMCR				U(0x26C)
+#define RCC_R72CIDCFGR				U(0x270)
+#define RCC_R72SEMCR				U(0x274)
+#define RCC_R73CIDCFGR				U(0x278)
+#define RCC_R73SEMCR				U(0x27C)
+#define RCC_R74CIDCFGR				U(0x280)
+#define RCC_R74SEMCR				U(0x284)
+#define RCC_R75CIDCFGR				U(0x288)
+#define RCC_R75SEMCR				U(0x28C)
+#define RCC_R76CIDCFGR				U(0x290)
+#define RCC_R76SEMCR				U(0x294)
+#define RCC_R77CIDCFGR				U(0x298)
+#define RCC_R77SEMCR				U(0x29C)
+#define RCC_R78CIDCFGR				U(0x2A0)
+#define RCC_R78SEMCR				U(0x2A4)
+#define RCC_R79CIDCFGR				U(0x2A8)
+#define RCC_R79SEMCR				U(0x2AC)
+#define RCC_R80CIDCFGR				U(0x2B0)
+#define RCC_R80SEMCR				U(0x2B4)
+#define RCC_R81CIDCFGR				U(0x2B8)
+#define RCC_R81SEMCR				U(0x2BC)
+#define RCC_R82CIDCFGR				U(0x2C0)
+#define RCC_R82SEMCR				U(0x2C4)
+#define RCC_R83CIDCFGR				U(0x2C8)
+#define RCC_R83SEMCR				U(0x2CC)
+#define RCC_R84CIDCFGR				U(0x2D0)
+#define RCC_R84SEMCR				U(0x2D4)
+#define RCC_R85CIDCFGR				U(0x2D8)
+#define RCC_R85SEMCR				U(0x2DC)
+#define RCC_R86CIDCFGR				U(0x2E0)
+#define RCC_R86SEMCR				U(0x2E4)
+#define RCC_R87CIDCFGR				U(0x2E8)
+#define RCC_R87SEMCR				U(0x2EC)
+#define RCC_R88CIDCFGR				U(0x2F0)
+#define RCC_R88SEMCR				U(0x2F4)
+#define RCC_R89CIDCFGR				U(0x2F8)
+#define RCC_R89SEMCR				U(0x2FC)
+#define RCC_R90CIDCFGR				U(0x300)
+#define RCC_R90SEMCR				U(0x304)
+#define RCC_R91CIDCFGR				U(0x308)
+#define RCC_R91SEMCR				U(0x30C)
+#define RCC_R92CIDCFGR				U(0x310)
+#define RCC_R92SEMCR				U(0x314)
+#define RCC_R93CIDCFGR				U(0x318)
+#define RCC_R93SEMCR				U(0x31C)
+#define RCC_R94CIDCFGR				U(0x320)
+#define RCC_R94SEMCR				U(0x324)
+#define RCC_R95CIDCFGR				U(0x328)
+#define RCC_R95SEMCR				U(0x32C)
+#define RCC_R96CIDCFGR				U(0x330)
+#define RCC_R96SEMCR				U(0x334)
+#define RCC_R97CIDCFGR				U(0x338)
+#define RCC_R97SEMCR				U(0x33C)
+#define RCC_R98CIDCFGR				U(0x340)
+#define RCC_R98SEMCR				U(0x344)
+#define RCC_R99CIDCFGR				U(0x348)
+#define RCC_R99SEMCR				U(0x34C)
+#define RCC_R100CIDCFGR				U(0x350)
+#define RCC_R100SEMCR				U(0x354)
+#define RCC_R101CIDCFGR				U(0x358)
+#define RCC_R101SEMCR				U(0x35C)
+#define RCC_R102CIDCFGR				U(0x360)
+#define RCC_R102SEMCR				U(0x364)
+#define RCC_R103CIDCFGR				U(0x368)
+#define RCC_R103SEMCR				U(0x36C)
+#define RCC_R104CIDCFGR				U(0x370)
+#define RCC_R104SEMCR				U(0x374)
+#define RCC_R105CIDCFGR				U(0x378)
+#define RCC_R105SEMCR				U(0x37C)
+#define RCC_R106CIDCFGR				U(0x380)
+#define RCC_R106SEMCR				U(0x384)
+#define RCC_R107CIDCFGR				U(0x388)
+#define RCC_R107SEMCR				U(0x38C)
+#define RCC_R108CIDCFGR				U(0x390)
+#define RCC_R108SEMCR				U(0x394)
+#define RCC_R109CIDCFGR				U(0x398)
+#define RCC_R109SEMCR				U(0x39C)
+#define RCC_R110CIDCFGR				U(0x3A0)
+#define RCC_R110SEMCR				U(0x3A4)
+#define RCC_R111CIDCFGR				U(0x3A8)
+#define RCC_R111SEMCR				U(0x3AC)
+#define RCC_R112CIDCFGR				U(0x3B0)
+#define RCC_R112SEMCR				U(0x3B4)
+#define RCC_R113CIDCFGR				U(0x3B8)
+#define RCC_R113SEMCR				U(0x3BC)
+#define RCC_GRSTCSETR				U(0x400)
+#define RCC_C1RSTCSETR				U(0x404)
+#define RCC_C1P1RSTCSETR			U(0x408)
+#define RCC_C2RSTCSETR				U(0x40C)
+#define RCC_HWRSTSCLRR				U(0x410)
+#define RCC_C1HWRSTSCLRR			U(0x414)
+#define RCC_C2HWRSTSCLRR			U(0x418)
+#define RCC_C1BOOTRSTSSETR			U(0x41C)
+#define RCC_C1BOOTRSTSCLRR			U(0x420)
+#define RCC_C2BOOTRSTSSETR			U(0x424)
+#define RCC_C2BOOTRSTSCLRR			U(0x428)
+#define RCC_C1SREQSETR				U(0x42C)
+#define RCC_C1SREQCLRR				U(0x430)
+#define RCC_CPUBOOTCR				U(0x434)
+#define RCC_STBYBOOTCR				U(0x438)
+#define RCC_LEGBOOTCR				U(0x43C)
+#define RCC_BDCR				U(0x440)
+#define RCC_D3DCR				U(0x444)
+#define RCC_D3DSR				U(0x448)
+#define RCC_RDCR				U(0x44C)
+#define RCC_C1MSRDCR				U(0x450)
+#define RCC_PWRLPDLYCR				U(0x454)
+#define RCC_C1CIESETR				U(0x458)
+#define RCC_C1CIFCLRR				U(0x45C)
+#define RCC_C2CIESETR				U(0x460)
+#define RCC_C2CIFCLRR				U(0x464)
+#define RCC_IWDGC1FZSETR			U(0x468)
+#define RCC_IWDGC1FZCLRR			U(0x46C)
+#define RCC_IWDGC1CFGSETR			U(0x470)
+#define RCC_IWDGC1CFGCLRR			U(0x474)
+#define RCC_IWDGC2FZSETR			U(0x478)
+#define RCC_IWDGC2FZCLRR			U(0x47C)
+#define RCC_IWDGC2CFGSETR			U(0x480)
+#define RCC_IWDGC2CFGCLRR			U(0x484)
+#define RCC_IWDGC3CFGSETR			U(0x488)
+#define RCC_IWDGC3CFGCLRR			U(0x48C)
+#define RCC_C3CFGR				U(0x490)
+#define RCC_MCO1CFGR				U(0x494)
+#define RCC_MCO2CFGR				U(0x498)
+#define RCC_OCENSETR				U(0x49C)
+#define RCC_OCENCLRR				U(0x4A0)
+#define RCC_OCRDYR				U(0x4A4)
+#define RCC_HSICFGR				U(0x4A8)
+#define RCC_CSICFGR				U(0x4AC)
+#define RCC_RTCDIVR				U(0x4B0)
+#define RCC_APB1DIVR				U(0x4B4)
+#define RCC_APB2DIVR				U(0x4B8)
+#define RCC_APB3DIVR				U(0x4BC)
+#define RCC_APB4DIVR				U(0x4C0)
+#define RCC_APBDBGDIVR				U(0x4C4)
+#define RCC_TIMG1PRER				U(0x4C8)
+#define RCC_TIMG2PRER				U(0x4CC)
+#define RCC_LSMCUDIVR				U(0x4D0)
+#define RCC_DDRCPCFGR				U(0x4D4)
+#define RCC_DDRCAPBCFGR				U(0x4D8)
+#define RCC_DDRPHYCAPBCFGR			U(0x4DC)
+#define RCC_DDRPHYCCFGR				U(0x4E0)
+#define RCC_DDRCFGR				U(0x4E4)
+#define RCC_DDRITFCFGR				U(0x4E8)
+#define RCC_SYSRAMCFGR				U(0x4F0)
+#define RCC_VDERAMCFGR				U(0x4F4)
+#define RCC_SRAM1CFGR				U(0x4F8)
+#define RCC_SRAM2CFGR				U(0x4FC)
+#define RCC_RETRAMCFGR				U(0x500)
+#define RCC_BKPSRAMCFGR				U(0x504)
+#define RCC_LPSRAM1CFGR				U(0x508)
+#define RCC_LPSRAM2CFGR				U(0x50C)
+#define RCC_LPSRAM3CFGR				U(0x510)
+#define RCC_OSPI1CFGR				U(0x514)
+#define RCC_OSPI2CFGR				U(0x518)
+#define RCC_FMCCFGR				U(0x51C)
+#define RCC_DBGCFGR				U(0x520)
+#define RCC_STM500CFGR				U(0x524)
+#define RCC_ETRCFGR				U(0x528)
+#define RCC_GPIOACFGR				U(0x52C)
+#define RCC_GPIOBCFGR				U(0x530)
+#define RCC_GPIOCCFGR				U(0x534)
+#define RCC_GPIODCFGR				U(0x538)
+#define RCC_GPIOECFGR				U(0x53C)
+#define RCC_GPIOFCFGR				U(0x540)
+#define RCC_GPIOGCFGR				U(0x544)
+#define RCC_GPIOHCFGR				U(0x548)
+#define RCC_GPIOICFGR				U(0x54C)
+#define RCC_GPIOJCFGR				U(0x550)
+#define RCC_GPIOKCFGR				U(0x554)
+#define RCC_GPIOZCFGR				U(0x558)
+#define RCC_HPDMA1CFGR				U(0x55C)
+#define RCC_HPDMA2CFGR				U(0x560)
+#define RCC_HPDMA3CFGR				U(0x564)
+#define RCC_LPDMACFGR				U(0x568)
+#define RCC_HSEMCFGR				U(0x56C)
+#define RCC_IPCC1CFGR				U(0x570)
+#define RCC_IPCC2CFGR				U(0x574)
+#define RCC_RTCCFGR				U(0x578)
+#define RCC_SYSCPU1CFGR				U(0x580)
+#define RCC_BSECCFGR				U(0x584)
+#define RCC_IS2MCFGR				U(0x58C)
+#define RCC_PLL2CFGR1				U(0x590)
+#define RCC_PLL2CFGR2				U(0x594)
+#define RCC_PLL2CFGR3				U(0x598)
+#define RCC_PLL2CFGR4				U(0x59C)
+#define RCC_PLL2CFGR5				U(0x5A0)
+#define RCC_PLL2CFGR6				U(0x5A8)
+#define RCC_PLL2CFGR7				U(0x5AC)
+#define RCC_PLL3CFGR1				U(0x5B8)
+#define RCC_PLL3CFGR2				U(0x5BC)
+#define RCC_PLL3CFGR3				U(0x5C0)
+#define RCC_PLL3CFGR4				U(0x5C4)
+#define RCC_PLL3CFGR5				U(0x5C8)
+#define RCC_PLL3CFGR6				U(0x5D0)
+#define RCC_PLL3CFGR7				U(0x5D4)
+#define RCC_HSIFMONCR				U(0x5E0)
+#define RCC_HSIFVALR				U(0x5E4)
+#define RCC_TIM1CFGR				U(0x700)
+#define RCC_TIM2CFGR				U(0x704)
+#define RCC_TIM3CFGR				U(0x708)
+#define RCC_TIM4CFGR				U(0x70C)
+#define RCC_TIM5CFGR				U(0x710)
+#define RCC_TIM6CFGR				U(0x714)
+#define RCC_TIM7CFGR				U(0x718)
+#define RCC_TIM8CFGR				U(0x71C)
+#define RCC_TIM10CFGR				U(0x720)
+#define RCC_TIM11CFGR				U(0x724)
+#define RCC_TIM12CFGR				U(0x728)
+#define RCC_TIM13CFGR				U(0x72C)
+#define RCC_TIM14CFGR				U(0x730)
+#define RCC_TIM15CFGR				U(0x734)
+#define RCC_TIM16CFGR				U(0x738)
+#define RCC_TIM17CFGR				U(0x73C)
+#define RCC_TIM20CFGR				U(0x740)
+#define RCC_LPTIM1CFGR				U(0x744)
+#define RCC_LPTIM2CFGR				U(0x748)
+#define RCC_LPTIM3CFGR				U(0x74C)
+#define RCC_LPTIM4CFGR				U(0x750)
+#define RCC_LPTIM5CFGR				U(0x754)
+#define RCC_SPI1CFGR				U(0x758)
+#define RCC_SPI2CFGR				U(0x75C)
+#define RCC_SPI3CFGR				U(0x760)
+#define RCC_SPI4CFGR				U(0x764)
+#define RCC_SPI5CFGR				U(0x768)
+#define RCC_SPI6CFGR				U(0x76C)
+#define RCC_SPI7CFGR				U(0x770)
+#define RCC_SPI8CFGR				U(0x774)
+#define RCC_SPDIFRXCFGR				U(0x778)
+#define RCC_USART1CFGR				U(0x77C)
+#define RCC_USART2CFGR				U(0x780)
+#define RCC_USART3CFGR				U(0x784)
+#define RCC_UART4CFGR				U(0x788)
+#define RCC_UART5CFGR				U(0x78C)
+#define RCC_USART6CFGR				U(0x790)
+#define RCC_UART7CFGR				U(0x794)
+#define RCC_UART8CFGR				U(0x798)
+#define RCC_UART9CFGR				U(0x79C)
+#define RCC_LPUART1CFGR				U(0x7A0)
+#define RCC_I2C1CFGR				U(0x7A4)
+#define RCC_I2C2CFGR				U(0x7A8)
+#define RCC_I2C3CFGR				U(0x7AC)
+#define RCC_I2C4CFGR				U(0x7B0)
+#define RCC_I2C5CFGR				U(0x7B4)
+#define RCC_I2C6CFGR				U(0x7B8)
+#define RCC_I2C7CFGR				U(0x7BC)
+#define RCC_I2C8CFGR				U(0x7C0)
+#define RCC_SAI1CFGR				U(0x7C4)
+#define RCC_SAI2CFGR				U(0x7C8)
+#define RCC_SAI3CFGR				U(0x7CC)
+#define RCC_SAI4CFGR				U(0x7D0)
+#define RCC_MDF1CFGR				U(0x7D8)
+#define RCC_ADF1CFGR				U(0x7DC)
+#define RCC_FDCANCFGR				U(0x7E0)
+#define RCC_HDPCFGR				U(0x7E4)
+#define RCC_ADC12CFGR				U(0x7E8)
+#define RCC_ADC3CFGR				U(0x7EC)
+#define RCC_ETH1CFGR				U(0x7F0)
+#define RCC_ETH2CFGR				U(0x7F4)
+#define RCC_USB2CFGR				U(0x7FC)
+#define RCC_USB2PHY1CFGR			U(0x800)
+#define RCC_USB2PHY2CFGR			U(0x804)
+#define RCC_USB3DRCFGR				U(0x808)
+#define RCC_USB3PCIEPHYCFGR			U(0x80C)
+#define RCC_PCIECFGR				U(0x810)
+#define RCC_USBTCCFGR				U(0x814)
+#define RCC_ETHSWCFGR				U(0x818)
+#define RCC_ETHSWACMCFGR			U(0x81C)
+#define RCC_ETHSWACMMSGCFGR			U(0x820)
+#define RCC_STGENCFGR				U(0x824)
+#define RCC_SDMMC1CFGR				U(0x830)
+#define RCC_SDMMC2CFGR				U(0x834)
+#define RCC_SDMMC3CFGR				U(0x838)
+#define RCC_GPUCFGR				U(0x83C)
+#define RCC_LTDCCFGR				U(0x840)
+#define RCC_DSICFGR				U(0x844)
+#define RCC_LVDSCFGR				U(0x850)
+#define RCC_CSI2CFGR				U(0x858)
+#define RCC_DCMIPPCFGR				U(0x85C)
+#define RCC_CCICFGR				U(0x860)
+#define RCC_VDECCFGR				U(0x864)
+#define RCC_VENCCFGR				U(0x868)
+#define RCC_RNGCFGR				U(0x870)
+#define RCC_PKACFGR				U(0x874)
+#define RCC_SAESCFGR				U(0x878)
+#define RCC_HASHCFGR				U(0x87C)
+#define RCC_CRYP1CFGR				U(0x880)
+#define RCC_CRYP2CFGR				U(0x884)
+#define RCC_IWDG1CFGR				U(0x888)
+#define RCC_IWDG2CFGR				U(0x88C)
+#define RCC_IWDG3CFGR				U(0x890)
+#define RCC_IWDG4CFGR				U(0x894)
+#define RCC_IWDG5CFGR				U(0x898)
+#define RCC_WWDG1CFGR				U(0x89C)
+#define RCC_WWDG2CFGR				U(0x8A0)
+#define RCC_VREFCFGR				U(0x8A8)
+#define RCC_TMPSENSCFGR				U(0x8AC)
+#define RCC_CRCCFGR				U(0x8B4)
+#define RCC_SERCCFGR				U(0x8B8)
+#define RCC_OSPIIOMCFGR				U(0x8BC)
+#define RCC_GICV2MCFGR				U(0x8C0)
+#define RCC_I3C1CFGR				U(0x8C8)
+#define RCC_I3C2CFGR				U(0x8CC)
+#define RCC_I3C3CFGR				U(0x8D0)
+#define RCC_I3C4CFGR				U(0x8D4)
+#define RCC_MUXSELCFGR				U(0x1000)
+#define RCC_XBAR0CFGR				U(0x1018)
+#define RCC_XBAR1CFGR				U(0x101C)
+#define RCC_XBAR2CFGR				U(0x1020)
+#define RCC_XBAR3CFGR				U(0x1024)
+#define RCC_XBAR4CFGR				U(0x1028)
+#define RCC_XBAR5CFGR				U(0x102C)
+#define RCC_XBAR6CFGR				U(0x1030)
+#define RCC_XBAR7CFGR				U(0x1034)
+#define RCC_XBAR8CFGR				U(0x1038)
+#define RCC_XBAR9CFGR				U(0x103C)
+#define RCC_XBAR10CFGR				U(0x1040)
+#define RCC_XBAR11CFGR				U(0x1044)
+#define RCC_XBAR12CFGR				U(0x1048)
+#define RCC_XBAR13CFGR				U(0x104C)
+#define RCC_XBAR14CFGR				U(0x1050)
+#define RCC_XBAR15CFGR				U(0x1054)
+#define RCC_XBAR16CFGR				U(0x1058)
+#define RCC_XBAR17CFGR				U(0x105C)
+#define RCC_XBAR18CFGR				U(0x1060)
+#define RCC_XBAR19CFGR				U(0x1064)
+#define RCC_XBAR20CFGR				U(0x1068)
+#define RCC_XBAR21CFGR				U(0x106C)
+#define RCC_XBAR22CFGR				U(0x1070)
+#define RCC_XBAR23CFGR				U(0x1074)
+#define RCC_XBAR24CFGR				U(0x1078)
+#define RCC_XBAR25CFGR				U(0x107C)
+#define RCC_XBAR26CFGR				U(0x1080)
+#define RCC_XBAR27CFGR				U(0x1084)
+#define RCC_XBAR28CFGR				U(0x1088)
+#define RCC_XBAR29CFGR				U(0x108C)
+#define RCC_XBAR30CFGR				U(0x1090)
+#define RCC_XBAR31CFGR				U(0x1094)
+#define RCC_XBAR32CFGR				U(0x1098)
+#define RCC_XBAR33CFGR				U(0x109C)
+#define RCC_XBAR34CFGR				U(0x10A0)
+#define RCC_XBAR35CFGR				U(0x10A4)
+#define RCC_XBAR36CFGR				U(0x10A8)
+#define RCC_XBAR37CFGR				U(0x10AC)
+#define RCC_XBAR38CFGR				U(0x10B0)
+#define RCC_XBAR39CFGR				U(0x10B4)
+#define RCC_XBAR40CFGR				U(0x10B8)
+#define RCC_XBAR41CFGR				U(0x10BC)
+#define RCC_XBAR42CFGR				U(0x10C0)
+#define RCC_XBAR43CFGR				U(0x10C4)
+#define RCC_XBAR44CFGR				U(0x10C8)
+#define RCC_XBAR45CFGR				U(0x10CC)
+#define RCC_XBAR46CFGR				U(0x10D0)
+#define RCC_XBAR47CFGR				U(0x10D4)
+#define RCC_XBAR48CFGR				U(0x10D8)
+#define RCC_XBAR49CFGR				U(0x10DC)
+#define RCC_XBAR50CFGR				U(0x10E0)
+#define RCC_XBAR51CFGR				U(0x10E4)
+#define RCC_XBAR52CFGR				U(0x10E8)
+#define RCC_XBAR53CFGR				U(0x10EC)
+#define RCC_XBAR54CFGR				U(0x10F0)
+#define RCC_XBAR55CFGR				U(0x10F4)
+#define RCC_XBAR56CFGR				U(0x10F8)
+#define RCC_XBAR57CFGR				U(0x10FC)
+#define RCC_XBAR58CFGR				U(0x1100)
+#define RCC_XBAR59CFGR				U(0x1104)
+#define RCC_XBAR60CFGR				U(0x1108)
+#define RCC_XBAR61CFGR				U(0x110C)
+#define RCC_XBAR62CFGR				U(0x1110)
+#define RCC_XBAR63CFGR				U(0x1114)
+#define RCC_PREDIV0CFGR				U(0x1118)
+#define RCC_PREDIV1CFGR				U(0x111C)
+#define RCC_PREDIV2CFGR				U(0x1120)
+#define RCC_PREDIV3CFGR				U(0x1124)
+#define RCC_PREDIV4CFGR				U(0x1128)
+#define RCC_PREDIV5CFGR				U(0x112C)
+#define RCC_PREDIV6CFGR				U(0x1130)
+#define RCC_PREDIV7CFGR				U(0x1134)
+#define RCC_PREDIV8CFGR				U(0x1138)
+#define RCC_PREDIV9CFGR				U(0x113C)
+#define RCC_PREDIV10CFGR			U(0x1140)
+#define RCC_PREDIV11CFGR			U(0x1144)
+#define RCC_PREDIV12CFGR			U(0x1148)
+#define RCC_PREDIV13CFGR			U(0x114C)
+#define RCC_PREDIV14CFGR			U(0x1150)
+#define RCC_PREDIV15CFGR			U(0x1154)
+#define RCC_PREDIV16CFGR			U(0x1158)
+#define RCC_PREDIV17CFGR			U(0x115C)
+#define RCC_PREDIV18CFGR			U(0x1160)
+#define RCC_PREDIV19CFGR			U(0x1164)
+#define RCC_PREDIV20CFGR			U(0x1168)
+#define RCC_PREDIV21CFGR			U(0x116C)
+#define RCC_PREDIV22CFGR			U(0x1170)
+#define RCC_PREDIV23CFGR			U(0x1174)
+#define RCC_PREDIV24CFGR			U(0x1178)
+#define RCC_PREDIV25CFGR			U(0x117C)
+#define RCC_PREDIV26CFGR			U(0x1180)
+#define RCC_PREDIV27CFGR			U(0x1184)
+#define RCC_PREDIV28CFGR			U(0x1188)
+#define RCC_PREDIV29CFGR			U(0x118C)
+#define RCC_PREDIV30CFGR			U(0x1190)
+#define RCC_PREDIV31CFGR			U(0x1194)
+#define RCC_PREDIV32CFGR			U(0x1198)
+#define RCC_PREDIV33CFGR			U(0x119C)
+#define RCC_PREDIV34CFGR			U(0x11A0)
+#define RCC_PREDIV35CFGR			U(0x11A4)
+#define RCC_PREDIV36CFGR			U(0x11A8)
+#define RCC_PREDIV37CFGR			U(0x11AC)
+#define RCC_PREDIV38CFGR			U(0x11B0)
+#define RCC_PREDIV39CFGR			U(0x11B4)
+#define RCC_PREDIV40CFGR			U(0x11B8)
+#define RCC_PREDIV41CFGR			U(0x11BC)
+#define RCC_PREDIV42CFGR			U(0x11C0)
+#define RCC_PREDIV43CFGR			U(0x11C4)
+#define RCC_PREDIV44CFGR			U(0x11C8)
+#define RCC_PREDIV45CFGR			U(0x11CC)
+#define RCC_PREDIV46CFGR			U(0x11D0)
+#define RCC_PREDIV47CFGR			U(0x11D4)
+#define RCC_PREDIV48CFGR			U(0x11D8)
+#define RCC_PREDIV49CFGR			U(0x11DC)
+#define RCC_PREDIV50CFGR			U(0x11E0)
+#define RCC_PREDIV51CFGR			U(0x11E4)
+#define RCC_PREDIV52CFGR			U(0x11E8)
+#define RCC_PREDIV53CFGR			U(0x11EC)
+#define RCC_PREDIV54CFGR			U(0x11F0)
+#define RCC_PREDIV55CFGR			U(0x11F4)
+#define RCC_PREDIV56CFGR			U(0x11F8)
+#define RCC_PREDIV57CFGR			U(0x11FC)
+#define RCC_PREDIV58CFGR			U(0x1200)
+#define RCC_PREDIV59CFGR			U(0x1204)
+#define RCC_PREDIV60CFGR			U(0x1208)
+#define RCC_PREDIV61CFGR			U(0x120C)
+#define RCC_PREDIV62CFGR			U(0x1210)
+#define RCC_PREDIV63CFGR			U(0x1214)
+#define RCC_PREDIVSR1				U(0x1218)
+#define RCC_PREDIVSR2				U(0x121C)
+#define RCC_FINDIV0CFGR				U(0x1224)
+#define RCC_FINDIV1CFGR				U(0x1228)
+#define RCC_FINDIV2CFGR				U(0x122C)
+#define RCC_FINDIV3CFGR				U(0x1230)
+#define RCC_FINDIV4CFGR				U(0x1234)
+#define RCC_FINDIV5CFGR				U(0x1238)
+#define RCC_FINDIV6CFGR				U(0x123C)
+#define RCC_FINDIV7CFGR				U(0x1240)
+#define RCC_FINDIV8CFGR				U(0x1244)
+#define RCC_FINDIV9CFGR				U(0x1248)
+#define RCC_FINDIV10CFGR			U(0x124C)
+#define RCC_FINDIV11CFGR			U(0x1250)
+#define RCC_FINDIV12CFGR			U(0x1254)
+#define RCC_FINDIV13CFGR			U(0x1258)
+#define RCC_FINDIV14CFGR			U(0x125C)
+#define RCC_FINDIV15CFGR			U(0x1260)
+#define RCC_FINDIV16CFGR			U(0x1264)
+#define RCC_FINDIV17CFGR			U(0x1268)
+#define RCC_FINDIV18CFGR			U(0x126C)
+#define RCC_FINDIV19CFGR			U(0x1270)
+#define RCC_FINDIV20CFGR			U(0x1274)
+#define RCC_FINDIV21CFGR			U(0x1278)
+#define RCC_FINDIV22CFGR			U(0x127C)
+#define RCC_FINDIV23CFGR			U(0x1280)
+#define RCC_FINDIV24CFGR			U(0x1284)
+#define RCC_FINDIV25CFGR			U(0x1288)
+#define RCC_FINDIV26CFGR			U(0x128C)
+#define RCC_FINDIV27CFGR			U(0x1290)
+#define RCC_FINDIV28CFGR			U(0x1294)
+#define RCC_FINDIV29CFGR			U(0x1298)
+#define RCC_FINDIV30CFGR			U(0x129C)
+#define RCC_FINDIV31CFGR			U(0x12A0)
+#define RCC_FINDIV32CFGR			U(0x12A4)
+#define RCC_FINDIV33CFGR			U(0x12A8)
+#define RCC_FINDIV34CFGR			U(0x12AC)
+#define RCC_FINDIV35CFGR			U(0x12B0)
+#define RCC_FINDIV36CFGR			U(0x12B4)
+#define RCC_FINDIV37CFGR			U(0x12B8)
+#define RCC_FINDIV38CFGR			U(0x12BC)
+#define RCC_FINDIV39CFGR			U(0x12C0)
+#define RCC_FINDIV40CFGR			U(0x12C4)
+#define RCC_FINDIV41CFGR			U(0x12C8)
+#define RCC_FINDIV42CFGR			U(0x12CC)
+#define RCC_FINDIV43CFGR			U(0x12D0)
+#define RCC_FINDIV44CFGR			U(0x12D4)
+#define RCC_FINDIV45CFGR			U(0x12D8)
+#define RCC_FINDIV46CFGR			U(0x12DC)
+#define RCC_FINDIV47CFGR			U(0x12E0)
+#define RCC_FINDIV48CFGR			U(0x12E4)
+#define RCC_FINDIV49CFGR			U(0x12E8)
+#define RCC_FINDIV50CFGR			U(0x12EC)
+#define RCC_FINDIV51CFGR			U(0x12F0)
+#define RCC_FINDIV52CFGR			U(0x12F4)
+#define RCC_FINDIV53CFGR			U(0x12F8)
+#define RCC_FINDIV54CFGR			U(0x12FC)
+#define RCC_FINDIV55CFGR			U(0x1300)
+#define RCC_FINDIV56CFGR			U(0x1304)
+#define RCC_FINDIV57CFGR			U(0x1308)
+#define RCC_FINDIV58CFGR			U(0x130C)
+#define RCC_FINDIV59CFGR			U(0x1310)
+#define RCC_FINDIV60CFGR			U(0x1314)
+#define RCC_FINDIV61CFGR			U(0x1318)
+#define RCC_FINDIV62CFGR			U(0x131C)
+#define RCC_FINDIV63CFGR			U(0x1320)
+#define RCC_FINDIVSR1				U(0x1324)
+#define RCC_FINDIVSR2				U(0x1328)
+#define RCC_FCALCOBS0CFGR			U(0x1340)
+#define RCC_FCALCOBS1CFGR			U(0x1344)
+#define RCC_FCALCREFCFGR			U(0x1348)
+#define RCC_FCALCCR1				U(0x134C)
+#define RCC_FCALCCR2				U(0x1354)
+#define RCC_FCALCSR				U(0x1358)
+#define RCC_PLL4CFGR1				U(0x1360)
+#define RCC_PLL4CFGR2				U(0x1364)
+#define RCC_PLL4CFGR3				U(0x1368)
+#define RCC_PLL4CFGR4				U(0x136C)
+#define RCC_PLL4CFGR5				U(0x1370)
+#define RCC_PLL4CFGR6				U(0x1378)
+#define RCC_PLL4CFGR7				U(0x137C)
+#define RCC_PLL5CFGR1				U(0x1388)
+#define RCC_PLL5CFGR2				U(0x138C)
+#define RCC_PLL5CFGR3				U(0x1390)
+#define RCC_PLL5CFGR4				U(0x1394)
+#define RCC_PLL5CFGR5				U(0x1398)
+#define RCC_PLL5CFGR6				U(0x13A0)
+#define RCC_PLL5CFGR7				U(0x13A4)
+#define RCC_PLL6CFGR1				U(0x13B0)
+#define RCC_PLL6CFGR2				U(0x13B4)
+#define RCC_PLL6CFGR3				U(0x13B8)
+#define RCC_PLL6CFGR4				U(0x13BC)
+#define RCC_PLL6CFGR5				U(0x13C0)
+#define RCC_PLL6CFGR6				U(0x13C8)
+#define RCC_PLL6CFGR7				U(0x13CC)
+#define RCC_PLL7CFGR1				U(0x13D8)
+#define RCC_PLL7CFGR2				U(0x13DC)
+#define RCC_PLL7CFGR3				U(0x13E0)
+#define RCC_PLL7CFGR4				U(0x13E4)
+#define RCC_PLL7CFGR5				U(0x13E8)
+#define RCC_PLL7CFGR6				U(0x13F0)
+#define RCC_PLL7CFGR7				U(0x13F4)
+#define RCC_PLL8CFGR1				U(0x1400)
+#define RCC_PLL8CFGR2				U(0x1404)
+#define RCC_PLL8CFGR3				U(0x1408)
+#define RCC_PLL8CFGR4				U(0x140C)
+#define RCC_PLL8CFGR5				U(0x1410)
+#define RCC_PLL8CFGR6				U(0x1418)
+#define RCC_PLL8CFGR7				U(0x141C)
+#define RCC_VERR				U(0xFFF4)
+#define RCC_IDR					U(0xFFF8)
+#define RCC_SIDR				U(0xFFFC)
+
+/* Offset between RCC_MP_xxxENSETR and RCC_MP_xxxENCLRR registers */
+#define RCC_MP_ENCLRR_OFFSET			U(4)
+
+/* RCC_SECCFGR3 register fields */
+#define RCC_SECCFGR3_SEC_MASK			GENMASK(17, 0)
+#define RCC_SECCFGR3_SEC_SHIFT			0
+
+/* RCC_PRIVCFGR3 register fields */
+#define RCC_PRIVCFGR3_PRIV_MASK			GENMASK(17, 0)
+#define RCC_PRIVCFGR3_PRIV_SHIFT		0
+
+/* RCC_RCFGLOCKR3 register fields */
+#define RCC_RCFGLOCKR3_RLOCK_MASK		GENMASK(17, 0)
+#define RCC_RCFGLOCKR3_RLOCK_SHIFT		0
+
+/* RCC_R0CIDCFGR register fields */
+#define RCC_R0CIDCFGR_CFEN			BIT(0)
+#define RCC_R0CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R0CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R0CIDCFGR_SCID_SHIFT		4
+#define RCC_R0CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R0CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R0SEMCR register fields */
+#define RCC_R0SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R0SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R0SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R1CIDCFGR register fields */
+#define RCC_R1CIDCFGR_CFEN			BIT(0)
+#define RCC_R1CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R1CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R1CIDCFGR_SCID_SHIFT		4
+#define RCC_R1CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R1CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R1SEMCR register fields */
+#define RCC_R1SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R1SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R1SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R2CIDCFGR register fields */
+#define RCC_R2CIDCFGR_CFEN			BIT(0)
+#define RCC_R2CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R2CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R2CIDCFGR_SCID_SHIFT		4
+#define RCC_R2CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R2CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R2SEMCR register fields */
+#define RCC_R2SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R2SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R2SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R3CIDCFGR register fields */
+#define RCC_R3CIDCFGR_CFEN			BIT(0)
+#define RCC_R3CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R3CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R3CIDCFGR_SCID_SHIFT		4
+#define RCC_R3CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R3CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R3SEMCR register fields */
+#define RCC_R3SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R3SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R3SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R4CIDCFGR register fields */
+#define RCC_R4CIDCFGR_CFEN			BIT(0)
+#define RCC_R4CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R4CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R4CIDCFGR_SCID_SHIFT		4
+#define RCC_R4CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R4CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R4SEMCR register fields */
+#define RCC_R4SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R4SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R4SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R5CIDCFGR register fields */
+#define RCC_R5CIDCFGR_CFEN			BIT(0)
+#define RCC_R5CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R5CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R5CIDCFGR_SCID_SHIFT		4
+#define RCC_R5CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R5CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R5SEMCR register fields */
+#define RCC_R5SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R5SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R5SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R6CIDCFGR register fields */
+#define RCC_R6CIDCFGR_CFEN			BIT(0)
+#define RCC_R6CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R6CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R6CIDCFGR_SCID_SHIFT		4
+#define RCC_R6CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R6CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R6SEMCR register fields */
+#define RCC_R6SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R6SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R6SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R7CIDCFGR register fields */
+#define RCC_R7CIDCFGR_CFEN			BIT(0)
+#define RCC_R7CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R7CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R7CIDCFGR_SCID_SHIFT		4
+#define RCC_R7CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R7CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R7SEMCR register fields */
+#define RCC_R7SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R7SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R7SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R8CIDCFGR register fields */
+#define RCC_R8CIDCFGR_CFEN			BIT(0)
+#define RCC_R8CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R8CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R8CIDCFGR_SCID_SHIFT		4
+#define RCC_R8CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R8CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R8SEMCR register fields */
+#define RCC_R8SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R8SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R8SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R9CIDCFGR register fields */
+#define RCC_R9CIDCFGR_CFEN			BIT(0)
+#define RCC_R9CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R9CIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_R9CIDCFGR_SCID_SHIFT		4
+#define RCC_R9CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R9CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R9SEMCR register fields */
+#define RCC_R9SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R9SEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_R9SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R10CIDCFGR register fields */
+#define RCC_R10CIDCFGR_CFEN			BIT(0)
+#define RCC_R10CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R10CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R10CIDCFGR_SCID_SHIFT		4
+#define RCC_R10CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R10CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R10SEMCR register fields */
+#define RCC_R10SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R10SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R10SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R11CIDCFGR register fields */
+#define RCC_R11CIDCFGR_CFEN			BIT(0)
+#define RCC_R11CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R11CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R11CIDCFGR_SCID_SHIFT		4
+#define RCC_R11CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R11CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R11SEMCR register fields */
+#define RCC_R11SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R11SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R11SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R12CIDCFGR register fields */
+#define RCC_R12CIDCFGR_CFEN			BIT(0)
+#define RCC_R12CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R12CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R12CIDCFGR_SCID_SHIFT		4
+#define RCC_R12CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R12CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R12SEMCR register fields */
+#define RCC_R12SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R12SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R12SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R13CIDCFGR register fields */
+#define RCC_R13CIDCFGR_CFEN			BIT(0)
+#define RCC_R13CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R13CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R13CIDCFGR_SCID_SHIFT		4
+#define RCC_R13CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R13CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R13SEMCR register fields */
+#define RCC_R13SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R13SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R13SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R14CIDCFGR register fields */
+#define RCC_R14CIDCFGR_CFEN			BIT(0)
+#define RCC_R14CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R14CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R14CIDCFGR_SCID_SHIFT		4
+#define RCC_R14CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R14CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R14SEMCR register fields */
+#define RCC_R14SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R14SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R14SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R15CIDCFGR register fields */
+#define RCC_R15CIDCFGR_CFEN			BIT(0)
+#define RCC_R15CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R15CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R15CIDCFGR_SCID_SHIFT		4
+#define RCC_R15CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R15CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R15SEMCR register fields */
+#define RCC_R15SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R15SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R15SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R16CIDCFGR register fields */
+#define RCC_R16CIDCFGR_CFEN			BIT(0)
+#define RCC_R16CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R16CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R16CIDCFGR_SCID_SHIFT		4
+#define RCC_R16CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R16CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R16SEMCR register fields */
+#define RCC_R16SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R16SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R16SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R17CIDCFGR register fields */
+#define RCC_R17CIDCFGR_CFEN			BIT(0)
+#define RCC_R17CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R17CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R17CIDCFGR_SCID_SHIFT		4
+#define RCC_R17CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R17CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R17SEMCR register fields */
+#define RCC_R17SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R17SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R17SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R18CIDCFGR register fields */
+#define RCC_R18CIDCFGR_CFEN			BIT(0)
+#define RCC_R18CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R18CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R18CIDCFGR_SCID_SHIFT		4
+#define RCC_R18CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R18CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R18SEMCR register fields */
+#define RCC_R18SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R18SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R18SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R19CIDCFGR register fields */
+#define RCC_R19CIDCFGR_CFEN			BIT(0)
+#define RCC_R19CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R19CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R19CIDCFGR_SCID_SHIFT		4
+#define RCC_R19CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R19CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R19SEMCR register fields */
+#define RCC_R19SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R19SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R19SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R20CIDCFGR register fields */
+#define RCC_R20CIDCFGR_CFEN			BIT(0)
+#define RCC_R20CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R20CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R20CIDCFGR_SCID_SHIFT		4
+#define RCC_R20CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R20CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R20SEMCR register fields */
+#define RCC_R20SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R20SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R20SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R21CIDCFGR register fields */
+#define RCC_R21CIDCFGR_CFEN			BIT(0)
+#define RCC_R21CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R21CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R21CIDCFGR_SCID_SHIFT		4
+#define RCC_R21CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R21CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R21SEMCR register fields */
+#define RCC_R21SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R21SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R21SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R22CIDCFGR register fields */
+#define RCC_R22CIDCFGR_CFEN			BIT(0)
+#define RCC_R22CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R22CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R22CIDCFGR_SCID_SHIFT		4
+#define RCC_R22CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R22CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R22SEMCR register fields */
+#define RCC_R22SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R22SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R22SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R23CIDCFGR register fields */
+#define RCC_R23CIDCFGR_CFEN			BIT(0)
+#define RCC_R23CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R23CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R23CIDCFGR_SCID_SHIFT		4
+#define RCC_R23CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R23CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R23SEMCR register fields */
+#define RCC_R23SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R23SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R23SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R24CIDCFGR register fields */
+#define RCC_R24CIDCFGR_CFEN			BIT(0)
+#define RCC_R24CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R24CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R24CIDCFGR_SCID_SHIFT		4
+#define RCC_R24CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R24CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R24SEMCR register fields */
+#define RCC_R24SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R24SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R24SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R25CIDCFGR register fields */
+#define RCC_R25CIDCFGR_CFEN			BIT(0)
+#define RCC_R25CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R25CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R25CIDCFGR_SCID_SHIFT		4
+#define RCC_R25CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R25CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R25SEMCR register fields */
+#define RCC_R25SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R25SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R25SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R26CIDCFGR register fields */
+#define RCC_R26CIDCFGR_CFEN			BIT(0)
+#define RCC_R26CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R26CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R26CIDCFGR_SCID_SHIFT		4
+#define RCC_R26CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R26CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R26SEMCR register fields */
+#define RCC_R26SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R26SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R26SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R27CIDCFGR register fields */
+#define RCC_R27CIDCFGR_CFEN			BIT(0)
+#define RCC_R27CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R27CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R27CIDCFGR_SCID_SHIFT		4
+#define RCC_R27CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R27CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R27SEMCR register fields */
+#define RCC_R27SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R27SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R27SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R28CIDCFGR register fields */
+#define RCC_R28CIDCFGR_CFEN			BIT(0)
+#define RCC_R28CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R28CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R28CIDCFGR_SCID_SHIFT		4
+#define RCC_R28CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R28CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R28SEMCR register fields */
+#define RCC_R28SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R28SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R28SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R29CIDCFGR register fields */
+#define RCC_R29CIDCFGR_CFEN			BIT(0)
+#define RCC_R29CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R29CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R29CIDCFGR_SCID_SHIFT		4
+#define RCC_R29CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R29CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R29SEMCR register fields */
+#define RCC_R29SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R29SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R29SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R30CIDCFGR register fields */
+#define RCC_R30CIDCFGR_CFEN			BIT(0)
+#define RCC_R30CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R30CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R30CIDCFGR_SCID_SHIFT		4
+#define RCC_R30CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R30CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R30SEMCR register fields */
+#define RCC_R30SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R30SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R30SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R31CIDCFGR register fields */
+#define RCC_R31CIDCFGR_CFEN			BIT(0)
+#define RCC_R31CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R31CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R31CIDCFGR_SCID_SHIFT		4
+#define RCC_R31CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R31CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R31SEMCR register fields */
+#define RCC_R31SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R31SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R31SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R32CIDCFGR register fields */
+#define RCC_R32CIDCFGR_CFEN			BIT(0)
+#define RCC_R32CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R32CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R32CIDCFGR_SCID_SHIFT		4
+#define RCC_R32CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R32CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R32SEMCR register fields */
+#define RCC_R32SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R32SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R32SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R33CIDCFGR register fields */
+#define RCC_R33CIDCFGR_CFEN			BIT(0)
+#define RCC_R33CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R33CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R33CIDCFGR_SCID_SHIFT		4
+#define RCC_R33CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R33CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R33SEMCR register fields */
+#define RCC_R33SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R33SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R33SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R34CIDCFGR register fields */
+#define RCC_R34CIDCFGR_CFEN			BIT(0)
+#define RCC_R34CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R34CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R34CIDCFGR_SCID_SHIFT		4
+#define RCC_R34CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R34CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R34SEMCR register fields */
+#define RCC_R34SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R34SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R34SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R35CIDCFGR register fields */
+#define RCC_R35CIDCFGR_CFEN			BIT(0)
+#define RCC_R35CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R35CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R35CIDCFGR_SCID_SHIFT		4
+#define RCC_R35CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R35CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R35SEMCR register fields */
+#define RCC_R35SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R35SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R35SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R36CIDCFGR register fields */
+#define RCC_R36CIDCFGR_CFEN			BIT(0)
+#define RCC_R36CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R36CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R36CIDCFGR_SCID_SHIFT		4
+#define RCC_R36CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R36CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R36SEMCR register fields */
+#define RCC_R36SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R36SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R36SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R37CIDCFGR register fields */
+#define RCC_R37CIDCFGR_CFEN			BIT(0)
+#define RCC_R37CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R37CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R37CIDCFGR_SCID_SHIFT		4
+#define RCC_R37CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R37CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R37SEMCR register fields */
+#define RCC_R37SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R37SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R37SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R38CIDCFGR register fields */
+#define RCC_R38CIDCFGR_CFEN			BIT(0)
+#define RCC_R38CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R38CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R38CIDCFGR_SCID_SHIFT		4
+#define RCC_R38CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R38CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R38SEMCR register fields */
+#define RCC_R38SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R38SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R38SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R39CIDCFGR register fields */
+#define RCC_R39CIDCFGR_CFEN			BIT(0)
+#define RCC_R39CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R39CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R39CIDCFGR_SCID_SHIFT		4
+#define RCC_R39CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R39CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R39SEMCR register fields */
+#define RCC_R39SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R39SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R39SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R40CIDCFGR register fields */
+#define RCC_R40CIDCFGR_CFEN			BIT(0)
+#define RCC_R40CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R40CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R40CIDCFGR_SCID_SHIFT		4
+#define RCC_R40CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R40CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R40SEMCR register fields */
+#define RCC_R40SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R40SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R40SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R41CIDCFGR register fields */
+#define RCC_R41CIDCFGR_CFEN			BIT(0)
+#define RCC_R41CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R41CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R41CIDCFGR_SCID_SHIFT		4
+#define RCC_R41CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R41CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R41SEMCR register fields */
+#define RCC_R41SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R41SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R41SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R42CIDCFGR register fields */
+#define RCC_R42CIDCFGR_CFEN			BIT(0)
+#define RCC_R42CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R42CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R42CIDCFGR_SCID_SHIFT		4
+#define RCC_R42CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R42CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R42SEMCR register fields */
+#define RCC_R42SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R42SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R42SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R43CIDCFGR register fields */
+#define RCC_R43CIDCFGR_CFEN			BIT(0)
+#define RCC_R43CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R43CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R43CIDCFGR_SCID_SHIFT		4
+#define RCC_R43CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R43CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R43SEMCR register fields */
+#define RCC_R43SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R43SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R43SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R44CIDCFGR register fields */
+#define RCC_R44CIDCFGR_CFEN			BIT(0)
+#define RCC_R44CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R44CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R44CIDCFGR_SCID_SHIFT		4
+#define RCC_R44CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R44CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R44SEMCR register fields */
+#define RCC_R44SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R44SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R44SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R45CIDCFGR register fields */
+#define RCC_R45CIDCFGR_CFEN			BIT(0)
+#define RCC_R45CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R45CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R45CIDCFGR_SCID_SHIFT		4
+#define RCC_R45CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R45CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R45SEMCR register fields */
+#define RCC_R45SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R45SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R45SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R46CIDCFGR register fields */
+#define RCC_R46CIDCFGR_CFEN			BIT(0)
+#define RCC_R46CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R46CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R46CIDCFGR_SCID_SHIFT		4
+#define RCC_R46CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R46CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R46SEMCR register fields */
+#define RCC_R46SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R46SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R46SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R47CIDCFGR register fields */
+#define RCC_R47CIDCFGR_CFEN			BIT(0)
+#define RCC_R47CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R47CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R47CIDCFGR_SCID_SHIFT		4
+#define RCC_R47CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R47CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R47SEMCR register fields */
+#define RCC_R47SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R47SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R47SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R48CIDCFGR register fields */
+#define RCC_R48CIDCFGR_CFEN			BIT(0)
+#define RCC_R48CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R48CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R48CIDCFGR_SCID_SHIFT		4
+#define RCC_R48CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R48CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R48SEMCR register fields */
+#define RCC_R48SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R48SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R48SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R49CIDCFGR register fields */
+#define RCC_R49CIDCFGR_CFEN			BIT(0)
+#define RCC_R49CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R49CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R49CIDCFGR_SCID_SHIFT		4
+#define RCC_R49CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R49CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R49SEMCR register fields */
+#define RCC_R49SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R49SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R49SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R50CIDCFGR register fields */
+#define RCC_R50CIDCFGR_CFEN			BIT(0)
+#define RCC_R50CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R50CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R50CIDCFGR_SCID_SHIFT		4
+#define RCC_R50CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R50CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R50SEMCR register fields */
+#define RCC_R50SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R50SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R50SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R51CIDCFGR register fields */
+#define RCC_R51CIDCFGR_CFEN			BIT(0)
+#define RCC_R51CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R51CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R51CIDCFGR_SCID_SHIFT		4
+#define RCC_R51CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R51CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R51SEMCR register fields */
+#define RCC_R51SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R51SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R51SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R52CIDCFGR register fields */
+#define RCC_R52CIDCFGR_CFEN			BIT(0)
+#define RCC_R52CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R52CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R52CIDCFGR_SCID_SHIFT		4
+#define RCC_R52CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R52CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R52SEMCR register fields */
+#define RCC_R52SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R52SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R52SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R53CIDCFGR register fields */
+#define RCC_R53CIDCFGR_CFEN			BIT(0)
+#define RCC_R53CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R53CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R53CIDCFGR_SCID_SHIFT		4
+#define RCC_R53CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R53CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R53SEMCR register fields */
+#define RCC_R53SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R53SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R53SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R54CIDCFGR register fields */
+#define RCC_R54CIDCFGR_CFEN			BIT(0)
+#define RCC_R54CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R54CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R54CIDCFGR_SCID_SHIFT		4
+#define RCC_R54CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R54CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R54SEMCR register fields */
+#define RCC_R54SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R54SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R54SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R55CIDCFGR register fields */
+#define RCC_R55CIDCFGR_CFEN			BIT(0)
+#define RCC_R55CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R55CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R55CIDCFGR_SCID_SHIFT		4
+#define RCC_R55CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R55CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R55SEMCR register fields */
+#define RCC_R55SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R55SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R55SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R56CIDCFGR register fields */
+#define RCC_R56CIDCFGR_CFEN			BIT(0)
+#define RCC_R56CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R56CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R56CIDCFGR_SCID_SHIFT		4
+#define RCC_R56CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R56CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R56SEMCR register fields */
+#define RCC_R56SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R56SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R56SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R57CIDCFGR register fields */
+#define RCC_R57CIDCFGR_CFEN			BIT(0)
+#define RCC_R57CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R57CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R57CIDCFGR_SCID_SHIFT		4
+#define RCC_R57CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R57CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R57SEMCR register fields */
+#define RCC_R57SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R57SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R57SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R58CIDCFGR register fields */
+#define RCC_R58CIDCFGR_CFEN			BIT(0)
+#define RCC_R58CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R58CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R58CIDCFGR_SCID_SHIFT		4
+#define RCC_R58CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R58CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R58SEMCR register fields */
+#define RCC_R58SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R58SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R58SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R59CIDCFGR register fields */
+#define RCC_R59CIDCFGR_CFEN			BIT(0)
+#define RCC_R59CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R59CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R59CIDCFGR_SCID_SHIFT		4
+#define RCC_R59CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R59CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R59SEMCR register fields */
+#define RCC_R59SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R59SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R59SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R60CIDCFGR register fields */
+#define RCC_R60CIDCFGR_CFEN			BIT(0)
+#define RCC_R60CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R60CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R60CIDCFGR_SCID_SHIFT		4
+#define RCC_R60CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R60CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R60SEMCR register fields */
+#define RCC_R60SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R60SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R60SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R61CIDCFGR register fields */
+#define RCC_R61CIDCFGR_CFEN			BIT(0)
+#define RCC_R61CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R61CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R61CIDCFGR_SCID_SHIFT		4
+#define RCC_R61CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R61CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R61SEMCR register fields */
+#define RCC_R61SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R61SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R61SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R62CIDCFGR register fields */
+#define RCC_R62CIDCFGR_CFEN			BIT(0)
+#define RCC_R62CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R62CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R62CIDCFGR_SCID_SHIFT		4
+#define RCC_R62CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R62CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R62SEMCR register fields */
+#define RCC_R62SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R62SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R62SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R63CIDCFGR register fields */
+#define RCC_R63CIDCFGR_CFEN			BIT(0)
+#define RCC_R63CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R63CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R63CIDCFGR_SCID_SHIFT		4
+#define RCC_R63CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R63CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R63SEMCR register fields */
+#define RCC_R63SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R63SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R63SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R64CIDCFGR register fields */
+#define RCC_R64CIDCFGR_CFEN			BIT(0)
+#define RCC_R64CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R64CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R64CIDCFGR_SCID_SHIFT		4
+#define RCC_R64CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R64CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R64SEMCR register fields */
+#define RCC_R64SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R64SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R64SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R65CIDCFGR register fields */
+#define RCC_R65CIDCFGR_CFEN			BIT(0)
+#define RCC_R65CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R65CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R65CIDCFGR_SCID_SHIFT		4
+#define RCC_R65CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R65CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R65SEMCR register fields */
+#define RCC_R65SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R65SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R65SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R66CIDCFGR register fields */
+#define RCC_R66CIDCFGR_CFEN			BIT(0)
+#define RCC_R66CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R66CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R66CIDCFGR_SCID_SHIFT		4
+#define RCC_R66CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R66CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R66SEMCR register fields */
+#define RCC_R66SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R66SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R66SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R67CIDCFGR register fields */
+#define RCC_R67CIDCFGR_CFEN			BIT(0)
+#define RCC_R67CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R67CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R67CIDCFGR_SCID_SHIFT		4
+#define RCC_R67CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R67CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R67SEMCR register fields */
+#define RCC_R67SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R67SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R67SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R68CIDCFGR register fields */
+#define RCC_R68CIDCFGR_CFEN			BIT(0)
+#define RCC_R68CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R68CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R68CIDCFGR_SCID_SHIFT		4
+#define RCC_R68CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R68CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R68SEMCR register fields */
+#define RCC_R68SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R68SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R68SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R69CIDCFGR register fields */
+#define RCC_R69CIDCFGR_CFEN			BIT(0)
+#define RCC_R69CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R69CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R69CIDCFGR_SCID_SHIFT		4
+#define RCC_R69CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R69CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R69SEMCR register fields */
+#define RCC_R69SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R69SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R69SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R70CIDCFGR register fields */
+#define RCC_R70CIDCFGR_CFEN			BIT(0)
+#define RCC_R70CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R70CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R70CIDCFGR_SCID_SHIFT		4
+#define RCC_R70CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R70CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R70SEMCR register fields */
+#define RCC_R70SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R70SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R70SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R71CIDCFGR register fields */
+#define RCC_R71CIDCFGR_CFEN			BIT(0)
+#define RCC_R71CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R71CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R71CIDCFGR_SCID_SHIFT		4
+#define RCC_R71CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R71CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R71SEMCR register fields */
+#define RCC_R71SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R71SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R71SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R72CIDCFGR register fields */
+#define RCC_R72CIDCFGR_CFEN			BIT(0)
+#define RCC_R72CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R72CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R72CIDCFGR_SCID_SHIFT		4
+#define RCC_R72CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R72CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R72SEMCR register fields */
+#define RCC_R72SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R72SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R72SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R73CIDCFGR register fields */
+#define RCC_R73CIDCFGR_CFEN			BIT(0)
+#define RCC_R73CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R73CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R73CIDCFGR_SCID_SHIFT		4
+#define RCC_R73CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R73CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R73SEMCR register fields */
+#define RCC_R73SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R73SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R73SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R74CIDCFGR register fields */
+#define RCC_R74CIDCFGR_CFEN			BIT(0)
+#define RCC_R74CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R74CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R74CIDCFGR_SCID_SHIFT		4
+#define RCC_R74CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R74CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R74SEMCR register fields */
+#define RCC_R74SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R74SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R74SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R75CIDCFGR register fields */
+#define RCC_R75CIDCFGR_CFEN			BIT(0)
+#define RCC_R75CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R75CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R75CIDCFGR_SCID_SHIFT		4
+#define RCC_R75CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R75CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R75SEMCR register fields */
+#define RCC_R75SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R75SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R75SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R76CIDCFGR register fields */
+#define RCC_R76CIDCFGR_CFEN			BIT(0)
+#define RCC_R76CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R76CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R76CIDCFGR_SCID_SHIFT		4
+#define RCC_R76CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R76CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R76SEMCR register fields */
+#define RCC_R76SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R76SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R76SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R77CIDCFGR register fields */
+#define RCC_R77CIDCFGR_CFEN			BIT(0)
+#define RCC_R77CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R77CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R77CIDCFGR_SCID_SHIFT		4
+#define RCC_R77CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R77CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R77SEMCR register fields */
+#define RCC_R77SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R77SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R77SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R78CIDCFGR register fields */
+#define RCC_R78CIDCFGR_CFEN			BIT(0)
+#define RCC_R78CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R78CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R78CIDCFGR_SCID_SHIFT		4
+#define RCC_R78CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R78CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R78SEMCR register fields */
+#define RCC_R78SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R78SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R78SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R79CIDCFGR register fields */
+#define RCC_R79CIDCFGR_CFEN			BIT(0)
+#define RCC_R79CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R79CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R79CIDCFGR_SCID_SHIFT		4
+#define RCC_R79CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R79CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R79SEMCR register fields */
+#define RCC_R79SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R79SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R79SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R80CIDCFGR register fields */
+#define RCC_R80CIDCFGR_CFEN			BIT(0)
+#define RCC_R80CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R80CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R80CIDCFGR_SCID_SHIFT		4
+#define RCC_R80CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R80CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R80SEMCR register fields */
+#define RCC_R80SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R80SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R80SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R81CIDCFGR register fields */
+#define RCC_R81CIDCFGR_CFEN			BIT(0)
+#define RCC_R81CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R81CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R81CIDCFGR_SCID_SHIFT		4
+#define RCC_R81CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R81CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R81SEMCR register fields */
+#define RCC_R81SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R81SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R81SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R82CIDCFGR register fields */
+#define RCC_R82CIDCFGR_CFEN			BIT(0)
+#define RCC_R82CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R82CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R82CIDCFGR_SCID_SHIFT		4
+#define RCC_R82CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R82CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R82SEMCR register fields */
+#define RCC_R82SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R82SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R82SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R83CIDCFGR register fields */
+#define RCC_R83CIDCFGR_CFEN			BIT(0)
+#define RCC_R83CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R83CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R83CIDCFGR_SCID_SHIFT		4
+#define RCC_R83CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R83CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R83SEMCR register fields */
+#define RCC_R83SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R83SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R83SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R84CIDCFGR register fields */
+#define RCC_R84CIDCFGR_CFEN			BIT(0)
+#define RCC_R84CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R84CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R84CIDCFGR_SCID_SHIFT		4
+#define RCC_R84CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R84CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R84SEMCR register fields */
+#define RCC_R84SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R84SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R84SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R85CIDCFGR register fields */
+#define RCC_R85CIDCFGR_CFEN			BIT(0)
+#define RCC_R85CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R85CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R85CIDCFGR_SCID_SHIFT		4
+#define RCC_R85CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R85CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R85SEMCR register fields */
+#define RCC_R85SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R85SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R85SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R86CIDCFGR register fields */
+#define RCC_R86CIDCFGR_CFEN			BIT(0)
+#define RCC_R86CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R86CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R86CIDCFGR_SCID_SHIFT		4
+#define RCC_R86CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R86CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R86SEMCR register fields */
+#define RCC_R86SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R86SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R86SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R87CIDCFGR register fields */
+#define RCC_R87CIDCFGR_CFEN			BIT(0)
+#define RCC_R87CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R87CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R87CIDCFGR_SCID_SHIFT		4
+#define RCC_R87CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R87CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R87SEMCR register fields */
+#define RCC_R87SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R87SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R87SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R88CIDCFGR register fields */
+#define RCC_R88CIDCFGR_CFEN			BIT(0)
+#define RCC_R88CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R88CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R88CIDCFGR_SCID_SHIFT		4
+#define RCC_R88CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R88CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R88SEMCR register fields */
+#define RCC_R88SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R88SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R88SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R89CIDCFGR register fields */
+#define RCC_R89CIDCFGR_CFEN			BIT(0)
+#define RCC_R89CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R89CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R89CIDCFGR_SCID_SHIFT		4
+#define RCC_R89CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R89CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R89SEMCR register fields */
+#define RCC_R89SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R89SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R89SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R90CIDCFGR register fields */
+#define RCC_R90CIDCFGR_CFEN			BIT(0)
+#define RCC_R90CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R90CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R90CIDCFGR_SCID_SHIFT		4
+#define RCC_R90CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R90CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R90SEMCR register fields */
+#define RCC_R90SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R90SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R90SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R91CIDCFGR register fields */
+#define RCC_R91CIDCFGR_CFEN			BIT(0)
+#define RCC_R91CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R91CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R91CIDCFGR_SCID_SHIFT		4
+#define RCC_R91CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R91CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R91SEMCR register fields */
+#define RCC_R91SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R91SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R91SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R92CIDCFGR register fields */
+#define RCC_R92CIDCFGR_CFEN			BIT(0)
+#define RCC_R92CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R92CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R92CIDCFGR_SCID_SHIFT		4
+#define RCC_R92CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R92CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R92SEMCR register fields */
+#define RCC_R92SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R92SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R92SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R93CIDCFGR register fields */
+#define RCC_R93CIDCFGR_CFEN			BIT(0)
+#define RCC_R93CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R93CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R93CIDCFGR_SCID_SHIFT		4
+#define RCC_R93CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R93CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R93SEMCR register fields */
+#define RCC_R93SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R93SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R93SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R94CIDCFGR register fields */
+#define RCC_R94CIDCFGR_CFEN			BIT(0)
+#define RCC_R94CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R94CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R94CIDCFGR_SCID_SHIFT		4
+#define RCC_R94CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R94CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R94SEMCR register fields */
+#define RCC_R94SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R94SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R94SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R95CIDCFGR register fields */
+#define RCC_R95CIDCFGR_CFEN			BIT(0)
+#define RCC_R95CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R95CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R95CIDCFGR_SCID_SHIFT		4
+#define RCC_R95CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R95CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R95SEMCR register fields */
+#define RCC_R95SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R95SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R95SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R96CIDCFGR register fields */
+#define RCC_R96CIDCFGR_CFEN			BIT(0)
+#define RCC_R96CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R96CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R96CIDCFGR_SCID_SHIFT		4
+#define RCC_R96CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R96CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R96SEMCR register fields */
+#define RCC_R96SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R96SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R96SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R97CIDCFGR register fields */
+#define RCC_R97CIDCFGR_CFEN			BIT(0)
+#define RCC_R97CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R97CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R97CIDCFGR_SCID_SHIFT		4
+#define RCC_R97CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R97CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R97SEMCR register fields */
+#define RCC_R97SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R97SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R97SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R98CIDCFGR register fields */
+#define RCC_R98CIDCFGR_CFEN			BIT(0)
+#define RCC_R98CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R98CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R98CIDCFGR_SCID_SHIFT		4
+#define RCC_R98CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R98CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R98SEMCR register fields */
+#define RCC_R98SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R98SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R98SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R99CIDCFGR register fields */
+#define RCC_R99CIDCFGR_CFEN			BIT(0)
+#define RCC_R99CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R99CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R99CIDCFGR_SCID_SHIFT		4
+#define RCC_R99CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R99CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R99SEMCR register fields */
+#define RCC_R99SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R99SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R99SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R100CIDCFGR register fields */
+#define RCC_R100CIDCFGR_CFEN			BIT(0)
+#define RCC_R100CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R100CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R100CIDCFGR_SCID_SHIFT		4
+#define RCC_R100CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R100CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R100SEMCR register fields */
+#define RCC_R100SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R100SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R100SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R101CIDCFGR register fields */
+#define RCC_R101CIDCFGR_CFEN			BIT(0)
+#define RCC_R101CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R101CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R101CIDCFGR_SCID_SHIFT		4
+#define RCC_R101CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R101CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R101SEMCR register fields */
+#define RCC_R101SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R101SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R101SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R102CIDCFGR register fields */
+#define RCC_R102CIDCFGR_CFEN			BIT(0)
+#define RCC_R102CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R102CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R102CIDCFGR_SCID_SHIFT		4
+#define RCC_R102CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R102CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R102SEMCR register fields */
+#define RCC_R102SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R102SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R102SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R103CIDCFGR register fields */
+#define RCC_R103CIDCFGR_CFEN			BIT(0)
+#define RCC_R103CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R103CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R103CIDCFGR_SCID_SHIFT		4
+#define RCC_R103CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R103CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R103SEMCR register fields */
+#define RCC_R103SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R103SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R103SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R104CIDCFGR register fields */
+#define RCC_R104CIDCFGR_CFEN			BIT(0)
+#define RCC_R104CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R104CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R104CIDCFGR_SCID_SHIFT		4
+#define RCC_R104CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R104CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R104SEMCR register fields */
+#define RCC_R104SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R104SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R104SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R105CIDCFGR register fields */
+#define RCC_R105CIDCFGR_CFEN			BIT(0)
+#define RCC_R105CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R105CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R105CIDCFGR_SCID_SHIFT		4
+#define RCC_R105CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R105CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R105SEMCR register fields */
+#define RCC_R105SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R105SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R105SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R106CIDCFGR register fields */
+#define RCC_R106CIDCFGR_CFEN			BIT(0)
+#define RCC_R106CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R106CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R106CIDCFGR_SCID_SHIFT		4
+#define RCC_R106CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R106CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R106SEMCR register fields */
+#define RCC_R106SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R106SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R106SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R107CIDCFGR register fields */
+#define RCC_R107CIDCFGR_CFEN			BIT(0)
+#define RCC_R107CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R107CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R107CIDCFGR_SCID_SHIFT		4
+#define RCC_R107CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R107CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R107SEMCR register fields */
+#define RCC_R107SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R107SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R107SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R108CIDCFGR register fields */
+#define RCC_R108CIDCFGR_CFEN			BIT(0)
+#define RCC_R108CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R108CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R108CIDCFGR_SCID_SHIFT		4
+#define RCC_R108CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R108CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R108SEMCR register fields */
+#define RCC_R108SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R108SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R108SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R109CIDCFGR register fields */
+#define RCC_R109CIDCFGR_CFEN			BIT(0)
+#define RCC_R109CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R109CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R109CIDCFGR_SCID_SHIFT		4
+#define RCC_R109CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R109CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R109SEMCR register fields */
+#define RCC_R109SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R109SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R109SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R110CIDCFGR register fields */
+#define RCC_R110CIDCFGR_CFEN			BIT(0)
+#define RCC_R110CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R110CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R110CIDCFGR_SCID_SHIFT		4
+#define RCC_R110CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R110CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R110SEMCR register fields */
+#define RCC_R110SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R110SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R110SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R111CIDCFGR register fields */
+#define RCC_R111CIDCFGR_CFEN			BIT(0)
+#define RCC_R111CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R111CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R111CIDCFGR_SCID_SHIFT		4
+#define RCC_R111CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R111CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R111SEMCR register fields */
+#define RCC_R111SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R111SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R111SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R112CIDCFGR register fields */
+#define RCC_R112CIDCFGR_CFEN			BIT(0)
+#define RCC_R112CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R112CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R112CIDCFGR_SCID_SHIFT		4
+#define RCC_R112CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R112CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R112SEMCR register fields */
+#define RCC_R112SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R112SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R112SEMCR_SEMCID_SHIFT		4
+
+/* RCC_R113CIDCFGR register fields */
+#define RCC_R113CIDCFGR_CFEN			BIT(0)
+#define RCC_R113CIDCFGR_SEM_EN			BIT(1)
+#define RCC_R113CIDCFGR_SCID_MASK		GENMASK(6, 4)
+#define RCC_R113CIDCFGR_SCID_SHIFT		4
+#define RCC_R113CIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_R113CIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_R113SEMCR register fields */
+#define RCC_R113SEMCR_SEM_MUTEX			BIT(0)
+#define RCC_R113SEMCR_SEMCID_MASK		GENMASK(6, 4)
+#define RCC_R113SEMCR_SEMCID_SHIFT		4
+
+/* RCC_RxCIDCFGR register fields */
+#define RCC_RxCIDCFGR_CFEN			BIT(0)
+#define RCC_RxCIDCFGR_SEM_EN			BIT(1)
+#define RCC_RxCIDCFGR_SCID_MASK			GENMASK(6, 4)
+#define RCC_RxCIDCFGR_SCID_SHIFT		4
+#define RCC_RxCIDCFGR_SEMWLC_MASK		GENMASK(23, 16)
+#define RCC_RxCIDCFGR_SEMWLC_SHIFT		16
+
+/* RCC_RxSEMCR register fields */
+#define RCC_RxSEMCR_SEM_MUTEX			BIT(0)
+#define RCC_RxSEMCR_SEMCID_MASK			GENMASK(6, 4)
+#define RCC_RxSEMCR_SEMCID_SHIFT		4
+
+/* RCC_GRSTCSETR register fields */
+#define RCC_GRSTCSETR_SYSRST			BIT(0)
+
+/* RCC_C1RSTCSETR register fields */
+#define RCC_C1RSTCSETR_C1RST			BIT(0)
+
+/* RCC_C1P1RSTCSETR register fields */
+#define RCC_C1P1RSTCSETR_C1P1PORRST		BIT(0)
+#define RCC_C1P1RSTCSETR_C1P1RST		BIT(1)
+
+/* RCC_C2RSTCSETR register fields */
+#define RCC_C2RSTCSETR_C2RST			BIT(0)
+
+/* RCC_CxRSTCSETR register fields */
+#define RCC_CxRSTCSETR_CxRST			BIT(0)
+
+/* RCC_HWRSTSCLRR register fields */
+#define RCC_HWRSTSCLRR_PORRSTF			BIT(0)
+#define RCC_HWRSTSCLRR_BORRSTF			BIT(1)
+#define RCC_HWRSTSCLRR_PADRSTF			BIT(2)
+#define RCC_HWRSTSCLRR_HCSSRSTF			BIT(3)
+#define RCC_HWRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_HWRSTSCLRR_SYSC1RSTF		BIT(5)
+#define RCC_HWRSTSCLRR_SYSC2RSTF		BIT(6)
+#define RCC_HWRSTSCLRR_IWDG1SYSRSTF		BIT(7)
+#define RCC_HWRSTSCLRR_IWDG2SYSRSTF		BIT(8)
+#define RCC_HWRSTSCLRR_IWDG3SYSRSTF		BIT(9)
+#define RCC_HWRSTSCLRR_IWDG4SYSRSTF		BIT(10)
+#define RCC_HWRSTSCLRR_IWDG5SYSRSTF		BIT(11)
+#define RCC_HWRSTSCLRR_RETCRCERRRSTF		BIT(12)
+#define RCC_HWRSTSCLRR_RETECCFAILCRCRSTF	BIT(13)
+#define RCC_HWRSTSCLRR_RETECCFAILRESTRSTF	BIT(14)
+
+/* RCC_C1HWRSTSCLRR register fields */
+#define RCC_C1HWRSTSCLRR_VCPURSTF		BIT(0)
+#define RCC_C1HWRSTSCLRR_C1RSTF			BIT(1)
+#define RCC_C1HWRSTSCLRR_C1P1RSTF		BIT(2)
+
+/* RCC_C2HWRSTSCLRR register fields */
+#define RCC_C2HWRSTSCLRR_C2RSTF			BIT(0)
+
+/* RCC_C1BOOTRSTSSETR register fields */
+#define RCC_C1BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSSETR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSSETR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSSETR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSSETR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSSETR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1BOOTRSTSCLRR register fields */
+#define RCC_C1BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C1BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C1BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C1BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C1BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C1BOOTRSTSCLRR_VCPURSTF		BIT(5)
+#define RCC_C1BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C1BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C1BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C1BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C1BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C1BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C1BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C1BOOTRSTSCLRR_C1RSTF		BIT(13)
+#define RCC_C1BOOTRSTSCLRR_C1P1RSTF		BIT(16)
+#define RCC_C1BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C1BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C1BOOTRSTSCLRR_STBYC1RSTF		BIT(20)
+#define RCC_C1BOOTRSTSCLRR_D1STBYRSTF		BIT(22)
+#define RCC_C1BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSSETR register fields */
+#define RCC_C2BOOTRSTSSETR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSSETR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSSETR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSSETR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSSETR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSSETR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSSETR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSSETR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSSETR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSSETR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSSETR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSSETR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSSETR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSSETR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSSETR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSSETR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSSETR_D2STBYRSTF		BIT(23)
+
+/* RCC_C2BOOTRSTSCLRR register fields */
+#define RCC_C2BOOTRSTSCLRR_PORRSTF		BIT(0)
+#define RCC_C2BOOTRSTSCLRR_BORRSTF		BIT(1)
+#define RCC_C2BOOTRSTSCLRR_PADRSTF		BIT(2)
+#define RCC_C2BOOTRSTSCLRR_HCSSRSTF		BIT(3)
+#define RCC_C2BOOTRSTSCLRR_VCORERSTF		BIT(4)
+#define RCC_C2BOOTRSTSCLRR_SYSC1RSTF		BIT(6)
+#define RCC_C2BOOTRSTSCLRR_SYSC2RSTF		BIT(7)
+#define RCC_C2BOOTRSTSCLRR_IWDG1SYSRSTF		BIT(8)
+#define RCC_C2BOOTRSTSCLRR_IWDG2SYSRSTF		BIT(9)
+#define RCC_C2BOOTRSTSCLRR_IWDG3SYSRSTF		BIT(10)
+#define RCC_C2BOOTRSTSCLRR_IWDG4SYSRSTF		BIT(11)
+#define RCC_C2BOOTRSTSCLRR_IWDG5SYSRSTF		BIT(12)
+#define RCC_C2BOOTRSTSCLRR_C2RSTF		BIT(14)
+#define RCC_C2BOOTRSTSCLRR_RETCRCERRRSTF	BIT(17)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILCRCRSTF	BIT(18)
+#define RCC_C2BOOTRSTSCLRR_RETECCFAILRESTRSTF	BIT(19)
+#define RCC_C2BOOTRSTSCLRR_STBYC2RSTF		BIT(21)
+#define RCC_C2BOOTRSTSCLRR_D2STBYRSTF		BIT(23)
+
+/* RCC_C1SREQSETR register fields */
+#define RCC_C1SREQSETR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQSETR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQSETR_STPREQ_MASK		GENMASK(1, 0)
+#define RCC_C1SREQSETR_ESLPREQ			BIT(16)
+
+/* RCC_C1SREQCLRR register fields */
+#define RCC_C1SREQCLRR_STPREQ_P0		BIT(0)
+#define RCC_C1SREQCLRR_STPREQ_P1		BIT(1)
+#define RCC_C1SREQCLRR_STPREQ_MASK		GENMASK(1, 0)
+#define RCC_C1SREQCLRR_ESLPREQ			BIT(16)
+
+/* RCC_CPUBOOTCR register fields */
+#define RCC_CPUBOOTCR_BOOT_CPU2			BIT(0)
+#define RCC_CPUBOOTCR_BOOT_CPU1			BIT(1)
+
+/* RCC_STBYBOOTCR register fields */
+#define RCC_STBYBOOTCR_CPU_BEN_SEL		BIT(1)
+#define RCC_STBYBOOTCR_COLD_CPU2		BIT(2)
+#define RCC_STBYBOOTCR_CPU2_HW_BEN		BIT(4)
+#define RCC_STBYBOOTCR_CPU1_HW_BEN		BIT(5)
+#define RCC_STBYBOOTCR_RET_CRCERR_RSTEN		BIT(8)
+
+/* RCC_LEGBOOTCR register fields */
+#define RCC_LEGBOOTCR_LEGACY_BEN		BIT(0)
+
+/* RCC_BDCR register fields */
+#define RCC_BDCR_LSEON				BIT(0)
+#define RCC_BDCR_LSEBYP				BIT(1)
+#define RCC_BDCR_LSERDY				BIT(2)
+#define RCC_BDCR_LSEDIGBYP			BIT(3)
+#define RCC_BDCR_LSEDRV_MASK			GENMASK(5, 4)
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSECSSON			BIT(6)
+#define RCC_BDCR_LSEGFON			BIT(7)
+#define RCC_BDCR_LSECSSD			BIT(8)
+#define RCC_BDCR_LSION				BIT(9)
+#define RCC_BDCR_LSIRDY				BIT(10)
+#define RCC_BDCR_RTCSRC_MASK			GENMASK(17, 16)
+#define RCC_BDCR_RTCSRC_SHIFT			16
+#define RCC_BDCR_RTCCKEN			BIT(20)
+#define RCC_BDCR_MSIFREQSEL			BIT(24)
+#define RCC_BDCR_C3SYSTICKSEL			BIT(25)
+#define RCC_BDCR_VSWRST				BIT(31)
+#define RCC_BDCR_LSEBYP_BIT			1
+#define RCC_BDCR_LSEDIGBYP_BIT			3
+#define RCC_BDCR_LSECSSON_BIT			6
+#define RCC_BDCR_LSERDY_BIT			2
+#define RCC_BDCR_LSIRDY_BIT			10
+
+#define RCC_BDCR_LSEDRV_SHIFT			4
+#define RCC_BDCR_LSEDRV_WIDTH			2
+
+/* RCC_D3DCR register fields */
+#define RCC_D3DCR_MSION				BIT(0)
+#define RCC_D3DCR_MSIKERON			BIT(1)
+#define RCC_D3DCR_MSIRDY			BIT(2)
+#define RCC_D3DCR_D3PERCKSEL_MASK		GENMASK(17, 16)
+#define RCC_D3DCR_D3PERCKSEL_SHIFT		16
+#define RCC_D3DCR_MSIRDY_BIT			2
+
+/* RCC_D3DSR register fields */
+#define RCC_D3DSR_D3STATE_MASK			GENMASK(1, 0)
+#define RCC_D3DSR_D3STATE_SHIFT			0
+
+/* RCC_RDCR register fields */
+#define RCC_RDCR_MRD_MASK			GENMASK(20, 16)
+#define RCC_RDCR_MRD_SHIFT			16
+#define RCC_RDCR_EADLY_MASK			GENMASK(27, 24)
+#define RCC_RDCR_EADLY_SHIFT			24
+
+/* RCC_C1MSRDCR register fields */
+#define RCC_C1MSRDCR_C1MSRD_MASK		GENMASK(4, 0)
+#define RCC_C1MSRDCR_C1MSRD_SHIFT		0
+#define RCC_C1MSRDCR_C1MSRST			BIT(8)
+
+/* RCC_PWRLPDLYCR register fields */
+#define RCC_PWRLPDLYCR_PWRLP_DLY_MASK		GENMASK(21, 0)
+#define RCC_PWRLPDLYCR_PWRLP_DLY_SHIFT		0
+#define RCC_PWRLPDLYCR_CPU2TMPSKP		BIT(24)
+
+/* RCC_C1CIESETR register fields */
+#define RCC_C1CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C1CIESETR_LSERDYIE			BIT(1)
+#define RCC_C1CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C1CIESETR_HSERDYIE			BIT(3)
+#define RCC_C1CIESETR_CSIRDYIE			BIT(4)
+#define RCC_C1CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C1CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C1CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C1CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C1CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C1CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C1CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C1CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C1CIESETR_LSECSSIE			BIT(16)
+#define RCC_C1CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C1CIFCLRR register fields */
+#define RCC_C1CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C1CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C1CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C1CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C1CIFCLRR_CSIRDYF			BIT(4)
+#define RCC_C1CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C1CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C1CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C1CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C1CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C1CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C1CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C1CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C1CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C1CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_C2CIESETR register fields */
+#define RCC_C2CIESETR_LSIRDYIE			BIT(0)
+#define RCC_C2CIESETR_LSERDYIE			BIT(1)
+#define RCC_C2CIESETR_HSIRDYIE			BIT(2)
+#define RCC_C2CIESETR_HSERDYIE			BIT(3)
+#define RCC_C2CIESETR_CSIRDYIE			BIT(4)
+#define RCC_C2CIESETR_PLL1RDYIE			BIT(5)
+#define RCC_C2CIESETR_PLL2RDYIE			BIT(6)
+#define RCC_C2CIESETR_PLL3RDYIE			BIT(7)
+#define RCC_C2CIESETR_PLL4RDYIE			BIT(8)
+#define RCC_C2CIESETR_PLL5RDYIE			BIT(9)
+#define RCC_C2CIESETR_PLL6RDYIE			BIT(10)
+#define RCC_C2CIESETR_PLL7RDYIE			BIT(11)
+#define RCC_C2CIESETR_PLL8RDYIE			BIT(12)
+#define RCC_C2CIESETR_LSECSSIE			BIT(16)
+#define RCC_C2CIESETR_WKUPIE			BIT(20)
+
+/* RCC_C2CIFCLRR register fields */
+#define RCC_C2CIFCLRR_LSIRDYF			BIT(0)
+#define RCC_C2CIFCLRR_LSERDYF			BIT(1)
+#define RCC_C2CIFCLRR_HSIRDYF			BIT(2)
+#define RCC_C2CIFCLRR_HSERDYF			BIT(3)
+#define RCC_C2CIFCLRR_CSIRDYF			BIT(4)
+#define RCC_C2CIFCLRR_PLL1RDYF			BIT(5)
+#define RCC_C2CIFCLRR_PLL2RDYF			BIT(6)
+#define RCC_C2CIFCLRR_PLL3RDYF			BIT(7)
+#define RCC_C2CIFCLRR_PLL4RDYF			BIT(8)
+#define RCC_C2CIFCLRR_PLL5RDYF			BIT(9)
+#define RCC_C2CIFCLRR_PLL6RDYF			BIT(10)
+#define RCC_C2CIFCLRR_PLL7RDYF			BIT(11)
+#define RCC_C2CIFCLRR_PLL8RDYF			BIT(12)
+#define RCC_C2CIFCLRR_LSECSSF			BIT(16)
+#define RCC_C2CIFCLRR_WKUPF			BIT(20)
+
+/* RCC_CxCIESETR register fields */
+#define RCC_CxCIESETR_LSIRDYIE			BIT(0)
+#define RCC_CxCIESETR_LSERDYIE			BIT(1)
+#define RCC_CxCIESETR_HSIRDYIE			BIT(2)
+#define RCC_CxCIESETR_HSERDYIE			BIT(3)
+#define RCC_CxCIESETR_CSIRDYIE			BIT(4)
+#define RCC_CxCIESETR_SHSIRDYIE			BIT(5)
+#define RCC_CxCIESETR_PLL1RDYIE			BIT(6)
+#define RCC_CxCIESETR_PLL2RDYIE			BIT(7)
+#define RCC_CxCIESETR_PLL3RDYIE			BIT(8)
+#define RCC_CxCIESETR_PLL4RDYIE			BIT(9)
+#define RCC_CxCIESETR_PLL5RDYIE			BIT(10)
+#define RCC_CxCIESETR_PLL6RDYIE			BIT(11)
+#define RCC_CxCIESETR_PLL7RDYIE			BIT(12)
+#define RCC_CxCIESETR_PLL8RDYIE			BIT(13)
+#define RCC_CxCIESETR_LSECSSIE			BIT(16)
+#define RCC_CxCIESETR_WKUPIE			BIT(20)
+
+/* RCC_CxCIFCLRR register fields */
+#define RCC_CxCIFCLRR_LSIRDYF			BIT(0)
+#define RCC_CxCIFCLRR_LSERDYF			BIT(1)
+#define RCC_CxCIFCLRR_HSIRDYF			BIT(2)
+#define RCC_CxCIFCLRR_HSERDYF			BIT(3)
+#define RCC_CxCIFCLRR_CSIRDYF			BIT(4)
+#define RCC_CxCIFCLRR_SHSIRDYF			BIT(5)
+#define RCC_CxCIFCLRR_PLL1RDYF			BIT(6)
+#define RCC_CxCIFCLRR_PLL2RDYF			BIT(7)
+#define RCC_CxCIFCLRR_PLL3RDYF			BIT(8)
+#define RCC_CxCIFCLRR_PLL4RDYF			BIT(9)
+#define RCC_CxCIFCLRR_PLL5RDYF			BIT(10)
+#define RCC_CxCIFCLRR_PLL6RDYF			BIT(11)
+#define RCC_CxCIFCLRR_PLL7RDYF			BIT(12)
+#define RCC_CxCIFCLRR_PLL8RDYF			BIT(13)
+#define RCC_CxCIFCLRR_LSECSSF			BIT(16)
+#define RCC_CxCIFCLRR_WKUPF			BIT(20)
+
+/* RCC_IWDGC1FZSETR register fields */
+#define RCC_IWDGC1FZSETR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZSETR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1FZCLRR register fields */
+#define RCC_IWDGC1FZCLRR_FZ_IWDG1		BIT(0)
+#define RCC_IWDGC1FZCLRR_FZ_IWDG2		BIT(1)
+
+/* RCC_IWDGC1CFGSETR register fields */
+#define RCC_IWDGC1CFGSETR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGSETR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGSETR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC1CFGCLRR register fields */
+#define RCC_IWDGC1CFGCLRR_IWDG1_SYSRSTEN	BIT(0)
+#define RCC_IWDGC1CFGCLRR_IWDG2_SYSRSTEN	BIT(2)
+#define RCC_IWDGC1CFGCLRR_IWDG2_KERRST		BIT(18)
+
+/* RCC_IWDGC2FZSETR register fields */
+#define RCC_IWDGC2FZSETR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZSETR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2FZCLRR register fields */
+#define RCC_IWDGC2FZCLRR_FZ_IWDG3		BIT(0)
+#define RCC_IWDGC2FZCLRR_FZ_IWDG4		BIT(1)
+
+/* RCC_IWDGC2CFGSETR register fields */
+#define RCC_IWDGC2CFGSETR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGSETR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGSETR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC2CFGCLRR register fields */
+#define RCC_IWDGC2CFGCLRR_IWDG3_SYSRSTEN	BIT(0)
+#define RCC_IWDGC2CFGCLRR_IWDG4_SYSRSTEN	BIT(2)
+#define RCC_IWDGC2CFGCLRR_IWDG4_KERRST		BIT(18)
+
+/* RCC_IWDGC3CFGSETR register fields */
+#define RCC_IWDGC3CFGSETR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_IWDGC3CFGCLRR register fields */
+#define RCC_IWDGC3CFGCLRR_IWDG5_SYSRSTEN	BIT(0)
+
+/* RCC_C3CFGR register fields */
+#define RCC_C3CFGR_C3RST			BIT(0)
+#define RCC_C3CFGR_C3EN				BIT(1)
+#define RCC_C3CFGR_C3LPEN			BIT(2)
+#define RCC_C3CFGR_C3AMEN			BIT(3)
+#define RCC_C3CFGR_LPTIM3C3EN			BIT(16)
+#define RCC_C3CFGR_LPTIM4C3EN			BIT(17)
+#define RCC_C3CFGR_LPTIM5C3EN			BIT(18)
+#define RCC_C3CFGR_SPI8C3EN			BIT(19)
+#define RCC_C3CFGR_LPUART1C3EN			BIT(20)
+#define RCC_C3CFGR_I2C8C3EN			BIT(21)
+#define RCC_C3CFGR_ADF1C3EN			BIT(23)
+#define RCC_C3CFGR_GPIOZC3EN			BIT(24)
+#define RCC_C3CFGR_LPDMAC3EN			BIT(25)
+#define RCC_C3CFGR_RTCC3EN			BIT(26)
+#define RCC_C3CFGR_I3C4C3EN			BIT(27)
+
+/* RCC_MCO1CFGR register fields */
+#define RCC_MCO1CFGR_MCO1SEL			BIT(0)
+#define RCC_MCO1CFGR_MCO1ON			BIT(8)
+
+/* RCC_MCO2CFGR register fields */
+#define RCC_MCO2CFGR_MCO2SEL			BIT(0)
+#define RCC_MCO2CFGR_MCO2ON			BIT(8)
+
+/* RCC_MCOxCFGR register fields */
+#define RCC_MCOxCFGR_MCOxSEL			BIT(0)
+#define RCC_MCOxCFGR_MCOxON			BIT(8)
+
+/* RCC_OCENSETR register fields */
+#define RCC_OCENSETR_HSION			BIT(0)
+#define RCC_OCENSETR_HSIKERON			BIT(1)
+#define RCC_OCENSETR_HSEDIV2ON			BIT(5)
+#define RCC_OCENSETR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENSETR_HSEDIGBYP			BIT(7)
+#define RCC_OCENSETR_HSEON			BIT(8)
+#define RCC_OCENSETR_HSEKERON			BIT(9)
+#define RCC_OCENSETR_HSEBYP			BIT(10)
+#define RCC_OCENSETR_HSECSSON			BIT(11)
+
+/* RCC_OCENCLRR register fields */
+#define RCC_OCENCLRR_HSION			BIT(0)
+#define RCC_OCENCLRR_HSIKERON			BIT(1)
+#define RCC_OCENCLRR_HSEDIV2ON			BIT(5)
+#define RCC_OCENCLRR_HSEDIV2BYP			BIT(6)
+#define RCC_OCENCLRR_HSEDIGBYP			BIT(7)
+#define RCC_OCENCLRR_HSEON			BIT(8)
+#define RCC_OCENCLRR_HSEKERON			BIT(9)
+#define RCC_OCENCLRR_HSEBYP			BIT(10)
+
+/* RCC_OCRDYR register fields */
+#define RCC_OCRDYR_HSIRDY			BIT(0)
+#define RCC_OCRDYR_HSERDY			BIT(8)
+#define RCC_OCRDYR_CKREST			BIT(25)
+
+#define RCC_OCRDYR_HSIRDY_BIT			0
+#define RCC_OCRDYR_HSERDY_BIT			8
+
+/* RCC_HSICFGR register fields */
+#define RCC_HSICFGR_HSITRIM_MASK		GENMASK(14, 8)
+#define RCC_HSICFGR_HSITRIM_SHIFT		8
+#define RCC_HSICFGR_HSICAL_MASK			GENMASK(24, 16)
+#define RCC_HSICFGR_HSICAL_SHIFT		16
+
+/* RCC_CSICFGR register fields */
+#define RCC_CSICFGR_CSITRIM_MASK		GENMASK(12, 8)
+#define RCC_CSICFGR_CSITRIM_SHIFT		8
+#define RCC_CSICFGR_CSICAL_MASK			GENMASK(23, 16)
+#define RCC_CSICFGR_CSICAL_SHIFT		16
+
+/* RCC_RTCDIVR register fields */
+#define RCC_RTCDIVR_RTCDIV_MASK			GENMASK(5, 0)
+#define RCC_RTCDIVR_RTCDIV_SHIFT		0
+
+/* RCC_APB1DIVR register fields */
+#define RCC_APB1DIVR_APB1DIV_MASK		GENMASK(2, 0)
+#define RCC_APB1DIVR_APB1DIV_SHIFT		0
+#define RCC_APB1DIVR_APB1DIVRDY			BIT(31)
+
+/* RCC_APB2DIVR register fields */
+#define RCC_APB2DIVR_APB2DIV_MASK		GENMASK(2, 0)
+#define RCC_APB2DIVR_APB2DIV_SHIFT		0
+#define RCC_APB2DIVR_APB2DIVRDY			BIT(31)
+
+/* RCC_APB3DIVR register fields */
+#define RCC_APB3DIVR_APB3DIV_MASK		GENMASK(2, 0)
+#define RCC_APB3DIVR_APB3DIV_SHIFT		0
+#define RCC_APB3DIVR_APB3DIVRDY			BIT(31)
+
+/* RCC_APB4DIVR register fields */
+#define RCC_APB4DIVR_APB4DIV_MASK		GENMASK(2, 0)
+#define RCC_APB4DIVR_APB4DIV_SHIFT		0
+#define RCC_APB4DIVR_APB4DIVRDY			BIT(31)
+
+/* RCC_APBDBGDIVR register fields */
+#define RCC_APBDBGDIVR_APBDBGDIV_MASK		GENMASK(2, 0)
+#define RCC_APBDBGDIVR_APBDBGDIV_SHIFT		0
+#define RCC_APBDBGDIVR_APBDBGDIVRDY		BIT(31)
+
+/* RCC_APBxDIVR register fields */
+#define RCC_APBxDIVR_APBxDIV_MASK		GENMASK(2, 0)
+#define RCC_APBxDIVR_APBxDIV_SHIFT		0
+#define RCC_APBxDIVR_APBxDIVRDY			BIT(31)
+
+/* RCC_TIMG1PRER register fields */
+#define RCC_TIMG1PRER_TIMG1PRE			BIT(0)
+#define RCC_TIMG1PRER_TIMG1PRERDY		BIT(31)
+
+/* RCC_TIMG2PRER register fields */
+#define RCC_TIMG2PRER_TIMG2PRE			BIT(0)
+#define RCC_TIMG2PRER_TIMG2PRERDY		BIT(31)
+
+/* RCC_TIMGxPRER register fields */
+#define RCC_TIMGxPRER_TIMGxPRE			BIT(0)
+#define RCC_TIMGxPRER_TIMGxPRERDY		BIT(31)
+
+/* RCC_LSMCUDIVR register fields */
+#define RCC_LSMCUDIVR_LSMCUDIV			BIT(0)
+#define RCC_LSMCUDIVR_LSMCUDIVRDY		BIT(31)
+
+/* RCC_DDRCPCFGR register fields */
+#define RCC_DDRCPCFGR_DDRCPRST			BIT(0)
+#define RCC_DDRCPCFGR_DDRCPEN			BIT(1)
+#define RCC_DDRCPCFGR_DDRCPLPEN			BIT(2)
+
+/* RCC_DDRCAPBCFGR register fields */
+#define RCC_DDRCAPBCFGR_DDRCAPBRST		BIT(0)
+#define RCC_DDRCAPBCFGR_DDRCAPBEN		BIT(1)
+#define RCC_DDRCAPBCFGR_DDRCAPBLPEN		BIT(2)
+
+/* RCC_DDRPHYCAPBCFGR register fields */
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBRST	BIT(0)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBEN		BIT(1)
+#define RCC_DDRPHYCAPBCFGR_DDRPHYCAPBLPEN	BIT(2)
+
+/* RCC_DDRPHYCCFGR register fields */
+#define RCC_DDRPHYCCFGR_DDRPHYCEN		BIT(1)
+
+/* RCC_DDRCFGR register fields */
+#define RCC_DDRCFGR_DDRCFGRST			BIT(0)
+#define RCC_DDRCFGR_DDRCFGEN			BIT(1)
+#define RCC_DDRCFGR_DDRCFGLPEN			BIT(2)
+
+/* RCC_DDRITFCFGR register fields */
+#define RCC_DDRITFCFGR_DDRRST			BIT(0)
+#define RCC_DDRITFCFGR_DDRCKMOD_MASK		GENMASK(5, 4)
+#define RCC_DDRITFCFGR_DDRCKMOD_SHIFT		4
+#define RCC_DDRITFCFGR_DDRCKMOD_HSR		BIT(5)
+#define RCC_DDRITFCFGR_DDRSHR			BIT(8)
+#define RCC_DDRITFCFGR_DDRPHYDLP		BIT(16)
+
+/* RCC_SYSRAMCFGR register fields */
+#define RCC_SYSRAMCFGR_SYSRAMEN			BIT(1)
+#define RCC_SYSRAMCFGR_SYSRAMLPEN		BIT(2)
+
+/* RCC_VDERAMCFGR register fields */
+#define RCC_VDERAMCFGR_VDERAMEN			BIT(1)
+#define RCC_VDERAMCFGR_VDERAMLPEN		BIT(2)
+
+/* RCC_SRAM1CFGR register fields */
+#define RCC_SRAM1CFGR_SRAM1EN			BIT(1)
+#define RCC_SRAM1CFGR_SRAM1LPEN			BIT(2)
+
+/* RCC_SRAM2CFGR register fields */
+#define RCC_SRAM2CFGR_SRAM2EN			BIT(1)
+#define RCC_SRAM2CFGR_SRAM2LPEN			BIT(2)
+
+/* RCC_RETRAMCFGR register fields */
+#define RCC_RETRAMCFGR_RETRAMEN			BIT(1)
+#define RCC_RETRAMCFGR_RETRAMLPEN		BIT(2)
+
+/* RCC_BKPSRAMCFGR register fields */
+#define RCC_BKPSRAMCFGR_BKPSRAMEN		BIT(1)
+#define RCC_BKPSRAMCFGR_BKPSRAMLPEN		BIT(2)
+
+/* RCC_LPSRAM1CFGR register fields */
+#define RCC_LPSRAM1CFGR_LPSRAM1EN		BIT(1)
+#define RCC_LPSRAM1CFGR_LPSRAM1LPEN		BIT(2)
+#define RCC_LPSRAM1CFGR_LPSRAM1AMEN		BIT(3)
+
+/* RCC_LPSRAM2CFGR register fields */
+#define RCC_LPSRAM2CFGR_LPSRAM2EN		BIT(1)
+#define RCC_LPSRAM2CFGR_LPSRAM2LPEN		BIT(2)
+#define RCC_LPSRAM2CFGR_LPSRAM2AMEN		BIT(3)
+
+/* RCC_LPSRAM3CFGR register fields */
+#define RCC_LPSRAM3CFGR_LPSRAM3EN		BIT(1)
+#define RCC_LPSRAM3CFGR_LPSRAM3LPEN		BIT(2)
+#define RCC_LPSRAM3CFGR_LPSRAM3AMEN		BIT(3)
+
+/* RCC_OSPI1CFGR register fields */
+#define RCC_OSPI1CFGR_OSPI1RST			BIT(0)
+#define RCC_OSPI1CFGR_OSPI1EN			BIT(1)
+#define RCC_OSPI1CFGR_OSPI1LPEN			BIT(2)
+#define RCC_OSPI1CFGR_OTFDEC1RST		BIT(8)
+#define RCC_OSPI1CFGR_OSPI1DLLRST		BIT(16)
+
+/* RCC_OSPI2CFGR register fields */
+#define RCC_OSPI2CFGR_OSPI2RST			BIT(0)
+#define RCC_OSPI2CFGR_OSPI2EN			BIT(1)
+#define RCC_OSPI2CFGR_OSPI2LPEN			BIT(2)
+#define RCC_OSPI2CFGR_OTFDEC2RST		BIT(8)
+#define RCC_OSPI2CFGR_OSPI2DLLRST		BIT(16)
+
+/* RCC_OSPIxCFGR register fields */
+#define RCC_OSPIxCFGR_OSPIxRST			BIT(0)
+#define RCC_OSPIxCFGR_OSPIxEN			BIT(1)
+#define RCC_OSPIxCFGR_OSPIxLPEN			BIT(2)
+#define RCC_OSPIxCFGR_OTFDECxRST		BIT(8)
+#define RCC_OSPIxCFGR_OSPIxDLLRST		BIT(16)
+
+/* RCC_FMCCFGR register fields */
+#define RCC_FMCCFGR_FMCRST			BIT(0)
+#define RCC_FMCCFGR_FMCEN			BIT(1)
+#define RCC_FMCCFGR_FMCLPEN			BIT(2)
+
+/* RCC_DBGCFGR register fields */
+#define RCC_DBGCFGR_DBGEN			BIT(8)
+#define RCC_DBGCFGR_TRACEEN			BIT(9)
+#define RCC_DBGCFGR_DBGRST			BIT(12)
+
+/* RCC_STM500CFGR register fields */
+#define RCC_STM500CFGR_STM500EN			BIT(1)
+#define RCC_STM500CFGR_STM500LPEN		BIT(2)
+
+/* RCC_ETRCFGR register fields */
+#define RCC_ETRCFGR_ETREN			BIT(1)
+#define RCC_ETRCFGR_ETRLPEN			BIT(2)
+
+/* RCC_GPIOACFGR register fields */
+#define RCC_GPIOACFGR_GPIOARST			BIT(0)
+#define RCC_GPIOACFGR_GPIOAEN			BIT(1)
+#define RCC_GPIOACFGR_GPIOALPEN			BIT(2)
+
+/* RCC_GPIOBCFGR register fields */
+#define RCC_GPIOBCFGR_GPIOBRST			BIT(0)
+#define RCC_GPIOBCFGR_GPIOBEN			BIT(1)
+#define RCC_GPIOBCFGR_GPIOBLPEN			BIT(2)
+
+/* RCC_GPIOCCFGR register fields */
+#define RCC_GPIOCCFGR_GPIOCRST			BIT(0)
+#define RCC_GPIOCCFGR_GPIOCEN			BIT(1)
+#define RCC_GPIOCCFGR_GPIOCLPEN			BIT(2)
+
+/* RCC_GPIODCFGR register fields */
+#define RCC_GPIODCFGR_GPIODRST			BIT(0)
+#define RCC_GPIODCFGR_GPIODEN			BIT(1)
+#define RCC_GPIODCFGR_GPIODLPEN			BIT(2)
+
+/* RCC_GPIOECFGR register fields */
+#define RCC_GPIOECFGR_GPIOERST			BIT(0)
+#define RCC_GPIOECFGR_GPIOEEN			BIT(1)
+#define RCC_GPIOECFGR_GPIOELPEN			BIT(2)
+
+/* RCC_GPIOFCFGR register fields */
+#define RCC_GPIOFCFGR_GPIOFRST			BIT(0)
+#define RCC_GPIOFCFGR_GPIOFEN			BIT(1)
+#define RCC_GPIOFCFGR_GPIOFLPEN			BIT(2)
+
+/* RCC_GPIOGCFGR register fields */
+#define RCC_GPIOGCFGR_GPIOGRST			BIT(0)
+#define RCC_GPIOGCFGR_GPIOGEN			BIT(1)
+#define RCC_GPIOGCFGR_GPIOGLPEN			BIT(2)
+
+/* RCC_GPIOHCFGR register fields */
+#define RCC_GPIOHCFGR_GPIOHRST			BIT(0)
+#define RCC_GPIOHCFGR_GPIOHEN			BIT(1)
+#define RCC_GPIOHCFGR_GPIOHLPEN			BIT(2)
+
+/* RCC_GPIOICFGR register fields */
+#define RCC_GPIOICFGR_GPIOIRST			BIT(0)
+#define RCC_GPIOICFGR_GPIOIEN			BIT(1)
+#define RCC_GPIOICFGR_GPIOILPEN			BIT(2)
+
+/* RCC_GPIOJCFGR register fields */
+#define RCC_GPIOJCFGR_GPIOJRST			BIT(0)
+#define RCC_GPIOJCFGR_GPIOJEN			BIT(1)
+#define RCC_GPIOJCFGR_GPIOJLPEN			BIT(2)
+
+/* RCC_GPIOKCFGR register fields */
+#define RCC_GPIOKCFGR_GPIOKRST			BIT(0)
+#define RCC_GPIOKCFGR_GPIOKEN			BIT(1)
+#define RCC_GPIOKCFGR_GPIOKLPEN			BIT(2)
+
+/* RCC_GPIOZCFGR register fields */
+#define RCC_GPIOZCFGR_GPIOZRST			BIT(0)
+#define RCC_GPIOZCFGR_GPIOZEN			BIT(1)
+#define RCC_GPIOZCFGR_GPIOZLPEN			BIT(2)
+#define RCC_GPIOZCFGR_GPIOZAMEN			BIT(3)
+
+/* RCC_GPIOxCFGR register fields */
+#define RCC_GPIOxCFGR_GPIOxRST			BIT(0)
+#define RCC_GPIOxCFGR_GPIOxEN			BIT(1)
+#define RCC_GPIOxCFGR_GPIOxLPEN			BIT(2)
+#define RCC_GPIOxCFGR_GPIOxAMEN			BIT(3)
+
+/* RCC_HPDMA1CFGR register fields */
+#define RCC_HPDMA1CFGR_HPDMA1RST		BIT(0)
+#define RCC_HPDMA1CFGR_HPDMA1EN			BIT(1)
+#define RCC_HPDMA1CFGR_HPDMA1LPEN		BIT(2)
+
+/* RCC_HPDMA2CFGR register fields */
+#define RCC_HPDMA2CFGR_HPDMA2RST		BIT(0)
+#define RCC_HPDMA2CFGR_HPDMA2EN			BIT(1)
+#define RCC_HPDMA2CFGR_HPDMA2LPEN		BIT(2)
+
+/* RCC_HPDMA3CFGR register fields */
+#define RCC_HPDMA3CFGR_HPDMA3RST		BIT(0)
+#define RCC_HPDMA3CFGR_HPDMA3EN			BIT(1)
+#define RCC_HPDMA3CFGR_HPDMA3LPEN		BIT(2)
+
+/* RCC_HPDMAxCFGR register fields */
+#define RCC_HPDMAxCFGR_HPDMAxRST		BIT(0)
+#define RCC_HPDMAxCFGR_HPDMAxEN			BIT(1)
+#define RCC_HPDMAxCFGR_HPDMAxLPEN		BIT(2)
+
+/* RCC_LPDMACFGR register fields */
+#define RCC_LPDMACFGR_LPDMARST			BIT(0)
+#define RCC_LPDMACFGR_LPDMAEN			BIT(1)
+#define RCC_LPDMACFGR_LPDMALPEN			BIT(2)
+#define RCC_LPDMACFGR_LPDMAAMEN			BIT(3)
+
+/* RCC_HSEMCFGR register fields */
+#define RCC_HSEMCFGR_HSEMRST			BIT(0)
+#define RCC_HSEMCFGR_HSEMEN			BIT(1)
+#define RCC_HSEMCFGR_HSEMLPEN			BIT(2)
+#define RCC_HSEMCFGR_HSEMAMEN			BIT(3)
+
+/* RCC_IPCC1CFGR register fields */
+#define RCC_IPCC1CFGR_IPCC1RST			BIT(0)
+#define RCC_IPCC1CFGR_IPCC1EN			BIT(1)
+#define RCC_IPCC1CFGR_IPCC1LPEN			BIT(2)
+
+/* RCC_IPCC2CFGR register fields */
+#define RCC_IPCC2CFGR_IPCC2RST			BIT(0)
+#define RCC_IPCC2CFGR_IPCC2EN			BIT(1)
+#define RCC_IPCC2CFGR_IPCC2LPEN			BIT(2)
+#define RCC_IPCC2CFGR_IPCC2AMEN			BIT(3)
+
+/* RCC_RTCCFGR register fields */
+#define RCC_RTCCFGR_RTCEN			BIT(1)
+#define RCC_RTCCFGR_RTCLPEN			BIT(2)
+#define RCC_RTCCFGR_RTCAMEN			BIT(3)
+
+/* RCC_SYSCPU1CFGR register fields */
+#define RCC_SYSCPU1CFGR_SYSCPU1EN		BIT(1)
+#define RCC_SYSCPU1CFGR_SYSCPU1LPEN		BIT(2)
+
+/* RCC_BSECCFGR register fields */
+#define RCC_BSECCFGR_BSECEN			BIT(1)
+#define RCC_BSECCFGR_BSECLPEN			BIT(2)
+
+/* RCC_IS2MCFGR register fields */
+#define RCC_IS2MCFGR_IS2MRST			BIT(0)
+#define RCC_IS2MCFGR_IS2MEN			BIT(1)
+#define RCC_IS2MCFGR_IS2MLPEN			BIT(2)
+
+/* RCC_PLL2CFGR1 register fields */
+#define RCC_PLL2CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL2CFGR1_PLLEN			BIT(8)
+#define RCC_PLL2CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL2CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL2CFGR2 register fields */
+#define RCC_PLL2CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL2CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL2CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL2CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL2CFGR3 register fields */
+#define RCC_PLL2CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL2CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL2CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL2CFGR3_DACEN			BIT(25)
+#define RCC_PLL2CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL2CFGR4 register fields */
+#define RCC_PLL2CFGR4_DSMEN			BIT(8)
+#define RCC_PLL2CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL2CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL2CFGR5 register fields */
+#define RCC_PLL2CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL2CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL2CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL2CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL2CFGR6 register fields */
+#define RCC_PLL2CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL2CFGR7 register fields */
+#define RCC_PLL2CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL2CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL3CFGR1 register fields */
+#define RCC_PLL3CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL3CFGR1_PLLEN			BIT(8)
+#define RCC_PLL3CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL3CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL3CFGR2 register fields */
+#define RCC_PLL3CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL3CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL3CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL3CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL3CFGR3 register fields */
+#define RCC_PLL3CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL3CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL3CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL3CFGR3_DACEN			BIT(25)
+#define RCC_PLL3CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL3CFGR4 register fields */
+#define RCC_PLL3CFGR4_DSMEN			BIT(8)
+#define RCC_PLL3CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL3CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL3CFGR5 register fields */
+#define RCC_PLL3CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL3CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL3CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL3CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL3CFGR6 register fields */
+#define RCC_PLL3CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL3CFGR7 register fields */
+#define RCC_PLL3CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL3CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_HSIFMONCR register fields */
+#define RCC_HSIFMONCR_HSIREF_MASK		GENMASK(10, 0)
+#define RCC_HSIFMONCR_HSIREF_SHIFT		0
+#define RCC_HSIFMONCR_HSIMONEN			BIT(15)
+#define RCC_HSIFMONCR_HSIDEV_MASK		GENMASK(21, 16)
+#define RCC_HSIFMONCR_HSIDEV_SHIFT		16
+#define RCC_HSIFMONCR_HSIMONIE			BIT(30)
+#define RCC_HSIFMONCR_HSIMONF			BIT(31)
+
+/* RCC_HSIFVALR register fields */
+#define RCC_HSIFVALR_HSIVAL_MASK		GENMASK(10, 0)
+#define RCC_HSIFVALR_HSIVAL_SHIFT		0
+
+/* RCC_TIM1CFGR register fields */
+#define RCC_TIM1CFGR_TIM1RST			BIT(0)
+#define RCC_TIM1CFGR_TIM1EN			BIT(1)
+#define RCC_TIM1CFGR_TIM1LPEN			BIT(2)
+
+/* RCC_TIM2CFGR register fields */
+#define RCC_TIM2CFGR_TIM2RST			BIT(0)
+#define RCC_TIM2CFGR_TIM2EN			BIT(1)
+#define RCC_TIM2CFGR_TIM2LPEN			BIT(2)
+
+/* RCC_TIM3CFGR register fields */
+#define RCC_TIM3CFGR_TIM3RST			BIT(0)
+#define RCC_TIM3CFGR_TIM3EN			BIT(1)
+#define RCC_TIM3CFGR_TIM3LPEN			BIT(2)
+
+/* RCC_TIM4CFGR register fields */
+#define RCC_TIM4CFGR_TIM4RST			BIT(0)
+#define RCC_TIM4CFGR_TIM4EN			BIT(1)
+#define RCC_TIM4CFGR_TIM4LPEN			BIT(2)
+
+/* RCC_TIM5CFGR register fields */
+#define RCC_TIM5CFGR_TIM5RST			BIT(0)
+#define RCC_TIM5CFGR_TIM5EN			BIT(1)
+#define RCC_TIM5CFGR_TIM5LPEN			BIT(2)
+
+/* RCC_TIM6CFGR register fields */
+#define RCC_TIM6CFGR_TIM6RST			BIT(0)
+#define RCC_TIM6CFGR_TIM6EN			BIT(1)
+#define RCC_TIM6CFGR_TIM6LPEN			BIT(2)
+
+/* RCC_TIM7CFGR register fields */
+#define RCC_TIM7CFGR_TIM7RST			BIT(0)
+#define RCC_TIM7CFGR_TIM7EN			BIT(1)
+#define RCC_TIM7CFGR_TIM7LPEN			BIT(2)
+
+/* RCC_TIM8CFGR register fields */
+#define RCC_TIM8CFGR_TIM8RST			BIT(0)
+#define RCC_TIM8CFGR_TIM8EN			BIT(1)
+#define RCC_TIM8CFGR_TIM8LPEN			BIT(2)
+
+/* RCC_TIM10CFGR register fields */
+#define RCC_TIM10CFGR_TIM10RST			BIT(0)
+#define RCC_TIM10CFGR_TIM10EN			BIT(1)
+#define RCC_TIM10CFGR_TIM10LPEN			BIT(2)
+
+/* RCC_TIM11CFGR register fields */
+#define RCC_TIM11CFGR_TIM11RST			BIT(0)
+#define RCC_TIM11CFGR_TIM11EN			BIT(1)
+#define RCC_TIM11CFGR_TIM11LPEN			BIT(2)
+
+/* RCC_TIM12CFGR register fields */
+#define RCC_TIM12CFGR_TIM12RST			BIT(0)
+#define RCC_TIM12CFGR_TIM12EN			BIT(1)
+#define RCC_TIM12CFGR_TIM12LPEN			BIT(2)
+
+/* RCC_TIM13CFGR register fields */
+#define RCC_TIM13CFGR_TIM13RST			BIT(0)
+#define RCC_TIM13CFGR_TIM13EN			BIT(1)
+#define RCC_TIM13CFGR_TIM13LPEN			BIT(2)
+
+/* RCC_TIM14CFGR register fields */
+#define RCC_TIM14CFGR_TIM14RST			BIT(0)
+#define RCC_TIM14CFGR_TIM14EN			BIT(1)
+#define RCC_TIM14CFGR_TIM14LPEN			BIT(2)
+
+/* RCC_TIM15CFGR register fields */
+#define RCC_TIM15CFGR_TIM15RST			BIT(0)
+#define RCC_TIM15CFGR_TIM15EN			BIT(1)
+#define RCC_TIM15CFGR_TIM15LPEN			BIT(2)
+
+/* RCC_TIM16CFGR register fields */
+#define RCC_TIM16CFGR_TIM16RST			BIT(0)
+#define RCC_TIM16CFGR_TIM16EN			BIT(1)
+#define RCC_TIM16CFGR_TIM16LPEN			BIT(2)
+
+/* RCC_TIM17CFGR register fields */
+#define RCC_TIM17CFGR_TIM17RST			BIT(0)
+#define RCC_TIM17CFGR_TIM17EN			BIT(1)
+#define RCC_TIM17CFGR_TIM17LPEN			BIT(2)
+
+/* RCC_TIM20CFGR register fields */
+#define RCC_TIM20CFGR_TIM20RST			BIT(0)
+#define RCC_TIM20CFGR_TIM20EN			BIT(1)
+#define RCC_TIM20CFGR_TIM20LPEN			BIT(2)
+
+/* RCC_LPTIM1CFGR register fields */
+#define RCC_LPTIM1CFGR_LPTIM1RST		BIT(0)
+#define RCC_LPTIM1CFGR_LPTIM1EN			BIT(1)
+#define RCC_LPTIM1CFGR_LPTIM1LPEN		BIT(2)
+
+/* RCC_LPTIM2CFGR register fields */
+#define RCC_LPTIM2CFGR_LPTIM2RST		BIT(0)
+#define RCC_LPTIM2CFGR_LPTIM2EN			BIT(1)
+#define RCC_LPTIM2CFGR_LPTIM2LPEN		BIT(2)
+
+/* RCC_LPTIM3CFGR register fields */
+#define RCC_LPTIM3CFGR_LPTIM3RST		BIT(0)
+#define RCC_LPTIM3CFGR_LPTIM3EN			BIT(1)
+#define RCC_LPTIM3CFGR_LPTIM3LPEN		BIT(2)
+#define RCC_LPTIM3CFGR_LPTIM3AMEN		BIT(3)
+
+/* RCC_LPTIM4CFGR register fields */
+#define RCC_LPTIM4CFGR_LPTIM4RST		BIT(0)
+#define RCC_LPTIM4CFGR_LPTIM4EN			BIT(1)
+#define RCC_LPTIM4CFGR_LPTIM4LPEN		BIT(2)
+#define RCC_LPTIM4CFGR_LPTIM4AMEN		BIT(3)
+
+/* RCC_LPTIM5CFGR register fields */
+#define RCC_LPTIM5CFGR_LPTIM5RST		BIT(0)
+#define RCC_LPTIM5CFGR_LPTIM5EN			BIT(1)
+#define RCC_LPTIM5CFGR_LPTIM5LPEN		BIT(2)
+#define RCC_LPTIM5CFGR_LPTIM5AMEN		BIT(3)
+
+/* RCC_LPTIMxCFGR register fields */
+#define RCC_LPTIMxCFGR_LPTIMxRST		BIT(0)
+#define RCC_LPTIMxCFGR_LPTIMxEN			BIT(1)
+#define RCC_LPTIMxCFGR_LPTIMxLPEN		BIT(2)
+#define RCC_LPTIMxCFGR_LPTIMxAMEN		BIT(3)
+
+/* RCC_SPI1CFGR register fields */
+#define RCC_SPI1CFGR_SPI1RST			BIT(0)
+#define RCC_SPI1CFGR_SPI1EN			BIT(1)
+#define RCC_SPI1CFGR_SPI1LPEN			BIT(2)
+
+/* RCC_SPI2CFGR register fields */
+#define RCC_SPI2CFGR_SPI2RST			BIT(0)
+#define RCC_SPI2CFGR_SPI2EN			BIT(1)
+#define RCC_SPI2CFGR_SPI2LPEN			BIT(2)
+
+/* RCC_SPI3CFGR register fields */
+#define RCC_SPI3CFGR_SPI3RST			BIT(0)
+#define RCC_SPI3CFGR_SPI3EN			BIT(1)
+#define RCC_SPI3CFGR_SPI3LPEN			BIT(2)
+
+/* RCC_SPI4CFGR register fields */
+#define RCC_SPI4CFGR_SPI4RST			BIT(0)
+#define RCC_SPI4CFGR_SPI4EN			BIT(1)
+#define RCC_SPI4CFGR_SPI4LPEN			BIT(2)
+
+/* RCC_SPI5CFGR register fields */
+#define RCC_SPI5CFGR_SPI5RST			BIT(0)
+#define RCC_SPI5CFGR_SPI5EN			BIT(1)
+#define RCC_SPI5CFGR_SPI5LPEN			BIT(2)
+
+/* RCC_SPI6CFGR register fields */
+#define RCC_SPI6CFGR_SPI6RST			BIT(0)
+#define RCC_SPI6CFGR_SPI6EN			BIT(1)
+#define RCC_SPI6CFGR_SPI6LPEN			BIT(2)
+
+/* RCC_SPI7CFGR register fields */
+#define RCC_SPI7CFGR_SPI7RST			BIT(0)
+#define RCC_SPI7CFGR_SPI7EN			BIT(1)
+#define RCC_SPI7CFGR_SPI7LPEN			BIT(2)
+
+/* RCC_SPI8CFGR register fields */
+#define RCC_SPI8CFGR_SPI8RST			BIT(0)
+#define RCC_SPI8CFGR_SPI8EN			BIT(1)
+#define RCC_SPI8CFGR_SPI8LPEN			BIT(2)
+#define RCC_SPI8CFGR_SPI8AMEN			BIT(3)
+
+/* RCC_SPIxCFGR register fields */
+#define RCC_SPIxCFGR_SPIxRST			BIT(0)
+#define RCC_SPIxCFGR_SPIxEN			BIT(1)
+#define RCC_SPIxCFGR_SPIxLPEN			BIT(2)
+#define RCC_SPIxCFGR_SPIxAMEN			BIT(3)
+
+/* RCC_SPDIFRXCFGR register fields */
+#define RCC_SPDIFRXCFGR_SPDIFRXRST		BIT(0)
+#define RCC_SPDIFRXCFGR_SPDIFRXEN		BIT(1)
+#define RCC_SPDIFRXCFGR_SPDIFRXLPEN		BIT(2)
+
+/* RCC_USART1CFGR register fields */
+#define RCC_USART1CFGR_USART1RST		BIT(0)
+#define RCC_USART1CFGR_USART1EN			BIT(1)
+#define RCC_USART1CFGR_USART1LPEN		BIT(2)
+
+/* RCC_USART2CFGR register fields */
+#define RCC_USART2CFGR_USART2RST		BIT(0)
+#define RCC_USART2CFGR_USART2EN			BIT(1)
+#define RCC_USART2CFGR_USART2LPEN		BIT(2)
+
+/* RCC_USART3CFGR register fields */
+#define RCC_USART3CFGR_USART3RST		BIT(0)
+#define RCC_USART3CFGR_USART3EN			BIT(1)
+#define RCC_USART3CFGR_USART3LPEN		BIT(2)
+
+/* RCC_UART4CFGR register fields */
+#define RCC_UART4CFGR_UART4RST			BIT(0)
+#define RCC_UART4CFGR_UART4EN			BIT(1)
+#define RCC_UART4CFGR_UART4LPEN			BIT(2)
+
+/* RCC_UART5CFGR register fields */
+#define RCC_UART5CFGR_UART5RST			BIT(0)
+#define RCC_UART5CFGR_UART5EN			BIT(1)
+#define RCC_UART5CFGR_UART5LPEN			BIT(2)
+
+/* RCC_USART6CFGR register fields */
+#define RCC_USART6CFGR_USART6RST		BIT(0)
+#define RCC_USART6CFGR_USART6EN			BIT(1)
+#define RCC_USART6CFGR_USART6LPEN		BIT(2)
+
+/* RCC_UART7CFGR register fields */
+#define RCC_UART7CFGR_UART7RST			BIT(0)
+#define RCC_UART7CFGR_UART7EN			BIT(1)
+#define RCC_UART7CFGR_UART7LPEN			BIT(2)
+
+/* RCC_UART8CFGR register fields */
+#define RCC_UART8CFGR_UART8RST			BIT(0)
+#define RCC_UART8CFGR_UART8EN			BIT(1)
+#define RCC_UART8CFGR_UART8LPEN			BIT(2)
+
+/* RCC_UART9CFGR register fields */
+#define RCC_UART9CFGR_UART9RST			BIT(0)
+#define RCC_UART9CFGR_UART9EN			BIT(1)
+#define RCC_UART9CFGR_UART9LPEN			BIT(2)
+
+/* RCC_USARTxCFGR register fields */
+#define RCC_USARTxCFGR_USARTxRST		BIT(0)
+#define RCC_USARTxCFGR_USARTxEN			BIT(1)
+#define RCC_USARTxCFGR_USARTxLPEN		BIT(2)
+
+/* RCC_UARTxCFGR register fields */
+#define RCC_UARTxCFGR_UARTxRST			BIT(0)
+#define RCC_UARTxCFGR_UARTxEN			BIT(1)
+#define RCC_UARTxCFGR_UARTxLPEN			BIT(2)
+
+/* RCC_LPUART1CFGR register fields */
+#define RCC_LPUART1CFGR_LPUART1RST		BIT(0)
+#define RCC_LPUART1CFGR_LPUART1EN		BIT(1)
+#define RCC_LPUART1CFGR_LPUART1LPEN		BIT(2)
+#define RCC_LPUART1CFGR_LPUART1AMEN		BIT(3)
+
+/* RCC_I2C1CFGR register fields */
+#define RCC_I2C1CFGR_I2C1RST			BIT(0)
+#define RCC_I2C1CFGR_I2C1EN			BIT(1)
+#define RCC_I2C1CFGR_I2C1LPEN			BIT(2)
+
+/* RCC_I2C2CFGR register fields */
+#define RCC_I2C2CFGR_I2C2RST			BIT(0)
+#define RCC_I2C2CFGR_I2C2EN			BIT(1)
+#define RCC_I2C2CFGR_I2C2LPEN			BIT(2)
+
+/* RCC_I2C3CFGR register fields */
+#define RCC_I2C3CFGR_I2C3RST			BIT(0)
+#define RCC_I2C3CFGR_I2C3EN			BIT(1)
+#define RCC_I2C3CFGR_I2C3LPEN			BIT(2)
+
+/* RCC_I2C4CFGR register fields */
+#define RCC_I2C4CFGR_I2C4RST			BIT(0)
+#define RCC_I2C4CFGR_I2C4EN			BIT(1)
+#define RCC_I2C4CFGR_I2C4LPEN			BIT(2)
+
+/* RCC_I2C5CFGR register fields */
+#define RCC_I2C5CFGR_I2C5RST			BIT(0)
+#define RCC_I2C5CFGR_I2C5EN			BIT(1)
+#define RCC_I2C5CFGR_I2C5LPEN			BIT(2)
+
+/* RCC_I2C6CFGR register fields */
+#define RCC_I2C6CFGR_I2C6RST			BIT(0)
+#define RCC_I2C6CFGR_I2C6EN			BIT(1)
+#define RCC_I2C6CFGR_I2C6LPEN			BIT(2)
+
+/* RCC_I2C7CFGR register fields */
+#define RCC_I2C7CFGR_I2C7RST			BIT(0)
+#define RCC_I2C7CFGR_I2C7EN			BIT(1)
+#define RCC_I2C7CFGR_I2C7LPEN			BIT(2)
+
+/* RCC_I2C8CFGR register fields */
+#define RCC_I2C8CFGR_I2C8RST			BIT(0)
+#define RCC_I2C8CFGR_I2C8EN			BIT(1)
+#define RCC_I2C8CFGR_I2C8LPEN			BIT(2)
+#define RCC_I2C8CFGR_I2C8AMEN			BIT(3)
+
+/* RCC_I2CxCFGR register fields */
+#define RCC_I2CxCFGR_I2CxRST			BIT(0)
+#define RCC_I2CxCFGR_I2CxEN			BIT(1)
+#define RCC_I2CxCFGR_I2CxLPEN			BIT(2)
+#define RCC_I2CxCFGR_I2CxAMEN			BIT(3)
+
+/* RCC_SAI1CFGR register fields */
+#define RCC_SAI1CFGR_SAI1RST			BIT(0)
+#define RCC_SAI1CFGR_SAI1EN			BIT(1)
+#define RCC_SAI1CFGR_SAI1LPEN			BIT(2)
+
+/* RCC_SAI2CFGR register fields */
+#define RCC_SAI2CFGR_SAI2RST			BIT(0)
+#define RCC_SAI2CFGR_SAI2EN			BIT(1)
+#define RCC_SAI2CFGR_SAI2LPEN			BIT(2)
+
+/* RCC_SAI3CFGR register fields */
+#define RCC_SAI3CFGR_SAI3RST			BIT(0)
+#define RCC_SAI3CFGR_SAI3EN			BIT(1)
+#define RCC_SAI3CFGR_SAI3LPEN			BIT(2)
+
+/* RCC_SAI4CFGR register fields */
+#define RCC_SAI4CFGR_SAI4RST			BIT(0)
+#define RCC_SAI4CFGR_SAI4EN			BIT(1)
+#define RCC_SAI4CFGR_SAI4LPEN			BIT(2)
+
+/* RCC_SAIxCFGR register fields */
+#define RCC_SAIxCFGR_SAIxRST			BIT(0)
+#define RCC_SAIxCFGR_SAIxEN			BIT(1)
+#define RCC_SAIxCFGR_SAIxLPEN			BIT(2)
+
+/* RCC_MDF1CFGR register fields */
+#define RCC_MDF1CFGR_MDF1RST			BIT(0)
+#define RCC_MDF1CFGR_MDF1EN			BIT(1)
+#define RCC_MDF1CFGR_MDF1LPEN			BIT(2)
+
+/* RCC_ADF1CFGR register fields */
+#define RCC_ADF1CFGR_ADF1RST			BIT(0)
+#define RCC_ADF1CFGR_ADF1EN			BIT(1)
+#define RCC_ADF1CFGR_ADF1LPEN			BIT(2)
+#define RCC_ADF1CFGR_ADF1AMEN			BIT(3)
+
+/* RCC_FDCANCFGR register fields */
+#define RCC_FDCANCFGR_FDCANRST			BIT(0)
+#define RCC_FDCANCFGR_FDCANEN			BIT(1)
+#define RCC_FDCANCFGR_FDCANLPEN			BIT(2)
+
+/* RCC_HDPCFGR register fields */
+#define RCC_HDPCFGR_HDPRST			BIT(0)
+#define RCC_HDPCFGR_HDPEN			BIT(1)
+
+/* RCC_ADC12CFGR register fields */
+#define RCC_ADC12CFGR_ADC12RST			BIT(0)
+#define RCC_ADC12CFGR_ADC12EN			BIT(1)
+#define RCC_ADC12CFGR_ADC12LPEN			BIT(2)
+#define RCC_ADC12CFGR_ADC12KERSEL		BIT(12)
+
+/* RCC_ADC3CFGR register fields */
+#define RCC_ADC3CFGR_ADC3RST			BIT(0)
+#define RCC_ADC3CFGR_ADC3EN			BIT(1)
+#define RCC_ADC3CFGR_ADC3LPEN			BIT(2)
+#define RCC_ADC3CFGR_ADC3KERSEL_MASK		GENMASK(13, 12)
+#define RCC_ADC3CFGR_ADC3KERSEL_SHIFT		12
+
+/* RCC_ETH1CFGR register fields */
+#define RCC_ETH1CFGR_ETH1RST			BIT(0)
+#define RCC_ETH1CFGR_ETH1MACEN			BIT(1)
+#define RCC_ETH1CFGR_ETH1MACLPEN		BIT(2)
+#define RCC_ETH1CFGR_ETH1STPEN			BIT(4)
+#define RCC_ETH1CFGR_ETH1EN			BIT(5)
+#define RCC_ETH1CFGR_ETH1LPEN			BIT(6)
+#define RCC_ETH1CFGR_ETH1TXEN			BIT(8)
+#define RCC_ETH1CFGR_ETH1TXLPEN			BIT(9)
+#define RCC_ETH1CFGR_ETH1RXEN			BIT(10)
+#define RCC_ETH1CFGR_ETH1RXLPEN			BIT(11)
+
+/* RCC_ETH2CFGR register fields */
+#define RCC_ETH2CFGR_ETH2RST			BIT(0)
+#define RCC_ETH2CFGR_ETH2MACEN			BIT(1)
+#define RCC_ETH2CFGR_ETH2MACLPEN		BIT(2)
+#define RCC_ETH2CFGR_ETH2STPEN			BIT(4)
+#define RCC_ETH2CFGR_ETH2EN			BIT(5)
+#define RCC_ETH2CFGR_ETH2LPEN			BIT(6)
+#define RCC_ETH2CFGR_ETH2TXEN			BIT(8)
+#define RCC_ETH2CFGR_ETH2TXLPEN			BIT(9)
+#define RCC_ETH2CFGR_ETH2RXEN			BIT(10)
+#define RCC_ETH2CFGR_ETH2RXLPEN			BIT(11)
+
+/* RCC_ETHxCFGR register fields */
+#define RCC_ETHxCFGR_ETHxRST			BIT(0)
+#define RCC_ETHxCFGR_ETHxMACEN			BIT(1)
+#define RCC_ETHxCFGR_ETHxMACLPEN		BIT(2)
+#define RCC_ETHxCFGR_ETHxSTPEN			BIT(4)
+#define RCC_ETHxCFGR_ETHxEN			BIT(5)
+#define RCC_ETHxCFGR_ETHxLPEN			BIT(6)
+#define RCC_ETHxCFGR_ETHxTXEN			BIT(8)
+#define RCC_ETHxCFGR_ETHxTXLPEN			BIT(9)
+#define RCC_ETHxCFGR_ETHxRXEN			BIT(10)
+#define RCC_ETHxCFGR_ETHxRXLPEN			BIT(11)
+
+/* RCC_USB2CFGR register fields */
+#define RCC_USB2CFGR_USB2RST			BIT(0)
+#define RCC_USB2CFGR_USB2EN			BIT(1)
+#define RCC_USB2CFGR_USB2LPEN			BIT(2)
+#define RCC_USB2CFGR_USB2STPEN			BIT(4)
+
+/* RCC_USB2PHY1CFGR register fields */
+#define RCC_USB2PHY1CFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHY1CFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHY1CFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHY1CFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHY1CFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB2PHY2CFGR register fields */
+#define RCC_USB2PHY2CFGR_USB2PHY2RST		BIT(0)
+#define RCC_USB2PHY2CFGR_USB2PHY2EN		BIT(1)
+#define RCC_USB2PHY2CFGR_USB2PHY2LPEN		BIT(2)
+#define RCC_USB2PHY2CFGR_USB2PHY2STPEN		BIT(4)
+#define RCC_USB2PHY2CFGR_USB2PHY2CKREFSEL	BIT(15)
+
+/* RCC_USB2PHYxCFGR register fields */
+#define RCC_USB2PHYxCFGR_USB2PHY1RST		BIT(0)
+#define RCC_USB2PHYxCFGR_USB2PHY1EN		BIT(1)
+#define RCC_USB2PHYxCFGR_USB2PHY1LPEN		BIT(2)
+#define RCC_USB2PHYxCFGR_USB2PHY1STPEN		BIT(4)
+#define RCC_USB2PHYxCFGR_USB2PHY1CKREFSEL	BIT(15)
+
+/* RCC_USB3DRCFGR register fields */
+#define RCC_USB3DRCFGR_USB3DRRST		BIT(0)
+#define RCC_USB3DRCFGR_USB3DREN			BIT(1)
+#define RCC_USB3DRCFGR_USB3DRLPEN		BIT(2)
+#define RCC_USB3DRCFGR_USB3DRSTPEN		BIT(4)
+
+/* RCC_USB3PCIEPHYCFGR register fields */
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYRST	BIT(0)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYEN	BIT(1)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYLPEN	BIT(2)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYSTPEN	BIT(4)
+#define RCC_USB3PCIEPHYCFGR_USB3PCIEPHYCKREFSEL	BIT(15)
+
+/* RCC_PCIECFGR register fields */
+#define RCC_PCIECFGR_PCIERST			BIT(0)
+#define RCC_PCIECFGR_PCIEEN			BIT(1)
+#define RCC_PCIECFGR_PCIELPEN			BIT(2)
+#define RCC_PCIECFGR_PCIESTPEN			BIT(4)
+
+/* RCC_USBTCCFGR register fields */
+#define RCC_USBTCCFGR_USBTCRST			BIT(0)
+#define RCC_USBTCCFGR_USBTCEN			BIT(1)
+#define RCC_USBTCCFGR_USBTCLPEN			BIT(2)
+
+/* RCC_ETHSWCFGR register fields */
+#define RCC_ETHSWCFGR_ETHSWRST			BIT(0)
+#define RCC_ETHSWCFGR_ETHSWMACEN		BIT(1)
+#define RCC_ETHSWCFGR_ETHSWMACLPEN		BIT(2)
+#define RCC_ETHSWCFGR_ETHSWEN			BIT(5)
+#define RCC_ETHSWCFGR_ETHSWLPEN			BIT(6)
+#define RCC_ETHSWCFGR_ETHSWREFEN		BIT(21)
+#define RCC_ETHSWCFGR_ETHSWREFLPEN		BIT(22)
+
+/* RCC_ETHSWACMCFGR register fields */
+#define RCC_ETHSWACMCFGR_ETHSWACMEN		BIT(1)
+#define RCC_ETHSWACMCFGR_ETHSWACMLPEN		BIT(2)
+
+/* RCC_ETHSWACMMSGCFGR register fields */
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGEN	BIT(1)
+#define RCC_ETHSWACMMSGCFGR_ETHSWACMMSGLPEN	BIT(2)
+
+/* RCC_STGENCFGR register fields */
+#define RCC_STGENCFGR_STGENEN			BIT(1)
+#define RCC_STGENCFGR_STGENLPEN			BIT(2)
+#define RCC_STGENCFGR_STGENSTPEN		BIT(4)
+
+/* RCC_SDMMC1CFGR register fields */
+#define RCC_SDMMC1CFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMC1CFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMC1CFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMC1CFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_SDMMC2CFGR register fields */
+#define RCC_SDMMC2CFGR_SDMMC2RST		BIT(0)
+#define RCC_SDMMC2CFGR_SDMMC2EN			BIT(1)
+#define RCC_SDMMC2CFGR_SDMMC2LPEN		BIT(2)
+#define RCC_SDMMC2CFGR_SDMMC2DLLRST		BIT(16)
+
+/* RCC_SDMMC3CFGR register fields */
+#define RCC_SDMMC3CFGR_SDMMC3RST		BIT(0)
+#define RCC_SDMMC3CFGR_SDMMC3EN			BIT(1)
+#define RCC_SDMMC3CFGR_SDMMC3LPEN		BIT(2)
+#define RCC_SDMMC3CFGR_SDMMC3DLLRST		BIT(16)
+
+/* RCC_SDMMCxCFGR register fields */
+#define RCC_SDMMCxCFGR_SDMMC1RST		BIT(0)
+#define RCC_SDMMCxCFGR_SDMMC1EN			BIT(1)
+#define RCC_SDMMCxCFGR_SDMMC1LPEN		BIT(2)
+#define RCC_SDMMCxCFGR_SDMMC1DLLRST		BIT(16)
+
+/* RCC_GPUCFGR register fields */
+#define RCC_GPUCFGR_GPURST			BIT(0)
+#define RCC_GPUCFGR_GPUEN			BIT(1)
+#define RCC_GPUCFGR_GPULPEN			BIT(2)
+
+/* RCC_LTDCCFGR register fields */
+#define RCC_LTDCCFGR_LTDCRST			BIT(0)
+#define RCC_LTDCCFGR_LTDCEN			BIT(1)
+#define RCC_LTDCCFGR_LTDCLPEN			BIT(2)
+
+/* RCC_DSICFGR register fields */
+#define RCC_DSICFGR_DSIRST			BIT(0)
+#define RCC_DSICFGR_DSIEN			BIT(1)
+#define RCC_DSICFGR_DSILPEN			BIT(2)
+#define RCC_DSICFGR_DSIBLSEL			BIT(12)
+#define RCC_DSICFGR_DSIPHYCKREFSEL		BIT(15)
+
+/* RCC_LVDSCFGR register fields */
+#define RCC_LVDSCFGR_LVDSRST			BIT(0)
+#define RCC_LVDSCFGR_LVDSEN			BIT(1)
+#define RCC_LVDSCFGR_LVDSLPEN			BIT(2)
+#define RCC_LVDSCFGR_LVDSPHYCKREFSEL		BIT(15)
+
+/* RCC_CSI2CFGR register fields */
+#define RCC_CSI2CFGR_CSI2RST			BIT(0)
+#define RCC_CSI2CFGR_CSI2EN			BIT(1)
+#define RCC_CSI2CFGR_CSI2LPEN			BIT(2)
+
+/* RCC_DCMIPPCFGR register fields */
+#define RCC_DCMIPPCFGR_DCMIPPRST		BIT(0)
+#define RCC_DCMIPPCFGR_DCMIPPEN			BIT(1)
+#define RCC_DCMIPPCFGR_DCMIPPLPEN		BIT(2)
+
+/* RCC_CCICFGR register fields */
+#define RCC_CCICFGR_CCIRST			BIT(0)
+#define RCC_CCICFGR_CCIEN			BIT(1)
+#define RCC_CCICFGR_CCILPEN			BIT(2)
+
+/* RCC_VDECCFGR register fields */
+#define RCC_VDECCFGR_VDECRST			BIT(0)
+#define RCC_VDECCFGR_VDECEN			BIT(1)
+#define RCC_VDECCFGR_VDECLPEN			BIT(2)
+
+/* RCC_VENCCFGR register fields */
+#define RCC_VENCCFGR_VENCRST			BIT(0)
+#define RCC_VENCCFGR_VENCEN			BIT(1)
+#define RCC_VENCCFGR_VENCLPEN			BIT(2)
+
+/* RCC_RNGCFGR register fields */
+#define RCC_RNGCFGR_RNGRST			BIT(0)
+#define RCC_RNGCFGR_RNGEN			BIT(1)
+#define RCC_RNGCFGR_RNGLPEN			BIT(2)
+
+/* RCC_PKACFGR register fields */
+#define RCC_PKACFGR_PKARST			BIT(0)
+#define RCC_PKACFGR_PKAEN			BIT(1)
+#define RCC_PKACFGR_PKALPEN			BIT(2)
+
+/* RCC_SAESCFGR register fields */
+#define RCC_SAESCFGR_SAESRST			BIT(0)
+#define RCC_SAESCFGR_SAESEN			BIT(1)
+#define RCC_SAESCFGR_SAESLPEN			BIT(2)
+
+/* RCC_HASHCFGR register fields */
+#define RCC_HASHCFGR_HASHRST			BIT(0)
+#define RCC_HASHCFGR_HASHEN			BIT(1)
+#define RCC_HASHCFGR_HASHLPEN			BIT(2)
+
+/* RCC_CRYP1CFGR register fields */
+#define RCC_CRYP1CFGR_CRYP1RST			BIT(0)
+#define RCC_CRYP1CFGR_CRYP1EN			BIT(1)
+#define RCC_CRYP1CFGR_CRYP1LPEN			BIT(2)
+
+/* RCC_CRYP2CFGR register fields */
+#define RCC_CRYP2CFGR_CRYP2RST			BIT(0)
+#define RCC_CRYP2CFGR_CRYP2EN			BIT(1)
+#define RCC_CRYP2CFGR_CRYP2LPEN			BIT(2)
+
+/* RCC_CRYPxCFGR register fields */
+#define RCC_CRYPxCFGR_CRYPxRST			BIT(0)
+#define RCC_CRYPxCFGR_CRYPxEN			BIT(1)
+#define RCC_CRYPxCFGR_CRYPxLPEN			BIT(2)
+
+/* RCC_IWDG1CFGR register fields */
+#define RCC_IWDG1CFGR_IWDG1EN			BIT(1)
+#define RCC_IWDG1CFGR_IWDG1LPEN			BIT(2)
+
+/* RCC_IWDG2CFGR register fields */
+#define RCC_IWDG2CFGR_IWDG2EN			BIT(1)
+#define RCC_IWDG2CFGR_IWDG2LPEN			BIT(2)
+
+/* RCC_IWDG3CFGR register fields */
+#define RCC_IWDG3CFGR_IWDG3EN			BIT(1)
+#define RCC_IWDG3CFGR_IWDG3LPEN			BIT(2)
+
+/* RCC_IWDG4CFGR register fields */
+#define RCC_IWDG4CFGR_IWDG4EN			BIT(1)
+#define RCC_IWDG4CFGR_IWDG4LPEN			BIT(2)
+
+/* RCC_IWDGxCFGR register fields */
+#define RCC_IWDGxCFGR_IWDGxEN			BIT(1)
+#define RCC_IWDGxCFGR_IWDGxLPEN			BIT(2)
+
+/* RCC_IWDG5CFGR register fields */
+#define RCC_IWDG5CFGR_IWDG5EN			BIT(1)
+#define RCC_IWDG5CFGR_IWDG5LPEN			BIT(2)
+#define RCC_IWDG5CFGR_IWDG5AMEN			BIT(3)
+
+/* RCC_WWDG1CFGR register fields */
+#define RCC_WWDG1CFGR_WWDG1RST			BIT(0)
+#define RCC_WWDG1CFGR_WWDG1EN			BIT(1)
+#define RCC_WWDG1CFGR_WWDG1LPEN			BIT(2)
+
+/* RCC_WWDG2CFGR register fields */
+#define RCC_WWDG2CFGR_WWDG2RST			BIT(0)
+#define RCC_WWDG2CFGR_WWDG2EN			BIT(1)
+#define RCC_WWDG2CFGR_WWDG2LPEN			BIT(2)
+#define RCC_WWDG2CFGR_WWDG2AMEN			BIT(3)
+
+/* RCC_VREFCFGR register fields */
+#define RCC_VREFCFGR_VREFRST			BIT(0)
+#define RCC_VREFCFGR_VREFEN			BIT(1)
+#define RCC_VREFCFGR_VREFLPEN			BIT(2)
+
+/* RCC_TMPSENSCFGR register fields */
+#define RCC_TMPSENSCFGR_TMPSENSRST		BIT(0)
+#define RCC_TMPSENSCFGR_TMPSENSEN		BIT(1)
+#define RCC_TMPSENSCFGR_TMPSENSLPEN		BIT(2)
+#define RCC_TMPSENSCFGR_TMPSENSKERSEL_MASK	GENMASK(13, 12)
+#define RCC_TMPSENSCFGR_TMPSENSKERSEL_SHIFT	12
+
+/* RCC_CRCCFGR register fields */
+#define RCC_CRCCFGR_CRCRST			BIT(0)
+#define RCC_CRCCFGR_CRCEN			BIT(1)
+#define RCC_CRCCFGR_CRCLPEN			BIT(2)
+
+/* RCC_SERCCFGR register fields */
+#define RCC_SERCCFGR_SERCRST			BIT(0)
+#define RCC_SERCCFGR_SERCEN			BIT(1)
+#define RCC_SERCCFGR_SERCLPEN			BIT(2)
+
+/* RCC_OSPIIOMCFGR register fields */
+#define RCC_OSPIIOMCFGR_OSPIIOMRST		BIT(0)
+#define RCC_OSPIIOMCFGR_OSPIIOMEN		BIT(1)
+#define RCC_OSPIIOMCFGR_OSPIIOMLPEN		BIT(2)
+
+/* RCC_GICV2MCFGR register fields */
+#define RCC_GICV2MCFGR_GICV2MEN			BIT(1)
+#define RCC_GICV2MCFGR_GICV2MLPEN		BIT(2)
+
+/* RCC_I3C1CFGR register fields */
+#define RCC_I3C1CFGR_I3C1RST			BIT(0)
+#define RCC_I3C1CFGR_I3C1EN			BIT(1)
+#define RCC_I3C1CFGR_I3C1LPEN			BIT(2)
+
+/* RCC_I3C2CFGR register fields */
+#define RCC_I3C2CFGR_I3C2RST			BIT(0)
+#define RCC_I3C2CFGR_I3C2EN			BIT(1)
+#define RCC_I3C2CFGR_I3C2LPEN			BIT(2)
+
+/* RCC_I3C3CFGR register fields */
+#define RCC_I3C3CFGR_I3C3RST			BIT(0)
+#define RCC_I3C3CFGR_I3C3EN			BIT(1)
+#define RCC_I3C3CFGR_I3C3LPEN			BIT(2)
+
+/* RCC_I3C4CFGR register fields */
+#define RCC_I3C4CFGR_I3C4RST			BIT(0)
+#define RCC_I3C4CFGR_I3C4EN			BIT(1)
+#define RCC_I3C4CFGR_I3C4LPEN			BIT(2)
+#define RCC_I3C4CFGR_I3C4AMEN			BIT(3)
+
+/* RCC_I3CxCFGR register fields */
+#define RCC_I3CxCFGR_I3CxRST			BIT(0)
+#define RCC_I3CxCFGR_I3CxEN			BIT(1)
+#define RCC_I3CxCFGR_I3CxLPEN			BIT(2)
+#define RCC_I3CxCFGR_I3CxAMEN			BIT(3)
+
+/* RCC_MUXSELCFGR register fields */
+#define RCC_MUXSELCFGR_MUXSEL0_MASK		GENMASK(1, 0)
+#define RCC_MUXSELCFGR_MUXSEL0_SHIFT		0
+#define RCC_MUXSELCFGR_MUXSEL1_MASK		GENMASK(5, 4)
+#define RCC_MUXSELCFGR_MUXSEL1_SHIFT		4
+#define RCC_MUXSELCFGR_MUXSEL2_MASK		GENMASK(9, 8)
+#define RCC_MUXSELCFGR_MUXSEL2_SHIFT		8
+#define RCC_MUXSELCFGR_MUXSEL3_MASK		GENMASK(13, 12)
+#define RCC_MUXSELCFGR_MUXSEL3_SHIFT		12
+#define RCC_MUXSELCFGR_MUXSEL4_MASK		GENMASK(17, 16)
+#define RCC_MUXSELCFGR_MUXSEL4_SHIFT		16
+#define RCC_MUXSELCFGR_MUXSEL5_MASK		GENMASK(21, 20)
+#define RCC_MUXSELCFGR_MUXSEL5_SHIFT		20
+#define RCC_MUXSELCFGR_MUXSEL6_MASK		GENMASK(25, 24)
+#define RCC_MUXSELCFGR_MUXSEL6_SHIFT		24
+#define RCC_MUXSELCFGR_MUXSEL7_MASK		GENMASK(29, 28)
+#define RCC_MUXSELCFGR_MUXSEL7_SHIFT		28
+
+/* RCC_XBAR0CFGR register fields */
+#define RCC_XBAR0CFGR_XBAR0SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR0CFGR_XBAR0SEL_SHIFT		0
+#define RCC_XBAR0CFGR_XBAR0EN			BIT(6)
+#define RCC_XBAR0CFGR_XBAR0STS			BIT(7)
+
+/* RCC_XBAR1CFGR register fields */
+#define RCC_XBAR1CFGR_XBAR1SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR1CFGR_XBAR1SEL_SHIFT		0
+#define RCC_XBAR1CFGR_XBAR1EN			BIT(6)
+#define RCC_XBAR1CFGR_XBAR1STS			BIT(7)
+
+/* RCC_XBAR2CFGR register fields */
+#define RCC_XBAR2CFGR_XBAR2SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR2CFGR_XBAR2SEL_SHIFT		0
+#define RCC_XBAR2CFGR_XBAR2EN			BIT(6)
+#define RCC_XBAR2CFGR_XBAR2STS			BIT(7)
+
+/* RCC_XBAR3CFGR register fields */
+#define RCC_XBAR3CFGR_XBAR3SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR3CFGR_XBAR3SEL_SHIFT		0
+#define RCC_XBAR3CFGR_XBAR3EN			BIT(6)
+#define RCC_XBAR3CFGR_XBAR3STS			BIT(7)
+
+/* RCC_XBAR4CFGR register fields */
+#define RCC_XBAR4CFGR_XBAR4SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR4CFGR_XBAR4SEL_SHIFT		0
+#define RCC_XBAR4CFGR_XBAR4EN			BIT(6)
+#define RCC_XBAR4CFGR_XBAR4STS			BIT(7)
+
+/* RCC_XBAR5CFGR register fields */
+#define RCC_XBAR5CFGR_XBAR5SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR5CFGR_XBAR5SEL_SHIFT		0
+#define RCC_XBAR5CFGR_XBAR5EN			BIT(6)
+#define RCC_XBAR5CFGR_XBAR5STS			BIT(7)
+
+/* RCC_XBAR6CFGR register fields */
+#define RCC_XBAR6CFGR_XBAR6SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR6CFGR_XBAR6SEL_SHIFT		0
+#define RCC_XBAR6CFGR_XBAR6EN			BIT(6)
+#define RCC_XBAR6CFGR_XBAR6STS			BIT(7)
+
+/* RCC_XBAR7CFGR register fields */
+#define RCC_XBAR7CFGR_XBAR7SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR7CFGR_XBAR7SEL_SHIFT		0
+#define RCC_XBAR7CFGR_XBAR7EN			BIT(6)
+#define RCC_XBAR7CFGR_XBAR7STS			BIT(7)
+
+/* RCC_XBAR8CFGR register fields */
+#define RCC_XBAR8CFGR_XBAR8SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR8CFGR_XBAR8SEL_SHIFT		0
+#define RCC_XBAR8CFGR_XBAR8EN			BIT(6)
+#define RCC_XBAR8CFGR_XBAR8STS			BIT(7)
+
+/* RCC_XBAR9CFGR register fields */
+#define RCC_XBAR9CFGR_XBAR9SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR9CFGR_XBAR9SEL_SHIFT		0
+#define RCC_XBAR9CFGR_XBAR9EN			BIT(6)
+#define RCC_XBAR9CFGR_XBAR9STS			BIT(7)
+
+/* RCC_XBAR10CFGR register fields */
+#define RCC_XBAR10CFGR_XBAR10SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR10CFGR_XBAR10SEL_SHIFT		0
+#define RCC_XBAR10CFGR_XBAR10EN			BIT(6)
+#define RCC_XBAR10CFGR_XBAR10STS		BIT(7)
+
+/* RCC_XBAR11CFGR register fields */
+#define RCC_XBAR11CFGR_XBAR11SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR11CFGR_XBAR11SEL_SHIFT		0
+#define RCC_XBAR11CFGR_XBAR11EN			BIT(6)
+#define RCC_XBAR11CFGR_XBAR11STS		BIT(7)
+
+/* RCC_XBAR12CFGR register fields */
+#define RCC_XBAR12CFGR_XBAR12SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR12CFGR_XBAR12SEL_SHIFT		0
+#define RCC_XBAR12CFGR_XBAR12EN			BIT(6)
+#define RCC_XBAR12CFGR_XBAR12STS		BIT(7)
+
+/* RCC_XBAR13CFGR register fields */
+#define RCC_XBAR13CFGR_XBAR13SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR13CFGR_XBAR13SEL_SHIFT		0
+#define RCC_XBAR13CFGR_XBAR13EN			BIT(6)
+#define RCC_XBAR13CFGR_XBAR13STS		BIT(7)
+
+/* RCC_XBAR14CFGR register fields */
+#define RCC_XBAR14CFGR_XBAR14SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR14CFGR_XBAR14SEL_SHIFT		0
+#define RCC_XBAR14CFGR_XBAR14EN			BIT(6)
+#define RCC_XBAR14CFGR_XBAR14STS		BIT(7)
+
+/* RCC_XBAR15CFGR register fields */
+#define RCC_XBAR15CFGR_XBAR15SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR15CFGR_XBAR15SEL_SHIFT		0
+#define RCC_XBAR15CFGR_XBAR15EN			BIT(6)
+#define RCC_XBAR15CFGR_XBAR15STS		BIT(7)
+
+/* RCC_XBAR16CFGR register fields */
+#define RCC_XBAR16CFGR_XBAR16SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR16CFGR_XBAR16SEL_SHIFT		0
+#define RCC_XBAR16CFGR_XBAR16EN			BIT(6)
+#define RCC_XBAR16CFGR_XBAR16STS		BIT(7)
+
+/* RCC_XBAR17CFGR register fields */
+#define RCC_XBAR17CFGR_XBAR17SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR17CFGR_XBAR17SEL_SHIFT		0
+#define RCC_XBAR17CFGR_XBAR17EN			BIT(6)
+#define RCC_XBAR17CFGR_XBAR17STS		BIT(7)
+
+/* RCC_XBAR18CFGR register fields */
+#define RCC_XBAR18CFGR_XBAR18SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR18CFGR_XBAR18SEL_SHIFT		0
+#define RCC_XBAR18CFGR_XBAR18EN			BIT(6)
+#define RCC_XBAR18CFGR_XBAR18STS		BIT(7)
+
+/* RCC_XBAR19CFGR register fields */
+#define RCC_XBAR19CFGR_XBAR19SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR19CFGR_XBAR19SEL_SHIFT		0
+#define RCC_XBAR19CFGR_XBAR19EN			BIT(6)
+#define RCC_XBAR19CFGR_XBAR19STS		BIT(7)
+
+/* RCC_XBAR20CFGR register fields */
+#define RCC_XBAR20CFGR_XBAR20SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR20CFGR_XBAR20SEL_SHIFT		0
+#define RCC_XBAR20CFGR_XBAR20EN			BIT(6)
+#define RCC_XBAR20CFGR_XBAR20STS		BIT(7)
+
+/* RCC_XBAR21CFGR register fields */
+#define RCC_XBAR21CFGR_XBAR21SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR21CFGR_XBAR21SEL_SHIFT		0
+#define RCC_XBAR21CFGR_XBAR21EN			BIT(6)
+#define RCC_XBAR21CFGR_XBAR21STS		BIT(7)
+
+/* RCC_XBAR22CFGR register fields */
+#define RCC_XBAR22CFGR_XBAR22SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR22CFGR_XBAR22SEL_SHIFT		0
+#define RCC_XBAR22CFGR_XBAR22EN			BIT(6)
+#define RCC_XBAR22CFGR_XBAR22STS		BIT(7)
+
+/* RCC_XBAR23CFGR register fields */
+#define RCC_XBAR23CFGR_XBAR23SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR23CFGR_XBAR23SEL_SHIFT		0
+#define RCC_XBAR23CFGR_XBAR23EN			BIT(6)
+#define RCC_XBAR23CFGR_XBAR23STS		BIT(7)
+
+/* RCC_XBAR24CFGR register fields */
+#define RCC_XBAR24CFGR_XBAR24SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR24CFGR_XBAR24SEL_SHIFT		0
+#define RCC_XBAR24CFGR_XBAR24EN			BIT(6)
+#define RCC_XBAR24CFGR_XBAR24STS		BIT(7)
+
+/* RCC_XBAR25CFGR register fields */
+#define RCC_XBAR25CFGR_XBAR25SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR25CFGR_XBAR25SEL_SHIFT		0
+#define RCC_XBAR25CFGR_XBAR25EN			BIT(6)
+#define RCC_XBAR25CFGR_XBAR25STS		BIT(7)
+
+/* RCC_XBAR26CFGR register fields */
+#define RCC_XBAR26CFGR_XBAR26SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR26CFGR_XBAR26SEL_SHIFT		0
+#define RCC_XBAR26CFGR_XBAR26EN			BIT(6)
+#define RCC_XBAR26CFGR_XBAR26STS		BIT(7)
+
+/* RCC_XBAR27CFGR register fields */
+#define RCC_XBAR27CFGR_XBAR27SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR27CFGR_XBAR27SEL_SHIFT		0
+#define RCC_XBAR27CFGR_XBAR27EN			BIT(6)
+#define RCC_XBAR27CFGR_XBAR27STS		BIT(7)
+
+/* RCC_XBAR28CFGR register fields */
+#define RCC_XBAR28CFGR_XBAR28SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR28CFGR_XBAR28SEL_SHIFT		0
+#define RCC_XBAR28CFGR_XBAR28EN			BIT(6)
+#define RCC_XBAR28CFGR_XBAR28STS		BIT(7)
+
+/* RCC_XBAR29CFGR register fields */
+#define RCC_XBAR29CFGR_XBAR29SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR29CFGR_XBAR29SEL_SHIFT		0
+#define RCC_XBAR29CFGR_XBAR29EN			BIT(6)
+#define RCC_XBAR29CFGR_XBAR29STS		BIT(7)
+
+/* RCC_XBAR30CFGR register fields */
+#define RCC_XBAR30CFGR_XBAR30SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR30CFGR_XBAR30SEL_SHIFT		0
+#define RCC_XBAR30CFGR_XBAR30EN			BIT(6)
+#define RCC_XBAR30CFGR_XBAR30STS		BIT(7)
+
+/* RCC_XBAR31CFGR register fields */
+#define RCC_XBAR31CFGR_XBAR31SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR31CFGR_XBAR31SEL_SHIFT		0
+#define RCC_XBAR31CFGR_XBAR31EN			BIT(6)
+#define RCC_XBAR31CFGR_XBAR31STS		BIT(7)
+
+/* RCC_XBAR32CFGR register fields */
+#define RCC_XBAR32CFGR_XBAR32SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR32CFGR_XBAR32SEL_SHIFT		0
+#define RCC_XBAR32CFGR_XBAR32EN			BIT(6)
+#define RCC_XBAR32CFGR_XBAR32STS		BIT(7)
+
+/* RCC_XBAR33CFGR register fields */
+#define RCC_XBAR33CFGR_XBAR33SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR33CFGR_XBAR33SEL_SHIFT		0
+#define RCC_XBAR33CFGR_XBAR33EN			BIT(6)
+#define RCC_XBAR33CFGR_XBAR33STS		BIT(7)
+
+/* RCC_XBAR34CFGR register fields */
+#define RCC_XBAR34CFGR_XBAR34SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR34CFGR_XBAR34SEL_SHIFT		0
+#define RCC_XBAR34CFGR_XBAR34EN			BIT(6)
+#define RCC_XBAR34CFGR_XBAR34STS		BIT(7)
+
+/* RCC_XBAR35CFGR register fields */
+#define RCC_XBAR35CFGR_XBAR35SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR35CFGR_XBAR35SEL_SHIFT		0
+#define RCC_XBAR35CFGR_XBAR35EN			BIT(6)
+#define RCC_XBAR35CFGR_XBAR35STS		BIT(7)
+
+/* RCC_XBAR36CFGR register fields */
+#define RCC_XBAR36CFGR_XBAR36SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR36CFGR_XBAR36SEL_SHIFT		0
+#define RCC_XBAR36CFGR_XBAR36EN			BIT(6)
+#define RCC_XBAR36CFGR_XBAR36STS		BIT(7)
+
+/* RCC_XBAR37CFGR register fields */
+#define RCC_XBAR37CFGR_XBAR37SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR37CFGR_XBAR37SEL_SHIFT		0
+#define RCC_XBAR37CFGR_XBAR37EN			BIT(6)
+#define RCC_XBAR37CFGR_XBAR37STS		BIT(7)
+
+/* RCC_XBAR38CFGR register fields */
+#define RCC_XBAR38CFGR_XBAR38SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR38CFGR_XBAR38SEL_SHIFT		0
+#define RCC_XBAR38CFGR_XBAR38EN			BIT(6)
+#define RCC_XBAR38CFGR_XBAR38STS		BIT(7)
+
+/* RCC_XBAR39CFGR register fields */
+#define RCC_XBAR39CFGR_XBAR39SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR39CFGR_XBAR39SEL_SHIFT		0
+#define RCC_XBAR39CFGR_XBAR39EN			BIT(6)
+#define RCC_XBAR39CFGR_XBAR39STS		BIT(7)
+
+/* RCC_XBAR40CFGR register fields */
+#define RCC_XBAR40CFGR_XBAR40SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR40CFGR_XBAR40SEL_SHIFT		0
+#define RCC_XBAR40CFGR_XBAR40EN			BIT(6)
+#define RCC_XBAR40CFGR_XBAR40STS		BIT(7)
+
+/* RCC_XBAR41CFGR register fields */
+#define RCC_XBAR41CFGR_XBAR41SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR41CFGR_XBAR41SEL_SHIFT		0
+#define RCC_XBAR41CFGR_XBAR41EN			BIT(6)
+#define RCC_XBAR41CFGR_XBAR41STS		BIT(7)
+
+/* RCC_XBAR42CFGR register fields */
+#define RCC_XBAR42CFGR_XBAR42SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR42CFGR_XBAR42SEL_SHIFT		0
+#define RCC_XBAR42CFGR_XBAR42EN			BIT(6)
+#define RCC_XBAR42CFGR_XBAR42STS		BIT(7)
+
+/* RCC_XBAR43CFGR register fields */
+#define RCC_XBAR43CFGR_XBAR43SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR43CFGR_XBAR43SEL_SHIFT		0
+#define RCC_XBAR43CFGR_XBAR43EN			BIT(6)
+#define RCC_XBAR43CFGR_XBAR43STS		BIT(7)
+
+/* RCC_XBAR44CFGR register fields */
+#define RCC_XBAR44CFGR_XBAR44SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR44CFGR_XBAR44SEL_SHIFT		0
+#define RCC_XBAR44CFGR_XBAR44EN			BIT(6)
+#define RCC_XBAR44CFGR_XBAR44STS		BIT(7)
+
+/* RCC_XBAR45CFGR register fields */
+#define RCC_XBAR45CFGR_XBAR45SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR45CFGR_XBAR45SEL_SHIFT		0
+#define RCC_XBAR45CFGR_XBAR45EN			BIT(6)
+#define RCC_XBAR45CFGR_XBAR45STS		BIT(7)
+
+/* RCC_XBAR46CFGR register fields */
+#define RCC_XBAR46CFGR_XBAR46SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR46CFGR_XBAR46SEL_SHIFT		0
+#define RCC_XBAR46CFGR_XBAR46EN			BIT(6)
+#define RCC_XBAR46CFGR_XBAR46STS		BIT(7)
+
+/* RCC_XBAR47CFGR register fields */
+#define RCC_XBAR47CFGR_XBAR47SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR47CFGR_XBAR47SEL_SHIFT		0
+#define RCC_XBAR47CFGR_XBAR47EN			BIT(6)
+#define RCC_XBAR47CFGR_XBAR47STS		BIT(7)
+
+/* RCC_XBAR48CFGR register fields */
+#define RCC_XBAR48CFGR_XBAR48SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR48CFGR_XBAR48SEL_SHIFT		0
+#define RCC_XBAR48CFGR_XBAR48EN			BIT(6)
+#define RCC_XBAR48CFGR_XBAR48STS		BIT(7)
+
+/* RCC_XBAR49CFGR register fields */
+#define RCC_XBAR49CFGR_XBAR49SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR49CFGR_XBAR49SEL_SHIFT		0
+#define RCC_XBAR49CFGR_XBAR49EN			BIT(6)
+#define RCC_XBAR49CFGR_XBAR49STS		BIT(7)
+
+/* RCC_XBAR50CFGR register fields */
+#define RCC_XBAR50CFGR_XBAR50SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR50CFGR_XBAR50SEL_SHIFT		0
+#define RCC_XBAR50CFGR_XBAR50EN			BIT(6)
+#define RCC_XBAR50CFGR_XBAR50STS		BIT(7)
+
+/* RCC_XBAR51CFGR register fields */
+#define RCC_XBAR51CFGR_XBAR51SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR51CFGR_XBAR51SEL_SHIFT		0
+#define RCC_XBAR51CFGR_XBAR51EN			BIT(6)
+#define RCC_XBAR51CFGR_XBAR51STS		BIT(7)
+
+/* RCC_XBAR52CFGR register fields */
+#define RCC_XBAR52CFGR_XBAR52SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR52CFGR_XBAR52SEL_SHIFT		0
+#define RCC_XBAR52CFGR_XBAR52EN			BIT(6)
+#define RCC_XBAR52CFGR_XBAR52STS		BIT(7)
+
+/* RCC_XBAR53CFGR register fields */
+#define RCC_XBAR53CFGR_XBAR53SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR53CFGR_XBAR53SEL_SHIFT		0
+#define RCC_XBAR53CFGR_XBAR53EN			BIT(6)
+#define RCC_XBAR53CFGR_XBAR53STS		BIT(7)
+
+/* RCC_XBAR54CFGR register fields */
+#define RCC_XBAR54CFGR_XBAR54SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR54CFGR_XBAR54SEL_SHIFT		0
+#define RCC_XBAR54CFGR_XBAR54EN			BIT(6)
+#define RCC_XBAR54CFGR_XBAR54STS		BIT(7)
+
+/* RCC_XBAR55CFGR register fields */
+#define RCC_XBAR55CFGR_XBAR55SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR55CFGR_XBAR55SEL_SHIFT		0
+#define RCC_XBAR55CFGR_XBAR55EN			BIT(6)
+#define RCC_XBAR55CFGR_XBAR55STS		BIT(7)
+
+/* RCC_XBAR56CFGR register fields */
+#define RCC_XBAR56CFGR_XBAR56SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR56CFGR_XBAR56SEL_SHIFT		0
+#define RCC_XBAR56CFGR_XBAR56EN			BIT(6)
+#define RCC_XBAR56CFGR_XBAR56STS		BIT(7)
+
+/* RCC_XBAR57CFGR register fields */
+#define RCC_XBAR57CFGR_XBAR57SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR57CFGR_XBAR57SEL_SHIFT		0
+#define RCC_XBAR57CFGR_XBAR57EN			BIT(6)
+#define RCC_XBAR57CFGR_XBAR57STS		BIT(7)
+
+/* RCC_XBAR58CFGR register fields */
+#define RCC_XBAR58CFGR_XBAR58SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR58CFGR_XBAR58SEL_SHIFT		0
+#define RCC_XBAR58CFGR_XBAR58EN			BIT(6)
+#define RCC_XBAR58CFGR_XBAR58STS		BIT(7)
+
+/* RCC_XBAR59CFGR register fields */
+#define RCC_XBAR59CFGR_XBAR59SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR59CFGR_XBAR59SEL_SHIFT		0
+#define RCC_XBAR59CFGR_XBAR59EN			BIT(6)
+#define RCC_XBAR59CFGR_XBAR59STS		BIT(7)
+
+/* RCC_XBAR60CFGR register fields */
+#define RCC_XBAR60CFGR_XBAR60SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR60CFGR_XBAR60SEL_SHIFT		0
+#define RCC_XBAR60CFGR_XBAR60EN			BIT(6)
+#define RCC_XBAR60CFGR_XBAR60STS		BIT(7)
+
+/* RCC_XBAR61CFGR register fields */
+#define RCC_XBAR61CFGR_XBAR61SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR61CFGR_XBAR61SEL_SHIFT		0
+#define RCC_XBAR61CFGR_XBAR61EN			BIT(6)
+#define RCC_XBAR61CFGR_XBAR61STS		BIT(7)
+
+/* RCC_XBAR62CFGR register fields */
+#define RCC_XBAR62CFGR_XBAR62SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR62CFGR_XBAR62SEL_SHIFT		0
+#define RCC_XBAR62CFGR_XBAR62EN			BIT(6)
+#define RCC_XBAR62CFGR_XBAR62STS		BIT(7)
+
+/* RCC_XBAR63CFGR register fields */
+#define RCC_XBAR63CFGR_XBAR63SEL_MASK		GENMASK(3, 0)
+#define RCC_XBAR63CFGR_XBAR63SEL_SHIFT		0
+#define RCC_XBAR63CFGR_XBAR63EN			BIT(6)
+#define RCC_XBAR63CFGR_XBAR63STS		BIT(7)
+
+/* RCC_XBARxCFGR register fields */
+#define RCC_XBARxCFGR_XBARxSEL_MASK		GENMASK(3, 0)
+#define RCC_XBARxCFGR_XBARxSEL_SHIFT		0
+#define RCC_XBARxCFGR_XBARxEN			BIT(6)
+#define RCC_XBARxCFGR_XBARxSTS			BIT(7)
+
+/* RCC_PREDIV0CFGR register fields */
+#define RCC_PREDIV0CFGR_PREDIV0_MASK		GENMASK(9, 0)
+#define RCC_PREDIV0CFGR_PREDIV0_SHIFT		0
+
+/* RCC_PREDIV1CFGR register fields */
+#define RCC_PREDIV1CFGR_PREDIV1_MASK		GENMASK(9, 0)
+#define RCC_PREDIV1CFGR_PREDIV1_SHIFT		0
+
+/* RCC_PREDIV2CFGR register fields */
+#define RCC_PREDIV2CFGR_PREDIV2_MASK		GENMASK(9, 0)
+#define RCC_PREDIV2CFGR_PREDIV2_SHIFT		0
+
+/* RCC_PREDIV3CFGR register fields */
+#define RCC_PREDIV3CFGR_PREDIV3_MASK		GENMASK(9, 0)
+#define RCC_PREDIV3CFGR_PREDIV3_SHIFT		0
+
+/* RCC_PREDIV4CFGR register fields */
+#define RCC_PREDIV4CFGR_PREDIV4_MASK		GENMASK(9, 0)
+#define RCC_PREDIV4CFGR_PREDIV4_SHIFT		0
+
+/* RCC_PREDIV5CFGR register fields */
+#define RCC_PREDIV5CFGR_PREDIV5_MASK		GENMASK(9, 0)
+#define RCC_PREDIV5CFGR_PREDIV5_SHIFT		0
+
+/* RCC_PREDIV6CFGR register fields */
+#define RCC_PREDIV6CFGR_PREDIV6_MASK		GENMASK(9, 0)
+#define RCC_PREDIV6CFGR_PREDIV6_SHIFT		0
+
+/* RCC_PREDIV7CFGR register fields */
+#define RCC_PREDIV7CFGR_PREDIV7_MASK		GENMASK(9, 0)
+#define RCC_PREDIV7CFGR_PREDIV7_SHIFT		0
+
+/* RCC_PREDIV8CFGR register fields */
+#define RCC_PREDIV8CFGR_PREDIV8_MASK		GENMASK(9, 0)
+#define RCC_PREDIV8CFGR_PREDIV8_SHIFT		0
+
+/* RCC_PREDIV9CFGR register fields */
+#define RCC_PREDIV9CFGR_PREDIV9_MASK		GENMASK(9, 0)
+#define RCC_PREDIV9CFGR_PREDIV9_SHIFT		0
+
+/* RCC_PREDIV10CFGR register fields */
+#define RCC_PREDIV10CFGR_PREDIV10_MASK		GENMASK(9, 0)
+#define RCC_PREDIV10CFGR_PREDIV10_SHIFT		0
+
+/* RCC_PREDIV11CFGR register fields */
+#define RCC_PREDIV11CFGR_PREDIV11_MASK		GENMASK(9, 0)
+#define RCC_PREDIV11CFGR_PREDIV11_SHIFT		0
+
+/* RCC_PREDIV12CFGR register fields */
+#define RCC_PREDIV12CFGR_PREDIV12_MASK		GENMASK(9, 0)
+#define RCC_PREDIV12CFGR_PREDIV12_SHIFT		0
+
+/* RCC_PREDIV13CFGR register fields */
+#define RCC_PREDIV13CFGR_PREDIV13_MASK		GENMASK(9, 0)
+#define RCC_PREDIV13CFGR_PREDIV13_SHIFT		0
+
+/* RCC_PREDIV14CFGR register fields */
+#define RCC_PREDIV14CFGR_PREDIV14_MASK		GENMASK(9, 0)
+#define RCC_PREDIV14CFGR_PREDIV14_SHIFT		0
+
+/* RCC_PREDIV15CFGR register fields */
+#define RCC_PREDIV15CFGR_PREDIV15_MASK		GENMASK(9, 0)
+#define RCC_PREDIV15CFGR_PREDIV15_SHIFT		0
+
+/* RCC_PREDIV16CFGR register fields */
+#define RCC_PREDIV16CFGR_PREDIV16_MASK		GENMASK(9, 0)
+#define RCC_PREDIV16CFGR_PREDIV16_SHIFT		0
+
+/* RCC_PREDIV17CFGR register fields */
+#define RCC_PREDIV17CFGR_PREDIV17_MASK		GENMASK(9, 0)
+#define RCC_PREDIV17CFGR_PREDIV17_SHIFT		0
+
+/* RCC_PREDIV18CFGR register fields */
+#define RCC_PREDIV18CFGR_PREDIV18_MASK		GENMASK(9, 0)
+#define RCC_PREDIV18CFGR_PREDIV18_SHIFT		0
+
+/* RCC_PREDIV19CFGR register fields */
+#define RCC_PREDIV19CFGR_PREDIV19_MASK		GENMASK(9, 0)
+#define RCC_PREDIV19CFGR_PREDIV19_SHIFT		0
+
+/* RCC_PREDIV20CFGR register fields */
+#define RCC_PREDIV20CFGR_PREDIV20_MASK		GENMASK(9, 0)
+#define RCC_PREDIV20CFGR_PREDIV20_SHIFT		0
+
+/* RCC_PREDIV21CFGR register fields */
+#define RCC_PREDIV21CFGR_PREDIV21_MASK		GENMASK(9, 0)
+#define RCC_PREDIV21CFGR_PREDIV21_SHIFT		0
+
+/* RCC_PREDIV22CFGR register fields */
+#define RCC_PREDIV22CFGR_PREDIV22_MASK		GENMASK(9, 0)
+#define RCC_PREDIV22CFGR_PREDIV22_SHIFT		0
+
+/* RCC_PREDIV23CFGR register fields */
+#define RCC_PREDIV23CFGR_PREDIV23_MASK		GENMASK(9, 0)
+#define RCC_PREDIV23CFGR_PREDIV23_SHIFT		0
+
+/* RCC_PREDIV24CFGR register fields */
+#define RCC_PREDIV24CFGR_PREDIV24_MASK		GENMASK(9, 0)
+#define RCC_PREDIV24CFGR_PREDIV24_SHIFT		0
+
+/* RCC_PREDIV25CFGR register fields */
+#define RCC_PREDIV25CFGR_PREDIV25_MASK		GENMASK(9, 0)
+#define RCC_PREDIV25CFGR_PREDIV25_SHIFT		0
+
+/* RCC_PREDIV26CFGR register fields */
+#define RCC_PREDIV26CFGR_PREDIV26_MASK		GENMASK(9, 0)
+#define RCC_PREDIV26CFGR_PREDIV26_SHIFT		0
+
+/* RCC_PREDIV27CFGR register fields */
+#define RCC_PREDIV27CFGR_PREDIV27_MASK		GENMASK(9, 0)
+#define RCC_PREDIV27CFGR_PREDIV27_SHIFT		0
+
+/* RCC_PREDIV28CFGR register fields */
+#define RCC_PREDIV28CFGR_PREDIV28_MASK		GENMASK(9, 0)
+#define RCC_PREDIV28CFGR_PREDIV28_SHIFT		0
+
+/* RCC_PREDIV29CFGR register fields */
+#define RCC_PREDIV29CFGR_PREDIV29_MASK		GENMASK(9, 0)
+#define RCC_PREDIV29CFGR_PREDIV29_SHIFT		0
+
+/* RCC_PREDIV30CFGR register fields */
+#define RCC_PREDIV30CFGR_PREDIV30_MASK		GENMASK(9, 0)
+#define RCC_PREDIV30CFGR_PREDIV30_SHIFT		0
+
+/* RCC_PREDIV31CFGR register fields */
+#define RCC_PREDIV31CFGR_PREDIV31_MASK		GENMASK(9, 0)
+#define RCC_PREDIV31CFGR_PREDIV31_SHIFT		0
+
+/* RCC_PREDIV32CFGR register fields */
+#define RCC_PREDIV32CFGR_PREDIV32_MASK		GENMASK(9, 0)
+#define RCC_PREDIV32CFGR_PREDIV32_SHIFT		0
+
+/* RCC_PREDIV33CFGR register fields */
+#define RCC_PREDIV33CFGR_PREDIV33_MASK		GENMASK(9, 0)
+#define RCC_PREDIV33CFGR_PREDIV33_SHIFT		0
+
+/* RCC_PREDIV34CFGR register fields */
+#define RCC_PREDIV34CFGR_PREDIV34_MASK		GENMASK(9, 0)
+#define RCC_PREDIV34CFGR_PREDIV34_SHIFT		0
+
+/* RCC_PREDIV35CFGR register fields */
+#define RCC_PREDIV35CFGR_PREDIV35_MASK		GENMASK(9, 0)
+#define RCC_PREDIV35CFGR_PREDIV35_SHIFT		0
+
+/* RCC_PREDIV36CFGR register fields */
+#define RCC_PREDIV36CFGR_PREDIV36_MASK		GENMASK(9, 0)
+#define RCC_PREDIV36CFGR_PREDIV36_SHIFT		0
+
+/* RCC_PREDIV37CFGR register fields */
+#define RCC_PREDIV37CFGR_PREDIV37_MASK		GENMASK(9, 0)
+#define RCC_PREDIV37CFGR_PREDIV37_SHIFT		0
+
+/* RCC_PREDIV38CFGR register fields */
+#define RCC_PREDIV38CFGR_PREDIV38_MASK		GENMASK(9, 0)
+#define RCC_PREDIV38CFGR_PREDIV38_SHIFT		0
+
+/* RCC_PREDIV39CFGR register fields */
+#define RCC_PREDIV39CFGR_PREDIV39_MASK		GENMASK(9, 0)
+#define RCC_PREDIV39CFGR_PREDIV39_SHIFT		0
+
+/* RCC_PREDIV40CFGR register fields */
+#define RCC_PREDIV40CFGR_PREDIV40_MASK		GENMASK(9, 0)
+#define RCC_PREDIV40CFGR_PREDIV40_SHIFT		0
+
+/* RCC_PREDIV41CFGR register fields */
+#define RCC_PREDIV41CFGR_PREDIV41_MASK		GENMASK(9, 0)
+#define RCC_PREDIV41CFGR_PREDIV41_SHIFT		0
+
+/* RCC_PREDIV42CFGR register fields */
+#define RCC_PREDIV42CFGR_PREDIV42_MASK		GENMASK(9, 0)
+#define RCC_PREDIV42CFGR_PREDIV42_SHIFT		0
+
+/* RCC_PREDIV43CFGR register fields */
+#define RCC_PREDIV43CFGR_PREDIV43_MASK		GENMASK(9, 0)
+#define RCC_PREDIV43CFGR_PREDIV43_SHIFT		0
+
+/* RCC_PREDIV44CFGR register fields */
+#define RCC_PREDIV44CFGR_PREDIV44_MASK		GENMASK(9, 0)
+#define RCC_PREDIV44CFGR_PREDIV44_SHIFT		0
+
+/* RCC_PREDIV45CFGR register fields */
+#define RCC_PREDIV45CFGR_PREDIV45_MASK		GENMASK(9, 0)
+#define RCC_PREDIV45CFGR_PREDIV45_SHIFT		0
+
+/* RCC_PREDIV46CFGR register fields */
+#define RCC_PREDIV46CFGR_PREDIV46_MASK		GENMASK(9, 0)
+#define RCC_PREDIV46CFGR_PREDIV46_SHIFT		0
+
+/* RCC_PREDIV47CFGR register fields */
+#define RCC_PREDIV47CFGR_PREDIV47_MASK		GENMASK(9, 0)
+#define RCC_PREDIV47CFGR_PREDIV47_SHIFT		0
+
+/* RCC_PREDIV48CFGR register fields */
+#define RCC_PREDIV48CFGR_PREDIV48_MASK		GENMASK(9, 0)
+#define RCC_PREDIV48CFGR_PREDIV48_SHIFT		0
+
+/* RCC_PREDIV49CFGR register fields */
+#define RCC_PREDIV49CFGR_PREDIV49_MASK		GENMASK(9, 0)
+#define RCC_PREDIV49CFGR_PREDIV49_SHIFT		0
+
+/* RCC_PREDIV50CFGR register fields */
+#define RCC_PREDIV50CFGR_PREDIV50_MASK		GENMASK(9, 0)
+#define RCC_PREDIV50CFGR_PREDIV50_SHIFT		0
+
+/* RCC_PREDIV51CFGR register fields */
+#define RCC_PREDIV51CFGR_PREDIV51_MASK		GENMASK(9, 0)
+#define RCC_PREDIV51CFGR_PREDIV51_SHIFT		0
+
+/* RCC_PREDIV52CFGR register fields */
+#define RCC_PREDIV52CFGR_PREDIV52_MASK		GENMASK(9, 0)
+#define RCC_PREDIV52CFGR_PREDIV52_SHIFT		0
+
+/* RCC_PREDIV53CFGR register fields */
+#define RCC_PREDIV53CFGR_PREDIV53_MASK		GENMASK(9, 0)
+#define RCC_PREDIV53CFGR_PREDIV53_SHIFT		0
+
+/* RCC_PREDIV54CFGR register fields */
+#define RCC_PREDIV54CFGR_PREDIV54_MASK		GENMASK(9, 0)
+#define RCC_PREDIV54CFGR_PREDIV54_SHIFT		0
+
+/* RCC_PREDIV55CFGR register fields */
+#define RCC_PREDIV55CFGR_PREDIV55_MASK		GENMASK(9, 0)
+#define RCC_PREDIV55CFGR_PREDIV55_SHIFT		0
+
+/* RCC_PREDIV56CFGR register fields */
+#define RCC_PREDIV56CFGR_PREDIV56_MASK		GENMASK(9, 0)
+#define RCC_PREDIV56CFGR_PREDIV56_SHIFT		0
+
+/* RCC_PREDIV57CFGR register fields */
+#define RCC_PREDIV57CFGR_PREDIV57_MASK		GENMASK(9, 0)
+#define RCC_PREDIV57CFGR_PREDIV57_SHIFT		0
+
+/* RCC_PREDIV58CFGR register fields */
+#define RCC_PREDIV58CFGR_PREDIV58_MASK		GENMASK(9, 0)
+#define RCC_PREDIV58CFGR_PREDIV58_SHIFT		0
+
+/* RCC_PREDIV59CFGR register fields */
+#define RCC_PREDIV59CFGR_PREDIV59_MASK		GENMASK(9, 0)
+#define RCC_PREDIV59CFGR_PREDIV59_SHIFT		0
+
+/* RCC_PREDIV60CFGR register fields */
+#define RCC_PREDIV60CFGR_PREDIV60_MASK		GENMASK(9, 0)
+#define RCC_PREDIV60CFGR_PREDIV60_SHIFT		0
+
+/* RCC_PREDIV61CFGR register fields */
+#define RCC_PREDIV61CFGR_PREDIV61_MASK		GENMASK(9, 0)
+#define RCC_PREDIV61CFGR_PREDIV61_SHIFT		0
+
+/* RCC_PREDIV62CFGR register fields */
+#define RCC_PREDIV62CFGR_PREDIV62_MASK		GENMASK(9, 0)
+#define RCC_PREDIV62CFGR_PREDIV62_SHIFT		0
+
+/* RCC_PREDIV63CFGR register fields */
+#define RCC_PREDIV63CFGR_PREDIV63_MASK		GENMASK(9, 0)
+#define RCC_PREDIV63CFGR_PREDIV63_SHIFT		0
+
+/* RCC_PREDIVxCFGR register fields */
+#define RCC_PREDIVxCFGR_PREDIVx_MASK		GENMASK(9, 0)
+#define RCC_PREDIVxCFGR_PREDIVx_SHIFT		0
+
+/* RCC_FINDIV0CFGR register fields */
+#define RCC_FINDIV0CFGR_FINDIV0_MASK		GENMASK(5, 0)
+#define RCC_FINDIV0CFGR_FINDIV0_SHIFT		0
+#define RCC_FINDIV0CFGR_FINDIV0EN		BIT(6)
+
+/* RCC_FINDIV1CFGR register fields */
+#define RCC_FINDIV1CFGR_FINDIV1_MASK		GENMASK(5, 0)
+#define RCC_FINDIV1CFGR_FINDIV1_SHIFT		0
+#define RCC_FINDIV1CFGR_FINDIV1EN		BIT(6)
+
+/* RCC_FINDIV2CFGR register fields */
+#define RCC_FINDIV2CFGR_FINDIV2_MASK		GENMASK(5, 0)
+#define RCC_FINDIV2CFGR_FINDIV2_SHIFT		0
+#define RCC_FINDIV2CFGR_FINDIV2EN		BIT(6)
+
+/* RCC_FINDIV3CFGR register fields */
+#define RCC_FINDIV3CFGR_FINDIV3_MASK		GENMASK(5, 0)
+#define RCC_FINDIV3CFGR_FINDIV3_SHIFT		0
+#define RCC_FINDIV3CFGR_FINDIV3EN		BIT(6)
+
+/* RCC_FINDIV4CFGR register fields */
+#define RCC_FINDIV4CFGR_FINDIV4_MASK		GENMASK(5, 0)
+#define RCC_FINDIV4CFGR_FINDIV4_SHIFT		0
+#define RCC_FINDIV4CFGR_FINDIV4EN		BIT(6)
+
+/* RCC_FINDIV5CFGR register fields */
+#define RCC_FINDIV5CFGR_FINDIV5_MASK		GENMASK(5, 0)
+#define RCC_FINDIV5CFGR_FINDIV5_SHIFT		0
+#define RCC_FINDIV5CFGR_FINDIV5EN		BIT(6)
+
+/* RCC_FINDIV6CFGR register fields */
+#define RCC_FINDIV6CFGR_FINDIV6_MASK		GENMASK(5, 0)
+#define RCC_FINDIV6CFGR_FINDIV6_SHIFT		0
+#define RCC_FINDIV6CFGR_FINDIV6EN		BIT(6)
+
+/* RCC_FINDIV7CFGR register fields */
+#define RCC_FINDIV7CFGR_FINDIV7_MASK		GENMASK(5, 0)
+#define RCC_FINDIV7CFGR_FINDIV7_SHIFT		0
+#define RCC_FINDIV7CFGR_FINDIV7EN		BIT(6)
+
+/* RCC_FINDIV8CFGR register fields */
+#define RCC_FINDIV8CFGR_FINDIV8_MASK		GENMASK(5, 0)
+#define RCC_FINDIV8CFGR_FINDIV8_SHIFT		0
+#define RCC_FINDIV8CFGR_FINDIV8EN		BIT(6)
+
+/* RCC_FINDIV9CFGR register fields */
+#define RCC_FINDIV9CFGR_FINDIV9_MASK		GENMASK(5, 0)
+#define RCC_FINDIV9CFGR_FINDIV9_SHIFT		0
+#define RCC_FINDIV9CFGR_FINDIV9EN		BIT(6)
+
+/* RCC_FINDIV10CFGR register fields */
+#define RCC_FINDIV10CFGR_FINDIV10_MASK		GENMASK(5, 0)
+#define RCC_FINDIV10CFGR_FINDIV10_SHIFT		0
+#define RCC_FINDIV10CFGR_FINDIV10EN		BIT(6)
+
+/* RCC_FINDIV11CFGR register fields */
+#define RCC_FINDIV11CFGR_FINDIV11_MASK		GENMASK(5, 0)
+#define RCC_FINDIV11CFGR_FINDIV11_SHIFT		0
+#define RCC_FINDIV11CFGR_FINDIV11EN		BIT(6)
+
+/* RCC_FINDIV12CFGR register fields */
+#define RCC_FINDIV12CFGR_FINDIV12_MASK		GENMASK(5, 0)
+#define RCC_FINDIV12CFGR_FINDIV12_SHIFT		0
+#define RCC_FINDIV12CFGR_FINDIV12EN		BIT(6)
+
+/* RCC_FINDIV13CFGR register fields */
+#define RCC_FINDIV13CFGR_FINDIV13_MASK		GENMASK(5, 0)
+#define RCC_FINDIV13CFGR_FINDIV13_SHIFT		0
+#define RCC_FINDIV13CFGR_FINDIV13EN		BIT(6)
+
+/* RCC_FINDIV14CFGR register fields */
+#define RCC_FINDIV14CFGR_FINDIV14_MASK		GENMASK(5, 0)
+#define RCC_FINDIV14CFGR_FINDIV14_SHIFT		0
+#define RCC_FINDIV14CFGR_FINDIV14EN		BIT(6)
+
+/* RCC_FINDIV15CFGR register fields */
+#define RCC_FINDIV15CFGR_FINDIV15_MASK		GENMASK(5, 0)
+#define RCC_FINDIV15CFGR_FINDIV15_SHIFT		0
+#define RCC_FINDIV15CFGR_FINDIV15EN		BIT(6)
+
+/* RCC_FINDIV16CFGR register fields */
+#define RCC_FINDIV16CFGR_FINDIV16_MASK		GENMASK(5, 0)
+#define RCC_FINDIV16CFGR_FINDIV16_SHIFT		0
+#define RCC_FINDIV16CFGR_FINDIV16EN		BIT(6)
+
+/* RCC_FINDIV17CFGR register fields */
+#define RCC_FINDIV17CFGR_FINDIV17_MASK		GENMASK(5, 0)
+#define RCC_FINDIV17CFGR_FINDIV17_SHIFT		0
+#define RCC_FINDIV17CFGR_FINDIV17EN		BIT(6)
+
+/* RCC_FINDIV18CFGR register fields */
+#define RCC_FINDIV18CFGR_FINDIV18_MASK		GENMASK(5, 0)
+#define RCC_FINDIV18CFGR_FINDIV18_SHIFT		0
+#define RCC_FINDIV18CFGR_FINDIV18EN		BIT(6)
+
+/* RCC_FINDIV19CFGR register fields */
+#define RCC_FINDIV19CFGR_FINDIV19_MASK		GENMASK(5, 0)
+#define RCC_FINDIV19CFGR_FINDIV19_SHIFT		0
+#define RCC_FINDIV19CFGR_FINDIV19EN		BIT(6)
+
+/* RCC_FINDIV20CFGR register fields */
+#define RCC_FINDIV20CFGR_FINDIV20_MASK		GENMASK(5, 0)
+#define RCC_FINDIV20CFGR_FINDIV20_SHIFT		0
+#define RCC_FINDIV20CFGR_FINDIV20EN		BIT(6)
+
+/* RCC_FINDIV21CFGR register fields */
+#define RCC_FINDIV21CFGR_FINDIV21_MASK		GENMASK(5, 0)
+#define RCC_FINDIV21CFGR_FINDIV21_SHIFT		0
+#define RCC_FINDIV21CFGR_FINDIV21EN		BIT(6)
+
+/* RCC_FINDIV22CFGR register fields */
+#define RCC_FINDIV22CFGR_FINDIV22_MASK		GENMASK(5, 0)
+#define RCC_FINDIV22CFGR_FINDIV22_SHIFT		0
+#define RCC_FINDIV22CFGR_FINDIV22EN		BIT(6)
+
+/* RCC_FINDIV23CFGR register fields */
+#define RCC_FINDIV23CFGR_FINDIV23_MASK		GENMASK(5, 0)
+#define RCC_FINDIV23CFGR_FINDIV23_SHIFT		0
+#define RCC_FINDIV23CFGR_FINDIV23EN		BIT(6)
+
+/* RCC_FINDIV24CFGR register fields */
+#define RCC_FINDIV24CFGR_FINDIV24_MASK		GENMASK(5, 0)
+#define RCC_FINDIV24CFGR_FINDIV24_SHIFT		0
+#define RCC_FINDIV24CFGR_FINDIV24EN		BIT(6)
+
+/* RCC_FINDIV25CFGR register fields */
+#define RCC_FINDIV25CFGR_FINDIV25_MASK		GENMASK(5, 0)
+#define RCC_FINDIV25CFGR_FINDIV25_SHIFT		0
+#define RCC_FINDIV25CFGR_FINDIV25EN		BIT(6)
+
+/* RCC_FINDIV26CFGR register fields */
+#define RCC_FINDIV26CFGR_FINDIV26_MASK		GENMASK(5, 0)
+#define RCC_FINDIV26CFGR_FINDIV26_SHIFT		0
+#define RCC_FINDIV26CFGR_FINDIV26EN		BIT(6)
+
+/* RCC_FINDIV27CFGR register fields */
+#define RCC_FINDIV27CFGR_FINDIV27_MASK		GENMASK(5, 0)
+#define RCC_FINDIV27CFGR_FINDIV27_SHIFT		0
+#define RCC_FINDIV27CFGR_FINDIV27EN		BIT(6)
+
+/* RCC_FINDIV28CFGR register fields */
+#define RCC_FINDIV28CFGR_FINDIV28_MASK		GENMASK(5, 0)
+#define RCC_FINDIV28CFGR_FINDIV28_SHIFT		0
+#define RCC_FINDIV28CFGR_FINDIV28EN		BIT(6)
+
+/* RCC_FINDIV29CFGR register fields */
+#define RCC_FINDIV29CFGR_FINDIV29_MASK		GENMASK(5, 0)
+#define RCC_FINDIV29CFGR_FINDIV29_SHIFT		0
+#define RCC_FINDIV29CFGR_FINDIV29EN		BIT(6)
+
+/* RCC_FINDIV30CFGR register fields */
+#define RCC_FINDIV30CFGR_FINDIV30_MASK		GENMASK(5, 0)
+#define RCC_FINDIV30CFGR_FINDIV30_SHIFT		0
+#define RCC_FINDIV30CFGR_FINDIV30EN		BIT(6)
+
+/* RCC_FINDIV31CFGR register fields */
+#define RCC_FINDIV31CFGR_FINDIV31_MASK		GENMASK(5, 0)
+#define RCC_FINDIV31CFGR_FINDIV31_SHIFT		0
+#define RCC_FINDIV31CFGR_FINDIV31EN		BIT(6)
+
+/* RCC_FINDIV32CFGR register fields */
+#define RCC_FINDIV32CFGR_FINDIV32_MASK		GENMASK(5, 0)
+#define RCC_FINDIV32CFGR_FINDIV32_SHIFT		0
+#define RCC_FINDIV32CFGR_FINDIV32EN		BIT(6)
+
+/* RCC_FINDIV33CFGR register fields */
+#define RCC_FINDIV33CFGR_FINDIV33_MASK		GENMASK(5, 0)
+#define RCC_FINDIV33CFGR_FINDIV33_SHIFT		0
+#define RCC_FINDIV33CFGR_FINDIV33EN		BIT(6)
+
+/* RCC_FINDIV34CFGR register fields */
+#define RCC_FINDIV34CFGR_FINDIV34_MASK		GENMASK(5, 0)
+#define RCC_FINDIV34CFGR_FINDIV34_SHIFT		0
+#define RCC_FINDIV34CFGR_FINDIV34EN		BIT(6)
+
+/* RCC_FINDIV35CFGR register fields */
+#define RCC_FINDIV35CFGR_FINDIV35_MASK		GENMASK(5, 0)
+#define RCC_FINDIV35CFGR_FINDIV35_SHIFT		0
+#define RCC_FINDIV35CFGR_FINDIV35EN		BIT(6)
+
+/* RCC_FINDIV36CFGR register fields */
+#define RCC_FINDIV36CFGR_FINDIV36_MASK		GENMASK(5, 0)
+#define RCC_FINDIV36CFGR_FINDIV36_SHIFT		0
+#define RCC_FINDIV36CFGR_FINDIV36EN		BIT(6)
+
+/* RCC_FINDIV37CFGR register fields */
+#define RCC_FINDIV37CFGR_FINDIV37_MASK		GENMASK(5, 0)
+#define RCC_FINDIV37CFGR_FINDIV37_SHIFT		0
+#define RCC_FINDIV37CFGR_FINDIV37EN		BIT(6)
+
+/* RCC_FINDIV38CFGR register fields */
+#define RCC_FINDIV38CFGR_FINDIV38_MASK		GENMASK(5, 0)
+#define RCC_FINDIV38CFGR_FINDIV38_SHIFT		0
+#define RCC_FINDIV38CFGR_FINDIV38EN		BIT(6)
+
+/* RCC_FINDIV39CFGR register fields */
+#define RCC_FINDIV39CFGR_FINDIV39_MASK		GENMASK(5, 0)
+#define RCC_FINDIV39CFGR_FINDIV39_SHIFT		0
+#define RCC_FINDIV39CFGR_FINDIV39EN		BIT(6)
+
+/* RCC_FINDIV40CFGR register fields */
+#define RCC_FINDIV40CFGR_FINDIV40_MASK		GENMASK(5, 0)
+#define RCC_FINDIV40CFGR_FINDIV40_SHIFT		0
+#define RCC_FINDIV40CFGR_FINDIV40EN		BIT(6)
+
+/* RCC_FINDIV41CFGR register fields */
+#define RCC_FINDIV41CFGR_FINDIV41_MASK		GENMASK(5, 0)
+#define RCC_FINDIV41CFGR_FINDIV41_SHIFT		0
+#define RCC_FINDIV41CFGR_FINDIV41EN		BIT(6)
+
+/* RCC_FINDIV42CFGR register fields */
+#define RCC_FINDIV42CFGR_FINDIV42_MASK		GENMASK(5, 0)
+#define RCC_FINDIV42CFGR_FINDIV42_SHIFT		0
+#define RCC_FINDIV42CFGR_FINDIV42EN		BIT(6)
+
+/* RCC_FINDIV43CFGR register fields */
+#define RCC_FINDIV43CFGR_FINDIV43_MASK		GENMASK(5, 0)
+#define RCC_FINDIV43CFGR_FINDIV43_SHIFT		0
+#define RCC_FINDIV43CFGR_FINDIV43EN		BIT(6)
+
+/* RCC_FINDIV44CFGR register fields */
+#define RCC_FINDIV44CFGR_FINDIV44_MASK		GENMASK(5, 0)
+#define RCC_FINDIV44CFGR_FINDIV44_SHIFT		0
+#define RCC_FINDIV44CFGR_FINDIV44EN		BIT(6)
+
+/* RCC_FINDIV45CFGR register fields */
+#define RCC_FINDIV45CFGR_FINDIV45_MASK		GENMASK(5, 0)
+#define RCC_FINDIV45CFGR_FINDIV45_SHIFT		0
+#define RCC_FINDIV45CFGR_FINDIV45EN		BIT(6)
+
+/* RCC_FINDIV46CFGR register fields */
+#define RCC_FINDIV46CFGR_FINDIV46_MASK		GENMASK(5, 0)
+#define RCC_FINDIV46CFGR_FINDIV46_SHIFT		0
+#define RCC_FINDIV46CFGR_FINDIV46EN		BIT(6)
+
+/* RCC_FINDIV47CFGR register fields */
+#define RCC_FINDIV47CFGR_FINDIV47_MASK		GENMASK(5, 0)
+#define RCC_FINDIV47CFGR_FINDIV47_SHIFT		0
+#define RCC_FINDIV47CFGR_FINDIV47EN		BIT(6)
+
+/* RCC_FINDIV48CFGR register fields */
+#define RCC_FINDIV48CFGR_FINDIV48_MASK		GENMASK(5, 0)
+#define RCC_FINDIV48CFGR_FINDIV48_SHIFT		0
+#define RCC_FINDIV48CFGR_FINDIV48EN		BIT(6)
+
+/* RCC_FINDIV49CFGR register fields */
+#define RCC_FINDIV49CFGR_FINDIV49_MASK		GENMASK(5, 0)
+#define RCC_FINDIV49CFGR_FINDIV49_SHIFT		0
+#define RCC_FINDIV49CFGR_FINDIV49EN		BIT(6)
+
+/* RCC_FINDIV50CFGR register fields */
+#define RCC_FINDIV50CFGR_FINDIV50_MASK		GENMASK(5, 0)
+#define RCC_FINDIV50CFGR_FINDIV50_SHIFT		0
+#define RCC_FINDIV50CFGR_FINDIV50EN		BIT(6)
+
+/* RCC_FINDIV51CFGR register fields */
+#define RCC_FINDIV51CFGR_FINDIV51_MASK		GENMASK(5, 0)
+#define RCC_FINDIV51CFGR_FINDIV51_SHIFT		0
+#define RCC_FINDIV51CFGR_FINDIV51EN		BIT(6)
+
+/* RCC_FINDIV52CFGR register fields */
+#define RCC_FINDIV52CFGR_FINDIV52_MASK		GENMASK(5, 0)
+#define RCC_FINDIV52CFGR_FINDIV52_SHIFT		0
+#define RCC_FINDIV52CFGR_FINDIV52EN		BIT(6)
+
+/* RCC_FINDIV53CFGR register fields */
+#define RCC_FINDIV53CFGR_FINDIV53_MASK		GENMASK(5, 0)
+#define RCC_FINDIV53CFGR_FINDIV53_SHIFT		0
+#define RCC_FINDIV53CFGR_FINDIV53EN		BIT(6)
+
+/* RCC_FINDIV54CFGR register fields */
+#define RCC_FINDIV54CFGR_FINDIV54_MASK		GENMASK(5, 0)
+#define RCC_FINDIV54CFGR_FINDIV54_SHIFT		0
+#define RCC_FINDIV54CFGR_FINDIV54EN		BIT(6)
+
+/* RCC_FINDIV55CFGR register fields */
+#define RCC_FINDIV55CFGR_FINDIV55_MASK		GENMASK(5, 0)
+#define RCC_FINDIV55CFGR_FINDIV55_SHIFT		0
+#define RCC_FINDIV55CFGR_FINDIV55EN		BIT(6)
+
+/* RCC_FINDIV56CFGR register fields */
+#define RCC_FINDIV56CFGR_FINDIV56_MASK		GENMASK(5, 0)
+#define RCC_FINDIV56CFGR_FINDIV56_SHIFT		0
+#define RCC_FINDIV56CFGR_FINDIV56EN		BIT(6)
+
+/* RCC_FINDIV57CFGR register fields */
+#define RCC_FINDIV57CFGR_FINDIV57_MASK		GENMASK(5, 0)
+#define RCC_FINDIV57CFGR_FINDIV57_SHIFT		0
+#define RCC_FINDIV57CFGR_FINDIV57EN		BIT(6)
+
+/* RCC_FINDIV58CFGR register fields */
+#define RCC_FINDIV58CFGR_FINDIV58_MASK		GENMASK(5, 0)
+#define RCC_FINDIV58CFGR_FINDIV58_SHIFT		0
+#define RCC_FINDIV58CFGR_FINDIV58EN		BIT(6)
+
+/* RCC_FINDIV59CFGR register fields */
+#define RCC_FINDIV59CFGR_FINDIV59_MASK		GENMASK(5, 0)
+#define RCC_FINDIV59CFGR_FINDIV59_SHIFT		0
+#define RCC_FINDIV59CFGR_FINDIV59EN		BIT(6)
+
+/* RCC_FINDIV60CFGR register fields */
+#define RCC_FINDIV60CFGR_FINDIV60_MASK		GENMASK(5, 0)
+#define RCC_FINDIV60CFGR_FINDIV60_SHIFT		0
+#define RCC_FINDIV60CFGR_FINDIV60EN		BIT(6)
+
+/* RCC_FINDIV61CFGR register fields */
+#define RCC_FINDIV61CFGR_FINDIV61_MASK		GENMASK(5, 0)
+#define RCC_FINDIV61CFGR_FINDIV61_SHIFT		0
+#define RCC_FINDIV61CFGR_FINDIV61EN		BIT(6)
+
+/* RCC_FINDIV62CFGR register fields */
+#define RCC_FINDIV62CFGR_FINDIV62_MASK		GENMASK(5, 0)
+#define RCC_FINDIV62CFGR_FINDIV62_SHIFT		0
+#define RCC_FINDIV62CFGR_FINDIV62EN		BIT(6)
+
+/* RCC_FINDIV63CFGR register fields */
+#define RCC_FINDIV63CFGR_FINDIV63_MASK		GENMASK(5, 0)
+#define RCC_FINDIV63CFGR_FINDIV63_SHIFT		0
+#define RCC_FINDIV63CFGR_FINDIV63EN		BIT(6)
+
+/* RCC_FINDIVxCFGR register fields */
+#define RCC_FINDIVxCFGR_FINDIVx_MASK		GENMASK(5, 0)
+#define RCC_FINDIVxCFGR_FINDIVx_SHIFT		0
+#define RCC_FINDIVxCFGR_FINDIVxEN		BIT(6)
+
+/* RCC_FCALCOBS0CFGR register fields */
+#define RCC_FCALCOBS0CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS0CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS0CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS0CFGR_FCALCCKEXTSEL		BIT(15)
+#define RCC_FCALCOBS0CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS0CFGR_FCALCCKINV		BIT(17)
+#define RCC_FCALCOBS0CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS0CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS0CFGR_FCALCCKEN		BIT(25)
+#define RCC_FCALCOBS0CFGR_CKOBSEN		BIT(26)
+
+/* RCC_FCALCOBS1CFGR register fields */
+#define RCC_FCALCOBS1CFGR_CKINTSEL_MASK		GENMASK(7, 0)
+#define RCC_FCALCOBS1CFGR_CKINTSEL_SHIFT	0
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_MASK		GENMASK(10, 8)
+#define RCC_FCALCOBS1CFGR_CKEXTSEL_SHIFT	8
+#define RCC_FCALCOBS1CFGR_CKOBSEXTSEL		BIT(16)
+#define RCC_FCALCOBS1CFGR_CKOBSINV		BIT(18)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_MASK		GENMASK(24, 22)
+#define RCC_FCALCOBS1CFGR_CKOBSDIV_SHIFT	22
+#define RCC_FCALCOBS1CFGR_CKOBSEN		BIT(26)
+#define RCC_FCALCOBS1CFGR_FCALCRSTN		BIT(27)
+
+/* RCC_FCALCREFCFGR register fields */
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_MASK	GENMASK(2, 0)
+#define RCC_FCALCREFCFGR_FCALCREFCKSEL_SHIFT	0
+
+/* RCC_FCALCCR1 register fields */
+#define RCC_FCALCCR1_FCALCRUN			BIT(0)
+
+/* RCC_FCALCCR2 register fields */
+#define RCC_FCALCCR2_FCALCMD_MASK		GENMASK(4, 3)
+#define RCC_FCALCCR2_FCALCMD_SHIFT		3
+#define RCC_FCALCCR2_FCALCTWC_MASK		GENMASK(14, 11)
+#define RCC_FCALCCR2_FCALCTWC_SHIFT		11
+#define RCC_FCALCCR2_FCALCTYP_MASK		GENMASK(21, 17)
+#define RCC_FCALCCR2_FCALCTYP_SHIFT		17
+
+/* RCC_FCALCSR register fields */
+#define RCC_FCALCSR_FVAL_MASK			GENMASK(16, 0)
+#define RCC_FCALCSR_FVAL_SHIFT			0
+#define RCC_FCALCSR_FCALCSTS			BIT(19)
+
+/* RCC_PLL4CFGR1 register fields */
+#define RCC_PLL4CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL4CFGR1_PLLEN			BIT(8)
+#define RCC_PLL4CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL4CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL4CFGR2 register fields */
+#define RCC_PLL4CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL4CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL4CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL4CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL4CFGR3 register fields */
+#define RCC_PLL4CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL4CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL4CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL4CFGR3_DACEN			BIT(25)
+#define RCC_PLL4CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL4CFGR4 register fields */
+#define RCC_PLL4CFGR4_DSMEN			BIT(8)
+#define RCC_PLL4CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL4CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL4CFGR5 register fields */
+#define RCC_PLL4CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL4CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL4CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL4CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL4CFGR6 register fields */
+#define RCC_PLL4CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL4CFGR7 register fields */
+#define RCC_PLL4CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL4CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL5CFGR1 register fields */
+#define RCC_PLL5CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL5CFGR1_PLLEN			BIT(8)
+#define RCC_PLL5CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL5CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL5CFGR2 register fields */
+#define RCC_PLL5CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL5CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL5CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL5CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL5CFGR3 register fields */
+#define RCC_PLL5CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL5CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL5CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL5CFGR3_DACEN			BIT(25)
+#define RCC_PLL5CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL5CFGR4 register fields */
+#define RCC_PLL5CFGR4_DSMEN			BIT(8)
+#define RCC_PLL5CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL5CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL5CFGR5 register fields */
+#define RCC_PLL5CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL5CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL5CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL5CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL5CFGR6 register fields */
+#define RCC_PLL5CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL5CFGR7 register fields */
+#define RCC_PLL5CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL5CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL6CFGR1 register fields */
+#define RCC_PLL6CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL6CFGR1_PLLEN			BIT(8)
+#define RCC_PLL6CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL6CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL6CFGR2 register fields */
+#define RCC_PLL6CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL6CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL6CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL6CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL6CFGR3 register fields */
+#define RCC_PLL6CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL6CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL6CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL6CFGR3_DACEN			BIT(25)
+#define RCC_PLL6CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL6CFGR4 register fields */
+#define RCC_PLL6CFGR4_DSMEN			BIT(8)
+#define RCC_PLL6CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL6CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL6CFGR5 register fields */
+#define RCC_PLL6CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL6CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL6CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL6CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL6CFGR6 register fields */
+#define RCC_PLL6CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL6CFGR7 register fields */
+#define RCC_PLL6CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL6CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL7CFGR1 register fields */
+#define RCC_PLL7CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL7CFGR1_PLLEN			BIT(8)
+#define RCC_PLL7CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL7CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL7CFGR2 register fields */
+#define RCC_PLL7CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL7CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL7CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL7CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL7CFGR3 register fields */
+#define RCC_PLL7CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL7CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL7CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL7CFGR3_DACEN			BIT(25)
+#define RCC_PLL7CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL7CFGR4 register fields */
+#define RCC_PLL7CFGR4_DSMEN			BIT(8)
+#define RCC_PLL7CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL7CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL7CFGR5 register fields */
+#define RCC_PLL7CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL7CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL7CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL7CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL7CFGR6 register fields */
+#define RCC_PLL7CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL7CFGR7 register fields */
+#define RCC_PLL7CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL7CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLL8CFGR1 register fields */
+#define RCC_PLL8CFGR1_SSMODRST			BIT(0)
+#define RCC_PLL8CFGR1_PLLEN			BIT(8)
+#define RCC_PLL8CFGR1_PLLRDY			BIT(24)
+#define RCC_PLL8CFGR1_CKREFST			BIT(28)
+
+/* RCC_PLL8CFGR2 register fields */
+#define RCC_PLL8CFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLL8CFGR2_FREFDIV_SHIFT		0
+#define RCC_PLL8CFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLL8CFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLL8CFGR3 register fields */
+#define RCC_PLL8CFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLL8CFGR3_FRACIN_SHIFT		0
+#define RCC_PLL8CFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLL8CFGR3_DACEN			BIT(25)
+#define RCC_PLL8CFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLL8CFGR4 register fields */
+#define RCC_PLL8CFGR4_DSMEN			BIT(8)
+#define RCC_PLL8CFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLL8CFGR4_BYPASS			BIT(10)
+
+/* RCC_PLL8CFGR5 register fields */
+#define RCC_PLL8CFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLL8CFGR5_DIVVAL_SHIFT		0
+#define RCC_PLL8CFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLL8CFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLL8CFGR6 register fields */
+#define RCC_PLL8CFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLL8CFGR7 register fields */
+#define RCC_PLL8CFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLL8CFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_PLLxCFGR1 register fields */
+#define RCC_PLLxCFGR1_SSMODRST			BIT(0)
+#define RCC_PLLxCFGR1_PLLEN			BIT(8)
+#define RCC_PLLxCFGR1_PLLRDY			BIT(24)
+#define RCC_PLLxCFGR1_CKREFST			BIT(28)
+
+/* RCC_PLLxCFGR2 register fields */
+#define RCC_PLLxCFGR2_FREFDIV_MASK		GENMASK(5, 0)
+#define RCC_PLLxCFGR2_FREFDIV_SHIFT		0
+#define RCC_PLLxCFGR2_FBDIV_MASK		GENMASK(27, 16)
+#define RCC_PLLxCFGR2_FBDIV_SHIFT		16
+
+/* RCC_PLLxCFGR3 register fields */
+#define RCC_PLLxCFGR3_FRACIN_MASK		GENMASK(23, 0)
+#define RCC_PLLxCFGR3_FRACIN_SHIFT		0
+#define RCC_PLLxCFGR3_DOWNSPREAD		BIT(24)
+#define RCC_PLLxCFGR3_DACEN			BIT(25)
+#define RCC_PLLxCFGR3_SSCGDIS			BIT(26)
+
+/* RCC_PLLxCFGR4 register fields */
+#define RCC_PLLxCFGR4_DSMEN			BIT(8)
+#define RCC_PLLxCFGR4_FOUTPOSTDIVEN		BIT(9)
+#define RCC_PLLxCFGR4_BYPASS			BIT(10)
+
+/* RCC_PLLxCFGR5 register fields */
+#define RCC_PLLxCFGR5_DIVVAL_MASK		GENMASK(3, 0)
+#define RCC_PLLxCFGR5_DIVVAL_SHIFT		0
+#define RCC_PLLxCFGR5_SPREAD_MASK		GENMASK(20, 16)
+#define RCC_PLLxCFGR5_SPREAD_SHIFT		16
+
+/* RCC_PLLxCFGR6 register fields */
+#define RCC_PLLxCFGR6_POSTDIV1_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR6_POSTDIV1_SHIFT		0
+
+/* RCC_PLLxCFGR7 register fields */
+#define RCC_PLLxCFGR7_POSTDIV2_MASK		GENMASK(2, 0)
+#define RCC_PLLxCFGR7_POSTDIV2_SHIFT		0
+
+/* RCC_VERR register fields */
+#define RCC_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RCC_VERR_MINREV_SHIFT			0
+#define RCC_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RCC_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP2_RCC_H */
diff --git a/include/drivers/st/stm32mp2_risaf.h b/include/drivers/st/stm32mp2_risaf.h
new file mode 100644
index 0000000000..ee8d88f88b
--- /dev/null
+++ b/include/drivers/st/stm32mp2_risaf.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_RISAF_H
+#define STM32MP2_RISAF_H
+
+int stm32mp2_risaf_write_master_key(int instance, uint8_t *mkey);
+int stm32mp2_risaf_lock(int instance);
+int stm32mp2_risaf_is_locked(int instance, bool *state);
+int stm32mp2_risaf_init(void);
+
+#endif /* STM32MP2_RISAF_H */
diff --git a/include/drivers/st/stm32mp_clkfunc.h b/include/drivers/st/stm32mp_clkfunc.h
index 61286b2244..9d10429db1 100644
--- a/include/drivers/st/stm32mp_clkfunc.h
+++ b/include/drivers/st/stm32mp_clkfunc.h
@@ -29,8 +29,6 @@ int fdt_get_clock_id(int node);
 unsigned long fdt_get_uart_clock_freq(uintptr_t instance);
 
 void stm32mp_stgen_config(unsigned long rate);
-void stm32mp_stgen_restore_counter(unsigned long long value,
-				   unsigned long long offset_in_ms);
-unsigned long long stm32mp_stgen_get_counter(void);
+void stm32mp_stgen_restore_rate(void);
 
 #endif /* STM32MP_CLKFUNC_H */
diff --git a/include/drivers/st/stm32mp_ddr.h b/include/drivers/st/stm32mp_ddr.h
index 1efca42a15..2baa63d981 100644
--- a/include/drivers/st/stm32mp_ddr.h
+++ b/include/drivers/st/stm32mp_ddr.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2024, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -26,9 +26,11 @@ enum stm32mp_ddr_reg_type {
 };
 
 struct stm32mp_ddr_reg_desc {
-	const char *name;
 	uint16_t offset;	/* Offset for base address */
 	uint8_t par_offset;	/* Offset for parameter array */
+#if STM32MP25
+	bool qd; /* quasi-dynamic register if true */
+#endif
 };
 
 struct stm32mp_ddr_reg_info {
@@ -53,17 +55,30 @@ struct stm32mp_ddr_priv {
 
 struct stm32mp_ddr_info {
 	const char *name;
-	uint32_t speed; /* in kHZ */
-	uint32_t size;  /* Memory size in byte = col * row * width */
+	uint32_t speed; /* in KHz */
+	size_t size;    /* Memory size in byte = col * row * width */
 };
 
-#define TIMEOUT_US_1S	1000000U
+#define DDR_DELAY_1US		1U
+#define DDR_DELAY_2US		2U
+#define DDR_DELAY_10US		10U
+#define DDR_DELAY_50US		50U
+#define DDR_TIMEOUT_500US	500U
+#define DDR_TIMEOUT_US_1S	1000000U
 
 void stm32mp_ddr_set_reg(const struct stm32mp_ddr_priv *priv, enum stm32mp_ddr_reg_type type,
 			 const void *param, const struct stm32mp_ddr_reg_info *ddr_registers);
 void stm32mp_ddr_start_sw_done(struct stm32mp_ddrctl *ctl);
 void stm32mp_ddr_wait_sw_done_ack(struct stm32mp_ddrctl *ctl);
 void stm32mp_ddr_enable_axi_port(struct stm32mp_ddrctl *ctl);
+int stm32mp_ddr_disable_axi_port(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_enable_host_interface(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_disable_host_interface(struct stm32mp_ddrctl *ctl);
+int stm32mp_ddr_sw_selfref_entry(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_sw_selfref_exit(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_set_qd3_update_conditions(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_unset_qd3_update_conditions(struct stm32mp_ddrctl *ctl);
+void stm32mp_ddr_wait_refresh_update_done_ack(struct stm32mp_ddrctl *ctl);
 int stm32mp_board_ddr_power_init(enum ddr_type ddr_type);
 
 #endif /* STM32MP_DDR_H */
diff --git a/include/drivers/st/stm32mp_ddr_test.h b/include/drivers/st/stm32mp_ddr_test.h
index 34e522ae33..cef5b486c3 100644
--- a/include/drivers/st/stm32mp_ddr_test.h
+++ b/include/drivers/st/stm32mp_ddr_test.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,9 +9,9 @@
 
 #include <stdint.h>
 
-uint32_t stm32mp_ddr_test_rw_access(void);
-uint32_t stm32mp_ddr_test_data_bus(void);
-uint32_t stm32mp_ddr_test_addr_bus(uint64_t size);
-uint32_t stm32mp_ddr_check_size(void);
+uintptr_t stm32mp_ddr_test_rw_access(void);
+uintptr_t stm32mp_ddr_test_data_bus(void);
+uintptr_t stm32mp_ddr_test_addr_bus(size_t size);
+size_t stm32mp_ddr_check_size(void);
 
 #endif /* STM32MP_DDR_TEST_H */
diff --git a/include/drivers/st/stm32mp_ddrctrl_regs.h b/include/drivers/st/stm32mp_ddrctrl_regs.h
index 79de86b2a8..f9f46aa428 100644
--- a/include/drivers/st/stm32mp_ddrctrl_regs.h
+++ b/include/drivers/st/stm32mp_ddrctrl_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2022-2024, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
  */
@@ -51,7 +51,8 @@ struct stm32mp_ddrctl {
 	uint32_t init7;		/* 0xec SDRAM Initialization 7 */
 	uint32_t dimmctl;	/* 0xf0 DIMM Control */
 	uint32_t rankctl;	/* 0xf4 Rank Control */
-	uint8_t reserved0f4[0x100 - 0xf8];
+	uint32_t rankctl1;	/* 0xf8 Rank Control 1 */
+	uint8_t reserved0fc[0x100 - 0xfc];
 	uint32_t dramtmg0;	/* 0x100 SDRAM Timing 0 */
 	uint32_t dramtmg1;	/* 0x104 SDRAM Timing 1 */
 	uint32_t dramtmg2;	/* 0x108 SDRAM Timing 2 */
@@ -112,7 +113,9 @@ struct stm32mp_ddrctl {
 	uint32_t perflpr1;	/* 0x264 Low Priority Read CAM 1 */
 	uint32_t reserved268;
 	uint32_t perfwr1;	/* 0x26c Write CAM 1 */
-	uint8_t reserved27c[0x300 - 0x270];
+	uint32_t sched3;	/* 0x270 Scheduler Control 3 */
+	uint32_t sched4;	/* 0x274 Scheduler Control 4 */
+	uint8_t reserved278[0x300 - 0x278];
 	uint32_t dbg0;		/* 0x300 Debug 0 */
 	uint32_t dbg1;		/* 0x304 Debug 1 */
 	uint32_t dbgcam;	/* 0x308 CAM Debug */
@@ -121,7 +124,8 @@ struct stm32mp_ddrctl {
 	uint8_t reserved314[0x320 - 0x314];
 	uint32_t swctl;		/* 0x320 Software Programming Control Enable */
 	uint32_t swstat;	/* 0x324 Software Programming Control Status */
-	uint8_t reserved328[0x36c - 0x328];
+	uint32_t swctlstatic;	/* 0x328 Statics Write Enable */
+	uint8_t reserved32c[0x36c - 0x32c];
 	uint32_t poisoncfg;	/* 0x36c AXI Poison Configuration Register */
 	uint32_t poisonstat;	/* 0x370 AXI Poison Status Register */
 	uint8_t reserved374[0x3f0 - 0x374];
@@ -153,7 +157,7 @@ struct stm32mp_ddrctl {
 	uint32_t pcfgqos1_1;	/* 0x548 Read QoS Configuration 1 */
 	uint32_t pcfgwqos0_1;	/* 0x54c Write QoS Configuration 0 */
 	uint32_t pcfgwqos1_1;	/* 0x550 Write QoS Configuration 1 */
-#endif
+#endif /* STM32MP_DDR_DUAL_AXI_PORT */
 
 	uint8_t reserved554[0xff0 - 0x554];
 	uint32_t umctl2_ver_number;	/* 0xff0 UMCTL2 Version Number */
@@ -170,6 +174,7 @@ struct stm32mp_ddrctl {
 #define DDRCTRL_RFSHCTL3			0x060
 #define DDRCTRL_RFSHTMG				0x064
 #define DDRCTRL_INIT0				0x0D0
+#define DDRCTRL_DFILPCFG0			0x198
 #define DDRCTRL_DFIMISC				0x1B0
 #define DDRCTRL_DBG1				0x304
 #define DDRCTRL_DBGCAM				0x308
@@ -181,7 +186,7 @@ struct stm32mp_ddrctl {
 #define DDRCTRL_PCTRL_0				0x490
 #if STM32MP_DDR_DUAL_AXI_PORT
 #define DDRCTRL_PCTRL_1				0x540
-#endif
+#endif /* STM32MP_DDR_DUAL_AXI_PORT */
 
 /* DDR Controller Register fields */
 #define DDRCTRL_MSTR_DDR3			BIT(0)
@@ -201,6 +206,8 @@ struct stm32mp_ddrctl {
 #define DDRCTRL_STAT_SELFREF_TYPE_MASK		GENMASK(5, 4)
 #define DDRCTRL_STAT_SELFREF_TYPE_ASR		(BIT(4) | BIT(5))
 #define DDRCTRL_STAT_SELFREF_TYPE_SR		BIT(5)
+#define DDRCTRL_STAT_SELFREF_STATE_MASK		GENMASK(9, 8)
+#define DDRCTRL_STAT_SELFREF_STATE_SRPD		BIT(9)
 
 #define DDRCTRL_MRCTRL0_MR_TYPE_WRITE		U(0)
 /* Only one rank supported */
@@ -217,6 +224,7 @@ struct stm32mp_ddrctl {
 #define DDRCTRL_PWRCTL_POWERDOWN_EN		BIT(1)
 #define DDRCTRL_PWRCTL_EN_DFI_DRAM_CLK_DISABLE	BIT(3)
 #define DDRCTRL_PWRCTL_SELFREF_SW		BIT(5)
+#define DDRCTRL_PWRCTL_STAY_IN_SELFREF		BIT(6)
 
 #define DDRCTRL_PWRTMG_SELFREF_TO_X32_MASK	GENMASK(23, 16)
 #define DDRCTRL_PWRTMG_SELFREF_TO_X32_0		BIT(16)
@@ -225,6 +233,9 @@ struct stm32mp_ddrctl {
 #define DDRCTRL_RFSHCTL3_REFRESH_UPDATE_LEVEL	BIT(1)
 
 #define DDRCTRL_HWLPCTL_HW_LP_EN		BIT(0)
+#define DDRCTRL_HWLPCTL_HW_LP_EXIT_IDLE_EN	BIT(1)
+#define DDRCTRL_HWLPCTL_HW_LP_IDLE_X32_MASK	GENMASK(27, 16)
+#define DDRCTRL_HWLPCTL_HW_LP_IDLE_X32_SHIFT	16
 
 #define DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_MASK	GENMASK(27, 16)
 #define DDRCTRL_RFSHTMG_T_RFC_NOM_X1_X32_SHIFT	16
@@ -232,21 +243,31 @@ struct stm32mp_ddrctl {
 #define DDRCTRL_INIT0_SKIP_DRAM_INIT_MASK	GENMASK(31, 30)
 #define DDRCTRL_INIT0_SKIP_DRAM_INIT_NORMAL	BIT(30)
 
+#define DDRCTRL_DFILPCFG0_DFI_LP_EN_SR		BIT(8)
+
 #define DDRCTRL_DFIMISC_DFI_INIT_COMPLETE_EN	BIT(0)
 #define DDRCTRL_DFIMISC_DFI_INIT_START		BIT(5)
+#define DDRCTRL_DFIMISC_DFI_FREQUENCY		GENMASK(12, 8)
 
 #define DDRCTRL_DFISTAT_DFI_INIT_COMPLETE	BIT(0)
+#define DDRCTRL_DFISTAT_DFI_LP_ACK		BIT(1)
 
+#define DDRCTRL_DBG1_DIS_DQ			BIT(0)
 #define DDRCTRL_DBG1_DIS_HIF			BIT(1)
 
 #define DDRCTRL_DBGCAM_WR_DATA_PIPELINE_EMPTY	BIT(29)
 #define DDRCTRL_DBGCAM_RD_DATA_PIPELINE_EMPTY	BIT(28)
 #define DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY		BIT(26)
+#define DDRCTRL_DBGCAM_DBG_RD_Q_EMPTY		BIT(25)
 #define DDRCTRL_DBGCAM_DBG_LPR_Q_DEPTH		GENMASK(12, 8)
 #define DDRCTRL_DBGCAM_DBG_HPR_Q_DEPTH		GENMASK(4, 0)
 #define DDRCTRL_DBGCAM_DATA_PIPELINE_EMPTY \
 		(DDRCTRL_DBGCAM_WR_DATA_PIPELINE_EMPTY | \
 		 DDRCTRL_DBGCAM_RD_DATA_PIPELINE_EMPTY)
+#define DDRCTRL_DBG_Q_AND_DATA_PIPELINE_EMPTY \
+		(DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY | \
+		 DDRCTRL_DBGCAM_DBG_RD_Q_EMPTY | \
+		 DDRCTRL_DBGCAM_DATA_PIPELINE_EMPTY)
 #define DDRCTRL_DBGCAM_DBG_Q_DEPTH \
 		(DDRCTRL_DBGCAM_DBG_WR_Q_EMPTY | \
 		 DDRCTRL_DBGCAM_DBG_LPR_Q_DEPTH | \
diff --git a/include/drivers/st/stm32mp_pmic.h b/include/drivers/st/stm32mp_pmic.h
index 303c571483..640f0a23a8 100644
--- a/include/drivers/st/stm32mp_pmic.h
+++ b/include/drivers/st/stm32mp_pmic.h
@@ -42,17 +42,17 @@ static inline void print_pmic_info_and_debug(void)
 #endif
 
 /*
- * pmic_ddr_power_init - Initialize regulators required for DDR
+ * pmic_voltages_init - Update voltages for platform init
  *
  * Returns 0 on success, and negative values on errors
  */
-int pmic_ddr_power_init(enum ddr_type ddr_type);
+int pmic_voltages_init(void);
 
 /*
- * pmic_voltages_init - Update voltages for platform init
+ * pmic_switch_off - switch off the platform with PMIC
  *
- * Returns 0 on success, and negative values on errors
+ * Panics on errors
  */
-int pmic_voltages_init(void);
+void pmic_switch_off(void);
 
 #endif /* STM32MP_PMIC_H */
diff --git a/include/drivers/st/stm32mp_pmic2.h b/include/drivers/st/stm32mp_pmic2.h
new file mode 100644
index 0000000000..4ea4a1e198
--- /dev/null
+++ b/include/drivers/st/stm32mp_pmic2.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_PMIC2_H
+#define STM32MP_PMIC2_H
+
+#include <stdbool.h>
+#include <drivers/st/regulator.h>
+
+#include <platform_def.h>
+
+/*
+ * dt_pmic_status - Check PMIC status from device tree
+ *
+ * Returns the status of the PMIC (secure, non-secure), or a negative value on
+ * error
+ */
+int dt_pmic_status(void);
+
+/*
+ * initialize_pmic_i2c - Initialize I2C for the PMIC control
+ *
+ * Returns true if PMIC is available, false if not found, panics on errors
+ */
+bool initialize_pmic_i2c(void);
+
+/*
+ * initialize_pmic - Main PMIC initialization function, called at platform init
+ *
+ * Panics on errors
+ */
+void initialize_pmic(void);
+
+/*
+ * stpmic2_set_prop - Set PMIC2 proprietary property
+ *
+ * Returns non zero on errors
+ */
+int stpmic2_set_prop(const struct regul_description *desc, uint16_t prop, uint32_t value);
+
+/*
+ * pmic_switch_off - switch off the platform with PMIC
+ *
+ * Panics on errors
+ */
+void pmic_switch_off(void);
+
+#endif /* STM32MP_PMIC2_H */
diff --git a/include/drivers/st/stm32mp_reset.h b/include/drivers/st/stm32mp_reset.h
index 84448050d7..40ecdd59ab 100644
--- a/include/drivers/st/stm32mp_reset.h
+++ b/include/drivers/st/stm32mp_reset.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2018-2020, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -47,4 +47,9 @@ static inline void stm32mp_reset_release(uint32_t reset_id)
 	(void)stm32mp_reset_deassert(reset_id, 0U);
 }
 
+/*
+ * Manage system reset control
+ */
+void __dead2 stm32mp_system_reset(void);
+
 #endif /* STM32MP_RESET_H */
diff --git a/include/drivers/st/stm32mp_rifsc_regs.h b/include/drivers/st/stm32mp_rifsc_regs.h
new file mode 100644
index 0000000000..d8abfd1af3
--- /dev/null
+++ b/include/drivers/st/stm32mp_rifsc_regs.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_RIFSC_REGS_H
+#define STM32MP_RIFSC_REGS_H
+
+/* RIFSC offset register */
+#define _RIFSC_RISC_CR			U(0x0)
+#define _RIFSC_RISC_SECCFGR(id)		(U(0x10) + U(0x4) * ((id) / 32))
+#define _RIFSC_RISC_PRIVCFGR(id)	(U(0x30) + U(0x4) * ((id) / 32))
+#define _RIFSC_RISC_RCFGLOCKR(id)	(U(0x50) + U(0x4) * ((id) / 32))
+#define _RIFSC_RISC_PERy_CIDCFGR(id)	(U(0x100) + U(0x8) * (id))
+#define _RIFSC_RISC_PERy_SEMCR(id)	(U(0x104) + U(0x8) * (id))
+#define _RIFSC_RIMC_CR			U(0xC00)
+#define _RIFSC_RIMC_SR			U(0xC04)
+#define _RIFSC_RIMC_ATTR(x)		(U(0xC10) + U(0x4) * (x))
+#define _RIFSC_PPSR(x)			(U(0xFB0) + U(0x4) * (x))
+#define _RIFSC_HWCFGR3			U(0xFE8)
+#define _RIFSC_HWCFGR2			U(0xFEC)
+#define _RIFSC_HWCFGR1			U(0xFF0)
+#define _RIFSC_VERR			U(0xFF4)
+#define _RFISC_IPIDR			U(0xFF8)
+#define _RFISC_SIDR			U(0xFFC)
+
+/* RIFSC_RIMC_ATTRx register fields */
+#define RIFSC_RIMC_ATTRx_CIDSEL			BIT(2)
+#define RIFSC_RIMC_ATTRx_MCID_MASK		GENMASK(6, 4)
+#define RIFSC_RIMC_ATTRx_MCID_SHIFT		4
+#define RIFSC_RIMC_ATTRx_MSEC			BIT(8)
+#define RIFSC_RIMC_ATTRx_MPRIV			BIT(9)
+
+#endif /* STM32MP_RIFSC_REGS_H */
diff --git a/include/drivers/st/stm32mp_risab_regs.h b/include/drivers/st/stm32mp_risab_regs.h
new file mode 100644
index 0000000000..c765c04e09
--- /dev/null
+++ b/include/drivers/st/stm32mp_risab_regs.h
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_RISAB_REGS_H
+#define STM32MP_RISAB_REGS_H
+
+#define RISAB_CR				U(0x00)
+#define RISAB_IASR				U(0x08)
+#define RISAB_IACR				U(0x0C)
+#define RISAB_RIFLOCKR				U(0x10)
+#define RISAB_IAESR				U(0x20)
+#define RISAB_IADDR				U(0x24)
+#define RISAB_PG0_SECCFGR			U(0x100)
+#define RISAB_PG1_SECCFGR			U(0x104)
+#define RISAB_PG2_SECCFGR			U(0x108)
+#define RISAB_PG3_SECCFGR			U(0x10C)
+#define RISAB_PG4_SECCFGR			U(0x110)
+#define RISAB_PG5_SECCFGR			U(0x114)
+#define RISAB_PG6_SECCFGR			U(0x118)
+#define RISAB_PG7_SECCFGR			U(0x11C)
+#define RISAB_PG8_SECCFGR			U(0x120)
+#define RISAB_PG9_SECCFGR			U(0x124)
+#define RISAB_PG10_SECCFGR			U(0x128)
+#define RISAB_PG11_SECCFGR			U(0x12C)
+#define RISAB_PG12_SECCFGR			U(0x130)
+#define RISAB_PG13_SECCFGR			U(0x134)
+#define RISAB_PG14_SECCFGR			U(0x138)
+#define RISAB_PG15_SECCFGR			U(0x13C)
+#define RISAB_PG16_SECCFGR			U(0x140)
+#define RISAB_PG17_SECCFGR			U(0x144)
+#define RISAB_PG18_SECCFGR			U(0x148)
+#define RISAB_PG19_SECCFGR			U(0x14C)
+#define RISAB_PG20_SECCFGR			U(0x150)
+#define RISAB_PG21_SECCFGR			U(0x154)
+#define RISAB_PG22_SECCFGR			U(0x158)
+#define RISAB_PG23_SECCFGR			U(0x15C)
+#define RISAB_PG24_SECCFGR			U(0x160)
+#define RISAB_PG25_SECCFGR			U(0x164)
+#define RISAB_PG26_SECCFGR			U(0x168)
+#define RISAB_PG27_SECCFGR			U(0x16C)
+#define RISAB_PG28_SECCFGR			U(0x170)
+#define RISAB_PG29_SECCFGR			U(0x174)
+#define RISAB_PG30_SECCFGR			U(0x178)
+#define RISAB_PG31_SECCFGR			U(0x17C)
+#define RISAB_PG0_PRIVCFGR			U(0x200)
+#define RISAB_PG1_PRIVCFGR			U(0x204)
+#define RISAB_PG2_PRIVCFGR			U(0x208)
+#define RISAB_PG3_PRIVCFGR			U(0x20C)
+#define RISAB_PG4_PRIVCFGR			U(0x210)
+#define RISAB_PG5_PRIVCFGR			U(0x214)
+#define RISAB_PG6_PRIVCFGR			U(0x218)
+#define RISAB_PG7_PRIVCFGR			U(0x21C)
+#define RISAB_PG8_PRIVCFGR			U(0x220)
+#define RISAB_PG9_PRIVCFGR			U(0x224)
+#define RISAB_PG10_PRIVCFGR			U(0x228)
+#define RISAB_PG11_PRIVCFGR			U(0x22C)
+#define RISAB_PG12_PRIVCFGR			U(0x230)
+#define RISAB_PG13_PRIVCFGR			U(0x234)
+#define RISAB_PG14_PRIVCFGR			U(0x238)
+#define RISAB_PG15_PRIVCFGR			U(0x23C)
+#define RISAB_PG16_PRIVCFGR			U(0x240)
+#define RISAB_PG17_PRIVCFGR			U(0x244)
+#define RISAB_PG18_PRIVCFGR			U(0x248)
+#define RISAB_PG19_PRIVCFGR			U(0x24C)
+#define RISAB_PG20_PRIVCFGR			U(0x250)
+#define RISAB_PG21_PRIVCFGR			U(0x254)
+#define RISAB_PG22_PRIVCFGR			U(0x258)
+#define RISAB_PG23_PRIVCFGR			U(0x25C)
+#define RISAB_PG24_PRIVCFGR			U(0x260)
+#define RISAB_PG25_PRIVCFGR			U(0x264)
+#define RISAB_PG26_PRIVCFGR			U(0x268)
+#define RISAB_PG27_PRIVCFGR			U(0x26C)
+#define RISAB_PG28_PRIVCFGR			U(0x270)
+#define RISAB_PG29_PRIVCFGR			U(0x274)
+#define RISAB_PG30_PRIVCFGR			U(0x278)
+#define RISAB_PG31_PRIVCFGR			U(0x27C)
+#define RISAB_PG0_C2PRIVCFGR			U(0x600)
+#define RISAB_PG1_C2PRIVCFGR			U(0x604)
+#define RISAB_PG2_C2PRIVCFGR			U(0x608)
+#define RISAB_PG3_C2PRIVCFGR			U(0x60C)
+#define RISAB_PG4_C2PRIVCFGR			U(0x610)
+#define RISAB_PG5_C2PRIVCFGR			U(0x614)
+#define RISAB_PG6_C2PRIVCFGR			U(0x618)
+#define RISAB_PG7_C2PRIVCFGR			U(0x61C)
+#define RISAB_PG8_C2PRIVCFGR			U(0x620)
+#define RISAB_PG9_C2PRIVCFGR			U(0x624)
+#define RISAB_PG10_C2PRIVCFGR			U(0x628)
+#define RISAB_PG11_C2PRIVCFGR			U(0x62C)
+#define RISAB_PG12_C2PRIVCFGR			U(0x630)
+#define RISAB_PG13_C2PRIVCFGR			U(0x634)
+#define RISAB_PG14_C2PRIVCFGR			U(0x638)
+#define RISAB_PG15_C2PRIVCFGR			U(0x63C)
+#define RISAB_PG16_C2PRIVCFGR			U(0x640)
+#define RISAB_PG17_C2PRIVCFGR			U(0x644)
+#define RISAB_PG18_C2PRIVCFGR			U(0x648)
+#define RISAB_PG19_C2PRIVCFGR			U(0x64C)
+#define RISAB_PG20_C2PRIVCFGR			U(0x650)
+#define RISAB_PG21_C2PRIVCFGR			U(0x654)
+#define RISAB_PG22_C2PRIVCFGR			U(0x658)
+#define RISAB_PG23_C2PRIVCFGR			U(0x65C)
+#define RISAB_PG24_C2PRIVCFGR			U(0x660)
+#define RISAB_PG25_C2PRIVCFGR			U(0x664)
+#define RISAB_PG26_C2PRIVCFGR			U(0x668)
+#define RISAB_PG27_C2PRIVCFGR			U(0x66C)
+#define RISAB_PG28_C2PRIVCFGR			U(0x670)
+#define RISAB_PG29_C2PRIVCFGR			U(0x674)
+#define RISAB_PG30_C2PRIVCFGR			U(0x678)
+#define RISAB_PG31_C2PRIVCFGR			U(0x67C)
+#define RISAB_CID0PRIVCFGR			U(0x800)
+#define RISAB_CID0RDCFGR			U(0x808)
+#define RISAB_CID0WRCFGR			U(0x810)
+#define RISAB_CID1PRIVCFGR			U(0x820)
+#define RISAB_CID1RDCFGR			U(0x828)
+#define RISAB_CID1WRCFGR			U(0x830)
+#define RISAB_CID2PRIVCFGR			U(0x840)
+#define RISAB_CID2RDCFGR			U(0x848)
+#define RISAB_CID2WRCFGR			U(0x850)
+#define RISAB_CID3PRIVCFGR			U(0x860)
+#define RISAB_CID3RDCFGR			U(0x868)
+#define RISAB_CID3WRCFGR			U(0x870)
+#define RISAB_CID4PRIVCFGR			U(0x880)
+#define RISAB_CID4RDCFGR			U(0x888)
+#define RISAB_CID4WRCFGR			U(0x890)
+#define RISAB_CID5PRIVCFGR			U(0x8A0)
+#define RISAB_CID5RDCFGR			U(0x8A8)
+#define RISAB_CID5WRCFGR			U(0x8B0)
+#define RISAB_CID6PRIVCFGR			U(0x8C0)
+#define RISAB_CID6RDCFGR			U(0x8C8)
+#define RISAB_CID6WRCFGR			U(0x8D0)
+#define RISAB_PG0_CIDCFGR			U(0xA00)
+#define RISAB_PG1_CIDCFGR			U(0xA04)
+#define RISAB_PG2_CIDCFGR			U(0xA08)
+#define RISAB_PG3_CIDCFGR			U(0xA0C)
+#define RISAB_PG4_CIDCFGR			U(0xA10)
+#define RISAB_PG5_CIDCFGR			U(0xA14)
+#define RISAB_PG6_CIDCFGR			U(0xA18)
+#define RISAB_PG7_CIDCFGR			U(0xA1C)
+#define RISAB_PG8_CIDCFGR			U(0xA20)
+#define RISAB_PG9_CIDCFGR			U(0xA24)
+#define RISAB_PG10_CIDCFGR			U(0xA28)
+#define RISAB_PG11_CIDCFGR			U(0xA2C)
+#define RISAB_PG12_CIDCFGR			U(0xA30)
+#define RISAB_PG13_CIDCFGR			U(0xA34)
+#define RISAB_PG14_CIDCFGR			U(0xA38)
+#define RISAB_PG15_CIDCFGR			U(0xA3C)
+#define RISAB_PG16_CIDCFGR			U(0xA40)
+#define RISAB_PG17_CIDCFGR			U(0xA44)
+#define RISAB_PG18_CIDCFGR			U(0xA48)
+#define RISAB_PG19_CIDCFGR			U(0xA4C)
+#define RISAB_PG20_CIDCFGR			U(0xA50)
+#define RISAB_PG21_CIDCFGR			U(0xA54)
+#define RISAB_PG22_CIDCFGR			U(0xA58)
+#define RISAB_PG23_CIDCFGR			U(0xA5C)
+#define RISAB_PG24_CIDCFGR			U(0xA60)
+#define RISAB_PG25_CIDCFGR			U(0xA64)
+#define RISAB_PG26_CIDCFGR			U(0xA68)
+#define RISAB_PG27_CIDCFGR			U(0xA6C)
+#define RISAB_PG28_CIDCFGR			U(0xA70)
+#define RISAB_PG29_CIDCFGR			U(0xA74)
+#define RISAB_PG30_CIDCFGR			U(0xA78)
+#define RISAB_PG31_CIDCFGR			U(0xA7C)
+#define RISAB_HWCFGR3				U(0xFE8)
+#define RISAB_HWCFGR2				U(0xFEC)
+#define RISAB_HWCFGR1				U(0xFF0)
+#define RISAB_VERR				U(0xFF4)
+#define RISAB_IPIDR				U(0xFF8)
+#define RISAB_SIDR				U(0xFFC)
+
+/* RISAB_CR register fields */
+#define RISAB_CR_GLOCK				BIT(0)
+#define RISAB_CR_SRWIAD				BIT(31)
+
+/* RISAB_IASR register fields */
+#define RISAB_IASR_CAEF				BIT(0)
+#define RISAB_IASR_IAEF				BIT(1)
+
+/* RISAB_IACR register fields */
+#define RISAB_IACR_CAEF				BIT(0)
+#define RISAB_IACR_IAEF				BIT(1)
+
+/* RISAB_RIFLOCKR register fields */
+#define RISAB_RIFLOCKR_RLOCK0			BIT(0)
+#define RISAB_RIFLOCKR_RLOCK1			BIT(1)
+#define RISAB_RIFLOCKR_RLOCK2			BIT(2)
+#define RISAB_RIFLOCKR_RLOCK3			BIT(3)
+#define RISAB_RIFLOCKR_RLOCK4			BIT(4)
+#define RISAB_RIFLOCKR_RLOCK5			BIT(5)
+#define RISAB_RIFLOCKR_RLOCK6			BIT(6)
+#define RISAB_RIFLOCKR_RLOCK7			BIT(7)
+#define RISAB_RIFLOCKR_RLOCK8			BIT(8)
+#define RISAB_RIFLOCKR_RLOCK9			BIT(9)
+#define RISAB_RIFLOCKR_RLOCK10			BIT(10)
+#define RISAB_RIFLOCKR_RLOCK11			BIT(11)
+#define RISAB_RIFLOCKR_RLOCK12			BIT(12)
+#define RISAB_RIFLOCKR_RLOCK13			BIT(13)
+#define RISAB_RIFLOCKR_RLOCK14			BIT(14)
+#define RISAB_RIFLOCKR_RLOCK15			BIT(15)
+#define RISAB_RIFLOCKR_RLOCK16			BIT(16)
+#define RISAB_RIFLOCKR_RLOCK17			BIT(17)
+#define RISAB_RIFLOCKR_RLOCK18			BIT(18)
+#define RISAB_RIFLOCKR_RLOCK19			BIT(19)
+#define RISAB_RIFLOCKR_RLOCK20			BIT(20)
+#define RISAB_RIFLOCKR_RLOCK21			BIT(21)
+#define RISAB_RIFLOCKR_RLOCK22			BIT(22)
+#define RISAB_RIFLOCKR_RLOCK23			BIT(23)
+#define RISAB_RIFLOCKR_RLOCK24			BIT(24)
+#define RISAB_RIFLOCKR_RLOCK25			BIT(25)
+#define RISAB_RIFLOCKR_RLOCK26			BIT(26)
+#define RISAB_RIFLOCKR_RLOCK27			BIT(27)
+#define RISAB_RIFLOCKR_RLOCK28			BIT(28)
+#define RISAB_RIFLOCKR_RLOCK29			BIT(29)
+#define RISAB_RIFLOCKR_RLOCK30			BIT(30)
+#define RISAB_RIFLOCKR_RLOCK31			BIT(31)
+
+/* RISAB_IAESR register fields */
+#define RISAB_IAESR_IACID_MASK			GENMASK(2, 0)
+#define RISAB_IAESR_IACID_SHIFT			0
+#define RISAB_IAESR_IAPRIV			BIT(4)
+#define RISAB_IAESR_IASEC			BIT(5)
+#define RISAB_IAESR_IANRW			BIT(7)
+
+/* RISAB_PGx_SECCFGR register fields */
+#define RISAB_PGx_SECCFGR_SEC(_y)		BIT(_y)
+
+/* RISAB_PGx_PRIVCFGR register fields */
+#define RISAB_PGx_PRIVCFGR_PRIV(_y)		BIT(_y)
+
+/* RISAB_PGx_CmPRIVCFGR register fields */
+#define RISAB_PGx_CmPRIVCFGR_PRIV(_y)		BIT(_y)
+
+/* RISAB_CIDxPRIVCFGR register fields */
+#define RISAB_CIDxPRIVCFGR_PPRIV(_y)		BIT(_y)
+
+/* RISAB_CIDxRDCFGR register fields */
+#define RISAB_CIDxRDCFGR_PRDEN(_y)		BIT(_y)
+
+/* RISAB_CIDxWRCFGR register fields */
+#define RISAB_CIDxWRCFGR_PWREN(_y)		BIT(_y)
+
+/* RISAB_PGx_CIDCFGR register fields */
+#define RISAB_PGx_CIDCFGR_CFEN			BIT(0)
+#define RISAB_PGx_CIDCFGR_DCEN			BIT(2)
+#define RISAB_PGx_CIDCFGR_DCCID_MASK		GENMASK(6, 4)
+#define RISAB_PGx_CIDCFGR_DCCID_SHIFT		4
+
+/* RISAB_HWCFGR1 register fields */
+#define RISAB_HWCFGR1_CFG1_MASK			GENMASK(3, 0)
+#define RISAB_HWCFGR1_CFG1_SHIFT		0
+#define RISAB_HWCFGR1_CFG2_MASK			GENMASK(7, 4)
+#define RISAB_HWCFGR1_CFG2_SHIFT		4
+#define RISAB_HWCFGR1_CFG3_MASK			GENMASK(11, 8)
+#define RISAB_HWCFGR1_CFG3_SHIFT		8
+#define RISAB_HWCFGR1_CFG4_MASK			GENMASK(15, 12)
+#define RISAB_HWCFGR1_CFG4_SHIFT		12
+#define RISAB_HWCFGR1_CFG5_MASK			GENMASK(19, 16)
+#define RISAB_HWCFGR1_CFG5_SHIFT		16
+#define RISAB_HWCFGR1_CFG6_MASK			GENMASK(23, 20)
+#define RISAB_HWCFGR1_CFG6_SHIFT		20
+#define RISAB_HWCFGR1_CFG7_MASK			GENMASK(27, 24)
+#define RISAB_HWCFGR1_CFG7_SHIFT		24
+
+/* RISAB_VERR register fields */
+#define RISAB_VERR_MINREV_MASK			GENMASK(3, 0)
+#define RISAB_VERR_MINREV_SHIFT			0
+#define RISAB_VERR_MAJREV_MASK			GENMASK(7, 4)
+#define RISAB_VERR_MAJREV_SHIFT			4
+
+#endif /* STM32MP_RISAB_REGS_H */
diff --git a/include/drivers/st/stm32mp_tamp_nvram.h b/include/drivers/st/stm32mp_tamp_nvram.h
new file mode 100644
index 0000000000..8c3d8ec165
--- /dev/null
+++ b/include/drivers/st/stm32mp_tamp_nvram.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_TAMP_NVRAM_H
+#define STM32MP_TAMP_NVRAM_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <drivers/st/nvmem.h>
+#include <dt-bindings/soc/rif.h>
+#include <lib/utils_def.h>
+
+#define TAMP_SECCFGR U(0x20)
+#define TAMP_BKPRIFR(x) (U(0x70) + (U(0x4) * (U(x) - U(1))))
+#define TAMP_RXCIDCFGR(x) (U(0x80) + (U(0x4) * (U(x))))
+#define CURRENT_CID U(RIF_CID1)
+
+#define REG_FIELD(_offset, _l, _h)                                 \
+	{                                                       \
+		.reg_offset = (_offset),				\
+		.lowest_bit = (_l),				\
+		.highest_bit = (_h)				\
+	}
+
+struct stm32_tamp_nvram_reg_field {
+	size_t reg_offset;
+	uint32_t lowest_bit;
+	uint32_t highest_bit;
+};
+
+enum stm32_tamp_bkpreg_access {
+	RONS,
+	RNSWNS,
+	RNSWS,
+	RSWS,
+	NORNOW,
+};
+
+struct stm32_tamp_nvram_drv_data {
+	uintptr_t base;
+	uintptr_t parent_base;
+	size_t size;
+	size_t parent_size;
+	const void *tamp_fdt;
+	int node;
+	size_t nb_total_regs;
+	int *bkpreg_zones_end;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+	const struct stm32_tamp_nvram_cdata *cdata;
+	bool *compartment_owner;
+};
+
+struct stm32_tamp_nvram_cdata {
+	const unsigned int nb_zones;
+	const struct stm32_tamp_nvram_reg_field *zone_cfg;
+};
+
+//Implemented for MP1 and MP2
+
+enum stm32_tamp_bkpreg_access *
+stm32_tamp_nvram_get_access_rights(struct stm32_tamp_nvram_drv_data *drv_data);
+
+const struct stm32_tamp_nvram_cdata *stm32_tamp_nvram_get_cdata(void);
+
+
+//Shared in core
+int stm32_tamp_nvram_reg_field_write(uintptr_t base,
+				     struct stm32_tamp_nvram_reg_field field,
+				     uint32_t val);
+
+int stm32_tamp_nvram_reg_field_read(uintptr_t base,
+				    struct stm32_tamp_nvram_reg_field field,
+				    uint32_t *val);
+
+int stm32_tamp_nvram_reg_get_zone(struct stm32_tamp_nvram_drv_data *drv_data,
+				  int reg);
+
+#endif /* STM32MP_TAMP_NVRAM_H */
diff --git a/include/drivers/st/stpmic2.h b/include/drivers/st/stpmic2.h
new file mode 100644
index 0000000000..bd04c4ec20
--- /dev/null
+++ b/include/drivers/st/stpmic2.h
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STPMIC2_H
+#define STPMIC2_H
+
+#include <drivers/st/stm32_i2c.h>
+#include <lib/utils_def.h>
+
+enum {
+	STPMIC2_BUCK1 = 0,
+	STPMIC2_BUCK2,
+	STPMIC2_BUCK3,
+	STPMIC2_BUCK4,
+	STPMIC2_BUCK5,
+	STPMIC2_BUCK6,
+	STPMIC2_BUCK7,
+	STPMIC2_REFDDR,
+	STPMIC2_LDO1,
+	STPMIC2_LDO2,
+	STPMIC2_LDO3,
+	STPMIC2_LDO4,
+	STPMIC2_LDO5,
+	STPMIC2_LDO6,
+	STPMIC2_LDO7,
+	STPMIC2_LDO8,
+	STPMIC2_NB_REG
+};
+
+/* Status Registers */
+#define PRODUCT_ID		0x00
+#define VERSION_SR		0x01
+#define TURN_ON_SR		0x02
+#define TURN_OFF_SR		0x03
+#define RESTART_SR		0x04
+#define OCP_SR1			0x05
+#define OCP_SR2			0x06
+#define EN_SR1			0x07
+#define EN_SR2			0x08
+#define FS_CNT_SR1		0x09
+#define FS_CNT_SR2		0x0A
+#define FS_CNT_SR3		0x0B
+#define MODE_SR			0x0C
+/* Control Registers */
+#define MAIN_CR			0x10
+#define VINLOW_CR		0x11
+#define PKEY_LKP_CR		0x12
+#define WDG_CR			0x13
+#define WDG_TMR_CR		0x14
+#define WDG_TMR_SR		0x15
+#define FS_OCP_CR1		0x16
+#define FS_OCP_CR2		0x17
+#define PADS_PULL_CR		0x18
+#define BUCKS_PD_CR1		0x19
+#define BUCKS_PD_CR2		0x1A
+#define LDOS_PD_CR1		0x1B
+#define LDOS_PD_CR2		0x1C
+#define BUCKS_MRST_CR		0x1D
+#define LDOS_MRST_CR		0x1E
+/* Buck CR */
+#define BUCK1_MAIN_CR1		0x20
+#define BUCK1_MAIN_CR2		0x21
+#define BUCK1_ALT_CR1		0x22
+#define BUCK1_ALT_CR2		0x23
+#define BUCK1_PWRCTRL_CR	0x24
+#define BUCK2_MAIN_CR1		0x25
+#define BUCK2_MAIN_CR2		0x26
+#define BUCK2_ALT_CR1		0x27
+#define BUCK2_ALT_CR2		0x28
+#define BUCK2_PWRCTRL_CR	0x29
+#define BUCK3_MAIN_CR1		0x2A
+#define BUCK3_MAIN_CR2		0x2B
+#define BUCK3_ALT_CR1		0x2C
+#define BUCK3_ALT_CR2		0x2D
+#define BUCK3_PWRCTRL_CR	0x2E
+#define BUCK4_MAIN_CR1		0x2F
+#define BUCK4_MAIN_CR2		0x30
+#define BUCK4_ALT_CR1		0x31
+#define BUCK4_ALT_CR2		0x32
+#define BUCK4_PWRCTRL_CR	0x33
+#define BUCK5_MAIN_CR1		0x34
+#define BUCK5_MAIN_CR2		0x35
+#define BUCK5_ALT_CR1		0x36
+#define BUCK5_ALT_CR2		0x37
+#define BUCK5_PWRCTRL_CR	0x38
+#define BUCK6_MAIN_CR1		0x39
+#define BUCK6_MAIN_CR2		0x3A
+#define BUCK6_ALT_CR1		0x3B
+#define BUCK6_ALT_CR2		0x3C
+#define BUCK6_PWRCTRL_CR	0x3D
+#define BUCK7_MAIN_CR1		0x3E
+#define BUCK7_MAIN_CR2		0x3F
+#define BUCK7_ALT_CR1		0x40
+#define BUCK7_ALT_CR2		0x41
+#define BUCK7_PWRCTRL_CR	0x42
+/* LDO CR */
+#define LDO1_MAIN_CR		0x4C
+#define LDO1_ALT_CR		0x4D
+#define LDO1_PWRCTRL_CR		0x4E
+#define LDO2_MAIN_CR		0x4F
+#define LDO2_ALT_CR		0x50
+#define LDO2_PWRCTRL_CR		0x51
+#define LDO3_MAIN_CR		0x52
+#define LDO3_ALT_CR		0x53
+#define LDO3_PWRCTRL_CR		0x54
+#define LDO4_MAIN_CR		0x55
+#define LDO4_ALT_CR		0x56
+#define LDO4_PWRCTRL_CR		0x57
+#define LDO5_MAIN_CR		0x58
+#define LDO5_ALT_CR		0x59
+#define LDO5_PWRCTRL_CR		0x5A
+#define LDO6_MAIN_CR		0x5B
+#define LDO6_ALT_CR		0x5C
+#define LDO6_PWRCTRL_CR		0x5D
+#define LDO7_MAIN_CR		0x5E
+#define LDO7_ALT_CR		0x5F
+#define LDO7_PWRCTRL_CR		0x60
+#define LDO8_MAIN_CR		0x61
+#define LDO8_ALT_CR		0x62
+#define LDO8_PWRCTRL_CR		0x63
+#define REFDDR_MAIN_CR		0x64
+#define REFDDR_ALT_CR		0x65
+#define REFDDR_PWRCTRL_CR	0x66
+/* INTERRUPT CR */
+#define INT_PENDING_R1		0x70
+#define INT_PENDING_R2		0x71
+#define INT_PENDING_R3		0x72
+#define INT_PENDING_R4		0x73
+#define INT_CLEAR_R1		0x74
+#define INT_CLEAR_R2		0x75
+#define INT_CLEAR_R3		0x76
+#define INT_CLEAR_R4		0x77
+#define INT_MASK_R1		0x78
+#define INT_MASK_R2		0x79
+#define INT_MASK_R3		0x7A
+#define INT_MASK_R4		0x7B
+#define INT_SRC_R1		0x7C
+#define INT_SRC_R2		0x7D
+#define INT_SRC_R3		0x7E
+#define INT_SRC_R4		0x7F
+#define INT_DBG_LATCH_R1	0x80
+#define INT_DBG_LATCH_R2	0x81
+#define INT_DBG_LATCH_R3	0x82
+#define INT_DBG_LATCH_R4	0x83
+/* NVM SHADOW REGISTERS */
+#define NVM_LDOS_IOUT_SHR	0xAE
+#define LDO5_ILIM_SHIFT		2
+
+/* BUCKS_MRST_CR bits definition */
+#define BUCK1_MRST		BIT(0)
+#define BUCK2_MRST		BIT(1)
+#define BUCK3_MRST		BIT(2)
+#define BUCK4_MRST		BIT(3)
+#define BUCK5_MRST		BIT(4)
+#define BUCK6_MRST		BIT(5)
+#define BUCK7_MRST		BIT(6)
+#define REFDDR_MRST		BIT(7)
+
+/* LDOS_MRST_CR bits definition */
+#define LDO1_MRST		BIT(0)
+#define LDO2_MRST		BIT(1)
+#define LDO3_MRST		BIT(2)
+#define LDO4_MRST		BIT(3)
+#define LDO5_MRST		BIT(4)
+#define LDO6_MRST		BIT(5)
+#define LDO7_MRST		BIT(6)
+#define LDO8_MRST		BIT(7)
+
+/* LDOx_MAIN_CR */
+#define LDO_VOLT_SHIFT		1
+#define LDO_BYPASS		BIT(6)
+#define LDO1_INPUT_SRC		BIT(7)
+#define LDO3_SNK_SRC		BIT(7)
+#define LDO4_INPUT_SRC_SHIFT	6
+#define LDO4_INPUT_SRC_MASK	GENMASK_32(7, 6)
+
+/* PWRCTRL register bit definition */
+#define PWRCTRL_EN		BIT(0)
+#define PWRCTRL_RS		BIT(1)
+#define PWRCTRL_SEL_SHIFT	2
+#define PWRCTRL_SEL_MASK	GENMASK_32(3, 2)
+
+/* BUCKx_MAIN_CR2 */
+#define PREG_MODE_SHIFT		1
+#define PREG_MODE_MASK		GENMASK_32(2, 1)
+
+/* BUCKS_PD_CR1 */
+#define BUCK1_PD_MASK		GENMASK_32(1, 0)
+#define BUCK2_PD_MASK		GENMASK_32(3, 2)
+#define BUCK3_PD_MASK		GENMASK_32(5, 4)
+#define BUCK4_PD_MASK		GENMASK_32(7, 6)
+
+#define BUCK1_PD_FAST		BIT(1)
+#define BUCK2_PD_FAST		BIT(3)
+#define BUCK3_PD_FAST		BIT(5)
+#define BUCK4_PD_FAST		BIT(7)
+
+/* BUCKS_PD_CR2 */
+#define BUCK5_PD_MASK		GENMASK_32(1, 0)
+#define BUCK6_PD_MASK		GENMASK_32(3, 2)
+#define BUCK7_PD_MASK		GENMASK_32(5, 4)
+
+#define BUCK5_PD_FAST		BIT(1)
+#define BUCK6_PD_FAST		BIT(3)
+#define BUCK7_PD_FAST		BIT(5)
+
+/* LDOS_PD_CR1 */
+#define LDO1_PD			BIT(0)
+#define LDO2_PD			BIT(1)
+#define LDO3_PD			BIT(2)
+#define LDO4_PD			BIT(3)
+#define LDO5_PD			BIT(4)
+#define LDO6_PD			BIT(5)
+#define LDO7_PD			BIT(6)
+#define LDO8_PD			BIT(7)
+
+/* LDOS_PD_CR2 */
+#define REFDDR_PD		BIT(0)
+
+/* FS_OCP_CR1 */
+#define FS_OCP_BUCK1		BIT(0)
+#define FS_OCP_BUCK2		BIT(1)
+#define FS_OCP_BUCK3		BIT(2)
+#define FS_OCP_BUCK4		BIT(3)
+#define FS_OCP_BUCK5		BIT(4)
+#define FS_OCP_BUCK6		BIT(5)
+#define FS_OCP_BUCK7		BIT(6)
+#define FS_OCP_REFDDR		BIT(7)
+
+/* FS_OCP_CR2 */
+#define FS_OCP_LDO1		BIT(0)
+#define FS_OCP_LDO2		BIT(1)
+#define FS_OCP_LDO3		BIT(2)
+#define FS_OCP_LDO4		BIT(3)
+#define FS_OCP_LDO5		BIT(4)
+#define FS_OCP_LDO6		BIT(5)
+#define FS_OCP_LDO7		BIT(6)
+#define FS_OCP_LDO8		BIT(7)
+
+/* IRQ definitions */
+#define IT_PONKEY_F	0
+#define IT_PONKEY_R	1
+#define IT_BUCK1_OCP	16
+#define IT_BUCK2_OCP	17
+#define IT_BUCK3_OCP	18
+#define IT_BUCK4_OCP	19
+#define IT_BUCK5_OCP	20
+#define IT_BUCK6_OCP	21
+#define IT_BUCK7_OCP	22
+#define IT_REFDDR_OCP	23
+#define IT_LDO1_OCP	24
+#define IT_LDO2_OCP	25
+#define IT_LDO3_OCP	26
+#define IT_LDO4_OCP	27
+#define IT_LDO5_OCP	28
+#define IT_LDO6_OCP	29
+#define IT_LDO7_OCP	30
+#define IT_LDO8_OCP	31
+
+enum stpmic2_prop_id {
+	STPMIC2_MASK_RESET = 0,
+	STPMIC2_PULL_DOWN,
+	STPMIC2_BYPASS,		/* arg: 1=set 0=reset */
+	STPMIC2_SINK_SOURCE,
+	STPMIC2_OCP,
+};
+
+struct pmic_handle_s {
+	struct i2c_handle_s *i2c_handle;
+	uint32_t i2c_addr;
+	unsigned int pmic_status;
+};
+
+int stpmic2_register_read(struct pmic_handle_s *pmic,
+			  uint8_t register_id, uint8_t *value);
+int stpmic2_register_write(struct pmic_handle_s *pmic,
+			   uint8_t register_id, uint8_t value);
+int stpmic2_register_update(struct pmic_handle_s *pmic,
+			    uint8_t register_id, uint8_t value, uint8_t mask);
+
+int stpmic2_regulator_set_state(struct pmic_handle_s *pmic,
+				uint8_t id, bool enable);
+int stpmic2_regulator_get_state(struct pmic_handle_s *pmic,
+				uint8_t id, bool *enabled);
+
+int stpmic2_regulator_levels_mv(struct pmic_handle_s *pmic,
+				uint8_t id, const uint16_t **levels,
+				size_t *levels_count);
+int stpmic2_regulator_get_voltage(struct pmic_handle_s *pmic,
+				  uint8_t id, uint16_t *val);
+int stpmic2_regulator_set_voltage(struct pmic_handle_s *pmic,
+				  uint8_t id, uint16_t millivolts);
+
+#if EVENT_LOG_LEVEL == LOG_LEVEL_VERBOSE
+void stpmic2_dump_regulators(struct pmic_handle_s *pmic);
+#endif
+
+int stpmic2_get_version(struct pmic_handle_s *pmic, uint8_t *val);
+int stpmic2_get_product_id(struct pmic_handle_s *pmic, uint8_t *val);
+
+int stpmic2_regulator_get_prop(struct pmic_handle_s *pmic, uint8_t id,
+			       enum stpmic2_prop_id prop);
+
+int stpmic2_regulator_set_prop(struct pmic_handle_s *pmic, uint8_t id,
+			       enum stpmic2_prop_id prop, uint32_t arg);
+
+#endif /*STPMIC2_H*/
diff --git a/include/drivers/st/usb_dwc3.h b/include/drivers/st/usb_dwc3.h
new file mode 100644
index 0000000000..47bdc76592
--- /dev/null
+++ b/include/drivers/st/usb_dwc3.h
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2015-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __USB_DWC3_H
+#define __USB_DWC3_H
+
+#include <drivers/usb_device.h>
+#include <platform_def.h>
+
+/* define value use in register */
+
+#define USB3_HS_MAX_PACKET_SIZE     512U
+#define USB3_FS_MAX_PACKET_SIZE     64U
+#ifdef USE_USB_FS
+#define USB3_MAX_PACKET_SIZE        USB3_FS_MAX_PACKET_SIZE
+#else
+#define USB3_MAX_PACKET_SIZE        USB3_HS_MAX_PACKET_SIZE
+#endif
+#define USB_SETUP_PACKET_SIZE       12U
+
+/* USB_DWC3_EPTypeDef->trb_flag */
+#define USB_DWC3_TRBCTL_NORMAL            1
+#define USB_DWC3_TRBCTL_CONTROL_SETUP     2
+#define USB_DWC3_TRBCTL_CONTROL_STATUS2   3
+#define USB_DWC3_TRBCTL_CONTROL_STATUS3   4
+#define USB_DWC3_TRBCTL_CONTROL_DATA      5
+#define USB_DWC3_TRBCTL_ISOCHRONOUS_FIRST 6
+#define USB_DWC3_TRBCTL_ISOCHRONOUS       7
+#define USB_DWC3_TRBCTL_LINK_TRB          8
+#define USB_DWC3_TRBCTL_MASK              0x3fUL
+
+/* USB_DWC3_EPTypeDef->flags */
+#define USB_DWC3_EP_REQ_QUEUED          BIT(0)
+#define USB_DWC3_EP_ISOC_START_PENDING  BIT(1)
+#define USB_DWC3_EP_ISOC_STARTED        BIT(2)
+
+/*
+ * DWC3 Specific Configurable macros
+ */
+#define USB_DWC3_INT_INUSE          1U
+#define USB_DWC3_EVENT_BUFFER_SIZE  2048U
+#define USB_DWC3_NUM_IN_EP          USBD_EP_NB
+#define USB_DWC3_NUM_OUT_EP         USBD_EP_NB
+
+typedef struct {
+	uint32_t dcfg;             /* @ offset 0x0 */
+	uint32_t dctl;             /* @ offset 0x4 */
+	uint32_t devten;           /* @ offset 0x8 */
+	uint32_t dsts;             /* @ offset 0xc */
+	uint32_t dgcmdpar;         /* @ offset 0x10 */
+	uint32_t dgcmd;            /* @ offset 0x14 */
+	uint32_t reserved_18[2];   /* Reserved @ offset 0x18 */
+	uint32_t dalepena;         /* @ offset 0x20 */
+	uint32_t reserved_24;      /* @ offset 0x24 */
+	uint32_t reserved_28[54];  /* Reserved @ offset 0x28 */
+	uint32_t depcmdpar2;       /* @ offset 0x100 */
+	uint32_t depcmdpar1;       /* @ offset 0x104 */
+	uint32_t depcmdpar0;       /* @ offset 0x108 */
+	uint32_t depcmd;           /* @ offset 0x10c */
+	uint32_t reserved_110[124];/* Reserved @ offset 0x110 */
+	uint32_t dev_imod;         /* @ offset 0x300 */
+	uint32_t reserved_304[0xfc / 4]; /* Reserved @ offset 0x304 */
+} usb_dwc3_device_t;
+
+typedef struct {
+	uint32_t gsbuscfg0;         /* @ offset 0x0 */
+	uint32_t gsbuscfg1;         /* @ offset 0x4 */
+	uint32_t gtxthrcfg;         /* @ offset 0x8 */
+	uint32_t grxthrcfg;         /* @ offset 0xc */
+	uint32_t gctl;              /* @ offset 0x10 */
+	uint32_t gpmsts;            /* @ offset 0x14 */
+	uint32_t gsts;              /* @ offset 0x18 */
+	uint32_t guctl1;            /* @ offset 0x1c */
+	uint32_t gsnpsid;           /* @ offset 0x20 */
+	uint32_t ggpio;             /* @ offset 0x24 */
+	uint32_t guid;              /* @ offset 0x28 */
+	uint32_t guctl;             /* @ offset 0x2c */
+	uint32_t gbuserraddrlo;     /* @ offset 0x30 */
+	uint32_t gbuserraddrhi;     /* @ offset 0x34 */
+	uint32_t gprtbimaplo;       /* @ offset 0x38 */
+	uint32_t gprtbimaphi;       /* @ offset 0x3c */
+	uint32_t ghwparams0;        /* @ offset 0x40 */
+	uint32_t ghwparams1;        /* @ offset 0x44 */
+	uint32_t ghwparams2;        /* @ offset 0x48 */
+	uint32_t ghwparams3;        /* @ offset 0x4c */
+	uint32_t ghwparams4;        /* @ offset 0x50 */
+	uint32_t ghwparams5;        /* @ offset 0x54 */
+	uint32_t ghwparams6;        /* @ offset 0x58 */
+	uint32_t ghwparams7;        /* @ offset 0x5c */
+	uint32_t gdbgfifospace;     /* @ offset 0x60 */
+	uint32_t gdbgltssm;         /* @ offset 0x64 */
+	uint32_t gdbglnmcc;         /* @ offset 0x68 */
+	uint32_t gdbgbmu;           /* @ offset 0x6c */
+	uint32_t gdbglspmux_hst;    /* @ offset 0x70 */
+	uint32_t gdbglsp;           /* @ offset 0x74 */
+	uint32_t gdbgepinfo0;       /* @ offset 0x78 */
+	uint32_t gdbgepinfo1;       /* @ offset 0x7c */
+	uint32_t gprtbimap_hslo;    /* @ offset 0x80 */
+	uint32_t gprtbimap_hshi;    /* @ offset 0x84 */
+	uint32_t gprtbimap_fslo;    /* @ offset 0x88 */
+	uint32_t gprtbimap_fshi;    /* @ offset 0x8c */
+	uint32_t reserved_90;       /* Reserved @ offset 0x90 */
+	uint32_t reserved_94;       /* @ offset 0x94 */
+	uint32_t reserved_98;       /* @ offset 0x98 */
+	uint32_t guctl2;            /* @ offset 0x9c */
+	uint32_t reserved_A0[24];   /* Reserved @ offset 0xa0 */
+	uint32_t gusb2phycfg;       /* @ offset 0x100 */
+	uint32_t reserved_104[15];  /* Reserved @ offset 0x104 */
+	uint32_t gusb2i2cctl;       /* @ offset 0x140 */
+	uint32_t reserved_144[15];  /* Reserved @ offset 0x144 */
+	uint32_t gusb2phyacc_ulpi;  /* @ offset 0x180 */
+	uint32_t reserved_184[15];  /* Reserved @ offset 0x184 */
+	uint32_t gusb3pipectl;      /* @ offset 0x1c0 */
+	uint32_t reserved_1c4[15];  /* Reserved @ offset 0x1c4 */
+	uint32_t gtxfifosiz0;       /* @ offset 0x200 */
+	uint32_t gtxfifosiz1;       /* @ offset 0x204 */
+	uint32_t gtxfifosiz2;       /* @ offset 0x208 */
+	uint32_t gtxfifosiz3;       /* @ offset 0x20c */
+	uint32_t gtxfifosiz4;       /* @ offset 0x210 */
+	uint32_t gtxfifosiz5;       /* @ offset 0x214 */
+	uint32_t gtxfifosiz6;       /* @ offset 0x218 */
+	uint32_t gtxfifosiz7;       /* @ offset 0x21c */
+	uint32_t gtxfifosiz8;       /* @ offset 0x220 */
+	uint32_t gtxfifosiz9;       /* @ offset 0x224 */
+	uint32_t gtxfifosiz10;      /* @ offset 0x228 */
+	uint32_t gtxfifosiz11;      /* @ offset 0x22c */
+	uint32_t reserved_230[20];  /* Reserved @ offset 0x230 */
+	uint32_t grxfifosiz0;       /* @ offset 0x280 */
+	uint32_t grxfifosiz1;       /* @ offset 0x284 */
+	uint32_t grxfifosiz2;       /* @ offset 0x288 */
+	uint32_t reserved_28c[29];  /* Reserved @ offset 0x28c */
+	uint32_t gevntadrlo;        /* @ offset 0x300 */
+	uint32_t gevntadrhi;        /* @ offset 0x304 */
+	uint32_t gevntsiz;          /* @ offset 0x308 */
+	uint32_t gevntcount;        /* @ offset 0x30c */
+	uint32_t reserved_310[124]; /* Reserved @ offset 0x310 */
+	uint32_t ghwparams8;        /* @ offset 0x500 */
+	uint32_t reserved_504[3];   /* Reserved @ offset 0x504 */
+	uint32_t gtxfifopridev;     /* @ offset 0x510 */
+	uint32_t reserved_514;      /* Reserved @ offset 0x514 */
+	uint32_t gtxfifoprihst;     /* @ offset 0x518 */
+	uint32_t grxfifoprihst;     /* @ offset 0x51c */
+	uint32_t reserved_520;      /* Reserved @ offset 0x520 */
+	uint32_t gdmahlratio;       /* @ offset 0x524 */
+	uint32_t reserved_528[2];   /* Reserved @ offset 0x528 */
+	uint32_t gfladj;            /* @ offset 0x530 */
+	uint32_t reserved_534[0xcc / 4];  /* Reserved @ offset 0x534 */
+} usb_dwc3_global_t;
+
+typedef struct {
+	uint32_t bpl;      /* Buffer Pointer Low Address */
+	uint32_t bph;      /* Buffer Pointer High Address */
+	uint32_t size;     /* Buffer Size */
+	uint32_t ctrl;     /* Control and Status field */
+} __packed usb_dwc3_trb_t __aligned(16);
+
+#define CACHED_MEMORY
+#define CACHE_LINE_SIZE CACHE_WRITEBACK_GRANULE
+
+typedef struct {
+	bool is_stall;				/* Endpoint stall condition */
+
+	volatile usb_dwc3_trb_t *trb_addr; /* Trb descriptor coherent address */
+	uintptr_t trb_dma_addr;   /* 32 bits aligned trb bus address */
+	uint8_t trb_flag;         /* TRB Control Flag */
+	uint8_t flags;            /* Endpoint state flags condition */
+	uint8_t phy_epnum;        /* physical EP number 0 - 31 */
+	uint8_t intr_num;         /* Interrupt number to get events for this EP */
+	/* to be used for receiving packet < EP-Max-Packet-Size */
+	uint8_t *bounce_buf;
+	/* Transmission FIFO number. Number between Min_Data = 1 and Max_Data = 15 */
+	uint8_t tx_fifo_num;
+	uint8_t resc_idx;       /* Resource index */
+	uintptr_t dma_addr;     /* 32 bits aligned transfer buffer address */
+	/* Pointer to destination buffer, used for receive case, where bounce_buf is used */
+	uint8_t *xfer_dest_buff;
+	/* length of destination buffer, used for receive case, where bounce_buf is used */
+	uint32_t xfer_dest_len;
+} usb_dwc3_endpoint_t;
+
+typedef struct {
+	uint8_t bounce_buf[USB3_MAX_PACKET_SIZE];  /* Event Buffer area */
+} usb_dwc3_endpoint_bouncebuf_t __aligned(CACHE_LINE_SIZE);
+
+/* Aligned to make EvtBuffer start address evtbuffer-size aligned */
+typedef struct {
+	uint8_t EvtBufferArea[USB_DWC3_EVENT_BUFFER_SIZE];  /* Event Buffer area */
+} PCD_intbufferareadef __aligned(USB_DWC3_EVENT_BUFFER_SIZE);
+
+typedef struct {
+	/* shield needed for the cache line (8 words) intersection with other members of structure,
+	 * only when USB_DWC3_EVENT_BUFFER_SIZE is non-cache_line aligned
+	 */
+
+	uint8_t *evtbuffer_addr[USB_DWC3_INT_INUSE]; /* Event Buffer coherent addr */
+	uintptr_t evtbuffer_dma_addr[USB_DWC3_INT_INUSE]; /* Event Buffer dma addr */
+	uint32_t evtbufferpos[USB_DWC3_INT_INUSE];   /*!< Read Position inside the Event Buffer */
+} PCD_intbuffersdef;
+
+typedef enum {
+	HAL_PCD_STATE_RESET   = 0x00U,
+	HAL_PCD_STATE_READY   = 0x01U,
+	HAL_PCD_STATE_ERROR   = 0x02U,
+	HAL_PCD_STATE_BUSY    = 0x03U,
+	HAL_PCD_STATE_TIMEOUT = 0x04U
+} usb_dwc3_state_t;
+
+typedef enum {
+	HAL_PCD_EP0_SETUP_COMPLETED = 0x00U,
+	HAL_PCD_EP0_SETUP_QUEUED  = 0x01U
+} usb_dwc3_ep0state_t;
+
+typedef struct {
+	/*
+	 * Kept at top to avoid struct size wastage since bounce_buf
+	 * needs to be CACHE_LINE_SIZE aligned
+	 */
+	usb_dwc3_endpoint_bouncebuf_t bounce_bufs[USB_DWC3_NUM_OUT_EP];
+	PCD_intbuffersdef intbuffers;
+	usb_dwc3_global_t *usb_global;
+	usb_dwc3_device_t *usb_device;
+	usb_dwc3_endpoint_t IN_ep[USB_DWC3_NUM_IN_EP];
+	usb_dwc3_endpoint_t OUT_ep[USB_DWC3_NUM_OUT_EP];
+
+	usb_dwc3_state_t State;      /*!< PCD communication state            */
+	usb_dwc3_ep0state_t EP0_State;  /*!< EP0 State */
+
+	uint8_t *setup_addr;  /*!< Setup packet coherent address    */
+	uintptr_t setup_dma_addr;  /*!< Setup packet buffer DMA Bus address */
+
+	struct pcd_handle *pcd_handle;
+} dwc3_handle_t;
+
+void usb_dwc3_init_driver(struct usb_handle *usb_core_handle,
+			  struct pcd_handle *pcd_handle, dwc3_handle_t *dwc3_handle,
+			  void *base_addr);
+
+#endif /* __USB_DWC3_H */
diff --git a/include/drivers/usb_device.h b/include/drivers/usb_device.h
index 8fdb6ae130..2f9403318a 100644
--- a/include/drivers/usb_device.h
+++ b/include/drivers/usb_device.h
@@ -11,6 +11,17 @@
 
 #include <lib/utils_def.h>
 
+/* Define for EP address */
+#define EP_DIR_MASK	BIT(7)
+#define EP_DIR_IN	BIT(7)
+#define EP_NUM_MASK	GENMASK(3, 0)
+
+#define EP0_IN	(0U | EP_DIR_IN)
+#define EP0_OUT	0U
+
+/* USB address between 1 through 127 = 0x7F mask */
+#define ADDRESS_MASK	GENMASK(6, 0)
+
 #define USBD_MAX_NUM_INTERFACES			1U
 #define USBD_MAX_NUM_CONFIGURATION		1U
 
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
index 1d5bb78381..3e09eaf947 100644
--- a/include/dt-bindings/clock/stm32mp13-clks.h
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -193,7 +193,13 @@
 #define SAI1		160
 #define SAI2		161
 
-#define STM32MP1_LAST_CLK 162
+#define SPI1		162
+#define SPI2		163
+#define SPI3		164
+#define SPI4		165
+#define SPI5		166
+
+#define STM32MP1_LAST_CLK 167
 
 /* SCMI clock identifiers */
 #define CK_SCMI0_HSE		0
diff --git a/include/dt-bindings/clock/stm32mp15-clksrc.h b/include/dt-bindings/clock/stm32mp15-clksrc.h
index 3a3792da3f..2f899a1a13 100644
--- a/include/dt-bindings/clock/stm32mp15-clksrc.h
+++ b/include/dt-bindings/clock/stm32mp15-clksrc.h
@@ -6,268 +6,408 @@
 #ifndef _DT_BINDINGS_CLOCK_STM32MP15_CLKSRC_H_
 #define _DT_BINDINGS_CLOCK_STM32MP15_CLKSRC_H_
 
+#include <lib/utils_def.h>
+
+#define CMD_DIV		0
+#define CMD_MUX		1
+#define CMD_CLK		2
+
+#define CMD_ADDR_BIT	BIT(31)
+
+#define CMD_SHIFT	26
+#define CMD_MASK	GENMASK_32(31, 26)
+#define CMD_DATA_MASK	GENMASK_32(25, 0)
+
+#define DIV_ID_SHIFT	8
+#define DIV_ID_MASK	GENMASK_32(15, 8)
+
+#define DIV_DIVN_SHIFT	0
+#define DIV_DIVN_MASK	GENMASK_32(7, 0)
+
+#define MUX_ID_SHIFT	4
+#define MUX_ID_MASK	GENMASK_32(11, 4)
+
+#define MUX_SEL_SHIFT	0
+#define MUX_SEL_MASK	GENMASK_32(3, 0)
+
+#define CLK_ID_MASK	GENMASK_32(19, 11)
+#define CLK_ID_SHIFT	11
+#define CLK_ON_MASK	0x00000400
+#define CLK_ON_SHIFT	10
+#define CLK_DIV_MASK	GENMASK_32(9, 4)
+#define CLK_DIV_SHIFT	4
+#define CLK_SEL_MASK	GENMASK_32(3, 0)
+#define CLK_SEL_SHIFT	0
+
+#define DIV(div_id, div)	((CMD_DIV << CMD_SHIFT) |\
+				 ((div_id) << DIV_ID_SHIFT) |\
+				 (div))
+
+#define CLKSRC(mux_id, sel)	((CMD_MUX << CMD_SHIFT) |\
+				 ((mux_id) << MUX_ID_SHIFT) |\
+				 (sel))
+
+/* CLK output is enable */
+#define CLK_SRC(clk_id, sel)	((CMD_CLK << CMD_SHIFT) |\
+				 ((clk_id) << CLK_ID_SHIFT) |\
+				 (sel) | CLK_ON_MASK)
+
+#define CLK_DISABLED(clk_id)	((CMD_CLK << CMD_SHIFT) |\
+				 ((clk_id) << CLK_ID_SHIFT))
+
+#define CLK_ADDR_SHIFT		16
+#define CLK_ADDR_MASK		GENMASK_32(30, 16)
+#define CLK_ADDR_VAL_MASK	GENMASK_32(15, 0)
+
+#define DIV_PLL1DIVP	0
+#define DIV_PLL2DIVP	1
+#define DIV_PLL2DIVQ	2
+#define DIV_PLL2DIVR	3
+#define DIV_PLL3DIVP	4
+#define DIV_PLL3DIVQ	5
+#define DIV_PLL3DIVR	6
+#define DIV_PLL4DIVP	7
+#define DIV_PLL4DIVQ	8
+#define DIV_PLL4DIVR	9
+#define DIV_MPU		10
+#define DIV_AXI		11
+#define DIV_MCU		12
+#define DIV_APB1	13
+#define DIV_APB2	14
+#define DIV_APB3	15
+#define DIV_APB4	16
+#define DIV_APB5	17
+#define DIV_RTC		19
+#define DIV_MCO1	20
+#define DIV_MCO2	21
+#define DIV_HSI		22
+#define DIV_TRACE	23
+#define DIV_ETHPTP	24
+#define DIV_NB		25
+
+#define MUX_MPU		0
+#define MUX_AXI		1
+#define MUX_MCU		2
+#define MUX_PLL12	3
+#define MUX_PLL3	4
+#define MUX_PLL4	5
+#define MUX_CKPER	6
+#define MUX_RTC		7
+#define MUX_SDMMC12	8
+#define MUX_SDMMC3	9
+#define MUX_FMC		10
+#define MUX_QSPI	11
+#define MUX_RNG1	12
+#define MUX_RNG2	13
+#define MUX_USBPHY	14
+#define MUX_USBO	15
+#define MUX_STGEN	16
+#define MUX_SPDIF	17
+#define MUX_SPI2S1	18
+#define MUX_SPI2S23	19
+#define MUX_SPI45	20
+#define MUX_SPI6	21
+#define MUX_CEC		22
+#define MUX_I2C12	23
+#define MUX_I2C35	24
+#define MUX_I2C46	25
+#define MUX_LPTIM1	26
+#define MUX_LPTIM23	27
+#define MUX_LPTIM45	28
+#define MUX_UART1	29
+#define MUX_UART24	30
+#define MUX_UART35	31
+#define MUX_UART6	32
+#define MUX_UART78	33
+#define MUX_SAI1	34
+#define MUX_SAI2	35
+#define MUX_SAI3	36
+#define MUX_SAI4	37
+#define MUX_DSI		38
+#define MUX_FDCAN	39
+#define MUX_ADC		40
+#define MUX_ETH		41
+#define MUX_MCO1	42
+#define MUX_MCO2	43
+#define MUX_NB		44
+
 /* PLL output is enable when x=1, with x=p,q or r */
 #define PQR(p, q, r)	(((p) & 1) | (((q) & 1) << 1) | (((r) & 1) << 2))
 
-/* st,clksrc: mandatory clock source */
-#define CLK_MPU_HSI		0x00000200
-#define CLK_MPU_HSE		0x00000201
-#define CLK_MPU_PLL1P		0x00000202
-#define CLK_MPU_PLL1P_DIV	0x00000203
-
-#define CLK_AXI_HSI		0x00000240
-#define CLK_AXI_HSE		0x00000241
-#define CLK_AXI_PLL2P		0x00000242
-
-#define CLK_MCU_HSI		0x00000480
-#define CLK_MCU_HSE		0x00000481
-#define CLK_MCU_CSI		0x00000482
-#define CLK_MCU_PLL3P		0x00000483
-
-#define CLK_PLL12_HSI		0x00000280
-#define CLK_PLL12_HSE		0x00000281
-
-#define CLK_PLL3_HSI		0x00008200
-#define CLK_PLL3_HSE		0x00008201
-#define CLK_PLL3_CSI		0x00008202
-
-#define CLK_PLL4_HSI		0x00008240
-#define CLK_PLL4_HSE		0x00008241
-#define CLK_PLL4_CSI		0x00008242
-#define CLK_PLL4_I2SCKIN	0x00008243
-
-#define CLK_RTC_DISABLED	0x00001400
-#define CLK_RTC_LSE		0x00001401
-#define CLK_RTC_LSI		0x00001402
-#define CLK_RTC_HSE		0x00001403
-
-#define CLK_MCO1_HSI		0x00008000
-#define CLK_MCO1_HSE		0x00008001
-#define CLK_MCO1_CSI		0x00008002
-#define CLK_MCO1_LSI		0x00008003
-#define CLK_MCO1_LSE		0x00008004
-#define CLK_MCO1_DISABLED	0x0000800F
-
-#define CLK_MCO2_MPU		0x00008040
-#define CLK_MCO2_AXI		0x00008041
-#define CLK_MCO2_MCU		0x00008042
-#define CLK_MCO2_PLL4P		0x00008043
-#define CLK_MCO2_HSE		0x00008044
-#define CLK_MCO2_HSI		0x00008045
-#define CLK_MCO2_DISABLED	0x0000804F
-
-/* st,pkcs: peripheral kernel clock source */
-
-#define CLK_I2C12_PCLK1		0x00008C00
-#define CLK_I2C12_PLL4R		0x00008C01
-#define CLK_I2C12_HSI		0x00008C02
-#define CLK_I2C12_CSI		0x00008C03
-#define CLK_I2C12_DISABLED	0x00008C07
-
-#define CLK_I2C35_PCLK1		0x00008C40
-#define CLK_I2C35_PLL4R		0x00008C41
-#define CLK_I2C35_HSI		0x00008C42
-#define CLK_I2C35_CSI		0x00008C43
-#define CLK_I2C35_DISABLED	0x00008C47
-
-#define CLK_I2C46_PCLK5		0x00000C00
-#define CLK_I2C46_PLL3Q		0x00000C01
-#define CLK_I2C46_HSI		0x00000C02
-#define CLK_I2C46_CSI		0x00000C03
-#define CLK_I2C46_DISABLED	0x00000C07
-
-#define CLK_SAI1_PLL4Q		0x00008C80
-#define CLK_SAI1_PLL3Q		0x00008C81
-#define CLK_SAI1_I2SCKIN	0x00008C82
-#define CLK_SAI1_CKPER		0x00008C83
-#define CLK_SAI1_PLL3R		0x00008C84
-#define CLK_SAI1_DISABLED	0x00008C87
-
-#define CLK_SAI2_PLL4Q		0x00008CC0
-#define CLK_SAI2_PLL3Q		0x00008CC1
-#define CLK_SAI2_I2SCKIN	0x00008CC2
-#define CLK_SAI2_CKPER		0x00008CC3
-#define CLK_SAI2_SPDIF		0x00008CC4
-#define CLK_SAI2_PLL3R		0x00008CC5
-#define CLK_SAI2_DISABLED	0x00008CC7
-
-#define CLK_SAI3_PLL4Q		0x00008D00
-#define CLK_SAI3_PLL3Q		0x00008D01
-#define CLK_SAI3_I2SCKIN	0x00008D02
-#define CLK_SAI3_CKPER		0x00008D03
-#define CLK_SAI3_PLL3R		0x00008D04
-#define CLK_SAI3_DISABLED	0x00008D07
-
-#define CLK_SAI4_PLL4Q		0x00008D40
-#define CLK_SAI4_PLL3Q		0x00008D41
-#define CLK_SAI4_I2SCKIN	0x00008D42
-#define CLK_SAI4_CKPER		0x00008D43
-#define CLK_SAI4_PLL3R		0x00008D44
-#define CLK_SAI4_DISABLED	0x00008D47
-
-#define CLK_SPI2S1_PLL4P	0x00008D80
-#define CLK_SPI2S1_PLL3Q	0x00008D81
-#define CLK_SPI2S1_I2SCKIN	0x00008D82
-#define CLK_SPI2S1_CKPER	0x00008D83
-#define CLK_SPI2S1_PLL3R	0x00008D84
-#define CLK_SPI2S1_DISABLED	0x00008D87
-
-#define CLK_SPI2S23_PLL4P	0x00008DC0
-#define CLK_SPI2S23_PLL3Q	0x00008DC1
-#define CLK_SPI2S23_I2SCKIN	0x00008DC2
-#define CLK_SPI2S23_CKPER	0x00008DC3
-#define CLK_SPI2S23_PLL3R	0x00008DC4
-#define CLK_SPI2S23_DISABLED	0x00008DC7
-
-#define CLK_SPI45_PCLK2		0x00008E00
-#define CLK_SPI45_PLL4Q		0x00008E01
-#define CLK_SPI45_HSI		0x00008E02
-#define CLK_SPI45_CSI		0x00008E03
-#define CLK_SPI45_HSE		0x00008E04
-#define CLK_SPI45_DISABLED	0x00008E07
-
-#define CLK_SPI6_PCLK5		0x00000C40
-#define CLK_SPI6_PLL4Q		0x00000C41
-#define CLK_SPI6_HSI		0x00000C42
-#define CLK_SPI6_CSI		0x00000C43
-#define CLK_SPI6_HSE		0x00000C44
-#define CLK_SPI6_PLL3Q		0x00000C45
-#define CLK_SPI6_DISABLED	0x00000C47
-
-#define CLK_UART6_PCLK2		0x00008E40
-#define CLK_UART6_PLL4Q		0x00008E41
-#define CLK_UART6_HSI		0x00008E42
-#define CLK_UART6_CSI		0x00008E43
-#define CLK_UART6_HSE		0x00008E44
-#define CLK_UART6_DISABLED	0x00008E47
-
-#define CLK_UART24_PCLK1	0x00008E80
-#define CLK_UART24_PLL4Q	0x00008E81
-#define CLK_UART24_HSI		0x00008E82
-#define CLK_UART24_CSI		0x00008E83
-#define CLK_UART24_HSE		0x00008E84
-#define CLK_UART24_DISABLED	0x00008E87
-
-#define CLK_UART35_PCLK1	0x00008EC0
-#define CLK_UART35_PLL4Q	0x00008EC1
-#define CLK_UART35_HSI		0x00008EC2
-#define CLK_UART35_CSI		0x00008EC3
-#define CLK_UART35_HSE		0x00008EC4
-#define CLK_UART35_DISABLED	0x00008EC7
-
-#define CLK_UART78_PCLK1	0x00008F00
-#define CLK_UART78_PLL4Q	0x00008F01
-#define CLK_UART78_HSI		0x00008F02
-#define CLK_UART78_CSI		0x00008F03
-#define CLK_UART78_HSE		0x00008F04
-#define CLK_UART78_DISABLED	0x00008F07
-
-#define CLK_UART1_PCLK5		0x00000C80
-#define CLK_UART1_PLL3Q		0x00000C81
-#define CLK_UART1_HSI		0x00000C82
-#define CLK_UART1_CSI		0x00000C83
-#define CLK_UART1_PLL4Q		0x00000C84
-#define CLK_UART1_HSE		0x00000C85
-#define CLK_UART1_DISABLED	0x00000C87
-
-#define CLK_SDMMC12_HCLK6	0x00008F40
-#define CLK_SDMMC12_PLL3R	0x00008F41
-#define CLK_SDMMC12_PLL4P	0x00008F42
-#define CLK_SDMMC12_HSI		0x00008F43
-#define CLK_SDMMC12_DISABLED	0x00008F47
-
-#define CLK_SDMMC3_HCLK2	0x00008F80
-#define CLK_SDMMC3_PLL3R	0x00008F81
-#define CLK_SDMMC3_PLL4P	0x00008F82
-#define CLK_SDMMC3_HSI		0x00008F83
-#define CLK_SDMMC3_DISABLED	0x00008F87
-
-#define CLK_ETH_PLL4P		0x00008FC0
-#define CLK_ETH_PLL3Q		0x00008FC1
-#define CLK_ETH_DISABLED	0x00008FC3
-
-#define CLK_QSPI_ACLK		0x00009000
-#define CLK_QSPI_PLL3R		0x00009001
-#define CLK_QSPI_PLL4P		0x00009002
-#define CLK_QSPI_CKPER		0x00009003
-
-#define CLK_FMC_ACLK		0x00009040
-#define CLK_FMC_PLL3R		0x00009041
-#define CLK_FMC_PLL4P		0x00009042
-#define CLK_FMC_CKPER		0x00009043
-
-#define CLK_FDCAN_HSE		0x000090C0
-#define CLK_FDCAN_PLL3Q		0x000090C1
-#define CLK_FDCAN_PLL4Q		0x000090C2
-#define CLK_FDCAN_PLL4R		0x000090C3
-
-#define CLK_SPDIF_PLL4P		0x00009140
-#define CLK_SPDIF_PLL3Q		0x00009141
-#define CLK_SPDIF_HSI		0x00009142
-#define CLK_SPDIF_DISABLED	0x00009143
-
-#define CLK_CEC_LSE		0x00009180
-#define CLK_CEC_LSI		0x00009181
-#define CLK_CEC_CSI_DIV122	0x00009182
-#define CLK_CEC_DISABLED	0x00009183
-
-#define CLK_USBPHY_HSE		0x000091C0
-#define CLK_USBPHY_PLL4R	0x000091C1
-#define CLK_USBPHY_HSE_DIV2	0x000091C2
-#define CLK_USBPHY_DISABLED	0x000091C3
-
-#define CLK_USBO_PLL4R		0x800091C0
-#define CLK_USBO_USBPHY		0x800091C1
-
-#define CLK_RNG1_CSI		0x00000CC0
-#define CLK_RNG1_PLL4R		0x00000CC1
-#define CLK_RNG1_LSE		0x00000CC2
-#define CLK_RNG1_LSI		0x00000CC3
-
-#define CLK_RNG2_CSI		0x00009200
-#define CLK_RNG2_PLL4R		0x00009201
-#define CLK_RNG2_LSE		0x00009202
-#define CLK_RNG2_LSI		0x00009203
-
-#define CLK_CKPER_HSI		0x00000D00
-#define CLK_CKPER_CSI		0x00000D01
-#define CLK_CKPER_HSE		0x00000D02
-#define CLK_CKPER_DISABLED	0x00000D03
-
-#define CLK_STGEN_HSI		0x00000D40
-#define CLK_STGEN_HSE		0x00000D41
-#define CLK_STGEN_DISABLED	0x00000D43
-
-#define CLK_DSI_DSIPLL		0x00009240
-#define CLK_DSI_PLL4P		0x00009241
-
-#define CLK_ADC_PLL4R		0x00009280
-#define CLK_ADC_CKPER		0x00009281
-#define CLK_ADC_PLL3Q		0x00009282
-#define CLK_ADC_DISABLED	0x00009283
-
-#define CLK_LPTIM45_PCLK3	0x000092C0
-#define CLK_LPTIM45_PLL4P	0x000092C1
-#define CLK_LPTIM45_PLL3Q	0x000092C2
-#define CLK_LPTIM45_LSE		0x000092C3
-#define CLK_LPTIM45_LSI		0x000092C4
-#define CLK_LPTIM45_CKPER	0x000092C5
-#define CLK_LPTIM45_DISABLED	0x000092C7
-
-#define CLK_LPTIM23_PCLK3	0x00009300
-#define CLK_LPTIM23_PLL4Q	0x00009301
-#define CLK_LPTIM23_CKPER	0x00009302
-#define CLK_LPTIM23_LSE		0x00009303
-#define CLK_LPTIM23_LSI		0x00009304
-#define CLK_LPTIM23_DISABLED	0x00009307
-
-#define CLK_LPTIM1_PCLK1	0x00009340
-#define CLK_LPTIM1_PLL4P	0x00009341
-#define CLK_LPTIM1_PLL3Q	0x00009342
-#define CLK_LPTIM1_LSE		0x00009343
-#define CLK_LPTIM1_LSI		0x00009344
-#define CLK_LPTIM1_CKPER	0x00009345
-#define CLK_LPTIM1_DISABLED	0x00009347
+/* st,clksrc: clock sources */
+#define CLK_MPU_HSI		CLKSRC(MUX_MPU, 0)
+#define CLK_MPU_HSE		CLKSRC(MUX_MPU, 1)
+#define CLK_MPU_PLL1P		CLKSRC(MUX_MPU, 2)
+#define CLK_MPU_PLL1P_DIV	CLKSRC(MUX_MPU, 3)
+
+#define CLK_AXI_HSI		CLKSRC(MUX_AXI, 0)
+#define CLK_AXI_HSE		CLKSRC(MUX_AXI, 1)
+#define CLK_AXI_PLL2P		CLKSRC(MUX_AXI, 2)
+
+#define CLK_MCU_HSI		CLKSRC(MUX_MCU, 0)
+#define CLK_MCU_HSE		CLKSRC(MUX_MCU, 1)
+#define CLK_MCU_CSI		CLKSRC(MUX_MCU, 2)
+#define CLK_MCU_PLL3P		CLKSRC(MUX_MCU, 3)
+
+#define CLK_PLL12_HSI		CLKSRC(MUX_PLL12, 0)
+#define CLK_PLL12_HSE		CLKSRC(MUX_PLL12, 1)
+
+#define CLK_PLL3_HSI		CLKSRC(MUX_PLL3, 0)
+#define CLK_PLL3_HSE		CLKSRC(MUX_PLL3, 1)
+#define CLK_PLL3_CSI		CLKSRC(MUX_PLL3, 2)
+
+#define CLK_PLL4_HSI		CLKSRC(MUX_PLL4, 0)
+#define CLK_PLL4_HSE		CLKSRC(MUX_PLL4, 1)
+#define CLK_PLL4_CSI		CLKSRC(MUX_PLL4, 2)
+#define CLK_PLL4_I2SCKIN	CLKSRC(MUX_PLL4, 3)
+
+#define CLK_RTC_DISABLED	CLK_DISABLED(RTC)
+#define CLK_RTC_LSE		CLK_SRC(RTC, 1)
+#define CLK_RTC_LSI		CLK_SRC(RTC, 2)
+#define CLK_RTC_HSE		CLK_SRC(RTC, 3)
+
+/* Register addresses of MCO1 & MCO2 */
+#define MCO1			0x800
+#define MCO2			0x804
+
+#define MCO_OFF			0
+#define MCO_ON			1
+#define MCO_STATUS_SHIFT	12
+
+#define MCO_ON_CFG(addr, sel)	(CMD_ADDR_BIT |\
+				((addr) << CLK_ADDR_SHIFT) |\
+				(MCO_ON << MCO_STATUS_SHIFT) |\
+				(sel))
+
+#define MCO_OFF_CFG(addr)	(CMD_ADDR_BIT |\
+				((addr) << CLK_ADDR_SHIFT) |\
+				(MCO_OFF << MCO_STATUS_SHIFT))
+
+#define CLK_MCO1_HSI		MCO_ON_CFG(MCO1, 0)
+#define CLK_MCO1_HSE		MCO_ON_CFG(MCO1, 1)
+#define CLK_MCO1_CSI		MCO_ON_CFG(MCO1, 2)
+#define CLK_MCO1_LSI		MCO_ON_CFG(MCO1, 3)
+#define CLK_MCO1_LSE		MCO_ON_CFG(MCO1, 4)
+#define CLK_MCO1_DISABLED	MCO_OFF_CFG(MCO1)
+
+#define CLK_MCO2_MPU		MCO_ON_CFG(MCO2, 0)
+#define CLK_MCO2_AXI		MCO_ON_CFG(MCO2, 1)
+#define CLK_MCO2_MCU		MCO_ON_CFG(MCO2, 2)
+#define CLK_MCO2_PLL4		MCO_ON_CFG(MCO2, 3)
+#define CLK_MCO2_HSE		MCO_ON_CFG(MCO2, 4)
+#define CLK_MCO2_HSI		MCO_ON_CFG(MCO2, 5)
+#define CLK_MCO2_DISABLED	MCO_OFF_CFG(MCO2)
+
+#define CLK_I2C12_PCLK1		CLKSRC(MUX_I2C12, 0)
+#define CLK_I2C12_PLL4R		CLKSRC(MUX_I2C12, 1)
+#define CLK_I2C12_HSI		CLKSRC(MUX_I2C12, 2)
+#define CLK_I2C12_CSI		CLKSRC(MUX_I2C12, 3)
+#define CLK_I2C12_DISABLED	CLKSRC(MUX_I2C12, 7)
+
+#define CLK_I2C35_PCLK1		CLKSRC(MUX_I2C35, 0)
+#define CLK_I2C35_PLL4R		CLKSRC(MUX_I2C35, 1)
+#define CLK_I2C35_HSI		CLKSRC(MUX_I2C35, 2)
+#define CLK_I2C35_CSI		CLKSRC(MUX_I2C35, 3)
+#define CLK_I2C35_DISABLED	CLKSRC(MUX_I2C35, 7)
+
+#define CLK_I2C46_PCLK5		CLKSRC(MUX_I2C46, 0)
+#define CLK_I2C46_PLL3Q		CLKSRC(MUX_I2C46, 1)
+#define CLK_I2C46_HSI		CLKSRC(MUX_I2C46, 2)
+#define CLK_I2C46_CSI		CLKSRC(MUX_I2C46, 3)
+#define CLK_I2C46_DISABLED	CLKSRC(MUX_I2C46, 7)
+
+#define CLK_SAI1_PLL4Q		CLKSRC(MUX_SAI1, 0)
+#define CLK_SAI1_PLL3Q		CLKSRC(MUX_SAI1, 1)
+#define CLK_SAI1_I2SCKIN	CLKSRC(MUX_SAI1, 2)
+#define CLK_SAI1_CKPER		CLKSRC(MUX_SAI1, 3)
+#define CLK_SAI1_PLL3R		CLKSRC(MUX_SAI1, 4)
+#define CLK_SAI1_DISABLED	CLKSRC(MUX_SAI1, 7)
+
+#define CLK_SAI2_PLL4Q		CLKSRC(MUX_SAI2, 0)
+#define CLK_SAI2_PLL3Q		CLKSRC(MUX_SAI2, 1)
+#define CLK_SAI2_I2SCKIN	CLKSRC(MUX_SAI2, 2)
+#define CLK_SAI2_CKPER		CLKSRC(MUX_SAI2, 3)
+#define CLK_SAI2_SPDIF		CLKSRC(MUX_SAI2, 4)
+#define CLK_SAI2_PLL3R		CLKSRC(MUX_SAI2, 5)
+#define CLK_SAI2_DISABLED	CLKSRC(MUX_SAI2, 7)
+
+#define CLK_SAI3_PLL4Q		CLKSRC(MUX_SAI3, 0)
+#define CLK_SAI3_PLL3Q		CLKSRC(MUX_SAI3, 1)
+#define CLK_SAI3_I2SCKIN	CLKSRC(MUX_SAI3, 2)
+#define CLK_SAI3_CKPER		CLKSRC(MUX_SAI3, 3)
+#define CLK_SAI3_PLL3R		CLKSRC(MUX_SAI3, 4)
+#define CLK_SAI3_DISABLED	CLKSRC(MUX_SAI3, 7)
+
+#define CLK_SAI4_PLL4Q		CLKSRC(MUX_SAI4, 0)
+#define CLK_SAI4_PLL3Q		CLKSRC(MUX_SAI4, 1)
+#define CLK_SAI4_I2SCKIN	CLKSRC(MUX_SAI4, 2)
+#define CLK_SAI4_CKPER		CLKSRC(MUX_SAI4, 3)
+#define CLK_SAI4_PLL3R		CLKSRC(MUX_SAI4, 4)
+#define CLK_SAI4_DISABLED	CLKSRC(MUX_SAI4, 7)
+
+#define CLK_SPI2S1_PLL4P	CLKSRC(MUX_SPI2S1, 0)
+#define CLK_SPI2S1_PLL3Q	CLKSRC(MUX_SPI2S1, 1)
+#define CLK_SPI2S1_I2SCKIN	CLKSRC(MUX_SPI2S1, 2)
+#define CLK_SPI2S1_CKPER	CLKSRC(MUX_SPI2S1, 3)
+#define CLK_SPI2S1_PLL3R	CLKSRC(MUX_SPI2S1, 4)
+#define CLK_SPI2S1_DISABLED	CLKSRC(MUX_SPI2S1, 7)
+
+#define CLK_SPI2S23_PLL4P	CLKSRC(MUX_SPI2S23, 0)
+#define CLK_SPI2S23_PLL3Q	CLKSRC(MUX_SPI2S23, 1)
+#define CLK_SPI2S23_I2SCKIN	CLKSRC(MUX_SPI2S23, 2)
+#define CLK_SPI2S23_CKPER	CLKSRC(MUX_SPI2S23, 3)
+#define CLK_SPI2S23_PLL3R	CLKSRC(MUX_SPI2S23, 4)
+#define CLK_SPI2S23_DISABLED	CLKSRC(MUX_SPI2S23, 7)
+
+#define CLK_SPI45_PCLK2		CLKSRC(MUX_SPI45, 0)
+#define CLK_SPI45_PLL4Q		CLKSRC(MUX_SPI45, 1)
+#define CLK_SPI45_HSI		CLKSRC(MUX_SPI45, 2)
+#define CLK_SPI45_CSI		CLKSRC(MUX_SPI45, 3)
+#define CLK_SPI45_HSE		CLKSRC(MUX_SPI45, 4)
+#define CLK_SPI45_DISABLED	CLKSRC(MUX_SPI45, 7)
+
+#define CLK_SPI6_PCLK5		CLKSRC(MUX_SPI6, 0)
+#define CLK_SPI6_PLL4Q		CLKSRC(MUX_SPI6, 1)
+#define CLK_SPI6_HSI		CLKSRC(MUX_SPI6, 2)
+#define CLK_SPI6_CSI		CLKSRC(MUX_SPI6, 3)
+#define CLK_SPI6_HSE		CLKSRC(MUX_SPI6, 4)
+#define CLK_SPI6_PLL3Q		CLKSRC(MUX_SPI6, 5)
+#define CLK_SPI6_DISABLED	CLKSRC(MUX_SPI6, 7)
+
+#define CLK_UART6_PCLK2		CLKSRC(MUX_UART6, 0)
+#define CLK_UART6_PLL4Q		CLKSRC(MUX_UART6, 1)
+#define CLK_UART6_HSI		CLKSRC(MUX_UART6, 2)
+#define CLK_UART6_CSI		CLKSRC(MUX_UART6, 3)
+#define CLK_UART6_HSE		CLKSRC(MUX_UART6, 4)
+#define CLK_UART6_DISABLED	CLKSRC(MUX_UART6, 7)
+
+#define CLK_UART24_PCLK1	CLKSRC(MUX_UART24, 0)
+#define CLK_UART24_PLL4Q	CLKSRC(MUX_UART24, 1)
+#define CLK_UART24_HSI		CLKSRC(MUX_UART24, 2)
+#define CLK_UART24_CSI		CLKSRC(MUX_UART24, 3)
+#define CLK_UART24_HSE		CLKSRC(MUX_UART24, 4)
+#define CLK_UART24_DISABLED	CLKSRC(MUX_UART24, 7)
+
+#define CLK_UART35_PCLK1	CLKSRC(MUX_UART35, 0)
+#define CLK_UART35_PLL4Q	CLKSRC(MUX_UART35, 1)
+#define CLK_UART35_HSI		CLKSRC(MUX_UART35, 2)
+#define CLK_UART35_CSI		CLKSRC(MUX_UART35, 3)
+#define CLK_UART35_HSE		CLKSRC(MUX_UART35, 4)
+#define CLK_UART35_DISABLED	CLKSRC(MUX_UART35, 7)
+
+#define CLK_UART78_PCLK1	CLKSRC(MUX_UART78, 0)
+#define CLK_UART78_PLL4Q	CLKSRC(MUX_UART78, 1)
+#define CLK_UART78_HSI		CLKSRC(MUX_UART78, 2)
+#define CLK_UART78_CSI		CLKSRC(MUX_UART78, 3)
+#define CLK_UART78_HSE		CLKSRC(MUX_UART78, 4)
+#define CLK_UART78_DISABLED	CLKSRC(MUX_UART78, 7)
+
+#define CLK_UART1_PCLK5		CLKSRC(MUX_UART1, 0)
+#define CLK_UART1_PLL3Q		CLKSRC(MUX_UART1, 1)
+#define CLK_UART1_HSI		CLKSRC(MUX_UART1, 2)
+#define CLK_UART1_CSI		CLKSRC(MUX_UART1, 3)
+#define CLK_UART1_PLL4Q		CLKSRC(MUX_UART1, 4)
+#define CLK_UART1_HSE		CLKSRC(MUX_UART1, 5)
+#define CLK_UART1_DISABLED	CLKSRC(MUX_UART1, 7)
+
+#define CLK_SDMMC12_HCLK6	CLKSRC(MUX_SDMMC12, 0)
+#define CLK_SDMMC12_PLL3R	CLKSRC(MUX_SDMMC12, 1)
+#define CLK_SDMMC12_PLL4P	CLKSRC(MUX_SDMMC12, 2)
+#define CLK_SDMMC12_HSI		CLKSRC(MUX_SDMMC12, 3)
+#define CLK_SDMMC12_DISABLED	CLKSRC(MUX_SDMMC12, 7)
+
+#define CLK_SDMMC3_HCLK2	CLKSRC(MUX_SDMMC3, 0)
+#define CLK_SDMMC3_PLL3R	CLKSRC(MUX_SDMMC3, 1)
+#define CLK_SDMMC3_PLL4P	CLKSRC(MUX_SDMMC3, 2)
+#define CLK_SDMMC3_HSI		CLKSRC(MUX_SDMMC3, 3)
+#define CLK_SDMMC3_DISABLED	CLKSRC(MUX_SDMMC3, 7)
+
+#define CLK_ETH_PLL4P		CLKSRC(MUX_ETH, 0)
+#define CLK_ETH_PLL3Q		CLKSRC(MUX_ETH, 1)
+#define CLK_ETH_DISABLED	CLKSRC(MUX_ETH, 3)
+
+#define CLK_QSPI_ACLK		CLKSRC(MUX_QSPI, 0)
+#define CLK_QSPI_PLL3R		CLKSRC(MUX_QSPI, 1)
+#define CLK_QSPI_PLL4P		CLKSRC(MUX_QSPI, 2)
+#define CLK_QSPI_CKPER		CLKSRC(MUX_QSPI, 3)
+
+#define CLK_FMC_ACLK		CLKSRC(MUX_FMC, 0)
+#define CLK_FMC_PLL3R		CLKSRC(MUX_FMC, 1)
+#define CLK_FMC_PLL4P		CLKSRC(MUX_FMC, 2)
+#define CLK_FMC_CKPER		CLKSRC(MUX_FMC, 3)
+
+#define CLK_FDCAN_HSE		CLKSRC(MUX_FDCAN, 0)
+#define CLK_FDCAN_PLL3Q		CLKSRC(MUX_FDCAN, 1)
+#define CLK_FDCAN_PLL4Q		CLKSRC(MUX_FDCAN, 2)
+#define CLK_FDCAN_PLL4R		CLKSRC(MUX_FDCAN, 3)
+
+#define CLK_SPDIF_PLL4P		CLKSRC(MUX_SPDIF, 0)
+#define CLK_SPDIF_PLL3Q		CLKSRC(MUX_SPDIF, 1)
+#define CLK_SPDIF_HSI		CLKSRC(MUX_SPDIF, 2)
+#define CLK_SPDIF_DISABLED	CLKSRC(MUX_SPDIF, 3)
+
+#define CLK_CEC_LSE		CLKSRC(MUX_CEC, 0)
+#define CLK_CEC_LSI		CLKSRC(MUX_CEC, 1)
+#define CLK_CEC_CSI_DIV122	CLKSRC(MUX_CEC, 2)
+#define CLK_CEC_DISABLED	CLKSRC(MUX_CEC, 3)
+
+#define CLK_USBPHY_HSE		CLKSRC(MUX_USBPHY, 0)
+#define CLK_USBPHY_PLL4R	CLKSRC(MUX_USBPHY, 1)
+#define CLK_USBPHY_HSE_DIV2	CLKSRC(MUX_USBPHY, 2)
+#define CLK_USBPHY_DISABLED	CLKSRC(MUX_USBPHY, 3)
+
+#define CLK_USBO_PLL4R		CLKSRC(MUX_USBO, 0)
+#define CLK_USBO_USBPHY		CLKSRC(MUX_USBO, 1)
+
+#define CLK_RNG1_CSI		CLKSRC(MUX_RNG1, 0)
+#define CLK_RNG1_PLL4R		CLKSRC(MUX_RNG1, 1)
+#define CLK_RNG1_LSE		CLKSRC(MUX_RNG1, 2)
+#define CLK_RNG1_LSI		CLKSRC(MUX_RNG1, 3)
+
+#define CLK_RNG2_CSI		CLKSRC(MUX_RNG2, 0)
+#define CLK_RNG2_PLL4R		CLKSRC(MUX_RNG2, 1)
+#define CLK_RNG2_LSE		CLKSRC(MUX_RNG2, 2)
+#define CLK_RNG2_LSI		CLKSRC(MUX_RNG2, 3)
+
+#define CLK_CKPER_HSI		CLKSRC(MUX_CKPER, 0)
+#define CLK_CKPER_CSI		CLKSRC(MUX_CKPER, 1)
+#define CLK_CKPER_HSE		CLKSRC(MUX_CKPER, 2)
+#define CLK_CKPER_DISABLED	CLKSRC(MUX_CKPER, 3)
+
+#define CLK_STGEN_HSI		CLKSRC(MUX_STGEN, 0)
+#define CLK_STGEN_HSE		CLKSRC(MUX_STGEN, 1)
+#define CLK_STGEN_DISABLED	CLKSRC(MUX_STGEN, 3)
+
+#define CLK_DSI_DSIPLL		CLKSRC(MUX_DSI, 0)
+#define CLK_DSI_PLL4P		CLKSRC(MUX_DSI, 1)
+
+#define CLK_ADC_PLL4R		CLKSRC(MUX_ADC, 0)
+#define CLK_ADC_CKPER		CLKSRC(MUX_ADC, 1)
+#define CLK_ADC_PLL3Q		CLKSRC(MUX_ADC, 2)
+#define CLK_ADC_DISABLED	CLKSRC(MUX_ADC, 3)
+
+#define CLK_LPTIM45_PCLK3	CLKSRC(MUX_LPTIM45, 0)
+#define CLK_LPTIM45_PLL4P	CLKSRC(MUX_LPTIM45, 1)
+#define CLK_LPTIM45_PLL3Q	CLKSRC(MUX_LPTIM45, 2)
+#define CLK_LPTIM45_LSE		CLKSRC(MUX_LPTIM45, 3)
+#define CLK_LPTIM45_LSI		CLKSRC(MUX_LPTIM45, 4)
+#define CLK_LPTIM45_CKPER	CLKSRC(MUX_LPTIM45, 5)
+#define CLK_LPTIM45_DISABLED	CLKSRC(MUX_LPTIM45, 7)
+
+#define CLK_LPTIM23_PCLK3	CLKSRC(MUX_LPTIM23, 0)
+#define CLK_LPTIM23_PLL4Q	CLKSRC(MUX_LPTIM23, 1)
+#define CLK_LPTIM23_CKPER	CLKSRC(MUX_LPTIM23, 2)
+#define CLK_LPTIM23_LSE		CLKSRC(MUX_LPTIM23, 3)
+#define CLK_LPTIM23_LSI		CLKSRC(MUX_LPTIM23, 4)
+#define CLK_LPTIM23_DISABLED	CLKSRC(MUX_LPTIM23, 7)
+
+#define CLK_LPTIM1_PCLK1	CLKSRC(MUX_LPTIM1, 0)
+#define CLK_LPTIM1_PLL4P	CLKSRC(MUX_LPTIM1, 1)
+#define CLK_LPTIM1_PLL3Q	CLKSRC(MUX_LPTIM1, 2)
+#define CLK_LPTIM1_LSE		CLKSRC(MUX_LPTIM1, 3)
+#define CLK_LPTIM1_LSI		CLKSRC(MUX_LPTIM1, 4)
+#define CLK_LPTIM1_CKPER	CLKSRC(MUX_LPTIM1, 5)
+#define CLK_LPTIM1_DISABLED	CLKSRC(MUX_LPTIM1, 7)
 
 /* define for st,pll /csg */
 #define SSCG_MODE_CENTER_SPREAD	0
diff --git a/include/dt-bindings/clock/stm32mp25-clks.h b/include/dt-bindings/clock/stm32mp25-clks.h
new file mode 100644
index 0000000000..f7a20849f8
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp25-clks.h
@@ -0,0 +1,492 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_CLKS_H_
+#define _DT_BINDINGS_STM32MP25_CLKS_H_
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL3_CK			10
+#define PLL4_CK			11
+#define PLL5_CK			12
+#define PLL6_CK			13
+#define PLL7_CK			14
+#define PLL8_CK			15
+
+#define CK_CPU1			16
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		17
+#define CK_ICN_APB2		18
+#define CK_ICN_APB3		19
+#define CK_ICN_APB4		20
+#define CK_ICN_APBDBG		21
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		22
+#define TIMG2_CK		23
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		24
+#define CK_ICN_SDMMC		25
+#define CK_ICN_DDR		26
+#define CK_ICN_DISPLAY		27
+#define CK_ICN_HSL		28
+#define CK_ICN_NIC		29
+#define CK_ICN_VID		30
+#define CK_FLEXGEN_07		31
+#define CK_FLEXGEN_08		32
+#define CK_FLEXGEN_09		33
+#define CK_FLEXGEN_10		34
+#define CK_FLEXGEN_11		35
+#define CK_FLEXGEN_12		36
+#define CK_FLEXGEN_13		37
+#define CK_FLEXGEN_14		38
+#define CK_FLEXGEN_15		39
+#define CK_FLEXGEN_16		40
+#define CK_FLEXGEN_17		41
+#define CK_FLEXGEN_18		42
+#define CK_FLEXGEN_19		43
+#define CK_FLEXGEN_20		44
+#define CK_FLEXGEN_21		45
+#define CK_FLEXGEN_22		46
+#define CK_FLEXGEN_23		47
+#define CK_FLEXGEN_24		48
+#define CK_FLEXGEN_25		49
+#define CK_FLEXGEN_26		50
+#define CK_FLEXGEN_27		51
+#define CK_FLEXGEN_28		52
+#define CK_FLEXGEN_29		53
+#define CK_FLEXGEN_30		54
+#define CK_FLEXGEN_31		55
+#define CK_FLEXGEN_32		56
+#define CK_FLEXGEN_33		57
+#define CK_FLEXGEN_34		58
+#define CK_FLEXGEN_35		59
+#define CK_FLEXGEN_36		60
+#define CK_FLEXGEN_37		61
+#define CK_FLEXGEN_38		62
+#define CK_FLEXGEN_39		63
+#define CK_FLEXGEN_40		64
+#define CK_FLEXGEN_41		65
+#define CK_FLEXGEN_42		66
+#define CK_FLEXGEN_43		67
+#define CK_FLEXGEN_44		68
+#define CK_FLEXGEN_45		69
+#define CK_FLEXGEN_46		70
+#define CK_FLEXGEN_47		71
+#define CK_FLEXGEN_48		72
+#define CK_FLEXGEN_49		73
+#define CK_FLEXGEN_50		74
+#define CK_FLEXGEN_51		75
+#define CK_FLEXGEN_52		76
+#define CK_FLEXGEN_53		77
+#define CK_FLEXGEN_54		78
+#define CK_FLEXGEN_55		79
+#define CK_FLEXGEN_56		80
+#define CK_FLEXGEN_57		81
+#define CK_FLEXGEN_58		82
+#define CK_FLEXGEN_59		83
+#define CK_FLEXGEN_60		84
+#define CK_FLEXGEN_61		85
+#define CK_FLEXGEN_62		86
+#define CK_FLEXGEN_63		87
+
+/* LOW SPEED MCU CLOCK */
+#define CK_ICN_LS_MCU		88
+
+#define CK_BUS_STM500		89
+#define CK_BUS_FMC		90
+#define CK_BUS_GPU		91
+#define CK_BUS_ETH1		92
+#define CK_BUS_ETH2		93
+#define CK_BUS_PCIE		94
+#define CK_BUS_DDRPHYC		95
+#define CK_BUS_SYSCPU1		96
+#define CK_BUS_ETHSW		97
+#define CK_BUS_HPDMA1		98
+#define CK_BUS_HPDMA2		99
+#define CK_BUS_HPDMA3		100
+#define CK_BUS_ADC12		101
+#define CK_BUS_ADC3		102
+#define CK_BUS_IPCC1		103
+#define CK_BUS_CCI		104
+#define CK_BUS_CRC		105
+#define CK_BUS_MDF1		106
+#define CK_BUS_OSPIIOM		107
+#define CK_BUS_BKPSRAM		108
+#define CK_BUS_HASH		109
+#define CK_BUS_RNG		110
+#define CK_BUS_CRYP1		111
+#define CK_BUS_CRYP2		112
+#define CK_BUS_SAES		113
+#define CK_BUS_PKA		114
+#define CK_BUS_GPIOA		115
+#define CK_BUS_GPIOB		116
+#define CK_BUS_GPIOC		117
+#define CK_BUS_GPIOD		118
+#define CK_BUS_GPIOE		119
+#define CK_BUS_GPIOF		120
+#define CK_BUS_GPIOG		121
+#define CK_BUS_GPIOH		122
+#define CK_BUS_GPIOI		123
+#define CK_BUS_GPIOJ		124
+#define CK_BUS_GPIOK		125
+#define CK_BUS_LPSRAM1		126
+#define CK_BUS_LPSRAM2		127
+#define CK_BUS_LPSRAM3		128
+#define CK_BUS_GPIOZ		129
+#define CK_BUS_LPDMA		130
+#define CK_BUS_HSEM		131
+#define CK_BUS_IPCC2		132
+#define CK_BUS_RTC		133
+#define CK_BUS_SPI8		134
+#define CK_BUS_LPUART1		135
+#define CK_BUS_I2C8		136
+#define CK_BUS_LPTIM3		137
+#define CK_BUS_LPTIM4		138
+#define CK_BUS_LPTIM5		139
+#define CK_BUS_IWDG5		140
+#define CK_BUS_WWDG2		141
+#define CK_BUS_I3C4		142
+#define CK_BUS_TIM2		143
+#define CK_BUS_TIM3		144
+#define CK_BUS_TIM4		145
+#define CK_BUS_TIM5		146
+#define CK_BUS_TIM6		147
+#define CK_BUS_TIM7		148
+#define CK_BUS_TIM10		149
+#define CK_BUS_TIM11		150
+#define CK_BUS_TIM12		151
+#define CK_BUS_TIM13		152
+#define CK_BUS_TIM14		153
+#define CK_BUS_LPTIM1		154
+#define CK_BUS_LPTIM2		155
+#define CK_BUS_SPI2		156
+#define CK_BUS_SPI3		157
+#define CK_BUS_SPDIFRX		158
+#define CK_BUS_USART2		159
+#define CK_BUS_USART3		160
+#define CK_BUS_UART4		161
+#define CK_BUS_UART5		162
+#define CK_BUS_I2C1		163
+#define CK_BUS_I2C2		164
+#define CK_BUS_I2C3		165
+#define CK_BUS_I2C4		166
+#define CK_BUS_I2C5		167
+#define CK_BUS_I2C6		168
+#define CK_BUS_I2C7		169
+#define CK_BUS_I3C1		170
+#define CK_BUS_I3C2		171
+#define CK_BUS_I3C3		172
+#define CK_BUS_TIM1		173
+#define CK_BUS_TIM8		174
+#define CK_BUS_TIM15		175
+#define CK_BUS_TIM16		176
+#define CK_BUS_TIM17		177
+#define CK_BUS_TIM20		178
+#define CK_BUS_SAI1		179
+#define CK_BUS_SAI2		180
+#define CK_BUS_SAI3		181
+#define CK_BUS_SAI4		182
+#define CK_BUS_USART1		183
+#define CK_BUS_USART6		184
+#define CK_BUS_UART7		185
+#define CK_BUS_UART8		186
+#define CK_BUS_UART9		187
+#define CK_BUS_FDCAN		188
+#define CK_BUS_SPI1		189
+#define CK_BUS_SPI4		190
+#define CK_BUS_SPI5		191
+#define CK_BUS_SPI6		192
+#define CK_BUS_SPI7		193
+#define CK_BUS_BSEC		194
+#define CK_BUS_IWDG1		195
+#define CK_BUS_IWDG2		196
+#define CK_BUS_IWDG3		197
+#define CK_BUS_IWDG4		198
+#define CK_BUS_WWDG1		199
+#define CK_BUS_VREF		200
+#define CK_BUS_DTS		201
+#define CK_BUS_SERC		202
+#define CK_BUS_HDP		203
+#define CK_BUS_IS2M		204
+#define CK_BUS_DSI		205
+#define CK_BUS_LTDC		206
+#define CK_BUS_CSI		207
+#define CK_BUS_DCMIPP		208
+#define CK_BUS_DDRC		209
+#define CK_BUS_DDRCFG		210
+#define CK_BUS_GICV2M		211
+#define CK_BUS_USBTC		212
+#define CK_BUS_USB3PCIEPHY	214
+#define CK_BUS_STGEN		215
+#define CK_BUS_VDEC		216
+#define CK_BUS_VENC		217
+#define CK_SYSDBG		218
+#define CK_KER_TIM2		219
+#define CK_KER_TIM3		220
+#define CK_KER_TIM4		221
+#define CK_KER_TIM5		222
+#define CK_KER_TIM6		223
+#define CK_KER_TIM7		224
+#define CK_KER_TIM10		225
+#define CK_KER_TIM11		226
+#define CK_KER_TIM12		227
+#define CK_KER_TIM13		228
+#define CK_KER_TIM14		229
+#define CK_KER_TIM1		230
+#define CK_KER_TIM8		231
+#define CK_KER_TIM15		232
+#define CK_KER_TIM16		233
+#define CK_KER_TIM17		234
+#define CK_KER_TIM20		235
+#define CK_BUS_SYSRAM		236
+#define CK_BUS_VDERAM		237
+#define CK_BUS_RETRAM		238
+#define CK_BUS_OSPI1		239
+#define CK_BUS_OSPI2		240
+#define CK_BUS_OTFD1		241
+#define CK_BUS_OTFD2		242
+#define CK_BUS_SRAM1		243
+#define CK_BUS_SRAM2		244
+#define CK_BUS_SDMMC1		245
+#define CK_BUS_SDMMC2		246
+#define CK_BUS_SDMMC3		247
+#define CK_BUS_DDR		248
+#define CK_BUS_RISAF4		249
+#define CK_BUS_USB2OHCI		250
+#define CK_BUS_USB2EHCI		251
+#define CK_BUS_USB3DR		252
+#define CK_KER_LPTIM1		253
+#define CK_KER_LPTIM2		254
+#define CK_KER_USART2		255
+#define CK_KER_UART4		256
+#define CK_KER_USART3		257
+#define CK_KER_UART5		258
+#define CK_KER_SPI2		259
+#define CK_KER_SPI3		260
+#define CK_KER_SPDIFRX		261
+#define CK_KER_I2C1		262
+#define CK_KER_I2C2		263
+#define CK_KER_I3C1		264
+#define CK_KER_I3C2		265
+#define CK_KER_I2C3		266
+#define CK_KER_I2C5		267
+#define CK_KER_I3C3		268
+#define CK_KER_I2C4		269
+#define CK_KER_I2C6		270
+#define CK_KER_I2C7		271
+#define CK_KER_SPI1		272
+#define CK_KER_SPI4		273
+#define CK_KER_SPI5		274
+#define CK_KER_SPI6		275
+#define CK_KER_SPI7		276
+#define CK_KER_USART1		277
+#define CK_KER_USART6		278
+#define CK_KER_UART7		279
+#define CK_KER_UART8		280
+#define CK_KER_UART9		281
+#define CK_KER_MDF1		282
+#define CK_KER_SAI1		283
+#define CK_KER_SAI2		284
+#define CK_KER_SAI3		285
+#define CK_KER_SAI4		286
+#define CK_KER_FDCAN		287
+#define CK_KER_DSIBLANE		288
+#define CK_KER_DSIPHY		289
+#define CK_KER_CSI		290
+#define CK_KER_CSITXESC		291
+#define CK_KER_CSIPHY		292
+#define CK_KER_LVDSPHY		293
+#define CK_KER_STGEN		294
+#define CK_KER_USB3PCIEPHY	295
+#define CK_KER_USB2PHY2EN	296
+#define CK_KER_I3C4		297
+#define CK_KER_SPI8		298
+#define CK_KER_I2C8		299
+#define CK_KER_LPUART1		300
+#define CK_KER_LPTIM3		301
+#define CK_KER_LPTIM4		302
+#define CK_KER_LPTIM5		303
+#define CK_KER_TSDBG		304
+#define CK_KER_TPIU		305
+#define CK_BUS_ETR		306
+#define CK_BUS_SYSATB		307
+#define CK_KER_ADC12		308
+#define CK_KER_ADC3		309
+#define CK_KER_OSPI1		310
+#define CK_KER_OSPI2		311
+#define CK_KER_FMC		312
+#define CK_KER_SDMMC1		313
+#define CK_KER_SDMMC2		314
+#define CK_KER_SDMMC3		315
+#define CK_KER_ETH1		316
+#define CK_KER_ETH2		317
+#define CK_KER_ETH1PTP		318
+#define CK_KER_ETH2PTP		319
+#define CK_KER_USB2PHY1		320
+#define CK_KER_USB2PHY2		321
+#define CK_KER_ETHSW		322
+#define CK_KER_ETHSWREF		323
+#define CK_MCO1			324
+#define CK_MCO2			325
+#define CK_KER_DTS		326
+#define CK_ETH1_RX		327
+#define CK_ETH1_TX		328
+#define CK_ETH1_MAC		329
+#define CK_ETH2_RX		330
+#define CK_ETH2_TX		331
+#define CK_ETH2_MAC		332
+#define CK_ETH1_STP		333
+#define CK_ETH2_STP		334
+#define CK_KER_USBTC		335
+#define CK_BUS_ADF1		336
+#define CK_KER_ADF1		337
+#define CK_BUS_LVDS		338
+#define CK_KER_LTDC		339
+#define CK_KER_GPU		340
+#define CK_BUS_ETHSWACMCFG	341
+#define CK_BUS_ETHSWACMMSG	342
+#define HSE_DIV2_CK		343
+
+#define STM32MP25_LAST_CLK	344
+
+#define CK_SCMI_ICN_HS_MCU	0
+#define CK_SCMI_ICN_SDMMC	1
+#define CK_SCMI_ICN_DDR		2
+#define CK_SCMI_ICN_DISPLAY	3
+#define CK_SCMI_ICN_HSL		4
+#define CK_SCMI_ICN_NIC		5
+#define CK_SCMI_ICN_VID		6
+#define CK_SCMI_FLEXGEN_07	7
+#define CK_SCMI_FLEXGEN_08	8
+#define CK_SCMI_FLEXGEN_09	9
+#define CK_SCMI_FLEXGEN_10	10
+#define CK_SCMI_FLEXGEN_11	11
+#define CK_SCMI_FLEXGEN_12	12
+#define CK_SCMI_FLEXGEN_13	13
+#define CK_SCMI_FLEXGEN_14	14
+#define CK_SCMI_FLEXGEN_15	15
+#define CK_SCMI_FLEXGEN_16	16
+#define CK_SCMI_FLEXGEN_17	17
+#define CK_SCMI_FLEXGEN_18	18
+#define CK_SCMI_FLEXGEN_19	19
+#define CK_SCMI_FLEXGEN_20	20
+#define CK_SCMI_FLEXGEN_21	21
+#define CK_SCMI_FLEXGEN_22	22
+#define CK_SCMI_FLEXGEN_23	23
+#define CK_SCMI_FLEXGEN_24	24
+#define CK_SCMI_FLEXGEN_25	25
+#define CK_SCMI_FLEXGEN_26	26
+#define CK_SCMI_FLEXGEN_27	27
+#define CK_SCMI_FLEXGEN_28	28
+#define CK_SCMI_FLEXGEN_29	29
+#define CK_SCMI_FLEXGEN_30	30
+#define CK_SCMI_FLEXGEN_31	31
+#define CK_SCMI_FLEXGEN_32	32
+#define CK_SCMI_FLEXGEN_33	33
+#define CK_SCMI_FLEXGEN_34	34
+#define CK_SCMI_FLEXGEN_35	35
+#define CK_SCMI_FLEXGEN_36	36
+#define CK_SCMI_FLEXGEN_37	37
+#define CK_SCMI_FLEXGEN_38	38
+#define CK_SCMI_FLEXGEN_39	39
+#define CK_SCMI_FLEXGEN_40	40
+#define CK_SCMI_FLEXGEN_41	41
+#define CK_SCMI_FLEXGEN_42	42
+#define CK_SCMI_FLEXGEN_43	43
+#define CK_SCMI_FLEXGEN_44	44
+#define CK_SCMI_FLEXGEN_45	45
+#define CK_SCMI_FLEXGEN_46	46
+#define CK_SCMI_FLEXGEN_47	47
+#define CK_SCMI_FLEXGEN_48	48
+#define CK_SCMI_FLEXGEN_49	49
+#define CK_SCMI_FLEXGEN_50	50
+#define CK_SCMI_FLEXGEN_51	51
+#define CK_SCMI_FLEXGEN_52	52
+#define CK_SCMI_FLEXGEN_53	53
+#define CK_SCMI_FLEXGEN_54	54
+#define CK_SCMI_FLEXGEN_55	55
+#define CK_SCMI_FLEXGEN_56	56
+#define CK_SCMI_FLEXGEN_57	57
+#define CK_SCMI_FLEXGEN_58	58
+#define CK_SCMI_FLEXGEN_59	59
+#define CK_SCMI_FLEXGEN_60	60
+#define CK_SCMI_FLEXGEN_61	61
+#define CK_SCMI_FLEXGEN_62	62
+#define CK_SCMI_FLEXGEN_63	63
+#define CK_SCMI_ICN_LS_MCU	64
+#define CK_SCMI_HSE		65
+#define CK_SCMI_LSE		66
+#define CK_SCMI_HSI		67
+#define CK_SCMI_LSI		68
+#define CK_SCMI_MSI		69
+#define CK_SCMI_HSE_DIV2	70
+#define CK_SCMI_CPU1		71
+#define CK_SCMI_SYSCPU1		72
+#define CK_SCMI_PLL2		73
+#define CK_SCMI_PLL3		74
+#define CK_SCMI_RTC		75
+#define CK_SCMI_RTCCK		76
+#define CK_SCMI_ICN_APB1	77
+#define CK_SCMI_ICN_APB2	78
+#define CK_SCMI_ICN_APB3	79
+#define CK_SCMI_ICN_APB4	80
+#define CK_SCMI_ICN_APBDBG	81
+#define CK_SCMI_TIMG1		82
+#define CK_SCMI_TIMG2		83
+#define CK_SCMI_BKPSRAM		84
+#define CK_SCMI_BSEC		85
+#define CK_SCMI_ETR		87
+#define CK_SCMI_FMC		88
+#define CK_SCMI_GPIOA		89
+#define CK_SCMI_GPIOB		90
+#define CK_SCMI_GPIOC		91
+#define CK_SCMI_GPIOD		92
+#define CK_SCMI_GPIOE		93
+#define CK_SCMI_GPIOF		94
+#define CK_SCMI_GPIOG		95
+#define CK_SCMI_GPIOH		96
+#define CK_SCMI_GPIOI		97
+#define CK_SCMI_GPIOJ		98
+#define CK_SCMI_GPIOK		99
+#define CK_SCMI_GPIOZ		100
+#define CK_SCMI_HPDMA1		101
+#define CK_SCMI_HPDMA2		102
+#define CK_SCMI_HPDMA3		103
+#define CK_SCMI_HSEM		104
+#define CK_SCMI_IPCC1		105
+#define CK_SCMI_IPCC2		106
+#define CK_SCMI_LPDMA		107
+#define CK_SCMI_RETRAM		108
+#define CK_SCMI_SRAM1		109
+#define CK_SCMI_SRAM2		110
+#define CK_SCMI_LPSRAM1		111
+#define CK_SCMI_LPSRAM2		112
+#define CK_SCMI_LPSRAM3		113
+#define CK_SCMI_VDERAM		114
+#define CK_SCMI_SYSRAM		115
+#define CK_SCMI_OSPI1		116
+#define CK_SCMI_OSPI2		117
+#define CK_SCMI_TPIU		118
+#define CK_SCMI_SYSDBG		119
+#define CK_SCMI_SYSATB		120
+#define CK_SCMI_TSDBG		121
+#define CK_SCMI_STM500		122
+
+#endif /* _DT_BINDINGS_STM32MP25_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp25-clksrc.h b/include/dt-bindings/clock/stm32mp25-clksrc.h
new file mode 100644
index 0000000000..ee22cc55ab
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp25-clksrc.h
@@ -0,0 +1,226 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2017-2020, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_STM32MP25_CLKSRC_H_
+#define _DT_BINDINGS_CLOCK_STM32MP25_CLKSRC_H_
+
+#define CMD_DIV		0
+#define CMD_MUX		1
+#define CMD_CLK		2
+#define CMD_FLEXGEN	3
+
+#define CMD_ADDR_BIT	0x80000000
+
+#define CMD_SHIFT	26
+#define CMD_MASK	0xFC000000
+#define CMD_DATA_MASK	0x03FFFFFF
+
+#define DIV_ID_SHIFT	8
+#define DIV_ID_MASK	0x0000FF00
+
+#define DIV_DIVN_SHIFT	0
+#define DIV_DIVN_MASK	0x000000FF
+
+#define MUX_ID_SHIFT	4
+#define MUX_ID_MASK	0x00000FF0
+
+#define MUX_SEL_SHIFT	0
+#define MUX_SEL_MASK	0x0000000F
+
+/* CLK define */
+#define CLK_ON_MASK	BIT(21)
+#define CLK_ON_SHIFT	21
+
+#define CLK_ID_MASK	GENMASK_32(20, 12)
+#define CLK_ID_SHIFT	12
+
+#define CLK_NO_DIV_MASK	0x0000080
+#define CLK_DIV_MASK	GENMASK_32(10, 5)
+#define CLK_DIV_SHIFT	5
+
+#define CLK_NO_SEL_MASK	0x00000010
+#define CLK_SEL_MASK	GENMASK_32(3, 0)
+#define CLK_SEL_SHIFT	0
+
+#define CLK_CFG(clk_id, sel, div, state)	((CMD_CLK << CMD_SHIFT) |\
+						 ((state) << CLK_ON_SHIFT) |\
+						 ((clk_id) << CLK_ID_SHIFT) |\
+						 ((div) << CLK_DIV_SHIFT) |\
+						 ((sel) << CLK_SEL_SHIFT))
+
+#define CLK_OFF		0
+#define CLK_ON		1
+#define CLK_NODIV	0x00000040
+#define CLK_NOMUX	0x00000010
+
+/* Flexgen define */
+#define FLEX_ID_SHIFT	13
+#define FLEX_SEL_SHIFT	9
+#define FLEX_PDIV_SHIFT	6
+#define FLEX_FDIV_SHIFT	0
+
+#define FLEX_ID_MASK	GENMASK_32(18, 13)
+#define FLEX_SEL_MASK	GENMASK_32(12, 9)
+#define FLEX_PDIV_MASK	GENMASK_32(8, 6)
+#define FLEX_FDIV_MASK	GENMASK_32(5, 0)
+
+#define DIV_CFG(div_id, div)	((CMD_DIV << CMD_SHIFT) |\
+				 ((div_id) << DIV_ID_SHIFT |\
+				 (div)))
+
+#define MUX_CFG(mux_id, sel)	((CMD_MUX << CMD_SHIFT) |\
+				 ((mux_id) << MUX_ID_SHIFT |\
+				 (sel)))
+
+#define CLK_ADDR_SHIFT		16
+#define CLK_ADDR_MASK		0x7FFF0000
+#define CLK_ADDR_VAL_MASK	0xFFFF
+
+#define DIV_LSMCU	0
+#define DIV_APB1	1
+#define DIV_APB2	2
+#define DIV_APB3	3
+#define DIV_APB4	4
+#define DIV_APBDBG	5
+#define DIV_RTC		6
+#define DIV_NB		7
+
+#define MUX_MUXSEL0	0
+#define MUX_MUXSEL1	1
+#define MUX_MUXSEL2	2
+#define MUX_MUXSEL3	3
+#define MUX_MUXSEL4	4
+#define MUX_MUXSEL5	5
+#define MUX_MUXSEL6	6
+#define MUX_MUXSEL7	7
+#define MUX_XBARSEL	8
+#define MUX_RTC		9
+#define MUX_MCO1	10
+#define MUX_MCO2	11
+#define MUX_ADC12	12
+#define MUX_ADC3	13
+#define MUX_USB2PHY1	14
+#define MUX_USB2PHY2	15
+#define MUX_USB3PCIEPHY	16
+#define MUX_DSIBLANE	17
+#define MUX_DSIPHY	18
+#define MUX_LVDSPHY	19
+#define MUX_DTS		20
+#define MUX_CPU1	21
+#define MUX_D3PER	22
+#define MUX_NB		23
+
+#define MUXSEL_HSI		0
+#define MUXSEL_HSE		1
+#define MUXSEL_MSI		2
+
+/* KERNEL source clocks */
+#define MUX_RTC_DISABLED	0x0
+#define MUX_RTC_LSE		0x1
+#define MUX_RTC_LSI		0x2
+#define MUX_RTC_HSE		0x3
+
+#define MUX_MCO1_FLEX61		0x0
+#define MUX_MCO1_OBSER0		0x1
+
+#define MUX_MCO2_FLEX62		0x0
+#define MUX_MCO2_OBSER1		0x1
+
+#define MUX_ADC12_FLEX46	0x0
+#define MUX_ADC12_LSMCU		0x1
+
+#define MUX_ADC3_FLEX47		0x0
+#define MUX_ADC3_LSMCU		0x1
+#define MUX_ADC3_FLEX46		0x2
+
+#define MUX_USB2PHY1_FLEX57	0x0
+#define MUX_USB2PHY1_HSE	0x1
+
+#define MUX_USB2PHY2_FLEX58	0x0
+#define MUX_USB2PHY2_HSE	0x1
+
+#define MUX_USB3PCIEPHY_FLEX34	0x0
+#define MUX_USB3PCIEPHY_HSE	0x1
+
+#define MUX_DSIBLANE_FLEX28	0x0
+#define MUX_DSIBLANE_FLEX27	0x1
+
+#define MUX_DSIPHY_FLEX28	0x0
+#define MUX_DSIPHY_HSE		0x1
+
+#define MUX_LVDSPHY_FLEX32	0x0
+#define MUX_LVDSPHY_HSE		0x1
+
+#define MUX_DTS_HSI		0x0
+#define MUX_DTS_HSE		0x1
+#define MUX_DTS_MSI		0x2
+
+#define MUX_D3PER_MSI		0x0
+#define MUX_D3PER_LSI		0x1
+#define MUX_D3PER_LSE		0x2
+
+/* PLLs source clocks */
+#define PLL_SRC_HSI		0x0
+#define PLL_SRC_HSE		0x1
+#define PLL_SRC_MSI		0x2
+#define PLL_SRC_DISABLED	0x3
+
+/* XBAR source clocks */
+#define XBAR_SRC_PLL4		0x0
+#define XBAR_SRC_PLL5		0x1
+#define XBAR_SRC_PLL6		0x2
+#define XBAR_SRC_PLL7		0x3
+#define XBAR_SRC_PLL8		0x4
+#define XBAR_SRC_HSI		0x5
+#define XBAR_SRC_HSE		0x6
+#define XBAR_SRC_MSI		0x7
+#define XBAR_SRC_HSI_KER	0x8
+#define XBAR_SRC_HSE_KER	0x9
+#define XBAR_SRC_MSI_KER	0xA
+#define XBAR_SRC_SPDIF_SYMB	0xB
+#define XBAR_SRC_I2S		0xC
+#define XBAR_SRC_LSI		0xD
+#define XBAR_SRC_LSE		0xE
+
+/*
+ * Configure a XBAR channel with its clock source
+ * channel_nb: XBAR channel number from 0 to 63
+ * channel_src: one of the 15 previous XBAR source clocks defines
+ * channel_prediv: value of the PREDIV in channel RCC_PREDIVxCFGR register
+ *		   can be either 1, 2, 4 or 1024
+ * channel_findiv: value of the FINDIV in channel RCC_FINDIVxCFGR register
+ *		   from 1 to 64
+ */
+
+#define FLEXGEN_CFG(ch, sel, pdiv, fdiv)	((CMD_FLEXGEN << CMD_SHIFT) |\
+						((ch) << FLEX_ID_SHIFT) |\
+						((sel) << FLEX_SEL_SHIFT) |\
+						((pdiv) << FLEX_PDIV_SHIFT) |\
+						((fdiv) << FLEX_FDIV_SHIFT))
+
+/* Register addresses of MCO1 & MCO2 */
+#define MCO1			0x494
+#define MCO2			0x498
+
+#define MCO_OFF			0
+#define MCO_ON			1
+#define MCO_STATUS_SHIFT	8
+
+#define MCO_CFG(addr, sel, status)	(CMD_ADDR_BIT |\
+					((addr) << CLK_ADDR_SHIFT) |\
+					((status) << MCO_STATUS_SHIFT) |\
+					(sel))
+
+/* define for st,pll /csg */
+#define SSCG_MODE_CENTER_SPREAD	0
+#define SSCG_MODE_DOWN_SPREAD	1
+
+/* define for st,drive */
+#define LSEDRV_LOWEST		0
+#define LSEDRV_MEDIUM_LOW	2
+#define LSEDRV_MEDIUM_HIGH	1
+#define LSEDRV_HIGHEST		3
+
+#endif /* _DT_BINDINGS_CLOCK_STM32MP25_CLKSRC_H_ */
diff --git a/include/dt-bindings/gpio/stm32-gpio.h b/include/dt-bindings/gpio/stm32-gpio.h
new file mode 100644
index 0000000000..3820bd1fb3
--- /dev/null
+++ b/include/dt-bindings/gpio/stm32-gpio.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Paillet Pascal <p.paillet@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_GPIO_H
+#define _DT_BINDINGS_STM32_GPIO_H
+
+/* Bank IDs used in GPIO driver API */
+#define GPIO_BANK_A			0U
+#define GPIO_BANK_B			1U
+#define GPIO_BANK_C			2U
+#define GPIO_BANK_D			3U
+#define GPIO_BANK_E			4U
+#define GPIO_BANK_F			5U
+#define GPIO_BANK_G			6U
+#define GPIO_BANK_H			7U
+#define GPIO_BANK_I			8U
+#define GPIO_BANK_J			9U
+#define GPIO_BANK_K			10U
+#define GPIO_BANK_Z			25U
+
+/* Bit 0 is used to set GPIO in input mode */
+#define GPIOF_DIR_OUT			0x0
+#define GPIOF_DIR_IN			0x1
+
+/* Bit 1 is used to set GPIO high level during init */
+#define GPIOF_INIT_LOW			0x0
+#define GPIOF_INIT_HIGH			0x2
+
+#define GPIOF_IN			(GPIOF_DIR_IN)
+#define GPIOF_OUT_INIT_LOW		(GPIOF_DIR_OUT | GPIOF_INIT_LOW)
+#define GPIOF_OUT_INIT_HIGH		(GPIOF_DIR_OUT | GPIOF_INIT_HIGH)
+
+/* Bit 2 is used to set GPIO pull up */
+#define GPIOF_PULL_UP			0x4
+/* Bit 3 is used to set GPIO pull down */
+#define GPIOF_PULL_DOWN			0x8
+
+#endif /* _DT_BINDINGS_STM32_GPIO_H */
diff --git a/include/dt-bindings/power/stm32mp1-power.h b/include/dt-bindings/power/stm32mp1-power.h
new file mode 100644
index 0000000000..3202e0b44e
--- /dev/null
+++ b/include/dt-bindings/power/stm32mp1-power.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C) 2018-2019, STMicroelectronics - All Rights Reserved
+ * Author: Yann Gautier <yann.gautier@st.com> for STMicroelectronics.
+ */
+
+#ifndef DT_BINDINGS_STM32MP1_POWER_H
+#define DT_BINDINGS_STM32MP1_POWER_H
+
+#define STM32_PM_CSLEEP_RUN			0
+#define STM32_PM_CSTOP_ALLOW_STOP		1
+#define STM32_PM_CSTOP_ALLOW_LP_STOP		2
+#define STM32_PM_CSTOP_ALLOW_LPLV_STOP		3
+#define STM32_PM_CSTOP_ALLOW_LPLV_STOP2		4
+#define STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR	5
+#define STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF	6
+#define STM32_PM_SHUTDOWN			7
+#define STM32_PM_MAX_SOC_MODE			8
+
+#endif /* DT_BINDINGS_STM32MP1_POWER_H */
diff --git a/include/dt-bindings/reset/stm32mp25-resets.h b/include/dt-bindings/reset/stm32mp25-resets.h
new file mode 100644
index 0000000000..9724038b33
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp25-resets.h
@@ -0,0 +1,167 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+  *	      Yann Gautier <yann.gautier@st.com> for STMicroelectronics.
+*/
+
+#ifndef _DT_BINDINGS_STM32MP25_RESET_H_
+#define _DT_BINDINGS_STM32MP25_RESET_H_
+
+#define SYS_R		8192
+#define C1_R		8224
+#define C1P1POR_R	8256
+#define C1P1_R		8257
+#define C2_R		8288
+#define C2_HOLDBOOT_R	8608
+#define C1_HOLDBOOT_R	8609
+#define VSW_R		8735
+#define C1MS_R		8840
+#define IWDG2_KER_R	9106
+#define IWDG4_KER_R	9234
+#define C3_R		9344
+#define DDRCP_R		9888
+#define DDRCAPB_R	9920
+#define DDRPHYCAPB_R	9952
+#define DDRCFG_R	10016
+#define DDR_R		10048
+#define OSPI1_R		10400
+#define OSPI1DLL_R	10416
+#define OSPI2_R		10432
+#define OSPI2DLL_R	10448
+#define FMC_R		10464
+#define DBG_R		10508
+#define GPIOA_R		10592
+#define GPIOB_R		10624
+#define GPIOC_R		10656
+#define GPIOD_R		10688
+#define GPIOE_R		10720
+#define GPIOF_R		10752
+#define GPIOG_R		10784
+#define GPIOH_R		10816
+#define GPIOI_R		10848
+#define GPIOJ_R		10880
+#define GPIOK_R		10912
+#define GPIOZ_R		10944
+#define HPDMA1_R	10976
+#define HPDMA2_R	11008
+#define HPDMA3_R	11040
+#define LPDMA_R		11072
+#define HSEM_R		11104
+#define IPCC1_R		11136
+#define IPCC2_R		11168
+#define IS2M_R		11360
+#define SSMOD_R		11392
+#define TIM1_R		14336
+#define TIM2_R		14368
+#define TIM3_R		14400
+#define TIM4_R		14432
+#define TIM5_R		14464
+#define TIM6_R		14496
+#define TIM7_R		14528
+#define TIM8_R		14560
+#define TIM10_R		14592
+#define TIM11_R		14624
+#define TIM12_R		14656
+#define TIM13_R		14688
+#define TIM14_R		14720
+#define TIM15_R		14752
+#define TIM16_R		14784
+#define TIM17_R		14816
+#define TIM20_R		14848
+#define LPTIM1_R	14880
+#define LPTIM2_R	14912
+#define LPTIM3_R	14944
+#define LPTIM4_R	14976
+#define LPTIM5_R	15008
+#define SPI1_R		15040
+#define SPI2_R		15072
+#define SPI3_R		15104
+#define SPI4_R		15136
+#define SPI5_R		15168
+#define SPI6_R		15200
+#define SPI7_R		15232
+#define SPI8_R		15264
+#define SPDIFRX_R	15296
+#define USART1_R	15328
+#define USART2_R	15360
+#define USART3_R	15392
+#define UART4_R		15424
+#define UART5_R		15456
+#define USART6_R	15488
+#define UART7_R		15520
+#define UART8_R		15552
+#define UART9_R		15584
+#define LPUART1_R	15616
+#define I2C1_R		15648
+#define I2C2_R		15680
+#define I2C3_R		15712
+#define I2C4_R		15744
+#define I2C5_R		15776
+#define I2C6_R		15808
+#define I2C7_R		15840
+#define I2C8_R		15872
+#define SAI1_R		15904
+#define SAI2_R		15936
+#define SAI3_R		15968
+#define SAI4_R		16000
+#define MDF1_R		16064
+#define MDF2_R		16096
+#define FDCAN_R		16128
+#define HDP_R		16160
+#define ADC12_R		16192
+#define ADC3_R		16224
+#define ETH1_R		16256
+#define ETH2_R		16288
+#define USB2_R		16352
+#define USB2PHY1_R	16384
+#define USB2PHY2_R	16416
+#define USB3DR_R	16448
+#define USB3PCIEPHY_R	16480
+#define PCIE_R		16512
+#define USBTC_R		16544
+#define ETHSW_R		16576
+#define SDMMC1_R	16768
+#define SDMMC1DLL_R	16784
+#define SDMMC2_R	16800
+#define SDMMC2DLL_R	16816
+#define SDMMC3_R	16832
+#define SDMMC3DLL_R	16848
+#define GPU_R		16864
+#define LTDC_R		16896
+#define DSI_R		16928
+#define LVDS_R		17024
+#define CSI_R		17088
+#define DCMIPP_R	17120
+#define CCI_R		17152
+#define VDEC_R		17184
+#define VENC_R		17216
+#define RNG_R		17280
+#define PKA_R		17312
+#define SAES_R		17344
+#define HASH_R		17376
+#define CRYP1_R		17408
+#define CRYP2_R		17440
+#define WWDG1_R		17632
+#define WWDG2_R		17664
+#define VREF_R		17728
+#define DTS_R		17760
+#define CRC_R		17824
+#define SERC_R		17856
+#define OSPIIOM_R	17888
+#define I3C1_R		17984
+#define I3C2_R		18016
+#define I3C3_R		18048
+#define I3C4_R		18080
+
+#define RST_SCMI_C1_R		0
+#define RST_SCMI_C2_R		1
+#define RST_SCMI_C1_HOLDBOOT_R	2
+#define RST_SCMI_C2_HOLDBOOT_R	3
+#define RST_SCMI_FMC		4
+#define RST_SCMI_OSPI1		5
+#define RST_SCMI_OSPI1DLL	6
+#define RST_SCMI_OSPI2		7
+#define RST_SCMI_OSPI2DLL	8
+
+#endif /* _DT_BINDINGS_STM32MP25_RESET_H_ */
diff --git a/include/dt-bindings/soc/rif.h b/include/dt-bindings/soc/rif.h
new file mode 100644
index 0000000000..9bba5a8cbd
--- /dev/null
+++ b/include/dt-bindings/soc/rif.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier:	GPL-2.0+	BSD-3-Clause
+ */
+
+#ifndef _DT_BINDINGS_RIF_H
+#define _DT_BINDINGS_RIF_H
+
+/* RIFSC CIDs */
+#define RIF_CID0		0x0
+#define RIF_CID1		0x1
+#define RIF_CID2		0x2
+#define RIF_CID3		0x3
+#define RIF_CID4		0x4
+#define RIF_CID5		0x5
+#define RIF_CID6		0x6
+#define RIF_CID7		0x7
+#define RIF_CID_MAX		0x8
+
+/* RIFSC semaphore list */
+#define EMPTY_SEMWL		0x0
+#define RIF_CID0_BF		(1 << RIF_CID0)
+#define RIF_CID1_BF		(1 << RIF_CID1)
+#define RIF_CID2_BF		(1 << RIF_CID2)
+#define RIF_CID3_BF		(1 << RIF_CID3)
+#define RIF_CID4_BF		(1 << RIF_CID4)
+#define RIF_CID5_BF		(1 << RIF_CID5)
+#define RIF_CID6_BF		(1 << RIF_CID6)
+#define RIF_CID7_BF		(1 << RIF_CID7)
+
+/* RIFSC secure levels */
+#define RIF_NSEC		0x0
+#define RIF_SEC			0x1
+
+/* RIFSC privilege levels */
+#define RIF_NPRIV		0x0
+#define RIF_PRIV		0x1
+
+/* RIFSC semaphore modes */
+#define RIF_SEM_DIS		0x0
+#define RIF_SEM_EN		0x1
+
+/* RIFSC CID filtering modes */
+#define RIF_CFDIS		0x0
+#define RIF_CFEN		0x1
+
+/* RIFSC lock states */
+#define RIF_UNLOCK		0x0
+#define RIF_LOCK		0x1
+
+#define RIFPROT(rifid, sem_list, sec, priv, scid, sem_en, cfen) \
+	(((rifid) << 24) | ((sem_list) << 16) | ((priv) << 9) | ((sec) << 8) | ((scid) << 4) | \
+	 ((sem_en) << 1) | (cfen))
+
+/* Masters IDs */
+#define RIMU_ID(idx)		(idx)
+
+/* Master configuration modes */
+#define RIF_CIDSEL_P		0x0 /* Config from RISUP */
+#define RIF_CIDSEL_M		0x1 /* Config from RIMU */
+
+#define RIMUPROT(rimuid, scid, sec, priv, mode) \
+	(((rimuid) << 16) | ((priv) << 9) | ((sec) << 8) | ((scid) << 4) | ((mode) << 2))
+
+/* RISAF region IDs */
+#define RISAF_REG_ID(idx)	(idx)
+
+/* RISAF base region enable modes */
+#define RIF_BREN_DIS		0x0
+#define RIF_BREN_EN		0x1
+
+/* RISAF encryption modes */
+#define RIF_ENC_DIS		0x0
+#define RIF_ENC_EN		0x2
+
+#define RISAFPROT(risaf_region, cid_read_list, cid_write_list, cid_priv_list, sec, enc, enabled) \
+	(((cid_write_list) << 24) | ((cid_read_list) << 16) | ((cid_priv_list) << 8) | \
+	 ((enc) << 6) | ((sec) << 5) | ((enabled) << 4) | (risaf_region))
+
+/* RISAB page IDs */
+#define RISAB_PAGE_ID(idx)	(idx)
+
+/* RISAB control modes */
+#define RIF_DDCID_DIS		0x0
+#define RIF_DDCID_EN		0x1
+
+#define RISABPROT(risab_page, delegate_en, delegate_cid, sec, default_priv, cid_read_list, \
+		  cid_write_list, cid_priv_list, enabled) \
+	(((risab_page) << 24) | ((default_priv) << 9) | ((sec) << 8) | ((delegate_cid) << 4) | \
+	 ((delegate_en) << 2) | (enabled)) \
+	((cid_write_list) << 16 | (cid_read_list) << 8 | (cid_priv_list))
+
+#endif /* _DT_BINDINGS_RIF_H */
+
diff --git a/include/dt-bindings/soc/stm32mp13-mce.h b/include/dt-bindings/soc/stm32mp13-mce.h
new file mode 100644
index 0000000000..15006fc612
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp13-mce.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */
+/*
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_MCE_H
+#define _DT_BINDINGS_STM32MP13_MCE_H
+
+#define MCE_PLAINTEXT  U(0)
+#define MCE_ENCRYPT    U(1)
+
+#endif /* _DT_BINDINGS_STM32MP13_MCE_H */
diff --git a/include/dt-bindings/soc/stm32mp25-rif.h b/include/dt-bindings/soc/stm32mp25-rif.h
new file mode 100644
index 0000000000..61bc8d0428
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp25-rif.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier:	GPL-2.0+	BSD-3-Clause
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RIF_H
+#define _DT_BINDINGS_STM32MP25_RIF_H
+
+/* define RIFSC ID */
+#define STM32MP25_RIFSC_TIM1_ID			0
+#define STM32MP25_RIFSC_TIM2_ID			1
+#define STM32MP25_RIFSC_TIM3_ID			2
+#define STM32MP25_RIFSC_TIM4_ID			3
+#define STM32MP25_RIFSC_TIM5_ID			4
+#define STM32MP25_RIFSC_TIM6_ID			5
+#define STM32MP25_RIFSC_TIM7_ID			6
+#define STM32MP25_RIFSC_TIM8_ID			7
+#define STM32MP25_RIFSC_TIM10_ID		8
+#define STM32MP25_RIFSC_TIM11_ID		9
+#define STM32MP25_RIFSC_TIM12_ID		10
+#define STM32MP25_RIFSC_TIM13_ID		11
+#define STM32MP25_RIFSC_TIM14_ID		12
+#define STM32MP25_RIFSC_TIM15_ID		13
+#define STM32MP25_RIFSC_TIM16_ID		14
+#define STM32MP25_RIFSC_TIM17_ID		15
+#define STM32MP25_RIFSC_TIM20_ID		16
+#define STM32MP25_RIFSC_LPTIM1_ID		17
+#define STM32MP25_RIFSC_LPTIM2_ID		18
+#define STM32MP25_RIFSC_LPTIM3_ID		19
+#define STM32MP25_RIFSC_LPTIM4_ID		20
+#define STM32MP25_RIFSC_LPTIM5_ID		21
+#define STM32MP25_RIFSC_SPI1_ID			22
+#define STM32MP25_RIFSC_SPI2_ID			23
+#define STM32MP25_RIFSC_SPI3_ID			24
+#define STM32MP25_RIFSC_SPI4_ID			25
+#define STM32MP25_RIFSC_SPI5_ID			26
+#define STM32MP25_RIFSC_SPI6_ID			27
+#define STM32MP25_RIFSC_SPI7_ID			28
+#define STM32MP25_RIFSC_SPI8_ID			29
+#define STM32MP25_RIFSC_SPDIFRX_ID		30
+#define STM32MP25_RIFSC_USART1_ID		31
+#define STM32MP25_RIFSC_USART2_ID		32
+#define STM32MP25_RIFSC_USART3_ID		33
+#define STM32MP25_RIFSC_UART4_ID		34
+#define STM32MP25_RIFSC_UART5_ID		35
+#define STM32MP25_RIFSC_USART6_ID		36
+#define STM32MP25_RIFSC_UART7_ID		37
+#define STM32MP25_RIFSC_UART8_ID		38
+#define STM32MP25_RIFSC_UART9_ID		39
+#define STM32MP25_RIFSC_LPUART1_ID		40
+#define STM32MP25_RIFSC_I2C1_ID			41
+#define STM32MP25_RIFSC_I2C2_ID			42
+#define STM32MP25_RIFSC_I2C3_ID			43
+#define STM32MP25_RIFSC_I2C4_ID			44
+#define STM32MP25_RIFSC_I2C5_ID			45
+#define STM32MP25_RIFSC_I2C6_ID			46
+#define STM32MP25_RIFSC_I2C7_ID			47
+#define STM32MP25_RIFSC_I2C8_ID			48
+#define STM32MP25_RIFSC_SAI1_ID			49
+#define STM32MP25_RIFSC_SAI2_ID			50
+#define STM32MP25_RIFSC_SAI3_ID			51
+#define STM32MP25_RIFSC_SAI4_ID			52
+#define STM32MP25_RIFSC_MDF1_ID			54
+#define STM32MP25_RIFSC_ADF1_ID			55
+#define STM32MP25_RIFSC_FDCAN_ID		56
+#define STM32MP25_RIFSC_HDP_ID			57
+#define STM32MP25_RIFSC_ADC12_ID		58
+#define STM32MP25_RIFSC_ADC3_ID			59
+#define STM32MP25_RIFSC_ETH1_ID			60
+#define STM32MP25_RIFSC_ETH2_ID			61
+#define STM32MP25_RIFSC_USBH_ID			63
+#define STM32MP25_RIFSC_USB3DR_ID		66
+#define STM32MP25_RIFSC_COMBOPHY_ID		67
+#define STM32MP25_RIFSC_PCIE_ID			68
+#define STM32MP25_RIFSC_UCPD1_ID		69
+#define STM32MP25_RIFSC_ETHSW_CFG_ID		70
+#define STM32MP25_RIFSC_ACM_CFG_ID		71
+#define STM32MP25_RIFSC_ACM_MSGBUF_ID		72
+#define STM32MP25_RIFSC_STGEN_ID		73
+#define STM32MP25_RIFSC_OCTOSPI1_ID		74
+#define STM32MP25_RIFSC_OCTOSPI2_ID		75
+#define STM32MP25_RIFSC_SDMMC1_ID		76
+#define STM32MP25_RIFSC_SDMMC2_ID		77
+#define STM32MP25_RIFSC_SDMMC3_ID		78
+#define STM32MP25_RIFSC_GPU_ID			79
+#define STM32MP25_RIFSC_LTDC_CMN_ID		80
+#define STM32MP25_RIFSC_DSI_CMN_ID		81
+#define STM32MP25_RIFSC_LDITX_ID		84
+#define STM32MP25_RIFSC_CSI2HOST_ID		86
+#define STM32MP25_RIFSC_DCMIPP_ID		87
+#define STM32MP25_RIFSC_CCI_ID			88
+#define STM32MP25_RIFSC_VDEC_ID			89
+#define STM32MP25_RIFSC_VENC_ID			90
+#define STM32MP25_RIFSC_RNG_ID			92
+#define STM32MP25_RIFSC_PKA_ID			93
+#define STM32MP25_RIFSC_SAES_ID			94
+#define STM32MP25_RIFSC_HASH_ID			95
+#define STM32MP25_RIFSC_CRYP1_ID		96
+#define STM32MP25_RIFSC_CRYP2_ID		97
+#define STM32MP25_RIFSC_IWDG1_ID		98
+#define STM32MP25_RIFSC_IWDG2_ID		99
+#define STM32MP25_RIFSC_IWDG3_ID		100
+#define STM32MP25_RIFSC_IWDG4_ID		101
+#define STM32MP25_RIFSC_IWDG5_ID		102
+#define STM32MP25_RIFSC_WWDG1_ID		103
+#define STM32MP25_RIFSC_WWDG2_ID		104
+#define STM32MP25_RIFSC_VREFBUF_ID		106
+#define STM32MP25_RIFSC_DTS_ID			107
+#define STM32MP25_RIFSC_CRC_ID			109
+#define STM32MP25_RIFSC_SERC_ID			110
+#define STM32MP25_RIFSC_OCTOSPIM_ID		111
+#define STM32MP25_RIFSC_GICV2M_ID		112
+#define STM32MP25_RIFSC_I3C1_ID			114
+#define STM32MP25_RIFSC_I3C2_ID			115
+#define STM32MP25_RIFSC_I3C3_ID			116
+#define STM32MP25_RIFSC_I3C4_ID			117
+#define STM32MP25_RIFSC_ICACHE_DCACHE_ID	118
+#define STM32MP25_RIFSC_LTDC_L0L1_ID		119
+#define STM32MP25_RIFSC_LTDC_L2_ID		120
+#define STM32MP25_RIFSC_LTDC_ROT_ID		121
+#define STM32MP25_RIFSC_DSI_TRIG_ID		122
+#define STM32MP25_RIFSC_DSI_RDFIFO_ID		123
+#define STM32MP25_RIFSC_OTFDEC1_ID		125
+#define STM32MP25_RIFSC_OTFDEC2_ID		126
+#define STM32MP25_RIFSC_IAC_ID			127
+#define STM32MP25_RIFSC_BSEC_ID			177
+
+#define STM32MP25_RIFSC_MAX_ID			178
+
+#endif /* _DT_BINDINGS_STM32MP25_RIF_H */
+
diff --git a/include/lib/fconf/fconf.h b/include/lib/fconf/fconf.h
index 131c542852..37620215a2 100644
--- a/include/lib/fconf/fconf.h
+++ b/include/lib/fconf/fconf.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, ARM Limited. All rights reserved.
+ * Copyright (c) 2019-2022, ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -21,7 +21,7 @@
  */
 #define FCONF_REGISTER_POPULATOR(config, name, callback)			\
 	__attribute__((used, section(".fconf_populator")))			\
-	const struct fconf_populator (name##__populator) = {			\
+	static const struct fconf_populator (name##__populator) = {		\
 		.config_type = (#config),					\
 		.info = (#name),						\
 		.populate = (callback)						\
diff --git a/include/lib/psci/psci.h b/include/lib/psci/psci.h
index b56e98b5f3..0342562593 100644
--- a/include/lib/psci/psci.h
+++ b/include/lib/psci/psci.h
@@ -1,5 +1,6 @@
 /*
- * Copyright (c) 2013-2019, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2013-2023, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2023, NVIDIA Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -29,12 +30,21 @@
 /* This is the power level corresponding to a CPU */
 #define PSCI_CPU_PWR_LVL	U(0)
 
+#if PSCI_EXTENDED_STATE_ID
+/*
+ * For Extented StateID format, the composite state use bits 27:0 with one
+ * nibble by local state (recommended ARM encoding = ARM_RECOM_STATE_ID_ENC),
+ * the maximum power level supported by PSCI is 7 (28/4).
+ */
+#define PSCI_MAX_PWR_LVL	U(7)
+#else
 /*
  * The maximum power level supported by PSCI. Since PSCI CPU_SUSPEND
  * uses the old power_state parameter format which has 2 bits to specify the
  * power level, this constant is defined to be 3.
  */
 #define PSCI_MAX_PWR_LVL	U(3)
+#endif
 
 /*******************************************************************************
  * Defines for runtime services function ids
@@ -59,6 +69,7 @@
 #define PSCI_NODE_HW_STATE_AARCH64	U(0xc400000d)
 #define PSCI_SYSTEM_SUSPEND_AARCH32	U(0x8400000E)
 #define PSCI_SYSTEM_SUSPEND_AARCH64	U(0xc400000E)
+#define PSCI_SET_SUSPEND_MODE		U(0x8400000F)
 #define PSCI_STAT_RESIDENCY_AARCH32	U(0x84000010)
 #define PSCI_STAT_RESIDENCY_AARCH64	U(0xc4000010)
 #define PSCI_STAT_COUNT_AARCH32		U(0x84000011)
@@ -73,9 +84,17 @@
  * Number of PSCI calls (above) implemented
  */
 #if ENABLE_PSCI_STAT
-#define PSCI_NUM_CALLS			U(22)
+#if PSCI_OS_INIT_MODE
+#define PSCI_NUM_CALLS			U(30)
 #else
-#define PSCI_NUM_CALLS			U(18)
+#define PSCI_NUM_CALLS			U(29)
+#endif
+#else
+#if PSCI_OS_INIT_MODE
+#define PSCI_NUM_CALLS			U(26)
+#else
+#define PSCI_NUM_CALLS			U(25)
+#endif
 #endif
 
 /* The macros below are used to identify PSCI calls from the SMC function ID */
@@ -134,7 +153,11 @@
 
 /* Features flags for CPU SUSPEND OS Initiated mode support. Bits [0:0] */
 #define FF_MODE_SUPPORT_SHIFT		U(0)
+#if PSCI_OS_INIT_MODE
 #define FF_SUPPORTS_OS_INIT_MODE	U(1)
+#else
+#define FF_SUPPORTS_OS_INIT_MODE	U(0)
+#endif
 
 /*******************************************************************************
  * PSCI version
@@ -268,6 +291,13 @@ typedef struct psci_power_state {
 	 * for the CPU.
 	 */
 	plat_local_state_t pwr_domain_state[PLAT_MAX_PWR_LVL + U(1)];
+#if PSCI_OS_INIT_MODE
+	/*
+	 * The highest power level at which the current CPU is the last running
+	 * CPU.
+	 */
+	unsigned int last_at_pwrlvl;
+#endif
 } psci_power_state_t;
 
 /*******************************************************************************
@@ -297,6 +327,11 @@ typedef struct plat_psci_ops {
 	void (*cpu_standby)(plat_local_state_t cpu_state);
 	int (*pwr_domain_on)(u_register_t mpidr);
 	void (*pwr_domain_off)(const psci_power_state_t *target_state);
+	int (*pwr_domain_off_early)(const psci_power_state_t *target_state);
+#if PSCI_OS_INIT_MODE
+	int (*pwr_domain_validate_suspend)(
+				const psci_power_state_t *target_state);
+#endif
 	void (*pwr_domain_suspend_pwrdown_early)(
 				const psci_power_state_t *target_state);
 	void (*pwr_domain_suspend)(const psci_power_state_t *target_state);
@@ -347,6 +382,9 @@ u_register_t psci_migrate_info_up_cpu(void);
 int psci_node_hw_state(u_register_t target_cpu,
 		       unsigned int power_level);
 int psci_features(unsigned int psci_fid);
+#if PSCI_OS_INIT_MODE
+int psci_set_suspend_mode(unsigned int mode);
+#endif
 void __dead2 psci_power_down_wfi(void);
 void psci_arch_setup(void);
 
diff --git a/include/lib/psci/psci_lib.h b/include/lib/psci/psci_lib.h
index 3edc50b6ce..4b244ec334 100644
--- a/include/lib/psci/psci_lib.h
+++ b/include/lib/psci/psci_lib.h
@@ -92,6 +92,7 @@ void psci_prepare_next_non_secure_ctx(
 int psci_stop_other_cores(unsigned int wait_ms,
 			  void (*stop_func)(u_register_t mpidr));
 bool psci_is_last_on_cpu_safe(void);
+bool psci_are_all_cpus_on_safe(void);
 void psci_pwrdown_cpu(unsigned int power_level);
 
 #endif /* __ASSEMBLER__ */
diff --git a/include/lib/utils_def.h b/include/lib/utils_def.h
index 198b890c7c..c944a10d2f 100644
--- a/include/lib/utils_def.h
+++ b/include/lib/utils_def.h
@@ -64,18 +64,28 @@
 	((val) + _div - (__typeof__(div)) 1) / _div;		\
 })
 
+/*
+ * Macro for unsigned integer division with nearest rounding variant.
+ * Default integer division rounds down.
+ */
+#define udiv_round_nearest(x, y) __extension__ ({	\
+	__typeof__(x) _x = (x);				\
+	__typeof__(y) _y = (y);				\
+	(_x + (_y / 2)) / _y;				\
+})
+
 #define MIN(x, y) __extension__ ({	\
 	__typeof__(x) _x = (x);		\
 	__typeof__(y) _y = (y);		\
 	(void)(&_x == &_y);		\
-	_x < _y ? _x : _y;		\
+	(_x < _y) ? _x : _y;		\
 })
 
 #define MAX(x, y) __extension__ ({	\
 	__typeof__(x) _x = (x);		\
 	__typeof__(y) _y = (y);		\
 	(void)(&_x == &_y);		\
-	_x > _y ? _x : _y;		\
+	(_x > _y) ? _x : _y;		\
 })
 
 #define CLAMP(x, min, max) __extension__ ({ \
@@ -84,7 +94,7 @@
 	__typeof__(max) _max = (max); \
 	(void)(&_x == &_min); \
 	(void)(&_x == &_max); \
-	(_x > _max ? _max : (_x < _min ? _min : _x)); \
+	((_x > _max) ? _max : ((_x < _min) ? _min : _x)); \
 })
 
 /*
diff --git a/include/plat/arm/common/plat_arm.h b/include/plat/arm/common/plat_arm.h
index 6c0d91d1fe..706ab1159c 100644
--- a/include/plat/arm/common/plat_arm.h
+++ b/include/plat/arm/common/plat_arm.h
@@ -125,6 +125,12 @@ void arm_setup_romlib(void);
 #define ARM_LOCAL_PSTATE_WIDTH		4
 #define ARM_LOCAL_PSTATE_MASK		((1 << ARM_LOCAL_PSTATE_WIDTH) - 1)
 
+#if PSCI_OS_INIT_MODE
+#define ARM_LAST_AT_PLVL_MASK		(ARM_LOCAL_PSTATE_MASK <<	\
+					 (ARM_LOCAL_PSTATE_WIDTH *	\
+					  (PLAT_MAX_PWR_LVL + 1)))
+#endif /* __PSCI_OS_INIT_MODE__ */
+
 /* Macros to construct the composite power state */
 
 /* Make composite power state parameter till power level 0 */
diff --git a/include/plat/common/platform.h b/include/plat/common/platform.h
index 472ed34385..078fa88f46 100644
--- a/include/plat/common/platform.h
+++ b/include/plat/common/platform.h
@@ -146,6 +146,7 @@ void plat_system_reset(void) __dead2;
 const char *plat_log_get_prefix(unsigned int log_level);
 void bl2_plat_preload_setup(void);
 int plat_try_next_boot_source(void);
+int plat_try_backup_partitions(unsigned int image_id);
 
 #if MEASURED_BOOT
 int plat_mboot_measure_image(unsigned int image_id, image_info_t *image_data);
@@ -434,5 +435,6 @@ int plat_fwu_set_metadata_image_source(unsigned int image_id,
 				       uintptr_t *image_spec);
 void plat_fwu_set_images_source(const struct fwu_metadata *metadata);
 uint32_t plat_fwu_get_boot_idx(void);
+bool plat_fwu_is_enabled(void);
 
 #endif /* PLATFORM_H */
diff --git a/lib/libc/snprintf.c b/lib/libc/snprintf.c
index c535c6ad58..21d34168fa 100644
--- a/lib/libc/snprintf.c
+++ b/lib/libc/snprintf.c
@@ -213,6 +213,7 @@ loop:
 				break;
 			case 'X':
 				capitalise = true;
+				/* fallthrough */
 			case 'x':
 				unum = get_unum_va_args(args, l_count);
 				unsigned_num_print(&s, n, &chars_printed,
diff --git a/lib/psci/aarch32/psci_helpers.S b/lib/psci/aarch32/psci_helpers.S
index 5cc192e66b..d28d469f38 100644
--- a/lib/psci/aarch32/psci_helpers.S
+++ b/lib/psci/aarch32/psci_helpers.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -143,6 +143,7 @@ endfunc do_stack_maintenance
  */
 func psci_power_down_wfi
 	dsb	sy		// ensure write buffer empty
+1:
 	wfi
-	no_ret	plat_panic_handler
+	b	1b
 endfunc psci_power_down_wfi
diff --git a/lib/psci/aarch64/psci_helpers.S b/lib/psci/aarch64/psci_helpers.S
index a557d49276..61f31e591a 100644
--- a/lib/psci/aarch64/psci_helpers.S
+++ b/lib/psci/aarch64/psci_helpers.S
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014-2018, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2014-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -128,6 +128,7 @@ func psci_power_down_wfi
 	bl apply_cpu_pwr_dwn_errata
 #endif
 	dsb	sy		// ensure write buffer empty
+1:
 	wfi
-	no_ret	plat_panic_handler
+	b	1b
 endfunc psci_power_down_wfi
diff --git a/lib/cpus/aarch64/runtime_errata.S b/lib/psci/aarch64/runtime_errata.S
similarity index 100%
rename from lib/cpus/aarch64/runtime_errata.S
rename to lib/psci/aarch64/runtime_errata.S
diff --git a/lib/psci/psci_common.c b/lib/psci/psci_common.c
index a74f10582e..6a15eb8e7e 100644
--- a/lib/psci/psci_common.c
+++ b/lib/psci/psci_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2013-2023, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -76,6 +76,14 @@ CASSERT((PLAT_MAX_PWR_LVL <= PSCI_MAX_PWR_LVL) &&
 	(PLAT_MAX_PWR_LVL >= PSCI_CPU_PWR_LVL),
 	assert_platform_max_pwrlvl_check);
 
+#if PSCI_OS_INIT_MODE
+/*******************************************************************************
+ * The power state coordination mode used in CPU_SUSPEND.
+ * Defaults to platform-coordinated mode.
+ ******************************************************************************/
+suspend_mode_t psci_suspend_mode = PLAT_COORD;
+#endif
+
 /*
  * The plat_local_state used by the platform is one of these types: RUN,
  * RETENTION and OFF. The platform can define further sub-states for each type
@@ -153,8 +161,52 @@ void psci_query_sys_suspend_pwrstate(psci_power_state_t *state_info)
 	psci_plat_pm_ops->get_sys_suspend_power_state(state_info);
 }
 
+#if PSCI_OS_INIT_MODE
+/*******************************************************************************
+ * This function verifies that all the other cores at the 'end_pwrlvl' have been
+ * idled and the current CPU is the last running CPU at the 'end_pwrlvl'.
+ * Returns 1 (true) if the current CPU is the last ON CPU or 0 (false)
+ * otherwise.
+ ******************************************************************************/
+static bool psci_is_last_cpu_to_idle_at_pwrlvl(unsigned int end_pwrlvl)
+{
+	unsigned int my_idx, lvl, parent_idx;
+	unsigned int cpu_start_idx, ncpus, cpu_idx;
+	plat_local_state_t local_state;
+
+	if (end_pwrlvl == PSCI_CPU_PWR_LVL) {
+		return true;
+	}
+
+	my_idx = plat_my_core_pos();
+	parent_idx = my_idx;
+
+	for (lvl = PSCI_CPU_PWR_LVL; lvl <= end_pwrlvl; lvl++) {
+		parent_idx = psci_cpu_pd_nodes[parent_idx].parent_node;
+	}
+
+	cpu_start_idx = psci_non_cpu_pd_nodes[parent_idx].cpu_start_idx;
+	ncpus = psci_non_cpu_pd_nodes[parent_idx].ncpus;
+
+	for (cpu_idx = cpu_start_idx; cpu_idx < cpu_start_idx + ncpus;
+			cpu_idx++) {
+		local_state = psci_get_cpu_local_state_by_idx(cpu_idx);
+		if (cpu_idx == my_idx) {
+			assert(is_local_state_run(local_state) != 0);
+			continue;
+		}
+
+		if (is_local_state_run(local_state) != 0) {
+			return false;
+		}
+	}
+
+	return true;
+}
+#endif
+
 /*******************************************************************************
- * This function verifies that the all the other cores in the system have been
+ * This function verifies that all the other cores in the system have been
  * turned OFF and the current CPU is the last running CPU in the system.
  * Returns true, if the current CPU is the last ON CPU or false otherwise.
  ******************************************************************************/
@@ -178,6 +230,23 @@ bool psci_is_last_on_cpu(void)
 	return true;
 }
 
+/*******************************************************************************
+ * This function verifies that all cores in the system have been turned ON.
+ * Returns true, if all CPUs are ON or false otherwise.
+ ******************************************************************************/
+static bool psci_are_all_cpus_on(void)
+{
+	unsigned int cpu_idx;
+
+	for (cpu_idx = 0; cpu_idx < psci_plat_core_count; cpu_idx++) {
+		if (psci_get_aff_info_state_by_idx(cpu_idx) == AFF_STATE_OFF) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
 /*******************************************************************************
  * Routine to return the maximum power level to traverse to after a cpu has
  * been physically powered up. It is expected to be called immediately after
@@ -253,6 +322,57 @@ static plat_local_state_t *psci_get_req_local_pwr_states(unsigned int pwrlvl,
 		return NULL;
 }
 
+#if PSCI_OS_INIT_MODE
+/******************************************************************************
+ * Helper function to save a copy of the psci_req_local_pwr_states (prev) for a
+ * CPU (cpu_idx), and update psci_req_local_pwr_states with the new requested
+ * local power states (state_info).
+ *****************************************************************************/
+void psci_update_req_local_pwr_states(unsigned int end_pwrlvl,
+				      unsigned int cpu_idx,
+				      psci_power_state_t *state_info,
+				      plat_local_state_t *prev)
+{
+	unsigned int lvl;
+#ifdef PLAT_MAX_CPU_SUSPEND_PWR_LVL
+	unsigned int max_pwrlvl = PLAT_MAX_CPU_SUSPEND_PWR_LVL;
+#else
+	unsigned int max_pwrlvl = PLAT_MAX_PWR_LVL;
+#endif
+	plat_local_state_t req_state;
+
+	for (lvl = PSCI_CPU_PWR_LVL + 1U; lvl <= max_pwrlvl; lvl++) {
+		/* Save the previous requested local power state */
+		prev[lvl - 1U] = *psci_get_req_local_pwr_states(lvl, cpu_idx);
+
+		/* Update the new requested local power state */
+		req_state = state_info->pwr_domain_state[lvl];
+
+		psci_set_req_local_pwr_state(lvl, cpu_idx, req_state);
+	}
+}
+
+/******************************************************************************
+ * Helper function to restore the previously saved requested local power states
+ * (prev) for a CPU (cpu_idx) to psci_req_local_pwr_states.
+ *****************************************************************************/
+void psci_restore_req_local_pwr_states(unsigned int cpu_idx,
+				       plat_local_state_t *prev)
+{
+	unsigned int lvl;
+#ifdef PLAT_MAX_CPU_SUSPEND_PWR_LVL
+	unsigned int max_pwrlvl = PLAT_MAX_CPU_SUSPEND_PWR_LVL;
+#else
+	unsigned int max_pwrlvl = PLAT_MAX_PWR_LVL;
+#endif
+
+	for (lvl = PSCI_CPU_PWR_LVL + 1U; lvl <= max_pwrlvl; lvl++) {
+		/* Restore the previous requested local power state */
+		psci_set_req_local_pwr_state(lvl, cpu_idx, prev[lvl - 1U]);
+	}
+}
+#endif
+
 /*
  * psci_non_cpu_pd_nodes can be placed either in normal memory or coherent
  * memory.
@@ -329,8 +449,8 @@ void psci_get_target_local_pwr_states(unsigned int end_pwrlvl,
  * enter. This function will be called after coordination of requested power
  * states has been done for each power level.
  *****************************************************************************/
-static void psci_set_target_local_pwr_states(unsigned int end_pwrlvl,
-					const psci_power_state_t *target_state)
+void psci_set_target_local_pwr_states(unsigned int end_pwrlvl,
+				      const psci_power_state_t *target_state)
 {
 	unsigned int parent_idx, lvl;
 	const plat_local_state_t *pd_state = target_state->pwr_domain_state;
@@ -352,7 +472,6 @@ static void psci_set_target_local_pwr_states(unsigned int end_pwrlvl,
 	}
 }
 
-
 /*******************************************************************************
  * PSCI helper function to get the parent nodes corresponding to a cpu_index.
  ******************************************************************************/
@@ -399,6 +518,8 @@ void psci_set_pwr_domains_to_run(unsigned int end_pwrlvl)
 }
 
 /******************************************************************************
+ * This function is used in platform-coordinated mode.
+ *
  * This function is passed the local power states requested for each power
  * domain (state_info) between the current CPU domain and its ancestors until
  * the target power level (end_pwrlvl). It updates the array of requested power
@@ -471,10 +592,97 @@ void psci_do_state_coordination(unsigned int end_pwrlvl,
 		state_info->pwr_domain_state[lvl] = PSCI_LOCAL_STATE_RUN;
 
 	}
+}
 
-	/* Update the target state in the power domain nodes */
-	psci_set_target_local_pwr_states(end_pwrlvl, state_info);
+#if PSCI_OS_INIT_MODE
+/******************************************************************************
+ * This function is used in OS-initiated mode.
+ *
+ * This function is passed the local power states requested for each power
+ * domain (state_info) between the current CPU domain and its ancestors until
+ * the target power level (end_pwrlvl), and ensures the requested power states
+ * are valid. It updates the array of requested power states with this
+ * information.
+ *
+ * Then, for each level (apart from the CPU level) until the 'end_pwrlvl', it
+ * retrieves the states requested by all the cpus of which the power domain at
+ * that level is an ancestor. It passes this information to the platform to
+ * coordinate and return the target power state. If the requested state does
+ * not match the target state, the request is denied.
+ *
+ * The 'state_info' is not modified.
+ *
+ * This function will only be invoked with data cache enabled and while
+ * powering down a core.
+ *****************************************************************************/
+int psci_validate_state_coordination(unsigned int end_pwrlvl,
+				     psci_power_state_t *state_info)
+{
+	int rc = PSCI_E_SUCCESS;
+	unsigned int lvl, parent_idx, cpu_idx = plat_my_core_pos();
+	unsigned int start_idx;
+	unsigned int ncpus;
+	plat_local_state_t target_state, *req_states;
+	plat_local_state_t prev[PLAT_MAX_PWR_LVL];
+
+	assert(end_pwrlvl <= PLAT_MAX_PWR_LVL);
+	parent_idx = psci_cpu_pd_nodes[cpu_idx].parent_node;
+
+	/*
+	 * Save a copy of the previous requested local power states and update
+	 * the new requested local power states.
+	 */
+	psci_update_req_local_pwr_states(end_pwrlvl, cpu_idx, state_info, prev);
+
+	for (lvl = PSCI_CPU_PWR_LVL + 1U; lvl <= end_pwrlvl; lvl++) {
+		/* Get the requested power states for this power level */
+		start_idx = psci_non_cpu_pd_nodes[parent_idx].cpu_start_idx;
+		req_states = psci_get_req_local_pwr_states(lvl, start_idx);
+
+		/*
+		 * Let the platform coordinate amongst the requested states at
+		 * this power level and return the target local power state.
+		 */
+		ncpus = psci_non_cpu_pd_nodes[parent_idx].ncpus;
+		target_state = plat_get_target_pwr_state(lvl,
+							 req_states,
+							 ncpus);
+
+		/*
+		 * Verify that the requested power state matches the target
+		 * local power state.
+		 */
+		if (state_info->pwr_domain_state[lvl] != target_state) {
+			if (target_state == PSCI_LOCAL_STATE_RUN) {
+				rc = PSCI_E_DENIED;
+			} else {
+				rc = PSCI_E_INVALID_PARAMS;
+			}
+			goto exit;
+		}
+
+		parent_idx = psci_non_cpu_pd_nodes[parent_idx].parent_node;
+	}
+
+	/*
+	 * Verify that the current core is the last running core at the
+	 * specified power level.
+	 */
+	lvl = state_info->last_at_pwrlvl;
+	if (!psci_is_last_cpu_to_idle_at_pwrlvl(lvl)) {
+		rc = PSCI_E_DENIED;
+	}
+
+exit:
+	if (rc != PSCI_E_SUCCESS) {
+		/* Restore the previous requested local power states. */
+		psci_restore_req_local_pwr_states(cpu_idx, prev);
+		return rc;
+	}
+
+	return rc;
 }
+#endif
 
 /******************************************************************************
  * This function validates a suspend request by making sure that if a standby
@@ -811,6 +1019,13 @@ void psci_warmboot_entrypoint(void)
 	else
 		psci_cpu_suspend_finish(cpu_idx, &state_info);
 
+	/*
+	 * Generic management: Now we just need to retrieve the
+	 * information that we had stashed away during the cpu_on
+	 * call to set this cpu on its way.
+	 */
+	cm_prepare_el3_exit_ns();
+
 	/*
 	 * Set the requested and target state of this CPU and all the higher
 	 * power domains which are ancestors of this CPU to run.
@@ -1039,3 +1254,29 @@ bool psci_is_last_on_cpu_safe(void)
 
 	return true;
 }
+
+/*******************************************************************************
+ * This function verifies that all cores in the system have been turned ON.
+ * Returns true, if all CPUs are ON or false otherwise.
+ *
+ * This API has following differences with psci_are_all_cpus_on
+ *  1. PSCI states are locked
+ ******************************************************************************/
+bool psci_are_all_cpus_on_safe(void)
+{
+	unsigned int this_core = plat_my_core_pos();
+	unsigned int parent_nodes[PLAT_MAX_PWR_LVL] = {0};
+
+	psci_get_parent_pwr_domain_nodes(this_core, PLAT_MAX_PWR_LVL, parent_nodes);
+
+	psci_acquire_pwr_domain_locks(PLAT_MAX_PWR_LVL, parent_nodes);
+
+	if (!psci_are_all_cpus_on()) {
+		psci_release_pwr_domain_locks(PLAT_MAX_PWR_LVL, parent_nodes);
+		return false;
+	}
+
+	psci_release_pwr_domain_locks(PLAT_MAX_PWR_LVL, parent_nodes);
+
+	return true;
+}
diff --git a/lib/psci/psci_lib.mk b/lib/psci/psci_lib.mk
index 6864202d81..c71580f950 100644
--- a/lib/psci/psci_lib.mk
+++ b/lib/psci/psci_lib.mk
@@ -22,7 +22,7 @@ PSCI_LIB_SOURCES	:=	lib/el3_runtime/cpu_data_array.c	\
 
 ifeq (${ARCH}, aarch64)
 PSCI_LIB_SOURCES	+=	lib/el3_runtime/aarch64/context.S	\
-				lib/cpus/aarch64/runtime_errata.S
+				lib/psci/aarch64/runtime_errata.S
 endif
 
 ifeq (${USE_COHERENT_MEM}, 1)
diff --git a/lib/psci/psci_main.c b/lib/psci/psci_main.c
index 31b1d1cf3e..5540f34e05 100644
--- a/lib/psci/psci_main.c
+++ b/lib/psci/psci_main.c
@@ -59,6 +59,10 @@ int psci_cpu_suspend(unsigned int power_state,
 	entry_point_info_t ep;
 	psci_power_state_t state_info = { {PSCI_LOCAL_STATE_RUN} };
 	plat_local_state_t cpu_pd_state;
+#if PSCI_OS_INIT_MODE
+	unsigned int cpu_idx = plat_my_core_pos();
+	plat_local_state_t prev[PLAT_MAX_PWR_LVL];
+#endif
 
 	/* Validate the power_state parameter */
 	rc = psci_validate_power_state(power_state, &state_info);
@@ -94,6 +98,18 @@ int psci_cpu_suspend(unsigned int power_state,
 		cpu_pd_state = state_info.pwr_domain_state[PSCI_CPU_PWR_LVL];
 		psci_set_cpu_local_state(cpu_pd_state);
 
+#if PSCI_OS_INIT_MODE
+		/*
+		 * If in OS-initiated mode, save a copy of the previous
+		 * requested local power states and update the new requested
+		 * local power states for this CPU.
+		 */
+		if (psci_suspend_mode == OS_INIT) {
+			psci_update_req_local_pwr_states(target_pwrlvl, cpu_idx,
+							 &state_info, prev);
+		}
+#endif
+
 #if ENABLE_PSCI_STAT
 		plat_psci_stat_accounting_start(&state_info);
 #endif
@@ -109,6 +125,16 @@ int psci_cpu_suspend(unsigned int power_state,
 		/* Upon exit from standby, set the state back to RUN. */
 		psci_set_cpu_local_state(PSCI_LOCAL_STATE_RUN);
 
+#if PSCI_OS_INIT_MODE
+		/*
+		 * If in OS-initiated mode, restore the previous requested
+		 * local power states for this CPU.
+		 */
+		if (psci_suspend_mode == OS_INIT) {
+			psci_restore_req_local_pwr_states(cpu_idx, prev);
+		}
+#endif
+
 #if ENABLE_RUNTIME_INSTRUMENTATION
 		PMF_CAPTURE_TIMESTAMP(rt_instr_svc,
 		    RT_INSTR_EXIT_HW_LOW_PWR,
@@ -141,12 +167,12 @@ int psci_cpu_suspend(unsigned int power_state,
 	 * might return if the power down was abandoned for any reason, e.g.
 	 * arrival of an interrupt
 	 */
-	psci_cpu_suspend_start(&ep,
-			    target_pwrlvl,
-			    &state_info,
-			    is_power_down_state);
+	rc = psci_cpu_suspend_start(&ep,
+				    target_pwrlvl,
+				    &state_info,
+				    is_power_down_state);
 
-	return PSCI_E_SUCCESS;
+	return rc;
 }
 
 
@@ -155,6 +181,12 @@ int psci_system_suspend(uintptr_t entrypoint, u_register_t context_id)
 	int rc;
 	psci_power_state_t state_info;
 	entry_point_info_t ep;
+	unsigned int pwrlvl;
+#ifdef PLAT_MIN_SUSPEND_PWR_LVL
+	unsigned int min_pwrlvl = PLAT_MIN_SUSPEND_PWR_LVL;
+#else
+	unsigned int min_pwrlvl = PLAT_MAX_PWR_LVL;
+#endif
 
 	/* Check if the current CPU is the last ON CPU in the system */
 	if (!psci_is_last_on_cpu())
@@ -172,32 +204,39 @@ int psci_system_suspend(uintptr_t entrypoint, u_register_t context_id)
 	 * Check if platform allows suspend to Highest power level
 	 * (System level)
 	 */
-	if (psci_find_target_suspend_lvl(&state_info) < PLAT_MAX_PWR_LVL)
+	pwrlvl = psci_find_target_suspend_lvl(&state_info);
+	if (pwrlvl < min_pwrlvl)
 		return PSCI_E_DENIED;
 
 	/* Ensure that the psci_power_state makes sense */
 	assert(psci_validate_suspend_req(&state_info, PSTATE_TYPE_POWERDOWN)
 						== PSCI_E_SUCCESS);
+#ifndef PLAT_MIN_SUSPEND_PWR_LVL
 	assert(is_local_state_off(
 			state_info.pwr_domain_state[PLAT_MAX_PWR_LVL]) != 0);
-
+#endif
 	/*
 	 * Do what is needed to enter the system suspend state. This function
 	 * might return if the power down was abandoned for any reason, e.g.
 	 * arrival of an interrupt
 	 */
-	psci_cpu_suspend_start(&ep,
-			    PLAT_MAX_PWR_LVL,
-			    &state_info,
-			    PSTATE_TYPE_POWERDOWN);
+	rc = psci_cpu_suspend_start(&ep,
+				    pwrlvl,
+				    &state_info,
+				    PSTATE_TYPE_POWERDOWN);
 
-	return PSCI_E_SUCCESS;
+	return rc;
 }
 
 int psci_cpu_off(void)
 {
 	int rc;
+#if PSCI_OS_INIT_MODE
+	/* When coordination is done by OS, only update local state for CORE */
+	unsigned int target_pwrlvl = PSCI_CPU_PWR_LVL;
+#else
 	unsigned int target_pwrlvl = PLAT_MAX_PWR_LVL;
+#endif
 
 	/*
 	 * Do what is needed to power off this CPU and possible higher power
@@ -357,19 +396,48 @@ int psci_features(unsigned int psci_fid)
 	/* Format the feature flags */
 	if ((psci_fid == PSCI_CPU_SUSPEND_AARCH32) ||
 	    (psci_fid == PSCI_CPU_SUSPEND_AARCH64)) {
-		/*
-		 * The trusted firmware does not support OS Initiated Mode.
-		 */
 		unsigned int ret = ((FF_PSTATE << FF_PSTATE_SHIFT) |
-			(((FF_SUPPORTS_OS_INIT_MODE == 1U) ? 0U : 1U)
-				<< FF_MODE_SUPPORT_SHIFT));
-		return (int) ret;
+			(FF_SUPPORTS_OS_INIT_MODE << FF_MODE_SUPPORT_SHIFT));
+		return (int)ret;
 	}
 
 	/* Return 0 for all other fid's */
 	return PSCI_E_SUCCESS;
 }
 
+#if PSCI_OS_INIT_MODE
+int psci_set_suspend_mode(unsigned int mode)
+{
+	if (psci_suspend_mode == mode) {
+		return PSCI_E_SUCCESS;
+	}
+
+	if (mode == PLAT_COORD) {
+		/* Check if the current CPU is the last ON CPU in the system */
+		if (!psci_is_last_on_cpu_safe()) {
+			return PSCI_E_DENIED;
+		}
+	}
+
+	if (mode == OS_INIT) {
+		/*
+		 * Check if all CPUs in the system are ON or if the current
+		 * CPU is the last ON CPU in the system.
+		 */
+		if (!(psci_are_all_cpus_on_safe() ||
+		      psci_is_last_on_cpu_safe())) {
+			return PSCI_E_DENIED;
+		}
+	}
+
+	psci_suspend_mode = mode;
+	psci_flush_dcache_range((uintptr_t)&psci_suspend_mode,
+				sizeof(psci_suspend_mode));
+
+	return PSCI_E_SUCCESS;
+}
+#endif
+
 /*******************************************************************************
  * PSCI top level handler for servicing SMCs.
  ******************************************************************************/
@@ -453,6 +521,12 @@ u_register_t psci_smc_handler(uint32_t smc_fid,
 			ret = (u_register_t)psci_features(r1);
 			break;
 
+#if PSCI_OS_INIT_MODE
+		case PSCI_SET_SUSPEND_MODE:
+			ret = (u_register_t)psci_set_suspend_mode(r1);
+			break;
+#endif
+
 #if ENABLE_PSCI_STAT
 		case PSCI_STAT_RESIDENCY_AARCH32:
 			ret = psci_stat_residency(r1, r2);
diff --git a/lib/psci/psci_off.c b/lib/psci/psci_off.c
index 637adb97e1..f83753fc9e 100644
--- a/lib/psci/psci_off.c
+++ b/lib/psci/psci_off.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2019, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2023, NVIDIA Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -56,6 +57,19 @@ int psci_do_cpu_off(unsigned int end_pwrlvl)
 	/* Construct the psci_power_state for CPU_OFF */
 	psci_set_power_off_state(&state_info);
 
+	/*
+	 * Call the platform provided early CPU_OFF handler to allow
+	 * platforms to perform any housekeeping activities before
+	 * actually powering the CPU off. PSCI_E_DENIED indicates that
+	 * the CPU off sequence should be aborted at this time.
+	 */
+	if (psci_plat_pm_ops->pwr_domain_off_early) {
+		rc = psci_plat_pm_ops->pwr_domain_off_early(&state_info);
+		if (rc == PSCI_E_DENIED) {
+			return rc;
+		}
+	}
+
 	/*
 	 * Get the parent nodes here, this is important to do before we
 	 * initiate the power down sequence as after that point the core may
@@ -90,6 +104,9 @@ int psci_do_cpu_off(unsigned int end_pwrlvl)
 	 */
 	psci_do_state_coordination(end_pwrlvl, &state_info);
 
+	/* Update the target state in the power domain nodes */
+	psci_set_target_local_pwr_states(end_pwrlvl, &state_info);
+
 #if ENABLE_PSCI_STAT
 	/* Update the last cpu for each level till end_pwrlvl */
 	psci_stats_update_pwr_down(end_pwrlvl, &state_info);
diff --git a/lib/psci/psci_on.c b/lib/psci/psci_on.c
index a5929e099a..8a271c5ed4 100644
--- a/lib/psci/psci_on.c
+++ b/lib/psci/psci_on.c
@@ -217,11 +217,4 @@ void psci_cpu_on_finish(unsigned int cpu_idx, const psci_power_state_t *state_in
 	/* Populate the mpidr field within the cpu node array */
 	/* This needs to be done only once */
 	psci_cpu_pd_nodes[cpu_idx].mpidr = read_mpidr() & MPIDR_AFFINITY_MASK;
-
-	/*
-	 * Generic management: Now we just need to retrieve the
-	 * information that we had stashed away during the cpu_on
-	 * call to set this cpu on its way.
-	 */
-	cm_prepare_el3_exit_ns();
 }
diff --git a/lib/psci/psci_private.h b/lib/psci/psci_private.h
index 8a1e7c46b8..2eb4a9b705 100644
--- a/lib/psci/psci_private.h
+++ b/lib/psci/psci_private.h
@@ -163,6 +163,16 @@ typedef struct cpu_pwr_domain_node {
 	spinlock_t cpu_lock;
 } cpu_pd_node_t;
 
+#if PSCI_OS_INIT_MODE
+/*******************************************************************************
+ * The supported power state coordination modes that can be used in CPU_SUSPEND.
+ ******************************************************************************/
+typedef enum suspend_mode {
+	PLAT_COORD = 0,
+	OS_INIT = 1
+} suspend_mode_t;
+#endif
+
 /*******************************************************************************
  * The following are helpers and declarations of locks.
  ******************************************************************************/
@@ -260,6 +270,9 @@ extern non_cpu_pd_node_t psci_non_cpu_pd_nodes[PSCI_NUM_NON_CPU_PWR_DOMAINS];
 extern cpu_pd_node_t psci_cpu_pd_nodes[PLATFORM_CORE_COUNT];
 extern unsigned int psci_caps;
 extern unsigned int psci_plat_core_count;
+#if PSCI_OS_INIT_MODE
+extern suspend_mode_t psci_suspend_mode;
+#endif
 
 /*******************************************************************************
  * SPD's power management hooks registered with PSCI
@@ -274,8 +287,18 @@ int psci_validate_power_state(unsigned int power_state,
 			      psci_power_state_t *state_info);
 void psci_query_sys_suspend_pwrstate(psci_power_state_t *state_info);
 void psci_init_req_local_pwr_states(void);
+#if PSCI_OS_INIT_MODE
+void psci_update_req_local_pwr_states(unsigned int end_pwrlvl,
+				      unsigned int cpu_idx,
+				      psci_power_state_t *state_info,
+				      plat_local_state_t *prev);
+void psci_restore_req_local_pwr_states(unsigned int cpu_idx,
+				       plat_local_state_t *prev);
+#endif
 void psci_get_target_local_pwr_states(unsigned int end_pwrlvl,
 				      psci_power_state_t *target_state);
+void psci_set_target_local_pwr_states(unsigned int end_pwrlvl,
+				      const psci_power_state_t *target_state);
 int psci_validate_entry_point(entry_point_info_t *ep,
 			uintptr_t entrypoint, u_register_t context_id);
 void psci_get_parent_pwr_domain_nodes(unsigned int cpu_idx,
@@ -283,6 +306,10 @@ void psci_get_parent_pwr_domain_nodes(unsigned int cpu_idx,
 				      unsigned int *node_index);
 void psci_do_state_coordination(unsigned int end_pwrlvl,
 				psci_power_state_t *state_info);
+#if PSCI_OS_INIT_MODE
+int psci_validate_state_coordination(unsigned int end_pwrlvl,
+				     psci_power_state_t *state_info);
+#endif
 void psci_acquire_pwr_domain_locks(unsigned int end_pwrlvl,
 				   const unsigned int *parent_nodes);
 void psci_release_pwr_domain_locks(unsigned int end_pwrlvl,
@@ -316,10 +343,10 @@ void psci_cpu_on_finish(unsigned int cpu_idx, const psci_power_state_t *state_in
 int psci_do_cpu_off(unsigned int end_pwrlvl);
 
 /* Private exported functions from psci_suspend.c */
-void psci_cpu_suspend_start(const entry_point_info_t *ep,
-			unsigned int end_pwrlvl,
-			psci_power_state_t *state_info,
-			unsigned int is_power_down_state);
+int psci_cpu_suspend_start(const entry_point_info_t *ep,
+			   unsigned int end_pwrlvl,
+			   psci_power_state_t *state_info,
+			   unsigned int is_power_down_state);
 
 void psci_cpu_suspend_finish(unsigned int cpu_idx, const psci_power_state_t *state_info);
 
diff --git a/lib/psci/psci_setup.c b/lib/psci/psci_setup.c
index eb074689b8..1f93cc9f59 100644
--- a/lib/psci/psci_setup.c
+++ b/lib/psci/psci_setup.c
@@ -254,6 +254,9 @@ int __init psci_setup(const psci_lib_args_t *lib_args)
 			psci_caps |=  define_psci_cap(PSCI_CPU_SUSPEND_AARCH64);
 		if (psci_plat_pm_ops->get_sys_suspend_power_state != NULL)
 			psci_caps |=  define_psci_cap(PSCI_SYSTEM_SUSPEND_AARCH64);
+#if PSCI_OS_INIT_MODE
+		psci_caps |= define_psci_cap(PSCI_SET_SUSPEND_MODE);
+#endif
 	}
 	if (psci_plat_pm_ops->system_off != NULL)
 		psci_caps |=  define_psci_cap(PSCI_SYSTEM_OFF);
diff --git a/lib/psci/psci_suspend.c b/lib/psci/psci_suspend.c
index f71994d71c..cb12b83517 100644
--- a/lib/psci/psci_suspend.c
+++ b/lib/psci/psci_suspend.c
@@ -75,6 +75,14 @@ static void psci_suspend_to_pwrdown_start(unsigned int end_pwrlvl,
 
 	PUBLISH_EVENT(psci_suspend_pwrdown_start);
 
+#if PSCI_OS_INIT_MODE
+#ifdef PLAT_MAX_CPU_SUSPEND_PWR_LVL
+	end_pwrlvl = PLAT_MAX_CPU_SUSPEND_PWR_LVL;
+#else
+	end_pwrlvl = PLAT_MAX_PWR_LVL;
+#endif
+#endif
+
 	/* Save PSCI target power level for the suspend finisher handler */
 	psci_set_suspend_pwrlvl(end_pwrlvl);
 
@@ -151,12 +159,13 @@ static void psci_suspend_to_pwrdown_start(unsigned int end_pwrlvl,
  * the state transition has been done, no further error is expected and it is
  * not possible to undo any of the actions taken beyond that point.
  ******************************************************************************/
-void psci_cpu_suspend_start(const entry_point_info_t *ep,
-			    unsigned int end_pwrlvl,
-			    psci_power_state_t *state_info,
-			    unsigned int is_power_down_state)
+int psci_cpu_suspend_start(const entry_point_info_t *ep,
+			   unsigned int end_pwrlvl,
+			   psci_power_state_t *state_info,
+			   unsigned int is_power_down_state)
 {
-	int skip_wfi = 0;
+	int rc = PSCI_E_SUCCESS;
+	bool skip_wfi = false;
 	unsigned int idx = plat_my_core_pos();
 	unsigned int parent_nodes[PLAT_MAX_PWR_LVL] = {0};
 
@@ -183,16 +192,45 @@ void psci_cpu_suspend_start(const entry_point_info_t *ep,
 	 * detection that a wake-up interrupt has fired.
 	 */
 	if (read_isr_el1() != 0U) {
-		skip_wfi = 1;
+		skip_wfi = true;
 		goto exit;
 	}
 
-	/*
-	 * This function is passed the requested state info and
-	 * it returns the negotiated state info for each power level upto
-	 * the end level specified.
-	 */
-	psci_do_state_coordination(end_pwrlvl, state_info);
+#if PSCI_OS_INIT_MODE
+	if (psci_suspend_mode == OS_INIT) {
+		/*
+		 * This function validates the requested state info for
+		 * OS-initiated mode.
+		 */
+		rc = psci_validate_state_coordination(end_pwrlvl, state_info);
+		if (rc != PSCI_E_SUCCESS) {
+			skip_wfi = true;
+			goto exit;
+		}
+	} else {
+#endif
+		/*
+		 * This function is passed the requested state info and
+		 * it returns the negotiated state info for each power level upto
+		 * the end level specified.
+		 */
+		psci_do_state_coordination(end_pwrlvl, state_info);
+#if PSCI_OS_INIT_MODE
+	}
+#endif
+
+#if PSCI_OS_INIT_MODE
+	if (psci_plat_pm_ops->pwr_domain_validate_suspend != NULL) {
+		rc = psci_plat_pm_ops->pwr_domain_validate_suspend(state_info);
+		if (rc != PSCI_E_SUCCESS) {
+			skip_wfi = true;
+			goto exit;
+		}
+	}
+#endif
+
+	/* Update the target state in the power domain nodes */
+	psci_set_target_local_pwr_states(end_pwrlvl, state_info);
 
 #if ENABLE_PSCI_STAT
 	/* Update the last cpu for each level till end_pwrlvl */
@@ -208,6 +246,7 @@ void psci_cpu_suspend_start(const entry_point_info_t *ep,
 	 * platform defined mailbox with the psci entrypoint,
 	 * program the power controller etc.
 	 */
+
 	psci_plat_pm_ops->pwr_domain_suspend(state_info);
 
 #if ENABLE_PSCI_STAT
@@ -221,8 +260,9 @@ exit:
 	 */
 	psci_release_pwr_domain_locks(end_pwrlvl, parent_nodes);
 
-	if (skip_wfi == 1)
-		return;
+	if (skip_wfi) {
+		return rc;
+	}
 
 	if (is_power_down_state != 0U) {
 #if ENABLE_RUNTIME_INSTRUMENTATION
@@ -269,6 +309,8 @@ exit:
 	 * context retaining suspend finisher.
 	 */
 	psci_suspend_to_standby_finisher(idx, end_pwrlvl);
+
+	return rc;
 }
 
 /*******************************************************************************
@@ -325,11 +367,4 @@ void psci_cpu_suspend_finish(unsigned int cpu_idx, const psci_power_state_t *sta
 	psci_set_suspend_pwrlvl(PSCI_INVALID_PWR_LVL);
 
 	PUBLISH_EVENT(psci_suspend_pwrdown_finish);
-
-	/*
-	 * Generic management: Now we just need to retrieve the
-	 * information that we had stashed away during the suspend
-	 * call to set this cpu on its way.
-	 */
-	cm_prepare_el3_exit_ns();
 }
diff --git a/make_helpers/build_macros.mk b/make_helpers/build_macros.mk
index 840714dde0..251e23f6a3 100644
--- a/make_helpers/build_macros.mk
+++ b/make_helpers/build_macros.mk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2015-2022, Arm Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2023, Arm Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -72,6 +72,7 @@ endef
 # Convenience function for verifying option has a boolean value
 # $(eval $(call assert_boolean,FOO)) will assert FOO is 0 or 1
 define assert_boolean
+    $(if $($(1)),,$(error $(1) must not be empty))
     $(if $(filter-out 0 1,$($1)),$(error $1 must be boolean))
 endef
 
@@ -167,6 +168,16 @@ $(2): $(1) enctool
 	$$(Q)$$(ENCTOOL) $$(ENC_ARGS) -i $$< -o $$@
 endef
 
+# GEN_METADATA
+define GEN_METADATA
+$(dir $(2)):
+	$$(Q)mkdir -p $$(dir $(2))
+
+$(2): $(1) | $(dir $(2))
+	$$(ECHO) "  GEN_METADATA     $$<"
+	$$(Q)$$(FWUMDTOOL) $$(FWUMD_ARGS) jsonparse $$< -b $$@
+endef
+
 # TOOL_ADD_PAYLOAD appends the command line arguments required by fiptool to
 # package a new payload and/or by cert_create to generate certificate.
 # Optionally, it adds the dependency on this payload
diff --git a/make_helpers/defaults.mk b/make_helpers/defaults.mk
index d9c6483bb0..886cf2e0eb 100644
--- a/make_helpers/defaults.mk
+++ b/make_helpers/defaults.mk
@@ -259,6 +259,9 @@ PROGRAMMABLE_RESET_ADDRESS	:= 0
 # Flag used to choose the power state format: Extended State-ID or Original
 PSCI_EXTENDED_STATE_ID		:= 0
 
+# Enable PSCI OS-initiated mode support
+PSCI_OS_INIT_MODE		:= 0
+
 # Enable RAS support
 RAS_EXTENSION			:= 0
 
@@ -453,6 +456,14 @@ NR_OF_IMAGES_IN_FW_BANK		:= 1
 # Disable Firmware update support by default
 PSA_FWU_SUPPORT			:= 0
 
+# Enable image description in FWU metadata by default when PSA_FWU_SUPPORT
+# is enabled.
+ifeq ($(PSA_FWU_SUPPORT),1)
+PSA_FWU_METADATA_FW_STORE_DESC	:= 1
+else
+PSA_FWU_METADATA_FW_STORE_DESC	:= 0
+endif
+
 # By default, disable access of trace buffer control registers from NS
 # lower ELs  i.e. NS-EL2, or NS-EL1 if NS-EL2 implemented but unused
 # if FEAT_TRBE is implemented.
diff --git a/plat/arm/board/fvp/fvp_pm.c b/plat/arm/board/fvp/fvp_pm.c
index 6b9d6184ca..d0c3f2bb11 100644
--- a/plat/arm/board/fvp/fvp_pm.c
+++ b/plat/arm/board/fvp/fvp_pm.c
@@ -269,6 +269,8 @@ static void fvp_pwr_domain_suspend(const psci_power_state_t *target_state)
 
 	/* Program the power controller to power off this cpu. */
 	fvp_pwrc_write_ppoffr(read_mpidr_el1());
+
+	return;
 }
 
 /*******************************************************************************
diff --git a/plat/arm/board/fvp/include/platform_def.h b/plat/arm/board/fvp/include/platform_def.h
index 7559fd2d85..248be0cb01 100644
--- a/plat/arm/board/fvp/include/platform_def.h
+++ b/plat/arm/board/fvp/include/platform_def.h
@@ -26,6 +26,10 @@
 
 #define PLAT_MAX_PWR_LVL		ARM_PWR_LVL2
 
+#if PSCI_OS_INIT_MODE
+#define PLAT_MAX_CPU_SUSPEND_PWR_LVL	ARM_PWR_LVL1
+#endif
+
 /*
  * Other platform porting definitions are provided by included headers
  */
diff --git a/plat/arm/board/fvp/platform.mk b/plat/arm/board/fvp/platform.mk
index 2a7d4c905a..20c4267a14 100644
--- a/plat/arm/board/fvp/platform.mk
+++ b/plat/arm/board/fvp/platform.mk
@@ -455,6 +455,8 @@ ifeq (${SPMC_AT_EL3}, 1)
 PLAT_BL_COMMON_SOURCES	+=	plat/arm/board/fvp/fvp_el3_spmc.c
 endif
 
+PSCI_OS_INIT_MODE	:=	1
+
 ifeq (${ERRATA_ABI_SUPPORT}, 1)
 include plat/arm/board/fvp/fvp_cpu_errata.mk
 endif
diff --git a/plat/arm/board/tc/platform.mk b/plat/arm/board/tc/platform.mk
index 672b6d43d9..fb31bb2c82 100644
--- a/plat/arm/board/tc/platform.mk
+++ b/plat/arm/board/tc/platform.mk
@@ -1,4 +1,4 @@
-# Copyright (c) 2021-2022, Arm Limited. All rights reserved.
+# Copyright (c) 2021-2023, Arm Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
diff --git a/plat/arm/common/arm_io_storage.c b/plat/arm/common/arm_io_storage.c
index 19ee1b0b05..aa44903ff1 100644
--- a/plat/arm/common/arm_io_storage.c
+++ b/plat/arm/common/arm_io_storage.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2021, ARM Limited. All rights reserved.
+ * Copyright (c) 2015-2022, ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -247,4 +247,9 @@ int plat_fwu_set_metadata_image_source(unsigned int image_id,
 
 	return result;
 }
+
+bool plat_fwu_is_enabled(void)
+{
+	return true;
+}
 #endif /* PSA_FWU_SUPPORT */
diff --git a/plat/arm/common/arm_pm.c b/plat/arm/common/arm_pm.c
index 5434c94571..4bd22a3d9c 100644
--- a/plat/arm/common/arm_pm.c
+++ b/plat/arm/common/arm_pm.c
@@ -79,7 +79,12 @@ int arm_validate_power_state(unsigned int power_state,
 	 *  search if the number of entries justify the additional complexity.
 	 */
 	for (i = 0; !!arm_pm_idle_states[i]; i++) {
+#if PSCI_OS_INIT_MODE
+		if ((power_state & ~ARM_LAST_AT_PLVL_MASK) ==
+					arm_pm_idle_states[i])
+#else
 		if (power_state == arm_pm_idle_states[i])
+#endif /* __PSCI_OS_INIT_MODE__ */
 			break;
 	}
 
@@ -91,11 +96,14 @@ int arm_validate_power_state(unsigned int power_state,
 	state_id = psci_get_pstate_id(power_state);
 
 	/* Parse the State ID and populate the state info parameter */
-	while (state_id) {
-		req_state->pwr_domain_state[i++] = state_id &
+	for (i = ARM_PWR_LVL0; i <= PLAT_MAX_PWR_LVL; i++) {
+		req_state->pwr_domain_state[i] = state_id &
 						ARM_LOCAL_PSTATE_MASK;
 		state_id >>= ARM_LOCAL_PSTATE_WIDTH;
 	}
+#if PSCI_OS_INIT_MODE
+	req_state->last_at_pwrlvl = state_id & ARM_LOCAL_PSTATE_MASK;
+#endif /* __PSCI_OS_INIT_MODE__ */
 
 	return PSCI_E_SUCCESS;
 }
diff --git a/plat/common/plat_bl_common.c b/plat/common/plat_bl_common.c
index 89b77ba6ce..cdf5a26d02 100644
--- a/plat/common/plat_bl_common.c
+++ b/plat/common/plat_bl_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2018-2022, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -25,6 +25,7 @@
 #pragma weak bl2_plat_handle_pre_image_load
 #pragma weak bl2_plat_handle_post_image_load
 #pragma weak plat_try_next_boot_source
+#pragma weak plat_try_backup_partitions
 #pragma weak plat_get_enc_key_info
 #pragma weak plat_is_smccc_feature_available
 #pragma weak plat_get_soc_version
@@ -74,6 +75,11 @@ int plat_try_next_boot_source(void)
 	return 0;
 }
 
+int plat_try_backup_partitions(unsigned int image_id)
+{
+	return 0;
+}
+
 /*
  * Weak implementation to provide dummy decryption key only for test purposes,
  * platforms must override this API for any real world firmware encryption
diff --git a/plat/imx/common/imx_sip_handler.c b/plat/imx/common/imx_sip_handler.c
index d4b3425af9..ec8631a4fe 100644
--- a/plat/imx/common/imx_sip_handler.c
+++ b/plat/imx/common/imx_sip_handler.c
@@ -20,7 +20,7 @@
 #if defined(PLAT_imx8qm) || defined(PLAT_imx8qx)
 
 #ifdef PLAT_imx8qm
-const static int ap_cluster_index[PLATFORM_CLUSTER_COUNT] = {
+static const int ap_cluster_index[PLATFORM_CLUSTER_COUNT] = {
 	SC_R_A53, SC_R_A72,
 };
 #endif
diff --git a/plat/imx/imx8qm/imx8qm_bl31_setup.c b/plat/imx/imx8qm/imx8qm_bl31_setup.c
index 68eb53422a..bd7896a997 100644
--- a/plat/imx/imx8qm/imx8qm_bl31_setup.c
+++ b/plat/imx/imx8qm/imx8qm_bl31_setup.c
@@ -62,7 +62,7 @@ static entry_point_info_t bl33_image_ep_info;
 #error "Provide proper UART number in IMX_DEBUG_UART"
 #endif
 
-const static int imx8qm_cci_map[] = {
+static const int imx8qm_cci_map[] = {
 	CLUSTER0_CCI_SLVAE_IFACE,
 	CLUSTER1_CCI_SLVAE_IFACE
 };
diff --git a/plat/imx/imx8qm/imx8qm_psci.c b/plat/imx/imx8qm/imx8qm_psci.c
index bdba37c6eb..dcc502ff89 100644
--- a/plat/imx/imx8qm/imx8qm_psci.c
+++ b/plat/imx/imx8qm/imx8qm_psci.c
@@ -26,7 +26,7 @@
 #define SYSTEM_PWR_STATE(state) \
 	((state)->pwr_domain_state[PLAT_MAX_PWR_LVL])
 
-const static int ap_core_index[PLATFORM_CORE_COUNT] = {
+static const int ap_core_index[PLATFORM_CORE_COUNT] = {
 	SC_R_A53_0, SC_R_A53_1, SC_R_A53_2,
 	SC_R_A53_3, SC_R_A72_0, SC_R_A72_1,
 };
diff --git a/plat/imx/imx8qx/imx8qx_psci.c b/plat/imx/imx8qx/imx8qx_psci.c
index aab3a2dae8..5f0556665e 100644
--- a/plat/imx/imx8qx/imx8qx_psci.c
+++ b/plat/imx/imx8qx/imx8qx_psci.c
@@ -18,7 +18,7 @@
 
 #include "../../common/sci/imx8_mu.h"
 
-const static int ap_core_index[PLATFORM_CORE_COUNT] = {
+static const int ap_core_index[PLATFORM_CORE_COUNT] = {
 	SC_R_A35_0, SC_R_A35_1, SC_R_A35_2, SC_R_A35_3
 };
 
diff --git a/plat/mediatek/common/mtk_smc_handlers.c b/plat/mediatek/common/mtk_smc_handlers.c
index 51a960fc3d..92b3873c33 100644
--- a/plat/mediatek/common/mtk_smc_handlers.c
+++ b/plat/mediatek/common/mtk_smc_handlers.c
@@ -51,6 +51,7 @@
 		x3 = x3 & MASK_32_BIT; \
 		x4 = x4 & MASK_32_BIT; \
 	} \
+	/* fallthrough */ \
 	case _smc_id##_AARCH64: \
 	{ \
 		if (_smc_id##_descriptor_index < 0) { \
diff --git a/plat/nvidia/tegra/soc/t186/plat_memctrl.c b/plat/nvidia/tegra/soc/t186/plat_memctrl.c
index 81de674bc6..253301304f 100644
--- a/plat/nvidia/tegra/soc/t186/plat_memctrl.c
+++ b/plat/nvidia/tegra/soc/t186/plat_memctrl.c
@@ -20,7 +20,7 @@ extern uint64_t tegra_bl31_phys_base;
 /*******************************************************************************
  * Array to hold stream_id override config register offsets
  ******************************************************************************/
-const static uint32_t tegra186_streamid_override_regs[] = {
+static const uint32_t tegra186_streamid_override_regs[] = {
 	MC_STREAMID_OVERRIDE_CFG_SDMMCRA,
 	MC_STREAMID_OVERRIDE_CFG_SDMMCRAA,
 	MC_STREAMID_OVERRIDE_CFG_SDMMCR,
@@ -34,7 +34,7 @@ const static uint32_t tegra186_streamid_override_regs[] = {
 /*******************************************************************************
  * Array to hold the security configs for stream IDs
  ******************************************************************************/
-const static mc_streamid_security_cfg_t tegra186_streamid_sec_cfgs[] = {
+static const mc_streamid_security_cfg_t tegra186_streamid_sec_cfgs[] = {
 	mc_make_sec_cfg(SCEW, NON_SECURE, NO_OVERRIDE, DISABLE),
 	mc_make_sec_cfg(AFIR, NON_SECURE, OVERRIDE, DISABLE),
 	mc_make_sec_cfg(AFIW, NON_SECURE, OVERRIDE, DISABLE),
@@ -112,7 +112,7 @@ const static mc_streamid_security_cfg_t tegra186_streamid_sec_cfgs[] = {
 /*******************************************************************************
  * Array to hold the transaction override configs
  ******************************************************************************/
-const static mc_txn_override_cfg_t tegra186_txn_override_cfgs[] = {
+static const mc_txn_override_cfg_t tegra186_txn_override_cfgs[] = {
 	mc_make_txn_override_cfg(BPMPW, CGID_TAG_ADR),
 	mc_make_txn_override_cfg(EQOSW, CGID_TAG_ADR),
 	mc_make_txn_override_cfg(NVJPGSWR, CGID_TAG_ADR),
diff --git a/plat/nxp/common/fip_handler/ddr_fip/ddr_fip_io.mk b/plat/nxp/common/fip_handler/ddr_fip/ddr_fip_io.mk
index 7d673ba545..36c07b7359 100644
--- a/plat/nxp/common/fip_handler/ddr_fip/ddr_fip_io.mk
+++ b/plat/nxp/common/fip_handler/ddr_fip/ddr_fip_io.mk
@@ -1,5 +1,6 @@
 #
 # Copyright 2020 NXP
+# Copyright (c) 2023, Arm Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -22,8 +23,6 @@ PLAT_INCLUDES		+= -I${FIP_HANDLER_COMMON_PATH}\
 
 DDR_FIP_IO_SOURCES	+= $(DDR_FIP_IO_STORAGE_PATH)/ddr_io_storage.c
 
-$(shell cp tools/nxp/plat_fiptool/plat_fiptool.mk ${PLAT_DIR})
-
 ifeq (${BL_COMM_DDR_FIP_IO_NEEDED},yes)
 BL_COMMON_SOURCES	+= ${DDR_FIP_IO_SOURCES}
 else
diff --git a/plat/nxp/common/fip_handler/fuse_fip/fuse.mk b/plat/nxp/common/fip_handler/fuse_fip/fuse.mk
index d8f5ae6ad9..4e84d02069 100644
--- a/plat/nxp/common/fip_handler/fuse_fip/fuse.mk
+++ b/plat/nxp/common/fip_handler/fuse_fip/fuse.mk
@@ -1,5 +1,6 @@
 #
 # Copyright 2018-2020 NXP
+# Copyright (c) 2023, Arm Limited. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -29,8 +30,6 @@ fip_fuse: ${BUILD_PLAT}/${FUSE_FIP_NAME}
 
 ifeq (${FUSE_PROV_FILE},)
 
-$(shell cp tools/nxp/plat_fiptool/plat_fiptool.mk ${PLAT_DIR})
-
 else
 ifeq (${TRUSTED_BOARD_BOOT},1)
 FUSE_PROV_FILE_SB = $(notdir ${FUSE_PROV_FILE})_prov.sb
diff --git a/plat/nxp/common/psci/plat_psci.c b/plat/nxp/common/psci/plat_psci.c
index 9281e97cbc..f6dd7b30ef 100644
--- a/plat/nxp/common/psci/plat_psci.c
+++ b/plat/nxp/common/psci/plat_psci.c
@@ -350,7 +350,7 @@ static int _pwr_state_validate(uint32_t pwr_state,
 		else if (SOC_SYSTEM_STANDBY)
 			state->pwr_domain_state[PLAT_MAX_LVL] =
 				PLAT_MAX_RET_STATE;
-		 /* intentional fall-thru condition */
+		 /* fallthrough */
 	case PWR_STATE_LVL_SYS:
 		if (pwrdn && SOC_SYSTEM_PWR_DWN)
 			state->pwr_domain_state[PLAT_SYS_LVL] =
@@ -358,7 +358,7 @@ static int _pwr_state_validate(uint32_t pwr_state,
 		else if (SOC_SYSTEM_STANDBY)
 			state->pwr_domain_state[PLAT_SYS_LVL] =
 				PLAT_MAX_RET_STATE;
-		 /* intentional fall-thru condition */
+		 /* fallthrough */
 	case PWR_STATE_LVL_CLSTR:
 		if (pwrdn && SOC_CLUSTER_PWR_DWN)
 			state->pwr_domain_state[PLAT_CLSTR_LVL] =
@@ -366,7 +366,7 @@ static int _pwr_state_validate(uint32_t pwr_state,
 		else if (SOC_CLUSTER_STANDBY)
 			state->pwr_domain_state[PLAT_CLSTR_LVL] =
 				PLAT_MAX_RET_STATE;
-		 /* intentional fall-thru condition */
+		 /* fallthrough */
 	case PWR_STATE_LVL_CORE:
 		stat = PSCI_E_SUCCESS;
 
diff --git a/plat/qti/common/src/qti_pm.c b/plat/qti/common/src/qti_pm.c
index 5f1b7aa1dc..6b4610cec4 100644
--- a/plat/qti/common/src/qti_pm.c
+++ b/plat/qti/common/src/qti_pm.c
@@ -24,6 +24,12 @@
 #define QTI_LOCAL_PSTATE_WIDTH		4
 #define QTI_LOCAL_PSTATE_MASK		((1 << QTI_LOCAL_PSTATE_WIDTH) - 1)
 
+#if PSCI_OS_INIT_MODE
+#define QTI_LAST_AT_PLVL_MASK		(QTI_LOCAL_PSTATE_MASK <<	\
+					 (QTI_LOCAL_PSTATE_WIDTH *	\
+					  (PLAT_MAX_PWR_LVL + 1)))
+#endif
+
 /* Make composite power state parameter till level 0 */
 #define qti_make_pwrstate_lvl0(lvl0_state, type) \
 		(((lvl0_state) << PSTATE_ID_SHIFT) | ((type) << PSTATE_TYPE_SHIFT))
@@ -89,7 +95,12 @@ int qti_validate_power_state(unsigned int power_state,
 	 *  search if the number of entries justify the additional complexity.
 	 */
 	for (i = 0; !!qti_pm_idle_states[i]; i++) {
+#if PSCI_OS_INIT_MODE
+		if ((power_state & ~QTI_LAST_AT_PLVL_MASK) ==
+		    qti_pm_idle_states[i])
+#else
 		if (power_state == qti_pm_idle_states[i])
+#endif
 			break;
 	}
 
@@ -101,11 +112,14 @@ int qti_validate_power_state(unsigned int power_state,
 	state_id = psci_get_pstate_id(power_state);
 
 	/* Parse the State ID and populate the state info parameter */
-	while (state_id) {
-		req_state->pwr_domain_state[i++] = state_id &
+	for (i = QTI_PWR_LVL0; i <= PLAT_MAX_PWR_LVL; i++) {
+		req_state->pwr_domain_state[i] = state_id &
 		    QTI_LOCAL_PSTATE_MASK;
 		state_id >>= QTI_LOCAL_PSTATE_WIDTH;
 	}
+#if PSCI_OS_INIT_MODE
+	req_state->last_at_pwrlvl = state_id & QTI_LOCAL_PSTATE_MASK;
+#endif
 
 	return PSCI_E_SUCCESS;
 }
diff --git a/plat/qti/sc7280/platform.mk b/plat/qti/sc7280/platform.mk
index df07bc4a7a..528a1d4416 100644
--- a/plat/qti/sc7280/platform.mk
+++ b/plat/qti/sc7280/platform.mk
@@ -28,6 +28,7 @@ ENABLE_PLAT_COMPAT		:=	0
 # Enable PSCI v1.0 extended state ID format
 PSCI_EXTENDED_STATE_ID	:=  1
 ARM_RECOM_STATE_ID_ENC  :=  1
+PSCI_OS_INIT_MODE	:=  1
 
 COLD_BOOT_SINGLE_CPU		:=	1
 PROGRAMMABLE_RESET_ADDRESS	:=	1
diff --git a/plat/st/common/bl2_io_storage.c b/plat/st/common/bl2_io_storage.c
index b271ed6d30..a9942e28dd 100644
--- a/plat/st/common/bl2_io_storage.c
+++ b/plat/st/common/bl2_io_storage.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,8 +10,12 @@
 #include <arch_helpers.h>
 #include <common/debug.h>
 #include <common/desc_image_load.h>
+#include <drivers/auth/auth_mod.h>
 #include <drivers/fwu/fwu.h>
 #include <drivers/fwu/fwu_metadata.h>
+#if STM32MP_HYPERFLASH
+#include <drivers/hyperflash.h>
+#endif
 #include <drivers/io/io_block.h>
 #include <drivers/io/io_driver.h>
 #include <drivers/io/io_encrypted.h>
@@ -27,7 +31,12 @@
 #include <drivers/spi_nor.h>
 #include <drivers/st/io_mmc.h>
 #include <drivers/st/stm32_fmc2_nand.h>
+#if STM32MP13 || STM32MP15
 #include <drivers/st/stm32_qspi.h>
+#endif
+#if STM32MP25
+#include <drivers/st/stm32_ospi.h>
+#endif
 #include <drivers/st/stm32_sdmmc2.h>
 #include <drivers/usb_device.h>
 #include <lib/fconf/fconf.h>
@@ -48,6 +57,7 @@ uintptr_t fip_dev_handle;
 uintptr_t storage_dev_handle;
 
 static const io_dev_connector_t *fip_dev_con;
+static uint32_t nand_block_sz;
 
 #ifndef DECRYPTION_SUPPORT_none
 static const io_dev_connector_t *enc_dev_con;
@@ -57,7 +67,7 @@ uintptr_t enc_dev_handle;
 #if STM32MP_SDMMC || STM32MP_EMMC
 static struct mmc_device_info mmc_info;
 
-static uint32_t block_buffer[MMC_BLOCK_SIZE] __aligned(MMC_BLOCK_SIZE);
+static uint8_t block_buffer[MMC_BLOCK_SIZE] __aligned(MMC_BLOCK_SIZE);
 
 static io_block_dev_spec_t mmc_block_dev_spec = {
 	/* It's used as temp buffer in block driver */
@@ -80,6 +90,7 @@ static io_mtd_dev_spec_t spi_nor_dev_spec = {
 	.ops = {
 		.init = spi_nor_init,
 		.read = spi_nor_read,
+		.reset = spi_nor_reset,
 	},
 };
 #endif
@@ -106,6 +117,17 @@ static io_mtd_dev_spec_t spi_nand_dev_spec = {
 };
 #endif
 
+#if STM32MP_HYPERFLASH
+static io_mtd_dev_spec_t hyperflash_dev_spec = {
+	.ops = {
+		.init = hyperflash_init,
+		.read = hyperflash_read,
+	},
+};
+
+static const io_dev_connector_t *hyperflash_dev_con;
+#endif
+
 #if STM32MP_SPI_NAND || STM32MP_SPI_NOR
 static const io_dev_connector_t *spi_dev_con;
 #endif
@@ -192,15 +214,20 @@ static void print_boot_device(boot_api_context_t *boot_context)
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC:
 		INFO("Using EMMC\n");
 		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
-		INFO("Using QSPI NOR\n");
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI:
+		INFO("Using SPI NOR\n");
 		break;
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC:
 		INFO("Using FMC NAND\n");
 		break;
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI:
 		INFO("Using SPI NAND\n");
 		break;
+#if STM32MP_HYPERFLASH
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_HYPERFLASH_OSPI:
+		INFO("Using HYPERFLASH\n");
+		break;
+#endif
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
 		INFO("Using UART\n");
 		break;
@@ -223,7 +250,7 @@ static void print_boot_device(boot_api_context_t *boot_context)
 static void boot_mmc(enum mmc_device_type mmc_dev_type,
 		     uint16_t boot_interface_instance)
 {
-	int io_result __unused;
+	int io_result __maybe_unused;
 	struct stm32_sdmmc2_params params;
 
 	zeromem(&params, sizeof(struct stm32_sdmmc2_params));
@@ -295,9 +322,15 @@ static void boot_mmc(enum mmc_device_type mmc_dev_type,
 #if STM32MP_SPI_NOR
 static void boot_spi_nor(boot_api_context_t *boot_context)
 {
-	int io_result __unused;
+	int io_result __maybe_unused = 0;
 
+#if STM32MP13 || STM32MP15
 	io_result = stm32_qspi_init();
+#endif
+#if STM32MP25
+	io_result = stm32_ospi_init();
+#endif
+
 	assert(io_result == 0);
 
 	io_result = register_io_dev_mtd(&spi_dev_con);
@@ -314,7 +347,7 @@ static void boot_spi_nor(boot_api_context_t *boot_context)
 #if STM32MP_RAW_NAND
 static void boot_fmc2_nand(boot_api_context_t *boot_context)
 {
-	int io_result __unused;
+	int io_result __maybe_unused;
 
 	io_result = stm32_fmc2_init();
 	assert(io_result == 0);
@@ -327,15 +360,22 @@ static void boot_fmc2_nand(boot_api_context_t *boot_context)
 	io_result = io_dev_open(nand_dev_con, (uintptr_t)&nand_dev_spec,
 				&storage_dev_handle);
 	assert(io_result == 0);
+
+	nand_block_sz = nand_dev_spec.erase_size;
 }
 #endif /* STM32MP_RAW_NAND */
 
 #if STM32MP_SPI_NAND
 static void boot_spi_nand(boot_api_context_t *boot_context)
 {
-	int io_result __unused;
+	int io_result __maybe_unused = 0;
 
+#if STM32MP13 || STM32MP15
 	io_result = stm32_qspi_init();
+#endif
+#if STM32MP25
+	io_result = stm32_ospi_init();
+#endif
 	assert(io_result == 0);
 
 	io_result = register_io_dev_mtd(&spi_dev_con);
@@ -346,13 +386,34 @@ static void boot_spi_nand(boot_api_context_t *boot_context)
 				(uintptr_t)&spi_nand_dev_spec,
 				&storage_dev_handle);
 	assert(io_result == 0);
+
+	nand_block_sz = spi_nand_dev_spec.erase_size;
 }
 #endif /* STM32MP_SPI_NAND */
 
+#if STM32MP_HYPERFLASH
+static void boot_hyperflash(boot_api_context_t *boot_context)
+{
+	int io_result __maybe_unused = 0;
+
+	io_result = stm32_ospi_init();
+	assert(io_result == 0);
+
+	io_result = register_io_dev_mtd(&hyperflash_dev_con);
+	assert(io_result == 0);
+
+	/* Open connections to device */
+	io_result = io_dev_open(hyperflash_dev_con,
+				(uintptr_t)&hyperflash_dev_spec,
+				&storage_dev_handle);
+	assert(io_result == 0);
+}
+#endif /* STM32MP_HYPERFLASH */
+
 #if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
 static void mmap_io_setup(void)
 {
-	int io_result __unused;
+	int io_result __maybe_unused;
 
 	io_result = register_io_dev_memmap(&memmap_dev_con);
 	assert(io_result == 0);
@@ -363,38 +424,39 @@ static void mmap_io_setup(void)
 }
 
 #if STM32MP_UART_PROGRAMMER
-static void stm32cubeprogrammer_uart(void)
+static void stm32cubeprogrammer_uart(uint8_t phase, uintptr_t base, size_t len)
 {
-	int ret __unused;
+	int ret __maybe_unused;
 	boot_api_context_t *boot_context =
 		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
 	uintptr_t uart_base;
 
 	uart_base = get_uart_address(boot_context->boot_interface_instance);
-	ret = stm32cubeprog_uart_load(uart_base, DWL_BUFFER_BASE, DWL_BUFFER_SIZE);
+	ret = stm32cubeprog_uart_load(uart_base, phase, base, len);
 	assert(ret == 0);
 }
 #endif
 
 #if STM32MP_USB_PROGRAMMER
-static void stm32cubeprogrammer_usb(void)
+static void stm32cubeprogrammer_usb(uint8_t phase, uintptr_t base, size_t len)
 {
-	int ret __unused;
-	struct usb_handle *pdev;
+	int ret __maybe_unused;
+	static struct usb_handle *pdev;
 
 	/* Init USB on platform */
-	pdev = usb_dfu_plat_init();
+	if (pdev == NULL) {
+		pdev = usb_dfu_plat_init();
+	}
 
-	ret = stm32cubeprog_usb_load(pdev, DWL_BUFFER_BASE, DWL_BUFFER_SIZE);
+	ret = stm32cubeprog_usb_load(pdev, phase, base, len);
 	assert(ret == 0);
 }
 #endif
 #endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
 
-
 void stm32mp_io_setup(void)
 {
-	int io_result __unused;
+	int io_result __maybe_unused;
 	boot_api_context_t *boot_context =
 		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
 
@@ -435,7 +497,7 @@ void stm32mp_io_setup(void)
 		break;
 #endif
 #if STM32MP_SPI_NOR
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI:
 		dmbsy();
 		boot_spi_nor(boot_context);
 		break;
@@ -447,11 +509,17 @@ void stm32mp_io_setup(void)
 		break;
 #endif
 #if STM32MP_SPI_NAND
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI:
 		dmbsy();
 		boot_spi_nand(boot_context);
 		break;
 #endif
+#if STM32MP_HYPERFLASH
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_HYPERFLASH_OSPI:
+		dmbsy();
+		boot_hyperflash(boot_context);
+		break;
+#endif
 #if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
 #if STM32MP_UART_PROGRAMMER
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
@@ -472,11 +540,24 @@ void stm32mp_io_setup(void)
 	}
 }
 
+void stm32mp_io_exit(void)
+{
+	int io_result __maybe_unused;
+
+	/* Close connection to device */
+	io_result = io_dev_close(storage_dev_handle);
+	assert(io_result == 0);
+}
+
 int bl2_plat_handle_pre_image_load(unsigned int image_id)
 {
-	static bool gpt_init_done __unused;
+	static bool gpt_init_done __maybe_unused;
 	uint16_t boot_itf = stm32mp_get_boot_itf_selected();
 
+	if (stm32mp_skip_boot_device_after_standby()) {
+		return 0;
+	}
+
 	switch (boot_itf) {
 #if STM32MP_SDMMC || STM32MP_EMMC
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC:
@@ -495,12 +576,10 @@ int bl2_plat_handle_pre_image_load(unsigned int image_id)
  */
 #if !PSA_FWU_SUPPORT
 			const partition_entry_t *entry;
-			const struct efi_guid img_type_guid = STM32MP_FIP_GUID;
-			uuid_t img_type_uuid;
+			const struct efi_guid fip_guid = STM32MP_FIP_GUID;
 
-			guidcpy(&img_type_uuid, &img_type_guid);
 			partition_init(GPT_IMAGE_ID);
-			entry = get_partition_entry_by_type(&img_type_uuid);
+			entry = get_partition_entry_by_type(&fip_guid);
 			if (entry == NULL) {
 				entry = get_partition_entry(FIP_IMAGE_NAME);
 				if (entry == NULL) {
@@ -517,6 +596,7 @@ int bl2_plat_handle_pre_image_load(unsigned int image_id)
 			gpt_init_done = true;
 		} else {
 			bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(image_id);
+
 			assert(bl_mem_params != NULL);
 
 			mmc_block_dev_spec.buffer.offset = bl_mem_params->image_info.image_base;
@@ -531,22 +611,68 @@ int bl2_plat_handle_pre_image_load(unsigned int image_id)
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC:
 #endif
 #if STM32MP_SPI_NAND
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI:
 #endif
+/*
+ * With FWU Multi Bank feature enabled, the selection of
+ * the image to boot will be done by fwu_init calling the
+ * platform hook, plat_fwu_set_images_source.
+ */
+#if !PSA_FWU_SUPPORT
 		image_block_spec.offset = STM32MP_NAND_FIP_OFFSET;
+#endif
 		break;
 #endif
 
 #if STM32MP_SPI_NOR
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI:
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI:
+/*
+ * With FWU Multi Bank feature enabled, the selection of
+ * the image to boot will be done by fwu_init calling the
+ * platform hook, plat_fwu_set_images_source.
+ */
+#if !PSA_FWU_SUPPORT
 		image_block_spec.offset = STM32MP_NOR_FIP_OFFSET;
+#endif
+		break;
+#endif
+
+#if STM32MP_HYPERFLASH
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_HYPERFLASH_OSPI:
+/*
+ * With FWU Multi Bank feature enabled, the selection of
+ * the image to boot will be done by fwu_init calling the
+ * platform hook, plat_fwu_set_images_source.
+ */
+#if !PSA_FWU_SUPPORT
+		image_block_spec.offset = STM32MP_HYPERFLASH_FIP_OFFSET;
+#endif
 		break;
 #endif
 
 #if STM32MP_UART_PROGRAMMER
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+#if STM32MP_DDR_FIP_IO_STORAGE
+		if (image_id == DDR_FW_ID) {
+			stm32cubeprogrammer_uart(PHASE_DDR_FW,
+						 DWL_DDR_BUFFER_BASE,
+						 DWL_DDR_BUFFER_SIZE);
+			/* FIP loaded at DWL address */
+			image_block_spec.offset = DWL_DDR_BUFFER_BASE;
+			image_block_spec.length = DWL_DDR_BUFFER_SIZE;
+		}
+#endif
 		if (image_id == FW_CONFIG_ID) {
-			stm32cubeprogrammer_uart();
+#if STM32MP_DDR_FIP_IO_STORAGE && TRUSTED_BOARD_BOOT
+			/*
+			 * Clear authentication state of STM32MP certificate that will
+			 * now be loaded from other FIP file
+			 */
+			auth_img_flags[STM32MP_CONFIG_CERT_ID] = 0U;
+#endif
+			stm32cubeprogrammer_uart(PHASE_SSBL,
+						 DWL_BUFFER_BASE,
+						 DWL_BUFFER_SIZE);
 			/* FIP loaded at DWL address */
 			image_block_spec.offset = DWL_BUFFER_BASE;
 			image_block_spec.length = DWL_BUFFER_SIZE;
@@ -555,8 +681,27 @@ int bl2_plat_handle_pre_image_load(unsigned int image_id)
 #endif
 #if STM32MP_USB_PROGRAMMER
 	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+#if STM32MP_DDR_FIP_IO_STORAGE
+		if (image_id == DDR_FW_ID) {
+			stm32cubeprogrammer_usb(PHASE_DDR_FW,
+						DWL_DDR_BUFFER_BASE,
+						DWL_DDR_BUFFER_SIZE);
+			/* FIP loaded at DWL address */
+			image_block_spec.offset = DWL_DDR_BUFFER_BASE;
+			image_block_spec.length = DWL_DDR_BUFFER_SIZE;
+		}
+#endif
 		if (image_id == FW_CONFIG_ID) {
-			stm32cubeprogrammer_usb();
+#if STM32MP_DDR_FIP_IO_STORAGE && TRUSTED_BOARD_BOOT
+			/*
+			 * Clear authentication state of STM32MP certificate that will
+			 * now be loaded from other FIP file
+			 */
+			auth_img_flags[STM32MP_CONFIG_CERT_ID] = 0U;
+#endif
+			stm32cubeprogrammer_usb(PHASE_SSBL,
+						DWL_BUFFER_BASE,
+						DWL_BUFFER_SIZE);
 			/* FIP loaded at DWL address */
 			image_block_spec.offset = DWL_BUFFER_BASE;
 			image_block_spec.length = DWL_BUFFER_SIZE;
@@ -592,7 +737,43 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
 	return rc;
 }
 
-#if (STM32MP_SDMMC || STM32MP_EMMC) && PSA_FWU_SUPPORT
+/*
+ * This function shall return 0 if it cannot find an alternate
+ * image to be loaded or it returns 1 otherwise.
+ */
+int plat_try_backup_partitions(unsigned int image_id)
+{
+	static unsigned int backup_id;
+	static unsigned int backup_block_nb;
+
+	/* Check if NAND storage used */
+	if (nand_block_sz == 0U) {
+		return 0;
+	}
+
+	if (backup_id != image_id) {
+		backup_block_nb = PLATFORM_MTD_MAX_PART_SIZE / nand_block_sz;
+		backup_id = image_id;
+	}
+
+	if (backup_block_nb-- == 0U) {
+		return 0;
+	}
+
+#if PSA_FWU_SUPPORT
+	if (((image_block_spec.offset < STM32MP_NAND_FIP_B_OFFSET) &&
+	     ((image_block_spec.offset + nand_block_sz) >= STM32MP_NAND_FIP_B_OFFSET)) ||
+	    (image_block_spec.offset + nand_block_sz >= STM32MP_NAND_FIP_B_MAX_OFFSET)) {
+		return 0;
+	}
+#endif
+
+	image_block_spec.offset += nand_block_sz;
+
+	return 1;
+}
+
+#if PSA_FWU_SUPPORT
 /*
  * In each boot in non-trial mode, we set the BKP register to
  * FWU_MAX_TRIAL_REBOOT, and return the active_index from metadata.
@@ -607,8 +788,6 @@ int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
  *     - we already boot FWU_MAX_TRIAL_REBOOT times in trial mode.
  * we select the previous_active_index.
  */
-#define INVALID_BOOT_IDX		0xFFFFFFFF
-
 uint32_t plat_fwu_get_boot_idx(void)
 {
 	/*
@@ -616,32 +795,38 @@ uint32_t plat_fwu_get_boot_idx(void)
 	 * even if this function is called several times.
 	 */
 	static uint32_t boot_idx = INVALID_BOOT_IDX;
-	const struct fwu_metadata *data;
-
-	data = fwu_get_metadata();
 
 	if (boot_idx == INVALID_BOOT_IDX) {
+		const struct fwu_metadata *data = fwu_get_metadata();
+
 		boot_idx = data->active_index;
-		if (fwu_is_trial_run_state()) {
+
+		if (data->bank_state[boot_idx] == FWU_BANK_STATE_VALID) {
 			if (stm32_get_and_dec_fwu_trial_boot_cnt() == 0U) {
 				WARN("Trial FWU fails %u times\n",
 				     FWU_MAX_TRIAL_REBOOT);
-				boot_idx = data->previous_active_index;
+				boot_idx = fwu_get_alternate_boot_bank();
 			}
-		} else {
+		} else if (data->bank_state[boot_idx] ==
+			   FWU_BANK_STATE_ACCEPTED) {
 			stm32_set_max_fwu_trial_boot_cnt();
+		} else {
+			ERROR("The active bank(%u) of the platform is in Invalid State.\n",
+				boot_idx);
+			boot_idx = fwu_get_alternate_boot_bank();
+			stm32_clear_fwu_trial_boot_cnt();
 		}
 	}
 
 	return boot_idx;
 }
 
-static void *stm32_get_image_spec(const uuid_t *img_type_uuid)
+static void *stm32_get_image_spec(const struct efi_guid *img_type_guid)
 {
 	unsigned int i;
 
 	for (i = 0U; i < MAX_NUMBER_IDS; i++) {
-		if ((guidcmp(&policies[i].img_type_guid, img_type_uuid)) == 0) {
+		if ((guidcmp(&policies[i].img_type_guid, img_type_guid)) == 0) {
 			return (void *)policies[i].image_spec;
 		}
 	}
@@ -653,54 +838,129 @@ void plat_fwu_set_images_source(const struct fwu_metadata *metadata)
 {
 	unsigned int i;
 	uint32_t boot_idx;
-	const partition_entry_t *entry;
-	const uuid_t *img_type_uuid, *img_uuid;
+	const partition_entry_t *entry __maybe_unused;
+	const struct fwu_image_entry *img_entry;
+	const void *img_type_guid;
+	const void *img_guid;
 	io_block_spec_t *image_spec;
 
 	boot_idx = plat_fwu_get_boot_idx();
 	assert(boot_idx < NR_OF_FW_BANKS);
+	VERBOSE("Selecting to boot from bank %u\n", boot_idx);
 
+	img_entry = (void *)&metadata->fw_desc.img_entry;
 	for (i = 0U; i < NR_OF_IMAGES_IN_FW_BANK; i++) {
-		img_type_uuid = &metadata->img_entry[i].img_type_uuid;
-		image_spec = stm32_get_image_spec(img_type_uuid);
+		img_type_guid = &img_entry[i].img_type_guid;
+
+		img_guid = &img_entry[i].img_bank_info[boot_idx].img_guid;
+
+		image_spec = stm32_get_image_spec(img_type_guid);
 		if (image_spec == NULL) {
 			ERROR("Unable to get image spec for the image in the metadata\n");
 			panic();
 		}
 
-		img_uuid =
-			&metadata->img_entry[i].img_props[boot_idx].img_uuid;
-
-		entry = get_partition_entry_by_uuid(img_uuid);
+#if (STM32MP_SDMMC || STM32MP_EMMC)
+		entry = get_partition_entry_by_guid(img_guid);
 		if (entry == NULL) {
-			ERROR("Unable to find the partition with the uuid mentioned in metadata\n");
+			ERROR("No partition with the uuid mentioned in metadata\n");
 			panic();
 		}
 
 		image_spec->offset = entry->start;
 		image_spec->length = entry->length;
+#endif
+#if STM32MP_SPI_NOR
+		if (guidcmp(img_guid, &STM32MP_NOR_FIP_A_GUID) == 0) {
+			image_spec->offset = STM32MP_NOR_FIP_A_OFFSET;
+		} else if (guidcmp(img_guid, &STM32MP_NOR_FIP_B_GUID) == 0) {
+			image_spec->offset = STM32MP_NOR_FIP_B_OFFSET;
+		} else {
+			ERROR("Invalid uuid mentioned in metadata\n");
+			panic();
+		}
+#endif
+#if (STM32MP_SPI_NAND || STM32MP_RAW_NAND)
+		if (guidcmp(img_guid, &STM32MP_NAND_FIP_A_GUID) == 0) {
+			image_spec->offset = STM32MP_NAND_FIP_A_OFFSET;
+		} else if (guidcmp(img_guid, &STM32MP_NAND_FIP_B_GUID) == 0) {
+			image_spec->offset = STM32MP_NAND_FIP_B_OFFSET;
+		} else {
+			ERROR("Invalid uuid mentioned in metadata\n");
+			panic();
+		}
+#endif
+#if STM32MP_HYPERFLASH
+		if (guidcmp(img_guid, &STM32MP_HYPERFLASH_FIP_A_GUID) == 0) {
+			image_spec->offset = STM32MP_HYPERFLASH_FIP_A_OFFSET;
+		} else if (guidcmp(img_guid, &STM32MP_HYPERFLASH_FIP_B_GUID) == 0) {
+			image_spec->offset = STM32MP_HYPERFLASH_FIP_B_OFFSET;
+		} else {
+			ERROR("Invalid uuid mentioned in metadata\n");
+			panic();
+		}
+#endif
 	}
 }
 
 static int plat_set_image_source(unsigned int image_id,
 				 uintptr_t *handle,
-				 uintptr_t *image_spec,
-				 const char *part_name)
+				 uintptr_t *image_spec)
 {
 	struct plat_io_policy *policy;
-	io_block_spec_t *spec;
-	const partition_entry_t *entry = get_partition_entry(part_name);
+	io_block_spec_t *spec __maybe_unused;
+	const partition_entry_t *entry __maybe_unused;
+
+	policy = &policies[image_id];
+	spec = (io_block_spec_t *)policy->image_spec;
+
+#if (STM32MP_SDMMC || STM32MP_EMMC)
+	partition_init(GPT_IMAGE_ID);
+
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		entry = get_partition_entry(METADATA_PART_1);
+	} else {
+		entry = get_partition_entry(METADATA_PART_2);
+	}
 
 	if (entry == NULL) {
-		ERROR("Unable to find the %s partition\n", part_name);
+		ERROR("Unable to find a metadata partition\n");
 		return -ENOENT;
 	}
 
-	policy = &policies[image_id];
-
-	spec = (io_block_spec_t *)policy->image_spec;
 	spec->offset = entry->start;
 	spec->length = entry->length;
+#endif
+
+#if STM32MP_SPI_NOR
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		spec->offset = STM32MP_NOR_METADATA1_OFFSET;
+	} else {
+		spec->offset = STM32MP_NOR_METADATA2_OFFSET;
+	}
+
+	spec->length = sizeof(struct fwu_metadata);
+#endif
+
+#if (STM32MP_SPI_NAND || STM32MP_RAW_NAND)
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		spec->offset = STM32MP_NAND_METADATA1_OFFSET;
+	} else {
+		spec->offset = STM32MP_NAND_METADATA2_OFFSET;
+	}
+
+	spec->length = sizeof(struct fwu_metadata);
+#endif
+
+#if STM32MP_HYPERFLASH
+	if (image_id == FWU_METADATA_IMAGE_ID) {
+		spec->offset = STM32MP_HYPERFLASH_METADATA1_OFFSET;
+	} else {
+		spec->offset = STM32MP_HYPERFLASH_METADATA2_OFFSET;
+	}
+
+	spec->length = sizeof(struct fwu_metadata);
+#endif
 
 	*image_spec = policy->image_spec;
 	*handle = *policy->dev_handle;
@@ -712,20 +972,14 @@ int plat_fwu_set_metadata_image_source(unsigned int image_id,
 				       uintptr_t *handle,
 				       uintptr_t *image_spec)
 {
-	char *part_name;
-
 	assert((image_id == FWU_METADATA_IMAGE_ID) ||
 	       (image_id == BKUP_FWU_METADATA_IMAGE_ID));
 
-	partition_init(GPT_IMAGE_ID);
-
-	if (image_id == FWU_METADATA_IMAGE_ID) {
-		part_name = METADATA_PART_1;
-	} else {
-		part_name = METADATA_PART_2;
-	}
+	return plat_set_image_source(image_id, handle, image_spec);
+}
 
-	return plat_set_image_source(image_id, handle, image_spec,
-				     part_name);
+bool plat_fwu_is_enabled(void)
+{
+	return !stm32mp_skip_boot_device_after_standby();
 }
-#endif /* (STM32MP_SDMMC || STM32MP_EMMC) && PSA_FWU_SUPPORT */
+#endif /* PSA_FWU_SUPPORT */
diff --git a/plat/st/common/common.mk b/plat/st/common/common.mk
new file mode 100644
index 0000000000..bb2fc078cf
--- /dev/null
+++ b/plat/st/common/common.mk
@@ -0,0 +1,292 @@
+#
+# Copyright (c) 2022-2024, Arm Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+BL2_AT_EL3		:=	1
+
+STM32MP_EARLY_CONSOLE	?=	0
+STM32MP_RECONFIGURE_CONSOLE ?=	0
+STM32MP_UART_BAUDRATE	?=	115200
+
+# Add specific ST version
+ST_VERSION 		:=	r2.0
+ST_GIT_SHA1		:=	$(shell git rev-parse --short=8 HEAD 2>/dev/null)
+VERSION_STRING		:=	v${VERSION_MAJOR}.${VERSION_MINOR}-${PLAT}-${ST_VERSION}(${BUILD_TYPE}):${BUILD_STRING}(${ST_GIT_SHA1})
+
+TRUSTED_BOARD_BOOT	?=	0
+STM32MP_USE_EXTERNAL_HEAP ?=	0
+
+# Use secure library from the ROM code for authentication
+STM32MP_CRYPTO_ROM_LIB	?=	0
+
+# Please don't increment this value without good understanding of
+# the monotonic counter
+STM32_TF_VERSION	?=	0
+
+# Enable dynamic memory mapping
+PLAT_XLAT_TABLES_DYNAMIC :=	1
+
+# STM32 image header binary type for BL2
+STM32_HEADER_BL2_BINARY_TYPE:=	0x10
+
+TF_CFLAGS		+=	-Wsign-compare
+TF_CFLAGS		+=	-Wformat-signedness
+
+# Number of TF-A copies in the device
+STM32_TF_A_COPIES		:=	2
+
+# PLAT_PARTITION_MAX_ENTRIES must take care of STM32_TF-A_COPIES and other partitions
+PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + $(STM32_EXTRA_PARTS))))
+
+ifeq (${PSA_FWU_SUPPORT},1)
+# Number of banks of updatable firmware
+NR_OF_FW_BANKS			:=	2
+NR_OF_IMAGES_IN_FW_BANK		:=	1
+JSON_METADATA			?=	plat/st/common/default_metadata.json
+
+$(eval $(call GEN_METADATA,${JSON_METADATA},${BUILD_PLAT}/metadata.bin))
+
+FWU_MAX_PART = $(shell echo $$(($(STM32_TF_A_COPIES) + 2 + $(NR_OF_FW_BANKS))))
+ifeq ($(shell test $(FWU_MAX_PART) -gt $(PLAT_PARTITION_MAX_ENTRIES); echo $$?),0)
+$(error "Required partition number is $(FWU_MAX_PART) where PLAT_PARTITION_MAX_ENTRIES is only \
+$(PLAT_PARTITION_MAX_ENTRIES)")
+endif
+endif
+
+# Boot devices
+STM32MP_EMMC		?=	0
+STM32MP_SDMMC		?=	0
+STM32MP_RAW_NAND	?=	0
+STM32MP_SPI_NAND	?=	0
+STM32MP_SPI_NOR		?=	0
+STM32MP_HYPERFLASH	?=	0
+STM32MP_EMMC_BOOT	?=	0
+
+# Serial boot devices
+STM32MP_UART_PROGRAMMER	?=	0
+STM32MP_USB_PROGRAMMER	?=	0
+
+$(eval DTC_V = $(shell $(DTC) -v | awk '{print $$NF}'))
+$(eval DTC_VERSION = $(shell printf "%d" $(shell echo ${DTC_V} | cut -d- -f1 | sed "s/\./0/g" | grep -o "[0-9]*")))
+DTC_CPPFLAGS		+=	${INCLUDES}
+DTC_FLAGS		+=	-Wno-unit_address_vs_reg
+ifeq ($(shell test $(DTC_VERSION) -ge 10601; echo $$?),0)
+DTC_FLAGS		+=	-Wno-interrupt_provider
+endif
+
+TFA_EXTERNAL_DT		?=	fdts/external-dt/tf-a
+
+# Macros and rules to build TF binary
+STM32_TF_ELF_LDFLAGS	:=	--hash-style=gnu --as-needed
+STM32_TF_LINKERFILE	:=	${BUILD_PLAT}/${PLAT}.ld
+
+ASFLAGS			+= -DBL2_BIN_PATH=\"${BUILD_PLAT}/bl2.bin\"
+
+# Variables for use with stm32image
+STM32IMAGEPATH		?= tools/stm32image
+STM32IMAGE		?= ${STM32IMAGEPATH}/stm32image${BIN_EXT}
+STM32IMAGE_SRC		:= ${STM32IMAGEPATH}/stm32image.c
+STM32_DEPS		+= ${STM32IMAGE}
+
+FIP_DEPS		+=	dtbs
+STM32MP_HW_CONFIG	:=	${BL33_CFG}
+
+# Add the HW_CONFIG to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_HW_CONFIG},--hw-config))
+
+$(eval $(call CERT_ADD_CMD_OPT,${BUILD_PLAT}/bl2.bin,--tb-fw))
+CRT_DEPS+=${BUILD_PLAT}/bl2.bin
+
+# Add the build options to pack Trusted OS Extra1 and Trusted OS Extra2 images
+# in the FIP if the platform requires.
+ifneq ($(BL32_EXTRA1),)
+$(eval $(call TOOL_ADD_IMG,BL32_EXTRA1,--tos-fw-extra1,,$(ENCRYPT_BL32)))
+endif
+ifneq ($(BL32_EXTRA2),)
+$(eval $(call TOOL_ADD_IMG,BL32_EXTRA2,--tos-fw-extra2,,$(ENCRYPT_BL32)))
+endif
+
+# Enable flags for C files
+$(eval $(call assert_booleans,\
+	$(sort \
+		PLAT_XLAT_TABLES_DYNAMIC \
+		STM32MP_EARLY_CONSOLE \
+		STM32MP_EMMC \
+		STM32MP_EMMC_BOOT \
+		STM32MP_HYPERFLASH \
+		STM32MP_RAW_NAND \
+		STM32MP_RECONFIGURE_CONSOLE \
+		STM32MP_SDMMC \
+		STM32MP_SPI_NAND \
+		STM32MP_SPI_NOR \
+		STM32MP_UART_PROGRAMMER \
+		STM32MP_USB_PROGRAMMER \
+)))
+
+$(eval $(call assert_numerics,\
+	$(sort \
+		STM32_TF_VERSION \
+		STM32MP_UART_BAUDRATE \
+)))
+
+$(eval $(call add_defines,\
+	$(sort \
+		PLAT_XLAT_TABLES_DYNAMIC \
+		STM32_TF_VERSION \
+		STM32MP_EARLY_CONSOLE \
+		STM32MP_EMMC \
+		STM32MP_EMMC_BOOT \
+		STM32MP_HYPERFLASH \
+		STM32MP_RAW_NAND \
+		STM32MP_RECONFIGURE_CONSOLE \
+		STM32MP_SDMMC \
+		STM32MP_SPI_NAND \
+		STM32MP_SPI_NOR \
+		STM32MP_UART_BAUDRATE \
+		STM32MP_UART_PROGRAMMER \
+		STM32MP_USB_PROGRAMMER \
+)))
+
+# Include paths and source files
+PLAT_INCLUDES		+=	-Iplat/st/common/include/
+
+include lib/fconf/fconf.mk
+include lib/libfdt/libfdt.mk
+include lib/zlib/zlib.mk
+ifeq (${PSA_FWU_SUPPORT},1)
+include drivers/fwu/fwu.mk
+endif
+
+PLAT_BL_COMMON_SOURCES	+=	common/uuid.c						\
+				plat/st/common/stm32mp_common.c
+
+
+include lib/xlat_tables_v2/xlat_tables.mk
+PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/clk/clk.c					\
+				drivers/delay_timer/delay_timer.c			\
+				drivers/delay_timer/generic_delay_timer.c		\
+				drivers/st/clk/stm32mp_clkfunc.c			\
+				drivers/st/ddr/stm32mp_ddr.c				\
+				drivers/st/gpio/stm32_gpio.c				\
+				drivers/st/nvmem/nvmem.c				\
+				drivers/st/nvmem/stm32mp_tamp_nvram_core.c		\
+				drivers/st/regulator/regulator_core.c			\
+				drivers/st/regulator/regulator_fixed.c			\
+				drivers/st/regulator/regulator_gpio.c			\
+				plat/st/common/stm32mp_dt.c				\
+				plat/st/common/stm32mp_fconf_fuse.c
+
+BL2_SOURCES		+=	${FCONF_SOURCES} ${FCONF_DYN_SOURCES}
+BL2_SOURCES		+=	$(ZLIB_SOURCES)
+
+BL2_SOURCES		+=	drivers/io/io_fip.c					\
+				plat/st/common/bl2_io_storage.c				\
+				plat/st/common/stm32mp_fconf_io.c
+
+BL2_SOURCES		+=	drivers/io/io_block.c					\
+				drivers/io/io_mtd.c					\
+				drivers/io/io_storage.c
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+AUTH_SOURCES		:=	drivers/auth/auth_mod.c					\
+				drivers/auth/crypto_mod.c				\
+				drivers/auth/img_parser_mod.c
+
+ifeq (${GENERATE_COT},1)
+TFW_NVCTR_VAL		:=	0
+NTFW_NVCTR_VAL		:=	0
+KEY_SIZE		:=
+KEY_ALG			:=	ecdsa
+HASH_ALG		:=	sha256
+
+ifeq (${SAVE_KEYS},1)
+TRUSTED_WORLD_KEY	?=	${BUILD_PLAT}/trusted.pem
+NON_TRUSTED_WORLD_KEY	?=	${BUILD_PLAT}/non-trusted.pem
+BL32_KEY		?=	${BUILD_PLAT}/trusted_os.pem
+BL33_KEY		?=	${BUILD_PLAT}/non-trusted_os.pem
+endif
+
+endif
+TF_MBEDTLS_KEY_ALG 	:=	ecdsa
+MBEDTLS_CONFIG_FILE	?=	"<stm32mp_mbedtls_config.h>"
+
+include drivers/auth/mbedtls/mbedtls_x509.mk
+
+COT_DESC_IN_DTB		:=	1
+AUTH_SOURCES		+=	lib/fconf/fconf_cot_getter.c				\
+				lib/fconf/fconf_tbbr_getter.c				\
+				plat/st/common/stm32mp_crypto_lib.c
+
+BL2_SOURCES		+=	$(AUTH_SOURCES)						\
+				plat/st/common/stm32mp_trusted_boot.c
+endif
+
+ifneq (${DECRYPTION_SUPPORT},none)
+BL2_SOURCES		+=	drivers/io/io_encrypted.c
+endif
+
+ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+BL2_SOURCES		+=	drivers/mmc/mmc.c					\
+				drivers/partition/gpt.c					\
+				drivers/partition/partition.c				\
+				drivers/st/io/io_mmc.c
+endif
+
+ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
+BL2_SOURCES		+=	drivers/mtd/spi-mem/spi_mem.c
+endif
+
+ifeq (${STM32MP_RAW_NAND},1)
+$(eval $(call add_define_val,NAND_ONFI_DETECT,1))
+BL2_SOURCES		+=	drivers/mtd/nand/raw_nand.c
+endif
+
+ifeq (${STM32MP_SPI_NAND},1)
+BL2_SOURCES		+=	drivers/mtd/nand/spi_nand.c
+endif
+
+ifeq (${STM32MP_SPI_NOR},1)
+ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
+$(eval $(call add_define_val,STM32MP_NOR_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
+endif
+BL2_SOURCES		+=	drivers/mtd/nor/spi_nor.c
+endif
+
+ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND}),)
+ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
+$(eval $(call add_define_val,STM32MP_NAND_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
+endif
+BL2_SOURCES		+=	drivers/mtd/nand/core.c
+endif
+
+ifeq (${STM32MP_HYPERFLASH},1)
+ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
+$(eval $(call add_define_val,STM32MP_HYPERFLASH_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
+endif
+BL2_SOURCES		+=	drivers/mtd/hyperflash/hyperflash.c
+endif
+
+ifneq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
+BL2_SOURCES		+=	drivers/io/io_memmap.c
+endif
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	plat/st/common/stm32cubeprogrammer_uart.c
+endif
+
+ifeq (${STM32MP_USB_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/usb/usb_device.c				\
+				plat/st/common/stm32cubeprogrammer_usb.c		\
+				plat/st/common/usb_dfu.c
+endif
+
+BL2_SOURCES		+=	drivers/st/ddr/stm32mp_ddr_test.c			\
+				drivers/st/ddr/stm32mp_ram.c
+
+BL2_SOURCES		+=	common/desc_image_load.c
+
+BL2_SOURCES		+=	lib/optee/optee_utils.c
diff --git a/plat/st/common/common_rules.mk b/plat/st/common/common_rules.mk
new file mode 100644
index 0000000000..838721641b
--- /dev/null
+++ b/plat/st/common/common_rules.mk
@@ -0,0 +1,85 @@
+#
+# Copyright (c) 2022-2024, Arm Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Compilation rules
+.PHONY: check_dtc_version stm32image clean_stm32image check_boot_device
+.SUFFIXES:
+
+all: check_dtc_version stm32image ${STM32_TF_STM32}
+
+distclean realclean clean: clean_stm32image
+
+bl2: check_boot_device
+
+check_boot_device:
+	@if [ ${STM32MP_EMMC} != 1 ] && \
+	    [ ${STM32MP_SDMMC} != 1 ] && \
+	    [ ${STM32MP_RAW_NAND} != 1 ] && \
+	    [ ${STM32MP_SPI_NAND} != 1 ] && \
+	    [ ${STM32MP_SPI_NOR} != 1 ] && \
+	    [ ${STM32MP_HYPERFLASH} != 1 ] && \
+	    [ ${STM32MP_UART_PROGRAMMER} != 1 ] && \
+	    [ ${STM32MP_USB_PROGRAMMER} != 1 ]; then \
+		echo "No boot device driver is enabled"; \
+		false; \
+	fi
+
+stm32image: ${STM32IMAGE}
+
+${STM32IMAGE}: ${STM32IMAGE_SRC}
+	${Q}${MAKE} CPPFLAGS="" --no-print-directory -C ${STM32IMAGEPATH}
+
+clean_stm32image:
+	${Q}${MAKE} --no-print-directory -C ${STM32IMAGEPATH} clean
+
+check_dtc_version:
+	@if [ ${DTC_VERSION} -lt 10407 ]; then \
+		echo "dtc version too old (${DTC_V}), you need at least version 1.4.7"; \
+		false; \
+	fi
+
+# Create DTB file for BL2
+${BUILD_PLAT}/fdts/%-bl2.dts: $(DT_SOURCE_PATH)/%.dts fdts/${BL2_DTSI} | ${BUILD_PLAT} fdt_dirs
+	@echo '#include "$(patsubst fdts/%,%,$<)"' > $@
+	@echo '#include "${BL2_DTSI}"' >> $@
+
+${BUILD_PLAT}/fdts/%-bl2.dtb: ${BUILD_PLAT}/fdts/%-bl2.dts
+
+${BUILD_PLAT}/$(PLAT)-%.o: ${BUILD_PLAT}/fdts/%-bl2.dtb $(STM32_BINARY_MAPPING) ${BUILD_PLAT}/bl2.bin
+	@echo "  AS      $${PLAT}.S"
+	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
+		-DDTB_BIN_PATH=\"$<\" \
+		-c $(word 2,$^) -o $@
+
+$(eval $(call MAKE_LD,${STM32_TF_LINKERFILE},$(STM32_LD_FILE),bl2))
+
+tf-a-%.elf: $(PLAT)-%.o ${STM32_TF_LINKERFILE}
+	@echo "  LDS     $<"
+	${Q}${LD} -o $@ ${STM32_TF_ELF_LDFLAGS} -Map=$(@:.elf=.map) --script ${STM32_TF_LINKERFILE} $<
+
+tf-a-%.bin: tf-a-%.elf
+	${Q}${OC} -O binary $< $@
+	@echo
+	@echo "Built $@ successfully"
+	@echo
+
+tf-a-%.stm32: tf-a-%.bin ${STM32_DEPS}
+	@echo
+	@echo "Generate $@"
+	$(eval LOADADDR = $(shell cat $(@:.stm32=.map) | grep '^RAM' | awk '{print $$2}'))
+	$(eval ENTRY = $(shell cat $(@:.stm32=.map) | grep "__BL2_IMAGE_START" | awk '{print $$1}'))
+	${Q}${STM32IMAGE} -s $< -d $@ \
+		-l $(LOADADDR) -e ${ENTRY} \
+		-v ${STM32_TF_VERSION} \
+		-m ${STM32_HEADER_VERSION_MAJOR} \
+		-n ${STM32_HEADER_VERSION_MINOR} \
+		-b ${STM32_HEADER_BL2_BINARY_TYPE}
+	@echo
+
+ifeq (${PSA_FWU_SUPPORT},1)
+.PHONY: metadata
+metadata: ${BUILD_PLAT}/metadata.bin
+endif
diff --git a/plat/st/common/default_metadata.json b/plat/st/common/default_metadata.json
new file mode 100644
index 0000000000..bd40f04d29
--- /dev/null
+++ b/plat/st/common/default_metadata.json
@@ -0,0 +1,37 @@
+{
+    "copyright": "Copyright (c) 2022, STMicroelectronics - All Rights Reserved",
+    "license": "SPDX-License-Identifier: BSD-3-Clause",
+
+    "metadata": {
+        "version": 0,
+        "active_index": 0,
+        "previous_active_index": 1,
+        "img_entry": {
+            "img_0": {
+                "location": "device0",
+                "img_bank_info": {
+                    "img_0_bank_0": {
+                        "accepted": true
+                    },
+                    "img_0_bank_1": {
+                        "accepted": false
+                    }
+                }
+            }
+        }
+    },
+    "uuids": {
+        "locations": {
+            "device0": "00000000-0000-0000-0000-000000000000"
+        },
+        "entries": {
+            "img_0_bank_0": "4fd84c93-54ef-463f-a7ef-ae25ff887087",
+            "img_0_bank_1": "09c54952-d5bf-45af-acee-335303766fb3",
+            "img_0":        "19d5df83-11b0-457b-be2c-7559c13142a5"
+        }
+    },
+    "configs": {
+        "nb_fw_img": 1,
+        "nb_fw_banks": 2
+    }
+}
diff --git a/plat/st/stm32mp1/include/plat_def_fip_uuid.h b/plat/st/common/include/plat_def_fip_uuid.h
similarity index 59%
rename from plat/st/stm32mp1/include/plat_def_fip_uuid.h
rename to plat/st/common/include/plat_def_fip_uuid.h
index e5fbc2dfc5..096fd952ff 100644
--- a/plat/st/stm32mp1/include/plat_def_fip_uuid.h
+++ b/plat/st/common/include/plat_def_fip_uuid.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2024, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,10 @@
 #ifndef PLAT_DEF_FIP_UUID_H
 #define PLAT_DEF_FIP_UUID_H
 
+#define UUID_DDR_FW \
+	{{0xb1, 0x12, 0x49, 0xbe}, {0x92, 0xdd}, {0x4b, 0x10}, 0x86, 0x7c, \
+	 {0x2c, 0x6a, 0x4b, 0x47, 0xa7, 0xfb} }
+
 #define UUID_STM32MP_CONFIG_CERT \
 	{{0x50, 0x1d, 0x8d, 0xd2}, {0x8b, 0xce}, {0x49, 0xa5}, 0x84, 0xeb, \
 	 {0x55, 0x9a, 0x9f, 0x2e, 0xae, 0xaf} }
diff --git a/plat/st/common/include/stm32cubeprogrammer.h b/plat/st/common/include/stm32cubeprogrammer.h
index 0f5a64d451..9a171ab35f 100644
--- a/plat/st/common/include/stm32cubeprogrammer.h
+++ b/plat/st/common/include/stm32cubeprogrammer.h
@@ -13,17 +13,33 @@
 
 /* Phase definition */
 #define PHASE_FLASHLAYOUT	0U
+#define PHASE_DDR_FW		2U
 #define PHASE_SSBL		3U
 #define PHASE_CMD		0xF1U
+#define PHASE_SSP		0xF3U
 #define PHASE_RESET		0xFFU
 
 /* Functions provided by plat */
 uint8_t usb_dfu_get_phase(uint8_t alt);
 
 int stm32cubeprog_usb_load(struct usb_handle *usb_core_handle,
+			   uint8_t phase,
 			   uintptr_t ssbl_base,
 			   size_t ssbl_len);
 
-int stm32cubeprog_uart_load(uintptr_t instance, uintptr_t base, size_t len);
+int stm32cubeprog_uart_load(uintptr_t instance, uint8_t phase,
+			   uintptr_t base, size_t len);
+
+int stm32cubeprog_usb_ssp(struct usb_handle *usb_core_handle,
+			  uintptr_t cert_base,
+			  size_t cert_len,
+			  uintptr_t ssp_base,
+			  size_t ssp_len);
+
+int stm32cubeprog_uart_ssp(uintptr_t instance,
+			   uintptr_t cert_base,
+			   size_t cert_len,
+			   uintptr_t ssp_base,
+			   size_t ssp_len);
 
 #endif /* STM32CUBEPROGRAMMER_H */
diff --git a/plat/st/common/include/stm32mp_common.h b/plat/st/common/include/stm32mp_common.h
index a5316b6689..0f5402b60b 100644
--- a/plat/st/common/include/stm32mp_common.h
+++ b/plat/st/common/include/stm32mp_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2018-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,18 +10,28 @@
 #include <stdbool.h>
 
 #include <platform_def.h>
+#include <drivers/st/nvmem.h>
 
 #define JEDEC_ST_BKID U(0x0)
 #define JEDEC_ST_MFID U(0x20)
 
+#define STM32MP_CHIP_SEC_CLOSED		U(0x34D9CCC5)
+#define STM32MP_CHIP_SEC_OPEN		U(0xA764D182)
+
+/* FWU configuration (max supported value is 15) */
+#define FWU_MAX_TRIAL_REBOOT		U(3)
+
 /* Functions to save and get boot context address given by ROM code */
 void stm32mp_save_boot_ctx_address(uintptr_t address);
 uintptr_t stm32mp_get_boot_ctx_address(void);
 uint16_t stm32mp_get_boot_itf_selected(void);
+#if STM32MP13 || STM32MP15
+uint32_t stm32mp_get_boot_action(void);
+#endif
 
 bool stm32mp_is_single_core(void);
-bool stm32mp_is_closed_device(void);
 bool stm32mp_is_auth_supported(void);
+uint32_t stm32mp_check_closed_device(void);
 
 /* Return the base address of the DDR controller */
 uintptr_t stm32mp_ddrctrl_base(void);
@@ -35,13 +45,29 @@ uintptr_t stm32mp_pwr_base(void);
 /* Return the base address of the RCC peripheral */
 uintptr_t stm32mp_rcc_base(void);
 
+void stm32mp_gic_cpuif_enable(void);
+void stm32mp_gic_cpuif_disable(void);
+void stm32mp_gic_pcpu_init(void);
+void stm32mp_gic_init(void);
+
+void stm32mp_gic_save(void);
+void stm32mp_gic_resume(void);
+
 /* Check MMU status to allow spinlock use */
 bool stm32mp_lock_available(void);
 
+/* SMP protection on PWR registers access */
+void stm32mp_pwr_regs_lock(void);
+void stm32mp_pwr_regs_unlock(void);
+
 int stm32_get_otp_index(const char *otp_name, uint32_t *otp_idx,
 			uint32_t *otp_len);
 int stm32_get_otp_value(const char *otp_name, uint32_t *otp_val);
 int stm32_get_otp_value_from_idx(const uint32_t otp_idx, uint32_t *otp_val);
+int stm32_lock_enc_key_otp(void);
+/* update UID_WORD_NB array */
+int stm32_get_uid_otp(uint32_t uid[]);
+int stm32_get_enc_key_otp_idx_len(uint32_t *otp_idx, uint32_t *otp_len);
 
 /* Get IWDG platform instance ID from peripheral IO memory base address */
 uint32_t stm32_iwdg_get_instance(uintptr_t base);
@@ -49,11 +75,6 @@ uint32_t stm32_iwdg_get_instance(uintptr_t base);
 /* Return bitflag mask for expected IWDG configuration from OTP content */
 uint32_t stm32_iwdg_get_otp_config(uint32_t iwdg_inst);
 
-#if defined(IMAGE_BL2)
-/* Update OTP shadow registers with IWDG configuration from device tree */
-uint32_t stm32_iwdg_shadow_update(uint32_t iwdg_inst, uint32_t flags);
-#endif
-
 #if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
 /* Get the UART address from its instance number */
 uintptr_t get_uart_address(uint32_t instance_nb);
@@ -63,12 +84,30 @@ uintptr_t get_uart_address(uint32_t instance_nb);
 int stm32mp_uart_console_setup(void);
 
 #if STM32MP_EARLY_CONSOLE
+#define EARLY_ERROR(...)	ERROR(__VA_ARGS__)
+#define EARLY_NOTICE(...)	NOTICE(__VA_ARGS__)
+#define EARLY_WARN(...)		WARN(__VA_ARGS__)
+#define EARLY_INFO(...)		INFO(__VA_ARGS__)
+#define EARLY_VERBOSE(...)	VERBOSE(__VA_ARGS__)
+
 void stm32mp_setup_early_console(void);
-#else
+#else /* STM32MP_EARLY_CONSOLE */
+#define EARLY_ERROR(...)
+#define EARLY_NOTICE(...)
+#define EARLY_WARN(...)
+#define EARLY_INFO(...)
+#define EARLY_VERBOSE(...)
+
 static inline void stm32mp_setup_early_console(void)
 {
 }
-#endif
+#endif /* STM32MP_EARLY_CONSOLE */
+
+void stm32_save_header(void);
+uintptr_t stm32_get_header_address(void);
+
+bool stm32mp_skip_boot_device_after_standby(void);
+bool stm32mp_is_wakeup_from_standby(void);
 
 /*
  * Platform util functions for the GPIO driver
@@ -109,21 +148,45 @@ void stm32mp_print_boardinfo(void);
 /* Initialise the IO layer and register platform IO devices */
 void stm32mp_io_setup(void);
 
+/* Deinitialise the IO layer */
+void stm32mp_io_exit(void);
+
 /* Functions to map DDR in MMU with non-cacheable attribute, and unmap it */
 int stm32mp_map_ddr_non_cacheable(void);
 int stm32mp_unmap_ddr(void);
 
-/* Functions to save and get boot peripheral info */
-void stm32_save_boot_interface(uint32_t interface, uint32_t instance);
+/* Functions to map RETRAM, and unmap it */
+int stm32mp_map_retram(void);
+int stm32mp_unmap_retram(void);
+
+/* Function to save boot info */
+void stm32_save_boot_info(boot_api_context_t *boot_context);
+/* Function to get boot peripheral info */
 void stm32_get_boot_interface(uint32_t *interface, uint32_t *instance);
 
-/* Functions to save and get boot authentication status and partition used */
-void stm32_save_boot_auth(uint32_t auth_status, uint32_t boot_partition);
+/* Display board information from the value found in OTP fuse */
+void stm32_display_board_info(uint32_t board_id);
+
+int stm32_tamp_nvram_init(void);
+int stm32_tamp_nvram_update_rights(void);
+
+int stm32_get_fwu_info_cell(struct nvmem_cell *fwu_info);
+int stm32_get_boot_mode_cell(struct nvmem_cell *boot_mode);
+
+#if STM32MP25
+int stm32_get_stop2_entrypoint_cell(struct nvmem_cell *stop2_entrypoint);
+#endif
+
+#if STM32MP15
+int stm32_get_magic_number_cell(struct nvmem_cell *magic_number);
+int stm32_get_core1_branch_address_cell(struct nvmem_cell *core1_branch_address);
+#endif
 
 #if PSA_FWU_SUPPORT
-void stm32mp1_fwu_set_boot_idx(void);
+void stm32_fwu_set_boot_idx(void);
 uint32_t stm32_get_and_dec_fwu_trial_boot_cnt(void);
 void stm32_set_max_fwu_trial_boot_cnt(void);
+void stm32_clear_fwu_trial_boot_cnt(void);
 #endif /* PSA_FWU_SUPPORT */
 
 #endif /* STM32MP_COMMON_H */
diff --git a/plat/st/common/include/stm32mp_dt.h b/plat/st/common/include/stm32mp_dt.h
index b7bf1d0123..737cdc4e7a 100644
--- a/plat/st/common/include/stm32mp_dt.h
+++ b/plat/st/common/include/stm32mp_dt.h
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2020-2022, STMicroelectronics - All Rights Reserved
- * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2020-2023, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2017-2023, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -35,12 +35,14 @@ void dt_fill_device_info(struct dt_node_info *info, int node);
 int dt_get_node(struct dt_node_info *info, int offset, const char *compat);
 int dt_get_stdout_uart_info(struct dt_node_info *info);
 int dt_match_instance_by_compatible(const char *compatible, uintptr_t address);
-uint32_t dt_get_ddr_size(void);
+size_t dt_get_ddr_size(void);
 uint32_t dt_get_pwr_vdd_voltage(void);
 struct rdev *dt_get_vdd_regulator(void);
 struct rdev *dt_get_cpu_regulator(void);
+struct rdev *dt_get_sysram_regulator(void);
 const char *dt_get_board_model(void);
 int dt_find_otp_name(const char *name, uint32_t *otp, uint32_t *otp_len);
+int dt_get_otp_by_phandle(const uint32_t phandle, uint32_t *otp_id, uint32_t *otp_len);
 int fdt_get_gpio_bank_pin_count(unsigned int bank);
 
 #endif /* STM32MP_DT_H */
diff --git a/plat/st/common/include/stm32mp_efi.h b/plat/st/common/include/stm32mp_efi.h
index 490560ff38..af9165f1da 100644
--- a/plat/st/common/include/stm32mp_efi.h
+++ b/plat/st/common/include/stm32mp_efi.h
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: BSD-3-Clause */
 /*
  * Copyright (c) 2021, Linaro Limited
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
  */
 
 #ifndef STM32MP_EFI_H
@@ -9,7 +10,7 @@
 #include <drivers/partition/efi.h>
 
 #define STM32MP_FIP_GUID \
-	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, \
-		 0xbe, 0x2c, 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+	EFI_GUID(0x19d5df83U, 0x11b0U, 0x457bU, \
+		 0xbeU, 0x2cU, 0x75U, 0x59U, 0xc1U, 0x31U, 0x42U, 0xa5U)
 
 #endif /* STM32MP_EFI_H */
diff --git a/plat/st/common/include/stm32mp_io_storage.h b/plat/st/common/include/stm32mp_io_storage.h
index 3c04c4716b..91c66c7d06 100644
--- a/plat/st/common/include/stm32mp_io_storage.h
+++ b/plat/st/common/include/stm32mp_io_storage.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,6 +10,70 @@
 
 #include <drivers/io/io_storage.h>
 
+/*******************************************************************************
+ * STM32MP1 RAW partition offset for devices without GPT
+ ******************************************************************************/
+#define STM32MP_EMMC_BOOT_FIP_OFFSET		U(0x00040000)
+#if PSA_FWU_SUPPORT
+#define STM32MP_NOR_METADATA1_OFFSET		U(0x00080000)
+#define STM32MP_NOR_METADATA2_OFFSET		U(0x000C0000)
+#define STM32MP_NOR_FIP_A_OFFSET		U(0x00100000)
+#define STM32MP_NOR_FIP_A_GUID			(const struct efi_guid)EFI_GUID(0x4fd84c93,  \
+						0x54ef, 0x463f, 0xa7, 0xef, 0xae, 0x25, 0xff,\
+						0x88, 0x70, 0x87)
+
+#define STM32MP_NOR_FIP_B_OFFSET		U(0x00500000)
+#define STM32MP_NOR_FIP_B_GUID			(const struct efi_guid)EFI_GUID(0x09c54952,  \
+						0xd5bf, 0x45af, 0xac, 0xee, 0x33, 0x53, 0x03,\
+						0x76, 0x6f, 0xb3)
+
+#define STM32MP_NAND_METADATA1_OFFSET		U(0x00100000)
+#define STM32MP_NAND_METADATA2_OFFSET		U(0x00180000)
+#define STM32MP_NAND_FIP_A_OFFSET		U(0x00200000)
+#define STM32MP_NAND_FIP_A_GUID			(const struct efi_guid)EFI_GUID(0x4fd84c93,  \
+						0x54ef, 0x463f, 0xa7, 0xef, 0xae, 0x25, 0xff,\
+						0x88, 0x70, 0x87)
+
+#define STM32MP_NAND_FIP_B_OFFSET		U(0x00A00000)
+#define STM32MP_NAND_FIP_B_GUID			(const struct efi_guid)EFI_GUID(0x09c54952,  \
+						0xd5bf, 0x45af, 0xac, 0xee, 0x33, 0x53, 0x03,\
+						0x76, 0x6f, 0xb3)
+
+#define STM32MP_NAND_FIP_B_MAX_OFFSET		U(0x01200000)
+
+#define STM32MP_HYPERFLASH_METADATA1_OFFSET	U(0x00080000)
+#define STM32MP_HYPERFLASH_METADATA2_OFFSET	U(0x000C0000)
+#define STM32MP_HYPERFLASH_FIP_A_OFFSET		U(0x00100000)
+#define STM32MP_HYPERFLASH_FIP_A_GUID		(const struct efi_guid)EFI_GUID(0x4fd84c93,  \
+						0x54ef, 0x463f, 0xa7, 0xef, 0xae, 0x25, 0xff,\
+						0x88, 0x70, 0x87)
+
+#define STM32MP_HYPERFLASH_FIP_B_OFFSET		U(0x00500000)
+#define STM32MP_HYPERFLASH_FIP_B_GUID		(const struct efi_guid)EFI_GUID(0x09c54952,  \
+						0xd5bf, 0x45af, 0xac, 0xee, 0x33, 0x53, 0x03,\
+						0x76, 0x6f, 0xb3)
+#else /* PSA_FWU_SUPPORT */
+#ifndef STM32MP_NOR_FIP_OFFSET
+#define STM32MP_NOR_FIP_OFFSET			U(0x00080000)
+#endif
+#ifndef STM32MP_NAND_FIP_OFFSET
+#define STM32MP_NAND_FIP_OFFSET			U(0x00200000)
+#endif
+#ifndef STM32MP_HYPERFLASH_FIP_OFFSET
+#define STM32MP_HYPERFLASH_FIP_OFFSET		U(0x00080000)
+#endif
+#endif /* PSA_FWU_SUPPORT */
+
+/*
+ * Only used for MTD devices that need some backup blocks.
+ * Must define a maximum size for a partition.
+ */
+#define PLATFORM_MTD_MAX_PART_SIZE		U(0x00400000)
+
+#define FIP_IMAGE_NAME				"fip"
+#define METADATA_PART_1				"metadata1"
+#define METADATA_PART_2				"metadata2"
+
 /* IO devices handle */
 extern uintptr_t storage_dev_handle;
 extern uintptr_t fip_dev_handle;
diff --git a/plat/st/stm32mp1/include/stm32mp1_mbedtls_config.h b/plat/st/common/include/stm32mp_mbedtls_config.h
similarity index 97%
rename from plat/st/stm32mp1/include/stm32mp1_mbedtls_config.h
rename to plat/st/common/include/stm32mp_mbedtls_config.h
index 2f07621c3b..66ff3465a4 100644
--- a/plat/st/stm32mp1/include/stm32mp1_mbedtls_config.h
+++ b/plat/st/common/include/stm32mp_mbedtls_config.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
diff --git a/plat/st/common/include/stm32mp_svc_setup.h b/plat/st/common/include/stm32mp_svc_setup.h
new file mode 100644
index 0000000000..55b2336191
--- /dev/null
+++ b/plat/st/common/include/stm32mp_svc_setup.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP_SVC_SETUP_H
+#define STM32MP_SVC_SETUP_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+/* Common SMC function IDs for STM32 Service queries across STM32MP paltforms */
+#define STM32_SIP_SVC_CALL_COUNT	0x8200ff00
+#define STM32_SIP_SVC_UID		0x8200ff01
+/*					0x8200ff02 is reserved */
+#define STM32_SIP_SVC_VERSION		0x8200ff03
+
+/* STM32 SiP Service Calls version numbers */
+#define STM32_SIP_SVC_VERSION_MAJOR	0x0
+#define STM32_SIP_SVC_VERSION_MINOR	0x1
+
+/* SMC error codes */
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xFFFFFFFFU
+#define STM32_SMC_FAILED		0xFFFFFFFEU
+#define STM32_SMC_INVALID_PARAMS	0xFFFFFFFDU
+
+void plat_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+			  u_register_t x2, u_register_t x3,
+			  u_register_t x4, uint32_t *ret1,
+			  uint32_t *ret2, bool *ret2_enabled,
+			  u_register_t flags);
+
+#endif /* STM32MP_SVC_SETUP_H */
diff --git a/plat/st/common/stm32cubeprogrammer_uart.c b/plat/st/common/stm32cubeprogrammer_uart.c
index d004dcfe4b..9410271202 100644
--- a/plat/st/common/stm32cubeprogrammer_uart.c
+++ b/plat/st/common/stm32cubeprogrammer_uart.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -47,6 +47,9 @@ static const uint8_t command_tab[] = {
 	GET_VER_COMMAND,
 	GET_ID_COMMAND,
 	PHASE_COMMAND,
+#if STM32MP_SSP
+	READ_PART_COMMAND,
+#endif
 	START_COMMAND,
 	DOWNLOAD_COMMAND
 };
@@ -58,6 +61,10 @@ struct stm32prog_uart_handle_s {
 	uint8_t *addr;
 	uint32_t len;
 	uint8_t phase;
+#if STM32MP_SSP
+	uintptr_t cert_base;
+	size_t cert_len;
+#endif
 	/* Error msg buffer: max 255 in UART protocol, reduced in TF-A */
 	uint8_t error[64];
 } handle;
@@ -131,11 +138,13 @@ static int uart_send_result(uint8_t byte)
 	return uart_write_8(byte);
 }
 
+#if !STM32MP_SSP
 static bool is_valid_header(fip_toc_header_t *header)
 {
 	return (header->name == TOC_HEADER_NAME) &&
 	       (header->serial_number != 0U);
 }
+#endif
 
 static int uart_receive_command(uint8_t *command)
 {
@@ -388,16 +397,110 @@ static int uart_start_cmd(uintptr_t buffer)
 		return 0;
 	}
 
+#if !STM32MP_SSP
 	if (!is_valid_header((fip_toc_header_t *)buffer)) {
 		STM32PROG_ERROR("FIP Header check failed %lx, for phase %u\n",
 				buffer, handle.phase);
 		return -EIO;
 	}
+
 	VERBOSE("FIP header looks OK.\n");
+#endif
 
 	return 0;
 }
 
+#if STM32MP_SSP
+static int uart_read_part(void)
+{
+	uint8_t byte = 0U;
+	uint8_t xor = 0U;
+	uint8_t partid = 0U;
+	uint16_t size = 0U;
+	uint32_t start_address = 0U;
+	uint32_t i;
+	size_t length;
+	uint8_t *buffer;
+
+	/* Get partition id */
+	if (uart_read_8(&partid) != 0) {
+		return -EIO;
+	}
+
+	if ((partid != PHASE_FLASHLAYOUT) && (partid != PHASE_SSP)) {
+		return -EPERM;
+	}
+
+	xor = partid;
+
+	/* Get address */
+	for (i = 4U; i > 0U; i--) {
+		if (uart_read_8(&byte) != 0) {
+			return -EIO;
+		}
+
+		xor ^= byte;
+		start_address = (start_address << 8) | byte;
+	}
+
+	/* Checksum */
+	if (uart_read_8(&byte) != 0) {
+		return -EIO;
+	}
+
+	if (xor != byte) {
+		WARN("UART: Start cmd: address checksum: %x != %x\n",
+		     xor, byte);
+		return -EPROTO;
+	}
+	/* OFFSET != 0 not supported */
+	if (start_address != 0U) {
+		return -EIO;
+	}
+
+	uart_write_8(ACK_BYTE);
+
+	/* Get number of bytes to send */
+	if (uart_read_8(&byte) != 0) {
+		return -EIO;
+	}
+
+	xor = byte;
+
+	/* Send Size + 1 */
+	size = byte++;
+
+	/* Checksum */
+	if (uart_read_8(&byte) != 0) {
+		return -EIO;
+	}
+
+	if ((xor ^ byte) != 0xFF) {
+		WARN("UART: Start cmd: length checksum: %x != %x\n", xor, byte);
+		return -EPROTO;
+	}
+
+	uart_write_8(ACK_BYTE);
+
+	if (partid != PHASE_SSP) {
+		WARN("Not supported\n");
+		return -EPROTO;
+	}
+
+	length = handle.cert_len;
+	buffer = (uint8_t *)handle.cert_base;
+
+	for (i = 0U; i < length; i++, buffer++) {
+		uart_write_8(*buffer);
+	}
+	for (; i < size; i++) {
+		uart_write_8(0x0);
+	}
+
+	return 0;
+}
+#endif /* STM32MP_SSP */
+
 static int uart_read(uint8_t id, uintptr_t buffer, size_t length)
 {
 	bool start_done = false;
@@ -409,7 +512,7 @@ static int uart_read(uint8_t id, uintptr_t buffer, size_t length)
 	handle.addr = (uint8_t *)buffer;
 	handle.len = length;
 
-	INFO("UART: read phase %u at 0x%lx size 0x%x\n",
+	INFO("UART: read phase %u at 0x%lx size 0x%zx\n",
 	     id, buffer, length);
 	while (!start_done) {
 		ret = uart_receive_command(&command);
@@ -456,11 +559,21 @@ static int uart_read(uint8_t id, uintptr_t buffer, size_t length)
 		case DOWNLOAD_COMMAND:
 			ret = uart_download_part();
 			break;
-
+#if STM32MP_SSP
+		case READ_PART_COMMAND:
+			ret = uart_read_part();
+			break;
+#endif
 		case START_COMMAND:
 			ret = uart_start_cmd(buffer);
 			if ((ret == 0) && (handle.phase == id)) {
 				INFO("UART: Start phase %u\n", handle.phase);
+#if STM32MP_SSP
+				if (handle.phase == PHASE_SSP) {
+					handle.phase = PHASE_RESET;
+					break;
+				}
+#endif
 				start_done = true;
 			}
 			break;
@@ -481,6 +594,8 @@ static int uart_read(uint8_t id, uintptr_t buffer, size_t length)
 		}
 	}
 
+	stm32_uart_flush(&handle.uart);
+
 	return 0;
 }
 
@@ -495,10 +610,49 @@ const struct stm32_uart_init_s init = {
 	.fifo_mode = STM32_UART_FIFOMODE_EN,
 };
 
-int stm32cubeprog_uart_load(uintptr_t instance, uintptr_t base, size_t len)
+#if STM32MP_SSP
+int stm32cubeprog_uart_ssp(uintptr_t instance,
+			   uintptr_t cert_base,
+			   size_t cert_len,
+			   uintptr_t ssp_base,
+			   size_t ssp_len)
 {
 	int ret;
 
+	if (stm32_uart_init(&handle.uart, instance, &init) != 0U) {
+		return -EIO;
+	}
+
+	/* NACK to synchronize STM32CubeProgrammer */
+	ret = uart_send_result(NACK_BYTE);
+	if (ret != 0) {
+		return ret;
+	}
+
+	if (cert_base == UNDEFINED_DOWN_ADDR) {
+		/* Send Provisioning message to programmer for reboot */
+		STM32PROG_ERROR("Provisioning\n");
+	} else {
+		handle.cert_base = cert_base;
+		handle.cert_len  = cert_len;
+		handle.phase = PHASE_SSP;
+	}
+
+	return uart_read(handle.phase, ssp_base, ssp_len);
+
+}
+#endif
+
+int stm32cubeprog_uart_load(uintptr_t instance, uint8_t phase,
+			    uintptr_t base, size_t len)
+{
+	int ret;
+	static bool init_done;
+
+	if (init_done) {
+		goto skip_init;
+	}
+
 	if (stm32_uart_init(&handle.uart, instance, &init) != 0) {
 		return -EIO;
 	}
@@ -516,5 +670,9 @@ int stm32cubeprog_uart_load(uintptr_t instance, uintptr_t base, size_t len)
 		return ret;
 	}
 
-	return uart_read(PHASE_SSBL, base, len);
+	init_done = true;
+
+skip_init:
+
+	return uart_read(phase, base, len);
 }
diff --git a/plat/st/common/stm32cubeprogrammer_usb.c b/plat/st/common/stm32cubeprogrammer_usb.c
index 75e8038599..a1d4b6eb10 100644
--- a/plat/st/common/stm32cubeprogrammer_usb.c
+++ b/plat/st/common/stm32cubeprogrammer_usb.c
@@ -21,6 +21,10 @@ struct dfu_state {
 	uintptr_t base;
 	size_t len;
 	uintptr_t address;
+#if STM32MP_SSP
+	uintptr_t cert_base;
+	size_t cert_len;
+#endif
 	/* working buffer */
 	uint8_t buffer[UCHAR_MAX];
 };
@@ -43,6 +47,7 @@ static struct dfu_state dfu_state;
 		} \
 	}
 
+#if !STM32MP_SSP
 static bool is_valid_header(fip_toc_header_t *header)
 {
 	if ((header->name == TOC_HEADER_NAME) && (header->serial_number != 0U)) {
@@ -51,6 +56,7 @@ static bool is_valid_header(fip_toc_header_t *header)
 
 	return false;
 }
+#endif
 
 static int dfu_callback_upload(uint8_t alt, uintptr_t *buffer, uint32_t *len,
 			       void *user_data)
@@ -62,7 +68,15 @@ static int dfu_callback_upload(uint8_t alt, uintptr_t *buffer, uint32_t *len,
 	switch (usb_dfu_get_phase(alt)) {
 	case PHASE_CMD:
 		/* Get Pḧase */
+#if STM32MP_SSP && STM32MP15
+		if (dfu->phase == PHASE_SSP) {
+			dfu->buffer[0] = PHASE_FLASHLAYOUT;
+		} else {
+			dfu->buffer[0] = dfu->phase;
+		}
+#else
 		dfu->buffer[0] = dfu->phase;
+#endif
 		dfu->buffer[1] = (uint8_t)(dfu->address);
 		dfu->buffer[2] = (uint8_t)(dfu->address >> 8);
 		dfu->buffer[3] = (uint8_t)(dfu->address >> 16);
@@ -85,6 +99,33 @@ static int dfu_callback_upload(uint8_t alt, uintptr_t *buffer, uint32_t *len,
 		}
 		break;
 
+#if STM32MP_SSP
+	case PHASE_SSP:
+#if STM32MP13
+		dfu->buffer[0] = dfu->phase;
+#endif
+#if STM32MP15
+		/* Fix phase to flashlayout phase */
+		dfu->buffer[0] = PHASE_FLASHLAYOUT;
+#endif
+		dfu->buffer[1] = (uint8_t)(dfu_state.cert_base);
+		dfu->buffer[2] = (uint8_t)(dfu_state.cert_base >> 8);
+		dfu->buffer[3] = (uint8_t)(dfu_state.cert_base >> 16);
+		dfu->buffer[4] = (uint8_t)(dfu_state.cert_base >> 24);
+		dfu->buffer[5] = 0x00;
+		dfu->buffer[6] = 0x00;
+		dfu->buffer[7] = 0x00;
+		dfu->buffer[8] = 0x00;
+		length = 9U;
+
+		if ((length + dfu_state.cert_len) <= sizeof(dfu->buffer)) {
+			memcpy(&dfu->buffer[9], (uint8_t *)dfu_state.cert_base,
+			       dfu_state.cert_len);
+			length += dfu_state.cert_len;
+		}
+
+		break;
+#endif
 	default:
 		DFU_ERROR("phase ID :%i, alternate %i for phase %i\n",
 			  dfu->phase, alt, usb_dfu_get_phase(alt));
@@ -137,6 +178,15 @@ static int dfu_callback_manifestation(uint8_t alt, void *user_data)
 	     dfu->phase, alt, dfu->address);
 
 	switch (dfu->phase) {
+#if STM32MP_SSP
+	case PHASE_SSP:
+		/* Configure End with request detach */
+		dfu->phase = PHASE_FLASHLAYOUT;
+		dfu->address = UNDEFINED_DOWN_ADDR;
+		dfu->len = 0;
+		break;
+#else
+	case PHASE_DDR_FW:
 	case PHASE_SSBL:
 		if (!is_valid_header((fip_toc_header_t *)dfu->base)) {
 			DFU_ERROR("FIP Header check failed for phase %d\n", alt);
@@ -149,6 +199,7 @@ static int dfu_callback_manifestation(uint8_t alt, void *user_data)
 		dfu->address = UNDEFINED_DOWN_ADDR;
 		dfu->len = 0;
 		break;
+#endif /* STM32MP_SSP */
 	default:
 		DFU_ERROR("Unknown phase\n");
 	}
@@ -163,7 +214,54 @@ static const struct usb_dfu_media usb_dfu_fops = {
 	.manifestation = dfu_callback_manifestation,
 };
 
+#if STM32MP_SSP
+int stm32cubeprog_usb_ssp(struct usb_handle *usb_core_handle,
+			  uintptr_t cert_base,
+			  size_t cert_len,
+			  uintptr_t ssp_base,
+			  size_t ssp_len)
+{
+	int ret;
+
+	usb_core_handle->user_data = (void *)&dfu_state;
+
+	INFO("DFU USB START...\n");
+	ret = usb_core_start(usb_core_handle);
+	if (ret != USBD_OK) {
+		return -EIO;
+	}
+
+	if (cert_base == UNDEFINED_DOWN_ADDR) {
+		struct dfu_state *dfu = (struct dfu_state *)usb_core_handle->user_data;
+
+		/* Send Provisioning message to programmer for reboot */
+		DFU_ERROR("Provisioning\n");
+	} else {
+		dfu_state.phase = PHASE_SSP;
+		dfu_state.address = ssp_base;
+		dfu_state.base = ssp_base;
+		dfu_state.len = ssp_len;
+		dfu_state.cert_base = cert_base;
+		dfu_state.cert_len = cert_len;
+	}
+
+	ret = usb_dfu_loop(usb_core_handle, &usb_dfu_fops);
+	if (ret != USBD_OK) {
+		return -EIO;
+	}
+
+	INFO("DFU USB STOP...\n");
+	ret = usb_core_stop(usb_core_handle);
+	if (ret != USBD_OK) {
+		return -EIO;
+	}
+
+	return 0;
+}
+#endif
+
 int stm32cubeprog_usb_load(struct usb_handle *usb_core_handle,
+			   uint8_t phase,
 			   uintptr_t base,
 			   size_t len)
 {
@@ -177,7 +275,7 @@ int stm32cubeprog_usb_load(struct usb_handle *usb_core_handle,
 		return -EIO;
 	}
 
-	dfu_state.phase = PHASE_SSBL;
+	dfu_state.phase = phase;
 	dfu_state.address = base;
 	dfu_state.base = base;
 	dfu_state.len = len;
diff --git a/plat/st/common/stm32mp_common.c b/plat/st/common/stm32mp_common.c
index bb56bac759..5060ab07e0 100644
--- a/plat/st/common/stm32mp_common.c
+++ b/plat/st/common/stm32mp_common.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2024, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,10 +11,13 @@
 #include <common/debug.h>
 #include <drivers/clk.h>
 #include <drivers/delay_timer.h>
+#include <drivers/st/nvmem.h>
 #include <drivers/st/stm32_console.h>
 #include <drivers/st/stm32mp_clkfunc.h>
 #include <drivers/st/stm32mp_reset.h>
+#include <lib/mmio.h>
 #include <lib/smccc.h>
+#include <lib/spinlock.h>
 #include <lib/xlat_tables/xlat_tables_v2.h>
 #include <plat/common/platform.h>
 #include <services/arm_arch_svc.h>
@@ -24,7 +27,44 @@
 #define HEADER_VERSION_MAJOR_MASK	GENMASK(23, 16)
 #define RESET_TIMEOUT_US_1MS		1000U
 
+/* Internal layout of the 32bit OTP word board_id */
+#define BOARD_ID_BOARD_NB_MASK		GENMASK_32(31, 16)
+#define BOARD_ID_BOARD_NB_SHIFT		16
+#define BOARD_ID_VARCPN_MASK		GENMASK_32(15, 12)
+#define BOARD_ID_VARCPN_SHIFT		12
+#define BOARD_ID_REVISION_MASK		GENMASK_32(11, 8)
+#define BOARD_ID_REVISION_SHIFT		8
+#define BOARD_ID_VARFG_MASK		GENMASK_32(7, 4)
+#define BOARD_ID_VARFG_SHIFT		4
+#define BOARD_ID_BOM_MASK		GENMASK_32(3, 0)
+
+#define BOARD_ID2NB(_id)		(((_id) & BOARD_ID_BOARD_NB_MASK) >> \
+					 BOARD_ID_BOARD_NB_SHIFT)
+#define BOARD_ID2VARCPN(_id)		(((_id) & BOARD_ID_VARCPN_MASK) >> \
+					 BOARD_ID_VARCPN_SHIFT)
+#define BOARD_ID2REV(_id)		(char)(((_id) & BOARD_ID_REVISION_MASK) >> \
+					       BOARD_ID_REVISION_SHIFT)
+#define BOARD_ID2VARFG(_id)		(((_id) & BOARD_ID_VARFG_MASK) >> \
+					 BOARD_ID_VARFG_SHIFT)
+#define BOARD_ID2BOM(_id)		((_id) & BOARD_ID_BOM_MASK)
+
+#define BOOT_AUTH_MASK			GENMASK_32(23, 20)
+#define BOOT_AUTH_SHIFT			20
+#define BOOT_PART_MASK			GENMASK_32(19, 16)
+#define BOOT_PART_SHIFT			16
+#define BOOT_ITF_MASK			GENMASK_32(15, 12)
+#define BOOT_ITF_SHIFT			12
+#define BOOT_INST_MASK			GENMASK_32(11, 8)
+#define BOOT_INST_SHIFT			8
+
+/* Layout for fwu update information. */
+#define FWU_INFO_IDX_MSK		GENMASK(3, 0)
+#define FWU_INFO_IDX_OFF		U(0)
+#define FWU_INFO_CNT_MSK		GENMASK(7, 4)
+#define FWU_INFO_CNT_OFF		U(4)
+
 static console_t console;
+static struct spinlock lock;
 
 uintptr_t plat_get_ns_image_entrypoint(void)
 {
@@ -38,6 +78,9 @@ unsigned int plat_get_syscnt_freq2(void)
 
 static uintptr_t boot_ctx_address;
 static uint16_t boot_itf_selected;
+#if STM32MP13 || STM32MP15
+static uint32_t boot_action_saved;
+#endif
 
 void stm32mp_save_boot_ctx_address(uintptr_t address)
 {
@@ -45,6 +88,9 @@ void stm32mp_save_boot_ctx_address(uintptr_t address)
 
 	boot_ctx_address = address;
 	boot_itf_selected = boot_context->boot_interface_selected;
+#if STM32MP13 || STM32MP15
+	boot_action_saved = boot_context->boot_action;
+#endif
 }
 
 uintptr_t stm32mp_get_boot_ctx_address(void)
@@ -57,6 +103,13 @@ uint16_t stm32mp_get_boot_itf_selected(void)
 	return boot_itf_selected;
 }
 
+#if STM32MP13 || STM32MP15
+uint32_t stm32mp_get_boot_action(void)
+{
+	return boot_action_saved;
+}
+#endif
+
 uintptr_t stm32mp_ddrctrl_base(void)
 {
 	return DDRCTRL_BASE;
@@ -82,7 +135,25 @@ bool stm32mp_lock_available(void)
 	const uint32_t c_m_bits = SCTLR_M_BIT | SCTLR_C_BIT;
 
 	/* The spinlocks are used only when MMU and data cache are enabled */
+#ifdef __aarch64__
+	return (read_sctlr_el3() & c_m_bits) == c_m_bits;
+#else
 	return (read_sctlr() & c_m_bits) == c_m_bits;
+#endif
+}
+
+void stm32mp_pwr_regs_lock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_lock(&lock);
+	}
+}
+
+void stm32mp_pwr_regs_unlock(void)
+{
+	if (stm32mp_lock_available()) {
+		spin_unlock(&lock);
+	}
 }
 
 int stm32mp_map_ddr_non_cacheable(void)
@@ -133,9 +204,9 @@ int stm32_get_otp_value_from_idx(const uint32_t otp_idx, uint32_t *otp_val)
 	assert(otp_val != NULL);
 
 #if defined(IMAGE_BL2)
-	ret = bsec_shadow_read_otp(otp_val, otp_idx);
-#elif defined(IMAGE_BL32)
-	ret = bsec_read_otp(otp_val, otp_idx);
+	ret = stm32_otp_shadow_read(otp_val, otp_idx);
+#elif defined(IMAGE_BL31) || defined(IMAGE_BL32)
+	ret = stm32_otp_read(otp_val, otp_idx);
 #else
 #error "Not supported"
 #endif
@@ -147,6 +218,79 @@ int stm32_get_otp_value_from_idx(const uint32_t otp_idx, uint32_t *otp_val)
 	return 0;
 }
 
+int stm32_lock_enc_key_otp(void)
+{
+	uint32_t otp_idx;
+	uint32_t otp_len;
+	uint32_t i;
+
+	if (stm32_get_otp_index(ENCKEY_OTP, &otp_idx, &otp_len) != 0) {
+		return -1;
+	}
+
+	for (i = 0U; i < otp_len / CHAR_BIT / sizeof(uint32_t); i++) {
+		uint32_t ret = stm32_otp_write(0U, otp_idx + i);
+
+		if (ret != BSEC_OK) {
+			return -1;
+		}
+
+		ret = stm32_otp_set_sr_lock(otp_idx + i);
+		if (ret != BSEC_OK) {
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int stm32_get_uid_otp(uint32_t uid[])
+{
+	uint8_t i;
+	uint32_t otp;
+	uint32_t len;
+
+	if (stm32_get_otp_index(UID_OTP, &otp, &len) != 0) {
+		ERROR("BSEC: Get UID_OTP number Error\n");
+		return -1;
+	}
+
+	if ((len / __WORD_BIT) != UID_WORD_NB) {
+		ERROR("BSEC: Get UID_OTP length Error\n");
+		return -1;
+	}
+
+	for (i = 0U; i < UID_WORD_NB; i++) {
+		if (stm32_otp_shadow_read(&uid[i], i + otp) != BSEC_OK) {
+			ERROR("BSEC: UID%u Error\n", i);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int stm32_get_enc_key_otp_idx_len(uint32_t *otp_idx, uint32_t *otp_len)
+{
+	static uint32_t idx;
+	static uint32_t len;
+	int ret;
+
+	if (len == 0U) {
+		ret = stm32_get_otp_index(ENCKEY_OTP, &idx, &len);
+		if (ret != 0) {
+			len = 0U;
+			ERROR("%s: get %s index error\n", __func__, ENCKEY_OTP);
+			return -EINVAL;
+		}
+	}
+
+	*otp_idx = idx;
+	*otp_len = len;
+
+	return 0;
+}
+
 #if  defined(IMAGE_BL2)
 static void reset_uart(uint32_t reset)
 {
@@ -208,7 +352,7 @@ int stm32mp_uart_console_setup(void)
 	}
 #endif
 
-#if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
+#if (STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)) && !STM32MP_SSP
 	stm32_get_boot_interface(&boot_itf, &boot_instance);
 
 	if ((boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) &&
@@ -277,3 +421,232 @@ int32_t plat_get_soc_revision(void)
 {
 	return (int32_t)(stm32mp_get_chip_version() & SOC_ID_REV_MASK);
 }
+
+void stm32_display_board_info(uint32_t board_id)
+{
+	NOTICE("Board: MB%04x Var%u.%u Rev.%c-%02u\n",
+	       BOARD_ID2NB(board_id),
+	       BOARD_ID2VARCPN(board_id),
+	       BOARD_ID2VARFG(board_id),
+	       BOARD_ID2REV(board_id) - 1 + 'A',
+	       BOARD_ID2BOM(board_id));
+}
+
+#if !STM32MP_SSP
+void stm32_save_boot_info(boot_api_context_t *boot_context)
+{
+	struct nvmem_cell boot_mode = {};
+	uint32_t reg_val = 0;
+
+	uint32_t clear = BOOT_ITF_MASK | BOOT_INST_MASK | BOOT_PART_MASK |
+			 BOOT_AUTH_MASK;
+	uint32_t set =
+		((boot_context->boot_interface_selected << BOOT_ITF_SHIFT) &
+		 BOOT_ITF_MASK) |
+		((boot_context->boot_interface_instance << BOOT_INST_SHIFT) &
+		 BOOT_INST_MASK) |
+		((boot_context->boot_partition_used_toboot << BOOT_PART_SHIFT) &
+		 BOOT_PART_MASK) |
+		((boot_context->auth_status << BOOT_AUTH_SHIFT) &
+		 BOOT_AUTH_MASK);
+
+	stm32_get_boot_mode_cell(&boot_mode);
+	nvmem_cell_read(&boot_mode, (uint8_t *)&reg_val, sizeof(reg_val), NULL);
+	reg_val &= ~clear;
+	reg_val |= set;
+	nvmem_cell_write(&boot_mode, (uint8_t *)&reg_val, sizeof(reg_val));
+}
+
+void stm32_get_boot_interface(uint32_t *interface, uint32_t *instance)
+{
+	static uint32_t itf;
+	struct nvmem_cell boot_mode = {};
+	uint32_t reg_val = 0;
+
+	if (itf == 0U) {
+		stm32_get_boot_mode_cell(&boot_mode);
+		nvmem_cell_read(&boot_mode, (uint8_t *)&reg_val,
+				sizeof(reg_val), NULL);
+		itf = reg_val & (BOOT_ITF_MASK | BOOT_INST_MASK);
+	}
+
+	*interface = (itf & BOOT_ITF_MASK) >> BOOT_ITF_SHIFT;
+	*instance = (itf & BOOT_INST_MASK) >> BOOT_INST_SHIFT;
+}
+
+static int stm32_get_bootinfo_cell(const char *name, struct nvmem_cell *cell)
+{
+	void *fdt = NULL;
+	int node = 0;
+	int ret;
+
+	if (fdt_get_address(&fdt) == 0) {
+		ret = -ENODEV;
+	} else {
+		node = fdt_node_offset_by_compatible(fdt, -1,
+						     "st,stm32mp-bootinfo");
+		if (node >= 0) {
+			ret = nvmem_get_cell_by_name(fdt, node, name, cell);
+		} else {
+			ret = -ENODEV;
+		}
+	}
+	return ret;
+}
+
+#if STM32MP15
+int stm32_get_magic_number_cell(struct nvmem_cell *magic_number)
+{
+	static bool initialized = false;
+	static struct nvmem_cell s_magic_number = { 0 };
+
+	if (!initialized) {
+		stm32_get_bootinfo_cell("magic-number", &s_magic_number);
+		initialized = true;
+	}
+
+	memcpy(magic_number, &s_magic_number, sizeof(*magic_number));
+
+	return 0;
+}
+
+int stm32_get_core1_branch_address_cell(struct nvmem_cell *core1_branch_address)
+{
+	static bool initialized = false;
+	static struct nvmem_cell s_core1_branch_address = { 0 };
+
+	if (!initialized) {
+		stm32_get_bootinfo_cell("core1-branch-address", &s_core1_branch_address);
+		initialized = true;
+	}
+
+	memcpy(core1_branch_address, &s_core1_branch_address, sizeof(*core1_branch_address));
+
+	return 0;
+}
+#endif
+
+int stm32_get_fwu_info_cell(struct nvmem_cell *fwu_info)
+{
+	static bool initialized = false;
+	static struct nvmem_cell s_fwu_info = { 0 };
+
+	if (!initialized) {
+		stm32_get_bootinfo_cell("fwu-info", &s_fwu_info);
+		initialized = true;
+	}
+
+	memcpy(fwu_info, &s_fwu_info, sizeof(*fwu_info));
+
+	return 0;
+}
+
+int stm32_get_boot_mode_cell(struct nvmem_cell *boot_mode)
+{
+	static bool initialized = false;
+	static struct nvmem_cell s_boot_mode = { 0 };
+
+	if (!initialized) {
+		stm32_get_bootinfo_cell("boot-mode", &s_boot_mode);
+		initialized = true;
+	}
+
+	memcpy(boot_mode, &s_boot_mode, sizeof(*boot_mode));
+
+	return 0;
+}
+
+#if STM32MP25
+int stm32_get_stop2_entrypoint_cell(struct nvmem_cell *stop2_entrypoint)
+{
+	static bool initialized = false;
+	static struct nvmem_cell s_stop2_entrypoint = { 0 };
+
+	if (!initialized) {
+		stm32_get_bootinfo_cell("stop2-entrypoint", &s_stop2_entrypoint);
+		initialized = true;
+	}
+
+	memcpy(stop2_entrypoint, &s_stop2_entrypoint, sizeof(*stop2_entrypoint));
+
+	return 0;
+}
+#endif
+#if PSA_FWU_SUPPORT
+static int stm32_nvmem_cell_clrset(struct nvmem_cell *cell, uint32_t clear,
+				   uint32_t set)
+{
+	int ret = 0;
+	uint32_t reg_val = 0;
+
+	ret = nvmem_cell_read(cell, (uint8_t *)&reg_val, sizeof(reg_val), NULL);
+	if (ret != 0) {
+		return ret;
+	}
+
+	reg_val &= ~clear;
+	reg_val |= set;
+
+	ret = nvmem_cell_write(cell, (uint8_t *)&reg_val, sizeof(reg_val));
+	if (ret != 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+void stm32_fwu_set_boot_idx(void)
+{
+	struct nvmem_cell fwu_info = {};
+
+	uint32_t clear = FWU_INFO_IDX_MSK;
+	uint32_t set = (plat_fwu_get_boot_idx() << FWU_INFO_IDX_OFF) &
+		       FWU_INFO_IDX_MSK;
+
+	stm32_get_fwu_info_cell(&fwu_info);
+
+	stm32_nvmem_cell_clrset(&fwu_info, clear, set);
+}
+
+uint32_t stm32_get_and_dec_fwu_trial_boot_cnt(void)
+{
+	struct nvmem_cell fwu_info_cell = {};
+	uint32_t try_cnt;
+	uint32_t fwu_info = 0;
+
+	stm32_get_fwu_info_cell(&fwu_info_cell);
+
+	nvmem_cell_read(&fwu_info_cell, (uint8_t *)&fwu_info, sizeof(fwu_info),
+			NULL);
+
+	try_cnt = (fwu_info & FWU_INFO_CNT_MSK) >> FWU_INFO_CNT_OFF;
+
+	assert(try_cnt <= FWU_MAX_TRIAL_REBOOT);
+
+	if (try_cnt != 0U) {
+		stm32_nvmem_cell_clrset(&fwu_info_cell, FWU_INFO_CNT_MSK,
+					(try_cnt - 1U) << FWU_INFO_CNT_OFF);
+	}
+
+	return try_cnt;
+}
+
+void stm32_set_max_fwu_trial_boot_cnt(void)
+{
+	struct nvmem_cell fwu_info_cell = {};
+
+	stm32_get_fwu_info_cell(&fwu_info_cell);
+	stm32_nvmem_cell_clrset(&fwu_info_cell, FWU_INFO_CNT_MSK,
+				(FWU_MAX_TRIAL_REBOOT << FWU_INFO_CNT_OFF) &
+					FWU_INFO_CNT_MSK);
+}
+
+void stm32_clear_fwu_trial_boot_cnt(void)
+{
+	struct nvmem_cell fwu_info_cell = {};
+
+	stm32_get_fwu_info_cell(&fwu_info_cell);
+	stm32_nvmem_cell_clrset(&fwu_info_cell, FWU_INFO_CNT_MSK, 0U);
+}
+#endif /* PSA_FWU_SUPPORT */
+#endif /* !STM32MP_SSP */
diff --git a/plat/st/common/stm32mp_crypto_lib.c b/plat/st/common/stm32mp_crypto_lib.c
index acfe701656..31d352647b 100644
--- a/plat/st/common/stm32mp_crypto_lib.c
+++ b/plat/st/common/stm32mp_crypto_lib.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,7 +11,6 @@
 #include <common/debug.h>
 #include <drivers/auth/crypto_mod.h>
 #include <drivers/io/io_storage.h>
-#include <drivers/st/bsec.h>
 #include <drivers/st/stm32_hash.h>
 #include <drivers/st/stm32_pka.h>
 #include <drivers/st/stm32_rng.h>
@@ -58,7 +57,8 @@ static void crypto_lib_init(void)
 		panic();
 	}
 
-	if (stm32mp_is_closed_device() || stm32mp_is_auth_supported()) {
+	if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) ||
+	    stm32mp_is_auth_supported()) {
 #if STM32MP_CRYPTO_ROM_LIB
 		boot_context = (boot_api_context_t *)stm32mp_get_boot_ctx_address();
 		auth_ops.verify_signature = boot_context->bootrom_ecdsa_verify_signature;
@@ -79,8 +79,8 @@ static void crypto_lib_init(void)
 	}
 }
 
-int get_plain_pk_from_asn1(void *pk_ptr, unsigned int pk_len, void **plain_pk,
-			   unsigned int *len, int *pk_alg)
+static int get_plain_pk_from_asn1(void *pk_ptr, unsigned int pk_len, void **plain_pk,
+				  size_t *len, int *pk_alg)
 {
 	int ret;
 	mbedtls_pk_context mbedtls_pk = {0};
@@ -170,7 +170,15 @@ uint32_t verify_signature(uint8_t *hash_in, uint8_t *pubkey_in,
 int plat_convert_pk(void *full_pk_ptr, unsigned int full_pk_len,
 		    void **hashed_pk_ptr, unsigned int *hashed_pk_len)
 {
-	return get_plain_pk_from_asn1(full_pk_ptr, full_pk_len, hashed_pk_ptr, hashed_pk_len, NULL);
+	size_t len;
+	int ret;
+
+	ret = get_plain_pk_from_asn1(full_pk_ptr, full_pk_len, hashed_pk_ptr, &len, NULL);
+	if (ret == 0) {
+		*hashed_pk_len = (unsigned int)len;
+	}
+
+	return ret;
 }
 #else /* STM32MP_CRYPTO_ROM_LIB*/
 static uint32_t verify_signature(uint8_t *hash_in, uint8_t *pubkey_in,
@@ -226,7 +234,7 @@ int plat_convert_pk(void *full_pk_ptr, unsigned int full_pk_len,
 	static uint8_t st_pk[CRYPTO_PUBKEY_MAX_SIZE + sizeof(uint32_t)];
 	int ret;
 	void *plain_pk;
-	unsigned int len;
+	size_t len;
 	int curve_id;
 	uint32_t cid;
 
@@ -241,7 +249,7 @@ int plat_convert_pk(void *full_pk_ptr, unsigned int full_pk_len,
 	memcpy(st_pk + sizeof(cid), plain_pk, len);
 
 	*hashed_pk_ptr = st_pk;
-	*hashed_pk_len = len + sizeof(cid);
+	*hashed_pk_len = (unsigned int)(len + sizeof(cid));
 
 	return 0;
 }
@@ -314,7 +322,8 @@ static int crypto_verify_signature(void *data_ptr, unsigned int data_len,
 	size_t bignum_len = sizeof(sig) / 2U;
 	unsigned int seq_num = 0U;
 
-	if (!stm32mp_is_closed_device() && !stm32mp_is_auth_supported()) {
+	if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_OPEN) &&
+	    !stm32mp_is_auth_supported()) {
 		return CRYPTO_SUCCESS;
 	}
 
@@ -339,15 +348,15 @@ static int crypto_verify_signature(void *data_ptr, unsigned int data_len,
 		return CRYPTO_ERR_SIGNATURE;
 	}
 
-	ret = get_plain_pk_from_asn1(pk_ptr, pk_len, &pk_ptr, &pk_len, &curve_id);
+	ret = get_plain_pk_from_asn1(pk_ptr, pk_len, &pk_ptr, &len, &curve_id);
 	if (ret != 0) {
 		VERBOSE("%s: get_plain_pk_from_asn1 (%d)\n", __func__, ret);
 		return CRYPTO_ERR_SIGNATURE;
 	}
 
 	/* We expect a known pk_len */
-	if (pk_len != sizeof(my_pk)) {
-		VERBOSE("%s: pk_len=%u sizeof(my_pk)=%zu)\n", __func__, pk_len, sizeof(my_pk));
+	if (len != sizeof(my_pk)) {
+		VERBOSE("%s: pk_len=%zu sizeof(my_pk)=%zu)\n", __func__, len, sizeof(my_pk));
 		return CRYPTO_ERR_SIGNATURE;
 	}
 
@@ -483,7 +492,7 @@ static int derive_key(uint8_t *key, size_t *key_len, size_t len,
 	/*
 	 * Not a real derivation yet
 	 *
-	 * But we expect a 32 bytes key, and OTP is only 16 bytes
+	 * We expect a 32 bytes key, if OTP is only 16 bytes
 	 *   => duplicate.
 	 */
 	for (i = 0U, j = len; j < 32U;
@@ -511,13 +520,12 @@ int plat_get_enc_key_info(enum fw_enc_status_t fw_enc_status, uint8_t *key,
 		return -EINVAL;
 	}
 
-	if (stm32_get_otp_index(ENCKEY_OTP, &otp_idx, &otp_len) != 0) {
-		VERBOSE("%s: get %s index error\n", __func__, ENCKEY_OTP);
+	if (stm32_get_enc_key_otp_idx_len(&otp_idx, &otp_len) != 0) {
 		return -EINVAL;
 	}
 
 	if (otp_len > (*key_len * CHAR_BIT)) {
-		VERBOSE("%s: length Error otp_len=%u key_len=%u\n", __func__,
+		VERBOSE("%s: length Error otp_len=%u key_len=%zu\n", __func__,
 			otp_len, *key_len * CHAR_BIT);
 		return -EINVAL;
 	}
diff --git a/plat/st/common/stm32mp_dt.c b/plat/st/common/stm32mp_dt.c
index c9efeb5334..7f0fffff67 100644
--- a/plat/st/common/stm32mp_dt.c
+++ b/plat/st/common/stm32mp_dt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2017-2023, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -79,11 +79,8 @@ uint8_t fdt_get_status(int node)
 	}
 
 	cchar = fdt_getprop(fdt, node, "secure-status", NULL);
-	if (cchar == NULL) {
-		if (status == DT_NON_SECURE) {
-			status |= DT_SECURE;
-		}
-	} else if (strncmp(cchar, "okay", strlen("okay")) == 0) {
+	if (((cchar == NULL) && (status == DT_NON_SECURE)) ||
+	    ((cchar != NULL) && (strncmp(cchar, "okay", strlen("okay")) == 0))) {
 		status |= DT_SECURE;
 	}
 
@@ -231,9 +228,9 @@ int dt_match_instance_by_compatible(const char *compatible, uintptr_t address)
  * This function gets DDR size information from the DT.
  * Returns value in bytes on success, and 0 on failure.
  ******************************************************************************/
-uint32_t dt_get_ddr_size(void)
+size_t dt_get_ddr_size(void)
 {
-	static uint32_t size;
+	static size_t size;
 	int node;
 
 	if (size != 0U) {
@@ -243,12 +240,16 @@ uint32_t dt_get_ddr_size(void)
 	node = fdt_node_offset_by_compatible(fdt, -1, DT_DDR_COMPAT);
 	if (node < 0) {
 		INFO("%s: Cannot read DDR node in DT\n", __func__);
-		return 0;
+		return 0U;
 	}
 
-	size = fdt_read_uint32_default(fdt, node, "st,mem-size", 0U);
+#ifdef __aarch64__
+	size = (size_t)fdt_read_uint64_default(fdt, node, "st,mem-size", 0ULL);
+#else /* __aarch64__ */
+	size = (size_t)fdt_read_uint32_default(fdt, node, "st,mem-size", 0U);
+#endif /* __aarch64__ */
 
-	flush_dcache_range((uintptr_t)&size, sizeof(uint32_t));
+	flush_dcache_range((uintptr_t)&size, sizeof(size_t));
 
 	return size;
 }
@@ -301,6 +302,32 @@ struct rdev *dt_get_cpu_regulator(void)
 	return regulator_get_by_supply_name(fdt, node, "cpu");
 }
 
+/*******************************************************************************
+ * This function retrieves SYSRAM supply regulator from DT.
+ * Returns an rdev taken from supply node, NULL otherwise.
+ ******************************************************************************/
+struct rdev *dt_get_sysram_regulator(void)
+{
+	int node;
+
+	fdt_for_each_compatible_node(fdt, node, DT_MMIO_SRAM) {
+		int len;
+		const fdt32_t *cuint = fdt_getprop(fdt, node, "reg", &len);
+
+		if (cuint != NULL) {
+			if (fdt32_to_cpu(*cuint) == STM32MP_SYSRAM_BASE) {
+				break;
+			}
+		}
+	}
+
+	if (node < 0) {
+		return NULL;
+	}
+
+	return regulator_get_by_supply_name(fdt, node, "vddcore");
+}
+
 /*******************************************************************************
  * This function retrieves board model from DT
  * Returns string taken from model node, NULL otherwise
@@ -350,7 +377,7 @@ int dt_find_otp_name(const char *name, uint32_t *otp, uint32_t *otp_len)
 		return -FDT_ERR_BADVALUE;
 	}
 
-	if (fdt32_to_cpu(*cuint) % sizeof(uint32_t)) {
+	if ((fdt32_to_cpu(*cuint) % sizeof(uint32_t)) != 0U) {
 		ERROR("Misaligned nvmem %s element: ignored\n", name);
 		return -FDT_ERR_BADVALUE;
 	}
@@ -367,6 +394,53 @@ int dt_find_otp_name(const char *name, uint32_t *otp, uint32_t *otp_len)
 	return 0;
 }
 
+/*
+ * dt_get_otp_by_phandle: return OTP id and OTP size for a given phandle
+ * phandle: phandle to be found
+ * otp_id: return value for the OTP id found
+ * otp_len: return value for the OTP len
+ * return: 0 if OTP found, a negative error value otherwise
+ */
+int dt_get_otp_by_phandle(const uint32_t phandle, uint32_t *otp_id, uint32_t *otp_len)
+{
+	int node;
+	int child;
+	const fdt32_t *cuint;
+	uint32_t offset;
+	bool otp_found = false;
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_BSEC_COMPAT);
+	if (node < 0) {
+		return node;
+	}
+
+	fdt_for_each_subnode(child, fdt, node) {
+		uint32_t ph = fdt_get_phandle(fdt, child);
+
+		if (ph == phandle) {
+			otp_found = true;
+			break;
+		}
+	}
+
+	if (!otp_found) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	cuint = fdt_getprop(fdt, child, "reg", NULL);
+	if (cuint == NULL) {
+		panic();
+	}
+
+	offset = fdt32_to_cpu(*cuint);
+	cuint++;
+	*otp_len = fdt32_to_cpu(*cuint);
+
+	*otp_id = offset / sizeof(uint32_t);
+
+	return 0;
+}
+
 /*******************************************************************************
  * This function gets the pin count for a GPIO bank based from the FDT.
  * It also checks node consistency.
@@ -386,7 +460,7 @@ int fdt_get_gpio_bank_pin_count(unsigned int bank)
 
 	fdt_for_each_subnode(node, fdt, pinctrl_node) {
 		const fdt32_t *cuint;
-		int pin_count;
+		int pin_count = 0;
 		int len;
 		int i;
 
@@ -415,11 +489,9 @@ int fdt_get_gpio_bank_pin_count(unsigned int bank)
 		}
 
 		/* Get the last defined gpio line (offset + nb of pins) */
-		pin_count = fdt32_to_cpu(*(cuint + 1)) + fdt32_to_cpu(*(cuint + 3));
-		for (i = 0; i < len / 4; i++) {
-			pin_count = MAX(pin_count, (int)(fdt32_to_cpu(*(cuint + 1)) +
-							 fdt32_to_cpu(*(cuint + 3))));
-			cuint += 4;
+		for (i = 0; i < len; i += 4) {
+			pin_count = MAX(pin_count, (int)(fdt32_to_cpu(cuint[i + 1]) +
+							 fdt32_to_cpu(cuint[i + 3])));
 		}
 
 		return pin_count;
diff --git a/plat/st/common/stm32mp_fconf_fuse.c b/plat/st/common/stm32mp_fconf_fuse.c
new file mode 100644
index 0000000000..5e7c1c3f3f
--- /dev/null
+++ b/plat/st/common/stm32mp_fconf_fuse.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <lib/fconf/fconf.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <stm32mp_fconf_getter.h>
+
+static int fconf_populate_stm32mp_fuse_provisioning(uintptr_t config)
+{
+	int node, child;
+
+	/* As libfdt uses void *, we can't avoid this cast */
+	const void *fdt = (void *)config;
+
+	/* Assert the node offset point to "st,provisioning" compatible property */
+	const char *compatible_str = "st,provisioning";
+
+	node = fdt_node_offset_by_compatible(fdt, -1, compatible_str);
+	if (node < 0) {
+		/* The node is not mandatory, just return */
+		return 0;
+	}
+
+	fdt_for_each_subnode(child, fdt, node) {
+		int rc;
+		const fdt32_t *cuint;
+		int shadow_len;
+		uint32_t phandle;
+		uint32_t otp_id;
+		uint32_t otp_len;
+		uint32_t otp_len_word;
+		unsigned int i;
+
+		cuint = fdt_getprop(fdt, child, "nvmem-cells", NULL);
+		if (cuint == NULL) {
+			panic();
+		}
+
+		phandle = fdt32_to_cpu(*cuint);
+		rc = dt_get_otp_by_phandle(phandle, &otp_id, &otp_len);
+		if (rc != 0) {
+			WARN("Phandle not found\n");
+			panic();
+		}
+
+		cuint = fdt_getprop(fdt, child, "st,shadow-value", &shadow_len);
+		if (cuint == NULL || shadow_len < 0 || (shadow_len % sizeof(uint32_t) != 0U)) {
+			panic();
+		}
+
+		otp_len_word = otp_len / sizeof(uint32_t);
+		if (otp_len % sizeof(uint32_t) != 0U) {
+			otp_len_word++;
+		}
+
+		if (otp_len_word != (shadow_len / sizeof(uint32_t))) {
+			WARN("Invalid OTP size\n");
+			panic();
+		}
+
+		for (i = 0U; i < otp_len_word; i++) {
+			uint32_t shadow_val;
+			uint32_t otp_val;
+			bool check_state;
+
+			if (stm32_otp_read_sw_lock(otp_id + i, &check_state) != BSEC_OK) {
+				panic();
+			}
+
+			if (check_state) {
+				WARN("Shadow write lock\n");
+				panic();
+			}
+
+			shadow_val = fdt32_to_cpu(*cuint++);
+
+			if (stm32_otp_shadow_read(&otp_val, otp_id + i) != BSEC_OK) {
+				panic();
+			}
+
+			if (otp_val != 0U) {
+				INFO("Override the OTP %u initial value\n", otp_id);
+			}
+
+			if (stm32_otp_write(otp_val | shadow_val, otp_id + i) != BSEC_OK) {
+				panic();
+			}
+		}
+	}
+
+	return 0;
+}
+
+FCONF_REGISTER_POPULATOR(TB_FW, stm32mp_fuse, fconf_populate_stm32mp_fuse_provisioning);
diff --git a/plat/st/common/stm32mp_fconf_io.c b/plat/st/common/stm32mp_fconf_io.c
index 0b6cc789cb..e12eded81f 100644
--- a/plat/st/common/stm32mp_fconf_io.c
+++ b/plat/st/common/stm32mp_fconf_io.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -27,12 +27,12 @@ static io_block_spec_t gpt_block_spec = {
 };
 #endif
 
-#if (STM32MP_SDMMC || STM32MP_EMMC) && PSA_FWU_SUPPORT
-io_block_spec_t metadata_block_spec = {
+#if PSA_FWU_SUPPORT
+static io_block_spec_t metadata_block_spec = {
 	.offset = 0,    /* To be filled at runtime */
 	.length = 0,    /* To be filled at runtime */
 };
-#endif /* (STM32MP_SDMMC || STM32MP_EMMC) && PSA_FWU_SUPPORT */
+#endif
 
 /* By default, STM32 platforms load images from the FIP */
 struct plat_io_policy policies[MAX_NUMBER_IDS] = {
@@ -58,7 +58,7 @@ struct plat_io_policy policies[MAX_NUMBER_IDS] = {
 		.check = open_storage
 	},
 #endif
-#if (STM32MP_SDMMC || STM32MP_EMMC) && PSA_FWU_SUPPORT
+#if PSA_FWU_SUPPORT
 	[FWU_METADATA_IMAGE_ID] = {
 		.dev_handle = &storage_dev_handle,
 		.image_spec = (uintptr_t)&metadata_block_spec,
@@ -71,19 +71,37 @@ struct plat_io_policy policies[MAX_NUMBER_IDS] = {
 		.img_type_guid = NULL_GUID,
 		.check = open_storage
 	},
-#endif /* (STM32MP_SDMMC || STM32MP_EMMC) && PSA_FWU_SUPPORT */
+#endif /* PSA_FWU_SUPPORT */
 };
 
 #define DEFAULT_UUID_NUMBER	U(7)
 
+#ifdef __aarch64__
+#define BL31_UUID_NUMBER	U(2)
+#else
+#define BL31_UUID_NUMBER	U(0)
+#endif
+
 #if TRUSTED_BOARD_BOOT
+#ifdef __aarch64__
+#define TBBR_UUID_NUMBER	U(8)
+#else
 #define TBBR_UUID_NUMBER	U(6)
+#endif
 #else
 #define TBBR_UUID_NUMBER	U(0)
 #endif
 
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define DDR_FW_UUID_NUMBER	U(1)
+#else
+#define DDR_FW_UUID_NUMBER	U(0)
+#endif
+
 #define FCONF_ST_IO_UUID_NUMBER	(DEFAULT_UUID_NUMBER + \
-				 TBBR_UUID_NUMBER)
+				 BL31_UUID_NUMBER + \
+				 TBBR_UUID_NUMBER + \
+				 DDR_FW_UUID_NUMBER)
 
 static io_uuid_spec_t fconf_stm32mp_uuids[FCONF_ST_IO_UUID_NUMBER];
 static OBJECT_POOL_ARRAY(fconf_stm32mp_uuids_pool, fconf_stm32mp_uuids);
@@ -95,7 +113,14 @@ struct policies_load_info {
 
 /* image id to property name table */
 static const struct policies_load_info load_info[FCONF_ST_IO_UUID_NUMBER] = {
+#if STM32MP_DDR_FIP_IO_STORAGE
+	{DDR_FW_ID, "ddr_fw_uuid"},
+#endif
 	{FW_CONFIG_ID, "fw_cfg_uuid"},
+#ifdef __aarch64__
+	{BL31_IMAGE_ID, "bl31_uuid"},
+	{SOC_FW_CONFIG_ID, "soc_fw_cfg_uuid"},
+#endif
 	{BL32_IMAGE_ID, "bl32_uuid"},
 	{BL32_EXTRA1_IMAGE_ID, "bl32_extra1_uuid"},
 	{BL32_EXTRA2_IMAGE_ID, "bl32_extra2_uuid"},
@@ -109,6 +134,10 @@ static const struct policies_load_info load_info[FCONF_ST_IO_UUID_NUMBER] = {
 	{NON_TRUSTED_FW_KEY_CERT_ID, "nt_fw_key_cert_uuid"},
 	{TRUSTED_OS_FW_CONTENT_CERT_ID, "tos_fw_content_cert_uuid"},
 	{NON_TRUSTED_FW_CONTENT_CERT_ID, "nt_fw_content_cert_uuid"},
+#ifdef __aarch64__
+	{SOC_FW_KEY_CERT_ID, "soc_fw_key_uuid"},
+	{SOC_FW_CONTENT_CERT_ID, "soc_fw_content_cert_uuid"},
+#endif
 #endif /* TRUSTED_BOARD_BOOT */
 };
 
@@ -160,6 +189,13 @@ int fconf_populate_stm32mp_io_policies(uintptr_t config)
 		uuid_ptr->uuid = uuid_helper.uuid_struct;
 		policies[load_info[i].image_id].image_spec = (uintptr_t)uuid_ptr;
 		switch (load_info[i].image_id) {
+#if ENCRYPT_BL31 && !defined(DECRYPTION_SUPPORT_none)
+		case BL31_IMAGE_ID:
+		case SOC_FW_CONFIG_ID:
+			policies[load_info[i].image_id].dev_handle = &enc_dev_handle;
+			policies[load_info[i].image_id].check = open_enc_fip;
+			break;
+#endif
 #if ENCRYPT_BL32 && !defined(DECRYPTION_SUPPORT_none)
 		case BL32_IMAGE_ID:
 		case BL32_EXTRA1_IMAGE_ID:
diff --git a/plat/st/stm32mp1/stm32mp1_gic.c b/plat/st/common/stm32mp_gic.c
similarity index 51%
rename from plat/st/stm32mp1/stm32mp1_gic.c
rename to plat/st/common/stm32mp_gic.c
index 851a9cf0c4..4cad7b0326 100644
--- a/plat/st/stm32mp1/stm32mp1_gic.c
+++ b/plat/st/common/stm32mp_gic.c
@@ -1,21 +1,20 @@
 /*
- * Copyright (c) 2016-2019, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2016-2023, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#include <libfdt.h>
-
-#include <platform_def.h>
-
 #include <common/bl_common.h>
 #include <common/debug.h>
 #include <drivers/arm/gicv2.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <lib/utils.h>
+#include <libfdt.h>
 #include <plat/common/platform.h>
 
-struct stm32_gic_instance {
+#include <platform_def.h>
+
+struct stm32mp_gic_instance {
 	uint32_t cells;
 	uint32_t phandle_node;
 };
@@ -24,7 +23,7 @@ struct stm32_gic_instance {
  * On a GICv2 system, the Group 1 secure interrupts are treated as Group 0
  * interrupts.
  *****************************************************************************/
-static const interrupt_prop_t stm32mp1_interrupt_props[] = {
+static const interrupt_prop_t stm32mp_interrupt_props[] = {
 	PLATFORM_G1S_PROPS(GICV2_INTR_GROUP0),
 	PLATFORM_G0_PROPS(GICV2_INTR_GROUP0)
 };
@@ -33,60 +32,90 @@ static const interrupt_prop_t stm32mp1_interrupt_props[] = {
 static unsigned int target_mask_array[PLATFORM_CORE_COUNT] = {1, 2};
 
 static gicv2_driver_data_t platform_gic_data = {
-	.interrupt_props = stm32mp1_interrupt_props,
-	.interrupt_props_num = ARRAY_SIZE(stm32mp1_interrupt_props),
+	.interrupt_props = stm32mp_interrupt_props,
+	.interrupt_props_num = ARRAY_SIZE(stm32mp_interrupt_props),
 	.target_masks = target_mask_array,
 	.target_masks_num = ARRAY_SIZE(target_mask_array),
 };
 
-static struct stm32_gic_instance stm32_gic;
+static struct stm32mp_gic_instance stm32mp_gic;
 
-void stm32mp1_gic_init(void)
+static gicv2_dist_ctx_t gicv2_dist_ctx;
+
+void stm32mp_gic_init(void)
 {
 	int node;
 	void *fdt;
 	const fdt32_t *cuint;
-	struct dt_node_info dt_gic;
 
 	if (fdt_get_address(&fdt) == 0) {
 		panic();
 	}
 
-	node = dt_get_node(&dt_gic, -1, "arm,cortex-a7-gic");
+	node = fdt_node_offset_by_compatible(fdt, -1, "arm,cortex-a7-gic");
 	if (node < 0) {
 		panic();
 	}
 
-	platform_gic_data.gicd_base = dt_gic.base;
-
 	cuint = fdt_getprop(fdt, node, "reg", NULL);
 	if (cuint == NULL) {
 		panic();
 	}
 
-	platform_gic_data.gicc_base = fdt32_to_cpu(*(cuint + 2));
+#ifdef __aarch64__
+	platform_gic_data.gicd_base = (uintptr_t)fdt32_to_cpu(cuint[0]) << 32;
+	platform_gic_data.gicd_base |= fdt32_to_cpu(cuint[1]);
+	platform_gic_data.gicc_base = (uintptr_t)fdt32_to_cpu(cuint[4]) << 32;
+	platform_gic_data.gicc_base |= fdt32_to_cpu(cuint[5]);
+#else /* __aarch64__ */
+	platform_gic_data.gicd_base = fdt32_to_cpu(cuint[0]);
+	platform_gic_data.gicc_base = fdt32_to_cpu(cuint[2]);
+#endif /* __aarch64__ */
 
 	cuint = fdt_getprop(fdt, node, "#interrupt-cells", NULL);
 	if (cuint == NULL) {
 		panic();
 	}
 
-	stm32_gic.cells = fdt32_to_cpu(*cuint);
+	stm32mp_gic.cells = fdt32_to_cpu(*cuint);
 
-	stm32_gic.phandle_node = fdt_get_phandle(fdt, node);
-	if (stm32_gic.phandle_node == 0U) {
+	stm32mp_gic.phandle_node = fdt_get_phandle(fdt, node);
+	if (stm32mp_gic.phandle_node == 0U) {
 		panic();
 	}
 
 	gicv2_driver_init(&platform_gic_data);
 	gicv2_distif_init();
 
-	stm32mp1_gic_pcpu_init();
+	stm32mp_gic_pcpu_init();
+	gicv2_cpuif_enable();
+}
+
+void stm32mp_gic_cpuif_enable(void)
+{
+	gicv2_cpuif_enable();
+}
+
+void stm32mp_gic_cpuif_disable(void)
+{
+	gicv2_cpuif_disable();
 }
 
-void stm32mp1_gic_pcpu_init(void)
+void stm32mp_gic_pcpu_init(void)
 {
 	gicv2_pcpu_distif_init();
 	gicv2_set_pe_target_mask(plat_my_core_pos());
-	gicv2_cpuif_enable();
+}
+
+void stm32mp_gic_save(void)
+{
+	gicv2_distif_save(&gicv2_dist_ctx);
+}
+
+void stm32mp_gic_resume(void)
+{
+	gicv2_distif_init();
+	stm32mp_gic_pcpu_init();
+
+	gicv2_distif_restore(&gicv2_dist_ctx);
 }
diff --git a/plat/st/common/stm32mp_svc_setup.c b/plat/st/common/stm32mp_svc_setup.c
new file mode 100644
index 0000000000..bb33dc81ce
--- /dev/null
+++ b/plat/st/common/stm32mp_svc_setup.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2014-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <drivers/scmi-msg.h>
+#include <lib/psci/psci.h>
+#include <platform_def.h>
+#include <tools_share/uuid.h>
+
+#include <stm32mp_svc_setup.h>
+
+/* STM32 SiP Service UUID */
+DEFINE_SVC_UUID2(stm32_sip_svc_uid,
+		 0xa778aa50, 0xf49b, 0x144a, 0x8a, 0x5e,
+		 0x26, 0x4d, 0x59, 0x94, 0xc2, 0x14);
+
+/* Setup STM32MP Standard Services */
+static int32_t stm32mp_svc_setup(void)
+{
+	/*
+	 * PSCI is the only specification implemented as a Standard Service.
+	 * Invoke PSCI setup from here.
+	 */
+	return 0;
+}
+
+/*
+ * Top-level Standard Service SMC handler. This handler will dispatch the SMC
+ * to the correct feature handler or default call a platform handler
+ */
+static uintptr_t stm32mp_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+					 u_register_t x2, u_register_t x3,
+					 u_register_t x4, void *cookie,
+					 void *handle, u_register_t flags)
+{
+	uint32_t ret1 = 0U, ret2 = 0U;
+	bool ret_uid = false, ret2_enabled = false;
+
+	switch (smc_fid) {
+	case STM32_SIP_SVC_UID:
+		/* Return UUID to the caller */
+		ret_uid = true;
+		break;
+
+	case STM32_SIP_SVC_VERSION:
+		/* Return the version of current implementation */
+		ret1 = STM32_SIP_SVC_VERSION_MAJOR;
+		ret2 = STM32_SIP_SVC_VERSION_MINOR;
+		ret2_enabled = true;
+		break;
+	default:
+		plat_svc_smc_handler(smc_fid, x1, x2, x3, x4, &ret1, &ret2, &ret2_enabled, flags);
+		break;
+	}
+
+	if (ret_uid) {
+		SMC_UUID_RET(handle, stm32_sip_svc_uid);
+	}
+
+	if (ret2_enabled) {
+		SMC_RET2(handle, ret1, ret2);
+	}
+
+	SMC_RET1(handle, ret1);
+}
+
+/* Register Standard Service Calls as runtime service */
+DECLARE_RT_SVC(stm32mp_sip_svc,
+	       OEN_SIP_START,
+	       OEN_SIP_END,
+	       SMC_TYPE_FAST,
+	       stm32mp_svc_setup,
+	       stm32mp_svc_smc_handler
+);
diff --git a/plat/st/common/stm32mp_trusted_boot.c b/plat/st/common/stm32mp_trusted_boot.c
index 051d6fcfb2..f19ed92e40 100644
--- a/plat/st/common/stm32mp_trusted_boot.c
+++ b/plat/st/common/stm32mp_trusted_boot.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,6 +10,7 @@
 
 #include <common/debug.h>
 #include <common/tbbr/cot_def.h>
+#include <drivers/clk.h>
 #include <drivers/st/stm32_hash.h>
 #include <lib/fconf/fconf.h>
 #include <lib/fconf/fconf_dyn_cfg_getter.h>
@@ -21,8 +22,6 @@
 #include <boot_api.h>
 #include <platform_def.h>
 
-#define HEADER_AND_EXT_TOTAL_SIZE 512
-
 static uint8_t der_sha256_header[] = {0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60,
 	0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20};
 static uint8_t root_pk_hash[HASH_DER_LEN];
@@ -66,14 +65,14 @@ static int copy_hash_from_otp(const char *otp_name, uint8_t *hash, size_t len)
 		 * Check if key hash values in OTP are 0 or 0xFFFFFFFFF
 		 * programmed : Invalid Key
 		 */
-		if (!stm32mp_is_closed_device() && !valid) {
+		if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_OPEN) && !valid) {
 			if ((tmp != 0U) && (tmp != 0xFFFFFFFFU) && (tmp != first)) {
 				valid = true;
 			}
 		}
 	}
 
-	if (!stm32mp_is_closed_device() && !valid) {
+	if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_OPEN) && !valid) {
 		return 0;
 	}
 
@@ -96,8 +95,7 @@ static int get_rotpk_hash(void *cookie, uint8_t *hash, size_t len)
 	uint32_t pk_idx = 0U;
 	uint8_t calc_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
 	uint8_t otp_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
-	boot_api_image_header_t *hdr = (boot_api_image_header_t *)(SRAM3_BASE + SRAM3_SIZE -
-								   HEADER_AND_EXT_TOTAL_SIZE);
+	boot_api_image_header_t *hdr = (boot_api_image_header_t *)stm32_get_header_address();
 	boot_extension_header_t *ext_header = (boot_extension_header_t *)hdr->ext_header;
 	boot_ext_header_params_authentication_t *param;
 
@@ -162,7 +160,7 @@ int plat_get_rotpk_info(void *cookie, void **key_ptr, unsigned int *key_len,
 	*key_ptr = &root_pk_hash;
 	*flags = ROTPK_IS_HASH;
 
-	if ((res == 0) && !stm32mp_is_closed_device()) {
+	if ((res == 0) && (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_OPEN)) {
 		*flags |= ROTPK_NOT_DEPLOYED;
 	}
 
@@ -171,16 +169,20 @@ int plat_get_rotpk_info(void *cookie, void **key_ptr, unsigned int *key_len,
 
 int plat_get_nv_ctr(void *cookie, unsigned int *nv_ctr)
 {
+	clk_enable(TAMP_BKP_REG_CLK);
 	*nv_ctr = mmio_read_32(TAMP_BASE + TAMP_COUNTR);
+	clk_disable(TAMP_BKP_REG_CLK);
 
 	return 0;
 }
 
 int plat_set_nv_ctr(void *cookie, unsigned int nv_ctr)
 {
+	clk_enable(TAMP_BKP_REG_CLK);
 	while (mmio_read_32(TAMP_BASE + TAMP_COUNTR) != nv_ctr) {
 		mmio_write_32(TAMP_BASE + TAMP_COUNTR, 1U);
 	}
+	clk_disable(TAMP_BKP_REG_CLK);
 
 	return 0;
 }
diff --git a/plat/st/stm32mp1/bl2_plat_setup.c b/plat/st/stm32mp1/bl2_plat_setup.c
index 4f04a6f03c..6752194bb8 100644
--- a/plat/st/stm32mp1/bl2_plat_setup.c
+++ b/plat/st/stm32mp1/bl2_plat_setup.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2024, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -12,19 +12,30 @@
 #include <common/bl_common.h>
 #include <common/debug.h>
 #include <common/desc_image_load.h>
+#include <drivers/clk.h>
 #include <drivers/generic_delay_timer.h>
 #include <drivers/mmc.h>
 #include <drivers/st/bsec.h>
+#include <drivers/st/nvmem.h>
 #include <drivers/st/regulator_fixed.h>
+#include <drivers/st/regulator_gpio.h>
 #include <drivers/st/stm32_iwdg.h>
+#if STM32MP13
+#include <drivers/st/stm32_mce.h>
+#endif
 #include <drivers/st/stm32_rng.h>
+#if STM32MP13
+#include <drivers/st/stm32_saes.h>
+#endif
 #include <drivers/st/stm32_uart.h>
+#include <drivers/st/stm32mp_reset.h>
 #include <drivers/st/stm32mp1_clk.h>
 #include <drivers/st/stm32mp1_pwr.h>
 #include <drivers/st/stm32mp1_ram.h>
 #include <drivers/st/stm32mp_pmic.h>
 #include <lib/fconf/fconf.h>
 #include <lib/fconf/fconf_dyn_cfg_getter.h>
+#include <libfdt.h>
 #include <lib/mmio.h>
 #include <lib/optee_utils.h>
 #include <lib/xlat_tables/xlat_tables_v2.h>
@@ -32,8 +43,18 @@
 
 #include <platform_def.h>
 #include <stm32mp_common.h>
+#include <stm32mp1_context.h>
 #include <stm32mp1_dbgmcu.h>
 
+#define PLL1_NOMINAL_FREQ_IN_KHZ	650000U /* 650MHz */
+
+#if !STM32MP1_OPTEE_IN_SYSRAM
+IMPORT_SYM(uintptr_t, __BSS_START__, BSS_START);
+IMPORT_SYM(uintptr_t, __BSS_END__, BSS_END);
+IMPORT_SYM(uintptr_t, __DATA_START__, DATA_START);
+IMPORT_SYM(uintptr_t, __DATA_END__, DATA_END);
+#endif
+
 #if DEBUG
 static const char debug_msg[] = {
 	"***************************************************\n"
@@ -157,6 +178,27 @@ void bl2_platform_setup(void)
 		panic();
 	}
 
+	if (!stm32mp1_ddr_is_restored()) {
+#if STM32MP15
+		struct nvmem_cell magic_number;
+		struct nvmem_cell branch_address;
+		uint32_t reg_val = 0;
+
+		stm32_get_magic_number_cell(&magic_number);
+		stm32_get_core1_branch_address_cell(&branch_address);
+
+		/* Clear backup register */
+		nvmem_cell_write(&branch_address, (uint8_t *)&reg_val,
+				 sizeof(reg_val));
+		/* Clear backup register magic */
+		nvmem_cell_write(&magic_number, (uint8_t *)&reg_val,
+				 sizeof(reg_val));
+#endif
+
+		/* Clear the context in BKPSRAM */
+		stm32_clean_context();
+	}
+
 	/* Map DDR for binary load, now with cacheable attribute */
 	ret = mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
 				      STM32MP_DDR_MAX_SIZE, MT_MEMORY | MT_RW | MT_SECURE);
@@ -202,35 +244,37 @@ static void update_monotonic_counter(void)
 }
 #endif
 
-void bl2_el3_plat_arch_setup(void)
+static void __maybe_unused handle_potential_tamper(uint32_t bit_off)
 {
-	const char *board_model;
-	boot_api_context_t *boot_context =
-		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
-	uintptr_t pwr_base;
-	uintptr_t rcc_base;
-
-	if (bsec_probe() != 0U) {
-		panic();
-	}
-
-	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
-			BL_CODE_END - BL_CODE_BASE,
-			MT_CODE | MT_SECURE);
+	/* Fixme: Add implementation specific logic here */
+	ERROR("Handling Potential tamper\n");
+	mmio_setbits_32(TAMP_BASE + TAMP_SCR, BIT_32(bit_off));
+}
 
-	/* Prevent corruption of preloaded Device Tree */
-	mmap_add_region(DTB_BASE, DTB_BASE,
-			DTB_LIMIT - DTB_BASE,
-			MT_RO_DATA | MT_SECURE);
+static void __maybe_unused handle_confirmed_tamper(uint32_t bit_off __unused)
+{
+	/* Fixme: Add implementation specific logic here */
+	ERROR("Handling Confirmed tamper\n");
+	panic();
+}
 
-	configure_mmu();
+static bool lse_tamper_detection(void)
+{
+	if ((mmio_read_32(TAMP_BASE + TAMP_SR) & TAMP_SR_LSE_MONITORING) != 0U) {
+		mmio_clrbits_32(RCC_BASE + RCC_BDCR, RCC_BDCR_LSECSSON);
+		mmio_clrbits_32(RCC_BASE + RCC_BDCR, RCC_BDCR_LSEON);
+		mmio_setbits_32(RCC_BASE + RCC_MP_CIFR, RCC_MP_CIFR_LSECSSF);
 
-	if (dt_open_and_check(STM32MP_DTB_BASE) < 0) {
-		panic();
+		return true;
 	}
 
-	pwr_base = stm32mp_pwr_base();
-	rcc_base = stm32mp_rcc_base();
+	return false;
+}
+
+static void reset_backup_domain(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
 
 	/*
 	 * Disable the backup domain write protection.
@@ -243,29 +287,103 @@ void bl2_el3_plat_arch_setup(void)
 		;
 	}
 
-	/* Reset backup domain on cold boot cases */
-	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCSRC_MASK) == 0U) {
+	/* Reset backup domain on cold boot cases or when LSE tamper occurred */
+	if (((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCCKEN) == 0U)) {
 		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
 
-		while ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST) ==
-		       0U) {
+		while ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST) == 0U) {
 			;
 		}
 
 		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
 	}
+}
+
+static void check_tamper_event(bool lse_tamper_occured)
+{
+	uint32_t sr = mmio_read_32(TAMP_BASE + TAMP_SR);
+
+	if (sr == 0U) {
+		return;
+	}
 
-#if STM32MP15
-	/* Disable MCKPROT */
-	mmio_clrbits_32(rcc_base + RCC_TZCR, RCC_TZCR_MCKPROT);
-#endif
+	ERROR("\n");
+	if (lse_tamper_occured) {
+		ERROR("** INTRUSION ALERT: LSE MONITORING TAMPER DETECTED **\n");
+		ERROR("\n");
+
+		/*
+		 * Fixme: Add logic to handle the LSE tamper here (e.g change RTC clock source
+		 * instead). This part is implementation specific.
+		 */
+		mmio_clrbits_32(RCC_BASE + RCC_BDCR, RCC_BDCR_RTCCKEN);
+		ERROR("** Rebooting... **\n");
+		stm32mp_system_reset();
+	} else {
+		while (sr != 0U) {
+			unsigned int bit_off = __builtin_ctz(sr);
+			bool is_internal = bit_off >= TAMP_SR_INT_SHIFT;
+			uint32_t cr2 __maybe_unused;
+			uint32_t cr3 __maybe_unused;
+
+			ERROR("** INTRUSION ALERT: %s TAMPER %u DETECTED **\n",
+			      is_internal ? "INTERNAL" : "EXTERNAL",
+			      is_internal ? (bit_off - TAMP_SR_INT_SHIFT + 1U) : (bit_off + 1U));
+
+#if STM32MP13
+			cr2 = mmio_read_32(TAMP_BASE + TAMP_CR2);
+			cr3 = mmio_read_32(TAMP_BASE + TAMP_CR3);
+
+			if ((is_internal && ((cr3 & BIT_32(bit_off >> TAMP_SR_INT_SHIFT)) != 0U)) ||
+			    (!is_internal && ((cr2 & BIT_32(bit_off)) != 0U))) {
+				handle_potential_tamper(bit_off);
+			} else {
+				handle_confirmed_tamper(bit_off);
+			}
+#endif /* STM32MP13 */
+
+			sr &= ~BIT_32(bit_off);
+		}
+		ERROR("\n");
+	}
+}
+
+void bl2_el3_plat_arch_setup(void)
+{
+	const char *board_model;
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+	bool lse_tamper_occured = false;
+
+	if (bsec_probe() != 0U) {
+		panic();
+	}
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_region(DTB_BASE, DTB_BASE,
+			DTB_LIMIT - DTB_BASE,
+			MT_RO_DATA | MT_SECURE);
+
+	configure_mmu();
+
+	if (dt_open_and_check(STM32MP_DTB_BASE) < 0) {
+		panic();
+	}
+
+	reset_backup_domain();
+
+	lse_tamper_occured = lse_tamper_detection();
 
 	/*
 	 * Set minimum reset pulse duration to 31ms for discrete power
 	 * supplied boards.
 	 */
 	if (dt_pmic_status() <= 0) {
-		mmio_clrsetbits_32(rcc_base + RCC_RDLSICR,
+		mmio_clrsetbits_32(stm32mp_rcc_base() + RCC_RDLSICR,
 				   RCC_RDLSICR_MRD_MASK,
 				   31U << RCC_RDLSICR_MRD_SHIFT);
 	}
@@ -286,14 +404,13 @@ void bl2_el3_plat_arch_setup(void)
 		panic();
 	}
 
-	if (stm32mp1_clk_init() < 0) {
+	if (stm32mp1_clk_init(PLL1_NOMINAL_FREQ_IN_KHZ) < 0) {
 		panic();
 	}
 
-	stm32_save_boot_interface(boot_context->boot_interface_selected,
-				  boot_context->boot_interface_instance);
-	stm32_save_boot_auth(boot_context->auth_status,
-			     boot_context->boot_partition_used_toboot);
+	stm32_tamp_nvram_init();
+
+	stm32_save_boot_info(boot_context);
 
 #if STM32MP_USB_PROGRAMMER && STM32MP15
 	/* Deconfigure all UART RX pins configured by ROM code */
@@ -304,6 +421,9 @@ void bl2_el3_plat_arch_setup(void)
 		goto skip_console_init;
 	}
 
+	/* Enter in boot mode */
+	stm32mp_syscfg_boot_mode_enable();
+
 	stm32mp_print_cpuinfo();
 
 	board_model = dt_get_board_model();
@@ -320,8 +440,10 @@ void bl2_el3_plat_arch_setup(void)
 	}
 
 skip_console_init:
+	check_tamper_event(lse_tamper_occured);
+
 #if !TRUSTED_BOARD_BOOT
-	if (stm32mp_is_closed_device()) {
+	if (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) {
 		/* Closed chip mandates authentication */
 		ERROR("Secure chip: TRUSTED_BOARD_BOOT must be enabled\n");
 		panic();
@@ -332,16 +454,23 @@ skip_console_init:
 		panic();
 	}
 
+#if (PLAT_NB_GPIO_REGUS > 0)
+	if (gpio_regulator_register() != 0) {
+		panic();
+	}
+#endif
+
 	if (dt_pmic_status() > 0) {
 		initialize_pmic();
-		if (pmic_voltages_init() != 0) {
+		if (!stm32mp_is_wakeup_from_standby() &&
+		    pmic_voltages_init() != 0) {
 			ERROR("PMIC voltages init failed\n");
 			panic();
 		}
 		print_pmic_info_and_debug();
 	}
 
-	stm32mp1_syscfg_init();
+	stm32mp_syscfg_init();
 
 	if (stm32_iwdg_init() < 0) {
 		panic();
@@ -350,7 +479,7 @@ skip_console_init:
 	stm32_iwdg_refresh();
 
 	if (bsec_read_debug_conf() != 0U) {
-		if (stm32mp_is_closed_device()) {
+		if (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) {
 #if DEBUG
 			WARN("\n%s", debug_msg);
 #else
@@ -370,16 +499,87 @@ skip_console_init:
 	print_reset_reason();
 
 #if STM32MP15
-	update_monotonic_counter();
+	if (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) {
+		update_monotonic_counter();
+	}
 #endif
 
-	stm32mp1_syscfg_enable_io_compensation_finish();
+	stm32mp_syscfg_enable_io_compensation_finish();
 
 	fconf_populate("TB_FW", STM32MP_DTB_BASE);
 
-	stm32mp_io_setup();
+	if (stm32mp_skip_boot_device_after_standby()) {
+		bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(FW_CONFIG_ID);
+
+		assert(bl_mem_params != NULL);
+
+		bl_mem_params->image_info.h.attr |= IMAGE_ATTRIB_SKIP_LOADING;
+	} else {
+		stm32mp_io_setup();
+	}
 }
 
+#if STM32MP13
+static int generate_mce_key_from_seed(uint8_t *mkey, uint8_t *seed, uint32_t seed_size){
+	int ret;
+	struct stm32_saes_context ctx;
+	uint8_t payload[MCE_KEY_SIZE_IN_BYTES] = {0U};
+
+	assert(seed_size <= MCE_KEY_SIZE_IN_BYTES);
+
+	ret = stm32_saes_driver_init();
+	if (ret != 0) {
+		return ret;
+	}
+
+	memcpy(payload, seed, seed_size); /* add seed in a block sized payload */
+
+	ret = stm32_saes_init(&ctx, false, STM32_SAES_MODE_ECB,
+			      STM32_SAES_KEY_DHU, NULL, MCE_KEY_SIZE_IN_BYTES, NULL, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return stm32_saes_update(&ctx, true, payload, mkey, sizeof(payload));
+}
+
+static void prepare_encryption(void)
+{
+	uint8_t mkey[MCE_KEY_SIZE_IN_BYTES];
+	uint8_t seed[MCE_SEED_SIZE_IN_BYTES];
+
+	stm32_mce_init();
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	if (stm32_rng_read(seed, MCE_SEED_SIZE_IN_BYTES) != 0) {
+		panic();
+	}
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+	if (stm32mp_is_wakeup_from_standby()) {
+		stm32mp1_pm_get_mce_seed_from_context(seed);
+		stm32_mce_reload_configuration();
+	} else {
+		/* Generate MCE master key seed from RNG */
+		if (stm32_rng_read(seed, MCE_SEED_SIZE_IN_BYTES) != 0) {
+			panic();
+		}
+
+		stm32mp1_pm_save_mce_seed_in_context(seed);
+	}
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+
+	if (generate_mce_key_from_seed(mkey, seed, MCE_SEED_SIZE_IN_BYTES) != 0) {
+		panic();
+	}
+
+	if (stm32_mce_write_master_key(mkey) != 0) {
+		panic();
+	}
+
+	stm32_mce_lock_master_key();
+}
+#endif
+
 /*******************************************************************************
  * This function can be used by the platforms to update/use image
  * information for given `image_id`.
@@ -396,6 +596,11 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 	unsigned int i;
 	unsigned int idx;
 	unsigned long long ddr_top __unused;
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	bool wakeup_ddr_sr = false;
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+	bool wakeup_ddr_sr = stm32mp1_ddr_is_restored();
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
 	const unsigned int image_ids[] = {
 		BL32_IMAGE_ID,
 		BL33_IMAGE_ID,
@@ -407,6 +612,16 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 
 	switch (image_id) {
 	case FW_CONFIG_ID:
+#if STM32MP13
+		if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) ||
+		    stm32mp_is_auth_supported()) {
+			prepare_encryption();
+		}
+#endif
+		if (stm32mp_skip_boot_device_after_standby()) {
+			return 0;
+		}
+
 		/* Set global DTB info for fixed fw_config information */
 		set_config_info(STM32MP_FW_CONFIG_BASE, ~0UL, STM32MP_FW_CONFIG_MAX_SIZE,
 				FW_CONFIG_ID);
@@ -431,7 +646,13 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 			bl_mem_params->image_info.image_base = config_info->config_addr;
 			bl_mem_params->image_info.image_max_size = config_info->config_max_size;
 
-			bl_mem_params->image_info.h.attr &= ~IMAGE_ATTRIB_SKIP_LOADING;
+			/*
+			 * If going back from CSTANDBY / STANDBY and DDR was in Self-Refresh,
+			 * DDR partitions must not be reloaded.
+			 */
+			if (!(wakeup_ddr_sr && (config_info->config_addr >= STM32MP_DDR_BASE))) {
+				bl_mem_params->image_info.h.attr &= ~IMAGE_ATTRIB_SKIP_LOADING;
+			}
 
 			switch (image_ids[i]) {
 			case BL32_IMAGE_ID:
@@ -448,15 +669,22 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 				paged_mem_params = get_bl_mem_params_node(BL32_EXTRA2_IMAGE_ID);
 				if (paged_mem_params != NULL) {
 					paged_mem_params->image_info.image_base = STM32MP_DDR_BASE +
-						(dt_get_ddr_size() - STM32MP_DDR_S_SIZE -
-						 STM32MP_DDR_SHMEM_SIZE);
+						(dt_get_ddr_size() - STM32MP_DDR_S_SIZE);
 					paged_mem_params->image_info.image_max_size =
 						STM32MP_DDR_S_SIZE;
 				}
 				break;
 
 			case BL33_IMAGE_ID:
-				bl_mem_params->ep_info.pc = config_info->config_addr;
+				if (wakeup_ddr_sr) {
+					/*
+					 * Set ep_info PC to 0, to inform BL32 it is a reset
+					 * after STANDBY
+					 */
+					bl_mem_params->ep_info.pc = 0U;
+				} else {
+					bl_mem_params->ep_info.pc = config_info->config_addr;
+				}
 				break;
 
 			case HW_CONFIG_ID:
@@ -470,11 +698,22 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 		break;
 
 	case BL32_IMAGE_ID:
+#if !STM32MP_UART_PROGRAMMER && !STM32MP_USB_PROGRAMMER
+		if (wakeup_ddr_sr && stm32mp_skip_boot_device_after_standby()) {
+			bl_mem_params->ep_info.pc = stm32_pm_get_optee_ep();
+			if (stm32mp1_addr_inside_backupsram(bl_mem_params->ep_info.pc)) {
+				clk_enable(BKPSRAM);
+			}
+			break;
+		}
+#endif /* !STM32MP_UART_PROGRAMMER && !STM32MP_USB_PROGRAMMER */
+
 		if (optee_header_is_valid(bl_mem_params->image_info.image_base)) {
 			image_info_t *paged_image_info = NULL;
 
 			/* BL32 is OP-TEE header */
 			bl_mem_params->ep_info.pc = bl_mem_params->image_info.image_base;
+
 			pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
 			assert(pager_mem_params != NULL);
 
@@ -509,6 +748,10 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 				tos_fw_mem_params->image_info.image_max_size;
 			bl_mem_params->ep_info.args.arg0 = 0;
 		}
+
+		if (bl_mem_params->ep_info.pc >= STM32MP_DDR_BASE) {
+			stm32_context_save_bl2_param();
+		}
 		break;
 
 	case BL33_IMAGE_ID:
@@ -516,7 +759,9 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 		assert(bl32_mem_params != NULL);
 		bl32_mem_params->ep_info.lr_svc = bl_mem_params->ep_info.pc;
 #if PSA_FWU_SUPPORT
-		stm32mp1_fwu_set_boot_idx();
+		if (plat_fwu_is_enabled()) {
+			stm32_fwu_set_boot_idx();
+		}
 #endif /* PSA_FWU_SUPPORT */
 		break;
 
@@ -543,20 +788,29 @@ int bl2_plat_handle_post_image_load(unsigned int image_id)
 
 void bl2_el3_plat_prepare_exit(void)
 {
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
 	uint16_t boot_itf = stm32mp_get_boot_itf_selected();
 
-	switch (boot_itf) {
-#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
-	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+	if ((boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) ||
+	    (boot_itf == BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB)) {
 		/* Invalidate the downloaded buffer used with io_memmap */
 		inv_dcache_range(DWL_BUFFER_BASE, DWL_BUFFER_SIZE);
-		break;
+	}
 #endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
-	default:
-		/* Do nothing in default case */
-		break;
+
+#if !STM32MP1_OPTEE_IN_SYSRAM
+	flush_dcache_range(BSS_START, BSS_END - BSS_START);
+	flush_dcache_range(DATA_START, DATA_END - DATA_START);
+#endif
+
+#if !defined(DECRYPTION_SUPPORT_none)
+	if (stm32_lock_enc_key_otp() != 0) {
+		panic();
 	}
+#endif
 
 	stm32mp1_security_setup();
+
+	/* end of boot mode */
+	stm32mp_syscfg_boot_mode_disable();
 }
diff --git a/plat/st/stm32mp1/cert_create_tbbr.mk b/plat/st/stm32mp1/cert_create_tbbr.mk
index 5b1a3ed949..dd402ec2ad 100644
--- a/plat/st/stm32mp1/cert_create_tbbr.mk
+++ b/plat/st/stm32mp1/cert_create_tbbr.mk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+# Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -7,6 +7,7 @@
 # Override TBBR Cert to update generic certificate
 
 $(eval $(call add_define,PDEF_CERTS))
+$(eval $(call add_define,PDEF_EXTS))
 
 PLAT_INCLUDE	+= -I${PLAT_DIR}include
 
diff --git a/plat/st/stm32mp1/include/boot_api.h b/plat/st/stm32mp1/include/boot_api.h
index 1054609a1e..4d92115c77 100644
--- a/plat/st/stm32mp1/include/boot_api.h
+++ b/plat/st/stm32mp1/include/boot_api.h
@@ -10,6 +10,102 @@
 #include <stdint.h>
 #include <stdio.h>
 
+/*
+ * Exported constants
+ */
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Possible value of boot context field 'boot_action'
+ */
+#if STM32MP13
+/* Boot action is Process Secure Boot */
+#define BOOT_API_CTX_BOOT_ACTION_SECURE_BOOT_PROCESS		0x7879598EUL
+/* Boot action is Process Wakeup from STANDBY  */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY			0x21276323UL
+/* Boot action is Process Engineering Boot */
+#define BOOT_API_CTX_BOOT_ACTION_ENGI_BOOT			0x4A05FE3AUL
+/* Boot Action is MPU P0 Local reset */
+#define BOOT_API_CTX_BOOT_ACTION_MPU_CORE0_RESET_PROCESS	0x0F6C12ABUL
+#endif
+#if STM32MP15
+/* Boot action is Process Cold Boot */
+#define BOOT_API_CTX_BOOT_ACTION_COLD_BOOT_PROCESS		0x09U
+/* Boot action is Process Wakeup from CSTANDBY */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY		0x0AU
+/* Boot action is Process Wakeup from STANDBY  */
+#define BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY			0x0BU
+/* Boot action is Process Engineering Boot */
+#define BOOT_API_CTX_BOOT_ACTION_ENGI_BOOT			0x0CU
+/* Boot Action is MPU P0 Local reset */
+#define BOOT_API_CTX_BOOT_ACTION_MPU_CORE0_RESET_PROCESS	0x0F
+#endif
+
+/*
+ * Possible value of boot context field 'stby_exit_status'
+ */
+
+/* The boot reason is not a STANDBY Exit reason */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_NO_STANDBY                0x00
+
+/* STANDBY Exit with MPU_BEN=1, MCU_BEN=0 */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MPU_ONLY             0x01
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MPU will go for cold boot
+ * MCU restarted by bootROM
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES            0x02
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MPU will go for cold boot
+ * but MCU restart aborted (code integrity check) : have not been restarted
+ * by bootROM
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES_MCU_ABT    0x03
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MPU gone to CSTANDBY,
+ * MCU restarted correctly by bootROM
+ * This value should never be read by FSBL, because not executed in that case
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY             0x04
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MCU restart aborted
+ * due code integrity check, then MPU will go for cold boot despite
+ * was not planned initially
+ */
+#define BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY_MCU_ABT     0x05
+
+/*
+ * STANDBY Exit with MPU_BEN=1, MCU_BEN=1, MCU restart aborted
+ * due to MCU security perimeter issue
+ */
+#define \
+BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_ALL_CORES_MCU_ABT_SEC_PERIMETER_ISSUE 0x06
+
+/*
+ * STANDBY Exit with MPU_BEN=0, MCU_BEN=1, MCU restart aborted
+ * due to MCU security perimeter issue, then MPU will go for cold boot
+ * despite was not planned initially
+ */
+#define \
+BOOT_API_CTX_STBY_EXIT_STATUS_WKUP_MCU_ONLY_MCU_ABT_SEC_PERIMETER_ISSUE	0x07
+
+/*
+ * Possible value of boot context field 'cstby_exit_status'
+ */
+/* The boot reason is not a CSTANDBY Exit reason */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_NO_CSTBY			0x00
+/* CSTANDBY Exit with MCU detected as Not running */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_MCU_NOT_RUNNING		0x01
+/* CSTANDBY Exit with MCU detected as Running  */
+#define BOOT_API_CTX_CSTBY_EXIT_STATUS_MCU_RUNNING		0x02
+
 /*
  * Possible value of boot context field 'auth_status'
  */
@@ -47,7 +143,7 @@
 #define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC		0x3U
 
 /* Boot occurred on QSPI NOR */
-#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_QSPI		0x4U
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI		0x4U
 
 /* Boot occurred on UART */
 #define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART		0x5U
@@ -56,7 +152,7 @@
 #define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB		0x6U
 
 /* Boot occurred on QSPI NAND */
-#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_QSPI		0x7U
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI		0x7U
 
 /**
  * @brief  Possible value of boot context field 'EmmcXferStatus'
@@ -82,6 +178,10 @@
 #define BOOT_API_CTX_EMMC_ERROR_STATUS_IMAGE_NOT_COMPLETE       0x7U
 #define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_ERROR                0x8U
 
+/* Definitions relative to 'p_rom_version_info->platform_type_ver' field */
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_IC_EMU_FPGA           0xAA
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_FPGA_ONLY             0xBB
+
 /* Image Header related definitions */
 
 /* Definition of header version */
@@ -160,6 +260,64 @@
 #define BOOT_API_A7_CORE0_MAGIC_NUMBER				0xCA7FACE0U
 #define BOOT_API_A7_CORE1_MAGIC_NUMBER				0xCA7FACE1U
 
+/*
+ * MCU Code Integrity Check related definitions
+ */
+
+/*
+ * Defines to identify RTC backup registers to be used for MCU code integrity
+ * check
+ */
+
+/*
+ * TAMP_BCK0R contains two bits
+ * bit 0 : wanted value of 'RCC_TZCR.TZEN'
+ * bit 1 : wanted value of 'RCC_TZCR.MCKPROT'
+ */
+
+/*
+ * TAMP_BCK0R bit position coding wanted value of 'RCC_TZCR.TZEN'
+ * trustZone aware domain enabling/disabling
+ */
+#define BOOT_API_MCIC_MCU_SECURITY_PERIMETER_TZEN_BIT			0
+
+/*
+ * TAMP_BCK0R bit position coding wanted value of 'RCC_TZCR.MCKPROT'
+ * ability of MCU to modify some clock settings in RCC
+ */
+#define BOOT_API_MCIC_MCU_SECURITY_PERIMETER_MCKPROT_BIT		1
+
+/* TAMP_BCK0R register index */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_TZEN_MCKPROT_TAMP_BCK_REG_IDX	0
+
+/*
+ * TAMP_BCK1R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR1'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR1_TAMP_BCK_REG_IDX	1
+
+/*
+ * TAMP_BCK2R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR2'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR2_TAMP_BCK_REG_IDX	2
+
+/*
+ * TAMP_BCK3R register index
+ * This register is coding the wanted value of register 'EXTI_TZENR3'
+ * to be programmed by bootROM on wakeup from STANDBY when MCUBEN=1
+ * that is MCU quick restart requested
+ */
+#define \
+BOOT_API_MCIC_MCU_SECURITY_PERIMETER_EXTI_TZENR3_TAMP_BCK_REG_IDX	3
+
 /*
  * TAMP_BCK4R register index
  * This register is used to write a Magic Number in order to restart
@@ -174,6 +332,39 @@
  */
 #define BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX		5U
 
+/*
+ * TAMP_BCK22R register index
+ * This register contains offset in bytes of code to Hash in RETRAM region
+ * Note : offset is intended as relative value from start of RETRAM
+ */
+#define \
+BOOT_API_MCIC_OFFSET_IN_BYTES_CODE_TO_HASH_RETRAM_TAMP_BCK_REG_IDX	22
+
+/*
+ * TAMP_BCK23R register index
+ * This register contains the size in bytes of the single consecutive region
+ * of MCU Firmware in RETRAM (Retention RAM) to hash (by SHA-256)
+ * Note : This is required as a MCU firmware Code Integrity Check (aka : MCIC)
+ * to avoid bootROM restarting MCU on a corrupted firmware
+ */
+#define \
+BOOT_API_MCIC_RETRAM_REGION_TO_HASH_IN_BYTES_TAMP_BCK_REG_IDX		23
+
+/*
+ * TAMP_BCK24R to TAMP_BCK31R register indexes
+ * Those registers contains SHA-256 digest of RETRAM MCU Firmware code between
+ * [(RETRAM_start + offset) -- (RETRAM_start + offset + size_to_hash)]
+ * in this order
+ * This is the MCU Code Integrity Check MCU Firmware signature
+ * value on 256 bits
+ */
+
+/* First TAMP_BKP index of MCU Firmware signature : ie TAMP_BCK24R */
+#define BOOT_API_MCIC_SHA_DIGEST_FIRST_TAMP_BCK_REG_IDX			24
+
+/* Last TAMP_BKP index of MCU Firmware signature : ie TAMP_BCK31R */
+#define BOOT_API_MCIC_SHA_DIGEST_LAST_TAMP_BCK_REG_IDX			31
+
 /*
  * Possible value of boot context field 'hse_clock_value_in_hz'
  */
@@ -200,6 +391,343 @@
 
 #define BOOT_API_RETURN_OK					0x77U
 
+/* Mapping of OTP Word and OTP bits managing SSP and useful to FSBL-SSP */
+#if STM32MP13
+/* OTP_CFG9 */
+#define BOOT_API_OTP_SSP_WORD_NB				9U
+/* SSP_REQ = OTP_CFG9[5] */
+#define BOOT_API_OTP_SSP_REQ_BIT_POS				5
+/* SSP_SUCCESS = OTP_CFG9[6] */
+#define BOOT_API_OTP_SSP_SUCCESS_BIT_POS			6
+#endif
+#if STM32MP15
+/* OTP_CFG8 */
+#define BOOT_API_OTP_SSP_WORD_NB				8U
+/* SSP_REQ = OTP_CFG8[8] */
+#define BOOT_API_OTP_SSP_REQ_BIT_POS				8
+/* SSP_SUCCESS = OTP_CFG8[9] */
+#define BOOT_API_OTP_SSP_SUCCESS_BIT_POS			9
+#endif
+
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd'
+ */
+/* 'K' 'B' 'U' 'P' -.> 'PUBK' */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK             0x4B425550
+
+#if STM32MP_SSP
+/* 'V' 'O' 'R' 'P' -.> 'PROV' */
+#define BOOT_API_CTX_SSP_CMD_PROV_SECRET		0x564F5250
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd' written by bootROM as Acknowledge
+ * of a request of SSP by FSBL.
+ */
+
+/* Written by bootROM on SSP error */
+#define BOOT_API_CTX_SSP_CMD_INVALID			0x00000000
+/*
+ * 'A' 'B' 'U' 'P' -.> 'PUBA' : ACK of ECIES_CHIP_PUBK calculation
+ * request by bootROM.
+ */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK_ACK		0x41425550
+/*
+ * 'A' 'O' 'R' 'P' -.> 'PROA' : ACK of OEM Secret Provisioning request
+ * by bootROM.
+ */
+#define BOOT_API_CTX_SSP_CMD_PROV_SECRET_ACK		0x414F5250
+
+/*
+ * Constants required for SSP
+ */
+/* '.' 'P' 'S' 'S' -.> 'SSP.' */
+#define BOOT_API_SSP_BLOB_LICENSE_TYPE_SSP_NORMAL	0x2E505353
+/* 'L' 'P' 'S' 'S' -.> 'SSPL' */
+#define BOOT_API_SSP_BLOB_LICENSE_TYPE_SSP_LIVE		0x4C505353
+/* version 1 */
+#define BOOT_API_SSP_LICENSE_LAYOUT_VERSION_TO_MATCH	0x00000001
+/* 'P' 'P' 'S' 'S' -.> 'SSPP' */
+#define BOOT_API_SSP_BLOB_PAYLOAD_MAGIC_SSP		0x50505353
+/* IV AES on 128 bits = 16 bytes and KEY AES on 128 bits = 16 bytes */
+#define BOOT_API_SSP_ENCRYPTED_IV_AND_KEY_SIZE_BYTES	32
+/* version 1 */
+#define BOOT_API_SSP_PAYLOAD_PROTOCOL_VERSION_TO_MATCH	0x00000001
+/*
+ * Scalar in Elliptic curve cryptography is an integer (often a Prime)
+ * the number of bytes of this scalar is defined below.
+ */
+#define BOOT_API_SSP_SCALAR_SIZE_BYTES				32
+
+/*
+ * In Elliptic curve cryptography coordinates of points are 2D P
+ * (Px, Py) as concatenation of two scalars.
+ */
+#define BOOT_API_SSP_EC_COORDINATE_SIZE_BYTES \
+	(2 * BOOT_API_SSP_SCALAR_SIZE_BYTES)
+
+/* In Elliptic curve cryptography Private Keys are scalars */
+#define BOOT_API_SSP_PRIVK_KEY_SIZE_BYTES \
+	BOOT_API_SSP_SCALAR_SIZE_BYTES
+
+/*
+ * In ECIES algorithm the Shared Secret (SS) is
+ * the x coordinate (Px) of a point P(Px,Py) obtained on reference
+ * chosen NIST-P256 Elliptic curve.
+ */
+#define BOOT_API_SSP_ECDH_SHARED_SECRET_SIZE_BYTES \
+	BOOT_API_SSP_SCALAR_SIZE_BYTES
+
+/*
+ * In Elliptic curve cryptography Public Keys are Points on chosen
+ * Elliptic curve P(x,y).
+ * Public Key is the x, y coordinates concatenated
+ * Ecies_eph_pubk and OEM_ECDSA_PUBK are each 64 bytes = 512 bits key
+ * sizes.
+ */
+#define BOOT_API_SSP_PUBK_KEY_SIZE_BYTES \
+	BOOT_API_SSP_EC_COORDINATE_SIZE_BYTES
+
+/*
+ * Size in bytes of ECIES_Chip_pubk obtained from bootROM at end of SSP
+ * phase 1 : Chip public key calculation.
+ */
+#define BOOT_API_SSP_ECIES_CHIP_PUBK_SIZE_BYTES \
+	BOOT_API_SSP_PUBK_KEY_SIZE_BYTES
+
+/* AES-GCM authentication tag size is 16 bytes = 128 bits */
+#define BOOT_API_SSP_AES_GCM_AUTH_TAG_SIZE_BYTES		16
+
+/* AES-GCM Symmetric Key size is 16 bytes = 128 bits */
+#define BOOT_API_SSP_AES_GCM_KEY_SIZE_BYTES			16
+
+/* AES-GCM Initialization Vector (IV) size is of 16 bytes = 128 bits */
+#define BOOT_API_SSP_AES_GCM_IV_SIZE_BYTES			16
+
+/*
+ * 88 bytes (license_type, live_session_id, license_version,
+ * fsbl_min_version, rfu[8], eph_ecies_pubk[])
+ */
+#define BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_LICENSE	88
+
+/*
+ * 32 bytes AAD License Secret from 2nd round KDF-SHA-256
+ * from ECDH Shared Secret hence KDF[32..63] aka "Authorization Token"
+ */
+#define BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_KDF	32
+
+/*
+ * Total License AAD size = 88 + 32 = 120 bytes
+ */
+#define BOOT_API_SSP_AES_GCM_LICENSE_AAD_SIZE_BYTES \
+	(BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_LICENSE + \
+	 BOOT_API_SSP_AES_GCM_LICENSE_AAD_NB_BYTES_FROM_KDF)
+
+/*
+ * AAD for Payload size : composed of :
+ * payload_magic, payload_protocol_version, oem_ecdsa_pubk[], oem_secret_size
+ * = 4 + 4 + 64 + 4 = 76 bytes AAD for Payload
+ */
+#define BOOT_API_SSP_AES_GCM_PAYLOAD_AAD_SIZE_BYTES		76
+
+/*
+ * OEM Secrets max size in bytes :
+ * [OTP[95:59] + OTP_CFG56 (RMA Unlock and Relock passwords)] x 4 bytes
+ * by OTP word = 152 bytes
+ */
+#define BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES			152
+
+/*
+ * Possible values of boot context field 'ssp_status'
+ * as can be read by FSBL-SSP
+ */
+#define BOOT_API_CTX_SSP_STATUS_NO_SSP				0
+#define BOOT_API_CTX_SSP_STATUS_CHIP_PUBK_CALC_FINISHED		1
+#define BOOT_API_CTX_SSP_STATUS_OEM_SEC_PROV_FINISHED		2
+#define BOOT_API_CTX_SSP_STATUS_OEM_SEC_PROV_FORBIDDEN		3
+
+/*
+ * Reserved size for future use
+ */
+#define BOOT_API_SSP_HSM_OEM_RFU_SIZE				8
+
+/*
+ * Exported types
+ */
+
+/*
+ * SSP related definitions
+ */
+/*
+ * SSP BLOB License structure : Binary Large OBject License structure
+ * Should be written by FSBL-SSP to provide bootROM with SSP OEM Secret
+ * provisioning.
+ * License information data, the structure is read by bootROM.
+ */
+typedef struct {
+	/*
+	 * License Type provided by HSM-OEM tool
+	 * should match Normal SSP License of Live SSP License.
+	 */
+	uint32_t license_type;
+
+	/* Live Session ID provided by HSM-OEM tool */
+	uint32_t live_session_id;
+
+	/*
+	 * Version of the License Protocol (Structure)
+	 * should be incremented each time a new.
+	 */
+	uint32_t license_version;
+
+	/*
+	 * Minimum FSBL version to be compared
+	 * with FSBL Header field 'imageVersion'.
+	 */
+	uint32_t fsbl_min_version;
+
+	/* RFU provided by HSM-OEM tool */
+	uint8_t  rfu[BOOT_API_SSP_HSM_OEM_RFU_SIZE];
+
+	/*
+	 * Ephemeral ECIES Public Key from HSM-OEM
+	 * 64 bytes = 512 bits.
+	 */
+	uint8_t  eph_ecies_pubk[BOOT_API_SSP_PUBK_KEY_SIZE_BYTES];
+
+	/*
+	 * Encrypted (IV,Key) : with Shared Secret based on
+	 * 'Ephemeral ECIES Key pair' and 'ECIES Chip Key pair'.
+	 */
+	uint8_t encrypted_iv_and_key
+		[BOOT_API_SSP_ENCRYPTED_IV_AND_KEY_SIZE_BYTES];
+
+	/*
+	 * AUTH_TAG AES-GCM from encryption of (IV, Key)
+	 * in HSM-OEM with License AAD scheme
+	 * License Tag is 16 bytes = 128 bits.
+	 */
+	uint8_t  license_tag[BOOT_API_SSP_AES_GCM_AUTH_TAG_SIZE_BYTES];
+
+} boot_api_ssp_blob_license_t;
+
+/*
+ * SSP BLOB Payload structure : Binary Large OBject Payload Structure
+ * Should be written by FSBL-SSP to provide bootROM with SSP OEM Secret
+ * provisioning input data, the structure is read by bootROM
+ * The BLOB Payload size is fixed to a max size of 244 bytes based
+ * on a max number of bytes of OEM secret derived from OTP upper free
+ * area in STM32MP15xx cut 2.0.In this table oem_encrypted_secrets[]
+ * of max size only the first 'p_blob_payload->oem_secret_size_bytes'
+ * bytes will be considered and used by bootROM.
+ */
+typedef struct {
+	/*
+	 * BLOB Payload Magic : for memory validity check of BLOB Payload
+	 * to match against BOOT_API_SSP_BLOB_PAYLOAD_MAGIC_SSP by bootROM.
+	 */
+	uint32_t payload_magic;
+
+	/*
+	 * SSP Payload protocol version : on 32 bits
+	 * to be checked by bootROM for equality with
+	 * BOOT_API_SSP_PAYLOAD_PROTOCOL_VERSION_TO_MATCH
+	 * ie : 0x00000001 : version 1 of SSP Payload
+	 */
+	uint32_t payload_protocol_version;
+
+#if STM32MP13
+	/* OEM_RPKTH OEM Root Public Key table hash is the
+	 * hash[ hash(algo + pubK i) for i=0..N-1] where N
+	 * is the number of OEM public keys in product for
+	 * key revocation feature
+	 *
+	 * N = 8 for STM32MP13xx
+	 * size of field = 32 bytes = 256 bits
+	 */
+	uint8_t  oem_rpkth[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+#endif
+#if STM32MP15
+	/*
+	 * OEM_ECDSA_PUBK Public Key defined by OEM
+	 * 64 bytes = 512 bits
+	 */
+	uint8_t  oem_ecdsa_pubk[BOOT_API_SSP_PUBK_KEY_SIZE_BYTES];
+#endif
+
+	/*
+	 * Size of Table of OEM Secrets encrypted with AES-GCM (Key,IV) from
+	 * License field 'encrypted_iv_and_key[]'
+	 * should be <= BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES:
+	 * is verified by bootROM.
+	 */
+	uint32_t oem_secret_size_bytes;
+
+	/*
+	 * AUTH_TAG AES-GCM computed by HSM-OEM when encrypting OEM Secrets with
+	 * (Key,IV) using special AAD scheme for Payload.
+	 * 16 bytes = 128 bits
+	 */
+	uint8_t  payload_tag[BOOT_API_SSP_AES_GCM_AUTH_TAG_SIZE_BYTES];
+
+	/*
+	 * OEM Secrets encrypted with AES-GCM (IV, Key) from
+	 * License field 'encrypted_iv_and_key[]'.
+	 * The payload size is 'oem_secret_size_bytes'
+	 * should be <= BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES =
+	 *  152 bytes : OEM Secrets max size in bytes :
+	 * [OTP_CFG56, OTP_CFG59, OTP_CFG60..95] x 4 bytes by OTP word.
+	 */
+	uint8_t oem_encrypted_secrets[BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES];
+
+} boot_api_ssp_blob_payload_t;
+#endif
+
+/* SSP Configuration structure */
+typedef struct {
+	/* SSP Command*/
+	uint32_t ssp_cmd;
+#if STM32MP_SSP
+	/* ECIES chip public key */
+	uint8_t *p_chip_pubk;
+	/* Blob License Address */
+	boot_api_ssp_blob_license_t *p_blob_license;
+	/* Blob Payload Address */
+	boot_api_ssp_blob_payload_t *p_blob_payload;
+	/* Secrets Decrypted Address */
+	uint8_t *p_ssp_oem_secrets_decrypted;
+	/* Reserved for Future Use (RFU) */
+	uint32_t padding_rfu;
+#else
+	uint8_t	reserved[20];
+#endif
+} boot_api_ssp_config_t;
+
+/*
+ * bootROM version information structure definition
+ * Total size = 24 bytes = 6 uint32_t
+ */
+typedef struct {
+	/* Chip Version */
+	uint32_t chip_ver;
+
+	/* Cut version within a fixed chip version */
+	uint32_t cut_ver;
+
+	/* Version of ROM Mask within a fixed cut version */
+	uint32_t rom_mask_ver;
+
+	/* Internal Version of bootROM code */
+	uint32_t bootrom_ver;
+
+	/* Version of bootROM adapted */
+	uint32_t for_chip_design_rtl_ver;
+
+	/* Restriction on compiled platform when it applies */
+	uint32_t platform_type_ver;
+
+} boot_api_rom_version_info_t;
+
 /*
  * Boot Context related definitions
  */
@@ -223,9 +751,27 @@ typedef struct {
 	uint32_t reserved1[13];
 #endif
 	uint32_t otp_afmux_values[3];
-	uint32_t reserved[3];
+	uint32_t reserved[2];
+	/*
+	 * Log to boot context, what was the kind of boot action
+	 * takes values from defines BOOT_API_BOOT_ACTION_XXX above
+	 */
+	uint32_t boot_action;
 #if STM32MP15
-	uint32_t reserved2[2];
+	/*
+	 * STANDBY Exit status to be checked by FSBL in case
+	 * field 'boot_action' == BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY
+	 * take values from defines above 'BOOT_API_CTX_STBY_EXIT_STATUS_XXX'
+	 * depending on encountered situation
+	 */
+	uint32_t stby_exit_status;
+	/*
+	 * CSTANDBY Exit status to be checked by FSBL in case
+	 * boot_action == BOOT_API_CTX_BOOT_ACTION_WAKEUP_CSTANDBY
+	 * take values from defines above 'BOOT_API_CTX_CSTBY_EXIT_STATUS_XXX'
+	 * depending on encountered situation
+	 */
+	uint32_t cstby_exit_status;
 #endif
 	uint32_t auth_status;
 
@@ -270,6 +816,21 @@ typedef struct {
 	 * ie FSBL partition on which the boot was successful
 	 */
 	uint32_t boot_partition_used_toboot;
+	/*
+	 * Address of SSP configuration structure :
+	 * given and defined by bootROM
+	 * and used by FSBL. The structure is of type
+	 * 'boot_api_ssp_config_t'
+	 */
+	boot_api_ssp_config_t *p_ssp_config;
+	/*
+	 * boot context field containing bootROM updated SSP Status
+	 * Values can be of type BOOT_API_CTX_SSP_STATUS_XXX
+	 */
+	uint32_t	ssp_status;
+
+	/* Pointer on ROM constant containing ROM information */
+	const boot_api_rom_version_info_t *p_rom_version_info;
 
 } __packed boot_api_context_t;
 
diff --git a/plat/st/stm32mp1/include/platform_def.h b/plat/st/stm32mp1/include/platform_def.h
index 61b847f6a7..75c8219a23 100644
--- a/plat/st/stm32mp1/include/platform_def.h
+++ b/plat/st/stm32mp1/include/platform_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -25,10 +25,6 @@
 #define PLATFORM_STACK_SIZE		0xC00
 #endif
 
-#define FIP_IMAGE_NAME			"fip"
-#define METADATA_PART_1			"metadata1"
-#define METADATA_PART_2			"metadata2"
-
 #define STM32MP_PRIMARY_CPU		U(0x0)
 #define STM32MP_SECONDARY_CPU		U(0x1)
 
diff --git a/plat/st/stm32mp1/include/stm32mp1_context.h b/plat/st/stm32mp1/include/stm32mp1_context.h
new file mode 100644
index 0000000000..42a00990a2
--- /dev/null
+++ b/plat/st/stm32mp1/include/stm32mp1_context.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2017-2022, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_CONTEXT_H
+#define STM32MP1_CONTEXT_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <drivers/st/stm32_mce.h>
+
+void stm32_clean_context(void);
+void stm32_context_save_bl2_param(void);
+uint32_t stm32_get_zdata_from_context(void);
+bool stm32_pm_context_is_valid(void);
+void stm32_restore_ddr_training_area(void);
+uint32_t stm32_pm_get_optee_ep(void);
+#if STM32MP13
+void stm32mp1_pm_save_mce_seed_in_context(uint8_t *data);
+void stm32mp1_pm_get_mce_seed_from_context(uint8_t *data);
+void stm32mp1_pm_save_mce_region(uint32_t index, struct stm32_mce_region_s *config);
+void stm32mp1_pm_get_mce_region(uint32_t index, struct stm32_mce_region_s *config);
+#endif
+
+#endif /* STM32MP1_CONTEXT_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_critic_power.h b/plat/st/stm32mp1/include/stm32mp1_critic_power.h
new file mode 100644
index 0000000000..0ce8733e4f
--- /dev/null
+++ b/plat/st/stm32mp1/include/stm32mp1_critic_power.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2019-2021, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP1_CRITIC_POWER_H
+#define STM32MP1_CRITIC_POWER_H
+
+extern void stm32_pwr_down_wfi_wrapper(bool is_cstop, uint32_t mode);
+extern void stm32_pwr_back_from_stop2(void);
+void stm32_pwr_down_wfi_load(bool is_cstop, uint32_t mode);
+void stm32_pwr_call_optee_ep(void);
+void stm32_pwr_cstop_critic_exit(void);
+
+#endif /* STM32MP1_CRITIC_POWER_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_private.h b/plat/st/stm32mp1/include/stm32mp1_private.h
index 21ef60d0a8..7054c2ce5c 100644
--- a/plat/st/stm32mp1/include/stm32mp1_private.h
+++ b/plat/st/stm32mp1/include/stm32mp1_private.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,25 +14,53 @@ void configure_mmu(void);
 void stm32mp1_arch_security_setup(void);
 void stm32mp1_security_setup(void);
 
-void stm32mp1_gic_pcpu_init(void);
-void stm32mp1_gic_init(void);
+bool stm32mp1_addr_inside_backupsram(uintptr_t addr);
 
-void stm32mp1_syscfg_init(void);
-void stm32mp1_syscfg_enable_io_compensation_start(void);
-void stm32mp1_syscfg_enable_io_compensation_finish(void);
-void stm32mp1_syscfg_disable_io_compensation(void);
-uint32_t stm32mp1_syscfg_get_chip_version(void);
-uint32_t stm32mp1_syscfg_get_chip_dev_id(void);
+void stm32mp_syscfg_init(void);
+void stm32mp_syscfg_enable_io_compensation_start(void);
+void stm32mp_syscfg_enable_io_compensation_finish(void);
+void stm32mp_syscfg_disable_io_compensation(void);
+uint32_t stm32mp_syscfg_get_chip_version(void);
+uint32_t stm32mp_syscfg_get_chip_dev_id(void);
 #if STM32MP13
-void stm32mp1_syscfg_boot_mode_enable(void);
-void stm32mp1_syscfg_boot_mode_disable(void);
+void stm32mp_syscfg_boot_mode_enable(void);
+void stm32mp_syscfg_boot_mode_disable(void);
 #endif
 #if STM32MP15
-static inline void stm32mp1_syscfg_boot_mode_enable(void){}
-static inline void stm32mp1_syscfg_boot_mode_disable(void){}
+static inline void stm32mp_syscfg_boot_mode_enable(void){}
+static inline void stm32mp_syscfg_boot_mode_disable(void){}
 #endif
 
 void stm32mp1_deconfigure_uart_pins(void);
 
 void stm32mp1_init_scmi_server(void);
+
+bool stm32mp_bkpram_get_access(void);
+
+/* Wrappers for OTP / BSEC functions */
+static inline uint32_t stm32_otp_read(uint32_t *val, uint32_t otp)
+{
+	return bsec_read_otp(val, otp);
+}
+
+static inline uint32_t stm32_otp_shadow_read(uint32_t *val, uint32_t otp)
+{
+	return bsec_shadow_read_otp(val, otp);
+}
+
+static inline uint32_t stm32_otp_write(uint32_t val, uint32_t otp)
+{
+	return bsec_write_otp(val, otp);
+}
+
+static inline uint32_t stm32_otp_set_sr_lock(uint32_t otp)
+{
+	return bsec_set_sr_lock(otp);
+}
+
+static inline uint32_t stm32_otp_read_sw_lock(uint32_t otp, bool *value)
+{
+	return bsec_read_sw_lock(otp, value);
+}
+
 #endif /* STM32MP1_PRIVATE_H */
diff --git a/plat/st/stm32mp1/include/stm32mp1_smc.h b/plat/st/stm32mp1/include/stm32mp1_smc.h
index 52088de28a..bcb19dd0de 100644
--- a/plat/st/stm32mp1/include/stm32mp1_smc.h
+++ b/plat/st/stm32mp1/include/stm32mp1_smc.h
@@ -39,16 +39,6 @@
 #define STM32_SIP_SMC_SCMI_AGENT0	0x82002000
 #define STM32_SIP_SMC_SCMI_AGENT1	0x82002001
 
-/* SMC function IDs for SiP Service queries */
-#define STM32_SIP_SVC_CALL_COUNT	0x8200ff00
-#define STM32_SIP_SVC_UID		0x8200ff01
-/*					0x8200ff02 is reserved */
-#define STM32_SIP_SVC_VERSION		0x8200ff03
-
-/* STM32 SiP Service Calls version numbers */
-#define STM32_SIP_SVC_VERSION_MAJOR	0x0
-#define STM32_SIP_SVC_VERSION_MINOR	0x1
-
 /* Number of STM32 SiP Calls implemented */
 #define STM32_COMMON_SIP_NUM_CALLS	3
 
@@ -58,10 +48,4 @@
 #define STM32_SMC_WRITE_SHADOW		0x03
 #define STM32_SMC_READ_OTP		0x04
 
-/* SMC error codes */
-#define STM32_SMC_OK			0x00000000U
-#define STM32_SMC_NOT_SUPPORTED		0xFFFFFFFFU
-#define STM32_SMC_FAILED		0xFFFFFFFEU
-#define STM32_SMC_INVALID_PARAMS	0xFFFFFFFDU
-
 #endif /* STM32MP1_SMC_H */
diff --git a/plat/st/stm32mp1/plat_bl2_mem_params_desc.c b/plat/st/stm32mp1/plat_bl2_mem_params_desc.c
index 9ca09307f4..9f1a3e588f 100644
--- a/plat/st/stm32mp1/plat_bl2_mem_params_desc.c
+++ b/plat/st/stm32mp1/plat_bl2_mem_params_desc.c
@@ -119,7 +119,11 @@ static bl_mem_params_node_t bl2_mem_params_descs[] = {
 				      VERSION_2, entry_point_info_t,
 				      NON_SECURE | EXECUTABLE),
 
+#if BL33_HYP
+		.ep_info.spsr = SPSR_MODE32(MODE32_hyp, SPSR_T_ARM,
+#else
 		.ep_info.spsr = SPSR_MODE32(MODE32_svc, SPSR_T_ARM,
+#endif
 					    SPSR_E_LITTLE,
 					    DISABLE_ALL_EXCEPTIONS),
 
diff --git a/plat/st/stm32mp1/plat_ddr.c b/plat/st/stm32mp1/plat_ddr.c
new file mode 100644
index 0000000000..8ed5b54364
--- /dev/null
+++ b/plat/st/stm32mp1/plat_ddr.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <drivers/st/regulator.h>
+#include <drivers/st/stm32mp_ddr.h>
+#include <drivers/st/stm32mp_pmic.h>
+
+/* configure the STPMIC1 regulators on STMicroelectronics boards */
+static int pmic_ddr_power_init(enum ddr_type ddr_type)
+{
+	int status;
+	uint16_t buck3_min_mv __unused;
+	struct rdev *buck2, *buck3 __unused, *vref;
+	struct rdev *ldo3 __unused;
+
+	buck2 = regulator_get_by_name("buck2");
+	if (buck2 == NULL) {
+		return -ENOENT;
+	}
+
+#if STM32MP15
+	ldo3 = regulator_get_by_name("ldo3");
+	if (ldo3 == NULL) {
+		return -ENOENT;
+	}
+#endif
+
+	vref = regulator_get_by_name("vref_ddr");
+	if (vref == NULL) {
+		return -ENOENT;
+	}
+
+	switch (ddr_type) {
+	case STM32MP_DDR3:
+#if STM32MP15
+		status = regulator_set_flag(ldo3, REGUL_SINK_SOURCE);
+		if (status != 0) {
+			return status;
+		}
+#endif
+
+		status = regulator_set_min_voltage(buck2);
+		if (status != 0) {
+			return status;
+		}
+
+		status = regulator_enable(buck2);
+		if (status != 0) {
+			return status;
+		}
+
+		status = regulator_enable(vref);
+		if (status != 0) {
+			return status;
+		}
+
+#if STM32MP15
+		status = regulator_enable(ldo3);
+		if (status != 0) {
+			return status;
+		}
+#endif
+		break;
+
+	case STM32MP_LPDDR2:
+	case STM32MP_LPDDR3:
+#if STM32MP15
+		/*
+		 * Set LDO3 to 1.8V according  BUCK3 voltage
+		 * => bypass mode if BUCK3 = 1.8V
+		 * => normal mode if BUCK3 != 1.8V
+		 */
+		buck3 = regulator_get_by_name("buck3");
+		if (buck3 == NULL) {
+			return -ENOENT;
+		}
+
+		regulator_get_range(buck3, &buck3_min_mv, NULL);
+
+		if (buck3_min_mv != 1800) {
+			status = regulator_set_min_voltage(ldo3);
+			if (status != 0) {
+				return status;
+			}
+		} else {
+			status = regulator_set_flag(ldo3, REGUL_ENABLE_BYPASS);
+			if (status != 0) {
+				return status;
+			}
+		}
+#endif
+
+		status = regulator_set_min_voltage(buck2);
+		if (status != 0) {
+			return status;
+		}
+
+#if STM32MP15
+		status = regulator_enable(ldo3);
+		if (status != 0) {
+			return status;
+		}
+#endif
+
+		status = regulator_enable(buck2);
+		if (status != 0) {
+			return status;
+		}
+
+		status = regulator_enable(vref);
+		if (status != 0) {
+			return status;
+		}
+		break;
+
+	default:
+		break;
+	};
+
+	return 0;
+}
+
+int stm32mp_board_ddr_power_init(enum ddr_type ddr_type)
+{
+	if (dt_pmic_status() > 0) {
+		return pmic_ddr_power_init(ddr_type);
+	}
+
+	return 0;
+}
diff --git a/plat/st/stm32mp1/plat_image_load.c b/plat/st/stm32mp1/plat_image_load.c
index c4048fc08e..c455544629 100644
--- a/plat/st/stm32mp1/plat_image_load.c
+++ b/plat/st/stm32mp1/plat_image_load.c
@@ -5,6 +5,7 @@
  */
 
 #include <common/desc_image_load.h>
+#include <plat/common/platform.h>
 
 /*******************************************************************************
  * This function flushes the data structures so that they are visible
diff --git a/plat/st/stm32mp1/platform.mk b/plat/st/stm32mp1/platform.mk
index 7eecf30407..9d9e08082e 100644
--- a/plat/st/stm32mp1/platform.mk
+++ b/plat/st/stm32mp1/platform.mk
@@ -1,31 +1,19 @@
 #
-# Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2023, Arm Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
 
+# Extra partitions used to find FIP, contains:
+# metadata (2) and the FIP partitions (default is 2).
+STM32_EXTRA_PARTS	:=	4
+
+include plat/st/common/common.mk
+
 ARM_CORTEX_A7		:=	yes
 ARM_WITH_NEON		:=	yes
-BL2_AT_EL3		:=	1
 USE_COHERENT_MEM	:=	0
 
-STM32MP_EARLY_CONSOLE	?=	0
-STM32MP_RECONFIGURE_CONSOLE ?=	0
-STM32MP_UART_BAUDRATE	?=	115200
-
-TRUSTED_BOARD_BOOT	?=	0
-STM32MP_USE_EXTERNAL_HEAP ?=	0
-
-# Use secure library from the ROM code for authentication
-STM32MP_CRYPTO_ROM_LIB	?=	0
-
-# Please don't increment this value without good understanding of
-# the monotonic counter
-STM32_TF_VERSION	?=	0
-
-# Enable dynamic memory mapping
-PLAT_XLAT_TABLES_DYNAMIC :=	1
-
 # Default Device tree
 DTB_FILE_NAME		?=	stm32mp157c-ev1.dtb
 
@@ -66,6 +54,9 @@ endif
 # STM32 image header version v2.0
 STM32_HEADER_VERSION_MAJOR:=	2
 STM32_HEADER_VERSION_MINOR:=	0
+
+# OP-TEE cannot be in SYSRAM on STM32MP13
+override STM32MP1_OPTEE_IN_SYSRAM :=	0
 endif
 
 ifeq ($(STM32MP15),1)
@@ -76,53 +67,31 @@ STM32MP_DDR_32BIT_INTERFACE:=	1
 # STM32 image header version v1.0
 STM32_HEADER_VERSION_MAJOR:=	1
 STM32_HEADER_VERSION_MINOR:=	0
-
-# Add OP-TEE reserved shared memory area in mapping
-STM32MP15_OPTEE_RSV_SHM	:=	1
-$(eval $(call add_defines,STM32MP15_OPTEE_RSV_SHM))
-
 STM32MP_CRYPTO_ROM_LIB :=	1
 
+STM32MP1_OPTEE_IN_SYSRAM ?=	0
+
 # Decryption support
 ifneq ($(DECRYPTION_SUPPORT),none)
 $(error "DECRYPTION_SUPPORT not supported on STM32MP15")
 endif
 endif
 
-# STM32 image header binary type for BL2
-STM32_HEADER_BL2_BINARY_TYPE:=	0x10
+PKA_USE_NIST_P256	?=	0
+PKA_USE_BRAINPOOL_P256T1 ?=	0
+
+# STM32 Secure Secret Provisioning mode (SSP)
+STM32MP_SSP		?=	0
 
 ifeq ($(AARCH32_SP),sp_min)
 # Disable Neon support: sp_min runtime may conflict with non-secure world
 TF_CFLAGS		+=	-mfloat-abi=soft
 endif
 
-TF_CFLAGS		+=	-Wsign-compare
-TF_CFLAGS		+=	-Wformat-signedness
-
 # Not needed for Cortex-A7
 WORKAROUND_CVE_2017_5715:=	0
 WORKAROUND_CVE_2022_23960:=	0
 
-# Number of TF-A copies in the device
-STM32_TF_A_COPIES		:=	2
-
-# PLAT_PARTITION_MAX_ENTRIES must take care of STM32_TF-A_COPIES and other partitions
-# such as metadata (2) to find all the FIP partitions (default is 2).
-PLAT_PARTITION_MAX_ENTRIES	:=	$(shell echo $$(($(STM32_TF_A_COPIES) + 4)))
-
-ifeq (${PSA_FWU_SUPPORT},1)
-# Number of banks of updatable firmware
-NR_OF_FW_BANKS			:=	2
-NR_OF_IMAGES_IN_FW_BANK		:=	1
-
-FWU_MAX_PART = $(shell echo $$(($(STM32_TF_A_COPIES) + 2 + $(NR_OF_FW_BANKS))))
-ifeq ($(shell test $(FWU_MAX_PART) -gt $(PLAT_PARTITION_MAX_ENTRIES); echo $$?),0)
-$(error "Required partition number is $(FWU_MAX_PART) where PLAT_PARTITION_MAX_ENTRIES is only \
-$(PLAT_PARTITION_MAX_ENTRIES)")
-endif
-endif
-
 ifeq ($(STM32MP13),1)
 STM32_HASH_VER		:=	4
 STM32_RNG_VER		:=	4
@@ -131,21 +100,12 @@ STM32_HASH_VER		:=	2
 STM32_RNG_VER		:=	2
 endif
 
-# Boot devices
-STM32MP_EMMC		?=	0
-STM32MP_SDMMC		?=	0
-STM32MP_RAW_NAND	?=	0
-STM32MP_SPI_NAND	?=	0
-STM32MP_SPI_NOR		?=	0
-STM32MP_EMMC_BOOT	?=	0
-
-# Serial boot devices
-STM32MP_USB_PROGRAMMER	?=	0
-STM32MP_UART_PROGRAMMER	?=	0
-
 # Download load address for serial boot devices
 DWL_BUFFER_BASE 	?=	0xC7000000
 
+# Hypervisor mode
+BL33_HYP			?= 0
+
 # Device tree
 ifeq ($(STM32MP13),1)
 BL2_DTSI		:=	stm32mp13-bl2.dtsi
@@ -159,42 +119,34 @@ FDT_SOURCES		+=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl32.dts,$(D
 endif
 endif
 
-$(eval DTC_V = $(shell $(DTC) -v | awk '{print $$NF}'))
-$(eval DTC_VERSION = $(shell printf "%d" $(shell echo ${DTC_V} | cut -d- -f1 | sed "s/\./0/g" | grep -o "[0-9]*")))
-DTC_CPPFLAGS		+=	${INCLUDES}
-DTC_FLAGS		+=	-Wno-unit_address_vs_reg
-ifeq ($(shell test $(DTC_VERSION) -ge 10601; echo $$?),0)
-DTC_FLAGS		+=	-Wno-interrupt_provider
+ifneq (,$(wildcard fdts/$(patsubst %.dtb,%.dts,$(DTB_FILE_NAME))))
+DT_SOURCE_PATH		:=	fdts
+else
+ifneq (,$(wildcard $(TFA_EXTERNAL_DT)/$(patsubst %.dtb,%.dts,$(DTB_FILE_NAME))))
+DT_SOURCE_PATH		:=	$(TFA_EXTERNAL_DT)
+else
+$(error Cannot find $(patsubst %.dtb,%.dts,$(DTB_FILE_NAME)) file)
+endif
 endif
 
 # Macros and rules to build TF binary
-STM32_TF_ELF_LDFLAGS	:=	--hash-style=gnu --as-needed
 STM32_TF_STM32		:=	$(addprefix ${BUILD_PLAT}/tf-a-, $(patsubst %.dtb,%.stm32,$(DTB_FILE_NAME)))
-STM32_TF_LINKERFILE	:=	${BUILD_PLAT}/stm32mp1.ld
+STM32_LD_FILE		:=	plat/st/stm32mp1/stm32mp1.ld.S
+STM32_BINARY_MAPPING	:=	plat/st/stm32mp1/stm32mp1.S
 
-ASFLAGS			+= -DBL2_BIN_PATH=\"${BUILD_PLAT}/bl2.bin\"
 ifeq ($(AARCH32_SP),sp_min)
 # BL32 is built only if using SP_MIN
 BL32_DEP		:= bl32
 ASFLAGS			+= -DBL32_BIN_PATH=\"${BUILD_PLAT}/bl32.bin\"
 endif
 
-# Variables for use with stm32image
-STM32IMAGEPATH		?= tools/stm32image
-STM32IMAGE		?= ${STM32IMAGEPATH}/stm32image${BIN_EXT}
-STM32IMAGE_SRC		:= ${STM32IMAGEPATH}/stm32image.c
-
-FIP_DEPS		+=	dtbs
-STM32MP_HW_CONFIG	:=	${BL33_CFG}
 STM32MP_FW_CONFIG_NAME	:=	$(patsubst %.dtb,%-fw-config.dtb,$(DTB_FILE_NAME))
 STM32MP_FW_CONFIG	:=	${BUILD_PLAT}/fdts/$(STM32MP_FW_CONFIG_NAME)
 ifneq (${AARCH32_SP},none)
-FDT_SOURCES		+=	$(addprefix fdts/, $(patsubst %.dtb,%.dts,$(STM32MP_FW_CONFIG_NAME)))
+FDT_SOURCES		+=	$(addprefix $(DT_SOURCE_PATH)/, $(patsubst %.dtb,%.dts,$(STM32MP_FW_CONFIG_NAME)))
 endif
 # Add the FW_CONFIG to FIP and specify the same to certtool
 $(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_FW_CONFIG},--fw-config))
-# Add the HW_CONFIG to FIP and specify the same to certtool
-$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_HW_CONFIG},--hw-config))
 ifeq ($(GENERATE_COT),1)
 STM32MP_CFG_CERT	:=	$(BUILD_PLAT)/stm32mp_cfg_cert.crt
 # Add the STM32MP_CFG_CERT to FIP and specify the same to certtool
@@ -203,40 +155,22 @@ endif
 ifeq ($(AARCH32_SP),sp_min)
 STM32MP_TOS_FW_CONFIG	:= $(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl32.dtb,$(DTB_FILE_NAME)))
 $(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_TOS_FW_CONFIG},--tos-fw-config))
-else
-# Add the build options to pack Trusted OS Extra1 and Trusted OS Extra2 images
-# in the FIP if the platform requires.
-ifneq ($(BL32_EXTRA1),)
-$(eval $(call TOOL_ADD_IMG,BL32_EXTRA1,--tos-fw-extra1,,$(ENCRYPT_BL32)))
-endif
-ifneq ($(BL32_EXTRA2),)
-$(eval $(call TOOL_ADD_IMG,BL32_EXTRA2,--tos-fw-extra2,,$(ENCRYPT_BL32)))
-endif
 endif
 
 # Enable flags for C files
 $(eval $(call assert_booleans,\
 	$(sort \
+		BL33_HYP \
 		PKA_USE_BRAINPOOL_P256T1 \
 		PKA_USE_NIST_P256 \
-		PLAT_TBBR_IMG_DEF \
-		PLAT_XLAT_TABLES_DYNAMIC \
 		STM32MP_CRYPTO_ROM_LIB \
 		STM32MP_DDR_32BIT_INTERFACE \
 		STM32MP_DDR_DUAL_AXI_PORT \
-		STM32MP_EARLY_CONSOLE \
-		STM32MP_EMMC \
-		STM32MP_EMMC_BOOT \
-		STM32MP_RAW_NAND \
-		STM32MP_RECONFIGURE_CONSOLE \
-		STM32MP_SDMMC \
-		STM32MP_SPI_NAND \
-		STM32MP_SPI_NOR \
-		STM32MP_UART_PROGRAMMER \
-		STM32MP_USB_PROGRAMMER \
+		STM32MP_SSP \
 		STM32MP_USE_EXTERNAL_HEAP \
 		STM32MP13 \
 		STM32MP15 \
+		STM32MP1_OPTEE_IN_SYSRAM \
 )))
 
 $(eval $(call assert_numerics,\
@@ -246,52 +180,34 @@ $(eval $(call assert_numerics,\
 		STM32_HEADER_VERSION_MAJOR \
 		STM32_RNG_VER \
 		STM32_TF_A_COPIES \
-		STM32_TF_VERSION \
-		STM32MP_UART_BAUDRATE \
 )))
 
 $(eval $(call add_defines,\
 	$(sort \
+		BL33_HYP \
 		DWL_BUFFER_BASE \
 		PKA_USE_BRAINPOOL_P256T1 \
 		PKA_USE_NIST_P256 \
 		PLAT_PARTITION_MAX_ENTRIES \
 		PLAT_TBBR_IMG_DEF \
-		PLAT_XLAT_TABLES_DYNAMIC \
 		STM32_HASH_VER \
 		STM32_HEADER_VERSION_MAJOR \
 		STM32_RNG_VER \
 		STM32_TF_A_COPIES \
-		STM32_TF_VERSION \
 		STM32MP_CRYPTO_ROM_LIB \
 		STM32MP_DDR_32BIT_INTERFACE \
 		STM32MP_DDR_DUAL_AXI_PORT \
-		STM32MP_EARLY_CONSOLE \
-		STM32MP_EMMC \
-		STM32MP_EMMC_BOOT \
-		STM32MP_RAW_NAND \
-		STM32MP_RECONFIGURE_CONSOLE \
-		STM32MP_SDMMC \
-		STM32MP_SPI_NAND \
-		STM32MP_SPI_NOR \
-		STM32MP_UART_BAUDRATE \
-		STM32MP_UART_PROGRAMMER \
-		STM32MP_USB_PROGRAMMER \
+		STM32MP_SSP \
 		STM32MP_USE_EXTERNAL_HEAP \
 		STM32MP13 \
 		STM32MP15 \
+		STM32MP1_OPTEE_IN_SYSRAM \
 )))
 
 # Include paths and source files
-PLAT_INCLUDES		:=	-Iplat/st/common/include/
 PLAT_INCLUDES		+=	-Iplat/st/stm32mp1/include/
 
-include lib/fconf/fconf.mk
-include lib/libfdt/libfdt.mk
-
-PLAT_BL_COMMON_SOURCES	:=	common/uuid.c						\
-				plat/st/common/stm32mp_common.c				\
-				plat/st/stm32mp1/stm32mp1_private.c
+PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp1/stm32mp1_private.c
 
 PLAT_BL_COMMON_SOURCES	+=	drivers/st/uart/aarch32/stm32_console.S
 
@@ -299,255 +215,96 @@ ifneq (${ENABLE_STACK_PROTECTOR},0)
 PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp1/stm32mp1_stack_protector.c
 endif
 
-include lib/xlat_tables_v2/xlat_tables.mk
-PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
-
 PLAT_BL_COMMON_SOURCES	+=	lib/cpus/aarch32/cortex_a7.S
 
 PLAT_BL_COMMON_SOURCES	+=	drivers/arm/tzc/tzc400.c				\
-				drivers/clk/clk.c					\
-				drivers/delay_timer/delay_timer.c			\
-				drivers/delay_timer/generic_delay_timer.c		\
 				drivers/st/bsec/bsec2.c					\
-				drivers/st/clk/stm32mp_clkfunc.c			\
-				drivers/st/ddr/stm32mp_ddr.c				\
 				drivers/st/ddr/stm32mp1_ddr_helpers.c			\
-				drivers/st/gpio/stm32_gpio.c				\
 				drivers/st/i2c/stm32_i2c.c				\
 				drivers/st/iwdg/stm32_iwdg.c				\
 				drivers/st/pmic/stm32mp_pmic.c				\
 				drivers/st/pmic/stpmic1.c				\
-				drivers/st/regulator/regulator_core.c			\
-				drivers/st/regulator/regulator_fixed.c			\
 				drivers/st/reset/stm32mp1_reset.c			\
-				plat/st/common/stm32mp_dt.c				\
+				plat/st/stm32mp1/stm32mp1_context.c			\
 				plat/st/stm32mp1/stm32mp1_dbgmcu.c			\
 				plat/st/stm32mp1/stm32mp1_helper.S			\
 				plat/st/stm32mp1/stm32mp1_syscfg.c
 
+PLAT_BL_COMMON_SOURCES  +=	drivers/st/nvmem/stm32mp_tamp_nvram_mp1.c
+
 ifeq ($(STM32MP13),1)
 PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/clk-stm32-core.c				\
 				drivers/st/clk/clk-stm32mp13.c				\
-				drivers/st/crypto/stm32_rng.c
+				drivers/st/crypto/stm32_rng.c				\
+				drivers/st/crypto/stm32_saes.c
 else
 PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/stm32mp1_clk.c
 endif
 
-BL2_SOURCES		+=	${FCONF_SOURCES} ${FCONF_DYN_SOURCES}
-
-BL2_SOURCES		+=	drivers/io/io_fip.c					\
-				plat/st/common/bl2_io_storage.c				\
-				plat/st/common/stm32mp_fconf_io.c			\
-				plat/st/stm32mp1/plat_bl2_mem_params_desc.c		\
+BL2_SOURCES		+=	plat/st/stm32mp1/plat_bl2_mem_params_desc.c		\
 				plat/st/stm32mp1/stm32mp1_fconf_firewall.c
 
-include lib/zlib/zlib.mk
-
-ifeq (${PSA_FWU_SUPPORT},1)
-include drivers/fwu/fwu.mk
-endif
-
-
-BL2_SOURCES		+=	$(ZLIB_SOURCES)
-
-BL2_SOURCES		+=	drivers/io/io_block.c					\
-				drivers/io/io_mtd.c					\
-				drivers/io/io_storage.c					\
-				drivers/st/crypto/stm32_hash.c				\
+BL2_SOURCES		+=	drivers/st/crypto/stm32_hash.c				\
 				plat/st/stm32mp1/bl2_plat_setup.c
 
-ifneq (${DECRYPTION_SUPPORT},none)
-BL2_SOURCES		+=	drivers/io/io_encrypted.c
+ifeq ($(STM32MP13),1)
+BL2_SOURCES		+=	drivers/st/mce/stm32_mce.c
 endif
 
 ifeq (${TRUSTED_BOARD_BOOT},1)
-AUTH_SOURCES		:=	drivers/auth/auth_mod.c					\
-				drivers/auth/crypto_mod.c				\
-				drivers/auth/img_parser_mod.c
-
-ifeq (${GENERATE_COT},1)
-TFW_NVCTR_VAL		:=	0
-NTFW_NVCTR_VAL		:=	0
-KEY_SIZE		:=
-KEY_ALG			:=	ecdsa
-HASH_ALG		:=	sha256
-
-ifeq (${SAVE_KEYS},1)
-TRUSTED_WORLD_KEY	?=	${BUILD_PLAT}/trusted.pem
-NON_TRUSTED_WORLD_KEY	?=	${BUILD_PLAT}/non-trusted.pem
-BL32_KEY		?=	${BUILD_PLAT}/trusted_os.pem
-BL33_KEY		?=	${BUILD_PLAT}/non-trusted_os.pem
-endif
-
-endif
-TF_MBEDTLS_KEY_ALG 	:=	ecdsa
-MBEDTLS_CONFIG_FILE	?=	"<stm32mp1_mbedtls_config.h>"
-
-include drivers/auth/mbedtls/mbedtls_x509.mk
-
-COT_DESC_IN_DTB		:=	1
-AUTH_SOURCES		+=	lib/fconf/fconf_cot_getter.c				\
-				lib/fconf/fconf_tbbr_getter.c				\
-				plat/st/common/stm32mp_crypto_lib.c
-
 ifeq ($(STM32MP13),1)
-AUTH_SOURCES		+=	drivers/st/crypto/stm32_pka.c
-AUTH_SOURCES		+=	drivers/st/crypto/stm32_saes.c
+BL2_SOURCES		+=	drivers/st/crypto/stm32_pka.c
 endif
-
-BL2_SOURCES		+=	$(AUTH_SOURCES)						\
-				plat/st/common/stm32mp_trusted_boot.c
 endif
 
 ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
-BL2_SOURCES		+=	drivers/mmc/mmc.c					\
-				drivers/partition/gpt.c					\
-				drivers/partition/partition.c				\
-				drivers/st/io/io_mmc.c					\
-				drivers/st/mmc/stm32_sdmmc2.c
+BL2_SOURCES		+=	drivers/st/mmc/stm32_sdmmc2.c
 endif
 
 ifeq (${STM32MP_RAW_NAND},1)
-$(eval $(call add_define_val,NAND_ONFI_DETECT,1))
-BL2_SOURCES		+=	drivers/mtd/nand/raw_nand.c				\
-				drivers/st/fmc/stm32_fmc2_nand.c
-endif
-
-ifeq (${STM32MP_SPI_NAND},1)
-BL2_SOURCES		+=	drivers/mtd/nand/spi_nand.c
-endif
-
-ifeq (${STM32MP_SPI_NOR},1)
-ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
-$(eval $(call add_define_val,STM32MP_NOR_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
-endif
-BL2_SOURCES		+=	drivers/mtd/nor/spi_nor.c
+BL2_SOURCES		+=	drivers/st/fmc/stm32_fmc2_nand.c
 endif
 
 ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
-BL2_SOURCES		+=	drivers/mtd/spi-mem/spi_mem.c				\
-				drivers/st/spi/stm32_qspi.c
-endif
-
-ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND}),)
-ifneq (${STM32MP_FORCE_MTD_START_OFFSET},)
-$(eval $(call add_define_val,STM32MP_NAND_FIP_OFFSET,${STM32MP_FORCE_MTD_START_OFFSET}))
-endif
-BL2_SOURCES		+=	drivers/mtd/nand/core.c
+BL2_SOURCES		+=	drivers/st/spi/stm32_qspi.c
 endif
 
 ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR}),)
 BL2_SOURCES		+=	plat/st/stm32mp1/stm32mp1_boot_device.c
 endif
 
-ifneq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
-BL2_SOURCES		+=	drivers/io/io_memmap.c
-endif
-
 ifeq (${STM32MP_UART_PROGRAMMER},1)
-BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c				\
-				plat/st/common/stm32cubeprogrammer_uart.c
+BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c
 endif
 
 ifeq (${STM32MP_USB_PROGRAMMER},1)
 #The DFU stack uses only one end point, reduce the USB stack footprint
 $(eval $(call add_define_val,CONFIG_USBD_EP_NB,1U))
 BL2_SOURCES		+=	drivers/st/usb/stm32mp1_usb.c				\
-				drivers/usb/usb_device.c				\
-				plat/st/common/stm32cubeprogrammer_usb.c		\
-				plat/st/common/usb_dfu.c					\
 				plat/st/stm32mp1/stm32mp1_usb_dfu.c
 endif
 
-BL2_SOURCES		+=	drivers/st/ddr/stm32mp_ddr_test.c			\
-				drivers/st/ddr/stm32mp_ram.c				\
-				drivers/st/ddr/stm32mp1_ddr.c				\
+BL2_SOURCES		+=	drivers/st/ddr/stm32mp1_ddr.c				\
 				drivers/st/ddr/stm32mp1_ram.c
 
-BL2_SOURCES		+=	common/desc_image_load.c				\
-				plat/st/stm32mp1/plat_image_load.c
-
-BL2_SOURCES		+=	lib/optee/optee_utils.c
-
-# Compilation rules
-.PHONY: check_dtc_version stm32image clean_stm32image check_boot_device
-.SUFFIXES:
-
-all: check_dtc_version stm32image ${STM32_TF_STM32}
+BL2_SOURCES		+=	plat/st/stm32mp1/plat_ddr.c
 
-distclean realclean clean: clean_stm32image
+BL2_SOURCES		+=	plat/st/stm32mp1/plat_image_load.c
 
-bl2: check_boot_device
+BL2_SOURCES		+=	plat/st/stm32mp1/stm32mp1_critic_power.c
+BL2_SOURCES		+=	plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
 
-check_boot_device:
-	@if [ ${STM32MP_EMMC} != 1 ] && \
-	    [ ${STM32MP_SDMMC} != 1 ] && \
-	    [ ${STM32MP_RAW_NAND} != 1 ] && \
-	    [ ${STM32MP_SPI_NAND} != 1 ] && \
-	    [ ${STM32MP_SPI_NOR} != 1 ] && \
-	    [ ${STM32MP_UART_PROGRAMMER} != 1 ] && \
-	    [ ${STM32MP_USB_PROGRAMMER} != 1 ]; then \
-		echo "No boot device driver is enabled"; \
-		false; \
-	fi
-
-stm32image: ${STM32IMAGE}
-
-${STM32IMAGE}: ${STM32IMAGE_SRC}
-	${Q}${MAKE} CPPFLAGS="" --no-print-directory -C ${STM32IMAGEPATH}
-
-clean_stm32image:
-	${Q}${MAKE} --no-print-directory -C ${STM32IMAGEPATH} clean
-
-check_dtc_version:
-	@if [ ${DTC_VERSION} -lt 10404 ]; then \
-		echo "dtc version too old (${DTC_V}), you need at least version 1.4.4"; \
-		false; \
-	fi
-
-# Create DTB file for BL2
-${BUILD_PLAT}/fdts/%-bl2.dts: fdts/%.dts fdts/${BL2_DTSI} | ${BUILD_PLAT} fdt_dirs
-	@echo '#include "$(patsubst fdts/%,%,$<)"' > $@
-	@echo '#include "${BL2_DTSI}"' >> $@
-
-${BUILD_PLAT}/fdts/%-bl2.dtb: ${BUILD_PLAT}/fdts/%-bl2.dts
+ifeq ($(STM32MP_SSP),1)
+include plat/st/stm32mp1/stm32mp1_ssp.mk
+endif
 
 ifeq ($(AARCH32_SP),sp_min)
 # Create DTB file for BL32
-${BUILD_PLAT}/fdts/%-bl32.dts: fdts/%.dts fdts/${BL32_DTSI} | ${BUILD_PLAT} fdt_dirs
+${BUILD_PLAT}/fdts/%-bl32.dts: $(DT_SOURCE_PATH)/%.dts fdts/${BL32_DTSI} | ${BUILD_PLAT} fdt_dirs
 	@echo '#include "$(patsubst fdts/%,%,$<)"' > $@
 	@echo '#include "${BL32_DTSI}"' >> $@
 
 ${BUILD_PLAT}/fdts/%-bl32.dtb: ${BUILD_PLAT}/fdts/%-bl32.dts
 endif
 
-${BUILD_PLAT}/stm32mp1-%.o: ${BUILD_PLAT}/fdts/%-bl2.dtb plat/st/stm32mp1/stm32mp1.S bl2
-	@echo "  AS      stm32mp1.S"
-	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
-		-DDTB_BIN_PATH=\"$<\" \
-		-c plat/st/stm32mp1/stm32mp1.S -o $@
-
-$(eval $(call MAKE_LD,${STM32_TF_LINKERFILE},plat/st/stm32mp1/stm32mp1.ld.S,bl2))
-
-tf-a-%.elf: stm32mp1-%.o ${STM32_TF_LINKERFILE}
-	@echo "  LDS     $<"
-	${Q}${LD} -o $@ ${STM32_TF_ELF_LDFLAGS} -Map=$(@:.elf=.map) --script ${STM32_TF_LINKERFILE} $<
-
-tf-a-%.bin: tf-a-%.elf
-	${Q}${OC} -O binary $< $@
-	@echo
-	@echo "Built $@ successfully"
-	@echo
-
-tf-a-%.stm32: ${STM32IMAGE} tf-a-%.bin
-	@echo
-	@echo "Generate $@"
-	$(eval LOADADDR = $(shell cat $(@:.stm32=.map) | grep RAM | awk '{print $$2}'))
-	$(eval ENTRY = $(shell cat $(@:.stm32=.map) | grep "__BL2_IMAGE_START" | awk '{print $$1}'))
-	${Q}${STM32IMAGE} -s $(word 2,$^) -d $@ \
-		-l $(LOADADDR) -e ${ENTRY} \
-		-v ${STM32_TF_VERSION} \
-		-m ${STM32_HEADER_VERSION_MAJOR} \
-		-n ${STM32_HEADER_VERSION_MINOR} \
-		-b ${STM32_HEADER_BL2_BINARY_TYPE}
-	@echo
+include plat/st/common/common_rules.mk
diff --git a/plat/st/stm32mp1/services/bsec_svc.c b/plat/st/stm32mp1/services/bsec_svc.c
index 1fb44b4879..fa8be81bd4 100644
--- a/plat/st/stm32mp1/services/bsec_svc.c
+++ b/plat/st/stm32mp1/services/bsec_svc.c
@@ -10,7 +10,9 @@
 #include <drivers/st/bsec.h>
 #include <drivers/st/bsec2_reg.h>
 
+#include <stm32mp_svc_setup.h>
 #include <stm32mp1_smc.h>
+#include <stm32mp_svc_setup.h>
 
 #include "bsec_svc.h"
 
@@ -39,12 +41,7 @@ uint32_t bsec_main(uint32_t x1, uint32_t x2, uint32_t x3,
 			break;
 		}
 
-		result = bsec_shadow_register(x2);
-		if (result != BSEC_OK) {
-			break;
-		}
-
-		result = bsec_read_otp(ret_otp_value, x2);
+		result = bsec_shadow_read_otp(ret_otp_value, x2);
 		if (result != BSEC_OK) {
 			break;
 		}
diff --git a/plat/st/stm32mp1/services/stm32mp1_svc_setup.c b/plat/st/stm32mp1/services/stm32mp1_svc_setup.c
index ed8a448b39..113128da0b 100644
--- a/plat/st/stm32mp1/services/stm32mp1_svc_setup.c
+++ b/plat/st/stm32mp1/services/stm32mp1_svc_setup.c
@@ -13,57 +13,28 @@
 #include <lib/psci/psci.h>
 #include <tools_share/uuid.h>
 
+#include <stm32mp_svc_setup.h>
 #include <stm32mp1_smc.h>
 
 #include "bsec_svc.h"
 
-/* STM32 SiP Service UUID */
-DEFINE_SVC_UUID2(stm32_sip_svc_uid,
-		 0xa778aa50, 0xf49b, 0x144a, 0x8a, 0x5e,
-		 0x26, 0x4d, 0x59, 0x94, 0xc2, 0x14);
-
-/* Setup STM32MP1 Standard Services */
-static int32_t stm32mp1_svc_setup(void)
-{
-	/*
-	 * PSCI is the only specification implemented as a Standard Service.
-	 * Invoke PSCI setup from here.
-	 */
-	return 0;
-}
-
 /*
- * Top-level Standard Service SMC handler. This handler will in turn dispatch
- * calls to PSCI SMC handler.
+ * Platform Standard Service SMC handler. This handler will dispatch
+ * calls to features handlers.
  */
-static uintptr_t stm32mp1_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
-					  u_register_t x2, u_register_t x3,
-					  u_register_t x4, void *cookie,
-					  void *handle, u_register_t flags)
+void plat_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+			  u_register_t x2, u_register_t x3,
+			  u_register_t x4, uint32_t *ret1,
+			  uint32_t *ret2, bool *ret2_enabled,
+			  u_register_t flags)
 {
-	uint32_t ret1 = 0U, ret2 = 0U;
-	bool ret_uid = false, ret2_enabled = false;
-
 	switch (smc_fid) {
 	case STM32_SIP_SVC_CALL_COUNT:
-		ret1 = STM32_COMMON_SIP_NUM_CALLS;
-		break;
-
-	case STM32_SIP_SVC_UID:
-		/* Return UUID to the caller */
-		ret_uid = true;
-		break;
-
-	case STM32_SIP_SVC_VERSION:
-		/* Return the version of current implementation */
-		ret1 = STM32_SIP_SVC_VERSION_MAJOR;
-		ret2 = STM32_SIP_SVC_VERSION_MINOR;
-		ret2_enabled = true;
+		*ret1 = STM32_COMMON_SIP_NUM_CALLS;
 		break;
-
 	case STM32_SMC_BSEC:
-		ret1 = bsec_main(x1, x2, x3, &ret2);
-		ret2_enabled = true;
+		*ret1 = bsec_main(x1, x2, x3, ret2);
+		*ret2_enabled = true;
 		break;
 
 	case STM32_SIP_SMC_SCMI_AGENT0:
@@ -75,26 +46,7 @@ static uintptr_t stm32mp1_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
 
 	default:
 		WARN("Unimplemented STM32MP1 Service Call: 0x%x\n", smc_fid);
-		ret1 = STM32_SMC_NOT_SUPPORTED;
+		*ret1 = STM32_SMC_NOT_SUPPORTED;
 		break;
 	}
-
-	if (ret_uid) {
-		SMC_UUID_RET(handle, stm32_sip_svc_uid);
-	}
-
-	if (ret2_enabled) {
-		SMC_RET2(handle, ret1, ret2);
-	}
-
-	SMC_RET1(handle, ret1);
 }
-
-/* Register Standard Service Calls as runtime service */
-DECLARE_RT_SVC(stm32mp1_sip_svc,
-	       OEN_SIP_START,
-	       OEN_SIP_END,
-	       SMC_TYPE_FAST,
-	       stm32mp1_svc_setup,
-	       stm32mp1_svc_smc_handler
-);
diff --git a/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk b/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk
index 1d754d9808..16e2f9087a 100644
--- a/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk
+++ b/plat/st/stm32mp1/sp_min/sp_min-stm32mp1.mk
@@ -32,7 +32,7 @@ include drivers/arm/gic/v2/gicv2.mk
 
 BL32_SOURCES		+=	${GICV2_SOURCES}			\
 				plat/common/plat_gicv2.c		\
-				plat/st/stm32mp1/stm32mp1_gic.c
+				plat/st/common/stm32mp_gic.c
 
 # Generic PSCI
 BL32_SOURCES		+=	plat/common/plat_psci_common.c
@@ -45,7 +45,8 @@ BL32_SOURCES		+=	drivers/scmi-msg/base.c		\
 				drivers/scmi-msg/smt.c
 
 # stm32mp1 specific services
-BL32_SOURCES		+=	plat/st/stm32mp1/services/bsec_svc.c		\
+BL32_SOURCES		+=	plat/st/common/stm32mp_svc_setup.c		\
+				plat/st/stm32mp1/services/bsec_svc.c		\
 				plat/st/stm32mp1/services/stm32mp1_svc_setup.c	\
 				plat/st/stm32mp1/stm32mp1_scmi.c
 
diff --git a/plat/st/stm32mp1/sp_min/sp_min_setup.c b/plat/st/stm32mp1/sp_min/sp_min_setup.c
index 50b079471d..02c2f57a1f 100644
--- a/plat/st/stm32mp1/sp_min/sp_min_setup.c
+++ b/plat/st/stm32mp1/sp_min/sp_min_setup.c
@@ -7,9 +7,8 @@
 #include <assert.h>
 #include <string.h>
 
-#include <platform_def.h>
-
 #include <arch_helpers.h>
+#include <bl32/sp_min/platform_sp_min.h>
 #include <common/bl_common.h>
 #include <common/debug.h>
 #include <context.h>
@@ -27,7 +26,7 @@
 #include <lib/xlat_tables/xlat_tables_v2.h>
 #include <plat/common/platform.h>
 
-#include <platform_sp_min.h>
+#include <platform_def.h>
 
 /******************************************************************************
  * Placeholder variables for copying the arguments that have been passed to
@@ -181,7 +180,10 @@ void sp_min_platform_setup(void)
 {
 	generic_delay_timer_init();
 
-	stm32mp1_gic_init();
+	stm32mp_gic_init();
+
+	/* Disable MCU subsystem protection */
+	stm32mp1_clk_mcuss_protect(false);
 
 	if (stm32_iwdg_init() < 0) {
 		panic();
diff --git a/plat/st/stm32mp1/stm32mp1_boot_device.c b/plat/st/stm32mp1/stm32mp1_boot_device.c
index 3a8a27ac91..63d5285039 100644
--- a/plat/st/stm32mp1/stm32mp1_boot_device.c
+++ b/plat/st/stm32mp1/stm32mp1_boot_device.c
@@ -177,6 +177,7 @@ int plat_get_spi_nand_data(struct spinand_device *device)
 {
 	zeromem(&device->spi_read_cache_op, sizeof(struct spi_mem_op));
 	device->spi_read_cache_op.cmd.opcode = SPI_NAND_OP_READ_FROM_CACHE_4X;
+	device->spi_read_cache_op.cmd.nbytes = 1U;
 	device->spi_read_cache_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	device->spi_read_cache_op.addr.nbytes = 2U;
 	device->spi_read_cache_op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
@@ -193,9 +194,11 @@ int plat_get_spi_nand_data(struct spinand_device *device)
 int plat_get_nor_data(struct nor_device *device)
 {
 	device->size = SZ_64M;
+	device->flags |= SPI_NOR_USE_BANK;
 
 	zeromem(&device->read_op, sizeof(struct spi_mem_op));
 	device->read_op.cmd.opcode = SPI_NOR_OP_READ_1_1_4;
+	device->read_op.cmd.nbytes = 1U;
 	device->read_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
 	device->read_op.addr.nbytes = 3U;
 	device->read_op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
diff --git a/plat/st/stm32mp1/stm32mp1_context.c b/plat/st/stm32mp1/stm32mp1_context.c
new file mode 100644
index 0000000000..e2ee79d219
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_context.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright (c) 2017-2023, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/clk.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <drivers/st/stm32mp1_ddr_regs.h>
+#include <dt-bindings/clock/stm32mp1-clks.h>
+#include <lib/utils.h>
+
+#include <platform_def.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_critic_power.h>
+
+#define TRAINING_AREA_SIZE		64U
+
+#define BL32_CANARY_ID			U(0x424c3332)
+
+/*
+ * MAILBOX_MAGIC relates to struct backup_data_s as defined
+ *
+ * MAILBOX_MAGIC_V1:
+ * Context provides magic, resume entry, zq0cr0 zdata and DDR training buffer.
+ *
+ * MAILBOX_MAGIC_V2:
+ * Context provides V1 content and PLL1 dual OPP settings structure (86 bytes).
+ *
+ * MAILBOX_MAGIC_V3:
+ * Context provides V2 content, low power entry point, BL2 code start, end and
+ * BL2_END (102 bytes). And, only for STM32MP13, adds MCE master key (16 bytes).
+ */
+#define MAILBOX_MAGIC_V1		(0x0001U << 16U)
+#define MAILBOX_MAGIC_V2		(0x0002U << 16U)
+#define MAILBOX_MAGIC_V3		(0x0003U << 16U)
+#define MAILBOX_MAGIC			(MAILBOX_MAGIC_V3 | \
+					 TRAINING_AREA_SIZE)
+
+#define MAGIC_ID(magic)			((magic) & GENMASK_32(31, 16))
+#define MAGIC_AREA_SIZE(magic)		((magic) & GENMASK_32(15, 0))
+
+#if (PLAT_MAX_OPP_NB != 2U) || (PLAT_MAX_PLLCFG_NB != 6U)
+#error MAILBOX_MAGIC_V2/_V3 does not support expected PLL1 settings
+#endif
+
+/* pll_settings structure size definitions (reference to clock driver) */
+#define PLL1_SETTINGS_SIZE		(((PLAT_MAX_OPP_NB * \
+					  (PLAT_MAX_PLLCFG_NB + 3U)) + 1U) * \
+					 sizeof(uint32_t))
+
+struct backup_data_s {
+	uint32_t magic;
+	uint32_t core0_resume_hint;
+	uint32_t zq0cr0_zdata;
+	uint8_t ddr_training_backup[TRAINING_AREA_SIZE];
+	uint8_t pll1_settings[PLL1_SETTINGS_SIZE];
+	uint32_t low_power_ep;
+	uint32_t bl2_code_base;
+	uint32_t bl2_code_end;
+	uint32_t bl2_end;
+#if STM32MP13
+	uint8_t mce_seed[MCE_SEED_SIZE_IN_BYTES];
+	struct stm32_mce_region_s mce_regions[MCE_IP_MAX_REGION_NB];
+#endif
+};
+
+uint32_t stm32_pm_get_optee_ep(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t ep;
+
+#if STM32MP15
+	clk_enable(BKPSRAM);
+#endif
+
+	/* Context & Data to be saved at the beginning of Backup SRAM */
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	switch (MAGIC_ID(backup_data->magic)) {
+	case MAILBOX_MAGIC_V1:
+	case MAILBOX_MAGIC_V2:
+	case MAILBOX_MAGIC_V3:
+		if (MAGIC_AREA_SIZE(backup_data->magic) != TRAINING_AREA_SIZE) {
+			panic();
+		}
+		break;
+	default:
+		ERROR("PM context: bad magic\n");
+		panic();
+	}
+
+	ep = backup_data->core0_resume_hint;
+
+#if STM32MP15
+	clk_disable(BKPSRAM);
+#endif
+
+	return ep;
+}
+
+void stm32_clean_context(void)
+{
+	if (!stm32mp_bkpram_get_access()) {
+		return;
+	}
+
+	clk_enable(BKPSRAM);
+
+	zeromem((void *)STM32MP_BACKUP_RAM_BASE, sizeof(struct backup_data_s));
+
+	clk_disable(BKPSRAM);
+}
+
+#if defined(IMAGE_BL2)
+void stm32_context_save_bl2_param(void)
+{
+	struct backup_data_s *backup_data;
+
+	if (!stm32mp_bkpram_get_access()) {
+		return;
+	}
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	backup_data->low_power_ep = (uint32_t)&stm32_pwr_down_wfi_wrapper;
+	backup_data->bl2_code_base = BL_CODE_BASE;
+	backup_data->bl2_code_end = BL_CODE_END;
+	backup_data->bl2_end = BL2_END;
+	backup_data->magic = MAILBOX_MAGIC_V3;
+	backup_data->zq0cr0_zdata = ddr_get_io_calibration_val();
+
+	clk_disable(BKPSRAM);
+}
+#endif
+
+uint32_t stm32_get_zdata_from_context(void)
+{
+	struct backup_data_s *backup_data;
+	uint32_t zdata;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	zdata = (backup_data->zq0cr0_zdata >> DDRPHYC_ZQ0CRN_ZDATA_SHIFT) &
+		DDRPHYC_ZQ0CRN_ZDATA_MASK;
+
+	clk_disable(BKPSRAM);
+
+	return zdata;
+}
+
+bool stm32_pm_context_is_valid(void)
+{
+	struct backup_data_s *backup_data;
+	bool ret;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	switch (MAGIC_ID(backup_data->magic)) {
+	case MAILBOX_MAGIC_V1:
+	case MAILBOX_MAGIC_V2:
+	case MAILBOX_MAGIC_V3:
+		ret = true;
+		break;
+	default:
+		ret = false;
+		break;
+	}
+
+	clk_disable(BKPSRAM);
+
+	return ret;
+}
+
+void stm32_restore_ddr_training_area(void)
+{
+	struct backup_data_s *backup_data;
+
+	clk_enable(BKPSRAM);
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	memcpy((uint32_t *)STM32MP_DDR_BASE,
+	       &backup_data->ddr_training_backup,
+	       TRAINING_AREA_SIZE);
+	dsb();
+
+	clk_disable(BKPSRAM);
+}
+
+#if STM32MP13
+void stm32mp1_pm_save_mce_seed_in_context(uint8_t *data)
+{
+	struct backup_data_s *backup_data;
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	if (!stm32mp_bkpram_get_access()) {
+		return;
+	}
+
+	clk_enable(BKPSRAM);
+
+	memcpy(backup_data->mce_seed, data, MCE_SEED_SIZE_IN_BYTES);
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_get_mce_seed_from_context(uint8_t *data)
+{
+	struct backup_data_s *backup_data;
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	if (!stm32mp_bkpram_get_access()) {
+		ERROR("DDR encryption key not available\n");
+		panic();
+	}
+
+	clk_enable(BKPSRAM);
+
+	memcpy(data, backup_data->mce_seed, MCE_SEED_SIZE_IN_BYTES);
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_save_mce_region(uint32_t index, struct stm32_mce_region_s *config)
+{
+	struct backup_data_s *backup_data;
+
+	if (index >= MCE_IP_MAX_REGION_NB) {
+		panic();
+	}
+
+	if (!stm32mp_bkpram_get_access()) {
+		return;
+	}
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	clk_enable(BKPSRAM);
+
+	memcpy(&backup_data->mce_regions[index], config, sizeof(struct stm32_mce_region_s));
+
+	clk_disable(BKPSRAM);
+}
+
+void stm32mp1_pm_get_mce_region(uint32_t index, struct stm32_mce_region_s *config)
+{
+	struct backup_data_s *backup_data;
+
+	if (index >= MCE_IP_MAX_REGION_NB) {
+		panic();
+	}
+
+	backup_data = (struct backup_data_s *)STM32MP_BACKUP_RAM_BASE;
+
+	if (!stm32mp_bkpram_get_access()) {
+		ERROR("MCE region not available\n");
+		panic();
+	}
+
+	clk_enable(BKPSRAM);
+
+	memcpy(config, &backup_data->mce_regions[index], sizeof(struct stm32_mce_region_s));
+
+	clk_disable(BKPSRAM);
+}
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_critic_power.c b/plat/st/stm32mp1/stm32mp1_critic_power.c
new file mode 100644
index 0000000000..0ae41f644d
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_critic_power.c
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2019-2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp1_ddr_helpers.h>
+#include <dt-bindings/power/stm32mp1-power.h>
+
+#include <platform_def.h>
+#include <stm32mp1_context.h>
+#include <stm32mp1_critic_power.h>
+
+static void cstop_critic_enter(uint32_t mode)
+{
+	/* Init generic timer that is needed for udelay used in ddr driver */
+	generic_delay_timer_init();
+
+	/* Switch to Software Self-Refresh mode */
+	ddr_set_sr_mode(DDR_SSR_MODE);
+
+	/*
+	 * Set DDR in Self-refresh,.
+	 * This is also the procedure awaited when switching off power supply.
+	 */
+	if (ddr_standby_sr_entry() != 0) {
+		ERROR("Unable to put DDR in SR\n");
+		if (mode != (uint32_t)STM32_PM_SHUTDOWN) {
+			panic();
+		}
+	}
+}
+
+static void shutdown_critic_enter(void)
+{
+	if (dt_pmic_status() > 0) {
+		if (!initialize_pmic_i2c()) {
+			panic();
+		}
+
+		pmic_switch_off();
+	}
+}
+
+/*
+ * stm32_exit_cstop_critic - Exit from CSTOP mode reenable DDR
+ */
+void stm32_pwr_cstop_critic_exit(void)
+{
+#if STM32MP13
+	bsec_write_scratch((uint32_t)0U);
+#endif
+
+#if defined(IMAGE_BL2)
+	/* Init generic timer that is needed for udelay used in ddr driver */
+	stm32mp_stgen_restore_rate();
+
+	generic_delay_timer_init();
+#endif
+
+	if (ddr_sw_self_refresh_exit() != 0) {
+		panic();
+	}
+}
+
+void stm32_pwr_down_wfi_load(bool is_cstop, uint32_t mode)
+{
+	if (mode == (uint32_t)STM32_PM_CSTOP_ALLOW_LPLV_STOP2) {
+#if STM32MP15
+		ERROR("LPLV-Stop2 mode not supported\n");
+		panic();
+#endif
+
+#if STM32MP13
+		/* If mode is STOP 2, set the entry point */
+		bsec_write_scratch((uint32_t)stm32_pwr_back_from_stop2);
+#endif
+	}
+
+	if (mode != (uint32_t)STM32_PM_CSLEEP_RUN) {
+		dcsw_op_all(DC_OP_CISW);
+	}
+
+	if (is_cstop) {
+		cstop_critic_enter(mode);
+	}
+
+	if (mode == (uint32_t)STM32_PM_SHUTDOWN) {
+		shutdown_critic_enter();
+	}
+
+	/*
+	 * Synchronize on memory accesses and instruction flow before the WFI
+	 * instruction.
+	 */
+	dsb();
+	isb();
+	wfi();
+
+	stm32_iwdg_refresh();
+
+	if (is_cstop) {
+		stm32_pwr_cstop_critic_exit();
+	}
+}
+
+#if STM32MP13
+void stm32_pwr_call_optee_ep(void)
+{
+	void (*optee_ep)(void);
+
+	optee_ep = (void (*)(void))stm32_pm_get_optee_ep();
+
+	optee_ep();
+
+	/* This shouldn't be reached */
+	panic();
+}
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S b/plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
new file mode 100644
index 0000000000..c3fb5cdbf9
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_critic_power_wrapper.S
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2019-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <common/bl_common.h>
+#include <drivers/st/stm32_gpio.h>
+#include <smccc_helpers.h>
+
+	.global	stm32_pwr_down_wfi_load
+	.global	stm32_pwr_cstop_critic_exit
+	.global	stm32_pwr_down_wfi_wrapper
+#if STM32MP13
+	.global	stm32_pwr_back_from_stop2
+	.global	stm32_pwr_call_optee_ep
+#endif
+	.global	bl2_vector_table
+	.global	disable_mmu_secure
+	.global	__STACKS_END__
+
+.section .data
+	.balign 4
+saved_sp:		.word	0x00000000
+saved_vbar:		.word	0x00000000
+saved_mvbar:		.word	0x00000000
+
+.section .text
+	.align	5
+
+func stm32_pwr_down_wfi_wrapper
+	push	{r4,r5,r6,lr}
+
+	# Save r0 and r1 in  r2 and r3, as they are used in disable_mmu_secure
+	mov	r2, r0
+	mov	r3, r1
+
+	# Save current sp in sp1
+	ldr	r1, =saved_sp
+	str	sp, [r1]
+
+	# Save current VBAR in vbar1
+	ldr	r1, =saved_vbar
+	ldcopr	r0, VBAR
+	str	r0, [r1]
+
+	# Save current MVBAR in mvbar1
+	ldr	r1, =saved_mvbar
+	ldcopr	r0, MVBAR
+	str	r0, [r1]
+
+	# Reuse BL2 vector table for VBAR and MVBAR
+	ldr	r1, =bl2_vector_table
+	stcopr	r1, VBAR
+	stcopr	r1, MVBAR
+
+	# Set sp to BL2 STACK (as BL2 is not using it anymore)
+	ldr	sp, =__STACKS_END__
+
+	mov	r0, r2
+	mov	r1, r3
+
+	bl	stm32_pwr_down_wfi_load
+
+	# Restore stack
+	ldr	r1, =saved_sp
+	ldr	sp, [r1]
+
+	# Restore VBAR
+	ldr	r1, =saved_vbar
+	ldr	r0, [r1]
+	stcopr	r0, VBAR
+
+	# Restore MVBAR
+	ldr	r1, =saved_mvbar
+	ldr	r0, [r1]
+	stcopr	r0, MVBAR
+
+	# Synchronize on memory access and instruction
+	# after resetting stack/IT handler
+	dsb
+	isb
+
+	pop	{r4,r5,r6,pc}
+endfunc stm32_pwr_down_wfi_wrapper
+
+#if STM32MP13
+func stm32_pwr_back_from_stop2
+	# switch to monitor mode.
+	cps	#MODE32_mon
+
+	ldr	sp, =__STACKS_END__
+
+	ldr	r1, =bl2_vector_table
+	stcopr	r1, VBAR
+	stcopr	r1, MVBAR
+
+	# exit ddr from self refresh
+	bl	stm32_pwr_cstop_critic_exit
+
+	# Restore stack
+	ldr	r1, =saved_sp
+	ldr	sp, [r1]
+
+	# Restore VBAR
+	ldr	r1, =saved_vbar
+	ldr	r0, [r1]
+	stcopr	r0, VBAR
+
+	# Restore MVBAR
+	ldr	r1, =saved_mvbar
+	ldr	r0, [r1]
+	stcopr	r0, MVBAR
+
+	# Synchronize on memory access and instruction
+	# after resetting stack/IT handler
+	dsb
+	isb
+
+	bl stm32_pwr_call_optee_ep
+
+endfunc stm32_pwr_back_from_stop2
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_def.h b/plat/st/stm32mp1/stm32mp1_def.h
index f0d85263e2..4074f27d9f 100644
--- a/plat/st/stm32mp1/stm32mp1_def.h
+++ b/plat/st/stm32mp1/stm32mp1_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -10,6 +10,7 @@
 #include <common/tbbr/tbbr_img_def.h>
 #include <drivers/st/stm32mp1_rcc.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/gpio/stm32-gpio.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
 #include <lib/utils_def.h>
 #include <lib/xlat_tables/xlat_tables_defs.h>
@@ -17,10 +18,13 @@
 #ifndef __ASSEMBLER__
 #include <drivers/st/bsec.h>
 #include <drivers/st/stm32mp1_clk.h>
+#include <drivers/st/stm32mp1_ddr_regs.h>
+#include <drivers/st/stm32mp1_pwr.h>
 
 #include <boot_api.h>
 #include <stm32mp_common.h>
 #include <stm32mp_dt.h>
+#include <stm32mp1_context.h>
 #include <stm32mp1_dbgmcu.h>
 #include <stm32mp1_private.h>
 #include <stm32mp1_shared_resources.h>
@@ -70,6 +74,7 @@
 #define STM32MP1_REV_Z		U(0x1001)
 #endif
 #if STM32MP15
+#define STM32MP1_REV_Y		U(0x2003)
 #define STM32MP1_REV_Z		U(0x2001)
 #endif
 
@@ -107,6 +112,14 @@
 #define STM32MP_SYSRAM_SIZE		U(0x00040000)
 #endif /* STM32MP15 */
 
+#define STM32MP_BACKUP_RAM_BASE		U(0x54000000)
+#if STM32MP13
+#define STM32MP_BACKUP_RAM_SIZE		U(0x00002000)	/* 8KB */
+#endif /* STM32MP13 */
+#if STM32MP15
+#define STM32MP_BACKUP_RAM_SIZE		U(0x00001000)	/* 4KB */
+#endif /* STM32MP15 */
+
 #define STM32MP_NS_SYSRAM_SIZE		PAGE_SIZE
 #define STM32MP_NS_SYSRAM_BASE		(STM32MP_SYSRAM_BASE + \
 					 STM32MP_SYSRAM_SIZE - \
@@ -136,6 +149,8 @@ enum ddr_type {
 #if STM32MP13
 /* 512 Octets reserved for header */
 #define STM32MP_HEADER_RESERVED_SIZE	U(0x200)
+#define STM32MP_HEADER_BASE		(SRAM3_BASE + SRAM3_SIZE -	\
+					 STM32MP_HEADER_RESERVED_SIZE)
 
 #define STM32MP_BINARY_BASE		STM32MP_SEC_SYSRAM_BASE
 
@@ -145,6 +160,8 @@ enum ddr_type {
 #define STM32MP_PARAM_LOAD_SIZE		U(0x00002400)	/* 9 KB for param */
 /* 256 Octets reserved for header */
 #define STM32MP_HEADER_SIZE		U(0x00000100)
+#define STM32MP_HEADER_BASE		(STM32MP_SEC_SYSRAM_BASE +	\
+					 STM32MP_PARAM_LOAD_SIZE)
 /* round_up(STM32MP_PARAM_LOAD_SIZE + STM32MP_HEADER_SIZE, PAGE_SIZE) */
 #define STM32MP_HEADER_RESERVED_SIZE	U(0x3000)
 
@@ -195,6 +212,7 @@ enum ddr_type {
 					 SRAM1_SIZE - \
 					 PLATFORM_MTD_MAX_PAGE_SIZE)
 #endif
+
 /*******************************************************************************
  * STM32MP1 device/io map related constants (used for MMU)
  ******************************************************************************/
@@ -233,21 +251,7 @@ enum ddr_type {
 #endif
 #define GPIO_BANK_OFFSET		U(0x1000)
 
-/* Bank IDs used in GPIO driver API */
-#define GPIO_BANK_A			U(0)
-#define GPIO_BANK_B			U(1)
-#define GPIO_BANK_C			U(2)
-#define GPIO_BANK_D			U(3)
-#define GPIO_BANK_E			U(4)
-#define GPIO_BANK_F			U(5)
-#define GPIO_BANK_G			U(6)
-#define GPIO_BANK_H			U(7)
-#define GPIO_BANK_I			U(8)
 #if STM32MP15
-#define GPIO_BANK_J			U(9)
-#define GPIO_BANK_K			U(10)
-#define GPIO_BANK_Z			U(25)
-
 #define STM32MP_GPIOZ_PIN_MAX_COUNT	8
 #endif
 
@@ -416,12 +420,6 @@ enum ddr_type {
 #define STM32MP_SDMMC2_BASE		U(0x58007000)
 #define STM32MP_SDMMC3_BASE		U(0x48004000)
 
-#define STM32MP_MMC_INIT_FREQ			U(400000)	/*400 KHz*/
-#define STM32MP_SD_NORMAL_SPEED_MAX_FREQ	U(25000000)	/*25 MHz*/
-#define STM32MP_SD_HIGH_SPEED_MAX_FREQ		U(50000000)	/*50 MHz*/
-#define STM32MP_EMMC_NORMAL_SPEED_MAX_FREQ	U(26000000)	/*26 MHz*/
-#define STM32MP_EMMC_HIGH_SPEED_MAX_FREQ	U(52000000)	/*52 MHz*/
-
 /*******************************************************************************
  * STM32MP1 BSEC / OTP
  ******************************************************************************/
@@ -440,15 +438,20 @@ enum ddr_type {
 #if STM32MP13
 #define NAND_OTP			"cfg9_otp"
 #define NAND2_OTP			"cfg10_otp"
+#define SSP_OTP				"cfg9_otp"
 #endif
 #if STM32MP15
 #define NAND_OTP			"nand_otp"
+#define SSP_OTP				"ssp_otp"
 #endif
 #define MONOTONIC_OTP			"monotonic_otp"
 #define UID_OTP				"uid_otp"
 #define PKH_OTP				"pkh_otp"
-#define ENCKEY_OTP			"enckey_otp"
+#define ENCKEY_OTP			"oem_enc_key"
 #define BOARD_ID_OTP			"board_id"
+#define CFG2_OTP			"cfg2_otp"
+#define CHIP_CERTIFICATE_OTP		"chip_otp"
+#define RMA_OTP				"rma_otp"
 
 /* OTP mask */
 /* CFG0 */
@@ -464,6 +467,31 @@ enum ddr_type {
 #define CFG0_CLOSED_DEVICE		BIT(6)
 #endif
 
+/* CFG2 */
+#define OTP_CFG2_SEC_COUNTER_MASK	GENMASK_32(27, 20)
+#define OTP_CFG2_SEC_COUNTER_SHIFT	U(20)
+#define OTP_CFG2_ST_KEY_MASK		GENMASK_32(31, 28)
+#define OTP_CFG2_ST_KEY_SHIFT		U(28)
+
+/* SSP */
+#define SSP_OTP_REQ			BIT(BOOT_API_OTP_SSP_REQ_BIT_POS)
+#define SSP_OTP_SUCCESS			BIT(BOOT_API_OTP_SSP_SUCCESS_BIT_POS)
+#define SSP_OTP_MASK			GENMASK_32(BOOT_API_OTP_SSP_SUCCESS_BIT_POS, \
+						   BOOT_API_OTP_SSP_REQ_BIT_POS)
+#define SSP_OTP_SECRET_BASE		U(59)
+#define SSP_OTP_SECRET_END		U(95)
+
+/* CHIP_CERT */
+#define CHIP_CERTIFICATE_MAX_SIZE	U(0x40)
+
+/* RMA */
+#if STM32MP13
+#define RMA_OTP_MASK			GENMASK_32(31, 0)
+#endif
+#if STM32MP15
+#define RMA_OTP_MASK			GENMASK_32(29, 0)
+#endif
+
 /* PART NUMBER */
 #if STM32MP13
 #define PART_NUMBER_OTP_PART_MASK	GENMASK_32(11, 0)
@@ -540,22 +568,28 @@ enum ddr_type {
 /* UID OTP */
 #define UID_WORD_NB			U(3)
 
-/* FWU configuration (max supported value is 15) */
-#define FWU_MAX_TRIAL_REBOOT		U(3)
-
 /*******************************************************************************
  * STM32MP1 TAMP
  ******************************************************************************/
 #define TAMP_BASE			U(0x5C00A000)
-#define TAMP_BKP_REGISTER_BASE		(TAMP_BASE + U(0x100))
+#define TAMP_BKP_REG_CLK		RTCAPB
+#define TAMP_CR2			U(0x4)
+#if STM32MP13
+#define TAMP_CR2_MASK_NOER		GENMASK_32(7, 0)
+#endif
+#if STM32MP15
+#define TAMP_CR2_MASK_NOER		GENMASK_32(2, 0)
+#define TAMP_SR_MASK_ITAMPx		(BIT_32(23)|GENMASK_32(20, 16))
+#endif
+#define TAMP_CR3			U(0x8)
+#define TAMP_CR3_MASK_NOER		GENMASK_32(12, 0)
+#define TAMP_SR				U(0x30)
+#define TAMP_SCR			U(0x3C)
 #define TAMP_COUNTR			U(0x40)
+#define TAMP_ERCFGR			U(0x54)
 
-#if !(defined(__LINKER__) || defined(__ASSEMBLER__))
-static inline uintptr_t tamp_bkpr(uint32_t idx)
-{
-	return TAMP_BKP_REGISTER_BASE + (idx << 2);
-}
-#endif
+#define TAMP_SR_LSE_MONITORING		BIT(18)
+#define TAMP_SR_INT_SHIFT		U(16)
 
 /*******************************************************************************
  * STM32MP1 USB
@@ -572,6 +606,15 @@ static inline uintptr_t tamp_bkpr(uint32_t idx)
  ******************************************************************************/
 #define DDRPHYC_BASE			U(0x5A004000)
 
+/*******************************************************************************
+ * STM32MP1 MCE
+ ******************************************************************************/
+#if STM32MP13
+#define MCE_BASE			U(0x58001000)
+#define MCE_KEY_SIZE_IN_BYTES		U(16)
+#define MCE_SEED_SIZE_IN_BYTES		U(4)
+#endif
+
 /*******************************************************************************
  * STM32MP1 IWDG
  ******************************************************************************/
@@ -635,25 +678,38 @@ static inline uintptr_t tamp_bkpr(uint32_t idx)
  ******************************************************************************/
 #define PKA_BASE			U(0x54006000)
 
+/*******************************************************************************
+ * STM32MP1 OPP
+ ******************************************************************************/
+#define PLAT_MAX_OPP_NB			U(2)
+#define PLAT_MAX_PLLCFG_NB		U(6)
+
 /*******************************************************************************
  * REGULATORS
  ******************************************************************************/
 /* 3 PWR + 1 VREFBUF + 14 PMIC regulators + 1 FIXED */
 #define PLAT_NB_RDEVS			U(19)
 /* 2 FIXED */
-#define PLAT_NB_FIXED_REGS		U(2)
+#define PLAT_NB_FIXED_REGUS		U(2)
+/* No GPIO regu */
+#define PLAT_NB_GPIO_REGUS		U(0)
+/* TAMP BACKUP REGISTER */
+#define PLAT_NB_NVMEM_DEVS		U(1)
+#define MAX_TAMP_BACKUP_REGS_ZONES	U(3)
 
 /*******************************************************************************
  * Device Tree defines
  ******************************************************************************/
-#define DT_BSEC_COMPAT			"st,stm32mp15-bsec"
 #if STM32MP13
+#define DT_BSEC_COMPAT			"st,stm32mp13-bsec"
 #define DT_DDR_COMPAT			"st,stm32mp13-ddr"
 #endif
 #if STM32MP15
+#define DT_BSEC_COMPAT			"st,stm32mp15-bsec"
 #define DT_DDR_COMPAT			"st,stm32mp1-ddr"
 #endif
 #define DT_IWDG_COMPAT			"st,stm32mp1-iwdg"
+#define DT_MMIO_SRAM			"mmio-sram"
 #define DT_PWR_COMPAT			"st,stm32mp1,pwr-reg"
 #if STM32MP13
 #define DT_RCC_CLK_COMPAT		"st,stm32mp13-rcc"
@@ -664,6 +720,7 @@ static inline uintptr_t tamp_bkpr(uint32_t idx)
 #define DT_RCC_SEC_CLK_COMPAT		"st,stm32mp1-rcc-secure"
 #endif
 #define DT_SDMMC2_COMPAT		"st,stm32-sdmmc2"
+#define DT_TAMP_NVRAM_COMPAT		"st,stm32mp15-tamp-nvram"
 #define DT_UART_COMPAT			"st,stm32h7-uart"
 
 #endif /* STM32MP1_DEF_H */
diff --git a/plat/st/stm32mp1/stm32mp1_fconf_firewall.c b/plat/st/stm32mp1/stm32mp1_fconf_firewall.c
index f2568ab5a0..d981ec4844 100644
--- a/plat/st/stm32mp1/stm32mp1_fconf_firewall.c
+++ b/plat/st/stm32mp1/stm32mp1_fconf_firewall.c
@@ -10,6 +10,7 @@
 #include <common/fdt_wrappers.h>
 #include <drivers/arm/tzc400.h>
 #include <drivers/clk.h>
+#include <drivers/st/stm32mp1_ram.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
 #include <lib/fconf/fconf.h>
 #include <lib/object_pool.h>
@@ -56,6 +57,11 @@ void stm32mp1_security_setup(void)
 {
 	uint8_t i;
 
+	/* DDR content will be restored, do not change the firewall protection */
+	if (stm32mp1_ddr_is_restored()) {
+		return;
+	}
+
 	assert(nb_regions > 0U);
 
 	tzc400_init(STM32MP1_TZC_BASE);
@@ -85,6 +91,11 @@ static int fconf_populate_stm32mp1_firewall(uintptr_t config)
 	/* Assert the node offset point to "st,mem-firewall" compatible property */
 	const char *compatible_str = "st,mem-firewall";
 
+	/* DDR content will be restored, do not change the firewall protection */
+	if (stm32mp1_ddr_is_restored()) {
+		return 0;
+	}
+
 	node = fdt_node_offset_by_compatible(dtb, -1, compatible_str);
 	if (node < 0) {
 		ERROR("FCONF: Can't find %s compatible in dtb\n", compatible_str);
@@ -99,15 +110,16 @@ static int fconf_populate_stm32mp1_firewall(uintptr_t config)
 
 	/* Locate the memory cells and read all values */
 	for (i = 0U; i < (unsigned int)(len / (sizeof(uint32_t) * STM32MP_REGION_PARAMS)); i++) {
+		uint32_t idx = i * STM32MP_REGION_PARAMS;
 		uint32_t base;
 		uint32_t size;
 		uint32_t sec_attr;
 		uint32_t nsaid;
 
-		base = fdt32_to_cpu(conf_list->id_attr[i * STM32MP_REGION_PARAMS]);
-		size = fdt32_to_cpu(conf_list->id_attr[i * STM32MP_REGION_PARAMS + 1]);
-		sec_attr = fdt32_to_cpu(conf_list->id_attr[i * STM32MP_REGION_PARAMS + 2]);
-		nsaid = fdt32_to_cpu(conf_list->id_attr[i * STM32MP_REGION_PARAMS + 3]);
+		base = fdt32_to_cpu(conf_list->id_attr[idx]);
+		size = fdt32_to_cpu(conf_list->id_attr[idx + 1]);
+		sec_attr = fdt32_to_cpu(conf_list->id_attr[idx + 2]);
+		nsaid = fdt32_to_cpu(conf_list->id_attr[idx + 3]);
 
 		VERBOSE("FCONF: stm32mp1-firewall cell found with value = 0x%x 0x%x 0x%x 0x%x\n",
 			base, size, sec_attr, nsaid);
diff --git a/plat/st/stm32mp1/stm32mp1_fip_def.h b/plat/st/stm32mp1/stm32mp1_fip_def.h
index 4098386fd2..8ad1ed9c76 100644
--- a/plat/st/stm32mp1/stm32mp1_fip_def.h
+++ b/plat/st/stm32mp1/stm32mp1_fip_def.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2021-2022, STMicroelectronics - All Rights Reserved
+ * Copyright (C) 2021-2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,14 +7,31 @@
 #ifndef STM32MP1_FIP_DEF_H
 #define STM32MP1_FIP_DEF_H
 
-#if STM32MP15_OPTEE_RSV_SHM
-#define STM32MP_DDR_S_SIZE		U(0x01E00000)	/* 30 MB */
-#define STM32MP_DDR_SHMEM_SIZE		U(0x00200000)	/* 2 MB */
-#else
 #define STM32MP_DDR_S_SIZE		U(0x02000000)	/* 32 MB */
-#define STM32MP_DDR_SHMEM_SIZE		U(0)		/* empty */
+
+#if STM32MP_SSP
+#if STM32MP13
+#define STM32MP_BL2_DTB_BASE		STM32MP_SEC_SYSRAM_BASE
+#endif
+#if STM32MP15
+#define STM32MP_BL2_DTB_BASE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_HEADER_RESERVED_SIZE)
 #endif
 
+#define STM32MP_BL2_DTB_SIZE		U(0x00005000)	/* 20 KB for DTB */
+
+#define STM32MP_BL2_RO_SIZE		U(0x0000E000)	/* 56 Ko for BL2 */
+
+#define STM32MP_BL2_RO_BASE		STM32MP_BL2_DTB_BASE + \
+					STM32MP_BL2_DTB_SIZE
+
+#define STM32MP_BL2_RW_BASE		(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define STM32MP_BL2_RW_SIZE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 STM32MP_BL2_RW_BASE)
+#else /* STM32MP_SSP */
 #if TRUSTED_BOARD_BOOT && !STM32MP_USE_EXTERNAL_HEAP
 #if STM32MP15
 #define STM32MP_BL2_RO_SIZE		U(0x00014000)	/* 80 KB */
@@ -87,6 +104,7 @@
 
 #define STM32MP_BL32_BASE		(STM32MP_BL32_DTB_BASE + \
 					 STM32MP_BL32_DTB_SIZE)
+#endif /* STM32MP_SSP */
 
 
 #if defined(IMAGE_BL2)
@@ -98,7 +116,7 @@
 #define STM32MP_DTB_BASE		STM32MP_BL32_DTB_BASE
 #endif
 
-#ifdef AARCH32_SP_OPTEE
+#if defined(AARCH32_SP_OPTEE) && STM32MP1_OPTEE_IN_SYSRAM
 #define STM32MP_OPTEE_BASE		STM32MP_SEC_SYSRAM_BASE
 
 #define STM32MP_OPTEE_SIZE		(STM32MP_BL2_DTB_BASE -  \
@@ -124,15 +142,4 @@
 #define MAX_MMAP_REGIONS		10
 #endif
 
-/*******************************************************************************
- * STM32MP1 RAW partition offset for devices without GPT
- ******************************************************************************/
-#define STM32MP_EMMC_BOOT_FIP_OFFSET	U(0x00040000)
-#ifndef STM32MP_NOR_FIP_OFFSET
-#define STM32MP_NOR_FIP_OFFSET		U(0x00080000)
-#endif
-#ifndef STM32MP_NAND_FIP_OFFSET
-#define STM32MP_NAND_FIP_OFFSET		U(0x00200000)
-#endif
-
 #endif /* STM32MP1_FIP_DEF_H */
diff --git a/plat/st/stm32mp1/stm32mp1_pm.c b/plat/st/stm32mp1/stm32mp1_pm.c
index 6e438c44e9..f284aa3d5f 100644
--- a/plat/st/stm32mp1/stm32mp1_pm.c
+++ b/plat/st/stm32mp1/stm32mp1_pm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2024, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -13,6 +13,7 @@
 #include <drivers/arm/gic_common.h>
 #include <drivers/arm/gicv2.h>
 #include <drivers/clk.h>
+#include <drivers/st/nvmem.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
 #include <lib/mmio.h>
 #include <lib/psci/psci.h>
@@ -60,10 +61,18 @@ static void stm32_cpu_standby(plat_local_state_t cpu_state)
 static int stm32_pwr_domain_on(u_register_t mpidr)
 {
 	unsigned long current_cpu_mpidr = read_mpidr_el1();
-	uintptr_t bkpr_core1_addr =
-		tamp_bkpr(BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX);
-	uintptr_t bkpr_core1_magic =
-		tamp_bkpr(BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX);
+	struct nvmem_cell magic_number;
+	struct nvmem_cell branch_address;
+	int ret = 0;
+
+	ret = stm32_get_magic_number_cell(&magic_number);
+	if (ret != 0) {
+		return -ENODEV;
+	}
+	ret = stm32_get_core1_branch_address_cell(&branch_address);
+	if (ret != 0) {
+		return -ENODEV;
+	}
 
 	if (mpidr == current_cpu_mpidr) {
 		return PSCI_E_INVALID_PARAMS;
@@ -79,10 +88,12 @@ static int stm32_pwr_domain_on(u_register_t mpidr)
 	cntfrq_core0 = read_cntfrq_el0();
 
 	/* Write entrypoint in backup RAM register */
-	mmio_write_32(bkpr_core1_addr, stm32_sec_entrypoint);
+	nvmem_cell_write(&branch_address, (uint8_t *)&stm32_sec_entrypoint,
+			 sizeof(stm32_sec_entrypoint));
 
 	/* Write magic number in backup register */
-	mmio_write_32(bkpr_core1_magic, BOOT_API_A7_CORE1_MAGIC_NUMBER);
+	nvmem_cell_write(&magic_number, (uint8_t *)&stm32_sec_entrypoint,
+			 sizeof(stm32_sec_entrypoint));
 
 	clk_disable(RTCAPB);
 
@@ -118,7 +129,8 @@ static void stm32_pwr_domain_suspend(const psci_power_state_t *target_state)
  ******************************************************************************/
 static void stm32_pwr_domain_on_finish(const psci_power_state_t *target_state)
 {
-	stm32mp1_gic_pcpu_init();
+	stm32mp_gic_pcpu_init();
+	stm32mp_gic_cpuif_enable();
 
 	write_cntfrq_el0(cntfrq_core0);
 }
@@ -161,17 +173,15 @@ static void __dead2 stm32_system_reset(void)
 static int stm32_validate_power_state(unsigned int power_state,
 				      psci_power_state_t *req_state)
 {
-	int pstate = psci_get_pstate_type(power_state);
-
-	if (pstate != 0) {
+	if (psci_get_pstate_type(power_state) != 0U) {
 		return PSCI_E_INVALID_PARAMS;
 	}
 
-	if (psci_get_pstate_pwrlvl(power_state)) {
+	if (psci_get_pstate_pwrlvl(power_state) != 0U) {
 		return PSCI_E_INVALID_PARAMS;
 	}
 
-	if (psci_get_pstate_id(power_state)) {
+	if (psci_get_pstate_id(power_state) != 0U) {
 		return PSCI_E_INVALID_PARAMS;
 	}
 
diff --git a/plat/st/stm32mp1/stm32mp1_private.c b/plat/st/stm32mp1/stm32mp1_private.c
index 9bdb07552a..77e1644cae 100644
--- a/plat/st/stm32mp1/stm32mp1_private.c
+++ b/plat/st/stm32mp1/stm32mp1_private.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2024, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -7,6 +7,7 @@
 #include <assert.h>
 
 #include <drivers/clk.h>
+#include <drivers/st/nvmem.h>
 #include <drivers/st/stm32_gpio.h>
 #include <drivers/st/stm32_iwdg.h>
 #include <lib/mmio.h>
@@ -16,49 +17,6 @@
 #include <plat/common/platform.h>
 #include <platform_def.h>
 
-/* Internal layout of the 32bit OTP word board_id */
-#define BOARD_ID_BOARD_NB_MASK		GENMASK(31, 16)
-#define BOARD_ID_BOARD_NB_SHIFT		16
-#define BOARD_ID_VARCPN_MASK		GENMASK(15, 12)
-#define BOARD_ID_VARCPN_SHIFT		12
-#define BOARD_ID_REVISION_MASK		GENMASK(11, 8)
-#define BOARD_ID_REVISION_SHIFT		8
-#define BOARD_ID_VARFG_MASK		GENMASK(7, 4)
-#define BOARD_ID_VARFG_SHIFT		4
-#define BOARD_ID_BOM_MASK		GENMASK(3, 0)
-
-#define BOARD_ID2NB(_id)		(((_id) & BOARD_ID_BOARD_NB_MASK) >> \
-					 BOARD_ID_BOARD_NB_SHIFT)
-#define BOARD_ID2VARCPN(_id)		(((_id) & BOARD_ID_VARCPN_MASK) >> \
-					 BOARD_ID_VARCPN_SHIFT)
-#define BOARD_ID2REV(_id)		(((_id) & BOARD_ID_REVISION_MASK) >> \
-					 BOARD_ID_REVISION_SHIFT)
-#define BOARD_ID2VARFG(_id)		(((_id) & BOARD_ID_VARFG_MASK) >> \
-					 BOARD_ID_VARFG_SHIFT)
-#define BOARD_ID2BOM(_id)		((_id) & BOARD_ID_BOM_MASK)
-
-#if STM32MP13
-#define TAMP_BOOT_MODE_BACKUP_REG_ID	U(30)
-#endif
-#if STM32MP15
-#define TAMP_BOOT_MODE_BACKUP_REG_ID	U(20)
-#endif
-#define TAMP_BOOT_MODE_ITF_MASK		GENMASK(15, 8)
-#define TAMP_BOOT_MODE_ITF_SHIFT	8
-#define TAMP_BOOT_MODE_AUTH_MASK	GENMASK(23, 16)
-#define TAMP_BOOT_MODE_AUTH_SHIFT	16
-
-/*
- * Backup register to store fwu update information.
- * It should be writeable only by secure world, but also readable by non secure
- * (so it should be in Zone 2).
- */
-#define TAMP_BOOT_FWU_INFO_REG_ID	U(10)
-#define TAMP_BOOT_FWU_INFO_IDX_MSK	GENMASK(3, 0)
-#define TAMP_BOOT_FWU_INFO_IDX_OFF	U(0)
-#define TAMP_BOOT_FWU_INFO_CNT_MSK	GENMASK(7, 4)
-#define TAMP_BOOT_FWU_INFO_CNT_OFF	U(4)
-
 #if defined(IMAGE_BL2)
 #define MAP_SEC_SYSRAM	MAP_REGION_FLAT(STM32MP_SYSRAM_BASE, \
 					STM32MP_SYSRAM_SIZE, \
@@ -140,14 +98,14 @@ void configure_mmu(void)
 uintptr_t stm32_get_gpio_bank_base(unsigned int bank)
 {
 #if STM32MP13
-	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_I);
+	assert(bank <= GPIO_BANK_I);
 #endif
 #if STM32MP15
 	if (bank == GPIO_BANK_Z) {
 		return GPIOZ_BASE;
 	}
 
-	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+	assert(bank <= GPIO_BANK_K);
 #endif
 
 	return GPIOA_BASE + (bank * GPIO_BANK_OFFSET);
@@ -156,14 +114,14 @@ uintptr_t stm32_get_gpio_bank_base(unsigned int bank)
 uint32_t stm32_get_gpio_bank_offset(unsigned int bank)
 {
 #if STM32MP13
-	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_I);
+	assert(bank <= GPIO_BANK_I);
 #endif
 #if STM32MP15
 	if (bank == GPIO_BANK_Z) {
 		return 0;
 	}
 
-	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+	assert(bank <= GPIO_BANK_K);
 #endif
 
 	return bank * GPIO_BANK_OFFSET;
@@ -186,14 +144,14 @@ bool stm32_gpio_is_secure_at_reset(unsigned int bank)
 unsigned long stm32_get_gpio_bank_clock(unsigned int bank)
 {
 #if STM32MP13
-	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_I);
+	assert(bank <= GPIO_BANK_I);
 #endif
 #if STM32MP15
 	if (bank == GPIO_BANK_Z) {
 		return GPIOZ;
 	}
 
-	assert(GPIO_BANK_A == 0 && bank <= GPIO_BANK_K);
+	assert(bank <= GPIO_BANK_K);
 #endif
 
 	return GPIOA + (bank - GPIO_BANK_A);
@@ -306,10 +264,15 @@ void stm32mp1_deconfigure_uart_pins(void)
 }
 #endif
 
+uintptr_t stm32_get_header_address(void)
+{
+	return STM32MP_HEADER_BASE;
+}
+
 uint32_t stm32mp_get_chip_version(void)
 {
 #if STM32MP13
-	return stm32mp1_syscfg_get_chip_version();
+	return stm32mp_syscfg_get_chip_version();
 #endif
 #if STM32MP15
 	uint32_t version = 0U;
@@ -326,7 +289,7 @@ uint32_t stm32mp_get_chip_version(void)
 uint32_t stm32mp_get_chip_dev_id(void)
 {
 #if STM32MP13
-	return stm32mp1_syscfg_get_chip_dev_id();
+	return stm32mp_syscfg_get_chip_dev_id();
 #endif
 #if STM32MP15
 	uint32_t dev_id;
@@ -378,7 +341,7 @@ static uint32_t get_cpu_package(void)
 
 void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
 {
-	char *cpu_s, *cpu_r, *pkg;
+	const char *cpu_s, *cpu_r, *pkg;
 
 	/* MPUs Part Numbers */
 	switch (get_part_number()) {
@@ -493,11 +456,9 @@ void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
 	case STM32MP1_REV_B:
 		cpu_r = "B";
 		break;
-#if STM32MP13
 	case STM32MP1_REV_Y:
 		cpu_r = "Y";
 		break;
-#endif
 	case STM32MP1_REV_Z:
 		cpu_r = "Z";
 		break;
@@ -520,23 +481,14 @@ void stm32mp_print_cpuinfo(void)
 
 void stm32mp_print_boardinfo(void)
 {
-	uint32_t board_id = 0;
+	uint32_t board_id = 0U;
 
 	if (stm32_get_otp_value(BOARD_ID_OTP, &board_id) != 0) {
 		return;
 	}
 
 	if (board_id != 0U) {
-		char rev[2];
-
-		rev[0] = BOARD_ID2REV(board_id) - 1 + 'A';
-		rev[1] = '\0';
-		NOTICE("Board: MB%04x Var%u.%u Rev.%s-%02u\n",
-		       BOARD_ID2NB(board_id),
-		       BOARD_ID2VARCPN(board_id),
-		       BOARD_ID2VARFG(board_id),
-		       rev,
-		       BOARD_ID2BOM(board_id));
+		stm32_display_board_info(board_id);
 	}
 }
 
@@ -565,12 +517,12 @@ bool stm32mp_is_single_core(void)
 }
 
 /* Return true when device is in closed state */
-bool stm32mp_is_closed_device(void)
+uint32_t stm32mp_check_closed_device(void)
 {
 	uint32_t value;
 
 	if (stm32_get_otp_value(CFG0_OTP, &value) != 0) {
-		return true;
+		return STM32MP_CHIP_SEC_CLOSED;
 	}
 
 #if STM32MP13
@@ -578,17 +530,22 @@ bool stm32mp_is_closed_device(void)
 
 	switch (value) {
 	case CFG0_OPEN_DEVICE:
-		return false;
+		return STM32MP_CHIP_SEC_OPEN;
 	case CFG0_CLOSED_DEVICE:
 	case CFG0_CLOSED_DEVICE_NO_BOUNDARY_SCAN:
 	case CFG0_CLOSED_DEVICE_NO_JTAG:
-		return true;
+		return STM32MP_CHIP_SEC_CLOSED;
 	default:
 		panic();
 	}
 #endif
 #if STM32MP15
-	return (value & CFG0_CLOSED_DEVICE) == CFG0_CLOSED_DEVICE;
+	if ((value & CFG0_CLOSED_DEVICE) == CFG0_CLOSED_DEVICE) {
+		return STM32MP_CHIP_SEC_CLOSED;
+	} else {
+		return STM32MP_CHIP_SEC_OPEN;
+	}
+
 #endif
 }
 
@@ -648,141 +605,109 @@ uint32_t stm32_iwdg_get_otp_config(uint32_t iwdg_inst)
 		iwdg_cfg |= IWDG_HW_ENABLED;
 	}
 
-	if ((otp_value & BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STOP_POS)) != 0U) {
-		iwdg_cfg |= IWDG_DISABLE_ON_STOP;
-	}
-
-	if ((otp_value & BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STANDBY_POS)) != 0U) {
-		iwdg_cfg |= IWDG_DISABLE_ON_STANDBY;
-	}
-
 	return iwdg_cfg;
 }
 
-#if defined(IMAGE_BL2)
-uint32_t stm32_iwdg_shadow_update(uint32_t iwdg_inst, uint32_t flags)
-{
-	uint32_t otp_value;
-	uint32_t otp;
-	uint32_t result;
 
-	if (stm32_get_otp_index(HW2_OTP, &otp, NULL) != 0) {
-		panic();
-	}
+bool stm32mp1_addr_inside_backupsram(uintptr_t addr)
+{
+	return (addr >= STM32MP_BACKUP_RAM_BASE) &&
+		(addr < (STM32MP_BACKUP_RAM_BASE + STM32MP_BACKUP_RAM_SIZE));
+}
 
-	if (stm32_get_otp_value(HW2_OTP, &otp_value) != 0) {
-		panic();
-	}
+bool stm32mp_is_wakeup_from_standby(void)
+{
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	return false;
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+	uint32_t rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_MP_RSTSCLRR);
+#if STM32MP15
+	uint32_t nsec_address;
+	struct nvmem_cell core1_branch_address = {};
+#endif
 
-	if ((flags & IWDG_DISABLE_ON_STOP) != 0) {
-		otp_value |= BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STOP_POS);
+	if ((rstsr & RCC_MP_RSTSCLRR_PADRSTF) != 0U) {
+		return false;
 	}
 
-	if ((flags & IWDG_DISABLE_ON_STANDBY) != 0) {
-		otp_value |= BIT(iwdg_inst + HW2_OTP_IWDG_FZ_STANDBY_POS);
+	if (stm32mp_get_boot_action() != BOOT_API_CTX_BOOT_ACTION_WAKEUP_STANDBY) {
+		return false;
 	}
 
-	result = bsec_write_otp(otp_value, otp);
-	if (result != BSEC_OK) {
-		return result;
-	}
+#if STM32MP15
+	stm32_get_core1_branch_address_cell(&core1_branch_address);
+	nvmem_cell_read(&core1_branch_address, (uint8_t *)&nsec_address,
+			sizeof(nsec_address), NULL);
 
-	/* Sticky lock OTP_IWDG (read and write) */
-	if ((bsec_set_sr_lock(otp) != BSEC_OK) ||
-	    (bsec_set_sw_lock(otp) != BSEC_OK)) {
-		return BSEC_LOCK_FAIL;
+	if (nsec_address == 0U) {
+		return false;
 	}
-
-	return BSEC_OK;
-}
 #endif
 
-void stm32_save_boot_interface(uint32_t interface, uint32_t instance)
-{
-	uintptr_t bkpr_itf_idx = tamp_bkpr(TAMP_BOOT_MODE_BACKUP_REG_ID);
-
-	clk_enable(RTCAPB);
-
-	mmio_clrsetbits_32(bkpr_itf_idx,
-			   TAMP_BOOT_MODE_ITF_MASK,
-			   ((interface << 4) | (instance & 0xFU)) <<
-			   TAMP_BOOT_MODE_ITF_SHIFT);
-
-	clk_disable(RTCAPB);
+	return stm32_pm_context_is_valid();
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
 }
 
-void stm32_get_boot_interface(uint32_t *interface, uint32_t *instance)
+bool stm32mp_skip_boot_device_after_standby(void)
 {
-	static uint32_t itf;
-
-	if (itf == 0U) {
-		uintptr_t bkpr = tamp_bkpr(TAMP_BOOT_MODE_BACKUP_REG_ID);
-
-		clk_enable(RTCAPB);
-
-		itf = (mmio_read_32(bkpr) & TAMP_BOOT_MODE_ITF_MASK) >>
-			TAMP_BOOT_MODE_ITF_SHIFT;
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	return false;
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+	static int skip = -1;
 
-		clk_disable(RTCAPB);
+	if (skip == -1) {
+		if (stm32mp_is_wakeup_from_standby()) {
+			skip = 1;
+#if STM32MP15
+			if (stm32_pm_get_optee_ep() == 0U) {
+				skip = 0;
+			}
+#endif
+		} else {
+			skip = 0;
+		}
 	}
 
-	*interface = itf >> 4;
-	*instance = itf & 0xFU;
+	return skip == 1;
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
 }
 
-void stm32_save_boot_auth(uint32_t auth_status, uint32_t boot_partition)
+#if STM32MP13
+bool stm32mp_bkpram_get_access(void)
 {
-	uint32_t boot_status = tamp_bkpr(TAMP_BOOT_MODE_BACKUP_REG_ID);
+	static bool state = true;
+
+	if (!state) {
+		return state;
+	}
 
 	clk_enable(RTCAPB);
 
-	mmio_clrsetbits_32(boot_status,
-			   TAMP_BOOT_MODE_AUTH_MASK,
-			   ((auth_status << 4) | (boot_partition & 0xFU)) <<
-			   TAMP_BOOT_MODE_AUTH_SHIFT);
+	if ((mmio_read_32(TAMP_BASE + TAMP_ERCFGR) != 0U) &&
+	    (mmio_read_32(TAMP_BASE + TAMP_SR) != 0U) &&
+	    (((mmio_read_32(TAMP_BASE + TAMP_CR2) & TAMP_CR2_MASK_NOER) == 0U) ||
+	     ((mmio_read_32(TAMP_BASE + TAMP_CR3) & TAMP_CR3_MASK_NOER) == 0U))) {
+		NOTICE("TAMPER detected : Degraded mode\n");
+		state = false;
+	}
 
 	clk_disable(RTCAPB);
-}
 
-#if PSA_FWU_SUPPORT
-void stm32mp1_fwu_set_boot_idx(void)
-{
-	clk_enable(RTCAPB);
-	mmio_clrsetbits_32(tamp_bkpr(TAMP_BOOT_FWU_INFO_REG_ID),
-			   TAMP_BOOT_FWU_INFO_IDX_MSK,
-			   (plat_fwu_get_boot_idx() << TAMP_BOOT_FWU_INFO_IDX_OFF) &
-			   TAMP_BOOT_FWU_INFO_IDX_MSK);
-	clk_disable(RTCAPB);
+	return state;
 }
-
-uint32_t stm32_get_and_dec_fwu_trial_boot_cnt(void)
+#else /* STM32MP15 */
+bool stm32mp_bkpram_get_access(void)
 {
-	uintptr_t bkpr_fwu_cnt = tamp_bkpr(TAMP_BOOT_FWU_INFO_REG_ID);
-	uint32_t try_cnt;
-
-	clk_enable(RTCAPB);
-	try_cnt = (mmio_read_32(bkpr_fwu_cnt) & TAMP_BOOT_FWU_INFO_CNT_MSK) >>
-		TAMP_BOOT_FWU_INFO_CNT_OFF;
-
-	assert(try_cnt <= FWU_MAX_TRIAL_REBOOT);
+	/* Remove erase signal before cleaning Backup SRAM */
+	uint32_t cr2_v = mmio_read_32(TAMP_BASE + TAMP_CR2);
+	uint32_t sr_v = mmio_read_32(TAMP_BASE + TAMP_SR);
+	uint32_t erase_flag = (sr_v & (TAMP_CR2_MASK_NOER | TAMP_SR_MASK_ITAMPx)) &
+			      (((~cr2_v) & TAMP_CR2_MASK_NOER) | TAMP_SR_MASK_ITAMPx);
 
-	if (try_cnt != 0U) {
-		mmio_clrsetbits_32(bkpr_fwu_cnt, TAMP_BOOT_FWU_INFO_CNT_MSK,
-				   (try_cnt - 1U) << TAMP_BOOT_FWU_INFO_CNT_OFF);
+	if (erase_flag != 0U) {
+		mmio_write_32(TAMP_BASE + TAMP_SCR, erase_flag);
 	}
-	clk_disable(RTCAPB);
-
-	return try_cnt;
-}
-
-void stm32_set_max_fwu_trial_boot_cnt(void)
-{
-	uintptr_t bkpr_fwu_cnt = tamp_bkpr(TAMP_BOOT_FWU_INFO_REG_ID);
 
-	clk_enable(RTCAPB);
-	mmio_clrsetbits_32(bkpr_fwu_cnt, TAMP_BOOT_FWU_INFO_CNT_MSK,
-			   (FWU_MAX_TRIAL_REBOOT << TAMP_BOOT_FWU_INFO_CNT_OFF) &
-			   TAMP_BOOT_FWU_INFO_CNT_MSK);
-	clk_disable(RTCAPB);
+	return true;
 }
-#endif /* PSA_FWU_SUPPORT */
+#endif
diff --git a/plat/st/stm32mp1/stm32mp1_ssp.c b/plat/st/stm32mp1/stm32mp1_ssp.c
new file mode 100644
index 0000000000..2819242b8a
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_ssp.c
@@ -0,0 +1,1048 @@
+/*
+ * Copyright (c) 2017-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <endian.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <drivers/clk.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/regulator.h>
+#include <drivers/st/stm32_hash.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32_uart.h>
+#include <drivers/st/stm32mp_pmic.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stpmic1.h>
+#include <drivers/usb_device.h>
+#include <lib/mmio.h>
+#include <lib/utils.h>
+#include <lib/utils_def.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32cubeprogrammer.h>
+#include <usb_dfu.h>
+
+#define CERT_CHIP_ID_LEN		U(3)
+#define CERT_SECURITY_COUNTER_LEN	U(2)
+#define CERT_SECURITY_COUNTER_SHIFT	CERT_CHIP_ID_LEN
+#define CERT_RFU_LEN			U(1)
+#define CERT_RFU_SHIFT			(CERT_SECURITY_COUNTER_LEN + \
+					 CERT_SECURITY_COUNTER_SHIFT)
+#define CERT_PRODUCT_KEY_LEN		U(2)
+#define CERT_PRODUCT_KEY_SHIFT		(CERT_RFU_LEN + CERT_RFU_SHIFT)
+#define CERT_PRODUCT_ID_SIZE		(CERT_PRODUCT_KEY_LEN + \
+					 CERT_PRODUCT_KEY_SHIFT)
+#define CERT_SIGNATURE_LEN		CHIP_CERTIFICATE_MAX_SIZE
+#define CERT_SIGNATURE_SHIFT		(CERT_PRODUCT_ID_SIZE + \
+					 BOOT_API_SSP_PUBK_KEY_SIZE_BYTES)
+#define CERTIFICATE_SIZE		(CERT_PRODUCT_ID_SIZE + \
+					 BOOT_API_SSP_PUBK_KEY_SIZE_BYTES + \
+					 CERT_SIGNATURE_LEN) /* 136 bytes */
+#define BLOB_FILE_MAX_ADDR		BL2_RW_LIMIT
+
+/* Local status for SSP processing sequences */
+typedef enum {
+	SSP_NONE,
+	SSP_GET_CERT,
+	SSP_FLASH_OEM,
+	SSP_DONE,
+	SSP_ERROR
+} ssp_result_e;
+
+struct otp_val {
+	uint32_t idx;
+	uint32_t nb;
+};
+
+static struct otp_val otp_ssp;
+static struct otp_val otp_rma;
+static struct otp_val otp_pubkey;
+
+/* Platform empty definition required */
+void bl2_platform_setup(void) {}
+struct bl_params *plat_get_next_bl_params(void) { return NULL; }
+void plat_flush_next_bl_params(void) {}
+struct bl_load_info *plat_get_bl_image_load_info(void) { return NULL; }
+int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
+			  uintptr_t *image_spec)
+{
+	return 0;
+}
+
+/*
+ * Initialized OTP index from device tree.
+ */
+static int initialize_otp(void)
+{
+	uint32_t len;
+
+	/* OTP SSP */
+	if (stm32_get_otp_index(SSP_OTP, &otp_ssp.idx, NULL) != 0) {
+		VERBOSE("%s: get index error\n", __func__);
+		return -EINVAL;
+	}
+
+	/* OTP public key */
+	if (stm32_get_otp_index(PKH_OTP, &otp_pubkey.idx, &len) != 0) {
+		VERBOSE("%s: get index error\n", __func__);
+		return -EINVAL;
+	}
+
+	if (len != (CHAR_BIT * BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES)) {
+		VERBOSE("%s: length Error\n", __func__);
+		return -EINVAL;
+	}
+
+	otp_pubkey.nb = len / __WORD_BIT;
+
+	/* OTP RMA */
+	if (stm32_get_otp_index(RMA_OTP, &otp_rma.idx, NULL) != 0) {
+		VERBOSE("%s: get index error\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Compute HASH from public key and burn it in OTP.
+ */
+static int ssp_pub_key_prog(boot_api_context_t *boot_context)
+{
+#if STM32MP13
+	uint32_t *value = (uint32_t *)
+		boot_context->p_ssp_config->p_blob_payload->oem_rpkth;
+#endif
+#if STM32MP15
+	uint8_t key_hash[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES] __aligned(4);
+	uint8_t *pubk = (uint8_t *)
+		boot_context->p_ssp_config->p_blob_payload->oem_ecdsa_pubk;
+	uint32_t *value = (uint32_t *)key_hash;
+#endif
+	uint32_t i;
+
+#if STM32MP15
+	if (stm32_hash_register() != 0) {
+		return -EINVAL;
+	}
+
+	stm32_hash_init(HASH_SHA256);
+
+	if (stm32_hash_final_update(pubk, BOOT_API_SSP_PUBK_KEY_SIZE_BYTES,
+				    key_hash) != 0) {
+		ERROR("Hash of payload failed\n");
+		return -EINVAL;
+	}
+#endif
+
+	for (i = otp_pubkey.idx; i < (otp_pubkey.idx + otp_pubkey.nb); i++) {
+		if (bsec_program_otp(bswap32(*value), i) != BSEC_OK) {
+			return -EINVAL;
+		}
+
+		value++;
+		if (bsec_permanent_lock_otp(i) != BSEC_OK) {
+			ERROR("Error locking OTP %u\n", i);
+			panic();
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Burn OTP to close device.
+ */
+static int ssp_close_device(void)
+{
+	uint32_t otp;
+	uint32_t value;
+
+	if (stm32_get_otp_index(CFG0_OTP, &otp, NULL) != 0) {
+		return -EINVAL;
+	}
+
+	if (bsec_read_otp(&value, otp) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+#if STM32MP13
+	if ((value & ~CFG0_OPEN_DEVICE) != 0U) {
+		ERROR("Device already closed\n");
+		return -EINVAL;
+	}
+#endif
+#if STM32MP15
+	if ((value & CFG0_CLOSED_DEVICE) != 0U) {
+		ERROR("Device already closed\n");
+		return -EINVAL;
+	}
+#endif
+
+	value |= CFG0_CLOSED_DEVICE;
+	if (bsec_program_otp(value, otp) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * OTP initial check to detect previous values.
+ */
+static int ssp_secrets_check(boot_api_context_t *boot_ctx)
+{
+	uint32_t i;
+	uint32_t check_val;
+	uint32_t otp_bytes = boot_ctx->p_ssp_config->p_blob_payload->oem_secret_size_bytes;
+	uint32_t otp_decrypted;
+	uint32_t *val;
+
+	if (otp_bytes == 0U) {
+		return -EINVAL;
+	}
+
+	for (i = otp_pubkey.idx; i < (otp_pubkey.idx + otp_pubkey.nb); i++) {
+		if (stm32_get_otp_value_from_idx(i, &check_val) != 0) {
+			return -EINVAL;
+		}
+
+		if (check_val != 0U) {
+			ERROR("OTP %u value already programmed\n", i);
+			return -EINVAL;
+		}
+	}
+
+	otp_decrypted = round_up(otp_bytes, sizeof(uint32_t)) / sizeof(uint32_t);
+
+	/* OTP decrypted include RMA password */
+	if (otp_decrypted > (2U + SSP_OTP_SECRET_END - SSP_OTP_SECRET_BASE)) {
+		return -EINVAL;
+	}
+
+	/* Check RMA password */
+	if (stm32_get_otp_value_from_idx(otp_rma.idx, &check_val) != 0) {
+		return -EINVAL;
+	}
+
+	if (check_val != 0U) {
+		ERROR("OTP %s value already programmed\n", RMA_OTP);
+		return -EINVAL;
+	}
+
+	val = (uint32_t *)boot_ctx->p_ssp_config->p_ssp_oem_secrets_decrypted;
+
+	/* Check all OTP available */
+	for (i = SSP_OTP_SECRET_BASE; i < SSP_OTP_SECRET_BASE + otp_decrypted - 1U; i++) {
+		val++;
+
+		if (*val == 0U) {
+			continue;
+		}
+
+		if (stm32_get_otp_value_from_idx(i, &check_val) != 0) {
+			return -EINVAL;
+		}
+
+		if (check_val != 0U) {
+			ERROR("OTP %u value already programmed\n", i);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Burn OTP with the decrypted secret received.
+ */
+static int ssp_secrets_flash(boot_api_context_t *boot_ctx)
+{
+	uint32_t i;
+	uint32_t *val;
+	uint32_t otp_val;
+	uint32_t otp_bytes =
+		boot_ctx->p_ssp_config->p_blob_payload->oem_secret_size_bytes;
+	uint32_t otp_decrypted;
+	uint32_t otp_mask = 0U;
+
+	if (otp_bytes == 0U) {
+		return -EINVAL;
+	}
+
+	if (otp_bytes % sizeof(uint32_t) != 0U) {
+		otp_mask = GENMASK_32(((otp_bytes % sizeof(uint32_t)) *
+				       sizeof(uint32_t)) - 1, 0);
+	}
+
+	val = (uint32_t *)boot_ctx->p_ssp_config->p_ssp_oem_secrets_decrypted;
+
+	otp_decrypted = round_up(otp_bytes, sizeof(uint32_t)) / sizeof(uint32_t);
+
+	/* Burn RMA password */
+	if (bsec_program_otp((*val & RMA_OTP_MASK), otp_rma.idx) !=  BSEC_OK) {
+		WARN("RMA programing failed\n");
+		return -EINVAL;
+	}
+
+	if (bsec_shadow_read_otp(&otp_val, otp_rma.idx) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+	if ((otp_val & RMA_OTP_MASK) != (*val & RMA_OTP_MASK)) {
+		WARN("RMA programming failed\n");
+		return -EINVAL;
+	}
+
+	if (bsec_permanent_lock_otp(otp_rma.idx) != BSEC_OK) {
+		WARN("Error locking RMA OTP\n");
+		return -EINVAL;
+	}
+
+	val++;
+	otp_decrypted--;
+	for (i = SSP_OTP_SECRET_BASE; i < (SSP_OTP_SECRET_BASE + otp_decrypted - 1U); i++) {
+		if (*val == 0U) {
+			val++;
+			continue;
+		}
+
+		if (bsec_program_otp(*val, i) != BSEC_OK) {
+			WARN("Error writing OTP %u\n", i);
+			return -EINVAL;
+		}
+
+		if (bsec_permanent_lock_otp(i) != BSEC_OK) {
+			WARN("Error locking OTP %u\n", i);
+			return -EINVAL;
+		}
+
+		val++;
+	}
+
+	if (*val == 0U) {
+		return 0;
+	}
+
+	/* Mask the last OTP value if needed */
+	if (otp_mask != 0U) {
+		*val &= otp_mask;
+	}
+
+	if (bsec_program_otp(*val, i) != BSEC_OK) {
+		WARN("Error writing OTP %u\n", i);
+		return -EINVAL;
+	}
+
+	if (bsec_permanent_lock_otp(i) != BSEC_OK) {
+		WARN("Error locking OTP %u\n", i);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Finish SSP processing by fusing OTP SSP success.
+ */
+static int ssp_finish_process(void)
+{
+	uint32_t val;
+
+	if (stm32_get_otp_value_from_idx(otp_ssp.idx, &val) != 0) {
+		return -EINVAL;
+	}
+
+	if ((val & SSP_OTP_SUCCESS) != 0U) {
+		WARN("Error while configuring OTP\n");
+		return -EINVAL;
+	}
+
+	val |= SSP_OTP_SUCCESS;
+	if (bsec_program_otp(val, otp_ssp.idx) != BSEC_OK) {
+		return -EINVAL;
+	}
+
+	VERBOSE("Write OTP Success\n");
+
+	return 0;
+}
+
+/*
+ * Transform integer to string.
+ */
+static void itoa(uint32_t num, char *str, int nb)
+{
+	if (num == 0U) {
+		while (nb-- != 0U) {
+			str[nb] = '0';
+		}
+
+		return;
+	}
+
+	while (num != 0U) {
+		int rem = num % 16;
+
+		str[--nb] = (rem > 9) ? (rem - 10) + 'A' : rem + '0';
+		num /= 16;
+	}
+
+	while (nb != 0) {
+		str[--nb] = '0';
+	}
+}
+
+/*
+ * Return chip product ID.
+ */
+static int ssp_get_product_id(char *msg)
+{
+	uint32_t otp;
+	uint32_t otp_idx;
+	uint32_t chip_id = stm32mp_get_chip_dev_id();
+
+	if (stm32_get_otp_index(CFG2_OTP, &otp_idx, NULL) != 0) {
+		VERBOSE("Get index error\n");
+		return -EINVAL;
+	}
+
+	if (stm32_get_otp_value_from_idx(otp_idx, &otp) != 0) {
+		return -EINVAL;
+	}
+
+	itoa(chip_id, msg, CERT_CHIP_ID_LEN);
+	itoa((otp & OTP_CFG2_SEC_COUNTER_MASK) >> OTP_CFG2_SEC_COUNTER_SHIFT,
+	     msg + CERT_SECURITY_COUNTER_SHIFT,
+	     CERT_SECURITY_COUNTER_LEN);
+
+	itoa(0, msg + CERT_RFU_SHIFT, CERT_RFU_LEN);
+	itoa((otp & OTP_CFG2_ST_KEY_MASK) >> OTP_CFG2_ST_KEY_SHIFT,
+	     msg + CERT_PRODUCT_KEY_SHIFT,
+	     CERT_PRODUCT_KEY_LEN);
+
+	return 0;
+}
+
+/*
+ * Construct SSP certificate.
+ */
+static int prepare_certificate(uint8_t *cert, const uint8_t *pubkey)
+{
+	uint32_t i;
+	uint32_t j;
+	uint32_t otp;
+	uint32_t otp_idx;
+	uint32_t otp_len;
+
+	/* Prepare the ROM Security constant */
+	if (ssp_get_product_id((char *)cert) != 0) {
+		return -EINVAL;
+	}
+
+	/* Prepare public key and certificate for flashloader */
+	/* Read Public Key from boot_context */
+	memcpy(cert + CERT_PRODUCT_ID_SIZE, pubkey, BOOT_API_SSP_PUBK_KEY_SIZE_BYTES);
+
+	if (stm32_get_otp_index(CHIP_CERTIFICATE_OTP,
+				&otp_idx, &otp_len) != 0) {
+		VERBOSE("Get index error\n");
+		return -EINVAL;
+	}
+
+	if (otp_len != (CHAR_BIT * CHIP_CERTIFICATE_MAX_SIZE)) {
+		VERBOSE("Length error\n");
+		return -EINVAL;
+	}
+
+	otp_len /= __WORD_BIT;
+
+	/* Read Certificat from OTP */
+	for (i = otp_idx, j = 0U; i < (otp_idx + otp_len); i++, j++) {
+		uint32_t otp_s;
+
+		if (stm32_get_otp_value_from_idx(i, &otp) != 0) {
+			return -EINVAL;
+		}
+
+		otp_s = bswap32(otp);
+		memcpy(&cert[CERT_SIGNATURE_SHIFT + (sizeof(uint32_t) * j)],
+		       &otp_s, sizeof(uint32_t));
+	}
+
+	return 0;
+}
+
+/*
+ * Clean OTP value that might be still in shadow registers
+ */
+static void cleanup_otp_value(void)
+{
+	unsigned int i;
+
+	/* RMA clear and lock */
+	if (bsec_write_otp(0U, otp_rma.idx) != BSEC_OK) {
+		return;
+	}
+
+	if (bsec_set_sr_lock(otp_rma.idx) != BSEC_OK) {
+		return;
+	}
+
+	for (i = SSP_OTP_SECRET_BASE; i < SSP_OTP_SECRET_END + 1U; i++) {
+		if (bsec_write_otp(0U, otp_rma.idx) != BSEC_OK) {
+			return;
+		}
+	}
+}
+
+/*
+ * Clean external data and bootrom context secret values.
+ */
+static void ssp_cleanup(boot_api_context_t *boot_context)
+{
+	boot_api_ssp_config_t *ssp_config = boot_context->p_ssp_config;
+
+	/* Cleanup boot_context */
+	if (ssp_config->p_ssp_oem_secrets_decrypted != NULL) {
+		zeromem(ssp_config->p_ssp_oem_secrets_decrypted,
+			BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES);
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_ssp_oem_secrets_decrypted,
+				   BOOT_API_SSP_OEM_SECRETS_MAX_SIZE_BYTES);
+#endif
+		ssp_config->p_ssp_oem_secrets_decrypted = NULL;
+	}
+
+	if (ssp_config->p_chip_pubk != NULL) {
+		zeromem(ssp_config->p_chip_pubk,
+			BOOT_API_SSP_PUBK_KEY_SIZE_BYTES);
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_chip_pubk,
+				   BOOT_API_SSP_PUBK_KEY_SIZE_BYTES);
+#endif
+		ssp_config->p_chip_pubk = NULL;
+	}
+
+	if (ssp_config->p_blob_license != NULL) {
+		zeromem(ssp_config->p_blob_license,
+			sizeof(boot_api_ssp_blob_license_t));
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_blob_license,
+				   sizeof(boot_api_ssp_blob_license_t));
+#endif
+		ssp_config->p_blob_license = NULL;
+	}
+
+	if (ssp_config->p_blob_payload != NULL) {
+		zeromem(ssp_config->p_blob_payload,
+			sizeof(boot_api_ssp_blob_payload_t));
+#ifndef DCACHE_OFF
+		flush_dcache_range((uintptr_t)ssp_config->p_blob_payload,
+			   sizeof(boot_api_ssp_blob_payload_t));
+#endif
+		ssp_config->p_blob_payload = NULL;
+	}
+
+	ssp_config->ssp_cmd = 0U;
+
+#ifndef DCACHE_OFF
+	flush_dcache_range((uintptr_t)boot_context->p_ssp_config,
+			   sizeof(boot_api_ssp_config_t));
+#endif
+}
+
+/*
+ * Send certificate to the programmer and retrieve the associated
+ * encrypted file.
+ */
+static int ssp_download_phase(boot_api_context_t *boot_ctx)
+{
+	uint8_t *blob_file;
+#if STM32MP_UART_PROGRAMMER
+	uintptr_t uart_base;
+#endif
+#if STM32MP_USB_PROGRAMMER
+	struct usb_handle *pdev;
+#endif
+	int result = 0;
+	uint8_t cert[CERTIFICATE_SIZE];
+
+#if STM32MP13
+	blob_file = (uint8_t *)boot_ctx->p_ssp_config->p_blob_license;
+#endif
+#if STM32MP15
+	blob_file = (uint8_t *)page_align(BLOB_FILE_MAX_ADDR -
+					  sizeof(boot_api_ssp_blob_license_t) -
+					  sizeof(boot_api_ssp_blob_payload_t),
+					  DOWN);
+#endif
+
+	if (prepare_certificate(cert, boot_ctx->p_ssp_config->p_chip_pubk) != 0) {
+		return -EINVAL;
+	}
+
+	switch (boot_ctx->boot_interface_selected) {
+#if STM32MP_USB_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+
+		/* init USB on platform */
+		pdev = usb_dfu_plat_init();
+
+		result = stm32cubeprog_usb_ssp(pdev, (uintptr_t)cert,
+					       sizeof(cert), (uintptr_t)blob_file,
+					       sizeof(boot_api_ssp_blob_license_t) +
+					       sizeof(boot_api_ssp_blob_payload_t));
+		if (result != 0) {
+			return -EINVAL;
+		}
+
+		break;
+#endif
+
+#if STM32MP_UART_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+		uart_base = get_uart_address(boot_ctx->boot_interface_instance);
+
+		if (uart_base == 0U) {
+			return -EINVAL;
+		}
+
+		result = stm32cubeprog_uart_ssp(uart_base, (uintptr_t)cert, sizeof(cert),
+						(uintptr_t)blob_file,
+						sizeof(boot_api_ssp_blob_license_t) +
+						sizeof(boot_api_ssp_blob_payload_t));
+		if (result != 0) {
+			return -EINVAL;
+		}
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	boot_ctx->p_ssp_config->p_blob_license =
+		(boot_api_ssp_blob_license_t *)blob_file;
+
+	/* Payload is concatened with license file */
+	boot_ctx->p_ssp_config->p_blob_payload =
+		(boot_api_ssp_blob_payload_t *)(blob_file +
+		sizeof(boot_api_ssp_blob_license_t));
+
+#ifndef DCACHE_OFF
+	flush_dcache_range((uintptr_t)blob_file,
+			   sizeof(boot_api_ssp_blob_license_t) +
+			   sizeof(boot_api_ssp_blob_payload_t));
+#endif
+
+	/* Set return address for decrypted_secrets */
+	boot_ctx->p_ssp_config->p_ssp_oem_secrets_decrypted =
+		boot_ctx->p_ssp_config->p_blob_payload->oem_encrypted_secrets;
+
+	return result;
+}
+
+/*
+ * Burn decrypted secrets into OTP, clean memory and close the device.
+ */
+static int ssp_secret_programming(boot_api_context_t *boot_context)
+{
+	int result;
+
+	result = ssp_secrets_check(boot_context);
+	if (result != 0) {
+		ERROR("SSP ERROR checking OTP\n");
+		goto clean;
+	}
+
+	result = ssp_pub_key_prog(boot_context);
+	if (result != 0) {
+		ERROR("SSP ERROR writing HASH key\n");
+		goto clean;
+	}
+
+	result = ssp_close_device();
+	if (result != 0) {
+		ERROR("SSP close device failed\n");
+		goto clean;
+	}
+
+	result = ssp_secrets_flash(boot_context);
+	if (result != 0) {
+		ERROR("SSP Secret flash failed\n");
+	}
+
+clean:
+	cleanup_otp_value();
+
+	ssp_cleanup(boot_context);
+
+	if (result != 0) {
+		return result;
+	}
+
+	return ssp_finish_process();
+}
+
+/*
+ * Enable the SSP processing.
+ */
+static int ssp_enable_processing(boot_api_context_t *boot_context)
+{
+	uint32_t val;
+	int result;
+#if STM32MP_USB_PROGRAMMER
+	struct usb_handle *pdev;
+#endif
+#if STM32MP_UART_PROGRAMMER
+	uintptr_t uart_base;
+#endif
+
+	if (stm32_get_otp_value_from_idx(otp_ssp.idx, &val) != 0) {
+		return -EINVAL;
+	}
+
+	if (((val & SSP_OTP_MASK) == SSP_OTP_MASK) ||
+	    ((val & SSP_OTP_MASK) == SSP_OTP_SUCCESS)) {
+		return -EINVAL;
+	}
+
+	if ((val & SSP_OTP_MASK) == 0U) {
+		if (bsec_program_otp(SSP_OTP_REQ, otp_ssp.idx) != BSEC_OK) {
+			return -EINVAL;
+		}
+	}
+
+	switch (boot_context->boot_interface_selected) {
+#if STM32MP_UART_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART:
+		uart_base = get_uart_address(boot_context->boot_interface_instance);
+		if (uart_base == 0U) {
+			return -EINVAL;
+		}
+
+		result = stm32cubeprog_uart_ssp(uart_base, (uintptr_t)-1, 0,
+						(uintptr_t)NULL, 0);
+		if (result != 0) {
+			return -EINVAL;
+		}
+		break;
+#endif
+#if STM32MP_USB_PROGRAMMER
+	case BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB:
+		/* init USB on platform */
+		pdev = usb_dfu_plat_init();
+
+		result = stm32cubeprog_usb_ssp(pdev, (uintptr_t)-1, 0,
+					       (uintptr_t)NULL, 0);
+		if (result != 0) {
+			return -EINVAL;
+		}
+
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	boot_context->p_ssp_config->ssp_cmd =
+		BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK;
+
+	return 0;
+}
+
+/*
+ * Retrieve the current status of the SSP from bootrom context and OTP value.
+ */
+static ssp_result_e ssp_check_status(boot_api_context_t *boot_context)
+{
+	uint32_t otp;
+
+	if (initialize_otp() < 0) {
+		return SSP_ERROR;
+	}
+
+	if (stm32_get_otp_value_from_idx(otp_ssp.idx, &otp) != 0) {
+		return SSP_ERROR;
+	}
+
+	if ((otp & SSP_OTP_REQ) == 0U) {
+		return SSP_NONE;
+	}
+
+	if ((otp & SSP_OTP_SUCCESS) != 0U) {
+		return SSP_DONE;
+	}
+
+	VERBOSE("Start Get ssp_cmd : %x\n",
+		boot_context->p_ssp_config->ssp_cmd);
+
+	switch (boot_context->p_ssp_config->ssp_cmd) {
+	case BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK_ACK:
+		INFO("Detected start SSP Phase 2\n");
+		return SSP_GET_CERT;
+	case BOOT_API_CTX_SSP_CMD_PROV_SECRET_ACK:
+		INFO("Detected start SSP Phase 3\n");
+		return SSP_FLASH_OEM;
+	default:
+		return SSP_NONE;
+	}
+}
+
+/*
+ * Start the SSP processing.
+ */
+static void ssp_start(boot_api_context_t *boot_context)
+{
+	int result;
+	uint8_t ssp_phase = ssp_check_status(boot_context);
+
+	switch (ssp_phase) {
+	case SSP_GET_CERT:
+		result = ssp_download_phase(boot_context);
+		if (result != 0) {
+			/*
+			 * Download Phase failed, clean, reset
+			 */
+			ssp_cleanup(boot_context);
+
+			ERROR("SSP_Error: Resetting target\n");
+		} else {
+			/* Process completed, go to Phase 3 */
+			boot_context->p_ssp_config->ssp_cmd =
+				BOOT_API_CTX_SSP_CMD_PROV_SECRET;
+		}
+
+		break;
+
+	case SSP_FLASH_OEM:
+		result = ssp_secret_programming(boot_context);
+		if (result != 0) {
+			ERROR("Error during provisionning\n");
+		} else {
+			NOTICE("Provisioning completed\n");
+		}
+
+		break;
+
+	case SSP_ERROR:
+		/*
+		 * Error during bootrom SSP processing
+		 */
+		result = -EINVAL;
+		ERROR("SSP_Error: Resetting target\n");
+		break;
+
+	case SSP_NONE:
+	default:
+		result = ssp_enable_processing(boot_context);
+		if (result != 0) {
+			ERROR("Start SSP Failed (%i)\n", result);
+		}
+	}
+
+	if ((result != 0) || (ssp_phase == SSP_FLASH_OEM)) {
+		goto out;
+	}
+
+	/*
+	 * Keep VDDCORE && VDD enabled if PMIC used to generate
+	 * the required MPSYSRST.
+	 */
+	if (dt_pmic_status() > 0) {
+		struct rdev *regul;
+
+		regul = dt_get_sysram_regulator();
+		if (regul == NULL) {
+			panic();
+		}
+
+		if (regulator_set_flag(regul, REGUL_MASK_RESET) < 0) {
+			WARN("Failed to write cpu-supply reset mask\n");
+		}
+
+		regul = dt_get_vdd_regulator();
+		if (regul == NULL) {
+			goto out;
+		}
+
+		if (regulator_set_flag(regul, REGUL_MASK_RESET) < 0) {
+			WARN("Failed to write vdd-supply reset mask\n");
+		}
+	} else {
+		static const char debug_msg[] = {
+			"SSP next step will be only guarantee if the VDD\n"
+			"domain is maintained during system reset\n"
+		};
+
+		NOTICE("%s", debug_msg);
+	}
+
+out:
+#ifndef DCACHE_OFF
+	if (boot_context->p_ssp_config != NULL) {
+		flush_dcache_range((uintptr_t)boot_context->p_ssp_config,
+				   sizeof(boot_api_ssp_config_t));
+	}
+#endif
+
+	stm32mp_system_reset();
+}
+
+void bl2_el3_early_platform_setup(u_register_t arg0,
+				  u_register_t arg1 __unused,
+				  u_register_t arg2 __unused,
+				  u_register_t arg3 __unused)
+{
+	stm32mp_save_boot_ctx_address(arg0);
+}
+
+void bl2_el3_plat_arch_setup(void)
+{
+#if DEBUG
+	const char *board_model;
+#endif
+	uintptr_t pwr_base;
+	uintptr_t rcc_base;
+
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+
+	if (bsec_probe() != 0) {
+		panic();
+	}
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+#if SEPARATE_CODE_AND_RODATA
+	mmap_add_region(BL_RO_DATA_BASE, BL_RO_DATA_BASE,
+			BL_RO_DATA_END - BL_RO_DATA_BASE,
+			MT_RO_DATA | MT_SECURE);
+#endif
+
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_region(DTB_BASE, DTB_BASE,
+			DTB_LIMIT - DTB_BASE,
+			MT_RO_DATA | MT_SECURE);
+
+	configure_mmu();
+
+	if (dt_open_and_check(STM32MP_DTB_BASE) < 0) {
+		panic();
+	}
+
+	pwr_base = stm32mp_pwr_base();
+	rcc_base = stm32mp_rcc_base();
+
+	/*
+	 * Disable the backup domain write protection.
+	 * The protection is enable at each reset by hardware
+	 * and must be disabled by software.
+	 */
+	mmio_setbits_32(pwr_base + PWR_CR1, PWR_CR1_DBP);
+
+	while ((mmio_read_32(pwr_base + PWR_CR1) & PWR_CR1_DBP) == 0U) {
+		;
+	}
+
+	/* Reset backup domain on cold boot cases */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCSRC_MASK) == 0U) {
+		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+
+		while ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST) ==
+		       0U) {
+			;
+		}
+
+		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+	}
+
+	/* Set minimum reset pulse duration to 31ms for discrete power supplied boards */
+	if (dt_pmic_status() <= 0) {
+		mmio_clrsetbits_32(rcc_base + RCC_RDLSICR, RCC_RDLSICR_MRD_MASK,
+				   31U << RCC_RDLSICR_MRD_SHIFT);
+	}
+
+	generic_delay_timer_init();
+
+#if STM32MP_UART_PROGRAMMER
+	/* Disable programmer UART before changing clock tree */
+	if (boot_context->boot_interface_selected ==
+	    BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART) {
+		uintptr_t uart_prog_addr =
+			get_uart_address(boot_context->boot_interface_instance);
+
+		stm32_uart_stop(uart_prog_addr);
+	}
+#endif
+
+	if (stm32mp1_clk_probe() < 0) {
+		panic();
+	}
+
+	if (dt_pmic_status() > 0) {
+		initialize_pmic();
+	}
+
+#if DEBUG
+	if (stm32mp_uart_console_setup() != 0) {
+		goto skip_console_init;
+	}
+
+	stm32mp_print_cpuinfo();
+
+	board_model = dt_get_board_model();
+	if (board_model != NULL) {
+		NOTICE("Model: %s\n", board_model);
+	}
+
+	stm32mp_print_boardinfo();
+
+	if ((boot_context->p_ssp_config == NULL) ||
+	    (boot_context->p_ssp_config->ssp_cmd !=
+	     BOOT_API_CTX_SSP_CMD_PROV_SECRET_ACK)) {
+		stm32mp_print_cpuinfo();
+		if (!stm32mp_is_auth_supported()) {
+			ERROR("Chip doesn't support SSP\n");
+			panic();
+		}
+	}
+
+skip_console_init:
+#endif
+	if (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) {
+		/* Closed chip required authentication */
+		ERROR("SSP not supported on closed chip\n");
+		panic();
+	}
+
+	if (stm32_iwdg_init() < 0) {
+		panic();
+	}
+
+	stm32_iwdg_refresh();
+
+	if (dt_pmic_status() > 0) {
+		initialize_pmic_i2c();
+		print_pmic_info_and_debug();
+	}
+
+	ssp_start(boot_context);
+
+	/* This must not be reached */
+	panic();
+}
diff --git a/plat/st/stm32mp1/stm32mp1_ssp.mk b/plat/st/stm32mp1/stm32mp1_ssp.mk
new file mode 100644
index 0000000000..b53d0e379f
--- /dev/null
+++ b/plat/st/stm32mp1/stm32mp1_ssp.mk
@@ -0,0 +1,102 @@
+#
+# Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+ST_VERSION 		:=	r1.0-ssp
+VERSION_STRING		:=	v${VERSION_MAJOR}.${VERSION_MINOR}-${PLAT}-${ST_VERSION}(${BUILD_TYPE}):${BUILD_STRING}
+
+# Required to use BL2_IN_XIP_MEM
+BL2_IN_XIP_MEM		:= 	1
+
+SEPARATE_CODE_AND_RODATA :=	1
+
+TRUSTED_BOARD_BOOT	:=	0
+
+# Macros and rules to build TF-A binary
+STM32_TF_STM32		:=	$(addprefix ${BUILD_PLAT}/tf-a-ssp-, $(patsubst %.dtb,%.stm32,$(DTB_FILE_NAME)))
+
+PLAT_BL_COMMON_SOURCES	:=	common/fdt_wrappers.c					\
+				common/uuid.c						\
+				plat/st/common/stm32mp_common.c				\
+				plat/st/stm32mp1/stm32mp1_private.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/uart/aarch32/stm32_console.S
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/regulator/regulator_core.c			\
+				drivers/st/regulator/regulator_fixed.c
+
+PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
+
+PLAT_BL_COMMON_SOURCES	+=	lib/cpus/aarch32/cortex_a7.S
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/arm/tzc/tzc400.c				\
+				drivers/clk/clk.c					\
+				drivers/delay_timer/delay_timer.c			\
+				drivers/delay_timer/generic_delay_timer.c		\
+				drivers/st/bsec/bsec2.c					\
+				drivers/st/clk/stm32mp_clkfunc.c			\
+				drivers/st/gpio/stm32_gpio.c				\
+				drivers/st/i2c/stm32_i2c.c				\
+				drivers/st/iwdg/stm32_iwdg.c				\
+				drivers/st/pmic/stm32mp_pmic.c				\
+				drivers/st/pmic/stpmic1.c				\
+				drivers/st/reset/stm32mp1_reset.c			\
+				plat/st/common/stm32mp_dt.c				\
+				plat/st/stm32mp1/stm32mp1_dbgmcu.c			\
+				plat/st/stm32mp1/stm32mp1_helper.S			\
+				plat/st/stm32mp1/stm32mp1_syscfg.c
+
+ifeq ($(STM32MP13),1)
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/clk-stm32-core.c				\
+				drivers/st/clk/clk-stm32mp13.c
+endif
+ifeq ($(STM32MP15),1)
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/stm32mp1_clk.c
+endif
+
+BL2_SOURCES		:=	drivers/io/io_storage.c					\
+				plat/st/stm32mp1/stm32mp1_ssp.c
+
+ifeq ($(STM32MP15),1)
+BL2_SOURCES		+=	drivers/st/crypto/stm32_hash.c
+endif
+
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c				\
+				plat/st/common/stm32cubeprogrammer_uart.c
+endif
+
+ifeq (${STM32MP_USB_PROGRAMMER},1)
+#The DFU stack uses only one end point, reduce the USB stack footprint
+$(eval $(call add_define_val,CONFIG_USBD_EP_NB,1U))
+BL2_SOURCES		+=	drivers/st/usb/stm32mp1_usb.c				\
+				drivers/usb/usb_device.c				\
+				plat/st/common/stm32cubeprogrammer_usb.c		\
+				plat/st/common/usb_dfu.c				\
+				plat/st/stm32mp1/stm32mp1_usb_dfu.c
+endif
+
+ifeq ($(STM32MP13),1)
+BL2_DTSI		:=	stm32mp13-ssp-bl2.dtsi
+endif
+ifeq ($(STM32MP15),1)
+BL2_DTSI		:=	stm32mp15-ssp-bl2.dtsi
+endif
+
+check_boot_ssp:
+	@if ([ ${STM32MP_UART_PROGRAMMER} = 1 ] && [ ${STM32MP_USB_PROGRAMMER} = 1 ]) || \
+	([ ${STM32MP_UART_PROGRAMMER} = 0 ] && [ ${STM32MP_USB_PROGRAMMER} = 0 ]); then \
+		echo "Error selecting serial boot device"; \
+		false; \
+	fi
+
+bl2: check_boot_ssp
+
+${BUILD_PLAT}/stm32mp1-ssp-%.o: ${BUILD_PLAT}/fdts/%-bl2.dtb plat/st/stm32mp1/stm32mp1.S bl2
+	@echo "  SSP AS      stm32mp1.S"
+	${Q}${AS} ${ASFLAGS} ${TF_CFLAGS} \
+		-DDTB_BIN_PATH=\"$<\" \
+		-c plat/st/stm32mp1/stm32mp1.S -o $@
diff --git a/plat/st/stm32mp1/stm32mp1_syscfg.c b/plat/st/stm32mp1/stm32mp1_syscfg.c
index ff79428a6a..c5fcfea241 100644
--- a/plat/st/stm32mp1/stm32mp1_syscfg.c
+++ b/plat/st/stm32mp1/stm32mp1_syscfg.c
@@ -235,7 +235,9 @@ static void enable_hslv_by_index(uint32_t index)
 	}
 
 	if (apply_hslv) {
-		mmio_write_32(SYSCFG_BASE + SYSCFG_HSLVEN0R + index * sizeof(uint32_t), HSLV_KEY);
+		uint32_t reg_offset = index * sizeof(uint32_t);
+
+		mmio_write_32(SYSCFG_BASE + SYSCFG_HSLVEN0R + reg_offset, HSLV_KEY);
 	}
 }
 #endif
@@ -259,7 +261,7 @@ static void enable_high_speed_mode_low_voltage(void)
 #endif
 }
 
-static void stm32mp1_syscfg_set_hslv(void)
+static void stm32mp_syscfg_set_hslv(void)
 {
 	uint32_t otp_value;
 	uint32_t vdd_voltage;
@@ -308,7 +310,7 @@ static void stm32mp1_syscfg_set_hslv(void)
 	}
 }
 
-void stm32mp1_syscfg_init(void)
+void stm32mp_syscfg_init(void)
 {
 #if STM32MP15
 	uint32_t bootr;
@@ -326,12 +328,12 @@ void stm32mp1_syscfg_init(void)
 			   bootr << SYSCFG_BOOTR_BOOTPD_SHIFT);
 #endif
 
-	stm32mp1_syscfg_set_hslv();
+	stm32mp_syscfg_set_hslv();
 
-	stm32mp1_syscfg_enable_io_compensation_start();
+	stm32mp_syscfg_enable_io_compensation_start();
 }
 
-void stm32mp1_syscfg_enable_io_compensation_start(void)
+void stm32mp_syscfg_enable_io_compensation_start(void)
 {
 	/*
 	 * Activate automatic I/O compensation.
@@ -351,7 +353,7 @@ void stm32mp1_syscfg_enable_io_compensation_start(void)
 #endif
 }
 
-void stm32mp1_syscfg_enable_io_compensation_finish(void)
+void stm32mp_syscfg_enable_io_compensation_finish(void)
 {
 	enable_io_comp_cell_finish(SYSCFG_CMPCR);
 #if STM32MP13
@@ -360,7 +362,7 @@ void stm32mp1_syscfg_enable_io_compensation_finish(void)
 #endif
 }
 
-void stm32mp1_syscfg_disable_io_compensation(void)
+void stm32mp_syscfg_disable_io_compensation(void)
 {
 	clk_enable(SYSCFG);
 
@@ -383,7 +385,7 @@ void stm32mp1_syscfg_disable_io_compensation(void)
  * @brief  Get silicon revision from SYSCFG registers.
  * @retval chip version (REV_ID).
  */
-uint32_t stm32mp1_syscfg_get_chip_version(void)
+uint32_t stm32mp_syscfg_get_chip_version(void)
 {
 	return (mmio_read_32(SYSCFG_BASE + SYSCFG_IDC) &
 		SYSCFG_IDC_REV_ID_MASK) >> SYSCFG_IDC_REV_ID_SHIFT;
@@ -393,18 +395,18 @@ uint32_t stm32mp1_syscfg_get_chip_version(void)
  * @brief  Get device ID from SYSCFG registers.
  * @retval device ID (DEV_ID).
  */
-uint32_t stm32mp1_syscfg_get_chip_dev_id(void)
+uint32_t stm32mp_syscfg_get_chip_dev_id(void)
 {
 	return mmio_read_32(SYSCFG_BASE + SYSCFG_IDC) & SYSCFG_IDC_DEV_ID_MASK;
 }
 
 #if STM32MP13
-void stm32mp1_syscfg_boot_mode_enable(void)
+void stm32mp_syscfg_boot_mode_enable(void)
 {
 	mmio_setbits_32(SYSCFG_BASE + SYSCFG_BOOTCR, SYSCFG_BOOTCR_BMEN);
 }
 
-void stm32mp1_syscfg_boot_mode_disable(void)
+void stm32mp_syscfg_boot_mode_disable(void)
 {
 	mmio_clrbits_32(SYSCFG_BASE + SYSCFG_BOOTCR, SYSCFG_BOOTCR_BMEN);
 }
diff --git a/plat/st/stm32mp1/stm32mp1_tbb_cert.c b/plat/st/stm32mp1/stm32mp1_tbb_cert.c
index 0e77397c80..69d03bd9bb 100644
--- a/plat/st/stm32mp1/stm32mp1_tbb_cert.c
+++ b/plat/st/stm32mp1/stm32mp1_tbb_cert.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2022, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2023, ARM Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -35,3 +35,12 @@ static cert_t stm32mp1_tbb_certs[] = {
 };
 
 PLAT_REGISTER_COT(stm32mp1_tbb_certs);
+
+static ext_t stm32mp1_tbb_ext[] = {
+	[0] = {
+		.opt = "ddr-fw",
+		.optional = 1
+	}
+};
+
+PLAT_REGISTER_EXTENSIONS(stm32mp1_tbb_ext);
diff --git a/plat/st/stm32mp1/stm32mp1_usb_dfu.c b/plat/st/stm32mp1/stm32mp1_usb_dfu.c
index 0fe2d24ae2..b784dec21b 100644
--- a/plat/st/stm32mp1/stm32mp1_usb_dfu.c
+++ b/plat/st/stm32mp1/stm32mp1_usb_dfu.c
@@ -129,7 +129,11 @@ static const uint8_t usb_stm32mp1_config_desc[USB_DFU_CONFIG_DESC_SIZ] = {
 /* The user strings: one by alternate as defined in USBD_DFU_IF_DESC */
 #if STM32MP13
 const char *const if_desc_string[USB_DFU_ITF_NUM] = {
+#if STM32MP_SSP
+	"@SSP /0xF3/1*512Ba",
+#else
 	"@SSBL /0x03/1*16Me",
+#endif
 	"@virtual /0xF1/1*512Ba"
 };
 #endif
@@ -176,31 +180,15 @@ static void stm32mp1_get_string(const char *desc, uint8_t *unicode, uint16_t *le
  */
 static void update_serial_num_string(void)
 {
-	uint8_t i;
 	char serial_string[SIZ_STRING_SERIAL + 2U];
 	/* serial number is set to 0 */
 	uint32_t deviceserial[UID_WORD_NB] = {0U, 0U, 0U};
-	uint32_t otp;
-	uint32_t len;
 	uint16_t length;
 
-	if (stm32_get_otp_index(UID_OTP, &otp, &len) != 0) {
-		ERROR("BSEC: Get UID_OTP number Error\n");
+	if (stm32_get_uid_otp(deviceserial) != 0) {
 		return;
 	}
 
-	if ((len / __WORD_BIT) != UID_WORD_NB) {
-		ERROR("BSEC: Get UID_OTP length Error\n");
-		return;
-	}
-
-	for (i = 0; i < UID_WORD_NB; i++) {
-		if (bsec_shadow_read_otp(&deviceserial[i], i + otp) !=
-		    BSEC_OK) {
-			ERROR("BSEC: UID%d Error\n", i);
-			return;
-		}
-	}
 	/* build serial number with OTP value as in ROM code */
 	snprintf(serial_string, sizeof(serial_string), "%08X%08X%08X",
 		 deviceserial[0], deviceserial[1], deviceserial[2]);
@@ -400,13 +388,22 @@ uint8_t usb_dfu_get_phase(uint8_t alt)
 	switch (alt) {
 #if STM32MP13
 	case 0:
+#if STM32MP_SSP
+		ret = PHASE_SSP;
+#else
 		ret = PHASE_SSBL;
+#endif
 		break;
 	case 1:
 		ret = PHASE_CMD;
 		break;
 #endif
 #if STM32MP15
+#if STM32MP_SSP
+	case 0:
+		ret =  PHASE_SSP;
+		break;
+#endif
 	case 3:
 		ret = PHASE_SSBL;
 		break;
diff --git a/plat/st/stm32mp2/aarch64/stm32mp2.S b/plat/st/stm32mp2/aarch64/stm32mp2.S
new file mode 100644
index 0000000000..1866b8b579
--- /dev/null
+++ b/plat/st/stm32mp2/aarch64/stm32mp2.S
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+.section .bl2_image
+.incbin BL2_BIN_PATH
+
+.section .dtb_image
+.incbin DTB_BIN_PATH
diff --git a/plat/st/stm32mp2/aarch64/stm32mp2.ld.S b/plat/st/stm32mp2/aarch64/stm32mp2.ld.S
new file mode 100644
index 0000000000..48bf424093
--- /dev/null
+++ b/plat/st/stm32mp2/aarch64/stm32mp2.ld.S
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_LD_S
+#define STM32MP2_LD_S
+
+#include <lib/xlat_tables/xlat_tables_defs.h>
+#include <platform_def.h>
+
+OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
+OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+
+ENTRY(__BL2_IMAGE_START__)
+
+MEMORY {
+	HEADER (rw) : ORIGIN = 0x00000000, LENGTH = STM32MP_HEADER_RESERVED_SIZE
+	RAM (rwx) : ORIGIN = STM32MP_BINARY_BASE, LENGTH = STM32MP_BINARY_SIZE
+}
+
+SECTIONS
+{
+    /*
+     * TF mapping must conform to ROM code specification.
+     */
+    .header : {
+        __HEADER_START__ = .;
+        KEEP(*(.header))
+        . = ALIGN(4);
+        __HEADER_END__ = .;
+    } >HEADER
+
+    . = STM32MP_BINARY_BASE;
+    .data . : {
+        . = ALIGN(PAGE_SIZE);
+        __DATA_START__ = .;
+        *(.data*)
+
+        /*
+         * dtb.
+         * The strongest and only alignment contraint is MMU 4K page.
+         * Indeed as images below will be removed, 4K pages will be re-used.
+         */
+        . = ( STM32MP_BL2_DTB_BASE - STM32MP_BINARY_BASE );
+        __DTB_IMAGE_START__ = .;
+        *(.dtb_image*)
+        __DTB_IMAGE_END__ = .;
+
+        /*
+         * bl2.
+         * The strongest and only alignment contraint is MMU 4K page.
+         * Indeed as images below will be removed, 4K pages will be re-used.
+         */
+#if SEPARATE_CODE_AND_RODATA
+        . = ( STM32MP_BL2_RO_BASE - STM32MP_BINARY_BASE );
+#else
+        . = ( STM32MP_BL2_BASE - STM32MP_BINARY_BASE );
+#endif
+        __BL2_IMAGE_START__ = .;
+        *(.bl2_image*)
+        __BL2_IMAGE_END__ = .;
+
+        __DATA_END__ = .;
+    } >RAM
+
+    __TF_END__ = .;
+
+}
+#endif /* STM32MP2_LD_S */
diff --git a/plat/st/stm32mp2/aarch64/stm32mp2_helper.S b/plat/st/stm32mp2/aarch64/stm32mp2_helper.S
new file mode 100644
index 0000000000..e4a58b0283
--- /dev/null
+++ b/plat/st/stm32mp2/aarch64/stm32mp2_helper.S
@@ -0,0 +1,241 @@
+/*
+ * Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <asm_macros.S>
+#include <drivers/st/stm32_gpio.h>
+
+#define GPIO_TX_SHIFT		(DEBUG_UART_TX_GPIO_PORT << 1)
+
+	.globl	platform_mem_init
+	.globl	plat_secondary_cold_boot_setup
+	.globl	plat_is_my_cpu_primary
+	.globl	plat_my_core_pos
+	.globl	plat_crash_console_init
+	.globl	plat_crash_console_flush
+	.globl	plat_crash_console_putc
+	.globl	plat_report_exception
+	.globl	stm32_stop2_entrypoint
+
+func platform_mem_init
+	/* Nothing to do, don't need to init SYSRAM */
+	ret
+endfunc platform_mem_init
+
+
+	/* ---------------------------------------------
+	 * void plat_secondary_cold_boot_setup (void);
+	 *
+	 * Set secondary core in WFI waiting for core reset.
+	 * ---------------------------------------------
+	 */
+func plat_secondary_cold_boot_setup
+	dsb	sy
+1:
+	wfi
+	/*
+	 * This shouldn't be reached, but when a debugger halts the
+	 * secondary core it causes exit from wfi.
+	 * Put back the core in wfi.
+	 */
+	b	1b
+endfunc plat_secondary_cold_boot_setup
+
+	/* ----------------------------------------------
+	 * unsigned int plat_is_my_cpu_primary(void);
+	 * This function checks if this is the primary CPU
+	 * ----------------------------------------------
+	 */
+func plat_is_my_cpu_primary
+	mrs	x0, mpidr_el1
+	and	x0, x0, #(MPIDR_CPU_MASK)
+	cmp	x0, #STM32MP_PRIMARY_CPU
+	cset	x0, eq
+	ret
+endfunc plat_is_my_cpu_primary
+
+	/* -----------------------------------------------------------
+	 *  unsigned int plat_stm32mp_get_core_pos(u_register_t mpidr)
+	 *  Helper function to calculate the core position.
+	 *  With this function: CorePos = (ClusterId * 4) +
+	 *  				  CoreId
+	 * -----------------------------------------------------------
+	 */
+func plat_stm32mp_get_core_pos
+	and	x1, x0, #MPIDR_CPU_MASK
+	and	x0, x0, #MPIDR_CLUSTER_MASK
+	add	x0, x1, x0, LSR #6
+	ret
+endfunc plat_stm32mp_get_core_pos
+
+	/* -----------------------------------------------------
+	 *  unsigned int plat_my_core_pos(void)
+	 *  This function uses the plat_stm32mp_get_core_pos()
+	 *  definition to get the index of the calling CPU.
+	 * -----------------------------------------------------
+	 */
+func plat_my_core_pos
+	mrs	x0, mpidr_el1
+	b	plat_stm32mp_get_core_pos
+endfunc plat_my_core_pos
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_init(void)
+	 *
+	 * Initialize the crash console without a C Runtime stack.
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_init
+	/* Reset UART peripheral */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_RST_REG)
+	ldr	x2, =DEBUG_UART_RST_BIT
+	ldr	x0, [x1]
+	orr	x0, x0, x2
+	str	x0, [x1]
+1:
+	ldr	x0, [x1]
+	tst	x0, #DEBUG_UART_RST_BIT
+	beq	1b
+	bic	x0, x0, #DEBUG_UART_RST_BIT
+	str	x0, [x1]
+2:
+	ldr	x0, [x1]
+	tst	x0, #DEBUG_UART_RST_BIT
+	bne	2b
+	/* Enable GPIOs for UART TX */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_TX_GPIO_BANK_CLK_REG)
+	ldr	w2, [x1]
+	/* Configure GPIO */
+	orr	w2, w2, #DEBUG_UART_TX_GPIO_BANK_CLK_EN
+	str	w2, [x1]
+	mov_imm	x1, DEBUG_UART_TX_GPIO_BANK_ADDRESS
+	/* Set GPIO mode alternate */
+	ldr	w2, [x1, #GPIO_MODE_OFFSET]
+	bic	w2, w2, #(GPIO_MODE_MASK << GPIO_TX_SHIFT)
+	orr	w2, w2, #(GPIO_MODE_ALTERNATE << GPIO_TX_SHIFT)
+	str	w2, [x1, #GPIO_MODE_OFFSET]
+	/* Set GPIO speed low */
+	ldr	w2, [x1, #GPIO_SPEED_OFFSET]
+	bic	w2, w2, #(GPIO_SPEED_MASK << GPIO_TX_SHIFT)
+	str	w2, [x1, #GPIO_SPEED_OFFSET]
+	/* Set no-pull */
+	ldr	w2, [x1, #GPIO_PUPD_OFFSET]
+	bic	w2, w2, #(GPIO_PULL_MASK << GPIO_TX_SHIFT)
+	str	w2, [x1, #GPIO_PUPD_OFFSET]
+	/* Set alternate */
+#if DEBUG_UART_TX_GPIO_PORT >= GPIO_ALT_LOWER_LIMIT
+	ldr	w2, [x1, #GPIO_AFRH_OFFSET]
+	bic	w2, w2, #(GPIO_ALTERNATE_MASK << \
+				((DEBUG_UART_TX_GPIO_PORT - GPIO_ALT_LOWER_LIMIT) << 2))
+	orr	w2, w2, #(DEBUG_UART_TX_GPIO_ALTERNATE << \
+				((DEBUG_UART_TX_GPIO_PORT - GPIO_ALT_LOWER_LIMIT) << 2))
+	str	w2, [x1, #GPIO_AFRH_OFFSET]
+#else
+	ldr	w2, [x1, #GPIO_AFRL_OFFSET]
+	bic	w2, w2, #(GPIO_ALTERNATE_MASK << (DEBUG_UART_TX_GPIO_PORT << 2))
+	orr	w2, w2, #(DEBUG_UART_TX_GPIO_ALTERNATE << (DEBUG_UART_TX_GPIO_PORT << 2))
+	str	w2, [x1, #GPIO_AFRL_OFFSET]
+#endif
+	/* Clear UART clock flexgen divisors, keep enable bit */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_PREDIV_CFGR)
+	mov	x2, #0
+	str	w2, [x1]
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_FINDIV_CFGR)
+	mov	x2, #0x40
+	str	w2, [x1]
+	/* Enable UART clock, with its source */
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_TX_CLKSRC_REG)
+	mov_imm	w2, (DEBUG_UART_TX_CLKSRC | RCC_XBARxCFGR_XBARxEN)
+	str	w2, [x1]
+	mov_imm	x1, (RCC_BASE + DEBUG_UART_TX_EN_REG)
+	ldr	w2, [x1]
+	orr	w2, w2, #DEBUG_UART_TX_EN
+	str	w2, [x1]
+
+	mov_imm	x0, STM32MP_DEBUG_USART_BASE
+	mov_imm	x1, STM32MP_DEBUG_USART_CLK_FRQ
+	mov_imm	x2, STM32MP_UART_BAUDRATE
+	b	console_stm32_core_init
+endfunc plat_crash_console_init
+
+func plat_crash_console_flush
+	mov_imm	x0, STM32MP_DEBUG_USART_BASE
+	b	console_stm32_core_flush
+endfunc plat_crash_console_flush
+
+func plat_crash_console_putc
+	mov_imm	x1, STM32MP_DEBUG_USART_BASE
+	cmp	x0, #'\n'
+	b.ne	1f
+	mov	x15, x30
+	mov	x0, #'\r'
+	bl	console_stm32_core_putc
+	mov	x30, x15
+	mov	x0, #'\n'
+1:
+	b	console_stm32_core_putc
+endfunc plat_crash_console_putc
+
+#ifdef IMAGE_BL2
+	/* ---------------------------------------------
+	 * void plat_report_exception(unsigned int type)
+	 * Function to report an unhandled exception
+	 * with platform-specific means.
+	 * ---------------------------------------------
+	 */
+func plat_report_exception
+	mov	x8, x30
+
+	adr	x4, plat_err_str
+	bl	asm_print_str
+
+	adr	x4, esr_el3_str
+	bl	asm_print_str
+
+	mrs	x4, esr_el3
+	bl	asm_print_hex
+
+	adr	x4, elr_el3_str
+	bl	asm_print_str
+
+	mrs	x4, elr_el3
+	bl	asm_print_hex
+
+	adr	x4, far_el3_str
+	bl	asm_print_str
+
+	mrs	x4, far_el3
+	bl	asm_print_hex
+
+	mov	x30, x8
+	ret
+endfunc plat_report_exception
+
+.section .rodata.rev_err_str, "aS"
+plat_err_str:
+	.asciz "\nPlatform exception reporting:"
+esr_el3_str:
+	.asciz "\nESR_EL3: "
+elr_el3_str:
+	.asciz "\nELR_EL3: "
+far_el3_str:
+	.asciz "\nFAR_EL3: "
+#endif /* IMAGE_BL2 */
+
+#ifdef IMAGE_BL31
+func stm32_stop2_entrypoint
+	bl	plat_is_my_cpu_primary
+	cbnz	w0, 1f
+0:	wfi
+	b.ne	0b
+1:
+	adrp	x1, stm32_sec_entrypoint
+	add	x1, x1, :lo12:stm32_sec_entrypoint
+	ldr	x0, [x1]
+	br	x0
+endfunc stm32_stop2_entrypoint
+#endif /* IMAGE_BL31 */
diff --git a/plat/st/stm32mp2/bl2_plat_setup.c b/plat/st/stm32mp2/bl2_plat_setup.c
new file mode 100644
index 0000000000..a05d63b5d0
--- /dev/null
+++ b/plat/st/stm32mp2/bl2_plat_setup.c
@@ -0,0 +1,785 @@
+/*
+ * Copyright (c) 2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdint.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <common/desc_image_load.h>
+#include <drivers/clk.h>
+#include <drivers/delay_timer.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/mmc.h>
+#include <drivers/st/bsec.h>
+#include <drivers/st/regulator.h>
+#include <drivers/st/regulator_fixed.h>
+#include <drivers/st/stm32_console.h>
+#include <drivers/st/stm32_hash.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <drivers/st/stm32_rifsc.h>
+#include <drivers/st/stm32_rng.h>
+#include <drivers/st/stm32_saes.h>
+#include <drivers/st/stm32_uart.h>
+#include <drivers/st/stm32mp_pmic2.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stm32mp_rifsc_regs.h>
+#include <drivers/st/stm32mp_risab_regs.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <drivers/st/stm32mp2_ram.h>
+#include <drivers/st/stm32mp2_risaf.h>
+#include <lib/fconf/fconf.h>
+#include <lib/fconf/fconf_dyn_cfg_getter.h>
+#include <lib/mmio.h>
+#include <lib/optee_utils.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp2_context.h>
+
+#define BOOT_CTX_ADDR	0x0e000020UL
+
+IMPORT_SYM(uintptr_t, __BSS_START__, BSS_START);
+IMPORT_SYM(uintptr_t, __BSS_END__, BSS_END);
+IMPORT_SYM(uintptr_t, __DATA_START__, DATA_START);
+IMPORT_SYM(uintptr_t, __DATA_END__, DATA_END);
+
+#define IAC_EXCEPT_LSB_BIT(x) ((x) * 32U)
+#define IAC_EXCEPT_MSB_BIT(x) (IAC_EXCEPT_LSB_BIT(x) + 31U)
+
+static void iac_dump(void)
+{
+#if !STM32MP_M33_TDCID
+#if DEBUG
+	unsigned int i;
+	unsigned int bit;
+
+	for (i = 0U; i < IAC_NB; i++) {
+		uint32_t isr = mmio_read_32(IAC_BASE + IAC_ISR(i));
+		uint32_t ier = mmio_read_32(IAC_BASE + IAC_IER(i));
+
+		isr &= ier;
+		if (isr == 0U) {
+			continue;
+		}
+
+		WARN("IAC exceptions pending [%u:%u] = %x\n",
+		     IAC_EXCEPT_MSB_BIT(i), IAC_EXCEPT_LSB_BIT(i), isr);
+		bit = 0U;
+		while ((isr != 0U) && (bit < 32U)) {
+			if ((isr & BIT(0)) != 0U) {
+				WARN(" - %u\n", IAC_EXCEPT_LSB_BIT(i) + bit);
+			}
+			isr >>= 1U;
+			bit++;
+		}
+	}
+#endif
+#endif
+}
+
+static void print_reset_reason(void)
+{
+	uint32_t rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_C1BOOTRSTSCLRR);
+
+	if (rstsr == 0U) {
+		WARN("Reset reason unknown\n");
+		return;
+	}
+
+	INFO("Reset reason (0x%x):\n", rstsr);
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_PADRSTF) == 0U) {
+		if ((rstsr & RCC_C1BOOTRSTSCLRR_STBYC1RSTF) != 0U) {
+			INFO("System exits from Standby for CA35\n");
+			return;
+		}
+
+		if ((rstsr & RCC_C1BOOTRSTSCLRR_D1STBYRSTF) != 0U) {
+			INFO("D1 domain exits from DStandby\n");
+			return;
+		}
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_PORRSTF) != 0U) {
+		INFO("  Power-on Reset (rst_por)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_BORRSTF) != 0U) {
+		INFO("  Brownout Reset (rst_bor)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSSETR_SYSC2RSTF) != 0U) {
+		INFO("  System reset (SYSRST) by M33\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSSETR_SYSC1RSTF) != 0U) {
+		INFO("  System reset (SYSRST) by A35\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_HCSSRSTF) != 0U) {
+		INFO("  Clock failure on HSE\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG1SYSRSTF) != 0U) {
+		INFO("  IWDG1 system reset (rst_iwdg1)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG2SYSRSTF) != 0U) {
+		INFO("  IWDG2 system reset (rst_iwdg2)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG3SYSRSTF) != 0U) {
+		INFO("  IWDG3 system reset (rst_iwdg3)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG4SYSRSTF) != 0U) {
+		INFO("  IWDG4 system reset (rst_iwdg4)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_IWDG5SYSRSTF) != 0U) {
+		INFO("  IWDG5 system reset (rst_iwdg5)\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_C1P1RSTF) != 0U) {
+		INFO("  A35 processor core 1 reset\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_PADRSTF) != 0U) {
+		INFO("  Pad Reset from NRST\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_VCORERSTF) != 0U) {
+		INFO("  Reset due to a failure of VDD_CORE\n");
+		return;
+	}
+
+	if ((rstsr & RCC_C1BOOTRSTSCLRR_C1RSTF) != 0U) {
+		INFO("  A35 processor reset\n");
+		return;
+	}
+
+	ERROR("  Unidentified reset reason\n");
+}
+
+void bl2_el3_early_platform_setup(u_register_t arg0 __unused,
+				  u_register_t arg1 __unused,
+				  u_register_t arg2 __unused,
+				  u_register_t arg3 __unused)
+{
+	stm32mp_setup_early_console();
+
+	stm32mp_save_boot_ctx_address(BOOT_CTX_ADDR);
+
+	stm32_save_header();
+}
+
+void bl2_platform_setup(void)
+{
+	int ret;
+
+#if !STM32MP_M33_TDCID
+	ret = stm32mp2_ddr_probe();
+	if (ret != 0) {
+		ERROR("DDR probe: error %d\n", ret);
+		panic();
+	}
+
+	if (stm32mp2_risaf_init() < 0) {
+		panic();
+	}
+#endif
+
+	/* Map DDR for binary load, now with cacheable attribute */
+	ret = mmap_add_dynamic_region(STM32MP_DDR_BASE, STM32MP_DDR_BASE,
+				      STM32MP_DDR_MAX_SIZE, MT_MEMORY | MT_RW | MT_SECURE);
+	if (ret < 0) {
+		ERROR("DDR mapping: error %d\n", ret);
+		panic();
+	}
+
+#if !STM32MP_M33_TDCID
+	/* Set QOS ICN priority */
+	stm32mp_syscfg_set_icn_qos();
+#endif
+}
+
+static void handle_potential_tamper(uint32_t bit_off)
+{
+	/* Fixme: Add implementation specific logic here */
+	ERROR("Handling Potential tamper\n");
+	mmio_setbits_32(TAMP_BASE + TAMP_SCR, BIT_32(bit_off));
+}
+
+static void handle_confirmed_tamper(uint32_t bit_off __unused)
+{
+	/* Fixme: Add implementation specific logic here */
+	ERROR("Handling Confirmed tamper\n");
+	panic();
+}
+
+static bool lse_tamper_detection(void)
+{
+	if ((mmio_read_32(TAMP_BASE + TAMP_SR) & TAMP_SR_LSE_MONITORING) != 0U) {
+		mmio_clrbits_32(RCC_BASE + RCC_BDCR, RCC_BDCR_LSECSSON);
+		mmio_clrbits_32(RCC_BASE + RCC_BDCR, RCC_BDCR_LSEON);
+		if (mmio_read_32(RCC_BASE + RCC_C1CIFCLRR) & RCC_C1CIFCLRR_LSECSSF) {
+			mmio_clrbits_32(RCC_BASE + RCC_C1CIFCLRR, RCC_C1CIFCLRR_LSECSSF);
+		}
+
+		return true;
+	}
+
+	return false;
+}
+
+static void reset_backup_domain(void)
+{
+#if !STM32MP_M33_TDCID
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+
+	/*
+	 * Disable the backup domain write protection.
+	 * The protection is enable at each reset by hardware
+	 * and must be disabled by software.
+	 */
+	mmio_setbits_32(pwr_base + PWR_BDCR1, PWR_BDCR1_DBD3P);
+
+	while ((mmio_read_32(pwr_base + PWR_BDCR1) & PWR_BDCR1_DBD3P) == 0U) {
+		;
+	}
+
+	/* Reset backup domain on cold boot cases or when LSE tamper occurred */
+	if ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_RTCCKEN) == 0U) {
+		mmio_setbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+
+		while ((mmio_read_32(rcc_base + RCC_BDCR) & RCC_BDCR_VSWRST) == 0U) {
+			;
+		}
+
+		mmio_clrbits_32(rcc_base + RCC_BDCR, RCC_BDCR_VSWRST);
+	}
+#endif
+}
+
+static void check_tamper_event(bool lse_tamper_occured)
+{
+	uint32_t sr = mmio_read_32(TAMP_BASE + TAMP_SR);
+
+	if (sr == 0U) {
+		return;
+	}
+
+	ERROR("\n");
+	if (lse_tamper_occured) {
+		ERROR("** INTRUSION ALERT: LSE MONITORING TAMPER DETECTED **\n");
+		ERROR("\n");
+
+#if !STM32MP_M33_TDCID
+		/*
+		 * Fixme: Add logic to handle the LSE tamper here (e.g change RTC clock source
+		 * instead). This part is implementation specific.
+		 */
+		mmio_clrbits_32(RCC_BASE + RCC_BDCR, RCC_BDCR_RTCCKEN);
+		ERROR("** Rebooting... **\n");
+		stm32mp_system_reset();
+#endif
+	} else {
+		while (sr != 0U) {
+			unsigned int bit_off = __builtin_ctz(sr);
+			bool is_internal = bit_off >= TAMP_SR_INT_SHIFT;
+			uint32_t cr2 = mmio_read_32(TAMP_BASE + TAMP_CR2);
+			uint32_t cr3 = mmio_read_32(TAMP_BASE + TAMP_CR3);
+
+			ERROR("** INTRUSION ALERT: %s TAMPER %u DETECTED **\n",
+			      is_internal ? "INTERNAL" : "EXTERNAL",
+			      is_internal ? (bit_off - TAMP_SR_INT_SHIFT + 1U) : (bit_off + 1U));
+
+			if ((is_internal && ((cr3 & BIT_32(bit_off >> TAMP_SR_INT_SHIFT)) != 0U)) ||
+			    (!is_internal && ((cr2 & BIT_32(bit_off)) != 0U))) {
+				handle_potential_tamper(bit_off);
+			} else {
+				handle_confirmed_tamper(bit_off);
+			}
+
+			sr &= ~BIT_32(bit_off);
+		}
+		ERROR("\n");
+	}
+}
+
+#if TRUSTED_BOARD_BOOT && DYN_DISABLE_AUTH
+static bool authentication_check(boot_api_context_t *boot_context)
+{
+	if (boot_context->auth_status == BOOT_API_CTX_AUTH_FAILED) {
+		return false;
+	}
+
+	if (stm32mp_check_closed_device() != STM32MP_CHIP_SEC_CLOSED) {
+		void *pk_ptr = NULL;
+		unsigned int len = 0U;
+		unsigned int flags = 0U;
+		int rc;
+
+		rc = plat_get_rotpk_info(NULL, &pk_ptr, &len, &flags);
+		if ((rc == -EINVAL) || ((flags & ROTPK_NOT_DEPLOYED) > 0)) {
+			return false;
+		}
+	}
+
+	return true;
+}
+#endif /* TRUSTED_BOARD_BOOT && DYN_DISABLE_AUTH */
+
+void bl2_el3_plat_arch_setup(void)
+{
+	const char *board_model;
+	boot_api_context_t *boot_context =
+		(boot_api_context_t *)stm32mp_get_boot_ctx_address();
+	bool serial_uart_interface __unused =
+				(boot_context->boot_interface_selected ==
+				 BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART);
+	uintptr_t uart_prog_addr __unused;
+	bool lse_tamper_occured = false;
+
+	if (stm32_otp_probe() != 0) {
+		panic();
+	}
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	configure_mmu();
+
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_dynamic_region(DTB_BASE, DTB_BASE,
+				DTB_LIMIT - DTB_BASE,
+				MT_RO_DATA | MT_SECURE);
+
+	if (dt_open_and_check(STM32MP_DTB_BASE) < 0) {
+		panic();
+	}
+
+	lse_tamper_occured = lse_tamper_detection();
+
+	reset_backup_domain();
+
+#if !STM32MP_M33_TDCID
+	/*
+	 * Initialize DDR sub-system clock. This needs to be done before enabling DDR PLL (PLL2),
+	 * and so before stm32mp2_clk_init().
+	 */
+	ddr_sub_system_clk_init();
+#endif
+
+	if (stm32mp2_clk_init() < 0) {
+		panic();
+	}
+
+	stm32_tamp_nvram_init();
+
+#if STM32MP_UART_PROGRAMMER
+	uart_prog_addr = get_uart_address(boot_context->boot_interface_instance);
+
+	/* Disable programmer UART before changing clock tree */
+	if (serial_uart_interface) {
+		stm32_uart_stop(uart_prog_addr);
+	}
+#endif
+
+	if (stm32_iwdg_init() < 0) {
+		panic();
+	}
+
+	stm32_iwdg_refresh();
+
+	stm32_save_boot_info(boot_context);
+
+	if (stm32mp_uart_console_setup() != 0) {
+		goto skip_console_init;
+	}
+
+	iac_dump();
+
+	/* Masking potential tamper during BL2 */
+	stm32mp_syscfg_mask_potential_tamper_enable();
+
+	stm32mp_print_cpuinfo();
+
+	board_model = dt_get_board_model();
+	if (board_model != NULL) {
+		NOTICE("Model: %s\n", board_model);
+	}
+
+	stm32mp_print_boardinfo();
+
+	print_reset_reason();
+
+#if TRUSTED_BOARD_BOOT && DYN_DISABLE_AUTH
+	if (stm32_hash_register() != 0) {
+		ERROR("HASH register fail\n");
+		panic();
+	}
+
+	if (boot_context->auth_status != BOOT_API_CTX_AUTH_NO) {
+		NOTICE("Bootrom authentication %s\n",
+		       authentication_check(boot_context) ? "succeeded" : "failed");
+	}
+#endif /* TRUSTED_BOARD_BOOT && DYN_DISABLE_AUTH */
+
+skip_console_init:
+	check_tamper_event(lse_tamper_occured);
+
+#if !TRUSTED_BOARD_BOOT
+	if (stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) {
+		/* Closed chip mandates authentication */
+		ERROR("Secure chip: TRUSTED_BOARD_BOOT must be enabled\n");
+		panic();
+	}
+#endif
+
+#if !STM32MP_M33_TDCID
+	if (stm32_rifsc_semaphore_init() != 0) {
+		panic();
+	}
+#endif
+
+	if (stm32_rng_init() != 0) {
+		panic();
+	}
+
+	if (fixed_regulator_register() != 0) {
+		panic();
+	}
+
+	if (dt_pmic_status() > 0) {
+		initialize_pmic();
+	}
+
+	fconf_populate("TB_FW", STM32MP_DTB_BASE);
+
+#if STM32MP_DDR_FIP_IO_STORAGE || TRUSTED_BOARD_BOOT
+#if !STM32MP_M33_TDCID
+	/*
+	 * RISAB3 setup (dedicated for SRAM1)
+	 *
+	 * Allow secure read/writes data accesses to non-secure
+	 * blocks or pages, all RISAB registers are writable.
+	 * DDR firmwares are saved there before being loaded in DDRPHY memory.
+	 */
+	mmio_write_32(RISAB3_BASE + RISAB_CR, RISAB_CR_SRWIAD);
+#endif
+#endif /* STM32MP_DDR_FIP_IO_STORAGE || TRUSTED_BOARD_BOOT */
+#if STM32MP_USB_PROGRAMMER
+	/*
+	 * Set USB3DR Peripheriphal accesses to Secure/Privilege only
+	 */
+	mmio_setbits_32(RIFSC_BASE + _RIFSC_RISC_SECCFGR(STM32MP25_RIFSC_USB3DR_ID),
+			RIFSC_USB3DR_SEC);
+	mmio_setbits_32(RIFSC_BASE + _RIFSC_RISC_PRIVCFGR(STM32MP25_RIFSC_USB3DR_ID),
+			RIFSC_USB3DR_PRIV);
+
+	/*
+	 * Apply USB boot specific configuration to RIF master USB3DR
+	 */
+	mmio_write_32(RIFSC_BASE + _RIFSC_RIMC_ATTR(STM32MP25_RIMU_USB3DR),
+		      RIFSC_USB_BOOT_USBDR_RIMC_CONF);
+#endif /* STM32MP_USB_PROGRAMMER */
+
+#if !STM32MP_M33_TDCID
+	/*
+	 * RISAB5 setup (dedicated for RETRAM)
+	 *
+	 * Allow secure read/writes data accesses to non-secure
+	 * blocks or pages, all RISAB registers are writable.
+	 * DDR retention registers are saved there and restored
+	 * when exiting standby low power state.
+	 */
+	mmio_write_32(RISAB5_BASE + RISAB_CR, RISAB_CR_SRWIAD);
+
+	if (stm32mp2_pwr_init_io_domains() != 0) {
+		panic();
+	}
+#endif
+
+#if STM32MP_DDR_FIP_IO_STORAGE && !STM32MP_UART_PROGRAMMER && !STM32MP_USB_PROGRAMMER
+	/* Skip DDR FW ID = the first image to load for standby exit */
+	if (stm32mp_is_wakeup_from_standby()) {
+		bl_mem_params_node_t *bl_mem_params;
+
+		bl_mem_params = get_bl_mem_params_node(DDR_FW_ID);
+		assert(bl_mem_params != NULL);
+		bl_mem_params->image_info.h.attr |= IMAGE_ATTRIB_SKIP_LOADING;
+	}
+#endif
+
+	stm32mp_io_setup();
+}
+
+#if STM32MP_M33_TDCID
+static inline void prepare_encryption(void) {}
+#else /* !STM32MP_M33_TDCID */
+static int generate_enc_mkey_from_seed(uint8_t *mkey, uint8_t *seed, uint32_t seed_size){
+	int ret;
+	struct stm32_saes_context ctx;
+	uint8_t payload[RISAF_KEY_SIZE_IN_BYTES] = {0U};
+
+	assert(seed_size <= RISAF_KEY_SIZE_IN_BYTES);
+
+	ret = stm32_saes_driver_init();
+	if (ret != 0) {
+		return ret;
+	}
+
+	memcpy(payload, seed, seed_size); /* add seed in a block sized payload */
+
+	ret = stm32_saes_init(&ctx, false, STM32_SAES_MODE_ECB,
+			      STM32_SAES_KEY_DHU, NULL, RISAF_KEY_SIZE_IN_BYTES, NULL, 0U);
+	if (ret != 0) {
+		return ret;
+	}
+
+	return stm32_saes_update(&ctx, true, payload, mkey, sizeof(payload));
+}
+
+static void prepare_encryption(void)
+{
+	uint8_t mkey[RISAF_KEY_SIZE_IN_BYTES];
+	uint8_t seed[RISAF_SEED_SIZE_IN_BYTES];
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	if (stm32_rng_read(seed, RISAF_SEED_SIZE_IN_BYTES) != 0) {
+		panic();
+	}
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+	if (stm32mp_is_wakeup_from_standby()) {
+		stm32mp_pm_get_enc_mkey_seed_from_context(seed);
+	} else {
+		/* Generate RISAF master key from RNG */
+		if (stm32_rng_read(seed, RISAF_SEED_SIZE_IN_BYTES) != 0) {
+			panic();
+		}
+
+		stm32mp_pm_save_enc_mkey_seed_in_context(seed);
+	}
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+
+	if (generate_enc_mkey_from_seed(mkey, seed, RISAF_SEED_SIZE_IN_BYTES) != 0) {
+		panic();
+	}
+
+	if (stm32mp2_risaf_write_master_key(RISAF4_INST, mkey) != 0) {
+		panic();
+	}
+}
+#endif /* STM32MP_M33_TDCID */
+
+/*******************************************************************************
+ * This function can be used by the platforms to update/use image
+ * information for given `image_id`.
+ ******************************************************************************/
+int bl2_plat_handle_post_image_load(unsigned int image_id)
+{
+	int err = 0;
+	bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(image_id);
+	bl_mem_params_node_t *pager_mem_params __unused;
+	const struct dyn_cfg_dtb_info_t *config_info;
+	unsigned int i;
+	unsigned long long ddr_top __unused;
+	const unsigned int image_ids[] = {
+		BL31_IMAGE_ID,
+		SOC_FW_CONFIG_ID,
+		BL32_IMAGE_ID,
+		BL33_IMAGE_ID,
+		HW_CONFIG_ID,
+	};
+	uint32_t otp_idx __maybe_unused;
+	uint32_t otp_len __maybe_unused;
+	bool wakeup_standby;
+
+	assert(bl_mem_params != NULL);
+
+#if STM32MP_SDMMC || STM32MP_EMMC
+	/*
+	 * Invalidate remaining data read from MMC but not flushed by load_image_flush().
+	 * We take the worst case which is 2 MMC blocks.
+	 */
+	if ((image_id != FW_CONFIG_ID) &&
+	    ((bl_mem_params->image_info.h.attr & IMAGE_ATTRIB_SKIP_LOADING) == 0U)) {
+		inv_dcache_range(bl_mem_params->image_info.image_base +
+				 bl_mem_params->image_info.image_size,
+				 2U * MMC_BLOCK_SIZE);
+	}
+#endif /* STM32MP_SDMMC || STM32MP_EMMC */
+
+	switch (image_id) {
+	case FW_CONFIG_ID:
+		if ((stm32mp_check_closed_device() == STM32MP_CHIP_SEC_CLOSED) ||
+		    stm32mp_is_auth_supported()) {
+			prepare_encryption();
+		}
+
+		/* Set global DTB info for fixed fw_config information */
+		set_config_info(STM32MP_FW_CONFIG_BASE, ~0UL, STM32MP_FW_CONFIG_MAX_SIZE,
+				FW_CONFIG_ID);
+		fconf_populate("FW_CONFIG", STM32MP_FW_CONFIG_BASE);
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+		wakeup_standby = false;
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+		wakeup_standby = stm32mp_is_wakeup_from_standby();
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+
+		/* Iterate through all the fw config IDs */
+		for (i = 0U; i < ARRAY_SIZE(image_ids); i++) {
+			bl_mem_params = get_bl_mem_params_node(image_ids[i]);
+			assert(bl_mem_params != NULL);
+
+			config_info = FCONF_GET_PROPERTY(dyn_cfg, dtb, image_ids[i]);
+			if (config_info == NULL) {
+				continue;
+			}
+
+			bl_mem_params->image_info.image_base = config_info->config_addr;
+			bl_mem_params->image_info.image_max_size = config_info->config_max_size;
+
+			/*
+			 * If not going back from STANDBY (preserve the DDR in Self-Refresh)
+			 * or partition not located in DDR
+			 * the partitions must be loaded = remove the SKIP flag
+			 */
+			if (!wakeup_standby || (config_info->config_addr < STM32MP_DDR_BASE)) {
+				bl_mem_params->image_info.h.attr &= ~IMAGE_ATTRIB_SKIP_LOADING;
+			}
+
+			switch (image_ids[i]) {
+			case BL31_IMAGE_ID:
+				bl_mem_params->ep_info.pc = config_info->config_addr;
+				if (bl_mem_params->image_info.image_base == STM32MP_SYSRAM_BASE) {
+					bl_mem_params->image_info.image_max_size =
+						BL2_BASE - STM32MP_SYSRAM_BASE;
+					INFO("BL31 max size = 0x%x (%uB)\n",
+					     bl_mem_params->image_info.image_max_size,
+					     bl_mem_params->image_info.image_max_size);
+				}
+				break;
+			case BL32_IMAGE_ID:
+				bl_mem_params->ep_info.pc = config_info->config_addr;
+
+				/* In case of OPTEE, initialize address space with tos_fw addr */
+				pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+				if (pager_mem_params != NULL) {
+					pager_mem_params->image_info.image_base =
+						config_info->config_addr;
+					pager_mem_params->image_info.image_max_size =
+						config_info->config_max_size;
+				}
+				break;
+
+			case BL33_IMAGE_ID:
+				bl_mem_params->ep_info.pc = config_info->config_addr;
+				break;
+
+			case HW_CONFIG_ID:
+			case SOC_FW_CONFIG_ID:
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+
+#ifndef DECRYPTION_SUPPORT_none
+		/* Load encryption key info before DT is unmapped */
+		err = stm32_get_enc_key_otp_idx_len(&otp_idx, &otp_len);
+		if (err != 0) {
+			panic();
+		}
+#endif
+		mmap_remove_dynamic_region(DTB_BASE, DTB_LIMIT - DTB_BASE);
+		inv_dcache_range(DTB_BASE, DTB_LIMIT - DTB_BASE);
+
+		break;
+
+	case BL32_IMAGE_ID:
+		if (optee_header_is_valid(bl_mem_params->image_info.image_base)) {
+			/* BL32 is OP-TEE header */
+			bl_mem_params->ep_info.pc = bl_mem_params->image_info.image_base;
+			pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+			assert(pager_mem_params != NULL);
+
+			err = parse_optee_header(&bl_mem_params->ep_info,
+						 &pager_mem_params->image_info,
+						 NULL);
+			if (err != 0) {
+				ERROR("OPTEE header parse error.\n");
+				panic();
+			}
+
+			/* Set optee boot info from parsed header data */
+			bl_mem_params->ep_info.args.arg0 = 0U; /* Unused */
+			bl_mem_params->ep_info.args.arg1 = 0U; /* Unused */
+			bl_mem_params->ep_info.args.arg2 = 0U; /* No DT supported */
+		}
+		break;
+
+#if STM32MP_M33_TDCID
+	case BL32_EXTRA1_IMAGE_ID:
+		dsbsy();
+		isb();
+		stm32mp_unmap_ddr();
+		err = mmap_add_dynamic_region(STM32MP_BL33_BASE, STM32MP_BL33_BASE,
+					      STM32MP_DDR_MAX_SIZE - (STM32MP_BL33_BASE -
+								      STM32MP_DDR_BASE),
+					      MT_MEMORY | MT_RW | MT_NS);
+		if (err != 0) {
+			panic();
+		}
+		break;
+#endif
+
+	case BL33_IMAGE_ID:
+#if PSA_FWU_SUPPORT
+		stm32_fwu_set_boot_idx();
+#endif /* PSA_FWU_SUPPORT */
+		break;
+
+	default:
+		/* Do nothing in default case */
+		break;
+	}
+
+	return err;
+}
+
+void bl2_el3_plat_prepare_exit(void)
+{
+	flush_dcache_range(BSS_START, BSS_END - BSS_START);
+	flush_dcache_range(DATA_START, DATA_END - DATA_START);
+
+	stm32mp_io_exit();
+
+	/* Unmask potential tamper before exit */
+	stm32mp_syscfg_mask_potential_tamper_disable();
+}
diff --git a/plat/st/stm32mp2/bl31_plat_setup.c b/plat/st/stm32mp2/bl31_plat_setup.c
new file mode 100644
index 0000000000..4d010e5f74
--- /dev/null
+++ b/plat/st/stm32mp2/bl31_plat_setup.c
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+
+#include <bl31/bl31.h>
+#include <common/bl_common.h>
+#include <common/runtime_svc.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32_console.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32mp2_context.h>
+
+static entry_point_info_t bl32_image_ep_info;
+static entry_point_info_t bl33_image_ep_info;
+
+void bl31_early_platform_setup2(u_register_t arg0, u_register_t arg1,
+				u_register_t arg2, u_register_t arg3)
+{
+	bl_params_t *params_from_bl2;
+	char name[STM32_SOC_NAME_SIZE];
+	int ret;
+
+	stm32mp_setup_early_console();
+
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	/*
+	 * Map soc_fw_config device tree with secure property, i.e. default region.
+	 * DDR region definitions will be finalized at BL32 level.
+	 */
+	mmap_add_region(arg1, arg1, STM32MP_SOC_FW_CONFIG_MAX_SIZE, MT_RO_DATA | MT_SECURE);
+
+#if USE_COHERENT_MEM
+	/* Map coherent memory */
+	mmap_add_region(BL_COHERENT_RAM_BASE, BL_COHERENT_RAM_BASE,
+			BL_COHERENT_RAM_END - BL_COHERENT_RAM_BASE,
+			MT_DEVICE | MT_RW | MT_SECURE);
+#endif
+
+	configure_mmu();
+
+	ret = dt_open_and_check(arg1);
+	if (ret < 0) {
+		EARLY_ERROR("%s: failed to open DT (%d)\n", __func__, ret);
+		panic();
+	}
+
+	ret = stm32mp2_clk_init();
+	if (ret < 0) {
+		EARLY_ERROR("%s: failed init clocks (%d)\n", __func__, ret);
+		panic();
+	}
+
+	stm32_tamp_nvram_init();
+
+	(void)stm32mp_uart_console_setup();
+
+	assert(arg0 != 0UL);
+	params_from_bl2 = (bl_params_t *)arg0;
+	assert(params_from_bl2 != NULL);
+	assert(params_from_bl2->h.type == PARAM_BL_PARAMS);
+	assert(params_from_bl2->h.version >= VERSION_2);
+
+	bl_params_node_t *bl_params = params_from_bl2->head;
+
+	while (bl_params != NULL) {
+		/*
+		 * Copy BL33 entry point information.
+		 * They are stored in Secure RAM, in BL2's address space.
+		 */
+		if (bl_params->image_id == BL33_IMAGE_ID) {
+			bl33_image_ep_info = *bl_params->ep_info;
+			/*
+			 *  Check if hw_configuration is given to BL32 and
+			 *  share it to BL33
+			 */
+			if (arg2 != 0U) {
+				bl33_image_ep_info.args.arg0 = 0U;
+				bl33_image_ep_info.args.arg1 = 0U;
+				bl33_image_ep_info.args.arg2 = arg2;
+			}
+		}
+
+		if (bl_params->image_id == BL32_IMAGE_ID) {
+			bl32_image_ep_info = *bl_params->ep_info;
+
+			if (arg2 != 0U) {
+				bl32_image_ep_info.args.arg3 = arg2;
+			}
+		}
+
+		bl_params = bl_params->next_params_info;
+	}
+
+	/*
+	 * This stm32mp_get_soc_name() call is mandatory here to store SoC part number,
+	 * and avoid using BL31 DT at runtime to check stm32mp_is_single_core().
+	 */
+	stm32mp_get_soc_name(name);
+	VERBOSE("CPU: %s\n", name);
+}
+
+void bl31_plat_arch_setup(void)
+{
+	generic_delay_timer_init();
+
+	stm32mp_gic_init();
+
+#if !STM32MP_UART_PROGRAMMER && !STM32MP_USB_PROGRAMMER
+	if (stm32mp_is_wakeup_from_standby()) {
+		/* Initialize the runtime services e.g. PSCI. */
+		runtime_svc_init();
+
+		stm32_pm_context_restore();
+
+		/* Jump manually to BL31 warm entry point, with MMU disabled. */
+		dsbsy();
+		flush_dcache_range(STM32MP_SYSRAM_BASE, STM32MP_SYSRAM_SIZE);
+		disable_mmu_el3();
+		bl31_warm_entrypoint();
+		panic();
+	}
+#endif /* !STM32MP_UART_PROGRAMMER && !STM32MP_USB_PROGRAMMER */
+}
+
+void bl31_platform_setup(void)
+{
+}
+
+void bl31_plat_runtime_setup(void)
+{
+	/* We reinit the nvram driver Optee should have update the register access configuration
+	 * based on the device tree
+	 */
+	int ret = stm32_tamp_nvram_update_rights();
+
+	if (ret != 0) {
+		ERROR("Failed to update TAMP backup registers rights\n");
+		panic();
+	}
+	console_switch_state(CONSOLE_FLAG_RUNTIME);
+}
+
+entry_point_info_t *bl31_plat_get_next_image_ep_info(unsigned int type)
+{
+	if (type == NON_SECURE)
+		return &bl33_image_ep_info;
+	if (type == SECURE)
+		return &bl32_image_ep_info;
+
+	return NULL;
+}
+
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+static const plat_psci_ops_t null_psci_ops;
+
+/* Stub PSCI platform functions */
+plat_local_state_t plat_get_target_pwr_state(unsigned int lvl,
+					     const plat_local_state_t *states,
+					     unsigned int ncpu)
+{
+	return 0U;
+}
+
+int plat_setup_psci_ops(uintptr_t sec_entrypoint,
+			const plat_psci_ops_t **psci_ops)
+{
+	*psci_ops = &null_psci_ops;
+	return 0;
+}
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
diff --git a/plat/st/stm32mp2/cert_create_tbbr.mk b/plat/st/stm32mp2/cert_create_tbbr.mk
new file mode 100644
index 0000000000..2b94fdd813
--- /dev/null
+++ b/plat/st/stm32mp2/cert_create_tbbr.mk
@@ -0,0 +1,20 @@
+#
+# Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Override TBBR Cert to update generic certificate
+$(eval $(call add_define,PLAT_DEF_OID))
+$(eval $(call add_define,PDEF_CERTS))
+$(eval $(call add_define,PDEF_EXTS))
+
+PLAT_INCLUDE	+= -I${PLAT_DIR}include
+
+src/stm32mp2_tbb_cert.o: ${PLAT_DIR}stm32mp2_tbb_cert.c
+	${Q}${HOSTCC} -c ${HOSTCCFLAGS} ${INC_DIR} $< -o $@
+
+PLAT_OBJECTS	= src/stm32mp2_tbb_cert.o
+
+OBJECTS		+= $(PLAT_OBJECTS)
+
diff --git a/plat/st/stm32mp2/include/boot_api.h b/plat/st/stm32mp2/include/boot_api.h
new file mode 100644
index 0000000000..580a65b590
--- /dev/null
+++ b/plat/st/stm32mp2/include/boot_api.h
@@ -0,0 +1,406 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef BOOT_API_H
+#define BOOT_API_H
+
+#include <stdint.h>
+#include <stdio.h>
+
+/*
+ * Exported constants
+ */
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Possible value of boot context field 'auth_status'
+ */
+/* No authentication done */
+#define BOOT_API_CTX_AUTH_NO					0x0U
+/* Authentication done and failed */
+#define BOOT_API_CTX_AUTH_FAILED				0x1U
+/* Authentication done and succeeded */
+#define BOOT_API_CTX_AUTH_SUCCESS				0x2U
+
+/*
+ * Possible value of boot context field 'boot_interface_sel'
+ */
+
+/* Value of field 'boot_interface_sel' when no boot occurred */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_NO			0x0U
+
+/* Boot occurred on SD */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_SD		0x1U
+
+/* Boot occurred on EMMC */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_EMMC		0x2U
+
+/* Boot occurred on FMC */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_FMC		0x3U
+
+/* Boot occurred on OSPI NOR */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NOR_SPI		0x4U
+
+/* Boot occurred on UART */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_UART		0x5U
+
+/* Boot occurred on USB */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_SERIAL_USB		0x6U
+
+/* Boot occurred on OSPI NAND */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_FLASH_NAND_SPI		0x7U
+
+/* Boot occurred on HyperFlash QSPI  */
+#define BOOT_API_CTX_BOOT_INTERFACE_SEL_HYPERFLASH_OSPI		0x8U
+
+/*
+ * Possible value of boot context field 'emmc_xfer_status'
+ */
+#define BOOT_API_CTX_EMMC_XFER_STATUS_NOT_STARTED			0x0U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_DATAEND_DETECTED			0x1U
+#define BOOT_API_CTX_EMMC_XFER_STATUS_XFER_DATA_TIMEOUT			0x2U
+
+/*
+ * Possible value of boot context field 'emmc_error_status'
+ */
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_NONE                     0x0U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_CMD_TIMEOUT              0x1U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_TIMEOUT              0x2U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_DATA_CRC_FAIL            0x3U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_NOT_ENOUGH_BOOT_DATA_RX  0x4U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_NOT_FOUND         0x5U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_HEADER_SIZE_ZERO         0x6U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_IMAGE_NOT_COMPLETE       0x7U
+#define BOOT_API_CTX_EMMC_ERROR_STATUS_ACK_ERROR		0x8U
+
+/* Definitions relative to 'p_rom_version_info->platform_type_ver' field */
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_IC_EMU_FPGA           0xAA
+#define BOOT_API_CTX_ROM_VERSION_PLAT_VER_FPGA_ONLY             0xBB
+
+/* Image Header related definitions */
+
+/* Definition of header version */
+#define BOOT_API_HEADER_VERSION					0x00020200U
+
+/*
+ * Magic number used to detect header in memory
+ * Its value must be 'S' 'T' 'M' 0x32, i.e 0x324D5453 as field
+ * 'bootapi_image_header_t.magic'
+ * This identifies the start of a boot image.
+ */
+#define BOOT_API_IMAGE_HEADER_MAGIC_NB				0x324D5453U
+
+/* Definitions related to Authentication used in image header structure */
+#define BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES			64
+#define BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES			64
+#define BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES			32
+
+/* Possible values of the field 'boot_api_image_header_t.ecc_algo_type' */
+#define BOOT_API_ECDSA_ALGO_TYPE_P256NIST			1
+#define BOOT_API_ECDSA_ALGO_TYPE_BRAINPOOL256			2
+
+/*
+ * Extension headers related definitions
+ */
+/* 'bootapi_image_header_t.extension_flag' used for authentication feature */
+#define BOOT_API_AUTHENTICATION_EXTENSION_BIT			BIT(0)
+/* 'bootapi_image_header_t.extension_flag' used for FSBL decryption feature */
+#define BOOT_API_FSBL_DECRYPTION_EXTENSION_BIT			BIT(1)
+/* 'bootapi_image_header_t.extension_flag' used for padding header feature */
+#define BOOT_API_PADDING_EXTENSION_BIT				BIT(31)
+/*
+ * mask of bits of field 'bootapi_image_header_t.extension_flag'
+ * used for extension headers
+ */
+#define BOOT_API_ALL_EXTENSIONS_MASK \
+	(BOOT_API_AUTHENTICATION_EXTENSION_BIT | \
+	 BOOT_API_FSBL_DECRYPTION_EXTENSION_BIT | \
+	 BOOT_API_PADDING_EXTENSION_BIT)
+/*
+ * Magic number of FSBL decryption extension header
+ * The value shall gives the four bytes 'S','T',0x00,0x01 in memory
+ */
+#define BOOT_API_FSBL_DECRYPTION_HEADER_MAGIC_NB		0x01005453U
+
+/*
+ * Magic number of PKH revocation extension header
+ * The value shall gives the four bytes 'S','T',0x00,0x02 in memory
+ */
+#define BOOT_API_AUTHENTICATION_HEADER_MAGIC_NB			0x02005453U
+
+/* Max number of ECDSA public key hash in table */
+#define BOOT_API_AUTHENTICATION_NB_PKH_MAX			8U
+
+/* ECDSA public key hash table size in bytes */
+#define BOOT_API_AUTHENTICATION_TABLE_SIZE_BYTES \
+	(BOOT_API_AUTHENTICATION_NB_PKH_MAX * \
+	 BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES)
+
+/*
+ * Magic number of padding extension header
+ * The value shall gives the four bytes 'S','T',0xFF,0xFF in memory
+ */
+#define BOOT_API_PADDING_HEADER_MAGIC_NB			0xFFFF5453U
+
+/*
+ * Related to binaryType
+ * 0x00: U-Boot
+ * 0x10-0x1F: TF-A
+ * 0x20-0X2F: OPTEE
+ * 0x30: CM33 image
+ */
+#define BOOT_API_IMAGE_TYPE_UBOOT				0x0
+#define BOOT_API_IMAGE_TYPE_M33					0x30
+
+/*
+ * Cores secure magic numbers
+ * Constant to be stored in bakcup register
+ * BOOT_API_MAGIC_NUMBER_TAMP_BCK_REG_IDX
+ */
+#define BOOT_API_A35_CORE0_MAGIC_NUMBER				0xCA7FACE0U
+#define BOOT_API_A35_CORE1_MAGIC_NUMBER				0xCA7FACE1U
+
+/*
+ * TAMP_BCK9R register index
+ * This register is used to write a Magic Number in order to restart
+ * Cortex A35 Core 1 and make it execute @ branch address from TAMP_BCK5R
+ */
+#define BOOT_API_CORE1_MAGIC_NUMBER_TAMP_BCK_REG_IDX		9U
+
+/*
+ * TAMP_BCK10R register index
+ * This register is used to contain the branch address of
+ * Cortex A35 Core 1 when restarted by a TAMP_BCK4R magic number writing
+ */
+#define BOOT_API_CORE1_BRANCH_ADDRESS_TAMP_BCK_REG_IDX		10U
+
+/*
+ * Possible value of boot context field 'hse_clock_value_in_hz'
+ */
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_UNDEFINED			0U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_19_2_MHZ			19200000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_24_MHZ			24000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_25_MHZ			25000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_26_MHZ			26000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_40_MHZ			40000000U
+#define BOOT_API_CTX_HSE_CLOCK_VALUE_48_MHZ			48000000U
+
+/*
+ * Possible value of boot context field 'boot_partition_used_toboot'
+ */
+#define BOOT_API_CTX_BOOT_PARTITION_UNDEFINED			0U
+
+/* Used FSBL1 to boot */
+#define BOOT_API_CTX_BOOT_PARTITION_FSBL1			1U
+
+/* Used FSBL2 to boot */
+#define BOOT_API_CTX_BOOT_PARTITION_FSBL2			2U
+
+#define BOOT_API_RETURN_OK					0x66U
+
+/*
+ * Possible values of boot context field
+ * 'ssp_config_ptr_in->ssp_cmd'
+ */
+/* 'K' 'B' 'U' 'P' -.> 'PUBK' */
+#define BOOT_API_CTX_SSP_CMD_CALC_CHIP_PUBK			0x4B425550
+
+/*
+ * Exported types
+ */
+
+/*
+ * bootROM version information structure definition
+ * Total size = 24 bytes = 6 uint32_t
+ */
+typedef struct {
+	/* Chip Version */
+	uint32_t chip_ver;
+
+	/* Cut version within a fixed chip version */
+	uint32_t cut_ver;
+
+	/* Version of ROM Mask within a fixed cut version */
+	uint32_t rom_mask_ver;
+
+	/* Internal Version of bootROM code */
+	uint32_t bootrom_ver;
+
+	/* Version of bootROM adapted */
+	uint32_t for_chip_design_rtl_ver;
+
+	/* Restriction on compiled platform when it applies */
+	uint32_t platform_type_ver;
+} boot_api_rom_version_info_t;
+
+/*
+ * Boot Context related definitions
+ */
+
+/*
+ * Boot core boot configuration structure
+ * Specifies all items of the secure boot configuration
+ * Memory and peripheral part.
+ */
+typedef struct {
+	/* Boot partition: ie FSBL partition on which the boot was successful */
+	uint32_t boot_partition_used_toboot;
+
+	uint32_t	reserved1[3];
+
+	/*
+	 * Information specific to an SD boot
+	 * Updated each time an SD boot is at least attempted,
+	 * even if not successful
+	 * Note : This is useful to understand why an SD boot failed
+	 * in particular
+	 */
+	uint32_t sd_err_internal_timeout_cnt;
+	uint32_t sd_err_dcrc_fail_cnt;
+	uint32_t sd_err_dtimeout_cnt;
+	uint32_t sd_err_ctimeout_cnt;
+	uint32_t sd_err_ccrc_fail_cnt;
+	uint32_t sd_overall_retry_cnt;
+	/*
+	 * Information specific to an eMMC boot
+	 * Updated each time an eMMC boot is at least attempted,
+	 * even if not successful
+	 * Note : This is useful to understand why an eMMC boot failed
+	 * in particular
+	 */
+	uint32_t emmc_xfer_status;
+	uint32_t emmc_error_status;
+	uint32_t emmc_nbbytes_rxcopied_tosysram_download_area;
+
+	uint32_t reserved[4];
+	/*
+	 * Boot interface used to boot : take values from defines
+	 * BOOT_API_CTX_BOOT_INTERFACE_SEL_XXX above
+	 */
+	uint16_t boot_interface_selected;
+	uint16_t boot_interface_instance;
+
+	uint32_t hse_clock_value_in_hz;
+
+	uint32_t nand_fsbl_first_block;
+
+	/*
+	 * Returned authentication status : take values from defines
+	 * BOOT_API_CTX_AUTH_XXX above
+	 */
+	uint32_t auth_status;
+
+	/* Pointer on ROM constant containing ROM information */
+	const boot_api_rom_version_info_t *p_rom_version_info;
+} __packed boot_api_context_t;
+
+/*
+ * Image Header related definitions
+ */
+
+/*
+ * Structure used to define the common Header format used for FSBL, xloader,
+ * ... and in particular used by bootROM for FSBL header readout.
+ * FSBL header size is 256 Bytes = 0x100
+ */
+typedef struct {
+	/* BOOT_API_IMAGE_HEADER_MAGIC_NB */
+	uint32_t magic;
+	uint8_t image_signature[BOOT_API_ECDSA_SIGNATURE_LEN_IN_BYTES];
+	/*
+	 * Checksum of payload
+	 * 32-bit sum all payload bytes considered as 8 bit unsigned
+	 * numbers, discarding any overflow bits.
+	 * Use to check UART/USB downloaded image integrity when signature
+	 * is not used
+	 */
+	uint32_t payload_checksum;
+	/* Image header version : should have value BOOT_API_HEADER_VERSION */
+	uint32_t header_version;
+	/* Image length in bytes */
+	uint32_t image_length;
+	/*
+	 * Image Entry point address : should be in the SYSRAM area
+	 * and at least within the download area range
+	 */
+	uint32_t image_entry_point;
+	/* Reserved */
+	uint32_t reserved1;
+	/*
+	 * Image load address : not used by bootROM but to be consistent
+	 * with header format for other packages (xloader, ...)
+	 */
+	uint32_t load_address;
+	/* Reserved */
+	uint32_t reserved2;
+	/* Image version to be compared by bootROM with FSBL_A or FSBL_M version
+	 * counter value in OTP prior executing the downloaded image
+	 */
+	uint32_t image_version;
+	/*
+	 * Extension flags :
+	 *
+	 * Bit 0 : Authentication extension header
+	 *      value 0 : No signature check request
+	 * Bit 1 : Encryption extension header
+	 * Bit 2 : Padding extension header
+	 */
+	uint32_t extension_flags;
+	/* Length in bytes of all extension headers */
+	uint32_t extension_headers_length;
+	/* Add binary type information */
+	uint32_t binary_type;
+	/* Pad up to 128 byte total size */
+	uint8_t pad[16];
+	/* Followed by extension header */
+	uint8_t ext_header[];
+} __packed boot_api_image_header_t;
+
+typedef uint8_t boot_api_sha256_t[BOOT_API_SHA256_DIGEST_SIZE_IN_BYTES];
+
+typedef struct {
+	/* Extension header type:
+	 * BOOT_API_FSBL_DECRYPTION_HEADER_MAGIC_NB or
+	 * BOOT_API_AUTHENTICATION_HEADER_MAGIC_NB
+	 * BOOT_API_PADDING_HEADER_MAGIC_NB
+	 */
+	uint32_t type;
+	/* Extension header len in byte */
+	uint32_t len;
+	/* parameters of this extension */
+	uint8_t  params[];
+} __packed boot_extension_header_t;
+
+typedef struct {
+	/* Idx of ECDSA public key to be used in table */
+	uint32_t pk_idx;
+	/* Number of ECDSA public key in table */
+	uint32_t nb_pk;
+	/*
+	 * Type of ECC algorithm to use  :
+	 * value 1 : for P-256 NIST algorithm
+	 * value 2 : for Brainpool 256 algorithm
+	 * See definitions 'BOOT_API_ECDSA_ALGO_TYPE_XXX' above.
+	 */
+	uint32_t ecc_algo_type;
+	/* ECDSA public key to be used to check signature. */
+	uint8_t ecc_pubk[BOOT_API_ECDSA_PUB_KEY_LEN_IN_BYTES];
+	/* table of Hash of Algo+ECDSA public key */
+	boot_api_sha256_t pk_hashes[];
+} __packed boot_ext_header_params_authentication_t;
+
+typedef struct {
+	/* Size of encryption key (128 or 256) */
+	uint32_t key_size;
+	uint32_t derivation_cont;
+	/* 128 msb bits of plain payload SHA256 */
+	uint32_t hash[4];
+} __packed boot_ext_header_params_encrypted_fsbl_t;
+
+#endif /* BOOT_API_H */
diff --git a/plat/st/stm32mp2/include/plat_def_fip_uuid.h b/plat/st/stm32mp2/include/plat_def_fip_uuid.h
new file mode 100644
index 0000000000..8f7d2af8ce
--- /dev/null
+++ b/plat/st/stm32mp2/include/plat_def_fip_uuid.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_DEF_FIP_UUID_H
+#define PLAT_DEF_FIP_UUID_H
+
+#define UUID_DDR_FW \
+	{{0xb1, 0x12, 0x49, 0xbe}, {0x92, 0xdd}, {0x4b, 0x10}, 0x86, 0x7c, \
+	 {0x2c, 0x6a, 0x4b, 0x47, 0xa7, 0xfb} }
+
+#define UUID_STM32MP_CONFIG_CERT \
+	{{0x50, 0x1d, 0x8d, 0xd2}, {0x8b, 0xce}, {0x49, 0xa5}, 0x84, 0xeb, \
+	 {0x55, 0x9a, 0x9f, 0x2e, 0xae, 0xaf} }
+#endif /* PLAT_DEF_FIP_UUID_H */
+
diff --git a/plat/st/stm32mp2/include/plat_macros.S b/plat/st/stm32mp2/include/plat_macros.S
new file mode 100644
index 0000000000..e5be2c8218
--- /dev/null
+++ b/plat/st/stm32mp2/include/plat_macros.S
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_MACROS_S
+#define PLAT_MACROS_S
+
+	.macro plat_crash_print_regs
+	.endm
+
+#endif /* PLAT_MACROS_S */
diff --git a/plat/st/stm32mp2/include/plat_tbbr_img_def.h b/plat/st/stm32mp2/include/plat_tbbr_img_def.h
new file mode 100644
index 0000000000..e786dd2b12
--- /dev/null
+++ b/plat/st/stm32mp2/include/plat_tbbr_img_def.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2021-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLAT_TBBR_IMG_DEF_H
+#define PLAT_TBBR_IMG_DEF_H
+
+#include <export/common/tbbr/tbbr_img_def_exp.h>
+
+/* Undef the existing values */
+#undef BKUP_FWU_METADATA_IMAGE_ID
+#undef FWU_METADATA_IMAGE_ID
+#undef FW_CONFIG_ID
+#undef ENC_IMAGE_ID
+#undef GPT_IMAGE_ID
+#undef NT_FW_CONFIG_ID
+#undef SOC_FW_CONFIG_ID
+#undef TB_FW_CONFIG_ID
+#undef HW_CONFIG_ID
+#undef TRUSTED_BOOT_FW_CERT_ID
+#undef SOC_FW_CONTENT_CERT_ID
+#undef BL32_EXTRA1_IMAGE_ID
+#undef TOS_FW_CONFIG_ID
+
+/* Define the STM32MP2 used ID */
+#define FW_CONFIG_ID			U(1)
+#define HW_CONFIG_ID			U(2)
+#define ENC_IMAGE_ID			U(6)
+#define BL32_EXTRA1_IMAGE_ID		U(8)
+#define FWU_METADATA_IMAGE_ID		U(12)
+#define BKUP_FWU_METADATA_IMAGE_ID	U(13)
+#define TOS_FW_CONFIG_ID		U(16)
+#define NT_FW_CONFIG_ID			U(18)
+#define SOC_FW_CONFIG_ID		U(19)
+#define TB_FW_CONFIG_ID			U(20)
+#define TRUSTED_BOOT_FW_CERT_ID		U(21)
+#define SOC_FW_CONTENT_CERT_ID		U(23)
+#define STM32MP_CONFIG_CERT_ID		U(24)
+#define GPT_IMAGE_ID			U(25)
+
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define DDR_FW_ID			U(26)
+/* Increase the MAX_NUMBER_IDS to match the authentication pool required */
+#define MAX_NUMBER_IDS			U(27)
+
+#else
+/* Increase the MAX_NUMBER_IDS to match the authentication pool required */
+#define MAX_NUMBER_IDS			U(26)
+
+#endif
+
+#endif /* PLAT_TBBR_IMG_DEF_H */
+
diff --git a/plat/st/stm32mp2/include/platform_def.h b/plat/st/stm32mp2/include/platform_def.h
new file mode 100644
index 0000000000..fb23155902
--- /dev/null
+++ b/plat/st/stm32mp2/include/platform_def.h
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLATFORM_DEF_H
+#define PLATFORM_DEF_H
+
+#include <arch.h>
+#include <drivers/arm/gic_common.h>
+#include <lib/utils_def.h>
+#include <plat/common/common_def.h>
+
+#include "../stm32mp2_def.h"
+
+/*******************************************************************************
+ * Generic platform constants
+ ******************************************************************************/
+
+/* Size of cacheable stacks */
+#define PLATFORM_STACK_SIZE		0xC00
+
+#define STM32MP_PRIMARY_CPU		U(0x0)
+#define STM32MP_SECONDARY_CPU		U(0x1)
+
+#define MAX_IO_DEVICES			U(4)
+#define MAX_IO_HANDLES			U(4)
+#define MAX_IO_BLOCK_DEVICES		U(1)
+#define MAX_IO_MTD_DEVICES		U(1)
+
+#define PLATFORM_CLUSTER_COUNT		U(1)
+#define PLATFORM_CORE_COUNT		U(2)
+#define PLATFORM_MAX_CPUS_PER_CLUSTER	U(2)
+
+#define PLAT_MAX_PWR_LVL		U(4)
+#define PLAT_MIN_SUSPEND_PWR_LVL	U(2)
+#define PLAT_NUM_PWR_DOMAINS		U(6)
+
+/* Local power state for power domains in Run state. */
+#define STM32MP_LOCAL_STATE_RUN		U(0)
+/* Local power state for retention. */
+#define STM32MP_LOCAL_STATE_RET		U(1)
+#define STM32MP_LOCAL_STATE_LP		U(2)
+#define PLAT_MAX_RET_STATE		STM32MP_LOCAL_STATE_LP
+/* Local power state for OFF/power-down. */
+#define STM32MP_LOCAL_STATE_OFF		U(3)
+#define PLAT_MAX_OFF_STATE		STM32MP_LOCAL_STATE_OFF
+
+/* Macros to parse the state information from State-ID (recommended encoding) */
+#define PLAT_LOCAL_PSTATE_WIDTH		U(4)
+#define PLAT_LOCAL_PSTATE_MASK		GENMASK(PLAT_LOCAL_PSTATE_WIDTH - 1U, 0)
+
+/*******************************************************************************
+ * BL2 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL2 just below BL3-1. BL2_BASE is calculated using the current BL2 debug
+ * size plus a little space for growth.
+ */
+#define BL2_BASE			STM32MP_BL2_BASE
+#define BL2_LIMIT			(STM32MP_BL2_BASE + \
+					 STM32MP_BL2_SIZE)
+
+#define BL2_RO_BASE			STM32MP_BL2_RO_BASE
+#define BL2_RO_LIMIT			(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define BL2_RW_BASE			STM32MP_BL2_RW_BASE
+#define BL2_RW_LIMIT			(STM32MP_BL2_RW_BASE + \
+					 STM32MP_BL2_RW_SIZE)
+
+/*******************************************************************************
+ * BL31 specific defines.
+ ******************************************************************************/
+#define BL31_BASE			0
+#define BL31_LIMIT			STM32MP_BL31_SIZE
+
+/*******************************************************************************
+ * BL33 specific defines.
+ ******************************************************************************/
+#define BL33_BASE			STM32MP_BL33_BASE
+
+/*
+ * Load address of BL33 for this platform port
+ */
+#define PLAT_STM32MP_NS_IMAGE_OFFSET	BL33_BASE
+
+/* Needed by STM32CubeProgrammer support */
+#define DWL_BUFFER_SIZE			U(0x01000000)
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define DWL_DDR_BUFFER_BASE		STM32MP_SYSRAM_BASE
+#define DWL_DDR_BUFFER_SIZE		U(0x0000A000)
+#endif
+
+/*
+ * SSBL offset in case it's stored in eMMC boot partition.
+ * We can fix it to 256K because TF-A size can't be bigger than SRAM
+ */
+#define PLAT_EMMC_BOOT_SSBL_OFFSET		U(0x40000)
+
+/*******************************************************************************
+ * DTB specific defines.
+ ******************************************************************************/
+#define DTB_BASE			STM32MP_DTB_BASE
+#define DTB_LIMIT			(STM32MP_DTB_BASE + \
+					 STM32MP_DTB_SIZE)
+
+/*******************************************************************************
+ * Platform specific page table and MMU setup constants
+ ******************************************************************************/
+#define PLAT_PHY_ADDR_SPACE_SIZE	(ULL(1) << 33)
+#define PLAT_VIRT_ADDR_SPACE_SIZE	(ULL(1) << 33)
+
+/*******************************************************************************
+ * Declarations and constants to access the mailboxes safely. Each mailbox is
+ * aligned on the biggest cache line size in the platform. This is known only
+ * to the platform as it might have a combination of integrated and external
+ * caches. Such alignment ensures that two maiboxes do not sit on the same cache
+ * line at any cache level. They could belong to different cpus/clusters &
+ * get written while being protected by different locks causing corruption of
+ * a valid mailbox address.
+ ******************************************************************************/
+#define CACHE_WRITEBACK_SHIFT		6
+#define CACHE_WRITEBACK_GRANULE		(U(1) << CACHE_WRITEBACK_SHIFT)
+
+/*
+ * Secure Interrupt: based on the standard ARM mapping
+ */
+#define ARM_IRQ_SEC_PHY_TIMER		U(29)
+
+#define ARM_IRQ_NON_SEC_SGI_0		U(0)
+
+#define ARM_IRQ_SEC_SGI_0		U(8)
+#define ARM_IRQ_SEC_SGI_1		U(9)
+#define ARM_IRQ_SEC_SGI_2		U(10)
+#define ARM_IRQ_SEC_SGI_3		U(11)
+#define ARM_IRQ_SEC_SGI_4		U(12)
+#define ARM_IRQ_SEC_SGI_5		U(13)
+#define ARM_IRQ_SEC_SGI_6		U(14)
+#define ARM_IRQ_SEC_SGI_7		U(15)
+
+/* Platform IRQ Priority */
+#define STM32MP_IRQ_SEC_SPI_PRIO	U(0x10)
+
+/*
+ * Define a list of Group 1 Secure and Group 0 interrupts as per GICv3
+ * terminology. On a GICv2 system or mode, the lists will be merged and treated
+ * as Group 0 interrupts.
+ */
+#define PLATFORM_G1S_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_PHY_TIMER,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_LEVEL),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_1,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_2,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_3,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_4,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_5,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_7,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE)
+
+#define PLATFORM_G0_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_0,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE),	\
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_6,		\
+		       GIC_HIGHEST_SEC_PRIORITY,	\
+		       (grp), GIC_INTR_CFG_EDGE)
+
+#endif /* PLATFORM_DEF_H */
diff --git a/plat/st/stm32mp2/include/platform_oid.h b/plat/st/stm32mp2/include/platform_oid.h
new file mode 100644
index 0000000000..da5b305a97
--- /dev/null
+++ b/plat/st/stm32mp2/include/platform_oid.h
@@ -0,0 +1,7 @@
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#define DDR_FW_HASH_OID		"1.3.6.1.4.1.4128.2300.1"
diff --git a/plat/st/stm32mp2/include/stm32mp2_context.h b/plat/st/stm32mp2/include/stm32mp2_context.h
new file mode 100644
index 0000000000..46489ddc1b
--- /dev/null
+++ b/plat/st/stm32mp2/include/stm32mp2_context.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2023, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_CONTEXT_H
+#define STM32MP2_CONTEXT_H
+
+#include <stdint.h>
+
+#include <lib/psci/psci.h>
+
+void stm32mp_pm_save_enc_mkey_seed_in_context(uint8_t *data);
+void stm32mp_pm_get_enc_mkey_seed_from_context(uint8_t *data);
+
+bool stm32_pm_context_is_valid(void);
+void stm32_pm_context_save(const psci_power_state_t *state);
+void stm32_pm_context_restore(void);
+void stm32_pm_context_clear(void);
+
+#endif /* STM32MP2_CONTEXT_H */
diff --git a/plat/st/stm32mp2/include/stm32mp2_private.h b/plat/st/stm32mp2/include/stm32mp2_private.h
new file mode 100644
index 0000000000..455ef4d0fb
--- /dev/null
+++ b/plat/st/stm32mp2/include/stm32mp2_private.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_PRIVATE_H
+#define STM32MP2_PRIVATE_H
+
+void configure_mmu(void);
+
+uint32_t stm32mp_syscfg_get_chip_dev_id(void);
+void stm32mp_syscfg_mask_potential_tamper_enable(void);
+void stm32mp_syscfg_mask_potential_tamper_disable(void);
+size_t stm32mp_syscfg_get_mm_size(uint8_t bank);
+int stm32mp_syscfg_dlyb_init(uint8_t bank, bool bypass_mode,
+			      uint16_t period_ps);
+int stm32mp_syscfg_dlyb_find_tap(uint8_t bank, int (*check_transfer)(void),
+				  bool rx_only, uint8_t *window_len);
+int stm32mp_syscfg_dlyb_set_cr(uint8_t bank, uint32_t dlyb_cr);
+void stm32mp_syscfg_dlyb_get_cr(uint8_t bank, uint32_t *dlyb_cr);
+void stm32mp_syscfg_dlyb_stop(uint8_t bank);
+
+/* IO compensation identifiers */
+enum syscfg_io_ids {
+	SYSFG_VDDIO1_ID,
+	SYSFG_VDDIO2_ID,
+	SYSFG_VDDIO3_ID,
+	SYSFG_VDDIO4_ID,
+	SYSFG_VDD_IO_ID,
+	SYSFG_NB_IO_ID
+};
+
+void stm32mp_syscfg_enable_io_compensation(enum syscfg_io_ids id);
+
+void stm32mp_syscfg_set_icn_qos(void);
+
+int stm32mp2_pwr_init_io_domains(void);
+
+/* Get RISAF platform instance ID from peripheral IO memory base address */
+int stm32_risaf_get_instance(uintptr_t base);
+
+/* Get RISAF peripheral IO memory base address from platform instance ID */
+uintptr_t stm32_risaf_get_base(int instance);
+
+/* Get RISAF maximum number of regions from platform instance ID */
+int stm32_risaf_get_max_region(int instance);
+
+/* Get RISAF memory base address from platform instance ID */
+uintptr_t stm32_risaf_get_memory_base(int instance);
+
+/* Get RISAF memory size in bytes from platform instance ID */
+size_t stm32_risaf_get_memory_size(int instance);
+
+/* Get DDRDBG peripheral IO memory base address */
+uintptr_t stm32_ddrdbg_get_base(void);
+
+/* Wrappers for OTP / BSEC functions */
+#if !STM32MP_M33_TDCID
+static inline uint32_t stm32_otp_probe(void)
+{
+	return bsec_probe();
+}
+
+static inline uint32_t stm32_otp_read(uint32_t *val, uint32_t otp)
+{
+	return bsec_read_otp(val, otp);
+}
+
+static inline uint32_t stm32_otp_shadow_read(uint32_t *val, uint32_t otp)
+{
+	return bsec_shadow_read_otp(val, otp);
+}
+
+static inline uint32_t stm32_otp_write(uint32_t val, uint32_t otp)
+{
+	return bsec_write_otp(val, otp);
+}
+
+static inline uint32_t stm32_otp_set_sr_lock(uint32_t otp)
+{
+	return bsec_set_sr_lock(otp);
+}
+
+static inline uint32_t stm32_otp_read_sw_lock(uint32_t otp, bool *value)
+{
+	return bsec_read_sw_lock(otp, value);
+}
+
+static inline bool stm32_otp_is_closed_device(void)
+{
+	return bsec_mode_is_closed_device();
+}
+#else /* STM32MP_M33_TDCID */
+uint32_t stm32_otp_probe(void);
+uint32_t stm32_otp_read(uint32_t *val, uint32_t otp);
+uint32_t stm32_otp_shadow_read(uint32_t *val, uint32_t otp);
+uint32_t stm32_otp_write(uint32_t val, uint32_t otp);
+uint32_t stm32_otp_set_sr_lock(uint32_t otp);
+uint32_t stm32_otp_read_sw_lock(uint32_t otp, bool *value);
+bool stm32_otp_is_closed_device(void);
+#endif /* STM32MP_M33_TDCID */
+
+#endif /* STM32MP2_PRIVATE_H */
diff --git a/plat/st/stm32mp2/include/stm32mp2_smc.h b/plat/st/stm32mp2/include/stm32mp2_smc.h
new file mode 100644
index 0000000000..56f0304fa8
--- /dev/null
+++ b/plat/st/stm32mp2/include/stm32mp2_smc.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_SMC_H
+#define STM32MP2_SMC_H
+
+#define STM32_COMMON_SIP_NUM_CALLS			1U
+
+/*
+ * STM32_SIP_SMC_STGEN_SET_RATE call API
+ * This service is opened to secure world only.
+ *
+ * Argument a0: (input) SMCC ID
+ *		(output) status return code
+ * Argument a1: (input) Frequency to set (given by sender)
+ */
+#define STM32_SIP_SMC_STGEN_SET_RATE                    0x82000000
+
+#endif /* STM32MP2_SMC_H */
diff --git a/plat/st/stm32mp2/include/tbbr/stm32mp2_tbb_cert.h b/plat/st/stm32mp2/include/tbbr/stm32mp2_tbb_cert.h
new file mode 100644
index 0000000000..25efafc268
--- /dev/null
+++ b/plat/st/stm32mp2/include/tbbr/stm32mp2_tbb_cert.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_TBB_CERT_H
+#define STM32MP2_TBB_CERT_H
+
+#include <tbbr/tbb_cert.h>
+#include <tbbr/tbb_ext.h>
+
+/*
+ * Enumerate the certificates that are used to establish the chain of trust
+ */
+enum {
+	STM32MP_CONFIG_CERT = FWU_CERT + 1
+};
+
+/* Plat Defined TBBR extensions */
+enum {
+	DDR_FW_HASH_EXT = FWU_HASH_EXT + 1,
+};
+
+#endif /* STM32MP2_TBB_CERT_H */
diff --git a/plat/st/stm32mp2/plat_bl2_mem_params_desc.c b/plat/st/stm32mp2/plat_bl2_mem_params_desc.c
new file mode 100644
index 0000000000..528c0d1d6a
--- /dev/null
+++ b/plat/st/stm32mp2/plat_bl2_mem_params_desc.c
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/bl_common.h>
+#include <common/desc_image_load.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+
+/*******************************************************************************
+ * Following descriptor provides BL image/ep information that gets used
+ * by BL2 to load the images and also subset of this information is
+ * passed to next BL image. The image loading sequence is managed by
+ * populating the images in required loading order. The image execution
+ * sequence is managed by populating the `next_handoff_image_id` with
+ * the next executable image id.
+ ******************************************************************************/
+static bl_mem_params_node_t bl2_mem_params_descs[] = {
+#if STM32MP_DDR_FIP_IO_STORAGE
+	/* Fill FW_DDR related information if it exists */
+	{
+		.image_id = DDR_FW_ID,
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t,
+				      0),
+
+		.image_info.image_base = STM32MP_DDR_FW_BASE,
+		.image_info.image_max_size = STM32MP_DDR_FW_MAX_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+#endif
+
+	/* Fill FW_CONFIG related information if it exists */
+	{
+		.image_id = FW_CONFIG_ID,
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_PLAT_SETUP),
+
+		.image_info.image_base = STM32MP_FW_CONFIG_BASE,
+		.image_info.image_max_size = STM32MP_FW_CONFIG_MAX_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+
+	/* Fill BL31 related information */
+	{
+		.image_id = BL31_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | EXECUTABLE | EP_FIRST_EXE),
+
+		.ep_info.spsr = SPSR_64(MODE_EL3, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = BL32_IMAGE_ID,
+	},
+
+	/* Fill SoC FW config related information */
+	{
+		.image_id = SOC_FW_CONFIG_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+
+	/* Fill BL32 related information */
+	{
+		.image_id = BL32_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = BL33_IMAGE_ID,
+	},
+
+	/* Fill BL32 external 1 image related information */
+	{
+		.image_id = BL32_EXTRA1_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+
+	/* Fill HW_CONFIG related information if it exists */
+	{
+		.image_id = HW_CONFIG_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      NON_SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+
+	/* Fill BL33 related information */
+	{
+		.image_id = BL33_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+				      VERSION_2, entry_point_info_t,
+				      NON_SECURE | EXECUTABLE),
+
+		.ep_info.spsr = SPSR_64(MODE_EL1, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+				      VERSION_2, image_info_t,
+				      IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	}
+};
+
+REGISTER_BL_IMAGE_DESCS(bl2_mem_params_descs)
diff --git a/plat/st/stm32mp2/plat_ddr.c b/plat/st/stm32mp2/plat_ddr.c
new file mode 100644
index 0000000000..2691ea00b0
--- /dev/null
+++ b/plat/st/stm32mp2/plat_ddr.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2023-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <libfdt.h>
+#include <stdint.h>
+
+#include <common/fdt_wrappers.h>
+#include <drivers/delay_timer.h>
+#include <drivers/st/regulator.h>
+#include <drivers/st/stm32mp_ddr.h>
+
+#include <platform_def.h>
+
+#if STM32MP_DDR3_TYPE
+struct ddr3_supply {
+	struct rdev *vdd;
+	struct rdev *vref;
+	struct rdev *vtt;
+};
+
+static void ddr3_supply_read(void *fdt, int node, struct ddr3_supply *supply)
+{
+	supply->vdd = regulator_get_by_supply_name(fdt, node, "vdd");
+	supply->vref = regulator_get_by_supply_name(fdt, node, "vref");
+	supply->vtt = regulator_get_by_supply_name(fdt, node, "vtt");
+}
+
+static int ddr_power_init(void *fdt, int node)
+{
+	int status;
+	struct ddr3_supply supply;
+
+	ddr3_supply_read(fdt, node, &supply);
+	if ((supply.vdd == NULL) || (supply.vref == NULL) || (supply.vtt == NULL)) {
+		return -ENOENT;
+	}
+
+	/*
+	 * DDR3 power on sequence is:
+	 * enable VREF_DDR, VTT_DDR, VPP_DDR
+	 */
+	status = regulator_set_min_voltage(supply.vdd);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vdd);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vref);
+	if (status != 0) {
+		return status;
+	}
+
+	return regulator_enable(supply.vtt);
+}
+#endif /* STM32MP_DDR3_TYPE */
+
+#if STM32MP_DDR4_TYPE
+struct ddr4_supply {
+	struct rdev *vdd;
+	struct rdev *vref;
+	struct rdev *vtt;
+	struct rdev *vpp;
+};
+
+static void ddr4_supply_read(void *fdt, int node, struct ddr4_supply *supply)
+{
+	supply->vpp = regulator_get_by_supply_name(fdt, node, "vpp");
+	supply->vdd = regulator_get_by_supply_name(fdt, node, "vdd");
+	supply->vref = regulator_get_by_supply_name(fdt, node, "vref");
+	supply->vtt = regulator_get_by_supply_name(fdt, node, "vtt");
+}
+
+static int ddr_power_init(void *fdt, int node)
+{
+	int status;
+	struct ddr4_supply supply;
+
+	ddr4_supply_read(fdt, node, &supply);
+	if ((supply.vpp == NULL) || (supply.vdd == NULL) || (supply.vref == NULL) ||
+	    (supply.vtt == NULL)) {
+		return -ENOENT;
+	}
+
+	/*
+	 * DDR4 power on sequence is:
+	 * enable VPP_DDR
+	 * enable VREF_DDR, VTT_DDR, VPP_DDR
+	 */
+	status = regulator_set_min_voltage(supply.vpp);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_set_min_voltage(supply.vdd);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vpp);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vdd);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vref);
+	if (status != 0) {
+		return status;
+	}
+
+	return regulator_enable(supply.vtt);
+}
+#endif /* STM32MP_DDR4_TYPE */
+
+#if STM32MP_LPDDR4_TYPE
+struct lpddr4_supply {
+	struct rdev *vdd1;
+	struct rdev *vdd2;
+	struct rdev *vddq;
+};
+
+static void lpddr4_supply_read(void *fdt, int node, struct lpddr4_supply *supply)
+{
+	supply->vdd1 = regulator_get_by_supply_name(fdt, node, "vdd1");
+	supply->vdd2 = regulator_get_by_supply_name(fdt, node, "vdd2");
+	supply->vddq = regulator_get_by_supply_name(fdt, node, "vddq");
+}
+
+static int ddr_power_init(void *fdt, int node)
+{
+	int status;
+	struct lpddr4_supply supply;
+
+	lpddr4_supply_read(fdt, node, &supply);
+	if ((supply.vdd1 == NULL) || (supply.vdd2 == NULL) || (supply.vddq == NULL)) {
+		return -ENOENT;
+	}
+
+	/*
+	 * LPDDR4 power on sequence is:
+	 * enable VDD1_DDR
+	 * enable VDD2_DDR
+	 * enable VDDQ_DDR
+	 */
+	status = regulator_set_min_voltage(supply.vdd1);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_set_min_voltage(supply.vdd2);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_set_min_voltage(supply.vddq);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vdd1);
+	if (status != 0) {
+		return status;
+	}
+
+	status = regulator_enable(supply.vdd2);
+	if (status != 0) {
+		return status;
+	}
+
+	return regulator_enable(supply.vddq);
+}
+#endif /* STM32MP_LPDDR4_TYPE */
+
+int stm32mp_board_ddr_power_init(enum ddr_type ddr_type)
+{
+	void *fdt = NULL;
+	int node;
+
+	VERBOSE("DDR power init, ddr_type = %u\n", ddr_type);
+
+#if STM32MP_DDR3_TYPE
+	assert(ddr_type == STM32MP_DDR3);
+#elif STM32MP_DDR4_TYPE
+	assert(ddr_type == STM32MP_DDR4);
+#elif STM32MP_LPDDR4_TYPE
+	assert(ddr_type == STM32MP_LPDDR4);
+#else
+	ERROR("DDR type (%u) not supported\n", ddr_type);
+	panic();
+#endif
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_DDR_COMPAT);
+	if (node < 0) {
+		ERROR("%s: Cannot read DDR node in DT\n", __func__);
+		return -EINVAL;
+	}
+
+	return ddr_power_init(fdt, node);
+}
diff --git a/plat/st/stm32mp1/plat_def_uuid_config.c b/plat/st/stm32mp2/plat_def_uuid_config.c
similarity index 54%
rename from plat/st/stm32mp1/plat_def_uuid_config.c
rename to plat/st/stm32mp2/plat_def_uuid_config.c
index efaf567014..ff786e0cd4 100644
--- a/plat/st/stm32mp1/plat_def_uuid_config.c
+++ b/plat/st/stm32mp2/plat_def_uuid_config.c
@@ -1,18 +1,30 @@
 /*
- * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
+#include <stddef.h>
+
 #include <firmware_image_package.h>
 
 #include "tbbr_config.h"
 
 toc_entry_t plat_def_toc_entries[] = {
+	{
+		.name = "DDR_FW",
+		.uuid = UUID_DDR_FW,
+		.cmdline_name = "ddr-fw"
+	},
 	{
 		.name = "STM32MP CONFIG CERT",
 		.uuid = UUID_STM32MP_CONFIG_CERT,
 		.cmdline_name = "stm32mp-cfg-cert"
+	},
+
+	{
+		.name = NULL,
+		.uuid = { {0} },
+		.cmdline_name = NULL,
 	}
 };
-
diff --git a/plat/st/stm32mp1/plat_fiptool.mk b/plat/st/stm32mp2/plat_fiptool.mk
similarity index 89%
rename from plat/st/stm32mp1/plat_fiptool.mk
rename to plat/st/stm32mp2/plat_fiptool.mk
index 00570c2b3f..93d50c8589 100644
--- a/plat/st/stm32mp1/plat_fiptool.mk
+++ b/plat/st/stm32mp2/plat_fiptool.mk
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2021-2022, STMicroelectronics - All Rights Reserved
+# Copyright (c) 2023, STMicroelectronics - All Rights Reserved
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
diff --git a/plat/st/stm32mp2/plat_image_load.c b/plat/st/stm32mp2/plat_image_load.c
new file mode 100644
index 0000000000..f92f1233c3
--- /dev/null
+++ b/plat/st/stm32mp2/plat_image_load.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/bl_common.h>
+#include <common/desc_image_load.h>
+#include <plat/common/platform.h>
+
+/*******************************************************************************
+ * This function flushes the data structures so that they are visible
+ * in memory for the next BL image.
+ ******************************************************************************/
+void plat_flush_next_bl_params(void)
+{
+	flush_bl_params_desc();
+}
+
+/*******************************************************************************
+ * This function returns the list of loadable images.
+ ******************************************************************************/
+bl_load_info_t *plat_get_bl_image_load_info(void)
+{
+	return get_bl_load_info_from_mem_params_desc();
+}
+
+/*******************************************************************************
+ * This function returns the list of executable images.
+ ******************************************************************************/
+bl_params_t *plat_get_next_bl_params(void)
+{
+	bl_params_t *bl_params = get_next_bl_params_from_mem_params_desc();
+
+	populate_next_bl_params_config(bl_params);
+
+	return bl_params;
+}
diff --git a/plat/st/stm32mp2/platform.mk b/plat/st/stm32mp2/platform.mk
new file mode 100644
index 0000000000..16ec7f498e
--- /dev/null
+++ b/plat/st/stm32mp2/platform.mk
@@ -0,0 +1,391 @@
+#
+# Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Extra partitions used to find FIP, contains:
+# metadata (2) and fsbl-m (2) and the FIP partitions (default is 2).
+STM32_EXTRA_PARTS	:=	6
+
+include plat/st/common/common.mk
+
+CRASH_REPORTING		:=	1
+ENABLE_PIE		:=	1
+PROGRAMMABLE_RESET_ADDRESS := 1
+BL2_IN_XIP_MEM		:=	1
+
+# Do not enable SPE (not supported on Arm v8.0).
+ENABLE_SPE_FOR_LOWER_ELS :=	0
+
+# Do not enable SVE (not supported on Arm v8.0).
+ENABLE_SVE_FOR_NS	:=	0
+
+# Enable PSCI v1.0 extended state ID format
+PSCI_EXTENDED_STATE_ID	:= 1
+PSCI_OS_INIT_MODE	:= 1
+
+# Reduce the number of interruption in GIC context
+GICV2_INTR_NUM		:=	416
+
+# Default Device tree
+DTB_FILE_NAME		?=	stm32mp257f-ev1.dtb
+
+STM32MP25		:=	1
+STM32MP_M33_TDCID	?=	0
+
+STM32MP_USE_EXTERNAL_HEAP :=	1
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+# PKA algo to include
+PKA_USE_NIST_P256	:=	1
+PKA_USE_BRAINPOOL_P256T1:=	1
+endif
+
+# STM32 image header version v2.2
+STM32_HEADER_VERSION_MAJOR:=	2
+STM32_HEADER_VERSION_MINOR:=	2
+
+PKA_USE_NIST_P256	?=	0
+PKA_USE_BRAINPOOL_P256T1 ?=	0
+
+STM32_HASH_VER		:=	4
+STM32_RNG_VER		:=	4
+
+# Download load address for serial boot devices
+DWL_BUFFER_BASE 	?=	0x87000000
+
+# DDR types
+STM32MP_DDR3_TYPE	?=	0
+STM32MP_DDR4_TYPE	?=	0
+STM32MP_LPDDR4_TYPE	?=	0
+ifeq ($(STM32MP_M33_TDCID),0)
+ifeq (${STM32MP_DDR3_TYPE},1)
+DDR_TYPE		:=	ddr3
+endif
+ifeq (${STM32MP_DDR4_TYPE},1)
+DDR_TYPE		:=	ddr4
+endif
+ifeq (${STM32MP_LPDDR4_TYPE},1)
+DDR_TYPE		:=	lpddr4
+endif
+
+# DDR features
+STM32MP_DDR_DUAL_AXI_PORT	:=	1
+STM32MP_DDR_FIP_IO_STORAGE	:=	1
+else #STM32MP_M33_TDCID
+STM32MP_DDR_DUAL_AXI_PORT	:=	0
+STM32MP_DDR_FIP_IO_STORAGE	:=	0
+endif #STM32MP_M33_TDCID
+
+# Device tree
+BL2_DTSI		:=	stm32mp25-bl2.dtsi
+FDT_SOURCES		:=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl2.dts,$(DTB_FILE_NAME)))
+BL31_DTSI		:=	stm32mp25-bl31.dtsi
+FDT_SOURCES		+=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl31.dts,$(DTB_FILE_NAME)))
+
+ifneq (,$(wildcard fdts/$(patsubst %.dtb,%.dts,$(DTB_FILE_NAME))))
+DT_SOURCE_PATH		:=	fdts
+else
+ifneq (,$(wildcard $(TFA_EXTERNAL_DT)/$(patsubst %.dtb,%.dts,$(DTB_FILE_NAME))))
+DT_SOURCE_PATH		:=	$(TFA_EXTERNAL_DT)
+else
+$(error Cannot find $(patsubst %.dtb,%.dts,$(DTB_FILE_NAME)) file)
+endif
+endif
+
+# Macros and rules to build TF binary
+STM32_TF_STM32		:=	$(addprefix ${BUILD_PLAT}/tf-a-, $(patsubst %.dtb,%.stm32,$(DTB_FILE_NAME)))
+STM32_LD_FILE		:=	plat/st/stm32mp2/${ARCH}/stm32mp2.ld.S
+STM32_BINARY_MAPPING	:=	plat/st/stm32mp2/${ARCH}/stm32mp2.S
+
+STM32MP_FW_CONFIG_NAME	:=	$(patsubst %.dtb,%-fw-config.dtb,$(DTB_FILE_NAME))
+STM32MP_FW_CONFIG	:=	${BUILD_PLAT}/fdts/$(STM32MP_FW_CONFIG_NAME)
+STM32MP_SOC_FW_CONFIG	:=	$(addprefix ${BUILD_PLAT}/fdts/, $(patsubst %.dtb,%-bl31.dtb,$(DTB_FILE_NAME)))
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+STM32MP_DDR_FW_PATH	?=	drivers/st/ddr/phy/firmware/bin/stm32mp2
+STM32MP_DDR_FW_NAME	:=	${DDR_TYPE}_pmu_train.bin
+STM32MP_DDR_FW		:=	${STM32MP_DDR_FW_PATH}/${STM32MP_DDR_FW_NAME}
+endif
+FDT_SOURCES		+=	$(addprefix $(DT_SOURCE_PATH)/, $(patsubst %.dtb,%.dts,$(STM32MP_FW_CONFIG_NAME)))
+# Add the FW_CONFIG to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_FW_CONFIG},--fw-config))
+# Add the SOC_FW_CONFIG to FIP and specify the same to certtool
+ifeq ($(ENCRYPT_BL31),1)
+$(eval $(call TOOL_ADD_IMG,STM32MP_SOC_FW_CONFIG,--soc-fw-config,,$(ENCRYPT_BL31)))
+else
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_SOC_FW_CONFIG},--soc-fw-config))
+endif
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+# Add the FW_DDR to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_IMG,STM32MP_DDR_FW,--ddr-fw))
+endif
+ifeq ($(GENERATE_COT),1)
+STM32MP_CFG_CERT	:=	$(BUILD_PLAT)/stm32mp_cfg_cert.crt
+# Add the STM32MP_CFG_CERT to FIP and specify the same to certtool
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_CFG_CERT},--stm32mp-cfg-cert))
+endif
+
+# Enable flags for C files
+$(eval $(call assert_booleans,\
+	$(sort \
+		PKA_USE_BRAINPOOL_P256T1 \
+		PKA_USE_NIST_P256 \
+		STM32MP_CRYPTO_ROM_LIB \
+		STM32MP_DDR_DUAL_AXI_PORT \
+		STM32MP_DDR_FIP_IO_STORAGE \
+		STM32MP_DDR3_TYPE \
+		STM32MP_DDR4_TYPE \
+		STM32MP_LPDDR4_TYPE \
+		STM32MP_M33_TDCID \
+		STM32MP_USE_EXTERNAL_HEAP \
+		STM32MP25 \
+)))
+
+$(eval $(call assert_numerics,\
+	$(sort \
+		PLAT_PARTITION_MAX_ENTRIES \
+		STM32_HASH_VER \
+		STM32_RNG_VER \
+		STM32_TF_A_COPIES \
+)))
+
+$(eval $(call add_defines,\
+	$(sort \
+		DWL_BUFFER_BASE \
+		PKA_USE_BRAINPOOL_P256T1 \
+		PKA_USE_NIST_P256 \
+		PLAT_DEF_FIP_UUID \
+		PLAT_PARTITION_MAX_ENTRIES \
+		PLAT_TBBR_IMG_DEF \
+		STM32_HASH_VER \
+		STM32_RNG_VER \
+		STM32_TF_A_COPIES \
+		STM32MP_CRYPTO_ROM_LIB \
+		STM32MP_DDR_DUAL_AXI_PORT \
+		STM32MP_DDR_FIP_IO_STORAGE \
+		STM32MP_DDR3_TYPE \
+		STM32MP_DDR4_TYPE \
+		STM32MP_LPDDR4_TYPE \
+		STM32MP_M33_TDCID \
+		STM32MP_USE_EXTERNAL_HEAP \
+		STM32MP25 \
+)))
+
+# STM32MP2x is based on Cortex-A35, which is Armv8.0, and does not support BTI
+# Disable mbranch-protection to avoid adding useless code
+TF_CFLAGS		+=	-mbranch-protection=none
+
+# Include paths and source files
+PLAT_INCLUDES		+=	-Iplat/st/stm32mp2/include/
+PLAT_INCLUDES		+=	-Idrivers/st/ddr/phy/phyinit/include/
+PLAT_INCLUDES		+=	-Idrivers/st/ddr/phy/firmware/include/
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/pmic/stm32mp_pmic2.c				\
+				drivers/st/pmic/stpmic2.c				\
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/i2c/stm32_i2c.c
+
+PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp2/stm32mp2_private.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/uart/${ARCH}/stm32_console.S
+
+PLAT_BL_COMMON_SOURCES	+=	lib/cpus/${ARCH}/cortex_a35.S
+
+ifeq ($(STM32MP_M33_TDCID),0)
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/bsec/bsec3.c
+else
+PLAT_BL_COMMON_SOURCES	+=	plat/st/stm32mp2/stm32mp2_otp.c
+endif
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/iwdg/stm32_iwdg.c				\
+				drivers/st/reset/stm32mp2_reset.c			\
+				plat/st/stm32mp2/${ARCH}/stm32mp2_helper.S		\
+				plat/st/stm32mp2/stm32mp2_syscfg.c			\
+				plat/st/stm32mp2/stm32mp2_pwr.c
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/st/clk/clk-stm32-core.c				\
+				drivers/st/clk/clk-stm32mp2.c				\
+				drivers/st/crypto/stm32_rng.c				\
+				drivers/st/crypto/stm32_saes.c
+
+PLAT_BL_COMMON_SOURCES  +=	drivers/st/nvmem/stm32mp_tamp_nvram_mp2.c
+
+ifeq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
+PLAT_BL_COMMON_SOURCES  +=	plat/st/stm32mp2/stm32mp2_context.c
+endif
+
+BL2_SOURCES		+=	plat/st/stm32mp2/plat_bl2_mem_params_desc.c
+
+BL2_SOURCES		+=	drivers/st/crypto/stm32_hash.c				\
+				plat/st/stm32mp2/bl2_plat_setup.c			\
+				plat/st/stm32mp2/plat_ddr.c
+
+BL2_SOURCES		+=	drivers/st/rif/stm32_rifsc.c
+
+ifeq ($(STM32MP_M33_TDCID),0)
+BL2_SOURCES		+=	drivers/st/rif/stm32mp2_risaf.c
+endif
+
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+BL2_SOURCES		+=	drivers/st/crypto/stm32_pka.c
+endif
+
+ifneq ($(filter 1,${STM32MP_EMMC} ${STM32MP_SDMMC}),)
+BL2_SOURCES		+=	drivers/st/mmc/stm32_sdmmc2.c
+endif
+
+ifeq (${STM32MP_RAW_NAND},1)
+BL2_SOURCES		+=	drivers/st/fmc/stm32_fmc2_nand.c
+endif
+
+ifneq ($(filter 1,${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR} ${STM32MP_HYPERFLASH}),)
+BL2_SOURCES		+=	drivers/st/spi/stm32_ospi.c
+endif
+
+ifneq ($(filter 1,${STM32MP_RAW_NAND} ${STM32MP_SPI_NAND} ${STM32MP_SPI_NOR} ${STM32MP_HYPERFLASH}),)
+BL2_SOURCES		+=	plat/st/stm32mp2/stm32mp2_boot_device.c
+endif
+
+ifeq (${STM32MP_UART_PROGRAMMER},1)
+BL2_SOURCES		+=	drivers/st/uart/stm32_uart.c
+endif
+
+ifeq (${STM32MP_USB_PROGRAMMER},1)
+#The DFU stack uses only one end point, reduce the USB stack footprint
+$(eval $(call add_define_val,CONFIG_USBD_EP_NB,1U))
+$(eval $(call add_define,USB_CORE_AVOID_PACKET_SPLIT_MPS))
+BL2_SOURCES		+=	drivers/st/usb_dwc3/usb_dwc3.c				\
+				plat/st/stm32mp2/stm32mp2_usb_dfu.c
+endif
+
+ifeq ($(STM32MP_M33_TDCID),0)
+BL2_SOURCES		+=	drivers/st/ddr/stm32mp2_ddr.c				\
+				drivers/st/ddr/stm32mp2_ddr_helpers.c			\
+				drivers/st/ddr/stm32mp2_ram.c
+
+BL2_SOURCES		+=	drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_c_initphyconfig.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_calcmb.c					\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_i_loadpieimage.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_initstruct.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_isdbytedisabled.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_loadpieprodcode.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_mapdrvstren.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_progcsrskiptrain.c			\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_reginterface.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_restore_sequence.c			\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_sequence.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_softsetmb.c				\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_custompretrain.c	\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_saveretregs.c
+
+BL2_SOURCES		+=	drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_d_loadimem.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_f_loaddmem.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_g_execfw.c				\
+				drivers/st/ddr/phy/phyinit/src/ddrphy_phyinit_writeoutmem.c				\
+				drivers/st/ddr/phy/phyinit/usercustom/ddrphy_phyinit_usercustom_g_waitfwdone.c
+endif #STM32MP_M33_TDCID
+
+BL2_SOURCES		+=	plat/st/stm32mp2/plat_image_load.c
+
+# BL31 sources
+BL31_SOURCES		+=	${FDT_WRAPPERS_SOURCES}
+
+BL31_SOURCES		+=	plat/st/stm32mp2/bl31_plat_setup.c			\
+				plat/st/stm32mp2/stm32mp2_topology.c
+
+ifeq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
+BL31_SOURCES		+=	plat/st/stm32mp2/stm32mp2_pm.c
+endif
+
+BL31_SOURCES		+=	drivers/st/ddr/stm32mp2_ddr_helpers.c
+
+# Generic GIC v2
+include drivers/arm/gic/v2/gicv2.mk
+
+BL31_SOURCES		+=	${GICV2_SOURCES}					\
+				plat/common/plat_gicv2.c				\
+				plat/st/common/stm32mp_gic.c
+
+BL31_SOURCES		+=	plat/st/common/stm32mp_svc_setup.c			\
+				plat/st/stm32mp2/services/stgen_svc.c			\
+				plat/st/stm32mp2/services/stm32mp2_svc_setup.c
+
+# Arm Archtecture services
+BL31_SOURCES		+=	services/arm_arch_svc/arm_arch_svc_setup.c
+
+# Compilation rules
+.SUFFIXES:
+ifeq ($(STM32MP_M33_TDCID),0)
+.PHONY: check_ddr_type
+
+bl2: check_ddr_type
+
+check_ddr_type:
+	$(eval DDR_TYPE = $(shell echo $$(($(STM32MP_DDR3_TYPE) + \
+					   $(STM32MP_DDR4_TYPE) + \
+					   $(STM32MP_LPDDR4_TYPE)))))
+	@if [ ${DDR_TYPE} != 1 ]; then \
+		echo "One and only one DDR type must be defined"; \
+		false; \
+	fi
+endif #STM32MP_M33_TDCID
+
+# generate separate DDR FIP image
+ifeq (${STM32MP_DDR_FIP_IO_STORAGE},1)
+ifneq ($(filter 1,${STM32MP_UART_PROGRAMMER} ${STM32MP_USB_PROGRAMMER}),)
+
+STM32MP_DDR_FW_COPY	:=	${STM32MP_DDR_FW}
+DDR_FIP_NAME		?=	fip-ddr.bin
+
+$(eval $(call TOOL_ADD_IMG,STM32MP_DDR_FW_COPY,--ddr-fw,DDR_))
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+ifneq (${GENERATE_COT},0)
+$(eval $(call TOOL_ADD_PAYLOAD,${STM32MP_CFG_CERT},--stm32mp-cfg-cert,,DDR_))
+$(if ${ROT_KEY},$(eval $(call CERT_ADD_CMD_OPT,${ROT_KEY},--rot-key,DDR_)))
+$(if ${TFW_NVCTR_VAL},$(eval $(call CERT_ADD_CMD_OPT,${TFW_NVCTR_VAL},--tfw-nvctr,DDR_)))
+$(if ${TRUSTED_WORLD_KEY},$(eval $(call CERT_ADD_CMD_OPT,${TRUSTED_WORLD_KEY},--trusted-world-key,DDR_)))
+
+ifneq (${CREATE_KEYS},0)
+$(eval DDR_CRT_ARGS += -n)
+ifneq (${SAVE_KEYS},0)
+$(eval DDR_CRT_ARGS += -k)
+endif
+endif
+
+ddr_certificates: ${DDR_CRT_DEPS} certtool
+	@echo "Build $@"
+	${Q}${CRTTOOL} ${DDR_CRT_ARGS}
+	@${ECHO_BLANK_LINE}
+	@echo "Built $@ successfully"
+	@echo "DDR certificates can be found in ${BUILD_PLAT}"
+	@${ECHO_BLANK_LINE}
+
+DDR_FIP_DEPS		+=	ddr_certificates
+endif
+endif
+
+${BUILD_PLAT}/${DDR_FIP_NAME}: ${DDR_FIP_DEPS} fiptool
+	${Q}${FIPTOOL} create ${DDR_FIP_ARGS} $@
+	${Q}${FIPTOOL} info $@
+	@${ECHO_BLANK_LINE}
+	@echo "Built $@ successfully"
+	@${ECHO_BLANK_LINE}
+
+fip-ddr: ${BUILD_PLAT}/${DDR_FIP_NAME}
+
+fip: fip-ddr
+
+endif
+endif
+
+# Create DTB file for BL31
+${BUILD_PLAT}/fdts/%-bl31.dts: $(DT_SOURCE_PATH)/%.dts fdts/${BL31_DTSI} | ${BUILD_PLAT} fdt_dirs
+	@echo '#include "$(patsubst fdts/%,%,$<)"' > $@
+	@echo '#include "${BL31_DTSI}"' >> $@
+
+${BUILD_PLAT}/fdts/%-bl31.dtb: ${BUILD_PLAT}/fdts/%-bl31.dts
+
+include plat/st/common/common_rules.mk
diff --git a/plat/st/stm32mp2/services/stgen_svc.c b/plat/st/stm32mp2/services/stgen_svc.c
new file mode 100644
index 0000000000..cfb27bc05b
--- /dev/null
+++ b/plat/st/stm32mp2/services/stgen_svc.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <lib/mmio.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32mp_svc_setup.h>
+#include <stm32mp_common.h>
+#include <stm32mp2_smc.h>
+
+#include "stgen_svc.h"
+
+/*
+ * This function reads and applies the STGEN frequency value in the STGENC base frequency register,
+ * which is the frequency the system base counter use for our platforms.
+ */
+uint32_t stgen_svc_handler(void)
+{
+	unsigned long freq_to_set = mmio_read_32(STGEN_BASE + CNTFID_OFF);
+
+	VERBOSE("STGEN frequency set to %lu\n", freq_to_set);
+
+	/*
+	 * Update the system counter frequency according to STGEN's base
+	 * counter frequency register
+	 */
+	write_cntfrq_el0((u_register_t)freq_to_set);
+
+	/* Need to update timer with new frequency */
+	generic_delay_timer_init();
+
+	return STM32_SMC_OK;
+}
diff --git a/plat/st/stm32mp2/services/stgen_svc.h b/plat/st/stm32mp2/services/stgen_svc.h
new file mode 100644
index 0000000000..36f717b2f1
--- /dev/null
+++ b/plat/st/stm32mp2/services/stgen_svc.h
@@ -0,0 +1,12 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STGEN_SVC_H
+#define STGEN_SVC_H
+
+uint32_t stgen_svc_handler(void);
+
+#endif /* STGEN_SVC_H */
diff --git a/plat/st/stm32mp2/services/stm32mp2_svc_setup.c b/plat/st/stm32mp2/services/stm32mp2_svc_setup.c
new file mode 100644
index 0000000000..08fe1630c1
--- /dev/null
+++ b/plat/st/stm32mp2/services/stm32mp2_svc_setup.c
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <lib/mmio.h>
+
+#include <stm32mp_svc_setup.h>
+#include <stm32mp2_smc.h>
+
+#include "stgen_svc.h"
+
+/*
+ * Platform-level Standard Service SIP SMC handler. This handler will dispatch
+ * the SMC to the correct feature handler.
+ */
+void plat_svc_smc_handler(uint32_t smc_fid, u_register_t x1,
+			  u_register_t x2, u_register_t x3,
+			  u_register_t x4, uint32_t *ret1,
+			  uint32_t *ret2, bool *ret2_enabled,
+			  u_register_t flags)
+{
+	switch (smc_fid) {
+	case STM32_SIP_SVC_CALL_COUNT:
+		*ret1 = STM32_COMMON_SIP_NUM_CALLS;
+		break;
+	case STM32_SIP_SMC_STGEN_SET_RATE:
+		if (!is_caller_secure(flags)) {
+			*ret1 = STM32_SMC_FAILED;
+			break;
+		}
+
+		*ret1 = stgen_svc_handler();
+		break;
+	default:
+		WARN("Unimplemented STM32MP2 Service Call: 0x%x\n", smc_fid);
+		*ret1 = STM32_SMC_NOT_SUPPORTED;
+		break;
+	}
+}
diff --git a/plat/st/stm32mp2/stm32mp2_boot_device.c b/plat/st/stm32mp2/stm32mp2_boot_device.c
new file mode 100644
index 0000000000..2fd275c262
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_boot_device.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2021-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <drivers/hyperflash.h>
+#include <drivers/nand.h>
+#include <drivers/raw_nand.h>
+#include <drivers/spi_nand.h>
+#include <drivers/spi_nor.h>
+#include <lib/utils.h>
+#include <plat/common/platform.h>
+
+#if STM32MP_RAW_NAND || STM32MP_SPI_NAND
+static int get_data_from_otp(struct nand_device *nand_dev, bool is_slc)
+{
+	uint32_t nand_param;
+	uint32_t nand2_param;
+
+	/* Check if NAND parameters are stored in OTP */
+	if (stm32_get_otp_value(NAND_OTP, &nand_param) != 0) {
+		ERROR("BSEC: NAND_OTP Error\n");
+		return -EACCES;
+	}
+
+	if ((nand_param == 0U) && is_slc) {
+		return 0;
+	}
+
+	if (((nand_param & NAND_PARAM_STORED_IN_OTP) == 0U) && is_slc) {
+		goto ecc;
+	}
+
+	if (stm32_get_otp_value(NAND2_OTP, &nand2_param) != 0) {
+		ERROR("BSEC: NAND2_OTP Error\n");
+		return -EACCES;
+	}
+
+	/* Check OTP configuration for this device */
+	if ((((nand2_param & NAND2_CONFIG_DISTRIB) == NAND2_PNAND_NAND1_SNAND_NAND2) && !is_slc) ||
+	    (((nand2_param & NAND2_CONFIG_DISTRIB) == NAND2_PNAND_NAND2_SNAND_NAND1) && is_slc)) {
+		nand_param = nand2_param << (NAND_PAGE_SIZE_SHIFT - NAND2_PAGE_SIZE_SHIFT);
+	}
+
+	/* NAND parameter shall be read from OTP */
+	if ((nand_param & NAND_WIDTH_MASK) != 0U) {
+		nand_dev->buswidth = NAND_BUS_WIDTH_16;
+	} else {
+		nand_dev->buswidth = NAND_BUS_WIDTH_8;
+	}
+
+	switch ((nand_param & NAND_PAGE_SIZE_MASK) >> NAND_PAGE_SIZE_SHIFT) {
+	case NAND_PAGE_SIZE_2K:
+		nand_dev->page_size = 0x800U;
+		break;
+
+	case NAND_PAGE_SIZE_4K:
+		nand_dev->page_size = 0x1000U;
+		break;
+
+	case NAND_PAGE_SIZE_8K:
+		nand_dev->page_size = 0x2000U;
+		break;
+
+	default:
+		ERROR("Cannot read NAND page size\n");
+		return -EINVAL;
+	}
+
+	switch ((nand_param & NAND_BLOCK_SIZE_MASK) >> NAND_BLOCK_SIZE_SHIFT) {
+	case NAND_BLOCK_SIZE_64_PAGES:
+		nand_dev->block_size = 64U * nand_dev->page_size;
+		break;
+
+	case NAND_BLOCK_SIZE_128_PAGES:
+		nand_dev->block_size = 128U * nand_dev->page_size;
+		break;
+
+	case NAND_BLOCK_SIZE_256_PAGES:
+		nand_dev->block_size = 256U * nand_dev->page_size;
+		break;
+
+	default:
+		ERROR("Cannot read NAND block size\n");
+		return -EINVAL;
+	}
+
+	nand_dev->size = ((nand_param & NAND_BLOCK_NB_MASK) >>
+			  NAND_BLOCK_NB_SHIFT) *
+		NAND_BLOCK_NB_UNIT * nand_dev->block_size;
+
+ecc:
+	if (is_slc) {
+		switch ((nand_param & NAND_ECC_BIT_NB_MASK) >>
+			NAND_ECC_BIT_NB_SHIFT) {
+		case NAND_ECC_BIT_NB_1_BITS:
+			nand_dev->ecc.max_bit_corr = 1U;
+			break;
+
+		case NAND_ECC_BIT_NB_4_BITS:
+			nand_dev->ecc.max_bit_corr = 4U;
+			break;
+
+		case NAND_ECC_BIT_NB_8_BITS:
+			nand_dev->ecc.max_bit_corr = 8U;
+			break;
+
+		case NAND_ECC_ON_DIE:
+			nand_dev->ecc.mode = NAND_ECC_ONDIE;
+			break;
+
+		default:
+			if (nand_dev->ecc.max_bit_corr == 0U) {
+				ERROR("No valid eccbit number\n");
+				return -EINVAL;
+			}
+		}
+	} else {
+		/* Selected multiple plane NAND */
+		if ((nand_param & NAND_PLANE_BIT_NB_MASK) != 0U) {
+			nand_dev->nb_planes = 2U;
+		} else {
+			nand_dev->nb_planes = 1U;
+		}
+	}
+
+	VERBOSE("OTP: Block %u Page %u Size %llu\n", nand_dev->block_size,
+		nand_dev->page_size, nand_dev->size);
+
+	return 0;
+}
+#endif /* STM32MP_RAW_NAND || STM32MP_SPI_NAND */
+
+#if STM32MP_RAW_NAND
+int plat_get_raw_nand_data(struct rawnand_device *device)
+{
+	device->nand_dev->ecc.mode = NAND_ECC_HW;
+	device->nand_dev->ecc.size = SZ_512;
+
+	return get_data_from_otp(device->nand_dev, true);
+}
+#endif
+
+#if STM32MP_SPI_NAND
+int plat_get_spi_nand_data(struct spinand_device *device)
+{
+	return get_data_from_otp(device->nand_dev, false);
+}
+#endif
+
+#if STM32MP_SPI_NOR
+int plat_get_nor_data(struct nor_device *device)
+{
+	/* Quad read command used with MX25L51245G */
+	device->size = SZ_64M;
+	device->flags |= SPI_NOR_USE_BANK;
+
+	zeromem(&device->read_op, sizeof(struct spi_mem_op));
+	device->read_op.cmd.opcode = SPI_NOR_OP_READ_1_1_4;
+	device->read_op.cmd.nbytes = 1U;
+	device->read_op.cmd.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	device->read_op.addr.nbytes = 3U;
+	device->read_op.addr.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	device->read_op.dummy.nbytes = 1U;
+	device->read_op.dummy.buswidth = SPI_MEM_BUSWIDTH_1_LINE;
+	device->read_op.data.buswidth = SPI_MEM_BUSWIDTH_4_LINE;
+	device->read_op.data.dir = SPI_MEM_DATA_IN;
+
+	return 0;
+}
+#endif
+
+#if STM32MP_HYPERFLASH
+int plat_get_hyperflash_data(struct hyperflash_device *device)
+{
+	device->size = SZ_64M;
+
+	return 0;
+}
+#endif
diff --git a/plat/st/stm32mp2/stm32mp2_context.c b/plat/st/stm32mp2/stm32mp2_context.c
new file mode 100644
index 0000000000..b54349ce0a
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_context.c
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2023-2024, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <drivers/clk.h>
+#include <lib/el3_runtime/context_mgmt.h>
+#include <lib/el3_runtime/cpu_data.h>
+
+#if defined(SPD_opteed)
+#include "../../../services/spd/opteed/opteed_private.h"
+#endif
+
+#include "../../../lib/psci/psci_private.h"
+
+#include <platform_def.h>
+#include <stm32mp2_context.h>
+
+#define BACKUP_CTX_ADDR		STM32MP_BACKUP_RAM_BASE
+#define BACKUP_CTX_CLK		CK_BUS_BKPSRAM
+#define KEY_SEED_SIZE_IN_BYTES	RISAF_SEED_SIZE_IN_BYTES
+
+/* Magic used to indicated valid = ' ' 'M' 'P' '2' */
+#define CONTEXT_MAGIC			0x204D5032
+
+struct backup_data_s {
+	uint32_t magic;
+	uint8_t mkey_seed[KEY_SEED_SIZE_IN_BYTES];
+	psci_power_state_t standby_pwr_state;
+	cpu_context_t saved_cpu_s_context[PLATFORM_CORE_COUNT];
+	cpu_context_t saved_cpu_ns_context[PLATFORM_CORE_COUNT];
+	suspend_mode_t psci_suspend_mode;
+#if defined(SPD_opteed)
+	uintptr_t optee_vector;
+	optee_context_t opteed_sp_context[OPTEED_CORE_COUNT];
+#endif
+	uintptr_t fdt_bl31;
+};
+
+void stm32mp_pm_save_enc_mkey_seed_in_context(uint8_t *data)
+{
+	struct backup_data_s *backup_data;
+
+	backup_data = (struct backup_data_s *)BACKUP_CTX_ADDR;
+
+	clk_enable(BACKUP_CTX_CLK);
+
+	memcpy(backup_data->mkey_seed, data, KEY_SEED_SIZE_IN_BYTES);
+
+	clk_disable(BACKUP_CTX_CLK);
+}
+
+void stm32mp_pm_get_enc_mkey_seed_from_context(uint8_t *data)
+{
+	struct backup_data_s *backup_data;
+
+	clk_enable(BACKUP_CTX_CLK);
+
+	backup_data = (struct backup_data_s *)BACKUP_CTX_ADDR;
+
+	memcpy(data, backup_data->mkey_seed, KEY_SEED_SIZE_IN_BYTES);
+
+	clk_disable(BACKUP_CTX_CLK);
+}
+
+bool stm32_pm_context_is_valid(void)
+{
+	struct backup_data_s *backup_data;
+	bool ret;
+
+	clk_enable(BACKUP_CTX_CLK);
+
+	backup_data = (struct backup_data_s *)BACKUP_CTX_ADDR;
+
+	ret = (backup_data->magic == CONTEXT_MAGIC);
+
+	clk_disable(BACKUP_CTX_CLK);
+
+	return ret;
+}
+
+void stm32_pm_context_save(const psci_power_state_t *state)
+{
+	void *cpu_context;
+	struct backup_data_s *backup_data;
+	void *fdt;
+
+	clk_enable(BACKUP_CTX_CLK);
+	backup_data = (struct backup_data_s *)BACKUP_CTX_ADDR;
+
+	backup_data->magic = CONTEXT_MAGIC;
+
+	/* Retrieve non-secure CPU context struct address */
+	cpu_context = cm_get_context(NON_SECURE);
+
+	/* Save context in Backup SRAM */
+	memcpy(&backup_data->saved_cpu_ns_context[0], cpu_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	/* Retrieve secure CPU context struct address */
+	cpu_context = cm_get_context(SECURE);
+
+	/* Save context in Backup SRAM */
+	memcpy(&backup_data->saved_cpu_s_context[0], cpu_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+#if defined(SPD_opteed)
+	backup_data->optee_vector = (uintptr_t)optee_vector_table;
+
+	memcpy(&backup_data->opteed_sp_context[0], opteed_sp_context,
+	       sizeof(optee_context_t) * OPTEED_CORE_COUNT);
+#endif
+
+	/* Save PSCI state in Backup SRAM */
+	memcpy(&backup_data->standby_pwr_state, state, sizeof(psci_power_state_t));
+	backup_data->psci_suspend_mode = psci_suspend_mode;
+
+	fdt_get_address(&fdt);
+	backup_data->fdt_bl31 = (uintptr_t)fdt;
+
+	clk_disable(BACKUP_CTX_CLK);
+}
+
+void stm32_pm_context_restore(void)
+{
+	void *cpu_context;
+	struct backup_data_s *backup_data;
+	int ret;
+
+	clk_enable(BACKUP_CTX_CLK);
+	backup_data = (struct backup_data_s *)BACKUP_CTX_ADDR;
+
+	/* Retrieve non-secure CPU context struct address */
+	cpu_context = cm_get_context(NON_SECURE);
+
+	/* Restore data from Backup SRAM */
+	memcpy(cpu_context, backup_data->saved_cpu_ns_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	/* Retrieve non-secure CPU context struct address */
+	cpu_context = cm_get_context(SECURE);
+
+	/* Restore data from Backup SRAM */
+	memcpy(cpu_context, backup_data->saved_cpu_s_context,
+	       sizeof(cpu_context_t) * PLATFORM_CORE_COUNT);
+
+	psci_set_target_local_pwr_states(PLAT_MAX_PWR_LVL,
+					 &backup_data->standby_pwr_state);
+
+	if (psci_set_suspend_mode(backup_data->psci_suspend_mode) != PSCI_E_SUCCESS) {
+		panic();
+	}
+
+#if defined(SPD_opteed)
+	optee_vector_table = (optee_vectors_t *)backup_data->optee_vector;
+
+	memcpy(opteed_sp_context, backup_data->opteed_sp_context,
+	       sizeof(optee_context_t) * OPTEED_CORE_COUNT);
+
+	opteed_restore();
+#endif
+
+	ret = dt_open_and_check(backup_data->fdt_bl31);
+	if (ret < 0) {
+		ERROR("%s: failed to open DT (%d)\n", __func__, ret);
+		panic();
+	}
+
+	clk_disable(BACKUP_CTX_CLK);
+}
+
+void stm32_pm_context_clear(void)
+{
+	struct backup_data_s *backup_data;
+
+	backup_data = (struct backup_data_s *)BACKUP_CTX_ADDR;
+
+	clk_enable(BACKUP_CTX_CLK);
+
+	backup_data->magic = 0U;
+
+	clk_disable(BACKUP_CTX_CLK);
+}
diff --git a/plat/st/stm32mp2/stm32mp2_def.h b/plat/st/stm32mp2/stm32mp2_def.h
new file mode 100644
index 0000000000..001b26abba
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_def.h
@@ -0,0 +1,608 @@
+/*
+ * Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef STM32MP2_DEF_H
+#define STM32MP2_DEF_H
+
+#include <common/tbbr/tbbr_img_def.h>
+#include <drivers/st/stm32mp2_pwr.h>
+#include <drivers/st/stm32mp2_rcc.h>
+#include <dt-bindings/clock/stm32mp25-clks.h>
+#include <dt-bindings/clock/stm32mp25-clksrc.h>
+#include <dt-bindings/gpio/stm32-gpio.h>
+#include <dt-bindings/reset/stm32mp25-resets.h>
+#include <dt-bindings/soc/rif.h>
+
+#ifndef __ASSEMBLER__
+#include <drivers/st/bsec.h>
+#include <drivers/st/stm32mp2_clk.h>
+
+#include <boot_api.h>
+#include <stm32mp_common.h>
+#include <stm32mp_dt.h>
+#include <stm32mp_shared_resources.h>
+#include <stm32mp2_private.h>
+#endif
+
+/*******************************************************************************
+ * CHIP ID
+ ******************************************************************************/
+#define STM32MP2_CHIP_ID	U(0x505)
+
+#define STM32MP251A_PART_NB	U(0x400B3E6D)
+#define STM32MP251C_PART_NB	U(0x000B306D)
+#define STM32MP251D_PART_NB	U(0xC00B3E6D)
+#define STM32MP251F_PART_NB	U(0x800B306D)
+#define STM32MP253A_PART_NB	U(0x400B3E0C)
+#define STM32MP253C_PART_NB	U(0x000B300C)
+#define STM32MP253D_PART_NB	U(0xC00B3E0C)
+#define STM32MP253F_PART_NB	U(0x800B300C)
+#define STM32MP255A_PART_NB	U(0x40082E00)
+#define STM32MP255C_PART_NB	U(0x00082000)
+#define STM32MP255D_PART_NB	U(0xC0082E00)
+#define STM32MP255F_PART_NB	U(0x80082000)
+#define STM32MP257A_PART_NB	U(0x40002E00)
+#define STM32MP257C_PART_NB	U(0x00002000)
+#define STM32MP257D_PART_NB	U(0xC0002E00)
+#define STM32MP257F_PART_NB	U(0x80002000)
+
+#define STM32MP2_REV_B		U(0x10)
+#define STM32MP2_REV_X		U(0x12)
+#define STM32MP2_REV_Y		U(0x11)
+#define STM32MP2_REV_Z		U(0x09)
+
+/*******************************************************************************
+ * PACKAGE ID
+ ******************************************************************************/
+#define STM32MP25_PKG_CUSTOM		U(0)
+#define STM32MP25_PKG_AL_TBGA361	U(3)
+#define STM32MP25_PKG_AK_TBGA424	U(4)
+#define STM32MP25_PKG_AI_TBGA436	U(5)
+#define STM32MP25_PKG_UNKNOWN		U(7)
+
+/*******************************************************************************
+ * STM32MP2 memory map related constants
+ ******************************************************************************/
+#define STM32MP_SYSRAM_BASE		U(0x0E000000)
+#define STM32MP_SYSRAM_SIZE		U(0x00040000)
+#define SRAM1_BASE			U(0x0E040000)
+#define SRAM1_SIZE_FOR_TFA		U(0x00010000)
+#define RETRAM_BASE			U(0x0E080000)
+#define RETRAM_SIZE			U(0x00020000)
+#define STM32MP_BACKUP_RAM_BASE		U(0x42000000)
+
+/* the first 4KB of SRAM1 are reserved are for BSEC shadow */
+#define STM32MP_SEC_SRAM1_SIZE		U(0x1000)
+
+#define STM32MP_SEC_SYSRAM_BASE		STM32MP_SYSRAM_BASE
+
+#if defined(IMAGE_BL2)
+#if STM32MP_USB_PROGRAMMER
+#define STM32MP_SEC_DEVICE_SYSRAM_SIZE		STM32MP_USB_DWC3_SIZE
+#define STM32MP_SEC_DEVICE_SYSRAM_BASE		(STM32MP_SYSRAM_BASE + \
+						 STM32MP_SYSRAM_SIZE - \
+						 STM32MP_SEC_DEVICE_SYSRAM_SIZE)
+
+#define STM32MP_SEC_SYSRAM_SIZE		(STM32MP_SYSRAM_SIZE - \
+					 STM32MP_SEC_DEVICE_SYSRAM_SIZE)
+
+#define STM32MP_USB_DWC3_BASE		STM32MP_SEC_DEVICE_SYSRAM_BASE
+#define STM32MP_USB_DWC3_SIZE		PAGE_SIZE
+#else /* STM32MP_USB_PROGRAMMER */
+#define STM32MP_SEC_SYSRAM_SIZE		STM32MP_SYSRAM_SIZE
+#endif /* STM32MP_USB_PROGRAMMER */
+#else /* IMAGE_BL2 */
+#define STM32MP_NS_SYSRAM_SIZE		PAGE_SIZE
+#define STM32MP_NS_SYSRAM_BASE		(STM32MP_SYSRAM_BASE + \
+					 STM32MP_SYSRAM_SIZE - \
+					 STM32MP_NS_SYSRAM_SIZE)
+
+#define STM32MP_SCMI_NS_SHM_BASE	STM32MP_NS_SYSRAM_BASE
+#define STM32MP_SCMI_NS_SHM_SIZE	STM32MP_NS_SYSRAM_SIZE
+
+#define STM32MP_SEC_SYSRAM_SIZE		(STM32MP_SYSRAM_SIZE - \
+					 STM32MP_NS_SYSRAM_SIZE)
+#endif
+
+/* DDR configuration */
+#define STM32MP_DDR_BASE		U(0x80000000)
+#define STM32MP_DDR_MAX_SIZE		UL(0x100000000)	/* Max 4GB */
+#define STM32MP_DDR_S_SIZE		U(0)
+#define STM32MP_DDR_SHMEM_SIZE		U(0)
+
+/* DDR power initializations */
+#ifndef __ASSEMBLER__
+enum ddr_type {
+	STM32MP_DDR3,
+	STM32MP_DDR4,
+	STM32MP_LPDDR4
+};
+#endif
+
+/* Section used inside TF binaries */
+#define STM32MP_PARAM_LOAD_SIZE		U(0x00002400)	/* 9 KB for param */
+/* 512 Octets reserved for header */
+#define STM32MP_HEADER_SIZE		U(0x00000200)
+#define STM32MP_HEADER_BASE		(STM32MP_SEC_SYSRAM_BASE +	\
+					 STM32MP_PARAM_LOAD_SIZE)
+
+/* round_up(STM32MP_PARAM_LOAD_SIZE + STM32MP_HEADER_SIZE, PAGE_SIZE) */
+#define STM32MP_HEADER_RESERVED_SIZE	U(0x3000)
+
+#define STM32MP_BINARY_BASE		(STM32MP_SEC_SYSRAM_BASE +	\
+					 STM32MP_PARAM_LOAD_SIZE +	\
+					 STM32MP_HEADER_SIZE)
+
+#define STM32MP_BINARY_SIZE		(STM32MP_SEC_SYSRAM_SIZE -	\
+					 (STM32MP_PARAM_LOAD_SIZE +	\
+					  STM32MP_HEADER_SIZE))
+
+#define STM32MP_BL31_SIZE		U(0x0001F000)	/* 124 KB for BL31 */
+
+#if TRUSTED_BOARD_BOOT
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+#define STM32MP_BL2_RO_SIZE		U(0x00021000)	/* 132 KB */
+#define STM32MP_BL2_SIZE		U(0x0002C000)	/* 176 KB for BL2 */
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+#define STM32MP_BL2_RO_SIZE		U(0x00021000)	/* 132 KB */
+#define STM32MP_BL2_SIZE		U(0x0002D000)	/* 180 KB for BL2 */
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+#else
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+#define STM32MP_BL2_RO_SIZE		U(0x0001F000)	/* 124 KB */
+#define STM32MP_BL2_SIZE		U(0x00028000)	/* 160 KB for BL2 */
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+#define STM32MP_BL2_RO_SIZE		U(0x00020000)	/* 128 KB */
+#define STM32MP_BL2_SIZE		U(0x00029000)	/* 164 KB for BL2 */
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+#endif
+
+#define STM32MP_BL2_BASE		(STM32MP_SEC_SYSRAM_BASE + \
+					 STM32MP_SEC_SYSRAM_SIZE - \
+					 STM32MP_BL2_SIZE)
+
+#define STM32MP_BL2_RO_BASE		STM32MP_BL2_BASE
+
+#define STM32MP_BL2_RW_BASE		(STM32MP_BL2_RO_BASE + \
+					 STM32MP_BL2_RO_SIZE)
+
+#define STM32MP_BL2_RW_SIZE		STM32MP_SYSRAM_BASE + \
+					STM32MP_SYSRAM_SIZE - \
+					STM32MP_BL2_RW_BASE
+
+#define STM32MP_MBEDTLS_HEAP_SIZE	U(0x2000)
+#define STM32MP_MBEDTLS_HEAP_BASE	(SRAM1_BASE + SRAM1_SIZE_FOR_TFA - \
+					 STM32MP_MBEDTLS_HEAP_SIZE)
+
+/* BL2 and BL32/sp_min require 4 tables */
+#define MAX_XLAT_TABLES			U(4)	/* 16 KB for mapping */
+
+/*
+ * MAX_MMAP_REGIONS is usually:
+ * BL stm32mp2_mmap size + mmap regions in *_plat_arch_setup
+ */
+#if STM32MP_USB_PROGRAMMER || defined(IMAGE_BL31)
+#define MAX_MMAP_REGIONS		7
+#else
+#define MAX_MMAP_REGIONS		6
+#endif
+
+/* DTB initialization value */
+#define STM32MP_BL2_DTB_SIZE		U(0x00006000)	/* 24 KB for DTB */
+
+#define STM32MP_BL2_DTB_BASE		(STM32MP_BL2_BASE - \
+					 STM32MP_BL2_DTB_SIZE)
+
+#if defined(IMAGE_BL2)
+#define STM32MP_DTB_SIZE		STM32MP_BL2_DTB_SIZE
+#define STM32MP_DTB_BASE		STM32MP_BL2_DTB_BASE
+#endif
+
+#if STM32MP_DDR_FIP_IO_STORAGE
+#define STM32MP_DDR_FW_BASE		(SRAM1_BASE + STM32MP_SEC_SRAM1_SIZE)
+#define STM32MP_DDR_FW_DMEM_OFFSET	U(0x400)
+#define STM32MP_DDR_FW_IMEM_OFFSET	U(0x800)
+#define STM32MP_DDR_FW_MAX_SIZE		U(0x8800)
+#endif
+
+#define STM32MP_FW_CONFIG_MAX_SIZE	PAGE_SIZE
+#define STM32MP_FW_CONFIG_BASE		STM32MP_SYSRAM_BASE
+
+#define STM32MP_BL33_BASE		(STM32MP_DDR_BASE + U(0x04000000))
+#define STM32MP_BL33_MAX_SIZE		U(0x400000)
+#define STM32MP_HW_CONFIG_BASE		(STM32MP_BL33_BASE + \
+					STM32MP_BL33_MAX_SIZE)
+#define STM32MP_HW_CONFIG_MAX_SIZE	U(0x40000)
+#define STM32MP_SOC_FW_CONFIG_MAX_SIZE	U(0x10000) /* 64kB for BL31 DT */
+
+/* Define maximum page size for NAND devices */
+#define PLATFORM_MTD_MAX_PAGE_SIZE	U(0x1000)
+
+/*******************************************************************************
+ * STM32MP2 device/io map related constants (used for MMU)
+ ******************************************************************************/
+#define STM32MP_DEVICE_BASE		U(0x40000000)
+#define STM32MP_DEVICE_SIZE		U(0x40000000)
+
+/*******************************************************************************
+ * STM32MP2 IAC
+ ******************************************************************************/
+#define IAC_BASE			U(0x42090000)
+
+#define IAC_NB				U(6)
+#define IAC_IER0			U(0x00)
+#define IAC_ISR0			U(0x80)
+#define IAC_ICR0			U(0x100)
+
+#define IAC_IER(n)			(IAC_IER0 + (U(4) * (n)))
+#define IAC_ISR(n)			(IAC_ISR0 + (U(4) * (n)))
+#define IAC_ICR(n)			(IAC_ICR0 + (U(4) * (n)))
+
+/*******************************************************************************
+ * STM32MP2 RCC
+ ******************************************************************************/
+#define RCC_BASE			U(0x44200000)
+
+/*******************************************************************************
+ * STM32MP2 PWR
+ ******************************************************************************/
+#define PWR_BASE			U(0x44210000)
+
+/*******************************************************************************
+ * STM32MP2 EXTI1
+ ******************************************************************************/
+#define STM32MP_EXTI1_BASE		U(0x44220000)
+
+/* EXTI1 CPU1 wake-up with interrupt mask register */
+#define EXTI1_C1IMR1			U(0x80)
+#define EXTI1_C1IMR2			U(0x90)
+#define EXTI1_C1IMR3			U(0xA0)
+
+#define EXTI1_C1IMR1_PVD		BIT(16)
+#define EXTI1_C1IMR1_PVM		BIT(17)
+
+#define EXTI1_C1IMR2_WKUP1		BIT(52 - 32)
+#define EXTI1_C1IMR2_WKUP2		BIT(53 - 32)
+#define EXTI1_C1IMR2_WKUP3		BIT(54 - 32)
+#define EXTI1_C1IMR2_WKUP4		BIT(55 - 32)
+#define EXTI1_C1IMR2_WKUP5		BIT(56 - 32)
+#define EXTI1_C1IMR2_WKUP6		BIT(57 - 32)
+
+#define EXTI1_C1IMR2_WKUP_MASK		GENMASK_32(57 - 32, 52 - 32)
+
+/*******************************************************************************
+ * STM32MP2 EXTI2
+ ******************************************************************************/
+#define STM32MP_EXTI2_BASE		U(0x46230000)
+
+#define EXTI2_C1IMR1			U(0x80)
+#define EXTI2_C1IMR2			U(0x90)
+#define EXTI2_C1IMR3			U(0xA0)
+#define EXTI2_C2IMR1			U(0xC0)
+#define EXTI2_C2IMR2			U(0xD0)
+#define EXTI2_C2IMR3			U(0xE0)
+#define EXTI2_C3IMR1			U(0x100)
+#define EXTI2_C3IMR2			U(0x110)
+#define EXTI2_C3IMR3			U(0x120)
+
+/*******************************************************************************
+ * STM32MP2 GPIO
+ ******************************************************************************/
+#define GPIOA_BASE			U(0x44240000)
+#define GPIOB_BASE			U(0x44250000)
+#define GPIOC_BASE			U(0x44260000)
+#define GPIOD_BASE			U(0x44270000)
+#define GPIOE_BASE			U(0x44280000)
+#define GPIOF_BASE			U(0x44290000)
+#define GPIOG_BASE			U(0x442A0000)
+#define GPIOH_BASE			U(0x442B0000)
+#define GPIOI_BASE			U(0x442C0000)
+#define GPIOJ_BASE			U(0x442D0000)
+#define GPIOK_BASE			U(0x442E0000)
+#define GPIOZ_BASE			U(0x46200000)
+#define GPIO_BANK_OFFSET		U(0x10000)
+
+#define STM32MP_GPIOS_PIN_MAX_COUNT	16
+#define STM32MP_GPIOZ_PIN_MAX_COUNT	8
+
+/*******************************************************************************
+ * STM32MP2 UART
+ ******************************************************************************/
+#define USART1_BASE			U(0x40330000)
+#define USART2_BASE			U(0x400E0000)
+#define USART3_BASE			U(0x400F0000)
+#define UART4_BASE			U(0x40100000)
+#define UART5_BASE			U(0x40110000)
+#define USART6_BASE			U(0x40220000)
+#define UART7_BASE			U(0x40370000)
+#define UART8_BASE			U(0x40380000)
+#define UART9_BASE			U(0x402C0000)
+#define STM32MP_NB_OF_UART		U(9)
+
+/* For UART crash console */
+#define STM32MP_DEBUG_USART_CLK_FRQ	64000000
+/* USART2 on HSI@64MHz, TX on GPIOA4 Alternate 6 */
+#define STM32MP_DEBUG_USART_BASE	USART2_BASE
+#define DEBUG_UART_TX_GPIO_BANK_ADDRESS	GPIOA_BASE
+#define DEBUG_UART_TX_GPIO_BANK_CLK_REG	RCC_GPIOACFGR
+#define DEBUG_UART_TX_GPIO_BANK_CLK_EN	RCC_GPIOxCFGR_GPIOxEN
+#define DEBUG_UART_TX_GPIO_PORT		4
+#define DEBUG_UART_TX_GPIO_ALTERNATE	6
+#define DEBUG_UART_TX_CLKSRC_REG	RCC_XBAR8CFGR
+#define DEBUG_UART_TX_CLKSRC		XBAR_SRC_HSI
+#define DEBUG_UART_TX_EN_REG		RCC_USART2CFGR
+#define DEBUG_UART_TX_EN		RCC_UARTxCFGR_UARTxEN
+#define DEBUG_UART_RST_REG		RCC_USART2CFGR
+#define DEBUG_UART_RST_BIT		RCC_UARTxCFGR_UARTxRST
+#define DEBUG_UART_PREDIV_CFGR		RCC_PREDIV8CFGR
+#define DEBUG_UART_FINDIV_CFGR		RCC_FINDIV8CFGR
+
+/*******************************************************************************
+ * STM32MP2 SDMMC
+ ******************************************************************************/
+#define STM32MP_SDMMC1_BASE		U(0x48220000)
+#define STM32MP_SDMMC2_BASE		U(0x48230000)
+#define STM32MP_SDMMC3_BASE		U(0x48240000)
+
+/*******************************************************************************
+ * STM32MP2 OSPI
+ ******************************************************************************/
+/* OSPI 1 & 2 memory map area */
+#define STM32MP_OSPI_MM_BASE		U(0x60000000)
+#define STM32MP_OSPI_MM_SIZE		U(0x10000000)
+
+/*******************************************************************************
+ * STM32MP2 BSEC / OTP
+ ******************************************************************************/
+/*
+ * 367 available OTPs, the other are masked
+ * - ECIES key: 368 to 375 (only readable by bootrom)
+ * - HWKEY: 376 to 383 (never reloadable or readable)
+ */
+#define STM32MP2_OTP_MAX_ID		0x16FU
+#define STM32MP2_MID_OTP_START		0x80U
+#define STM32MP2_UPPER_OTP_START	0x100U
+
+/* OTP labels */
+#define PART_NUMBER_OTP			"part_number_otp"
+#define REVISION_OTP			"rev_otp"
+#define PACKAGE_OTP			"package_otp"
+#define HCONF1_OTP			"otp124"
+#define NAND_OTP			"otp16"
+#define NAND2_OTP			"otp20"
+#define BOARD_ID_OTP			"board_id"
+#define UID_OTP				"uid_otp"
+#define LIFECYCLE2_OTP			"otp18"
+#define PKH_OTP				"otp144"
+#define ENCKEY_OTP			"otp260"
+
+/* OTP mask */
+/* PACKAGE */
+#define PACKAGE_OTP_PKG_MASK		GENMASK_32(2, 0)
+#define PACKAGE_OTP_PKG_SHIFT		0
+
+/* IWDG OTP */
+#define HCONF1_OTP_IWDG_HW_MASK(i)		BIT((i) * 3U)
+#define HCONF1_OTP_IWDG_FZ_STOP_MASK(i)		BIT((i) * 3U + 1U)
+#define HCONF1_OTP_IWDG_FZ_STANDBY_MASK(i)	BIT((i) * 3U + 2U)
+
+/* NAND OTP */
+/* NAND parameter storage flag */
+#define NAND_PARAM_STORED_IN_OTP	BIT(31)
+
+/* NAND page size in bytes */
+#define NAND_PAGE_SIZE_MASK		GENMASK_32(30, 29)
+#define NAND_PAGE_SIZE_SHIFT		29
+#define NAND_PAGE_SIZE_2K		U(0)
+#define NAND_PAGE_SIZE_4K		U(1)
+#define NAND_PAGE_SIZE_8K		U(2)
+
+/* NAND block size in pages */
+#define NAND_BLOCK_SIZE_MASK		GENMASK_32(28, 27)
+#define NAND_BLOCK_SIZE_SHIFT		27
+#define NAND_BLOCK_SIZE_64_PAGES	U(0)
+#define NAND_BLOCK_SIZE_128_PAGES	U(1)
+#define NAND_BLOCK_SIZE_256_PAGES	U(2)
+
+/* NAND number of block (in unit of 256 blocks) */
+#define NAND_BLOCK_NB_MASK		GENMASK_32(26, 19)
+#define NAND_BLOCK_NB_SHIFT		19
+#define NAND_BLOCK_NB_UNIT		U(256)
+
+/* NAND bus width in bits */
+#define NAND_WIDTH_MASK			BIT(18)
+#define NAND_WIDTH_SHIFT		18
+
+/* NAND number of ECC bits per 512 bytes */
+#define NAND_ECC_BIT_NB_MASK		GENMASK_32(17, 15)
+#define NAND_ECC_BIT_NB_SHIFT		15
+#define NAND_ECC_BIT_NB_UNSET		U(0)
+#define NAND_ECC_BIT_NB_1_BITS		U(1)
+#define NAND_ECC_BIT_NB_4_BITS		U(2)
+#define NAND_ECC_BIT_NB_8_BITS		U(3)
+#define NAND_ECC_ON_DIE			U(4)
+
+/* NAND number of planes */
+#define NAND_PLANE_BIT_NB_MASK		BIT(14)
+
+/* NAND2 OTP */
+#define NAND2_PAGE_SIZE_SHIFT		16
+
+/* NAND2 config distribution */
+#define NAND2_CONFIG_DISTRIB		BIT(0)
+#define NAND2_PNAND_NAND2_SNAND_NAND1	U(0)
+#define NAND2_PNAND_NAND1_SNAND_NAND2	U(1)
+
+/* MONOTONIC OTP */
+#define MAX_MONOTONIC_VALUE		32
+
+/* UID OTP */
+#define UID_WORD_NB			U(3)
+
+/* Lifecycle OTP */
+#define SECURE_BOOT_CLOSED_SECURE	GENMASK_32(3, 0)
+
+/*******************************************************************************
+ * STM32MP2 TAMP
+ ******************************************************************************/
+#define PLAT_MAX_TAMP_INT		U(5)
+#define PLAT_MAX_TAMP_EXT		U(3)
+#define TAMP_BASE			U(0x46010000)
+#define TAMP_CR2			U(0x4)
+#define TAMP_CR2_MASK_POM		GENMASK_32(7, 0)
+#define TAMP_CR3			U(0x8)
+#define TAMP_CR3_MASK_POM		GENMASK_32(14, 0)
+#define TAMP_SMCR			U(0x20)
+#define TAMP_SR				U(0x30)
+#define TAMP_SR_INT_SHIFT		U(16)
+#define TAMP_BKP_REG_CLK		CK_BUS_RTC
+#define TAMP_BKP_SEC_NUMBER		U(10)
+#define TAMP_SCR			U(0x3C)
+#define TAMP_COUNTR			U(0x40)
+
+#define TAMP_SR_LSE_MONITORING		BIT(18)
+
+/*******************************************************************************
+ * STM32MP2 USB
+ ******************************************************************************/
+#define USB_DWC3_BASE			U(0x48300000)
+
+/*******************************************************************************
+ * STM32MP2 DDRCTRL
+ ******************************************************************************/
+#define DDRCTRL_BASE			U(0x48040000)
+
+/*******************************************************************************
+ * STM32MP2 DDRDBG
+ ******************************************************************************/
+#define DDRDBG_BASE			U(0x48050000)
+
+/*******************************************************************************
+ * STM32MP2 DDRPHYC
+ ******************************************************************************/
+#define DDRPHYC_BASE			U(0x48C00000)
+
+/*******************************************************************************
+ * STM32MP2 IWDG
+ ******************************************************************************/
+#define IWDG_MAX_INSTANCE		U(2)
+#define IWDG1_INST			U(0)
+#define IWDG2_INST			U(1)
+
+#define IWDG1_BASE			U(0x44010000)
+#define IWDG2_BASE			U(0x44020000)
+
+/*******************************************************************************
+ * Miscellaneous STM32MP2 peripherals base address
+ ******************************************************************************/
+#define BSEC_BASE			U(0x44000000)
+#define DBGMCU_BASE			U(0x4A010000)
+#define HASH_BASE			U(0x42010000)
+#define RAMCFG_BASE			U(0x42070000)
+#define RTC_BASE			U(0x46000000)
+#define STGEN_BASE			U(0x48080000)
+#define SYSCFG_BASE			U(0x44230000)
+
+/*******************************************************************************
+ * STM32MP RIF
+ ******************************************************************************/
+#define RIFSC_BASE			U(0x42080000)
+#define RISAB1_BASE			U(0x420F0000)
+#define RISAB2_BASE			U(0x42100000)
+#define RISAB3_BASE			U(0x42110000)
+#define RISAB4_BASE			U(0x42120000)
+#define RISAB5_BASE			U(0x42130000)
+
+#define RISAF1_INST			0
+#define RISAF2_INST			1
+#define RISAF4_INST			3
+#define RISAF5_INST			4
+#define RISAF_MAX_INSTANCE		5
+
+#define RISAF2_BASE			U(0x420B0000)
+#define RISAF4_BASE			U(0x420D0000)
+
+#ifdef RISAF1_BASE
+#define RISAF1_MAX_REGION		4
+#else
+#define RISAF1_MAX_REGION		0
+#endif
+#ifdef RISAF2_BASE
+#define RISAF2_MAX_REGION		4
+#else
+#define RISAF2_MAX_REGION		0
+#endif
+#ifdef RISAF4_BASE
+/* Consider only encrypted region maximum number, to save memory consumption */
+#define RISAF4_MAX_REGION		4
+#else
+#define RISAF4_MAX_REGION		0
+#endif
+#ifdef RISAF5_BASE
+#define RISAF5_MAX_REGION		2
+#else
+#define RISAF5_MAX_REGION		0
+#endif
+#define RISAF_MAX_REGION		(RISAF1_MAX_REGION + RISAF2_MAX_REGION + \
+					RISAF4_MAX_REGION + RISAF5_MAX_REGION)
+
+#define RISAF_KEY_SIZE_IN_BYTES		U(16)
+#define RISAF_SEED_SIZE_IN_BYTES	U(4)
+
+/*******************************************************************************
+ * RIFSC IDs
+ ******************************************************************************/
+#define STM32MP25_RIFSC_USB3DR_ID	U(66)
+#define STM32MP25_RIFSC_RNG_ID		U(92)
+#define STM32MP25_RIFSC_PKA_ID		U(93)
+#define STM32MP25_RIFSC_SAES_ID		U(94)
+
+#define STM32MP25_RIMU_USB3DR		U(4)
+
+#define RIFSC_USB3DR_PRIV		BIT(STM32MP25_RIFSC_USB3DR_ID % U(32))
+#define RIFSC_USB3DR_SEC		BIT(STM32MP25_RIFSC_USB3DR_ID % U(32))
+
+/*
+ * USB3DR Secure/Priv Master (DMA) access
+ */
+#define RIFSC_USB_BOOT_USBDR_RIMC_CONF	(RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC | \
+					 RIF_CID1 << RIFSC_RIMC_ATTRx_MCID_SHIFT | \
+					 RIFSC_RIMC_ATTRx_CIDSEL)
+
+/*******************************************************************************
+ * STM32MP CA35SSC
+ ******************************************************************************/
+#define A35SSC_BASE			U(0x48800000)
+
+/*******************************************************************************
+ * REGULATORS
+ ******************************************************************************/
+/* 3 PWR + 1 VREFBUF + 14 PMIC regulators + 1 FIXED */
+#define PLAT_NB_RDEVS			U(19)
+/* 2 FIXED */
+#define PLAT_NB_FIXED_REGUS		U(2)
+/* No GPIO regu */
+#define PLAT_NB_GPIO_REGUS		U(0)
+/* Number of low power modes defined in the device tree */
+#define PLAT_NB_SUSPEND_MODES		7
+/* TAMP BACKUP REGISTER */
+#define PLAT_NB_NVMEM_DEVS		U(1)
+#define MAX_TAMP_BACKUP_REGS_ZONES	U(7)
+
+/*******************************************************************************
+ * Device Tree defines
+ ******************************************************************************/
+#define DT_BSEC_COMPAT			"st,stm32mp25-bsec"
+#define DT_DDR_COMPAT			"st,stm32mp2-ddr"
+#define DT_IWDG_COMPAT			"st,stm32mp1-iwdg"
+#define DT_MMIO_SRAM			"mmio-sram"
+#define DT_PWR_COMPAT			"st,stm32mp25-pwr"
+#define DT_RCC_CLK_COMPAT		"st,stm32mp25-rcc"
+#define DT_SDMMC2_COMPAT		"st,stm32mp25-sdmmc2"
+#define DT_TAMP_NVRAM_COMPAT		"st,stm32mp25-tamp-nvram"
+#define DT_UART_COMPAT			"st,stm32h7-uart"
+
+#endif /* STM32MP2_DEF_H */
diff --git a/plat/st/stm32mp2/stm32mp2_otp.c b/plat/st/stm32mp2/stm32mp2_otp.c
new file mode 100644
index 0000000000..757bb7dc61
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_otp.c
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+uint32_t stm32_otp_probe(void)
+{
+	return BSEC_OK;
+}
+
+uint32_t stm32_otp_read(uint32_t *val, uint32_t otp)
+{
+	return BSEC_OK;
+}
+
+uint32_t stm32_otp_shadow_read(uint32_t *val, uint32_t otp)
+{
+	return BSEC_OK;
+}
+
+uint32_t stm32_otp_write(uint32_t val, uint32_t otp)
+{
+	return BSEC_OK;
+}
+
+uint32_t stm32_otp_set_sr_lock(uint32_t otp)
+{
+	return BSEC_OK;
+}
+
+uint32_t stm32_otp_read_sw_lock(uint32_t otp, bool *value)
+{
+	return BSEC_OK;
+}
+
+bool stm32_otp_is_closed_device(void)
+{
+	return false;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_pm.c b/plat/st/stm32mp2/stm32mp2_pm.c
new file mode 100644
index 0000000000..59741da1c2
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_pm.c
@@ -0,0 +1,1135 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <bl31/interrupt_mgmt.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/arm/gic_common.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/clk.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/st/bsec3_reg.h>
+#include <drivers/st/stm32mp_clkfunc.h>
+#include <drivers/st/stm32mp_reset.h>
+#include <drivers/st/stm32mp2_ddr_helpers.h>
+#include <lib/mmio.h>
+#include <lib/psci/psci.h>
+#include <lib/spinlock.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32mp2_context.h>
+
+/* Default value for STM32MP25 with STPMIC25, defined in AN5727 */
+#define DEFAULT_POPL_D1		3U
+#define DEFAULT_PODH_D2		1U
+#define DEFAULT_POPL_D2		2U
+#define DEFAULT_LPCFG_D2	1U		/* PWR_ON=0 for Standby1/2 = PMIC_PWRCTRL1 */
+#define DEFAULT_LPLVDLY_D2	0U		/* 6xLSI cycle = 187 us */
+#define DEFAULT_LPSTOP1DLY	100U		/* LP-Stop1 PWRLP_DLY to wait VTT */
+
+#define CA35SS_SYSCFG_VBAR_CR	0x2084U
+
+#define RAMCFG_RETRAMCR		0x180U
+#define SRAMHWERDIS		BIT(12)
+
+/* GIC interrupt number */
+#define RCC_WAKEUP_IRQn		254
+
+/* Value with 64 MHz HSI period */
+#define PWRLPDLYCR_VAL(delay_us, lsmcu)	((64U * (delay_us)) / (1U + (lsmcu)))
+
+#define STATE_START	U(0)
+#define STATE_RUNNING	U(1)
+#define STATE_DDR	U(2)
+#define STATE_NB	U(3)
+
+/*
+ * Struct for synchronization between the cores, protected by stm32mp_state_lock
+ * to protect simultaneous acces, 3 states:
+ * - START: start is requested on the current core (hotplug/not in reset)
+ * - RUNNING: currently running (not in WFI loop)
+ * - DDR: the DDR is not in self refresh, usable after WFI loop exit
+ *        used for handshake for standby exit / supend entry
+ *        only configured for STM32MP_PRIMARY_CPU
+ * The element of the array is cache-line aligned to allow cache maintenance
+ */
+static struct stm32_psci_percpu_data {
+	bool state[STATE_NB];
+} __aligned(CACHE_WRITEBACK_GRANULE) stm32_percpu_data[PLATFORM_CORE_COUNT];
+
+static spinlock_t stm32mp_state_lock;
+
+uintptr_t stm32_sec_entrypoint;
+
+static u_register_t saved_scr_el3;
+
+static uint32_t lpstop1_pwrlpdly;
+static uint32_t stop2_pwrlpdly;
+
+/* Support PSCI v1.0 Extended State-ID with the recommended encoding */
+#define LVL_CORE		U(0)
+#define LVL_D1			U(1)
+#define LVL_D1_LPLV		U(2)
+#define LVL_D2			U(3)
+#define LVL_D2_LPLV		U(4)
+
+#define stm32_make_pwrstate(lvl4, lvl3, lvl2, lvl1, lvl0, type) \
+	(((STM32MP_LOCAL_STATE_ ## lvl4) << (PLAT_LOCAL_PSTATE_WIDTH * 4)) | \
+	 ((STM32MP_LOCAL_STATE_ ## lvl3) << (PLAT_LOCAL_PSTATE_WIDTH * 3)) | \
+	 ((STM32MP_LOCAL_STATE_ ## lvl2) << (PLAT_LOCAL_PSTATE_WIDTH * 2)) | \
+	 ((STM32MP_LOCAL_STATE_ ## lvl1) << (PLAT_LOCAL_PSTATE_WIDTH * 1)) | \
+	 ((STM32MP_LOCAL_STATE_ ## lvl0) << (PLAT_LOCAL_PSTATE_WIDTH * 0)) | \
+	 ((type) << PSTATE_TYPE_SHIFT))
+
+#define stm32_get_stateid_lvl(pwr_domain_state, lvl) \
+	(pwr_domain_state[(lvl)] << (PLAT_LOCAL_PSTATE_WIDTH * (lvl)))
+
+#define stm32_get_stateid(pwr_domain_state) \
+	(stm32_get_stateid_lvl(pwr_domain_state, LVL_CORE) | \
+	 stm32_get_stateid_lvl(pwr_domain_state, LVL_D1) | \
+	 stm32_get_stateid_lvl(pwr_domain_state, LVL_D1_LPLV) | \
+	 stm32_get_stateid_lvl(pwr_domain_state, LVL_D2) | \
+	 stm32_get_stateid_lvl(pwr_domain_state, LVL_D2_LPLV) | \
+	 ((pwr_domain_state[LVL_D1_LPLV] == STM32MP_LOCAL_STATE_OFF ? PSTATE_TYPE_POWERDOWN : 0) \
+		<< PSTATE_TYPE_SHIFT))
+
+/* State-id - 0x00000001 */
+#define PWRSTATE_RUN \
+	stm32_make_pwrstate(RUN, RUN, RUN, RUN, RET, PSTATE_TYPE_STANDBY)
+
+/* State-id - 0x00000011 Stop1 */
+#define PWRSTATE_STOP1 \
+	stm32_make_pwrstate(RUN, RUN, RUN, RET, RET, PSTATE_TYPE_STANDBY)
+
+/* State-id - 0x00000021 LP-Stop1*/
+#define PWRSTATE_LP_STOP1 \
+	stm32_make_pwrstate(RUN, RUN, RUN, LP, RET, PSTATE_TYPE_STANDBY)
+
+/* State-id - 0x00000211 LPLV-Stop1*/
+#define PWRSTATE_LPLV_STOP1 \
+	stm32_make_pwrstate(RUN, RUN, LP, RET, RET, PSTATE_TYPE_STANDBY)
+
+/* State-id - 0x40001333 Stop2 */
+#define PWRSTATE_STOP2 \
+	stm32_make_pwrstate(RUN, RET, OFF, OFF, OFF, PSTATE_TYPE_POWERDOWN)
+
+/* State-id - 0x40002333 LP-Stop2*/
+#define PWRSTATE_LP_STOP2 \
+	stm32_make_pwrstate(RUN, LP, OFF, OFF, OFF, PSTATE_TYPE_POWERDOWN)
+
+/* State-id - 0x40023333 LPLV-Stop2*/
+#define PWRSTATE_LPLV_STOP2 \
+	stm32_make_pwrstate(LP, OFF, OFF, OFF, OFF, PSTATE_TYPE_POWERDOWN)
+
+/* State-id - 0x40033333 Standby */
+#define PWRSTATE_STANDBY \
+	stm32_make_pwrstate(OFF, OFF, OFF, OFF, OFF, PSTATE_TYPE_POWERDOWN)
+
+/*
+ *  The table storing the valid idle power states. Ensure that the
+ *  array entries are populated in ascending order of state-id to
+ *  enable us to use binary search during power state validation.
+ *  The table must be terminated by a NULL entry.
+ */
+static const unsigned int stm32mp_pm_idle_states[] = {
+	PWRSTATE_RUN,
+	PWRSTATE_STOP1,
+	PWRSTATE_LP_STOP1,
+	PWRSTATE_LPLV_STOP1,
+	PWRSTATE_STOP2,
+	PWRSTATE_LP_STOP2,
+	PWRSTATE_LPLV_STOP2,
+	0U, /* sentinel */
+};
+
+#define PM_IDLE_STATES_SIZE ARRAY_SIZE(stm32mp_pm_idle_states)
+
+/* The supported low power mode on the board, including STANDBY */
+static unsigned int stm32mp_supported_pwr_states[PM_IDLE_STATES_SIZE + 1U];
+
+extern void stm32_stop2_entrypoint(void);
+
+static bool stm32mp_state_check(unsigned int core_id, unsigned int state_id)
+{
+	bool val;
+	bool spin_lock_available = stm32mp_lock_available();
+
+	if (spin_lock_available) {
+		spin_lock(&stm32mp_state_lock);
+	}
+	val = stm32_percpu_data[core_id].state[state_id];
+	if (spin_lock_available) {
+		spin_unlock(&stm32mp_state_lock);
+	}
+
+	return val;
+}
+
+static void stm32mp_state_set(unsigned int core_id, unsigned int state_id, bool state)
+{
+	bool spin_lock_available = stm32mp_lock_available();
+
+	if (spin_lock_available) {
+		spin_lock(&stm32mp_state_lock);
+	}
+	stm32_percpu_data[core_id].state[state_id] = state;
+	flush_dcache_range((uintptr_t)&stm32_percpu_data[core_id], sizeof(stm32_percpu_data[0]));
+	if (spin_lock_available) {
+		spin_unlock(&stm32mp_state_lock);
+	}
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a CPU is about to enter standby.
+ ******************************************************************************/
+static void stm32_cpu_standby(plat_local_state_t cpu_state)
+{
+	u_register_t scr = read_scr_el3();
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+
+	assert(cpu_state == STM32MP_LOCAL_STATE_RET);
+
+	stm32mp_state_set(core_id, STATE_RUNNING, false);
+
+	/* Enable the Non-secure interrupt to wake the CPU. */
+	write_scr_el3(scr | SCR_IRQ_BIT | SCR_FIQ_BIT);
+	isb();
+	/*
+	 * Enter standby state.
+	 * dsb is good practice before using wfi to enter low power states.
+	 */
+	dsb();
+	wfi();
+
+	write_scr_el3(scr);
+
+	/* Coordinate the cores to prevent DDR access in self refresh */
+	stm32mp_state_set(core_id, STATE_RUNNING, true);
+
+	/* Force wake-up of other core, waiting in WFI */
+	plat_ic_set_interrupt_pending(RCC_WAKEUP_IRQn);
+
+	/* Handshake to wait DDR */
+	while (!stm32mp_state_check(STM32MP_PRIMARY_CPU, STATE_DDR)) {
+		wfe();
+	}
+
+	/* DDR is available, the other core is running */
+	plat_ic_clear_interrupt_pending(RCC_WAKEUP_IRQn);
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a power domain is about to be turned on. The
+ * mpidr determines the CPU to be turned on.
+ * Called by core 0 to activate core 1.
+ ******************************************************************************/
+static int stm32_pwr_domain_on(u_register_t mpidr)
+{
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+
+	if (stm32mp_is_single_core()) {
+		return PSCI_E_NOT_SUPPORTED;
+	}
+
+	stm32mp_state_set(core_id, STATE_START, true);
+
+	if (core_id == STM32MP_PRIMARY_CPU) {
+		/* Cortex-A35 core0 can't be turned OFF, emulate it with a WFE loop */
+		VERBOSE("BL31: Releasing core0 from wait loop...\n");
+		dsb();
+		isb();
+		sev();
+	} else {
+		/* Reset the secondary core */
+		mmio_write_32(RCC_BASE + RCC_C1P1RSTCSETR, RCC_C1P1RSTCSETR_C1P1PORRST);
+	}
+
+	return PSCI_E_SUCCESS;
+}
+
+static void stm32_pwr_domain_off(const psci_power_state_t *target_state)
+{
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+
+	/* Prevent interrupts from spuriously waking up this cpu */
+	stm32mp_gic_cpuif_disable();
+
+	/* Force state to OFF to allow synchronization */
+	stm32mp_state_set(core_id, STATE_START, false);
+}
+
+static void stm32mp2_setup_rcc_wakeup_irq(uintptr_t rcc_base)
+{
+	plat_ic_set_interrupt_type(RCC_WAKEUP_IRQn, INTR_TYPE_S_EL1);
+	plat_ic_set_interrupt_priority(RCC_WAKEUP_IRQn, GIC_HIGHEST_SEC_PRIORITY);
+}
+
+static void stm32mp2_enable_rcc_wakeup_irq(uintptr_t rcc_base)
+{
+	plat_ic_set_spi_routing(RCC_WAKEUP_IRQn, INTR_ROUTING_MODE_ANY, 0x0U);
+	/* Enable RCC Wake-up interrupt, */
+	mmio_setbits_32(rcc_base + RCC_C1CIESETR, RCC_C1CIESETR_WKUPIE);
+	plat_ic_enable_interrupt(RCC_WAKEUP_IRQn);
+}
+
+static void stm32mp2_disable_rcc_wakeup_irq(uintptr_t rcc_base)
+{
+	plat_ic_disable_interrupt(RCC_WAKEUP_IRQn);
+
+	/* Clear wakeup flag */
+	mmio_setbits_32(rcc_base + RCC_C1CIFCLRR, RCC_C1CIFCLRR_WKUPF);
+
+	/* Disable RCC Wake-up interrupt */
+	mmio_clrbits_32(rcc_base + RCC_C1CIESETR, RCC_C1CIESETR_WKUPIE);
+}
+
+/*
+ * Core synchronization to protect DDR access for running cores
+ * Handshake by using the state 'DDR' and 'RUNNING' to safely block
+ * the exit of stm32_cpu_standby() for other core,
+ * The 'DDR' flag is used only on STM32MP_PRIMARY_CPU core
+ *  = true when DDR is accessble for any cores
+ *  = false when 'core_id' try to set the DDR in self refresh mode
+ * This function return true if other core is blocked in stm32_cpu_standby()
+ */
+static bool stm32_freeze_other_core(unsigned int core_id)
+{
+	bool result = true;
+	unsigned int id;
+
+	/* Forbid access on DDR in stm32_cpu_standby() */
+	stm32mp_state_set(STM32MP_PRIMARY_CPU, STATE_DDR, false);
+
+	/*
+	 * Check if the other core is not started or running:
+	 * no more in WFI loop in stm32_cpu_standby() after interuption
+	 */
+	for (id = 0U; id < PLATFORM_CORE_COUNT; id++) {
+		if (id == core_id) {
+			continue;
+		}
+		if (stm32mp_state_check(id, STATE_START) &&
+		    stm32mp_state_check(id, STATE_RUNNING)) {
+			result = false;
+			break;
+		}
+	}
+	if (!result) {
+		/* Unblock the other core in stm32_cpu_standby() on error */
+		stm32mp_state_set(STM32MP_PRIMARY_CPU, STATE_DDR, true);
+		sev();
+	}
+
+	return result;
+}
+
+static int stm32_pwr_domain_validate_suspend(const psci_power_state_t *target_state)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uint32_t stateid = stm32_get_stateid(target_state->pwr_domain_state);
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+
+	/* If retention only at D1 level return as nothing is to be done */
+	if (stateid == PWRSTATE_RUN) {
+		return PSCI_E_SUCCESS;
+	}
+
+	/* If CPU2 is not in reset: low power mode is not supported by CPU1 */
+	if ((mmio_read_32(pwr_base + PWR_CPU2D2SR) & PWR_CPU2D2SR_CSTATE_MASK) != 0U) {
+		WARN("PSCI power domain supend request with Cortex M33 running.\n");
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	if (!stm32_freeze_other_core(core_id)) {
+		return PSCI_E_DENIED;
+	}
+
+	return PSCI_E_SUCCESS;
+}
+
+/* Display Stop2 or Standby1 modes, when console is available */
+static void print_mode_info(const char *mode)
+{
+	INFO("Entering %s low power mode\n", mode);
+}
+
+/* Display Stop1 modes, at verbose level to avoid this trace with CPUIdle */
+static void print_mode_verbose(const char *mode)
+{
+	VERBOSE("Entering %s low power mode\n", mode);
+}
+
+static void stm32_pwr_domain_suspend(const psci_power_state_t *target_state)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	bool standby = false;
+	uint32_t stateid = stm32_get_stateid(target_state->pwr_domain_state);
+
+	/* If retention only at D1 level return as nothing is to be done */
+	if (stateid == PWRSTATE_RUN) {
+		return;
+	}
+
+	/* Request STOP for both cores */
+	mmio_write_32(rcc_base + RCC_C1SREQSETR, RCC_C1SREQSETR_STPREQ_MASK);
+
+	/*
+	 * No PWR_LP delay by default, because VTT_DRR is not stopped (for Stop1)
+	 * or VTT ramp-up delay is masked by VDD CPU delay (for other modes except LP-Stop1).
+	 * It is required only for LP-Stop1 mode for design with STPMIC25.
+	 */
+	mmio_write_32(rcc_base + RCC_PWRLPDLYCR, 0U);
+
+	/* Switch to Software Self-Refresh mode */
+	if (stateid == PWRSTATE_STANDBY) {
+		standby = true;
+	}
+
+	dcsw_op_all(DCCISW);
+	ddr_save_sr_mode();
+	ddr_set_sr_mode(DDR_SSR_MODE);
+	if (ddr_sr_entry(standby) != 0) {
+		panic();
+	}
+
+	/* Disable DDRSHR to avoid STANDBY/STOP exit issue */
+	mmio_clrbits_32(rcc_base + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRSHR);
+
+	/* Perform the PWR configuration for the requested mode */
+	switch (stateid) {
+	case PWRSTATE_STOP1:
+		print_mode_verbose("Stop1");
+		mmio_write_32(pwr_base + PWR_CPU1CR, 0U);
+		mmio_write_32(pwr_base + PWR_CPU2CR, 0U);
+		stm32mp2_enable_rcc_wakeup_irq(rcc_base);
+		break;
+
+	case PWRSTATE_LP_STOP1:
+		print_mode_verbose("LP_Stop1");
+		mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_LPDS_D1);
+		mmio_write_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_LPDS_D2);
+		/* Wait VTT ramp-up delay for LP-Stop1 */
+		mmio_write_32(rcc_base + RCC_PWRLPDLYCR, lpstop1_pwrlpdly);
+		stm32mp2_enable_rcc_wakeup_irq(rcc_base);
+		break;
+
+	case PWRSTATE_LPLV_STOP1:
+		print_mode_verbose("LPLV_Stop1");
+		mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_LPDS_D1 | PWR_CPU1CR_LVDS_D1);
+		mmio_write_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_LPDS_D2 | PWR_CPU2CR_LVDS_D2);
+		stm32mp2_enable_rcc_wakeup_irq(rcc_base);
+		break;
+
+	case PWRSTATE_STOP2:
+		print_mode_info("Stop2");
+		mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_PDDS_D1);
+		mmio_write_32(pwr_base + PWR_CPU2CR, 0U);
+		mmio_write_32(rcc_base + RCC_PWRLPDLYCR, stop2_pwrlpdly);
+		stm32mp_gic_cpuif_disable();
+		stm32mp_gic_save();
+		stm32mp2_pll1_disable();
+		break;
+
+	case PWRSTATE_LP_STOP2:
+		print_mode_info("LP_Stop2");
+		mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_PDDS_D1);
+		mmio_write_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_LPDS_D2);
+		mmio_write_32(rcc_base + RCC_PWRLPDLYCR, stop2_pwrlpdly);
+		stm32mp_gic_cpuif_disable();
+		stm32mp_gic_save();
+		stm32mp2_pll1_disable();
+		break;
+
+	case PWRSTATE_LPLV_STOP2:
+		print_mode_info("LPLV_Stop2");
+		mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_PDDS_D1);
+		mmio_write_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_LPDS_D2 | PWR_CPU2CR_LVDS_D2);
+		mmio_write_32(rcc_base + RCC_PWRLPDLYCR, stop2_pwrlpdly);
+		stm32mp_gic_cpuif_disable();
+		stm32mp_gic_save();
+		stm32mp2_pll1_disable();
+		break;
+
+	case PWRSTATE_STANDBY:
+		print_mode_info("Standby1");
+		mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_PDDS_D1 | PWR_CPU1CR_PDDS_D2);
+		mmio_write_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_PDDS_D2);
+
+		stm32mp_gic_cpuif_disable();
+		stm32mp2_pll1_disable();
+		break;
+
+	default:
+		panic();
+		break;
+	}
+
+	/* Clear previous status */
+	mmio_setbits_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_CSSF);
+	mmio_setbits_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_CSSF);
+	mmio_setbits_32(pwr_base + PWR_CPU3CR, PWR_CPU3CR_CSSF);
+
+	/* Enable the Non-secure interrupt to wake up the CPU with WFI for pending interrupt */
+	saved_scr_el3 = read_scr_el3();
+	write_scr_el3(saved_scr_el3 | SCR_IRQ_BIT | SCR_FIQ_BIT);
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a power domain has just been powered on after
+ * being turned off earlier. The target_state encodes the low power state that
+ * each level has woken up from.
+ * Called by core 1 just after wake up.
+ ******************************************************************************/
+static void stm32_pwr_domain_on_finish(const psci_power_state_t *target_state)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+
+	stm32mp_state_set(core_id, STATE_RUNNING, true);
+	if (core_id == STM32MP_PRIMARY_CPU) {
+		dsb();
+		isb();
+	} else {
+		/* Restore generic timer after reset */
+		stm32mp_stgen_restore_rate();
+	}
+
+	stm32mp2_disable_rcc_wakeup_irq(rcc_base);
+
+	stm32mp_gic_pcpu_init();
+	stm32mp_gic_cpuif_enable();
+
+	mmio_write_32(rcc_base + RCC_C1SREQCLRR, RCC_C1SREQCLRR_STPREQ_MASK);
+}
+
+/*******************************************************************************
+ * STM32MP2 handler called when a power domain has just been powered on after
+ * having been suspended earlier. The target_state encodes the low power state
+ * that each level has woken up from.
+ ******************************************************************************/
+static void stm32_pwr_domain_suspend_finish(const psci_power_state_t
+					    *target_state)
+{
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+	uint32_t stateid = stm32_get_stateid(target_state->pwr_domain_state);
+
+	stm32mp_state_set(core_id, STATE_RUNNING, true);
+
+	stm32mp2_disable_rcc_wakeup_irq(rcc_base);
+
+	mmio_write_32(rcc_base + RCC_C1SREQCLRR, RCC_C1SREQCLRR_STPREQ_MASK);
+
+	/* Restore DDRSHR after STANDBY/STOP exit issue */
+	mmio_setbits_32(rcc_base + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRSHR);
+
+	/* Perform the common system specific operations */
+	switch (stateid) {
+	case PWRSTATE_STANDBY:
+		VERBOSE("STANDBY exit\n");
+		/* Restore the DDR self refresh mode */
+		ddr_restore_sr_mode();
+		break;
+	case PWRSTATE_STOP2:
+	case PWRSTATE_LP_STOP2:
+	case PWRSTATE_LPLV_STOP2:
+		VERBOSE("STOP2 exit\n");
+		/* Restore STGEN and generic timer with current clock */
+		stm32mp_stgen_config(clk_get_rate(CK_KER_STGEN));
+
+		/* Exit DDR self refresh mode after STOP mode */
+		ddr_sr_exit();
+		ddr_restore_sr_mode();
+
+		stm32mp_gic_resume();
+		stm32mp_gic_cpuif_enable();
+
+		/* Restore register in CA35SS */
+		mmio_write_32(A35SSC_BASE + CA35SS_SYSCFG_VBAR_CR, stm32_sec_entrypoint);
+
+		/* Start the secondary core if it was running before STOP */
+		if ((core_id == STM32MP_PRIMARY_CPU) &&
+		    stm32mp_state_check(STM32MP_SECONDARY_CPU, STATE_START)) {
+			/* Reset the secondary core to execute warm boot */
+			mmio_write_32(RCC_BASE + RCC_C1P1RSTCSETR, RCC_C1P1RSTCSETR_C1P1PORRST);
+		}
+		break;
+	case PWRSTATE_STOP1:
+	case PWRSTATE_LP_STOP1:
+	case PWRSTATE_LPLV_STOP1:
+		VERBOSE("STOP1 exit\n");
+		/* Exit DDR self refresh mode after STOP mode */
+		ddr_sr_exit();
+		ddr_restore_sr_mode();
+		stm32mp2_disable_rcc_wakeup_irq(rcc_base);
+		break;
+	default:
+		ERROR("Invalid state id %x\n", stateid);
+		panic();
+		break;
+	}
+
+	/* Restore SCR */
+	write_scr_el3(saved_scr_el3);
+
+	/* Core synchronization to protect DDR access */
+	stm32mp_state_set(STM32MP_PRIMARY_CPU, STATE_DDR, true);
+	/* Unblock the other core in CPU standby loop */
+	sev();
+}
+
+static void __dead2 stm32_pwr_domain_pwr_down_wfi(const psci_power_state_t
+						  *target_state)
+{
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+
+	/* Core is no more running (stopped or suspended) */
+	stm32mp_state_set(core_id, STATE_RUNNING, false);
+
+	/* The first power down on core 0, core 1 is running */
+	if ((core_id == STM32MP_PRIMARY_CPU) &&
+	    !stm32mp_state_check(STM32MP_PRIMARY_CPU, STATE_START)) {
+		uintptr_t sec_entrypoint;
+
+		/* Core 0 can't be turned OFF, emulate it with a WFE loop */
+		VERBOSE("BL31: core0 entering wait loop...\n");
+		while (!stm32mp_state_check(STM32MP_PRIMARY_CPU, STATE_START)) {
+			wfe();
+		}
+
+		VERBOSE("BL31: core0 resumed.\n");
+		dsbsy();
+		sec_entrypoint = mmio_read_32(A35SSC_BASE + CA35SS_SYSCFG_VBAR_CR);
+		/* Jump manually to entry point, with mmu disabled. */
+		disable_mmu_el3();
+		((void(*)(void))sec_entrypoint)();
+
+		/* This shouldn't be reached */
+		panic();
+	}
+
+	if (psci_is_last_on_cpu_safe() &&
+	    stm32_get_stateid(target_state->pwr_domain_state) == PWRSTATE_STANDBY) {
+		/* Save the context when all the core are requested to stop */
+		stm32_pm_context_save(target_state);
+	}
+
+	/*
+	 * Synchronize on memory accesses and instruction flow before
+	 * auto-reset from the WFI instruction.
+	 */
+	dsb();
+	isb();
+	wfi();
+
+	/* This shouldn't be reached */
+	panic();
+}
+
+static void __dead2 stm32_system_off(void)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	u_register_t mpidr = read_mpidr();
+	unsigned int core_id = MPIDR_AFFLVL0_VAL(mpidr);
+	uintptr_t exti2_base = STM32MP_EXTI2_BASE;
+	uint32_t otp_idx = 0U;
+	uint32_t otp_value = 0U;
+
+	if (core_id != STM32MP_PRIMARY_CPU) {
+		ERROR("PSCI system off request on core %u\n", core_id);
+		panic();
+	}
+
+	if (!stm32_freeze_other_core(core_id)) {
+		WARN("PSCI system off with other core running.\n");
+
+		/* Core is no more running */
+		stm32mp_state_set(STM32MP_SECONDARY_CPU, STATE_RUNNING, false);
+
+		/* Program secondary CPU entry points */
+		mmio_write_32(A35SSC_BASE + CA35SS_SYSCFG_VBAR_CR,
+			      (uintptr_t)&stm32_stop2_entrypoint);
+
+		/* After reset, the core is stopped, waiting in WFI loop */
+		stm32mp_state_set(STM32MP_SECONDARY_CPU, STATE_START, false);
+
+		/* Reset the secondary core */
+		mmio_write_32(RCC_BASE + RCC_C1P1RSTCSETR, RCC_C1P1RSTCSETR_C1P1PORRST);
+
+		/* Forbid access to DDR */
+		stm32mp_state_set(STM32MP_PRIMARY_CPU, STATE_DDR, false);
+	}
+
+	/* If CPU2 is not in reset */
+	if ((mmio_read_32(pwr_base + PWR_CPU2D2SR) & PWR_CPU2D2SR_CSTATE_MASK) != 0U) {
+		WARN("PSCI system off with Cortex M33 running.\n");
+		/* Force Hold Boot and reset of CPU2 = Cortex M33 */
+		mmio_clrbits_32(rcc_base + RCC_CPUBOOTCR, RCC_CPUBOOTCR_BOOT_CPU2);
+		mmio_setbits_32(rcc_base + RCC_C2RSTCSETR, RCC_C2RSTCSETR_C2RST);
+	}
+
+	/* If CPU3 is not in reset */
+	if ((mmio_read_32(pwr_base + PWR_CPU3D3SR) & PWR_CPU3D3SR_CSTATE_MASK) != 0U) {
+		WARN("PSCI system off with Cortex M0 running.\n");
+		/* Force reset of CPU3 = Cortex M0+ */
+		mmio_setbits_32(rcc_base + RCC_C3CFGR, RCC_C3CFGR_C3RST);
+	}
+
+	/* Freeze all watchdog with shadow value of HCONF1 */
+	if (stm32_get_otp_index(HCONF1_OTP, &otp_idx, NULL) == 0U) {
+		if (stm32_get_otp_value_from_idx(otp_idx, &otp_value) == 0U) {
+			otp_value |= HCONF1_OTP_IWDG_FZ_STANDBY_MASK(0);
+			otp_value |= HCONF1_OTP_IWDG_FZ_STANDBY_MASK(1);
+			otp_value |= HCONF1_OTP_IWDG_FZ_STANDBY_MASK(2);
+			otp_value |= HCONF1_OTP_IWDG_FZ_STANDBY_MASK(3);
+			stm32_otp_write(otp_value, otp_idx);
+		}
+	}
+
+	/* Force DDR off */
+	ddr_sub_system_clk_off();
+
+	/* Prevent interrupts from spuriously waking up this cpu */
+	stm32mp_gic_cpuif_disable();
+
+	/* Request STOP for both cores */
+	mmio_write_32(rcc_base + RCC_C1SREQSETR, RCC_C1SREQSETR_STPREQ_MASK);
+
+	/* Request standby2 */
+	mmio_write_32(pwr_base + PWR_CPU1CR, PWR_CPU1CR_PDDS_D1 | PWR_CPU1CR_PDDS_D2);
+	mmio_write_32(pwr_base + PWR_CPU2CR, PWR_CPU2CR_PDDS_D2);
+	mmio_write_32(pwr_base + PWR_D3CR, PWR_D3CR_PDDS_D3);
+	stm32mp2_pll1_disable();
+
+	/* Do not maintain RETRAM memory content in Standby or Vbat */
+	mmio_write_32(pwr_base + PWR_CR10, PWR_CR10_RETRBSEN_DISABLE);
+
+	/* Clear PM context in BKPSRAM: cold boot at next wake-up */
+	stm32_pm_context_clear();
+
+	/* Deactivate all WakeUp except WKUP pins */
+	mmio_write_32(exti2_base + EXTI2_C1IMR1, 0U);
+	mmio_write_32(exti2_base + EXTI2_C1IMR2, 0U);
+	mmio_write_32(exti2_base + EXTI2_C1IMR3, 0U);
+	mmio_write_32(exti2_base + EXTI2_C2IMR1, 0U);
+	mmio_write_32(exti2_base + EXTI2_C2IMR2, 0U);
+	mmio_write_32(exti2_base + EXTI2_C2IMR3, 0U);
+	mmio_write_32(exti2_base + EXTI2_C3IMR1, 0U);
+	mmio_write_32(exti2_base + EXTI2_C3IMR2, 0U);
+	mmio_write_32(exti2_base + EXTI2_C3IMR3, 0U);
+
+	/* Disable STATE_RUNNING state for this core */
+	stm32mp_state_set(core_id, STATE_RUNNING, false);
+
+	VERBOSE("BL31: power off\n");
+
+	dsb();
+	isb();
+	wfi();
+
+	/* This shouldn't be reached */
+	panic();
+}
+
+static void __dead2 stm32_system_reset(void)
+{
+	stm32mp_system_reset();
+}
+
+/**
+ * stm32_validate_power_state() - This function ensures that the power state
+ * parameter in request is valid.
+ *
+ * @power_state		Power state of core
+ * @req_state		Requested state
+ *
+ * @return	Returns status, either success or reason
+ */
+static int stm32_validate_power_state(unsigned int power_state,
+				      psci_power_state_t *req_state)
+{
+	unsigned int state_id;
+	unsigned int i;
+
+	assert(req_state != NULL);
+
+	/*
+	 *  Currently we are using a linear search for finding the matching
+	 *  entry in the idle power state array. This can be made a binary
+	 *  search if the number of entries justify the additional complexity.
+	 */
+	for (i = 0U; stm32mp_pm_idle_states[i] != 0U; i++) {
+		if (power_state == stm32mp_pm_idle_states[i]) {
+			break;
+		}
+	}
+
+	/* Return error if entry not found in the idle state array */
+	if (stm32mp_pm_idle_states[i] == 0U) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	/* Search if board restrict the number of supported modes */
+	for (i = 0U; stm32mp_supported_pwr_states[i] != 0U; i++) {
+		if (power_state == stm32mp_supported_pwr_states[i]) {
+			break;
+		}
+	}
+	if (stm32mp_supported_pwr_states[i] == 0U) {
+		ERROR("PSCI power state not supported %x\n", power_state);
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	i = 0U;
+	state_id = psci_get_pstate_id(power_state);
+
+	/* Parse the State ID and populate the state info parameter */
+	while (state_id != 0U) {
+		req_state->pwr_domain_state[i++] = state_id & PLAT_LOCAL_PSTATE_MASK;
+		state_id >>= PLAT_LOCAL_PSTATE_WIDTH;
+	}
+
+	/*
+	 * With PSCI v1.0 Extended State-ID, 'last at pwrlvl' is not directly available
+	 * and with current toplogy only the CPU level is checked for coordination
+	 */
+	req_state->last_at_pwrlvl = LVL_CORE;
+
+	return PSCI_E_SUCCESS;
+}
+
+static int stm32_validate_ns_entrypoint(uintptr_t entrypoint)
+{
+	/* The non-secure entry point must be in DDR */
+	if (entrypoint < STM32MP_DDR_BASE) {
+		return PSCI_E_INVALID_ADDRESS;
+	}
+
+	return PSCI_E_SUCCESS;
+}
+
+/*
+ * The PSCI code uses this API to let the platform participate in state
+ * coordination during a power management operation. It compares the platform
+ * specific local power states requested by each cpu for a given power domain
+ * and returns the coordinated target power state that the domain should
+ * enter.
+ * This implementation assumes that the power state is RUN for simple
+ * CPU STANDBY called by fast path in psci_cpu_suspend(), and assumes that the
+ * power state are ordered in increasing depth of the power.
+ * As a result, the  coordinated target local power state for a power domain
+ * will be the minimum of the requested local power states wich is NOT RUN.
+ * And it return a invalid state ()= OFF_STATE + 1) when state is RUN for all
+ * the cpu.
+ */
+plat_local_state_t plat_get_target_pwr_state(unsigned int lvl,
+					     const plat_local_state_t *states,
+					     unsigned int ncpu)
+{
+	plat_local_state_t target = PLAT_MAX_OFF_STATE + 1U, temp;
+	const plat_local_state_t *st = states;
+	unsigned int n = ncpu;
+
+	assert(ncpu > 0U);
+
+	do {
+		temp = *st;
+		st++;
+		if ((temp < target) && (temp != STM32MP_LOCAL_STATE_RUN)) {
+			target = temp;
+		}
+		n--;
+	} while (n > 0U);
+
+	return target;
+}
+
+/**
+ * stm32_get_sys_suspend_power_state() -  Get power state for system suspend
+ *
+ * @req_state	Requested state
+ */
+static void stm32_get_sys_suspend_power_state(psci_power_state_t *req_state)
+{
+	unsigned int state_id;
+	unsigned int pwr_state, max_pwr_state = PWRSTATE_STANDBY;
+	unsigned int i;
+	uintptr_t exti_base = STM32MP_EXTI1_BASE;
+	uint32_t c1imr1 = mmio_read_32(exti_base + EXTI1_C1IMR1);
+	uint32_t c1imr2 = mmio_read_32(exti_base + EXTI1_C1IMR2);
+	uint32_t c1imr3 = mmio_read_32(exti_base + EXTI1_C1IMR3);
+
+	/* Verify the max level supported according to the activated EXTI1 */
+	if ((c1imr1 & (EXTI1_C1IMR1_PVD | EXTI1_C1IMR1_PVM)) != 0U) {
+		max_pwr_state = PWRSTATE_LPLV_STOP2;
+		VERBOSE("%s: max_pwr_state = PWRSTATE_LPLV_STOP2 C1IMR1=%x\n", __func__, c1imr1);
+	}
+
+	/* Wake-up pin are connected directly to PWR */
+	if (((c1imr1 & ~(EXTI1_C1IMR1_PVD | EXTI1_C1IMR1_PVM)) != 0U) ||
+	    ((c1imr2 & ~EXTI1_C1IMR2_WKUP_MASK) != 0U) || (c1imr3 != 0U)) {
+		max_pwr_state = PWRSTATE_LP_STOP2;
+		VERBOSE("%s: max_pwr_state = PWRSTATE_LP_STOP2, C1IMR1=%x, C1IMR2=%x, C1IMR3=%x\n",
+			__func__, c1imr1, c1imr2, c1imr3);
+	}
+
+	/* Search the max supported POWERDOWN modes  <= max_pwr_state */
+	for (i = ARRAY_SIZE(stm32mp_supported_pwr_states) - 1U; i > 0U; i--) {
+		pwr_state = stm32mp_supported_pwr_states[i];
+		if ((pwr_state != 0U) && (pwr_state <= max_pwr_state) &&
+		    (psci_get_pstate_type(pwr_state) == PSTATE_TYPE_POWERDOWN)) {
+			break;
+		}
+	}
+	state_id = psci_get_pstate_id(pwr_state);
+
+	/* Parse the State ID and populate the state info parameter */
+	for (i = 0U; i <= PLAT_MAX_PWR_LVL; i++) {
+		req_state->pwr_domain_state[i] = state_id & PLAT_LOCAL_PSTATE_MASK;
+		state_id >>= PLAT_LOCAL_PSTATE_WIDTH;
+	}
+
+	/*
+	 * With PSCI v1.0 Extended State-ID, 'last at pwrlvl' is not directly available
+	 * and with current toplogy only the CPU level is checked for coordination
+	 */
+	req_state->last_at_pwrlvl = LVL_CORE;
+}
+
+/*******************************************************************************
+ * Export the platform handlers. The ARM Standard platform layer will take care
+ * of registering the handlers with PSCI.
+ ******************************************************************************/
+static const plat_psci_ops_t stm32_psci_ops = {
+	.cpu_standby = stm32_cpu_standby,
+	.pwr_domain_on = stm32_pwr_domain_on,
+	.pwr_domain_off = stm32_pwr_domain_off,
+	.pwr_domain_validate_suspend = stm32_pwr_domain_validate_suspend,
+	.pwr_domain_suspend = stm32_pwr_domain_suspend,
+	.pwr_domain_on_finish = stm32_pwr_domain_on_finish,
+	.pwr_domain_suspend_finish = stm32_pwr_domain_suspend_finish,
+	.pwr_domain_pwr_down_wfi = stm32_pwr_domain_pwr_down_wfi,
+	.system_off = stm32_system_off,
+	.system_reset = stm32_system_reset,
+	.validate_power_state = stm32_validate_power_state,
+	.validate_ns_entrypoint = stm32_validate_ns_entrypoint,
+	.get_sys_suspend_power_state = stm32_get_sys_suspend_power_state,
+};
+
+/*******************************************************************************
+ * This function retrieve the generic information from DT.
+ * Returns node on success and a negative FDT error code on failure.
+ ******************************************************************************/
+static int stm32_parse_domain_idle_state(void *fdt)
+{
+	unsigned int domain_idle_states[PM_IDLE_STATES_SIZE];
+	int node = 0;
+	int subnode = 0;
+	uint32_t power_state;
+	unsigned int i = 0U;
+	unsigned int j = 0U;
+	unsigned int nb_states = 0U;
+	int ret;
+
+	/* Search supported domain-idle-state in device tree */
+	node = fdt_path_offset(fdt, "/cpus/domain-idle-states");
+	if (node < 0) {
+		return node;
+	}
+
+	memset(domain_idle_states, 0, sizeof(domain_idle_states));
+	fdt_for_each_subnode(subnode, fdt, node) {
+		ret = fdt_read_uint32(fdt, subnode, "arm,psci-suspend-param", &power_state);
+		if (ret != 0) {
+			return ret;
+		}
+
+		/* Cross check with supported pm idle state in driver */
+		for (j = 0U; stm32mp_pm_idle_states[j] != 0U; j++) {
+			if (stm32mp_pm_idle_states[j] == power_state) {
+				break;
+			}
+		}
+		/* Return error if entry not found and not standby */
+		if ((stm32mp_pm_idle_states[j] == 0U) && (power_state != PWRSTATE_STANDBY)) {
+			return -EINVAL;
+		}
+
+		domain_idle_states[i++] = power_state;
+
+		/* Check array size */
+		if (i > ARRAY_SIZE(domain_idle_states)) {
+			return -E2BIG;
+		}
+	}
+
+	memset(stm32mp_supported_pwr_states, 0, sizeof(stm32mp_supported_pwr_states));
+
+	/* The CPU idle state is always supported, not present in domain node */
+	stm32mp_supported_pwr_states[nb_states++] = PWRSTATE_RUN;
+
+	/* Add each supported power state with same order than stm32mp_pm_idle_states */
+	for (j = 0U; stm32mp_pm_idle_states[j] != 0U; j++) {
+		for (i = 0U; domain_idle_states[i] != 0U && i < PM_IDLE_STATES_SIZE; i++) {
+			if (domain_idle_states[i] == stm32mp_pm_idle_states[j]) {
+				stm32mp_supported_pwr_states[nb_states++] = domain_idle_states[i];
+				break;
+			}
+		}
+	}
+
+	/* Add STANDBY at the end of the list if supported */
+	for (i = 0U; domain_idle_states[i] != 0U && i < PM_IDLE_STATES_SIZE; i++) {
+		if (domain_idle_states[i] == PWRSTATE_STANDBY) {
+			stm32mp_supported_pwr_states[nb_states++] = PWRSTATE_STANDBY;
+			break;
+		}
+	}
+
+	VERBOSE("stm32mp_supported_pwr_states[]=\n");
+	for (i = 0U; stm32mp_supported_pwr_states[i] != 0U; i++) {
+		VERBOSE("%u = %x\n", i, stm32mp_supported_pwr_states[i]);
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Initialize STM32MP2 for PM support: RCC, PWR
+ ******************************************************************************/
+struct pm_param {
+	uint8_t popl_d1;
+	uint8_t podh_d2;
+	uint8_t popl_d2;
+	uint8_t lplvdly_d2;
+	uint8_t lpcfg_d2;
+	uint32_t lpstop1dly;
+};
+
+static void stm32_read_dt_pm_param(void *fdt, struct pm_param *param)
+{
+	int node;
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_PWR_COMPAT);
+	if (node <= 0) {
+		panic();
+	}
+
+	param->popl_d1 = fdt_read_uint32_default(fdt, node, "st,popl-d1-ms", DEFAULT_POPL_D1);
+	param->podh_d2 = fdt_read_uint32_default(fdt, node, "st,podh-d2-ms", DEFAULT_PODH_D2);
+	param->popl_d2 = fdt_read_uint32_default(fdt, node, "st,popl-d2-ms", DEFAULT_POPL_D2);
+	param->lpcfg_d2 = fdt_read_uint32_default(fdt, node, "st,lpcfg-d2", DEFAULT_LPCFG_D2);
+	param->lplvdly_d2 = fdt_read_uint32_default(fdt, node, "st,lplvdly-d2", DEFAULT_LPLVDLY_D2);
+	param->lpstop1dly = fdt_read_uint32_default(fdt, node, "st,lpstop1dly-us",
+						    DEFAULT_LPSTOP1DLY);
+}
+
+static void stm32_pm_init(void *fdt)
+{
+	uintptr_t pwr_base = stm32mp_pwr_base();
+	uintptr_t rcc_base = stm32mp_rcc_base();
+	uint32_t lsmcu;
+	struct pm_param param;
+
+	stm32mp2_setup_rcc_wakeup_irq(rcc_base);
+
+	/* RCC init: DDR is shared by default */
+	mmio_setbits_32(rcc_base + RCC_DDRITFCFGR, RCC_DDRITFCFGR_DDRSHR);
+
+	/* Legacy mode: only CPU1 is allowed to boot, core1 is OFF */
+	mmio_setbits_32(rcc_base + RCC_LEGBOOTCR, RCC_LEGBOOTCR_LEGACY_BEN);
+
+	mmio_write_32(rcc_base + RCC_C1SREQCLRR, RCC_C1SREQSETR_STPREQ_MASK);
+
+	/* Maintain BKPSRAM & RETRAM content in Standby */
+	mmio_write_32(pwr_base + PWR_CR9, PWR_CR9_BKPRBSEN);
+	mmio_write_32(pwr_base + PWR_CR10, PWR_CR10_RETRBSEN_STANDBY);
+
+	/* Prevent RETRAM erase */
+	mmio_write_32(RAMCFG_BASE + RAMCFG_RETRAMCR, SRAMHWERDIS);
+
+	/* System standby not set (D3) */
+	mmio_write_32(pwr_base + PWR_D3CR, 0U);
+
+	/* Configure delay in PWR */
+	stm32_read_dt_pm_param(fdt, &param);
+
+	mmio_write_32(pwr_base + PWR_D1CR,
+		      (param.popl_d1 << PWR_D1CR_POPL_D1_SHIFT) & PWR_D1CR_POPL_D1_MASK);
+
+	mmio_write_32(pwr_base + PWR_D2CR,
+		      (param.lpcfg_d2 & PWR_D2CR_LPCFG_D2) |
+		      ((param.popl_d2  << PWR_D2CR_POPL_D2_SHIFT) & PWR_D2CR_POPL_D2_MASK) |
+		      ((param.lplvdly_d2 << PWR_D2CR_LPLVDLY_D2_SHIFT) & PWR_D2CR_LPLVDLY_D2_MASK) |
+		      ((param.podh_d2 << PWR_D2CR_PODH_D2_SHIFT) & PWR_D2CR_PODH_D2_MASK));
+
+	/* Compute RCC PWR LP DLY according to parent clock */
+	lsmcu = mmio_read_32(rcc_base + RCC_LSMCUDIVR) & RCC_LSMCUDIVR_LSMCUDIV;
+	lpstop1_pwrlpdly = PWRLPDLYCR_VAL(param.lpstop1dly, lsmcu);
+	/* Wait 2ms for Stop2 */
+	stop2_pwrlpdly = PWRLPDLYCR_VAL(2000, lsmcu);
+}
+
+/*******************************************************************************
+ * Export the platform specific power ops.
+ ******************************************************************************/
+int plat_setup_psci_ops(uintptr_t sec_entrypoint,
+			const plat_psci_ops_t **psci_ops)
+{
+	int ret = 0;
+	void *fdt = NULL;
+	uint32_t stop2_entrypoint = (uint32_t)(uintptr_t)&stm32_stop2_entrypoint;
+	struct nvmem_cell stop2_entrypoint_cell;
+	assert(stop2_entrypoint < UINT32_MAX);
+
+	if (fdt_get_address(&fdt) == 0) {
+		panic();
+	}
+
+	ret = stm32_parse_domain_idle_state(fdt);
+	if (ret != 0) {
+		ERROR("invalid domain-idle-states in device tree %d\n", ret);
+		panic();
+	}
+
+	/* Program secondary CPU entry points. */
+	stm32_sec_entrypoint = sec_entrypoint;
+	mmio_write_32(A35SSC_BASE + CA35SS_SYSCFG_VBAR_CR, stm32_sec_entrypoint);
+
+	/* Initialize the state per cpu */
+	stm32_percpu_data[STM32MP_PRIMARY_CPU].state[STATE_START] = true;
+	stm32_percpu_data[STM32MP_PRIMARY_CPU].state[STATE_RUNNING] = true;
+	stm32_percpu_data[STM32MP_PRIMARY_CPU].state[STATE_DDR] = true;
+	stm32_percpu_data[STM32MP_SECONDARY_CPU].state[STATE_START] = false;
+	stm32_percpu_data[STM32MP_SECONDARY_CPU].state[STATE_RUNNING] = false;
+
+	/* Save boot entry point for STOP2 exit */
+	ret = stm32_get_stop2_entrypoint_cell(&stop2_entrypoint_cell);
+	if (ret != 0) {
+		return ret;
+	}
+	nvmem_cell_write(&stop2_entrypoint_cell, (uint8_t *)&stop2_entrypoint,
+			 sizeof(stop2_entrypoint));
+
+	stm32_pm_init(fdt);
+
+	*psci_ops = &stm32_psci_ops;
+
+	return 0;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_private.c b/plat/st/stm32mp2/stm32mp2_private.c
new file mode 100644
index 0000000000..ca894a997c
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_private.c
@@ -0,0 +1,571 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/st/stm32_iwdg.h>
+#include <lib/mmio.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+#include <plat/common/platform.h>
+
+#include <platform_def.h>
+#include <stm32mp2_context.h>
+
+#if STM32MP_DDR_FIP_IO_STORAGE && defined(IMAGE_BL2)
+/* Map the whole SRAM1 as secure, required to load DDR FW from FIP */
+#define SRAM1_MAP_SIZE	SRAM1_SIZE_FOR_TFA
+#else
+/* Map the beginning of SRAM1 as secure */
+#define SRAM1_MAP_SIZE	STM32MP_SEC_SRAM1_SIZE
+#endif
+
+#define MAP_SYSRAM	MAP_REGION_FLAT(STM32MP_SYSRAM_BASE, \
+					STM32MP_SYSRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_SEC_SYSRAM	MAP_REGION_FLAT(STM32MP_SEC_SYSRAM_BASE, \
+					STM32MP_SEC_SYSRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#if STM32MP_USB_PROGRAMMER
+#define MAP_SEC_DEVICE_SYSRAM	MAP_REGION_FLAT(STM32MP_SEC_DEVICE_SYSRAM_BASE, \
+					STM32MP_SEC_DEVICE_SYSRAM_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+#endif
+
+/* Non-secure SYSRAM is used a uncached memory for SCMI message transfer */
+#define MAP_NS_SYSRAM	MAP_REGION_FLAT(STM32MP_NS_SYSRAM_BASE, \
+					STM32MP_NS_SYSRAM_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_NS | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_SRAM1	MAP_REGION_FLAT(SRAM1_BASE, \
+					SRAM1_MAP_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#define MAP_DEVICE	MAP_REGION_FLAT(STM32MP_DEVICE_BASE, \
+					STM32MP_DEVICE_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE | \
+					MT_EXECUTE_NEVER)
+
+#if defined(IMAGE_BL2)
+static const mmap_region_t stm32mp2_mmap[] = {
+#if STM32MP_USB_PROGRAMMER
+	MAP_SEC_SYSRAM,
+	MAP_SEC_DEVICE_SYSRAM,
+#else
+	MAP_SYSRAM,
+#endif
+	MAP_SRAM1,
+	MAP_DEVICE,
+	{0}
+};
+#endif
+#if defined(IMAGE_BL31)
+static const mmap_region_t stm32mp2_mmap[] = {
+	MAP_SEC_SYSRAM,
+	MAP_NS_SYSRAM,
+	MAP_SRAM1,
+	MAP_DEVICE,
+	{0}
+};
+#endif
+
+static uint8_t saved_header[STM32MP_HEADER_SIZE] __maybe_unused;
+
+void configure_mmu(void)
+{
+	mmap_add(stm32mp2_mmap);
+	init_xlat_tables();
+
+	enable_mmu_el3(0);
+}
+
+int stm32mp_map_retram(void)
+{
+	return  mmap_add_dynamic_region(RETRAM_BASE, RETRAM_BASE,
+					RETRAM_SIZE,
+					MT_RW | MT_SECURE);
+}
+
+int stm32mp_unmap_retram(void)
+{
+	return  mmap_remove_dynamic_region(RETRAM_BASE,
+					   RETRAM_SIZE);
+}
+
+uintptr_t stm32_get_gpio_bank_base(unsigned int bank)
+{
+	if (bank == GPIO_BANK_Z) {
+		return GPIOZ_BASE;
+	}
+
+	assert(bank <= GPIO_BANK_K);
+
+	return GPIOA_BASE + (bank * GPIO_BANK_OFFSET);
+}
+
+uint32_t stm32_get_gpio_bank_offset(unsigned int bank)
+{
+	if (bank == GPIO_BANK_Z) {
+		return 0;
+	}
+
+	assert(bank <= GPIO_BANK_K);
+
+	return bank * GPIO_BANK_OFFSET;
+}
+
+unsigned long stm32_get_gpio_bank_clock(unsigned int bank)
+{
+	if (bank == GPIO_BANK_Z) {
+		return CK_BUS_GPIOZ;
+	}
+
+	assert(bank <= GPIO_BANK_K);
+
+	return CK_BUS_GPIOA + (bank - GPIO_BANK_A);
+}
+
+#if STM32MP_UART_PROGRAMMER || !defined(IMAGE_BL2)
+/*
+ * UART Management
+ */
+static const uintptr_t stm32mp2_uart_addresses[STM32MP_NB_OF_UART] = {
+	USART1_BASE,
+	USART2_BASE,
+	USART3_BASE,
+	UART4_BASE,
+	UART5_BASE,
+	USART6_BASE,
+	UART7_BASE,
+	UART8_BASE,
+	UART9_BASE,
+};
+
+uintptr_t get_uart_address(uint32_t instance_nb)
+{
+	if ((instance_nb == 0U) ||
+	    (instance_nb > STM32MP_NB_OF_UART)) {
+		return 0U;
+	}
+
+	return stm32mp2_uart_addresses[instance_nb - 1U];
+}
+#endif
+
+void stm32_save_header(void)
+{
+#if (STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER) && TRUSTED_BOARD_BOOT
+	memcpy(&saved_header, (uint8_t *)STM32MP_HEADER_BASE, STM32MP_HEADER_SIZE);
+#endif /* STM32MP_USB_PROGRAMMER && TRUSTED_BOARD_BOOT */
+}
+
+uintptr_t stm32_get_header_address(void)
+{
+#if (STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER) && TRUSTED_BOARD_BOOT
+	return (uintptr_t)&saved_header;
+#else
+	return STM32MP_HEADER_BASE;
+#endif /* STM32MP_USB_PROGRAMMER && TRUSTED_BOARD_BOOT */
+}
+
+uint32_t stm32mp_get_chip_version(void)
+{
+	static uint32_t rev;
+
+	if (rev != 0U) {
+		return rev;
+	}
+
+	if (stm32_get_otp_value(REVISION_OTP, &rev) != 0) {
+		panic();
+	}
+
+	return rev;
+}
+
+uint32_t stm32mp_get_chip_dev_id(void)
+{
+	return stm32mp_syscfg_get_chip_dev_id();
+}
+
+static uint32_t get_part_number(void)
+{
+	static uint32_t part_number;
+
+	if (part_number != 0U) {
+		return part_number;
+	}
+
+	if (stm32_get_otp_value(PART_NUMBER_OTP, &part_number) != 0) {
+		panic();
+	}
+
+	return part_number;
+}
+
+static uint32_t get_cpu_package(void)
+{
+	static uint32_t package = UINT32_MAX;
+
+	if (package == UINT32_MAX) {
+		if (stm32_get_otp_value(PACKAGE_OTP, &package) != 0) {
+			panic();
+		}
+	}
+
+	return (package & PACKAGE_OTP_PKG_MASK) >> PACKAGE_OTP_PKG_SHIFT;
+}
+
+void stm32mp_get_soc_name(char name[STM32_SOC_NAME_SIZE])
+{
+	char *cpu_s, *cpu_r, *pkg;
+
+	/* MPUs Part Numbers */
+	switch (get_part_number()) {
+	case STM32MP251A_PART_NB:
+		cpu_s = "251A";
+		break;
+	case STM32MP251C_PART_NB:
+		cpu_s = "251C";
+		break;
+	case STM32MP251D_PART_NB:
+		cpu_s = "251D";
+		break;
+	case STM32MP251F_PART_NB:
+		cpu_s = "251F";
+		break;
+	case STM32MP253A_PART_NB:
+		cpu_s = "253A";
+		break;
+	case STM32MP253C_PART_NB:
+		cpu_s = "253C";
+		break;
+	case STM32MP253D_PART_NB:
+		cpu_s = "253D";
+		break;
+	case STM32MP253F_PART_NB:
+		cpu_s = "253F";
+		break;
+	case STM32MP255A_PART_NB:
+		cpu_s = "255A";
+		break;
+	case STM32MP255C_PART_NB:
+		cpu_s = "255C";
+		break;
+	case STM32MP255D_PART_NB:
+		cpu_s = "255D";
+		break;
+	case STM32MP255F_PART_NB:
+		cpu_s = "255F";
+		break;
+	case STM32MP257A_PART_NB:
+		cpu_s = "257A";
+		break;
+	case STM32MP257C_PART_NB:
+		cpu_s = "257C";
+		break;
+	case STM32MP257D_PART_NB:
+		cpu_s = "257D";
+		break;
+	case STM32MP257F_PART_NB:
+		cpu_s = "257F";
+		break;
+	default:
+		cpu_s = "????";
+		break;
+	}
+
+	/* Package */
+	switch (get_cpu_package()) {
+	case STM32MP25_PKG_CUSTOM:
+		pkg = "XX";
+		break;
+	case STM32MP25_PKG_AL_TBGA361:
+		pkg = "AL";
+		break;
+	case STM32MP25_PKG_AK_TBGA424:
+		pkg = "AK";
+		break;
+	case STM32MP25_PKG_AI_TBGA436:
+		pkg = "AI";
+		break;
+	default:
+		pkg = "??";
+		break;
+	}
+
+	/* REVISION */
+	switch (stm32mp_get_chip_version()) {
+#if STM32MP25
+	case 0:
+#endif
+	case STM32MP2_REV_B:
+		cpu_r = "B";
+		break;
+	case STM32MP2_REV_X:
+		cpu_r = "X";
+		break;
+	case STM32MP2_REV_Y:
+		cpu_r = "Y";
+		break;
+	case STM32MP2_REV_Z:
+		cpu_r = "Z";
+		break;
+	default:
+		cpu_r = "?";
+		break;
+	}
+
+	snprintf(name, STM32_SOC_NAME_SIZE,
+		 "STM32MP%s%s Rev.%s", cpu_s, pkg, cpu_r);
+}
+
+void stm32mp_print_cpuinfo(void)
+{
+	char name[STM32_SOC_NAME_SIZE];
+
+	stm32mp_get_soc_name(name);
+	NOTICE("CPU: %s\n", name);
+}
+
+void stm32mp_print_boardinfo(void)
+{
+	uint32_t board_id = 0U;
+
+	if (stm32_get_otp_value(BOARD_ID_OTP, &board_id) != 0) {
+		return;
+	}
+
+	if (board_id != 0U) {
+		stm32_display_board_info(board_id);
+	}
+}
+
+/* Return true when SoC provides a single Cortex-A35 core, and false otherwise */
+bool stm32mp_is_single_core(void)
+{
+	bool single_core = false;
+
+	switch (get_part_number()) {
+	case STM32MP251A_PART_NB:
+	case STM32MP251C_PART_NB:
+	case STM32MP251D_PART_NB:
+	case STM32MP251F_PART_NB:
+		single_core = true;
+		break;
+	default:
+		break;
+	}
+
+	return single_core;
+}
+
+/* Return true when device is in closed state */
+uint32_t stm32mp_check_closed_device(void)
+{
+	static uint32_t otp_idx;
+	static uint32_t otp_len;
+	uint32_t otp_val;
+	uint32_t status = STM32MP_CHIP_SEC_CLOSED;
+
+	if (otp_len == 0U) {
+		if (stm32_get_otp_index(LIFECYCLE2_OTP, &otp_idx, &otp_len) != 0) {
+			panic();
+		}
+
+		if (otp_len != __WORD_BIT) {
+			panic();
+		}
+	}
+
+	if (stm32_get_otp_value_from_idx(otp_idx, &otp_val) != 0) {
+		panic();
+	}
+
+	if (!stm32_otp_is_closed_device() ||
+	    ((otp_val & SECURE_BOOT_CLOSED_SECURE) == 0U)) {
+		status = STM32MP_CHIP_SEC_OPEN;
+	}
+
+	return status;
+}
+
+/* Return true when device supports secure boot */
+bool stm32mp_is_auth_supported(void)
+{
+	bool supported = false;
+
+	switch (get_part_number()) {
+	case STM32MP251C_PART_NB:
+	case STM32MP251F_PART_NB:
+	case STM32MP253C_PART_NB:
+	case STM32MP253F_PART_NB:
+	case STM32MP255C_PART_NB:
+	case STM32MP255F_PART_NB:
+	case STM32MP257C_PART_NB:
+	case STM32MP257F_PART_NB:
+		supported = true;
+		break;
+	default:
+		break;
+	}
+
+	return supported;
+}
+
+uint32_t stm32_iwdg_get_instance(uintptr_t base)
+{
+	uint32_t instance = UINT32_MAX;
+
+	switch (base) {
+	case IWDG1_BASE:
+		instance = IWDG1_INST;
+		break;
+	case IWDG2_BASE:
+		instance = IWDG2_INST;
+		break;
+	default:
+		break;
+	}
+
+	if (instance == UINT32_MAX) {
+		panic();
+	}
+
+	return instance;
+}
+
+uint32_t stm32_iwdg_get_otp_config(uint32_t iwdg_inst)
+{
+	uint32_t iwdg_cfg = 0U;
+	uint32_t otp_value;
+
+	if (stm32_get_otp_value(HCONF1_OTP, &otp_value) != 0U) {
+		panic();
+	}
+
+	if ((otp_value & HCONF1_OTP_IWDG_HW_MASK(iwdg_inst)) != 0U) {
+		iwdg_cfg |= IWDG_HW_ENABLED;
+	}
+
+	return iwdg_cfg;
+}
+
+bool stm32mp_skip_boot_device_after_standby(void)
+{
+	return false;
+}
+
+bool stm32mp_is_wakeup_from_standby(void)
+{
+#if STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER
+	return false;
+#else /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+	static int standby = -1;
+	uint32_t rstsr;
+
+	if (standby == -1) {
+		rstsr = mmio_read_32(stm32mp_rcc_base() + RCC_C1BOOTRSTSCLRR);
+
+		if ((rstsr & RCC_C1BOOTRSTSCLRR_PADRSTF) != 0U) {
+			return false;
+		}
+		if (stm32_pm_context_is_valid()) {
+			standby = 1;
+		} else {
+			standby = 0;
+		}
+	}
+
+	return standby == 1;
+#endif /* STM32MP_UART_PROGRAMMER || STM32MP_USB_PROGRAMMER */
+}
+
+int stm32_risaf_get_instance(uintptr_t base)
+{
+	switch (base) {
+	case RISAF2_BASE:
+		return (int)RISAF2_INST;
+	case RISAF4_BASE:
+		return (int)RISAF4_INST;
+	default:
+		return -ENODEV;
+	}
+}
+
+uintptr_t stm32_risaf_get_base(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return (uintptr_t)RISAF2_BASE;
+	case RISAF4_INST:
+		return (uintptr_t)RISAF4_BASE;
+	default:
+		return 0U;
+	}
+}
+
+int stm32_risaf_get_max_region(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return (int)RISAF2_MAX_REGION;
+	case RISAF4_INST:
+		return (int)RISAF4_MAX_REGION;
+	default:
+		return 0;
+	}
+}
+
+uintptr_t stm32_risaf_get_memory_base(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return (uintptr_t)STM32MP_OSPI_MM_BASE;
+	case RISAF4_INST:
+		return (uintptr_t)STM32MP_DDR_BASE;
+	default:
+		return 0U;
+	}
+}
+
+size_t stm32_risaf_get_memory_size(int instance)
+{
+	switch (instance) {
+	case RISAF2_INST:
+		return STM32MP_OSPI_MM_SIZE;
+	case RISAF4_INST:
+		return dt_get_ddr_size();
+	default:
+		return 0U;
+	}
+}
+
+uintptr_t stm32_ddrdbg_get_base(void)
+{
+	return DDRDBG_BASE;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_pwr.c b/plat/st/stm32mp2/stm32mp2_pwr.c
new file mode 100644
index 0000000000..4ca47a737a
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_pwr.c
@@ -0,0 +1,179 @@
+/*
+ * Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <drivers/st/regulator.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+#include <libfdt.h>
+
+#include <platform_def.h>
+#include <stm32mp2_private.h>
+
+#define IO_VOLTAGE_THRESHOLD_MV 2700
+
+struct pwr_regu {
+	const char *node_name;
+	uint32_t enable_reg;
+	uint32_t valid_mask;
+	uint32_t vrsel_mask;
+	int comp_idx;
+	const char *supply_name;
+};
+
+enum pwr_regulator_id {
+	IOD_VDDIO1,
+	IOD_VDDIO2,
+	IOD_VDDIO3,
+	IOD_VDDIO4,
+	IOD_VDDIO,
+	PWR_REGU_COUNT
+};
+
+static const struct pwr_regu pwr_regulators[] = {
+	 [IOD_VDDIO1] = {
+		.node_name = "vddio1",
+		.enable_reg = PWR_CR8,
+		.valid_mask = PWR_CR8_VDDIO1SV,
+		.vrsel_mask = PWR_CR8_VDDIO1VRSEL,
+		.comp_idx = SYSFG_VDDIO1_ID,
+		.supply_name = "vddio1",
+	 },
+	 [IOD_VDDIO2] = {
+		.node_name = "vddio2",
+		.enable_reg = PWR_CR7,
+		.valid_mask = PWR_CR7_VDDIO2SV,
+		.vrsel_mask = PWR_CR7_VDDIO2VRSEL,
+		.comp_idx = SYSFG_VDDIO2_ID,
+		.supply_name = "vddio2",
+	 },
+	 [IOD_VDDIO3] = {
+		.node_name = "vddio3",
+		.enable_reg = PWR_CR1,
+		.valid_mask = PWR_CR1_VDDIO3SV,
+		.vrsel_mask = PWR_CR1_VDDIO3VRSEL,
+		.comp_idx = SYSFG_VDDIO3_ID,
+		.supply_name = "vddio3",
+	 },
+	 [IOD_VDDIO4] = {
+		.node_name = "vddio4",
+		.enable_reg = PWR_CR1,
+		.valid_mask = PWR_CR1_VDDIO4SV,
+		.vrsel_mask = PWR_CR1_VDDIO4VRSEL,
+		.comp_idx = SYSFG_VDDIO4_ID,
+		.supply_name = "vddio4",
+	 },
+	 [IOD_VDDIO] = {
+		.node_name = "vddio",
+		.enable_reg = PWR_CR1,
+		.vrsel_mask = PWR_CR1_VDDIOVRSEL,
+		.comp_idx = SYSFG_VDD_IO_ID,
+		.supply_name = "vdd",
+	 },
+};
+
+static bool stm32mp2_pwr_domain_is_enabled(const struct pwr_regu *regu)
+{
+	uint32_t val = mmio_read_32(stm32mp_pwr_base() + regu->enable_reg);
+	bool status = (val & (regu->valid_mask | regu->enable_reg)) != 0U;
+
+	VERBOSE("pwr: IO doamin status for %s is %d\n", regu->node_name, status);
+
+	return status;
+
+}
+
+static int stm32mp2_pwr_handle_vrsel(void *fdt, int node, const struct pwr_regu *regu)
+{
+	struct rdev *supply;
+	int mv;
+
+	VERBOSE("Check VRSEL for %s\n", regu->node_name);
+
+	/* Look for supply */
+	supply = regulator_get_by_supply_name(fdt, node, regu->supply_name);
+	if (supply == NULL) {
+		VERBOSE("Failed to get %s-supply\n", regu->supply_name);
+		return 0;
+	}
+
+	mv = regulator_get_voltage(supply);
+	if (mv < 0) {
+		return mv;
+	}
+
+	if (mv < IO_VOLTAGE_THRESHOLD_MV) {
+		VERBOSE("Enable VRSEL for %s\n", regu->node_name);
+
+		mmio_setbits_32(stm32mp_pwr_base() + regu->enable_reg, regu->vrsel_mask);
+
+		if ((mmio_read_32(stm32mp_pwr_base() + regu->enable_reg) &
+		    regu->vrsel_mask) == 0U) {
+			WARN("Could not enable VRSEL for %s\n", regu->node_name);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * @brief  Enable IO compensation for the IO domains that are already ON,
+ *         and set domain to high speed depending on power supply voltage.
+ * @retval 0 or error.
+ */
+int stm32mp2_pwr_init_io_domains(void)
+{
+	void *fdt;
+	int node;
+	int subnode = 0;
+
+	VERBOSE("Init IO domains\n");
+
+	if (fdt_get_address(&fdt) == 0) {
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, DT_PWR_COMPAT);
+	if (node < 0) {
+		ERROR("Pwr node not found\n");
+		return -FDT_ERR_NOTFOUND;
+	}
+
+	fdt_for_each_subnode(subnode, fdt, node) {
+		const struct pwr_regu *regu = NULL;
+		int i;
+
+		/* Find regu from node name */
+		const char *node_name = fdt_get_name(fdt, subnode, NULL);
+
+		for (i = 0; i < PWR_REGU_COUNT; i++) {
+			regu = &pwr_regulators[i];
+
+			if (strcmp(regu->node_name, node_name) == 0) {
+				break;
+			}
+		}
+
+		if (i == PWR_REGU_COUNT) {
+			continue;
+		}
+
+		if (stm32mp2_pwr_domain_is_enabled(regu)) {
+			int ret;
+
+			VERBOSE("Init IO domain %d\n", i);
+
+			ret = stm32mp2_pwr_handle_vrsel(fdt, subnode, regu);
+			if (ret < 0) {
+				return ret;
+			}
+
+			stm32mp_syscfg_enable_io_compensation(regu->comp_idx);
+		}
+	}
+
+	return 0;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_syscfg.c b/plat/st/stm32mp2/stm32mp2_syscfg.c
new file mode 100644
index 0000000000..c5d99ab16c
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_syscfg.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) 2023-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <errno.h>
+
+#include <common/debug.h>
+#include <drivers/delay_timer.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <platform_def.h>
+#include <stm32mp2_private.h>
+
+/*
+ * SYSCFG register offsets (base relative)
+ */
+#define SYSCFG_OCTOSPIAMCR		0x2C00U
+#define SYSCFG_DEVICEID			0x6400U
+
+/*
+ * SYSCFG_OCTOSPIAMCR Register
+ */
+#define SYSCFG_OCTOSPIAMCR_OAM_MASK	GENMASK_32(2, 0)
+
+/*
+ * SYSCFG_DEVICEID Register
+ */
+#define SYSCFG_DEVICEID_DEV_ID_MASK	GENMASK_32(11, 0)
+#define SYSCFG_DEVICEID_REV_ID_MASK	GENMASK_32(31, 16)
+#define SYSCFG_DEVICEID_REV_ID_SHIFT	16
+
+/*
+ * SYSCFG IO Compensation Registers
+ */
+#define SYSCFG_VDDIO3CCCR		0x4000U
+#define SYSCFG_VDDIO4CCCR		0x4008U
+#define SYSCFG_VDDCCCR			0x4010U
+#define SYSCFG_VDDIO2CCCR		0x4018U
+#define SYSCFG_VDDIO1CCCR		0x4020U
+
+/* IO compensation CCR registers bit definition */
+#define SYSCFG_CCCR_CS			BIT(9)
+#define SYSCFG_CCCR_EN			BIT(8)
+#define SYSCFG_CCCR_RAPSRC_MASK		GENMASK(7, 4)
+#define SYSCFG_CCCR_RANSRC_MASK		GENMASK(3, 0)
+
+/* IO compensation CCSR registers bit definition */
+#define SYSCFG_CCSR_READY		BIT(8)
+#define SYSCFG_CCSR_APSRC_MASK		GENMASK(7, 4)
+#define SYSCFG_CCSR_ANSRC_MASK		GENMASK(3, 0)
+
+#define SYSCFG_CCSR_READY_TIMEOUT_US	1000U
+
+/* DLYBOS registers */
+#define SYSCFG_DLYBOS1_CR		0x1000U
+#define SYSCFG_DLYBOS1_SR		0x1004U
+#define SYSCFG_DLYBOS2_CR		0x1400U
+#define SYSCFG_DLYBOS2_SR		0x1404U
+
+#define SYSCFG_DLYBOS_CR_EN		BIT(0)
+#define SYSCFG_DLYBOS_CR_RXTAPSEL_SHIFT	1U
+#define SYSCFG_DLYBOS_CR_RXTAPSEL_MASK	GENMASK(6, 1)
+#define SYSCFG_DLYBOS_CR_TXTAPSEL_SHIFT	7U
+#define SYSCFG_DLYBOS_CR_TXTAPSEL_MASK	GENMASK(12, 7)
+#define SYSCFG_DLYBOS_BYP_EN		BIT(16)
+#define SYSCFG_DLYBOS_BYP_CMD_MASK	GENMASK(21, 17)
+#define SYSCFG_DLYBOS_BYP_CMD_SHIFT	17U
+
+#define SYSCFG_DLYBOS_SR_LOCK		BIT(0)
+#define SYSCFG_DLYBOS_SR_RXTAPSEL_ACK	BIT(1)
+#define SYSCFG_DLYBOS_SR_TXTAPSEL_ACK	BIT(2)
+
+#define SYSCFG_MAX_DLYBOS		2U
+#define SYSCFG_DLYBOS_TIMEOUT_US	10000U
+#define SYSCFG_DLYBOS_TAPSEL_NB		33U
+#define SYSCFG_DLYBOS_CMD_NB		24U
+
+/* SYSCFG potential tamper reset control register */
+#define SYSCFG_POTTAMPRSTCR		U(0x1804)
+
+#define SYSCFG_POTTAMPRSTCR_RSTMASK	BIT(0)
+
+/* ICN registers */
+#define SYSCFG_ICNQPCR1			U(0x2000)
+#define SYSCFG_ICNQPCR2			U(0x2004)
+#define SYSCFG_ICNEWRCR			U(0x2008)
+#define SYSCFG_ICNCGCR			U(0x200C)
+#define SYSCFG_ICNGPUBWLCR		U(0x2010)
+#define SYSCFG_ICNE2EBWRCR		U(0x2014)
+#define SYSCFG_ICNPCIBWLCR		U(0x201C)
+#define SYSCFG_ICNETHBWLCR		U(0x2020)
+#define SYSCFG_ICNUSB3BWLCR		U(0x2024)
+#define SYSCFG_ICNCPU1BWLCR		U(0x2028)
+#define SYSCFG_ICNLTDCBWLCR		U(0x202C)
+#define SYSCFG_ICNDCMIPPBWLCR		U(0x2030)
+#define SYSCFG_ICNVDEBWLCR		U(0x2034)
+
+struct syscfg_tap_window {
+	uint8_t end;
+	uint8_t length;
+};
+
+/*
+ * SYSCFG IO compensation register offsets (base relative)
+ */
+static uint32_t syscfg_cccr_offset[SYSFG_NB_IO_ID] = {
+	[SYSFG_VDDIO1_ID] = SYSCFG_VDDIO1CCCR,
+	[SYSFG_VDDIO2_ID] = SYSCFG_VDDIO2CCCR,
+	[SYSFG_VDDIO3_ID] = SYSCFG_VDDIO3CCCR,
+	[SYSFG_VDDIO4_ID] = SYSCFG_VDDIO4CCCR,
+	[SYSFG_VDD_IO_ID] = SYSCFG_VDDCCCR,
+};
+
+/*
+ * @brief  Get device ID from SYSCFG registers.
+ * @retval device ID (DEV_ID).
+ */
+uint32_t stm32mp_syscfg_get_chip_dev_id(void)
+{
+	return mmio_read_32(SYSCFG_BASE + SYSCFG_DEVICEID) & SYSCFG_DEVICEID_DEV_ID_MASK;
+}
+
+size_t stm32mp_syscfg_get_mm_size(uint8_t bank)
+{
+	uint32_t amcr = mmio_read_32(SYSCFG_BASE + SYSCFG_OCTOSPIAMCR);
+	uint32_t oam = amcr & SYSCFG_OCTOSPIAMCR_OAM_MASK;
+	size_t addr_mapping1;
+	size_t addr_mapping2;
+
+	if (oam > 3U) {
+		addr_mapping2 = SZ_256M;
+	} else {
+		addr_mapping2 = oam * SZ_64M;
+	}
+
+	addr_mapping1 = SZ_256M - addr_mapping2;
+
+	return (bank == 0U) ? addr_mapping1 : addr_mapping2;
+}
+
+/*
+ * @brief  Enable IO compensation for an IO domain.
+ * @param  id: IO compensation ID
+ * @retval 0.
+ */
+void stm32mp_syscfg_enable_io_compensation(enum syscfg_io_ids id)
+{
+	uintptr_t cccr_addr = SYSCFG_BASE + syscfg_cccr_offset[id];
+	uintptr_t ccsr_addr = cccr_addr + 4U;
+	uint64_t timeout_ref;
+
+	VERBOSE("Enable IO comp for id %u\n", id);
+
+	if ((mmio_read_32(ccsr_addr) & SYSCFG_CCSR_READY) != 0U) {
+		return;
+	}
+
+	mmio_setbits_32(cccr_addr, SYSCFG_CCCR_EN);
+
+	timeout_ref = timeout_init_us(SYSCFG_CCSR_READY_TIMEOUT_US);
+
+	while ((mmio_read_32(ccsr_addr) & SYSCFG_CCSR_READY) == 0U)
+		if (timeout_elapsed(timeout_ref)) {
+			WARN("IO compensation cell not ready\n");
+			/* Allow an almost silent failure here */
+			break;
+		}
+
+	mmio_clrbits_32(cccr_addr, SYSCFG_CCCR_CS);
+}
+
+#if STM32MP_SPI_NAND || STM32MP_SPI_NOR || STM32MP_HYPERFLASH
+/*
+ * SYSCFG DLYBOS register offsets (base relative)
+ */
+static const uint32_t syscfg_dlybos_cr_offset[SYSCFG_MAX_DLYBOS] = {
+	SYSCFG_DLYBOS1_CR,
+	SYSCFG_DLYBOS2_CR
+};
+
+static const uint32_t syscfg_dlybos_sr_offset[SYSCFG_MAX_DLYBOS] = {
+	SYSCFG_DLYBOS1_SR,
+	SYSCFG_DLYBOS2_SR
+};
+
+static int stm32_syscfg_dlyb_set_tap(uint8_t bank, uint8_t tap, bool rx_tap)
+{
+	uintptr_t cr = SYSCFG_BASE + syscfg_dlybos_cr_offset[bank];
+	uintptr_t sr = SYSCFG_BASE + syscfg_dlybos_sr_offset[bank];
+	uint64_t timeout;
+	uint32_t mask, ack;
+	uint8_t shift;
+
+	if (rx_tap) {
+		mask = SYSCFG_DLYBOS_CR_RXTAPSEL_MASK;
+		shift = SYSCFG_DLYBOS_CR_RXTAPSEL_SHIFT;
+		ack = SYSCFG_DLYBOS_SR_RXTAPSEL_ACK;
+	} else {
+		mask = SYSCFG_DLYBOS_CR_TXTAPSEL_MASK;
+		shift = SYSCFG_DLYBOS_CR_TXTAPSEL_SHIFT;
+		ack = SYSCFG_DLYBOS_SR_TXTAPSEL_ACK;
+	}
+
+	mmio_clrsetbits_32(cr, mask, (tap << shift) & mask);
+
+	timeout = timeout_init_us(SYSCFG_DLYBOS_TIMEOUT_US);
+	while ((mmio_read_32(sr) & ack) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			WARN("%s: %s delay block phase configuration timeout\n",
+			     __func__, rx_tap ? "RX" : "TX");
+
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+void stm32mp_syscfg_dlyb_stop(uint8_t bank)
+{
+	mmio_write_32(SYSCFG_BASE + syscfg_dlybos_cr_offset[bank], 0x0);
+}
+
+int stm32mp_syscfg_dlyb_find_tap(uint8_t bank, int (*check_transfer)(void),
+				  bool rx_only, uint8_t *window_len)
+{
+	struct syscfg_tap_window rx_tap_w[SYSCFG_DLYBOS_TAPSEL_NB];
+	int ret;
+	uint8_t rx_len, rx_window_len, rx_window_end;
+	uint8_t tx_len, tx_window_len, tx_window_end;
+	uint8_t rx_tap, tx_tap, tx_tap_max, tx_tap_min, best_tx_tap;
+	uint8_t score, score_max;
+
+	if (bank >= SYSCFG_MAX_DLYBOS) {
+		return -EINVAL;
+	}
+
+	tx_len = 0U;
+	tx_window_len = 0U;
+	tx_window_end = 0U;
+	rx_window_len = 0U;
+	rx_window_end = 0U;
+	best_tx_tap = 0U;
+
+	for (tx_tap = 0U;
+	     tx_tap < (rx_only ? 1U : SYSCFG_DLYBOS_TAPSEL_NB);
+	     tx_tap++) {
+		ret = stm32_syscfg_dlyb_set_tap(bank, tx_tap, false);
+		if (ret != 0) {
+			return ret;
+		}
+
+		rx_len = 0U;
+		rx_window_len = 0U;
+		rx_window_end = 0U;
+
+		for (rx_tap = 0U; rx_tap < SYSCFG_DLYBOS_TAPSEL_NB; rx_tap++) {
+			ret = stm32_syscfg_dlyb_set_tap(bank, rx_tap, true);
+			if (ret != 0) {
+				return ret;
+			}
+
+			if (check_transfer() != 0) {
+				if ((!rx_only && (ret == -ETIMEDOUT)) ||
+				    (ret == -EOPNOTSUPP)) {
+					break;
+				}
+
+				rx_len = 0U;
+			} else {
+				rx_len++;
+
+				if (rx_len > rx_window_len) {
+					rx_window_len = rx_len;
+					rx_window_end = rx_tap;
+				}
+			}
+		}
+
+		if (ret == -EOPNOTSUPP) {
+			break;
+		}
+
+		rx_tap_w[tx_tap].end = rx_window_end;
+		rx_tap_w[tx_tap].length = rx_window_len;
+
+		if (rx_window_len == 0U) {
+			tx_len = 0U;
+		} else {
+			tx_len++;
+
+			if (tx_len > tx_window_len) {
+				tx_window_len = tx_len;
+				tx_window_end = tx_tap;
+			}
+		}
+
+		VERBOSE("%s: rx_tap_w[%d].end = %d rx_tap_w[%d].length = %d\n",
+			__func__, tx_tap, rx_tap_w[tx_tap].end,
+			tx_tap, rx_tap_w[tx_tap].length);
+	}
+
+	if (ret == -EOPNOTSUPP) {
+		ERROR("%s: calibration can not be done on this device\n", __func__);
+
+		return ret;
+	}
+
+	if (rx_only) {
+		if (rx_window_len == 0U) {
+			WARN("%s: can't find RX phase settings\n", __func__);
+
+			return -EIO;
+		}
+
+		rx_tap = rx_window_end - rx_window_len / 2U;
+		*window_len = rx_window_len;
+		VERBOSE("%s: RX_TAP_SEL set to %d\n", __func__, rx_tap);
+
+		return stm32_syscfg_dlyb_set_tap(bank, rx_tap, true);
+	}
+
+	if (tx_window_len == 0U) {
+		WARN("%s: can't find TX phase settings\n", __func__);
+
+		return -EIO;
+	}
+
+	/* Find the best duet TX/RX TAP */
+	tx_tap_min = (tx_window_end + 1U) - tx_window_len;
+	tx_tap_max = tx_window_end;
+	score_max = 0U;
+
+	for (tx_tap = tx_tap_min; tx_tap <= tx_tap_max; tx_tap++) {
+		score = MIN(tx_tap - tx_tap_min, tx_tap_max - tx_tap) +
+			rx_tap_w[tx_tap].length;
+
+		if (score > score_max) {
+			score_max = score;
+			best_tx_tap = tx_tap;
+		}
+	}
+
+	rx_tap = rx_tap_w[best_tx_tap].end - rx_tap_w[best_tx_tap].length / 2U;
+
+	VERBOSE("%s: RX_TAP_SEL set to %d\n", __func__, rx_tap);
+	ret = stm32_syscfg_dlyb_set_tap(bank, rx_tap, true);
+	if (ret != 0) {
+		return ret;
+	}
+
+	VERBOSE("%s: TX_TAP_SEL set to %d\n", __func__, best_tx_tap);
+
+	return stm32_syscfg_dlyb_set_tap(bank, best_tx_tap, false);
+}
+
+int stm32mp_syscfg_dlyb_set_cr(uint8_t bank, uint32_t dlyb_cr)
+{
+	bool bypass_mode = false;
+	uint16_t period_ps;
+	uint8_t rx_tap;
+	uint8_t tx_tap;
+	int ret;
+
+	period_ps = (dlyb_cr & SYSCFG_DLYBOS_BYP_CMD_MASK) >>
+		    SYSCFG_DLYBOS_BYP_CMD_SHIFT;
+	if ((dlyb_cr & SYSCFG_DLYBOS_BYP_EN) != 0U) {
+		bypass_mode = true;
+	}
+
+	ret = stm32mp_syscfg_dlyb_init(bank, bypass_mode, period_ps);
+	if (ret != 0) {
+		return ret;
+	}
+
+	/* restore Rx and TX tap */
+	rx_tap = (dlyb_cr & SYSCFG_DLYBOS_CR_RXTAPSEL_MASK) >>
+		 SYSCFG_DLYBOS_CR_RXTAPSEL_SHIFT;
+	ret = stm32_syscfg_dlyb_set_tap(bank, rx_tap, true);
+	if (ret != 0) {
+		return ret;
+	}
+
+	tx_tap = (dlyb_cr & SYSCFG_DLYBOS_CR_TXTAPSEL_MASK) >>
+		 SYSCFG_DLYBOS_CR_TXTAPSEL_SHIFT;
+
+	return stm32_syscfg_dlyb_set_tap(bank, tx_tap, false);
+}
+
+void stm32mp_syscfg_dlyb_get_cr(uint8_t bank, uint32_t *dlyb_cr)
+{
+	uintptr_t cr = SYSCFG_BASE + syscfg_dlybos_cr_offset[bank];
+
+	*dlyb_cr = mmio_read_32(cr);
+}
+
+/* ½ memory clock period in pico second */
+static const uint16_t syscfg_dlybos_cmd_delay_ps[SYSCFG_DLYBOS_CMD_NB] = {
+2816U, 4672U, 6272U, 7872U, 9472U, 11104U, 12704U, 14304U,
+15904U, 17536U, 19136U, 20736U, 22336U, 23968U, 25568U, 27168U,
+28768U, 30400U, 32000U, 33600U, 35232U, 36832U, 38432U, 40032U
+};
+
+static uint32_t stm32mp_syscfg_find_byp_cmd(uint16_t period_ps)
+{
+	uint16_t half_period_ps = period_ps / 2U;
+	uint8_t max = SYSCFG_DLYBOS_CMD_NB - 1U;
+	uint8_t i, min = 0U;
+
+	/* Find closest value in syscfg_dlybos_delay_ps[] with half_period_ps */
+	if (half_period_ps < syscfg_dlybos_cmd_delay_ps[min]) {
+		return (1U << SYSCFG_DLYBOS_BYP_CMD_SHIFT) &
+			SYSCFG_DLYBOS_BYP_CMD_MASK;
+	}
+
+	if (half_period_ps > syscfg_dlybos_cmd_delay_ps[max]) {
+		return SYSCFG_DLYBOS_BYP_CMD_MASK;
+	}
+
+	while (max > (min + 1U)) {
+		i = div_round_up(min + max, 2U);
+		if (half_period_ps > syscfg_dlybos_cmd_delay_ps[i]) {
+			min = i;
+		} else {
+			max = i;
+		}
+	}
+
+	if ((syscfg_dlybos_cmd_delay_ps[max] - half_period_ps) >
+	    (half_period_ps - syscfg_dlybos_cmd_delay_ps[min])) {
+		return ((min + 1U) << SYSCFG_DLYBOS_BYP_CMD_SHIFT) &
+			SYSCFG_DLYBOS_BYP_CMD_MASK;
+	} else {
+		return ((max + 1U) << SYSCFG_DLYBOS_BYP_CMD_SHIFT) &
+			SYSCFG_DLYBOS_BYP_CMD_MASK;
+	}
+}
+
+int stm32mp_syscfg_dlyb_init(uint8_t bank, bool bypass_mode,
+			      uint16_t period_ps)
+{
+	uint64_t timeout;
+	uintptr_t cr = SYSCFG_BASE + syscfg_dlybos_cr_offset[bank];
+	uintptr_t sr = SYSCFG_BASE + syscfg_dlybos_sr_offset[bank];
+	uint32_t mask, val;
+
+	if (bank >= SYSCFG_MAX_DLYBOS) {
+		return -EINVAL;
+	}
+
+	if (bypass_mode) {
+		mask = SYSCFG_DLYBOS_BYP_EN | SYSCFG_DLYBOS_BYP_CMD_MASK;
+		val = SYSCFG_DLYBOS_BYP_EN |
+		      stm32mp_syscfg_find_byp_cmd(period_ps);
+	} else {
+		mask = SYSCFG_DLYBOS_CR_EN;
+		val = SYSCFG_DLYBOS_CR_EN;
+	}
+
+	mmio_clrsetbits_32(cr, mask, val);
+
+	if (bypass_mode) {
+		return 0;
+	}
+
+	/* In lock mode, wait for lock status bit */
+	timeout = timeout_init_us(SYSCFG_DLYBOS_TIMEOUT_US);
+	while ((mmio_read_32(sr) & SYSCFG_DLYBOS_SR_LOCK) == 0U) {
+		if (timeout_elapsed(timeout)) {
+			WARN("%s: delay Block lock timeout\n", __func__);
+			mmio_clrbits_32(cr, SYSCFG_DLYBOS_CR_EN);
+
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+void stm32mp_syscfg_mask_potential_tamper_enable(void)
+{
+#if !STM32MP_M33_TDCID
+	mmio_setbits_32(SYSCFG_BASE + SYSCFG_POTTAMPRSTCR,
+			SYSCFG_POTTAMPRSTCR_RSTMASK);
+#endif
+}
+
+void stm32mp_syscfg_mask_potential_tamper_disable(void)
+{
+#if !STM32MP_M33_TDCID
+	mmio_clrbits_32(SYSCFG_BASE + SYSCFG_POTTAMPRSTCR,
+			SYSCFG_POTTAMPRSTCR_RSTMASK);
+#endif
+}
+
+/*
+ * @brief  Set ICN QOS priority per master.
+ *	   By default, SYSCFG_ICN* register keep their reset values
+ * @retval 0.
+ */
+void stm32mp_syscfg_set_icn_qos(void)
+{
+/*
+ *	Reset values, un-comment and change if required
+ *
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNQPCR1, U(0xCCCBBB3E));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNQPCR2, U(0x2449865A));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNEWRCR, U(0x0));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNCGCR, U(0x0));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNGPUBWLCR, U(0x0000400B));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNE2EBWRCR, U(0x00000052));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNPCIBWLCR, U(0x00002002));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNETHBWLCR, U(0x00001002));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNUSB3BWLCR, U(0x00004002));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNCPU1BWLCR, U(0x00002002));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNLTDCBWLCR, U(0x00008002));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNDCMIPPBWLCR, U(0x00005002));
+ *	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNVDEBWLCR, U(0x00003502));
+ */
+
+	/* Enable BW regulator */
+	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNE2EBWRCR, U(0x00000051));
+
+	/* Disable GPU BW limiter */
+	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNGPUBWLCR, U(0x00004009));
+
+#if STM32MP_DDR4_TYPE || STM32MP_LPDDR4_TYPE
+	/* Change value of CPU BW limiter */
+	mmio_write_32(SYSCFG_BASE + SYSCFG_ICNCPU1BWLCR, U(0x00005002));
+#endif
+}
diff --git a/plat/st/stm32mp2/stm32mp2_tbb_cert.c b/plat/st/stm32mp2/stm32mp2_tbb_cert.c
new file mode 100644
index 0000000000..3810a2f0ca
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_tbb_cert.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_oid.h>
+
+#include "tbbr/tbb_ext.h"
+#include "tbbr/tbb_key.h"
+
+#include "tbbr/stm32mp2_tbb_cert.h"
+
+/*
+ * Certificates used in the chain of trust
+ *
+ * The order of the certificates must follow the enumeration specified in
+ * stm32mp2_tbb_cert.h. All certificates are self-signed, so the issuer certificate
+ * field points to itself.
+ */
+static cert_t stm32mp2_tbb_certs[] = {
+	[0] = {
+		.id = STM32MP_CONFIG_CERT,
+		.opt = "stm32mp-cfg-cert",
+		.help_msg = "STM32MP Config Certificate (output file)",
+		.fn = NULL,
+		.cn = "STM32MP config FW Certificate",
+		.key = ROT_KEY,
+		.issuer = STM32MP_CONFIG_CERT,
+		.ext = {
+			TRUSTED_FW_NVCOUNTER_EXT,
+			HW_CONFIG_HASH_EXT,
+			FW_CONFIG_HASH_EXT,
+			DDR_FW_HASH_EXT
+		},
+		.num_ext = 4
+	},
+};
+
+PLAT_REGISTER_COT(stm32mp2_tbb_certs);
+
+static ext_t stm32mp2_tbb_ext[] = {
+	[0] = {
+		.oid = DDR_FW_HASH_OID,
+		.opt = "ddr-fw",
+		.help_msg = "DDR Firmware image file",
+		.sn = "DDR Firmware Hash",
+		.ln = "DDR Firmware hash (SHA256)",
+		.asn1_type = V_ASN1_OCTET_STRING,
+		.type = EXT_TYPE_HASH,
+		.optional = 1
+	}
+};
+
+PLAT_REGISTER_EXTENSIONS(stm32mp2_tbb_ext);
diff --git a/plat/st/stm32mp2/stm32mp2_topology.c b/plat/st/stm32mp2/stm32mp2_topology.c
new file mode 100644
index 0000000000..8ed5e4894d
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_topology.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <lib/psci/psci.h>
+#include <plat/common/platform.h>
+
+static const unsigned char stm32mp2_power_domain_tree_desc[PLAT_MAX_PWR_LVL + 1U] = {
+	1U, /* SoC,  D2 LPLV */
+	1U, /* D2 */
+	1U, /* D1 LPLV */
+	PLATFORM_CLUSTER_COUNT, /* D1 */
+	PLATFORM_CORE_COUNT, /* Number of children for the cluster node */
+};
+
+/* This function returns the platform topology */
+const unsigned char *plat_get_power_domain_tree_desc(void)
+{
+	return stm32mp2_power_domain_tree_desc;
+}
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform that allows the former to query the platform
+ * to convert an MPIDR to a unique linear index. An error code (-1) is returned
+ * in case the MPIDR is invalid.
+ ******************************************************************************/
+int plat_core_pos_by_mpidr(u_register_t mpidr)
+{
+	unsigned int cluster_id, cpu_id;
+	u_register_t mpidr_copy = mpidr;
+
+	mpidr_copy &= MPIDR_AFFINITY_MASK;
+
+	if ((mpidr_copy & ~(MPIDR_CLUSTER_MASK | MPIDR_CPU_MASK)) != 0U) {
+		return -1;
+	}
+
+	cluster_id = (mpidr_copy >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+	cpu_id = (mpidr_copy >> MPIDR_AFF0_SHIFT) & MPIDR_AFFLVL_MASK;
+
+	if (cluster_id >= PLATFORM_CLUSTER_COUNT) {
+		return -1;
+	}
+
+	/*
+	 * Validate cpu_id by checking whether it represents a CPU in one
+	 * of the two clusters present on the platform.
+	 */
+	if (cpu_id >= PLATFORM_CORE_COUNT) {
+		return -1;
+	}
+
+	return (int)cpu_id;
+}
diff --git a/plat/st/stm32mp2/stm32mp2_usb_dfu.c b/plat/st/stm32mp2/stm32mp2_usb_dfu.c
new file mode 100644
index 0000000000..cce6442d15
--- /dev/null
+++ b/plat/st/stm32mp2/stm32mp2_usb_dfu.c
@@ -0,0 +1,374 @@
+/*
+ * Copyright (c) 2022-2023, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <limits.h>
+#include <string.h>
+
+#include <common/debug.h>
+#include <drivers/st/usb_dwc3.h>
+#include <drivers/usb_device.h>
+
+#include <platform_def.h>
+#include <stm32cubeprogrammer.h>
+#include <stm32mp_common.h>
+#include <usb_dfu.h>
+
+/*  String size (1 byte) + type (1 byte) + 24 UTF16 characters: 2 bytes each */
+#define SIZ_STRING_SERIAL		U(24)
+#define USB_SIZ_STRING_SERIAL		(1U + 1U + (SIZ_STRING_SERIAL * 2U))
+#define USBD_MAX_STR_DESC_SIZ		U(0x100)
+#define USBD_VID			U(0x0483)
+#define USBD_PID			U(0xDF11)
+#define USBD_LANGID_STRING		U(0x409)
+#define USBD_MANUFACTURER_STRING	"STMicroelectronics"
+#define USBD_CONFIGURATION_STRING	"DFU Config"
+#define USBD_INTERFACE_STRING		"DFU Interface"
+
+#define USB_DFU_ITF_NUM			U(3)
+
+#define USB_DFU_CONFIG_DESC_SIZ		USB_DFU_DESC_SIZ(USB_DFU_ITF_NUM)
+
+/* DFU devices */
+static struct usb_dfu_handle usb_dfu_handle;
+
+/* USB Standard Device Descriptor */
+static const uint8_t usb_stm32mp2_desc[USB_LEN_DEV_DESC] = {
+	USB_LEN_DEV_DESC,           /* bLength */
+	USB_DESC_TYPE_DEVICE,       /* bDescriptorType */
+	0x00,                       /* bcdUSB */
+	0x02,                       /* version */
+	0x00,                       /* bDeviceClass */
+	0x00,                       /* bDeviceSubClass */
+	0x00,                       /* bDeviceProtocol */
+	USB_MAX_EP0_SIZE,           /* bMaxPacketSize */
+	LOBYTE(USBD_VID),           /* idVendor */
+	HIBYTE(USBD_VID),           /* idVendor */
+	LOBYTE(USBD_PID),           /* idVendor */
+	HIBYTE(USBD_PID),           /* idVendor */
+	0x00,                       /* bcdDevice rel. 2.00 */
+	0x02,
+	USBD_IDX_MFC_STR,           /* Index of manufacturer string */
+	USBD_IDX_PRODUCT_STR,       /* Index of product string */
+	USBD_IDX_SERIAL_STR,        /* Index of serial number string */
+	USBD_MAX_NUM_CONFIGURATION  /* bNumConfigurations */
+}; /* USB_DeviceDescriptor */
+
+/* USB Standard String Descriptor */
+static const uint8_t usb_stm32mp2_lang_id_desc[USB_LEN_LANGID_STR_DESC] = {
+	USB_LEN_LANGID_STR_DESC,
+	USB_DESC_TYPE_STRING,
+	LOBYTE(USBD_LANGID_STRING),
+	HIBYTE(USBD_LANGID_STRING),
+};
+
+/* USB Standard Device Descriptor */
+static const uint8_t
+usbd_stm32mp2_qualifier_desc[USB_LEN_DEV_QUALIFIER_DESC] = {
+	USB_LEN_DEV_QUALIFIER_DESC,
+	USB_DESC_TYPE_DEVICE_QUALIFIER,
+	0x00,
+	0x02,
+	0x00,
+	0x00,
+	0x00,
+	0x40,
+	0x01,
+	0x00,
+};
+
+/* USB serial number: build dynamically */
+static uint8_t usb_stm32mp2_serial[USB_SIZ_STRING_SERIAL + 1];
+
+/* USB DFU device Configuration Descriptor */
+static const uint8_t usb_stm32mp2_config_desc[USB_DFU_CONFIG_DESC_SIZ] = {
+	0x09, /* bLength: Configuration Descriptor size */
+	USB_DESC_TYPE_CONFIGURATION, /* bDescriptorType: Configuration */
+	USB_DFU_CONFIG_DESC_SIZ, /* wTotalLength: Bytes returned */
+	0x00,
+	0x01, /* bNumInterfaces: 1 interface */
+	0x01, /* bConfigurationValue: Configuration value */
+	0x02, /* iConfiguration: Index of string descriptor for configuration */
+	0xC0, /* bmAttributes: bus powered and Supprts Remote Wakeup */
+	0x32, /* MaxPower 100 mA: this current is used for detecting Vbus */
+
+	/* Descriptor of DFU interface 0 Alternate setting 0..N */
+	USBD_DFU_IF_DESC(0),
+	USBD_DFU_IF_DESC(1),
+	USBD_DFU_IF_DESC(2),
+	/* DFU Functional Descriptor */
+	0x09, /* blength = 9 Bytes */
+	DFU_DESCRIPTOR_TYPE, /* DFU Functional Descriptor */
+	DFU_BM_ATTRIBUTE, /* bmAttribute for DFU */
+	0xFF, /* DetachTimeOut = 255 ms */
+	0x00,
+	/* WARNING: In DMA mode the multiple MPS packets feature
+	 *  is still not supported ==> In this case,
+	 *  when using DMA USBD_DFU_XFER_SIZE should be set
+	 *  to 64 in usbd_conf.h
+	 */
+	TRANSFER_SIZE_BYTES(USBD_DFU_XFER_SIZE), /* TransferSize = 1024 Byte */
+	((USB_DFU_VERSION >> 0) & 0xFF), /* bcdDFUVersion */
+	((USB_DFU_VERSION >> 8) & 0xFF)
+};
+
+const char *const if_desc_string[USB_DFU_ITF_NUM] = {
+	"@DDR FIP /0x02/1*32Ke",
+	"@FIP /0x03/1*16Me",
+	"@virtual /0xF1/1*512Ba"
+};
+
+/* Buffer to build the unicode string provided to USB device stack */
+static uint8_t usb_str_dec[USBD_MAX_STR_DESC_SIZ];
+
+/*
+ * Convert Ascii string into unicode one
+ * desc : descriptor buffer
+ * unicode : Formatted string buffer (unicode)
+ * len : descriptor length
+ */
+static void stm32mp2_get_string(const char *desc, uint8_t *unicode, uint16_t *len)
+{
+	uint8_t idx = 0U;
+
+	if (desc == NULL) {
+		return;
+	}
+
+	*len =  strlen(desc) * 2U + 2U;
+	unicode[idx++] = *len;
+	unicode[idx++] =  USB_DESC_TYPE_STRING;
+
+	while (*desc != '\0') {
+		unicode[idx++] = *desc++;
+		unicode[idx++] =  0x00U;
+	}
+}
+
+/*
+ * Create the serial number string descriptor
+ */
+static void update_serial_num_string(void)
+{
+	char serial_string[SIZ_STRING_SERIAL + 2U];
+	/* serial number is set to 0 */
+	uint32_t deviceserial[UID_WORD_NB] = {0U, 0U, 0U};
+	uint16_t length;
+
+	if (stm32_get_uid_otp(deviceserial) != 0) {
+		return;
+	}
+
+	/* build serial number with OTP value as in ROM code */
+	snprintf(serial_string, sizeof(serial_string), "%08X%08X%08X",
+		 deviceserial[0], deviceserial[1], deviceserial[2]);
+
+	length = USB_SIZ_STRING_SERIAL;
+	stm32mp2_get_string(serial_string, usb_stm32mp2_serial, &length);
+}
+
+/*
+ * Return Device Qualifier descriptor
+ * length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_get_qualifier_desc(uint16_t *length)
+{
+	*length = sizeof(usbd_stm32mp2_qualifier_desc);
+
+	return (uint8_t *)usbd_stm32mp2_qualifier_desc;
+}
+
+/*
+ * Return configuration descriptor
+ * length : pointer data length
+ * return : pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_get_config_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp2_config_desc);
+
+	return (uint8_t *)usb_stm32mp2_config_desc;
+}
+
+/*
+ * Returns the device descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_device_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp2_desc);
+
+	return (uint8_t *)usb_stm32mp2_desc;
+}
+
+/*
+ * Returns the LangID string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_lang_id_desc(uint16_t *length)
+{
+	*length = sizeof(usb_stm32mp2_lang_id_desc);
+
+	return (uint8_t *)usb_stm32mp2_lang_id_desc;
+}
+
+/*
+ *  Returns the product string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_product_desc(uint16_t *length)
+{
+	char name[STM32_SOC_NAME_SIZE];
+	char product[128];
+	uint32_t chip_id;
+	uint32_t chip_version;
+
+	stm32mp_get_soc_name(name);
+	chip_id = stm32mp_get_chip_dev_id();
+	chip_version = stm32mp_get_chip_version();
+
+	snprintf(product, sizeof(product),
+		 "DFU @Device ID /0x%03X, @Revision ID /0x%04X, @Name /%s,",
+		 chip_id, chip_version, name);
+
+	stm32mp2_get_string(product, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Returns the manufacturer string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_manufacturer_desc(uint16_t *length)
+{
+	stm32mp2_get_string(USBD_MANUFACTURER_STRING, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Returns the serial number string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_serial_desc(uint16_t *length)
+{
+	*length = USB_SIZ_STRING_SERIAL;
+
+	return (uint8_t *)usb_stm32mp2_serial;
+}
+
+/*
+ * Returns the configuration string descriptor.
+ * length: Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_config_desc(uint16_t *length)
+{
+	stm32mp2_get_string(USBD_CONFIGURATION_STRING, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Returns the interface string descriptor.
+ * length : Pointer to data length variable
+ * return : Pointer to descriptor buffer
+ */
+static uint8_t *stm32mp2_interface_desc(uint16_t *length)
+{
+	stm32mp2_get_string(USBD_INTERFACE_STRING, usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+/*
+ * Manages the transfer of memory interfaces string descriptors.
+ * index: descriptor index
+ * length : pointer data length
+ * return : pointer to the descriptor table or NULL if the descriptor
+ *          is not supported.
+ */
+static uint8_t *stm32mp2_get_usr_desc(uint8_t index, uint16_t *length)
+{
+	if (index >= ARRAY_SIZE(if_desc_string)) {
+		return NULL;
+	}
+
+	stm32mp2_get_string(if_desc_string[index], usb_str_dec, length);
+
+	return usb_str_dec;
+}
+
+static const struct usb_desc dfu_desc = {
+	.get_device_desc = stm32mp2_device_desc,
+	.get_lang_id_desc = stm32mp2_lang_id_desc,
+	.get_manufacturer_desc = stm32mp2_manufacturer_desc,
+	.get_product_desc = stm32mp2_product_desc,
+	.get_configuration_desc = stm32mp2_config_desc,
+	.get_serial_desc = stm32mp2_serial_desc,
+	.get_interface_desc = stm32mp2_interface_desc,
+	.get_usr_desc = stm32mp2_get_usr_desc,
+	.get_config_desc = stm32mp2_get_config_desc,
+	.get_device_qualifier_desc = stm32mp2_get_qualifier_desc,
+	/* only HS is supported, as ROM code */
+	.get_other_speed_config_desc = NULL,
+};
+
+static struct usb_handle usb_core_handle;
+static struct pcd_handle pcd_handle;
+static dwc3_handle_t dwc3_handle;
+
+struct usb_handle *usb_dfu_plat_init(void)
+{
+	/* prepare USB Driver */
+	pcd_handle.in_ep[0].maxpacket = USB_MAX_EP0_SIZE;
+	pcd_handle.out_ep[0].maxpacket = USB_MAX_EP0_SIZE;
+	usb_dwc3_init_driver(&usb_core_handle, &pcd_handle, &dwc3_handle, (void *)USB_DWC3_BASE);
+
+	/* keep the configuration from ROM code */
+	usb_core_handle.ep0_state = USBD_EP0_DATA_IN;
+	usb_core_handle.dev_state = USBD_STATE_CONFIGURED;
+
+	/* Update the serial number string descriptor from the unique ID */
+	update_serial_num_string();
+
+	/* Prepare USB DFU stack */
+	usb_dfu_register(&usb_core_handle, &usb_dfu_handle);
+
+	/* Register DFU descriptor in USB stack */
+	register_platform(&usb_core_handle, &dfu_desc);
+
+	return &usb_core_handle;
+}
+
+/* Link between USB alternate and STM32CubeProgramer phase */
+uint8_t usb_dfu_get_phase(uint8_t alt)
+{
+	uint8_t ret;
+
+	switch (alt) {
+	case 0:
+		ret = PHASE_DDR_FW;
+		break;
+	case 1:
+		ret = PHASE_SSBL;
+		break;
+	case 2:
+		ret = PHASE_CMD;
+		break;
+	default:
+		ret = PHASE_RESET;
+		break;
+	}
+
+	return ret;
+}
diff --git a/plat/xilinx/common/ipi.c b/plat/xilinx/common/ipi.c
index 643889647b..8fa7bc563f 100644
--- a/plat/xilinx/common/ipi.c
+++ b/plat/xilinx/common/ipi.c
@@ -39,7 +39,7 @@
 #define IPI_BIT_MASK(I) (ipi_table[(I)].ipi_bit_mask)
 
 /* IPI configuration table */
-const static struct ipi_config *ipi_table;
+static const struct ipi_config *ipi_table;
 
 /* Total number of IPI */
 static uint32_t ipi_total;
diff --git a/plat/xilinx/zynqmp/pm_service/pm_svc_main.c b/plat/xilinx/zynqmp/pm_service/pm_svc_main.c
index 03fa316324..6c959f4f9f 100644
--- a/plat/xilinx/zynqmp/pm_service/pm_svc_main.c
+++ b/plat/xilinx/zynqmp/pm_service/pm_svc_main.c
@@ -328,22 +328,18 @@ uint64_t pm_smc_handler(uint32_t smc_fid, uint64_t x1, uint64_t x2, uint64_t x3,
 		SMC_RET1(handle, (uint64_t)ret);
 
 	case PM_GET_API_VERSION:
-		/* Check is PM API version already verified */
-		if (pm_ctx.api_version >= PM_VERSION) {
-			if (ipi_irq_flag == 0U) {
-				/*
-				 * Enable IPI IRQ
-				 * assume the rich OS is OK to handle callback IRQs now.
-				 * Even if we were wrong, it would not enable the IRQ in
-				 * the GIC.
-				 */
-				pm_ipi_irq_enable(primary_proc);
-				ipi_irq_flag = 1U;
-			}
-			SMC_RET1(handle, (uint64_t)PM_RET_SUCCESS |
-				 ((uint64_t)pm_ctx.api_version << 32));
+		if (ipi_irq_flag == 0U) {
+			/*
+			 * Enable IPI IRQ
+			 * assume the rich OS is OK to handle callback IRQs now.
+			 * Even if we were wrong, it would not enable the IRQ in
+			 * the GIC.
+			 */
+			pm_ipi_irq_enable(primary_proc);
+			ipi_irq_flag = 1U;
 		}
-
+		SMC_RET1(handle, (uint64_t)PM_RET_SUCCESS |
+			 ((uint64_t)pm_ctx.api_version << 32));
 	case PM_FPGA_LOAD:
 		ret = pm_fpga_load(pm_arg[0], pm_arg[1], pm_arg[2], pm_arg[3]);
 		SMC_RET1(handle, (uint64_t)ret);
diff --git a/plat/xilinx/zynqmp/zynqmp_ipi.c b/plat/xilinx/zynqmp/zynqmp_ipi.c
index 4ea3c6a33c..acd31df0ea 100644
--- a/plat/xilinx/zynqmp/zynqmp_ipi.c
+++ b/plat/xilinx/zynqmp/zynqmp_ipi.c
@@ -21,7 +21,7 @@
 #include <plat_private.h>
 
 /* Zynqmp ipi configuration table */
-const static struct ipi_config zynqmp_ipi_table[] = {
+static const struct ipi_config zynqmp_ipi_table[] = {
 	/* APU IPI */
 	{
 		.ipi_bit_mask = 0x1,
diff --git a/services/spd/opteed/opteed_main.c b/services/spd/opteed/opteed_main.c
index 160a693b2c..09a1cd9f74 100644
--- a/services/spd/opteed/opteed_main.c
+++ b/services/spd/opteed/opteed_main.c
@@ -179,6 +179,35 @@ static int32_t opteed_init(void)
 	return rc;
 }
 
+/*******************************************************************************
+ * This function register OPTEE image (BL32) for the first time
+ * on the primary cpu after a cold boot or restore the state after standby.
+ ******************************************************************************/
+static void opteed_register(void)
+{
+	uint64_t rc;
+	u_register_t flags;
+
+	/*
+	 * OPTEE has been successfully initialized.
+	 * Register power management hooks with PSCI
+	 */
+	psci_register_spd_pm_hook(&opteed_pm);
+
+	/*
+	 * Register an interrupt handler for S-EL1 interrupts
+	 * when generated during code executing in the
+	 * non-secure state.
+	 */
+	flags = 0;
+	set_interrupt_rm_flag(flags, NON_SECURE);
+	rc = register_interrupt_type_handler(INTR_TYPE_S_EL1,
+				opteed_sel1_interrupt_handler,
+				flags);
+	if (rc)
+		panic();
+}
+
 
 /*******************************************************************************
  * This function is responsible for handling all SMCs in the Trusted OS/App
@@ -200,7 +229,6 @@ static uintptr_t opteed_smc_handler(uint32_t smc_fid,
 	cpu_context_t *ns_cpu_context;
 	uint32_t linear_id = plat_my_core_pos();
 	optee_context_t *optee_ctx = &opteed_sp_context[linear_id];
-	uint64_t rc;
 
 	/*
 	 * Determine which security state this SMC originated from
@@ -286,24 +314,7 @@ static uintptr_t opteed_smc_handler(uint32_t smc_fid,
 		if (optee_vector_table) {
 			set_optee_pstate(optee_ctx->state, OPTEE_PSTATE_ON);
 
-			/*
-			 * OPTEE has been successfully initialized.
-			 * Register power management hooks with PSCI
-			 */
-			psci_register_spd_pm_hook(&opteed_pm);
-
-			/*
-			 * Register an interrupt handler for S-EL1 interrupts
-			 * when generated during code executing in the
-			 * non-secure state.
-			 */
-			flags = 0;
-			set_interrupt_rm_flag(flags, NON_SECURE);
-			rc = register_interrupt_type_handler(INTR_TYPE_S_EL1,
-						opteed_sel1_interrupt_handler,
-						flags);
-			if (rc)
-				panic();
+			opteed_register();
 		}
 
 		/*
@@ -418,3 +429,9 @@ DECLARE_RT_SVC(
 	NULL,
 	opteed_smc_handler
 );
+
+/* Define an OPTEED service to restore the SPD when BL31 data are lost */
+void opteed_restore(void)
+{
+	opteed_register();
+}
diff --git a/services/spd/opteed/opteed_private.h b/services/spd/opteed/opteed_private.h
index 242154f0ec..701ac906eb 100644
--- a/services/spd/opteed/opteed_private.h
+++ b/services/spd/opteed/opteed_private.h
@@ -157,6 +157,9 @@ void opteed_init_optee_ep_state(struct entry_point_info *optee_entry_point,
 extern optee_context_t opteed_sp_context[OPTEED_CORE_COUNT];
 extern uint32_t opteed_rw;
 extern struct optee_vectors *optee_vector_table;
+
+void opteed_restore(void);
+
 #endif /*__ASSEMBLER__*/
 
 #endif /* OPTEED_PRIVATE_H */
diff --git a/services/std_svc/spmd/spmd_main.c b/services/std_svc/spmd/spmd_main.c
index 7e6c89df36..afd0f2ea27 100644
--- a/services/std_svc/spmd/spmd_main.c
+++ b/services/std_svc/spmd/spmd_main.c
@@ -868,7 +868,8 @@ uint64_t spmd_smc_handler(uint32_t smc_fid,
 						     FFA_ERROR_NOT_SUPPORTED);
 		}
 
-		/* Fall through to forward the call to the other world */
+		/* Forward the call to the other world */
+		/* fallthrough */
 	case FFA_MSG_SEND:
 	case FFA_MSG_SEND_DIRECT_RESP_SMC64:
 	case FFA_MEM_DONATE_SMC32:
@@ -908,7 +909,8 @@ uint64_t spmd_smc_handler(uint32_t smc_fid,
 			spmd_spm_core_sync_exit(0ULL);
 		}
 
-		/* Fall through to forward the call to the other world */
+		/* Forward the call to the other world */
+		/* fallthrough */
 	case FFA_INTERRUPT:
 	case FFA_MSG_YIELD:
 		/* This interface must be invoked only by the Secure world */
diff --git a/tools/fiptool/Makefile b/tools/fiptool/Makefile
index d7e0fe5beb..77da4ac45b 100644
--- a/tools/fiptool/Makefile
+++ b/tools/fiptool/Makefile
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2014-2022, Arm Limited and Contributors. All rights reserved.
+# Copyright (c) 2014-2023, Arm Limited and Contributors. All rights reserved.
 #
 # SPDX-License-Identifier: BSD-3-Clause
 #
@@ -54,10 +54,13 @@ HOSTCC ?= gcc
 ifneq (${PLAT},)
 TF_PLATFORM_ROOT	:=	../../plat/
 include ${MAKE_HELPERS_DIRECTORY}plat_helpers.mk
-PLAT_FIPTOOL_HELPER_MK := ${PLAT_DIR}/plat_fiptool.mk
+COMBINED_PATH_FRAG := plat_fiptool/
+PLAT_FIPTOOL_HELPER_MK := $(foreach path_frag,$(subst /, ,$(patsubst ../../plat/%/,%,${PLAT_DIR})),\
+			  $(eval COMBINED_PATH_FRAG := ${COMBINED_PATH_FRAG}/${path_frag})\
+			  $(wildcard ${COMBINED_PATH_FRAG}/plat_fiptool.mk))
 endif
 
-ifneq (,$(wildcard ${PLAT_FIPTOOL_HELPER_MK}))
+ifneq (,$(wildcard $(lastword ${PLAT_FIPTOOL_HELPER_MK})))
 include ${PLAT_FIPTOOL_HELPER_MK}
 endif
 
diff --git a/tools/fiptool/plat_fiptool/arm/board/tc/plat_fiptool.mk b/tools/fiptool/plat_fiptool/arm/board/tc/plat_fiptool.mk
new file mode 100644
index 0000000000..70ccfc528e
--- /dev/null
+++ b/tools/fiptool/plat_fiptool/arm/board/tc/plat_fiptool.mk
@@ -0,0 +1,12 @@
+#
+# Copyright (c) 2021, NXP. All rights reserved.
+# Copyright (c) 2022-2023, Arm Limited. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+INCLUDE_PATHS += -I./ \
+		 -I../../plat/arm/board/tc
+
+HOSTCCFLAGS += -DPLAT_DEF_FIP_UUID
+OBJECTS += plat_fiptool/arm/board/tc/plat_def_uuid_config.o
diff --git a/tools/nxp/plat_fiptool/plat_def_uuid_config.c b/tools/fiptool/plat_fiptool/nxp/plat_def_uuid_config.c
similarity index 100%
rename from tools/nxp/plat_fiptool/plat_def_uuid_config.c
rename to tools/fiptool/plat_fiptool/nxp/plat_def_uuid_config.c
diff --git a/tools/fiptool/plat_fiptool/st/plat_def_uuid_config.c b/tools/fiptool/plat_fiptool/st/plat_def_uuid_config.c
new file mode 100644
index 0000000000..8d3329fc0d
--- /dev/null
+++ b/tools/fiptool/plat_fiptool/st/plat_def_uuid_config.c
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2022-2024, STMicroelectronics - All Rights Reserved
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stddef.h>
+
+#include <firmware_image_package.h>
+
+#include "tbbr_config.h"
+
+toc_entry_t plat_def_toc_entries[] = {
+	{
+		.name = "DDR_FW",
+		.uuid = UUID_DDR_FW,
+		.cmdline_name = "ddr-fw"
+	},
+	{
+		.name = "STM32MP CONFIG CERT",
+		.uuid = UUID_STM32MP_CONFIG_CERT,
+		.cmdline_name = "stm32mp-cfg-cert"
+	},
+
+	{
+		.name = NULL,
+		.uuid = { {0} },
+		.cmdline_name = NULL,
+	}
+};
diff --git a/tools/fiptool/plat_fiptool/st/plat_fiptool.mk b/tools/fiptool/plat_fiptool/st/plat_fiptool.mk
new file mode 100644
index 0000000000..41d5791c74
--- /dev/null
+++ b/tools/fiptool/plat_fiptool/st/plat_fiptool.mk
@@ -0,0 +1,25 @@
+#
+# Copyright (c) 2021-2024, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Name of the platform defined source file name,
+# which contains platform defined UUID entries populated
+# in the plat_def_toc_entries[].
+PLAT_DEF_UUID_FILE_NAME	:= plat_def_uuid_config
+
+INCLUDE_PATHS		+= -I../../plat/st/common/include -I./
+
+PLAT_DEF_UUID		:= yes
+
+ifeq (${PLAT_DEF_UUID},yes)
+HOSTCCFLAGS += -DPLAT_DEF_FIP_UUID
+
+${PLAT_DEF_UUID_FILE_NAME}.o: plat_fiptool/st/${PLAT_DEF_UUID_FILE_NAME}.c
+	${HOSTCC} -c ${CPPFLAGS} ${HOSTCCFLAGS} ${INCLUDE_PATHS} $< -o $@
+
+PLAT_OBJECTS += ${PLAT_DEF_UUID_FILE_NAME}.o
+endif
+
+OBJECTS += ${PLAT_OBJECTS}
diff --git a/tools/fwu_gen_metadata/README.md b/tools/fwu_gen_metadata/README.md
new file mode 100644
index 0000000000..3469bda525
--- /dev/null
+++ b/tools/fwu_gen_metadata/README.md
@@ -0,0 +1,87 @@
+# fwumd\_tool
+Tool to create FWU Metadata struct in Python
+
+## Getting started
+As metadata struct composition and length changes depending on how many images and how many banks you want to put in them,
+the options `--nb-img-in-banks` (or `-ni` for short) and `--nb-banks` (or `-nb` for short) may be required to format the binary data properly.
+The default values are **1 image** and **2 banks**
+
+### From Json to binary
+`fwumd_tool.py dummy` will generate a file `dummy.json` and `dummy.bin`, containing
+dummy metadata for testing purpose.
+
+Modify the json file with the correct metadata you want to set, then call
+`fwumd_tool.py jsonparse <json file>` to generate the binary metadata from the given json file
+In both of these commands, passing option `-v` will dump the content of the metadata for visual
+inspection.
+
+**The name format `<image>_bank_<nb>` needs to be respected for images in banks**
+
+### From binary to json
+You can dump a binary metadata file using the command `fwumd_tool.py dump <binary file>` to
+visualize the metadata in human-readable format from the binary.
+
+You can also generate a json config file from binary data using the command `fwumd_tool.py binparse <binary file>`.
+It will generate json data in which names are automatically generated.
+
+Passing the option `--template <jsonfile>` to binparse allows the tool to get the config from the given json file,
+and will mimic the number of images, the number of banks, and the names given to images, banks, location.
+
+### Test reproducible binary metadata
+Passing these commands should end up with matching checksum.
+```bash
+./fwumd_tool.py dummy
+./fwumd_tool.py binparse dummy.bin -j dummy2.json
+./fwumd_tool.py jsonparse dummy2.json -b dummy2.bin
+shasum dummy.bin dummy2.bin
+```
+
+## Propositions, precepts, thoughts
+- Endianness of the data contained in the struct has to either be fixed, or defined in the "configs" section of the metadata and embedded into the binary metadata
+- Discussions has been made to embed configs into the binary metadata directly, allowing for much easier validation of the data and less prone to errors
+- A list of wanted features to ease scripting with the tool should be made.
+- PEP8 rules have been applied as much as possible on the code, as well as comments & docstrings.
+
+## TODO
+- Verify CRC32 of binary metadata file
+
+## Json examples
+### Dummy JSON metadata
+```json
+{
+    "metadata": {
+        "version": 0,
+        "active_index": 1,
+        "previous_active_index": 0,
+        "img_entry": {
+            "img_0": {
+                "location": "sda",
+                "img_bank_info": {
+                    "img_0_bank_0": {
+                        "accepted": true,
+                        "reserved": 101
+                    },
+                    "img_0_bank_1": {
+                        "accepted": false,
+                        "reserved": 102
+                    }
+                }
+            }
+        }
+    },
+    "uuids": {
+        "locations": {
+            "sda": "7e93078a-2dc2-4657-b496-eaf638247c5b"
+        },
+        "entries": {
+            "img_0_bank_0": "c31fe18a-9408-49b5-a647-03113b85dc58",
+            "img_0_bank_1": "d4ccc9b2-58a0-46ed-beeb-1f37059db676",
+            "img_0": "50833315-fe46-4eb1-8c4a-b38d03684f7f"
+        }
+    },
+    "configs": {
+        "nb_fw_img": 1,
+        "nb_fw_banks": 2
+    }
+}
+```
diff --git a/tools/fwu_gen_metadata/fwumd_tool.py b/tools/fwu_gen_metadata/fwumd_tool.py
new file mode 100755
index 0000000000..6a79223f8b
--- /dev/null
+++ b/tools/fwu_gen_metadata/fwumd_tool.py
@@ -0,0 +1,181 @@
+#!/usr/bin/env python3
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    CLI tool to interact with the 'fwu_metadata' data structure
+    Contains files for:
+        - fwumd_tool.py:    CLI management
+        - src/metadata.py:  Python dict fwu_metadata
+        - src/structs.py:   C-style struct fwu_metadata
+        - src/utils.py:     Useful functions for all project
+        - src/uuid_t.py:    Class & functions to deal with UUID
+"""
+
+import json
+import argparse
+
+from src.uuid_t import test_uuids
+from src.utils import test_utils
+from src.metadata import create_dummy_metadata, validate_metadata
+from src.structs import fwupd_from_dict, fwupd_to_dict
+
+# COMMAND LINE
+
+def cli_dummy(dummy_args):
+    """
+        Routine for the command "dummy" passed in CLI
+    """
+    try:
+        dummy_metadata = create_dummy_metadata(dummy_args.nb_fw_imgs, dummy_args.nb_banks)
+        assert validate_metadata(dummy_metadata)
+        fwupd = fwupd_from_dict(dummy_metadata)
+        if dummy_args.display:
+            fwupd.display()
+        json.dump(dummy_metadata, dummy_args.jsonfile, indent=4)
+        dummy_args.binfile.write(fwupd)
+    finally:
+        dummy_args.jsonfile.close()
+        dummy_args.binfile.close()
+
+def cli_jsonparse(jsonparse_args):
+    """
+        Routine for the command "jsonparse" passed in CLI
+    """
+    try:
+        data = json.load(jsonparse_args.jsonfile)
+        if not validate_metadata(data):
+            raise Exception("Metadata contained in file are not correct")
+        fwupd = fwupd_from_dict(data)
+        if jsonparse_args.display:
+            fwupd.display()
+        jsonparse_args.binfile.write(fwupd)
+    finally:
+        jsonparse_args.jsonfile.close()
+        jsonparse_args.binfile.close()
+
+def cli_binparse(binparse_args):
+    """
+        Routine for the command "binparse" passed in CLI
+    """
+    template_data = {"uuids": {"locations": {}, "entries": {}}}
+    dummy_metadata = create_dummy_metadata(binparse_args.nb_fw_imgs, binparse_args.nb_banks)
+    assert validate_metadata(dummy_metadata)
+    fwupd = fwupd_from_dict(dummy_metadata)
+    binparse_args.binfile.readinto(fwupd)
+    if binparse_args.display:
+        fwupd.display()
+    data = fwupd_to_dict(fwupd, binparse_args.nb_fw_imgs,
+                         binparse_args.nb_banks,
+                         list(template_data["uuids"]["entries"].keys()),
+                         template_data["uuids"]["locations"])
+    json.dump(data, binparse_args.jsonfile, indent=4)
+
+    binparse_args.binfile.close()
+    binparse_args.jsonfile.close()
+
+def cli_dump(dump_args):
+    """
+        Routine for the "Dump" command passed in CLI
+    """
+    try:
+        dummy_metadata = create_dummy_metadata(dump_args.nb_fw_imgs, dump_args.nb_banks)
+        fwupd = fwupd_from_dict(dummy_metadata)
+        dump_args.binfile.readinto(fwupd)
+        fwupd.display()
+    finally:
+        dump_args.binfile.close()
+
+def cli_test(test_args):
+    """ Routine for the "Test" command passed in CLI """
+    all_tests = [("Utils", test_utils), ("UUIDs", test_uuids)]
+    if test_args.number == -1:
+        for (key, test) in all_tests:
+            print("Test " + key)
+            test(test_args)
+            print("")
+    elif test_args.number < len(all_tests):
+        print("Test " + all_tests[test_args.number][0])
+        all_tests[test_args.number][1](test_args)
+    else:
+        print("Tests available:")
+        for nbtest, (test, _) in enumerate(all_tests):
+            print("\t{} - Test {}".format(nbtest, test))
+
+def cli():
+    """ Function parsing args, dispatching commands """
+    parser = argparse.ArgumentParser()
+    subp = parser.add_subparsers(dest="cmd")
+
+    # GENERAL ARGS
+    parser.add_argument("--nb-fw-imgs", "-ni", default=1, type=int,
+                        help="Number of firmware images in entries")
+    parser.add_argument("--nb-banks", "-nb", default=2, type=int,
+                        help="Number of firmware banks for each image")
+
+    # DUMMY
+    dummy = subp.add_parser("dummy",
+                            help="Create a JSON metadata and a binary metadata dummy files")
+    dummy.add_argument("--display", "-v", action="store_true",
+                       help="Display the content of the binary metadata after creation")
+    dummy.add_argument("--jsonfile", "-j", type=argparse.FileType("w"),
+                       default="dummy.json",
+                       help="The JSON file where to write the dummy metadata")
+    dummy.add_argument("--binfile", "-b", type=argparse.FileType("wb"),
+                       default="dummy.bin",
+                       help="The binary file where to write the dummy metadata")
+
+    # JSON PARSE
+    jsparse = subp.add_parser("jsonparse",
+                              help="Parse json and creates a binary metadata file")
+    jsparse.add_argument("jsonfile", type=argparse.FileType("r"),
+                         help="The JSON file where to read the metadata from")
+    jsparse.add_argument("--display", "-v", action="store_true",
+                         help="Display the content of the binary metadata after creation")
+    jsparse.add_argument("--binfile", "-b", type=argparse.FileType("wb"),
+                         default="fwupd.bin",
+                         help="The binary file where to write the binary metadata")
+
+    # BINPARSE
+    binparse = subp.add_parser("binparse",
+                               help="Parse binary data and generates a JSON metadata file")
+    binparse.add_argument("binfile", type=argparse.FileType("rb"),
+                          help="The binary file where to read the metadata from")
+    binparse.add_argument("--display", "-v", action="store_true",
+                          help="Display the content of the binary metadata after creation")
+    binparse.add_argument("--jsonfile", "-j", type=argparse.FileType("w"),
+                          default="fwupd.json",
+                          help="The JSON file where to write the generated JSON metadata")
+
+    # DUMP
+    dump = subp.add_parser("dump",
+                           help="Read a binary metadata file and prints its data")
+    dump.add_argument("binfile", type=argparse.FileType("rb"),
+                      help="The binary file where to read the metadata from")
+
+    # TEST
+    test = subp.add_parser("test",
+                           help="Perform validation tests on the tool")
+    test.add_argument("--number", "-n", type=int, default=-1,
+                      help="The test nb to perform (default: all)")
+
+    args = parser.parse_args()
+
+    # Dispatch commands
+    if args.cmd == "dummy":
+        cli_dummy(args)
+    elif args.cmd == "jsonparse":
+        cli_jsonparse(args)
+    elif args.cmd == "binparse":
+        cli_binparse(args)
+    elif args.cmd == "dump":
+        cli_dump(args)
+    elif args.cmd == "test":
+        cli_test(args)
+    else:
+        # If no command passed, considered as faulty, print help
+        parser.print_help()
+
+if __name__ == "__main__":
+    cli()
diff --git a/tools/fwu_gen_metadata/src/metadata.py b/tools/fwu_gen_metadata/src/metadata.py
new file mode 100644
index 0000000000..aa31f35ad7
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/metadata.py
@@ -0,0 +1,102 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    metadata.py
+        Manage Python dict formatted fwu_metadata
+"""
+import uuid
+
+def create_dummy_metadata(nb_fw_img, nb_fw_banks):
+    """
+        This function creates a Python dict containing dummy metadata
+        Used for testing or for placeholding
+    """
+    data = {
+        "metadata": {
+            "version": 0,
+            "active_index": 1,
+            "previous_active_index": 0,
+            "img_entry": {}
+        },
+        "uuids": {
+            "locations": {
+                "sda": str(uuid.uuid4()),
+            },
+            "entries": {},
+        },
+        "configs": {
+            "nb_fw_img": nb_fw_img,
+            "nb_fw_banks": nb_fw_banks
+        }
+    }
+
+    entries = {}
+    for nimg in range(nb_fw_img):
+        banks = {}
+        for nbnk in range(nb_fw_banks):
+            entry_name = "img_" + str(nimg) + "_bank_" + str(nbnk)
+            banks[entry_name] = {"accepted": True,
+                                 "reserved": 0}
+            data["uuids"]["entries"][entry_name] = str(uuid.uuid4())
+
+        entries["img_" + str(nimg)] = {
+            "location": "sda",
+            "img_bank_info": banks
+        }
+        data["uuids"]["entries"]["img_" + str(nimg)] = str(uuid.uuid4())
+    data["metadata"]["img_entry"] = entries
+    return data
+
+def __check_md(res, cond, msg):
+    """
+        Helper function used to validate metadata.
+        If cond is false, return False, and display message
+    """
+    if not cond:
+        print("Metadata validation failed: '{}'".format(msg))
+        return False
+    return res
+
+def validate_metadata(metadata):
+    """
+        Validate content of a Python dict metadata
+        Passes through all the data, display errors if any,
+        then return if errors got encountered
+    """
+    res = True
+
+    for key in ["metadata", "uuids", "configs"]:
+        res = __check_md(res, key in metadata.keys(),
+                         "Key missing: {}".format(key))
+    for conf in ["nb_fw_img", "nb_fw_banks"]:
+        res = __check_md(res, conf in metadata["configs"].keys(), "Config missing: {}".format(conf))
+
+    res = __check_md(res, "locations" in metadata["uuids"].keys(), "UUID type location missing")
+    res = __check_md(res, "entries" in metadata["uuids"].keys(), "UUID type entries missing")
+    res = __check_md(res,
+                     len(metadata["metadata"]["img_entry"].keys()) ==
+                     metadata["configs"]["nb_fw_img"],
+                     "Wrong number of firmware images entries")
+
+    for iname, img in metadata["metadata"]["img_entry"].items():
+        res = __check_md(res, iname in metadata["uuids"]["entries"].keys(),
+                         "Image {} UUID not known".format(iname))
+
+        res = __check_md(res,
+                         img["location"] in metadata["uuids"]["locations"].keys(),
+                         "Location {} UUID not known".format(img["location"]))
+
+        res = __check_md(res,
+                         len(metadata["metadata"]["img_entry"] [iname]["img_bank_info"].keys()) ==
+                         metadata["configs"]["nb_fw_banks"],
+                         "Wrong number of banks for image {}".format(iname))
+
+        for bname, _ in metadata["metadata"]["img_entry"][iname]["img_bank_info"].items():
+            res = __check_md(res, bname in metadata["uuids"]["entries"],
+                             "Bank {} UUID not known".format(bname))
+            res = __check_md(res, iname + "_bank_" in bname,
+                             "Bank name wrongly named")
+
+    return res
diff --git a/tools/fwu_gen_metadata/src/structs.py b/tools/fwu_gen_metadata/src/structs.py
new file mode 100644
index 0000000000..0e58bbecdb
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/structs.py
@@ -0,0 +1,262 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    structs.py
+        Manage C-style struct formatted fwu_metadata
+"""
+
+import binascii
+
+from ctypes import Structure, c_uint32, c_uint16, c_uint8, Array
+
+from src.uuid_t import uuid_t, get_uuids, uuid_t_from_str
+from src.utils import get_template_location_key
+
+# IMAGE BANK
+
+class image_bank_info(Structure):
+    """
+        Image bank C struct
+    """
+    _fields_ = [
+        ("img_uuid", uuid_t),
+        ("accepted", c_uint32),
+        ("reserved", c_uint32),
+    ]
+
+    def from_metadata(self, bank_name, bank, uuids):
+        """
+            Use Python-dict metadata to generate the Python / C-struct object
+        """
+        self.img_uuid = uuid_t_from_str(get_uuids(uuids["entries"], bank_name))
+        self.accepted = bank["accepted"]
+        self.reserved = bank.get("reserved", 0) #default value 0 if not in json
+
+    def display(self, buff):
+        """
+            Helper function to render the data of the bank in a buffer
+        """
+        buff += "\t\t  Image UUID: {}\n".format(str(self.img_uuid))
+        buff += "\t\t  Accepted: {}\n".format(self.accepted)
+        buff += "\t\t  Reserved: {}\n".format(self.reserved)
+        return buff
+
+    def to_dict(self, bankname, bank, uuids):
+        """
+            Helper function to add the data contained into dicts
+        """
+        uuids["entries"][bankname] = str(self.img_uuid)
+        bank["accepted"] = bool(self.accepted)
+        bank["reserved"] = self.reserved
+
+# IMAGE ENTRY
+def get_struct_imgentry(nb_fw_banks):
+    """
+        As the structure depend on a variable parameter, the Python class is
+        generated at runtime, allowing to not rely on global variables
+    """
+    class image_entry(Structure):
+        """
+            Image entry C struct
+        """
+        _fields_ = [
+            ("img_type_uuid", uuid_t),
+            ("location_uuid", uuid_t),
+            ("img_bank_info", image_bank_info * nb_fw_banks),
+        ]
+
+        def from_metadata(self, img_name, entry, uuids):
+            """
+                Generate this Python / C-struct object from Python dict
+                metadata
+            """
+            self.img_type_uuid = uuid_t_from_str(
+                get_uuids(uuids["entries"], img_name))
+            self.location_uuid = uuid_t_from_str(get_uuids(uuids["locations"], entry["location"]))
+            for n, (bank_name, bank) in enumerate(entry["img_bank_info"].items()):
+                self.img_bank_info[n].from_metadata(bank_name, bank, uuids)
+
+        def display(self, buff):
+            """
+                Render the data contained inside a buffer
+            """
+            buff += "\t  Image type UUID: {}\n".format(str(self.img_type_uuid))
+            buff += "\t  Location UUID: {}\n".format(str(self.location_uuid))
+            buff += "\t  --- Banks ---\n"
+            for n, bank in enumerate(self.img_bank_info):
+                buff += "\t\tBank {}\n".format(n)
+                buff = bank.display(buff)
+            return buff
+
+        def to_dict(self, imgname, entry, uuids, imgkeys, loc_uuids):
+            """
+                Helper function to add this struct's data into Python dict
+                metadata
+            """
+            uuids["entries"][imgname] = str(self.img_type_uuid)
+            location_uuid_str = str(self.location_uuid)
+            loc_key = get_template_location_key(loc_uuids, location_uuid_str)
+            entry["location"] = loc_key
+            uuids["locations"][loc_key] = location_uuid_str
+            banks = {}
+            for b, bank in enumerate(self.img_bank_info):
+                bname = imgname + "_bank_" + str(b)
+                banks[bname] = {}
+                bank.to_dict(bname, banks[bname], uuids)
+            entry["img_bank_info"] = banks
+
+    return image_entry
+
+# FWU-Metadata struct creation
+def generate_fwu_metadata(nb_fw_img, nb_fw_banks):
+    """
+        Generate an empty FWU-Metadata object from the given parameters
+    """
+    class fwu_metadata(Structure):
+        """
+            FWU Metadata C struct (parent struct)
+        """
+        _fields_ = [
+            ("crc_32", c_uint32),
+            ("version", c_uint32),
+            ("active_index", c_uint32),
+            ("previous_active_index", c_uint32),
+            ("img_entry", get_struct_imgentry(nb_fw_banks) * nb_fw_img)
+        ]
+
+        def update_crc32(self):
+            """
+                Compute and update the CRC32 from the data contained
+            """
+            self.crc_32 = binascii.crc32(bytearray(self)[4:])
+
+        def from_metadata(self, metadata, uuids):
+            """
+                Update the contained metadata from given Python dict
+            """
+            self.version = metadata["version"]
+            self.active_index = metadata["active_index"]
+            self.previous_active_index = metadata["previous_active_index"]
+            for n, (img_name, img) in enumerate(metadata["img_entry"].items()):
+                self.img_entry[n].from_metadata(img_name, img, uuids)
+            self.update_crc32()
+
+        def display(self):
+            """
+                Prints a text-rendered display of the data contained
+            """
+            buff = "METADATA\n"
+            buff += "  CRC32: {}\n".format(self.crc_32)
+            buff += "  Version: {}\n".format(self.version)
+            buff += "  Active index: {}\n".format(self.active_index)
+            buff += "  Previous active index: {}\n".format(
+                self.previous_active_index)
+            buff += "  --- Image entries ---\n"
+            for n, img in enumerate(self.img_entry):
+                buff += "\tEntry {}\n".format(n)
+                buff = img.display(buff)
+            print(buff)
+
+        def to_dict(self, metadata, uuids, imgkeys, loc_uuids):
+            """
+                Pass the data contained in this object into Python dicts
+            """
+            metadata["crc_32"] = self.crc_32
+            metadata["version"] = self.version
+            metadata["active_index"] = self.active_index
+            metadata["previous_active_index"] = self.previous_active_index
+            entries = {}
+            for n, img in enumerate(self.img_entry):
+                iname = imgkeys[n]
+                entries[iname] = {}
+                img.to_dict(iname, entries[iname], uuids, imgkeys, loc_uuids)
+            metadata["img_entry"] = entries
+
+    return fwu_metadata()
+
+def fwupd_from_dict(data):
+    """
+        Return a fwu_metadata object from a complete Python dict as saved in
+        the JSON file
+    """
+    fwupd = generate_fwu_metadata(
+        data["configs"]["nb_fw_img"],
+        data["configs"]["nb_fw_banks"])
+    fwupd.from_metadata(data["metadata"], data["uuids"])
+    return fwupd
+
+def fwupd_to_dict(fwupd, nb_fw_imgs, nb_banks, images_keys, loc_uuids):
+    """
+        Create a Python dict containing all the information contained in a
+        fwu_metadata object
+    """
+    data = {"metadata": {}, "uuids": {"locations": {}, "entries": {}},
+            "configs": {
+                "nb_fw_img": nb_fw_imgs,
+                "nb_fw_banks": nb_banks
+            },
+           }
+    images_keys += ["img_" + str(n) for n in range(max(0, nb_fw_imgs - len(images_keys)))]
+
+    fwupd.to_dict(data["metadata"], data["uuids"], images_keys, loc_uuids)
+    return data
+
+def __check_same(res, name, mdel, binel):
+    """
+        Helper function for binary metadata cross-validation with JSON
+
+        If @mdel (JSON) and @binel (Binary) are not the same, return False
+            and display a formatted error with the given @name.
+        Else return @res
+    """
+    if str(mdel) != str(binel):
+        print("Element '{}' are not the same in metadata and binary data".format(name))
+        return False
+    else:
+        return res
+
+def validate_fwupd_and_dict(md, fwupd):
+    """
+        Validation function for binary + JSON metadata
+        Ensure the data of the both formats are the same
+
+        Do not check CRC32
+    """
+    res = True
+
+    # Check elements of fwu_metadata struct
+    for key in ["version", "active_index", "previous_active_index"]:
+        res = __check_same(res, key, md["metadata"][key], getattr(fwupd, key))
+
+    # Check elements in each image entry
+    for n, (img_name, img) in enumerate(md["metadata"]["img_entry"].items()):
+        entry = fwupd.img_entry[n]
+
+        res = __check_same(res, "Image {} type UUID".format(img_name),
+                           md["uuids"]["entries"][img_name],
+                           entry.img_type_uuid)
+
+        res = __check_same(res, "Location UUID",
+                           md["uuids"]["locations"][img["location"]],
+                           entry.location_uuid)
+
+        # Check elements in each banks of image entry
+        for b, (bname, bank) in enumerate(img["img_bank_info"].items()):
+            fwbank = entry.img_bank_info[b]
+            res = __check_same(res, "Image {} Bank {} UUID".format(
+                                                            img_name, b),
+                               md["uuids"]["entries"][bname],
+                               fwbank.img_uuid)
+
+            res = __check_same(res, "Image {} Bank {} Accepted".format(
+                                                                img_name, b),
+                               bank["accepted"],
+                               bool(fwbank.accepted))
+
+            res = __check_same(res, "Image {} Bank {} Reserved field".format(
+                                                                img_name, b),
+                               bank["reserved"],
+                               fwbank.reserved)
+    return res
diff --git a/tools/fwu_gen_metadata/src/utils.py b/tools/fwu_gen_metadata/src/utils.py
new file mode 100644
index 0000000000..e994e9a38f
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/utils.py
@@ -0,0 +1,69 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+"""
+    utils.py
+        Useful functions for the whole project
+"""
+from ctypes import c_uint8
+
+# Number manipulation
+def uint8array_to_number(uint8array):
+    """ Convert array of uint8_t into a single Python number """
+    return sum([x << (i*8) for i, x in enumerate(reversed(uint8array))])
+
+def number_to_uint8array(number, array_length):
+    """ Convert a single Python number into an array of uint8_t """
+    uint8array = c_uint8 * array_length
+    array = [(number & (0xff << (n*8))) >> (n*8)
+        for n in reversed(range(array_length))
+    ]
+    return uint8array(*array)
+
+def test_number_to_array(args):
+    """ Test back and forth conversion works for our use case"""
+    numbers = [0x42053497, 0x45]
+    for number in numbers:
+        a = number_to_uint8array(number, 4)
+        n = uint8array_to_number(a)
+        print_and_assert(number, n)
+
+# Default values creation
+def get_template_location_key(locations, uuid):
+    """
+        Get the location key of the given location.
+        If it doesn't exist, generate one from the UUID
+    """
+    if uuid in locations.values():
+        return [key for key, val in locations.items() if val == uuid][0]
+    else:
+        key = "loc_" + uuid.replace("-", "_")
+        locations[key] = uuid
+        return key
+
+def test_template_location_key(args):
+    """ Test location key getter works well """
+    print_and_assert(get_template_location_key({"sda": "uuid"}, "uuid"),
+                     "sda")
+    print_and_assert(get_template_location_key({"sda": "uuid"}, "new"),
+                     "loc_new")
+    print_and_assert(get_template_location_key({"sda": "uuid"}, "sda-2"),
+                     "loc_sda_2")
+
+# Testing utils
+def print_and_assert(el1, el2):
+    """ Print the two values to test, then assert their equality"""
+    print(el1, "==", el2)
+    assert el1 == el2
+
+def test_utils(args):
+    all_tests = {
+        "Number to array": test_number_to_array,
+        "Template location key": test_template_location_key
+    }
+
+    for (key, test) in all_tests.items():
+        print("--- Test " + key)
+        test(args)
+        print("---\n")
diff --git a/tools/fwu_gen_metadata/src/uuid_t.py b/tools/fwu_gen_metadata/src/uuid_t.py
new file mode 100644
index 0000000000..8f9a891af1
--- /dev/null
+++ b/tools/fwu_gen_metadata/src/uuid_t.py
@@ -0,0 +1,79 @@
+# Copyright (c) 2022, STMicroelectronics - All Rights Reserved
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+import uuid
+from ctypes import Structure, c_uint32, c_uint16, c_uint8, Array
+
+from src.utils import uint8array_to_number, number_to_uint8array
+from src.utils import print_and_assert
+
+UUID_NODE_LEN = 6
+UUID_STR_LEN = 24 + (UUID_NODE_LEN*2)
+
+# UUIDS
+
+class uuid_t(Structure):
+    """
+        C-style struct for the UUID data
+    """
+    _fields_ = [
+        ("time_low", c_uint32),
+        ("time_mid", c_uint16),
+        ("time_hi_and_version", c_uint16),
+        ("clock_seq_hi_and_reserved", c_uint8),
+        ("clock_seq_low", c_uint8),
+        ("node", c_uint8 * UUID_NODE_LEN)
+    ]
+
+    def to_uuid_class(self):
+        """
+            Helper function to convert the Python / C struct into the class
+                UUID from the library uuid, much easier to use.
+        """
+        return uuid.UUID(fields=(
+            self.time_low, self.time_mid, self.time_hi_and_version,
+            self.clock_seq_hi_and_reserved, self.clock_seq_low,
+            uint8array_to_number(self.node)))
+
+    def __str__(self):
+        """ Display this class as a normalized UUID string """
+        return self.to_uuid_class().__str__()
+
+def uuid_t_from_str(uuid_str):
+    """
+        Generate a Python / C-struct uuid_t class from a normalized uuid string
+    """
+    if len(uuid_str) != UUID_STR_LEN:
+        raise Exception("Wrong formatted UUID str: {}".format(uuid_str))
+    obj = uuid.UUID(uuid_str)
+    return uuid_t(
+        obj.time_low,
+        obj.time_mid,
+        obj.time_hi_version,
+        obj.clock_seq_hi_variant,
+        obj.clock_seq_low,
+        number_to_uint8array(obj.node, UUID_NODE_LEN))
+
+def get_uuids(uuids, key):
+    """
+        Get the UUID of a certain key, generate a new one if none is
+        found for the key
+    """
+    # TODO   Is there a context in which auto-generation of missing UUID
+    #           is not desirable ?
+    if key not in uuids.keys():
+        uuids[key] = str(uuid.uuid4())
+    return uuids[key]
+
+def validate_uuid(uuid_str):
+    try:
+        uuid.UUID(uuid_str)
+        return True
+    except ValueError:
+        return False
+
+def test_uuids(args):
+    uuid_str = "737d3401-64c1-4584-a40d-29f2238c82cf"
+    uuid_t = uuid_t_from_str(uuid_str)
+    print_and_assert(str(uuid_t), uuid_str)
diff --git a/tools/fwu_gen_metadata/tests/testall.sh b/tools/fwu_gen_metadata/tests/testall.sh
new file mode 100755
index 0000000000..7b3050d3fb
--- /dev/null
+++ b/tools/fwu_gen_metadata/tests/testall.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+VERBOSE=0
+SEPARATOR="\033[94m-------------------------------------------------------------------------\033[0m"
+if [ $VERBOSE -eq 1 ]; then
+	set -eux
+	OPTS=-v
+else
+	set -e
+	OPTS=
+fi
+
+rm -f dummy.bin dummy.json a.bin a.json
+
+../fwumd_tool.py dummy $OPTS
+echo -e "$SEPARATOR"
+../fwumd_tool.py jsonparse $OPTS dummy.json -b a.bin
+echo -e "$SEPARATOR"
+../fwumd_tool.py binparse $OPTS dummy.bin -j a.json
+echo -e "$SEPARATOR"
+../fwumd_tool.py test $OPTS
diff --git a/tools/fwu_gen_metadata/tests/validate_stable.sh b/tools/fwu_gen_metadata/tests/validate_stable.sh
new file mode 100755
index 0000000000..957a833b6a
--- /dev/null
+++ b/tools/fwu_gen_metadata/tests/validate_stable.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+
+set -e
+rm -f dummy*
+../fwumd_tool.py dummy
+../fwumd_tool.py binparse dummy.bin -j dummy2.json
+../fwumd_tool.py jsonparse dummy2.json -b dummy2.bin
+shasum dummy*.bin
diff --git a/tools/nxp/plat_fiptool/plat_fiptool.mk b/tools/nxp/plat_fiptool/plat_fiptool.mk
deleted file mode 100644
index ca2962a045..0000000000
--- a/tools/nxp/plat_fiptool/plat_fiptool.mk
+++ /dev/null
@@ -1,33 +0,0 @@
-#
-# Copyright (c) 2021, NXP. All rights reserved.
-#
-# SPDX-License-Identifier: BSD-3-Clause
-#
-
-# Name of the platform defined source file name,
-# which contains platform defined UUID entries populated
-# in the plat_def_toc_entries[].
-PLAT_DEF_UUID_CONFIG_FILE_NAME	:= plat_def_uuid_config
-
-PLAT_DEF_UUID_CONFIG_FILE_PATH := ../nxp/plat_fiptool
-
-PLAT_DEF_OID := yes
-PLAT_DEF_UUID := yes
-PLAT_DEF_UUID_OID_CONFIG_PATH := ../../plat/nxp/common/fip_handler/common
-
-
-INCLUDE_PATHS += -I${PLAT_DEF_UUID_OID_CONFIG_PATH} \
-		 -I./
-# Clean the stale object file.
-$(shell rm ${PLAT_DEF_UUID_CONFIG_FILE_PATH}/${PLAT_DEF_UUID_CONFIG_FILE_NAME}.o)
-
-ifeq (${PLAT_DEF_OID},yes)
-HOSTCCFLAGS += -DPLAT_DEF_OID
-endif
-
-ifeq (${PLAT_DEF_UUID},yes)
-HOSTCCFLAGS += -DPLAT_DEF_FIP_UUID
-PLAT_OBJECTS += ${PLAT_DEF_UUID_CONFIG_FILE_PATH}/${PLAT_DEF_UUID_CONFIG_FILE_NAME}.o
-endif
-
-OBJECTS += ${PLAT_OBJECTS}
-- 
2.34.1


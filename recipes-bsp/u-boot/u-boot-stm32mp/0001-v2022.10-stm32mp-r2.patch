From dc5d7824fca14584a05723f507a9576f032c234d Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
Date: Fri, 12 Apr 2024 14:34:37 +0200
Subject: [PATCH] v2022.10-stm32mp-r2

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@foss.st.com>
---
 CONTRIBUTING.md                               |   30 +
 MAINTAINERS                                   |   18 +-
 Makefile                                      |   11 +-
 SECURITY.md                                   |    8 +
 arch/arm/Kconfig                              |    2 +-
 arch/arm/dts/Makefile                         |   23 +-
 arch/arm/dts/stm32429i-eval-u-boot.dtsi       |    2 +-
 arch/arm/dts/stm32746g-eval.dts               |   18 +-
 arch/arm/dts/stm32f4-pinctrl.dtsi             |    2 +-
 arch/arm/dts/stm32f429-disco-u-boot.dtsi      |    8 +-
 arch/arm/dts/stm32f429-disco.dts              |   20 +-
 arch/arm/dts/stm32f429-pinctrl.dtsi           |   94 +-
 arch/arm/dts/stm32f429.dtsi                   |   69 +-
 arch/arm/dts/stm32f469-disco-u-boot.dtsi      |    7 +-
 arch/arm/dts/stm32f469-disco.dts              |   24 +-
 arch/arm/dts/stm32f469-pinctrl.dtsi           |   96 +-
 arch/arm/dts/stm32f7-pinctrl.dtsi             |    2 +-
 arch/arm/dts/stm32f7-u-boot.dtsi              |    2 +-
 arch/arm/dts/stm32f746-disco.dts              |   12 +
 arch/arm/dts/stm32f746.dtsi                   |   67 +-
 arch/arm/dts/stm32f769-disco.dts              |   18 +-
 arch/arm/dts/stm32h743.dtsi                   |   17 +-
 arch/arm/dts/stm32h743i-disco.dts             |    8 +-
 arch/arm/dts/stm32h743i-eval.dts              |    8 +-
 arch/arm/dts/stm32h750i-art-pi.dts            |    8 +-
 arch/arm/dts/stm32mp13-pinctrl.dtsi           |  501 +++
 arch/arm/dts/stm32mp13-u-boot.dtsi            |   30 +-
 arch/arm/dts/stm32mp131.dtsi                  | 1809 ++++++++-
 arch/arm/dts/stm32mp133.dtsi                  |   71 +-
 arch/arm/dts/stm32mp135.dtsi                  |   24 +
 arch/arm/dts/stm32mp135f-dk-u-boot.dtsi       |   24 +-
 arch/arm/dts/stm32mp135f-dk.dts               |  617 ++-
 arch/arm/dts/stm32mp13xa.dtsi                 |    5 +
 arch/arm/dts/stm32mp13xc.dtsi                 |   19 +-
 arch/arm/dts/stm32mp13xd.dtsi                 |    5 +
 arch/arm/dts/stm32mp13xf.dtsi                 |   19 +-
 arch/arm/dts/stm32mp15-ddr.dtsi               |   16 +
 arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi    |  524 +++
 arch/arm/dts/stm32mp15-m4-srm.dtsi            |  447 +++
 arch/arm/dts/stm32mp15-pinctrl.dtsi           |  402 +-
 arch/arm/dts/stm32mp15-scmi-u-boot.dtsi       |   22 +-
 arch/arm/dts/stm32mp15-scmi.dtsi              |   72 -
 arch/arm/dts/stm32mp15-u-boot.dtsi            |   20 +-
 arch/arm/dts/stm32mp151.dtsi                  | 3338 ++++++++++-------
 arch/arm/dts/stm32mp153.dtsi                  |   53 +-
 arch/arm/dts/stm32mp157.dtsi                  |   10 +-
 arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi |   57 -
 ...dk1-scmi.dts => stm32mp157a-dk1-scmi.dtsi} |   20 +-
 arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi      |  166 +-
 arch/arm/dts/stm32mp157a-dk1.dts              |    5 +-
 arch/arm/dts/stm32mp157a-ed1-scmi.dtsi        |   94 +
 arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157a-ed1.dts              |  433 +++
 arch/arm/dts/stm32mp157a-ev1-scmi.dtsi        |   91 +
 arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157a-ev1.dts              |  798 ++++
 ...157a-microgea-stm32mp1-microdev2.0-of7.dts |    3 +-
 ...dk2-scmi.dts => stm32mp157c-dk2-scmi.dtsi} |   25 +-
 arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi      |   15 +-
 arch/arm/dts/stm32mp157c-dk2.dts              |   76 +-
 arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi |   47 -
 ...ed1-scmi.dts => stm32mp157c-ed1-scmi.dtsi} |   29 +-
 arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi      |  193 +-
 arch/arm/dts/stm32mp157c-ed1.dts              |   85 +-
 arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi |   17 -
 ...ev1-scmi.dts => stm32mp157c-ev1-scmi.dtsi} |   28 +-
 arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi      |  117 +-
 arch/arm/dts/stm32mp157c-ev1.dts              |  437 ++-
 ...-boot.dtsi => stm32mp157d-dk1-u-boot.dtsi} |    2 +-
 arch/arm/dts/stm32mp157d-dk1.dts              |   27 +
 arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157d-ed1.dts              |  441 +++
 arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157d-ev1.dts              |  798 ++++
 arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi      |   10 +
 arch/arm/dts/stm32mp157f-dk2.dts              |  171 +
 arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157f-ed1.dts              |  445 +++
 arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi      |    6 +
 arch/arm/dts/stm32mp157f-ev1.dts              |  811 ++++
 arch/arm/dts/stm32mp15xa.dtsi                 |    5 +
 arch/arm/dts/stm32mp15xc.dtsi                 |   22 +-
 arch/arm/dts/stm32mp15xd.dtsi                 |   28 +
 arch/arm/dts/stm32mp15xf.dtsi                 |   26 +
 arch/arm/dts/stm32mp15xx-dhcom-som.dtsi       |   20 +-
 arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi    |   44 +-
 .../stm32mp15xx-dhcor-avenger96-u-boot.dtsi   |    5 +-
 arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi |   34 +-
 arch/arm/dts/stm32mp15xx-dhcor-som.dtsi       |    8 +-
 .../stm32mp15xx-dhcor-testbench-u-boot.dtsi   |  100 +
 arch/arm/dts/stm32mp15xx-dhcor-testbench.dts  |  178 +
 arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi    |   44 +-
 arch/arm/dts/stm32mp15xx-dkx.dtsi             |  166 +-
 arch/arm/dts/stm32mp25-pinctrl.dtsi           |  971 +++++
 arch/arm/dts/stm32mp25-u-boot.dtsi            |  129 +
 arch/arm/dts/stm32mp251.dtsi                  | 3178 ++++++++++++++++
 arch/arm/dts/stm32mp253.dtsi                  |  183 +
 arch/arm/dts/stm32mp255.dtsi                  |   80 +
 arch/arm/dts/stm32mp257.dtsi                  |   54 +
 .../dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi  |  167 +
 arch/arm/dts/stm32mp257f-dk-u-boot.dtsi       |   48 +
 arch/arm/dts/stm32mp257f-dk.dts               |  754 ++++
 .../dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi |  171 +
 arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi      |   86 +
 arch/arm/dts/stm32mp257f-ev1.dts              |  825 ++++
 arch/arm/dts/stm32mp25xc.dtsi                 |   36 +
 arch/arm/dts/stm32mp25xf.dtsi                 |   36 +
 arch/arm/dts/stm32mp25xxai-pinctrl.dtsi       |   83 +
 arch/arm/dts/stm32mp25xxak-pinctrl.dtsi       |   71 +
 arch/arm/dts/stm32mp25xxal-pinctrl.dtsi       |   71 +
 arch/arm/include/asm/arch-stm32f7/stm32.h     |    6 +-
 arch/arm/include/asm/system.h                 |   16 +-
 arch/arm/mach-stm32mp/Kconfig                 |   53 +-
 arch/arm/mach-stm32mp/Kconfig.13x             |    6 +-
 arch/arm/mach-stm32mp/Kconfig.15x             |   14 +-
 arch/arm/mach-stm32mp/Kconfig.25x             |   43 +
 arch/arm/mach-stm32mp/Makefile                |   14 +-
 arch/arm/mach-stm32mp/bsec.c                  |  250 +-
 arch/arm/mach-stm32mp/cmd_stm32key.c          |  548 ++-
 arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig   |    3 +
 .../cmd_stm32prog/cmd_stm32prog.c             |   33 +-
 .../mach-stm32mp/cmd_stm32prog/stm32prog.c    |  156 +-
 .../mach-stm32mp/cmd_stm32prog/stm32prog.h    |   41 +-
 .../cmd_stm32prog/stm32prog_serial.c          |   17 +-
 .../cmd_stm32prog/stm32prog_usb.c             |    6 +-
 arch/arm/mach-stm32mp/dram_init.c             |   22 +-
 arch/arm/mach-stm32mp/etzpc.c                 |  205 +
 arch/arm/mach-stm32mp/fdt.c                   |  514 ---
 arch/arm/mach-stm32mp/include/mach/bsec.h     |    7 +
 arch/arm/mach-stm32mp/include/mach/etzpc.h    |   32 +
 arch/arm/mach-stm32mp/include/mach/rif.h      |   26 +
 arch/arm/mach-stm32mp/include/mach/stm32.h    |  194 +-
 .../mach-stm32mp/include/mach/stm32mp1_smc.h  |   48 +-
 .../arm/mach-stm32mp/include/mach/stm32prog.h |    6 -
 .../arm/mach-stm32mp/include/mach/sys_proto.h |   45 +-
 arch/arm/mach-stm32mp/nvram.c                 |  665 ++++
 arch/arm/mach-stm32mp/soc.c                   |   80 +
 arch/arm/mach-stm32mp/stm32mp1/Makefile       |   18 +
 arch/arm/mach-stm32mp/{ => stm32mp1}/cpu.c    |   58 -
 arch/arm/mach-stm32mp/stm32mp1/fdt.c          |  256 ++
 arch/arm/mach-stm32mp/{ => stm32mp1}/psci.c   |    0
 .../{ => stm32mp1}/pwr_regulator.c            |    5 +
 .../mach-stm32mp/{ => stm32mp1}/stm32mp13x.c  |    0
 .../mach-stm32mp/{ => stm32mp1}/stm32mp15x.c  |    7 +-
 arch/arm/mach-stm32mp/stm32mp2/Makefile       |   10 +
 arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c    |   69 +
 arch/arm/mach-stm32mp/stm32mp2/cpu.c          |  265 ++
 arch/arm/mach-stm32mp/stm32mp2/fdt.c          |   16 +
 arch/arm/mach-stm32mp/stm32mp2/rifsc.c        |  360 ++
 arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c   |  208 +
 arch/arm/mach-stm32mp/syscon.c                |    1 +
 arch/sandbox/Kconfig                          |    6 +
 arch/sandbox/dts/test.dts                     |    7 +-
 arch/sandbox/include/asm/gpio.h               |    3 +-
 board/dhelectronics/dh_stm32mp1/board.c       |   43 +-
 .../dh_stm32mp1/u-boot-dhcor.its              |   21 +-
 board/engicam/stm32mp1/Makefile               |    2 +
 board/engicam/stm32mp1/spl.c                  |   25 -
 board/sandbox/sandbox.c                       |   10 +-
 board/st/common/Kconfig                       |   74 +-
 board/st/common/Makefile                      |    3 +-
 board/st/common/cmd_stboard.c                 |   14 +-
 board/st/common/stm32mp_dfu.c                 |  132 +-
 board/st/common/stm32mp_dfu_virt.c            |   99 +
 board/st/common/stm32mp_mtdparts.c            |  177 -
 board/st/common/stusb160x.c                   |   48 -
 board/st/common/stusb160x.h                   |   10 -
 board/st/stm32mp1/Kconfig                     |    4 +-
 board/st/stm32mp1/Makefile                    |    2 +
 board/st/stm32mp1/debug_uart.c                |   29 +
 board/st/stm32mp1/spl.c                       |   28 -
 board/st/stm32mp1/stm32mp1.c                  |  559 ++-
 board/st/stm32mp2/Kconfig                     |   13 +
 board/st/stm32mp2/MAINTAINERS                 |   10 +
 board/st/stm32mp2/Makefile                    |    6 +
 board/st/stm32mp2/README                      |    1 +
 board/st/stm32mp2/stm32mp2.c                  |  876 +++++
 boot/pxe_utils.c                              |   78 +-
 cmd/Kconfig                                   |    8 +
 cmd/Makefile                                  |    1 +
 cmd/clk.c                                     |   21 +-
 cmd/fwu_mdata.c                               |   63 +
 cmd/gpt.c                                     |    2 -
 cmd/legacy-mtd-utils.c                        |   70 +-
 cmd/mtdparts.c                                |   90 +-
 common/Kconfig                                |   12 +
 common/Makefile                               |    1 +
 common/board_r.c                              |    6 +-
 common/event.c                                |    3 +
 common/fdt_support.c                          |   75 +-
 common/spl/spl.c                              |    3 -
 common/usb_hub.c                              |    2 +-
 common/usb_onboard_hub.c                      |   49 +
 configs/corstone1000_defconfig                |    3 +
 configs/sandbox64_defconfig                   |    7 +-
 configs/stm32746g-eval_defconfig              |    1 -
 configs/stm32746g-eval_spl_defconfig          |   10 +-
 configs/stm32f429-discovery_defconfig         |    1 -
 configs/stm32f429-evaluation_defconfig        |    1 -
 configs/stm32f469-discovery_defconfig         |    1 -
 configs/stm32f746-disco_defconfig             |    1 -
 configs/stm32f746-disco_spl_defconfig         |   10 +-
 configs/stm32f769-disco_defconfig             |    3 +-
 configs/stm32f769-disco_spl_defconfig         |   10 +-
 configs/stm32h743-disco_defconfig             |    1 -
 configs/stm32h743-eval_defconfig              |    1 -
 configs/stm32h750-art-pi_defconfig            |    1 -
 configs/stm32mp13_defconfig                   |  105 +-
 configs/stm32mp15_basic_defconfig             |   40 +-
 configs/stm32mp15_defconfig                   |   48 +-
 configs/stm32mp15_dhcom_basic_defconfig       |   16 +-
 configs/stm32mp15_dhcor_basic_defconfig       |   16 +-
 configs/stm32mp15_trusted_defconfig           |   45 +-
 configs/stm32mp25_defconfig                   |  187 +
 configs/synquacer_developerbox_defconfig      |    4 +
 configs/tools-only_defconfig                  |    1 +
 disk/part_efi.c                               |   15 +-
 doc/README.gpio                               |    6 +-
 doc/README.gpt                                |    2 +-
 doc/README.pxe                                |    8 +
 doc/README.uniphier                           |    2 +-
 doc/board/emulation/qemu-x86.rst              |    3 +-
 doc/board/st/index.rst                        |    1 +
 doc/board/st/st-dt.rst                        |    1 +
 doc/board/st/stm32mp1.rst                     |   51 +-
 doc/board/st/stm32mp2.rst                     |  544 +++
 doc/board/tbs/tbs2910.rst                     |    2 +-
 doc/develop/uefi/fwu_updates.rst              |  194 +
 doc/develop/uefi/index.rst                    |    1 +
 doc/develop/uefi/uefi.rst                     |   78 +
 .../firmware/firmware-version.txt             |   22 +
 .../firmware/fwu-mdata-gpt.yaml               |   32 +
 .../firmware/fwu-mdata-mtd.yaml               |  105 +-
 doc/mkeficapsule.1                            |   43 +-
 doc/mkfwumdata.1                              |  103 +
 doc/usage/cmd/fwu_mdata.rst                   |   43 +
 doc/usage/index.rst                           |    1 +
 drivers/Kconfig                               |    2 +
 drivers/Makefile                              |    1 +
 drivers/adc/stm32-adc-core.c                  |    1 +
 drivers/adc/stm32-adc.c                       |  493 ++-
 drivers/clk/Kconfig                           |   11 +
 drivers/clk/clk-uclass.c                      |   53 +-
 drivers/clk/clk_fixed_rate.c                  |    1 +
 drivers/clk/clk_sandbox.c                     |   35 +-
 drivers/clk/clk_sandbox_ccf.c                 |   48 +-
 drivers/clk/clk_scmi.c                        |   14 +-
 drivers/clk/stm32/Kconfig                     |   26 +-
 drivers/clk/stm32/Makefile                    |    3 +
 drivers/clk/stm32/clk-stm32-core.c            |  329 ++
 drivers/clk/stm32/clk-stm32-core.h            |  276 ++
 drivers/clk/stm32/clk-stm32mp1.c              |    4 +-
 drivers/clk/stm32/clk-stm32mp13.c             |  846 +++++
 drivers/clk/stm32/clk-stm32mp25.c             |  786 ++++
 drivers/clk/stm32/stm32mp13_rcc.h             |  288 ++
 drivers/clk/stm32/stm32mp25_rcc.h             |  712 ++++
 drivers/core/ofnode.c                         |   64 +-
 drivers/core/read.c                           |    6 +
 drivers/dfu/Kconfig                           |    1 -
 drivers/dfu/dfu_mtd.c                         |   66 +-
 drivers/fastboot/fb_command.c                 |    7 +-
 drivers/firmware/scmi/mailbox_agent.c         |    2 +-
 drivers/firmware/scmi/optee_agent.c           |    2 +-
 drivers/firmware/scmi/scmi_agent-uclass.c     |    7 +-
 drivers/firmware/scmi/smccc_agent.c           |    2 +-
 drivers/fwu-mdata/Kconfig                     |   31 +
 drivers/fwu-mdata/Makefile                    |    9 +
 drivers/fwu-mdata/fwu-mdata-uclass.c          |   57 +
 drivers/fwu-mdata/gpt_blk.c                   |  220 ++
 drivers/fwu-mdata/raw_mtd.c                   |  289 ++
 drivers/gpio/gpio-uclass.c                    |   50 +-
 drivers/gpio/sandbox.c                        |   21 +-
 drivers/gpio/stm32_gpio.c                     |  148 +-
 drivers/gpio/stm32_gpio_priv.h                |   70 +-
 drivers/hwspinlock/hwspinlock-uclass.c        |    2 +-
 drivers/i2c/stm32f7_i2c.c                     |   39 +-
 drivers/memory/Kconfig                        |    8 +
 drivers/memory/Makefile                       |    1 +
 drivers/memory/stm32-fmc2-ebi.c               |  449 ++-
 drivers/memory/stm32-omi.c                    |  523 +++
 drivers/misc/Kconfig                          |   17 +
 drivers/misc/Makefile                         |    1 +
 drivers/misc/stm32_omm.c                      |  428 +++
 drivers/misc/stm32_rcc.c                      |    5 +
 drivers/mmc/stm32_sdmmc2.c                    |   29 +-
 drivers/mtd/Kconfig                           |   15 +
 drivers/mtd/Makefile                          |    2 +
 drivers/mtd/cfi_flash.c                       |  287 +-
 drivers/mtd/cfi_mtd.c                         |    3 +-
 drivers/mtd/mtd_uboot.c                       |   14 +-
 drivers/mtd/nand/raw/stm32_fmc2_nand.c        |   50 +-
 drivers/mtd/sfdp_flash.c                      |   85 +
 drivers/mtd/spi/spi-nor-core.c                |    9 +
 drivers/mtd/stm32_hyperbus.c                  |  356 ++
 drivers/net/dwc_eth_qos.c                     |  156 +-
 drivers/net/dwc_eth_qos.h                     |   16 +-
 drivers/phy/Kconfig                           |    8 +
 drivers/phy/Makefile                          |    1 +
 drivers/phy/phy-stm32-usb2phy.c               |  643 ++++
 drivers/phy/phy-stm32-usbphyc.c               |   21 +-
 drivers/phy/phy-uclass.c                      |   69 +
 drivers/pinctrl/Kconfig                       |    8 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/pinctrl-mcp23017.c            |  411 ++
 drivers/pinctrl/pinctrl-stmfx.c               |    4 +-
 drivers/pinctrl/pinctrl_stm32.c               |  174 +-
 drivers/power/pmic/pmic-uclass.c              |    4 +
 drivers/power/pmic/stpmic1.c                  |    2 +
 drivers/power/regulator/scmi_regulator.c      |    2 +-
 drivers/remoteproc/Kconfig                    |    8 +
 drivers/remoteproc/Makefile                   |    1 +
 drivers/remoteproc/rproc-optee.c              |  239 ++
 drivers/remoteproc/stm32_copro.c              |  293 +-
 drivers/reset/reset-scmi.c                    |    2 +-
 drivers/reset/reset-uclass.c                  |    4 -
 drivers/reset/stm32-reset.c                   |   18 +-
 drivers/rng/Kconfig                           |    9 +-
 drivers/rng/Makefile                          |    2 +-
 drivers/rng/optee_rng.c                       |    7 +-
 drivers/rng/stm32_rng.c                       |  445 +++
 drivers/rng/stm32mp1_rng.c                    |  198 -
 drivers/rtc/stm32_rtc.c                       |   57 +-
 drivers/serial/serial_stm32.c                 |   69 +-
 drivers/serial/serial_stm32.h                 |    3 +-
 drivers/spi/Kconfig                           |    8 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-mem.c                         |    4 -
 drivers/spi/stm32_ospi.c                      |  738 ++++
 drivers/spi/stm32_qspi.c                      |   31 +-
 drivers/tee/optee/Kconfig                     |    8 +
 drivers/tee/optee/core.c                      |  198 +-
 drivers/tpm/tpm2_ftpm_tee.c                   |    1 +
 drivers/usb/Kconfig                           |   12 +
 drivers/usb/cdns3/core.h                      |    6 -
 drivers/usb/dwc3/core.c                       |   40 +-
 drivers/usb/dwc3/dwc3-generic.c               |   92 +-
 drivers/usb/gadget/dwc2_udc_otg.c             |   21 +-
 drivers/usb/host/Kconfig                      |   14 +
 drivers/usb/host/Makefile                     |    3 +
 drivers/usb/host/ehci-generic.c               |   36 +-
 drivers/usb/host/ehci-hcd.c                   |   88 +-
 drivers/usb/host/ehci-msm.c                   |    4 +-
 drivers/usb/host/ehci-mx6.c                   |    6 +-
 drivers/usb/host/ehci-pci.c                   |    4 +-
 drivers/usb/host/ehci.h                       |    4 -
 drivers/usb/host/ohci-generic.c               |  148 +-
 drivers/usb/host/ohci-hcd.c                   |    3 +-
 drivers/usb/host/usb-uclass.c                 |   16 +-
 drivers/usb/host/usbh-stm32.c                 |  107 +
 drivers/usb/typec/Kconfig                     |   24 +
 drivers/usb/typec/Makefile                    |    5 +
 drivers/usb/typec/typec-stusb160x.c           |  130 +
 drivers/usb/typec/typec-uclass.c              |  127 +
 drivers/usb/typec/ucsi/Kconfig                |   26 +
 drivers/usb/typec/ucsi/Makefile               |    4 +
 drivers/usb/typec/ucsi/ucsi-stm32g0.c         |  117 +
 drivers/usb/typec/ucsi/ucsi-uclass.c          |  393 ++
 drivers/video/Kconfig                         |    9 +
 drivers/video/Makefile                        |    1 +
 drivers/video/rocktech-hx8394.c               |  250 ++
 drivers/video/simple_panel.c                  |   17 +
 drivers/video/stm32/Kconfig                   |    9 +
 drivers/video/stm32/Makefile                  |    1 +
 drivers/video/stm32/stm32_dsi.c               |  604 ++-
 drivers/video/stm32/stm32_ltdc.c              |  234 +-
 drivers/video/stm32/stm32_lvds.c              |  706 ++++
 drivers/watchdog/Kconfig                      |    8 +
 drivers/watchdog/Makefile                     |    1 +
 drivers/watchdog/arm_smc_wdt.c                |  140 +
 drivers/watchdog/stm32mp_wdt.c                |   44 +-
 drivers/watchdog/wdt-uclass.c                 |   16 +-
 dts/Makefile                                  |   11 +-
 env/Kconfig                                   |   16 +
 env/common.c                                  |    3 +-
 env/env.c                                     |    8 +-
 env/flash.c                                   |  220 +-
 env/mmc.c                                     |  176 +-
 env/ubi.c                                     |   40 +
 fs/btrfs/disk-io.c                            |    7 +-
 fs/ext4/ext4_common.c                         |    6 +-
 fs/fs_internal.c                              |    3 +-
 include/asm-generic/gpio.h                    |   10 +-
 include/clk.h                                 |   24 +
 include/configs/stm32f746-disco.h             |    1 -
 include/configs/stm32mp13_common.h            |   54 +-
 include/configs/stm32mp13_st_common.h         |   36 +-
 include/configs/stm32mp15_common.h            |   30 +-
 include/configs/stm32mp15_st_common.h         |    2 +-
 include/configs/stm32mp25_common.h            |  145 +
 include/configs/stm32mp25_st_common.h         |   50 +
 include/dfu.h                                 |    2 +-
 include/dm/ofnode.h                           |   12 +
 include/dm/pinctrl.h                          |    2 +-
 include/dm/read.h                             |   20 +
 include/dm/uclass-id.h                        |    3 +
 include/dt-bindings/arm/coresight-cti-dt.h    |   37 +
 include/dt-bindings/bus/stm32mp13_sys_bus.h   |   60 +
 include/dt-bindings/bus/stm32mp15_sys_bus.h   |   98 +
 include/dt-bindings/bus/stm32mp25_sys_bus.h   |  127 +
 include/dt-bindings/clock/stm32mp13-clks.h    |  235 ++
 include/dt-bindings/clock/stm32mp2-clksrc.h   |   89 +
 include/dt-bindings/clock/stm32mp25-clks.h    |  496 +++
 include/dt-bindings/gpio/gpio.h               |    3 +
 include/dt-bindings/gpio/sandbox-gpio.h       |    3 +
 include/dt-bindings/pinctrl/stm32-pinfunc.h   |    4 +
 include/dt-bindings/pinctrl/stm32mp13-hdp.h   |  130 +
 include/dt-bindings/pinctrl/stm32mp15-hdp.h   |  116 +
 include/dt-bindings/pinctrl/stm32mp25-hdp.h   |  144 +
 .../power/stm32mp25-power-domains.h           |   11 +
 .../regulator/st,stm32mp13-regulator.h        |   42 +
 .../regulator/st,stm32mp25-regulator.h        |   48 +
 include/dt-bindings/reset/stm32mp13-resets.h  |  100 +
 include/dt-bindings/reset/stm32mp25-resets.h  |  166 +
 include/dt-bindings/rtc/rtc-stm32.h           |   14 +
 include/dt-bindings/soc/stm32-hdp.h           |  108 +
 include/dt-bindings/soc/stm32mp13-hdp.h       |  133 +
 include/efi_api.h                             |    6 +
 include/efi_loader.h                          |    3 +-
 include/event.h                               |    3 +
 include/fdt_support.h                         |    8 +
 include/flash.h                               |    2 +
 include/fwu.h                                 |  420 +++
 include/fwu_mdata.h                           |  127 +
 include/generic-phy.h                         |   98 +
 include/image.h                               |    8 +-
 include/linux/clk-provider.h                  |    9 +-
 include/linux/ioport.h                        |   16 +
 include/linux/mtd/spi-nor.h                   |    1 +
 include/linux/usb/otg.h                       |    6 +
 include/mtd/cfi_flash.h                       |    1 +
 include/mtd/sfdp_flash.h                      |   11 +
 include/netdev.h                              |    2 +-
 include/pxe_utils.h                           |    2 +
 include/reset.h                               |    9 +-
 include/rproc_optee.h                         |  127 +
 include/spi-mem.h                             |    3 +
 include/stm32_omi.h                           |  182 +
 include/tee/optee_service.h                   |   34 +
 include/typec.h                               |  154 +
 include/ucsi.h                                |  112 +
 include/usb.h                                 |    6 +
 include/wdt.h                                 |    9 +
 lib/Kconfig                                   |    6 +
 lib/Makefile                                  |    1 +
 lib/efi_loader/efi_capsule.c                  |  214 +-
 lib/efi_loader/efi_device_path.c              |   48 +-
 lib/efi_loader/efi_device_path_to_text.c      |    7 +
 lib/efi_loader/efi_disk.c                     |   37 +-
 lib/efi_loader/efi_firmware.c                 |  299 +-
 lib/fwu_updates/Kconfig                       |   47 +
 lib/fwu_updates/Makefile                      |   10 +
 lib/fwu_updates/fwu.c                         |  750 ++++
 lib/fwu_updates/fwu_gpt.c                     |  123 +
 lib/fwu_updates/fwu_mtd.c                     |  187 +
 lib/fwu_updates/fwu_v1.c                      |  167 +
 lib/fwu_updates/fwu_v2.c                      |  260 ++
 scripts/Makefile.lib                          |    7 +-
 scripts/dtc/README                            |  106 +
 scripts/dtc/pylibfdt/Makefile                 |    5 +-
 scripts/dtc/pylibfdt/libfdt.i_shipped         |    4 +
 scripts/dtc/pylibfdt/setup.py                 |   67 +-
 test/dm/Makefile                              |    1 +
 test/dm/clk_ccf.c                             |   26 +-
 test/dm/fwu_mdata.c                           |  147 +
 test/dm/fwu_mdata_disk_image.h                |  112 +
 test/dm/gpio.c                                |   35 +
 test/dm/reset.c                               |   22 +
 .../tests/test_efi_capsule/capsule_common.py  |  142 +
 test/py/tests/test_efi_capsule/conftest.py    |  109 +-
 .../test_capsule_firmware_fit.py              |  247 +-
 .../test_capsule_firmware_raw.py              |  301 +-
 .../test_capsule_firmware_signed_fit.py       |  311 +-
 .../test_capsule_firmware_signed_raw.py       |  314 +-
 test/py/tests/test_efi_capsule/version.dts    |   24 +
 test/py/tests/test_pinmux.py                  |   40 +-
 tools/Kconfig                                 |    9 +
 tools/Makefile                                |   16 +-
 tools/eficapsule.h                            |   40 +
 tools/mkeficapsule.c                          |  370 +-
 tools/mkfwumdata.c                            |  493 +++
 480 files changed, 48166 insertions(+), 6461 deletions(-)
 create mode 100644 CONTRIBUTING.md
 create mode 100644 SECURITY.md
 create mode 100644 arch/arm/dts/stm32mp13xa.dtsi
 create mode 100644 arch/arm/dts/stm32mp13xd.dtsi
 create mode 100644 arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp15-m4-srm.dtsi
 delete mode 100644 arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157a-dk1-scmi.dts => stm32mp157a-dk1-scmi.dtsi} (79%)
 create mode 100644 arch/arm/dts/stm32mp157a-ed1-scmi.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ed1.dts
 create mode 100644 arch/arm/dts/stm32mp157a-ev1-scmi.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157a-ev1.dts
 rename arch/arm/dts/{stm32mp157c-dk2-scmi.dts => stm32mp157c-dk2-scmi.dtsi} (78%)
 delete mode 100644 arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157c-ed1-scmi.dts => stm32mp157c-ed1-scmi.dtsi} (74%)
 delete mode 100644 arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi
 rename arch/arm/dts/{stm32mp157c-ev1-scmi.dts => stm32mp157c-ev1-scmi.dtsi} (78%)
 rename arch/arm/dts/{stm32mp157c-dk2-scmi-u-boot.dtsi => stm32mp157d-dk1-u-boot.dtsi} (71%)
 create mode 100644 arch/arm/dts/stm32mp157d-dk1.dts
 create mode 100644 arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157d-ed1.dts
 create mode 100644 arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157d-ev1.dts
 create mode 100644 arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157f-dk2.dts
 create mode 100644 arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157f-ed1.dts
 create mode 100644 arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp157f-ev1.dts
 create mode 100644 arch/arm/dts/stm32mp15xa.dtsi
 create mode 100644 arch/arm/dts/stm32mp15xd.dtsi
 create mode 100644 arch/arm/dts/stm32mp15xf.dtsi
 create mode 100644 arch/arm/dts/stm32mp15xx-dhcor-testbench-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp15xx-dhcor-testbench.dts
 create mode 100644 arch/arm/dts/stm32mp25-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp251.dtsi
 create mode 100644 arch/arm/dts/stm32mp253.dtsi
 create mode 100644 arch/arm/dts/stm32mp255.dtsi
 create mode 100644 arch/arm/dts/stm32mp257.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-dk-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-dk.dts
 create mode 100644 arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi
 create mode 100644 arch/arm/dts/stm32mp257f-ev1.dts
 create mode 100644 arch/arm/dts/stm32mp25xc.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xf.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxai-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxak-pinctrl.dtsi
 create mode 100644 arch/arm/dts/stm32mp25xxal-pinctrl.dtsi
 create mode 100644 arch/arm/mach-stm32mp/Kconfig.25x
 create mode 100644 arch/arm/mach-stm32mp/etzpc.c
 delete mode 100644 arch/arm/mach-stm32mp/fdt.c
 create mode 100644 arch/arm/mach-stm32mp/include/mach/etzpc.h
 create mode 100644 arch/arm/mach-stm32mp/include/mach/rif.h
 create mode 100644 arch/arm/mach-stm32mp/nvram.c
 create mode 100644 arch/arm/mach-stm32mp/soc.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp1/Makefile
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/cpu.c (85%)
 create mode 100644 arch/arm/mach-stm32mp/stm32mp1/fdt.c
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/psci.c (100%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/pwr_regulator.c (96%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/stm32mp13x.c (100%)
 rename arch/arm/mach-stm32mp/{ => stm32mp1}/stm32mp15x.c (98%)
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/Makefile
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/cpu.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/fdt.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/rifsc.c
 create mode 100644 arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c
 create mode 100644 board/st/common/stm32mp_dfu_virt.c
 delete mode 100644 board/st/common/stm32mp_mtdparts.c
 delete mode 100644 board/st/common/stusb160x.c
 delete mode 100644 board/st/common/stusb160x.h
 create mode 100644 board/st/stm32mp1/debug_uart.c
 create mode 100644 board/st/stm32mp2/Kconfig
 create mode 100644 board/st/stm32mp2/MAINTAINERS
 create mode 100644 board/st/stm32mp2/Makefile
 create mode 100644 board/st/stm32mp2/README
 create mode 100644 board/st/stm32mp2/stm32mp2.c
 create mode 100644 cmd/fwu_mdata.c
 create mode 100644 common/usb_onboard_hub.c
 create mode 100644 configs/stm32mp25_defconfig
 create mode 100644 doc/board/st/stm32mp2.rst
 create mode 100644 doc/develop/uefi/fwu_updates.rst
 create mode 100644 doc/device-tree-bindings/firmware/firmware-version.txt
 create mode 100644 doc/device-tree-bindings/firmware/fwu-mdata-gpt.yaml
 create mode 100644 doc/mkfwumdata.1
 create mode 100644 doc/usage/cmd/fwu_mdata.rst
 create mode 100644 drivers/clk/stm32/clk-stm32-core.c
 create mode 100644 drivers/clk/stm32/clk-stm32-core.h
 create mode 100644 drivers/clk/stm32/clk-stm32mp13.c
 create mode 100644 drivers/clk/stm32/clk-stm32mp25.c
 create mode 100644 drivers/clk/stm32/stm32mp13_rcc.h
 create mode 100644 drivers/clk/stm32/stm32mp25_rcc.h
 create mode 100644 drivers/fwu-mdata/Kconfig
 create mode 100644 drivers/fwu-mdata/Makefile
 create mode 100644 drivers/fwu-mdata/fwu-mdata-uclass.c
 create mode 100644 drivers/fwu-mdata/gpt_blk.c
 create mode 100644 drivers/fwu-mdata/raw_mtd.c
 create mode 100644 drivers/memory/stm32-omi.c
 create mode 100644 drivers/misc/stm32_omm.c
 create mode 100644 drivers/mtd/sfdp_flash.c
 create mode 100644 drivers/mtd/stm32_hyperbus.c
 create mode 100644 drivers/phy/phy-stm32-usb2phy.c
 create mode 100644 drivers/pinctrl/pinctrl-mcp23017.c
 create mode 100644 drivers/remoteproc/rproc-optee.c
 create mode 100644 drivers/rng/stm32_rng.c
 delete mode 100644 drivers/rng/stm32mp1_rng.c
 create mode 100644 drivers/spi/stm32_ospi.c
 create mode 100644 drivers/usb/host/usbh-stm32.c
 create mode 100644 drivers/usb/typec/Kconfig
 create mode 100644 drivers/usb/typec/Makefile
 create mode 100644 drivers/usb/typec/typec-stusb160x.c
 create mode 100644 drivers/usb/typec/typec-uclass.c
 create mode 100644 drivers/usb/typec/ucsi/Kconfig
 create mode 100644 drivers/usb/typec/ucsi/Makefile
 create mode 100644 drivers/usb/typec/ucsi/ucsi-stm32g0.c
 create mode 100644 drivers/usb/typec/ucsi/ucsi-uclass.c
 create mode 100644 drivers/video/rocktech-hx8394.c
 create mode 100644 drivers/video/stm32/stm32_lvds.c
 create mode 100644 drivers/watchdog/arm_smc_wdt.c
 create mode 100644 include/configs/stm32mp25_common.h
 create mode 100644 include/configs/stm32mp25_st_common.h
 create mode 100644 include/dt-bindings/arm/coresight-cti-dt.h
 create mode 100644 include/dt-bindings/bus/stm32mp13_sys_bus.h
 create mode 100644 include/dt-bindings/bus/stm32mp15_sys_bus.h
 create mode 100644 include/dt-bindings/bus/stm32mp25_sys_bus.h
 create mode 100644 include/dt-bindings/clock/stm32mp13-clks.h
 create mode 100644 include/dt-bindings/clock/stm32mp2-clksrc.h
 create mode 100644 include/dt-bindings/clock/stm32mp25-clks.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp13-hdp.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp15-hdp.h
 create mode 100644 include/dt-bindings/pinctrl/stm32mp25-hdp.h
 create mode 100644 include/dt-bindings/power/stm32mp25-power-domains.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp13-regulator.h
 create mode 100644 include/dt-bindings/regulator/st,stm32mp25-regulator.h
 create mode 100644 include/dt-bindings/reset/stm32mp13-resets.h
 create mode 100644 include/dt-bindings/reset/stm32mp25-resets.h
 create mode 100644 include/dt-bindings/rtc/rtc-stm32.h
 create mode 100644 include/dt-bindings/soc/stm32-hdp.h
 create mode 100644 include/dt-bindings/soc/stm32mp13-hdp.h
 create mode 100644 include/fwu.h
 create mode 100644 include/fwu_mdata.h
 create mode 100644 include/mtd/sfdp_flash.h
 create mode 100644 include/rproc_optee.h
 create mode 100644 include/stm32_omi.h
 create mode 100644 include/tee/optee_service.h
 create mode 100644 include/typec.h
 create mode 100644 include/ucsi.h
 create mode 100644 lib/fwu_updates/Kconfig
 create mode 100644 lib/fwu_updates/Makefile
 create mode 100644 lib/fwu_updates/fwu.c
 create mode 100644 lib/fwu_updates/fwu_gpt.c
 create mode 100644 lib/fwu_updates/fwu_mtd.c
 create mode 100644 lib/fwu_updates/fwu_v1.c
 create mode 100644 lib/fwu_updates/fwu_v2.c
 create mode 100644 scripts/dtc/README
 create mode 100644 test/dm/fwu_mdata.c
 create mode 100644 test/dm/fwu_mdata_disk_image.h
 create mode 100644 test/py/tests/test_efi_capsule/capsule_common.py
 create mode 100644 test/py/tests/test_efi_capsule/version.dts
 create mode 100644 tools/mkfwumdata.c

diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000000..3d1bacd78a
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,30 @@
+﻿# Contributing guide
+
+This document serves as a checklist before contributing to this repository. It includes links to read up on if topics are unclear to you.
+
+This guide mainly focuses on the proper use of Git.
+
+## 1. Issues
+
+STM32MPU projects do not activate "Github issues" feature for the time being. If you need to report an issue or question about this project deliverables, you can report them using [ ST Support Center ](https://my.st.com/ols#/ols/newrequest)  or  [ ST Community MPU Forum ](https://community.st.com/s/topic/0TO0X0000003u2AWAQ/stm32-mpus).
+
+## 2. Pull Requests
+
+STMicrolectronics is happy to receive contributions from the community, based on an initial Contributor License Agreement (CLA) procedure.
+
+* If you are an individual writing original source code and you are sure **you own the intellectual property**, then you need to sign an Individual CLA (https://cla.st.com).
+* If you work for a company that wants also to allow you to contribute with your work, your company needs to provide a Corporate CLA (https://cla.st.com) mentioning your GitHub account name.
+* If you are not sure that a CLA (Individual or Corporate) has been signed for your GitHub account you can check here (https://cla.st.com).
+
+Please note that:
+* The Corporate CLA will always take precedence over the Individual CLA.
+* One CLA submission is sufficient, for any project proposed by STMicroelectronics.
+
+__How to proceed__
+
+* We recommend to fork the project in your GitHub account to further develop your contribution. Please use the latest commit version.
+* Please, submit one Pull Request for one new feature or proposal. This will ease the analysis and final merge if accepted.
+
+__Note__
+
+Merge will not be done directly in GitHub but it will need first to follow internal integration process before public deliver in a standard release. The Pull request will stay open until it is merged and delivered.
diff --git a/MAINTAINERS b/MAINTAINERS
index 83346183ee..8472befe48 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -523,18 +523,20 @@ F:	drivers/ram/stm32mp1/
 F:	drivers/remoteproc/stm32_copro.c
 F:	drivers/reset/stm32-reset.c
 F:	drivers/rng/optee_rng.c
-F:	drivers/rng/stm32mp1_rng.c
+F:	drivers/rng/stm32_rng.c
 F:	drivers/rtc/stm32_rtc.c
 F:	drivers/serial/serial_stm32.*
 F:	drivers/spi/stm32_qspi.c
 F:	drivers/spi/stm32_spi.c
 F:	drivers/video/stm32/stm32_ltdc.c
 F:	drivers/watchdog/stm32mp_wdt.c
+F:	include/dt-bindings/bus/stm32mp*
 F:	include/dt-bindings/clock/stm32fx-clock.h
-F:	include/dt-bindings/clock/stm32mp1-clks.h
-F:	include/dt-bindings/clock/stm32mp1-clksrc.h
+F:	include/dt-bindings/clock/stm32mp*
 F:	include/dt-bindings/pinctrl/stm32-pinfunc.h
-F:	include/dt-bindings/reset/stm32mp1-resets.h
+F:	include/dt-bindings/reset/stm32mp*
+F:	include/dt-bindings/rtc/rtc-stm32.h
+F:	include/dt-bindings/soc/stm32*
 F:	include/stm32_rcc.h
 F:	tools/stm32image.c
 N:	stm
@@ -943,6 +945,14 @@ T:	git https://source.denx.de/u-boot/custodians/u-boot-fsl-qoriq.git
 F:	drivers/watchdog/sp805_wdt.c
 F:	drivers/watchdog/sbsa_gwdt.c
 
+FWU Multi Bank Update
+M:	Sughosh Ganu <sughosh.ganu@linaro.org>
+S:	Maintained
+T:	git https://source.denx.de/u-boot/custodians/u-boot-efi.git
+F:	lib/fwu_updates/*
+F:	drivers/fwu-mdata/*
+F:	tools/mkfwumdata.c
+
 GATEWORKS_SC
 M:	Tim Harvey <tharvey@gateworks.com>
 S:	Maintained
diff --git a/Makefile b/Makefile
index 50077027ba..c1d67cc3f0 100644
--- a/Makefile
+++ b/Makefile
@@ -3,7 +3,7 @@
 VERSION = 2022
 PATCHLEVEL = 10
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -stm32mp-r2
 NAME =
 
 # *DOCUMENTATION*
@@ -483,6 +483,11 @@ export RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o    \
 export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
 			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
 
+# handle external device tree
+
+EXT_DTS ?= $(srctree)/arch/$(ARCH)/dts/external-dt/u-boot
+export EXT_DTS
+
 # ===========================================================================
 # Rules shared between *config targets and build targets
 
@@ -799,6 +804,9 @@ KBUILD_CPPFLAGS += $(KCPPFLAGS)
 KBUILD_AFLAGS += $(KAFLAGS)
 KBUILD_CFLAGS += $(KCFLAGS)
 
+KBUILD_LDFLAGS  += -z noexecstack
+KBUILD_LDFLAGS  += $(call ld-option,--no-warn-rwx-segments)
+
 KBUILD_HOSTCFLAGS += $(if $(CONFIG_TOOLS_DEBUG),-g)
 
 # Use UBOOTINCLUDE when you must reference the include/ directory.
@@ -855,6 +863,7 @@ libs-y += drivers/usb/musb/
 libs-y += drivers/usb/musb-new/
 libs-y += drivers/usb/isp1760/
 libs-y += drivers/usb/phy/
+libs-y += drivers/usb/typec/
 libs-y += drivers/usb/ulpi/
 ifdef CONFIG_POST
 libs-y += post/
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 0000000000..4b3e4e6ba5
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,8 @@
+# Report potential product security vulnerabilities
+ST places a high priority on security, and our Product Security Incident Response Team (PSIRT) is committed to rapidly addressing potential security vulnerabilities affecting our products. PSIRT's long history and vast experience in security allows ST to perform clear analyses and provide appropriate guidance on mitigations  and solutions when applicable.
+If you wish to report potential security vulnerabilities regarding our products, **please do not report them through public GitHub issues.** Instead, we encourage you to report them to our ST PSIRT following the process described at: **https://www.st.com/content/st_com/en/security/report-vulnerabilities.html**
+
+### IMPORTANT - READ CAREFULLY:
+STMicroelectronics International N.V., on behalf of itself, its affiliates and  subsidiaries, (collectively “ST”) takes all potential security vulnerability reports or other related communications (“Report(s)”)  seriously. In order to review Your Report (the terms “You” and “Yours”  include your employer, and all affiliates, subsidiaries and related  persons or entities) and take actions as deemed appropriate, ST requires that we have the rights and Your permission to do so.
+As such, by submitting Your Report to ST, You agree that You have the right to do so, and You grant to ST the rights to use the Report for purposes related to security vulnerability analysis, testing, correction, patching, reporting and any other related purpose or function.
+By submitting Your Report, You agree that ST’s [Privacy Policy](https://www.st.com/content/st_com/en/common/privacy-portal.html) applies to all related communications.
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 82cd456f51..92932983b2 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1955,7 +1955,7 @@ config ARCH_STM32MP
 	select REGMAP
 	select SYSCON
 	select SYSRESET
-	select SYS_THUMB_BUILD
+	select SYS_THUMB_BUILD if !ARM64
 	imply SPL_SYSRESET
 	imply CMD_DM
 	imply CMD_POWEROFF
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 965895bc2a..5424eac7cd 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -1180,28 +1180,37 @@ dtb-$(CONFIG_ASPEED_AST2600) += ast2600-evb.dtb
 
 dtb-$(CONFIG_ARCH_STI) += stih410-b2260.dtb
 
-dtb-$(CONFIG_STM32MP13x) += \
+dtb-$(CONFIG_STM32MP13X) += \
 	stm32mp135f-dk.dtb
 
-dtb-$(CONFIG_STM32MP15x) += \
+dtb-$(CONFIG_STM32MP15X) += \
 	stm32mp157a-dk1.dtb \
-	stm32mp157a-dk1-scmi.dtb \
+	stm32mp157a-ed1.dtb \
+	stm32mp157a-ev1.dtb \
 	stm32mp157a-icore-stm32mp1-ctouch2.dtb \
 	stm32mp157a-icore-stm32mp1-edimm2.2.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0.dtb \
 	stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dtb \
 	stm32mp157c-dk2.dtb \
-	stm32mp157c-dk2-scmi.dtb \
 	stm32mp157c-ed1.dtb \
-	stm32mp157c-ed1-scmi.dtb \
 	stm32mp157c-ev1.dtb \
-	stm32mp157c-ev1-scmi.dtb \
 	stm32mp157c-odyssey.dtb \
+	stm32mp157d-dk1.dtb \
+	stm32mp157d-ed1.dtb \
+	stm32mp157d-ev1.dtb \
+	stm32mp157f-dk2.dtb \
+	stm32mp157f-ed1.dtb \
+	stm32mp157f-ev1.dtb \
 	stm32mp15xx-dhcom-drc02.dtb \
 	stm32mp15xx-dhcom-pdk2.dtb \
 	stm32mp15xx-dhcom-picoitx.dtb \
 	stm32mp15xx-dhcor-avenger96.dtb \
-	stm32mp15xx-dhcor-drc-compact.dtb
+	stm32mp15xx-dhcor-drc-compact.dtb \
+	stm32mp15xx-dhcor-testbench.dtb
+
+dtb-$(CONFIG_STM32MP25X) += \
+	stm32mp257f-dk.dtb \
+	stm32mp257f-ev1.dtb
 
 dtb-$(CONFIG_SOC_K3_AM654) += \
 	k3-am654-base-board.dtb \
diff --git a/arch/arm/dts/stm32429i-eval-u-boot.dtsi b/arch/arm/dts/stm32429i-eval-u-boot.dtsi
index fcab9ae977..030da47b7a 100644
--- a/arch/arm/dts/stm32429i-eval-u-boot.dtsi
+++ b/arch/arm/dts/stm32429i-eval-u-boot.dtsi
@@ -218,6 +218,6 @@
 	};
 };
 
-&timer5 {
+&timers5 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32746g-eval.dts b/arch/arm/dts/stm32746g-eval.dts
index 9940cf1873..0e6445a539 100644
--- a/arch/arm/dts/stm32746g-eval.dts
+++ b/arch/arm/dts/stm32746g-eval.dts
@@ -45,12 +45,10 @@
 		};
 	};
 
-	gpio_keys {
+	gpio-keys {
 		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
 		autorepeat;
-		button@0 {
+		button-0 {
 			label = "Wake up";
 			linux,code = <KEY_WAKEUP>;
 			gpios = <&gpioc 13 0>;
@@ -160,6 +158,18 @@
 	bus-width = <4>;
 };
 
+&timers5 {
+	/* Override timer5 to act as clockevent */
+	compatible = "st,stm32-timer";
+	interrupts = <50>;
+	status = "okay";
+	/delete-property/#address-cells;
+	/delete-property/#size-cells;
+	/delete-property/clock-names;
+	/delete-node/pwm;
+	/delete-node/timer@4;
+};
+
 &usart1 {
 	pinctrl-0 = <&usart1_pins_a>;
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/stm32f4-pinctrl.dtsi b/arch/arm/dts/stm32f4-pinctrl.dtsi
index adf502694b..46815c965d 100644
--- a/arch/arm/dts/stm32f4-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f4-pinctrl.dtsi
@@ -9,7 +9,7 @@
 
 / {
 	soc {
-		pinctrl: pin-controller {
+		pinctrl: pinctrl@40020000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0 0x40020000 0x3000>;
diff --git a/arch/arm/dts/stm32f429-disco-u-boot.dtsi b/arch/arm/dts/stm32f429-disco-u-boot.dtsi
index c993f86be8..45f899662d 100644
--- a/arch/arm/dts/stm32f429-disco-u-boot.dtsi
+++ b/arch/arm/dts/stm32f429-disco-u-boot.dtsi
@@ -27,10 +27,6 @@
 
 	soc {
 		u-boot,dm-pre-reloc;
-		pin-controller {
-			u-boot,dm-pre-reloc;
-		};
-
 		fmc: fmc@A0000000 {
 			compatible = "st,stm32-fmc";
 			reg = <0xa0000000 0x1000>;
@@ -123,6 +119,8 @@
 };
 
 &pinctrl {
+	u-boot,dm-pre-reloc;
+
 	usart1_pins_a: usart1-0	{
 		u-boot,dm-pre-reloc;
 		pins1 {
@@ -193,6 +191,6 @@
 	u-boot,dm-pre-reloc;
 };
 
-&timer5 {
+&timers5 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32f429-disco.dts b/arch/arm/dts/stm32f429-disco.dts
index 42477c8d3f..30daabd10a 100644
--- a/arch/arm/dts/stm32f429-disco.dts
+++ b/arch/arm/dts/stm32f429-disco.dts
@@ -39,12 +39,10 @@
 		};
 	};
 
-	gpio_keys {
+	gpio-keys {
 		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
 		autorepeat;
-		button@0 {
+		button-0 {
 			label = "User";
 			linux,code = <KEY_HOME>;
 			gpios = <&gpioa 0 0>;
@@ -152,7 +150,7 @@
 
 	display: display@1{
 		/* Connect panel-ilitek-9341 to ltdc */
-		compatible = "st,sf-tc240t-9370-t";
+		compatible = "st,sf-tc240t-9370-t", "ilitek,ili9341";
 		reg = <1>;
 		spi-3wire;
 		spi-max-frequency = <10000000>;
@@ -165,6 +163,18 @@
 	};
 };
 
+&timers5 {
+	/* Override timer5 to act as clockevent */
+	compatible = "st,stm32-timer";
+	interrupts = <50>;
+	status = "okay";
+	/delete-property/#address-cells;
+	/delete-property/#size-cells;
+	/delete-property/clock-names;
+	/delete-node/pwm;
+	/delete-node/timer@4;
+};
+
 &usart1 {
 	pinctrl-0 = <&usart1_pins_a>;
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/stm32f429-pinctrl.dtsi b/arch/arm/dts/stm32f429-pinctrl.dtsi
index 575c7eecab..5be171eea5 100644
--- a/arch/arm/dts/stm32f429-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f429-pinctrl.dtsi
@@ -6,54 +6,50 @@
 
 #include "stm32f4-pinctrl.dtsi"
 
-/ {
-	soc {
-		pinctrl: pin-controller {
-			compatible = "st,stm32f429-pinctrl";
-
-			gpioa: gpio@40020000 {
-				gpio-ranges = <&pinctrl 0 0 16>;
-			};
-
-			gpiob: gpio@40020400 {
-				gpio-ranges = <&pinctrl 0 16 16>;
-			};
-
-			gpioc: gpio@40020800 {
-				gpio-ranges = <&pinctrl 0 32 16>;
-			};
-
-			gpiod: gpio@40020c00 {
-				gpio-ranges = <&pinctrl 0 48 16>;
-			};
-
-			gpioe: gpio@40021000 {
-				gpio-ranges = <&pinctrl 0 64 16>;
-			};
-
-			gpiof: gpio@40021400 {
-				gpio-ranges = <&pinctrl 0 80 16>;
-			};
-
-			gpiog: gpio@40021800 {
-				gpio-ranges = <&pinctrl 0 96 16>;
-			};
-
-			gpioh: gpio@40021c00 {
-				gpio-ranges = <&pinctrl 0 112 16>;
-			};
-
-			gpioi: gpio@40022000 {
-				gpio-ranges = <&pinctrl 0 128 16>;
-			};
-
-			gpioj: gpio@40022400 {
-				gpio-ranges = <&pinctrl 0 144 16>;
-			};
-
-			gpiok: gpio@40022800 {
-				gpio-ranges = <&pinctrl 0 160 8>;
-			};
-		};
+&pinctrl {
+	compatible = "st,stm32f429-pinctrl";
+
+	gpioa: gpio@40020000 {
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@40020400 {
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@40020800 {
+		gpio-ranges = <&pinctrl 0 32 16>;
+	};
+
+	gpiod: gpio@40020c00 {
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@40021000 {
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@40021400 {
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@40021800 {
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@40021c00 {
+		gpio-ranges = <&pinctrl 0 112 16>;
+	};
+
+	gpioi: gpio@40022000 {
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@40022400 {
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@40022800 {
+		gpio-ranges = <&pinctrl 0 160 8>;
 	};
 };
diff --git a/arch/arm/dts/stm32f429.dtsi b/arch/arm/dts/stm32f429.dtsi
index a81e916064..e5b13aca40 100644
--- a/arch/arm/dts/stm32f429.dtsi
+++ b/arch/arm/dts/stm32f429.dtsi
@@ -52,14 +52,6 @@
 			};
 		};
 
-		timer2: timer@40000000 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000000 0x400>;
-			interrupts = <28>;
-			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM2)>;
-			status = "disabled";
-		};
-
 		timers2: timers@40000000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -82,14 +74,6 @@
 			};
 		};
 
-		timer3: timer@40000400 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000400 0x400>;
-			interrupts = <29>;
-			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM3)>;
-			status = "disabled";
-		};
-
 		timers3: timers@40000400 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -112,14 +96,6 @@
 			};
 		};
 
-		timer4: timer@40000800 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000800 0x400>;
-			interrupts = <30>;
-			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM4)>;
-			status = "disabled";
-		};
-
 		timers4: timers@40000800 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -142,13 +118,6 @@
 			};
 		};
 
-		timer5: timer@40000c00 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000c00 0x400>;
-			interrupts = <50>;
-			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM5)>;
-		};
-
 		timers5: timers@40000c00 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -171,14 +140,6 @@
 			};
 		};
 
-		timer6: timer@40001000 {
-			compatible = "st,stm32-timer";
-			reg = <0x40001000 0x400>;
-			interrupts = <54>;
-			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM6)>;
-			status = "disabled";
-		};
-
 		timers6: timers@40001000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -195,14 +156,6 @@
 			};
 		};
 
-		timer7: timer@40001400 {
-			compatible = "st,stm32-timer";
-			reg = <0x40001400 0x400>;
-			interrupts = <55>;
-			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM7)>;
-			status = "disabled";
-		};
-
 		timers7: timers@40001400 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -242,8 +195,6 @@
 		};
 
 		timers13: timers@40001c00 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40001C00 0x400>;
 			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM13)>;
@@ -258,8 +209,6 @@
 		};
 
 		timers14: timers@40002000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40002000 0x400>;
 			clocks = <&rcc 0 STM32F4_APB1_CLOCK(TIM14)>;
@@ -525,7 +474,7 @@
 			};
 		};
 
-		sdio: sdio@40012c00 {
+		sdio: mmc@40012c00 {
 			compatible = "arm,pl180", "arm,primecell";
 			arm,primecell-periphid = <0x00880180>;
 			reg = <0x40012c00 0x400>;
@@ -592,8 +541,6 @@
 		};
 
 		timers10: timers@40014400 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40014400 0x400>;
 			clocks = <&rcc 0 STM32F4_APB2_CLOCK(TIM10)>;
@@ -608,8 +555,6 @@
 		};
 
 		timers11: timers@40014800 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40014800 0x400>;
 			clocks = <&rcc 0 STM32F4_APB2_CLOCK(TIM11)>;
@@ -668,7 +613,7 @@
 			status = "disabled";
 		};
 
-		rcc: rcc@40023810 {
+		rcc: rcc@40023800 {
 			#reset-cells = <1>;
 			#clock-cells = <2>;
 			compatible = "st,stm32f42xx-rcc", "st,stm32-rcc";
@@ -726,6 +671,16 @@
 			status = "disabled";
 		};
 
+		dma2d: dma2d@4002b000 {
+			compatible = "st,stm32-dma2d";
+			reg = <0x4002b000 0xc00>;
+			interrupts = <90>;
+			resets = <&rcc STM32F4_AHB1_RESET(DMA2D)>;
+			clocks = <&rcc 0 STM32F4_AHB1_CLOCK(DMA2D)>;
+			clock-names = "dma2d";
+			status = "disabled";
+		};
+
 		usbotg_hs: usb@40040000 {
 			compatible = "snps,dwc2";
 			reg = <0x40040000 0x40000>;
diff --git a/arch/arm/dts/stm32f469-disco-u-boot.dtsi b/arch/arm/dts/stm32f469-disco-u-boot.dtsi
index cd173623ef..ee0c82b53e 100644
--- a/arch/arm/dts/stm32f469-disco-u-boot.dtsi
+++ b/arch/arm/dts/stm32f469-disco-u-boot.dtsi
@@ -28,9 +28,6 @@
 
 	soc {
 		u-boot,dm-pre-reloc;
-		pin-controller {
-			u-boot,dm-pre-reloc;
-		};
 
 		fmc: fmc@A0000000 {
 			compatible = "st,stm32-fmc";
@@ -138,6 +135,8 @@
 };
 
 &pinctrl {
+	u-boot,dm-pre-reloc;
+
 	fmc_pins_d32: fmc_d32@0 {
 		u-boot,dm-pre-reloc;
 		pins
@@ -256,6 +255,6 @@
 	u-boot,dm-pre-reloc;
 };
 
-&timer5 {
+&timers5 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32f469-disco.dts b/arch/arm/dts/stm32f469-disco.dts
index 23d87ee27a..6e0ffc1903 100644
--- a/arch/arm/dts/stm32f469-disco.dts
+++ b/arch/arm/dts/stm32f469-disco.dts
@@ -19,7 +19,7 @@
 		stdout-path = "serial0:115200n8";
 	};
 
-	memory@00000000 {
+	memory@0 {
 		device_type = "memory";
 		reg = <0x00000000 0x1000000>;
 	};
@@ -63,12 +63,10 @@
 		};
 	};
 
-	gpio_keys {
+	gpio-keys {
 		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
 		autorepeat;
-		button@0 {
+		button-0 {
 			label = "User";
 			linux,code = <KEY_WAKEUP>;
 			gpios = <&gpioa 0 GPIO_ACTIVE_HIGH>;
@@ -93,6 +91,10 @@
 	clock-frequency = <8000000>;
 };
 
+&dma2d {
+	status = "okay";
+};
+
 &dsi {
 	#address-cells = <1>;
 	#size-cells = <0>;
@@ -185,6 +187,18 @@
 	bus-width = <4>;
 };
 
+&timers5 {
+	/* Override timer5 to act as clockevent */
+	compatible = "st,stm32-timer";
+	interrupts = <50>;
+	status = "okay";
+	/delete-property/#address-cells;
+	/delete-property/#size-cells;
+	/delete-property/clock-names;
+	/delete-node/pwm;
+	/delete-node/timer@4;
+};
+
 &usart3 {
 	pinctrl-0 = <&usart3_pins_a>;
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/stm32f469-pinctrl.dtsi b/arch/arm/dts/stm32f469-pinctrl.dtsi
index 1e2bb0191e..0610407c7b 100644
--- a/arch/arm/dts/stm32f469-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f469-pinctrl.dtsi
@@ -5,55 +5,51 @@
 
 #include "stm32f4-pinctrl.dtsi"
 
-/ {
-	soc {
-		pinctrl: pin-controller {
-			compatible = "st,stm32f469-pinctrl";
-
-			gpioa: gpio@40020000 {
-				gpio-ranges = <&pinctrl 0 0 16>;
-			};
-
-			gpiob: gpio@40020400 {
-				gpio-ranges = <&pinctrl 0 16 16>;
-			};
-
-			gpioc: gpio@40020800 {
-				gpio-ranges = <&pinctrl 0 32 16>;
-			};
-
-			gpiod: gpio@40020c00 {
-				gpio-ranges = <&pinctrl 0 48 16>;
-			};
-
-			gpioe: gpio@40021000 {
-				gpio-ranges = <&pinctrl 0 64 16>;
-			};
-
-			gpiof: gpio@40021400 {
-				gpio-ranges = <&pinctrl 0 80 16>;
-			};
-
-			gpiog: gpio@40021800 {
-				gpio-ranges = <&pinctrl 0 96 16>;
-			};
-
-			gpioh: gpio@40021c00 {
-				gpio-ranges = <&pinctrl 0 112 16>;
-			};
-
-			gpioi: gpio@40022000 {
-				gpio-ranges = <&pinctrl 0 128 16>;
-			};
-
-			gpioj: gpio@40022400 {
-				gpio-ranges = <&pinctrl 0 144 6>,
-					      <&pinctrl 12 156 4>;
-			};
-
-			gpiok: gpio@40022800 {
-				gpio-ranges = <&pinctrl 3 163 5>;
-			};
-		};
+&pinctrl {
+	compatible = "st,stm32f469-pinctrl";
+
+	gpioa: gpio@40020000 {
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@40020400 {
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@40020800 {
+		gpio-ranges = <&pinctrl 0 32 16>;
+	};
+
+	gpiod: gpio@40020c00 {
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@40021000 {
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@40021400 {
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@40021800 {
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@40021c00 {
+		gpio-ranges = <&pinctrl 0 112 16>;
+	};
+
+	gpioi: gpio@40022000 {
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@40022400 {
+		gpio-ranges = <&pinctrl 0 144 6>,
+			      <&pinctrl 12 156 4>;
+	};
+
+	gpiok: gpio@40022800 {
+		gpio-ranges = <&pinctrl 3 163 5>;
 	};
 };
diff --git a/arch/arm/dts/stm32f7-pinctrl.dtsi b/arch/arm/dts/stm32f7-pinctrl.dtsi
index fe4cfda72a..8f37aefa73 100644
--- a/arch/arm/dts/stm32f7-pinctrl.dtsi
+++ b/arch/arm/dts/stm32f7-pinctrl.dtsi
@@ -9,7 +9,7 @@
 
 / {
 	soc {
-		pinctrl: pin-controller {
+		pinctrl: pinctrl@40020000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			ranges = <0 0x40020000 0x3000>;
diff --git a/arch/arm/dts/stm32f7-u-boot.dtsi b/arch/arm/dts/stm32f7-u-boot.dtsi
index c1b2ac25c3..0ba8031c33 100644
--- a/arch/arm/dts/stm32f7-u-boot.dtsi
+++ b/arch/arm/dts/stm32f7-u-boot.dtsi
@@ -119,7 +119,7 @@
 	u-boot,dm-pre-reloc;
 };
 
-&timer5 {
+&timers5 {
 	u-boot,dm-pre-reloc;
 };
 
diff --git a/arch/arm/dts/stm32f746-disco.dts b/arch/arm/dts/stm32f746-disco.dts
index 9430dc08ec..1ed58f2361 100644
--- a/arch/arm/dts/stm32f746-disco.dts
+++ b/arch/arm/dts/stm32f746-disco.dts
@@ -73,6 +73,18 @@
 	bus-width = <4>;
 };
 
+&timers5 {
+	/* Override timer5 to act as clockevent */
+	compatible = "st,stm32-timer";
+	interrupts = <50>;
+	status = "okay";
+	/delete-property/#address-cells;
+	/delete-property/#size-cells;
+	/delete-property/clock-names;
+	/delete-node/pwm;
+	/delete-node/timer@4;
+};
+
 &usart1 {
 	pinctrl-0 = <&usart1_pins_b>;
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/stm32f746.dtsi b/arch/arm/dts/stm32f746.dtsi
index 78facde2b5..c97b3d0d07 100644
--- a/arch/arm/dts/stm32f746.dtsi
+++ b/arch/arm/dts/stm32f746.dtsi
@@ -39,14 +39,6 @@
 	};
 
 	soc {
-		timer2: timer@40000000 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000000 0x400>;
-			interrupts = <28>;
-			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM2)>;
-			status = "disabled";
-		};
-
 		timers2: timers@40000000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -69,14 +61,6 @@
 			};
 		};
 
-		timer3: timer@40000400 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000400 0x400>;
-			interrupts = <29>;
-			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM3)>;
-			status = "disabled";
-		};
-
 		timers3: timers@40000400 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -99,14 +83,6 @@
 			};
 		};
 
-		timer4: timer@40000800 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000800 0x400>;
-			interrupts = <30>;
-			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM4)>;
-			status = "disabled";
-		};
-
 		timers4: timers@40000800 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -129,13 +105,6 @@
 			};
 		};
 
-		timer5: timer@40000c00 {
-			compatible = "st,stm32-timer";
-			reg = <0x40000c00 0x400>;
-			interrupts = <50>;
-			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM5)>;
-		};
-
 		timers5: timers@40000c00 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -158,14 +127,6 @@
 			};
 		};
 
-		timer6: timer@40001000 {
-			compatible = "st,stm32-timer";
-			reg = <0x40001000 0x400>;
-			interrupts = <54>;
-			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM6)>;
-			status = "disabled";
-		};
-
 		timers6: timers@40001000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -182,14 +143,6 @@
 			};
 		};
 
-		timer7: timer@40001400 {
-			compatible = "st,stm32-timer";
-			reg = <0x40001400 0x400>;
-			interrupts = <55>;
-			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM7)>;
-			status = "disabled";
-		};
-
 		timers7: timers@40001400 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -229,8 +182,6 @@
 		};
 
 		timers13: timers@40001c00 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40001C00 0x400>;
 			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM13)>;
@@ -245,8 +196,6 @@
 		};
 
 		timers14: timers@40002000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40002000 0x400>;
 			clocks = <&rcc 0 STM32F7_APB1_CLOCK(TIM14)>;
@@ -313,7 +262,6 @@
 			clocks = <&rcc 1 CLK_I2C1>;
 			#address-cells = <1>;
 			#size-cells = <0>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -326,20 +274,18 @@
 			clocks = <&rcc 1 CLK_I2C2>;
 			#address-cells = <1>;
 			#size-cells = <0>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
-		i2c3: i2c@40005C00 {
+		i2c3: i2c@40005c00 {
 			compatible = "st,stm32f7-i2c";
-			reg = <0x40005C00 0x400>;
+			reg = <0x40005c00 0x400>;
 			interrupts = <72>,
 				     <73>;
 			resets = <&rcc STM32F7_APB1_RESET(I2C3)>;
 			clocks = <&rcc 1 CLK_I2C3>;
 			#address-cells = <1>;
 			#size-cells = <0>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -352,7 +298,6 @@
 			clocks = <&rcc 1 CLK_I2C4>;
 			#address-cells = <1>;
 			#size-cells = <0>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -441,7 +386,7 @@
 			status = "disabled";
 		};
 
-		sdio2: sdio2@40011c00 {
+		sdio2: mmc@40011c00 {
 			compatible = "arm,pl180", "arm,primecell";
 			arm,primecell-periphid = <0x00880180>;
 			reg = <0x40011c00 0x400>;
@@ -452,7 +397,7 @@
 			status = "disabled";
 		};
 
-		sdio1: sdio1@40012c00 {
+		sdio1: mmc@40012c00 {
 			compatible = "arm,pl180", "arm,primecell";
 			arm,primecell-periphid = <0x00880180>;
 			reg = <0x40012c00 0x400>;
@@ -499,8 +444,6 @@
 		};
 
 		timers10: timers@40014400 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40014400 0x400>;
 			clocks = <&rcc 0 STM32F7_APB2_CLOCK(TIM10)>;
@@ -515,8 +458,6 @@
 		};
 
 		timers11: timers@40014800 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-timers";
 			reg = <0x40014800 0x400>;
 			clocks = <&rcc 0 STM32F7_APB2_CLOCK(TIM11)>;
diff --git a/arch/arm/dts/stm32f769-disco.dts b/arch/arm/dts/stm32f769-disco.dts
index 03cfbd7cc2..6f93fc7bcf 100644
--- a/arch/arm/dts/stm32f769-disco.dts
+++ b/arch/arm/dts/stm32f769-disco.dts
@@ -39,12 +39,10 @@
 		};
 	};
 
-	gpio_keys {
+	gpio-keys {
 		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
 		autorepeat;
-		button@0 {
+		button-0 {
 			label = "User";
 			linux,code = <KEY_HOME>;
 			gpios = <&gpioa 0 GPIO_ACTIVE_HIGH>;
@@ -103,6 +101,18 @@
 	bus-width = <4>;
 };
 
+&timers5 {
+	/* Override timer5 to act as clockevent */
+	compatible = "st,stm32-timer";
+	interrupts = <50>;
+	status = "okay";
+	/delete-property/#address-cells;
+	/delete-property/#size-cells;
+	/delete-property/clock-names;
+	/delete-node/pwm;
+	/delete-node/timer@4;
+};
+
 &usart1 {
 	pinctrl-0 = <&usart1_pins_a>;
 	pinctrl-names = "default";
diff --git a/arch/arm/dts/stm32h743.dtsi b/arch/arm/dts/stm32h743.dtsi
index dbfebf07f2..c490d0a571 100644
--- a/arch/arm/dts/stm32h743.dtsi
+++ b/arch/arm/dts/stm32h743.dtsi
@@ -124,7 +124,6 @@
 				     <32>;
 			resets = <&rcc STM32H7_APB1L_RESET(I2C1)>;
 			clocks = <&rcc I2C1_CK>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -137,7 +136,6 @@
 				     <34>;
 			resets = <&rcc STM32H7_APB1L_RESET(I2C2)>;
 			clocks = <&rcc I2C2_CK>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -150,7 +148,6 @@
 				     <73>;
 			resets = <&rcc STM32H7_APB1L_RESET(I2C3)>;
 			clocks = <&rcc I2C3_CK>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -337,12 +334,11 @@
 			dma-requests = <32>;
 		};
 
-		sdmmc1: sdmmc@52007000 {
+		sdmmc1: mmc@52007000 {
 			compatible = "arm,pl18x", "arm,primecell";
 			arm,primecell-periphid = <0x10153180>;
 			reg = <0x52007000 0x1000>;
 			interrupts = <49>;
-			interrupt-names	= "cmd_irq";
 			clocks = <&rcc SDMMC1_CK>;
 			clock-names = "apb_pclk";
 			resets = <&rcc STM32H7_AHB3_RESET(SDMMC1)>;
@@ -351,18 +347,18 @@
 			max-frequency = <120000000>;
 		};
 
-		sdmmc2: sdmmc@48022400 {
+		sdmmc2: mmc@48022400 {
 			compatible = "arm,pl18x", "arm,primecell";
 			arm,primecell-periphid = <0x10153180>;
 			reg = <0x48022400 0x400>;
 			interrupts = <124>;
-			interrupt-names	= "cmd_irq";
 			clocks = <&rcc SDMMC2_CK>;
 			clock-names = "apb_pclk";
 			resets = <&rcc STM32H7_AHB2_RESET(SDMMC2)>;
 			cap-sd-highspeed;
 			cap-mmc-highspeed;
 			max-frequency = <120000000>;
+			status = "disabled";
 		};
 
 		exti: interrupt-controller@58000000 {
@@ -398,7 +394,6 @@
 				     <96>;
 			resets = <&rcc STM32H7_APB4_RESET(I2C4)>;
 			clocks = <&rcc I2C4_CK>;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
@@ -452,8 +447,6 @@
 		};
 
 		lptimer4: timer@58002c00 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-lptimer";
 			reg = <0x58002c00 0x400>;
 			clocks = <&rcc LPTIM4_CK>;
@@ -468,8 +461,6 @@
 		};
 
 		lptimer5: timer@58003000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
 			compatible = "st,stm32-lptimer";
 			reg = <0x58003000 0x400>;
 			clocks = <&rcc LPTIM5_CK>;
@@ -554,7 +545,7 @@
 			status = "disabled";
 		};
 
-		pinctrl: pin-controller@58020000 {
+		pinctrl: pinctrl@58020000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32h743-pinctrl";
diff --git a/arch/arm/dts/stm32h743i-disco.dts b/arch/arm/dts/stm32h743i-disco.dts
index 3a01ebd563..b31188f8b9 100644
--- a/arch/arm/dts/stm32h743i-disco.dts
+++ b/arch/arm/dts/stm32h743i-disco.dts
@@ -41,10 +41,10 @@
 
 &mac {
 	status = "disabled";
-	pinctrl-0	= <&ethernet_rmii>;
-	pinctrl-names	= "default";
-	phy-mode	= "rmii";
-	phy-handle	= <&phy0>;
+	pinctrl-0 = <&ethernet_rmii>;
+	pinctrl-names = "default";
+	phy-mode = "rmii";
+	phy-handle = <&phy0>;
 
 	mdio0 {
 		#address-cells = <1>;
diff --git a/arch/arm/dts/stm32h743i-eval.dts b/arch/arm/dts/stm32h743i-eval.dts
index 38cc7faf68..5c5d8059bd 100644
--- a/arch/arm/dts/stm32h743i-eval.dts
+++ b/arch/arm/dts/stm32h743i-eval.dts
@@ -115,10 +115,10 @@
 
 &mac {
 	status = "disabled";
-	pinctrl-0	= <&ethernet_rmii>;
-	pinctrl-names	= "default";
-	phy-mode	= "rmii";
-	phy-handle	= <&phy0>;
+	pinctrl-0 = <&ethernet_rmii>;
+	pinctrl-names = "default";
+	phy-mode = "rmii";
+	phy-handle = <&phy0>;
 
 	mdio0 {
 		#address-cells = <1>;
diff --git a/arch/arm/dts/stm32h750i-art-pi.dts b/arch/arm/dts/stm32h750i-art-pi.dts
index 2a4d1cb496..c7c7132f22 100644
--- a/arch/arm/dts/stm32h750i-art-pi.dts
+++ b/arch/arm/dts/stm32h750i-art-pi.dts
@@ -87,10 +87,10 @@
 
 &mac {
 	status = "disabled";
-	pinctrl-0	= <&ethernet_rmii>;
-	pinctrl-names	= "default";
-	phy-mode	= "rmii";
-	phy-handle	= <&phy0>;
+	pinctrl-0 = <&ethernet_rmii>;
+	pinctrl-names = "default";
+	phy-mode = "rmii";
+	phy-handle = <&phy0>;
 
 	mdio0 {
 		#address-cells = <1>;
diff --git a/arch/arm/dts/stm32mp13-pinctrl.dtsi b/arch/arm/dts/stm32mp13-pinctrl.dtsi
index d2472cd8f1..6a7ae14477 100644
--- a/arch/arm/dts/stm32mp13-pinctrl.dtsi
+++ b/arch/arm/dts/stm32mp13-pinctrl.dtsi
@@ -6,6 +6,348 @@
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
 
 &pinctrl {
+	adc1_usb_cc_pins_a: adc1-usb-cc-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, ANALOG)>, /* ADC1 in6 */
+				 <STM32_PINMUX('A', 3, ANALOG)>; /* ADC1 in12 */
+		};
+	};
+
+	dcmipp_pins_a: dcmi-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  AF13)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  AF13)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  AF14)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  AF13)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  AF13)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  AF13)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  AF13)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  AF14)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  AF13)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  AF13)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  AF13)>;/* DCMI_D7 */
+			bias-disable;
+		};
+	};
+
+	dcmipp_sleep_pins_a: dcmi-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H',  8,  ANALOG)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('G',  9,  ANALOG)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('B',  7,  ANALOG)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A',  9,  ANALOG)>,/* DCMI_D0 */
+				 <STM32_PINMUX('D',  0,  ANALOG)>,/* DCMI_D1 */
+				 <STM32_PINMUX('G', 10,  ANALOG)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E',  4,  ANALOG)>,/* DCMI_D3 */
+				 <STM32_PINMUX('D', 11,  ANALOG)>,/* DCMI_D4 */
+				 <STM32_PINMUX('D',  3,  ANALOG)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B',  8,  ANALOG)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 14,  ANALOG)>;/* DCMI_D7 */
+		};
+	};
+
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	dfsdm_datin1_pins_a: dfsdm-datin1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF6)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin1_sleep_pins_a: dfsdm-datin1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* DFSDM_DATIN1 */
+		};
+	};
+
+	dfsdm_datin3_pins_a: dfsdm-datin3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	dfsdm_datin3_sleep_pins_a: dfsdm-datin3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATIN3 */
+		};
+	};
+
+	eth1_rmii_pins_a: eth1-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, AF11)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, AF11)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, AF11)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, AF11)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, AF10)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+
+	};
+
+	eth1_rmii_sleep_pins_a: eth1-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('B', 11, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('A', 1, ANALOG)>, /* ETH_RMII_REF_CLK */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 2, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('C', 1, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	eth2_rmii_pins_a: eth2-rmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF11)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, AF10)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, AF13)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, AF11)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, AF11)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 4, AF11)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, AF10)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, AF11)>; /* ETH_RMII_CRS_DV */
+			bias-disable;
+		};
+	};
+
+	eth2_rmii_sleep_pins_a: eth2-rmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RMII_TXD0 */
+				 <STM32_PINMUX('G', 11, ANALOG)>, /* ETH_RMII_TXD1 */
+				 <STM32_PINMUX('G', 8, ANALOG)>, /* ETH_RMII_ETHCK */
+				 <STM32_PINMUX('F', 6, ANALOG)>, /* ETH_RMII_TX_EN */
+				 <STM32_PINMUX('B', 2, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 4, ANALOG)>, /* ETH_RMII_RXD0 */
+				 <STM32_PINMUX('E', 2, ANALOG)>, /* ETH_RMII_RXD1 */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* ETH_RMII_CRS_DV */
+		};
+	};
+
+	goodix_pins_a: goodix-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 5, GPIO)>;
+			bias-pull-down;
+		};
+	};
+
+	i2c1_pins_a: i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
+				 <STM32_PINMUX('E', 8, AF5)>; /* I2C1_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c1_sleep_pins_a: i2c1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, ANALOG)>, /* I2C1_SCL */
+				 <STM32_PINMUX('E', 8, ANALOG)>; /* I2C1_SDA */
+		};
+	};
+
+	i2c5_pins_a: i2c5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 1, AF4)>, /* I2C5_SCL */
+				 <STM32_PINMUX('H', 6, AF4)>; /* I2C5_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c5_sleep_pins_a: i2c5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 1, ANALOG)>, /* I2C5_SCL */
+				 <STM32_PINMUX('H', 6, ANALOG)>; /* I2C5_SDA */
+		};
+	};
+
+	ltdc_pins_a: ltdc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, AF13)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, AF14)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, AF11)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, AF11)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, AF14)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, AF13)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, AF14)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, AF14)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, AF14)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, AF14)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, AF14)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, AF14)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, AF14)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, AF14)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, AF11)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, AF14)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, AF14)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, AF11)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, AF14)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, AF7)>,  /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, AF13)>; /* LCD_B7 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ltdc_sleep_pins_a: ltdc-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D',  9, ANALOG)>, /* LCD_CLK */
+				 <STM32_PINMUX('C',  6, ANALOG)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('G',  4, ANALOG)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('H',  9, ANALOG)>, /* LCD_DE */
+				 <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_R2 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* LCD_R3 */
+				 <STM32_PINMUX('D', 14, ANALOG)>, /* LCD_R4 */
+				 <STM32_PINMUX('E',  7, ANALOG)>, /* LCD_R5 */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* LCD_R6 */
+				 <STM32_PINMUX('E',  9, ANALOG)>, /* LCD_R7 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
+				 <STM32_PINMUX('F',  3, ANALOG)>, /* LCD_G3 */
+				 <STM32_PINMUX('D',  5, ANALOG)>, /* LCD_G4 */
+				 <STM32_PINMUX('G',  0, ANALOG)>, /* LCD_G5 */
+				 <STM32_PINMUX('C',  7, ANALOG)>, /* LCD_G6 */
+				 <STM32_PINMUX('A', 15, ANALOG)>, /* LCD_G7 */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* LCD_B2 */
+				 <STM32_PINMUX('F',  2, ANALOG)>, /* LCD_B3 */
+				 <STM32_PINMUX('H', 14, ANALOG)>, /* LCD_B4 */
+				 <STM32_PINMUX('E',  0, ANALOG)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  6, ANALOG)>, /* LCD_B6 */
+				 <STM32_PINMUX('F',  1, ANALOG)>; /* LCD_B7 */
+		};
+	};
+
+	mcp23017_pins_a: mcp23017-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, GPIO)>;
+			bias-pull-up;
+		};
+	};
+
+	pwm3_pins_a: pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, AF2)>; /* TIM3_CH4 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm3_sleep_pins_a: pwm3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 1, ANALOG)>; /* TIM3_CH4 */
+		};
+	};
+
+	pwm4_pins_a: pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, AF2)>; /* TIM4_CH2 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm4_sleep_pins_a: pwm4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, ANALOG)>; /* TIM4_CH2 */
+		};
+	};
+
+	pwm8_pins_a: pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, AF3)>; /* TIM8_CH3 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm8_sleep_pins_a: pwm8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 5, ANALOG)>; /* TIM8_CH3 */
+		};
+	};
+
+	pwm14_pins_a: pwm14-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 9, AF9)>; /* TIM14_CH1 */
+			bias-pull-down;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	pwm14_sleep_pins_a: pwm14-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 9, ANALOG)>; /* TIM14_CH1 */
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 1, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1_pins_a: sai1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, AF12)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, AF6)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, AF6)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, AF6)>; /* SAI1_FS_A */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sai1_sleep_pins_a: sai1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('A', 0, ANALOG)>, /* SAI1_SD_B */
+				 <STM32_PINMUX('A', 5, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('F', 11, ANALOG)>; /* SAI1_FS_A */
+		};
+	};
+
 	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -108,6 +450,36 @@
 		};
 	};
 
+	spi5_pins_a: spi5-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 7, AF6)>, /* SPI5_SCK */
+				 <STM32_PINMUX('H', 3, AF5)>; /* SPI5_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF5)>; /* SPI5_MISO */
+			bias-disable;
+		};
+	};
+
+	spi5_sleep_pins_a: spi5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 7, ANALOG)>, /* SPI5_SCK */
+				 <STM32_PINMUX('A', 8, ANALOG)>, /* SPI5_MISO */
+				 <STM32_PINMUX('H', 3, ANALOG)>; /* SPI5_MOSI */
+		};
+	};
+
+	stm32g0_intn_pins_a: stm32g0-intn-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, GPIO)>;
+			bias-pull-up;
+		};
+	};
+
 	uart4_pins_a: uart4-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('D', 6, AF8)>; /* UART4_TX */
@@ -120,4 +492,133 @@
 			bias-disable;
 		};
 	};
+
+	uart4_idle_pins_a: uart4-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>; /* UART4_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 8, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	uart4_sleep_pins_a: uart4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 6, ANALOG)>, /* UART4_TX */
+				 <STM32_PINMUX('D', 8, ANALOG)>; /* UART4_RX */
+		};
+	};
+
+	uart8_pins_a: uart8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, AF8)>; /* UART8_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart8_idle_pins_a: uart8-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>; /* UART8_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 9, AF8)>; /* UART8_RX */
+			bias-pull-up;
+		};
+	};
+
+	uart8_sleep_pins_a: uart8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 1, ANALOG)>, /* UART8_TX */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* UART8_RX */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, AF7)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>, /* USART1_RX */
+				 <STM32_PINMUX('A', 7, AF7)>; /* USART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('A', 7, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 2, AF7)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 0, AF4)>; /* USART1_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>, /* USART1_TX */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* USART1_RTS */
+				 <STM32_PINMUX('A', 7, ANALOG)>, /* USART1_CTS_NSS */
+				 <STM32_PINMUX('B', 0, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 12, AF1)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, AF3)>; /* USART2_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>, /* USART2_RX */
+				 <STM32_PINMUX('E', 11, AF2)>; /* USART2_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('H', 12, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('E', 11, ANALOG)>; /* USART2_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 4, AF3)>; /* USART2_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 15, AF1)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 12, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, ANALOG)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 15, ANALOG)>, /* USART2_RX */
+				 <STM32_PINMUX('E', 11, ANALOG)>; /* USART2_CTS_NSS */
+		};
+	};
 };
diff --git a/arch/arm/dts/stm32mp13-u-boot.dtsi b/arch/arm/dts/stm32mp13-u-boot.dtsi
index 01552adb7c..ff620da2ba 100644
--- a/arch/arm/dts/stm32mp13-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp13-u-boot.dtsi
@@ -17,6 +17,12 @@
 		pinctrl0 = &pinctrl;
 	};
 
+	firmware {
+		optee {
+			u-boot,dm-pre-reloc;
+		};
+	};
+
 	/* need PSCI for sysreset during board_f */
 	psci {
 		u-boot,dm-pre-proper;
@@ -35,6 +41,13 @@
 
 			status = "okay";
 		};
+
+		etzpc: etzpc@5c007000 {
+			/* pre-reloc probe = reserve video frame buffer in video_reserve() */
+			display-controller@5a001000 {
+				u-boot,dm-pre-proper;
+			};
+		};
 	};
 };
 
@@ -42,6 +55,10 @@
 	u-boot,dm-pre-reloc;
 };
 
+&etzpc {
+	u-boot,dm-pre-reloc;
+};
+
 &gpioa {
 	u-boot,dm-pre-reloc;
 };
@@ -82,11 +99,11 @@
 	u-boot,dm-pre-reloc;
 };
 
-&optee {
+&pinctrl {
 	u-boot,dm-pre-reloc;
 };
 
-&pinctrl {
+&rcc {
 	u-boot,dm-pre-reloc;
 };
 
@@ -102,14 +119,11 @@
 	u-boot,dm-pre-reloc;
 };
 
-&scmi_shm {
-	u-boot,dm-pre-reloc;
-};
-
-&scmi_sram {
+&syscfg {
 	u-boot,dm-pre-reloc;
 };
 
-&syscfg {
+&usbphyc {
+	/* stm32-usbphyc-clk = ck_usbo_48m is a source clock of RCC CCF */
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32mp131.dtsi b/arch/arm/dts/stm32mp131.dtsi
index 84e16bb2f2..108ac5d6f0 100644
--- a/arch/arm/dts/stm32mp131.dtsi
+++ b/arch/arm/dts/stm32mp131.dtsi
@@ -3,7 +3,12 @@
  * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
+#include <dt-bindings/bus/stm32mp13_sys_bus.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/stm32mp13-clks.h>
+#include <dt-bindings/regulator/st,stm32mp13-regulator.h>
+#include <dt-bindings/reset/stm32mp13-resets.h>
+#include <dt-bindings/thermal/thermal.h>
 
 / {
 	#address-cells = <1>;
@@ -17,9 +22,22 @@
 			compatible = "arm,cortex-a7";
 			device_type = "cpu";
 			reg = <0>;
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			nvmem-cells = <&part_number_otp>;
+			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
 		};
 	};
 
+	intc: interrupt-controller@a0021000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0xa0021000 0x1000>,
+		      <0xa0022000 0x2000>;
+	};
+
 	arm-pmu {
 		compatible = "arm,cortex-a7-pmu";
 		interrupts = <GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>;
@@ -27,23 +45,35 @@
 		interrupt-parent = <&intc>;
 	};
 
-	scmi_sram: sram@2ffff000 {
-		compatible = "mmio-sram";
-		reg = <0x2ffff000 0x1000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-		ranges = <0 0x2ffff000 0x1000>;
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xb200005a>;
+		status = "disabled";
+	};
 
-		scmi_shm: scmi_shm@0 {
-			compatible = "arm,scmi-shmem";
-			reg = <0 0x80>;
-		};
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		interrupt-parent = <&intc>;
+		always-on;
 	};
 
 	firmware {
 		optee: optee {
 			method = "smc";
 			compatible = "linaro,optee-tz";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
 		};
 
 		scmi: scmi {
@@ -51,7 +81,11 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 			linaro,optee-channel-id = <0>;
-			shmem = <&scmi_shm>;
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
 
 			scmi_clk: protocol@14 {
 				reg = <0x14>;
@@ -62,103 +96,695 @@
 				reg = <0x16>;
 				#reset-cells = <1>;
 			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_reg11: regulator@0 {
+						reg = <VOLTD_SCMI_REG11>;
+						regulator-name = "reg11";
+					};
+					scmi_reg18: regulator@1 {
+						reg = <VOLTD_SCMI_REG18>;
+						regulator-name = "reg18";
+					};
+					scmi_usb33: regulator@2 {
+						reg = <VOLTD_SCMI_USB33>;
+						regulator-name = "usb33";
+					};
+				};
+			};
 		};
 	};
 
-	clocks {
-		clk_axi: clk-axi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <266500000>;
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
 		};
+	};
 
-		clk_hse: clk-hse {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <24000000>;
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&dts>;
+
+			trips {
+				cpu_alert: cpu-alert0 {
+					temperature = <95000>;
+					hysteresis = <10000>;
+					type = "passive";
+				};
+				cpu_crit: cpu-crit0 {
+					temperature = <120000>;
+					hysteresis = <0>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert>;
+					cooling-device = <&cpu0 1 1>;
+				};
+			};
 		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges;
+
+		timers2: timer@40000000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40000000 0x400>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 18 0x400 0x1>,
+			       <&dmamux1 19 0x400 0x1>,
+			       <&dmamux1 20 0x400 0x1>,
+			       <&dmamux1 21 0x400 0x1>,
+			       <&dmamux1 22 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@1 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <1>;
+				status = "disabled";
+			};
 
-		clk_hsi: clk-hsi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <64000000>;
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
 		};
 
-		clk_lsi: clk-lsi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <32000>;
+		timers3: timer@40001000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40001000 0x400>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 23 0x400 0x1>,
+			       <&dmamux1 24 0x400 0x1>,
+			       <&dmamux1 25 0x400 0x1>,
+			       <&dmamux1 26 0x400 0x1>,
+			       <&dmamux1 27 0x400 0x1>,
+			       <&dmamux1 28 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@2 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <2>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
 		};
 
-		clk_pclk3: clk-pclk3 {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <104438965>;
+		timers4: timer@40002000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40002000 0x400>;
+			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 29 0x400 0x1>,
+			       <&dmamux1 30 0x400 0x1>,
+			       <&dmamux1 31 0x400 0x1>,
+			       <&dmamux1 32 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "up";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@3 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <3>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
 		};
 
-		clk_pclk4: clk-pclk4 {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <133250000>;
+		timers5: timer@40003000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40003000 0x400>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 55 0x400 0x1>,
+			       <&dmamux1 56 0x400 0x1>,
+			       <&dmamux1 57 0x400 0x1>,
+			       <&dmamux1 58 0x400 0x1>,
+			       <&dmamux1 59 0x400 0x1>,
+			       <&dmamux1 60 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@4 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <4>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
 		};
 
-		clk_pll4_p: clk-pll4_p {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <50000000>;
+		timers6: timer@40004000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40004000 0x400>;
+			interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 69 0x400 0x1>;
+			dma-names = "up";
+			status = "disabled";
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+
+			timer@5 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <5>;
+				status = "disabled";
+			};
 		};
 
-		clk_pll4_r: clk-pll4_r {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <99000000>;
+		timers7: timer@40005000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x40005000 0x400>;
+			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "global";
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 70 0x400 0x1>;
+			dma-names = "up";
+			status = "disabled";
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+
+			timer@6 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <6>;
+				status = "disabled";
+			};
 		};
 
-		clk_rtc_k: clk-rtc-k {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <32768>;
+		lptimer1: timer@40009000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-lptimer";
+			reg = <0x40009000 0x400>;
+			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			trigger@0 {
+				compatible = "st,stm32-lptimer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-lptimer-counter";
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
 		};
-	};
 
-	intc: interrupt-controller@a0021000 {
-		compatible = "arm,cortex-a7-gic";
-		#interrupt-cells = <3>;
-		interrupt-controller;
-		reg = <0xa0021000 0x1000>,
-		      <0xa0022000 0x2000>;
-	};
+		i2s2: audio-controller@4000b000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000b000 0x400>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
 
-	psci {
-		compatible = "arm,psci-1.0";
-		method = "smc";
-	};
+		spi2: spi@4000b000 {
+			compatible = "st,stm32h7-spi";
+			reg = <0x4000b000 0x400>;
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI2_K>;
+			resets = <&rcc SPI2_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 39 0x400 0x01>,
+			       <&dmamux1 40 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
 
-	timer {
-		compatible = "arm,armv7-timer";
-		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
-			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
-		interrupt-parent = <&intc>;
-		always-on;
-	};
+		i2s3: audio-controller@4000c000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x4000c000 0x400>;
+			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 61 0x400 0x01>,
+			       <&dmamux1 62 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
 
-	soc {
-		compatible = "simple-bus";
-		#address-cells = <1>;
-		#size-cells = <1>;
-		interrupt-parent = <&intc>;
-		ranges;
+		spi3: spi@4000c000 {
+			compatible = "st,stm32h7-spi";
+			reg = <0x4000c000 0x400>;
+			interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI3_K>;
+			resets = <&rcc SPI3_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 61 0x400 0x01>,
+			       <&dmamux1 62 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		spdifrx: audio-controller@4000d000 {
+			compatible = "st,stm32h7-spdifrx";
+			#sound-dai-cells = <0>;
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 93 0x400 0x01>,
+			       <&dmamux1 94 0x400 0x01>;
+			dma-names = "rx", "rx-ctrl";
+			status = "disabled";
+		};
+
+		usart3: serial@4000f000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x4000f000 0x400>;
+			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART3_K>;
+			resets = <&rcc USART3_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 45 0x400 0x5>,
+			       <&dmamux1 46 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
 
 		uart4: serial@40010000 {
 			compatible = "st,stm32h7-uart";
 			reg = <0x40010000 0x400>;
-			interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_hsi>;
+			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART4_K>;
+			resets = <&rcc UART4_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 63 0x400 0x5>,
+			       <&dmamux1 64 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart5: serial@40011000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40011000 0x400>;
+			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART5_K>;
+			resets = <&rcc UART5_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 65 0x400 0x5>,
+			       <&dmamux1 66 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2c1: i2c@40012000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x40012000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C1_K>;
+			resets = <&rcc I2C1_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 33 0x400 0x1>,
+			       <&dmamux1 34 0x400 0x1>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x1>;
+			i2c-analog-filter;
+			status = "disabled";
+		};
+
+		i2c2: i2c@40013000 {
+			compatible = "st,stm32mp13-i2c";
+			reg = <0x40013000 0x400>;
+			interrupt-names = "event", "error";
+			interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc I2C2_K>;
+			resets = <&rcc I2C2_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 35 0x400 0x1>,
+			       <&dmamux1 36 0x400 0x1>;
+			dma-names = "rx", "tx";
+			st,syscfg-fmp = <&syscfg 0x4 0x2>;
+			i2c-analog-filter;
+			status = "disabled";
+		};
+
+		uart7: serial@40018000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40018000 0x400>;
+			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART7_K>;
+			resets = <&rcc UART7_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 79 0x400 0x5>,
+			       <&dmamux1 80 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		uart8: serial@40019000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x40019000 0x400>;
+			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc UART8_K>;
+			resets = <&rcc UART8_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 81 0x400 0x5>,
+			       <&dmamux1 82 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		timers1: timer@44000000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x44000000 0x400>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "brk", "up", "trg-com", "cc";
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 11 0x400 0x1>,
+			       <&dmamux1 12 0x400 0x1>,
+			       <&dmamux1 13 0x400 0x1>,
+			       <&dmamux1 14 0x400 0x1>,
+			       <&dmamux1 15 0x400 0x1>,
+			       <&dmamux1 16 0x400 0x1>,
+			       <&dmamux1 17 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@0 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <0>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		timers8: timer@44001000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "st,stm32-timers";
+			reg = <0x44001000 0x400>;
+			interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "brk", "up", "trg-com", "cc";
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			dmas = <&dmamux1 47 0x400 0x1>,
+			       <&dmamux1 48 0x400 0x1>,
+			       <&dmamux1 49 0x400 0x1>,
+			       <&dmamux1 50 0x400 0x1>,
+			       <&dmamux1 51 0x400 0x1>,
+			       <&dmamux1 52 0x400 0x1>,
+			       <&dmamux1 53 0x400 0x1>;
+			dma-names = "ch1", "ch2", "ch3", "ch4",
+				    "up", "trig", "com";
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer@7 {
+				compatible = "st,stm32h7-timer-trigger";
+				reg = <7>;
+				status = "disabled";
+			};
+
+			counter {
+				compatible = "st,stm32-timer-counter";
+				status = "disabled";
+			};
+		};
+
+		usart6: serial@44003000 {
+			compatible = "st,stm32h7-uart";
+			reg = <0x44003000 0x400>;
+			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc USART6_K>;
+			resets = <&rcc USART6_R>;
+			wakeup-source;
+			power-domains = <&pd_core_ret>;
+			dmas = <&dmamux1 71 0x400 0x5>,
+			       <&dmamux1 72 0x400 0x1>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		i2s1: audio-controller@44004000 {
+			compatible = "st,stm32h7-i2s";
+			#sound-dai-cells = <0>;
+			reg = <0x44004000 0x400>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmamux1 37 0x400 0x01>,
+			       <&dmamux1 38 0x400 0x01>;
+			dma-names = "rx", "tx";
 			status = "disabled";
 		};
 
+		spi1: spi@44004000 {
+			compatible = "st,stm32h7-spi";
+			reg = <0x44004000 0x400>;
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SPI1_K>;
+			resets = <&rcc SPI1_R>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			dmas = <&dmamux1 37 0x400 0x01>,
+			       <&dmamux1 38 0x400 0x01>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		sai1: sai@4400a000 {
+			compatible = "st,stm32h7-sai";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x4400a000 0x400>;
+			reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
+			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI1_R>;
+			status = "disabled";
+
+			sai1a: audio-controller@4400a004 {
+				#sound-dai-cells = <0>;
+
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				clocks = <&rcc SAI1_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 87 0x400 0x01>;
+				status = "disabled";
+			};
+
+			sai1b: audio-controller@4400a024 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				clocks = <&rcc SAI1_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 88 0x400 0x01>;
+				status = "disabled";
+			};
+		};
+
+		sai2: sai@4400b000 {
+			compatible = "st,stm32h7-sai";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x4400b000 0x400>;
+			reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
+			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&rcc SAI2_R>;
+			status = "disabled";
+
+			sai2a: audio-controller@4400b004 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-a";
+				reg = <0x4 0x20>;
+				clocks = <&rcc SAI2_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 89 0x400 0x01>;
+				status = "disabled";
+			};
+
+			sai2b: audio-controller@4400b024 {
+				#sound-dai-cells = <0>;
+				compatible = "st,stm32-sai-sub-b";
+				reg = <0x24 0x20>;
+				clocks = <&rcc SAI2_K>;
+				clock-names = "sai_ck";
+				dmas = <&dmamux1 90 0x400 0x01>;
+				status = "disabled";
+			};
+		};
+
+		dfsdm: dfsdm@4400d000 {
+			compatible = "st,stm32mp1-dfsdm";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>;
+			clock-names = "dfsdm";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			dfsdm0: filter@0 {
+				compatible = "st,stm32-dfsdm-adc";
+				#io-channel-cells = <1>;
+				reg = <0>;
+				interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 101 0x400 0x01>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+
+			dfsdm1: filter@1 {
+				compatible = "st,stm32-dfsdm-adc";
+				#io-channel-cells = <1>;
+				reg = <1>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 102 0x400 0x01>;
+				dma-names = "rx";
+				status = "disabled";
+			};
+		};
+
 		dma1: dma-controller@48000000 {
 			compatible = "st,stm32-dma";
 			reg = <0x48000000 0x400>;
@@ -170,7 +796,8 @@
 				     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_pclk4>;
+			clocks = <&rcc DMA1>;
+			resets = <&rcc DMA1_R>;
 			#dma-cells = <4>;
 			st,mem2mem;
 			dma-requests = <8>;
@@ -187,7 +814,8 @@
 				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_pclk4>;
+			clocks = <&rcc DMA2>;
+			resets = <&rcc DMA2_R>;
 			#dma-cells = <4>;
 			st,mem2mem;
 			dma-requests = <8>;
@@ -196,109 +824,33 @@
 		dmamux1: dma-router@48002000 {
 			compatible = "st,stm32h7-dmamux";
 			reg = <0x48002000 0x40>;
-			clocks = <&clk_pclk4>;
+			clocks = <&rcc DMAMUX1>;
+			resets = <&rcc DMAMUX1_R>;
 			#dma-cells = <3>;
 			dma-masters = <&dma1 &dma2>;
 			dma-requests = <128>;
 			dma-channels = <16>;
 		};
 
-		exti: interrupt-controller@5000d000 {
-			compatible = "st,stm32mp13-exti", "syscon";
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			reg = <0x5000d000 0x400>;
-		};
-
-		syscfg: syscon@50020000 {
-			compatible = "st,stm32mp157-syscfg", "syscon";
-			reg = <0x50020000 0x400>;
-			clocks = <&clk_pclk3>;
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp13-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				 <&scmi_clk CK_SCMI_HSI>,
+				 <&scmi_clk CK_SCMI_CSI>,
+				 <&scmi_clk CK_SCMI_LSE>,
+				 <&scmi_clk CK_SCMI_LSI>;
 		};
 
-		mdma: dma-controller@58000000 {
-			compatible = "st,stm32h7-mdma";
-			reg = <0x58000000 0x1000>;
-			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_pclk4>;
-			#dma-cells = <5>;
-			dma-channels = <32>;
-			dma-requests = <48>;
-		};
-
-		sdmmc1: mmc@58005000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x20253180>;
-			reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
-			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&clk_pll4_p>;
-			clock-names = "apb_pclk";
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <130000000>;
-			status = "disabled";
-		};
-
-		sdmmc2: mmc@58007000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x20253180>;
-			reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
-			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&clk_pll4_p>;
-			clock-names = "apb_pclk";
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <130000000>;
-			status = "disabled";
-		};
-
-		iwdg2: watchdog@5a002000 {
-			compatible = "st,stm32mp1-iwdg";
-			reg = <0x5a002000 0x400>;
-			clocks = <&clk_pclk4>, <&clk_lsi>;
-			clock-names = "pclk", "lsi";
-			status = "disabled";
-		};
-
-		rtc: rtc@5c004000 {
-			compatible = "st,stm32mp1-rtc";
-			reg = <0x5c004000 0x400>;
-			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_pclk4>, <&clk_rtc_k>;
-			clock-names = "pclk", "rtc_ck";
-			status = "disabled";
-		};
-
-		bsec: efuse@5c005000 {
-			compatible = "st,stm32mp13-bsec";
-			reg = <0x5c005000 0x400>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			part_number_otp: part_number_otp@4 {
-				reg = <0x4 0x2>;
-			};
-			ts_cal1: calib@5c {
-				reg = <0x5c 0x2>;
-			};
-			ts_cal2: calib@5e {
-				reg = <0x5e 0x2>;
-			};
-		};
-
-		/*
-		 * Break node order to solve dependency probe issue between
-		 * pinctrl and exti.
-		 */
 		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
 			#size-cells = <1>;
 			compatible = "st,stm32mp135-pinctrl";
 			ranges = <0 0x50002000 0x8400>;
 			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
 			pins-are-numbered;
 
 			gpioa: gpio@50002000 {
@@ -307,7 +859,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x0 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOA>;
 				st,bank-name = "GPIOA";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 0 16>;
@@ -319,7 +871,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x1000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOB>;
 				st,bank-name = "GPIOB";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 16 16>;
@@ -331,7 +883,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x2000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOC>;
 				st,bank-name = "GPIOC";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 32 16>;
@@ -343,7 +895,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x3000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOD>;
 				st,bank-name = "GPIOD";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 48 16>;
@@ -355,7 +907,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x4000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOE>;
 				st,bank-name = "GPIOE";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 64 16>;
@@ -367,7 +919,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x5000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOF>;
 				st,bank-name = "GPIOF";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 80 16>;
@@ -379,7 +931,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x6000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOG>;
 				st,bank-name = "GPIOG";
 				ngpios = <16>;
 				gpio-ranges = <&pinctrl 0 96 16>;
@@ -391,7 +943,7 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x7000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOH>;
 				st,bank-name = "GPIOH";
 				ngpios = <15>;
 				gpio-ranges = <&pinctrl 0 112 15>;
@@ -403,11 +955,914 @@
 				interrupt-controller;
 				#interrupt-cells = <2>;
 				reg = <0x8000 0x400>;
-				clocks = <&clk_pclk4>;
+				clocks = <&rcc GPIOI>;
 				st,bank-name = "GPIOI";
 				ngpios = <8>;
 				gpio-ranges = <&pinctrl 0 128 8>;
 			};
 		};
+
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 68  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 41  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 43  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 78  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 34  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 73  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 54  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 84  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_40 */
+				<0>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 96  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 92  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<&intc GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 63  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
+		};
+
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
+		};
+
+		lptimer4: timer@50023000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50023000 0x400>;
+			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		lptimer5: timer@50024000 {
+			compatible = "st,stm32-lptimer";
+			reg = <0x50024000 0x400>;
+			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			power-domains = <&pd_core_ret>;
+			wakeup-source;
+			status = "disabled";
+
+			pwm {
+				compatible = "st,stm32-pwm-lp";
+				#pwm-cells = <3>;
+				status = "disabled";
+			};
+
+			timer {
+				compatible = "st,stm32-lptimer-timer";
+				status = "disabled";
+			};
+		};
+
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc DTS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
+			reg = <0x50028000 0x100>;
+			status = "disabled";
+		};
+
+		hdp: pinctrl@5002a000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
+			status = "disabled";
+		};
+
+		mdma: dma-controller@58000000 {
+			compatible = "st,stm32h7-mdma";
+			reg = <0x58000000 0x1000>;
+			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc MDMA>;
+			#dma-cells = <5>;
+			dma-channels = <32>;
+			dma-requests = <48>;
+		};
+
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
+			status = "disabled";
+		};
+
+		usbh_ohci: usb@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		usbh_ehci: usb@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
+			wakeup-source;
+			status = "disabled";
+		};
+
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+			clock-names = "pclk", "lsi";
+			status = "disabled";
+		};
+
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
+			status = "disabled";
+		};
+
+		rtc: rtc@5c004000 {
+			compatible = "st,stm32mp1-rtc";
+			reg = <0x5c004000 0x400>;
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_RTCAPB>,
+				 <&scmi_clk CK_SCMI_RTC>;
+			clock-names = "pclk", "rtc_ck";
+			status = "disabled";
+		};
+
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp13-bsec";
+			reg = <0x5c005000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp: part-number-otp@4 {
+				reg = <0x4 0x2>;
+				bits = <0 12>;
+			};
+			vrefint: vrefin-cal@52 {
+				reg = <0x52 0x2>;
+			};
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			ethernet_mac1_address: mac1@e4 {
+				reg = <0xe4 0x6>;
+			};
+			ethernet_mac2_address: mac2@ea {
+				reg = <0xea 0x6>;
+			};
+		};
+
+		etzpc: etzpc@5c007000 {
+			compatible = "st,stm32mp13-sys-bus";
+			reg = <0x5c007000 0x400>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+			feature-domain-controller;
+			#feature-domain-cells = <1>;
+
+			adc_2: adc@48004000 {
+				reg = <0x48004000 0x400>;
+				compatible = "st,stm32mp13-adc-core";
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC2>, <&rcc ADC2_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ADC2_ID>;
+				status = "disabled";
+
+				adc2: adc@0 {
+					compatible = "st,stm32mp13-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_2>;
+					interrupts = <0>;
+					dmas = <&dmamux1 10 0x400 0x80000001>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+
+					channel@13 {
+						reg = <13>;
+						label = "vrefint";
+					};
+					channel@14 {
+						reg = <14>;
+						label = "vddcore";
+					};
+					channel@16 {
+						reg = <16>;
+						label = "vddcpu";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddq_ddr";
+					};
+				};
+			};
+
+			usbotg_hs: usb@49000000 {
+				compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+				reg = <0x49000000 0x40000>;
+				clocks = <&rcc USBO_K>;
+				clock-names = "otg";
+				resets = <&rcc USBO_R>;
+				reset-names = "dwc2";
+				interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+				g-rx-fifo-size = <512>;
+				g-np-tx-fifo-size = <32>;
+				g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				usb33d-supply = <&scmi_usb33>;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_OTG_ID>;
+				status = "disabled";
+			};
+
+			usart1: serial@4c000000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4c000000 0x400>;
+				interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART1_K>;
+				resets = <&rcc USART1_R>;
+				wakeup-source;
+				power-domains = <&pd_core_ret>;
+				dmas = <&dmamux1 41 0x400 0x5>,
+				       <&dmamux1 42 0x400 0x1>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART1_ID>;
+				status = "disabled";
+			};
+
+			usart2: serial@4c001000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4c001000 0x400>;
+				interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART2_K>;
+				resets = <&rcc USART2_R>;
+				wakeup-source;
+				power-domains = <&pd_core_ret>;
+				dmas = <&dmamux1 43 0x400 0x5>,
+				       <&dmamux1 44 0x400 0x1>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART2_ID>;
+				status = "disabled";
+			};
+
+			i2s4: audio-controller@4c002000 {
+				compatible = "st,stm32h7-i2s";
+				#sound-dai-cells = <0>;
+				reg = <0x4c002000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI4_ID>;
+				status = "disabled";
+			};
+
+			spi4: spi@4c002000 {
+				compatible = "st,stm32h7-spi";
+				reg = <0x4c002000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI4_K>;
+				resets = <&rcc SPI4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI4_ID>;
+				status = "disabled";
+			};
+
+			spi5: spi@4c003000 {
+				compatible = "st,stm32h7-spi";
+				reg = <0x4c003000 0x400>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI5_K>;
+				resets = <&rcc SPI5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 85 0x400 0x01>,
+				       <&dmamux1 86 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI5_ID>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@4c004000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c004000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C3_K>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 73 0x400 0x1>,
+				       <&dmamux1 74 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x4>;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C3_ID>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@4c005000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c005000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C4_K>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 75 0x400 0x1>,
+				       <&dmamux1 76 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x8>;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C4_ID>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@4c006000 {
+				compatible = "st,stm32mp13-i2c";
+				reg = <0x4c006000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C5_K>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 115 0x400 0x1>,
+				       <&dmamux1 116 0x400 0x1>;
+				dma-names = "rx", "tx";
+				st,syscfg-fmp = <&syscfg 0x4 0x10>;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C5_ID>;
+				status = "disabled";
+			};
+
+			timers12: timer@4c007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c007000 0x400>;
+				interrupts = <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM12_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM12_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@4c008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c008000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM13_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM13_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@4c009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c009000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM14_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM14_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			timers15: timer@4c00a000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00a000 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM15_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 105 0x400 0x1>,
+				       <&dmamux1 106 0x400 0x1>,
+				       <&dmamux1 107 0x400 0x1>,
+				       <&dmamux1 108 0x400 0x1>;
+				dma-names = "ch1", "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM15_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@4c00b000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00b000 0x400>;
+				interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM16_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 109 0x400 0x1>,
+				       <&dmamux1 110 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM16_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@4c00c000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x4c00c000 0x400>;
+				interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM17_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 111 0x400 0x1>,
+				       <&dmamux1 112 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM17_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@50021000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50021000 0x400>;
+				interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM2_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core_ret>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM2_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
+
+			lptimer3: timer@50022000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50022000 0x400>;
+				interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM3_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core_ret>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM3_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
+
+			hash: hash@54003000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x54003000 0x400>;
+				interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&mdma 30 0x2 0x1000a02 0x0 0x0 0x0>;
+				dma-names = "in";
+				feature-domains = <&etzpc STM32MP1_ETZPC_HASH_ID>;
+				status = "disabled";
+			};
+
+			rng: rng@54004000 {
+				compatible = "st,stm32mp13-rng";
+				reg = <0x54004000 0x400>;
+				clocks = <&rcc RNG1_K>;
+				resets = <&rcc RNG1_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_RNG_ID>;
+				status = "disabled";
+			};
+
+			fmc: memory-controller@58002000 {
+				compatible = "st,stm32mp1-fmc2-ebi";
+				reg = <0x58002000 0x1000>;
+				ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+					 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+					 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+					 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+					 <4 0 0x80000000 0x10000000>; /* NAND */
+				#address-cells = <2>;
+				#size-cells = <1>;
+				clocks = <&rcc FMC_K>;
+				resets = <&rcc FMC_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_FMC_ID>;
+				status = "disabled";
+
+				nand-controller@4,0 {
+					compatible = "st,stm32mp1-fmc2-nfc";
+					reg = <4 0x00000000 0x1000>,
+					      <4 0x08010000 0x1000>,
+					      <4 0x08020000 0x1000>,
+					      <4 0x01000000 0x1000>,
+					      <4 0x09010000 0x1000>,
+					      <4 0x09020000 0x1000>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&mdma 24 0x2 0x12000a02 0x0 0x0>,
+					       <&mdma 24 0x2 0x12000a08 0x0 0x0>,
+					       <&mdma 25 0x2 0x12000a0a 0x0 0x0>;
+					dma-names = "tx", "rx", "ecc";
+					status = "disabled";
+				};
+			};
+
+			qspi: spi@58003000 {
+				compatible = "st,stm32f469-qspi";
+				reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+				reg-names = "qspi", "qspi_mm";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma 26 0x2 0x10100002 0x0 0x0>,
+				       <&mdma 26 0x2 0x10100008 0x0 0x0>;
+				dma-names = "tx", "rx";
+				clocks = <&rcc QSPI_K>;
+				resets = <&rcc QSPI_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_QSPI_ID>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@58005000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x20253180>;
+				reg = <0x58005000 0x1000>, <0x58006000 0x1000>;
+				interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC1_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <130000000>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SDMMC1_ID>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@58007000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x20253180>;
+				reg = <0x58007000 0x1000>, <0x58008000 0x1000>;
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC2_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <130000000>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SDMMC2_ID>;
+				status = "disabled";
+			};
+
+			eth1: eth1@5800a000 {
+				compatible = "snps,dwmac-4.20a", "st,stm32mp13-dwmac";
+				reg = <0x5800a000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti 68 1>;
+				interrupt-names = "macirq", "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc ETH1MAC>,
+					 <&rcc ETH1TX>,
+					 <&rcc ETH1RX>,
+					 <&rcc ETH1STP>,
+					 <&rcc ETH1CK_K>;
+				st,syscon = <&syscfg 0x4 0xff0000>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ETH1_ID>;
+				status = "disabled";
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+			};
+
+			usbphyc: usbphyc@5a006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				#clock-cells = <0>;
+				compatible = "st,stm32mp1-usbphyc";
+				reg = <0x5a006000 0x1000>;
+				clocks = <&rcc USBPHY_K>;
+				resets = <&rcc USBPHY_R>;
+				vdda1v1-supply = <&scmi_reg11>;
+				vdda1v8-supply = <&scmi_reg18>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_USBPHYCTRL_ID>;
+				status = "disabled";
+
+				usbphyc_port0: usb-phy@0 {
+					#phy-cells = <0>;
+					reg = <0>;
+					interrupts-extended = <&exti 42 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				usbphyc_port1: usb-phy@1 {
+					#phy-cells = <1>;
+					reg = <1>;
+					interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+				};
+			};
+		};
+
+		tamp: tamp@5c00a000 {
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x5c00a000 0x400>;
+			ranges;
+
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x5c00a100 0x80>;
+
+				saes_secret_key: tamp-bkp@0 {
+					/* see saes secret key feature */
+					reg = <0x0 0x20>;
+				};
+				boot_mode: tamp-bkp@78 {
+					/* see boot mode selection feature */
+					reg = <0x78 0x4>;
+				};
+				boot_counter: tamp-bkp@7c {
+					/* see boot counter feature */
+					reg = <0x7c 0x4>;
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp133.dtsi b/arch/arm/dts/stm32mp133.dtsi
index 0fb1386257..41b1c57186 100644
--- a/arch/arm/dts/stm32mp133.dtsi
+++ b/arch/arm/dts/stm32mp133.dtsi
@@ -15,7 +15,7 @@
 			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "int0", "int1";
-			clocks = <&clk_hse>, <&clk_pll4_r>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 			clock-names = "hclk", "cclk";
 			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
 			status = "disabled";
@@ -28,10 +28,77 @@
 			interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
 				     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
 			interrupt-names = "int0", "int1";
-			clocks = <&clk_hse>, <&clk_pll4_r>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 			clock-names = "hclk", "cclk";
 			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
 			status = "disabled";
 		};
+
+		etzpc: etzpc@5c007000 {
+			adc_1: adc@48003000 {
+				compatible = "st,stm32mp13-adc-core";
+				reg = <0x48003000 0x400>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC1>, <&rcc ADC1_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ADC1_ID>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp13-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc_1>;
+					interrupts = <0>;
+					dmas = <&dmamux1 9 0x400 0x80000001>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+
+					channel@18 {
+						reg = <18>;
+						label = "vrefint";
+					};
+				};
+			};
+
+			eth2: eth2@5800e000 {
+				compatible = "snps,dwmac-4.20a", "st,stm32mp13-dwmac";
+				reg = <0x5800e000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc ETH2MAC>,
+					 <&rcc ETH2TX>,
+					 <&rcc ETH2RX>,
+					 <&rcc ETH2STP>,
+					 <&rcc ETH2CK_K>;
+				st,syscon = <&syscfg 0x4 0xff000000>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,axi-config = <&stmmac_axi_config_2>;
+				snps,tso;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ETH2_ID>;
+				status = "disabled";
+
+				stmmac_axi_config_2: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+			};
+		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp135.dtsi b/arch/arm/dts/stm32mp135.dtsi
index abf2acd37b..c3d4b3198c 100644
--- a/arch/arm/dts/stm32mp135.dtsi
+++ b/arch/arm/dts/stm32mp135.dtsi
@@ -8,5 +8,29 @@
 
 / {
 	soc {
+		etzpc: etzpc@5c007000 {
+			dcmipp: dcmipp@5a000000 {
+				compatible = "st,stm32mp13-dcmipp";
+				reg = <0x5a000000 0x400>;
+				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPP_R>;
+				clocks = <&rcc DCMIPP_K>;
+				clock-names = "kclk";
+				feature-domains = <&etzpc STM32MP1_ETZPC_DCMIPP_ID>;
+				status = "disabled";
+			};
+
+			ltdc: display-controller@5a001000 {
+				compatible = "st,stm32-ltdc";
+				reg = <0x5a001000 0x400>;
+				interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LTDC_PX>;
+				clock-names = "lcd";
+				resets = <&scmi_reset RST_SCMI_LTDC>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LTDC_ID>;
+				status = "disabled";
+			};
+		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi b/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi
index cbe4eb5608..19caec51cd 100644
--- a/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp135f-dk-u-boot.dtsi
@@ -11,20 +11,36 @@
 	};
 
 	config {
-		u-boot,boot-led = "led-blue";
-		u-boot,error-led = "led-red";
+		u-boot,boot-led = "heartbeat";
+		u-boot,error-led = "error";
 		u-boot,mmc-env-partition = "u-boot-env";
+		st,adc_usb_pd = <&adc1 6>, <&adc1 12>;
+		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
 	};
 
 	leds {
 		led-red {
-			color = <LED_COLOR_ID_RED>;
+			label = "error";
 			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
+		};
+
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpioa 14 GPIO_ACTIVE_LOW>;
 		};
 	};
 };
 
+&sdmmc2 {
+	status = "disabled";
+};
+
 &uart4 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32mp135f-dk.dts b/arch/arm/dts/stm32mp135f-dk.dts
index f436ffab99..40e02fe88a 100644
--- a/arch/arm/dts/stm32mp135f-dk.dts
+++ b/arch/arm/dts/stm32mp135f-dk.dts
@@ -9,6 +9,8 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/st,stm32mp13-regulator.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
 #include "stm32mp135.dtsi"
 #include "stm32mp13xf.dtsi"
 #include "stm32mp13-pinctrl.dtsi"
@@ -18,7 +20,39 @@
 	compatible = "st,stm32mp135f-dk", "st,stm32mp135";
 
 	aliases {
+		ethernet0 = &eth1;
+		ethernet1 = &eth2;
 		serial0 = &uart4;
+		serial1 = &usart1;
+		serial2 = &uart8;
+		serial3 = &usart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_mco1: clk-mco1 {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
 	};
 
 	memory@c0000000 {
@@ -31,8 +65,8 @@
 		#size-cells = <1>;
 		ranges;
 
-		optee@de000000 {
-			reg = <0xde000000 0x2000000>;
+		optee@dd000000 {
+			reg = <0xdd000000 0x3000000>;
 			no-map;
 		};
 	};
@@ -59,39 +93,602 @@
 		};
 	};
 
-	vdd_sd: vdd-sd {
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioe 12 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	panel_rgb: panel-rgb {
+		compatible = "rocktech,rk043fn48h", "panel-dpi";
+		enable-gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_backlight>;
+		power-supply = <&scmi_v3v3_sw>;
+		data-mapping = "bgr666";
+		status = "okay";
+
+		width-mm = <105>;
+		height-mm = <67>;
+
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&ltdc_out_rgb>;
+			};
+		};
+
+		panel-timing {
+			clock-frequency = <10000000>;
+			hactive = <480>;
+			vactive = <272>;
+			hsync-len = <52>;
+			hfront-porch = <10>;
+			hback-porch = <10>;
+			vsync-len = <10>;
+			vfront-porch = <10>;
+			vback-porch = <10>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			de-active = <1>;
+			pixelclk-active = <1>;
+		};
+	};
+
+	v3v3_ao: v3v3-ao {
 		compatible = "regulator-fixed";
-		regulator-name = "vdd_sd";
-		regulator-min-microvolt = <2900000>;
-		regulator-max-microvolt = <2900000>;
+		regulator-name = "v3v3_ao";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
 		regulator-always-on;
 	};
+
+	wake_up {
+		compatible = "gpio-keys";
+		status = "okay";
+
+		button {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&mcp23017 11 GPIO_ACTIVE_LOW>;
+	};
 };
 
-&iwdg2 {
+&adc_1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc1_usb_cc_pins_a>;
+	vdda-supply = <&scmi_vdd_adc>;
+	vref-supply = <&scmi_vdd_adc>;
+	status = "okay";
+	adc1: adc@0 {
+		status = "okay";
+		/*
+		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in6 & in12.
+		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
+		 * 5 * (5.1 + 47kOhms) * 5pF => 1.3us.
+		 * Use arbitrary margin here (e.g. 5us).
+		 */
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@12 {
+			reg = <12>;
+			st,min-sample-time-ns = <5000>;
+		};
+	};
+};
+
+&arm_wdt {
 	timeout-sec = <32>;
 	status = "okay";
 };
 
+&crc1 {
+	status = "okay";
+};
+
+&cryp {
+	status = "okay";
+};
+
+&dcmipp {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmipp_pins_a>;
+	pinctrl-1 = <&dcmipp_sleep_pins_a>;
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&mipid02_2>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <0>;
+			pclk-max-frequency = <120000000>;
+		};
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rmii_pins_a>;
+	pinctrl-1 = <&eth1_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth1>;
+	nvmem-cells = <&ethernet_mac1_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+
+		phy0_eth1: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios =  <&mcp23017 9 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+			wakeup-source;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rmii_pins_a>;
+	pinctrl-1 = <&eth2_rmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rmii";
+	max-speed = <100>;
+	phy-handle = <&phy0_eth2>;
+	st,ext-phyclk;
+	phy-supply = <&scmi_v3v3_sw>;
+	nvmem-cells = <&ethernet_mac2_address>;
+	nvmem-cell-names = "mac-address";
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0_eth2: ethernet-phy@0 {
+			compatible = "ethernet-phy-id0007.c131";
+			reset-gpios = <&mcp23017 10 GPIO_ACTIVE_LOW>;
+			reg = <0>;
+		};
+	};
+};
+
+&i2c1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c1_pins_a>;
+	pinctrl-1 = <&i2c1_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <96>;
+	i2c-scl-falling-time-ns = <3>;
+	clock-frequency = <1000000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	mcp23017: pinctrl@21 {
+		compatible = "microchip,mcp23017";
+		reg = <0x21>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-parent = <&gpiog>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mcp23017_pins_a>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		microchip,irq-mirror;
+	};
+
+	typec@53 {
+		compatible = "st,stm32g0-typec";
+		reg = <0x53>;
+		/* Alert pin on PI2 (PWR wakeup pin), managed by optee */
+		interrupts-extended = <&optee 1>;
+		firmware-name = "stm32g0-ucsi.mp135f-dk.fw";
+		wakeup-source;
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+
+			port {
+				con_usb_c_g0_ep: endpoint {
+					remote-endpoint = <&usbotg_hs_ep>;
+				};
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <170>;
+	i2c-scl-falling-time-ns = <5>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	stmipi: stmipi@14 {
+		compatible = "st,st-mipid02";
+		reg = <0x14>;
+		status = "okay";
+		clocks = <&clk_mco1>;
+		clock-names = "xclk";
+		VDDE-supply = <&scmi_v1v8_periph>;
+		VDDIN-supply = <&scmi_v1v8_periph>;
+		reset-gpios = <&mcp23017 2 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+
+				mipid02_0: endpoint {
+					data-lanes = <1 2>;
+					lane-polarities = <0 0 0>;
+					remote-endpoint = <&gc2145_ep>;
+				};
+			};
+			port@2 {
+				reg = <2>;
+
+				mipid02_2: endpoint {
+					bus-width = <8>;
+					hsync-active = <0>;
+					vsync-active = <0>;
+					pclk-sample = <0>;
+					remote-endpoint = <&dcmipp_0>;
+				};
+			};
+		};
+	};
+
+	gc2145: gc2145@3c {
+		compatible = "galaxycore,gc2145";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		IOVDD-supply = <&scmi_v3v3_sw>;
+		AVDD-supply = <&scmi_v3v3_sw>;
+		DVDD-supply = <&scmi_v3v3_sw>;
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			gc2145_ep: endpoint {
+				remote-endpoint = <&mipid02_0>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&scmi_v3v3_sw>;
+		status = "disabled";
+		powerdown-gpios = <&mcp23017 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		reset-gpios = <&mcp23017 4 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+
+		port {
+			ov5640_0: endpoint {
+				/*remote-endpoint = <&mipid02_0>;*/
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	goodix: goodix-ts@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&goodix_pins_a>;
+		interrupt-parent = <&gpiof>;
+		interrupts = <5 IRQ_TYPE_NONE>;
+		reset-gpios = <&gpioh 2 GPIO_ACTIVE_LOW>;
+		AVDD28-supply = <&scmi_v3v3_sw>;
+		VDDIO-supply = <&scmi_v3v3_sw>;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <272>;
+		status = "okay" ;
+	};
+};
+
+&ltdc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ltdc_pins_a>;
+	pinctrl-1 = <&ltdc_sleep_pins_a>;
+	default-on;
+	status = "okay";
+
+	port {
+		ltdc_out_rgb: endpoint {
+			remote-endpoint = <&panel_in_rgb>;
+		};
+	};
+};
+
 &rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
 	status = "okay";
 };
 
+&scmi_regu {
+	scmi_vddcpu: regulator@6 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK1>;
+		regulator-name = "vddcpu";
+	};
+	scmi_vdd: regulator@8 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK3>;
+		regulator-name = "vdd";
+	};
+	scmi_vddcore: regulator@9 {
+		reg = <VOLTD_SCMI_STPMIC1_BUCK4>;
+		regulator-name = "vddcore";
+	};
+	scmi_vdd_adc: regulator@10 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO1>;
+		regulator-name = "vdd_adc";
+	};
+	scmi_vdd_usb: regulator@13 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO4>;
+		regulator-name = "vdd_usb";
+	};
+	scmi_vdd_sd: regulator@14 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO5>;
+		regulator-name = "vdd_sd";
+	};
+	scmi_v1v8_periph: regulator@15 {
+		reg = <VOLTD_SCMI_STPMIC1_LDO6>;
+		regulator-name = "v1v8_periph";
+	};
+	scmi_v3v3_sw: regulator@19 {
+		reg = <VOLTD_SCMI_STPMIC1_PWR_SW2>;
+		regulator-name = "v3v3_sw";
+	};
+};
+
 &sdmmc1 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_clk_pins_a>;
 	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_clk_pins_a>;
 	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
-	broken-cd;
+	cd-gpios = <&gpioh 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 	disable-wp;
 	st,neg-edge;
 	bus-width = <4>;
-	vmmc-supply = <&vdd_sd>;
+	vmmc-supply = <&scmi_vdd_sd>;
 	status = "okay";
 };
 
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_clk_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3_ao>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-parent = <&gpiof>;
+		interrupts = <0 IRQ_TYPE_LEVEL_HIGH>; /* WL_HOST_WAKE */
+		interrupt-names = "host-wake";
+	};
+};
+
+&spi5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi5_pins_a>;
+	pinctrl-1 = <&spi5_sleep_pins_a>;
+	status = "disabled";
+};
+
+&timers3 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm3_pins_a>;
+		pinctrl-1 = <&pwm3_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@2 {
+		status = "okay";
+	};
+};
+
+&timers4 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm4_pins_a>;
+		pinctrl-1 = <&pwm4_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@3 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers14 {
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm14_pins_a>;
+		pinctrl-1 = <&pwm14_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@13 {
+		status = "okay";
+	};
+};
+
 &uart4 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 };
+
+&uart8 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart8_pins_a>;
+	pinctrl-1 = <&uart8_sleep_pins_a>;
+	pinctrl-2 = <&uart8_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_sleep_pins_a>;
+	pinctrl-2 = <&usart2_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&mcp23017 13 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3_ao>;
+		vddio-supply = <&v3v3_ao>;
+	};
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&scmi_v3v3_sw>;
+	};
+};
+
+&usbotg_hs {
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	usb-role-switch;
+	status = "okay";
+	port {
+		usbotg_hs_ep: endpoint {
+			remote-endpoint = <&con_usb_c_g0_ep>;
+		};
+	};
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&scmi_vdd_usb>;
+	st,current-boost-microamp = <1000>;
+	st,decrease-hs-slew-rate;
+	st,tune-hs-dc-level = <2>;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <11>;
+	st,trim-hs-impedance = <2>;
+	st,tune-squelch-level = <1>;
+	st,enable-hs-rx-gain-eq;
+	st,no-hs-ftime-ctrl;
+	st,no-lsfs-sc;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&scmi_vdd_usb>;
+	st,current-boost-microamp = <1000>;
+	st,decrease-hs-slew-rate;
+	st,tune-hs-dc-level = <2>;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <11>;
+	st,trim-hs-impedance = <2>;
+	st,tune-squelch-level = <1>;
+	st,enable-hs-rx-gain-eq;
+	st,no-hs-ftime-ctrl;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp13xa.dtsi b/arch/arm/dts/stm32mp13xa.dtsi
new file mode 100644
index 0000000000..cc6456e71b
--- /dev/null
+++ b/arch/arm/dts/stm32mp13xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/dts/stm32mp13xc.dtsi b/arch/arm/dts/stm32mp13xc.dtsi
index fa6889e305..aa4ce81c74 100644
--- a/arch/arm/dts/stm32mp13xc.dtsi
+++ b/arch/arm/dts/stm32mp13xc.dtsi
@@ -6,12 +6,19 @@
 
 / {
 	soc {
-		cryp: crypto@54002000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_axi>;
-			status = "disabled";
+		etzpc: etzpc@5c007000 {
+			cryp: crypto@54002000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma 28 0x0 0x400202 0x0 0x0>,
+				       <&mdma 29 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp13xd.dtsi b/arch/arm/dts/stm32mp13xd.dtsi
new file mode 100644
index 0000000000..cc6456e71b
--- /dev/null
+++ b/arch/arm/dts/stm32mp13xd.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/dts/stm32mp13xf.dtsi b/arch/arm/dts/stm32mp13xf.dtsi
index fa6889e305..aa4ce81c74 100644
--- a/arch/arm/dts/stm32mp13xf.dtsi
+++ b/arch/arm/dts/stm32mp13xf.dtsi
@@ -6,12 +6,19 @@
 
 / {
 	soc {
-		cryp: crypto@54002000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&clk_axi>;
-			status = "disabled";
+		etzpc: etzpc@5c007000 {
+			cryp: crypto@54002000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma 28 0x0 0x400202 0x0 0x0>,
+				       <&mdma 29 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp15-ddr.dtsi b/arch/arm/dts/stm32mp15-ddr.dtsi
index 0aac9131a6..d02f79dac6 100644
--- a/arch/arm/dts/stm32mp15-ddr.dtsi
+++ b/arch/arm/dts/stm32mp15-ddr.dtsi
@@ -4,7 +4,22 @@
  */
 #include <linux/stringify.h>
 
+#ifdef CONFIG_SPL
 &ddr {
+	clocks = <&rcc AXIDCG>,
+		 <&rcc DDRC1>,
+		 <&rcc DDRC2>,
+		 <&rcc DDRPHYC>,
+		 <&rcc DDRCAPB>,
+		 <&rcc DDRPHYCAPB>;
+
+	clock-names = "axidcg",
+		      "ddrc1",
+		      "ddrc2",
+		      "ddrphyc",
+		      "ddrcapb",
+		      "ddrphycapb";
+
 	config-DDR_MEM_COMPATIBLE {
 		u-boot,dm-pre-reloc;
 
@@ -119,6 +134,7 @@
 		status = "okay";
 	};
 };
+#endif
 
 #undef DDR_MEM_COMPATIBLE
 #undef DDR_MEM_NAME
diff --git a/arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi b/arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi
new file mode 100644
index 0000000000..49a3ea5db9
--- /dev/null
+++ b/arch/arm/dts/stm32mp15-m4-srm-pinctrl.dtsi
@@ -0,0 +1,524 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	m4_adc1_in6_pins_a: m4-adc1-in6 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 12, RSVD)>;
+		};
+	};
+
+	m4_adc12_ain_pins_a: m4-adc12-ain-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>, /* ADC1 in13 */
+				 <STM32_PINMUX('F', 12, RSVD)>, /* ADC1 in6 */
+				 <STM32_PINMUX('F', 13, RSVD)>, /* ADC2 in2 */
+				 <STM32_PINMUX('F', 14, RSVD)>; /* ADC2 in6 */
+		};
+	};
+
+	m4_adc12_usb_pwr_pins_a: m4-adc12-usb-pwr-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>, /* ADC12 in18 */
+				 <STM32_PINMUX('A', 5, RSVD)>; /* ADC12 in19 */
+		};
+	};
+
+	m4_cec_pins_a: m4-cec-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, RSVD)>;
+		};
+	};
+
+	m4_cec_pins_b: m4-cec-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, RSVD)>;
+		};
+	};
+
+	m4_dac_ch1_pins_a: m4-dac-ch1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, RSVD)>;
+		};
+	};
+
+	m4_dac_ch2_pins_a: m4-dac-ch2 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 5, RSVD)>;
+		};
+	};
+
+	m4_dcmi_pins_a: m4-dcmi-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 8,  RSVD)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('B', 7,  RSVD)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('A', 6,  RSVD)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('H', 9,  RSVD)>,/* DCMI_D0 */
+				 <STM32_PINMUX('H', 10, RSVD)>,/* DCMI_D1 */
+				 <STM32_PINMUX('H', 11, RSVD)>,/* DCMI_D2 */
+				 <STM32_PINMUX('H', 12, RSVD)>,/* DCMI_D3 */
+				 <STM32_PINMUX('H', 14, RSVD)>,/* DCMI_D4 */
+				 <STM32_PINMUX('I', 4,  RSVD)>,/* DCMI_D5 */
+				 <STM32_PINMUX('B', 8,  RSVD)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 6,  RSVD)>,/* DCMI_D7 */
+				 <STM32_PINMUX('I', 1,  RSVD)>,/* DCMI_D8 */
+				 <STM32_PINMUX('H', 7,  RSVD)>,/* DCMI_D9 */
+				 <STM32_PINMUX('I', 3,  RSVD)>,/* DCMI_D10 */
+				 <STM32_PINMUX('H', 15, RSVD)>;/* DCMI_D11 */
+		};
+	};
+
+	m4_dfsdm_clkout_pins_a: m4-dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, RSVD)>; /* DFSDM_CKOUT */
+		};
+	};
+
+	m4_dfsdm_data1_pins_a: m4-dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, RSVD)>; /* DFSDM_DATA1 */
+		};
+	};
+
+	m4_dfsdm_data3_pins_a: m4-dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, RSVD)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	m4_ethernet0_rgmii_pins_a: m4-ethernet0-rgmii-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 5, RSVD)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('G', 4, RSVD)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('G', 13, RSVD)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('G', 14, RSVD)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 2, RSVD)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('E', 2, RSVD)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('B', 11, RSVD)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('C', 1, RSVD)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 2, RSVD)>, /* ETH_MDIO */
+				 <STM32_PINMUX('C', 4, RSVD)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 5, RSVD)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('B', 0, RSVD)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('B', 1, RSVD)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 1, RSVD)>, /* ETH_RGMII_RX_CLK */
+				 <STM32_PINMUX('A', 7, RSVD)>; /* ETH_RGMII_RX_CTL */
+		};
+	};
+
+	m4_fmc_pins_a: m4-fmc-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, RSVD)>, /* FMC_NOE */
+				 <STM32_PINMUX('D', 5, RSVD)>, /* FMC_NWE */
+				 <STM32_PINMUX('D', 11, RSVD)>, /* FMC_A16_FMC_CLE */
+				 <STM32_PINMUX('D', 12, RSVD)>, /* FMC_A17_FMC_ALE */
+				 <STM32_PINMUX('D', 14, RSVD)>, /* FMC_D0 */
+				 <STM32_PINMUX('D', 15, RSVD)>, /* FMC_D1 */
+				 <STM32_PINMUX('D', 0, RSVD)>, /* FMC_D2 */
+				 <STM32_PINMUX('D', 1, RSVD)>, /* FMC_D3 */
+				 <STM32_PINMUX('E', 7, RSVD)>, /* FMC_D4 */
+				 <STM32_PINMUX('E', 8, RSVD)>, /* FMC_D5 */
+				 <STM32_PINMUX('E', 9, RSVD)>, /* FMC_D6 */
+				 <STM32_PINMUX('E', 10, RSVD)>, /* FMC_D7 */
+				 <STM32_PINMUX('G', 9, RSVD)>, /* FMC_NE2_FMC_NCE */
+				 <STM32_PINMUX('D', 6, RSVD)>; /* FMC_NWAIT */
+		};
+	};
+
+	m4_hdp0_pins_a: m4-hdp0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 12, RSVD)>; /* HDP0 */
+		};
+	};
+
+	m4_hdp6_pins_a: m4-hdp6-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 5, RSVD)>; /* HDP6 */
+		};
+	};
+
+	m4_hdp7_pins_a: m4-hdp7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 6, RSVD)>; /* HDP7 */
+		};
+	};
+
+	m4_i2c1_pins_a: m4-i2c1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 12, RSVD)>, /* I2C1_SCL */
+				 <STM32_PINMUX('F', 15, RSVD)>; /* I2C1_SDA */
+		};
+	};
+
+	m4_i2c2_pins_a: m4-i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 4, RSVD)>, /* I2C2_SCL */
+				 <STM32_PINMUX('H', 5, RSVD)>; /* I2C2_SDA */
+		};
+	};
+
+	m4_i2c5_pins_a: m4-i2c5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* I2C5_SCL */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* I2C5_SDA */
+		};
+	};
+
+	m4_i2s2_pins_a: m4-i2s2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 3, RSVD)>, /* I2S2_SDO */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* I2S2_WS */
+				 <STM32_PINMUX('A', 9, RSVD)>; /* I2S2_CK */
+		};
+	};
+
+	m4_ltdc_pins_a: m4-ltdc-a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G',  7, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 10, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I',  9, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('F', 10, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('H',  2, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('H',  3, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('H',  8, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('H',  9, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('H', 10, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('C',  0, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('H', 12, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('E', 15, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('E',  5, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('E',  6, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('H', 13, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('H', 14, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('H', 15, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('I',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('I',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('I',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('D',  9, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('G', 12, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('D', 10, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('I',  4, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('A',  3, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('B',  8, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('D',  8, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_ltdc_pins_b: m4-ltdc-b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 14, RSVD)>, /* LCD_CLK */
+				 <STM32_PINMUX('I', 12, RSVD)>, /* LCD_HSYNC */
+				 <STM32_PINMUX('I', 13, RSVD)>, /* LCD_VSYNC */
+				 <STM32_PINMUX('K',  7, RSVD)>, /* LCD_DE */
+				 <STM32_PINMUX('I', 15, RSVD)>, /* LCD_R0 */
+				 <STM32_PINMUX('J',  0, RSVD)>, /* LCD_R1 */
+				 <STM32_PINMUX('J',  1, RSVD)>, /* LCD_R2 */
+				 <STM32_PINMUX('J',  2, RSVD)>, /* LCD_R3 */
+				 <STM32_PINMUX('J',  3, RSVD)>, /* LCD_R4 */
+				 <STM32_PINMUX('J',  4, RSVD)>, /* LCD_R5 */
+				 <STM32_PINMUX('J',  5, RSVD)>, /* LCD_R6 */
+				 <STM32_PINMUX('J',  6, RSVD)>, /* LCD_R7 */
+				 <STM32_PINMUX('J',  7, RSVD)>, /* LCD_G0 */
+				 <STM32_PINMUX('J',  8, RSVD)>, /* LCD_G1 */
+				 <STM32_PINMUX('J',  9, RSVD)>, /* LCD_G2 */
+				 <STM32_PINMUX('J', 10, RSVD)>, /* LCD_G3 */
+				 <STM32_PINMUX('J', 11, RSVD)>, /* LCD_G4 */
+				 <STM32_PINMUX('K',  0, RSVD)>, /* LCD_G5 */
+				 <STM32_PINMUX('K',  1, RSVD)>, /* LCD_G6 */
+				 <STM32_PINMUX('K',  2, RSVD)>, /* LCD_G7 */
+				 <STM32_PINMUX('J', 12, RSVD)>, /* LCD_B0 */
+				 <STM32_PINMUX('J', 13, RSVD)>, /* LCD_B1 */
+				 <STM32_PINMUX('J', 14, RSVD)>, /* LCD_B2 */
+				 <STM32_PINMUX('J', 15, RSVD)>, /* LCD_B3 */
+				 <STM32_PINMUX('K',  3, RSVD)>, /* LCD_B4 */
+				 <STM32_PINMUX('K',  4, RSVD)>, /* LCD_B5 */
+				 <STM32_PINMUX('K',  5, RSVD)>, /* LCD_B6 */
+				 <STM32_PINMUX('K',  6, RSVD)>; /* LCD_B7 */
+		};
+	};
+
+	m4_m_can1_pins_a: m4-m-can1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 13, RSVD)>, /* CAN1_TX */
+				 <STM32_PINMUX('I', 9, RSVD)>; /* CAN1_RX */
+		};
+	};
+
+	m4_pwm1_pins_a: m4-pwm1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 9, RSVD)>, /* TIM1_CH1 */
+				 <STM32_PINMUX('E', 11, RSVD)>, /* TIM1_CH2 */
+				 <STM32_PINMUX('E', 14, RSVD)>; /* TIM1_CH4 */
+		};
+	};
+
+	m4_pwm2_pins_a: m4-pwm2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 3, RSVD)>; /* TIM2_CH4 */
+		};
+	};
+
+	m4_pwm3_pins_a: m4-pwm3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, RSVD)>; /* TIM3_CH2 */
+		};
+	};
+
+	m4_pwm4_pins_a: m4-pwm4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 14, RSVD)>, /* TIM4_CH3 */
+				 <STM32_PINMUX('D', 15, RSVD)>; /* TIM4_CH4 */
+		};
+	};
+
+	m4_pwm4_pins_b: m4-pwm4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 13, RSVD)>; /* TIM4_CH2 */
+		};
+	};
+
+	m4_pwm5_pins_a: m4-pwm5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, RSVD)>; /* TIM5_CH2 */
+		};
+	};
+
+	m4_pwm8_pins_a: m4-pwm8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 2, RSVD)>; /* TIM8_CH4 */
+		};
+	};
+
+	m4_pwm12_pins_a: m4-pwm12-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 6, RSVD)>; /* TIM12_CH1 */
+		};
+	};
+
+	m4_qspi_bk1_pins_a: m4-qspi-bk1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 8, RSVD)>, /* QSPI_BK1_IO0 */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* QSPI_BK1_IO1 */
+				 <STM32_PINMUX('F', 7, RSVD)>, /* QSPI_BK1_IO2 */
+				 <STM32_PINMUX('F', 6, RSVD)>, /* QSPI_BK1_IO3 */
+				 <STM32_PINMUX('B', 6, RSVD)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	m4_qspi_bk2_pins_a: m4-qspi-bk2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, RSVD)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, RSVD)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, RSVD)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, RSVD)>, /* QSPI_BK2_IO3 */
+				 <STM32_PINMUX('C', 0, RSVD)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	m4_qspi_clk_pins_a: m4-qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, RSVD)>; /* QSPI_CLK */
+		};
+	};
+
+	m4_rtc_out2_rmp_pins_a: m4-rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, RSVD)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	m4_sai2a_pins_a: m4-sai2a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 5, RSVD)>, /* SAI2_SCK_A */
+				 <STM32_PINMUX('I', 6, RSVD)>, /* SAI2_SD_A */
+				 <STM32_PINMUX('I', 7, RSVD)>, /* SAI2_FS_A */
+				 <STM32_PINMUX('E', 0, RSVD)>; /* SAI2_MCLK_A */
+		};
+	};
+
+	m4_sai2b_pins_a: m4-sai2b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SAI2_SCK_B */
+				 <STM32_PINMUX('E', 13, RSVD)>, /* SAI2_FS_B */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SAI2_MCLK_B */
+				 <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai2b_pins_b: m4-sai2b-2 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 11, RSVD)>; /* SAI2_SD_B */
+		};
+	};
+
+	m4_sai4a_pins_a: m4-sai4a-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, RSVD)>; /* SAI4_SD_A */
+		};
+	};
+
+	m4_sdmmc1_b4_pins_a: m4-sdmmc1-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 8, RSVD)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, RSVD)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, RSVD)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, RSVD)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D', 2, RSVD)>, /* SDMMC1_CMD */
+				 <STM32_PINMUX('C', 12, RSVD)>; /* SDMMC1_CK */
+		};
+	};
+
+	m4_sdmmc1_dir_pins_a: m4-sdmmc1-dir-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, RSVD)>, /* SDMMC1_D0DIR */
+				 <STM32_PINMUX('C', 7, RSVD)>, /* SDMMC1_D123DIR */
+				 <STM32_PINMUX('B', 9, RSVD)>, /* SDMMC1_CDIR */
+				 <STM32_PINMUX('E', 4, RSVD)>; /* SDMMC1_CKIN */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_a: m4-sdmmc2-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_b4_pins_b: m4-sdmmc2-b4-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, RSVD)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, RSVD)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('B', 3, RSVD)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('B', 4, RSVD)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('G', 6, RSVD)>, /* SDMMC2_CMD */
+				 <STM32_PINMUX('E', 3, RSVD)>; /* SDMMC2_CK */
+		};
+	};
+
+	m4_sdmmc2_d47_pins_a: m4-sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 8, RSVD)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('A', 9, RSVD)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 5, RSVD)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* SDMMC2_D7 */
+		};
+	};
+
+	m4_sdmmc3_b4_pins_a: m4-sdmmc3-b4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 0, RSVD)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('F', 4, RSVD)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('F', 5, RSVD)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('D', 7, RSVD)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('F', 1, RSVD)>, /* SDMMC3_CMD */
+				 <STM32_PINMUX('G', 15, RSVD)>; /* SDMMC3_CK */
+		};
+	};
+
+	m4_spdifrx_pins_a: m4-spdifrx-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 12, RSVD)>; /* SPDIF_IN1 */
+		};
+	};
+
+	m4_spi4_pins_a: m4-spi4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, RSVD)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, RSVD)>, /* SPI4_MOSI */
+				 <STM32_PINMUX('E', 13, RSVD)>; /* SPI4_MISO */
+		};
+	};
+
+	m4_spi5_pins_a: m4-spi5-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, RSVD)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, RSVD)>, /* SPI5_MOSI */
+				 <STM32_PINMUX('F', 8, RSVD)>; /* SPI5_MISO */
+		};
+	};
+
+	m4_stusb1600_pins_a: m4-stusb1600-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 11, RSVD)>;
+		};
+	};
+
+	m4_uart4_pins_a: m4-uart4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, RSVD)>, /* UART4_TX */
+				 <STM32_PINMUX('B', 2, RSVD)>; /* UART4_RX */
+		};
+	};
+
+	m4_uart7_pins_a: m4-uart7-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 8, RSVD)>, /* USART7_TX */
+				 <STM32_PINMUX('E', 7, RSVD)>; /* USART7_RX */
+		};
+	};
+
+	m4_usart2_pins_a: m4-usart2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 5, RSVD)>, /* USART2_TX */
+				 <STM32_PINMUX('D', 4, RSVD)>, /* USART2_RTS */
+				 <STM32_PINMUX('D', 6, RSVD)>, /* USART2_RX */
+				 <STM32_PINMUX('D', 3, RSVD)>; /* USART2_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_a: m4-usart3-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('I', 10, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usart3_pins_b: m4-usart3-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 10, RSVD)>, /* USART3_TX */
+				 <STM32_PINMUX('G', 8, RSVD)>, /* USART3_RTS */
+				 <STM32_PINMUX('B', 12, RSVD)>, /* USART3_RX */
+				 <STM32_PINMUX('B', 13, RSVD)>; /* USART3_CTS_NSS */
+		};
+	};
+
+	m4_usbotg_fs_dp_dm_pins_a: m4-usbotg-fs-dp-dm-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 11, RSVD)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, RSVD)>; /* OTG_FS_DP */
+		};
+	};
+
+	m4_usbotg_hs_pins_a: m4-usbotg-hs-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 10, RSVD)>; /* OTG_ID */
+		};
+	};
+};
+
+&pinctrl_z {
+	m4_i2c4_pins_a: m4-i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, RSVD)>, /* I2C4_SCL */
+				 <STM32_PINMUX('Z', 5, RSVD)>; /* I2C4_SDA */
+		};
+	};
+
+	m4_spi1_pins_a: m4-spi1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, RSVD)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 2, RSVD)>, /* SPI1_MOSI */
+				 <STM32_PINMUX('Z', 1, RSVD)>; /* SPI1_MISO */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15-m4-srm.dtsi b/arch/arm/dts/stm32mp15-m4-srm.dtsi
new file mode 100644
index 0000000000..7fa3ca411a
--- /dev/null
+++ b/arch/arm/dts/stm32mp15-m4-srm.dtsi
@@ -0,0 +1,447 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Fabien Dessenne <fabien.dessenne@st.com> for STMicroelectronics.
+ */
+
+&m4_rproc {
+	m4_system_resources {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		m4_timers2: timer@40000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40000000 0x400>;
+			clocks = <&rcc TIM2_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers3: timer@40001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40001000 0x400>;
+			clocks = <&rcc TIM3_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers4: timer@40002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40002000 0x400>;
+			clocks = <&rcc TIM4_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers5: timer@40003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40003000 0x400>;
+			clocks = <&rcc TIM5_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers6: timer@40004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40004000 0x400>;
+			clocks = <&rcc TIM6_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers7: timer@40005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40005000 0x400>;
+			clocks = <&rcc TIM7_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers12: timer@40006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40006000 0x400>;
+			clocks = <&rcc TIM12_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers13: timer@40007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40007000 0x400>;
+			clocks = <&rcc TIM13_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers14: timer@40008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40008000 0x400>;
+			clocks = <&rcc TIM14_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_lptimer1: timer@40009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40009000 0x400>;
+			clocks = <&rcc LPTIM1_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_spi2: spi@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			clocks = <&rcc SPI2_K>;
+			status = "disabled";
+		};
+		m4_i2s2: audio-controller@4000b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000b000 0x400>;
+			status = "disabled";
+		};
+		m4_spi3: spi@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			clocks = <&rcc SPI3_K>;
+			status = "disabled";
+		};
+		m4_i2s3: audio-controller@4000c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000c000 0x400>;
+			status = "disabled";
+		};
+		m4_spdifrx: audio-controller@4000d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000d000 0x400>;
+			clocks = <&rcc SPDIF_K>;
+			clock-names = "kclk";
+			status = "disabled";
+		};
+		m4_usart2: serial@4000e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000e000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <27 1>;
+			clocks = <&rcc USART2_K>;
+			status = "disabled";
+		};
+		m4_usart3: serial@4000f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4000f000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <28 1>;
+			clocks = <&rcc USART3_K>;
+			status = "disabled";
+		};
+		m4_uart4: serial@40010000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40010000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <30 1>;
+			clocks = <&rcc UART4_K>;
+			status = "disabled";
+		};
+		m4_uart5: serial@40011000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40011000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <31 1>;
+			clocks = <&rcc UART5_K>;
+			status = "disabled";
+		};
+		m4_i2c1: i2c@40012000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40012000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <21 1>;
+			clocks = <&rcc I2C1_K>;
+			status = "disabled";
+		};
+		m4_i2c2: i2c@40013000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40013000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <22 1>;
+			clocks = <&rcc I2C2_K>;
+			status = "disabled";
+		};
+		m4_i2c3: i2c@40014000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40014000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <23 1>;
+			clocks = <&rcc I2C3_K>;
+			status = "disabled";
+		};
+		m4_i2c5: i2c@40015000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40015000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <25 1>;
+			clocks = <&rcc I2C5_K>;
+			status = "disabled";
+		};
+		m4_cec: cec@40016000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40016000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <69 1>;
+			clocks = <&rcc CEC_K>, <&rcc CEC>;
+			clock-names = "cec", "hdmi-cec";
+			status = "disabled";
+		};
+		m4_dac: dac@40017000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40017000 0x400>;
+			clocks = <&rcc DAC12>;
+			clock-names = "pclk";
+			status = "disabled";
+		};
+		m4_uart7: serial@40018000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40018000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <32 1>;
+			clocks = <&rcc UART7_K>;
+			status = "disabled";
+		};
+		m4_uart8: serial@40019000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x40019000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <33 1>;
+			clocks = <&rcc UART8_K>;
+			status = "disabled";
+		};
+		m4_timers1: timer@44000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44000000 0x400>;
+			clocks = <&rcc TIM1_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers8: timer@44001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44001000 0x400>;
+			clocks = <&rcc TIM8_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_usart6: serial@44003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44003000 0x400>;
+			interrupt-parent = <&exti>;
+			interrupts = <29 1>;
+			clocks = <&rcc USART6_K>;
+			status = "disabled";
+		};
+		m4_spi1: spi@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			clocks = <&rcc SPI1_K>;
+			status = "disabled";
+		};
+		m4_i2s1: audio-controller@44004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44004000 0x400>;
+			status = "disabled";
+		};
+		m4_spi4: spi@44005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44005000 0x400>;
+			clocks = <&rcc SPI4_K>;
+			status = "disabled";
+		};
+		m4_timers15: timer@44006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44006000 0x400>;
+			clocks = <&rcc TIM15_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers16: timer@44007000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44007000 0x400>;
+			clocks = <&rcc TIM16_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_timers17: timer@44008000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44008000 0x400>;
+			clocks = <&rcc TIM17_K>;
+			clock-names = "int";
+			status = "disabled";
+		};
+		m4_spi5: spi@44009000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x44009000 0x400>;
+			clocks = <&rcc SPI5_K>;
+			status = "disabled";
+		};
+		m4_sai1: sai@4400a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400a000 0x4>;
+			clocks = <&rcc SAI1_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai2: sai@4400b000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400b000 0x4>;
+			clocks = <&rcc SAI2_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_sai3: sai@4400c000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400c000 0x4>;
+			clocks = <&rcc SAI3_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+		};
+		m4_dfsdm: dfsdm@4400d000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400d000 0x800>;
+			clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+			clock-names = "dfsdm", "audio";
+			status = "disabled";
+		};
+		m4_m_can1: can@4400e000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400e000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_m_can2: can@4400f000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+			clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+			clock-names = "hclk", "cclk";
+			status = "disabled";
+		};
+		m4_dma1: dma@48000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48000000 0x400>;
+			clocks = <&rcc DMA1>;
+			status = "disabled";
+		};
+		m4_dma2: dma@48001000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48001000 0x400>;
+			clocks = <&rcc DMA2>;
+			status = "disabled";
+		};
+		m4_dmamux1: dma-router@48002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48002000 0x1c>;
+			clocks = <&rcc DMAMUX>;
+			status = "disabled";
+		};
+		m4_adc: adc@48003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48003000 0x400>;
+			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+			clock-names = "bus", "adc";
+			status = "disabled";
+		};
+		m4_sdmmc3: sdmmc@48004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x48004000 0x400>, <0x48005000 0x400>;
+			clocks = <&rcc SDMMC3_K>;
+			status = "disabled";
+		};
+		m4_usbotg_hs: usb-otg@49000000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x49000000 0x10000>;
+			clocks = <&rcc USBO_K>;
+			clock-names = "otg";
+			status = "disabled";
+		};
+		m4_hash2: hash@4c002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c002000 0x400>;
+			clocks = <&rcc HASH2>;
+			status = "disabled";
+		};
+		m4_rng2: rng@4c003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c003000 0x400>;
+			clocks = <&rcc RNG2_K>;
+			status = "disabled";
+		};
+		m4_crc2: crc@4c004000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c004000 0x400>;
+			clocks = <&rcc CRC2>;
+			status = "disabled";
+		};
+		m4_cryp2: cryp@4c005000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c005000 0x400>;
+			clocks = <&rcc CRYP2>;
+			status = "disabled";
+		};
+		m4_dcmi: dcmi@4c006000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x4c006000 0x400>;
+			clocks = <&rcc DCMI>;
+			clock-names = "mclk";
+			status = "disabled";
+		};
+		m4_lptimer2: timer@50021000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50021000 0x400>;
+			clocks = <&rcc LPTIM2_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer3: timer@50022000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50022000 0x400>;
+			clocks = <&rcc LPTIM3_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer4: timer@50023000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50023000 0x400>;
+			clocks = <&rcc LPTIM4_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_lptimer5: timer@50024000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50024000 0x400>;
+			clocks = <&rcc LPTIM5_K>;
+			clock-names = "mux";
+			status = "disabled";
+		};
+		m4_sai4: sai@50027000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x50027000 0x4>;
+			clocks = <&rcc SAI4_K>;
+			clock-names = "sai_ck";
+			status = "disabled";
+			};
+		m4_fmc: memory-controller@58002000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800200 0x1000>;
+			clocks = <&rcc FMC_K>;
+			status = "disabled";
+		};
+		m4_qspi: qspi@58003000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+			clocks = <&rcc QSPI_K>;
+			status = "disabled";
+		};
+		m4_ethernet0: ethernet@5800a000 {
+			compatible = "rproc-srm-dev";
+			reg = <0x5800a000 0x2000>;
+			clock-names = "stmmaceth",
+				      "mac-clk-tx",
+				      "mac-clk-rx",
+				      "ethstp",
+				      "syscfg-clk";
+			clocks = <&rcc ETHMAC>,
+				 <&rcc ETHTX>,
+				 <&rcc ETHRX>,
+				 <&rcc ETHSTP>,
+				 <&rcc SYSCFG>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15-pinctrl.dtsi b/arch/arm/dts/stm32mp15-pinctrl.dtsi
index d3ed10335d..20b4f0d82b 100644
--- a/arch/arm/dts/stm32mp15-pinctrl.dtsi
+++ b/arch/arm/dts/stm32mp15-pinctrl.dtsi
@@ -4,6 +4,14 @@
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
+#include <dt-bindings/pinctrl/stm32mp15-hdp.h>
+
+&hdp {
+	hdp2_gpo: hdp2-pins {
+		pins = "hdp2";
+		function = HDP2_GPOVAL_2;
+	};
+};
 
 &pinctrl {
 	adc1_in6_pins_a: adc1-in6-0 {
@@ -151,7 +159,78 @@
 		};
 	};
 
-	ethernet0_rgmii_pins_a: rgmii-0 {
+	dcmi_pins_c: dcmi-2 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4,  AF13)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('B', 7,  AF13)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('A', 6,  AF13)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A', 9,  AF13)>,/* DCMI_D0 */
+				 <STM32_PINMUX('H', 10, AF13)>,/* DCMI_D1 */
+				 <STM32_PINMUX('E', 0, AF13)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E', 1, AF13)>,/* DCMI_D3 */
+				 <STM32_PINMUX('H', 14, AF13)>,/* DCMI_D4 */
+				 <STM32_PINMUX('I', 4,  AF13)>,/* DCMI_D5 */
+				 <STM32_PINMUX('I', 6,  AF13)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 6,  AF13)>,/* DCMI_D7 */
+				 <STM32_PINMUX('I', 1,  AF13)>,/* DCMI_D8 */
+				 <STM32_PINMUX('H', 7,  AF13)>;/* DCMI_D9 */
+			bias-pull-up;
+		};
+	};
+
+	dcmi_sleep_pins_c: dcmi-sleep-2 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4,  ANALOG)>,/* DCMI_HSYNC */
+				 <STM32_PINMUX('B', 7,  ANALOG)>,/* DCMI_VSYNC */
+				 <STM32_PINMUX('A', 6,  ANALOG)>,/* DCMI_PIXCLK */
+				 <STM32_PINMUX('A', 9,  ANALOG)>,/* DCMI_D0 */
+				 <STM32_PINMUX('H', 10, ANALOG)>,/* DCMI_D1 */
+				 <STM32_PINMUX('E', 0, ANALOG)>,/* DCMI_D2 */
+				 <STM32_PINMUX('E', 1, ANALOG)>,/* DCMI_D3 */
+				 <STM32_PINMUX('H', 14, ANALOG)>,/* DCMI_D4 */
+				 <STM32_PINMUX('I', 4,  ANALOG)>,/* DCMI_D5 */
+				 <STM32_PINMUX('I', 6,  ANALOG)>,/* DCMI_D6 */
+				 <STM32_PINMUX('E', 6,  ANALOG)>,/* DCMI_D7 */
+				 <STM32_PINMUX('I', 1,  ANALOG)>,/* DCMI_D8 */
+				 <STM32_PINMUX('H', 7,  ANALOG)>;/* DCMI_D9 */
+		};
+	};
+
+	dfsdm_clkout_pins_a: dfsdm-clkout-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, AF3)>; /* DFSDM_CKOUT */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+	dfsdm_clkout_sleep_pins_a: dfsdm-clkout-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 13, ANALOG)>; /* DFSDM_CKOUT */
+		};
+	};
+	dfsdm_data1_pins_a: dfsdm-data1-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, AF3)>; /* DFSDM_DATA1 */
+		};
+	};
+	dfsdm_data1_sleep_pins_a: dfsdm-data1-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 3, ANALOG)>; /* DFSDM_DATA1 */
+		};
+	};
+	dfsdm_data3_pins_a: dfsdm-data3-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, AF6)>; /* DFSDM_DATA3 */
+		};
+	};
+	dfsdm_data3_sleep_pins_a: dfsdm-data3-sleep-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>; /* DFSDM_DATA3 */
+		};
+	};
+
+	ethernet0_rgmii_pins_a: ethernet0-rgmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -182,7 +261,7 @@
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_a: rgmii-sleep-0 {
+	ethernet0_rgmii_sleep_pins_a: ethernet0-rgmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -202,7 +281,7 @@
 		};
 	};
 
-	ethernet0_rgmii_pins_b: rgmii-1 {
+	ethernet0_rgmii_pins_b: ethernet0-rgmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -233,7 +312,7 @@
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_b: rgmii-sleep-1 {
+	ethernet0_rgmii_sleep_pins_b: ethernet0-rgmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -253,7 +332,7 @@
 		 };
 	};
 
-	ethernet0_rgmii_pins_c: rgmii-2 {
+	ethernet0_rgmii_pins_c: ethernet0-rgmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, AF11)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, AF11)>, /* ETH_RGMII_GTX_CLK */
@@ -284,7 +363,7 @@
 		};
 	};
 
-	ethernet0_rgmii_sleep_pins_c: rgmii-sleep-2 {
+	ethernet0_rgmii_sleep_pins_c: ethernet0-rgmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 5, ANALOG)>, /* ETH_RGMII_CLK125 */
 				 <STM32_PINMUX('G', 4, ANALOG)>, /* ETH_RGMII_GTX_CLK */
@@ -304,7 +383,7 @@
 		};
 	};
 
-	ethernet0_rmii_pins_a: rmii-0 {
+	ethernet0_rmii_pins_a: ethernet0-rmii-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -324,7 +403,7 @@
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_a: rmii-sleep-0 {
+	ethernet0_rmii_sleep_pins_a: ethernet0-rmii-sleep-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -338,7 +417,7 @@
 		};
 	};
 
-	ethernet0_rmii_pins_b: rmii-1 {
+	ethernet0_rmii_pins_b: ethernet0-rmii-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('B', 5, AF0)>, /* ETH1_CLK */
 				<STM32_PINMUX('C', 1, AF11)>, /* ETH1_MDC */
@@ -365,7 +444,7 @@
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_b: rmii-sleep-1 {
+	ethernet0_rmii_sleep_pins_b: ethernet0-rmii-sleep-1 {
 		pins1 {
 			pinmux = <STM32_PINMUX('A', 2, ANALOG)>, /* ETH1_MDIO */
 				<STM32_PINMUX('A', 7, ANALOG)>, /* ETH1_CRS_DV */
@@ -379,7 +458,7 @@
 		};
 	};
 
-	ethernet0_rmii_pins_c: rmii-2 {
+	ethernet0_rmii_pins_c: ethernet0-rmii-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
@@ -399,7 +478,7 @@
 		};
 	};
 
-	ethernet0_rmii_sleep_pins_c: rmii-sleep-2 {
+	ethernet0_rmii_sleep_pins_c: ethernet0-rmii-sleep-2 {
 		pins1 {
 			pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
 				 <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
@@ -512,6 +591,21 @@
 		};
 	};
 
+	hdp2_pins_a: hdp2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, AF0)>; /* HDP2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	hdp2_sleep_pins_a: hdp2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>; /* HDP2 */
+		};
+	};
+
 	i2c1_pins_a: i2c1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('D', 12, AF5)>, /* I2C1_SCL */
@@ -923,21 +1017,6 @@
 		};
 	};
 
-	mco2_pins_a: mco2-0 {
-		pins {
-			pinmux = <STM32_PINMUX('G', 2, AF1)>; /* MCO2 */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <2>;
-		};
-	};
-
-	mco2_sleep_pins_a: mco2-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('G', 2, ANALOG)>; /* MCO2 */
-		};
-	};
-
 	m_can1_pins_a: m-can1-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('H', 13, AF9)>; /* CAN1_TX */
@@ -951,7 +1030,7 @@
 		};
 	};
 
-	m_can1_sleep_pins_a: m_can1-sleep-0 {
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('I', 9, ANALOG)>; /* CAN1_RX */
@@ -971,7 +1050,7 @@
 		};
 	};
 
-	m_can1_sleep_pins_b: m_can1-sleep-1 {
+	m_can1_sleep_pins_b: m-can1-sleep-1 {
 		pins {
 			pinmux = <STM32_PINMUX('A', 12, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('A', 11, ANALOG)>; /* CAN1_RX */
@@ -991,7 +1070,7 @@
 		};
 	};
 
-	m_can1_sleep_pins_c: m_can1-sleep-2 {
+	m_can1_sleep_pins_c: m-can1-sleep-2 {
 		pins {
 			pinmux = <STM32_PINMUX('H', 13, ANALOG)>, /* CAN1_TX */
 				 <STM32_PINMUX('H', 14, ANALOG)>; /* CAN1_RX */
@@ -1011,13 +1090,43 @@
 		};
 	};
 
-	m_can2_sleep_pins_a: m_can2-sleep-0 {
+	m_can2_sleep_pins_a: m-can2-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('B', 13, ANALOG)>, /* CAN2_TX */
 				 <STM32_PINMUX('B', 5, ANALOG)>; /* CAN2_RX */
 		};
 	};
 
+	mco1_pins_a: mco1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, AF2)>; /* MCO1 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	mco1_sleep_pins_a: mco1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 13, ANALOG)>; /* MCO1 */
+		};
+	};
+
+	mco2_pins_a: mco2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 2, AF1)>; /* MCO2 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	mco2_sleep_pins_a: mco2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 2, ANALOG)>; /* MCO2 */
+		};
+	};
+
 	pwm1_pins_a: pwm1-0 {
 		pins {
 			pinmux = <STM32_PINMUX('E', 9, AF1)>, /* TIM1_CH1 */
@@ -1193,23 +1302,8 @@
 		};
 	};
 
-	qspi_clk_pins_a: qspi-clk-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
-			bias-disable;
-			drive-push-pull;
-			slew-rate = <3>;
-		};
-	};
-
-	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
-		pins {
-			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
-		};
-	};
-
 	qspi_bk1_pins_a: qspi-bk1-0 {
-		pins1 {
+		pins {
 			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* QSPI_BK1_IO0 */
 				 <STM32_PINMUX('F', 9, AF10)>, /* QSPI_BK1_IO1 */
 				 <STM32_PINMUX('F', 7, AF9)>, /* QSPI_BK1_IO2 */
@@ -1218,12 +1312,6 @@
 			drive-push-pull;
 			slew-rate = <1>;
 		};
-		pins2 {
-			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
-			bias-pull-up;
-			drive-push-pull;
-			slew-rate = <1>;
-		};
 	};
 
 	qspi_bk1_sleep_pins_a: qspi-bk1-sleep-0 {
@@ -1231,13 +1319,12 @@
 			pinmux = <STM32_PINMUX('F', 8, ANALOG)>, /* QSPI_BK1_IO0 */
 				 <STM32_PINMUX('F', 9, ANALOG)>, /* QSPI_BK1_IO1 */
 				 <STM32_PINMUX('F', 7, ANALOG)>, /* QSPI_BK1_IO2 */
-				 <STM32_PINMUX('F', 6, ANALOG)>, /* QSPI_BK1_IO3 */
-				 <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+				 <STM32_PINMUX('F', 6, ANALOG)>; /* QSPI_BK1_IO3 */
 		};
 	};
 
 	qspi_bk2_pins_a: qspi-bk2-0 {
-		pins1 {
+		pins {
 			pinmux = <STM32_PINMUX('H', 2, AF9)>, /* QSPI_BK2_IO0 */
 				 <STM32_PINMUX('H', 3, AF9)>, /* QSPI_BK2_IO1 */
 				 <STM32_PINMUX('G', 10, AF11)>, /* QSPI_BK2_IO2 */
@@ -1246,7 +1333,49 @@
 			drive-push-pull;
 			slew-rate = <1>;
 		};
-		pins2 {
+	};
+
+	qspi_bk2_sleep_pins_a: qspi-bk2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* QSPI_BK2_IO0 */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* QSPI_BK2_IO1 */
+				 <STM32_PINMUX('G', 10, ANALOG)>, /* QSPI_BK2_IO2 */
+				 <STM32_PINMUX('G', 7, ANALOG)>; /* QSPI_BK2_IO3 */
+		};
+	};
+
+	qspi_clk_pins_a: qspi-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, AF9)>; /* QSPI_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+	};
+
+	qspi_clk_sleep_pins_a: qspi-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 10, ANALOG)>; /* QSPI_CLK */
+		};
+	};
+
+	qspi_cs1_pins_a: qspi-cs1-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, AF10)>; /* QSPI_BK1_NCS */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+	};
+
+	qspi_cs1_sleep_pins_a: qspi-cs1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 6, ANALOG)>; /* QSPI_BK1_NCS */
+		};
+	};
+
+	qspi_cs2_pins_a: qspi-cs2-0 {
+		pins {
 			pinmux = <STM32_PINMUX('C', 0, AF10)>; /* QSPI_BK2_NCS */
 			bias-pull-up;
 			drive-push-pull;
@@ -1254,13 +1383,15 @@
 		};
 	};
 
-	qspi_bk2_sleep_pins_a: qspi-bk2-sleep-0 {
+	qspi_cs2_sleep_pins_a: qspi-cs2-sleep-0 {
 		pins {
-			pinmux = <STM32_PINMUX('H', 2, ANALOG)>, /* QSPI_BK2_IO0 */
-				 <STM32_PINMUX('H', 3, ANALOG)>, /* QSPI_BK2_IO1 */
-				 <STM32_PINMUX('G', 10, ANALOG)>, /* QSPI_BK2_IO2 */
-				 <STM32_PINMUX('G', 7, ANALOG)>, /* QSPI_BK2_IO3 */
-				 <STM32_PINMUX('C', 0, ANALOG)>; /* QSPI_BK2_NCS */
+			pinmux = <STM32_PINMUX('C', 0, ANALOG)>; /* QSPI_BK2_NCS */
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
 		};
 	};
 
@@ -1407,6 +1538,18 @@
 		};
 	};
 
+	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
 	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
 		pins1 {
 			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
@@ -1431,18 +1574,6 @@
 		};
 	};
 
-	sdmmc1_b4_init_pins_a: sdmmc1-b4-init-0 {
-		pins1 {
-			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
-				 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
-				 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
-				 <STM32_PINMUX('C', 11, AF12)>; /* SDMMC1_D3 */
-			slew-rate = <1>;
-			drive-push-pull;
-			bias-disable;
-		};
-	};
-
 	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
 		pins {
 			pinmux = <STM32_PINMUX('C', 8, ANALOG)>, /* SDMMC1_D0 */
@@ -1812,32 +1943,47 @@
 		};
 	};
 
+	spi1_pins_b: spi1-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 5, AF5)>, /* SPI1_SCK */
+				 <STM32_PINMUX('B', 5, AF5)>; /* SPI1_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 6, AF5)>; /* SPI1_MISO */
+			bias-disable;
+		};
+	};
+
 	spi2_pins_a: spi2-0 {
 		pins1 {
-			pinmux = <STM32_PINMUX('B', 10, AF5)>, /* SPI1_SCK */
-				 <STM32_PINMUX('I', 3, AF5)>; /* SPI1_MOSI */
+			pinmux = <STM32_PINMUX('B', 10, AF5)>, /* SPI2_SCK */
+				 <STM32_PINMUX('I', 3, AF5)>; /* SPI2_MOSI */
 			bias-disable;
 			drive-push-pull;
 			slew-rate = <1>;
 		};
 
 		pins2 {
-			pinmux = <STM32_PINMUX('I', 2, AF5)>; /* SPI1_MISO */
+			pinmux = <STM32_PINMUX('I', 2, AF5)>; /* SPI2_MISO */
 			bias-disable;
 		};
 	};
 
 	spi2_pins_b: spi2-1 {
 		pins1 {
-			pinmux = <STM32_PINMUX('I', 1, AF5)>, /* SPI1_SCK */
-				 <STM32_PINMUX('I', 3, AF5)>; /* SPI1_MOSI */
+			pinmux = <STM32_PINMUX('I', 1, AF5)>, /* SPI2_SCK */
+				 <STM32_PINMUX('I', 3, AF5)>; /* SPI2_MOSI */
 			bias-disable;
 			drive-push-pull;
 			slew-rate = <1>;
 		};
 
 		pins2 {
-			pinmux = <STM32_PINMUX('I', 2, AF5)>; /* SPI1_MISO */
+			pinmux = <STM32_PINMUX('I', 2, AF5)>; /* SPI2_MISO */
 			bias-disable;
 		};
 	};
@@ -1856,6 +2002,52 @@
 		};
 	};
 
+	spi4_pins_b: spi4-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 12, AF5)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 14, AF5)>; /* SPI4_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 13, AF5)>; /* SPI4_MISO */
+			bias-disable;
+		};
+	};
+
+	spi4_sleep_pins_b: spi4-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 12, ANALOG)>, /* SPI4_SCK */
+				 <STM32_PINMUX('E', 13, ANALOG)>, /* SPI4_MISO */
+				 <STM32_PINMUX('E', 14, ANALOG)>; /* SPI4_MOSI */
+		};
+	};
+
+	spi5_pins_a: spi5-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF5)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 9, AF5)>; /* SPI5_MOSI */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF5)>; /* SPI5_MISO */
+			bias-disable;
+		};
+	};
+
+	spi5_sleep_pins_a: spi5-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI5_SCK */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* SPI5_MISO */
+				 <STM32_PINMUX('F', 9, ANALOG)>; /* SPI5_MOSI */
+		};
+	};
+
 	stusb1600_pins_a: stusb1600-0 {
 		pins {
 			pinmux = <STM32_PINMUX('I', 11, GPIO)>;
@@ -2095,7 +2287,7 @@
 				 <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
 			bias-disable;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 		pins2 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>, /* USART2_RX */
@@ -2113,7 +2305,7 @@
 			pinmux = <STM32_PINMUX('D', 4, AF7)>; /* USART2_RTS */
 			bias-disable;
 			drive-push-pull;
-			slew-rate = <3>;
+			slew-rate = <0>;
 		};
 		pins3 {
 			pinmux = <STM32_PINMUX('D', 6, AF7)>; /* USART2_RX */
@@ -2302,16 +2494,16 @@
 		};
 	};
 
-	usbotg_hs_pins_a: usbotg-hs-0 {
+	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
+			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
+				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
 		};
 	};
 
-	usbotg_fs_dp_dm_pins_a: usbotg-fs-dp-dm-0 {
+	usbotg_hs_pins_a: usbotg-hs-0 {
 		pins {
-			pinmux = <STM32_PINMUX('A', 11, ANALOG)>, /* OTG_FS_DM */
-				 <STM32_PINMUX('A', 12, ANALOG)>; /* OTG_FS_DP */
+			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* OTG_ID */
 		};
 	};
 };
@@ -2381,18 +2573,38 @@
 		};
 	};
 
-	spi1_pins_b: spi1-1 {
+	spi1_sleep_pins_a: spi1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI1_SCK */
+				 <STM32_PINMUX('Z', 1, ANALOG)>, /* SPI1_MISO */
+				 <STM32_PINMUX('Z', 2, ANALOG)>; /* SPI1_MOSI */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
 		pins1 {
-			pinmux = <STM32_PINMUX('A', 5, AF5)>, /* SPI1_SCK */
-				 <STM32_PINMUX('B', 5, AF5)>; /* SPI1_MOSI */
-			bias-disable;
+			pinmux = <STM32_PINMUX('Z', 6, AF4)>; /* USART1_CK */
 			drive-push-pull;
-			slew-rate = <1>;
+			bias-disable;
 		};
-
 		pins2 {
-			pinmux = <STM32_PINMUX('A', 6, AF5)>; /* SPI1_MISO */
+			pinmux = <STM32_PINMUX('Z', 7, AF7)>; /* USART1_TX_RX */
+			drive-open-drain;
 			bias-disable;
 		};
 	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART1_TX_RX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART1_CK */
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* USART1_TX_RX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* USART1_CK */
+		};
+	};
 };
diff --git a/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi
index 314fc39a05..7a2f0ae648 100644
--- a/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15-scmi-u-boot.dtsi
@@ -25,6 +25,17 @@
 		multiple-images;
 	};
 
+	firmware {
+		optee {
+			u-boot,dm-pre-reloc;
+		};
+	};
+
+	/* need PSCI for sysreset during board_f */
+	psci {
+		u-boot,dm-pre-proper;
+	};
+
 	soc {
 		u-boot,dm-pre-reloc;
 
@@ -39,11 +50,6 @@
 			status = "okay";
 		};
 	};
-
-	/* need PSCI for sysreset during board_f */
-	psci {
-		u-boot,dm-pre-proper;
-	};
 };
 
 &bsec {
@@ -98,10 +104,6 @@
 	u-boot,dm-pre-reloc;
 };
 
-&optee {
-	u-boot,dm-pre-proper;
-};
-
 &iwdg2 {
 	u-boot,dm-pre-reloc;
 };
@@ -135,7 +137,7 @@
 };
 
 &usart1 {
-	resets = <&rcc USART1_R>;
+	resets = <&scmi_reset RST_SCMI_USART1>;
 };
 
 &usart2 {
diff --git a/arch/arm/dts/stm32mp15-scmi.dtsi b/arch/arm/dts/stm32mp15-scmi.dtsi
index 37d4547b3e..caa8c15a3e 100644
--- a/arch/arm/dts/stm32mp15-scmi.dtsi
+++ b/arch/arm/dts/stm32mp15-scmi.dtsi
@@ -16,7 +16,6 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 			linaro,optee-channel-id = <0>;
-			shmem = <&scmi_shm>;
 
 			scmi_clk: protocol@14 {
 				reg = <0x14>;
@@ -27,83 +26,12 @@
 				reg = <0x16>;
 				#reset-cells = <1>;
 			};
-
-			scmi_voltd: protocol@17 {
-				reg = <0x17>;
-
-				scmi_reguls: regulators {
-					#address-cells = <1>;
-					#size-cells = <0>;
-
-					scmi_reg11: reg11@0 {
-						reg = <0>;
-						regulator-name = "reg11";
-						regulator-min-microvolt = <1100000>;
-						regulator-max-microvolt = <1100000>;
-					};
-
-					scmi_reg18: reg18@1 {
-						voltd-name = "reg18";
-						reg = <1>;
-						regulator-name = "reg18";
-						regulator-min-microvolt = <1800000>;
-						regulator-max-microvolt = <1800000>;
-					};
-
-					scmi_usb33: usb33@2 {
-						reg = <2>;
-						regulator-name = "usb33";
-						regulator-min-microvolt = <3300000>;
-						regulator-max-microvolt = <3300000>;
-					};
-				};
-			};
-		};
-	};
-
-	soc {
-		scmi_sram: sram@2ffff000 {
-			compatible = "mmio-sram";
-			reg = <0x2ffff000 0x1000>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x2ffff000 0x1000>;
-
-			scmi_shm: scmi-sram@0 {
-				compatible = "arm,scmi-shmem";
-				reg = <0 0x80>;
-			};
 		};
 	};
 };
 
-&reg11 {
-	status = "disabled";
-};
-
-&reg18 {
-	status = "disabled";
-};
-
-&usb33 {
-	status = "disabled";
-};
-
-&usbotg_hs {
-	usb33d-supply = <&scmi_usb33>;
-};
-
-&usbphyc {
-	vdda1v1-supply = <&scmi_reg11>;
-	vdda1v8-supply = <&scmi_reg18>;
-};
-
 /delete-node/ &clk_hse;
 /delete-node/ &clk_hsi;
 /delete-node/ &clk_lse;
 /delete-node/ &clk_lsi;
 /delete-node/ &clk_csi;
-/delete-node/ &reg11;
-/delete-node/ &reg18;
-/delete-node/ &usb33;
-/delete-node/ &pwr_regulators;
diff --git a/arch/arm/dts/stm32mp15-u-boot.dtsi b/arch/arm/dts/stm32mp15-u-boot.dtsi
index d9d04743ac..19f7fb7aa7 100644
--- a/arch/arm/dts/stm32mp15-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15-u-boot.dtsi
@@ -53,20 +53,6 @@
 			reg = <0x5a003000 0x550
 			       0x5a004000 0x234>;
 
-			clocks = <&rcc AXIDCG>,
-				 <&rcc DDRC1>,
-				 <&rcc DDRC2>,
-				 <&rcc DDRPHYC>,
-				 <&rcc DDRCAPB>,
-				 <&rcc DDRPHYCAPB>;
-
-			clock-names = "axidcg",
-				      "ddrc1",
-				      "ddrc2",
-				      "ddrphyc",
-				      "ddrcapb",
-				      "ddrphycapb";
-
 			status = "okay";
 		};
 	};
@@ -106,6 +92,10 @@
 	};
 };
 
+&etzpc {
+	u-boot,dm-pre-reloc;
+};
+
 &gpioa {
 	u-boot,dm-pre-reloc;
 };
@@ -220,7 +210,7 @@
 	resets = <&rcc UART8_R>;
 };
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE)
+#if defined(CONFIG_STM32MP15X_STM32IMAGE)
 &binman {
 	u-boot-stm32 {
 		filename = "u-boot.stm32";
diff --git a/arch/arm/dts/stm32mp151.dtsi b/arch/arm/dts/stm32mp151.dtsi
index 767a06ef68..c3d8cf0127 100644
--- a/arch/arm/dts/stm32mp151.dtsi
+++ b/arch/arm/dts/stm32mp151.dtsi
@@ -3,8 +3,10 @@
  * Copyright (C) STMicroelectronics 2017 - All Rights Reserved
  * Author: Ludovic Barre <ludovic.barre@st.com> for STMicroelectronics.
  */
+#include <dt-bindings/bus/stm32mp15_sys_bus.h>
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/clock/stm32mp1-clks.h>
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/reset/stm32mp1-resets.h>
 
 / {
@@ -17,23 +19,33 @@
 
 		cpu0: cpu@0 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <0>;
+			clock-names = "cpu";
 			operating-points-v2 = <&cpu0_opp_table>;
 			nvmem-cells = <&part_number_otp>;
 			nvmem-cell-names = "part_number";
+			#cooling-cells = <2>;
 		};
 	};
 
 	cpu0_opp_table: cpu0-opp-table {
 		compatible = "operating-points-v2";
 		opp-shared;
+
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <1200000>;
+			opp-supported-hw = <0x2>;
+			opp-suspend;
+		};
+
 		opp-650000000 {
 			opp-hz = /bits/ 64 <650000000>;
 			opp-microvolt = <1200000>;
 			opp-supported-hw = <0x1>;
 		};
+
 		opp-800000000 {
 			opp-hz = /bits/ 64 <800000000>;
 			opp-microvolt = <1350000>;
@@ -41,6 +53,14 @@
 		};
 	};
 
+	intc: interrupt-controller@a0021000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0xa0021000 0x1000>,
+		      <0xa0022000 0x2000>;
+	};
+
 	arm-pmu {
 		compatible = "arm,cortex-a7-pmu";
 		interrupts = <GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>;
@@ -48,19 +68,17 @@
 		interrupt-parent = <&intc>;
 	};
 
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xb200005a>;
+		status = "disabled";
+	};
+
 	psci {
 		compatible = "arm,psci-1.0";
 		method = "smc";
 	};
 
-	intc: interrupt-controller@a0021000 {
-		compatible = "arm,cortex-a7-gic";
-		#interrupt-cells = <3>;
-		interrupt-controller;
-		reg = <0xa0021000 0x1000>,
-		      <0xa0022000 0x2000>;
-	};
-
 	timer {
 		compatible = "arm,armv7-timer";
 		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
@@ -71,6 +89,12 @@
 	};
 
 	clocks {
+		clk_csi: clk-csi {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <4000000>;
+		};
+
 		clk_hse: clk-hse {
 			#clock-cells = <0>;
 			compatible = "fixed-clock";
@@ -94,14 +118,34 @@
 			compatible = "fixed-clock";
 			clock-frequency = <32000>;
 		};
+	};
 
-		clk_csi: clk-csi {
-			#clock-cells = <0>;
-			compatible = "fixed-clock";
-			clock-frequency = <4000000>;
+	pm_domain {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "st,stm32mp157c-pd";
+
+		pd_core_ret: core-ret-power-domain@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <1>;
+			#power-domain-cells = <0>;
+			label = "CORE-RETENTION";
+
+			pd_core: core-power-domain@2 {
+				reg = <2>;
+				#power-domain-cells = <0>;
+				label = "CORE";
+			};
 		};
 	};
 
+	booster: regulator-booster {
+		compatible = "st,stm32mp1-booster";
+		st,syscfg = <&syscfg>;
+		status = "disabled";
+	};
+
 	thermal-zones {
 		cpu_thermal: cpu-thermal {
 			polling-delay-passive = <0>;
@@ -109,12 +153,6 @@
 			thermal-sensors = <&dts>;
 
 			trips {
-				cpu_alert1: cpu-alert1 {
-					temperature = <85000>;
-					hysteresis = <0>;
-					type = "passive";
-				};
-
 				cpu-crit {
 					temperature = <120000>;
 					hysteresis = <0>;
@@ -127,12 +165,6 @@
 		};
 	};
 
-	booster: regulator-booster {
-		compatible = "st,stm32mp1-booster";
-		st,syscfg = <&syscfg>;
-		status = "disabled";
-	};
-
 	soc {
 		compatible = "simple-bus";
 		#address-cells = <1>;
@@ -140,1672 +172,2106 @@
 		interrupt-parent = <&intc>;
 		ranges;
 
-		timers2: timer@40000000 {
+		sram4: sram@10050000 {
+			compatible = "mmio-sram";
+			reg = <0x10050000 0x10000>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40000000 0x400>;
-			clocks = <&rcc TIM2_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 18 0x400 0x1>,
-			       <&dmamux1 19 0x400 0x1>,
-			       <&dmamux1 20 0x400 0x1>,
-			       <&dmamux1 21 0x400 0x1>,
-			       <&dmamux1 22 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@1 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <1>;
-				status = "disabled";
-			};
+			#size-cells = <1>;
+			ranges = <0 0x10050000 0x10000>;
+		};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+		hsem: hwspinlock@4c000000 {
+			compatible = "st,stm32-hwspinlock";
+			#hwlock-cells = <2>;
+			reg = <0x4c000000 0x400>;
+			clocks = <&rcc HSEM>;
+			clock-names = "hsem";
 		};
 
-		timers3: timer@40001000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40001000 0x400>;
-			clocks = <&rcc TIM3_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 23 0x400 0x1>,
-			       <&dmamux1 24 0x400 0x1>,
-			       <&dmamux1 25 0x400 0x1>,
-			       <&dmamux1 26 0x400 0x1>,
-			       <&dmamux1 27 0x400 0x1>,
-			       <&dmamux1 28 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+		ipcc: mailbox@4c001000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x4c001000 0x400>;
+			st,proc-id = <0>;
+			interrupts-extended =
+				<&exti 61 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&rcc IPCC>;
+			wakeup-source;
+			power-domains = <&pd_core>;
 			status = "disabled";
+		};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@2 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <2>;
-				status = "disabled";
-			};
+		rcc: rcc@50000000 {
+			compatible = "st,stm32mp1-rcc", "syscon";
+			reg = <0x50000000 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+			clock-names = "hse", "hsi", "csi", "lse", "lsi";
+			clocks = <&clk_hse>, <&clk_hsi>, <&clk_csi>,
+				 <&clk_lse>, <&clk_lsi>;
 		};
 
-		timers4: timer@40002000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40002000 0x400>;
-			clocks = <&rcc TIM4_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 29 0x400 0x1>,
-			       <&dmamux1 30 0x400 0x1>,
-			       <&dmamux1 31 0x400 0x1>,
-			       <&dmamux1 32 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4";
-			status = "disabled";
+		pwr_regulators: pwr@50001000 {
+			compatible = "st,stm32mp1,pwr-reg";
+			reg = <0x50001000 0x10>;
+			st,tzcr = <&rcc 0x0 0x1>;
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+			reg11: reg11 {
+				regulator-name = "reg11";
+				regulator-min-microvolt = <1100000>;
+				regulator-max-microvolt = <1100000>;
 			};
 
-			timer@3 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <3>;
-				status = "disabled";
+			reg18: reg18 {
+				regulator-name = "reg18";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
 			};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			usb33: usb33 {
+				regulator-name = "usb33";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
 			};
 		};
 
-		timers5: timer@40003000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40003000 0x400>;
-			clocks = <&rcc TIM5_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 55 0x400 0x1>,
-			       <&dmamux1 56 0x400 0x1>,
-			       <&dmamux1 57 0x400 0x1>,
-			       <&dmamux1 58 0x400 0x1>,
-			       <&dmamux1 59 0x400 0x1>,
-			       <&dmamux1 60 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-
-			timer@4 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <4>;
-				status = "disabled";
-			};
-
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
-			};
+		pwr_mcu: pwr-mcu@50001014 {
+			compatible = "st,stm32mp151-pwr-mcu", "syscon";
+			reg = <0x50001014 0x4>;
 		};
 
-		timers6: timer@40004000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40004000 0x400>;
-			clocks = <&rcc TIM6_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 69 0x400 0x1>;
-			dma-names = "up";
-			status = "disabled";
+		pwr_irq: pwr@50001020 {
+			compatible = "st,stm32mp1-pwr";
+			reg = <0x50001020 0x100>;
+			interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
 
-			timer@5 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <5>;
-				status = "disabled";
-			};
+			st,wakeup-pins = <&gpioa 0 GPIO_ACTIVE_HIGH>,
+					 <&gpioa 2 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 13 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 8 GPIO_ACTIVE_HIGH>,
+					 <&gpioi 11 GPIO_ACTIVE_HIGH>,
+					 <&gpioc 1 GPIO_ACTIVE_HIGH>;
 		};
 
-		timers7: timer@40005000 {
+		pinctrl: pinctrl@50002000 {
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40005000 0x400>;
-			clocks = <&rcc TIM7_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 70 0x400 0x1>;
-			dma-names = "up";
-			status = "disabled";
+			#size-cells = <1>;
+			compatible = "st,stm32mp157-pinctrl";
+			ranges = <0 0x50002000 0xa400>;
+			interrupt-parent = <&exti>;
+			hwlocks = <&hsem 0 1>;
+			pins-are-numbered;
 
-			timer@6 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <6>;
+			gpioa: gpio@50002000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&rcc GPIOA>;
+				st,bank-name = "GPIOA";
 				status = "disabled";
 			};
-		};
 
-		timers12: timer@40006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40006000 0x400>;
-			clocks = <&rcc TIM12_K>;
-			clock-names = "int";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiob: gpio@50003000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x1000 0x400>;
+				clocks = <&rcc GPIOB>;
+				st,bank-name = "GPIOB";
 				status = "disabled";
 			};
 
-			timer@11 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <11>;
+			gpioc: gpio@50004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x2000 0x400>;
+				clocks = <&rcc GPIOC>;
+				st,bank-name = "GPIOC";
 				status = "disabled";
 			};
-		};
-
-		timers13: timer@40007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40007000 0x400>;
-			clocks = <&rcc TIM13_K>;
-			clock-names = "int";
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiod: gpio@50005000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x3000 0x400>;
+				clocks = <&rcc GPIOD>;
+				st,bank-name = "GPIOD";
 				status = "disabled";
 			};
 
-			timer@12 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <12>;
+			gpioe: gpio@50006000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x4000 0x400>;
+				clocks = <&rcc GPIOE>;
+				st,bank-name = "GPIOE";
 				status = "disabled";
 			};
-		};
-
-		timers14: timer@40008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x40008000 0x400>;
-			clocks = <&rcc TIM14_K>;
-			clock-names = "int";
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
+			gpiof: gpio@50007000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x5000 0x400>;
+				clocks = <&rcc GPIOF>;
+				st,bank-name = "GPIOF";
 				status = "disabled";
 			};
 
-			timer@13 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <13>;
+			gpiog: gpio@50008000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x6000 0x400>;
+				clocks = <&rcc GPIOG>;
+				st,bank-name = "GPIOG";
 				status = "disabled";
 			};
-		};
-
-		lptimer1: timer@40009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x40009000 0x400>;
-			interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM1_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
+			gpioh: gpio@50009000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x7000 0x400>;
+				clocks = <&rcc GPIOH>;
+				st,bank-name = "GPIOH";
 				status = "disabled";
 			};
 
-			trigger@0 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <0>;
+			gpioi: gpio@5000a000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x8000 0x400>;
+				clocks = <&rcc GPIOI>;
+				st,bank-name = "GPIOI";
 				status = "disabled";
 			};
 
-			counter {
-				compatible = "st,stm32-lptimer-counter";
+			gpioj: gpio@5000b000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x9000 0x400>;
+				clocks = <&rcc GPIOJ>;
+				st,bank-name = "GPIOJ";
 				status = "disabled";
 			};
-		};
 
-		spi2: spi@4000b000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI2_K>;
-			resets = <&rcc SPI2_R>;
-			dmas = <&dmamux1 39 0x400 0x05>,
-			       <&dmamux1 40 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+			gpiok: gpio@5000c000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa000 0x400>;
+				clocks = <&rcc GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
 		};
 
-		i2s2: audio-controller@4000b000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000b000 0x400>;
-			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 39 0x400 0x01>,
-			       <&dmamux1 40 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		exti: interrupt-controller@5000d000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x5000d000 0x400>;
+			hwlocks = <&hsem 1 1>;
+			wakeup-parent = <&pwr_irq>;
+			interrupts-extended =
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 8   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 9   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 64  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 65  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 66  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 67  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 40  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 42  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 76  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 77  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 33  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 72  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 95  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 37  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 38  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 39  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 71  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 52  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 53  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 82  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 83  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 75  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 98  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 93  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<&intc GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+				<&pwr_irq 0 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 1 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 2 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 3 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 4 IRQ_TYPE_EDGE_FALLING 0>,
+				<&pwr_irq 5 IRQ_TYPE_EDGE_FALLING 0>,		/* EXTI_60 */
+				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 94  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 62  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
 		};
 
-		spi3: spi@4000c000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI3_K>;
-			resets = <&rcc SPI3_R>;
-			dmas = <&dmamux1 61 0x400 0x05>,
-			       <&dmamux1 62 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		syscfg: syscon@50020000 {
+			compatible = "st,stm32mp157-syscfg", "syscon";
+			reg = <0x50020000 0x400>;
+			clocks = <&rcc SYSCFG>;
 		};
 
-		i2s3: audio-controller@4000c000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x4000c000 0x400>;
-			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 61 0x400 0x01>,
-			       <&dmamux1 62 0x400 0x01>;
-			dma-names = "rx", "tx";
+		dts: thermal@50028000 {
+			compatible = "st,stm32-thermal";
+			reg = <0x50028000 0x100>;
+			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc TMPSENS>;
+			clock-names = "pclk";
+			#thermal-sensor-cells = <0>;
 			status = "disabled";
 		};
 
-		spdifrx: audio-controller@4000d000 {
-			compatible = "st,stm32h7-spdifrx";
-			#sound-dai-cells = <0>;
-			reg = <0x4000d000 0x400>;
-			clocks = <&rcc SPDIF_K>;
-			clock-names = "kclk";
-			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 93 0x400 0x01>,
-			       <&dmamux1 94 0x400 0x01>;
-			dma-names = "rx", "rx-ctrl";
+		hdp: pinctrl@5002a000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x5002a000 0x400>;
+			clocks = <&rcc HDP>;
 			status = "disabled";
 		};
 
-		usart2: serial@4000e000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4000e000 0x400>;
-			interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART2_K>;
-			wakeup-source;
-			dmas = <&dmamux1 43 0x400 0x15>,
-			       <&dmamux1 44 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		pinctrl_z: pinctrl@54004000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp157-z-pinctrl";
+			ranges = <0 0x54004000 0x400>;
+			pins-are-numbered;
+			interrupt-parent = <&exti>;
+			hwlocks = <&hsem 0 1>;
+
+			gpioz: gpio@54004000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&rcc GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
 		};
 
-		usart3: serial@4000f000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x4000f000 0x400>;
-			interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART3_K>;
-			wakeup-source;
-			dmas = <&dmamux1 45 0x400 0x15>,
-			       <&dmamux1 46 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
+		mdma1: dma-controller@58000000 {
+			compatible = "st,stm32h7-mdma";
+			reg = <0x58000000 0x1000>;
+			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc MDMA>;
+			resets = <&rcc MDMA_R>;
+			#dma-cells = <5>;
+			dma-channels = <32>;
+			dma-requests = <48>;
 		};
 
-		uart4: serial@40010000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40010000 0x400>;
-			interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART4_K>;
-			wakeup-source;
-			dmas = <&dmamux1 63 0x400 0x15>,
-			       <&dmamux1 64 0x400 0x11>;
-			dma-names = "rx", "tx";
+		sdmmc1: mmc@58005000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00253180>;
+			reg = <0x58005000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SDMMC1_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC1_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
 			status = "disabled";
 		};
 
-		uart5: serial@40011000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40011000 0x400>;
-			interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART5_K>;
-			wakeup-source;
-			dmas = <&dmamux1 65 0x400 0x15>,
-			       <&dmamux1 66 0x400 0x11>;
-			dma-names = "rx", "tx";
+		sdmmc2: mmc@58007000 {
+			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+			arm,primecell-periphid = <0x00253180>;
+			reg = <0x58007000 0x1000>;
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc SDMMC2_K>;
+			clock-names = "apb_pclk";
+			resets = <&rcc SDMMC2_R>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			max-frequency = <120000000>;
 			status = "disabled";
 		};
 
-		i2c1: i2c@40012000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40012000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C1_K>;
-			resets = <&rcc I2C1_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x1>;
-			wakeup-source;
-			i2c-analog-filter;
+		crc1: crc@58009000 {
+			compatible = "st,stm32f7-crc";
+			reg = <0x58009000 0x400>;
+			clocks = <&rcc CRC1>;
 			status = "disabled";
 		};
 
-		i2c2: i2c@40013000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40013000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C2_K>;
-			resets = <&rcc I2C2_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x2>;
-			wakeup-source;
-			i2c-analog-filter;
+		usbh_ohci: usb@5800c000 {
+			compatible = "generic-ohci";
+			reg = <0x5800c000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
-		i2c3: i2c@40014000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40014000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C3_K>;
-			resets = <&rcc I2C3_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x4>;
+		usbh_ehci: usb@5800d000 {
+			compatible = "generic-ehci";
+			reg = <0x5800d000 0x1000>;
+			clocks = <&usbphyc>, <&rcc USBH>;
+			resets = <&rcc USBH_R>;
+			interrupts-extended = <&exti 43 IRQ_TYPE_LEVEL_HIGH>;
+			companion = <&usbh_ohci>;
+			power-domains = <&pd_core>;
 			wakeup-source;
-			i2c-analog-filter;
 			status = "disabled";
 		};
 
-		i2c5: i2c@40015000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x40015000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C5_K>;
-			resets = <&rcc I2C5_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x10>;
-			wakeup-source;
-			i2c-analog-filter;
+		ltdc: display-controller@5a001000 {
+			compatible = "st,stm32-ltdc";
+			reg = <0x5a001000 0x400>;
+			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&rcc LTDC_PX>;
+			clock-names = "lcd";
+			resets = <&rcc LTDC_R>;
 			status = "disabled";
 		};
 
-		cec: cec@40016000 {
-			compatible = "st,stm32-cec";
-			reg = <0x40016000 0x400>;
-			interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CEC_K>, <&rcc CEC>;
-			clock-names = "cec", "hdmi-cec";
+		iwdg2: watchdog@5a002000 {
+			compatible = "st,stm32mp1-iwdg";
+			reg = <0x5a002000 0x400>;
+			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
+			clock-names = "pclk", "lsi";
 			status = "disabled";
 		};
 
-		dac: dac@40017000 {
-			compatible = "st,stm32h7-dac-core";
-			reg = <0x40017000 0x400>;
-			clocks = <&rcc DAC12>;
-			clock-names = "pclk";
+		usbphyc: usbphyc@5a006000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
+			#clock-cells = <0>;
+			compatible = "st,stm32mp1-usbphyc";
+			reg = <0x5a006000 0x1000>;
+			clocks = <&rcc USBPHY_K>;
+			resets = <&rcc USBPHY_R>;
+			vdda1v1-supply = <&reg11>;
+			vdda1v8-supply = <&reg18>;
 			status = "disabled";
 
-			dac1: dac@1 {
-				compatible = "st,stm32-dac";
-				#io-channel-cells = <1>;
-				reg = <1>;
-				status = "disabled";
+			usbphyc_port0: usb-phy@0 {
+				#phy-cells = <0>;
+				reg = <0>;
 			};
 
-			dac2: dac@2 {
-				compatible = "st,stm32-dac";
-				#io-channel-cells = <1>;
-				reg = <2>;
-				status = "disabled";
+			usbphyc_port1: usb-phy@1 {
+				#phy-cells = <1>;
+				reg = <1>;
 			};
 		};
 
-		uart7: serial@40018000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40018000 0x400>;
-			interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART7_K>;
-			wakeup-source;
-			dmas = <&dmamux1 79 0x400 0x15>,
-			       <&dmamux1 80 0x400 0x11>;
-			dma-names = "rx", "tx";
+		ddrperfm: perf@5a007000 {
+			compatible = "st,stm32-ddr-pmu";
+			reg = <0x5a007000 0x400>;
+			clocks = <&rcc DDRPERFM>;
+			resets = <&rcc DDRPERFM_R>;
 			status = "disabled";
 		};
 
-		uart8: serial@40019000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x40019000 0x400>;
-			interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc UART8_K>;
-			wakeup-source;
-			dmas = <&dmamux1 81 0x400 0x15>,
-			       <&dmamux1 82 0x400 0x11>;
-			dma-names = "rx", "tx";
+		rtc: rtc@5c004000 {
+			compatible = "st,stm32mp1-rtc";
+			reg = <0x5c004000 0x400>;
+			clocks = <&rcc RTCAPB>, <&rcc RTC>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
 			status = "disabled";
 		};
 
-		timers1: timer@44000000 {
+		bsec: efuse@5c005000 {
+			compatible = "st,stm32mp15-bsec";
+			reg = <0x5c005000 0x400>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44000000 0x400>;
-			clocks = <&rcc TIM1_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 11 0x400 0x1>,
-			       <&dmamux1 12 0x400 0x1>,
-			       <&dmamux1 13 0x400 0x1>,
-			       <&dmamux1 14 0x400 0x1>,
-			       <&dmamux1 15 0x400 0x1>,
-			       <&dmamux1 16 0x400 0x1>,
-			       <&dmamux1 17 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4",
-				    "up", "trig", "com";
-			status = "disabled";
-
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+			#size-cells = <1>;
+			part_number_otp: part-number-otp@4 {
+				reg = <0x4 0x1>;
 			};
-
-			timer@0 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <0>;
-				status = "disabled";
+			vrefint: vrefin-cal@52 {
+				reg = <0x52 0x2>;
 			};
-
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+			ts_cal1: calib@5c {
+				reg = <0x5c 0x2>;
+			};
+			ts_cal2: calib@5e {
+				reg = <0x5e 0x2>;
+			};
+			ethernet_mac_address: mac@e4 {
+				reg = <0xe4 0x6>;
 			};
 		};
 
-		timers8: timer@44001000 {
+		etzpc: etzpc@5c007000 {
+			compatible = "st,stm32mp15-sys-bus";
+			reg = <0x5c007000 0x400>;
 			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44001000 0x400>;
-			clocks = <&rcc TIM8_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 47 0x400 0x1>,
-			       <&dmamux1 48 0x400 0x1>,
-			       <&dmamux1 49 0x400 0x1>,
-			       <&dmamux1 50 0x400 0x1>,
-			       <&dmamux1 51 0x400 0x1>,
-			       <&dmamux1 52 0x400 0x1>,
-			       <&dmamux1 53 0x400 0x1>;
-			dma-names = "ch1", "ch2", "ch3", "ch4",
-				    "up", "trig", "com";
-			status = "disabled";
+			#size-cells = <1>;
+			ranges;
+			feature-domain-controller;
+			#feature-domain-cells = <1>;
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
+			timers2: timer@40000000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM2_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 18 0x400 0x1>,
+				       <&dmamux1 19 0x400 0x1>,
+				       <&dmamux1 20 0x400 0x1>,
+				       <&dmamux1 21 0x400 0x1>,
+				       <&dmamux1 22 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM2_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			timer@7 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <7>;
-				status = "disabled";
-			};
+				timer@1 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
 
-			counter {
-				compatible = "st,stm32-timer-counter";
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
-		};
 
-		usart6: serial@44003000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x44003000 0x400>;
-			interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART6_K>;
-			wakeup-source;
-			dmas = <&dmamux1 71 0x400 0x15>,
-			       <&dmamux1 72 0x400 0x11>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers3: timer@40001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40001000 0x400>;
+				interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM3_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 23 0x400 0x1>,
+				       <&dmamux1 24 0x400 0x1>,
+				       <&dmamux1 25 0x400 0x1>,
+				       <&dmamux1 26 0x400 0x1>,
+				       <&dmamux1 27 0x400 0x1>,
+				       <&dmamux1 28 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM3_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		spi1: spi@44004000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44004000 0x400>;
-			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI1_K>;
-			resets = <&rcc SPI1_R>;
-			dmas = <&dmamux1 37 0x400 0x05>,
-			       <&dmamux1 38 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+				timer@2 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
 
-		i2s1: audio-controller@44004000 {
-			compatible = "st,stm32h7-i2s";
-			#sound-dai-cells = <0>;
-			reg = <0x44004000 0x400>;
-			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&dmamux1 37 0x400 0x01>,
-			       <&dmamux1 38 0x400 0x01>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+			};
 
-		spi4: spi@44005000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44005000 0x400>;
-			interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI4_K>;
-			resets = <&rcc SPI4_R>;
-			dmas = <&dmamux1 83 0x400 0x05>,
-			       <&dmamux1 84 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers4: timer@40002000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40002000 0x400>;
+				interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM4_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 29 0x400 0x1>,
+				       <&dmamux1 30 0x400 0x1>,
+				       <&dmamux1 31 0x400 0x1>,
+				       <&dmamux1 32 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM4_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		timers15: timer@44006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44006000 0x400>;
-			clocks = <&rcc TIM15_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 105 0x400 0x1>,
-			       <&dmamux1 106 0x400 0x1>,
-			       <&dmamux1 107 0x400 0x1>,
-			       <&dmamux1 108 0x400 0x1>;
-			dma-names = "ch1", "up", "trig", "com";
-			status = "disabled";
+				timer@3 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			timer@14 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <14>;
-				status = "disabled";
-			};
-		};
+			timers5: timer@40003000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40003000 0x400>;
+				interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM5_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 55 0x400 0x1>,
+				       <&dmamux1 56 0x400 0x1>,
+				       <&dmamux1 57 0x400 0x1>,
+				       <&dmamux1 58 0x400 0x1>,
+				       <&dmamux1 59 0x400 0x1>,
+				       <&dmamux1 60 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4", "up", "trig";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM5_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		timers16: timer@44007000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44007000 0x400>;
-			clocks = <&rcc TIM16_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 109 0x400 0x1>,
-			       <&dmamux1 110 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
+				timer@4 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
-			timer@15 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <15>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
-		};
 
-		timers17: timer@44008000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-timers";
-			reg = <0x44008000 0x400>;
-			clocks = <&rcc TIM17_K>;
-			clock-names = "int";
-			dmas = <&dmamux1 111 0x400 0x1>,
-			       <&dmamux1 112 0x400 0x1>;
-			dma-names = "ch1", "up";
-			status = "disabled";
+			timers6: timer@40004000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40004000 0x400>;
+				interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM6_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 69 0x400 0x1>;
+				dma-names = "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM6_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm";
-				#pwm-cells = <3>;
-				status = "disabled";
+				timer@5 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
 			};
 
-			timer@16 {
-				compatible = "st,stm32h7-timer-trigger";
-				reg = <16>;
-				status = "disabled";
+			timers7: timer@40005000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40005000 0x400>;
+				interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM7_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 70 0x400 0x1>;
+				dma-names = "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM7_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
 			};
-		};
 
-		spi5: spi@44009000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x44009000 0x400>;
-			interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI5_K>;
-			resets = <&rcc SPI5_R>;
-			dmas = <&dmamux1 85 0x400 0x05>,
-			       <&dmamux1 86 0x400 0x05>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
+			timers12: timer@40006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40006000 0x400>;
+				interrupts = <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM12_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM12_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		sai1: sai@4400a000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400a000 0x400>;
-			reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
-			interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI1_R>;
-			status = "disabled";
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			sai1a: audio-controller@4400a004 {
-				#sound-dai-cells = <0>;
+				timer@11 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
 
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x4 0x20>;
-				clocks = <&rcc SAI1_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 87 0x400 0x01>;
-				status = "disabled";
+			timers13: timer@40007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40007000 0x400>;
+				interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM13_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM13_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
 			};
 
-			sai1b: audio-controller@4400a024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI1_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 88 0x400 0x01>;
-				status = "disabled";
+			timers14: timer@40008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x40008000 0x400>;
+				interrupts = <GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM14_K>;
+				clock-names = "int";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM14_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
 			};
-		};
 
-		sai2: sai@4400b000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400b000 0x400>;
-			reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
-			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI2_R>;
-			status = "disabled";
+			lptimer1: timer@40009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x40009000 0x400>;
+				interrupts-extended = <&exti 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM1_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM1_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			sai2a: audio-controller@4400b004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x4 0x20>;
-				clocks = <&rcc SAI2_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 89 0x400 0x01>;
-				status = "disabled";
+				trigger@0 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			sai2b: audio-controller@4400b024 {
+			i2s2: audio-controller@4000b000 {
+				compatible = "st,stm32h7-i2s";
 				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI2_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 90 0x400 0x01>;
+				reg = <0x4000b000 0x400>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 39 0x400 0x01>,
+				       <&dmamux1 40 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI2_ID>;
 				status = "disabled";
 			};
-		};
-
-		sai3: sai@4400c000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x4400c000 0x400>;
-			reg = <0x4400c000 0x4>, <0x4400c3f0 0x10>;
-			interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI3_R>;
-			status = "disabled";
 
-			sai3a: audio-controller@4400c004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x04 0x20>;
-				clocks = <&rcc SAI3_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 113 0x400 0x01>;
+			spi2: spi@4000b000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x4000b000 0x400>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI2_K>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&dmamux1 39 0x400 0x01>,
+				       <&dmamux1 40 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI2_ID>;
 				status = "disabled";
 			};
 
-			sai3b: audio-controller@4400c024 {
+			i2s3: audio-controller@4000c000 {
+				compatible = "st,stm32h7-i2s";
 				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI3_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 114 0x400 0x01>;
+				reg = <0x4000c000 0x400>;
+				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 61 0x400 0x01>,
+				       <&dmamux1 62 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI3_ID>;
 				status = "disabled";
 			};
-		};
-
-		dfsdm: dfsdm@4400d000 {
-			compatible = "st,stm32mp1-dfsdm";
-			reg = <0x4400d000 0x800>;
-			clocks = <&rcc DFSDM_K>;
-			clock-names = "dfsdm";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
 
-			dfsdm0: filter@0 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <0>;
-				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 101 0x400 0x01>;
-				dma-names = "rx";
+			spi3: spi@4000c000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x4000c000 0x400>;
+				interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI3_K>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&dmamux1 61 0x400 0x01>,
+				       <&dmamux1 62 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI3_ID>;
 				status = "disabled";
 			};
 
-			dfsdm1: filter@1 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <1>;
-				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 102 0x400 0x01>;
-				dma-names = "rx";
+			spdifrx: audio-controller@4000d000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x4000d000 0x400>;
+				clocks = <&rcc SPDIF_K>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 93 0x400 0x01>,
+				       <&dmamux1 94 0x400 0x01>;
+				dma-names = "rx", "rx-ctrl";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPDIFRX_ID>;
+				status = "disabled";
+			};
+
+			usart2: serial@4000e000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4000e000 0x400>;
+				interrupts-extended = <&exti 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART2_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 43 0x400 0x15>,
+				       <&dmamux1 44 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART2_ID>;
+				status = "disabled";
+			};
+
+			usart3: serial@4000f000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x4000f000 0x400>;
+				interrupts-extended = <&exti 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART3_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 45 0x400 0x15>,
+				       <&dmamux1 46 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART3_ID>;
+				status = "disabled";
+			};
+
+			uart4: serial@40010000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40010000 0x400>;
+				interrupts-extended = <&exti 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART4_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 63 0x400 0x15>,
+				       <&dmamux1 64 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART4_ID>;
+				status = "disabled";
+			};
+
+			uart5: serial@40011000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40011000 0x400>;
+				interrupts-extended = <&exti 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART5_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 65 0x400 0x15>,
+				       <&dmamux1 66 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART5_ID>;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40012000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40012000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 21 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C1_K>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 33 0x400 0x1>,
+				       <&dmamux1 34 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x1>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C1_ID>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40013000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40013000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 22 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C2_K>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 35 0x400 0x1>,
+				       <&dmamux1 36 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x2>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C2_ID>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40014000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40014000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 23 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C3_K>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 73 0x400 0x1>,
+				       <&dmamux1 74 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x4>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C3_ID>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40015000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x40015000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts-extended = <&exti 25 IRQ_TYPE_LEVEL_HIGH>,
+						      <&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C5_K>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&dmamux1 115 0x400 0x1>,
+				       <&dmamux1 116 0x400 0x1>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x10>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C5_ID>;
 				status = "disabled";
 			};
 
-			dfsdm2: filter@2 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <2>;
-				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 103 0x400 0x01>;
-				dma-names = "rx";
+			cec: cec@40016000 {
+				compatible = "st,stm32-cec";
+				reg = <0x40016000 0x400>;
+				interrupts = <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CEC_K>, <&rcc CEC>;
+				clock-names = "cec", "hdmi-cec";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CEC_ID>;
 				status = "disabled";
 			};
 
-			dfsdm3: filter@3 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <3>;
-				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 104 0x400 0x01>;
-				dma-names = "rx";
+			dac: dac@40017000 {
+				compatible = "st,stm32h7-dac-core";
+				reg = <0x40017000 0x400>;
+				clocks = <&rcc DAC12>;
+				clock-names = "pclk";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DAC_ID>;
 				status = "disabled";
+
+				dac1: dac@1 {
+					compatible = "st,stm32-dac";
+					#io-channel-cells = <1>;
+					reg = <1>;
+					status = "disabled";
+				};
+
+				dac2: dac@2 {
+					compatible = "st,stm32-dac";
+					#io-channel-cells = <1>;
+					reg = <2>;
+					status = "disabled";
+				};
 			};
 
-			dfsdm4: filter@4 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <4>;
-				interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 91 0x400 0x01>;
-				dma-names = "rx";
+			uart7: serial@40018000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40018000 0x400>;
+				interrupts-extended = <&exti 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART7_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 79 0x400 0x15>,
+				       <&dmamux1 80 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART7_ID>;
 				status = "disabled";
 			};
 
-			dfsdm5: filter@5 {
-				compatible = "st,stm32-dfsdm-adc";
-				#io-channel-cells = <1>;
-				reg = <5>;
-				interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&dmamux1 92 0x400 0x01>;
-				dma-names = "rx";
+			uart8: serial@40019000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40019000 0x400>;
+				interrupts-extended = <&exti 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc UART8_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 81 0x400 0x15>,
+				       <&dmamux1 82 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_UART8_ID>;
 				status = "disabled";
 			};
-		};
 
-		dma1: dma-controller@48000000 {
-			compatible = "st,stm32-dma";
-			reg = <0x48000000 0x400>;
-			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc DMA1>;
-			resets = <&rcc DMA1_R>;
-			#dma-cells = <4>;
-			st,mem2mem;
-			dma-requests = <8>;
-		};
+			timers1: timer@44000000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44000000 0x400>;
+				interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc TIM1_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 11 0x400 0x1>,
+				       <&dmamux1 12 0x400 0x1>,
+				       <&dmamux1 13 0x400 0x1>,
+				       <&dmamux1 14 0x400 0x1>,
+				       <&dmamux1 15 0x400 0x1>,
+				       <&dmamux1 16 0x400 0x1>,
+				       <&dmamux1 17 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4",
+					    "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM1_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		dma2: dma-controller@48001000 {
-			compatible = "st,stm32-dma";
-			reg = <0x48001000 0x400>;
-			interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc DMA2>;
-			resets = <&rcc DMA2_R>;
-			#dma-cells = <4>;
-			st,mem2mem;
-			dma-requests = <8>;
-		};
+				timer@0 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
 
-		dmamux1: dma-router@48002000 {
-			compatible = "st,stm32h7-dmamux";
-			reg = <0x48002000 0x40>;
-			#dma-cells = <3>;
-			dma-requests = <128>;
-			dma-masters = <&dma1 &dma2>;
-			dma-channels = <16>;
-			clocks = <&rcc DMAMUX>;
-			resets = <&rcc DMAMUX_R>;
-		};
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
+			};
 
-		adc: adc@48003000 {
-			compatible = "st,stm32mp1-adc-core";
-			reg = <0x48003000 0x400>;
-			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc ADC12>, <&rcc ADC12_K>;
-			clock-names = "bus", "adc";
-			interrupt-controller;
-			st,syscfg = <&syscfg>;
-			#interrupt-cells = <1>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
+			timers8: timer@44001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44001000 0x400>;
+				interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc TIM8_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 47 0x400 0x1>,
+				       <&dmamux1 48 0x400 0x1>,
+				       <&dmamux1 49 0x400 0x1>,
+				       <&dmamux1 50 0x400 0x1>,
+				       <&dmamux1 51 0x400 0x1>,
+				       <&dmamux1 52 0x400 0x1>,
+				       <&dmamux1 53 0x400 0x1>;
+				dma-names = "ch1", "ch2", "ch3", "ch4",
+					    "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM8_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			adc1: adc@0 {
-				compatible = "st,stm32mp1-adc";
-				#io-channel-cells = <1>;
-				reg = <0x0>;
-				interrupt-parent = <&adc>;
-				interrupts = <0>;
-				dmas = <&dmamux1 9 0x400 0x01>;
-				dma-names = "rx";
-				status = "disabled";
+				timer@7 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 			};
 
-			adc2: adc@100 {
-				compatible = "st,stm32mp1-adc";
-				#io-channel-cells = <1>;
-				reg = <0x100>;
-				interrupt-parent = <&adc>;
-				interrupts = <1>;
-				dmas = <&dmamux1 10 0x400 0x01>;
-				dma-names = "rx";
+			usart6: serial@44003000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x44003000 0x400>;
+				interrupts-extended = <&exti 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART6_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				dmas = <&dmamux1 71 0x400 0x15>,
+				       <&dmamux1 72 0x400 0x11>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART6_ID>;
 				status = "disabled";
 			};
-		};
 
-		sdmmc3: mmc@48004000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x48004000 0x400>;
-			interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC3_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC3_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
+			i2s1: audio-controller@44004000 {
+				compatible = "st,stm32h7-i2s";
+				#sound-dai-cells = <0>;
+				reg = <0x44004000 0x400>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&dmamux1 37 0x400 0x01>,
+				       <&dmamux1 38 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI1_ID>;
+				status = "disabled";
+			};
 
-		usbotg_hs: usb-otg@49000000 {
-			compatible = "st,stm32mp15-hsotg", "snps,dwc2";
-			reg = <0x49000000 0x10000>;
-			clocks = <&rcc USBO_K>;
-			clock-names = "otg";
-			resets = <&rcc USBO_R>;
-			reset-names = "dwc2";
-			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
-			g-rx-fifo-size = <512>;
-			g-np-tx-fifo-size = <32>;
-			g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
-			dr_mode = "otg";
-			otg-rev = <0x200>;
-			usb33d-supply = <&usb33>;
-			status = "disabled";
-		};
+			spi1: spi@44004000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44004000 0x400>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI1_K>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&dmamux1 37 0x400 0x01>,
+				       <&dmamux1 38 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI1_ID>;
+				status = "disabled";
+			};
 
-		hwspinlock: hwspinlock@4c000000 {
-			compatible = "st,stm32-hwspinlock";
-			#hwlock-cells = <1>;
-			reg = <0x4c000000 0x400>;
-			clocks = <&rcc HSEM>;
-			clock-names = "hwspinlock";
-		};
+			spi4: spi@44005000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44005000 0x400>;
+				interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI4_K>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&dmamux1 83 0x400 0x01>,
+				       <&dmamux1 84 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI4_ID>;
+				status = "disabled";
+			};
 
-		ipcc: mailbox@4c001000 {
-			compatible = "st,stm32mp1-ipcc";
-			#mbox-cells = <1>;
-			reg = <0x4c001000 0x400>;
-			st,proc-id = <0>;
-			interrupts-extended =
-				<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
-				<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
-				<&exti 61 1>;
-			interrupt-names = "rx", "tx", "wakeup";
-			clocks = <&rcc IPCC>;
-			wakeup-source;
-			status = "disabled";
-		};
+			timers15: timer@44006000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44006000 0x400>;
+				interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM15_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 105 0x400 0x1>,
+				       <&dmamux1 106 0x400 0x1>,
+				       <&dmamux1 107 0x400 0x1>,
+				       <&dmamux1 108 0x400 0x1>;
+				dma-names = "ch1", "up", "trig", "com";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM15_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		dcmi: dcmi@4c006000 {
-			compatible = "st,stm32-dcmi";
-			reg = <0x4c006000 0x400>;
-			interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc CAMITF_R>;
-			clocks = <&rcc DCMI>;
-			clock-names = "mclk";
-			dmas = <&dmamux1 75 0x400 0x01>;
-			dma-names = "tx";
-			status = "disabled";
-		};
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		rcc: rcc@50000000 {
-			compatible = "st,stm32mp1-rcc", "syscon";
-			reg = <0x50000000 0x1000>;
-			#clock-cells = <1>;
-			#reset-cells = <1>;
+				timer@14 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
 
-			clock-names = "hse", "hsi", "csi", "lse", "lsi";
-			clocks = <&clk_hse>, <&clk_hsi>, <&clk_csi>,
-				 <&clk_lse>, <&clk_lsi>;
-		};
+			timers16: timer@44007000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44007000 0x400>;
+				interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM16_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 109 0x400 0x1>,
+				       <&dmamux1 110 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM16_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-		pwr_regulators: pwr@50001000 {
-			compatible = "st,stm32mp1,pwr-reg";
-			reg = <0x50001000 0x10>;
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-			reg11: reg11 {
-				regulator-name = "reg11";
-				regulator-min-microvolt = <1100000>;
-				regulator-max-microvolt = <1100000>;
+				timer@15 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
 			};
 
-			reg18: reg18 {
-				regulator-name = "reg18";
-				regulator-min-microvolt = <1800000>;
-				regulator-max-microvolt = <1800000>;
-			};
+			timers17: timer@44008000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-timers";
+				reg = <0x44008000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc TIM17_K>;
+				clock-names = "int";
+				dmas = <&dmamux1 111 0x400 0x1>,
+				       <&dmamux1 112 0x400 0x1>;
+				dma-names = "ch1", "up";
+				feature-domains = <&etzpc STM32MP1_ETZPC_TIM17_ID>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32-timer-counter";
+					status = "disabled";
+				};
 
-			usb33: usb33 {
-				regulator-name = "usb33";
-				regulator-min-microvolt = <3300000>;
-				regulator-max-microvolt = <3300000>;
+				pwm {
+					compatible = "st,stm32-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32h7-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
 			};
-		};
 
-		pwr_mcu: pwr_mcu@50001014 {
-			compatible = "st,stm32mp151-pwr-mcu", "syscon";
-			reg = <0x50001014 0x4>;
-		};
+			spi5: spi@44009000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x44009000 0x400>;
+				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI5_K>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&dmamux1 85 0x400 0x01>,
+				       <&dmamux1 86 0x400 0x01>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI5_ID>;
+				status = "disabled";
+			};
 
-		exti: interrupt-controller@5000d000 {
-			compatible = "st,stm32mp1-exti", "syscon";
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			reg = <0x5000d000 0x400>;
-		};
+			sai1: sai@4400a000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400a000 0x400>;
+				reg = <0x4400a000 0x4>, <0x4400a3f0 0x10>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI1_ID>;
+				status = "disabled";
+
+				sai1a: audio-controller@4400a004 {
+					#sound-dai-cells = <0>;
+
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					clocks = <&rcc SAI1_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 87 0x400 0x01>;
+					status = "disabled";
+				};
 
-		syscfg: syscon@50020000 {
-			compatible = "st,stm32mp157-syscfg", "syscon";
-			reg = <0x50020000 0x400>;
-			clocks = <&rcc SYSCFG>;
-		};
+				sai1b: audio-controller@4400a024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI1_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 88 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-		lptimer2: timer@50021000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50021000 0x400>;
-			interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM2_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+			sai2: sai@4400b000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400b000 0x400>;
+				reg = <0x4400b000 0x4>, <0x4400b3f0 0x10>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI2_ID>;
+				status = "disabled";
+
+				sai2a: audio-controller@4400b004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					clocks = <&rcc SAI2_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 89 0x400 0x01>;
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				sai2b: audio-controller@4400b024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI2_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 90 0x400 0x01>;
+					status = "disabled";
+				};
 			};
 
-			trigger@1 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <1>;
-				status = "disabled";
+			sai3: sai@4400c000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x4400c000 0x400>;
+				reg = <0x4400c000 0x4>, <0x4400c3f0 0x10>;
+				interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI3_ID>;
+				status = "disabled";
+
+				sai3a: audio-controller@4400c004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x04 0x20>;
+					clocks = <&rcc SAI3_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 113 0x400 0x01>;
+					status = "disabled";
+				};
+
+				sai3b: audio-controller@4400c024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI3_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 114 0x400 0x01>;
+					status = "disabled";
+				};
 			};
 
-			counter {
-				compatible = "st,stm32-lptimer-counter";
+			dfsdm: dfsdm@4400d000 {
+				compatible = "st,stm32mp1-dfsdm";
+				reg = <0x4400d000 0x800>;
+				clocks = <&rcc DFSDM_K>;
+				clock-names = "dfsdm";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DFSDM_ID>;
 				status = "disabled";
-			};
-		};
 
-		lptimer3: timer@50022000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32-lptimer";
-			reg = <0x50022000 0x400>;
-			interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM3_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+				dfsdm0: filter@0 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <0>;
+					interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 101 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
-			};
+				dfsdm1: filter@1 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <1>;
+					interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 102 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			trigger@2 {
-				compatible = "st,stm32-lptimer-trigger";
-				reg = <2>;
-				status = "disabled";
-			};
-		};
+				dfsdm2: filter@2 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <2>;
+					interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 103 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-		lptimer4: timer@50023000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50023000 0x400>;
-			interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM4_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+				dfsdm3: filter@3 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <3>;
+					interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 104 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				dfsdm4: filter@4 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <4>;
+					interrupts = <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 91 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				dfsdm5: filter@5 {
+					compatible = "st,stm32-dfsdm-adc";
+					#io-channel-cells = <1>;
+					reg = <5>;
+					interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&dmamux1 92 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 			};
-		};
 
-		lptimer5: timer@50024000 {
-			compatible = "st,stm32-lptimer";
-			reg = <0x50024000 0x400>;
-			interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LPTIM5_K>;
-			clock-names = "mux";
-			wakeup-source;
-			status = "disabled";
+			dma1: dma-controller@48000000 {
+				compatible = "st,stm32-dma";
+				reg = <0x48000000 0x400>;
+				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc DMA1>;
+				resets = <&rcc DMA1_R>;
+				#dma-cells = <4>;
+				st,mem2mem;
+				dma-requests = <8>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DMA1_ID>;
+			};
+
+			dma2: dma-controller@48001000 {
+				compatible = "st,stm32-dma";
+				reg = <0x48001000 0x400>;
+				interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc DMA2>;
+				resets = <&rcc DMA2_R>;
+				#dma-cells = <4>;
+				st,mem2mem;
+				dma-requests = <8>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DMA2_ID>;
+			};
+
+			dmamux1: dma-router@48002000 {
+				compatible = "st,stm32h7-dmamux";
+				reg = <0x48002000 0x40>;
+				#dma-cells = <3>;
+				dma-requests = <128>;
+				dma-masters = <&dma1 &dma2>;
+				dma-channels = <16>;
+				clocks = <&rcc DMAMUX>;
+				resets = <&rcc DMAMUX_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_DMAMUX_ID>;
+			};
+
+			adc: adc@48003000 {
+				compatible = "st,stm32mp1-adc-core";
+				reg = <0x48003000 0x400>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc ADC12>, <&rcc ADC12_K>;
+				clock-names = "bus", "adc";
+				interrupt-controller;
+				st,syscfg = <&syscfg>;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ADC_ID>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp1-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x0>;
+					interrupt-parent = <&adc>;
+					interrupts = <0>;
+					dmas = <&dmamux1 9 0x400 0x01>;
+					dma-names = "rx";
+					status = "disabled";
+				};
 
-			pwm {
-				compatible = "st,stm32-pwm-lp";
-				#pwm-cells = <3>;
-				status = "disabled";
+				adc2: adc@100 {
+					compatible = "st,stm32mp1-adc";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0x100>;
+					interrupt-parent = <&adc>;
+					interrupts = <1>;
+					dmas = <&dmamux1 10 0x400 0x01>;
+					dma-names = "rx";
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@13 {
+						reg = <13>;
+						label = "vrefint";
+					};
+					channel@14 {
+						reg = <14>;
+						label = "vddcore";
+					};
+				};
 			};
-		};
 
-		vrefbuf: vrefbuf@50025000 {
-			compatible = "st,stm32-vrefbuf";
-			reg = <0x50025000 0x8>;
-			regulator-min-microvolt = <1500000>;
-			regulator-max-microvolt = <2500000>;
-			clocks = <&rcc VREF>;
-			status = "disabled";
-		};
+			sdmmc3: mmc@48004000 {
+				compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00253180>;
+				reg = <0x48004000 0x400>;
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SDMMC3_K>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				status = "disabled";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SDMMC3_ID>;
+			};
+
+			usbotg_hs: usb-otg@49000000 {
+				compatible = "st,stm32mp15-hsotg", "snps,dwc2";
+				reg = <0x49000000 0x10000>;
+				clocks = <&rcc USBO_K>, <&usbphyc>;
+				clock-names = "otg", "utmi";
+				resets = <&rcc USBO_R>;
+				reset-names = "dwc2";
+				interrupts-extended = <&exti 44 IRQ_TYPE_LEVEL_HIGH>;
+				g-rx-fifo-size = <512>;
+				g-np-tx-fifo-size = <32>;
+				g-tx-fifo-size = <256 16 16 16 16 16 16 16>;
+				dr_mode = "otg";
+				otg-rev = <0x200>;
+				usb33d-supply = <&usb33>;
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_OTG_ID>;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@4c006000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x4c006000 0x400>;
+				interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CAMITF_R>;
+				clocks = <&rcc DCMI>;
+				clock-names = "mclk";
+				dmas = <&dmamux1 75 0x400 0x01>;
+				dma-names = "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_DCMI_ID>;
+				status = "disabled";
+			};
+
+			lptimer2: timer@50021000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50021000 0x400>;
+				interrupts-extended = <&exti 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM2_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM2_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		sai4: sai@50027000 {
-			compatible = "st,stm32h7-sai";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			ranges = <0 0x50027000 0x400>;
-			reg = <0x50027000 0x4>, <0x500273f0 0x10>;
-			interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
-			resets = <&rcc SAI4_R>;
-			status = "disabled";
+				trigger@1 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
 
-			sai4a: audio-controller@50027004 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-a";
-				reg = <0x04 0x20>;
-				clocks = <&rcc SAI4_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 99 0x400 0x01>;
-				status = "disabled";
+				counter {
+					compatible = "st,stm32-lptimer-counter";
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
 			};
 
-			sai4b: audio-controller@50027024 {
-				#sound-dai-cells = <0>;
-				compatible = "st,stm32-sai-sub-b";
-				reg = <0x24 0x20>;
-				clocks = <&rcc SAI4_K>;
-				clock-names = "sai_ck";
-				dmas = <&dmamux1 100 0x400 0x01>;
-				status = "disabled";
-			};
-		};
-
-		dts: thermal@50028000 {
-			compatible = "st,stm32-thermal";
-			reg = <0x50028000 0x100>;
-			interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc TMPSENS>;
-			clock-names = "pclk";
-			#thermal-sensor-cells = <0>;
-			status = "disabled";
-		};
-
-		hash1: hash@54002000 {
-			compatible = "st,stm32f756-hash";
-			reg = <0x54002000 0x400>;
-			interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc HASH1>;
-			resets = <&rcc HASH1_R>;
-			dmas = <&mdma1 31 0x2 0x1000A02 0x0 0x0>;
-			dma-names = "in";
-			dma-maxburst = <2>;
-			status = "disabled";
-		};
-
-		rng1: rng@54003000 {
-			compatible = "st,stm32-rng";
-			reg = <0x54003000 0x400>;
-			clocks = <&rcc RNG1_K>;
-			resets = <&rcc RNG1_R>;
-			status = "disabled";
-		};
-
-		mdma1: dma-controller@58000000 {
-			compatible = "st,stm32h7-mdma";
-			reg = <0x58000000 0x1000>;
-			interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc MDMA>;
-			resets = <&rcc MDMA_R>;
-			#dma-cells = <5>;
-			dma-channels = <32>;
-			dma-requests = <48>;
-		};
+			lptimer3: timer@50022000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32-lptimer";
+				reg = <0x50022000 0x400>;
+				interrupts-extended = <&exti 50 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM3_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM3_ID>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		fmc: memory-controller@58002000 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp1-fmc2-ebi";
-			reg = <0x58002000 0x1000>;
-			clocks = <&rcc FMC_K>;
-			resets = <&rcc FMC_R>;
-			status = "disabled";
+				trigger@2 {
+					compatible = "st,stm32-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
 
-			ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
-				 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
-				 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
-				 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
-				 <4 0 0x80000000 0x10000000>; /* NAND */
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
 
-			nand-controller@4,0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "st,stm32mp1-fmc2-nfc";
-				reg = <4 0x00000000 0x1000>,
-				      <4 0x08010000 0x1000>,
-				      <4 0x08020000 0x1000>,
-				      <4 0x01000000 0x1000>,
-				      <4 0x09010000 0x1000>,
-				      <4 0x09020000 0x1000>;
-				interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
-				dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
-				       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
-				       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
-				dma-names = "tx", "rx", "ecc";
+			lptimer4: timer@50023000 {
+				compatible = "st,stm32-lptimer";
+				reg = <0x50023000 0x400>;
+				interrupts-extended = <&exti 52 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM4_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM4_ID>;
 				status = "disabled";
-			};
-		};
 
-		qspi: spi@58003000 {
-			compatible = "st,stm32f469-qspi";
-			reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
-			reg-names = "qspi", "qspi_mm";
-			interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
-			dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
-			       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
-			dma-names = "tx", "rx";
-			clocks = <&rcc QSPI_K>;
-			resets = <&rcc QSPI_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			status = "disabled";
-		};
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		sdmmc1: mmc@58005000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x58005000 0x1000>;
-			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC1_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC1_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
 
-		sdmmc2: mmc@58007000 {
-			compatible = "st,stm32-sdmmc2", "arm,pl18x", "arm,primecell";
-			arm,primecell-periphid = <0x00253180>;
-			reg = <0x58007000 0x1000>;
-			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "cmd_irq";
-			clocks = <&rcc SDMMC2_K>;
-			clock-names = "apb_pclk";
-			resets = <&rcc SDMMC2_R>;
-			cap-sd-highspeed;
-			cap-mmc-highspeed;
-			max-frequency = <120000000>;
-			status = "disabled";
-		};
+			lptimer5: timer@50024000 {
+				compatible = "st,stm32-lptimer";
+				reg = <0x50024000 0x400>;
+				interrupts-extended = <&exti 53 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc LPTIM5_K>;
+				clock-names = "mux";
+				power-domains = <&pd_core>;
+				wakeup-source;
+				feature-domains = <&etzpc STM32MP1_ETZPC_LPTIM5_ID>;
+				status = "disabled";
 
-		crc1: crc@58009000 {
-			compatible = "st,stm32f7-crc";
-			reg = <0x58009000 0x400>;
-			clocks = <&rcc CRC1>;
-			status = "disabled";
-		};
+				pwm {
+					compatible = "st,stm32-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
 
-		ethernet0: ethernet@5800a000 {
-			compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
-			reg = <0x5800a000 0x2000>;
-			reg-names = "stmmaceth";
-			interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "macirq";
-			clock-names = "stmmaceth",
-				      "mac-clk-tx",
-				      "mac-clk-rx",
-				      "eth-ck",
-				      "ptp_ref",
-				      "ethstp";
-			clocks = <&rcc ETHMAC>,
-				 <&rcc ETHTX>,
-				 <&rcc ETHRX>,
-				 <&rcc ETHCK_K>,
-				 <&rcc ETHPTP_K>,
-				 <&rcc ETHSTP>;
-			st,syscon = <&syscfg 0x4>;
-			snps,mixed-burst;
-			snps,pbl = <2>;
-			snps,en-tx-lpi-clockgating;
-			snps,axi-config = <&stmmac_axi_config_0>;
-			snps,tso;
-			status = "disabled";
+				timer {
+					compatible = "st,stm32-lptimer-timer";
+					status = "disabled";
+				};
+			};
 
-			stmmac_axi_config_0: stmmac-axi-config {
-				snps,wr_osr_lmt = <0x7>;
-				snps,rd_osr_lmt = <0x7>;
-				snps,blen = <0 0 0 0 16 8 4>;
+			vrefbuf: vrefbuf@50025000 {
+				compatible = "st,stm32-vrefbuf";
+				reg = <0x50025000 0x8>;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <2500000>;
+				clocks = <&rcc VREF>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_VREFBUF_ID>;
+				status = "disabled";
 			};
-		};
 
-		usbh_ohci: usb@5800c000 {
-			compatible = "generic-ohci";
-			reg = <0x5800c000 0x1000>;
-			clocks = <&usbphyc>, <&rcc USBH>;
-			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
-			status = "disabled";
-		};
+			sai4: sai@50027000 {
+				compatible = "st,stm32h7-sai";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x50027000 0x400>;
+				reg = <0x50027000 0x4>, <0x500273f0 0x10>;
+				interrupts = <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_SAI4_ID>;
+				status = "disabled";
+
+				sai4a: audio-controller@50027004 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x04 0x20>;
+					clocks = <&rcc SAI4_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 99 0x400 0x01>;
+					status = "disabled";
+				};
 
-		usbh_ehci: usb@5800d000 {
-			compatible = "generic-ehci";
-			reg = <0x5800d000 0x1000>;
-			clocks = <&usbphyc>, <&rcc USBH>;
-			resets = <&rcc USBH_R>;
-			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
-			companion = <&usbh_ohci>;
-			status = "disabled";
-		};
+				sai4b: audio-controller@50027024 {
+					#sound-dai-cells = <0>;
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					clocks = <&rcc SAI4_K>;
+					clock-names = "sai_ck";
+					dmas = <&dmamux1 100 0x400 0x01>;
+					status = "disabled";
+				};
+			};
 
-		ltdc: display-controller@5a001000 {
-			compatible = "st,stm32-ltdc";
-			reg = <0x5a001000 0x400>;
-			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc LTDC_PX>;
-			clock-names = "lcd";
-			resets = <&rcc LTDC_R>;
-			status = "disabled";
+			hash1: hash@54002000 {
+				compatible = "st,stm32f756-hash";
+				reg = <0x54002000 0x400>;
+				interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc HASH1>;
+				resets = <&rcc HASH1_R>;
+				dmas = <&mdma1 31 0x2 0x1000a02 0x0 0x0>;
+				dma-names = "in";
+				dma-maxburst = <2>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_HASH1_ID>;
+				status = "disabled";
+			};
+
+			rng1: rng@54003000 {
+				compatible = "st,stm32-rng";
+				reg = <0x54003000 0x400>;
+				clocks = <&rcc RNG1_K>;
+				resets = <&rcc RNG1_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_RNG1_ID>;
+				status = "disabled";
+			};
+
+			fmc: memory-controller@58002000 {
+				#address-cells = <2>;
+				#size-cells = <1>;
+				compatible = "st,stm32mp1-fmc2-ebi";
+				reg = <0x58002000 0x1000>;
+				clocks = <&rcc FMC_K>;
+				resets = <&rcc FMC_R>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_FMC_ID>;
+				status = "disabled";
+
+				ranges = <0 0 0x60000000 0x04000000>, /* EBI CS 1 */
+					 <1 0 0x64000000 0x04000000>, /* EBI CS 2 */
+					 <2 0 0x68000000 0x04000000>, /* EBI CS 3 */
+					 <3 0 0x6c000000 0x04000000>, /* EBI CS 4 */
+					 <4 0 0x80000000 0x10000000>; /* NAND */
+
+				nand-controller@4,0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					compatible = "st,stm32mp1-fmc2-nfc";
+					reg = <4 0x00000000 0x1000>,
+					      <4 0x08010000 0x1000>,
+					      <4 0x08020000 0x1000>,
+					      <4 0x01000000 0x1000>,
+					      <4 0x09010000 0x1000>,
+					      <4 0x09020000 0x1000>;
+					interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&mdma1 20 0x2 0x12000a02 0x0 0x0>,
+					       <&mdma1 20 0x2 0x12000a08 0x0 0x0>,
+					       <&mdma1 21 0x2 0x12000a0a 0x0 0x0>;
+					dma-names = "tx", "rx", "ecc";
+					status = "disabled";
+				};
+			};
 
-			port {
+			qspi: spi@58003000 {
+				compatible = "st,stm32f469-qspi";
+				reg = <0x58003000 0x1000>, <0x70000000 0x10000000>;
+				reg-names = "qspi", "qspi_mm";
+				interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&mdma1 22 0x2 0x10100002 0x0 0x0>,
+				       <&mdma1 22 0x2 0x10100008 0x0 0x0>;
+				dma-names = "tx", "rx";
+				clocks = <&rcc QSPI_K>;
+				resets = <&rcc QSPI_R>;
 				#address-cells = <1>;
 				#size-cells = <0>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_QSPI_ID>;
+				status = "disabled";
+			};
+
+			ethernet0: ethernet@5800a000 {
+				compatible = "st,stm32mp1-dwmac", "snps,dwmac-4.20a";
+				reg = <0x5800a000 0x2000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti 70 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "eth-ck",
+					      "ptp_ref",
+					      "ethstp";
+				clocks = <&rcc ETHMAC>,
+					 <&rcc ETHTX>,
+					 <&rcc ETHRX>,
+					 <&rcc ETHCK_K>,
+					 <&rcc ETHPTP_K>,
+					 <&rcc ETHSTP>;
+				st,syscon = <&syscfg 0x4>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,en-tx-lpi-clockgating;
+				snps,axi-config = <&stmmac_axi_config_0>;
+				snps,tso;
+				feature-domains = <&etzpc STM32MP1_ETZPC_ETH_ID>;
+				status = "disabled";
+				power-domains = <&pd_core>;
+
+				stmmac_axi_config_0: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
 			};
-		};
-
-		iwdg2: watchdog@5a002000 {
-			compatible = "st,stm32mp1-iwdg";
-			reg = <0x5a002000 0x400>;
-			clocks = <&rcc IWDG2>, <&rcc CK_LSI>;
-			clock-names = "pclk", "lsi";
-			status = "disabled";
-		};
 
-		usbphyc: usbphyc@5a006000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			#clock-cells = <0>;
-			compatible = "st,stm32mp1-usbphyc";
-			reg = <0x5a006000 0x1000>;
-			clocks = <&rcc USBPHY_K>;
-			resets = <&rcc USBPHY_R>;
-			vdda1v1-supply = <&reg11>;
-			vdda1v8-supply = <&reg18>;
-			status = "disabled";
-
-			usbphyc_port0: usb-phy@0 {
-				#phy-cells = <0>;
-				reg = <0>;
+			usart1: serial@5c000000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x5c000000 0x400>;
+				interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc USART1_K>;
+				wakeup-source;
+				power-domains = <&pd_core>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_USART1_ID>;
+				status = "disabled";
 			};
 
-			usbphyc_port1: usb-phy@1 {
-				#phy-cells = <1>;
-				reg = <1>;
+			spi6: spi@5c001000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32h7-spi";
+				reg = <0x5c001000 0x400>;
+				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc SPI6_K>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 35 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				feature-domains = <&etzpc STM32MP1_ETZPC_SPI6_ID>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@5c002000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x5c002000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C4_K>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&mdma1 36 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 37 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x8>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C4_ID>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@5c009000 {
+				compatible = "st,stm32mp15-i2c";
+				reg = <0x5c009000 0x400>;
+				interrupt-names = "event", "error";
+				interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc I2C6_K>;
+				resets = <&rcc I2C6_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&mdma1 38 0x0 0x40008 0x0 0x0>,
+				       <&mdma1 39 0x0 0x40002 0x0 0x0>;
+				dma-names = "rx", "tx";
+				power-domains = <&pd_core>;
+				st,syscfg-fmp = <&syscfg 0x4 0x20>;
+				wakeup-source;
+				i2c-analog-filter;
+				feature-domains = <&etzpc STM32MP1_ETZPC_I2C6_ID>;
+				status = "disabled";
 			};
 		};
 
-		usart1: serial@5c000000 {
-			compatible = "st,stm32h7-uart";
-			reg = <0x5c000000 0x400>;
-			interrupts-extended = <&exti 26 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc USART1_K>;
-			wakeup-source;
-			status = "disabled";
-		};
-
-		spi6: spi@5c001000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "st,stm32h7-spi";
-			reg = <0x5c001000 0x400>;
-			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc SPI6_K>;
-			resets = <&rcc SPI6_R>;
-			dmas = <&mdma1 34 0x0 0x40008 0x0 0x0>,
-			       <&mdma1 35 0x0 0x40002 0x0 0x0>;
-			dma-names = "rx", "tx";
-			status = "disabled";
-		};
-
-		i2c4: i2c@5c002000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x5c002000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C4_K>;
-			resets = <&rcc I2C4_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x8>;
-			wakeup-source;
-			i2c-analog-filter;
-			status = "disabled";
-		};
-
-		rtc: rtc@5c004000 {
-			compatible = "st,stm32mp1-rtc";
-			reg = <0x5c004000 0x400>;
-			clocks = <&rcc RTCAPB>, <&rcc RTC>;
-			clock-names = "pclk", "rtc_ck";
-			interrupts-extended = <&exti 19 IRQ_TYPE_LEVEL_HIGH>;
-			status = "disabled";
-		};
-
-		bsec: efuse@5c005000 {
-			compatible = "st,stm32mp15-bsec";
-			reg = <0x5c005000 0x400>;
+		tamp: tamp@5c00a000 {
+			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
 			#address-cells = <1>;
 			#size-cells = <1>;
-			part_number_otp: part_number_otp@4 {
-				reg = <0x4 0x1>;
-			};
-			ts_cal1: calib@5c {
-				reg = <0x5c 0x2>;
-			};
-			ts_cal2: calib@5e {
-				reg = <0x5e 0x2>;
-			};
-		};
+			reg = <0x5c00a000 0x400>;
+			ranges;
 
-		i2c6: i2c@5c009000 {
-			compatible = "st,stm32mp15-i2c";
-			reg = <0x5c009000 0x400>;
-			interrupt-names = "event", "error";
-			interrupts = <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc I2C6_K>;
-			resets = <&rcc I2C6_R>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			st,syscfg-fmp = <&syscfg 0x4 0x20>;
-			wakeup-source;
-			i2c-analog-filter;
-			status = "disabled";
-		};
+			nvram: nvram@5c00a100 {
+				compatible = "st,stm32mp15-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x5c00a100 0x80>;
 
-		tamp: tamp@5c00a000 {
-			compatible = "st,stm32-tamp", "syscon", "simple-mfd";
-			reg = <0x5c00a000 0x400>;
-		};
+				wakeup_sec: tamp-bkp@0 {
+					reg = <0x0 0x4>;
+				};
 
-		/*
-		 * Break node order to solve dependency probe issue between
-		 * pinctrl and exti.
-		 */
-		pinctrl: pinctrl@50002000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp157-pinctrl";
-			ranges = <0 0x50002000 0xa400>;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
-			pins-are-numbered;
+				m4_security_perimeter_exti1: tamp-bkp@4 {
+					/* see cortex-m4 wake up feature */
+					reg = <0x4 0x4>;
+				};
 
-			gpioa: gpio@50002000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x0 0x400>;
-				clocks = <&rcc GPIOA>;
-				st,bank-name = "GPIOA";
-				status = "disabled";
-			};
+				m4_security_perimeter_exti2: tamp-bkp@8 {
+					/* see cortex-m4 wake up feature */
+					reg = <0x8 0x4>;
+				};
 
-			gpiob: gpio@50003000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x1000 0x400>;
-				clocks = <&rcc GPIOB>;
-				st,bank-name = "GPIOB";
-				status = "disabled";
-			};
+				m4_security_perimeter_exti3: tamp-bkp@c {
+					/* see cortex-m4 wtake up feature */
+					reg = <0xc 0x4>;
+				};
 
-			gpioc: gpio@50004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x2000 0x400>;
-				clocks = <&rcc GPIOC>;
-				st,bank-name = "GPIOC";
-				status = "disabled";
-			};
+				magic_number: tamp-bkp@10 {
+					/* see ddr and cpu wake up management feature */
+					reg = <0x10 0x4>;
+				};
 
-			gpiod: gpio@50005000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x3000 0x400>;
-				clocks = <&rcc GPIOD>;
-				st,bank-name = "GPIOD";
-				status = "disabled";
-			};
+				branch_address: tamp-bkp@14 {
+					/* see ddr and cpu wake up management feature */
+					reg = <0x14 0x4>;
+				};
 
-			gpioe: gpio@50006000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x4000 0x400>;
-				clocks = <&rcc GPIOE>;
-				st,bank-name = "GPIOE";
-				status = "disabled";
-			};
+				fwu_info: tamp-bkp@28 {
+					/* see firmware update info feature */
+					reg = <0x28 0x4>;
+				};
 
-			gpiof: gpio@50007000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x5000 0x400>;
-				clocks = <&rcc GPIOF>;
-				st,bank-name = "GPIOF";
-				status = "disabled";
-			};
+				copro_rsc_tbl_address: tamp-bkp@44 {
+					/* see cortex-m4 management feature */
+					reg = <0x44 0x4>;
+				};
 
-			gpiog: gpio@50008000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x6000 0x400>;
-				clocks = <&rcc GPIOG>;
-				st,bank-name = "GPIOG";
-				status = "disabled";
-			};
+				cortex_m_state: tamp-bkp@48 {
+					/* see cortex-m4 management feature */
+					reg = <0x48 0x4>;
+				};
 
-			gpioh: gpio@50009000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x7000 0x400>;
-				clocks = <&rcc GPIOH>;
-				st,bank-name = "GPIOH";
-				status = "disabled";
-			};
+				boot_mode: tamp-bkp@50 {
+					/* see boot mode selection feature */
+					reg = <0x50 0x4>;
+				};
 
-			gpioi: gpio@5000a000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x8000 0x400>;
-				clocks = <&rcc GPIOI>;
-				st,bank-name = "GPIOI";
-				status = "disabled";
-			};
+				boot_counter: tamp-bkp@54 {
+					/* see boot counter feature */
+					reg = <0x54 0x4>;
+				};
 
-			gpioj: gpio@5000b000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0x9000 0x400>;
-				clocks = <&rcc GPIOJ>;
-				st,bank-name = "GPIOJ";
-				status = "disabled";
-			};
+				m4_wakeup_area_start: tamp-bkp@58 {
+					/* see cortex-m4 wake up feature */
+					reg = <0x58 0x4>;
+				};
 
-			gpiok: gpio@5000c000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0xa000 0x400>;
-				clocks = <&rcc GPIOK>;
-				st,bank-name = "GPIOK";
-				status = "disabled";
-			};
-		};
+				m4_wakeup_area_length: tamp-bkp@5c {
+					/* see cortex-m4 wake up feature */
+					reg = <0x5c 0x4>;
+				};
 
-		pinctrl_z: pinctrl@54004000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "st,stm32mp157-z-pinctrl";
-			ranges = <0 0x54004000 0x400>;
-			pins-are-numbered;
-			interrupt-parent = <&exti>;
-			st,syscfg = <&exti 0x60 0xff>;
+				m4_wakeup_area_hash: tamp-bkp@60 {
+					/* SHA-0x100 value see Cortex-M4 wake up feature */
+					reg = <0x60 0x20>;
+				};
+			};
 
-			gpioz: gpio@54004000 {
-				gpio-controller;
-				#gpio-cells = <2>;
-				interrupt-controller;
-				#interrupt-cells = <2>;
-				reg = <0 0x400>;
-				clocks = <&rcc GPIOZ>;
-				st,bank-name = "GPIOZ";
-				st,bank-ioport = <11>;
-				status = "disabled";
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
 			};
 		};
 	};
@@ -1825,12 +2291,16 @@
 			      <0x30000000 0x40000>,
 			      <0x38000000 0x10000>;
 			resets = <&rcc MCU_R>;
-			st,syscfg-holdboot = <&rcc 0x10C 0x1>;
-			st,syscfg-tz = <&rcc 0x000 0x1>;
+			st,syscfg-holdboot = <&rcc 0x10c 0x1>;
 			st,syscfg-pdds = <&pwr_mcu 0x0 0x1>;
-			st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
-			st,syscfg-m4-state = <&tamp 0x148 0xFFFFFFFF>;
+			st,syscfg-rsc-tbl = <&tamp 0x144 0xffffffff>;
+			st,syscfg-cm-state = <&tamp 0x148 0xffffffff>;
 			status = "disabled";
+
+			m4_system_resources {
+				compatible = "rproc-srm-core";
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp153.dtsi b/arch/arm/dts/stm32mp153.dtsi
index 486084e0b8..e7faba5b04 100644
--- a/arch/arm/dts/stm32mp153.dtsi
+++ b/arch/arm/dts/stm32mp153.dtsi
@@ -10,9 +10,10 @@
 	cpus {
 		cpu1: cpu@1 {
 			compatible = "arm,cortex-a7";
-			clock-frequency = <650000000>;
 			device_type = "cpu";
 			reg = <1>;
+			clock-names = "cpu";
+			operating-points-v2 = <&cpu0_opp_table>;
 		};
 	};
 
@@ -30,30 +31,34 @@
 	};
 
 	soc {
-		m_can1: can@4400e000 {
-			compatible = "bosch,m_can";
-			reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
-			reg-names = "m_can", "message_ram";
-			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
-			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
-			status = "disabled";
-		};
+		etzpc: etzpc@5c007000 {
+			m_can1: can@4400e000 {
+				compatible = "bosch,m_can";
+				reg = <0x4400e000 0x400>, <0x44011000 0x1400>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_TT_FDCAN_ID>;
+				status = "disabled";
+			};
 
-		m_can2: can@4400f000 {
-			compatible = "bosch,m_can";
-			reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
-			reg-names = "m_can", "message_ram";
-			interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
-				     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
-			interrupt-names = "int0", "int1";
-			clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
-			clock-names = "hclk", "cclk";
-			bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
-			status = "disabled";
+			m_can2: can@4400f000 {
+				compatible = "bosch,m_can";
+				reg = <0x4400f000 0x400>, <0x44011000 0x2800>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_HSE>, <&rcc FDCAN_K>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+				feature-domains = <&etzpc STM32MP1_ETZPC_TT_FDCAN_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp157.dtsi b/arch/arm/dts/stm32mp157.dtsi
index 54e73ccea4..3756ee7eec 100644
--- a/arch/arm/dts/stm32mp157.dtsi
+++ b/arch/arm/dts/stm32mp157.dtsi
@@ -20,18 +20,12 @@
 		dsi: dsi@5a000000 {
 			compatible = "st,stm32-dsi";
 			reg = <0x5a000000 0x800>;
-			clocks = <&rcc DSI_K>, <&clk_hse>, <&rcc DSI_PX>;
+			phy-dsi-supply = <&reg18>;
+			clocks = <&rcc DSI>, <&clk_hse>, <&rcc DSI_PX>;
 			clock-names = "pclk", "ref", "px_clk";
 			resets = <&rcc DSI_R>;
 			reset-names = "apb";
-			#address-cells = <1>;
-			#size-cells = <0>;
 			status = "disabled";
-
-			ports {
-				#address-cells = <1>;
-				#size-cells = <0>;
-			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi
deleted file mode 100644
index 2db045e7ce..0000000000
--- a/arch/arm/dts/stm32mp157a-dk1-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-scmi-u-boot.dtsi"
-#include "stm32mp15-ddr3-1x4Gb-1066-binG.dtsi"
-
-/ {
-	aliases {
-		i2c3 = &i2c4;
-		usb0 = &usbotg_hs;
-	};
-
-	config {
-		u-boot,boot-led = "heartbeat";
-		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "u-boot-env";
-		st,adc_usb_pd = <&adc1 18>, <&adc1 19>;
-		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-	};
-
-	led {
-		red {
-			label = "error";
-			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
-		};
-	};
-};
-
-&adc {
-	status = "okay";
-};
-
-&uart4 {
-	u-boot,dm-pre-reloc;
-};
-
-&uart4_pins_a {
-	u-boot,dm-pre-reloc;
-	pins1 {
-		u-boot,dm-pre-reloc;
-	};
-	pins2 {
-		u-boot,dm-pre-reloc;
-		/* pull-up on rx to avoid floating level */
-		bias-pull-up;
-	};
-};
-
-&usbotg_hs {
-	u-boot,force-b-session-valid;
-};
diff --git a/arch/arm/dts/stm32mp157a-dk1-scmi.dts b/arch/arm/dts/stm32mp157a-dk1-scmi.dtsi
similarity index 79%
rename from arch/arm/dts/stm32mp157a-dk1-scmi.dts
rename to arch/arm/dts/stm32mp157a-dk1-scmi.dtsi
index e539cc80be..34fcf8c155 100644
--- a/arch/arm/dts/stm32mp157a-dk1-scmi.dts
+++ b/arch/arm/dts/stm32mp157a-dk1-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157a-dk1.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157A-DK1 SCMI Discovery Board";
-	compatible = "st,stm32mp157a-dk1-scmi", "st,stm32mp157a-dk1", "st,stm32mp157";
-
 	reserved-memory {
 		optee@de000000 {
 			reg = <0xde000000 0x2000000>;
@@ -30,7 +24,7 @@
 };
 
 &dsi {
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -47,10 +41,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
diff --git a/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
index 15a04ae927..2ceeafd024 100644
--- a/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi
@@ -1,58 +1,29 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-u-boot.dtsi"
-#include "stm32mp15-ddr3-1x4Gb-1066-binG.dtsi"
+#include "stm32mp15-scmi-u-boot.dtsi"
 
 / {
 	aliases {
 		i2c3 = &i2c4;
 		usb0 = &usbotg_hs;
 	};
+
 	config {
 		u-boot,boot-led = "heartbeat";
 		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "fip";
+		u-boot,mmc-env-partition = "u-boot-env";
 		st,adc_usb_pd = <&adc1 18>, <&adc1 19>;
 		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 	};
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE) || defined(CONFIG_SPL)
-	config {
-		u-boot,mmc-env-partition = "ssbl";
-	};
-#endif
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	/* only needed for boot with TF-A, witout FIP support */
-	firmware {
-		optee {
-			compatible = "linaro,optee-tz";
-			method = "smc";
-		};
-	};
-
-	reserved-memory {
-		u-boot,dm-spl;
-
-		optee@de000000 {
-			reg = <0xde000000 0x02000000>;
-			no-map;
-			u-boot,dm-spl;
-		};
-	};
-#endif
-
 	led {
-		red {
+		led-red {
 			label = "error";
 			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
 		};
 	};
 };
@@ -61,131 +32,6 @@
 	status = "okay";
 };
 
-&clk_hse {
-	st,digbypass;
-};
-
-&i2c4 {
-	u-boot,dm-pre-reloc;
-};
-
-&i2c4_pins_a {
-	u-boot,dm-pre-reloc;
-	pins {
-		u-boot,dm-pre-reloc;
-	};
-};
-
-&pmic {
-	u-boot,dm-pre-reloc;
-};
-
-&rcc {
-	st,clksrc = <
-		CLK_MPU_PLL1P
-		CLK_AXI_PLL2P
-		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
-		CLK_MCO1_DISABLED
-		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
-		CLK_CKPER_HSE
-		CLK_FMC_ACLK
-		CLK_QSPI_ACLK
-		CLK_ETH_DISABLED
-		CLK_SDMMC12_PLL4P
-		CLK_DSI_DSIPLL
-		CLK_STGEN_HSE
-		CLK_USBPHY_HSE
-		CLK_SPI2S1_PLL3Q
-		CLK_SPI2S23_PLL3Q
-		CLK_SPI45_HSI
-		CLK_SPI6_HSI
-		CLK_I2C46_HSI
-		CLK_SDMMC3_PLL4P
-		CLK_USBO_USBPHY
-		CLK_ADC_CKPER
-		CLK_CEC_LSE
-		CLK_I2C12_HSI
-		CLK_I2C35_HSI
-		CLK_UART1_HSI
-		CLK_UART24_HSI
-		CLK_UART35_HSI
-		CLK_UART6_HSI
-		CLK_UART78_HSI
-		CLK_SPDIF_PLL4P
-		CLK_FDCAN_PLL4R
-		CLK_SAI1_PLL3Q
-		CLK_SAI2_PLL3Q
-		CLK_SAI3_PLL3Q
-		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
-		CLK_RNG2_LSI
-		CLK_LPTIM1_PCLK1
-		CLK_LPTIM23_PCLK3
-		CLK_LPTIM45_LSE
-	>;
-
-	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
-	pll2: st,pll@1 {
-		compatible = "st,stm32mp1-pll";
-		reg = <1>;
-		cfg = < 2 65 1 0 0 PQR(1,1,1) >;
-		frac = < 0x1400 >;
-		u-boot,dm-pre-reloc;
-	};
-
-	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
-	pll3: st,pll@2 {
-		compatible = "st,stm32mp1-pll";
-		reg = <2>;
-		cfg = < 1 33 1 16 36 PQR(1,1,1) >;
-		frac = < 0x1a04 >;
-		u-boot,dm-pre-reloc;
-	};
-
-	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
-	pll4: st,pll@3 {
-		compatible = "st,stm32mp1-pll";
-		reg = <3>;
-		cfg = < 3 98 5 7 7 PQR(1,1,1) >;
-		u-boot,dm-pre-reloc;
-	};
-};
-
-&sdmmc1 {
-	u-boot,dm-spl;
-};
-
-&sdmmc1_b4_pins_a {
-	u-boot,dm-spl;
-	pins1 {
-		u-boot,dm-spl;
-	};
-	pins2 {
-		u-boot,dm-spl;
-	};
-};
-
 &uart4 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32mp157a-dk1.dts b/arch/arm/dts/stm32mp157a-dk1.dts
index 4c8be9c8eb..e262d22d4f 100644
--- a/arch/arm/dts/stm32mp157a-dk1.dts
+++ b/arch/arm/dts/stm32mp157a-dk1.dts
@@ -7,9 +7,11 @@
 /dts-v1/;
 
 #include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157a-dk1-scmi.dtsi"
 
 / {
 	model = "STMicroelectronics STM32MP157A-DK1 Discovery Board";
@@ -17,9 +19,6 @@
 
 	aliases {
 		ethernet0 = &ethernet0;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &uart7;
 	};
 
 	chosen {
diff --git a/arch/arm/dts/stm32mp157a-ed1-scmi.dtsi b/arch/arm/dts/stm32mp157a-ed1-scmi.dtsi
new file mode 100644
index 0000000000..c36fa23ff8
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ed1-scmi.dtsi
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15-scmi.dtsi"
+
+/ {
+	reserved-memory {
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi
new file mode 100644
index 0000000000..a447929c9f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ed1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ed1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157a-ed1.dts b/arch/arm/dts/stm32mp157a-ed1.dts
new file mode 100644
index 0000000000..578ca40647
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ed1.dts
@@ -0,0 +1,433 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xa.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157a-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter";
+	compatible = "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/dts/stm32mp157a-ev1-scmi.dtsi b/arch/arm/dts/stm32mp157a-ev1-scmi.dtsi
new file mode 100644
index 0000000000..0c79a2b3ed
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ev1-scmi.dtsi
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/ {
+	reserved-memory {
+		optee@fe000000 {
+			reg = <0xfe000000 0x2000000>;
+			no-map;
+		};
+	};
+};
+
+&cpu0 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&cpu1 {
+	clocks = <&scmi_clk CK_SCMI_MPU>;
+};
+
+&dsi {
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+};
+
+&gpioz {
+	clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+};
+
+&hash1 {
+	clocks = <&scmi_clk CK_SCMI_HASH1>;
+	resets = <&scmi_reset RST_SCMI_HASH1>;
+};
+
+&i2c4 {
+	clocks = <&scmi_clk CK_SCMI_I2C4>;
+	resets = <&scmi_reset RST_SCMI_I2C4>;
+};
+
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
+&iwdg2 {
+	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+};
+
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
+&m_can1 {
+	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
+};
+
+&mdma1 {
+	resets = <&scmi_reset RST_SCMI_MDMA>;
+};
+
+&mlahb {
+	resets = <&scmi_reset RST_SCMI_MCU>;
+};
+
+&rcc {
+	compatible = "st,stm32mp1-rcc-secure", "syscon";
+	clock-names = "hse", "hsi", "csi", "lse", "lsi";
+	clocks = <&scmi_clk CK_SCMI_HSE>,
+		 <&scmi_clk CK_SCMI_HSI>,
+		 <&scmi_clk CK_SCMI_CSI>,
+		 <&scmi_clk CK_SCMI_LSE>,
+		 <&scmi_clk CK_SCMI_LSI>;
+};
+
+&rng1 {
+	clocks = <&scmi_clk CK_SCMI_RNG1>;
+	resets = <&scmi_reset RST_SCMI_RNG1>;
+};
+
+&rtc {
+	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..7a8d2ae584
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ev1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ev1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157a-ev1.dts b/arch/arm/dts/stm32mp157a-ev1.dts
new file mode 100644
index 0000000000..c17d288ec9
--- /dev/null
+++ b/arch/arm/dts/stm32mp157a-ev1.dts
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157a-ed1.dts"
+#include "stm32mp157a-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157A eval daughter on eval mother";
+	compatible = "st,stm32mp157a-ev1", "st,stm32mp157a-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts b/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
index fae656edd8..355a2d0fcc 100644
--- a/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
+++ b/arch/arm/dts/stm32mp157a-microgea-stm32mp1-microdev2.0-of7.dts
@@ -81,8 +81,7 @@
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&panel_in>;
 		};
 	};
diff --git a/arch/arm/dts/stm32mp157c-dk2-scmi.dts b/arch/arm/dts/stm32mp157c-dk2-scmi.dtsi
similarity index 78%
rename from arch/arm/dts/stm32mp157c-dk2-scmi.dts
rename to arch/arm/dts/stm32mp157c-dk2-scmi.dtsi
index 97e4f94b0a..0b8bba427c 100644
--- a/arch/arm/dts/stm32mp157c-dk2-scmi.dts
+++ b/arch/arm/dts/stm32mp157c-dk2-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-dk2.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157C-DK2 SCMI Discovery Board";
-	compatible = "st,stm32mp157c-dk2-scmi", "st,stm32mp157c-dk2", "st,stm32mp157";
-
 	reserved-memory {
 		optee@de000000 {
 			reg = <0xde000000 0x2000000>;
@@ -35,8 +29,7 @@
 };
 
 &dsi {
-	phy-dsi-supply = <&scmi_reg18>;
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -53,10 +46,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
@@ -83,3 +88,7 @@
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi b/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi
index 06ef3a4095..329c48723a 100644
--- a/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-dk2-u-boot.dtsi
@@ -1,6 +1,17 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
 #include "stm32mp157a-dk1-u-boot.dtsi"
+
+/ {
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&sdmmc2 {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/stm32mp157c-dk2.dts b/arch/arm/dts/stm32mp157c-dk2.dts
index 2bc92ef3ae..55126617bf 100644
--- a/arch/arm/dts/stm32mp157c-dk2.dts
+++ b/arch/arm/dts/stm32mp157c-dk2.dts
@@ -11,6 +11,8 @@
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxac-pinctrl.dtsi"
 #include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157c-dk2-scmi.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
 
 / {
 	model = "STMicroelectronics STM32MP157C-DK2 Discovery Board";
@@ -18,14 +20,25 @@
 
 	aliases {
 		ethernet0 = &ethernet0;
-		serial0 = &uart4;
-		serial1 = &usart3;
-		serial2 = &uart7;
 		serial3 = &usart2;
 	};
 
 	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
 		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
 	};
 };
 
@@ -34,10 +47,14 @@
 };
 
 &dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
 	status = "okay";
-	phy-dsi-supply = <&reg18>;
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in: endpoint {
@@ -53,7 +70,7 @@
 		};
 	};
 
-	panel@0 {
+	panel_otm8009a: panel-otm8009a@0 {
 		compatible = "orisetech,otm8009a";
 		reg = <0>;
 		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
@@ -77,14 +94,21 @@
 		interrupt-controller;
 		touchscreen-size-x = <480>;
 		touchscreen-size-y = <800>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		panel = <&panel_otm8009a>;
 		status = "okay";
 	};
 };
 
 &ltdc {
+	default-on;
 	status = "okay";
 
 	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		ltdc_ep1_out: endpoint@1 {
 			reg = <1>;
 			remote-endpoint = <&dsi_in>;
@@ -92,10 +116,50 @@
 	};
 };
 
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-parent = <&gpiod>;
+		interrupts = <0 IRQ_TYPE_LEVEL_HIGH>; /* WL_HOST_WAKE */
+		interrupt-names = "host-wake";
+	};
+};
+
+/* Bluetooth */
 &usart2 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart2_pins_c>;
 	pinctrl-1 = <&usart2_sleep_pins_c>;
 	pinctrl-2 = <&usart2_idle_pins_c>;
-	status = "disabled";
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
 };
diff --git a/arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi
deleted file mode 100644
index 54662f7e29..0000000000
--- a/arch/arm/dts/stm32mp157c-ed1-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,47 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-scmi-u-boot.dtsi"
-#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
-
-/ {
-	aliases {
-		i2c3 = &i2c4;
-	};
-
-	config {
-		u-boot,boot-led = "heartbeat";
-		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "u-boot-env";
-		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
-	};
-
-	led {
-		red {
-			label = "error";
-			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
-		};
-	};
-};
-
-&uart4 {
-	u-boot,dm-pre-reloc;
-};
-
-&uart4_pins_a {
-	u-boot,dm-pre-reloc;
-	pins1 {
-		u-boot,dm-pre-reloc;
-	};
-	pins2 {
-		u-boot,dm-pre-reloc;
-		/* pull-up on rx to avoid floating level */
-		bias-pull-up;
-	};
-};
diff --git a/arch/arm/dts/stm32mp157c-ed1-scmi.dts b/arch/arm/dts/stm32mp157c-ed1-scmi.dtsi
similarity index 74%
rename from arch/arm/dts/stm32mp157c-ed1-scmi.dts
rename to arch/arm/dts/stm32mp157c-ed1-scmi.dtsi
index 9cf0a44d2f..a26929e696 100644
--- a/arch/arm/dts/stm32mp157c-ed1-scmi.dts
+++ b/arch/arm/dts/stm32mp157c-ed1-scmi.dtsi
@@ -4,15 +4,9 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-ed1.dts"
 #include "stm32mp15-scmi.dtsi"
 
 / {
-	model = "STMicroelectronics STM32MP157C-ED1 SCMI eval daughter";
-	compatible = "st,stm32mp157c-ed1-scmi", "st,stm32mp157c-ed1", "st,stm32mp157";
-
 	reserved-memory {
 		optee@fe000000 {
 			reg = <0xfe000000 0x2000000>;
@@ -35,7 +29,7 @@
 };
 
 &dsi {
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -52,10 +46,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &mdma1 {
 	resets = <&scmi_reset RST_SCMI_MDMA>;
 };
@@ -82,3 +88,12 @@
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&spi6 {
+	clocks = <&scmi_clk CK_SCMI_SPI6>;
+	resets = <&scmi_reset RST_SCMI_SPI6>;
+};
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
index 408abaf52f..47472eb688 100644
--- a/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-ed1-u-boot.dtsi
@@ -1,11 +1,9 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
-#include <dt-bindings/clock/stm32mp1-clksrc.h>
-#include "stm32mp15-u-boot.dtsi"
-#include "stm32mp15-ddr3-2x4Gb-1066-binG.dtsi"
+#include "stm32mp15-scmi-u-boot.dtsi"
 
 / {
 	aliases {
@@ -15,200 +13,19 @@
 	config {
 		u-boot,boot-led = "heartbeat";
 		u-boot,error-led = "error";
-		u-boot,mmc-env-partition = "fip";
+		u-boot,mmc-env-partition = "u-boot-env";
 		st,fastboot-gpios = <&gpioa 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 		st,stm32prog-gpios = <&gpioa 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
 	};
 
-#if defined(CONFIG_STM32MP15x_STM32IMAGE) || defined(CONFIG_SPL)
-	config {
-		u-boot,mmc-env-partition = "ssbl";
-	};
-#endif
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	/* only needed for boot with TF-A, witout FIP support */
-	firmware {
-		optee {
-			compatible = "linaro,optee-tz";
-			method = "smc";
-		};
-	};
-
-	reserved-memory {
-		optee@fe000000 {
-			reg = <0xfe000000 0x02000000>;
-			no-map;
-		};
-	};
-#endif
-
 	led {
-		red {
+		led-red {
 			label = "error";
 			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
-			default-state = "off";
-			status = "okay";
 		};
 	};
 };
 
-&clk_hse {
-	st,digbypass;
-};
-
-&i2c4 {
-	u-boot,dm-pre-reloc;
-};
-
-&i2c4_pins_a {
-	u-boot,dm-pre-reloc;
-	pins {
-		u-boot,dm-pre-reloc;
-	};
-};
-
-&pmic {
-	u-boot,dm-pre-reloc;
-};
-
-&rcc {
-	st,clksrc = <
-		CLK_MPU_PLL1P
-		CLK_AXI_PLL2P
-		CLK_MCU_PLL3P
-		CLK_PLL12_HSE
-		CLK_PLL3_HSE
-		CLK_PLL4_HSE
-		CLK_RTC_LSE
-		CLK_MCO1_DISABLED
-		CLK_MCO2_DISABLED
-	>;
-
-	st,clkdiv = <
-		1 /*MPU*/
-		0 /*AXI*/
-		0 /*MCU*/
-		1 /*APB1*/
-		1 /*APB2*/
-		1 /*APB3*/
-		1 /*APB4*/
-		2 /*APB5*/
-		23 /*RTC*/
-		0 /*MCO1*/
-		0 /*MCO2*/
-	>;
-
-	st,pkcs = <
-		CLK_CKPER_HSE
-		CLK_FMC_ACLK
-		CLK_QSPI_ACLK
-		CLK_ETH_DISABLED
-		CLK_SDMMC12_PLL4P
-		CLK_DSI_DSIPLL
-		CLK_STGEN_HSE
-		CLK_USBPHY_HSE
-		CLK_SPI2S1_PLL3Q
-		CLK_SPI2S23_PLL3Q
-		CLK_SPI45_HSI
-		CLK_SPI6_HSI
-		CLK_I2C46_HSI
-		CLK_SDMMC3_PLL4P
-		CLK_USBO_USBPHY
-		CLK_ADC_CKPER
-		CLK_CEC_LSE
-		CLK_I2C12_HSI
-		CLK_I2C35_HSI
-		CLK_UART1_HSI
-		CLK_UART24_HSI
-		CLK_UART35_HSI
-		CLK_UART6_HSI
-		CLK_UART78_HSI
-		CLK_SPDIF_PLL4P
-		CLK_FDCAN_PLL4R
-		CLK_SAI1_PLL3Q
-		CLK_SAI2_PLL3Q
-		CLK_SAI3_PLL3Q
-		CLK_SAI4_PLL3Q
-		CLK_RNG1_LSI
-		CLK_RNG2_LSI
-		CLK_LPTIM1_PCLK1
-		CLK_LPTIM23_PCLK3
-		CLK_LPTIM45_LSE
-	>;
-
-	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
-	pll2: st,pll@1 {
-		compatible = "st,stm32mp1-pll";
-		reg = <1>;
-		cfg = < 2 65 1 0 0 PQR(1,1,1) >;
-		frac = < 0x1400 >;
-		u-boot,dm-pre-reloc;
-	};
-
-	/* VCO = 417.8 MHz => P = 209, Q = 24, R = 11 */
-	pll3: st,pll@2 {
-		compatible = "st,stm32mp1-pll";
-		reg = <2>;
-		cfg = < 1 33 1 16 36 PQR(1,1,1) >;
-		frac = < 0x1a04 >;
-		u-boot,dm-pre-reloc;
-	};
-
-	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 74 */
-	pll4: st,pll@3 {
-		compatible = "st,stm32mp1-pll";
-		reg = <3>;
-		cfg = < 3 98 5 7 7 PQR(1,1,1) >;
-		u-boot,dm-pre-reloc;
-	};
-};
-
-&sdmmc1 {
-	u-boot,dm-spl;
-};
-
-&sdmmc1_b4_pins_a {
-	u-boot,dm-spl;
-	pins1 {
-		u-boot,dm-spl;
-	};
-	pins2 {
-		u-boot,dm-spl;
-	};
-};
-
-&sdmmc1_dir_pins_a {
-	u-boot,dm-spl;
-	pins1 {
-		u-boot,dm-spl;
-	};
-	pins2 {
-		u-boot,dm-spl;
-	};
-};
-
-&sdmmc2 {
-	u-boot,dm-spl;
-};
-
-&sdmmc2_b4_pins_a {
-	u-boot,dm-spl;
-	pins1 {
-		u-boot,dm-spl;
-	};
-	pins2 {
-		u-boot,dm-spl;
-	};
-};
-
-&sdmmc2_d47_pins_a {
-	u-boot,dm-spl;
-	pins {
-		u-boot,dm-spl;
-	};
-};
-
 &uart4 {
 	u-boot,dm-pre-reloc;
 };
diff --git a/arch/arm/dts/stm32mp157c-ed1.dts b/arch/arm/dts/stm32mp157c-ed1.dts
index fe5c8f25ce..849227aa47 100644
--- a/arch/arm/dts/stm32mp157c-ed1.dts
+++ b/arch/arm/dts/stm32mp157c-ed1.dts
@@ -9,6 +9,9 @@
 #include "stm32mp15xc.dtsi"
 #include "stm32mp15-pinctrl.dtsi"
 #include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157c-ed1-scmi.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
 
@@ -16,13 +19,17 @@
 	model = "STMicroelectronics STM32MP157C eval daughter";
 	compatible = "st,stm32mp157c-ed1", "st,stm32mp157";
 
+	aliases {
+		serial0 = &uart4;
+	};
+
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
 
 	memory@c0000000 {
 		device_type = "memory";
-		reg = <0xC0000000 0x40000000>;
+		reg = <0xc0000000 0x40000000>;
 	};
 
 	reserved-memory {
@@ -54,6 +61,12 @@
 			no-map;
 		};
 
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -70,13 +83,28 @@
 			reg = <0xe8000000 0x8000000>;
 			no-map;
 		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
 	};
 
-	aliases {
-		serial0 = &uart4;
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
 	};
 
-	sd_switch: regulator-sd_switch {
+	sd_switch: regulator-sd-switch {
 		compatible = "regulator-gpio";
 		regulator-name = "sd_switch";
 		regulator-min-microvolt = <1800000>;
@@ -108,18 +136,33 @@
 	vref-supply = <&vdda>;
 	status = "disabled";
 	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		/* 16.5 ck_cycles sampling time */
-		st,min-sample-time-nsecs = <400>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
 	};
 };
 
-&cpu0{
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
 	cpu-supply = <&vddcore>;
 };
 
-&cpu1{
+&cpu1 {
 	cpu-supply = <&vddcore>;
 };
 
@@ -171,7 +214,7 @@
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -272,7 +315,7 @@
 				interrupts = <IT_CURLIM_LDO6 0>;
 			};
 
-			vref_ddr: vref_ddr {
+			vref_ddr: vref-ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 			};
@@ -282,16 +325,16 @@
 				interrupts = <IT_OCP_BOOST 0>;
 			};
 
-			vbus_otg: pwr_sw1 {
+			vbus_otg: pwr-sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr-sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
-			 };
+			};
 		};
 
 		onkey {
@@ -313,18 +356,14 @@
 	status = "okay";
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -333,10 +372,6 @@
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
diff --git a/arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi
deleted file mode 100644
index 71a94f9130..0000000000
--- a/arch/arm/dts/stm32mp157c-ev1-scmi-u-boot.dtsi
+++ /dev/null
@@ -1,17 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
-/*
- * Copyright : STMicroelectronics 2022
- */
-
-#include "stm32mp157c-ed1-scmi-u-boot.dtsi"
-
-/ {
-	aliases {
-		gpio26 = &stmfx_pinctrl;
-		i2c1 = &i2c2;
-		i2c4 = &i2c5;
-		pinctrl2 = &stmfx_pinctrl;
-		spi0 = &qspi;
-		usb0 = &usbotg_hs;
-	};
-};
diff --git a/arch/arm/dts/stm32mp157c-ev1-scmi.dts b/arch/arm/dts/stm32mp157c-ev1-scmi.dtsi
similarity index 78%
rename from arch/arm/dts/stm32mp157c-ev1-scmi.dts
rename to arch/arm/dts/stm32mp157c-ev1-scmi.dtsi
index 3b9dd6f4cc..b682649ebe 100644
--- a/arch/arm/dts/stm32mp157c-ev1-scmi.dts
+++ b/arch/arm/dts/stm32mp157c-ev1-scmi.dtsi
@@ -4,16 +4,7 @@
  * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
  */
 
-/dts-v1/;
-
-#include "stm32mp157c-ev1.dts"
-#include "stm32mp15-scmi.dtsi"
-
 / {
-	model = "STMicroelectronics STM32MP157C-EV1 SCMI eval daughter on eval mother";
-	compatible = "st,stm32mp157c-ev1-scmi", "st,stm32mp157c-ev1", "st,stm32mp157c-ed1",
-		     "st,stm32mp157";
-
 	reserved-memory {
 		optee@fe000000 {
 			reg = <0xfe000000 0x2000000>;
@@ -36,8 +27,7 @@
 };
 
 &dsi {
-	phy-dsi-supply = <&scmi_reg18>;
-	clocks = <&rcc DSI_K>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
+	clocks = <&rcc DSI>, <&scmi_clk CK_SCMI_HSE>, <&rcc DSI_PX>;
 };
 
 &gpioz {
@@ -54,10 +44,22 @@
 	resets = <&scmi_reset RST_SCMI_I2C4>;
 };
 
+&i2c6 {
+	clocks = <&scmi_clk CK_SCMI_I2C6>;
+	resets = <&scmi_reset RST_SCMI_I2C6>;
+};
+
 &iwdg2 {
 	clocks = <&rcc IWDG2>, <&scmi_clk CK_SCMI_LSI>;
 };
 
+&m4_rproc {
+	resets = <&scmi_reset RST_SCMI_MCU>,
+		 <&scmi_reset RST_SCMI_MCU_HOLD_BOOT>;
+	reset-names = "mcu_rst", "hold_boot";
+	/delete-property/ st,syscfg-holdboot;
+};
+
 &m_can1 {
 	clocks = <&scmi_clk CK_SCMI_HSE>, <&rcc FDCAN_K>;
 };
@@ -88,3 +90,7 @@
 &rtc {
 	clocks = <&scmi_clk CK_SCMI_RTCAPB>, <&scmi_clk CK_SCMI_RTC>;
 };
+
+&usart1 {
+	clocks = <&scmi_clk CK_SCMI_USART1>;
+};
diff --git a/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
index ec60486f41..c8cbc4232d 100644
--- a/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi
@@ -1,6 +1,6 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
 /*
- * Copyright : STMicroelectronics 2018
+ * Copyright : STMicroelectronics 2022
  */
 
 #include "stm32mp157c-ed1-u-boot.dtsi"
@@ -14,40 +14,99 @@
 		spi0 = &qspi;
 		usb0 = &usbotg_hs;
 	};
-};
 
-&flash0 {
-	u-boot,dm-spl;
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
 };
 
-&qspi {
-	u-boot,dm-spl;
-};
+&flash0 {
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
 
-&qspi_clk_pins_a {
-	u-boot,dm-spl;
-	pins {
-		u-boot,dm-spl;
+		partition@0 {
+			label = "fsbl1";
+			reg = <0x00000000 0x00040000>;
+		};
+		partition@40000 {
+			label = "fsbl2";
+			reg = <0x00040000 0x00040000>;
+		};
+		partition@80000 {
+			label = "metadata1";
+			reg = <0x00080000 0x00040000>;
+		};
+		partition@c0000 {
+			label = "metadata2";
+			reg = <0x000c0000 0x00040000>;
+		};
+		partition@100000 {
+			label = "fip-a";
+			reg = <0x00100000 0x00400000>;
+		};
+		partition@500000 {
+			label = "fip-b";
+			reg = <0x00500000 0x00400000>;
+		};
+		partition@900000 {
+			label = "u-boot-env";
+			reg = <0x00900000 0x00080000>;
+		};
+		partition@980000 {
+			label = "nor-user";
+			reg = <0x00980000 0x03680000>;
+		};
 	};
 };
 
-&qspi_bk1_pins_a {
-	u-boot,dm-spl;
-	pins1 {
-		u-boot,dm-spl;
-	};
-	pins2 {
-		u-boot,dm-spl;
-	};
-};
+&fmc {
+	nand-controller@4,0 {
+		nand@0 {
+			partitions {
+				compatible = "fixed-partitions";
+				#address-cells = <1>;
+				#size-cells = <1>;
 
-&qspi_bk2_pins_a {
-	u-boot,dm-spl;
-	pins1 {
-		u-boot,dm-spl;
-	};
-	pins2 {
-		u-boot,dm-spl;
+				partition@0 {
+					label = "fsbl1";
+					reg = <0x00000000 0x00080000>;
+				};
+				partition@80000 {
+					label = "fsbl2";
+					reg = <0x00080000 0x00080000>;
+				};
+				partition@100000 {
+					label = "metadata1";
+					reg = <0x00100000 0x00080000>;
+				};
+				partition@180000 {
+					label = "metadata2";
+					reg = <0x00180000 0x00080000>;
+				};
+				partition@200000 {
+					label = "fip-a1";
+					reg = <0x00200000 0x00400000>;
+				};
+				partition@600000 {
+					label = "fip-a2";
+					reg = <0x00600000 0x00400000>;
+				};
+				partition@a00000 {
+					label = "fip-b1";
+					reg = <0x00a00000 0x00400000>;
+				};
+				partition@e00000 {
+					label = "fip-b2";
+					reg = <0x00e00000 0x00400000>;
+				};
+				partition@1200000 {
+					label = "UBI";
+					reg = <0x01200000 0x3ee00000>;
+				};
+			};
+		};
 	};
 };
-
diff --git a/arch/arm/dts/stm32mp157c-ev1.dts b/arch/arm/dts/stm32mp157c-ev1.dts
index d142dd30e1..ac37098b95 100644
--- a/arch/arm/dts/stm32mp157c-ev1.dts
+++ b/arch/arm/dts/stm32mp157c-ev1.dts
@@ -6,6 +6,7 @@
 /dts-v1/;
 
 #include "stm32mp157c-ed1.dts"
+#include "stm32mp157c-ev1-scmi.dtsi"
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 
@@ -13,16 +14,25 @@
 	model = "STMicroelectronics STM32MP157C eval daughter on eval mother";
 	compatible = "st,stm32mp157c-ev1", "st,stm32mp157c-ed1", "st,stm32mp157";
 
-	chosen {
-		stdout-path = "serial0:115200n8";
-	};
-
 	aliases {
-		serial0 = &uart4;
 		serial1 = &usart3;
+		serial4 = &usart1;
 		ethernet0 = &ethernet0;
 	};
 
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
 	clocks {
 		clk_ext_camera: clk-ext-camera {
 			#clock-cells = <0>;
@@ -31,6 +41,54 @@
 		};
 	};
 
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
 	joystick {
 		compatible = "gpio-keys";
 		pinctrl-0 = <&joystick_pins>;
@@ -71,8 +129,45 @@
 		compatible = "gpio-backlight";
 		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
 		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
 		status = "okay";
 	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
 };
 
 &cec {
@@ -86,6 +181,14 @@
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&dcmi_pins_a>;
 	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
 
 	port {
 		dcmi_0: endpoint {
@@ -95,15 +198,128 @@
 			hsync-active = <0>;
 			vsync-active = <0>;
 			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
 		};
 	};
 };
 
 &dsi {
-	phy-dsi-supply = <&reg18>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	default-on;
 	status = "okay";
 
 	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
 		port@0 {
 			reg = <0>;
 			dsi_in: endpoint {
@@ -119,7 +335,7 @@
 		};
 	};
 
-	panel-dsi@0 {
+	panel_dsi: panel-dsi@0 {
 		compatible = "raydium,rm68200";
 		reg = <0>;
 		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
@@ -144,7 +360,7 @@
 	max-speed = <1000>;
 	phy-handle = <&phy0>;
 
-	mdio0 {
+	mdio {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "snps,dwmac-mdio";
@@ -178,8 +394,52 @@
 	pinctrl-1 = <&i2c2_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
 	ov5640: camera@3c {
 		compatible = "ovti,ov5640";
 		reg = <0x3c>;
@@ -199,6 +459,7 @@
 				hsync-active = <0>;
 				vsync-active = <0>;
 				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
 			};
 		};
 	};
@@ -218,12 +479,41 @@
 			#interrupt-cells = <2>;
 			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
 
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
 			joystick_pins: joystick-pins {
 				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
 				bias-pull-down;
 			};
 		};
 	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
 };
 
 &i2c5 {
@@ -232,15 +522,17 @@
 	pinctrl-1 = <&i2c5_sleep_pins_a>;
 	i2c-scl-rising-time-ns = <185>;
 	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
 	status = "okay";
 };
 
 &ltdc {
+	default-on;
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&dsi_in>;
 		};
 	};
@@ -255,8 +547,16 @@
 
 &qspi {
 	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a &qspi_bk2_pins_a>;
-	pinctrl-1 = <&qspi_clk_sleep_pins_a &qspi_bk1_sleep_pins_a &qspi_bk2_sleep_pins_a>;
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
 	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
 	#address-cells = <1>;
 	#size-cells = <0>;
@@ -281,6 +581,65 @@
 	};
 };
 
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
 &sdmmc3 {
 	pinctrl-names = "default", "opendrain", "sleep";
 	pinctrl-0 = <&sdmmc3_b4_pins_a>;
@@ -293,17 +652,41 @@
 	status = "disabled";
 };
 
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
 &spi1 {
-	pinctrl-names = "default";
+	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
 	status = "disabled";
 };
 
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
 &timers2 {
 	/* spare dmas for other usage (un-delete to enable pwm capture) */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm2_pins_a>;
 		pinctrl-1 = <&pwm2_sleep_pins_a>;
@@ -319,6 +702,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm8_pins_a>;
 		pinctrl-1 = <&pwm8_sleep_pins_a>;
@@ -334,6 +720,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
 		pinctrl-1 = <&pwm12_sleep_pins_a>;
@@ -345,6 +734,16 @@
 	};
 };
 
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
 &usart3 {
 	pinctrl-names = "default", "sleep", "idle";
 	pinctrl-0 = <&usart3_pins_b>;
@@ -362,6 +761,14 @@
 &usbh_ehci {
 	phys = <&usbphyc_port0>;
 	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
 };
 
 &usbotg_hs {
@@ -385,6 +792,10 @@
 	st,tune-squelch-level = <3>;
 	st,tune-hs-rx-offset = <2>;
 	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
 };
 
 &usbphyc_port1 {
diff --git a/arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi b/arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi
similarity index 71%
rename from arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi
rename to arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi
index 5a8fc15ab2..41f36278b6 100644
--- a/arch/arm/dts/stm32mp157c-dk2-scmi-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp157d-dk1-u-boot.dtsi
@@ -3,4 +3,4 @@
  * Copyright : STMicroelectronics 2022
  */
 
-#include "stm32mp157a-dk1-scmi-u-boot.dtsi"
+#include "stm32mp157a-dk1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157d-dk1.dts b/arch/arm/dts/stm32mp157d-dk1.dts
new file mode 100644
index 0000000000..4bc9fc868e
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-dk1.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157a-dk1-scmi.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP157D-DK1 Discovery Board";
+	compatible = "st,stm32mp157d-dk1", "st,stm32mp157";
+
+	aliases {
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
diff --git a/arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi
new file mode 100644
index 0000000000..a447929c9f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ed1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ed1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157d-ed1.dts b/arch/arm/dts/stm32mp157d-ed1.dts
new file mode 100644
index 0000000000..0584b6adbf
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ed1.dts
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xd.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157a-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter";
+	compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..7a8d2ae584
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ev1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ev1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157d-ev1.dts b/arch/arm/dts/stm32mp157d-ev1.dts
new file mode 100644
index 0000000000..730b466d6a
--- /dev/null
+++ b/arch/arm/dts/stm32mp157d-ev1.dts
@@ -0,0 +1,798 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157d-ed1.dts"
+#include "stm32mp157a-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157D eval daughter on eval mother";
+	compatible = "st,stm32mp157d-ev1", "st,stm32mp157d-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi b/arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi
new file mode 100644
index 0000000000..53133e98ba
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-dk2-u-boot.dtsi
@@ -0,0 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2022
+ */
+
+#include "stm32mp157a-dk1-u-boot.dtsi"
+
+&sdmmc2 {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/stm32mp157f-dk2.dts b/arch/arm/dts/stm32mp157f-dk2.dts
new file mode 100644
index 0000000000..f18aa8c35f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-dk2.dts
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxac-pinctrl.dtsi"
+#include "stm32mp15xx-dkx.dtsi"
+#include "stm32mp157c-dk2-scmi.dtsi"
+#include <dt-bindings/rtc/rtc-stm32.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F-DK2 Discovery Board";
+	compatible = "st,stm32mp157f-dk2", "st,stm32mp157";
+
+	aliases {
+		serial3 = &usart2;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpioh 4 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+
+	panel_otm8009a: panel-otm8009a@0 {
+		compatible = "orisetech,otm8009a";
+		reg = <0>;
+		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&hdp {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&hdp2_gpo &hdp2_pins_a>;
+	pinctrl-1 = <&hdp2_sleep_pins_a>;
+	status = "disabled";
+};
+
+&i2c1 {
+	touchscreen@38 {
+		compatible = "focaltech,ft6236";
+		reg = <0x38>;
+		interrupts = <2 2>;
+		interrupt-parent = <&gpiof>;
+		interrupt-controller;
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <800>;
+		vcc-supply = <&v3v3>;
+		iovcc-supply = <&v3v3>;
+		panel = <&panel_otm8009a>;
+		status = "okay";
+	};
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+};
+
+/* Wifi */
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-parent = <&gpiod>;
+		interrupts = <0 IRQ_TYPE_LEVEL_HIGH>; /* WL_HOST_WAKE */
+		interrupt-names = "host-wake";
+	};
+};
+
+/* Bluetooth */
+&usart2 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart2_pins_c>;
+	pinctrl-1 = <&usart2_sleep_pins_c>;
+	pinctrl-2 = <&usart2_idle_pins_c>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpioz 6 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&v3v3>;
+		vddio-supply = <&v3v3>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi b/arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi
new file mode 100644
index 0000000000..a447929c9f
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ed1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ed1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157f-ed1.dts b/arch/arm/dts/stm32mp157f-ed1.dts
new file mode 100644
index 0000000000..127af532e1
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ed1.dts
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157.dtsi"
+#include "stm32mp15xf.dtsi"
+#include "stm32mp15-pinctrl.dtsi"
+#include "stm32mp15xxaa-pinctrl.dtsi"
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
+#include "stm32mp157c-ed1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter";
+	compatible = "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	aliases {
+		serial0 = &uart4;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@c0000000 {
+		device_type = "memory";
+		reg = <0xc0000000 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		mcuram2: mcuram2@10000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10000000 0x40000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@10040000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10040000 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@10041000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10041000 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@10042000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10042000 0x4000>;
+			no-map;
+		};
+
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
+		mcuram: mcuram@30000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x30000000 0x40000>;
+			no-map;
+		};
+
+		retram: retram@38000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x38000000 0x10000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu@e8000000 {
+			reg = <0xe8000000 0x8000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x8000000>;
+			alignment = <0x2000>;
+			linux,cma-default;
+		};
+	};
+
+	led {
+		compatible = "gpio-leds";
+		led-blue {
+			label = "heartbeat";
+			gpios = <&gpiod 9 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	sd_switch: regulator-sd-switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpiof 14 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+
+	vin: vin {
+		compatible = "regulator-fixed";
+		regulator-name = "vin";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&adc {
+	/* ANA0, ANA1 are dedicated pins and don't need pinctrl: only in6. */
+	pinctrl-0 = <&adc1_in6_pins_a>;
+	pinctrl-names = "default";
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	adc1: adc@0 {
+		status = "okay";
+		channel@0 {
+			reg = <0>;
+			/* 16.5 ck_cycles sampling time */
+			st,min-sample-time-ns = <400>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <400>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <400>;
+		};
+	};
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vddcore>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcore>;
+};
+
+&crc1 {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&dac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dac_ch1_pins_a &dac_ch2_pins_a>;
+	vref-supply = <&vdda>;
+	status = "disabled";
+	dac1: dac@1 {
+		status = "okay";
+	};
+	dac2: dac@2 {
+		status = "okay";
+	};
+};
+
+&dts {
+	status = "okay";
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+};
+
+&hash1 {
+	status = "okay";
+};
+
+&i2c4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c4_pins_a>;
+	pinctrl-1 = <&i2c4_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			buck1-supply = <&vin>;
+			buck2-supply = <&vin>;
+			buck3-supply = <&vin>;
+			buck4-supply = <&vin>;
+			ldo1-supply = <&v3v3>;
+			ldo2-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo4-supply = <&vin>;
+			ldo5-supply = <&v3v3>;
+			ldo6-supply = <&v3v3>;
+			vref_ddr-supply = <&vin>;
+			boost-supply = <&vin>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			vdda: ldo1 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v2v8: ldo2 {
+				regulator-name = "v2v8";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdd_sd: ldo5 {
+				regulator-name = "vdd_sd";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v8: ldo6 {
+				regulator-name = "v1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref-ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr-sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr-sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge = <1>;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+			status = "okay";
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+};
+
+&ipcc {
+	status = "okay";
+};
+
+&m4_rproc {
+	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
+	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
+	mbox-names = "vq0", "vq1", "shutdown", "detach";
+	interrupt-parent = <&exti>;
+	interrupts = <68 1>;
+	wakeup-source;
+	status = "okay";
+};
+
+&pwr_regulators {
+	vdd-supply = <&vdd>;
+	vdd_3v3_usbfs-supply = <&vdd_usb>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_a>;
+	cd-gpios = <&gpiog 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&vdd>;
+	mmc-ddr-3_3v;
+	status = "okay";
+};
+
+&timers6 {
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	timer@5 {
+		status = "okay";
+	};
+};
+
+&uart4 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&uart4_pins_a>;
+	pinctrl-1 = <&uart4_sleep_pins_a>;
+	pinctrl-2 = <&uart4_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbotg_hs {
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
diff --git a/arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..7a8d2ae584
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ev1-u-boot.dtsi
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2018
+ */
+
+#include "stm32mp157c-ev1-u-boot.dtsi"
diff --git a/arch/arm/dts/stm32mp157f-ev1.dts b/arch/arm/dts/stm32mp157f-ev1.dts
new file mode 100644
index 0000000000..fb8051fab9
--- /dev/null
+++ b/arch/arm/dts/stm32mp157f-ev1.dts
@@ -0,0 +1,811 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+/dts-v1/;
+
+#include "stm32mp157f-ed1.dts"
+#include "stm32mp157c-ev1-scmi.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "STMicroelectronics STM32MP157F eval daughter on eval mother";
+	compatible = "st,stm32mp157f-ev1", "st,stm32mp157f-ed1", "st,stm32mp157";
+
+	aliases {
+		serial1 = &usart3;
+		serial4 = &usart1;
+		ethernet0 = &ethernet0;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0:115200n8";
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc LTDC_PX>, <&rcc DSI>, <&rcc DSI_PX>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint1>;
+			};
+		};
+	};
+
+	dmic2: dmic-2 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic2";
+
+		port {
+			dmic2_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint2>;
+			};
+		};
+	};
+
+	dmic3: dmic-3 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic3";
+
+		port {
+			dmic3_endpoint: endpoint {
+				remote-endpoint = <&dfsdm_endpoint3>;
+			};
+		};
+	};
+
+	joystick {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&joystick_pins>;
+		pinctrl-names = "default";
+		button-0 {
+			label = "JoySel";
+			linux,code = <KEY_ENTER>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <0 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-1 {
+			label = "JoyDown";
+			linux,code = <KEY_DOWN>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <1 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-2 {
+			label = "JoyLeft";
+			linux,code = <KEY_LEFT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <2 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-3 {
+			label = "JoyRight";
+			linux,code = <KEY_RIGHT>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+		};
+		button-4 {
+			label = "JoyUp";
+			linux,code = <KEY_UP>;
+			interrupt-parent = <&stmfx_pinctrl>;
+			interrupts = <4 IRQ_TYPE_EDGE_RISING>;
+		};
+	};
+
+	panel_backlight: panel-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpiod 13 GPIO_ACTIVE_LOW>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP15-EV";
+		routing =
+			"AIF1CLK" , "MCLK1",
+			"AIF2CLK" , "MCLK1",
+			"IN1LN" , "MICBIAS2",
+			"DMIC2DAT" , "MICBIAS1",
+			"DMIC1DAT" , "MICBIAS1";
+		dais = <&sai2a_port &sai2b_port &sai4a_port &spdifrx_port
+			&dfsdm0_port &dfsdm1_port &dfsdm2_port &dfsdm3_port>;
+		status = "okay";
+	};
+
+	spdif_in: spdif-in {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dir";
+
+		spdif_in_port: port {
+			spdif_in_endpoint: endpoint {
+				remote-endpoint = <&spdifrx_endpoint>;
+			};
+		};
+	};
+
+	spdif_out: spdif-out {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+
+		spdif_out_port: port {
+			spdif_out_endpoint: endpoint {
+				remote-endpoint = <&sai4a_endpoint>;
+			};
+		};
+	};
+};
+
+&cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cec_pins_a>;
+	status = "okay";
+};
+
+&dcmi {
+	status = "okay";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dcmi_pins_a>;
+	pinctrl-1 = <&dcmi_sleep_pins_a>;
+
+	/*
+	 * Enable DMA-MDMA chaining by adding a SRAM pool and
+	 * a MDMA channel
+	 */
+	sram = <&dcmi_pool>;
+
+	dmas = <&dmamux1 75 0x400 0x01>, <&mdma1 0 0x3 0x1200000a 0 0>;
+	dma-names = "tx", "mdma_tx";
+
+	port {
+		dcmi_0: endpoint {
+			remote-endpoint = <&ov5640_0>;
+			bus-type = <5>;
+			bus-width = <8>;
+			hsync-active = <0>;
+			vsync-active = <0>;
+			pclk-sample = <1>;
+			pclk-max-frequency = <77000000>;
+		};
+	};
+};
+
+&dfsdm {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&dfsdm_clkout_pins_a
+		     &dfsdm_data1_pins_a &dfsdm_data3_pins_a>;
+	pinctrl-1 = <&dfsdm_clkout_sleep_pins_a
+		     &dfsdm_data1_sleep_pins_a &dfsdm_data3_sleep_pins_a>;
+	spi-max-frequency = <2048000>;
+
+	clocks = <&rcc DFSDM_K>, <&rcc ADFSDM_K>;
+	clock-names = "dfsdm", "audio";
+	status = "okay";
+
+	dfsdm0: filter@0 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <3>;
+		st,adc-channel-names = "dmic_u1";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm0: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm0 0>;
+			status = "okay";
+
+			dfsdm0_port: port {
+				dfsdm_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm1: filter@1 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <0>;
+		st,adc-channel-names = "dmic_u2";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		st,adc-alt-channel = <1>;
+		status = "okay";
+
+		asoc_pdm1: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm1 0>;
+			status = "okay";
+
+			dfsdm1_port: port {
+				dfsdm_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm2: filter@2 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <2>;
+		st,adc-channel-names = "dmic_u3";
+		st,adc-channel-types = "SPI_F";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,adc-alt-channel = <1>;
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm2: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm2 0>;
+			status = "okay";
+
+			dfsdm2_port: port {
+				dfsdm_endpoint2: endpoint {
+					remote-endpoint = <&dmic2_endpoint>;
+				};
+			};
+		};
+	};
+
+	dfsdm3: filter@3 {
+		compatible = "st,stm32-dfsdm-dmic";
+		st,adc-channels = <1>;
+		st,adc-channel-names = "dmic_u4";
+		st,adc-channel-types = "SPI_R";
+		st,adc-channel-clk-src = "CLKOUT";
+		st,filter-order = <3>;
+		status = "okay";
+
+		asoc_pdm3: dfsdm-dai {
+			compatible = "st,stm32h7-dfsdm-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&dfsdm3 0>;
+			status = "okay";
+
+			dfsdm3_port: port {
+				dfsdm_endpoint3: endpoint {
+					remote-endpoint = <&dmic3_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&dsi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	default-on;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out: endpoint {
+				remote-endpoint = <&dsi_panel_in>;
+			};
+		};
+	};
+
+	panel_dsi: panel-dsi@0 {
+		compatible = "raydium,rm68200";
+		reg = <0>;
+		reset-gpios = <&gpiof 15 GPIO_ACTIVE_LOW>;
+		backlight = <&panel_backlight>;
+		power-supply = <&v3v3>;
+		status = "okay";
+
+		port {
+			dsi_panel_in: endpoint {
+				remote-endpoint = <&dsi_out>;
+			};
+		};
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy0: ethernet-phy@0 {
+			reg = <0>;
+		};
+	};
+};
+
+&fmc {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&fmc_pins_a>;
+	pinctrl-1 = <&fmc_sleep_pins_a>;
+	status = "okay";
+
+	nand-controller@4,0 {
+		status = "okay";
+
+		nand@0 {
+			reg = <0>;
+			nand-on-flash-bbt;
+			#address-cells = <1>;
+			#size-cells = <1>;
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+
+	wm8994: wm8994@1b {
+		compatible = "wlf,wm8994";
+		#sound-dai-cells = <0>;
+		reg = <0x1b>;
+
+		gpio-controller;
+		#gpio-cells = <2>;
+
+		DBVDD-supply = <&vdd>;
+		SPKVDD1-supply = <&vdd>;
+		SPKVDD2-supply = <&vdd>;
+		AVDD2-supply = <&v1v8>;
+		CPVDD-supply = <&v1v8>;
+
+		wlf,ldoena-always-driven;
+
+		clocks = <&sai2a>;
+		clock-names = "MCLK1";
+
+		wlf,gpio-cfg = <0x8101 0xa100 0xa100 0xa100 0xa101 0xa101\
+						0xa100 0xa101 0xa101 0xa101 0xa101>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			wm8994_tx_port: port@0 {
+				reg = <0>;
+				wm8994_tx_endpoint: endpoint {
+					remote-endpoint = <&sai2a_endpoint>;
+				};
+			};
+
+			wm8994_rx_port: port@1 {
+				reg = <1>;
+				wm8994_rx_endpoint: endpoint {
+					remote-endpoint = <&sai2b_endpoint>;
+				};
+			};
+		};
+	};
+
+	ov5640: camera@3c {
+		compatible = "ovti,ov5640";
+		reg = <0x3c>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		DOVDD-supply = <&v2v8>;
+		powerdown-gpios = <&stmfx_pinctrl 18 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		reset-gpios = <&stmfx_pinctrl 19 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
+		rotation = <180>;
+		status = "okay";
+
+		port {
+			ov5640_0: endpoint {
+				remote-endpoint = <&dcmi_0>;
+				bus-width = <8>;
+				data-shift = <2>; /* lines 9:2 are used */
+				hsync-active = <0>;
+				vsync-active = <0>;
+				pclk-sample = <1>;
+				pclk-max-frequency = <77000000>;
+			};
+		};
+	};
+
+	stmfx: stmfx@42 {
+		compatible = "st,stmfx-0300";
+		reg = <0x42>;
+		interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+		interrupt-parent = <&gpioi>;
+		vdd-supply = <&v3v3>;
+
+		stmfx_pinctrl: pinctrl {
+			compatible = "st,stmfx-0300-pinctrl";
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-ranges = <&stmfx_pinctrl 0 0 24>;
+
+			goodix_pins: goodix {
+				pins = "gpio14";
+				bias-pull-down;
+			};
+
+			joystick_pins: joystick-pins {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3", "gpio4";
+				bias-pull-down;
+			};
+		};
+	};
+
+	gt9147: goodix-ts@5d {
+		compatible = "goodix,gt9147";
+		reg = <0x5d>;
+		panel = <&panel_dsi>;
+		pinctrl-0 = <&goodix_pins>;
+		pinctrl-names = "default";
+		AVDD28-supply = <&v3v3>;
+		VDDIO-supply = <&v3v3>;
+		status = "okay";
+
+		interrupts = <14 IRQ_TYPE_NONE>;
+		interrupt-parent = <&stmfx_pinctrl>;
+	};
+};
+
+&i2c4 {
+	pmic: stpmic@33 {
+		regulators {
+			v1v8: ldo6 {
+				regulator-enable-ramp-delay = <300000>;
+			};
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c5_pins_a>;
+	pinctrl-1 = <&i2c5_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&ltdc {
+	default-on;
+	status = "okay";
+
+	port {
+		ltdc_ep0_out: endpoint {
+			remote-endpoint = <&dsi_in>;
+		};
+	};
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a
+		     &qspi_bk2_pins_a
+		     &qspi_cs2_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a
+		     &qspi_bk2_sleep_pins_a
+		     &qspi_cs2_sleep_pins_a>;
+	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	flash1: flash@1 {
+		compatible = "jedec,spi-nor";
+		reg = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <108000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&sai2 {
+	clocks = <&rcc SAI2>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sai2a_pins_a>, <&sai2b_pins_a>;
+	pinctrl-1 = <&sai2a_sleep_pins_a>, <&sai2b_sleep_pins_a>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai2a: audio-controller@4400b004 {
+		#clock-cells = <0>;
+		dma-names = "tx";
+		status = "okay";
+
+		sai2a_port: port {
+			sai2a_endpoint: endpoint {
+				remote-endpoint = <&wm8994_tx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+
+	sai2b: audio-controller@4400b024 {
+		dma-names = "rx";
+		clocks = <&rcc SAI2_K>, <&sai2a>;
+		clock-names = "sai_ck", "MCLK";
+		status = "okay";
+
+		sai2b_port: port {
+			sai2b_endpoint: endpoint {
+				remote-endpoint = <&wm8994_rx_endpoint>;
+				format = "i2s";
+				mclk-fs = <256>;
+			};
+		};
+	};
+};
+
+&sai4 {
+	clocks = <&rcc SAI4>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
+	clock-names = "pclk", "x8k", "x11k";
+	status = "okay";
+
+	sai4a: audio-controller@50027004 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&sai4a_pins_a>;
+		pinctrl-1 = <&sai4a_sleep_pins_a>;
+		dma-names = "tx";
+		st,iec60958;
+		status = "okay";
+
+		sai4a_port: port {
+			sai4a_endpoint: endpoint {
+				remote-endpoint = <&spdif_out_endpoint>;
+			};
+		};
+	};
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&v3v3>;
+	status = "disabled";
+};
+
+&spdifrx {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spdifrx_pins_a>;
+	pinctrl-1 = <&spdifrx_sleep_pins_a>;
+	status = "okay";
+
+	spdifrx_port: port {
+		spdifrx_endpoint: endpoint {
+			remote-endpoint = <&spdif_in_endpoint>;
+		};
+	};
+};
+
+&spi1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi1_pins_a>;
+	pinctrl-1 = <&spi1_sleep_pins_a>;
+	status = "disabled";
+};
+
+&sram4 {
+	dcmi_pool: dcmi-pool@0 {
+		reg = <0x0 0x8000>;
+		pool;
+	};
+};
+
+&timers2 {
+	/* spare dmas for other usage (un-delete to enable pwm capture) */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm2_pins_a>;
+		pinctrl-1 = <&pwm2_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@1 {
+		status = "okay";
+	};
+};
+
+&timers8 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm8_pins_a>;
+		pinctrl-1 = <&pwm8_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@7 {
+		status = "okay";
+	};
+};
+
+&timers12 {
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+	counter {
+		status = "okay";
+	};
+	pwm {
+		pinctrl-0 = <&pwm12_pins_a>;
+		pinctrl-1 = <&pwm12_sleep_pins_a>;
+		pinctrl-names = "default", "sleep";
+		status = "okay";
+	};
+	timer@11 {
+		status = "okay";
+	};
+};
+
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "disabled";
+};
+
+&usart3 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart3_pins_b>;
+	pinctrl-1 = <&usart3_sleep_pins_b>;
+	pinctrl-2 = <&usart3_idle_pins_b>;
+	/*
+	 * HW flow control USART3_RTS is optional, and isn't default wired to
+	 * the connector. SB23 needs to be soldered in order to use it, and R77
+	 * (ETH_CLK) should be removed.
+	 */
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phys = <&usbphyc_port1 0>;
+	phy-names = "usb2-phy";
+	status = "okay";
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+	connector {
+		compatible = "usb-a-connector";
+		vbus-supply = <&vbus_sw>;
+	};
+};
+
+&usbphyc_port1 {
+	st,tune-hs-dc-level = <2>;
+	st,enable-fs-rftime-tuning;
+	st,enable-hs-rftime-reduction;
+	st,trim-hs-current = <15>;
+	st,trim-hs-impedance = <1>;
+	st,tune-squelch-level = <3>;
+	st,tune-hs-rx-offset = <2>;
+	st,no-lsfs-sc;
+};
diff --git a/arch/arm/dts/stm32mp15xa.dtsi b/arch/arm/dts/stm32mp15xa.dtsi
new file mode 100644
index 0000000000..cc6456e71b
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xa.dtsi
@@ -0,0 +1,5 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
diff --git a/arch/arm/dts/stm32mp15xc.dtsi b/arch/arm/dts/stm32mp15xc.dtsi
index b06a55a2fa..f5c26b7f3e 100644
--- a/arch/arm/dts/stm32mp15xc.dtsi
+++ b/arch/arm/dts/stm32mp15xc.dtsi
@@ -4,15 +4,23 @@
  * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
  */
 
+#include "stm32mp15xa.dtsi"
+
 / {
 	soc {
-		cryp1: cryp@54001000 {
-			compatible = "st,stm32mp1-cryp";
-			reg = <0x54001000 0x400>;
-			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&rcc CRYP1>;
-			resets = <&rcc CRYP1_R>;
-			status = "disabled";
+		etzpc: etzpc@5c007000 {
+			cryp1: cryp@54001000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54001000 0x400>;
+				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma1 29 0x0 0x400202 0x0 0x0>,
+				       <&mdma1 30 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP1_ID>;
+				status = "disabled";
+			};
 		};
 	};
 };
diff --git a/arch/arm/dts/stm32mp15xd.dtsi b/arch/arm/dts/stm32mp15xd.dtsi
new file mode 100644
index 0000000000..d8a14c55b2
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xd.dtsi
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&cpu_thermal {
+	trips {
+		cpu-crit {
+			temperature = <105000>;
+			hysteresis = <0>;
+			type = "critical";
+		};
+
+		cpu_alert: cpu-alert {
+			temperature = <95000>;
+			hysteresis = <10000>;
+			type = "passive";
+		};
+	};
+
+	cooling-maps {
+		map0 {
+			trip = <&cpu_alert>;
+			cooling-device = <&cpu0 1 1>;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15xf.dtsi b/arch/arm/dts/stm32mp15xf.dtsi
new file mode 100644
index 0000000000..9f8dc6cbe5
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xf.dtsi
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2019 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.
+ */
+
+#include "stm32mp15xd.dtsi"
+
+/ {
+	soc {
+		etzpc: etzpc@5c007000 {
+			cryp1: cryp@54001000 {
+				compatible = "st,stm32mp1-cryp";
+				reg = <0x54001000 0x400>;
+				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CRYP1>;
+				resets = <&rcc CRYP1_R>;
+				dmas = <&mdma1 29 0x0 0x400202 0x0 0x0>,
+				       <&mdma1 30 0x3 0x400808 0x0 0x0>;
+				dma-names = "in", "out";
+				feature-domains = <&etzpc STM32MP1_ETZPC_CRYP1_ID>;
+				status = "disabled";
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi b/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi
index 83e2c87713..9f34ad864b 100644
--- a/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcom-som.dtsi
@@ -82,15 +82,19 @@
 	status = "okay";
 
 	adc1: adc@0 {
-		st,min-sample-time-nsecs = <5000>;
-		st,adc-channels = <0>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 
 	adc2: adc@100 {
-		st,adc-channels = <1>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
@@ -429,8 +433,12 @@
 
 &qspi {
 	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
-	pinctrl-1 = <&qspi_clk_sleep_pins_a &qspi_bk1_sleep_pins_a>;
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a>;
 	reg = <0x58003000 0x1000>, <0x70000000 0x4000000>;
 	#address-cells = <1>;
 	#size-cells = <0>;
diff --git a/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi b/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi
index 8a7156c93b..b62cdf98ee 100644
--- a/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcom-u-boot.dtsi
@@ -92,6 +92,33 @@
 
 &flash0 {
 	u-boot,dm-spl;
+
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "fsbl1";
+			reg = <0x00000000 0x00040000>;
+		};
+		partition@40000 {
+			label = "fsbl2";
+			reg = <0x00040000 0x00040000>;
+		};
+		partition@500000 {
+			label = "uboot";
+			reg = <0x00080000 0x00160000>;
+		};
+		partition@900000 {
+			label = "env1";
+			reg = <0x001E0000 0x00010000>;
+		};
+		partition@980000 {
+			label = "env2";
+			reg = <0x001F0000 0x00010000>;
+		};
+	};
 };
 
 &qspi {
@@ -190,6 +217,21 @@
 		CLK_LPTIM45_LSE
 	>;
 
+	/*
+	 * cfg = < DIVM1 DIVN P Q R PQR(p,q,r) >;
+	 * frac = < f >;
+	 *
+	 * PRQ(p,q,r) ... for p,q,r: 0-output disabled / 1-output enabled
+	 * DIVN ... actually multiplier, but RCC_PLL1CFGR1 calls the field DIVN
+	 * m ... for PLL1,2: m=2 ; for PLL3,4: m=1
+	 * XTAL = 24 MHz
+	 *
+	 * VCO = ( XTAL / (DIVM1 + 1) ) * m * ( DIVN + 1 + ( f / 8192 ) )
+	 *   P = VCO / (P + 1)
+	 *   Q = VCO / (Q + 1)
+	 *   R = VCO / (R + 1)
+	 */
+
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
@@ -208,7 +250,7 @@
 		u-boot,dm-pre-reloc;
 	};
 
-	/* VCO = 600.0 MHz => P = 50, Q = 50, R = 50 */
+	/* VCO = 600.0 MHz => P = 100, Q = 50, R = 50 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-avenger96-u-boot.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-avenger96-u-boot.dtsi
index 5bed53e3fd..6dee51dc1c 100644
--- a/arch/arm/dts/stm32mp15xx-dhcor-avenger96-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcor-avenger96-u-boot.dtsi
@@ -19,7 +19,6 @@
 	};
 };
 
-
 &ethernet0 {
 	phy-reset-gpios = <&gpioz 2 GPIO_ACTIVE_LOW>;
 
@@ -102,6 +101,10 @@
 	hnp-srp-disable;
 };
 
+&vdd {
+	/delete-property/ regulator-always-on;
+};
+
 &vdd_io {
 	u-boot,dm-spl;
 };
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi
index 61e17f44ce..19fcff6c3a 100644
--- a/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtsi
@@ -114,15 +114,35 @@
 	status = "okay";
 
 	adc1: adc@0 {
-		st,adc-channels = <0 1 6>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@6 {
+			reg = <6>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 
 	adc2: adc@100 {
-		st,adc-channels = <0 1 2>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		channel@0 {
+			reg = <0>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@1 {
+			reg = <1>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@2 {
+			reg = <2>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
@@ -275,11 +295,7 @@
 	status = "okay";
 
 	port {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&adv7513_in>;
 		};
 	};
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-som.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-som.dtsi
index 98033b5147..f36eec1b4a 100644
--- a/arch/arm/dts/stm32mp15xx-dhcor-som.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcor-som.dtsi
@@ -191,8 +191,12 @@
 
 &qspi {
 	pinctrl-names = "default", "sleep";
-	pinctrl-0 = <&qspi_clk_pins_a &qspi_bk1_pins_a>;
-	pinctrl-1 = <&qspi_clk_sleep_pins_a &qspi_bk1_sleep_pins_a>;
+	pinctrl-0 = <&qspi_clk_pins_a
+		     &qspi_bk1_pins_a
+		     &qspi_cs1_pins_a>;
+	pinctrl-1 = <&qspi_clk_sleep_pins_a
+		     &qspi_bk1_sleep_pins_a
+		     &qspi_cs1_sleep_pins_a>;
 	reg = <0x58003000 0x1000>, <0x70000000 0x200000>;
 	#address-cells = <1>;
 	#size-cells = <0>;
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-testbench-u-boot.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-testbench-u-boot.dtsi
new file mode 100644
index 0000000000..5b051b8ac4
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xx-dhcor-testbench-u-boot.dtsi
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022 Marek Vasut <marex@denx.de>
+ */
+
+#include "stm32mp15xx-dhcor-u-boot.dtsi"
+
+/ {
+	aliases {
+		mmc0 = &sdmmc1;
+		mmc1 = &sdmmc2;
+		usb0 = &usbotg_hs;
+	};
+
+	config {
+		dh,board-coding-gpios = <&gpiog 13 0>, <&gpiod 9 0>;
+	};
+};
+
+&ethernet0 {
+	phy-reset-gpios = <&gpioz 2 GPIO_ACTIVE_LOW>;
+
+	mdio0 {
+		ethernet-phy@7 {
+			reset-gpios = <&gpioz 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <11000>;
+			reset-deassert-us = <1000>;
+		};
+	};
+};
+
+&sdmmc1 {
+	u-boot,dm-spl;
+	st,use-ckin;
+	st,cmd-gpios = <&gpiod 2 0>;
+	st,ck-gpios = <&gpioc 12 0>;
+	st,ckin-gpios = <&gpioe 4 0>;
+};
+
+&sdmmc1_b4_pins_a {
+	u-boot,dm-spl;
+	pins1 {
+		u-boot,dm-spl;
+	};
+	pins2 {
+		u-boot,dm-spl;
+	};
+};
+
+&sdmmc1_dir_pins_b {
+	u-boot,dm-spl;
+	pins1 {
+		u-boot,dm-spl;
+	};
+	pins2 {
+		u-boot,dm-spl;
+	};
+};
+
+&sdmmc2 {
+	u-boot,dm-spl;
+};
+
+&sdmmc2_b4_pins_a {
+	u-boot,dm-spl;
+	pins1 {
+		u-boot,dm-spl;
+	};
+	pins2 {
+		u-boot,dm-spl;
+	};
+};
+
+&sdmmc2_d47_pins_c {
+	u-boot,dm-spl;
+	pins {
+		u-boot,dm-spl;
+	};
+};
+
+&uart4 {
+	u-boot,dm-pre-reloc;
+};
+
+&uart4_pins_b {
+	u-boot,dm-pre-reloc;
+	pins1 {
+		u-boot,dm-pre-reloc;
+	};
+	pins2 {
+		u-boot,dm-pre-reloc;
+		/delete-property/ bias-disable;
+		bias-pull-up;
+	};
+};
+
+&usbotg_hs {
+	u-boot,force-b-session-valid;
+	hnp-srp-disable;
+};
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-testbench.dts b/arch/arm/dts/stm32mp15xx-dhcor-testbench.dts
new file mode 100644
index 0000000000..c9163e1c02
--- /dev/null
+++ b/arch/arm/dts/stm32mp15xx-dhcor-testbench.dts
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: (GPL-2.0 OR BSD-3-Clause)
+/*
+ * Copyright (C) 2022 Marek Vasut <marex@denx.de>
+ */
+/dts-v1/;
+
+#include "stm32mp151.dtsi"
+#include "stm32mp15xx-dhcor-som.dtsi"
+
+/ {
+	model = "DH electronics STM32MP15xx DHCOR Testbench";
+	compatible = "dh,stm32mp15xx-dhcor-testbench", "st,stm32mp1xx";
+
+	aliases {
+		ethernet0 = &ethernet0;
+		mmc0 = &sdmmc1;
+		mmc1 = &sdmmc2;
+		serial0 = &uart4;
+		serial1 = &uart7;
+		spi0 = &qspi;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	sd_switch: regulator-sd_switch {
+		compatible = "regulator-gpio";
+		regulator-name = "sd_switch";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2900000>;
+		regulator-type = "voltage";
+		regulator-always-on;
+
+		gpios = <&gpioi 5 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0>;
+		states = <1800000 0x1>,
+			 <2900000 0x0>;
+	};
+};
+
+&adc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&adc12_ain_pins_b>;
+	vdd-supply = <&vdd>;
+	vdda-supply = <&vdda>;
+	vref-supply = <&vdda>;
+	status = "okay";
+
+	adc1: adc@0 {
+		st,adc-channels = <0 1 6>;
+		st,min-sample-time-nsecs = <5000>;
+		status = "okay";
+	};
+
+	adc2: adc@100 {
+		st,adc-channels = <0 1 2>;
+		st,min-sample-time-nsecs = <5000>;
+		status = "okay";
+	};
+};
+
+&ethernet0 {
+	status = "okay";
+	pinctrl-0 = <&ethernet0_rgmii_pins_c>;
+	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_c>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii";
+	max-speed = <1000>;
+	phy-handle = <&phy0>;
+
+	mdio0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		reset-gpios = <&gpioz 2 GPIO_ACTIVE_LOW>;
+		reset-delay-us = <1000>;
+
+		phy0: ethernet-phy@7 {
+			reg = <7>;
+
+			rxc-skew-ps = <1500>;
+			rxdv-skew-ps = <540>;
+			rxd0-skew-ps = <420>;
+			rxd1-skew-ps = <420>;
+			rxd2-skew-ps = <420>;
+			rxd3-skew-ps = <420>;
+
+			txc-skew-ps = <1440>;
+			txen-skew-ps = <540>;
+			txd0-skew-ps = <420>;
+			txd1-skew-ps = <420>;
+			txd2-skew-ps = <420>;
+			txd3-skew-ps = <420>;
+		};
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a &sdmmc1_dir_pins_b>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a &sdmmc1_dir_pins_b>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a &sdmmc1_dir_sleep_pins_b>;
+	cd-gpios = <&gpioi 8 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,sig-dir;
+	st,neg-edge;
+	st,use-ckin;
+	bus-width = <4>;
+	vmmc-supply = <&vdd_sd>;
+	vqmmc-supply = <&sd_switch>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_c>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_c>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_c>;
+	bus-width = <8>;
+	mmc-ddr-1_8v;
+	no-sd;
+	no-sdio;
+	non-removable;
+	st,neg-edge;
+	vmmc-supply = <&v3v3>;
+	vqmmc-supply = <&v3v3>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_b>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&uart7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart7_pins_a>;
+	uart-has-rtscts;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usbh_ehci {
+	phys = <&usbphyc_port0>;
+	phy-names = "usb";
+	status = "okay";
+};
+
+&usbotg_hs {
+	pinctrl-0 = <&usbotg_hs_pins_a>;
+	pinctrl-names = "default";
+	phy-names = "usb2-phy";
+	phys = <&usbphyc_port1 0>;
+	status = "okay";
+	vbus-supply = <&vbus_otg>;
+};
+
+&usbphyc {
+	status = "okay";
+};
+
+&usbphyc_port0 {
+	phy-supply = <&vdd_usb>;
+};
+
+&usbphyc_port1 {
+	phy-supply = <&vdd_usb>;
+};
+
+&vdd {
+	/delete-property/ regulator-always-on;
+	regulator-min-microvolt = <1200000>;
+};
diff --git a/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi b/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi
index 19f4221f87..427eb60f1f 100644
--- a/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dhcor-u-boot.dtsi
@@ -28,6 +28,33 @@
 
 &flash0 {
 	u-boot,dm-spl;
+
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "fsbl1";
+			reg = <0x00000000 0x00040000>;
+		};
+		partition@40000 {
+			label = "fsbl2";
+			reg = <0x00040000 0x00040000>;
+		};
+		partition@500000 {
+			label = "uboot";
+			reg = <0x00080000 0x00160000>;
+		};
+		partition@900000 {
+			label = "env1";
+			reg = <0x001E0000 0x00010000>;
+		};
+		partition@980000 {
+			label = "env2";
+			reg = <0x001F0000 0x00010000>;
+		};
+	};
 };
 
 &i2c4 {
@@ -144,6 +171,21 @@
 		CLK_LPTIM45_LSE
 	>;
 
+	/*
+	 * cfg = < DIVM1 DIVN P Q R PQR(p,q,r) >;
+	 * frac = < f >;
+	 *
+	 * PRQ(p,q,r) ... for p,q,r: 0-output disabled / 1-output enabled
+	 * DIVN ... actually multiplier, but RCC_PLL1CFGR1 calls the field DIVN
+	 * m ... for PLL1,2: m=2 ; for PLL3,4: m=1
+	 * XTAL = 24 MHz
+	 *
+	 * VCO = ( XTAL / (DIVM1 + 1) ) * m * ( DIVN + 1 + ( f / 8192 ) )
+	 *   P = VCO / (P + 1)
+	 *   Q = VCO / (Q + 1)
+	 *   R = VCO / (R + 1)
+	 */
+
 	/* VCO = 1066.0 MHz => P = 266 (AXI), Q = 533 (GPU), R = 533 (DDR) */
 	pll2: st,pll@1 {
 		compatible = "st,stm32mp1-pll";
@@ -162,7 +204,7 @@
 		u-boot,dm-pre-reloc;
 	};
 
-	/* VCO = 600.0 MHz => P = 99, Q = 74, R = 99 */
+	/* VCO = 594.0 MHz => P = 99, Q = 74, R = 99 */
 	pll4: st,pll@3 {
 		compatible = "st,stm32mp1-pll";
 		reg = <3>;
diff --git a/arch/arm/dts/stm32mp15xx-dkx.dtsi b/arch/arm/dts/stm32mp15xx-dkx.dtsi
index 3d36cac9ed..f28072380a 100644
--- a/arch/arm/dts/stm32mp15xx-dkx.dtsi
+++ b/arch/arm/dts/stm32mp15xx-dkx.dtsi
@@ -6,8 +6,17 @@
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/mfd/st,stpmic1.h>
+#include "stm32mp15-m4-srm.dtsi"
+#include "stm32mp15-m4-srm-pinctrl.dtsi"
 
 / {
+	aliases {
+		ethernet0 = &ethernet0;
+		serial0 = &uart4;
+		serial1 = &usart3;
+		serial2 = &uart7;
+	};
+
 	memory@c0000000 {
 		device_type = "memory";
 		reg = <0xc0000000 0x20000000>;
@@ -42,6 +51,12 @@
 			no-map;
 		};
 
+		mcu_rsc_table: mcu-rsc-table@10048000 {
+			compatible = "shared-dma-pool";
+			reg = <0x10048000 0x8000>;
+			no-map;
+		};
+
 		mcuram: mcuram@30000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x30000000 0x40000>;
@@ -60,6 +75,19 @@
 		};
 	};
 
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&sii9022_out>;
+			};
+		};
+	};
+
 	led {
 		compatible = "gpio-leds";
 		led-blue {
@@ -72,7 +100,7 @@
 
 	sound {
 		compatible = "audio-graph-card";
-		label = "STM32MP1-DK";
+		label = "STM32MP15-DK";
 		routing =
 			"Playback" , "MCLK",
 			"Capture" , "MCLK",
@@ -92,31 +120,47 @@
 
 &adc {
 	pinctrl-names = "default";
-	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
+	pinctrl-0 = <&adc12_usb_cc_pins_a>;
 	vdd-supply = <&vdd>;
 	vdda-supply = <&vdd>;
 	vref-supply = <&vrefbuf>;
-	status = "disabled";
+	status = "okay";
 	adc1: adc@0 {
+		status = "okay";
 		/*
 		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in18 & in19.
 		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
 		 * 5 * (56 + 47kOhms) * 5pF => 2.5us.
 		 * Use arbitrary margin here (e.g. 5us).
 		 */
-		st,min-sample-time-nsecs = <5000>;
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 6 13 18 19>;
-		status = "okay";
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 	adc2: adc@100 {
-		/* AIN connector, USB Type-C CC1 & CC2 */
-		st,adc-channels = <0 1 2 6 18 19>;
-		st,min-sample-time-nsecs = <5000>;
 		status = "okay";
+		/* USB Type-C CC1 & CC2 */
+		channel@18 {
+			reg = <18>;
+			st,min-sample-time-ns = <5000>;
+		};
+		channel@19 {
+			reg = <19>;
+			st,min-sample-time-ns = <5000>;
+		};
 	};
 };
 
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
 &cec {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&cec_pins_b>;
@@ -124,20 +168,20 @@
 	status = "okay";
 };
 
-&crc1 {
-	status = "okay";
+&cpu0 {
+	cpu-supply = <&vddcore>;
 };
 
-&dts {
-	status = "okay";
+&cpu1 {
+	cpu-supply = <&vddcore>;
 };
 
-&cpu0{
-	cpu-supply = <&vddcore>;
+&crc1 {
+	status = "okay";
 };
 
-&cpu1{
-	cpu-supply = <&vddcore>;
+&dts {
+	status = "okay";
 };
 
 &ethernet0 {
@@ -148,8 +192,10 @@
 	phy-mode = "rgmii-id";
 	max-speed = <1000>;
 	phy-handle = <&phy0>;
+	nvmem-cells = <&ethernet_mac_address>;
+	nvmem-cell-names = "mac-address";
 
-	mdio0 {
+	mdio {
 		#address-cells = <1>;
 		#size-cells = <0>;
 		compatible = "snps,dwmac-mdio";
@@ -199,6 +245,13 @@
 				};
 			};
 
+			port@1 {
+				reg = <1>;
+				sii9022_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
 			port@3 {
 				reg = <3>;
 				sii9022_tx_endpoint: endpoint {
@@ -281,7 +334,7 @@
 	pmic: stpmic@33 {
 		compatible = "st,stpmic1";
 		reg = <0x33>;
-		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupts-extended = <&exti 55 IRQ_TYPE_EDGE_FALLING>;
 		interrupt-controller;
 		#interrupt-cells = <2>;
 		status = "okay";
@@ -385,26 +438,26 @@
 				interrupts = <IT_CURLIM_LDO6 0>;
 			};
 
-			vref_ddr: vref_ddr {
+			vref_ddr: vref-ddr {
 				regulator-name = "vref_ddr";
 				regulator-always-on;
 			};
 
-			 bst_out: boost {
+			bst_out: boost {
 				regulator-name = "bst_out";
 				interrupts = <IT_OCP_BOOST 0>;
-			 };
+			};
 
-			vbus_otg: pwr_sw1 {
+			vbus_otg: pwr-sw1 {
 				regulator-name = "vbus_otg";
 				interrupts = <IT_OCP_OTG 0>;
-			 };
+			};
 
-			 vbus_sw: pwr_sw2 {
+			vbus_sw: pwr-sw2 {
 				regulator-name = "vbus_sw";
 				interrupts = <IT_OCP_SWOUT 0>;
 				regulator-active-discharge = <1>;
-			 };
+			};
 		};
 
 		onkey {
@@ -446,7 +499,7 @@
 	i2s2_port: port {
 		i2s2_endpoint: endpoint {
 			remote-endpoint = <&sii9022_tx_endpoint>;
-			format = "i2s";
+			dai-format = "i2s";
 			mclk-fs = <256>;
 		};
 	};
@@ -456,11 +509,6 @@
 	status = "okay";
 };
 
-&iwdg2 {
-	timeout-sec = <32>;
-	status = "okay";
-};
-
 &ltdc {
 	pinctrl-names = "default", "sleep";
 	pinctrl-0 = <&ltdc_pins_a>;
@@ -468,8 +516,7 @@
 	status = "okay";
 
 	port {
-		ltdc_ep0_out: endpoint@0 {
-			reg = <0>;
+		ltdc_ep0_out: endpoint {
 			remote-endpoint = <&sii9022_in>;
 		};
 	};
@@ -477,11 +524,12 @@
 
 &m4_rproc {
 	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
-			<&vdev0vring1>, <&vdev0buffer>;
+			<&vdev0vring1>, <&vdev0buffer>, <&mcu_rsc_table>;
 	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>, <&ipcc 3>;
 	mbox-names = "vq0", "vq1", "shutdown", "detach";
 	interrupt-parent = <&exti>;
 	interrupts = <68 1>;
+	wakeup-source;
 	status = "okay";
 };
 
@@ -490,10 +538,6 @@
 	vdd_3v3_usbfs-supply = <&vdd_usb>;
 };
 
-&rng1 {
-	status = "okay";
-};
-
 &rtc {
 	status = "okay";
 };
@@ -509,8 +553,6 @@
 	sai2a: audio-controller@4400b004 {
 		#clock-cells = <0>;
 		dma-names = "tx";
-		clocks = <&rcc SAI2_K>;
-		clock-names = "sai_ck";
 		status = "okay";
 
 		sai2a_port: port {
@@ -568,11 +610,28 @@
 	status = "disabled";
 };
 
+&spi4 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi4_pins_b>;
+	pinctrl-1 = <&spi4_sleep_pins_b>;
+	status = "disabled";
+};
+
+&spi5 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi5_pins_a>;
+	pinctrl-1 = <&spi5_sleep_pins_a>;
+	status = "disabled";
+};
+
 &timers1 {
 	/* spare dmas for other usage */
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm1_pins_a>;
 		pinctrl-1 = <&pwm1_sleep_pins_a>;
@@ -588,6 +647,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm3_pins_a>;
 		pinctrl-1 = <&pwm3_sleep_pins_a>;
@@ -603,6 +665,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm4_pins_a &pwm4_pins_b>;
 		pinctrl-1 = <&pwm4_sleep_pins_a &pwm4_sleep_pins_b>;
@@ -618,6 +683,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm5_pins_a>;
 		pinctrl-1 = <&pwm5_sleep_pins_a>;
@@ -633,6 +701,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	timer@5 {
 		status = "okay";
 	};
@@ -642,6 +713,9 @@
 	/delete-property/dmas;
 	/delete-property/dma-names;
 	status = "disabled";
+	counter {
+		status = "okay";
+	};
 	pwm {
 		pinctrl-0 = <&pwm12_pins_a>;
 		pinctrl-1 = <&pwm12_sleep_pins_a>;
@@ -685,6 +759,14 @@
 &usbh_ehci {
 	phys = <&usbphyc_port0>;
 	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	/* onboard HUB */
+	hub@1 {
+		compatible = "usb424,2514";
+		reg = <1>;
+		vdd-supply = <&v3v3>;
+	};
 };
 
 &usbotg_hs {
diff --git a/arch/arm/dts/stm32mp25-pinctrl.dtsi b/arch/arm/dts/stm32mp25-pinctrl.dtsi
new file mode 100644
index 0000000000..b97e10591a
--- /dev/null
+++ b/arch/arm/dts/stm32mp25-pinctrl.dtsi
@@ -0,0 +1,971 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	eth1_mdio_pins_a: eth1-mdio-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 2, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	eth1_mdio_sleep_pins_a: eth1-mdio-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 0, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('F', 2, ANALOG)>; /* ETH_MDIO */
+		};
+	};
+
+	eth1_rgmii_pins_a: eth1-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_sleep_pins_a: eth1-rgmii-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 9, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 14, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth1_rgmii_pins_b: eth1-rgmii-1 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 15, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 9, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, AF12)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, AF10)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 10, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 1, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth1_rgmii_sleep_pins_b: eth1-rgmii-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 15, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 1, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 10, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 11, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 13, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 9, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('C', 0, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('F', 1, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 2, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 12, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 13, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 11, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 14, AF10)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth2_rgmii_pins_a: eth2-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C', 7, AF10)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, AF10)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, AF10)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, AF10)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, AF10)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 8, AF10)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, AF10)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, AF10)>; /* ETH_MDC */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('C', 5, AF10)>; /* ETH_MDIO */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('G', 0, AF10)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, AF10)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, AF10)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, AF10)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, AF10)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins5 {
+			pinmux = <STM32_PINMUX('F', 6, AF10)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth2_rgmii_sleep_pins_a: eth2-rgmii-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('C', 7, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('C', 8, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('C', 9, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('C', 10, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('C', 4, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('F', 8, ANALOG)>, /* ETH_RGMII_CLK125 */
+				 <STM32_PINMUX('F', 7, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('C', 6, ANALOG)>, /* ETH_MDC */
+				 <STM32_PINMUX('C', 5, ANALOG)>, /* ETH_MDIO */
+				 <STM32_PINMUX('G', 0, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('C', 12, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('F', 9, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('C', 11, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('C', 3, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('F', 6, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	eth3_rgmii_pins_a: eth3-rgmii-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF14)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, AF14)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, AF14)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, AF14)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, AF14)>; /* ETH_RGMII_TX_CTL */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('H', 2, AF14)>; /* ETH_RGMII_GTX_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <3>;
+			st,io-delay = <2>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('A', 9, AF14)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, AF14)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, AF14)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, AF14)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, AF14)>; /* ETH_RGMII_RX_CTL */
+			bias-disable;
+			st,io-retime = <1>;
+			st,io-clk-edge = <1>;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('A', 5, AF14)>; /* ETH_RGMII_RX_CLK */
+			bias-disable;
+		};
+	};
+
+	eth3_rgmii_sleep_pins_a: eth3-rgmii-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>, /* ETH_RGMII_TXD0 */
+				 <STM32_PINMUX('A', 7, ANALOG)>, /* ETH_RGMII_TXD1 */
+				 <STM32_PINMUX('H', 6, ANALOG)>, /* ETH_RGMII_TXD2 */
+				 <STM32_PINMUX('H', 3, ANALOG)>, /* ETH_RGMII_TXD3 */
+				 <STM32_PINMUX('A', 3, ANALOG)>, /* ETH_RGMII_TX_CTL */
+				 <STM32_PINMUX('H', 2, ANALOG)>, /* ETH_RGMII_GTX_CLK */
+				 <STM32_PINMUX('A', 9, ANALOG)>, /* ETH_RGMII_RXD0 */
+				 <STM32_PINMUX('A', 10, ANALOG)>, /* ETH_RGMII_RXD1 */
+				 <STM32_PINMUX('H', 7, ANALOG)>, /* ETH_RGMII_RXD2 */
+				 <STM32_PINMUX('H', 8, ANALOG)>, /* ETH_RGMII_RXD3 */
+				 <STM32_PINMUX('A', 2, ANALOG)>, /* ETH_RGMII_RX_CTL */
+				 <STM32_PINMUX('A', 5, ANALOG)>; /* ETH_RGMII_RX_CLK */
+		};
+	};
+
+	i2c2_pins_a: i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('B', 4, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_a: i2c2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 5, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('B', 4, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2c2_pins_b: i2c2-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, AF9)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, AF9)>; /* I2C2_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c2_sleep_pins_b: i2c2-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 2, ANALOG)>, /* I2C2_SCL */
+				 <STM32_PINMUX('F', 0, ANALOG)>; /* I2C2_SDA */
+		};
+	};
+
+	i2s2_pins_a: i2s2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('K', 1, AF2)>, /* I2S2_SDO */
+				 <STM32_PINMUX('I', 14, AF2)>, /* I2S2_WS */
+				 <STM32_PINMUX('B', 0, AF2)>; /* I2S2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	i2s2_sleep_pins_a: i2s2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('K', 1, ANALOG)>, /* I2S2_SDO */
+				 <STM32_PINMUX('I', 14, ANALOG)>, /* I2S2_WS */
+				 <STM32_PINMUX('B', 0, ANALOG)>; /* I2S2_CK */
+		};
+	};
+
+	i2s2_pins_b: i2s2-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 2, AF2)>, /* I2S2_SDO */
+				<STM32_PINMUX('B', 3, AF2)>, /* I2S2_WS */
+				<STM32_PINMUX('B', 0, AF2)>; /* I2S2_CK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	i2s2_sleep_pins_b: i2s2-sleep-1 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 2, ANALOG)>, /* I2S2_SDO */
+				<STM32_PINMUX('B', 3, ANALOG)>, /* I2S2_WS */
+				<STM32_PINMUX('B', 0, ANALOG)>; /* I2S2_CK */
+		};
+	};
+
+	m_can1_pins_a: m-can1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 11, AF7)>; /* CAN1_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 12, AF7)>; /* CAN1_RX */
+			bias-disable;
+		};
+	};
+
+	m_can1_sleep_pins_a: m-can1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 11, ANALOG)>, /* CAN3_TX */
+				 <STM32_PINMUX('G', 12, ANALOG)>; /* CAN3_RX */
+		};
+	};
+
+	m_can3_pins_a: m-can3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J', 14, AF7)>; /* CAN3_TX */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 12, AF7)>; /* CAN3_RX */
+			bias-disable;
+		};
+	};
+
+	m_can3_sleep_pins_a: m-can3-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 14, ANALOG)>, /* CAN3_TX */
+				 <STM32_PINMUX('I', 12, ANALOG)>; /* CAN3_RX */
+		};
+	};
+
+	mdf_cck0_pins_a: mdf-cck0-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 7, AF5)>; /* MDF1_CCK */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_cck0_sleep_pins_a: mdf-cck0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 7, ANALOG)>; /* MDF1_CCK */
+		};
+	};
+
+	mdf_sdi6_pins_a: mdf-sdi6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 6, AF5)>; /* MDF1_SDI6 */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	mdf_sdi6_sleep_pins_a: mdf-sdi6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 6, ANALOG)>; /* MDF1_SDI6 */
+		};
+	};
+
+	ospi_port1_clk_pins_a: ospi-port1-clk-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, AF10)>; /* OSPI1_CLK */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	ospi_port1_clk_sleep_pins_a: ospi-port1-clk-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 0, ANALOG)>; /* OSPI1_CLK */
+		};
+	};
+
+	ospi_port1_cs0_pins_a: ospi-port1-cs0-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, AF10)>; /* OSPI_NCS0 */
+			bias-pull-up;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_cs0_sleep_pins_a: ospi-port1-cs0-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 3, ANALOG)>; /* OSPI_NCS0 */
+		};
+	};
+
+	ospi_port1_io03_pins_a: ospi-port1-io03-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF10)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, AF10)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, AF10)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, AF10)>; /* OSPI_IO3 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	ospi_port1_io03_sleep_pins_a: ospi-port1-io03-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>, /* OSPI_IO0 */
+				 <STM32_PINMUX('D', 5, ANALOG)>, /* OSPI_IO1 */
+				 <STM32_PINMUX('D', 6, ANALOG)>, /* OSPI_IO2 */
+				 <STM32_PINMUX('D', 7, ANALOG)>; /* OSPI_IO3 */
+		};
+	};
+
+	pcie_pins_a: pcie-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, AF4)>;
+			bias-disable;
+		};
+	};
+
+	pcie_init_pins_a: pcie-init-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, GPIO)>;
+			output-low;
+		};
+	};
+
+	pcie_sleep_pins_a: pcie-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('J', 0, ANALOG)>;
+		};
+	};
+
+	rtc_out2_rmp_pins_a: rtc-out2-rmp-pins-0 {
+		pins {
+			pinmux = <STM32_PINMUX('I', 8, ANALOG)>; /* RTC_OUT2_RMP */
+		};
+	};
+
+	sai1a_pins_a: sai1a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('D', 9, AF3)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('D', 8, AF3)>, /* SAI1_FS_A */
+				 <STM32_PINMUX('D', 10, AF3)>; /* SAI1_SCK_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('D', 11, AF3)>; /* SAI1_MCLK_A */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <2>;
+		};
+	};
+
+	sai1a_sleep_pins_a: sai1a-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 9, ANALOG)>, /* SAI1_SD_A */
+				 <STM32_PINMUX('D', 8, ANALOG)>, /* SAI1_FS_A */
+				 <STM32_PINMUX('D', 10, ANALOG)>, /* SAI1_SCK_A */
+				 <STM32_PINMUX('D', 11, ANALOG)>; /* SAI1_MCLK_A */
+		};
+	};
+
+	sai1b_pins_a: sai1b-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, AF4)>; /* SAI1_SD_B */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+	};
+
+	sai1b_sleep_pins_a: sai1b-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('D', 4, ANALOG)>; /* SAI1_SD_B */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_od_pins_a: sdmmc1-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 4, AF10)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, AF10)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, AF10)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, AF10)>; /* SDMMC1_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF10)>; /* SDMMC1_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 2, AF10)>; /* SDMMC1_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-disable;
+		};
+	};
+
+	sdmmc1_b4_sleep_pins_a: sdmmc1-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 4, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('E', 5, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E', 0, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('E', 1, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('E', 3, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('E', 2, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	sdmmc2_b4_pins_a: sdmmc2-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_od_pins_a: sdmmc2-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('E', 13, AF12)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, AF12)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, AF12)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, AF12)>; /* SDMMC2_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 14, AF12)>; /* SDMMC2_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('E', 15, AF12)>; /* SDMMC2_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_b4_sleep_pins_a: sdmmc2-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 13, ANALOG)>, /* SDMMC2_D0 */
+				 <STM32_PINMUX('E', 11, ANALOG)>, /* SDMMC2_D1 */
+				 <STM32_PINMUX('E', 8, ANALOG)>, /* SDMMC2_D2 */
+				 <STM32_PINMUX('E', 12, ANALOG)>, /* SDMMC2_D3 */
+				 <STM32_PINMUX('E', 14, ANALOG)>, /* SDMMC2_CK */
+				 <STM32_PINMUX('E', 15, ANALOG)>; /* SDMMC2_CMD */
+		};
+	};
+
+	sdmmc2_d47_pins_a: sdmmc2-d47-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, AF12)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, AF12)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, AF12)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, AF12)>; /* SDMMC2_D7 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc2_d47_sleep_pins_a: sdmmc2-d47-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('E', 10, ANALOG)>, /* SDMMC2_D4 */
+				 <STM32_PINMUX('E', 9, ANALOG)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E', 6, ANALOG)>, /* SDMMC2_D6 */
+				 <STM32_PINMUX('E', 7, ANALOG)>; /* SDMMC2_D7 */
+		};
+	};
+
+	sdmmc3_b4_pins_a: sdmmc3-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>, /* SDMMC3_D3 */
+				 <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_od_pins_a: sdmmc3-b4-od-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF10)>, /* SDMMC3_D0 */
+				 <STM32_PINMUX('D', 13, AF10)>, /* SDMMC3_D1 */
+				 <STM32_PINMUX('B', 12, AF10)>, /* SDMMC3_D2 */
+				 <STM32_PINMUX('I', 11, AF10)>; /* SDMMC3_D3 */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 13, AF10)>; /* SDMMC3_CK */
+			slew-rate = <3>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('D', 12, AF10)>; /* SDMMC3_CMD */
+			slew-rate = <2>;
+			drive-open-drain;
+			bias-pull-up;
+		};
+	};
+
+	sdmmc3_b4_sleep_pins_a: sdmmc3-b4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('B', 14, ANALOG)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('D', 13, ANALOG)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('B', 12, ANALOG)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('I', 11, ANALOG)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('B', 13, ANALOG)>, /* SDMMC1_CK */
+				 <STM32_PINMUX('D', 12, ANALOG)>; /* SDMMC1_CMD */
+		};
+	};
+
+	spi3_pins_a: spi3-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 7, AF1)>, /* SPI3_SCK */
+				 <STM32_PINMUX('B', 8, AF1)>; /* SPI3_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 10, AF1)>; /* SPI3_MISO */
+			bias-disable;
+		};
+	};
+
+	spi3_sleep_pins_a: spi3-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 7, ANALOG)>, /* SPI3_SCK */
+				 <STM32_PINMUX('B', 8, ANALOG)>, /* SPI3_MOSI */
+				 <STM32_PINMUX('B', 10, ANALOG)>; /* SPI3_MISO */
+		};
+	};
+
+	spi6_pins_a: spi6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, AF3)>, /* SPI6_SCK */
+				 <STM32_PINMUX('C', 7, AF3)>; /* SPI6_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 4, AF3)>; /* SPI6_MISO */
+			bias-disable;
+		};
+	};
+
+	spi6_sleep_pins_a: spi6-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 7, ANALOG)>, /* SPI6_SCK */
+				 <STM32_PINMUX('C', 7, ANALOG)>, /* SPI6_MOSI */
+				 <STM32_PINMUX('C', 4, ANALOG)>; /* SPI6_MISO */
+		};
+	};
+
+	usart1_pins_a: usart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, AF6)>, /* USART1_TX */
+				<STM32_PINMUX('I', 2, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 15, AF6)>, /* USART1_RX */
+				<STM32_PINMUX('I', 3, AF6)>; /* USART1_CTS_NSS */
+			bias-disable;
+		};
+	};
+
+	usart1_idle_pins_a: usart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				<STM32_PINMUX('I', 3, ANALOG)>; /* USART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('I', 2, AF6)>; /* USART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('G', 15, AF6)>; /* USART1_RX */
+			bias-disable;
+		};
+	};
+
+	usart1_sleep_pins_a: usart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('G', 14, ANALOG)>, /* USART1_TX */
+				<STM32_PINMUX('I', 2, ANALOG)>, /* USART1_RTS */
+				<STM32_PINMUX('I', 3, ANALOG)>, /* USART1_CTS_NSS */
+				<STM32_PINMUX('G', 15, ANALOG)>; /* USART1_RX */
+		};
+	};
+
+	usart2_pins_a: usart2-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, AF6)>; /* USART2_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_idle_pins_a: usart2-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>; /* USART2_TX */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 8, AF8)>; /* USART2_RX */
+			bias-disable;
+		};
+	};
+
+	usart2_sleep_pins_a: usart2-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('A', 4, ANALOG)>, /* USART2_TX */
+				 <STM32_PINMUX('A', 8, ANALOG)>; /* USART2_RX */
+		};
+	};
+
+	usart6_pins_a: usart6-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, AF3)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, AF3)>;  /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>, /* USART6_RX */
+				 <STM32_PINMUX('F', 15, AF3)>; /* USART6_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	usart6_idle_pins_a: usart6-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('F', 15, ANALOG)>; /* USART6_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('G', 5, AF3)>; /* USART6_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('F', 14, AF3)>; /* USART6_RX */
+			bias-pull-up;
+		};
+	};
+
+	usart6_sleep_pins_a: usart6-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('F', 13, ANALOG)>, /* USART6_TX */
+				 <STM32_PINMUX('G', 5, ANALOG)>,  /* USART6_RTS */
+				 <STM32_PINMUX('F', 15, ANALOG)>, /* USART6_CTS_NSS */
+				 <STM32_PINMUX('F', 14, ANALOG)>; /* USART6_RX */
+		};
+	};
+};
+
+&pinctrl_z {
+	i2c8_pins_a: i2c8-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF8)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, AF8)>; /* I2C8_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c8_sleep_pins_a: i2c8-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I2C8_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I2C8_SDA */
+		};
+	};
+
+	i3c4_pins_a: i3c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, AF11)>, /* I3C4_SCL */
+				 <STM32_PINMUX('Z', 3, AF11)>; /* I3C4_SDA */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <3>;
+		};
+	};
+
+	i3c4_init_pins_a: i3c4-init-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 4, AF11)>; /* I3C4_SCL */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 3, AF11)>; /* I3C4_SDA */
+			drive-push-pull;
+			bias-pull-up;
+			slew-rate = <1>;
+		};
+	};
+
+	i3c4_sleep_pins_a: i3c4-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 4, ANALOG)>, /* I3C4_SCL */
+				 <STM32_PINMUX('Z', 3, ANALOG)>; /* I3C4_SDA */
+		};
+	};
+
+	lpuart1_pins_a: lpuart1-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, AF6)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 5, AF6)>; /* LPUART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 8, AF6)>, /* LPUART1_RX */
+				 <STM32_PINMUX('Z', 6, AF6)>; /* LPUART1_CTS_NSS */
+			bias-pull-up;
+		};
+	};
+
+	lpuart1_idle_pins_a: lpuart1-idle-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 6, ANALOG)>; /* LPUART1_CTS_NSS */
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 5, AF6)>; /* LPUART1_RTS */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('Z', 8, AF6)>; /* LPUART1_RX */
+			bias-pull-up;
+		};
+	};
+
+	lpuart1_sleep_pins_a: lpuart1-sleep-0 {
+		pins {
+			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>, /* LPUART1_TX */
+				 <STM32_PINMUX('Z', 5, ANALOG)>, /* LPUART1_RTS */
+				 <STM32_PINMUX('Z', 6, ANALOG)>, /* LPUART1_CTS_NSS */
+				 <STM32_PINMUX('Z', 8, ANALOG)>; /* LPUART1_RX */
+		};
+	};
+
+	spi8_pins_a: spi8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 2, AF3)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 0, AF3)>; /* SPI8_MOSI */
+			drive-push-pull;
+			bias-disable;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('Z', 1, AF3)>; /* SPI8_MISO */
+			bias-disable;
+		};
+	};
+
+	spi8_sleep_pins_a: spi8-sleep-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('Z', 2, ANALOG)>, /* SPI8_SCK */
+				 <STM32_PINMUX('Z', 0, ANALOG)>, /* SPI8_MOSI */
+				 <STM32_PINMUX('Z', 1, ANALOG)>; /* SPI8_MISO */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp25-u-boot.dtsi b/arch/arm/dts/stm32mp25-u-boot.dtsi
new file mode 100644
index 0000000000..47f46fc9fe
--- /dev/null
+++ b/arch/arm/dts/stm32mp25-u-boot.dtsi
@@ -0,0 +1,129 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright : STMicroelectronics 2019
+ */
+
+/ {
+	aliases {
+		gpio0 = &gpioa;
+		gpio1 = &gpiob;
+		gpio2 = &gpioc;
+		gpio3 = &gpiod;
+		gpio4 = &gpioe;
+		gpio5 = &gpiof;
+		gpio6 = &gpiog;
+		gpio7 = &gpioh;
+		gpio8 = &gpioi;
+		gpio9 = &gpioj;
+		gpio10 = &gpiok;
+		gpio25 = &gpioz;
+		pinctrl0 = &pinctrl;
+		pinctrl1 = &pinctrl_z;
+	};
+
+	clocks {
+		txbyteclk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <27000000>;
+		};
+	};
+
+	firmware {
+		optee {
+			u-boot,dm-pre-reloc;
+		};
+	};
+
+	/* need PSCI for sysreset during board_f */
+	psci {
+		u-boot,dm-pre-reloc;
+	};
+
+	soc@0 {
+		u-boot,dm-pre-reloc;
+	};
+};
+
+&bsec {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioa {
+	u-boot,dm-pre-reloc;
+};
+
+&gpiob {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioc {
+	u-boot,dm-pre-reloc;
+};
+
+&gpiod {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioe {
+	u-boot,dm-pre-reloc;
+};
+
+&gpiof {
+	u-boot,dm-pre-reloc;
+};
+
+&gpiog {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioh {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioi {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioj {
+	u-boot,dm-pre-reloc;
+};
+
+&gpiok {
+	u-boot,dm-pre-reloc;
+};
+
+&gpioz {
+	u-boot,dm-pre-reloc;
+};
+
+/* pre-reloc probe = reserve video frame buffer in video_reserve() */
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+	clock-names = "bus", "lcd";
+	u-boot,dm-pre-reloc;
+};
+
+&pinctrl {
+	u-boot,dm-pre-reloc;
+};
+
+&rcc {
+	u-boot,dm-pre-reloc;
+};
+
+&rifsc {
+	u-boot,dm-pre-reloc;
+};
+
+&scmi {
+	u-boot,dm-pre-reloc;
+};
+
+&scmi_clk {
+	u-boot,dm-pre-reloc;
+};
+
+&syscfg {
+	u-boot,dm-pre-reloc;
+};
diff --git a/arch/arm/dts/stm32mp251.dtsi b/arch/arm/dts/stm32mp251.dtsi
new file mode 100644
index 0000000000..1fa8dd216d
--- /dev/null
+++ b/arch/arm/dts/stm32mp251.dtsi
@@ -0,0 +1,3178 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/arm/coresight-cti-dt.h>
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+#include <dt-bindings/clock/stm32mp25-clks.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/reset/stm32mp25-resets.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD0>;
+			power-domain-names = "psci";
+		};
+
+		idle-states {
+			entry-method = "psci";
+
+			CPU_PWRDN: cpu-power-down {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x00000001>;
+				local-timer-stop;
+				entry-latency-us = <300>;
+				exit-latency-us = <500>;
+				min-residency-us = <1000>;
+			};
+		};
+
+		domain-idle-states {
+			STOP1: domain-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000011>;
+				entry-latency-us = <400>;
+				exit-latency-us = <1200>;
+				min-residency-us = <1500>;
+			};
+
+			LP_STOP1: domain-lp-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x0000021>;
+				entry-latency-us = <500>;
+				exit-latency-us = <2000>;
+				min-residency-us = <3000>;
+			};
+
+			LPLV_STOP1: domain-lplv-stop1 {
+				compatible = "domain-idle-state";
+				arm,psci-suspend-param = <0x00000211>;
+				entry-latency-us = <500>;
+				exit-latency-us = <3000>;
+				min-residency-us = <4000>;
+			};
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a35-pmu";
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+		interrupt-parent = <&intc>;
+	};
+
+	arm_wdt: watchdog {
+		compatible = "arm,smc-wdt";
+		arm,smc-id = <0xb200005a>;
+		status = "disabled";
+	};
+
+	clocks {
+		clk_rcbsec: clk-rcbsec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <64000000>;
+		};
+	};
+
+	cs_replicator: replicator {
+		compatible = "arm,coresight-static-replicator";
+		clocks = <&scmi_clk CK_SCMI_SYSATB>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				replicator_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				replicator_out_port0: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				replicator_out_port1: endpoint {
+					remote-endpoint = <&tpiu_in_port>;
+				};
+			};
+		};
+	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		scmi: scmi {
+			compatible = "linaro,scmi-optee";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			linaro,optee-channel-id = <0>;
+
+			scmi_devpd: protocol@11 {
+				reg = <0x11>;
+				#power-domain-cells = <1>;
+			};
+
+			scmi_perf: protocol@13 {
+				reg = <0x13>;
+				#clock-cells = <1>;
+			};
+
+			scmi_clk: protocol@14 {
+				reg = <0x14>;
+				#clock-cells = <1>;
+			};
+
+			scmi_reset: protocol@16 {
+				reg = <0x16>;
+				#reset-cells = <1>;
+			};
+
+			scmi_voltd: protocol@17 {
+				reg = <0x17>;
+
+				scmi_regu: regulators {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					scmi_vddio1: regulator@0 {
+						voltd-name = "vddio1";
+						reg = <VOLTD_SCMI_VDDIO1>;
+						regulator-name = "vddio1";
+					};
+					scmi_vddio2: regulator@1 {
+						voltd-name = "vddio2";
+						reg = <VOLTD_SCMI_VDDIO2>;
+						regulator-name = "vddio2";
+					};
+					scmi_vddio3: regulator@2 {
+						voltd-name = "vddio3";
+						reg = <VOLTD_SCMI_VDDIO3>;
+						regulator-name = "vddio3";
+					};
+					scmi_vddio4: regulator@3 {
+						voltd-name = "vddio4";
+						reg = <VOLTD_SCMI_VDDIO4>;
+						regulator-name = "vddio4";
+					};
+					scmi_vdd33ucpd: regulator@5 {
+						voltd-name = "vdd33ucpd";
+						reg = <VOLTD_SCMI_UCPD>;
+						regulator-name = "vdd33ucpd";
+					};
+					scmi_vdda18adc: regulator@7 {
+						voltd-name = "vdda18adc";
+						reg = <VOLTD_SCMI_ADC>;
+						regulator-name = "vdda18adc";
+					};
+					scmi_vddgpu: regulator@8 {
+						voltd-name = "vddgpu";
+						reg = <VOLTD_SCMI_GPU>;
+						regulator-name = "vddgpu";
+					};
+				};
+			};
+		};
+	};
+
+	intc: interrupt-controller@4ac00000 {
+		compatible = "arm,cortex-a7-gic";
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		reg = <0x0 0x4ac10000 0x0 0x1000>,
+		      <0x0 0x4ac20000 0x0 0x2000>,
+		      <0x0 0x4ac40000 0x0 0x2000>,
+		      <0x0 0x4ac60000 0x0 0x2000>;
+
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		v2m0: v2m@48090000 {
+			compatible = "arm,gic-v2m-frame";
+			reg = <0x0 0x48090000 0x0 0x1000>;
+			msi-controller;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+
+		CPU_PD0: power-domain-cpu0 {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+
+		CLUSTER_PD: power-domain-cluster {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&STOP1>, <&LP_STOP1>;
+			power-domains = <&RET_PD>;
+		};
+
+		RET_PD: power-domain-retention {
+			#power-domain-cells = <0>;
+			domain-idle-states = <&LPLV_STOP1>;
+		};
+	};
+
+	thermal-zones {
+		cpu0-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 0>;
+
+			trips {
+				cpu0_crit {
+					temperature = <95000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+
+		cpu1-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <1000>;
+			thermal-sensors = <&dts 1>;
+
+			trips {
+				cpu1_crit {
+					temperature = <95000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&intc>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_LOW)>;
+		arm,no-tick-in-suspend;
+	};
+
+	usb2_phy1: usb2-phy1 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2400>;
+		clocks          = <&rcc CK_KER_USB2PHY1>;
+		resets          = <&rcc USB2PHY1_R>;
+		status          = "disabled";
+	};
+
+	usb2_phy2: usb2-phy2 {
+		compatible      = "st,stm32mp25-usb2phy";
+		#phy-cells      = <0>;
+		#clock-cells    = <0>;
+		st,syscfg       = <&syscfg 0x2800>;
+		clocks          = <&rcc CK_KER_USB2PHY2EN>;
+		resets          = <&rcc USB2PHY2_R>;
+		status          = "disabled";
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges = <0x0 0x0 0x0 0x80000000>;
+
+		hpdma: dma-controller@40400000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40400000 0x1000>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 39 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA1>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma2: dma-controller@40410000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40410000 0x1000>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA2>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		hpdma3: dma-controller@40420000 {
+			compatible = "st,stm32-dma3";
+			reg = <0x40420000 0x1000>;
+			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&scmi_clk CK_SCMI_HPDMA3>;
+			power-domains = <&RET_PD>;
+			#dma-cells = <3>;
+			st,axi-max-burst-len = <16>;
+		};
+
+		ipcc1: mailbox@40490000 {
+			compatible = "st,stm32mp1-ipcc";
+			#mbox-cells = <1>;
+			reg = <0x40490000 0x400>;
+			st,proc-id = <0>;
+			interrupts = <GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "rx", "tx";
+			clocks = <&scmi_clk CK_SCMI_IPCC1>;
+			status = "disabled";
+		};
+
+		ommanager: ommanager@40500000 {
+			#address-cells = <2>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp25-omm";
+			reg = <0x40500000 0x400>, <0x60000000 0x10000000>;
+			reg-names = "omm", "omm_mm";
+			clocks = <&rcc CK_BUS_OSPIIOM>;
+			resets = <&rcc OSPIIOM_R>;
+			st,syscfg-amcr = <&syscfg 0x2c00 0x7>;
+			feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPIM_ID>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+			ranges = <0 0 0x40430000 0x400>,
+				 <1 0 0x40440000 0x400>;
+
+			ospi1: spi@40430000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <0 0 0x400>;
+				interrupts = <GIC_SPI 163 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 2 0x62 0x00003121>,
+				       <&hpdma 2 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1000>;
+				clocks = <&scmi_clk CK_SCMI_OSPI1>;
+				resets = <&scmi_reset RST_SCMI_OSPI1>, <&scmi_reset RST_SCMI_OSPI1DLL>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ospi2: spi@40440000 {
+				compatible = "st,stm32mp25-omi";
+				reg = <1 0 0x400>;
+				interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 3 0x62 0x00003121>,
+				       <&hpdma 3 0x42 0x00003112>;
+				dma-names = "tx", "rx";
+				st,syscfg-dlyb = <&syscfg 0x1400>;
+				clocks = <&scmi_clk CK_SCMI_OSPI2>;
+				resets = <&scmi_reset RST_SCMI_OSPI2>, <&scmi_reset RST_SCMI_OSPI2DLL>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_OCTOSPI2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		rifsc: rifsc@42080000 {
+			compatible = "st,stm32mp25-sys-bus";
+			reg = <0x42080000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+			feature-domain-controller;
+			#feature-domain-cells = <1>;
+
+			timers2: timer@40000000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40000000 0x400>;
+				interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM2>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@1 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers3: timer@40010000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40010000 0x400>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM3>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@2 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers4: timer@40020000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40020000 0x400>;
+				interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM4>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@3 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers5: timer@40030000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40030000 0x400>;
+				interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM5>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@4 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers6: timer@40040000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40040000 0x400>;
+				interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM6>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@5 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <5>;
+					status = "disabled";
+				};
+			};
+
+			timers7: timer@40050000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40050000 0x400>;
+				interrupts = <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM7>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				timer@6 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <6>;
+					status = "disabled";
+				};
+			};
+
+			timers12: timer@40060000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40060000 0x400>;
+				interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM12>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM12_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@11 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <11>;
+					status = "disabled";
+				};
+			};
+
+			timers13: timer@40070000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40070000 0x400>;
+				interrupts = <GIC_SPI 203 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM13>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM13_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@12 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <12>;
+					status = "disabled";
+				};
+			};
+
+			timers14: timer@40080000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40080000 0x400>;
+				interrupts = <GIC_SPI 204 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM14>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM14_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@13 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <13>;
+					status = "disabled";
+				};
+			};
+
+			lptimer1: timer@40090000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x40090000 0x400>;
+				interrupts-extended = <&exti1 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM1>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM1_ID>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@0 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+			};
+
+			lptimer2: timer@400a0000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x400a0000 0x400>;
+				interrupts-extended = <&exti1 48 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM2>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM2_ID>;
+				power-domains = <&RET_PD>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@1 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <1>;
+					status = "disabled";
+				};
+			};
+
+			i2s2: audio-controller@400b0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400b0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI2>, <&rcc CK_KER_SPI2>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x43 0x12>,
+					<&hpdma 52 0x43 0x21>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI2_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi2: spi@400b0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400b0000 0x400>;
+				interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI2>;
+				resets = <&rcc SPI2_R>;
+				dmas = <&hpdma 51 0x20 0x00003012>,
+				       <&hpdma 52 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2s3: audio-controller@400c0000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x400c0000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI3>, <&rcc CK_KER_SPI3>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x43 0x12>,
+					<&hpdma 54 0x43 0x21>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI3_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi3: spi@400c0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x400c0000 0x400>;
+				interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI3>;
+				resets = <&rcc SPI3_R>;
+				dmas = <&hpdma 53 0x20 0x00003012>,
+				       <&hpdma 54 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spdifrx: audio-controller@400d0000 {
+				compatible = "st,stm32h7-spdifrx";
+				#sound-dai-cells = <0>;
+				reg = <0x400d0000 0x400>;
+				clocks = <&rcc CK_KER_SPDIFRX>;
+				clock-names = "kclk";
+				interrupts = <GIC_SPI 170 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 71 0x43 0x212>,
+					<&hpdma 72 0x43 0x212>;
+				dma-names = "rx", "rx-ctrl";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPDIFRX_ID>;
+				status = "disabled";
+			};
+
+			usart2: serial@400e0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400e0000 0x400>;
+				interrupts-extended = <&exti1 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART2>;
+				dmas = <&hpdma 11 0x20 0x10012>,
+				       <&hpdma 12 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			usart3: serial@400f0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x400f0000 0x400>;
+				interrupts-extended = <&exti1 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART3>;
+				dmas = <&hpdma 13 0x20 0x10012>,
+				       <&hpdma 14 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart4: serial@40100000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40100000 0x400>;
+				interrupts-extended = <&exti1 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART4>;
+				dmas = <&hpdma 15 0x20 0x10012>,
+				       <&hpdma 16 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart5: serial@40110000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40110000 0x400>;
+				interrupts-extended = <&exti1 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART5>;
+				dmas = <&hpdma 17 0x20 0x10012>,
+				       <&hpdma 18 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2c1: i2c@40120000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40120000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C1>;
+				resets = <&rcc I2C1_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 27 0x20 0x00003012>,
+				       <&hpdma 28 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@40130000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40130000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C2>;
+				resets = <&rcc I2C2_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 30 0x20 0x00003012>,
+				       <&hpdma 31 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@40140000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40140000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C3>;
+				resets = <&rcc I2C3_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 33 0x20 0x00003012>,
+				       <&hpdma 34 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@40150000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40150000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C4>;
+				resets = <&rcc I2C4_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 36 0x20 0x00003012>,
+				       <&hpdma 37 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c5: i2c@40160000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40160000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C5>;
+				resets = <&rcc I2C5_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 39 0x20 0x00003012>,
+				       <&hpdma 40 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@40170000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40170000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C6>;
+				resets = <&rcc I2C6_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 42 0x20 0x00003012>,
+				       <&hpdma 43 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i2c7: i2c@40180000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x40180000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C7>;
+				resets = <&rcc I2C7_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 45 0x20 0x00003012>,
+				       <&hpdma 46 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c1: i3c@40190000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x40190000 0x400>;
+				interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C1>;
+				resets = <&rcc I3C1_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c2: i3c@401a0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401a0000 0x400>;
+				interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C2>;
+				resets = <&rcc I3C2_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			i3c3: i3c@401b0000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x401b0000 0x400>;
+				interrupts = <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C3>;
+				resets = <&rcc I3C3_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers10: timer@401c0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401c0000 0x400>;
+				interrupts = <GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM10>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM10_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@9 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <9>;
+					status = "disabled";
+				};
+			};
+
+			timers11: timer@401d0000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x401d0000 0x400>;
+				interrupts = <GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM11>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM11_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@10 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <10>;
+					status = "disabled";
+				};
+			};
+
+			timers1: timer@40200000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40200000 0x400>;
+				interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM1>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@0 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <0>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			timers8: timer@40210000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40210000 0x400>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 121 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM8>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@7 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <7>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart6: serial@40220000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40220000 0x400>;
+				interrupts-extended = <&exti1 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART6>;
+				dmas = <&hpdma 19 0x20 0x10012>,
+				       <&hpdma 20 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			i2s1: audio-controller@40230000 {
+				compatible = "st,stm32mp25-i2s";
+				reg = <0x40230000 0x400>;
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_SPI1>, <&rcc CK_KER_SPI1>;
+				clock-names = "pclk", "i2sclk";
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x43 0x12>,
+					<&hpdma 50 0x43 0x21>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI1_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+			};
+
+			spi1: spi@40230000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40230000 0x400>;
+				interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI1>;
+				resets = <&rcc SPI1_R>;
+				dmas = <&hpdma 49 0x20 0x00003012>,
+				       <&hpdma 50 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi4: spi@40240000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40240000 0x400>;
+				interrupts = <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI4>;
+				resets = <&rcc SPI4_R>;
+				dmas = <&hpdma 55 0x20 0x00003012>,
+				       <&hpdma 56 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			timers15: timer@40250000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40250000 0x400>;
+				interrupts = <GIC_SPI 193 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM15>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM15_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@14 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <14>;
+					status = "disabled";
+				};
+			};
+
+			timers16: timer@40260000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40260000 0x400>;
+				interrupts = <GIC_SPI 194 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM16>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM16_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@15 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <15>;
+					status = "disabled";
+				};
+			};
+
+			timers17: timer@40270000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40270000 0x400>;
+				interrupts = <GIC_SPI 195 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "global";
+				clocks = <&rcc CK_KER_TIM17>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM17_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@16 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <16>;
+					status = "disabled";
+				};
+			};
+
+			spi5: spi@40280000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40280000 0x400>;
+				interrupts = <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI5>;
+				resets = <&rcc SPI5_R>;
+				dmas = <&hpdma 57 0x20 0x00003012>,
+				       <&hpdma 58 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI5_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sai1: sai@40290000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40290000 0x4>, <0x4029a3f0 0x10>;
+				ranges = <0 0x40290000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI1>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI1_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai1a: audio-controller@40290004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 73 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai1b: audio-controller@40290024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI1>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 74 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai2: sai@402a0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402a0000 0x4>, <0x402aa3f0 0x10>;
+				ranges = <0 0x402a0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI2>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 162 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI2_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai2a: audio-controller@402a0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 75 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai2b: audio-controller@402a0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI2>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 76 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			sai3: sai@402b0000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x402b0000 0x4>, <0x402ba3f0 0x10>;
+				ranges = <0 0x402b0000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI3>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 192 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI3_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai3a: audio-controller@402b0004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 77 0x43 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai3b: audio-controller@502b0024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI3>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 78 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			uart9: serial@402c0000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x402c0000 0x400>;
+				interrupts-extended = <&exti1 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART9>;
+				dmas = <&hpdma 25 0x20 0x10012>,
+				       <&hpdma 26 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART9_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			timers20: timer@40320000 {
+				compatible = "st,stm32mp25-timers";
+				reg = <0x40320000 0x400>;
+				interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "brk", "up", "trg-com", "cc";
+				clocks = <&rcc CK_KER_TIM20>;
+				clock-names = "int";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_TIM20_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				pwm {
+					compatible = "st,stm32mp25-pwm";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer@19 {
+					compatible = "st,stm32mp25-timer-trigger";
+					reg = <19>;
+					status = "disabled";
+				};
+
+				counter {
+					compatible = "st,stm32mp25-timer-counter";
+					status = "disabled";
+				};
+			};
+
+			usart1: serial@40330000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40330000 0x400>;
+				interrupts-extended = <&exti1 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_USART1>;
+				dmas = <&hpdma 9 0x20 0x10012>,
+				       <&hpdma 10 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_USART1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			sai4: sai@40340000 {
+				compatible = "st,stm32mp25-sai";
+				reg = <0x40340000 0x4>, <0x4034a3f0 0x10>;
+				ranges = <0 0x40340000 0x400>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_BUS_SAI4>;
+				clock-names = "pclk";
+				interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc SAI4_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SAI4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				sai4a: audio-controller@40340004 {
+					compatible = "st,stm32-sai-sub-a";
+					reg = <0x4 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 79 0x63 0x21>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+
+				sai4b: audio-controller@40340024 {
+					compatible = "st,stm32-sai-sub-b";
+					reg = <0x24 0x20>;
+					#sound-dai-cells = <0>;
+					clocks = <&rcc CK_KER_SAI4>;
+					clock-names = "sai_ck";
+					dmas = <&hpdma 80 0x43 0x12>;
+					power-domains = <&CLUSTER_PD>;
+					status = "disabled";
+				};
+			};
+
+			spi6: spi@40350000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40350000 0x400>;
+				interrupts = <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI6>;
+				resets = <&rcc SPI6_R>;
+				dmas = <&hpdma 59 0x20 0x00003012>,
+				       <&hpdma 60 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI6_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			spi7: spi@40360000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x40360000 0x400>;
+				interrupts = <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI7>;
+				resets = <&rcc SPI7_R>;
+				dmas = <&hpdma 61 0x20 0x00003012>,
+				       <&hpdma 62 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			uart7: serial@40370000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40370000 0x400>;
+				interrupts-extended = <&exti1 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART7>;
+				dmas = <&hpdma 21 0x20 0x10012>,
+				       <&hpdma 22 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART7_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			uart8: serial@40380000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x40380000 0x400>;
+				interrupts-extended = <&exti1 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_UART8>;
+				dmas = <&hpdma 23 0x20 0x10012>,
+				       <&hpdma 24 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_UART8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+			};
+
+			dcmi: dcmi@404a0000 {
+				compatible = "st,stm32-dcmi";
+				reg = <0x404a0000 0x400>;
+				interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CCI_R>;
+				clocks = <&rcc CK_BUS_CCI>;
+				clock-names = "mclk";
+				dmas = <&hpdma 137 0x60 0x00003012>;
+				dma-names = "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_DCMI_PSSI_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			crc: crc@404c0000 {
+				compatible = "st,stm32f7-crc";
+				reg = <0x404c0000 0x400>;
+				clocks = <&rcc CK_BUS_CRC>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_CRC_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			adc_12: adc@404e0000 {
+				compatible = "st,stm32mp25-adc-core";
+				reg = <0x404e0000 0x400>;
+				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC12>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ADC12_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc1: adc@0 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <0>;
+					dmas = <&hpdma 81 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+				};
+
+				adc2: adc@100 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x100>;
+					interrupt-parent = <&adc_12>;
+					interrupts = <1>;
+					dmas = <&hpdma 82 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			mdf1: mdf@404d0000 {
+				compatible = "st,stm32mp25-mdf";
+				ranges = <0 0x404d0000 0x1000>;
+				reg = <0x404d0000 0x8>, <0x404d0ff0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				clocks = <&rcc CK_KER_MDF1>;
+				clock-names = "ker_ck";
+				clock-ranges;
+				resets = <&rcc MDF1_R>;
+				reset-names = "mdf";
+				feature-domains = <&rifsc STM32MP25_RIFSC_MDF1_ID>;
+				power-domains = <&RET_PD>;
+				status = "disabled";
+
+				sitf0: sitf@80 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x80 0x4>;
+					status = "disabled";
+				};
+
+				sitf1: sitf@100 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x100 0x4>;
+					status = "disabled";
+				};
+
+				sitf2: sitf@180 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x180 0x4>;
+					status = "disabled";
+				};
+
+				sitf3: sitf@200 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x200 0x4>;
+					status = "disabled";
+				};
+
+				sitf4: sitf@280 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x280 0x4>;
+					status = "disabled";
+				};
+
+				sitf5: sitf@300 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x300 0x4>;
+					status = "disabled";
+				};
+
+				sitf6: sitf@380 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x380 0x4>;
+					status = "disabled";
+				};
+
+				sitf7: sitf@400 {
+					compatible = "st,stm32mp25-sitf-mdf";
+					reg = <0x400 0x4>;
+					status = "disabled";
+				};
+
+				filter0: filter@84 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x84 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 63 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter1: filter@104 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x104 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 185 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 64 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter2: filter@184 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x184 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 186 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 65 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter3: filter@204 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x204 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 187 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 66 0x63 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter4: filter@284 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x284 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 188 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 67 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter5: filter@304 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x304 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 189 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 68 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter6: filter@384 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x384 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 69 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+
+				filter7: filter@404 {
+					compatible = "st,stm32mp25-mdf-dmic";
+					reg = <0x404 0x70>;
+					#io-channel-cells = <1>;
+					interrupts = <GIC_SPI 191 IRQ_TYPE_LEVEL_HIGH>;
+					dmas = <&hpdma 70 0x43 0x12>;
+					dma-names = "rx";
+					status = "disabled";
+				};
+			};
+
+			adc_3: adc@404f0000 {
+				compatible = "st,stm32mp25-adc-core";
+				reg = <0x404f0000 0x400>;
+				interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_ADC3>;
+				clock-names = "adc";
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ADC3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				adc3: adc@0 {
+					compatible = "st,stm32mp25-adc";
+					reg = <0x0>;
+					interrupt-parent = <&adc_3>;
+					interrupts = <0>;
+					dmas = <&hpdma 83 0x20 0x12>;
+					dma-names = "rx";
+					#io-channel-cells = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+					nvmem-cells = <&vrefint>;
+					nvmem-cell-names = "vrefint";
+					status = "disabled";
+					channel@14 {
+						reg = <14>;
+						label = "vrefint";
+					};
+					channel@15 {
+						reg = <15>;
+						label = "vddcore";
+					};
+					channel@17 {
+						reg = <17>;
+						label = "vddcpu";
+					};
+					channel@18 {
+						reg = <18>;
+						label = "vddgpu";
+					};
+				};
+			};
+
+			hash: hash@42010000 {
+				compatible = "st,stm32mp13-hash";
+				reg = <0x42010000 0x400>;
+				interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_HASH>;
+				resets = <&rcc HASH_R>;
+				dmas = <&hpdma 6 0x40 0x3021>;
+				dma-names = "in";
+				feature-domains = <&rifsc STM32MP25_RIFSC_HASH_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			rng: rng@42020000 {
+				compatible = "st,stm32mp25-rng";
+				reg = <0x42020000 0x400>;
+				clocks = <&clk_rcbsec>, <&rcc CK_BUS_RNG>;
+				clock-names = "rng_clk", "rng_hclk";
+				resets = <&rcc RNG_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_RNG_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			iwdg1: watchdog@44010000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44010000 0x400>;
+				interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG1>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				feature-domains = <&rifsc STM32MP25_RIFSC_IWDG1_ID>;
+				status = "disabled";
+			};
+
+			iwdg2: watchdog@44020000 {
+				compatible = "st,stm32mp1-iwdg";
+				reg = <0x44020000 0x400>;
+				interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_IWDG2>, <&scmi_clk CK_SCMI_LSI>;
+				clock-names = "pclk", "lsi";
+				feature-domains = <&rifsc STM32MP25_RIFSC_IWDG2_ID>;
+				status = "disabled";
+			};
+
+			spi8: spi@46020000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "st,stm32mp25-spi";
+				reg = <0x46020000 0x400>;
+				interrupts = <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SPI8>;
+				resets = <&rcc SPI8_R>;
+				dmas = <&hpdma 171 0x20 0x00003012>,
+				       <&hpdma 172 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_SPI8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lpuart1: serial@46030000 {
+				compatible = "st,stm32h7-uart";
+				reg = <0x46030000 0x400>;
+				interrupts-extended = <&exti2 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPUART1>;
+				dmas = <&hpdma 166 0x20 0x10012>,
+				       <&hpdma 167 0x20 0x3021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPUART1_ID>;
+				status = "disabled";
+			};
+
+			i2c8: i2c@46040000 {
+				compatible = "st,stm32mp25-i2c";
+				reg = <0x46040000 0x400>;
+				interrupt-names = "event";
+				interrupts = <GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I2C8>;
+				resets = <&rcc I2C8_R>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				dmas = <&hpdma 168 0x20 0x00003012>,
+				       <&hpdma 169 0x20 0x00003021>;
+				dma-names = "rx", "tx";
+				feature-domains = <&rifsc STM32MP25_RIFSC_I2C8_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lptimer3: timer@46050000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46050000 0x400>;
+				interrupts-extended = <&exti2 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM3>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM3_ID>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@2 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <2>;
+					status = "disabled";
+				};
+			};
+
+			lptimer4: timer@46060000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46060000 0x400>;
+				interrupts-extended = <&exti2 30 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM4>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM4_ID>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@3 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <3>;
+					status = "disabled";
+				};
+			};
+
+			lptimer5: timer@46070000 {
+				compatible = "st,stm32mp25-lptimer";
+				reg = <0x46070000 0x400>;
+				interrupts-extended = <&exti2 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_LPTIM5>;
+				clock-names = "mux";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LPTIM5_ID>;
+				wakeup-source;
+				status = "disabled";
+
+				counter {
+					compatible = "st,stm32mp25-lptimer-counter";
+					status = "disabled";
+				};
+
+				pwm {
+					compatible = "st,stm32mp25-pwm-lp";
+					#pwm-cells = <3>;
+					status = "disabled";
+				};
+
+				timer {
+					compatible = "st,stm32mp25-lptimer-timer";
+					status = "disabled";
+				};
+
+				trigger@4 {
+					compatible = "st,stm32mp25-lptimer-trigger";
+					reg = <4>;
+					status = "disabled";
+				};
+			};
+
+			i3c4: i3c@46080000 {
+				#address-cells = <3>;
+				#size-cells = <0>;
+				compatible = "st,stm32-i3c";
+				reg = <0x46080000 0x400>;
+				interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_I3C4>;
+				resets = <&rcc I3C4_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_I3C4_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			ltdc: display-controller@48010000 {
+				compatible = "st,stm32mp25-ltdc";
+				reg = <0x48010000 0x400>;
+				st,syscon = <&syscfg>;
+				interrupts = <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>;
+				clock-names = "bus", "lcd";
+				resets = <&rcc LTDC_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LTDC_CMN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			csi2host: csi2host@48020000 {
+				compatible = "st,stm32-csi2host";
+				reg = <0x48020000 0x2000>;
+				interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc CSI_R>;
+				clocks = <&rcc CK_KER_CSI>, <&rcc CK_KER_CSITXESC>,
+					 <&rcc CK_KER_CSIPHY>;
+				clock-names = "pclk", "txesc", "csi2phy";
+				feature-domains = <&rifsc STM32MP25_RIFSC_CSI_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			dcmipp: dcmipp@48030000 {
+				compatible = "st,stm32mp25-dcmipp";
+				reg = <0x48030000 0x1000>;
+				interrupts = <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc DCMIPP_R>;
+				clocks = <&rcc CK_BUS_DCMIPP>, <&rcc CK_KER_CSI>;
+				clock-names = "kclk", "mclk";
+				feature-domains = <&rifsc STM32MP25_RIFSC_DCMIPP_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			combophy: phy@480c0000 {
+				compatible = "st,stm32mp25-combophy";
+				reg = <0x480c0000 0x1000>;
+				#phy-cells = <1>;
+				clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>;
+				clock-names = "apb-clk", "ker-clk";
+				resets = <&rcc USB3PCIEPHY_R>;
+				reset-names = "phy-rst";
+				st,syscfg = <&syscfg>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_COMBOPHY_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 45 IRQ_TYPE_EDGE_FALLING>;
+				status = "disabled";
+			};
+
+			sdmmc1: mmc@48220000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48220000 0x400>, <0x44230400 0x8>;
+				interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC1>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC1_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SDMMC1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc2: mmc@48230000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48230000 0x400>, <0x44230800 0x8>;
+				interrupts = <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC2>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC2_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SDMMC2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			sdmmc3: mmc@48240000 {
+				compatible = "st,stm32mp25-sdmmc2", "arm,pl18x", "arm,primecell";
+				arm,primecell-periphid = <0x00353180>;
+				reg = <0x48240000 0x400>, <0x44230c00 0x8>;
+				interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&rcc CK_KER_SDMMC3>;
+				clock-names = "apb_pclk";
+				resets = <&rcc SDMMC3_R>;
+				cap-sd-highspeed;
+				cap-mmc-highspeed;
+				max-frequency = <120000000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_SDMMC3_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			eth1: eth1@482c0000 {
+				compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+				reg = <0x482c0000 0x4000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti1 68 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ptp_ref",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc CK_ETH1_MAC>,
+					 <&rcc CK_ETH1_TX>,
+					 <&rcc CK_ETH1_RX>,
+					 <&rcc CK_KER_ETH1PTP>,
+					 <&rcc CK_ETH1_STP>,
+					 <&rcc CK_KER_ETH1>;
+				st,syscon = <&syscfg 0x3000 0xffffffff>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,txqos = <7>;
+				snps,rxqos = <7>;
+				snps,axi-config = <&stmmac_axi_config_1>;
+				snps,tso;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ETH1_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+				snps,mtl-rx-config = <&mtl_rx_setup_1>;
+				snps,mtl-tx-config = <&mtl_tx_setup_1>;
+
+				stmmac_axi_config_1: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+
+				mtl_rx_setup_1: rx-queues-config {
+					snps,rx-queues-to-use = <2>;
+					queue0 {};
+					queue1 {};
+				};
+
+				mtl_tx_setup_1: tx-queues-config {
+					snps,tx-queues-to-use = <4>;
+					queue0 {};
+					queue1 {};
+					queue2 {};
+					queue3 {};
+				};
+			};
+
+			usbh: usb@482e0000 {
+				compatible = "st,stm32mp25-usbh";
+				st,syscfg = <&syscfg 0x2420>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x482e0000 0x482e0000 0x20000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_USBH_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 43 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				usbh_ohci: usb@482e0000 {
+					compatible = "generic-ohci";
+					reg = <0x482e0000 0x1000>;
+					clocks = <&usb2_phy1>, <&rcc CK_BUS_USB2OHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+
+				usbh_ehci: usb@482f0000 {
+					compatible = "generic-ehci";
+					reg = <0x482f0000 0x1000>;
+					clocks = <&rcc CK_BUS_USB2EHCI>;
+					resets = <&rcc USB2_R>;
+					interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+					companion = <&usbh_ohci>;
+					phys = <&usb2_phy1>;
+					phy-names = "usb";
+					wakeup-source;
+				};
+			};
+
+			usb3dr: usb@48300000 {
+				compatible = "st,stm32mp25-dwc3";
+				st,syscfg = <&syscfg 0x4800>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x48300000 0x48300000 0x100000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_USB3DR_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				interrupts-extended = <&exti1 44 IRQ_TYPE_EDGE_RISING>;
+				status = "disabled";
+
+				dwc3: usb@48300000 {
+					compatible = "snps,dwc3";
+					reg = <0x48300000 0x100000>;
+					interrupts = <GIC_SPI 228 IRQ_TYPE_LEVEL_HIGH>;
+					clock-names = "ref", "bus_early", "suspend";
+					clocks = <&rcc CK_KER_USB2PHY2>, <&rcc CK_BUS_USB3DR>,
+						 <&rcc CK_KER_USB2PHY2>;
+					resets = <&rcc USB3DR_R>;
+					phys = <&usb2_phy2>;
+					phy-names = "usb2-phy";
+					wakeup-source;
+				};
+			};
+
+			pcie_ep: pcie-ep@48400000 {
+				compatible = "st,stm32mp25-pcie-ep";
+				num-lanes = <1>;
+				reg = <0x48400000 0x400000>,
+				      <0x10000000 0x8000000>;
+				reg-names = "dbi", "addr_space";
+				st,syscfg = <&syscfg>;
+				clocks = <&rcc CK_BUS_PCIE>;
+				clock-names = "core";
+				resets = <&rcc PCIE_R>;
+				reset-names = "pcie";
+				phys = <&combophy PHY_TYPE_PCIE>;
+				phy-names = "pcie-phy";
+				feature-domains = <&rifsc STM32MP25_RIFSC_PCIE_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			pcie_rc: pcie@48400000 {
+				compatible = "st,stm32mp25-pcie-rc";
+				device_type = "pci";
+				num-lanes = <1>;
+				reg = <0x48400000 0x400000>,
+				      <0x10000000 0x10000>;
+				reg-names = "dbi", "config";
+				st,syscfg = <&syscfg>;
+				#interrupt-cells = <1>;
+				interrupt-map-mask = <0 0 0 7>;
+				interrupt-map = <0 0 0 1 &intc 0 0 GIC_SPI 264 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 2 &intc 0 0 GIC_SPI 265 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 3 &intc 0 0 GIC_SPI 266 IRQ_TYPE_LEVEL_HIGH>,
+						<0 0 0 4 &intc 0 0 GIC_SPI 267 IRQ_TYPE_LEVEL_HIGH>;
+				interrupts = <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "aer_msi", "pme_msi";
+				#address-cells = <3>;
+				#size-cells = <2>;
+				ranges = <0x01000000 0 0x10010000 0x10010000 0 0x10000>,
+					 <0x02000000 0 0x10020000 0x10020000 0 0x7fe0000>,
+					 <0x42000000 0 0x18000000 0x18000000 0 0x8000000>;
+				bus-range = <0x00 0xff>;
+				clocks = <&rcc CK_BUS_PCIE>;
+				clock-names = "core";
+				resets = <&rcc PCIE_R>;
+				reset-names = "pcie";
+				phys = <&combophy PHY_TYPE_PCIE>;
+				phy-names = "pcie-phy";
+
+				msi-parent = <&v2m0>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_PCIE_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+		};
+
+		risaf1: risaf@420a0000 {
+			compatible = "st,stm32mp25-risaf";
+			reg = <0x420a0000 0x1000>;
+			clocks = <&rcc CK_BUS_BKPSRAM>;
+			st,mem-map = <0x0 0x42000000 0x0 0x2000>;
+		};
+
+		risaf4: risaf@420d0000 {
+			compatible = "st,stm32mp25-risaf-enc";
+			reg = <0x420d0000 0x1000>;
+			clocks = <&rcc CK_BUS_RISAF4>;
+			st,mem-map = <0x0 0x80000000 0x1 0x00000000>;
+		};
+
+		bsec: efuse@44000000 {
+			compatible = "st,stm32mp25-bsec";
+			reg = <0x44000000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			part_number_otp@24 {
+				reg = <0x24 0x4>;
+			};
+
+			vrefint: vrefin-cal@1b8 {
+				reg = <0x1b8 0x2>;
+			};
+
+			package_otp@1e8 {
+				reg = <0x1e8 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		dts: thermal-sensor@44070000 {
+			compatible = "moortec,mr75203";
+			reg = <0x44070000 0x80>,
+			      <0x44070080 0x180>,
+			      <0x44070200 0x200>,
+			      <0x44070400 0xc00>;
+			reg-names = "common", "ts", "pd", "vm";
+			clocks = <&rcc CK_KER_DTS>;
+			resets = <&rcc DTS_R>;
+			#thermal-sensor-cells = <1>;
+		};
+
+		rcc: rcc@44200000 {
+			compatible = "st,stm32mp25-rcc";
+			reg = <0x44200000 0x10000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			clock-names = "hse", "hsi", "msi", "lse", "lsi";
+			clocks = <&scmi_clk CK_SCMI_HSE>,
+				<&scmi_clk CK_SCMI_HSI>,
+				<&scmi_clk CK_SCMI_MSI>,
+				<&scmi_clk CK_SCMI_LSE>,
+				<&scmi_clk CK_SCMI_LSI>;
+			feature-domains = <&rifsc 156>;
+		};
+
+		pwr: syscon@44210000 {
+			compatible = "st,stm32mp25-pwr", "syscon";
+			reg = <0x44210000 0x0400>;
+		};
+
+		exti1: interrupt-controller@44220000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x44220000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 268 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 269 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 270 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 271 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 272 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 273 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 274 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 275 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 276 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 277 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 278 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 279 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 280 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 281 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 0   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 1   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 260 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 150 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<&intc GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 182 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 209 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 229 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 166 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 210 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 220 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 10  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 131 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_70 */
+				<0>,
+				<&intc GIC_SPI 224 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 202 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 254 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 255 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,						/* EXTI_80 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		syscfg: syscon@44230000 {
+			compatible = "st,stm32mp25-syscfg", "syscon";
+			reg = <0x44230000 0x10000>;
+			#clock-cells = <1>;
+		};
+
+		pinctrl: pinctrl@44240000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-pinctrl";
+			ranges = <0 0x44240000 0xa0400>;
+			interrupt-parent = <&exti1>;
+			pins-are-numbered;
+			interrupts-extended =
+				<&exti1  0 0>, <&exti1  1 0>, <&exti1  2 0>, <&exti1  3 0>,
+				<&exti1  4 0>, <&exti1  5 0>, <&exti1  6 0>, <&exti1  7 0>,
+				<&exti1  8 0>, <&exti1  9 0>, <&exti1 10 0>, <&exti1 11 0>,
+				<&exti1 12 0>, <&exti1 13 0>, <&exti1 14 0>, <&exti1 15 0>,
+				<&exti2  0 0>, <&exti2  1 0>, <&exti2  2 0>, <&exti2  3 0>,
+				<&exti2  4 0>, <&exti2  5 0>, <&exti2  6 0>, <&exti2  7 0>,
+				<&exti2  8 0>, <&exti2  9 0>, <&exti2 10 0>, <&exti2 11 0>,
+				<&exti2 12 0>, <&exti2 13 0>, <&exti2 14 0>, <&exti2 15 0>;
+
+			gpioa: gpio@44240000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOA>;
+				st,bank-name = "GPIOA";
+				status = "disabled";
+			};
+
+			gpiob: gpio@44250000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x10000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOB>;
+				st,bank-name = "GPIOB";
+				status = "disabled";
+			};
+
+			gpioc: gpio@44260000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x20000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOC>;
+				st,bank-name = "GPIOC";
+				status = "disabled";
+			};
+
+			gpiod: gpio@44270000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x30000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOD>;
+				st,bank-name = "GPIOD";
+				status = "disabled";
+			};
+
+			gpioe: gpio@44280000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x40000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOE>;
+				st,bank-name = "GPIOE";
+				status = "disabled";
+			};
+
+			gpiof: gpio@44290000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x50000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOF>;
+				st,bank-name = "GPIOF";
+				status = "disabled";
+			};
+
+			gpiog: gpio@442a0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x60000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOG>;
+				st,bank-name = "GPIOG";
+				status = "disabled";
+			};
+
+			gpioh: gpio@442b0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x70000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOH>;
+				st,bank-name = "GPIOH";
+				status = "disabled";
+			};
+
+			gpioi: gpio@442c0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x80000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOI>;
+				st,bank-name = "GPIOI";
+				status = "disabled";
+			};
+
+			gpioj: gpio@442d0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0x90000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOJ>;
+				st,bank-name = "GPIOJ";
+				status = "disabled";
+			};
+
+			gpiok: gpio@442e0000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0xa0000 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOK>;
+				st,bank-name = "GPIOK";
+				status = "disabled";
+			};
+		};
+
+		rtc: rtc@46000000 {
+			compatible = "st,stm32mp25-rtc";
+			reg = <0x46000000 0x400>;
+			clocks = <&scmi_clk CK_SCMI_RTC>,
+				 <&scmi_clk CK_SCMI_RTCCK>;
+			clock-names = "pclk", "rtc_ck";
+			interrupts-extended = <&exti2 17 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		tamp: tamp@46010000 {
+			compatible = "st,stm32mp25-tamp", "syscon", "simple-mfd";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x46010000 0x400>;
+			ranges;
+
+			nvram: nvram@46010100 {
+				compatible = "st,stm32mp25-tamp-nvram";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x46010100 0x200>;
+
+				boot_mode: tamp-bkp@180 {
+					reg = <0x180 0x4>;
+				};
+				rsc_tbl_addr: tamp-bkp@184 {
+					reg = <0x184 0x4>;
+				};
+				rsc_tbl_size: tamp-bkp@188 {
+					reg = <0x188 0x4>;
+				};
+			};
+
+			reboot_mode: reboot-mode {
+				compatible = "nvmem-reboot-mode";
+				nvmem-cells = <&boot_mode>;
+				nvmem-cell-names = "reboot-mode";
+				mode-normal = <0x00>;
+				mode-fastboot = <0x01>;
+				mode-recovery = <0x02>;
+				mode-stm32cubeprogrammer = <0x03>;
+				mode-ums_mmc0 = <0x10>;
+				mode-ums_mmc1 = <0x11>;
+				mode-ums_mmc2 = <0x12>;
+				mode-romcode_serial = <0xff>;
+			};
+		};
+
+		pinctrl_z: pinctrl@46200000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "st,stm32mp257-z-pinctrl";
+			ranges = <0 0x46200000 0x400>;
+			interrupt-parent = <&exti1>;
+			pins-are-numbered;
+
+			gpioz: gpio@46200000 {
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				reg = <0 0x400>;
+				clocks = <&scmi_clk CK_SCMI_GPIOZ>;
+				st,bank-name = "GPIOZ";
+				st,bank-ioport = <11>;
+				status = "disabled";
+			};
+		};
+
+		exti2: interrupt-controller@46230000 {
+			compatible = "st,stm32mp1-exti";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0x46230000 0x400>;
+			interrupts-extended =
+				<&intc GIC_SPI 17  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_0 */
+				<&intc GIC_SPI 18  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 19  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 20  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 21  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 22  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 23  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 24  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 25  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 26  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 27  IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_10 */
+				<&intc GIC_SPI 28  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 29  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 30  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 31  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 32  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 12  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 13  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_20 */
+				<&intc GIC_SPI 14  IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 15  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 212 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 151 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_30 */
+				<&intc GIC_SPI 218 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 207 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_40 */
+				<0>,
+				<0>,
+				<&intc GIC_SPI 200 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 11  IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 5   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 4   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 6   IRQ_TYPE_LEVEL_HIGH>,	/* EXTI_50 */
+				<&intc GIC_SPI 7   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 2   IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 3   IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,
+				<0>,						/* EXTI_60 */
+				<&intc GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<&intc GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+				<&intc GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH>,
+				<0>,
+				<0>,
+				<&intc GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>;	/* EXTI_70 */
+		};
+
+		fmc: memory-controller@48200000 {
+			compatible = "st,stm32mp25-fmc2-ebi";
+			reg = <0x48200000 0x400>;
+			ranges = <0 0 0x70000000 0x04000000>, /* EBI CS 1 */
+				 <1 0 0x74000000 0x04000000>, /* EBI CS 2 */
+				 <2 0 0x78000000 0x04000000>, /* EBI CS 3 */
+				 <3 0 0x7c000000 0x04000000>, /* EBI CS 4 */
+				 <4 0 0x48810000 0x00001000>; /* NAND */
+			#address-cells = <2>;
+			#size-cells = <1>;
+			clocks = <&scmi_clk CK_SCMI_FMC>;
+			resets = <&scmi_reset RST_SCMI_FMC>;
+			power-domains = <&CLUSTER_PD>;
+			status = "disabled";
+
+			nand-controller@4,0 {
+				compatible = "st,stm32mp25-fmc2-nfc";
+				reg = <4 0x0000 0x10>,
+				      <4 0x0090 0x10>,
+				      <4 0x00a0 0x10>,
+				      <4 0x0400 0x10>,
+				      <4 0x0490 0x10>,
+				      <4 0x04a0 0x10>,
+				      <4 0x0800 0x10>,
+				      <4 0x0890 0x10>,
+				      <4 0x08a0 0x10>,
+				      <4 0x0c00 0x10>,
+				      <4 0x0c90 0x10>,
+				      <4 0x0ca0 0x10>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+				interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+				dmas = <&hpdma 0 0x62 0x00003101>,
+				       <&hpdma 0 0x62 0x00003110>,
+				       <&hpdma 1 0x22 0x00003113>;
+				dma-names = "tx", "rx", "ecc";
+				status = "disabled";
+			};
+		};
+
+		a35ss_syscfg: syscon@48802000  {
+			compatible = "st,stm32mp25-a35ss-syscfg", "syscon";
+			reg = <0x48802000 0xac>;
+			status = "disabled";
+		};
+
+		cs_funnel: funnel@4a020000 {
+			compatible = "arm,coresight-dynamic-funnel", "arm,primecell";
+			reg = <0x4a020000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					funnel_in_port0: endpoint {
+						remote-endpoint = <&etm0_out_port>;
+					};
+				};
+
+				port@2 {
+					reg = <2>;
+					funnel_in_port2: endpoint {
+						remote-endpoint = <&stm_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					funnel_out_port: endpoint {
+						remote-endpoint = <&etf_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etf: etf@4a030000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a030000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					etf_in_port: endpoint {
+						remote-endpoint = <&funnel_out_port>;
+					};
+				};
+			};
+
+			out-ports {
+				port {
+					etf_out_port: endpoint {
+						remote-endpoint = <&replicator_in_port>;
+					};
+				};
+			};
+		};
+
+		cs_etr: etr@4a040000 {
+			compatible = "arm,coresight-tmc", "arm,primecell";
+			reg = <0x4a040000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_BUS_ETR>, <&scmi_clk CK_SCMI_KER_ETR>;
+			clock-names = "apb_pclk", "atclk";
+			arm,max-burst-size = <3>;
+			arm,scatter-gather;
+			status = "disabled";
+
+			in-ports {
+				port {
+					etr_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port0>;
+					};
+				};
+			};
+		};
+
+		cs_tpiu: tpiu@4a050000 {
+			compatible = "arm,coresight-tpiu", "arm,primecell";
+			reg = <0x4a050000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_TPIU>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			in-ports {
+				port {
+					tpiu_in_port: endpoint {
+						remote-endpoint = <&replicator_out_port1>;
+					};
+				};
+			};
+		};
+
+		cs_stm: stm@4a080000 {
+			compatible = "arm,coresight-stm", "arm,primecell";
+			reg = <0x4a080000 0x1000>,
+			      <0x4a800000 0x400000>;
+			reg-names = "stm-base", "stm-stimulus-base";
+			clocks = <&scmi_clk CK_SCMI_BUS_STM>, <&scmi_clk CK_SCMI_KER_STM>;
+			clock-names = "apb_pclk", "atclk";
+			status = "disabled";
+
+			out-ports {
+				port {
+					stm_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port2>;
+					};
+				};
+			};
+		};
+
+		cs_cti0: cti@4a090000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a090000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0 1>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <0 1>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etr>;
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-in-sigs = <2 3>;
+				arm,trig-in-types = <SNK_FULL
+						     SNK_ACQCOMP>;
+				arm,trig-out-sigs = <2 3>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_etf>;
+			};
+
+			trig-conns@2 {
+				reg = <2>;
+				arm,trig-out-sigs = <4 5>;
+				arm,trig-out-types = <SNK_FLUSHIN
+						      SNK_TRIGIN>;
+				arm,cs-dev-assoc = <&cs_tpiu>;
+			};
+
+			trig-conns@3 {
+				reg = <3>;
+				arm,trig-in-sigs = <4 5 6 7>;
+				arm,trig-in-types = <STM_TOUT_SPTE
+						     STM_TOUT_SW
+						     STM_TOUT_HETE
+						     STM_ASYNCOUT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cti1: cti@4a0a0000 {
+			compatible = "arm,coresight-cti", "arm,primecell";
+			reg = <0x4a0a0000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			trig-conns@0 {
+				reg = <0>;
+				arm,trig-in-sigs = <0>;
+				arm,trig-in-types = <GEN_IO>;
+				arm,trig-out-sigs = <0>;
+				arm,trig-out-types = <GEN_IO>;
+				arm,trig-conn-name = "dbtrgio";
+			};
+
+			trig-conns@1 {
+				reg = <1>;
+				arm,trig-out-sigs = <1 2>;
+				arm,trig-out-types = <STM_HWEVENT
+						      STM_HWEVENT>;
+				arm,cs-dev-assoc = <&cs_stm>;
+			};
+		};
+
+		cs_cpu_debug0: cpu-debug@4a210000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a210000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			status = "disabled";
+		};
+
+		cs_cti_cpu0: cti@4a220000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a220000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu0>;
+			arm,cs-dev-assoc = <&cs_etm0>;
+			status = "disabled";
+		};
+
+		cs_etm0: etm@4a240000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a240000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu0>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm0_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port0>;
+					};
+				};
+			};
+		};
+
+		hdp: pinctrl@54090000 {
+			compatible = "st,stm32mp-hdp";
+			reg = <0x54090000 0x400>;
+			clocks = <&rcc CK_BUS_HDP>;
+			status = "disabled";
+		};
+	};
+
+	mlahb: ahb@1 {
+		compatible = "st,mlahb", "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0xfffffffc>;
+		dma-ranges = <0x0 0x0 0x0 0xfffffffc>;
+
+		m33_rproc: m33@0 {
+			compatible = "st,stm32mp2-m33";
+			reg = <0 0>;
+			resets = <&scmi_reset RST_SCMI_C2_R>,
+				 <&scmi_reset RST_SCMI_C2_HOLDBOOT_R>;
+			reset-names = "mcu_rst", "hold_boot";
+			st,syscfg-cm-state = <&pwr 0x204 0x0000000c>;
+			interrupt-parent = <&intc>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			nvmem-cells = <&rsc_tbl_addr>, <&rsc_tbl_size>;
+			nvmem-cell-names = "rsc-tbl-addr", "rsc-tbl-size";
+
+			status = "disabled";
+		};
+	};
+
+};
diff --git a/arch/arm/dts/stm32mp253.dtsi b/arch/arm/dts/stm32mp253.dtsi
new file mode 100644
index 0000000000..4e9568a56a
--- /dev/null
+++ b/arch/arm/dts/stm32mp253.dtsi
@@ -0,0 +1,183 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp251.dtsi"
+
+/ {
+	cpus {
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a35";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "psci";
+			clocks = <&scmi_perf 0>;
+			clock-names = "cpu";
+			power-domains = <&CPU_PD1>;
+			power-domain-names = "psci";
+		};
+	};
+
+	arm-pmu {
+		interrupts = <GIC_SPI 368 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 369 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>;
+	};
+
+	psci {
+		CPU_PD1: power-domain-cpu1 {
+			#power-domain-cells = <0>;
+			domain-idle-states =  <&CPU_PWRDN>;
+			power-domains = <&CLUSTER_PD>;
+		};
+	};
+
+	timer {
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	soc@0 {
+		rifsc: rifsc@42080000 {
+			m_can1: can@402d0000 {
+				compatible = "bosch,m_can";
+				reg = <0x402d0000 0x400>, <0x40310000 0x1400>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x0 0 0 32 0 0 2 2>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_FDCAN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			m_can3: can@402f0000 {
+				compatible = "bosch,m_can";
+				reg = <0x402f0000 0x400>, <0x40310000 0x2800>;
+				reg-names = "m_can", "message_ram";
+				interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "int0", "int1";
+				clocks = <&rcc CK_BUS_FDCAN>, <&rcc CK_KER_FDCAN>;
+				clock-names = "hclk", "cclk";
+				bosch,mram-cfg = <0x1400 0 0 32 0 0 2 2>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_FDCAN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			eth2: eth2@482d0000 {
+				compatible = "st,stm32mp25-dwmac", "snps,dwmac-5.10a";
+				reg = <0x482d0000 0x4000>;
+				reg-names = "stmmaceth";
+				interrupts-extended = <&intc GIC_SPI 133 IRQ_TYPE_LEVEL_HIGH>,
+						      <&exti1 70 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "macirq",
+						  "eth_wake_irq";
+				clock-names = "stmmaceth",
+					      "mac-clk-tx",
+					      "mac-clk-rx",
+					      "ptp_ref",
+					      "ethstp",
+					      "eth-ck";
+				clocks = <&rcc CK_ETH2_MAC>,
+					 <&rcc CK_ETH2_TX>,
+					 <&rcc CK_ETH2_RX>,
+					 <&rcc CK_KER_ETH2PTP>,
+					 <&rcc CK_ETH2_STP>,
+					 <&rcc CK_KER_ETH2>;
+				st,syscon = <&syscfg 0x3400 0xffffffff>;
+				snps,mixed-burst;
+				snps,pbl = <2>;
+				snps,txqos = <7>;
+				snps,rxqos = <7>;
+				snps,axi-config = <&stmmac_axi_config_2>;
+				snps,tso;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ETH2_ID>;
+				power-domains = <&CLUSTER_PD>;
+				wakeup-source;
+				status = "disabled";
+				snps,mtl-rx-config = <&mtl_rx_setup_2>;
+				snps,mtl-tx-config = <&mtl_tx_setup_2>;
+
+				stmmac_axi_config_2: stmmac-axi-config {
+					snps,wr_osr_lmt = <0x7>;
+					snps,rd_osr_lmt = <0x7>;
+					snps,blen = <0 0 0 0 16 8 4>;
+				};
+
+				mtl_rx_setup_2: rx-queues-config {
+					snps,rx-queues-to-use = <2>;
+					queue0 {};
+					queue1 {};
+				};
+
+				mtl_tx_setup_2: tx-queues-config {
+					snps,tx-queues-to-use = <4>;
+					queue0 {};
+					queue1 {};
+					queue2 {};
+					queue3 {};
+				};
+			};
+		};
+
+		cs_cpu_debug1: cpu-debug@4a310000 {
+			compatible = "arm,coresight-cpu-debug", "arm,primecell";
+			reg = <0x4a310000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+		};
+
+		cs_cti_cpu1: cti@4a320000 {
+			compatible = "arm,coresight-cti-v8-arch", "arm,coresight-cti",
+				     "arm,primecell";
+			reg = <0x4a320000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>;
+			clock-names = "apb_pclk";
+			cpu = <&cpu1>;
+			arm,cs-dev-assoc = <&cs_etm1>;
+			status = "disabled";
+		};
+
+		cs_etm1: etm@4a340000 {
+			compatible = "arm,coresight-etm4x", "arm,primecell";
+			reg = <0x4a340000 0x1000>;
+			clocks = <&scmi_clk CK_SCMI_SYSDBG>, <&scmi_clk CK_SCMI_SYSATB>;
+			clock-names = "apb_pclk", "atclk";
+			cpu = <&cpu1>;
+			status = "disabled";
+
+			out-ports {
+				port {
+					etm1_out_port: endpoint {
+						remote-endpoint = <&funnel_in_port1>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&cs_funnel {
+	in-ports {
+		port@1 {
+			reg = <1>;
+			funnel_in_port1: endpoint {
+				remote-endpoint = <&etm1_out_port>;
+			};
+		};
+	};
+};
+
+&optee {
+	interrupts = <GIC_PPI 15 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+};
diff --git a/arch/arm/dts/stm32mp255.dtsi b/arch/arm/dts/stm32mp255.dtsi
new file mode 100644
index 0000000000..918e1fa945
--- /dev/null
+++ b/arch/arm/dts/stm32mp255.dtsi
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/power/stm32mp25-power-domains.h>
+#include "stm32mp253.dtsi"
+
+/ {
+	soc@0 {
+		rifsc: rifsc@42080000 {
+			dsi: dsi@48000000 {
+				compatible = "st,stm32mp25-dsi";
+				reg = <0x48000000 0x800>;
+				#clock-cells = <0>;
+				clocks = <&rcc CK_BUS_DSI>, <&rcc CK_KER_DSIPHY>,
+					 <&rcc CK_KER_LTDC>;
+				clock-names = "pclk", "ref", "px_clk";
+				resets = <&rcc DSI_R>;
+				reset-names = "apb";
+				feature-domains = <&rifsc STM32MP25_RIFSC_DSI_CMN_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			lvds: lvds@48060000 {
+				#clock-cells = <0>;
+				compatible = "st,stm32mp25-lvds";
+				reg = <0x48060000 0x2000>;
+				clocks = <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+				clock-names = "pclk", "ref";
+				resets = <&rcc LVDS_R>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_LVDS_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+			};
+
+			vdec: vdec@480d0000 {
+				compatible = "st,stm32mp25-vdec";
+				reg = <0x480d0000 0x3c8>;
+				resets = <&rcc VDEC_R>;
+				interrupt-names = "vdec";
+				interrupts = <GIC_SPI 117 IRQ_TYPE_LEVEL_HIGH>;
+				clock-names = "vdec-clk";
+				clocks = <&rcc CK_BUS_VDEC>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_VDEC_ID>;
+				power-domains = <&CLUSTER_PD>;
+			};
+			venc: venc@480e0000 {
+				compatible = "st,stm32mp25-venc";
+				reg = <0x480e0000 0x800>;
+				reset-names = "venc-rst";
+				resets = <&rcc VENC_R>;
+				interrupt-names = "venc";
+				interrupts = <GIC_SPI 167 IRQ_TYPE_LEVEL_HIGH>;
+				clock-names = "venc-clk";
+				clocks = <&rcc CK_BUS_VENC>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_VENC_ID>;
+				power-domains = <&CLUSTER_PD>;
+			};
+
+			gpu: gpu@48280000 {
+				compatible = "vivante,gc";
+				reg = <0x48280000 0x800>;
+				interrupts = <GIC_SPI 183 IRQ_TYPE_LEVEL_HIGH>;
+				resets = <&rcc GPU_R>;
+				clock-names = "axi", "core";
+				clocks = <&rcc CK_BUS_GPU>, <&rcc CK_KER_GPU>;
+				power-domains = <&scmi_devpd PD_SCMI_GPU>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_GPU_ID>;
+				status = "disabled";
+			};
+		};
+	};
+};
+
+&ltdc {
+	clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>, <&syscfg 0>, <&lvds 0>;
+	clock-names = "bus", "ref", "lcd", "lvds";
+};
diff --git a/arch/arm/dts/stm32mp257.dtsi b/arch/arm/dts/stm32mp257.dtsi
new file mode 100644
index 0000000000..f074157b23
--- /dev/null
+++ b/arch/arm/dts/stm32mp257.dtsi
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include "stm32mp255.dtsi"
+
+/ {
+	soc@0 {
+		rifsc: rifsc@42080000 {
+			switch0: ttt-sw@4c000000 {
+				#address-cells  = <1>;
+				#size-cells     = <1>;
+				compatible = "st,stm32-deip";
+				clock-names = "ethsw-bus-clk", "ethsw-clk",
+					      "ethswacmcfg-bus-clk", "ethswacmmsg-bus-clk";
+				clocks = <&rcc CK_BUS_ETHSW>,
+					 <&rcc CK_KER_ETHSW>,
+					 <&rcc CK_BUS_ETHSWACMCFG>,
+					 <&rcc CK_BUS_ETHSWACMMSG>;
+				st,syscon = <&syscfg 0x3800>;
+				ranges = <0x4c000000 0x4c000000 0x2000000>,
+					 <0x4b000000 0x4b000000 0xc0000>;
+				feature-domains = <&rifsc STM32MP25_RIFSC_ETHSW_DEIP_ID>;
+				power-domains = <&CLUSTER_PD>;
+				status = "disabled";
+
+				deip_sw0: deip-sw@4c000000 {
+					compatible =  "ttt,deip-sw";
+					reg = <0x4c000000 0x2000000>;
+					interrupts = <GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				acm@4b000000 {
+					compatible = "ttt,acm-4.0";
+					reg = <0x4b000000 0x00400>,
+					      <0x4b010000 0x10000>,
+					      <0x4b030000 0x10000>,
+					      <0x4b050000 0x10000>,
+					      <0x4b060000 0x20000>,
+					      <0x4b080000 0x40000>;
+					reg-names = "CommonRegister",
+						    "Bypass1",
+						    "Bypass0",
+						    "Redundancy",
+						    "Scheduler",
+						    "Messagebuffer";
+					buffers = <32>;
+					ptp_worker = <&deip_sw0>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi b/arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi
new file mode 100644
index 0000000000..7e2df35693
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-dk-ca35tdcid-resmem.dtsi
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 3/6/2024 11:20:05 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-dk-u-boot.dtsi b/arch/arm/dts/stm32mp257f-dk-u-boot.dtsi
new file mode 100644
index 0000000000..c0920b3947
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-dk-u-boot.dtsi
@@ -0,0 +1,48 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+
+#include "stm32mp25-u-boot.dtsi"
+
+/ {
+	config {
+		u-boot,boot-led = "led-blue";
+		u-boot,mmc-env-partition = "u-boot-env";
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&dwc3 {
+	phys = <&usb2_phy2>;
+	phy-names = "usb2-phy";
+	dr_mode = "peripheral";
+	maximum-speed = "high-speed";
+	/delete-node/ port;
+};
+
+&i2c_rpmsg {
+	/delete-node/ typec@35;
+};
+
+&sdmmc3 {
+	status = "disabled";
+};
+
+&usart2 {
+	u-boot,dm-pre-reloc;
+};
+
+&usart2_pins_a {
+	u-boot,dm-pre-reloc;
+	pins1 {
+		u-boot,dm-pre-reloc;
+	};
+	pins2 {
+		u-boot,dm-pre-reloc;
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-dk.dts b/arch/arm/dts/stm32mp257f-dk.dts
new file mode 100644
index 0000000000..0345d346ef
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-dk.dts
@@ -0,0 +1,754 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/rtc/rtc-stm32.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxak-pinctrl.dtsi"
+#include "stm32mp257f-dk-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-DK Discovery Board";
+	compatible = "st,stm32mp257f-dk", "st,stm32mp257";
+
+	aliases {
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &usart1;
+		ethernet0 = &eth1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		clk_ext_cec: clk-ext-cec {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+	};
+
+	dmic0: dmic-0 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic0";
+
+		port {
+			dmic0_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint0>;
+			};
+		};
+	};
+
+	dmic1: dmic-1 {
+		compatible = "dmic-codec";
+		#sound-dai-cells = <1>;
+		sound-name-prefix = "dmic1";
+
+		port {
+			dmic1_endpoint: endpoint {
+				remote-endpoint = <&mdf_endpoint1>;
+			};
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpioc 5 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpioc 11 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioh 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+		hdmi-pwr-supply = <&scmi_v5v_hdmi>;
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv7535_out>;
+			};
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x0>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpioi 4 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 7 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <0>;
+		status = "okay";
+	};
+
+	sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-DK";
+		dais = <&i2s2_port &mdf1_port0 &mdf1_port1>;
+		status = "okay";
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpiog 8 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&combophy {
+	st,ssc-on;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&csi2host {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi2host_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi2host_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi2host_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv7535_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_b>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_b>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioa 2 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_b>;
+	pinctrl-1 = <&i2c2_sleep_pins_b>;
+	i2c-scl-rising-time-ns = <108>;
+	i2c-scl-falling-time-ns = <12>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		reset-gpios = <&gpiob 1 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpiob 11 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi2host_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv7535: hdmi@3d {
+		compatible = "adi,adv7535";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		status = "okay";
+		adi,dsi-lanes = <4>;
+		clocks = <&clk_ext_cec>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiob>;
+		interrupts = <4 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiob 6 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv7535_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv7535_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv7535_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpioi 0 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	clock-frequency = <100000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_b>;
+	pinctrl-1 = <&i2s2_sleep_pins_b>;
+	status = "okay";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv7535_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&ltdc {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	status = "okay";
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&mdf1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdf_cck0_pins_a>;
+	pinctrl-1 = <&mdf_cck0_sleep_pins_a>;
+	#clock-cells = <0>;
+	clock-output-names = "cck0";
+	clock-frequency = <1536000>;
+	status = "okay";
+
+	sitf6: sitf@380 {
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&mdf_sdi6_pins_a>;
+		pinctrl-1 = <&mdf_sdi6_sleep_pins_a>;
+		st,sitf-mode = "spi";
+		clocks = <&mdf1>;
+		status = "okay";
+	};
+
+	filter0: filter@84  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf6 0>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm0: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter0 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port0: port {
+				mdf_endpoint0: endpoint {
+					remote-endpoint = <&dmic0_endpoint>;
+				};
+			};
+		};
+	};
+
+	filter1: filter@104  {
+		st,cic-mode = <4>;
+		st,sitf = <&sitf6 1>;
+		st,hpf-filter-cutoff-bp = <625>;
+		status = "okay";
+
+		asoc_pdm1: mdf-dai {
+			compatible = "st,stm32mp25-mdf-dai";
+			#sound-dai-cells = <0>;
+			io-channels = <&filter1 0>;
+			power-domains = <&RET_PD>;
+			status = "okay";
+
+			mdf1_port1: port {
+				mdf_endpoint1: endpoint {
+					remote-endpoint = <&dmic1_endpoint>;
+				};
+			};
+		};
+	};
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&rtc {
+	st,lsco = <RTC_OUT2_RMP>;
+	pinctrl-0 = <&rtc_out2_rmp_pins_a>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_v5v_hdmi: regulator@21 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO5>;
+		regulator-name = "v5v_hdmi";
+	};
+	scmi_v5v_vconn: regulator@22 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO6>;
+		regulator-name = "v5v_vconn";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+/* Wifi */
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	non-removable;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	cap-sdio-irq;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+	};
+};
+
+&spi6 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi6_pins_a>;
+	pinctrl-1 = <&spi6_sleep_pins_a>;
+	status = "disabled";
+};
+
+/* Bluetooth */
+&usart1 {
+	pinctrl-names = "default", "sleep", "idle";
+	pinctrl-0 = <&usart1_pins_a>;
+	pinctrl-1 = <&usart1_sleep_pins_a>;
+	pinctrl-2 = <&usart1_idle_pins_a>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		shutdown-gpios = <&gpiog 4 GPIO_ACTIVE_HIGH>;
+		compatible = "brcm,bcm43438-bt";
+		max-speed = <3000000>;
+		vbat-supply = <&scmi_v3v3>;
+		vddio-supply = <&scmi_v3v3>;
+	};
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		phys            = <&usb2_phy2>, <&combophy PHY_TYPE_USB3>;
+		phy-names       = "usb2-phy", "usb3-phy";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi b/arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
new file mode 100644
index 0000000000..fba1febc6e
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-ev1-ca35tdcid-resmem.dtsi
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Loic Pallardy loic.pallardy@foss.st.com for STMicroelectronics.
+ */
+
+/*
+ * STM32MP25 reserved memory device tree configuration
+ * Project : open
+ * Generated by XLmx tool version 2.2 - 7/4/2023 9:06:24 AM
+ */
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Internal RAM reserved memory declaration */
+		tfa_bl31: tfa-bl31@a000000 {
+			reg = <0x0 0xa000000 0x0 0x20000>;
+			no-map;
+		};
+
+		hpdma1_lli: hpdma1-lli@a020000 {
+			reg = <0x0 0xa020000 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma2_lli: hpdma2-lli@a02f0f0 {
+			reg = <0x0 0xa02f0f0 0x0 0xf0f0>;
+			no-map;
+		};
+
+		hpdma3_lli: hpdma3-lli@a03e1e0 {
+			reg = <0x0 0xa03e1e0 0x0 0x1e20>;
+			no-map;
+		};
+
+		bsec_mirror: bsec-mirror@a040000 {
+			reg = <0x0 0xa040000 0x0 0x1000>;
+			no-map;
+		};
+
+		cm33_sram1: cm33-sram1@a041000 {
+			reg = <0x0 0xa041000 0x0 0x1f000>;
+			no-map;
+		};
+
+		cm33_sram2: cm33-sram2@a060000 {
+			reg = <0x0 0xa060000 0x0 0x20000>;
+			no-map;
+		};
+
+		cm33_retram: cm33-retram@a080000 {
+			reg = <0x0 0xa080000 0x0 0x1f000>;
+			no-map;
+		};
+
+		ddr_param: ddr-param@a09f000 {
+			reg = <0x0 0xa09f000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Backup RAM reserved memory declaration */
+		bl31_lowpower: bl31-lowpower@42000000 {
+			reg = <0x0 0x42000000 0x0 0x1000>;
+			no-map;
+		};
+
+		tfm_its: tfm-its@42001000 {
+			reg = <0x0 0x42001000 0x0 0x1000>;
+			no-map;
+		};
+
+		/* Octo Memory Manager reserved memory declaration */
+		mm_ospi1: mm-ospi@60000000 {
+			reg = <0x0 0x60000000 0x0 0x10000000>;
+			no-map;
+		};
+
+		/* DDR reserved memory declaration */
+		tfm_code: tfm-code@80000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80000000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_fw: cm33-cube-fw@80100000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80100000 0x0 0x800000>;
+			no-map;
+		};
+
+		tfm_data: tfm-data@80900000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80900000 0x0 0x100000>;
+			no-map;
+		};
+
+		cm33_cube_data: cm33-cube-data@80a00000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x80a00000 0x0 0x800000>;
+			no-map;
+		};
+
+		ipc_shmem_1: ipc-shmem-1@81200000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x81200000 0x0 0xf8000>;
+			no-map;
+		};
+
+		vdev0vring0: vdev0vring0@812f8000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f8000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0vring1: vdev0vring1@812f9000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812f9000 0x0 0x1000>;
+			no-map;
+		};
+
+		vdev0buffer: vdev0buffer@812fa000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0x812fa000 0x0 0x6000>;
+			no-map;
+		};
+
+		spare1: spare1@81300000 {
+			reg = <0x0 0x81300000 0x0 0xcc0000>;
+			no-map;
+		};
+
+		bl31_context: bl31-context@81fc0000 {
+			reg = <0x0 0x81fc0000 0x0 0x40000>;
+			no-map;
+		};
+
+		op_tee: op-tee@82000000 {
+			reg = <0x0 0x82000000 0x0 0x2000000>;
+			no-map;
+		};
+
+		gpu_reserved: gpu-reserved@fa800000 {
+			reg = <0x0 0xfa800000 0x0 0x4000000>;
+			no-map;
+		};
+
+		ltdc_sec_layer: ltdc-sec-layer@fe800000 {
+			reg = <0x0 0xfe800000 0x0 0x800000>;
+			no-map;
+		};
+
+		ltdc_sec_rotation: ltdc-sec-rotation@ff000000 {
+			reg = <0x0 0xff000000 0x0 0x1000000>;
+			no-map;
+		};
+
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			alloc-ranges = <0 0x80000000 0 0x80000000>;
+			size = <0x0 0x8000000>;
+			alignment = <0x0 0x2000>;
+			linux,cma-default;
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi b/arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi
new file mode 100644
index 0000000000..dd3ab77ea9
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-ev1-u-boot.dtsi
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
+ */
+
+#include "stm32mp25-u-boot.dtsi"
+
+/ {
+	aliases {
+		spi0 = &ospi1;
+	};
+
+	config {
+		u-boot,boot-led = "led-blue";
+		u-boot,mmc-env-partition = "u-boot-env";
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&sdmmc1>;
+	};
+};
+
+&dwc3 {
+	dr_mode = "peripheral";
+	/delete-node/ port;
+};
+
+&flash0 {
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "fsbla1";
+			reg = <0x00000000 0x00040000>;
+		};
+		partition@40000 {
+			label = "fsbla2";
+			reg = <0x00040000 0x00040000>;
+		};
+		partition@80000 {
+			label = "metadata1";
+			reg = <0x00080000 0x00040000>;
+		};
+		partition@C0000 {
+			label = "metadata2";
+			reg = <0x000C0000 0x00040000>;
+		};
+		partition@100000 {
+			label = "fip-a";
+			reg = <0x00100000 0x00400000>;
+		};
+		partition@500000 {
+			label = "fip-b";
+			reg = <0x00500000 0x00400000>;
+		};
+		partition@900000 {
+			label = "u-boot-env";
+			reg = <0x00900000 0x00080000>;
+		};
+		partition@980000 {
+			label = "nor-user";
+			reg = <0x00980000 0x03680000>;
+		};
+	};
+};
+
+&i2c_rpmsg {
+	/delete-node/ typec@35;
+};
+
+&usart2 {
+	u-boot,dm-pre-reloc;
+};
+
+&usart2_pins_a {
+	u-boot,dm-pre-reloc;
+	pins1 {
+		u-boot,dm-pre-reloc;
+	};
+	pins2 {
+		u-boot,dm-pre-reloc;
+	};
+};
diff --git a/arch/arm/dts/stm32mp257f-ev1.dts b/arch/arm/dts/stm32mp257f-ev1.dts
new file mode 100644
index 0000000000..19393d47aa
--- /dev/null
+++ b/arch/arm/dts/stm32mp257f-ev1.dts
@@ -0,0 +1,825 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/st,stm32mp25-regulator.h>
+#include "stm32mp257.dtsi"
+#include "stm32mp25xf.dtsi"
+#include "stm32mp25-pinctrl.dtsi"
+#include "stm32mp25xxai-pinctrl.dtsi"
+#include "stm32mp257f-ev1-ca35tdcid-resmem.dtsi"
+
+/ {
+	model = "STMicroelectronics STM32MP257F-EV1 Evaluation Board";
+	compatible = "st,stm32mp257f-ev1", "st,stm32mp257";
+
+	aliases {
+		ethernet0 = &eth2;
+		ethernet1 = &eth1;
+		serial0 = &usart2;
+		serial1 = &usart6;
+		serial2 = &lpuart1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer {
+			compatible = "simple-framebuffer";
+			clocks = <&rcc CK_BUS_LTDC>, <&rcc CK_KER_LTDC>,
+				 <&rcc CK_BUS_LVDS>, <&rcc CK_KER_LVDSPHY>;
+			status = "disabled";
+		};
+	};
+
+	clocks {
+		cec_clock: cec-clock {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <12000000>;
+		};
+
+		clk_ext_camera: clk-ext-camera {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+		};
+
+		pad_clk: pad-clk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button-user-1 {
+			label = "User-1";
+			linux,code = <BTN_1>;
+			gpios = <&gpiod 2 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-user-2 {
+			label = "User-2";
+			linux,code = <BTN_2>;
+			gpios = <&gpiog 8 GPIO_ACTIVE_HIGH>;
+			status = "okay";
+		};
+
+		button-wake-up {
+			label = "wake-up";
+			linux,code = <KEY_WAKEUP>;
+			interrupts-extended = <&optee 0>;
+			status = "okay";
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-blue {
+			function = LED_FUNCTION_HEARTBEAT;
+			color = <LED_COLOR_ID_BLUE>;
+			gpios = <&gpioj 7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+
+	hdmi: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&adv753x_out>;
+			};
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x1 0x0>;
+	};
+
+	panel_lvds: panel-lvds {
+		compatible = "edt,etml0700z9ndha", "panel-lvds";
+		enable-gpios = <&gpiog 15 GPIO_ACTIVE_HIGH>;
+		backlight = <&panel_lvds_backlight>;
+		status = "okay";
+
+		width-mm = <156>;
+		height-mm = <92>;
+		data-mapping = "vesa-24";
+
+		panel-timing {
+			clock-frequency = <54000000>;
+			hactive = <1024>;
+			vactive = <600>;
+			hfront-porch = <150>;
+			hback-porch = <150>;
+			hsync-len = <21>;
+			vfront-porch = <24>;
+			vback-porch = <24>;
+			vsync-len = <21>;
+		};
+
+		port {
+			lvds_panel_in: endpoint {
+				remote-endpoint = <&lvds_out0>;
+			};
+		};
+	};
+
+	panel_lvds_backlight: panel-lvds-backlight {
+		compatible = "gpio-backlight";
+		gpios = <&gpioi 5 GPIO_ACTIVE_HIGH>;
+		default-on;
+		default-brightness-level = <1>;
+		status = "okay";
+	};
+
+	sound: sound {
+		compatible = "audio-graph-card";
+		label = "STM32MP25-EV1";
+		dais = <&i2s2_port>;
+		status = "disabled";
+	};
+};
+
+&a35ss_syscfg {
+	status = "okay";
+};
+
+&arm_wdt {
+	timeout-sec = <32>;
+	status = "okay";
+};
+
+&combophy {
+	clocks = <&rcc CK_BUS_USB3PCIEPHY>, <&rcc CK_KER_USB3PCIEPHY>, <&pad_clk>;
+	clock-names = "apb-clk", "ker-clk", "pad-clk";
+	st,rx_equalizer = <1>;
+	status = "okay";
+};
+
+&crc {
+	status = "okay";
+};
+
+&cryp1 {
+	status = "okay";
+};
+
+&cs_cpu_debug0 {
+	status = "okay";
+};
+
+&cs_cpu_debug1 {
+	status = "okay";
+};
+
+&cs_cti0 {
+	status = "okay";
+};
+
+&cs_cti1 {
+	status = "okay";
+};
+
+&cs_cti_cpu0 {
+	status = "okay";
+};
+
+&cs_cti_cpu1 {
+	status = "okay";
+};
+
+&cs_etf {
+	status = "okay";
+};
+
+&cs_etm0 {
+	status = "okay";
+};
+
+&cs_etm1 {
+	status = "okay";
+};
+
+&cs_etr {
+	status = "okay";
+};
+
+&cs_funnel {
+	status = "okay";
+};
+
+&cs_replicator {
+	status = "okay";
+};
+
+&cs_stm {
+	status = "okay";
+};
+
+&cs_tpiu {
+	status = "okay";
+};
+
+&csi2host {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			csi2host_sink: endpoint {
+				remote-endpoint = <&imx335_ep>;
+				data-lanes = <0 1>;
+				bus-type = <4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			csi2host_source: endpoint {
+				remote-endpoint = <&dcmipp_0>;
+			};
+		};
+	};
+};
+
+&dcmipp {
+	status = "okay";
+	port {
+		dcmipp_0: endpoint {
+			remote-endpoint = <&csi2host_source>;
+			bus-type = <4>;
+		};
+	};
+};
+
+&dsi {
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			dsi_in: endpoint {
+				remote-endpoint = <&ltdc_ep0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			dsi_out1: endpoint {
+				remote-endpoint = <&adv753x_in>;
+			};
+		};
+	};
+};
+
+&eth1 {
+	status = "okay";
+	pinctrl-0 = <&eth1_rgmii_pins_a &eth1_mdio_pins_a>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_a &eth1_mdio_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth1>;
+	st,eth-clk-sel;
+	snps,ext-systime;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth1: ethernet-phy@4 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpioj 9 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <4>;
+		};
+	};
+};
+
+&eth2 {
+	status = "okay";
+	pinctrl-0 = <&eth2_rgmii_pins_a>;
+	pinctrl-1 = <&eth2_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii-id";
+	max-speed = <1000>;
+	phy-handle = <&phy1_eth2>;
+	st,eth-ptp-from-rcc;
+
+	mdio1 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "snps,dwmac-mdio";
+		phy1_eth2: ethernet-phy@1 {
+			compatible = "ethernet-phy-id001c.c916";
+			reset-gpios =  <&gpiog 6 GPIO_ACTIVE_LOW>;
+			reset-assert-us = <10000>;
+			reset-deassert-us = <80000>;
+			realtek,eee-disable;
+			reg = <1>;
+		};
+	};
+};
+
+&gpu {
+	contiguous-area = <&gpu_reserved>;
+	status = "okay";
+};
+
+&hpdma {
+	memory-region = <&hpdma1_lli>;
+};
+
+&hpdma2 {
+	memory-region = <&hpdma2_lli>;
+};
+
+&hpdma3 {
+	memory-region = <&hpdma3_lli>;
+};
+
+&i2c2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c2_pins_a>;
+	pinctrl-1 = <&i2c2_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <100>;
+	i2c-scl-falling-time-ns = <13>;
+	clock-frequency = <400000>;
+	status = "okay";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+
+	imx335: imx335@1a {
+		compatible = "sony,imx335";
+		reg = <0x1a>;
+		clocks = <&clk_ext_camera>;
+		reset-gpios = <&gpioi 7 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		powerdown-gpios = <&gpioi 0 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
+		status = "okay";
+
+		port {
+			imx335_ep: endpoint {
+				remote-endpoint = <&csi2host_sink>;
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				link-frequencies = /bits/ 64 <594000000>;
+			};
+		};
+	};
+
+	adv753x: hdmi@3d {
+		/*
+		 * With MB1232 board, use "adi,adv7533" (1080p30)
+		 * With MB1752 board, use "adi,adv7535" (1080p60)
+		 */
+		compatible = "adi,adv7533";
+		reg = <0x3d>, <0x3c>, <0x3f>, <0x38>;
+		reg-names = "main", "cec", "edid", "packet";
+		clocks = <&cec_clock>;
+		clock-names = "cec";
+		interrupt-parent = <&gpiod>;
+		interrupts = <10 IRQ_TYPE_EDGE_FALLING>;
+		status = "disabled";
+		adi,dsi-lanes = <4>;
+		reset-gpios = <&gpiog 14 GPIO_ACTIVE_LOW>;
+		avdd-supply = <&scmi_v1v8>;
+		dvdd-supply = <&scmi_v1v8>;
+		pvdd-supply = <&scmi_v1v8>;
+		a2vdd-supply = <&scmi_v1v8>;
+		v3p3-supply = <&scmi_v3v3>;
+		v1p2-supply = <&scmi_v1v8>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				adv753x_in: endpoint {
+					remote-endpoint = <&dsi_out1>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				adv753x_out: endpoint {
+					remote-endpoint = <&hdmi_connector_in>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				adv753x_tx_endpoint: endpoint {
+					remote-endpoint = <&i2s2_endpoint>;
+				};
+			};
+		};
+	};
+
+	ili2511: ili2511@41 {
+		compatible = "ilitek,ili251x";
+		reg = <0x41>;
+		interrupt-parent = <&gpioi>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&gpiog 14 GPIO_ACTIVE_LOW>;
+		status = "okay";
+	};
+};
+
+&i2c8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2c8_pins_a>;
+	pinctrl-1 = <&i2c8_sleep_pins_a>;
+	i2c-scl-rising-time-ns = <57>;
+	i2c-scl-falling-time-ns = <7>;
+	clock-frequency = <400000>;
+	status = "disabled";
+	/* spare dmas for other usage */
+	/delete-property/dmas;
+	/delete-property/dma-names;
+};
+
+&i2s2 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&i2s2_pins_a>;
+	pinctrl-1 = <&i2s2_sleep_pins_a>;
+	status = "disabled";
+
+	i2s2_port: port {
+		i2s2_endpoint: endpoint {
+			remote-endpoint = <&adv753x_tx_endpoint>;
+			format = "i2s";
+			mclk-fs = <256>;
+		};
+	};
+};
+
+&ipcc1 {
+	status = "okay";
+};
+
+&lpuart1 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&lpuart1_pins_a>;
+	pinctrl-1 = <&lpuart1_idle_pins_a>;
+	pinctrl-2 = <&lpuart1_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	wakeup-source;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&ltdc {
+	default-on;
+	rotation-memory = <&ltdc_sec_rotation>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ltdc_ep0_out: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dsi_in>;
+		};
+
+		ltdc_ep1_out: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&lvds_in>;
+		};
+	};
+};
+
+&lvds {
+	default-on;
+	vdd-supply =  <&scmi_vddcore>;
+	vdda18-supply = <&scmi_v1v8>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			lvds_in: endpoint {
+				remote-endpoint = <&ltdc_ep1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			lvds_out0: endpoint {
+				remote-endpoint = <&lvds_panel_in>;
+			};
+		};
+	};
+};
+
+&m33_rproc {
+	mboxes = <&ipcc1 0x100>, <&ipcc1 0x101>, <&ipcc1 2>;
+	mbox-names = "vq0", "vq1", "shutdown";
+	memory-region = <&cm33_cube_fw>, <&cm33_cube_data>,
+			<&ipc_shmem_1>, <&vdev0vring0>,
+			<&vdev0vring1>, <&vdev0buffer>,
+			<&cm33_sram2>;
+	st,syscfg-nsvtor = <&a35ss_syscfg 0xa8 0xffffff80>;
+	status = "okay";
+};
+
+&m_can1 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can1_pins_a>;
+	pinctrl-1 = <&m_can1_sleep_pins_a>;
+	status = "okay";
+};
+
+&m_can3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&m_can3_pins_a>;
+	pinctrl-1 = <&m_can3_sleep_pins_a>;
+	status = "okay";
+};
+
+&mlahb {
+	intc_rpmsg: interrupt-controller@1 {
+		compatible = "rpmsg,intc";
+		reg = <1 0>;
+		#interrupt-cells = <1>;
+		interrupt-controller;
+	};
+
+	i2c_rpmsg: i2c@2 {
+		compatible = "rpmsg,i2c-controller";
+		reg = <2 0>;
+		rpmsg,dev-id = "rpmsg_i2c";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "okay";
+
+		typec@35 {
+			compatible = "st,stm32mp25-typec";
+			reg = <0x35>;
+			interrupts-extended = <&intc_rpmsg 0>;
+			status = "okay";
+			connector {
+				compatible = "usb-c-connector";
+				label = "USB-C";
+
+				port {
+					typec_ep: endpoint {
+						remote-endpoint = <&dwc3_ep>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&ommanager {
+	memory-region = <&mm_ospi1>;
+	memory-region-names = "mm_ospi1";
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&ospi_port1_clk_pins_a
+		     &ospi_port1_io03_pins_a
+		     &ospi_port1_cs0_pins_a>;
+	pinctrl-1 = <&ospi_port1_clk_sleep_pins_a
+		     &ospi_port1_io03_sleep_pins_a
+		     &ospi_port1_cs0_sleep_pins_a>;
+	status = "okay";
+
+	spi@40430000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		memory-region = <&mm_ospi1>;
+		status = "okay";
+
+		flash0: flash@0 {
+			compatible = "jedec,spi-nor";
+			reg = <0>;
+			spi-rx-bus-width = <4>;
+			spi-tx-bus-width = <4>;
+			spi-max-frequency = <84000000>;
+		};
+	};
+};
+
+&pcie_ep {
+	pinctrl-names = "default", "init";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	status = "disabled";
+};
+
+&pcie_rc {
+	pinctrl-names = "default", "init", "sleep";
+	pinctrl-0 = <&pcie_pins_a>;
+	pinctrl-1 = <&pcie_init_pins_a>;
+	pinctrl-2 = <&pcie_sleep_pins_a>;
+	reset-gpios = <&gpioj 8 GPIO_ACTIVE_LOW>;
+	wakeup-source;
+	wake-gpios = <&gpioh 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	status = "okay";
+};
+
+&rtc {
+	status = "okay";
+};
+
+&scmi_regu {
+	scmi_vddio1: regulator@0 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+	};
+	scmi_vddcore: regulator@11  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK2>;
+		regulator-name = "vddcore";
+	};
+	scmi_v1v8: regulator@14  {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK5>;
+		regulator-name = "v1v8";
+	};
+	scmi_v3v3: regulator@16 {
+		reg = <VOLTD_SCMI_STPMIC2_BUCK7>;
+		regulator-name = "v3v3";
+	};
+	scmi_vdd_emmc: regulator@18 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO2>;
+		regulator-name = "vdd_emmc";
+	};
+	scmi_vdd3v3_usb: regulator@20 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO4>;
+		regulator-name = "vdd3v3_usb";
+	};
+	scmi_vdd_sdcard: regulator@23 {
+		reg = <VOLTD_SCMI_STPMIC2_LDO7>;
+		regulator-name = "vdd_sdcard";
+	};
+};
+
+&sdmmc1 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
+	cd-gpios = <&gpiod 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_vdd_sdcard>;
+	vqmmc-supply = <&scmi_vddio1>;
+	sd-uhs-sdr12;
+	sd-uhs-sdr25;
+	sd-uhs-sdr50;
+	sd-uhs-ddr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc2 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc2_b4_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-1 = <&sdmmc2_b4_od_pins_a &sdmmc2_d47_pins_a>;
+	pinctrl-2 = <&sdmmc2_b4_sleep_pins_a &sdmmc2_d47_sleep_pins_a>;
+	non-removable;
+	no-sd;
+	no-sdio;
+	st,neg-edge;
+	bus-width = <8>;
+	vmmc-supply = <&scmi_vdd_emmc>;
+	vqmmc-supply = <&scmi_vddio2>;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&sdmmc3 {
+	pinctrl-names = "default", "opendrain", "sleep";
+	pinctrl-0 = <&sdmmc3_b4_pins_a>;
+	pinctrl-1 = <&sdmmc3_b4_od_pins_a>;
+	pinctrl-2 = <&sdmmc3_b4_sleep_pins_a>;
+	broken-cd;
+	disable-wp;
+	st,neg-edge;
+	bus-width = <4>;
+	vmmc-supply = <&scmi_v3v3>;
+	status = "disabled";
+};
+
+&spi3 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi3_pins_a>;
+	pinctrl-1 = <&spi3_sleep_pins_a>;
+	status = "disabled";
+};
+
+&spi8 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&spi8_pins_a>;
+	pinctrl-1 = <&spi8_sleep_pins_a>;
+	status = "disabled";
+};
+
+&switch0 {
+	status = "disabled";
+	pinctrl-0 = <&eth1_rgmii_pins_a>, <&eth3_rgmii_pins_a>;
+	pinctrl-1 = <&eth1_rgmii_sleep_pins_a>, <&eth3_rgmii_sleep_pins_a>;
+	pinctrl-names = "default", "sleep";
+	phy-mode = "rgmii";
+	st,ethsw-internal-125;
+};
+
+&usart2 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart2_pins_a>;
+	pinctrl-1 = <&usart2_idle_pins_a>;
+	pinctrl-2 = <&usart2_sleep_pins_a>;
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	status = "okay";
+};
+
+&usart6 {
+	pinctrl-names = "default", "idle", "sleep";
+	pinctrl-0 = <&usart6_pins_a>;
+	pinctrl-1 = <&usart6_idle_pins_a>;
+	pinctrl-2 = <&usart6_sleep_pins_a>;
+	uart-has-rtscts;
+	status = "disabled";
+};
+
+&usb2_phy1 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usb2_phy2 {
+	vdd33-supply = <&scmi_vdd3v3_usb>;
+	status = "okay";
+};
+
+&usbh {
+	status = "okay";
+
+	usbh_ehci: usb@482f0000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		/* onboard HUB */
+		hub@1 {
+			compatible = "usb424,2514";
+			reg = <1>;
+			vdd-supply = <&scmi_v3v3>;
+		};
+	};
+
+	usbh_ohci: usb@482e0000 {
+		status = "disabled";
+	};
+};
+
+&usb3dr {
+	status = "okay";
+
+	dwc3: usb@48300000 {
+		maximum-speed = "high-speed";
+		usb-role-switch;
+		port {
+			dwc3_ep: endpoint {
+				remote-endpoint = <&typec_ep>;
+			};
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xc.dtsi b/arch/arm/dts/stm32mp25xc.dtsi
new file mode 100644
index 0000000000..8d6ae78f50
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xc.dtsi
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP1_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	cryp2: crypto@42040000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42040000 0x1000>;
+		interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP2>;
+		resets = <&rcc CRYP2_R>;
+		dmas = <&hpdma 140 0x40 0x3021>,
+		       <&hpdma 141 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP2_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xf.dtsi b/arch/arm/dts/stm32mp25xf.dtsi
new file mode 100644
index 0000000000..8d6ae78f50
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xf.dtsi
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+
+&rifsc {
+	cryp1: crypto@42030000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42030000 0x1000>;
+		interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP1>;
+		resets = <&rcc CRYP1_R>;
+		dmas = <&hpdma 4 0x40 0x3021>,
+		       <&hpdma 5 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP1_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+
+	cryp2: crypto@42040000 {
+		compatible = "st,stm32mp1-cryp";
+		reg = <0x42040000 0x1000>;
+		interrupts = <GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&rcc CK_BUS_CRYP2>;
+		resets = <&rcc CRYP2_R>;
+		dmas = <&hpdma 140 0x40 0x3021>,
+		       <&hpdma 141 0x43 0x3012>;
+		dma-names = "in", "out";
+		feature-domains = <&rifsc STM32MP25_RIFSC_CRYP2_ID>;
+		power-domains = <&CLUSTER_PD>;
+		status = "disabled";
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxai-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxai-pinctrl.dtsi
new file mode 100644
index 0000000000..abdbc7aebc
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxai-pinctrl.dtsi
@@ -0,0 +1,83 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AI>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 128 16>;
+	};
+
+	gpioj: gpio@442d0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 144 16>;
+	};
+
+	gpiok: gpio@442e0000 {
+		status = "okay";
+		ngpios = <8>;
+		gpio-ranges = <&pinctrl 0 160 8>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxak-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxak-pinctrl.dtsi
new file mode 100644
index 0000000000..2e0d4d349d
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxak-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AK>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/dts/stm32mp25xxal-pinctrl.dtsi b/arch/arm/dts/stm32mp25xxal-pinctrl.dtsi
new file mode 100644
index 0000000000..2406e97255
--- /dev/null
+++ b/arch/arm/dts/stm32mp25xxal-pinctrl.dtsi
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Alexandre Torgue <alexandre.torgue@foss.st.com> for STMicroelectronics.
+ */
+
+&pinctrl {
+	st,package = <STM32MP_PKG_AL>;
+
+	gpioa: gpio@44240000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 0 16>;
+	};
+
+	gpiob: gpio@44250000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 16 16>;
+	};
+
+	gpioc: gpio@44260000 {
+		status = "okay";
+		ngpios = <14>;
+		gpio-ranges = <&pinctrl 0 32 14>;
+	};
+
+	gpiod: gpio@44270000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 48 16>;
+	};
+
+	gpioe: gpio@44280000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 64 16>;
+	};
+
+	gpiof: gpio@44290000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 80 16>;
+	};
+
+	gpiog: gpio@442a0000 {
+		status = "okay";
+		ngpios = <16>;
+		gpio-ranges = <&pinctrl 0 96 16>;
+	};
+
+	gpioh: gpio@442b0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 2 114 12>;
+	};
+
+	gpioi: gpio@442c0000 {
+		status = "okay";
+		ngpios = <12>;
+		gpio-ranges = <&pinctrl 0 128 12>;
+	};
+};
+
+&pinctrl_z {
+	gpioz: gpio@46200000 {
+		status = "okay";
+		ngpios = <10>;
+		gpio-ranges = <&pinctrl_z 0 400 10>;
+	};
+};
diff --git a/arch/arm/include/asm/arch-stm32f7/stm32.h b/arch/arm/include/asm/arch-stm32f7/stm32.h
index 3451e74a3d..57db839e8d 100644
--- a/arch/arm/include/asm/arch-stm32f7/stm32.h
+++ b/arch/arm/include/asm/arch-stm32f7/stm32.h
@@ -10,9 +10,9 @@
 #include <asm/arch-stm32/stm32f.h>
 
 static const u32 sect_sz_kb[CONFIG_SYS_MAX_FLASH_SECT] = {
-	[0 ... 3] =	32 * 1024,
-	[4] =		128 * 1024,
-	[5 ... 7] =	256 * 1024
+	[0 ... 3] =				32 * 1024,
+	[4] =					128 * 1024,
+	[5 ... CONFIG_SYS_MAX_FLASH_SECT - 1] =	256 * 1024
 };
 
 #endif /* _ASM_ARCH_HARDWARE_H */
diff --git a/arch/arm/include/asm/system.h b/arch/arm/include/asm/system.h
index 87d1c77e8b..8db8bfd354 100644
--- a/arch/arm/include/asm/system.h
+++ b/arch/arm/include/asm/system.h
@@ -512,14 +512,6 @@ enum dcache_option {
 };
 #endif
 
-#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
-#define DCACHE_DEFAULT_OPTION	DCACHE_WRITETHROUGH
-#elif defined(CONFIG_SYS_ARM_CACHE_WRITEALLOC)
-#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEALLOC
-#elif defined(CONFIG_SYS_ARM_CACHE_WRITEBACK)
-#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEBACK
-#endif
-
 /* Size of an MMU section */
 enum {
 #ifdef CONFIG_ARMV7_LPAE
@@ -577,6 +569,14 @@ void psci_system_reset(void);
 
 #endif /* CONFIG_ARM64 */
 
+#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
+#define DCACHE_DEFAULT_OPTION	DCACHE_WRITETHROUGH
+#elif defined(CONFIG_SYS_ARM_CACHE_WRITEALLOC)
+#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEALLOC
+#elif defined(CONFIG_SYS_ARM_CACHE_WRITEBACK)
+#define DCACHE_DEFAULT_OPTION	DCACHE_WRITEBACK
+#endif
+
 #ifndef __ASSEMBLY__
 /**
  * save_boot_params() - Save boot parameters before starting reset sequence
diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index db47baba6d..d024ad0a61 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -35,9 +35,9 @@ config ENV_SIZE
 
 choice
 	prompt "Select STMicroelectronics STM32MPxxx Soc"
-	default STM32MP15x
+	default STM32MP15X
 
-config STM32MP13x
+config STM32MP13X
 	bool "Support STMicroelectronics STM32MP13x Soc"
 	select ARM_SMCCC
 	select CPU_V7A
@@ -49,13 +49,14 @@ config STM32MP13x
 	select STM32_RCC
 	select STM32_RESET
 	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
 	select SYS_ARCH_TIMER
 	imply CMD_NVEDIT_INFO
 	help
 		support of STMicroelectronics SOC STM32MP13x family
 		STMicroelectronics MPU with core ARMv7
 
-config STM32MP15x
+config STM32MP15X
 	bool "Support STMicroelectronics STM32MP15x Soc"
 	select ARCH_SUPPORT_PSCI
 	select BINMAN
@@ -68,6 +69,7 @@ config STM32MP15x
 	select STM32_RCC
 	select STM32_RESET
 	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
 	select SUPPORT_SPL
 	select SYS_ARCH_TIMER
 	imply CMD_NVEDIT_INFO
@@ -76,6 +78,32 @@ config STM32MP15x
 		STM32MP157, STM32MP153 or STM32MP151
 		STMicroelectronics MPU with core ARMv7
 		dual core A7 for STM32MP157/3, monocore for STM32MP151
+
+config STM32MP25X
+	bool "Support STMicroelectronics STM32MP25x Soc"
+	select ARM64
+	select CLK_STM32MP25
+	select OF_BOARD
+	select OF_BOARD_SETUP
+	select PINCTRL_STM32
+	select STM32_RCC
+	select STM32_RESET
+	select STM32_SERIAL
+	select STM32MP_TAMP_NVMEM
+	select SYS_ARCH_TIMER
+	select TFABOOT
+	imply CLK_SCMI
+	imply CMD_NVEDIT_INFO
+	imply DM_REGULATOR
+	imply DM_REGULATOR_SCMI
+	imply OPTEE
+	imply RESET_SCMI
+	imply SYSRESET_PSCI
+	imply TEE
+	imply VERSION_VARIABLE
+	help
+		Support of STMicroelectronics SOC STM32MP25x family
+		STMicroelectronics MPU with 2 * A53 core and 1 M33 core
 endchoice
 
 config NR_DRAM_BANKS
@@ -84,6 +112,7 @@ config NR_DRAM_BANKS
 config DDR_CACHEABLE_SIZE
 	hex "Size of the DDR marked cacheable in pre-reloc stage"
 	default 0x40000000
+	depends on STM32MP15X || STM32MP13X
 	help
 		Define the size of the DDR marked as cacheable in U-Boot
 		pre-reloc stage.
@@ -101,14 +130,6 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_MMC2
 	  Partition on the second MMC to load U-Boot from when the MMC is being
 	  used in raw mode
 
-config STM32_ETZPC
-	bool "STM32 Extended TrustZone Protection"
-	depends on STM32MP15x || STM32MP13x
-	default y
-	imply BOOTP_SERVERIP
-	help
-	  Say y to enable STM32 Extended TrustZone Protection
-
 config STM32_ECDSA_VERIFY
 	bool "STM32 ECDSA verification via the ROM API"
 	depends on SPL_ECDSA_VERIFY
@@ -118,6 +139,15 @@ config STM32_ECDSA_VERIFY
 	  ROM API provided on STM32MP.
 	  The ROM API is only available during SPL for now.
 
+config STM32MP_TAMP_NVMEM
+	bool "STM32 TAMP backup registers via NVMEM API"
+	select NVMEM
+	default y
+	help
+	  Say y to enable the uclass driver for TAMP Backup registers using the
+	  NVMEM API. It allows to access to boot mode or others shared information
+	  between software components/execution levels.
+
 config CMD_STM32KEY
 	bool "command stm32key to fuse public key hash"
 	help
@@ -128,6 +158,7 @@ config CMD_STM32KEY
 
 source "arch/arm/mach-stm32mp/Kconfig.13x"
 source "arch/arm/mach-stm32mp/Kconfig.15x"
+source "arch/arm/mach-stm32mp/Kconfig.25x"
 
 source "arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig"
 endif
diff --git a/arch/arm/mach-stm32mp/Kconfig.13x b/arch/arm/mach-stm32mp/Kconfig.13x
index 5fc000986e..d1b48df36f 100644
--- a/arch/arm/mach-stm32mp/Kconfig.13x
+++ b/arch/arm/mach-stm32mp/Kconfig.13x
@@ -1,17 +1,15 @@
-if STM32MP13x
+if STM32MP13X
 
 choice
 	prompt "STM32MP13x board select"
 	optional
 
-config TARGET_ST_STM32MP13x
+config TARGET_ST_STM32MP13X
 	bool "STMicroelectronics STM32MP13x boards"
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 		target the STMicroelectronics board with SOC STM32MP13x
 		managed by board/st/stm32mp1.
diff --git a/arch/arm/mach-stm32mp/Kconfig.15x b/arch/arm/mach-stm32mp/Kconfig.15x
index d516270292..a6009c52ae 100644
--- a/arch/arm/mach-stm32mp/Kconfig.15x
+++ b/arch/arm/mach-stm32mp/Kconfig.15x
@@ -1,6 +1,6 @@
-if STM32MP15x
+if STM32MP15X
 
-config STM32MP15x_STM32IMAGE
+config STM32MP15X_STM32IMAGE
 	bool "Support STM32 image for generated U-Boot image"
 	depends on TFABOOT
 	help
@@ -11,14 +11,12 @@ choice
 	prompt "STM32MP15x board select"
 	optional
 
-config TARGET_ST_STM32MP15x
+config TARGET_ST_STM32MP15X
 	bool "STMicroelectronics STM32MP15x boards"
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 		target the STMicroelectronics board with SOC STM32MP15x
 		managed by board/st/stm32mp1:
@@ -35,9 +33,7 @@ config TARGET_MICROGEA_STM32MP1
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 	  MicroGEA STM32MP1 is a STM32MP157A based Micro SOM.
 
@@ -59,9 +55,7 @@ config TARGET_ICORE_STM32MP1
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
 	imply CMD_CLS if CMD_BMP
-	imply DISABLE_CONSOLE
 	imply PRE_CONSOLE_BUFFER
-	imply SILENT_CONSOLE
 	help
 	  i.Core STM32MP1 is an EDIMM SOM based on STM32MP157A.
 
@@ -117,7 +111,7 @@ endif
 if DEBUG_UART
 
 config DEBUG_UART_BOARD_INIT
-	default y
+	default y if SPL
 
 # debug on UART4 by default
 config DEBUG_UART_BASE
diff --git a/arch/arm/mach-stm32mp/Kconfig.25x b/arch/arm/mach-stm32mp/Kconfig.25x
new file mode 100644
index 0000000000..3077b37fe5
--- /dev/null
+++ b/arch/arm/mach-stm32mp/Kconfig.25x
@@ -0,0 +1,43 @@
+if STM32MP25X
+
+choice
+	prompt "STM32MP25x board select"
+	optional
+
+config TARGET_ST_STM32MP25X
+	bool "STMicroelectronics STM32MP25x boards"
+	imply BOOTSTAGE
+	imply CMD_BOOTSTAGE
+	help
+		target the STMicroelectronics board with SOC STM32MP25x
+		managed by board/st/stm32mp2
+		The difference between board are managed with devicetree
+
+endchoice
+
+config SYS_TEXT_BASE
+	default 0x84000000
+
+config PRE_CON_BUF_ADDR
+	default 0x84800000
+
+config PRE_CON_BUF_SZ
+	default 4096
+
+config BOOTSTAGE_STASH_ADDR
+	default 0x87000000
+
+if DEBUG_UART
+
+config DEBUG_UART_BOARD_INIT
+	default y
+
+# debug on USART2 by default
+config DEBUG_UART_BASE
+	default 0x400e0000
+
+endif
+
+source "board/st/stm32mp2/Kconfig"
+
+endif
diff --git a/arch/arm/mach-stm32mp/Makefile b/arch/arm/mach-stm32mp/Makefile
index 1db9057e04..99e8148836 100644
--- a/arch/arm/mach-stm32mp/Makefile
+++ b/arch/arm/mach-stm32mp/Makefile
@@ -3,13 +3,17 @@
 # Copyright (C) 2018, STMicroelectronics - All Rights Reserved
 #
 
-obj-y += cpu.o
 obj-y += dram_init.o
 obj-y += syscon.o
 obj-y += bsec.o
+obj-y += etzpc.o
+obj-y += soc.o
 
-obj-$(CONFIG_STM32MP13x) += stm32mp13x.o
-obj-$(CONFIG_STM32MP15x) += stm32mp15x.o
+obj-$(CONFIG_STM32MP13X) += stm32mp1/
+obj-$(CONFIG_STM32MP15X) += stm32mp1/
+obj-$(CONFIG_STM32MP25X) += stm32mp2/
+
+obj-$(CONFIG_STM32MP_TAMP_NVMEM) += nvram.o
 
 ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
@@ -18,9 +22,5 @@ obj-$(CONFIG_STM32_ECDSA_VERIFY) += ecdsa_romapi.o
 else
 obj-y += cmd_stm32prog/
 obj-$(CONFIG_CMD_STM32KEY) += cmd_stm32key.o
-obj-$(CONFIG_ARMV7_PSCI) += psci.o
 obj-$(CONFIG_TFABOOT) += boot_params.o
 endif
-
-obj-$(CONFIG_$(SPL_)STM32MP15_PWR) += pwr_regulator.o
-obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
diff --git a/arch/arm/mach-stm32mp/bsec.c b/arch/arm/mach-stm32mp/bsec.c
index c00130b08b..8d4d4708e3 100644
--- a/arch/arm/mach-stm32mp/bsec.c
+++ b/arch/arm/mach-stm32mp/bsec.c
@@ -10,14 +10,15 @@
 #include <dm.h>
 #include <log.h>
 #include <misc.h>
+#include <tee.h>
 #include <asm/io.h>
 #include <asm/arch/bsec.h>
 #include <asm/arch/stm32mp1_smc.h>
+#include <dm/device.h>
 #include <dm/device_compat.h>
 #include <linux/arm-smccc.h>
 #include <linux/iopoll.h>
 
-#define BSEC_OTP_MAX_VALUE		95
 #define BSEC_OTP_UPPER_START		32
 #define BSEC_TIMEOUT_US			10000
 
@@ -63,10 +64,43 @@
  */
 #define BSEC_LOCK_PROGRAM		0x04
 
+#define PTA_BSEC_UUID { 0x94cf71ad, 0x80e6, 0x40b5, \
+	{ 0xa7, 0xc6, 0x3d, 0xc5, 0x01, 0xeb, 0x28, 0x03 } }
+
+/*
+ * Read OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0:shadow, 1:fuse, 2:lock)
+ * [out]	memref[1].buffer	Output buffer to store read values
+ * [out]	memref[1].size		Size of OTP to be read
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_ACCESS_DENIED - OTP not accessible by caller
+ */
+#define PTA_BSEC_READ_MEM		0x0
+
 /*
- * OTP status: bit 0 permanent lock
+ * Write OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0:shadow, 1:fuse, 2:lock)
+ * [in]		memref[1].buffer	Input buffer to read values
+ * [in]		memref[1].size		Size of OTP to be written
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_ACCESS_DENIED - OTP not accessible by caller
  */
-#define BSEC_LOCK_PERM			BIT(0)
+#define PTA_BSEC_WRITE_MEM		0x1
+
+/* value of PTA_BSEC access type = value[in] b */
+#define SHADOW_ACCESS			0
+#define FUSE_ACCESS			1
+#define LOCK_ACCESS			2
 
 /**
  * bsec_lock() - manage lock for each type SR/SP/SW
@@ -74,7 +108,7 @@
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_lock(u32 address, u32 otp)
+static bool bsec_read_lock(void __iomem *address, u32 otp)
 {
 	u32 bit;
 	u32 bank;
@@ -82,7 +116,7 @@ static bool bsec_read_lock(u32 address, u32 otp)
 	bit = 1 << (otp & OTP_LOCK_MASK);
 	bank = ((otp >> OTP_LOCK_BANK_SHIFT) & OTP_LOCK_MASK) * sizeof(u32);
 
-	return !!(readl(address + bank) & bit);
+	return !!(readl((address + bank)) & bit);
 }
 
 /**
@@ -91,7 +125,7 @@ static bool bsec_read_lock(u32 address, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error, -EAGAIN or -ENOTSUPP
  */
-static u32 bsec_check_error(u32 base, u32 otp)
+static u32 bsec_check_error(void __iomem *base, u32 otp)
 {
 	u32 bit;
 	u32 bank;
@@ -113,7 +147,7 @@ static u32 bsec_check_error(u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_SR_lock(u32 base, u32 otp)
+static bool bsec_read_SR_lock(void __iomem *base, u32 otp)
 {
 	return bsec_read_lock(base + BSEC_SRLOCK_OFF, otp);
 }
@@ -124,7 +158,7 @@ static bool bsec_read_SR_lock(u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_SP_lock(u32 base, u32 otp)
+static bool bsec_read_SP_lock(void __iomem *base, u32 otp)
 {
 	return bsec_read_lock(base + BSEC_SPLOCK_OFF, otp);
 }
@@ -135,7 +169,7 @@ static bool bsec_read_SP_lock(u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: true if locked else false
  */
-static bool bsec_read_SW_lock(u32 base, u32 otp)
+static bool bsec_read_SW_lock(void __iomem *base, u32 otp)
 {
 	return bsec_read_lock(base + BSEC_SWLOCK_OFF, otp);
 }
@@ -146,7 +180,7 @@ static bool bsec_read_SW_lock(u32 base, u32 otp)
  * @power: true to power up , false to power down
  * Return: 0 if succeed
  */
-static int bsec_power_safmem(u32 base, bool power)
+static int bsec_power_safmem(void __iomem *base, bool power)
 {
 	u32 val;
 	u32 mask;
@@ -172,7 +206,7 @@ static int bsec_power_safmem(u32 base, bool power)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_shadow_register(struct udevice *dev, u32 base, u32 otp)
+static int bsec_shadow_register(struct udevice *dev, void __iomem *base, u32 otp)
 {
 	u32 val;
 	int ret;
@@ -217,7 +251,8 @@ static int bsec_shadow_register(struct udevice *dev, u32 base, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_read_shadow(struct udevice *dev, u32 base, u32 *val, u32 otp)
+static int bsec_read_shadow(struct udevice *dev, void __iomem *base, u32 *val,
+			    u32 otp)
 {
 	*val = readl(base + BSEC_OTP_DATA_OFF + otp * sizeof(u32));
 
@@ -232,7 +267,7 @@ static int bsec_read_shadow(struct udevice *dev, u32 base, u32 *val, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_write_shadow(struct udevice *dev, u32 base, u32 val, u32 otp)
+static int bsec_write_shadow(struct udevice *dev, void __iomem *base, u32 val, u32 otp)
 {
 	/* check if programming of otp is locked */
 	if (bsec_read_SW_lock(base, otp))
@@ -252,7 +287,7 @@ static int bsec_write_shadow(struct udevice *dev, u32 base, u32 val, u32 otp)
  * after the function the otp data is not refreshed in shadow
  * Return: 0 if no error
  */
-static int bsec_program_otp(struct udevice *dev, long base, u32 val, u32 otp)
+static int bsec_program_otp(struct udevice *dev,void __iomem *base, u32 val, u32 otp)
 {
 	u32 ret;
 	bool power_up = false;
@@ -302,7 +337,7 @@ static int bsec_program_otp(struct udevice *dev, long base, u32 val, u32 otp)
  * @otp: otp number (0 - BSEC_OTP_MAX_VALUE)
  * Return: 0 if no error
  */
-static int bsec_permanent_lock_otp(struct udevice *dev, long base, uint32_t otp)
+static int bsec_permanent_lock_otp(struct udevice *dev, void __iomem *base, uint32_t otp)
 {
 	int ret;
 	bool power_up = false;
@@ -356,7 +391,16 @@ static int bsec_permanent_lock_otp(struct udevice *dev, long base, uint32_t otp)
 
 /* BSEC MISC driver *******************************************************/
 struct stm32mp_bsec_plat {
-	u32 base;
+	void __iomem *base;
+};
+
+struct stm32mp_bsec_priv {
+	struct udevice *tee;
+};
+
+struct stm32mp_bsec_drvdata {
+	int size;
+	bool ta;
 };
 
 static int stm32mp_bsec_read_otp(struct udevice *dev, u32 *val, u32 otp)
@@ -468,18 +512,112 @@ static int stm32mp_bsec_write_lock(struct udevice *dev, u32 val, u32 otp)
 	plat = dev_get_plat(dev);
 
 	return bsec_permanent_lock_otp(dev, plat->base, otp);
+}
+
+static int bsec_pta_open_session(struct udevice *tee, u32 *tee_session)
+{
+	const struct tee_optee_ta_uuid uuid = PTA_BSEC_UUID;
+	struct tee_open_session_arg arg;
+	int rc;
 
-	return -EINVAL;
+	memset(&arg, 0, sizeof(arg));
+	tee_optee_ta_uuid_to_octets(arg.uuid, &uuid);
+	arg.clnt_login = TEE_LOGIN_REE_KERNEL;
+	rc = tee_open_session(tee, &arg, 0, NULL);
+	if (rc < 0)
+		return -ENODEV;
+
+	*tee_session = arg.session;
+
+	return 0;
+}
+
+static int bsec_optee_open(struct udevice *dev)
+{
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	struct udevice *tee;
+	u32 tee_session;
+	int rc;
+
+	tee = tee_find_device(NULL, NULL, NULL, NULL);
+	if (!tee)
+		return -ENODEV;
+
+	/* try to open the STM32 BSEC TA */
+	rc = bsec_pta_open_session(tee, &tee_session);
+	if (rc)
+		return rc;
+
+	tee_close_session(tee, tee_session);
+
+	priv->tee = tee;
+
+	return 0;
+}
+
+static int bsec_optee_pta(struct udevice *dev, int cmd, int type, int offset,
+			  void *buff, ulong size)
+{
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	u32 tee_session;
+	struct tee_invoke_arg arg;
+	struct tee_param param[2];
+	struct tee_shm *fw_shm;
+	int rc;
+
+	rc = bsec_pta_open_session(priv->tee, &tee_session);
+	if (rc)
+		return rc;
+
+	rc = tee_shm_register(priv->tee, buff, size, 0, &fw_shm);
+	if (rc)
+		goto close_session;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.func = cmd;
+	arg.session = tee_session;
+
+	memset(param, 0, sizeof(param));
+
+	param[0].attr = TEE_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = offset;
+	param[0].u.value.b = type;
+
+	if (cmd == PTA_BSEC_WRITE_MEM)
+		param[1].attr = TEE_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else
+		param[1].attr = TEE_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+
+	param[1].u.memref.shm = fw_shm;
+	param[1].u.memref.size = size;
+
+	rc = tee_invoke_func(priv->tee, &arg, 2, param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(priv->tee,
+			"PTA_BSEC invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	tee_shm_free(fw_shm);
+
+close_session:
+	tee_close_session(priv->tee, tee_session);
+
+	return rc;
 }
 
 static int stm32mp_bsec_read(struct udevice *dev, int offset,
 			     void *buf, int size)
 {
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	struct stm32mp_bsec_drvdata *data = (struct stm32mp_bsec_drvdata *)dev_get_driver_data(dev);
 	int ret;
 	int i;
 	bool shadow = true, lock = false;
 	int nb_otp = size / sizeof(u32);
-	int otp;
+	int otp, cmd;
 	unsigned int offs = offset;
 
 	if (offs >= STM32_BSEC_LOCK_OFFSET) {
@@ -490,12 +628,25 @@ static int stm32mp_bsec_read(struct udevice *dev, int offset,
 		shadow = false;
 	}
 
-	if ((offs % 4) || (size % 4))
+	if ((offs % 4) || (size % 4) || !size)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_OPTEE) && priv->tee) {
+		cmd = FUSE_ACCESS;
+		if (shadow)
+			cmd = SHADOW_ACCESS;
+		if (lock)
+			cmd = LOCK_ACCESS;
+		ret = bsec_optee_pta(dev, PTA_BSEC_READ_MEM, cmd, offs, buf, size);
+		if (ret)
+			return ret;
+
+		return size;
+	}
+
 	otp = offs / sizeof(u32);
 
-	for (i = otp; i < (otp + nb_otp) && i <= BSEC_OTP_MAX_VALUE; i++) {
+	for (i = otp; i < (otp + nb_otp) && i < data->size; i++) {
 		u32 *addr = &((u32 *)buf)[i - otp];
 
 		if (lock)
@@ -517,11 +668,13 @@ static int stm32mp_bsec_read(struct udevice *dev, int offset,
 static int stm32mp_bsec_write(struct udevice *dev, int offset,
 			      const void *buf, int size)
 {
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	struct stm32mp_bsec_drvdata *data = (struct stm32mp_bsec_drvdata *)dev_get_driver_data(dev);
 	int ret = 0;
 	int i;
 	bool shadow = true, lock = false;
 	int nb_otp = size / sizeof(u32);
-	int otp;
+	int otp, cmd;
 	unsigned int offs = offset;
 
 	if (offs >= STM32_BSEC_LOCK_OFFSET) {
@@ -532,12 +685,25 @@ static int stm32mp_bsec_write(struct udevice *dev, int offset,
 		shadow = false;
 	}
 
-	if ((offs % 4) || (size % 4))
+	if ((offs % 4) || (size % 4) || !size)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_OPTEE) && priv->tee) {
+		cmd = FUSE_ACCESS;
+		if (shadow)
+			cmd = SHADOW_ACCESS;
+		if (lock)
+			cmd = LOCK_ACCESS;
+		ret = bsec_optee_pta(dev, PTA_BSEC_WRITE_MEM, cmd, offs, (void *)buf, size);
+		if (ret)
+			return ret;
+
+		return size;
+	}
+
 	otp = offs / sizeof(u32);
 
-	for (i = otp; i < otp + nb_otp && i <= BSEC_OTP_MAX_VALUE; i++) {
+	for (i = otp; i < otp + nb_otp && i < data->size; i++) {
 		u32 *val = &((u32 *)buf)[i - otp];
 
 		if (lock)
@@ -564,13 +730,14 @@ static int stm32mp_bsec_of_to_plat(struct udevice *dev)
 {
 	struct stm32mp_bsec_plat *plat = dev_get_plat(dev);
 
-	plat->base = (u32)dev_read_addr_ptr(dev);
+	plat->base = dev_read_addr_ptr(dev);
 
 	return 0;
 }
 
 static int stm32mp_bsec_probe(struct udevice *dev)
 {
+	struct stm32mp_bsec_drvdata *data = (struct stm32mp_bsec_drvdata *)dev_get_driver_data(dev);
 	int otp;
 	struct stm32mp_bsec_plat *plat;
 	struct clk_bulk clk_bulk;
@@ -583,14 +750,23 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 			return ret;
 	}
 
+	if (IS_ENABLED(CONFIG_OPTEE))
+		ret = bsec_optee_open(dev);
+	else
+		ret = -ENOTSUPP;
+	/* failed if OP-TEE TA is required */
+	if (data->ta && !ret)
+		return ret;
+
 	/*
 	 * update unlocked shadow for OTP cleared by the rom code
 	 * only executed in SPL, it is done in TF-A for TFABOOT
 	 */
-	if (IS_ENABLED(CONFIG_SPL_BUILD)) {
+	if (IS_ENABLED(CONFIG_SPL_BUILD) && !data->ta) {
 		plat = dev_get_plat(dev);
 
-		for (otp = 57; otp <= BSEC_OTP_MAX_VALUE; otp++)
+		/* here 57 is the value for STM32MP15x ROM code, only MPU with SPL support*/
+		for (otp = 57; otp < data->size; otp++)
 			if (!bsec_read_SR_lock(plat->base, otp))
 				bsec_shadow_register(dev, plat->base, otp);
 	}
@@ -598,8 +774,25 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 	return 0;
 }
 
+static const struct stm32mp_bsec_drvdata stm32mp13_data = {
+	.size = 96,
+	.ta = true,
+};
+
+static const struct stm32mp_bsec_drvdata stm32mp15_data = {
+	.size = 96,
+	.ta = false,
+};
+
+static const struct stm32mp_bsec_drvdata stm32mp25_data = {
+	.size = 368, /* 384 but no access to HWKEY and STM32PRVKEY */
+	.ta = true,
+};
+
 static const struct udevice_id stm32mp_bsec_ids[] = {
-	{ .compatible = "st,stm32mp15-bsec" },
+	{ .compatible = "st,stm32mp13-bsec", .data = (ulong)&stm32mp13_data},
+	{ .compatible = "st,stm32mp15-bsec", .data = (ulong)&stm32mp15_data},
+	{ .compatible = "st,stm32mp25-bsec", .data = (ulong)&stm32mp25_data},
 	{}
 };
 
@@ -608,7 +801,8 @@ U_BOOT_DRIVER(stm32mp_bsec) = {
 	.id = UCLASS_MISC,
 	.of_match = stm32mp_bsec_ids,
 	.of_to_plat = stm32mp_bsec_of_to_plat,
-	.plat_auto	= sizeof(struct stm32mp_bsec_plat),
+	.plat_auto = sizeof(struct stm32mp_bsec_plat),
+	.priv_auto = sizeof(struct stm32mp_bsec_priv),
 	.ops = &stm32mp_bsec_ops,
 	.probe = stm32mp_bsec_probe,
 };
diff --git a/arch/arm/mach-stm32mp/cmd_stm32key.c b/arch/arm/mach-stm32mp/cmd_stm32key.c
index 68f28922d1..0cc1bbfa72 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32key.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32key.c
@@ -8,16 +8,208 @@
 #include <console.h>
 #include <log.h>
 #include <misc.h>
+#include <asm/arch/bsec.h>
 #include <dm/device.h>
 #include <dm/uclass.h>
 
-/* Closed device : bit 6 of OPT0*/
-#define STM32_OTP_CLOSE_ID		0
-#define STM32_OTP_CLOSE_MASK		BIT(6)
+/*
+ * Closed device: OTP0
+ * STM32MP15x: bit 6 of OTP0
+ * STM32MP13x: 0b111111 = 0x3F for OTP_SECURED closed device
+ * STM32MP25x: bit 0 of OTP18
+ */
+#define STM32MP1_OTP_CLOSE_ID				0
+#define STM32_OTP_STM32MP13X_CLOSE_MASK			GENMASK(5, 0)
+#define STM32_OTP_STM32MP15X_CLOSE_MASK			BIT(6)
+#define STM32MP25_OTP_WORD8				8
+#define STM32_OTP_STM32MP25X_BOOTROM_CLOSE_MASK		GENMASK(7, 0)
+#define STM32MP25_OTP_CLOSE_ID				18
+#define STM32_OTP_STM32MP25X_CLOSE_MASK			GENMASK(3, 0)
+#define STM32_OTP_STM32MP25X_PROVISIONING_DONE_MASK	GENMASK(7, 4)
+#define STM32MP25_OTP_HWCONFIG				124
+#define STM32_OTP_STM32MP25X_DISABLE_SCAN_MASK		BIT(20)
+
+#define STM32MP25_OTP_BOOTROM_CONF8	17
+#define STM32_OTP_STM32MP25X_OEM_KEY2_EN	BIT(8)
+
+/* PKH is the first element of the key list */
+#define STM32KEY_PKH 0
+
+struct stm32key {
+	char *name;
+	char *desc;
+	u16 start;
+	u8 size;
+	int (*post_process)(struct udevice *dev);
+};
+
+const struct stm32key stm32mp13_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "PKHTH",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm)",
+		.start = 24,
+		.size = 8,
+	},
+	{
+		.name = "EDMK",
+		.desc = "Encryption/Decryption Master Key",
+		.start = 92,
+		.size = 4,
+	}
+};
+
+const struct stm32key stm32mp15_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "PKH",
+		.desc = "Hash of the ECC Public Key (ECDSA is the authentication algorithm)",
+		.start = 24,
+		.size = 8,
+	}
+};
+
+static int post_process_oem_key2(struct udevice *dev);
+
+const struct stm32key stm32mp25_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "OEM-KEY1",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm) for FSBLA or M",
+		.start = 144,
+		.size = 8,
+	},
+	{
+		.name = "OEM-KEY2",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm) for FSBLM",
+		.start = 152,
+		.size = 8,
+		.post_process = post_process_oem_key2,
+	},
+	{
+		.name = "FIP-EDMK",
+		.desc = "Encryption/Decryption Master Key for FIP",
+		.start = 260,
+		.size = 8,
+	},
+	{
+		.name = "EDMK1",
+		.desc = "Encryption/Decryption Master Key for FSBLA or M",
+		.start = 364,
+		.size = 4,
+	},
+	{
+		.name = "EDMK2",
+		.desc = "Encryption/Decryption Master Key for FSBLM",
+		.start = 360,
+		.size = 4,
+	}
+};
+
+struct otp_close {
+	u32 word;
+	u32 mask_wr;
+	u32 mask_rd;
+	bool (*close_status_ops)(u32 value, u32 mask);
+};
+
+static bool compare_mask_exact(u32 value, u32 mask)
+{
+	return ((value & mask) == mask);
+}
+
+static bool compare_any_bits(u32 value, u32 mask)
+{
+	return ((value & mask) != 0);
+}
+
+const struct otp_close stm32mp13_close_state_otp[] = {
+	{
+		.word = STM32MP1_OTP_CLOSE_ID,
+		.mask_wr = STM32_OTP_STM32MP13X_CLOSE_MASK,
+		.mask_rd = STM32_OTP_STM32MP13X_CLOSE_MASK,
+		.close_status_ops = compare_mask_exact,
+	}
+};
+
+const struct otp_close stm32mp15_close_state_otp[] = {
+	{
+		.word = STM32MP1_OTP_CLOSE_ID,
+		.mask_wr = STM32_OTP_STM32MP15X_CLOSE_MASK,
+		.mask_rd = STM32_OTP_STM32MP15X_CLOSE_MASK,
+		.close_status_ops = compare_mask_exact,
+	}
+};
+
+const struct otp_close stm32mp25_close_state_otp[] = {
+	{
+		.word = STM32MP25_OTP_WORD8,
+		.mask_wr = STM32_OTP_STM32MP25X_BOOTROM_CLOSE_MASK,
+		.mask_rd = 0,
+		.close_status_ops = NULL
+	},
+	{
+		.word = STM32MP25_OTP_CLOSE_ID,
+		.mask_wr = STM32_OTP_STM32MP25X_CLOSE_MASK |
+			   STM32_OTP_STM32MP25X_PROVISIONING_DONE_MASK,
+		.mask_rd = STM32_OTP_STM32MP25X_CLOSE_MASK,
+		.close_status_ops = compare_any_bits
+	},
+	{
+		.word = STM32MP25_OTP_HWCONFIG,
+		.mask_wr = STM32_OTP_STM32MP25X_DISABLE_SCAN_MASK,
+		.mask_rd = 0,
+		.close_status_ops = NULL
+	},
+};
+
+/* index of current selected key in stm32key list, 0 = PKH by default */
+static u8 stm32key_index;
+
+static u8 get_key_nb(void)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return ARRAY_SIZE(stm32mp13_list);
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return ARRAY_SIZE(stm32mp15_list);
+
+	if (IS_ENABLED(CONFIG_STM32MP25X))
+		return ARRAY_SIZE(stm32mp25_list);
+}
+
+static const struct stm32key *get_key(u8 index)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return &stm32mp13_list[index];
 
-/* HASH of key: 8 OTPs, starting with OTP24) */
-#define STM32_OTP_HASH_KEY_START	24
-#define STM32_OTP_HASH_KEY_SIZE		8
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return &stm32mp15_list[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP25X))
+		return &stm32mp25_list[index];
+}
+
+static u8 get_otp_close_state_nb(void)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return ARRAY_SIZE(stm32mp13_close_state_otp);
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return ARRAY_SIZE(stm32mp15_close_state_otp);
+
+	if (IS_ENABLED(CONFIG_STM32MP25X))
+		return ARRAY_SIZE(stm32mp25_close_state_otp);
+}
+
+static const struct otp_close *get_otp_close_state(u8 index)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return &stm32mp13_close_state_otp[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return &stm32mp15_close_state_otp[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP25X))
+		return &stm32mp25_close_state_otp[index];
+}
 
 static int get_misc_dev(struct udevice **dev)
 {
@@ -30,108 +222,172 @@ static int get_misc_dev(struct udevice **dev)
 	return ret;
 }
 
-static void read_hash_value(u32 addr)
+static void read_key_value(const struct stm32key *key, u32 addr)
 {
 	int i;
 
-	printf("Read KEY at 0x%x\n", addr);
-	for (i = 0; i < STM32_OTP_HASH_KEY_SIZE; i++) {
-		printf("OTP value %i: %x\n", STM32_OTP_HASH_KEY_START + i,
-		       __be32_to_cpu(*(u32 *)addr));
+	for (i = 0; i < key->size; i++) {
+		printf("%s OTP %i: [%08x] %08x\n", key->name, key->start + i,
+		       addr, __be32_to_cpu(*(u32 *)(long)addr));
 		addr += 4;
 	}
 }
 
-static int read_hash_otp(bool print, bool *locked, bool *closed)
+static int read_key_otp(struct udevice *dev, const struct stm32key *key, bool print, bool *locked)
 {
-	struct udevice *dev;
 	int i, word, ret;
-	int nb_invalid = 0, nb_zero = 0, nb_lock = 0;
+	int nb_invalid = 0, nb_zero = 0, nb_lock = 0, nb_lock_err = 0;
 	u32 val, lock;
 	bool status;
 
-	ret = get_misc_dev(&dev);
-	if (ret)
-		return ret;
-
-	for (i = 0, word = STM32_OTP_HASH_KEY_START; i < STM32_OTP_HASH_KEY_SIZE; i++, word++) {
+	for (i = 0, word = key->start; i < key->size; i++, word++) {
 		ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
 		if (ret != 4)
 			val = ~0x0;
 		ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
 		if (ret != 4)
-			lock = -1;
+			lock = BSEC_LOCK_ERROR;
 		if (print)
-			printf("OTP HASH %i: %x lock : %d\n", word, val, lock);
+			printf("%s OTP %i: %08x lock : %08x\n", key->name, word, val, lock);
 		if (val == ~0x0)
 			nb_invalid++;
 		else if (val == 0x0)
 			nb_zero++;
-		if (lock == 1)
+		if (lock & BSEC_LOCK_PERM)
 			nb_lock++;
+		if (lock & BSEC_LOCK_ERROR)
+			nb_lock_err++;
 	}
 
-	word = STM32_OTP_CLOSE_ID;
-	ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
-	if (ret != 4)
-		val = 0x0;
-	ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
-	if (ret != 4)
-		lock = -1;
-
-	status = (val & STM32_OTP_CLOSE_MASK) == STM32_OTP_CLOSE_MASK;
-	if (closed)
-		*closed = status;
-	if (print)
-		printf("OTP %d: closed status: %d lock : %d\n", word, status, lock);
-
-	status = (nb_lock == STM32_OTP_HASH_KEY_SIZE);
+	status = nb_lock_err || (nb_lock == key->size);
 	if (locked)
 		*locked = status;
-	if (!status && print)
-		printf("Hash of key is not locked!\n");
+	if (nb_lock_err && print)
+		printf("%s lock is invalid!\n", key->name);
+	else if (!status && print)
+		printf("%s is not locked!\n", key->name);
 
-	if (nb_invalid == STM32_OTP_HASH_KEY_SIZE) {
+	if (nb_invalid == key->size) {
 		if (print)
-			printf("Hash of key is invalid!\n");
+			printf("%s is invalid!\n", key->name);
 		return -EINVAL;
 	}
-	if (nb_zero == STM32_OTP_HASH_KEY_SIZE) {
+	if (nb_zero == key->size) {
 		if (print)
-			printf("Hash of key is free!\n");
+			printf("%s is free!\n", key->name);
 		return -ENOENT;
 	}
 
 	return 0;
 }
 
-static int fuse_hash_value(u32 addr, bool print)
+static int read_close_status(struct udevice *dev, bool print, bool *closed)
+{
+	int ret, result, i;
+	const struct otp_close *otp_close = NULL;
+	u32 otp_close_nb = get_otp_close_state_nb();
+	u32 val, lock, mask, word = 0;
+	bool status = true;
+	bool tested_once = false;
+
+	result = 0;
+	for (i = 0; status && (i < otp_close_nb); i++) {
+		otp_close = get_otp_close_state(i);
+
+		if (!otp_close->close_status_ops)
+			continue;
+
+		mask = otp_close->mask_rd;
+		word = otp_close->word;
+
+		ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
+		if (ret < 0)
+			result = ret;
+		if (ret != 4)
+			val = 0x0;
+
+		ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
+		if (ret < 0)
+			result = ret;
+		if (ret != 4)
+			lock = BSEC_LOCK_ERROR;
+
+		status = otp_close->close_status_ops(val, mask);
+		tested_once = true;
+	}
+
+	if (!tested_once)
+		status = false;
+
+	if (closed)
+		*closed = status;
+	if (print)
+		printf("OTP %d: closed status: %d lock : %08x\n", word, status, lock);
+
+	return result;
+}
+
+static int write_close_status(struct udevice *dev)
+{
+	int i;
+	u32 val, word, ret;
+	const struct otp_close *otp_close = NULL;
+	u32 otp_num = get_otp_close_state_nb();
+
+	for (i = 0; i < otp_num; i++) {
+		otp_close = get_otp_close_state(i);
+		val = otp_close->mask_wr;
+		word = otp_close->word;
+		ret = misc_write(dev, STM32_BSEC_OTP(word), &val, 4);
+		if (ret != 4) {
+			log_err("Error: can't update OTP %d\n", word);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int post_process_oem_key2(struct udevice *dev)
+{
+	int ret;
+	u32 val;
+
+	ret = misc_read(dev, STM32_BSEC_OTP(STM32MP25_OTP_BOOTROM_CONF8), &val, 4);
+	if (ret != 4) {
+		log_err("Error %d failed to read STM32MP25_OTP_BOOTROM_CONF8\n", ret);
+		return -EIO;
+	}
+
+	val |= STM32_OTP_STM32MP25X_OEM_KEY2_EN;
+	ret = misc_write(dev, STM32_BSEC_OTP(STM32MP25_OTP_BOOTROM_CONF8), &val, 4);
+	if (ret != 4) {
+		log_err("Error %d failed to write OEM_KEY2_ENABLE\n", ret);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int fuse_key_value(struct udevice *dev, const struct stm32key *key, u32 addr, bool print)
 {
-	struct udevice *dev;
 	u32 word, val;
 	int i, ret;
 
-	ret = get_misc_dev(&dev);
-	if (ret)
-		return ret;
-
-	for (i = 0, word = STM32_OTP_HASH_KEY_START;
-	     i < STM32_OTP_HASH_KEY_SIZE;
-	     i++, word++, addr += 4) {
-		val = __be32_to_cpu(*(u32 *)addr);
+	for (i = 0, word = key->start; i < key->size; i++, word++, addr += 4) {
+		val = __be32_to_cpu(*(u32 *)(long)addr);
 		if (print)
-			printf("Fuse OTP %i : %x\n", word, val);
+			printf("Fuse %s OTP %i : %08x\n", key->name, word, val);
 
 		ret = misc_write(dev, STM32_BSEC_OTP(word), &val, 4);
 		if (ret != 4) {
-			log_err("Fuse OTP %i failed\n", word);
+			log_err("Fuse %s OTP %i failed\n", key->name, word);
 			return ret;
 		}
-		/* on success, lock the OTP for HASH key */
-		val = 1;
+		/* on success, lock the OTP for the key */
+		val = BSEC_LOCK_PERM;
 		ret = misc_write(dev, STM32_BSEC_LOCK(word), &val, 4);
 		if (ret != 4) {
-			log_err("Lock OTP %i failed\n", word);
+			log_err("Lock %s OTP %i failed\n", key->name, word);
 			return ret;
 		}
 	}
@@ -153,28 +409,103 @@ static int confirm_prog(void)
 	return 0;
 }
 
+static void display_key_info(const struct stm32key *key)
+{
+	printf("%s : %s\n", key->name, key->desc);
+	printf("\tOTP%d..%d\n", key->start, key->start + key->size - 1);
+}
+
+static int do_stm32key_list(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int i;
+
+	for (i = 0; i < get_key_nb(); i++)
+		display_key_info(get_key(i));
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_stm32key_select(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	const struct stm32key *key;
+	int i;
+
+	if (argc == 1) {
+		printf("Selected key:\n");
+		key = get_key(stm32key_index);
+		display_key_info(key);
+		return CMD_RET_SUCCESS;
+	}
+
+	for (i = 0; i < get_key_nb(); i++) {
+		key = get_key(i);
+		if (!strcmp(key->name, argv[1])) {
+			printf("%s selected\n", key->name);
+			stm32key_index = i;
+			return CMD_RET_SUCCESS;
+		}
+	}
+
+	printf("Unknown key %s\n", argv[1]);
+
+	return CMD_RET_FAILURE;
+}
+
 static int do_stm32key_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
+	const struct stm32key *key;
+	struct udevice *dev;
 	u32 addr;
+	int ret, i;
+	int result;
+
+	ret = get_misc_dev(&dev);
 
 	if (argc == 1) {
-		read_hash_otp(true, NULL, NULL);
+		if (ret)
+			return CMD_RET_FAILURE;
+		key = get_key(stm32key_index);
+		ret = read_key_otp(dev, key, true, NULL);
+		if (ret != -ENOENT)
+			return CMD_RET_FAILURE;
 		return CMD_RET_SUCCESS;
 	}
 
+	if (!strcmp("-a", argv[1])) {
+		if (ret)
+			return CMD_RET_FAILURE;
+		result = CMD_RET_SUCCESS;
+		for (i = 0; i < get_key_nb(); i++) {
+			key = get_key(i);
+			ret = read_key_otp(dev, key, true, NULL);
+			if (ret != -ENOENT)
+				result = CMD_RET_FAILURE;
+		}
+		ret = read_close_status(dev, true, NULL);
+		if (ret)
+			result = CMD_RET_FAILURE;
+
+		return result;
+	}
+
 	addr = hextoul(argv[1], NULL);
 	if (!addr)
 		return CMD_RET_USAGE;
 
-	read_hash_value(addr);
+	key = get_key(stm32key_index);
+	printf("Read %s at 0x%08x\n", key->name, addr);
+	read_key_value(key, addr);
 
 	return CMD_RET_SUCCESS;
 }
 
 static int do_stm32key_fuse(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
+	const struct stm32key *key = get_key(stm32key_index);
+	struct udevice *dev;
 	u32 addr;
-	bool yes = false, lock, closed;
+	int ret;
+	bool yes = false, lock;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -189,32 +520,47 @@ static int do_stm32key_fuse(struct cmd_tbl *cmdtp, int flag, int argc, char *con
 	if (!addr)
 		return CMD_RET_USAGE;
 
-	if (read_hash_otp(!yes, &lock, &closed) != -ENOENT) {
+	ret = get_misc_dev(&dev);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	if (read_key_otp(dev, key, !yes, &lock) != -ENOENT) {
 		printf("Error: can't fuse again the OTP\n");
 		return CMD_RET_FAILURE;
 	}
-
-	if (lock || closed) {
-		printf("Error: invalid OTP configuration (lock=%d, closed=%d)\n", lock, closed);
+	if (lock) {
+		printf("Error: %s is locked\n", key->name);
 		return CMD_RET_FAILURE;
 	}
 
+	if (!yes) {
+		printf("Writing %s with\n", key->name);
+		read_key_value(key, addr);
+	}
+
 	if (!yes && !confirm_prog())
 		return CMD_RET_FAILURE;
 
-	if (fuse_hash_value(addr, !yes))
+	if (fuse_key_value(dev, key, addr, !yes))
 		return CMD_RET_FAILURE;
 
-	printf("Hash key updated !\n");
+	if (key->post_process) {
+		if (key->post_process(dev)) {
+			printf("Error: %s for post process\n", key->name);
+			return CMD_RET_FAILURE;
+		}
+	}
+
+	printf("%s updated !\n", key->name);
 
 	return CMD_RET_SUCCESS;
 }
 
 static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
+	const struct stm32key *key;
 	bool yes, lock, closed;
 	struct udevice *dev;
-	u32 val;
 	int ret;
 
 	yes = false;
@@ -224,34 +570,34 @@ static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *co
 		yes = true;
 	}
 
-	ret = read_hash_otp(!yes, &lock, &closed);
-	if (ret) {
-		if (ret == -ENOENT)
-			printf("Error: OTP not programmed!\n");
+	ret = get_misc_dev(&dev);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	if (read_close_status(dev, !yes, &closed))
 		return CMD_RET_FAILURE;
-	}
 
 	if (closed) {
 		printf("Error: already closed!\n");
 		return CMD_RET_FAILURE;
 	}
 
+	/* check PKH status before to close */
+	key = get_key(STM32KEY_PKH);
+	ret = read_key_otp(dev, key, !yes, &lock);
+	if (ret) {
+		if (ret == -ENOENT)
+			printf("Error: %s not programmed!\n", key->name);
+		return CMD_RET_FAILURE;
+	}
 	if (!lock)
-		printf("Warning: OTP not locked!\n");
+		printf("Warning: %s not locked!\n", key->name);
 
 	if (!yes && !confirm_prog())
 		return CMD_RET_FAILURE;
 
-	ret = get_misc_dev(&dev);
-	if (ret)
-		return CMD_RET_FAILURE;
-
-	val = STM32_OTP_CLOSE_MASK;
-	ret = misc_write(dev, STM32_BSEC_OTP(STM32_OTP_CLOSE_ID), &val, 4);
-	if (ret != 4) {
-		printf("Error: can't update OTP\n");
+	if (write_close_status(dev))
 		return CMD_RET_FAILURE;
-	}
 
 	printf("Device is closed !\n");
 
@@ -259,11 +605,37 @@ static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *co
 }
 
 static char stm32key_help_text[] =
-	"read [<addr>]: Read the hash stored at addr in memory or in OTP\n"
-	"stm32key fuse [-y] <addr> : Fuse hash stored at addr in OTP\n"
-	"stm32key close [-y] : Close the device, the hash stored in OTP\n";
-
-U_BOOT_CMD_WITH_SUBCMDS(stm32key, "Fuse ST Hash key", stm32key_help_text,
+	"list : list the supported key with description\n"
+	"stm32key select [<key>] : Select the key identified by <key> or display the key used for read/fuse command\n"
+	"stm32key read [<addr> | -a ] : Read the curent key at <addr> or current / all (-a) key in OTP\n"
+	"stm32key fuse [-y] <addr> : Fuse the current key at addr in OTP\n"
+	"stm32key close [-y] : Close the device\n";
+
+U_BOOT_CMD_WITH_SUBCMDS(stm32key, "Manage key on STM32", stm32key_help_text,
+	U_BOOT_SUBCMD_MKENT(list, 1, 0, do_stm32key_list),
+	U_BOOT_SUBCMD_MKENT(select, 2, 0, do_stm32key_select),
 	U_BOOT_SUBCMD_MKENT(read, 2, 0, do_stm32key_read),
 	U_BOOT_SUBCMD_MKENT(fuse, 3, 0, do_stm32key_fuse),
 	U_BOOT_SUBCMD_MKENT(close, 2, 0, do_stm32key_close));
+
+/*
+ * Check the "closed" state in product life cycle, when product secrets have
+ * been provisioned into the device, by SSP tools for example.
+ * On closed devices, authentication is mandatory.
+ */
+bool stm32mp_is_closed(void)
+{
+	struct udevice *dev;
+	bool closed;
+	int ret;
+
+	ret = get_misc_dev(&dev);
+	if (ret)
+		return false;
+
+	ret = read_close_status(dev, false, &closed);
+	if (ret)
+		return false;
+
+	return closed;
+}
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig b/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
index 8f91db4b46..490097e98b 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/Kconfig
@@ -17,6 +17,7 @@ config CMD_STM32PROG
 config CMD_STM32PROG_USB
 	bool "support stm32prog over USB"
 	depends on CMD_STM32PROG
+	depends on USB_GADGET_DOWNLOAD
 	default y
 	help
 		activate the command "stm32prog usb" for STM32MP soc family
@@ -26,6 +27,8 @@ config CMD_STM32PROG_USB
 config CMD_STM32PROG_SERIAL
 	bool "support stm32prog over UART"
 	depends on CMD_STM32PROG
+	imply DISABLE_CONSOLE
+	imply SILENT_CONSOLE
 	default y
 	help
 		activate the command "stm32prog serial" for STM32MP soc family
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
index f59414e716..465589d02a 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
@@ -61,7 +61,7 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	dev = (int)dectoul(argv[2], NULL);
 
-	addr = STM32_DDR_BASE;
+	addr = CONFIG_SYS_LOAD_ADDR;
 	size = 0;
 	if (argc > 3) {
 		addr = hextoul(argv[3], NULL);
@@ -126,21 +126,21 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 		char *bootm_argv[5] = {
 			"bootm", boot_addr_start, "-", dtb_addr, NULL
 		};
-		u32 uimage = data->uimage;
-		u32 dtb = data->dtb;
-		u32 initrd = data->initrd;
+		const void *uimage = (void *)data->uimage;
+		const void *dtb = (void *)data->dtb;
+		const void *initrd = (void *)data->initrd;
 
 		if (!dtb)
 			bootm_argv[3] = env_get("fdtcontroladdr");
 		else
 			snprintf(dtb_addr, sizeof(dtb_addr) - 1,
-				 "0x%x", dtb);
+				 "0x%p", dtb);
 
 		snprintf(boot_addr_start, sizeof(boot_addr_start) - 1,
-			 "0x%x", uimage);
+			 "0x%p", uimage);
 
 		if (initrd) {
-			snprintf(initrd_addr, sizeof(initrd_addr) - 1, "0x%x:0x%x",
+			snprintf(initrd_addr, sizeof(initrd_addr) - 1, "0x%p:0x%zx",
 				 initrd, data->initrd_size);
 			bootm_argv[2] = initrd_addr;
 		}
@@ -148,7 +148,7 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 		printf("Booting kernel at %s %s %s...\n\n\n",
 		       boot_addr_start, bootm_argv[2], bootm_argv[3]);
 		/* Try bootm for legacy and FIT format image */
-		if (genimg_get_format((void *)uimage) != IMAGE_FORMAT_INVALID)
+		if (genimg_get_format(uimage) != IMAGE_FORMAT_INVALID)
 			do_bootm(cmdtp, 0, 4, bootm_argv);
 		else if (CONFIG_IS_ENABLED(CMD_BOOTZ))
 			do_bootz(cmdtp, 0, 4, bootm_argv);
@@ -180,20 +180,3 @@ U_BOOT_CMD(stm32prog, 5, 0, do_stm32prog,
 	   "  <size> = size of flashlayout (optional for image with STM32 header)\n"
 );
 
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-bool stm32prog_get_tee_partitions(void)
-{
-	if (stm32prog_data)
-		return stm32prog_data->tee_detected;
-
-	return false;
-}
-#endif
-
-bool stm32prog_get_fsbl_nor(void)
-{
-	if (stm32prog_data)
-		return stm32prog_data->fsbl_nor_detected;
-
-	return false;
-}
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
index c391b6c7ab..6488bcb30b 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
@@ -13,6 +13,7 @@
 #include <part.h>
 #include <tee.h>
 #include <asm/arch/stm32mp1_smc.h>
+#include <asm/arch/sys_proto.h>
 #include <asm/global_data.h>
 #include <dm/device_compat.h>
 #include <dm/uclass.h>
@@ -63,6 +64,12 @@ static const efi_guid_t uuid_mmc[3] = {
 	ROOTFS_MMC2_UUID
 };
 
+/*
+ * GUID value defined in the FWU specification for identification
+ * of the FWU metadata partition.
+ */
+#define FWU_MDATA_UUID "8a7a84a0-8387-40f6-ab41-a8b9a5a60d23"
+
 /* FIP type partition UUID used by TF-A*/
 #define FIP_TYPE_UUID "19D5DF83-11B0-457B-BE2C-7559C13142A5"
 
@@ -208,11 +215,6 @@ static int optee_ta_invoke(struct stm32prog_data *data, int cmd, int type,
 	return rc;
 }
 
-/* partition handling routines : CONFIG_CMD_MTDPARTS */
-int mtdparts_init(void);
-int find_dev_and_part(const char *id, struct mtd_device **dev,
-		      u8 *part_num, struct part_info **part);
-
 char *stm32prog_get_error(struct stm32prog_data *data)
 {
 	static const char error_msg[] = "Unspecified";
@@ -322,7 +324,7 @@ void stm32prog_header_check(uintptr_t raw_header, struct image_header_s *header)
 	header->image_length = 0x0;
 }
 
-static u32 stm32prog_header_checksum(u32 addr, struct image_header_s *header)
+static u32 stm32prog_header_checksum(uintptr_t addr, struct image_header_s *header)
 {
 	u32 i, checksum;
 	u8 *payload;
@@ -398,7 +400,7 @@ static int parse_name(struct stm32prog_data *data,
 	if (strlen(p) < sizeof(part->name)) {
 		strcpy(part->name, p);
 	} else {
-		stm32prog_err("Layout line %d: partition name too long [%d]: %s",
+		stm32prog_err("Layout line %d: partition name too long [%zd]: %s",
 			      i, strlen(p), p);
 		result = -EINVAL;
 	}
@@ -430,8 +432,14 @@ static int parse_type(struct stm32prog_data *data,
 		}
 	} else if (!strcmp(p, "FIP")) {
 		part->part_type = PART_FIP;
+	} else if (!strcmp(p, "FWU_MDATA")) {
+		part->part_type = PART_FWU_MDATA;
+	} else if (!strcmp(p, "ENV")) {
+		part->part_type = PART_ENV;
 	} else if (!strcmp(p, "System")) {
 		part->part_type = PART_SYSTEM;
+	} else if (!strcmp(p, "ESP")) {
+		part->part_type = PART_ESP;
 	} else if (!strcmp(p, "FileSystem")) {
 		part->part_type = PART_FILESYSTEM;
 	} else if (!strcmp(p, "RawImage")) {
@@ -514,7 +522,7 @@ static int parse_offset(struct stm32prog_data *data,
 			stm32prog_err("Layout line %d: invalid part '%s'",
 				      i, p);
 	} else {
-		part->addr = simple_strtoull(p, &tail, 0);
+		part->addr = simple_strtoull(p, &tail, 10);
 		if (tail == p || *tail != '\0') {
 			stm32prog_err("Layout line %d: invalid offset '%s'",
 				      i, p);
@@ -537,7 +545,7 @@ int (* const parse[COL_NB_STM32])(struct stm32prog_data *data, int i, char *p,
 };
 
 static int parse_flash_layout(struct stm32prog_data *data,
-			      ulong addr,
+			      uintptr_t addr,
 			      ulong size)
 {
 	int column = 0, part_nb = 0, ret;
@@ -741,6 +749,7 @@ static int init_device(struct stm32prog_data *data,
 	struct mmc *mmc = NULL;
 	struct blk_desc *block_dev = NULL;
 	struct mtd_info *mtd = NULL;
+	struct mtd_info *partition;
 	char mtd_id[16];
 	int part_id;
 	int ret;
@@ -749,6 +758,7 @@ static int init_device(struct stm32prog_data *data,
 	u64 part_addr, part_size;
 	bool part_found;
 	const char *part_name;
+	u8 i;
 
 	switch (dev->target) {
 	case STM32PROG_MMC:
@@ -793,10 +803,11 @@ static int init_device(struct stm32prog_data *data,
 			stm32prog_err("unknown device type = %d", dev->target);
 			return -ENODEV;
 		}
+		/* register partitions with MTDIDS/MTDPARTS or OF fallback */
+		mtd_probe_devices();
 		get_mtd_by_target(mtd_id, dev->target, dev->dev_id);
 		log_debug("%s\n", mtd_id);
 
-		mtdparts_init();
 		mtd = get_mtd_device_nm(mtd_id);
 		if (IS_ERR(mtd)) {
 			stm32prog_err("MTD device %s not found", mtd_id);
@@ -943,25 +954,23 @@ static int init_device(struct stm32prog_data *data,
 		}
 
 		if (IS_ENABLED(CONFIG_MTD) && mtd) {
-			char mtd_part_id[32];
-			struct part_info *mtd_part;
-			struct mtd_device *mtd_dev;
-			u8 part_num;
-
-			sprintf(mtd_part_id, "%s,%d", mtd_id,
-				part->part_id - 1);
-			ret = find_dev_and_part(mtd_part_id, &mtd_dev,
-						&part_num, &mtd_part);
-			if (ret != 0) {
-				stm32prog_err("%s (0x%x): Invalid MTD partition %s",
-					      part->name, part->id,
-					      mtd_part_id);
+			i = 0;
+			list_for_each_entry(partition, &mtd->partitions, node) {
+				if ((part->part_id - 1) == i) {
+					part_found = true;
+					break;
+				}
+				i++;
+			}
+			if (part_found) {
+				part_addr = partition->offset;
+				part_size = partition->size;
+				part_name = partition->name;
+			} else {
+				stm32prog_err("%s (0x%x):Couldn't find part %d on device mtd %s",
+					      part->name, part->id, part->part_id, mtd_id);
 				return -ENODEV;
 			}
-			part_addr = mtd_part->offset;
-			part_size = mtd_part->size;
-			part_name = mtd_part->name;
-			part_found = true;
 		}
 
 		/* no partition for this device */
@@ -999,10 +1008,6 @@ static int treat_partition_list(struct stm32prog_data *data)
 		INIT_LIST_HEAD(&data->dev[j].part_list);
 	}
 
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	data->tee_detected = false;
-#endif
-	data->fsbl_nor_detected = false;
 	for (i = 0; i < data->part_nb; i++) {
 		part = &data->part_array[i];
 		part->alt_id = -1;
@@ -1047,23 +1052,6 @@ static int treat_partition_list(struct stm32prog_data *data)
 			stm32prog_err("Layout: too many device");
 			return -EINVAL;
 		}
-		switch (part->target)  {
-		case STM32PROG_NOR:
-			if (!data->fsbl_nor_detected &&
-			    !strncmp(part->name, "fsbl", 4))
-				data->fsbl_nor_detected = true;
-			/* fallthrough */
-		case STM32PROG_NAND:
-		case STM32PROG_SPI_NAND:
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-			if (!data->tee_detected &&
-			    !strncmp(part->name, "tee", 3))
-				data->tee_detected = true;
-			break;
-#endif
-		default:
-			break;
-		}
 		part->dev = &data->dev[j];
 		if (!IS_SELECT(part))
 			part->dev->full_update = false;
@@ -1090,7 +1078,6 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 	if (!buf)
 		return -ENOMEM;
 
-	puts("partitions : ");
 	/* initialize the selected device */
 	for (i = 0; i < data->dev_nb; i++) {
 		/* create gpt partition support only for full update on MMC */
@@ -1098,6 +1085,7 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 		    !data->dev[i].full_update)
 			continue;
 
+		printf("partitions on mmc%d: ", data->dev[i].dev_id);
 		offset = 0;
 		rootfs_found = false;
 		memset(buf, 0, buflen);
@@ -1130,10 +1118,20 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 			case PART_BINARY:
 				type_str = LINUX_RESERVED_UUID;
 				break;
+			case PART_ENV:
+				type_str = "u-boot-env";
+				break;
 			case PART_FIP:
 				type_str = FIP_TYPE_UUID;
 				break;
-			default:
+			case PART_FWU_MDATA:
+				type_str = FWU_MDATA_UUID;
+				break;
+			case PART_ESP:
+				/* EFI System Partition */
+				type_str = "system";
+				break;
+			default: /* PART_FILESYSTEM or PART_SYSTEM for distro */
 				type_str = "linux";
 				break;
 			}
@@ -1197,8 +1195,8 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 		sprintf(buf, "part list mmc %d", data->dev[i].dev_id);
 		run_command(buf, 0);
 #endif
+		puts("done\n");
 	}
-	puts("done\n");
 
 #ifdef DEBUG
 	run_command("mtd list", 0);
@@ -1342,10 +1340,22 @@ static int dfu_init_entities(struct stm32prog_data *data)
 	struct stm32prog_part_t *part;
 	struct dfu_entity *dfu;
 	int alt_nb;
+	u32 otp_size = 0;
 
 	alt_nb = 1; /* number of virtual = CMD*/
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_OTP))
-		alt_nb++; /* OTP*/
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_OTP) && !stm32mp_is_closed()) {
+		/* OTP_SIZE_SMC = 0 if SMC is not supported */
+		otp_size = OTP_SIZE_SMC;
+		/* check if PTA BSEC is supported */
+		ret = optee_ta_open(data);
+		log_debug("optee_ta_open(PTA_NVMEM) result %d\n", ret);
+		if (!ret && data->tee)
+			otp_size = OTP_SIZE_TA;
+		if (otp_size)
+			alt_nb++; /* OTP*/
+	}
+
 	if (CONFIG_IS_ENABLED(DM_PMIC))
 		alt_nb++; /* PMIC NVMEM*/
 
@@ -1363,6 +1373,7 @@ static int dfu_init_entities(struct stm32prog_data *data)
 	puts("DFU alt info setting: ");
 	if (data->part_nb) {
 		alt_id = 0;
+		ret = 0;
 		for (phase = 1;
 		     (phase <= PHASE_LAST_USER) &&
 		     (alt_id < alt_nb) && !ret;
@@ -1388,7 +1399,7 @@ static int dfu_init_entities(struct stm32prog_data *data)
 		char buf[ALT_BUF_LEN];
 
 		sprintf(buf, "@FlashLayout/0x%02x/1*256Ke ram %x 40000",
-			PHASE_FLASHLAYOUT, STM32_DDR_BASE);
+			PHASE_FLASHLAYOUT, CONFIG_SYS_LOAD_ADDR);
 		ret = dfu_alt_add(dfu, "ram", NULL, buf);
 		log_debug("dfu_alt_add(ram, NULL,%s) result %d\n", buf, ret);
 	}
@@ -1396,12 +1407,8 @@ static int dfu_init_entities(struct stm32prog_data *data)
 	if (!ret)
 		ret = stm32prog_alt_add_virt(dfu, "virtual", PHASE_CMD, CMD_SIZE);
 
-	if (!ret && IS_ENABLED(CONFIG_CMD_STM32PROG_OTP)) {
-		ret = optee_ta_open(data);
-		log_debug("optee_ta result %d\n", ret);
-		ret = stm32prog_alt_add_virt(dfu, "OTP", PHASE_OTP,
-					     data->tee ? OTP_SIZE_TA : OTP_SIZE_SMC);
-	}
+	if (!ret && IS_ENABLED(CONFIG_CMD_STM32PROG_OTP) && otp_size)
+		ret = stm32prog_alt_add_virt(dfu, "OTP", PHASE_OTP, otp_size);
 
 	if (!ret && CONFIG_IS_ENABLED(DM_PMIC))
 		ret = stm32prog_alt_add_virt(dfu, "PMIC", PHASE_PMIC, PMIC_SIZE);
@@ -1430,8 +1437,11 @@ int stm32prog_otp_write(struct stm32prog_data *data, u32 offset, u8 *buffer,
 
 	if (!data->otp_part) {
 		data->otp_part = memalign(CONFIG_SYS_CACHELINE_SIZE, otp_size);
-		if (!data->otp_part)
+		if (!data->otp_part) {
+			stm32prog_err("OTP write issue %d", -ENOMEM);
+
 			return -ENOMEM;
+		}
 	}
 
 	if (!offset)
@@ -1440,7 +1450,7 @@ int stm32prog_otp_write(struct stm32prog_data *data, u32 offset, u8 *buffer,
 	if (offset + *size > otp_size)
 		*size = otp_size - offset;
 
-	memcpy((void *)((u32)data->otp_part + offset), buffer, *size);
+	memcpy((void *)((uintptr_t)data->otp_part + offset), buffer, *size);
 
 	return 0;
 }
@@ -1479,7 +1489,7 @@ int stm32prog_otp_read(struct stm32prog_data *data, u32 offset, u8 *buffer,
 						 data->otp_part, OTP_SIZE_TA);
 		else if (IS_ENABLED(CONFIG_ARM_SMCCC))
 			result = stm32_smc_exec(STM32_SMC_BSEC, STM32_SMC_READ_ALL,
-						(u32)data->otp_part, 0);
+						(unsigned long)data->otp_part, 0);
 		if (result)
 			goto end_otp_read;
 	}
@@ -1491,9 +1501,11 @@ int stm32prog_otp_read(struct stm32prog_data *data, u32 offset, u8 *buffer,
 
 	if (offset + *size > otp_size)
 		*size = otp_size - offset;
-	memcpy(buffer, (void *)((u32)data->otp_part + offset), *size);
+	memcpy(buffer, (void *)((uintptr_t)data->otp_part + offset), *size);
 
 end_otp_read:
+	if (result)
+		stm32prog_err("OTP read issue %d", result);
 	log_debug("%s: result %i\n", __func__, result);
 
 	return result;
@@ -1521,7 +1533,7 @@ int stm32prog_otp_start(struct stm32prog_data *data)
 					 data->otp_part, OTP_SIZE_TA);
 	} else if (IS_ENABLED(CONFIG_ARM_SMCCC)) {
 		arm_smccc_smc(STM32_SMC_BSEC, STM32_SMC_WRITE_ALL,
-			      (u32)data->otp_part, 0, 0, 0, 0, 0, &res);
+			      (uintptr_t)data->otp_part, 0, 0, 0, 0, 0, &res);
 
 		if (!res.a0) {
 			switch (res.a1) {
@@ -1547,6 +1559,8 @@ int stm32prog_otp_start(struct stm32prog_data *data)
 
 	free(data->otp_part);
 	data->otp_part = NULL;
+	if (result)
+		stm32prog_err("OTP write issue %d", result);
 	log_debug("%s: result %i\n", __func__, result);
 
 	return result;
@@ -1699,15 +1713,15 @@ static void stm32prog_end_phase(struct stm32prog_data *data, u64 offset)
 {
 	if (data->phase == PHASE_FLASHLAYOUT) {
 #if defined(CONFIG_LEGACY_IMAGE_FORMAT)
-		if (genimg_get_format((void *)STM32_DDR_BASE) == IMAGE_FORMAT_LEGACY) {
-			data->script = STM32_DDR_BASE;
+		if (genimg_get_format((void *)CONFIG_SYS_LOAD_ADDR) == IMAGE_FORMAT_LEGACY) {
+			data->script = CONFIG_SYS_LOAD_ADDR;
 			data->phase = PHASE_END;
 			log_notice("U-Boot script received\n");
 			return;
 		}
 #endif
 		log_notice("\nFlashLayout received, size = %lld\n", offset);
-		if (parse_flash_layout(data, STM32_DDR_BASE, offset))
+		if (parse_flash_layout(data, CONFIG_SYS_LOAD_ADDR, offset))
 			stm32prog_err("Layout: invalid FlashLayout");
 		return;
 	}
@@ -1884,6 +1898,10 @@ static void stm32prog_devices_init(struct stm32prog_data *data)
 	if (ret)
 		goto error;
 
+	/* empty flashlayout */
+	if (!data->dev_nb)
+		return;
+
 	/* initialize the selected device */
 	for (i = 0; i < data->dev_nb; i++) {
 		ret = init_device(data, &data->dev[i]);
@@ -1947,7 +1965,7 @@ int stm32prog_dfu_init(struct stm32prog_data *data)
 	return dfu_init_entities(data);
 }
 
-int stm32prog_init(struct stm32prog_data *data, ulong addr, ulong size)
+int stm32prog_init(struct stm32prog_data *data, uintptr_t addr, ulong size)
 {
 	memset(data, 0x0, sizeof(*data));
 	data->read_phase = PHASE_RESET;
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
index ac300768ca..79c9f10b29 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
@@ -20,8 +20,19 @@
 #define DEFAULT_ADDRESS		0xFFFFFFFF
 
 #define CMD_SIZE		512
+/* SMC is only supported in SPMIN for STM32MP15X */
+#ifdef CONFIG_STM32MP15X
 #define OTP_SIZE_SMC		1024
-#define OTP_SIZE_TA		776
+#else
+#define OTP_SIZE_SMC		0
+#endif
+/* size of the OTP struct in NVMEM PTA */
+#define _OTP_SIZE_TA(otp)	(((otp) * 2 + 2) * 4)
+#ifdef CONFIG_STM32MP25X
+#define OTP_SIZE_TA		_OTP_SIZE_TA(368)
+#else
+#define OTP_SIZE_TA		_OTP_SIZE_TA(96)
+#endif
 #define PMIC_SIZE		8
 
 enum stm32prog_target {
@@ -91,12 +102,20 @@ struct stm32_header_v2 {
 	u8 extension_padding[376];
 };
 
-/* partition type in flashlayout file */
+/*
+ * partition type in flashlayout file
+ * SYSTEM = linux partition, bootable
+ * FILESYSTEM = linux partition
+ * ESP = EFI system partition
+ */
 enum stm32prog_part_type {
 	PART_BINARY,
 	PART_FIP,
+	PART_FWU_MDATA,
+	PART_ENV,
 	PART_SYSTEM,
 	PART_FILESYSTEM,
+	PART_ESP,
 	RAW_IMAGE,
 };
 
@@ -144,17 +163,13 @@ struct stm32prog_data {
 	struct stm32prog_dev_t	dev[STM32PROG_MAX_DEV];	/* array of device */
 	int			part_nb;	/* nb of partition */
 	struct stm32prog_part_t	*part_array;	/* array of partition */
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	bool			tee_detected;
-#endif
-	bool			fsbl_nor_detected;
 
 	/* command internal information */
 	unsigned int		phase;
 	u32			offset;
 	char			error[255];
 	struct stm32prog_part_t	*cur_part;
-	u32			*otp_part;
+	void			*otp_part;
 	u8			pmic_part[PMIC_SIZE];
 
 	/* SERIAL information */
@@ -165,12 +180,12 @@ struct stm32prog_data {
 	u8	read_phase;
 
 	/* bootm information */
-	u32	uimage;
-	u32	dtb;
-	u32	initrd;
-	u32	initrd_size;
+	uintptr_t	uimage;
+	uintptr_t	dtb;
+	uintptr_t	initrd;
+	size_t		initrd_size;
 
-	u32	script;
+	uintptr_t	script;
 
 	/* OPTEE PTA NVMEM */
 	struct udevice *tee;
@@ -209,7 +224,7 @@ char *stm32prog_get_error(struct stm32prog_data *data);
 	}
 
 /* Main function */
-int stm32prog_init(struct stm32prog_data *data, ulong addr, ulong size);
+int stm32prog_init(struct stm32prog_data *data, uintptr_t addr, ulong size);
 void stm32prog_clean(struct stm32prog_data *data);
 
 #ifdef CONFIG_CMD_STM32PROG_SERIAL
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
index 2932eae757..9f2ab2b625 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
@@ -300,7 +300,7 @@ static void stm32prog_serial_putc(u8 w_byte)
 }
 
 /* Helper function ************************************************/
-static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
+static u8 stm32prog_start(struct stm32prog_data *data, uintptr_t address)
 {
 	u8 ret = 0;
 	struct dfu_entity *dfu_entity;
@@ -353,7 +353,7 @@ static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
 	} else {
 		void (*entry)(void) = (void *)address;
 
-		printf("## Starting application at 0x%x ...\n", address);
+		printf("## Starting application at 0x%p ...\n", (void *)address);
 		(*entry)();
 		printf("## Application terminated\n");
 		ret = -ENOEXEC;
@@ -368,9 +368,9 @@ static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
  * @tmp_xor:		Current xor value to update
  * Return: The address area
  */
-static u32 get_address(u8 *tmp_xor)
+static uintptr_t get_address(u8 *tmp_xor)
 {
-	u32 address = 0x0;
+	uintptr_t address = 0x0;
 	u8 data;
 
 	data = stm32prog_serial_getc();
@@ -462,7 +462,7 @@ static void get_phase_command(struct stm32prog_data *data)
 		length = strlen(err_msg);
 	}
 	if (phase == PHASE_FLASHLAYOUT)
-		destination = STM32_DDR_BASE;
+		destination = CONFIG_SYS_LOAD_ADDR;
 
 	stm32prog_serial_putc(length + 5);           /* Total length */
 	stm32prog_serial_putc(phase & 0xFF);         /* partition ID */
@@ -487,7 +487,7 @@ static void get_phase_command(struct stm32prog_data *data)
  */
 static void read_memory_command(struct stm32prog_data *data)
 {
-	u32 address = 0x0;
+	uintptr_t address = 0x0;
 	u8 rcv_data = 0x0, tmp_xor = 0x0;
 	u32 counter = 0x0;
 
@@ -532,7 +532,7 @@ static void read_memory_command(struct stm32prog_data *data)
  */
 static void start_command(struct stm32prog_data *data)
 {
-	u32 address = 0;
+	uintptr_t address = 0;
 	u8 tmp_xor = 0x0;
 	u8 ret, rcv_data;
 
@@ -546,8 +546,7 @@ static void start_command(struct stm32prog_data *data)
 		return;
 	}
 	/* validate partition */
-	ret = stm32prog_start(data,
-			      address);
+	ret = stm32prog_start(data, address);
 
 	if (ret)
 		stm32prog_serial_result(ABORT_BYTE);
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c
index a8b57c4d8f..be38ff239b 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c
@@ -41,7 +41,7 @@ static int stm32prog_set_phase(struct stm32prog_data *data, u8 phase,
 static int stm32prog_cmd_write(u64 offset, void *buf, long *len)
 {
 	u8 phase;
-	u32 address;
+	uintptr_t address;
 	u8 *pt = buf;
 	void (*entry)(void);
 	int ret;
@@ -58,7 +58,7 @@ static int stm32prog_cmd_write(u64 offset, void *buf, long *len)
 	address = (pt[1] << 24) | (pt[2] << 16) | (pt[3] << 8) | pt[4];
 	if (phase == PHASE_RESET) {
 		entry = (void *)address;
-		printf("## Starting application at 0x%x ...\n", address);
+		printf("## Starting application at 0x%p ...\n", entry);
 		(*entry)();
 		printf("## Application terminated\n");
 		return 0;
@@ -90,7 +90,7 @@ static int stm32prog_cmd_read(u64 offset, void *buf, long *len)
 	}
 	phase = stm32prog_data->phase;
 	if (phase == PHASE_FLASHLAYOUT)
-		destination = STM32_DDR_BASE;
+		destination = CONFIG_SYS_LOAD_ADDR;
 	dfu_offset = stm32prog_data->offset;
 
 	/* mandatory header, size = PHASE_MIN_SIZE */
diff --git a/arch/arm/mach-stm32mp/dram_init.c b/arch/arm/mach-stm32mp/dram_init.c
index 920b99bb68..98ea9d1d30 100644
--- a/arch/arm/mach-stm32mp/dram_init.c
+++ b/arch/arm/mach-stm32mp/dram_init.c
@@ -24,8 +24,16 @@ int dram_init(void)
 	int ret;
 
 	ret = uclass_get_device(UCLASS_RAM, 0, &dev);
-	if (ret) {
-		log_debug("RAM init failed: %d\n", ret);
+	/* in case there is no RAM driver, retrieve DDR size from DT */
+	if (ret == -ENODEV) {
+		ret = fdtdec_setup_mem_size_base();
+		if (ret)
+			return ret;
+		if (gd->ram_size > STM32_DDR_SIZE)
+			return -EINVAL;
+		return 0;
+	} else if (ret) {
+		log_err("RAM init failed: %d\n", ret);
 		return ret;
 	}
 	ret = ram_get_info(dev, &ram);
@@ -33,7 +41,7 @@ int dram_init(void)
 		log_debug("Cannot get RAM size: %d\n", ret);
 		return ret;
 	}
-	log_debug("RAM init base=%lx, size=%x\n", ram.base, ram.size);
+	log_debug("RAM init base=%p, size=%zx\n", (void *)ram.base, ram.size);
 
 	gd->ram_size = ram.size;
 
@@ -49,9 +57,15 @@ ulong board_get_usable_ram_top(ulong total_size)
 	if (!total_size)
 		return gd->ram_top;
 
+	/*
+	 * make sure U-Boot uses address space below 4GB boundaries even
+	 * if the effective available memory is bigger
+	 */
+	gd->ram_top = clamp_val((gd->ram_base + gd->ram_size), 0, SZ_4G - 1);
+
 	/* found enough not-reserved memory to relocated U-Boot */
 	lmb_init(&lmb);
-	lmb_add(&lmb, gd->ram_base, gd->ram_size);
+	lmb_add(&lmb, gd->ram_base, gd->ram_top - gd->ram_base);
 	boot_fdt_add_mem_rsv_regions(&lmb, (void *)gd->fdt_blob);
 	/* add 8M for reserved memory for display, fdt, gd,... */
 	size = ALIGN(SZ_8M + CONFIG_SYS_MALLOC_LEN + total_size, MMU_SECTION_SIZE),
diff --git a/arch/arm/mach-stm32mp/etzpc.c b/arch/arm/mach-stm32mp/etzpc.c
new file mode 100644
index 0000000000..25b8e518bb
--- /dev/null
+++ b/arch/arm/mach-stm32mp/etzpc.c
@@ -0,0 +1,205 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SIMPLE_BUS
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <linux/bitfield.h>
+#include <mach/etzpc.h>
+
+/* ETZPC peripheral as firewall bus */
+/* ETZPC registers */
+#define ETZPC_DECPROT			0x10
+
+/* ETZPC miscellaneous */
+#define ETZPC_PROT_MASK			GENMASK(1, 0)
+#define ETZPC_PROT_A7NS			0x3
+#define ETZPC_DECPROT_SHIFT		1
+
+#define IDS_PER_DECPROT_REGS		16
+#define STM32MP15_ETZPC_ENTRIES		96
+#define STM32MP13_ETZPC_ENTRIES		64
+
+/*
+ * struct stm32_sys_bus_match_data: Match data for ETZPC device
+ *
+ * @max_entries: Number of securable peripherals in ETZPC
+ */
+struct stm32_sys_bus_match_data {
+	unsigned int max_entries;
+};
+
+/*
+ * struct stm32_etzpc_plat: Information about ETZPC device
+ *
+ * @base: Base address of ETZPC
+ */
+struct stm32_etzpc_plat {
+	void *base;
+};
+
+static int etzpc_parse_feature_domain(ofnode node, struct ofnode_phandle_args *args)
+{
+	int ret;
+
+	ret = ofnode_parse_phandle_with_args(node, "feature-domains",
+					     "#feature-domain-cells", 0,
+					     0, args);
+	if (ret) {
+		log_debug("failed to parse feature-domains (%d)\n", ret);
+		return ret;
+	}
+
+	if (args->args_count != 1) {
+		log_debug("invalid domain args_count: %d\n", args->args_count);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int etzpc_check_access(void *base, u32 id)
+{
+	u32 reg_offset, offset, sec_val;
+
+	/* Check access configuration, 16 peripherals per register */
+	reg_offset = ETZPC_DECPROT + 0x4 * (id / IDS_PER_DECPROT_REGS);
+	offset = (id % IDS_PER_DECPROT_REGS) << ETZPC_DECPROT_SHIFT;
+
+	/* Verify peripheral is non-secure and attributed to cortex A7 */
+	sec_val = (readl(base + reg_offset) >> offset) & ETZPC_PROT_MASK;
+	if (sec_val != ETZPC_PROT_A7NS) {
+		log_debug("Invalid bus configuration: reg_offset %#x, value %d\n",
+			  reg_offset, sec_val);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+int stm32_etzpc_check_access_by_id(ofnode device_node, u32 id)
+{
+	struct stm32_sys_bus_match_data *pconf;
+	struct stm32_etzpc_plat *plat;
+	struct ofnode_phandle_args args;
+	struct udevice *dev;
+	int err;
+
+	err = etzpc_parse_feature_domain(device_node, &args);
+	if (err)
+		return err;
+
+	if (id == -1U)
+		id = args.args[0];
+
+	err = uclass_get_device_by_ofnode(UCLASS_NOP, args.node, &dev);
+	if (err || dev->driver != DM_DRIVER_GET(stm32_etzpc)) {
+		log_err("No device found\n");
+		return -EINVAL;
+	}
+
+	plat = dev_get_plat(dev);
+	pconf = (struct stm32_sys_bus_match_data *)dev_get_driver_data(dev);
+
+	if (id >= pconf->max_entries) {
+		dev_err(dev, "Invalid sys bus ID for %s\n", ofnode_get_name(device_node));
+		return -EINVAL;
+	}
+
+	return etzpc_check_access(plat->base, id);
+}
+
+int stm32_etzpc_check_access(ofnode device_node)
+{
+	return stm32_etzpc_check_access_by_id(device_node, -1U);
+}
+
+static int stm32_etzpc_bind(struct udevice *dev)
+{
+	struct stm32_etzpc_plat *plat = dev_get_plat(dev);
+	struct stm32_sys_bus_match_data *pconf;
+	struct ofnode_phandle_args args;
+	int ret = 0, err = 0;
+	ofnode node, parent;
+
+	plat->base = dev_read_addr_ptr(dev);
+	if (!plat->base) {
+		dev_err(dev, "can't get registers base address\n");
+		return -ENOENT;
+	}
+
+	pconf = (struct stm32_sys_bus_match_data *)dev_get_driver_data(dev);
+	parent = dev_ofnode(dev);
+	for (node = ofnode_first_subnode(parent);
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node))
+			continue;
+
+		err = etzpc_parse_feature_domain(node, &args);
+		if (err) {
+			dev_err(dev, "%s failed to parse child on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		if (!ofnode_equal(args.node, parent)) {
+			dev_err(dev, "%s phandle to %s\n",
+				node_name, ofnode_get_name(args.node));
+			continue;
+		}
+
+		if (args.args[0] >= pconf->max_entries) {
+			dev_err(dev, "Invalid sys bus ID for %s\n", node_name);
+			return -EINVAL;
+		}
+
+		err = etzpc_check_access(plat->base, args.args[0]);
+		if (err) {
+			dev_info(dev, "%s not allowed on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err) {
+			ret = err;
+			dev_err(dev, "%s failed to bind on bus (%d)\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_err(dev, "Some child failed to bind (%d)\n", ret);
+
+	return ret;
+}
+
+static const struct stm32_sys_bus_match_data stm32mp15_sys_bus_data = {
+	.max_entries = STM32MP15_ETZPC_ENTRIES,
+};
+
+static const struct stm32_sys_bus_match_data stm32mp13_sys_bus_data = {
+	.max_entries = STM32MP13_ETZPC_ENTRIES,
+};
+
+static const struct udevice_id stm32_etzpc_ids[] = {
+	{ .compatible = "st,stm32mp13-sys-bus", .data = (ulong)&stm32mp13_sys_bus_data },
+	{ .compatible = "st,stm32mp15-sys-bus", .data = (ulong)&stm32mp15_sys_bus_data },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_etzpc) = {
+	.name = "stm32_etzpc",
+	.id = UCLASS_NOP,
+	.of_match = stm32_etzpc_ids,
+	.bind = stm32_etzpc_bind,
+	.plat_auto = sizeof(struct stm32_etzpc_plat),
+};
diff --git a/arch/arm/mach-stm32mp/fdt.c b/arch/arm/mach-stm32mp/fdt.c
deleted file mode 100644
index 3b4c05d745..0000000000
--- a/arch/arm/mach-stm32mp/fdt.c
+++ /dev/null
@@ -1,514 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
-/*
- * Copyright (C) 2019-2020, STMicroelectronics - All Rights Reserved
- */
-
-#define LOG_CATEGORY LOGC_ARCH
-
-#include <common.h>
-#include <fdtdec.h>
-#include <fdt_support.h>
-#include <log.h>
-#include <tee.h>
-#include <asm/arch/sys_proto.h>
-#include <dt-bindings/pinctrl/stm32-pinfunc.h>
-#include <linux/io.h>
-
-#define ETZPC_DECPROT(n)	(STM32_ETZPC_BASE + 0x10 + 4 * (n))
-#define ETZPC_DECPROT_NB	6
-
-#define DECPROT_MASK		0x03
-#define NB_PROT_PER_REG		0x10
-#define DECPROT_NB_BITS		2
-
-#define DECPROT_SECURED		0x00
-#define DECPROT_WRITE_SECURE	0x01
-#define DECPROT_MCU_ISOLATION	0x02
-#define DECPROT_NON_SECURED	0x03
-
-#define ETZPC_RESERVED		0xffffffff
-
-#define STM32MP13_FDCAN_BASE	0x4400F000
-#define STM32MP13_ADC1_BASE	0x48003000
-#define STM32MP13_TSC_BASE	0x5000B000
-#define STM32MP13_CRYP_BASE	0x54002000
-#define STM32MP13_ETH2_BASE	0x5800E000
-#define STM32MP13_DCMIPP_BASE	0x5A000000
-#define STM32MP13_LTDC_BASE	0x5A010000
-
-#define STM32MP15_FDCAN_BASE	0x4400e000
-#define STM32MP15_CRYP2_BASE	0x4c005000
-#define STM32MP15_CRYP1_BASE	0x54001000
-#define STM32MP15_GPU_BASE	0x59000000
-#define STM32MP15_DSI_BASE	0x5a000000
-
-static const u32 stm32mp13_ip_addr[] = {
-	0x50025000,		/* 0 VREFBUF APB3 */
-	0x50021000,		/* 1 LPTIM2 APB3 */
-	0x50022000,		/* 2 LPTIM3 APB3 */
-	STM32MP13_LTDC_BASE,	/* 3 LTDC APB4 */
-	STM32MP13_DCMIPP_BASE,	/* 4 DCMIPP APB4 */
-	0x5A006000,		/* 5 USBPHYCTRL APB4 */
-	0x5A003000,		/* 6 DDRCTRLPHY APB4 */
-	ETZPC_RESERVED,		/* 7 Reserved*/
-	ETZPC_RESERVED,		/* 8 Reserved*/
-	ETZPC_RESERVED,		/* 9 Reserved*/
-	0x5C006000,		/* 10 TZC APB5 */
-	0x58001000,		/* 11 MCE APB5 */
-	0x5C000000,		/* 12 IWDG1 APB5 */
-	0x5C008000,		/* 13 STGENC APB5 */
-	ETZPC_RESERVED,		/* 14 Reserved*/
-	ETZPC_RESERVED,		/* 15 Reserved*/
-	0x4C000000,		/* 16 USART1 APB6 */
-	0x4C001000,		/* 17 USART2 APB6 */
-	0x4C002000,		/* 18 SPI4 APB6 */
-	0x4C003000,		/* 19 SPI5 APB6 */
-	0x4C004000,		/* 20 I2C3 APB6 */
-	0x4C005000,		/* 21 I2C4 APB6 */
-	0x4C006000,		/* 22 I2C5 APB6 */
-	0x4C007000,		/* 23 TIM12 APB6 */
-	0x4C008000,		/* 24 TIM13 APB6 */
-	0x4C009000,		/* 25 TIM14 APB6 */
-	0x4C00A000,		/* 26 TIM15 APB6 */
-	0x4C00B000,		/* 27 TIM16 APB6 */
-	0x4C00C000,		/* 28 TIM17 APB6 */
-	ETZPC_RESERVED,		/* 29 Reserved*/
-	ETZPC_RESERVED,		/* 30 Reserved*/
-	ETZPC_RESERVED,		/* 31 Reserved*/
-	STM32MP13_ADC1_BASE,	/* 32 ADC1 AHB2 */
-	0x48004000,		/* 33 ADC2 AHB2 */
-	0x49000000,		/* 34 OTG AHB2 */
-	ETZPC_RESERVED,		/* 35 Reserved*/
-	ETZPC_RESERVED,		/* 36 Reserved*/
-	STM32MP13_TSC_BASE,	/* 37 TSC AHB4 */
-	ETZPC_RESERVED,		/* 38 Reserved*/
-	ETZPC_RESERVED,		/* 39 Reserved*/
-	0x54004000,		/* 40 RNG AHB5 */
-	0x54003000,		/* 41 HASH AHB5 */
-	STM32MP13_CRYP_BASE,	/* 42 CRYPT AHB5 */
-	0x54005000,		/* 43 SAES AHB5 */
-	0x54006000,		/* 44 PKA AHB5 */
-	0x54000000,		/* 45 BKPSRAM AHB5 */
-	ETZPC_RESERVED,		/* 46 Reserved*/
-	ETZPC_RESERVED,		/* 47 Reserved*/
-	0x5800A000,		/* 48 ETH1 AHB6 */
-	STM32MP13_ETH2_BASE,	/* 49 ETH2 AHB6 */
-	0x58005000,		/* 50 SDMMC1 AHB6 */
-	0x58007000,		/* 51 SDMMC2 AHB6 */
-	ETZPC_RESERVED,		/* 52 Reserved*/
-	ETZPC_RESERVED,		/* 53 Reserved*/
-	0x58002000,		/* 54 FMC AHB6 */
-	0x58003000,		/* 55 QSPI AHB6 */
-	ETZPC_RESERVED,		/* 56 Reserved*/
-	ETZPC_RESERVED,		/* 57 Reserved*/
-	ETZPC_RESERVED,		/* 58 Reserved*/
-	ETZPC_RESERVED,		/* 59 Reserved*/
-	0x30000000,		/* 60 SRAM1 MLAHB */
-	0x30004000,		/* 61 SRAM2 MLAHB */
-	0x30006000,		/* 62 SRAM3 MLAHB */
-	ETZPC_RESERVED,		/* 63 Reserved*/
-	ETZPC_RESERVED,		/* 64 Reserved*/
-	ETZPC_RESERVED,		/* 65 Reserved*/
-	ETZPC_RESERVED,		/* 66 Reserved*/
-	ETZPC_RESERVED,		/* 67 Reserved*/
-	ETZPC_RESERVED,		/* 68 Reserved*/
-	ETZPC_RESERVED,		/* 69 Reserved*/
-	ETZPC_RESERVED,		/* 70 Reserved*/
-	ETZPC_RESERVED,		/* 71 Reserved*/
-	ETZPC_RESERVED,		/* 72 Reserved*/
-	ETZPC_RESERVED,		/* 73 Reserved*/
-	ETZPC_RESERVED,		/* 74 Reserved*/
-	ETZPC_RESERVED,		/* 75 Reserved*/
-	ETZPC_RESERVED,		/* 76 Reserved*/
-	ETZPC_RESERVED,		/* 77 Reserved*/
-	ETZPC_RESERVED,		/* 78 Reserved*/
-	ETZPC_RESERVED,		/* 79 Reserved*/
-	ETZPC_RESERVED,		/* 80 Reserved*/
-	ETZPC_RESERVED,		/* 81 Reserved*/
-	ETZPC_RESERVED,		/* 82 Reserved*/
-	ETZPC_RESERVED,		/* 83 Reserved*/
-	ETZPC_RESERVED,		/* 84 Reserved*/
-	ETZPC_RESERVED,		/* 85 Reserved*/
-	ETZPC_RESERVED,		/* 86 Reserved*/
-	ETZPC_RESERVED,		/* 87 Reserved*/
-	ETZPC_RESERVED,		/* 88 Reserved*/
-	ETZPC_RESERVED,		/* 89 Reserved*/
-	ETZPC_RESERVED,		/* 90 Reserved*/
-	ETZPC_RESERVED,		/* 91 Reserved*/
-	ETZPC_RESERVED,		/* 92 Reserved*/
-	ETZPC_RESERVED,		/* 93 Reserved*/
-	ETZPC_RESERVED,		/* 94 Reserved*/
-	ETZPC_RESERVED,		/* 95 Reserved*/
-};
-
-static const u32 stm32mp15_ip_addr[] = {
-	0x5c008000,	/* 00 stgenc */
-	0x54000000,	/* 01 bkpsram */
-	0x5c003000,	/* 02 iwdg1 */
-	0x5c000000,	/* 03 usart1 */
-	0x5c001000,	/* 04 spi6 */
-	0x5c002000,	/* 05 i2c4 */
-	ETZPC_RESERVED,	/* 06 reserved */
-	0x54003000,	/* 07 rng1 */
-	0x54002000,	/* 08 hash1 */
-	STM32MP15_CRYP1_BASE,	/* 09 cryp1 */
-	0x5a003000,	/* 0A ddrctrl */
-	0x5a004000,	/* 0B ddrphyc */
-	0x5c009000,	/* 0C i2c6 */
-	ETZPC_RESERVED,	/* 0D reserved */
-	ETZPC_RESERVED,	/* 0E reserved */
-	ETZPC_RESERVED,	/* 0F reserved */
-	0x40000000,	/* 10 tim2 */
-	0x40001000,	/* 11 tim3 */
-	0x40002000,	/* 12 tim4 */
-	0x40003000,	/* 13 tim5 */
-	0x40004000,	/* 14 tim6 */
-	0x40005000,	/* 15 tim7 */
-	0x40006000,	/* 16 tim12 */
-	0x40007000,	/* 17 tim13 */
-	0x40008000,	/* 18 tim14 */
-	0x40009000,	/* 19 lptim1 */
-	0x4000a000,	/* 1A wwdg1 */
-	0x4000b000,	/* 1B spi2 */
-	0x4000c000,	/* 1C spi3 */
-	0x4000d000,	/* 1D spdifrx */
-	0x4000e000,	/* 1E usart2 */
-	0x4000f000,	/* 1F usart3 */
-	0x40010000,	/* 20 uart4 */
-	0x40011000,	/* 21 uart5 */
-	0x40012000,	/* 22 i2c1 */
-	0x40013000,	/* 23 i2c2 */
-	0x40014000,	/* 24 i2c3 */
-	0x40015000,	/* 25 i2c5 */
-	0x40016000,	/* 26 cec */
-	0x40017000,	/* 27 dac */
-	0x40018000,	/* 28 uart7 */
-	0x40019000,	/* 29 uart8 */
-	ETZPC_RESERVED,	/* 2A reserved */
-	ETZPC_RESERVED,	/* 2B reserved */
-	0x4001c000,	/* 2C mdios */
-	ETZPC_RESERVED,	/* 2D reserved */
-	ETZPC_RESERVED,	/* 2E reserved */
-	ETZPC_RESERVED,	/* 2F reserved */
-	0x44000000,	/* 30 tim1 */
-	0x44001000,	/* 31 tim8 */
-	ETZPC_RESERVED,	/* 32 reserved */
-	0x44003000,	/* 33 usart6 */
-	0x44004000,	/* 34 spi1 */
-	0x44005000,	/* 35 spi4 */
-	0x44006000,	/* 36 tim15 */
-	0x44007000,	/* 37 tim16 */
-	0x44008000,	/* 38 tim17 */
-	0x44009000,	/* 39 spi5 */
-	0x4400a000,	/* 3A sai1 */
-	0x4400b000,	/* 3B sai2 */
-	0x4400c000,	/* 3C sai3 */
-	0x4400d000,	/* 3D dfsdm */
-	STM32MP15_FDCAN_BASE,	/* 3E tt_fdcan */
-	ETZPC_RESERVED,	/* 3F reserved */
-	0x50021000,	/* 40 lptim2 */
-	0x50022000,	/* 41 lptim3 */
-	0x50023000,	/* 42 lptim4 */
-	0x50024000,	/* 43 lptim5 */
-	0x50027000,	/* 44 sai4 */
-	0x50025000,	/* 45 vrefbuf */
-	0x4c006000,	/* 46 dcmi */
-	0x4c004000,	/* 47 crc2 */
-	0x48003000,	/* 48 adc */
-	0x4c002000,	/* 49 hash2 */
-	0x4c003000,	/* 4A rng2 */
-	STM32MP15_CRYP2_BASE,	/* 4B cryp2 */
-	ETZPC_RESERVED,	/* 4C reserved */
-	ETZPC_RESERVED,	/* 4D reserved */
-	ETZPC_RESERVED,	/* 4E reserved */
-	ETZPC_RESERVED,	/* 4F reserved */
-	ETZPC_RESERVED,	/* 50 sram1 */
-	ETZPC_RESERVED,	/* 51 sram2 */
-	ETZPC_RESERVED,	/* 52 sram3 */
-	ETZPC_RESERVED,	/* 53 sram4 */
-	ETZPC_RESERVED,	/* 54 retram */
-	0x49000000,	/* 55 otg */
-	0x48004000,	/* 56 sdmmc3 */
-	0x48005000,	/* 57 dlybsd3 */
-	0x48000000,	/* 58 dma1 */
-	0x48001000,	/* 59 dma2 */
-	0x48002000,	/* 5A dmamux */
-	0x58002000,	/* 5B fmc */
-	0x58003000,	/* 5C qspi */
-	0x58004000,	/* 5D dlybq */
-	0x5800a000,	/* 5E eth */
-	ETZPC_RESERVED,	/* 5F reserved */
-};
-
-/* fdt helper */
-static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
-{
-	int node;
-	fdt_addr_t regs;
-
-	for (node = fdt_first_subnode(fdt, offset);
-	     node >= 0;
-	     node = fdt_next_subnode(fdt, node)) {
-		regs = fdtdec_get_addr(fdt, node, "reg");
-		if (addr == regs) {
-			if (fdtdec_get_is_enabled(fdt, node)) {
-				fdt_status_disabled(fdt, node);
-
-				return true;
-			}
-			return false;
-		}
-	}
-
-	return false;
-}
-
-static int stm32_fdt_fixup_etzpc(void *fdt, int soc_node)
-{
-	const u32 *array;
-	int array_size, i;
-	int offset, shift;
-	u32 addr, status, decprot[ETZPC_DECPROT_NB];
-
-	if (IS_ENABLED(CONFIG_STM32MP13x)) {
-		array = stm32mp13_ip_addr;
-		array_size = ARRAY_SIZE(stm32mp13_ip_addr);
-	}
-
-	if (IS_ENABLED(CONFIG_STM32MP15x)) {
-		array = stm32mp15_ip_addr;
-		array_size = ARRAY_SIZE(stm32mp15_ip_addr);
-	}
-
-	for (i = 0; i < ETZPC_DECPROT_NB; i++)
-		decprot[i] = readl(ETZPC_DECPROT(i));
-
-	for (i = 0; i < array_size; i++) {
-		offset = i / NB_PROT_PER_REG;
-		shift = (i % NB_PROT_PER_REG) * DECPROT_NB_BITS;
-		status = (decprot[offset] >> shift) & DECPROT_MASK;
-		addr = array[i];
-
-		log_debug("ETZPC: 0x%08x decprot %d=%d\n", addr, i, status);
-
-		if (addr == ETZPC_RESERVED ||
-		    status == DECPROT_NON_SECURED)
-			continue;
-
-		if (fdt_disable_subnode_by_address(fdt, soc_node, addr))
-			log_notice("ETZPC: 0x%08x node disabled, decprot %d=%d\n",
-				   addr, i, status);
-	}
-
-	return 0;
-}
-
-/* deactivate all the cpu except core 0 */
-static void stm32_fdt_fixup_cpu(void *blob, char *name)
-{
-	int off;
-	u32 reg;
-
-	off = fdt_path_offset(blob, "/cpus");
-	if (off < 0) {
-		log_warning("%s: couldn't find /cpus node\n", __func__);
-		return;
-	}
-
-	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
-	while (off != -FDT_ERR_NOTFOUND) {
-		reg = fdtdec_get_addr(blob, off, "reg");
-		if (reg != 0) {
-			fdt_del_node(blob, off);
-			log_notice("FDT: cpu %d node remove for %s\n",
-				   reg, name);
-			/* after delete we can't trust the offsets anymore */
-			off = -1;
-		}
-		off = fdt_node_offset_by_prop_value(blob, off,
-						    "device_type", "cpu", 4);
-	}
-}
-
-static void stm32_fdt_disable(void *fdt, int offset, u32 addr,
-			      const char *string, const char *name)
-{
-	if (fdt_disable_subnode_by_address(fdt, offset, addr))
-		log_notice("FDT: %s@%08x node disabled for %s\n",
-			   string, addr, name);
-}
-
-static void stm32_fdt_disable_optee(void *blob)
-{
-	int off, node;
-
-	/* Delete "optee" firmware node */
-	off = fdt_node_offset_by_compatible(blob, -1, "linaro,optee-tz");
-	if (off >= 0 && fdtdec_get_is_enabled(blob, off))
-		fdt_del_node(blob, off);
-
-	/* Delete "optee@..." reserved-memory node */
-	off = fdt_path_offset(blob, "/reserved-memory/");
-	if (off < 0)
-		return;
-	for (node = fdt_first_subnode(blob, off);
-	     node >= 0;
-	     node = fdt_next_subnode(blob, node)) {
-		if (strncmp(fdt_get_name(blob, node, NULL), "optee@", 6))
-			continue;
-
-		if (fdt_del_node(blob, node))
-			printf("Failed to remove optee reserved-memory node\n");
-	}
-}
-
-static void stm32mp13_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
-{
-	switch (cpu) {
-	case CPU_STM32MP131Fxx:
-	case CPU_STM32MP131Dxx:
-	case CPU_STM32MP131Cxx:
-	case CPU_STM32MP131Axx:
-		stm32_fdt_disable(blob, soc, STM32MP13_FDCAN_BASE, "can", name);
-		stm32_fdt_disable(blob, soc, STM32MP13_ADC1_BASE, "adc", name);
-		fallthrough;
-	case CPU_STM32MP133Fxx:
-	case CPU_STM32MP133Dxx:
-	case CPU_STM32MP133Cxx:
-	case CPU_STM32MP133Axx:
-		stm32_fdt_disable(blob, soc, STM32MP13_LTDC_BASE, "ltdc", name);
-		stm32_fdt_disable(blob, soc, STM32MP13_DCMIPP_BASE, "dcmipp",
-				  name);
-		stm32_fdt_disable(blob, soc, STM32MP13_TSC_BASE, "tsc", name);
-		break;
-	default:
-		break;
-	}
-
-	switch (cpu) {
-	case CPU_STM32MP135Dxx:
-	case CPU_STM32MP135Axx:
-	case CPU_STM32MP133Dxx:
-	case CPU_STM32MP133Axx:
-	case CPU_STM32MP131Dxx:
-	case CPU_STM32MP131Axx:
-		stm32_fdt_disable(blob, soc, STM32MP13_CRYP_BASE, "cryp", name);
-		break;
-	default:
-		break;
-	}
-}
-
-static void stm32mp15_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
-{
-	u32 pkg;
-
-	switch (cpu) {
-	case CPU_STM32MP151Fxx:
-	case CPU_STM32MP151Dxx:
-	case CPU_STM32MP151Cxx:
-	case CPU_STM32MP151Axx:
-		stm32_fdt_fixup_cpu(blob, name);
-		/* after cpu delete we can't trust the soc offsets anymore */
-		soc = fdt_path_offset(blob, "/soc");
-		stm32_fdt_disable(blob, soc, STM32MP15_FDCAN_BASE, "can", name);
-		fallthrough;
-	case CPU_STM32MP153Fxx:
-	case CPU_STM32MP153Dxx:
-	case CPU_STM32MP153Cxx:
-	case CPU_STM32MP153Axx:
-		stm32_fdt_disable(blob, soc, STM32MP15_GPU_BASE, "gpu", name);
-		stm32_fdt_disable(blob, soc, STM32MP15_DSI_BASE, "dsi", name);
-		break;
-	default:
-		break;
-	}
-	switch (cpu) {
-	case CPU_STM32MP157Dxx:
-	case CPU_STM32MP157Axx:
-	case CPU_STM32MP153Dxx:
-	case CPU_STM32MP153Axx:
-	case CPU_STM32MP151Dxx:
-	case CPU_STM32MP151Axx:
-		stm32_fdt_disable(blob, soc, STM32MP15_CRYP1_BASE, "cryp",
-				  name);
-		stm32_fdt_disable(blob, soc, STM32MP15_CRYP2_BASE, "cryp",
-				  name);
-		break;
-	default:
-		break;
-	}
-	switch (get_cpu_package()) {
-	case STM32MP15_PKG_AA_LBGA448:
-		pkg = STM32MP_PKG_AA;
-		break;
-	case STM32MP15_PKG_AB_LBGA354:
-		pkg = STM32MP_PKG_AB;
-		break;
-	case STM32MP15_PKG_AC_TFBGA361:
-		pkg = STM32MP_PKG_AC;
-		break;
-	case STM32MP15_PKG_AD_TFBGA257:
-		pkg = STM32MP_PKG_AD;
-		break;
-	default:
-		pkg = 0;
-		break;
-	}
-	if (pkg) {
-		do_fixup_by_compat_u32(blob, "st,stm32mp157-pinctrl",
-				       "st,package", pkg, false);
-		do_fixup_by_compat_u32(blob, "st,stm32mp157-z-pinctrl",
-				       "st,package", pkg, false);
-	}
-}
-
-/*
- * This function is called right before the kernel is booted. "blob" is the
- * device tree that will be passed to the kernel.
- */
-int ft_system_setup(void *blob, struct bd_info *bd)
-{
-	int ret = 0;
-	int soc;
-	u32 cpu;
-	char name[SOC_NAME_SIZE];
-
-	soc = fdt_path_offset(blob, "/soc");
-	/* when absent, nothing to do */
-	if (soc == -FDT_ERR_NOTFOUND)
-		return 0;
-	if (soc < 0)
-		return soc;
-
-	if (CONFIG_IS_ENABLED(STM32_ETZPC)) {
-		ret = stm32_fdt_fixup_etzpc(blob, soc);
-		if (ret)
-			return ret;
-	}
-
-	/* MPUs Part Numbers and name*/
-	cpu = get_cpu_type();
-	get_soc_name(name);
-
-	if (IS_ENABLED(CONFIG_STM32MP13x))
-		stm32mp13_fdt_fixup(blob, soc, cpu, name);
-
-	if (IS_ENABLED(CONFIG_STM32MP15x)) {
-		stm32mp15_fdt_fixup(blob, soc, cpu, name);
-
-		/*
-		 * TEMP: remove OP-TEE nodes in kernel device tree
-		 *       copied from U-Boot device tree by optee_copy_fdt_nodes
-		 *       when OP-TEE is not detected (probe failed)
-		 * these OP-TEE nodes are present in <board>-u-boot.dtsi
-		 * under CONFIG_STM32MP15x_STM32IMAGE only for compatibility
-		 * when FIP is not used by TF-A
-		 */
-		if (CONFIG_IS_ENABLED(STM32MP15x_STM32IMAGE) &&
-		    !tee_find_device(NULL, NULL, NULL, NULL))
-			stm32_fdt_disable_optee(blob);
-	}
-
-	return ret;
-}
diff --git a/arch/arm/mach-stm32mp/include/mach/bsec.h b/arch/arm/mach-stm32mp/include/mach/bsec.h
index 252eac3946..10ebc535c4 100644
--- a/arch/arm/mach-stm32mp/include/mach/bsec.h
+++ b/arch/arm/mach-stm32mp/include/mach/bsec.h
@@ -5,3 +5,10 @@
 
 /* check self hosted debug status = BSEC_DENABLE.DBGSWENABLE */
 bool bsec_dbgswenable(void);
+
+/* Bitfield definition for LOCK status */
+#define BSEC_LOCK_PERM			BIT(30)
+#define BSEC_LOCK_SHADOW_R		BIT(29)
+#define BSEC_LOCK_SHADOW_W		BIT(28)
+#define BSEC_LOCK_SHADOW_P		BIT(27)
+#define BSEC_LOCK_ERROR			BIT(26)
diff --git a/arch/arm/mach-stm32mp/include/mach/etzpc.h b/arch/arm/mach-stm32mp/include/mach/etzpc.h
new file mode 100644
index 0000000000..fd697c3e2a
--- /dev/null
+++ b/arch/arm/mach-stm32mp/include/mach/etzpc.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef MACH_ETZPC_H
+#define MACH_ETZPC_H
+
+#include <linux/types.h>
+
+/**
+ * stm32_etzpc_check_access - Check ETZPC accesses for given device node
+ *
+ * @device_node		Node of the device for which the accesses are checked
+ *
+ * @returns 0 on success (if access is granted), -EINVAL if access is denied.
+ *          Else, returns an appropriate negative ERRNO value
+ */
+int stm32_etzpc_check_access(ofnode device_node);
+
+/**
+ * stm32_etzpc_check_access_by_id - Check ETZPC accesses for given id
+ *
+ * @device_node		Node of the device to get a reference on ETZPC
+ * @id			ID of the resource to check
+ *
+ * @returns 0 on success (if access is granted), -EINVAL if access is denied.
+ *          Else, returns an appropriate negative ERRNO value
+ */
+int stm32_etzpc_check_access_by_id(ofnode device_node, u32 id);
+
+#endif /* MACH_ETZPC_H*/
diff --git a/arch/arm/mach-stm32mp/include/mach/rif.h b/arch/arm/mach-stm32mp/include/mach/rif.h
new file mode 100644
index 0000000000..10b2210812
--- /dev/null
+++ b/arch/arm/mach-stm32mp/include/mach/rif.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef MACH_RIF_H
+#define MACH_RIF_H
+
+#include <linux/types.h>
+
+/**
+ * stm32_rifsc_check_access - Check RIF accesses for given device node
+ *
+ * @device_node		Node of the device for which the accesses are checked
+ */
+int stm32_rifsc_check_access(ofnode device_node);
+
+/**
+ * stm32_rifsc_check_access - Check RIF accesses for given id
+ *
+ * @device_node		Node of the device to get a reference on RIFSC
+ * @id			ID of the resource to check
+ */
+int stm32_rifsc_check_access_by_id(ofnode device_node, u32 id);
+
+#endif /* MACH_RIF_H*/
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32.h b/arch/arm/mach-stm32mp/include/mach/stm32.h
index c70375a723..7051ad3e2c 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32.h
@@ -8,16 +8,73 @@
 
 #ifndef __ASSEMBLY__
 #include <linux/bitops.h>
+
+enum boot_device {
+	BOOT_FLASH_SD = 0x10,
+	BOOT_FLASH_SD_1 = 0x11,
+	BOOT_FLASH_SD_2 = 0x12,
+	BOOT_FLASH_SD_3 = 0x13,
+
+	BOOT_FLASH_EMMC = 0x20,
+	BOOT_FLASH_EMMC_1 = 0x21,
+	BOOT_FLASH_EMMC_2 = 0x22,
+	BOOT_FLASH_EMMC_3 = 0x23,
+
+	BOOT_FLASH_NAND = 0x30,
+	BOOT_FLASH_NAND_FMC = 0x31,
+
+	BOOT_FLASH_NOR = 0x40,
+	BOOT_FLASH_NOR_QSPI = 0x41,
+
+	BOOT_SERIAL_UART = 0x50,
+	BOOT_SERIAL_UART_1 = 0x51,
+	BOOT_SERIAL_UART_2 = 0x52,
+	BOOT_SERIAL_UART_3 = 0x53,
+	BOOT_SERIAL_UART_4 = 0x54,
+	BOOT_SERIAL_UART_5 = 0x55,
+	BOOT_SERIAL_UART_6 = 0x56,
+	BOOT_SERIAL_UART_7 = 0x57,
+	BOOT_SERIAL_UART_8 = 0x58,
+
+	BOOT_SERIAL_USB = 0x60,
+	BOOT_SERIAL_USB_OTG = 0x62,
+
+	BOOT_FLASH_SPINAND = 0x70,
+	BOOT_FLASH_SPINAND_1 = 0x71,
+
+	BOOT_FLASH_HYPERFLASH = 0x80,
+	BOOT_FLASH_HYPERFLASH_1 = 0x81
+};
+
+#define TAMP_BOOT_MODE_MASK		GENMASK(15, 8)
+#define TAMP_BOOT_MODE_SHIFT		8
+#define TAMP_BOOT_DEVICE_MASK		GENMASK(7, 4)
+#define TAMP_BOOT_INSTANCE_MASK		GENMASK(3, 0)
+#define TAMP_BOOT_FORCED_MASK		GENMASK(7, 0)
+#define TAMP_BOOT_DEBUG_ON		BIT(16)
+
+enum forced_boot_mode {
+	BOOT_NORMAL = 0x00,
+	BOOT_FASTBOOT = 0x01,
+	BOOT_RECOVERY = 0x02,
+	BOOT_STM32PROG = 0x03,
+	BOOT_UMS_MMC0 = 0x10,
+	BOOT_UMS_MMC1 = 0x11,
+	BOOT_UMS_MMC2 = 0x12,
+};
+
 #endif
 
 /*
  * Peripheral memory map
  * only address used before device tree parsing
  */
+
+#if defined (CONFIG_STM32MP15X) || defined (CONFIG_STM32MP13X)
 #define STM32_RCC_BASE			0x50000000
 #define STM32_PWR_BASE			0x50001000
 #define STM32_SYSCFG_BASE		0x50020000
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_DBGMCU_BASE		0x50081000
 #endif
 #define STM32_FMC2_BASE			0x58002000
@@ -28,11 +85,11 @@
 #define STM32_STGEN_BASE		0x5C008000
 #define STM32_TAMP_BASE			0x5C00A000
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_USART1_BASE		0x5C000000
 #define STM32_USART2_BASE		0x4000E000
 #endif
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define STM32_USART1_BASE		0x4c000000
 #define STM32_USART2_BASE		0x4c001000
 #endif
@@ -47,7 +104,7 @@
 #define STM32_SDMMC2_BASE		0x58007000
 #define STM32_SDMMC3_BASE		0x48004000
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_SYSRAM_BASE		0x2FFC0000
 #define STM32_SYSRAM_SIZE		SZ_256K
 #endif
@@ -56,12 +113,6 @@
 #define STM32_DDR_SIZE			SZ_1G
 
 #ifndef __ASSEMBLY__
-/* enumerated used to identify the SYSCON driver instance */
-enum {
-	STM32MP_SYSCON_UNKNOWN,
-	STM32MP_SYSCON_SYSCFG,
-};
-
 /*
  * enumerated for boot interface from Bootrom, used in TAMP_BOOT_CONTEXT
  * - boot device = bit 8:4
@@ -72,79 +123,61 @@ enum {
 #define BOOT_INSTANCE_MASK	0x0F
 #define BOOT_INSTANCE_SHIFT	0
 
-enum boot_device {
-	BOOT_FLASH_SD = 0x10,
-	BOOT_FLASH_SD_1 = 0x11,
-	BOOT_FLASH_SD_2 = 0x12,
-	BOOT_FLASH_SD_3 = 0x13,
-
-	BOOT_FLASH_EMMC = 0x20,
-	BOOT_FLASH_EMMC_1 = 0x21,
-	BOOT_FLASH_EMMC_2 = 0x22,
-	BOOT_FLASH_EMMC_3 = 0x23,
-
-	BOOT_FLASH_NAND = 0x30,
-	BOOT_FLASH_NAND_FMC = 0x31,
-
-	BOOT_FLASH_NOR = 0x40,
-	BOOT_FLASH_NOR_QSPI = 0x41,
-
-	BOOT_SERIAL_UART = 0x50,
-	BOOT_SERIAL_UART_1 = 0x51,
-	BOOT_SERIAL_UART_2 = 0x52,
-	BOOT_SERIAL_UART_3 = 0x53,
-	BOOT_SERIAL_UART_4 = 0x54,
-	BOOT_SERIAL_UART_5 = 0x55,
-	BOOT_SERIAL_UART_6 = 0x56,
-	BOOT_SERIAL_UART_7 = 0x57,
-	BOOT_SERIAL_UART_8 = 0x58,
-
-	BOOT_SERIAL_USB = 0x60,
-	BOOT_SERIAL_USB_OTG = 0x62,
-
-	BOOT_FLASH_SPINAND = 0x70,
-	BOOT_FLASH_SPINAND_1 = 0x71,
-};
-
 /* TAMP registers */
 #define TAMP_BACKUP_REGISTER(x)		(STM32_TAMP_BASE + 0x100 + 4 * x)
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define TAMP_BACKUP_MAGIC_NUMBER	TAMP_BACKUP_REGISTER(4)
 #define TAMP_BACKUP_BRANCH_ADDRESS	TAMP_BACKUP_REGISTER(5)
+#define TAMP_FWU_BOOT_INFO_REG		TAMP_BACKUP_REGISTER(10)
 #define TAMP_COPRO_RSC_TBL_ADDRESS	TAMP_BACKUP_REGISTER(17)
 #define TAMP_COPRO_STATE		TAMP_BACKUP_REGISTER(18)
 #define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(20)
 #define TAMP_BOOTCOUNT			TAMP_BACKUP_REGISTER(21)
 
-#define TAMP_COPRO_STATE_OFF		0
-#define TAMP_COPRO_STATE_INIT		1
-#define TAMP_COPRO_STATE_CRUN		2
-#define TAMP_COPRO_STATE_CSTOP		3
-#define TAMP_COPRO_STATE_STANDBY	4
-#define TAMP_COPRO_STATE_CRASH		5
+#define TAMP_FWU_BOOT_IDX_MASK		GENMASK(3, 0)
+
+#define TAMP_FWU_BOOT_IDX_OFFSET	0
 #endif
 
-#ifdef CONFIG_STM32MP13x
-#define TAMP_BOOTCOUNT			TAMP_BACKUP_REGISTER(31)
+#ifdef CONFIG_STM32MP13X
+#define TAMP_FWU_BOOT_INFO_REG		TAMP_BACKUP_REGISTER(10)
 #define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(30)
-#endif
+#define TAMP_BOOTCOUNT			TAMP_BACKUP_REGISTER(31)
 
-#define TAMP_BOOT_MODE_MASK		GENMASK(15, 8)
-#define TAMP_BOOT_MODE_SHIFT		8
-#define TAMP_BOOT_DEVICE_MASK		GENMASK(7, 4)
-#define TAMP_BOOT_INSTANCE_MASK		GENMASK(3, 0)
-#define TAMP_BOOT_FORCED_MASK		GENMASK(7, 0)
+#define TAMP_FWU_BOOT_IDX_MASK		GENMASK(3, 0)
+#define TAMP_FWU_BOOT_IDX_OFFSET	0
+#endif
 
-enum forced_boot_mode {
-	BOOT_NORMAL = 0x00,
-	BOOT_FASTBOOT = 0x01,
-	BOOT_RECOVERY = 0x02,
-	BOOT_STM32PROG = 0x03,
-	BOOT_UMS_MMC0 = 0x10,
-	BOOT_UMS_MMC1 = 0x11,
-	BOOT_UMS_MMC2 = 0x12,
-};
+#endif /* __ASSEMBLY__ */
+#endif /* CONFIG_STM32MP15X || CONFIG_STM32MP13X */
+
+#ifdef CONFIG_STM32MP25X
+#define STM32_USART2_BASE		0x400E0000
+#define STM32_USART3_BASE		0x400F0000
+#define STM32_UART4_BASE		0x40100000
+#define STM32_UART5_BASE		0x40110000
+#define STM32_USART6_BASE		0x40220000
+#define STM32_UART9_BASE		0x402C0000
+#define STM32_USART1_BASE		0x40330000
+#define STM32_UART7_BASE		0x40370000
+#define STM32_UART8_BASE		0x40380000
+#define STM32_RCC_BASE			0x44200000
+#define STM32_TAMP_BASE			0x46010000
+#define STM32_SDMMC1_BASE		0x48220000
+#define STM32_SDMMC2_BASE		0x48230000
+#define STM32_SDMMC3_BASE		0x48240000
+
+#define STM32_DDR_BASE			0x80000000
+
+#define STM32_DDR_SIZE			SZ_4G
+
+/* TAMP registers x = 0 to 127 : hardcoded description, waiting NVMEM node in DT */
+#define TAMP_BACKUP_REGISTER(x)		(STM32_TAMP_BASE + 0x100 + 4 * (x))
+
+/* TAMP registers zone 3 RIF 1 (RW) at 96*/
+#define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(96)
+#endif /* STM32MP25X */
 
 /* offset used for BSEC driver: misc_read and misc_write */
 #define STM32_BSEC_SHADOW_OFFSET	0x0
@@ -155,19 +188,38 @@ enum forced_boot_mode {
 #define STM32_BSEC_LOCK(id)		(STM32_BSEC_LOCK_OFFSET + (id) * 4)
 
 /* BSEC OTP index */
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define BSEC_OTP_RPN	1
 #define BSEC_OTP_SERIAL	13
 #define BSEC_OTP_PKG	16
 #define BSEC_OTP_MAC	57
 #define BSEC_OTP_BOARD	59
 #endif
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define BSEC_OTP_RPN	1
 #define BSEC_OTP_SERIAL	13
 #define BSEC_OTP_MAC	57
 #define BSEC_OTP_BOARD	60
 #endif
+#ifdef CONFIG_STM32MP25X
+#define BSEC_OTP_SERIAL	5
+#define BSEC_OTP_RPN	9
+#define BSEC_OTP_REVID	102
+#define BSEC_OTP_PKG	122
+
+#define BSEC_OTP_BOARD	246
+#define BSEC_OTP_MAC	247
+
+#endif
+
+#ifndef __ASSEMBLY__
+#include <asm/types.h>
+
+/* enumerated used to identify the SYSCON driver instance */
+enum {
+	STM32MP_SYSCON_UNKNOWN,
+	STM32MP_SYSCON_SYSCFG,
+};
+#endif /* __ASSEMBLY__*/
 
-#endif /* __ASSEMBLY__ */
 #endif /* _MACH_STM32_H_ */
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
index 4ad14f963b..b4ea6190a6 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
@@ -15,11 +15,39 @@
  * for SiP (silicon Partner)
  * http://infocenter.arm.com/help/topic/com.arm.doc.den0028a/index.html
  */
-#define STM32_SMC_VERSION		0x82000000
 
 /* Secure Service access from Non-secure */
+
+/*
+ * STM32_SMC_PWR call API
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_PWR			0x82001001
+
+/*
+ * STM32_SMC_BSEC call API
+ *
+ * Argument a0: (input) SMCC ID
+ *		(output) status return code
+ * Argument a1: (input) Service ID (STM32_SMC_BSEC_xxx)
+ * Argument a2: (input) OTP index
+ *		(output) OTP read value, if applicable
+ * Argument a3: (input) OTP value if applicable
+ */
 #define STM32_SMC_BSEC			0x82001003
 
+/* Service ID for STM32_SMC_PWR */
+#define STM32_SMC_REG_READ		0x0
+#define STM32_SMC_REG_WRITE		0x1
+#define STM32_SMC_REG_SET		0x2
+#define STM32_SMC_REG_CLEAR		0x3
+
 /* Service for BSEC */
 #define STM32_SMC_READ_SHADOW		0x01
 #define STM32_SMC_PROG_OTP		0x02
@@ -30,23 +58,25 @@
 #define STM32_SMC_WRLOCK_OTP		0x07
 
 /* SMC error codes */
-#define STM32_SMC_OK			0x0
-#define STM32_SMC_NOT_SUPPORTED		-1
-#define STM32_SMC_FAILED		-2
-#define STM32_SMC_INVALID_PARAMS	-3
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xffffffffU
+#define STM32_SMC_FAILED		0xfffffffeU
+#define STM32_SMC_INVALID_PARAMS	0xfffffffdU
 
 #define stm32_smc_exec(svc, op, data1, data2) \
 	stm32_smc(svc, op, data1, data2, NULL)
 
 #ifdef CONFIG_ARM_SMCCC
-static inline u32 stm32_smc(u32 svc, u8 op, u32 data1, u32 data2, u32 *result)
+static inline u32 stm32_smc(unsigned long svc, unsigned long op,
+			    unsigned long data1, unsigned long data2,
+			    u32 *result)
 {
 	struct arm_smccc_res res;
 
 	arm_smccc_smc(svc, op, data1, data2, 0, 0, 0, 0, &res);
 
 	if (res.a0) {
-		pr_err("%s: Failed to exec svc=%x op=%x in secure mode (err = %ld)\n",
+		pr_err("%s: Failed to exec svc=%lx op=%lx in secure mode (err = %ld)\n",
 		       __func__, svc, op, res.a0);
 		return -EINVAL;
 	}
@@ -56,7 +86,9 @@ static inline u32 stm32_smc(u32 svc, u8 op, u32 data1, u32 data2, u32 *result)
 	return 0;
 }
 #else
-static inline u32 stm32_smc(u32 svc, u8 op, u32 data1, u32 data2, u32 *result)
+static inline u32 stm32_smc(unsigned long svc, unsigned long op,
+			    unsigned long data1, unsigned long data2,
+			    u32 *result)
 {
 	return 0;
 }
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32prog.h b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
index 99be4e1d65..c10bff09c8 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32prog.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
@@ -10,9 +10,3 @@ int stm32prog_write_medium_virt(struct dfu_entity *dfu, u64 offset,
 int stm32prog_read_medium_virt(struct dfu_entity *dfu, u64 offset,
 			       void *buf, long *len);
 int stm32prog_get_medium_size_virt(struct dfu_entity *dfu, u64 *size);
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-bool stm32prog_get_tee_partitions(void);
-#endif
-
-bool stm32prog_get_fsbl_nor(void);
diff --git a/arch/arm/mach-stm32mp/include/mach/sys_proto.h b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
index f19a70e53e..0b31386c8b 100644
--- a/arch/arm/mach-stm32mp/include/mach/sys_proto.h
+++ b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
@@ -30,22 +30,51 @@
 #define CPU_STM32MP131Fxx	0x05010EC8
 #define CPU_STM32MP131Dxx	0x05010EC9
 
+/* ID for STM32MP25x = Device Part Number (RPN) (bit31:0) */
+#define CPU_STM32MP257Cxx       0x00002000
+#define CPU_STM32MP255Cxx       0x00082000
+#define CPU_STM32MP253Cxx       0x000B300C
+#define CPU_STM32MP251Cxx       0x000B306D
+#define CPU_STM32MP257Axx       0x40002E00
+#define CPU_STM32MP255Axx       0x40082E00
+#define CPU_STM32MP253Axx       0x400B3E0C
+#define CPU_STM32MP251Axx       0x400B3E6D
+#define CPU_STM32MP257Fxx       0x80002000
+#define CPU_STM32MP255Fxx       0x80082000
+#define CPU_STM32MP253Fxx       0x800B300C
+#define CPU_STM32MP251Fxx       0x800B306D
+#define CPU_STM32MP257Dxx       0xC0002E00
+#define CPU_STM32MP255Dxx       0xC0082E00
+#define CPU_STM32MP253Dxx       0xC00B3E0C
+#define CPU_STM32MP251Dxx       0xC00B3E6D
+
 /* return CPU_STMP32MP...Xxx constants */
 u32 get_cpu_type(void);
 
 #define CPU_DEV_STM32MP15	0x500
 #define CPU_DEV_STM32MP13	0x501
+#define CPU_DEV_STM32MP25	0x505
 
 /* return CPU_DEV constants */
 u32 get_cpu_dev(void);
 
+/* Silicon revision = REV_ID[15:0] of Device Version */
 #define CPU_REV1	0x1000
 #define CPU_REV1_1	0x1001
 #define CPU_REV1_2	0x1003
 #define CPU_REV2	0x2000
 #define CPU_REV2_1	0x2001
+#define CPU_REV2_2	0x2003
+
+/* OTP revision ID = 6 bits : 3 for Major / 3 for Minor */
+#define OTP_REVID_1	0b001000
+#define OTP_REVID_1_1	0b001001
+#define OTP_REVID_1_2	0b001010
+#define OTP_REVID_2	0b010000
+#define OTP_REVID_2_1	0b010001
+#define OTP_REVID_2_2	0b010010
 
-/* return Silicon revision = REV_ID[15:0] of Device Version */
+/* return SoC revision = Silicon revision (STM32MP1) or OTP revision ID (STM32MP2)*/
 u32 get_cpu_rev(void);
 
 /* Get Package options from OTP */
@@ -58,6 +87,13 @@ u32 get_cpu_package(void);
 #define STM32MP15_PKG_AD_TFBGA257	1
 #define STM32MP15_PKG_UNKNOWN		0
 
+/* package used for STM32MP25x */
+#define STM32MP25_PKG_CUSTOM		0
+#define STM32MP25_PKG_AL_TBGA361	3
+#define STM32MP25_PKG_AK_TBGA424	4
+#define STM32MP25_PKG_AI_TBGA436	5
+#define STM32MP25_PKG_UNKNOWN		7
+
 /* Get SOC name */
 #define SOC_NAME_SIZE 20
 void get_soc_name(char name[SOC_NAME_SIZE]);
@@ -77,3 +113,10 @@ void stm32mp_misc_init(void);
 
 /* helper function: read data from OTP */
 u32 get_otp(int index, int shift, int mask);
+
+/* helper function: check "closed" state in product "Life Cycle" */
+#ifdef CONFIG_CMD_STM32KEY
+bool stm32mp_is_closed(void);
+#else
+static inline bool stm32mp_is_closed(void) { return false; }
+#endif
diff --git a/arch/arm/mach-stm32mp/nvram.c b/arch/arm/mach-stm32mp/nvram.c
new file mode 100644
index 0000000000..f513246d2c
--- /dev/null
+++ b/arch/arm/mach-stm32mp/nvram.c
@@ -0,0 +1,665 @@
+// SPDX-License-Identifier: GPL-2.0-or-lat OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+#define LOG_CATEGORY UCLASS_MISC
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <log.h>
+#include <misc.h>
+#include <regmap.h>
+#include <tee.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/devres.h>
+
+#define RIF_CID1			0x1
+#define CURRENT_CID			RIF_CID1
+#define NB_ZONES_STM32MP1		3
+#define NB_ZONES_STM32MP2		7
+
+#define _TAMP_SECCFGR			0x20U
+#define _TAMP_BKPRIFR(x)		(0x70U + 0x4U * ((x) - 1))
+#define _TAMP_RXCIDCFGR(x)		(0x80U + 0x4U * ((x)))
+
+#define BKPREG_PROTECTION_ZONE_1	0
+#define BKPREG_PROTECTION_ZONE_2	1
+#define BKPREG_PROTECTION_ZONE_3	2
+
+#define BKPREG_PROTECTION_ZONE_1_RIF1	0
+#define BKPREG_PROTECTION_ZONE_1_RIF2	1
+#define BKPREG_PROTECTION_ZONE_2_RIF1	2
+#define BKPREG_PROTECTION_ZONE_2_RIF2	3
+#define BKPREG_PROTECTION_ZONE_3_RIF1	4
+#define BKPREG_PROTECTION_ZONE_3_RIF0	5
+#define BKPREG_PROTECTION_ZONE_3_RIF2	6
+#define NB_COMPARTMENT_STM32MP2		3
+
+enum stm32_tamp_bkpreg_access {
+	BKP_READ_WRITE,
+	BKP_READ,
+	BKP_NO
+};
+
+struct stm32_tamp_nvram_plat {
+	void __iomem *base;
+	void __iomem *parent_base;
+	fdt_size_t size;
+	fdt_size_t parent_size;
+	unsigned int nb_total_regs;
+};
+
+struct stm32_tamp_nvram_priv {
+	int *idx_bkpreg_zones_end;
+	struct regmap *config_regmap;
+	struct regmap *bkpregs_regmap;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+};
+
+struct stm32_tamp_nvram_drvdata {
+	const unsigned int nb_zones;
+	const struct reg_field *reg_fields;
+};
+
+static const struct reg_field stm32mp1_tamp_nvram_zone_cfg_fields[NB_ZONES_STM32MP1 - 1] = {
+	[BKPREG_PROTECTION_ZONE_1] = REG_FIELD(_TAMP_SECCFGR, 0, 7),
+	[BKPREG_PROTECTION_ZONE_2] = REG_FIELD(_TAMP_SECCFGR, 16, 23),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_zone_cfg_fields[NB_ZONES_STM32MP2 - 1] = {
+	[BKPREG_PROTECTION_ZONE_1_RIF1] = REG_FIELD(_TAMP_BKPRIFR(1), 0,  7),
+	[BKPREG_PROTECTION_ZONE_1_RIF2] = REG_FIELD(_TAMP_SECCFGR,    0,  7),
+	[BKPREG_PROTECTION_ZONE_2_RIF1] = REG_FIELD(_TAMP_BKPRIFR(2), 0,  7),
+	[BKPREG_PROTECTION_ZONE_2_RIF2] = REG_FIELD(_TAMP_SECCFGR,   16, 23),
+	[BKPREG_PROTECTION_ZONE_3_RIF1] = REG_FIELD(_TAMP_BKPRIFR(3), 0,  7),
+	[BKPREG_PROTECTION_ZONE_3_RIF0] = REG_FIELD(_TAMP_BKPRIFR(3), 16, 23),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_rxcidcfg_cfen_fields[NB_COMPARTMENT_STM32MP2] = {
+	REG_FIELD(_TAMP_RXCIDCFGR(0), 0, 0),
+	REG_FIELD(_TAMP_RXCIDCFGR(1), 0, 0),
+	REG_FIELD(_TAMP_RXCIDCFGR(2), 0, 0),
+};
+
+static const struct reg_field stm32mp25_tamp_nvram_rxcidcfg_fields[NB_COMPARTMENT_STM32MP2] = {
+	REG_FIELD(_TAMP_RXCIDCFGR(0), 4, 6),
+	REG_FIELD(_TAMP_RXCIDCFGR(1), 4, 6),
+	REG_FIELD(_TAMP_RXCIDCFGR(2), 4, 6),
+};
+
+static enum stm32_tamp_bkpreg_access stm32mp1_tamp_bkpreg_access[NB_ZONES_STM32MP1] = {
+	[BKPREG_PROTECTION_ZONE_1] = BKP_NO,
+	[BKPREG_PROTECTION_ZONE_2] = BKP_READ,
+	[BKPREG_PROTECTION_ZONE_3] = BKP_READ_WRITE,
+};
+
+static const struct stm32_tamp_nvram_drvdata stm32mp1_tamp_nvram = {
+	.nb_zones = NB_ZONES_STM32MP1,
+	.reg_fields = stm32mp1_tamp_nvram_zone_cfg_fields,
+};
+
+static const struct stm32_tamp_nvram_drvdata stm32mp25_tamp_nvram = {
+	.nb_zones = NB_ZONES_STM32MP2,
+	.reg_fields = stm32mp25_tamp_nvram_zone_cfg_fields,
+};
+
+static int stm32_tamp_is_compartment_isolation_enabled_mp2X(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int nb_compartment_enabled = 0;
+	u32 cfen;
+	struct regmap_field *cfen_field;
+
+	for (int i = 0; i < NB_COMPARTMENT_STM32MP2; i++) {
+		cfen_field = devm_regmap_field_alloc(dev,
+						     priv->config_regmap,
+						     stm32mp25_tamp_nvram_rxcidcfg_cfen_fields[i]);
+		if (IS_ERR_OR_NULL(cfen_field)) {
+			dev_err(dev, "Can't allocate field for reading configuration\n");
+			return -ENOMEM;
+		}
+		if (regmap_field_read(cfen_field, &cfen) != 0) {
+			dev_err(dev, "Can't read field for registers zones\n");
+			devm_regmap_field_free(dev, cfen_field);
+			return -EINVAL;
+		}
+		nb_compartment_enabled += cfen;
+		devm_regmap_field_free(dev, cfen_field);
+	}
+
+	if (nb_compartment_enabled == 0)
+		return 0;
+	else if (nb_compartment_enabled == NB_COMPARTMENT_STM32MP2)
+		return 1;
+	else
+		return -EINVAL;
+}
+
+static bool *stm32_tamp_get_compartment_owner_mp2X(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	struct regmap_field *cid_field;
+	u32 cid_per_zone;
+	int isolation_enabled;
+	bool *compartment_owner;
+
+	isolation_enabled = stm32_tamp_is_compartment_isolation_enabled_mp2X(dev);
+	if (isolation_enabled < 0)
+		return NULL;
+
+	compartment_owner = devm_kcalloc(dev,
+					 NB_COMPARTMENT_STM32MP2,
+					 sizeof(*compartment_owner),
+					 GFP_KERNEL);
+	if (!compartment_owner)
+		return ERR_PTR(-ENOMEM);
+
+	for (int i = 0; i < NB_COMPARTMENT_STM32MP2; i++) {
+		if (isolation_enabled) {
+			cid_field = devm_regmap_field_alloc(dev,
+							    priv->config_regmap,
+							    stm32mp25_tamp_nvram_rxcidcfg_fields[i]
+							    );
+
+			if (regmap_field_read(cid_field, &cid_per_zone) != 0) {
+				dev_err(dev, "Can't read field for registers zones\n");
+				devm_regmap_field_free(dev, cid_field);
+				devm_kfree(dev, compartment_owner);
+				return ERR_PTR(-EINVAL);
+			}
+			if (cid_per_zone == CURRENT_CID)
+				compartment_owner[i] = true;
+			else
+				compartment_owner[i] = false;
+
+			devm_regmap_field_free(dev, cid_field);
+		} else {
+			compartment_owner[i] = true;
+		}
+	}
+
+	return compartment_owner;
+}
+
+static enum stm32_tamp_bkpreg_access *stm32_tamp_get_access_rights_mp2X(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_drvdata *drvdata =
+		(struct stm32_tamp_nvram_drvdata *)dev_get_driver_data(dev);
+	unsigned int nb_zones = drvdata->nb_zones;
+	bool *compartment_owner;
+	enum stm32_tamp_bkpreg_access *bkpreg_access;
+
+	compartment_owner = stm32_tamp_get_compartment_owner_mp2X(dev);
+	if (IS_ERR(compartment_owner))
+		return ERR_PTR(-ENODEV);
+
+	bkpreg_access = devm_kcalloc(dev,
+				     NB_ZONES_STM32MP2,
+				     sizeof(*bkpreg_access),
+				     GFP_KERNEL);
+
+	for (int protection_zone_idx = 0; protection_zone_idx < nb_zones;
+	     protection_zone_idx++) {
+		switch (protection_zone_idx) {
+		case BKPREG_PROTECTION_ZONE_1_RIF1:
+			bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_1_RIF2:
+			bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_2_RIF1:
+			if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_2_RIF2:
+			if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF1:
+			if (compartment_owner[1])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[0] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF0:
+			if (compartment_owner[0])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[1] || compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		case BKPREG_PROTECTION_ZONE_3_RIF2:
+			if (compartment_owner[2])
+				bkpreg_access[protection_zone_idx] = BKP_READ_WRITE;
+			else if (compartment_owner[0] || compartment_owner[1])
+				bkpreg_access[protection_zone_idx] = BKP_READ;
+			else
+				bkpreg_access[protection_zone_idx] = BKP_NO;
+			break;
+		default:
+			devm_kfree(dev, bkpreg_access);
+			return ERR_PTR(-ENODEV);
+		}
+	}
+
+	return bkpreg_access;
+}
+
+static int stm32_tamp_nvram_bkpreg_get_zone_idx(struct udevice *dev, int reg)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	struct stm32_tamp_nvram_drvdata *drvdata =
+		(struct stm32_tamp_nvram_drvdata *)dev_get_driver_data(dev);
+	int *idx_bkpreg_zones_end = priv->idx_bkpreg_zones_end;
+	int nb_zones = drvdata->nb_zones;
+	int protection_zone_idx;
+
+	if (reg < 0)
+		return -1; // negative reg is the boundary of an empty zone
+
+	for (protection_zone_idx = 0; protection_zone_idx < nb_zones; protection_zone_idx++) {
+		if (reg <= idx_bkpreg_zones_end[protection_zone_idx])
+			break;
+	}
+
+	if (protection_zone_idx >= nb_zones)
+		return -1; // the reg is not a part of any zone
+
+	return protection_zone_idx;
+}
+
+static bool stm32_tamp_nvram_rights(struct udevice *dev, int reg, bool read_only)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int protection_zone_idx = stm32_tamp_nvram_bkpreg_get_zone_idx(dev, reg);
+
+	if (protection_zone_idx < 0)
+		return false;
+
+	switch (priv->bkpreg_access[protection_zone_idx]) {
+	case BKP_READ_WRITE:
+		return true;
+	case BKP_READ:
+		return read_only;
+	case BKP_NO:
+		return false;
+	default:
+		dev_err(dev, "Can't get access rights for the zone\n");
+		return false;
+	}
+
+	return false;
+}
+
+static int stm32_tamp_nvram_write_byte(struct udevice *dev, u32 offset, u8 byte)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int offset_aligned = ALIGN_DOWN(offset, sizeof(u32));
+	int byte_in_word = offset - offset_aligned;
+	u32 read_value, to_be_writen_value;
+	u32 reg_idx = offset_aligned / sizeof(u32);
+
+	if (!stm32_tamp_nvram_rights(dev, reg_idx, false))
+		return -EIO;
+
+	regmap_read(priv->bkpregs_regmap, offset_aligned, &read_value);
+	to_be_writen_value = read_value & ~(0xFFUL << byte_in_word * 8);
+	to_be_writen_value |=  (u32)byte << (byte_in_word * 8);
+
+	return regmap_write(priv->bkpregs_regmap, offset_aligned, to_be_writen_value);
+}
+
+static int stm32_tamp_nvram_read_byte(struct udevice *dev, unsigned int offset, u8 *byte)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int offset_aligned = ALIGN_DOWN(offset, sizeof(u32));
+	int byte_in_word = offset - offset_aligned;
+	u32 read_value;
+	u32 reg_idx = offset_aligned / sizeof(u32);
+
+	if (!stm32_tamp_nvram_rights(dev, reg_idx, true))
+		return -EIO;
+
+	regmap_read(priv->bkpregs_regmap, offset_aligned, &read_value);
+	*byte = (read_value >> (byte_in_word * 8)) & 0xFF;
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_read(struct udevice *dev, int offset, void *buf, int size)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	u8 byte;
+	u8 *buf_u8 = buf;
+	u32 temp_u32;
+	int i, ret;
+	int total = offset + size;
+	u32 reg_idx;
+
+	i = offset;
+	while (i < total)  {
+		reg_idx = i / sizeof(u32);
+		if (i + sizeof(u32) <= total && IS_ALIGNED(i, sizeof(u32))) {
+			if (!stm32_tamp_nvram_rights(dev, reg_idx, true)) {
+				dev_dbg(dev, "Backup register %u is not allowed to be read\n",
+					reg_idx);
+				temp_u32 = 0;
+			} else {
+				regmap_read(priv->bkpregs_regmap, i, &temp_u32);
+			}
+			memcpy(buf_u8, &temp_u32, sizeof(u32));
+			buf_u8 += sizeof(u32);
+			i += sizeof(u32);
+		} else {
+			ret = stm32_tamp_nvram_read_byte(dev, i, &byte);
+			if (ret != 0) {
+				dev_dbg(dev, "Backup register %u is not allowed to be read\n",
+					reg_idx);
+				byte = 0;
+			}
+			*buf_u8 = byte;
+			i++;
+			buf_u8++;
+		}
+	}
+
+	return size;
+}
+
+static int stm32_tamp_nvram_write(struct udevice *dev, int offset, const void *buf, int size)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	u8 *buf_u8 = (u8 *)buf;
+	u32 temp_u32;
+	size_t total = offset + size;
+	int i, ret;
+	u32 reg_idx;
+
+	i = offset;
+	while (i < total)  {
+		reg_idx = i / sizeof(u32);
+		if (i + sizeof(u32) <= total && IS_ALIGNED(i, sizeof(u32))) {
+			if (stm32_tamp_nvram_rights(dev, reg_idx, false)) {
+				memcpy(&temp_u32, buf_u8, sizeof(u32));
+				regmap_write(priv->bkpregs_regmap, i, temp_u32);
+			} else {
+				dev_dbg(dev, "Backup register %u is not allowed to be written",
+					reg_idx);
+			}
+			buf_u8 += sizeof(u32);
+			i += sizeof(u32);
+		} else {
+			ret = stm32_tamp_nvram_write_byte(dev, i, *buf_u8);
+			if (ret != 0)
+				dev_dbg(dev, "Backup register %u is not allowed to be written",
+					reg_idx);
+			i++;
+			buf_u8++;
+		}
+	}
+
+	return size;
+}
+
+static const struct misc_ops stm32_tamp_nvram_ops = {
+	.read = stm32_tamp_nvram_read,
+	.write = stm32_tamp_nvram_write,
+};
+
+static u32 *stm32_tamp_nvram_get_backup_zones(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_plat *plat = dev_get_plat(dev);
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	const struct stm32_tamp_nvram_drvdata *drvdata =
+		(struct stm32_tamp_nvram_drvdata *)dev_get_driver_data(dev);
+	int nb_zones = drvdata->nb_zones;
+	int zone_idx;
+	int *idx_bkpreg_zones_end;
+	struct regmap *tamp_regmap = priv->config_regmap;
+	u32 offset_field;
+
+	idx_bkpreg_zones_end = devm_kcalloc(dev,
+					    sizeof(*idx_bkpreg_zones_end),
+					    nb_zones,
+					    GFP_KERNEL);
+	if (IS_ERR_OR_NULL(idx_bkpreg_zones_end)) {
+		dev_err(dev, "Can't allocate registers zones\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	//Get the n-1 frontiers of zone within the tamp configuration registers
+	for (zone_idx = 0; zone_idx < nb_zones - 1; zone_idx++) {
+		const struct reg_field reg_field = drvdata->reg_fields[zone_idx];
+		struct regmap_field *field = devm_regmap_field_alloc(dev,
+								     tamp_regmap,
+								     reg_field);
+
+		if (IS_ERR_OR_NULL(field)) {
+			dev_err(dev, "Can't allocate registers zones\n");
+			devm_kfree(dev, idx_bkpreg_zones_end);
+			return ERR_PTR(-ENOMEM);
+		}
+		if (regmap_field_read(field, &offset_field) != 0) {
+			dev_err(dev, "Can't read field for registers zones\n");
+			devm_kfree(dev, idx_bkpreg_zones_end);
+			return ERR_PTR(-EIO);
+		}
+
+		idx_bkpreg_zones_end[zone_idx] = offset_field - 1;
+	}
+
+	//The last zone end is defined by the number of registers in TAMP
+	idx_bkpreg_zones_end[zone_idx] = plat->nb_total_regs - 1;
+
+	return idx_bkpreg_zones_end;
+}
+
+static void stm32_tamp_nvram_print_zones(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	int *zones_end = priv->idx_bkpreg_zones_end;
+
+	if (device_is_compatible(dev, "st,stm32mp25-tamp-nvram")) {
+		dev_dbg(dev,
+			"\n"
+			"Zone 1-RIF1 %3d - %3d %c%c\n"
+			"Zone 1-RIF2 %3d - %3d %c%c\n"
+			"Zone 2-RIF1 %3d - %3d %c%c\n"
+			"Zone 2-RIF2 %3d - %3d %c%c\n"
+			"Zone 3-RIF1 %3d - %3d %c%c\n"
+			"Zone 3-RIF0 %3d - %3d %c%c\n"
+			"Zone 3-RIF2 %3d - %3d %c%c\n",
+			0, zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF1],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1_RIF2],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_1_RIF2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF1],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2_RIF2],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_2_RIF2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF1],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF0],
+						false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF0] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+						true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3_RIF2],
+						false) ?
+				'W' :
+				'-');
+	} else if (device_is_compatible(dev, "st,stm32mp15-tamp-nvram")) {
+		dev_dbg(dev,
+			"\n"
+			"Zone 1 %3d - %3d %c%c\n"
+			"Zone 2 %3d - %3d %c%c\n"
+			"Zone 3 %3d - %3d %c%c\n",
+			0, zones_end[BKPREG_PROTECTION_ZONE_1],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1], true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_1], false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_1] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_2],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2], true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_2], false) ?
+				'W' :
+				'-',
+			zones_end[BKPREG_PROTECTION_ZONE_2] + 1,
+			zones_end[BKPREG_PROTECTION_ZONE_3],
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3], true) ?
+				'R' :
+				'-',
+			stm32_tamp_nvram_rights(dev, zones_end[BKPREG_PROTECTION_ZONE_3], false) ?
+				'W' :
+				'-');
+	}
+}
+
+static int stm32_tamp_nvram_of_to_plat(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_plat *plat = dev_get_plat(dev);
+	fdt_addr_t addr = dev_read_addr_size_index(dev, 0, &plat->size);
+	fdt_addr_t parent_addr = dev_read_addr_size_index(dev->parent, 0, &plat->parent_size);
+
+	if (addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+	plat->base = (void __iomem *)addr;
+
+	if (parent_addr == FDT_ADDR_T_NONE)
+		return -EINVAL;
+	plat->parent_base = (void __iomem *)parent_addr;
+
+	if (plat->size == FDT_ADDR_T_NONE)
+		return -EOPNOTSUPP;
+
+	plat->nb_total_regs =  plat->size / sizeof(uint32_t);
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_probe(struct udevice *dev)
+{
+	struct stm32_tamp_nvram_plat *plat = dev_get_plat(dev);
+	struct stm32_tamp_nvram_priv *priv = dev_get_priv(dev);
+	struct regmap_config config_regmap;
+	struct regmap_config bckreg_regmap;
+
+	config_regmap.r_start = (ulong)(plat->parent_base);
+	config_regmap.r_size = plat->parent_size;
+	config_regmap.reg_offset_shift = 0;
+	config_regmap.width = REGMAP_SIZE_32;
+	priv->config_regmap = devm_regmap_init(dev, NULL, NULL, &config_regmap);
+
+	bckreg_regmap.r_start = (ulong)(plat->base);
+	bckreg_regmap.r_size = plat->size;
+	bckreg_regmap.reg_offset_shift = 0;
+	bckreg_regmap.width = REGMAP_SIZE_32;
+	priv->bkpregs_regmap = devm_regmap_init(dev, NULL, NULL, &bckreg_regmap);
+
+	priv->idx_bkpreg_zones_end = stm32_tamp_nvram_get_backup_zones(dev);
+	if (IS_ERR_OR_NULL(priv->idx_bkpreg_zones_end)) {
+		dev_err(dev, "Failed to get the backup zone from tamp regs\n\n");
+		return -ENODEV;
+	}
+
+	if (device_is_compatible(dev, "st,stm32mp25-tamp-nvram")) {
+		priv->bkpreg_access = stm32_tamp_get_access_rights_mp2X(dev);
+		if (IS_ERR_OR_NULL(priv->bkpreg_access))
+			return -ENODEV;
+	} else {
+		priv->bkpreg_access = stm32mp1_tamp_bkpreg_access;
+	}
+
+	stm32_tamp_nvram_print_zones(dev);
+
+	return 0;
+}
+
+static int stm32_tamp_nvram_remove(struct udevice *dev)
+{
+	return 0;
+}
+
+static const struct udevice_id stm32_tamp_nvram_ids[] = {
+	{ .compatible = "st,stm32mp15-tamp-nvram", .data = (ulong)&stm32mp1_tamp_nvram },
+	{ .compatible = "st,stm32mp25-tamp-nvram", .data = (ulong)&stm32mp25_tamp_nvram },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_tamp_nvram) = {
+	.name = "stm32_tamp_nvram",
+	.id = UCLASS_MISC,
+	.of_match = stm32_tamp_nvram_ids,
+	.priv_auto = sizeof(struct stm32_tamp_nvram_priv),
+	.plat_auto = sizeof(struct stm32_tamp_nvram_plat),
+	.ops = &stm32_tamp_nvram_ops,
+	.of_to_plat = of_match_ptr(stm32_tamp_nvram_of_to_plat),
+	.probe = stm32_tamp_nvram_probe,
+	.remove = stm32_tamp_nvram_remove,
+};
+
diff --git a/arch/arm/mach-stm32mp/soc.c b/arch/arm/mach-stm32mp/soc.c
new file mode 100644
index 0000000000..318c6aa935
--- /dev/null
+++ b/arch/arm/mach-stm32mp/soc.c
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <misc.h>
+#include <net.h>
+#include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+
+/* max: 8 OTP for 5 mac address on stm32mp2*/
+#define MAX_NB_OTP	8
+
+/*
+ * If there is no MAC address in the environment, then it will be initialized
+ * (silently) from the value in the OTP.
+ */
+__weak int setup_mac_address(void)
+{
+	int ret;
+	int i;
+	u32 otp[MAX_NB_OTP];
+	uchar enetaddr[ARP_HLEN];
+	struct udevice *dev;
+	int nb_eth, nb_otp, index;
+
+	if (!IS_ENABLED(CONFIG_NET))
+		return 0;
+
+	nb_eth = get_eth_nb();
+	if (!nb_eth)
+		return 0;
+
+	/* 6 bytes for each MAC addr and 4 bytes for each OTP */
+	nb_otp = DIV_ROUND_UP(ARP_HLEN * nb_eth, 4);
+	if (nb_otp > MAX_NB_OTP) {
+		log_err("invalid number of OTP = %d, max = %d\n", nb_otp, MAX_NB_OTP);
+		return -EINVAL;
+	}
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_MAC), otp, 4 * nb_otp);
+	if (ret < 0)
+		return ret;
+
+	for (index = 0; index < nb_eth; index++) {
+		/* MAC already in environment */
+		if (eth_env_get_enetaddr_by_index("eth", index, enetaddr))
+			continue;
+
+		for (i = 0; i < ARP_HLEN; i++)
+			enetaddr[i] = ((uint8_t *)&otp)[i + ARP_HLEN * index];
+
+		/* skip FF:FF:FF:FF:FF:FF */
+		if (is_broadcast_ethaddr(enetaddr))
+			continue;
+
+		if (!is_valid_ethaddr(enetaddr)) {
+			log_err("invalid MAC address %d in OTP %pM\n",
+				index, enetaddr);
+			return -EINVAL;
+		}
+		log_debug("OTP MAC address %d = %pM\n", index, enetaddr);
+		ret = eth_env_set_enetaddr_by_index("eth", index, enetaddr);
+		if (ret) {
+			log_err("Failed to set mac address %pM from OTP: %d\n",
+				enetaddr, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-stm32mp/stm32mp1/Makefile b/arch/arm/mach-stm32mp/stm32mp1/Makefile
new file mode 100644
index 0000000000..b9688026bc
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp1/Makefile
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (C) 2018, STMicroelectronics - All Rights Reserved
+#
+
+obj-y += cpu.o
+
+obj-$(CONFIG_STM32MP13X) += stm32mp13x.o
+obj-$(CONFIG_STM32MP15X) += stm32mp15x.o
+
+ifdef CONFIG_SPL_BUILD
+obj-$(CONFIG_STM32MP1_RESET_HALT_WORKAROUND) += stm32mp1_helper_dbg.o
+else
+obj-$(CONFIG_ARMV7_PSCI) += psci.o
+endif
+
+obj-$(CONFIG_$(SPL_)STM32MP15_PWR) += pwr_regulator.o
+obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
diff --git a/arch/arm/mach-stm32mp/cpu.c b/arch/arm/mach-stm32mp/stm32mp1/cpu.c
similarity index 85%
rename from arch/arm/mach-stm32mp/cpu.c
rename to arch/arm/mach-stm32mp/stm32mp1/cpu.c
index 855fc755fe..2af91d764c 100644
--- a/arch/arm/mach-stm32mp/cpu.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/cpu.c
@@ -127,8 +127,6 @@ int mach_cpu_init(void)
 	if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) &&
 	    (boot_mode & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_UART)
 		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
-	else if (IS_ENABLED(CONFIG_DEBUG_UART) && IS_ENABLED(CONFIG_SPL_BUILD))
-		debug_uart_init();
 
 	return 0;
 }
@@ -282,62 +280,6 @@ static void setup_boot_mode(void)
 	clrsetbits_le32(TAMP_BOOT_CONTEXT, TAMP_BOOT_FORCED_MASK, BOOT_NORMAL);
 }
 
-/*
- * If there is no MAC address in the environment, then it will be initialized
- * (silently) from the value in the OTP.
- */
-__weak int setup_mac_address(void)
-{
-	int ret;
-	int i;
-	u32 otp[3];
-	uchar enetaddr[6];
-	struct udevice *dev;
-	int nb_eth, nb_otp, index;
-
-	if (!IS_ENABLED(CONFIG_NET))
-		return 0;
-
-	nb_eth = get_eth_nb();
-
-	/* 6 bytes for each MAC addr and 4 bytes for each OTP */
-	nb_otp = DIV_ROUND_UP(6 * nb_eth, 4);
-
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_DRIVER_GET(stm32mp_bsec),
-					  &dev);
-	if (ret)
-		return ret;
-
-	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_MAC), otp, 4 * nb_otp);
-	if (ret < 0)
-		return ret;
-
-	for (index = 0; index < nb_eth; index++) {
-		/* MAC already in environment */
-		if (eth_env_get_enetaddr_by_index("eth", index, enetaddr))
-			continue;
-
-		for (i = 0; i < 6; i++)
-			enetaddr[i] = ((uint8_t *)&otp)[i + 6 * index];
-
-		if (!is_valid_ethaddr(enetaddr)) {
-			log_err("invalid MAC address %d in OTP %pM\n",
-				index, enetaddr);
-			return -EINVAL;
-		}
-		log_debug("OTP MAC address %d = %pM\n", index, enetaddr);
-		ret = eth_env_set_enetaddr_by_index("eth", index, enetaddr);
-		if (ret) {
-			log_err("Failed to set mac address %pM from OTP: %d\n",
-				enetaddr, ret);
-			return ret;
-		}
-	}
-
-	return 0;
-}
-
 static int setup_serial_number(void)
 {
 	char serial_string[25];
diff --git a/arch/arm/mach-stm32mp/stm32mp1/fdt.c b/arch/arm/mach-stm32mp/stm32mp1/fdt.c
new file mode 100644
index 0000000000..7282cb34f2
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp1/fdt.c
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2019-2020, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <fdtdec.h>
+#include <fdt_support.h>
+#include <log.h>
+#include <tee.h>
+#include <asm/arch/sys_proto.h>
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+#include <linux/io.h>
+
+#define STM32MP13_FDCAN_BASE	0x4400F000
+#define STM32MP13_ADC1_BASE	0x48003000
+#define STM32MP13_TSC_BASE	0x5000B000
+#define STM32MP13_CRYP_BASE	0x54002000
+#define STM32MP13_ETH2_BASE	0x5800E000
+#define STM32MP13_DCMIPP_BASE	0x5A000000
+#define STM32MP13_LTDC_BASE	0x5A010000
+
+#define STM32MP15_FDCAN_BASE	0x4400e000
+#define STM32MP15_CRYP2_BASE	0x4c005000
+#define STM32MP15_CRYP1_BASE	0x54001000
+#define STM32MP15_GPU_BASE	0x59000000
+#define STM32MP15_DSI_BASE	0x5a000000
+
+/* fdt helper */
+static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
+{
+	int node;
+	fdt_addr_t regs;
+
+	for (node = fdt_first_subnode(fdt, offset);
+	     node >= 0;
+	     node = fdt_next_subnode(fdt, node)) {
+		regs = fdtdec_get_addr(fdt, node, "reg");
+		if (addr == regs) {
+			if (fdtdec_get_is_enabled(fdt, node)) {
+				fdt_status_disabled(fdt, node);
+
+				return true;
+			}
+			return false;
+		}
+	}
+
+	return false;
+}
+
+/* deactivate all the cpu except core 0 */
+static void stm32_fdt_fixup_cpu(void *blob, char *name)
+{
+	int off;
+	u32 reg;
+
+	off = fdt_path_offset(blob, "/cpus");
+	if (off < 0) {
+		log_warning("%s: couldn't find /cpus node\n", __func__);
+		return;
+	}
+
+	off = fdt_node_offset_by_prop_value(blob, -1, "device_type", "cpu", 4);
+	while (off != -FDT_ERR_NOTFOUND) {
+		reg = fdtdec_get_addr(blob, off, "reg");
+		if (reg != 0) {
+			fdt_del_node(blob, off);
+			log_notice("FDT: cpu %d node remove for %s\n",
+				   reg, name);
+			/* after delete we can't trust the offsets anymore */
+			off = -1;
+		}
+		off = fdt_node_offset_by_prop_value(blob, off,
+						    "device_type", "cpu", 4);
+	}
+}
+
+static void stm32_fdt_disable(void *fdt, int offset, u32 addr,
+			      const char *string, const char *name)
+{
+	if (fdt_disable_subnode_by_address(fdt, offset, addr))
+		log_notice("FDT: %s@%08x node disabled for %s\n",
+			   string, addr, name);
+}
+
+static void stm32_fdt_disable_optee(void *blob)
+{
+	int off, node;
+
+	/* Delete "optee" firmware node */
+	off = fdt_node_offset_by_compatible(blob, -1, "linaro,optee-tz");
+	if (off >= 0 && fdtdec_get_is_enabled(blob, off))
+		fdt_del_node(blob, off);
+
+	/* Delete "optee@..." reserved-memory node */
+	off = fdt_path_offset(blob, "/reserved-memory/");
+	if (off < 0)
+		return;
+	for (node = fdt_first_subnode(blob, off);
+	     node >= 0;
+	     node = fdt_next_subnode(blob, node)) {
+		if (strncmp(fdt_get_name(blob, node, NULL), "optee@", 6))
+			continue;
+
+		if (fdt_del_node(blob, node))
+			printf("Failed to remove optee reserved-memory node\n");
+	}
+}
+
+static void stm32mp13_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
+{
+	switch (cpu) {
+	case CPU_STM32MP131Fxx:
+	case CPU_STM32MP131Dxx:
+	case CPU_STM32MP131Cxx:
+	case CPU_STM32MP131Axx:
+		stm32_fdt_disable(blob, soc, STM32MP13_FDCAN_BASE, "can", name);
+		stm32_fdt_disable(blob, soc, STM32MP13_ADC1_BASE, "adc", name);
+		fallthrough;
+	case CPU_STM32MP133Fxx:
+	case CPU_STM32MP133Dxx:
+	case CPU_STM32MP133Cxx:
+	case CPU_STM32MP133Axx:
+		stm32_fdt_disable(blob, soc, STM32MP13_LTDC_BASE, "ltdc", name);
+		stm32_fdt_disable(blob, soc, STM32MP13_DCMIPP_BASE, "dcmipp",
+				  name);
+		stm32_fdt_disable(blob, soc, STM32MP13_TSC_BASE, "tsc", name);
+		break;
+	default:
+		break;
+	}
+
+	switch (cpu) {
+	case CPU_STM32MP135Dxx:
+	case CPU_STM32MP135Axx:
+	case CPU_STM32MP133Dxx:
+	case CPU_STM32MP133Axx:
+	case CPU_STM32MP131Dxx:
+	case CPU_STM32MP131Axx:
+		stm32_fdt_disable(blob, soc, STM32MP13_CRYP_BASE, "cryp", name);
+		break;
+	default:
+		break;
+	}
+}
+
+static void stm32mp15_fdt_fixup(void *blob, int soc, u32 cpu, char *name)
+{
+	u32 pkg;
+
+	switch (cpu) {
+	case CPU_STM32MP151Fxx:
+	case CPU_STM32MP151Dxx:
+	case CPU_STM32MP151Cxx:
+	case CPU_STM32MP151Axx:
+		stm32_fdt_fixup_cpu(blob, name);
+		/* after cpu delete we can't trust the soc offsets anymore */
+		soc = fdt_path_offset(blob, "/soc");
+		stm32_fdt_disable(blob, soc, STM32MP15_FDCAN_BASE, "can", name);
+		fallthrough;
+	case CPU_STM32MP153Fxx:
+	case CPU_STM32MP153Dxx:
+	case CPU_STM32MP153Cxx:
+	case CPU_STM32MP153Axx:
+		stm32_fdt_disable(blob, soc, STM32MP15_GPU_BASE, "gpu", name);
+		stm32_fdt_disable(blob, soc, STM32MP15_DSI_BASE, "dsi", name);
+		break;
+	default:
+		break;
+	}
+	switch (cpu) {
+	case CPU_STM32MP157Dxx:
+	case CPU_STM32MP157Axx:
+	case CPU_STM32MP153Dxx:
+	case CPU_STM32MP153Axx:
+	case CPU_STM32MP151Dxx:
+	case CPU_STM32MP151Axx:
+		stm32_fdt_disable(blob, soc, STM32MP15_CRYP1_BASE, "cryp",
+				  name);
+		stm32_fdt_disable(blob, soc, STM32MP15_CRYP2_BASE, "cryp",
+				  name);
+		break;
+	default:
+		break;
+	}
+	switch (get_cpu_package()) {
+	case STM32MP15_PKG_AA_LBGA448:
+		pkg = STM32MP_PKG_AA;
+		break;
+	case STM32MP15_PKG_AB_LBGA354:
+		pkg = STM32MP_PKG_AB;
+		break;
+	case STM32MP15_PKG_AC_TFBGA361:
+		pkg = STM32MP_PKG_AC;
+		break;
+	case STM32MP15_PKG_AD_TFBGA257:
+		pkg = STM32MP_PKG_AD;
+		break;
+	default:
+		pkg = 0;
+		break;
+	}
+	if (pkg) {
+		do_fixup_by_compat_u32(blob, "st,stm32mp157-pinctrl",
+				       "st,package", pkg, false);
+		do_fixup_by_compat_u32(blob, "st,stm32mp157-z-pinctrl",
+				       "st,package", pkg, false);
+	}
+}
+
+/*
+ * This function is called right before the kernel is booted. "blob" is the
+ * device tree that will be passed to the kernel.
+ */
+int ft_system_setup(void *blob, struct bd_info *bd)
+{
+	int ret = 0;
+	int soc;
+	u32 cpu;
+	char name[SOC_NAME_SIZE];
+
+	soc = fdt_path_offset(blob, "/soc");
+	/* when absent, nothing to do */
+	if (soc == -FDT_ERR_NOTFOUND)
+		return 0;
+	if (soc < 0)
+		return soc;
+
+	/* MPUs Part Numbers and name*/
+	cpu = get_cpu_type();
+	get_soc_name(name);
+
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		stm32mp13_fdt_fixup(blob, soc, cpu, name);
+
+	if (IS_ENABLED(CONFIG_STM32MP15X)) {
+		stm32mp15_fdt_fixup(blob, soc, cpu, name);
+
+		/*
+		 * TEMP: remove OP-TEE nodes in kernel device tree
+		 *       copied from U-Boot device tree by optee_copy_fdt_nodes
+		 *       when OP-TEE is not detected (probe failed)
+		 * these OP-TEE nodes are present in <board>-u-boot.dtsi
+		 * under CONFIG_STM32MP15X_STM32IMAGE only for compatibility
+		 * when FIP is not used by TF-A
+		 */
+		if (CONFIG_IS_ENABLED(STM32MP15X_STM32IMAGE) &&
+		    !tee_find_device(NULL, NULL, NULL, NULL))
+			stm32_fdt_disable_optee(blob);
+	}
+
+	return ret;
+}
diff --git a/arch/arm/mach-stm32mp/psci.c b/arch/arm/mach-stm32mp/stm32mp1/psci.c
similarity index 100%
rename from arch/arm/mach-stm32mp/psci.c
rename to arch/arm/mach-stm32mp/stm32mp1/psci.c
diff --git a/arch/arm/mach-stm32mp/pwr_regulator.c b/arch/arm/mach-stm32mp/stm32mp1/pwr_regulator.c
similarity index 96%
rename from arch/arm/mach-stm32mp/pwr_regulator.c
rename to arch/arm/mach-stm32mp/stm32mp1/pwr_regulator.c
index 846637ab16..c666f9f409 100644
--- a/arch/arm/mach-stm32mp/pwr_regulator.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/pwr_regulator.c
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
+#include <asm/arch/stm32mp1_smc.h>
 #include <dm/device_compat.h>
 #include <dm/device-internal.h>
 #include <linux/bitops.h>
@@ -44,6 +45,10 @@ static int stm32mp_pwr_write(struct udevice *dev, uint reg,
 	if (len != 4)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_ARM_SMCCC) && !IS_ENABLED(CONFIG_SPL_BUILD))
+		return stm32_smc_exec(STM32_SMC_PWR, STM32_SMC_REG_WRITE,
+				      STM32MP_PWR_CR3, val);
+
 	writel(val, priv->base + STM32MP_PWR_CR3);
 
 	return 0;
diff --git a/arch/arm/mach-stm32mp/stm32mp13x.c b/arch/arm/mach-stm32mp/stm32mp1/stm32mp13x.c
similarity index 100%
rename from arch/arm/mach-stm32mp/stm32mp13x.c
rename to arch/arm/mach-stm32mp/stm32mp1/stm32mp13x.c
diff --git a/arch/arm/mach-stm32mp/stm32mp15x.c b/arch/arm/mach-stm32mp/stm32mp1/stm32mp15x.c
similarity index 98%
rename from arch/arm/mach-stm32mp/stm32mp15x.c
rename to arch/arm/mach-stm32mp/stm32mp1/stm32mp15x.c
index 660c907a6b..ed4fca4214 100644
--- a/arch/arm/mach-stm32mp/stm32mp15x.c
+++ b/arch/arm/mach-stm32mp/stm32mp1/stm32mp15x.c
@@ -208,7 +208,7 @@ void stm32mp_cpu_init(void)
 	if (!IS_ENABLED(CONFIG_SPL) || IS_ENABLED(CONFIG_SPL_BUILD)) {
 		/* Reset Coprocessor state unless it wakes up from Standby power mode */
 		if (!(readl(PWR_MCUCR) & PWR_MCUCR_SBF)) {
-			writel(TAMP_COPRO_STATE_OFF, TAMP_COPRO_STATE);
+			writel(0, TAMP_COPRO_STATE);
 			writel(0, TAMP_COPRO_RSC_TBL_ADDRESS);
 		}
 	}
@@ -266,7 +266,7 @@ static const char * const soc_type[] = {
 };
 
 static const char * const soc_pkg[] = { "??", "AD", "AC", "AB", "AA" };
-static const char * const soc_rev[] = { "?", "A", "B", "Z" };
+static const char * const soc_rev[] = { "?", "A", "B", "Z", "Y"};
 
 static void get_cpu_string_offsets(unsigned int *type, unsigned int *pkg,
 				   unsigned int *rev)
@@ -307,6 +307,9 @@ static void get_cpu_string_offsets(unsigned int *type, unsigned int *pkg,
 	case CPU_REV2_1:
 		*rev = 3;
 		break;
+	case CPU_REV2_2:
+		*rev = 4;
+		break;
 	default:
 		*rev = 0;
 		break;
diff --git a/arch/arm/mach-stm32mp/stm32mp2/Makefile b/arch/arm/mach-stm32mp/stm32mp2/Makefile
new file mode 100644
index 0000000000..e14f62fce7
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+#
+# Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+#
+
+obj-y += cpu.o
+obj-y += arm64-mmu.o
+obj-y += rifsc.o
+obj-$(CONFIG_OF_SYSTEM_SETUP) += fdt.o
+obj-$(CONFIG_STM32MP25X) += stm32mp25x.o
diff --git a/arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c b/arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c
new file mode 100644
index 0000000000..820e889982
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/arm64-mmu.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <asm/system.h>
+#include <asm/armv8/mmu.h>
+
+#define MP2_MEM_MAP_MAX 10
+
+#if (CONFIG_SYS_TEXT_BASE < STM32_DDR_BASE) || \
+	(CONFIG_SYS_TEXT_BASE > (STM32_DDR_BASE + STM32_DDR_SIZE))
+#error "invalid CONFIG_SYS_TEXT_BASE value"
+#endif
+
+struct mm_region stm32mp2_mem_map[MP2_MEM_MAP_MAX] = {
+	{
+		/* PCIe */
+		.virt = 0x10000000UL,
+		.phys = 0x10000000UL,
+		.size = 0x10000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* LPSRAMs, VDERAM, RETRAM, SRAMs, SYSRAM: alias1 */
+		.virt = 0x20000000UL,
+		.phys = 0x20000000UL,
+		.size = 0x00200000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* Peripherals: alias1 */
+		.virt = 0x40000000UL,
+		.phys = 0x40000000UL,
+		.size = 0x10000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/* OSPI and FMC: memory-map area */
+		.virt = 0x60000000UL,
+		.phys = 0x60000000UL,
+		.size = 0x20000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		/*
+		 * DDR = STM32_DDR_BASE / STM32_DDR_SIZE
+		 * the beginning of DDR (before CONFIG_SYS_TEXT_BASE) is not
+		 * mapped, protected by RIF and reserved for other firmware
+		 * (OP-TEE / TF-M / Cube M33)
+		 */
+		.virt = CONFIG_SYS_TEXT_BASE,
+		.phys = CONFIG_SYS_TEXT_BASE,
+		.size = STM32_DDR_SIZE -
+			(CONFIG_SYS_TEXT_BASE - STM32_DDR_BASE),
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) |
+			 PTE_BLOCK_INNER_SHARE
+	}, {
+		/* List terminator */
+		0,
+	}
+};
+
+struct mm_region *mem_map = stm32mp2_mem_map;
diff --git a/arch/arm/mach-stm32mp/stm32mp2/cpu.c b/arch/arm/mach-stm32mp/stm32mp2/cpu.c
new file mode 100644
index 0000000000..eb31c1a49d
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/cpu.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+#include <common.h>
+#include <clk.h>
+#include <cpu_func.h>
+#include <debug_uart.h>
+#include <env_internal.h>
+#include <init.h>
+#include <misc.h>
+#include <wdt.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/lists.h>
+#include <dm/uclass.h>
+#include <dt-bindings/clock/stm32mp25-clks.h>
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+/*
+ * early TLB into the .data section so that it not get cleared
+ * with 16kB alignment
+ */
+#define EARLY_TLB_SIZE 0xA000
+u8 early_tlb[EARLY_TLB_SIZE] __section(".data") __aligned(0x4000);
+
+/*
+ * initialize the MMU and activate cache in U-Boot pre-reloc stage
+ * MMU/TLB is updated in enable_caches() for U-Boot after relocation
+ */
+static void early_enable_caches(void)
+{
+	if (CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
+		return;
+
+#if !(CONFIG_IS_ENABLED(SYS_ICACHE_OFF) && CONFIG_IS_ENABLED(SYS_DCACHE_OFF))
+	gd->arch.tlb_size = EARLY_TLB_SIZE;
+	gd->arch.tlb_addr = (unsigned long)&early_tlb;
+#endif
+	/* enable MMU (default configuration) */
+	dcache_enable();
+}
+
+/*
+ * Early system init
+ */
+int arch_cpu_init(void)
+{
+	icache_enable();
+	early_enable_caches();
+
+	return 0;
+}
+
+int mach_cpu_init(void)
+{
+	u32 boot_mode;
+
+	boot_mode = get_bootmode();
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) &&
+	    (boot_mode & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_UART)
+		gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+
+	return 0;
+}
+
+void enable_caches(void)
+{
+	/* deactivate the data cache, early enabled in arch_cpu_init() */
+	dcache_disable();
+	/*
+	 * Force the call of setup_all_pgtables() in mmu_setup() by clearing tlb_fillptr
+	 * to update the TLB location udpated in board_f.c::reserve_mmu
+	 */
+	gd->arch.tlb_fillptr = 0;
+	dcache_enable();
+}
+
+/* used when CONFIG_DISPLAY_CPUINFO is activated */
+int print_cpuinfo(void)
+{
+	char name[SOC_NAME_SIZE];
+
+	get_soc_name(name);
+	printf("CPU: %s\n", name);
+
+	return 0;
+}
+
+u32 get_bootmode(void)
+{
+	/* read bootmode from TAMP backup register */
+	return (readl(TAMP_BOOT_CONTEXT) & TAMP_BOOT_MODE_MASK) >>
+		    TAMP_BOOT_MODE_SHIFT;
+}
+
+static void setup_boot_mode(void)
+{
+	const u32 serial_addr[] = {
+		STM32_USART1_BASE,
+		STM32_USART2_BASE,
+		STM32_USART3_BASE,
+		STM32_UART4_BASE,
+		STM32_UART5_BASE,
+		STM32_USART6_BASE,
+		STM32_UART7_BASE,
+		STM32_UART8_BASE,
+		STM32_UART9_BASE
+	};
+	const u32 sdmmc_addr[] = {
+		STM32_SDMMC1_BASE,
+		STM32_SDMMC2_BASE,
+		STM32_SDMMC3_BASE
+	};
+	char cmd[60];
+	u32 boot_ctx = readl(TAMP_BOOT_CONTEXT);
+	u32 boot_mode =
+		(boot_ctx & TAMP_BOOT_MODE_MASK) >> TAMP_BOOT_MODE_SHIFT;
+	unsigned int instance = (boot_mode & TAMP_BOOT_INSTANCE_MASK) - 1;
+	u32 forced_mode = (boot_ctx & TAMP_BOOT_FORCED_MASK);
+	struct udevice *dev;
+
+	log_debug("%s: boot_ctx=0x%x => boot_mode=%x, instance=%d forced=%x\n",
+		  __func__, boot_ctx, boot_mode, instance, forced_mode);
+	switch (boot_mode & TAMP_BOOT_DEVICE_MASK) {
+	case BOOT_SERIAL_UART:
+		if (instance > ARRAY_SIZE(serial_addr))
+			break;
+		/* serial : search associated node in devicetree */
+		sprintf(cmd, "serial@%x", serial_addr[instance]);
+		if (uclass_get_device_by_name(UCLASS_SERIAL, cmd, &dev)) {
+			/* restore console on error */
+			if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL))
+				gd->flags &= ~(GD_FLG_SILENT |
+					       GD_FLG_DISABLE_CONSOLE);
+			log_err("uart%d = %s not found in device tree!\n",
+				instance + 1, cmd);
+			break;
+		}
+		sprintf(cmd, "%d", dev_seq(dev));
+		env_set("boot_device", "serial");
+		env_set("boot_instance", cmd);
+
+		/* restore console on uart when not used */
+		if (IS_ENABLED(CONFIG_CMD_STM32PROG_SERIAL) && gd->cur_serial_dev != dev) {
+			gd->flags &= ~(GD_FLG_SILENT |
+				       GD_FLG_DISABLE_CONSOLE);
+			log_info("serial boot with console enabled!\n");
+		}
+		break;
+	case BOOT_SERIAL_USB:
+		env_set("boot_device", "usb");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		if (instance > ARRAY_SIZE(sdmmc_addr))
+			break;
+		/* search associated sdmmc node in devicetree */
+		sprintf(cmd, "mmc@%x", sdmmc_addr[instance]);
+		if (uclass_get_device_by_name(UCLASS_MMC, cmd, &dev)) {
+			printf("mmc%d = %s not found in device tree!\n",
+			       instance, cmd);
+			break;
+		}
+		sprintf(cmd, "%d", dev_seq(dev));
+		env_set("boot_device", "mmc");
+		env_set("boot_instance", cmd);
+		break;
+	case BOOT_FLASH_NAND:
+		env_set("boot_device", "nand");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_FLASH_SPINAND:
+		env_set("boot_device", "spi-nand");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_FLASH_NOR:
+		env_set("boot_device", "nor");
+		if (IS_ENABLED(CONFIG_SYS_MAX_FLASH_BANKS))
+			sprintf(cmd, "%d", CONFIG_SYS_MAX_FLASH_BANKS);
+		else
+			sprintf(cmd, "%d", 0);
+		env_set("boot_instance", cmd);
+		break;
+	case BOOT_FLASH_HYPERFLASH:
+		env_set("boot_device", "nor");
+		env_set("boot_instance", "0");
+		break;
+	default:
+		env_set("boot_device", "invalid");
+		env_set("boot_instance", "");
+		log_err("unexpected boot mode = %x\n", boot_mode);
+		break;
+	}
+
+	switch (forced_mode) {
+	case BOOT_FASTBOOT:
+		log_info("Enter fastboot!\n");
+		env_set("preboot", "env set preboot; fastboot 0");
+		break;
+	case BOOT_STM32PROG:
+		env_set("boot_device", "usb");
+		env_set("boot_instance", "0");
+		break;
+	case BOOT_UMS_MMC0:
+	case BOOT_UMS_MMC1:
+	case BOOT_UMS_MMC2:
+		log_info("Enter UMS!\n");
+		instance = forced_mode - BOOT_UMS_MMC0;
+		sprintf(cmd, "env set preboot; ums 0 mmc %d", instance);
+		env_set("preboot", cmd);
+		break;
+	case BOOT_RECOVERY:
+		env_set("preboot", "env set preboot; run altbootcmd");
+		break;
+	case BOOT_NORMAL:
+		break;
+	default:
+		log_debug("unexpected forced boot mode = %x\n", forced_mode);
+		break;
+	}
+
+	/* clear TAMP for next reboot */
+	clrsetbits_le32(TAMP_BOOT_CONTEXT, TAMP_BOOT_FORCED_MASK, BOOT_NORMAL);
+}
+
+static int setup_serial_number(void)
+{
+	char serial_string[25];
+	u32 otp[3] = {0, 0, 0 };
+	struct udevice *dev;
+	int ret;
+
+	if (env_get("serial#"))
+		return 0;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_SERIAL),
+			otp, sizeof(otp));
+	if (ret < 0)
+		return ret;
+
+	sprintf(serial_string, "%08X%08X%08X", otp[0], otp[1], otp[2]);
+	env_set("serial#", serial_string);
+
+	return 0;
+}
+
+int arch_misc_init(void)
+{
+	setup_boot_mode();
+	setup_serial_number();
+	setup_mac_address();
+
+	return 0;
+}
diff --git a/arch/arm/mach-stm32mp/stm32mp2/fdt.c b/arch/arm/mach-stm32mp/stm32mp2/fdt.c
new file mode 100644
index 0000000000..96a41010d3
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/fdt.c
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+
+/*
+ * This function is called right before the kernel is booted. "blob" is the
+ * device tree that will be passed to the kernel.
+ */
+int ft_system_setup(void *blob, struct bd_info *bd)
+{
+	return 0;
+}
+
diff --git a/arch/arm/mach-stm32mp/stm32mp2/rifsc.c b/arch/arm/mach-stm32mp/stm32mp2/rifsc.c
new file mode 100644
index 0000000000..30432f823a
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/rifsc.c
@@ -0,0 +1,360 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SIMPLE_BUS
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <linux/bitfield.h>
+#include <mach/rif.h>
+
+/* RIFSC offset register */
+#define RIFSC_RISC_SECCFGR0(id)		(0x10 + 0x4 * (id))
+#define RIFSC_RISC_PER0_CIDCFGR(id)	(0x100 + 0x8 * (id))
+#define RIFSC_RISC_PER0_SEMCR(id)	(0x104 + 0x8 * (id))
+
+/*
+ * SEMCR register
+ */
+#define SEMCR_MUTEX			BIT(0)
+
+/* RIFSC miscellaneous */
+#define RIFSC_RISC_SCID_MASK		GENMASK(6, 4)
+#define RIFSC_RISC_SEMWL_MASK		GENMASK(23, 16)
+
+#define IDS_PER_RISC_SEC_PRIV_REGS	32
+
+/*
+ * CIDCFGR register fields
+ */
+#define CIDCFGR_CFEN			BIT(0)
+#define CIDCFGR_SEMEN			BIT(1)
+
+#define SEMWL_SHIFT			16
+
+#define STM32MP25_RIFSC_ENTRIES		178
+
+/* Compartiment IDs */
+#define RIF_CID1			0x1
+
+/*
+ * struct stm32_rifsc_plat: Information about RIFSC device
+ *
+ * @base: Base address of RIFSC
+ */
+struct stm32_rifsc_plat {
+	void *base;
+};
+
+/*
+ * struct stm32_rifsc_child_plat: Information about each child
+ *
+ * @domain_id: Domain id
+ */
+struct stm32_rifsc_child_plat {
+	u32 domain_id;
+};
+
+static bool stm32_rif_is_semaphore_available(void *base, u32 id)
+{
+	void *addr = base + RIFSC_RISC_PER0_SEMCR(id);
+
+	return !(readl(addr) & SEMCR_MUTEX);
+}
+
+static int stm32_rif_acquire_semaphore(void *base, u32 id)
+{
+	void *addr = base + RIFSC_RISC_PER0_SEMCR(id);
+
+	/* Check that the semaphore is available */
+	if (!stm32_rif_is_semaphore_available(base, id))
+		return -EACCES;
+
+	setbits_le32(addr, SEMCR_MUTEX);
+
+	/* Check that CID1 has the semaphore */
+	if (stm32_rif_is_semaphore_available(base, id) ||
+	    FIELD_GET(RIFSC_RISC_SCID_MASK, (readl(addr)) != RIF_CID1))
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32_rif_release_semaphore(void *base, u32 id)
+{
+	void *addr = base + RIFSC_RISC_PER0_SEMCR(id);
+
+	if (stm32_rif_is_semaphore_available(base, id))
+		return 0;
+
+	clrbits_le32(addr, SEMCR_MUTEX);
+
+	/* Ok if another compartment takes the semaphore before the check */
+	if (!stm32_rif_is_semaphore_available(base, id) &&
+	    FIELD_GET(RIFSC_RISC_SCID_MASK, (readl(addr)) == RIF_CID1))
+		return -EACCES;
+
+	return 0;
+}
+
+static int rifsc_parse_feature_domain(ofnode node, struct ofnode_phandle_args *args)
+{
+	int ret;
+
+	ret = ofnode_parse_phandle_with_args(node, "feature-domains",
+					     "#feature-domain-cells", 0,
+					     0, args);
+	if (ret) {
+		log_debug("failed to parse feature-domains (%d)\n", ret);
+		return ret;
+	}
+
+	if (args->args_count != 1) {
+		log_debug("invalid domain args_count: %d\n", args->args_count);
+		return -EINVAL;
+	}
+
+	if (args->args[0] >= STM32MP25_RIFSC_ENTRIES) {
+		log_err("Invalid sys bus ID for %s\n", ofnode_get_name(node));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rifsc_check_access(void *base, u32 id)
+{
+	u32 reg_offset, reg_id, sec_reg_value, cid_reg_value, sem_reg_value;
+
+	/*
+	 * RIFSC_RISC_PRIVCFGRx and RIFSC_RISC_SECCFGRx both handle configuration access for
+	 * 32 peripherals. On the other hand, there is one _RIFSC_RISC_PERx_CIDCFGR register
+	 * per peripheral
+	 */
+	reg_id = id / IDS_PER_RISC_SEC_PRIV_REGS;
+	reg_offset = id % IDS_PER_RISC_SEC_PRIV_REGS;
+	sec_reg_value = readl(base + RIFSC_RISC_SECCFGR0(reg_id));
+	cid_reg_value = readl(base + RIFSC_RISC_PER0_CIDCFGR(id));
+	sem_reg_value = readl(base + RIFSC_RISC_PER0_SEMCR(id));
+
+	/*
+	 * First check conditions for semaphore mode, which doesn't take into
+	 * account static CID.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN)
+		goto skip_cid_check;
+
+	/* Skip CID check if CID filtering isn't enabled */
+	if (!(cid_reg_value & CIDCFGR_CFEN))
+		goto skip_cid_check;
+
+	/* Coherency check with the CID configuration */
+	if (FIELD_GET(RIFSC_RISC_SCID_MASK, cid_reg_value) != RIF_CID1) {
+		log_debug("Invalid CID configuration for peripheral %d\n", id);
+		return -EACCES;
+	}
+
+skip_cid_check:
+	/* Check security configuration */
+	if (sec_reg_value & BIT(reg_offset)) {
+		log_debug("Invalid security configuration for peripheral %d\n", id);
+		return -EACCES;
+	}
+
+	/* Check semaphore accesses */
+	if (cid_reg_value & CIDCFGR_SEMEN) {
+		if (!(FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_reg_value) & BIT(RIF_CID1))) {
+			log_debug("Not in semaphore whitelist for peripheral %d\n", id);
+			return -EACCES;
+		}
+		if (!stm32_rif_is_semaphore_available(base, id) &&
+		    !(FIELD_GET(RIFSC_RISC_SCID_MASK, sem_reg_value) & BIT(RIF_CID1))) {
+			log_debug("Semaphore unavailable for peripheral %d\n", id);
+			return -EACCES;
+		}
+	}
+
+	return 0;
+}
+
+int stm32_rifsc_check_access_by_id(ofnode device_node, u32 id)
+{
+	struct ofnode_phandle_args args;
+	int err;
+
+	if (id >= STM32MP25_RIFSC_ENTRIES)
+		return -EINVAL;
+
+	err = rifsc_parse_feature_domain(device_node, &args);
+	if (err)
+		return err;
+
+	return rifsc_check_access((void *)ofnode_get_addr(args.node), id);
+}
+
+int stm32_rifsc_check_access(ofnode device_node)
+{
+	struct ofnode_phandle_args args;
+	int err;
+
+	err = rifsc_parse_feature_domain(device_node, &args);
+	if (err)
+		return err;
+
+	return rifsc_check_access((void *)ofnode_get_addr(args.node), args.args[0]);
+}
+
+static int stm32_rifsc_child_pre_probe(struct udevice *dev)
+{
+	struct stm32_rifsc_plat *plat = dev_get_plat(dev->parent);
+	struct stm32_rifsc_child_plat *child_plat = dev_get_parent_plat(dev);
+	u32 cid_reg_value;
+	int err;
+	u32 id = child_plat->domain_id;
+
+	cid_reg_value = readl(plat->base + RIFSC_RISC_PER0_CIDCFGR(id));
+
+	/*
+	 * If the peripheral is in semaphore mode, take the semaphore so that
+	 * the CID1 has the ownership.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN &&
+	    (FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_reg_value) & BIT(RIF_CID1))) {
+		err = stm32_rif_acquire_semaphore(plat->base, id);
+		if (err) {
+			dev_err(dev, "Couldn't acquire RIF semaphore for peripheral %d (%d)\n",
+				id, err);
+			return err;
+		}
+		dev_dbg(dev, "Acquiring semaphore for peripheral %d\n", id);
+	}
+
+	return 0;
+}
+
+static int stm32_rifsc_child_post_remove(struct udevice *dev)
+{
+	struct stm32_rifsc_plat *plat = dev_get_plat(dev->parent);
+	struct stm32_rifsc_child_plat *child_plat = dev_get_parent_plat(dev);
+	u32 cid_reg_value;
+	int err;
+	u32 id = child_plat->domain_id;
+
+	cid_reg_value = readl(plat->base + RIFSC_RISC_PER0_CIDCFGR(id));
+
+	/*
+	 * If the peripheral is in semaphore mode, release the semaphore so that
+	 * there's no ownership.
+	 */
+	if (cid_reg_value & CIDCFGR_SEMEN &&
+	    (FIELD_GET(RIFSC_RISC_SEMWL_MASK, cid_reg_value) & BIT(RIF_CID1))) {
+		err = stm32_rif_release_semaphore(plat->base, id);
+		if (err)
+			dev_err(dev, "Couldn't release rif semaphore for peripheral %d (%d)\n",
+				id, err);
+	}
+
+	return 0;
+}
+
+static int stm32_rifsc_child_post_bind(struct udevice *dev)
+{
+	struct stm32_rifsc_child_plat *child_plat = dev_get_parent_plat(dev);
+	struct ofnode_phandle_args args;
+	int ret;
+
+	if (!dev_has_ofnode(dev))
+		return -EPERM;
+
+	ret = rifsc_parse_feature_domain(dev_ofnode(dev), &args);
+	if (ret)
+		return ret;
+
+	child_plat->domain_id = args.args[0];
+
+	return 0;
+}
+
+static int stm32_rifsc_bind(struct udevice *dev)
+{
+	struct stm32_rifsc_plat *plat = dev_get_plat(dev);
+	struct ofnode_phandle_args args;
+	int ret = 0, err = 0;
+	ofnode node;
+
+	plat->base = dev_read_addr_ptr(dev);
+	if (!plat->base) {
+		dev_err(dev, "can't get registers base address\n");
+		return -ENOENT;
+	}
+
+	for (node = ofnode_first_subnode(dev_ofnode(dev));
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node))
+			continue;
+
+		err = rifsc_parse_feature_domain(node, &args);
+		if (err) {
+			dev_dbg(dev, "%s failed to parse child on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = rifsc_check_access(plat->base, args.args[0]);
+		if (err) {
+			dev_info(dev, "%s not allowed on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err && !ret) {
+			ret = err;
+			dev_err(dev, "%s failed to bind on bus (%d)\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_err(dev, "Some child failed to bind (%d)\n", ret);
+
+	return ret;
+}
+
+static int stm32_rifsc_remove(struct udevice *bus)
+{
+	struct udevice *dev;
+
+	/* Deactivate all child devices not yet removed */
+	for (device_find_first_child(bus, &dev); dev; device_find_next_child(&dev))
+		if (device_active(dev))
+			stm32_rifsc_child_post_remove(dev);
+
+	return 0;
+}
+
+static const struct udevice_id stm32_rifsc_ids[] = {
+	{ .compatible = "st,stm32mp25-sys-bus" },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_rifsc) = {
+	.name = "stm32_rifsc",
+	.id = UCLASS_NOP,
+	.of_match = stm32_rifsc_ids,
+	.bind = stm32_rifsc_bind,
+	.remove = stm32_rifsc_remove,
+	.child_post_bind = stm32_rifsc_child_post_bind,
+	.child_pre_probe = stm32_rifsc_child_pre_probe,
+	.child_post_remove = stm32_rifsc_child_post_remove,
+	.plat_auto = sizeof(struct stm32_rifsc_plat),
+	.per_child_plat_auto = sizeof(struct stm32_rifsc_child_plat),
+	.flags = DM_FLAG_OS_PREPARE,
+};
diff --git a/arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c b/arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c
new file mode 100644
index 0000000000..5885891ccd
--- /dev/null
+++ b/arch/arm/mach-stm32mp/stm32mp2/stm32mp25x.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_ARCH
+
+#include <common.h>
+#include <log.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <asm/arch/sys_proto.h>
+
+/* SYSCFG register */
+#define SYSCFG_DEVICEID_OFFSET		0x6400
+#define SYSCFG_DEVICEID_DEV_ID_MASK	GENMASK(11, 0)
+#define SYSCFG_DEVICEID_DEV_ID_SHIFT	0
+
+/* Revision ID = OTP102[5:0] 6 bits : 3 for Major / 3 for Minor*/
+#define REVID_SHIFT	0
+#define REVID_MASK	GENMASK(5, 0)
+
+/* Device Part Number (RPN) = OTP9 */
+#define RPN_SHIFT	0
+#define RPN_MASK	GENMASK(31, 0)
+
+/* Package = bit 0:2 of OTP122 => STM32MP25_PKG defines
+ * - 000: Custom package
+ * - 011: TFBGA361 => AL = 10x10, 361 balls pith 0.5mm
+ * - 100: TFBGA424 => AK = 14x14, 424 balls pith 0.5mm
+ * - 101: TFBGA436 => AI = 18x18, 436 balls pith 0.5mm
+ * - others: Reserved
+ */
+#define PKG_SHIFT	0
+#define PKG_MASK	GENMASK(2, 0)
+
+static u32 read_deviceid(void)
+{
+	void *syscfg = syscon_get_first_range(STM32MP_SYSCON_SYSCFG);
+
+	return readl(syscfg + SYSCFG_DEVICEID_OFFSET);
+}
+
+u32 get_cpu_dev(void)
+{
+	return (read_deviceid() & SYSCFG_DEVICEID_DEV_ID_MASK) >> SYSCFG_DEVICEID_DEV_ID_SHIFT;
+}
+
+u32 get_cpu_rev(void)
+{
+	return get_otp(BSEC_OTP_REVID, REVID_SHIFT, REVID_MASK);
+}
+
+/* Get Device Part Number (RPN) from OTP */
+u32 get_cpu_type(void)
+{
+	return get_otp(BSEC_OTP_RPN, RPN_SHIFT, RPN_MASK);
+}
+
+/* Get Package options from OTP */
+u32 get_cpu_package(void)
+{
+	return get_otp(BSEC_OTP_PKG, PKG_SHIFT, PKG_MASK);
+}
+
+int get_eth_nb(void)
+{
+	int nb_eth;
+
+	switch (get_cpu_type()) {
+	case CPU_STM32MP257Fxx:
+		fallthrough;
+	case CPU_STM32MP257Dxx:
+		fallthrough;
+	case CPU_STM32MP257Cxx:
+		fallthrough;
+	case CPU_STM32MP257Axx:
+		nb_eth = 5; /* dual ETH with TSN support */
+		break;
+	case CPU_STM32MP253Fxx:
+		fallthrough;
+	case CPU_STM32MP253Dxx:
+		fallthrough;
+	case CPU_STM32MP253Cxx:
+		fallthrough;
+	case CPU_STM32MP253Axx:
+		nb_eth = 2; /* dual ETH */
+		break;
+	case CPU_STM32MP251Fxx:
+		fallthrough;
+	case CPU_STM32MP251Dxx:
+		fallthrough;
+	case CPU_STM32MP251Cxx:
+		fallthrough;
+	case CPU_STM32MP251Axx:
+		nb_eth = 1; /* single ETH */
+		break;
+	default:
+		nb_eth = 0;
+		break;
+	}
+
+	return nb_eth;
+}
+
+void get_soc_name(char name[SOC_NAME_SIZE])
+{
+	char *cpu_s, *cpu_r, *package;
+
+	cpu_s = "????";
+	cpu_r = "?";
+	package = "??";
+	if (get_cpu_dev() == CPU_DEV_STM32MP25) {
+		switch (get_cpu_type()) {
+		case CPU_STM32MP257Fxx:
+			cpu_s = "257F";
+			break;
+		case CPU_STM32MP257Dxx:
+			cpu_s = "257D";
+			break;
+		case CPU_STM32MP257Cxx:
+			cpu_s = "257C";
+			break;
+		case CPU_STM32MP257Axx:
+			cpu_s = "257A";
+			break;
+		case CPU_STM32MP255Fxx:
+			cpu_s = "255F";
+			break;
+		case CPU_STM32MP255Dxx:
+			cpu_s = "255D";
+			break;
+		case CPU_STM32MP255Cxx:
+			cpu_s = "255C";
+			break;
+		case CPU_STM32MP255Axx:
+			cpu_s = "255A";
+			break;
+		case CPU_STM32MP253Fxx:
+			cpu_s = "253F";
+			break;
+		case CPU_STM32MP253Dxx:
+			cpu_s = "253D";
+			break;
+		case CPU_STM32MP253Cxx:
+			cpu_s = "253C";
+			break;
+		case CPU_STM32MP253Axx:
+			cpu_s = "253A";
+			break;
+		case CPU_STM32MP251Fxx:
+			cpu_s = "251F";
+			break;
+		case CPU_STM32MP251Dxx:
+			cpu_s = "251D";
+			break;
+		case CPU_STM32MP251Cxx:
+			cpu_s = "251C";
+			break;
+		case CPU_STM32MP251Axx:
+			cpu_s = "251A";
+			break;
+		default:
+			cpu_s = "25??";
+			break;
+		}
+		/* REVISION */
+		switch (get_cpu_rev()) {
+		case OTP_REVID_1:
+			cpu_r = "A";
+			break;
+		case OTP_REVID_1_1:
+			cpu_r = "Z";
+			break;
+		case OTP_REVID_2:
+			cpu_r = "B";
+			break;
+		case OTP_REVID_2_1:
+			cpu_r = "Y";
+			break;
+		case OTP_REVID_2_2:
+			cpu_r = "X";
+			break;
+		default:
+			break;
+		}
+		/* PACKAGE */
+		switch (get_cpu_package()) {
+		case STM32MP25_PKG_CUSTOM:
+			package = "XX";
+			break;
+		case STM32MP25_PKG_AL_TBGA361:
+			package = "AL";
+			break;
+		case STM32MP25_PKG_AK_TBGA424:
+			package = "AK";
+			break;
+		case STM32MP25_PKG_AI_TBGA436:
+			package = "AI";
+			break;
+		default:
+			break;
+		}
+	}
+
+	snprintf(name, SOC_NAME_SIZE, "STM32MP%s%s Rev.%s", cpu_s, package, cpu_r);
+}
diff --git a/arch/arm/mach-stm32mp/syscon.c b/arch/arm/mach-stm32mp/syscon.c
index a0e8e1dfdc..299bd8b110 100644
--- a/arch/arm/mach-stm32mp/syscon.c
+++ b/arch/arm/mach-stm32mp/syscon.c
@@ -12,6 +12,7 @@
 static const struct udevice_id stm32mp_syscon_ids[] = {
 	{ .compatible = "st,stm32mp157-syscfg",
 	  .data = STM32MP_SYSCON_SYSCFG },
+	{ .compatible = "st,stm32mp25-syscfg", .data = STM32MP_SYSCON_SYSCFG},
 	{ }
 };
 
diff --git a/arch/sandbox/Kconfig b/arch/sandbox/Kconfig
index 852a7c8bf2..40cdea7d46 100644
--- a/arch/sandbox/Kconfig
+++ b/arch/sandbox/Kconfig
@@ -84,3 +84,9 @@ config SYS_FDT_LOAD_ADDR
 	  See `doc/arch/sandbox.rst` for more information.
 
 endmenu
+
+config FWU_NUM_BANKS
+	default 2
+
+config FWU_NUM_IMAGES_PER_BANK
+	default 2
diff --git a/arch/sandbox/dts/test.dts b/arch/sandbox/dts/test.dts
index 2761588f0d..ef3ad72929 100644
--- a/arch/sandbox/dts/test.dts
+++ b/arch/sandbox/dts/test.dts
@@ -948,7 +948,7 @@
 	};
 
 	/* This is used for the fastboot tests */
-	mmc0 {
+	mmc0: mmc0 {
 		compatible = "sandbox,mmc";
 	};
 
@@ -1683,6 +1683,11 @@
 			compatible = "sandbox,regmap_test";
 		};
 	};
+	};
+
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-gpt";
+		fwu-mdata-store = <&mmc0>;
 };
 
 #include "sandbox_pmic.dtsi"
diff --git a/arch/sandbox/include/asm/gpio.h b/arch/sandbox/include/asm/gpio.h
index 0dd4c7bf60..c5ff9e9cdd 100644
--- a/arch/sandbox/include/asm/gpio.h
+++ b/arch/sandbox/include/asm/gpio.h
@@ -28,9 +28,10 @@
 #define GPIOD_EXT_DRIVEN	BIT(30)	/* external source is driven */
 #define GPIOD_EXT_PULL_UP	BIT(29)	/* GPIO has external pull-up */
 #define GPIOD_EXT_PULL_DOWN	BIT(28)	/* GPIO has external pull-down */
+#define GPIOD_EXT_PROTECTED	BIT(27)	/* GPIO is access protected */
 
 #define GPIOD_EXT_PULL		(BIT(28) | BIT(29))
-#define GPIOD_SANDBOX_MASK	GENMASK(31, 28)
+#define GPIOD_SANDBOX_MASK	GENMASK(31, 27)
 
 /**
  * Return the simulated value of a GPIO (used only in sandbox test code)
diff --git a/board/dhelectronics/dh_stm32mp1/board.c b/board/dhelectronics/dh_stm32mp1/board.c
index 9188f5381e..eff4c1f8c2 100644
--- a/board/dhelectronics/dh_stm32mp1/board.c
+++ b/board/dhelectronics/dh_stm32mp1/board.c
@@ -547,7 +547,7 @@ static int board_get_regulator_buck3_nvm_uv_av96(int *uv)
 	if (!prop || !len)
 		return -ENODEV;
 
-	if (!strstr(prop, "avenger96"))
+	if (!strstr(prop, "avenger96") && !strstr(prop, "dhcor-testbench"))
 		return -EINVAL;
 
 	/* Read out STPMIC1 NVM and determine default Buck3 voltage. */
@@ -564,18 +564,32 @@ static int board_get_regulator_buck3_nvm_uv_av96(int *uv)
 	bucks_vout >>= STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_OFFSET(3);
 	bucks_vout &= STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_MASK;
 
-	/*
-	 * Avenger96 board comes in multiple regulator configurations:
-	 * - rev.100 or rev.200 have Buck3 preconfigured to 3V3 operation on
-	 *   boot and contains extra Enpirion EP53A8LQI DCDC converter which
-	 *   supplies the IO. Reduce Buck3 voltage to 2V9 to not waste power.
-	 * - rev.200L have Buck3 preconfigured to 1V8 operation and have no
-	 *   Enpirion EP53A8LQI DCDC anymore, the IO is supplied from Buck3.
-	 */
-	if (bucks_vout == STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_3V3)
-		*uv = 2900000;
-	else
-		*uv = 1800000;
+	if (strstr(prop, "avenger96")) {
+		/*
+		 * Avenger96 board comes in multiple regulator configurations:
+		 * - rev.100 or rev.200 have Buck3 preconfigured to
+		 *   3V3 operation on boot and contains extra Enpirion
+		 *   EP53A8LQI DCDC converter which supplies the IO.
+		 *   Reduce Buck3 voltage to 2V9 to not waste power.
+		 * - rev.200L have Buck3 preconfigured to 1V8 operation
+		 *   and have no Enpirion EP53A8LQI DCDC anymore, the
+		 *   IO is supplied from Buck3.
+		 */
+		if (bucks_vout == STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_3V3)
+			*uv = 2900000;
+		else
+			*uv = 1800000;
+	} else {
+		/* Testbench always respects Buck3 NVM settings */
+		if (bucks_vout == STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_3V3)
+			*uv = 3300000;
+		else if (bucks_vout == STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_3V0)
+			*uv = 3000000;
+		else if (bucks_vout == STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_1V8)
+			*uv = 1800000;
+		else	/* STPMIC_NVM_BUCKS_VOUT_SHR_BUCK_1V2 */
+			*uv = 1200000;
+	}
 
 	return 0;
 }
@@ -595,6 +609,7 @@ static void board_init_regulator_av96(void)
 
 	/* Adjust Buck3 per preconfigured PMIC voltage from NVM. */
 	regulator_set_value(rdev, uv);
+	regulator_set_enable(rdev, true);
 }
 
 static void board_init_regulator(void)
@@ -664,7 +679,7 @@ void board_quiesce_devices(void)
 
 /* eth init function : weak called in eqos driver */
 int board_interface_eth_init(struct udevice *dev,
-			     phy_interface_t interface_type)
+			     phy_interface_t interface_type, ulong rate)
 {
 	u8 *syscfg;
 	u32 value;
diff --git a/board/dhelectronics/dh_stm32mp1/u-boot-dhcor.its b/board/dhelectronics/dh_stm32mp1/u-boot-dhcor.its
index de7dcb317f..f9c1075616 100644
--- a/board/dhelectronics/dh_stm32mp1/u-boot-dhcor.its
+++ b/board/dhelectronics/dh_stm32mp1/u-boot-dhcor.its
@@ -18,13 +18,21 @@
 
 		fdt-1 {
 			description = ".dtb";
-			data = /incbin/("arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtb");
+			data = /incbin/("arch/arm/dts/stm32mp15xx-dhcor-testbench.dtb");
 			type = "flat_dt";
 			arch = "arm";
 			compression = "none";
 		};
 
 		fdt-2 {
+			description = ".dtb";
+			data = /incbin/("arch/arm/dts/stm32mp15xx-dhcor-avenger96.dtb");
+			type = "flat_dt";
+			arch = "arm";
+			compression = "none";
+		};
+
+		fdt-3 {
 			description = ".dtb";
 			data = /incbin/("arch/arm/dts/stm32mp15xx-dhcor-drc-compact.dtb");
 			type = "flat_dt";
@@ -38,18 +46,25 @@
 
 		config-1 {
 			/* DT+SoM+board model */
-			description = "arrow,stm32mp15xx-avenger96_somrev0_boardrev1";
+			description = "dh,stm32mp15xx-dhcor-testbench_somrev0_boardrev1";
 			firmware = "uboot";
 			fdt = "fdt-1";
 		};
 
 		config-2 {
 			/* DT+SoM+board model */
-			description = "dh,stm32mp15xx-dhcor-drc-compact_somrev0_boardrev0";
+			description = "arrow,stm32mp15xx-avenger96_somrev0_boardrev1";
 			firmware = "uboot";
 			fdt = "fdt-2";
 		};
 
+		config-3 {
+			/* DT+SoM+board model */
+			description = "dh,stm32mp15xx-dhcor-drc-compact_somrev0_boardrev0";
+			firmware = "uboot";
+			fdt = "fdt-3";
+		};
+
 		/* Add 586-200..586-400 with fdt-2..fdt-4 here */
 	};
 };
diff --git a/board/engicam/stm32mp1/Makefile b/board/engicam/stm32mp1/Makefile
index 65560df290..155d33f9ee 100644
--- a/board/engicam/stm32mp1/Makefile
+++ b/board/engicam/stm32mp1/Makefile
@@ -8,3 +8,5 @@ obj-y += spl.o
 else
 obj-y += stm32mp1.o
 endif
+
+obj-$(CONFIG_DEBUG_UART_BOARD_INIT) += ../../st/stm32mp1/debug_uart.o
diff --git a/board/engicam/stm32mp1/spl.c b/board/engicam/stm32mp1/spl.c
index 3aa738b3fa..2b7779cc01 100644
--- a/board/engicam/stm32mp1/spl.c
+++ b/board/engicam/stm32mp1/spl.c
@@ -6,7 +6,6 @@
  */
 
 #include <common.h>
-#include <asm/io.h>
 
 /* board early initialisation in board_f: need to use global variable */
 static u32 opp_voltage_mv __section(".data");
@@ -22,27 +21,3 @@ int board_early_init_f(void)
 	return 0;
 }
 
-#ifdef CONFIG_DEBUG_UART_BOARD_INIT
-void board_debug_uart_init(void)
-{
-#if (CONFIG_DEBUG_UART_BASE == STM32_UART4_BASE)
-
-#define RCC_MP_APB1ENSETR (STM32_RCC_BASE + 0x0A00)
-#define RCC_MP_AHB4ENSETR (STM32_RCC_BASE + 0x0A28)
-
-	/* UART4 clock enable */
-	setbits_le32(RCC_MP_APB1ENSETR, BIT(16));
-
-#define GPIOG_BASE 0x50008000
-	/* GPIOG clock enable */
-	writel(BIT(6), RCC_MP_AHB4ENSETR);
-	/* GPIO configuration for ST boards: Uart4 TX = G11 */
-	writel(0xffbfffff, GPIOG_BASE + 0x00);
-	writel(0x00006000, GPIOG_BASE + 0x24);
-#else
-
-#error("CONFIG_DEBUG_UART_BASE: not supported value")
-
-#endif
-}
-#endif
diff --git a/board/sandbox/sandbox.c b/board/sandbox/sandbox.c
index ca9a2ca5b1..46788c6be7 100644
--- a/board/sandbox/sandbox.c
+++ b/board/sandbox/sandbox.c
@@ -54,10 +54,10 @@ struct efi_fw_image fw_images[] = {
 struct efi_capsule_update_info update_info = {
 	.dfu_string = "sf 0:0=u-boot-bin raw 0x100000 0x50000;"
 		"u-boot-env raw 0x150000 0x200000",
+	.num_images = ARRAY_SIZE(fw_images),
 	.images = fw_images,
 };
 
-u8 num_image_type_guids = ARRAY_SIZE(fw_images);
 #endif /* EFI_HAVE_CAPSULE_SUPPORT */
 
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
@@ -164,3 +164,11 @@ int init_addr_map(void)
 
 	return 0;
 }
+
+#if defined(CONFIG_FWU_MULTI_BANK_UPDATE)
+void fwu_plat_get_bootidx(uint *boot_idx)
+{
+	/* Dummy value */
+	*boot_idx = 0;
+}
+#endif
diff --git a/board/st/common/Kconfig b/board/st/common/Kconfig
index 2f57118bb2..33047a32af 100644
--- a/board/st/common/Kconfig
+++ b/board/st/common/Kconfig
@@ -1,77 +1,11 @@
 config CMD_STBOARD
 	bool "stboard - command for OTP board information"
 	depends on ARCH_STM32MP
-	default y if TARGET_ST_STM32MP15x
+	default y if TARGET_ST_STM32MP25X || TARGET_ST_STM32MP15X || TARGET_ST_STM32MP13X
 	help
 	  This compile the stboard command to
 	  read and write the board in the OTP.
 
-config MTDPARTS_NAND0_BOOT
-	string "mtd boot partitions for nand0"
-	default "2m(fsbl),2m(ssbl1),2m(ssbl2)" if STM32MP15x_STM32IMAGE || \
-						  !TFABOOT
-	default "2m(fsbl),4m(fip1),4m(fip2)"
-	depends on SYS_MTDPARTS_RUNTIME && ARCH_STM32MP
-	help
-	  This define the partitions of nand0 used to build mtparts dynamically
-	  for boot from nand0.
-	  Each partition need to be aligned with the device erase block size,
-	  512KB is the max size for the NAND supported by stm32mp1 platform.
-	  The fsbl partition support multiple copy of the same binary, one by
-	  erase block.
-
-config MTDPARTS_NAND0_TEE
-	string "mtd tee partitions for nand0"
-	default "512k(teeh),512k(teed),512k(teex)"
-	depends on SYS_MTDPARTS_RUNTIME && ARCH_STM32MP && STM32MP15x_STM32IMAGE
-	help
-	  This define the tee partitions added in mtparts dynamically
-	  when tee is supported with boot from nand0.
-	  Each partition need to be aligned with the device erase block size,
-	  512KB is the max size for the NAND supported by stm32mp1 platform.
-
-config MTDPARTS_NOR0_BOOT
-	string "mtd boot partitions for nor0"
-	default "256k(fsbl1),256k(fsbl2),2m(ssbl),512k(u-boot-env)" if STM32MP15x_STM32IMAGE || \
-								       !TFABOOT
-	default "256k(fsbl1),256k(fsbl2),4m(fip),512k(u-boot-env)"
-	depends on SYS_MTDPARTS_RUNTIME && ARCH_STM32MP
-	help
-	  This define the partitions of nand0 used to build mtparts dynamically
-	  for boot from nor0.
-	  Each partition need to be aligned with the device erase block size,
-	  with 256KB we support all the NOR.
-	  U-Boot env partition (512kB) use 2 erase block for redundancy.
-
-config MTDPARTS_NOR0_TEE
-	string "mtd tee partitions for nor0"
-	default "256k(teeh),512k(teed),256k(teex)"
-	depends on SYS_MTDPARTS_RUNTIME && ARCH_STM32MP && STM32MP15x_STM32IMAGE
-	help
-	  This define the tee partitions added in mtparts dynamically
-	  when tee is supported with boot from nor0.
-
-config MTDPARTS_SPINAND0_BOOT
-	string "mtd boot partitions for spi-nand0"
-	default "2m(fsbl),2m(ssbl1),2m(ssbl2)" if STM32MP15x_STM32IMAGE || !TFABOOT
-	default "2m(fsbl),4m(fip1),4m(fip2)"
-	depends on SYS_MTDPARTS_RUNTIME && ARCH_STM32MP
-	help
-	  This define the partitions of nand0 used to build mtparts dynamically
-	  for boot from spi-nand0,
-	  512KB is the max size for the NAND supported by stm32mp1 platform.
-	  The fsbl partition support multiple copy of the same binary, one by
-	  erase block.
-
-config MTDPARTS_SPINAND0_TEE
-	string "mtd tee partitions for spi-nand0"
-	default "512k(teeh),512k(teed),512k(teex)"
-	depends on SYS_MTDPARTS_RUNTIME && ARCH_STM32MP && STM32MP15x_STM32IMAGE
-	help
-	  This define the tee partitions added in mtparts dynamically
-	  when tee is supported with boot from spi-nand0,
-	  512KB is the max size for the NAND supported by stm32mp1 platform.
-
 config DFU_ALT_RAM0
 	string "dfu for ram0"
 	default "uImage ram 0xc2000000 0x2000000;devicetree.dtb ram 0xc4000000 0x100000;uramdisk.image.gz ram 0xc4400000 0x10000000"
@@ -79,9 +13,3 @@ config DFU_ALT_RAM0
 	help
 	  This defines the partitions of ram used to build dfu dynamically.
 
-config TYPEC_STUSB160X
-	tristate "STMicroelectronics STUSB160X Type-C controller driver"
-	depends on DM_I2C
-	help
-	  Say Y if your system has STMicroelectronics STUSB160X Type-C port
-	  controller.
diff --git a/board/st/common/Makefile b/board/st/common/Makefile
index 65bbebd6ab..f048bca93e 100644
--- a/board/st/common/Makefile
+++ b/board/st/common/Makefile
@@ -7,8 +7,7 @@ obj-$(CONFIG_CMD_STBOARD) += cmd_stboard.o
 obj-$(CONFIG_PMIC_STPMIC1) += stpmic1.o
 
 ifeq ($(CONFIG_ARCH_STM32MP),y)
-obj-$(CONFIG_SYS_MTDPARTS_RUNTIME) += stm32mp_mtdparts.o
 obj-$(CONFIG_SET_DFU_ALT_INFO) += stm32mp_dfu.o
+obj-$(CONFIG_$(SPL_)DFU_VIRT) += stm32mp_dfu_virt.o
 endif
 
-obj-$(CONFIG_TYPEC_STUSB160X) += stusb160x.o
diff --git a/board/st/common/cmd_stboard.c b/board/st/common/cmd_stboard.c
index e12669b862..8b29443fac 100644
--- a/board/st/common/cmd_stboard.c
+++ b/board/st/common/cmd_stboard.c
@@ -2,8 +2,8 @@
 /*
  * Copyright (C) 2019, STMicroelectronics - All Rights Reserved
  *
- * the st command stboard supports the STMicroelectronics board identification
- * saved in OTP 59.
+ * the command stboard supports the STMicroelectronics board identification
+ * saved in OTP_BOARD.
  *
  * The ST product codification have several element
  * - "Commercial Product Name" (CPN): type of product board (DKX, EVX)
@@ -18,7 +18,7 @@
  * - Finished Good = EVA32MP157A1$AU1
  *
  * Both information are written on board and these information are also saved
- * in OTP59, with:
+ * in OTP_BOARD (59 for STM32MP15x or 60 for STM32MP13x), with:
  * bit [31:16] (hex) => Board id, MBxxxx
  * bit [15:12] (dec) => Variant CPN (1....15)
  * bit [11:8]  (dec) => Revision board (index with A = 1, Z = 26)
@@ -34,6 +34,7 @@
 #include <command.h>
 #include <console.h>
 #include <misc.h>
+#include <asm/arch/bsec.h>
 #include <dm/device.h>
 #include <dm/uclass.h>
 
@@ -48,6 +49,9 @@ static bool check_stboard(u16 board)
 		0x1298,
 		0x1341,
 		0x1497,
+		0x1605, /* stm32mp25xx-dk */
+		0x1635,
+		0x1936, /* stm32mp25xx-ev */
 	};
 
 	for (i = 0; i < ARRAY_SIZE(st_board_id); i++)
@@ -109,7 +113,7 @@ static int do_stboard(struct cmd_tbl *cmdtp, int flag, int argc,
 		else
 			display_stboard(otp);
 		printf("      OTP %d %s locked !\n", BSEC_OTP_BOARD,
-		       lock == 1 ? "" : "NOT");
+		       lock & BSEC_LOCK_PERM ? "" : "NOT");
 		return CMD_RET_SUCCESS;
 	}
 
@@ -178,7 +182,7 @@ static int do_stboard(struct cmd_tbl *cmdtp, int flag, int argc,
 	}
 
 	/* write persistent lock */
-	otp = 1;
+	otp = BSEC_LOCK_PERM;
 	ret = misc_write(dev, STM32_BSEC_LOCK(BSEC_OTP_BOARD),
 			 &otp, sizeof(otp));
 	if (ret != sizeof(otp)) {
diff --git a/board/st/common/stm32mp_dfu.c b/board/st/common/stm32mp_dfu.c
index fa48b2a35e..735a908790 100644
--- a/board/st/common/stm32mp_dfu.c
+++ b/board/st/common/stm32mp_dfu.c
@@ -13,7 +13,6 @@
 #include <misc.h>
 #include <mtd.h>
 #include <mtd_node.h>
-#include <asm/arch/stm32prog.h>
 
 #define DFU_ALT_BUF_LEN SZ_1K
 
@@ -72,7 +71,6 @@ static void board_get_alt_info_mmc(struct udevice *dev, char *buf)
 static void board_get_alt_info_mtd(struct mtd_info *mtd, char *buf)
 {
 	struct mtd_info *part;
-	bool first = true;
 	const char *name;
 	int len, partnum = 0;
 
@@ -85,17 +83,13 @@ static void board_get_alt_info_mtd(struct mtd_info *mtd, char *buf)
 			"mtd %s=", name);
 
 	len += snprintf(buf + len, DFU_ALT_BUF_LEN - len,
-			"%s raw 0x0 0x%llx ",
+			"%s raw 0x0 0x%llx",
 			name, mtd->size);
 
 	list_for_each_entry(part, &mtd->partitions, node) {
 		partnum++;
-		if (!first)
-			len += snprintf(buf + len, DFU_ALT_BUF_LEN - len, ";");
-		first = false;
-
 		len += snprintf(buf + len, DFU_ALT_BUF_LEN - len,
-				"%s_%s part %d",
+				";%s_%s part %d",
 				name, part->name, partnum);
 	}
 }
@@ -126,129 +120,19 @@ void set_dfu_alt_info(char *interface, char *devstr)
 	if (CONFIG_IS_ENABLED(MTD)) {
 		/* probe all MTD devices */
 		mtd_probe_devices();
-
-		/* probe SPI flash device on a bus */
-		if (!uclass_get_device(UCLASS_SPI_FLASH, 0, &dev)) {
-			mtd = get_mtd_device_nm("nor0");
-			if (!IS_ERR_OR_NULL(mtd))
+		mtd_for_each_device(mtd)
+			if (!mtd_is_partition(mtd))
 				board_get_alt_info_mtd(mtd, buf);
-
-			mtd = get_mtd_device_nm("nor1");
-			if (!IS_ERR_OR_NULL(mtd))
-				board_get_alt_info_mtd(mtd, buf);
-		}
-
-		mtd = get_mtd_device_nm("nand0");
-		if (!IS_ERR_OR_NULL(mtd))
-			board_get_alt_info_mtd(mtd, buf);
-
-		mtd = get_mtd_device_nm("spi-nand0");
-		if (!IS_ERR_OR_NULL(mtd))
-			board_get_alt_info_mtd(mtd, buf);
 	}
 
-	if (IS_ENABLED(CONFIG_DFU_VIRT) &&
-	    IS_ENABLED(CMD_STM32PROG_USB)) {
-		strncat(buf, "&virt 0=OTP", DFU_ALT_BUF_LEN);
+	if (IS_ENABLED(CONFIG_DFU_VIRT)) {
+		/* virtual device id 0 is aligned with stm32mp_dfu_virt.c */
+		strlcat(buf, "&virt 0=OTP", DFU_ALT_BUF_LEN);
 
 		if (IS_ENABLED(CONFIG_PMIC_STPMIC1))
-			strncat(buf, "&virt 1=PMIC", DFU_ALT_BUF_LEN);
+			strlcat(buf, "&virt 1=PMIC", DFU_ALT_BUF_LEN);
 	}
 
 	env_set("dfu_alt_info", buf);
 	puts("DFU alt info setting: done\n");
 }
-
-#if CONFIG_IS_ENABLED(DFU_VIRT)
-#include <dfu.h>
-#include <power/stpmic1.h>
-
-static int dfu_otp_read(u64 offset, u8 *buffer, long *size)
-{
-	struct udevice *dev;
-	int ret;
-
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_DRIVER_GET(stm32mp_bsec),
-					  &dev);
-	if (ret)
-		return ret;
-
-	ret = misc_read(dev, offset + STM32_BSEC_OTP_OFFSET, buffer, *size);
-	if (ret >= 0) {
-		*size = ret;
-		ret = 0;
-	}
-
-	return 0;
-}
-
-static int dfu_pmic_read(u64 offset, u8 *buffer, long *size)
-{
-	int ret;
-#ifdef CONFIG_PMIC_STPMIC1
-	struct udevice *dev;
-
-	ret = uclass_get_device_by_driver(UCLASS_MISC,
-					  DM_DRIVER_GET(stpmic1_nvm),
-					  &dev);
-	if (ret)
-		return ret;
-
-	ret = misc_read(dev, 0xF8 + offset, buffer, *size);
-	if (ret >= 0) {
-		*size = ret;
-		ret = 0;
-	}
-	if (ret == -EACCES) {
-		*size = 0;
-		ret = 0;
-	}
-#else
-	log_err("PMIC update not supported");
-	ret = -EOPNOTSUPP;
-#endif
-
-	return ret;
-}
-
-int dfu_read_medium_virt(struct dfu_entity *dfu, u64 offset,
-			 void *buf, long *len)
-{
-	switch (dfu->data.virt.dev_num) {
-	case 0x0:
-		return dfu_otp_read(offset, buf, len);
-	case 0x1:
-		return dfu_pmic_read(offset, buf, len);
-	}
-
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
-	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
-		return stm32prog_read_medium_virt(dfu, offset, buf, len);
-
-	*len = 0;
-	return 0;
-}
-
-int dfu_write_medium_virt(struct dfu_entity *dfu, u64 offset,
-			  void *buf, long *len)
-{
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
-	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
-		return stm32prog_write_medium_virt(dfu, offset, buf, len);
-
-	return -EOPNOTSUPP;
-}
-
-int __weak dfu_get_medium_size_virt(struct dfu_entity *dfu, u64 *size)
-{
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
-	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
-		return stm32prog_get_medium_size_virt(dfu, size);
-
-	*size = SZ_1K;
-
-	return 0;
-}
-
-#endif
diff --git a/board/st/common/stm32mp_dfu_virt.c b/board/st/common/stm32mp_dfu_virt.c
new file mode 100644
index 0000000000..ac1ef7fb96
--- /dev/null
+++ b/board/st/common/stm32mp_dfu_virt.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <dfu.h>
+#include <dm.h>
+#include <misc.h>
+#include <asm/arch/stm32prog.h>
+#include <power/stpmic1.h>
+
+static int dfu_otp_read(u64 offset, u8 *buffer, long *size)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stm32mp_bsec),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, offset + STM32_BSEC_OTP_OFFSET, buffer, *size);
+	if (ret >= 0) {
+		*size = ret;
+		ret = 0;
+	}
+
+	return 0;
+}
+
+static int dfu_pmic_read(u64 offset, u8 *buffer, long *size)
+{
+	int ret;
+	struct udevice *dev;
+
+	if (!IS_ENABLED(CONFIG_PMIC_STPMIC1)) {
+		log_err("PMIC update not supported");
+		return -EOPNOTSUPP;
+	}
+
+	ret = uclass_get_device_by_driver(UCLASS_MISC,
+					  DM_DRIVER_GET(stpmic1_nvm),
+					  &dev);
+	if (ret)
+		return ret;
+
+	ret = misc_read(dev, 0xF8 + offset, buffer, *size);
+	if (ret >= 0) {
+		*size = ret;
+		ret = 0;
+	}
+	if (ret == -EACCES) {
+		*size = 0;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+int dfu_read_medium_virt(struct dfu_entity *dfu, u64 offset,
+			 void *buf, long *len)
+{
+	switch (dfu->data.virt.dev_num) {
+	case 0x0:
+		return dfu_otp_read(offset, buf, len);
+	case 0x1:
+		return dfu_pmic_read(offset, buf, len);
+	}
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
+	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
+		return stm32prog_read_medium_virt(dfu, offset, buf, len);
+
+	*len = 0;
+	return 0;
+}
+
+int dfu_write_medium_virt(struct dfu_entity *dfu, u64 offset,
+			  void *buf, long *len)
+{
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
+	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
+		return stm32prog_write_medium_virt(dfu, offset, buf, len);
+
+	return -EOPNOTSUPP;
+}
+
+int dfu_get_medium_size_virt(struct dfu_entity *dfu, u64 *size)
+{
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_USB) &&
+	    dfu->data.virt.dev_num >= STM32PROG_VIRT_FIRST_DEV_NUM)
+		return stm32prog_get_medium_size_virt(dfu, size);
+
+	*size = SZ_1K;
+
+	return 0;
+}
diff --git a/board/st/common/stm32mp_mtdparts.c b/board/st/common/stm32mp_mtdparts.c
deleted file mode 100644
index 18878424c7..0000000000
--- a/board/st/common/stm32mp_mtdparts.c
+++ /dev/null
@@ -1,177 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
-/*
- * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
- */
-
-#include <common.h>
-#include <dfu.h>
-#include <dm.h>
-#include <env.h>
-#include <env_internal.h>
-#include <log.h>
-#include <mtd.h>
-#include <mtd_node.h>
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-#include <tee.h>
-#endif
-#include <asm/arch/stm32prog.h>
-#include <asm/arch/sys_proto.h>
-#include <asm/global_data.h>
-
-#define MTDPARTS_LEN		256
-#define MTDIDS_LEN		128
-
-/*
- * Get a global data pointer
- */
-DECLARE_GLOBAL_DATA_PTR;
-
-/**
- * update the variables "mtdids" and "mtdparts" with boot, tee and user strings
- */
-static void board_set_mtdparts(const char *dev,
-			       char *mtdids,
-			       char *mtdparts,
-			       const char *boot,
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-			       const char *tee,
-#endif
-			       const char *user)
-{
-	/* mtdids: "<dev>=<dev>, ...." */
-	if (mtdids[0] != '\0')
-		strcat(mtdids, ",");
-	strcat(mtdids, dev);
-	strcat(mtdids, "=");
-	strcat(mtdids, dev);
-
-	/* mtdparts: "mtdparts=<dev>:<mtdparts_<dev>>;..." */
-	if (mtdparts[0] != '\0')
-		strncat(mtdparts, ";", MTDPARTS_LEN);
-	else
-		strcat(mtdparts, "mtdparts=");
-
-	strncat(mtdparts, dev, MTDPARTS_LEN);
-	strncat(mtdparts, ":", MTDPARTS_LEN);
-
-	if (boot) {
-		strncat(mtdparts, boot, MTDPARTS_LEN);
-		strncat(mtdparts, ",", MTDPARTS_LEN);
-	}
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	if (tee) {
-		strncat(mtdparts, tee, MTDPARTS_LEN);
-		strncat(mtdparts, ",", MTDPARTS_LEN);
-	}
-#endif
-
-	strncat(mtdparts, user, MTDPARTS_LEN);
-}
-
-void board_mtdparts_default(const char **mtdids, const char **mtdparts)
-{
-	struct mtd_info *mtd;
-	struct udevice *dev;
-	static char parts[3 * MTDPARTS_LEN + 1];
-	static char ids[MTDIDS_LEN + 1];
-	static bool mtd_initialized;
-	bool nor, nand, spinand, serial;
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	bool tee = false;
-#endif
-
-	if (mtd_initialized) {
-		*mtdids = ids;
-		*mtdparts = parts;
-		return;
-	}
-
-	nor = false;
-	nand = false;
-	spinand = false;
-	serial = false;
-
-	switch (get_bootmode() & TAMP_BOOT_DEVICE_MASK) {
-	case BOOT_SERIAL_UART:
-	case BOOT_SERIAL_USB:
-		serial = true;
-		if (CONFIG_IS_ENABLED(CMD_STM32PROG)) {
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-			tee = stm32prog_get_tee_partitions();
-#endif
-			nor = stm32prog_get_fsbl_nor();
-		}
-		nand = true;
-		spinand = true;
-		break;
-	case BOOT_FLASH_NAND:
-		nand = true;
-		break;
-	case BOOT_FLASH_SPINAND:
-		spinand = true;
-		break;
-	case BOOT_FLASH_NOR:
-		nor = true;
-		break;
-	default:
-		break;
-	}
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	if (!serial && tee_find_device(NULL, NULL, NULL, NULL))
-		tee = true;
-#endif
-
-	memset(parts, 0, sizeof(parts));
-	memset(ids, 0, sizeof(ids));
-
-	/* probe all MTD devices */
-	for (uclass_first_device(UCLASS_MTD, &dev);
-	     dev;
-	     uclass_next_device(&dev)) {
-		log_debug("mtd device = %s\n", dev->name);
-	}
-
-	if (nand) {
-		mtd = get_mtd_device_nm("nand0");
-		if (!IS_ERR_OR_NULL(mtd)) {
-			board_set_mtdparts("nand0", ids, parts,
-					   CONFIG_MTDPARTS_NAND0_BOOT,
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-					   !nor && tee ? CONFIG_MTDPARTS_NAND0_TEE : NULL,
-#endif
-					   "-(UBI)");
-			put_mtd_device(mtd);
-		}
-	}
-
-	if (spinand) {
-		mtd = get_mtd_device_nm("spi-nand0");
-		if (!IS_ERR_OR_NULL(mtd)) {
-			board_set_mtdparts("spi-nand0", ids, parts,
-					   CONFIG_MTDPARTS_SPINAND0_BOOT,
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-					   !nor && tee ? CONFIG_MTDPARTS_SPINAND0_TEE : NULL,
-#endif
-					   "-(UBI)");
-			put_mtd_device(mtd);
-		}
-	}
-
-	if (nor) {
-		if (!uclass_get_device(UCLASS_SPI_FLASH, 0, &dev)) {
-			board_set_mtdparts("nor0", ids, parts,
-					   CONFIG_MTDPARTS_NOR0_BOOT,
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-					   tee ? CONFIG_MTDPARTS_NOR0_TEE : NULL,
-#endif
-					   "-(nor_user)");
-		}
-	}
-
-	mtd_initialized = true;
-	*mtdids = ids;
-	*mtdparts = parts;
-	log_debug("mtdids=%s & mtdparts=%s\n", ids, parts);
-}
diff --git a/board/st/common/stusb160x.c b/board/st/common/stusb160x.c
deleted file mode 100644
index f0385e5e38..0000000000
--- a/board/st/common/stusb160x.c
+++ /dev/null
@@ -1,48 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
-/*
- * STMicroelectronics STUSB Type-C controller driver
- * based on Linux drivers/usb/typec/stusb160x.c
- *
- * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
- */
-
-#define LOG_CATEGORY UCLASS_I2C_GENERIC
-
-#include <common.h>
-#include <dm.h>
-#include <i2c.h>
-
-/* REGISTER */
-#define STUSB160X_CC_CONNECTION_STATUS		0x0E
-
-/* STUSB160X_CC_CONNECTION_STATUS bitfields */
-#define STUSB160X_CC_ATTACH			BIT(0)
-
-int stusb160x_cable_connected(void)
-{
-	struct udevice *dev;
-	int ret;
-
-	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC,
-					  DM_DRIVER_GET(stusb160x),
-					  &dev);
-	if (ret < 0)
-		return ret;
-
-	ret = dm_i2c_reg_read(dev, STUSB160X_CC_CONNECTION_STATUS);
-	if (ret < 0)
-		return 0;
-
-	return ret & STUSB160X_CC_ATTACH;
-}
-
-static const struct udevice_id stusb160x_ids[] = {
-	{ .compatible = "st,stusb1600" },
-	{}
-};
-
-U_BOOT_DRIVER(stusb160x) = {
-	.name = "stusb160x",
-	.id = UCLASS_I2C_GENERIC,
-	.of_match = stusb160x_ids,
-};
diff --git a/board/st/common/stusb160x.h b/board/st/common/stusb160x.h
deleted file mode 100644
index fe39840b41..0000000000
--- a/board/st/common/stusb160x.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2020, STMicroelectronics
- */
-
-#ifdef CONFIG_TYPEC_STUSB160X
-int stusb160x_cable_connected(void);
-#else
-int stusb160x_cable_connected(void) { return -ENODEV; }
-#endif
diff --git a/board/st/stm32mp1/Kconfig b/board/st/stm32mp1/Kconfig
index 6ab8f80fa4..96de41546f 100644
--- a/board/st/stm32mp1/Kconfig
+++ b/board/st/stm32mp1/Kconfig
@@ -1,4 +1,4 @@
-if TARGET_ST_STM32MP15x
+if TARGET_ST_STM32MP15X
 
 config SYS_BOARD
 	default "stm32mp1"
@@ -12,7 +12,7 @@ config SYS_CONFIG_NAME
 source "board/st/common/Kconfig"
 endif
 
-if TARGET_ST_STM32MP13x
+if TARGET_ST_STM32MP13X
 
 config SYS_BOARD
 	default "stm32mp1"
diff --git a/board/st/stm32mp1/Makefile b/board/st/stm32mp1/Makefile
index 65560df290..f2d720b67b 100644
--- a/board/st/stm32mp1/Makefile
+++ b/board/st/stm32mp1/Makefile
@@ -8,3 +8,5 @@ obj-y += spl.o
 else
 obj-y += stm32mp1.o
 endif
+
+obj-$(CONFIG_DEBUG_UART_BOARD_INIT) += debug_uart.o
diff --git a/board/st/stm32mp1/debug_uart.c b/board/st/stm32mp1/debug_uart.c
new file mode 100644
index 0000000000..24e3f9f220
--- /dev/null
+++ b/board/st/stm32mp1/debug_uart.c
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <config.h>
+#include <debug_uart.h>
+#include <asm/io.h>
+#include <asm/arch/stm32.h>
+#include <linux/bitops.h>
+
+#define RCC_MP_APB1ENSETR (STM32_RCC_BASE + 0x0A00)
+#define RCC_MP_AHB4ENSETR (STM32_RCC_BASE + 0x0A28)
+
+#define GPIOG_BASE 0x50008000
+
+void board_debug_uart_init(void)
+{
+	if (CONFIG_DEBUG_UART_BASE == STM32_UART4_BASE) {
+		/* UART4 clock enable */
+		setbits_le32(RCC_MP_APB1ENSETR, BIT(16));
+
+		/* GPIOG clock enable */
+		writel(BIT(6), RCC_MP_AHB4ENSETR);
+		/* GPIO configuration for ST boards: Uart4 TX = G11 */
+		writel(0xffbfffff, GPIOG_BASE + 0x00);
+		writel(0x00006000, GPIOG_BASE + 0x24);
+	}
+}
diff --git a/board/st/stm32mp1/spl.c b/board/st/stm32mp1/spl.c
index 8e4549a1b3..747ec7e445 100644
--- a/board/st/stm32mp1/spl.c
+++ b/board/st/stm32mp1/spl.c
@@ -5,11 +5,7 @@
 
 #include <config.h>
 #include <common.h>
-#include <init.h>
-#include <asm/io.h>
 #include <asm/arch/sys_proto.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
 #include "../common/stpmic1.h"
 
 /* board early initialisation in board_f: need to use global variable */
@@ -29,27 +25,3 @@ int board_early_init_f(void)
 	return 0;
 }
 
-#ifdef CONFIG_DEBUG_UART_BOARD_INIT
-void board_debug_uart_init(void)
-{
-#if (CONFIG_DEBUG_UART_BASE == STM32_UART4_BASE)
-
-#define RCC_MP_APB1ENSETR (STM32_RCC_BASE + 0x0A00)
-#define RCC_MP_AHB4ENSETR (STM32_RCC_BASE + 0x0A28)
-
-	/* UART4 clock enable */
-	setbits_le32(RCC_MP_APB1ENSETR, BIT(16));
-
-#define GPIOG_BASE 0x50008000
-	/* GPIOG clock enable */
-	writel(BIT(6), RCC_MP_AHB4ENSETR);
-	/* GPIO configuration for ST boards: Uart4 TX = G11 */
-	writel(0xffbfffff, GPIOG_BASE + 0x00);
-	writel(0x00006000, GPIOG_BASE + 0x24);
-#else
-
-#error("CONFIG_DEBUG_UART_BASE: not supported value")
-
-#endif
-}
-#endif
diff --git a/board/st/stm32mp1/stm32mp1.c b/board/st/stm32mp1/stm32mp1.c
index 8c162b42a5..5a6a42c95a 100644
--- a/board/st/stm32mp1/stm32mp1.c
+++ b/board/st/stm32mp1/stm32mp1.c
@@ -11,6 +11,7 @@
 #include <clk.h>
 #include <config.h>
 #include <dm.h>
+#include <efi_loader.h>
 #include <env.h>
 #include <env_internal.h>
 #include <fdt_simplefb.h>
@@ -19,18 +20,19 @@
 #include <generic-phy.h>
 #include <hang.h>
 #include <i2c.h>
+#include <regmap.h>
 #include <init.h>
 #include <led.h>
 #include <log.h>
 #include <malloc.h>
 #include <misc.h>
-#include <mtd_node.h>
 #include <net.h>
 #include <netdev.h>
 #include <phy.h>
 #include <remoteproc.h>
 #include <reset.h>
 #include <syscon.h>
+#include <typec.h>
 #include <usb.h>
 #include <watchdog.h>
 #include <asm/global_data.h>
@@ -38,6 +40,8 @@
 #include <asm/gpio.h>
 #include <asm/arch/stm32.h>
 #include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
 #include <dm/ofnode.h>
 #include <jffs2/load_kernel.h>
 #include <linux/bitops.h>
@@ -47,8 +51,6 @@
 #include <power/regulator.h>
 #include <usb/dwc2_udc.h>
 
-#include "../../st/common/stusb160x.h"
-
 /* SYSCFG registers */
 #define SYSCFG_BOOTR		0x00
 #define SYSCFG_PMCSETR		0x04
@@ -56,7 +58,8 @@
 #define SYSCFG_ICNR		0x1C
 #define SYSCFG_CMPCR		0x20
 #define SYSCFG_CMPENSETR	0x24
-#define SYSCFG_PMCCLRR		0x44
+#define SYSCFG_PMCCLRR		0x08
+#define SYSCFG_MP13_PMCCLRR	0x44
 
 #define SYSCFG_BOOTR_BOOT_MASK		GENMASK(2, 0)
 #define SYSCFG_BOOTR_BOOTPD_SHIFT	4
@@ -72,21 +75,24 @@
 
 #define SYSCFG_CMPENSETR_MPU_EN		BIT(0)
 
-#define SYSCFG_PMCSETR_ETH_CLK_SEL	BIT(16)
-#define SYSCFG_PMCSETR_ETH_REF_CLK_SEL	BIT(17)
-
-#define SYSCFG_PMCSETR_ETH_SELMII	BIT(20)
-
-#define SYSCFG_PMCSETR_ETH_SEL_MASK	GENMASK(23, 21)
-#define SYSCFG_PMCSETR_ETH_SEL_GMII_MII	0
-#define SYSCFG_PMCSETR_ETH_SEL_RGMII	BIT(21)
-#define SYSCFG_PMCSETR_ETH_SEL_RMII	BIT(23)
+#define GOODIX_REG_ID		0x8140
+#define GOODIX_ID_LEN		4
 
 #define USB_LOW_THRESHOLD_UV		200000
 #define USB_WARNING_LOW_THRESHOLD_UV	660000
 #define USB_START_LOW_THRESHOLD_UV	1230000
 #define USB_START_HIGH_THRESHOLD_UV	2150000
 
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+struct efi_fw_image fw_images[1];
+
+struct efi_capsule_update_info update_info = {
+	.num_images = ARRAY_SIZE(fw_images),
+	.images = fw_images,
+};
+
+#endif /* EFI_HAVE_CAPSULE_SUPPORT */
+
 int board_early_init_f(void)
 {
 	/* nothing to do, only used in SPL */
@@ -103,7 +109,7 @@ int checkboard(void)
 	int fdt_compat_len;
 
 	if (IS_ENABLED(CONFIG_TFABOOT)) {
-		if (IS_ENABLED(CONFIG_STM32MP15x_STM32IMAGE))
+		if (IS_ENABLED(CONFIG_STM32MP15X_STM32IMAGE))
 			mode = "trusted - stm32image";
 		else
 			mode = "trusted";
@@ -186,6 +192,20 @@ static void board_key_check(void)
 	}
 }
 
+static int typec_usb_cable_connected(void)
+{
+	struct udevice *dev;
+	int ret;
+	u8 connector = 0;
+
+	ret = uclass_get_device(UCLASS_USB_TYPEC, 0, &dev);
+	if (ret < 0)
+		return ret;
+
+	return (typec_is_attached(dev, connector) == TYPEC_ATTACHED) &&
+	       (typec_get_data_role(dev, connector) == TYPEC_DEVICE);
+}
+
 int g_dnl_board_usb_cable_connected(void)
 {
 	struct udevice *dwc2_udc_otg;
@@ -201,8 +221,8 @@ int g_dnl_board_usb_cable_connected(void)
 	if ((get_bootmode() & TAMP_BOOT_DEVICE_MASK) == BOOT_SERIAL_USB)
 		return true;
 
-	/* if typec stusb160x is present, means DK1 or DK2 board */
-	ret = stusb160x_cable_connected();
+	/* if Type-C is present, it means DK1 or DK2 board */
+	ret = typec_usb_cable_connected();
 	if (ret >= 0)
 		return ret;
 
@@ -357,9 +377,6 @@ static int board_check_usb_power(void)
 	u32 nb_blink;
 	u8 i;
 
-	if (!IS_ENABLED(CONFIG_ADC))
-		return -ENODEV;
-
 	node = ofnode_path("/config");
 	if (!ofnode_valid(node)) {
 		log_debug("no /config node?\n");
@@ -605,8 +622,9 @@ error:
 
 static bool board_is_stm32mp15x_dk2(void)
 {
-	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15x) &&
-	    of_machine_is_compatible("st,stm32mp157c-dk2"))
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15X) &&
+	    (of_machine_is_compatible("st,stm32mp157c-dk2") ||
+	     of_machine_is_compatible("st,stm32mp157f-dk2")))
 		return true;
 
 	return false;
@@ -614,7 +632,7 @@ static bool board_is_stm32mp15x_dk2(void)
 
 static bool board_is_stm32mp15x_ev1(void)
 {
-	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15x) &&
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP15X) &&
 	    (of_machine_is_compatible("st,stm32mp157a-ev1") ||
 	     of_machine_is_compatible("st,stm32mp157c-ev1") ||
 	     of_machine_is_compatible("st,stm32mp157d-ev1") ||
@@ -624,24 +642,192 @@ static bool board_is_stm32mp15x_ev1(void)
 	return false;
 }
 
+/* touchscreen driver: used for focaltech touchscreen detection */
+static const struct udevice_id edt_ft6236_ids[] = {
+	{ .compatible = "focaltech,ft6236", },
+	{ }
+};
+
+U_BOOT_DRIVER(edt_ft6236) = {
+	.name		= "edt_ft6236",
+	.id		= UCLASS_I2C_GENERIC,
+	.of_match	= edt_ft6236_ids,
+};
+
 /* touchscreen driver: only used for pincontrol configuration */
 static const struct udevice_id goodix_ids[] = {
+	{ .compatible = "goodix,gt911", },
 	{ .compatible = "goodix,gt9147", },
 	{ }
 };
 
 U_BOOT_DRIVER(goodix) = {
 	.name		= "goodix",
-	.id		= UCLASS_NOP,
+	.id		= UCLASS_I2C_GENERIC,
 	.of_match	= goodix_ids,
 };
 
+static int goodix_i2c_read(struct udevice *dev, u16 reg, u8 *buf, int len)
+{
+	struct i2c_msg msgs[2];
+	__be16 wbuf = cpu_to_be16(reg);
+	int ret;
+
+	msgs[0].flags = 0;
+	msgs[0].addr  = 0x5d;
+	msgs[0].len   = 2;
+	msgs[0].buf   = (u8 *)&wbuf;
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr  = 0x5d;
+	msgs[1].len   = len;
+	msgs[1].buf   = buf;
+
+	ret = dm_i2c_xfer(dev, msgs, 2);
+
+	return ret;
+}
+
+/* HELPER: search detected driver */
+struct detect_info_t {
+	bool (*detect)(void);
+	struct driver *drv;
+};
+
+static struct driver *detect_device(struct detect_info_t *info, u8 size)
+{
+	struct driver *drv = NULL;
+	u8 i;
+
+	for (i = 0; i < size && !drv; i++)
+		if (info[i].detect())
+			drv = info[i].drv;
+
+	return drv;
+}
+
+/* HELPER: force new driver binding, replace the existing one */
+static void bind_driver(struct driver *drv, const char *path)
+{
+	ofnode node;
+	struct udevice *dev;
+	struct udevice *parent;
+	int ret;
+
+	node = ofnode_path(path);
+	if (!ofnode_valid(node))
+		return;
+	if (!ofnode_is_enabled(node))
+		return;
+
+	ret = device_find_global_by_ofnode(ofnode_get_parent(node), &parent);
+	if (!parent || ret) {
+		log_debug("Unable to found parent. err:%d\n", ret);
+		return;
+	}
+
+	ret = device_find_global_by_ofnode(node, &dev);
+	/* remove the driver previously binded */
+	if (dev && !ret) {
+		if (dev->driver == drv) {
+			log_debug("nothing to do, %s already binded.\n", drv->name);
+			return;
+		}
+		log_debug("%s unbind\n", dev->driver->name);
+		device_remove(dev, DM_REMOVE_NORMAL);
+		device_unbind(dev);
+	}
+	/* bind the new driver */
+	ret = device_bind_with_driver_data(parent, drv, ofnode_get_name(node),
+					   0, node, &dev);
+	if (ret)
+		log_debug("Unable to bind %s, err:%d\n", drv->name, ret);
+}
+
+bool stm32mp15x_ev1_rm68200(void)
+{
+	struct udevice *dev;
+	struct udevice *bus;
+	struct dm_i2c_chip *chip;
+	char id[GOODIX_ID_LEN];
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC, DM_DRIVER_GET(goodix), &dev);
+	if (ret)
+		return false;
+
+	bus = dev_get_parent(dev);
+	chip = dev_get_parent_plat(dev);
+	ret = dm_i2c_probe(bus, chip->chip_addr, 0, &dev);
+	if (ret)
+		return false;
+
+	ret = goodix_i2c_read(dev, GOODIX_REG_ID, id, sizeof(id));
+	if (ret)
+		return false;
+
+	if (!strncmp(id, "9147", sizeof(id)))
+		return true;
+
+	return false;
+}
+
+bool stm32mp15x_ev1_hx8394(void)
+{
+	return true;
+}
+
+extern U_BOOT_DRIVER(rm68200_panel);
+extern U_BOOT_DRIVER(hx8394_panel);
+
+struct detect_info_t stm32mp15x_ev1_panels[] = {
+	CONFIG_IS_ENABLED(VIDEO_LCD_RAYDIUM_RM68200,
+			  ({ .detect = stm32mp15x_ev1_rm68200,
+			   .drv = DM_DRIVER_REF(rm68200_panel)
+			   },
+			   ))
+	CONFIG_IS_ENABLED(VIDEO_LCD_ROCKTECH_HX8394,
+			  ({ .detect = stm32mp15x_ev1_hx8394,
+			   .drv = DM_DRIVER_REF(hx8394_panel)
+			   },
+			   ))
+};
+
 static void board_stm32mp15x_ev1_init(void)
 {
 	struct udevice *dev;
+	struct driver *drv;
+	struct gpio_desc reset_gpio;
+	char path[40];
 
 	/* configure IRQ line on EV1 for touchscreen before LCD reset */
-	uclass_get_device_by_driver(UCLASS_NOP, DM_DRIVER_GET(goodix), &dev);
+	uclass_get_device_by_driver(UCLASS_I2C_GENERIC, DM_DRIVER_GET(goodix), &dev);
+
+	/* get & set reset gpio for panel */
+	uclass_get_device_by_driver(UCLASS_PANEL, DM_DRIVER_GET(rm68200_panel), &dev);
+
+	gpio_request_by_name(dev, "reset-gpios", 0, &reset_gpio, GPIOD_IS_OUT);
+
+	if (!dm_gpio_is_valid(&reset_gpio))
+		return;
+
+	dm_gpio_set_value(&reset_gpio, true);
+	mdelay(1);
+	dm_gpio_set_value(&reset_gpio, false);
+	mdelay(10);
+
+	/* auto detection of connected panel-dsi */
+	drv = detect_device(stm32mp15x_ev1_panels, ARRAY_SIZE(stm32mp15x_ev1_panels));
+	if (!drv)
+		return;
+	/* save the detected compatible in environment */
+	env_set("panel-dsi", drv->of_match->compatible);
+
+	dm_gpio_free(NULL, &reset_gpio);
+
+	/* select the driver for the detected PANEL */
+	ofnode_get_path(dev_ofnode(dev), path, sizeof(path));
+	bind_driver(drv, path);
 }
 
 /* board dependent setup after realloc */
@@ -649,12 +835,6 @@ int board_init(void)
 {
 	board_key_check();
 
-	if (board_is_stm32mp15x_ev1())
-		board_stm32mp15x_ev1_init();
-
-	if (board_is_stm32mp15x_dk2())
-		board_stm32mp15x_dk2_init();
-
 	regulators_enable_boot_on(_DEBUG);
 
 	/*
@@ -666,6 +846,13 @@ int board_init(void)
 
 	setup_led(LEDST_ON);
 
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+	efi_guid_t image_type_guid = STM32MP_FIP_IMAGE_GUID;
+
+	guidcpy(&fw_images[0].image_type_id, &image_type_guid);
+	fw_images[0].fw_name = u"STM32MP-FIP";
+	fw_images[0].image_index = 1;
+#endif
 	return 0;
 }
 
@@ -680,6 +867,12 @@ int board_late_init(void)
 	char dtb_name[256];
 	int buf_len;
 
+	if (IS_ENABLED(CONFIG_VIDEO_LCD_RAYDIUM_RM68200) && board_is_stm32mp15x_ev1())
+		board_stm32mp15x_ev1_init();
+
+	if (board_is_stm32mp15x_dk2())
+		board_stm32mp15x_dk2_init();
+
 	if (IS_ENABLED(CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG)) {
 		fdt_compat = ofnode_get_property(ofnode_root(), "compatible",
 						 &fdt_compat_len);
@@ -713,8 +906,14 @@ int board_late_init(void)
 		}
 	}
 
-	/* for DK1/DK2 boards */
-	board_check_usb_power();
+	if (IS_ENABLED(CONFIG_ADC)) {
+		/* probe all ADC for calibration */
+		uclass_foreach_dev_probe(UCLASS_ADC, dev) {
+			log_debug("ACD probe for calibration: %s\n", dev->name);
+		}
+		/* for DK1/DK2 boards */
+		board_check_usb_power();
+	}
 
 	return 0;
 }
@@ -724,58 +923,114 @@ void board_quiesce_devices(void)
 	setup_led(LEDST_OFF);
 }
 
+/* CLOCK feed to PHY*/
+#define ETH_CK_F_25M	25000000
+#define ETH_CK_F_50M	50000000
+#define ETH_CK_F_125M	125000000
+
+struct stm32_syscfg_pmcsetr {
+	u32 syscfg_clr_off;
+	u32 eth1_clk_sel;
+	u32 eth1_ref_clk_sel;
+	u32 eth1_sel_mii;
+	u32 eth1_sel_rgmii;
+	u32 eth1_sel_rmii;
+	u32 eth2_clk_sel;
+	u32 eth2_ref_clk_sel;
+	u32 eth2_sel_rgmii;
+	u32 eth2_sel_rmii;
+};
+
+const struct stm32_syscfg_pmcsetr stm32mp15_syscfg_pmcsetr = {
+	.syscfg_clr_off		= 0x44,
+	.eth1_clk_sel		= BIT(16),
+	.eth1_ref_clk_sel	= BIT(17),
+	.eth1_sel_mii		= BIT(20),
+	.eth1_sel_rgmii		= BIT(21),
+	.eth1_sel_rmii		= BIT(23),
+	.eth2_clk_sel		= 0,
+	.eth2_ref_clk_sel	= 0,
+	.eth2_sel_rgmii		= 0,
+	.eth2_sel_rmii		= 0
+};
+
+const struct stm32_syscfg_pmcsetr stm32mp13_syscfg_pmcsetr = {
+	.syscfg_clr_off		= 0x08,
+	.eth1_clk_sel		= BIT(16),
+	.eth1_ref_clk_sel	= BIT(17),
+	.eth1_sel_mii		= 0,
+	.eth1_sel_rgmii		= BIT(21),
+	.eth1_sel_rmii		= BIT(23),
+	.eth2_clk_sel		= BIT(24),
+	.eth2_ref_clk_sel	= BIT(25),
+	.eth2_sel_rgmii		= BIT(29),
+	.eth2_sel_rmii		= BIT(31)
+};
+
+#define SYSCFG_PMCSETR_ETH_MASK		GENMASK(23, 16)
+#define SYSCFG_PMCR_ETH_SEL_GMII	0
+
 /* eth init function : weak called in eqos driver */
 int board_interface_eth_init(struct udevice *dev,
-			     phy_interface_t interface_type)
+			     phy_interface_t interface_type, ulong rate)
 {
-	u8 *syscfg;
+	struct regmap *regmap;
+	uint regmap_mask;
+	int ret;
 	u32 value;
-	bool eth_clk_sel_reg = false;
-	bool eth_ref_clk_sel_reg = false;
+	bool ext_phyclk, eth_clk_sel_reg, eth_ref_clk_sel_reg;
+	const struct stm32_syscfg_pmcsetr *pmcsetr;
+
+	/* Ethernet PHY have no crystal */
+	ext_phyclk = dev_read_bool(dev, "st,ext-phyclk");
 
 	/* Gigabit Ethernet 125MHz clock selection. */
 	eth_clk_sel_reg = dev_read_bool(dev, "st,eth-clk-sel");
 
 	/* Ethernet 50Mhz RMII clock selection */
-	eth_ref_clk_sel_reg =
-		dev_read_bool(dev, "st,eth-ref-clk-sel");
+	eth_ref_clk_sel_reg = dev_read_bool(dev, "st,eth-ref-clk-sel");
 
-	syscfg = (u8 *)syscon_get_first_range(STM32MP_SYSCON_SYSCFG);
+	if (device_is_compatible(dev, "st,stm32mp13-dwmac"))
+		pmcsetr = &stm32mp13_syscfg_pmcsetr;
+	else
+		pmcsetr = &stm32mp15_syscfg_pmcsetr;
+
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscon");
+	if (!IS_ERR(regmap)) {
+		u32 fmp[3];
 
-	if (!syscfg)
+		ret = dev_read_u32_array(dev, "st,syscon", fmp, 3);
+		if (ret)
+			/*  If no mask in DT, it is MP15 (backward compatibility) */
+			regmap_mask = SYSCFG_PMCSETR_ETH_MASK;
+		else
+			regmap_mask = fmp[2];
+	} else {
 		return -ENODEV;
+	}
 
 	switch (interface_type) {
 	case PHY_INTERFACE_MODE_MII:
-		value = SYSCFG_PMCSETR_ETH_SEL_GMII_MII |
-			SYSCFG_PMCSETR_ETH_REF_CLK_SEL;
+		value = pmcsetr->eth1_sel_mii;
 		log_debug("PHY_INTERFACE_MODE_MII\n");
 		break;
 	case PHY_INTERFACE_MODE_GMII:
-		if (eth_clk_sel_reg)
-			value = SYSCFG_PMCSETR_ETH_SEL_GMII_MII |
-				SYSCFG_PMCSETR_ETH_CLK_SEL;
-		else
-			value = SYSCFG_PMCSETR_ETH_SEL_GMII_MII;
+		value = SYSCFG_PMCR_ETH_SEL_GMII;
 		log_debug("PHY_INTERFACE_MODE_GMII\n");
 		break;
 	case PHY_INTERFACE_MODE_RMII:
-		if (eth_ref_clk_sel_reg)
-			value = SYSCFG_PMCSETR_ETH_SEL_RMII |
-				SYSCFG_PMCSETR_ETH_REF_CLK_SEL;
-		else
-			value = SYSCFG_PMCSETR_ETH_SEL_RMII;
+		value = pmcsetr->eth1_sel_rmii | pmcsetr->eth2_sel_rmii;
+		if (rate == ETH_CK_F_50M && (eth_clk_sel_reg || ext_phyclk))
+			value |= pmcsetr->eth1_ref_clk_sel | pmcsetr->eth2_ref_clk_sel;
 		log_debug("PHY_INTERFACE_MODE_RMII\n");
 		break;
 	case PHY_INTERFACE_MODE_RGMII:
 	case PHY_INTERFACE_MODE_RGMII_ID:
 	case PHY_INTERFACE_MODE_RGMII_RXID:
 	case PHY_INTERFACE_MODE_RGMII_TXID:
-		if (eth_clk_sel_reg)
-			value = SYSCFG_PMCSETR_ETH_SEL_RGMII |
-				SYSCFG_PMCSETR_ETH_CLK_SEL;
-		else
-			value = SYSCFG_PMCSETR_ETH_SEL_RGMII;
+		value = pmcsetr->eth1_sel_rgmii | pmcsetr->eth2_sel_rgmii;
+		if (rate == ETH_CK_F_125M && (eth_clk_sel_reg || ext_phyclk))
+			value |= pmcsetr->eth1_clk_sel | pmcsetr->eth2_clk_sel;
 		log_debug("PHY_INTERFACE_MODE_RGMII\n");
 		break;
 	default:
@@ -785,13 +1040,12 @@ int board_interface_eth_init(struct udevice *dev,
 		return -EINVAL;
 	}
 
-	/* clear and set ETH configuration bits */
-	writel(SYSCFG_PMCSETR_ETH_SEL_MASK | SYSCFG_PMCSETR_ETH_SELMII |
-	       SYSCFG_PMCSETR_ETH_REF_CLK_SEL | SYSCFG_PMCSETR_ETH_CLK_SEL,
-	       syscfg + SYSCFG_PMCCLRR);
-	writel(value, syscfg + SYSCFG_PMCSETR);
+	/* Need to update PMCCLRR (clear register) */
+	regmap_write(regmap, pmcsetr->syscfg_clr_off, regmap_mask);
 
-	return 0;
+	ret = regmap_update_bits(regmap, SYSCFG_PMCSETR, regmap_mask, value);
+
+	return ret;
 }
 
 enum env_location env_get_location(enum env_operation op, int prio)
@@ -895,30 +1149,160 @@ int mmc_get_env_dev(void)
 }
 
 #if defined(CONFIG_OF_BOARD_SETUP)
-int ft_board_setup(void *blob, struct bd_info *bd)
+void stm32mp15x_dk2_fdt_update(void *new_blob)
 {
-	static const struct node_info nodes[] = {
-		{ "st,stm32f469-qspi",		MTD_DEV_TYPE_NOR,  },
-		{ "st,stm32f469-qspi",		MTD_DEV_TYPE_SPINAND},
-		{ "st,stm32mp15-fmc2",		MTD_DEV_TYPE_NAND, },
-		{ "st,stm32mp1-fmc2-nfc",	MTD_DEV_TYPE_NAND, },
-	};
-	char *boot_device;
+	struct udevice *dev;
+	struct udevice *bus;
+	int nodeoff = 0;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_I2C_GENERIC, DM_DRIVER_GET(edt_ft6236), &dev);
+	if (ret)
+		return;
 
-	/* Check the boot-source and don't update MTD for serial or usb boot */
-	boot_device = env_get("boot_device");
-	if (!boot_device ||
-	    (strcmp(boot_device, "serial") && strcmp(boot_device, "usb")))
-		if (IS_ENABLED(CONFIG_FDT_FIXUP_PARTITIONS))
-			fdt_fixup_mtdparts(blob, nodes, ARRAY_SIZE(nodes));
+	bus = dev_get_parent(dev);
+
+	ret = dm_i2c_probe(bus, 0x38, 0, &dev);
+	if (ret < 0) {
+		nodeoff = fdt_node_offset_by_compatible(new_blob, -1, "focaltech,ft6236");
+		if (nodeoff < 0) {
+			log_warning("touchscreen@38 node not found\n");
+		} else {
+			fdt_set_name(new_blob, nodeoff, "touchscreen@2a");
+			fdt_setprop_u32(new_blob, nodeoff, "reg", 0x2a);
+			log_debug("touchscreen@38 node updated to @2a\n");
+		}
+	}
+}
+
+void fdt_update_panel_dsi(void *new_blob)
+{
+	char const *panel = env_get("panel-dsi");
+	int nodeoff = 0;
+
+	if (!panel)
+		return;
+
+	if (!strcmp(panel, "rocktech,hx8394")) {
+		nodeoff = fdt_node_offset_by_compatible(new_blob, -1, "raydium,rm68200");
+		if (nodeoff < 0) {
+			log_warning("panel-dsi node not found");
+			return;
+		}
+		fdt_setprop_string(new_blob, nodeoff, "compatible", panel);
+
+		nodeoff = fdt_node_offset_by_compatible(new_blob, -1, "goodix,gt9147");
+		if (nodeoff < 0) {
+			log_warning("touchscreen node not found");
+			return;
+		}
+		fdt_setprop_string(new_blob, nodeoff, "compatible", "goodix,gt911");
+	}
+}
+
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	fdt_copy_fixed_partitions(blob);
 
 	if (CONFIG_IS_ENABLED(FDT_SIMPLEFB))
 		fdt_simplefb_enable_and_mem_rsv(blob);
 
+	if (board_is_stm32mp15x_dk2())
+		stm32mp15x_dk2_fdt_update(blob);
+
+	if (board_is_stm32mp15x_ev1())
+		fdt_update_panel_dsi(blob);
+
 	return 0;
 }
 #endif
 
+#if defined(CONFIG_OF_BOARD_FIXUP)
+
+int fdt_update_fwu_properties(void *blob, int nodeoff,
+			      const char *compat_str,
+			      const char *storage_path)
+{
+	int ret;
+	int storage_off;
+
+	ret = fdt_increase_size(blob, 100);
+	if (ret) {
+		printf("fdt_increase_size: err=%s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "compatible", compat_str);
+	if (ret) {
+		log_err("Can't set compatible property\n");
+		return ret;
+	}
+
+	storage_off = fdt_path_offset(blob, storage_path);
+	if (storage_off < 0) {
+		log_err("Can't find %s path\n", storage_path);
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "fwu-mdata-store", storage_path);
+
+	if (ret < 0)
+		log_err("Can't set fwu-mdata-store property\n");
+
+	return ret;
+}
+
+int fdt_update_fwu_mdata(void *blob)
+{
+	int nodeoff, ret = 0;
+	u32 bootmode;
+
+	nodeoff = fdt_path_offset(blob, "/fwu-mdata");
+	if (nodeoff < 0) {
+		log_info("no /fwu-mdata node ?\n");
+
+		return 0;
+	}
+
+	bootmode = get_bootmode() & TAMP_BOOT_DEVICE_MASK;
+
+	switch (bootmode) {
+	case BOOT_FLASH_SD:
+		/* sdmmc1 : nothing to do, already the default device tree configuration */
+		break;
+	case BOOT_FLASH_EMMC:
+		/* sdmmc2 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-mtd",
+						"/soc/mmc@58007000");
+		break;
+
+	case BOOT_FLASH_NAND:
+		/* nand@0 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-gpt",
+						"/soc/etzpc@5c007000/memory-controller@58002000/nand-controller@4,0/nand@0");
+		break;
+
+	case BOOT_FLASH_SPINAND:
+	case BOOT_FLASH_NOR:
+		/* flash0 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-gpt",
+						"/soc/etzpc@5c007000/spi@58003000/flash@0");
+		break;
+	}
+
+	return ret;
+}
+
+int board_fix_fdt(void *blob)
+{
+	int ret = 0;
+	if (CONFIG_IS_ENABLED(FWU_MDATA) && board_is_stm32mp15x_ev1())
+		ret = fdt_update_fwu_mdata(blob);
+
+	return ret;
+}
+#endif /* CONFIG_OF_BOARD_FIXUP */
+
 static void board_copro_image_process(ulong fw_image, size_t fw_size)
 {
 	int ret, id = 0; /* Copro id fixed to 0 as only one coproc on mp1 */
@@ -939,3 +1323,24 @@ static void board_copro_image_process(ulong fw_image, size_t fw_size)
 }
 
 U_BOOT_FIT_LOADABLE_HANDLER(IH_TYPE_COPRO, board_copro_image_process);
+
+#if defined(CONFIG_FWU_MULTI_BANK_UPDATE)
+
+#include <fwu.h>
+
+/**
+ * fwu_plat_get_bootidx() - Get the value of the boot index
+ * @boot_idx: Boot index value
+ *
+ * Get the value of the bank(partition) from which the platform
+ * has booted. This value is passed to U-Boot from the earlier
+ * stage bootloader which loads and boots all the relevant
+ * firmware images
+ *
+ */
+void fwu_plat_get_bootidx(uint *boot_idx)
+{
+	*boot_idx = (readl(TAMP_FWU_BOOT_INFO_REG) >>
+		    TAMP_FWU_BOOT_IDX_OFFSET) & TAMP_FWU_BOOT_IDX_MASK;
+}
+#endif /* CONFIG_FWU_MULTI_BANK_UPDATE */
diff --git a/board/st/stm32mp2/Kconfig b/board/st/stm32mp2/Kconfig
new file mode 100644
index 0000000000..f91e25f1f9
--- /dev/null
+++ b/board/st/stm32mp2/Kconfig
@@ -0,0 +1,13 @@
+if TARGET_ST_STM32MP25X
+
+config SYS_BOARD
+	default "stm32mp2"
+
+config SYS_VENDOR
+	default "st"
+
+config SYS_CONFIG_NAME
+	default "stm32mp25_st_common"
+
+source "board/st/common/Kconfig"
+endif
diff --git a/board/st/stm32mp2/MAINTAINERS b/board/st/stm32mp2/MAINTAINERS
new file mode 100644
index 0000000000..94732f3b96
--- /dev/null
+++ b/board/st/stm32mp2/MAINTAINERS
@@ -0,0 +1,10 @@
+STM32MP2 BOARD
+M:	Patrice Chotard <patrice.chotard@st.com>
+M:	Patrick Delaunay <patrick.delaunay@st.com>
+L:	uboot-stm32@st-md-mailman.stormreply.com (moderated for non-subscribers)
+S:	Maintained
+F:	arch/arm/dts/stm32mp257*
+F:	board/st/stm32mp2
+F:	configs/stm32mp25_defconfig
+F:	include/configs/stm32mp25_common.h
+F:	include/configs/stm32mp25_st_common.h
diff --git a/board/st/stm32mp2/Makefile b/board/st/stm32mp2/Makefile
new file mode 100644
index 0000000000..ecd1d90c4c
--- /dev/null
+++ b/board/st/stm32mp2/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+#
+# Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+#
+
+obj-y += stm32mp2.o
diff --git a/board/st/stm32mp2/README b/board/st/stm32mp2/README
new file mode 100644
index 0000000000..b9ec3c965d
--- /dev/null
+++ b/board/st/stm32mp2/README
@@ -0,0 +1 @@
+see doc/board/st/stm32mp2.rst
diff --git a/board/st/stm32mp2/stm32mp2.c b/board/st/stm32mp2/stm32mp2.c
new file mode 100644
index 0000000000..349075e907
--- /dev/null
+++ b/board/st/stm32mp2/stm32mp2.c
@@ -0,0 +1,876 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY LOGC_BOARD
+
+#include <common.h>
+#include <button.h>
+#include <config.h>
+#include <dm.h>
+#include <efi_loader.h>
+#include <env.h>
+#include <env_internal.h>
+#include <fdt_simplefb.h>
+#include <fdt_support.h>
+#include <g_dnl.h>
+#include <i2c.h>
+#include <led.h>
+#include <log.h>
+#include <misc.h>
+#include <mmc.h>
+#include <init.h>
+#include <net.h>
+#include <netdev.h>
+#include <phy.h>
+#include <regmap.h>
+#include <syscon.h>
+#include <asm/io.h>
+#include <asm/global_data.h>
+#include <asm/gpio.h>
+#include <asm/arch/sys_proto.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
+#include <dm/ofnode.h>
+#include <dm/uclass.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/iopoll.h>
+
+#define SYSCFG_ETHCR_ETH_SEL_MII	0
+#define SYSCFG_ETHCR_ETH_SEL_RGMII	BIT(4)
+#define SYSCFG_ETHCR_ETH_SEL_RMII	BIT(6)
+#define SYSCFG_ETHCR_ETH_CLK_SEL	BIT(1)
+#define SYSCFG_ETHCR_ETH_REF_CLK_SEL	BIT(0)
+/* CLOCK feed to PHY*/
+#define ETH_CK_F_25M	25000000
+#define ETH_CK_F_50M	50000000
+#define ETH_CK_F_125M	125000000
+
+#define ILITEK_REG_ID		0x40
+#define ILITEK_ID_LEN		7
+#define ADV7511_REG_CHIP_REVISION	0x00
+#define ADV7511_CHIP_REVISION_LEN	256
+
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+struct efi_fw_image fw_images[1];
+
+struct efi_capsule_update_info update_info = {
+	.num_images = ARRAY_SIZE(fw_images),
+	.images = fw_images,
+};
+
+u8 num_image_type_guids = ARRAY_SIZE(fw_images);
+#endif /* EFI_HAVE_CAPSULE_SUPPORT */
+
+/*
+ * Get a global data pointer
+ */
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	int ret;
+	u32 otp;
+	struct udevice *dev;
+	const char *fdt_compat;
+	int fdt_compat_len;
+
+	fdt_compat = ofnode_get_property(ofnode_root(), "compatible", &fdt_compat_len);
+
+	log_info("Board: stm32mp2 (%s)\n", fdt_compat && fdt_compat_len ? fdt_compat : "");
+
+	/* display the STMicroelectronics board identification */
+	if (CONFIG_IS_ENABLED(CMD_STBOARD)) {
+		ret = uclass_get_device_by_driver(UCLASS_MISC,
+						  DM_DRIVER_GET(stm32mp_bsec),
+						  &dev);
+		if (!ret)
+			ret = misc_read(dev, STM32_BSEC_SHADOW(BSEC_OTP_BOARD),
+					&otp, sizeof(otp));
+		if (ret > 0 && otp)
+			log_info("Board: MB%04x Var%d.%d Rev.%c-%02d\n",
+				 otp >> 16,
+				 (otp >> 12) & 0xF,
+				 (otp >> 4) & 0xF,
+				 ((otp >> 8) & 0xF) - 1 + 'A',
+				 otp & 0xF);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_GADGET_DOWNLOAD
+#define STM32MP1_G_DNL_DFU_PRODUCT_NUM 0xdf11
+#define STM32MP1_G_DNL_FASTBOOT_PRODUCT_NUM 0x0afb
+
+int g_dnl_bind_fixup(struct usb_device_descriptor *dev, const char *name)
+{
+	if (IS_ENABLED(CONFIG_DFU_OVER_USB) &&
+	    !strcmp(name, "usb_dnl_dfu"))
+		put_unaligned(STM32MP1_G_DNL_DFU_PRODUCT_NUM, &dev->idProduct);
+	else if (IS_ENABLED(CONFIG_FASTBOOT) &&
+		 !strcmp(name, "usb_dnl_fastboot"))
+		put_unaligned(STM32MP1_G_DNL_FASTBOOT_PRODUCT_NUM,
+			      &dev->idProduct);
+	else
+		put_unaligned(CONFIG_USB_GADGET_PRODUCT_NUM, &dev->idProduct);
+
+	return 0;
+}
+#endif /* CONFIG_USB_GADGET_DOWNLOAD */
+
+/* touchscreen driver: only used for pincontrol configuration */
+static const struct udevice_id touchscreen_ids[] = {
+	{ .compatible = "ilitek,ili251x", },
+	{ }
+};
+
+U_BOOT_DRIVER(touchscreen) = {
+	.name		= "touchscreen",
+	.id		= UCLASS_I2C_GENERIC,
+	.of_match	= touchscreen_ids,
+};
+
+static int i2c_read(ofnode node, u16 reg, u8 *buf, int len, uint wlen)
+{
+	ofnode bus_node;
+	struct udevice *dev;
+	struct udevice *bus;
+	struct i2c_msg msgs[2];
+	u32 chip_addr;
+	__be16 wbuf;
+	int ret;
+
+	/* parent should be an I2C bus */
+	bus_node = ofnode_get_parent(node);
+	ret = uclass_get_device_by_ofnode(UCLASS_I2C, bus_node, &bus);
+	if (ret) {
+		log_debug("can't find I2C bus for node %s\n", ofnode_get_name(bus_node));
+		return ret;
+	}
+
+	ret = ofnode_read_u32(node, "reg", &chip_addr);
+	if (ret) {
+		log_debug("can't read I2C address in %s\n", ofnode_get_name(node));
+		return ret;
+	}
+
+	ret = dm_i2c_probe(bus, chip_addr, 0, &dev);
+	if (ret)
+		return false;
+
+	if (wlen == 2)
+		wbuf = cpu_to_be16(reg);
+	else
+		wbuf = reg;
+
+	msgs[0].flags = 0;
+	msgs[0].addr  = chip_addr;
+	msgs[0].len   = wlen;
+	msgs[0].buf   = (u8 *)&wbuf;
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr  = chip_addr;
+	msgs[1].len   = len;
+	msgs[1].buf   = buf;
+
+	ret = dm_i2c_xfer(dev, msgs, 2);
+
+	return ret;
+}
+
+static bool reset_gpio(ofnode node)
+{
+	struct gpio_desc reset_gpio;
+
+	gpio_request_by_name_nodev(node, "reset-gpios", 0, &reset_gpio, GPIOD_IS_OUT);
+
+	if (!dm_gpio_is_valid(&reset_gpio))
+		return false;
+
+	dm_gpio_set_value(&reset_gpio, true);
+	mdelay(1);
+	dm_gpio_set_value(&reset_gpio, false);
+	mdelay(10);
+
+	dm_gpio_free(NULL, &reset_gpio);
+
+	return true;
+}
+
+/* HELPER: search detected driver */
+struct detect_info_t {
+	bool (*detect)(void);
+	char *compatible;
+};
+
+static const char *detect_device(const struct detect_info_t *info, u8 size)
+{
+	u8 i;
+
+	for (i = 0; i < size; i++) {
+		if (info[i].detect())
+			return info[i].compatible;
+	}
+
+	return NULL;
+}
+
+bool detect_stm32mp25x_etml0700zxxdha(void)
+{
+	ofnode node;
+	char id[ILITEK_ID_LEN];
+	int ret;
+
+	node = ofnode_by_compatible(ofnode_null(), "ilitek,ili251x");
+	if (!ofnode_valid(node))
+		return false;
+
+	if (!reset_gpio(node))
+		return false;
+
+	mdelay(200);
+
+	ret = i2c_read(node, ILITEK_REG_ID, id, sizeof(id), 1);
+	if (ret)
+		return false;
+
+	/* FW panel ID is starting at the 4th byte */
+	if (!strncmp(&id[4], "WSV", sizeof(id) - 4))
+		return true;
+
+	return false;
+}
+
+bool detect_stm32mp25x_adv753x(void)
+{
+	ofnode node;
+	char id[ADV7511_CHIP_REVISION_LEN];
+
+	node = ofnode_by_compatible(ofnode_null(),  "adi,adv7533");
+	if (!ofnode_valid(node)) {
+		node = ofnode_by_compatible(ofnode_null(),  "adi,adv7535");
+		if (!ofnode_valid(node))
+			return false;
+	}
+
+	if (!reset_gpio(node))
+		return false;
+
+	mdelay(10);
+
+	i2c_read(node, ADV7511_REG_CHIP_REVISION, id, sizeof(id), 1);
+
+	if (id[0] == 0x14)
+		return true;
+
+	return false;
+}
+
+static const struct detect_info_t stm32mp25x_panels[] = {
+	{
+		.detect = detect_stm32mp25x_etml0700zxxdha,
+		.compatible = "edt,etml0700z9ndha",
+	},
+};
+
+static const struct detect_info_t stm32mp25x_bridges[] = {
+	{
+		.detect = detect_stm32mp25x_adv753x,
+		.compatible = "adi,adv7533",
+	},
+	{
+		.detect = detect_stm32mp25x_adv753x,
+		.compatible = "adi,adv7535",
+	},
+};
+
+static void board_stm32mp25x_eval_init(void)
+{
+	const char *compatible;
+	struct udevice *dev;
+	ofnode node;
+
+	/* auto detection of connected panels */
+	compatible = detect_device(stm32mp25x_panels, ARRAY_SIZE(stm32mp25x_panels));
+
+	if (!compatible) {
+		/* remove the panel in environment */
+		env_set("panel", "");
+
+		/* no panel detected then unbind lvds to avoid a bad clock tree */
+		node = ofnode_by_compatible(ofnode_null(), "st,stm32mp25-lvds");
+		if (!ofnode_valid(node))
+			return;
+
+		device_find_global_by_ofnode(node, &dev);
+		device_remove(dev, DM_REMOVE_NORMAL);
+		device_unbind(dev);
+	} else {
+		/* save the detected compatible in environment */
+		env_set("panel", compatible);
+	}
+
+	/* auto detection of connected hdmi bridge */
+	compatible = detect_device(stm32mp25x_bridges, ARRAY_SIZE(stm32mp25x_bridges));
+
+	if (!compatible)
+		/* remove the hdmi bridge in environment */
+		env_set("hdmi", "");
+	else
+		/* save the detected compatible in environment */
+		env_set("hdmi", compatible);
+}
+
+static void board_stm32mp25x_disco_init(void)
+{
+	const char *compatible;
+	struct udevice *dev;
+	ofnode node;
+
+	/* auto detection of connected panels */
+	compatible = detect_device(stm32mp25x_panels, ARRAY_SIZE(stm32mp25x_panels));
+
+	if (!compatible) {
+		/* remove the panel in environment */
+		env_set("panel", "");
+
+		/* no panel detected then unbind lvds to avoid a bad clock tree */
+		node = ofnode_by_compatible(ofnode_null(), "st,stm32mp25-lvds");
+		if (!ofnode_valid(node))
+			return;
+
+		device_find_global_by_ofnode(node, &dev);
+		device_remove(dev, DM_REMOVE_NORMAL);
+		device_unbind(dev);
+	} else {
+		/* save the detected compatible in environment */
+		env_set("panel", compatible);
+	}
+}
+
+static int get_led(struct udevice **dev, char *led_string)
+{
+	const char *led_name;
+	int ret;
+
+	led_name = ofnode_conf_read_str(led_string);
+	if (!led_name) {
+		log_debug("could not find %s config string\n", led_string);
+		return -ENOENT;
+	}
+	ret = led_get_by_label(led_name, dev);
+	if (ret) {
+		log_debug("get=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int setup_led(enum led_state_t cmd)
+{
+	struct udevice *dev;
+	int ret;
+
+	if (!CONFIG_IS_ENABLED(LED))
+		return 0;
+
+	ret = get_led(&dev, "u-boot,boot-led");
+	if (ret)
+		return ret;
+
+	ret = led_set_state(dev, cmd);
+	return ret;
+}
+
+static void check_user_button(void)
+{
+	struct udevice *button1 = NULL, *button2 = NULL;
+	enum forced_boot_mode boot_mode = BOOT_NORMAL;
+
+	if (!IS_ENABLED(CONFIG_BUTTON))
+		return;
+
+	if (!IS_ENABLED(CONFIG_FASTBOOT) && !IS_ENABLED(CONFIG_CMD_STM32PROG))
+		return;
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG))
+		button_get_by_label("User-1", &button1);
+
+	if (IS_ENABLED(CONFIG_FASTBOOT))
+		button_get_by_label("User-2", &button2);
+
+	if (!button1 && !button2)
+		return;
+
+	if (button2 && button_get_state(button2) == BUTTON_ON) {
+		log_notice("Fastboot key pressed, ");
+		boot_mode = BOOT_FASTBOOT;
+	}
+
+	if (button1 && button_get_state(button1) == BUTTON_ON) {
+		log_notice("STM32Programmer key pressed, ");
+		boot_mode = BOOT_STM32PROG;
+	}
+
+	if (boot_mode != BOOT_NORMAL) {
+		log_notice("entering download mode...\n");
+		clrsetbits_le32(TAMP_BOOT_CONTEXT, TAMP_BOOT_FORCED_MASK,
+				boot_mode);
+	}
+}
+
+static bool board_is_stm32mp257_eval(void)
+{
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP25X) &&
+	    (of_machine_is_compatible("st,stm32mp257f-ev1")))
+		return true;
+
+	return false;
+}
+
+static bool board_is_stm32mp257_disco(void)
+{
+	if (CONFIG_IS_ENABLED(TARGET_ST_STM32MP25X) &&
+	    (of_machine_is_compatible("st,stm32mp257f-dk")))
+		return true;
+
+	return false;
+}
+
+/* board dependent setup after realloc */
+int board_init(void)
+{
+	setup_led(LEDST_ON);
+
+	check_user_button();
+
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+	efi_guid_t image_type_guid = STM32MP_FIP_IMAGE_GUID;
+
+	guidcpy(&fw_images[0].image_type_id, &image_type_guid);
+	fw_images[0].fw_name = u"STM32MP-FIP";
+	fw_images[0].image_index = 1;
+#endif
+
+	return 0;
+}
+
+/* eth init function : weak called in eqos driver */
+int board_interface_eth_init(struct udevice *dev,
+			     phy_interface_t interface_type, ulong rate)
+{
+	struct regmap *regmap;
+	uint regmap_mask, regmap_offset;
+	int ret;
+	u32 value;
+	bool ext_phyclk;
+
+	/* Ethernet PHY have no cristal or need to be clock by RCC */
+	ext_phyclk = dev_read_bool(dev, "st,ext-phyclk");
+
+	regmap = syscon_regmap_lookup_by_phandle(dev,"st,syscon");
+
+	if (!IS_ERR(regmap)) {
+		u32 fmp[3];
+
+		ret = dev_read_u32_array(dev, "st,syscon", fmp, 3);
+		if (ret) {
+			pr_err("%s: Need to specify Offset and Mask of syscon register\n", __func__);
+			return ret;
+		}
+		else {
+			regmap_mask = fmp[2];
+			regmap_offset = fmp[1];
+		}
+	} else
+		return -ENODEV;
+
+	switch (interface_type) {
+	case PHY_INTERFACE_MODE_MII:
+		value = SYSCFG_ETHCR_ETH_SEL_MII;
+		debug("%s: PHY_INTERFACE_MODE_MII\n", __func__);
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		if ((rate == ETH_CK_F_50M) && ext_phyclk)
+			value = SYSCFG_ETHCR_ETH_SEL_RMII |
+				SYSCFG_ETHCR_ETH_REF_CLK_SEL;
+		else
+			value = SYSCFG_ETHCR_ETH_SEL_RMII;
+		debug("%s: PHY_INTERFACE_MODE_RMII\n", __func__);
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+		if ((rate == ETH_CK_F_125M) && ext_phyclk)
+			value = SYSCFG_ETHCR_ETH_SEL_RGMII |
+				SYSCFG_ETHCR_ETH_CLK_SEL;
+		else
+			value = SYSCFG_ETHCR_ETH_SEL_RGMII;
+		debug("%s: PHY_INTERFACE_MODE_RGMII\n", __func__);
+		break;
+	default:
+		debug("%s: Do not manage %d interface\n",
+		      __func__, interface_type);
+		/* Do not manage others interfaces */
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(regmap, regmap_offset, regmap_mask, value);
+
+	return ret;
+}
+
+enum env_location env_get_location(enum env_operation op, int prio)
+{
+	u32 bootmode = get_bootmode();
+
+	if (prio)
+		return ENVL_UNKNOWN;
+
+	switch (bootmode & TAMP_BOOT_DEVICE_MASK) {
+	case BOOT_FLASH_SD:
+	case BOOT_FLASH_EMMC:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_MMC))
+			return ENVL_MMC;
+		else
+			return ENVL_NOWHERE;
+
+	case BOOT_FLASH_NAND:
+	case BOOT_FLASH_SPINAND:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_UBI))
+			return ENVL_UBI;
+		else
+			return ENVL_NOWHERE;
+
+	case BOOT_FLASH_NOR:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_SPI_FLASH))
+			return ENVL_SPI_FLASH;
+		else
+			return ENVL_NOWHERE;
+
+	case BOOT_FLASH_HYPERFLASH:
+		if (CONFIG_IS_ENABLED(ENV_IS_IN_FLASH))
+			return ENVL_FLASH;
+		else
+			return ENVL_NOWHERE;
+
+	default:
+		return ENVL_NOWHERE;
+	}
+}
+
+int mmc_get_boot(void)
+{
+	struct udevice *dev;
+	u32 boot_mode = get_bootmode();
+	unsigned int instance = (boot_mode & TAMP_BOOT_INSTANCE_MASK) - 1;
+	char cmd[20];
+	const u32 sdmmc_addr[] = {
+		STM32_SDMMC1_BASE,
+		STM32_SDMMC2_BASE,
+		STM32_SDMMC3_BASE
+	};
+
+	if (instance > ARRAY_SIZE(sdmmc_addr))
+		return 0;
+
+	/* search associated sdmmc node in devicetree */
+	snprintf(cmd, sizeof(cmd), "mmc@%x", sdmmc_addr[instance]);
+	if (uclass_get_device_by_name(UCLASS_MMC, cmd, &dev)) {
+		log_err("mmc%d = %s not found in device tree!\n", instance, cmd);
+		return 0;
+	}
+
+	return dev_seq(dev);
+};
+
+int mmc_get_env_dev(void)
+{
+	const int mmc_env_dev = CONFIG_IS_ENABLED(ENV_IS_IN_MMC, (CONFIG_SYS_MMC_ENV_DEV), (-1));
+
+	if (mmc_env_dev >= 0)
+		return mmc_env_dev;
+
+	/* use boot instance to select the correct mmc device identifier */
+	return mmc_get_boot();
+}
+
+int board_late_init(void)
+{
+	const void *fdt_compat;
+	int fdt_compat_len;
+	char dtb_name[256];
+	int buf_len;
+
+	if (board_is_stm32mp257_eval())
+		board_stm32mp25x_eval_init();
+
+	if (board_is_stm32mp257_disco())
+		board_stm32mp25x_disco_init();
+
+	if (IS_ENABLED(CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG)) {
+		fdt_compat = fdt_getprop(gd->fdt_blob, 0, "compatible",
+					 &fdt_compat_len);
+		if (fdt_compat && fdt_compat_len) {
+			if (strncmp(fdt_compat, "st,", 3) != 0) {
+				env_set("board_name", fdt_compat);
+			} else {
+				env_set("board_name", fdt_compat + 3);
+
+				buf_len = sizeof(dtb_name);
+				strncpy(dtb_name, fdt_compat + 3, buf_len);
+				buf_len -= strlen(fdt_compat + 3);
+				strncat(dtb_name, ".dtb", buf_len);
+				env_set("fdtfile", dtb_name);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int fixup_stm32mp257_eval_panel(void *blob)
+{
+	char const *panel = env_get("panel");
+	char const *hdmi = env_get("hdmi");
+	bool detect_etml0700z9ndha = false;
+	bool detect_adv753x = false;
+	int nodeoff = 0, ret;
+	enum fdt_status status;
+
+	if (panel)
+		detect_etml0700z9ndha = !strcmp(panel, "edt,etml0700z9ndha");
+
+	if (hdmi)
+		/* string compare the hdmi compatible limit to 10 chars (adi,adv753) */
+		detect_adv753x = !strncmp(hdmi, "adi,adv753x", 10);
+
+	/* update LVDS panel "edt,etml0700z9ndha" */
+	status = detect_etml0700z9ndha ? FDT_STATUS_OKAY : FDT_STATUS_DISABLED;
+	nodeoff = fdt_set_status_by_compatible(blob, "edt,etml0700z9ndha", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "ilitek,ili251x", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_pathf(blob, status, "/panel-lvds-backlight");
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "st,stm32mp25-lvds", status);
+	if (nodeoff < 0)
+		return nodeoff;
+
+	/* update HDMI bridge "adi,adv753x" */
+	status = detect_adv753x ? FDT_STATUS_OKAY : FDT_STATUS_DISABLED;
+	nodeoff = fdt_set_status_by_compatible(blob, "adi,adv7533", status);
+	if (nodeoff < 0)
+		nodeoff = fdt_set_status_by_compatible(blob, "adi,adv7535", status);
+	/* Do not force disable status for sound card. Keep default status instead */
+	if (status == FDT_STATUS_OKAY) {
+		if (nodeoff < 0)
+			return nodeoff;
+		nodeoff = fdt_node_offset_by_compat_reg(blob, "st,stm32mp25-i2s", 0x400b0000);
+		if (nodeoff < 0)
+			return nodeoff;
+		ret = fdt_set_node_status(blob, nodeoff, status);
+		if (ret < 0)
+			return ret;
+		nodeoff = fdt_set_status_by_pathf(blob, status, "/sound");
+		if (nodeoff < 0)
+			return nodeoff;
+		nodeoff = fdt_status_okay_by_compatible(blob, "st,stm32mp25-dsi");
+		if (nodeoff < 0)
+			return nodeoff;
+	}
+
+	if (!detect_adv753x && !detect_etml0700z9ndha) {
+		nodeoff = fdt_status_disabled_by_compatible(blob, "st,stm32mp25-ltdc");
+		if (nodeoff < 0)
+			return nodeoff;
+	}
+
+	return 0;
+}
+
+static int fixup_stm32mp257_disco_panel(void *blob)
+{
+	char const *panel = env_get("panel");
+	bool detect_etml0700z9ndha = false;
+	int nodeoff = 0;
+	enum fdt_status status;
+
+	if (panel)
+		detect_etml0700z9ndha = !strcmp(panel, "edt,etml0700z9ndha");
+
+	/* update LVDS panel "edt,etml0700z9ndha" */
+	status = detect_etml0700z9ndha ? FDT_STATUS_OKAY : FDT_STATUS_DISABLED;
+	nodeoff = fdt_set_status_by_compatible(blob, "edt,etml0700z9ndha", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "ilitek,ili251x", status);
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_pathf(blob, status, "/panel-lvds-backlight");
+	if (nodeoff < 0)
+		return nodeoff;
+	nodeoff = fdt_set_status_by_compatible(blob, "st,stm32mp25-lvds", status);
+	if (nodeoff < 0)
+		return nodeoff;
+
+	return 0;
+}
+
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	int ret;
+
+	fdt_copy_fixed_partitions(blob);
+
+	if (CONFIG_IS_ENABLED(FDT_SIMPLEFB))
+		fdt_simplefb_enable_and_mem_rsv(blob);
+
+	if (board_is_stm32mp257_eval()) {
+		ret = fixup_stm32mp257_eval_panel(blob);
+		if (ret)
+			log_err("Error during panel fixup ! (%d)\n", ret);
+	}
+
+	if (board_is_stm32mp257_disco()) {
+		ret = fixup_stm32mp257_disco_panel(blob);
+		if (ret)
+			log_err("Error during panel fixup ! (%d)\n", ret);
+	}
+
+	return 0;
+}
+
+void board_quiesce_devices(void)
+{
+	setup_led(LEDST_OFF);
+}
+
+#if defined(CONFIG_USB_DWC3) && defined(CONFIG_CMD_STM32PROG_USB)
+#include <dfu.h>
+/*
+ * TEMP: force USB BUS reset forced to false, because it is not supported
+ *       in DWC3 USB driver
+ * avoid USB bus reset support in DFU stack is required to reenumeration in
+ * stm32prog command after flashlayout load or after "dfu-util -e -R"
+ */
+bool dfu_usb_get_reset(void)
+{
+	return false;
+}
+#endif
+
+#if defined(CONFIG_STM32_HYPERBUS)
+/* weak function called from common/board_r.c */
+int is_flash_available(void)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MTD,
+					  DM_DRIVER_GET(stm32_hyperbus),
+					  &dev);
+	if (ret)
+		return 0;
+
+	return 1;
+}
+#endif
+
+/* weak function called from env/sf.c */
+void *env_sf_get_env_addr(void)
+{
+	return NULL;
+}
+
+#if defined(CONFIG_OF_BOARD_FIXUP)
+
+int fdt_update_fwu_properties(void *blob, int nodeoff,
+			      const char *compat_str,
+			      const char *storage_path)
+{
+	int ret;
+	int storage_off;
+
+	ret = fdt_increase_size(blob, 100);
+	if (ret) {
+		printf("fdt_increase_size: err=%s\n", fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "compatible", compat_str);
+	if (ret) {
+		log_err("Can't set compatible property\n");
+		return ret;
+	}
+
+	storage_off = fdt_path_offset(blob, storage_path);
+	if (storage_off < 0) {
+		log_err("Can't find %s path\n", storage_path);
+		return nodeoff;
+	}
+
+	ret = fdt_setprop_string(blob, nodeoff, "fwu-mdata-store", storage_path);
+
+	if (ret < 0)
+		log_err("Can't set fwu-mdata-store property\n");
+
+	return ret;
+}
+
+int fdt_update_fwu_mdata(void *blob)
+{
+	int nodeoff, ret = 0;
+	u32 bootmode;
+
+	nodeoff = fdt_path_offset(blob, "/fwu-mdata");
+	if (nodeoff < 0) {
+		log_info("no /fwu-mdata node ?\n");
+
+		return 0;
+	}
+
+	bootmode = get_bootmode() & TAMP_BOOT_DEVICE_MASK;
+
+	switch (bootmode) {
+	case BOOT_FLASH_SD:
+		/* sdmmc1 : nothing to do, already the default device tree configuration */
+		break;
+	case BOOT_FLASH_EMMC:
+		/* sdmmc2 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-mtd",
+						"/soc@0/rifsc@42080000/mmc@48230000");
+		break;
+
+	case BOOT_FLASH_SPINAND:
+	case BOOT_FLASH_NOR:
+		/* flash0 */
+		ret = fdt_update_fwu_properties(blob, nodeoff, "u-boot,fwu-mdata-gpt",
+						"/soc@0/ommanager@40500000/spi@40430000/flash@0");
+		break;
+	}
+
+	return ret;
+}
+
+int board_fix_fdt(void *blob)
+{
+	int ret = 0;
+
+	if (CONFIG_IS_ENABLED(FWU_MDATA) &&
+	    (board_is_stm32mp257_eval() || board_is_stm32mp257_disco()))
+		ret = fdt_update_fwu_mdata(blob);
+
+	return ret;
+}
+#endif /* CONFIG_OF_BOARD_FIXUP */
+
diff --git a/boot/pxe_utils.c b/boot/pxe_utils.c
index a364fa8bb5..5b4b8a7229 100644
--- a/boot/pxe_utils.c
+++ b/boot/pxe_utils.c
@@ -259,6 +259,7 @@ static struct pxe_label *label_create(void)
 static void label_destroy(struct pxe_label *label)
 {
 	free(label->name);
+	free(label->kernel_label);
 	free(label->kernel);
 	free(label->config);
 	free(label->append);
@@ -521,28 +522,44 @@ static int label_boot(struct pxe_context *ctx, struct pxe_label *label)
 		return 1;
 	}
 
-	if (label->initrd) {
-		ulong size;
+	if (get_relfile_envaddr(ctx, label->kernel, "kernel_addr_r",
+				NULL) < 0) {
+		printf("Skipping %s for failure retrieving kernel\n",
+		       label->name);
+		return 1;
+	}
 
+	kernel_addr = env_get("kernel_addr_r");
+	/* for FIT, append the configuration identifier */
+	if (label->config) {
+		int len = strlen(kernel_addr) + strlen(label->config) + 1;
+
+		fit_addr = malloc(len);
+		if (!fit_addr) {
+			printf("malloc fail (FIT address)\n");
+			return 1;
+		}
+		snprintf(fit_addr, len, "%s%s", kernel_addr, label->config);
+		kernel_addr = fit_addr;
+	}
+
+	/* For FIT, the label can be identical to kernel one */
+	if (label->initrd && !strcmp(label->kernel_label, label->initrd)) {
+		initrd_addr_str =  kernel_addr;
+	} else if (label->initrd) {
+		ulong size;
 		if (get_relfile_envaddr(ctx, label->initrd, "ramdisk_addr_r",
 					&size) < 0) {
 			printf("Skipping %s for failure retrieving initrd\n",
 			       label->name);
-			return 1;
+			goto cleanup;
 		}
 
 		initrd_addr_str = env_get("ramdisk_addr_r");
 		size = snprintf(initrd_str, sizeof(initrd_str), "%s:%lx",
 				initrd_addr_str, size);
 		if (size >= sizeof(initrd_str))
-			return 1;
-	}
-
-	if (get_relfile_envaddr(ctx, label->kernel, "kernel_addr_r",
-				NULL) < 0) {
-		printf("Skipping %s for failure retrieving kernel\n",
-		       label->name);
-		return 1;
+			goto cleanup;
 	}
 
 	if (label->ipappend & 0x1) {
@@ -572,7 +589,7 @@ static int label_boot(struct pxe_context *ctx, struct pxe_label *label)
 			       strlen(label->append ?: ""),
 			       strlen(ip_str), strlen(mac_str),
 			       sizeof(bootargs));
-			return 1;
+			goto cleanup;
 		}
 
 		if (label->append)
@@ -587,21 +604,6 @@ static int label_boot(struct pxe_context *ctx, struct pxe_label *label)
 		printf("append: %s\n", finalbootargs);
 	}
 
-	kernel_addr = env_get("kernel_addr_r");
-
-	/* for FIT, append the configuration identifier */
-	if (label->config) {
-		int len = strlen(kernel_addr) + strlen(label->config) + 1;
-
-		fit_addr = malloc(len);
-		if (!fit_addr) {
-			printf("malloc fail (FIT address)\n");
-			return 1;
-		}
-		snprintf(fit_addr, len, "%s%s", kernel_addr, label->config);
-		kernel_addr = fit_addr;
-	}
-
 	/*
 	 * fdt usage is optional:
 	 * It handles the following scenarios.
@@ -617,14 +619,17 @@ static int label_boot(struct pxe_context *ctx, struct pxe_label *label)
 	 * bootm, and adjust argc appropriately.
 	 *
 	 * Scenario 3: If there is an fdtcontroladdr specified, pass it along to
-	 * bootm, and adjust argc appropriately.
+	 * bootm, and adjust argc appropriately, unless the image type is fitImage.
 	 *
 	 * Scenario 4: fdt blob is not available.
 	 */
 	bootm_argv[3] = env_get("fdt_addr_r");
 
+	/* For FIT, the label can be identical to kernel one */
+	if (label->fdt && !strcmp(label->kernel_label, label->fdt)) {
+		bootm_argv[3] = kernel_addr;
 	/* if fdt label is defined then get fdt from server */
-	if (bootm_argv[3]) {
+	} else if (bootm_argv[3]) {
 		char *fdtfile = NULL;
 		char *fdtfilefree = NULL;
 
@@ -724,7 +729,10 @@ static int label_boot(struct pxe_context *ctx, struct pxe_label *label)
 	if (!bootm_argv[3])
 		bootm_argv[3] = env_get("fdt_addr");
 
-	if (!bootm_argv[3])
+	kernel_addr_r = genimg_get_kernel_addr(kernel_addr);
+	buf = map_sysmem(kernel_addr_r, 0);
+
+	if (!bootm_argv[3] && genimg_get_format(buf) != IMAGE_FORMAT_FIT)
 		bootm_argv[3] = env_get("fdtcontroladdr");
 
 	if (bootm_argv[3]) {
@@ -733,8 +741,6 @@ static int label_boot(struct pxe_context *ctx, struct pxe_label *label)
 		bootm_argc = 4;
 	}
 
-	kernel_addr_r = genimg_get_kernel_addr(kernel_addr);
-	buf = map_sysmem(kernel_addr_r, 0);
 	/* Try bootm for legacy and FIT format image */
 	if (genimg_get_format(buf) != IMAGE_FORMAT_INVALID &&
             IS_ENABLED(CONFIG_CMD_BOOTM))
@@ -1164,15 +1170,19 @@ static int parse_label_kernel(char **c, struct pxe_label *label)
 	if (err < 0)
 		return err;
 
+	/* copy the kernel label to compare with FDT / INITRD when FIT is used */
+	label->kernel_label = strdup(label->kernel);
+	if (!label->kernel_label)
+		return -ENOMEM;
+
 	s = strstr(label->kernel, "#");
 	if (!s)
 		return 1;
 
-	label->config = malloc(strlen(s) + 1);
+	label->config = strdup(s);
 	if (!label->config)
 		return -ENOMEM;
 
-	strcpy(label->config, s);
 	*s = 0;
 
 	return 1;
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 0e0be94f41..f825b1ad1c 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -161,6 +161,12 @@ config CMD_CPU
 	  internal name) and clock frequency. Other information may be
 	  available depending on the CPU driver.
 
+config CMD_FWU_METADATA
+	bool "fwu metadata read"
+	depends on FWU_MULTI_BANK_UPDATE
+	help
+	  Command to read the metadata and dump it's contents
+
 config CMD_LICENSE
 	bool "license"
 	select BUILD_BIN2C
@@ -2450,6 +2456,7 @@ config CMD_MTDPARTS_SHOW_NET_SIZES
 config MTDIDS_DEFAULT
 	string "Default MTD IDs"
 	depends on MTD || SPI_FLASH
+	depends on !SYS_MTDPARTS_RUNTIME
 	help
 	  Defines a default MTD IDs list for use with MTD partitions in the
 	  Linux MTD command line partitions format.
@@ -2457,6 +2464,7 @@ config MTDIDS_DEFAULT
 config MTDPARTS_DEFAULT
 	string "Default MTD partition scheme"
 	depends on MTD || SPI_FLASH
+	depends on !SYS_MTDPARTS_RUNTIME
 	help
 	  Defines a default MTD partitioning scheme in the Linux MTD command
 	  line partitions format
diff --git a/cmd/Makefile b/cmd/Makefile
index 6e87522b62..ff6e160f4a 100644
--- a/cmd/Makefile
+++ b/cmd/Makefile
@@ -76,6 +76,7 @@ obj-$(CONFIG_CMD_FPGA) += fpga.o
 obj-$(CONFIG_CMD_FPGAD) += fpgad.o
 obj-$(CONFIG_CMD_FS_GENERIC) += fs.o
 obj-$(CONFIG_CMD_FUSE) += fuse.o
+obj-$(CONFIG_CMD_FWU_METADATA) += fwu_mdata.o
 obj-$(CONFIG_CMD_GETTIME) += gettime.o
 obj-$(CONFIG_CMD_GPIO) += gpio.o
 obj-$(CONFIG_CMD_HVC) += smccc.o
diff --git a/cmd/clk.c b/cmd/clk.c
index a483fd8981..a12b8d2ac6 100644
--- a/cmd/clk.c
+++ b/cmd/clk.c
@@ -22,14 +22,14 @@ static void show_clks(struct udevice *dev, int depth, int last_flag)
 	u32 rate;
 
 	clkp = dev_get_clk_ptr(dev);
-	if (device_get_uclass_id(dev) == UCLASS_CLK && clkp) {
+	if (clkp) {
 		parent = clk_get_parent(clkp);
 		if (!IS_ERR(parent) && depth == -1)
 			return;
 		depth++;
 		rate = clk_get_rate(clkp);
 
-		printf(" %-12u  %8d        ", rate, clkp->enable_count);
+		printf(" %-12u  %8lx  %8d        ", rate, clkp->id, clkp->enable_count);
 
 		for (i = depth; i >= 0; i--) {
 			is_last = (last_flag >> i) & 1;
@@ -49,10 +49,11 @@ static void show_clks(struct udevice *dev, int depth, int last_flag)
 		printf("%s\n", dev->name);
 	}
 
-	list_for_each_entry(child, &dev->child_head, sibling_node) {
+	device_foreach_child_probe(child, dev) {
+		if (device_get_uclass_id(child) != UCLASS_CLK)
+			continue;
 		if (child == dev)
 			continue;
-
 		is_last = list_is_last(&child->sibling_node, &dev->child_head);
 		show_clks(child, depth, (last_flag << 1) | is_last);
 	}
@@ -61,17 +62,11 @@ static void show_clks(struct udevice *dev, int depth, int last_flag)
 int __weak soc_clk_dump(void)
 {
 	struct udevice *dev;
-	struct uclass *uc;
-	int ret;
-
-	ret = uclass_get(UCLASS_CLK, &uc);
-	if (ret)
-		return ret;
 
-	printf(" Rate               Usecnt      Name\n");
-	printf("------------------------------------------\n");
+	printf(" Rate             Id          Usecnt      Name\n");
+	printf("--------------------------------------------------\n");
 
-	uclass_foreach_dev(dev, uc)
+	uclass_foreach_dev_probe(UCLASS_CLK, dev)
 		show_clks(dev, -1, 0);
 
 	return 0;
diff --git a/cmd/fwu_mdata.c b/cmd/fwu_mdata.c
new file mode 100644
index 0000000000..3c8be576ac
--- /dev/null
+++ b/cmd/fwu_mdata.c
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#include <command.h>
+#include <dm.h>
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <linux/types.h>
+
+static void print_mdata(struct fwu_data *data)
+{
+	int i, j;
+	struct fwu_image_entry *img_entry;
+	struct fwu_image_bank_info *img_info;
+
+	printf("\tFWU Metadata\n");
+	printf("crc32: %#x\n", data->crc32);
+	printf("version: %#x\n", data->version);
+	printf("active_index: %#x\n", data->active_index);
+	printf("previous_active_index: %#x\n", data->previous_active_index);
+
+	if (data->version == 2) {
+		for (i = 0; i < 4; i++)
+			printf("bank_state[%d]: %#x\n",
+			       i, data->bank_state[i]);
+	}
+
+	printf("\tImage Info\n");
+	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
+		img_entry = &data->fwu_images[i];
+		printf("\nImage Type Guid: %pUL\n",
+		       &img_entry->image_type_guid);
+		printf("Location Guid: %pUL\n", &img_entry->location_guid);
+		for (j = 0; j < CONFIG_FWU_NUM_BANKS; j++) {
+			img_info = &img_entry->img_bank_info[j];
+			printf("Image Guid:  %pUL\n", &img_info->image_guid);
+			printf("Image Acceptance: %s\n",
+			       img_info->accepted == 0x1 ? "yes" : "no");
+		}
+	}
+}
+
+int do_fwu_mdata_read(struct cmd_tbl *cmdtp, int flag,
+		     int argc, char * const argv[])
+{
+	struct fwu_data *data = fwu_get_data();
+
+	print_mdata(data);
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	fwu_mdata_read,	1,	1,	do_fwu_mdata_read,
+	"Read and print FWU metadata",
+	""
+);
diff --git a/cmd/gpt.c b/cmd/gpt.c
index 007a68eaa7..e6f7b0319a 100644
--- a/cmd/gpt.c
+++ b/cmd/gpt.c
@@ -1060,8 +1060,6 @@ U_BOOT_CMD(gpt, CONFIG_SYS_MAXARGS, 1, do_gpt,
 	"      gpt_partition_name, gpt_partition_entry\n"
 	" gpt enumerate mmc 0\n"
 	"    - store list of partitions to gpt_partition_list environment variable\n"
-	" read <interface> <dev>\n"
-	"    - read GPT into a data structure for manipulation\n"
 	" gpt guid <interface> <dev>\n"
 	"    - print disk GUID\n"
 	" gpt guid <interface> <dev> <varname>\n"
diff --git a/cmd/legacy-mtd-utils.c b/cmd/legacy-mtd-utils.c
index ac7139f84d..5c86063bbc 100644
--- a/cmd/legacy-mtd-utils.c
+++ b/cmd/legacy-mtd-utils.c
@@ -1,44 +1,66 @@
 // SPDX-License-Identifier: GPL-2.0+
 
 #include <common.h>
-#include <jffs2/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/string.h>
 #include <mtd.h>
 
-static int get_part(const char *partname, int *idx, loff_t *off, loff_t *size,
-	     loff_t *maxsize, int devtype)
+/* mapping between legacy parameter and MTD device type */
+bool check_devtype(int devtype, u_char mtdtype)
 {
-#ifdef CONFIG_CMD_MTDPARTS
-	struct mtd_device *dev;
-	struct part_info *part;
-	u8 pnum;
-	int ret;
+	if (devtype == MTD_DEV_TYPE_NOR && mtdtype == MTD_NORFLASH)
+		return true;
 
-	ret = mtdparts_init();
-	if (ret)
-		return ret;
+	if ((devtype == MTD_DEV_TYPE_NAND || devtype == MTD_DEV_TYPE_ONENAND) &&
+	    (mtdtype == MTD_NANDFLASH || mtdtype == MTD_NANDFLASH))
+		return true;
+
+	return false;
+}
 
-	ret = find_dev_and_part(partname, &dev, &pnum, &part);
-	if (ret)
-		return ret;
 
-	if (dev->id->type != devtype) {
-		printf("not same typ %d != %d\n", dev->id->type, devtype);
+static int get_part(const char *partname, int *idx, loff_t *off, loff_t *size,
+		    loff_t *maxsize, int devtype)
+{
+	struct mtd_info *mtd;
+	struct mtd_info *partition;
+	bool part_found = false;
+	int part_num;
+
+	if (!IS_ENABLED(CONFIG_MTD)) {
+		puts("mtd support missing.\n");
 		return -1;
 	}
+	/* register partitions with MTDIDS/MTDPARTS or OF fallback */
+	mtd_probe_devices();
+
+	mtd_for_each_device(mtd) {
+		printf("%s:%d(%d, %s)\n", __func__, __LINE__, mtd->type, mtd->name);
+		if (mtd_is_partition(mtd) &&
+		    check_devtype(devtype, mtd->type) &&
+		    (!strcmp(partname, mtd->name))) {
+			part_found = true;
+			break;
+		}
+	}
+	if (!part_found)
+		return -1;
+
+	*off = mtd->offset;
+	*size = mtd->size;
+	*maxsize = mtd->size;
 
-	*off = part->offset;
-	*size = part->size;
-	*maxsize = part->size;
-	*idx = dev->id->num;
+	/* loop on partition list as index is not accessbile in MTD */
+	part_num = 0;
+	list_for_each_entry(partition, &mtd->parent->partitions, node) {
+		part_num++;
+		if (partition == mtd)
+			break;
+	}
 
+	*idx = part_num;
 	return 0;
-#else
-	puts("mtdparts support missing.\n");
-	return -1;
-#endif
 }
 
 int mtd_arg_off(const char *arg, int *idx, loff_t *off, loff_t *size,
diff --git a/cmd/mtdparts.c b/cmd/mtdparts.c
index bab75a262f..4936e9e51b 100644
--- a/cmd/mtdparts.c
+++ b/cmd/mtdparts.c
@@ -75,11 +75,13 @@
 #include <env.h>
 #include <log.h>
 #include <malloc.h>
+#include <mtd.h>
 #include <asm/global_data.h>
 #include <jffs2/load_kernel.h>
 #include <linux/list.h>
 #include <linux/ctype.h>
 #include <linux/err.h>
+#include <linux/sizes.h>
 #include <linux/mtd/mtd.h>
 
 #if defined(CONFIG_CMD_NAND)
@@ -131,6 +133,10 @@ extern void board_mtdparts_default(const char **mtdids, const char **mtdparts);
 static const char *mtdids_default = MTDIDS_DEFAULT;
 static const char *mtdparts_default = MTDPARTS_DEFAULT;
 
+/* default 'mtdids' and 'mtdparts' build from device tree */
+static char *mtdids_dyn;
+static char *mtdparts_dyn;
+
 /* copies of last seen 'mtdids', 'mtdparts' and 'partition' env variables */
 #define MTDIDS_MAXLEN		128
 #define MTDPARTS_MAXLEN		512
@@ -1325,8 +1331,9 @@ static void list_partitions(void)
 	}
 
 	printf("\ndefaults:\n");
-	printf("mtdids  : %s\n",
-		mtdids_default ? mtdids_default : "none");
+	printf("mtdids  : %s%s\n",
+	       mtdids_default ? mtdids_default : "none",
+	       mtdids_default == mtdids_dyn ? "(build from DT)" : "");
 	/*
 	 * Using printf() here results in printbuffer overflow
 	 * if default mtdparts string is greater than console
@@ -1334,7 +1341,7 @@ static void list_partitions(void)
 	 */
 	puts("mtdparts: ");
 	puts(mtdparts_default ? mtdparts_default : "none");
-	puts("\n");
+	puts(mtdparts_default == mtdparts_dyn ? "(build from DT)\n" : "\n");
 }
 
 /**
@@ -1713,6 +1720,55 @@ static int parse_mtdids(const char *const ids)
 	return 0;
 }
 
+/*
+ * update the variables "mtdids" and "mtdparts" for MTD device
+ */
+static void mtdparts_default_build(struct mtd_info *mtd, char *mtdids, char *mtdparts)
+{
+	struct mtd_info *part;
+	char multiplier = 'b';
+	u32 size;
+	char partition[PARTITION_MAXLEN + 20]; /* name + size + mutiliplier */
+	bool first_part;
+
+	/* mtdids: "<dev>=<dev>, ...." */
+	if (mtdids[0] != '\0')
+		strcat(mtdids, ",");
+	strcat(mtdids, mtd->name);
+	strcat(mtdids, "=");
+	strcat(mtdids, mtd->name);
+
+	/* mtdparts: "<dev>:<part1>,<part2>...,<partN>;..." */
+	if (mtdparts[0] != '\0')
+		strlcat(mtdparts, ";", MTDPARTS_MAXLEN);
+
+	strlcat(mtdparts, mtd->name, MTDPARTS_MAXLEN);
+	strlcat(mtdparts, ":", MTDPARTS_MAXLEN);
+
+	first_part = true;
+	list_for_each_entry(part, &mtd->partitions, node) {
+		if (!(part->size % SZ_1G)) {
+			size = (u32)(part->size / SZ_1G);
+			multiplier = 'g';
+		} else if (!(part->size % SZ_1M)) {
+			size = (u32)(part->size / SZ_1M);
+			multiplier = 'm';
+		} else if (!(part->size % SZ_1K)) {
+			size = (u32)(part->size / SZ_1K);
+			multiplier = 'k';
+		} else {
+			size = (u32)part->size;
+		}
+		snprintf(partition, sizeof(partition), "%d%c(%s)", size, multiplier, part->name);
+
+		if (first_part)
+			first_part = false;
+		else
+			strlcat(mtdparts, ",", MTDPARTS_MAXLEN);
+
+		strlcat(mtdparts, partition, MTDPARTS_MAXLEN);
+	}
+}
 
 /**
  * Parse and initialize global mtdids mapping and create global
@@ -1741,6 +1797,34 @@ int mtdparts_init(void)
 #endif
 		use_defaults = 1;
 		initialized = 1;
+
+		if ((!mtdids_default || !strlen(mtdids_default)) &&
+		    (!mtdparts_default || !strlen(mtdparts_default))) {
+			struct mtd_info *mtd;
+
+			mtdids_dyn = malloc(MTDIDS_MAXLEN);
+			mtdparts_dyn = malloc(MTDPARTS_MAXLEN);
+			if (!mtdids_dyn || !mtdparts_dyn) {
+				free(mtdparts_dyn);
+				printf("out of memory\n");
+				return 1;
+			}
+
+			/* used new default */
+			mtdids_dyn[0] = '\0';
+			mtdparts_dyn[0] = '\0';
+			mtdids_default = mtdids_dyn;
+			mtdparts_default = mtdparts_dyn;
+
+			/* register partitions with OF fallback */
+			mtd_probe_devices();
+
+			/* build default variable value with MTD partitions */
+			mtd_for_each_device(mtd) {
+				if (!mtd_is_partition(mtd) && mtd_has_partitions(mtd))
+					mtdparts_default_build(mtd, mtdids_dyn, mtdparts_dyn);
+			}
+		}
 	}
 
 	/* get variables */
diff --git a/common/Kconfig b/common/Kconfig
index ebee856e56..a88e5ed57e 100644
--- a/common/Kconfig
+++ b/common/Kconfig
@@ -1006,3 +1006,15 @@ config FDT_SIMPLEFB
 	  These functions can be used by board to indicate to the OS
 	  the presence of the simple frame buffer with associated reserved
 	  memory
+
+config USB_HUB_DEBOUNCE_TIMEOUT
+	int "Timeout in milliseconds for USB HUB connection"
+	depends on USB
+	default 1000
+	help
+	  Value in milliseconds of the USB connection timeout, the max delay to
+	  wait the hub port status to be connected steadily after being powered
+	  off and powered on in the usb hub driver.
+	  This define allows to increase the HUB_DEBOUNCE_TIMEOUT default
+	  value = 1s because some usb device needs around 1.5s to be initialized
+	  and a 2s value should solve detection issue on problematic USB keys.
diff --git a/common/Makefile b/common/Makefile
index 2ed8672c3a..56f060aa72 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_PHYLIB) += miiphyutil.o
 obj-$(CONFIG_USB_HOST) += usb.o usb_hub.o
 obj-$(CONFIG_USB_GADGET) += usb.o usb_hub.o
 obj-$(CONFIG_USB_STORAGE) += usb_storage.o
+obj-$(CONFIG_USB_ONBOARD_HUB) += usb_onboard_hub.o
 
 # others
 obj-$(CONFIG_CONSOLE_MUX) += iomux.o
diff --git a/common/board_r.c b/common/board_r.c
index 00926dcb1e..3559f15249 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -576,6 +576,9 @@ static int run_main_loop(void)
 #ifdef CONFIG_SANDBOX
 	sandbox_main_loop_init();
 #endif
+
+	event_notify_null(EVT_MAIN_LOOP);
+
 	/* main_loop() can return to retry autoboot, if so just run it again */
 	for (;;)
 		main_loop();
@@ -750,9 +753,6 @@ static init_fnc_t init_sequence_r[] = {
 	initr_status_led,
 #endif
 	/* PPC has a udelay(20) here dating from 2002. Why? */
-#if defined(CONFIG_GPIO_HOG)
-	gpio_hog_probe_all,
-#endif
 #ifdef CONFIG_BOARD_LATE_INIT
 	board_late_init,
 #endif
diff --git a/common/event.c b/common/event.c
index 3e34550978..231b9e6ffd 100644
--- a/common/event.c
+++ b/common/event.c
@@ -38,6 +38,9 @@ const char *const type_name[] = {
 
 	/* fdt hooks */
 	"ft_fixup",
+
+	/* main loop events */
+	"main_loop",
 };
 
 _Static_assert(ARRAY_SIZE(type_name) == EVT_COUNT, "event type_name size");
diff --git a/common/fdt_support.c b/common/fdt_support.c
index baf7fb7065..890c8383ee 100644
--- a/common/fdt_support.c
+++ b/common/fdt_support.c
@@ -13,6 +13,7 @@
 #include <mapmem.h>
 #include <net.h>
 #include <stdio_dev.h>
+#include <dm/ofnode.h>
 #include <linux/ctype.h>
 #include <linux/types.h>
 #include <asm/global_data.h>
@@ -1050,6 +1051,79 @@ void fdt_fixup_mtdparts(void *blob, const struct node_info *node_info,
 }
 #endif
 
+int fdt_copy_fixed_partitions(void *blob)
+{
+	ofnode node, subnode;
+	int off, suboff, res;
+	char path[256];
+	int address_cells, size_cells;
+	u8 i, j, child_count;
+
+	node = ofnode_by_compatible(ofnode_null(), "fixed-partitions");
+	while (ofnode_valid(node)) {
+		/* copy the U-Boot fixed partition */
+		address_cells = ofnode_read_simple_addr_cells(node);
+		size_cells = ofnode_read_simple_size_cells(node);
+
+		res = ofnode_get_path(ofnode_get_parent(node), path, sizeof(path));
+		if (res)
+			return res;
+
+		off = fdt_path_offset(blob, path);
+		if (off < 0)
+			return -ENODEV;
+
+		off = fdt_find_or_add_subnode(blob, off, "partitions");
+		res = fdt_setprop_string(blob, off, "compatible", "fixed-partitions");
+		if (res)
+			return res;
+
+		res = fdt_setprop_u32(blob, off, "#address-cells", address_cells);
+		if (res)
+			return res;
+
+		res = fdt_setprop_u32(blob, off, "#size-cells", size_cells);
+		if (res)
+			return res;
+
+		/*
+		 * parse partition in reverse order as fdt_find_or_add_subnode() only
+		 * insert the new node after the parent's properties
+		 */
+		child_count = ofnode_get_child_count(node);
+		for (i = child_count; i > 0 ; i--) {
+			subnode = ofnode_first_subnode(node);
+			if (!ofnode_valid(subnode))
+				break;
+
+			for (j = 0; (j < i - 1); j++)
+				subnode = ofnode_next_subnode(subnode);
+
+			if (!ofnode_valid(subnode))
+				break;
+
+			const u32 *reg;
+			int len;
+
+			suboff = fdt_find_or_add_subnode(blob, off, ofnode_get_name(subnode));
+			res = fdt_setprop_string(blob, suboff, "label",
+						 ofnode_read_string(subnode, "label"));
+			if (res)
+				return res;
+
+			reg = ofnode_get_property(subnode, "reg", &len);
+			res = fdt_setprop(blob, suboff, "reg", reg, len);
+			if (res)
+				return res;
+		}
+
+		/* go to next fixed-partitions node */
+		node = ofnode_by_compatible(node, "fixed-partitions");
+	}
+
+	return 0;
+}
+
 void fdt_del_node_and_alias(void *blob, const char *alias)
 {
 	int off = fdt_path_offset(blob, alias);
@@ -1065,7 +1139,6 @@ void fdt_del_node_and_alias(void *blob, const char *alias)
 
 /* Max address size we deal with */
 #define OF_MAX_ADDR_CELLS	4
-#define OF_BAD_ADDR	FDT_ADDR_T_NONE
 #define OF_CHECK_COUNTS(na, ns)	((na) > 0 && (na) <= OF_MAX_ADDR_CELLS && \
 			(ns) > 0)
 
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 29e0898f03..683e0dfc52 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -770,9 +770,6 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 		}
 	}
 
-	if (CONFIG_IS_ENABLED(GPIO_HOG))
-		gpio_hog_probe_all();
-
 #if CONFIG_IS_ENABLED(BOARD_INIT)
 	spl_board_init();
 #endif
diff --git a/common/usb_hub.c b/common/usb_hub.c
index d73638950b..87fd93c55d 100644
--- a/common/usb_hub.c
+++ b/common/usb_hub.c
@@ -47,7 +47,7 @@
 #define HUB_SHORT_RESET_TIME	20
 #define HUB_LONG_RESET_TIME	200
 
-#define HUB_DEBOUNCE_TIMEOUT	1000
+#define HUB_DEBOUNCE_TIMEOUT	CONFIG_USB_HUB_DEBOUNCE_TIMEOUT
 
 #define PORT_OVERCURRENT_MAX_SCAN_COUNT		3
 
diff --git a/common/usb_onboard_hub.c b/common/usb_onboard_hub.c
new file mode 100644
index 0000000000..8a83f7877e
--- /dev/null
+++ b/common/usb_onboard_hub.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for onboard USB hubs
+ *
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * Mostly inspired by Linux kernel v6.1 onboard_usb_hub driver
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <power/regulator.h>
+
+struct onboard_hub {
+	struct udevice *vdd;
+};
+
+static int usb_onboard_hub_probe(struct udevice *dev)
+{
+	struct onboard_hub *hub = dev_get_priv(dev);
+	int ret;
+
+	ret = device_get_supply_regulator(dev, "vdd-supply", &hub->vdd);
+	if (ret) {
+		dev_err(dev, "can't get vdd-supply: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_set_enable_if_allowed(hub->vdd, true);
+	if (ret)
+		dev_err(dev, "can't enable vdd-supply: %d\n", ret);
+
+	return ret;
+}
+
+static const struct udevice_id usb_onboard_hub_ids[] = {
+	/* Use generic usbVID,PID dt-bindings (usb-device.yaml) */
+	{ .compatible = "usb424,2514" }, /* USB2514B USB 2.0 */
+	{ }
+};
+
+U_BOOT_DRIVER(usb_onboard_hub) = {
+	.name	= "usb_onboard_hub",
+	.id	= UCLASS_USB_HUB,
+	.probe = usb_onboard_hub_probe,
+	.of_match = usb_onboard_hub_ids,
+	.priv_auto = sizeof(struct onboard_hub),
+};
diff --git a/configs/corstone1000_defconfig b/configs/corstone1000_defconfig
index ed2e0fe70a..b5310dc3cf 100644
--- a/configs/corstone1000_defconfig
+++ b/configs/corstone1000_defconfig
@@ -23,6 +23,7 @@ CONFIG_LOGLEVEL=7
 CONFIG_SYS_MAXARGS=64
 CONFIG_SYS_CBSIZE=512
 # CONFIG_CMD_CONSOLE is not set
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_CMD_BOOTZ=y
 CONFIG_SYS_BOOTM_LEN=0x800000
 # CONFIG_CMD_XIMG is not set
@@ -52,3 +53,5 @@ CONFIG_DM_SERIAL=y
 CONFIG_USB=y
 CONFIG_USB_ISP1760=y
 CONFIG_ERRNO_STR=y
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V1=y
diff --git a/configs/sandbox64_defconfig b/configs/sandbox64_defconfig
index 290d1506c2..91fc94d9fd 100644
--- a/configs/sandbox64_defconfig
+++ b/configs/sandbox64_defconfig
@@ -242,9 +242,14 @@ CONFIG_LZ4=y
 CONFIG_ERRNO_STR=y
 CONFIG_EFI_RUNTIME_UPDATE_CAPSULE=y
 CONFIG_EFI_CAPSULE_ON_DISK=y
-CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
 CONFIG_EFI_SECURE_BOOT=y
 CONFIG_TEST_FDTDEC=y
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V1=y
 CONFIG_UNIT_TEST=y
 CONFIG_UT_TIME=y
 CONFIG_UT_DM=y
+CONFIG_FWU_MDATA=y
+CONFIG_FWU_MDATA_GPT_BLK=y
+CONFIG_FWU_MULTI_BANK_UPDATE=y
diff --git a/configs/stm32746g-eval_defconfig b/configs/stm32746g-eval_defconfig
index 58232a7114..7200446d28 100644
--- a/configs/stm32746g-eval_defconfig
+++ b/configs/stm32746g-eval_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xE00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32746g-eval"
diff --git a/configs/stm32746g-eval_spl_defconfig b/configs/stm32746g-eval_spl_defconfig
index a3b7146454..ff42952a76 100644
--- a/configs/stm32746g-eval_spl_defconfig
+++ b/configs/stm32746g-eval_spl_defconfig
@@ -1,8 +1,7 @@
 CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
-CONFIG_SYS_TEXT_BASE=0x08008000
+CONFIG_SYS_TEXT_BASE=0x08009000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xE00
 CONFIG_SPL_GPIO=y
 CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
@@ -13,10 +12,11 @@ CONFIG_SPL_TEXT_BASE=0x8000000
 CONFIG_SYS_PROMPT="U-Boot > "
 CONFIG_SPL_SERIAL=y
 CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL_SIZE_LIMIT=0x9000
 CONFIG_STM32F7=y
 CONFIG_TARGET_STM32F746_DISCO=y
 CONFIG_SPL=y
-CONFIG_SYS_LOAD_ADDR=0x8008000
+CONFIG_SYS_LOAD_ADDR=0x8009000
 CONFIG_BUILD_TARGET="u-boot-with-spl.bin"
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
@@ -29,13 +29,13 @@ CONFIG_USE_BOOTARGS=y
 CONFIG_BOOTARGS="console=ttyS0,115200 earlyprintk consoleblank=0 ignore_loglevel"
 # CONFIG_DISPLAY_CPUINFO is not set
 CONFIG_BOARD_LATE_INIT=y
-CONFIG_SPL_PAD_TO=0x8000
+CONFIG_SPL_PAD_TO=0x9000
 CONFIG_SPL_NO_BSS_LIMIT=y
 CONFIG_SPL_BOARD_INIT=y
 CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_MTD_SUPPORT=y
 CONFIG_SPL_XIP_SUPPORT=y
-CONFIG_SYS_SPL_ARGS_ADDR=0x81c0000
+CONFIG_SYS_SPL_ARGS_ADDR=0x80c0000
 CONFIG_SPL_DM_RESET=y
 CONFIG_SYS_PBSIZE=1050
 CONFIG_CMD_GPT=y
diff --git a/configs/stm32f429-discovery_defconfig b/configs/stm32f429-discovery_defconfig
index e6e595d495..914ac14641 100644
--- a/configs/stm32f429-discovery_defconfig
+++ b/configs/stm32f429-discovery_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x0200000
-CONFIG_SYS_MALLOC_F_LEN=0xF00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_ENV_SECT_SIZE=0x20000
diff --git a/configs/stm32f429-evaluation_defconfig b/configs/stm32f429-evaluation_defconfig
index 073f27168a..af7a8bf076 100644
--- a/configs/stm32f429-evaluation_defconfig
+++ b/configs/stm32f429-evaluation_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xF00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32429i-eval"
diff --git a/configs/stm32f469-discovery_defconfig b/configs/stm32f469-discovery_defconfig
index bd3693275e..90680fdb05 100644
--- a/configs/stm32f469-discovery_defconfig
+++ b/configs/stm32f469-discovery_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xF00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32f469-disco"
diff --git a/configs/stm32f746-disco_defconfig b/configs/stm32f746-disco_defconfig
index ed537b0578..a8edf11b40 100644
--- a/configs/stm32f746-disco_defconfig
+++ b/configs/stm32f746-disco_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xE00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32f746-disco"
diff --git a/configs/stm32f746-disco_spl_defconfig b/configs/stm32f746-disco_spl_defconfig
index e7b1acc433..0e358e86ff 100644
--- a/configs/stm32f746-disco_spl_defconfig
+++ b/configs/stm32f746-disco_spl_defconfig
@@ -1,8 +1,7 @@
 CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
-CONFIG_SYS_TEXT_BASE=0x08008000
+CONFIG_SYS_TEXT_BASE=0x08009000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xE00
 CONFIG_SPL_GPIO=y
 CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
@@ -13,10 +12,11 @@ CONFIG_SPL_TEXT_BASE=0x8000000
 CONFIG_SYS_PROMPT="U-Boot > "
 CONFIG_SPL_SERIAL=y
 CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL_SIZE_LIMIT=0x9000
 CONFIG_STM32F7=y
 CONFIG_TARGET_STM32F746_DISCO=y
 CONFIG_SPL=y
-CONFIG_SYS_LOAD_ADDR=0x8008000
+CONFIG_SYS_LOAD_ADDR=0x8009000
 CONFIG_BUILD_TARGET="u-boot-with-spl.bin"
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
@@ -29,13 +29,13 @@ CONFIG_USE_BOOTARGS=y
 CONFIG_BOOTARGS="console=ttyS0,115200 earlyprintk consoleblank=0 ignore_loglevel"
 # CONFIG_DISPLAY_CPUINFO is not set
 CONFIG_BOARD_LATE_INIT=y
-CONFIG_SPL_PAD_TO=0x8000
+CONFIG_SPL_PAD_TO=0x9000
 CONFIG_SPL_NO_BSS_LIMIT=y
 CONFIG_SPL_BOARD_INIT=y
 CONFIG_SPL_SYS_MALLOC_SIMPLE=y
 CONFIG_SPL_MTD_SUPPORT=y
 CONFIG_SPL_XIP_SUPPORT=y
-CONFIG_SYS_SPL_ARGS_ADDR=0x81c0000
+CONFIG_SYS_SPL_ARGS_ADDR=0x80c0000
 CONFIG_SPL_DM_RESET=y
 CONFIG_SYS_PBSIZE=1050
 CONFIG_CMD_GPT=y
diff --git a/configs/stm32f769-disco_defconfig b/configs/stm32f769-disco_defconfig
index 423af7446a..3e7b5bd06e 100644
--- a/configs/stm32f769-disco_defconfig
+++ b/configs/stm32f769-disco_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xE00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32f769-disco"
@@ -41,7 +40,7 @@ CONFIG_MTD=y
 CONFIG_DM_MTD=y
 CONFIG_MTD_NOR_FLASH=y
 CONFIG_STM32_FLASH=y
-CONFIG_SYS_MAX_FLASH_SECT=8
+CONFIG_SYS_MAX_FLASH_SECT=12
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_STMICRO=y
diff --git a/configs/stm32f769-disco_spl_defconfig b/configs/stm32f769-disco_spl_defconfig
index 19d2c24abb..f0a1b667b8 100644
--- a/configs/stm32f769-disco_spl_defconfig
+++ b/configs/stm32f769-disco_spl_defconfig
@@ -1,8 +1,7 @@
 CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
-CONFIG_SYS_TEXT_BASE=0x08008000
+CONFIG_SYS_TEXT_BASE=0x08009000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xE00
 CONFIG_SPL_GPIO=y
 CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
@@ -13,10 +12,11 @@ CONFIG_SPL_TEXT_BASE=0x8000000
 CONFIG_SYS_PROMPT="U-Boot > "
 CONFIG_SPL_SERIAL=y
 CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL_SIZE_LIMIT=0x9000
 CONFIG_STM32F7=y
 CONFIG_TARGET_STM32F746_DISCO=y
 CONFIG_SPL=y
-CONFIG_SYS_LOAD_ADDR=0x8008000
+CONFIG_SYS_LOAD_ADDR=0x8009000
 CONFIG_BUILD_TARGET="u-boot-with-spl.bin"
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
@@ -28,7 +28,7 @@ CONFIG_AUTOBOOT_STOP_STR=" "
 CONFIG_USE_BOOTARGS=y
 CONFIG_BOOTARGS="console=ttyS0,115200 earlyprintk consoleblank=0 ignore_loglevel"
 # CONFIG_DISPLAY_CPUINFO is not set
-CONFIG_SPL_PAD_TO=0x8000
+CONFIG_SPL_PAD_TO=0x9000
 CONFIG_SPL_NO_BSS_LIMIT=y
 CONFIG_SPL_BOARD_INIT=y
 CONFIG_SPL_SYS_MALLOC_SIMPLE=y
@@ -62,7 +62,7 @@ CONFIG_MTD=y
 CONFIG_DM_MTD=y
 CONFIG_MTD_NOR_FLASH=y
 CONFIG_STM32_FLASH=y
-CONFIG_SYS_MAX_FLASH_SECT=8
+CONFIG_SYS_MAX_FLASH_SECT=12
 CONFIG_DM_SPI_FLASH=y
 CONFIG_SPI_FLASH_MACRONIX=y
 CONFIG_SPI_FLASH_STMICRO=y
diff --git a/configs/stm32h743-disco_defconfig b/configs/stm32h743-disco_defconfig
index d33da43065..8c62c70a57 100644
--- a/configs/stm32h743-disco_defconfig
+++ b/configs/stm32h743-disco_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xF00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32h743i-disco"
diff --git a/configs/stm32h743-eval_defconfig b/configs/stm32h743-eval_defconfig
index a72de48690..1ff6b50819 100644
--- a/configs/stm32h743-eval_defconfig
+++ b/configs/stm32h743-eval_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x08000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xF00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32h743i-eval"
diff --git a/configs/stm32h750-art-pi_defconfig b/configs/stm32h750-art-pi_defconfig
index b8296a98b4..a5fce5e866 100644
--- a/configs/stm32h750-art-pi_defconfig
+++ b/configs/stm32h750-art-pi_defconfig
@@ -2,7 +2,6 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32=y
 CONFIG_SYS_TEXT_BASE=0x90000000
 CONFIG_SYS_MALLOC_LEN=0x100000
-CONFIG_SYS_MALLOC_F_LEN=0xF00
 CONFIG_NR_DRAM_BANKS=1
 CONFIG_ENV_SIZE=0x2000
 CONFIG_DEFAULT_DEVICE_TREE="stm32h750i-art-pi"
diff --git a/configs/stm32mp13_defconfig b/configs/stm32mp13_defconfig
index 26beb73e84..0f2caf688a 100644
--- a/configs/stm32mp13_defconfig
+++ b/configs/stm32mp13_defconfig
@@ -3,33 +3,52 @@ CONFIG_ARCH_STM32MP=y
 CONFIG_TFABOOT=y
 CONFIG_SYS_MALLOC_F_LEN=0x180000
 CONFIG_ENV_OFFSET=0x900000
+CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp135f-dk"
 CONFIG_SYS_PROMPT="STM32MP> "
-CONFIG_STM32MP13x=y
-CONFIG_DDR_CACHEABLE_SIZE=0x10000000
-CONFIG_TARGET_ST_STM32MP13x=y
+CONFIG_STM32MP13X=y
+CONFIG_DDR_CACHEABLE_SIZE=0x8000000
+CONFIG_CMD_STM32KEY=y
+CONFIG_TARGET_ST_STM32MP13X=y
 CONFIG_ENV_OFFSET_REDUND=0x940000
+CONFIG_CMD_STM32PROG=y
 # CONFIG_ARMV7_NONSEC is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0400000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_FDT_SIMPLEFB=y
+CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
 CONFIG_CMD_MEMINFO=y
 CONFIG_CMD_MEMTEST=y
 CONFIG_CMD_UNZIP=y
+CONFIG_CMD_ADC=y
 CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
 CONFIG_CMD_GPIO=y
 CONFIG_CMD_I2C=y
 CONFIG_CMD_LSBLK=y
 CONFIG_CMD_MMC=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BMP=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_EFIDEBUG=y
 CONFIG_CMD_TIME=y
@@ -37,43 +56,115 @@ CONFIG_CMD_RNG=y
 CONFIG_CMD_TIMER=y
 CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
-CONFIG_CMD_MTDPARTS=y
 CONFIG_CMD_LOG=y
 CONFIG_CMD_UBI=y
 CONFIG_OF_LIVE=y
 CONFIG_ENV_IS_NOWHERE=y
 CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_IS_IN_UBI=y
 CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_UBI_PART="UBI"
+CONFIG_ENV_UBI_VOLUME="uboot_config"
+CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_ENV_MMC_USE_DT=y
+CONFIG_TFTP_TSIZE=y
+CONFIG_STM32_ADC=y
 CONFIG_CLK_SCMI=y
+CONFIG_DFU_TFTP=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
+CONFIG_FASTBOOT_BUF_SIZE=0x02000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
+CONFIG_FWU_MDATA=y
 CONFIG_GPIO_HOG=y
 CONFIG_DM_I2C=y
 CONFIG_SYS_I2C_STM32F7=y
 CONFIG_LED=y
 CONFIG_LED_GPIO=y
+CONFIG_STM32_FMC2_EBI=y
 CONFIG_SUPPORT_EMMC_BOOT=y
 CONFIG_STM32_SDMMC2=y
 CONFIG_MTD=y
 CONFIG_DM_MTD=y
-CONFIG_SYS_MTDPARTS_RUNTIME=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_NAND_STM32_FMC2=y
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USBPHYC=y
 CONFIG_PINCONF=y
+CONFIG_PINCTRL_MCP23017=y
 CONFIG_DM_REGULATOR=y
 CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_SCMI=y
 CONFIG_RESET_SCMI=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_OPTEE=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_STM32_QSPI=y
+CONFIG_STM32_SPI=y
 CONFIG_SYSRESET_PSCI=y
 CONFIG_TEE=y
 CONFIG_OPTEE=y
 # CONFIG_OPTEE_TA_AVB is not set
+CONFIG_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS=1
+CONFIG_TYPEC=y
+CONFIG_TYPEC_UCSI=y
+CONFIG_UCSI_STM32G0=y
+CONFIG_USB_ONBOARD_HUB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_DM_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEO_STM32=y
+CONFIG_VIDEO_STM32_MAX_XRES=480
+CONFIG_VIDEO_STM32_MAX_YRES=272
+CONFIG_VIDEO_BMP_RLE8=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
 CONFIG_ERRNO_STR=y
-CONFIG_FDT_FIXUP_PARTITIONS=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp15_basic_defconfig b/configs/stm32mp15_basic_defconfig
index 33680dc25e..12aaa46f7c 100644
--- a/configs/stm32mp15_basic_defconfig
+++ b/configs/stm32mp15_basic_defconfig
@@ -1,7 +1,7 @@
 CONFIG_ARM=y
 CONFIG_ARCH_STM32MP=y
 CONFIG_SYS_MALLOC_F_LEN=0x3000
-CONFIG_ENV_OFFSET=0x280000
+CONFIG_ENV_OFFSET=0x900000
 CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_SPL_DM_SPI=y
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
@@ -10,20 +10,23 @@ CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_SPL_MMC=y
 CONFIG_SPL=y
 CONFIG_CMD_STM32KEY=y
-CONFIG_TYPEC_STUSB160X=y
-CONFIG_TARGET_ST_STM32MP15x=y
-CONFIG_ENV_OFFSET_REDUND=0x2C0000
+CONFIG_TARGET_ST_STM32MP15X=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
 CONFIG_CMD_STM32PROG=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI=y
 # CONFIG_ARMV7_VIRT is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0100000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
 CONFIG_SPL_LOG=y
@@ -46,8 +49,11 @@ CONFIG_SPL_POWER=y
 CONFIG_SPL_SPI_FLASH_MTD=y
 CONFIG_SYS_SPI_U_BOOT_OFFS=0x80000
 CONFIG_FDT_SIMPLEFB=y
+CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
 CONFIG_SYS_PBSIZE=1050
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -75,7 +81,6 @@ CONFIG_CMD_TIMER=y
 CONFIG_CMD_PMIC=y
 CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
-CONFIG_CMD_MTDPARTS=y
 CONFIG_CMD_LOG=y
 CONFIG_CMD_UBI=y
 # CONFIG_SPL_DOS_PARTITION is not set
@@ -91,15 +96,14 @@ CONFIG_ENV_UBI_VOLUME="uboot_config"
 CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_ENV_MMC_USE_DT=y
 # CONFIG_SPL_ENV_IS_NOWHERE is not set
 # CONFIG_SPL_ENV_IS_IN_SPI_FLASH is not set
 CONFIG_TFTP_TSIZE=y
 CONFIG_STM32_ADC=y
-CONFIG_SET_DFU_ALT_INFO=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
 CONFIG_FASTBOOT_BUF_SIZE=0x02000000
-CONFIG_FASTBOOT_USB_DEV=1
 CONFIG_FASTBOOT_FLASH=y
 CONFIG_FASTBOOT_FLASH_MMC_DEV=1
 CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
@@ -110,6 +114,7 @@ CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
 CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_FWU_MDATA=y
 CONFIG_GPIO_HOG=y
 CONFIG_DM_HWSPINLOCK=y
 CONFIG_HWSPINLOCK_STM32=y
@@ -122,7 +127,6 @@ CONFIG_SUPPORT_EMMC_BOOT=y
 CONFIG_STM32_SDMMC2=y
 CONFIG_MTD=y
 CONFIG_DM_MTD=y
-CONFIG_SYS_MTDPARTS_RUNTIME=y
 CONFIG_MTD_RAW_NAND=y
 CONFIG_NAND_STM32_FMC2=y
 CONFIG_SYS_NAND_ONFI_DETECTION=y
@@ -151,7 +155,7 @@ CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
 CONFIG_REMOTEPROC_STM32_COPRO=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_STM32MP1=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
@@ -164,19 +168,28 @@ CONFIG_USB=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS=1
+CONFIG_TYPEC=y
+CONFIG_TYPEC_STUSB160X=y
+CONFIG_USB_ONBOARD_HUB=y
 CONFIG_USB_GADGET=y
 CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
 CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_DM_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_DSI=y
 CONFIG_VIDEO_STM32_MAX_XRES=1280
 CONFIG_VIDEO_STM32_MAX_YRES=800
+CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
@@ -184,7 +197,14 @@ CONFIG_WDT=y
 CONFIG_WDT_STM32MP=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_ERRNO_STR=y
-CONFIG_FDT_FIXUP_PARTITIONS=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp15_defconfig b/configs/stm32mp15_defconfig
index 0f6b3738ca..5f3fbac002 100644
--- a/configs/stm32mp15_defconfig
+++ b/configs/stm32mp15_defconfig
@@ -1,29 +1,35 @@
 CONFIG_ARM=y
 CONFIG_ARCH_STM32MP=y
 CONFIG_TFABOOT=y
-CONFIG_SYS_MALLOC_F_LEN=0x20000
-CONFIG_ENV_OFFSET=0x480000
+CONFIG_SYS_MALLOC_F_LEN=0x80000
+CONFIG_ENV_OFFSET=0x900000
 CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
 CONFIG_SYS_PROMPT="STM32MP> "
-CONFIG_DDR_CACHEABLE_SIZE=0x10000000
+CONFIG_DDR_CACHEABLE_SIZE=0x8000000
 CONFIG_CMD_STM32KEY=y
-CONFIG_TYPEC_STUSB160X=y
-CONFIG_TARGET_ST_STM32MP15x=y
-CONFIG_ENV_OFFSET_REDUND=0x4C0000
+CONFIG_TARGET_ST_STM32MP15X=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
 CONFIG_CMD_STM32PROG=y
 # CONFIG_ARMV7_NONSEC is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0100000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
 CONFIG_FDT_SIMPLEFB=y
+CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
 CONFIG_SYS_PBSIZE=1050
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -51,7 +57,6 @@ CONFIG_CMD_TIMER=y
 CONFIG_CMD_PMIC=y
 CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
-CONFIG_CMD_MTDPARTS=y
 CONFIG_CMD_LOG=y
 CONFIG_CMD_UBI=y
 CONFIG_OF_LIVE=y
@@ -65,14 +70,14 @@ CONFIG_ENV_UBI_VOLUME="uboot_config"
 CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_ENV_MMC_USE_DT=y
 CONFIG_TFTP_TSIZE=y
 CONFIG_STM32_ADC=y
 CONFIG_CLK_SCMI=y
-CONFIG_SET_DFU_ALT_INFO=y
+CONFIG_DFU_TFTP=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
 CONFIG_FASTBOOT_BUF_SIZE=0x02000000
-CONFIG_FASTBOOT_USB_DEV=1
 CONFIG_FASTBOOT_FLASH=y
 CONFIG_FASTBOOT_FLASH_MMC_DEV=1
 CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
@@ -83,6 +88,7 @@ CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
 CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_FWU_MDATA=y
 CONFIG_GPIO_HOG=y
 CONFIG_DM_HWSPINLOCK=y
 CONFIG_HWSPINLOCK_STM32=y
@@ -95,7 +101,6 @@ CONFIG_SUPPORT_EMMC_BOOT=y
 CONFIG_STM32_SDMMC2=y
 CONFIG_MTD=y
 CONFIG_DM_MTD=y
-CONFIG_SYS_MTDPARTS_RUNTIME=y
 CONFIG_MTD_RAW_NAND=y
 CONFIG_NAND_STM32_FMC2=y
 CONFIG_SYS_NAND_ONFI_DETECTION=y
@@ -121,11 +126,11 @@ CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
 CONFIG_DM_REGULATOR_SCMI=y
+CONFIG_REMOTEPROC_OPTEE=y
 CONFIG_REMOTEPROC_STM32_COPRO=y
 CONFIG_RESET_SCMI=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_OPTEE=y
-CONFIG_RNG_STM32MP1=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
@@ -141,27 +146,44 @@ CONFIG_USB=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS=1
+CONFIG_TYPEC=y
+CONFIG_TYPEC_STUSB160X=y
+CONFIG_USB_ONBOARD_HUB=y
 CONFIG_USB_GADGET=y
 CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
 CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_DM_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_DSI=y
 CONFIG_VIDEO_STM32_MAX_XRES=1280
 CONFIG_VIDEO_STM32_MAX_YRES=800
+CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
 CONFIG_WDT=y
 CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_ERRNO_STR=y
-CONFIG_FDT_FIXUP_PARTITIONS=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp15_dhcom_basic_defconfig b/configs/stm32mp15_dhcom_basic_defconfig
index f47e70be44..f92a333391 100644
--- a/configs/stm32mp15_dhcom_basic_defconfig
+++ b/configs/stm32mp15_dhcom_basic_defconfig
@@ -8,8 +8,14 @@ CONFIG_DEFAULT_DEVICE_TREE="stm32mp15xx-dhcom-pdk2"
 CONFIG_SPL_TEXT_BASE=0x2FFC2500
 CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_SPL_MMC=y
+CONFIG_BOOTCOUNT_BOOTLIMIT=3
+CONFIG_SYS_BOOTCOUNT_ADDR=0x5C00A14C
 CONFIG_SPL=y
+CONFIG_CMD_STM32KEY=y
+CONFIG_CMD_STBOARD=y
 CONFIG_TARGET_DH_STM32MP1_PDK2=y
+CONFIG_CMD_STM32PROG=y
+CONFIG_CMD_STM32PROG_OTP=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI=y
 # CONFIG_ARMV7_VIRT is not set
@@ -30,6 +36,7 @@ CONFIG_CONSOLE_MUX=y
 CONFIG_BOARD_EARLY_INIT_F=y
 CONFIG_SPL_FOOTPRINT_LIMIT=y
 CONFIG_SPL_MAX_FOOTPRINT=0x3db00
+CONFIG_SPL_BOOTCOUNT_LIMIT=y
 CONFIG_SPL_LEGACY_IMAGE_FORMAT=y
 # CONFIG_SPL_SHARES_INIT_SP_ADDR is not set
 CONFIG_SPL_STACK=0x30000000
@@ -74,15 +81,15 @@ CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 CONFIG_CMD_USB_MASS_STORAGE=y
 CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BOOTCOUNT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_TIMER=y
 CONFIG_CMD_PMIC=y
 CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_BTRFS=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_MTDPARTS=y
-CONFIG_MTDIDS_DEFAULT="nor0=nor0"
-CONFIG_MTDPARTS_DEFAULT="mtdparts=nor0:256k(fsbl1),256k(fsbl2),1408k(uboot),64k(env1),64k(env2)"
 # CONFIG_SPL_DOS_PARTITION is not set
 # CONFIG_ISO_PARTITION is not set
 # CONFIG_SPL_PARTITION_UUIDS is not set
@@ -93,11 +100,14 @@ CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SPL_ENV_IS_NOWHERE=y
+CONFIG_VERSION_VARIABLE=y
 CONFIG_NET_RANDOM_ETHADDR=y
 CONFIG_IP_DEFRAG=y
 CONFIG_TFTP_TSIZE=y
 CONFIG_STM32_ADC=y
 CONFIG_SPL_BLOCK_CACHE=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_SYS_BOOTCOUNT_MAGIC=0xB0C40000
 CONFIG_DFU_MMC=y
 CONFIG_DFU_MTD=y
 CONFIG_DFU_RAM=y
@@ -163,6 +173,8 @@ CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
 CONFIG_FAT_WRITE=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_LZO=y
diff --git a/configs/stm32mp15_dhcor_basic_defconfig b/configs/stm32mp15_dhcor_basic_defconfig
index 02cce50691..8924a762d9 100644
--- a/configs/stm32mp15_dhcor_basic_defconfig
+++ b/configs/stm32mp15_dhcor_basic_defconfig
@@ -8,8 +8,14 @@ CONFIG_DEFAULT_DEVICE_TREE="stm32mp15xx-dhcor-avenger96"
 CONFIG_SPL_TEXT_BASE=0x2FFC2500
 CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_SPL_MMC=y
+CONFIG_BOOTCOUNT_BOOTLIMIT=3
+CONFIG_SYS_BOOTCOUNT_ADDR=0x5C00A14C
 CONFIG_SPL=y
+CONFIG_CMD_STM32KEY=y
+CONFIG_CMD_STBOARD=y
 CONFIG_TARGET_DH_STM32MP1_PDK2=y
+CONFIG_CMD_STM32PROG=y
+CONFIG_CMD_STM32PROG_OTP=y
 CONFIG_SPL_SPI_FLASH_SUPPORT=y
 CONFIG_SPL_SPI=y
 # CONFIG_ARMV7_VIRT is not set
@@ -28,6 +34,7 @@ CONFIG_CONSOLE_MUX=y
 CONFIG_BOARD_EARLY_INIT_F=y
 CONFIG_SPL_FOOTPRINT_LIMIT=y
 CONFIG_SPL_MAX_FOOTPRINT=0x3db00
+CONFIG_SPL_BOOTCOUNT_LIMIT=y
 CONFIG_SPL_LEGACY_IMAGE_FORMAT=y
 # CONFIG_SPL_SHARES_INIT_SP_ADDR is not set
 CONFIG_SPL_STACK=0x30000000
@@ -72,15 +79,15 @@ CONFIG_CMD_SPI=y
 CONFIG_CMD_USB=y
 CONFIG_CMD_USB_MASS_STORAGE=y
 CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BOOTCOUNT=y
 CONFIG_CMD_CACHE=y
 CONFIG_CMD_TIME=y
 CONFIG_CMD_TIMER=y
 CONFIG_CMD_PMIC=y
 CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_BTRFS=y
 CONFIG_CMD_EXT4_WRITE=y
 CONFIG_CMD_MTDPARTS=y
-CONFIG_MTDIDS_DEFAULT="nor0=nor0"
-CONFIG_MTDPARTS_DEFAULT="mtdparts=nor0:256k(fsbl1),256k(fsbl2),1408k(uboot),64k(env1),64k(env2)"
 # CONFIG_SPL_DOS_PARTITION is not set
 # CONFIG_ISO_PARTITION is not set
 # CONFIG_SPL_PARTITION_UUIDS is not set
@@ -90,11 +97,14 @@ CONFIG_ENV_IS_IN_SPI_FLASH=y
 CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SPL_ENV_IS_NOWHERE=y
+CONFIG_VERSION_VARIABLE=y
 CONFIG_NET_RANDOM_ETHADDR=y
 CONFIG_IP_DEFRAG=y
 CONFIG_TFTP_TSIZE=y
 CONFIG_STM32_ADC=y
 CONFIG_SPL_BLOCK_CACHE=y
+CONFIG_BOOTCOUNT_LIMIT=y
+CONFIG_SYS_BOOTCOUNT_MAGIC=0xB0C40000
 CONFIG_DFU_MMC=y
 CONFIG_DFU_MTD=y
 CONFIG_DFU_RAM=y
@@ -162,6 +172,8 @@ CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
 CONFIG_FAT_WRITE=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_LZO=y
diff --git a/configs/stm32mp15_trusted_defconfig b/configs/stm32mp15_trusted_defconfig
index 1154eec210..a40ef9f75b 100644
--- a/configs/stm32mp15_trusted_defconfig
+++ b/configs/stm32mp15_trusted_defconfig
@@ -2,29 +2,35 @@ CONFIG_ARM=y
 CONFIG_ARCH_STM32MP=y
 CONFIG_TFABOOT=y
 CONFIG_SYS_MALLOC_F_LEN=0x3000
-CONFIG_ENV_OFFSET=0x280000
+CONFIG_ENV_OFFSET=0x900000
 CONFIG_ENV_SECT_SIZE=0x40000
 CONFIG_DEFAULT_DEVICE_TREE="stm32mp157c-ev1"
 CONFIG_SYS_PROMPT="STM32MP> "
 CONFIG_DDR_CACHEABLE_SIZE=0x10000000
 CONFIG_CMD_STM32KEY=y
-CONFIG_TYPEC_STUSB160X=y
-CONFIG_STM32MP15x_STM32IMAGE=y
-CONFIG_TARGET_ST_STM32MP15x=y
-CONFIG_ENV_OFFSET_REDUND=0x2C0000
+CONFIG_STM32MP15X_STM32IMAGE=y
+CONFIG_TARGET_ST_STM32MP15X=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
 CONFIG_CMD_STM32PROG=y
 # CONFIG_ARMV7_NONSEC is not set
 CONFIG_SYS_LOAD_ADDR=0xc2000000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
 CONFIG_SYS_MEMTEST_START=0xc0000000
 CONFIG_SYS_MEMTEST_END=0xc4000000
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0xc0100000
 CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
 CONFIG_BOOTDELAY=1
 CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
 CONFIG_FDT_SIMPLEFB=y
+CONFIG_USB_HUB_DEBOUNCE_TIMEOUT=2000
 CONFIG_SYS_PBSIZE=1050
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
 CONFIG_CMD_ADTIMG=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -52,7 +58,6 @@ CONFIG_CMD_TIMER=y
 CONFIG_CMD_PMIC=y
 CONFIG_CMD_REGULATOR=y
 CONFIG_CMD_EXT4_WRITE=y
-CONFIG_CMD_MTDPARTS=y
 CONFIG_CMD_LOG=y
 CONFIG_CMD_UBI=y
 CONFIG_OF_LIVE=y
@@ -66,14 +71,14 @@ CONFIG_ENV_UBI_VOLUME="uboot_config"
 CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_ENV_MMC_USE_DT=y
 CONFIG_TFTP_TSIZE=y
 CONFIG_STM32_ADC=y
 CONFIG_CLK_SCMI=y
-CONFIG_SET_DFU_ALT_INFO=y
+CONFIG_DFU_TFTP=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0xC0000000
 CONFIG_FASTBOOT_BUF_SIZE=0x02000000
-CONFIG_FASTBOOT_USB_DEV=1
 CONFIG_FASTBOOT_FLASH=y
 CONFIG_FASTBOOT_FLASH_MMC_DEV=1
 CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
@@ -84,6 +89,7 @@ CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
 CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
 CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
 CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_FWU_MDATA=y
 CONFIG_GPIO_HOG=y
 CONFIG_DM_HWSPINLOCK=y
 CONFIG_HWSPINLOCK_STM32=y
@@ -96,7 +102,6 @@ CONFIG_SUPPORT_EMMC_BOOT=y
 CONFIG_STM32_SDMMC2=y
 CONFIG_MTD=y
 CONFIG_DM_MTD=y
-CONFIG_SYS_MTDPARTS_RUNTIME=y
 CONFIG_MTD_RAW_NAND=y
 CONFIG_NAND_STM32_FMC2=y
 CONFIG_SYS_NAND_ONFI_DETECTION=y
@@ -121,11 +126,11 @@ CONFIG_DM_REGULATOR_FIXED=y
 CONFIG_DM_REGULATOR_GPIO=y
 CONFIG_DM_REGULATOR_STM32_VREFBUF=y
 CONFIG_DM_REGULATOR_STPMIC1=y
+CONFIG_REMOTEPROC_OPTEE=y
 CONFIG_REMOTEPROC_STM32_COPRO=y
 CONFIG_RESET_SCMI=y
 CONFIG_DM_RNG=y
-CONFIG_RNG_OPTEE=y
-CONFIG_RNG_STM32MP1=y
+CONFIG_RNG_STM32=y
 CONFIG_DM_RTC=y
 CONFIG_RTC_STM32=y
 CONFIG_SERIAL_RX_BUFFER=y
@@ -141,19 +146,28 @@ CONFIG_USB=y
 CONFIG_DM_USB_GADGET=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_GENERIC=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_GENERIC=y
+CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS=1
+CONFIG_TYPEC=y
+CONFIG_TYPEC_STUSB160X=y
+CONFIG_USB_ONBOARD_HUB=y
 CONFIG_USB_GADGET=y
 CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
 CONFIG_USB_GADGET_VENDOR_NUM=0x0483
 CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
 CONFIG_USB_GADGET_DWC2_OTG=y
 CONFIG_DM_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
 CONFIG_BACKLIGHT_GPIO=y
 CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
 CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
 CONFIG_VIDEO_STM32=y
 CONFIG_VIDEO_STM32_DSI=y
 CONFIG_VIDEO_STM32_MAX_XRES=1280
 CONFIG_VIDEO_STM32_MAX_YRES=800
+CONFIG_VIDEO_BMP_RLE8=y
 CONFIG_BMP_16BPP=y
 CONFIG_BMP_24BPP=y
 CONFIG_BMP_32BPP=y
@@ -161,7 +175,14 @@ CONFIG_WDT=y
 CONFIG_WDT_STM32MP=y
 # CONFIG_BINMAN_FDT is not set
 CONFIG_ERRNO_STR=y
-CONFIG_FDT_FIXUP_PARTITIONS=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
 # CONFIG_LMB_USE_MAX_REGIONS is not set
 CONFIG_LMB_MEMORY_REGIONS=2
 CONFIG_LMB_RESERVED_REGIONS=16
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/stm32mp25_defconfig b/configs/stm32mp25_defconfig
new file mode 100644
index 0000000000..80d1756180
--- /dev/null
+++ b/configs/stm32mp25_defconfig
@@ -0,0 +1,187 @@
+CONFIG_ARM=y
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_ARCH_STM32MP=y
+CONFIG_SYS_MALLOC_F_LEN=0x400000
+CONFIG_ENV_OFFSET=0x900000
+CONFIG_ENV_SECT_SIZE=0x40000
+CONFIG_DEFAULT_DEVICE_TREE="stm32mp257f-ev1"
+CONFIG_SYS_PROMPT="STM32MP> "
+CONFIG_STM32MP25X=y
+CONFIG_CMD_STM32KEY=y
+CONFIG_ENV_OFFSET_REDUND=0x940000
+CONFIG_TARGET_ST_STM32MP25X=y
+CONFIG_CMD_STM32PROG=y
+CONFIG_SYS_LOAD_ADDR=0x84000000
+CONFIG_ENV_ADDR=0x60900000
+CONFIG_FWU_NUM_IMAGES_PER_BANK=1
+CONFIG_OF_BOARD_FIXUP=y
+CONFIG_SYS_MEMTEST_START=0x84000000
+CONFIG_SYS_MEMTEST_END=0x88000000
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x90000000
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_BOOTDELAY=1
+CONFIG_BOOTCOMMAND="run bootcmd_stm32mp"
+CONFIG_FDT_SIMPLEFB=y
+CONFIG_CMD_FWU_METADATA=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_SYS_BOOTM_LEN=0x2000000
+CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_ADTIMG=y
+# CONFIG_CMD_ELF is not set
+CONFIG_CMD_ERASEENV=y
+CONFIG_CMD_NVEDIT_EFI=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LSBLK=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_REMOTEPROC=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_SYS_DISABLE_AUTOLOAD=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_CLS=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_RNG=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_CMD_LOG=y
+CONFIG_CMD_UBI=y
+CONFIG_OF_LIVE=y
+CONFIG_ENV_IS_NOWHERE=y
+CONFIG_ENV_IS_IN_FLASH=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_ENV_IS_IN_SPI_FLASH=y
+CONFIG_ENV_IS_IN_UBI=y
+CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
+CONFIG_ENV_ADDR_REDUND=0x60940000
+CONFIG_ENV_UBI_PART="UBI"
+CONFIG_ENV_UBI_VOLUME="uboot_config"
+CONFIG_ENV_UBI_VOLUME_REDUND="uboot_config_r"
+CONFIG_SYS_MMC_ENV_DEV=-1
+CONFIG_BUTTON=y
+CONFIG_BUTTON_GPIO=y
+CONFIG_DFU_TFTP=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x84000000
+CONFIG_FASTBOOT_BUF_SIZE=0x2000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=1
+CONFIG_FASTBOOT_MMC_BOOT_SUPPORT=y
+CONFIG_FASTBOOT_MMC_BOOT1_NAME="mmc1boot0"
+CONFIG_FASTBOOT_MMC_BOOT2_NAME="mmc1boot1"
+CONFIG_FASTBOOT_MMC_USER_SUPPORT=y
+CONFIG_FASTBOOT_MMC_USER_NAME="mmc1"
+CONFIG_FASTBOOT_CMD_OEM_FORMAT=y
+CONFIG_FASTBOOT_CMD_OEM_PARTCONF=y
+CONFIG_FASTBOOT_CMD_OEM_BOOTBUS=y
+CONFIG_FWU_MDATA=y
+CONFIG_GPIO_HOG=y
+CONFIG_DM_I2C=y
+CONFIG_SYS_I2C_STM32F7=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_STM32_FMC2_EBI=y
+CONFIG_STM32_OMI=y
+CONFIG_STM32_OMM=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_STM32_SDMMC2=y
+CONFIG_MTD=y
+CONFIG_DM_MTD=y
+CONFIG_MTD_NOR_FLASH=y
+CONFIG_SYS_FLASH_CFI_WIDTH_16BIT=y
+CONFIG_CFI_FLASH=y
+CONFIG_SYS_FLASH_USE_BUFFER_WRITE=y
+CONFIG_FLASH_CFI_MTD=y
+CONFIG_FLASH_CFI_SFDP=y
+CONFIG_SYS_FLASH_CFI=y
+CONFIG_STM32_HYPERBUS=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_SYS_NAND_USE_FLASH_BBT=y
+CONFIG_NAND_STM32_FMC2=y
+CONFIG_SYS_NAND_ONFI_DETECTION=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_SPI_FLASH_SFDP_SUPPORT=y
+CONFIG_SPI_FLASH_SOFT_RESET=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_WINBOND=y
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+CONFIG_SPI_FLASH_MTD=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DWC_ETH_QOS=y
+CONFIG_PHY=y
+CONFIG_PHY_STM32_USB2PHY=y
+CONFIG_PINCONF=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_RAM=y
+# CONFIG_STM32MP1_DDR is not set
+CONFIG_REMOTEPROC_OPTEE=y
+CONFIG_REMOTEPROC_STM32_COPRO=y
+CONFIG_DM_RNG=y
+CONFIG_RNG_STM32=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_STM32=y
+CONFIG_SERIAL_RX_BUFFER=y
+CONFIG_SPI=y
+CONFIG_DM_SPI=y
+CONFIG_STM32_OSPI=y
+CONFIG_STM32_SPI=y
+# CONFIG_OPTEE_TA_AVB is not set
+CONFIG_USB=y
+CONFIG_DM_USB_GADGET=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DWC3=y
+CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS=1
+CONFIG_USB_STM32_USBH=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_GENERIC=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="STMicroelectronics"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0483
+CONFIG_USB_GADGET_PRODUCT_NUM=0x5720
+CONFIG_DM_VIDEO=y
+# CONFIG_VIDEO_LOGO is not set
+CONFIG_BACKLIGHT_GPIO=y
+CONFIG_VIDEO_LCD_ORISETECH_OTM8009A=y
+CONFIG_VIDEO_LCD_RAYDIUM_RM68200=y
+CONFIG_VIDEO_LCD_ROCKTECH_HX8394=y
+CONFIG_VIDEO_STM32=y
+CONFIG_VIDEO_STM32_DSI=y
+CONFIG_VIDEO_STM32_LVDS=y
+CONFIG_VIDEO_STM32_MAX_XRES=1920
+CONFIG_VIDEO_STM32_MAX_YRES=1200
+CONFIG_VIDEO_BMP_RLE8=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_WDT=y
+CONFIG_WDT_STM32MP=y
+CONFIG_WDT_ARM_SMC=y
+CONFIG_ERRNO_STR=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_SECURE_BOOT=y
+# CONFIG_LMB_USE_MAX_REGIONS is not set
+CONFIG_LMB_MEMORY_REGIONS=2
+CONFIG_LMB_RESERVED_REGIONS=32
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
+# CONFIG_TOOLS_MKEFICAPSULE is not set
+# CONFIG_TOOLS_MKFWUMDATA is not set
diff --git a/configs/synquacer_developerbox_defconfig b/configs/synquacer_developerbox_defconfig
index c0b784b072..13a20e733f 100644
--- a/configs/synquacer_developerbox_defconfig
+++ b/configs/synquacer_developerbox_defconfig
@@ -18,6 +18,7 @@ CONFIG_BOOTSTAGE_STASH_SIZE=4096
 CONFIG_HUSH_PARSER=y
 CONFIG_SYS_MAXARGS=128
 CONFIG_SYS_BOOTM_LEN=0x800000
+CONFIG_CMD_FWU_METADATA=y
 CONFIG_CMD_IMLS=y
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
@@ -53,6 +54,7 @@ CONFIG_DFU_TFTP=y
 CONFIG_DFU_MTD=y
 CONFIG_DFU_RAM=y
 CONFIG_DFU_SF=y
+CONFIG_FWU_MDATA_MTD=y
 CONFIG_DM_I2C=y
 CONFIG_SYS_I2C_SYNQUACER=y
 CONFIG_MMC_SDHCI=y
@@ -96,3 +98,5 @@ CONFIG_EFI_RUNTIME_UPDATE_CAPSULE=y
 CONFIG_EFI_CAPSULE_ON_DISK=y
 CONFIG_EFI_IGNORE_OSINDICATIONS=y
 CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
+CONFIG_FWU_MULTI_BANK_UPDATE=y
+CONFIG_FWU_MDATA_V2=y
diff --git a/configs/tools-only_defconfig b/configs/tools-only_defconfig
index 211acc7774..07506006ce 100644
--- a/configs/tools-only_defconfig
+++ b/configs/tools-only_defconfig
@@ -35,3 +35,4 @@ CONFIG_I2C_EDID=y
 # CONFIG_GENERATE_ACPI_TABLE is not set
 # CONFIG_EFI_LOADER is not set
 CONFIG_TOOLS_MKEFICAPSULE=y
+CONFIG_TOOLS_MKFWUMDATA=y
diff --git a/disk/part_efi.c b/disk/part_efi.c
index 5090efd119..911089f76d 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -266,20 +266,19 @@ int part_get_info_efi(struct blk_desc *dev_desc, int part,
 
 	/* "part" argument must be at least 1 */
 	if (part < 1) {
-		printf("%s: Invalid Argument(s)\n", __func__);
-		return -1;
+		log_debug("Invalid Argument(s)\n");
+		return -EINVAL;
 	}
 
 	/* This function validates AND fills in the GPT header and PTE */
 	if (find_valid_gpt(dev_desc, gpt_head, &gpt_pte) != 1)
-		return -1;
+		return -EINVAL;
 
 	if (part > le32_to_cpu(gpt_head->num_partition_entries) ||
 	    !is_pte_valid(&gpt_pte[part - 1])) {
-		debug("%s: *** ERROR: Invalid partition number %d ***\n",
-			__func__, part);
+		log_debug("*** ERROR: Invalid partition number %d ***\n", part);
 		free(gpt_pte);
-		return -1;
+		return -EPERM;
 	}
 
 	/* The 'lbaint_t' casting may limit the maximum disk size to 2 TB */
@@ -302,8 +301,8 @@ int part_get_info_efi(struct blk_desc *dev_desc, int part,
 			info->type_guid, UUID_STR_FORMAT_GUID);
 #endif
 
-	debug("%s: start 0x" LBAF ", size 0x" LBAF ", name %s\n", __func__,
-	      info->start, info->size, info->name);
+	log_debug("start 0x" LBAF ", size 0x" LBAF ", name %s\n", info->start,
+		  info->size, info->name);
 
 	/* Remember to free pte */
 	free(gpt_pte);
diff --git a/doc/README.gpio b/doc/README.gpio
index 548ff37b8c..d253f654fa 100644
--- a/doc/README.gpio
+++ b/doc/README.gpio
@@ -2,10 +2,8 @@
 GPIO hog (CONFIG_GPIO_HOG)
 --------
 
-All the GPIO hog are initialized in gpio_hog_probe_all() function called in
-board_r.c just before board_late_init() but you can also acces directly to
-the gpio with gpio_hog_lookup_name().
-
+All the GPIO hog are initialized using DM_FLAG_PROBE_AFTER_BIND DM flag
+after bind().
 
 Example, for the device tree:
 
diff --git a/doc/README.gpt b/doc/README.gpt
index 91e397d06f..394cea0aa8 100644
--- a/doc/README.gpt
+++ b/doc/README.gpt
@@ -177,7 +177,7 @@ To restore GUID partition table one needs to:
      "name=u-boot,size=60MiB;name=boot,size=60Mib,bootable;name=rootfs,size=0"
    It can be used to locate bootable disks with command
    "part list <interface> <dev> -bootable <varname>",
-   please check out doc/README.distro for use.
+   please check out doc/develop/distro.rst for use.
 
 2. Define 'CONFIG_EFI_PARTITION' and 'CONFIG_CMD_GPT'
 
diff --git a/doc/README.pxe b/doc/README.pxe
index 75caa01c4a..51a206680b 100644
--- a/doc/README.pxe
+++ b/doc/README.pxe
@@ -172,11 +172,19 @@ initrd <path>	    - if this label is chosen, use tftp to retrieve the initrd
 		      at <path>. it will be stored at the address indicated in
 		      the initrd_addr_r environment variable, and that address
 		      will be passed to bootm.
+		      For FIT image, the initrd can be provided with the same value than
+		      kernel, including configuration:
+		        <path>#<conf>[#<extra-conf[#...]]
+		      In this case, kernel_addr_r is passed to bootm.
 
 fdt <path>	    - if this label is chosen, use tftp to retrieve the fdt blob
 		      at <path>. it will be stored at the address indicated in
 		      the fdt_addr_r environment variable, and that address will
 		      be passed to bootm.
+		      For FIT image, the device tree can be provided with the same value
+		      than kernel, including configuration:
+		        <path>#<conf>[#<extra-conf[#...]]
+		      In this case, kernel_addr_r is passed to bootm.
 
 fdtdir <path>	    - if this label is chosen, use tftp to retrieve a fdt blob
 		      relative to <path>. If the fdtfile environment variable
diff --git a/doc/README.uniphier b/doc/README.uniphier
index badfacd66a..af746f6c31 100644
--- a/doc/README.uniphier
+++ b/doc/README.uniphier
@@ -336,7 +336,7 @@ Deployment for Distro Boot
 --------------------------
 
 UniPhier SoC family boot the kernel in a generic manner as described in
-doc/README.distro .
+doc/develop/distro.rst.
 
 To boot the kernel, you need to deploy necesssary components to a file
 system on one of your block devices (eMMC, NAND, USB drive, etc.).
diff --git a/doc/board/emulation/qemu-x86.rst b/doc/board/emulation/qemu-x86.rst
index db842f2ece..e7dd4e994d 100644
--- a/doc/board/emulation/qemu-x86.rst
+++ b/doc/board/emulation/qemu-x86.rst
@@ -57,7 +57,8 @@ to instantiate. Note, the maximum supported CPU number in QEMU is 255.
 U-Boot uses 'distro_bootcmd' by default when booting on x86 QEMU. This tries to
 load a boot script, kernel, and ramdisk from several different interfaces. For
 the default boot order, see 'qemu-x86.h'. For more information, see
-'README.distro'. Most Linux distros can be booted by writing a uboot script.
+'doc/develop/distro.rst'. Most Linux distros can be booted by writing a uboot
+script.
 For example, Debian (stretch) can be booted by creating a script file named
 'boot.txt' with the contents::
 
diff --git a/doc/board/st/index.rst b/doc/board/st/index.rst
index 2a8a4ef3b8..4aece52a07 100644
--- a/doc/board/st/index.rst
+++ b/doc/board/st/index.rst
@@ -8,4 +8,5 @@ STMicroelectronics
 
    st-dt
    stm32mp1
+   stm32mp2
    stm32_MCU
diff --git a/doc/board/st/st-dt.rst b/doc/board/st/st-dt.rst
index 67e16ef165..a9e9a42a69 100644
--- a/doc/board/st/st-dt.rst
+++ b/doc/board/st/st-dt.rst
@@ -25,6 +25,7 @@ kernel binding directory = Documentation/devicetree/bindings/
 * display
 	- display/st,stm32-dsi.yaml
 	- display/st,stm32-ltdc.yaml
+        - display/st,stm32-lvds.yaml
 * gpio
 	- pinctrl/st,stm32-pinctrl.yaml
 * hwlock
diff --git a/doc/board/st/stm32mp1.rst b/doc/board/st/stm32mp1.rst
index 3759df353e..ec3fb20409 100644
--- a/doc/board/st/stm32mp1.rst
+++ b/doc/board/st/stm32mp1.rst
@@ -69,23 +69,29 @@ a Cortex-A frequency option:
  - D : Cortex-A7 @ 800 MHz
  - F : Secure Boot + HW Crypto + Cortex-A7 @ 800 MHz
 
-Currently the following boards are supported:
+Currently the following STMIcroelectronics boards are supported:
 
  + stm32mp157a-dk1.dts
+ + stm32mp157a-ed1.dts
+ + stm32mp157a-ev1.dts
  + stm32mp157c-dk2.dts
  + stm32mp157c-ed1.dts
  + stm32mp157c-ev1.dts
- + stm32mp15xx-dhcor-avenger96.dts
+ + stm32mp157d-dk1.dts
+ + stm32mp157d-ed1.dts
+ + stm32mp157d-ev1.dts
+ + stm32mp157f-dk2.dts
+ + stm32mp157f-ed1.dts
+ + stm32mp157f-ev1.dts
 
-The SCMI variant of each board is supported by a specific "scmi" device tree:
- + stm32mp157a-dk1-scmi.dts
- + stm32mp157c-dk2-scmi.dts
- + stm32mp157c-ed1-scmi.dts
- + stm32mp157c-ev1-scmi.dts
+These board with SCMI support are only managed with stm32mp15_defconfig,
+when the resources are secured with RCC_TZCR.TZEN=1 in OP-TEE. The access to
+these reset and clock resources are provided by OP-TEE and the associated SCMI
+services.
 
-SCMI variant is used only with stm32mp15_defconfig, when the resources are
-secured with RCC_TZCR.TZEN=1 in OP-TEE. The access to these reset and clock
-resources are provided by OP-TEE and the associated SCMI services.
+Currently the following customer boards are supported:
+
+ + stm32mp15xx-dhcor-avenger96.dts
 
 STM32MP13x
 ``````````
@@ -146,7 +152,7 @@ TF-A_ (BL2) initialize the DDR and loads the next stage binaries from a FIP file
      the secure monitor to access to secure resources.
    + HW_CONFIG: The hardware configuration file = the U-Boot device tree
 
-The scmi variant of each device tree is only support with OP-TEE as secure
+The SCMI variant of each device tree is only support with OP-TEE as secure
 monitor, with stm32mp15_defconfig.
 
 The **Basic** boot chain with SPL (for STM32MP15x)
@@ -184,19 +190,27 @@ The supported device trees for STM32MP15x (stm32mp15_trusted_defconfig and stm32
 
 + ev1: eval board with pmic stpmic1 (ev1 = mother board + daughter ed1)
 
+   + stm32mp157a-ev1
    + stm32mp157c-ev1
+   + stm32mp157d-ev1
+   + stm32mp157f-ev1
 
 + ed1: daughter board with pmic stpmic1
 
+   + stm32mp157a-ed1
    + stm32mp157c-ed1
+   + stm32mp157d-ed1
+   + stm32mp157f-ed1
 
 + dk1: Discovery board
 
    + stm32mp157a-dk1
+   + stm32mp157d-dk1
 
 + dk2: Discovery board = dk1 with a BT/WiFI combo and a DSI panel
 
    + stm32mp157c-dk2
+   + stm32mp157f-dk2
 
 + avenger96: Avenger96 board from Arrow Electronics based on DH Elec. DHCOR SoM
 
@@ -261,12 +275,6 @@ Build Procedure
 
   a) trusted boot with FIP on STM32MP15x ev1::
 
-     # export KBUILD_OUTPUT=stm32mp15
-     # make stm32mp15_defconfig
-     # make DEVICE_TREE=stm32mp157c-ev1-scmi all
-
-    or without SCMI support
-
      # export KBUILD_OUTPUT=stm32mp15
      # make stm32mp15_defconfig
      # make DEVICE_TREE=stm32mp157c-ev1 all
@@ -478,7 +486,8 @@ or:
   +-------+--------+---------+------------------------+------------------------+
 
 And the 4th partition (Rootfs) is marked bootable with a file extlinux.conf
-following the Generic Distribution feature (doc/README.distro for use).
+following the Generic Distribution feature (see :doc:`../../develop/distro` for
+use).
 
 The size of fip or ssbl partition must be enough for the associated binary file,
 4MB and 2MB are default values.
@@ -620,7 +629,7 @@ Prerequisite: check if a MAC address isn't yet programmed in OTP
     STM32MP> env print ethaddr
     ## Error: "ethaddr" not defined
 
-3) check lock status of fuse 57 & 58 (at 0x39, 0=unlocked, 1=locked)::
+3) check lock status of fuse 57 & 58 (at 0x39, 0=unlocked, 0x40000000=locked)::
 
     STM32MP> fuse sense 0 0x10000039 2
     Sensing bank 0:
@@ -640,11 +649,11 @@ Example to set mac address "12:34:56:78:9a:bc"
 
 3) Lock OTP::
 
-    STM32MP> fuse prog 0 0x10000039 1 1
+    STM32MP> fuse prog 0 0x10000039 0x40000000 0x40000000
 
     STM32MP> fuse sense 0 0x10000039 2
     Sensing bank 0:
-       Word 0x10000039: 00000001 00000001
+       Word 0x10000039: 40000000 40000000
 
 4) next REBOOT, in the trace::
 
diff --git a/doc/board/st/stm32mp2.rst b/doc/board/st/stm32mp2.rst
new file mode 100644
index 0000000000..fbfab043a8
--- /dev/null
+++ b/doc/board/st/stm32mp2.rst
@@ -0,0 +1,544 @@
+.. SPDX-License-Identifier: GPL-2.0-or-later
+.. sectionauthor:: Patrice Chotard <patrice.chotard@foss.st.com>
+
+STM32MP2xx boards
+=================
+
+This is a quick instruction for setup STMicroelectronics STM32MP2xx boards.
+
+Further information can be found in STMicroelectronics STM32 WIKI_.
+
+Supported devices
+-----------------
+
+U-Boot supports all the STMicroelectronics MPU with the associated boards
+
+ - STMP32MP25x SoCs:
+
+  - STM32MP257
+  - STM32MP253
+  - STM32MP251
+
+Everything is supported in Linux but U-Boot is limited to the boot device:
+
+ 1. UART
+ 2. SD card/MMC controller (SDMMC)
+ 3. NAND controller (FMC)
+ 4. NOR controller (OSPI)
+ 5. HyperFlash controller (OSPI)
+ 6. USB controller (USB_STM32_USBH)
+ 7. Ethernet controller
+
+And the necessary drivers
+
+ 1. I2C
+ 2. Clock, Reset, Sysreset
+ 3. Fuse (BSEC)
+ 4. OP-TEE
+ 5. ETH
+ 6. USB host
+ 7. WATCHDOG
+ 8. RNG
+ 9. RTC
+
+STM32MP25x
+``````````
+The STM32MP25x is a Cortex-A35 MPU aimed at various applications.
+
+It features:
+
+ - Dual core Cortex-A35 application core (Single on STM32MP251)
+ - 2D/3D image composition with GPU (only on STM32MP255 and STM32MP257)
+ - Standard memories interface support
+ - Standard connectivity, widely inherited from the STM32 MCU family
+ - Comprehensive security support
+ - Cortex M33 coprocessor
+
+Each line comes with a security option (cryptography & secure boot) and
+a Cortex-A frequency option:
+
+ - A : Cortex-A35 @ 1.2 GHz
+ - C : Secure Boot + HW Crypto + Cortex-A35 @ 1.2 GHz
+ - D : Cortex-A35 @ 1.5 GHz
+ - F : Secure Boot + HW Crypto + Cortex-A35 @ 1.5 GHz
+
+Currently the following STMicroelectronics boards are supported:
+
+ + stm32mp257f-dk.dts
+ + stm32mp257f-ev1.dts
+
+The access to reset and clock resources are provided by OP-TEE and the associated SCMI
+services.
+
+Boot Sequences
+--------------
+
+The boot chain is :
+
+- FSBL = **TF-A BL2**
+- Secure monitor = **TF-A BL31**
+- Secure OS = **OP-TEE**
+- SSBL = **U-Boot**
+
+It is the only supported boot chain for STM32MP25x family.
+
+defconfig_file :
+   + **stm32mp25_defconfig**
+
+TF-A_ and OP-TEE_ are 2 separate projects, with their git repository;
+they are compiled separately.
+
+TF-A_ (BL2) initialize the DDR and loads the next stage binaries from a FIP file:
+   + BL32: a secure monitor BL32 = OP-TEE, performs a full initialization of
+     Secure peripherals and provides service to normal world.
+   + BL33: a non-trusted firmware = U-Boot, running in normal world and uses
+     the secure monitor to access to secure resources.
+   + HW_CONFIG: The hardware configuration file = the U-Boot device tree
+
+Device Tree
+-----------
+
+All the STM32MP25x boards supported by U-Boot use the same generic board stm32mp2
+which supports all the bootable devices.
+
+Each STMicroelectronics board is only configured with the associated device tree.
+
+STM32MP25x device Tree Selection
+````````````````````````````````
+The supported device trees for STM32MP25x are:
+
++ ev1: Evaluation board
+
+   + stm32mp257f-ev1
+
++ dk: Discovery board
+
+   + stm32mp257f-dk
+
+Build Procedure
+---------------
+
+1. Install the required tools for U-Boot
+
+  * install package needed in U-Boot makefile
+    (libssl-dev, swig, libpython-dev...)
+
+  * install ARMv8 toolchain for 64bit Cortex-A (from Linaro,
+    from SDK for STM32MP25x, or any crosstoolchains from your distribution)
+    (you can use any gcc cross compiler compatible with U-Boot)
+
+2. Set the cross compiler::
+
+   # export CROSS_COMPILE=/path/to/toolchain/arm-linux-gnueabi-
+
+3. Select the output directory (optional)::
+
+   # export KBUILD_OUTPUT=/path/to/output
+
+   for example: use one output directory for each board::
+
+   # export KBUILD_OUTPUT=stm32mp257f-ev1
+   # export KBUILD_OUTPUT=stm32mp257f-dk
+
+   you can build outside of code directory::
+
+   # export KBUILD_OUTPUT=../build/stm32mp25
+
+4. Configure U-Boot::
+
+   # make <defconfig_file>
+
+   with <defconfig_file>: stm32mp25_defconfig
+
+5. Configure the device-tree and build the U-Boot image::
+
+   # make DEVICE_TREE=<name> all
+
+ 6. U-Boot Output files
+
+   In the output directory (selected by KBUILD_OUTPUT),
+   you can found the needed U-Boot files:
+
+     - stm32mp25_defconfig = **u-boot-nodtb.bin** and **u-boot.dtb**
+
+7. TF-A_ compilation
+
+   see OP-TEE_ and TF-A_ documentation for build commands.
+
+   - compile OP-TEE to generate the binary included in FIP
+
+   - after TF-A compilation, the used files are:
+
+     - TF-A_ BL2 => FSBL = **tf-a.stm32**
+
+     - FIP => **fip.bin**
+
+       FIP file includes the 2 files given in arguments of TF-A_ compilation:
+
+      - BL33=u-boot-nodtb.bin
+      - BL33_CFG=u-boot.dtb
+
+     You can also update an existing FIP after U-boot compilation with fiptool,
+     a tool provided by TF-A_::
+
+     # fiptool update --nt-fw u-boot-nodtb.bin --hw-config u-boot.dtb fip-stm32mp157c-ev1.bin
+
+8. The bootloaders files
+
++ The **ROM code** expects FSBL binaries with STM32 image header = tf-a.stm32
+
+According the FSBL / the boot mode:
+
++ **TF-A** expect a FIP binary = fip.bin, including the OS monitor (OP-TEE_) and the
+  U-Boot binary + device tree
+
+Switch Setting for Boot Mode
+----------------------------
+
+You can select the boot mode, on the board with one switch, to select
+the boot pin values = BOOT0, BOOT1, BOOT2, BOOT3
+
+  +-------------+---------+---------+---------+---------+
+  |*Boot Mode*  | *BOOT3* | *BOOT2* | *BOOT1* | *BOOT0* |
+  +=============+=========+=========+=========+=========+
+  | Recovery    |    0    |    0    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | SD-Card     |    0    |    0    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | eMMC        |    0    |    0    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    0    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | SPI-NOR     |    0    |    1    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    1    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    1    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    0    |    1    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    0    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    1    |    0    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    1    |    0    |    1    |
+  +-------------+---------+---------+---------+---------+
+  | Reserved    |    1    |    1    |    1    |    0    |
+  +-------------+---------+---------+---------+---------+
+  | Recovery    |    1    |    1    |    1    |    1    |
+  +-------------+---------+---------+---------+---------+
+
+- on the STM32MP25x **evaluation board ev1 = MB1936** with the switch SW1
+  (BOOT0, BOOT1, BOOT2, BOOT3)
+- on the STM32MP25x **discovery board dk = MB1605** with the switch SW1
+  (BOOT0, BOOT1 only)
+
+Recovery is a boot from serial link (UART/USB) and it is used with
+STM32CubeProgrammer tool to load executable in RAM and to update the flash
+devices available on the board (HyperFlash/NOR/NAND/eMMC/SD card).
+
+The communication between HOST and board is based on
+
+  - for UARTs : the uart protocol used with all MCU STM32
+  - for USB : based on USB DFU 1.1 (without the ST extensions used on MCU STM32)
+
+Prepare a SD card
+-----------------
+
+The minimal requirements for STMP32MP25x boot up to U-Boot are:
+
+- GPT partitioning (with gdisk or with sgdisk)
+- 2 fsbl partitions, named "fsbla1" and "fsbla2", size at least 256KiB (2 copies for
+  redundancy)
+- 2 metadata partitions for FIP update support, named "metadata1" and "metadata2",
+  size at least 256KiB (2 copies for redundancy)
+- 2 fip partitions named "fip-a" and "fip-b" for FIP binary
+- 1 environment partition named "u-boot-env"
+
+The 2 fsbl partitions have the same content and are present to guarantee a
+fail-safe update of FSBL; fsbl2 can be omitted if this ROM code feature is
+not required.
+
+Then the minimal GPT partition is:
+
+  +-------+------------+---------+------------------------+
+  | *Num* |   *Name*   | *Size*  | *Content*              |
+  +=======+============+=========+========================+
+  | 1     |   fsbla1   | 256 KiB | TF-A_ BL2 (tf-a.stm32) |
+  +-------+------------+---------+------------------------+
+  | 2     |   fsbla2   | 256 KiB | TF-A_ BL2 (tf-a.stm32) |
+  +-------+------------+---------+------------------------+
+  | 3     | metadata1  | 256 KiB |                        |
+  +-------+------------+---------+------------------------+
+  | 4     | metadata1  | 256 KiB |                        |
+  +-------+------------+---------+------------------------+
+  | 5     |   fip-a    |   4 MiB |       fip.bin          |
+  +-------+------------+---------+------------------------+
+  | 6     |   fip-b    |   4 MiB |       fip.bin          |
+  +-------+------------+---------+------------------------+
+  | 7     | u-boot-env |  512 KiB|                        |
+  +-------+------------+---------+------------------------+
+  | 8     |   <any>    |  <any>  | Rootfs                 |
+  +-------+------------+---------+------------------------+
+
+And the 8th partition (Rootfs) is marked bootable with a file extlinux.conf
+following the Generic Distribution feature (see :doc:`../../develop/distro` for
+use).
+
+The size of fip partition must be enough for the associated binary file,
+4MB is the default value.
+
+According the used card reader select the correct block device
+(for example /dev/sdx or /dev/mmcblk0), in the next example, it is /dev/mmcblk0
+
+For example:
+
+a) remove previous formatting::
+
+    # sgdisk -o /dev/<SD card dev>
+
+b) create minimal image for FIP
+
+   For FIP support in TF-A_::
+
+    # sgdisk --resize-table=128 -a 1 \
+    -n 1:34:545	                -c 1:fsbla1 \
+    -n 2:546:1057		-c 2:fsbla2 \
+    -n 3:1058:1569              -c 3:metadata1 \
+    -n 4:1570:2081		-c 4:metadata2 \
+    -n 5:2082:10273		-c 5:fip-a \
+    -n 6:10274:18465		-c 6:fip-b \
+    -n 7:18466:19489		-c 7:u-boot-env \
+    -n 8:19490:			-c 8:rootfs -A 4:set:2 \
+    -p /dev/<SD card dev>
+
+   With gpt table with 128 entries an the partition 4 marked bootable (bit 2).
+
+c) copy the FSBL (2 times) and SSBL file on the correct partition.
+   in this example in partition 1 to 6::
+
+    # dd if=tf-a.stm32 of=/dev/mmcblk0p1
+    # dd if=tf-a.stm32 of=/dev/mmcblk0p2
+    # dd if=fip.bin of=/dev/mmcblk0p5
+    # dd if=fip.bin of=/dev/mmcblk0p6
+
+To boot from SD card, select BootPinMode = 1 0 0 0 and reset.
+
+Prepare eMMC
+------------
+
+You can use U-Boot to copy binary in eMMC.
+
+In the next example, you need to boot from SD card and the images
+(tf-a.stm32, metadata, fip.bin, u-boot.img are presents on SD card
+(mmc 0) in ext4 partition 4 (bootfs)
+
+To boot from SD card, select BootPinMode = 1 0 0 0 and reset.
+
+Then you update the eMMC with the next U-Boot command :
+
+a) prepare GPT on eMMC,
+   example with 3 partitions, fip, bootfs and roots::
+
+    # setenv emmc_part "name==metadata1,size=256KiB;name=metada2,size=256KiB;name=fip-a,size=4MiB;name=fip-b,size=4MiB;name=bootfs,type=linux,bootable,size=64MiB;name=rootfs,type=linux,size=512"
+    # gpt write mmc 1 ${emmc_part}
+
+b) copy FSBL ( TF-A_ ) in first eMMC boot partition::
+
+    # ext4load mmc 0:4 0xC0000000 tf-a.stm32
+
+    # mmc dev 1
+    # mmc partconf 1 1 1 1
+    # mmc write ${fileaddr} 0 200
+    # mmc partconf 1 1 1 0
+
+c) copy SSBL ( FIP ) in fip-a GPT partition of eMMC::
+
+    # ext4load mmc 0:4 0xC0000000 fip.bin
+
+    # mmc dev 1
+    # part start mmc 1 fip-a partstart
+    # mmc write ${fileaddr} ${partstart} ${filesize}
+
+To boot from eMMC, select BootPinMode = 0 0 1 0 and reset.
+
+Coprocessor firmware on STM32MP25x
+----------------------------------
+
+U-Boot can boot the coprocessor before the kernel (coprocessor early boot) by using rproc commands (update the bootcmd)
+
+   Configurations::
+
+	# env set name_copro "rproc-m33-fw_sign.bin"
+	# env set dev_copro 0
+	# env set loadaddr_copro ${kernel_addr_r}
+
+   Load binary from bootfs partition on SD card (mmc 0)::
+
+	# load mmc 0#bootfs ${loadaddr_copro} ${name_copro}
+
+   => ${filesize} variable is updated with the size of the loaded file.
+
+   Start M33 firmware with remote proc command::
+
+	# rproc init
+	# rproc load ${dev_copro} ${loadaddr_copro} ${filesize}
+	# rproc start ${dev_copro}"0
+
+DFU support
+-----------
+
+The DFU is supported on ST board.
+
+The env variable dfu_alt_info is automatically build, and all
+the memory present on the ST boards are exported.
+
+The dfu mode is started by the command::
+
+  STM32MP> dfu 0
+
+On EV1 board, booting from SD card::
+
+  STM32MP> dfu 0 list
+  DFU alt settings list:
+
+dev: RAM alt: 0 name: uImage layout: RAM_ADDR
+dev: RAM alt: 1 name: devicetree.dtb layout: RAM_ADDR
+dev: RAM alt: 2 name: uramdisk.image.gz layout: RAM_ADDR
+dev: eMMC alt: 3 name: mmc0_fsbla1 layout: RAW_ADDR
+dev: eMMC alt: 4 name: mmc0_fsbla2 layout: RAW_ADDR
+dev: eMMC alt: 5 name: mmc0_metadata1 layout: RAW_ADDR
+dev: eMMC alt: 6 name: mmc0_metadata2 layout: RAW_ADDR
+dev: eMMC alt: 7 name: mmc0_fip-a layout: RAW_ADDR
+dev: eMMC alt: 8 name: mmc0_fip-b layout: RAW_ADDR
+dev: eMMC alt: 9 name: mmc0_u-boot-env layout: RAW_ADDR
+dev: eMMC alt: 10 name: mmc0_bootfs layout: RAW_ADDR
+dev: eMMC alt: 11 name: mmc0_vendorfs layout: RAW_ADDR
+dev: eMMC alt: 12 name: mmc0_rootfs layout: RAW_ADDR
+dev: eMMC alt: 13 name: mmc0_userfs layout: RAW_ADDR
+dev: eMMC alt: 14 name: mmc1_boot1 layout: RAW_ADDR
+dev: eMMC alt: 15 name: mmc1_boot2 layout: RAW_ADDR
+dev: eMMC alt: 16 name: mmc1_fip layout: RAW_ADDR
+dev: eMMC alt: 17 name: mmc1_bootfs layout: RAW_ADDR
+dev: eMMC alt: 18 name: mmc1_vendorfs layout: RAW_ADDR
+dev: eMMC alt: 19 name: mmc1_rootfs layout: RAW_ADDR
+dev: eMMC alt: 20 name: mmc1_test_report layout: RAW_ADDR
+dev: eMMC alt: 21 name: mmc1_backup layout: RAW_ADDR
+dev: MTD alt: 22 name: nor1 layout: RAW_ADDR
+dev: MTD alt: 23 name: nor1_fsbla1 layout: RAW_ADDR
+dev: MTD alt: 24 name: nor1_fsbla2 layout: RAW_ADDR
+dev: MTD alt: 25 name: nor1_metadata1 layout: RAW_ADDR
+dev: MTD alt: 26 name: nor1_metadata2 layout: RAW_ADDR
+dev: MTD alt: 27 name: nor1_fip-a layout: RAW_ADDR
+dev: MTD alt: 28 name: nor1_fip-b layout: RAW_ADDR
+dev: MTD alt: 29 name: nor1_u-boot-env layout: RAW_ADDR
+dev: MTD alt: 30 name: nor1_nor-user layout: RAW_ADDR
+dev: VIRT alt: 31 name: OTP layout: RAW_ADDR
+
+All the supported device are exported for dfu-util tool::
+
+  $> dfu-util -l
+
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=31, name="OTP", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=30, name="nor1_nor-user", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=29, name="nor1_u-boot-env", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=28, name="nor1_fip-b", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=27, name="nor1_fip-a", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=26, name="nor1_metadata2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=25, name="nor1_metadata1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=24, name="nor1_fsbla2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=23, name="nor1_fsbla1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=22, name="nor1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=21, name="mmc1_backup", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=20, name="mmc1_test_report", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=19, name="mmc1_rootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=18, name="mmc1_vendorfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=17, name="mmc1_bootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=16, name="mmc1_fip", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=15, name="mmc1_boot2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=14, name="mmc1_boot1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=13, name="mmc0_userfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=12, name="mmc0_rootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=11, name="mmc0_vendorfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=10, name="mmc0_bootfs", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=9, name="mmc0_u-boot-env", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=8, name="mmc0_fip-b", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=7, name="mmc0_fip-a", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=6, name="mmc0_metadata2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=5, name="mmc0_metadata1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=4, name="mmc0_fsbla2", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=3, name="mmc0_fsbla1", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=2, name="uramdisk.image.gz", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=1, name="devicetree.dtb", serial="004A00253836500B00343046"
+  Found DFU: [0483:df11] ver=0200, devnum=21, cfg=1, intf=0, path="3-6.1", alt=0, name="uImage", serial="004A00253836500B00343046"
+
+You can update the boot device:
+
+- SD card (mmc0)::
+
+  $> dfu-util -d 0483:df11 -a 3 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 4 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 5 -D fip-stm32mp257f-ev1.bin
+  $> dfu-util -d 0483:df11 -a 10 -D st-image-bootfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 11 -D st-image-vendorfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 12 -D st-image-weston-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 13 -D st-image-userfs-openstlinux-weston-stm32mp2.ext4
+
+- EMMC (mmc1)::
+
+  $> dfu-util -d 0483:df11 -a 14 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 15 -D tf-a-stm32mp257f-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 16 -D fip-stm32mp257f-ev1.bin
+  $> dfu-util -d 0483:df11 -a 17 -D st-image-bootfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 18 -D st-image-vendorfs-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 19 -D st-image-weston-openstlinux-weston-stm32mp2.ext4
+  $> dfu-util -d 0483:df11 -a 20 -D st-image-userfs-openstlinux-weston-stm32mp2.ext4
+
+- you can also dump the OTP and the PMIC NVM with::
+
+  $> dfu-util -d 0483:df11 -a 31 -U otp.bin
+
+When the board is booting for nor1, only the MTD partition on the boot devices are available, for example:
+
+- NOR (nor1 = alt 15) :
+
+  $> dfu-util -d 0483:df11 -a 16 -D tf-a-stm32mp157c-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 17 -D tf-a-stm32mp157c-ev1.stm32
+  $> dfu-util -d 0483:df11 -a 20 -D fip-stm32mp157c-ev1.bin
+  $> dfu-util -d 0483:df11 -a 23 -D st-image-weston-openstlinux-weston-stm32mp1_nand_4_256_multivolume.ubi
+
+References
+----------
+
+.. _WIKI:
+
+STM32 Arm® Cortex®-based MPUs user guide
+
+  + https://wiki.st.com/
+  + https://wiki.st.com/stm32mpu/wiki/Main_Page
+
+.. _TF-A:
+
+TF-A = The Trusted Firmware-A project provides a reference implementation of
+secure world software for Armv7-A and Armv8-A class processors
+
+  + https://www.trustedfirmware.org/projects/tf-a/
+  + https://trustedfirmware-a.readthedocs.io/en/latest/
+  + https://trustedfirmware-a.readthedocs.io/en/latest/plat/stm32mp2.html
+  + https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/
+
+.. _OP-TEE:
+
+OP-TEE = an open source Trusted Execution Environment (TEE) implementing the
+Arm TrustZone technology
+
+  + https://www.op-tee.org/
+  + https://optee.readthedocs.io/en/latest/
+  + https://optee.readthedocs.io/en/latest/building/devices/stm32mp2.html
+  + https://github.com/OP-TEE/optee_os
diff --git a/doc/board/tbs/tbs2910.rst b/doc/board/tbs/tbs2910.rst
index e97f2b6e61..9d4be61783 100644
--- a/doc/board/tbs/tbs2910.rst
+++ b/doc/board/tbs/tbs2910.rst
@@ -181,7 +181,7 @@ If that fails it will then try to boot from several interfaces using
 'distro_bootcmd': It will first try to boot from the microSD slot, then the
 SD slot, then the internal eMMC, then the SATA interface and finally the USB
 interface. For more information on how to configure your distribution to boot,
-see 'README.distro'.
+see 'doc/develop/distro.rst'.
 
 Links:
 ------
diff --git a/doc/develop/uefi/fwu_updates.rst b/doc/develop/uefi/fwu_updates.rst
new file mode 100644
index 0000000000..4ce28df13d
--- /dev/null
+++ b/doc/develop/uefi/fwu_updates.rst
@@ -0,0 +1,194 @@
+.. SPDX-License-Identifier: GPL-2.0+
+.. Copyright (c) 2022 Linaro Limited
+
+FWU Multi Bank Updates in U-Boot
+================================
+
+The FWU Multi Bank Update feature implements the firmware update
+mechanism described in the PSA Firmware Update for A-profile Arm
+Architecture specification [1]. Certain aspects of the Dependable
+Boot specification [2] are also implemented. The feature provides a
+mechanism to have multiple banks of updatable firmware images and for
+updating the firmware images on the non-booted bank. On a successful
+update, the platform boots from the updated bank on subsequent
+boot. The UEFI capsule-on-disk update feature is used for performing
+the actual updates of the updatable firmware images.
+
+The bookkeeping of the updatable images is done through a structure
+called metadata. Currently, the FWU metadata supports identification
+of images based on image GUIDs stored on a GPT partitioned storage
+media. There are plans to extend the metadata structure for non GPT
+partitioned devices as well.
+
+Accessing the FWU metadata is done through generic API's which are
+defined in a driver which complies with the U-Boot's driver model. A
+new uclass UCLASS_FWU_MDATA has been added for accessing the FWU
+metadata. Individual drivers can be added based on the type of storage
+media, and its partitioning method. Details of the storage device
+containing the FWU metadata partitions are specified through a U-Boot
+specific device tree property `fwu-mdata-store`. Please refer to
+U-Boot `doc <doc/device-tree-bindings/firmware/fwu-mdata-gpt.yaml>`__
+for the device tree bindings.
+
+Enabling the FWU Multi Bank Update feature
+------------------------------------------
+
+The feature can be enabled by specifying the following configs::
+
+    CONFIG_EFI_CAPSULE_ON_DISK=y
+    CONFIG_EFI_CAPSULE_FIRMWARE_MANAGEMENT=y
+    CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
+
+    CONFIG_FWU_MULTI_BANK_UPDATE=y
+    CONFIG_FWU_MDATA=y
+    CONFIG_FWU_MDATA_GPT_BLK=y
+    CONFIG_FWU_NUM_BANKS=<val>
+    CONFIG_FWU_NUM_IMAGES_PER_BANK=<val>
+
+    CONFIG_FWU_MDATA_V1=y or CONFIG_FWU_MDATA_V2=y
+
+in the .config file
+
+By enabling the CONFIG_CMD_FWU_METADATA config option, the
+fwu_mdata_read command can be used to check the current state of the
+FWU metadata structure.
+
+The first group of configuration settings enable the UEFI
+capsule-on-disk update functionality. The second group of configs
+enable the FWU Multi Bank Update functionality. Please refer to the
+section :ref:`uefi_capsule_update_ref` for more details on generation
+of the UEFI capsule.
+
+FWU Metadata
+------------
+
+U-Boot supports both versions(1 and 2) of the FWU metadata defined in
+the two revisions of the specification. Support can be enabled for
+either of the two versions through a config flag. The mkfwumdata tool
+can generate metadata for both the supported versions.
+
+Setting up the device for GPT partitioned storage
+-------------------------------------------------
+
+Before enabling the functionality in U-Boot, a GPT partitioned storage
+device is required. Assuming a GPT partitioned storage device, the
+storage media needs to be partitioned with the correct number of
+partitions, given the number of banks and number of images per bank
+that the platform is going to support. Each updatable firmware image
+will be stored on a separate partition. In addition, the two copies
+of the FWU metadata will be stored on two separate partitions. These
+partitions need to be created at the time of the platform's
+provisioning.
+
+As an example, a platform supporting two banks with each bank
+containing three images would need to have 2 * 3 = 6 partitions plus
+the two metadata partitions, or 8 partitions. In addition the storage
+media can have additional partitions of non-updatable images, like the
+EFI System Partition(ESP), a partition for the root file system
+etc. An example list of images on the storage medium would be
+
+* FWU metadata 1
+* U-Boot 1
+* OP-TEE 1
+* FWU metadata 2
+* OP-TEE 2
+* U-Boot 2
+* ESP
+* rootfs
+
+When generating the partitions, a few aspects need to be taken care
+of. Each GPT partition entry in the GPT header has two GUIDs::
+
+* PartitionTypeGUID
+* UniquePartitionGUID
+
+The PartitionTypeGUID value should correspond to the
+``image_type_guid`` field of the FWU metadata. This field is used to
+identify a given type of updatable firmware image, e.g. U-Boot,
+OP-TEE, FIP etc. This GUID should also be used for specifying the
+`--guid` parameter when generating the capsule.
+
+The UniquePartitionGUID value should correspond to the ``image_guid``
+field in the FWU metadata. This GUID is used to identify images of a
+given image type in different banks.
+
+The FWU specification defines the GUID value to be used for the
+metadata partitions. This would be the PartitionTypeGUID for the
+metadata partitions. Similarly, the UEFI specification defines the ESP
+GUID to be be used.
+
+When generating the metadata, the ``image_type_guid`` and the
+``image_guid`` values should match the *PartitionTypeGUID* and the
+*UniquePartitionGUID* values respectively.
+
+Performing the Update
+---------------------
+
+Once the storage media has been partitioned and populated with the
+metadata partitions, the UEFI capsule-on-disk update functionality can
+be used for performing the update. Refer to the section
+:ref:`uefi_capsule_update_ref` for details on how the update can be
+invoked.
+
+On a successful update, the FWU metadata gets updated to reflect the
+bank from which the platform would be booting on subsequent boot.
+
+Based on the value of bit15 of the Flags member of the capsule header,
+the updated images would either be accepted by the U-Boot's UEFI
+implementation, or by the Operating System. If the Operating System is
+accepting the firmware images, it does so by generating an empty
+*accept* capsule. The Operating System can also reject the updated
+firmware by generating a *revert* capsule. The empty capsule can be
+applied by using the exact same procedure used for performing the
+capsule-on-disk update.
+
+The task of accepting the different firmware images, post an update
+may be done by multiple, separate components in the Operating
+System. To help identify the firmware image that is being accepted,
+the accept capsule passes the image GUID of the firmware image being
+accepted. The relevant code in U-Boot then sets the Accept bit of the
+corresponding firmware image for which the accept capsule was
+found. Only when all the firmware components in a bank have been
+accepted does the platform transition from trial state to regular
+state.
+
+The revert capsule on the other hand does not pass any image GUID,
+since reverting any image of the bank has the same result of the
+platform booting from the other bank on subsequent boot.
+
+In the scenario that bit15 of the Flags member of the capsule header
+has not been set, the images being updated are accepted by the
+U-Boot's UEFI firmware implementation by default, on successful
+update of the image.
+
+Generating an empty capsule
+---------------------------
+
+The empty capsule can be generated using the mkeficapsule utility. To
+build the tool, enable::
+
+    CONFIG_TOOLS_MKEFICAPSULE=y
+
+Run the following commands to generate the accept/revert capsules::
+
+.. code-block:: bash
+
+    $ ./tools/mkeficapsule \
+      [--fw-accept --guid <image guid>] | \
+      [--fw-revert] \
+      <capsule_file_name>
+
+Some examples of using the mkeficapsule tool for generation of the
+empty capsule would be::
+
+.. code-block:: bash
+
+    $ ./tools/mkeficapsule --fw-accept --guid <image guid> \
+    <accept_capsule_name>
+    $ ./tools/mkeficapsule --fw-revert <revert_capsule_name>
+
+Links
+-----
+
+* [1] https://developer.arm.com/documentation/den0118/ - FWU Specification
+* [2] https://git.codelinaro.org/linaro/dependable-boot/mbfw/uploads/6f7ddfe3be24e18d4319e108a758d02e/mbfw.pdf - Dependable Boot Specification
diff --git a/doc/develop/uefi/index.rst b/doc/develop/uefi/index.rst
index 7e65dbc5d5..e26b1fbe05 100644
--- a/doc/develop/uefi/index.rst
+++ b/doc/develop/uefi/index.rst
@@ -13,3 +13,4 @@ can be run an UEFI payload.
    uefi.rst
    u-boot_on_efi.rst
    iscsi.rst
+   fwu_updates.rst
diff --git a/doc/develop/uefi/uefi.rst b/doc/develop/uefi/uefi.rst
index 941e427093..f4c4e782bf 100644
--- a/doc/develop/uefi/uefi.rst
+++ b/doc/develop/uefi/uefi.rst
@@ -277,6 +277,8 @@ Enable ``CONFIG_OPTEE``, ``CONFIG_CMD_OPTEE_RPMB`` and ``CONFIG_EFI_MM_COMM_TEE`
 
 [1] https://optee.readthedocs.io/en/latest/building/efi_vars/stmm.html
 
+.. _uefi_capsule_update_ref:
+
 Enabling UEFI Capsule Update feature
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -316,6 +318,33 @@ Run the following command
       --guid <image GUID> \
       <capsule_file_name>
 
+The UEFI specification does not define the firmware versioning mechanism.
+EDK II reference implementation inserts the FMP Payload Header right before
+the payload. It coutains the fw_version and lowest supported version,
+EDK II reference implementation uses these information to implement the
+firmware versioning and anti-rollback protection, the firmware version and
+lowest supported version is stored into EFI non-volatile variable.
+
+In U-Boot, the firmware versioning is implemented utilizing
+the FMP Payload Header same as EDK II reference implementation,
+reads the FMP Payload Header and stores the firmware version into
+"FmpStateXXXX" EFI non-volatile variable. XXXX indicates the image index,
+since FMP protocol handles multiple image indexes.
+
+To add the fw_version into the FMP Payload Header,
+add --fw-version option in mkeficapsule tool.
+
+.. code-block:: console
+
+    $ mkeficapsule \
+      --index <index> --instance 0 \
+      --guid <image GUID> \
+      --fw-version 5 \
+      <capsule_file_name>
+
+If the --fw-version option is not set, FMP Payload Header is not inserted
+and fw_version is set as 0.
+
 Performing the update
 *********************
 
@@ -377,6 +406,16 @@ following command::
 
     dfu list
 
+When the FWU Multi Bank Update feature is enabled on the platform, the
+image index is used only to identify the image index with the image
+GUID. The image index would not correspond to the dfu alt number. This
+is because the FWU feature supports multiple partitions(banks) of
+updatable images, and the actual dfu alt number to which the image is
+to be written to is determined at runtime, based on the value of the
+update bank to which the image is to be written. For more information
+on the FWU Multi Bank Update feature, please refer `doc
+<doc/develop/uefi/fwu_updates.rst>`__.
+
 When using the FMP for FIT images, the image index value needs to be
 set to 1.
 
@@ -498,6 +537,45 @@ where signature.dts looks like::
             };
     };
 
+Anti-rollback Protection
+************************
+
+Anti-rollback prevents unintentional installation of outdated firmware.
+To enable anti-rollback, you must add the lowest-supported-version property
+to dtb and specify --fw-version when creating a capsule file with the
+mkeficapsule tool.
+When executing capsule update, U-Boot checks if fw_version is greater than
+or equal to lowest-supported-version. If fw_version is less than
+lowest-supported-version, the update will fail.
+For example, if lowest-supported-version is set to 7 and you run capsule
+update using a capsule file with --fw-version of 5, the update will fail.
+When the --fw-version in the capsule file is updated, lowest-supported-version
+in the dtb might be updated accordingly.
+
+To insert the lowest supported version into a dtb
+
+.. code-block:: console
+
+    $ dtc -@ -I dts -O dtb -o version.dtbo version.dts
+    $ fdtoverlay -i orig.dtb -o new.dtb -v version.dtbo
+
+where version.dts looks like::
+
+    /dts-v1/;
+    /plugin/;
+    &{/} {
+            firmware-version {
+                    image1 {
+                            image-type-id = "09D7CF52-0720-4710-91D1-08469B7FE9C8";
+                            image-index = <1>;
+                            lowest-supported-version = <3>;
+                    };
+            };
+    };
+
+The properties of image-type-id and image-index must match the value
+defined in the efi_fw_image array as image_type_id and image_index.
+
 Executing the boot manager
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
diff --git a/doc/device-tree-bindings/firmware/firmware-version.txt b/doc/device-tree-bindings/firmware/firmware-version.txt
new file mode 100644
index 0000000000..ee90ce3117
--- /dev/null
+++ b/doc/device-tree-bindings/firmware/firmware-version.txt
@@ -0,0 +1,22 @@
+firmware-version bindings
+-------------------------------
+
+Required properties:
+- image-type-id			: guid for image blob type
+- image-index			: image index
+- lowest-supported-version	: lowest supported version
+
+Example:
+
+	firmware-version {
+		image1 {
+			image-type-id = "09D7CF52-0720-4710-91D1-08469B7FE9C8";
+			image-index = <1>;
+			lowest-supported-version = <3>;
+		};
+		image2 {
+			image-type-id = "5A7021F5-FEF2-48B4-AABA-832E777418C0";
+			image-index = <2>;
+			lowest-supported-version = <7>;
+		};
+	};
diff --git a/doc/device-tree-bindings/firmware/fwu-mdata-gpt.yaml b/doc/device-tree-bindings/firmware/fwu-mdata-gpt.yaml
new file mode 100644
index 0000000000..0735191ff1
--- /dev/null
+++ b/doc/device-tree-bindings/firmware/fwu-mdata-gpt.yaml
@@ -0,0 +1,32 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/firmware/fwu-mdata-gpt.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: FWU metadata on device with GPT partitioned layout
+
+maintainers:
+ - Sughosh Ganu <sughosh.ganu@linaro.org>
+
+properties:
+  compatible:
+    items:
+      - const: u-boot,fwu-mdata-gpt
+
+  fwu-mdata-store:
+    maxItems: 1
+    description: Phandle of the device which contains the FWU medatata partition.
+
+required:
+  - compatible
+  - fwu-mdata-store
+
+additionalProperties: false
+
+examples:
+  - |
+    fwu-mdata {
+        compatible = "u-boot,fwu-mdata-gpt";
+        fwu-mdata-store = <&sdmmc1>;
+    };
diff --git a/doc/device-tree-bindings/firmware/fwu-mdata-mtd.yaml b/doc/device-tree-bindings/firmware/fwu-mdata-mtd.yaml
index 4f5404f999..6a22aeea30 100644
--- a/doc/device-tree-bindings/firmware/fwu-mdata-mtd.yaml
+++ b/doc/device-tree-bindings/firmware/fwu-mdata-mtd.yaml
@@ -1,13 +1,13 @@
 # SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
 %YAML 1.2
 ---
-$id: http://devicetree.org/schemas/firmware/u-boot,fwu-mdata-sf.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
+$id: http://devicetree.org/schemas/firmware/u-boot,fwu-mdata-mtd.yaml#
+$schema: http://devicetree.org/meta-schemas/base.yaml#
 
 title: FWU metadata on MTD device without GPT
 
 maintainers:
- - Masami Hiramatsu <masami.hiramatsu@linaro.org>
+ - Jassi Brar <jaswinder.singh@linaro.org>
 
 properties:
   compatible:
@@ -15,24 +15,101 @@ properties:
       - const: u-boot,fwu-mdata-mtd
 
   fwu-mdata-store:
-    maxItems: 1
-    description: Phandle of the MTD device which contains the FWU medatata.
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description: Phandle of the MTD device which contains the FWU MetaData and Banks.
 
-  mdata-offsets:
+  mdata-parts:
+    $ref: /schemas/types.yaml#/definitions/non-unique-string-array
     minItems: 2
-    description: Offsets of the primary and secondary FWU metadata in the NOR flash.
+    maxItems: 2
+    description: labels of the primary and secondary FWU metadata partitions in the 'fixed-partitions' subnode of the 'jedec,spi-nor' flash device node.
+
+  patternProperties:
+    "fwu-bank[0-9]":
+    type: object
+    description: List of FWU mtd-backed banks. Typically two banks.
+
+    properties:
+      id:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        description: Index of the bank.
+
+      label:
+        $ref: /schemas/types.yaml#/definitions/non-unique-string-array
+        minItems: 1
+        maxItems: 1
+        description: label of the partition, in the 'fixed-partitions' subnode of the 'jedec,spi-nor' flash device node, that holds this bank.
+
+      patternProperties:
+        "fwu-image[0-9]":
+        type: object
+        description: List of images in the FWU mtd-backed bank.
+
+        properties:
+          id:
+            $ref: /schemas/types.yaml#/definitions/uint32
+            description: Index of the bank.
+
+          offset:
+            $ref: /schemas/types.yaml#/definitions/uint32
+            description: Offset, from start of the bank, where the image is located.
+
+          size:
+            $ref: /schemas/types.yaml#/definitions/uint32
+            description: Size reserved for the image.
+
+          uuid:
+            $ref: /schemas/types.yaml#/definitions/non-unique-string-array
+            minItems: 1
+            maxItems: 1
+            description: UUID of the image.
+
+        required:
+          - id
+          - offset
+          - size
+          - uuid
+        additionalProperties: false
+
+    required:
+      - id
+      - label
+      - fwu-images
+    additionalProperties: false
 
 required:
   - compatible
   - fwu-mdata-store
-  - mdata-offsets
-
+  - mdata-parts
+  - fwu-banks
 additionalProperties: false
 
 examples:
   - |
-    fwu-mdata {
-        compatible = "u-boot,fwu-mdata-mtd";
-        fwu-mdata-store = <&spi-flash>;
-        mdata-offsets = <0x500000 0x530000>;
-    };
+	fwu-mdata {
+		compatible = "u-boot,fwu-mdata-mtd";
+		fwu-mdata-store = <&flash0>;
+		mdata-parts = "MDATA-Pri", "MDATA-Sec";
+
+		fwu-bank0 {
+			id = <0>;
+			label = "FIP-Bank0";
+			fwu-image0 {
+				id = <0>;
+				offset = <0x0>;
+				size = <0x400000>;
+				uuid = "5a66a702-99fd-4fef-a392-c26e261a2828";
+			};
+		};
+		fwu-bank1 {
+			id = <1>;
+			label = "FIP-Bank1";
+			fwu-image0 {
+				id = <0>;
+				offset = <0x0>;
+				size = <0x400000>;
+				uuid = "a8f868a1-6e5c-4757-878d-ce63375ef2c0";
+			};
+		};
+	};
+...
diff --git a/doc/mkeficapsule.1 b/doc/mkeficapsule.1
index 09bdc24295..e02e743d63 100644
--- a/doc/mkeficapsule.1
+++ b/doc/mkeficapsule.1
@@ -8,7 +8,7 @@ mkeficapsule \- Generate EFI capsule file for U-Boot
 
 .SH SYNOPSIS
 .B mkeficapsule
-.RI [ options "] " image-blob " " capsule-file
+.RI [ options ] " " [ image-blob ] " " capsule-file
 
 .SH "DESCRIPTION"
 .B mkeficapsule
@@ -23,8 +23,13 @@ Optionally, a capsule file can be signed with a given private key.
 In this case, the update will be authenticated by verifying the signature
 before applying.
 
+Additionally, an empty capsule file can be generated for acceptance or
+rejection of firmware images by a governing component like an Operating
+System. The empty capsules do not require an image-blob input file.
+
+
 .B mkeficapsule
-takes any type of image files, including:
+takes any type of image files when generating non empty capsules, including:
 .TP
 .I raw image
 format is a single binary blob of any type of firmware.
@@ -36,18 +41,16 @@ multiple binary blobs in a single capsule file.
 This type of image file can be generated by
 .BR mkimage .
 
-.PP
-If you want to use other types than above two, you should explicitly
-specify a guid for the FMP driver.
-
 .SH "OPTIONS"
+
 .TP
 .BI "-g\fR,\fB --guid " guid-string
 Specify guid for image blob type. The format is:
     xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
 
 The first three elements are in little endian, while the rest
-is in big endian.
+is in big endian. The option must be specified for all non empty and
+image acceptance capsules
 
 .TP
 .BI "-i\fR,\fB --index " index
@@ -57,6 +60,32 @@ Specify an image index
 .BI "-I\fR,\fB --instance " instance
 Specify a hardware instance
 
+.PP
+FMP Payload Header is inserted right before the payload if
+.BR --fw-version
+is specified
+
+
+.TP
+.BI "-v\fR,\fB --fw-version " firmware-version
+Specify a firmware version, 0 if omitted
+
+.PP
+For generation of firmware accept empty capsule
+.BR --guid
+is mandatory
+.TP
+.BI "-A\fR,\fB --fw-accept "
+Generate a firmware acceptance empty capsule
+
+.TP
+.BI "-R\fR,\fB --fw-revert "
+Generate a firmware revert empty capsule
+
+.TP
+.BI "-o\fR,\fB --capoemflag "
+Capsule OEM flag, value between 0x0000 to 0xffff
+
 .TP
 .BR -h ", " --help
 Print a help message
diff --git a/doc/mkfwumdata.1 b/doc/mkfwumdata.1
new file mode 100644
index 0000000000..2ed0fb100b
--- /dev/null
+++ b/doc/mkfwumdata.1
@@ -0,0 +1,103 @@
+.\" SPDX-License-Identifier: GPL-2.0-or-later
+.\" Copyright (C) 2023 Jassi Brar <jaswinder.singh@linaro.org>
+.TH MKFWUMDATA 1 2023-04-10 U-Boot
+.SH NAME
+mkfwumdata \- create FWU metadata image
+.
+.SH SYNOPSIS
+.SY mkfwumdata
+.OP \-v version
+.OP \-a activeidx
+.OP \-p previousidx
+.OP \-g
+.OP \-V vendor-file
+.BI \-i\~ imagecount
+.BI \-b\~ bankcount
+.I UUIDs
+.I outputimage
+.YS
+.SY mkfwumdata
+.B \-h
+.YS
+.
+.SH DESCRIPTION
+.B mkfwumdata
+creates metadata info to be used with FWU.
+.
+.SH OPTIONS
+.TP
+.B \-h
+Print usage information and exit.
+.
+.TP
+.B \-v
+Set 
+.IR version
+as the metadata version to generate. Valid values 1 or 2.
+.
+.TP
+.B \-a
+Set 
+.IR activeidx
+as the currently active Bank. Default is 0.
+.
+.TP
+.B \-p
+Set 
+.IR previousidx
+as the previous active Bank. Default is
+.IR activeidx "-1"
+or
+.IR bankcount "-1,"
+whichever is non-negative.
+.
+.TP
+.B \-g
+Convert the
+.IR UUIDs
+as GUIDs before use.
+.
+.TP
+.B \-V
+Pass
+.IR vendor-file
+for appending vendor data to the metadata. Supported only with version 2.
+.
+.TP
+.B \-i
+Specify there are
+.IR imagecount
+images in each bank.
+.
+.TP
+.B \-b
+Specify there are a total of
+.IR bankcount
+banks.
+.
+.TP
+.IR UUIDs
+Comma-separated list of UUIDs required to create the metadata :-
+location_uuid,image_type_uuid,<images per bank uuid list of all banks>
+.
+.TP
+.IR outputimage
+Specify the name of the metadata image file to be created.
+.
+.SH BUGS
+Please report bugs to the
+.UR https://\:source\:.denx\:.de/\:u-boot/\:u-boot/\:issues
+U-Boot bug tracker
+.UE .
+.SH EXAMPLES
+Create a metadata image with 2 banks and 1 image/bank, BankAct=0, BankPrev=1:
+.PP
+.EX
+.in +4
+$ \c
+.B mkfwumdata \-v 2 \-a 0 \-p 1 \-b 2 \-i 1 \\\\\&
+.in +6
+.B 17e86d77-41f9-4fd7-87ec-a55df9842de5,\\\\\&
+.B 10c36d7d-ca52-b843-b7b9-f9d6c501d108,\\\\\&
+.B 5a66a702-99fd-4fef-a392-c26e261a2828,a8f868a1-6e5c-4757-878d-ce63375ef2c0 \\\\\&
+.B fwu-mdata.img
diff --git a/doc/usage/cmd/fwu_mdata.rst b/doc/usage/cmd/fwu_mdata.rst
new file mode 100644
index 0000000000..ea3c22724a
--- /dev/null
+++ b/doc/usage/cmd/fwu_mdata.rst
@@ -0,0 +1,43 @@
+.. SPDX-License-Identifier: GPL-2.0+
+
+fwu_mdata_read command
+======================
+
+Synopsis
+--------
+
+::
+
+    fwu_mdata_read
+
+Description
+-----------
+
+The fwu_mdata_read command is used to read the FWU metadata
+structure. The command prints out information about the current active
+bank, the previous active bank, image GUIDs, image acceptance etc.
+
+The output may look like:
+
+::
+
+    => fwu_mdata_read
+            FWU Metadata
+    crc32: 0xec4fb997
+    version: 0x1
+    active_index: 0x0
+    previous_active_index: 0x1
+            Image Info
+
+    Image Type Guid: 19D5DF83-11B0-457B-BE2C-7559C13142A5
+    Location Guid: 49272BEB-8DD8-46DF-8D75-356C65EFF417
+    Image Guid:  D57428CC-BB9A-42E0-AA36-3F5A132059C7
+    Image Acceptance: yes
+    Image Guid:  2BE37D6D-8281-4938-BD7B-9A5BBF80869F
+    Image Acceptance: yes
+
+Configuration
+-------------
+
+To use the fwu_mdata_read command, CONFIG_CMD_FWU_METADATA needs to be
+enabled.
diff --git a/doc/usage/index.rst b/doc/usage/index.rst
index f1beeec59c..5b21451f6a 100644
--- a/doc/usage/index.rst
+++ b/doc/usage/index.rst
@@ -45,6 +45,7 @@ Shell commands
    cmd/fatload
    cmd/fdt
    cmd/for
+   cmd/fwu_mdata
    cmd/gpio
    cmd/load
    cmd/loadm
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 8b6fead351..75ac149d31 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -44,6 +44,8 @@ source "drivers/fuzz/Kconfig"
 
 source "drivers/fpga/Kconfig"
 
+source "drivers/fwu-mdata/Kconfig"
+
 source "drivers/gpio/Kconfig"
 
 source "drivers/hwspinlock/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index eba9940231..af7ed7bdf3 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -84,6 +84,7 @@ obj-y += cache/
 obj-$(CONFIG_CPU) += cpu/
 obj-y += crypto/
 obj-$(CONFIG_FASTBOOT) += fastboot/
+obj-$(CONFIG_FWU_MDATA) += fwu-mdata/
 obj-y += misc/
 obj-$(CONFIG_MMC) += mmc/
 obj-$(CONFIG_NVME) += nvme/
diff --git a/drivers/adc/stm32-adc-core.c b/drivers/adc/stm32-adc-core.c
index 6c176961f1..bca030891c 100644
--- a/drivers/adc/stm32-adc-core.c
+++ b/drivers/adc/stm32-adc-core.c
@@ -201,6 +201,7 @@ err_aclk_disable:
 static const struct udevice_id stm32_adc_core_ids[] = {
 	{ .compatible = "st,stm32h7-adc-core" },
 	{ .compatible = "st,stm32mp1-adc-core" },
+	{ .compatible = "st,stm32mp13-adc-core" },
 	{}
 };
 
diff --git a/drivers/adc/stm32-adc.c b/drivers/adc/stm32-adc.c
index ad8d1a32cd..334a7358e8 100644
--- a/drivers/adc/stm32-adc.c
+++ b/drivers/adc/stm32-adc.c
@@ -9,6 +9,7 @@
 #include <common.h>
 #include <adc.h>
 #include <dm.h>
+#include <env.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
 #include <linux/bitops.h>
@@ -26,6 +27,8 @@
 #define STM32H7_ADC_SQR1		0x30
 #define STM32H7_ADC_DR			0x40
 #define STM32H7_ADC_DIFSEL		0xC0
+#define STM32H7_ADC_CALFACT		0xC4
+#define STM32H7_ADC_CALFACT2		0xC8
 
 /* STM32H7_ADC_ISR - bit fields */
 #define STM32MP1_VREGREADY		BIT(12)
@@ -33,13 +36,27 @@
 #define STM32H7_ADRDY			BIT(0)
 
 /* STM32H7_ADC_CR - bit fields */
+#define STM32H7_ADCAL			BIT(31)
+#define STM32H7_ADCALDIF		BIT(30)
 #define STM32H7_DEEPPWD			BIT(29)
 #define STM32H7_ADVREGEN		BIT(28)
+#define STM32H7_LINCALRDYW6		BIT(27)
+#define STM32H7_LINCALRDYW5		BIT(26)
+#define STM32H7_LINCALRDYW4		BIT(25)
+#define STM32H7_LINCALRDYW3		BIT(24)
+#define STM32H7_LINCALRDYW2		BIT(23)
+#define STM32H7_LINCALRDYW1		BIT(22)
+#define STM32H7_ADCALLIN		BIT(16)
 #define STM32H7_BOOST			BIT(8)
+#define STM32H7_ADSTP			BIT(4)
 #define STM32H7_ADSTART			BIT(2)
 #define STM32H7_ADDIS			BIT(1)
 #define STM32H7_ADEN			BIT(0)
 
+/* STM32H7_ADC_CALFACT2 - bit fields */
+#define STM32H7_LINCALFACT_SHIFT	0
+#define STM32H7_LINCALFACT_MASK		GENMASK(29, 0)
+
 /* STM32H7_ADC_CFGR bit fields */
 #define STM32H7_EXTEN			GENMASK(11, 10)
 #define STM32H7_DMNGT			GENMASK(1, 0)
@@ -47,80 +64,155 @@
 /* STM32H7_ADC_SQR1 - bit fields */
 #define STM32H7_SQ1_SHIFT		6
 
+/* STM32H7_ADC_DIFSEL - bit fields */
+#define STM32H7_DIFSEL_SHIFT	0
+#define STM32H7_DIFSEL_MASK		GENMASK(19, 0)
+
 /* BOOST bit must be set on STM32H7 when ADC clock is above 20MHz */
 #define STM32H7_BOOST_CLKRATE		20000000UL
 
+/* STM32MP13 - Registers for each ADC instance */
+#define STM32MP13_ADC_DIFSEL	0xB0
+
+/* STM32MP13_ADC_CFGR specific bit fields */
+#define STM32MP13_DMAEN			BIT(0)
+#define STM32MP13_DMACFG		BIT(1)
+
+/* STM32MP13_ADC_DIFSEL - bit fields */
+#define STM32MP13_DIFSEL_SHIFT	0
+#define STM32MP13_DIFSEL_MASK	GENMASK(18, 0)
+
 #define STM32_ADC_CH_MAX		20	/* max number of channels */
 #define STM32_ADC_TIMEOUT_US		100000
+/* Number of linear calibration shadow registers / LINCALRDYW control bits */
+#define STM32H7_LINCALFACT_NUM		6
+#define STM32H7_LINCAL_NAME_LEN		32
 
 struct stm32_adc_cfg {
+	const struct stm32_adc_regspec	*regs;
 	unsigned int max_channels;
 	unsigned int num_bits;
 	bool has_vregready;
+	bool has_boostmode;
+	bool has_linearcal;
+	bool has_presel;
 };
 
 struct stm32_adc {
 	void __iomem *regs;
 	int active_channel;
 	const struct stm32_adc_cfg *cfg;
+	u32 lincalfact[STM32H7_LINCALFACT_NUM];
 };
 
-static int stm32_adc_stop(struct udevice *dev)
+struct stm32_adc_regs {
+	int reg;
+	int mask;
+	int shift;
+};
+
+struct stm32_adc_regspec {
+	const struct stm32_adc_regs difsel;
+};
+
+static const struct stm32_adc_regspec stm32h7_adc_regspec = {
+	.difsel = { STM32H7_ADC_DIFSEL, STM32H7_DIFSEL_MASK },
+};
+
+static const struct stm32_adc_regspec stm32mp13_adc_regspec = {
+	.difsel = { STM32MP13_ADC_DIFSEL, STM32MP13_DIFSEL_MASK },
+};
+static void stm32_adc_enter_pwr_down(struct udevice *dev)
 {
 	struct stm32_adc *adc = dev_get_priv(dev);
 
-	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADDIS);
 	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_BOOST);
 	/* Setting DEEPPWD disables ADC vreg and clears ADVREGEN */
 	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_DEEPPWD);
-	adc->active_channel = -1;
-
-	return 0;
 }
 
-static int stm32_adc_start_channel(struct udevice *dev, int channel)
+static int stm32_adc_exit_pwr_down(struct udevice *dev)
 {
-	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
 	struct stm32_adc_common *common = dev_get_priv(dev_get_parent(dev));
 	struct stm32_adc *adc = dev_get_priv(dev);
 	int ret;
 	u32 val;
 
+	/* return immediately if ADC is not in deep power down mode */
+	if (!(readl(adc->regs + STM32H7_ADC_CR) & STM32H7_DEEPPWD))
+		return 0;
+
 	/* Exit deep power down, then enable ADC voltage regulator */
 	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_DEEPPWD);
 	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADVREGEN);
-	if (common->rate > STM32H7_BOOST_CLKRATE)
+	if (adc->cfg->has_boostmode && common->rate > STM32H7_BOOST_CLKRATE)
 		setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_BOOST);
 
 	/* Wait for startup time */
 	if (!adc->cfg->has_vregready) {
 		udelay(20);
-	} else {
-		ret = readl_poll_timeout(adc->regs + STM32H7_ADC_ISR, val,
-					 val & STM32MP1_VREGREADY,
-					 STM32_ADC_TIMEOUT_US);
-		if (ret < 0) {
-			stm32_adc_stop(dev);
-			dev_err(dev, "Failed to enable vreg: %d\n", ret);
-			return ret;
-		}
+		return 0;
 	}
 
-	/* Only use single ended channels */
-	writel(0, adc->regs + STM32H7_ADC_DIFSEL);
+	ret = readl_poll_timeout(adc->regs + STM32H7_ADC_ISR, val,
+				 val & STM32MP1_VREGREADY,
+				 STM32_ADC_TIMEOUT_US);
+	if (ret < 0) {
+		stm32_adc_enter_pwr_down(dev);
+		dev_err(dev, "Failed to enable vreg: %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int stm32_adc_stop(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+
+	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADDIS);
+	stm32_adc_enter_pwr_down(dev);
+	adc->active_channel = -1;
+
+	return 0;
+}
+
+static int stm32_adc_enable(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	int ret;
+	u32 val;
 
-	/* Enable ADC, Poll for ADRDY to be set (after adc startup time) */
 	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADEN);
 	ret = readl_poll_timeout(adc->regs + STM32H7_ADC_ISR, val,
 				 val & STM32H7_ADRDY, STM32_ADC_TIMEOUT_US);
 	if (ret < 0) {
 		stm32_adc_stop(dev);
 		dev_err(dev, "Failed to enable ADC: %d\n", ret);
-		return ret;
 	}
 
+	return ret;
+}
+
+static int stm32_adc_start_channel(struct udevice *dev, int channel)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct stm32_adc *adc = dev_get_priv(dev);
+	int ret;
+
+	ret = stm32_adc_exit_pwr_down(dev);
+	if (ret < 0)
+		return ret;
+
+	/* Only use single ended channels */
+	clrbits_le32(adc->regs + adc->cfg->regs->difsel.reg, adc->cfg->regs->difsel.mask);
+
+	ret = stm32_adc_enable(dev);
+	if (ret)
+		return ret;
+
 	/* Preselect channels */
-	writel(uc_pdata->channel_mask, adc->regs + STM32H7_ADC_PCSEL);
+	if (adc->cfg->has_presel)
+		writel(uc_pdata->channel_mask, adc->regs + STM32H7_ADC_PCSEL);
 
 	/* Set sampling time to max value by default */
 	writel(0xffffffff, adc->regs + STM32H7_ADC_SMPR1);
@@ -129,9 +221,11 @@ static int stm32_adc_start_channel(struct udevice *dev, int channel)
 	/* Program regular sequence: chan in SQ1 & len = 0 for one channel */
 	writel(channel << STM32H7_SQ1_SHIFT, adc->regs + STM32H7_ADC_SQR1);
 
-	/* Trigger detection disabled (conversion can be launched in SW) */
-	clrbits_le32(adc->regs + STM32H7_ADC_CFGR, STM32H7_EXTEN |
-		     STM32H7_DMNGT);
+	/*
+	 * Trigger detection disabled (conversion can be launched in SW)
+	 * STM32H7_DMNGT is equivalent to STM32MP13_DMAEN & STM32MP13_DMACFG
+	 */
+	clrbits_le32(adc->regs + STM32H7_ADC_CFGR, STM32H7_EXTEN | STM32H7_DMNGT);
 	adc->active_channel = channel;
 
 	return 0;
@@ -159,15 +253,247 @@ static int stm32_adc_channel_data(struct udevice *dev, int channel,
 
 	*data = readl(adc->regs + STM32H7_ADC_DR);
 
+	ret = readl_poll_timeout(adc->regs + STM32H7_ADC_CR, val,
+				 !(val & (STM32H7_ADSTART)), STM32_ADC_TIMEOUT_US);
+	if (ret)
+		dev_warn(dev, "conversion stop timed out\n");
+
+	if (adc->cfg->has_presel)
+		setbits_le32(adc->regs + STM32H7_ADC_PCSEL, 0);
+
+	return ret;
+}
+
+/**
+ * Fixed timeout value for ADC calibration.
+ * worst cases:
+ * - low clock frequency (0.12 MHz min)
+ * - maximum prescalers
+ * Calibration requires:
+ * - 16384 ADC clock cycle for the linear calibration
+ * - 20 ADC clock cycle for the offset calibration
+ *
+ * Set to 100ms for now
+ */
+#define STM32H7_ADC_CALIB_TIMEOUT_US		100000
+
+static int stm32_adc_run_selfcalib(struct udevice *dev, int do_lincal)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	int ret;
+	u32 val, mask;
+
+	/*
+	 * Select calibration mode:
+	 * - Offset calibration for single ended inputs
+	 * - No linearity calibration.
+	 */
+	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+
+	/* Start calibration, then wait for completion */
+	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCAL);
+	ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+				       !(val & STM32H7_ADCAL), 100,
+				       STM32H7_ADC_CALIB_TIMEOUT_US);
+	if (ret) {
+		dev_err(dev, "calibration (offset single-ended) failed\n");
+		goto out;
+	}
+
+	/*
+	 * Select calibration mode, then start calibration:
+	 * - Offset calibration for differential input
+	 * - Linearity calibration if not already done.
+	 *   will run simultaneously with offset calibration.
+	 */
+	mask = STM32H7_ADCALDIF;
+	if (adc->cfg->has_linearcal && do_lincal)
+		mask |= STM32H7_ADCALLIN;
+	setbits_le32(adc->regs + STM32H7_ADC_CR, mask);
+
+	/* Start calibration, then wait for completion */
+	setbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCAL);
+	ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+				       !(val & STM32H7_ADCAL), 100,
+				       STM32H7_ADC_CALIB_TIMEOUT_US);
+	if (ret)
+		dev_err(dev, "calibration (offset diff%s) failed\n",
+			(mask & STM32H7_ADCALLIN) ? "+linear" : "");
+
+out:
+	clrbits_le32(adc->regs + STM32H7_ADC_CR, STM32H7_ADCALDIF | STM32H7_ADCALLIN);
+
+	return ret;
+}
+
+/* Retrieve calibration data from env variables */
+static bool stm32_adc_getenv_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	char env_name[STM32H7_LINCAL_NAME_LEN];
+	char *env;
+	int i;
+
+	memset(&adc->lincalfact, 0, STM32H7_LINCALFACT_NUM * sizeof(u32));
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		/*
+		 * Save ADC linear calibration factors in U-boot environment variables
+		 * Variables are instantiated according to the adc address through
+		 * adcx_ prefix.
+		 */
+		snprintf(env_name, sizeof(env_name), "adc%x_lincalfact%d", (u32)adc->regs, i + 1);
+		env = env_get(env_name);
+		if (!env)
+			return false;
+		adc->lincalfact[i] = env_get_hex(env_name, 0);
+	}
+	return true;
+}
+
+/* Save calibration data to env variables */
+static void stm32_adc_save_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	char env_name[STM32H7_LINCAL_NAME_LEN];
+	int i;
+
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		snprintf(env_name, sizeof(env_name), "adc%x_lincalfact%d", (u32)adc->regs, i + 1);
+		if (env_set_hex(env_name, adc->lincalfact[i]))
+			dev_warn(dev, "Failed to save %s\n", env_name);
+	}
+}
+
+/* Read calibration data from ADC */
+static int stm32_adc_read_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 lincalrdyw_mask, val;
+	int i, ret;
+
+	/* Read linearity calibration */
+	lincalrdyw_mask = STM32H7_LINCALRDYW6;
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		/* Clear STM32H7_LINCALRDYW[6..1]: transfer calib to CALFACT2 */
+		clrbits_le32(adc->regs + STM32H7_ADC_CR, lincalrdyw_mask);
+
+		/* Poll: wait calib data to be ready in CALFACT2 register */
+		ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+					       !(val & lincalrdyw_mask), 100,
+					       STM32_ADC_TIMEOUT_US);
+		if (ret) {
+			dev_err(dev, "Failed to read calfact\n");
+			return ret;
+		}
+
+		val = readl(adc->regs + STM32H7_ADC_CALFACT2);
+		adc->lincalfact[i] = (val & STM32H7_LINCALFACT_MASK);
+		adc->lincalfact[i] >>= STM32H7_LINCALFACT_SHIFT;
+
+		lincalrdyw_mask >>= 1;
+	}
+
 	return 0;
 }
 
-static int stm32_adc_chan_of_init(struct udevice *dev)
+/* Write calibration data to ADC */
+static int stm32_adc_write_selfcalib(struct udevice *dev)
 {
-	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
 	struct stm32_adc *adc = dev_get_priv(dev);
-	u32 chans[STM32_ADC_CH_MAX];
-	unsigned int i, num_channels;
+	u32 lincalrdyw_mask, val;
+	int i, ret;
+
+	lincalrdyw_mask = STM32H7_LINCALRDYW6;
+	for (i = STM32H7_LINCALFACT_NUM - 1; i >= 0; i--) {
+		/*
+		 * Write saved calibration data to shadow registers:
+		 * Write CALFACT2, and set LINCALRDYW[6..1] bit to trigger
+		 * data write. Then poll to wait for complete transfer.
+		 */
+		val = adc->lincalfact[i] << STM32H7_LINCALFACT_SHIFT;
+		writel(val, adc->regs + STM32H7_ADC_CALFACT2);
+		setbits_le32(adc->regs + STM32H7_ADC_CR, lincalrdyw_mask);
+		ret = readl_poll_sleep_timeout(adc->regs + STM32H7_ADC_CR, val,
+					       val & lincalrdyw_mask,
+					       100, STM32_ADC_TIMEOUT_US);
+		if (ret) {
+			dev_err(dev, "Failed to write calfact\n");
+			return ret;
+		}
+
+		lincalrdyw_mask >>= 1;
+	}
+
+	return 0;
+}
+
+static int stm32_adc_selfcalib(struct udevice *dev)
+{
+	struct stm32_adc *adc = dev_get_priv(dev);
+	int ret;
+	bool lincal_done = false;
+
+	/* Try to restore linear calibration */
+	if (adc->cfg->has_linearcal)
+		lincal_done = stm32_adc_getenv_selfcalib(dev);
+
+	/*
+	 * Run offset calibration unconditionally.
+	 * Run linear calibration if not already available.
+	 */
+	ret = stm32_adc_run_selfcalib(dev, !lincal_done);
+	if (ret)
+		return ret;
+
+	ret = stm32_adc_enable(dev);
+	if (ret)
+		return ret;
+
+	if (adc->cfg->has_linearcal) {
+		if (!lincal_done) {
+			ret = stm32_adc_read_selfcalib(dev);
+			if (ret)
+				goto disable;
+
+			stm32_adc_save_selfcalib(dev);
+		}
+
+		/*
+		 * Always write linear calibration data to ADC.
+		 * This allows to ensure that LINCALRDYWx bits are set when entering kernel
+		 *
+		 * - First boot:
+		 *   U-boot performs ADC linear calibration (& offset calibration)
+		 *   U-boot reads & saves linear calibration result in environment variable
+		 *   (Here LINCALRDYWx have been cleared due to the read procedure)
+		 *   U-boot writes back ADC linear calibration to set LINCALRDYWx bits,
+		 *   making the linear calibration available for the kernel.
+		 *
+		 * - Subsequent boot (environment set earlier):
+		 *   U-boot performs ADC offset calibration only
+		 *   U-boot reads ADC linear calibration from environment variable
+		 *   and writes back ADC linear calibration.
+		 *
+		 * - All boot: kernel steps
+		 *   * Case1: ADC calibrated by U-boot (LINCALRDYWx bits set)
+		 *     Read back the linear calibration from ADC registers and save it.
+		 *   * Case2: ADC not calibrated by U-boot
+		 *     Run a linear calibration and save it.
+		 */
+		ret = stm32_adc_write_selfcalib(dev);
+		if (ret)
+			goto disable;
+	}
+
+	return ret;
+
+disable:
+	stm32_adc_stop(dev);
+	return ret;
+}
+
+static int stm32_adc_get_legacy_chan_count(struct udevice *dev)
+{
 	int ret;
 
 	/* Retrieve single ended channels listed in device tree */
@@ -176,12 +502,16 @@ static int stm32_adc_chan_of_init(struct udevice *dev)
 		dev_err(dev, "can't get st,adc-channels: %d\n", ret);
 		return ret;
 	}
-	num_channels = ret / sizeof(u32);
 
-	if (num_channels > adc->cfg->max_channels) {
-		dev_err(dev, "too many st,adc-channels: %d\n", num_channels);
-		return -EINVAL;
-	}
+	return (ret / sizeof(u32));
+}
+
+static int stm32_adc_legacy_chan_init(struct udevice *dev, unsigned int num_channels)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct stm32_adc *adc = dev_get_priv(dev);
+	u32 chans[STM32_ADC_CH_MAX];
+	int i, ret;
 
 	ret = dev_read_u32_array(dev, "st,adc-channels", chans, num_channels);
 	if (ret < 0) {
@@ -197,6 +527,69 @@ static int stm32_adc_chan_of_init(struct udevice *dev)
 		uc_pdata->channel_mask |= 1 << chans[i];
 	}
 
+	return ret;
+}
+
+static int stm32_adc_generic_chan_init(struct udevice *dev, unsigned int num_channels)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct stm32_adc *adc = dev_get_priv(dev);
+	ofnode child;
+	int val, ret;
+
+	ofnode_for_each_subnode(child, dev_ofnode(dev)) {
+		ret = ofnode_read_u32(child, "reg", &val);
+		if (ret) {
+			dev_err(dev, "Missing channel index %d\n", ret);
+			return ret;
+		}
+
+		if (val >= adc->cfg->max_channels) {
+			dev_err(dev, "Invalid channel %d\n", val);
+			return -EINVAL;
+		}
+
+		uc_pdata->channel_mask |= 1 << val;
+	}
+
+	return 0;
+}
+
+static int stm32_adc_chan_of_init(struct udevice *dev)
+{
+	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
+	struct stm32_adc *adc = dev_get_priv(dev);
+	unsigned int num_channels;
+	int ret;
+	bool legacy = false;
+
+	num_channels = dev_get_child_count(dev);
+	/* If no channels have been found, fallback to channels legacy properties. */
+	if (!num_channels) {
+		legacy = true;
+
+		ret = stm32_adc_get_legacy_chan_count(dev);
+		if (!ret) {
+			dev_err(dev, "No channel found\n");
+			return -ENODATA;
+		} else if (ret < 0) {
+			return ret;
+		}
+		num_channels = ret;
+	}
+
+	if (num_channels > adc->cfg->max_channels) {
+		dev_err(dev, "too many st,adc-channels: %d\n", num_channels);
+		return -EINVAL;
+	}
+
+	if (legacy)
+		ret = stm32_adc_legacy_chan_init(dev, num_channels);
+	else
+		ret = stm32_adc_generic_chan_init(dev, num_channels);
+	if (ret < 0)
+		return ret;
+
 	uc_pdata->data_mask = (1 << adc->cfg->num_bits) - 1;
 	uc_pdata->data_format = ADC_DATA_FORMAT_BIN;
 	uc_pdata->data_timeout_us = 100000;
@@ -209,7 +602,7 @@ static int stm32_adc_probe(struct udevice *dev)
 	struct adc_uclass_plat *uc_pdata = dev_get_uclass_plat(dev);
 	struct stm32_adc_common *common = dev_get_priv(dev_get_parent(dev));
 	struct stm32_adc *adc = dev_get_priv(dev);
-	int offset;
+	int offset, ret;
 
 	offset = dev_read_u32_default(dev, "reg", -ENODATA);
 	if (offset < 0) {
@@ -224,7 +617,19 @@ static int stm32_adc_probe(struct udevice *dev)
 	uc_pdata->vdd_microvolts = common->vref_uv;
 	uc_pdata->vss_microvolts = 0;
 
-	return stm32_adc_chan_of_init(dev);
+	ret = stm32_adc_chan_of_init(dev);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_adc_exit_pwr_down(dev);
+	if (ret < 0)
+		return ret;
+
+	ret = stm32_adc_selfcalib(dev);
+	if (ret)
+		stm32_adc_enter_pwr_down(dev);
+
+	return ret;
 }
 
 static const struct adc_ops stm32_adc_ops = {
@@ -234,14 +639,28 @@ static const struct adc_ops stm32_adc_ops = {
 };
 
 static const struct stm32_adc_cfg stm32h7_adc_cfg = {
+	.regs = &stm32h7_adc_regspec,
 	.num_bits = 16,
 	.max_channels = STM32_ADC_CH_MAX,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
 };
 
 static const struct stm32_adc_cfg stm32mp1_adc_cfg = {
+	.regs = &stm32h7_adc_regspec,
 	.num_bits = 16,
 	.max_channels = STM32_ADC_CH_MAX,
 	.has_vregready = true,
+	.has_boostmode = true,
+	.has_linearcal = true,
+	.has_presel = true,
+};
+
+static const struct stm32_adc_cfg stm32mp13_adc_cfg = {
+	.regs = &stm32mp13_adc_regspec,
+	.num_bits = 12,
+	.max_channels = STM32_ADC_CH_MAX - 1,
 };
 
 static const struct udevice_id stm32_adc_ids[] = {
@@ -249,6 +668,8 @@ static const struct udevice_id stm32_adc_ids[] = {
 	  .data = (ulong)&stm32h7_adc_cfg },
 	{ .compatible = "st,stm32mp1-adc",
 	  .data = (ulong)&stm32mp1_adc_cfg },
+	{ .compatible = "st,stm32mp13-adc",
+	  .data = (ulong)&stm32mp13_adc_cfg },
 	{}
 };
 
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index fd9e1a80c6..b7c05b4686 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -10,6 +10,16 @@ config CLK
 	  feed into other clocks in a tree structure, with multiplexers to
 	  choose the source for each clock.
 
+config CLK_AUTO_ID
+	bool "Enable support of an unique clock id with several provider"
+	depends on CLK
+	help
+	  Add the uclass sequence number of clock provider in the 8 higher bits
+	  of the clk id to guaranty an unique clock identifier in clk uclass
+	  when several clock providers are present on the device and when
+	  default xlate are used.
+	  This feature limit each identifier for each clock providers (24 bits).
+
 config SPL_CLK
 	bool "Enable clock support in SPL"
 	depends on CLK && SPL && SPL_DM
@@ -161,6 +171,7 @@ config SANDBOX_CLK_CCF
 config CLK_SCMI
 	bool "Enable SCMI clock driver"
 	depends on SCMI_FIRMWARE
+	select CLK_AUTO_ID if CLK_CCF
 	help
 	  Enable this option if you want to support clock devices exposed
 	  by a SCMI agent based on SCMI clock protocol communication
diff --git a/drivers/clk/clk-uclass.c b/drivers/clk/clk-uclass.c
index b89c77bf79..9c8a459fdb 100644
--- a/drivers/clk/clk-uclass.c
+++ b/drivers/clk/clk-uclass.c
@@ -35,6 +35,12 @@ struct clk *dev_get_clk_ptr(struct udevice *dev)
 	return (struct clk *)dev_get_uclass_priv(dev);
 }
 
+ulong clk_get_id(const struct clk *clk)
+{
+	return (ulong)(clk->id & CLK_ID_MSK);
+}
+
+
 #if CONFIG_IS_ENABLED(OF_PLATDATA)
 int clk_get_by_phandle(struct udevice *dev, const struct phandle_1_arg *cells,
 		       struct clk *clk)
@@ -44,7 +50,7 @@ int clk_get_by_phandle(struct udevice *dev, const struct phandle_1_arg *cells,
 	ret = device_get_by_ofplat_idx(cells->idx, &clk->dev);
 	if (ret)
 		return ret;
-	clk->id = cells->arg[0];
+	clk->id = CLK_ID(dev, cells->arg[0]);
 
 	return 0;
 }
@@ -62,7 +68,7 @@ static int clk_of_xlate_default(struct clk *clk,
 	}
 
 	if (args->args_count)
-		clk->id = args->args[0];
+		clk->id = CLK_ID(clk->dev, args->args[0]);
 	else
 		clk->id = 0;
 
@@ -544,6 +550,19 @@ ulong clk_round_rate(struct clk *clk, ulong rate)
 	return ops->round_rate(clk, rate);
 }
 
+static void clk_get_priv(struct clk *clk, struct clk **clkp)
+{
+	*clkp = clk;
+
+	/* get private clock struct associated to the provided clock */
+	if (CONFIG_IS_ENABLED(CLK_CCF)) {
+		/* Take id 0 as a non-valid clk, such as dummy */
+		if (clk->id)
+			clk_get_by_id(clk->id, clkp);
+	}
+}
+
+/* clean cache, called with private clock struct */
 static void clk_clean_rate_cache(struct clk *clk)
 {
 	struct udevice *child_dev;
@@ -563,19 +582,39 @@ static void clk_clean_rate_cache(struct clk *clk)
 ulong clk_set_rate(struct clk *clk, ulong rate)
 {
 	const struct clk_ops *ops;
+	struct clk *clkp;
 
 	debug("%s(clk=%p, rate=%lu)\n", __func__, clk, rate);
 	if (!clk_valid(clk))
 		return 0;
-	ops = clk_dev_ops(clk->dev);
 
-	if (!ops->set_rate)
-		return -ENOSYS;
+	/* get private clock struct*/
+	clk_get_priv(clk, &clkp);
+
+	ops = clk_dev_ops(clkp->dev);
+
+	if (!ops->set_rate) {
+		struct clk *pclk = NULL;
+
+		if ((clkp->flags & CLK_SET_RATE_PARENT) == 0)
+			return -ENOSYS;
+
+		pclk = clk_get_parent(clkp);
+		if (IS_ERR(pclk))
+			return -ENODEV;
+
+		ops = clk_dev_ops(pclk->dev);
+
+		/* Clean up cached rates for us and all child clocks */
+		clk_clean_rate_cache(pclk);
+
+		return ops->set_rate(pclk, rate);
+	}
 
 	/* Clean up cached rates for us and all child clocks */
-	clk_clean_rate_cache(clk);
+	clk_clean_rate_cache(clkp);
 
-	return ops->set_rate(clk, rate);
+	return ops->set_rate(clkp, rate);
 }
 
 int clk_set_parent(struct clk *clk, struct clk *parent)
diff --git a/drivers/clk/clk_fixed_rate.c b/drivers/clk/clk_fixed_rate.c
index b5e78c7055..d79d158ef2 100644
--- a/drivers/clk/clk_fixed_rate.c
+++ b/drivers/clk/clk_fixed_rate.c
@@ -45,6 +45,7 @@ void clk_fixed_rate_ofdata_to_plat_(struct udevice *dev,
 	dev_set_uclass_priv(dev, clk);
 
 	clk->dev = dev;
+	clk->id = CLK_ID(dev, 0);
 	clk->enable_count = 0;
 }
 
diff --git a/drivers/clk/clk_sandbox.c b/drivers/clk/clk_sandbox.c
index 636914db8c..cfec0779de 100644
--- a/drivers/clk/clk_sandbox.c
+++ b/drivers/clk/clk_sandbox.c
@@ -14,24 +14,26 @@
 static ulong sandbox_clk_get_rate(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	return priv->rate[clk->id];
+	return priv->rate[id];
 }
 
 static ulong sandbox_clk_round_rate(struct clk *clk, ulong rate)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
 	if (!rate)
@@ -44,18 +46,19 @@ static ulong sandbox_clk_set_rate(struct clk *clk, ulong rate)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
 	ulong old_rate;
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
 	if (!rate)
 		return -EINVAL;
 
-	old_rate = priv->rate[clk->id];
-	priv->rate[clk->id] = rate;
+	old_rate = priv->rate[id];
+	priv->rate[id] = rate;
 
 	return old_rate;
 }
@@ -63,14 +66,15 @@ static ulong sandbox_clk_set_rate(struct clk *clk, ulong rate)
 static int sandbox_clk_enable(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	priv->enabled[clk->id] = true;
+	priv->enabled[id] = true;
 
 	return 0;
 }
@@ -78,14 +82,15 @@ static int sandbox_clk_enable(struct clk *clk)
 static int sandbox_clk_disable(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
 	if (!priv->probed)
 		return -ENODEV;
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	priv->enabled[clk->id] = false;
+	priv->enabled[id] = false;
 
 	return 0;
 }
@@ -93,22 +98,24 @@ static int sandbox_clk_disable(struct clk *clk)
 static int sandbox_clk_request(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return -EINVAL;
 
-	priv->requested[clk->id] = true;
+	priv->requested[id] = true;
 	return 0;
 }
 
 static void sandbox_clk_free(struct clk *clk)
 {
 	struct sandbox_clk_priv *priv = dev_get_priv(clk->dev);
+	ulong id = clk_get_id(clk);
 
-	if (clk->id >= SANDBOX_CLK_ID_COUNT)
+	if (id >= SANDBOX_CLK_ID_COUNT)
 		return;
 
-	priv->requested[clk->id] = false;
+	priv->requested[id] = false;
 	return;
 }
 
diff --git a/drivers/clk/clk_sandbox_ccf.c b/drivers/clk/clk_sandbox_ccf.c
index fedcdd4044..9ca19b4945 100644
--- a/drivers/clk/clk_sandbox_ccf.c
+++ b/drivers/clk/clk_sandbox_ccf.c
@@ -236,47 +236,47 @@ static int sandbox_clk_ccf_probe(struct udevice *dev)
 	void *base = NULL;
 	u32 reg;
 
-	clk_dm(SANDBOX_CLK_PLL3,
-	       sandbox_clk_pllv3(SANDBOX_PLLV3_USB, "pll3_usb_otg", "osc",
-				 base + 0x10, 0x3));
+	dev_clk_dm(dev, SANDBOX_CLK_PLL3,
+		   sandbox_clk_pllv3(SANDBOX_PLLV3_USB, "pll3_usb_otg", "osc",
+				     base + 0x10, 0x3));
 
-	clk_dm(SANDBOX_CLK_PLL3_60M,
-	       sandbox_clk_fixed_factor("pll3_60m",  "pll3_usb_otg",   1, 8));
+	dev_clk_dm(dev, SANDBOX_CLK_PLL3_60M,
+		   sandbox_clk_fixed_factor("pll3_60m", "pll3_usb_otg",   1, 8));
 
-	clk_dm(SANDBOX_CLK_PLL3_80M,
-	       sandbox_clk_fixed_factor("pll3_80m",  "pll3_usb_otg",   1, 6));
+	dev_clk_dm(dev, SANDBOX_CLK_PLL3_80M,
+		   sandbox_clk_fixed_factor("pll3_80m", "pll3_usb_otg",   1, 6));
 
 	/* The HW adds +1 to the divider value (2+1) is the divider */
 	reg = (2 << 19);
-	clk_dm(SANDBOX_CLK_ECSPI_ROOT,
-	       sandbox_clk_divider("ecspi_root", "pll3_60m", &reg, 19, 6));
+	dev_clk_dm(dev, SANDBOX_CLK_ECSPI_ROOT,
+		   sandbox_clk_divider("ecspi_root", "pll3_60m", &reg, 19, 6));
 
 	reg = 0;
-	clk_dm(SANDBOX_CLK_ECSPI0,
-	       sandbox_clk_gate("ecspi0", "ecspi_root", &reg, 0, 0));
+	dev_clk_dm(dev, SANDBOX_CLK_ECSPI0,
+		   sandbox_clk_gate("ecspi0", "ecspi_root", &reg, 0, 0));
 
-	clk_dm(SANDBOX_CLK_ECSPI1,
-	       sandbox_clk_gate2("ecspi1", "ecspi_root", base + 0x6c, 0));
+	dev_clk_dm(dev, SANDBOX_CLK_ECSPI1,
+		   sandbox_clk_gate2("ecspi1", "ecspi_root", base + 0x6c, 0));
 
 	/* Select 'pll3_60m' */
 	reg = 0;
-	clk_dm(SANDBOX_CLK_USDHC1_SEL,
-	       sandbox_clk_mux("usdhc1_sel", &reg, 16, 1, usdhc_sels,
-			       ARRAY_SIZE(usdhc_sels)));
+	dev_clk_dm(dev, SANDBOX_CLK_USDHC1_SEL,
+		   sandbox_clk_mux("usdhc1_sel", &reg, 16, 1, usdhc_sels,
+				   ARRAY_SIZE(usdhc_sels)));
 
 	/* Select 'pll3_80m' */
 	reg = BIT(17);
-	clk_dm(SANDBOX_CLK_USDHC2_SEL,
-	       sandbox_clk_mux("usdhc2_sel", &reg, 17, 1, usdhc_sels,
-			       ARRAY_SIZE(usdhc_sels)));
+	dev_clk_dm(dev, SANDBOX_CLK_USDHC2_SEL,
+		   sandbox_clk_mux("usdhc2_sel", &reg, 17, 1, usdhc_sels,
+				   ARRAY_SIZE(usdhc_sels)));
 
 	reg = BIT(28) | BIT(24) | BIT(16);
-	clk_dm(SANDBOX_CLK_I2C,
-	       sandbox_clk_composite("i2c", i2c_sels, ARRAY_SIZE(i2c_sels),
-				     &reg, CLK_SET_RATE_UNGATE));
+	dev_clk_dm(dev, SANDBOX_CLK_I2C,
+		   sandbox_clk_composite("i2c", i2c_sels, ARRAY_SIZE(i2c_sels),
+					 &reg, CLK_SET_RATE_UNGATE));
 
-	clk_dm(SANDBOX_CLK_I2C_ROOT,
-	       sandbox_clk_gate2("i2c_root", "i2c", base + 0x7c, 0));
+	dev_clk_dm(dev, SANDBOX_CLK_I2C_ROOT,
+		   sandbox_clk_gate2("i2c_root", "i2c", base + 0x7c, 0));
 
 	return 0;
 }
diff --git a/drivers/clk/clk_scmi.c b/drivers/clk/clk_scmi.c
index d172fed24c..e55dbc3769 100644
--- a/drivers/clk/clk_scmi.c
+++ b/drivers/clk/clk_scmi.c
@@ -42,7 +42,7 @@ static int scmi_clk_get_num_clock(struct udevice *dev, size_t *num_clocks)
 	return 0;
 }
 
-static int scmi_clk_get_attibute(struct udevice *dev, int clkid, char **name)
+static int scmi_clk_get_attribute(struct udevice *dev, int clkid, char **name)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(dev);
 	struct scmi_clk_attribute_in in = {
@@ -72,7 +72,7 @@ static int scmi_clk_gate(struct clk *clk, int enable)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(clk->dev);
 	struct scmi_clk_state_in in = {
-		.clock_id = clk->id,
+		.clock_id = clk_get_id(clk),
 		.attributes = enable,
 	};
 	struct scmi_clk_state_out out;
@@ -102,7 +102,7 @@ static ulong scmi_clk_get_rate(struct clk *clk)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(clk->dev);
 	struct scmi_clk_rate_get_in in = {
-		.clock_id = clk->id,
+		.clock_id = clk_get_id(clk),
 	};
 	struct scmi_clk_rate_get_out out;
 	struct scmi_msg msg = SCMI_MSG_IN(SCMI_PROTOCOL_ID_CLOCK,
@@ -125,7 +125,7 @@ static ulong scmi_clk_set_rate(struct clk *clk, ulong rate)
 {
 	struct scmi_clk_priv *priv = dev_get_priv(clk->dev);
 	struct scmi_clk_rate_set_in in = {
-		.clock_id = clk->id,
+		.clock_id = clk_get_id(clk),
 		.flags = SCMI_CLK_RATE_ROUND_CLOSEST,
 		.rate_lsb = (u32)rate,
 		.rate_msb = (u32)((u64)rate >> 32),
@@ -172,7 +172,7 @@ static int scmi_clk_probe(struct udevice *dev)
 	for (i = 0; i < num_clocks; i++) {
 		char *clock_name;
 
-		if (!scmi_clk_get_attibute(dev, i, &clock_name)) {
+		if (!scmi_clk_get_attribute(dev, i, &clock_name)) {
 			clk = kzalloc(sizeof(*clk), GFP_KERNEL);
 			if (!clk || !clock_name)
 				ret = -ENOMEM;
@@ -186,7 +186,7 @@ static int scmi_clk_probe(struct udevice *dev)
 				return ret;
 			}
 
-			clk_dm(i, clk);
+			dev_clk_dm(dev, i, clk);
 		}
 	}
 
@@ -205,5 +205,5 @@ U_BOOT_DRIVER(scmi_clock) = {
 	.id = UCLASS_CLK,
 	.ops = &scmi_clk_ops,
 	.probe = scmi_clk_probe,
-	.priv_auto = sizeof(struct scmi_clk_priv *),
+	.priv_auto = sizeof(struct scmi_clk_priv),
 };
diff --git a/drivers/clk/stm32/Kconfig b/drivers/clk/stm32/Kconfig
index eac3fc1e9d..ea856be166 100644
--- a/drivers/clk/stm32/Kconfig
+++ b/drivers/clk/stm32/Kconfig
@@ -14,10 +14,34 @@ config CLK_STM32H7
 	  This clock driver adds support for RCC clock management
 	  for STM32H7 SoCs.
 
+config CLK_STM32_CORE
+	bool "Enable RCC clock core driver for STM32MP"
+	depends on ARCH_STM32MP && CLK
+	select CLK_CCF
+	select CLK_COMPOSITE_CCF
+
 config CLK_STM32MP1
 	bool "Enable RCC clock driver for STM32MP15"
 	depends on ARCH_STM32MP && CLK
-	default y if STM32MP15x
+	default y if STM32MP15X
 	help
 	  Enable the STM32 clock (RCC) driver. Enable support for
 	  manipulating STM32MP15's on-SoC clocks.
+
+config CLK_STM32MP13
+	bool "Enable RCC clock driver for STM32MP13"
+	depends on ARCH_STM32MP && CLK
+	default y if STM32MP13X
+	select CLK_STM32_CORE
+	help
+	  Enable the STM32 clock (RCC) driver. Enable support for
+	  manipulating STM32MP13's on-SoC clocks.
+
+config CLK_STM32MP25
+	bool "Enable RCC clock driver for STM32MP25"
+	depends on ARCH_STM32MP && CLK
+	default y if STM32MP25X
+	select CLK_STM32_CORE
+	help
+	  Enable the STM32 clock (RCC) driver. Enable support for
+	  manipulating STM32MP25's on-SoC clocks.
diff --git a/drivers/clk/stm32/Makefile b/drivers/clk/stm32/Makefile
index f66f295403..56adb8a4bb 100644
--- a/drivers/clk/stm32/Makefile
+++ b/drivers/clk/stm32/Makefile
@@ -2,6 +2,9 @@
 #
 # Copyright (C) 2022, STMicroelectronics - All Rights Reserved
 
+obj-$(CONFIG_CLK_STM32_CORE) += clk-stm32-core.o
 obj-$(CONFIG_CLK_STM32F) += clk-stm32f.o
 obj-$(CONFIG_CLK_STM32H7) += clk-stm32h7.o
 obj-$(CONFIG_CLK_STM32MP1) += clk-stm32mp1.o
+obj-$(CONFIG_CLK_STM32MP13) += clk-stm32mp13.o
+obj-$(CONFIG_CLK_STM32MP25) += clk-stm32mp25.o
diff --git a/drivers/clk/stm32/clk-stm32-core.c b/drivers/clk/stm32/clk-stm32-core.c
new file mode 100644
index 0000000000..5bb9843065
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32-core.c
@@ -0,0 +1,329 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#define LOG_CATEGORY UCLASS_CLK
+
+#include <common.h>
+#include <clk-uclass.h>
+#include <dm.h>
+#include <log.h>
+#include <asm/io.h>
+#include <dm/device_compat.h>
+#include <linux/clk-provider.h>
+#include "clk-stm32-core.h"
+
+int stm32_rcc_init(struct udevice *dev,
+		   const struct stm32_clock_match_data *data)
+{
+	int i;
+	u8 *cpt;
+	struct stm32mp_rcc_priv *priv = dev_get_priv(dev);
+	fdt_addr_t base = dev_read_addr(dev->parent);
+	const struct clk_stm32_clock_data *clock_data = data->clock_data;
+
+	if (base == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	priv->base = (void __iomem *)base;
+
+	/* allocate the counter of user for internal RCC gates, common for several user */
+	cpt = kzalloc(clock_data->num_gates, GFP_KERNEL);
+	if (!cpt)
+		return -ENOMEM;
+
+	priv->gate_cpt = cpt;
+
+	priv->data = clock_data;
+
+	for (i = 0; i < data->num_clocks; i++) {
+		const struct clock_config *cfg = &data->tab_clocks[i];
+		struct clk *clk = ERR_PTR(-ENOENT);
+
+		if (data->check_security && data->check_security(dev, priv->base, cfg))
+			continue;
+
+		if (cfg->setup) {
+			clk = cfg->setup(dev, cfg);
+			/* set identifier of clock provider*/
+			dev_clk_dm(dev, cfg->id, clk);
+		} else {
+			dev_err(dev, "failed to register clock %s\n", cfg->name);
+			return -ENOENT;
+		}
+	}
+
+	return 0;
+}
+
+ulong clk_stm32_get_rate_by_name(const char *name)
+{
+	struct udevice *dev;
+
+	if (!uclass_get_device_by_name(UCLASS_CLK, name, &dev)) {
+		struct clk *clk = dev_get_clk_ptr(dev);
+
+		return clk_get_rate(clk);
+	}
+
+	return 0;
+}
+
+static const struct clk_ops *clk_dev_ops(struct udevice *dev)
+{
+	return (const struct clk_ops *)dev->driver->ops;
+}
+
+static int stm32_clk_endisable(struct clk *clk, bool enable)
+{
+	const struct clk_ops *ops;
+	struct clk *c = NULL;
+
+	if (!clk->id || clk_get_by_id(clk->id, &c))
+		return -ENOENT;
+
+	ops = clk_dev_ops(c->dev);
+	if (!ops->enable || !ops->disable)
+		return 0;
+
+	return enable ? ops->enable(c) : ops->disable(c);
+}
+
+static int stm32_clk_enable(struct clk *clk)
+{
+	return stm32_clk_endisable(clk, true);
+}
+
+static int stm32_clk_disable(struct clk *clk)
+{
+	return stm32_clk_endisable(clk, false);
+}
+
+static ulong stm32_clk_get_rate(struct clk *clk)
+{
+	const struct clk_ops *ops;
+	struct clk *c = NULL;
+
+	if (!clk->id || clk_get_by_id(clk->id, &c))
+		return -ENOENT;
+
+	ops = clk_dev_ops(c->dev);
+	if (!ops->get_rate)
+		return -ENOSYS;
+
+	return ops->get_rate(c);
+}
+
+static ulong stm32_clk_set_rate(struct clk *clk, unsigned long clk_rate)
+{
+	const struct clk_ops *ops;
+	struct clk *c = NULL;
+
+	if (!clk->id || clk_get_by_id(clk->id, &c))
+		return -ENOENT;
+
+	ops = clk_dev_ops(c->dev);
+	if (!ops->set_rate)
+		return -ENOSYS;
+
+	return ops->set_rate(c, clk_rate);
+}
+
+const struct clk_ops stm32_clk_ops = {
+	.enable = stm32_clk_enable,
+	.disable = stm32_clk_disable,
+	.get_rate = stm32_clk_get_rate,
+	.set_rate = stm32_clk_set_rate,
+};
+
+#define RCC_MP_ENCLRR_OFFSET	4
+
+static void clk_stm32_gate_set_state(void __iomem *base,
+				     const struct clk_stm32_clock_data *data,
+				     u8 *cpt, u16 gate_id, int enable)
+{
+	const struct stm32_gate_cfg *gate_cfg = &data->gates[gate_id];
+	void __iomem *addr = base + gate_cfg->reg_off;
+	u8 set_clr = gate_cfg->set_clr ? RCC_MP_ENCLRR_OFFSET : 0;
+
+	if (enable) {
+		if (cpt[gate_id]++ > 0)
+			return;
+
+		if (set_clr)
+			writel(BIT(gate_cfg->bit_idx), addr);
+		else
+			writel(readl(addr) | BIT(gate_cfg->bit_idx), addr);
+	} else {
+		if (--cpt[gate_id] > 0)
+			return;
+
+		if (set_clr)
+			writel(BIT(gate_cfg->bit_idx), addr + set_clr);
+		else
+			writel(readl(addr) & ~BIT(gate_cfg->bit_idx), addr);
+	}
+}
+
+static int clk_stm32_gate_enable(struct clk *clk)
+{
+	struct clk_stm32_gate *stm32_gate = to_clk_stm32_gate(clk);
+	struct stm32mp_rcc_priv *priv = stm32_gate->priv;
+
+	clk_stm32_gate_set_state(priv->base, priv->data, priv->gate_cpt,
+				 stm32_gate->gate_id, 1);
+
+	return 0;
+}
+
+static int clk_stm32_gate_disable(struct clk *clk)
+{
+	struct clk_stm32_gate *stm32_gate = to_clk_stm32_gate(clk);
+	struct stm32mp_rcc_priv *priv = stm32_gate->priv;
+
+	clk_stm32_gate_set_state(priv->base, priv->data, priv->gate_cpt,
+				 stm32_gate->gate_id, 0);
+
+	return 0;
+}
+
+static const struct clk_ops clk_stm32_gate_ops = {
+	.enable = clk_stm32_gate_enable,
+	.disable = clk_stm32_gate_disable,
+	.get_rate = clk_generic_get_rate,
+};
+
+#define UBOOT_DM_CLK_STM32_GATE "clk_stm32_gate"
+
+U_BOOT_DRIVER(clk_stm32_gate) = {
+	.name	= UBOOT_DM_CLK_STM32_GATE,
+	.id	= UCLASS_CLK,
+	.ops	= &clk_stm32_gate_ops,
+};
+
+struct clk *clk_stm32_gate_register(struct udevice *dev,
+				    const struct clock_config *cfg)
+{
+	struct stm32mp_rcc_priv *priv = dev_get_priv(dev);
+	struct stm32_clk_gate_cfg *clk_cfg = cfg->clock_cfg;
+	struct clk_stm32_gate *stm32_gate;
+	struct clk *clk;
+	int ret;
+
+	stm32_gate = kzalloc(sizeof(*stm32_gate), GFP_KERNEL);
+	if (!stm32_gate)
+		return ERR_PTR(-ENOMEM);
+
+	stm32_gate->priv = priv;
+	stm32_gate->gate_id = clk_cfg->gate_id;
+
+	clk = &stm32_gate->clk;
+	clk->flags = cfg->flags;
+
+	ret = clk_register(clk, UBOOT_DM_CLK_STM32_GATE,
+			   cfg->name, cfg->parent_name);
+	if (ret) {
+		kfree(stm32_gate);
+		return ERR_PTR(ret);
+	}
+
+	return clk;
+}
+
+struct clk *
+clk_stm32_register_composite(struct udevice *dev,
+			     const struct clock_config *cfg)
+{
+	struct stm32_clk_composite_cfg *composite = cfg->clock_cfg;
+	const char *const *parent_names;
+	int num_parents;
+	struct clk *clk = ERR_PTR(-ENOMEM);
+	struct clk_mux *mux = NULL;
+	struct clk_stm32_gate *gate = NULL;
+	struct clk_divider *div = NULL;
+	struct clk *mux_clk = NULL;
+	const struct clk_ops *mux_ops = NULL;
+	struct clk *gate_clk = NULL;
+	const struct clk_ops *gate_ops = NULL;
+	struct clk *div_clk = NULL;
+	const struct clk_ops *div_ops = NULL;
+	struct stm32mp_rcc_priv *priv = dev_get_priv(dev);
+	const struct clk_stm32_clock_data *data = priv->data;
+
+	if  (composite->mux_id != NO_STM32_MUX) {
+		const struct stm32_mux_cfg *mux_cfg;
+
+		mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+		if (!mux)
+			goto fail;
+
+		mux_cfg = &data->muxes[composite->mux_id];
+
+		mux->reg = priv->base + mux_cfg->reg_off;
+		mux->shift = mux_cfg->shift;
+		mux->mask = BIT(mux_cfg->width) - 1;
+		mux->num_parents = mux_cfg->num_parents;
+		mux->flags = 0;
+		mux->parent_names = mux_cfg->parent_names;
+
+		mux_clk = &mux->clk;
+		mux_ops = &clk_mux_ops;
+
+		parent_names = mux_cfg->parent_names;
+		num_parents = mux_cfg->num_parents;
+	} else {
+		parent_names = &cfg->parent_name;
+		num_parents = 1;
+	}
+
+	if  (composite->div_id != NO_STM32_DIV) {
+		const struct stm32_div_cfg *div_cfg;
+
+		div = kzalloc(sizeof(*div), GFP_KERNEL);
+		if (!div)
+			goto fail;
+
+		div_cfg = &data->dividers[composite->div_id];
+
+		div->reg = priv->base + div_cfg->reg_off;
+		div->shift = div_cfg->shift;
+		div->width = div_cfg->width;
+		div->width = div_cfg->width;
+		div->flags = div_cfg->div_flags;
+		div->table = div_cfg->table;
+
+		div_clk = &div->clk;
+		div_ops = &clk_divider_ops;
+	}
+
+	if  (composite->gate_id != NO_STM32_GATE) {
+		gate = kzalloc(sizeof(*gate), GFP_KERNEL);
+		if (!gate)
+			goto fail;
+
+		gate->priv = priv;
+		gate->gate_id = composite->gate_id;
+
+		gate_clk = &gate->clk;
+		gate_ops = &clk_stm32_gate_ops;
+	}
+
+	clk = clk_register_composite(NULL, cfg->name,
+				     parent_names, num_parents,
+				     mux_clk, mux_ops,
+				     div_clk, div_ops,
+				     gate_clk, gate_ops,
+				     cfg->flags);
+	if (IS_ERR(clk))
+		goto fail;
+
+	return clk;
+
+fail:
+	kfree(gate);
+	kfree(div);
+	kfree(mux);
+	return ERR_CAST(clk);
+}
diff --git a/drivers/clk/stm32/clk-stm32-core.h b/drivers/clk/stm32/clk-stm32-core.h
new file mode 100644
index 0000000000..296ac297c5
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32-core.h
@@ -0,0 +1,276 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+struct stm32_clock_match_data;
+
+/**
+ * struct stm32_mux_cfg - multiplexer configuration
+ *
+ * @parent_names:	array of string names for all possible parents
+ * @num_parents:	number of possible parents
+ * @reg_off:		register controlling multiplexer
+ * @shift:		shift to multiplexer bit field
+ * @width:		width of the multiplexer bit field
+ * @mux_flags:		hardware-specific flags
+ * @table:		array of register values corresponding to the parent
+ *			index
+ */
+struct stm32_mux_cfg {
+	const char * const *parent_names;
+	u8 num_parents;
+	u32 reg_off;
+	u8 shift;
+	u8 width;
+	u8 mux_flags;
+	u32 *table;
+};
+
+/**
+ * struct stm32_gate_cfg - gating configuration
+ *
+ * @reg_off:	register controlling gate
+ * @bit_idx:	single bit controlling gate
+ * @gate_flags:	hardware-specific flags
+ * @set_clr:	0 : normal gate, 1 : has a register to clear the gate
+ */
+struct stm32_gate_cfg {
+	u32 reg_off;
+	u8 bit_idx;
+	u8 gate_flags;
+	u8 set_clr;
+};
+
+/**
+ * struct stm32_div_cfg - divider configuration
+ *
+ * @reg_off:	register containing the divider
+ * @shift:	shift to the divider bit field
+ * @width:	width of the divider bit field
+ * @table:	array of value/divider pairs, last entry should have div = 0
+ */
+struct stm32_div_cfg {
+	u32 reg_off;
+	u8 shift;
+	u8 width;
+	u8 div_flags;
+	const struct clk_div_table *table;
+};
+
+#define NO_STM32_MUX	-1
+#define NO_STM32_DIV	-1
+#define NO_STM32_GATE	-1
+
+/**
+ * struct stm32_composite_cfg - composite configuration
+ *
+ * @mux:	index of a multiplexer
+ * @gate:	index of a gate
+ * @div:	index of a divider
+ */
+struct stm32_composite_cfg {
+	int mux;
+	int gate;
+	int div;
+};
+
+/**
+ * struct clock_config - clock configuration
+ *
+ * @id:			binding id of the clock
+ * @name:		clock name
+ * @parent_name:	name of the clock parent
+ * @flags:		framework-specific flags
+ * @sec_id:		secure id (use to known if the clock is secured or not)
+ * @clock_cfg:		specific clock data configuration
+ * @setup:		specific call back to reister the clock (will use
+ *			clock_cfg data as input)
+ */
+struct clock_config {
+	unsigned long id;
+	const char *name;
+	const char *parent_name;
+	unsigned long flags;
+	int sec_id;
+	void *clock_cfg;
+
+	struct clk *(*setup)(struct udevice *dev,
+			     const struct clock_config *cfg);
+};
+
+/**
+ * struct clk_stm32_clock_data - clock data
+ *
+ * @num_gates:		number of defined gates
+ * @gates:		array of gate configuration
+ * @muxes:		array of multiplexer configuration
+ * @dividers:		array of divider configuration
+ */
+struct clk_stm32_clock_data {
+	unsigned int num_gates;
+	const struct stm32_gate_cfg *gates;
+	const struct stm32_mux_cfg *muxes;
+	const struct stm32_div_cfg *dividers;
+};
+
+/**
+ * struct stm32_clock_match_data - clock match data
+ *
+ * @num_gates:		number of clocks
+ * @tab_clocks:		array of clock configuration
+ * @clock_data:		definition of all gates / dividers / multiplexers
+ * @check_security:	call back to check if clock is secured or not
+ */
+struct stm32_clock_match_data {
+	unsigned int num_clocks;
+	const struct clock_config *tab_clocks;
+	const struct clk_stm32_clock_data *clock_data;
+	int (*check_security)(struct udevice *dev, void __iomem *base,
+			      const struct clock_config *cfg);
+};
+
+/**
+ * struct stm32mp_rcc_priv - private struct for stm32mp clocks
+ *
+ * @base:	base register of RCC driver
+ * @gate_cpt:	array of refcounting for gate with more than one
+ *		clocks as input. See explanation of Peripheral clock enabling
+ *              below.
+ * @data:	data for gate / divider / multiplexer configuration
+ */
+struct stm32mp_rcc_priv {
+	void __iomem *base;
+	u8 *gate_cpt;
+	const struct clk_stm32_clock_data *data;
+};
+
+int stm32_rcc_init(struct udevice *dev,
+		   const struct stm32_clock_match_data *data);
+
+/**
+ * STM32 Gate
+ *
+ *               PCE (Peripheral Clock Enabling)                  Peripheral
+ *
+ *                ------------------------------                   ----------
+ *               |                              |                 |          |
+ *               |                              |                 |   PERx   |
+ * bus_ck        |                   -----      |                 |          |
+ * ------------->|------------------|     |     |  ckg_bus_perx   |          |
+ *               |                  | AND |-----|---------------->|          |
+ *               |       -----------|     |     |                 |          |
+ *               |      |            -----      |                 |          |
+ *               |      |                       |                 |          |
+ *               |    -----                     |                 |          |
+ * Perx_EN |-----|---| GCL |  Gating            |                 |          |
+ *               |    -----   Control           |                 |          |
+ *               |      |     Logic             |                 |          |
+ *               |      |                       |                 |          |
+ *               |      |            -----      |                 |          |
+ *               |       -----------|     |     |  ckg_ker_perx   |          |
+ * perx_ker_ck   |                  | AND |-----|---------------->|          |
+ * ------------->|------------------|     |     |                 |          |
+ *               |                   -----      |                 |          |
+ *               |                              |                 |          |
+ *               |                              |                 |          |
+ *                ------------------------------                   ----------
+
+ * Each peripheral requires a bus interface clock, named ckg_bus_perx
+ * (for peripheral ‘x’).
+ * Some peripherals (SAI, UART...) need also a dedicated clock for their
+ * communication interface, this clock is generally asynchronous with respect to
+ * the bus interface clock, and is named kernel clock (ckg_ker_perx).
+
+ * Both clocks can be gated by one Perx_EN enable bit.
+ * Then we have to manage a refcounting on gate level to avoid gate if one
+ * the bus or the Kernel was enable.
+ *
+ * Example:
+ * 1) enable the bus clock
+ *	--> bus_clk ref_counting = 1, gate_ref_count = 1
+ * 2) enable the kernel clock
+ *	--> perx_ker_ck ref_counting = 1, gate_ref_count = 2
+ * 3) disable kernel clock
+ * 	---> perx_ker_ck ref_counting = 0, gate_ref_count = 1
+ * 	==> then i will not gate because gate_ref_count > 0
+ * 4) disable bus clock
+ *	--> bus_clk  ref_counting  = 0, gate_ref_count = 0
+ *	==> then i can gate (write in the register) because
+ *	    gate_ref_count = 0
+ */
+
+struct clk_stm32_gate {
+	struct clk clk;
+	struct stm32mp_rcc_priv *priv;
+	int gate_id;
+};
+
+#define to_clk_stm32_gate(_clk) container_of(_clk, struct clk_stm32_gate, clk)
+
+struct clk *
+clk_stm32_gate_register(struct udevice *dev,
+			const struct clock_config *cfg);
+
+struct clk *
+clk_stm32_register_composite(struct udevice *dev,
+			     const struct clock_config *cfg);
+
+struct stm32_clk_gate_cfg {
+	int gate_id;
+};
+
+#define STM32_GATE(_id, _name, _parent, _flags, _gate_id, _sec_id) \
+{ \
+	.id		= _id, \
+	.sec_id		= _sec_id, \
+	.name		= _name, \
+	.parent_name	= _parent, \
+	.flags		= _flags, \
+	.clock_cfg	= &(struct stm32_clk_gate_cfg) { \
+		.gate_id	= _gate_id, \
+	}, \
+	.setup		= clk_stm32_gate_register, \
+}
+
+struct stm32_clk_composite_cfg {
+	int	gate_id;
+	int	mux_id;
+	int	div_id;
+};
+
+#define STM32_COMPOSITE(_id, _name, _flags, _sec_id, \
+			_gate_id, _mux_id, _div_id) \
+{ \
+	.id		= _id, \
+	.name		= _name, \
+	.sec_id		= _sec_id, \
+	.flags		= _flags, \
+	.clock_cfg	= &(struct stm32_clk_composite_cfg) { \
+		.gate_id	= _gate_id, \
+		.mux_id		= _mux_id, \
+		.div_id		= _div_id, \
+	}, \
+	.setup		= clk_stm32_register_composite, \
+}
+
+#define STM32_COMPOSITE_NOMUX(_id, _name, _parent, _flags, _sec_id, \
+			      _gate_id, _div_id) \
+{ \
+	.id		= _id, \
+	.name		= _name, \
+	.parent_name	= _parent, \
+	.sec_id		= _sec_id, \
+	.flags		= _flags, \
+	.clock_cfg	= &(struct stm32_clk_composite_cfg) { \
+		.gate_id	= _gate_id, \
+		.mux_id		= NO_STM32_MUX, \
+		.div_id		= _div_id, \
+	}, \
+	.setup		= clk_stm32_register_composite, \
+}
+
+extern const struct clk_ops stm32_clk_ops;
+
+ulong clk_stm32_get_rate_by_name(const char *name);
diff --git a/drivers/clk/stm32/clk-stm32mp1.c b/drivers/clk/stm32/clk-stm32mp1.c
index 4f4524fcb2..7565947b2a 100644
--- a/drivers/clk/stm32/clk-stm32mp1.c
+++ b/drivers/clk/stm32/clk-stm32mp1.c
@@ -550,6 +550,7 @@ static const struct stm32mp1_clk_gate stm32mp1_clk_gate[] = {
 	STM32MP1_CLK_SET_CLR_F(RCC_MP_APB4ENSETR, 0, LTDC_PX, _PLL4_Q),
 	STM32MP1_CLK_SET_CLR_F(RCC_MP_APB4ENSETR, 4, DSI_PX, _PLL4_Q),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 4, DSI_K, _DSI_SEL),
+	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 4, DSI, _PLL4_P),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 8, DDRPERFM, _UNKNOWN_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 15, IWDG2, _UNKNOWN_SEL),
 	STM32MP1_CLK_SET_CLR(RCC_MP_APB4ENSETR, 16, USBPHY_K, _USBPHY_SEL),
@@ -881,7 +882,8 @@ static int stm32mp1_clk_get_parent(struct stm32mp1_clk_priv *priv,
 		return sel[s].parent[p];
 	}
 
-	log_err("no parents defined for clk id %d\n", (u32)id);
+	/* clock is DISABLED when the clock src is not in clk_parent[] range */
+	log_debug("no parents defined for clk id %d\n", (u32)id);
 
 	return -EINVAL;
 }
diff --git a/drivers/clk/stm32/clk-stm32mp13.c b/drivers/clk/stm32/clk-stm32mp13.c
new file mode 100644
index 0000000000..a946213cd3
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp13.c
@@ -0,0 +1,846 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#define LOG_CATEGORY UCLASS_CLK
+
+#include <clk-uclass.h>
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <asm/io.h>
+#include <dt-bindings/clock/stm32mp13-clks.h>
+#include <linux/clk-provider.h>
+
+#include "clk-stm32-core.h"
+#include "stm32mp13_rcc.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static const char * const adc12_src[] = {
+	"pll4_r", "ck_per", "pll3_q"
+};
+
+static const char * const dcmipp_src[] = {
+	"ck_axi", "pll2_q", "pll4_p", "ck_per",
+};
+
+static const char * const eth12_src[] = {
+	"pll4_p", "pll3_q"
+};
+
+static const char * const fdcan_src[] = {
+	"ck_hse", "pll3_q", "pll4_q", "pll4_r"
+};
+
+static const char * const fmc_src[] = {
+	"ck_axi", "pll3_r", "pll4_p", "ck_per"
+};
+
+static const char * const i2c12_src[] = {
+	"pclk1", "pll4_r", "ck_hsi", "ck_csi"
+};
+
+static const char * const i2c345_src[] = {
+	"pclk6", "pll4_r", "ck_hsi", "ck_csi"
+};
+
+static const char * const lptim1_src[] = {
+	"pclk1", "pll4_p", "pll3_q", "ck_lse", "ck_lsi", "ck_per"
+};
+
+static const char * const lptim23_src[] = {
+	"pclk3", "pll4_q", "ck_per", "ck_lse", "ck_lsi"
+};
+
+static const char * const lptim45_src[] = {
+	"pclk3", "pll4_p", "pll3_q", "ck_lse", "ck_lsi", "ck_per"
+};
+
+static const char * const mco1_src[] = {
+	"ck_hsi", "ck_hse", "ck_csi", "ck_lsi", "ck_lse"
+};
+
+static const char * const mco2_src[] = {
+	"ck_mpu", "ck_axi", "ck_mlahb", "pll4_p", "ck_hse", "ck_hsi"
+};
+
+static const char * const qspi_src[] = {
+	"ck_axi", "pll3_r", "pll4_p", "ck_per"
+};
+
+static const char * const rng1_src[] = {
+	"ck_csi", "pll4_r", "reserved", "ck_lsi"
+};
+
+static const char * const saes_src[] = {
+	"ck_axi", "ck_per", "pll4_r", "ck_lsi"
+};
+
+static const char * const sai1_src[] = {
+	"pll4_q", "pll3_q", "i2s_ckin", "ck_per", "pll3_r"
+};
+
+static const char * const sai2_src[] = {
+	"pll4_q", "pll3_q", "i2s_ckin", "ck_per", "spdif_ck_symb", "pll3_r"
+};
+
+static const char * const sdmmc12_src[] = {
+	"ck_axi", "pll3_r", "pll4_p", "ck_hsi"
+};
+
+static const char * const spdif_src[] = {
+	"pll4_p", "pll3_q", "ck_hsi"
+};
+
+static const char * const spi123_src[] = {
+	"pll4_p", "pll3_q", "i2s_ckin", "ck_per", "pll3_r"
+};
+
+static const char * const spi4_src[] = {
+	"pclk6", "pll4_q", "ck_hsi", "ck_csi", "ck_hse", "i2s_ckin"
+};
+
+static const char * const spi5_src[] = {
+	"pclk6", "pll4_q", "ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const stgen_src[] = {
+	"ck_hsi", "ck_hse"
+};
+
+static const char * const usart12_src[] = {
+	"pclk6", "pll3_q", "ck_hsi", "ck_csi", "pll4_q", "ck_hse"
+};
+
+static const char * const usart34578_src[] = {
+	"pclk1", "pll4_q", "ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const usart6_src[] = {
+	"pclk2", "pll4_q", "ck_hsi", "ck_csi", "ck_hse"
+};
+
+static const char * const usbo_src[] = {
+	"pll4_r", "ck_usbo_48m"
+};
+
+static const char * const usbphy_src[] = {
+	"ck_hse", "pll4_r", "clk-hse-div2"
+};
+
+enum enum_mux_cfg {
+	MUX_I2C12,
+	MUX_LPTIM45,
+	MUX_SPI23,
+	MUX_UART35,
+	MUX_UART78,
+	MUX_ADC1,
+	MUX_ADC2,
+	MUX_DCMIPP,
+	MUX_ETH1,
+	MUX_ETH2,
+	MUX_FDCAN,
+	MUX_FMC,
+	MUX_I2C3,
+	MUX_I2C4,
+	MUX_I2C5,
+	MUX_LPTIM1,
+	MUX_LPTIM2,
+	MUX_LPTIM3,
+	MUX_QSPI,
+	MUX_RNG1,
+	MUX_SAES,
+	MUX_SAI1,
+	MUX_SAI2,
+	MUX_SDMMC1,
+	MUX_SDMMC2,
+	MUX_SPDIF,
+	MUX_SPI1,
+	MUX_SPI4,
+	MUX_SPI5,
+	MUX_STGEN,
+	MUX_UART1,
+	MUX_UART2,
+	MUX_UART4,
+	MUX_UART6,
+	MUX_USBO,
+	MUX_USBPHY,
+	MUX_MCO1,
+	MUX_MCO2
+};
+
+#define MUX_CFG(id, src, _offset, _shift, _witdh) \
+	[id] = { \
+		.num_parents	= ARRAY_SIZE(src), \
+		.parent_names	= (src), \
+		.reg_off	= (_offset), \
+		.shift		= (_shift), \
+		.width		= (_witdh), \
+	}
+
+static const struct stm32_mux_cfg stm32mp13_muxes[] = {
+	MUX_CFG(MUX_I2C12,	i2c12_src,	RCC_I2C12CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM45,	lptim45_src,	RCC_LPTIM45CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI23,	spi123_src,	RCC_SPI2S23CKSELR, 0, 3),
+	MUX_CFG(MUX_UART35,	usart34578_src,	RCC_UART35CKSELR, 0, 3),
+	MUX_CFG(MUX_UART78,	usart34578_src,	RCC_UART78CKSELR, 0, 3),
+	MUX_CFG(MUX_ADC1,	adc12_src,	RCC_ADC12CKSELR, 0, 2),
+	MUX_CFG(MUX_ADC2,	adc12_src,	RCC_ADC12CKSELR, 2, 2),
+	MUX_CFG(MUX_DCMIPP,	dcmipp_src,	RCC_DCMIPPCKSELR, 0, 2),
+	MUX_CFG(MUX_ETH1,	eth12_src,	RCC_ETH12CKSELR, 0, 2),
+	MUX_CFG(MUX_ETH2,	eth12_src,	RCC_ETH12CKSELR, 8, 2),
+	MUX_CFG(MUX_FDCAN,	fdcan_src,	RCC_FDCANCKSELR, 0, 2),
+	MUX_CFG(MUX_FMC,	fmc_src,	RCC_FMCCKSELR, 0, 2),
+	MUX_CFG(MUX_I2C3,	i2c345_src,	RCC_I2C345CKSELR, 0, 3),
+	MUX_CFG(MUX_I2C4,	i2c345_src,	RCC_I2C345CKSELR, 3, 3),
+	MUX_CFG(MUX_I2C5,	i2c345_src,	RCC_I2C345CKSELR, 6, 3),
+	MUX_CFG(MUX_LPTIM1,	lptim1_src,	RCC_LPTIM1CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM2,	lptim23_src,	RCC_LPTIM23CKSELR, 0, 3),
+	MUX_CFG(MUX_LPTIM3,	lptim23_src,	RCC_LPTIM23CKSELR, 3, 3),
+	MUX_CFG(MUX_MCO1,	mco1_src,	RCC_MCO1CFGR, 0, 3),
+	MUX_CFG(MUX_MCO2,	mco2_src,	RCC_MCO2CFGR, 0, 3),
+	MUX_CFG(MUX_QSPI,	qspi_src,	RCC_QSPICKSELR, 0, 2),
+	MUX_CFG(MUX_RNG1,	rng1_src,	RCC_RNG1CKSELR, 0, 2),
+	MUX_CFG(MUX_SAES,	saes_src,	RCC_SAESCKSELR, 0, 2),
+	MUX_CFG(MUX_SAI1,	sai1_src,	RCC_SAI1CKSELR, 0, 3),
+	MUX_CFG(MUX_SAI2,	sai2_src,	RCC_SAI2CKSELR, 0, 3),
+	MUX_CFG(MUX_SDMMC1,	sdmmc12_src,	RCC_SDMMC12CKSELR, 0, 3),
+	MUX_CFG(MUX_SDMMC2,	sdmmc12_src,	RCC_SDMMC12CKSELR, 3, 3),
+	MUX_CFG(MUX_SPDIF,	spdif_src,	RCC_SPDIFCKSELR, 0, 2),
+	MUX_CFG(MUX_SPI1,	spi123_src,	RCC_SPI2S1CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI4,	spi4_src,	RCC_SPI45CKSELR, 0, 3),
+	MUX_CFG(MUX_SPI5,	spi5_src,	RCC_SPI45CKSELR, 3, 3),
+	MUX_CFG(MUX_STGEN,	stgen_src,	RCC_STGENCKSELR, 0, 2),
+	MUX_CFG(MUX_UART1,	usart12_src,	RCC_UART12CKSELR, 0, 3),
+	MUX_CFG(MUX_UART2,	usart12_src,	RCC_UART12CKSELR, 3, 3),
+	MUX_CFG(MUX_UART4,	usart34578_src,	RCC_UART4CKSELR, 0, 3),
+	MUX_CFG(MUX_UART6,	usart6_src,	RCC_UART6CKSELR, 0, 3),
+	MUX_CFG(MUX_USBO,	usbo_src,	RCC_USBCKSELR, 4, 1),
+	MUX_CFG(MUX_USBPHY,	usbphy_src,	RCC_USBCKSELR, 0, 2),
+};
+
+enum enum_gate_cfg {
+	GATE_ZERO, /* reserved for no gate */
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_DBGCK,
+	GATE_TRACECK,
+	GATE_DDRC1,
+	GATE_DDRC1LP,
+	GATE_DDRPHYC,
+	GATE_DDRPHYCLP,
+	GATE_DDRCAPB,
+	GATE_DDRCAPBLP,
+	GATE_AXIDCG,
+	GATE_DDRPHYCAPB,
+	GATE_DDRPHYCAPBLP,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_LPTIM1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_USART3,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_SPDIF,
+	GATE_TIM1,
+	GATE_TIM8,
+	GATE_SPI1,
+	GATE_USART6,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_DFSDM,
+	GATE_ADFSDM,
+	GATE_FDCAN,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_VREF,
+	GATE_DTS,
+	GATE_PMBCTRL,
+	GATE_HDP,
+	GATE_SYSCFG,
+	GATE_DCMIPP,
+	GATE_DDRPERFM,
+	GATE_IWDG2APB,
+	GATE_USBPHY,
+	GATE_STGENRO,
+	GATE_LTDC,
+	GATE_TZC,
+	GATE_ETZPC,
+	GATE_IWDG1APB,
+	GATE_BSEC,
+	GATE_STGENC,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_DMA1,
+	GATE_DMA2,
+	GATE_DMAMUX1,
+	GATE_DMA3,
+	GATE_DMAMUX2,
+	GATE_ADC1,
+	GATE_ADC2,
+	GATE_USBO,
+	GATE_TSC,
+	GATE_GPIOA,
+	GATE_GPIOB,
+	GATE_GPIOC,
+	GATE_GPIOD,
+	GATE_GPIOE,
+	GATE_GPIOF,
+	GATE_GPIOG,
+	GATE_GPIOH,
+	GATE_GPIOI,
+	GATE_PKA,
+	GATE_SAES,
+	GATE_CRYP1,
+	GATE_HASH1,
+	GATE_RNG1,
+	GATE_BKPSRAM,
+	GATE_AXIMC,
+	GATE_MCE,
+	GATE_ETH1CK,
+	GATE_ETH1TX,
+	GATE_ETH1RX,
+	GATE_ETH1MAC,
+	GATE_FMC,
+	GATE_QSPI,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_CRC1,
+	GATE_USBH,
+	GATE_ETH2CK,
+	GATE_ETH2TX,
+	GATE_ETH2RX,
+	GATE_ETH2MAC,
+	GATE_ETH1STP,
+	GATE_ETH2STP,
+	GATE_MDMA
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr) \
+	[id] = { \
+		.reg_off	= (_offset), \
+		.bit_idx	= (_bit_idx), \
+		.set_clr	= (_offset_clr), \
+	}
+
+static const struct stm32_gate_cfg stm32mp13_gates[] = {
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,	12,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,	12,	0),
+	GATE_CFG(GATE_DBGCK,		RCC_DBGCFGR,	8,	0),
+	GATE_CFG(GATE_TRACECK,		RCC_DBGCFGR,	9,	0),
+	GATE_CFG(GATE_DDRC1,		RCC_DDRITFCR,	0,	0),
+	GATE_CFG(GATE_DDRC1LP,		RCC_DDRITFCR,	1,	0),
+	GATE_CFG(GATE_DDRPHYC,		RCC_DDRITFCR,	4,	0),
+	GATE_CFG(GATE_DDRPHYCLP,	RCC_DDRITFCR,	5,	0),
+	GATE_CFG(GATE_DDRCAPB,		RCC_DDRITFCR,	6,	0),
+	GATE_CFG(GATE_DDRCAPBLP,	RCC_DDRITFCR,	7,	0),
+	GATE_CFG(GATE_AXIDCG,		RCC_DDRITFCR,	8,	0),
+	GATE_CFG(GATE_DDRPHYCAPB,	RCC_DDRITFCR,	9,	0),
+	GATE_CFG(GATE_DDRPHYCAPBLP,	RCC_DDRITFCR,	10,	0),
+	GATE_CFG(GATE_TIM2,		RCC_MP_APB1ENSETR,	0,	1),
+	GATE_CFG(GATE_TIM3,		RCC_MP_APB1ENSETR,	1,	1),
+	GATE_CFG(GATE_TIM4,		RCC_MP_APB1ENSETR,	2,	1),
+	GATE_CFG(GATE_TIM5,		RCC_MP_APB1ENSETR,	3,	1),
+	GATE_CFG(GATE_TIM6,		RCC_MP_APB1ENSETR,	4,	1),
+	GATE_CFG(GATE_TIM7,		RCC_MP_APB1ENSETR,	5,	1),
+	GATE_CFG(GATE_LPTIM1,		RCC_MP_APB1ENSETR,	9,	1),
+	GATE_CFG(GATE_SPI2,		RCC_MP_APB1ENSETR,	11,	1),
+	GATE_CFG(GATE_SPI3,		RCC_MP_APB1ENSETR,	12,	1),
+	GATE_CFG(GATE_USART3,		RCC_MP_APB1ENSETR,	15,	1),
+	GATE_CFG(GATE_UART4,		RCC_MP_APB1ENSETR,	16,	1),
+	GATE_CFG(GATE_UART5,		RCC_MP_APB1ENSETR,	17,	1),
+	GATE_CFG(GATE_UART7,		RCC_MP_APB1ENSETR,	18,	1),
+	GATE_CFG(GATE_UART8,		RCC_MP_APB1ENSETR,	19,	1),
+	GATE_CFG(GATE_I2C1,		RCC_MP_APB1ENSETR,	21,	1),
+	GATE_CFG(GATE_I2C2,		RCC_MP_APB1ENSETR,	22,	1),
+	GATE_CFG(GATE_SPDIF,		RCC_MP_APB1ENSETR,	26,	1),
+	GATE_CFG(GATE_TIM1,		RCC_MP_APB2ENSETR,	0,	1),
+	GATE_CFG(GATE_TIM8,		RCC_MP_APB2ENSETR,	1,	1),
+	GATE_CFG(GATE_SPI1,		RCC_MP_APB2ENSETR,	8,	1),
+	GATE_CFG(GATE_USART6,		RCC_MP_APB2ENSETR,	13,	1),
+	GATE_CFG(GATE_SAI1,		RCC_MP_APB2ENSETR,	16,	1),
+	GATE_CFG(GATE_SAI2,		RCC_MP_APB2ENSETR,	17,	1),
+	GATE_CFG(GATE_DFSDM,		RCC_MP_APB2ENSETR,	20,	1),
+	GATE_CFG(GATE_ADFSDM,		RCC_MP_APB2ENSETR,	21,	1),
+	GATE_CFG(GATE_FDCAN,		RCC_MP_APB2ENSETR,	24,	1),
+	GATE_CFG(GATE_LPTIM2,		RCC_MP_APB3ENSETR,	0,	1),
+	GATE_CFG(GATE_LPTIM3,		RCC_MP_APB3ENSETR,	1,	1),
+	GATE_CFG(GATE_LPTIM4,		RCC_MP_APB3ENSETR,	2,	1),
+	GATE_CFG(GATE_LPTIM5,		RCC_MP_APB3ENSETR,	3,	1),
+	GATE_CFG(GATE_VREF,		RCC_MP_APB3ENSETR,	13,	1),
+	GATE_CFG(GATE_DTS,		RCC_MP_APB3ENSETR,	16,	1),
+	GATE_CFG(GATE_PMBCTRL,		RCC_MP_APB3ENSETR,	17,	1),
+	GATE_CFG(GATE_HDP,		RCC_MP_APB3ENSETR,	20,	1),
+	GATE_CFG(GATE_SYSCFG,		RCC_MP_NS_APB3ENSETR,	0,	1),
+	GATE_CFG(GATE_DCMIPP,		RCC_MP_APB4ENSETR,	1,	1),
+	GATE_CFG(GATE_DDRPERFM,		RCC_MP_APB4ENSETR,	8,	1),
+	GATE_CFG(GATE_IWDG2APB,		RCC_MP_APB4ENSETR,	15,	1),
+	GATE_CFG(GATE_USBPHY,		RCC_MP_APB4ENSETR,	16,	1),
+	GATE_CFG(GATE_STGENRO,		RCC_MP_APB4ENSETR,	20,	1),
+	GATE_CFG(GATE_LTDC,		RCC_MP_NS_APB4ENSETR,	0,	1),
+	GATE_CFG(GATE_TZC,		RCC_MP_APB5ENSETR,	11,	1),
+	GATE_CFG(GATE_ETZPC,		RCC_MP_APB5ENSETR,	13,	1),
+	GATE_CFG(GATE_IWDG1APB,		RCC_MP_APB5ENSETR,	15,	1),
+	GATE_CFG(GATE_BSEC,		RCC_MP_APB5ENSETR,	16,	1),
+	GATE_CFG(GATE_STGENC,		RCC_MP_APB5ENSETR,	20,	1),
+	GATE_CFG(GATE_USART1,		RCC_MP_APB6ENSETR,	0,	1),
+	GATE_CFG(GATE_USART2,		RCC_MP_APB6ENSETR,	1,	1),
+	GATE_CFG(GATE_SPI4,		RCC_MP_APB6ENSETR,	2,	1),
+	GATE_CFG(GATE_SPI5,		RCC_MP_APB6ENSETR,	3,	1),
+	GATE_CFG(GATE_I2C3,		RCC_MP_APB6ENSETR,	4,	1),
+	GATE_CFG(GATE_I2C4,		RCC_MP_APB6ENSETR,	5,	1),
+	GATE_CFG(GATE_I2C5,		RCC_MP_APB6ENSETR,	6,	1),
+	GATE_CFG(GATE_TIM12,		RCC_MP_APB6ENSETR,	7,	1),
+	GATE_CFG(GATE_TIM13,		RCC_MP_APB6ENSETR,	8,	1),
+	GATE_CFG(GATE_TIM14,		RCC_MP_APB6ENSETR,	9,	1),
+	GATE_CFG(GATE_TIM15,		RCC_MP_APB6ENSETR,	10,	1),
+	GATE_CFG(GATE_TIM16,		RCC_MP_APB6ENSETR,	11,	1),
+	GATE_CFG(GATE_TIM17,		RCC_MP_APB6ENSETR,	12,	1),
+	GATE_CFG(GATE_DMA1,		RCC_MP_AHB2ENSETR,	0,	1),
+	GATE_CFG(GATE_DMA2,		RCC_MP_AHB2ENSETR,	1,	1),
+	GATE_CFG(GATE_DMAMUX1,		RCC_MP_AHB2ENSETR,	2,	1),
+	GATE_CFG(GATE_DMA3,		RCC_MP_AHB2ENSETR,	3,	1),
+	GATE_CFG(GATE_DMAMUX2,		RCC_MP_AHB2ENSETR,	4,	1),
+	GATE_CFG(GATE_ADC1,		RCC_MP_AHB2ENSETR,	5,	1),
+	GATE_CFG(GATE_ADC2,		RCC_MP_AHB2ENSETR,	6,	1),
+	GATE_CFG(GATE_USBO,		RCC_MP_AHB2ENSETR,	8,	1),
+	GATE_CFG(GATE_TSC,		RCC_MP_AHB4ENSETR,	15,	1),
+	GATE_CFG(GATE_GPIOA,		RCC_MP_NS_AHB4ENSETR,	0,	1),
+	GATE_CFG(GATE_GPIOB,		RCC_MP_NS_AHB4ENSETR,	1,	1),
+	GATE_CFG(GATE_GPIOC,		RCC_MP_NS_AHB4ENSETR,	2,	1),
+	GATE_CFG(GATE_GPIOD,		RCC_MP_NS_AHB4ENSETR,	3,	1),
+	GATE_CFG(GATE_GPIOE,		RCC_MP_NS_AHB4ENSETR,	4,	1),
+	GATE_CFG(GATE_GPIOF,		RCC_MP_NS_AHB4ENSETR,	5,	1),
+	GATE_CFG(GATE_GPIOG,		RCC_MP_NS_AHB4ENSETR,	6,	1),
+	GATE_CFG(GATE_GPIOH,		RCC_MP_NS_AHB4ENSETR,	7,	1),
+	GATE_CFG(GATE_GPIOI,		RCC_MP_NS_AHB4ENSETR,	8,	1),
+	GATE_CFG(GATE_PKA,		RCC_MP_AHB5ENSETR,	2,	1),
+	GATE_CFG(GATE_SAES,		RCC_MP_AHB5ENSETR,	3,	1),
+	GATE_CFG(GATE_CRYP1,		RCC_MP_AHB5ENSETR,	4,	1),
+	GATE_CFG(GATE_HASH1,		RCC_MP_AHB5ENSETR,	5,	1),
+	GATE_CFG(GATE_RNG1,		RCC_MP_AHB5ENSETR,	6,	1),
+	GATE_CFG(GATE_BKPSRAM,		RCC_MP_AHB5ENSETR,	8,	1),
+	GATE_CFG(GATE_AXIMC,		RCC_MP_AHB5ENSETR,	16,	1),
+	GATE_CFG(GATE_MCE,		RCC_MP_AHB6ENSETR,	1,	1),
+	GATE_CFG(GATE_ETH1CK,		RCC_MP_AHB6ENSETR,	7,	1),
+	GATE_CFG(GATE_ETH1TX,		RCC_MP_AHB6ENSETR,	8,	1),
+	GATE_CFG(GATE_ETH1RX,		RCC_MP_AHB6ENSETR,	9,	1),
+	GATE_CFG(GATE_ETH1MAC,		RCC_MP_AHB6ENSETR,	10,	1),
+	GATE_CFG(GATE_FMC,		RCC_MP_AHB6ENSETR,	12,	1),
+	GATE_CFG(GATE_QSPI,		RCC_MP_AHB6ENSETR,	14,	1),
+	GATE_CFG(GATE_SDMMC1,		RCC_MP_AHB6ENSETR,	16,	1),
+	GATE_CFG(GATE_SDMMC2,		RCC_MP_AHB6ENSETR,	17,	1),
+	GATE_CFG(GATE_CRC1,		RCC_MP_AHB6ENSETR,	20,	1),
+	GATE_CFG(GATE_USBH,		RCC_MP_AHB6ENSETR,	24,	1),
+	GATE_CFG(GATE_ETH2CK,		RCC_MP_AHB6ENSETR,	27,	1),
+	GATE_CFG(GATE_ETH2TX,		RCC_MP_AHB6ENSETR,	28,	1),
+	GATE_CFG(GATE_ETH2RX,		RCC_MP_AHB6ENSETR,	29,	1),
+	GATE_CFG(GATE_ETH2MAC,		RCC_MP_AHB6ENSETR,	30,	1),
+	GATE_CFG(GATE_ETH1STP,		RCC_MP_AHB6LPENSETR,	11,	1),
+	GATE_CFG(GATE_ETH2STP,		RCC_MP_AHB6LPENSETR,	31,	1),
+	GATE_CFG(GATE_MDMA,		RCC_MP_NS_AHB6ENSETR,	0,	1),
+};
+
+static const struct clk_div_table ck_trace_div_table[] = {
+	{ 0, 1 }, { 1, 2 }, { 2, 4 }, { 3, 8 },
+	{ 4, 16 }, { 5, 16 }, { 6, 16 }, { 7, 16 },
+	{ 0 },
+};
+
+enum enum_div_cfg {
+	DIV_MCO1,
+	DIV_MCO2,
+	DIV_TRACE,
+	DIV_ETH1PTP,
+	DIV_ETH2PTP,
+	LAST_DIV
+};
+
+#define DIV_CFG(id, _offset, _shift, _width, _flags, _table) \
+	[id] = { \
+		.reg_off	= _offset, \
+		.shift	= _shift, \
+		.width	= _width, \
+		.div_flags	= _flags, \
+		.table	= _table, \
+	}
+
+static const struct stm32_div_cfg stm32mp13_dividers[LAST_DIV] = {
+	DIV_CFG(DIV_MCO1, RCC_MCO1CFGR, 4, 4, 0, NULL),
+	DIV_CFG(DIV_MCO2, RCC_MCO2CFGR, 4, 4, 0, NULL),
+	DIV_CFG(DIV_TRACE, RCC_DBGCFGR, 0, 3, 0, ck_trace_div_table),
+	DIV_CFG(DIV_ETH1PTP, RCC_ETH12CKSELR, 4, 4, 0, NULL),
+	DIV_CFG(DIV_ETH2PTP, RCC_ETH12CKSELR, 12, 4, 0, NULL),
+};
+
+struct clk_stm32_securiy {
+	u16	offset;
+	u8	bit_idx;
+};
+
+enum securit_clk {
+	SECF_NONE,
+	SECF_LPTIM2,
+	SECF_LPTIM3,
+	SECF_VREF,
+	SECF_DCMIPP,
+	SECF_USBPHY,
+	SECF_RTC,
+	SECF_TZC,
+	SECF_ETZPC,
+	SECF_IWDG1,
+	SECF_BSEC,
+	SECF_STGENC,
+	SECF_STGENRO,
+	SECF_USART1,
+	SECF_USART2,
+	SECF_SPI4,
+	SECF_SPI5,
+	SECF_I2C3,
+	SECF_I2C4,
+	SECF_I2C5,
+	SECF_TIM12,
+	SECF_TIM13,
+	SECF_TIM14,
+	SECF_TIM15,
+	SECF_TIM16,
+	SECF_TIM17,
+	SECF_DMA3,
+	SECF_DMAMUX2,
+	SECF_ADC1,
+	SECF_ADC2,
+	SECF_USBO,
+	SECF_TSC,
+	SECF_PKA,
+	SECF_SAES,
+	SECF_CRYP1,
+	SECF_HASH1,
+	SECF_RNG1,
+	SECF_BKPSRAM,
+	SECF_MCE,
+	SECF_FMC,
+	SECF_QSPI,
+	SECF_SDMMC1,
+	SECF_SDMMC2,
+	SECF_ETH1CK,
+	SECF_ETH1TX,
+	SECF_ETH1RX,
+	SECF_ETH1MAC,
+	SECF_ETH1STP,
+	SECF_ETH2CK,
+	SECF_ETH2TX,
+	SECF_ETH2RX,
+	SECF_ETH2MAC,
+	SECF_ETH2STP,
+	SECF_MCO1,
+	SECF_MCO2
+};
+
+#define SECF(_sec_id, _offset, _bit_idx) \
+	[_sec_id] = { \
+		.offset	= _offset, \
+		.bit_idx	= _bit_idx, \
+	}
+
+static const struct clk_stm32_securiy stm32mp13_security[] = {
+	SECF(SECF_LPTIM2, RCC_APB3SECSR, RCC_APB3SECSR_LPTIM2SECF),
+	SECF(SECF_LPTIM3, RCC_APB3SECSR, RCC_APB3SECSR_LPTIM3SECF),
+	SECF(SECF_VREF, RCC_APB3SECSR, RCC_APB3SECSR_VREFSECF),
+	SECF(SECF_DCMIPP, RCC_APB4SECSR, RCC_APB4SECSR_DCMIPPSECF),
+	SECF(SECF_USBPHY, RCC_APB4SECSR, RCC_APB4SECSR_USBPHYSECF),
+	SECF(SECF_RTC, RCC_APB5SECSR, RCC_APB5SECSR_RTCSECF),
+	SECF(SECF_TZC, RCC_APB5SECSR, RCC_APB5SECSR_TZCSECF),
+	SECF(SECF_ETZPC, RCC_APB5SECSR, RCC_APB5SECSR_ETZPCSECF),
+	SECF(SECF_IWDG1, RCC_APB5SECSR, RCC_APB5SECSR_IWDG1SECF),
+	SECF(SECF_BSEC, RCC_APB5SECSR, RCC_APB5SECSR_BSECSECF),
+	SECF(SECF_STGENC, RCC_APB5SECSR, RCC_APB5SECSR_STGENCSECF),
+	SECF(SECF_STGENRO, RCC_APB5SECSR, RCC_APB5SECSR_STGENROSECF),
+	SECF(SECF_USART1, RCC_APB6SECSR, RCC_APB6SECSR_USART1SECF),
+	SECF(SECF_USART2, RCC_APB6SECSR, RCC_APB6SECSR_USART2SECF),
+	SECF(SECF_SPI4, RCC_APB6SECSR, RCC_APB6SECSR_SPI4SECF),
+	SECF(SECF_SPI5, RCC_APB6SECSR, RCC_APB6SECSR_SPI5SECF),
+	SECF(SECF_I2C3, RCC_APB6SECSR, RCC_APB6SECSR_I2C3SECF),
+	SECF(SECF_I2C4, RCC_APB6SECSR, RCC_APB6SECSR_I2C4SECF),
+	SECF(SECF_I2C5, RCC_APB6SECSR, RCC_APB6SECSR_I2C5SECF),
+	SECF(SECF_TIM12, RCC_APB6SECSR, RCC_APB6SECSR_TIM12SECF),
+	SECF(SECF_TIM13, RCC_APB6SECSR, RCC_APB6SECSR_TIM13SECF),
+	SECF(SECF_TIM14, RCC_APB6SECSR, RCC_APB6SECSR_TIM14SECF),
+	SECF(SECF_TIM15, RCC_APB6SECSR, RCC_APB6SECSR_TIM15SECF),
+	SECF(SECF_TIM16, RCC_APB6SECSR, RCC_APB6SECSR_TIM16SECF),
+	SECF(SECF_TIM17, RCC_APB6SECSR, RCC_APB6SECSR_TIM17SECF),
+	SECF(SECF_DMA3, RCC_AHB2SECSR, RCC_AHB2SECSR_DMA3SECF),
+	SECF(SECF_DMAMUX2, RCC_AHB2SECSR, RCC_AHB2SECSR_DMAMUX2SECF),
+	SECF(SECF_ADC1, RCC_AHB2SECSR, RCC_AHB2SECSR_ADC1SECF),
+	SECF(SECF_ADC2, RCC_AHB2SECSR, RCC_AHB2SECSR_ADC2SECF),
+	SECF(SECF_USBO, RCC_AHB2SECSR, RCC_AHB2SECSR_USBOSECF),
+	SECF(SECF_TSC, RCC_AHB4SECSR, RCC_AHB4SECSR_TSCSECF),
+	SECF(SECF_PKA, RCC_AHB5SECSR, RCC_AHB5SECSR_PKASECF),
+	SECF(SECF_SAES, RCC_AHB5SECSR, RCC_AHB5SECSR_SAESSECF),
+	SECF(SECF_CRYP1, RCC_AHB5SECSR, RCC_AHB5SECSR_CRYP1SECF),
+	SECF(SECF_HASH1, RCC_AHB5SECSR, RCC_AHB5SECSR_HASH1SECF),
+	SECF(SECF_RNG1, RCC_AHB5SECSR, RCC_AHB5SECSR_RNG1SECF),
+	SECF(SECF_BKPSRAM, RCC_AHB5SECSR, RCC_AHB5SECSR_BKPSRAMSECF),
+	SECF(SECF_MCE, RCC_AHB6SECSR, RCC_AHB6SECSR_MCESECF),
+	SECF(SECF_FMC, RCC_AHB6SECSR, RCC_AHB6SECSR_FMCSECF),
+	SECF(SECF_QSPI, RCC_AHB6SECSR, RCC_AHB6SECSR_QSPISECF),
+	SECF(SECF_SDMMC1, RCC_AHB6SECSR, RCC_AHB6SECSR_SDMMC1SECF),
+	SECF(SECF_SDMMC2, RCC_AHB6SECSR, RCC_AHB6SECSR_SDMMC2SECF),
+	SECF(SECF_ETH1CK, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1CKSECF),
+	SECF(SECF_ETH1TX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1TXSECF),
+	SECF(SECF_ETH1RX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1RXSECF),
+	SECF(SECF_ETH1MAC, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1MACSECF),
+	SECF(SECF_ETH1STP, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH1STPSECF),
+	SECF(SECF_ETH2CK, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2CKSECF),
+	SECF(SECF_ETH2TX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2TXSECF),
+	SECF(SECF_ETH2RX, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2RXSECF),
+	SECF(SECF_ETH2MAC, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2MACSECF),
+	SECF(SECF_ETH2STP, RCC_AHB6SECSR, RCC_AHB6SECSR_ETH2STPSECF),
+	SECF(SECF_MCO1, RCC_SECCFGR, RCC_SECCFGR_MCO1SECF),
+	SECF(SECF_MCO2, RCC_SECCFGR, RCC_SECCFGR_MCO2SECF),
+};
+
+#define PCLK(_id, _name, _parent, _flags, _gate_id, _sec_id) \
+	STM32_GATE(_id, _name, _parent, _flags, _gate_id, _sec_id)
+
+#define TIMER(_id, _name, _parent, _flags, _gate_id, _sec_id) \
+	STM32_GATE(_id, _name, _parent, ((_flags) | CLK_SET_RATE_PARENT), \
+		   _gate_id, _sec_id)
+
+#define KCLK(_id, _name, _flags, _gate_id, _mux_id, _sec_id) \
+	STM32_COMPOSITE(_id, _name, _flags, _sec_id, \
+			_gate_id, _mux_id, NO_STM32_DIV)
+
+static const struct clock_config stm32mp13_clock_cfg[] = {
+	TIMER(TIM2_K, "tim2_k", "timg1_ck", 0, GATE_TIM2, SECF_NONE),
+	TIMER(TIM3_K, "tim3_k", "timg1_ck", 0, GATE_TIM3, SECF_NONE),
+	TIMER(TIM4_K, "tim4_k", "timg1_ck", 0, GATE_TIM4, SECF_NONE),
+	TIMER(TIM5_K, "tim5_k", "timg1_ck", 0, GATE_TIM5, SECF_NONE),
+	TIMER(TIM6_K, "tim6_k", "timg1_ck", 0, GATE_TIM6, SECF_NONE),
+	TIMER(TIM7_K, "tim7_k", "timg1_ck", 0, GATE_TIM7, SECF_NONE),
+	TIMER(TIM1_K, "tim1_k", "timg2_ck", 0, GATE_TIM1, SECF_NONE),
+	TIMER(TIM8_K, "tim8_k", "timg2_ck", 0, GATE_TIM8, SECF_NONE),
+	TIMER(TIM12_K, "tim12_k", "timg3_ck", 0, GATE_TIM12, SECF_TIM12),
+	TIMER(TIM13_K, "tim13_k", "timg3_ck", 0, GATE_TIM13, SECF_TIM13),
+	TIMER(TIM14_K, "tim14_k", "timg3_ck", 0, GATE_TIM14, SECF_TIM14),
+	TIMER(TIM15_K, "tim15_k", "timg3_ck", 0, GATE_TIM15, SECF_TIM15),
+	TIMER(TIM16_K, "tim16_k", "timg3_ck", 0, GATE_TIM16, SECF_TIM16),
+	TIMER(TIM17_K, "tim17_k", "timg3_ck", 0, GATE_TIM17, SECF_TIM17),
+
+	/* Peripheral clocks */
+	PCLK(SYSCFG, "syscfg", "pclk3", 0, GATE_SYSCFG, SECF_NONE),
+	PCLK(VREF, "vref", "pclk3", 0, GATE_VREF, SECF_VREF),
+	PCLK(PMBCTRL, "pmbctrl", "pclk3", 0, GATE_PMBCTRL, SECF_NONE),
+	PCLK(HDP, "hdp", "pclk3", 0, GATE_HDP, SECF_NONE),
+	PCLK(IWDG2, "iwdg2", "pclk4", 0, GATE_IWDG2APB, SECF_NONE),
+	PCLK(STGENRO, "stgenro", "pclk4", 0, GATE_STGENRO, SECF_STGENRO),
+	PCLK(TZPC, "tzpc", "pclk5", 0, GATE_TZC, SECF_TZC),
+	PCLK(IWDG1, "iwdg1", "pclk5", 0, GATE_IWDG1APB, SECF_IWDG1),
+	PCLK(BSEC, "bsec", "pclk5", 0, GATE_BSEC, SECF_BSEC),
+	PCLK(DMA1, "dma1", "ck_mlahb", 0, GATE_DMA1, SECF_NONE),
+	PCLK(DMA2, "dma2", "ck_mlahb",  0, GATE_DMA2, SECF_NONE),
+	PCLK(DMAMUX1, "dmamux1", "ck_mlahb", 0, GATE_DMAMUX1, SECF_NONE),
+	PCLK(DMAMUX2, "dmamux2", "ck_mlahb", 0, GATE_DMAMUX2, SECF_DMAMUX2),
+	PCLK(ADC1, "adc1", "ck_mlahb", 0, GATE_ADC1, SECF_ADC1),
+	PCLK(ADC2, "adc2", "ck_mlahb", 0, GATE_ADC2, SECF_ADC2),
+	PCLK(GPIOA, "gpioa", "pclk4", 0, GATE_GPIOA, SECF_NONE),
+	PCLK(GPIOB, "gpiob", "pclk4", 0, GATE_GPIOB, SECF_NONE),
+	PCLK(GPIOC, "gpioc", "pclk4", 0, GATE_GPIOC, SECF_NONE),
+	PCLK(GPIOD, "gpiod", "pclk4", 0, GATE_GPIOD, SECF_NONE),
+	PCLK(GPIOE, "gpioe", "pclk4", 0, GATE_GPIOE, SECF_NONE),
+	PCLK(GPIOF, "gpiof", "pclk4", 0, GATE_GPIOF, SECF_NONE),
+	PCLK(GPIOG, "gpiog", "pclk4", 0, GATE_GPIOG, SECF_NONE),
+	PCLK(GPIOH, "gpioh", "pclk4", 0, GATE_GPIOH, SECF_NONE),
+	PCLK(GPIOI, "gpioi", "pclk4", 0, GATE_GPIOI, SECF_NONE),
+	PCLK(TSC, "tsc", "pclk4", 0, GATE_TSC, SECF_TZC),
+	PCLK(PKA, "pka", "ck_axi", 0, GATE_PKA, SECF_PKA),
+	PCLK(CRYP1, "cryp1", "ck_axi", 0, GATE_CRYP1, SECF_CRYP1),
+	PCLK(HASH1, "hash1", "ck_axi", 0, GATE_HASH1, SECF_HASH1),
+	PCLK(BKPSRAM, "bkpsram", "ck_axi", 0, GATE_BKPSRAM, SECF_BKPSRAM),
+	PCLK(MDMA, "mdma", "ck_axi", 0, GATE_MDMA, SECF_NONE),
+	PCLK(ETH1TX, "eth1tx", "ck_axi", 0, GATE_ETH1TX, SECF_ETH1TX),
+	PCLK(ETH1RX, "eth1rx", "ck_axi", 0, GATE_ETH1RX, SECF_ETH1RX),
+	PCLK(ETH1MAC, "eth1mac", "ck_axi", 0, GATE_ETH1MAC, SECF_ETH1MAC),
+	PCLK(ETH2TX, "eth2tx", "ck_axi", 0, GATE_ETH2TX, SECF_ETH2TX),
+	PCLK(ETH2RX, "eth2rx", "ck_axi", 0, GATE_ETH2RX, SECF_ETH2RX),
+	PCLK(ETH2MAC, "eth2mac", "ck_axi", 0, GATE_ETH2MAC, SECF_ETH2MAC),
+	PCLK(CRC1, "crc1", "ck_axi", 0, GATE_CRC1, SECF_NONE),
+	PCLK(USBH, "usbh", "ck_axi", 0, GATE_USBH, SECF_NONE),
+	PCLK(DDRPERFM, "ddrperfm", "pclk4", 0, GATE_DDRPERFM, SECF_NONE),
+	PCLK(ETH1STP, "eth1stp", "ck_axi", 0, GATE_ETH1STP, SECF_ETH1STP),
+	PCLK(ETH2STP, "eth2stp", "ck_axi", 0, GATE_ETH2STP, SECF_ETH2STP),
+	PCLK(SPI1, "spi1", "pclk2", 0, GATE_SPI1, SECF_NONE),
+	PCLK(SPI2, "spi2", "pclk1", 0, GATE_SPI2, SECF_NONE),
+	PCLK(SPI3, "spi3", "pclk1", 0, GATE_SPI3, SECF_NONE),
+	PCLK(SPI4, "spi4", "pclk6", 0, GATE_SPI4, SECF_SPI4),
+	PCLK(SPI5, "spi5", "pclk6", 0, GATE_SPI5, SECF_SPI5),
+
+	/* Kernel clocks */
+	KCLK(SDMMC1_K, "sdmmc1_k", 0, GATE_SDMMC1, MUX_SDMMC1, SECF_SDMMC1),
+	KCLK(SDMMC2_K, "sdmmc2_k", 0, GATE_SDMMC2, MUX_SDMMC2, SECF_SDMMC2),
+	KCLK(FMC_K, "fmc_k", 0, GATE_FMC, MUX_FMC, SECF_FMC),
+	KCLK(QSPI_K, "qspi_k", 0, GATE_QSPI, MUX_QSPI, SECF_QSPI),
+	KCLK(SPI2_K, "spi2_k", 0, GATE_SPI2, MUX_SPI23, SECF_NONE),
+	KCLK(SPI3_K, "spi3_k", 0, GATE_SPI3, MUX_SPI23, SECF_NONE),
+	KCLK(I2C1_K, "i2c1_k", 0, GATE_I2C1, MUX_I2C12, SECF_NONE),
+	KCLK(I2C2_K, "i2c2_k", 0, GATE_I2C2, MUX_I2C12, SECF_NONE),
+	KCLK(LPTIM4_K, "lptim4_k", 0, GATE_LPTIM4, MUX_LPTIM45, SECF_NONE),
+	KCLK(LPTIM5_K, "lptim5_k", 0, GATE_LPTIM5, MUX_LPTIM45, SECF_NONE),
+	KCLK(USART3_K, "usart3_k", 0, GATE_USART3, MUX_UART35, SECF_NONE),
+	KCLK(UART5_K, "uart5_k", 0, GATE_UART5, MUX_UART35, SECF_NONE),
+	KCLK(UART7_K, "uart7_k", 0, GATE_UART7, MUX_UART78, SECF_NONE),
+	KCLK(UART8_K, "uart8_k", 0, GATE_UART8, MUX_UART78, SECF_NONE),
+	KCLK(RNG1_K, "rng1_k", 0, GATE_RNG1, MUX_RNG1, SECF_RNG1),
+	KCLK(USBPHY_K, "usbphy_k", 0, GATE_USBPHY, MUX_USBPHY, SECF_USBPHY),
+	KCLK(STGEN_K, "stgen_k", 0, GATE_STGENC, MUX_STGEN, SECF_STGENC),
+	KCLK(SPDIF_K, "spdif_k", 0, GATE_SPDIF, MUX_SPDIF, SECF_NONE),
+	KCLK(SPI1_K, "spi1_k", 0, GATE_SPI1, MUX_SPI1, SECF_NONE),
+	KCLK(SPI4_K, "spi4_k", 0, GATE_SPI4, MUX_SPI4, SECF_SPI4),
+	KCLK(SPI5_K, "spi5_k", 0, GATE_SPI5, MUX_SPI5, SECF_SPI5),
+	KCLK(I2C3_K, "i2c3_k", 0, GATE_I2C3, MUX_I2C3, SECF_I2C3),
+	KCLK(I2C4_K, "i2c4_k", 0, GATE_I2C4, MUX_I2C4, SECF_I2C4),
+	KCLK(I2C5_K, "i2c5_k", 0, GATE_I2C5, MUX_I2C5, SECF_I2C5),
+	KCLK(LPTIM1_K, "lptim1_k", 0, GATE_LPTIM1, MUX_LPTIM1, SECF_NONE),
+	KCLK(LPTIM2_K, "lptim2_k", 0, GATE_LPTIM2, MUX_LPTIM2, SECF_LPTIM2),
+	KCLK(LPTIM3_K, "lptim3_k", 0, GATE_LPTIM3, MUX_LPTIM3, SECF_LPTIM3),
+	KCLK(USART1_K, "usart1_k", 0, GATE_USART1, MUX_UART1, SECF_USART1),
+	KCLK(USART2_K, "usart2_k", 0, GATE_USART2, MUX_UART2, SECF_USART2),
+	KCLK(UART4_K, "uart4_k", 0, GATE_UART4, MUX_UART4, SECF_NONE),
+	KCLK(USART6_K, "uart6_k", 0, GATE_USART6, MUX_UART6, SECF_NONE),
+	KCLK(FDCAN_K, "fdcan_k", 0, GATE_FDCAN, MUX_FDCAN, SECF_NONE),
+	KCLK(SAI1_K, "sai1_k", 0, GATE_SAI1, MUX_SAI1, SECF_NONE),
+	KCLK(SAI2_K, "sai2_k", 0, GATE_SAI2, MUX_SAI2, SECF_NONE),
+	KCLK(ADC1_K, "adc1_k", 0, GATE_ADC1, MUX_ADC1, SECF_ADC1),
+	KCLK(ADC2_K, "adc2_k", 0, GATE_ADC2, MUX_ADC2, SECF_ADC2),
+	KCLK(DCMIPP_K, "dcmipp_k", 0, GATE_DCMIPP, MUX_DCMIPP, SECF_DCMIPP),
+	KCLK(ADFSDM_K, "adfsdm_k", 0, GATE_ADFSDM, MUX_SAI1, SECF_NONE),
+	KCLK(USBO_K, "usbo_k", 0, GATE_USBO, MUX_USBO, SECF_USBO),
+	KCLK(ETH1CK_K, "eth1ck_k", 0, GATE_ETH1CK, MUX_ETH1, SECF_ETH1CK),
+	KCLK(ETH2CK_K, "eth2ck_k", 0, GATE_ETH2CK, MUX_ETH2, SECF_ETH2CK),
+	KCLK(SAES_K, "saes_k", 0, GATE_SAES, MUX_SAES, SECF_SAES),
+
+	STM32_GATE(DFSDM_K, "dfsdm_k", "ck_mlahb", 0, GATE_DFSDM, SECF_NONE),
+	STM32_GATE(LTDC_PX, "ltdc_px", "pll4_q", CLK_SET_RATE_PARENT,
+		   GATE_LTDC, SECF_NONE),
+
+	STM32_GATE(DTS_K, "dts_k", "ck_lse", 0, GATE_DTS, SECF_NONE),
+
+	STM32_COMPOSITE(ETH1PTP_K, "eth1ptp_k", CLK_OPS_PARENT_ENABLE |
+		  CLK_SET_RATE_NO_REPARENT, SECF_ETH1CK,
+		  NO_STM32_GATE, MUX_ETH1, DIV_ETH1PTP),
+
+	STM32_COMPOSITE(ETH2PTP_K, "eth2ptp_k", CLK_OPS_PARENT_ENABLE |
+		  CLK_SET_RATE_NO_REPARENT, SECF_ETH2CK,
+		  NO_STM32_GATE, MUX_ETH2, DIV_ETH2PTP),
+
+	/* MCO clocks */
+	STM32_COMPOSITE(CK_MCO1, "ck_mco1", CLK_OPS_PARENT_ENABLE |
+			CLK_SET_RATE_NO_REPARENT, SECF_MCO1,
+			GATE_MCO1, MUX_MCO1, DIV_MCO1),
+
+	STM32_COMPOSITE(CK_MCO2, "ck_mco2", CLK_OPS_PARENT_ENABLE |
+			CLK_SET_RATE_NO_REPARENT, SECF_MCO2,
+			GATE_MCO2, MUX_MCO2, DIV_MCO2),
+
+	/* Debug clocks */
+	STM32_GATE(CK_DBG, "ck_sys_dbg", "ck_axi", CLK_IGNORE_UNUSED,
+		   GATE_DBGCK, SECF_NONE),
+
+	STM32_COMPOSITE_NOMUX(CK_TRACE, "ck_trace", "ck_axi",
+			      CLK_OPS_PARENT_ENABLE, SECF_NONE,
+			      GATE_TRACECK, DIV_TRACE),
+};
+
+static int stm32mp13_check_security(struct udevice *dev, void __iomem *base,
+				    const struct clock_config *cfg)
+{
+	int sec_id = cfg->sec_id;
+	int secured = 0;
+
+	if (sec_id != SECF_NONE) {
+		const struct clk_stm32_securiy *secf;
+
+		secf = &stm32mp13_security[sec_id];
+		secured = !!(readl(base + secf->offset) & BIT(secf->bit_idx));
+	}
+
+	return secured;
+}
+
+static const struct stm32_clock_match_data stm32mp13_data = {
+	.tab_clocks	= stm32mp13_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp13_clock_cfg),
+	.clock_data = &(const struct clk_stm32_clock_data) {
+		.num_gates	= ARRAY_SIZE(stm32mp13_gates),
+		.gates		= stm32mp13_gates,
+		.muxes		= stm32mp13_muxes,
+		.dividers	= stm32mp13_dividers,
+	},
+	.check_security = stm32mp13_check_security,
+};
+
+static int stm32mp1_clk_probe(struct udevice *dev)
+{
+	struct udevice *scmi;
+	int err;
+
+	/* force SCMI probe to register all SCMI clocks */
+	uclass_get_device_by_driver(UCLASS_CLK, DM_DRIVER_GET(scmi_clock), &scmi);
+
+	err = stm32_rcc_init(dev, &stm32mp13_data);
+	if (err)
+		return err;
+
+	gd->cpu_clk = clk_stm32_get_rate_by_name("ck_mpu");
+	gd->bus_clk = clk_stm32_get_rate_by_name("ck_axi");
+
+	/* DDRPHYC father */
+	gd->mem_clk = clk_stm32_get_rate_by_name("pll2_r");
+
+	if (IS_ENABLED(CONFIG_DISPLAY_CPUINFO)) {
+		if (gd->flags & GD_FLG_RELOC) {
+			char buf[32];
+
+			log_info("Clocks:\n");
+			log_info("- MPU : %s MHz\n", strmhz(buf, gd->cpu_clk));
+			log_info("- AXI : %s MHz\n", strmhz(buf, gd->bus_clk));
+			log_info("- PER : %s MHz\n",
+				 strmhz(buf, clk_stm32_get_rate_by_name("ck_per")));
+			log_info("- DDR : %s MHz\n", strmhz(buf, gd->mem_clk));
+		}
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(stm32mp1_clock) = {
+	.name = "stm32mp13_clk",
+	.id = UCLASS_CLK,
+	.ops = &stm32_clk_ops,
+	.priv_auto = sizeof(struct stm32mp_rcc_priv),
+	.probe = stm32mp1_clk_probe,
+};
diff --git a/drivers/clk/stm32/clk-stm32mp25.c b/drivers/clk/stm32/clk-stm32mp25.c
new file mode 100644
index 0000000000..c02094707d
--- /dev/null
+++ b/drivers/clk/stm32/clk-stm32mp25.c
@@ -0,0 +1,786 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#include <clk-uclass.h>
+#include <common.h>
+#include <dm.h>
+#include <dt-bindings/bus/stm32mp25_sys_bus.h>
+#include <dt-bindings/clock/stm32mp25-clks.h>
+#include <linux/bitfield.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <mach/rif.h>
+
+#include "clk-stm32-core.h"
+#include "stm32mp25_rcc.h"
+
+/* Clock security definition */
+#define SECF_NONE		-1
+
+#define RCC_REG_SIZE	32
+#define RCC_SECCFGR(x)	(((x) / RCC_REG_SIZE) * 0x4 + RCC_SECCFGR0)
+#define RCC_CIDCFGR(x)	((x) * 0x8 + RCC_R0CIDCFGR)
+#define RCC_SEMCR(x)	((x) * 0x8 + RCC_R0SEMCR)
+#define RCC_CID1	1
+
+/* Register: RIFSC_CIDCFGR */
+#define RCC_CIDCFGR_CFEN	BIT(0)
+#define RCC_CIDCFGR_SEM_EN	BIT(1)
+#define RCC_CIDCFGR_SEMWLC1_EN	BIT(17)
+#define RCC_CIDCFGR_SCID_MASK	GENMASK(6, 4)
+
+/* Register: RIFSC_SEMCR */
+#define RCC_SEMCR_SEMCID_MASK	GENMASK(6, 4)
+
+#define STM32MP25_RIFRCC_DBG_ID		73
+#define STM32MP25_RIFRCC_IS2M_ID	107
+#define STM32MP25_RIFRCC_MCO1_ID	108
+#define STM32MP25_RIFRCC_MCO2_ID	109
+#define STM32MP25_RIFRCC_OSPI1_ID	110
+#define STM32MP25_RIFRCC_OSPI2_ID	111
+
+#define SEC_RIFSC_FLAG		BIT(31)
+#define SEC_RIFRCC(_id)		(STM32MP25_RIFRCC_##_id##_ID)
+#define SEC_RIFSC(_name)	(STM32MP25_RIFSC_##_name##_ID | SEC_RIFSC_FLAG)
+
+static const char * const adc12_src[] = {
+	"ck_flexgen_46", "ck_icn_ls_mcu"
+};
+
+static const char * const adc3_src[] = {
+	"ck_flexgen_47", "ck_icn_ls_mcu", "ck_flexgen_46"
+};
+
+static const char * const usb2phy1_src[] = {
+	"ck_flexgen_57", "hse_div2_ck"
+};
+
+static const char * const usb2phy2_src[] = {
+	"ck_flexgen_58", "hse_div2_ck"
+};
+
+static const char * const usb3pciphy_src[] = {
+	"ck_flexgen_34", "hse_div2_ck"
+};
+
+static const char * const dsiblane_src[] = {
+	"txbyteclk", "ck_ker_ltdc"
+};
+
+static const char * const dsiphy_src[] = {
+	"ck_flexgen_28", "hse_ck"
+};
+
+static const char * const lvdsphy_src[] = {
+	"ck_flexgen_32", "hse_ck"
+};
+
+static const char * const dts_src[] = {
+	"hsi_ck", "hse_ck", "msi_ck"
+};
+
+static const char * const mco1_src[] = {
+	"ck_flexgen_61", "ck_obs0"
+};
+
+static const char * const mco2_src[] = {
+	"ck_flexgen_62", "ck_obs1"
+};
+
+enum enum_mux_cfg {
+	MUX_MCO1,
+	MUX_MCO2,
+	MUX_ADC12,
+	MUX_ADC3,
+	MUX_USB2PHY1,
+	MUX_USB2PHY2,
+	MUX_USB3PCIEPHY,
+	MUX_DSIBLANE,
+	MUX_DSIPHY,
+	MUX_LVDSPHY,
+	MUX_DTS,
+	MUX_NB
+};
+
+#define MUX_CFG(id, src, _offset, _shift, _witdh)[id] = {\
+		.num_parents	= ARRAY_SIZE(src),\
+		.parent_names	= src,\
+		.reg_off	= (_offset),\
+		.shift		= (_shift),\
+		.width		= (_witdh),\
+}
+
+static const struct stm32_mux_cfg stm32mp25_muxes[MUX_NB] = {
+	MUX_CFG(MUX_ADC12,		adc12_src,	RCC_ADC12CFGR,		12,	1),
+	MUX_CFG(MUX_ADC3,		adc3_src,	RCC_ADC3CFGR,		12,	2),
+	MUX_CFG(MUX_DSIBLANE,		dsiblane_src,	RCC_DSICFGR,		12,	1),
+	MUX_CFG(MUX_DSIPHY,		dsiphy_src,	RCC_DSICFGR,		15,	1),
+	MUX_CFG(MUX_DTS,		dts_src,	RCC_DTSCFGR,		12,	2),
+	MUX_CFG(MUX_MCO1,		mco1_src,	RCC_MCO1CFGR,		0,	1),
+	MUX_CFG(MUX_MCO2,		mco2_src,	RCC_MCO2CFGR,		0,	1),
+	MUX_CFG(MUX_LVDSPHY,		lvdsphy_src,	RCC_LVDSCFGR,		15,	1),
+	MUX_CFG(MUX_USB2PHY1,		usb2phy1_src,	RCC_USB2PHY1CFGR,	15,	1),
+	MUX_CFG(MUX_USB2PHY2,		usb2phy2_src,	RCC_USB2PHY2CFGR,	15,	1),
+	MUX_CFG(MUX_USB3PCIEPHY,	usb3pciphy_src,	RCC_USB3PCIEPHYCFGR,	15,	1),
+};
+
+enum enum_gate_cfg {
+	GATE_ADC12,
+	GATE_ADC3,
+	GATE_ADF1,
+	GATE_CCI,
+	GATE_CRC,
+	GATE_CRYP1,
+	GATE_CRYP2,
+	GATE_CSI,
+	GATE_DBG,
+	GATE_DCMIPP,
+	GATE_DSI,
+	GATE_DTS,
+	GATE_ETH1,
+	GATE_ETH1MAC,
+	GATE_ETH1RX,
+	GATE_ETH1STP,
+	GATE_ETH1TX,
+	GATE_ETH2,
+	GATE_ETH2MAC,
+	GATE_ETH2RX,
+	GATE_ETH2STP,
+	GATE_ETH2TX,
+	GATE_ETHSW,
+	GATE_ETHSWMAC,
+	GATE_ETHSWREF,
+	GATE_ETR,
+	GATE_FDCAN,
+	GATE_GPU,
+	GATE_HASH,
+	GATE_HDP,
+	GATE_I2C1,
+	GATE_I2C2,
+	GATE_I2C3,
+	GATE_I2C4,
+	GATE_I2C5,
+	GATE_I2C6,
+	GATE_I2C7,
+	GATE_I2C8,
+	GATE_I3C1,
+	GATE_I3C2,
+	GATE_I3C3,
+	GATE_I3C4,
+	GATE_IS2M,
+	GATE_IWDG1,
+	GATE_IWDG2,
+	GATE_IWDG3,
+	GATE_IWDG4,
+	GATE_IWDG5,
+	GATE_LPTIM1,
+	GATE_LPTIM2,
+	GATE_LPTIM3,
+	GATE_LPTIM4,
+	GATE_LPTIM5,
+	GATE_LPUART1,
+	GATE_LTDC,
+	GATE_LVDS,
+	GATE_MCO1,
+	GATE_MCO2,
+	GATE_MDF1,
+	GATE_OSPI1,
+	GATE_OSPI2,
+	GATE_OSPIIOM,
+	GATE_PCIE,
+	GATE_PKA,
+	GATE_RNG,
+	GATE_SAES,
+	GATE_SAI1,
+	GATE_SAI2,
+	GATE_SAI3,
+	GATE_SAI4,
+	GATE_SDMMC1,
+	GATE_SDMMC2,
+	GATE_SDMMC3,
+	GATE_SERC,
+	GATE_SPDIFRX,
+	GATE_SPI1,
+	GATE_SPI2,
+	GATE_SPI3,
+	GATE_SPI4,
+	GATE_SPI5,
+	GATE_SPI6,
+	GATE_SPI7,
+	GATE_SPI8,
+	GATE_STGEN,
+	GATE_STM500,
+	GATE_TIM1,
+	GATE_TIM2,
+	GATE_TIM3,
+	GATE_TIM4,
+	GATE_TIM5,
+	GATE_TIM6,
+	GATE_TIM7,
+	GATE_TIM8,
+	GATE_TIM10,
+	GATE_TIM11,
+	GATE_TIM12,
+	GATE_TIM13,
+	GATE_TIM14,
+	GATE_TIM15,
+	GATE_TIM16,
+	GATE_TIM17,
+	GATE_TIM20,
+	GATE_TRACE,
+	GATE_UART4,
+	GATE_UART5,
+	GATE_UART7,
+	GATE_UART8,
+	GATE_UART9,
+	GATE_USART1,
+	GATE_USART2,
+	GATE_USART3,
+	GATE_USART6,
+	GATE_USB2,
+	GATE_USB2PHY1,
+	GATE_USB2PHY2,
+	GATE_USB3DR,
+	GATE_USB3PCIEPHY,
+	GATE_USBTC,
+	GATE_VDEC,
+	GATE_VENC,
+	GATE_VREF,
+	GATE_WWDG1,
+	GATE_WWDG2,
+	GATE_NB
+};
+
+#define GATE_CFG(id, _offset, _bit_idx, _offset_clr)[id] = {\
+	.reg_off	= (_offset),\
+	.bit_idx	= (_bit_idx),\
+	.set_clr	= (_offset_clr),\
+}
+
+static const struct stm32_gate_cfg stm32mp25_gates[GATE_NB] = {
+	GATE_CFG(GATE_MCO1,		RCC_MCO1CFGR,		8,	0),
+	GATE_CFG(GATE_MCO2,		RCC_MCO2CFGR,		8,	0),
+	GATE_CFG(GATE_OSPI1,		RCC_OSPI1CFGR,		1,	0),
+	GATE_CFG(GATE_OSPI2,		RCC_OSPI2CFGR,		1,	0),
+	GATE_CFG(GATE_DBG,		RCC_DBGCFGR,		8,	0),
+	GATE_CFG(GATE_TRACE,		RCC_DBGCFGR,		9,	0),
+	GATE_CFG(GATE_STM500,		RCC_STM500CFGR,		1,	0),
+	GATE_CFG(GATE_ETR,		RCC_ETRCFGR,		1,	0),
+	GATE_CFG(GATE_IS2M,		RCC_IS2MCFGR,		1,	0),
+	GATE_CFG(GATE_TIM1,		RCC_TIM1CFGR,		1,	0),
+	GATE_CFG(GATE_TIM2,		RCC_TIM2CFGR,		1,	0),
+	GATE_CFG(GATE_TIM3,		RCC_TIM3CFGR,		1,	0),
+	GATE_CFG(GATE_TIM4,		RCC_TIM4CFGR,		1,	0),
+	GATE_CFG(GATE_TIM5,		RCC_TIM5CFGR,		1,	0),
+	GATE_CFG(GATE_TIM6,		RCC_TIM6CFGR,		1,	0),
+	GATE_CFG(GATE_TIM7,		RCC_TIM7CFGR,		1,	0),
+	GATE_CFG(GATE_TIM8,		RCC_TIM8CFGR,		1,	0),
+	GATE_CFG(GATE_TIM10,		RCC_TIM10CFGR,		1,	0),
+	GATE_CFG(GATE_TIM11,		RCC_TIM11CFGR,		1,	0),
+	GATE_CFG(GATE_TIM12,		RCC_TIM12CFGR,		1,	0),
+	GATE_CFG(GATE_TIM13,		RCC_TIM13CFGR,		1,	0),
+	GATE_CFG(GATE_TIM14,		RCC_TIM14CFGR,		1,	0),
+	GATE_CFG(GATE_TIM15,		RCC_TIM15CFGR,		1,	0),
+	GATE_CFG(GATE_TIM16,		RCC_TIM16CFGR,		1,	0),
+	GATE_CFG(GATE_TIM17,		RCC_TIM17CFGR,		1,	0),
+	GATE_CFG(GATE_TIM20,		RCC_TIM20CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM1,		RCC_LPTIM1CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM2,		RCC_LPTIM2CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM3,		RCC_LPTIM3CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM4,		RCC_LPTIM4CFGR,		1,	0),
+	GATE_CFG(GATE_LPTIM5,		RCC_LPTIM5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI1,		RCC_SPI1CFGR,		1,	0),
+	GATE_CFG(GATE_SPI2,		RCC_SPI2CFGR,		1,	0),
+	GATE_CFG(GATE_SPI3,		RCC_SPI3CFGR,		1,	0),
+	GATE_CFG(GATE_SPI4,		RCC_SPI4CFGR,		1,	0),
+	GATE_CFG(GATE_SPI5,		RCC_SPI5CFGR,		1,	0),
+	GATE_CFG(GATE_SPI6,		RCC_SPI6CFGR,		1,	0),
+	GATE_CFG(GATE_SPI7,		RCC_SPI7CFGR,		1,	0),
+	GATE_CFG(GATE_SPI8,		RCC_SPI8CFGR,		1,	0),
+	GATE_CFG(GATE_SPDIFRX,		RCC_SPDIFRXCFGR,	1,	0),
+	GATE_CFG(GATE_USART1,		RCC_USART1CFGR,		1,	0),
+	GATE_CFG(GATE_USART2,		RCC_USART2CFGR,		1,	0),
+	GATE_CFG(GATE_USART3,		RCC_USART3CFGR,		1,	0),
+	GATE_CFG(GATE_UART4,		RCC_UART4CFGR,		1,	0),
+	GATE_CFG(GATE_UART5,		RCC_UART5CFGR,		1,	0),
+	GATE_CFG(GATE_USART6,		RCC_USART6CFGR,		1,	0),
+	GATE_CFG(GATE_UART7,		RCC_UART7CFGR,		1,	0),
+	GATE_CFG(GATE_UART8,		RCC_UART8CFGR,		1,	0),
+	GATE_CFG(GATE_UART9,		RCC_UART9CFGR,		1,	0),
+	GATE_CFG(GATE_LPUART1,		RCC_LPUART1CFGR,	1,	0),
+	GATE_CFG(GATE_I2C1,		RCC_I2C1CFGR,		1,	0),
+	GATE_CFG(GATE_I2C2,		RCC_I2C2CFGR,		1,	0),
+	GATE_CFG(GATE_I2C3,		RCC_I2C3CFGR,		1,	0),
+	GATE_CFG(GATE_I2C4,		RCC_I2C4CFGR,		1,	0),
+	GATE_CFG(GATE_I2C5,		RCC_I2C5CFGR,		1,	0),
+	GATE_CFG(GATE_I2C6,		RCC_I2C6CFGR,		1,	0),
+	GATE_CFG(GATE_I2C7,		RCC_I2C7CFGR,		1,	0),
+	GATE_CFG(GATE_I2C8,		RCC_I2C8CFGR,		1,	0),
+	GATE_CFG(GATE_SAI1,		RCC_SAI1CFGR,		1,	0),
+	GATE_CFG(GATE_SAI2,		RCC_SAI2CFGR,		1,	0),
+	GATE_CFG(GATE_SAI3,		RCC_SAI3CFGR,		1,	0),
+	GATE_CFG(GATE_SAI4,		RCC_SAI4CFGR,		1,	0),
+	GATE_CFG(GATE_MDF1,		RCC_MDF1CFGR,		1,	0),
+	GATE_CFG(GATE_ADF1,		RCC_ADF1CFGR,		1,	0),
+	GATE_CFG(GATE_FDCAN,		RCC_FDCANCFGR,		1,	0),
+	GATE_CFG(GATE_HDP,		RCC_HDPCFGR,		1,	0),
+	GATE_CFG(GATE_ADC12,		RCC_ADC12CFGR,		1,	0),
+	GATE_CFG(GATE_ADC3,		RCC_ADC3CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1MAC,		RCC_ETH1CFGR,		1,	0),
+	GATE_CFG(GATE_ETH1STP,		RCC_ETH1CFGR,		4,	0),
+	GATE_CFG(GATE_ETH1,		RCC_ETH1CFGR,		5,	0),
+	GATE_CFG(GATE_ETH1TX,		RCC_ETH1CFGR,		8,	0),
+	GATE_CFG(GATE_ETH1RX,		RCC_ETH1CFGR,		10,	0),
+	GATE_CFG(GATE_ETH2MAC,		RCC_ETH2CFGR,		1,	0),
+	GATE_CFG(GATE_ETH2STP,		RCC_ETH2CFGR,		4,	0),
+	GATE_CFG(GATE_ETH2,		RCC_ETH2CFGR,		5,	0),
+	GATE_CFG(GATE_ETH2TX,		RCC_ETH2CFGR,		8,	0),
+	GATE_CFG(GATE_ETH2RX,		RCC_ETH2CFGR,		10,	0),
+	GATE_CFG(GATE_USB2,		RCC_USB2CFGR,		1,	0),
+	GATE_CFG(GATE_USB2PHY1,		RCC_USB2PHY1CFGR,	1,	0),
+	GATE_CFG(GATE_USB2PHY2,		RCC_USB2PHY2CFGR,	1,	0),
+	GATE_CFG(GATE_USB3DR,		RCC_USB3DRCFGR,		1,	0),
+	GATE_CFG(GATE_USB3PCIEPHY,	RCC_USB3PCIEPHYCFGR,	1,	0),
+	GATE_CFG(GATE_PCIE,		RCC_PCIECFGR,		1,	0),
+	GATE_CFG(GATE_USBTC,		RCC_USBTCCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSWMAC,		RCC_ETHSWCFGR,		1,	0),
+	GATE_CFG(GATE_ETHSW,		RCC_ETHSWCFGR,		5,	0),
+	GATE_CFG(GATE_ETHSWREF,		RCC_ETHSWCFGR,		21,	0),
+	GATE_CFG(GATE_STGEN,		RCC_STGENCFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC1,		RCC_SDMMC1CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC2,		RCC_SDMMC2CFGR,		1,	0),
+	GATE_CFG(GATE_SDMMC3,		RCC_SDMMC3CFGR,		1,	0),
+	GATE_CFG(GATE_GPU,		RCC_GPUCFGR,		1,	0),
+	GATE_CFG(GATE_LTDC,		RCC_LTDCCFGR,		1,	0),
+	GATE_CFG(GATE_DSI,		RCC_DSICFGR,		1,	0),
+	GATE_CFG(GATE_LVDS,		RCC_LVDSCFGR,		1,	0),
+	GATE_CFG(GATE_CSI,		RCC_CSICFGR,		1,	0),
+	GATE_CFG(GATE_DCMIPP,		RCC_DCMIPPCFGR,		1,	0),
+	GATE_CFG(GATE_CCI,		RCC_CCICFGR,		1,	0),
+	GATE_CFG(GATE_VDEC,		RCC_VDECCFGR,		1,	0),
+	GATE_CFG(GATE_VENC,		RCC_VENCCFGR,		1,	0),
+	GATE_CFG(GATE_RNG,		RCC_RNGCFGR,		1,	0),
+	GATE_CFG(GATE_PKA,		RCC_PKACFGR,		1,	0),
+	GATE_CFG(GATE_SAES,		RCC_SAESCFGR,		1,	0),
+	GATE_CFG(GATE_HASH,		RCC_HASHCFGR,		1,	0),
+	GATE_CFG(GATE_CRYP1,		RCC_CRYP1CFGR,		1,	0),
+	GATE_CFG(GATE_CRYP2,		RCC_CRYP2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG1,		RCC_IWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG2,		RCC_IWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG3,		RCC_IWDG3CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG4,		RCC_IWDG4CFGR,		1,	0),
+	GATE_CFG(GATE_IWDG5,		RCC_IWDG5CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG1,		RCC_WWDG1CFGR,		1,	0),
+	GATE_CFG(GATE_WWDG2,		RCC_WWDG2CFGR,		1,	0),
+	GATE_CFG(GATE_VREF,		RCC_VREFCFGR,		1,	0),
+	GATE_CFG(GATE_DTS,		RCC_DTSCFGR,		1,	0),
+	GATE_CFG(GATE_CRC,		RCC_CRCCFGR,		1,	0),
+	GATE_CFG(GATE_SERC,		RCC_SERCCFGR,		1,	0),
+	GATE_CFG(GATE_OSPIIOM,		RCC_OSPIIOMCFGR,	1,	0),
+	GATE_CFG(GATE_I3C1,		RCC_I3C1CFGR,		1,	0),
+	GATE_CFG(GATE_I3C2,		RCC_I3C2CFGR,		1,	0),
+	GATE_CFG(GATE_I3C3,		RCC_I3C3CFGR,		1,	0),
+	GATE_CFG(GATE_I3C4,		RCC_I3C4CFGR,		1,	0),
+};
+
+static int stm32_rcc_get_access(struct udevice *dev, u32 index)
+{
+	fdt_addr_t rcc_base = dev_read_addr(dev->parent);
+	u32 seccfgr, cidcfgr, semcr;
+	int bit, cid;
+
+	bit = index % RCC_REG_SIZE;
+
+	seccfgr = readl(rcc_base + RCC_SECCFGR(index));
+	if (seccfgr & BIT(bit))
+		return -EACCES;
+
+	cidcfgr = readl(rcc_base + RCC_CIDCFGR(index));
+	if (!(cidcfgr & RCC_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & RCC_CIDCFGR_SEM_EN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(RCC_CIDCFGR_SCID_MASK, cidcfgr);
+		if (cid != RCC_CID1)
+			return -EACCES;
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & RCC_CIDCFGR_SEMWLC1_EN))
+		return -EACCES;
+
+	semcr = readl(rcc_base + RCC_SEMCR(index));
+
+	cid = FIELD_GET(RCC_SEMCR_SEMCID_MASK, semcr);
+	if (cid != RCC_CID1)
+		return -EACCES;
+
+	return 0;
+}
+
+static int stm32mp25_check_security(struct udevice *dev, void __iomem *base,
+				    const struct clock_config *cfg)
+{
+	int ret = 0;
+
+	if (cfg->sec_id != SECF_NONE) {
+		u32 index = (u32)cfg->sec_id;
+
+		if (index & SEC_RIFSC_FLAG)
+			ret = stm32_rifsc_check_access_by_id(dev_ofnode(dev),
+							     index & ~SEC_RIFSC_FLAG);
+		else
+			ret = stm32_rcc_get_access(dev, index);
+	}
+
+	return ret;
+}
+
+#define STM32_COMPOSITE_NODIV(_id, _name, _flags, _sec_id, _gate_id, _mux_id)\
+	STM32_COMPOSITE(_id, _name, _flags, _sec_id, _gate_id, _mux_id, NO_STM32_DIV)
+
+static const struct clock_config stm32mp25_clock_cfg[] = {
+	/* ADC */
+	STM32_GATE(CK_BUS_ADC12, "ck_icn_p_adc12", "ck_icn_ls_mcu", 0, GATE_ADC12,
+		   SEC_RIFSC(ADC12)),
+	STM32_COMPOSITE_NODIV(CK_KER_ADC12, "ck_ker_adc12", 0, SEC_RIFSC(ADC12),
+			      GATE_ADC12, MUX_ADC12),
+	STM32_GATE(CK_BUS_ADC3, "ck_icn_p_adc3", "ck_icn_ls_mcu", 0, GATE_ADC3, SEC_RIFSC(ADC3)),
+	STM32_COMPOSITE_NODIV(CK_KER_ADC3, "ck_ker_adc3", 0, SEC_RIFSC(ADC3), GATE_ADC3, MUX_ADC3),
+
+	/* ADF */
+	STM32_GATE(CK_BUS_ADF1, "ck_icn_p_adf1", "ck_icn_ls_mcu", 0, GATE_ADF1, SEC_RIFSC(ADF1)),
+	STM32_GATE(CK_KER_ADF1, "ck_ker_adf1", "ck_flexgen_42", 0, GATE_ADF1, SEC_RIFSC(ADF1)),
+
+	/* Camera */
+	/* DCMI */
+	STM32_GATE(CK_BUS_CCI, "ck_icn_p_cci", "ck_icn_ls_mcu", 0, GATE_CCI, SEC_RIFSC(DCMI_PSSI)),
+
+	/*TODO: check csi gate for all clocks ? */
+	/* CSI-HOST */
+	STM32_GATE(CK_BUS_CSI, "ck_icn_p_csi", "ck_icn_apb4", 0, GATE_CSI, SEC_RIFSC(CSI)),
+	STM32_GATE(CK_KER_CSI, "ck_ker_csi", "ck_flexgen_29", 0, GATE_CSI, SEC_RIFSC(CSI)),
+	STM32_GATE(CK_KER_CSITXESC, "ck_ker_csitxesc", "ck_flexgen_30", 0, GATE_CSI,
+		   SEC_RIFSC(CSI)),
+
+	/* CSI-PHY */
+	STM32_GATE(CK_KER_CSIPHY, "ck_ker_csiphy", "ck_flexgen_31", 0, GATE_CSI,
+		   SEC_RIFSC(CSI)),
+
+	/* DCMIPP */
+	STM32_GATE(CK_BUS_DCMIPP, "ck_icn_p_dcmipp", "ck_icn_apb4", 0, GATE_DCMIPP,
+		   SEC_RIFSC(DCMIPP)),
+
+	/* CRC */
+	STM32_GATE(CK_BUS_CRC, "ck_icn_p_crc", "ck_icn_ls_mcu", 0, GATE_CRC, SEC_RIFSC(CRC)),
+
+	/* CRYP */
+	STM32_GATE(CK_BUS_CRYP1, "ck_icn_p_cryp1", "ck_icn_ls_mcu", 0, GATE_CRYP1,
+		   SEC_RIFSC(CRYP1)),
+	STM32_GATE(CK_BUS_CRYP2, "ck_icn_p_cryp2", "ck_icn_ls_mcu", 0, GATE_CRYP2,
+		   SEC_RIFSC(CRYP2)),
+
+	/* DBG & TRACE*/
+	/* Trace and debug clocks are managed by SCMI */
+
+	/* Display subsystem */
+	/* LTDC */
+	STM32_GATE(CK_BUS_LTDC, "ck_icn_p_ltdc", "ck_icn_apb4", 0, GATE_LTDC, SEC_RIFSC(LTDC_CMN)),
+	STM32_GATE(CK_KER_LTDC, "ck_ker_ltdc", "ck_flexgen_27", CLK_SET_RATE_PARENT, GATE_LTDC,
+		   SEC_RIFSC(LTDC_CMN)),
+
+	/* DSI */
+	STM32_GATE(CK_BUS_DSI, "ck_icn_p_dsi", "ck_icn_apb4", 0, GATE_DSI, SEC_RIFSC(DSI_CMN)),
+	STM32_COMPOSITE_NODIV(CK_KER_DSIBLANE, "clk_lanebyte", 0, SEC_RIFSC(DSI_CMN),
+			      GATE_DSI, MUX_DSIBLANE),
+
+	/* LVDS */
+	STM32_GATE(CK_BUS_LVDS, "ck_icn_p_lvds", "ck_icn_apb4", 0, GATE_LVDS, SEC_RIFSC(LVDS)),
+
+	/* DSI PHY */
+	STM32_COMPOSITE_NODIV(CK_KER_DSIPHY, "ck_ker_dsiphy", 0, SEC_RIFSC(DSI_CMN),
+			      GATE_DSI, MUX_DSIPHY),
+
+	/* LVDS PHY */
+	STM32_COMPOSITE_NODIV(CK_KER_LVDSPHY, "ck_ker_lvdsphy", 0, SEC_RIFSC(LVDS),
+			      GATE_LVDS, MUX_LVDSPHY),
+
+	/* DTS */
+	STM32_COMPOSITE_NODIV(CK_KER_DTS, "ck_ker_dts", 0, SEC_RIFSC(DTS), GATE_DTS, MUX_DTS),
+
+	/* ETHERNET */
+	STM32_GATE(CK_BUS_ETH1, "ck_icn_p_eth1", "ck_icn_ls_mcu", 0, GATE_ETH1, SEC_RIFSC(ETH1)),
+	STM32_GATE(CK_ETH1_STP, "ck_ker_eth1stp", "ck_icn_ls_mcu", 0, GATE_ETH1STP,
+		   SEC_RIFSC(ETH1)),
+	STM32_GATE(CK_KER_ETH1, "ck_ker_eth1", "ck_flexgen_54", 0, GATE_ETH1, SEC_RIFSC(ETH1)),
+	STM32_GATE(CK_KER_ETH1, "ck_ker_eth1ptp", "ck_flexgen_56", 0, GATE_ETH1, SEC_RIFSC(ETH1)),
+	STM32_GATE(CK_ETH1_MAC, "ck_ker_eth1mac", "ck_icn_ls_mcu", 0, GATE_ETH1MAC,
+		   SEC_RIFSC(ETH1)),
+	STM32_GATE(CK_ETH1_TX, "ck_ker_eth1tx", "ck_icn_ls_mcu", 0, GATE_ETH1TX, SEC_RIFSC(ETH1)),
+	STM32_GATE(CK_ETH1_RX, "ck_ker_eth1rx", "ck_icn_ls_mcu", 0, GATE_ETH1RX, SEC_RIFSC(ETH1)),
+
+	STM32_GATE(CK_BUS_ETH2, "ck_icn_p_eth2", "ck_icn_ls_mcu", 0, GATE_ETH2, SEC_RIFSC(ETH2)),
+	STM32_GATE(CK_ETH2_STP, "ck_ker_eth2stp", "ck_icn_ls_mcu", 0, GATE_ETH2STP,
+		   SEC_RIFSC(ETH2)),
+	STM32_GATE(CK_KER_ETH2, "ck_ker_eth2", "ck_flexgen_54", 0, GATE_ETH2, SEC_RIFSC(ETH2)),
+	STM32_GATE(CK_KER_ETH2, "ck_ker_eth2ptp", "ck_flexgen_56", 0, GATE_ETH2, SEC_RIFSC(ETH2)),
+	STM32_GATE(CK_ETH2_MAC, "ck_ker_eth2mac", "ck_icn_ls_mcu", 0, GATE_ETH2MAC,
+		   SEC_RIFSC(ETH2)),
+	STM32_GATE(CK_ETH2_TX, "ck_ker_eth2tx", "ck_icn_ls_mcu", 0, GATE_ETH2TX, SEC_RIFSC(ETH2)),
+	STM32_GATE(CK_ETH2_RX, "ck_ker_eth2rx", "ck_icn_ls_mcu", 0, GATE_ETH2RX, SEC_RIFSC(ETH2)),
+
+	STM32_GATE(CK_BUS_ETHSW, "ck_icn_p_ethsw", "ck_icn_ls_mcu", 0, GATE_ETHSWMAC,
+		   SEC_RIFSC(ETHSW_DEIP)),
+	STM32_GATE(CK_KER_ETHSW, "ck_ker_ethsw", "ck_flexgen_54", 0, GATE_ETHSW,
+		   SEC_RIFSC(ETHSW_DEIP)),
+	STM32_GATE(CK_KER_ETHSWREF, "ck_ker_ethswref", "ck_flexgen_60", 0, GATE_ETHSWREF,
+		   SEC_RIFSC(ETHSW_DEIP)),
+
+	/* FDCAN */
+	STM32_GATE(CK_BUS_FDCAN, "ck_icn_p_fdcan", "ck_icn_apb2", 0, GATE_FDCAN, SEC_RIFSC(FDCAN)),
+	STM32_GATE(CK_KER_FDCAN, "ck_ker_fdcan", "ck_flexgen_26", 0, GATE_FDCAN, SEC_RIFSC(FDCAN)),
+
+	/* GPU */
+	STM32_GATE(CK_BUS_GPU, "ck_icn_m_gpu", "ck_flexgen_59", 0, GATE_GPU, SEC_RIFSC(GPU)),
+	STM32_GATE(CK_KER_GPU, "ck_ker_gpu", "ck_pll3", 0, GATE_GPU, SEC_RIFSC(GPU)),
+
+	/* HASH */
+	STM32_GATE(CK_BUS_HASH, "ck_icn_p_hash", "ck_icn_ls_mcu", 0, GATE_HASH, SEC_RIFSC(HASH)),
+
+	/* HDP */
+	STM32_GATE(CK_BUS_HDP, "ck_icn_p_hdp", "ck_icn_apb3", 0, GATE_HDP, SEC_RIFSC(HDP)),
+
+	/* I2C */
+	STM32_GATE(CK_KER_I2C1, "ck_ker_i2c1", "ck_flexgen_12", 0, GATE_I2C1, SEC_RIFSC(I2C1)),
+	STM32_GATE(CK_KER_I2C2, "ck_ker_i2c2", "ck_flexgen_12", 0, GATE_I2C2, SEC_RIFSC(I2C2)),
+	STM32_GATE(CK_KER_I2C3, "ck_ker_i2c3", "ck_flexgen_13", 0, GATE_I2C3, SEC_RIFSC(I2C3)),
+	STM32_GATE(CK_KER_I2C5, "ck_ker_i2c5", "ck_flexgen_13", 0, GATE_I2C5, SEC_RIFSC(I2C5)),
+	STM32_GATE(CK_KER_I2C4, "ck_ker_i2c4", "ck_flexgen_14", 0, GATE_I2C4, SEC_RIFSC(I2C4)),
+	STM32_GATE(CK_KER_I2C6, "ck_ker_i2c6", "ck_flexgen_14", 0, GATE_I2C6, SEC_RIFSC(I2C6)),
+	STM32_GATE(CK_KER_I2C7, "ck_ker_i2c7", "ck_flexgen_15", 0, GATE_I2C7, SEC_RIFSC(I2C7)),
+	STM32_GATE(CK_KER_I2C8, "ck_ker_i2c8", "ck_flexgen_38", 0, GATE_I2C8, SEC_RIFSC(I2C8)),
+
+	/* I3C */
+	STM32_GATE(CK_KER_I3C1, "ck_ker_i3c1", "ck_flexgen_12", 0, GATE_I3C1, SEC_RIFSC(I3C1)),
+	STM32_GATE(CK_KER_I3C2, "ck_ker_i3c2", "ck_flexgen_12", 0, GATE_I3C2, SEC_RIFSC(I3C2)),
+	STM32_GATE(CK_KER_I3C3, "ck_ker_i3c3", "ck_flexgen_13", 0, GATE_I3C3, SEC_RIFSC(I3C3)),
+	STM32_GATE(CK_KER_I3C4, "ck_ker_i3c4", "ck_flexgen_36", 0, GATE_I3C4, SEC_RIFSC(I3C4)),
+
+	/* I2S */
+	STM32_GATE(CK_BUS_IS2M, "ck_icn_p_is2m", "ck_icn_apb3", 0, GATE_IS2M, SEC_RIFRCC(IS2M)),
+
+	/* IWDG */
+	STM32_GATE(CK_BUS_IWDG1, "ck_icn_p_iwdg1", "ck_icn_apb3", 0, GATE_IWDG1, SEC_RIFSC(IWDG1)),
+	STM32_GATE(CK_BUS_IWDG2, "ck_icn_p_iwdg2", "ck_icn_apb3", 0, GATE_IWDG2, SEC_RIFSC(IWDG2)),
+	STM32_GATE(CK_BUS_IWDG3, "ck_icn_p_iwdg3", "ck_icn_apb3", 0, GATE_IWDG3, SEC_RIFSC(IWDG3)),
+	STM32_GATE(CK_BUS_IWDG4, "ck_icn_p_iwdg4", "ck_icn_apb3", 0, GATE_IWDG4, SEC_RIFSC(IWDG4)),
+	STM32_GATE(CK_BUS_IWDG5, "ck_icn_p_iwdg5", "ck_icn_ls_mcu", 0, GATE_IWDG5,
+		   SEC_RIFSC(IWDG5)),
+
+	/* LPTIM */
+	STM32_GATE(CK_KER_LPTIM1, "ck_ker_lptim1", "ck_flexgen_07", 0, GATE_LPTIM1,
+		   SEC_RIFSC(LPTIM1)),
+	STM32_GATE(CK_KER_LPTIM2, "ck_ker_lptim2", "ck_flexgen_07", 0, GATE_LPTIM2,
+		   SEC_RIFSC(LPTIM2)),
+	STM32_GATE(CK_KER_LPTIM3, "ck_ker_lptim3", "ck_flexgen_40", 0, GATE_LPTIM3,
+		   SEC_RIFSC(LPTIM3)),
+	STM32_GATE(CK_KER_LPTIM4, "ck_ker_lptim4", "ck_flexgen_41", 0, GATE_LPTIM4,
+		   SEC_RIFSC(LPTIM4)),
+	STM32_GATE(CK_KER_LPTIM5, "ck_ker_lptim5", "ck_flexgen_41", 0, GATE_LPTIM5,
+		   SEC_RIFSC(LPTIM5)),
+
+	/* LPUART */
+	STM32_GATE(CK_KER_LPUART1, "ck_ker_lpuart1", "ck_flexgen_39", 0, GATE_LPUART1,
+		   SEC_RIFSC(LPUART1)),
+
+	/* MCO1 & MCO2 */
+	STM32_COMPOSITE_NODIV(CK_MCO1, "ck_mco1", 0, SEC_RIFRCC(MCO1), GATE_MCO1, MUX_MCO1),
+	STM32_COMPOSITE_NODIV(CK_MCO2, "ck_mco2", 0, SEC_RIFRCC(MCO2), GATE_MCO2, MUX_MCO2),
+
+	/* MDF */
+	STM32_GATE(CK_KER_MDF1, "ck_ker_mdf1", "ck_flexgen_23", 0, GATE_MDF1, SEC_RIFSC(MDF1)),
+
+	/* OCTOSPI */
+	STM32_GATE(CK_BUS_OSPIIOM, "ck_icn_p_ospiiom", "ck_icn_ls_mcu", 0, GATE_OSPIIOM,
+		   SEC_RIFSC(OCTOSPIM)),
+
+	/* PCIE */
+	STM32_GATE(CK_BUS_PCIE, "ck_icn_p_pcie", "ck_icn_ls_mcu", 0, GATE_PCIE, SEC_RIFSC(PCIE)),
+
+	/* PKA */
+	STM32_GATE(CK_BUS_PKA, "ck_icn_p_pka", "ck_icn_ls_mcu", 0, GATE_PKA, SEC_RIFSC(PKA)),
+
+	/* RNG */
+	STM32_GATE(CK_BUS_RNG, "ck_icn_p_rng", "ck_icn_ls_mcu", CLK_IGNORE_UNUSED, GATE_RNG,
+		   SEC_RIFSC(RNG)),
+
+	/* SAES */
+	STM32_GATE(CK_BUS_SAES, "ck_icn_p_saes", "ck_icn_ls_mcu", 0, GATE_SAES, SEC_RIFSC(SAES)),
+
+	/* SAI [1..4] */
+	STM32_GATE(CK_BUS_SAI1, "ck_icn_p_sai1", "ck_icn_apb2", 0, GATE_SAI1, SEC_RIFSC(SAI1)),
+	STM32_GATE(CK_BUS_SAI2, "ck_icn_p_sai2", "ck_icn_apb2", 0, GATE_SAI2, SEC_RIFSC(SAI2)),
+	STM32_GATE(CK_BUS_SAI3, "ck_icn_p_sai3", "ck_icn_apb2", 0, GATE_SAI3, SEC_RIFSC(SAI3)),
+	STM32_GATE(CK_BUS_SAI4, "ck_icn_p_sai4", "ck_icn_apb2", 0, GATE_SAI4, SEC_RIFSC(SAI4)),
+	STM32_GATE(CK_KER_SAI1, "ck_ker_sai1", "ck_flexgen_23", 0, GATE_SAI1, SEC_RIFSC(SAI1)),
+	STM32_GATE(CK_KER_SAI2, "ck_ker_sai2", "ck_flexgen_24", 0, GATE_SAI2, SEC_RIFSC(SAI2)),
+	STM32_GATE(CK_KER_SAI3, "ck_ker_sai3", "ck_flexgen_25", 0, GATE_SAI3, SEC_RIFSC(SAI3)),
+	STM32_GATE(CK_KER_SAI4, "ck_ker_sai4", "ck_flexgen_25", 0, GATE_SAI4, SEC_RIFSC(SAI4)),
+
+	/* SDMMC */
+	STM32_GATE(CK_KER_SDMMC1, "ck_ker_sdmmc1", "ck_flexgen_51", 0, GATE_SDMMC1,
+		   SEC_RIFSC(SDMMC1)),
+	STM32_GATE(CK_KER_SDMMC2, "ck_ker_sdmmc2", "ck_flexgen_52", 0, GATE_SDMMC2,
+		   SEC_RIFSC(SDMMC2)),
+	STM32_GATE(CK_KER_SDMMC3, "ck_ker_sdmmc3", "ck_flexgen_53", 0, GATE_SDMMC3,
+		   SEC_RIFSC(SDMMC3)),
+
+	/* SERC */
+	STM32_GATE(CK_BUS_SERC, "ck_icn_p_serc", "ck_icn_apb3", 0, GATE_SERC, SEC_RIFSC(SERC)),
+
+	/* SPDIF */
+	STM32_GATE(CK_KER_SPDIFRX, "ck_ker_spdifrx", "ck_flexgen_11", 0, GATE_SPDIFRX,
+		   SEC_RIFSC(SPDIFRX)),
+
+	/* SPI */
+	STM32_GATE(CK_KER_SPI1, "ck_ker_spi1", "ck_flexgen_16", 0, GATE_SPI1, SEC_RIFSC(SPI1)),
+	STM32_GATE(CK_KER_SPI2, "ck_ker_spi2", "ck_flexgen_10", 0, GATE_SPI2, SEC_RIFSC(SPI2)),
+	STM32_GATE(CK_KER_SPI3, "ck_ker_spi3", "ck_flexgen_10", 0, GATE_SPI3, SEC_RIFSC(SPI3)),
+	STM32_GATE(CK_KER_SPI4, "ck_ker_spi4", "ck_flexgen_17", 0, GATE_SPI4, SEC_RIFSC(SPI4)),
+	STM32_GATE(CK_KER_SPI5, "ck_ker_spi5", "ck_flexgen_17", 0, GATE_SPI5, SEC_RIFSC(SPI5)),
+	STM32_GATE(CK_KER_SPI6, "ck_ker_spi6", "ck_flexgen_18", 0, GATE_SPI6, SEC_RIFSC(SPI6)),
+	STM32_GATE(CK_KER_SPI7, "ck_ker_spi7", "ck_flexgen_18", 0, GATE_SPI7, SEC_RIFSC(SPI7)),
+	STM32_GATE(CK_KER_SPI8, "ck_ker_spi8", "ck_flexgen_37", 0, GATE_SPI8, SEC_RIFSC(SPI8)),
+
+	/* STGEN */
+	STM32_GATE(CK_KER_STGEN, "ck_ker_stgen", "ck_flexgen_33", CLK_IGNORE_UNUSED, GATE_STGEN,
+		   SEC_RIFSC(STGEN)),
+
+	/* Timers */
+	STM32_GATE(CK_KER_TIM2, "ck_ker_tim2", "timg1_ck", 0, GATE_TIM2, SEC_RIFSC(TIM2)),
+	STM32_GATE(CK_KER_TIM3, "ck_ker_tim3", "timg1_ck", 0, GATE_TIM3, SEC_RIFSC(TIM3)),
+	STM32_GATE(CK_KER_TIM4, "ck_ker_tim4", "timg1_ck", 0, GATE_TIM4, SEC_RIFSC(TIM4)),
+	STM32_GATE(CK_KER_TIM5, "ck_ker_tim5", "timg1_ck", 0, GATE_TIM5, SEC_RIFSC(TIM5)),
+	STM32_GATE(CK_KER_TIM6, "ck_ker_tim6", "timg1_ck", 0, GATE_TIM6, SEC_RIFSC(TIM6)),
+	STM32_GATE(CK_KER_TIM7, "ck_ker_tim7", "timg1_ck", 0, GATE_TIM7, SEC_RIFSC(TIM7)),
+	STM32_GATE(CK_KER_TIM10, "ck_ker_tim10", "timg1_ck", 0, GATE_TIM10, SEC_RIFSC(TIM10)),
+	STM32_GATE(CK_KER_TIM11, "ck_ker_tim11", "timg1_ck", 0, GATE_TIM11, SEC_RIFSC(TIM11)),
+	STM32_GATE(CK_KER_TIM12, "ck_ker_tim12", "timg1_ck", 0, GATE_TIM12, SEC_RIFSC(TIM12)),
+	STM32_GATE(CK_KER_TIM13, "ck_ker_tim13", "timg1_ck", 0, GATE_TIM13, SEC_RIFSC(TIM13)),
+	STM32_GATE(CK_KER_TIM14, "ck_ker_tim14", "timg1_ck", 0, GATE_TIM14, SEC_RIFSC(TIM14)),
+
+	STM32_GATE(CK_KER_TIM1, "ck_ker_tim1", "timg2_ck", 0, GATE_TIM1, SEC_RIFSC(TIM1)),
+	STM32_GATE(CK_KER_TIM8, "ck_ker_tim8", "timg2_ck", 0, GATE_TIM8, SEC_RIFSC(TIM8)),
+	STM32_GATE(CK_KER_TIM15, "ck_ker_tim15", "timg2_ck", 0, GATE_TIM15, SEC_RIFSC(TIM15)),
+	STM32_GATE(CK_KER_TIM16, "ck_ker_tim16", "timg2_ck", 0, GATE_TIM16, SEC_RIFSC(TIM16)),
+	STM32_GATE(CK_KER_TIM17, "ck_ker_tim17", "timg2_ck", 0, GATE_TIM17, SEC_RIFSC(TIM17)),
+	STM32_GATE(CK_KER_TIM20, "ck_ker_tim20", "timg2_ck", 0, GATE_TIM20, SEC_RIFSC(TIM20)),
+
+	/* UART/USART */
+	STM32_GATE(CK_KER_USART2, "ck_ker_usart2", "ck_flexgen_08", 0, GATE_USART2,
+		   SEC_RIFSC(USART2)),
+	STM32_GATE(CK_KER_UART4, "ck_ker_uart4", "ck_flexgen_08", 0, GATE_UART4,
+		   SEC_RIFSC(UART4)),
+	STM32_GATE(CK_KER_USART3, "ck_ker_usart3", "ck_flexgen_09", 0, GATE_USART3,
+		   SEC_RIFSC(USART3)),
+	STM32_GATE(CK_KER_UART5, "ck_ker_uart5", "ck_flexgen_09", 0, GATE_UART5,
+		   SEC_RIFSC(UART5)),
+	STM32_GATE(CK_KER_USART1, "ck_ker_usart1", "ck_flexgen_19", 0, GATE_USART1,
+		   SEC_RIFSC(USART1)),
+	STM32_GATE(CK_KER_USART6, "ck_ker_usart6", "ck_flexgen_20", 0, GATE_USART6,
+		   SEC_RIFSC(USART6)),
+	STM32_GATE(CK_KER_UART7, "ck_ker_uart7", "ck_flexgen_21", 0, GATE_UART7,
+		   SEC_RIFSC(UART7)),
+	STM32_GATE(CK_KER_UART8, "ck_ker_uart8", "ck_flexgen_21", 0, GATE_UART8,
+		   SEC_RIFSC(UART8)),
+	STM32_GATE(CK_KER_UART9, "ck_ker_uart9", "ck_flexgen_22", 0, GATE_UART9,
+		   SEC_RIFSC(UART9)),
+
+	/* USB2PHY1 */
+	STM32_COMPOSITE_NODIV(CK_KER_USB2PHY1, "ck_ker_usb2phy1", 0, SEC_RIFSC(USBH),
+			      GATE_USB2PHY1, MUX_USB2PHY1),
+
+	/* USBH */
+	STM32_GATE(CK_BUS_USB2OHCI, "ck_icn_m_usb2ohci", "ck_icn_hsl", 0, GATE_USB2,
+		   SEC_RIFSC(USBH)),
+	STM32_GATE(CK_BUS_USB2EHCI, "ck_icn_m_usb2ehci", "ck_icn_hsl", 0, GATE_USB2,
+		   SEC_RIFSC(USBH)),
+
+	/* USB2PHY2 */
+	STM32_COMPOSITE_NODIV(CK_KER_USB2PHY2EN, "ck_ker_usb2phy2_en", 0, SEC_RIFSC(USBH),
+			      GATE_USB2PHY2, MUX_USB2PHY2),
+
+	/* USB3 PCIe COMBOPHY */
+	STM32_GATE(CK_BUS_USB3PCIEPHY, "ck_icn_p_usb3pciephy", "ck_icn_apb4", 0, GATE_USB3PCIEPHY,
+		   SEC_RIFSC(USB3DR)),
+
+	STM32_COMPOSITE_NODIV(CK_KER_USB3PCIEPHY, "ck_ker_usb3pciephy", 0, SEC_RIFSC(USB3DR),
+			      GATE_USB3PCIEPHY, MUX_USB3PCIEPHY),
+
+	/* USB3 DRD */
+	STM32_GATE(CK_BUS_USB3DR, "ck_icn_m_usb3dr", "ck_icn_hsl", 0, GATE_USB3DR,
+		   SEC_RIFSC(USB3DR)),
+	STM32_GATE(CK_KER_USB2PHY2, "ck_ker_usb2phy2", "ck_flexgen_58", 0, GATE_USB3DR,
+		   SEC_RIFSC(USBH)),
+
+	/* USBTC */
+	STM32_GATE(CK_BUS_USBTC, "ck_icn_p_usbtc", "ck_flexgen_35", 0, GATE_USBTC,
+		   SEC_RIFSC(USBH)),
+	STM32_GATE(CK_KER_USBTC, "ck_ker_usbtc", "ck_flexgen_35", 0, GATE_USBTC,
+		   SEC_RIFSC(USBH)),
+
+	/* VDEC / VENC */
+	STM32_GATE(CK_BUS_VDEC, "ck_icn_p_vdec", "ck_icn_apb4", 0, GATE_VDEC, SEC_RIFSC(VDEC)),
+	STM32_GATE(CK_BUS_VENC, "ck_icn_p_venc", "ck_icn_apb4", 0, GATE_VENC, SEC_RIFSC(VENC)),
+
+	/* VREF */
+	STM32_GATE(CK_BUS_VREF, "ck_icn_p_vref", "ck_icn_apb3", 0, RCC_VREFCFGR,
+		   SEC_RIFSC(VREFBUF)),
+
+	/* WWDG */
+	STM32_GATE(CK_BUS_WWDG1, "ck_icn_p_wwdg1", "ck_icn_apb3", 0, GATE_WWDG1,
+		   SEC_RIFSC(WWDG1)),
+	STM32_GATE(CK_BUS_WWDG2, "ck_icn_p_wwdg2", "ck_icn_ls_mcu", 0, GATE_WWDG2,
+		   SEC_RIFSC(WWDG2)),
+};
+
+static const struct stm32_clock_match_data stm32mp25_data = {
+	.tab_clocks	= stm32mp25_clock_cfg,
+	.num_clocks	= ARRAY_SIZE(stm32mp25_clock_cfg),
+	.clock_data = &(const struct clk_stm32_clock_data) {
+		.num_gates	= ARRAY_SIZE(stm32mp25_gates),
+		.gates		= stm32mp25_gates,
+		.muxes		= stm32mp25_muxes,
+	},
+	.check_security = stm32mp25_check_security,
+
+};
+
+static int stm32mp25_clk_probe(struct udevice *dev)
+{
+	fdt_addr_t base = dev_read_addr(dev->parent);
+	struct udevice *scmi;
+
+	if (base == FDT_ADDR_T_NONE)
+		return -EINVAL;
+
+	/* force SCMI probe to register all SCMI clocks */
+	uclass_get_device_by_driver(UCLASS_CLK, DM_DRIVER_GET(scmi_clock), &scmi);
+
+	stm32_rcc_init(dev, &stm32mp25_data);
+
+	return 0;
+}
+
+U_BOOT_DRIVER(stm32mp25_clock) = {
+	.name = "stm32mp25_clk",
+	.id = UCLASS_CLK,
+	.ops = &stm32_clk_ops,
+	.priv_auto = sizeof(struct stm32mp_rcc_priv),
+	.probe = stm32mp25_clk_probe,
+};
diff --git a/drivers/clk/stm32/stm32mp13_rcc.h b/drivers/clk/stm32/stm32mp13_rcc.h
new file mode 100644
index 0000000000..e7191b428a
--- /dev/null
+++ b/drivers/clk/stm32/stm32mp13_rcc.h
@@ -0,0 +1,288 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STM32MP13x CPU
+ */
+
+#ifndef STM32MP13_RCC_H
+#define STM32MP13_RCC_H
+
+/* RCC registers */
+#define RCC_SECCFGR			0x0
+#define RCC_MP_SREQSETR			0x100
+#define RCC_MP_SREQCLRR			0x104
+#define RCC_MP_APRSTCR			0x108
+#define RCC_MP_APRSTSR			0x10c
+#define RCC_PWRLPDLYCR			0x110
+#define RCC_MP_GRSTCSETR		0x114
+#define RCC_BR_RSTSCLRR			0x118
+#define RCC_MP_RSTSSETR			0x11c
+#define RCC_MP_RSTSCLRR			0x120
+#define RCC_MP_IWDGFZSETR		0x124
+#define RCC_MP_IWDGFZCLRR		0x128
+#define RCC_MP_CIER			0x200
+#define RCC_MP_CIFR			0x204
+#define RCC_BDCR			0x400
+#define RCC_RDLSICR			0x404
+#define RCC_OCENSETR			0x420
+#define RCC_OCENCLRR			0x424
+#define RCC_OCRDYR			0x428
+#define RCC_HSICFGR			0x440
+#define RCC_CSICFGR			0x444
+#define RCC_MCO1CFGR			0x460
+#define RCC_MCO2CFGR			0x464
+#define RCC_DBGCFGR			0x468
+#define RCC_RCK12SELR			0x480
+#define RCC_RCK3SELR			0x484
+#define RCC_RCK4SELR			0x488
+#define RCC_PLL1CR			0x4a0
+#define RCC_PLL1CFGR1			0x4a4
+#define RCC_PLL1CFGR2			0x4a8
+#define RCC_PLL1FRACR			0x4ac
+#define RCC_PLL1CSGR			0x4b0
+#define RCC_PLL2CR			0x4d0
+#define RCC_PLL2CFGR1			0x4d4
+#define RCC_PLL2CFGR2			0x4d8
+#define RCC_PLL2FRACR			0x4dc
+#define RCC_PLL2CSGR			0x4e0
+#define RCC_PLL3CR			0x500
+#define RCC_PLL3CFGR1			0x504
+#define RCC_PLL3CFGR2			0x508
+#define RCC_PLL3FRACR			0x50c
+#define RCC_PLL3CSGR			0x510
+#define RCC_PLL4CR			0x520
+#define RCC_PLL4CFGR1			0x524
+#define RCC_PLL4CFGR2			0x528
+#define RCC_PLL4FRACR			0x52c
+#define RCC_PLL4CSGR			0x530
+#define RCC_MPCKSELR			0x540
+#define RCC_ASSCKSELR			0x544
+#define RCC_MSSCKSELR			0x548
+#define RCC_CPERCKSELR			0x54c
+#define RCC_RTCDIVR			0x560
+#define RCC_MPCKDIVR			0x564
+#define RCC_AXIDIVR			0x568
+#define RCC_MLAHBDIVR			0x56c
+#define RCC_APB1DIVR			0x570
+#define RCC_APB2DIVR			0x574
+#define RCC_APB3DIVR			0x578
+#define RCC_APB4DIVR			0x57c
+#define RCC_APB5DIVR			0x580
+#define RCC_APB6DIVR			0x584
+#define RCC_TIMG1PRER			0x5a0
+#define RCC_TIMG2PRER			0x5a4
+#define RCC_TIMG3PRER			0x5a8
+#define RCC_DDRITFCR			0x5c0
+#define RCC_I2C12CKSELR			0x600
+#define RCC_I2C345CKSELR		0x604
+#define RCC_SPI2S1CKSELR		0x608
+#define RCC_SPI2S23CKSELR		0x60c
+#define RCC_SPI45CKSELR			0x610
+#define RCC_UART12CKSELR		0x614
+#define RCC_UART35CKSELR		0x618
+#define RCC_UART4CKSELR			0x61c
+#define RCC_UART6CKSELR			0x620
+#define RCC_UART78CKSELR		0x624
+#define RCC_LPTIM1CKSELR		0x628
+#define RCC_LPTIM23CKSELR		0x62c
+#define RCC_LPTIM45CKSELR		0x630
+#define RCC_SAI1CKSELR			0x634
+#define RCC_SAI2CKSELR			0x638
+#define RCC_FDCANCKSELR			0x63c
+#define RCC_SPDIFCKSELR			0x640
+#define RCC_ADC12CKSELR			0x644
+#define RCC_SDMMC12CKSELR		0x648
+#define RCC_ETH12CKSELR			0x64c
+#define RCC_USBCKSELR			0x650
+#define RCC_QSPICKSELR			0x654
+#define RCC_FMCCKSELR			0x658
+#define RCC_RNG1CKSELR			0x65c
+#define RCC_STGENCKSELR			0x660
+#define RCC_DCMIPPCKSELR		0x664
+#define RCC_SAESCKSELR			0x668
+#define RCC_APB1RSTSETR			0x6a0
+#define RCC_APB1RSTCLRR			0x6a4
+#define RCC_APB2RSTSETR			0x6a8
+#define RCC_APB2RSTCLRR			0x6ac
+#define RCC_APB3RSTSETR			0x6b0
+#define RCC_APB3RSTCLRR			0x6b4
+#define RCC_APB4RSTSETR			0x6b8
+#define RCC_APB4RSTCLRR			0x6bc
+#define RCC_APB5RSTSETR			0x6c0
+#define RCC_APB5RSTCLRR			0x6c4
+#define RCC_APB6RSTSETR			0x6c8
+#define RCC_APB6RSTCLRR			0x6cc
+#define RCC_AHB2RSTSETR			0x6d0
+#define RCC_AHB2RSTCLRR			0x6d4
+#define RCC_AHB4RSTSETR			0x6e0
+#define RCC_AHB4RSTCLRR			0x6e4
+#define RCC_AHB5RSTSETR			0x6e8
+#define RCC_AHB5RSTCLRR			0x6ec
+#define RCC_AHB6RSTSETR			0x6f0
+#define RCC_AHB6RSTCLRR			0x6f4
+#define RCC_MP_APB1ENSETR		0x700
+#define RCC_MP_APB1ENCLRR		0x704
+#define RCC_MP_APB2ENSETR		0x708
+#define RCC_MP_APB2ENCLRR		0x70c
+#define RCC_MP_APB3ENSETR		0x710
+#define RCC_MP_APB3ENCLRR		0x714
+#define RCC_MP_S_APB3ENSETR		0x718
+#define RCC_MP_S_APB3ENCLRR		0x71c
+#define RCC_MP_NS_APB3ENSETR		0x720
+#define RCC_MP_NS_APB3ENCLRR		0x724
+#define RCC_MP_APB4ENSETR		0x728
+#define RCC_MP_APB4ENCLRR		0x72c
+#define RCC_MP_S_APB4ENSETR		0x730
+#define RCC_MP_S_APB4ENCLRR		0x734
+#define RCC_MP_NS_APB4ENSETR		0x738
+#define RCC_MP_NS_APB4ENCLRR		0x73c
+#define RCC_MP_APB5ENSETR		0x740
+#define RCC_MP_APB5ENCLRR		0x744
+#define RCC_MP_APB6ENSETR		0x748
+#define RCC_MP_APB6ENCLRR		0x74c
+#define RCC_MP_AHB2ENSETR		0x750
+#define RCC_MP_AHB2ENCLRR		0x754
+#define RCC_MP_AHB4ENSETR		0x760
+#define RCC_MP_AHB4ENCLRR		0x764
+#define RCC_MP_S_AHB4ENSETR		0x768
+#define RCC_MP_S_AHB4ENCLRR		0x76c
+#define RCC_MP_NS_AHB4ENSETR		0x770
+#define RCC_MP_NS_AHB4ENCLRR		0x774
+#define RCC_MP_AHB5ENSETR		0x778
+#define RCC_MP_AHB5ENCLRR		0x77c
+#define RCC_MP_AHB6ENSETR		0x780
+#define RCC_MP_AHB6ENCLRR		0x784
+#define RCC_MP_S_AHB6ENSETR		0x788
+#define RCC_MP_S_AHB6ENCLRR		0x78c
+#define RCC_MP_NS_AHB6ENSETR		0x790
+#define RCC_MP_NS_AHB6ENCLRR		0x794
+#define RCC_MP_APB1LPENSETR		0x800
+#define RCC_MP_APB1LPENCLRR		0x804
+#define RCC_MP_APB2LPENSETR		0x808
+#define RCC_MP_APB2LPENCLRR		0x80c
+#define RCC_MP_APB3LPENSETR		0x810
+#define RCC_MP_APB3LPENCLRR		0x814
+#define RCC_MP_S_APB3LPENSETR		0x818
+#define RCC_MP_S_APB3LPENCLRR		0x81c
+#define RCC_MP_NS_APB3LPENSETR		0x820
+#define RCC_MP_NS_APB3LPENCLRR		0x824
+#define RCC_MP_APB4LPENSETR		0x828
+#define RCC_MP_APB4LPENCLRR		0x82c
+#define RCC_MP_S_APB4LPENSETR		0x830
+#define RCC_MP_S_APB4LPENCLRR		0x834
+#define RCC_MP_NS_APB4LPENSETR		0x838
+#define RCC_MP_NS_APB4LPENCLRR		0x83c
+#define RCC_MP_APB5LPENSETR		0x840
+#define RCC_MP_APB5LPENCLRR		0x844
+#define RCC_MP_APB6LPENSETR		0x848
+#define RCC_MP_APB6LPENCLRR		0x84c
+#define RCC_MP_AHB2LPENSETR		0x850
+#define RCC_MP_AHB2LPENCLRR		0x854
+#define RCC_MP_AHB4LPENSETR		0x858
+#define RCC_MP_AHB4LPENCLRR		0x85c
+#define RCC_MP_S_AHB4LPENSETR		0x868
+#define RCC_MP_S_AHB4LPENCLRR		0x86c
+#define RCC_MP_NS_AHB4LPENSETR		0x870
+#define RCC_MP_NS_AHB4LPENCLRR		0x874
+#define RCC_MP_AHB5LPENSETR		0x878
+#define RCC_MP_AHB5LPENCLRR		0x87c
+#define RCC_MP_AHB6LPENSETR		0x880
+#define RCC_MP_AHB6LPENCLRR		0x884
+#define RCC_MP_S_AHB6LPENSETR		0x888
+#define RCC_MP_S_AHB6LPENCLRR		0x88c
+#define RCC_MP_NS_AHB6LPENSETR		0x890
+#define RCC_MP_NS_AHB6LPENCLRR		0x894
+#define RCC_MP_S_AXIMLPENSETR		0x898
+#define RCC_MP_S_AXIMLPENCLRR		0x89c
+#define RCC_MP_NS_AXIMLPENSETR		0x8a0
+#define RCC_MP_NS_AXIMLPENCLRR		0x8a4
+#define RCC_MP_MLAHBLPENSETR		0x8a8
+#define RCC_MP_MLAHBLPENCLRR		0x8ac
+#define RCC_APB3SECSR			0x8c0
+#define RCC_APB4SECSR			0x8c4
+#define RCC_APB5SECSR			0x8c8
+#define RCC_APB6SECSR			0x8cc
+#define RCC_AHB2SECSR			0x8d0
+#define RCC_AHB4SECSR			0x8d4
+#define RCC_AHB5SECSR			0x8d8
+#define RCC_AHB6SECSR			0x8dc
+#define RCC_VERR			0xff4
+#define RCC_IDR				0xff8
+#define RCC_SIDR			0xffc
+
+/* RCC_SECCFGR register fields */
+#define RCC_SECCFGR_MCO1SECF		22
+#define RCC_SECCFGR_MCO2SECF		23
+
+/* RCC_APB3SECSR register fields */
+#define RCC_APB3SECSR_LPTIM2SECF	0
+#define RCC_APB3SECSR_LPTIM3SECF	1
+#define RCC_APB3SECSR_VREFSECF		13
+
+/* RCC_APB4SECSR register fields */
+#define RCC_APB4SECSR_DCMIPPSECF	1
+#define RCC_APB4SECSR_USBPHYSECF	16
+
+/* RCC_APB5SECSR register fields */
+#define RCC_APB5SECSR_RTCSECF		8
+#define RCC_APB5SECSR_TZCSECF		11
+#define RCC_APB5SECSR_ETZPCSECF		13
+#define RCC_APB5SECSR_IWDG1SECF		15
+#define RCC_APB5SECSR_BSECSECF		16
+#define RCC_APB5SECSR_STGENCSECF	20
+#define RCC_APB5SECSR_STGENROSECF	21
+
+/* RCC_APB6SECSR register fields */
+#define RCC_APB6SECSR_USART1SECF        0
+#define RCC_APB6SECSR_USART2SECF	1
+#define RCC_APB6SECSR_SPI4SECF		2
+#define RCC_APB6SECSR_SPI5SECF		3
+#define RCC_APB6SECSR_I2C3SECF		4
+#define RCC_APB6SECSR_I2C4SECF		5
+#define RCC_APB6SECSR_I2C5SECF		6
+#define RCC_APB6SECSR_TIM12SECF		7
+#define RCC_APB6SECSR_TIM13SECF		8
+#define RCC_APB6SECSR_TIM14SECF		9
+#define RCC_APB6SECSR_TIM15SECF		10
+#define RCC_APB6SECSR_TIM16SECF		11
+#define RCC_APB6SECSR_TIM17SECF		12
+
+/* RCC_AHB2SECSR register fields */
+#define RCC_AHB2SECSR_DMA3SECF		3
+#define RCC_AHB2SECSR_DMAMUX2SECF	4
+#define RCC_AHB2SECSR_ADC1SECF		5
+#define RCC_AHB2SECSR_ADC2SECF		6
+#define RCC_AHB2SECSR_USBOSECF		8
+
+/* RCC_AHB4SECSR register fields */
+#define RCC_AHB4SECSR_TSCSECF		15
+
+/* RCC_AHB5SECSR register fields */
+#define RCC_AHB5SECSR_PKASECF		2
+#define RCC_AHB5SECSR_SAESSECF		3
+#define RCC_AHB5SECSR_CRYP1SECF		4
+#define RCC_AHB5SECSR_HASH1SECF		5
+#define RCC_AHB5SECSR_RNG1SECF		6
+#define RCC_AHB5SECSR_BKPSRAMSECF	8
+
+/* RCC_AHB6SECSR register fields */
+#define RCC_AHB6SECSR_MCESECF		1
+#define RCC_AHB6SECSR_FMCSECF		12
+#define RCC_AHB6SECSR_QSPISECF		14
+#define RCC_AHB6SECSR_SDMMC1SECF	16
+#define RCC_AHB6SECSR_SDMMC2SECF	17
+
+#define RCC_AHB6SECSR_ETH1CKSECF	7
+#define RCC_AHB6SECSR_ETH1TXSECF	8
+#define RCC_AHB6SECSR_ETH1RXSECF	9
+#define RCC_AHB6SECSR_ETH1MACSECF	10
+#define RCC_AHB6SECSR_ETH1STPSECF	11
+
+#define RCC_AHB6SECSR_ETH2CKSECF	27
+#define RCC_AHB6SECSR_ETH2TXSECF	28
+#define RCC_AHB6SECSR_ETH2RXSECF	29
+#define RCC_AHB6SECSR_ETH2MACSECF	30
+#define RCC_AHB6SECSR_ETH2STPSECF	31
+
+#endif /* STM32MP13_RCC_H */
diff --git a/drivers/clk/stm32/stm32mp25_rcc.h b/drivers/clk/stm32/stm32mp25_rcc.h
new file mode 100644
index 0000000000..93f5c8347f
--- /dev/null
+++ b/drivers/clk/stm32/stm32mp25_rcc.h
@@ -0,0 +1,712 @@
+/* SPDX-License-Identifier: GPL-2.0 or BSD-3-Clause */
+/*
+ * Copyright (C STMicroelectronics 2019 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@st.com> for STMicroelectronics.
+ */
+
+#ifndef STM32MP2_RCC_H
+#define STM32MP2_RCC_H
+
+#define RCC_SECCFGR0				0x0
+#define RCC_SECCFGR1				0x4
+#define RCC_SECCFGR2				0x8
+#define RCC_SECCFGR3				0xC
+#define RCC_PRIVCFGR0				0x10
+#define RCC_PRIVCFGR1				0x14
+#define RCC_PRIVCFGR2				0x18
+#define RCC_PRIVCFGR3				0x1C
+#define RCC_RCFGLOCKR0				0x20
+#define RCC_RCFGLOCKR1				0x24
+#define RCC_RCFGLOCKR2				0x28
+#define RCC_RCFGLOCKR3				0x2C
+#define RCC_R0CIDCFGR				0x30
+#define RCC_R0SEMCR				0x34
+#define RCC_R1CIDCFGR				0x38
+#define RCC_R1SEMCR				0x3C
+#define RCC_R2CIDCFGR				0x40
+#define RCC_R2SEMCR				0x44
+#define RCC_R3CIDCFGR				0x48
+#define RCC_R3SEMCR				0x4C
+#define RCC_R4CIDCFGR				0x50
+#define RCC_R4SEMCR				0x54
+#define RCC_R5CIDCFGR				0x58
+#define RCC_R5SEMCR				0x5C
+#define RCC_R6CIDCFGR				0x60
+#define RCC_R6SEMCR				0x64
+#define RCC_R7CIDCFGR				0x68
+#define RCC_R7SEMCR				0x6C
+#define RCC_R8CIDCFGR				0x70
+#define RCC_R8SEMCR				0x74
+#define RCC_R9CIDCFGR				0x78
+#define RCC_R9SEMCR				0x7C
+#define RCC_R10CIDCFGR				0x80
+#define RCC_R10SEMCR				0x84
+#define RCC_R11CIDCFGR				0x88
+#define RCC_R11SEMCR				0x8C
+#define RCC_R12CIDCFGR				0x90
+#define RCC_R12SEMCR				0x94
+#define RCC_R13CIDCFGR				0x98
+#define RCC_R13SEMCR				0x9C
+#define RCC_R14CIDCFGR				0xA0
+#define RCC_R14SEMCR				0xA4
+#define RCC_R15CIDCFGR				0xA8
+#define RCC_R15SEMCR				0xAC
+#define RCC_R16CIDCFGR				0xB0
+#define RCC_R16SEMCR				0xB4
+#define RCC_R17CIDCFGR				0xB8
+#define RCC_R17SEMCR				0xBC
+#define RCC_R18CIDCFGR				0xC0
+#define RCC_R18SEMCR				0xC4
+#define RCC_R19CIDCFGR				0xC8
+#define RCC_R19SEMCR				0xCC
+#define RCC_R20CIDCFGR				0xD0
+#define RCC_R20SEMCR				0xD4
+#define RCC_R21CIDCFGR				0xD8
+#define RCC_R21SEMCR				0xDC
+#define RCC_R22CIDCFGR				0xE0
+#define RCC_R22SEMCR				0xE4
+#define RCC_R23CIDCFGR				0xE8
+#define RCC_R23SEMCR				0xEC
+#define RCC_R24CIDCFGR				0xF0
+#define RCC_R24SEMCR				0xF4
+#define RCC_R25CIDCFGR				0xF8
+#define RCC_R25SEMCR				0xFC
+#define RCC_R26CIDCFGR				0x100
+#define RCC_R26SEMCR				0x104
+#define RCC_R27CIDCFGR				0x108
+#define RCC_R27SEMCR				0x10C
+#define RCC_R28CIDCFGR				0x110
+#define RCC_R28SEMCR				0x114
+#define RCC_R29CIDCFGR				0x118
+#define RCC_R29SEMCR				0x11C
+#define RCC_R30CIDCFGR				0x120
+#define RCC_R30SEMCR				0x124
+#define RCC_R31CIDCFGR				0x128
+#define RCC_R31SEMCR				0x12C
+#define RCC_R32CIDCFGR				0x130
+#define RCC_R32SEMCR				0x134
+#define RCC_R33CIDCFGR				0x138
+#define RCC_R33SEMCR				0x13C
+#define RCC_R34CIDCFGR				0x140
+#define RCC_R34SEMCR				0x144
+#define RCC_R35CIDCFGR				0x148
+#define RCC_R35SEMCR				0x14C
+#define RCC_R36CIDCFGR				0x150
+#define RCC_R36SEMCR				0x154
+#define RCC_R37CIDCFGR				0x158
+#define RCC_R37SEMCR				0x15C
+#define RCC_R38CIDCFGR				0x160
+#define RCC_R38SEMCR				0x164
+#define RCC_R39CIDCFGR				0x168
+#define RCC_R39SEMCR				0x16C
+#define RCC_R40CIDCFGR				0x170
+#define RCC_R40SEMCR				0x174
+#define RCC_R41CIDCFGR				0x178
+#define RCC_R41SEMCR				0x17C
+#define RCC_R42CIDCFGR				0x180
+#define RCC_R42SEMCR				0x184
+#define RCC_R43CIDCFGR				0x188
+#define RCC_R43SEMCR				0x18C
+#define RCC_R44CIDCFGR				0x190
+#define RCC_R44SEMCR				0x194
+#define RCC_R45CIDCFGR				0x198
+#define RCC_R45SEMCR				0x19C
+#define RCC_R46CIDCFGR				0x1A0
+#define RCC_R46SEMCR				0x1A4
+#define RCC_R47CIDCFGR				0x1A8
+#define RCC_R47SEMCR				0x1AC
+#define RCC_R48CIDCFGR				0x1B0
+#define RCC_R48SEMCR				0x1B4
+#define RCC_R49CIDCFGR				0x1B8
+#define RCC_R49SEMCR				0x1BC
+#define RCC_R50CIDCFGR				0x1C0
+#define RCC_R50SEMCR				0x1C4
+#define RCC_R51CIDCFGR				0x1C8
+#define RCC_R51SEMCR				0x1CC
+#define RCC_R52CIDCFGR				0x1D0
+#define RCC_R52SEMCR				0x1D4
+#define RCC_R53CIDCFGR				0x1D8
+#define RCC_R53SEMCR				0x1DC
+#define RCC_R54CIDCFGR				0x1E0
+#define RCC_R54SEMCR				0x1E4
+#define RCC_R55CIDCFGR				0x1E8
+#define RCC_R55SEMCR				0x1EC
+#define RCC_R56CIDCFGR				0x1F0
+#define RCC_R56SEMCR				0x1F4
+#define RCC_R57CIDCFGR				0x1F8
+#define RCC_R57SEMCR				0x1FC
+#define RCC_R58CIDCFGR				0x200
+#define RCC_R58SEMCR				0x204
+#define RCC_R59CIDCFGR				0x208
+#define RCC_R59SEMCR				0x20C
+#define RCC_R60CIDCFGR				0x210
+#define RCC_R60SEMCR				0x214
+#define RCC_R61CIDCFGR				0x218
+#define RCC_R61SEMCR				0x21C
+#define RCC_R62CIDCFGR				0x220
+#define RCC_R62SEMCR				0x224
+#define RCC_R63CIDCFGR				0x228
+#define RCC_R63SEMCR				0x22C
+#define RCC_R64CIDCFGR				0x230
+#define RCC_R64SEMCR				0x234
+#define RCC_R65CIDCFGR				0x238
+#define RCC_R65SEMCR				0x23C
+#define RCC_R66CIDCFGR				0x240
+#define RCC_R66SEMCR				0x244
+#define RCC_R67CIDCFGR				0x248
+#define RCC_R67SEMCR				0x24C
+#define RCC_R68CIDCFGR				0x250
+#define RCC_R68SEMCR				0x254
+#define RCC_R69CIDCFGR				0x258
+#define RCC_R69SEMCR				0x25C
+#define RCC_R70CIDCFGR				0x260
+#define RCC_R70SEMCR				0x264
+#define RCC_R71CIDCFGR				0x268
+#define RCC_R71SEMCR				0x26C
+#define RCC_R72CIDCFGR				0x270
+#define RCC_R72SEMCR				0x274
+#define RCC_R73CIDCFGR				0x278
+#define RCC_R73SEMCR				0x27C
+#define RCC_R74CIDCFGR				0x280
+#define RCC_R74SEMCR				0x284
+#define RCC_R75CIDCFGR				0x288
+#define RCC_R75SEMCR				0x28C
+#define RCC_R76CIDCFGR				0x290
+#define RCC_R76SEMCR				0x294
+#define RCC_R77CIDCFGR				0x298
+#define RCC_R77SEMCR				0x29C
+#define RCC_R78CIDCFGR				0x2A0
+#define RCC_R78SEMCR				0x2A4
+#define RCC_R79CIDCFGR				0x2A8
+#define RCC_R79SEMCR				0x2AC
+#define RCC_R80CIDCFGR				0x2B0
+#define RCC_R80SEMCR				0x2B4
+#define RCC_R81CIDCFGR				0x2B8
+#define RCC_R81SEMCR				0x2BC
+#define RCC_R82CIDCFGR				0x2C0
+#define RCC_R82SEMCR				0x2C4
+#define RCC_R83CIDCFGR				0x2C8
+#define RCC_R83SEMCR				0x2CC
+#define RCC_R84CIDCFGR				0x2D0
+#define RCC_R84SEMCR				0x2D4
+#define RCC_R85CIDCFGR				0x2D8
+#define RCC_R85SEMCR				0x2DC
+#define RCC_R86CIDCFGR				0x2E0
+#define RCC_R86SEMCR				0x2E4
+#define RCC_R87CIDCFGR				0x2E8
+#define RCC_R87SEMCR				0x2EC
+#define RCC_R88CIDCFGR				0x2F0
+#define RCC_R88SEMCR				0x2F4
+#define RCC_R89CIDCFGR				0x2F8
+#define RCC_R89SEMCR				0x2FC
+#define RCC_R90CIDCFGR				0x300
+#define RCC_R90SEMCR				0x304
+#define RCC_R91CIDCFGR				0x308
+#define RCC_R91SEMCR				0x30C
+#define RCC_R92CIDCFGR				0x310
+#define RCC_R92SEMCR				0x314
+#define RCC_R93CIDCFGR				0x318
+#define RCC_R93SEMCR				0x31C
+#define RCC_R94CIDCFGR				0x320
+#define RCC_R94SEMCR				0x324
+#define RCC_R95CIDCFGR				0x328
+#define RCC_R95SEMCR				0x32C
+#define RCC_R96CIDCFGR				0x330
+#define RCC_R96SEMCR				0x334
+#define RCC_R97CIDCFGR				0x338
+#define RCC_R97SEMCR				0x33C
+#define RCC_R98CIDCFGR				0x340
+#define RCC_R98SEMCR				0x344
+#define RCC_R99CIDCFGR				0x348
+#define RCC_R99SEMCR				0x34C
+#define RCC_R100CIDCFGR				0x350
+#define RCC_R100SEMCR				0x354
+#define RCC_R101CIDCFGR				0x358
+#define RCC_R101SEMCR				0x35C
+#define RCC_R102CIDCFGR				0x360
+#define RCC_R102SEMCR				0x364
+#define RCC_R103CIDCFGR				0x368
+#define RCC_R103SEMCR				0x36C
+#define RCC_R104CIDCFGR				0x370
+#define RCC_R104SEMCR				0x374
+#define RCC_R105CIDCFGR				0x378
+#define RCC_R105SEMCR				0x37C
+#define RCC_R106CIDCFGR				0x380
+#define RCC_R106SEMCR				0x384
+#define RCC_R107CIDCFGR				0x388
+#define RCC_R107SEMCR				0x38C
+#define RCC_R108CIDCFGR				0x390
+#define RCC_R108SEMCR				0x394
+#define RCC_R109CIDCFGR				0x398
+#define RCC_R109SEMCR				0x39C
+#define RCC_R110CIDCFGR				0x3A0
+#define RCC_R110SEMCR				0x3A4
+#define RCC_R111CIDCFGR				0x3A8
+#define RCC_R111SEMCR				0x3AC
+#define RCC_R112CIDCFGR				0x3B0
+#define RCC_R112SEMCR				0x3B4
+#define RCC_R113CIDCFGR				0x3B8
+#define RCC_R113SEMCR				0x3BC
+#define RCC_GRSTCSETR				0x400
+#define RCC_C1RSTCSETR				0x404
+#define RCC_C1P1RSTCSETR			0x408
+#define RCC_C2RSTCSETR				0x40C
+#define RCC_HWRSTSCLRR				0x410
+#define RCC_C1HWRSTSCLRR			0x414
+#define RCC_C2HWRSTSCLRR			0x418
+#define RCC_C1BOOTRSTSSETR			0x41C
+#define RCC_C1BOOTRSTSCLRR			0x420
+#define RCC_C2BOOTRSTSSETR			0x424
+#define RCC_C2BOOTRSTSCLRR			0x428
+#define RCC_C1SREQSETR				0x42C
+#define RCC_C1SREQCLRR				0x430
+#define RCC_CPUBOOTCR				0x434
+#define RCC_STBYBOOTCR				0x438
+#define RCC_LEGBOOTCR				0x43C
+#define RCC_BDCR				0x440
+#define RCC_D3DCR				0x444
+#define RCC_D3DSR				0x448
+#define RCC_RDCR				0x44C
+#define RCC_C1MSRDCR				0x450
+#define RCC_PWRLPDLYCR				0x454
+#define RCC_C1CIESETR				0x458
+#define RCC_C1CIFCLRR				0x45C
+#define RCC_C2CIESETR				0x460
+#define RCC_C2CIFCLRR				0x464
+#define RCC_IWDGC1FZSETR			0x468
+#define RCC_IWDGC1FZCLRR			0x46C
+#define RCC_IWDGC1CFGSETR			0x470
+#define RCC_IWDGC1CFGCLRR			0x474
+#define RCC_IWDGC2FZSETR			0x478
+#define RCC_IWDGC2FZCLRR			0x47C
+#define RCC_IWDGC2CFGSETR			0x480
+#define RCC_IWDGC2CFGCLRR			0x484
+#define RCC_IWDGC3CFGSETR			0x488
+#define RCC_IWDGC3CFGCLRR			0x48C
+#define RCC_C3CFGR				0x490
+#define RCC_MCO1CFGR				0x494
+#define RCC_MCO2CFGR				0x498
+#define RCC_OCENSETR				0x49C
+#define RCC_OCENCLRR				0x4A0
+#define RCC_OCRDYR				0x4A4
+#define RCC_HSICFGR				0x4A8
+#define RCC_MSICFGR				0x4AC
+#define RCC_RTCDIVR				0x4B0
+#define RCC_APB1DIVR				0x4B4
+#define RCC_APB2DIVR				0x4B8
+#define RCC_APB3DIVR				0x4BC
+#define RCC_APB4DIVR				0x4C0
+#define RCC_APBDBGDIVR				0x4C4
+#define RCC_TIMG1PRER				0x4C8
+#define RCC_TIMG2PRER				0x4CC
+#define RCC_LSMCUDIVR				0x4D0
+#define RCC_DDRCPCFGR				0x4D4
+#define RCC_DDRCAPBCFGR				0x4D8
+#define RCC_DDRPHYCAPBCFGR			0x4DC
+#define RCC_DDRPHYCCFGR				0x4E0
+#define RCC_DDRCFGR				0x4E4
+#define RCC_DDRITFCFGR				0x4E8
+#define RCC_SYSRAMCFGR				0x4F0
+#define RCC_VDERAMCFGR				0x4F4
+#define RCC_SRAM1CFGR				0x4F8
+#define RCC_SRAM2CFGR				0x4FC
+#define RCC_RETRAMCFGR				0x500
+#define RCC_BKPSRAMCFGR				0x504
+#define RCC_LPSRAM1CFGR				0x508
+#define RCC_LPSRAM2CFGR				0x50C
+#define RCC_LPSRAM3CFGR				0x510
+#define RCC_OSPI1CFGR				0x514
+#define RCC_OSPI2CFGR				0x518
+#define RCC_FMCCFGR				0x51C
+#define RCC_DBGCFGR				0x520
+#define RCC_STM500CFGR				0x524
+#define RCC_ETRCFGR				0x528
+#define RCC_GPIOACFGR				0x52C
+#define RCC_GPIOBCFGR				0x530
+#define RCC_GPIOCCFGR				0x534
+#define RCC_GPIODCFGR				0x538
+#define RCC_GPIOECFGR				0x53C
+#define RCC_GPIOFCFGR				0x540
+#define RCC_GPIOGCFGR				0x544
+#define RCC_GPIOHCFGR				0x548
+#define RCC_GPIOICFGR				0x54C
+#define RCC_GPIOJCFGR				0x550
+#define RCC_GPIOKCFGR				0x554
+#define RCC_GPIOZCFGR				0x558
+#define RCC_HPDMA1CFGR				0x55C
+#define RCC_HPDMA2CFGR				0x560
+#define RCC_HPDMA3CFGR				0x564
+#define RCC_LPDMACFGR				0x568
+#define RCC_HSEMCFGR				0x56C
+#define RCC_IPCC1CFGR				0x570
+#define RCC_IPCC2CFGR				0x574
+#define RCC_RTCCFGR				0x578
+#define RCC_SYSCPU1CFGR				0x580
+#define RCC_BSECCFGR				0x584
+#define RCC_IS2MCFGR				0x58C
+#define RCC_PLL2CFGR1				0x590
+#define RCC_PLL2CFGR2				0x594
+#define RCC_PLL2CFGR3				0x598
+#define RCC_PLL2CFGR4				0x59C
+#define RCC_PLL2CFGR5				0x5A0
+#define RCC_PLL2CFGR6				0x5A8
+#define RCC_PLL2CFGR7				0x5AC
+#define RCC_PLL3CFGR1				0x5B8
+#define RCC_PLL3CFGR2				0x5BC
+#define RCC_PLL3CFGR3				0x5C0
+#define RCC_PLL3CFGR4				0x5C4
+#define RCC_PLL3CFGR5				0x5C8
+#define RCC_PLL3CFGR6				0x5D0
+#define RCC_PLL3CFGR7				0x5D4
+#define RCC_HSIFMONCR				0x5E0
+#define RCC_HSIFVALR				0x5E4
+#define RCC_TIM1CFGR				0x700
+#define RCC_TIM2CFGR				0x704
+#define RCC_TIM3CFGR				0x708
+#define RCC_TIM4CFGR				0x70C
+#define RCC_TIM5CFGR				0x710
+#define RCC_TIM6CFGR				0x714
+#define RCC_TIM7CFGR				0x718
+#define RCC_TIM8CFGR				0x71C
+#define RCC_TIM10CFGR				0x720
+#define RCC_TIM11CFGR				0x724
+#define RCC_TIM12CFGR				0x728
+#define RCC_TIM13CFGR				0x72C
+#define RCC_TIM14CFGR				0x730
+#define RCC_TIM15CFGR				0x734
+#define RCC_TIM16CFGR				0x738
+#define RCC_TIM17CFGR				0x73C
+#define RCC_TIM20CFGR				0x740
+#define RCC_LPTIM1CFGR				0x744
+#define RCC_LPTIM2CFGR				0x748
+#define RCC_LPTIM3CFGR				0x74C
+#define RCC_LPTIM4CFGR				0x750
+#define RCC_LPTIM5CFGR				0x754
+#define RCC_SPI1CFGR				0x758
+#define RCC_SPI2CFGR				0x75C
+#define RCC_SPI3CFGR				0x760
+#define RCC_SPI4CFGR				0x764
+#define RCC_SPI5CFGR				0x768
+#define RCC_SPI6CFGR				0x76C
+#define RCC_SPI7CFGR				0x770
+#define RCC_SPI8CFGR				0x774
+#define RCC_SPDIFRXCFGR				0x778
+#define RCC_USART1CFGR				0x77C
+#define RCC_USART2CFGR				0x780
+#define RCC_USART3CFGR				0x784
+#define RCC_UART4CFGR				0x788
+#define RCC_UART5CFGR				0x78C
+#define RCC_USART6CFGR				0x790
+#define RCC_UART7CFGR				0x794
+#define RCC_UART8CFGR				0x798
+#define RCC_UART9CFGR				0x79C
+#define RCC_LPUART1CFGR				0x7A0
+#define RCC_I2C1CFGR				0x7A4
+#define RCC_I2C2CFGR				0x7A8
+#define RCC_I2C3CFGR				0x7AC
+#define RCC_I2C4CFGR				0x7B0
+#define RCC_I2C5CFGR				0x7B4
+#define RCC_I2C6CFGR				0x7B8
+#define RCC_I2C7CFGR				0x7BC
+#define RCC_I2C8CFGR				0x7C0
+#define RCC_SAI1CFGR				0x7C4
+#define RCC_SAI2CFGR				0x7C8
+#define RCC_SAI3CFGR				0x7CC
+#define RCC_SAI4CFGR				0x7D0
+#define RCC_MDF1CFGR				0x7D8
+#define RCC_ADF1CFGR				0x7DC
+#define RCC_FDCANCFGR				0x7E0
+#define RCC_HDPCFGR				0x7E4
+#define RCC_ADC12CFGR				0x7E8
+#define RCC_ADC3CFGR				0x7EC
+#define RCC_ETH1CFGR				0x7F0
+#define RCC_ETH2CFGR				0x7F4
+#define RCC_USB2CFGR				0x7FC
+#define RCC_USB2PHY1CFGR			0x800
+#define RCC_USB2PHY2CFGR			0x804
+#define RCC_USB3DRCFGR				0x808
+#define RCC_USB3PCIEPHYCFGR			0x80C
+#define RCC_PCIECFGR				0x810
+#define RCC_USBTCCFGR				0x814
+#define RCC_ETHSWCFGR				0x818
+#define RCC_ETHSWACMCFGR			0x81C
+#define RCC_ETHSWACMMSGCFGR			0x820
+#define RCC_STGENCFGR				0x824
+#define RCC_SDMMC1CFGR				0x830
+#define RCC_SDMMC2CFGR				0x834
+#define RCC_SDMMC3CFGR				0x838
+#define RCC_GPUCFGR				0x83C
+#define RCC_LTDCCFGR				0x840
+#define RCC_DSICFGR				0x844
+#define RCC_LVDSCFGR				0x850
+#define RCC_CSICFGR				0x858
+#define RCC_DCMIPPCFGR				0x85C
+#define RCC_CCICFGR				0x860
+#define RCC_VDECCFGR				0x864
+#define RCC_VENCCFGR				0x868
+#define RCC_RNGCFGR				0x870
+#define RCC_PKACFGR				0x874
+#define RCC_SAESCFGR				0x878
+#define RCC_HASHCFGR				0x87C
+#define RCC_CRYP1CFGR				0x880
+#define RCC_CRYP2CFGR				0x884
+#define RCC_IWDG1CFGR				0x888
+#define RCC_IWDG2CFGR				0x88C
+#define RCC_IWDG3CFGR				0x890
+#define RCC_IWDG4CFGR				0x894
+#define RCC_IWDG5CFGR				0x898
+#define RCC_WWDG1CFGR				0x89C
+#define RCC_WWDG2CFGR				0x8A0
+#define RCC_VREFCFGR				0x8A8
+#define RCC_DTSCFGR				0x8AC
+#define RCC_CRCCFGR				0x8B4
+#define RCC_SERCCFGR				0x8B8
+#define RCC_OSPIIOMCFGR				0x8BC
+#define RCC_GICV2MCFGR				0x8C0
+#define RCC_I3C1CFGR				0x8C8
+#define RCC_I3C2CFGR				0x8CC
+#define RCC_I3C3CFGR				0x8D0
+#define RCC_I3C4CFGR				0x8D4
+#define RCC_MUXSELCFGR				0x1000
+#define RCC_XBAR0CFGR				0x1018
+#define RCC_XBAR1CFGR				0x101C
+#define RCC_XBAR2CFGR				0x1020
+#define RCC_XBAR3CFGR				0x1024
+#define RCC_XBAR4CFGR				0x1028
+#define RCC_XBAR5CFGR				0x102C
+#define RCC_XBAR6CFGR				0x1030
+#define RCC_XBAR7CFGR				0x1034
+#define RCC_XBAR8CFGR				0x1038
+#define RCC_XBAR9CFGR				0x103C
+#define RCC_XBAR10CFGR				0x1040
+#define RCC_XBAR11CFGR				0x1044
+#define RCC_XBAR12CFGR				0x1048
+#define RCC_XBAR13CFGR				0x104C
+#define RCC_XBAR14CFGR				0x1050
+#define RCC_XBAR15CFGR				0x1054
+#define RCC_XBAR16CFGR				0x1058
+#define RCC_XBAR17CFGR				0x105C
+#define RCC_XBAR18CFGR				0x1060
+#define RCC_XBAR19CFGR				0x1064
+#define RCC_XBAR20CFGR				0x1068
+#define RCC_XBAR21CFGR				0x106C
+#define RCC_XBAR22CFGR				0x1070
+#define RCC_XBAR23CFGR				0x1074
+#define RCC_XBAR24CFGR				0x1078
+#define RCC_XBAR25CFGR				0x107C
+#define RCC_XBAR26CFGR				0x1080
+#define RCC_XBAR27CFGR				0x1084
+#define RCC_XBAR28CFGR				0x1088
+#define RCC_XBAR29CFGR				0x108C
+#define RCC_XBAR30CFGR				0x1090
+#define RCC_XBAR31CFGR				0x1094
+#define RCC_XBAR32CFGR				0x1098
+#define RCC_XBAR33CFGR				0x109C
+#define RCC_XBAR34CFGR				0x10A0
+#define RCC_XBAR35CFGR				0x10A4
+#define RCC_XBAR36CFGR				0x10A8
+#define RCC_XBAR37CFGR				0x10AC
+#define RCC_XBAR38CFGR				0x10B0
+#define RCC_XBAR39CFGR				0x10B4
+#define RCC_XBAR40CFGR				0x10B8
+#define RCC_XBAR41CFGR				0x10BC
+#define RCC_XBAR42CFGR				0x10C0
+#define RCC_XBAR43CFGR				0x10C4
+#define RCC_XBAR44CFGR				0x10C8
+#define RCC_XBAR45CFGR				0x10CC
+#define RCC_XBAR46CFGR				0x10D0
+#define RCC_XBAR47CFGR				0x10D4
+#define RCC_XBAR48CFGR				0x10D8
+#define RCC_XBAR49CFGR				0x10DC
+#define RCC_XBAR50CFGR				0x10E0
+#define RCC_XBAR51CFGR				0x10E4
+#define RCC_XBAR52CFGR				0x10E8
+#define RCC_XBAR53CFGR				0x10EC
+#define RCC_XBAR54CFGR				0x10F0
+#define RCC_XBAR55CFGR				0x10F4
+#define RCC_XBAR56CFGR				0x10F8
+#define RCC_XBAR57CFGR				0x10FC
+#define RCC_XBAR58CFGR				0x1100
+#define RCC_XBAR59CFGR				0x1104
+#define RCC_XBAR60CFGR				0x1108
+#define RCC_XBAR61CFGR				0x110C
+#define RCC_XBAR62CFGR				0x1110
+#define RCC_XBAR63CFGR				0x1114
+#define RCC_PREDIV0CFGR				0x1118
+#define RCC_PREDIV1CFGR				0x111C
+#define RCC_PREDIV2CFGR				0x1120
+#define RCC_PREDIV3CFGR				0x1124
+#define RCC_PREDIV4CFGR				0x1128
+#define RCC_PREDIV5CFGR				0x112C
+#define RCC_PREDIV6CFGR				0x1130
+#define RCC_PREDIV7CFGR				0x1134
+#define RCC_PREDIV8CFGR				0x1138
+#define RCC_PREDIV9CFGR				0x113C
+#define RCC_PREDIV10CFGR			0x1140
+#define RCC_PREDIV11CFGR			0x1144
+#define RCC_PREDIV12CFGR			0x1148
+#define RCC_PREDIV13CFGR			0x114C
+#define RCC_PREDIV14CFGR			0x1150
+#define RCC_PREDIV15CFGR			0x1154
+#define RCC_PREDIV16CFGR			0x1158
+#define RCC_PREDIV17CFGR			0x115C
+#define RCC_PREDIV18CFGR			0x1160
+#define RCC_PREDIV19CFGR			0x1164
+#define RCC_PREDIV20CFGR			0x1168
+#define RCC_PREDIV21CFGR			0x116C
+#define RCC_PREDIV22CFGR			0x1170
+#define RCC_PREDIV23CFGR			0x1174
+#define RCC_PREDIV24CFGR			0x1178
+#define RCC_PREDIV25CFGR			0x117C
+#define RCC_PREDIV26CFGR			0x1180
+#define RCC_PREDIV27CFGR			0x1184
+#define RCC_PREDIV28CFGR			0x1188
+#define RCC_PREDIV29CFGR			0x118C
+#define RCC_PREDIV30CFGR			0x1190
+#define RCC_PREDIV31CFGR			0x1194
+#define RCC_PREDIV32CFGR			0x1198
+#define RCC_PREDIV33CFGR			0x119C
+#define RCC_PREDIV34CFGR			0x11A0
+#define RCC_PREDIV35CFGR			0x11A4
+#define RCC_PREDIV36CFGR			0x11A8
+#define RCC_PREDIV37CFGR			0x11AC
+#define RCC_PREDIV38CFGR			0x11B0
+#define RCC_PREDIV39CFGR			0x11B4
+#define RCC_PREDIV40CFGR			0x11B8
+#define RCC_PREDIV41CFGR			0x11BC
+#define RCC_PREDIV42CFGR			0x11C0
+#define RCC_PREDIV43CFGR			0x11C4
+#define RCC_PREDIV44CFGR			0x11C8
+#define RCC_PREDIV45CFGR			0x11CC
+#define RCC_PREDIV46CFGR			0x11D0
+#define RCC_PREDIV47CFGR			0x11D4
+#define RCC_PREDIV48CFGR			0x11D8
+#define RCC_PREDIV49CFGR			0x11DC
+#define RCC_PREDIV50CFGR			0x11E0
+#define RCC_PREDIV51CFGR			0x11E4
+#define RCC_PREDIV52CFGR			0x11E8
+#define RCC_PREDIV53CFGR			0x11EC
+#define RCC_PREDIV54CFGR			0x11F0
+#define RCC_PREDIV55CFGR			0x11F4
+#define RCC_PREDIV56CFGR			0x11F8
+#define RCC_PREDIV57CFGR			0x11FC
+#define RCC_PREDIV58CFGR			0x1200
+#define RCC_PREDIV59CFGR			0x1204
+#define RCC_PREDIV60CFGR			0x1208
+#define RCC_PREDIV61CFGR			0x120C
+#define RCC_PREDIV62CFGR			0x1210
+#define RCC_PREDIV63CFGR			0x1214
+#define RCC_PREDIVSR1				0x1218
+#define RCC_PREDIVSR2				0x121C
+#define RCC_FINDIV0CFGR				0x1224
+#define RCC_FINDIV1CFGR				0x1228
+#define RCC_FINDIV2CFGR				0x122C
+#define RCC_FINDIV3CFGR				0x1230
+#define RCC_FINDIV4CFGR				0x1234
+#define RCC_FINDIV5CFGR				0x1238
+#define RCC_FINDIV6CFGR				0x123C
+#define RCC_FINDIV7CFGR				0x1240
+#define RCC_FINDIV8CFGR				0x1244
+#define RCC_FINDIV9CFGR				0x1248
+#define RCC_FINDIV10CFGR			0x124C
+#define RCC_FINDIV11CFGR			0x1250
+#define RCC_FINDIV12CFGR			0x1254
+#define RCC_FINDIV13CFGR			0x1258
+#define RCC_FINDIV14CFGR			0x125C
+#define RCC_FINDIV15CFGR			0x1260
+#define RCC_FINDIV16CFGR			0x1264
+#define RCC_FINDIV17CFGR			0x1268
+#define RCC_FINDIV18CFGR			0x126C
+#define RCC_FINDIV19CFGR			0x1270
+#define RCC_FINDIV20CFGR			0x1274
+#define RCC_FINDIV21CFGR			0x1278
+#define RCC_FINDIV22CFGR			0x127C
+#define RCC_FINDIV23CFGR			0x1280
+#define RCC_FINDIV24CFGR			0x1284
+#define RCC_FINDIV25CFGR			0x1288
+#define RCC_FINDIV26CFGR			0x128C
+#define RCC_FINDIV27CFGR			0x1290
+#define RCC_FINDIV28CFGR			0x1294
+#define RCC_FINDIV29CFGR			0x1298
+#define RCC_FINDIV30CFGR			0x129C
+#define RCC_FINDIV31CFGR			0x12A0
+#define RCC_FINDIV32CFGR			0x12A4
+#define RCC_FINDIV33CFGR			0x12A8
+#define RCC_FINDIV34CFGR			0x12AC
+#define RCC_FINDIV35CFGR			0x12B0
+#define RCC_FINDIV36CFGR			0x12B4
+#define RCC_FINDIV37CFGR			0x12B8
+#define RCC_FINDIV38CFGR			0x12BC
+#define RCC_FINDIV39CFGR			0x12C0
+#define RCC_FINDIV40CFGR			0x12C4
+#define RCC_FINDIV41CFGR			0x12C8
+#define RCC_FINDIV42CFGR			0x12CC
+#define RCC_FINDIV43CFGR			0x12D0
+#define RCC_FINDIV44CFGR			0x12D4
+#define RCC_FINDIV45CFGR			0x12D8
+#define RCC_FINDIV46CFGR			0x12DC
+#define RCC_FINDIV47CFGR			0x12E0
+#define RCC_FINDIV48CFGR			0x12E4
+#define RCC_FINDIV49CFGR			0x12E8
+#define RCC_FINDIV50CFGR			0x12EC
+#define RCC_FINDIV51CFGR			0x12F0
+#define RCC_FINDIV52CFGR			0x12F4
+#define RCC_FINDIV53CFGR			0x12F8
+#define RCC_FINDIV54CFGR			0x12FC
+#define RCC_FINDIV55CFGR			0x1300
+#define RCC_FINDIV56CFGR			0x1304
+#define RCC_FINDIV57CFGR			0x1308
+#define RCC_FINDIV58CFGR			0x130C
+#define RCC_FINDIV59CFGR			0x1310
+#define RCC_FINDIV60CFGR			0x1314
+#define RCC_FINDIV61CFGR			0x1318
+#define RCC_FINDIV62CFGR			0x131C
+#define RCC_FINDIV63CFGR			0x1320
+#define RCC_FINDIVSR1				0x1324
+#define RCC_FINDIVSR2				0x1328
+#define RCC_FCALCOBS0CFGR			0x1340
+#define RCC_FCALCOBS1CFGR			0x1344
+#define RCC_FCALCREFCFGR			0x1348
+#define RCC_FCALCCR1				0x134C
+#define RCC_FCALCCR2				0x1354
+#define RCC_FCALCSR				0x1358
+#define RCC_PLL4CFGR1				0x1360
+#define RCC_PLL4CFGR2				0x1364
+#define RCC_PLL4CFGR3				0x1368
+#define RCC_PLL4CFGR4				0x136C
+#define RCC_PLL4CFGR5				0x1370
+#define RCC_PLL4CFGR6				0x1378
+#define RCC_PLL4CFGR7				0x137C
+#define RCC_PLL5CFGR1				0x1388
+#define RCC_PLL5CFGR2				0x138C
+#define RCC_PLL5CFGR3				0x1390
+#define RCC_PLL5CFGR4				0x1394
+#define RCC_PLL5CFGR5				0x1398
+#define RCC_PLL5CFGR6				0x13A0
+#define RCC_PLL5CFGR7				0x13A4
+#define RCC_PLL6CFGR1				0x13B0
+#define RCC_PLL6CFGR2				0x13B4
+#define RCC_PLL6CFGR3				0x13B8
+#define RCC_PLL6CFGR4				0x13BC
+#define RCC_PLL6CFGR5				0x13C0
+#define RCC_PLL6CFGR6				0x13C8
+#define RCC_PLL6CFGR7				0x13CC
+#define RCC_PLL7CFGR1				0x13D8
+#define RCC_PLL7CFGR2				0x13DC
+#define RCC_PLL7CFGR3				0x13E0
+#define RCC_PLL7CFGR4				0x13E4
+#define RCC_PLL7CFGR5				0x13E8
+#define RCC_PLL7CFGR6				0x13F0
+#define RCC_PLL7CFGR7				0x13F4
+#define RCC_PLL8CFGR1				0x1400
+#define RCC_PLL8CFGR2				0x1404
+#define RCC_PLL8CFGR3				0x1408
+#define RCC_PLL8CFGR4				0x140C
+#define RCC_PLL8CFGR5				0x1410
+#define RCC_PLL8CFGR6				0x1418
+#define RCC_PLL8CFGR7				0x141C
+#define RCC_VERR				0xFFF4
+#define RCC_IDR					0xFFF8
+#define RCC_SIDR				0xFFFC
+
+#endif /* STM32MP2_RCC_H */
diff --git a/drivers/core/ofnode.c b/drivers/core/ofnode.c
index 45ea84e9fb..77498c1a1f 100644
--- a/drivers/core/ofnode.c
+++ b/drivers/core/ofnode.c
@@ -653,13 +653,16 @@ int ofnode_decode_display_timing(ofnode parent, int index,
 	int ret = 0;
 
 	timings = ofnode_find_subnode(parent, "display-timings");
-	if (!ofnode_valid(timings))
-		return -EINVAL;
-
-	i = 0;
-	ofnode_for_each_subnode(node, timings) {
-		if (i++ == index)
-			break;
+	if (ofnode_valid(timings)) {
+		i = 0;
+		ofnode_for_each_subnode(node, timings) {
+			if (i++ == index)
+				break;
+		}
+	} else {
+		if (index != 0)
+			return -EINVAL;
+		node = ofnode_find_subnode(parent, "panel-timing");
 	}
 
 	if (!ofnode_valid(node))
@@ -709,6 +712,53 @@ int ofnode_decode_display_timing(ofnode parent, int index,
 	return ret;
 }
 
+int ofnode_decode_panel_timing(ofnode parent,
+			       struct display_timing *dt)
+{
+	ofnode timings;
+	u32 val = 0;
+	int ret = 0;
+
+	timings = ofnode_find_subnode(parent, "panel-timing");
+	if (!ofnode_valid(timings))
+		return -EINVAL;
+	memset(dt, 0, sizeof(*dt));
+	ret |= decode_timing_property(timings, "hback-porch", &dt->hback_porch);
+	ret |= decode_timing_property(timings, "hfront-porch", &dt->hfront_porch);
+	ret |= decode_timing_property(timings, "hactive", &dt->hactive);
+	ret |= decode_timing_property(timings, "hsync-len", &dt->hsync_len);
+	ret |= decode_timing_property(timings, "vback-porch", &dt->vback_porch);
+	ret |= decode_timing_property(timings, "vfront-porch", &dt->vfront_porch);
+	ret |= decode_timing_property(timings, "vactive", &dt->vactive);
+	ret |= decode_timing_property(timings, "vsync-len", &dt->vsync_len);
+	ret |= decode_timing_property(timings, "clock-frequency", &dt->pixelclock);
+	dt->flags = 0;
+	if (!ofnode_read_u32(timings, "vsync-active", &val)) {
+		dt->flags |= val ? DISPLAY_FLAGS_VSYNC_HIGH :
+		    DISPLAY_FLAGS_VSYNC_LOW;
+	}
+	if (!ofnode_read_u32(timings, "hsync-active", &val)) {
+		dt->flags |= val ? DISPLAY_FLAGS_HSYNC_HIGH :
+		    DISPLAY_FLAGS_HSYNC_LOW;
+	}
+	if (!ofnode_read_u32(timings, "de-active", &val)) {
+		dt->flags |= val ? DISPLAY_FLAGS_DE_HIGH :
+		    DISPLAY_FLAGS_DE_LOW;
+	}
+	if (!ofnode_read_u32(timings, "pixelclk-active", &val)) {
+		dt->flags |= val ? DISPLAY_FLAGS_PIXDATA_POSEDGE :
+		DISPLAY_FLAGS_PIXDATA_NEGEDGE;
+	}
+	if (ofnode_read_bool(timings, "interlaced"))
+		dt->flags |= DISPLAY_FLAGS_INTERLACED;
+	if (ofnode_read_bool(timings, "doublescan"))
+		dt->flags |= DISPLAY_FLAGS_DOUBLESCAN;
+	if (ofnode_read_bool(timings, "doubleclk"))
+		dt->flags |= DISPLAY_FLAGS_DOUBLECLK;
+
+	return ret;
+}
+
 const void *ofnode_get_property(ofnode node, const char *propname, int *lenp)
 {
 	if (ofnode_is_np(node))
diff --git a/drivers/core/read.c b/drivers/core/read.c
index c73508d276..88026e5111 100644
--- a/drivers/core/read.c
+++ b/drivers/core/read.c
@@ -399,6 +399,12 @@ int dev_decode_display_timing(const struct udevice *dev, int index,
 	return ofnode_decode_display_timing(dev_ofnode(dev), index, config);
 }
 
+int dev_decode_panel_timing(const struct udevice *dev,
+			    struct display_timing *config)
+{
+	return ofnode_decode_panel_timing(dev_ofnode(dev), config);
+}
+
 ofnode dev_get_phy_node(const struct udevice *dev)
 {
 	return ofnode_get_phy_node(dev_ofnode(dev));
diff --git a/drivers/dfu/Kconfig b/drivers/dfu/Kconfig
index 8d7f13dcb0..c3a0b93b25 100644
--- a/drivers/dfu/Kconfig
+++ b/drivers/dfu/Kconfig
@@ -41,7 +41,6 @@ config DFU_MMC
 config DFU_MTD
 	bool "MTD back end for DFU"
 	depends on DM_MTD
-	depends on CMD_MTDPARTS
 	help
 	  This option enables using DFU to read and write to on any MTD device.
 
diff --git a/drivers/dfu/dfu_mtd.c b/drivers/dfu/dfu_mtd.c
index c7075f12ec..cb20a10618 100644
--- a/drivers/dfu/dfu_mtd.c
+++ b/drivers/dfu/dfu_mtd.c
@@ -10,7 +10,6 @@
 #include <common.h>
 #include <dfu.h>
 #include <mtd.h>
-#include <jffs2/load_kernel.h>
 #include <linux/err.h>
 #include <linux/ctype.h>
 
@@ -86,27 +85,39 @@ static int mtd_block_op(enum dfu_op op, struct dfu_entity *dfu,
 
 		while (remaining) {
 			if (erase_op.addr + remaining > lim) {
-				printf("Limit reached 0x%llx while erasing at offset 0x%llx\n",
-				       lim, off);
+				printf("Limit reached 0x%llx while erasing at offset 0x%llx, remaining 0x%llx\n",
+				       lim, erase_op.addr, remaining);
 				return -EIO;
 			}
 
+			/* Skip the block if it is bad, don't erase it again */
+			if (mtd_block_isbad(mtd, erase_op.addr)) {
+				printf("Skipping bad block at 0x%08llx\n",
+				       erase_op.addr);
+				erase_op.addr += mtd->erasesize;
+				continue;
+			}
+
 			ret = mtd_erase(mtd, &erase_op);
 
 			if (ret) {
-				/* Abort if its not a bad block error */
-				if (ret != -EIO) {
-					printf("Failure while erasing at offset 0x%llx\n",
-					       erase_op.fail_addr);
-					return 0;
+				/* If this is not -EIO, we have no idea what to do. */
+				if (ret == -EIO) {
+					printf("Marking bad block at 0x%08llx (%d)\n",
+					       erase_op.fail_addr, ret);
+					ret = mtd_block_markbad(mtd, erase_op.addr);
+				}
+				/* Abort if it is not -EIO or can't mark bad */
+				if (ret) {
+					printf("Failure while erasing at offset 0x%llx (%d)\n",
+					       erase_op.fail_addr, ret);
+					return ret;
 				}
-				printf("Skipping bad block at 0x%08llx\n",
-				       erase_op.addr);
 			} else {
 				remaining -= mtd->erasesize;
 			}
 
-			/* Continue erase behind bad block */
+			/* Continue erase behind the current block */
 			erase_op.addr += mtd->erasesize;
 		}
 	}
@@ -275,7 +286,7 @@ int dfu_fill_entity_mtd(struct dfu_entity *dfu, char *devstr, char **argv, int a
 {
 	char *s;
 	struct mtd_info *mtd;
-	int ret, part;
+	int part;
 
 	mtd = get_mtd_device_nm(devstr);
 	if (IS_ERR_OR_NULL(mtd))
@@ -299,10 +310,9 @@ int dfu_fill_entity_mtd(struct dfu_entity *dfu, char *devstr, char **argv, int a
 		if (*s)
 			return -EINVAL;
 	} else if ((!strcmp(argv[0], "part")) || (!strcmp(argv[0], "partubi"))) {
-		char mtd_id[32];
-		struct mtd_device *mtd_dev;
-		u8 part_num;
-		struct part_info *pi;
+		struct mtd_info *partition;
+		int partnum = 0;
+		bool part_found = false;
 
 		if (argc != 2)
 			return -EINVAL;
@@ -313,19 +323,25 @@ int dfu_fill_entity_mtd(struct dfu_entity *dfu, char *devstr, char **argv, int a
 		if (*s)
 			return -EINVAL;
 
-		sprintf(mtd_id, "%s,%d", devstr, part - 1);
-		printf("using id '%s'\n", mtd_id);
-
-		mtdparts_init();
+		/* register partitions with MTDIDS/MTDPARTS or OF fallback */
+		mtd_probe_devices();
 
-		ret = find_dev_and_part(mtd_id, &mtd_dev, &part_num, &pi);
-		if (ret != 0) {
-			printf("Could not locate '%s'\n", mtd_id);
+		partnum = 0;
+		list_for_each_entry(partition, &mtd->partitions, node) {
+			partnum++;
+			if (partnum == part) {
+				part_found = true;
+				break;
+			}
+		}
+		if (!part_found) {
+			printf("No partition %d in %s\n", part, mtd->name);
 			return -1;
 		}
+		log_debug("partition %d:%s in %s\n", partnum, partition->name, mtd->name);
 
-		dfu->data.mtd.start = pi->offset;
-		dfu->data.mtd.size = pi->size;
+		dfu->data.mtd.start = partition->offset;
+		dfu->data.mtd.size = partition->size;
 		if (!strcmp(argv[0], "partubi"))
 			dfu->data.mtd.ubi = 1;
 	} else {
diff --git a/drivers/fastboot/fb_command.c b/drivers/fastboot/fb_command.c
index bdfdf262c8..8901f8c0aa 100644
--- a/drivers/fastboot/fb_command.c
+++ b/drivers/fastboot/fb_command.c
@@ -446,14 +446,17 @@ static void reboot_recovery(char *cmd_parameter, char *response)
 static void oem_format(char *cmd_parameter, char *response)
 {
 	char cmdbuf[32];
+	const char *part = env_get("partitions");
 
-	if (!env_get("partitions")) {
+	if (!part) {
 		fastboot_fail("partitions not set", response);
 	} else {
 		sprintf(cmdbuf, "gpt write mmc %x $partitions",
 			CONFIG_FASTBOOT_FLASH_MMC_DEV);
+		printf("Execute: %s\n", cmdbuf);
+		printf("with partitions: %s\n", part);
 		if (run_command(cmdbuf, 0))
-			fastboot_fail("", response);
+			fastboot_fail("Cannot write GPT", response);
 		else
 			fastboot_okay(NULL, response);
 	}
diff --git a/drivers/firmware/scmi/mailbox_agent.c b/drivers/firmware/scmi/mailbox_agent.c
index 3efdab9e72..8277c18606 100644
--- a/drivers/firmware/scmi/mailbox_agent.c
+++ b/drivers/firmware/scmi/mailbox_agent.c
@@ -96,7 +96,7 @@ static int setup_channel(struct udevice *dev, struct scmi_mbox_channel *chan)
 static int scmi_mbox_get_channel(struct udevice *dev,
 				 struct scmi_channel **channel)
 {
-	struct scmi_mbox_channel *base_chan = dev_get_plat(dev->parent);
+	struct scmi_mbox_channel *base_chan = dev_get_plat(dev);
 	struct scmi_mbox_channel *chan;
 	int ret;
 
diff --git a/drivers/firmware/scmi/optee_agent.c b/drivers/firmware/scmi/optee_agent.c
index 2b2b8c1670..db927fb214 100644
--- a/drivers/firmware/scmi/optee_agent.c
+++ b/drivers/firmware/scmi/optee_agent.c
@@ -326,7 +326,7 @@ static int setup_channel(struct udevice *dev, struct scmi_optee_channel *chan)
 static int scmi_optee_get_channel(struct udevice *dev,
 				  struct scmi_channel **channel)
 {
-	struct scmi_optee_channel *base_chan = dev_get_plat(dev->parent);
+	struct scmi_optee_channel *base_chan = dev_get_plat(dev);
 	struct scmi_optee_channel *chan;
 	u32 channel_id;
 	int ret;
diff --git a/drivers/firmware/scmi/scmi_agent-uclass.c b/drivers/firmware/scmi/scmi_agent-uclass.c
index 2b6211c4e6..fb89c61215 100644
--- a/drivers/firmware/scmi/scmi_agent-uclass.c
+++ b/drivers/firmware/scmi/scmi_agent-uclass.c
@@ -60,6 +60,7 @@ static int scmi_bind_protocols(struct udevice *dev)
 {
 	int ret = 0;
 	ofnode node;
+	const char *name;
 
 	dev_for_each_subnode(node, dev) {
 		struct driver *drv = NULL;
@@ -71,6 +72,7 @@ static int scmi_bind_protocols(struct udevice *dev)
 		if (ofnode_read_u32(node, "reg", &protocol_id))
 			continue;
 
+		name = ofnode_get_name(node);
 		switch (protocol_id) {
 		case SCMI_PROTOCOL_ID_CLOCK:
 			if (IS_ENABLED(CONFIG_CLK_SCMI))
@@ -100,8 +102,7 @@ static int scmi_bind_protocols(struct udevice *dev)
 			continue;
 		}
 
-		ret = device_bind(dev, drv, ofnode_get_name(node), NULL, node,
-				  NULL);
+		ret = device_bind(dev, drv, name, NULL, node, NULL);
 		if (ret)
 			break;
 	}
@@ -137,7 +138,7 @@ int devm_scmi_of_get_channel(struct udevice *dev, struct scmi_channel **channel)
 		return -ENODEV;
 
 	if (transport_dev_ops(parent)->of_get_channel)
-		return transport_dev_ops(parent)->of_get_channel(dev, channel);
+		return transport_dev_ops(parent)->of_get_channel(parent, channel);
 
 	/* Drivers without a get_channel operator don't need a channel ref */
 	*channel = NULL;
diff --git a/drivers/firmware/scmi/smccc_agent.c b/drivers/firmware/scmi/smccc_agent.c
index bc2eb67335..6a52cd75d6 100644
--- a/drivers/firmware/scmi/smccc_agent.c
+++ b/drivers/firmware/scmi/smccc_agent.c
@@ -83,7 +83,7 @@ static int setup_channel(struct udevice *dev, struct scmi_smccc_channel *chan)
 static int scmi_smccc_get_channel(struct udevice *dev,
 				  struct scmi_channel **channel)
 {
-	struct scmi_smccc_channel *base_chan = dev_get_plat(dev->parent);
+	struct scmi_smccc_channel *base_chan = dev_get_plat(dev);
 	struct scmi_smccc_channel *chan;
 	u32 func_id;
 	int ret;
diff --git a/drivers/fwu-mdata/Kconfig b/drivers/fwu-mdata/Kconfig
new file mode 100644
index 0000000000..42736a5e43
--- /dev/null
+++ b/drivers/fwu-mdata/Kconfig
@@ -0,0 +1,31 @@
+config FWU_MDATA
+	bool "Driver support for accessing FWU Metadata"
+	depends on DM
+	help
+	  Enable support for accessing FWU Metadata partitions. The
+	  FWU Metadata partitions reside on the same storage device
+	  which contains the other FWU updatable firmware images.
+
+choice
+	prompt "Storage Layout Scheme"
+	depends on FWU_MDATA
+	default FWU_MDATA_GPT_BLK
+
+config FWU_MDATA_GPT_BLK
+	bool "FWU Metadata access for GPT partitioned Block devices"
+	select PARTITION_TYPE_GUID
+	select PARTITION_UUIDS
+	depends on FWU_MDATA && BLK && EFI_PARTITION
+	help
+	  Enable support for accessing FWU Metadata on GPT partitioned
+	  block devices.
+
+config FWU_MDATA_MTD
+	bool "Raw MTD devices"
+	depends on MTD
+	help
+	  Enable support for accessing FWU Metadata on non-partitioned
+	  (or non-GPT partitioned, e.g. partition nodes in devicetree)
+	  MTD devices.
+
+endchoice
diff --git a/drivers/fwu-mdata/Makefile b/drivers/fwu-mdata/Makefile
new file mode 100644
index 0000000000..06c49747ba
--- /dev/null
+++ b/drivers/fwu-mdata/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Copyright (c) 2022, Linaro Limited
+#
+
+
+obj-$(CONFIG_FWU_MDATA) += fwu-mdata-uclass.o
+obj-$(CONFIG_FWU_MDATA_GPT_BLK) += gpt_blk.o
+obj-$(CONFIG_FWU_MDATA_MTD) += raw_mtd.o
diff --git a/drivers/fwu-mdata/fwu-mdata-uclass.c b/drivers/fwu-mdata/fwu-mdata-uclass.c
new file mode 100644
index 0000000000..145479bab0
--- /dev/null
+++ b/drivers/fwu-mdata/fwu-mdata-uclass.c
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#define LOG_CATEGORY UCLASS_FWU_MDATA
+
+#include <common.h>
+#include <dm.h>
+#include <efi_loader.h>
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+/**
+ * fwu_read_mdata() - Wrapper around fwu_mdata_ops.read_mdata()
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary,
+		   uint32_t size)
+{
+	const struct fwu_mdata_ops *ops = device_get_ops(dev);
+
+	if (!ops->read_mdata) {
+		log_debug("read_mdata() method not defined\n");
+		return -ENOSYS;
+	}
+
+	return ops->read_mdata(dev, mdata, primary, size);
+}
+
+/**
+ * fwu_write_mdata() - Wrapper around fwu_mdata_ops.write_mdata()
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata, bool primary,
+		    uint32_t size)
+{
+	const struct fwu_mdata_ops *ops = device_get_ops(dev);
+
+	if (!ops->write_mdata) {
+		log_debug("write_mdata() method not defined\n");
+		return -ENOSYS;
+	}
+
+	return ops->write_mdata(dev, mdata, primary, size);
+}
+
+UCLASS_DRIVER(fwu_mdata) = {
+	.id		= UCLASS_FWU_MDATA,
+	.name		= "fwu-mdata",
+};
diff --git a/drivers/fwu-mdata/gpt_blk.c b/drivers/fwu-mdata/gpt_blk.c
new file mode 100644
index 0000000000..97eac3611f
--- /dev/null
+++ b/drivers/fwu-mdata/gpt_blk.c
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#define LOG_CATEGORY UCLASS_FWU_MDATA
+
+#include <blk.h>
+#include <dm.h>
+#include <efi_loader.h>
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+#include <memalign.h>
+#include <part.h>
+#include <part_efi.h>
+
+#include <dm/device-internal.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+
+enum {
+	MDATA_READ = 1,
+	MDATA_WRITE,
+};
+
+static uint g_mdata_part[2]; /* = {0, 0} to check against uninit parts */
+
+static int gpt_get_mdata_partitions(struct blk_desc *desc)
+{
+	int i;
+	u32 nparts;
+	efi_guid_t part_type_guid;
+	struct disk_partition info;
+	const efi_guid_t fwu_mdata_guid = FWU_MDATA_GUID;
+
+	/* if primary and secondary partitions already found */
+	if (g_mdata_part[0] && g_mdata_part[1])
+		return 0;
+
+	nparts = 0;
+	for (i = 1; i < MAX_SEARCH_PARTITIONS && nparts < 2; i++) {
+		if (part_get_info(desc, i, &info))
+			continue;
+		uuid_str_to_bin(info.type_guid, part_type_guid.b,
+				UUID_STR_FORMAT_GUID);
+
+		if (!guidcmp(&fwu_mdata_guid, &part_type_guid))
+			g_mdata_part[nparts++] = i;
+	}
+
+	if (nparts != 2) {
+		log_debug("Expect two copies of the FWU metadata instead of %d\n",
+			  nparts);
+		g_mdata_part[0] = 0;
+		g_mdata_part[1] = 0;
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int gpt_get_mdata_disk_part(struct blk_desc *desc,
+				   struct disk_partition *info,
+				   u32 part_num)
+{
+	int ret;
+	char *mdata_guid_str = "8a7a84a0-8387-40f6-ab41-a8b9a5a60d23";
+
+	ret = part_get_info(desc, part_num, info);
+	if (ret < 0) {
+		log_debug("Unable to get the partition info for the FWU metadata part %d\n",
+			  part_num);
+		return -ENOENT;
+	}
+
+	/* Check that it is indeed the FWU metadata partition */
+	if (!strncmp(info->type_guid, mdata_guid_str, UUID_STR_LEN))
+		return 0;
+
+	return -ENOENT;
+}
+
+static int gpt_read_write_mdata(struct blk_desc *desc, struct fwu_mdata *mdata,
+				u8 access, u32 part_num, u32 size)
+{
+	int ret;
+	u32 len, blk_start, blkcnt;
+	struct disk_partition info;
+
+	ALLOC_CACHE_ALIGN_BUFFER_PAD(u8, mdata_aligned, size,
+				     desc->blksz);
+
+	if (!mdata)
+		return -ENOMEM;
+
+	ret = gpt_get_mdata_disk_part(desc, &info, part_num);
+	if (ret < 0) {
+		printf("Unable to get the FWU metadata partition\n");
+		return -ENOENT;
+	}
+
+	len = size;
+	blkcnt = BLOCK_CNT(len, desc);
+	if (blkcnt > info.size) {
+		log_debug("Block count exceeds FWU metadata partition size\n");
+		return -ERANGE;
+	}
+
+	blk_start = info.start;
+	if (access == MDATA_READ) {
+		if (blk_dread(desc, blk_start, blkcnt, mdata_aligned) != blkcnt) {
+			log_debug("Error reading FWU metadata from the device\n");
+			return -EIO;
+		}
+		memcpy(mdata, mdata_aligned, size);
+	} else {
+		if (blk_dwrite(desc, blk_start, blkcnt, mdata) != blkcnt) {
+			log_debug("Error writing FWU metadata to the device\n");
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static int fwu_get_mdata_device(struct udevice *dev, struct udevice **mdata_dev)
+{
+	u32 phandle;
+	int ret, size;
+	struct udevice *parent;
+	const fdt32_t *phandle_p = NULL;
+
+	phandle_p = dev_read_prop(dev, "fwu-mdata-store", &size);
+	if (!phandle_p) {
+		log_debug("fwu-mdata-store property not found\n");
+		return -ENOENT;
+	}
+
+	phandle = fdt32_to_cpu(*phandle_p);
+
+	ret = device_get_global_by_ofnode(ofnode_get_by_phandle(phandle),
+					  &parent);
+	if (ret)
+		return ret;
+
+	return blk_get_from_parent(parent, mdata_dev);
+}
+
+static int fwu_mdata_gpt_blk_probe(struct udevice *dev)
+{
+	int ret;
+	struct udevice *mdata_dev = NULL;
+	struct fwu_mdata_gpt_blk_priv *priv = dev_get_priv(dev);
+
+	ret = fwu_get_mdata_device(dev, &mdata_dev);
+	if (ret)
+		return ret;
+
+	priv->blk_dev = mdata_dev;
+
+	return 0;
+}
+
+static int fwu_gpt_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+			      bool primary, u32 size)
+{
+	struct fwu_mdata_gpt_blk_priv *priv = dev_get_priv(dev);
+	struct blk_desc *desc = dev_get_uclass_plat(priv->blk_dev);
+	int ret;
+
+	ret = gpt_get_mdata_partitions(desc);
+	if (ret < 0) {
+		log_debug("Error getting the FWU metadata partitions\n");
+		return -ENOENT;
+	}
+
+	return gpt_read_write_mdata(desc, mdata, MDATA_READ,
+				    primary ?
+				    g_mdata_part[0] : g_mdata_part[1],
+				    size);
+}
+
+static int fwu_gpt_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+			       bool primary, u32 size)
+{
+	struct fwu_mdata_gpt_blk_priv *priv = dev_get_priv(dev);
+	struct blk_desc *desc = dev_get_uclass_plat(priv->blk_dev);
+	int ret;
+
+	ret = gpt_get_mdata_partitions(desc);
+	if (ret < 0) {
+		log_debug("Error getting the FWU metadata partitions\n");
+		return -ENOENT;
+	}
+
+	return gpt_read_write_mdata(desc, mdata, MDATA_WRITE,
+				    primary ?
+				    g_mdata_part[0] : g_mdata_part[1],
+				    size);
+}
+
+static const struct fwu_mdata_ops fwu_gpt_blk_ops = {
+	.read_mdata = fwu_gpt_read_mdata,
+	.write_mdata = fwu_gpt_write_mdata,
+};
+
+static const struct udevice_id fwu_mdata_ids[] = {
+	{ .compatible = "u-boot,fwu-mdata-gpt" },
+	{ }
+};
+
+U_BOOT_DRIVER(fwu_mdata_gpt_blk) = {
+	.name		= "fwu-mdata-gpt-blk",
+	.id		= UCLASS_FWU_MDATA,
+	.of_match	= fwu_mdata_ids,
+	.ops		= &fwu_gpt_blk_ops,
+	.probe		= fwu_mdata_gpt_blk_probe,
+	.priv_auto	= sizeof(struct fwu_mdata_gpt_blk_priv),
+};
diff --git a/drivers/fwu-mdata/raw_mtd.c b/drivers/fwu-mdata/raw_mtd.c
new file mode 100644
index 0000000000..78a709f766
--- /dev/null
+++ b/drivers/fwu-mdata/raw_mtd.c
@@ -0,0 +1,289 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023, Linaro Limited
+ */
+
+#define LOG_CATEGORY UCLASS_FWU_MDATA
+
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <memalign.h>
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+enum fwu_mtd_op {
+	FWU_MTD_READ,
+	FWU_MTD_WRITE,
+};
+
+static bool mtd_is_aligned_with_block_size(struct mtd_info *mtd, u64 size)
+{
+	return !do_div(size, mtd->erasesize);
+}
+
+static int mtd_io_data(struct mtd_info *mtd, u32 offs, u32 size, void *data,
+		       enum fwu_mtd_op op)
+{
+	struct mtd_oob_ops io_op = {};
+	u64 lock_len;
+	size_t len;
+	void *buf;
+	int ret;
+
+	if (!mtd_is_aligned_with_block_size(mtd, offs)) {
+		log_err("Offset unaligned with a block (0x%x)\n", mtd->erasesize);
+		return -EINVAL;
+	}
+
+	/* This will expand erase size to align with the block size */
+	lock_len = round_up(size, mtd->erasesize);
+
+	ret = mtd_unlock(mtd, offs, lock_len);
+	if (ret && ret != -EOPNOTSUPP)
+		return ret;
+
+	if (op == FWU_MTD_WRITE) {
+		struct erase_info erase_op = {};
+
+		erase_op.mtd = mtd;
+		erase_op.addr = offs;
+		erase_op.len = lock_len;
+		erase_op.scrub = 0;
+
+		ret = mtd_erase(mtd, &erase_op);
+		if (ret)
+			goto lock;
+	}
+
+	/* Also, expand the write size to align with the write size */
+	len = round_up(size, mtd->writesize);
+
+	buf = memalign(ARCH_DMA_MINALIGN, len);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto lock;
+	}
+	memset(buf, 0xff, len);
+
+	io_op.mode = MTD_OPS_AUTO_OOB;
+	io_op.len = len;
+	io_op.datbuf = buf;
+
+	if (op == FWU_MTD_WRITE) {
+		memcpy(buf, data, size);
+		ret = mtd_write_oob(mtd, offs, &io_op);
+	} else {
+		ret = mtd_read_oob(mtd, offs, &io_op);
+		if (!ret)
+			memcpy(data, buf, size);
+	}
+	free(buf);
+
+lock:
+	mtd_lock(mtd, offs, lock_len);
+
+	return ret;
+}
+
+static int fwu_mtd_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+			      bool primary, u32 size)
+{
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
+	struct mtd_info *mtd = mtd_priv->mtd;
+	u32 offs = primary ? mtd_priv->pri_offset : mtd_priv->sec_offset;
+
+	return mtd_io_data(mtd, offs, size, mdata, FWU_MTD_READ);
+}
+
+static int fwu_mtd_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+			       bool primary, u32 size)
+{
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
+	struct mtd_info *mtd = mtd_priv->mtd;
+	u32 offs = primary ? mtd_priv->pri_offset : mtd_priv->sec_offset;
+
+	return mtd_io_data(mtd, offs, size, mdata, FWU_MTD_WRITE);
+}
+
+static int flash_partition_offset(struct udevice *dev, const char *part_name, fdt_addr_t *offset)
+{
+	ofnode node, parts_node;
+	fdt_addr_t size = 0;
+
+	parts_node = ofnode_by_compatible(dev_ofnode(dev), "fixed-partitions");
+	node = ofnode_by_prop_value(parts_node, "label", part_name, strlen(part_name) + 1);
+	if (!ofnode_valid(node)) {
+		log_err("Warning: Failed to find partition by label <%s>\n", part_name);
+		return -ENOENT;
+	}
+
+	*offset = ofnode_get_addr_size_index_notrans(node, 0, &size);
+
+	return (int)size;
+}
+
+static int get_fwu_mdata_dev(struct udevice *dev)
+{
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
+	const fdt32_t *phandle_p = NULL;
+	struct udevice *mtd_dev;
+	struct mtd_info *mtd;
+	const char *label;
+	fdt_addr_t offset;
+	int ret, size;
+	u32 phandle;
+
+	/* Find the FWU mdata storage device */
+	phandle_p = ofnode_get_property(dev_ofnode(dev),
+					"fwu-mdata-store", &size);
+	if (!phandle_p) {
+		log_err("FWU meta data store not defined in device-tree\n");
+		return -ENOENT;
+	}
+
+	phandle = fdt32_to_cpu(*phandle_p);
+
+	ret = device_get_global_by_ofnode(ofnode_get_by_phandle(phandle),
+					  &mtd_dev);
+	if (ret) {
+		log_err("FWU: failed to get mtd device\n");
+		return ret;
+	}
+
+	mtd_probe_devices();
+
+	mtd_for_each_device(mtd) {
+		if (mtd->dev == mtd_dev) {
+			mtd_priv->mtd = mtd;
+			log_debug("Found the FWU mdata mtd device %s\n", mtd->name);
+			break;
+		}
+	}
+	if (!mtd_priv->mtd) {
+		log_err("Failed to find mtd device by fwu-mdata-store\n");
+		return -ENODEV;
+	}
+
+	/* Get the offset of primary and secondary mdata */
+	ret = ofnode_read_string_index(dev_ofnode(dev), "mdata-parts", 0, &label);
+	if (ret)
+		return ret;
+	strncpy(mtd_priv->pri_label, label, 50);
+
+	ret = flash_partition_offset(mtd_dev, mtd_priv->pri_label, &offset);
+	if (ret <= 0)
+		return ret;
+	mtd_priv->pri_offset = offset;
+
+	ret = ofnode_read_string_index(dev_ofnode(dev), "mdata-parts", 1, &label);
+	if (ret)
+		return ret;
+	strncpy(mtd_priv->sec_label, label, 50);
+
+	ret = flash_partition_offset(mtd_dev, mtd_priv->sec_label, &offset);
+	if (ret <= 0)
+		return ret;
+	mtd_priv->sec_offset = offset;
+
+	return 0;
+}
+
+static int fwu_mtd_image_info_populate(struct udevice *dev, u8 nbanks,
+				       u16 nimages)
+{
+	struct fwu_mtd_image_info *mtd_images;
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(dev);
+	struct udevice *mtd_dev = mtd_priv->mtd->dev;
+	fdt_addr_t offset;
+	ofnode bank;
+	int off_img;
+	u32 total_images;
+
+	total_images = nbanks * nimages;
+	mtd_priv->fwu_mtd_images = malloc(sizeof(struct fwu_mtd_image_info) *
+					  total_images);
+	if (!mtd_priv->fwu_mtd_images)
+		return -ENOMEM;
+
+	off_img = 0;
+	mtd_images = mtd_priv->fwu_mtd_images;
+	ofnode_for_each_subnode(bank, dev_ofnode(dev)) {
+		int bank_num, bank_offset, bank_size;
+		const char *bank_name;
+		ofnode image;
+
+		ofnode_read_u32(bank, "id", &bank_num);
+		bank_name = ofnode_read_string(bank, "label");
+		bank_size = flash_partition_offset(mtd_dev, bank_name, &offset);
+		if (bank_size <= 0)
+			return bank_size;
+		bank_offset = offset;
+		log_debug("Bank%d: %s [0x%x - 0x%x]\n",
+			  bank_num, bank_name, bank_offset, bank_offset + bank_size);
+
+		ofnode_for_each_subnode(image, bank) {
+			int image_num, image_offset, image_size;
+			const char *uuid;
+
+			if (off_img == total_images) {
+				log_err("DT provides more images than configured!\n");
+				break;
+			}
+
+			uuid = ofnode_read_string(image, "uuid");
+			ofnode_read_u32(image, "id", &image_num);
+			ofnode_read_u32(image, "offset", &image_offset);
+			ofnode_read_u32(image, "size", &image_size);
+
+			mtd_images[off_img].start = bank_offset + image_offset;
+			mtd_images[off_img].size = image_size;
+			mtd_images[off_img].bank_num = bank_num;
+			mtd_images[off_img].image_num = image_num;
+			strcpy(mtd_images[off_img].uuidbuf, uuid);
+			log_debug("\tImage%d: %s @0x%x\n\n",
+				  image_num, uuid, bank_offset + image_offset);
+			off_img++;
+		}
+	}
+
+	return 0;
+}
+
+static int fwu_mdata_mtd_probe(struct udevice *dev)
+{
+	u8 nbanks;
+	u16 nimages;
+	int ret;
+
+	ret = get_fwu_mdata_dev(dev);
+	if (ret)
+		return ret;
+
+	nbanks = CONFIG_FWU_NUM_BANKS;
+	nimages = CONFIG_FWU_NUM_IMAGES_PER_BANK;
+	ret = fwu_mtd_image_info_populate(dev, nbanks, nimages);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static struct fwu_mdata_ops fwu_mtd_ops = {
+	.read_mdata = fwu_mtd_read_mdata,
+	.write_mdata = fwu_mtd_write_mdata,
+};
+
+static const struct udevice_id fwu_mdata_ids[] = {
+	{ .compatible = "u-boot,fwu-mdata-mtd" },
+	{ }
+};
+
+U_BOOT_DRIVER(fwu_mdata_mtd) = {
+	.name		= "fwu-mdata-mtd",
+	.id		= UCLASS_FWU_MDATA,
+	.of_match	= fwu_mdata_ids,
+	.ops		= &fwu_mtd_ops,
+	.probe		= fwu_mdata_mtd_probe,
+	.priv_auto	= sizeof(struct fwu_mdata_mtd_priv),
+};
diff --git a/drivers/gpio/gpio-uclass.c b/drivers/gpio/gpio-uclass.c
index 0ed32b7217..4566e2971b 100644
--- a/drivers/gpio/gpio-uclass.c
+++ b/drivers/gpio/gpio-uclass.c
@@ -315,34 +315,11 @@ static int gpio_hog_probe(struct udevice *dev)
 	return 0;
 }
 
-int gpio_hog_probe_all(void)
-{
-	struct udevice *dev;
-	int ret;
-	int retval = 0;
-
-	for (uclass_first_device(UCLASS_NOP, &dev);
-	     dev;
-	     uclass_find_next_device(&dev)) {
-		if (dev->driver == DM_DRIVER_GET(gpio_hog)) {
-			ret = device_probe(dev);
-			if (ret) {
-				printf("Failed to probe device %s err: %d\n",
-				       dev->name, ret);
-				retval = ret;
-			}
-		}
-	}
-
-	return retval;
-}
-
 int gpio_hog_lookup_name(const char *name, struct gpio_desc **desc)
 {
 	struct udevice *dev;
 
 	*desc = NULL;
-	gpio_hog_probe_all();
 	if (!uclass_get_device_by_name(UCLASS_NOP, name, &dev)) {
 		struct gpio_hog_priv *priv = dev_get_priv(dev);
 
@@ -838,6 +815,7 @@ static const char * const gpio_function[GPIOF_COUNT] = {
 	"unused",
 	"unknown",
 	"func",
+	"protected",
 };
 
 static int get_function(struct udevice *dev, int offset, bool skip_unused,
@@ -884,26 +862,31 @@ int gpio_get_status(struct udevice *dev, int offset, char *buf, int buffsize)
 	const struct dm_gpio_ops *ops = gpio_get_ops(dev);
 	struct gpio_dev_priv *priv;
 	char *str = buf;
+	const char *label;
 	int func;
 	int ret;
 	int len;
+	bool used;
 
 	BUILD_BUG_ON(GPIOF_COUNT != ARRAY_SIZE(gpio_function));
 
 	*buf = 0;
 	priv = dev_get_uclass_priv(dev);
-	ret = gpio_get_raw_function(dev, offset, NULL);
+	ret = gpio_get_raw_function(dev, offset, &label);
 	if (ret < 0)
 		return ret;
 	func = ret;
 	len = snprintf(str, buffsize, "%s%d: %s",
 		       priv->bank_name ? priv->bank_name : "",
 		       offset, gpio_function[func]);
-	if (func == GPIOF_INPUT || func == GPIOF_OUTPUT ||
-	    func == GPIOF_UNUSED) {
-		const char *label;
-		bool used;
 
+	switch (func) {
+	case GPIOF_FUNC:
+		snprintf(str + len, buffsize - len, " %s", label ? label : "");
+		break;
+	case GPIOF_INPUT:
+	case GPIOF_OUTPUT:
+	case GPIOF_UNUSED:
 		ret = ops->get_value(dev, offset);
 		if (ret < 0)
 			return ret;
@@ -911,8 +894,9 @@ int gpio_get_status(struct udevice *dev, int offset, char *buf, int buffsize)
 		snprintf(str + len, buffsize - len, ": %d [%c]%s%s",
 			 ret,
 			 used ? 'x' : ' ',
-			 used ? " " : "",
+			 label ? " " : "",
 			 label ? label : "");
+		break;
 	}
 
 	return 0;
@@ -1503,9 +1487,17 @@ static int gpio_post_bind(struct udevice *dev)
 								 &child);
 				if (ret)
 					return ret;
+
+				/*
+				 * Make sure gpio-hogs are probed after bind
+				 * since hogs can be essential to the hardware
+				 * system.
+				 */
+				dev_or_flags(child, DM_FLAG_PROBE_AFTER_BIND);
 			}
 		}
 	}
+
 	return 0;
 }
 
diff --git a/drivers/gpio/sandbox.c b/drivers/gpio/sandbox.c
index 106b2a7b27..41a0095bd8 100644
--- a/drivers/gpio/sandbox.c
+++ b/drivers/gpio/sandbox.c
@@ -192,12 +192,16 @@ static int sb_gpio_set_value(struct udevice *dev, unsigned offset, int value)
 
 static int sb_gpio_get_function(struct udevice *dev, unsigned offset)
 {
+	if (get_gpio_flag(dev, offset, GPIOD_EXT_PROTECTED))
+		return GPIOF_PROTECTED;
 	if (get_gpio_flag(dev, offset, GPIOD_IS_OUT))
 		return GPIOF_OUTPUT;
 	if (get_gpio_flag(dev, offset, GPIOD_IS_IN))
 		return GPIOF_INPUT;
+	if (get_gpio_flag(dev, offset, GPIOD_IS_AF))
+		return GPIOF_FUNC;
 
-	return GPIOF_INPUT; /*GPIO is not configurated */
+	return GPIOF_INPUT; /* GPIO is not configured */
 }
 
 static int sb_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
@@ -219,6 +223,9 @@ static int sb_gpio_xlate(struct udevice *dev, struct gpio_desc *desc,
 	if (args->args[1] & GPIO_OUT_ACTIVE)
 		desc->flags |= GPIOD_IS_OUT_ACTIVE;
 
+	if (args->args[1] & GPIO_AF)
+		desc->flags |= GPIOD_IS_AF;
+
 	return 0;
 }
 
@@ -523,6 +530,14 @@ static int sb_pinctrl_get_pin_muxing(struct udevice *dev,
 	unsigned int gpio_idx;
 	ulong flags;
 	int function;
+	static const char * const gpio_function[GPIOF_COUNT] = {
+		"input",
+		"output",
+		"unused",
+		"unknown",
+		"func",
+		"protected",
+	};
 
 	/* look up for the bank which owns the requested pin */
 	gpio_dev = sb_pinctrl_get_gpio_dev(dev, selector, &gpio_idx);
@@ -531,9 +546,7 @@ static int sb_pinctrl_get_pin_muxing(struct udevice *dev,
 	} else {
 		function = sb_gpio_get_function(gpio_dev, gpio_idx);
 		flags = *get_gpio_flags(gpio_dev, gpio_idx);
-
-		snprintf(buf, size, "gpio %s %s",
-			 function == GPIOF_OUTPUT ? "output" : "input",
+		snprintf(buf, size, "gpio %s %s", gpio_function[function],
 			 get_flags_string(flags));
 	}
 
diff --git a/drivers/gpio/stm32_gpio.c b/drivers/gpio/stm32_gpio.c
index 7a2ca91c76..98fc021c15 100644
--- a/drivers/gpio/stm32_gpio.c
+++ b/drivers/gpio/stm32_gpio.c
@@ -15,6 +15,7 @@
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/errno.h>
 #include <linux/io.h>
@@ -33,6 +34,19 @@
 #define OTYPE_BITS(gpio_pin)		(gpio_pin)
 #define OTYPE_MSK			1
 
+#define SECCFG_BITS(gpio_pin)		(gpio_pin)
+#define SECCFG_MSK			1
+
+#define STM32_GPIO_CID1			1
+
+#define STM32_GPIO_CIDCFGR_CFEN		BIT(0)
+#define STM32_GPIO_CIDCFGR_SEMEN	BIT(1)
+#define STM32_GPIO_CIDCFGR_SCID_MASK	GENMASK(5, 4)
+#define STM32_GPIO_CIDCFGR_SEMWL_CID1	BIT(16 + STM32_GPIO_CID1)
+
+#define STM32_GPIO_SEMCR_SEM_MUTEX	BIT(0)
+#define STM32_GPIO_SEMCR_SEMCID_MASK	GENMASK(5, 4)
+
 static void stm32_gpio_set_moder(struct stm32_gpio_regs *regs,
 				 int idx,
 				 int mode)
@@ -90,6 +104,97 @@ static bool stm32_gpio_is_mapped(struct udevice *dev, int offset)
 	return !!(priv->gpio_range & BIT(offset));
 }
 
+bool stm32_gpio_rif_valid(struct stm32_gpio_regs *regs, unsigned int offset)
+{
+	u32 cid, sem;
+
+	cid = readl(&regs->rif[offset].cidcfgr);
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return true;
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMEN)) {
+		if (FIELD_GET(STM32_GPIO_CIDCFGR_SCID_MASK, cid) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	if (!(cid & STM32_GPIO_CIDCFGR_SEMWL_CID1))
+		return false;
+
+	sem = readl(&regs->rif[offset].semcr);
+
+	if (sem & STM32_GPIO_SEMCR_SEM_MUTEX) {
+		if (FIELD_GET(STM32_GPIO_SEMCR_SEMCID_MASK, sem) == STM32_GPIO_CID1)
+			return true;
+
+		return false;
+	}
+
+	writel(STM32_GPIO_SEMCR_SEM_MUTEX, &regs->rif[offset].semcr);
+	sem = readl(&regs->rif[offset].semcr);
+	if (sem & STM32_GPIO_SEMCR_SEM_MUTEX &&
+	    FIELD_GET(STM32_GPIO_SEMCR_SEMCID_MASK, sem) == STM32_GPIO_CID1)
+		return true;
+
+	return false;
+}
+
+static void stm32_gpio_rif_release(struct stm32_gpio_regs *regs, unsigned int offset)
+{
+	u32 cid;
+
+	cid = readl(&regs->rif[offset].cidcfgr);
+
+	if (!(cid & STM32_GPIO_CIDCFGR_CFEN))
+		return;
+
+	if (cid & STM32_GPIO_CIDCFGR_SEMEN && cid & STM32_GPIO_CIDCFGR_SEMWL_CID1)
+		writel(0, &regs->rif[offset].semcr);
+}
+
+static int stm32_gpio_request(struct udevice *dev, unsigned offset, const char *label)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(dev);
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
+
+	if (!stm32_gpio_is_mapped(dev, offset))
+		return -ENXIO;
+
+	/* Deny request access if IO is secured */
+	if ((drv_data & STM32_GPIO_FLAG_SEC_CTRL) &&
+	    ((readl(&regs->seccfgr) >> SECCFG_BITS(offset)) & SECCFG_MSK)) {
+		dev_err(dev, "Failed to get secure IO %s %d @ %p\n",
+			uc_priv->bank_name, offset, regs);
+		return -EACCES;
+	}
+
+	/* Deny request access if IO RIF semaphore is not available */
+	if ((drv_data & STM32_GPIO_FLAG_RIF_CTRL) &&
+	    !stm32_gpio_rif_valid(regs, offset)) {
+		dev_err(dev, "Failed to take RIF semaphore on IO %s %d @ %p\n",
+			uc_priv->bank_name, offset, regs);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+static int stm32_gpio_rfree(struct udevice *dev, unsigned int offset)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
+
+	if (drv_data & STM32_GPIO_FLAG_RIF_CTRL)
+		stm32_gpio_rif_release(regs, offset);
+
+	return 0;
+}
+
 static int stm32_gpio_direction_input(struct udevice *dev, unsigned offset)
 {
 	struct stm32_gpio_priv *priv = dev_get_priv(dev);
@@ -147,6 +252,7 @@ static int stm32_gpio_get_function(struct udevice *dev, unsigned int offset)
 {
 	struct stm32_gpio_priv *priv = dev_get_priv(dev);
 	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
 	int bits_index;
 	int mask;
 	u32 mode;
@@ -154,6 +260,16 @@ static int stm32_gpio_get_function(struct udevice *dev, unsigned int offset)
 	if (!stm32_gpio_is_mapped(dev, offset))
 		return GPIOF_UNKNOWN;
 
+	/* Return 'protected' if the IO is secured */
+	if ((drv_data & STM32_GPIO_FLAG_SEC_CTRL) &&
+	    ((readl(&regs->seccfgr) >> SECCFG_BITS(offset)) & SECCFG_MSK))
+		return GPIOF_PROTECTED;
+
+	/* Return 'protected' if the IO RIF semaphore is not available */
+	if ((drv_data & STM32_GPIO_FLAG_RIF_CTRL) &&
+	    !stm32_gpio_rif_valid(regs, offset))
+		return GPIOF_PROTECTED;
+
 	bits_index = MODE_BITS(offset);
 	mask = MODE_BITS_MASK << bits_index;
 
@@ -239,6 +355,8 @@ static int stm32_gpio_get_flags(struct udevice *dev, unsigned int offset,
 }
 
 static const struct dm_gpio_ops gpio_stm32_ops = {
+	.request		= stm32_gpio_request,
+	.rfree			= stm32_gpio_rfree,
 	.direction_input	= stm32_gpio_direction_input,
 	.direction_output	= stm32_gpio_direction_output,
 	.get_value		= stm32_gpio_get_value,
@@ -309,11 +427,39 @@ static int gpio_stm32_probe(struct udevice *dev)
 	return 0;
 }
 
+static int gpio_stm32_remove(struct udevice *dev)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(dev);
+	unsigned int offset;
+	u32 seccfgr = 0;
+
+	if (!(drv_data & STM32_GPIO_FLAG_RIF_CTRL))
+		return 0;
+
+	if (drv_data & STM32_GPIO_FLAG_SEC_CTRL)
+		seccfgr = readl(&regs->seccfgr);
+
+	for (offset = 0; offset < STM32_GPIOS_PER_BANK; offset++) {
+		if (!stm32_gpio_is_mapped(dev, offset))
+			continue;
+
+		if ((seccfgr >> SECCFG_BITS(offset)) & SECCFG_MSK)
+			continue;
+
+		stm32_gpio_rif_release(regs, offset);
+	}
+
+	return 0;
+}
+
 U_BOOT_DRIVER(gpio_stm32) = {
 	.name	= "gpio_stm32",
 	.id	= UCLASS_GPIO,
 	.probe	= gpio_stm32_probe,
+	.remove	= gpio_stm32_remove,
 	.ops	= &gpio_stm32_ops,
-	.flags	= DM_UC_FLAG_SEQ_ALIAS,
+	.flags	= DM_UC_FLAG_SEQ_ALIAS | DM_FLAG_OS_PREPARE,
 	.priv_auto	= sizeof(struct stm32_gpio_priv),
 };
diff --git a/drivers/gpio/stm32_gpio_priv.h b/drivers/gpio/stm32_gpio_priv.h
index 662a000fe7..1da066dec3 100644
--- a/drivers/gpio/stm32_gpio_priv.h
+++ b/drivers/gpio/stm32_gpio_priv.h
@@ -51,17 +51,63 @@ enum stm32_gpio_af {
 	STM32_GPIO_AF15
 };
 
+enum stm32_gpio_delay_path {
+	STM32_GPIO_DELAY_PATH_OUT = 0,
+	STM32_GPIO_DELAY_PATH_IN
+};
+
+enum stm32_gpio_clk_edge {
+	STM32_GPIO_CLK_EDGE_SINGLE = 0,
+	STM32_GPIO_CLK_EDGE_DOUBLE
+};
+
+enum stm32_gpio_clk_type {
+	STM32_GPIO_CLK_TYPE_NOT_INVERT = 0,
+	STM32_GPIO_CLK_TYPE_INVERT
+};
+
+enum stm32_gpio_retime {
+	STM32_GPIO_RETIME_DISABLED = 0,
+	STM32_GPIO_RETIME_ENABLED
+};
+
+enum stm32_gpio_delay {
+	STM32_GPIO_DELAY_NONE = 0,
+	STM32_GPIO_DELAY_0_3,
+	STM32_GPIO_DELAY_0_5,
+	STM32_GPIO_DELAY_0_75,
+	STM32_GPIO_DELAY_1_0,
+	STM32_GPIO_DELAY_1_25,
+	STM32_GPIO_DELAY_1_5,
+	STM32_GPIO_DELAY_1_75,
+	STM32_GPIO_DELAY_2_0,
+	STM32_GPIO_DELAY_2_25,
+	STM32_GPIO_DELAY_2_5,
+	STM32_GPIO_DELAY_2_75,
+	STM32_GPIO_DELAY_3_0,
+	STM32_GPIO_DELAY_3_25
+};
+
+#define STM32_GPIO_FLAG_SEC_CTRL	BIT(0)
+#define STM32_GPIO_FLAG_IO_SYNC_CTRL	BIT(1)
+#define STM32_GPIO_FLAG_RIF_CTRL	BIT(2)
+
 struct stm32_gpio_dsc {
 	u8	port;
 	u8	pin;
 };
 
 struct stm32_gpio_ctl {
-	enum stm32_gpio_mode	mode;
-	enum stm32_gpio_otype	otype;
-	enum stm32_gpio_speed	speed;
-	enum stm32_gpio_pupd	pupd;
-	enum stm32_gpio_af	af;
+	enum stm32_gpio_mode		mode;
+	enum stm32_gpio_otype		otype;
+	enum stm32_gpio_speed		speed;
+	enum stm32_gpio_pupd		pupd;
+	enum stm32_gpio_af		af;
+	enum stm32_gpio_delay_path	delay_path;
+	enum stm32_gpio_clk_edge	clk_edge;
+	enum stm32_gpio_clk_type	clk_type;
+	enum stm32_gpio_retime		retime;
+	enum stm32_gpio_delay		delay;
 };
 
 struct stm32_gpio_regs {
@@ -74,6 +120,18 @@ struct stm32_gpio_regs {
 	u32 bsrr;	/* GPIO port bit set/reset */
 	u32 lckr;	/* GPIO port configuration lock */
 	u32 afr[2];	/* GPIO alternate function */
+	u32 brr;	/* GPIO port bit reset */
+	u32 rfu;	/* Reserved */
+	u32 seccfgr;	/* GPIO secure configuration */
+	u32 rfu2;	/* Reserved (privcfgr) */
+	u32 rfu3;	/* Reserved (rcfglock) */
+	u32 rfu4;	/* Reserved */
+	u32 delayr[2];	/* GPIO port delay */
+	u32 advcfgr[2];	/* GPIO port PIO control */
+	struct {
+		u32 cidcfgr;	/* GPIO RIF CID configuration */
+		u32 semcr;	/* GPIO RIF semaphore */
+	} rif[16];
 };
 
 struct stm32_gpio_priv {
@@ -81,4 +139,6 @@ struct stm32_gpio_priv {
 	unsigned int gpio_range;
 };
 
+bool stm32_gpio_rif_valid(struct stm32_gpio_regs *regs, unsigned int offset);
+
 #endif /* _STM32_GPIO_PRIV_H_ */
diff --git a/drivers/hwspinlock/hwspinlock-uclass.c b/drivers/hwspinlock/hwspinlock-uclass.c
index e012d5a4c9..a47d615841 100644
--- a/drivers/hwspinlock/hwspinlock-uclass.c
+++ b/drivers/hwspinlock/hwspinlock-uclass.c
@@ -24,7 +24,7 @@ hwspinlock_dev_ops(struct udevice *dev)
 static int hwspinlock_of_xlate_default(struct hwspinlock *hws,
 				       struct ofnode_phandle_args *args)
 {
-	if (args->args_count > 1) {
+	if (args->args_count > 2) {
 		debug("Invalid args_count: %d\n", args->args_count);
 		return -EINVAL;
 	}
diff --git a/drivers/i2c/stm32f7_i2c.c b/drivers/i2c/stm32f7_i2c.c
index 836148e4c1..eec5ac4ef9 100644
--- a/drivers/i2c/stm32f7_i2c.c
+++ b/drivers/i2c/stm32f7_i2c.c
@@ -170,9 +170,11 @@ struct stm32_i2c_setup {
 /**
  * struct stm32_i2c_data - driver data for I2C configuration by compatible
  * @fmp_clr_offset: Fast Mode Plus clear register offset from set register
+ * @fmp_cr1_bit: Fast Mode Plus control is done via a bit in CR1
  */
 struct stm32_i2c_data {
 	u32 fmp_clr_offset;
+	bool fmp_cr1_bit;
 };
 
 /**
@@ -270,6 +272,10 @@ static const struct stm32_i2c_data stm32mp13_data = {
 	.fmp_clr_offset = 0x4,
 };
 
+static const struct stm32_i2c_data stm32mp25_data = {
+	.fmp_cr1_bit = true,
+};
+
 static int stm32_i2c_check_device_busy(struct stm32_i2c_priv *i2c_priv)
 {
 	struct stm32_i2c_regs *regs = i2c_priv->regs;
@@ -483,9 +489,9 @@ static int stm32_i2c_message_xfer(struct stm32_i2c_priv *i2c_priv,
 		}
 	}
 
-	/* End of transfer, send stop condition if appropriate */
-	if (!ret && !(status & (STM32_I2C_ISR_NACKF | STM32_I2C_ISR_ERRORS)))
-		setbits_le32(&regs->cr2, STM32_I2C_CR2_STOP);
+	/* End of transfer, send stop condition */
+	mask = STM32_I2C_CR2_STOP;
+	setbits_le32(&regs->cr2, mask);
 
 	return stm32_i2c_check_end_of_message(i2c_priv);
 }
@@ -797,6 +803,8 @@ static int stm32_i2c_write_fm_plus_bits(struct stm32_i2c_priv *i2c_priv)
 	int ret;
 	bool enable = i2c_priv->speed > I2C_SPEED_FAST_RATE;
 
+	/* TODO STM32MP25: handle FMP bit in CR1  register (fmp_cr1_bit = true) */
+
 	/* Optional */
 	if (IS_ERR_OR_NULL(i2c_priv->regmap))
 		return 0;
@@ -934,19 +942,21 @@ static int stm32_of_to_plat(struct udevice *dev)
 
 	i2c_priv->setup.analog_filter = dev_read_bool(dev, "i2c-analog-filter");
 
-	/* Optional */
-	i2c_priv->regmap = syscon_regmap_lookup_by_phandle(dev,
-							   "st,syscfg-fmp");
-	if (!IS_ERR(i2c_priv->regmap)) {
-		u32 fmp[3];
+	if (!data->fmp_cr1_bit) {
+		/* Optional */
+		i2c_priv->regmap = syscon_regmap_lookup_by_phandle(dev,
+								   "st,syscfg-fmp");
+		if (!IS_ERR(i2c_priv->regmap)) {
+			u32 fmp[3];
 
-		ret = dev_read_u32_array(dev, "st,syscfg-fmp", fmp, 3);
-		if (ret)
-			return ret;
+			ret = dev_read_u32_array(dev, "st,syscfg-fmp", fmp, 3);
+			if (ret)
+				return ret;
 
-		i2c_priv->regmap_sreg = fmp[1];
-		i2c_priv->regmap_creg = fmp[1] + data->fmp_clr_offset;
-		i2c_priv->regmap_mask = fmp[2];
+			i2c_priv->regmap_sreg = fmp[1];
+			i2c_priv->regmap_creg = fmp[1] + data->fmp_clr_offset;
+			i2c_priv->regmap_mask = fmp[2];
+		}
 	}
 
 	return 0;
@@ -961,6 +971,7 @@ static const struct udevice_id stm32_i2c_of_match[] = {
 	{ .compatible = "st,stm32f7-i2c", .data = (ulong)&stm32f7_data },
 	{ .compatible = "st,stm32mp15-i2c", .data = (ulong)&stm32mp15_data },
 	{ .compatible = "st,stm32mp13-i2c", .data = (ulong)&stm32mp13_data },
+	{ .compatible = "st,stm32mp25-i2c", .data = (ulong)&stm32mp25_data },
 	{}
 };
 
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 7271892763..91b21d1f74 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -13,6 +13,14 @@ config STM32_FMC2_EBI
 	  devices (like SRAM, ethernet adapters, FPGAs, LCD displays, ...) on
 	  SOCs containing the FMC2 External Bus Interface.
 
+config STM32_OMI
+	bool "Support for Octo Memory Interface on STM32MP SoCs"
+	depends on ARCH_STM32MP
+	help
+	  Select this option to enable the STM32 Octo Memory Interface controller
+	  (OMI) which provides either SPI or HyperBus support. This allows to support
+	  sNOR, sNAND or HyperFlash devices.
+
 config TI_AEMIF
 	tristate "Texas Instruments AEMIF driver"
 	depends on ARCH_KEYSTONE
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index fec52efb60..2685b9235d 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -1,3 +1,4 @@
 
 obj-$(CONFIG_STM32_FMC2_EBI) += stm32-fmc2-ebi.o
+obj-$(CONFIG_STM32_OMI) += stm32-omi.o
 obj-$(CONFIG_TI_AEMIF) += ti-aemif.o
diff --git a/drivers/memory/stm32-fmc2-ebi.c b/drivers/memory/stm32-fmc2-ebi.c
index 212bb4f5dc..2ef3cf5bba 100644
--- a/drivers/memory/stm32-fmc2-ebi.c
+++ b/drivers/memory/stm32-fmc2-ebi.c
@@ -21,8 +21,15 @@
 #define FMC2_BCR(x)			((x) * 0x8 + FMC2_BCR1)
 #define FMC2_BTR(x)			((x) * 0x8 + FMC2_BTR1)
 #define FMC2_PCSCNTR			0x20
+#define FMC2_CFGR			0x20
+#define FMC2_SR				0x84
 #define FMC2_BWTR1			0x104
 #define FMC2_BWTR(x)			((x) * 0x8 + FMC2_BWTR1)
+#define FMC2_SECCFGR			0x300
+#define FMC2_CIDCFGR0			0x30c
+#define FMC2_CIDCFGR(x)			((x) * 0x8 + FMC2_CIDCFGR0)
+#define FMC2_SEMCR0			0x310
+#define FMC2_SEMCR(x)			((x) * 0x8 + FMC2_SEMCR0)
 
 /* Register: FMC2_BCR1 */
 #define FMC2_BCR1_CCLKEN		BIT(20)
@@ -43,6 +50,7 @@
 #define FMC2_BCR_ASYNCWAIT		BIT(15)
 #define FMC2_BCR_CPSIZE			GENMASK(18, 16)
 #define FMC2_BCR_CBURSTRW		BIT(19)
+#define FMC2_BCR_CSCOUNT		GENMASK(21, 20)
 #define FMC2_BCR_NBLSET			GENMASK(23, 22)
 
 /* Register: FMC2_BTRx/FMC2_BWTRx */
@@ -59,8 +67,28 @@
 #define FMC2_PCSCNTR_CSCOUNT		GENMASK(15, 0)
 #define FMC2_PCSCNTR_CNTBEN(x)		BIT((x) + 16)
 
+/* Register: FMC2_CFGR */
+#define FMC2_CFGR_CLKDIV		GENMASK(19, 16)
+#define FMC2_CFGR_CCLKEN		BIT(20)
+#define FMC2_CFGR_FMC2EN		BIT(31)
+
+/* Register: FMC2_SR */
+#define FMC2_SR_ISOST			GENMASK(1, 0)
+
+/* Register: FMC2_CIDCFGR */
+#define FMC2_CIDCFGR_CFEN		BIT(0)
+#define FMC2_CIDCFGR_SEMEN		BIT(1)
+#define FMC2_CIDCFGR_SCID		GENMASK(6, 4)
+#define FMC2_CIDCFGR_SEMWLC1		BIT(17)
+
+/* Register: FMC2_SEMCR */
+#define FMC2_SEMCR_SEM_MUTEX		BIT(0)
+#define FMC2_SEMCR_SEMCID		GENMASK(6, 4)
+
 #define FMC2_MAX_EBI_CE			4
 #define FMC2_MAX_BANKS			5
+#define FMC2_MAX_RESOURCES		6
+#define FMC2_CID1			1
 
 #define FMC2_BCR_CPSIZE_0		0x0
 #define FMC2_BCR_CPSIZE_128		0x1
@@ -75,6 +103,11 @@
 #define FMC2_BCR_MTYP_PSRAM		0x1
 #define FMC2_BCR_MTYP_NOR		0x2
 
+#define FMC2_BCR_CSCOUNT_0		0x0
+#define FMC2_BCR_CSCOUNT_1		0x1
+#define FMC2_BCR_CSCOUNT_64		0x2
+#define FMC2_BCR_CSCOUNT_256		0x3
+
 #define FMC2_BXTR_EXTMOD_A		0x0
 #define FMC2_BXTR_EXTMOD_B		0x1
 #define FMC2_BXTR_EXTMOD_C		0x2
@@ -89,6 +122,7 @@
 #define FMC2_BTR_CLKDIV_MAX		0xf
 #define FMC2_BTR_DATLAT_MAX		0xf
 #define FMC2_PCSCNTR_CSCOUNT_MAX	0xff
+#define FMC2_CFGR_CLKDIV_MAX		0xf
 
 #define FMC2_NSEC_PER_SEC		1000000000L
 
@@ -104,7 +138,8 @@ enum stm32_fmc2_ebi_register_type {
 	FMC2_REG_BCR = 1,
 	FMC2_REG_BTR,
 	FMC2_REG_BWTR,
-	FMC2_REG_PCSCNTR
+	FMC2_REG_PCSCNTR,
+	FMC2_REG_CFGR
 };
 
 enum stm32_fmc2_ebi_transaction_type {
@@ -135,10 +170,30 @@ enum stm32_fmc2_ebi_cpsize {
 	FMC2_CPSIZE_1024 = 1024
 };
 
+enum stm32_fmc2_ebi_cscount {
+	FMC2_CSCOUNT_0 = 0,
+	FMC2_CSCOUNT_1 = 1,
+	FMC2_CSCOUNT_64 = 64,
+	FMC2_CSCOUNT_256 = 256
+};
+
+struct stm32_fmc2_ebi;
+
+struct stm32_fmc2_ebi_data {
+	const struct stm32_fmc2_prop *child_props;
+	unsigned int nb_child_props;
+	u32 fmc2_enable_reg;
+	u32 fmc2_enable_bit;
+	int (*nwait_used_by_ctrls)(struct stm32_fmc2_ebi *ebi);
+	int (*check_rif)(struct stm32_fmc2_ebi *ebi, u32 resource);
+};
+
 struct stm32_fmc2_ebi {
 	struct clk clk;
 	fdt_addr_t io_base;
+	const struct stm32_fmc2_ebi_data *data;
 	u8 bank_assigned;
+	bool access_granted;
 };
 
 /*
@@ -210,6 +265,28 @@ static int stm32_fmc2_ebi_check_sync_trans(struct stm32_fmc2_ebi *ebi,
 	return -EINVAL;
 }
 
+static int stm32_fmc2_ebi_mp25_check_cclk(struct stm32_fmc2_ebi *ebi,
+					  const struct stm32_fmc2_prop *prop,
+					  int cs)
+{
+	if (!ebi->access_granted)
+		return -EACCES;
+
+	return stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);
+}
+
+static int stm32_fmc2_ebi_mp25_check_clk_period(struct stm32_fmc2_ebi *ebi,
+						const struct stm32_fmc2_prop *prop,
+						int cs)
+{
+	u32 cfgr = readl(ebi->io_base + FMC2_CFGR);
+
+	if (cfgr & FMC2_CFGR_CCLKEN && !ebi->access_granted)
+		return -EACCES;
+
+	return stm32_fmc2_ebi_check_sync_trans(ebi, prop, cs);
+}
+
 static int stm32_fmc2_ebi_check_async_trans(struct stm32_fmc2_ebi *ebi,
 					    const struct stm32_fmc2_prop *prop,
 					    int cs)
@@ -297,6 +374,24 @@ static u32 stm32_fmc2_ebi_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
 	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
 }
 
+static u32 stm32_fmc2_ebi_mp25_ns_to_clk_period(struct stm32_fmc2_ebi *ebi,
+						int cs, u32 setup)
+{
+	u32 nb_clk_cycles = stm32_fmc2_ebi_ns_to_clock_cycles(ebi, cs, setup);
+	u32 cfgr = readl(ebi->io_base + FMC2_CFGR);
+	u32 clk_period;
+
+	if (cfgr & FMC2_CFGR_CCLKEN) {
+		clk_period = FIELD_GET(FMC2_CFGR_CLKDIV, cfgr) + 1;
+	} else {
+		u32 btr = readl(ebi->io_base + FMC2_BTR(cs));
+
+		clk_period = FIELD_GET(FMC2_BTR_CLKDIV, btr) + 1;
+	}
+
+	return DIV_ROUND_UP(nb_clk_cycles, clk_period);
+}
+
 static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 {
 	switch (reg_type) {
@@ -312,6 +407,9 @@ static int stm32_fmc2_ebi_get_reg(int reg_type, int cs, u32 *reg)
 	case FMC2_REG_PCSCNTR:
 		*reg = FMC2_PCSCNTR;
 		break;
+	case FMC2_REG_CFGR:
+		*reg = FMC2_CFGR;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -650,6 +748,26 @@ static int stm32_fmc2_ebi_set_clk_period(struct stm32_fmc2_ebi *ebi,
 	return 0;
 }
 
+static int stm32_fmc2_ebi_mp25_set_clk_period(struct stm32_fmc2_ebi *ebi,
+					      const struct stm32_fmc2_prop *prop,
+					      int cs, u32 setup)
+{
+	u32 cfgr = readl(ebi->io_base + FMC2_CFGR);
+	u32 val;
+
+	if (cfgr & FMC2_CFGR_CCLKEN) {
+		val = setup ? clamp_val(setup - 1, 1, FMC2_CFGR_CLKDIV_MAX) : 1;
+		val = FIELD_PREP(FMC2_CFGR_CLKDIV, val);
+		clrsetbits_le32(ebi->io_base + FMC2_CFGR, FMC2_CFGR_CLKDIV, val);
+	} else {
+		val = setup ? clamp_val(setup - 1, 1, FMC2_BTR_CLKDIV_MAX) : 1;
+		val = FIELD_PREP(FMC2_BTR_CLKDIV, val);
+		clrsetbits_le32(ebi->io_base + FMC2_BTR(cs), FMC2_BTR_CLKDIV, val);
+	}
+
+	return 0;
+}
+
 static int stm32_fmc2_ebi_set_data_latency(struct stm32_fmc2_ebi *ebi,
 					   const struct stm32_fmc2_prop *prop,
 					   int cs, u32 setup)
@@ -690,6 +808,27 @@ static int stm32_fmc2_ebi_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
 	return 0;
 }
 
+static int stm32_fmc2_ebi_mp25_set_max_low_pulse(struct stm32_fmc2_ebi *ebi,
+						 const struct stm32_fmc2_prop *prop,
+						 int cs, u32 setup)
+{
+	u32 val;
+
+	if (setup == FMC2_CSCOUNT_0)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_0);
+	else if (setup == FMC2_CSCOUNT_1)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_1);
+	else if (setup <= FMC2_CSCOUNT_64)
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_64);
+	else
+		val = FIELD_PREP(FMC2_BCR_CSCOUNT, FMC2_BCR_CSCOUNT_256);
+
+	clrsetbits_le32(ebi->io_base + FMC2_BCR(cs),
+			FMC2_BCR_CSCOUNT, val);
+
+	return 0;
+}
+
 static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	/* st,fmc2-ebi-cs-trans-type must be the first property */
 	{
@@ -855,6 +994,235 @@ static const struct stm32_fmc2_prop stm32_fmc2_child_props[] = {
 	},
 };
 
+static const struct stm32_fmc2_prop stm32_fmc2_mp25_child_props[] = {
+	/* st,fmc2-ebi-cs-trans-type must be the first property */
+	{
+		.name = "st,fmc2-ebi-cs-transaction-type",
+		.mprop = true,
+		.set = stm32_fmc2_ebi_set_trans_type,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-cclk-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_CFGR,
+		.reg_mask = FMC2_CFGR_CCLKEN,
+		.check = stm32_fmc2_ebi_mp25_check_cclk,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-mux-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_MUXEN,
+		.check = stm32_fmc2_ebi_check_mux,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-buswidth",
+		.reset_val = FMC2_BUSWIDTH_16,
+		.set = stm32_fmc2_ebi_set_buswidth,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-waitpol-high",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITPOL,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-waitcfg-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITCFG,
+		.check = stm32_fmc2_ebi_check_waitcfg,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-wait-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_WAITEN,
+		.check = stm32_fmc2_ebi_check_sync_trans,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-asyncwait-enable",
+		.bprop = true,
+		.reg_type = FMC2_REG_BCR,
+		.reg_mask = FMC2_BCR_ASYNCWAIT,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.set = stm32_fmc2_ebi_set_bit_field,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-cpsize",
+		.check = stm32_fmc2_ebi_check_cpsize,
+		.set = stm32_fmc2_ebi_set_cpsize,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-byte-lane-setup-ns",
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bl_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-address-setup-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_ADDSET_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-address-hold-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_ADDHLD_MAX,
+		.check = stm32_fmc2_ebi_check_address_hold,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-setup-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_DATAST_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-bus-turnaround-ns",
+		.reg_type = FMC2_REG_BTR,
+		.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bus_turnaround,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-hold-ns",
+		.reg_type = FMC2_REG_BTR,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-clk-period-ns",
+		.reset_val = FMC2_CFGR_CLKDIV_MAX + 1,
+		.check = stm32_fmc2_ebi_mp25_check_clk_period,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_mp25_set_clk_period,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-data-latency-ns",
+		.check = stm32_fmc2_ebi_check_sync_trans,
+		.calculate = stm32_fmc2_ebi_mp25_ns_to_clk_period,
+		.set = stm32_fmc2_ebi_set_data_latency,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-address-setup-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_ADDSET_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-address-hold-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_ADDHLD_MAX,
+		.check = stm32_fmc2_ebi_check_address_hold,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_address_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-data-setup-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_DATAST_MAX,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_setup,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-bus-turnaround-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.reset_val = FMC2_BXTR_BUSTURN_MAX + 1,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_bus_turnaround,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-write-data-hold-ns",
+		.reg_type = FMC2_REG_BWTR,
+		.check = stm32_fmc2_ebi_check_async_trans,
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_set_data_hold,
+	},
+	{
+		.name = "st,fmc2-ebi-cs-max-low-pulse-ns",
+		.calculate = stm32_fmc2_ebi_ns_to_clock_cycles,
+		.set = stm32_fmc2_ebi_mp25_set_max_low_pulse,
+	},
+};
+
+static int stm32_fmc2_ebi_mp25_check_rif(struct stm32_fmc2_ebi *ebi, u32 resource)
+{
+	u32 seccfgr, cidcfgr, semcr;
+	int cid;
+
+	if (resource >= FMC2_MAX_RESOURCES)
+		return -EINVAL;
+
+	seccfgr = readl(ebi->io_base + FMC2_SECCFGR);
+	if (seccfgr & BIT(resource)) {
+		if (resource)
+			log_err("resource %d is configured as secure\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	cidcfgr = readl(ebi->io_base + FMC2_CIDCFGR(resource));
+	if (!(cidcfgr & FMC2_CIDCFGR_CFEN))
+		/* CID filtering is turned off: access granted */
+		return 0;
+
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMEN)) {
+		/* Static CID mode */
+		cid = FIELD_GET(FMC2_CIDCFGR_SCID, cidcfgr);
+		if (cid != FMC2_CID1) {
+			if (resource)
+				log_err("static CID%d set for resource %d\n",
+					cid, resource);
+
+			return -EACCES;
+		}
+
+		return 0;
+	}
+
+	/* Pass-list with semaphore mode */
+	if (!(cidcfgr & FMC2_CIDCFGR_SEMWLC1)) {
+		if (resource)
+			log_err("CID1 is block-listed for resource %d\n",
+				resource);
+
+		return -EACCES;
+	}
+
+	semcr = readl(ebi->io_base + FMC2_SEMCR(resource));
+	if (!(semcr & FMC2_SEMCR_SEM_MUTEX)) {
+		setbits_le32(ebi->io_base + FMC2_SEMCR(resource),
+			     FMC2_SEMCR_SEM_MUTEX);
+		semcr = readl(ebi->io_base + FMC2_SEMCR(resource));
+	}
+
+	cid = FIELD_GET(FMC2_SEMCR_SEMCID, semcr);
+	if (cid != FMC2_CID1) {
+		if (resource)
+			log_err("resource %d is already used by CID%d\n",
+				resource, cid);
+
+		return -EACCES;
+	}
+
+	return 0;
+}
+
 static int stm32_fmc2_ebi_parse_prop(struct stm32_fmc2_ebi *ebi,
 				     ofnode node,
 				     const struct stm32_fmc2_prop *prop,
@@ -916,7 +1284,7 @@ static void stm32_fmc2_ebi_disable_bank(struct stm32_fmc2_ebi *ebi, int cs)
 }
 
 /* NWAIT signal can not be connected to EBI controller and NAND controller */
-static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
+static int stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 {
 	unsigned int cs;
 	u32 bcr;
@@ -927,16 +1295,22 @@ static bool stm32_fmc2_ebi_nwait_used_by_ctrls(struct stm32_fmc2_ebi *ebi)
 
 		bcr = readl(ebi->io_base + FMC2_BCR(cs));
 		if ((bcr & FMC2_BCR_WAITEN || bcr & FMC2_BCR_ASYNCWAIT) &&
-		    ebi->bank_assigned & BIT(FMC2_NAND))
-			return true;
+		    ebi->bank_assigned & BIT(FMC2_NAND)) {
+			log_err("NWAIT signal connected to EBI and NAND controllers\n");
+			return -EINVAL;
+		}
 	}
 
-	return false;
+	return 0;
 }
 
 static void stm32_fmc2_ebi_enable(struct stm32_fmc2_ebi *ebi)
 {
-	setbits_le32(ebi->io_base + FMC2_BCR1, FMC2_BCR1_FMC2EN);
+	if (!ebi->access_granted)
+		return;
+
+	setbits_le32(ebi->io_base + ebi->data->fmc2_enable_reg,
+		     ebi->data->fmc2_enable_bit);
 }
 
 static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
@@ -947,8 +1321,8 @@ static int stm32_fmc2_ebi_setup_cs(struct stm32_fmc2_ebi *ebi,
 
 	stm32_fmc2_ebi_disable_bank(ebi, cs);
 
-	for (i = 0; i < ARRAY_SIZE(stm32_fmc2_child_props); i++) {
-		const struct stm32_fmc2_prop *p = &stm32_fmc2_child_props[i];
+	for (i = 0; i < ebi->data->nb_child_props; i++) {
+		const struct stm32_fmc2_prop *p = &ebi->data->child_props[i];
 
 		ret = stm32_fmc2_ebi_parse_prop(ebi, node, p, cs);
 		if (ret) {
@@ -988,6 +1362,14 @@ static int stm32_fmc2_ebi_parse_dt(struct udevice *dev,
 			return -EINVAL;
 		}
 
+		if (ebi->data->check_rif) {
+			ret = ebi->data->check_rif(ebi, bank + 1);
+			if (ret) {
+				dev_err(dev, "bank access failed: %d\n", bank);
+				return ret;
+			}
+		}
+
 		if (bank < FMC2_MAX_EBI_CE) {
 			ret = stm32_fmc2_ebi_setup_cs(ebi, child, bank);
 			if (ret) {
@@ -1005,9 +1387,10 @@ static int stm32_fmc2_ebi_parse_dt(struct udevice *dev,
 		return -ENODEV;
 	}
 
-	if (stm32_fmc2_ebi_nwait_used_by_ctrls(ebi)) {
-		dev_err(dev, "NWAIT signal connected to EBI and NAND controllers\n");
-		return -EINVAL;
+	if (ebi->data->nwait_used_by_ctrls) {
+		ret = ebi->data->nwait_used_by_ctrls(ebi);
+		if (ret)
+			return ret;
 	}
 
 	stm32_fmc2_ebi_enable(ebi);
@@ -1021,6 +1404,10 @@ static int stm32_fmc2_ebi_probe(struct udevice *dev)
 	struct reset_ctl reset;
 	int ret;
 
+	ebi->data = (void *)dev_get_driver_data(dev);
+	if (!ebi->data)
+		return -EINVAL;
+
 	ebi->io_base = dev_read_addr(dev);
 	if (ebi->io_base == FDT_ADDR_T_NONE)
 		return -EINVAL;
@@ -1040,11 +1427,49 @@ static int stm32_fmc2_ebi_probe(struct udevice *dev)
 		reset_deassert(&reset);
 	}
 
+	/* Check if CFGR register can be modified */
+	ebi->access_granted = true;
+	if (ebi->data->check_rif) {
+		ret = ebi->data->check_rif(ebi, 0);
+		if (ret) {
+			ebi->access_granted = false;
+
+			/* In case of CFGR is secure, just check that the FMC2 is enabled */
+			if (readl(ebi->io_base + FMC2_SR) & FMC2_SR_ISOST) {
+				dev_err(dev, "FMC2 is not ready to be used.\n");
+				return -EACCES;
+			}
+		}
+	}
+
 	return stm32_fmc2_ebi_parse_dt(dev, ebi);
 }
 
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp1_data = {
+	.child_props = stm32_fmc2_child_props,
+	.nb_child_props = ARRAY_SIZE(stm32_fmc2_child_props),
+	.fmc2_enable_reg = FMC2_BCR1,
+	.fmc2_enable_bit = FMC2_BCR1_FMC2EN,
+	.nwait_used_by_ctrls = stm32_fmc2_ebi_nwait_used_by_ctrls,
+};
+
+static const struct stm32_fmc2_ebi_data stm32_fmc2_ebi_mp25_data = {
+	.child_props = stm32_fmc2_mp25_child_props,
+	.nb_child_props = ARRAY_SIZE(stm32_fmc2_mp25_child_props),
+	.fmc2_enable_reg = FMC2_CFGR,
+	.fmc2_enable_bit = FMC2_CFGR_FMC2EN,
+	.check_rif = stm32_fmc2_ebi_mp25_check_rif,
+};
+
 static const struct udevice_id stm32_fmc2_ebi_match[] = {
-	{.compatible = "st,stm32mp1-fmc2-ebi"},
+	{
+		.compatible = "st,stm32mp1-fmc2-ebi",
+		.data = (ulong)&stm32_fmc2_ebi_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-ebi",
+		.data = (ulong)&stm32_fmc2_ebi_mp25_data,
+	},
 	{ /* Sentinel */ }
 };
 
diff --git a/drivers/memory/stm32-omi.c b/drivers/memory/stm32-omi.c
new file mode 100644
index 0000000000..a8a210d739
--- /dev/null
+++ b/drivers/memory/stm32-omi.c
@@ -0,0 +1,523 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <misc.h>
+#include <regmap.h>
+#include <stm32_omi.h>
+#include <syscon.h>
+#include <watchdog.h>
+#include <dm/of_access.h>
+#include <dm/device-internal.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <dm/read.h>
+#include <linux/bitfield.h>
+#include <linux/ioport.h>
+
+static int stm32_omi_dlyb_set_tap(struct udevice *dev, u8 tap, bool rx_tap)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	u32 sr, mask, ack;
+	int ret;
+	u8 shift;
+
+	if (!omi_plat->regmap || !omi_plat->dlyb_base)
+		return -EINVAL;
+
+	if (rx_tap) {
+		mask = DLYBOS_CR_RXTAPSEL_MASK;
+		shift = DLYBOS_CR_RXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_RXTAPSEL_ACK;
+	} else {
+		mask = DLYBOS_CR_TXTAPSEL_MASK;
+		shift = DLYBOS_CR_TXTAPSEL_SHIFT;
+		ack = DLYBOS_SR_TXTAPSEL_ACK;
+	}
+
+	regmap_update_bits(omi_plat->regmap,
+			   omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+			   mask, mask & (tap << shift));
+
+	ret = regmap_read_poll_timeout(omi_plat->regmap,
+				       omi_plat->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & ack, 1,
+				       STM32_DLYBOS_TIMEOUT_MS);
+	if (ret)
+		dev_err(dev, "%s delay block phase configuration timeout\n",
+			rx_tap ? "RX" : "TX");
+
+	return ret;
+}
+
+int stm32_omi_dlyb_find_tap(struct udevice *dev, bool rx_only, u8 *window_len)
+{
+	struct stm32_omi_priv *omi_priv = dev_get_priv(dev);
+	struct stm32_tap_window rx_tap_w[DLYBOS_TAPSEL_NB];
+	int ret;
+	u8 rx_len, rx_window_len, rx_window_end;
+	u8 tx_len, tx_window_len, tx_window_end;
+	u8 rx_tap, tx_tap, tx_tap_max, tx_tap_min, best_tx_tap = 0;
+	u8 score, score_max;
+
+	tx_len = 0;
+	tx_window_len = 0;
+	tx_window_end = 0;
+	omi_priv->is_calibrating = true;
+
+	for (tx_tap = 0;
+	     tx_tap < (rx_only ? 1 : DLYBOS_TAPSEL_NB);
+	     tx_tap++) {
+		ret = stm32_omi_dlyb_set_tap(dev, tx_tap, false);
+		if (ret)
+			return ret;
+
+		rx_len = 0;
+		rx_window_len = 0;
+		rx_window_end = 0;
+
+		for (rx_tap = 0; rx_tap < DLYBOS_TAPSEL_NB; rx_tap++) {
+			ret = stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+			if (ret)
+				return ret;
+
+			ret = omi_priv->check_transfer(dev);
+			if (ret) {
+				if ((!rx_only && ret == -ETIMEDOUT) ||
+				    ret == -EOPNOTSUPP)
+					break;
+
+				rx_len = 0;
+			} else {
+				rx_len++;
+				if (rx_len > rx_window_len) {
+					rx_window_len = rx_len;
+					rx_window_end = rx_tap;
+				}
+			}
+		}
+
+		if (ret == -EOPNOTSUPP)
+			break;
+
+		rx_tap_w[tx_tap].end = rx_window_end;
+		rx_tap_w[tx_tap].length = rx_window_len;
+
+		if (!rx_window_len) {
+			tx_len = 0;
+		} else {
+			tx_len++;
+			if (tx_len > tx_window_len) {
+				tx_window_len = tx_len;
+				tx_window_end = tx_tap;
+			}
+		}
+
+		dev_dbg(dev, "rx_tap_w[%02d].end = %d rx_tap_w[%02d].length = %d\n",
+			tx_tap, rx_tap_w[tx_tap].end, tx_tap, rx_tap_w[tx_tap].length);
+	}
+
+	omi_priv->is_calibrating = false;
+
+	if (ret == -EOPNOTSUPP) {
+		dev_err(dev, "Calibration can not be done on this device\n");
+		return ret;
+	}
+
+	if (rx_only) {
+		if (!rx_window_len) {
+			dev_err(dev, "Can't find RX phase settings\n");
+			return -EIO;
+		}
+
+		rx_tap = rx_window_end - rx_window_len / 2;
+		*window_len = rx_window_len;
+		dev_dbg(dev, "RX_TAP_SEL set to %d\n", rx_tap);
+
+		return stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+	}
+
+	if (!tx_window_len) {
+		dev_err(dev, "Can't find TX phase settings\n");
+		return -EIO;
+	}
+
+	/* find the best duet TX/RX TAP */
+	tx_tap_min = tx_window_end - tx_window_len + 1;
+	tx_tap_max = tx_window_end;
+	score_max = 0;
+	for (tx_tap = tx_tap_min; tx_tap <= tx_tap_max; tx_tap++) {
+		score = min_t(u8, tx_tap - tx_tap_min, tx_tap_max - tx_tap) +
+			rx_tap_w[tx_tap].length;
+		if (score > score_max) {
+			score_max = score;
+			best_tx_tap = tx_tap;
+		}
+	}
+
+	rx_tap = rx_tap_w[best_tx_tap].end - rx_tap_w[best_tx_tap].length / 2;
+
+	dev_dbg(dev, "RX_TAP_SEL set to %d\n", rx_tap);
+	ret = stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+	if (ret)
+		return ret;
+
+	dev_dbg(dev, "TX_TAP_SEL set to %d\n", best_tx_tap);
+
+	return stm32_omi_dlyb_set_tap(dev, best_tx_tap, false);
+}
+
+int stm32_omi_dlyb_set_cr(struct udevice *dev, u32 dlyb_cr)
+{
+	bool bypass_mode = false;
+	int ret;
+	u16 period_ps;
+	u8 rx_tap, tx_tap;
+
+	period_ps = FIELD_GET(DLYBOS_BYP_CMD_MASK, dlyb_cr);
+	if (dlyb_cr & DLYBOS_BYP_EN)
+		bypass_mode = true;
+
+	ret = stm32_omi_dlyb_configure(dev, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	/* restore Rx and TX tap */
+	rx_tap = FIELD_GET(DLYBOS_CR_RXTAPSEL_MASK, dlyb_cr);
+	ret = stm32_omi_dlyb_set_tap(dev, rx_tap, true);
+	if (ret)
+		return ret;
+
+	tx_tap = FIELD_GET(DLYBOS_CR_TXTAPSEL_MASK, dlyb_cr);
+	return stm32_omi_dlyb_set_tap(dev, tx_tap, false);
+}
+
+void stm32_omi_dlyb_get_cr(struct udevice *dev, u32 *dlyb_cr)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+
+	regmap_read(omi_plat->regmap, omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+		    dlyb_cr);
+}
+
+/* ½ memory clock period in pico second */
+static const u16 dlybos_delay_ps[STM32_DLYBOS_DELAY_NB] = {
+2816, 4672, 6272, 7872, 9472, 11104, 12704, 14304, 15904, 17536, 19136, 20736,
+22336, 23968, 25568, 27168, 28768, 30400, 32000, 33600, 35232, 36832, 38432, 40032
+};
+
+static u32 stm32_omi_find_byp_cmd(u16 period_ps)
+{
+	u16 half_period_ps = period_ps / 2;
+	u8 max = STM32_DLYBOS_DELAY_NB - 1;
+	u8 i, min = 0;
+
+	/* find closest value in dlybos_delay_ps[] with half_period_ps*/
+	if (half_period_ps < dlybos_delay_ps[0])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, 1);
+
+	if (half_period_ps > dlybos_delay_ps[max])
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, STM32_DLYBOS_DELAY_NB);
+
+	while (max - min > 1) {
+		i = DIV_ROUND_UP(min + max, 2);
+		if (half_period_ps > dlybos_delay_ps[i])
+			min = i;
+		else
+			max = i;
+	}
+
+	if ((dlybos_delay_ps[max] - half_period_ps) >
+	    (half_period_ps - dlybos_delay_ps[min]))
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, min + 1);
+	else
+		return FIELD_PREP(DLYBOS_BYP_CMD_MASK, max + 1);
+}
+
+void stm32_omi_dlyb_stop(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+
+	/* disable delay block */
+	regmap_write(omi_plat->regmap,
+		     omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+		     0x0);
+}
+
+int stm32_omi_dlyb_configure(struct udevice *dev,
+			     bool bypass_mode, u16 period_ps)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	u32 sr, mask, val;
+	int ret;
+
+	if (!omi_plat->regmap || !omi_plat->dlyb_base)
+		return -EINVAL;
+
+	if (bypass_mode) {
+		val = DLYBOS_BYP_EN | stm32_omi_find_byp_cmd(period_ps);
+		mask = DLYBOS_BYP_EN | DLYBOS_BYP_CMD_MASK;
+	} else {
+		val = DLYBOS_CR_EN;
+		mask = DLYBOS_CR_EN;
+	}
+
+	regmap_update_bits(omi_plat->regmap,
+			  omi_plat->dlyb_base + SYSCFG_DLYBOS_CR,
+			  mask, val);
+
+	if (bypass_mode)
+		return 0;
+
+	/* in lock mode, wait for lock status bit */
+	ret = regmap_read_poll_timeout(omi_plat->regmap,
+				       omi_plat->dlyb_base + SYSCFG_DLYBOS_SR,
+				       sr, sr & DLYBOS_SR_LOCK, 1,
+				       STM32_DLYBOS_TIMEOUT_MS);
+	if (ret) {
+		dev_err(dev, "Delay Block lock timeout\n");
+		stm32_omi_dlyb_stop(dev);
+	}
+
+	return ret;
+}
+
+static void stm32_omi_read_fifo(u8 *val, phys_addr_t addr)
+{
+	*val = readb(addr);
+	WATCHDOG_RESET();
+}
+
+static void stm32_omi_write_fifo(u8 *val, phys_addr_t addr)
+{
+	writeb(*val, addr);
+}
+
+int stm32_omi_tx_poll(struct udevice *dev, u8 *buf, u32 len, bool read)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	struct stm32_omi_priv *omi_priv = dev_get_priv(dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	void (*fifo)(u8 *val, phys_addr_t addr);
+	u32 sr;
+	int ret;
+
+	if (read)
+		fifo = stm32_omi_read_fifo;
+	else
+		fifo = stm32_omi_write_fifo;
+
+	while (len--) {
+		ret = readl_poll_timeout(regs_base + OSPI_SR, sr,
+					 sr & OSPI_SR_FTF,
+					 OSPI_FIFO_TIMEOUT_US);
+		if (ret) {
+			if (!omi_priv->is_calibrating)
+				dev_err(dev, "fifo timeout (len:%d stat:%#x)\n",
+					len, sr);
+			return ret;
+		}
+
+		fifo(buf++, regs_base + OSPI_DR);
+	}
+
+	return 0;
+}
+
+int stm32_omi_wait_for_not_busy(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 sr;
+	int ret;
+
+	ret = readl_poll_timeout(regs_base + OSPI_SR, sr, !(sr & OSPI_SR_BUSY),
+				 OSPI_BUSY_TIMEOUT_US);
+	if (ret)
+		dev_err(dev, "busy timeout (stat:%#x)\n", sr);
+
+	return ret;
+}
+
+int stm32_omi_wait_cmd(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 sr;
+	int ret = 0;
+
+	ret = readl_poll_timeout(regs_base + OSPI_SR, sr,
+				 sr & OSPI_SR_TCF,
+				 OSPI_CMD_TIMEOUT_US);
+	if (ret) {
+		dev_err(dev, "cmd timeout (stat:%#x)\n", sr);
+	} else if (readl(regs_base + OSPI_SR) & OSPI_SR_TEF) {
+		dev_err(dev, "transfer error (stat:%#x)\n", sr);
+		ret = -EIO;
+	}
+
+	/* clear flags */
+	writel(OSPI_FCR_CTCF | OSPI_FCR_CTEF, regs_base + OSPI_FCR);
+
+	if (!ret)
+		ret = stm32_omi_wait_for_not_busy(dev);
+
+	return ret;
+}
+
+static int stm32_omi_bind(struct udevice *dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(dev);
+	struct driver *drv;
+	const char *name;
+	ofnode flash_node;
+	u8 hyperflash_count = 0;
+	u8 spi_flash_count = 0;
+	u8 child_count = 0;
+
+	/*
+	 * Flash subnodes sanity check:
+	 *        2 spi-nand/spi-nor flashes			=> supported
+	 *        1 HyperFlash					=> supported
+	 *	  All other flash node configuration		=> not supported
+	 */
+	omi_plat->jedec_flash = false;
+
+	dev_for_each_subnode(flash_node, dev) {
+		if (ofnode_device_is_compatible(flash_node, "cfi-flash"))
+			hyperflash_count++;
+
+		if (ofnode_device_is_compatible(flash_node, "jedec-flash")) {
+			hyperflash_count++;
+			omi_plat->jedec_flash = true;
+		}
+
+		if (ofnode_device_is_compatible(flash_node, "jedec,spi-nor") ||
+		    ofnode_device_is_compatible(flash_node, "spi-nand"))
+			spi_flash_count++;
+
+		child_count++;
+	}
+
+	if (!child_count) {
+		dev_err(dev, "Missing flash node\n");
+		return -ENODEV;
+	}
+
+	if ((!hyperflash_count && !spi_flash_count) ||
+	    child_count != (hyperflash_count + spi_flash_count)) {
+		dev_warn(dev, "Unknown flash type\n");
+		return -ENODEV;
+	}
+
+	if ((hyperflash_count && spi_flash_count) ||
+	    hyperflash_count > 1) {
+		dev_err(dev, "Flash node configuration not supported\n");
+		return -EINVAL;
+	}
+
+	if (spi_flash_count)
+		name = "stm32_ospi";
+	else
+		name = "stm32_hyperbus";
+
+	drv = lists_driver_lookup_name(name);
+	if (!drv) {
+		dev_err(dev, "Cannot find driver '%s'\n", name);
+		return -ENOENT;
+	}
+
+	return device_bind(dev, drv, dev_read_name(dev), NULL, dev_ofnode(dev), NULL);
+}
+
+static int stm32_omi_of_to_plat(struct udevice *dev)
+{
+	struct stm32_omi_plat *plat = dev_get_plat(dev);
+	struct resource res;
+	struct ofnode_phandle_args args;
+	const fdt32_t *reg;
+	int ret, len;
+
+	reg = dev_read_prop(dev, "reg", &len);
+	if (!reg) {
+		dev_err(dev, "Can't get regs base address\n");
+		return -ENOENT;
+	}
+
+	plat->regs_base = (phys_addr_t)dev_translate_address(dev, reg);
+
+	/* optional */
+	ret = dev_read_phandle_with_args(dev, "memory-region", NULL, 0, 0, &args);
+	if (!ret) {
+		ret = ofnode_read_resource(args.node, 0, &res);
+		if (ret) {
+			dev_err(dev, "Can't get mmap base address(%d)\n", ret);
+			return ret;
+		}
+
+		plat->mm_base = res.start;
+		plat->mm_size = resource_size(&res);
+
+		if (plat->mm_size > OSPI_MAX_MMAP_SZ) {
+			dev_err(dev, "Incorrect memory-map size: %lld Bytes\n", plat->mm_size);
+			return -EINVAL;
+		}
+
+		dev_dbg(dev, "%s: regs_base=<0x%llx> mm_base=<0x%llx> mm_size=<0x%x>\n",
+			__func__, plat->regs_base, plat->mm_base, (u32)plat->mm_size);
+	} else {
+		plat->mm_base = 0;
+		plat->mm_size = 0;
+		dev_info(dev, "memory-region property not found (%d)\n", ret);
+	}
+
+	ret = clk_get_by_index(dev, 0, &plat->clk);
+	if (ret < 0) {
+		dev_err(dev, "Failed to get clock\n");
+		return ret;
+	}
+
+	ret = reset_get_bulk(dev, &plat->rst_ctl);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Failed to get reset\n");
+		clk_free(&plat->clk);
+		return ret;
+	}
+
+	plat->clock_rate = clk_get_rate(&plat->clk);
+	if (!plat->clock_rate) {
+		clk_free(&plat->clk);
+		return -EINVAL;
+	}
+
+	plat->regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg-dlyb");
+	if (IS_ERR(plat->regmap)) {
+		dev_err(dev, "Can't find st,syscfg-dlyb property\n");
+		ret = PTR_ERR(plat->regmap);
+	} else {
+		ret = dev_read_u32_index(dev, "st,syscfg-dlyb", 1, &plat->dlyb_base);
+		if (ret)
+			dev_err(dev, "Can't read delay block base address\n");
+	}
+
+	return ret;
+};
+
+static const struct udevice_id stm32_omi_ids[] = {
+	{.compatible = "st,stm32mp25-omi" },
+	{ }
+};
+
+U_BOOT_DRIVER(stm32_omi) = {
+	.name		= "stm32-omi",
+	.id		= UCLASS_NOP,
+	.of_match	= stm32_omi_ids,
+	.of_to_plat	= stm32_omi_of_to_plat,
+	.plat_auto	= sizeof(struct stm32_omi_plat),
+	.priv_auto	= sizeof(struct stm32_omi_priv),
+	.bind		= stm32_omi_bind,
+};
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index a6da6e215d..a9fc0cf2c2 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -438,6 +438,23 @@ config STM32MP_FUSE
 	  for STM32MP architecture.
 	  This API is needed for CMD_FUSE.
 
+config STM32_OMM
+	bool "Enable Octo Memory Manager (OMM) driver for the STM32MP2 SoC's family"
+	depends on STM32MP25X && MISC
+	help
+	  This driver manages the muxing between the 2 OSPI busses and
+	  the 2 output ports. There are 4 possible muxing configurations:
+	  - direct mode (no multiplexing): OSPI1 output is on port 1 and OSPI2
+	       output is on port 2
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 1
+	  - swapped mode (no multiplexing), OSPI1 output is on port 2,
+	       OSPI2 output is on port 1
+	  - OSPI1 and OSPI2 are multiplexed over the same output port 2
+	  It also manages :
+	    - the split of the memory area shared between the 2 OSPI instances.
+	    - chip select selection override.
+	    - the time between 2 transactions in multiplexed mode.
+
 config STM32_RCC
 	bool "Enable RCC driver for the STM32 SoC's family"
 	depends on (ARCH_STM32 || ARCH_STM32MP) && MISC
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index d494639cd9..5cddb99a69 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -75,6 +75,7 @@ obj-$(CONFIG_SIFIVE_OTP) += sifive-otp.o
 obj-$(CONFIG_SMSC_LPC47M) += smsc_lpc47m.o
 obj-$(CONFIG_SMSC_SIO1007) += smsc_sio1007.o
 obj-$(CONFIG_STM32MP_FUSE) += stm32mp_fuse.o
+obj-$(CONFIG_STM32_OMM) += stm32_omm.o
 obj-$(CONFIG_STM32_RCC) += stm32_rcc.o
 obj-$(CONFIG_SYS_DPAA_QBMAN) += fsl_portals.o
 obj-$(CONFIG_TEGRA186_BPMP) += tegra186_bpmp.o
diff --git a/drivers/misc/stm32_omm.c b/drivers/misc/stm32_omm.c
new file mode 100644
index 0000000000..0d4f618ca4
--- /dev/null
+++ b/drivers/misc/stm32_omm.c
@@ -0,0 +1,428 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <regmap.h>
+#include <stm32_omi.h>
+#include <syscon.h>
+#include <dm/device_compat.h>
+#include <dm/device-internal.h>
+#include <dm/lists.h>
+#include <dm/of_addr.h>
+#include <dm/of_access.h>
+#include <linux/bitfield.h>
+#include <linux/ioport.h>
+#include <mach/rif.h>
+
+#define OCTOSPIM_CR		0
+#define CR_MUXEN		BIT(0)
+#define CR_MUXENMODE_MASK	GENMASK(1, 0)
+#define CR_CSSEL_OVR_EN		BIT(4)
+#define CR_CSSEL_OVR_MASK	GENMASK(6, 5)
+#define CR_REQ2ACK_MASK		GENMASK(23, 16)
+
+#define OMM_CHILD_NB		2
+
+#define NSEC_PER_SEC		1000000000L
+
+struct stm32_omm_plat {
+	struct regmap *omm_regmap;
+	struct regmap *syscfg_regmap;
+	struct clk clk;
+	struct reset_ctl reset_ctl;
+	resource_size_t mm_ospi2_size;
+	u32 mux;
+	u32 cssel_ovr;
+	u32 req2ack;
+	u32 amcr_base;
+	u32 amcr_mask;
+	unsigned long clk_rate_max;
+};
+
+static int stm32_omm_set_amcr(struct udevice *dev, bool set)
+{
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	unsigned int amcr, read_amcr;
+
+	amcr = plat->mm_ospi2_size / SZ_64M;
+
+	if (set)
+		regmap_update_bits(plat->syscfg_regmap, plat->amcr_base,
+				   plat->amcr_mask, amcr);
+
+	/* read AMCR and check coherency with memory-map areas defined in DT */
+	regmap_read(plat->syscfg_regmap, plat->amcr_base, &read_amcr);
+	read_amcr = read_amcr >> (ffs(plat->amcr_mask) - 1);
+
+	if (amcr != read_amcr) {
+		dev_err(dev, "AMCR value not coherent with DT memory-map areas\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32_omm_configure(struct udevice *dev)
+{
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	int ret;
+	u32 mux = 0;
+	u32 cssel_ovr = 0;
+	u32 req2ack = 0;
+
+	ret = clk_enable(&plat->clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable OMM clock (%d)\n", ret);
+		return ret;
+	}
+
+	reset_assert(&plat->reset_ctl);
+	udelay(2);
+	reset_deassert(&plat->reset_ctl);
+
+	if (plat->mux & CR_MUXEN) {
+		if (!plat->req2ack) {
+			req2ack = DIV_ROUND_UP(plat->req2ack,
+					       NSEC_PER_SEC / plat->clk_rate_max) - 1;
+			if (req2ack > 256)
+				req2ack = 256;
+		}
+
+		req2ack = FIELD_PREP(CR_REQ2ACK_MASK, req2ack);
+		regmap_update_bits(plat->omm_regmap, OCTOSPIM_CR,
+					 CR_REQ2ACK_MASK, req2ack);
+	}
+
+	if (plat->cssel_ovr != 0xff) {
+		cssel_ovr = FIELD_PREP(CR_CSSEL_OVR_MASK, cssel_ovr);
+		cssel_ovr |= CR_CSSEL_OVR_EN;
+		regmap_update_bits(plat->omm_regmap, OCTOSPIM_CR,
+				   CR_CSSEL_OVR_MASK, cssel_ovr);
+	}
+
+	mux = FIELD_PREP(CR_MUXENMODE_MASK, plat->mux);
+	regmap_update_bits(plat->omm_regmap, OCTOSPIM_CR,
+			   CR_MUXENMODE_MASK, mux);
+
+	clk_disable(&plat->clk);
+
+	return stm32_omm_set_amcr(dev, true);
+}
+
+static int stm32_omm_disable_child(struct udevice *dev, ofnode child)
+{
+	struct regmap *omi_regmap;
+	struct clk omi_clk;
+	int ret;
+
+	ret = regmap_init_mem(child, &omi_regmap);
+	if (ret) {
+		dev_err(dev, "Regmap failed for node %s\n", ofnode_get_name(child));
+		return ret;
+	}
+
+	/* retrieve OMI clk */
+	ret = clk_get_by_index_nodev(child, 0, &omi_clk);
+	if (ret) {
+		dev_err(dev, "Failed to get clock for %s\n", ofnode_get_name(child));
+		return ret;
+	}
+
+	ret = clk_enable(&omi_clk);
+	if (ret) {
+		dev_err(dev, "Failed to enable clock for %s\n", ofnode_get_name(child));
+		goto clk_free;
+	}
+
+	regmap_update_bits(omi_regmap, OSPI_CR, OSPI_CR_EN, 0);
+
+	clk_disable(&omi_clk);
+clk_free:
+	clk_free(&omi_clk);
+
+	return ret;
+}
+
+static int stm32_omm_enable_child_clock(struct udevice *dev, ofnode child)
+{
+	struct clk omi_clk;
+	int ret;
+
+	ret = clk_get_by_index_nodev(child, 0, &omi_clk);
+	if (ret) {
+		dev_err(dev, "Failed to get clock for %s\n", ofnode_get_name(child));
+		return ret;
+	}
+
+	ret = clk_enable(&omi_clk);
+	if (ret)
+		dev_err(dev, "Failed to enable clock for %s\n", ofnode_get_name(child));
+
+	clk_free(&omi_clk);
+
+	return ret;
+}
+
+static int stm32_omm_probe(struct udevice *dev) {
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	ofnode child_list[OMM_CHILD_NB];
+	ofnode child;
+	int ret;
+	u8 nb_child = 0;
+	u8 child_access_granted = 0;
+	u8 i;
+	bool child_access[OMM_CHILD_NB];
+
+	/* check child's access */
+	for (child = ofnode_first_subnode(dev_ofnode(dev));
+	     ofnode_valid(child);
+	     child = ofnode_next_subnode(child)) {
+
+		if (nb_child > OMM_CHILD_NB) {
+			dev_err(dev, "Bad DT, found too much children\n");
+			return -E2BIG;
+		}
+
+		if (!ofnode_device_is_compatible(child, "st,stm32mp25-omi"))
+			return -EINVAL;
+
+		ret = stm32_rifsc_check_access(child);
+		if (ret < 0 && ret != -EACCES)
+			return ret;
+
+		child_access[nb_child] = false;
+		if (!ret) {
+			child_access_granted++;
+			child_access[nb_child] = true;
+		}
+
+		child_list[nb_child] = child;
+		nb_child++;
+	}
+
+	if (nb_child != OMM_CHILD_NB)
+		return -EINVAL;
+
+	/* check if OMM's ressource access is granted */
+	ret = stm32_rifsc_check_access(dev_ofnode(dev));
+	if (ret < 0 && ret != -EACCES)
+		return ret;
+
+	/* All child's access are granted ? */
+	if (!ret && child_access_granted == nb_child) {
+		/* Ensure both OSPI instance are disabled before configuring OMM */
+		for (i = 0; i < nb_child; i++) {
+			ret = stm32_omm_disable_child(dev, child_list[i]);
+			if (ret)
+				return ret;
+		}
+
+		ret = stm32_omm_configure(dev);
+		if (ret)
+			return ret;
+
+		if (plat->mux & CR_MUXEN) {
+			/*
+			 * If the mux is enabled, the 2 OSPI clocks have to be
+			 * always enabled
+			 */
+
+			for (i = 0; i < nb_child; i++) {
+				ret = stm32_omm_enable_child_clock(dev, child_list[i]);
+				if (ret)
+					return ret;
+			}
+		}
+	} else {
+		dev_dbg(dev, "Octo Memory Manager resource's access not granted\n");
+		/*
+		 * AMCR can't be set, so check if current value is coherent
+		 * with memory-map areas defined in DT
+		 */
+		ret = stm32_omm_set_amcr(dev, false);
+	}
+
+	return ret;
+}
+
+static int stm32_omm_of_to_plat(struct udevice *dev)
+{
+	struct stm32_omm_plat *plat = dev_get_plat(dev);
+	static const char *mm_name[] = { "mm_ospi1", "mm_ospi2" };
+	struct resource res, res1, mm_res;
+	struct ofnode_phandle_args args;
+	struct udevice *child;
+	unsigned long clk_rate;
+	struct clk child_clk;
+	u32 mm_size = 0;
+	int ret, idx;
+	u8 i;
+
+	ret = regmap_init_mem(dev_ofnode(dev), &plat->omm_regmap);
+	if (ret) {
+		dev_err(dev, "I/O manager regmap failed\n");
+		return ret;
+	}
+
+	ret = dev_read_resource_byname(dev, "omm_mm", &mm_res);
+	if (ret) {
+		dev_err(dev, "can't get omm_mm mmap resource(ret = %d)!\n", ret);
+		return ret;
+	}
+
+	ret = reset_get_by_index(dev, 0, &plat->reset_ctl);
+	if (ret)
+		return ret;
+
+	ret = clk_get_by_index(dev, 0, &plat->clk);
+	if (ret < 0) {
+		dev_err(dev, "Can't find I/O manager clock\n");
+		return ret;
+	}
+
+	/* parse children's clock */
+	plat->clk_rate_max = 0;
+	device_foreach_child(child, dev) {
+		ret = clk_get_by_index(child, 0, &child_clk);
+		if (ret) {
+			dev_err(dev, "Failed to get clock for %s\n",
+				dev_read_name(child));
+			return ret;
+		}
+
+		clk_rate = clk_get_rate(&child_clk);
+		clk_free(&child_clk);
+		if (!clk_rate) {
+			dev_err(dev, "Invalid clock rate\n");
+			return -EINVAL;
+		}
+
+		if (clk_rate > plat->clk_rate_max)
+			plat->clk_rate_max = clk_rate;
+	}
+
+	plat->mux = dev_read_u32_default(dev, "st,omm-mux", 0);
+	plat->req2ack = dev_read_u32_default(dev, "st,omm-req2ack-ns", 0);
+	plat->cssel_ovr = dev_read_u32_default(dev, "st,omm-cssel-ovr", 0xff);
+	plat->mm_ospi2_size = 0;
+
+	for (i = 0; i < 2; i++) {
+		idx = dev_read_stringlist_search(dev, "memory-region-names",
+						 mm_name[i]);
+		if (idx < 0)
+			continue;
+
+		/* res1 only used on second loop iteration */
+		res1.start = res.start;
+		res1.end = res.end;
+
+		dev_read_phandle_with_args(dev, "memory-region", NULL, 0, idx,
+					   &args);
+		ret = ofnode_read_resource(args.node, 0, &res);
+		if (ret) {
+			dev_err(dev, "unable to resolve memory region\n");
+			goto clk_free;
+		}
+
+		/* check that memory region fits inside OMM memory map area */
+		if (!resource_contains(&mm_res, &res)) {
+			dev_err(dev, "%s doesn't fit inside OMM memory map area\n",
+				mm_name[i]);
+			dev_err(dev, "[0x%llx-0x%llx] doesn't fit inside [0x%llx-0x%llx]\n",
+				res.start, res.end,
+				mm_res.start, mm_res.end);
+
+			return -EFAULT;
+		}
+
+		if (i == 1) {
+			plat->mm_ospi2_size = resource_size(&res);
+
+			/* check that OMM memory region 1 doesn't overlap memory region 2 */
+			if (resource_overlaps(&res, &res1)) {
+				dev_err(dev, "OMM memory-region %s overlaps memory region %s\n",
+					mm_name[0], mm_name[1]);
+				dev_err(dev, "[0x%llx-0x%llx] overlaps [0x%llx-0x%llx]\n",
+					res1.start, res1.end, res.start, res.end);
+
+				return -EFAULT;
+			}
+		}
+
+		mm_size += resource_size(&res);
+	}
+
+	plat->syscfg_regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg-amcr");
+	if (IS_ERR(plat->syscfg_regmap)) {
+		dev_err(dev, "Failed to get st,syscfg-amcr property\n");
+		ret = PTR_ERR(plat->syscfg_regmap);
+		goto clk_free;
+	}
+
+	ret = dev_read_u32_index(dev, "st,syscfg-amcr", 1, &plat->amcr_base);
+	if (ret) {
+		dev_err(dev, "Failed to get st,syscfg-amcr base\n");
+		goto clk_free;
+	}
+
+	ret = dev_read_u32_index(dev, "st,syscfg-amcr", 2, &plat->amcr_mask);
+	if (ret) {
+		dev_err(dev, "Failed to get st,syscfg-amcr mask\n");
+		goto clk_free;
+	}
+
+	return 0;
+
+clk_free:
+	clk_free(&plat->clk);
+
+	return ret;
+};
+
+static int stm32_omm_bind(struct udevice *dev)
+{
+	int ret = 0, err = 0;
+	ofnode node;
+
+	for (node = ofnode_first_subnode(dev_ofnode(dev));
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node) || stm32_rifsc_check_access(node)) {
+			dev_dbg(dev, "%s failed to bind\n", node_name);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err && !ret) {
+			ret = err;
+			dev_dbg(dev, "%s: ret=%d\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_dbg(dev, "Some drivers failed to bind\n");
+
+	return ret;
+}
+
+static const struct udevice_id stm32_omm_ids[] = {
+	{ .compatible = "st,stm32mp25-omm", },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_omm) = {
+	.name		= "stm32_omm",
+	.id		= UCLASS_NOP,
+	.probe		= stm32_omm_probe,
+	.of_match	= stm32_omm_ids,
+	.of_to_plat	= stm32_omm_of_to_plat,
+	.plat_auto	= sizeof(struct stm32_omm_plat),
+	.bind		= stm32_omm_bind,
+};
diff --git a/drivers/misc/stm32_rcc.c b/drivers/misc/stm32_rcc.c
index c1e5428a6b..5b89afe409 100644
--- a/drivers/misc/stm32_rcc.c
+++ b/drivers/misc/stm32_rcc.c
@@ -44,6 +44,10 @@ struct stm32_rcc_clk stm32_rcc_clk_mp13 = {
 	.soc = STM32MP1,
 };
 
+struct stm32_rcc_clk stm32_rcc_clk_mp25 = {
+	.drv_name = "stm32mp25_clk",
+};
+
 static int stm32_rcc_bind(struct udevice *dev)
 {
 	struct udevice *child;
@@ -86,6 +90,7 @@ static const struct udevice_id stm32_rcc_ids[] = {
 	{.compatible = "st,stm32mp1-rcc", .data = (ulong)&stm32_rcc_clk_mp1 },
 	{.compatible = "st,stm32mp1-rcc-secure", .data = (ulong)&stm32_rcc_clk_mp1 },
 	{.compatible = "st,stm32mp13-rcc", .data = (ulong)&stm32_rcc_clk_mp13 },
+	{.compatible = "st,stm32mp25-rcc", .data = (ulong)&stm32_rcc_clk_mp25 },
 	{ }
 };
 
diff --git a/drivers/mmc/stm32_sdmmc2.c b/drivers/mmc/stm32_sdmmc2.c
index bfce8a2e4a..e39e71ba4f 100644
--- a/drivers/mmc/stm32_sdmmc2.c
+++ b/drivers/mmc/stm32_sdmmc2.c
@@ -25,6 +25,7 @@
 #include <asm/io.h>
 #include <asm/gpio.h>
 #include <linux/iopoll.h>
+#include <power/regulator.h>
 #include <watchdog.h>
 
 struct stm32_sdmmc2_plat {
@@ -36,6 +37,9 @@ struct stm32_sdmmc2_plat {
 	struct gpio_desc cd_gpio;
 	u32 clk_reg_msk;
 	u32 pwr_reg_msk;
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
+	bool vqmmc_enabled;
+#endif
 };
 
 struct stm32_sdmmc2_ctx {
@@ -215,9 +219,9 @@ static void stm32_sdmmc2_start_data(struct udevice *dev,
 
 	if (data->flags & MMC_DATA_READ) {
 		data_ctrl |= SDMMC_DCTRL_DTDIR;
-		idmabase0 = (u32)data->dest;
+		idmabase0 = (u32)(long)data->dest;
 	} else {
-		idmabase0 = (u32)data->src;
+		idmabase0 = (u32)(long)data->src;
 	}
 
 	/* Set the SDMMC DataLength value */
@@ -458,8 +462,8 @@ retry_cmd:
 
 	stm32_sdmmc2_start_cmd(dev, cmd, cmdat, &ctx);
 
-	dev_dbg(dev, "send cmd %d data: 0x%x @ 0x%x\n",
-		cmd->cmdidx, data ? ctx.data_length : 0, (unsigned int)data);
+	dev_dbg(dev, "send cmd %d data: 0x%x @ 0x%p\n",
+		cmd->cmdidx, data ? ctx.data_length : 0, data);
 
 	ret = stm32_sdmmc2_end_cmd(dev, cmd, &ctx);
 
@@ -572,6 +576,15 @@ static void stm32_sdmmc2_pwron(struct stm32_sdmmc2_plat *plat)
 	       plat->base + SDMMC_POWER);
 
 	/* during the first 74 SDMMC_CK cycles the SDMMC is still disabled. */
+
+#if CONFIG_IS_ENABLED(DM_REGULATOR)
+	if (plat->mmc.vqmmc_supply && !plat->vqmmc_enabled) {
+		if (regulator_set_enable_if_allowed(plat->mmc.vqmmc_supply, true))
+			dev_dbg(plat->mmc.dev, "failed to enable vqmmc-supply\n");
+		else
+			plat->vqmmc_enabled = true;
+	}
+#endif
 }
 
 #define IS_RISING_EDGE(reg) (reg & SDMMC_CLKCR_NEGEDGE ? 0 : 1)
@@ -598,13 +611,16 @@ static int stm32_sdmmc2_set_ios(struct udevice *dev)
 	 * clk_div > 0 and NEGEDGE = 1 => command and data generated on
 	 * SDMMCCLK falling edge
 	 */
-	if (desired && ((sys_clock > desired) ||
+	if (desired && (sys_clock > desired || mmc->ddr_mode ||
 			IS_RISING_EDGE(plat->clk_reg_msk))) {
 		clk = DIV_ROUND_UP(sys_clock, 2 * desired);
 		if (clk > SDMMC_CLKCR_CLKDIV_MAX)
 			clk = SDMMC_CLKCR_CLKDIV_MAX;
 	}
 
+	if (mmc->ddr_mode)
+		clk |= SDMMC_CLKCR_DDR;
+
 	if (mmc->bus_width == 4)
 		clk |= SDMMC_CLKCR_WIDBUS_4;
 	if (mmc->bus_width == 8)
@@ -672,6 +688,8 @@ static int stm32_sdmmc2_of_to_plat(struct udevice *dev)
 	if (ret)
 		return ret;
 
+	cfg->host_caps &= ~(UHS_CAPS | MMC_MODE_HS200 | MMC_MODE_HS400 | MMC_MODE_HS400_ES);
+
 	ret = clk_get_by_index(dev, 0, &plat->clk);
 	if (ret)
 		return ret;
@@ -772,6 +790,7 @@ static int stm32_sdmmc2_bind(struct udevice *dev)
 
 static const struct udevice_id stm32_sdmmc2_ids[] = {
 	{ .compatible = "st,stm32-sdmmc2" },
+	{ .compatible = "st,stm32mp25-sdmmc2" },
 	{ }
 };
 
diff --git a/drivers/mtd/Kconfig b/drivers/mtd/Kconfig
index fcdb450f77..1d0c946931 100644
--- a/drivers/mtd/Kconfig
+++ b/drivers/mtd/Kconfig
@@ -118,6 +118,13 @@ config FLASH_CFI_MTD
 	  in the drivers directory. The driver exports CFI flash
 	  to the MTD layer.
 
+ config FLASH_CFI_SFDP
+	bool "Enable SFDP parsing"
+	depends on FLASH_CFI_DRIVER
+	help
+	  This option enables the SFDP parsing which allows
+	  to support SEMPER flashes.
+
 config SYS_FLASH_PROTECTION
 	bool "Use hardware flash protection"
 	depends on FLASH_CFI_DRIVER
@@ -179,6 +186,13 @@ config STM32_FLASH
 	 This is the driver of embedded flash for some STMicroelectronics
 	 STM32 MCU.
 
+config STM32_HYPERBUS
+	bool "STMicroelectronics HyperBus driver"
+	depends on STM32MP25X && DM_MTD && CFI_FLASH
+	help
+	  This enables STMicroelectronics HyperBus controller on STM32MP2
+	  SoCs family.
+
 config SYS_MAX_FLASH_SECT
 	int "Maximumm number of sectors on a flash chip"
 	depends on MTD_NOR_FLASH || FLASH_CFI_DRIVER
@@ -187,6 +201,7 @@ config SYS_MAX_FLASH_SECT
 config SAMSUNG_ONENAND
 	bool "Samsung OneNAND driver support"
 
+
 config USE_SYS_MAX_FLASH_BANKS
 	bool "Enable Max number of Flash memory banks"
 	help
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
index 3a78590aaa..0846dff13c 100644
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -11,7 +11,9 @@ mtd-$(CONFIG_ALTERA_QSPI) += altera_qspi.o
 mtd-$(CONFIG_FLASH_CFI_DRIVER) += cfi_flash.o
 mtd-$(CONFIG_FLASH_CFI_MTD) += cfi_mtd.o
 mtd-$(CONFIG_FLASH_CFI_LEGACY) += jedec_flash.o
+mtd-$(CONFIG_FLASH_CFI_SFDP) += sfdp_flash.o
 mtd-$(CONFIG_STM32_FLASH) += stm32_flash.o
+mtd-$(CONFIG_STM32_HYPERBUS) += stm32_hyperbus.o
 mtd-$(CONFIG_RENESAS_RPC_HF) += renesas_rpc_hf.o
 mtd-$(CONFIG_HBMC_AM654) += hbmc-am654.o
 
diff --git a/drivers/mtd/cfi_flash.c b/drivers/mtd/cfi_flash.c
index 4950410706..0eaf0db1e4 100644
--- a/drivers/mtd/cfi_flash.c
+++ b/drivers/mtd/cfi_flash.c
@@ -31,9 +31,15 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <asm/unaligned.h>
+#include <dm/device_compat.h>
+#include <dm/of_access.h>
+#include <dm/ofnode.h>
 #include <env_internal.h>
 #include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sizes.h>
 #include <mtd/cfi_flash.h>
+#include <mtd/sfdp_flash.h>
 #include <watchdog.h>
 
 /*
@@ -599,6 +605,11 @@ static int flash_status_check(flash_info_t *info, flash_sect_t sector,
 	return ERR_OK;
 }
 
+static inline int manufact_match(flash_info_t *info, u32 manu)
+{
+	return info->manufacturer_id == ((manu & FLASH_VENDMASK) >> 16);
+}
+
 /*-----------------------------------------------------------------------
  * Wait for XSR.7 to be set, if it times out print an error, otherwise
  * do a full status check.
@@ -641,6 +652,30 @@ static int flash_full_status_check(flash_info_t *info, flash_sect_t sector,
 		flash_write_cmd(info, sector, 0, info->cmd_reset);
 		udelay(1);
 		break;
+	case CFI_CMDSET_AMD_STANDARD:
+		if (retcode == ERR_OK && manufact_match(info, CY_MANUFACT)) {
+			ushort st;
+
+			flash_write_cmd(info, sector, info->addr_unlock1,
+					FLASH_CMD_READ_STATUS);
+			st = flash_read_word(info, 0);
+
+			if (st & (FLASH_STATUS_ECLBS | FLASH_STATUS_PSLBS)) {
+				if (st & FLASH_STATUS_ECLBS) {
+					puts("Block Erase Error.\n");
+					retcode = ERR_NOT_ERASED;
+				} else if (st & FLASH_STATUS_VPENS) {
+					puts("Write Buffer Abort.\n");
+					retcode = ERR_ABORTED;
+				} else {
+					puts("Program Error.\n");
+					retcode = ERR_PROG_ERROR;
+				}
+				flash_write_cmd(info, 0, info->addr_unlock1,
+						FLASH_CMD_CLEAR_ERROR_STATUS);
+			}
+		}
+		break;
 	default:
 		break;
 	}
@@ -994,6 +1029,11 @@ static int flash_write_cfibuffer(flash_info_t *info, ulong dest, uchar *cp,
 #ifdef CONFIG_FLASH_SPANSION_S29WS_N
 		offset = ((unsigned long)dst - info->start[sector]) >> shift;
 #endif
+		if (manufact_match(info, CY_MANUFACT) &&
+		    flash_sector_size(info, sector) != SZ_256K)
+			offset = (((unsigned long)dst - info->start[sector]) &
+				  ~(SZ_4K - 1)) >> shift;
+
 		flash_write_cmd(info, sector, offset, AMD_CMD_WRITE_TO_BUFFER);
 		cnt = len >> shift;
 		flash_write_cmd(info, sector, offset, cnt - 1);
@@ -1028,7 +1068,10 @@ static int flash_write_cfibuffer(flash_info_t *info, ulong dest, uchar *cp,
 			goto out_unmap;
 		}
 
-		flash_write_cmd(info, sector, 0, AMD_CMD_WRITE_BUFFER_CONFIRM);
+		if (!manufact_match(info, CY_MANUFACT))
+			offset = 0;
+
+		flash_write_cmd(info, sector, offset, AMD_CMD_WRITE_BUFFER_CONFIRM);
 		if (use_flash_status_poll(info))
 			retcode = flash_status_poll(info, src - (1 << shift),
 						    dst - (1 << shift),
@@ -1051,6 +1094,29 @@ out_unmap:
 }
 #endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
 
+static int flash_blank_check(flash_info_t *info, int sect)
+{
+	int retcode;
+
+	/* Issue Blank Check command */
+	flash_write_cmd(info, sect, info->addr_unlock1, 0x33);
+
+	/* Wait till ready */
+	retcode = flash_status_check(info, sect, info->erase_blk_tout,
+				     "blkchk");
+	if (retcode)
+		return 0; /* Not erased in any error cases */
+
+	/* Read status again to check erase status */
+	flash_write_cmd(info, sect, info->addr_unlock1, FLASH_CMD_READ_STATUS);
+	if (flash_isset(info, sect, 0, FLASH_STATUS_ECLBS)) {
+		flash_write_cmd(info, 0, info->addr_unlock1, 0x71);
+		return 0;
+	}
+
+	return 1; /* erased */
+}
+
 /*-----------------------------------------------------------------------
  */
 int flash_erase(flash_info_t *info, int s_first, int s_last)
@@ -1087,32 +1153,41 @@ int flash_erase(flash_info_t *info, int s_first, int s_last)
 		}
 
 		if (info->protect[sect] == 0) { /* not protected */
-#ifdef CONFIG_SYS_FLASH_CHECK_BLANK_BEFORE_ERASE
-			int k;
-			int size;
-			int erased;
-			u32 *flash;
+			if (IS_ENABLED(CONFIG_SYS_FLASH_CHECK_BLANK_BEFORE_ERASE)) {
+				int k;
+				int size;
+				int erased;
+				u32 *flash;
+
+				if (manufact_match(info, CY_MANUFACT) &&
+				    flash_blank_check(info, sect)) {
+					if (flash_verbose)
+						putc(',');
+					continue;
+				}
 
-			/*
-			 * Check if whole sector is erased
-			 */
-			size = flash_sector_size(info, sect);
-			erased = 1;
-			flash = (u32 *)info->start[sect];
-			/* divide by 4 for longword access */
-			size = size >> 2;
-			for (k = 0; k < size; k++) {
-				if (flash_read32(flash++) != 0xffffffff) {
-					erased = 0;
-					break;
+				/*
+				 * Check if whole sector is erased
+				 */
+				size = flash_sector_size(info, sect);
+				erased = 1;
+				flash = (u32 *)info->start[sect];
+				/* divide by 4 for longword access */
+				size = size >> 2;
+				for (k = 0; k < size; k++) {
+					if (flash_read32(flash++) != 0xffffffff) {
+						erased = 0;
+						break;
+					}
+				}
+
+				if (erased) {
+					if (flash_verbose)
+						putc(',');
+					continue;
 				}
 			}
-			if (erased) {
-				if (flash_verbose)
-					putc(',');
-				continue;
-			}
-#endif
+
 			switch (info->vendor) {
 			case CFI_CMDSET_INTEL_PROG_REGIONS:
 			case CFI_CMDSET_INTEL_STANDARD:
@@ -1186,6 +1261,9 @@ static int sector_erased(flash_info_t *info, int i)
 	int size;
 	u32 *flash;
 
+	if (manufact_match(info, CY_MANUFACT))
+		return flash_blank_check(info, i);
+
 	/*
 	 * Check if whole sector is erased
 	 */
@@ -1434,11 +1512,6 @@ int write_buff(flash_info_t *info, uchar *src, ulong addr, ulong cnt)
 	return flash_write_cfiword(info, wp, cword);
 }
 
-static inline int manufact_match(flash_info_t *info, u32 manu)
-{
-	return info->manufacturer_id == ((manu & FLASH_VENDMASK) >> 16);
-}
-
 /*-----------------------------------------------------------------------
  */
 #ifdef CONFIG_SYS_FLASH_PROTECTION
@@ -1865,6 +1938,115 @@ static inline int flash_detect_legacy(phys_addr_t base, int banknum)
 }
 #endif
 
+#define S26_CMD_READ_VCR1	0xC7
+#define S26_CMD_READ_VCR2	0xC9
+#define S26_CFR1V_UNIFORM	BIT(9)
+#define S26_CFR1V_TP4KBS	BIT(8)
+#define S26_CFR2V_SP4KBS	BIT(2)
+#define S26_MAX_ERASE_REGIONS	(5)
+
+struct erase_info {
+	uint size;
+	uint blocks;
+};
+
+static struct erase_info regions[S26_MAX_ERASE_REGIONS];
+
+static void flash_add_erase_info(struct erase_info **region, uint size, uint blocks)
+{
+	(*region)->size = size;
+	(*region)->blocks = blocks;
+	(*region)++;
+}
+
+static void flash_fixup_s26(flash_info_t *info, ulong base)
+{
+	struct erase_info *r = regions;
+	ushort cfr1v, cfr2v;
+	uchar btm4ks, top4ks;
+	int i, j, sect_cnt;
+
+	flash_unlock_seq(info, 0);
+	flash_write_cmd(info, 0, info->addr_unlock1, S26_CMD_READ_VCR1);
+	cfr1v = flash_read_word(info, 0);
+
+	flash_unlock_seq(info, 0);
+	flash_write_cmd(info, 0, info->addr_unlock1, S26_CMD_READ_VCR2);
+	cfr2v = flash_read_word(info, 0);
+
+	if (cfr1v & S26_CFR1V_UNIFORM) {
+		btm4ks = 0;
+		top4ks = 0;
+	} else if (cfr2v & S26_CFR2V_SP4KBS) {
+		btm4ks = 16;
+		top4ks = 16;
+	} else if (cfr1v & S26_CFR1V_TP4KBS) {
+		btm4ks = 0;
+		top4ks = 32;
+	} else {
+		btm4ks = 32;
+		top4ks = 0;
+	}
+
+	if (btm4ks) {
+		flash_add_erase_info(&r, SZ_4K, btm4ks);
+		flash_add_erase_info(&r, SZ_256K - SZ_4K * btm4ks, 1);
+	}
+
+	flash_add_erase_info(&r, SZ_256K, info->size / SZ_256K - !!(btm4ks) - !!(top4ks));
+
+	if (top4ks) {
+		flash_add_erase_info(&r, SZ_256K - SZ_4K * top4ks, 1);
+		flash_add_erase_info(&r, SZ_4K, top4ks);
+	}
+
+	sect_cnt = 0;
+	for (i = 0; i < r - regions; i++) {
+		for (j = 0; j < regions[i].blocks; j++) {
+			if (sect_cnt >= CONFIG_SYS_MAX_FLASH_SECT) {
+				printf("ERROR: too many flash sectors\n");
+				break;
+			}
+			info->start[sect_cnt] = base;
+			base += regions[i].size;
+			sect_cnt++;
+		}
+	}
+	info->sector_count = sect_cnt;
+}
+
+static void flash_fixup_sfdp(flash_info_t *info, ulong base)
+{
+	if (manufact_match(info, CY_MANUFACT))
+		flash_fixup_s26(info, base);
+}
+
+static int flash_detect_sfdp(phys_addr_t base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+	void *addr;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_FLASH_CFI_SFDP))
+		return 0;
+
+	info->start[0] = (ulong)map_physmem(base, 0, MAP_NOCACHE);
+	info->portwidth = FLASH_CFI_16BIT;
+	info->chipwidth = FLASH_CFI_BY16;
+	info->chip_lsb = 0;
+
+	flash_write_cmd(info, 0, FLASH_OFFSET_CFI_ALT, FLASH_CMD_CFI);
+	addr = flash_map(info, 0, 0);
+	ret = sfdp_flash_scan(info, addr);
+	flash_unmap(info, 0, 0, addr);
+	flash_cmd_reset(info);
+
+	if (ret)
+		flash_fixup_sfdp(info, info->start[0]);
+
+	return ret;
+}
+
 /*-----------------------------------------------------------------------
  * detect if flash is compatible with the Common Flash Interface (CFI)
  * http://www.jedec.org/download/search/jesd68.pdf
@@ -2409,6 +2591,8 @@ unsigned long flash_init(void)
 
 #ifdef CONFIG_CFI_FLASH /* for driver model */
 	cfi_flash_init_dm();
+	if (!cfi_flash_num_flash_banks)
+		return 0;
 #endif
 
 	/* Init: no FLASHes known */
@@ -2419,7 +2603,8 @@ unsigned long flash_init(void)
 		cfi_flash_set_config_reg(cfi_flash_bank_addr(i),
 					 cfi_flash_config_reg(i));
 
-		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i))
+		if (!flash_detect_legacy(cfi_flash_bank_addr(i), i) &&
+		    !flash_detect_sfdp(cfi_flash_bank_addr(i), i))
 			flash_get_size(cfi_flash_bank_addr(i), i);
 		size += flash_info[i].size;
 		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
@@ -2492,17 +2677,42 @@ unsigned long flash_init(void)
 static int cfi_flash_probe(struct udevice *dev)
 {
 	fdt_addr_t addr;
-	int idx;
+	struct ofnode_phandle_args args;
+	struct resource res;
+	int idx, ret;
 
-	for (idx = 0; idx < CFI_MAX_FLASH_BANKS; idx++) {
-		addr = dev_read_addr_index(dev, idx);
-		if (addr == FDT_ADDR_T_NONE)
-			break;
+	/*
+	 * first, check if parent's node has a "status" property
+	 * if this status property is set to disabled, don't probe cfi
+	 */
+	if (!dev_read_enabled(dev_get_parent(dev)))
+		return -ENODEV;
+
+	ret = dev_read_phandle_with_args(dev_get_parent(dev), "memory-region", NULL, 0, 0, &args);
+	if (!ret) {
+		for (idx = 0; idx < CFI_MAX_FLASH_BANKS; idx++) {
+			ret = ofnode_read_resource(args.node, idx, &res);
+			if (ret) {
+				dev_err(dev, "Can't get mmap base address(%d)\n", ret);
+				return ret;
+			}
 
-		flash_info[cfi_flash_num_flash_banks].dev = dev;
-		flash_info[cfi_flash_num_flash_banks].base = addr;
-		cfi_flash_num_flash_banks++;
+			flash_info[cfi_flash_num_flash_banks].dev = dev;
+			flash_info[cfi_flash_num_flash_banks].base = res.start;
+			cfi_flash_num_flash_banks++;
+		}
+	} else {
+		for (idx = 0; idx < CFI_MAX_FLASH_BANKS; idx++) {
+			addr = dev_read_addr_index(dev, idx);
+			if (addr == FDT_ADDR_T_NONE)
+				break;
+
+			flash_info[cfi_flash_num_flash_banks].dev = dev;
+			flash_info[cfi_flash_num_flash_banks].base = addr;
+			cfi_flash_num_flash_banks++;
+		}
 	}
+
 	gd->bd->bi_flashstart = flash_info[0].base;
 
 	return 0;
@@ -2511,6 +2721,7 @@ static int cfi_flash_probe(struct udevice *dev)
 static const struct udevice_id cfi_flash_ids[] = {
 	{ .compatible = "cfi-flash" },
 	{ .compatible = "jedec-flash" },
+	{ .compatible = "sfdp-flash" },
 	{}
 };
 
diff --git a/drivers/mtd/cfi_mtd.c b/drivers/mtd/cfi_mtd.c
index bf4473ba9e..a4d958121a 100644
--- a/drivers/mtd/cfi_mtd.c
+++ b/drivers/mtd/cfi_mtd.c
@@ -10,6 +10,7 @@
 #include <flash.h>
 #include <malloc.h>
 
+#include <asm/io.h>
 #include <linux/errno.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/concat.h>
@@ -71,7 +72,7 @@ static int cfi_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
 	u_char *f = (u_char*)(fi->start[0]) + from;
 
 	if (dma_memcpy(buf, f, len) < 0)
-		memcpy(buf, f, len);
+		memcpy_fromio(buf, f, len);
 	*retlen = len;
 
 	return 0;
diff --git a/drivers/mtd/mtd_uboot.c b/drivers/mtd/mtd_uboot.c
index dd0b0242f9..42be9e7038 100644
--- a/drivers/mtd/mtd_uboot.c
+++ b/drivers/mtd/mtd_uboot.c
@@ -325,16 +325,18 @@ int mtd_probe_devices(void)
 	mtd_probe_uclass_spi_nor_devs();
 
 	/*
-	 * Check if mtdparts/mtdids changed, if the MTD dev list was updated
+	 * Check if the MTD dev list is updated or
+	 * if mtdparts/mtdids changed,
 	 * or if our previous attempt to delete existing partititions failed.
 	 * In any of these cases we want to update the partitions, otherwise,
 	 * everything is up-to-date and we can return 0 directly.
 	 */
-	if ((!mtdparts && !old_mtdparts && !mtdids && !old_mtdids) ||
-	    (mtdparts && old_mtdparts && mtdids && old_mtdids &&
-	     !mtd_dev_list_updated() && !mtd_del_all_parts_failed &&
-	     !strcmp(mtdparts, old_mtdparts) &&
-	     !strcmp(mtdids, old_mtdids)))
+	if (!mtd_dev_list_updated() &&
+	    ((!mtdparts && !old_mtdparts && !mtdids && !old_mtdids) ||
+	     (mtdparts && old_mtdparts && mtdids && old_mtdids &&
+	      !mtd_del_all_parts_failed &&
+	      !strcmp(mtdparts, old_mtdparts) &&
+	      !strcmp(mtdids, old_mtdids))))
 		return 0;
 
 	/* Update the local copy of mtdparts */
diff --git a/drivers/mtd/nand/raw/stm32_fmc2_nand.c b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
index fb3279b405..013ba79432 100644
--- a/drivers/mtd/nand/raw/stm32_fmc2_nand.c
+++ b/drivers/mtd/nand/raw/stm32_fmc2_nand.c
@@ -32,7 +32,7 @@
 #define FMC2_RB_DELAY_US		30
 
 /* Max chip enable */
-#define FMC2_MAX_CE			2
+#define FMC2_MAX_CE			4
 
 /* Timings */
 #define FMC2_THIZ			1
@@ -160,6 +160,11 @@ static inline struct stm32_fmc2_nand *to_fmc2_nand(struct nand_chip *chip)
 	return container_of(chip, struct stm32_fmc2_nand, chip);
 }
 
+struct stm32_fmc2_nfc_data {
+	int max_ncs;
+	struct udevice *(*get_cdev)(struct udevice *dev);
+};
+
 struct stm32_fmc2_nfc {
 	struct nand_hw_control base;
 	struct stm32_fmc2_nand nand;
@@ -169,6 +174,7 @@ struct stm32_fmc2_nfc {
 	fdt_addr_t cmd_base[FMC2_MAX_CE];
 	fdt_addr_t addr_base[FMC2_MAX_CE];
 	struct clk clk;
+	const struct stm32_fmc2_nfc_data *data;
 
 	u8 cs_assigned;
 	int cs_sel;
@@ -735,6 +741,9 @@ static int stm32_fmc2_nfc_setup_interface(struct mtd_info *mtd, int chipnr,
 	if (IS_ERR(sdrt))
 		return PTR_ERR(sdrt);
 
+	if (sdrt->tRC_min < 30000)
+		return -EOPNOTSUPP;
+
 	if (chipnr == NAND_DATA_IFACE_CHECK_ONLY)
 		return 0;
 
@@ -812,7 +821,7 @@ static int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc, ofnode node)
 	}
 
 	for (i = 0; i < nand->ncs; i++) {
-		if (cs[i] >= FMC2_MAX_CE) {
+		if (cs[i] >= nfc->data->max_ncs) {
 			log_err("Invalid reg value: %d\n", nand->cs_used[i]);
 			return -EINVAL;
 		}
@@ -903,10 +912,18 @@ static int stm32_fmc2_nfc_probe(struct udevice *dev)
 	spin_lock_init(&nfc->controller.lock);
 	init_waitqueue_head(&nfc->controller.wq);
 
-	cdev = stm32_fmc2_nfc_get_cdev(dev);
-	if (!cdev)
+	nfc->data = (void *)dev_get_driver_data(dev);
+	if (!nfc->data)
 		return -EINVAL;
 
+	if (nfc->data->get_cdev) {
+		cdev = nfc->data->get_cdev(dev);
+		if (!cdev)
+			return -EINVAL;
+	} else {
+		cdev = dev->parent;
+	}
+
 	ret = stm32_fmc2_nfc_parse_dt(dev, nfc);
 	if (ret)
 		return ret;
@@ -918,7 +935,7 @@ static int stm32_fmc2_nfc_probe(struct udevice *dev)
 	if (dev == cdev)
 		start_region = 1;
 
-	for (chip_cs = 0, mem_region = start_region; chip_cs < FMC2_MAX_CE;
+	for (chip_cs = 0, mem_region = start_region; chip_cs < nfc->data->max_ncs;
 	     chip_cs++, mem_region += 3) {
 		if (!(nfc->cs_assigned & BIT(chip_cs)))
 			continue;
@@ -1030,9 +1047,28 @@ static int stm32_fmc2_nfc_probe(struct udevice *dev)
 	return nand_register(0, mtd);
 }
 
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp1_data = {
+	.max_ncs = 2,
+	.get_cdev = stm32_fmc2_nfc_get_cdev,
+};
+
+static const struct stm32_fmc2_nfc_data stm32_fmc2_nfc_mp25_data = {
+	.max_ncs = 4,
+};
+
 static const struct udevice_id stm32_fmc2_nfc_match[] = {
-	{ .compatible = "st,stm32mp15-fmc2" },
-	{ .compatible = "st,stm32mp1-fmc2-nfc" },
+	{
+		.compatible = "st,stm32mp15-fmc2",
+		.data = (ulong)&stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp1-fmc2-nfc",
+		.data = (ulong)&stm32_fmc2_nfc_mp1_data,
+	},
+	{
+		.compatible = "st,stm32mp25-fmc2-nfc",
+		.data = (ulong)&stm32_fmc2_nfc_mp25_data,
+	},
 	{ /* Sentinel */ }
 };
 
diff --git a/drivers/mtd/sfdp_flash.c b/drivers/mtd/sfdp_flash.c
new file mode 100644
index 0000000000..e99bfbfc6a
--- /dev/null
+++ b/drivers/mtd/sfdp_flash.c
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause
+/*
+ * (C) Copyright 2022
+ * Takahiro Kuwano, <takahiro.kuwano@infineon.com>
+ */
+
+#include <common.h>
+#include <flash.h>
+#include <asm/byteorder.h>
+#include <mtd/cfi_flash.h>
+
+#define SFDP_SIGNATURE		0x50444653U
+#define SFDP_JESD216_MAJOR	1
+#define SFDP_OFFSET_S26_ID	(0x800)
+
+struct sfdp_header {
+	u32		signature; /* Ox50444653U <=> "SFDP" */
+	u8		minor;
+	u8		major;
+	u8		nph; /* 0-base number of parameter headers */
+	u8		prot;
+};
+
+struct sfdp_flash_info {
+	const ushort mfr_id;
+	const ushort dev_id;
+	const ushort dev_id2;
+	const char *name;
+};
+
+static const struct sfdp_flash_info s26_table[] = {
+	{ 0x0034, 0x006a, 0x001a, "s26hl512t" },
+	{ 0x0034, 0x006a, 0x001b, "s26hl01gt" },
+	{ 0x0034, 0x007b, 0x001a, "s26hs512t" },
+	{ 0x0034, 0x007b, 0x001b, "s26hs01gt" },
+};
+
+static int detect_s26(flash_info_t *info, const void *sfdp)
+{
+	const ushort *id = (const ushort *)sfdp + SFDP_OFFSET_S26_ID;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(s26_table); i++) {
+		if (s26_table[i].mfr_id == le16_to_cpu(id[0]) &&
+		    s26_table[i].dev_id == le16_to_cpu(id[1]) &&
+		    s26_table[i].dev_id2 == le16_to_cpu(id[2])) {
+			info->manufacturer_id = s26_table[i].mfr_id;
+			info->device_id = s26_table[i].dev_id;
+			info->device_id2 = s26_table[i].dev_id2;
+			info->name = s26_table[i].name;
+			info->vendor = CFI_CMDSET_AMD_STANDARD;
+			info->flash_id = FLASH_MAN_CFI;
+			info->interface = FLASH_CFI_X16;
+			info->addr_unlock1 = 0x555;
+			info->addr_unlock2 = 0x2aa;
+			info->sr_supported = 1;
+			info->buffer_size = 512;
+			info->cmd_reset = AMD_CMD_RESET;
+			info->cmd_erase_sector = AMD_CMD_ERASE_SECTOR;
+			info->erase_blk_tout = 3072;
+			info->write_tout = 1;
+			info->buffer_write_tout = 4;
+			info->size = 1ULL << info->device_id2;
+#ifdef CONFIG_SYS_FLASH_PROTECTION
+			info->legacy_unlock = 1;
+#endif
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int sfdp_flash_scan(flash_info_t *info, const void *sfdp)
+{
+	const struct sfdp_header *header = (const struct sfdp_header *)sfdp;
+
+	/* Check the SFDP signature and header version. */
+	if (le32_to_cpu(header->signature) == SFDP_SIGNATURE &&
+	    header->major == SFDP_JESD216_MAJOR) {
+		return detect_s26(info, sfdp);
+	}
+
+	return 0;
+}
diff --git a/drivers/mtd/spi/spi-nor-core.c b/drivers/mtd/spi/spi-nor-core.c
index e3c86e080a..4def3b8c7a 100644
--- a/drivers/mtd/spi/spi-nor-core.c
+++ b/drivers/mtd/spi/spi-nor-core.c
@@ -167,6 +167,7 @@ struct sfdp_header {
 #define BFPT_DWORD18_CMD_EXT_INV		(0x1UL << 29) /* Invert */
 #define BFPT_DWORD18_CMD_EXT_RES		(0x2UL << 29) /* Reserved */
 #define BFPT_DWORD18_CMD_EXT_16B		(0x3UL << 29) /* 16-bit opcode */
+#define BFPT_DWORD18_BYTE_ORDER_SWAPPED		BIT(31) /* Byte order of 16-bit words */
 
 /* xSPI Profile 1.0 table (from JESD216D.01). */
 #define PROFILE1_DWORD1_RD_FAST_CMD		GENMASK(15, 8)
@@ -272,6 +273,8 @@ static void spi_nor_setup_op(const struct spi_nor *nor,
 		 */
 		op->cmd.dtr = op->addr.dtr = op->dummy.dtr =
 			op->data.dtr = true;
+		op->data.dtr_swab16 = (proto == SNOR_PROTO_8_8_8_DTR) &&
+				      (nor->flags & SNOR_F_DTR_SWAB16);
 
 		/* 2 bytes per clock cycle in DTR mode. */
 		op->dummy.nbytes *= 2;
@@ -2352,6 +2355,10 @@ static int spi_nor_parse_bfpt(struct spi_nor *nor,
 		return -ENOTSUPP;
 	}
 
+	/* Byte order in 8D-8D-8D mode */
+	if (bfpt.dwords[BFPT_DWORD(18)] & BFPT_DWORD18_BYTE_ORDER_SWAPPED)
+		nor->flags |= SNOR_F_DTR_SWAB16;
+
 	return spi_nor_post_bfpt_fixups(nor, bfpt_header, &bfpt, params);
 }
 
@@ -3973,6 +3980,8 @@ int spi_nor_scan(struct spi_nor *nor)
 	if (spi_nor_protocol_is_dtr(nor->read_proto)) {
 		 /* Always use 4-byte addresses in DTR mode. */
 		nor->addr_width = 4;
+		if (info->flags & SPI_NOR_4B_OPCODES)
+			spi_nor_set_4byte_opcodes(nor, info);
 	} else if (nor->addr_width) {
 		/* already configured from SFDP */
 	} else if (info->addr_width) {
diff --git a/drivers/mtd/stm32_hyperbus.c b/drivers/mtd/stm32_hyperbus.c
new file mode 100644
index 0000000000..1b4f95e21f
--- /dev/null
+++ b/drivers/mtd/stm32_hyperbus.c
@@ -0,0 +1,356 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+
+/*
+ * STMicroelectronics hyperflash driver
+ * Copyright (C) 2021 STMicroelectronics - All Rights Reserved
+ *
+ */
+
+#include <common.h>
+#include <flash.h>
+#include <mtd.h>
+#include <stm32_omi.h>
+#include <asm/io.h>
+#include <dm/device_compat.h>
+#include <dm/read.h>
+#include <linux/bitfield.h>
+#include <mtd/cfi_flash.h>
+
+#define WRITE	0
+#define READ	1
+#define NSEC_PER_SEC		1000000000L
+
+/* HyperBus Commands */
+#define HYPERBUS_ADDR_UNLOCK1	0x555
+#define HYPERBUS_ADDR_UNLOCK2	0x2AA
+#define HYPERBUS_CMD_UNLOCK1	0xAA
+#define HYPERBUS_CMD_UNLOCK2	0x55
+#define HYPERBUS_CMD_RDSFDP	0x90
+
+struct stm32_hb_priv {
+	struct udevice *dev;
+	struct udevice *omi_dev;
+	ulong real_flash_freq;		/* real flash freq = bus_freq x prescaler */
+};
+
+struct stm32_hb_plat {
+	ulong flash_freq;		/* flash max supported frequency */
+	u32 tacc;
+	u32 cs;
+	bool wzl;
+};
+
+static struct stm32_hb_priv *g_stm32_hb_priv;
+
+static int stm32_hb_xfer(void *addr, u16 wdata, u16 *rdata,
+			 bool read)
+{
+	struct stm32_hb_priv *priv = g_stm32_hb_priv;
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	int ret;
+	u32 cr;
+	u32 offset;
+
+	/* exit from memory map mode by setting ABORT bit */
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_ABORT);
+
+	/* Wait clear of abort bit by hw */
+	ret = readl_poll_timeout(regs_base + OSPI_CR, cr, !(cr & OSPI_CR_ABORT),
+				 OSPI_ABT_TIMEOUT_US);
+
+	if (ret) {
+		dev_err(priv->dev, "%s abort timeout:%d\n", __func__, ret);
+		return ret;
+	}
+
+	offset = (u32)(long)addr - omi_plat->mm_base;
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			FIELD_PREP(OSPI_CR_FMODE_MASK,
+				   read ? OSPI_CR_FMODE_IND_READ :
+				   OSPI_CR_FMODE_IND_WRITE));
+
+	writel((uintptr_t)offset, regs_base + OSPI_AR);
+
+	ret = stm32_omi_tx_poll(priv->omi_dev, read ? (u8 *)rdata : (u8 *)&wdata, 2, read);
+	if (ret)
+		return ret;
+
+	/* Wait end of tx in indirect mode */
+	ret = stm32_omi_wait_cmd(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	dev_dbg(priv->dev, "%s: %s 0x%x @ 0x%x\n", __func__,
+		read ? "read" : "write",
+		read ? *rdata : wdata, offset >> 1);
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			FIELD_PREP(OSPI_CR_FMODE_MASK, OSPI_CR_FMODE_MMAP));
+
+	return ret;
+}
+
+u16 flash_read16(void *addr)
+{
+	struct stm32_hb_priv *priv = g_stm32_hb_priv;
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t mm_base = omi_plat->mm_base;
+	resource_size_t mm_size = omi_plat->mm_size;
+	int ret;
+	u16 rdata = 0;
+
+	/*
+	 * Before going further, check if this read is accessing DDR or Flash
+	 */
+	if (((u32)(long)addr < mm_base) ||
+	    ((u32)(long)addr > mm_base + mm_size))
+		return readw(addr);
+
+	ret = stm32_hb_xfer(addr, 0, &rdata, READ);
+	if (ret)
+		dev_err(priv->dev, "%s failed, ret=%i\n", __func__, ret);
+
+	return rdata;
+}
+
+void flash_write16(u16 value, void *addr)
+{
+	struct stm32_hb_priv *priv = g_stm32_hb_priv;
+	int ret;
+
+	ret = stm32_hb_xfer(addr, value, 0, WRITE);
+	if (ret)
+		dev_err(priv->dev, "%s failed, ret=%i\n", __func__, ret);
+};
+
+static int stm32_hb_test_sfdp(struct udevice *omi_dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+	phys_addr_t mm_base = omi_plat->mm_base;
+	int ret = -EIO;
+	u16 sfdp[2];
+
+	/* Reset */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+	flash_write16(HYPERBUS_CMD_UNLOCK1, (void *)mm_base + (HYPERBUS_ADDR_UNLOCK1 << 1));
+	flash_write16(HYPERBUS_CMD_UNLOCK2, (void *)mm_base + (HYPERBUS_ADDR_UNLOCK2 << 1));
+	flash_write16(HYPERBUS_CMD_RDSFDP, (void *)mm_base + (HYPERBUS_ADDR_UNLOCK1 << 1));
+
+	sfdp[0] = readw(mm_base);
+	sfdp[1] = readw(mm_base + 0x2);
+
+	/* compare with "SF" & "DP" */
+	if (sfdp[0] == 0x4653 && sfdp[1] == 0x5044)
+		ret = 0;
+
+	/* Reset CFI */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+
+	return ret;
+}
+
+static int stm32_hb_test_cfi(struct udevice *omi_dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+	phys_addr_t mm_base = omi_plat->mm_base;
+	int ret = -EIO;
+	u16 qry[3];
+
+	/* Reset/Enter in CFI */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+	flash_write16(FLASH_CMD_CFI, (void *)mm_base + 0xaa);
+
+	qry[0] = readw(mm_base + 0x20);
+	qry[1] = readw(mm_base + 0x22);
+	qry[2] = readw(mm_base + 0x24);
+	if (qry[0] == 'Q' && qry[1] == 'R' && qry[2] == 'Y')
+		ret = 0;
+
+	/* Reset/Exit from CFI */
+	flash_write16(AMD_CMD_RESET, (void *)mm_base);
+	flash_write16(FLASH_CMD_RESET, (void *)mm_base);
+
+	return ret;
+}
+
+static int stm32_hb_check_transfer(struct udevice *omi_dev)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+
+	if (omi_plat->jedec_flash)
+		return stm32_hb_test_sfdp(omi_dev);
+	else
+		return stm32_hb_test_cfi(omi_dev);
+}
+
+static int stm32_hb_calibrate(struct stm32_hb_priv *priv)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	u32 prescaler;
+	u16 period_ps = 0;
+	u8 window_len = 0;
+	int ret;
+	bool bypass_mode = false;
+
+	prescaler = FIELD_GET(OSPI_DCR2_PRESC_MASK,
+			      readl(omi_plat->regs_base + OSPI_DCR2));
+	if (prescaler)
+		setbits_le32(omi_plat->regs_base + OSPI_TCR, OSPI_TCR_DHQC);
+
+	if (priv->real_flash_freq <= STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (priv->real_flash_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	if (bypass_mode || prescaler)
+		/* perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len);
+	else
+		/* perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, false, &window_len);
+
+	if (ret) {
+		dev_err(priv->omi_dev, "Calibration failed\n");
+		if (!bypass_mode)
+			/* stop delay block when configured in lock mode */
+			stm32_omi_dlyb_stop(priv->omi_dev);
+	}
+
+	return ret;
+}
+
+static void stm32_hb_init(struct udevice *dev)
+{
+	struct stm32_hb_priv *priv = dev_get_priv(dev);
+	struct stm32_hb_plat *plat = dev_get_plat(dev);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	unsigned long period;
+	u32 ccr, dcr1, hlcr, prescaler;
+
+	/* enable IP */
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_EN);
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_CSSEL,
+			FIELD_PREP(OSPI_CR_CSSEL, plat->cs));
+
+	/* set MTYP to HyperBus memory-map mode */
+	dcr1 = FIELD_PREP(OSPI_DCR1_MTYP_MASK, OSPI_DCR1_MTYP_HP_MEMMODE);
+	/* set DEVSIZE to memory map size */
+	dcr1 |= FIELD_PREP(OSPI_DCR1_DEVSIZE_MASK, ffs(omi_plat->mm_size) - 1);
+	writel(dcr1, regs_base + OSPI_DCR1);
+
+	prescaler = DIV_ROUND_UP(omi_plat->clock_rate, plat->flash_freq) - 1;
+	if (prescaler > 255)
+		prescaler = 255;
+
+	clrsetbits_le32(regs_base + OSPI_DCR2, OSPI_DCR2_PRESC_MASK,
+			FIELD_PREP(OSPI_DCR2_PRESC_MASK, prescaler));
+	priv->real_flash_freq = omi_plat->clock_rate / (prescaler + 1);
+
+	writel(1, regs_base + OSPI_DLR);
+
+	/* set access time latency */
+	period = NSEC_PER_SEC / priv->real_flash_freq;
+	hlcr = FIELD_PREP(OSPI_HLCR_TACC_MASK, DIV_ROUND_UP(plat->tacc, period));
+	/* set write zero latency */
+	if (plat->wzl)
+		hlcr |= OSPI_HLCR_WZL;
+
+	writel(hlcr, regs_base + OSPI_HLCR);
+
+	ccr = OSPI_CCR_DQSE | OSPI_CCR_DDTR | OSPI_CCR_ADDTR;
+	ccr |= FIELD_PREP(OSPI_CCR_DMODE_MASK, OSPI_CCR_DMODE_8LINES);
+	ccr |= FIELD_PREP(OSPI_CCR_ADSIZE_MASK, OSPI_CCR_ADSIZE_32BITS);
+	ccr |= FIELD_PREP(OSPI_CCR_ADMODE_MASK, OSPI_CCR_ADMODE_8LINES);
+	writel(ccr, regs_base + OSPI_CCR);
+
+	/* Set FMODE to memory map mode */
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			FIELD_PREP(OSPI_CR_FMODE_MASK, OSPI_CR_FMODE_MMAP));
+}
+
+static int stm32_hb_probe(struct udevice *dev)
+{
+	struct stm32_hb_priv *priv = dev_get_priv(dev);
+	struct stm32_omi_plat *omi_plat;
+	struct stm32_omi_priv *omi_priv;
+	int ret;
+
+	priv->omi_dev = dev->parent;
+	omi_plat = dev_get_plat(priv->omi_dev);
+	omi_priv = dev_get_priv(priv->omi_dev);
+	omi_priv->dev = dev;
+	priv->dev = dev;
+
+	g_stm32_hb_priv = priv;
+
+	/* mandatory for HyperFlash */
+	if (!omi_plat->mm_size) {
+		dev_err(dev, "Memory-map region not found\n");
+		return -EINVAL;
+	}
+
+	/* mandatory for HyperFlash */
+	if (!omi_plat->dlyb_base) {
+		dev_err(dev, "Incorrect delay block base address\n");
+		return -EINVAL;
+	}
+
+	ret = clk_enable(&omi_plat->clk);
+	if (ret) {
+		dev_err(dev, "failed to enable HyperBus clock\n");
+		return ret;
+	}
+
+	reset_assert_bulk(&omi_plat->rst_ctl);
+	udelay(2);
+	reset_deassert_bulk(&omi_plat->rst_ctl);
+
+	omi_priv->check_transfer = stm32_hb_check_transfer;
+	stm32_hb_init(dev);
+
+	return stm32_hb_calibrate(priv);
+}
+
+static int stm32_hb_of_to_plat(struct udevice *dev)
+{
+	struct stm32_hb_plat *plat = dev_get_plat(dev);
+	ofnode flash_node;
+	int ret;
+
+	flash_node = dev_read_first_subnode(dev);
+
+	ret = ofnode_read_u32(flash_node, "reg", &plat->cs);
+	if (ret) {
+		dev_err(dev, "could not retrieve reg property: %d\n", ret);
+		return ret;
+	}
+
+	plat->flash_freq = ofnode_read_u32_default(flash_node, "st,max-frequency", 0);
+	if (!plat->flash_freq) {
+		dev_err(dev, "Can't find st,max-frequency property\n");
+		return -ENOENT;
+	}
+
+	plat->tacc = ofnode_read_u32_default(flash_node, "st,tacc-ns", 0);
+	plat->wzl = ofnode_read_bool(flash_node, "st,wzl");
+
+	return 0;
+}
+
+U_BOOT_DRIVER(stm32_hyperbus) = {
+	.name		= "stm32_hyperbus",
+	.id		= UCLASS_MTD,
+	.bind		= dm_scan_fdt_dev,
+	.of_to_plat	= stm32_hb_of_to_plat,
+	.plat_auto	= sizeof(struct stm32_hb_plat),
+	.priv_auto	= sizeof(struct stm32_hb_priv),
+	.probe		= stm32_hb_probe,
+};
diff --git a/drivers/net/dwc_eth_qos.c b/drivers/net/dwc_eth_qos.c
index 001b028fa1..61281e1076 100644
--- a/drivers/net/dwc_eth_qos.c
+++ b/drivers/net/dwc_eth_qos.c
@@ -47,11 +47,13 @@
 #include <asm/cache.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
+#include <dm/device_compat.h>
 #ifdef CONFIG_ARCH_IMX8M
 #include <asm/arch/clock.h>
 #include <asm/mach-imx/sys_proto.h>
 #endif
 #include <linux/delay.h>
+#include <power/regulator.h>
 
 #include "dwc_eth_qos.h"
 
@@ -75,15 +77,38 @@
  */
 static void *eqos_alloc_descs(struct eqos_priv *eqos, unsigned int num)
 {
+	void *descs = NULL;
+	ulong desc_pad;
+
+	/*
+	 * if descriptors can to be cache-line aligned with the DSL =
+	 * "Descriptor Skip Length" field of the DMA channel control register
+	 */
 	eqos->desc_size = ALIGN(sizeof(struct eqos_desc),
 				(unsigned int)ARCH_DMA_MINALIGN);
+	desc_pad = (eqos->desc_size - sizeof(struct eqos_desc)) /
+		   eqos->config->axi_bus_width;
+	if (desc_pad <= EQOS_DMA_CH0_CONTROL_DSL_MAX) {
+		eqos->use_cached_mem = true;
+		descs = memalign(eqos->desc_size, num * eqos->desc_size);
+	} else {
+		eqos->use_cached_mem = false;
+		eqos->desc_size = sizeof(struct eqos_desc);
+#ifdef CONFIG_SYS_NONCACHED_MEMORY
+		descs = (void *)noncached_alloc(num * eqos->desc_size, ARCH_DMA_MINALIGN);
+#else
+		log_err("DMA descriptors with cached memory.");
+#endif
+	}
 
-	return memalign(eqos->desc_size, num * eqos->desc_size);
+	return descs;
 }
 
-static void eqos_free_descs(void *descs)
+static void eqos_free_descs(struct eqos_priv *eqos)
 {
-	free(descs);
+	if (eqos->use_cached_mem)
+		free(eqos->descs);
+	/* memory allocated by noncached_alloc() can't be freed */
 }
 
 static struct eqos_desc *eqos_get_desc(struct eqos_priv *eqos,
@@ -93,22 +118,24 @@ static struct eqos_desc *eqos_get_desc(struct eqos_priv *eqos,
 		((rx ? EQOS_DESCRIPTORS_TX : 0) + num) * eqos->desc_size;
 }
 
-void eqos_inval_desc_generic(void *desc)
+void eqos_inval_desc_generic(struct eqos_priv *eqos, void *desc)
 {
 	unsigned long start = (unsigned long)desc;
 	unsigned long end = ALIGN(start + sizeof(struct eqos_desc),
 				  ARCH_DMA_MINALIGN);
 
-	invalidate_dcache_range(start, end);
+	if (eqos->use_cached_mem)
+		invalidate_dcache_range(start, end);
 }
 
-void eqos_flush_desc_generic(void *desc)
+void eqos_flush_desc_generic(struct eqos_priv *eqos, void *desc)
 {
 	unsigned long start = (unsigned long)desc;
 	unsigned long end = ALIGN(start + sizeof(struct eqos_desc),
 				  ARCH_DMA_MINALIGN);
 
-	flush_dcache_range(start, end);
+	if (eqos->use_cached_mem)
+		flush_dcache_range(start, end);
 }
 
 void eqos_inval_buffer_tegra186(void *buf, size_t size)
@@ -383,6 +410,27 @@ static int eqos_stop_clks_stm32(struct udevice *dev)
 	return 0;
 }
 
+static int eqos_phy_power_on_stm32(struct udevice *dev)
+{
+	struct eqos_priv *eqos = dev_get_priv(dev);
+	int ret;
+
+	debug("%s(dev=%p):\n", __func__, dev);
+
+#ifdef CONFIG_DM_REGULATOR
+	if (eqos->phy_supply) {
+		ret = regulator_set_enable(eqos->phy_supply, true);
+		if (ret) {
+			printf("%s: Error enabling phy supply\n", dev->name);
+			return ret;
+		}
+	}
+#endif
+
+	debug("%s: OK\n", __func__);
+	return 0;
+}
+
 static int eqos_start_resets_tegra186(struct udevice *dev)
 {
 	struct eqos_priv *eqos = dev_get_priv(dev);
@@ -754,6 +802,12 @@ static int eqos_start(struct udevice *dev)
 	eqos->tx_desc_idx = 0;
 	eqos->rx_desc_idx = 0;
 
+	ret = eqos->config->ops->eqos_phy_power_on(dev);
+	if (ret < 0) {
+		pr_err("eqos_phy_power_on() failed: %d", ret);
+		goto err;
+	}
+
 	ret = eqos->config->ops->eqos_start_resets(dev);
 	if (ret < 0) {
 		pr_err("eqos_start_resets() failed: %d", ret);
@@ -967,12 +1021,17 @@ static int eqos_start(struct udevice *dev)
 			EQOS_MAX_PACKET_SIZE <<
 			EQOS_DMA_CH0_RX_CONTROL_RBSZ_SHIFT);
 
-	desc_pad = (eqos->desc_size - sizeof(struct eqos_desc)) /
-		   eqos->config->axi_bus_width;
+	setbits_le32(&eqos->dma_regs->ch0_control, EQOS_DMA_CH0_CONTROL_PBLX8);
 
-	setbits_le32(&eqos->dma_regs->ch0_control,
-		     EQOS_DMA_CH0_CONTROL_PBLX8 |
-		     (desc_pad << EQOS_DMA_CH0_CONTROL_DSL_SHIFT));
+	/* "Descriptor Skip Length" field of the DMA channel control register */
+	if (eqos->use_cached_mem) {
+		desc_pad = (eqos->desc_size - sizeof(struct eqos_desc)) /
+			    eqos->config->axi_bus_width;
+		setbits_le32(&eqos->dma_regs->ch0_control,
+			     desc_pad << EQOS_DMA_CH0_CONTROL_DSL_SHIFT);
+		if (desc_pad > EQOS_DMA_CH0_CONTROL_DSL_MAX)
+			dev_dbg(dev, "DMA_CH0_CONTROL.DSL overflow");
+	}
 
 	/*
 	 * Burst length must be < 1/2 FIFO size.
@@ -1005,7 +1064,7 @@ static int eqos_start(struct udevice *dev)
 
 	for (i = 0; i < EQOS_DESCRIPTORS_TX; i++) {
 		struct eqos_desc *tx_desc = eqos_get_desc(eqos, i, false);
-		eqos->config->ops->eqos_flush_desc(tx_desc);
+		eqos->config->ops->eqos_flush_desc(eqos, tx_desc);
 	}
 
 	for (i = 0; i < EQOS_DESCRIPTORS_RX; i++) {
@@ -1014,7 +1073,7 @@ static int eqos_start(struct udevice *dev)
 					     (i * EQOS_MAX_PACKET_SIZE));
 		rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
 		mb();
-		eqos->config->ops->eqos_flush_desc(rx_desc);
+		eqos->config->ops->eqos_flush_desc(eqos, rx_desc);
 		eqos->config->ops->eqos_inval_buffer(eqos->rx_dma_buf +
 						(i * EQOS_MAX_PACKET_SIZE),
 						EQOS_MAX_PACKET_SIZE);
@@ -1142,13 +1201,13 @@ static int eqos_send(struct udevice *dev, void *packet, int length)
 	 */
 	mb();
 	tx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_FD | EQOS_DESC3_LD | length;
-	eqos->config->ops->eqos_flush_desc(tx_desc);
+	eqos->config->ops->eqos_flush_desc(eqos, tx_desc);
 
 	writel((ulong)eqos_get_desc(eqos, eqos->tx_desc_idx, false),
 		&eqos->dma_regs->ch0_txdesc_tail_pointer);
 
 	for (i = 0; i < 1000000; i++) {
-		eqos->config->ops->eqos_inval_desc(tx_desc);
+		eqos->config->ops->eqos_inval_desc(eqos, tx_desc);
 		if (!(readl(&tx_desc->des3) & EQOS_DESC3_OWN))
 			return 0;
 		udelay(1);
@@ -1168,7 +1227,7 @@ static int eqos_recv(struct udevice *dev, int flags, uchar **packetp)
 	debug("%s(dev=%p, flags=%x):\n", __func__, dev, flags);
 
 	rx_desc = eqos_get_desc(eqos, eqos->rx_desc_idx, true);
-	eqos->config->ops->eqos_inval_desc(rx_desc);
+	eqos->config->ops->eqos_inval_desc(eqos, rx_desc);
 	if (rx_desc->des3 & EQOS_DESC3_OWN) {
 		debug("%s: RX packet not available\n", __func__);
 		return -EAGAIN;
@@ -1206,7 +1265,7 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 
 	rx_desc->des0 = 0;
 	mb();
-	eqos->config->ops->eqos_flush_desc(rx_desc);
+	eqos->config->ops->eqos_flush_desc(eqos, rx_desc);
 	eqos->config->ops->eqos_inval_buffer(packet, length);
 	rx_desc->des0 = (u32)(ulong)packet;
 	rx_desc->des1 = 0;
@@ -1217,7 +1276,7 @@ static int eqos_free_pkt(struct udevice *dev, uchar *packet, int length)
 	 */
 	mb();
 	rx_desc->des3 = EQOS_DESC3_OWN | EQOS_DESC3_BUF1V;
-	eqos->config->ops->eqos_flush_desc(rx_desc);
+	eqos->config->ops->eqos_flush_desc(eqos, rx_desc);
 
 	writel((ulong)rx_desc, &eqos->dma_regs->ch0_rxdesc_tail_pointer);
 
@@ -1292,7 +1351,7 @@ static int eqos_remove_resources_core(struct udevice *dev)
 	free(eqos->rx_pkt);
 	free(eqos->rx_dma_buf);
 	free(eqos->tx_dma_buf);
-	eqos_free_descs(eqos->descs);
+	eqos_free_descs(eqos);
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -1372,7 +1431,7 @@ err_free_reset_eqos:
 
 /* board-specific Ethernet Interface initializations. */
 __weak int board_interface_eth_init(struct udevice *dev,
-				    phy_interface_t interface_type)
+				    phy_interface_t interface_type, ulong rate)
 {
 	return 0;
 }
@@ -1382,6 +1441,7 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	int ret;
 	phy_interface_t interface;
+	ulong rate = 0;
 
 	debug("%s(dev=%p):\n", __func__, dev);
 
@@ -1392,7 +1452,15 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	ret = board_interface_eth_init(dev, interface);
+	/*  Get ETH_CLK clocks (optional) */
+	ret = clk_get_by_name(dev, "eth-ck", &eqos->clk_ck);
+	if (ret)
+		debug("No phy clock provided %d", ret);
+	else
+		rate = clk_get_rate(&eqos->clk_ck);
+
+	/*  Initialize the soc for the PHY configuration */
+	ret = board_interface_eth_init(dev, interface, rate);
 	if (ret)
 		return -EINVAL;
 
@@ -1414,10 +1482,14 @@ static int eqos_probe_resources_stm32(struct udevice *dev)
 		goto err_free_clk_rx;
 	}
 
-	/*  Get ETH_CLK clocks (optional) */
-	ret = clk_get_by_name(dev, "eth-ck", &eqos->clk_ck);
-	if (ret)
-		pr_warn("No phy clock provided %d", ret);
+#ifdef CONFIG_DM_REGULATOR
+	/* check presence of optional regulator */
+	ret = device_get_supply_regulator(dev, "phy-supply", &eqos->phy_supply);
+	if (ret && ret != -ENOENT) {
+		pr_err("device_get_supply_regulator failed: %d", ret);
+		goto err_free_clk_rx;
+	}
+#endif
 
 	debug("%s: OK\n", __func__);
 	return 0;
@@ -1604,6 +1676,7 @@ static struct eqos_ops eqos_tegra186_ops = {
 	.eqos_stop_clks = eqos_stop_clks_tegra186,
 	.eqos_start_clks = eqos_start_clks_tegra186,
 	.eqos_calibrate_pads = eqos_calibrate_pads_tegra186,
+	.eqos_phy_power_on = eqos_null_ops,
 	.eqos_disable_calibration = eqos_disable_calibration_tegra186,
 	.eqos_set_tx_clk_speed = eqos_set_tx_clk_speed_tegra186,
 	.eqos_get_enetaddr = eqos_null_ops,
@@ -1633,6 +1706,7 @@ static struct eqos_ops eqos_stm32_ops = {
 	.eqos_stop_clks = eqos_stop_clks_stm32,
 	.eqos_start_clks = eqos_start_clks_stm32,
 	.eqos_calibrate_pads = eqos_null_ops,
+	.eqos_phy_power_on = eqos_phy_power_on_stm32,
 	.eqos_disable_calibration = eqos_null_ops,
 	.eqos_set_tx_clk_speed = eqos_null_ops,
 	.eqos_get_enetaddr = eqos_null_ops,
@@ -1650,6 +1724,28 @@ static const struct eqos_config __maybe_unused eqos_stm32_config = {
 	.ops = &eqos_stm32_ops
 };
 
+static const struct eqos_config __maybe_unused eqos_stm32mp13_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 50,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
+	.axi_bus_width = EQOS_AXI_WIDTH_32,
+	.interface = dev_read_phy_mode,
+	.ops = &eqos_stm32_ops
+};
+
+static const struct eqos_config eqos_stm32mp25_config = {
+	.reg_access_always_ok = false,
+	.mdio_wait = 10000,
+	.swr_wait = 50,
+	.config_mac = EQOS_MAC_RXQ_CTRL0_RXQ0EN_ENABLED_DCB,
+	.config_mac_mdio = EQOS_MAC_MDIO_ADDRESS_CR_250_300,
+	.axi_bus_width = EQOS_AXI_WIDTH_64,
+	.interface = dev_read_phy_mode,
+	.ops = &eqos_stm32_ops
+};
+
 static const struct udevice_id eqos_ids[] = {
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_TEGRA186)
 	{
@@ -1662,6 +1758,14 @@ static const struct udevice_id eqos_ids[] = {
 		.compatible = "st,stm32mp1-dwmac",
 		.data = (ulong)&eqos_stm32_config
 	},
+	{
+		.compatible = "st,stm32mp13-dwmac",
+		.data = (ulong)&eqos_stm32mp13_config
+	},
+	{
+		.compatible = "st,stm32mp25-dwmac",
+		.data = (ulong)&eqos_stm32mp25_config
+	},
 #endif
 #if IS_ENABLED(CONFIG_DWC_ETH_QOS_IMX)
 	{
diff --git a/drivers/net/dwc_eth_qos.h b/drivers/net/dwc_eth_qos.h
index b35e774263..e024043075 100644
--- a/drivers/net/dwc_eth_qos.h
+++ b/drivers/net/dwc_eth_qos.h
@@ -162,6 +162,7 @@ struct eqos_dma_regs {
 #define EQOS_DMA_SYSBUS_MODE_BLEN4			BIT(1)
 
 #define EQOS_DMA_CH0_CONTROL_DSL_SHIFT			18
+#define EQOS_DMA_CH0_CONTROL_DSL_MAX			7
 #define EQOS_DMA_CH0_CONTROL_PBLX8			BIT(16)
 
 #define EQOS_DMA_CH0_TX_CONTROL_TXPBL_SHIFT		16
@@ -226,9 +227,11 @@ struct eqos_config {
 	struct eqos_ops *ops;
 };
 
+struct eqos_priv;
+
 struct eqos_ops {
-	void (*eqos_inval_desc)(void *desc);
-	void (*eqos_flush_desc)(void *desc);
+	void (*eqos_inval_desc)(struct eqos_priv *eqos, void *desc);
+	void (*eqos_flush_desc)(struct eqos_priv *eqos, void *desc);
 	void (*eqos_inval_buffer)(void *buf, size_t size);
 	void (*eqos_flush_buffer)(void *buf, size_t size);
 	int (*eqos_probe_resources)(struct udevice *dev);
@@ -238,6 +241,7 @@ struct eqos_ops {
 	int (*eqos_stop_clks)(struct udevice *dev);
 	int (*eqos_start_clks)(struct udevice *dev);
 	int (*eqos_calibrate_pads)(struct udevice *dev);
+	int (*eqos_phy_power_on)(struct udevice *dev);
 	int (*eqos_disable_calibration)(struct udevice *dev);
 	int (*eqos_set_tx_clk_speed)(struct udevice *dev);
 	int (*eqos_get_enetaddr)(struct udevice *dev);
@@ -273,10 +277,14 @@ struct eqos_priv {
 	bool started;
 	bool reg_access_ok;
 	bool clk_ck_enabled;
+	bool use_cached_mem;
+#ifdef CONFIG_DM_REGULATOR
+	struct udevice *phy_supply;
+#endif
 };
 
-void eqos_inval_desc_generic(void *desc);
-void eqos_flush_desc_generic(void *desc);
+void eqos_inval_desc_generic(struct eqos_priv *eqos, void *desc);
+void eqos_flush_desc_generic(struct eqos_priv *eqos, void *desc);
 void eqos_inval_buffer_generic(void *buf, size_t size);
 void eqos_flush_buffer_generic(void *buf, size_t size);
 int eqos_null_ops(struct udevice *dev);
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index c25b42c68f..530e2fe461 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -178,6 +178,14 @@ config PHY_STM32_USBPHYC
 	  between an HS USB OTG controller and an HS USB Host controller,
 	  selected by an USB switch.
 
+config PHY_STM32_USB2PHY
+	tristate "STMicroelectronics STM32 USB2 PHY Controller driver"
+	depends on PHY && ARCH_STM32MP
+	help
+	  Enable this to support the High-Speed USB2 transceivers that are part
+	  of some STMicroelectronics STM32 SoCs. The PHY integrated is from
+	  synopsys, and called USB2-PHY
+
 config MESON_GXBB_USB_PHY
 	bool "Amlogic Meson GXBB USB PHY"
 	depends on PHY && ARCH_MESON && MESON_GXBB
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index d95439c425..c650a4ffa1 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_PHY_QCOM_IPQ4019_USB) += phy-qcom-ipq4019-usb.o
 obj-$(CONFIG_PHY_RCAR_GEN2) += phy-rcar-gen2.o
 obj-$(CONFIG_PHY_RCAR_GEN3) += phy-rcar-gen3.o
 obj-$(CONFIG_PHY_STM32_USBPHYC) += phy-stm32-usbphyc.o
+obj-$(CONFIG_PHY_STM32_USB2PHY) += phy-stm32-usb2phy.o
 obj-$(CONFIG_MESON_GXBB_USB_PHY) += meson-gxbb-usb2.o
 obj-$(CONFIG_MESON_GXL_USB_PHY) += meson-gxl-usb2.o
 obj-$(CONFIG_MESON_G12A_USB_PHY) += meson-g12a-usb2.o meson-g12a-usb3-pcie.o
diff --git a/drivers/phy/phy-stm32-usb2phy.c b/drivers/phy/phy-stm32-usb2phy.c
new file mode 100644
index 0000000000..cc68319bf1
--- /dev/null
+++ b/drivers/phy/phy-stm32-usb2phy.c
@@ -0,0 +1,643 @@
+// SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_PHY
+
+#include <asm/io.h>
+#include <common.h>
+#include <clk.h>
+#include <clk-uclass.h>
+#include <div64.h>
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <dm/of_access.h>
+#include <fdtdec.h>
+#include <generic-phy.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/usb/otg.h>
+#include <log.h>
+#include <power/regulator.h>
+#include <regmap.h>
+#include <reset.h>
+#include <syscon.h>
+#include <usb.h>
+
+#define PHY1CR_OFFSET		0x2400
+#define PHY1TRIM1_OFFSET	0x240C
+#define PHY1TRIM2_OFFSET	0x2410
+#define PHY2CR_OFFSET		0x2800
+#define PHY2TRIM1_OFFSET	0x2808
+#define PHY2TRIM2_OFFSET	0x280C
+
+#define PHYCR_REG      1
+
+/* Retention mode enable (active low) */
+#define SYSCFG_USB2PHY2CR_RETENABLEN2_MASK		BIT(0)
+/*
+ * Auto-resume mode enable. Enables auto-resume logic in USB2PHY so that the PHY automatically
+ * responds to a remote wake-up without initial involvement of the Host controller.
+ */
+#define SYSCFG_USB2PHY2CR_AUTORSMENB2_MASK		BIT(1)
+/* Controls the power down of analog blocks during Suspend and Sleep. */
+#define SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK		BIT(2)
+/* Controls vbus valid input of USB3 DRD controller when in Host mode */
+#define SYSCFG_USB2PHY2CR_VBUSVALID_MASK		BIT(4)
+/* Selects VBUS valid comparator that is used when USB3 DRD controller is in Device mode */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK		BIT(5)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK		BIT(6)
+/*
+ * 0: internal debounce logic is enabled (default).
+ * Bit0: applies to utmiotg_vbusvalid,
+ * Bit1: applies to pipe3_PowerPresent,
+ * Bit2: applies to utmisrp_bvalid,
+ * Bit3: applies to utmiotg_iddig]. (default)
+ */
+#define SYSCFG_USB2PHY2CR_FILTER_BYPASS_MASK		GENMASK(10, 7)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_OTGDISABLE0_MASK		BIT(16)
+/* Voltage comparison result when an external voltage comparator is used */
+#define SYSCFG_USB2PHY2CR_DRVVBUS0_MASK			BIT(17)
+
+#define SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK		GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK		GENMASK(5, 2)
+#define SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK		GENMASK(8, 6)
+#define SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK		GENMASK(11, 9)
+#define SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK		GENMASK(13, 12)
+#define SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK		GENMASK(16, 14)
+#define SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK		GENMASK(18, 17)
+#define SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK		GENMASK(22, 19)
+#define SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK		GENMASK(26, 23)
+#define SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK		GENMASK(28, 27)
+#define SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK		GENMASK(30, 29)
+
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK	GENMASK(1, 0)
+#define SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK	BIT(2)
+
+struct stm32_usb2phy {
+	struct regmap *regmap;
+	struct clk clk;
+	struct reset_ctl reset;
+	struct udevice *vdd33;
+	struct udevice *vdda18;
+	uint init;
+	bool internal_vbus_comp;
+	const struct stm32mp2_usb2phy_hw_data *hw_data;
+};
+
+enum stm32_usb2phy_mode {
+	USB2_MODE_HOST_ONLY = 0x1,
+	USB2_MODE_DRD = 0x3,
+};
+
+struct stm32mp2_usb2phy_hw_data {
+	u32 phyrefsel_mask, phyrefsel_bitpos, cr_offset, trim1_offset, trim2_offset;
+	enum stm32_usb2phy_mode valid_mode;
+};
+
+static const struct stm32mp2_usb2phy_hw_data stm32mp2_usb2phy_hwdata[] = {
+	{
+		.cr_offset = PHY1CR_OFFSET,
+		.trim1_offset = PHY1TRIM1_OFFSET,
+		.trim2_offset = PHY1TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_HOST_ONLY,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 4,
+	},
+	{
+		.cr_offset = PHY2CR_OFFSET,
+		.trim1_offset = PHY2TRIM1_OFFSET,
+		.trim2_offset = PHY2TRIM2_OFFSET,
+		.valid_mode = USB2_MODE_DRD,
+		.phyrefsel_mask = 0x7,
+		.phyrefsel_bitpos = 12,
+	}
+};
+
+/*
+ * Two phy instances are found in mp25, and some bitfields are a bit different (shift...)
+ * depending on the instance. So identify the instance by using CR offset to report
+ * the correct bitfields & modes to use
+ */
+static const struct stm32mp2_usb2phy_hw_data *stm32_usb2phy_get_hwdata(unsigned long offset)
+{
+	int i;
+
+	for (i = 0; i < sizeof(stm32mp2_usb2phy_hwdata); i++)
+		if (stm32mp2_usb2phy_hwdata[i].cr_offset == offset)
+			break;
+
+	if (i < sizeof(stm32mp2_usb2phy_hwdata))
+		return &stm32mp2_usb2phy_hwdata[i];
+
+	return NULL;
+}
+
+static int stm32_usb2phy_getrefsel(unsigned long rate)
+{
+	switch (rate) {
+	case 19200000:
+		return 0;
+	case 20000000:
+		return 1;
+	case 24000000:
+		return 2;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int stm32_usb2phy_regulators_enable(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+
+	ret = regulator_set_enable_if_allowed(phy_dev->vdd33, true);
+	if (ret)
+		return ret;
+
+	if (phy_dev->vdda18) {
+		ret = regulator_set_enable_if_allowed(phy_dev->vdda18, true);
+		if (ret)
+			goto vdd33_disable;
+	}
+
+	return 0;
+
+vdd33_disable:
+	regulator_set_enable(phy_dev->vdd33, false);
+
+	return ret;
+}
+
+static int stm32_usb2phy_regulators_disable(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+
+	if (phy_dev->vdda18) {
+		ret = regulator_set_enable_if_allowed(phy_dev->vdda18, false);
+		if (ret)
+			return ret;
+	}
+
+	ret = regulator_set_enable_if_allowed(phy_dev->vdd33, false);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int stm32_usb2phy_init(struct phy *phy)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	struct udevice *dev = phy->dev;
+	unsigned long phyref_rate;
+	u32 phyrefsel;
+	const struct stm32mp2_usb2phy_hw_data *phy_data = phy_dev->hw_data;
+
+	if (phy_dev->init) {
+		phy_dev->init++;
+		return 0;
+	}
+
+	ret = stm32_usb2phy_regulators_enable(phy);
+	if (ret) {
+		dev_err(dev, "can't enable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	ret = clk_enable(&phy_dev->clk);
+	if (ret) {
+		dev_err(dev, "could not enable clock: %d\n", ret);
+		goto error_regl_dis;
+	}
+
+	phyref_rate = clk_get_rate(&phy_dev->clk);
+
+	ret = stm32_usb2phy_getrefsel(phyref_rate);
+	if (ret < 0) {
+		dev_err(dev, "invalid phyref clk rate\n");
+		goto error_clk_dis;
+	}
+	phyrefsel = (u32)ret;
+	dev_dbg(dev, "phyrefsel value (%d)\n", phyrefsel);
+
+	ret = regmap_update_bits(phy_dev->regmap,
+				 phy_data->cr_offset,
+				 phy_data->phyrefsel_mask << phy_data->phyrefsel_bitpos,
+				 phyrefsel << phy_data->phyrefsel_bitpos);
+	if (ret) {
+		dev_err(dev, "can't set phyrefclksel (%d)\n", ret);
+		goto error_clk_dis;
+	}
+
+	ret = reset_deassert(&phy_dev->reset);
+	if (ret) {
+		dev_err(dev, "can't release reset (%d)\n", ret);
+		goto error_clk_dis;
+	}
+
+	phy_dev->init++;
+
+	return 0;
+
+error_clk_dis:
+	clk_disable(&phy_dev->clk);
+error_regl_dis:
+	stm32_usb2phy_regulators_disable(phy);
+
+	return ret;
+}
+
+static int stm32_usb2phy_exit(struct phy *phy)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	int ret;
+
+        if (!phy_dev->init) {
+		dev_err(phy->dev, "Invalid ref-count for phy\n");
+		return -EINVAL;
+	}
+
+	phy_dev->init--;
+
+	if (phy_dev->init)
+		return 0;
+
+	ret = clk_disable(&phy_dev->clk);
+	if (ret)
+		return ret;
+
+	ret = stm32_usb2phy_regulators_disable(phy);
+	if (ret) {
+		dev_err(phy->dev, "can't disable regulators (%d)\n", ret);
+		return ret;
+	}
+
+	return reset_assert(&phy_dev->reset);
+}
+
+static int stm32_usb2phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	int ret;
+	struct stm32_usb2phy *phy_dev = dev_get_priv(phy->dev);
+	const struct stm32mp2_usb2phy_hw_data *phy_data = phy_dev->hw_data;
+	struct udevice *dev = phy->dev;
+
+	switch (mode) {
+	case PHY_MODE_USB_HOST:
+		if (phy_data->valid_mode == USB2_MODE_HOST_ONLY)
+			/*
+			 * CMN bit cleared since OHCI-ctrl registers are inaccessible
+			 * when clocks (clk12+clk48) are turned off in Suspend which
+			 * makes it impossible to resume
+			 */
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK,
+						 0);
+		else {
+			/*
+			 * CMN bit cleared since when running in usb3speed with dwc3-usb
+			 * xHCI ctrl is (most likely) suspending the (unused) usb2phy2
+			 * and when the clocks (utmi_clk) input to usb3dr-ctrl from usb2phy2
+			 * are turned off, there is some internal error inside the usb3dr-ctrl
+			 * while running in usb3-speed
+			 */
+			if (!phy_dev->internal_vbus_comp && submode == USB_ROLE_NONE) {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK, 0);
+			} else {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK);
+			}
+		}
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	case PHY_MODE_USB_DEVICE:
+		/*
+		 * USB DWC3 gadget driver (in uboot) first sets the RUN bit, and
+		 * later it performs the device-mode conf init.
+		 * Hence USB2PHY2CMN bit of PHY needs to be cleared, since incase
+		 * VBUS is not present then usb-ctrl puts PHY in suspend and inturn
+		 * PHY turns off clocks to ctrl which makes the device-mode init fail
+		 */
+		if (phy_dev->internal_vbus_comp) {
+			ret = regmap_update_bits(phy_dev->regmap,
+						 phy_data->cr_offset,
+						 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+						 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+						 0);
+		} else {
+			if (submode == USB_ROLE_NONE) {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK);
+			} else {
+				ret = regmap_update_bits(phy_dev->regmap,
+							 phy_data->cr_offset,
+							 SYSCFG_USB2PHY2CR_USB2PHY2CMN_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVALID_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK,
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXTSEL_MASK |
+							 SYSCFG_USB2PHY2CR_VBUSVLDEXT_MASK);
+			}
+		}
+		if (ret) {
+			dev_err(dev, "can't set usb2phycr (%d)\n", ret);
+			return ret;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int stm32_usb2phy_tuning(struct udevice *dev, ofnode node)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(dev);
+	u32 mask_trim1 = 0, value_trim1 = 0, mask_trim2 = 0, value_trim2 = 0, val;
+	int ret;
+
+	ret = ofnode_read_u32(node, "st,pll-ipath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLITUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ipath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,pll-ppath-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && val <= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_PLLPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting pll-ppath-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,comp-dis-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_COMPDISTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting comp-dis-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,sqrx-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_SQRXTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting sqrx-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,vdatref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_VDATREFTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting vdatref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,otg-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_OTGTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting otg-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txhsxv-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXHSXVTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txhsxv-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txfsls-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXFSLSTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txfsls-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txvref-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXVREFTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txvref-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txrise-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRISETUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txrise-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txres-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK, val)) {
+			mask_trim1 |= SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK;
+			value_trim1 |= FIELD_PREP(SYSCFG_USB2PHYTRIM1_TXRESTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txres-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txpreempamp-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK, val)) {
+			mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK;
+			value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPAMPTUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txpreempamp-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ofnode_read_u32(node, "st,txpreemppulse-tune", &val);
+	if (ret != -EINVAL) {
+		if (!ret && FIELD_FIT(SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK, val)) {
+			mask_trim2 |= SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK;
+			value_trim2 |= FIELD_PREP(SYSCFG_USB2PHYTRIM2_TXPREEMPPULSETUNE_MASK, val);
+		} else {
+			dev_err(dev, "Error getting txpreemppulse-tune property (%d)\n", ret);
+			return ret;
+		}
+	}
+
+	if (mask_trim1) {
+		ret = regmap_update_bits(phy_dev->regmap,
+					 phy_dev->hw_data->trim1_offset,
+					 mask_trim1,
+					 value_trim1);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim1 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim1 mask = %x value = %x\n", mask_trim1, value_trim1);
+	}
+
+	if (mask_trim2) {
+		ret = regmap_update_bits(phy_dev->regmap,
+					 phy_dev->hw_data->trim2_offset,
+					 mask_trim2,
+					 value_trim2);
+		if (ret) {
+			dev_err(dev, "can't set usb2phytrim2 (%d)\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "usb2phytrim2 mask = %x value = %x\n", mask_trim2, value_trim2);
+	}
+
+	return 0;
+}
+
+static const struct phy_ops stm32_usb2phy_ops = {
+	.init = stm32_usb2phy_init,
+	.exit = stm32_usb2phy_exit,
+	.set_mode = stm32_usb2phy_set_mode,
+};
+
+static int stm32_usb2phy_probe(struct udevice *dev)
+{
+	struct stm32_usb2phy *phy_dev = dev_get_priv(dev);
+	ofnode node = dev_ofnode(dev);
+	int ret;
+	u32 phycr;
+
+	phy_dev->regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg");
+	if (IS_ERR(phy_dev->regmap)) {
+		dev_err(dev, "unable to find regmap\n");
+		return PTR_ERR(phy_dev->regmap);
+	}
+
+	ret = dev_read_u32_index(dev, "st,syscfg", PHYCR_REG, &phycr);
+	if (ret) {
+		dev_err(dev, "Can't get sysconfig phycr offset (%d)\n", ret);
+		return ret;
+	}
+	dev_dbg(dev, "phycr offset 0x%x\n", phycr);
+
+	ret = clk_get_by_index(dev, 0, &phy_dev->clk);
+	if (ret)
+		return ret;
+
+	ret = reset_get_by_index(dev, 0, &phy_dev->reset);
+	if (ret)
+		return ret;
+
+	ret = device_get_supply_regulator(dev, "vdd33-supply", &phy_dev->vdd33);
+	if (ret) {
+		dev_err(dev, "Can't get vdd33-supply regulator\n");
+		return ret;
+	}
+
+	/* Vdda18 regulator is optional */
+	ret = device_get_supply_regulator(dev, "vdda18-supply", &phy_dev->vdda18);
+	if (ret) {
+		if (ret != -ENOENT)
+			return ret;
+		dev_dbg(dev, "Can't get vdda18-supply regulator\n");
+	}
+
+	phy_dev->hw_data = stm32_usb2phy_get_hwdata(phycr);
+	if (!phy_dev->hw_data) {
+		dev_err(dev, "can't get matching stm32mp2_usb2_of_data\n");
+		return -EINVAL;
+	}
+
+	if (phy_dev->hw_data->valid_mode != USB2_MODE_HOST_ONLY) {
+		phy_dev->internal_vbus_comp = ofnode_read_bool(node, "st,internal-vbus-comp");
+		dev_dbg(dev, "Using usb2phy %s VBUS Comparator\n",
+			phy_dev->internal_vbus_comp ? "Internal" : "External");
+	}
+
+	/* Configure phy tuning */
+	ret = stm32_usb2phy_tuning(dev, node);
+	if (ret) {
+		dev_err(dev, "can't set tuning parameters: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id stm32_usb2phy_of_match[] = {
+	{ .compatible = "st,stm32mp25-usb2phy", },
+	{ },
+};
+
+U_BOOT_DRIVER(stm32_usb2phy) = {
+	.name = "stm32-usb2phy",
+	.id = UCLASS_PHY,
+	.of_match = stm32_usb2phy_of_match,
+	.ops = &stm32_usb2phy_ops,
+	.probe = stm32_usb2phy_probe,
+	.priv_auto	= sizeof(struct stm32_usb2phy),
+};
diff --git a/drivers/phy/phy-stm32-usbphyc.c b/drivers/phy/phy-stm32-usbphyc.c
index 9f0b7d7118..77abdfc862 100644
--- a/drivers/phy/phy-stm32-usbphyc.c
+++ b/drivers/phy/phy-stm32-usbphyc.c
@@ -17,7 +17,9 @@
 #include <syscon.h>
 #include <usb.h>
 #include <asm/io.h>
+#include <dm/device.h>
 #include <dm/device_compat.h>
+#include <dm/device-internal.h>
 #include <dm/lists.h>
 #include <dm/of_access.h>
 #include <linux/bitfield.h>
@@ -375,7 +377,7 @@ static int stm32_usbphyc_phy_power_off(struct phy *phy)
 		return 0;
 
 	if (usbphyc_phy->vbus) {
-		ret = regulator_set_enable(usbphyc_phy->vbus, false);
+		ret = regulator_set_enable_if_allowed(usbphyc_phy->vbus, false);
 		if (ret)
 			return ret;
 	}
@@ -633,6 +635,7 @@ U_BOOT_DRIVER(stm32_usb_phyc) = {
 
 struct stm32_usbphyc_clk {
 	bool enable;
+	struct clk clkp;
 };
 
 static ulong stm32_usbphyc_clk48_get_rate(struct clk *clk)
@@ -687,9 +690,25 @@ const struct clk_ops usbphyc_clk48_ops = {
 	.disable = stm32_usbphyc_clk48_disable,
 };
 
+int usbphyc_clk48_probe(struct udevice *dev)
+{
+	struct stm32_usbphyc_clk *priv = dev_get_priv(dev);
+
+	/* prepare clkp to correctly register clock with CCF */
+	priv->clkp.dev = dev;
+	priv->clkp.id = CLK_ID(dev, 0);
+
+	/* Store back pointer to clk from udevice */
+	/* FIXME: This is not allowed...should be allocated by driver model */
+	dev_set_uclass_priv(dev, &priv->clkp);
+
+	return 0;
+}
+
 U_BOOT_DRIVER(stm32_usb_phyc_clk) = {
 	.name = "stm32-usbphyc-clk",
 	.id = UCLASS_CLK,
 	.ops = &usbphyc_clk48_ops,
+	.probe = &usbphyc_clk48_probe,
 	.priv_auto = sizeof(struct stm32_usbphyc_clk),
 };
diff --git a/drivers/phy/phy-uclass.c b/drivers/phy/phy-uclass.c
index 8b84da3ce0..9b2d2bcc0f 100644
--- a/drivers/phy/phy-uclass.c
+++ b/drivers/phy/phy-uclass.c
@@ -351,6 +351,17 @@ int generic_phy_configure(struct phy *phy, void *params)
 	return ops->configure ? ops->configure(phy, params) : 0;
 }
 
+int generic_phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	struct phy_ops const *ops;
+
+	if (!generic_phy_valid(phy))
+		return 0;
+	ops = phy_dev_ops(phy->dev);
+
+	return ops->set_mode ? ops->set_mode(phy, mode, submode) : 0;
+}
+
 int generic_phy_get_bulk(struct udevice *dev, struct phy_bulk *bulk)
 {
 	int i, ret, count;
@@ -455,6 +466,64 @@ int generic_phy_power_off_bulk(struct phy_bulk *bulk)
 	return ret;
 }
 
+int generic_setup_phy(struct udevice *dev, struct phy *phy, int index)
+{
+	int ret = 0;
+
+	if (!phy)
+		return 0;
+
+	ret = generic_phy_get_by_index(dev, index, phy);
+	if (ret) {
+		if (ret != -ENOENT)
+			return ret;
+	} else {
+		ret = generic_phy_init(phy);
+		if (ret)
+			return ret;
+
+		ret = generic_phy_power_on(phy);
+		if (ret)
+			ret = generic_phy_exit(phy);
+	}
+
+	return ret;
+}
+
+int generic_shutdown_phy(struct phy *phy)
+{
+	int ret = 0;
+
+	if (!phy)
+		return 0;
+
+	if (generic_phy_valid(phy)) {
+		ret = generic_phy_power_off(phy);
+		if (ret)
+			return ret;
+
+		ret = generic_phy_exit(phy);
+	}
+
+	return ret;
+}
+
+int generic_phy_set_mode_bulk(struct phy_bulk *bulk, enum phy_mode mode, int submode)
+{
+	struct phy *phys = bulk->phys;
+	int i, ret;
+
+	for (i = 0; i < bulk->count; i++) {
+		ret = generic_phy_set_mode(&phys[i], mode, submode);
+		if (ret) {
+			pr_err("Can't set mode on PHY%d\n", i);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 UCLASS_DRIVER(phy) = {
 	.id		= UCLASS_PHY,
 	.name		= "phy",
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index b6ef2acced..aa72701a92 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -210,6 +210,14 @@ config PINCTRL_INTEL
 	  driver which must be separately enabled. The driver supports setting
 	  pins on start-up and changing the GPIO attributes.
 
+config PINCTRL_MCP23017
+	bool "Microchip MCP23017 pinctrl driver"
+	help
+	  I2C driver for Microchip MCP23017 16-Bit I/O Expander.
+	  The driver is controlled by a device tree node which contains both
+	  the GPIO definitions and pin control functions for each available
+	  multiplex function.
+
 config PINCTRL_PIC32
 	bool "Microchip PIC32 pin-control and pin-mux driver"
 	depends on DM && MACH_PIC32
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index 3b167d099f..23f97eaf43 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_PINCTRL_UNIPHIER)	+= uniphier/
 obj-$(CONFIG_PINCTRL_PIC32)	+= pinctrl_pic32.o
 obj-$(CONFIG_PINCTRL_EXYNOS)	+= exynos/
 obj-$(CONFIG_PINCTRL_K210)	+= pinctrl-k210.o
+obj-$(CONFIG_PINCTRL_MCP23017)	+= pinctrl-mcp23017.o
 obj-$(CONFIG_PINCTRL_MESON)	+= meson/
 obj-$(CONFIG_PINCTRL_MTK)	+= mediatek/
 obj-$(CONFIG_PINCTRL_MSCC)	+= mscc/
diff --git a/drivers/pinctrl/pinctrl-mcp23017.c b/drivers/pinctrl/pinctrl-mcp23017.c
new file mode 100644
index 0000000000..78eb9086c0
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-mcp23017.c
@@ -0,0 +1,411 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * Driver for Microchip MCP23017 16-Bit I/O Expander with I2C interface
+ */
+
+#define LOG_CATEGORY UCLASS_PINCTRL
+
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <i2c.h>
+#include <reset.h>
+#include <asm/gpio.h>
+#include <dm/device.h>
+#include <dm/device-internal.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <dm/pinctrl.h>
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <power/regulator.h>
+
+/* register offset for IOCON.BANK = 0, the normal mode at reset */
+#define MCP_REG_IODIR	0x00		/* init/reset:  all ones */
+#define MCP_REG_IOCON	0x0A
+#define IOCON_SEQOP	BIT(5)
+#define MCP_REG_GPPU	0x0C
+#define MCP_REG_GPIO	0x12
+
+#define MCP_REG_SIZE	8
+#define MCP_MAX_GPIO	16
+
+static int mcp23017_read(struct udevice *dev, uint offset)
+{
+	return  dm_i2c_reg_read(dev_get_parent(dev), offset);
+}
+
+static int mcp23017_write(struct udevice *dev, uint reg, unsigned int val)
+{
+	dev_dbg(dev, "%s reg = 0x%x val = 0x%x\n", __func__, reg, val);
+
+	return dm_i2c_reg_write(dev_get_parent(dev), reg, val);
+}
+
+static int mcp23017_read_reg(struct udevice *dev, u8 reg, uint offset)
+{
+	u8 mask = BIT(offset);
+	int ret;
+
+	ret = mcp23017_read(dev, reg);
+
+	dev_dbg(dev, "%s reg = 0x%x offset = %d ret = 0x%x mask = 0x%x\n",
+		__func__, reg, offset, ret, mask);
+
+	return ret < 0 ? ret : !!(ret & mask);
+}
+
+static int mcp23017_write_reg(struct udevice *dev, u8 reg, uint offset,
+			      uint val)
+{
+	u8 mask = BIT(offset);
+	int ret;
+
+	ret = mcp23017_read(dev, reg);
+	if (ret < 0)
+		return ret;
+	ret = (ret & ~mask) | (val ? mask : 0);
+
+	return mcp23017_write(dev, reg, ret);
+}
+
+static int mcp23017_conf_set_gppu(struct udevice *dev, unsigned int offset,
+				  uint pupd)
+{
+	int reg = MCP_REG_GPPU + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	return mcp23017_write_reg(dev, reg, bit, pupd);
+}
+
+static int mcp23017_conf_get_gppu(struct udevice *dev, unsigned int offset)
+{
+	int reg = MCP_REG_GPPU + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+	int ret = mcp23017_read_reg(dev, reg, bit);
+
+	return ret;
+}
+
+static int mcp23017_gpio_get(struct udevice *dev, unsigned int offset)
+{
+	int reg = MCP_REG_GPIO + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+	int ret = mcp23017_read_reg(dev, reg, bit);
+
+	return ret;
+}
+
+static int mcp23017_gpio_set(struct udevice *dev, unsigned int offset, int value)
+{
+	int reg = MCP_REG_GPIO + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	return mcp23017_write_reg(dev, reg, bit, value);
+}
+
+static int mcp23017_gpio_get_function(struct udevice *dev, unsigned int offset)
+{
+	int ret;
+	int reg = MCP_REG_IODIR + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	ret = mcp23017_read_reg(dev, reg, bit);
+
+	if (ret < 0)
+		return ret;
+	/* On mcp23017, gpio pins direction is (0)output, (1)input. */
+	return ret ? GPIOF_INPUT : GPIOF_OUTPUT;
+}
+
+static int mcp23017_gpio_direction_input(struct udevice *dev, unsigned int offset)
+{
+	int reg = MCP_REG_IODIR + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+
+	return mcp23017_write_reg(dev, reg, bit, 1);
+}
+
+static int mcp23017_gpio_direction_output(struct udevice *dev,
+					  unsigned int offset, int value)
+{
+	int reg = MCP_REG_IODIR + offset / MCP_REG_SIZE;
+	int bit = offset % MCP_REG_SIZE;
+	int ret = mcp23017_gpio_set(dev, offset, value);
+
+	if (ret < 0)
+		return ret;
+
+	return mcp23017_write_reg(dev, reg, bit, 0);
+}
+
+static int mcp23017_gpio_set_flags(struct udevice *dev, unsigned int offset,
+				   ulong flags)
+{
+	int ret = -ENOTSUPP;
+
+	if (flags & GPIOD_IS_OUT) {
+		bool value = flags & GPIOD_IS_OUT_ACTIVE;
+
+		if (flags & GPIOD_OPEN_SOURCE)
+			return -ENOTSUPP;
+		if (flags & GPIOD_OPEN_DRAIN)
+			return -ENOTSUPP;
+		ret = mcp23017_gpio_direction_output(dev, offset, value);
+	} else if (flags & GPIOD_IS_IN) {
+		ret = mcp23017_gpio_direction_input(dev, offset);
+		if (ret)
+			return ret;
+		if (flags & GPIOD_PULL_UP) {
+			ret = mcp23017_conf_set_gppu(dev, offset, 1);
+			if (ret)
+				return ret;
+		} else {
+			ret = mcp23017_conf_set_gppu(dev, offset, 0);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return ret;
+}
+
+static int mcp23017_gpio_get_flags(struct udevice *dev, unsigned int offset,
+				   ulong *flags)
+{
+	ulong dir_flags = 0;
+	int ret;
+
+	if (mcp23017_gpio_get_function(dev, offset) == GPIOF_OUTPUT) {
+		dir_flags |= GPIOD_IS_OUT;
+
+		ret = mcp23017_gpio_get(dev, offset);
+		if (ret < 0)
+			return ret;
+		if (ret)
+			dir_flags |= GPIOD_IS_OUT_ACTIVE;
+	} else {
+		dir_flags |= GPIOD_IS_IN;
+
+		ret = mcp23017_conf_get_gppu(dev, offset);
+		if (ret < 0)
+			return ret;
+		if (ret == 1)
+			dir_flags |= GPIOD_PULL_UP;
+	}
+	*flags = dir_flags;
+
+	return 0;
+}
+
+static int mcp23017_gpio_probe(struct udevice *dev)
+{
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(dev);
+
+	uc_priv->bank_name = "mcp_gpio";
+	uc_priv->gpio_count = MCP_MAX_GPIO;
+
+	return 0;
+}
+
+static const struct dm_gpio_ops mcp23017_gpio_ops = {
+	.set_value = mcp23017_gpio_set,
+	.get_value = mcp23017_gpio_get,
+	.get_function = mcp23017_gpio_get_function,
+	.direction_input = mcp23017_gpio_direction_input,
+	.direction_output = mcp23017_gpio_direction_output,
+	.set_flags = mcp23017_gpio_set_flags,
+	.get_flags = mcp23017_gpio_get_flags,
+};
+
+U_BOOT_DRIVER(mcp23017_gpio) = {
+	.name	= "mcp23017-gpio",
+	.id	= UCLASS_GPIO,
+	.probe	= mcp23017_gpio_probe,
+	.ops	= &mcp23017_gpio_ops,
+};
+
+#if CONFIG_IS_ENABLED(PINCONF)
+static const struct pinconf_param mcp23017_pinctrl_conf_params[] = {
+	{ "bias-pull-up", PIN_CONFIG_BIAS_PULL_UP, 0 },
+	{ "output-high", PIN_CONFIG_OUTPUT, 1 },
+	{ "output-low", PIN_CONFIG_OUTPUT, 0 },
+};
+
+static int mcp23017_pinctrl_conf_set(struct udevice *dev, unsigned int pin,
+				     unsigned int param, unsigned int arg)
+{
+	int ret, dir;
+
+	/* directly call the generic gpio function, only based on i2c parent */
+	dir = mcp23017_gpio_get_function(dev, pin);
+
+	if (dir < 0)
+		return dir;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_PULL_UP:
+		ret = mcp23017_conf_set_gppu(dev, pin, 1);
+		break;
+	case PIN_CONFIG_OUTPUT:
+		ret = mcp23017_gpio_direction_output(dev, pin, arg);
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return ret;
+}
+#endif
+
+static int mcp23017_pinctrl_get_pins_count(struct udevice *dev)
+{
+	return MCP_MAX_GPIO;
+}
+
+static char pin_name[PINNAME_SIZE];
+static const char *mcp23017_pinctrl_get_pin_name(struct udevice *dev,
+						 unsigned int selector)
+{
+	snprintf(pin_name, PINNAME_SIZE, "mcp_gpio%u", selector);
+
+	return pin_name;
+}
+
+static const char *mcp23017_pinctrl_get_pin_conf(struct udevice *dev,
+						 unsigned int pin, int func)
+{
+	int pupd;
+
+	pupd = mcp23017_conf_get_gppu(dev, pin);
+	if (pupd < 0)
+		return "";
+
+	if (pupd)
+		return "bias-pull-up";
+	else
+		return "";
+}
+
+static int mcp23017_pinctrl_get_pin_muxing(struct udevice *dev,
+					   unsigned int selector,
+					   char *buf, int size)
+{
+	int func;
+
+	func = mcp23017_gpio_get_function(dev, selector);
+	if (func < 0)
+		return func;
+
+	snprintf(buf, size, "%s ", func == GPIOF_INPUT ? "input" : "output");
+
+	strlcat(buf, mcp23017_pinctrl_get_pin_conf(dev, selector, func), size);
+
+	return 0;
+}
+
+const struct pinctrl_ops mcp23017_pinctrl_ops = {
+	.get_pins_count = mcp23017_pinctrl_get_pins_count,
+	.get_pin_name = mcp23017_pinctrl_get_pin_name,
+	.set_state = pinctrl_generic_set_state,
+	.get_pin_muxing	= mcp23017_pinctrl_get_pin_muxing,
+#if CONFIG_IS_ENABLED(PINCONF)
+	.pinconf_set = mcp23017_pinctrl_conf_set,
+	.pinconf_num_params = ARRAY_SIZE(mcp23017_pinctrl_conf_params),
+	.pinconf_params = mcp23017_pinctrl_conf_params,
+#endif
+};
+
+U_BOOT_DRIVER(mcp23017_pinctrl) = {
+	.name = "mcp23017-pinctrl",
+	.id = UCLASS_PINCTRL,
+	.ops = &mcp23017_pinctrl_ops,
+};
+
+static int mcp23017_bind(struct udevice *dev)
+{
+	int ret;
+
+	ret = device_bind_driver_to_node(dev, "mcp23017-pinctrl", "mcp23017-pinctrl",
+					 dev_ofnode(dev), NULL);
+	if (ret)
+		return ret;
+
+	return device_bind_driver_to_node(dev, "mcp23017-gpio", "mcp23017-gpio",
+					  dev_ofnode(dev), NULL);
+}
+
+static int mcp23017_chip_init(struct udevice *dev)
+{
+	int ret, iocon;
+
+	ret = dm_i2c_reg_read(dev, MCP_REG_IOCON);
+	dev_dbg(dev, "reg = 0x%x val = 0x%x\n", MCP_REG_IOCON, ret);
+	if (ret < 0) {
+		dev_err(dev, "Can't read MCP23017 IOCON register (%d)\n", ret);
+		return ret;
+	}
+
+	/* deactivate Sequential mode if activated */
+	if (ret & IOCON_SEQOP) {
+		iocon = ret & ~IOCON_SEQOP;
+
+		ret = dm_i2c_reg_write(dev, MCP_REG_IOCON, iocon);
+		if (ret < 0) {
+			dev_err(dev, "can't write IOCON register (%d)\n", ret);
+		} else {
+			/* mcp23017 has IOCON twice, make sure they are in sync */
+			ret = dm_i2c_reg_write(dev, MCP_REG_IOCON + 1, iocon);
+			if (ret < 0)
+				dev_err(dev, "can't write IOCON register (%d)\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+static int mcp23017_probe(struct udevice *dev)
+{
+	struct udevice *vdd;
+	struct reset_ctl reset;
+	int ret;
+
+	if (CONFIG_IS_ENABLED(DM_REGULATOR)) {
+		ret = device_get_supply_regulator(dev, "vdd-supply", &vdd);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "vdd regulator error:%d\n", ret);
+			return ret;
+		}
+		if (!ret) {
+			ret = regulator_set_enable(vdd, true);
+			if (ret) {
+				dev_err(dev, "vdd enable failed: %d\n", ret);
+				return ret;
+			}
+		}
+	}
+
+	ret = reset_get_by_index(dev, 0, &reset);
+	if (!ret) {
+		reset_assert(&reset);
+		udelay(2);
+		reset_deassert(&reset);
+	}
+
+	return mcp23017_chip_init(dev);
+}
+
+static const struct udevice_id mcp23017_match[] = {
+	{ .compatible = "microchip,mcp23017", },
+};
+
+U_BOOT_DRIVER(mcp23017) = {
+	.name = "mcp23017",
+	.id = UCLASS_I2C_GENERIC,
+	.of_match = of_match_ptr(mcp23017_match),
+	.probe = mcp23017_probe,
+	.bind = mcp23017_bind,
+};
diff --git a/drivers/pinctrl/pinctrl-stmfx.c b/drivers/pinctrl/pinctrl-stmfx.c
index 509e2a80e9..a82087374a 100644
--- a/drivers/pinctrl/pinctrl-stmfx.c
+++ b/drivers/pinctrl/pinctrl-stmfx.c
@@ -178,9 +178,9 @@ static int stmfx_gpio_set_flags(struct udevice *dev, unsigned int offset,
 		if (flags & GPIOD_OPEN_SOURCE)
 			return -ENOTSUPP;
 		if (flags & GPIOD_OPEN_DRAIN)
-			ret = stmfx_conf_set_type(dev, offset, 0);
-		else /* PUSH-PULL */
 			ret = stmfx_conf_set_type(dev, offset, 1);
+		else /* PUSH-PULL */
+			ret = stmfx_conf_set_type(dev, offset, 0);
 		if (ret)
 			return ret;
 		ret = stmfx_gpio_direction_output(dev, offset, value);
diff --git a/drivers/pinctrl/pinctrl_stm32.c b/drivers/pinctrl/pinctrl_stm32.c
index 990cd19286..81fa918e62 100644
--- a/drivers/pinctrl/pinctrl_stm32.c
+++ b/drivers/pinctrl/pinctrl_stm32.c
@@ -12,6 +12,7 @@
 #include <malloc.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
+#include <dm/device-internal.h>
 #include <dm/device_compat.h>
 #include <dm/lists.h>
 #include <dm/pinctrl.h>
@@ -27,6 +28,13 @@
 #define PUPD_MASK			3
 #define OTYPE_MSK			1
 #define AFR_MASK			0xF
+#define SECCFG_MSK			1
+#define ADVCFGR_MASK			0xF
+#define DELAYR_MASK			0xF
+#define ADVCFGR_DLYPATH_POS		0
+#define ADVCFGR_DE_POS			1
+#define ADVCFGR_INVCLK_POS		2
+#define ADVCFGR_RET_POS			3
 
 struct stm32_pinctrl_priv {
 	struct hwspinlock hws;
@@ -39,6 +47,14 @@ struct stm32_gpio_bank {
 	struct list_head list;
 };
 
+struct stm32_pinctrl_data {
+	bool secure_control;
+	bool io_sync_control;
+	bool rif_control;
+};
+
+static int stm32_pinctrl_get_access(struct udevice *gpio_dev, unsigned int gpio_idx);
+
 #ifndef CONFIG_SPL_BUILD
 
 static char pin_name[PINNAME_SIZE];
@@ -61,6 +77,13 @@ static const char * const pinmux_otype[] = {
 	[STM32_GPIO_OTYPE_OD] = "open-drain",
 };
 
+static const char * const pinmux_speed[] = {
+	[STM32_GPIO_SPEED_2M] = "Low speed",
+	[STM32_GPIO_SPEED_25M] = "Medium speed",
+	[STM32_GPIO_SPEED_50M] = "High speed",
+	[STM32_GPIO_SPEED_100M] = "Very-high speed",
+};
+
 static int stm32_pinctrl_get_af(struct udevice *dev, unsigned int offset)
 {
 	struct stm32_gpio_priv *priv = dev_get_priv(dev);
@@ -201,6 +224,7 @@ static int stm32_pinctrl_get_pin_muxing(struct udevice *dev,
 	int af_num;
 	unsigned int gpio_idx;
 	u32 pupd, otype;
+	u8 speed;
 
 	/* look up for the bank which owns the requested pin */
 	gpio_dev = stm32_pinctrl_get_gpio_dev(dev, selector, &gpio_idx);
@@ -208,12 +232,19 @@ static int stm32_pinctrl_get_pin_muxing(struct udevice *dev,
 	if (!gpio_dev)
 		return -ENODEV;
 
+	/* Check access protection */
+	if (stm32_pinctrl_get_access(gpio_dev, gpio_idx)) {
+		snprintf(buf, size, "NO ACCESS");
+		return 0;
+	}
+
 	mode = gpio_get_raw_function(gpio_dev, gpio_idx, &label);
 	dev_dbg(dev, "selector = %d gpio_idx = %d mode = %d\n",
 		selector, gpio_idx, mode);
 	priv = dev_get_priv(gpio_dev);
 	pupd = (readl(&priv->regs->pupdr) >> (gpio_idx * 2)) & PUPD_MASK;
 	otype = (readl(&priv->regs->otyper) >> gpio_idx) & OTYPE_MSK;
+	speed = (readl(&priv->regs->ospeedr) >> gpio_idx * 2) & OSPEED_MASK;
 
 	switch (mode) {
 	case GPIOF_UNKNOWN:
@@ -222,13 +253,15 @@ static int stm32_pinctrl_get_pin_muxing(struct udevice *dev,
 		break;
 	case GPIOF_FUNC:
 		af_num = stm32_pinctrl_get_af(gpio_dev, gpio_idx);
-		snprintf(buf, size, "%s %d %s %s", pinmux_mode[mode], af_num,
-			 pinmux_otype[otype], pinmux_bias[pupd]);
+		snprintf(buf, size, "%s %d %s %s %s", pinmux_mode[mode], af_num,
+			 pinmux_otype[otype], pinmux_bias[pupd],
+			 pinmux_speed[speed]);
 		break;
 	case GPIOF_OUTPUT:
-		snprintf(buf, size, "%s %s %s %s",
+		snprintf(buf, size, "%s %s %s %s %s",
 			 pinmux_mode[mode], pinmux_otype[otype],
-			 pinmux_bias[pupd], label ? label : "");
+			 pinmux_bias[pupd], label ? label : "",
+			 pinmux_speed[speed]);
 		break;
 	case GPIOF_INPUT:
 		snprintf(buf, size, "%s %s %s", pinmux_mode[mode],
@@ -241,6 +274,25 @@ static int stm32_pinctrl_get_pin_muxing(struct udevice *dev,
 
 #endif
 
+static int stm32_pinctrl_get_access(struct udevice *gpio_dev, unsigned int gpio_idx)
+{
+	struct stm32_gpio_priv *priv = dev_get_priv(gpio_dev);
+	struct stm32_gpio_regs *regs = priv->regs;
+	ulong drv_data = dev_get_driver_data(gpio_dev);
+
+	/* Deny request access if IO is secured */
+	if ((drv_data & STM32_GPIO_FLAG_SEC_CTRL) &&
+	    ((readl(&regs->seccfgr) >> gpio_idx) & SECCFG_MSK))
+		return -EACCES;
+
+	/* Deny request access if IO RIF semaphore is not available */
+	if ((drv_data & STM32_GPIO_FLAG_RIF_CTRL) &&
+	    !stm32_gpio_rif_valid(regs, gpio_idx))
+		return -EACCES;
+
+	return 0;
+}
+
 static int stm32_pinctrl_probe(struct udevice *dev)
 {
 	struct stm32_pinctrl_priv *priv = dev_get_priv(dev);
@@ -257,19 +309,37 @@ static int stm32_pinctrl_probe(struct udevice *dev)
 	return 0;
 }
 
-static int stm32_gpio_config(struct gpio_desc *desc,
+static int stm32_gpio_config(ofnode node,
+			     struct gpio_desc *desc,
 			     const struct stm32_gpio_ctl *ctl)
 {
 	struct stm32_gpio_priv *priv = dev_get_priv(desc->dev);
+	struct gpio_dev_priv *uc_priv = dev_get_uclass_priv(desc->dev);
 	struct stm32_gpio_regs *regs = priv->regs;
 	struct stm32_pinctrl_priv *ctrl_priv;
 	int ret;
-	u32 index;
+	u32 index, io_sync, advcfg;
+
+	/* Check access protection */
+	ret = stm32_pinctrl_get_access(desc->dev, desc->offset);
+	if (ret) {
+		dev_err(desc->dev, "Failed to get secure IO %s %d @ %p\n",
+			uc_priv->bank_name, desc->offset, regs);
+		return ret;
+	}
 
 	if (!ctl || ctl->af > 15 || ctl->mode > 3 || ctl->otype > 1 ||
 	    ctl->pupd > 2 || ctl->speed > 3)
 		return -EINVAL;
 
+	io_sync = dev_get_driver_data(desc->dev) & STM32_GPIO_FLAG_IO_SYNC_CTRL;
+	if (io_sync && (ctl->delay_path > STM32_GPIO_DELAY_PATH_IN ||
+			ctl->clk_edge > STM32_GPIO_CLK_EDGE_DOUBLE ||
+			ctl->clk_type > STM32_GPIO_CLK_TYPE_INVERT ||
+			ctl->retime > STM32_GPIO_RETIME_ENABLED ||
+			ctl->delay > STM32_GPIO_DELAY_3_25))
+		return -EINVAL;
+
 	ctrl_priv = dev_get_priv(dev_get_parent(desc->dev));
 	ret = hwspinlock_lock_timeout(&ctrl_priv->hws, 10);
 	if (ret == -ETIME) {
@@ -291,6 +361,22 @@ static int stm32_gpio_config(struct gpio_desc *desc,
 	index = desc->offset;
 	clrsetbits_le32(&regs->otyper, OTYPE_MSK << index, ctl->otype << index);
 
+	if (io_sync) {
+		index = (desc->offset & 0x07) * 4;
+		advcfg = (ctl->delay_path << ADVCFGR_DLYPATH_POS) |
+			 (ctl->clk_edge << ADVCFGR_DE_POS) |
+			 (ctl->clk_type << ADVCFGR_INVCLK_POS) |
+			 (ctl->retime << ADVCFGR_RET_POS);
+
+		clrsetbits_le32(&regs->advcfgr[desc->offset >> 3],
+				ADVCFGR_MASK << index, advcfg << index);
+
+		clrsetbits_le32(&regs->delayr[desc->offset >> 3],
+				DELAYR_MASK << index, ctl->delay << index);
+	}
+
+	uc_priv->name[desc->offset] = strdup(ofnode_get_name(node));
+
 	hwspinlock_unlock(&ctrl_priv->hws);
 
 	return 0;
@@ -341,10 +427,24 @@ static int prep_gpio_ctl(struct stm32_gpio_ctl *gpio_ctl, u32 gpio_fn,
 	else
 		gpio_ctl->pupd = STM32_GPIO_PUPD_NO;
 
+	gpio_ctl->delay_path = ofnode_read_u32_default(node, "st,io-delay-path", 0);
+	gpio_ctl->clk_edge = ofnode_read_u32_default(node, "st,io-clk-edge", 0);
+	gpio_ctl->clk_type = ofnode_read_u32_default(node, "st,io-clk-type", 0);
+	gpio_ctl->retime = ofnode_read_u32_default(node, "st,io-retime", 0);
+	gpio_ctl->delay = ofnode_read_u32_default(node, "st,io-delay", 0);
+
 	log_debug("gpio fn= %d, slew-rate= %x, op type= %x, pull-upd is = %x\n",
 		  gpio_fn, gpio_ctl->speed, gpio_ctl->otype,
 		  gpio_ctl->pupd);
 
+	if (gpio_ctl->retime || gpio_ctl->clk_type || gpio_ctl->clk_edge || gpio_ctl->delay_path ||
+	    gpio_ctl->delay)
+		log_debug("	Retime:%d InvClk:%d DblEdge:%d DelayIn:%d\n",
+			  gpio_ctl->retime, gpio_ctl->clk_type, gpio_ctl->clk_edge,
+			  gpio_ctl->delay_path);
+	if (gpio_ctl->delay)
+		log_debug("	Delay: %d (%d ps)\n", gpio_ctl->delay, gpio_ctl->delay * 250);
+
 	return 0;
 }
 
@@ -385,7 +485,7 @@ static int stm32_pinctrl_config(ofnode node)
 			if (rv)
 				return rv;
 			desc.offset = gpio_dsc.pin;
-			rv = stm32_gpio_config(&desc, &gpio_ctl);
+			rv = stm32_gpio_config(node, &desc, &gpio_ctl);
 			log_debug("rv = %d\n\n", rv);
 			if (rv)
 				return rv;
@@ -399,8 +499,29 @@ static int stm32_pinctrl_bind(struct udevice *dev)
 {
 	ofnode node;
 	const char *name;
+	struct driver *drv;
+	const struct stm32_pinctrl_data *drv_data;
+	ulong gpio_data = 0;
 	int ret;
 
+	drv = lists_driver_lookup_name("gpio_stm32");
+	if (!drv) {
+		debug("Cannot find driver 'gpio_stm32'\n");
+		return -ENOENT;
+	}
+
+	drv_data = (const struct stm32_pinctrl_data *)dev_get_driver_data(dev);
+	if (!drv_data) {
+		debug("Cannot find driver data\n");
+		return -EINVAL;
+	}
+	if (drv_data->secure_control)
+		gpio_data |= STM32_GPIO_FLAG_SEC_CTRL;
+	if (drv_data->io_sync_control)
+		gpio_data |= STM32_GPIO_FLAG_IO_SYNC_CTRL;
+	if (drv_data->rif_control)
+		gpio_data |= STM32_GPIO_FLAG_RIF_CTRL;
+
 	dev_for_each_subnode(node, dev) {
 		dev_dbg(dev, "bind %s\n", ofnode_get_name(node));
 
@@ -416,8 +537,7 @@ static int stm32_pinctrl_bind(struct udevice *dev)
 			return -EINVAL;
 
 		/* Bind each gpio node */
-		ret = device_bind_driver_to_node(dev, "gpio_stm32",
-						 name, node, NULL);
+		ret = device_bind_with_driver_data(dev, drv, name, gpio_data, node, NULL);
 		if (ret)
 			return ret;
 
@@ -480,15 +600,35 @@ static struct pinctrl_ops stm32_pinctrl_ops = {
 #endif
 };
 
+static const struct stm32_pinctrl_data stm32_pinctrl_base = {
+	.secure_control = false,
+	.io_sync_control = false,
+	.rif_control = false,
+};
+
+static const struct stm32_pinctrl_data stm32_pinctrl_sec = {
+	.secure_control = true,
+	.io_sync_control = false,
+	.rif_control = false,
+};
+
+static const struct stm32_pinctrl_data stm32_pinctrl_sec_iosync = {
+	.secure_control = true,
+	.io_sync_control = true,
+	.rif_control = true,
+};
+
 static const struct udevice_id stm32_pinctrl_ids[] = {
-	{ .compatible = "st,stm32f429-pinctrl" },
-	{ .compatible = "st,stm32f469-pinctrl" },
-	{ .compatible = "st,stm32f746-pinctrl" },
-	{ .compatible = "st,stm32f769-pinctrl" },
-	{ .compatible = "st,stm32h743-pinctrl" },
-	{ .compatible = "st,stm32mp157-pinctrl" },
-	{ .compatible = "st,stm32mp157-z-pinctrl" },
-	{ .compatible = "st,stm32mp135-pinctrl" },
+	{ .compatible = "st,stm32f429-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32f469-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32f746-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32f769-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32h743-pinctrl",    .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32mp157-pinctrl",   .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32mp157-z-pinctrl", .data = (ulong)&stm32_pinctrl_base },
+	{ .compatible = "st,stm32mp135-pinctrl",   .data = (ulong)&stm32_pinctrl_sec },
+	{ .compatible = "st,stm32mp257-pinctrl",   .data = (ulong)&stm32_pinctrl_sec_iosync },
+	{ .compatible = "st,stm32mp257-z-pinctrl", .data = (ulong)&stm32_pinctrl_sec_iosync },
 	{ }
 };
 
diff --git a/drivers/power/pmic/pmic-uclass.c b/drivers/power/pmic/pmic-uclass.c
index 5dcf6d8079..0e2f5e1f41 100644
--- a/drivers/power/pmic/pmic-uclass.c
+++ b/drivers/power/pmic/pmic-uclass.c
@@ -39,6 +39,10 @@ int pmic_bind_children(struct udevice *pmic, ofnode parent,
 		node_name = ofnode_get_name(node);
 
 		debug("* Found child node: '%s'\n", node_name);
+		if (!ofnode_is_enabled(node)) {
+			debug("  - ignoring disabled device\n");
+			continue;
+		}
 
 		child = NULL;
 		for (info = child_info; info->prefix && info->driver; info++) {
diff --git a/drivers/power/pmic/stpmic1.c b/drivers/power/pmic/stpmic1.c
index 2c85410b1b..8701d4f971 100644
--- a/drivers/power/pmic/stpmic1.c
+++ b/drivers/power/pmic/stpmic1.c
@@ -34,7 +34,9 @@ static const struct pmic_child_info stpmic1_children_info[] = {
 	{ .prefix = "ldo", .driver = "stpmic1_ldo" },
 	{ .prefix = "buck", .driver = "stpmic1_buck" },
 	{ .prefix = "vref_ddr", .driver = "stpmic1_vref_ddr" },
+	{ .prefix = "vref-ddr", .driver = "stpmic1_vref_ddr" },
 	{ .prefix = "pwr_sw", .driver = "stpmic1_pwr_sw" },
+	{ .prefix = "pwr-sw", .driver = "stpmic1_pwr_sw" },
 	{ .prefix = "boost", .driver = "stpmic1_boost" },
 	{ },
 };
diff --git a/drivers/power/regulator/scmi_regulator.c b/drivers/power/regulator/scmi_regulator.c
index 801148036f..fa690d4a43 100644
--- a/drivers/power/regulator/scmi_regulator.c
+++ b/drivers/power/regulator/scmi_regulator.c
@@ -184,7 +184,7 @@ U_BOOT_DRIVER(scmi_regulator) = {
 	.probe = scmi_regulator_probe,
 	.of_to_plat = scmi_regulator_of_to_plat,
 	.plat_auto = sizeof(struct scmi_regulator_platdata),
-	.priv_auto = sizeof(struct scmi_regulator_priv *),
+	.priv_auto = sizeof(struct scmi_regulator_priv),
 };
 
 static int scmi_regulator_bind(struct udevice *dev)
diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index 27e4a60ff5..891ef470ae 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -12,6 +12,14 @@ config REMOTEPROC
 	bool
 	depends on DM
 
+config REMOTEPROC_OPTEE
+	bool "Support for the remoteproc in OPTEE"
+	depends on REMOTEPROC
+	depends on OPTEE
+	help
+	  Say y here to support remote processor firmware management by the
+	  trusted execution environment.
+
 # Please keep the configuration alphabetically sorted.
 config K3_SYSTEM_CONTROLLER
 	bool "Support for TI' K3 System Controller"
diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
index fbe9c172bc..394397435d 100644
--- a/drivers/remoteproc/Makefile
+++ b/drivers/remoteproc/Makefile
@@ -5,6 +5,7 @@
 #
 
 obj-$(CONFIG_$(SPL_)REMOTEPROC) += rproc-uclass.o rproc-elf-loader.o
+obj-$(CONFIG_REMOTEPROC_OPTEE) += rproc-optee.o
 
 # Remote proc drivers - Please keep this list alphabetically sorted.
 obj-$(CONFIG_K3_SYSTEM_CONTROLLER) += k3_system_controller.o
diff --git a/drivers/remoteproc/rproc-optee.c b/drivers/remoteproc/rproc-optee.c
new file mode 100644
index 0000000000..20743c4428
--- /dev/null
+++ b/drivers/remoteproc/rproc-optee.c
@@ -0,0 +1,239 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ * Authors: Arnaud Pouliquen <arnaud.pouliquen@st.com>
+ */
+
+#define LOG_CATEGORY UCLASS_REMOTEPROC
+
+#include <dm.h>
+#include <errno.h>
+#include <remoteproc.h>
+#include <rproc_optee.h>
+#include <tee.h>
+#include <dm/device_compat.h>
+
+#define TA_REMOTEPROC_UUID  { 0x80a4c275, 0x0a47, 0x4905, \
+		   { 0x82, 0x85, 0x14, 0x86, 0xa9, 0x77, 0x1a, 0x08} }
+
+/* The function IDs implemented in the associated TA */
+
+/*
+ * Authentication of the firmware and load in the remote processor memory.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [in]  params[1].memref:	buffer containing the image of the firmware
+ */
+#define TA_RPROC_FW_CMD_LOAD_FW		1
+
+/*
+ * Start the remote processor.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_START_FW	2
+
+/*
+ * Stop the remote processor.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ */
+#define TA_RPROC_FW_CMD_STOP_FW		3
+
+/*
+ * Return the physical address of the resource table, or 0 if not found
+ * No check is done to verify that the address returned is accessible by the
+ * non secure world. If the resource table is loaded in a protected memory,
+ * then accesses from non-secure world will likely fail.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out] params[1].value.a:	32bit LSB resource table memory address
+ * [out] params[1].value.b:	32bit MSB resource table memory address
+ * [out] params[2].value.a:	32bit LSB resource table memory size
+ * [out] params[2].value.b:	32bit MSB resource table memory size
+ */
+#define TA_RPROC_FW_CMD_GET_RSC_TABLE	4
+
+/*
+ * Get remote processor firmware core dump. If found, return either
+ * TEE_SUCCESS on successful completion or TEE_ERROR_SHORT_BUFFER if output
+ * buffer is too short to store the core dump.
+ *
+ * [in]  params[0].value.a:	unique 32bit identifier of the firmware
+ * [out] params[1].memref:	Core dump, if found
+ */
+#define TA_RPROC_FW_CMD_GET_COREDUMP	5
+
+static void prepare_args(struct rproc_optee *trproc, int cmd,
+			 struct tee_invoke_arg *arg, uint num_param,
+			 struct tee_param *param)
+{
+	memset(arg, 0, sizeof(*arg));
+	memset(param, 0, num_param * sizeof(*param));
+
+	arg->func = cmd;
+	arg->session = trproc->session;
+
+	param[0] = (struct tee_param) {
+		.attr = TEE_PARAM_ATTR_TYPE_VALUE_INPUT,
+		.u.value.a = trproc->proc_id,
+	};
+}
+
+int rproc_optee_load(struct rproc_optee *trproc, ulong addr, ulong size)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param[2];
+	struct tee_shm *fw_shm;
+	int rc;
+
+	rc = tee_shm_register(trproc->tee, (void *)addr, size, 0, &fw_shm);
+	if (rc)
+		return rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_LOAD_FW, &arg, 2, param);
+
+	/* Provide the address and size of the firmware image */
+	param[1] = (struct tee_param){
+		.attr = TEE_PARAM_ATTR_TYPE_MEMREF_INPUT,
+		.u.memref = {
+			.shm = fw_shm,
+			.size = size,
+			.shm_offs = 0,
+		},
+	};
+
+	rc = tee_invoke_func(trproc->tee, &arg, 2, param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_LOAD_FW invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	tee_shm_free(fw_shm);
+
+	return rc;
+}
+
+int rproc_optee_get_rsc_table(struct rproc_optee *trproc, phys_addr_t *rsc_addr,
+			      phys_size_t *rsc_size)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param[3];
+	int rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_GET_RSC_TABLE, &arg, 3, param);
+
+	param[1].attr = TEE_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+	param[2].attr = TEE_PARAM_ATTR_TYPE_VALUE_OUTPUT;
+
+	rc = tee_invoke_func(trproc->tee, &arg, 3, param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_GET_RSC_TABLE invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+
+		return rc;
+	}
+
+	*rsc_size = (phys_size_t)
+			(param[2].u.value.b << 32 | param[2].u.value.a);
+	*rsc_addr = (phys_addr_t)
+			(param[1].u.value.b << 32 | param[1].u.value.a);
+
+	return 0;
+}
+
+int rproc_optee_start(struct rproc_optee *trproc)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param;
+	int rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_START_FW, &arg, 1, &param);
+
+	rc =  tee_invoke_func(trproc->tee, &arg, 1, &param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_START_FW invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	return rc;
+}
+
+int rproc_optee_stop(struct rproc_optee *trproc)
+{
+	struct tee_invoke_arg arg;
+	struct tee_param param;
+	int rc;
+
+	prepare_args(trproc, TA_RPROC_FW_CMD_STOP_FW, &arg, 1, &param);
+
+	rc =  tee_invoke_func(trproc->tee, &arg, 1, &param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(trproc->tee,
+			"TA_RPROC_FW_CMD_STOP_FW invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	return rc;
+}
+
+int rproc_optee_open(struct rproc_optee *trproc)
+{
+	struct udevice *tee = NULL;
+	const struct tee_optee_ta_uuid uuid = TA_REMOTEPROC_UUID;
+	struct tee_open_session_arg arg = { };
+	struct tee_param param;
+	int rc;
+
+	if (!trproc)
+		return -EINVAL;
+
+	tee = tee_find_device(tee, NULL, NULL, NULL);
+	if (!tee)
+		return -ENODEV;
+
+	tee_optee_ta_uuid_to_octets(arg.uuid, &uuid);
+
+	param.attr = TEE_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param.u.value.a = trproc->proc_id;
+
+	rc = tee_open_session(tee, &arg, 1, &param);
+	if (rc < 0 || arg.ret != 0) {
+		if (!rc)
+			rc = -EIO;
+		return rc;
+	}
+
+	trproc->tee = tee;
+	trproc->session = arg.session;
+
+	return 0;
+}
+
+int rproc_optee_close(struct rproc_optee *trproc)
+{
+	int rc;
+
+	if (!trproc->tee)
+		return -ENODEV;
+
+	rc = tee_close_session(trproc->tee, trproc->session);
+	if (rc)
+		return rc;
+
+	trproc->tee = NULL;
+	trproc->session = 0;
+
+	return 0;
+}
diff --git a/drivers/remoteproc/stm32_copro.c b/drivers/remoteproc/stm32_copro.c
index 5271f83bc0..7cde9a6b0b 100644
--- a/drivers/remoteproc/stm32_copro.c
+++ b/drivers/remoteproc/stm32_copro.c
@@ -9,12 +9,25 @@
 #include <errno.h>
 #include <fdtdec.h>
 #include <log.h>
+#include <nvmem.h>
 #include <remoteproc.h>
+#include <rproc_optee.h>
 #include <reset.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
 #include <linux/err.h>
 
+#define STM32MP15_M4_FW_ID	0
+#define STM32MP25_M33_FW_ID	1
+
+/* TAMP_COPRO_STATE register values */
+#define TAMP_COPRO_STATE_OFF		0
+#define TAMP_COPRO_STATE_INIT		1
+#define TAMP_COPRO_STATE_CRUN		2
+#define TAMP_COPRO_STATE_CSTOP		3
+#define TAMP_COPRO_STATE_STANDBY	4
+#define TAMP_COPRO_STATE_CRASH		5
+
 /**
  * struct stm32_copro_privdata - power processor private data
  * @reset_ctl:		reset controller handle
@@ -25,30 +38,57 @@ struct stm32_copro_privdata {
 	struct reset_ctl reset_ctl;
 	struct reset_ctl hold_boot;
 	ulong rsc_table_addr;
+	ulong rsc_table_size;
+	struct nvmem_cell rsc_t_addr_cell;
+	struct nvmem_cell rsc_t_size_cell;
+	struct rproc_optee trproc;
 };
 
+static int stm32_copro_stop(struct udevice *dev);
+
 /**
  * stm32_copro_probe() - Basic probe
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_probe(struct udevice *dev)
 {
-	struct stm32_copro_privdata *priv;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
 	int ret;
 
-	priv = dev_get_priv(dev);
+	trproc->proc_id = (u32)dev_get_driver_data(dev);
 
-	ret = reset_get_by_name(dev, "mcu_rst", &priv->reset_ctl);
-	if (ret) {
-		dev_err(dev, "failed to get reset (%d)\n", ret);
-		return ret;
+	if (trproc->proc_id == STM32MP25_M33_FW_ID) {
+		ret = nvmem_cell_get_by_name(dev, "rsc-tbl-addr", &priv->rsc_t_addr_cell);
+		if (ret && ret != -ENODATA)
+			return ret;
+		ret = nvmem_cell_get_by_name(dev, "rsc-tbl-size", &priv->rsc_t_size_cell);
+		if (ret && ret != -ENODATA)
+			return ret;
 	}
 
-	ret = reset_get_by_name(dev, "hold_boot", &priv->hold_boot);
-	if (ret) {
-		dev_err(dev, "failed to get hold boot (%d)\n", ret);
-		return ret;
+	if (device_is_compatible(dev, "st,stm32mp1-m4-tee") ||
+	    device_is_compatible(dev, "st,stm32mp2-m33-tee")) {
+		ret = rproc_optee_open(trproc);
+		if (ret) {
+			dev_err(dev, "failed to delegate to OP-TEE\n");
+			return ret;
+		}
+
+		dev_info(dev, "delegate the firmware management to OP-TEE\n");
+	} else {
+		ret = reset_get_by_name(dev, "mcu_rst", &priv->reset_ctl);
+		if (ret) {
+			dev_err(dev, "failed to get reset (%d)\n", ret);
+			return ret;
+		}
+
+		ret = reset_get_by_name(dev, "hold_boot", &priv->hold_boot);
+		if (ret) {
+			dev_err(dev, "failed to get hold boot (%d)\n", ret);
+			return ret;
+		}
 	}
 
 	dev_dbg(dev, "probed\n");
@@ -57,47 +97,84 @@ static int stm32_copro_probe(struct udevice *dev)
 }
 
 /**
- * stm32_copro_device_to_virt() - Convert device address to virtual address
- * @dev:	corresponding STM32 remote processor device
+ * stm32_copro_optee_remove() - Close the rproc trusted application session
+ * @dev:	 remote processor device
+ * @return 0 if all went ok, else corresponding -ve error
+ */
+static int stm32_copro_remove(struct udevice *dev)
+{
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+
+	if (trproc->tee)
+		return rproc_optee_close(trproc);
+
+	return 0;
+}
+
+/**
+ * stm32_copro_device_to_phys() - Convert device address to physical address
+ * @dev:	remote processor device
  * @da:		device address
  * @size:	Size of the memory region @da is pointing to
- * Return: converted virtual address
+ * Return: converted physical address
  */
-static void *stm32_copro_device_to_virt(struct udevice *dev, ulong da,
-					ulong size)
+static phys_addr_t stm32_copro_device_to_phys(struct udevice *dev, ulong da,
+					      ulong size)
 {
 	fdt32_t in_addr = cpu_to_be32(da), end_addr;
-	u64 paddr;
+	phys_addr_t paddr;
 
 	paddr = dev_translate_dma_address(dev, &in_addr);
 	if (paddr == OF_BAD_ADDR) {
 		dev_err(dev, "Unable to convert address %ld\n", da);
-		return NULL;
+		return 0;
 	}
-
 	end_addr = cpu_to_be32(da + size - 1);
 	if (dev_translate_dma_address(dev, &end_addr) == OF_BAD_ADDR) {
 		dev_err(dev, "Unable to convert address %ld\n", da + size - 1);
-		return NULL;
+		return 0;
 	}
 
+	return paddr;
+}
+/**
+ * stm32_copro_device_to_virt() - Convert device address to virtual address
+ * @dev:	remote processor device
+ * @da:		device address
+ * @size:	Size of the memory region @da is pointing to
+ * Return: converted virtual address
+ */
+static void *stm32_copro_device_to_virt(struct udevice *dev, ulong da,
+					ulong size)
+{
+	phys_addr_t paddr;
+
+	paddr = stm32_copro_device_to_phys(dev, da, size);
+	if (!paddr)
+		return NULL;
+
 	return phys_to_virt(paddr);
 }
 
 /**
  * stm32_copro_load() - Loadup the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * @addr:	Address in memory where image is stored
  * @size:	Size in bytes of the image
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_load(struct udevice *dev, ulong addr, ulong size)
 {
-	struct stm32_copro_privdata *priv;
-	ulong rsc_table_size;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+	ulong rsc_table_size = 0;
+	ulong rsc_table_addr = 0;
+	phys_addr_t paddr;
 	int ret;
 
-	priv = dev_get_priv(dev);
+	if (trproc->tee)
+		return rproc_optee_load(trproc, addr, size);
 
 	ret = reset_assert(&priv->hold_boot);
 	if (ret) {
@@ -111,81 +188,155 @@ static int stm32_copro_load(struct udevice *dev, ulong addr, ulong size)
 		return ret;
 	}
 
-	if (rproc_elf32_load_rsc_table(dev, addr, size, &priv->rsc_table_addr,
-				       &rsc_table_size)) {
-		priv->rsc_table_addr = 0;
-		dev_warn(dev, "No valid resource table for this firmware\n");
+	priv->rsc_table_addr = 0;
+	ret = rproc_elf32_load_rsc_table(dev, addr, size, &rsc_table_addr,
+					 &rsc_table_size);
+	if (ret) {
+		if (ret != -ENODATA)
+			return ret;
+		dev_dbg(dev, "No resource table for this firmware\n");
 	}
 
+	paddr = stm32_copro_device_to_phys(dev, rsc_table_addr, rsc_table_size);
+
+	priv->rsc_table_addr = (ulong)paddr;
+	priv->rsc_table_size = rsc_table_size;
+
 	return rproc_elf32_load_image(dev, addr, size);
 }
 
 /**
  * stm32_copro_start() - Start the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_start(struct udevice *dev)
 {
-	struct stm32_copro_privdata *priv;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+	unsigned int proc_id = (u32)dev_get_driver_data(dev);
+	phys_size_t rsc_size;
+	phys_addr_t rsc_addr;
 	int ret;
 
-	priv = dev_get_priv(dev);
+	if (trproc->tee) {
+		ret = rproc_optee_get_rsc_table(trproc, &rsc_addr, &rsc_size);
+		if (ret)
+			return ret;
+
+		priv->rsc_table_size = (ulong)rsc_size;
+		priv->rsc_table_addr = (ulong)rsc_addr;
+
+		ret = rproc_optee_start(trproc);
+		if (ret)
+			return ret;
+
+	} else {
+		ret = reset_deassert(&priv->hold_boot);
+		if (ret) {
+			dev_err(dev, "Unable to deassert hold boot (ret=%d)\n",
+				ret);
+			return ret;
+		}
+
+		/*
+		 * Once copro running, reset hold boot flag to avoid copro
+		 * rebooting autonomously (error should never occur)
+		 */
+		ret = reset_assert(&priv->hold_boot);
+		if (ret)
+			dev_err(dev, "Unable to assert hold boot (ret=%d)\n",
+				ret);
+	}
 
-	ret = reset_deassert(&priv->hold_boot);
-	if (ret) {
-		dev_err(dev, "Unable to deassert hold boot (ret=%d)\n", ret);
-		return ret;
+	if (proc_id == STM32MP15_M4_FW_ID) {
+#ifdef CONFIG_STM32MP15X
+		/* Indicates that copro is running */
+		writel(TAMP_COPRO_STATE_CRUN, TAMP_COPRO_STATE);
+		/* Store rsc_address in bkp register */
+		writel(priv->rsc_table_addr, TAMP_COPRO_RSC_TBL_ADDRESS);
+#else
+		return -EOPNOTSUPP;
+#endif
+	} else if (proc_id == STM32MP25_M33_FW_ID) {
+		/* Store the resource table address and size in 32-bit registers*/
+		ret = nvmem_cell_write(&priv->rsc_t_addr_cell, &priv->rsc_table_addr, sizeof(u32));
+		if (ret)
+			goto error;
+
+		ret = nvmem_cell_write(&priv->rsc_t_size_cell, &priv->rsc_table_size, sizeof(u32));
+		if (ret)
+			goto error;
 	}
 
-	/*
-	 * Once copro running, reset hold boot flag to avoid copro
-	 * rebooting autonomously (error should never occur)
-	 */
-	ret = reset_assert(&priv->hold_boot);
-	if (ret)
-		dev_err(dev, "Unable to assert hold boot (ret=%d)\n", ret);
+	return 0;
 
-	/* indicates that copro is running */
-	writel(TAMP_COPRO_STATE_CRUN, TAMP_COPRO_STATE);
-	/* Store rsc_address in bkp register */
-	writel(priv->rsc_table_addr, TAMP_COPRO_RSC_TBL_ADDRESS);
+error:
+	stm32_copro_stop(dev);
 
-	return 0;
+	return ret;
 }
 
 /**
  * stm32_copro_reset() - Reset the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_reset(struct udevice *dev)
 {
-	struct stm32_copro_privdata *priv;
+	struct stm32_copro_privdata *priv = dev_get_priv(dev);
+	struct rproc_optee *trproc = &priv->trproc;
+	unsigned int proc_id = (u32)dev_get_driver_data(dev);
 	int ret;
 
-	priv = dev_get_priv(dev);
 
-	ret = reset_assert(&priv->hold_boot);
-	if (ret) {
-		dev_err(dev, "Unable to assert hold boot (ret=%d)\n", ret);
-		return ret;
+	if (trproc->tee) {
+		ret = rproc_optee_stop(trproc);
+		if (ret)
+			return ret;
+	} else {
+		ret = reset_assert(&priv->hold_boot);
+		if (ret) {
+			dev_err(dev, "Unable to assert hold boot (ret=%d)\n",
+				ret);
+			return ret;
+		}
+
+		ret = reset_assert(&priv->reset_ctl);
+		if (ret) {
+			dev_err(dev, "Unable to assert reset line (ret=%d)\n",
+				ret);
+			return ret;
+		}
 	}
 
-	ret = reset_assert(&priv->reset_ctl);
-	if (ret) {
-		dev_err(dev, "Unable to assert reset line (ret=%d)\n", ret);
-		return ret;
+	/* Clean-up backup registers */
+	priv->rsc_table_addr = 0;
+	priv->rsc_table_size = 0;
+
+	if (proc_id == STM32MP15_M4_FW_ID) {
+#ifdef CONFIG_STM32MP15X
+		writel(TAMP_COPRO_STATE_OFF, TAMP_COPRO_STATE);
+		writel(priv->rsc_table_addr, TAMP_COPRO_RSC_TBL_ADDRESS);
+#else
+		return -EOPNOTSUPP;
+#endif
+	} else if (proc_id == STM32MP25_M33_FW_ID) {
+		ret = nvmem_cell_write(&priv->rsc_t_addr_cell, &priv->rsc_table_addr, sizeof(u32));
+		if (ret)
+			return ret;
+
+		ret = nvmem_cell_write(&priv->rsc_t_size_cell, &priv->rsc_table_size, sizeof(u32));
+		if (ret)
+			return ret;
 	}
 
-	writel(TAMP_COPRO_STATE_OFF, TAMP_COPRO_STATE);
-
 	return 0;
 }
 
 /**
  * stm32_copro_stop() - Stop the STM32 remote processor
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if all went ok, else corresponding -ve error
  */
 static int stm32_copro_stop(struct udevice *dev)
@@ -195,12 +346,18 @@ static int stm32_copro_stop(struct udevice *dev)
 
 /**
  * stm32_copro_is_running() - Is the STM32 remote processor running
- * @dev:	corresponding STM32 remote processor device
+ * @dev:	remote processor device
  * Return: 0 if the remote processor is running, 1 otherwise
  */
 static int stm32_copro_is_running(struct udevice *dev)
 {
-	return (readl(TAMP_COPRO_STATE) == TAMP_COPRO_STATE_OFF);
+#ifdef CONFIG_STM32MP15X
+	unsigned int proc_id = (u32)dev_get_driver_data(dev);
+
+	if (proc_id == STM32MP15_M4_FW_ID)
+		return (readl(TAMP_COPRO_STATE) == TAMP_COPRO_STATE_OFF);
+#endif
+	return -EOPNOTSUPP;
 }
 
 static const struct dm_rproc_ops stm32_copro_ops = {
@@ -213,15 +370,19 @@ static const struct dm_rproc_ops stm32_copro_ops = {
 };
 
 static const struct udevice_id stm32_copro_ids[] = {
-	{.compatible = "st,stm32mp1-m4"},
+	{ .compatible = "st,stm32mp1-m4", .data = STM32MP15_M4_FW_ID },
+	{ .compatible = "st,stm32mp1-m4-tee", .data = STM32MP15_M4_FW_ID },
+	{ .compatible = "st,stm32mp2-m33-tee", .data = STM32MP25_M33_FW_ID },
 	{}
 };
 
 U_BOOT_DRIVER(stm32_copro) = {
-	.name = "stm32_m4_proc",
+	.name = "stm32_copro",
 	.of_match = stm32_copro_ids,
 	.id = UCLASS_REMOTEPROC,
 	.ops = &stm32_copro_ops,
 	.probe = stm32_copro_probe,
-	.priv_auto	= sizeof(struct stm32_copro_privdata),
+	.remove = stm32_copro_remove,
+	.priv_auto = sizeof(struct stm32_copro_privdata),
+	.flags = DM_FLAG_OS_PREPARE,
 };
diff --git a/drivers/reset/reset-scmi.c b/drivers/reset/reset-scmi.c
index 122556162e..a2975085c4 100644
--- a/drivers/reset/reset-scmi.c
+++ b/drivers/reset/reset-scmi.c
@@ -93,5 +93,5 @@ U_BOOT_DRIVER(scmi_reset_domain) = {
 	.id = UCLASS_RESET,
 	.ops = &scmi_reset_domain_ops,
 	.probe = scmi_reset_probe,
-	.priv_auto = sizeof(struct scmi_reset_priv *),
+	.priv_auto = sizeof(struct scmi_reset_priv),
 };
diff --git a/drivers/reset/reset-uclass.c b/drivers/reset/reset-uclass.c
index bcef46039c..1e1a48324b 100644
--- a/drivers/reset/reset-uclass.c
+++ b/drivers/reset/reset-uclass.c
@@ -244,10 +244,6 @@ int reset_release_all(struct reset_ctl *reset_ctl, int count)
 		if (!reset_ctl[i].dev)
 			continue;
 
-		ret = reset_assert(&reset_ctl[i]);
-		if (ret)
-			return ret;
-
 		ret = reset_free(&reset_ctl[i]);
 		if (ret)
 			return ret;
diff --git a/drivers/reset/stm32-reset.c b/drivers/reset/stm32-reset.c
index 0bbde29810..09116c039a 100644
--- a/drivers/reset/stm32-reset.c
+++ b/drivers/reset/stm32-reset.c
@@ -16,6 +16,7 @@
 #include <asm/io.h>
 #include <dm/device_compat.h>
 #include <linux/bitops.h>
+#include <linux/iopoll.h>
 
 /* offset of register without set/clear management */
 #define RCC_MP_GCR_OFFSET 0x10C
@@ -23,6 +24,8 @@
 /* reset clear offset for STM32MP RCC */
 #define RCC_CL 0x4
 
+#define STM32_DEASSERT_TIMEOUT_US	10000
+
 struct stm32_reset_priv {
 	fdt_addr_t base;
 };
@@ -48,6 +51,18 @@ static int stm32_reset_assert(struct reset_ctl *reset_ctl)
 	return 0;
 }
 
+static int stm32_check_deassert(struct reset_ctl *reset_ctl)
+{
+	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
+	int bank = (reset_ctl->id / (sizeof(u32) * BITS_PER_BYTE)) * 4;
+	int offset = reset_ctl->id % (sizeof(u32) * BITS_PER_BYTE);
+	u32 status;
+
+	return readl_poll_timeout(priv->base + bank, status,
+				  !(status & BIT(offset)),
+				   STM32_DEASSERT_TIMEOUT_US);
+}
+
 static int stm32_reset_deassert(struct reset_ctl *reset_ctl)
 {
 	struct stm32_reset_priv *priv = dev_get_priv(reset_ctl->dev);
@@ -66,7 +81,8 @@ static int stm32_reset_deassert(struct reset_ctl *reset_ctl)
 	else
 		clrbits_le32(priv->base + bank, BIT(offset));
 
-	return 0;
+
+	return stm32_check_deassert(reset_ctl);
 }
 
 static const struct reset_ops stm32_reset_ops = {
diff --git a/drivers/rng/Kconfig b/drivers/rng/Kconfig
index 16143681da..64e52adcb7 100644
--- a/drivers/rng/Kconfig
+++ b/drivers/rng/Kconfig
@@ -41,17 +41,18 @@ config RNG_NPCM
 config RNG_OPTEE
 	bool "OP-TEE based Random Number Generator support"
 	depends on DM_RNG && OPTEE
+	default y if OPTEE_SERVICE_DISCOVERY
 	help
 	  This driver provides support for the OP-TEE based Random Number
 	  Generator on ARM SoCs where hardware entropy sources are not
 	  accessible to normal world but reserved and used by the OP-TEE
 	  to avoid the weakness of a software PRNG.
 
-config RNG_STM32MP1
-	bool "Enable random number generator for STM32MP1"
-	depends on ARCH_STM32MP
+config RNG_STM32
+	bool "Enable random number generator for STM32"
+	depends on ARCH_STM32 || ARCH_STM32MP
 	help
-	  Enable STM32MP1 rng driver.
+	  Enable STM32 rng driver.
 
 config RNG_ROCKCHIP
 	bool "Enable random number generator for rockchip crypto rng"
diff --git a/drivers/rng/Makefile b/drivers/rng/Makefile
index 78f61051ac..192f911e15 100644
--- a/drivers/rng/Makefile
+++ b/drivers/rng/Makefile
@@ -9,7 +9,7 @@ obj-$(CONFIG_RNG_SANDBOX) += sandbox_rng.o
 obj-$(CONFIG_RNG_MSM) += msm_rng.o
 obj-$(CONFIG_RNG_NPCM) += npcm_rng.o
 obj-$(CONFIG_RNG_OPTEE) += optee_rng.o
-obj-$(CONFIG_RNG_STM32MP1) += stm32mp1_rng.o
+obj-$(CONFIG_RNG_STM32) += stm32_rng.o
 obj-$(CONFIG_RNG_ROCKCHIP) += rockchip_rng.o
 obj-$(CONFIG_RNG_IPROC200) += iproc_rng200.o
 obj-$(CONFIG_RNG_SMCCC_TRNG) += smccc_trng.o
diff --git a/drivers/rng/optee_rng.c b/drivers/rng/optee_rng.c
index aa8ce864d3..410dfc053f 100644
--- a/drivers/rng/optee_rng.c
+++ b/drivers/rng/optee_rng.c
@@ -11,6 +11,9 @@
 #include <dm/device.h>
 #include <dm/device_compat.h>
 #include <linux/sizes.h>
+#include <tee/optee_service.h>
+
+#define DRIVER_NAME	"optee-rng"
 
 #define TEE_ERROR_HEALTH_TEST_FAIL	0x00000001
 
@@ -35,6 +38,8 @@
 #define TA_HWRNG_UUID { 0xab7a617c, 0xb8e7, 0x4d8f, \
 			{ 0x83, 0x01, 0xd0, 0x9b, 0x61, 0x03, 0x6b, 0x64 } }
 
+OPTEE_SERVICE_DRIVER(optee_rng, TA_HWRNG_UUID, DRIVER_NAME);
+
 /** open_session_ta_hwrng() - Open session with hwrng Trusted App
  *
  * @dev:		device
@@ -177,7 +182,7 @@ static const struct dm_rng_ops optee_rng_ops = {
 };
 
 U_BOOT_DRIVER(optee_rng) = {
-	.name = "optee-rng",
+	.name = DRIVER_NAME,
 	.id = UCLASS_RNG,
 	.ops = &optee_rng_ops,
 	.probe = optee_rng_probe,
diff --git a/drivers/rng/stm32_rng.c b/drivers/rng/stm32_rng.c
new file mode 100644
index 0000000000..fa232423b4
--- /dev/null
+++ b/drivers/rng/stm32_rng.c
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2019, Linaro Limited
+ */
+
+#define LOG_CATEGORY UCLASS_RNG
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <log.h>
+#include <reset.h>
+#include <rng.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+
+#define RNG_CR			0x00
+#define RNG_CR_RNGEN		BIT(2)
+#define RNG_CR_CED		BIT(5)
+#define RNG_CR_CONFIG1		GENMASK(11, 8)
+#define RNG_CR_NISTC		BIT(12)
+#define RNG_CR_CONFIG2		GENMASK(15, 13)
+#define RNG_CR_CLKDIV_SHIFT	16
+#define RNG_CR_CLKDIV		GENMASK(19, 16)
+#define RNG_CR_CONFIG3		GENMASK(25, 20)
+#define RNG_CR_CONDRST		BIT(30)
+#define RNG_CR_ENTROPY_SRC_MASK	(RNG_CR_CONFIG1 | RNG_CR_NISTC | RNG_CR_CONFIG2 | RNG_CR_CONFIG3)
+#define RNG_CR_CONFIG_MASK	(RNG_CR_ENTROPY_SRC_MASK | RNG_CR_CED | RNG_CR_CLKDIV)
+
+#define RNG_SR		0x04
+#define RNG_SR_SEIS	BIT(6)
+#define RNG_SR_CEIS	BIT(5)
+#define RNG_SR_SECS	BIT(2)
+#define RNG_SR_DRDY	BIT(0)
+
+#define RNG_DR		0x08
+
+#define RNG_NSCR		0x0C
+#define RNG_NSCR_MASK		GENMASK(17, 0)
+
+#define RNG_HTCR	0x10
+
+#define RNG_NB_RECOVER_TRIES	3
+
+/*
+ * struct stm32_rng_data - RNG compat data
+ *
+ * @max_clock_rate:	Max RNG clock frequency, in Hertz
+ * @nb_clock:		Number of clock to handle
+ * @cr:			Entropy source configuration
+ * @nscr:		Noice sources control configuration
+ * @htcr:		Health tests configuration
+ * @has_cond_reset:	True if conditional reset is supported
+ *
+ */
+struct stm32_rng_data {
+	uint max_clock_rate;
+	uint nb_clock;
+	u32 cr;
+	u32 nscr;
+	u32 htcr;
+	bool has_cond_reset;
+};
+
+struct stm32_rng_plat {
+	fdt_addr_t base;
+	struct clk clk;
+	struct clk bus_clk;
+	struct reset_ctl rst;
+	const struct stm32_rng_data *data;
+	bool ced;
+};
+
+/*
+ * Extracts from the STM32 RNG specification when RNG supports CONDRST.
+ *
+ * When a noise source (or seed) error occurs, the RNG stops generating
+ * random numbers and sets to “1” both SEIS and SECS bits to indicate
+ * that a seed error occurred. (...)
+ *
+ * 1. Software reset by writing CONDRST at 1 and at 0 (see bitfield
+ * description for details). This step is needed only if SECS is set.
+ * Indeed, when SEIS is set and SECS is cleared it means RNG performed
+ * the reset automatically (auto-reset).
+ * 2. If SECS was set in step 1 (no auto-reset) wait for CONDRST
+ * to be cleared in the RNG_CR register, then confirm that SEIS is
+ * cleared in the RNG_SR register. Otherwise just clear SEIS bit in
+ * the RNG_SR register.
+ * 3. If SECS was set in step 1 (no auto-reset) wait for SECS to be
+ * cleared by RNG. The random number generation is now back to normal.
+ */
+static int stm32_rng_conceal_seed_error_cond_reset(struct stm32_rng_plat *pdata)
+{
+	u32 sr = readl_relaxed(pdata->base + RNG_SR);
+	u32 cr = readl_relaxed(pdata->base + RNG_CR);
+	int err;
+
+	if (sr & RNG_SR_SECS) {
+		/* Conceal by resetting the subsystem (step 1.) */
+		writel_relaxed(cr | RNG_CR_CONDRST, pdata->base + RNG_CR);
+		writel_relaxed(cr & ~RNG_CR_CONDRST, pdata->base + RNG_CR);
+	} else {
+		/* RNG auto-reset (step 2.) */
+		writel_relaxed(sr & ~RNG_SR_SEIS, pdata->base + RNG_SR);
+		return 0;
+	}
+
+	err = readl_relaxed_poll_timeout(pdata->base + RNG_SR, sr, !(sr & RNG_CR_CONDRST), 100000);
+	if (err) {
+		log_err("%s: timeout %x\n", __func__, sr);
+		return err;
+	}
+
+	/* Check SEIS is cleared (step 2.) */
+	if (readl_relaxed(pdata->base + RNG_SR) & RNG_SR_SEIS)
+		return -EINVAL;
+
+	err = readl_relaxed_poll_timeout(pdata->base + RNG_SR, sr, !(sr & RNG_SR_SECS), 100000);
+	if (err) {
+		log_err("%s: timeout %x\n", __func__, sr);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * Extracts from the STM32 RNG specification, when CONDRST is not supported
+ *
+ * When a noise source (or seed) error occurs, the RNG stops generating
+ * random numbers and sets to “1” both SEIS and SECS bits to indicate
+ * that a seed error occurred. (...)
+ *
+ * The following sequence shall be used to fully recover from a seed
+ * error after the RNG initialization:
+ * 1. Clear the SEIS bit by writing it to “0”.
+ * 2. Read out 12 words from the RNG_DR register, and discard each of
+ * them in order to clean the pipeline.
+ * 3. Confirm that SEIS is still cleared. Random number generation is
+ * back to normal.
+ */
+static int stm32_rng_conceal_seed_error_sw_reset(struct stm32_rng_plat *pdata)
+{
+	uint i = 0;
+	u32 sr = readl_relaxed(pdata->base + RNG_SR);
+
+	writel_relaxed(sr & ~RNG_SR_SEIS, pdata->base + RNG_SR);
+
+	for (i = 12; i != 0; i--)
+		(void)readl_relaxed(pdata->base + RNG_DR);
+
+	if (readl_relaxed(pdata->base + RNG_SR) & RNG_SR_SEIS)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int stm32_rng_conceal_seed_error(struct stm32_rng_plat *pdata)
+{
+	log_debug("Concealing RNG seed error\n");
+
+	if (pdata->data->has_cond_reset)
+		return stm32_rng_conceal_seed_error_cond_reset(pdata);
+	else
+		return stm32_rng_conceal_seed_error_sw_reset(pdata);
+};
+
+static int stm32_rng_read(struct udevice *dev, void *data, size_t len)
+{
+	int retval;
+	u32 sr, reg;
+	size_t increment;
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+	uint tries = 0;
+
+	while (len > 0) {
+		retval = readl_poll_timeout(pdata->base + RNG_SR, sr,
+					    sr, 10000);
+		if (retval) {
+			log_err("%s: Timeout RNG no data",  __func__);
+			return retval;
+		}
+
+		if (sr != RNG_SR_DRDY) {
+			if (sr & RNG_SR_SEIS) {
+				retval = stm32_rng_conceal_seed_error(pdata);
+				tries++;
+				if (retval || tries > RNG_NB_RECOVER_TRIES) {
+					log_err("%s: Couldn't recover from seed error",  __func__);
+					return -ENOTRECOVERABLE;
+				}
+
+				/* Start again */
+				continue;
+			}
+
+			if (sr & RNG_SR_CEIS) {
+				log_info("RNG clock too slow");
+				writel_relaxed(0, pdata->base + RNG_SR);
+			}
+		}
+
+		/*
+		 * Once the DRDY bit is set, the RNG_DR register can
+		 * be read up to four consecutive times.
+		 */
+		reg = readl(pdata->base + RNG_DR);
+		/* Late seed error case: DR being 0 is an error status */
+		if (!reg) {
+			retval = stm32_rng_conceal_seed_error(pdata);
+			tries++;
+
+			if (retval || tries > RNG_NB_RECOVER_TRIES) {
+				log_err("%s: Couldn't recover from seed error",  __func__);
+				return -ENOTRECOVERABLE;
+			}
+
+			/* Start again */
+			continue;
+		}
+
+		increment = min(len, sizeof(u32));
+		memcpy(data, &reg, increment);
+		data += increment;
+		len -= increment;
+
+		tries = 0;
+	}
+
+	return 0;
+}
+
+static uint stm32_rng_clock_freq_restrain(struct stm32_rng_plat *pdata)
+{
+	ulong clock_rate = 0;
+	uint clock_div = 0;
+
+	clock_rate = clk_get_rate(&pdata->clk);
+
+	/*
+	 * Get the exponent to apply on the CLKDIV field in RNG_CR register.
+	 * No need to handle the case when clock-div > 0xF as it is physically
+	 * impossible.
+	 */
+	while ((clock_rate >> clock_div) > pdata->data->max_clock_rate)
+		clock_div++;
+
+	log_debug("RNG clk rate : %lu\n", clk_get_rate(&pdata->clk) >> clock_div);
+
+	return clock_div;
+}
+
+static int stm32_rng_init(struct stm32_rng_plat *pdata)
+{
+	int err;
+	u32 cr, sr;
+
+	err = clk_enable(&pdata->clk);
+	if (err)
+		return err;
+
+	if (pdata->data->nb_clock > 1) {
+		err = clk_enable(&pdata->bus_clk);
+		if (err) {
+			clk_disable(&pdata->clk);
+			return err;
+		}
+	}
+
+	cr = readl(pdata->base + RNG_CR);
+
+	/*
+	 * Keep default RNG configuration if none was specified, that is when conf.cr is set to 0.
+	 */
+	if (pdata->data->has_cond_reset && pdata->data->cr) {
+		uint clock_div = stm32_rng_clock_freq_restrain(pdata);
+
+		cr &= ~RNG_CR_CONFIG_MASK;
+		cr |= RNG_CR_CONDRST | (pdata->data->cr & RNG_CR_ENTROPY_SRC_MASK) |
+		      (clock_div << RNG_CR_CLKDIV_SHIFT);
+		if (pdata->ced)
+			cr &= ~RNG_CR_CED;
+		else
+			cr |= RNG_CR_CED;
+		writel(cr, pdata->base + RNG_CR);
+
+		/* Health tests and noise control registers */
+		writel_relaxed(pdata->data->htcr, pdata->base + RNG_HTCR);
+		writel_relaxed(pdata->data->nscr & RNG_NSCR_MASK, pdata->base + RNG_NSCR);
+
+		cr &= ~RNG_CR_CONDRST;
+		cr |= RNG_CR_RNGEN;
+		writel(cr, pdata->base + RNG_CR);
+		err = readl_poll_timeout(pdata->base + RNG_CR, cr,
+					 (!(cr & RNG_CR_CONDRST)), 10000);
+		if (err) {
+			log_err("%s: Timeout!",  __func__);
+			return err;
+		}
+	} else {
+		if (pdata->data->has_cond_reset)
+			cr |= RNG_CR_CONDRST;
+
+		if (pdata->ced)
+			cr &= ~RNG_CR_CED;
+		else
+			cr |= RNG_CR_CED;
+
+		writel(cr, pdata->base + RNG_CR);
+
+		if (pdata->data->has_cond_reset)
+			cr &= ~RNG_CR_CONDRST;
+
+		cr |= RNG_CR_RNGEN;
+
+		writel(cr, pdata->base + RNG_CR);
+	}
+
+	/* clear error indicators */
+	writel(0, pdata->base + RNG_SR);
+
+	err = readl_poll_timeout(pdata->base + RNG_SR, sr,
+				 sr & RNG_SR_DRDY, 10000);
+	if (err)
+		log_err("%s: Timeout!",  __func__);
+
+	return err;
+}
+
+static int stm32_rng_cleanup(struct stm32_rng_plat *pdata)
+{
+	int err;
+
+	writel(0, pdata->base + RNG_CR);
+
+	if (pdata->data->nb_clock > 1) {
+		err = clk_disable(&pdata->bus_clk);
+		if (err)
+			return err;
+	}
+
+	return clk_disable(&pdata->clk);
+}
+
+static int stm32_rng_probe(struct udevice *dev)
+{
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+
+	reset_assert(&pdata->rst);
+	udelay(20);
+	reset_deassert(&pdata->rst);
+
+	return stm32_rng_init(pdata);
+}
+
+static int stm32_rng_remove(struct udevice *dev)
+{
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+
+	return stm32_rng_cleanup(pdata);
+}
+
+static int stm32_rng_of_to_plat(struct udevice *dev)
+{
+	struct stm32_rng_plat *pdata = dev_get_plat(dev);
+	int err;
+
+	pdata->base = dev_read_addr(dev);
+	if (!pdata->base)
+		return -ENOMEM;
+
+	pdata->data = (struct stm32_rng_data *)dev_get_driver_data(dev);
+
+	if (pdata->data->nb_clock > 1) {
+		err = clk_get_by_name(dev, "rng_clk", &pdata->clk);
+		if (err)
+			return err;
+
+		err = clk_get_by_name(dev, "rng_hclk", &pdata->bus_clk);
+		if (err)
+			return err;
+	} else {
+		err = clk_get_by_index(dev, 0, &pdata->clk);
+		if (err)
+			return err;
+	}
+
+	err = reset_get_by_index(dev, 0, &pdata->rst);
+	if (err)
+		return err;
+
+	pdata->ced = dev_read_bool(dev, "clock-error-detect");
+
+	return 0;
+}
+
+static const struct dm_rng_ops stm32_rng_ops = {
+	.read = stm32_rng_read,
+};
+
+static const struct stm32_rng_data stm32mp25_rng_data = {
+	.has_cond_reset = true,
+	.max_clock_rate = 48000000,
+	.nb_clock = 2,
+	.htcr = 0x969D,
+	.nscr = 0x2B5BB,
+	.cr = 0xF00D00,
+};
+
+static const struct stm32_rng_data stm32mp13_rng_data = {
+	.has_cond_reset = true,
+	.max_clock_rate = 48000000,
+	.nb_clock = 1,
+	.htcr = 0x969D,
+	.nscr = 0x2B5BB,
+	.cr = 0xF00D00,
+};
+
+static const struct stm32_rng_data stm32_rng_data = {
+	.has_cond_reset = false,
+	.max_clock_rate = 48000000,
+	.nb_clock = 1,
+};
+
+static const struct udevice_id stm32_rng_match[] = {
+	{.compatible = "st,stm32mp25-rng", .data = (ulong)&stm32mp25_rng_data},
+	{.compatible = "st,stm32mp13-rng", .data = (ulong)&stm32mp13_rng_data},
+	{.compatible = "st,stm32-rng", .data = (ulong)&stm32_rng_data},
+	{},
+};
+
+U_BOOT_DRIVER(stm32_rng) = {
+	.name = "stm32-rng",
+	.id = UCLASS_RNG,
+	.of_match = stm32_rng_match,
+	.ops = &stm32_rng_ops,
+	.probe = stm32_rng_probe,
+	.remove = stm32_rng_remove,
+	.plat_auto	= sizeof(struct stm32_rng_plat),
+	.of_to_plat = stm32_rng_of_to_plat,
+};
diff --git a/drivers/rng/stm32mp1_rng.c b/drivers/rng/stm32mp1_rng.c
deleted file mode 100644
index 89da78c6c8..0000000000
--- a/drivers/rng/stm32mp1_rng.c
+++ /dev/null
@@ -1,198 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (c) 2019, Linaro Limited
- */
-
-#define LOG_CATEGORY UCLASS_RNG
-
-#include <common.h>
-#include <clk.h>
-#include <dm.h>
-#include <log.h>
-#include <reset.h>
-#include <rng.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
-
-#include <asm/io.h>
-#include <linux/iopoll.h>
-#include <linux/kernel.h>
-
-#define RNG_CR		0x00
-#define RNG_CR_RNGEN	BIT(2)
-#define RNG_CR_CED	BIT(5)
-#define RNG_CR_CONDRST	BIT(30)
-
-#define RNG_SR		0x04
-#define RNG_SR_SEIS	BIT(6)
-#define RNG_SR_CEIS	BIT(5)
-#define RNG_SR_SECS	BIT(2)
-#define RNG_SR_DRDY	BIT(0)
-
-#define RNG_DR		0x08
-
-struct stm32_rng_data {
-	bool has_cond_reset;
-};
-
-struct stm32_rng_plat {
-	fdt_addr_t base;
-	struct clk clk;
-	struct reset_ctl rst;
-	const struct stm32_rng_data *data;
-};
-
-static int stm32_rng_read(struct udevice *dev, void *data, size_t len)
-{
-	int retval, i;
-	u32 sr, count, reg;
-	size_t increment;
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-
-	while (len > 0) {
-		retval = readl_poll_timeout(pdata->base + RNG_SR, sr,
-					    sr & RNG_SR_DRDY, 10000);
-		if (retval)
-			return retval;
-
-		if (sr & (RNG_SR_SEIS | RNG_SR_SECS)) {
-			/* As per SoC TRM */
-			clrbits_le32(pdata->base + RNG_SR, RNG_SR_SEIS);
-			for (i = 0; i < 12; i++)
-				readl(pdata->base + RNG_DR);
-			if (readl(pdata->base + RNG_SR) & RNG_SR_SEIS) {
-				log_err("RNG Noise");
-				return -EIO;
-			}
-			/* start again */
-			continue;
-		}
-
-		/*
-		 * Once the DRDY bit is set, the RNG_DR register can
-		 * be read four consecutive times.
-		 */
-		count = 4;
-		while (len && count) {
-			reg = readl(pdata->base + RNG_DR);
-			memcpy(data, &reg, min(len, sizeof(u32)));
-			increment = min(len, sizeof(u32));
-			data += increment;
-			len -= increment;
-			count--;
-		}
-	}
-
-	return 0;
-}
-
-static int stm32_rng_init(struct stm32_rng_plat *pdata)
-{
-	int err;
-	u32 cr, sr;
-
-	err = clk_enable(&pdata->clk);
-	if (err)
-		return err;
-
-	cr = readl(pdata->base + RNG_CR);
-
-	/* Disable CED */
-	cr |= RNG_CR_CED;
-	if (pdata->data->has_cond_reset) {
-		cr |= RNG_CR_CONDRST;
-		writel(cr, pdata->base + RNG_CR);
-		cr &= ~RNG_CR_CONDRST;
-		writel(cr, pdata->base + RNG_CR);
-		err = readl_poll_timeout(pdata->base + RNG_CR, cr,
-					 (!(cr & RNG_CR_CONDRST)), 10000);
-		if (err)
-			return err;
-	}
-
-	/* clear error indicators */
-	writel(0, pdata->base + RNG_SR);
-
-	cr |= RNG_CR_RNGEN;
-	writel(cr, pdata->base + RNG_CR);
-
-	err = readl_poll_timeout(pdata->base + RNG_SR, sr,
-				 sr & RNG_SR_DRDY, 10000);
-	return err;
-}
-
-static int stm32_rng_cleanup(struct stm32_rng_plat *pdata)
-{
-	writel(0, pdata->base + RNG_CR);
-
-	return clk_disable(&pdata->clk);
-}
-
-static int stm32_rng_probe(struct udevice *dev)
-{
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-
-	pdata->data = (struct stm32_rng_data *)dev_get_driver_data(dev);
-
-	reset_assert(&pdata->rst);
-	udelay(20);
-	reset_deassert(&pdata->rst);
-
-	return stm32_rng_init(pdata);
-}
-
-static int stm32_rng_remove(struct udevice *dev)
-{
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-
-	return stm32_rng_cleanup(pdata);
-}
-
-static int stm32_rng_of_to_plat(struct udevice *dev)
-{
-	struct stm32_rng_plat *pdata = dev_get_plat(dev);
-	int err;
-
-	pdata->base = dev_read_addr(dev);
-	if (!pdata->base)
-		return -ENOMEM;
-
-	err = clk_get_by_index(dev, 0, &pdata->clk);
-	if (err)
-		return err;
-
-	err = reset_get_by_index(dev, 0, &pdata->rst);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-static const struct dm_rng_ops stm32_rng_ops = {
-	.read = stm32_rng_read,
-};
-
-static const struct stm32_rng_data stm32mp13_rng_data = {
-	.has_cond_reset = true,
-};
-
-static const struct stm32_rng_data stm32_rng_data = {
-	.has_cond_reset = false,
-};
-
-static const struct udevice_id stm32_rng_match[] = {
-	{.compatible = "st,stm32mp13-rng", .data = (ulong)&stm32mp13_rng_data},
-	{.compatible = "st,stm32-rng", .data = (ulong)&stm32_rng_data},
-	{},
-};
-
-U_BOOT_DRIVER(stm32_rng) = {
-	.name = "stm32-rng",
-	.id = UCLASS_RNG,
-	.of_match = stm32_rng_match,
-	.ops = &stm32_rng_ops,
-	.probe = stm32_rng_probe,
-	.remove = stm32_rng_remove,
-	.plat_auto	= sizeof(struct stm32_rng_plat),
-	.of_to_plat = stm32_rng_of_to_plat,
-};
diff --git a/drivers/rtc/stm32_rtc.c b/drivers/rtc/stm32_rtc.c
index 1753283460..a2ae5f8056 100644
--- a/drivers/rtc/stm32_rtc.c
+++ b/drivers/rtc/stm32_rtc.c
@@ -12,6 +12,7 @@
 #include <rtc.h>
 #include <asm/io.h>
 #include <dm/device_compat.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/iopoll.h>
 
@@ -60,10 +61,25 @@
 #define RTC_WPR_2ND_KEY		0x53
 #define RTC_WPR_WRONG_KEY	0xFF
 
+/* STM32_RTC_SECCFGR bit fields */
+#define STM32_RTC_SECCFGR		0x20
+#define STM32_RTC_SECCFGR_INIT_SEC	BIT(14)
+#define STM32_RTC_SECCFGR_SEC		BIT(15)
+
+/* STM32_RTC_R5CIDCFGR bit fields */
+#define STM32_RTC_R5CIDCFGR		0x94
+#define STM32_RTC_R5CIDCFGR_CFEN	BIT(0)
+#define STM32_RTC_R5CIDCFGR_CID		GENMASK(6, 4)
+#define STM32_RTC_R5CIDCFGR_CID1	0x1
+
 struct stm32_rtc_priv {
 	fdt_addr_t base;
 };
 
+struct stm32_rtc_data {
+	bool rif_protected;
+};
+
 static int stm32_rtc_get(struct udevice *dev, struct rtc_time *tm)
 {
 	struct stm32_rtc_priv *priv = dev_get_priv(dev);
@@ -206,6 +222,25 @@ static int stm32_rtc_reset(struct udevice *dev)
 	return stm32_rtc_set_time(dev, 0, 0);
 }
 
+static int stm32_rtc_check_rif(struct udevice *dev)
+{
+	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	u32 rxcidcfgr = readl(priv->base + STM32_RTC_R5CIDCFGR);
+	u32 seccfgr;
+
+	/* Check if RTC available for our CID */
+	if ((rxcidcfgr & STM32_RTC_R5CIDCFGR_CFEN) &&
+	    (FIELD_GET(STM32_RTC_R5CIDCFGR_CID, rxcidcfgr) != STM32_RTC_R5CIDCFGR_CID1))
+		return -EACCES;
+
+	/* Check if RTC available for non-secure world */
+	seccfgr = readl(priv->base + STM32_RTC_SECCFGR);
+	if (seccfgr & (STM32_RTC_SECCFGR_SEC | STM32_RTC_SECCFGR_INIT_SEC))
+		return -EACCES;
+
+	return 0;
+}
+
 static int stm32_rtc_init(struct udevice *dev)
 {
 	struct stm32_rtc_priv *priv = dev_get_priv(dev);
@@ -286,6 +321,7 @@ unlock:
 static int stm32_rtc_probe(struct udevice *dev)
 {
 	struct stm32_rtc_priv *priv = dev_get_priv(dev);
+	const struct stm32_rtc_data *data = (const struct stm32_rtc_data *)dev_get_driver_data(dev);
 	struct clk clk;
 	int ret;
 
@@ -303,6 +339,16 @@ static int stm32_rtc_probe(struct udevice *dev)
 		return ret;
 	}
 
+	if (data->rif_protected) {
+		ret = stm32_rtc_check_rif(dev);
+		if (ret) {
+			dev_err(dev, "Failed to probe RTC due to RIF configuration\n");
+			clk_disable(&clk);
+			clk_free(&clk);
+			return ret;
+		}
+	}
+
 	ret = stm32_rtc_init(dev);
 
 	if (ret) {
@@ -313,6 +359,14 @@ static int stm32_rtc_probe(struct udevice *dev)
 	return ret;
 }
 
+static const struct stm32_rtc_data stm32mp1_data = {
+	.rif_protected = false
+};
+
+static const struct stm32_rtc_data stm32mp25_data = {
+	.rif_protected = true
+};
+
 static const struct rtc_ops stm32_rtc_ops = {
 	.get = stm32_rtc_get,
 	.set = stm32_rtc_set,
@@ -320,7 +374,8 @@ static const struct rtc_ops stm32_rtc_ops = {
 };
 
 static const struct udevice_id stm32_rtc_ids[] = {
-	{ .compatible = "st,stm32mp1-rtc" },
+	{ .compatible = "st,stm32mp1-rtc", .data = (ulong)&stm32mp1_data },
+	{ .compatible = "st,stm32mp25-rtc", .data = (ulong)&stm32mp25_data },
 	{ }
 };
 
diff --git a/drivers/serial/serial_stm32.c b/drivers/serial/serial_stm32.c
index 2ba92bf9c4..cda7880a18 100644
--- a/drivers/serial/serial_stm32.c
+++ b/drivers/serial/serial_stm32.c
@@ -18,16 +18,32 @@
 #include <dm/device_compat.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
+#include <linux/iopoll.h>
 #include "serial_stm32.h"
 #include <dm/device_compat.h>
 
-static void _stm32_serial_setbrg(fdt_addr_t base,
+/*
+ * At 115200 bits/s
+ * 1 bit = 1 / 115200 = 8,68 us
+ * 8 bits = 69,444 us
+ * 10 bits are needed for worst case (8 bits + 1 start + 1 stop) = 86.806 us
+ */
+#define ONE_BYTE_B115200_US		87
+
+/* This is used to compute a timeout, take the worst possible case: STM32MP2 */
+#define STM32_USART_FIFO_TMO_US		(64 * ONE_BYTE_B115200_US)
+
+static void _stm32_serial_setbrg(void __iomem *base,
 				 struct stm32_uart_info *uart_info,
 				 u32 clock_rate,
 				 int baudrate)
 {
 	bool stm32f4 = uart_info->stm32f4;
 	u32 int_div, mantissa, fraction, oversampling;
+	u8 uart_enable_bit = uart_info->uart_enable_bit;
+
+	/* BRR register must be set when uart is disabled */
+	clrbits_le32(base + CR1_OFFSET(stm32f4), BIT(uart_enable_bit));
 
 	int_div = DIV_ROUND_CLOSEST(clock_rate, baudrate);
 
@@ -43,6 +59,8 @@ static void _stm32_serial_setbrg(fdt_addr_t base,
 	fraction = int_div % oversampling;
 
 	writel(mantissa | fraction, base + BRR_OFFSET(stm32f4));
+
+	setbits_le32(base + CR1_OFFSET(stm32f4), BIT(uart_enable_bit));
 }
 
 static int stm32_serial_setbrg(struct udevice *dev, int baudrate)
@@ -60,7 +78,7 @@ static int stm32_serial_setconfig(struct udevice *dev, uint serial_config)
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	bool stm32f4 = plat->uart_info->stm32f4;
 	u8 uart_enable_bit = plat->uart_info->uart_enable_bit;
-	u32 cr1 = plat->base + CR1_OFFSET(stm32f4);
+	void __iomem *cr1 = plat->base + CR1_OFFSET(stm32f4);
 	u32 config = 0;
 	uint parity = SERIAL_GET_PARITY(serial_config);
 	uint bits = SERIAL_GET_BITS(serial_config);
@@ -107,7 +125,7 @@ static int stm32_serial_getc(struct udevice *dev)
 {
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	bool stm32f4 = plat->uart_info->stm32f4;
-	fdt_addr_t base = plat->base;
+	void __iomem *base = plat->base;
 	u32 isr = readl(base + ISR_OFFSET(stm32f4));
 
 	if ((isr & USART_ISR_RXNE) == 0)
@@ -126,7 +144,7 @@ static int stm32_serial_getc(struct udevice *dev)
 	return readl(base + RDR_OFFSET(stm32f4));
 }
 
-static int _stm32_serial_putc(fdt_addr_t base,
+static int _stm32_serial_putc(void __iomem *base,
 			      struct stm32_uart_info *uart_info,
 			      const char c)
 {
@@ -151,7 +169,7 @@ static int stm32_serial_pending(struct udevice *dev, bool input)
 {
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	bool stm32f4 = plat->uart_info->stm32f4;
-	fdt_addr_t base = plat->base;
+	void __iomem *base = plat->base;
 
 	if (input)
 		return readl(base + ISR_OFFSET(stm32f4)) &
@@ -161,7 +179,7 @@ static int stm32_serial_pending(struct udevice *dev, bool input)
 			USART_ISR_TXE ? 0 : 1;
 }
 
-static void _stm32_serial_init(fdt_addr_t base,
+static void _stm32_serial_init(void __iomem *base,
 			       struct stm32_uart_info *uart_info)
 {
 	bool stm32f4 = uart_info->stm32f4;
@@ -181,9 +199,12 @@ static int stm32_serial_probe(struct udevice *dev)
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
 	struct clk clk;
 	struct reset_ctl reset;
+	u32 isr;
 	int ret;
+	bool stm32f4;
 
 	plat->uart_info = (struct stm32_uart_info *)dev_get_driver_data(dev);
+	stm32f4 = plat->uart_info->stm32f4;
 
 	ret = clk_get_by_index(dev, 0, &clk);
 	if (ret < 0)
@@ -195,6 +216,15 @@ static int stm32_serial_probe(struct udevice *dev)
 		return ret;
 	}
 
+	/*
+	 * before uart initialization, wait for TC bit (Transmission Complete)
+	 * in case there is still chars from previous bootstage to transmit
+	 */
+	ret = read_poll_timeout(readl, isr, isr & USART_ISR_TC, 50, STM32_USART_FIFO_TMO_US,
+				plat->base + ISR_OFFSET(stm32f4));
+	if (ret)
+		dev_dbg(dev, "FIFO not empty, some character can be lost (%d)\n", ret);
+
 	ret = reset_get_by_index(dev, 0, &reset);
 	if (!ret) {
 		reset_assert(&reset);
@@ -223,11 +253,14 @@ static const struct udevice_id stm32_serial_id[] = {
 static int stm32_serial_of_to_plat(struct udevice *dev)
 {
 	struct stm32x7_serial_plat *plat = dev_get_plat(dev);
+	fdt_addr_t addr;
 
-	plat->base = dev_read_addr(dev);
-	if (plat->base == FDT_ADDR_T_NONE)
+	addr = dev_read_addr(dev);
+	if (addr == FDT_ADDR_T_NONE)
 		return -EINVAL;
 
+	plat->base = (void __iomem*)addr;
+
 	return 0;
 }
 
@@ -270,18 +303,24 @@ static inline struct stm32_uart_info *_debug_uart_info(void)
 
 static inline void _debug_uart_init(void)
 {
-	fdt_addr_t base = CONFIG_VAL(DEBUG_UART_BASE);
-	struct stm32_uart_info *uart_info = _debug_uart_info();
+	void __maybe_unused __iomem *base = (void __iomem *)CONFIG_VAL(DEBUG_UART_BASE);
+	struct stm32_uart_info *uart_info __maybe_unused = _debug_uart_info();
 
-	_stm32_serial_init(base, uart_info);
-	_stm32_serial_setbrg(base, uart_info,
-			     CONFIG_DEBUG_UART_CLOCK,
-			     CONFIG_BAUDRATE);
+	/*
+	 * debug_uart_init() is only usable when SPL_BUILD is enabled
+	 * (STM32MP1 case only)
+	 */
+	if (IS_ENABLED(CONFIG_DEBUG_UART) && IS_ENABLED(CONFIG_SPL_BUILD)) {
+		_stm32_serial_init(base, uart_info);
+		_stm32_serial_setbrg(base, uart_info,
+				     CONFIG_DEBUG_UART_CLOCK,
+				     CONFIG_BAUDRATE);
+	}
 }
 
 static inline void _debug_uart_putc(int c)
 {
-	fdt_addr_t base = CONFIG_VAL(DEBUG_UART_BASE);
+	void __iomem *base = (void __iomem *)CONFIG_VAL(DEBUG_UART_BASE);
 	struct stm32_uart_info *uart_info = _debug_uart_info();
 
 	while (_stm32_serial_putc(base, uart_info, c) == -EAGAIN)
diff --git a/drivers/serial/serial_stm32.h b/drivers/serial/serial_stm32.h
index 5bee68fa9c..d2c92ba48e 100644
--- a/drivers/serial/serial_stm32.h
+++ b/drivers/serial/serial_stm32.h
@@ -49,7 +49,7 @@ struct stm32_uart_info stm32h7_info = {
 
 /* Information about a serial port */
 struct stm32x7_serial_plat {
-	fdt_addr_t base;  /* address of registers in physical memory */
+	void __iomem *base;  /* address of registers in physical memory */
 	struct stm32_uart_info *uart_info;
 	unsigned long int clock_rate;
 };
@@ -66,6 +66,7 @@ struct stm32x7_serial_plat {
 #define USART_CR3_OVRDIS		BIT(12)
 
 #define USART_ISR_TXE			BIT(7)
+#define USART_ISR_TC			BIT(6)
 #define USART_ISR_RXNE			BIT(5)
 #define USART_ISR_ORE			BIT(3)
 #define USART_ISR_FE			BIT(1)
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 75b794548b..ad374595d5 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -423,6 +423,14 @@ config SPI_SUNXI
 
 	  Same controller driver can reuse in all Allwinner SoC variants.
 
+config STM32_OSPI
+	bool "STM32MP2 OSPI driver"
+	depends on STM32MP25X && STM32_OMM
+	help
+	  Enable the STM32MP2 Octo-SPI (OSPI) driver. This driver can be
+	  used to access the SPI NOR flash chips on platforms embedding
+	  this ST IP core.
+
 config STM32_QSPI
 	bool "STM32F7 QSPI driver"
 	depends on STM32F4 || STM32F7 || ARCH_STM32MP
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 4de77c260a..3095cf6bf1 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -65,6 +65,7 @@ obj-$(CONFIG_SANDBOX_SPI) += sandbox_spi.o
 obj-$(CONFIG_SPI_SIFIVE) += spi-sifive.o
 obj-$(CONFIG_SPI_SUNXI) += spi-sunxi.o
 obj-$(CONFIG_SH_QSPI) += sh_qspi.o
+obj-$(CONFIG_STM32_OSPI) += stm32_ospi.o
 obj-$(CONFIG_STM32_QSPI) += stm32_qspi.o
 obj-$(CONFIG_STM32_SPI) += stm32_spi.o
 obj-$(CONFIG_TEGRA114_SPI) += tegra114_spi.o
diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index 9c1ede1b61..ac8ccc3aea 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -179,10 +179,6 @@ bool spi_mem_dtr_supports_op(struct spi_slave *slave,
 	if (op->dummy.nbytes && op->dummy.buswidth == 8 && op->dummy.nbytes % 2)
 		return false;
 
-	if (op->data.dir != SPI_MEM_NO_DATA &&
-	    op->dummy.buswidth == 8 && op->data.nbytes % 2)
-		return false;
-
 	return spi_mem_check_buswidth(slave, op);
 }
 EXPORT_SYMBOL_GPL(spi_mem_dtr_supports_op);
diff --git a/drivers/spi/stm32_ospi.c b/drivers/spi/stm32_ospi.c
new file mode 100644
index 0000000000..3af197df01
--- /dev/null
+++ b/drivers/spi/stm32_ospi.c
@@ -0,0 +1,738 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SPI
+
+#include <common.h>
+#include <dm.h>
+#include <log.h>
+#include <regmap.h>
+#include <spi.h>
+#include <spi-mem.h>
+#include <stm32_omi.h>
+#include <syscon.h>
+#include <dm/device_compat.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/sizes.h>
+
+#define NSEC_PER_SEC		1000000000L
+#define MACRONIX_ID		0xc2
+
+struct stm32_ospi_flash {
+	u64 str_idcode;
+	u64 dtr_idcode;
+	bool is_spi_nor;
+	bool is_str_calibration;
+	bool dtr_calibration_done_once;
+	bool octal_dtr;
+};
+
+struct stm32_ospi_priv {
+	struct udevice *omi_dev;
+	struct stm32_ospi_flash flash[OSPI_MAX_CHIP];
+	int cs_used;
+};
+
+static int stm32_ospi_mm(struct udevice *omi_dev,
+			 const struct spi_mem_op *op)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+
+	memcpy_fromio(op->data.buf.in,
+		      (void __iomem *)omi_plat->mm_base + op->addr.val,
+		      op->data.nbytes);
+
+	return 0;
+}
+
+static int stm32_ospi_tx(struct udevice *omi_dev,
+			 const struct spi_mem_op *op,
+			 u8 mode)
+{
+	struct stm32_omi_priv *omi_priv = dev_get_priv(omi_dev);
+	struct stm32_ospi_priv *priv = dev_get_priv(omi_priv->dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	u8 *buf;
+	u8 dummy = 0xff;
+	int ret;
+
+	if (!op->data.nbytes)
+		return 0;
+
+	if (mode == OSPI_CCR_MEM_MAP)
+		return stm32_ospi_mm(omi_dev, op);
+
+	if (op->data.dir == SPI_MEM_DATA_IN)
+		buf = op->data.buf.in;
+	else
+		buf = (u8 *)op->data.buf.out;
+
+	if (flash->octal_dtr && op->addr.val % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi_dev, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	ret = stm32_omi_tx_poll(omi_dev, buf, op->data.nbytes,
+				op->data.dir == SPI_MEM_DATA_IN);
+	if (ret)
+		return ret;
+
+	if (flash->octal_dtr && (op->addr.val + op->data.nbytes) % 2) {
+		/* Read/write dummy byte */
+		ret = stm32_omi_tx_poll(omi_dev, &dummy, 1,
+					op->data.dir == SPI_MEM_DATA_IN);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_get_mode(u8 buswidth)
+{
+	if (buswidth == 8)
+		return 4;
+
+	if (buswidth == 4)
+		return 3;
+
+	return buswidth;
+}
+
+static int stm32_ospi_send(struct udevice *omi_dev,
+			   const struct spi_mem_op *op, u8 mode)
+{
+	struct stm32_omi_plat *omi_plat = dev_get_plat(omi_dev);
+	struct stm32_omi_priv *omi_priv = dev_get_priv(omi_dev);
+	struct stm32_ospi_priv *priv = dev_get_priv(omi_priv->dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 cr, ccr = 0;
+	int timeout, ret;
+	int dmode;
+	u8 dcyc = 0;
+	u64 addr = op->addr.val;
+	unsigned int nbytes = op->data.nbytes;
+
+	dev_dbg(omi_priv->dev, "%s: cmd:%#x dtr: %d mode:%d.%d.%d.%d addr:%#llx len:%#x\n",
+		__func__, op->cmd.opcode, op->cmd.dtr, op->cmd.buswidth,
+		op->addr.buswidth, op->dummy.buswidth, op->data.buswidth,
+		op->addr.val, op->data.nbytes);
+
+	/*
+	 * When DTR mode and indirect read/write mode are set, there is a
+	 * constraint on the address and the number of bytes read or write
+	 * that should be even.
+	 */
+	if (flash->octal_dtr && mode != OSPI_CCR_MEM_MAP && op->data.nbytes) {
+		if (op->addr.val % 2) {
+			addr--;
+			nbytes++;
+		}
+
+		if ((op->addr.val + op->data.nbytes) % 2)
+			nbytes++;
+	}
+
+	clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_MTYP_MASK);
+
+	if (op->data.nbytes && mode != OSPI_CCR_MEM_MAP)
+		writel(nbytes - 1, regs_base + OSPI_DLR);
+
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_FMODE_MASK,
+			mode << OSPI_CR_FMODE_SHIFT);
+
+	ccr |= ((op->cmd.nbytes - 1) << OSPI_CCR_ISIZE_SHIFT) &
+	       OSPI_CCR_ISIZE_MASK;
+
+	ccr |= (stm32_ospi_get_mode(op->cmd.buswidth) << OSPI_CCR_IMODE_SHIFT) &
+		OSPI_CCR_IMODE_MASK;
+
+	if (op->cmd.dtr) {
+		ccr |= OSPI_CCR_IDTR;
+		ccr |= OSPI_CCR_DQSE;
+	}
+
+	if (op->addr.dtr)
+		ccr |= OSPI_CCR_ADDTR;
+
+	if (op->data.dtr)
+		ccr |= OSPI_CCR_DDTR;
+
+	if (op->data.dtr_swab16)
+		clrsetbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_MTYP_MASK,
+				OSPI_DCR1_MTYP_MX_MODE << OSPI_DCR1_MTYP_SHIFT);
+
+	if (op->addr.nbytes) {
+		ccr |= ((op->addr.nbytes - 1) << OSPI_CCR_ADSIZE_SHIFT);
+		ccr |= (stm32_ospi_get_mode(op->addr.buswidth)
+			<< OSPI_CCR_ADMODE_SHIFT) & OSPI_CCR_ADMODE_MASK;
+	}
+
+	if (op->dummy.buswidth && op->dummy.nbytes) {
+		dcyc = op->dummy.nbytes * 8 / op->dummy.buswidth;
+
+		if (op->dummy.dtr)
+			dcyc /= 2;
+	}
+
+	clrsetbits_le32(regs_base + OSPI_TCR, OSPI_TCR_DCYC_MASK,
+			dcyc << OSPI_TCR_DCYC_SHIFT);
+
+	if (op->data.nbytes) {
+		dmode = stm32_ospi_get_mode(op->data.buswidth);
+		ccr |= (dmode << OSPI_CCR_DMODE_SHIFT) & OSPI_CCR_DMODE_MASK;
+	}
+
+	writel(ccr, regs_base + OSPI_CCR);
+
+	/* Set instruction, must be set after ccr register update */
+	writel(op->cmd.opcode, regs_base + OSPI_IR);
+
+	if (op->addr.nbytes && mode != OSPI_CCR_MEM_MAP)
+		writel(addr, regs_base + OSPI_AR);
+
+	ret = stm32_ospi_tx(omi_dev, op, mode);
+	/*
+	 * Abort in:
+	 * -error case
+	 * -read memory map: prefetching must be stopped if we read the last
+	 *  byte of device (device size - fifo size). like device size is not
+	 *  knows, the prefetching is always stop.
+	 */
+	if (ret || mode == OSPI_CCR_MEM_MAP)
+		goto abort;
+
+	/* Wait end of tx in indirect mode */
+	ret = stm32_omi_wait_cmd(omi_dev);
+	if (ret)
+		goto abort;
+
+	return 0;
+
+abort:
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_ABORT);
+
+	/* Wait clear of abort bit by hw */
+	timeout = readl_poll_timeout(regs_base + OSPI_CR, cr,
+				     !(cr & OSPI_CR_ABORT),
+				     OSPI_ABT_TIMEOUT_US);
+
+	writel(OSPI_FCR_CTCF, regs_base + OSPI_FCR);
+
+	if (!omi_priv->is_calibrating && (ret || timeout))
+		dev_err(omi_priv->dev, "%s ret:%d abort timeout:%d\n", __func__,
+			ret, timeout);
+
+	return ret;
+}
+
+static int stm32_ospi_set_speed(struct udevice *bus, uint speed)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 ospi_clk = omi_plat->clock_rate;
+	u32 prescaler = 255;
+	u32 csht;
+	uint bus_freq;
+	int ret;
+
+	if (speed > 0) {
+		prescaler = 0;
+		if (ospi_clk) {
+			prescaler = DIV_ROUND_UP(ospi_clk, speed) - 1;
+			if (prescaler > 255)
+				prescaler = 255;
+		}
+	}
+
+	csht = (DIV_ROUND_UP((5 * ospi_clk) / (prescaler + 1), 100000000)) - 1;
+
+	ret = stm32_omi_wait_for_not_busy(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	clrsetbits_le32(regs_base + OSPI_DCR2, OSPI_DCR2_PRESC_MASK,
+			prescaler << OSPI_DCR2_PRESC_SHIFT);
+
+	clrsetbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_CSHT_MASK,
+			csht << OSPI_DCR1_CSHT_SHIFT);
+
+	bus_freq = DIV_ROUND_UP(ospi_clk, prescaler + 1);
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD)
+		setbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DLYBYP);
+	else
+		clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DLYBYP);
+
+	return 0;
+}
+
+static int stm32_ospi_readid(struct udevice *omi_dev)
+{
+	struct stm32_omi_priv *omi_priv = dev_get_priv(omi_dev);
+	struct stm32_ospi_priv *priv = dev_get_priv(omi_priv->dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	u64 rx_buf;
+	struct spi_mem_op readid_op;
+	int ret;
+
+	if (flash->is_str_calibration) {
+		u8 nb_dummy_bytes = flash->is_spi_nor ? 0 : 1;
+
+		readid_op = (struct spi_mem_op)
+			    SPI_MEM_OP(SPI_MEM_OP_CMD(0x9f, 1),
+				       SPI_MEM_OP_NO_ADDR,
+				       SPI_MEM_OP_DUMMY(nb_dummy_bytes, 1),
+				       SPI_MEM_OP_DATA_IN(8, (u8 *)&rx_buf, 1));
+	} else {
+		if (flash->octal_dtr && flash->is_spi_nor) {
+			u16 opcode;
+			u8 nb_addr_bytes;
+			u8 nb_dummy_bytes;
+
+			if ((flash->dtr_idcode & 0xff) == MACRONIX_ID) {
+				opcode = 0x9f60;
+				nb_addr_bytes = 4;
+				nb_dummy_bytes = 8;
+			} else {
+				/*
+				 * All memory providers are not currently
+				 * supported, feel free to add them
+				 */
+				return -EOPNOTSUPP;
+			}
+
+			readid_op = (struct spi_mem_op)
+				    SPI_MEM_OP(SPI_MEM_OP_CMD(opcode, 8),
+					       SPI_MEM_OP_ADDR(nb_addr_bytes, 0, 8),
+					       SPI_MEM_OP_DUMMY(nb_dummy_bytes, 8),
+					       SPI_MEM_OP_DATA_IN(8, (u8 *)&rx_buf, 8));
+			readid_op.cmd.dtr = true;
+			readid_op.addr.dtr = true;
+			readid_op.dummy.dtr = true;
+			readid_op.data.dtr = true;
+			readid_op.cmd.nbytes = 2;
+		} else {
+			/*
+			 * Only OCTAL DTR calibration on SPI NOR devices
+			 * is currently supported
+			 */
+			return -EOPNOTSUPP;
+		}
+	}
+
+	ret = stm32_ospi_send(omi_dev, &readid_op, OSPI_CCR_IND_READ);
+	if (ret)
+		return ret;
+
+	dev_dbg(omi_dev, "Flash ID 0x%08llx\n", rx_buf);
+
+	if (flash->is_str_calibration) {
+		/*
+		 * On stm32_ospi_readid() first execution, save the golden
+		 * read id
+		 */
+		if (flash->str_idcode == 0) {
+			flash->str_idcode = rx_buf;
+
+			if (flash->is_spi_nor) {
+				/* Build DTR id code */
+				if ((rx_buf & 0xff) == MACRONIX_ID) {
+					/*
+					 * Retrieve odd array and re-sort id
+					 * because of read id format will be
+					 * A-A-B-B-C-C after enter into octal
+					 * dtr mode for Macronix flashes.
+					 */
+					flash->dtr_idcode = rx_buf & 0xff;
+					flash->dtr_idcode |= (rx_buf & 0xff) << 8;
+					flash->dtr_idcode |= (rx_buf & 0xff00) << 8;
+					flash->dtr_idcode |= (rx_buf & 0xff00) << 16;
+					flash->dtr_idcode |= (rx_buf & 0xff0000) << 16;
+					flash->dtr_idcode |= (rx_buf & 0xff0000) << 24;
+					flash->dtr_idcode |= (rx_buf & 0xff000000) << 24;
+					flash->dtr_idcode |= (rx_buf & 0xff000000) << 32;
+				} else {
+					flash->dtr_idcode = rx_buf;
+				}
+			}
+		}
+
+		if (rx_buf == flash->str_idcode)
+			return 0;
+	} else if (rx_buf == flash->dtr_idcode) {
+		return 0;
+	}
+
+	return -EIO;
+}
+
+static int stm32_ospi_str_calibration(struct udevice *bus)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 dlyb_cr;
+	u8 window_len_tcr0 = 0, window_len_tcr1 = 0;
+	int ret, ret_tcr0, ret_tcr1;
+	u32 dcr2, prescaler;
+	uint bus_freq;
+
+	dcr2 = readl(regs_base + OSPI_DCR2);
+	prescaler = (dcr2 & OSPI_DCR2_PRESC_MASK) >> OSPI_DCR2_PRESC_SHIFT;
+	bus_freq = DIV_ROUND_UP(omi_plat->clock_rate, prescaler + 1);
+
+	/*
+	 * Set memory device at low frequency (50MHz) and sent
+	 * READID (0x9F) command, save the answer as golden answer
+	 */
+	ret = stm32_ospi_set_speed(bus, STM32_DLYB_FREQ_THRESHOLD);
+	if (ret)
+		return ret;
+
+	flash->str_idcode = 0;
+	ret = stm32_ospi_readid(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	/* Set frequency at requested value */
+	ret = stm32_ospi_set_speed(bus, bus_freq);
+	if (ret)
+		return ret;
+
+	/* Calibration needed above 50MHz */
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD)
+		return 0;
+
+	/* Perform calibration */
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, false, 0);
+	if (ret)
+		return ret;
+
+	ret_tcr0 = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len_tcr0);
+	if (!ret_tcr0)
+		stm32_omi_dlyb_get_cr(priv->omi_dev, &dlyb_cr);
+
+	stm32_omi_dlyb_stop(priv->omi_dev);
+
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, false, 0);
+	if (ret)
+		return ret;
+
+	setbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+
+	ret_tcr1 = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len_tcr1);
+	if (ret_tcr0 && ret_tcr1) {
+		dev_info(bus, "Calibration phase failed\n");
+		return ret_tcr0;
+	}
+
+	if (window_len_tcr0 >= window_len_tcr1) {
+		clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+
+		stm32_omi_dlyb_stop(priv->omi_dev);
+
+		ret = stm32_omi_dlyb_set_cr(priv->omi_dev, dlyb_cr);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_dtr_calibration(struct udevice *bus)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 dcr2, prescaler;
+	uint bus_freq;
+	u16 period_ps = 0;
+	u8 window_len = 0;
+	int ret;
+	bool bypass_mode = false;
+
+	clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DLYBYP);
+
+	dcr2 = readl(regs_base + OSPI_DCR2);
+	prescaler = (dcr2 & OSPI_DCR2_PRESC_MASK) >> OSPI_DCR2_PRESC_SHIFT;
+	bus_freq = DIV_ROUND_UP(omi_plat->clock_rate, prescaler + 1);
+
+	if (prescaler)
+		setbits_le32(regs_base + OSPI_TCR, OSPI_TCR_DHQC);
+
+	if (bus_freq <= STM32_DLYB_FREQ_THRESHOLD) {
+		bypass_mode = true;
+		period_ps = NSEC_PER_SEC / (bus_freq / 1000);
+	}
+
+	ret = stm32_omi_dlyb_configure(priv->omi_dev, bypass_mode, period_ps);
+	if (ret)
+		return ret;
+
+	if (bypass_mode || prescaler)
+		/* Perform only RX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, true, &window_len);
+	else
+		/* Perform RX/TX TAP selection */
+		ret = stm32_omi_dlyb_find_tap(priv->omi_dev, false, &window_len);
+
+	if (ret) {
+		dev_err(bus, "Calibration failed\n");
+		if (!bypass_mode)
+			/* Stop delay block when configured in lock mode */
+			stm32_omi_dlyb_stop(priv->omi_dev);
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_exec_op(struct spi_slave *slave,
+			      const struct spi_mem_op *op)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(slave->dev->parent);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	struct stm32_ospi_flash *flash = &priv->flash[priv->cs_used];
+	phys_addr_t regs_base = omi_plat->regs_base;
+	u32 addr_max;
+	u8 mode = OSPI_CCR_IND_WRITE;
+	int ret;
+
+	if (op->cmd.dtr && !flash->dtr_calibration_done_once) {
+		stm32_omi_dlyb_stop(priv->omi_dev);
+		clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+		flash->octal_dtr = (op->cmd.nbytes == 2);
+
+		ret = stm32_ospi_dtr_calibration(slave->dev->parent);
+		if (ret)
+			return ret;
+
+		flash->dtr_calibration_done_once = true;
+	}
+
+	addr_max = op->addr.val + op->data.nbytes + 1;
+
+	if (op->data.dir == SPI_MEM_DATA_IN && op->data.nbytes) {
+		if (addr_max < omi_plat->mm_size && op->addr.buswidth)
+			mode = OSPI_CCR_MEM_MAP;
+		else
+			mode = OSPI_CCR_IND_READ;
+	}
+
+	return stm32_ospi_send(priv->omi_dev, op, mode);
+}
+
+static int stm32_ospi_probe(struct udevice *bus)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat;
+	struct stm32_omi_priv *omi_priv;
+	phys_addr_t regs_base;
+	ofnode child;
+	int ret;
+
+	priv->omi_dev = bus->parent;
+	omi_plat = dev_get_plat(priv->omi_dev);
+	omi_priv = dev_get_priv(priv->omi_dev);
+	omi_priv->dev = bus;
+	regs_base = omi_plat->regs_base;
+
+	ret = clk_enable(&omi_plat->clk);
+	if (ret) {
+		dev_err(bus, "failed to enable clock\n");
+		return ret;
+	}
+
+	/* Reset OSPI controller */
+	reset_assert_bulk(&omi_plat->rst_ctl);
+	udelay(2);
+	reset_deassert_bulk(&omi_plat->rst_ctl);
+
+	/* Set dcr devsize to max address */
+	setbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_DEVSIZE_MASK);
+
+	priv->cs_used = -1;
+	omi_priv->check_transfer = stm32_ospi_readid;
+
+	/* Find memory model on each child node (SPI NOR or SPI NAND) */
+	dev_for_each_subnode(child, priv->omi_dev) {
+		u32 cs;
+
+		ret = ofnode_read_u32(child, "reg", &cs);
+		if (ret) {
+			dev_err(bus, "could not retrieve reg property: %d\n",
+				ret);
+			return ret;
+		}
+
+		if (cs >= OSPI_MAX_CHIP) {
+			dev_err(bus, "invalid reg value: %d\n", cs);
+			return -EINVAL;
+		}
+
+		if (ofnode_device_is_compatible(child, "jedec,spi-nor")) {
+			struct stm32_ospi_flash *flash = &priv->flash[cs];
+
+			flash->is_spi_nor = true;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_ospi_claim_bus(struct udevice *dev)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(dev->parent);
+	struct dm_spi_slave_plat *slave_plat = dev_get_parent_plat(dev);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	struct stm32_ospi_flash *flash;
+	phys_addr_t regs_base = omi_plat->regs_base;
+	int slave_cs = slave_plat->cs;
+	int ret;
+
+	if (slave_cs >= OSPI_MAX_CHIP)
+		return -ENODEV;
+
+	setbits_le32(regs_base + OSPI_CR, OSPI_CR_EN);
+
+	if (priv->cs_used == slave_cs)
+		return 0;
+
+	priv->cs_used = slave_cs;
+	flash = &priv->flash[priv->cs_used];
+
+	stm32_omi_dlyb_stop(priv->omi_dev);
+
+	/* Set chip select */
+	clrsetbits_le32(regs_base + OSPI_CR, OSPI_CR_CSSEL,
+			priv->cs_used ? OSPI_CR_CSSEL : 0);
+	clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+
+	if (flash->dtr_calibration_done_once) {
+		ret = stm32_ospi_dtr_calibration(dev->parent);
+	} else {
+		flash->is_str_calibration = true;
+
+		ret = stm32_ospi_str_calibration(dev->parent);
+		if (ret) {
+			dev_info(dev->parent, "Set flash frequency to a safe value (%d Hz)\n",
+				 STM32_DLYB_FREQ_THRESHOLD);
+
+			stm32_omi_dlyb_stop(priv->omi_dev);
+
+			clrbits_le32(regs_base + OSPI_TCR, OSPI_TCR_SSHIFT);
+			ret = stm32_ospi_set_speed(dev->parent,
+						   STM32_DLYB_FREQ_THRESHOLD);
+		}
+
+		flash->is_str_calibration = false;
+	}
+
+	return ret;
+}
+
+static int stm32_ospi_release_bus(struct udevice *dev)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(dev->parent);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+
+	clrbits_le32(regs_base + OSPI_CR, OSPI_CR_EN);
+
+	return 0;
+}
+
+static int stm32_ospi_set_mode(struct udevice *bus, uint mode)
+{
+	struct stm32_ospi_priv *priv = dev_get_priv(bus);
+	struct stm32_omi_plat *omi_plat = dev_get_plat(priv->omi_dev);
+	phys_addr_t regs_base = omi_plat->regs_base;
+	const char *str_rx, *str_tx;
+	int ret;
+
+	ret = stm32_omi_wait_for_not_busy(priv->omi_dev);
+	if (ret)
+		return ret;
+
+	if ((mode & SPI_CPHA) && (mode & SPI_CPOL))
+		setbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_CKMODE);
+	else if (!(mode & SPI_CPHA) && !(mode & SPI_CPOL))
+		clrbits_le32(regs_base + OSPI_DCR1, OSPI_DCR1_CKMODE);
+	else
+		return -ENODEV;
+
+	if (mode & SPI_CS_HIGH)
+		return -ENODEV;
+
+	if (mode & SPI_RX_OCTAL)
+		str_rx = "octal";
+	else if (mode & SPI_RX_QUAD)
+		str_rx = "quad";
+	else if (mode & SPI_RX_DUAL)
+		str_rx = "dual";
+	else
+		str_rx = "single";
+
+	if (mode & SPI_TX_OCTAL)
+		str_tx = "octal";
+	else if (mode & SPI_TX_QUAD)
+		str_tx = "quad";
+	else if (mode & SPI_TX_DUAL)
+		str_tx = "dual";
+	else
+		str_tx = "single";
+
+	dev_dbg(bus, "mode=%d rx: %s, tx: %s\n", mode, str_rx, str_tx);
+
+	return 0;
+}
+
+static bool stm32_ospi_mem_supports_op(struct spi_slave *slave,
+				       const struct spi_mem_op *op)
+{
+	if (op->data.buswidth > 8 || op->addr.buswidth > 8 ||
+	    op->dummy.buswidth > 8 || op->cmd.buswidth > 8)
+		return false;
+
+	if (op->cmd.nbytes > 4 || op->addr.nbytes > 4)
+		return false;
+
+	if ((!op->dummy.dtr && op->dummy.nbytes > 32) ||
+	    (op->dummy.dtr && op->dummy.nbytes > 64))
+		return false;
+
+	if (!op->cmd.dtr && !op->addr.dtr && !op->dummy.dtr &&
+	    !op->data.dtr && op->cmd.nbytes == 1)
+		return spi_mem_default_supports_op(slave, op);
+
+	return spi_mem_dtr_supports_op(slave, op);
+}
+
+static const struct spi_controller_mem_ops stm32_ospi_mem_ops = {
+	.exec_op = stm32_ospi_exec_op,
+	.supports_op = stm32_ospi_mem_supports_op,
+};
+
+static const struct dm_spi_ops stm32_ospi_ops = {
+	.claim_bus	= stm32_ospi_claim_bus,
+	.release_bus	= stm32_ospi_release_bus,
+	.set_speed	= stm32_ospi_set_speed,
+	.set_mode	= stm32_ospi_set_mode,
+	.mem_ops	= &stm32_ospi_mem_ops,
+};
+
+U_BOOT_DRIVER(stm32_ospi) = {
+	.name = "stm32_ospi",
+	.id = UCLASS_SPI,
+	.ops = &stm32_ospi_ops,
+	.priv_auto = sizeof(struct stm32_ospi_priv),
+	.probe = stm32_ospi_probe,
+};
diff --git a/drivers/spi/stm32_qspi.c b/drivers/spi/stm32_qspi.c
index ceba413727..65b692f7ce 100644
--- a/drivers/spi/stm32_qspi.c
+++ b/drivers/spi/stm32_qspi.c
@@ -115,15 +115,8 @@ struct stm32_qspi_regs {
 #define STM32_BUSY_TIMEOUT_US		100000
 #define STM32_ABT_TIMEOUT_US		100000
 
-struct stm32_qspi_flash {
-	u32 cr;
-	u32 dcr;
-	bool initialized;
-};
-
 struct stm32_qspi_priv {
 	struct stm32_qspi_regs *regs;
-	struct stm32_qspi_flash flash[STM32_QSPI_MAX_CHIP];
 	void __iomem *mm_base;
 	resource_size_t mm_size;
 	ulong clock_rate;
@@ -353,8 +346,8 @@ static int stm32_qspi_probe(struct udevice *bus)
 	if (priv->mm_size > STM32_QSPI_MAX_MMAP_SZ)
 		return -EINVAL;
 
-	dev_dbg(bus, "regs=<0x%p> mapped=<0x%p> mapped_size=<0x%lx>\n",
-		priv->regs, priv->mm_base, priv->mm_size);
+	dev_dbg(bus, "%s: regs=<0x%p> mapped=<0x%p> mapped_size=<0x%x>\n",
+		__func__, priv->regs, priv->mm_base, (u32)priv->mm_size);
 
 	ret = clk_get_by_index(bus, 0, &clk);
 	if (ret < 0)
@@ -407,25 +400,11 @@ static int stm32_qspi_claim_bus(struct udevice *dev)
 		return -ENODEV;
 
 	if (priv->cs_used != slave_cs) {
-		struct stm32_qspi_flash *flash = &priv->flash[slave_cs];
-
 		priv->cs_used = slave_cs;
 
-		if (flash->initialized) {
-			/* Set the configuration: speed + cs */
-			writel(flash->cr, &priv->regs->cr);
-			writel(flash->dcr, &priv->regs->dcr);
-		} else {
-			/* Set chip select */
-			clrsetbits_le32(&priv->regs->cr, STM32_QSPI_CR_FSEL,
-					priv->cs_used ? STM32_QSPI_CR_FSEL : 0);
-
-			/* Save the configuration: speed + cs */
-			flash->cr = readl(&priv->regs->cr);
-			flash->dcr = readl(&priv->regs->dcr);
-
-			flash->initialized = true;
-		}
+		/* Set chip select */
+		clrsetbits_le32(&priv->regs->cr, STM32_QSPI_CR_FSEL,
+				priv->cs_used ? STM32_QSPI_CR_FSEL : 0);
 	}
 
 	setbits_le32(&priv->regs->cr, STM32_QSPI_CR_EN);
diff --git a/drivers/tee/optee/Kconfig b/drivers/tee/optee/Kconfig
index d03028070b..9dc65b0501 100644
--- a/drivers/tee/optee/Kconfig
+++ b/drivers/tee/optee/Kconfig
@@ -37,6 +37,14 @@ config OPTEE_TA_SCP03
 	help
 	  Enables support for controlling (enabling, provisioning) the
 	  Secure Channel Protocol 03 operation in the OP-TEE SCP03 TA.
+
+config OPTEE_SERVICE_DISCOVERY
+	bool "OP-TEE service discovery"
+	default y
+	help
+	  This implements automated driver binding of OP-TEE service drivers by
+	  requesting OP-TEE firmware to enumerate its hosted services.
+
 endmenu
 
 endif
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index a89d62aaf0..47f845cffe 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -14,6 +14,7 @@
 #include <linux/arm-smccc.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <tee/optee_service.h>
 
 #include "optee_smc.h"
 #include "optee_msg.h"
@@ -22,6 +23,25 @@
 #define PAGELIST_ENTRIES_PER_PAGE \
 	((OPTEE_MSG_NONCONTIG_PAGE_SIZE / sizeof(u64)) - 1)
 
+/*
+ * PTA_DEVICE_ENUM interface exposed by OP-TEE to discover enumerated services
+ */
+#define PTA_DEVICE_ENUM		{ 0x7011a688, 0xddde, 0x4053, \
+				  { 0xa5, 0xa9, 0x7b, 0x3c, 0x4d, 0xdf, 0x13, 0xb8 } }
+/*
+ * PTA_CMD_GET_DEVICES - List services without supplicant dependencies
+ *
+ * [out]    memref[0]: List of the UUIDs of service enumerated by OP-TEE
+ */
+#define PTA_CMD_GET_DEVICES		0x0
+
+/*
+ * PTA_CMD_GET_DEVICES_SUPP - List services depending on tee supplicant
+ *
+ * [out]    memref[0]: List of the UUIDs of service enumerated by OP-TEE
+ */
+#define PTA_CMD_GET_DEVICES_SUPP	0x1
+
 typedef void (optee_invoke_fn)(unsigned long, unsigned long, unsigned long,
 			       unsigned long, unsigned long, unsigned long,
 			       unsigned long, unsigned long,
@@ -42,6 +62,155 @@ struct rpc_param {
 	u32	a7;
 };
 
+static struct optee_service *find_service_driver(const struct tee_optee_ta_uuid *uuid)
+{
+	struct optee_service *service;
+	u8 loc_uuid[TEE_UUID_LEN];
+	size_t service_cnt, idx;
+
+	service_cnt = ll_entry_count(struct optee_service, optee_service);
+	service = ll_entry_start(struct optee_service, optee_service);
+
+	for (idx = 0; idx < service_cnt; idx++, service++) {
+		tee_optee_ta_uuid_to_octets(loc_uuid, &service->uuid);
+		if (!memcmp(uuid, loc_uuid, sizeof(*uuid)))
+			return service;
+	}
+
+	return NULL;
+}
+
+static int bind_service_list(struct udevice *dev, struct tee_shm *service_list, size_t count)
+{
+	const struct tee_optee_ta_uuid *service_uuid = (const void *)service_list->addr;
+	struct optee_service *service;
+	size_t idx;
+	int ret;
+
+	for (idx = 0; idx < count; idx++) {
+		service = find_service_driver(service_uuid + idx);
+		if (!service)
+			continue;
+
+		ret = device_bind_driver_to_node(dev, service->driver_name, service->driver_name,
+						 dev_ofnode(dev), NULL);
+		if (ret) {
+			dev_warn(dev, "%s was not bound: %d, ignored\n", service->driver_name, ret);
+			continue;
+		}
+	}
+
+	return 0;
+}
+
+static int __enum_services(struct udevice *dev, struct tee_shm *shm, size_t *shm_size, u32 tee_sess,
+			   unsigned int pta_cmd)
+{
+	struct tee_invoke_arg arg = { };
+	struct tee_param param = { };
+	int ret = 0;
+
+	arg.func = pta_cmd;
+	arg.session = tee_sess;
+
+	/* Fill invoke cmd params */
+	param.attr = TEE_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	param.u.memref.shm = shm;
+	param.u.memref.size = *shm_size;
+
+	ret = tee_invoke_func(dev, &arg, 1, &param);
+	if (ret || (arg.ret && arg.ret != TEE_ERROR_SHORT_BUFFER)) {
+		dev_err(dev, "Enumeration command 0x%x failed: 0x%x\n", pta_cmd, arg.ret);
+		return -EINVAL;
+	}
+
+	*shm_size = param.u.memref.size;
+
+	return 0;
+}
+
+static int enum_services(struct udevice *dev, struct tee_shm **shm, size_t *count, u32 tee_sess,
+			 unsigned int pta_cmd)
+{
+	size_t shm_size = 0;
+	int ret;
+
+	ret = __enum_services(dev, NULL, &shm_size, tee_sess, pta_cmd);
+	if (ret)
+		return ret;
+
+	if (!shm_size) {
+		*count = 0;
+		return 0;
+	}
+
+	ret = tee_shm_alloc(dev, shm_size, 0, shm);
+	if (ret) {
+		dev_err(dev, "Failed to allocated shared memory: %d\n", ret);
+		return ret;
+	}
+
+	ret = __enum_services(dev, *shm, &shm_size, tee_sess, pta_cmd);
+	if (!ret)
+		*count = shm_size / sizeof(struct tee_optee_ta_uuid);
+
+	return ret;
+}
+
+static int open_enum_session(struct udevice *dev, u32 *tee_sess)
+{
+	const struct tee_optee_ta_uuid pta_uuid = PTA_DEVICE_ENUM;
+	struct tee_open_session_arg arg = { };
+	int ret;
+
+	tee_optee_ta_uuid_to_octets(arg.uuid, &pta_uuid);
+
+	ret = tee_open_session(dev, &arg, 0, NULL);
+	if (ret || arg.ret) {
+		if (!ret)
+			ret = -EIO;
+		return ret;
+	}
+
+	*tee_sess = arg.session;
+
+	return 0;
+}
+
+static int bind_service_drivers(struct udevice *dev)
+{
+	struct tee_shm *service_list = NULL;
+	size_t service_count;
+	u32 tee_sess;
+	int ret, ret2;
+
+	ret = open_enum_session(dev, &tee_sess);
+	if (ret)
+		return ret;
+
+	ret = enum_services(dev, &service_list, &service_count, tee_sess,
+			    PTA_CMD_GET_DEVICES);
+	if (!ret && service_count)
+		ret = bind_service_list(dev, service_list, service_count);
+
+	tee_shm_free(service_list);
+	service_list = NULL;
+
+	ret2 = enum_services(dev, &service_list, &service_count, tee_sess,
+			     PTA_CMD_GET_DEVICES_SUPP);
+	if (!ret2 && service_count)
+		ret2 = bind_service_list(dev, service_list, service_count);
+
+	tee_shm_free(service_list);
+
+	tee_close_session(dev, tee_sess);
+
+	if (ret)
+		return ret;
+
+	return ret2;
+}
+
 /**
  * reg_pair_to_ptr() - Make a pointer of 2 32-bit values
  * @reg0:	High bits of the pointer
@@ -638,11 +807,18 @@ static int optee_of_to_plat(struct udevice *dev)
 	return 0;
 }
 
+static int optee_bind(struct udevice *dev)
+{
+	if (IS_ENABLED(CONFIG_OPTEE_SERVICE_DISCOVERY))
+		dev_or_flags(dev, DM_FLAG_PROBE_AFTER_BIND);
+
+	return 0;
+}
+
 static int optee_probe(struct udevice *dev)
 {
 	struct optee_pdata *pdata = dev_get_plat(dev);
 	u32 sec_caps;
-	struct udevice *child;
 	int ret;
 
 	if (!is_optee_api(pdata->invoke_fn)) {
@@ -668,14 +844,19 @@ static int optee_probe(struct udevice *dev)
 		return -ENOENT;
 	}
 
-	/*
-	 * in U-Boot, the discovery of TA on the TEE bus is not supported:
-	 * only bind the drivers associated to the supported OP-TEE TA
-	 */
-	if (IS_ENABLED(CONFIG_RNG_OPTEE)) {
-		ret = device_bind_driver(dev, "optee-rng", "optee-rng", &child);
+	if (IS_ENABLED(CONFIG_OPTEE_SERVICE_DISCOVERY)) {
+		ret = bind_service_drivers(dev);
+		if (ret)
+			dev_warn(dev, "optee service enumeration failed: %d\n", ret);
+	} else if (IS_ENABLED(CONFIG_RNG_OPTEE)) {
+		/*
+		 * Discovery of TAs on the TEE bus is not supported in U-Boot:
+		 * only bind the drivers associated to the supported OP-TEE TA
+		 */
+		ret = device_bind_driver_to_node(dev, "optee-rng", "optee-rng",
+						 dev_ofnode(dev), NULL);
 		if (ret)
-			return ret;
+			dev_warn(dev, "optee-rng failed to bind: %d\n", ret);
 	}
 
 	return 0;
@@ -692,6 +873,7 @@ U_BOOT_DRIVER(optee) = {
 	.of_match = optee_match,
 	.of_to_plat = optee_of_to_plat,
 	.probe = optee_probe,
+	.bind = optee_bind,
 	.ops = &optee_ops,
 	.plat_auto	= sizeof(struct optee_pdata),
 	.priv_auto	= sizeof(struct optee_private),
diff --git a/drivers/tpm/tpm2_ftpm_tee.c b/drivers/tpm/tpm2_ftpm_tee.c
index 53e59f42b4..3c4c12983d 100644
--- a/drivers/tpm/tpm2_ftpm_tee.c
+++ b/drivers/tpm/tpm2_ftpm_tee.c
@@ -186,6 +186,7 @@ static int ftpm_tee_probe(struct udevice *dev)
 
 	/* Open a session with the fTPM TA */
 	memset(&sess_arg, 0, sizeof(sess_arg));
+	sess_arg.clnt_login = TEE_LOGIN_REE_KERNEL;
 	tee_optee_ta_uuid_to_octets(sess_arg.uuid, &uuid);
 
 	rc = tee_open_session(context->tee_dev, &sess_arg, 0, NULL);
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 3afb45d5cc..7ca9388d4a 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -85,6 +85,8 @@ source "drivers/usb/emul/Kconfig"
 
 source "drivers/usb/phy/Kconfig"
 
+source "drivers/usb/typec/Kconfig"
+
 source "drivers/usb/ulpi/Kconfig"
 
 if USB_HOST
@@ -106,6 +108,16 @@ config USB_KEYBOARD
 	  Say Y here if you want to use a USB keyboard for U-Boot command line
 	  input.
 
+config USB_ONBOARD_HUB
+	bool "Onboard USB hub support"
+	depends on DM_USB
+	---help---
+	  Say Y here if you want to support discrete onboard USB hubs that
+	  don't require an additional control bus for initialization, but
+	  need some non-trivial form of initialization, such as enabling a
+	  power regulator. An example for such a hub is the Microchip
+	  USB2514B.
+
 if USB_KEYBOARD
 
 config USB_KEYBOARD_FN_KEYS
diff --git a/drivers/usb/cdns3/core.h b/drivers/usb/cdns3/core.h
index 0668d646fc..52d6d01cd6 100644
--- a/drivers/usb/cdns3/core.h
+++ b/drivers/usb/cdns3/core.h
@@ -16,12 +16,6 @@
 #ifndef __LINUX_CDNS3_CORE_H
 #define __LINUX_CDNS3_CORE_H
 
-enum usb_role {
-	USB_ROLE_NONE,
-	USB_ROLE_HOST,
-	USB_ROLE_DEVICE,
-};
-
 struct cdns3;
 
 /**
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index b592a487e0..3dff368437 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -700,12 +700,6 @@ static int dwc3_core_init_mode(struct dwc3 *dwc)
 	return 0;
 }
 
-static void dwc3_gadget_run(struct dwc3 *dwc)
-{
-	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_RUN_STOP);
-	mdelay(100);
-}
-
 static void dwc3_core_stop(struct dwc3 *dwc)
 {
 	u32 reg;
@@ -737,7 +731,6 @@ static void dwc3_core_exit_mode(struct dwc3 *dwc)
 	 * This enables the phy to enter idle and then, if enabled, suspend.
 	 */
 	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
-	dwc3_gadget_run(dwc);
 }
 
 #define DWC3_ALIGN_MASK		(16 - 1)
@@ -939,6 +932,8 @@ MODULE_DESCRIPTION("DesignWare USB3 DRD Controller Driver");
 int dwc3_setup_phy(struct udevice *dev, struct phy_bulk *phys)
 {
 	int ret;
+	enum usb_dr_mode dr_mode;
+	enum phy_mode phymode;
 
 	ret = generic_phy_get_bulk(dev, phys);
 	if (ret)
@@ -950,7 +945,33 @@ int dwc3_setup_phy(struct udevice *dev, struct phy_bulk *phys)
 
 	ret = generic_phy_power_on_bulk(phys);
 	if (ret)
-		generic_phy_exit_bulk(phys);
+		goto err_power_on;
+
+	dr_mode = usb_get_dr_mode(dev_ofnode(dev));
+
+	switch(dr_mode)
+	{
+		case USB_DR_MODE_HOST:
+			phymode = PHY_MODE_USB_HOST;
+			break;
+		case USB_DR_MODE_PERIPHERAL:
+			phymode = PHY_MODE_USB_DEVICE;
+			break;
+		default:
+			goto err_mode;
+	}
+
+	ret = generic_phy_set_mode_bulk(phys, phymode, (dr_mode == USB_DR_MODE_HOST) ?
+					USB_ROLE_HOST : USB_ROLE_DEVICE);
+	if (ret)
+		goto err_mode;
+
+	return ret;
+
+err_mode:
+	generic_phy_power_off_bulk(phys);
+err_power_on:
+	generic_phy_exit_bulk(phys);
 
 	return ret;
 }
@@ -1058,7 +1079,8 @@ void dwc3_of_parse(struct dwc3 *dwc)
 				       i, &val))
 			break;
 
-		dwc->incrx_mode = INCRX_UNDEF_LENGTH_BURST_MODE;
+		if (i > 0)
+			dwc->incrx_mode = INCRX_UNDEF_LENGTH_BURST_MODE;
 		dwc->incrx_size = max(dwc->incrx_size, val);
 	}
 }
diff --git a/drivers/usb/dwc3/dwc3-generic.c b/drivers/usb/dwc3/dwc3-generic.c
index 466b25a0c3..6c994b902f 100644
--- a/drivers/usb/dwc3/dwc3-generic.c
+++ b/drivers/usb/dwc3/dwc3-generic.c
@@ -7,26 +7,32 @@
  * Based on dwc3-omap.c.
  */
 
+#define LOG_CATEGORY UCLASS_USB
+
+#include <asm/gpio.h>
+#include <clk.h>
 #include <common.h>
 #include <cpu_func.h>
-#include <log.h>
 #include <dm.h>
 #include <dm/device-internal.h>
+#include <dm/device_compat.h>
 #include <dm/lists.h>
 #include <dwc3-uboot.h>
 #include <generic-phy.h>
+#include <linux/bitfield.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <log.h>
 #include <malloc.h>
+#include <regmap.h>
+#include <reset.h>
+#include <syscon.h>
 #include <usb.h>
+#include <usb/xhci.h>
 #include "core.h"
 #include "gadget.h"
-#include <reset.h>
-#include <clk.h>
-#include <usb/xhci.h>
-#include <asm/gpio.h>
 
 struct dwc3_glue_data {
 	struct clk_bulk		clks;
@@ -150,7 +156,7 @@ static int dwc3_generic_of_to_plat(struct udevice *dev)
 
 	plat->maximum_speed = usb_get_maximum_speed(node);
 	if (plat->maximum_speed == USB_SPEED_UNKNOWN) {
-		pr_info("No USB maximum speed specified. Using super speed\n");
+		dev_info(dev, "No USB maximum speed specified. Using super speed\n");
 		plat->maximum_speed = USB_SPEED_SUPER;
 	}
 
@@ -160,7 +166,7 @@ static int dwc3_generic_of_to_plat(struct udevice *dev)
 		node = dev_ofnode(dev->parent);
 		plat->dr_mode = usb_get_dr_mode(node);
 		if (plat->dr_mode == USB_DR_MODE_UNKNOWN) {
-			pr_err("Invalid usb mode setup\n");
+			dev_err(dev, "Invalid usb mode setup\n");
 			return -ENODEV;
 		}
 	}
@@ -389,6 +395,69 @@ struct dwc3_glue_ops ti_ops = {
 	.glue_configure = dwc3_ti_glue_configure,
 };
 
+void dwc3_stm32_glue_configure(struct udevice *dev, int index, enum usb_dr_mode mode)
+{
+#define SYSCFG_USB3DRCR_USB2ONLYH_MASK        BIT(3U) /*!< 0x00000008 : USB2-only Mode for Host */
+#define SYSCFG_USB3DRCR_USB2ONLYD_MASK        BIT(4U) /*!< 0x00000010 : USB2-only Mode for Device */
+	int ret;
+	struct regmap *regmap;
+	struct dwc3_glue_data *glue = dev_get_plat(dev);
+	u32 syscfg_usb3drcr_reg_off;
+	bool usb2only_conf;
+
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "unable to find regmap\n");
+		return;
+	}
+
+	ret = ofnode_count_phandle_with_args(ofnode_first_subnode(dev_ofnode(dev)),
+					     "phys", "#phy-cells", 0);
+	if (ret < 1) {
+		dev_err(dev, "unable to find phys\n");
+		return;
+	}
+
+	if (ret < 2)
+		usb2only_conf = true;
+	else
+		usb2only_conf = false;
+	dev_info(dev, "configured in %s mode\n", usb2only_conf ? "usb2" : "usb3");
+
+	ret = dev_read_u32_index(dev, "st,syscfg", 1, &syscfg_usb3drcr_reg_off);
+	if (ret) {
+		dev_err(dev, "Can't get sysconfig usb3drcr offset (%d)\n", ret);
+		return;
+	}
+	dev_dbg(dev, "syscfg-usb3drcr-reg offset 0x%x\n", syscfg_usb3drcr_reg_off);
+
+	ret = regmap_update_bits(regmap, syscfg_usb3drcr_reg_off, SYSCFG_USB3DRCR_USB2ONLYD_MASK |
+			SYSCFG_USB3DRCR_USB2ONLYH_MASK,
+			FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYD_MASK, usb2only_conf ? 1 : 0) |
+			FIELD_PREP(SYSCFG_USB3DRCR_USB2ONLYH_MASK, usb2only_conf ? 1 : 0));
+	if (ret) {
+		dev_err(dev, "regmap_write error: %d\n", ret);
+		return;
+	}
+
+	// Assert + Deassert Reset for DWC3-ctrl to sample syscfg settings
+	ret = reset_assert_bulk(&glue->resets);
+	if (ret) {
+		dev_err(dev, "reset_assert_bulk error: %d\n", ret);
+		return;
+	}
+
+	ret = reset_deassert_bulk(&glue->resets);
+	if (ret) {
+		dev_err(dev, "reset_deassert_bulk error: %d\n", ret);
+		return;
+	}
+}
+
+struct dwc3_glue_ops stm32_ops = {
+	.glue_configure = dwc3_stm32_glue_configure,
+};
+
 static int dwc3_glue_bind(struct udevice *parent)
 {
 	ofnode node;
@@ -498,7 +567,7 @@ static int dwc3_glue_probe(struct udevice *dev)
 		ret = generic_phy_init(&phy);
 		if (ret)
 			return ret;
-	} else if (ret != -ENOENT && ret != -ENODATA) {
+	} else if (ret != -ENOENT && ret != -ENODATA && ret != -EINVAL) {
 		debug("could not get phy (err %d)\n", ret);
 		return ret;
 	} else {
@@ -525,6 +594,12 @@ static int dwc3_glue_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
+	if (glue->clks.count == 0) {
+		ret = dwc3_glue_clk_init(child, glue);
+		if (ret)
+			return ret;
+	}
+
 	if (glue->resets.count == 0) {
 		ret = dwc3_glue_reset_init(child, glue);
 		if (ret)
@@ -568,6 +643,7 @@ static const struct udevice_id dwc3_glue_ids[] = {
 	{ .compatible = "fsl,imx8mp-dwc3", .data = (ulong)&imx8mp_ops },
 	{ .compatible = "fsl,imx8mq-dwc3" },
 	{ .compatible = "intel,tangier-dwc3" },
+	{ .compatible = "st,stm32mp25-dwc3", .data = (ulong)&stm32_ops },
 	{ }
 };
 
diff --git a/drivers/usb/gadget/dwc2_udc_otg.c b/drivers/usb/gadget/dwc2_udc_otg.c
index 77988f78ab..9b95cae892 100644
--- a/drivers/usb/gadget/dwc2_udc_otg.c
+++ b/drivers/usb/gadget/dwc2_udc_otg.c
@@ -24,6 +24,7 @@
 #include <log.h>
 #include <malloc.h>
 #include <reset.h>
+#include <typec.h>
 #include <dm/device_compat.h>
 #include <dm/devres.h>
 #include <linux/bug.h>
@@ -981,6 +982,7 @@ static void dwc2_phy_shutdown(struct udevice *dev, struct phy_bulk *phys)
 static int dwc2_udc_otg_of_to_plat(struct udevice *dev)
 {
 	struct dwc2_plat_otg_data *plat = dev_get_plat(dev);
+	struct udevice *typec;
 	ulong drvdata;
 	void (*set_params)(struct dwc2_plat_otg_data *data);
 	int ret;
@@ -1009,11 +1011,20 @@ static int dwc2_udc_otg_of_to_plat(struct udevice *dev)
 			return ret;
 	}
 
-	plat->force_b_session_valid =
-		dev_read_bool(dev, "u-boot,force-b-session-valid");
-
-	plat->force_vbus_detection =
-		dev_read_bool(dev, "u-boot,force-vbus-detection");
+	/*
+	 * check for High speed port/endpoint subnode presence and retrieve Type-C
+	 * device if exist. HS port subnode is always port number 0 => port@0
+	 */
+	ret = typec_get_device_from_usb(dev, &typec, 0);
+	if (!ret) {
+		ret = typec_get_data_role(typec, 0);
+		plat->force_b_session_valid = (ret == TYPEC_DEVICE);
+	} else {
+		plat->force_b_session_valid =
+			dev_read_bool(dev, "u-boot,force-b-session-valid");
+		plat->force_vbus_detection =
+			dev_read_bool(dev, "u-boot,force-vbus-detection");
+	}
 
 	/* force plat according compatible */
 	drvdata = dev_get_driver_data(dev);
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 1aabe062fb..5523308631 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -452,3 +452,17 @@ config USB_MAX_CONTROLLER_COUNT
 	depends on USB_EHCI_FSL || USB_XHCI_FSL || \
 		(SPL_USB_HOST && !DM_SPL_USB) || (USB_HOST && !DM_USB)
 	default 1
+
+config USB_STM32_USBH
+	bool "Support for STMicroelectronics STM32 Family USBH controller"
+	depends on DM && OF_CONTROL
+	select USB_HOST
+	select USB_EHCI_HCD
+	select USB_EHCI_GENERIC
+	select USB_OHCI_HCD
+	select USB_OHCI_GENERIC
+	help
+	  STM32 Family USB 2.0 Host Controller includes generic EHCI and OHCI
+	  controller blocks to support High-Speed and Full+Low-Speed respectively
+	  This driver is to configure the glue logic to enable EHCI+OHCI controllers
+	  inside the USBH block.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index ddc3663206..c2ef5c6412 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -63,3 +63,6 @@ obj-$(CONFIG_USB_XHCI_OCTEON) += dwc3-octeon-glue.o
 
 # designware
 obj-$(CONFIG_USB_DWC2) += dwc2.o
+
+# STM32
+obj-$(CONFIG_USB_STM32_USBH) += usbh-stm32.o
diff --git a/drivers/usb/host/ehci-generic.c b/drivers/usb/host/ehci-generic.c
index 75c73bfe4e..afc9a77b7d 100644
--- a/drivers/usb/host/ehci-generic.c
+++ b/drivers/usb/host/ehci-generic.c
@@ -66,6 +66,7 @@ static int ehci_usb_probe(struct udevice *dev)
 	struct ehci_hccr *hccr;
 	struct ehci_hcor *hcor;
 	int err, ret;
+	struct udevice *companion_dev;
 
 	err = 0;
 	ret = clk_get_bulk(dev, &priv->clocks);
@@ -96,14 +97,43 @@ static int ehci_usb_probe(struct udevice *dev)
 	if (err)
 		goto reset_err;
 
-	err = ehci_setup_phy(dev, &priv->phy, 0);
+	err = generic_setup_phy(dev, &priv->phy, 0);
 	if (err)
 		goto regulator_err;
 
+	err = generic_phy_set_mode(&priv->phy, PHY_MODE_USB_HOST, 0);
+	if (err) {
+		dev_dbg(dev, "failed to set mode on usb phy\n");
+		goto phy_err;
+	}
+
 	hccr = map_physmem(dev_read_addr(dev), 0x100, MAP_NOCACHE);
 	hcor = (struct ehci_hcor *)((uintptr_t)hccr +
 				    HC_LENGTH(ehci_readl(&hccr->cr_capbase)));
 
+	/*
+	 * Enforce optional companion controller is marked as such. This allows
+	 * the bus scan in usb-uclass to 1st scan the primary controller,
+	 * before the companion controller (ownership is given to companion
+	 * when low or full speed devices have been detected).
+	 */
+	err = uclass_get_device_by_phandle(UCLASS_USB, dev, "companion", &companion_dev);
+	if (!err) {
+		struct usb_bus_priv *companion_bus_priv;
+
+		dev_dbg(companion_dev, "companion of %s\n", dev->name);
+		companion_bus_priv = dev_get_uclass_priv(companion_dev);
+		companion_bus_priv->companion = true;
+	} else if (err && err != -ENOENT && err != -ENODEV) {
+		/*
+		 * Treat everything else than no companion or disabled
+		 * companion as an error. (It may not be enabled on boards
+		 * that have a High-Speed HUB to handle FS and LS traffic).
+		 */
+		dev_err(dev, "Failed to get companion (err=%d)\n", err);
+		goto phy_err;
+	}
+
 	err = ehci_register(dev, hccr, hcor, NULL, 0, USB_INIT_HOST);
 	if (err)
 		goto phy_err;
@@ -111,7 +141,7 @@ static int ehci_usb_probe(struct udevice *dev)
 	return 0;
 
 phy_err:
-	ret = ehci_shutdown_phy(dev, &priv->phy);
+	ret = generic_shutdown_phy(&priv->phy);
 	if (ret)
 		dev_err(dev, "failed to shutdown usb phy (ret=%d)\n", ret);
 
@@ -141,7 +171,7 @@ static int ehci_usb_remove(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	ret = ehci_shutdown_phy(dev, &priv->phy);
+	ret = generic_shutdown_phy(&priv->phy);
 	if (ret)
 		return ret;
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f033198a7c..3204a85904 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -178,8 +178,26 @@ static int handshake(uint32_t *ptr, uint32_t mask, uint32_t done, int usec)
 
 static int ehci_reset(struct ehci_ctrl *ctrl)
 {
-	uint32_t cmd;
-	int ret = 0;
+	uint32_t cmd, reg;
+	int ret = 0, i;
+	int max_ports = HCS_N_PORTS(ehci_readl(&ctrl->hccr->cr_hcsparams));
+
+	for (i = 0; i < max_ports; i++) {
+		reg = ehci_readl(&ctrl->hcor->or_portsc[i]);
+		if (reg & EHCI_PS_SUSP) {
+			reg &= ~EHCI_PS_CLEAR;
+			reg |= EHCI_PS_FPR;
+			ehci_writel(&ctrl->hcor->or_portsc[i], reg);
+		}
+	}
+	mdelay(USB_RESUME_TIMEOUT);
+	for (i = 0; i < max_ports; i++) {
+		reg = ehci_readl(&ctrl->hcor->or_portsc[i]);
+		if (reg & EHCI_PS_FPR) {
+			reg &= ~(EHCI_PS_CLEAR | EHCI_PS_SUSP | EHCI_PS_FPR);
+			ehci_writel(&ctrl->hcor->or_portsc[i], reg);
+		}
+	}
 
 	cmd = ehci_readl(&ctrl->hcor->or_usbcmd);
 	cmd = (cmd & ~CMD_RUN) | CMD_RESET;
@@ -1767,69 +1785,3 @@ struct dm_usb_ops ehci_usb_ops = {
 };
 
 #endif
-
-#ifdef CONFIG_PHY
-int ehci_setup_phy(struct udevice *dev, struct phy *phy, int index)
-{
-	int ret;
-
-	if (!phy)
-		return 0;
-
-	ret = generic_phy_get_by_index(dev, index, phy);
-	if (ret) {
-		if (ret != -ENOENT) {
-			dev_err(dev, "failed to get usb phy\n");
-			return ret;
-		}
-	} else {
-		ret = generic_phy_init(phy);
-		if (ret) {
-			dev_dbg(dev, "failed to init usb phy\n");
-			return ret;
-		}
-
-		ret = generic_phy_power_on(phy);
-		if (ret) {
-			dev_dbg(dev, "failed to power on usb phy\n");
-			return generic_phy_exit(phy);
-		}
-	}
-
-	return 0;
-}
-
-int ehci_shutdown_phy(struct udevice *dev, struct phy *phy)
-{
-	int ret = 0;
-
-	if (!phy)
-		return 0;
-
-	if (generic_phy_valid(phy)) {
-		ret = generic_phy_power_off(phy);
-		if (ret) {
-			dev_dbg(dev, "failed to power off usb phy\n");
-			return ret;
-		}
-
-		ret = generic_phy_exit(phy);
-		if (ret) {
-			dev_dbg(dev, "failed to power off usb phy\n");
-			return ret;
-		}
-	}
-
-	return 0;
-}
-#else
-int ehci_setup_phy(struct udevice *dev, struct phy *phy, int index)
-{
-	return 0;
-}
-
-int ehci_shutdown_phy(struct udevice *dev, struct phy *phy)
-{
-	return 0;
-}
-#endif
diff --git a/drivers/usb/host/ehci-msm.c b/drivers/usb/host/ehci-msm.c
index d160cf019d..dd0d153500 100644
--- a/drivers/usb/host/ehci-msm.c
+++ b/drivers/usb/host/ehci-msm.c
@@ -56,7 +56,7 @@ static int ehci_usb_probe(struct udevice *dev)
 	hcor = (struct ehci_hcor *)((phys_addr_t)hccr +
 			HC_LENGTH(ehci_readl(&(hccr)->cr_capbase)));
 
-	ret = ehci_setup_phy(dev, &p->phy, 0);
+	ret = generic_setup_phy(dev, &p->phy, 0);
 	if (ret)
 		return ret;
 
@@ -81,7 +81,7 @@ static int ehci_usb_remove(struct udevice *dev)
 	/* Stop controller. */
 	clrbits_le32(&ehci->usbcmd, CMD_RUN);
 
-	ret = ehci_shutdown_phy(dev, &p->phy);
+	ret = generic_shutdown_phy(&p->phy);
 	if (ret)
 		return ret;
 
diff --git a/drivers/usb/host/ehci-mx6.c b/drivers/usb/host/ehci-mx6.c
index e30449b55e..fa2ca2a1d9 100644
--- a/drivers/usb/host/ehci-mx6.c
+++ b/drivers/usb/host/ehci-mx6.c
@@ -726,7 +726,7 @@ static int ehci_usb_probe(struct udevice *dev)
 	mdelay(10);
 
 #if defined(CONFIG_PHY)
-	ret = ehci_setup_phy(dev, &priv->phy, 0);
+	ret = generic_setup_phy(dev, &priv->phy, 0);
 	if (ret)
 		goto err_regulator;
 #endif
@@ -743,7 +743,7 @@ static int ehci_usb_probe(struct udevice *dev)
 
 err_phy:
 #if defined(CONFIG_PHY)
-	ehci_shutdown_phy(dev, &priv->phy);
+	generic_shutdown_phy(&priv->phy);
 err_regulator:
 #endif
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
@@ -767,7 +767,7 @@ int ehci_usb_remove(struct udevice *dev)
 	ehci_deregister(dev);
 
 #if defined(CONFIG_PHY)
-	ehci_shutdown_phy(dev, &priv->phy);
+	generic_shutdown_phy(&priv->phy);
 #endif
 
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 1ab306147f..e98ab31261 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -31,7 +31,7 @@ static int ehci_pci_init(struct udevice *dev, struct ehci_hccr **ret_hccr,
 	int ret;
 	u32 cmd;
 
-	ret = ehci_setup_phy(dev, &priv->phy, 0);
+	ret = generic_setup_phy(dev, &priv->phy, 0);
 	if (ret)
 		return ret;
 
@@ -149,7 +149,7 @@ static int ehci_pci_remove(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	return ehci_shutdown_phy(dev, &priv->phy);
+	return generic_shutdown_phy(&priv->phy);
 }
 
 static const struct udevice_id ehci_pci_ids[] = {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 5170044a3a..5770d35b46 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -295,9 +295,5 @@ int ehci_register(struct udevice *dev, struct ehci_hccr *hccr,
 int ehci_deregister(struct udevice *dev);
 extern struct dm_usb_ops ehci_usb_ops;
 
-/* EHCI PHY functions */
-int ehci_setup_phy(struct udevice *dev, struct phy *phy, int index);
-int ehci_shutdown_phy(struct udevice *dev, struct phy *phy);
-
 #include <linux/bitops.h>
 #endif /* USB_EHCI_H */
diff --git a/drivers/usb/host/ohci-generic.c b/drivers/usb/host/ohci-generic.c
index 5d23058aaf..57d6bb9f2a 100644
--- a/drivers/usb/host/ohci-generic.c
+++ b/drivers/usb/host/ohci-generic.c
@@ -16,129 +16,49 @@
 
 struct generic_ohci {
 	ohci_t ohci;
-	struct clk *clocks;	/* clock list */
-	struct reset_ctl *resets; /* reset list */
+	struct clk_bulk clocks;	/* clock list */
+	struct reset_ctl_bulk resets; /* reset list */
 	struct phy phy;
-	int clock_count;	/* number of clock in clock list */
-	int reset_count;	/* number of reset in reset list */
 };
 
-static int ohci_setup_phy(struct udevice *dev, int index)
+static int ohci_usb_probe(struct udevice *dev)
 {
+	struct ohci_regs *regs = dev_read_addr_ptr(dev);
 	struct generic_ohci *priv = dev_get_priv(dev);
-	int ret;
+	int err, ret;
 
-	ret = generic_phy_get_by_index(dev, index, &priv->phy);
-	if (ret) {
-		if (ret != -ENOENT) {
-			dev_err(dev, "failed to get usb phy\n");
-			return ret;
-		}
-	} else {
-		ret = generic_phy_init(&priv->phy);
-		if (ret) {
-			dev_dbg(dev, "failed to init usb phy\n");
-			return ret;
-		}
-
-		ret = generic_phy_power_on(&priv->phy);
-		if (ret) {
-			dev_dbg(dev, "failed to power on usb phy\n");
-			return generic_phy_exit(&priv->phy);
-		}
+	ret = clk_get_bulk(dev, &priv->clocks);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Failed to get clocks (ret=%d)\n", ret);
+		return ret;
 	}
 
-	return 0;
-}
-
-static int ohci_shutdown_phy(struct udevice *dev)
-{
-	struct generic_ohci *priv = dev_get_priv(dev);
-	int ret = 0;
-
-	if (generic_phy_valid(&priv->phy)) {
-		ret = generic_phy_power_off(&priv->phy);
-		if (ret) {
-			dev_dbg(dev, "failed to power off usb phy\n");
-			return ret;
-		}
-
-		ret = generic_phy_exit(&priv->phy);
-		if (ret) {
-			dev_dbg(dev, "failed to power off usb phy\n");
-			return ret;
-		}
+	err = clk_enable_bulk(&priv->clocks);
+	if (err) {
+		dev_err(dev, "Failed to enable clocks (err=%d)\n", err);
+		goto clk_err;
 	}
 
-	return 0;
-}
-
-static int ohci_usb_probe(struct udevice *dev)
-{
-	struct ohci_regs *regs = dev_read_addr_ptr(dev);
-	struct generic_ohci *priv = dev_get_priv(dev);
-	int i, err, ret, clock_nb, reset_nb;
-
-	err = 0;
-	priv->clock_count = 0;
-	clock_nb = dev_count_phandle_with_args(dev, "clocks", "#clock-cells",
-					       0);
-	if (clock_nb > 0) {
-		priv->clocks = devm_kcalloc(dev, clock_nb, sizeof(struct clk),
-					    GFP_KERNEL);
-		if (!priv->clocks)
-			return -ENOMEM;
-
-		for (i = 0; i < clock_nb; i++) {
-			err = clk_get_by_index(dev, i, &priv->clocks[i]);
-			if (err < 0)
-				break;
-
-			err = clk_enable(&priv->clocks[i]);
-			if (err && err != -ENOSYS) {
-				dev_err(dev, "failed to enable clock %d\n", i);
-				clk_free(&priv->clocks[i]);
-				goto clk_err;
-			}
-			priv->clock_count++;
-		}
-	} else if (clock_nb != -ENOENT) {
-		dev_err(dev, "failed to get clock phandle(%d)\n", clock_nb);
-		return clock_nb;
+	err = reset_get_bulk(dev, &priv->resets);
+	if (err && err != -ENOENT) {
+		dev_err(dev, "failed to get resets (err=%d)\n", err);
+		goto clk_err;
 	}
 
-	priv->reset_count = 0;
-	reset_nb = dev_count_phandle_with_args(dev, "resets", "#reset-cells",
-					       0);
-	if (reset_nb > 0) {
-		priv->resets = devm_kcalloc(dev, reset_nb,
-					    sizeof(struct reset_ctl),
-					    GFP_KERNEL);
-		if (!priv->resets)
-			return -ENOMEM;
-
-		for (i = 0; i < reset_nb; i++) {
-			err = reset_get_by_index(dev, i, &priv->resets[i]);
-			if (err < 0)
-				break;
-
-			err = reset_deassert(&priv->resets[i]);
-			if (err) {
-				dev_err(dev, "failed to deassert reset %d\n", i);
-				reset_free(&priv->resets[i]);
-				goto reset_err;
-			}
-			priv->reset_count++;
-		}
-	} else if (reset_nb != -ENOENT) {
-		dev_err(dev, "failed to get reset phandle(%d)\n", reset_nb);
-		goto clk_err;
+	err = reset_deassert_bulk(&priv->resets);
+	if (err) {
+		dev_err(dev, "failed to get deassert resets (err=%d)\n", err);
+		goto reset_err;
 	}
 
-	err = ohci_setup_phy(dev, 0);
+	err = generic_setup_phy(dev, &priv->phy, 0);
 	if (err)
 		goto reset_err;
 
+	err = generic_phy_set_mode(&priv->phy, PHY_MODE_USB_HOST, 0);
+	if (err)
+		goto phy_err;
+
 	err = ohci_register(dev, regs);
 	if (err)
 		goto phy_err;
@@ -146,18 +66,18 @@ static int ohci_usb_probe(struct udevice *dev)
 	return 0;
 
 phy_err:
-	ret = ohci_shutdown_phy(dev);
+	ret = generic_shutdown_phy(&priv->phy);
 	if (ret)
 		dev_err(dev, "failed to shutdown usb phy\n");
 
 reset_err:
-	ret = reset_release_all(priv->resets, priv->reset_count);
+	ret = reset_release_bulk(&priv->resets);
 	if (ret)
-		dev_err(dev, "failed to assert all resets\n");
+		dev_err(dev, "failed to release resets (ret=%d)\n", ret);
 clk_err:
-	ret = clk_release_all(priv->clocks, priv->clock_count);
+	ret = clk_release_bulk(&priv->clocks);
 	if (ret)
-		dev_err(dev, "failed to disable all clocks\n");
+		dev_err(dev, "failed to release clocks (ret=%d)\n", ret);
 
 	return err;
 }
@@ -171,15 +91,15 @@ static int ohci_usb_remove(struct udevice *dev)
 	if (ret)
 		return ret;
 
-	ret = ohci_shutdown_phy(dev);
+	ret = generic_shutdown_phy(&priv->phy);
 	if (ret)
 		return ret;
 
-	ret = reset_release_all(priv->resets, priv->reset_count);
+	ret = reset_release_bulk(&priv->resets);
 	if (ret)
 		return ret;
 
-	return clk_release_all(priv->clocks, priv->clock_count);
+	return clk_release_bulk(&priv->clocks);
 }
 
 static const struct udevice_id ohci_usb_ids[] = {
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 9acef5ee4f..005995f43e 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -935,7 +935,8 @@ static void td_submit_job(ohci_t *ohci, struct usb_device *dev,
 	__u32 info = 0;
 	unsigned int toggle = 0;
 
-	flush_dcache_buffer(buffer, data_len);
+	if (data_len)
+		flush_dcache_buffer(buffer, data_len);
 
 	/* OHCI handles the DATA-toggles itself, we just use the USB-toggle
 	 * bits for resetting */
diff --git a/drivers/usb/host/usb-uclass.c b/drivers/usb/host/usb-uclass.c
index 27e2fc6fcd..25e7e6183f 100644
--- a/drivers/usb/host/usb-uclass.c
+++ b/drivers/usb/host/usb-uclass.c
@@ -271,19 +271,23 @@ int usb_init(void)
 		/* init low_level USB */
 		printf("Bus %s: ", bus->name);
 
-#ifdef CONFIG_SANDBOX
 		/*
 		 * For Sandbox, we need scan the device tree each time when we
 		 * start the USB stack, in order to re-create the emulated USB
 		 * devices and bind drivers for them before we actually do the
 		 * driver probe.
+		 *
+		 * For USB onboard HUB, we need to do some non-trivial init
+		 * like enabling a power regulator, before enumeration.
 		 */
-		ret = dm_scan_fdt_dev(bus);
-		if (ret) {
-			printf("Sandbox USB device scan failed (%d)\n", ret);
-			continue;
+		if (IS_ENABLED(CONFIG_SANDBOX) ||
+		    IS_ENABLED(CONFIG_USB_ONBOARD_HUB)) {
+			ret = dm_scan_fdt_dev(bus);
+			if (ret) {
+				printf("USB device scan from fdt failed (%d)", ret);
+				continue;
+			}
 		}
-#endif
 
 		ret = device_probe(bus);
 		if (ret == -ENODEV) {	/* No such device. */
diff --git a/drivers/usb/host/usbh-stm32.c b/drivers/usb/host/usbh-stm32.c
new file mode 100644
index 0000000000..e69d648afd
--- /dev/null
+++ b/drivers/usb/host/usbh-stm32.c
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STM32 USB2 EHCI/OHCI (USBH) controller glue driver
+ *
+ * Copyright (C) 2023 STMicroelectronics – All Rights Reserved
+ *
+ * Author: Pankaj Dev <pankaj.dev@st.com>
+ */
+
+#define LOG_CATEGORY UCLASS_USB
+
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/devres.h>
+#include <dm/ofnode.h>
+#include <linux/bitfield.h>
+#include <regmap.h>
+#include <reset.h>
+#include <syscon.h>
+
+#define SYSCFG_USBHCR_OVRCUR_POLARITY_MASK      BIT(0)
+#define SYSCFG_USBHCR_VBUSEN_POLARITY_MASK      BIT(1)
+
+/**
+ * struct stm32_usbh_data - usbh-stm32 driver private structure
+ * @dev:		device pointer
+ * @regmap:		regmap pointer for getting syscfg
+ * @syscfg_usbhcr_reg_off:	usbhcr syscfg control offset
+ * @vbusen_polarity_low:	vbusen signal polarity
+ * @ovrcur_polarity_low:	ovrcur signal polarity
+ */
+struct stm32_usbh_data {
+	struct udevice *dev;
+	struct regmap *regmap;
+	int syscfg_usbhcr_reg_off;
+	bool vbusen_polarity_low;
+	bool ovrcur_polarity_low;
+};
+
+/**
+ * stm32_usbh_init: init the controller via glue logic
+ * @usbh_data: driver private structure
+ */
+static int stm32_usbh_init(struct stm32_usbh_data *usbh_data)
+{
+	return regmap_update_bits(usbh_data->regmap, usbh_data->syscfg_usbhcr_reg_off,
+				  SYSCFG_USBHCR_OVRCUR_POLARITY_MASK |
+				  SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+				  FIELD_PREP(SYSCFG_USBHCR_OVRCUR_POLARITY_MASK,
+					     usbh_data->ovrcur_polarity_low) |
+				  FIELD_PREP(SYSCFG_USBHCR_VBUSEN_POLARITY_MASK,
+					     usbh_data->vbusen_polarity_low));
+}
+
+static int stm32_usbh_probe(struct udevice *dev)
+{
+	ofnode node = dev_ofnode(dev);
+	struct regmap *regmap;
+	struct stm32_usbh_data *usbh_data = dev_get_plat(dev);
+	int ret;
+
+	regmap = syscon_regmap_lookup_by_phandle(dev, "st,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "no st,syscfg node found(%ld)\n", PTR_ERR(regmap));
+		ret = PTR_ERR(regmap);
+		return ret;
+	}
+
+	ret = ofnode_read_u32_index(node, "st,syscfg", 1, &usbh_data->syscfg_usbhcr_reg_off);
+	if (ret) {
+		dev_err(dev, "can't get usbhcr offset(%d)\n", ret);
+		return ret;
+	}
+
+	dev_vdbg(dev, "syscfg-usbhcr-reg offset 0x%x\n", usbh_data->syscfg_usbhcr_reg_off);
+
+	usbh_data->dev = dev;
+	usbh_data->regmap = regmap;
+
+	if (ofnode_read_bool(node, "st,vbusen-active-low"))
+		usbh_data->vbusen_polarity_low = true;
+	if (ofnode_read_bool(node, "st,ovrcur-active-low"))
+		usbh_data->ovrcur_polarity_low = true;
+
+	/* ST USBH glue logic init */
+	ret = stm32_usbh_init(usbh_data);
+	if (ret) {
+		dev_err(dev, "err setting syscfg_usbhcr_reg(%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct udevice_id stm32_usbh_ids[] = {
+	{ .compatible = "st,stm32mp25-usbh" },
+	{ /* sentinel */ },
+};
+
+U_BOOT_DRIVER(stm32_usbh_glue) = {
+	.name = "stm32-usbh-glue",
+	.id = UCLASS_NOP,
+	.of_match = stm32_usbh_ids,
+	.bind = dm_scan_fdt_dev,
+	.probe = stm32_usbh_probe,
+	.plat_auto = sizeof(struct stm32_usbh_data),
+};
diff --git a/drivers/usb/typec/Kconfig b/drivers/usb/typec/Kconfig
new file mode 100644
index 0000000000..c9930320ca
--- /dev/null
+++ b/drivers/usb/typec/Kconfig
@@ -0,0 +1,24 @@
+menuconfig TYPEC
+	bool "USB Type-C support"
+	depends on DM
+	help
+	  Enable this configurations option if you have USB Type-C connectors on
+	  your system and 1) you know your USB Type-C hardware requires OS
+	  control (a driver) to function, or 2) if you need to be able to read
+	  the status of the USB Type-C ports in your system, or 3) if you need
+	  to be able to swap the power role (decide are you supplying or
+	  consuming power over the cable) or data role (host or device) when
+	  both roles are supported.
+
+if TYPEC
+
+config TYPEC_STUSB160X
+    bool "STMicroelectronics STUSB160x Type-C controller driver"
+	depends on DM && DM_I2C
+	help
+	  Say Y or M here if your system has STMicroelectronics STUSB160x
+	  Type-C port controller.
+
+source "drivers/usb/typec/ucsi/Kconfig"
+
+endif
diff --git a/drivers/usb/typec/Makefile b/drivers/usb/typec/Makefile
new file mode 100644
index 0000000000..e0b66ae8ef
--- /dev/null
+++ b/drivers/usb/typec/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-$(CONFIG_TYPEC) += typec-uclass.o
+obj-$(CONFIG_TYPEC_STUSB160X) += typec-stusb160x.o
+obj-$(CONFIG_TYPEC_UCSI) += ucsi/
diff --git a/drivers/usb/typec/typec-stusb160x.c b/drivers/usb/typec/typec-stusb160x.c
new file mode 100644
index 0000000000..28e9bf1c74
--- /dev/null
+++ b/drivers/usb/typec/typec-stusb160x.c
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_USB_TYPEC
+
+#include <common.h>
+#include <dm.h>
+#include <i2c.h>
+#include <typec.h>
+#include <dm/device_compat.h>
+
+#define STUSB160X_ALERT_STATUS			0x0B /* RC */
+#define STUSB160X_CC_CONNECTION			BIT(6)
+
+#define STUSB160X_CC_CONNECTION_STATUS_TRANS	0x0D /* RC */
+#define STUSB160X_CC_ATTACH_TRANS		BIT(0)
+
+#define STUSB160X_CC_CONNECTION_STATUS		0x0E /* RO */
+#define STUSB160X_CC_ATTACH			BIT(0)
+#define STUSB160X_CC_DATA_ROLE			BIT(2)
+
+#define STUSB160X_CC_POWER_MODE_CTRL		0x28 /* RW */
+#define STUSB160X_DUAL_WITH_ACCESSORY		3
+
+struct stusb160x_priv {
+	enum typec_state attached;
+	enum typec_data_role data_role;
+};
+
+static int stusb160x_get_status(struct udevice *dev, bool force)
+{
+	struct stusb160x_priv *priv = dev_get_priv(dev);
+	int alert, trans, status;
+
+	alert = dm_i2c_reg_read(dev, STUSB160X_ALERT_STATUS);
+	if (alert < 0)
+		return alert;
+
+	/* If no update, exit */
+	if ((!(alert & STUSB160X_CC_CONNECTION)) && !force)
+		goto exit;
+
+	trans = dm_i2c_reg_read(dev, STUSB160X_CC_CONNECTION_STATUS_TRANS);
+	if (trans < 0)
+		return trans;
+
+	status = dm_i2c_reg_read(dev, STUSB160X_CC_CONNECTION_STATUS);
+	if (status < 0)
+		return status;
+
+	priv->data_role = status & STUSB160X_CC_DATA_ROLE ? TYPEC_HOST : TYPEC_DEVICE;
+	priv->attached = status & STUSB160X_CC_ATTACH ? TYPEC_ATTACHED : TYPEC_UNATTACHED;
+exit:
+	dev_dbg(dev, "status: %s data role: %s\n",
+		priv->attached == TYPEC_ATTACHED ? "Attached" : "Unattached",
+		priv->data_role == TYPEC_HOST ? "Host" : "Device");
+
+	return 0;
+}
+
+static int stusb160x_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	struct stusb160x_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = stusb160x_get_status(dev, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->data_role;
+}
+
+static int stusb160x_is_attached(struct udevice *dev, u8 con_idx)
+{
+	struct stusb160x_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = stusb160x_get_status(dev, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->attached;
+}
+
+static u8 stusb160x_get_nb_connector(struct udevice *dev)
+{
+	/* only one connector supported */
+	return 1;
+}
+
+static int stusb160x_probe(struct udevice *dev)
+{
+	int power_mode_ctrl;
+	int ret;
+
+	/* configure STUSB160X_CC_POWER_MODE_CTRL */
+	power_mode_ctrl = dm_i2c_reg_read(dev, STUSB160X_CC_POWER_MODE_CTRL);
+	if (power_mode_ctrl < 0)
+		return power_mode_ctrl;
+
+	power_mode_ctrl |= STUSB160X_DUAL_WITH_ACCESSORY;
+	ret = dm_i2c_reg_write(dev, STUSB160X_CC_POWER_MODE_CTRL, power_mode_ctrl);
+	if (ret < 0)
+		return ret;
+
+	/* get current status : attached/unattached, device/host */
+	return stusb160x_get_status(dev, true);
+}
+
+static const struct typec_ops stusb160x_typec_ops = {
+	.is_attached = stusb160x_is_attached,
+	.get_data_role = stusb160x_get_data_role,
+	.get_nb_connector = stusb160x_get_nb_connector,
+};
+
+static const struct udevice_id typec_of_match[] = {
+	{ .compatible = "st,stusb1600"},
+	{}
+};
+
+U_BOOT_DRIVER(typec_stusb160x) = {
+	.id			= UCLASS_USB_TYPEC,
+	.name			= "typec_stusb160x",
+	.of_match		= typec_of_match,
+	.ops			= &stusb160x_typec_ops,
+	.priv_auto		= sizeof(struct stusb160x_priv),
+	.probe			= stusb160x_probe,
+};
diff --git a/drivers/usb/typec/typec-uclass.c b/drivers/usb/typec/typec-uclass.c
new file mode 100644
index 0000000000..6b870c7ff6
--- /dev/null
+++ b/drivers/usb/typec/typec-uclass.c
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_USB_TYPEC
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <typec.h>
+#include <dm/device_compat.h>
+#include <dm/device-internal.h>
+#include <dm/uclass-internal.h>
+
+int typec_get_device_from_usb(struct udevice *dev, struct udevice **typec, u8 index)
+{
+	ofnode node, child;
+	u32 endpoint_phandle;
+	u32 reg;
+	int ret;
+
+	/* 'port' nodes can be grouped under an optional 'ports' node */
+	node = dev_read_subnode(dev, "ports");
+	if (!ofnode_valid(node)) {
+		node = dev_read_subnode(dev, "port");
+	} else {
+		/* several 'port' nodes, found the requested port@index one */
+		ofnode_for_each_subnode(child, node) {
+			ofnode_read_u32(child, "reg", &reg);
+			if (index == reg) {
+				node = child;
+				break;
+			}
+		}
+		node = child;
+	}
+
+	if (!ofnode_valid(node)) {
+		dev_dbg(dev, "connector port or port@%d subnode not found\n", index);
+		return -ENODEV;
+	}
+
+	/* get endpoint node */
+	node = ofnode_first_subnode(node);
+	if (!ofnode_valid(node))
+		return -EINVAL;
+
+	ret = ofnode_read_u32(node, "remote-endpoint", &endpoint_phandle);
+	if (ret)
+		return ret;
+
+	/* retrieve connector endpoint phandle */
+	node = ofnode_get_by_phandle(endpoint_phandle);
+	if (!ofnode_valid(node))
+		return -EINVAL;
+	/*
+	 * Use a while to retrieve an USB Type-C device either at connector
+	 * level or just above (depending if UCSI uclass is used or not)
+	 */
+	while (ofnode_valid(node)) {
+		node = ofnode_get_parent(node);
+		if (!ofnode_valid(node)) {
+			dev_err(dev, "No UCLASS_USB_TYPEC for remote-endpoint\n");
+			return -EINVAL;
+		}
+
+		uclass_find_device_by_ofnode(UCLASS_USB_TYPEC, node, typec);
+		if (*typec)
+			break;
+	}
+
+	ret = device_probe(*typec);
+	if (ret) {
+		dev_err(dev, "Type-C won't probe (ret=%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int typec_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	const struct typec_ops *ops = device_get_ops(dev);
+	int ret;
+
+	if (!ops->get_data_role)
+		return -ENOSYS;
+
+	ret = ops->get_data_role(dev, con_idx);
+	dev_dbg(dev, "%s\n", ret == TYPEC_HOST ? "Host" : "Device");
+
+	return ret;
+}
+
+int typec_is_attached(struct udevice *dev, u8 con_idx)
+{
+	const struct typec_ops *ops = device_get_ops(dev);
+	int ret;
+
+	if (!ops->is_attached)
+		return -ENOSYS;
+
+	ret = ops->is_attached(dev, con_idx);
+	dev_dbg(dev, "%s\n", ret == TYPEC_ATTACHED ? "Attached" : "Not attached");
+
+	return ret;
+}
+
+int typec_get_nb_connector(struct udevice *dev)
+{
+	const struct typec_ops *ops = device_get_ops(dev);
+	int ret;
+
+	if (!ops->get_nb_connector)
+		return -ENOSYS;
+
+	ret = ops->get_nb_connector(dev);
+	dev_dbg(dev, "%d connector(s)\n", ret);
+
+	return ret;
+}
+
+UCLASS_DRIVER(typec) = {
+	.id	= UCLASS_USB_TYPEC,
+	.name	= "typec",
+};
diff --git a/drivers/usb/typec/ucsi/Kconfig b/drivers/usb/typec/ucsi/Kconfig
new file mode 100644
index 0000000000..928106b1db
--- /dev/null
+++ b/drivers/usb/typec/ucsi/Kconfig
@@ -0,0 +1,26 @@
+menuconfig TYPEC_UCSI
+	bool "USB Type-C Connector System Software Interface (UCSI)"
+	depends on DM && TYPEC
+	help
+	  USB Type-C Connector System Software Interface (UCSI) is a
+	  specification for an interface that allows the operating system to
+	  control the USB Type-C ports. On UCSI system the USB Type-C ports
+	  function autonomously by default, but in order to get the status of
+	  the ports and support basic operations like role swapping, the driver
+	  is required. UCSI is available on most of the new Intel based systems
+	  that are equipped with Embedded Controller and USB Type-C ports.
+
+	  UCSI specification does not define the interface method, so depending
+	  on the platform, ACPI, PCI, I2C, etc. may be used. Therefore this
+	  driver only provides the core part, and separate drivers are needed
+	  for every supported interface method.
+
+	  The UCSI specification can be downloaded from:
+	  https://www.intel.com/content/www/us/en/io/universal-serial-bus/usb-type-c-ucsi-spec.html
+
+config UCSI_STM32G0
+	bool "Support for STM32G0 UCSI controller"
+	depends on TYPEC_UCSI && DM_I2C
+	help
+	  This driver enables UCSI support on platforms that expose a STM32G0
+	  Type-C controller over I2C interface.
diff --git a/drivers/usb/typec/ucsi/Makefile b/drivers/usb/typec/ucsi/Makefile
new file mode 100644
index 0000000000..043000e238
--- /dev/null
+++ b/drivers/usb/typec/ucsi/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0+
+
+obj-y +=  ucsi-uclass.o
+obj-$(CONFIG_UCSI_STM32G0) += ucsi-stm32g0.o
diff --git a/drivers/usb/typec/ucsi/ucsi-stm32g0.c b/drivers/usb/typec/ucsi/ucsi-stm32g0.c
new file mode 100644
index 0000000000..e3a1bc4889
--- /dev/null
+++ b/drivers/usb/typec/ucsi/ucsi-stm32g0.c
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_UCSI
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <ucsi.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+
+static int stm32_ucsi_read(struct udevice *dev, unsigned int offset, void *val, size_t len)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
+	u8 reg = offset;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= chip->chip_addr,
+			.flags  = 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= chip->chip_addr,
+			.flags  = I2C_M_RD,
+			.len	= len,
+			.buf	= val,
+		},
+	};
+	int ret;
+
+	ret = dm_i2c_xfer(dev, msg, ARRAY_SIZE(msg));
+	if (ret)
+		dev_err(dev, "i2c read failed @offset 0x%x (%d)\n", offset, ret);
+
+	/*
+	 * Add this delay to ensure that PPM has completed the current command,
+	 * before sending it another one.
+	 */
+	udelay(20);
+
+	return ret;
+}
+
+static int stm32_ucsi_write(struct udevice *dev, unsigned int offset,
+			    const void *val, size_t len)
+{
+	struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
+	struct i2c_msg msg[] = {
+		{
+			.addr	= chip->chip_addr,
+			.flags  = 0,
+		}
+	};
+	unsigned char *buf;
+	int ret;
+
+	buf = kzalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = offset;
+	memcpy(&buf[1], val, len);
+	msg[0].len = len + 1;
+	msg[0].buf = buf;
+
+	ret = dm_i2c_xfer(dev, msg, ARRAY_SIZE(msg));
+	kfree(buf);
+	if (ret)
+		dev_err(dev, "i2c write failed @offset 0x%x (%d)\n", offset, ret);
+
+	/*
+	 * Add this delay to ensure that PPM has completed the current command,
+	 * before sending it another one.
+	 */
+	mdelay(2);
+
+	return ret;
+}
+
+int stm32_ucsi_probe(struct udevice *dev)
+{
+	u16 ucsi_version;
+	int ret;
+
+	ret = stm32_ucsi_read(dev, UCSI_VERSION, &ucsi_version, sizeof(ucsi_version));
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(dev, "STM32G0 version 0x%x\n", ucsi_version);
+
+	return 0;
+}
+
+static const struct ucsi_ops stm32_ucsi_ops = {
+	.read = stm32_ucsi_read,
+	.write = stm32_ucsi_write,
+};
+
+static const struct udevice_id stm32_ucsi_of_match[] = {
+	{ .compatible = "st,stm32g0-typec"},
+	{}
+};
+
+U_BOOT_DRIVER(ucsi_stm32g0) = {
+	.id		= UCLASS_UCSI,
+	.name		= "ucsi-stm32g0",
+	.of_match	= stm32_ucsi_of_match,
+	.probe		= stm32_ucsi_probe,
+	.ops		= &stm32_ucsi_ops,
+	.bind		= dm_scan_fdt_dev,
+};
diff --git a/drivers/usb/typec/ucsi/ucsi-uclass.c b/drivers/usb/typec/ucsi/ucsi-uclass.c
new file mode 100644
index 0000000000..8744497ebf
--- /dev/null
+++ b/drivers/usb/typec/ucsi/ucsi-uclass.c
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ *
+ * Code inspired from kernel drivers/usb/typec/ucsi/ucsi.c
+ *
+ */
+
+#define LOG_CATEGORY UCLASS_UCSI
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <typec.h>
+#include <ucsi.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+
+/*
+ * UCSI_TIMEOUT_US - PPM communication timeout
+ *
+ * Ideally we could use MIN_TIME_TO_RESPOND_WITH_BUSY (which is defined in UCSI
+ * specification) here as reference, but unfortunately we can't. It is very
+ * difficult to estimate the time it takes for the system to process the command
+ * before it is actually passed to the PPM.
+ */
+#define UCSI_TIMEOUT_US		50000000
+
+struct connector {
+	enum typec_state attached;
+	enum typec_data_role data_role;
+};
+
+struct ucsi_priv {
+	struct connector *con;
+	u8 nb_connector;
+};
+
+static int ucsi_read(struct udevice *dev, int offset, void *buf, int size)
+{
+	const struct ucsi_ops *ops = device_get_ops(dev);
+
+	if (!ops->read)
+		return -ENOSYS;
+
+	return ops->read(dev, offset, buf, size);
+}
+
+static int ucsi_write(struct udevice *dev, int offset, void *buf, int size)
+{
+	const struct ucsi_ops *ops = device_get_ops(dev);
+
+	if (!ops->write)
+		return -ENOSYS;
+
+	return ops->write(dev, offset, buf, size);
+}
+
+static int ucsi_acknowledge_command(struct udevice *dev)
+{
+	u64 ctrl;
+
+	ctrl = UCSI_ACK_CC_CI;
+	ctrl |= UCSI_ACK_COMMAND_COMPLETE;
+
+	return ucsi_write(dev, UCSI_CONTROL, &ctrl, sizeof(ctrl));
+}
+
+static int ucsi_acknowledge_connector_change(struct udevice *dev)
+{
+	u64 ctrl;
+
+	ctrl = UCSI_ACK_CC_CI;
+	ctrl |= UCSI_ACK_CONNECTOR_CHANGE;
+
+	return ucsi_write(dev, UCSI_CONTROL, &ctrl, sizeof(ctrl));
+}
+
+static int ucsi_exec_command(struct udevice *dev, u64 command);
+
+static int ucsi_read_error(struct udevice *dev)
+{
+	u16 error;
+	int ret;
+
+	/* Acknowlege the command that failed */
+	ret = ucsi_acknowledge_command(dev);
+
+	if (ret)
+		return ret;
+
+	ret = ucsi_exec_command(dev, UCSI_GET_ERROR_STATUS);
+
+	if (ret < 0)
+		return ret;
+
+	ret = ucsi_read(dev, UCSI_MESSAGE_IN, &error, sizeof(error));
+	if (ret)
+		return ret;
+
+	switch (error) {
+	case UCSI_ERROR_INCOMPATIBLE_PARTNER:
+		return -EOPNOTSUPP;
+	case UCSI_ERROR_CC_COMMUNICATION_ERR:
+		return -ECOMM;
+	case UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL:
+		return -EPROTO;
+	case UCSI_ERROR_DEAD_BATTERY:
+		dev_warn(dev, "Dead battery condition!\n");
+		return -EPERM;
+	case UCSI_ERROR_INVALID_CON_NUM:
+	case UCSI_ERROR_UNREGONIZED_CMD:
+	case UCSI_ERROR_INVALID_CMD_ARGUMENT:
+		dev_err(dev, "possible UCSI driver bug %u\n", error);
+		return -EINVAL;
+	case UCSI_ERROR_OVERCURRENT:
+		dev_warn(dev, "Overcurrent condition\n");
+		break;
+	case UCSI_ERROR_PARTNER_REJECTED_SWAP:
+		dev_warn(dev, "Partner rejected swap\n");
+		break;
+	case UCSI_ERROR_HARD_RESET:
+		dev_warn(dev, "Hard reset occurred\n");
+		break;
+	case UCSI_ERROR_PPM_POLICY_CONFLICT:
+		dev_warn(dev, "PPM Policy conflict\n");
+		break;
+	case UCSI_ERROR_SWAP_REJECTED:
+		dev_warn(dev, "Swap rejected\n");
+		break;
+	case UCSI_ERROR_UNDEFINED:
+	default:
+		dev_err(dev, "unknown error %u\n", error);
+		break;
+	}
+
+	return -EIO;
+}
+
+static int ucsi_exec_command(struct udevice *dev, u64 cmd)
+{
+	u32 cci;
+	int ret;
+
+	ret = ucsi_write(dev, UCSI_CONTROL, &cmd, sizeof(cmd));
+	if (ret)
+		return ret;
+
+	ret = ucsi_read(dev, UCSI_CCI, &cci, sizeof(cci));
+	if (ret)
+		return ret;
+
+	if (cci & UCSI_CCI_BUSY)
+		return -EBUSY;
+
+	if (!(cci & UCSI_CCI_COMMAND_COMPLETE))
+		return -EIO;
+
+	if (cci & UCSI_CCI_NOT_SUPPORTED)
+		return -EOPNOTSUPP;
+
+	if (cci & UCSI_CCI_ERROR) {
+		if (cmd == UCSI_GET_ERROR_STATUS)
+			return -EIO;
+		return ucsi_read_error(dev);
+	}
+
+	return UCSI_CCI_LENGTH(cci);
+}
+
+static int ucsi_send_command(struct udevice *dev, u64 command,
+			     void *data, size_t size)
+{
+	u8 length;
+	int ret;
+
+	ret = ucsi_exec_command(dev, command);
+	if (ret < 0)
+		goto out;
+
+	length = ret;
+
+	if (data) {
+		ret = ucsi_read(dev, UCSI_MESSAGE_IN, data, size);
+		if (ret)
+			goto out;
+	}
+
+	ret = ucsi_acknowledge_command(dev);
+	if (ret)
+		goto out;
+
+	ret = length;
+out:
+
+	return ret;
+}
+
+static int ucsi_reset_ppm(struct udevice *dev)
+{
+	u64 command = UCSI_PPM_RESET;
+	unsigned long tmo;
+	u32 cci;
+	int ret;
+
+	ret = ucsi_write(dev, UCSI_CONTROL, &command, sizeof(command));
+	if (ret < 0)
+		goto out;
+
+	tmo = timer_get_us() + UCSI_TIMEOUT_US;
+
+	do {
+		if (time_before(tmo, timer_get_us())) {
+			ret = -ETIMEDOUT;
+			goto out;
+		}
+
+		ret = ucsi_read(dev, UCSI_CCI, &cci, sizeof(cci));
+		if (ret)
+			goto out;
+
+		/* If the PPM is still doing something else, reset it again. */
+		if (cci & ~UCSI_CCI_RESET_COMPLETE) {
+			ret = ucsi_write(dev, UCSI_CONTROL, &command,
+					 sizeof(command));
+			if (ret < 0)
+				goto out;
+		}
+
+		mdelay(20);
+	} while (!(cci & UCSI_CCI_RESET_COMPLETE));
+
+out:
+	return ret;
+}
+
+static int ucsi_get_status(struct udevice *child, u8 con_idx, bool force)
+{
+	struct udevice *parent = dev_get_parent(child);
+	struct ucsi_priv *priv = dev_get_priv(child);
+	struct ucsi_connector_status status;
+	u64 command;
+	u32 cci;
+	int ret = 0;
+
+	if (con_idx > (priv->nb_connector - 1))
+		return -EINVAL;
+
+	ret = ucsi_read(parent, UCSI_CCI, &cci, sizeof(cci));
+	if (ret)
+		return ret;
+
+	/* is there any change ? */
+	if (!UCSI_CCI_CONNECTOR(cci) && !force)
+		goto exit;
+
+	command = UCSI_GET_CONNECTOR_STATUS | UCSI_CONNECTOR_NUMBER(con_idx + 1);
+	ret = ucsi_send_command(parent, command, &status, sizeof(status));
+	if (ret < 0)
+		return ret;
+
+	priv->con[con_idx].attached = status.flags & UCSI_CONSTAT_CONNECTED ?
+		TYPEC_ATTACHED : TYPEC_UNATTACHED;
+
+	switch (UCSI_CONSTAT_PARTNER_TYPE(status.flags)) {
+	case UCSI_CONSTAT_PARTNER_TYPE_UFP:
+	case UCSI_CONSTAT_PARTNER_TYPE_CABLE_AND_UFP:
+	case UCSI_CONSTAT_PARTNER_TYPE_CABLE:
+		priv->con[con_idx].data_role = TYPEC_HOST;
+		break;
+	case UCSI_CONSTAT_PARTNER_TYPE_DFP:
+		priv->con[con_idx].data_role = TYPEC_DEVICE;
+		break;
+	}
+
+	ret = ucsi_acknowledge_connector_change(parent);
+exit:
+	dev_dbg(child, "connector[%d] status: %s data role: %s\n",
+		con_idx,
+		priv->con[con_idx].attached == TYPEC_ATTACHED ? "Attached" : "Unattached",
+		priv->con[con_idx].data_role == TYPEC_HOST ? "Host" : "Device");
+
+	return ret;
+}
+
+int ucsi_post_probe(struct udevice *dev)
+{
+	struct connector *con;
+	struct ucsi_priv *priv;
+	struct udevice *child;
+	struct ucsi_capability cap;
+	u64 command;
+	int ret;
+	u8 i;
+
+	/* Reset the PPM */
+	ret = ucsi_reset_ppm(dev);
+	if (ret) {
+		dev_err(dev, "failed to reset PPM!\n");
+		return ret;
+	}
+
+	/* enable connector change notification */
+	command = UCSI_SET_NOTIFICATION_ENABLE | UCSI_ENABLE_NTFY_CONNECTOR_CHANGE;
+	ret = ucsi_send_command(dev, command, NULL, 0);
+	if (ret < 0)
+		return ret;
+
+	/* get current status : attached/unattached, device/host */
+	ret = device_get_child(dev, 0, &child);
+	if (ret < 0)
+		return ret;
+
+	/* Get PPM capabilities */
+	command = UCSI_GET_CAPABILITY;
+	ret = ucsi_send_command(dev, command, &cap, sizeof(cap));
+	if (ret < 0)
+		return ret;
+
+	if (!cap.num_connectors)
+		return -ENODEV;
+
+	priv = dev_get_priv(child);
+	priv->nb_connector = cap.num_connectors;
+	priv->con = kcalloc(priv->nb_connector, sizeof(*con), GFP_KERNEL);
+	if (!priv->con)
+		return -ENOMEM;
+
+	for (i = 0; i < priv->nb_connector; i++) {
+		ret = ucsi_get_status(child, i, true);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+UCLASS_DRIVER(ucsi) = {
+	.id		= UCLASS_UCSI,
+	.name		= "ucsi",
+	.post_probe	= ucsi_post_probe,
+};
+
+static int ucsi_is_attached(struct udevice *dev, u8 con_idx)
+{
+	struct ucsi_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ucsi_get_status(dev, con_idx, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->con[con_idx].attached;
+}
+
+static int ucsi_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	struct ucsi_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = ucsi_get_status(dev, con_idx, false);
+	if (ret < 0)
+		return ret;
+
+	return priv->con[con_idx].data_role;
+}
+
+static u8 usci_get_nb_connector(struct udevice *dev)
+{
+	struct ucsi_priv *priv = dev_get_priv(dev);
+
+	return priv->nb_connector;
+}
+
+static const struct typec_ops ucsi_typec_ops = {
+	.is_attached = ucsi_is_attached,
+	.get_data_role = ucsi_get_data_role,
+	.get_nb_connector = usci_get_nb_connector,
+};
+
+static const struct udevice_id typec_of_match[] = {
+	{ .compatible = "usb-c-connector"},
+	{}
+};
+
+U_BOOT_DRIVER(typec_ucsi) = {
+	.id		= UCLASS_USB_TYPEC,
+	.name		= "typec_ucsi",
+	.of_match	= typec_of_match,
+	.ops		= &ucsi_typec_ops,
+	.priv_auto	= sizeof(struct ucsi_priv),
+};
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 4ecc158c46..0b87cd9de0 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -454,6 +454,15 @@ config VIDEO_LCD_RAYDIUM_RM68200
 	Say Y here if you want to enable support for Raydium RM68200
 	720x1280 DSI video mode panel.
 
+config VIDEO_LCD_ROCKTECH_HX8394
+	bool "ROCKTECH HX8394 DSI LCD panel support"
+	depends on DM_VIDEO
+	select VIDEO_MIPI_DSI
+	default n
+	help
+	Say Y here if you want to enable support for Rocktech HX8394
+	720x1280 DSI video mode panel.
+
 config VIDEO_LCD_SSD2828
 	bool "SSD2828 bridge chip"
 	---help---
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 7019b26396..752a0166b5 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_VIDEO_LCD_ANX9804) += anx9804.o
 obj-$(CONFIG_VIDEO_LCD_HITACHI_TX18D42VM) += hitachi_tx18d42vm_lcd.o
 obj-$(CONFIG_VIDEO_LCD_ORISETECH_OTM8009A) += orisetech_otm8009a.o
 obj-$(CONFIG_VIDEO_LCD_RAYDIUM_RM68200) += raydium-rm68200.o
+obj-$(CONFIG_VIDEO_LCD_ROCKTECH_HX8394) += rocktech-hx8394.o
 obj-$(CONFIG_VIDEO_LCD_SSD2828) += ssd2828.o
 obj-$(CONFIG_VIDEO_LCD_TDO_TL070WSH30) += tdo-tl070wsh30.o
 obj-$(CONFIG_VIDEO_MCDE_SIMPLE) += mcde_simple.o
diff --git a/drivers/video/rocktech-hx8394.c b/drivers/video/rocktech-hx8394.c
new file mode 100644
index 0000000000..9a2689600b
--- /dev/null
+++ b/drivers/video/rocktech-hx8394.c
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2022 STMicroelectronics - All Rights Reserved
+ * Author: Yannick Fertre <yannick.fertre@foss.st.com> for STMicroelectronics.
+ *
+ * This hx8394 panel driver is inspired from the Linux Kernel driver
+ * drivers/gpu/drm/panel/panel-rocktech-hx8394.c.
+ */
+#include <common.h>
+#include <backlight.h>
+#include <dm.h>
+#include <mipi_dsi.h>
+#include <panel.h>
+#include <asm/gpio.h>
+#include <dm/device_compat.h>
+#include <linux/delay.h>
+#include <power/regulator.h>
+
+#define MCS_SETPOWER	0xB1
+#define MCS_SETDISP	0xB2
+#define MCS_SETCYC	0xB4
+#define MCS_SETVCOM	0xB6
+#define MCS_SETEXTC	0xB9
+#define MCS_SETMIPI	0xBA
+#define MCS_SET_BANK	0xBD
+#define MCS_NO_DOC1	0xBF
+#define MCS_NO_DOC2	0xC0
+#define MCS_NO_DOC3	0xC6
+#define MCS_NO_DOC4	0xD8
+#define MCS_NO_DOC5	0xD4
+#define MCS_SETPANEL	0xCC
+#define MCS_SETGIP_0	0xD3
+#define MCS_SETGIP_1	0xD5
+#define MCS_SETGIP_2	0xD6
+
+#define MCS_SETGAMMA	0xE0
+#define MCS_READ_ID1	0xDA
+#define MCS_READ_ID2	0xDB
+#define MCS_READ_ID3	0xDC
+
+#define MY	BIT(7)	/* Row Address Order */
+#define MX	BIT(6)	/* Column Address Order */
+#define MV	BIT(5)	/* Row/Column Exchange */
+#define ML	BIT(4)	/* Vertical Refresh Order */
+#define RGB	BIT(3)	/* RGB-BGR Order */
+#define DDL	BIT(2)	/* Display Data Latch Order */
+#define FH	BIT(1)	/* Flip Horizontal */
+#define FV	BIT(0)	/* Flip Vertical */
+
+struct hx8394_panel_priv {
+	struct udevice *reg;
+	struct udevice *backlight;
+	struct gpio_desc reset;
+};
+
+static const struct display_timing default_timing = {
+	.pixelclock.typ		= 54000000,
+	.hactive.typ		= 720,
+	.hfront_porch.typ	= 48,
+	.hback_porch.typ	= 48,
+	.hsync_len.typ		= 9,
+	.vactive.typ		= 1280,
+	.vfront_porch.typ	= 12,
+	.vback_porch.typ	= 12,
+	.vsync_len.typ		= 5,
+};
+
+static void hx8394_dcs_write_buf(struct udevice *dev, const void *data,
+				 size_t len)
+{
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);
+	struct mipi_dsi_device *device = plat->device;
+	int err;
+
+	err = mipi_dsi_dcs_write_buffer(device, data, len);
+	if (err < 0)
+		dev_err(dev, "MIPI DSI DCS write buffer failed: %d\n", err);
+}
+
+#define dcs_write_seq(dev, seq...)				\
+({								\
+	static const u8 d[] = { seq };				\
+								\
+	hx8394_dcs_write_buf(dev, d, ARRAY_SIZE(d));	\
+})
+
+#define dcs_write_cmd_seq(dev, cmd, seq...)				\
+({									\
+	static const u8 d[] = { seq };					\
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);		\
+	struct mipi_dsi_device *device = plat->device;			\
+	int err;							\
+	err = mipi_dsi_dcs_write(device, cmd, d, ARRAY_SIZE(d));	\
+	if (err < 0)							\
+		dev_err(dev, "MIPI DSI DCS write failed: %d\n", err);	\
+})
+
+static void hx8394_init_sequence(struct udevice *dev)
+{
+	dcs_write_cmd_seq(dev, MCS_SETEXTC, 0xFF, 0x83, 0x94);
+	dcs_write_cmd_seq(dev, MCS_SETMIPI, 0x61, 0x03, 0x68, 0x6B, 0xB2, 0xC0);
+	dcs_write_seq(dev, MCS_SETPOWER, 0x48, 0x12, 0x72, 0x09, 0x32, 0x54, 0x71, 0x71, 0x57,
+		      0x47);
+	dcs_write_cmd_seq(dev, MCS_SETDISP, 0x00, 0x80, 0x64, 0x0C, 0x0D, 0x2F);
+	dcs_write_seq(dev, MCS_SETCYC, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86, 0x75,
+		      0x00, 0x3F, 0x73, 0x74, 0x73, 0x74, 0x73, 0x74, 0x01, 0x0C, 0x86);
+	dcs_write_seq(dev, MCS_SETGIP_0, 0x00, 0x00, 0x07, 0x07, 0x40, 0x07, 0x0C, 0x00, 0x08, 0x10,
+		      0x08, 0x00, 0x08, 0x54, 0x15, 0x0A, 0x05, 0x0A, 0x02, 0x15, 0x06, 0x05, 0x06,
+		      0x47, 0x44, 0x0A, 0x0A, 0x4B, 0x10, 0x07, 0x07, 0x0C, 0x40);
+	dcs_write_seq(dev, MCS_SETGIP_1, 0x1C, 0x1C, 0x1D, 0x1D, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
+		      0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x24, 0x25, 0x18, 0x18, 0x26, 0x27, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x20, 0x21, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_seq(dev, MCS_SETGIP_2, 0x1C, 0x1C, 0x1D, 0x1D, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02,
+		      0x01, 0x00, 0x0B, 0x0A, 0x09, 0x08, 0x21, 0x20, 0x18, 0x18, 0x27, 0x26, 0x18,
+		      0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+		      0x18, 0x18, 0x25, 0x24, 0x18, 0x18, 0x18, 0x18);
+	dcs_write_cmd_seq(dev, MCS_SETVCOM, 0x92, 0x92);
+	dcs_write_seq(dev, MCS_SETGAMMA, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24, 0x22, 0x47, 0x56,
+		      0x65, 0x66, 0x6E, 0x82, 0x88, 0x8B, 0x9A, 0x9D, 0x98, 0xA8, 0xB9, 0x5D, 0x5C,
+		      0x61, 0x66, 0x6A, 0x6F, 0x7F, 0x7F, 0x00, 0x0A, 0x15, 0x1B, 0x1E, 0x21, 0x24,
+		      0x22, 0x47, 0x56, 0x65, 0x65, 0x6E, 0x81, 0x87, 0x8B, 0x98, 0x9D, 0x99, 0xA8,
+		      0xBA, 0x5D, 0x5D, 0x62, 0x67, 0x6B, 0x72, 0x7F,  0x7F);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC2, 0x1F, 0x31);
+	dcs_write_cmd_seq(dev, MCS_SETPANEL, 0x03);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC5, 0x02);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x02);
+	dcs_write_seq(dev, MCS_NO_DOC4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		      0xFF, 0xFF);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x01);
+	dcs_write_cmd_seq(dev, MCS_SETPOWER, 0x00);
+	dcs_write_cmd_seq(dev, MCS_SET_BANK, 0x00);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC1, 0x40, 0x81, 0x50, 0x00, 0x1A, 0xFC, 0x01);
+	dcs_write_cmd_seq(dev, MCS_NO_DOC3, 0xED);
+	dcs_write_cmd_seq(dev, MIPI_DCS_SET_ADDRESS_MODE, FH);
+}
+
+static int hx8394_panel_enable_backlight(struct udevice *dev)
+{
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);
+	struct mipi_dsi_device *device = plat->device;
+	struct hx8394_panel_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret = mipi_dsi_attach(device);
+	if (ret < 0)
+		return ret;
+
+	hx8394_init_sequence(dev);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(device);
+	if (ret)
+		return ret;
+
+	mdelay(120);
+
+	ret = mipi_dsi_dcs_set_display_on(device);
+	if (ret)
+		return ret;
+
+	mdelay(50);
+
+	ret = backlight_enable(priv->backlight);
+
+	return ret;
+}
+
+static int hx8394_panel_get_display_timing(struct udevice *dev,
+					   struct display_timing *timings)
+{
+	memcpy(timings, &default_timing, sizeof(*timings));
+
+	return 0;
+}
+
+static int hx8394_panel_of_to_plat(struct udevice *dev)
+{
+	struct hx8394_panel_priv *priv = dev_get_priv(dev);
+	int ret;
+
+	ret =  device_get_supply_regulator(dev, "power-supply",
+					   &priv->reg);
+	if (ret) {
+		dev_err(dev, "Warning: cannot get power supply\n");
+		return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "reset-gpios", 0, &priv->reset,
+				   GPIOD_IS_OUT);
+	if (ret) {
+		dev_err(dev, "Warning: cannot get reset GPIO\n");
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev,
+					   "backlight", &priv->backlight);
+	if (ret)
+		dev_err(dev, "Cannot get backlight: ret=%d\n", ret);
+
+	return ret;
+}
+
+static int hx8394_panel_probe(struct udevice *dev)
+{
+	struct hx8394_panel_priv *priv = dev_get_priv(dev);
+	struct mipi_dsi_panel_plat *plat = dev_get_plat(dev);
+	int ret;
+
+	ret = regulator_set_enable(priv->reg, true);
+	if (ret)
+		return ret;
+
+	/* reset panel */
+	dm_gpio_set_value(&priv->reset, true);
+	mdelay(1);
+	dm_gpio_set_value(&priv->reset, false);
+	mdelay(50);
+
+	/* fill characteristics of DSI data link */
+	plat->lanes = 2;
+	plat->format = MIPI_DSI_FMT_RGB888;
+	plat->mode_flags = MIPI_DSI_MODE_VIDEO |
+			   MIPI_DSI_MODE_VIDEO_BURST |
+			   MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct panel_ops hx8394_panel_ops = {
+	.enable_backlight = hx8394_panel_enable_backlight,
+	.get_display_timing = hx8394_panel_get_display_timing,
+};
+
+static const struct udevice_id hx8394_panel_ids[] = {
+	{ .compatible = "rocktech,hx8394" },
+	{ }
+};
+
+U_BOOT_DRIVER(hx8394_panel) = {
+	.name			  = "hx8394_panel",
+	.id			  = UCLASS_PANEL,
+	.of_match		  = hx8394_panel_ids,
+	.ops			  = &hx8394_panel_ops,
+	.of_to_plat	  = hx8394_panel_of_to_plat,
+	.probe			  = hx8394_panel_probe,
+	.plat_auto	= sizeof(struct mipi_dsi_panel_plat),
+	.priv_auto	= sizeof(struct hx8394_panel_priv),
+};
diff --git a/drivers/video/simple_panel.c b/drivers/video/simple_panel.c
index c8f7022ea6..e8162cbf68 100644
--- a/drivers/video/simple_panel.c
+++ b/drivers/video/simple_panel.c
@@ -48,6 +48,20 @@ static int simple_panel_set_backlight(struct udevice *dev, int percent)
 	return 0;
 }
 
+static int simple_panel_get_display_timing(struct udevice *dev, struct display_timing *timing)
+{
+	int ret;
+
+	ret = ofnode_decode_display_timing(dev_ofnode(dev), 0, timing);
+	if (ret) {
+		debug("%s: Could not decode display timings: ret=%d\n",
+		      __func__, ret);
+		ret = ofnode_decode_panel_timing(dev_ofnode(dev), timing);
+	}
+
+	return ret;
+}
+
 static int simple_panel_of_to_plat(struct udevice *dev)
 {
 	struct simple_panel_priv *priv = dev_get_priv(dev);
@@ -99,6 +113,7 @@ static int simple_panel_probe(struct udevice *dev)
 static const struct panel_ops simple_panel_ops = {
 	.enable_backlight	= simple_panel_enable_backlight,
 	.set_backlight		= simple_panel_set_backlight,
+	.get_display_timing	= simple_panel_get_display_timing,
 };
 
 static const struct udevice_id simple_panel_ids[] = {
@@ -110,6 +125,8 @@ static const struct udevice_id simple_panel_ids[] = {
 	{ .compatible = "lg,lb070wv8" },
 	{ .compatible = "sharp,lq123p1jx31" },
 	{ .compatible = "boe,nv101wxmn51" },
+	{ .compatible = "panel-dpi" },
+	{ .compatible = "panel-lvds" },
 	{ }
 };
 
diff --git a/drivers/video/stm32/Kconfig b/drivers/video/stm32/Kconfig
index 95d51bb4e9..84e96517d7 100644
--- a/drivers/video/stm32/Kconfig
+++ b/drivers/video/stm32/Kconfig
@@ -22,6 +22,15 @@ config VIDEO_STM32_DSI
 	  This option enables support DSI internal bridge which can be used on
 	  devices which have DSI devices connected.
 
+config VIDEO_STM32_LVDS
+	bool "Enable STM32 LVDS video support"
+	depends on VIDEO_STM32
+	select VIDEO_BRIDGE
+	select VIDEO_DW_MIPI_DSI
+	help
+	  This enables Low Voltage Differential Signaling (LVDS) display
+	  support.
+
 config VIDEO_STM32_MAX_XRES
 	int "Maximum horizontal resolution (for memory allocation purposes)"
 	depends on VIDEO_STM32
diff --git a/drivers/video/stm32/Makefile b/drivers/video/stm32/Makefile
index f8b42d1a4d..059d9000c1 100644
--- a/drivers/video/stm32/Makefile
+++ b/drivers/video/stm32/Makefile
@@ -7,3 +7,4 @@
 
 obj-${CONFIG_VIDEO_STM32} = stm32_ltdc.o
 obj-${CONFIG_VIDEO_STM32_DSI} += stm32_dsi.o
+obj-${CONFIG_VIDEO_STM32_LVDS} += stm32_lvds.o
diff --git a/drivers/video/stm32/stm32_dsi.c b/drivers/video/stm32/stm32_dsi.c
index 5871ac7c4f..4d7f0d42cf 100644
--- a/drivers/video/stm32/stm32_dsi.c
+++ b/drivers/video/stm32/stm32_dsi.c
@@ -30,6 +30,7 @@
 
 #define HWVER_130			0x31333000	/* IP version 1.30 */
 #define HWVER_131			0x31333100	/* IP version 1.31 */
+#define HWVER_141			0x31343100	/* IP version 1.41 */
 
 /* DSI digital registers & bit definitions */
 #define DSI_VERSION			0x00
@@ -68,6 +69,11 @@
 #define ODF_MIN		1
 #define ODF_MAX		8
 
+#define IDF_PHY_141_MIN		1
+#define IDF_PHY_141_MAX		16
+#define NDIV_PHY_141_MIN	64
+#define NDIV_PHY_141_MAX	625
+
 /* dsi color format coding according to the datasheet */
 enum dsi_color {
 	DSI_RGB565_CONF1,
@@ -81,6 +87,50 @@ enum dsi_color {
 #define LANE_MIN_KBPS	31250
 #define LANE_MAX_KBPS	500000
 
+/* specific registers for hardware version 1.41 */
+#define DSI_WPCR1	0x0430		/* Wrapper Phy Conf Reg 1 */
+#define WPCR1_CCF	GENMASK(5, 0)	/* Configuration clock frequency */
+#define WPCR1_HSFR	GENMASK(14, 8)	/* High speed frequency range in Tx mode */
+#define WPCR1_DLD	BIT(16)		/* Data lanes 0 direction */
+
+#define DSI_WRPCR0	0x0434		/* Wrapper regulator and PLL configuration register 0 */
+#define WRPCR0_IDF	GENMASK(3, 0)	/* PLL input division ratio */
+#define WRPCR0_NDIV	GENMASK(13, 4)	/* PLL InLoop division ratio */
+#define WRPCR0_PSC	BIT(16)		/* PLL shadow control */
+
+#define DSI_WRPCR1	0x0438		/* Wrapper regulator and PLL configuration register 1 */
+#define WRPCR1_PROP	GENMASK(5, 0)	/* Proportional charge pump */
+#define WRPCR1_GMP	GENMASK(7, 6)	/* Loop filter resistance */
+#define WRPCR1_INT	GENMASK(13, 8)	/* Integral of charge pump */
+#define WRPCR1_BIAS	GENMASK(22, 16)	/* Charge pump bias */
+#define WRPCR1_VCO	GENMASK(27, 24)	/* VCO operating range */
+#define WRPCR1_ODF	GENMASK(29, 28)	/* Output division factor */
+
+#define DSI_WRPCR2	0x043C		/* Wrapper regulator and PLL configuration register 2 */
+#define WRPCR2_SEL	GENMASK(1, 0)	/* Output selection for PLL Clock */
+#define WRPCR2_PLLEN	BIT(8)		/* PLL ENable */
+#define WRPCR2_UPD	BIT(16)		/* Update (copies) the PLL shadow registers */
+#define WRPCR2_CLR	BIT(24)		/* Clears the PLL shadow registers to their reset values */
+#define WRPCR2_FPLL	BIT(28)		/* Force PLL lock signal */
+
+#define DSI_PTCR0	0x00B4		/* Host PHY test control register 0 */
+#define PTCR0_TRSEN	BIT(0)		/* Test-interface reset enable for the TDI bus */
+#define PTCR0_TCKEN	BIT(1)		/* Test-interface clock enable for the TDI bus */
+
+#define DSI_PCTLR	0x00A0		/* Host PHY control register */
+#define PCTLR_PWEN	BIT(0)		/* Power enable */
+#define PCTLR_DEN	BIT(1)		/* Digital enable */
+#define PCTLR_CKEN	BIT(2)		/* Clock enable */
+#define PCTLR_UCKEN	BIT(3)		/* ULPS clock enable */
+
+#define DSI_PSR		0x00B0		/* Host PHY status register */
+#define PSR_PSSC	BIT(2)		/* PHY stop state clock lane */
+
+#define LANE_MIN_PHY_141_KBPS	80000
+#define LANE_MAX_PHY_141_KBPS	2500000
+#define FVCO_MIN_PHY_141_KBPS	320000
+#define FVCO_MAX_PHY_141_KBPS	1250000
+
 /* Timeout for regulator on/off, pll lock/unlock & fifo empty */
 #define TIMEOUT_US	200000
 
@@ -93,7 +143,10 @@ struct stm32_dsi_priv {
 	int lane_min_kbps;
 	int lane_max_kbps;
 	struct udevice *vdd_reg;
+	struct udevice *vdda18_reg;
 	struct udevice *dsi_host;
+	unsigned int lane_mbps;
+	u32 format;
 };
 
 static inline void dsi_write(struct stm32_dsi_priv *dsi, u32 reg, u32 val)
@@ -338,6 +391,474 @@ static const struct mipi_dsi_phy_ops dsi_stm_phy_ops = {
 	.post_set_mode = dsi_phy_post_set_mode,
 };
 
+struct hstt {
+	unsigned int maxfreq;
+	struct mipi_dsi_phy_timing timing;
+};
+
+#define HSTT(_maxfreq, _c_lp2hs, _c_hs2lp, _d_lp2hs, _d_hs2lp)	\
+{					\
+	.maxfreq = _maxfreq,		\
+	.timing = {			\
+		.clk_lp2hs = _c_lp2hs,	\
+		.clk_hs2lp = _c_hs2lp,	\
+		.data_lp2hs = _d_lp2hs,	\
+		.data_hs2lp = _d_hs2lp,	\
+	}				\
+}
+
+/* Table High-Speed Transition Times */
+static const struct hstt hstt_phy_141_table[] = {
+	HSTT(80, 21, 17, 15, 10),
+	HSTT(90, 23, 17, 16, 10),
+	HSTT(100, 22, 17, 16, 10),
+	HSTT(110, 25, 18, 17, 11),
+	HSTT(120, 26, 20, 18, 11),
+	HSTT(130, 27, 19, 19, 11),
+	HSTT(140, 27, 19, 19, 11),
+	HSTT(150, 28, 20, 20, 12),
+	HSTT(160, 30, 21, 22, 13),
+	HSTT(170, 30, 21, 23, 13),
+	HSTT(180, 31, 21, 23, 13),
+	HSTT(190, 32, 22, 24, 13),
+	HSTT(205, 35, 22, 25, 13),
+	HSTT(220, 37, 26, 27, 15),
+	HSTT(235, 38, 28, 27, 16),
+	HSTT(250, 41, 29, 30, 17),
+	HSTT(275, 43, 29, 32, 18),
+	HSTT(300, 45, 32, 35, 19),
+	HSTT(325, 48, 33, 36, 18),
+	HSTT(350, 51, 35, 40, 20),
+	HSTT(400, 59, 37, 44, 21),
+	HSTT(450, 65, 40, 49, 23),
+	HSTT(500, 71, 41, 54, 24),
+	HSTT(550, 77, 44, 57, 26),
+	HSTT(600, 82, 46, 64, 27),
+	HSTT(650, 87, 48, 67, 28),
+	HSTT(700, 94, 52, 71, 29),
+	HSTT(750, 99, 52, 75, 31),
+	HSTT(800, 105, 55, 82, 32),
+	HSTT(850, 110, 58, 85, 32),
+	HSTT(900, 115, 58, 88, 35),
+	HSTT(950, 120, 62, 93, 36),
+	HSTT(1000, 128, 63, 99, 38),
+	HSTT(1050, 132, 65, 102, 38),
+	HSTT(1100, 138, 67, 106, 39),
+	HSTT(1150, 146, 69, 112, 42),
+	HSTT(1200, 151, 71, 117, 43),
+	HSTT(1250, 153, 74, 120, 45),
+	HSTT(1300, 160, 73, 124, 46),
+	HSTT(1350, 165, 76, 130, 47),
+	HSTT(1400, 172, 78, 134, 49),
+	HSTT(1450, 177, 80, 138, 49),
+	HSTT(1500, 183, 81, 143, 52),
+	HSTT(1550, 191, 84, 147, 52),
+	HSTT(1600, 194, 85, 152, 52),
+	HSTT(1650, 201, 86, 155, 53),
+	HSTT(1700, 208, 88, 161, 53),
+	HSTT(1750, 212, 89, 165, 53),
+	HSTT(1800, 220, 90, 171, 54),
+	HSTT(1850, 223, 92, 175, 55),
+	HSTT(1900, 231, 91, 180, 56),
+	HSTT(1950, 236, 95, 185, 56),
+	HSTT(2000, 243, 97, 190, 58),
+	HSTT(2050, 248, 99, 194, 59),
+	HSTT(2100, 252, 100, 199, 61),
+	HSTT(2150, 259, 102, 204, 62),
+	HSTT(2200, 266, 105, 210, 63),
+	HSTT(2250, 269, 109, 213, 65),
+	HSTT(2300, 272, 109, 217, 66),
+	HSTT(2350, 281, 112, 225, 66),
+	HSTT(2400, 283, 115, 226, 67),
+	HSTT(2450, 282, 115, 226, 67),
+	HSTT(2500, 281, 118, 227, 68)
+};
+
+struct dphy_pll_parameter_map {
+	u32 data_rate;	/* upper margin of frequency range */
+	u8 hs_freq;	/* hsfreqrange */
+	u8 odf;
+	u8 vco;
+	u8 prop;
+};
+
+static const struct dphy_pll_parameter_map dppa_map_phy_141[] = {
+	{80, 0x00, 0x03, 0x0F, 0x0B},
+	{90, 0x10, 0x03, 0x0F, 0x0B},
+	{100, 0x20, 0x03, 0x0F, 0x0B},
+	{110, 0x30, 0x03, 0x09, 0x0B},
+	{120, 0x01, 0x03, 0x09, 0x0B},
+	{130, 0x11, 0x03, 0x09, 0x0B},
+	{140, 0x21, 0x03, 0x09, 0x0B},
+	{150, 0x31, 0x03, 0x09, 0x0B},
+	{160, 0x02, 0x02, 0x0F, 0x0B},
+	{170, 0x12, 0x02, 0x0F, 0x0B},
+	{180, 0x22, 0x02, 0x0F, 0x0B},
+	{190, 0x32, 0x02, 0x0F, 0x0B},
+	{205, 0x03, 0x02, 0x0F, 0x0B},
+	{220, 0x13, 0x02, 0x09, 0x0B},
+	{235, 0x23, 0x02, 0x09, 0x0B},
+	{250, 0x33, 0x02, 0x09, 0x0B},
+	{275, 0x04, 0x02, 0x09, 0x0B},
+	{300, 0x14, 0x02, 0x09, 0x0B},
+	{325, 0x25, 0x01, 0x0F, 0x0B},
+	{350, 0x35, 0x01, 0x0F, 0x0B},
+	{400, 0x05, 0x01, 0x0F, 0x0B},
+	{450, 0x16, 0x01, 0x09, 0x0B},
+	{500, 0x26, 0x01, 0x09, 0x0B},
+	{550, 0x37, 0x01, 0x09, 0x0B},
+	{600, 0x07, 0x01, 0x09, 0x0B},
+	{650, 0x18, 0x00, 0x0F, 0x0B},
+	{700, 0x28, 0x00, 0x0F, 0x0B},
+	{750, 0x39, 0x00, 0x0F, 0x0B},
+	{800, 0x09, 0x00, 0x0F, 0x0B},
+	{850, 0x19, 0x00, 0x09, 0x0B},
+	{900, 0x29, 0x00, 0x09, 0x0B},
+	{950, 0x3A, 0x00, 0x09, 0x0B},
+	{1000, 0x0A, 0x00, 0x09, 0x0B},
+	{1050, 0x1A, 0x00, 0x09, 0x0B},
+	{1100, 0x2A, 0x00, 0x09, 0x0B},
+	{1150, 0x3B, 0x00, 0x09, 0x0B},
+	{1200, 0x0B, 0x00, 0x09, 0x0B},
+	{1250, 0x1B, 0x00, 0x09, 0x0B},
+	{1300, 0x2B, 0x00, 0x03, 0x0B},
+	{1350, 0x3C, 0x00, 0x03, 0x0B},
+	{1400, 0x0C, 0x00, 0x03, 0x0B},
+	{1450, 0x1C, 0x00, 0x03, 0x0B},
+	{1500, 0x2C, 0x00, 0x03, 0x0B},
+	{1550, 0x3D, 0x00, 0x03, 0x0B},
+	{1600, 0x0D, 0x00, 0x03, 0x0B},
+	{1650, 0x1D, 0x00, 0x03, 0x0B},
+	{1700, 0x2E, 0x00, 0x03, 0x0B},
+	{1750, 0x3E, 0x00, 0x03, 0x0B},
+	{1800, 0x0E, 0x00, 0x03, 0x0B},
+	{1850, 0x1E, 0x00, 0x03, 0x0B},
+	{1900, 0x2F, 0x00, 0x03, 0x0B},
+	{1950, 0x3F, 0x00, 0x03, 0x0B},
+	{2000, 0x0F, 0x00, 0x03, 0x0B},
+	{2050, 0x40, 0x00, 0x03, 0x0B},
+	{2100, 0x41, 0x00, 0x03, 0x0B},
+	{2150, 0x42, 0x00, 0x03, 0x0B},
+	{2200, 0x43, 0x00, 0x01, 0x0B},
+	{2250, 0x44, 0x00, 0x01, 0x0B},
+	{2300, 0x45, 0x00, 0x01, 0x0C},
+	{2350, 0x46, 0x00, 0x01, 0x0C},
+	{2400, 0x47, 0x00, 0x01, 0x0C},
+	{2450, 0x48, 0x00, 0x01, 0x0C},
+	{2500, 0x49, 0x00, 0x01, 0x0C}
+};
+
+static int dsi_phy_141_pll_get_params(struct stm32_dsi_priv *dsi,
+				      int clkin_khz, int clkout_khz,
+				      int *idf, int *ndiv, int *odf)
+{
+	int i, n;
+	int delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = IDF_PHY_141_MIN; i <= IDF_PHY_141_MAX; i++) {
+		for (n = NDIV_PHY_141_MIN; n <= NDIV_PHY_141_MAX; n++) {
+			/* Check if new delta is better & saves parameters */
+			delta = dsi_pll_get_clkout_khz(clkin_khz, i, n, *odf) - clkout_khz;
+
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				*idf = i;
+				*ndiv = n;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int dsi_phy_141_init(void *priv_data)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	struct stm32_dsi_priv *dsi = dev_get_priv(dev);
+	u32 val, ccf, prop, gmp, int1, bias, vco, ndiv, odf, idf;
+	unsigned int pll_in_khz, pll_out_khz, hsfreq;
+	int ret, i;
+
+	dev_dbg(dev, "Initialize DSI physical layer\n");
+
+	/* Select video mode by resetting DSIM bit */
+	dsi_clear(dsi, DSI_WCFGR, WCFGR_DSIM);
+
+	/* Select the color coding */
+	dsi_update_bits(dsi, DSI_WCFGR, WCFGR_COLMUX,
+			dsi_color_from_mipi(dsi->format) << 1);
+
+	dsi_write(dsi, DSI_PCTLR, 0x00);
+
+	/* clear the pll shadow regs */
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_CLR);
+	mdelay(1);
+
+	/* set testclr = 1 */
+	dsi_set(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_PTCR0, PTCR0_TRSEN);
+	mdelay(1);
+
+	/* Compute requested pll out, pll out is the half of the lane data rate */
+	pll_out_khz = dsi->lane_mbps * 1000 / 2;
+	pll_in_khz = dsi->pllref_clk / 1000;
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map_phy_141); i++) {
+		if (dsi->lane_mbps < dppa_map_phy_141[i].data_rate) {
+			i--;
+			break;
+		}
+	}
+
+	switch (dppa_map_phy_141[i].odf) {
+	case(3):
+		odf = 8;
+		break;
+	case(2):
+		odf = 4;
+		break;
+	case(1):
+		odf = 2;
+		break;
+	default:
+		odf = 1;
+		break;
+	}
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+
+	ccf = ((pll_in_khz / 1000 - 17)) * 4;
+	hsfreq = dppa_map_phy_141[i].hs_freq;
+
+	vco = dppa_map_phy_141[i].vco;
+	bias = 0x10;
+	int1 = 0x00;
+	gmp = 0x01;
+	prop = dppa_map_phy_141[i].prop;
+
+	/* set DLD, HSFR & CCF */
+	val = (hsfreq << 8) | ccf;
+	dsi_write(dsi, DSI_WPCR1, val);
+
+	val = ((ndiv - 2) << 4) | (idf - 1);
+	dsi_write(dsi, DSI_WRPCR0, val);
+
+	val = ((odf - 1) << 28) | (vco << 24) | (bias << 16) | (int1 << 8) | (gmp << 6) | prop;
+	dsi_write(dsi, DSI_WRPCR1, val);
+
+	dsi_write(dsi, DSI_PCTLR, PCTLR_CKEN);
+
+	dsi_update_bits(dsi, DSI_WRPCR2, WRPCR2_SEL, 0x01);
+
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_UPD);
+	mdelay(1);
+
+	dsi_clear(dsi, DSI_WRPCR2, WRPCR2_UPD);
+	mdelay(1);
+
+	dsi_set(dsi, DSI_PCTLR, PCTLR_PWEN | PCTLR_DEN);
+
+	ret = readl_poll_timeout(dsi->base + DSI_PSR, val, val & PSR_PSSC, TIMEOUT_US);
+	if (ret)
+		dev_err(dev, "!TIMEOUT! waiting PLL, let's continue\n");
+
+	dev_dbg(dev, "IDF %d ODF %d NDIV %d\n", idf, odf, ndiv);
+	dev_dbg(dev, "VCO %d BIAS %d INT %d GMP %d PROP %d\n", vco, bias, int1, gmp, prop);
+
+	dsi_set(dsi, DSI_WRPCR2, WRPCR2_PLLEN);
+
+	return 0;
+}
+
+static void dsi_phy_141_post_set_mode(void *priv_data, unsigned long mode_flags)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	struct stm32_dsi_priv *dsi = dev_get_priv(dev);
+
+	dev_dbg(dev, "Set mode %p enable %ld\n", dsi,
+		mode_flags & MIPI_DSI_MODE_VIDEO);
+
+	if (!dsi)
+		return;
+
+	/*
+	 * DSI wrapper must be enabled in video mode & disabled in command mode.
+	 * If wrapper is enabled in command mode, the display controller
+	 * register access will hang.
+	 */
+
+	if (mode_flags & MIPI_DSI_MODE_VIDEO)
+		dsi_set(dsi, DSI_WCR, WCR_DSIEN);
+	else
+		dsi_clear(dsi, DSI_WCR, WCR_DSIEN);
+}
+
+static int dsi_phy_141_get_lane_mbps(void *priv_data, struct display_timing *timings,
+				     u32 lanes, u32 format, unsigned int *lane_mbps)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	struct stm32_dsi_priv *dsi = dev_get_priv(dev);
+	int idf, ndiv, odf, pll_in_khz, pll_out_khz;
+	int bpp, i;
+
+	/* Update lane capabilities according to hw version */
+	dsi->lane_min_kbps = LANE_MIN_PHY_141_KBPS;
+	dsi->lane_max_kbps = LANE_MAX_PHY_141_KBPS;
+
+	pll_in_khz = dsi->pllref_clk / 1000;
+
+	/* Compute requested pll out */
+	bpp = mipi_dsi_pixel_format_to_bpp(format);
+	pll_out_khz = (timings->pixelclock.typ / 1000) * bpp / (lanes * 2);
+	/* Add 20% to pll out to be higher than pixel bw (burst mode only) */
+	pll_out_khz = (pll_out_khz * 12) / 10;
+	if (pll_out_khz > dsi->lane_max_kbps) {
+		pll_out_khz = dsi->lane_max_kbps;
+		dev_warn(dev, "Warning max phy mbps is used\n");
+	}
+	if (pll_out_khz < dsi->lane_min_kbps) {
+		pll_out_khz = dsi->lane_min_kbps;
+		dev_warn(dev, "Warning min phy mbps is used\n");
+	}
+
+	/* find frequency mapping */
+	for (i = 0; i < ARRAY_SIZE(dppa_map_phy_141); i++) {
+		if (dsi->lane_mbps < dppa_map_phy_141[i].data_rate) {
+			i--;
+			break;
+		}
+	}
+
+	switch (dppa_map_phy_141[i].odf) {
+	case(3):
+		odf = 8;
+		break;
+	case(2):
+		odf = 4;
+		break;
+	case(1):
+		odf = 2;
+		break;
+	default:
+		odf = 1;
+		break;
+	}
+
+	dsi_phy_141_pll_get_params(dsi, pll_in_khz, pll_out_khz, &idf, &ndiv, &odf);
+
+	/* Get the adjusted lane data rate value, lane data rate = 2 * pll output */
+	*lane_mbps = 2 * dsi_pll_get_clkout_khz(pll_in_khz, idf, ndiv, odf) / 1000;
+	dsi->lane_mbps = *lane_mbps;
+
+	dev_dbg(dev, "pll_in %ukHz pll_out %ukHz lane_mbps %uMHz\n",
+		pll_in_khz, pll_out_khz, *lane_mbps);
+
+	return 0;
+}
+
+static int dsi_phy_141_get_timing(void *priv_data, unsigned int lane_mbps,
+				  struct mipi_dsi_phy_timing *timing)
+{
+	struct mipi_dsi_device *device = priv_data;
+	struct udevice *dev = device->dev;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hstt_phy_141_table); i++)
+		if (lane_mbps < hstt_phy_141_table[i].maxfreq)
+			break;
+
+	if (i == ARRAY_SIZE(hstt_phy_141_table))
+		i--;
+
+	*timing = hstt_phy_141_table[i].timing;
+
+	dev_dbg(dev, "data hs2lp %d data lp2hs %d\n", timing->data_hs2lp, timing->data_lp2hs);
+	dev_dbg(dev, "data hs2lp %d data lp2hs %d\n", timing->clk_hs2lp, timing->clk_lp2hs);
+
+	return 0;
+}
+
+static const struct mipi_dsi_phy_ops dsi_stm_phy_141_ops = {
+	.init = dsi_phy_141_init,
+	.get_lane_mbps = dsi_phy_141_get_lane_mbps,
+	.post_set_mode = dsi_phy_141_post_set_mode,
+	.get_timing = dsi_phy_141_get_timing,
+};
+
+static int stm32_dsi_get_panel(struct udevice *dev, struct udevice **panel)
+{
+	ofnode ep_node, node, ports, remote;
+	u32 remote_phandle;
+	int ret = 0;
+
+	ports = ofnode_find_subnode(dev_ofnode(dev), "ports");
+	if (!ofnode_valid(ports)) {
+		dev_dbg(dev, "Remote bridge subnode\n");
+		return ret;
+	}
+
+	for (node = ofnode_first_subnode(ports);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ep_node = ofnode_first_subnode(node);
+		if (!ofnode_valid(ep_node))
+			continue;
+
+		ret = ofnode_read_u32(ep_node, "remote-endpoint", &remote_phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(remote_phandle);
+		if (!ofnode_valid(remote)) {
+			dev_dbg(dev, "%s(%s): Remote is not valid\n", __func__, dev_read_name(dev));
+			return -EINVAL;
+		}
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_DISPLAY for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				continue;
+			}
+
+			uclass_get_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel)
+				if (ofnode_valid(dev_ofnode(*panel)))
+					return 0;
+		}
+	}
+
+	/* Sanity check, we can get out of the loop without having a clean ofnode */
+	if (!(*panel))
+		ret = -EINVAL;
+
+	return ret;
+}
+
 static int stm32_dsi_attach(struct udevice *dev)
 {
 	struct stm32_dsi_priv *priv = dev_get_priv(dev);
@@ -346,13 +867,18 @@ static int stm32_dsi_attach(struct udevice *dev)
 	struct display_timing timings;
 	int ret;
 
-	ret = uclass_first_device(UCLASS_PANEL, &priv->panel);
+	ret = stm32_dsi_get_panel(dev, &priv->panel);
 	if (ret) {
-		dev_err(dev, "panel device error %d\n", ret);
+		dev_err(dev, "No panel found %d\n", ret);
 		return ret;
 	}
 
 	mplat = dev_get_plat(priv->panel);
+
+	/* check that the panel contains platform data */
+	if (!mplat)
+		return -EINVAL;
+
 	mplat->device = &priv->device;
 	device->lanes = mplat->lanes;
 	device->format = mplat->format;
@@ -374,11 +900,24 @@ static int stm32_dsi_attach(struct udevice *dev)
 		return ret;
 	}
 
-	ret = dsi_host_init(priv->dsi_host, device, &timings, 2,
-			    &dsi_stm_phy_ops);
-	if (ret) {
-		dev_err(dev, "failed to initialize mipi dsi host\n");
-		return ret;
+	if (priv->hw_version == HWVER_141 && IS_ENABLED(CONFIG_STM32MP25X)) {
+		ret = dsi_host_init(priv->dsi_host, device, &timings, 4,
+				    &dsi_stm_phy_141_ops);
+		if (ret) {
+			dev_err(dev, "failed to initialize mipi dsi host\n");
+			return ret;
+		}
+	} else if ((priv->hw_version == HWVER_131 || priv->hw_version == HWVER_130) &&
+		   IS_ENABLED(CONFIG_STM32MP15X)) {
+		ret = dsi_host_init(priv->dsi_host, device, &timings, 2,
+				    &dsi_stm_phy_ops);
+		if (ret) {
+			dev_err(dev, "failed to initialize mipi dsi host\n");
+			return ret;
+		}
+	} else {
+		dev_err(dev, "Hardware version not supported\n");
+		return -EINVAL;
 	}
 
 	return 0;
@@ -433,17 +972,47 @@ static int stm32_dsi_probe(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	ret =  device_get_supply_regulator(dev, "phy-dsi-supply",
-					   &priv->vdd_reg);
-	if (ret && ret != -ENOENT) {
-		dev_err(dev, "Warning: cannot get phy dsi supply\n");
-		return -ENODEV;
+	if (device_is_compatible(dev, "st,stm32-dsi")) {
+		ret =  device_get_supply_regulator(dev, "phy-dsi-supply",
+						   &priv->vdd_reg);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Warning: cannot get phy dsi supply\n");
+			return -ENODEV;
+		}
+
+		if (ret != -ENOENT) {
+			ret = regulator_set_enable(priv->vdd_reg, true);
+			if (ret)
+				return ret;
+		}
 	}
 
-	if (ret != -ENOENT) {
-		ret = regulator_set_enable(priv->vdd_reg, true);
-		if (ret)
+	if (device_is_compatible(dev, "st,stm32mp25-dsi")) {
+		ret =  device_get_supply_regulator(dev, "vdd-supply",
+						   &priv->vdd_reg);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Warning: cannot get phy dsi supply\n");
+			return -ENODEV;
+		}
+
+		if (ret != -ENOENT) {
+			ret = regulator_set_enable(priv->vdd_reg, true);
+			if (ret)
+				return ret;
+		}
+
+		ret =  device_get_supply_regulator(dev, "vdda18",
+						   &priv->vdda18_reg);
+		if (ret && ret != -ENOENT) {
+			dev_err(dev, "Warning: cannot get vdda18 supply\n");
 			return ret;
+		}
+
+		if (ret != -ENOENT) {
+			ret = regulator_set_enable(priv->vdda18_reg, true);
+			if (ret)
+				return ret;
+		}
 	}
 
 	ret = clk_get_by_name(device->dev, "pclk", &clk);
@@ -478,7 +1047,8 @@ static int stm32_dsi_probe(struct udevice *dev)
 	/* check hardware version */
 	priv->hw_version = dsi_read(priv, DSI_VERSION) & VERSION;
 	if (priv->hw_version != HWVER_130 &&
-	    priv->hw_version != HWVER_131) {
+	    priv->hw_version != HWVER_131 &&
+	    priv->hw_version != HWVER_141) {
 		dev_err(dev, "DSI version 0x%x not supported\n", priv->hw_version);
 		dev_dbg(dev, "remove and unbind all DSI child\n");
 		device_chld_remove(dev, NULL, DM_REMOVE_NORMAL);
@@ -491,6 +1061,7 @@ static int stm32_dsi_probe(struct udevice *dev)
 err_clk:
 	clk_disable(&clk);
 err_reg:
+	regulator_set_enable(priv->vdda18_reg, false);
 	regulator_set_enable(priv->vdd_reg, false);
 
 	return ret;
@@ -503,6 +1074,7 @@ struct video_bridge_ops stm32_dsi_ops = {
 
 static const struct udevice_id stm32_dsi_ids[] = {
 	{ .compatible = "st,stm32-dsi"},
+	{ .compatible = "st,stm32mp25-dsi"},
 	{ }
 };
 
diff --git a/drivers/video/stm32/stm32_ltdc.c b/drivers/video/stm32/stm32_ltdc.c
index 58b6434a48..88e58aa379 100644
--- a/drivers/video/stm32/stm32_ltdc.c
+++ b/drivers/video/stm32/stm32_ltdc.c
@@ -4,7 +4,6 @@
  * Author(s): Philippe Cornu <philippe.cornu@st.com> for STMicroelectronics.
  *	      Yannick Fertre <yannick.fertre@st.com> for STMicroelectronics.
  */
-
 #define LOG_CATEGORY UCLASS_VIDEO
 
 #include <common.h>
@@ -13,12 +12,16 @@
 #include <dm.h>
 #include <log.h>
 #include <panel.h>
+#include <regmap.h>
 #include <reset.h>
+#include <syscon.h>
 #include <video.h>
 #include <video_bridge.h>
 #include <asm/io.h>
 #include <dm/device-internal.h>
+#include <dm/uclass-internal.h>
 #include <dm/device_compat.h>
+#include <dm/pinctrl.h>
 #include <linux/bitops.h>
 
 struct stm32_ltdc_priv {
@@ -262,6 +265,11 @@ static const u32 layer_regs_a2[] = {
 #define HWVER_10300 0x010300
 #define HWVER_20101 0x020101
 #define HWVER_40100 0x040100
+#define HWVER_40101 0x040101
+
+#define SYSCFG_DISPLAYCLKCR 0x5000
+#define DISPLAYCLKCR_LVDS	0x01
+#define DISPLAYCLKCR_DPI	0x02
 
 enum stm32_ltdc_pix_fmt {
 	PF_ARGB8888 = 0,	/* ARGB [32 bits] */
@@ -494,6 +502,135 @@ static void stm32_ltdc_set_layer1(struct stm32_ltdc_priv *priv, ulong fb_addr)
 	setbits_le32(priv->regs + LTDC_L1CR, LXCR_LEN);
 }
 
+static int stm32_ltdc_get_panel(struct udevice *dev, struct udevice **panel)
+{
+	ofnode ep_node, node, ports, remote;
+	u32 remote_phandle;
+	int ret = 0;
+
+	if (!dev)
+		return -EINVAL;
+
+	ports = ofnode_find_subnode(dev_ofnode(dev), "ports");
+	if (!ofnode_valid(ports)) {
+		dev_err(dev, "Remote bridge subnode\n");
+		return ret;
+	}
+
+	for (node = ofnode_first_subnode(ports);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ep_node = ofnode_first_subnode(node);
+		if (!ofnode_valid(ep_node))
+			continue;
+
+		ret = ofnode_read_u32(ep_node, "remote-endpoint", &remote_phandle);
+		if (ret) {
+			dev_err(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(remote_phandle);
+		if (!ofnode_valid(remote))
+			return -EINVAL;
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_DISPLAY for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				continue;
+			}
+
+			uclass_find_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel)
+				if (ofnode_valid(dev_ofnode(*panel)))
+					return 0;
+		};
+	}
+
+	/* Sanity check, we can get out of the loop without having a clean ofnode */
+	if (!(*panel))
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static int stm32_ltdc_display_init(struct udevice *dev, ofnode *ep_node,
+				   struct udevice **panel, struct udevice **bridge)
+{
+	ofnode remote;
+	u32 remote_phandle;
+	int ret;
+
+	if (*panel)
+		return -EINVAL;
+
+	if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
+		ret = ofnode_read_u32(*ep_node, "remote-endpoint", &remote_phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(remote_phandle);
+		if (!ofnode_valid(remote))
+			return -EINVAL;
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_VIDEO_BRIDGE for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				return -EINVAL;
+			}
+
+			uclass_find_device_by_ofnode(UCLASS_VIDEO_BRIDGE, remote, bridge);
+			if (*bridge && !ret) {
+				ret = uclass_get_device_by_ofnode(UCLASS_VIDEO_BRIDGE,
+								  remote, bridge);
+				if (ret)
+					dev_dbg(dev,
+						"No video bridge, or no backlight on bridge\n");
+				break;
+			}
+		}
+
+		ret = stm32_ltdc_get_panel(*bridge, panel);
+	} else {
+		/* no bridge , search a panel from display controller node */
+		ret = ofnode_read_u32(*ep_node, "remote-endpoint", &remote_phandle);
+		if (ret) {
+			dev_dbg(dev, "%s(%s): Could not find remote-endpoint property\n",
+				__func__, dev_read_name(dev));
+			return ret;
+		}
+
+		remote = ofnode_get_by_phandle(remote_phandle);
+		if (!ofnode_valid(remote))
+			return -EINVAL;
+
+		while (ofnode_valid(remote)) {
+			remote = ofnode_get_parent(remote);
+			if (!ofnode_valid(remote)) {
+				dev_dbg(dev, "%s(%s): no UCLASS_VIDEO_BRIDGE for remote-endpoint\n",
+					__func__, dev_read_name(dev));
+				return -EINVAL;
+			}
+
+			ret = uclass_find_device_by_ofnode(UCLASS_PANEL, remote, panel);
+			if (*panel && !ret) {
+				ret = uclass_get_device_by_ofnode(UCLASS_PANEL, remote, panel);
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
 static int stm32_ltdc_probe(struct udevice *dev)
 {
 	struct video_uc_plat *uc_plat = dev_get_uclass_plat(dev);
@@ -502,18 +639,54 @@ static int stm32_ltdc_probe(struct udevice *dev)
 	struct udevice *bridge = NULL;
 	struct udevice *panel = NULL;
 	struct display_timing timings;
-	struct clk pclk;
+	struct clk pclk, bclk;
 	struct reset_ctl rst;
+	struct regmap *regmap = NULL;
+	struct udevice *syscon;
+	ofnode node, port;
 	ulong rate;
 	int ret;
 
+	if (IS_ENABLED(CONFIG_SYSCON) && IS_ENABLED(CONFIG_STM32MP25X)) {
+		ret = uclass_get_device_by_phandle(UCLASS_SYSCON, dev, "st,syscon", &syscon);
+		if (ret) {
+			if (ret != -ENOENT) {
+				dev_err(dev, "unable to find syscon device\n");
+				return ret;
+			}
+		} else {
+			regmap = syscon_get_regmap(syscon);
+			if (IS_ERR(regmap)) {
+				dev_err(dev, "Fail to get Syscon regmap\n");
+				return PTR_ERR(regmap);
+			}
+
+			/* Set default pixel clock to enable register access */
+			regmap_write(regmap, SYSCFG_DISPLAYCLKCR, DISPLAYCLKCR_DPI);
+		}
+	}
+
 	priv->regs = (void *)dev_read_addr(dev);
 	if ((fdt_addr_t)priv->regs == FDT_ADDR_T_NONE) {
 		dev_err(dev, "ltdc dt register address error\n");
 		return -EINVAL;
 	}
 
-	ret = clk_get_by_index(dev, 0, &pclk);
+	ret = clk_get_by_name(dev, "bus", &bclk);
+	if (ret) {
+		if (ret != -ENODATA) {
+			dev_err(dev, "bus clock get error %d\n", ret);
+			return ret;
+		}
+	} else {
+		ret = clk_enable(&bclk);
+		if (ret) {
+			dev_err(dev, "bus clock enable error %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = clk_get_by_name(dev, "lcd", &pclk);
 	if (ret) {
 		dev_err(dev, "peripheral clock get error %d\n", ret);
 		return ret;
@@ -526,7 +699,7 @@ static int stm32_ltdc_probe(struct udevice *dev)
 	}
 
 	priv->hw_version = readl(priv->regs + LTDC_IDR);
-	debug("%s: LTDC hardware 0x%x\n", __func__, priv->hw_version);
+	dev_dbg(dev, "%s: LTDC hardware 0x%x\n", __func__, priv->hw_version);
 
 	switch (priv->hw_version) {
 	case HWVER_10200:
@@ -539,6 +712,7 @@ static int stm32_ltdc_probe(struct udevice *dev)
 		priv->pix_fmt_hw = pix_fmt_a1;
 		break;
 	case HWVER_40100:
+	case HWVER_40101:
 		priv->layer_regs = layer_regs_a2;
 		priv->pix_fmt_hw = pix_fmt_a2;
 		break;
@@ -546,13 +720,37 @@ static int stm32_ltdc_probe(struct udevice *dev)
 		return -ENODEV;
 	}
 
-	ret = uclass_first_device_err(UCLASS_PANEL, &panel);
-	if (ret) {
-		if (ret != -ENODEV)
-			dev_err(dev, "panel device error %d\n", ret);
-		return ret;
+	/*
+	 * Try all the ports until one working.
+	 *
+	 * This means that it will search first for the DSI node
+	 * and then for the LVDS.
+	 * This is done in two times. First is checks for the
+	 * UCLASS_VIDEO_BRIDGE available, and then for this bridge
+	 * it scans for a UCLASS_PANEL.
+	 */
+
+	port = dev_read_subnode(dev, "port");
+	if (!ofnode_valid(port)) {
+		dev_err(dev, "%s(%s): 'port' subnode not found\n",
+			__func__, dev_read_name(dev));
+		return -EINVAL;
+	}
+
+	for (node = ofnode_first_subnode(port);
+	     ofnode_valid(node);
+	     node = dev_read_next_subnode(node)) {
+		ret = stm32_ltdc_display_init(dev, &node, &panel, &bridge);
+		if (ret)
+			dev_dbg(dev, "Device failed ret=%d\n", ret);
+		else
+			break;
 	}
 
+	/* Sanity check */
+	if (ret)
+		return ret;
+
 	ret = panel_get_display_timing(panel, &timings);
 	if (ret) {
 		ret = ofnode_decode_display_timing(dev_ofnode(panel),
@@ -581,17 +779,22 @@ static int stm32_ltdc_probe(struct udevice *dev)
 	reset_deassert(&rst);
 
 	if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
-		ret = uclass_get_device(UCLASS_VIDEO_BRIDGE, 0, &bridge);
-		if (ret)
-			dev_dbg(dev,
-				"No video bridge, or no backlight on bridge\n");
-
 		if (bridge) {
+			/* Set the pixel clock according to the encoder */
+			if (IS_ENABLED(CONFIG_SYSCON) && IS_ENABLED(CONFIG_STM32MP25X)) {
+				if (!strncmp(bridge->name, "lvds", 4))
+					regmap_write(regmap, SYSCFG_DISPLAYCLKCR,
+						     DISPLAYCLKCR_LVDS);
+			}
+
 			ret = video_bridge_attach(bridge);
 			if (ret) {
-				dev_err(bridge, "fail to attach bridge\n");
+				dev_dbg(bridge, "fail to attach bridge\n");
 				return ret;
 			}
+
+			/* set state the pinctrl to sleep to avoid noise */
+			pinctrl_select_state(dev, "sleep");
 		}
 	}
 
@@ -657,6 +860,7 @@ static int stm32_ltdc_bind(struct udevice *dev)
 
 static const struct udevice_id stm32_ltdc_ids[] = {
 	{ .compatible = "st,stm32-ltdc" },
+	{ .compatible = "st,stm32mp25-ltdc" },
 	{ }
 };
 
diff --git a/drivers/video/stm32/stm32_lvds.c b/drivers/video/stm32/stm32_lvds.c
new file mode 100644
index 0000000000..b0ccd4db04
--- /dev/null
+++ b/drivers/video/stm32/stm32_lvds.c
@@ -0,0 +1,706 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2023 STMicroelectronics - All Rights Reserved
+ * Author(s): Raphaël Gallais-Pou <raphael.gallais-pou@foss.st.com> for STMicroelectronics.
+ *
+ * This Low Voltage Differential Signal controller driver is based on the Linux Kernel driver from
+ * drivers/gpu/drm/stm/ltdc.c
+ */
+
+#define LOG_CATEGORY UCLASS_VIDEO_BRIDGE
+
+#include <common.h>
+#include <clk.h>
+#include <dm.h>
+#include <log.h>
+#include <media_bus_format.h>
+#include <panel.h>
+#include <reset.h>
+#include <video.h>
+#include <video_bridge.h>
+#include <asm/io.h>
+#include <dm/device_compat.h>
+#include <dm/ofnode.h>
+#include <linux/iopoll.h>
+#include <power/regulator.h>
+
+/* LVDS Host registers */
+#define LVDS_CR		0x0000  /* configuration register */
+#define LVDS_DMLCR0	0x0004  /* data mapping lsb configuration register 0	*/
+#define LVDS_DMMCR0	0x0008  /* data mapping msb configuration register 0	*/
+#define LVDS_DMLCR1	0x000C  /* data mapping lsb configuration register 1	*/
+#define LVDS_DMMCR1	0x0010  /* data mapping msb configuration register 1	*/
+#define LVDS_DMLCR2	0x0014  /* data mapping lsb configuration register 2	*/
+#define LVDS_DMMCR2	0x0018  /* data mapping msb configuration register 2	*/
+#define LVDS_DMLCR3	0x001C  /* data mapping lsb configuration register 3	*/
+#define LVDS_DMMCR3	0x0020  /* data mapping msb configuration register 3	*/
+#define LVDS_DMLCR4	0x0024  /* data mapping lsb configuration register 4	*/
+#define LVDS_DMMCR4	0x0028  /* data mapping msb configuration register 4	*/
+#define LVDS_DMLCR(id)	(LVDS_DMLCR0 + 8U * (id))
+#define LVDS_DMMCR(id)	(LVDS_DMMCR0 + 8U * (id))
+#define LVDS_CDL1CR	0x002C  /* channel distrib link 1 configuration register	*/
+#define LVDS_CDL2CR	0x0030  /* channel distrib link 2 configuration register	*/
+
+#define CDL1CR_DEFAULT	0x4321
+#define CDL2CR_DEFAULT	0x59876
+
+/* LVDS Host registers */
+#define LVDS_PHY_MASTER	0x0
+#define LVDS_PHY_SLAVE	0x100
+
+/* phy parameter can only be one of those two above */
+#define LVDS_PxGCR(phy)		((phy) + 0x1000)   /* Global Control Register	*/
+#define LVDS_PxCMCR1(phy)	((phy) + 0x100C)   /* Current Mode Control Register 1 */
+#define LVDS_PxCMCR2(phy)	((phy) + 0x1010)  /* Current Mode Control Register 2 */
+#define LVDS_PxSCR(phy)		((phy) + 0x1020)  /* Serial Control Register	*/
+#define LVDS_PxBCR1(phy)	((phy) + 0x102C)  /* Bias Control Register 1	*/
+#define LVDS_PxBCR2(phy)	((phy) + 0x1030)  /* Bias Control Register 2	*/
+#define LVDS_PxBCR3(phy)	((phy) + 0x1034)  /* Bias Control Register 3	*/
+#define LVDS_PxMPLCR(phy)	((phy) + 0x1064)  /* Monitor PLL Lock Control Register */
+#define LVDS_PxDCR(phy)		((phy) + 0x1084)  /* Debug Control Register	*/
+#define LVDS_PxSSR1(phy)	((phy) + 0x1088)  /* Spare Status Register 1	*/
+#define LVDS_PxCFGCR(phy)	((phy) + 0x10A0)  /* Configuration Control Register */
+#define LVDS_PxPLLCR1(phy)	((phy) + 0x10C0)  /* PLL_MODE 1 Control Register	*/
+#define LVDS_PxPLLCR2(phy)	((phy) + 0x10C4)  /* PLL_MODE 2 Control Register	*/
+#define LVDS_PxPLLSR(phy)	((phy) + 0x10C8)  /* PLL Status Register	*/
+#define LVDS_PxPLLSDCR1(phy)	((phy) + 0x10CC)  /* PLL_SD_1 Control Register	*/
+#define LVDS_PxPLLSDCR2(phy)	((phy) + 0x10D0)  /* PLL_SD_2 Control Register	*/
+#define LVDS_PxPLLTWGCR1(phy)	((phy) + 0x10D4)  /* PLL_TWG_1 Control Register	*/
+#define LVDS_PxPLLTWGCR2(phy)	((phy) + 0x10D8)  /* PLL_TWG_2 Control Register	*/
+#define LVDS_PxPLLCPCR(phy)	((phy) + 0x10E0)  /* PLL_CP Control Register	*/
+#define LVDS_PxPLLTESTCR(phy)	((phy) + 0x10E8)  /* PLL_TEST Control Register	*/
+
+/* LVDS Wrapper registers */
+#define LVDS_WCLKCR	0x11B0  /* Wrapper clock control register */
+#define LVDS_HWCFGR	0x1FF0  /* HW configuration register	*/
+#define LVDS_VERR	0x1FF4  /* Version register	*/
+#define LVDS_IPIDR	0x1FF8  /* Identification register	*/
+#define LVDS_SIDR	0x1FFC  /* Size Identification register	*/
+
+#define CR_LVDSEN	BIT(0)  /* LVDS PHY Enable */
+#define CR_HSPOL	BIT(1)  /* HS Polarity (horizontal sync) */
+#define CR_VSPOL	BIT(2)  /* VS Polarity (vertical sync) */
+#define CR_DEPOL	BIT(3)  /* DE Polarity (data enable) */
+#define CR_CI		BIT(4)  /* Control Internal (software controlled bit) */
+#define CR_LKMOD	BIT(5)  /* Link Mode, for both Links */
+#define CR_LKPHA	BIT(6)  /* Link Phase, for both Links */
+#define CR_LK1POL	GENMASK(20, 16)  /* Link-1 output Polarity */
+#define CR_LK2POL	GENMASK(25, 21)  /* Link-2 output Polarity */
+
+#define DMMCRx_MAP0	GENMASK(4, 0)
+#define DMMCRx_MAP1	GENMASK(9, 5)
+#define DMMCRx_MAP2	GENMASK(14, 10)
+#define DMMCRx_MAP3	GENMASK(19, 15)
+#define DMLCRx_MAP4	GENMASK(4, 0)
+#define DMLCRx_MAP5	GENMASK(9, 5)
+#define DMLCRx_MAP6	GENMASK(14, 10)
+
+#define CDLCRx_DISTR0	GENMASK(3, 0)
+#define CDLCRx_DISTR1	GENMASK(7, 4)
+#define CDLCRx_DISTR2	GENMASK(11, 8)
+#define CDLCRx_DISTR3	GENMASK(15, 12)
+#define CDLCRx_DISTR4	GENMASK(19, 16)
+
+#define FREF_INDEX	0
+#define NDIV_INDEX	1
+#define FPFD_INDEX	2
+#define MDIV_INDEX	3
+#define FVCO_INDEX	4
+#define BDIV_INDEX	5
+#define FBIT_INDEX	6
+#define FLS_INDEX	7
+#define FDP_INDEX	8
+
+#define PHY_GCR_BIT_CLK_OUT	BIT(0)
+#define PHY_GCR_LS_CLK_OUT	BIT(4)
+#define PHY_GCR_DP_CLK_OUT	BIT(8)
+#define PHY_GCR_RSTZ		BIT(24)
+#define PHY_GCR_DIV_RSTN	BIT(25)
+
+#define PHY_PxPLLTESTCR_TDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_NDIV	GENMASK(25, 16)
+#define PHY_PxPLLCR2_BDIV	GENMASK(9, 0)
+#define PHY_PxPLLSDCR1_MDIV	GENMASK(9, 0)
+
+#define PLL_EN		BIT(0)
+#define PLL_LOCK	BIT(0)
+#define CM_EN_DL	(BIT(28) | BIT(20) | BIT(12) | BIT(4))
+#define CM_EN_DL4	BIT(4)
+#define VM_EN_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_BIAS_DL	(BIT(16) | BIT(12) | BIT(8) | BIT(4) | BIT(0))
+#define EN_DIG_DL	GENMASK(4, 0)
+#define BIAS_EN		BIT(28)
+#define POWER_OK	BIT(12)
+
+#define WCLKCR_SLV_CLKPIX_SEL	BIT(0)
+#define WCLKCR_SRCSEL		BIT(8)
+
+/* Sleep & timeout for pll lock/unlock */
+#define SLEEP_US	1000
+#define TIMEOUT_US	20000000
+
+#define PHY_SLV_OFS	0x100
+
+struct stm32_lvds {
+	void __iomem *base;
+	struct udevice *panel;
+	u32 refclk;
+	int dual_link;
+	int bus_format;
+	struct udevice *vdd_reg;
+	struct udevice *vdda18_reg;
+};
+
+/*
+ * enum lvds_pixels_order - Pixel order of an LVDS connection
+ * @LVDS_DUAL_LINK_EVEN_ODD_PIXELS: Even pixels are expected to be generated
+ *    from the first port, odd pixels from the second port
+ * @LVDS_DUAL_LINK_ODD_EVEN_PIXELS: Odd pixels are expected to be generated
+ *    from the first port, even pixels from the second port
+ */
+enum lvds_pixels_order {
+	LVDS_DUAL_LINK_EVEN_ODD_PIXELS = BIT(0),
+	LVDS_DUAL_LINK_ODD_EVEN_PIXELS = BIT(1),
+};
+
+enum lvds_pixel {
+	PIX_R_0		= 0x00,
+	PIX_R_1		= 0x01,
+	PIX_R_2		= 0x02,
+	PIX_R_3		= 0x03,
+	PIX_R_4		= 0x04,
+	PIX_R_5		= 0x05,
+	PIX_R_6		= 0x06,
+	PIX_R_7		= 0x07,
+	PIX_G_0		= 0x08,
+	PIX_G_1		= 0x09,
+	PIX_G_2		= 0x0A,
+	PIX_G_3		= 0x0B,
+	PIX_G_4		= 0x0C,
+	PIX_G_5		= 0x0D,
+	PIX_G_6		= 0x0E,
+	PIX_G_7		= 0x0F,
+	PIX_B_0		= 0x10,
+	PIX_B_1		= 0x11,
+	PIX_B_2		= 0x12,
+	PIX_B_3		= 0x13,
+	PIX_B_4		= 0x14,
+	PIX_B_5		= 0x15,
+	PIX_B_6		= 0x16,
+	PIX_B_7		= 0x17,
+	PIX_H_S		= 0x18,
+	PIX_V_S		= 0x19,
+	PIX_D_E		= 0x1A,
+	PIX_C_E		= 0x1B,
+	PIX_C_I		= 0x1C,
+	PIX_TOG		= 0x1D,
+	PIX_ONE		= 0x1E,
+	PIX_ZER		= 0x1F,
+};
+
+/*
+ * Expected JEIDA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ */
+const enum lvds_pixel lvds_bitmap_jeida_rgb888[5][7] = {
+	{ PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE },
+	{ PIX_G_2, PIX_R_7, PIX_R_6, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2 },
+	{ PIX_B_3, PIX_B_2, PIX_G_7, PIX_G_6, PIX_G_5, PIX_G_4, PIX_G_3 },
+	{ PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_7, PIX_B_6, PIX_B_5, PIX_B_4 },
+	{ PIX_C_E, PIX_B_1, PIX_B_0, PIX_G_1, PIX_G_0, PIX_R_1, PIX_R_0 }
+};
+
+/*
+ * Expected VESA-RGB888 data to be sent in LSB format
+ *	    bit6 ............................bit0
+ */
+const enum lvds_pixel lvds_bitmap_vesa_rgb888[5][7] = {
+	{ PIX_ONE, PIX_ONE, PIX_ZER, PIX_ZER, PIX_ZER, PIX_ONE, PIX_ONE },
+	{ PIX_G_0, PIX_R_5, PIX_R_4, PIX_R_3, PIX_R_2, PIX_R_1, PIX_R_0 },
+	{ PIX_B_1, PIX_B_0, PIX_G_5, PIX_G_4, PIX_G_3, PIX_G_2, PIX_G_1 },
+	{ PIX_D_E, PIX_V_S, PIX_H_S, PIX_B_5, PIX_B_4, PIX_B_3, PIX_B_2 },
+	{ PIX_C_E, PIX_B_7, PIX_B_6, PIX_G_7, PIX_G_6, PIX_R_7, PIX_R_6 }
+};
+
+static inline void lvds_writel(struct stm32_lvds *lvds, u32 reg, u32 val)
+{
+	writel(val, lvds->base + reg);
+}
+
+static inline u32 lvds_readl(struct stm32_lvds *lvds, u32 reg)
+{
+	return readl(lvds->base + reg);
+}
+
+static inline void lvds_set(struct stm32_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_writel(lvds, reg, lvds_readl(lvds, reg) | mask);
+}
+
+static inline void lvds_clear(struct stm32_lvds *lvds, u32 reg, u32 mask)
+{
+	lvds_writel(lvds, reg, lvds_readl(lvds, reg) & ~mask);
+}
+
+/* Integer mode */
+#define EN_SD		0
+#define EN_TWG		0
+#define DOWN_SPREAD	0
+#define TEST_DIV	70
+
+static u32 pll_get_clkout_khz(u32 clkin_khz, u32 bdiv, u32 mdiv, u32 ndiv)
+{
+	int divisor = ndiv * bdiv;
+
+	/* Prevents from division by 0 */
+	if (!divisor)
+		return 0;
+
+	return clkin_khz * mdiv / divisor;
+}
+
+#define NDIV_MIN	2
+#define NDIV_MAX	6
+#define BDIV_MIN	2
+#define BDIV_MAX	6
+#define MDIV_MIN	1
+#define MDIV_MAX	1023
+
+static int lvds_pll_get_params(u32 clkin_khz, u32 clkout_khz,
+			       u32 *bdiv, u32 *mdiv, u32 *ndiv)
+{
+	u32 i, o, n;
+	u32 delta, best_delta; /* all in khz */
+
+	/* Early checks preventing division by 0 & odd results */
+	if (clkin_khz <= 0 || clkout_khz <= 0)
+		return -EINVAL;
+
+	best_delta = 1000000; /* big started value (1000000khz) */
+
+	for (i = NDIV_MIN; i <= NDIV_MAX; i++) {
+		for (o = BDIV_MIN; o <= BDIV_MAX; o++) {
+			n = DIV_ROUND_CLOSEST(i * o * clkout_khz, clkin_khz);
+			/* Check ndiv according to vco range */
+			if (n < MDIV_MIN || n > MDIV_MAX)
+				continue;
+			/* Check if new delta is better & saves parameters */
+			delta = abs(pll_get_clkout_khz(clkin_khz, i, n, o) - clkout_khz);
+			if (delta < best_delta) {
+				*ndiv = i;
+				*mdiv = n;
+				*bdiv = o;
+				best_delta = delta;
+			}
+			/* fast return in case of "perfect result" */
+			if (!delta)
+				return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int stm32_lvds_pll_enable(struct stm32_lvds *lvds,
+				 struct display_timing *timings,
+				 int phy)
+{
+	u32 pll_in_khz, bdiv = 0, mdiv = 0, ndiv = 0;
+	int ret, val, multiplier;
+
+	/* Release PHY from reset */
+	lvds_set(lvds, LVDS_PxGCR(phy), PHY_GCR_DIV_RSTN | PHY_GCR_RSTZ);
+
+	/* lvds_pll_config */
+	/* Set PLL Slv & Mst configs and timings */
+	pll_in_khz = lvds->refclk / 1000;
+
+	if (lvds->dual_link)
+		multiplier = 2;
+	else
+		multiplier = 1;
+
+	ret = lvds_pll_get_params(pll_in_khz, timings->pixelclock.typ * 7 / 1000 / multiplier,
+				  &bdiv, &mdiv, &ndiv);
+	if (ret)
+		return ret;
+
+	/* Set PLL parameters */
+	lvds_writel(lvds, LVDS_PxPLLCR2(phy), (ndiv << 16) | bdiv);
+	lvds_writel(lvds, LVDS_PxPLLSDCR1(phy), mdiv);
+	lvds_writel(lvds, LVDS_PxPLLTESTCR(phy), TEST_DIV << 16);
+
+	/* Disable TWG and SD: for now, PLL just need to be in integer mode */
+	lvds_clear(lvds, LVDS_PxPLLCR1(phy), EN_TWG | EN_SD);
+
+	/* Power up bias and PLL dividers */
+	lvds_set(lvds, LVDS_PxDCR(phy), POWER_OK);
+
+	lvds_set(lvds, LVDS_PxCMCR1(phy), CM_EN_DL);
+	lvds_set(lvds, LVDS_PxCMCR2(phy), CM_EN_DL4);
+
+	lvds_set(lvds, LVDS_PxPLLCPCR(phy), 0x1);
+	lvds_set(lvds, LVDS_PxBCR3(phy), VM_EN_DL);
+	lvds_set(lvds, LVDS_PxBCR1(phy), EN_BIAS_DL);
+	lvds_set(lvds, LVDS_PxCFGCR(phy), EN_DIG_DL);
+
+	/* lvds_pll_enable */
+	/* PLL lock timing control for the monitor unmask after startup (pll_en) */
+	/* Adjust the value so that the masking window is opened at start-up */
+	/* MST_MON_PLL_LOCK_UNMASK_TUNE */
+	lvds_writel(lvds, LVDS_PxMPLCR(phy), (0x200 - 0x160) << 16);
+
+	lvds_writel(lvds, LVDS_PxBCR2(phy), BIAS_EN);
+
+	lvds_set(lvds, LVDS_PxGCR(phy),
+		 PHY_GCR_DP_CLK_OUT | PHY_GCR_LS_CLK_OUT | PHY_GCR_BIT_CLK_OUT);
+
+	/* TODO hardcoded values for now */
+	lvds_set(lvds, LVDS_PxPLLTESTCR(phy), BIT(8) /* PLL_TEST_DIV_EN */);
+	lvds_set(lvds, LVDS_PxPLLCR1(phy), BIT(8) /* PLL_DIVIDERS_ENABLE */);
+
+	lvds_set(lvds, LVDS_PxSCR(phy), BIT(16) /* SER_DATA_OK */);
+
+	/* Enable the LVDS PLL & wait for its lock */
+	lvds_set(lvds, LVDS_PxPLLCR1(phy), PLL_EN);
+	ret = readl_poll_sleep_timeout(lvds->base + LVDS_PxPLLSR(phy),
+				       val, val & PLL_LOCK, SLEEP_US, TIMEOUT_US);
+	if (ret)
+		return ret;
+
+	/* Select MST PHY clock as pixel clock for the LDITX instead of FREF */
+	/* WCLKCR_SLV_CLKPIX_SEL is for dual link */
+	lvds_writel(lvds, LVDS_WCLKCR, WCLKCR_SLV_CLKPIX_SEL);
+
+	lvds_set(lvds, LVDS_PxPLLTESTCR(phy), BIT(0));
+
+	return 0;
+}
+
+static int stm32_lvds_enable(struct udevice *dev,
+			     const struct display_timing *timings)
+{
+	struct stm32_lvds *lvds = dev_get_priv(dev);
+	u32 lvds_cdl1cr = 0;
+	u32 lvds_cdl2cr = 0;
+	u32 lvds_dmlcr = 0;
+	u32 lvds_dmmcr = 0;
+	u32 lvds_cr = 0;
+	int i;
+
+	lvds_clear(lvds, LVDS_CDL1CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+	lvds_clear(lvds, LVDS_CDL2CR, CDLCRx_DISTR0 | CDLCRx_DISTR1 | CDLCRx_DISTR2
+					| CDLCRx_DISTR3 | CDLCRx_DISTR4);
+
+	/* Set channel distribution */
+	lvds_cr &= ~CR_LKMOD;
+	lvds_cdl1cr = CDL1CR_DEFAULT;
+
+	if (lvds->dual_link) {
+		lvds_cr |= CR_LKMOD;
+		lvds_cdl2cr = CDL2CR_DEFAULT;
+	}
+
+	/* Set signal polarity */
+	if (timings->flags & DISPLAY_FLAGS_DE_LOW)
+		lvds_cr |= CR_DEPOL;
+
+	if (timings->flags & DISPLAY_FLAGS_HSYNC_LOW)
+		lvds_cr |= CR_HSPOL;
+
+	if (timings->flags & DISPLAY_FLAGS_VSYNC_LOW)
+		lvds_cr |= CR_VSPOL;
+
+	/* Set link phase */
+	switch (lvds->dual_link) {
+	case LVDS_DUAL_LINK_EVEN_ODD_PIXELS: /* LKPHA = 0 */
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	case LVDS_DUAL_LINK_ODD_EVEN_PIXELS: /* LKPHA = 1 */
+		lvds_cr |= CR_LKPHA;
+		break;
+	default:
+		dev_dbg(dev, "No phase precised, setting default\n");
+		lvds_cr &= ~CR_LKPHA;
+		break;
+	}
+
+	/* Set Data Mapping */
+	switch (lvds->bus_format) {
+	case MEDIA_BUS_FMT_RGB888_1X7X4_SPWG: /* VESA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr = ((lvds_bitmap_vesa_rgb888[i][0])
+				      + (lvds_bitmap_vesa_rgb888[i][1] << 5)
+				      + (lvds_bitmap_vesa_rgb888[i][2] << 10)
+				      + (lvds_bitmap_vesa_rgb888[i][3] << 15));
+			lvds_dmmcr = ((lvds_bitmap_vesa_rgb888[i][4])
+				      + (lvds_bitmap_vesa_rgb888[i][5] << 5)
+				      + (lvds_bitmap_vesa_rgb888[i][6] << 10));
+
+			/* Write registers at the end of computations */
+			lvds_writel(lvds, LVDS_DMLCR(i), lvds_dmlcr);
+			lvds_writel(lvds, LVDS_DMMCR(i), lvds_dmmcr);
+		}
+		break;
+	case MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA: /* JEIDA-RGB888 */
+		for (i = 0; i < 5; i++) {
+			lvds_dmlcr = ((lvds_bitmap_jeida_rgb888[i][0])
+				      + (lvds_bitmap_jeida_rgb888[i][1] << 5)
+				      + (lvds_bitmap_jeida_rgb888[i][2] << 10)
+				      + (lvds_bitmap_jeida_rgb888[i][3] << 15));
+			lvds_dmmcr = ((lvds_bitmap_jeida_rgb888[i][4])
+				      + (lvds_bitmap_jeida_rgb888[i][5] << 5)
+				      + (lvds_bitmap_jeida_rgb888[i][6] << 10));
+
+			/* Write registers at the end of computations */
+			lvds_writel(lvds, LVDS_DMLCR(i), lvds_dmlcr);
+			lvds_writel(lvds, LVDS_DMMCR(i), lvds_dmmcr);
+		}
+		break;
+	default:
+		dev_dbg(dev, "Unsupported LVDS bus format 0x%04x\n", lvds->bus_format);
+	}
+
+	/* Turn the output on */
+	lvds_cr |= CR_LVDSEN;
+
+	/* Commit config to registers */
+	lvds_set(lvds, LVDS_CR, lvds_cr);
+	lvds_writel(lvds, LVDS_CDL1CR, lvds_cdl1cr);
+	lvds_writel(lvds, LVDS_CDL2CR, lvds_cdl2cr);
+
+	return 0;
+}
+
+static int stm32_lvds_attach(struct udevice *dev)
+{
+	struct stm32_lvds *lvds = dev_get_priv(dev);
+	struct display_timing timings;
+	int ret;
+
+	ret = panel_get_display_timing(lvds->panel, &timings);
+	if (ret) {
+		ret = ofnode_decode_display_timing(dev_ofnode(lvds->panel),
+						   0, &timings);
+		if (ret) {
+			dev_err(dev, "decode display timing error %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = stm32_lvds_enable(dev, &timings);
+
+	return ret;
+}
+
+static int stm32_lvds_set_backlight(struct udevice *dev, int percent)
+{
+	struct stm32_lvds *lvds = dev_get_priv(dev);
+	int ret;
+
+	ret = panel_enable_backlight(lvds->panel);
+	if (ret) {
+		dev_err(dev, "panel %s enable backlight error %d\n",
+			lvds->panel->name, ret);
+	}
+
+	return ret;
+}
+
+static int lvds_handle_pixel_order(struct stm32_lvds *lvds)
+{
+	ofnode parent, panel_port0, panel_port1;
+	bool even_pixels, odd_pixels;
+	int port0, port1;
+
+	/*
+	 * In case we are operating in single link,
+	 * there is only one port linked to the LVDS.
+	 * Check whether we are in this case and exit if yes.
+	 */
+	parent = ofnode_find_subnode(dev_ofnode(lvds->panel), "ports");
+	if (!ofnode_valid(parent))
+		return 0;
+
+	panel_port0 = ofnode_first_subnode(parent);
+	if (!ofnode_valid(panel_port0))
+		return -EPIPE;
+
+	even_pixels = ofnode_read_bool(panel_port0, "dual-lvds-even-pixels");
+	odd_pixels = ofnode_read_bool(panel_port0, "dual-lvds-odd-pixels");
+	if (even_pixels && odd_pixels)
+		return -EINVAL;
+
+	port0 = even_pixels ? LVDS_DUAL_LINK_EVEN_ODD_PIXELS :
+		LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+
+	panel_port1 = ofnode_next_subnode(panel_port0);
+	if (!ofnode_valid(panel_port1))
+		return -EPIPE;
+
+	even_pixels = ofnode_read_bool(panel_port1, "dual-lvds-even-pixels");
+	odd_pixels = ofnode_read_bool(panel_port1, "dual-lvds-odd-pixels");
+	if (even_pixels && odd_pixels)
+		return -EINVAL;
+
+	port1 = even_pixels ? LVDS_DUAL_LINK_EVEN_ODD_PIXELS :
+		LVDS_DUAL_LINK_ODD_EVEN_PIXELS;
+
+	/*
+	 * A valid dual-LVDS bus is found when one port is marked with
+	 * "dual-lvds-even-pixels", and the other port is marked with
+	 * "dual-lvds-odd-pixels", bail out if the markers are not right.
+	 */
+	if (port0 + port1 != LVDS_DUAL_LINK_EVEN_ODD_PIXELS + LVDS_DUAL_LINK_ODD_EVEN_PIXELS)
+		return -EINVAL;
+
+	return port0;
+}
+
+static int stm32_lvds_probe(struct udevice *dev)
+{
+	struct stm32_lvds *priv = dev_get_priv(dev);
+	struct display_timing timings;
+	struct reset_ctl rst;
+	struct clk pclk, refclk;
+	const char *data_mapping;
+	int ret;
+
+	ret =  device_get_supply_regulator(dev, "vdd",
+					   &priv->vdd_reg);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Warning: cannot get vdd supply\n");
+		return ret;
+	}
+
+	if (ret != -ENOENT) {
+		ret = regulator_set_enable(priv->vdd_reg, true);
+		if (ret)
+			return ret;
+	}
+
+	ret =  device_get_supply_regulator(dev, "vdda18",
+					   &priv->vdda18_reg);
+	if (ret && ret != -ENOENT) {
+		dev_err(dev, "Warning: cannot get vdda18 supply\n");
+		return ret;
+	}
+
+	if (ret != -ENOENT) {
+		ret = regulator_set_enable(priv->vdda18_reg, true);
+		if (ret)
+			return ret;
+	}
+
+	priv->base = dev_read_addr_ptr(dev);
+	if ((fdt_addr_t)priv->base == FDT_ADDR_T_NONE) {
+		dev_err(dev, "Unable to read LVDS base address\n");
+		return -EINVAL;
+	}
+
+	ret = clk_get_by_name(dev, "pclk", &pclk);
+	if (ret) {
+		dev_err(dev, "Unable to get peripheral clock: %d\n", ret);
+		goto err_reg;
+	}
+
+	ret = clk_enable(&pclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable peripheral clock: %d\n", ret);
+		goto err_reg;
+	}
+
+	ret = clk_get_by_name(dev, "ref", &refclk);
+	if (ret) {
+		dev_err(dev, "Unable to get reference clock: %d\n", ret);
+		goto err_reg;
+	}
+
+	ret = clk_enable(&refclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable reference clock: %d\n", ret);
+		goto err_clk;
+	}
+
+	priv->refclk = (unsigned int)clk_get_rate(&refclk);
+
+	ret = reset_get_by_index(dev, 0, &rst);
+	if (ret) {
+		dev_err(dev, "Failed to get LVDS reset: %d\n", ret);
+		goto err_rst;
+	}
+
+	reset_deassert(&rst);
+
+	ret = uclass_get_device_by_driver(UCLASS_PANEL,
+					  DM_DRIVER_GET(simple_panel), &priv->panel);
+	if (ret) {
+		dev_err(dev, "panel device error %d\n", ret);
+		goto err_rst;
+	}
+
+	ret = panel_get_display_timing(priv->panel, &timings);
+	if (ret) {
+		ret = ofnode_decode_display_timing(dev_ofnode(priv->panel),
+						   0, &timings);
+		if (ret) {
+			dev_err(dev, "decode display timing error %d\n", ret);
+			goto err_rst;
+		}
+	}
+
+	data_mapping = ofnode_read_string(dev_ofnode(priv->panel), "data-mapping");
+	if (!strcmp(data_mapping, "vesa-24"))
+		priv->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
+	else if (!strcmp(data_mapping, "jeida-24"))
+		priv->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA;
+	else
+		priv->bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG;
+
+	/* Handle dual link config */
+	priv->dual_link = lvds_handle_pixel_order(priv);
+	if (priv->dual_link < 0)
+		goto err_rst;
+
+	if (priv->dual_link > 0) {
+		ret = stm32_lvds_pll_enable(priv, &timings, LVDS_PHY_SLAVE);
+		if (ret)
+			goto err_rst;
+	}
+
+	ret = stm32_lvds_pll_enable(priv, &timings, LVDS_PHY_MASTER);
+	if (ret)
+		goto err_rst;
+
+	return 0;
+
+err_rst:
+	clk_disable(&refclk);
+err_clk:
+	clk_disable(&pclk);
+err_reg:
+	regulator_set_enable(priv->vdda18_reg, false);
+	regulator_set_enable(priv->vdd_reg, false);
+
+	return ret;
+}
+
+static const struct video_bridge_ops stm32_lvds_ops = {
+	.attach = stm32_lvds_attach,
+	.set_backlight = stm32_lvds_set_backlight,
+};
+
+static const struct udevice_id stm32_lvds_ids[] = {
+	{.compatible = "st,stm32mp25-lvds"},
+	{}
+};
+
+U_BOOT_DRIVER(stm32_lvds) = {
+	.name		= "stm32-display-lvds",
+	.id		= UCLASS_VIDEO_BRIDGE,
+	.of_match	= stm32_lvds_ids,
+	.ops		= &stm32_lvds_ops,
+	.probe		= stm32_lvds_probe,
+	.priv_auto	= sizeof(struct stm32_lvds),
+};
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 50e6a1efba..602658b396 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -342,6 +342,14 @@ config WDT_TANGIER
 	  Intel Tangier SoC. If you're using a board with Intel Tangier
 	  SoC, say Y here.
 
+config WDT_ARM_SMC
+	bool "ARM SMC watchdog timer support"
+	depends on WDT && ARM_SMCCC
+	imply WATCHDOG
+	help
+	  Select this to enable Arm SMC watchdog timer. This watchdog will manage
+	  a watchdog based on ARM SMCCC communication.
+
 config SPL_WDT
 	bool "Enable driver model for watchdog timer drivers in SPL"
 	depends on SPL_DM
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 0e2f582a5f..69f6d25077 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_ULP_WATCHDOG) += ulp_wdog.o
 obj-$(CONFIG_$(SPL_TPL_)WDT) += wdt-uclass.o
 obj-$(CONFIG_WDT_SANDBOX) += sandbox_wdt.o
 obj-$(CONFIG_WDT_APPLE) += apple_wdt.o
+obj-$(CONFIG_WDT_ARM_SMC) += arm_smc_wdt.o
 obj-$(CONFIG_WDT_ARMADA_37XX) += armada-37xx-wdt.o
 obj-$(CONFIG_WDT_ASPEED) += ast_wdt.o
 obj-$(CONFIG_WDT_AST2600) += ast2600_wdt.o
diff --git a/drivers/watchdog/arm_smc_wdt.c b/drivers/watchdog/arm_smc_wdt.c
new file mode 100644
index 0000000000..4134609ebe
--- /dev/null
+++ b/drivers/watchdog/arm_smc_wdt.c
@@ -0,0 +1,140 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * ARM Secure Monitor Call watchdog driver
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ * This file is based on Linux driver drivers/watchdog/arm_smc_wdt.c
+ */
+
+#define LOG_CATEGORY UCLASS_WDT
+
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <linux/arm-smccc.h>
+#include <linux/psci.h>
+#include <wdt.h>
+
+#define DRV_NAME		"arm_smc_wdt"
+
+#define WDT_TIMEOUT_SECS(TIMEOUT)	((TIMEOUT) / 1000)
+
+enum smcwd_call {
+	SMCWD_INIT		= 0,
+	SMCWD_SET_TIMEOUT	= 1,
+	SMCWD_ENABLE		= 2,
+	SMCWD_PET		= 3,
+	SMCWD_GET_TIMELEFT	= 4,
+};
+
+struct smcwd_priv_data {
+	u32 smc_id;
+	unsigned int min_timeout;
+	unsigned int max_timeout;
+};
+
+static int smcwd_call(struct udevice *dev, enum smcwd_call call,
+		      unsigned long arg, struct arm_smccc_res *res)
+{
+	struct smcwd_priv_data *priv = dev_get_priv(dev);
+	struct arm_smccc_res local_res;
+
+	if (!res)
+		res = &local_res;
+
+	arm_smccc_smc(priv->smc_id, call, arg, 0, 0, 0, 0, 0, res);
+
+	if (res->a0 == PSCI_RET_NOT_SUPPORTED)
+		return -ENODEV;
+	if (res->a0 == PSCI_RET_INVALID_PARAMS)
+		return -EINVAL;
+	if (res->a0 == PSCI_RET_DISABLED)
+		return -ENODATA;
+	if (res->a0 != PSCI_RET_SUCCESS)
+		return -EIO;
+
+	return 0;
+}
+
+static int smcwd_reset(struct udevice *dev)
+{
+	return smcwd_call(dev, SMCWD_PET, 0, NULL);
+}
+
+static int smcwd_stop(struct udevice *dev)
+{
+	return smcwd_call(dev, SMCWD_ENABLE, 0, NULL);
+}
+
+static int smcwd_start(struct udevice *dev, u64 timeout_ms, ulong flags)
+{
+	struct smcwd_priv_data *priv = dev_get_priv(dev);
+	u64 timeout_sec = WDT_TIMEOUT_SECS(timeout_ms);
+	int err;
+
+	if (timeout_sec < priv->min_timeout || timeout_sec > priv->max_timeout) {
+		dev_err(dev, "Timeout value not supported\n");
+		return -EINVAL;
+	}
+
+	err = smcwd_call(dev, SMCWD_SET_TIMEOUT, timeout_sec, NULL);
+	if (err) {
+		dev_err(dev, "Timeout out configuration failed\n");
+		return err;
+	}
+
+	return smcwd_call(dev, SMCWD_ENABLE, 1, NULL);
+}
+
+static int smcwd_probe(struct udevice *dev)
+{
+	struct smcwd_priv_data *priv = dev_get_priv(dev);
+	struct arm_smccc_res res;
+	int err;
+
+	priv->smc_id = dev_read_u32_default(dev, "arm,smc-id", 0x82003D06);
+
+	err = smcwd_call(dev, SMCWD_INIT, 0, &res);
+	if (err < 0) {
+		dev_err(dev, "Init failed\n");
+		return err;
+	}
+
+	priv->min_timeout = res.a1;
+	priv->max_timeout = res.a2;
+
+	/* If already started, then force u-boot to use it */
+	err = smcwd_call(dev, SMCWD_GET_TIMELEFT, 0, NULL);
+	switch (err) {
+	case 0:
+		dev_dbg(dev, "Already started\n");
+		wdt_set_force_start(dev);
+		break;
+	case -ENODATA:
+		dev_dbg(dev, "Not already started\n");
+		break;
+	default:
+		/* Optional SMCWD_GET_TIMELEFT not implemented */
+		break;
+	}
+
+	return 0;
+}
+
+static const struct wdt_ops smcwd_ops = {
+	.start		= smcwd_start,
+	.stop		= smcwd_stop,
+	.reset		= smcwd_reset,
+};
+
+static const struct udevice_id smcwd_dt_ids[] = {
+	{ .compatible = "arm,smc-wdt" },
+	{}
+};
+
+U_BOOT_DRIVER(wdt_sandbox) = {
+	.name = "smcwd",
+	.id = UCLASS_WDT,
+	.of_match = smcwd_dt_ids,
+	.priv_auto = sizeof(struct smcwd_priv_data),
+	.probe = smcwd_probe,
+	.ops = &smcwd_ops,
+};
diff --git a/drivers/watchdog/stm32mp_wdt.c b/drivers/watchdog/stm32mp_wdt.c
index 4be616c1b6..32cb92606c 100644
--- a/drivers/watchdog/stm32mp_wdt.c
+++ b/drivers/watchdog/stm32mp_wdt.c
@@ -16,16 +16,20 @@
 #include <linux/bitops.h>
 #include <linux/iopoll.h>
 
+#define MSEC_PER_SEC	1000
+
 /* IWDG registers */
 #define IWDG_KR		0x00	/* Key register */
 #define IWDG_PR		0x04	/* Prescaler Register */
 #define IWDG_RLR	0x08	/* ReLoad Register */
 #define IWDG_SR		0x0C	/* Status Register */
+#define IWDG_VERR	0x3F4	/* Version Register */
 
 /* IWDG_KR register bit mask */
 #define KR_KEY_RELOAD	0xAAAA	/* Reload counter enable */
 #define KR_KEY_ENABLE	0xCCCC	/* Peripheral enable */
 #define KR_KEY_EWA	0x5555	/* Write access enable */
+#define KR_KEY_DWA	0x0000	/* Write access disable*/
 
 /* IWDG_PR register bit values */
 #define PR_256		0x06	/* Prescaler set to 256 */
@@ -36,10 +40,17 @@
 /* IWDG_SR register bit values */
 #define SR_PVU		BIT(0)	/* Watchdog prescaler value update */
 #define SR_RVU		BIT(1)	/* Watchdog counter reload value update */
+#define SR_ONF		BIT(8)	/* Watchdog enable status bit */
+
+/* IWDG Compatibility */
+#define ONF_MIN_VER	0x31
+
+#define TIMEOUT_US	10000
 
 struct stm32mp_wdt_priv {
 	fdt_addr_t base;		/* registers addr in physical memory */
 	unsigned long wdt_clk_rate;	/* Watchdog dedicated clock rate */
+	unsigned int hw_version;	/* Peripheral version */
 };
 
 static int stm32mp_wdt_reset(struct udevice *dev)
@@ -59,7 +70,7 @@ static int stm32mp_wdt_start(struct udevice *dev, u64 timeout_ms, ulong flags)
 	int ret;
 
 	/* Prescaler fixed to 256 */
-	reload = timeout_ms * priv->wdt_clk_rate / 256;
+	reload = timeout_ms * priv->wdt_clk_rate / (256 * MSEC_PER_SEC);
 	if (reload > RLR_MAX + 1)
 		/* Force to max watchdog counter reload value */
 		reload = RLR_MAX + 1;
@@ -77,19 +88,23 @@ static int stm32mp_wdt_start(struct udevice *dev, u64 timeout_ms, ulong flags)
 
 	/* Wait for the registers to be updated */
 	ret = readl_poll_timeout(priv->base + IWDG_SR, val,
-				 val & (SR_PVU | SR_RVU), CONFIG_SYS_HZ);
+				 !(val & (SR_PVU | SR_RVU)), CONFIG_SYS_HZ);
 
 	if (ret < 0) {
-		dev_err(dev, "Updating IWDG registers timeout");
+		dev_err(dev, "Updating IWDG registers timeout\n");
 		return -ETIMEDOUT;
 	}
 
+	/* Reload watchdog */
+	writel(KR_KEY_RELOAD, priv->base + IWDG_KR);
+
 	return 0;
 }
 
 static int stm32mp_wdt_probe(struct udevice *dev)
 {
 	struct stm32mp_wdt_priv *priv = dev_get_priv(dev);
+	u32 rlr, sr;
 	struct clk clk;
 	int ret;
 
@@ -115,6 +130,29 @@ static int stm32mp_wdt_probe(struct udevice *dev)
 
 	priv->wdt_clk_rate = clk_get_rate(&clk);
 
+	priv->hw_version = readl(priv->base + IWDG_VERR);
+
+	if (priv->hw_version >= ONF_MIN_VER) {
+		if (readl(priv->base + IWDG_SR) & SR_ONF)
+			wdt_set_force_start(dev);
+	} else {
+		/*
+		 * Workaround for old versions without IWDG_SR_ONF bit:
+		 * - write in IWDG_RLR_OFFSET
+		 * - wait for sync
+		 * - if sync succeeds, then iwdg is running
+		 */
+		writel(KR_KEY_EWA, priv->base + IWDG_KR);
+		rlr = readl(priv->base + IWDG_RLR);
+		writel(rlr, priv->base + IWDG_RLR);
+		ret = readl_poll_timeout(priv->base + IWDG_SR, sr, sr & SR_RVU,
+					 TIMEOUT_US);
+		if (!ret)
+			wdt_set_force_start(dev);
+
+		writel(KR_KEY_DWA, priv->base + IWDG_KR);
+	}
+
 	dev_dbg(dev, "IWDG init done\n");
 
 	return 0;
diff --git a/drivers/watchdog/wdt-uclass.c b/drivers/watchdog/wdt-uclass.c
index dbf556467d..f0e04930b2 100644
--- a/drivers/watchdog/wdt-uclass.c
+++ b/drivers/watchdog/wdt-uclass.c
@@ -38,8 +38,21 @@ struct wdt_priv {
 	bool running;
 	/* No autostart */
 	bool noautostart;
+	/* Force start */
+	bool force_start;
 };
 
+int wdt_set_force_start(struct udevice *dev)
+{
+	struct wdt_priv *priv;
+
+	priv = dev_get_uclass_priv(dev);
+
+	priv->force_start = true;
+
+	return 0;
+}
+
 static void init_watchdog_dev(struct udevice *dev)
 {
 	struct wdt_priv *priv;
@@ -54,7 +67,8 @@ static void init_watchdog_dev(struct udevice *dev)
 			       dev->name);
 	}
 
-	if (!IS_ENABLED(CONFIG_WATCHDOG_AUTOSTART) || priv->noautostart) {
+	if (!priv->force_start &&
+	    (!IS_ENABLED(CONFIG_WATCHDOG_AUTOSTART) || priv->noautostart)) {
 		printf("WDT:   Not starting %s\n", dev->name);
 		return;
 	}
diff --git a/dts/Makefile b/dts/Makefile
index cb31113829..efb20fc85d 100644
--- a/dts/Makefile
+++ b/dts/Makefile
@@ -30,7 +30,7 @@ endif
 
 targets += dt.dtb
 
-$(DTB): arch-dtbs
+$(DTB): arch-dtbs arch-ext-dtbs
 	$(Q)test -e $@ || (						\
 	echo >&2;							\
 	echo >&2 "Device Tree Source ($@) is not correctly specified.";	\
@@ -43,6 +43,14 @@ PHONY += arch-dtbs
 arch-dtbs:
 	$(Q)$(MAKE) $(build)=arch/$(ARCH)/dts dtbs
 
+PHONY += arch-ext-dtbs
+arch-ext-dtbs: arch-dtbs
+	$(Q)test -e $(EXT_DTS) && (\
+		echo "  EXT_DTS in $(EXT_DTS)";\
+		$(MAKE) $(build)=$(EXT_DTS) dtbs && \
+		cp $(EXT_DTS)/*.dtb arch/$(ARCH)/dts/ || \
+		/bin/true) || /bin/true
+
 ifeq ($(CONFIG_SPL_BUILD),y)
 obj-$(CONFIG_OF_EMBED) := dt-spl.dtb.o
 # support "out-of-tree" build for dtb-spl
@@ -64,3 +72,4 @@ clean-files := dt.dtb.S
 
 # Let clean descend into dts directories
 subdir- += ../arch/arm/dts ../arch/microblaze/dts ../arch/mips/dts ../arch/sandbox/dts ../arch/x86/dts ../arch/powerpc/dts ../arch/riscv/dts
+subdir- += $(EXT_DTS)
diff --git a/env/Kconfig b/env/Kconfig
index 238e4c70cf..1759e7d50a 100644
--- a/env/Kconfig
+++ b/env/Kconfig
@@ -242,6 +242,13 @@ config ENV_IS_IN_MMC
 	  This value is also in units of bytes, but must also be aligned to
 	  an MMC sector boundary.
 
+	  CONFIG_ENV_MMC_USE_DT (optional):
+
+	  These define forces the configuration by the config node in device
+	  tree with partition name: "u-boot,mmc-env-partition" or with
+	  offset: "u-boot,mmc-env-offset", "u-boot,mmc-env-offset-redundant".
+	  CONFIG_ENV_OFFSET and CONFIG_ENV_OFFSET_REDUND are not used.
+
 config ENV_IS_IN_NAND
 	bool "Environment in a NAND device"
 	depends on !CHAIN_OF_TRUST
@@ -649,6 +656,15 @@ config SYS_MMC_ENV_PART
 	  partition 0 or the first boot partition, which is 1 or some other defined
 	  partition.
 
+config ENV_MMC_USE_DT
+	bool "Read partition name and offset in DT"
+	depends on ENV_IS_IN_MMC && OF_CONTROL
+	help
+	  Only use the device tree to get the environment location in MMC
+	  device, with partition name or with offset.
+	  The 2 defines CONFIG_ENV_OFFSET, CONFIG_ENV_OFFSET_REDUND
+	  are not used as fallback.
+
 config USE_DEFAULT_ENV_FILE
 	bool "Create default environment from file"
 	help
diff --git a/env/common.c b/env/common.c
index f9226e0690..da0535833c 100644
--- a/env/common.c
+++ b/env/common.c
@@ -15,6 +15,7 @@
 #include <log.h>
 #include <sort.h>
 #include <asm/global_data.h>
+#include <asm/io.h>
 #include <linux/stddef.h>
 #include <search.h>
 #include <errno.h>
@@ -172,7 +173,7 @@ static int env_get_from_linear(const char *env, const char *name, char *buf,
 		value = &p[name_len + 1];
 
 		res = end - value;
-		memcpy(buf, value, min(len, res + 1));
+		memcpy_fromio(buf, value, min(len, res + 1));
 
 		if (len <= res) {
 			buf[len - 1] = '\0';
diff --git a/env/env.c b/env/env.c
index 69848fb060..06078c7f37 100644
--- a/env/env.c
+++ b/env/env.c
@@ -311,11 +311,15 @@ int env_erase(void)
 	if (drv) {
 		int ret;
 
-		if (!drv->erase)
+		if (!drv->erase) {
+			printf("not possible\n");
 			return -ENODEV;
+		}
 
-		if (!env_has_inited(drv->location))
+		if (!env_has_inited(drv->location)) {
+			printf("not initialized\n");
 			return -ENODEV;
+		}
 
 		printf("Erasing Environment on %s... ", drv->name);
 		ret = drv->erase();
diff --git a/env/flash.c b/env/flash.c
index 1e75f8c004..31b81f56b0 100644
--- a/env/flash.c
+++ b/env/flash.c
@@ -15,6 +15,7 @@
 #include <env_internal.h>
 #include <log.h>
 #include <asm/global_data.h>
+#include <asm/io.h>
 #include <linux/stddef.h>
 #include <malloc.h>
 #include <search.h>
@@ -73,16 +74,34 @@ static ulong __maybe_unused end_addr_new =
 static int env_flash_init(void)
 {
 	int crc1_ok = 0, crc2_ok = 0;
+	uchar flag1, flag2;
+	ulong addr1, addr2;
+	env_t *tmp_env1, *tmp_env2;
 
-	uchar flag1 = flash_addr->flags;
-	uchar flag2 = flash_addr_new->flags;
+	gd->env_valid = ENV_INVALID;
+
+	if (!is_flash_available())
+		return 0;
+
+	tmp_env1 = (env_t *)malloc(CONFIG_ENV_SIZE);
+	tmp_env2 = (env_t *)malloc(CONFIG_ENV_SIZE);
+
+	if (!tmp_env1 || !tmp_env2) {
+		env_set_default("malloc() failed", 0);
+		return -EIO;
+	}
+
+	memcpy_fromio(tmp_env1, flash_addr, CONFIG_ENV_SIZE);
+	memcpy_fromio(tmp_env2, flash_addr_new, CONFIG_ENV_SIZE);
 
-	ulong addr1 = (ulong)&(flash_addr->data);
-	ulong addr2 = (ulong)&(flash_addr_new->data);
+	flag1 = tmp_env1->flags;
+	flag2 = tmp_env2->flags;
 
-	crc1_ok = crc32(0, flash_addr->data, ENV_SIZE) == flash_addr->crc;
-	crc2_ok =
-		crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc;
+	addr1 = (ulong)&(flash_addr->data);
+	addr2 = (ulong)&(flash_addr_new->data);
+
+	crc1_ok = crc32(0, tmp_env1->data, ENV_SIZE) == tmp_env1->crc;
+	crc2_ok = crc32(0, tmp_env2->data, ENV_SIZE) == tmp_env2->crc;
 
 	if (crc1_ok && !crc2_ok) {
 		gd->env_addr	= addr1;
@@ -111,10 +130,92 @@ static int env_flash_init(void)
 		gd->env_valid	= ENV_REDUND;
 	}
 
+	free(tmp_env1);
+	free(tmp_env2);
+
 	return 0;
 }
+
+#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+static int save_rest_of_sector(ulong start, ulong end, char **saved_data)
+{
+	ulong up_data = 0;
+
+	up_data = end + 1 - (start + CONFIG_ENV_SIZE);
+	debug("Data to save 0x%lX\n", up_data);
+	if (up_data) {
+		*saved_data = malloc(up_data);
+		if (!saved_data) {
+			printf("Can't allocate the rest of sector\n");
+			return -ENOMEM;
+		}
+		memcpy_fromio(*saved_data, (void *)(start + CONFIG_ENV_SIZE),
+			      up_data);
+		debug("Data (start 0x%lX, len 0x%lX) saved at 0x%p\n",
+		      start + CONFIG_ENV_SIZE, up_data, *saved_data);
+	}
+
+	return 0;
+}
+
+static int restore_rest_of_sector(ulong start, ulong end, char *saved_data)
+{
+	ulong up_data;
+	int ret = 0;
+
+	up_data = end + 1 - (start + CONFIG_ENV_SIZE);
+	if (up_data) {
+		debug("Restoring the rest of data to 0x%lX len 0x%lX\n",
+		      start + CONFIG_ENV_SIZE, up_data);
+		ret = flash_write(saved_data, start + CONFIG_ENV_SIZE, up_data);
+	}
+
+	return ret;
+}
+#endif
+#endif
+
+static int env_update_flag(char flag, env_t *start, ulong end)
+{
+	env_t tmp_env;
+	char *saved_data = NULL;
+	int ret;
+
+	memcpy_fromio(&tmp_env, start, CONFIG_ENV_SIZE);
+	tmp_env.flags = flag;
+
+#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+	ret = save_rest_of_sector((ulong)start, end, &saved_data);
+	if (ret)
+		return ret;
+#endif
+	puts("Erasing Flash...");
+	debug(" %08lX ... %08lX ...", (ulong)start, end);
+
+	if (flash_sect_erase((ulong)start, end))
+		goto done;
+
+	puts("Writing to Flash... ");
+	debug(" %08lX ... %08lX ...",
+	      (ulong)&start,
+	      sizeof(tmp_env.data) + (ulong)&start->data);
+
+	ret = flash_write((char *)&tmp_env, (ulong)start, sizeof(tmp_env));
+	if (ret)
+		goto perror;
+
+#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
+	ret = restore_rest_of_sector((long)start, end, saved_data);
 #endif
 
+perror:
+	flash_perror(ret);
+done:
+	free(saved_data);
+
+	return ret;
+}
+
 #ifdef CMD_SAVEENV
 static int env_flash_save(void)
 {
@@ -122,9 +223,6 @@ static int env_flash_save(void)
 	char	*saved_data = NULL;
 	char	flag = ENV_REDUND_OBSOLETE, new_flag = ENV_REDUND_ACTIVE;
 	int	rc = 1;
-#if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	ulong	up_data = 0;
-#endif
 
 	debug("Protect off %08lX ... %08lX\n", (ulong)flash_addr, end_addr);
 
@@ -143,22 +241,10 @@ static int env_flash_save(void)
 	env_new.flags	= new_flag;
 
 #if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	up_data = end_addr_new + 1 - ((long)flash_addr_new + CONFIG_ENV_SIZE);
-	debug("Data to save 0x%lX\n", up_data);
-	if (up_data) {
-		saved_data = malloc(up_data);
-		if (saved_data == NULL) {
-			printf("Unable to save the rest of sector (%ld)\n",
-				up_data);
-			goto done;
-		}
-		memcpy(saved_data,
-			(void *)((long)flash_addr_new + CONFIG_ENV_SIZE),
-			up_data);
-		debug("Data (start 0x%lX, len 0x%lX) saved at 0x%p\n",
-			(long)flash_addr_new + CONFIG_ENV_SIZE,
-			up_data, saved_data);
-	}
+	rc = save_rest_of_sector((long)flash_addr_new, end_addr_new, &saved_data);
+	if (rc)
+		goto done;
+
 #endif
 	puts("Erasing Flash...");
 	debug(" %08lX ... %08lX ...", (ulong)flash_addr_new, end_addr_new);
@@ -168,27 +254,22 @@ static int env_flash_save(void)
 
 	puts("Writing to Flash... ");
 	debug(" %08lX ... %08lX ...",
-		(ulong)&(flash_addr_new->data),
+		(ulong)&(flash_addr_new),
 		sizeof(env_ptr->data) + (ulong)&(flash_addr_new->data));
 	rc = flash_write((char *)&env_new, (ulong)flash_addr_new,
 			 sizeof(env_new));
 	if (rc)
 		goto perror;
 
-	rc = flash_write(&flag, (ulong)&(flash_addr->flags),
-			 sizeof(flash_addr->flags));
+	rc = env_update_flag(flag, flash_addr, end_addr);
 	if (rc)
 		goto perror;
 
 #if CONFIG_ENV_SECT_SIZE > CONFIG_ENV_SIZE
-	if (up_data) { /* restore the rest of sector */
-		debug("Restoring the rest of data to 0x%lX len 0x%lX\n",
-			(long)flash_addr_new + CONFIG_ENV_SIZE, up_data);
-		if (flash_write(saved_data,
-				(long)flash_addr_new + CONFIG_ENV_SIZE,
-				up_data))
-			goto perror;
-	}
+	rc = restore_rest_of_sector((long)flash_addr_new, end_addr_new, saved_data);
+	if (rc)
+		goto perror;
+
 #endif
 	puts("done\n");
 
@@ -222,13 +303,28 @@ done:
 #ifdef INITENV
 static int env_flash_init(void)
 {
-	if (crc32(0, env_ptr->data, ENV_SIZE) == env_ptr->crc) {
-		gd->env_addr	= (ulong)&(env_ptr->data);
-		gd->env_valid	= ENV_VALID;
+	env_t *tmp_env;
+
+	gd->env_valid = ENV_INVALID;
+
+	if (!is_flash_available())
 		return 0;
+
+	tmp_env = malloc(CONFIG_ENV_SIZE);
+	if (!tmp_env) {
+		env_set_default("malloc() failed", 0);
+		return -EIO;
 	}
 
-	gd->env_valid = ENV_INVALID;
+	memcpy_fromio(tmp_env, env_ptr, CONFIG_ENV_SIZE);
+
+	if (crc32(0, tmp_env->data, ENV_SIZE) == tmp_env->crc) {
+		gd->env_addr = (ulong)&(env_ptr->data);
+		gd->env_valid = ENV_VALID;
+	}
+
+	free(tmp_env);
+
 	return 0;
 }
 #endif
@@ -306,6 +402,17 @@ done:
 #ifdef LOADENV
 static int env_flash_load(void)
 {
+	env_t *tmp_env;
+	int ret = 0;
+
+	tmp_env = malloc(CONFIG_ENV_SIZE);
+	if (!tmp_env) {
+		env_set_default("malloc() failed", 0);
+		return -EIO;
+	}
+
+	memcpy_fromio(tmp_env, flash_addr, CONFIG_ENV_SIZE);
+
 #ifdef CONFIG_ENV_ADDR_REDUND
 	if (gd->env_addr != (ulong)&(flash_addr->data)) {
 		env_t *etmp = flash_addr;
@@ -319,35 +426,36 @@ static int env_flash_load(void)
 	}
 
 	if (flash_addr_new->flags != ENV_REDUND_OBSOLETE &&
-	    crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc) {
-		char flag = ENV_REDUND_OBSOLETE;
-
+	    crc32(0, tmp_env->data, ENV_SIZE) == tmp_env->crc) {
 		gd->env_valid = ENV_REDUND;
 		flash_sect_protect(0, (ulong)flash_addr_new, end_addr_new);
-		flash_write(&flag,
-			    (ulong)&(flash_addr_new->flags),
-			    sizeof(flash_addr_new->flags));
+		ret = env_update_flag(ENV_REDUND_OBSOLETE, flash_addr_new, end_addr_new);
 		flash_sect_protect(1, (ulong)flash_addr_new, end_addr_new);
 	}
 
 	if (flash_addr->flags != ENV_REDUND_ACTIVE &&
 	    (flash_addr->flags & ENV_REDUND_ACTIVE) == ENV_REDUND_ACTIVE) {
-		char flag = ENV_REDUND_ACTIVE;
-
 		gd->env_valid = ENV_REDUND;
 		flash_sect_protect(0, (ulong)flash_addr, end_addr);
-		flash_write(&flag,
-			    (ulong)&(flash_addr->flags),
-			    sizeof(flash_addr->flags));
+		ret = env_update_flag(ENV_REDUND_ACTIVE, flash_addr, end_addr);
 		flash_sect_protect(1, (ulong)flash_addr, end_addr);
 	}
 
-	if (gd->env_valid == ENV_REDUND)
-		puts("*** Warning - some problems detected "
-		     "reading environment; recovered successfully\n\n");
+	if (gd->env_valid == ENV_REDUND) {
+		if (ret)
+			puts("*** Error - some problems detected "
+			     "environment can't be recovered\n\n");
+		else
+			puts("*** Warning - some problems detected "
+			     "reading environment; recovered successfully\n\n");
+	}
+
 #endif /* CONFIG_ENV_ADDR_REDUND */
 
-	return env_import((char *)flash_addr, 1, H_EXTERNAL);
+	ret = env_import((char *)tmp_env, 1, H_EXTERNAL);
+	free(tmp_env);
+
+	return ret;
 }
 #endif /* LOADENV */
 
diff --git a/env/mmc.c b/env/mmc.c
index 0c498d9a46..beb2360687 100644
--- a/env/mmc.c
+++ b/env/mmc.c
@@ -21,8 +21,23 @@
 #include <errno.h>
 #include <dm/ofnode.h>
 
-#define __STR(X) #X
-#define STR(X) __STR(X)
+#define ENV_MMC_INVALID_OFFSET ((s64)-1)
+
+#if defined(CONFIG_ENV_MMC_USE_DT)
+/* ENV offset is invalid when not defined in Device Tree */
+#define ENV_MMC_OFFSET		ENV_MMC_INVALID_OFFSET
+#define ENV_MMC_OFFSET_REDUND	ENV_MMC_INVALID_OFFSET
+
+#else
+/* Default ENV offset when not defined in Device Tree */
+#define ENV_MMC_OFFSET		CONFIG_ENV_OFFSET
+
+#if defined(CONFIG_ENV_OFFSET_REDUND)
+#define ENV_MMC_OFFSET_REDUND	CONFIG_ENV_OFFSET_REDUND
+#else
+#define ENV_MMC_OFFSET_REDUND	ENV_MMC_INVALID_OFFSET
+#endif
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -35,7 +50,7 @@ DECLARE_GLOBAL_DATA_PTR;
 #if (defined(CONFIG_SYS_REDUNDAND_ENVIRONMENT) && \
      (CONFIG_SYS_MMC_ENV_PART == 1) && \
      (CONFIG_ENV_OFFSET == CONFIG_ENV_OFFSET_REDUND))
-#define ENV_MMC_HWPART_REDUND
+#define ENV_MMC_HWPART_REDUND	1
 #endif
 
 #if CONFIG_IS_ENABLED(OF_CONTROL)
@@ -56,8 +71,18 @@ static inline int mmc_offset_try_partition(const char *str, int copy, s64 *val)
 		if (ret < 0)
 			return ret;
 
-		if (!strncmp((const char *)info.name, str, sizeof(info.name)))
+		if (str && !strncmp((const char *)info.name, str, sizeof(info.name)))
 			break;
+#ifdef CONFIG_PARTITION_TYPE_GUID
+		if (!str) {
+			const efi_guid_t env_guid = PARTITION_U_BOOT_ENVIRONMENT;
+			efi_guid_t type_guid;
+
+			uuid_str_to_bin(info.type_guid, type_guid.b, UUID_STR_FORMAT_GUID);
+			if (!memcmp(&env_guid, &type_guid, sizeof(efi_guid_t)))
+				break;
+		}
+#endif
 	}
 
 	/* round up to info.blksz */
@@ -92,28 +117,34 @@ static inline s64 mmc_offset(int copy)
 		err = mmc_offset_try_partition(str, copy, &val);
 		if (!err)
 			return val;
+		debug("env partition '%s' not found (%d)", str, err);
 	}
 
-	defvalue = CONFIG_ENV_OFFSET;
+	/* try the GPT partition with "U-Boot ENV" TYPE GUID */
+	if (IS_ENABLED(CONFIG_PARTITION_TYPE_GUID)) {
+		err = mmc_offset_try_partition(NULL, copy, &val);
+		if (!err)
+			return val;
+	}
+
+	defvalue = ENV_MMC_OFFSET;
 	propname = dt_prop.offset;
 
-#if defined(CONFIG_ENV_OFFSET_REDUND)
-	if (copy) {
-		defvalue = CONFIG_ENV_OFFSET_REDUND;
+	if (IS_ENABLED(CONFIG_SYS_REDUNDAND_ENVIRONMENT) && copy) {
+		defvalue = ENV_MMC_OFFSET_REDUND;
 		propname = dt_prop.offset_redund;
 	}
-#endif
+
 	return ofnode_conf_read_int(propname, defvalue);
 }
 #else
 static inline s64 mmc_offset(int copy)
 {
-	s64 offset = CONFIG_ENV_OFFSET;
+	s64 offset = ENV_MMC_OFFSET;
+
+	if (IS_ENABLED(CONFIG_SYS_REDUNDAND_ENVIRONMENT) && copy)
+		offset = ENV_MMC_OFFSET_REDUND;
 
-#if defined(CONFIG_ENV_OFFSET_REDUND)
-	if (copy)
-		offset = CONFIG_ENV_OFFSET_REDUND;
-#endif
 	return offset;
 }
 #endif
@@ -122,6 +153,11 @@ __weak int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr)
 {
 	s64 offset = mmc_offset(copy);
 
+	if (offset == ENV_MMC_INVALID_OFFSET) {
+		printf("Invalid ENV offset in MMC, copy=%d\n", copy);
+		return -ENOENT;
+	}
+
 	if (offset < 0)
 		offset += mmc->capacity;
 
@@ -149,8 +185,24 @@ static int mmc_set_env_part(struct mmc *mmc, uint part)
 
 	return ret;
 }
+
+static bool mmc_set_env_part_init(struct mmc *mmc)
+{
+	env_mmc_orig_hwpart = mmc_get_blk_desc(mmc)->hwpart;
+	if (mmc_set_env_part(mmc, mmc_get_env_part(mmc)))
+		return false;
+
+	return true;
+}
+
+static int mmc_set_env_part_restore(struct mmc *mmc)
+{
+	return mmc_set_env_part(mmc, env_mmc_orig_hwpart);
+}
 #else
 static inline int mmc_set_env_part(struct mmc *mmc, uint part) {return 0; };
+static bool mmc_set_env_part_init(struct mmc *mmc) {return true; }
+static inline int mmc_set_env_part_restore(struct mmc *mmc) {return 0; };
 #endif
 
 static const char *init_mmc_for_env(struct mmc *mmc)
@@ -167,8 +219,7 @@ static const char *init_mmc_for_env(struct mmc *mmc)
 	if (mmc_init(mmc))
 		return "MMC init failed";
 #endif
-	env_mmc_orig_hwpart = mmc_get_blk_desc(mmc)->hwpart;
-	if (mmc_set_env_part(mmc, mmc_get_env_part(mmc)))
+	if (!mmc_set_env_part_init(mmc))
 		return "MMC partition switch failed";
 
 	return NULL;
@@ -176,11 +227,7 @@ static const char *init_mmc_for_env(struct mmc *mmc)
 
 static void fini_mmc_for_env(struct mmc *mmc)
 {
-#ifdef CONFIG_SYS_MMC_ENV_PART
-	int dev = mmc_get_env_dev();
-
-	blk_select_hwpart_devnum(IF_TYPE_MMC, dev, env_mmc_orig_hwpart);
-#endif
+	mmc_set_env_part_restore(mmc);
 }
 
 #if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_SPL_BUILD)
@@ -217,17 +264,16 @@ static int env_mmc_save(void)
 	if (ret)
 		goto fini;
 
-#ifdef CONFIG_ENV_OFFSET_REDUND
-	if (gd->env_valid == ENV_VALID)
-		copy = 1;
+	if (IS_ENABLED(CONFIG_SYS_REDUNDAND_ENVIRONMENT)) {
+		if (gd->env_valid == ENV_VALID)
+			copy = 1;
 
-#ifdef ENV_MMC_HWPART_REDUND
-	ret = mmc_set_env_part(mmc, copy + 1);
-	if (ret)
-		goto fini;
-#endif
-
-#endif
+		if (IS_ENABLED(ENV_MMC_HWPART_REDUND)) {
+			ret = mmc_set_env_part(mmc, copy + 1);
+			if (ret)
+				goto fini;
+		}
+	}
 
 	if (mmc_get_env_addr(mmc, copy, &offset)) {
 		ret = 1;
@@ -243,12 +289,12 @@ static int env_mmc_save(void)
 
 	ret = 0;
 
-#ifdef CONFIG_ENV_OFFSET_REDUND
-	gd->env_valid = gd->env_valid == ENV_REDUND ? ENV_VALID : ENV_REDUND;
-#endif
+	if (IS_ENABLED(CONFIG_SYS_REDUNDAND_ENVIRONMENT))
+		gd->env_valid = gd->env_valid == ENV_REDUND ? ENV_VALID : ENV_REDUND;
 
 fini:
 	fini_mmc_for_env(mmc);
+
 	return ret;
 }
 
@@ -292,22 +338,22 @@ static int env_mmc_erase(void)
 	printf("\n");
 	ret = erase_env(mmc, CONFIG_ENV_SIZE, offset);
 
-#ifdef CONFIG_ENV_OFFSET_REDUND
-	copy = 1;
+	if (IS_ENABLED(CONFIG_SYS_REDUNDAND_ENVIRONMENT)) {
+		copy = 1;
 
-#ifdef ENV_MMC_HWPART_REDUND
-	ret = mmc_set_env_part(mmc, copy + 1);
-	if (ret)
-		goto fini;
-#endif
+		if (IS_ENABLED(ENV_MMC_HWPART_REDUND)) {
+			ret = mmc_set_env_part(mmc, copy + 1);
+			if (ret)
+				goto fini;
+		}
 
-	if (mmc_get_env_addr(mmc, copy, &offset)) {
-		ret = CMD_RET_FAILURE;
-		goto fini;
-	}
+		if (mmc_get_env_addr(mmc, copy, &offset)) {
+			ret = CMD_RET_FAILURE;
+			goto fini;
+		}
 
-	ret |= erase_env(mmc, CONFIG_ENV_SIZE, offset);
-#endif
+		ret |= erase_env(mmc, CONFIG_ENV_SIZE, offset);
+	}
 
 fini:
 	fini_mmc_for_env(mmc);
@@ -329,10 +375,14 @@ static inline int read_env(struct mmc *mmc, unsigned long size,
 	return (n == blk_cnt) ? 0 : -1;
 }
 
-#ifdef CONFIG_ENV_OFFSET_REDUND
+#if defined(ENV_IS_EMBEDDED)
+static int env_mmc_load(void)
+{
+	return 0;
+}
+#elif defined(CONFIG_SYS_REDUNDAND_ENVIRONMENT)
 static int env_mmc_load(void)
 {
-#if !defined(ENV_IS_EMBEDDED)
 	struct mmc *mmc;
 	u32 offset1, offset2;
 	int read1_fail = 0, read2_fail = 0;
@@ -359,19 +409,19 @@ static int env_mmc_load(void)
 		goto fini;
 	}
 
-#ifdef ENV_MMC_HWPART_REDUND
-	ret = mmc_set_env_part(mmc, 1);
-	if (ret)
-		goto fini;
-#endif
+	if (IS_ENABLED(ENV_MMC_HWPART_REDUND)) {
+		ret = mmc_set_env_part(mmc, 1);
+		if (ret)
+			goto fini;
+	}
 
 	read1_fail = read_env(mmc, CONFIG_ENV_SIZE, offset1, tmp_env1);
 
-#ifdef ENV_MMC_HWPART_REDUND
-	ret = mmc_set_env_part(mmc, 2);
-	if (ret)
-		goto fini;
-#endif
+	if (IS_ENABLED(ENV_MMC_HWPART_REDUND)) {
+		ret = mmc_set_env_part(mmc, 2);
+		if (ret)
+			goto fini;
+	}
 
 	read2_fail = read_env(mmc, CONFIG_ENV_SIZE, offset2, tmp_env2);
 
@@ -384,13 +434,11 @@ err:
 	if (ret)
 		env_set_default(errmsg, 0);
 
-#endif
 	return ret;
 }
-#else /* ! CONFIG_ENV_OFFSET_REDUND */
+#else /* ! CONFIG_SYS_REDUNDAND_ENVIRONMENT */
 static int env_mmc_load(void)
 {
-#if !defined(ENV_IS_EMBEDDED)
 	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
 	struct mmc *mmc;
 	u32 offset;
@@ -429,10 +477,10 @@ fini:
 err:
 	if (ret)
 		env_set_default(errmsg, 0);
-#endif
+
 	return ret;
 }
-#endif /* CONFIG_ENV_OFFSET_REDUND */
+#endif /* CONFIG_SYS_REDUNDAND_ENVIRONMENT */
 
 U_BOOT_ENV_LOCATION(mmc) = {
 	.location	= ENVL_MMC,
diff --git a/env/ubi.c b/env/ubi.c
index eb21c4f38b..445d34fedb 100644
--- a/env/ubi.c
+++ b/env/ubi.c
@@ -28,6 +28,12 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#if CONFIG_SYS_REDUNDAND_ENVIRONMENT
+#define ENV_UBI_VOLUME_REDUND CONFIG_ENV_UBI_VOLUME_REDUND
+#else
+#define ENV_UBI_VOLUME_REDUND "invalid"
+#endif
+
 #ifdef CONFIG_CMD_SAVEENV
 #ifdef CONFIG_SYS_REDUNDAND_ENVIRONMENT
 static int env_ubi_save(void)
@@ -177,9 +183,43 @@ static int env_ubi_load(void)
 }
 #endif /* CONFIG_SYS_REDUNDAND_ENVIRONMENT */
 
+static int env_ubi_erase(void)
+{
+	ALLOC_CACHE_ALIGN_BUFFER(char, env_buf, CONFIG_ENV_SIZE);
+	int ret = 0;
+
+	if (ubi_part(CONFIG_ENV_UBI_PART, UBI_VID_OFFSET)) {
+		printf("\n** Cannot find mtd partition \"%s\"\n",
+		       CONFIG_ENV_UBI_PART);
+		return 1;
+	}
+
+	memset(env_buf, 0x0, CONFIG_ENV_SIZE);
+
+	if (ubi_volume_write(CONFIG_ENV_UBI_VOLUME,
+			     (void *)env_buf, CONFIG_ENV_SIZE)) {
+		printf("\n** Unable to erase env to %s:%s **\n",
+		       CONFIG_ENV_UBI_PART,
+		       CONFIG_ENV_UBI_VOLUME);
+		ret = 1;
+	}
+	if (IS_ENABLED(CONFIG_SYS_REDUNDAND_ENVIRONMENT)) {
+		if (ubi_volume_write(ENV_UBI_VOLUME_REDUND,
+				     (void *)env_buf, CONFIG_ENV_SIZE)) {
+			printf("\n** Unable to erase env to %s:%s **\n",
+			       CONFIG_ENV_UBI_PART,
+			       ENV_UBI_VOLUME_REDUND);
+			ret = 1;
+		}
+	}
+
+	return ret;
+}
+
 U_BOOT_ENV_LOCATION(ubi) = {
 	.location	= ENVL_UBI,
 	ENV_NAME("UBI")
 	.load		= env_ubi_load,
 	.save		= env_save_ptr(env_ubi_save),
+	.erase		= ENV_ERASE_PTR(env_ubi_erase),
 };
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index c80f8e8028..3f0d9f1c11 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0+
 #include <common.h>
 #include <fs_internal.h>
+#include <log.h>
 #include <uuid.h>
 #include <memalign.h>
 #include "kernel-shared/btrfs_tree.h"
@@ -910,9 +911,9 @@ static int btrfs_scan_fs_devices(struct blk_desc *desc,
 
 	if (round_up(BTRFS_SUPER_INFO_SIZE + BTRFS_SUPER_INFO_OFFSET,
 		     desc->blksz) > (part->size << desc->log2blksz)) {
-		error("superblock end %u is larger than device size " LBAFU,
-				BTRFS_SUPER_INFO_SIZE + BTRFS_SUPER_INFO_OFFSET,
-				part->size << desc->log2blksz);
+		log_debug("superblock end %u is larger than device size " LBAFU,
+			  BTRFS_SUPER_INFO_SIZE + BTRFS_SUPER_INFO_OFFSET,
+			  part->size << desc->log2blksz);
 		return -EINVAL;
 	}
 
diff --git a/fs/ext4/ext4_common.c b/fs/ext4/ext4_common.c
index d49ba4a995..feb9d16ab3 100644
--- a/fs/ext4/ext4_common.c
+++ b/fs/ext4/ext4_common.c
@@ -2368,6 +2368,10 @@ int ext4fs_mount(unsigned part_length)
 	struct ext2_data *data;
 	int status;
 	struct ext_filesystem *fs = get_fs();
+
+	if (part_length < SUPERBLOCK_SIZE)
+		return 0;
+
 	data = zalloc(SUPERBLOCK_SIZE);
 	if (!data)
 		return 0;
@@ -2415,7 +2419,7 @@ int ext4fs_mount(unsigned part_length)
 
 	return 1;
 fail:
-	printf("Failed to mount ext2 filesystem...\n");
+	log_debug("Failed to mount ext2 filesystem...\n");
 fail_noerr:
 	free(data);
 	ext4fs_root = NULL;
diff --git a/fs/fs_internal.c b/fs/fs_internal.c
index ae1cb8584c..111f91b355 100644
--- a/fs/fs_internal.c
+++ b/fs/fs_internal.c
@@ -29,8 +29,7 @@ int fs_devread(struct blk_desc *blk, struct disk_partition *partition,
 	/* Check partition boundaries */
 	if ((sector + ((byte_offset + byte_len - 1) >> log2blksz))
 	    >= partition->size) {
-		log_err("%s read outside partition " LBAFU "\n", __func__,
-			sector);
+		log_debug("read outside partition " LBAFU "\n", sector);
 		return 0;
 	}
 
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index 81f63f06f1..38f80d320b 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -110,6 +110,7 @@ enum gpio_func_t {
 	GPIOF_UNUSED,		/* Not claimed */
 	GPIOF_UNKNOWN,		/* Not known */
 	GPIOF_FUNC,		/* Not used as a GPIO */
+	GPIOF_PROTECTED,	/* Protected access */
 
 	GPIOF_COUNT,
 };
@@ -127,6 +128,7 @@ struct gpio_desc {
 #define GPIOD_OPEN_SOURCE	BIT(6)	/* GPIO is open source type */
 #define GPIOD_PULL_UP		BIT(7)	/* GPIO has pull-up enabled */
 #define GPIOD_PULL_DOWN		BIT(8)	/* GPIO has pull-down enabled */
+#define GPIOD_IS_AF		BIT(9)	/* GPIO is an alternate function */
 
 /* Flags for updating the above */
 #define GPIOD_MASK_DIR		(GPIOD_IS_OUT | GPIOD_IS_IN | \
@@ -460,14 +462,6 @@ int dm_gpio_lookup_name(const char *name, struct gpio_desc *desc);
  */
 int gpio_hog_lookup_name(const char *name, struct gpio_desc **desc);
 
-/**
- * gpio_hog_probe_all() - probe all gpio devices with
- * gpio-hog subnodes.
- *
- * @return:	Returns return value from device_probe()
- */
-int gpio_hog_probe_all(void);
-
 /**
  * gpio_lookup_name - Look up a GPIO name and return its details
  *
diff --git a/include/clk.h b/include/clk.h
index 76bb64bb5e..57b6628fff 100644
--- a/include/clk.h
+++ b/include/clk.h
@@ -13,6 +13,15 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 
+#ifdef CONFIG_CLK_AUTO_ID
+#define CLK_ID_SZ	24
+#define CLK_ID_MSK	GENMASK(23, 0)
+#define CLK_ID(dev, id)	(((dev_seq(dev) + 1) << CLK_ID_SZ) | ((id) & CLK_ID_MSK))
+#else
+#define CLK_ID_MSK	(~0UL)
+#define CLK_ID(dev, id)	id
+#endif
+
 /**
  * DOC: Overview
  *
@@ -555,6 +564,16 @@ int clk_get_by_id(ulong id, struct clk **clkp);
  */
 bool clk_dev_binded(struct clk *clk);
 
+/**
+ * clk_get_id - get clk id
+ *
+ * @clk:	A clock struct
+ *
+ * Return: the clock identifier as it is defined by the clock provider in
+ * device tree or in platdata
+ */
+ulong clk_get_id(const struct clk *clk);
+
 #else /* CONFIG_IS_ENABLED(CLK) */
 
 static inline int clk_request(struct udevice *dev, struct clk *clk)
@@ -631,6 +650,11 @@ static inline bool clk_dev_binded(struct clk *clk)
 {
 	return false;
 }
+
+static inline ulong clk_get_id(const struct clk *clk)
+{
+	return 0;
+}
 #endif /* CONFIG_IS_ENABLED(CLK) */
 
 /**
diff --git a/include/configs/stm32f746-disco.h b/include/configs/stm32f746-disco.h
index 64c1bc7d43..b0ec226114 100644
--- a/include/configs/stm32f746-disco.h
+++ b/include/configs/stm32f746-disco.h
@@ -34,7 +34,6 @@
 			BOOTENV
 
 #define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
-#define CONFIG_SYS_UBOOT_START		0x080083FD
 #define CONFIG_SYS_UBOOT_BASE		(CONFIG_SYS_FLASH_BASE + \
 					 CONFIG_SPL_PAD_TO)
 
diff --git a/include/configs/stm32mp13_common.h b/include/configs/stm32mp13_common.h
index 3ca65ea2a3..ffdee51444 100644
--- a/include/configs/stm32mp13_common.h
+++ b/include/configs/stm32mp13_common.h
@@ -21,14 +21,22 @@
  */
 #define CONFIG_SYS_BOOTMAPSZ		SZ_256M
 
-/* Extend size of kernel image for uncompression */
-
 /*MMC SD*/
 #define CONFIG_SYS_MMC_MAX_DEVICE	2
 
 /* NAND support */
 #define CONFIG_SYS_MAX_NAND_DEVICE	1
 
+/* Ethernet need */
+#ifdef CONFIG_DWC_ETH_QOS
+#define CONFIG_SYS_NONCACHED_MEMORY	(1 * SZ_1M)
+#define CONFIG_SERVERIP                 192.168.1.1
+#endif
+
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
 /*****************************************************************************/
 #ifdef CONFIG_DISTRO_DEFAULTS
 /*****************************************************************************/
@@ -41,19 +49,49 @@
 #define BOOT_TARGET_MMC1(func)
 #endif
 
+#ifdef CONFIG_NET
+#define BOOT_TARGET_PXE(func)	func(PXE, pxe, na)
+#else
+#define BOOT_TARGET_PXE(func)
+#endif
+
+#ifdef CONFIG_CMD_UBIFS
+#define BOOT_TARGET_UBIFS(func)	func(UBIFS, ubifs, 0, UBI, boot)
+#else
+#define BOOT_TARGET_UBIFS(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func)	func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
 #define BOOT_TARGET_DEVICES(func)	\
 	BOOT_TARGET_MMC1(func)		\
-	BOOT_TARGET_MMC0(func)
+	BOOT_TARGET_UBIFS(func)		\
+	BOOT_TARGET_MMC0(func)		\
+	BOOT_TARGET_USB(func)		\
+	BOOT_TARGET_PXE(func)
 
 /*
  * default bootcmd for stm32mp13:
+ * for serial/usb: execute the stm32prog command
  * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition
+ * for nor boot, use the default distro order in ${boot_targets}
  */
 #define STM32MP_BOOTCMD "bootcmd_stm32mp=" \
 	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
 		"run env_check;" \
 		"if test ${boot_device} = mmc;" \
 		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
 		"run distro_bootcmd;" \
 	"fi;\0"
 
@@ -73,11 +111,11 @@
  * and the ramdisk at the end.
  */
 #define __KERNEL_ADDR_R     __stringify(0xc2000000)
-#define __FDT_ADDR_R        __stringify(0xc4000000)
-#define __SCRIPT_ADDR_R     __stringify(0xc4100000)
-#define __PXEFILE_ADDR_R    __stringify(0xc4200000)
-#define __FDTOVERLAY_ADDR_R __stringify(0xc4300000)
-#define __RAMDISK_ADDR_R    __stringify(0xc4400000)
+#define __FDT_ADDR_R        __stringify(0xc6000000)
+#define __SCRIPT_ADDR_R     __stringify(0xc6100000)
+#define __PXEFILE_ADDR_R    __stringify(0xc6200000)
+#define __FDTOVERLAY_ADDR_R __stringify(0xc6300000)
+#define __RAMDISK_ADDR_R    __stringify(0xc6400000)
 
 #define STM32MP_MEM_LAYOUT \
 	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
diff --git a/include/configs/stm32mp13_st_common.h b/include/configs/stm32mp13_st_common.h
index c51022b40d..b831d0d29d 100644
--- a/include/configs/stm32mp13_st_common.h
+++ b/include/configs/stm32mp13_st_common.h
@@ -9,7 +9,7 @@
 #define __CONFIG_STM32MP13_ST_COMMON_H__
 
 #define STM32MP_BOARD_EXTRA_ENV \
-	"usb_pgood_delay=1000\0" \
+	"usb_pgood_delay=2000\0" \
 	"console=ttySTM0\0"
 
 #include <configs/stm32mp13_common.h>
@@ -19,4 +19,38 @@
 					 230400, 460800, 921600, \
 					 1000000, 2000000, 4000000}
 
+#ifdef CONFIG_EXTRA_ENV_SETTINGS
+/*
+ * default bootcmd for stm32mp13 STMicroelectronics boards:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition
+ * for nor boot, distro boot on SD card = mmc0 ONLY !
+ */
+#define ST_STM32MP13_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
+		"if test ${boot_device} = nor;" \
+		"then env set boot_targets mmc0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	ST_STM32MP13_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+
 #endif
diff --git a/include/configs/stm32mp15_common.h b/include/configs/stm32mp15_common.h
index c5412ffeb3..50a989332d 100644
--- a/include/configs/stm32mp15_common.h
+++ b/include/configs/stm32mp15_common.h
@@ -21,8 +21,6 @@
  */
 #define CONFIG_SYS_BOOTMAPSZ		SZ_256M
 
-/* Extend size of kernel image for uncompression */
-
 /*MMC SD*/
 #define CONFIG_SYS_MMC_MAX_DEVICE	3
 
@@ -34,6 +32,10 @@
 #define CONFIG_SERVERIP                 192.168.1.1
 #endif
 
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
 /*****************************************************************************/
 #ifdef CONFIG_DISTRO_DEFAULTS
 /*****************************************************************************/
@@ -97,19 +99,6 @@
 		"run distro_bootcmd;" \
 	"fi;\0"
 
-#ifdef CONFIG_FASTBOOT_CMD_OEM_FORMAT
-/* eMMC default partitions for fastboot command: oem format */
-#define STM32MP_PARTS_DEFAULT \
-	"partitions=" \
-	"name=ssbl,size=2M;" \
-	"name=bootfs,size=64MB,bootable;" \
-	"name=vendorfs,size=16M;" \
-	"name=rootfs,size=746M;" \
-	"name=userfs,size=-\0"
-#else
-#define STM32MP_PARTS_DEFAULT
-#endif
-
 #define STM32MP_EXTRA \
 	"env_check=if env info -p -d -q; then env save; fi\0" \
 	"boot_net_usb_start=true\0"
@@ -126,11 +115,11 @@
  * and the ramdisk at the end.
  */
 #define __KERNEL_ADDR_R     __stringify(0xc2000000)
-#define __FDT_ADDR_R        __stringify(0xc4000000)
-#define __SCRIPT_ADDR_R     __stringify(0xc4100000)
-#define __PXEFILE_ADDR_R    __stringify(0xc4200000)
-#define __FDTOVERLAY_ADDR_R __stringify(0xc4300000)
-#define __RAMDISK_ADDR_R    __stringify(0xc4400000)
+#define __FDT_ADDR_R        __stringify(0xc6000000)
+#define __SCRIPT_ADDR_R     __stringify(0xc6100000)
+#define __PXEFILE_ADDR_R    __stringify(0xc6200000)
+#define __FDTOVERLAY_ADDR_R __stringify(0xc6300000)
+#define __RAMDISK_ADDR_R    __stringify(0xc6400000)
 
 #define STM32MP_MEM_LAYOUT \
 	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
@@ -143,7 +132,6 @@
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	STM32MP_MEM_LAYOUT \
 	STM32MP_BOOTCMD \
-	STM32MP_PARTS_DEFAULT \
 	BOOTENV \
 	STM32MP_EXTRA \
 	STM32MP_BOARD_EXTRA_ENV
diff --git a/include/configs/stm32mp15_st_common.h b/include/configs/stm32mp15_st_common.h
index 6bdc286cfc..7b0ed0a121 100644
--- a/include/configs/stm32mp15_st_common.h
+++ b/include/configs/stm32mp15_st_common.h
@@ -9,6 +9,7 @@
 #define __CONFIG_STM32MP15_ST_COMMON_H__
 
 #define STM32MP_BOARD_EXTRA_ENV \
+	"usb_pgood_delay=2000\0" \
 	"console=ttySTM0\0"
 
 #include <configs/stm32mp15_common.h>
@@ -46,7 +47,6 @@
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	STM32MP_MEM_LAYOUT \
 	ST_STM32MP1_BOOTCMD \
-	STM32MP_PARTS_DEFAULT \
 	BOOTENV \
 	STM32MP_EXTRA \
 	STM32MP_BOARD_EXTRA_ENV
diff --git a/include/configs/stm32mp25_common.h b/include/configs/stm32mp25_common.h
new file mode 100644
index 0000000000..912dea4972
--- /dev/null
+++ b/include/configs/stm32mp25_common.h
@@ -0,0 +1,145 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2018-2019, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STM32MP25x CPU
+ */
+
+#ifndef __CONFIG_STM32MP25_COMMMON_H
+#define __CONFIG_STM32MP25_COMMMON_H
+#include <linux/sizes.h>
+#include <asm/arch/stm32.h>
+
+/*
+ * Configuration of the external SRAM memory used by U-Boot
+ */
+#define CONFIG_SYS_SDRAM_BASE		STM32_DDR_BASE
+
+/*
+ * For booting Linux, use the first 256 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ		SZ_256M
+
+/* MMC */
+#define CONFIG_SYS_MMC_MAX_DEVICE	3
+
+/* NAND support */
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+
+/* CFI support */
+#define CONFIG_SYS_MAX_FLASH_BANKS	1
+#define CONFIG_CFI_FLASH_USE_WEAK_ACCESSORS
+
+/* Ethernet need */
+#ifdef CONFIG_DWC_ETH_QOS
+#define CONFIG_SERVERIP                 192.168.1.1
+#endif
+
+#define STM32MP_FIP_IMAGE_GUID \
+	EFI_GUID(0x19d5df83, 0x11b0, 0x457b, 0xbe, 0x2c, \
+		 0x75, 0x59, 0xc1, 0x31, 0x42, 0xa5)
+
+/*****************************************************************************/
+#ifdef CONFIG_DISTRO_DEFAULTS
+/*****************************************************************************/
+
+#ifdef CONFIG_NET
+#define BOOT_TARGET_PXE(func)	func(PXE, pxe, na)
+#else
+#define BOOT_TARGET_PXE(func)
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#define BOOT_TARGET_MMC0(func)	func(MMC, mmc, 0)
+#define BOOT_TARGET_MMC1(func)	func(MMC, mmc, 1)
+#define BOOT_TARGET_MMC2(func)	func(MMC, mmc, 2)
+#else
+#define BOOT_TARGET_MMC0(func)
+#define BOOT_TARGET_MMC1(func)
+#define BOOT_TARGET_MMC2(func)
+#endif
+
+#ifdef CONFIG_CMD_UBIFS
+#define BOOT_TARGET_UBIFS(func)	func(UBIFS, ubifs, 0, UBI, boot)
+#else
+#define BOOT_TARGET_UBIFS(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func)	func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func)	\
+	BOOT_TARGET_MMC1(func)		\
+	BOOT_TARGET_UBIFS(func)		\
+	BOOT_TARGET_MMC0(func)		\
+	BOOT_TARGET_MMC2(func)		\
+	BOOT_TARGET_USB(func)		\
+	BOOT_TARGET_PXE(func)
+
+/*
+ * default bootcmd for stm32mp25:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for NAND or SPI-NAND boot, distro boot with UBIFS on UBI partition
+ * for other boot, use the default distro order in ${boot_targets}
+ */
+#define STM32MP_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#ifndef STM32MP_BOARD_EXTRA_ENV
+#define STM32MP_BOARD_EXTRA_ENV
+#endif
+
+#define STM32MP_EXTRA \
+	"env_check=if env info -p -d -q; then env save; fi\0" \
+	"boot_net_usb_start=true\0"
+/*
+ * memory layout for 64M uncompressed/compressed kernel,
+ * 1M fdt, 1M script, 1M pxe and 1M for overlay
+ * and the ramdisk at the end.
+ */
+#define __KERNEL_COMP_ADDR_R	__stringify(0x84000000)
+#define __KERNEL_COMP_SIZE_R	__stringify(0x04000000)
+#define __KERNEL_ADDR_R		__stringify(0x88000000)
+#define __FDT_ADDR_R		__stringify(0x8c000000)
+#define __SCRIPT_ADDR_R		__stringify(0x8c100000)
+#define __PXEFILE_ADDR_R	__stringify(0x8c200000)
+#define __FDTOVERLAY_ADDR_R	__stringify(0x8c300000)
+#define __RAMDISK_ADDR_R	__stringify(0x8c400000)
+
+#define STM32MP_MEM_LAYOUT \
+	"kernel_addr_r=" __KERNEL_ADDR_R "\0" \
+	"fdt_addr_r=" __FDT_ADDR_R "\0" \
+	"scriptaddr=" __SCRIPT_ADDR_R "\0" \
+	"pxefile_addr_r=" __PXEFILE_ADDR_R "\0" \
+	"fdtoverlay_addr_r=" __FDTOVERLAY_ADDR_R "\0" \
+	"ramdisk_addr_r=" __RAMDISK_ADDR_R "\0" \
+	"kernel_comp_addr_r=" __KERNEL_COMP_ADDR_R "\0"	\
+	"kernel_comp_size=" __KERNEL_COMP_SIZE_R "\0"
+
+#include <config_distro_bootcmd.h>
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	STM32MP_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+
+#endif /* __CONFIG_STM32MP25_COMMMON_H */
diff --git a/include/configs/stm32mp25_st_common.h b/include/configs/stm32mp25_st_common.h
new file mode 100644
index 0000000000..2b62966c52
--- /dev/null
+++ b/include/configs/stm32mp25_st_common.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2022, STMicroelectronics - All Rights Reserved
+ *
+ * Configuration settings for the STMicroelectonics STM32MP25x boards
+ */
+
+#ifndef __CONFIG_STM32MP25_ST_COMMON_H__
+#define __CONFIG_STM32MP25_ST_COMMON_H__
+
+#define STM32MP_BOARD_EXTRA_ENV \
+	"usb_pgood_delay=2000\0" \
+	"console=ttySTM0\0"
+
+#include <configs/stm32mp25_common.h>
+
+#ifdef CONFIG_EXTRA_ENV_SETTINGS
+/*
+ * default bootcmd for stm32mp25 STMicroelectronics boards:
+ * for serial/usb: execute the stm32prog command
+ * for mmc boot (eMMC, SD card), distro boot on the same mmc device
+ * for nand or spi-nand boot, distro boot with ubifs on UBI partition
+ * for nor boot, distro boot on SD card = mmc0 ONLY !
+ */
+#define ST_STM32MP25_BOOTCMD "bootcmd_stm32mp=" \
+	"echo \"Boot over ${boot_device}${boot_instance}!\";" \
+	"if test ${boot_device} = serial || test ${boot_device} = usb;" \
+	"then stm32prog ${boot_device} ${boot_instance}; " \
+	"else " \
+		"run env_check;" \
+		"if test ${boot_device} = mmc;" \
+		"then env set boot_targets \"mmc${boot_instance}\"; fi;" \
+		"if test ${boot_device} = nand ||" \
+		  " test ${boot_device} = spi-nand ;" \
+		"then env set boot_targets ubifs0; fi;" \
+		"if test ${boot_device} = nor;" \
+		"then env set boot_targets mmc0; fi;" \
+		"run distro_bootcmd;" \
+	"fi;\0"
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	STM32MP_MEM_LAYOUT \
+	ST_STM32MP25_BOOTCMD \
+	BOOTENV \
+	STM32MP_EXTRA \
+	STM32MP_BOARD_EXTRA_ENV
+
+#endif
+#endif
diff --git a/include/dfu.h b/include/dfu.h
index dcb9cd9d79..07922224ef 100644
--- a/include/dfu.h
+++ b/include/dfu.h
@@ -495,7 +495,7 @@ static inline int dfu_fill_entity_mtd(struct dfu_entity *dfu, char *devstr,
 }
 #endif
 
-#ifdef CONFIG_DFU_VIRT
+#if CONFIG_IS_ENABLED(DFU_VIRT)
 int dfu_fill_entity_virt(struct dfu_entity *dfu, char *devstr,
 			 char **argv, int argc);
 int dfu_write_medium_virt(struct dfu_entity *dfu, u64 offset,
diff --git a/include/dm/ofnode.h b/include/dm/ofnode.h
index 7ce1e4c6d9..e38d28289f 100644
--- a/include/dm/ofnode.h
+++ b/include/dm/ofnode.h
@@ -764,6 +764,18 @@ struct display_timing;
 int ofnode_decode_display_timing(ofnode node, int index,
 				 struct display_timing *config);
 
+/**
+ * ofnode_decode_panel_timing() - decode display timings
+ *
+ * Decode panel timings from the supplied 'panel-timings' node.
+ *
+ * @node:	'display-timing' node containing the timing subnodes
+ * @config:	Place to put timings
+ * Return: 0 if OK, -FDT_ERR_NOTFOUND if not found
+ */
+int ofnode_decode_panel_timing(ofnode node,
+			       struct display_timing *config);
+
 /**
  * ofnode_get_property() - get a pointer to the value of a node property
  *
diff --git a/include/dm/pinctrl.h b/include/dm/pinctrl.h
index e3e50afeaf..84a1bf916d 100644
--- a/include/dm/pinctrl.h
+++ b/include/dm/pinctrl.h
@@ -6,7 +6,7 @@
 #ifndef __PINCTRL_H
 #define __PINCTRL_H
 
-#define PINNAME_SIZE	10
+#define PINNAME_SIZE	16
 #define PINMUX_SIZE	80
 
 /**
diff --git a/include/dm/read.h b/include/dm/read.h
index 1b54b69acf..56537944b4 100644
--- a/include/dm/read.h
+++ b/include/dm/read.h
@@ -743,6 +743,20 @@ int dev_read_pci_bus_range(const struct udevice *dev, struct resource *res);
 int dev_decode_display_timing(const struct udevice *dev, int index,
 			      struct display_timing *config);
 
+/**
+ * dev_decode_panel_timing() - decode panel timings
+ *
+ * Decode display timings from the supplied 'panel-timings' node.
+ *
+ * @dev: device to read DT display timings from. The node linked to the device
+ *       contains a child node called 'display-timings' which in turn contains
+ *       one or more display timing nodes.
+ * @config: place to put timings
+ * Return: 0 if OK, -FDT_ERR_NOTFOUND if not found
+ */
+int dev_decode_panel_timing(const struct udevice *dev,
+			    struct display_timing *config);
+
 /**
  * dev_get_phy_node() - Get PHY node for a MAC (if not fixed-link)
  *
@@ -1118,6 +1132,12 @@ static inline int dev_decode_display_timing(const struct udevice *dev,
 	return ofnode_decode_display_timing(dev_ofnode(dev), index, config);
 }
 
+static inline int dev_decode_panel_timing(const struct udevice *dev,
+					  struct display_timing *config)
+{
+	return ofnode_decode_panel_timing(dev_ofnode(dev), config);
+}
+
 static inline ofnode dev_get_phy_node(const struct udevice *dev)
 {
 	return ofnode_get_phy_node(dev_ofnode(dev));
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index a432e43871..d3cdf72a15 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -58,6 +58,7 @@ enum uclass_id {
 	UCLASS_FIRMWARE,	/* Firmware */
 	UCLASS_FUZZING_ENGINE,	/* Fuzzing engine */
 	UCLASS_FS_FIRMWARE_LOADER,		/* Generic loader */
+	UCLASS_FWU_MDATA,	/* FWU Metadata Access */
 	UCLASS_GPIO,		/* Bank of general-purpose I/O pins */
 	UCLASS_HASH,		/* Hash device */
 	UCLASS_HWSPINLOCK,	/* Hardware semaphores */
@@ -126,10 +127,12 @@ enum uclass_id {
 	UCLASS_TIMER,		/* Timer device */
 	UCLASS_TPM,		/* Trusted Platform Module TIS interface */
 	UCLASS_UFS,		/* Universal Flash Storage */
+	UCLASS_UCSI,		/* USB Type-C Connector System Software Interface */
 	UCLASS_USB,		/* USB bus */
 	UCLASS_USB_DEV_GENERIC,	/* USB generic device */
 	UCLASS_USB_HUB,		/* USB hub */
 	UCLASS_USB_GADGET_GENERIC,	/* USB generic device */
+	UCLASS_USB_TYPEC,	/* USB Type-C */
 	UCLASS_VIDEO,		/* Video or LCD device */
 	UCLASS_VIDEO_BRIDGE,	/* Video bridge, e.g. DisplayPort to LVDS */
 	UCLASS_VIDEO_CONSOLE,	/* Text console driver for video device */
diff --git a/include/dt-bindings/arm/coresight-cti-dt.h b/include/dt-bindings/arm/coresight-cti-dt.h
new file mode 100644
index 0000000000..61e7bdf8ea
--- /dev/null
+++ b/include/dt-bindings/arm/coresight-cti-dt.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for the defined trigger signal
+ * types on CoreSight CTI.
+ */
+
+#ifndef _DT_BINDINGS_ARM_CORESIGHT_CTI_DT_H
+#define _DT_BINDINGS_ARM_CORESIGHT_CTI_DT_H
+
+#define GEN_IO		0
+#define GEN_INTREQ	1
+#define GEN_INTACK	2
+#define GEN_HALTREQ	3
+#define GEN_RESTARTREQ	4
+#define PE_EDBGREQ	5
+#define PE_DBGRESTART	6
+#define PE_CTIIRQ	7
+#define PE_PMUIRQ	8
+#define PE_DBGTRIGGER	9
+#define ETM_EXTOUT	10
+#define ETM_EXTIN	11
+#define SNK_FULL	12
+#define SNK_ACQCOMP	13
+#define SNK_FLUSHCOMP	14
+#define SNK_FLUSHIN	15
+#define SNK_TRIGIN	16
+#define STM_ASYNCOUT	17
+#define STM_TOUT_SPTE	18
+#define STM_TOUT_SW	19
+#define STM_TOUT_HETE	20
+#define STM_HWEVENT	21
+#define ELA_TSTART	22
+#define ELA_TSTOP	23
+#define ELA_DBGREQ	24
+#define CTI_TRIG_MAX	25
+
+#endif /*_DT_BINDINGS_ARM_CORESIGHT_CTI_DT_H */
diff --git a/include/dt-bindings/bus/stm32mp13_sys_bus.h b/include/dt-bindings/bus/stm32mp13_sys_bus.h
new file mode 100644
index 0000000000..1160de87bc
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp13_sys_bus.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H
+
+/* ETZPC IDs */
+#define STM32MP1_ETZPC_VREFBUF_ID	0
+#define STM32MP1_ETZPC_LPTIM2_ID	1
+#define STM32MP1_ETZPC_LPTIM3_ID	2
+#define STM32MP1_ETZPC_LTDC_ID		3
+#define STM32MP1_ETZPC_DCMIPP_ID	4
+#define STM32MP1_ETZPC_USBPHYCTRL_ID	5
+#define STM32MP1_ETZPC_DDRCTRLPHY_ID	6
+/* IDs 7-11 reserved */
+#define STM32MP1_ETZPC_IWDG1_ID		12
+#define STM32MP1_ETZPC_STGENC_ID	13
+/* IDs 14-15 reserved */
+#define STM32MP1_ETZPC_USART1_ID	16
+#define STM32MP1_ETZPC_USART2_ID	17
+#define STM32MP1_ETZPC_SPI4_ID		18
+#define STM32MP1_ETZPC_SPI5_ID		19
+#define STM32MP1_ETZPC_I2C3_ID		20
+#define STM32MP1_ETZPC_I2C4_ID		21
+#define STM32MP1_ETZPC_I2C5_ID		22
+#define STM32MP1_ETZPC_TIM12_ID		23
+#define STM32MP1_ETZPC_TIM13_ID		24
+#define STM32MP1_ETZPC_TIM14_ID		25
+#define STM32MP1_ETZPC_TIM15_ID		26
+#define STM32MP1_ETZPC_TIM16_ID		27
+#define STM32MP1_ETZPC_TIM17_ID		28
+/* IDs 29-31 reserved */
+#define STM32MP1_ETZPC_ADC1_ID		32
+#define STM32MP1_ETZPC_ADC2_ID		33
+#define STM32MP1_ETZPC_OTG_ID		34
+/* IDs 35-39 reserved */
+#define STM32MP1_ETZPC_TSC_ID		37
+#define STM32MP1_ETZPC_RNG_ID		40
+#define STM32MP1_ETZPC_HASH_ID		41
+#define STM32MP1_ETZPC_CRYP_ID		42
+#define STM32MP1_ETZPC_SAES_ID		43
+#define STM32MP1_ETZPC_PKA_ID		44
+#define STM32MP1_ETZPC_BKPSRAM_ID	45
+/* IDs 46-47 reserved */
+#define STM32MP1_ETZPC_ETH1_ID		48
+#define STM32MP1_ETZPC_ETH2_ID		49
+#define STM32MP1_ETZPC_SDMMC1_ID	50
+#define STM32MP1_ETZPC_SDMMC2_ID	51
+/* ID 52 reserved */
+#define STM32MP1_ETZPC_MCE_ID		53
+#define STM32MP1_ETZPC_FMC_ID		54
+#define STM32MP1_ETZPC_QSPI_ID		55
+/* IDs 56-59 reserved */
+#define STM32MP1_ETZPC_SRAM1_ID		60
+#define STM32MP1_ETZPC_SRAM2_ID		61
+#define STM32MP1_ETZPC_SRAM3_ID		62
+/* ID 63 reserved */
+
+#endif /* _DT_BINDINGS_BUS_STM32MP13_SYS_BUS_H */
diff --git a/include/dt-bindings/bus/stm32mp15_sys_bus.h b/include/dt-bindings/bus/stm32mp15_sys_bus.h
new file mode 100644
index 0000000000..97eacc7b5f
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp15_sys_bus.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H
+
+/* ETZPC IDs */
+#define STM32MP1_ETZPC_STGENC_ID	0
+#define STM32MP1_ETZPC_BKPSRAM_ID	1
+#define STM32MP1_ETZPC_IWDG1_ID		2
+#define STM32MP1_ETZPC_USART1_ID	3
+#define STM32MP1_ETZPC_SPI6_ID		4
+#define STM32MP1_ETZPC_I2C4_ID		5
+/* ID 6 reserved */
+#define STM32MP1_ETZPC_RNG1_ID		7
+#define STM32MP1_ETZPC_HASH1_ID		8
+#define STM32MP1_ETZPC_CRYP1_ID		9
+#define STM32MP1_ETZPC_DDRCTRL_ID	10
+#define STM32MP1_ETZPC_DDRPHYC_ID	11
+#define STM32MP1_ETZPC_I2C6_ID		12
+/* IDs 13-15 reserved */
+#define STM32MP1_ETZPC_TIM2_ID		16
+#define STM32MP1_ETZPC_TIM3_ID		17
+#define STM32MP1_ETZPC_TIM4_ID		18
+#define STM32MP1_ETZPC_TIM5_ID		19
+#define STM32MP1_ETZPC_TIM6_ID		20
+#define STM32MP1_ETZPC_TIM7_ID		21
+#define STM32MP1_ETZPC_TIM12_ID		22
+#define STM32MP1_ETZPC_TIM13_ID		23
+#define STM32MP1_ETZPC_TIM14_ID		24
+#define STM32MP1_ETZPC_LPTIM1_ID	25
+#define STM32MP1_ETZPC_WWDG1_ID		26
+#define STM32MP1_ETZPC_SPI2_ID		27
+#define STM32MP1_ETZPC_SPI3_ID		28
+#define STM32MP1_ETZPC_SPDIFRX_ID	29
+#define STM32MP1_ETZPC_USART2_ID	30
+#define STM32MP1_ETZPC_USART3_ID	31
+#define STM32MP1_ETZPC_UART4_ID		32
+#define STM32MP1_ETZPC_UART5_ID		33
+#define STM32MP1_ETZPC_I2C1_ID		34
+#define STM32MP1_ETZPC_I2C2_ID		35
+#define STM32MP1_ETZPC_I2C3_ID		36
+#define STM32MP1_ETZPC_I2C5_ID		37
+#define STM32MP1_ETZPC_CEC_ID		38
+#define STM32MP1_ETZPC_DAC_ID		39
+#define STM32MP1_ETZPC_UART7_ID		40
+#define STM32MP1_ETZPC_UART8_ID		41
+/* IDs 42-43 reserved */
+#define STM32MP1_ETZPC_MDIOS_ID		44
+/* IDs 45-47 reserved */
+#define STM32MP1_ETZPC_TIM1_ID		48
+#define STM32MP1_ETZPC_TIM8_ID		49
+/* ID 50 reserved */
+#define STM32MP1_ETZPC_USART6_ID	51
+#define STM32MP1_ETZPC_SPI1_ID		52
+#define STM32MP1_ETZPC_SPI4_ID		53
+#define STM32MP1_ETZPC_TIM15_ID		54
+#define STM32MP1_ETZPC_TIM16_ID		55
+#define STM32MP1_ETZPC_TIM17_ID		56
+#define STM32MP1_ETZPC_SPI5_ID		57
+#define STM32MP1_ETZPC_SAI1_ID		58
+#define STM32MP1_ETZPC_SAI2_ID		59
+#define STM32MP1_ETZPC_SAI3_ID		60
+#define STM32MP1_ETZPC_DFSDM_ID		61
+#define STM32MP1_ETZPC_TT_FDCAN_ID	62
+/* IDs 63 reserved */
+#define STM32MP1_ETZPC_LPTIM2_ID	64
+#define STM32MP1_ETZPC_LPTIM3_ID	65
+#define STM32MP1_ETZPC_LPTIM4_ID	66
+#define STM32MP1_ETZPC_LPTIM5_ID	67
+#define STM32MP1_ETZPC_SAI4_ID		68
+#define STM32MP1_ETZPC_VREFBUF_ID	69
+#define STM32MP1_ETZPC_DCMI_ID		70
+#define STM32MP1_ETZPC_CRC2_ID		71
+#define STM32MP1_ETZPC_ADC_ID		72
+#define STM32MP1_ETZPC_HASH2_ID		73
+#define STM32MP1_ETZPC_RNG2_ID		74
+#define STM32MP1_ETZPC_CRYP2_ID		75
+/* IDs 76-79 reserved */
+#define STM32MP1_ETZPC_SRAM1_ID		80
+#define STM32MP1_ETZPC_SRAM2_ID		81
+#define STM32MP1_ETZPC_SRAM3_ID		82
+#define STM32MP1_ETZPC_SRAM4_ID		83
+#define STM32MP1_ETZPC_RETRAM_ID	84
+#define STM32MP1_ETZPC_OTG_ID		85
+#define STM32MP1_ETZPC_SDMMC3_ID	86
+#define STM32MP1_ETZPC_DLYBSD3_ID	87
+#define STM32MP1_ETZPC_DMA1_ID		88
+#define STM32MP1_ETZPC_DMA2_ID		89
+#define STM32MP1_ETZPC_DMAMUX_ID	90
+#define STM32MP1_ETZPC_FMC_ID		91
+#define STM32MP1_ETZPC_QSPI_ID		92
+#define STM32MP1_ETZPC_DLYBQ_ID		93
+#define STM32MP1_ETZPC_ETH_ID		94
+/* ID 95 reserved */
+
+#endif /* _DT_BINDINGS_BUS_STM32MP15_SYS_BUS_H */
diff --git a/include/dt-bindings/bus/stm32mp25_sys_bus.h b/include/dt-bindings/bus/stm32mp25_sys_bus.h
new file mode 100644
index 0000000000..76ad05cfb1
--- /dev/null
+++ b/include/dt-bindings/bus/stm32mp25_sys_bus.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ */
+#ifndef _DT_BINDINGS_BUS_STM32MP25_SYS_BUS_H
+#define _DT_BINDINGS_BUS_STM32MP25_SYS_BUS_H
+
+/* RIFSC ID */
+#define STM32MP25_RIFSC_TIM1_ID			0
+#define STM32MP25_RIFSC_TIM2_ID			1
+#define STM32MP25_RIFSC_TIM3_ID			2
+#define STM32MP25_RIFSC_TIM4_ID			3
+#define STM32MP25_RIFSC_TIM5_ID			4
+#define STM32MP25_RIFSC_TIM6_ID			5
+#define STM32MP25_RIFSC_TIM7_ID			6
+#define STM32MP25_RIFSC_TIM8_ID			7
+#define STM32MP25_RIFSC_TIM10_ID		8
+#define STM32MP25_RIFSC_TIM11_ID		9
+#define STM32MP25_RIFSC_TIM12_ID		10
+#define STM32MP25_RIFSC_TIM13_ID		11
+#define STM32MP25_RIFSC_TIM14_ID		12
+#define STM32MP25_RIFSC_TIM15_ID		13
+#define STM32MP25_RIFSC_TIM16_ID		14
+#define STM32MP25_RIFSC_TIM17_ID		15
+#define STM32MP25_RIFSC_TIM20_ID		16
+#define STM32MP25_RIFSC_LPTIM1_ID		17
+#define STM32MP25_RIFSC_LPTIM2_ID		18
+#define STM32MP25_RIFSC_LPTIM3_ID		19
+#define STM32MP25_RIFSC_LPTIM4_ID		20
+#define STM32MP25_RIFSC_LPTIM5_ID		21
+#define STM32MP25_RIFSC_SPI1_ID			22
+#define STM32MP25_RIFSC_SPI2_ID			23
+#define STM32MP25_RIFSC_SPI3_ID			24
+#define STM32MP25_RIFSC_SPI4_ID			25
+#define STM32MP25_RIFSC_SPI5_ID			26
+#define STM32MP25_RIFSC_SPI6_ID			27
+#define STM32MP25_RIFSC_SPI7_ID			28
+#define STM32MP25_RIFSC_SPI8_ID			29
+#define STM32MP25_RIFSC_SPDIFRX_ID		30
+#define STM32MP25_RIFSC_USART1_ID		31
+#define STM32MP25_RIFSC_USART2_ID		32
+#define STM32MP25_RIFSC_USART3_ID		33
+#define STM32MP25_RIFSC_UART4_ID		34
+#define STM32MP25_RIFSC_UART5_ID		35
+#define STM32MP25_RIFSC_USART6_ID		36
+#define STM32MP25_RIFSC_UART7_ID		37
+#define STM32MP25_RIFSC_UART8_ID		38
+#define STM32MP25_RIFSC_UART9_ID		39
+#define STM32MP25_RIFSC_LPUART1_ID		40
+#define STM32MP25_RIFSC_I2C1_ID			41
+#define STM32MP25_RIFSC_I2C2_ID			42
+#define STM32MP25_RIFSC_I2C3_ID			43
+#define STM32MP25_RIFSC_I2C4_ID			44
+#define STM32MP25_RIFSC_I2C5_ID			45
+#define STM32MP25_RIFSC_I2C6_ID			46
+#define STM32MP25_RIFSC_I2C7_ID			47
+#define STM32MP25_RIFSC_I2C8_ID			48
+#define STM32MP25_RIFSC_SAI1_ID			49
+#define STM32MP25_RIFSC_SAI2_ID			50
+#define STM32MP25_RIFSC_SAI3_ID			51
+#define STM32MP25_RIFSC_SAI4_ID			52
+#define STM32MP25_RIFSC_MDF1_ID			54
+#define STM32MP25_RIFSC_ADF1_ID			55
+#define STM32MP25_RIFSC_FDCAN_ID		56
+#define STM32MP25_RIFSC_HDP_ID			57
+#define STM32MP25_RIFSC_ADC12_ID		58
+#define STM32MP25_RIFSC_ADC3_ID			59
+#define STM32MP25_RIFSC_ETH1_ID			60
+#define STM32MP25_RIFSC_ETH2_ID			61
+#define STM32MP25_RIFSC_USBH_ID			63
+#define STM32MP25_RIFSC_USB3DR_ID		66
+#define STM32MP25_RIFSC_COMBOPHY_ID		67
+#define STM32MP25_RIFSC_PCIE_ID			68
+#define STM32MP25_RIFSC_UCPD1_ID		69
+#define STM32MP25_RIFSC_ETHSW_DEIP_ID		70
+#define STM32MP25_RIFSC_ETHSW_ACM_CFG_ID	71
+#define STM32MP25_RIFSC_ETHSW_ACM_MSGBUF_ID	72
+#define STM32MP25_RIFSC_STGEN_ID		73
+#define STM32MP25_RIFSC_OCTOSPI1_ID		74
+#define STM32MP25_RIFSC_OCTOSPI2_ID		75
+#define STM32MP25_RIFSC_SDMMC1_ID		76
+#define STM32MP25_RIFSC_SDMMC2_ID		77
+#define STM32MP25_RIFSC_SDMMC3_ID		78
+#define STM32MP25_RIFSC_GPU_ID			79
+#define STM32MP25_RIFSC_LTDC_CMN_ID		80
+#define STM32MP25_RIFSC_DSI_CMN_ID		81
+#define STM32MP25_RIFSC_LVDS_ID			84
+#define STM32MP25_RIFSC_CSI_ID			86
+#define STM32MP25_RIFSC_DCMIPP_ID		87
+#define STM32MP25_RIFSC_DCMI_PSSI_ID		88
+#define STM32MP25_RIFSC_VDEC_ID			89
+#define STM32MP25_RIFSC_VENC_ID			90
+#define STM32MP25_RIFSC_RNG_ID			92
+#define STM32MP25_RIFSC_PKA_ID			93
+#define STM32MP25_RIFSC_SAES_ID			94
+#define STM32MP25_RIFSC_HASH_ID			95
+#define STM32MP25_RIFSC_CRYP1_ID		96
+#define STM32MP25_RIFSC_CRYP2_ID		97
+#define STM32MP25_RIFSC_IWDG1_ID		98
+#define STM32MP25_RIFSC_IWDG2_ID		99
+#define STM32MP25_RIFSC_IWDG3_ID		100
+#define STM32MP25_RIFSC_IWDG4_ID		101
+#define STM32MP25_RIFSC_IWDG5_ID		102
+#define STM32MP25_RIFSC_WWDG1_ID		103
+#define STM32MP25_RIFSC_WWDG2_ID		104
+#define STM32MP25_RIFSC_VREFBUF_ID		106
+#define STM32MP25_RIFSC_DTS_ID			107
+#define STM32MP25_RIFSC_RAMCFG_ID		108
+#define STM32MP25_RIFSC_CRC_ID			109
+#define STM32MP25_RIFSC_SERC_ID			110
+#define STM32MP25_RIFSC_OCTOSPIM_ID		111
+#define STM32MP25_RIFSC_GICV2M_ID		112
+#define STM32MP25_RIFSC_I3C1_ID			114
+#define STM32MP25_RIFSC_I3C2_ID			115
+#define STM32MP25_RIFSC_I3C3_ID			116
+#define STM32MP25_RIFSC_I3C4_ID			117
+#define STM32MP25_RIFSC_ICACHE_DCACHE_ID	118
+#define STM32MP25_RIFSC_LTDC_L0L1_ID		119
+#define STM32MP25_RIFSC_LTDC_L2_ID		120
+#define STM32MP25_RIFSC_LTDC_ROT_ID		121
+#define STM32MP25_RIFSC_DSI_TRIG_ID		122
+#define STM32MP25_RIFSC_DSI_RDFIFO_ID		123
+#define STM32MP25_RIFSC_OTFDEC1_ID		125
+#define STM32MP25_RIFSC_OTFDEC2_ID		126
+#define STM32MP25_RIFSC_IAC_ID			127
+
+#endif /* _DT_BINDINGS_BUS_STM32MP25_SYS_BUS_H */
diff --git a/include/dt-bindings/clock/stm32mp13-clks.h b/include/dt-bindings/clock/stm32mp13-clks.h
new file mode 100644
index 0000000000..e7937de5c7
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp13-clks.h
@@ -0,0 +1,235 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_CLKS_H_
+#define _DT_BINDINGS_STM32MP13_CLKS_H_
+
+/* OSCILLATOR clocks */
+#define CK_HSE		0
+#define CK_CSI		1
+#define CK_LSI		2
+#define CK_LSE		3
+#define CK_HSI		4
+#define CK_HSE_DIV2	5
+
+/* PLL */
+#define PLL1		6
+#define PLL2		7
+#define PLL3		8
+#define PLL4		9
+
+/* ODF */
+#define PLL1_P		10
+#define PLL1_Q		11
+#define PLL1_R		12
+#define PLL2_P		13
+#define PLL2_Q		14
+#define PLL2_R		15
+#define PLL3_P		16
+#define PLL3_Q		17
+#define PLL3_R		18
+#define PLL4_P		19
+#define PLL4_Q		20
+#define PLL4_R		21
+
+#define PCLK1		22
+#define PCLK2		23
+#define PCLK3		24
+#define PCLK4		25
+#define PCLK5		26
+#define PCLK6		27
+
+/* SYSTEM CLOCK */
+#define CK_PER		28
+#define CK_MPU		29
+#define CK_AXI		30
+#define CK_MLAHB	31
+
+/* BASE TIMER */
+#define CK_TIMG1	32
+#define CK_TIMG2	33
+#define CK_TIMG3	34
+
+/* AUX */
+#define RTC		35
+
+/* TRACE & DEBUG clocks */
+#define CK_DBG		36
+#define CK_TRACE	37
+
+/* MCO clocks */
+#define CK_MCO1		38
+#define CK_MCO2		39
+
+/* IP clocks */
+#define SYSCFG		40
+#define VREF		41
+#define DTS		42
+#define PMBCTRL		43
+#define HDP		44
+#define IWDG2		45
+#define STGENRO		46
+#define USART1		47
+#define RTCAPB		48
+#define TZC		49
+#define TZPC		50
+#define IWDG1		51
+#define BSEC		52
+#define DMA1		53
+#define DMA2		54
+#define DMAMUX1		55
+#define DMAMUX2		56
+#define GPIOA		57
+#define GPIOB		58
+#define GPIOC		59
+#define GPIOD		60
+#define GPIOE		61
+#define GPIOF		62
+#define GPIOG		63
+#define GPIOH		64
+#define GPIOI		65
+#define CRYP1		66
+#define HASH1		67
+#define BKPSRAM		68
+#define MDMA		69
+#define CRC1		70
+#define USBH		71
+#define DMA3		72
+#define TSC		73
+#define PKA		74
+#define AXIMC		75
+#define MCE		76
+#define ETH1TX		77
+#define ETH2TX		78
+#define ETH1RX		79
+#define ETH2RX		80
+#define ETH1MAC		81
+#define ETH2MAC		82
+#define ETH1STP		83
+#define ETH2STP		84
+
+/* IP clocks with parents */
+#define SDMMC1_K	85
+#define SDMMC2_K	86
+#define ADC1_K		87
+#define ADC2_K		88
+#define FMC_K		89
+#define QSPI_K		90
+#define RNG1_K		91
+#define USBPHY_K	92
+#define STGEN_K		93
+#define SPDIF_K		94
+#define SPI1_K		95
+#define SPI2_K		96
+#define SPI3_K		97
+#define SPI4_K		98
+#define SPI5_K		99
+#define I2C1_K		100
+#define I2C2_K		101
+#define I2C3_K		102
+#define I2C4_K		103
+#define I2C5_K		104
+#define TIM2_K		105
+#define TIM3_K		106
+#define TIM4_K		107
+#define TIM5_K		108
+#define TIM6_K		109
+#define TIM7_K		110
+#define TIM12_K		111
+#define TIM13_K		112
+#define TIM14_K		113
+#define TIM1_K		114
+#define TIM8_K		115
+#define TIM15_K		116
+#define TIM16_K		117
+#define TIM17_K		118
+#define LPTIM1_K	119
+#define LPTIM2_K	120
+#define LPTIM3_K	121
+#define LPTIM4_K	122
+#define LPTIM5_K	123
+#define USART1_K	124
+#define USART2_K	125
+#define USART3_K	126
+#define UART4_K		127
+#define UART5_K		128
+#define USART6_K	129
+#define UART7_K		130
+#define UART8_K		131
+#define DFSDM_K		132
+#define FDCAN_K		133
+#define SAI1_K		134
+#define SAI2_K		135
+#define ADFSDM_K	136
+#define USBO_K		137
+#define LTDC_PX		138
+#define ETH1CK_K	139
+#define ETH1PTP_K	140
+#define ETH2CK_K	141
+#define ETH2PTP_K	142
+#define DCMIPP_K	143
+#define SAES_K		144
+#define DTS_K		145
+
+/* DDR */
+#define DDRC1		146
+#define DDRC1LP		147
+#define DDRC2		148
+#define DDRC2LP		149
+#define DDRPHYC		150
+#define DDRPHYCLP	151
+#define DDRCAPB		152
+#define DDRCAPBLP	153
+#define AXIDCG		154
+#define DDRPHYCAPB	155
+#define DDRPHYCAPBLP	156
+#define DDRPERFM	157
+
+#define ADC1		158
+#define ADC2		159
+#define SAI1		160
+#define SAI2		161
+
+#define SPI1		162
+#define SPI2		163
+#define SPI3		164
+#define SPI4		165
+#define SPI5		166
+
+#define STM32MP1_LAST_CLK 167
+
+/* SCMI clock identifiers */
+#define CK_SCMI_HSE		0
+#define CK_SCMI_HSI		1
+#define CK_SCMI_CSI		2
+#define CK_SCMI_LSE		3
+#define CK_SCMI_LSI		4
+#define CK_SCMI_HSE_DIV2	5
+#define CK_SCMI_PLL2_Q		6
+#define CK_SCMI_PLL2_R		7
+#define CK_SCMI_PLL3_P		8
+#define CK_SCMI_PLL3_Q		9
+#define CK_SCMI_PLL3_R		10
+#define CK_SCMI_PLL4_P		11
+#define CK_SCMI_PLL4_Q		12
+#define CK_SCMI_PLL4_R		13
+#define CK_SCMI_MPU		14
+#define CK_SCMI_AXI		15
+#define CK_SCMI_MLAHB		16
+#define CK_SCMI_CKPER		17
+#define CK_SCMI_PCLK1		18
+#define CK_SCMI_PCLK2		19
+#define CK_SCMI_PCLK3		20
+#define CK_SCMI_PCLK4		21
+#define CK_SCMI_PCLK5		22
+#define CK_SCMI_PCLK6		23
+#define CK_SCMI_CKTIMG1		24
+#define CK_SCMI_CKTIMG2		25
+#define CK_SCMI_CKTIMG3		26
+#define CK_SCMI_RTC		27
+#define CK_SCMI_RTCAPB		28
+
+#endif /* _DT_BINDINGS_STM32MP13_CLKS_H_ */
diff --git a/include/dt-bindings/clock/stm32mp2-clksrc.h b/include/dt-bindings/clock/stm32mp2-clksrc.h
new file mode 100644
index 0000000000..971f01a458
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp2-clksrc.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2017-2019, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_
+#define _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_
+
+/* PLLs source clocks */
+#define PLL_SRC_HSI		0x0
+#define PLL_SRC_HSE		0x1
+#define PLL_SRC_CSI		0x2
+#define PLL_SRC_DISABLED	0x3
+
+/*
+ * Configure a PLL with its clock source
+ * pll_nb: PLL number from 1 to 8
+ * pll_src: one of the 3 previous PLLs source clocks defines
+ */
+#define PLL_CFG(pll_nb, pll_src) \
+	(((pll_nb) - 1) | (pll_src << 4))
+
+/* XBAR source clocks */
+#define XBAR_SRC_PLL4		0x0
+#define XBAR_SRC_PLL5		0x1
+#define XBAR_SRC_PLL6		0x2
+#define XBAR_SRC_PLL7		0x3
+#define XBAR_SRC_PLL8		0x4
+#define XBAR_SRC_HSI		0x5
+#define XBAR_SRC_HSE		0x6
+#define XBAR_SRC_CSI		0x7
+#define XBAR_SRC_HSI_KER	0x8
+#define XBAR_SRC_HSE_KER	0x9
+#define XBAR_SRC_CSI_KER	0xA
+#define XBAR_SRC_SPDIF_SYMB	0xB
+#define XBAR_SRC_I2S		0xC
+#define XBAR_SRC_LSI		0xD
+#define XBAR_SRC_LSE		0xE
+#define XBAR_SRC_DISABLED	0xF
+
+/*
+ * Configure a XBAR channel with its clock source
+ * channel_nb: XBAR channel number from 0 to 63
+ * channel_src: one of the 15 previous XBAR source clocks defines
+ * channel_prediv: value of the PREDIV in channel RCC_PREDIVxCFGR register
+ *		   can be either 1, 2, 4 or 1024
+ * channel_findiv: value of the FINDIV in channel RCC_FINDIVxCFGR register
+ *		   from 1 to 64
+ */
+#define XBAR_CFG(channel_nb, channel_src, channel_prediv, channel_findiv) \
+	((channel_nb) | ((channel_src) << 6) |\
+	 ((channel_prediv) << 10) | (((channel_findiv) - 1) << 20))
+
+/* st,clksrc: mandatory clock source */
+
+#define CLK_CA35SS_EXT2F	0x0
+#define CLK_CA35SS_PLL1		0x1
+
+#define CLK_RTC_DISABLED	0x0
+#define CLK_RTC_LSE		0x1
+#define CLK_RTC_LSI		0x2
+#define CLK_RTC_HSE		0x3
+
+#define CLK_MCO1_HSI		0x00008000
+#define CLK_MCO1_HSE		0x00008001
+#define CLK_MCO1_CSI		0x00008002
+#define CLK_MCO1_LSI		0x00008003
+#define CLK_MCO1_LSE		0x00008004
+#define CLK_MCO1_DISABLED	0x0000800F
+
+#define CLK_MCO2_MPU		0x00008040
+#define CLK_MCO2_AXI		0x00008041
+#define CLK_MCO2_MCU		0x00008042
+#define CLK_MCO2_PLL4P		0x00008043
+#define CLK_MCO2_HSE		0x00008044
+#define CLK_MCO2_HSI		0x00008045
+#define CLK_MCO2_DISABLED	0x0000804F
+
+/* define for st,pll /csg */
+#define SSCG_MODE_CENTER_SPREAD	0
+#define SSCG_MODE_DOWN_SPREAD	1
+
+/* define for st,drive */
+#define LSEDRV_LOWEST		0
+#define LSEDRV_MEDIUM_LOW	1
+#define LSEDRV_MEDIUM_HIGH	2
+#define LSEDRV_HIGHEST		3
+
+#endif /* _DT_BINDINGS_CLOCK_STM32MP2_CLKSRC_H_ */
diff --git a/include/dt-bindings/clock/stm32mp25-clks.h b/include/dt-bindings/clock/stm32mp25-clks.h
new file mode 100644
index 0000000000..a8d28b325d
--- /dev/null
+++ b/include/dt-bindings/clock/stm32mp25-clks.h
@@ -0,0 +1,496 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_CLKS_H_
+#define _DT_BINDINGS_STM32MP25_CLKS_H_
+
+/* INTERNAL/EXTERNAL OSCILLATORS */
+#define HSI_CK			0
+#define HSE_CK			1
+#define MSI_CK			2
+#define LSI_CK			3
+#define LSE_CK			4
+#define I2S_CK			5
+#define RTC_CK			6
+#define SPDIF_CK_SYMB		7
+
+/* PLL CLOCKS */
+#define PLL1_CK			8
+#define PLL2_CK			9
+#define PLL3_CK			10
+#define PLL4_CK			11
+#define PLL5_CK			12
+#define PLL6_CK			13
+#define PLL7_CK			14
+#define PLL8_CK			15
+
+#define CK_CPU1			16
+
+/* APB DIV CLOCKS */
+#define CK_ICN_APB1		17
+#define CK_ICN_APB2		18
+#define CK_ICN_APB3		19
+#define CK_ICN_APB4		20
+#define CK_ICN_APBDBG		21
+
+/* GLOBAL TIMER */
+#define TIMG1_CK		22
+#define TIMG2_CK		23
+
+/* FLEXGEN CLOCKS */
+#define CK_ICN_HS_MCU		24
+#define CK_ICN_SDMMC		25
+#define CK_ICN_DDR		26
+#define CK_ICN_DISPLAY		27
+#define CK_ICN_HSL		28
+#define CK_ICN_NIC		29
+#define CK_ICN_VID		30
+#define CK_FLEXGEN_07		31
+#define CK_FLEXGEN_08		32
+#define CK_FLEXGEN_09		33
+#define CK_FLEXGEN_10		34
+#define CK_FLEXGEN_11		35
+#define CK_FLEXGEN_12		36
+#define CK_FLEXGEN_13		37
+#define CK_FLEXGEN_14		38
+#define CK_FLEXGEN_15		39
+#define CK_FLEXGEN_16		40
+#define CK_FLEXGEN_17		41
+#define CK_FLEXGEN_18		42
+#define CK_FLEXGEN_19		43
+#define CK_FLEXGEN_20		44
+#define CK_FLEXGEN_21		45
+#define CK_FLEXGEN_22		46
+#define CK_FLEXGEN_23		47
+#define CK_FLEXGEN_24		48
+#define CK_FLEXGEN_25		49
+#define CK_FLEXGEN_26		50
+#define CK_FLEXGEN_27		51
+#define CK_FLEXGEN_28		52
+#define CK_FLEXGEN_29		53
+#define CK_FLEXGEN_30		54
+#define CK_FLEXGEN_31		55
+#define CK_FLEXGEN_32		56
+#define CK_FLEXGEN_33		57
+#define CK_FLEXGEN_34		58
+#define CK_FLEXGEN_35		59
+#define CK_FLEXGEN_36		60
+#define CK_FLEXGEN_37		61
+#define CK_FLEXGEN_38		62
+#define CK_FLEXGEN_39		63
+#define CK_FLEXGEN_40		64
+#define CK_FLEXGEN_41		65
+#define CK_FLEXGEN_42		66
+#define CK_FLEXGEN_43		67
+#define CK_FLEXGEN_44		68
+#define CK_FLEXGEN_45		69
+#define CK_FLEXGEN_46		70
+#define CK_FLEXGEN_47		71
+#define CK_FLEXGEN_48		72
+#define CK_FLEXGEN_49		73
+#define CK_FLEXGEN_50		74
+#define CK_FLEXGEN_51		75
+#define CK_FLEXGEN_52		76
+#define CK_FLEXGEN_53		77
+#define CK_FLEXGEN_54		78
+#define CK_FLEXGEN_55		79
+#define CK_FLEXGEN_56		80
+#define CK_FLEXGEN_57		81
+#define CK_FLEXGEN_58		82
+#define CK_FLEXGEN_59		83
+#define CK_FLEXGEN_60		84
+#define CK_FLEXGEN_61		85
+#define CK_FLEXGEN_62		86
+#define CK_FLEXGEN_63		87
+
+/* LOW SPEED MCU CLOCK */
+#define CK_ICN_LS_MCU		88
+
+#define CK_BUS_STM		89
+#define CK_BUS_FMC		90
+#define CK_BUS_GPU		91
+#define CK_BUS_ETH1		92
+#define CK_BUS_ETH2		93
+#define CK_BUS_PCIE		94
+#define CK_BUS_DDRPHYC		95
+#define CK_BUS_SYSCPU1		96
+#define CK_BUS_ETHSW		97
+#define CK_BUS_HPDMA1		98
+#define CK_BUS_HPDMA2		99
+#define CK_BUS_HPDMA3		100
+#define CK_BUS_ADC12		101
+#define CK_BUS_ADC3		102
+#define CK_BUS_IPCC1		103
+#define CK_BUS_CCI		104
+#define CK_BUS_CRC		105
+#define CK_BUS_MDF1		106
+#define CK_BUS_OSPIIOM		107
+#define CK_BUS_BKPSRAM		108
+#define CK_BUS_HASH		109
+#define CK_BUS_RNG		110
+#define CK_BUS_CRYP1		111
+#define CK_BUS_CRYP2		112
+#define CK_BUS_SAES		113
+#define CK_BUS_PKA		114
+#define CK_BUS_GPIOA		115
+#define CK_BUS_GPIOB		116
+#define CK_BUS_GPIOC		117
+#define CK_BUS_GPIOD		118
+#define CK_BUS_GPIOE		119
+#define CK_BUS_GPIOF		120
+#define CK_BUS_GPIOG		121
+#define CK_BUS_GPIOH		122
+#define CK_BUS_GPIOI		123
+#define CK_BUS_GPIOJ		124
+#define CK_BUS_GPIOK		125
+#define CK_BUS_LPSRAM1		126
+#define CK_BUS_LPSRAM2		127
+#define CK_BUS_LPSRAM3		128
+#define CK_BUS_GPIOZ		129
+#define CK_BUS_LPDMA		130
+#define CK_BUS_HSEM		131
+#define CK_BUS_IPCC2		132
+#define CK_BUS_RTC		133
+#define CK_BUS_SPI8		134
+#define CK_BUS_LPUART1		135
+#define CK_BUS_I2C8		136
+#define CK_BUS_LPTIM3		137
+#define CK_BUS_LPTIM4		138
+#define CK_BUS_LPTIM5		139
+#define CK_BUS_IWDG5		140
+#define CK_BUS_WWDG2		141
+#define CK_BUS_I3C4		142
+#define CK_BUS_TIM2		143
+#define CK_BUS_TIM3		144
+#define CK_BUS_TIM4		145
+#define CK_BUS_TIM5		146
+#define CK_BUS_TIM6		147
+#define CK_BUS_TIM7		148
+#define CK_BUS_TIM10		149
+#define CK_BUS_TIM11		150
+#define CK_BUS_TIM12		151
+#define CK_BUS_TIM13		152
+#define CK_BUS_TIM14		153
+#define CK_BUS_LPTIM1		154
+#define CK_BUS_LPTIM2		155
+#define CK_BUS_SPI2		156
+#define CK_BUS_SPI3		157
+#define CK_BUS_SPDIFRX		158
+#define CK_BUS_USART2		159
+#define CK_BUS_USART3		160
+#define CK_BUS_UART4		161
+#define CK_BUS_UART5		162
+#define CK_BUS_I2C1		163
+#define CK_BUS_I2C2		164
+#define CK_BUS_I2C3		165
+#define CK_BUS_I2C4		166
+#define CK_BUS_I2C5		167
+#define CK_BUS_I2C6		168
+#define CK_BUS_I2C7		169
+#define CK_BUS_I3C1		170
+#define CK_BUS_I3C2		171
+#define CK_BUS_I3C3		172
+#define CK_BUS_TIM1		173
+#define CK_BUS_TIM8		174
+#define CK_BUS_TIM15		175
+#define CK_BUS_TIM16		176
+#define CK_BUS_TIM17		177
+#define CK_BUS_TIM20		178
+#define CK_BUS_SAI1		179
+#define CK_BUS_SAI2		180
+#define CK_BUS_SAI3		181
+#define CK_BUS_SAI4		182
+#define CK_BUS_USART1		183
+#define CK_BUS_USART6		184
+#define CK_BUS_UART7		185
+#define CK_BUS_UART8		186
+#define CK_BUS_UART9		187
+#define CK_BUS_FDCAN		188
+#define CK_BUS_SPI1		189
+#define CK_BUS_SPI4		190
+#define CK_BUS_SPI5		191
+#define CK_BUS_SPI6		192
+#define CK_BUS_SPI7		193
+#define CK_BUS_BSEC		194
+#define CK_BUS_IWDG1		195
+#define CK_BUS_IWDG2		196
+#define CK_BUS_IWDG3		197
+#define CK_BUS_IWDG4		198
+#define CK_BUS_WWDG1		199
+#define CK_BUS_VREF		200
+#define CK_BUS_DTS		201
+#define CK_BUS_SERC		202
+#define CK_BUS_HDP		203
+#define CK_BUS_IS2M		204
+#define CK_BUS_DSI		205
+#define CK_BUS_LTDC		206
+#define CK_BUS_CSI		207
+#define CK_BUS_DCMIPP		208
+#define CK_BUS_DDRC		209
+#define CK_BUS_DDRCFG		210
+#define CK_BUS_GICV2M		211
+#define CK_BUS_USBTC		212
+#define CK_BUS_USB3PCIEPHY	214
+#define CK_BUS_STGEN		215
+#define CK_BUS_VDEC		216
+#define CK_BUS_VENC		217
+#define CK_SYSDBG		218
+#define CK_KER_TIM2		219
+#define CK_KER_TIM3		220
+#define CK_KER_TIM4		221
+#define CK_KER_TIM5		222
+#define CK_KER_TIM6		223
+#define CK_KER_TIM7		224
+#define CK_KER_TIM10		225
+#define CK_KER_TIM11		226
+#define CK_KER_TIM12		227
+#define CK_KER_TIM13		228
+#define CK_KER_TIM14		229
+#define CK_KER_TIM1		230
+#define CK_KER_TIM8		231
+#define CK_KER_TIM15		232
+#define CK_KER_TIM16		233
+#define CK_KER_TIM17		234
+#define CK_KER_TIM20		235
+#define CK_BUS_SYSRAM		236
+#define CK_BUS_VDERAM		237
+#define CK_BUS_RETRAM		238
+#define CK_BUS_OSPI1		239
+#define CK_BUS_OSPI2		240
+#define CK_BUS_OTFD1		241
+#define CK_BUS_OTFD2		242
+#define CK_BUS_SRAM1		243
+#define CK_BUS_SRAM2		244
+#define CK_BUS_SDMMC1		245
+#define CK_BUS_SDMMC2		246
+#define CK_BUS_SDMMC3		247
+#define CK_BUS_DDR		248
+#define CK_BUS_RISAF4		249
+#define CK_BUS_USB2OHCI		250
+#define CK_BUS_USB2EHCI		251
+#define CK_BUS_USB3DR		252
+#define CK_KER_LPTIM1		253
+#define CK_KER_LPTIM2		254
+#define CK_KER_USART2		255
+#define CK_KER_UART4		256
+#define CK_KER_USART3		257
+#define CK_KER_UART5		258
+#define CK_KER_SPI2		259
+#define CK_KER_SPI3		260
+#define CK_KER_SPDIFRX		261
+#define CK_KER_I2C1		262
+#define CK_KER_I2C2		263
+#define CK_KER_I3C1		264
+#define CK_KER_I3C2		265
+#define CK_KER_I2C3		266
+#define CK_KER_I2C5		267
+#define CK_KER_I3C3		268
+#define CK_KER_I2C4		269
+#define CK_KER_I2C6		270
+#define CK_KER_I2C7		271
+#define CK_KER_SPI1		272
+#define CK_KER_SPI4		273
+#define CK_KER_SPI5		274
+#define CK_KER_SPI6		275
+#define CK_KER_SPI7		276
+#define CK_KER_USART1		277
+#define CK_KER_USART6		278
+#define CK_KER_UART7		279
+#define CK_KER_UART8		280
+#define CK_KER_UART9		281
+#define CK_KER_MDF1		282
+#define CK_KER_SAI1		283
+#define CK_KER_SAI2		284
+#define CK_KER_SAI3		285
+#define CK_KER_SAI4		286
+#define CK_KER_FDCAN		287
+#define CK_KER_DSIBLANE		288
+#define CK_KER_DSIPHY		289
+#define CK_KER_CSI		290
+#define CK_KER_CSITXESC		291
+#define CK_KER_CSIPHY		292
+#define CK_KER_LVDSPHY		293
+#define CK_KER_STGEN		294
+#define CK_KER_USB3PCIEPHY	295
+#define CK_KER_USB2PHY2EN	296
+#define CK_KER_I3C4		297
+#define CK_KER_SPI8		298
+#define CK_KER_I2C8		299
+#define CK_KER_LPUART1		300
+#define CK_KER_LPTIM3		301
+#define CK_KER_LPTIM4		302
+#define CK_KER_LPTIM5		303
+#define CK_KER_TSDBG		304
+#define CK_KER_TPIU		305
+#define CK_BUS_ETR		306
+#define CK_BUS_SYSATB		307
+#define CK_KER_ADC12		308
+#define CK_KER_ADC3		309
+#define CK_KER_OSPI1		310
+#define CK_KER_OSPI2		311
+#define CK_KER_FMC		312
+#define CK_KER_SDMMC1		313
+#define CK_KER_SDMMC2		314
+#define CK_KER_SDMMC3		315
+#define CK_KER_ETH1		316
+#define CK_KER_ETH2		317
+#define CK_KER_ETH1PTP		318
+#define CK_KER_ETH2PTP		319
+#define CK_KER_USB2PHY1		320
+#define CK_KER_USB2PHY2		321
+#define CK_KER_ETHSW		322
+#define CK_KER_ETHSWREF		323
+#define CK_MCO1			324
+#define CK_MCO2			325
+#define CK_KER_DTS		326
+#define CK_ETH1_RX		327
+#define CK_ETH1_TX		328
+#define CK_ETH1_MAC		329
+#define CK_ETH2_RX		330
+#define CK_ETH2_TX		331
+#define CK_ETH2_MAC		332
+#define CK_ETH1_STP		333
+#define CK_ETH2_STP		334
+#define CK_KER_USBTC		335
+#define CK_BUS_ADF1		336
+#define CK_KER_ADF1		337
+#define CK_BUS_LVDS		338
+#define CK_KER_LTDC		339
+#define CK_KER_GPU		340
+#define CK_BUS_ETHSWACMCFG	341
+#define CK_BUS_ETHSWACMMSG	342
+#define HSE_DIV2_CK		343
+#define CK_KER_ETR		344
+#define CK_KER_STM		345
+
+#define STM32MP25_LAST_CLK	346
+
+#define CK_SCMI_ICN_HS_MCU	0
+#define CK_SCMI_ICN_SDMMC	1
+#define CK_SCMI_ICN_DDR		2
+#define CK_SCMI_ICN_DISPLAY	3
+#define CK_SCMI_ICN_HSL		4
+#define CK_SCMI_ICN_NIC		5
+#define CK_SCMI_ICN_VID		6
+#define CK_SCMI_FLEXGEN_07	7
+#define CK_SCMI_FLEXGEN_08	8
+#define CK_SCMI_FLEXGEN_09	9
+#define CK_SCMI_FLEXGEN_10	10
+#define CK_SCMI_FLEXGEN_11	11
+#define CK_SCMI_FLEXGEN_12	12
+#define CK_SCMI_FLEXGEN_13	13
+#define CK_SCMI_FLEXGEN_14	14
+#define CK_SCMI_FLEXGEN_15	15
+#define CK_SCMI_FLEXGEN_16	16
+#define CK_SCMI_FLEXGEN_17	17
+#define CK_SCMI_FLEXGEN_18	18
+#define CK_SCMI_FLEXGEN_19	19
+#define CK_SCMI_FLEXGEN_20	20
+#define CK_SCMI_FLEXGEN_21	21
+#define CK_SCMI_FLEXGEN_22	22
+#define CK_SCMI_FLEXGEN_23	23
+#define CK_SCMI_FLEXGEN_24	24
+#define CK_SCMI_FLEXGEN_25	25
+#define CK_SCMI_FLEXGEN_26	26
+#define CK_SCMI_FLEXGEN_27	27
+#define CK_SCMI_FLEXGEN_28	28
+#define CK_SCMI_FLEXGEN_29	29
+#define CK_SCMI_FLEXGEN_30	30
+#define CK_SCMI_FLEXGEN_31	31
+#define CK_SCMI_FLEXGEN_32	32
+#define CK_SCMI_FLEXGEN_33	33
+#define CK_SCMI_FLEXGEN_34	34
+#define CK_SCMI_FLEXGEN_35	35
+#define CK_SCMI_FLEXGEN_36	36
+#define CK_SCMI_FLEXGEN_37	37
+#define CK_SCMI_FLEXGEN_38	38
+#define CK_SCMI_FLEXGEN_39	39
+#define CK_SCMI_FLEXGEN_40	40
+#define CK_SCMI_FLEXGEN_41	41
+#define CK_SCMI_FLEXGEN_42	42
+#define CK_SCMI_FLEXGEN_43	43
+#define CK_SCMI_FLEXGEN_44	44
+#define CK_SCMI_FLEXGEN_45	45
+#define CK_SCMI_FLEXGEN_46	46
+#define CK_SCMI_FLEXGEN_47	47
+#define CK_SCMI_FLEXGEN_48	48
+#define CK_SCMI_FLEXGEN_49	49
+#define CK_SCMI_FLEXGEN_50	50
+#define CK_SCMI_FLEXGEN_51	51
+#define CK_SCMI_FLEXGEN_52	52
+#define CK_SCMI_FLEXGEN_53	53
+#define CK_SCMI_FLEXGEN_54	54
+#define CK_SCMI_FLEXGEN_55	55
+#define CK_SCMI_FLEXGEN_56	56
+#define CK_SCMI_FLEXGEN_57	57
+#define CK_SCMI_FLEXGEN_58	58
+#define CK_SCMI_FLEXGEN_59	59
+#define CK_SCMI_FLEXGEN_60	60
+#define CK_SCMI_FLEXGEN_61	61
+#define CK_SCMI_FLEXGEN_62	62
+#define CK_SCMI_FLEXGEN_63	63
+#define CK_SCMI_ICN_LS_MCU	64
+#define CK_SCMI_HSE		65
+#define CK_SCMI_LSE		66
+#define CK_SCMI_HSI		67
+#define CK_SCMI_LSI		68
+#define CK_SCMI_MSI		69
+#define CK_SCMI_HSE_DIV2	70
+#define CK_SCMI_CPU1		71
+#define CK_SCMI_SYSCPU1		72
+#define CK_SCMI_PLL2		73
+#define CK_SCMI_PLL3		74
+#define CK_SCMI_RTC		75
+#define CK_SCMI_RTCCK		76
+#define CK_SCMI_ICN_APB1	77
+#define CK_SCMI_ICN_APB2	78
+#define CK_SCMI_ICN_APB3	79
+#define CK_SCMI_ICN_APB4	80
+#define CK_SCMI_ICN_APBDBG	81
+#define CK_SCMI_TIMG1		82
+#define CK_SCMI_TIMG2		83
+#define CK_SCMI_BKPSRAM		84
+#define CK_SCMI_BSEC		85
+#define CK_SCMI_BUS_ETR		87
+#define CK_SCMI_FMC		88
+#define CK_SCMI_GPIOA		89
+#define CK_SCMI_GPIOB		90
+#define CK_SCMI_GPIOC		91
+#define CK_SCMI_GPIOD		92
+#define CK_SCMI_GPIOE		93
+#define CK_SCMI_GPIOF		94
+#define CK_SCMI_GPIOG		95
+#define CK_SCMI_GPIOH		96
+#define CK_SCMI_GPIOI		97
+#define CK_SCMI_GPIOJ		98
+#define CK_SCMI_GPIOK		99
+#define CK_SCMI_GPIOZ		100
+#define CK_SCMI_HPDMA1		101
+#define CK_SCMI_HPDMA2		102
+#define CK_SCMI_HPDMA3		103
+#define CK_SCMI_HSEM		104
+#define CK_SCMI_IPCC1		105
+#define CK_SCMI_IPCC2		106
+#define CK_SCMI_LPDMA		107
+#define CK_SCMI_RETRAM		108
+#define CK_SCMI_SRAM1		109
+#define CK_SCMI_SRAM2		110
+#define CK_SCMI_LPSRAM1		111
+#define CK_SCMI_LPSRAM2		112
+#define CK_SCMI_LPSRAM3		113
+#define CK_SCMI_VDERAM		114
+#define CK_SCMI_SYSRAM		115
+#define CK_SCMI_OSPI1		116
+#define CK_SCMI_OSPI2		117
+#define CK_SCMI_TPIU		118
+#define CK_SCMI_SYSDBG		119
+#define CK_SCMI_SYSATB		120
+#define CK_SCMI_TSDBG		121
+#define CK_SCMI_BUS_STM		122
+#define CK_SCMI_KER_STM		123
+#define CK_SCMI_KER_ETR		124
+
+#endif /* _DT_BINDINGS_STM32MP25_CLKS_H_ */
diff --git a/include/dt-bindings/gpio/gpio.h b/include/dt-bindings/gpio/gpio.h
index c029467e82..5566e58196 100644
--- a/include/dt-bindings/gpio/gpio.h
+++ b/include/dt-bindings/gpio/gpio.h
@@ -39,4 +39,7 @@
 /* Bit 5 express pull down */
 #define GPIO_PULL_DOWN 32
 
+/* Bit 6 express pull disable */
+#define GPIO_PULL_DISABLE 64
+
 #endif
diff --git a/include/dt-bindings/gpio/sandbox-gpio.h b/include/dt-bindings/gpio/sandbox-gpio.h
index e4bfdb3ce1..05f9836583 100644
--- a/include/dt-bindings/gpio/sandbox-gpio.h
+++ b/include/dt-bindings/gpio/sandbox-gpio.h
@@ -21,4 +21,7 @@
 /* Bit 18 express GPIO output is active */
 #define GPIO_OUT_ACTIVE		0x40000
 
+/* Bit 19 express GPIO set as alternate function */
+#define GPIO_AF			0x80000
+
 #endif
diff --git a/include/dt-bindings/pinctrl/stm32-pinfunc.h b/include/dt-bindings/pinctrl/stm32-pinfunc.h
index e6fb8ada3f..d078ae309a 100644
--- a/include/dt-bindings/pinctrl/stm32-pinfunc.h
+++ b/include/dt-bindings/pinctrl/stm32-pinfunc.h
@@ -26,6 +26,7 @@
 #define AF14	0xf
 #define AF15	0x10
 #define ANALOG	0x11
+#define RSVD    0x12
 
 /* define Pins number*/
 #define PIN_NO(port, line)	(((port) - 'A') * 0x10 + (line))
@@ -37,6 +38,9 @@
 #define STM32MP_PKG_AB	0x2
 #define STM32MP_PKG_AC	0x4
 #define STM32MP_PKG_AD	0x8
+#define STM32MP_PKG_AI	0x100
+#define STM32MP_PKG_AK	0x400
+#define STM32MP_PKG_AL	0x800
 
 #endif /* _DT_BINDINGS_STM32_PINFUNC_H */
 
diff --git a/include/dt-bindings/pinctrl/stm32mp13-hdp.h b/include/dt-bindings/pinctrl/stm32mp13-hdp.h
new file mode 100644
index 0000000000..4d233da8e1
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp13-hdp.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clément Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_HDP_H
+#define _DT_BINDINGS_STM32MP13_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			 "0"
+#define HDP0_PWR_STOP_FORBIDDEN			 "1"
+#define HDP0_PWR_STDBY_WAKEUP			 "2"
+#define HDP0_PWR_ENCOMP_VDDCORE			 "3"
+#define HDP0_BSEC_OUT_SEC_NIDEN			 "4"
+#define HDP0_AIEC_SYS_WAKEUP			 "5"
+#define HDP0_DDRCTRL_LP_REQ			 "8"
+#define HDP0_PWR_DDR_RET_ENABLE_N		 "9"
+#define HDP0_DTS_CLK_PTAT			 "10"
+#define HDP0_SRAM3CTRL_TAMP_ERASE_ACT		 "12"
+#define HDP0_GPOVAL_0				 "15"
+
+#define HDP1_PWR_SEL_VTH_VDDCPU			 "0"
+#define HDP1_PWR_MPU_RAM_LOWSPEED		 "1"
+#define HDP1_CA7_NAXIERRIRQ			 "2"
+#define HDP1_PWR_OKIN_MR			 "3"
+#define HDP1_BSEC_OUT_SEC_DBGEN			 "4"
+#define HDP1_AIEC_C1_WAKEUP			 "5"
+#define HDP1_RCC_PWRDS_MPU			 "6"
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		 "8"
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		 "9"
+#define HDP1_SRAM3CTRL_HW_ERASE_ACT		 "12"
+#define HDP1_NIC400_S0_BREADY			 "13"
+#define HDP1_GPOVAL_1				 "15"
+
+#define HDP2_PWR_PWRWAKE_MPU			 "0"
+#define HDP2_PWR_MPU_CLOCK_DISABLE_ACK		 "1"
+#define HDP2_CA7_NDBGRESET_I			 "2"
+#define HDP2_BSEC_IN_RSTCORE_N			 "4"
+#define HDP2_BSEC_OUT_SEC_BSC_DIS		 "5"
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		 "8"
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		 "9"
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		 "10"
+#define HDP2_SRAM3CTRL_SW_ERASE_ACT		 "12"
+#define HDP2_NIC400_S0_BVALID			 "13"
+#define HDP2_GPOVAL_2				 "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCORE		 "0"
+#define HDP3_PWR_MPU_CLOCK_DISABLE_REQ		 "1"
+#define HDP3_CA7_NPMUIRQ0			 "2"
+#define HDP3_CA7_NFIQOUT0			 "3"
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		 "4"
+#define HDP3_BSEC_OUT_SEC_JTAG_DIS		 "5"
+#define HDP3_RCC_PWRDS_SYS			 "6"
+#define HDP3_SRAM3CTRL_TAMP_ERASE_REQ		 "7"
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE0 "8"
+#define HDP3_DTS_VALOBUS1_0			 "10"
+#define HDP3_DTS_VALOBUS2_0			 "11"
+#define HDP3_TAMP_POTENTIAL_TAMP_ERFCFG		 "12"
+#define HDP3_NIC400_S0_WREADY			 "13"
+#define HDP3_NIC400_S0_RREADY			 "14"
+#define HDP3_GPOVAL_3				 "15"
+
+#define HDP4_PWR_STOP2_ACTIVE			 "1"
+#define HDP4_CA7_NL2RESET_I			 "2"
+#define HDP4_CA7_NPORESET_VARM_I		 "3"
+#define HDP4_BSEC_OUT_SEC_DFTEN			 "4"
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		 "5"
+#define HDP4_ETH1_OUT_PMT_INTR_O		 "6"
+#define HDP4_ETH2_OUT_PMT_INTR_O		 "7"
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE1 "8"
+#define HDP4_DDRCTRL_CACTIVE_0			 "9"
+#define HDP4_DTS_VALOBUS1_1			 "10"
+#define HDP4_DTS_VALOBUS2_1			 "11"
+#define HDP4_TAMP_NRESET_SRAM_ERCFG		 "12"
+#define HDP4_NIC400_S0_WLAST			 "13"
+#define HDP4_NIC400_S0_RLAST			 "14"
+#define HDP4_GPOVAL_4				 "15"
+
+#define HDP5_CA7_STANDBYWFIL2			 "0"
+#define HDP5_PWR_VTH_VDDCORE_ACK		 "1"
+#define HDP5_CA7_NCORERESET_I			 "2"
+#define HDP5_CA7_NIRQOUT0			 "3"
+#define HDP5_BSEC_IN_PWROK			 "4"
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		 "5"
+#define HDP5_ETH1_OUT_LPI_INTR_O		 "6"
+#define HDP5_ETH2_OUT_LPI_INTR_O		 "7"
+#define HDP5_DDRCTRL_CACTIVE_DDRC		 "8"
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		 "9"
+#define HDP5_DTS_VALOBUS1_2			 "10"
+#define HDP5_DTS_VALOBUS2_2			 "11"
+#define HDP5_PKA_PKA_ITAMP_OUT			 "12"
+#define HDP5_NIC400_S0_WVALID			 "13"
+#define HDP5_NIC400_S0_RVALID			 "14"
+#define HDP5_GPOVAL_5				 "15"
+
+#define HDP6_CA7_STANDBYWFE0			 "0"
+#define HDP6_PWR_VTH_VDDCPU_ACK			 "1"
+#define HDP6_CA7_EVENTO				 "2"
+#define HDP6_BSEC_IN_TAMPER_DET			 "4"
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		 "5"
+#define HDP6_ETH1_OUT_MAC_SPEED_O1		 "6"
+#define HDP6_ETH2_OUT_MAC_SPEED_O1		 "7"
+#define HDP6_DDRCTRL_CSYSACK_DDRC		 "8"
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		 "9"
+#define HDP6_DTS_VALOBUS1_3			 "10"
+#define HDP6_DTS_VALOBUS2_3			 "11"
+#define HDP6_SAES_TAMPER_OUT			 "12"
+#define HDP6_NIC400_S0_AWREADY			 "13"
+#define HDP6_NIC400_S0_ARREADY			 "14"
+#define HDP6_GPOVAL_6				 "15"
+
+#define HDP7_CA7_STANDBYWFI0			 "0"
+#define HDP7_PWR_RCC_VCPU_RDY			 "1"
+#define HDP7_CA7_EVENTI				 "2"
+#define HDP7_CA7_DBGACK0			 "3"
+#define HDP7_BSEC_OUT_FUSE_OK			 "4"
+#define HDP7_BSEC_OUT_SEC_SPIDEN		 "5"
+#define HDP7_ETH1_OUT_MAC_SPEED_O0		 "6"
+#define HDP7_ETH2_OUT_MAC_SPEED_O0		 "7"
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		 "8"
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		 "9"
+#define HDP7_DTS_VALOBUS1_4			 "10"
+#define HDP7_DTS_VALOBUS2_4			 "11"
+#define HDP7_RNG_TAMPER_OUT			 "12"
+#define HDP7_NIC400_S0_AWAVALID			 "13"
+#define HDP7_NIC400_S0_ARAVALID			 "14"
+#define HDP7_GPOVAL_7				 "15"
+
+#endif /* _DT_BINDINGS_STM32MP13_HDP_H */
diff --git a/include/dt-bindings/pinctrl/stm32mp15-hdp.h b/include/dt-bindings/pinctrl/stm32mp15-hdp.h
new file mode 100644
index 0000000000..b761cd66b0
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp15-hdp.h
@@ -0,0 +1,116 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clément Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP15_HDP_H
+#define _DT_BINDINGS_STM32MP15_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			 "0"
+#define HDP0_CM4_SLEEPDEEP			 "1"
+#define HDP0_PWR_STDBY_WKUP			 "2"
+#define HDP0_PWR_ENCOMP_VDDCORE			 "3"
+#define HDP0_BSEC_OUT_SEC_NIDEN			 "4"
+#define HDP0_RCC_CM4_SLEEPDEEP			 "6"
+#define HDP0_GPU_DBG7				 "7"
+#define HDP0_DDRCTRL_LP_REQ			 "8"
+#define HDP0_PWR_DDR_RET_ENABLE_N		 "9"
+#define HDP0_DTS_CLK_PTAT			 "10"
+#define HDP0_GPOVAL_0				 "15"
+
+#define HDP1_PWR_PWRWAKE_MCU			 "0"
+#define HDP1_CM4_HALTED				 "1"
+#define HDP1_CA7_NAXIERRIRQ			 "2"
+#define HDP1_PWR_OKIN_MR			 "3"
+#define HDP1_BSEC_OUT_SEC_DBGEN			 "4"
+#define HDP1_EXTI_SYS_WAKEUP			 "5"
+#define HDP1_RCC_PWRDS_MPU			 "6"
+#define HDP1_GPU_DBG6				 "7"
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		 "8"
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		 "9"
+#define HDP1_GPOVAL_1				 "15"
+
+#define HDP2_PWR_PWRWAKE_MPU			 "0"
+#define HDP2_CM4_RXEV				 "1"
+#define HDP2_CA7_NPMUIRQ1			 "2"
+#define HDP2_CA7_NFIQOUT1			 "3"
+#define HDP2_BSEC_IN_RSTCORE_N			 "4"
+#define HDP2_EXTI_C2_WAKEUP			 "5"
+#define HDP2_RCC_PWRDS_MCU			 "6"
+#define HDP2_GPU_DBG5				 "7"
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		 "8"
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		 "9"
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		 "10"
+#define HDP2_GPOVAL_2				 "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCORE		 "0"
+#define HDP3_CM4_TXEV				 "1"
+#define HDP3_CA7_NPMUIRQ0			 "2"
+#define HDP3_CA7_NFIQOUT0			 "3"
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		 "4"
+#define HDP3_EXTI_C1_WAKEUP			 "5"
+#define HDP3_RCC_PWRDS_SYS			 "6"
+#define HDP3_GPU_DBG4				 "7"
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE0 "8"
+#define HDP3_DDRCTRL_CACTIVE_1			 "9"
+#define HDP3_DTS_VALOBUS1_0			 "10"
+#define HDP3_DTS_VALOBUS2_0			 "11"
+#define HDP3_GPOVAL_3				 "15"
+
+#define HDP4_PWR_PDDS_NOT_CSTBYDIS		 "0"
+#define HDP4_CM4_SLEEPING			 "1"
+#define HDP4_CA7_NRESET1			 "2"
+#define HDP4_CA7_NIRQOUT1			 "3"
+#define HDP4_BSEC_OUT_SEC_DFTEN			 "4"
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		 "5"
+#define HDP4_ETH_OUT_PMT_INTR_O			 "6"
+#define HDP4_GPU_DBG3				 "7"
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELFREF_TYPE1 "8"
+#define HDP4_DDRCTRL_CACTIVE_0			 "9"
+#define HDP4_DTS_VALOBUS1_1			 "10"
+#define HDP4_DTS_VALOBUS2_1			 "11"
+#define HDP4_GPOVAL_4				 "15"
+
+#define HDP5_CA7_STANDBYWFIL2			 "0"
+#define HDP5_PWR_VTH_VDDCORE_ACK		 "1"
+#define HDP5_CA7_NRESET0			 "2"
+#define HDP5_CA7_NIRQOUT0			 "3"
+#define HDP5_BSEC_IN_PWROK			 "4"
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		 "5"
+#define HDP5_ETH_OUT_LPI_INTR_O			 "6"
+#define HDP5_GPU_DBG2				 "7"
+#define HDP5_DDRCTRL_CACTIVE_DDRC		 "8"
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		 "9"
+#define HDP5_DTS_VALOBUS1_2			 "10"
+#define HDP5_DTS_VALOBUS2_2			 "11"
+#define HDP5_GPOVAL_5				 "15"
+
+#define HDP6_CA7_STANDBYWFI1			 "0"
+#define HDP6_CA7_STANDBYWFE1			 "1"
+#define HDP6_CA7_EVENTO				 "2"
+#define HDP6_CA7_DBGACK1			 "3"
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		 "5"
+#define HDP6_ETH_OUT_MAC_SPEED_O1		 "6"
+#define HDP6_GPU_DBG1				 "7"
+#define HDP6_DDRCTRL_CSYSACK_DDRC		 "8"
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		 "9"
+#define HDP6_DTS_VALOBUS1_3			 "10"
+#define HDP6_DTS_VALOBUS2_3			 "11"
+#define HDP6_GPOVAL_6				 "15"
+
+#define HDP7_CA7_STANDBYWFI0			 "0"
+#define HDP7_CA7_STANDBYWFE0			 "1"
+#define HDP7_CA7_DBGACK0			 "3"
+#define HDP7_BSEC_OUT_FUSE_OK			 "4"
+#define HDP7_BSEC_OUT_SEC_SPIDEN		 "5"
+#define HDP7_ETH_OUT_MAC_SPEED_O0		 "6"
+#define HDP7_GPU_DBG0				 "7"
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		 "8"
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		 "9"
+#define HDP7_DTS_VALOBUS1_4			 "10"
+#define HDP7_DTS_VALOBUS2_4			 "11"
+#define HDP7_GPOVAL_7				 "15"
+
+#endif /* _DT_BINDINGS_STM32MP15_HDP_H */
diff --git a/include/dt-bindings/pinctrl/stm32mp25-hdp.h b/include/dt-bindings/pinctrl/stm32mp25-hdp.h
new file mode 100644
index 0000000000..3f1bbb6bc3
--- /dev/null
+++ b/include/dt-bindings/pinctrl/stm32mp25-hdp.h
@@ -0,0 +1,144 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ * Author: Clément Le Goffic <clement.legoffic@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_HDP_H
+#define _DT_BINDINGS_STM32MP25_HDP_H
+
+/* define a macro for each function a HDP pin can transmit */
+#define HDP0_PWR_PWRWAKE_SYS			     "0"
+#define HDP0_CPU2_SLEEP_DEEP			     "1"
+#define HDP0_BSEC_OUT_TST_SDR_UNLOCK_OR_DISABLE_SCAN "2"
+#define HDP0_BSEC_OUT_NIDENM			     "3"
+#define HDP0_BSEC_OUT_NIDENA			     "4"
+#define HDP0_CPU2_STATE_0			     "5"
+#define HDP0_RCC_PWRDS_SYS			     "6"
+#define HDP0_GPU_DBG7				     "7"
+#define HDP0_DDRSS_CSYSREQ_DDRC			     "8"
+#define HDP0_DDRSS_DFI_PHYUPD_REQ		     "9"
+#define HDP0_CPU3_SLEEP_DEEP			     "10"
+#define HDP0_D2_GBL_PER_CLK_BUS_REQ		     "11"
+#define HDP0_PCIE_USB_CXPL_DEBUG_INFO_EI_0	     "12"
+#define HDP0_PCIE_USB_CXPL_DEBUG_INFO_EI_8	     "13"
+#define HDP0_D3_STATE_0				     "14"
+#define HDP0_GPOVAL_0				     "15"
+
+#define HDP1_PWR_PWRWAKE_CPU2			     "0"
+#define HDP1_CPU2_HALTED			     "1"
+#define HDP1_CPU2_STATE_1			     "2"
+#define HDP1_BSEC_OUT_DBGENM			     "3"
+#define HDP1_BSEC_OUT_DBGENA			     "4"
+#define HDP1_EXTI1_SYS_WAKEUP			     "5"
+#define HDP1_RCC_PWRDS_CPU2			     "6"
+#define HDP1_GPU_DBG6				     "7"
+#define HDP1_DDRSS_CSYSACK_DDRC			     "8"
+#define HDP1_DDRSS_DFI_PHYMSTR_REQ		     "9"
+#define HDP1_CPU3_HALTED			     "10"
+#define HDP1_D2_GBL_PER_DMA_REQ			     "11"
+#define HDP1_PCIE_USB_CXPL_DEBUG_INFO_EI_1	     "12"
+#define HDP1_PCIE_USB_CXPL_DEBUG_INFO_EI_9	     "13"
+#define HDP1_D3_STATE_1				     "14"
+#define HDP1_GPOVAL_1				     "15"
+
+#define HDP2_PWR_PWRWAKE_CPU1			     "0"
+#define HDP2_CPU2_RXEV				     "1"
+#define HDP2_CPU1_NPMUIRQ1			     "2"
+#define HDP2_CPU1_NFIQOUT1			     "3"
+#define HDP2_BSEC_OUT_SHDBGEN			     "4"
+#define HDP2_EXTI1_CPU2_WAKEUP			     "5"
+#define HDP2_RCC_PWRDS_CPU1			     "6"
+#define HDP2_GPU_DBG5				     "7"
+#define HDP2_DDRSS_CACTIVE_DDRC			     "8"
+#define HDP2_DDRSS_DFI_LP_REQ			     "9"
+#define HDP2_CPU3_RXEV				     "10"
+#define HDP2_HPDMA1_CLK_BUS_REQ			     "11"
+#define HDP2_PCIE_USB_CXPL_DEBUG_INFO_EI_2	     "12"
+#define HDP2_PCIE_USB_CXPL_DEBUG_INFO_EI_10	     "13"
+#define HDP2_D3_STATE_2				     "14"
+#define HDP2_GPOVAL_2				     "15"
+
+#define HDP3_PWR_SEL_VTH_VDDCPU			     "0"
+#define HDP3_CPU2_TXEV				     "1"
+#define HDP3_CPU1_NPMUIRQ0			     "2"
+#define HDP3_CPU1_NFIQOUT0			     "3"
+#define HDP3_BSEC_OUT_DDBGEN			     "4"
+#define HDP3_EXTI1_CPU1_WAKEUP			     "5"
+#define HDP3_CPU3_STATE_0			     "6"
+#define HDP3_GPU_DBG4				     "7"
+#define HDP3_DDRSS_MCDCG_EN			     "8"
+#define HDP3_DDRSS_DFI_FREQ_0			     "9"
+#define HDP3_CPU3_TXEV				     "10"
+#define HDP3_HPDMA2_CLK_BUS_REQ			     "11"
+#define HDP3_PCIE_USB_CXPL_DEBUG_INFO_EI_3	     "12"
+#define HDP3_PCIE_USB_CXPL_DEBUG_INFO_EI_11	     "13"
+#define HDP3_D1_STATE_0				     "14"
+#define HDP3_GPOVAL_3				     "15"
+
+#define HDP4_PWR_SEL_VTH_VDDCORE		     "0"
+#define HDP4_CPU2_SLEEPING			     "1"
+#define HDP4_CPU1_EVENTO			     "2"
+#define HDP4_CPU1_NIRQOUT1			     "3"
+#define HDP4_BSEC_OUT_SPNIDENA			     "4"
+#define HDP4_EXTI2_D3_WAKEUP			     "5"
+#define HDP4_ETH1_OUT_PMT_INTR_O		     "6"
+#define HDP4_GPU_DBG3				     "7"
+#define HDP4_DDRSS_DPHYCG_EN			     "8"
+#define HDP4_DDRSS_OBSP0			     "9"
+#define HDP4_CPU3_SLEEPING			     "10"
+#define HDP4_HPDMA3_CLK_BUS_REQ			     "11"
+#define HDP4_PCIE_USB_CXPL_DEBUG_INFO_EI_4	     "12"
+#define HDP4_PCIE_USB_CXPL_DEBUG_INFO_EI_12	     "13"
+#define HDP4_D1_STATE_1				     "14"
+#define HDP4_GPOVAL_4				     "15"
+
+#define HDP5_CPU1_STANDBY_WFIL2			     "0"
+#define HDP5_CPU1_NIRQOUT0			     "3"
+#define HDP5_BSEC_OUT_SPIDENA			     "4"
+#define HDP5_EXTI2_CPU3_WAKEUP			     "5"
+#define HDP5_ETH1_OUT_LPI_INTR_O		     "6"
+#define HDP5_GPU_DBG2				     "7"
+#define HDP5_DDRCTRL_DFI_INIT_START		     "8"
+#define HDP5_DDRSS_OBSP1			     "9"
+#define HDP5_CPU3_STATE_1			     "10"
+#define HDP5_D3_GBL_PER_CLK_BUS_REQ		     "11"
+#define HDP5_PCIE_USB_CXPL_DEBUG_INFO_EI_5	     "12"
+#define HDP5_PCIE_USB_CXPL_DEBUG_INFO_EI_13	     "13"
+#define HDP5_D1_STATE_2				     "14"
+#define HDP5_GPOVAL_5				     "15"
+
+#define HDP6_CPU1_STANDBY_WFI1			     "0"
+#define HDP6_CPU1_STANDBY_WFE1			     "1"
+#define HDP6_CPU1_HALTED1			     "2"
+#define HDP6_CPU1_NAXIERRIRQ			     "3"
+#define HDP6_BSEC_OUT_SPNIDENM			     "4"
+#define HDP6_EXTI2_CPU2_WAKEUP			     "5"
+#define HDP6_ETH2_OUT_PMT_INTR_O		     "6"
+#define HDP6_GPU_DBG1				     "7"
+#define HDP6_DDRSS_DFI_INIT_COMPLETE		     "8"
+#define HDP6_DDRSS_OBSP2			     "9"
+#define HDP6_D2_STATE_0				     "10"
+#define HDP6_D3_GBL_PER_DMA_REQ			     "11"
+#define HDP6_PCIE_USB_CXPL_DEBUG_INFO_EI_6	     "12"
+#define HDP6_PCIE_USB_CXPL_DEBUG_INFO_EI_14	     "13"
+#define HDP6_CPU1_STATE_0			     "14"
+#define HDP6_GPOVAL_6				     "15"
+
+#define HDP7_CPU1_STANDBY_WFI0			     "0"
+#define HDP7_CPU1_STANDBY_WFE0			     "1"
+#define HDP7_CPU1_HALTED0			     "2"
+#define HDP7_BSEC_OUT_SPIDENM			     "4"
+#define HDP7_EXTI2_CPU1__WAKEUP			     "5"
+#define HDP7_ETH2_OUT_LPI_INTR_O		     "6"
+#define HDP7_GPU_DBG0				     "7"
+#define HDP7_DDRSS_DFI_CTRLUPD_REQ		     "8"
+#define HDP7_DDRSS_OBSP3			     "9"
+#define HDP7_D2_STATE_1				     "10"
+#define HDP7_LPDMA1_CLK_BUS_REQ			     "11"
+#define HDP7_PCIE_USB_CXPL_DEBUG_INFO_EI_7	     "12"
+#define HDP7_PCIE_USB_CXPL_DEBUG_INFO_EI_15	     "13"
+#define HDP7_CPU1_STATE_1			     "14"
+#define HDP7_GPOVAL_7				     "15"
+
+#endif /* _DT_BINDINGS_STM32MP25_HDP_H */
diff --git a/include/dt-bindings/power/stm32mp25-power-domains.h b/include/dt-bindings/power/stm32mp25-power-domains.h
new file mode 100644
index 0000000000..fe5d9f40ca
--- /dev/null
+++ b/include/dt-bindings/power/stm32mp25-power-domains.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2024 - All Rights Reserved
+ */
+
+#ifndef _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_
+#define _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_
+
+#define PD_SCMI_GPU             0
+
+#endif /* _DT_BINDINGS_POWER_STM32MP25_POWER_DOMAINS_H_ */
diff --git a/include/dt-bindings/regulator/st,stm32mp13-regulator.h b/include/dt-bindings/regulator/st,stm32mp13-regulator.h
new file mode 100644
index 0000000000..8e49312f61
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp13-regulator.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2020, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_REG11		0
+#define VOLTD_SCMI_REG18		1
+#define VOLTD_SCMI_USB33		2
+#define VOLTD_SCMI_SDMMC1_IO		3
+#define VOLTD_SCMI_SDMMC2_IO		4
+#define VOLTD_SCMI_VREFBUF		5
+
+/* STPMIC1 regulators */
+#define VOLTD_SCMI_STPMIC1_BUCK1	6
+#define VOLTD_SCMI_STPMIC1_BUCK2	7
+#define VOLTD_SCMI_STPMIC1_BUCK3	8
+#define VOLTD_SCMI_STPMIC1_BUCK4	9
+#define VOLTD_SCMI_STPMIC1_LDO1	        10
+#define VOLTD_SCMI_STPMIC1_LDO2	        11
+#define VOLTD_SCMI_STPMIC1_LDO3	        12
+#define VOLTD_SCMI_STPMIC1_LDO4	        13
+#define VOLTD_SCMI_STPMIC1_LDO5	        14
+#define VOLTD_SCMI_STPMIC1_LDO6	        15
+#define VOLTD_SCMI_STPMIC1_VREFDDR	16
+#define VOLTD_SCMI_STPMIC1_BOOST	17
+#define VOLTD_SCMI_STPMIC1_PWR_SW1	18
+#define VOLTD_SCMI_STPMIC1_PWR_SW2	19
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		20
+#define VOLTD_SCMI_REGU1		21
+#define VOLTD_SCMI_REGU2		22
+#define VOLTD_SCMI_REGU3		23
+#define VOLTD_SCMI_REGU4		24
+
+#endif /*__DT_BINDINGS_REGULATOR_ST_STM32MP13_REGULATOR_H */
diff --git a/include/dt-bindings/regulator/st,stm32mp25-regulator.h b/include/dt-bindings/regulator/st,stm32mp25-regulator.h
new file mode 100644
index 0000000000..d1f0013c9a
--- /dev/null
+++ b/include/dt-bindings/regulator/st,stm32mp25-regulator.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause) */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef __DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H
+#define __DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H
+
+/* SCMI voltage domains identifiers */
+
+/* SOC Internal regulators */
+#define VOLTD_SCMI_VDDIO1		0
+#define VOLTD_SCMI_VDDIO2		1
+#define VOLTD_SCMI_VDDIO3		2
+#define VOLTD_SCMI_VDDIO4		3
+#define VOLTD_SCMI_VDDIO		4
+#define VOLTD_SCMI_UCPD			5
+#define VOLTD_SCMI_USB33		6
+#define VOLTD_SCMI_ADC			7
+#define VOLTD_SCMI_GPU			8
+#define VOLTD_SCMI_VREFBUF		9
+
+/* STPMIC2 regulators */
+#define VOLTD_SCMI_STPMIC2_BUCK1	10
+#define VOLTD_SCMI_STPMIC2_BUCK2	11
+#define VOLTD_SCMI_STPMIC2_BUCK3	12
+#define VOLTD_SCMI_STPMIC2_BUCK4	13
+#define VOLTD_SCMI_STPMIC2_BUCK5	14
+#define VOLTD_SCMI_STPMIC2_BUCK6	15
+#define VOLTD_SCMI_STPMIC2_BUCK7	16
+#define VOLTD_SCMI_STPMIC2_LDO1		17
+#define VOLTD_SCMI_STPMIC2_LDO2		18
+#define VOLTD_SCMI_STPMIC2_LDO3		19
+#define VOLTD_SCMI_STPMIC2_LDO4		20
+#define VOLTD_SCMI_STPMIC2_LDO5		21
+#define VOLTD_SCMI_STPMIC2_LDO6		22
+#define VOLTD_SCMI_STPMIC2_LDO7		23
+#define VOLTD_SCMI_STPMIC2_LDO8		24
+#define VOLTD_SCMI_STPMIC2_REFDDR	25
+
+/* External regulators */
+#define VOLTD_SCMI_REGU0		26
+#define VOLTD_SCMI_REGU1		27
+#define VOLTD_SCMI_REGU2		28
+#define VOLTD_SCMI_REGU3		29
+#define VOLTD_SCMI_REGU4		30
+
+#endif /*__DT_BINDINGS_REGULATOR_ST_STM32MP25_REGULATOR_H */
diff --git a/include/dt-bindings/reset/stm32mp13-resets.h b/include/dt-bindings/reset/stm32mp13-resets.h
new file mode 100644
index 0000000000..18ccb05db6
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp13-resets.h
@@ -0,0 +1,100 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later or BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2022 - All Rights Reserved
+ * Author: Gabriel Fernandez <gabriel.fernandez@foss.st.com> for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32MP13_RESET_H_
+#define _DT_BINDINGS_STM32MP13_RESET_H_
+
+#define TIM2_R		13568
+#define TIM3_R		13569
+#define TIM4_R		13570
+#define TIM5_R		13571
+#define TIM6_R		13572
+#define TIM7_R		13573
+#define LPTIM1_R	13577
+#define SPI2_R		13579
+#define SPI3_R		13580
+#define USART3_R	13583
+#define UART4_R		13584
+#define UART5_R		13585
+#define UART7_R		13586
+#define UART8_R		13587
+#define I2C1_R		13589
+#define I2C2_R		13590
+#define SPDIF_R		13594
+#define TIM1_R		13632
+#define TIM8_R		13633
+#define SPI1_R		13640
+#define USART6_R	13645
+#define SAI1_R		13648
+#define SAI2_R		13649
+#define DFSDM_R		13652
+#define FDCAN_R		13656
+#define LPTIM2_R	13696
+#define LPTIM3_R	13697
+#define LPTIM4_R	13698
+#define LPTIM5_R	13699
+#define SYSCFG_R	13707
+#define VREF_R		13709
+#define DTS_R		13712
+#define PMBCTRL_R	13713
+#define LTDC_R		13760
+#define DCMIPP_R	13761
+#define DDRPERFM_R	13768
+#define USBPHY_R	13776
+#define STGEN_R		13844
+#define USART1_R	13888
+#define USART2_R	13889
+#define SPI4_R		13890
+#define SPI5_R		13891
+#define I2C3_R		13892
+#define I2C4_R		13893
+#define I2C5_R		13894
+#define TIM12_R		13895
+#define TIM13_R		13896
+#define TIM14_R		13897
+#define TIM15_R		13898
+#define TIM16_R		13899
+#define TIM17_R		13900
+#define DMA1_R		13952
+#define DMA2_R		13953
+#define DMAMUX1_R	13954
+#define DMA3_R		13955
+#define DMAMUX2_R	13956
+#define ADC1_R		13957
+#define ADC2_R		13958
+#define USBO_R		13960
+#define GPIOA_R		14080
+#define GPIOB_R		14081
+#define GPIOC_R		14082
+#define GPIOD_R		14083
+#define GPIOE_R		14084
+#define GPIOF_R		14085
+#define GPIOG_R		14086
+#define GPIOH_R		14087
+#define GPIOI_R		14088
+#define TSC_R		14095
+#define PKA_R		14146
+#define SAES_R		14147
+#define CRYP1_R		14148
+#define HASH1_R		14149
+#define RNG1_R		14150
+#define AXIMC_R		14160
+#define MDMA_R		14208
+#define MCE_R		14209
+#define ETH1MAC_R	14218
+#define FMC_R		14220
+#define QSPI_R		14222
+#define SDMMC1_R	14224
+#define SDMMC2_R	14225
+#define CRC1_R		14228
+#define USBH_R		14232
+#define ETH2MAC_R	14238
+
+/* SCMI reset domain identifiers */
+#define RST_SCMI_LTDC		0
+#define RST_SCMI_MDMA		1
+
+#endif /* _DT_BINDINGS_STM32MP13_RESET_H_ */
diff --git a/include/dt-bindings/reset/stm32mp25-resets.h b/include/dt-bindings/reset/stm32mp25-resets.h
new file mode 100644
index 0000000000..9e4d44df5b
--- /dev/null
+++ b/include/dt-bindings/reset/stm32mp25-resets.h
@@ -0,0 +1,166 @@
+/* SPDX-License-Identifier: GPL-2.0-only OR BSD-3-Clause */
+/*
+ * Copyright (C) STMicroelectronics 2023 - All Rights Reserved
+ * Author(s): Gabriel Fernandez <gabriel.fernandez@foss.st.com>
+ */
+
+#ifndef _DT_BINDINGS_STM32MP25_RESET_H_
+#define _DT_BINDINGS_STM32MP25_RESET_H_
+
+#define SYS_R		8192
+#define C1_R		8224
+#define C1P1POR_R	8256
+#define C1P1_R		8257
+#define C2_R		8288
+#define C2_HOLDBOOT_R	8608
+#define C1_HOLDBOOT_R	8609
+#define VSW_R		8735
+#define C1MS_R		8840
+#define IWDG2_KER_R	9106
+#define IWDG4_KER_R	9234
+#define C3_R		9344
+#define DDRCP_R		9888
+#define DDRCAPB_R	9920
+#define DDRPHYCAPB_R	9952
+#define DDRCFG_R	10016
+#define DDR_R		10048
+#define OSPI1_R		10400
+#define OSPI1DLL_R	10416
+#define OSPI2_R		10432
+#define OSPI2DLL_R	10448
+#define FMC_R		10464
+#define DBG_R		10508
+#define GPIOA_R		10592
+#define GPIOB_R		10624
+#define GPIOC_R		10656
+#define GPIOD_R		10688
+#define GPIOE_R		10720
+#define GPIOF_R		10752
+#define GPIOG_R		10784
+#define GPIOH_R		10816
+#define GPIOI_R		10848
+#define GPIOJ_R		10880
+#define GPIOK_R		10912
+#define GPIOZ_R		10944
+#define HPDMA1_R	10976
+#define HPDMA2_R	11008
+#define HPDMA3_R	11040
+#define LPDMA_R		11072
+#define HSEM_R		11104
+#define IPCC1_R		11136
+#define IPCC2_R		11168
+#define IS2M_R		11360
+#define SSMOD_R		11392
+#define TIM1_R		14336
+#define TIM2_R		14368
+#define TIM3_R		14400
+#define TIM4_R		14432
+#define TIM5_R		14464
+#define TIM6_R		14496
+#define TIM7_R		14528
+#define TIM8_R		14560
+#define TIM10_R		14592
+#define TIM11_R		14624
+#define TIM12_R		14656
+#define TIM13_R		14688
+#define TIM14_R		14720
+#define TIM15_R		14752
+#define TIM16_R		14784
+#define TIM17_R		14816
+#define TIM20_R		14848
+#define LPTIM1_R	14880
+#define LPTIM2_R	14912
+#define LPTIM3_R	14944
+#define LPTIM4_R	14976
+#define LPTIM5_R	15008
+#define SPI1_R		15040
+#define SPI2_R		15072
+#define SPI3_R		15104
+#define SPI4_R		15136
+#define SPI5_R		15168
+#define SPI6_R		15200
+#define SPI7_R		15232
+#define SPI8_R		15264
+#define SPDIFRX_R	15296
+#define USART1_R	15328
+#define USART2_R	15360
+#define USART3_R	15392
+#define UART4_R		15424
+#define UART5_R		15456
+#define USART6_R	15488
+#define UART7_R		15520
+#define UART8_R		15552
+#define UART9_R		15584
+#define LPUART1_R	15616
+#define I2C1_R		15648
+#define I2C2_R		15680
+#define I2C3_R		15712
+#define I2C4_R		15744
+#define I2C5_R		15776
+#define I2C6_R		15808
+#define I2C7_R		15840
+#define I2C8_R		15872
+#define SAI1_R		15904
+#define SAI2_R		15936
+#define SAI3_R		15968
+#define SAI4_R		16000
+#define MDF1_R		16064
+#define MDF2_R		16096
+#define FDCAN_R		16128
+#define HDP_R		16160
+#define ADC12_R		16192
+#define ADC3_R		16224
+#define ETH1_R		16256
+#define ETH2_R		16288
+#define USB2_R		16352
+#define USB2PHY1_R	16384
+#define USB2PHY2_R	16416
+#define USB3DR_R	16448
+#define USB3PCIEPHY_R	16480
+#define PCIE_R		16512
+#define USBTC_R		16544
+#define ETHSW_R		16576
+#define SDMMC1_R	16768
+#define SDMMC1DLL_R	16784
+#define SDMMC2_R	16800
+#define SDMMC2DLL_R	16816
+#define SDMMC3_R	16832
+#define SDMMC3DLL_R	16848
+#define GPU_R		16864
+#define LTDC_R		16896
+#define DSI_R		16928
+#define LVDS_R		17024
+#define CSI_R		17088
+#define DCMIPP_R	17120
+#define CCI_R		17152
+#define VDEC_R		17184
+#define VENC_R		17216
+#define RNG_R		17280
+#define PKA_R		17312
+#define SAES_R		17344
+#define HASH_R		17376
+#define CRYP1_R		17408
+#define CRYP2_R		17440
+#define WWDG1_R		17632
+#define WWDG2_R		17664
+#define VREF_R		17728
+#define DTS_R		17760
+#define CRC_R		17824
+#define SERC_R		17856
+#define OSPIIOM_R	17888
+#define I3C1_R		17984
+#define I3C2_R		18016
+#define I3C3_R		18048
+#define I3C4_R		18080
+
+#define RST_SCMI_C1_R		0
+#define RST_SCMI_C2_R		1
+#define RST_SCMI_C1_HOLDBOOT_R	2
+#define RST_SCMI_C2_HOLDBOOT_R	3
+#define RST_SCMI_FMC		4
+#define RST_SCMI_OSPI1		5
+#define RST_SCMI_OSPI1DLL	6
+#define RST_SCMI_OSPI2		7
+#define RST_SCMI_OSPI2DLL	8
+
+#endif /* _DT_BINDINGS_STM32MP25_RESET_H_ */
diff --git a/include/dt-bindings/rtc/rtc-stm32.h b/include/dt-bindings/rtc/rtc-stm32.h
new file mode 100644
index 0000000000..2fd78c2e62
--- /dev/null
+++ b/include/dt-bindings/rtc/rtc-stm32.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for STM32_RTC bindings.
+ */
+
+#ifndef _DT_BINDINGS_RTC_RTC_STM32_H
+#define _DT_BINDINGS_RTC_RTC_STM32_H
+
+#define RTC_NO_OUT	0
+#define RTC_OUT1	1
+#define RTC_OUT2	2
+#define RTC_OUT2_RMP	3
+
+#endif
diff --git a/include/dt-bindings/soc/stm32-hdp.h b/include/dt-bindings/soc/stm32-hdp.h
new file mode 100644
index 0000000000..d986653272
--- /dev/null
+++ b/include/dt-bindings/soc/stm32-hdp.h
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_CM4_SLEEPDEEP			1
+#define HDP0_PWR_STDBY_WKUP			2
+#define HDP0_PWR_ENCOMP_VDDCORE			3
+#define HDP0_BSEC_OUT_SEC_NIDEN			4
+#define HDP0_RCC_CM4_SLEEPDEEP			6
+#define HDP0_GPU_DBG7				7
+#define HDP0_DDRCTRL_LP_REQ			8
+#define HDP0_PWR_DDR_RET_ENABLE_N		9
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_PWRWAKE_MCU			0
+#define HDP1_CM4_HALTED				1
+#define HDP1_CA7_NAXIERRIRQ			2
+#define HDP1_PWR_OKIN_MR			3
+#define HDP1_BSEC_OUT_SEC_DBGEN			4
+#define HDP1_EXTI_SYS_WAKEUP			5
+#define HDP1_RCC_PWRDS_MPU			6
+#define HDP1_GPU_DBG6				7
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		8
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		9
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_MPU			0
+#define HDP2_CM4_RXEV				1
+#define HDP2_CA7_NPMUIRQ1			2
+#define HDP2_CA7_NFIQOUT1			3
+#define HDP2_BSEC_IN_RSTCORE_N			4
+#define HDP2_EXTI_C2_WAKEUP			5
+#define HDP2_RCC_PWRDS_MCU			6
+#define HDP2_GPU_DBG5				7
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		8
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		9
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		10
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CORE		0
+#define HDP3_CM4_TXEV				1
+#define HDP3_CA7_NPMUIRQ0			2
+#define HDP3_CA7_NFIQOUT0			3
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		4
+#define HDP3_EXTI_C1_WAKEUP			5
+#define HDP3_RCC_PWRDS_SYS			6
+#define HDP3_GPU_DBG4				7
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE0	8
+#define HDP3_DDRCTRL_CACTIVE_1			9
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_PDDS				0
+#define HDP4_CM4_SLEEPING			1
+#define HDP4_CA7_NRESET1			2
+#define HDP4_CA7_NIRQOUT1			3
+#define HDP4_BSEC_OUT_SEC_DFTEN			4
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		5
+#define HDP4_ETH_OUT_PMT_INTR_O			6
+#define HDP4_GPU_DBG3				7
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE1	8
+#define HDP4_DDRCTRL_CACTIVE_0			9
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CA7_STANDBYWFIL2			0
+#define HDP5_PWR_VTH_VDDCORE_ACK		1
+#define HDP5_CA7_NRESET0			2
+#define HDP5_CA7_NIRQOUT0			3
+#define HDP5_BSEC_IN_PWROK			4
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		5
+#define HDP5_ETH_OUT_LPI_INTR_O			6
+#define HDP5_GPU_DBG2				7
+#define HDP5_DDRCTRL_CACTIVE_DDRC		8
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		9
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CA7_STANDBYWFI1			0
+#define HDP6_CA7_STANDBYWFE1			1
+#define HDP6_CA7_EVENT0				2
+#define HDP6_CA7_DBGACK1			3
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		5
+#define HDP6_ETH_OUT_MAC_SPEED_O1		6
+#define HDP6_GPU_DBG1				7
+#define HDP6_DDRCTRL_CSYSACK_DDRC		8
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		9
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CA7_STANDBYWFI0			0
+#define HDP7_CA7_STANDBYWFE0			1
+#define HDP7_CA7_DBGACK0			3
+#define HDP7_BSEC_OUT_FUSE_OK			4
+#define HDP7_BSEC_OUT_SEC_SPIDEN		5
+#define HDP7_ETH_OUT_MAC_SPEED_O0		6
+#define HDP7_GPU_DBG0				7
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		8
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		9
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/dt-bindings/soc/stm32mp13-hdp.h b/include/dt-bindings/soc/stm32mp13-hdp.h
new file mode 100644
index 0000000000..091c1c8358
--- /dev/null
+++ b/include/dt-bindings/soc/stm32mp13-hdp.h
@@ -0,0 +1,133 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
+/*
+ * Copyright (C) STMicroelectronics 2018 - All Rights Reserved
+ * Author: Roullier Christophe <christophe.roullier@st.com>
+ * for STMicroelectronics.
+ */
+
+#ifndef _DT_BINDINGS_STM32_HDP_H
+#define _DT_BINDINGS_STM32_HDP_H
+
+#define STM32_HDP(port, value) ((value) << ((port) * 4))
+
+/* define HDP Pins number*/
+#define HDP0_PWR_PWRWAKE_SYS			0
+#define HDP0_PWR_STOP_FORBIDDEN			1
+#define HDP0_PWR_STDBY_WKUP			2
+#define HDP0_PWR_ENCOMP_VDDCORE			3
+#define HDP0_BSEC_OUT_SEC_NIDEN			4
+#define HDP0_AIEC_SYS_WAKEUP			5
+#define HDP0_DDRCTRL_LP_REQ			8
+#define HDP0_PWR_DDR_RET_ENABLE_N		9
+#define HDP0_DTS_CLK_PTAT			10
+#define HDP0_SRAM3CTRL_TAMP_ERASE_ACT		12
+#define HDP0_GPOVAL_0				15
+
+#define HDP1_PWR_SEL_VTH_VDDCPU			0
+#define HDP1_PWR_MPU_RAM_LOWSPEED		1
+#define HDP1_CA7_NAXIERRIRQ			2
+#define HDP1_PWR_OKIN_MR			3
+#define HDP1_BSEC_OUT_SEC_DBGEN			4
+#define HDP1_AIEC_C1_WAKEUP			5
+#define HDP1_RCC_PWRDS_MPU			6
+#define HDP1_DDRCTRL_DFI_CTRLUPD_REQ		8
+#define HDP1_DDRCTRL_CACTIVE_DDRC_ASR		9
+#define HDP1_SRAM3CTRL_HW_ERASE_ACT		12
+#define HDP1_NIC400_S0_BREADY			13
+#define HDP1_GPOVAL_1				15
+
+#define HDP2_PWR_PWRWAKE_MPU			0
+#define HDP2_PWR_MPU_CLOCK_DISABLE_ACK		1
+#define HDP2_CA7_NDGBRESET_I			2
+#define HDP2_BSEC_IN_RSTCORE_N			4
+#define HDP2_BSEC_OUT_SEC_BSC_DIS		5
+#define HDP2_DDRCTRL_DFI_INIT_COMPLETE		8
+#define HDP2_DDRCTRL_PERF_OP_IS_REFRESH		9
+#define HDP2_DDRCTRL_GSKP_DFI_LP_REQ		10
+#define HDP2_SRAM3CTRL_SW_ERASE_ACT		12
+#define HDP2_NIC400_S0_BVALID			13
+#define HDP2_GPOVAL_2				15
+
+#define HDP3_PWR_SEL_VTH_VDD_CORE		0
+#define HDP3_PWR_MPU_CLOCK_DISABLE_REQ		1
+#define HDP3_CA7_NPMUIRQ0			2
+#define HDP3_CA7_NFIQOUT0			3
+#define HDP3_BSEC_OUT_SEC_DFTLOCK		4
+#define HDP3_BSEC_OUT_SEC_JTAG_DIS		5
+#define HDP3_RCC_PWRDS_SYS			6
+#define HDP3_SRAM3CTRL_TAMP_ERASE_REQ		7
+#define HDP3_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE0	8
+#define HDP3_DTS_VALOBUS1_0			10
+#define HDP3_DTS_VALOBUS2_0			11
+#define HDP3_TAMP_POTENTIAL_TAMP_ERFCFG		12
+#define HDP3_NIC400_S0_WREADY			13
+#define HDP3_NIC400_S0_RREADY			14
+#define HDP3_GPOVAL_3				15
+
+#define HDP4_PWR_STOP2_ACTIVE			1
+#define HDP4_CA7_NL2RESET1			2
+#define HDP4_CA7_NPORESET_VARM_I		3
+#define HDP4_BSEC_OUT_SEC_DFTEN			4
+#define HDP4_BSEC_OUT_SEC_DBGSWENABLE		5
+#define HDP4_ETH1_OUT_PMT_INTR_O		6
+#define HDP4_ETH2_OUT_PMT_INTR_O		7
+#define HDP4_DDRCTRL_STAT_DDRC_REG_SELREF_TYPE1	8
+#define HDP4_DDRCTRL_CACTIVE_0			9
+#define HDP4_DTS_VALOBUS1_1			10
+#define HDP4_DTS_VALOBUS2_1			11
+#define HDP4_TAMP_NRESET_SRAM_ERCFG		12
+#define HDP4_NIC400_S0_WLAST			13
+#define HDP4_NIC400_S0_RLAST			14
+#define HDP4_GPOVAL_4				15
+
+#define HDP5_CA7_STANDBYWFIL2			0
+#define HDP5_PWR_VTH_VDDCORE_ACK		1
+#define HDP5_CA7_NCORERESET_I			2
+#define HDP5_CA7_NIRQOUT0			3
+#define HDP5_BSEC_IN_PWROK			4
+#define HDP5_BSEC_OUT_SEC_DEVICEEN		5
+#define HDP5_ETH1_OUT_LPI_INTR_O		6
+#define HDP5_ETH2_OUT_LPI_INTR_O		7
+#define HDP5_DDRCTRL_CACTIVE_DDRC		8
+#define HDP5_DDRCTRL_WR_CREDIT_CNT		9
+#define HDP5_DTS_VALOBUS1_2			10
+#define HDP5_DTS_VALOBUS2_2			11
+#define HDP5_PKA_PKA_ITAMP_OUT			12
+#define HDP5_NIC400_S0_WVALID			13
+#define HDP5_NIC400_S0_RVALID			14
+#define HDP5_GPOVAL_5				15
+
+#define HDP6_CA7_STANDBYWFE0			0
+#define HDP6_PWR_VTH_VDDCPU_ACK			1
+#define HDP6_CA7_EVENT0				2
+#define HDP6_BSEC_IN_TAMPER_DET			4
+#define HDP6_BSEC_OUT_SEC_SPNIDEN		5
+#define HDP6_ETH1_OUT_MAC_SPEED_O1		6
+#define HDP6_ETH2_OUT_MAC_SPEED_O1		7
+#define HDP6_DDRCTRL_CSYSACK_DDRC		8
+#define HDP6_DDRCTRL_LPR_CREDIT_CNT		9
+#define HDP6_DTS_VALOBUS1_3			10
+#define HDP6_DTS_VALOBUS2_3			11
+#define HDP6_SAES_TAMPER_OUT			12
+#define HDP6_NIC400_S0_AWREADY			13
+#define HDP6_NIC400_S0_ARREADY			14
+#define HDP6_GPOVAL_6				15
+
+#define HDP7_CA7_STANDBYWFI0			0
+#define HDP7_PWR_RCC_VCPU_RDY			1
+#define HDP7_CA7_EVENTI				2
+#define HDP7_CA7_DBGACK0			3
+#define HDP7_BSEC_OUT_FUSE_OK			4
+#define HDP7_BSEC_OUT_SEC_SPIDEN		5
+#define HDP7_ETH1_OUT_MAC_SPEED_O0		6
+#define HDP7_ETH2_OUT_MAC_SPEED_O0		7
+#define HDP7_DDRCTRL_CSYSREQ_DDRC		8
+#define HDP7_DDRCTRL_HPR_CREDIT_CNT		9
+#define HDP7_DTS_VALOBUS1_4			10
+#define HDP7_DTS_VALOBUS2_4			11
+#define HDP7_RNG_TAMPER_OUT			12
+#define HDP7_NIC400_S0_AWVALID			13
+#define HDP7_NIC400_S0_ARVALID			14
+#define HDP7_GPOVAL_7				15
+
+#endif /* _DT_BINDINGS_STM32_HDP_H */
diff --git a/include/efi_api.h b/include/efi_api.h
index 9bb0d44ac8..5287fddade 100644
--- a/include/efi_api.h
+++ b/include/efi_api.h
@@ -560,6 +560,7 @@ struct efi_mac_addr {
 #define DEVICE_PATH_TYPE_HARDWARE_DEVICE	0x01
 #  define DEVICE_PATH_SUB_TYPE_MEMORY		0x03
 #  define DEVICE_PATH_SUB_TYPE_VENDOR		0x04
+#  define DEVICE_PATH_SUB_TYPE_CONTROLLER	0x05
 
 struct efi_device_path_memory {
 	struct efi_device_path dp;
@@ -574,6 +575,11 @@ struct efi_device_path_vendor {
 	u8 vendor_data[];
 } __packed;
 
+struct efi_device_path_controller {
+	struct efi_device_path dp;
+	u32 controller_number;
+} __packed;
+
 #define DEVICE_PATH_TYPE_ACPI_DEVICE		0x02
 #  define DEVICE_PATH_SUB_TYPE_ACPI_DEVICE	0x01
 
diff --git a/include/efi_loader.h b/include/efi_loader.h
index 545ba06d94..1266f42e30 100644
--- a/include/efi_loader.h
+++ b/include/efi_loader.h
@@ -1035,15 +1035,16 @@ struct efi_fw_image {
  * platforms which enable capsule updates
  *
  * @dfu_string:		String used to populate dfu_alt_info
+ * @num_images:		The number of images array entries
  * @images:		Pointer to an array of updatable images
  */
 struct efi_capsule_update_info {
 	const char *dfu_string;
+	int num_images;
 	struct efi_fw_image *images;
 };
 
 extern struct efi_capsule_update_info update_info;
-extern u8 num_image_type_guids;
 
 /**
  * Install the ESRT system table.
diff --git a/include/event.h b/include/event.h
index e8f2f55c63..8089b464b1 100644
--- a/include/event.h
+++ b/include/event.h
@@ -34,6 +34,9 @@ enum event_t {
 	/* Device tree fixups before booting */
 	EVT_FT_FIXUP,
 
+	/* To be called once, before calling main_loop() */
+	EVT_MAIN_LOOP,
+
 	EVT_COUNT
 };
 
diff --git a/include/fdt_support.h b/include/fdt_support.h
index b8380716f3..c513200205 100644
--- a/include/fdt_support.h
+++ b/include/fdt_support.h
@@ -257,6 +257,14 @@ static inline void fdt_fixup_mtdparts(void *fdt,
 }
 #endif
 
+/**
+ * copy the fixed-partition nodes from U-Boot device tree to external blob
+ *
+ * @param blob		FDT blob to update
+ * Return: 0 if ok, or non-zero on error
+ */
+int fdt_copy_fixed_partitions(void *blob);
+
 void fdt_del_node_and_alias(void *blob, const char *alias);
 
 /**
diff --git a/include/flash.h b/include/flash.h
index 95992fa689..847fe73850 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -89,6 +89,7 @@ int flash_sect_roundb(ulong *addr);
 unsigned long flash_sector_size(flash_info_t *info, flash_sect_t sect);
 void flash_cmd_reset(flash_info_t *info);
 void flash_set_verbose(uint v);
+int is_flash_available(void);
 
 /* common/flash.c */
 void flash_protect(int flag, ulong from, ulong to, flash_info_t *info);
@@ -166,6 +167,7 @@ void flash_perror(int err);
 #define AMIC_MANUFACT	0x00370037	/* AMIC    manuf. ID in D23..D16, D7..D0 */
 #define WINB_MANUFACT	0x00DA00DA	/* Winbond manuf. ID in D23..D16, D7..D0 */
 #define EON_ALT_MANU	0x001C001C	/* EON     manuf. ID in D23..D16, D7..D0 */
+#define CY_MANUFACT	0x00340034	/* Cypress manuf. IF in D23..D16, D7..D0 */
 
 /* Manufacturers inside bank 1 have ids like 0x01xx01xx */
 #define EON_MANUFACT	0x011C011C	/* EON     manuf. ID in D23..D16, D7..D0 */
diff --git a/include/fwu.h b/include/fwu.h
new file mode 100644
index 0000000000..77ec65e618
--- /dev/null
+++ b/include/fwu.h
@@ -0,0 +1,420 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#if !defined _FWU_H_
+#define _FWU_H_
+
+#include <blk.h>
+#include <efi.h>
+#include <fwu_mdata.h>
+#include <mtd.h>
+#include <uuid.h>
+
+#include <linux/types.h>
+
+struct fwu_mdata;
+struct udevice;
+
+struct fwu_mdata_gpt_blk_priv {
+	struct udevice *blk_dev;
+};
+
+struct fwu_mtd_image_info {
+	u32 start, size;
+	int bank_num, image_num;
+	char uuidbuf[UUID_STR_LEN + 1];
+};
+
+struct fwu_mdata_mtd_priv {
+	struct mtd_info *mtd;
+	char pri_label[50];
+	char sec_label[50];
+	u32 pri_offset;
+	u32 sec_offset;
+	struct fwu_mtd_image_info *fwu_mtd_images;
+};
+
+struct fwu_data {
+	uint32_t crc32;
+	uint32_t version;
+	uint32_t active_index;
+	uint32_t previous_active_index;
+	uint32_t metadata_size;
+	uint32_t boot_index;
+	uint32_t num_banks;
+	uint32_t num_images;
+	uint8_t  bank_state[4];
+	bool     trial_state;
+
+	struct fwu_mdata *fwu_mdata;
+
+	struct fwu_image_entry fwu_images[CONFIG_FWU_NUM_IMAGES_PER_BANK];
+};
+
+struct fwu_mdata_ops {
+	/**
+	 * read_mdata() - Populate the asked FWU metadata copy
+	 * @dev: FWU metadata device
+	 * @mdata: Output FWU mdata read
+	 * @primary: If primary or secondary copy of metadata is to be read
+	 * @size: Size in bytes of the metadata to be read
+	 *
+	 * Return: 0 if OK, -ve on error
+	 */
+	int (*read_mdata)(struct udevice *dev, struct fwu_mdata *mdata,
+			  bool primary, uint32_t size);
+
+	/**
+	 * write_mdata() - Write the given FWU metadata copy
+	 * @dev: FWU metadata device
+	 * @mdata: Copy of the FWU metadata to write
+	 * @primary: If primary or secondary copy of metadata is to be written
+	 * @size: Size in bytes of the metadata to be written
+	 *
+	 * Return: 0 if OK, -ve on error
+	 */
+	int (*write_mdata)(struct udevice *dev, struct fwu_mdata *mdata,
+			   bool primary, uint32_t size);
+};
+
+#define FWU_IMAGE_ACCEPTED	0x1
+
+#define FWU_BANK_INVALID	(uint8_t)0xFF
+#define FWU_BANK_VALID		(uint8_t)0xFE
+#define FWU_BANK_ACCEPTED	(uint8_t)0xFC
+
+enum {
+	PRIMARY_PART = 1,
+	SECONDARY_PART,
+	BOTH_PARTS,
+};
+
+/*
+* GUID value defined in the FWU specification for identification
+* of the FWU metadata partition.
+*/
+#define FWU_MDATA_GUID \
+	EFI_GUID(0x8a7a84a0, 0x8387, 0x40f6, 0xab, 0x41, \
+		 0xa8, 0xb9, 0xa5, 0xa6, 0x0d, 0x23)
+
+/*
+* GUID value defined in the Dependable Boot specification for
+* identification of the revert capsule, used for reverting
+* any image in the updated bank.
+*/
+#define FWU_OS_REQUEST_FW_REVERT_GUID \
+	EFI_GUID(0xacd58b4b, 0xc0e8, 0x475f, 0x99, 0xb5, \
+		 0x6b, 0x3f, 0x7e, 0x07, 0xaa, 0xf0)
+
+/*
+* GUID value defined in the Dependable Boot specification for
+* identification of the accept capsule, used for accepting
+* an image in the updated bank.
+*/
+#define FWU_OS_REQUEST_FW_ACCEPT_GUID \
+	EFI_GUID(0x0c996046, 0xbcc0, 0x4d04, 0x85, 0xec, \
+		 0xe1, 0xfc, 0xed, 0xf1, 0xc6, 0xf8)
+
+/**
+ * fwu_read_mdata() - Wrapper around fwu_mdata_ops.read_mdata()
+ */
+int fwu_read_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+		   bool primary, uint32_t size);
+
+/**
+ * fwu_write_mdata() - Wrapper around fwu_mdata_ops.write_mdata()
+ */
+int fwu_write_mdata(struct udevice *dev, struct fwu_mdata *mdata,
+		    bool primary, uint32_t size);
+
+/**
+ * fwu_get_mdata() - Read, verify and return the FWU metadata
+ *
+ * Read both the metadata copies from the storage media, verify their checksum,
+ * and ascertain that both copies match. If one of the copies has gone bad,
+ * restore it from the good copy.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata(struct fwu_mdata *mdata);
+
+/**
+ * fwu_get_active_index() - Get active_index from the FWU metadata
+ * @active_idxp: active_index value to be read
+ *
+ * Read the active_index field from the FWU metadata and place it in
+ * the variable pointed to be the function argument.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_get_active_index(uint *active_idxp);
+
+/**
+ * fwu_set_active_index() - Set active_index in the FWU metadata
+ * @active_idx: active_index value to be set
+ *
+ * Update the active_index field in the FWU metadata
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_set_active_index(uint active_idx);
+
+/**
+ * fwu_get_dfu_alt_num() - Get the dfu_alt_num to be used for capsule update
+ * @image_index:	The Image Index for the image
+ * @alt_num:		pointer to store dfu_alt_num
+ *
+ * Currently, the capsule update driver uses the DFU framework for
+ * the updates. This function gets the DFU alt number which is to
+ * be used for capsule update.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_get_dfu_alt_num(u8 image_index, u8 *alt_num);
+
+/**
+ * fwu_revert_boot_index() - Revert the active index in the FWU metadata
+ *
+ * Revert the active_index value in the FWU metadata, by swapping the values
+ * of active_index and previous_active_index in both copies of the
+ * FWU metadata.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_revert_boot_index(void);
+
+/**
+ * fwu_accept_image() - Set the Acceptance bit for the image
+ * @img_type_id: GUID of the image type for which the accepted bit is to be
+ *               cleared
+ * @bank: Bank of which the image's Accept bit is to be set
+ *
+ * Set the accepted bit for the image specified by the img_guid parameter. This
+ * indicates acceptance of image for subsequent boots by some governing component
+ * like OS(or firmware).
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_accept_image(efi_guid_t *img_type_id, u32 bank);
+
+/**
+ * fwu_clear_accept_image() - Clear the Acceptance bit for the image
+ * @img_type_id: GUID of the image type for which the accepted bit is to be
+ *               cleared
+ * @bank: Bank of which the image's Accept bit is to be cleared
+ *
+ * Clear the accepted bit for the image type specified by the img_type_id parameter.
+ * This function is called after the image has been updated. The accepted bit is
+ * cleared to be set subsequently after passing the image acceptance criteria, by
+ * either the OS(or firmware)
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_clear_accept_image(efi_guid_t *img_type_id, u32 bank);
+
+/**
+ * fwu_plat_get_alt_num() - Get the DFU Alt Num for the image from the platform
+ * @dev: FWU device
+ * @image_guid: Image GUID for which DFU alt number needs to be retrieved
+ * @alt_num: Pointer to the alt_num
+ *
+ * Get the DFU alt number from the platform for the image specified by the
+ * image GUID.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_plat_get_alt_num(struct udevice *dev, efi_guid_t *image_guid,
+			 u8 *alt_num);
+
+/**
+ * fwu_plat_get_update_index() - Get the value of the update bank
+ * @update_idx: Bank number to which images are to be updated
+ *
+ * Get the value of the bank(partition) to which the update needs to be
+ * made.
+ *
+ * Note: This is a weak function and platforms can override this with
+ * their own implementation for selection of the update bank.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_plat_get_update_index(uint *update_idx);
+
+/**
+ * fwu_plat_get_bootidx() - Get the value of the boot index
+ * @boot_idx: Boot index value
+ *
+ * Get the value of the bank(partition) from which the platform
+ * has booted. This value is passed to U-Boot from the earlier
+ * stage bootloader which loads and boots all the relevant
+ * firmware images
+ *
+ */
+void fwu_plat_get_bootidx(uint *boot_idx);
+
+/**
+ * fwu_update_checks_pass() - Check if FWU update can be done
+ *
+ * Check if the FWU update can be executed. The updates are
+ * allowed only when the platform is not in Trial State and
+ * the boot time checks have passed
+ *
+ * Return: 1 if OK, 0 if checks do not pass
+ *
+ */
+u8 fwu_update_checks_pass(void);
+
+/**
+ * fwu_empty_capsule_checks_pass() - Check if empty capsule can be processed
+ *
+ * Check if the empty capsule can be processed to either accept or revert
+ * an earlier executed update. The empty capsules need to be processed
+ * only when the platform is in Trial State and the boot time checks have
+ * passed
+ *
+ * Return: 1 if OK, 0 if not to be allowed
+ *
+ */
+u8 fwu_empty_capsule_checks_pass(void);
+
+/**
+ * fwu_trial_state_ctr_start() - Start the Trial State counter
+ *
+ * Start the counter to identify the platform booting in the
+ * Trial State. The counter is implemented as an EFI variable.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_trial_state_ctr_start(void);
+
+/**
+ * fwu_gen_alt_info_from_mtd() - Parse dfu_alt_info from metadata in mtd
+ * @buf: Buffer into which the dfu_alt_info is filled
+ * @len: Maximum characters that can be written in buf
+ * @mtd: Pointer to underlying MTD device
+ *
+ * Parse dfu_alt_info from metadata in mtd. Used for setting the env.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_gen_alt_info_from_mtd(char *buf, size_t len, struct mtd_info *mtd);
+
+/**
+ * fwu_mtd_get_alt_num() - Mapping of fwu_plat_get_alt_num for MTD device
+ * @image_guid: Image GUID for which DFU alt number needs to be retrieved
+ * @alt_num: Pointer to the alt_num
+ * @mtd_dev: Name of mtd device instance
+ *
+ * To map fwu_plat_get_alt_num onto mtd based metadata implementation.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_mtd_get_alt_num(efi_guid_t *image_guid, u8 *alt_num, const char *mtd_dev);
+
+/**
+ * fwu_mdata_copies_allocate() - Allocate memory for metadata
+ * @mdata_size: Size of the metadata structure
+ *
+ * Allocate memory for storing both the copies of the FWU metadata. The
+ * copies are then used as a cache for storing FWU metadata contents.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_mdata_copies_allocate(u32 mdata_size);
+
+/**
+ * fwu_get_dev() - Return the FWU metadata device
+ *
+ * Return the pointer to the FWU metadata device.
+ *
+ * Return: Pointer to the FWU metadata dev
+ */
+struct udevice *fwu_get_dev(void);
+
+/**
+ * fwu_get_data() - Return the version agnostic FWU structure
+ *
+ * Return the pointer to the version agnostic FWU structure.
+ *
+ * Return: Pointer to the FWU data structure
+ */
+struct fwu_data *fwu_get_data(void);
+
+/**
+ * fwu_sync_mdata() - Update given meta-data partition(s) with the copy provided
+ * @data: FWU Data structure
+ * @part: Bitmask of FWU metadata partitions to be written to
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_sync_mdata(struct fwu_mdata *mdata, int part);
+
+/**
+ * fwu_populate_mdata_image_info() - Populate the image information
+ * of the metadata
+ * @data: Version agnostic FWU metadata information
+ *
+ * Populate the image information in the FWU metadata by copying it
+ * from the version agnostic structure. This is done before the
+ * metadata gets written to the storage media.
+ *
+ * Return: None
+ */
+void fwu_populate_mdata_image_info(struct fwu_data *data);
+
+/**
+ * fwu_get_mdata_size() - Get the FWU metadata size
+ * @mdata_size: Size of the metadata structure
+ *
+ * Get the size of the FWU metadata from the structure. This is later used
+ * to allocate memory for the structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata_size(uint32_t *mdata_size);
+
+/**
+ * fwu_state_machine_updates() - Update FWU state of the platform
+ * @trial_state: Is platform transitioning into Trial State
+ * @update_index: Bank number to which images have been updated
+ *
+ * On successful completion of updates, transition the platform to
+ * either Trial State or Regular State.
+ *
+ * To transition the platform to Trial State, start the
+ * TrialStateCtr counter, followed by setting the value of bank_state
+ * field of the metadata to Valid state(applicable only in version 2
+ * of metadata).
+ *
+ * In case, the platform is to transition directly to Regular State,
+ * update the bank_state field of the metadata to Accepted
+ * state(applicable only in version 2 of metadata).
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_state_machine_updates(bool trial_state, uint32_t update_index);
+
+/**
+ * fwu_init() - FWU specific initialisations
+ *
+ * Carry out some FWU specific initialisations including allocation
+ * of memory for the metadata copies, and reading the FWU metadata
+ * copies into the allocated memory. The metadata fields are then
+ * copied into a version agnostic structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_init(void);
+
+#endif /* _FWU_H_ */
diff --git a/include/fwu_mdata.h b/include/fwu_mdata.h
new file mode 100644
index 0000000000..d2521f39b4
--- /dev/null
+++ b/include/fwu_mdata.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#if !defined _FWU_MDATA_H_
+#define _FWU_MDATA_H_
+
+#include <linux/compiler_attributes.h>
+#include <efi.h>
+
+/**
+ * struct fwu_image_bank_info - firmware image information
+ * @image_guid: Guid value of the image in this bank
+ * @accepted: Acceptance status of the image
+ * @reserved: Reserved
+ *
+ * The structure contains image specific fields which are
+ * used to identify the image and to specify the image's
+ * acceptance status
+ */
+struct fwu_image_bank_info {
+	efi_guid_t  image_guid;
+	uint32_t accepted;
+	uint32_t reserved;
+} __packed;
+
+/**
+ * struct fwu_image_entry - information for a particular type of image
+ * @image_type_guid: Guid value for identifying the image type
+ * @location_guid: Guid of the storage volume where the image is located
+ * @img_bank_info: Array containing properties of images
+ *
+ * This structure contains information on various types of updatable
+ * firmware images. Each image type then contains an array of image
+ * information per bank.
+ */
+struct fwu_image_entry {
+	efi_guid_t image_type_guid;
+	efi_guid_t location_guid;
+	struct fwu_image_bank_info img_bank_info[CONFIG_FWU_NUM_BANKS];
+} __packed;
+
+/**
+ * struct fwu_fw_store_desc - FWU updatable image information
+ * @num_banks: Number of firmware banks
+ * @num_images: Number of images per bank
+ * @img_entry_size: The size of the img_entry array
+ * @bank_info_entry_size: The size of the img_bank_info array
+ * @img_entry: Array of image entries each giving information on a image
+ *
+ * This image descriptor structure contains information on the number of
+ * updatable banks and images per bank. It also gives the total sizes of
+ * the fwu_image_entry and fwu_image_bank_info arrays. This structure is
+ * only present in version 2 of the metadata structure.
+ */
+struct fwu_fw_store_desc {
+	uint8_t  num_banks;
+	uint8_t  reserved;
+	uint16_t num_images;
+	uint16_t img_entry_size;
+	uint16_t bank_info_entry_size;
+
+	struct fwu_image_entry img_entry[CONFIG_FWU_NUM_IMAGES_PER_BANK];
+} __packed;
+
+#if defined(CONFIG_FWU_MDATA_V1)
+/**
+ * struct fwu_mdata - FWU metadata structure for multi-bank updates
+ * @crc32: crc32 value for the FWU metadata
+ * @version: FWU metadata version
+ * @active_index: Index of the bank currently used for booting images
+ * @previous_active_inde: Index of the bank used before the current bank
+ *                        being used for booting
+ * @img_entry: Array of information on various firmware images that can
+ *             be updated
+ *
+ * This structure is used to store all the needed information for performing
+ * multi bank updates on the platform. This contains info on the bank being
+ * used to boot along with the information needed for identification of
+ * individual images
+ */
+struct fwu_mdata {
+	uint32_t crc32;
+	uint32_t version;
+	uint32_t active_index;
+	uint32_t previous_active_index;
+
+	struct fwu_image_entry img_entry[CONFIG_FWU_NUM_IMAGES_PER_BANK];
+} __packed;
+
+#else /* CONFIG_FWU_MDATA_V1 */
+/**
+ * struct fwu_mdata - FWU metadata structure for multi-bank updates
+ * @crc32: crc32 value for the FWU metadata
+ * @version: FWU metadata version
+ * @active_index: Index of the bank currently used for booting images
+ * @previous_active_inde: Index of the bank used before the current bank
+ *                        being used for booting
+ * @metadata_size: Size of the entire metadata structure, including the
+ *                 image descriptors
+ * @desc_offset: The offset from the start of this structure where the
+ *               image descriptor structure starts. 0 if absent
+ * @bank_state: State of each bank, valid, invalid or accepted
+ * @fw_desc: The structure describing the FWU updatable images
+ *
+ * This is the top level structure used to store all information for performing
+ * multi bank updates on the platform. This contains info on the bank being
+ * used to boot along with the information on state of individual banks.
+ */
+struct fwu_mdata {
+	uint32_t crc32;
+	uint32_t version;
+	uint32_t active_index;
+	uint32_t previous_active_index;
+	uint32_t metadata_size;
+	uint16_t desc_offset;
+	uint16_t reserved1;
+	uint8_t  bank_state[4];
+	uint32_t reserved2;
+
+	// struct fwu_fw_store_desc fw_desc;
+} __packed;
+
+#endif /* CONFIG_FWU_MDATA_V1 */
+
+#endif /* _FWU_MDATA_H_ */
diff --git a/include/generic-phy.h b/include/generic-phy.h
index d40ce589b6..893839f749 100644
--- a/include/generic-phy.h
+++ b/include/generic-phy.h
@@ -11,6 +11,29 @@
 
 struct ofnode_phandle_args;
 
+enum phy_mode {
+	PHY_MODE_INVALID,
+	PHY_MODE_USB_HOST,
+	PHY_MODE_USB_HOST_LS,
+	PHY_MODE_USB_HOST_FS,
+	PHY_MODE_USB_HOST_HS,
+	PHY_MODE_USB_HOST_SS,
+	PHY_MODE_USB_DEVICE,
+	PHY_MODE_USB_DEVICE_LS,
+	PHY_MODE_USB_DEVICE_FS,
+	PHY_MODE_USB_DEVICE_HS,
+	PHY_MODE_USB_DEVICE_SS,
+	PHY_MODE_USB_OTG,
+	PHY_MODE_UFS_HS_A,
+	PHY_MODE_UFS_HS_B,
+	PHY_MODE_PCIE,
+	PHY_MODE_ETHERNET,
+	PHY_MODE_MIPI_DPHY,
+	PHY_MODE_SATA,
+	PHY_MODE_LVDS,
+	PHY_MODE_DP
+};
+
 /**
  * struct phy - A handle to (allowing control of) a single phy port.
  *
@@ -136,6 +159,21 @@ struct phy_ops {
 	* Return: 0 if OK, or a negative error code
 	*/
 	int	(*configure)(struct phy *phy, void *params);
+
+	/*
+	 * set_mode - set mode for a PHY device
+	 *
+	 * @phy:	PHY port to be configured
+	 * @mode: PHY mode, enum phy_mode
+	 * @submode: submode, underlying data is specific to the PHY function
+	 *
+	 * During runtime, the PHY mode may need to be set for it's main function.
+	 * This function sets the PHY mode for it's main function following
+	 * power_on/off() after being initialized.
+	 *
+	 * Return 0 if OK, or a negative error code
+	 */
+	int	(*set_mode)(struct phy *phy, enum phy_mode mode, int submode);
 };
 
 /**
@@ -206,6 +244,15 @@ int generic_phy_power_off(struct phy *phy);
  */
 int generic_phy_configure(struct phy *phy, void *params);
 
+/**
+ * generic_phy_set_mode() - configure a PHY device
+ *
+ * @phy:	PHY port to be configured
+ * @mode:	PHY mode, enum phy_mode
+ * @submode:	submode, underlying data is specific to the PHY function
+ * Return 0 if OK, or a negative error code
+ */
+int generic_phy_set_mode(struct phy *phy, enum phy_mode mode, int submode);
 
 /**
  * generic_phy_get_by_index() - Get a PHY device by integer index.
@@ -342,6 +389,37 @@ int generic_phy_power_on_bulk(struct phy_bulk *bulk);
  */
 int generic_phy_power_off_bulk(struct phy_bulk *bulk);
 
+/**
+ * generic_setup_phy() - Get, initialize and power on phy.
+ *
+ * @dev:	The consumer device.
+ * @phy:	A pointer to the PHY port
+ * @index:	The index in the list of available PHYs
+ *
+ * Return: 0 if OK, or negative error code.
+ */
+int generic_setup_phy(struct udevice *dev, struct phy *phy, int index);
+
+/**
+ * generic_shutdown_phy() - Power off and de-initialize phy.
+ *
+ * @phy:	A pointer to the PHY port.
+ *
+ * Return: 0 if OK, or negative error code.
+ */
+int generic_shutdown_phy(struct phy *phy);
+
+/**
+ * generic_phy_set_mode_bulk() - Set Mode on all phys in a phy bulk struct.
+ *
+ * @bulk:	A phy bulk struct that was previously successfully requested
+ *		by generic_phy_get_bulk().
+ * @mode:	PHY mode, enum phy_mode
+ * @submode:	submode, underlying data is specific to the PHY function
+ * Return 0 if OK, or negative error code.
+ */
+int generic_phy_set_mode_bulk(struct phy_bulk *bulk, enum phy_mode mode, int submode);
+
 #else /* CONFIG_PHY */
 
 static inline int generic_phy_init(struct phy *phy)
@@ -369,6 +447,11 @@ static inline int generic_phy_power_off(struct phy *phy)
 	return 0;
 }
 
+static inline int generic_phy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	return 0;
+}
+
 static inline int generic_phy_get_by_index(struct udevice *user, int index,
 			     struct phy *phy)
 {
@@ -407,6 +490,21 @@ static inline int generic_phy_power_off_bulk(struct phy_bulk *bulk)
 	return 0;
 }
 
+static inline int generic_setup_phy(struct udevice *dev, struct phy *phy, int index)
+{
+	return 0;
+}
+
+static inline int generic_shutdown_phy(struct phy *phy)
+{
+	return 0;
+}
+
+static inline int generic_phy_set_mode_bulk(struct phy_bulk *bulk, enum phy_mode mode, int submode)
+{
+	return 0;
+}
+
 #endif /* CONFIG_PHY */
 
 /**
diff --git a/include/image.h b/include/image.h
index d7d756c645..6c0dffd3ce 100644
--- a/include/image.h
+++ b/include/image.h
@@ -776,7 +776,13 @@ image_set_hdr_b(comp)		/* image_set_comp */
 
 static inline void image_set_name(image_header_t *hdr, const char *name)
 {
-	strncpy(image_get_name(hdr), name, IH_NMLEN);
+	/*
+	 * This is equivalent to: strncpy(image_get_name(hdr), name, IH_NMLEN);
+	 *
+	 * Use the tortured code below to avoid a warning with gcc 12. We do not
+	 * want to include a nul terminator if the name is of length IH_NMLEN
+	 */
+	memcpy(image_get_name(hdr), name, strnlen(name, IH_NMLEN));
 }
 
 int image_check_hcrc(const image_header_t *hdr);
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index 2d04882d05..507cedfdb5 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -15,10 +15,17 @@
 
 struct udevice;
 
+/* update clock ID for the dev = clock provider, compatible with CLK_AUTO_ID */
+static inline void dev_clk_dm(const struct udevice *dev, ulong id, struct clk *clk)
+{
+	if (!IS_ERR(clk))
+		clk->id = CLK_ID(dev, id);
+}
+
 static inline void clk_dm(ulong id, struct clk *clk)
 {
 	if (!IS_ERR(clk))
-		clk->id = id;
+		clk->id = CLK_ID(clk->dev, id);
 }
 
 /*
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index 85288c3729..c12a7f70ad 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -135,6 +135,22 @@ static inline unsigned long resource_type(const struct resource *res)
 	return res->flags & IORESOURCE_TYPE_BITS;
 }
 
+/* True iff r1 completely contains r2 */
+static inline bool resource_contains(struct resource *r1, struct resource *r2)
+{
+	if (resource_type(r1) != resource_type(r2))
+		return false;
+	if (r1->flags & IORESOURCE_UNSET || r2->flags & IORESOURCE_UNSET)
+		return false;
+	return r1->start <= r2->start && r1->end >= r2->end;
+}
+
+/* True if any part of r1 overlaps r2 */
+static inline bool resource_overlaps(struct resource *r1, struct resource *r2)
+{
+	return r1->start <= r2->end && r1->end >= r2->start;
+}
+
 /* Convenience shorthand with allocation */
 #define request_region(start,n,name)	__request_region(&ioport_resource, (start), (n), (name), 0)
 #define __request_mem_region(start,n,name, excl) __request_region(&iomem_resource, (start), (n), (name), excl)
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 2595bad9df..9c520e8ead 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -291,6 +291,7 @@ enum spi_nor_option_flags {
 	SNOR_F_BROKEN_RESET	= BIT(6),
 	SNOR_F_SOFT_RESET	= BIT(7),
 	SNOR_F_IO_MODE_EN_VOLATILE = BIT(8),
+	SNOR_F_DTR_SWAB16       = BIT(9),
 };
 
 struct spi_nor;
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 5d0dac950e..af6350170a 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -18,6 +18,12 @@ enum usb_dr_mode {
 	USB_DR_MODE_OTG,
 };
 
+enum usb_role {
+	USB_ROLE_NONE,
+	USB_ROLE_HOST,
+	USB_ROLE_DEVICE,
+};
+
 /**
  * usb_get_dr_mode() - Get dual role mode for given device
  * @node: ofnode of the given device
diff --git a/include/mtd/cfi_flash.h b/include/mtd/cfi_flash.h
index 1321da1910..2b2dc1f111 100644
--- a/include/mtd/cfi_flash.h
+++ b/include/mtd/cfi_flash.h
@@ -20,6 +20,7 @@
 #define FLASH_CMD_PROTECT_CLEAR		0xD0
 #define FLASH_CMD_CLEAR_STATUS		0x50
 #define FLASH_CMD_READ_STATUS		0x70
+#define FLASH_CMD_CLEAR_ERROR_STATUS	0x71
 #define FLASH_CMD_WRITE_TO_BUFFER	0xE8
 #define FLASH_CMD_WRITE_BUFFER_PROG	0xE9
 #define FLASH_CMD_WRITE_BUFFER_CONFIRM	0xD0
diff --git a/include/mtd/sfdp_flash.h b/include/mtd/sfdp_flash.h
new file mode 100644
index 0000000000..4f9d8bd697
--- /dev/null
+++ b/include/mtd/sfdp_flash.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2024
+ */
+
+#ifndef __SFDP_FLASH_H__
+#define __SFDP_FLASH_H__
+
+int sfdp_flash_scan(flash_info_t *info, const void *sfdp);
+
+#endif /* __SFDP_FLASH_H__ */
diff --git a/include/netdev.h b/include/netdev.h
index b3f8584e90..44b19ec3e2 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -25,7 +25,7 @@ struct udevice;
 
 int board_eth_init(struct bd_info *bis);
 int board_interface_eth_init(struct udevice *dev,
-			     phy_interface_t interface_type);
+			     phy_interface_t interface_type, ulong rate);
 int cpu_eth_init(struct bd_info *bis);
 
 /* Driver initialization prototypes */
diff --git a/include/pxe_utils.h b/include/pxe_utils.h
index 4a73b2aace..1e5e8424f5 100644
--- a/include/pxe_utils.h
+++ b/include/pxe_utils.h
@@ -28,6 +28,7 @@
  * Create these with the 'label_create' function given below.
  *
  * name - the name of the menu as given on the 'menu label' line.
+ * kernel_label - the kernel label, including FIT config if present.
  * kernel - the path to the kernel file to use for this label.
  * append - kernel command line to use when booting this label
  * initrd - path to the initrd to use for this label.
@@ -40,6 +41,7 @@ struct pxe_label {
 	char num[4];
 	char *name;
 	char *menu;
+	char *kernel_label;
 	char *kernel;
 	char *config;
 	char *append;
diff --git a/include/reset.h b/include/reset.h
index 965f02e0ce..1004225944 100644
--- a/include/reset.h
+++ b/include/reset.h
@@ -329,10 +329,10 @@ int reset_deassert_bulk(struct reset_ctl_bulk *bulk);
 int reset_status(struct reset_ctl *reset_ctl);
 
 /**
- * reset_release_all - Assert/Free an array of previously requested resets.
+ * reset_release_all - Free an array of previously requested resets.
  *
  * For each reset contained in the reset array, this function will check if
- * reset has been previously requested and then will assert and free it.
+ * reset has been previously requested and then free it.
  *
  * @reset_ctl:	A reset struct array that was previously successfully
  *		requested by reset_get_by_*().
@@ -342,12 +342,11 @@ int reset_status(struct reset_ctl *reset_ctl);
 int reset_release_all(struct reset_ctl *reset_ctl, int count);
 
 /**
- * reset_release_bulk - Assert/Free an array of previously requested reset
+ * reset_release_bulk - Free an array of previously requested reset
  * signals in a reset control bulk struct.
  *
  * For each reset contained in the reset control bulk struct, this function
- * will check if reset has been previously requested and then will assert
- * and free it.
+ * will check if reset has been previously requested and then will free it.
  *
  * @bulk:	A reset control bulk struct that was previously successfully
  *		requested by reset_get_bulk().
diff --git a/include/rproc_optee.h b/include/rproc_optee.h
new file mode 100644
index 0000000000..9718239afc
--- /dev/null
+++ b/include/rproc_optee.h
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) STMicroelectronics 2020 - All Rights Reserved
+ */
+
+#ifndef _RPROC_OPTEE_H_
+#define _RPROC_OPTEE_H_
+
+/**
+ * struct rproc_optee - TEE remoteproc structure
+ * @tee:	TEE device
+ * @proc_id:	Identifier of the target processor
+ * @session:	TEE session identifier
+ */
+struct rproc_optee {
+	struct udevice *tee;
+	u32 proc_id;
+	u32 session;
+};
+
+#if IS_ENABLED(CONFIG_REMOTEPROC_OPTEE)
+
+/**
+ * rproc_optee_open() - open a rproc tee session
+ *
+ * Open a session towards the trusted application in charge of the remote
+ * processor.
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 if the session is opened, or an appropriate error value.
+ */
+int rproc_optee_open(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_close() - close a rproc tee session
+ *
+ * Close the trusted application session in charge of the remote processor.
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_close(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_start() - Request OP-TEE to start a remote processor
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_start(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_stop() - Request OP-TEE to stop a remote processor
+ *
+ * @trproc: OPTEE remoteproc context structure
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_stop(struct rproc_optee *trproc);
+
+/**
+ * rproc_optee_get_rsc_table() - Request OP-TEE the resource table
+ *
+ * Get the address and the size of the resource table. If no resource table is
+ * found, the size and address are null.
+ *
+ * @trproc: OPTEE remoteproc context structure
+ * @rsc_addr:  out the physical address of the resource table returned
+ * @rsc_size:  out the size of the resource table
+ *
+ * @return 0 on success, or an appropriate error value.
+ */
+int rproc_optee_get_rsc_table(struct rproc_optee *trproc, phys_addr_t *rsc_addr,
+			      phys_size_t *rsc_size);
+
+/**
+ * rproc_optee_load() - load an signed ELF image
+ *
+ * @trproc: OPTEE remoteproc context structure
+ * @addr:	valid ELF image address
+ * @size:	size of the image
+ *
+ * @return 0 if the image is successfully loaded, else appropriate error value.
+ */
+int rproc_optee_load(struct rproc_optee *trproc, ulong addr, ulong size);
+
+#else
+
+static inline int  rproc_optee_open(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_close(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_start(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_stop(struct rproc_optee *trproc)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_get_rsc_table(struct rproc_optee *trproc,
+					     phys_addr_t *rsc_addr,
+					     phys_size_t *rsc_size)
+{
+	return -ENOSYS;
+}
+
+static inline int  rproc_optee_load(struct rproc_optee *trproc, ulong addr,
+				    ulong size)
+{
+	return -ENOSYS;
+}
+
+#endif
+
+#endif	/* _RPROC_OPTEE_H_ */
diff --git a/include/spi-mem.h b/include/spi-mem.h
index 32ffdc2e0f..e5e0ef6333 100644
--- a/include/spi-mem.h
+++ b/include/spi-mem.h
@@ -89,6 +89,8 @@ enum spi_mem_data_dir {
  * @dummy.dtr: whether the dummy bytes should be sent in DTR mode or not
  * @data.buswidth: number of IO lanes used to send/receive the data
  * @data.dtr: whether the data should be sent in DTR mode or not
+ * @data.dtr_swab16: whether the byte order of 16-bit words is swapped when read
+ *		     or written in Octal DTR mode compared to STR mode.
  * @data.dir: direction of the transfer
  * @data.buf.in: input buffer
  * @data.buf.out: output buffer
@@ -117,6 +119,7 @@ struct spi_mem_op {
 	struct {
 		u8 buswidth;
 		u8 dtr : 1;
+		u8 dtr_swab16 : 1;
 		enum spi_mem_data_dir dir;
 		unsigned int nbytes;
 		/* buf.{in,out} must be DMA-able. */
diff --git a/include/stm32_omi.h b/include/stm32_omi.h
new file mode 100644
index 0000000000..119992bfea
--- /dev/null
+++ b/include/stm32_omi.h
@@ -0,0 +1,182 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+#include <clk.h>
+#include <reset.h>
+#include <linux/iopoll.h>
+#include <linux/ioport.h>
+
+/*
+ * OCTOSPI control register
+ */
+#define OSPI_CR			0x00
+#define OSPI_CR_EN		BIT(0)
+#define OSPI_CR_ABORT		BIT(1)
+#define OSPI_CR_TCEN		BIT(3)
+#define OSPI_CR_FSEL		BIT(7)
+#define OSPI_CR_FTHRES_MASK	GENMASK(12,8)
+#define OSPI_CR_CSSEL		BIT(24)
+#define OSPI_CR_FMODE_SHIFT	28
+#define OSPI_CR_FMODE_MASK	GENMASK(29, 28)
+#define OSPI_CR_FMODE_IND_WRITE	0
+#define OSPI_CR_FMODE_IND_READ	1
+#define OSPI_CR_FMODE_MMAP	3
+/*
+ * OCTOSPI device configuration register
+ */
+#define OSPI_DCR1		0x08
+#define OSPI_DCR1_CKMODE	BIT(0)
+#define OSPI_DCR1_DLYBYP	BIT(3)
+#define OSPI_DCR1_CSHT_SHIFT	8
+#define OSPI_DCR1_CSHT_MASK	GENMASK(13, 8)
+#define OSPI_DCR1_DEVSIZE_MASK	GENMASK(20,16)
+#define OSPI_DCR1_MTYP_MASK	GENMASK(26, 24)
+#define OSPI_DCR1_MTYP_SHIFT	24
+#define OSPI_DCR1_MTYP_MX_MODE	1
+#define OSPI_DCR1_MTYP_HP_MEMMODE	4
+/*
+ * OCTOSPI device configuration register 2
+ */
+#define OSPI_DCR2		0x0c
+#define OSPI_DCR2_PRESC_SHIFT	0
+#define OSPI_DCR2_PRESC_MASK	GENMASK(7, 0)
+/*
+ * OCTOSPI status register
+ */
+#define OSPI_SR			0x20
+#define OSPI_SR_TEF		BIT(0)
+#define OSPI_SR_TCF		BIT(1)
+#define OSPI_SR_FTF		BIT(2)
+#define OSPI_SR_BUSY		BIT(5)
+/*
+ * OCTOSPI flag clear register
+ */
+#define OSPI_FCR		0x24
+#define OSPI_FCR_CTEF		BIT(0)
+#define OSPI_FCR_CTCF		BIT(1)
+/*
+ * OCTOSPI data length register
+ */
+#define OSPI_DLR		0x40
+/*
+ * OCTOSPI address register
+ */
+#define OSPI_AR			0x48
+/*
+ * OCTOSPI data configuration register
+ */
+#define OSPI_DR			0x50
+/*
+ * OCTOSPI communication configuration register
+ */
+#define OSPI_CCR		0x100
+#define OSPI_CCR_IMODE_SHIFT	0
+#define OSPI_CCR_IMODE_MASK	GENMASK(2, 0)
+#define OSPI_CCR_IDTR		BIT(3)
+#define OSPI_CCR_ISIZE_SHIFT	4
+#define OSPI_CCR_ISIZE_MASK	GENMASK(5, 4)
+#define OSPI_CCR_ADMODE_SHIFT	8
+#define OSPI_CCR_ADMODE_MASK	GENMASK(10, 8)
+#define OSPI_CCR_ADMODE_8LINES	4
+#define OSPI_CCR_ADDTR		BIT(11)
+#define OSPI_CCR_ADSIZE_SHIFT	12
+#define OSPI_CCR_ADSIZE_MASK	GENMASK(13,12)
+#define OSPI_CCR_ADSIZE_32BITS	3
+#define OSPI_CCR_DMODE_SHIFT	24
+#define OSPI_CCR_DMODE_MASK	GENMASK(26, 24)
+#define OSPI_CCR_DMODE_8LINES	4
+#define OSPI_CCR_IND_WRITE	0
+#define OSPI_CCR_IND_READ	1
+#define OSPI_CCR_MEM_MAP	3
+#define OSPI_CCR_DDTR		BIT(27)
+#define OSPI_CCR_DQSE		BIT(29)
+/*
+ * OCTOSPI timing configuration register
+ */
+#define OSPI_TCR		0x108
+#define OSPI_TCR_DCYC_SHIFT	0x0
+#define OSPI_TCR_DCYC_MASK	GENMASK(4, 0)
+#define OSPI_TCR_DHQC		BIT(28)
+#define OSPI_TCR_SSHIFT		BIT(30)
+/*
+ * OCTOSPI instruction register
+ */
+#define OSPI_IR			0x110
+/*
+ * OCTOSPI low power timeout register
+ */
+#define OSPI_LPTR		0x130
+#define OSPI_LPTR_TIMEOUT_MASK	GENMASK(15, 0)
+
+/*
+ * OCTOSPI write communication configuration register
+ */
+#define OSPI_WCCR		0x180
+/*
+ * HyperBus latency configuration register
+ */
+#define OSPI_HLCR		0x200
+#define OSPI_HLCR_WZL		BIT(1)
+#define OSPI_HLCR_TACC_MASK	GENMASK(15,8)
+#define OSPI_HLCR_TRWR_MASK	GENMASK(23,16)
+
+#define SYSCFG_DLYBOS_CR		0
+#define DLYBOS_CR_EN			BIT(0)
+#define DLYBOS_CR_RXTAPSEL_SHIFT	1
+#define DLYBOS_CR_RXTAPSEL_MASK		GENMASK(6, 1)
+#define DLYBOS_CR_TXTAPSEL_SHIFT	7
+#define DLYBOS_CR_TXTAPSEL_MASK		GENMASK(12, 7)
+#define DLYBOS_TAPSEL_NB		33
+#define DLYBOS_BYP_EN			BIT(16)
+#define DLYBOS_BYP_CMD_MASK		GENMASK(21, 17)
+
+#define SYSCFG_DLYBOS_SR	4
+#define DLYBOS_SR_LOCK		BIT(0)
+#define DLYBOS_SR_RXTAPSEL_ACK	BIT(1)
+#define DLYBOS_SR_TXTAPSEL_ACK	BIT(2)
+
+#define OSPI_MAX_MMAP_SZ	SZ_256M
+#define OSPI_MAX_CHIP		2
+
+#define OSPI_ABT_TIMEOUT_US		100000
+#define OSPI_BUSY_TIMEOUT_US		100000
+#define OSPI_CMD_TIMEOUT_US		1000000
+#define OSPI_FIFO_TIMEOUT_US		30000
+#define STM32_DLYB_FREQ_THRESHOLD	50000000
+#define STM32_DLYBOS_TIMEOUT_MS		1000
+#define STM32_DLYBOS_DELAY_NB		24
+
+struct stm32_omi_plat {
+	struct regmap *regmap;
+	phys_addr_t regs_base;		/* register base address */
+	phys_addr_t mm_base;		/* memory map base address */
+	resource_size_t mm_size;
+	struct clk clk;
+	struct reset_ctl_bulk rst_ctl;
+	ulong clock_rate;
+	u32 dlyb_base;
+	bool jedec_flash;
+};
+
+struct stm32_omi_priv {
+	int (*check_transfer)(struct udevice * omi_dev);
+	struct udevice *dev;
+	bool is_calibrating;
+};
+
+struct stm32_tap_window {
+	u8 end;
+	u8 length;
+};
+
+int stm32_omi_dlyb_configure(struct udevice *dev,
+			     bool bypass_mode, u16 period_ps);
+int stm32_omi_dlyb_find_tap(struct udevice *dev, bool rx_only, u8 *window_len);
+int stm32_omi_dlyb_set_cr(struct udevice *dev, u32 dlyb_cr);
+void stm32_omi_dlyb_get_cr(struct udevice *dev, u32 *dlyb_cr);
+void stm32_omi_dlyb_stop(struct udevice *dev);
+int stm32_omi_tx_poll(struct udevice *dev, u8 *buf, u32 len, bool read);
+int stm32_omi_wait_cmd(struct udevice *dev);
+int stm32_omi_wait_for_not_busy(struct udevice *dev);
diff --git a/include/tee/optee_service.h b/include/tee/optee_service.h
new file mode 100644
index 0000000000..fca468af7c
--- /dev/null
+++ b/include/tee/optee_service.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * (C) Copyright 2022 Linaro Limited
+ */
+
+#ifndef _OPTEE_SERVICE_H
+#define _OPTEE_SERVICE_H
+
+/*
+ * struct optee_service - Discoverable OP-TEE service
+ *
+ * @driver_name - Name of the related driver
+ * @uuid - UUID of the OP-TEE service related to the driver
+ *
+ * Use macro OPTEE_SERVICE_DRIVER() to register a driver related to an
+ * OP-TEE service discovered when driver asks OP-TEE services enumaration.
+ */
+struct optee_service {
+	const char *driver_name;
+	const struct tee_optee_ta_uuid uuid;
+};
+
+#ifdef CONFIG_OPTEE_SERVICE_DISCOVERY
+#define OPTEE_SERVICE_DRIVER(__name, __uuid, __drv_name) \
+	ll_entry_declare(struct optee_service, __name, optee_service) = { \
+		.uuid = __uuid, \
+		.driver_name = __drv_name, \
+	}
+#else
+#define OPTEE_SERVICE_DRIVER(__name, __uuid, __drv_name) \
+	static int __name##__COUNTER__ __always_unused
+#endif
+
+#endif /* _OPTEE_SERVICE_H */
diff --git a/include/typec.h b/include/typec.h
new file mode 100644
index 0000000000..9241da4614
--- /dev/null
+++ b/include/typec.h
@@ -0,0 +1,154 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021, STMicroelectronics - All Rights Reserved
+ */
+
+enum typec_state {
+	TYPEC_UNATTACHED,
+	TYPEC_ATTACHED,
+};
+
+enum typec_data_role {
+	TYPEC_DEVICE,
+	TYPEC_HOST,
+};
+
+/**
+ * struct typec_ops - driver I/O operations for TYPEC uclass
+ *
+ * Drivers should support 2 operations. These operations is intended
+ * to be used by uclass code, not directly from other code.
+ */
+struct typec_ops {
+	/**
+	 * is_attached() - Return if cable is attached
+	 *
+	 * @dev: TYPEC device to read from
+	 * @con_idx: connector index (0 is the first one)
+	 * @return  TYPEC_UNATTACHED if not attached, TYPEC_ATTACHED if attached, -ve on error
+	 */
+	int (*is_attached)(struct udevice *dev, u8 con_idx);
+
+	/**
+	 * get_data_role() - Return data role (HOST or DEVICE)
+	 *
+	 * @dev: TYPEC device to read from
+	 * @con_idx: connector index (0 is the first one)
+	 * @return: TYPEC_DEVICE if device role, TYPEC_HOST if host role, -ve on error
+	 */
+	int (*get_data_role)(struct udevice *dev, u8 con_idx);
+
+	/**
+	 * get_nb_connector() - Return connector number managed by TypeC controller.
+	 *
+	 * @dev: TYPEC device to read from
+	 * @return: number of connector managed by TypeC controller, -ve on error
+	 */
+	u8 (*get_nb_connector)(struct udevice *dev);
+};
+
+#ifdef CONFIG_TYPEC
+/**
+ * typec_is_attached() - Test if Type-C connector is attached
+ *
+ * @return TYPEC_ATTACHED if attached, TYPEC_UNATTACHED is not attached,
+ * or -ve on error.
+ */
+int typec_is_attached(struct udevice *dev, u8 con_idx);
+
+/**
+ * typec_get_data_role() - Return current Type-C data role
+ *
+ * @return TYPEC_DEVICE if attached to a host, TYPEC_HOST is attached to a
+ * device or -ve on error.
+ */
+int typec_get_data_role(struct udevice *dev, u8 con_idx);
+
+/**
+ * typec_get_nb_connector() - Return Type-C connector supported by controller
+ *
+ * @return Type-C connector number or -ve on error.
+ */
+int typec_get_nb_connector(struct udevice *dev);
+
+/**
+ * typec_get_device_from_usb() - Allows to retrieve a Type-C device from
+ * an USB device. typec_get_driver_from_usb() checks in USB device node
+ * for port and endpoint sub-node, if exist, retrieve the connector node,
+ * probe the associated Type-C device and return it (see DT example below).
+ * See Documentation/devicetree/bindings/connector/usb-connector.yaml for more
+ * details
+ *
+ * @dev: USB device
+ * @typec: Type-C device
+ * @index: USB controller port number
+ * @return -ve on error.
+ *
+ * usb_dwc3_0: usb@10000000 {
+ *	...
+ *	port@0 {
+ *		reg = <0>;
+ *		typec_hs: endpoint {
+ *			remote-endpoint = <&usb_con_hs>;
+ *		};
+ *	};
+ *
+ *	port@1 {
+ *		reg = <1>;
+ *		typec_ss: endpoint {
+ *			remote-endpoint = <&usb_con_ss>;
+ *		};
+ *	};
+ * };
+ *
+ * usb-typec@1 {
+ *	...
+ *	connector {
+ *		compatible = "usb-c-connector";
+ *		label = "USB-C";
+ *
+ *		ports {
+ *			#address-cells = <1>;
+ *			#size-cells = <0>;
+ *
+ *			port@0 {
+ *				reg = <0>;
+ *				usb_con_hs: endpoint {
+ *					remote-endpoint = <&typec_hs>;
+ *				};
+ *			};
+ *
+ *			port@1 {
+ *				reg = <1>;
+ *				usb_con_ss: endpoint {
+ *					remote-endpoint = <&typec_ss>;
+ *				};
+ *			};
+ *		};
+ *	};
+ * };
+ */
+int typec_get_device_from_usb(struct udevice *dev, struct udevice **typec, u8
+			      index);
+#else
+static inline int typec_is_attached(struct udevice *dev, u8 con_idx)
+{
+	return -ENODEV;
+}
+
+static inline int typec_get_data_role(struct udevice *dev, u8 con_idx)
+{
+	return -EINVAL;
+}
+
+static inline int typec_get_nb_connector(struct udevice *dev)
+{
+	return -EINVAL;
+}
+
+static inline int typec_get_device_from_usb(struct udevice *dev, struct udevice **typec,
+					    u8 index)
+{
+	return -ENODEV;
+}
+#endif
diff --git a/include/ucsi.h b/include/ucsi.h
new file mode 100644
index 0000000000..1c46e05481
--- /dev/null
+++ b/include/ucsi.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+
+#ifndef _UCSI_H_
+#define _UCSI_H_
+
+/* UCSI offsets (Bytes) */
+#define UCSI_VERSION			0
+#define UCSI_CCI			4
+#define UCSI_CONTROL			8
+#define UCSI_MESSAGE_IN			16
+
+/* Commands */
+#define UCSI_PPM_RESET			0x01
+#define UCSI_ACK_CC_CI			0x04
+#define UCSI_SET_NOTIFICATION_ENABLE	0x05
+#define UCSI_GET_CAPABILITY		0x06
+#define UCSI_GET_ALTERNATE_MODES	0x0c
+#define UCSI_GET_CONNECTOR_STATUS	0x12
+#define UCSI_GET_ERROR_STATUS		0x13
+
+#define UCSI_CONNECTOR_NUMBER(_num_)		((u64)(_num_) << 16)
+
+/* ACK_CC_CI bits */
+#define UCSI_ACK_CONNECTOR_CHANGE		BIT(16)
+#define UCSI_ACK_COMMAND_COMPLETE		BIT(17)
+
+/* SET_NOTIFICATION_ENABLE command bits */
+#define UCSI_ENABLE_NTFY_CONNECTOR_CHANGE	BIT(30)
+
+/* Command Status and Connector Change Indication (CCI) bits */
+#define UCSI_CCI_CONNECTOR(_c_)		(((_c_) & GENMASK(7, 1)) >> 1)
+#define UCSI_CCI_LENGTH(_c_)		(((_c_) & GENMASK(15, 8)) >> 8)
+#define UCSI_CCI_NOT_SUPPORTED		BIT(25)
+#define UCSI_CCI_RESET_COMPLETE		BIT(27)
+#define UCSI_CCI_BUSY			BIT(28)
+#define UCSI_CCI_ERROR			BIT(30)
+#define UCSI_CCI_COMMAND_COMPLETE	BIT(31)
+
+/* Error information returned by PPM in response to GET_ERROR_STATUS command. */
+#define UCSI_ERROR_UNREGONIZED_CMD		BIT(0)
+#define UCSI_ERROR_INVALID_CON_NUM		BIT(1)
+#define UCSI_ERROR_INVALID_CMD_ARGUMENT		BIT(2)
+#define UCSI_ERROR_INCOMPATIBLE_PARTNER		BIT(3)
+#define UCSI_ERROR_CC_COMMUNICATION_ERR		BIT(4)
+#define UCSI_ERROR_DEAD_BATTERY			BIT(5)
+#define UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL	BIT(6)
+#define UCSI_ERROR_OVERCURRENT			BIT(7)
+#define UCSI_ERROR_UNDEFINED			BIT(8)
+#define UCSI_ERROR_PARTNER_REJECTED_SWAP	BIT(9)
+#define UCSI_ERROR_HARD_RESET			BIT(10)
+#define UCSI_ERROR_PPM_POLICY_CONFLICT		BIT(11)
+#define UCSI_ERROR_SWAP_REJECTED		BIT(12)
+
+/* Data structure filled by PPM in response to GET_CAPABILITY command. */
+struct ucsi_capability {
+	u32 attributes;
+	u8 num_connectors;
+	u8 features;
+	u16 reserved_1;
+	u8 num_alt_modes;
+	u8 reserved_2;
+	u16 bc_version;
+	u16 pd_version;
+	u16 typec_version;
+} __packed;
+
+/* Data structure filled by PPM in response to GET_CONNECTOR_STATUS command. */
+struct ucsi_connector_status {
+	u16 change;
+	u16 flags;
+#define UCSI_CONSTAT_CONNECTED			BIT(3)
+#define UCSI_CONSTAT_PARTNER_TYPE(_f_)		(((_f_) & GENMASK(15, 13)) >> 13)
+#define   UCSI_CONSTAT_PARTNER_TYPE_DFP		1
+#define   UCSI_CONSTAT_PARTNER_TYPE_UFP		2
+#define   UCSI_CONSTAT_PARTNER_TYPE_CABLE	3 /* Powered Cable */
+#define   UCSI_CONSTAT_PARTNER_TYPE_CABLE_AND_UFP	4 /* Powered Cable */
+#define   UCSI_CONSTAT_PARTNER_TYPE_DEBUG	5
+#define   UCSI_CONSTAT_PARTNER_TYPE_AUDIO	6
+	u32 request_data_obj;
+	u8 pwr_status;
+} __packed;
+
+/**
+ * struct ucsi_ops - driver I/O operations for UCSI uclass
+ *
+ * Drivers should support 2 operations. These operations are intended to be used
+ * by uclass code, not directly from other code.
+ */
+struct ucsi_ops {
+	/**
+	 * read() - Read operation
+	 *
+	 * @ucsi:	UCSI device to read from
+	 * @offset:	UCSI data structure offset
+	 * @buf:	Buffer to receive the data
+	 * @len		Number of bytes to read
+	 * @return 0 on success, -ve on failure
+	 */
+	int (*read)(struct udevice *ucsi, unsigned int offset, void *val, size_t len);
+
+	/**
+	 * write() - Write operation
+	 *
+	 * @ucsi:	UCSI device to write to
+	 * @offset:	UCSI data structure offset
+	 * @buf:	Buffer data to write
+	 * @len		Number of bytes to write
+	 * @return 0 on success, -ve on failure
+	 */
+	int (*write)(struct udevice *ucsi, unsigned int offset, const void *val, size_t len);
+};
+#endif /* _UCSI_H_ */
diff --git a/include/usb.h b/include/usb.h
index 7e3796bd5b..297e1059f8 100644
--- a/include/usb.h
+++ b/include/usb.h
@@ -46,6 +46,12 @@
  */
 #define USB_TIMEOUT_MS(pipe) (usb_pipebulk(pipe) ? 5000 : 1000)
 
+/*
+ * USB Resume Timer: Every Host controller driver should drive the resume
+ * signalling on the bus for the amount of time defined by this macro.
+ */
+#define USB_RESUME_TIMEOUT      40 /* ms */
+
 /* device request (setup) */
 struct devrequest {
 	__u8	requesttype;
diff --git a/include/wdt.h b/include/wdt.h
index 5026f5a6db..14349c1c0c 100644
--- a/include/wdt.h
+++ b/include/wdt.h
@@ -18,6 +18,15 @@ struct udevice;
  * which typically include placing the system in a safe, known state.
  */
 
+/*
+ * Force watchdog start during init. Called by driver's probe when the watchdog
+ * is detected as already started.
+ *
+ * @dev: WDT Device
+ * @return: 0 if OK, -ve on error
+ */
+int wdt_set_force_start(struct udevice *dev);
+
 /*
  * Start the timer
  *
diff --git a/lib/Kconfig b/lib/Kconfig
index 6121c80dc8..6abe1d0a86 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -978,3 +978,9 @@ config LMB_RESERVED_REGIONS
 	  memory blocks.
 
 endmenu
+
+menu "FWU Multi Bank Updates"
+
+source lib/fwu_updates/Kconfig
+
+endmenu
diff --git a/lib/Makefile b/lib/Makefile
index e3deb15287..f2cfd1e428 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_EFI) += efi/
 obj-$(CONFIG_EFI_LOADER) += efi_driver/
 obj-$(CONFIG_EFI_LOADER) += efi_loader/
 obj-$(CONFIG_CMD_BOOTEFI_SELFTEST) += efi_selftest/
+obj-$(CONFIG_FWU_MULTI_BANK_UPDATE) += fwu_updates/
 obj-$(CONFIG_LZMA) += lzma/
 obj-$(CONFIG_BZIP2) += bzip2/
 obj-$(CONFIG_FIT) += libfdt/
diff --git a/lib/efi_loader/efi_capsule.c b/lib/efi_loader/efi_capsule.c
index a6b98f066a..51fa57edac 100644
--- a/lib/efi_loader/efi_capsule.c
+++ b/lib/efi_loader/efi_capsule.c
@@ -14,6 +14,7 @@
 #include <env.h>
 #include <fdtdec.h>
 #include <fs.h>
+#include <fwu.h>
 #include <hang.h>
 #include <malloc.h>
 #include <mapmem.h>
@@ -32,6 +33,12 @@ static const efi_guid_t efi_guid_firmware_management_capsule_id =
 		EFI_FIRMWARE_MANAGEMENT_CAPSULE_ID_GUID;
 const efi_guid_t efi_guid_firmware_management_protocol =
 		EFI_FIRMWARE_MANAGEMENT_PROTOCOL_GUID;
+const efi_guid_t fwu_guid_os_request_fw_revert =
+		FWU_OS_REQUEST_FW_REVERT_GUID;
+const efi_guid_t fwu_guid_os_request_fw_accept =
+		FWU_OS_REQUEST_FW_ACCEPT_GUID;
+
+#define FW_ACCEPT_OS	(u32)0x8000
 
 #ifdef CONFIG_EFI_CAPSULE_ON_DISK
 /* for file system access */
@@ -388,6 +395,136 @@ efi_status_t efi_capsule_authenticate(const void *capsule, efi_uintn_t capsule_s
 }
 #endif /* CONFIG_EFI_CAPSULE_AUTHENTICATE */
 
+static __maybe_unused bool fwu_empty_capsule(struct efi_capsule_header *capsule)
+{
+	return !guidcmp(&capsule->capsule_guid,
+			&fwu_guid_os_request_fw_revert) ||
+		!guidcmp(&capsule->capsule_guid,
+			 &fwu_guid_os_request_fw_accept);
+}
+
+static __maybe_unused efi_status_t fwu_to_efi_error(int err)
+{
+	efi_status_t ret;
+
+	switch(err) {
+	case 0:
+		ret = EFI_SUCCESS;
+		break;
+	case -ERANGE:
+	case -EIO:
+		ret = EFI_DEVICE_ERROR;
+		break;
+	case -EINVAL:
+		ret = EFI_INVALID_PARAMETER;
+		break;
+	case -ENODEV:
+		ret = EFI_NOT_FOUND;
+		break;
+	default:
+		ret = EFI_OUT_OF_RESOURCES;
+	}
+
+	return ret;
+}
+
+static __maybe_unused efi_status_t fwu_empty_capsule_process(
+	struct efi_capsule_header *capsule)
+{
+	int status;
+	u32 active_idx;
+	efi_guid_t *image_guid;
+	efi_status_t ret = EFI_INVALID_PARAMETER;
+
+	if (!guidcmp(&capsule->capsule_guid,
+		     &fwu_guid_os_request_fw_revert)) {
+		/*
+		 * One of the previously updated image has
+		 * failed the OS acceptance test. OS has
+		 * requested to revert back to the earlier
+		 * boot index
+		 */
+		status = fwu_revert_boot_index();
+		ret = fwu_to_efi_error(status);
+		if (ret == EFI_SUCCESS)
+			log_debug("Reverted the FWU active_index. Recommend rebooting the system\n");
+		else
+			log_err("Failed to revert the FWU boot index\n");
+	} else if (!guidcmp(&capsule->capsule_guid,
+			    &fwu_guid_os_request_fw_accept)) {
+		/*
+		 * Image accepted by the OS. Set the acceptance
+		 * status for the image.
+		 */
+		image_guid = (void *)(char *)capsule +
+			capsule->header_size;
+
+		status = fwu_get_active_index(&active_idx);
+		ret = fwu_to_efi_error(status);
+		if (ret != EFI_SUCCESS) {
+			log_err("Unable to get the active_index from the FWU metadata\n");
+			return ret;
+		}
+
+		status = fwu_accept_image(image_guid, active_idx);
+		ret = fwu_to_efi_error(status);
+		if (ret != EFI_SUCCESS)
+			log_err("Unable to set the Accept bit for the image %pUs\n",
+				image_guid);
+
+		status = fwu_state_machine_updates(0, active_idx);
+		if (status < 0)
+			ret = EFI_DEVICE_ERROR;
+
+	}
+
+	return ret;
+}
+
+static __maybe_unused void fwu_post_update_checks(
+	struct efi_capsule_header *capsule,
+	bool *fw_accept_os, bool *capsule_update)
+{
+	if (fwu_empty_capsule(capsule))
+		*capsule_update = false;
+	else
+		if (!*fw_accept_os)
+			*fw_accept_os =
+				capsule->flags & FW_ACCEPT_OS ? true : false;
+}
+
+static __maybe_unused efi_status_t fwu_post_update_process(bool fw_accept_os)
+{
+	int status;
+	uint update_index;
+	efi_status_t ret;
+
+	status = fwu_plat_get_update_index(&update_index);
+	if (status < 0) {
+		log_err("Failed to get the FWU update_index value\n");
+		return EFI_DEVICE_ERROR;
+	}
+
+	/*
+	 * All the capsules have been updated successfully,
+	 * update the FWU metadata.
+	 */
+	log_debug("Update Complete. Now updating active_index to %u\n",
+		  update_index);
+	status = fwu_set_active_index(update_index);
+	ret = fwu_to_efi_error(status);
+	if (ret != EFI_SUCCESS) {
+		log_err("Failed to update FWU metadata index values\n");
+	} else {
+		log_debug("Successfully updated the active_index\n");
+		status = fwu_state_machine_updates(fw_accept_os ? 1 : 0,
+						   update_index);
+		if (status < 0)
+			ret = EFI_DEVICE_ERROR;
+	}
+
+	return ret;
+}
 
 /**
  * efi_capsule_update_firmware - update firmware from capsule
@@ -410,7 +547,32 @@ static efi_status_t efi_capsule_update_firmware(
 	int item;
 	struct efi_firmware_management_protocol *fmp;
 	u16 *abort_reason;
+	efi_guid_t *image_type_id;
 	efi_status_t ret = EFI_SUCCESS;
+	int status;
+	uint update_index;
+	bool fw_accept_os;
+
+	if (IS_ENABLED(CONFIG_FWU_MULTI_BANK_UPDATE)) {
+		if (fwu_empty_capsule_checks_pass() &&
+		    fwu_empty_capsule(capsule_data))
+			return fwu_empty_capsule_process(capsule_data);
+
+		if (!fwu_update_checks_pass()) {
+			log_err("FWU checks failed. Cannot start update\n");
+			return EFI_INVALID_PARAMETER;
+		}
+
+
+		/* Obtain the update_index from the platform */
+		status = fwu_plat_get_update_index(&update_index);
+		if (status < 0) {
+			log_err("Failed to get the FWU update_index value\n");
+			return EFI_DEVICE_ERROR;
+		}
+
+		fw_accept_os = capsule_data->flags & FW_ACCEPT_OS ? 0x1 : 0x0;
+	}
 
 	/* sanity check */
 	if (capsule_data->header_size < sizeof(*capsule) ||
@@ -497,6 +659,34 @@ static efi_status_t efi_capsule_update_firmware(
 			efi_free_pool(abort_reason);
 			goto out;
 		}
+
+		if (IS_ENABLED(CONFIG_FWU_MULTI_BANK_UPDATE)) {
+			image_type_id = &image->update_image_type_id;
+			if (!fw_accept_os) {
+				/*
+				 * The OS will not be accepting the firmware
+				 * images. Set the accept bit of all the
+				 * images contained in this capsule.
+				 */
+				status = fwu_accept_image(image_type_id,
+							  update_index);
+			} else {
+				status = fwu_clear_accept_image(image_type_id,
+								update_index);
+			}
+			ret = fwu_to_efi_error(status);
+			if (ret != EFI_SUCCESS) {
+				log_err("Unable to %s the accept bit for the image %pUs\n",
+					fw_accept_os ? "clear" : "set",
+					image_type_id);
+				goto out;
+			}
+
+			log_debug("%s the accepted bit for Image %pUs\n",
+				  fw_accept_os ? "Cleared" : "Set",
+				  image_type_id);
+		}
+
 	}
 
 out:
@@ -1104,6 +1294,9 @@ efi_status_t efi_launch_capsules(void)
 	u16 **files;
 	unsigned int nfiles, index, i;
 	efi_status_t ret;
+	bool capsule_update = true;
+	bool update_status = true;
+	bool fw_accept_os = false;
 
 	if (check_run_capsules() != EFI_SUCCESS)
 		return EFI_SUCCESS;
@@ -1131,12 +1324,19 @@ efi_status_t efi_launch_capsules(void)
 		ret = efi_capsule_read_file(files[i], &capsule);
 		if (ret == EFI_SUCCESS) {
 			ret = efi_capsule_update_firmware(capsule);
-			if (ret != EFI_SUCCESS)
+			if (ret != EFI_SUCCESS) {
 				log_err("Applying capsule %ls failed.\n",
 					files[i]);
-			else
+				update_status = false;
+			} else {
 				log_info("Applying capsule %ls succeeded.\n",
 					 files[i]);
+				if (IS_ENABLED(CONFIG_FWU_MULTI_BANK_UPDATE)) {
+					fwu_post_update_checks(capsule,
+							       &fw_accept_os,
+							       &capsule_update);
+				}
+			}
 
 			/* create CapsuleXXXX */
 			set_capsule_result(index, capsule, ret);
@@ -1144,6 +1344,7 @@ efi_status_t efi_launch_capsules(void)
 			free(capsule);
 		} else {
 			log_err("Reading capsule %ls failed\n", files[i]);
+			update_status = false;
 		}
 		/* delete a capsule either in case of success or failure */
 		ret = efi_capsule_delete_file(files[i]);
@@ -1151,8 +1352,17 @@ efi_status_t efi_launch_capsules(void)
 			log_err("Deleting capsule %ls failed\n",
 				files[i]);
 	}
+
 	efi_capsule_scan_done();
 
+	if (IS_ENABLED(CONFIG_FWU_MULTI_BANK_UPDATE)) {
+		if (capsule_update == true && update_status == true) {
+			ret = fwu_post_update_process(fw_accept_os);
+		} else if (capsule_update == true && update_status == false) {
+			log_err("All capsules were not updated. Not updating FWU metadata\n");
+		}
+	}
+
 	for (i = 0; i < nfiles; i++)
 		free(files[i]);
 	free(files);
diff --git a/lib/efi_loader/efi_device_path.c b/lib/efi_loader/efi_device_path.c
index ebffb77122..4b12f3c7c2 100644
--- a/lib/efi_loader/efi_device_path.c
+++ b/lib/efi_loader/efi_device_path.c
@@ -148,7 +148,7 @@ struct efi_device_path *efi_dp_shorten(struct efi_device_path *dp)
 		 * in practice fallback.efi just uses MEDIA:HARD_DRIVE
 		 * so not sure when we would see these other cases.
 		 */
-		if (EFI_DP_TYPE(dp, MESSAGING_DEVICE, MSG_USB_CLASS) ||
+		if (EFI_DP_TYPE(dp, MESSAGING_DEVICE, MSG_USB) ||
 		    EFI_DP_TYPE(dp, MEDIA_DEVICE, HARD_DRIVE_PATH) ||
 		    EFI_DP_TYPE(dp, MEDIA_DEVICE, FILE_PATH))
 			return dp;
@@ -565,6 +565,11 @@ __maybe_unused static unsigned int dp_size(struct udevice *dev)
 			return dp_size(dev->parent)
 				+ sizeof(struct efi_device_path_vendor) + 1;
 #endif
+#ifdef CONFIG_USB
+		case UCLASS_MASS_STORAGE:
+			return dp_size(dev->parent)
+				+ sizeof(struct efi_device_path_controller);
+#endif
 #ifdef CONFIG_VIRTIO_BLK
 		case UCLASS_VIRTIO:
 			 /*
@@ -586,7 +591,7 @@ __maybe_unused static unsigned int dp_size(struct udevice *dev)
 	case UCLASS_MASS_STORAGE:
 	case UCLASS_USB_HUB:
 		return dp_size(dev->parent) +
-			sizeof(struct efi_device_path_usb_class);
+			sizeof(struct efi_device_path_usb);
 	default:
 		/* just skip over unknown classes: */
 		return dp_size(dev->parent);
@@ -742,6 +747,19 @@ __maybe_unused static void *dp_fill(void *buf, struct udevice *dev)
 			memcpy(&dp->ns_id, &ns_id, sizeof(ns_id));
 			return &dp[1];
 			}
+#endif
+#if defined(CONFIG_USB)
+		case UCLASS_MASS_STORAGE: {
+			struct blk_desc *desc = desc = dev_get_uclass_plat(dev);
+			struct efi_device_path_controller *dp =
+				dp_fill(buf, dev->parent);
+
+			dp->dp.type	= DEVICE_PATH_TYPE_HARDWARE_DEVICE;
+			dp->dp.sub_type = DEVICE_PATH_SUB_TYPE_CONTROLLER;
+			dp->dp.length	= sizeof(*dp);
+			dp->controller_number = desc->lun;
+			return &dp[1];
+		}
 #endif
 		default:
 			debug("%s(%u) %s: unhandled parent class: %s (%u)\n",
@@ -768,19 +786,22 @@ __maybe_unused static void *dp_fill(void *buf, struct udevice *dev)
 #endif
 	case UCLASS_MASS_STORAGE:
 	case UCLASS_USB_HUB: {
-		struct efi_device_path_usb_class *udp =
-			dp_fill(buf, dev->parent);
-		struct usb_device *udev = dev_get_parent_priv(dev);
-		struct usb_device_descriptor *desc = &udev->descriptor;
+		struct efi_device_path_usb *udp = dp_fill(buf, dev->parent);
+
+		switch (device_get_uclass_id(dev->parent)) {
+		case UCLASS_USB_HUB: {
+			struct usb_device *udev = dev_get_parent_priv(dev);
 
+			udp->parent_port_number = udev->portnr;
+			break;
+		}
+		default:
+			udp->parent_port_number = 0;
+		}
 		udp->dp.type     = DEVICE_PATH_TYPE_MESSAGING_DEVICE;
-		udp->dp.sub_type = DEVICE_PATH_SUB_TYPE_MSG_USB_CLASS;
+		udp->dp.sub_type = DEVICE_PATH_SUB_TYPE_MSG_USB;
 		udp->dp.length   = sizeof(*udp);
-		udp->vendor_id   = desc->idVendor;
-		udp->product_id  = desc->idProduct;
-		udp->device_class    = desc->bDeviceClass;
-		udp->device_subclass = desc->bDeviceSubClass;
-		udp->device_protocol = desc->bDeviceProtocol;
+		udp->usb_interface = 0;
 
 		return &udp[1];
 	}
@@ -936,7 +957,8 @@ struct efi_device_path *efi_dp_part_node(struct blk_desc *desc, int part)
 		dpsize = sizeof(struct efi_device_path_hard_drive_path);
 	buf = dp_alloc(dpsize);
 
-	dp_part_node(buf, desc, part);
+	if (buf)
+		dp_part_node(buf, desc, part);
 
 	return buf;
 }
diff --git a/lib/efi_loader/efi_device_path_to_text.c b/lib/efi_loader/efi_device_path_to_text.c
index 9062058ac2..4b2ade3803 100644
--- a/lib/efi_loader/efi_device_path_to_text.c
+++ b/lib/efi_loader/efi_device_path_to_text.c
@@ -77,6 +77,13 @@ static char *dp_hardware(char *s, struct efi_device_path *dp)
 		s += sprintf(s, ")");
 		break;
 	}
+	case DEVICE_PATH_SUB_TYPE_CONTROLLER: {
+		struct efi_device_path_controller *cdp =
+			(struct efi_device_path_controller *)dp;
+
+		s += sprintf(s, "Ctrl(0x%0x)", cdp->controller_number);
+		break;
+	}
 	default:
 		s = dp_unknown(s, dp);
 		break;
diff --git a/lib/efi_loader/efi_disk.c b/lib/efi_loader/efi_disk.c
index 5feeb52ccb..dec3e822d2 100644
--- a/lib/efi_loader/efi_disk.c
+++ b/lib/efi_loader/efi_disk.c
@@ -415,10 +415,18 @@ static efi_status_t efi_disk_add_dev(
 		struct efi_handler *handler;
 		void *protocol_interface;
 
+		if (!node) {
+			ret = EFI_OUT_OF_RESOURCES;
+			log_debug("no node\n");
+			goto error;
+		}
+
 		/* Parent must expose EFI_BLOCK_IO_PROTOCOL */
 		ret = efi_search_protocol(parent, &efi_block_io_guid, &handler);
-		if (ret != EFI_SUCCESS)
+		if (ret != EFI_SUCCESS) {
+			log_debug("search failed\n");
 			goto error;
+		}
 
 		/*
 		 * Link the partition (child controller) to the block device
@@ -427,8 +435,10 @@ static efi_status_t efi_disk_add_dev(
 		ret = efi_protocol_open(handler, &protocol_interface, NULL,
 					&diskobj->header,
 					EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER);
-		if (ret != EFI_SUCCESS)
-				goto error;
+		if (ret != EFI_SUCCESS) {
+			log_debug("prot open failed\n");
+			goto error;
+		}
 
 		diskobj->dp = efi_dp_append_node(dp_parent, node);
 		efi_free_pool(node);
@@ -453,8 +463,10 @@ static efi_status_t efi_disk_add_dev(
 			&handle, &efi_guid_device_path, diskobj->dp,
 			&efi_block_io_guid, &diskobj->ops,
 			guid, NULL, NULL));
-	if (ret != EFI_SUCCESS)
+	if (ret != EFI_SUCCESS) {
+		log_debug("install failed %lx\n", ret);
 		goto error;
+	}
 
 	/*
 	 * On partitions or whole disks without partitions install the
@@ -467,8 +479,10 @@ static efi_status_t efi_disk_add_dev(
 		ret = efi_add_protocol(&diskobj->header,
 				       &efi_simple_file_system_protocol_guid,
 				       diskobj->volume);
-		if (ret != EFI_SUCCESS)
+		if (ret != EFI_SUCCESS) {
+			log_debug("simple FS failed\n");
 			return ret;
+		}
 	}
 	diskobj->ops = block_io_disk_template;
 	diskobj->dev_index = dev_index;
@@ -537,18 +551,21 @@ static int efi_disk_create_raw(struct udevice *dev)
 	ret = efi_disk_add_dev(NULL, NULL, desc,
 			       diskid, NULL, 0, &disk);
 	if (ret != EFI_SUCCESS) {
-		if (ret == EFI_NOT_READY)
+		if (ret == EFI_NOT_READY) {
 			log_notice("Disk %s not ready\n", dev->name);
-		else
-			log_err("Adding disk for %s failed\n", dev->name);
+			ret = -EBUSY;
+		} else {
+			log_err("Adding disk for %s failed (err=%ld/%#lx)\n", dev->name, ret, ret);
+			ret = -ENOENT;
+		}
 
-		return -1;
+		return ret;
 	}
 	if (efi_link_dev(&disk->header, dev)) {
 		efi_free_pool(disk->dp);
 		efi_delete_handle(&disk->header);
 
-		return -1;
+		return -EINVAL;
 	}
 
 	return 0;
diff --git a/lib/efi_loader/efi_firmware.c b/lib/efi_loader/efi_firmware.c
index 30cafd15ca..e2200abdb2 100644
--- a/lib/efi_loader/efi_firmware.c
+++ b/lib/efi_loader/efi_firmware.c
@@ -10,6 +10,8 @@
 #include <charset.h>
 #include <dfu.h>
 #include <efi_loader.h>
+#include <efi_variable.h>
+#include <fwu.h>
 #include <image.h>
 #include <signatures.h>
 
@@ -35,11 +37,52 @@ struct fmp_payload_header {
 	u32 lowest_supported_version;
 };
 
+/**
+ * struct fmp_state - fmp firmware update state
+ *
+ * This structure describes the state of the firmware update
+ * through FMP protocol.
+ *
+ * @fw_version:			Firmware versions used
+ * @lowest_supported_version:	Lowest supported version
+ * @last_attempt_version:	Last attempt version
+ * @last_attempt_status:	Last attempt status
+ */
+struct fmp_state {
+	u32 fw_version;
+	u32 lowest_supported_version; /* not used */
+	u32 last_attempt_version; /* not used */
+	u32 last_attempt_status; /* not used */
+};
+
 __weak void set_dfu_alt_info(char *interface, char *devstr)
 {
 	env_set("dfu_alt_info", update_info.dfu_string);
 }
 
+/**
+ * efi_firmware_get_image_type_id - get image_type_id
+ * @image_index:	image index
+ *
+ * Return the image_type_id identified by the image index.
+ *
+ * Return:		pointer to the image_type_id, NULL if image_index is invalid
+ */
+static
+efi_guid_t *efi_firmware_get_image_type_id(u8 image_index)
+{
+	int i;
+	struct efi_fw_image *fw_array;
+
+	fw_array = update_info.images;
+	for (i = 0; i < update_info.num_images; i++) {
+		if (fw_array[i].image_index == image_index)
+			return &fw_array[i].image_type_id;
+	}
+
+	return NULL;
+}
+
 /* Place holder; not supported */
 static
 efi_status_t EFIAPI efi_firmware_get_image_unsupported(
@@ -101,6 +144,87 @@ efi_status_t EFIAPI efi_firmware_set_package_info_unsupported(
 	return EFI_EXIT(EFI_UNSUPPORTED);
 }
 
+/**
+ * efi_firmware_get_lsv_from_dtb - get lowest supported version from dtb
+ * @image_index:	Image index
+ * @image_type_id:	Image type id
+ * @lsv:		Pointer to store the lowest supported version
+ *
+ * Read the firmware version information from dtb.
+ */
+static void efi_firmware_get_lsv_from_dtb(u8 image_index,
+					  efi_guid_t *image_type_id, u32 *lsv)
+{
+	const void *fdt = gd->fdt_blob;
+	const fdt32_t *val;
+	const char *guid_str;
+	int len, offset, index;
+	int parent;
+
+	*lsv = 0;
+
+	parent = fdt_subnode_offset(fdt, 0, "firmware-version");
+	if (parent < 0)
+		return;
+
+	fdt_for_each_subnode(offset, fdt, parent) {
+		efi_guid_t guid;
+
+		guid_str = fdt_getprop(fdt, offset, "image-type-id", &len);
+		if (!guid_str)
+			continue;
+		uuid_str_to_bin(guid_str, guid.b, UUID_STR_FORMAT_GUID);
+
+		val = fdt_getprop(fdt, offset, "image-index", &len);
+		if (!val)
+			continue;
+		index = fdt32_to_cpu(*val);
+
+		if (!guidcmp(&guid, image_type_id) && index == image_index) {
+			val = fdt_getprop(fdt, offset,
+					  "lowest-supported-version", &len);
+			if (val)
+				*lsv = fdt32_to_cpu(*val);
+		}
+	}
+}
+
+/**
+ * efi_firmware_fill_version_info - fill the version information
+ * @image_info:		Image information
+ * @fw_array:		Pointer to size of new image
+ *
+ * Fill the version information into image_info strucrure.
+ *
+ */
+static
+void efi_firmware_fill_version_info(struct efi_firmware_image_descriptor *image_info,
+				    struct efi_fw_image *fw_array)
+{
+	u16 varname[13]; /* u"FmpStateXXXX" */
+	efi_status_t ret;
+	efi_uintn_t size;
+	struct fmp_state var_state = { 0 };
+
+	efi_create_indexed_name(varname, sizeof(varname), "FmpState",
+				fw_array->image_index);
+	size = sizeof(var_state);
+	ret = efi_get_variable_int(varname, &fw_array->image_type_id,
+				   NULL, &size, &var_state, NULL);
+	if (ret == EFI_SUCCESS)
+		image_info->version = var_state.fw_version;
+	else
+		image_info->version = 0;
+
+	efi_firmware_get_lsv_from_dtb(fw_array->image_index,
+				      &fw_array->image_type_id,
+				      &image_info->lowest_supported_image_version);
+
+	image_info->version_name = NULL; /* not supported */
+	image_info->last_attempt_version = 0;
+	image_info->last_attempt_status = LAST_ATTEMPT_STATUS_SUCCESS;
+}
+
 /**
  * efi_fill_image_desc_array - populate image descriptor array
  * @image_info_size:		Size of @image_info
@@ -130,7 +254,7 @@ static efi_status_t efi_fill_image_desc_array(
 	struct efi_fw_image *fw_array;
 	int i;
 
-	total_size = sizeof(*image_info) * num_image_type_guids;
+	total_size = sizeof(*image_info) * update_info.num_images;
 
 	if (*image_info_size < total_size) {
 		*image_info_size = total_size;
@@ -140,21 +264,20 @@ static efi_status_t efi_fill_image_desc_array(
 	*image_info_size = total_size;
 
 	fw_array = update_info.images;
-	*descriptor_count = num_image_type_guids;
+	*descriptor_count = update_info.num_images;
 	*descriptor_version = EFI_FIRMWARE_IMAGE_DESCRIPTOR_VERSION;
 	*descriptor_size = sizeof(*image_info);
 	*package_version = 0xffffffff; /* not supported */
 	*package_version_name = NULL; /* not supported */
 
-	for (i = 0; i < num_image_type_guids; i++) {
+	for (i = 0; i < update_info.num_images; i++) {
 		image_info[i].image_index = fw_array[i].image_index;
 		image_info[i].image_type_id = fw_array[i].image_type_id;
 		image_info[i].image_id = fw_array[i].image_index;
-
 		image_info[i].image_id_name = fw_array[i].fw_name;
 
-		image_info[i].version = 0; /* not supported */
-		image_info[i].version_name = NULL; /* not supported */
+		efi_firmware_fill_version_info(&image_info[i], &fw_array[i]);
+
 		image_info[i].size = 0;
 		image_info[i].attributes_supported =
 			IMAGE_ATTRIBUTE_IMAGE_UPDATABLE |
@@ -167,9 +290,6 @@ static efi_status_t efi_fill_image_desc_array(
 			image_info[0].attributes_setting |=
 				IMAGE_ATTRIBUTE_AUTHENTICATION_REQUIRED;
 
-		image_info[i].lowest_supported_image_version = 0;
-		image_info[i].last_attempt_version = 0;
-		image_info[i].last_attempt_status = LAST_ATTEMPT_STATUS_SUCCESS;
 		image_info[i].hardware_instance = 1;
 		image_info[i].dependencies = NULL;
 	}
@@ -193,8 +313,6 @@ efi_status_t efi_firmware_capsule_authenticate(const void **p_image,
 {
 	const void *image = *p_image;
 	efi_uintn_t image_size = *p_image_size;
-	u32 fmp_hdr_signature;
-	struct fmp_payload_header *header;
 	void *capsule_payload;
 	efi_status_t status;
 	efi_uintn_t capsule_payload_size;
@@ -221,26 +339,121 @@ efi_status_t efi_firmware_capsule_authenticate(const void **p_image,
 		debug("Updating capsule without authenticating.\n");
 	}
 
-	fmp_hdr_signature = FMP_PAYLOAD_HDR_SIGNATURE;
-	header = (void *)image;
-
-	if (!memcmp(&header->signature, &fmp_hdr_signature,
-		    sizeof(fmp_hdr_signature))) {
-		/*
-		 * When building the capsule with the scripts in
-		 * edk2, a FMP header is inserted above the capsule
-		 * payload. Compensate for this header to get the
-		 * actual payload that is to be updated.
-		 */
-		image += header->header_size;
-		image_size -= header->header_size;
-	}
-
 	*p_image = image;
 	*p_image_size = image_size;
 	return EFI_SUCCESS;
 }
 
+/**
+ * efi_firmware_set_fmp_state_var - set FmpStateXXXX variable
+ * @state:		Pointer to fmp state
+ * @image_index:	image index
+ *
+ * Update the FmpStateXXXX variable with the firmware update state.
+ *
+ * Return:		status code
+ */
+static
+efi_status_t efi_firmware_set_fmp_state_var(struct fmp_state *state, u8 image_index)
+{
+	u16 varname[13]; /* u"FmpStateXXXX" */
+	efi_status_t ret;
+	efi_guid_t *image_type_id;
+	struct fmp_state var_state = { 0 };
+
+	image_type_id = efi_firmware_get_image_type_id(image_index);
+	if (!image_type_id)
+		return EFI_INVALID_PARAMETER;
+
+	efi_create_indexed_name(varname, sizeof(varname), "FmpState",
+				image_index);
+
+	/*
+	 * Only the fw_version is set here.
+	 * lowest_supported_version in FmpState variable is ignored since
+	 * it can be tampered if the file based EFI variable storage is used.
+	 */
+	var_state.fw_version = state->fw_version;
+
+	ret = efi_set_variable_int(varname, image_type_id,
+				   EFI_VARIABLE_READ_ONLY |
+				   EFI_VARIABLE_NON_VOLATILE |
+				   EFI_VARIABLE_BOOTSERVICE_ACCESS |
+				   EFI_VARIABLE_RUNTIME_ACCESS,
+				   sizeof(var_state), &var_state, false);
+
+	return ret;
+}
+
+/**
+ * efi_firmware_get_fw_version - get fw_version from FMP payload header
+ * @p_image:		Pointer to new image
+ * @p_image_size:	Pointer to size of new image
+ * @state:		Pointer to fmp state
+ *
+ * Parse the FMP payload header and fill the fmp_state structure.
+ * If no FMP payload header is found, fmp_state structure is not updated.
+ *
+ */
+static void efi_firmware_get_fw_version(const void **p_image,
+					efi_uintn_t *p_image_size,
+					struct fmp_state *state)
+{
+	const struct fmp_payload_header *header;
+	u32 fmp_hdr_signature = FMP_PAYLOAD_HDR_SIGNATURE;
+
+	header = *p_image;
+	if (header->signature == fmp_hdr_signature) {
+		/* FMP header is inserted above the capsule payload */
+		state->fw_version = header->fw_version;
+
+		*p_image += header->header_size;
+		*p_image_size -= header->header_size;
+	}
+}
+
+/**
+ * efi_firmware_verify_image - verify image
+ * @p_image:		Pointer to new image
+ * @p_image_size:	Pointer to size of new image
+ * @image_index:	Image index
+ * @state:		Pointer to fmp state
+ *
+ * Verify the capsule authentication and check if the fw_version
+ * is equal or greater than the lowest supported version.
+ *
+ * Return:		status code
+ */
+static
+efi_status_t efi_firmware_verify_image(const void **p_image,
+				       efi_uintn_t *p_image_size,
+				       u8 image_index,
+				       struct fmp_state *state)
+{
+	u32 lsv;
+	efi_status_t ret;
+	efi_guid_t *image_type_id;
+
+	ret = efi_firmware_capsule_authenticate(p_image, p_image_size);
+	if (ret != EFI_SUCCESS)
+		return ret;
+
+	efi_firmware_get_fw_version(p_image, p_image_size, state);
+
+	image_type_id = efi_firmware_get_image_type_id(image_index);
+	if (!image_type_id)
+		return EFI_INVALID_PARAMETER;
+
+	efi_firmware_get_lsv_from_dtb(image_index, image_type_id, &lsv);
+	if (state->fw_version < lsv) {
+		log_err("Firmware version %u too low. Expecting >= %u. Aborting update\n",
+			state->fw_version, lsv);
+		return EFI_INVALID_PARAMETER;
+	}
+
+	return ret;
+}
+
 /**
  * efi_firmware_get_image_info - return information about the current
  *				     firmware image
@@ -330,6 +543,7 @@ efi_status_t EFIAPI efi_firmware_fit_set_image(
 	u16 **abort_reason)
 {
 	efi_status_t status;
+	struct fmp_state state = { 0 };
 
 	EFI_ENTRY("%p %d %p %zu %p %p %p\n", this, image_index, image,
 		  image_size, vendor_code, progress, abort_reason);
@@ -337,13 +551,16 @@ efi_status_t EFIAPI efi_firmware_fit_set_image(
 	if (!image || image_index != 1)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
-	status = efi_firmware_capsule_authenticate(&image, &image_size);
+	status = efi_firmware_verify_image(&image, &image_size, image_index,
+					   &state);
 	if (status != EFI_SUCCESS)
 		return EFI_EXIT(status);
 
 	if (fit_update(image))
 		return EFI_EXIT(EFI_DEVICE_ERROR);
 
+	efi_firmware_set_fmp_state_var(&state, image_index);
+
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
@@ -389,7 +606,10 @@ efi_status_t EFIAPI efi_firmware_raw_set_image(
 	efi_status_t (*progress)(efi_uintn_t completion),
 	u16 **abort_reason)
 {
+	int ret;
+	u8 dfu_alt_num;
 	efi_status_t status;
+	struct fmp_state state = { 0 };
 
 	EFI_ENTRY("%p %d %p %zu %p %p %p\n", this, image_index, image,
 		  image_size, vendor_code, progress, abort_reason);
@@ -397,14 +617,35 @@ efi_status_t EFIAPI efi_firmware_raw_set_image(
 	if (!image)
 		return EFI_EXIT(EFI_INVALID_PARAMETER);
 
-	status = efi_firmware_capsule_authenticate(&image, &image_size);
+	status = efi_firmware_verify_image(&image, &image_size, image_index,
+					   &state);
 	if (status != EFI_SUCCESS)
 		return EFI_EXIT(status);
 
-	if (dfu_write_by_alt(image_index - 1, (void *)image, image_size,
+	/*
+	 * dfu_alt_num is assigned from 0 while image_index starts from 1.
+	 * dfu_alt_num is calculated by (image_index - 1) when multi bank update
+	 * is not used.
+	 */
+	dfu_alt_num = image_index - 1;
+	if (IS_ENABLED(CONFIG_FWU_MULTI_BANK_UPDATE)) {
+		/*
+		 * Based on the value of update bank, derive the
+		 * image index value.
+		 */
+		ret = fwu_get_dfu_alt_num(image_index, &dfu_alt_num);
+		if (ret) {
+			log_debug("Unable to get FWU image_index\n");
+			return EFI_EXIT(EFI_DEVICE_ERROR);
+		}
+	}
+
+	if (dfu_write_by_alt(dfu_alt_num, (void *)image, image_size,
 			     NULL, NULL))
 		return EFI_EXIT(EFI_DEVICE_ERROR);
 
+	efi_firmware_set_fmp_state_var(&state, image_index);
+
 	return EFI_EXIT(EFI_SUCCESS);
 }
 
diff --git a/lib/fwu_updates/Kconfig b/lib/fwu_updates/Kconfig
new file mode 100644
index 0000000000..2809f7bb13
--- /dev/null
+++ b/lib/fwu_updates/Kconfig
@@ -0,0 +1,47 @@
+config FWU_MULTI_BANK_UPDATE
+	bool "Enable FWU Multi Bank Update Feature"
+	depends on EFI_CAPSULE_ON_DISK
+	select PARTITION_TYPE_GUID
+	select EFI_SETUP_EARLY
+	imply EFI_CAPSULE_ON_DISK_EARLY
+	select EVENT
+	help
+	  Feature for updating firmware images on platforms having
+	  multiple banks(copies) of the firmware images. One of the
+	  bank is selected for updating all the firmware components
+
+config FWU_NUM_BANKS
+	int "Number of Banks defined by the platform"
+	depends on FWU_MULTI_BANK_UPDATE
+	help
+	  Define the number of banks of firmware images on a platform
+
+config FWU_NUM_IMAGES_PER_BANK
+	int "Number of firmware images per bank"
+	depends on FWU_MULTI_BANK_UPDATE
+	help
+	  Define the number of firmware images per bank. This value
+	  should be the same for all the banks.
+
+config FWU_TRIAL_STATE_CNT
+	int "Number of times system boots in Trial State"
+	depends on FWU_MULTI_BANK_UPDATE
+	default 3
+	help
+	  With FWU Multi Bank Update feature enabled, number of times
+	  the platform is allowed to boot in Trial State after an
+	  update.
+
+config FWU_MDATA_V1
+	bool "Enable support FWU Metadata version 1"
+	help
+	  The FWU specification supports two versions of the
+	  metadata structure. This option enables support for FWU
+	  Metadata version 1 access.
+
+config FWU_MDATA_V2
+	bool "Enable support FWU Metadata version 2"
+	help
+	  The FWU specification supports two versions of the
+	  metadata structure. This option enables support for FWU
+	  Metadata version 2 access.
diff --git a/lib/fwu_updates/Makefile b/lib/fwu_updates/Makefile
new file mode 100644
index 0000000000..3681bef46c
--- /dev/null
+++ b/lib/fwu_updates/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Copyright (c) 2022, Linaro Limited
+#
+
+obj-$(CONFIG_FWU_MULTI_BANK_UPDATE) += fwu.o
+obj-$(CONFIG_FWU_MDATA_GPT_BLK) += fwu_gpt.o
+obj-$(CONFIG_FWU_MDATA_MTD) += fwu_mtd.o
+obj-$(CONFIG_FWU_MDATA_V1) += fwu_v1.o
+obj-$(CONFIG_FWU_MDATA_V2) += fwu_v2.o
diff --git a/lib/fwu_updates/fwu.c b/lib/fwu_updates/fwu.c
new file mode 100644
index 0000000000..129905236a
--- /dev/null
+++ b/lib/fwu_updates/fwu.c
@@ -0,0 +1,750 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#include <dm.h>
+#include <efi.h>
+#include <efi_loader.h>
+#include <efi_variable.h>
+#include <event.h>
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+#include <malloc.h>
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#include <u-boot/crc.h>
+
+struct fwu_data g_fwu_data;
+static struct udevice *g_dev;
+static u8 in_trial;
+static u8 boottime_check;
+
+enum {
+	IMAGE_ACCEPT_SET = 1,
+	IMAGE_ACCEPT_CLEAR,
+};
+
+static int trial_counter_update(u16 *trial_state_ctr)
+{
+	bool delete;
+	u32 var_attr;
+	efi_status_t status;
+	efi_uintn_t var_size;
+
+	delete = !trial_state_ctr ? true : false;
+	var_size = !trial_state_ctr ? 0 : (efi_uintn_t)sizeof(*trial_state_ctr);
+	var_attr = !trial_state_ctr ? 0 : EFI_VARIABLE_NON_VOLATILE |
+		EFI_VARIABLE_BOOTSERVICE_ACCESS;
+	status = efi_set_variable_int(u"TrialStateCtr",
+				      &efi_global_variable_guid,
+				      var_attr,
+				      var_size, trial_state_ctr, false);
+
+	if ((delete && (status != EFI_NOT_FOUND &&
+			status != EFI_SUCCESS)) ||
+	    (!delete && status != EFI_SUCCESS))
+		return -1;
+
+	return 0;
+}
+
+static int trial_counter_read(u16 *trial_state_ctr)
+{
+	efi_status_t status;
+	efi_uintn_t var_size;
+
+	var_size = (efi_uintn_t)sizeof(trial_state_ctr);
+	status = efi_get_variable_int(u"TrialStateCtr",
+				      &efi_global_variable_guid,
+				      NULL,
+				      &var_size, trial_state_ctr,
+				      NULL);
+	if (status != EFI_SUCCESS) {
+		log_err("Unable to read TrialStateCtr variable\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int fwu_trial_count_update(void)
+{
+	int ret;
+	u16 trial_state_ctr;
+
+	ret = trial_counter_read(&trial_state_ctr);
+	if (ret) {
+		log_debug("Unable to read trial_state_ctr\n");
+		goto out;
+	}
+
+	++trial_state_ctr;
+	if (trial_state_ctr > CONFIG_FWU_TRIAL_STATE_CNT) {
+		log_info("Trial State count exceeded. Revert back to previous_active_index\n");
+		ret = fwu_revert_boot_index();
+		if (ret)
+			log_err("Unable to revert active_index\n");
+		ret = 1;
+	} else {
+		log_info("Trial State count: attempt %d out of %d\n",
+			 trial_state_ctr, CONFIG_FWU_TRIAL_STATE_CNT);
+		ret = trial_counter_update(&trial_state_ctr);
+		if (ret)
+			log_err("Unable to increment TrialStateCtr variable\n");
+	}
+
+out:
+	return ret;
+}
+
+static u32 in_trial_state(void)
+{
+	return g_fwu_data.trial_state;
+}
+
+static int fwu_get_image_type_id(u8 image_index, efi_guid_t *image_type_id)
+{
+	int i;
+	struct efi_fw_image *image;
+
+	image = update_info.images;
+	for (i = 0; i < update_info.num_images; i++) {
+		if (image_index == image[i].image_index) {
+			guidcpy(image_type_id, &image[i].image_type_id);
+			return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+
+static int mdata_crc_check(struct fwu_mdata *mdata)
+{
+	int ret;
+	u32 calc_crc32;
+	uint32_t mdata_size;
+	void *buf = &mdata->version;
+
+	ret = fwu_get_mdata_size(&mdata_size);
+	if (ret)
+		return ret;
+
+	calc_crc32 = crc32(0, buf, mdata_size - sizeof(u32));
+	return calc_crc32 == mdata->crc32 ? 0 : -EINVAL;
+}
+
+static void fwu_data_crc_update(uint32_t crc32)
+{
+	g_fwu_data.crc32 = crc32;
+}
+
+/**
+ * fwu_get_data() - Return the version agnostic FWU structure
+ *
+ * Return the pointer to the version agnostic FWU structure.
+ *
+ * Return: Pointer to the FWU data structure
+ */
+struct fwu_data *fwu_get_data(void)
+{
+	return &g_fwu_data;
+}
+
+static void fwu_populate_mdata_bank_index(struct fwu_data *fwu_data)
+{
+	struct fwu_mdata *mdata = fwu_data->fwu_mdata;
+
+	mdata->active_index = fwu_data->active_index;
+	mdata->previous_active_index = fwu_data->previous_active_index;
+}
+
+/**
+ * fwu_get_dev() - Return the FWU metadata device
+ *
+ * Return the pointer to the FWU metadata device.
+ *
+ * Return: Pointer to the FWU metadata dev
+ */
+struct udevice *fwu_get_dev(void)
+{
+	return g_dev;
+}
+
+/**
+ * fwu_sync_mdata() - Update given meta-data partition(s) with the copy provided
+ * @data: FWU Data structure
+ * @part: Bitmask of FWU metadata partitions to be written to
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_sync_mdata(struct fwu_mdata *mdata, int part)
+{
+	int err;
+	uint mdata_size;
+	void *buf = &mdata->version;
+
+	if (part == BOTH_PARTS) {
+		err = fwu_sync_mdata(mdata, SECONDARY_PART);
+		if (err)
+			return err;
+		part = PRIMARY_PART;
+	}
+
+	err = fwu_get_mdata_size(&mdata_size);
+	if (err)
+		return err;
+
+	/*
+	 * Calculate the crc32 for the updated FWU metadata
+	 * and put the updated value in the FWU metadata crc32
+	 * field
+	 */
+	mdata->crc32 = crc32(0, buf, mdata_size - sizeof(u32));
+	fwu_data_crc_update(mdata->crc32);
+
+	err = fwu_write_mdata(g_dev, mdata, part == PRIMARY_PART, mdata_size);
+	if (err) {
+		log_err("Unable to write %s mdata\n",
+			part == PRIMARY_PART ?  "primary" : "secondary");
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * fwu_mdata_copies_allocate() - Allocate memory for metadata
+ * @mdata_size: Size of the metadata structure
+ *
+ * Allocate memory for storing both the copies of the FWU metadata. The
+ * copies are then used as a cache for storing FWU metadata contents.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_mdata_copies_allocate(u32 mdata_size)
+{
+	if (g_fwu_data.fwu_mdata)
+		return 0;
+
+	/*
+	 * Allocate the total memory that would be needed for both
+	 * the copies.
+	 */
+	g_fwu_data.fwu_mdata = calloc(2, mdata_size);
+	if (!g_fwu_data.fwu_mdata) {
+		log_err("Unable to allocate space for FWU metadata\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * fwu_get_mdata() - Read, verify and return the FWU metadata
+ * @mdata: Output FWU metadata read or NULL
+ *
+ * Read both the metadata copies from the storage media, verify their checksum,
+ * and ascertain that both copies match. If one of the copies has gone bad,
+ * restore it from the good copy.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata(struct fwu_mdata *mdata)
+{
+	int err;
+	uint32_t mdata_size;
+	bool parts_ok[2] = { false };
+	struct fwu_mdata *parts_mdata[2];
+
+	err = fwu_get_mdata_size(&mdata_size);
+	if (err)
+		return err;
+
+	parts_mdata[0] = g_fwu_data.fwu_mdata;
+	if (!parts_mdata[0]) {
+		log_err("Memory not allocated for the FWU Metadata copies\n");
+		return -ENOMEM;
+	}
+
+	parts_mdata[1] = (struct fwu_mdata *)((char *)parts_mdata[0] +
+					      mdata_size);
+
+	/* if mdata already read and ready */
+	err = mdata_crc_check(parts_mdata[0]);
+	if (!err)
+		goto ret_mdata;
+
+
+	/* else read, verify and, if needed, fix mdata */
+	for (int i = 0; i < 2; i++) {
+		parts_ok[i] = false;
+		err = fwu_read_mdata(g_dev, parts_mdata[i], !i, mdata_size);
+		if (!err) {
+			err = mdata_crc_check(parts_mdata[i]);
+			if (!err)
+				parts_ok[i] = true;
+			else
+				log_debug("mdata : %s crc32 failed\n", i ? "secondary" : "primary");
+		}
+	}
+
+	if (parts_ok[0] && parts_ok[1]) {
+		/*
+		 * Before returning, check that both the
+		 * FWU metadata copies are the same.
+		 */
+		err = memcmp(parts_mdata[0], parts_mdata[1], mdata_size);
+		if (!err)
+			goto ret_mdata;
+
+		/*
+		 * If not, populate the secondary partition from the
+		 * primary partition copy.
+		 */
+		log_info("Both FWU metadata copies are valid but do not match.");
+		log_info(" Restoring the secondary partition from the primary\n");
+		parts_ok[1] = false;
+	}
+
+	for (int i = 0; i < 2; i++) {
+		if (parts_ok[i])
+			continue;
+
+		memcpy(parts_mdata[i], parts_mdata[1 - i], mdata_size);
+		err = fwu_sync_mdata(parts_mdata[i], i ? SECONDARY_PART : PRIMARY_PART);
+		if (err) {
+			log_debug("mdata : %s write failed\n", i ? "secondary" : "primary");
+			return err;
+		}
+	}
+
+ret_mdata:
+	if (!err && mdata)
+		memcpy(mdata, parts_mdata[0], mdata_size);
+
+	return err;
+}
+
+/**
+ * fwu_get_active_index() - Get active_index from the FWU metadata
+ * @active_idx: active_index value to be read
+ *
+ * Read the active_index field from the FWU metadata and place it in
+ * the variable pointed to be the function argument.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_get_active_index(uint *active_idx)
+{
+	int ret = 0;
+	struct fwu_data *data = &g_fwu_data;
+
+	/*
+	 * Found the FWU metadata partition, now read the active_index
+	 * value
+	 */
+	*active_idx = data->active_index;
+	if (*active_idx >= CONFIG_FWU_NUM_BANKS) {
+		log_debug("Active index value read is incorrect\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * fwu_set_active_index() - Set active_index in the FWU metadata
+ * @active_idx: active_index value to be set
+ *
+ * Update the active_index field in the FWU metadata
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_set_active_index(uint active_idx)
+{
+	int ret;
+	struct fwu_data *data =  &g_fwu_data;
+
+	if (active_idx >= CONFIG_FWU_NUM_BANKS) {
+		log_debug("Invalid active index value\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Update the active index and previous_active_index fields
+	 * in the FWU metadata
+	 */
+	data->previous_active_index = data->active_index;
+	data->active_index = active_idx;
+
+	fwu_populate_mdata_bank_index(data);
+
+	/*
+	 * Now write this updated FWU metadata to both the
+	 * FWU metadata partitions
+	 */
+	ret = fwu_sync_mdata(data->fwu_mdata, BOTH_PARTS);
+	if (ret) {
+		log_debug("Failed to update FWU metadata partitions\n");
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+/**
+ * fwu_get_dfu_alt_num() - Get the dfu_alt_num to be used for capsule update
+ * @image_index:	The Image Index for the image
+ * @alt_num:		pointer to store dfu_alt_num
+ *
+ * Currently, the capsule update driver uses the DFU framework for
+ * the updates. This function gets the DFU alt number which is to
+ * be used for capsule update.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_get_dfu_alt_num(u8 image_index, u8 *alt_num)
+{
+	int ret, i;
+	uint update_bank;
+	efi_guid_t *image_guid, image_type_id;
+	struct fwu_data *data = &g_fwu_data;
+	struct fwu_image_entry *img_entry;
+	struct fwu_image_bank_info *img_bank_info;
+
+	ret = fwu_plat_get_update_index(&update_bank);
+	if (ret) {
+		log_debug("Failed to get the FWU update bank\n");
+		goto out;
+	}
+
+	ret = fwu_get_image_type_id(image_index, &image_type_id);
+	if (ret) {
+		log_debug("Unable to get image_type_id for image_index %u\n",
+			  image_index);
+		goto out;
+	}
+
+	ret = -EINVAL;
+	/*
+	 * The FWU metadata has been read. Now get the image_guid for the
+	 * image with the update_bank.
+	 */
+	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
+		if (!guidcmp(&image_type_id,
+			     &data->fwu_images[i].image_type_guid)) {
+			img_entry = &data->fwu_images[i];
+			img_bank_info = &img_entry->img_bank_info[update_bank];
+			image_guid = &img_bank_info->image_guid;
+			ret = fwu_plat_get_alt_num(g_dev, image_guid, alt_num);
+			if (ret)
+				log_debug("alt_num not found for partition with GUID %pUs\n",
+					  image_guid);
+			else
+				log_debug("alt_num %d for partition %pUs\n",
+					  *alt_num, image_guid);
+
+			goto out;
+		}
+	}
+
+	log_err("Partition with the image type %pUs not found\n",
+		&image_type_id);
+
+out:
+	return ret;
+}
+
+/**
+ * fwu_revert_boot_index() - Revert the active index in the FWU metadata
+ *
+ * Revert the active_index value in the FWU metadata, by swapping the values
+ * of active_index and previous_active_index in both copies of the
+ * FWU metadata.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_revert_boot_index(void)
+{
+	int ret;
+	u32 cur_active_index;
+	struct fwu_data *data =  &g_fwu_data;
+
+	/*
+	 * Swap the active index and previous_active_index fields
+	 * in the FWU metadata
+	 */
+	cur_active_index = data->active_index;
+	data->active_index = data->previous_active_index;
+	data->previous_active_index = cur_active_index;
+
+	fwu_populate_mdata_bank_index(data);
+
+	/*
+	 * Now write this updated FWU metadata to both the
+	 * FWU metadata partitions
+	 */
+	ret = fwu_sync_mdata(data->fwu_mdata, BOTH_PARTS);
+	if (ret) {
+		log_debug("Failed to update FWU metadata partitions\n");
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+/**
+ * fwu_clrset_image_accept() - Set or Clear the Acceptance bit for the image
+ * @img_type_id: GUID of the image type for which the accepted bit is to be
+ *               set or cleared
+ * @bank: Bank of which the image's Accept bit is to be set or cleared
+ * @action: Action which specifies whether image's Accept bit is to be set or
+ *          cleared
+ *
+ * Set/Clear the accepted bit for the image specified by the img_guid parameter.
+ * This indicates acceptance or rejection of image for subsequent boots by some
+ * governing component like OS(or firmware).
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+static int fwu_clrset_image_accept(efi_guid_t *img_type_id, u32 bank, u8 action)
+{
+	int ret, i;
+	struct fwu_data *data = &g_fwu_data;
+	struct fwu_image_entry *img_entry;
+	struct fwu_image_bank_info *img_bank_info;
+
+	img_entry = &data->fwu_images[0];
+	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
+		if (!guidcmp(&img_entry[i].image_type_guid, img_type_id)) {
+			img_bank_info = &img_entry[i].img_bank_info[bank];
+			if (action == IMAGE_ACCEPT_SET)
+				img_bank_info->accepted |= FWU_IMAGE_ACCEPTED;
+			else
+				img_bank_info->accepted = 0;
+
+			fwu_populate_mdata_image_info(data);
+			ret = fwu_sync_mdata(data->fwu_mdata, BOTH_PARTS);
+			goto out;
+		}
+	}
+
+	/* Image not found */
+	ret = -ENOENT;
+
+out:
+	return ret;
+}
+
+/**
+ * fwu_accept_image() - Set the Acceptance bit for the image
+ * @img_type_id: GUID of the image type for which the accepted bit is to be
+ *               cleared
+ * @bank: Bank of which the image's Accept bit is to be set
+ *
+ * Set the accepted bit for the image specified by the img_guid parameter. This
+ * indicates acceptance of image for subsequent boots by some governing component
+ * like OS(or firmware).
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_accept_image(efi_guid_t *img_type_id, u32 bank)
+{
+	return fwu_clrset_image_accept(img_type_id, bank,
+				       IMAGE_ACCEPT_SET);
+}
+
+/**
+ * fwu_clear_accept_image() - Clear the Acceptance bit for the image
+ * @img_type_id: GUID of the image type for which the accepted bit is to be
+ *               cleared
+ * @bank: Bank of which the image's Accept bit is to be cleared
+ *
+ * Clear the accepted bit for the image type specified by the img_type_id parameter.
+ * This function is called after the image has been updated. The accepted bit is
+ * cleared to be set subsequently after passing the image acceptance criteria, by
+ * either the OS(or firmware)
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_clear_accept_image(efi_guid_t *img_type_id, u32 bank)
+{
+	return fwu_clrset_image_accept(img_type_id, bank,
+				       IMAGE_ACCEPT_CLEAR);
+}
+
+/**
+ * fwu_plat_get_update_index() - Get the value of the update bank
+ * @update_idx: Bank number to which images are to be updated
+ *
+ * Get the value of the bank(partition) to which the update needs to be
+ * made.
+ *
+ * Note: This is a weak function and platforms can override this with
+ * their own implementation for selection of the update bank.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+__weak int fwu_plat_get_update_index(uint *update_idx)
+{
+	int ret;
+	u32 active_idx;
+
+	ret = fwu_get_active_index(&active_idx);
+	if (ret < 0)
+		return -1;
+
+	*update_idx = (active_idx + 1) % CONFIG_FWU_NUM_BANKS;
+
+	return ret;
+}
+
+/**
+ * fwu_plat_get_bootidx() - Get the value of the boot index
+ * @boot_idx: Boot index value
+ *
+ * Get the value of the bank(partition) from which the platform
+ * has booted. This value is passed to U-Boot from the earlier
+ * stage bootloader which loads and boots all the relevant
+ * firmware images
+ */
+__weak void fwu_plat_get_bootidx(uint *boot_idx)
+{
+	int ret;
+
+	ret = fwu_get_active_index(boot_idx);
+	if (ret < 0)
+		*boot_idx = 0; /* Dummy value */
+}
+
+/**
+ * fwu_update_checks_pass() - Check if FWU update can be done
+ *
+ * Check if the FWU update can be executed. The updates are
+ * allowed only when the platform is not in Trial State and
+ * the boot time checks have passed
+ *
+ * Return: 1 if OK, 0 if checks do not pass
+ *
+ */
+u8 fwu_update_checks_pass(void)
+{
+	return !in_trial && boottime_check;
+}
+
+/**
+ * fwu_empty_capsule_checks_pass() - Check if empty capsule can be processed
+ *
+ * Check if the empty capsule can be processed to either accept or revert
+ * an earlier executed update. The empty capsules need to be processed
+ * only when the platform is in Trial State and the boot time checks have
+ * passed
+ *
+ * Return: 1 if OK, 0 if not to be allowed
+ *
+ */
+u8 fwu_empty_capsule_checks_pass(void)
+{
+	return in_trial && boottime_check;
+}
+
+/**
+ * fwu_trial_state_ctr_start() - Start the Trial State counter
+ *
+ * Start the counter to identify the platform booting in the
+ * Trial State. The counter is implemented as an EFI variable.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+int fwu_trial_state_ctr_start(void)
+{
+	int ret;
+	u16 trial_state_ctr;
+
+	trial_state_ctr = 0;
+	ret = trial_counter_update(&trial_state_ctr);
+	if (ret)
+		log_err("Unable to initialise TrialStateCtr\n");
+
+	return ret;
+}
+
+static int fwu_boottime_checks(void *ctx, struct event *event)
+{
+	int ret;
+	u32 boot_idx, active_idx;
+
+	ret = uclass_first_device_err(UCLASS_FWU_MDATA, &g_dev);
+	if (ret) {
+		log_debug("Cannot find fwu device\n");
+		return ret;
+	}
+
+	/* Don't have boot time checks on sandbox */
+	if (IS_ENABLED(CONFIG_SANDBOX)) {
+		boottime_check = 1;
+		return 0;
+	}
+
+	ret = fwu_init();
+	if (ret) {
+		log_debug("fwu_init() failed\n");
+		return ret;
+	}
+
+	/*
+	 * Get the Boot Index, i.e. the bank from
+	 * which the platform has booted. This value
+	 * gets passed from the ealier stage bootloader
+	 * which booted u-boot, e.g. tf-a. If the
+	 * boot index is not the same as the
+	 * active_index read from the FWU metadata,
+	 * update the active_index.
+	 */
+	fwu_plat_get_bootidx(&boot_idx);
+	if (boot_idx >= CONFIG_FWU_NUM_BANKS) {
+		log_err("Received incorrect value of boot_index\n");
+		return 0;
+	}
+
+	ret = fwu_get_active_index(&active_idx);
+	if (ret) {
+		log_err("Unable to read active_index\n");
+		return 0;
+	}
+
+	if (boot_idx != active_idx) {
+		log_info("Boot idx %u is not matching active idx %u, changing active_idx\n",
+			 boot_idx, active_idx);
+		ret = fwu_set_active_index(boot_idx);
+		if (!ret)
+			boottime_check = 1;
+	}
+
+	if (efi_init_obj_list() != EFI_SUCCESS)
+		return 0;
+
+	in_trial = in_trial_state();
+	if (!in_trial || (ret = fwu_trial_count_update()) > 0)
+		ret = trial_counter_update(NULL);
+
+	if (!ret)
+		boottime_check = 1;
+
+	return 0;
+}
+
+EVENT_SPY(EVT_MAIN_LOOP, fwu_boottime_checks);
diff --git a/lib/fwu_updates/fwu_gpt.c b/lib/fwu_updates/fwu_gpt.c
new file mode 100644
index 0000000000..4a2f4e9a8d
--- /dev/null
+++ b/lib/fwu_updates/fwu_gpt.c
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2022, Linaro Limited
+ */
+
+#include <blk.h>
+#include <dfu.h>
+#include <efi.h>
+#include <efi_loader.h>
+#include <fwu.h>
+#include <log.h>
+#include <part.h>
+
+#include <linux/errno.h>
+
+static int get_gpt_dfu_identifier(struct blk_desc *desc, efi_guid_t *image_guid)
+{
+	int i;
+	struct disk_partition info;
+	efi_guid_t unique_part_guid;
+
+	for (i = 1; i < MAX_SEARCH_PARTITIONS; i++) {
+		if (part_get_info(desc, i, &info))
+			continue;
+		uuid_str_to_bin(info.uuid, unique_part_guid.b,
+				UUID_STR_FORMAT_GUID);
+
+		if (!guidcmp(&unique_part_guid, image_guid))
+			return i;
+	}
+
+	log_err("No partition found with image_guid %pUs\n", image_guid);
+	return -ENOENT;
+}
+
+static int fwu_alt_num_for_dfu_dev(struct dfu_entity *dfu, int dev_num,
+				   int part, unsigned char dfu_dev,
+				   u8 *alt_num)
+{
+	int ret;
+
+	switch (dfu_dev) {
+	case DFU_DEV_MMC:
+		if (dfu->layout == DFU_RAW_ADDR &&
+		    dfu->data.mmc.dev_num == dev_num &&
+		    dfu->data.mmc.part == part) {
+			*alt_num = dfu->alt;
+			ret = 0;
+		} else {
+			ret = -ENOENT;
+		}
+		break;
+	default:
+		ret = -ENOENT;
+	}
+
+	return ret;
+}
+
+static int fwu_gpt_get_alt_num(struct blk_desc *desc, efi_guid_t *image_guid,
+			       u8 *alt_num, unsigned char dfu_dev)
+{
+	int ret = -1;
+	int i, part, dev_num;
+	struct dfu_entity *dfu;
+
+	dev_num = desc->devnum;
+	part = get_gpt_dfu_identifier(desc, image_guid);
+	if (part < 0)
+		return -ENOENT;
+
+	ret = dfu_init_env_entities(NULL, NULL);
+	if (ret)
+		goto out;
+
+	i = 0;
+	while (true) {
+		dfu = dfu_get_entity(i++);
+		if (!dfu) {
+			ret = -ENOENT;
+			break;
+		}
+
+		if (dfu->dev_type != dfu_dev)
+			continue;
+
+		ret = fwu_alt_num_for_dfu_dev(dfu, dev_num, part, dfu_dev,
+					      alt_num);
+		if (!ret)
+			break;
+	}
+
+out:
+	dfu_free_entities();
+
+	return ret;
+}
+
+/**
+ * fwu_plat_get_alt_num() - Get the DFU alt number
+ * @dev: FWU metadata device
+ * @image_guid: GUID value of the image for which the alt num is to
+ *              be obtained
+ * @alt_num: The DFU alt number for the image that is to be updated
+ *
+ * Get the DFU alt number for the image that is to be updated. The
+ * image is identified with the image_guid parameter that is passed
+ * to the function.
+ *
+ * Note: This is a weak function and platforms can override this with
+ * their own implementation for obtaining the alt number value.
+ *
+ * Return: 0 if OK, -ve on error
+ *
+ */
+__weak int fwu_plat_get_alt_num(struct udevice *dev, efi_guid_t *image_guid,
+				u8 *alt_num)
+{
+	struct fwu_mdata_gpt_blk_priv *priv = dev_get_priv(dev);
+
+	return fwu_gpt_get_alt_num(dev_get_uclass_plat(priv->blk_dev),
+				   image_guid, alt_num, DFU_DEV_MMC);
+}
diff --git a/lib/fwu_updates/fwu_mtd.c b/lib/fwu_updates/fwu_mtd.c
new file mode 100644
index 0000000000..e8211dd5ba
--- /dev/null
+++ b/lib/fwu_updates/fwu_mtd.c
@@ -0,0 +1,187 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023, Linaro Limited
+ */
+
+#include <dm.h>
+#include <dfu.h>
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+#include <malloc.h>
+#include <mtd.h>
+#include <uuid.h>
+#include <vsprintf.h>
+
+#include <dm/ofnode.h>
+
+static struct fwu_mtd_image_info *mtd_img_by_uuid(const char *uuidbuf)
+{
+	int num_images;
+	struct fwu_mdata_mtd_priv *mtd_priv = dev_get_priv(fwu_get_dev());
+	struct fwu_mtd_image_info *image_info = mtd_priv->fwu_mtd_images;
+
+	if (!image_info)
+		return NULL;
+
+	num_images = CONFIG_FWU_NUM_BANKS *
+		CONFIG_FWU_NUM_IMAGES_PER_BANK;
+
+	for (int i = 0; i < num_images; i++)
+		if (!strcmp(uuidbuf, image_info[i].uuidbuf))
+			return &image_info[i];
+
+	return NULL;
+}
+
+int fwu_mtd_get_alt_num(efi_guid_t *image_id, u8 *alt_num,
+			const char *mtd_dev)
+{
+	struct fwu_mtd_image_info *mtd_img_info;
+	char uuidbuf[UUID_STR_LEN + 1];
+	fdt_addr_t offset, size = 0;
+	struct dfu_entity *dfu;
+	int i, nalt, ret;
+
+	mtd_probe_devices();
+
+	uuid_bin_to_str(image_id->b, uuidbuf, UUID_STR_FORMAT_STD);
+
+	mtd_img_info = mtd_img_by_uuid(uuidbuf);
+	if (!mtd_img_info) {
+		log_err("%s: Not found partition for image %s\n", __func__, uuidbuf);
+		return -ENOENT;
+	}
+
+	offset = mtd_img_info->start;
+	size = mtd_img_info->size;
+
+	ret = dfu_init_env_entities(NULL, NULL);
+	if (ret)
+		return -ENOENT;
+
+	nalt = 0;
+	list_for_each_entry(dfu, &dfu_list, list)
+		nalt++;
+
+	if (!nalt) {
+		log_warning("No entities in dfu_alt_info\n");
+		dfu_free_entities();
+		return -ENOENT;
+	}
+
+	ret = -ENOENT;
+	for (i = 0; i < nalt; i++) {
+		dfu = dfu_get_entity(i);
+
+		/* Only MTD RAW access */
+		if (!dfu || dfu->dev_type != DFU_DEV_MTD ||
+		    dfu->layout != DFU_RAW_ADDR ||
+			dfu->data.mtd.start != offset ||
+			dfu->data.mtd.size != size)
+			continue;
+
+		*alt_num = dfu->alt;
+		ret = 0;
+		break;
+	}
+
+	dfu_free_entities();
+
+	log_debug("%s: %s -> %d\n", __func__, uuidbuf, *alt_num);
+	return ret;
+}
+
+/**
+ * fwu_plat_get_alt_num() - Get the DFU Alt Num for the image from the platform
+ * @dev: FWU device
+ * @image_id: Image GUID for which DFU alt number needs to be retrieved
+ * @alt_num: Pointer to the alt_num
+ *
+ * Get the DFU alt number from the platform for the image specified by the
+ * image GUID.
+ *
+ * Note: This is a weak function and platforms can override this with
+ * their own implementation for obtaining the alt number value.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+__weak int fwu_plat_get_alt_num(struct udevice *dev, efi_guid_t *image_id,
+				u8 *alt_num)
+{
+	return fwu_mtd_get_alt_num(image_id, alt_num, "nor1");
+}
+
+static int gen_image_alt_info(char *buf, size_t len,
+			      struct fwu_image_entry *img, struct mtd_info *mtd)
+{
+	char *p = buf, *end = buf + len;
+	int i;
+
+	p += snprintf(p, end - p, "mtd %s", mtd->name);
+	if (end < p) {
+		log_err("%s:%d Run out of buffer\n", __func__, __LINE__);
+		return -E2BIG;
+	}
+
+	/*
+	 * List the image banks in the FWU mdata and search the corresponding
+	 * partition based on partition's uuid.
+	 */
+	for (i = 0; i < CONFIG_FWU_NUM_BANKS; i++) {
+		struct fwu_mtd_image_info *mtd_img_info;
+		struct fwu_image_bank_info *bank;
+		char uuidbuf[UUID_STR_LEN + 1];
+		u32 offset, size;
+
+		/* Query a partition by image UUID */
+		bank = &img->img_bank_info[i];
+		uuid_bin_to_str(bank->image_guid.b, uuidbuf, UUID_STR_FORMAT_STD);
+
+		mtd_img_info = mtd_img_by_uuid(uuidbuf);
+		if (!mtd_img_info) {
+			log_err("%s: Not found partition for image %s\n", __func__, uuidbuf);
+			break;
+		}
+
+		offset = mtd_img_info->start;
+		size = mtd_img_info->size;
+
+		p += snprintf(p, end - p, "%sbank%d raw %x %x",
+			      i == 0 ? "=" : ";", i, offset, size);
+		if (end < p) {
+			log_err("%s:%d Run out of buffer\n", __func__, __LINE__);
+			return -E2BIG;
+		}
+	}
+
+	if (i == CONFIG_FWU_NUM_BANKS)
+		return 0;
+
+	return -ENOENT;
+}
+
+int fwu_gen_alt_info_from_mtd(char *buf, size_t len, struct mtd_info *mtd)
+{
+	int i, l, ret;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_image_entry *img_entry;
+
+	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
+		img_entry = &data->fwu_images[i];
+		ret = gen_image_alt_info(buf, len, img_entry, mtd);
+		if (ret)
+			break;
+
+		l = strlen(buf);
+		/* Replace the last ';' with '&' if there is another image. */
+		if (i != CONFIG_FWU_NUM_IMAGES_PER_BANK - 1 && l) {
+			buf[l] = '&';
+			buf++;
+		}
+		len -= l;
+		buf += l;
+	}
+
+	return ret;
+}
diff --git a/lib/fwu_updates/fwu_v1.c b/lib/fwu_updates/fwu_v1.c
new file mode 100644
index 0000000000..efb8d51500
--- /dev/null
+++ b/lib/fwu_updates/fwu_v1.c
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024, Linaro Limited
+ */
+
+#include <fwu.h>
+#include <fwu_mdata.h>
+
+#include <linux/types.h>
+
+#define FWU_MDATA_VERSION	0x1U
+
+static uint32_t fwu_check_trial_state(struct fwu_mdata *mdata, uint32_t bank)
+{
+	u32 i;
+	struct fwu_image_entry *img_entry;
+	struct fwu_image_bank_info *img_bank_info;
+
+	img_entry = &mdata->img_entry[0];
+	for (i = 0; i < CONFIG_FWU_NUM_IMAGES_PER_BANK; i++) {
+		img_bank_info = &img_entry[i].img_bank_info[bank];
+		if (!img_bank_info->accepted) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void fwu_data_init(void)
+{
+	size_t image_info_size;
+	void *dst_img_info, *src_img_info;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	data->crc32 = mdata->crc32;
+	data->version = mdata->version;
+	data->active_index = mdata->active_index;
+	data->previous_active_index = mdata->previous_active_index;
+
+	data->metadata_size = sizeof(struct fwu_mdata);
+	data->num_banks = CONFIG_FWU_NUM_BANKS;
+	data->num_images = CONFIG_FWU_NUM_IMAGES_PER_BANK;
+	fwu_plat_get_bootidx(&data->boot_index);
+	data->trial_state = fwu_check_trial_state(mdata, data->boot_index);
+
+	src_img_info = &mdata->img_entry[0];
+	dst_img_info = &data->fwu_images[0];
+	image_info_size = sizeof(data->fwu_images);
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+static int fwu_trial_state_update(bool trial_state)
+{
+	int ret;
+	struct fwu_data *data = fwu_get_data();
+
+	if (trial_state) {
+		ret = fwu_trial_state_ctr_start();
+		if (ret)
+			return ret;
+	}
+
+	data->trial_state = trial_state;
+
+	return 0;
+}
+
+/**
+ * fwu_populate_mdata_image_info() - Populate the image information
+ * of the metadata
+ * @data: Version agnostic FWU metadata information
+ *
+ * Populate the image information in the FWU metadata by copying it
+ * from the version agnostic structure. This is done before the
+ * metadata gets written to the storage media.
+ *
+ * Return: None
+ */
+void fwu_populate_mdata_image_info(struct fwu_data *data)
+{
+	size_t image_info_size;
+	void *dst_img_info, *src_img_info;
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	image_info_size = sizeof(data->fwu_images);
+	dst_img_info = &mdata->img_entry[0];
+	src_img_info = &data->fwu_images[0];
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+/**
+ * fwu_state_machine_updates() - Update FWU state of the platform
+ * @trial_state: Is platform transitioning into Trial State
+ * @update_index: Bank number to which images have been updated
+ *
+ * On successful completion of updates, transition the platform to
+ * either Trial State or Regular State.
+ *
+ * To transition the platform to Trial State, start the
+ * TrialStateCtr counter, followed by setting the value of bank_state
+ * field of the metadata to Valid state(applicable only in version 2
+ * of metadata).
+ *
+ * In case, the platform is to transition directly to Regular State,
+ * update the bank_state field of the metadata to Accepted
+ * state(applicable only in version 2 of metadata).
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_state_machine_updates(bool trial_state,
+			      __maybe_unused uint32_t update_index)
+{
+	return fwu_trial_state_update(trial_state);
+}
+
+/**
+ * fwu_get_mdata_size() - Get the FWU metadata size
+ * @mdata_size: Size of the metadata structure
+ *
+ * Get the size of the FWU metadata.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata_size(uint32_t *mdata_size)
+{
+	*mdata_size = sizeof(struct fwu_mdata);
+
+	return 0;
+}
+
+/**
+ * fwu_init() - FWU specific initialisations
+ *
+ * Carry out some FWU specific initialisations including allocation
+ * of memory for the metadata copies, and reading the FWU metadata
+ * copies into the allocated memory. The metadata fields are then
+ * copied into a version agnostic structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_init(void)
+{
+	int ret;
+	uint32_t mdata_size;
+
+	fwu_get_mdata_size(&mdata_size);
+
+	ret = fwu_mdata_copies_allocate(mdata_size);
+	if (ret)
+		return ret;
+
+	/*
+	 * Now read the entire structure, both copies, and
+	 * validate that the copies.
+	 */
+	ret = fwu_get_mdata(NULL);
+	if (ret)
+		return ret;
+
+	fwu_data_init();
+
+	return 0;
+}
diff --git a/lib/fwu_updates/fwu_v2.c b/lib/fwu_updates/fwu_v2.c
new file mode 100644
index 0000000000..108bc9bb4a
--- /dev/null
+++ b/lib/fwu_updates/fwu_v2.c
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2024, Linaro Limited
+ */
+
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+
+#include <linux/types.h>
+
+#define FWU_MDATA_VERSION	0x2U
+
+static inline struct fwu_fw_store_desc *fwu_get_fw_desc(struct fwu_mdata *mdata)
+{
+	return (struct fwu_fw_store_desc *)((u8 *)mdata + sizeof(*mdata));
+}
+
+static uint32_t fwu_check_trial_state(struct fwu_mdata *mdata, uint32_t bank)
+{
+	return mdata->bank_state[bank] == FWU_BANK_VALID ? 1 : 0;
+}
+
+static void fwu_data_init(void)
+{
+	int i;
+	size_t image_info_size;
+	void *dst_img_info, *src_img_info;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	data->crc32 = mdata->crc32;
+	data->version = mdata->version;
+	data->active_index = mdata->active_index;
+	data->previous_active_index = mdata->previous_active_index;
+	data->metadata_size = mdata->metadata_size;
+	fwu_plat_get_bootidx(&data->boot_index);
+	data->trial_state = fwu_check_trial_state(mdata, data->boot_index);
+
+	data->num_banks = fwu_get_fw_desc(mdata)->num_banks;
+	data->num_images = fwu_get_fw_desc(mdata)->num_images;
+
+	for (i = 0; i < 4; i++) {
+		data->bank_state[i] = mdata->bank_state[i];
+	}
+
+	image_info_size = sizeof(data->fwu_images);
+	src_img_info = &fwu_get_fw_desc(mdata)->img_entry[0];
+	dst_img_info = &data->fwu_images[0];
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+static int fwu_mdata_sanity_checks(void)
+{
+	uint8_t num_banks;
+	uint16_t num_images;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	if (mdata->version != FWU_MDATA_VERSION) {
+		log_err("FWU metadata version %u. Expected value of %u\n",
+			mdata->version, FWU_MDATA_VERSION);
+		return -EINVAL;
+	}
+
+	if (!mdata->desc_offset) {
+		log_err("No image information provided with the Metadata. ");
+		log_err("Image information expected in the metadata\n");
+		return -EINVAL;
+	}
+
+	if (mdata->desc_offset != 0x20) {
+		log_err("Descriptor Offset(0x%x) in the FWU Metadata not equal to 0x20\n",
+			mdata->desc_offset);
+		return -EINVAL;
+	}
+
+	num_banks = fwu_get_fw_desc(mdata)->num_banks;
+	num_images = fwu_get_fw_desc(mdata)->num_images;
+
+	if (num_banks != CONFIG_FWU_NUM_BANKS) {
+		log_err("Number of Banks(%u) in FWU Metadata different from the configured value(%d)",
+			num_banks, CONFIG_FWU_NUM_BANKS);
+		return -EINVAL;
+	}
+
+	if (num_images != CONFIG_FWU_NUM_IMAGES_PER_BANK) {
+		log_err("Number of Images(%u) in FWU Metadata different from the configured value(%d)",
+			num_images, CONFIG_FWU_NUM_IMAGES_PER_BANK);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int fwu_bank_state_update(bool trial_state, uint32_t bank)
+{
+	int ret;
+	struct fwu_data *data = fwu_get_data();
+	struct fwu_mdata *mdata = data->fwu_mdata;
+
+	mdata->bank_state[bank] = data->bank_state[bank] = trial_state ?
+		FWU_BANK_VALID : FWU_BANK_ACCEPTED;
+
+	ret = fwu_sync_mdata(mdata, BOTH_PARTS);
+	if (ret)
+		log_err("Unable to set bank_state for bank %u\n", bank);
+	else
+		data->trial_state = trial_state;
+
+	return ret;
+}
+
+static int fwu_trial_state_start(uint update_index)
+{
+	int ret;
+
+	ret = fwu_trial_state_ctr_start();
+	if (ret)
+		return ret;
+
+	ret = fwu_bank_state_update(1, update_index);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+/**
+ * fwu_populate_mdata_image_info() - Populate the image information
+ * of the metadata
+ * @data: Version agnostic FWU metadata information
+ *
+ * Populate the image information in the FWU metadata by copying it
+ * from the version agnostic structure. This is done before the
+ * metadata gets written to the storage media.
+ *
+ * Return: None
+ */
+void fwu_populate_mdata_image_info(struct fwu_data *data)
+{
+	size_t image_info_size;
+	struct fwu_mdata *mdata = data->fwu_mdata;
+	void *dst_img_info, *src_img_info;
+
+	image_info_size = sizeof(data->fwu_images);
+	dst_img_info = &fwu_get_fw_desc(mdata)->img_entry[0];
+	src_img_info = &data->fwu_images[0];
+
+	memcpy(dst_img_info, src_img_info, image_info_size);
+}
+
+/**
+ * fwu_state_machine_updates() - Update FWU state of the platform
+ * @trial_state: Is platform transitioning into Trial State
+ * @update_index: Bank number to which images have been updated
+ *
+ * On successful completion of updates, transition the platform to
+ * either Trial State or Regular State.
+ *
+ * To transition the platform to Trial State, start the
+ * TrialStateCtr counter, followed by setting the value of bank_state
+ * field of the metadata to Valid state(applicable only in version 2
+ * of metadata).
+ *
+ * In case, the platform is to transition directly to Regular State,
+ * update the bank_state field of the metadata to Accepted
+ * state(applicable only in version 2 of metadata).
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_state_machine_updates(bool trial_state, uint32_t update_index)
+{
+	return trial_state ? fwu_trial_state_start(update_index) :
+		fwu_bank_state_update(0, update_index);
+}
+
+/**
+ * fwu_get_mdata_size() - Get the FWU metadata size
+ * @mdata_size: Size of the metadata structure
+ *
+ * Get the size of the FWU metadata from the structure. This is later used
+ * to allocate memory for the structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_get_mdata_size(uint32_t *mdata_size)
+{
+	int ret = 0;
+	struct fwu_mdata mdata = { 0 };
+	struct fwu_data *data = fwu_get_data();
+	struct udevice *fwu_dev = fwu_get_dev();
+
+	if (data->metadata_size) {
+		*mdata_size = data->metadata_size;
+		return 0;
+	}
+
+	ret = fwu_read_mdata(fwu_dev, &mdata, 1,
+			     sizeof(struct fwu_mdata));
+	if (ret) {
+		log_err("FWU metadata read failed\n");
+		return ret;
+	}
+
+	*mdata_size = mdata.metadata_size;
+	if (!*mdata_size)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * fwu_init() - FWU specific initialisations
+ *
+ * Carry out some FWU specific initialisations including allocation
+ * of memory for the metadata copies, and reading the FWU metadata
+ * copies into the allocated memory. The metadata fields are then
+ * copied into a version agnostic structure.
+ *
+ * Return: 0 if OK, -ve on error
+ */
+int fwu_init(void)
+{
+	int ret;
+	struct fwu_mdata mdata = { 0 };
+	struct udevice *fwu_dev = fwu_get_dev();
+
+	/*
+	 * First we read only the top level structure
+	 * and get the size of the complete structure.
+	 */
+	ret = fwu_read_mdata(fwu_dev, &mdata, 1,
+			     sizeof(struct fwu_mdata));
+	if (ret) {
+		log_err("FWU metadata read failed\n");
+		return ret;
+	}
+
+	ret = fwu_mdata_copies_allocate(mdata.metadata_size);
+	if (ret)
+		return ret;
+
+	/*
+	 * Now read the entire structure, both copies, and
+	 * validate that the copies.
+	 */
+	ret = fwu_get_mdata(NULL);
+	if (ret)
+		return ret;
+
+	ret = fwu_mdata_sanity_checks();
+	if (ret)
+		return ret;
+
+	fwu_data_init();
+
+	return 0;
+}
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 8e13bf2b98..3be83f8020 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -189,6 +189,7 @@ dtc_cpp_flags  = -Wp,-MD,$(depfile).pre.tmp -nostdinc                    \
 		 -I$(srctree)/arch/$(ARCH)/dts                           \
 		 -I$(srctree)/arch/$(ARCH)/dts/include                   \
 		 -I$(srctree)/include                                    \
+		 -I$(EXT_DTS)                                            \
 		 -D__ASSEMBLY__                                          \
 		 -undef -D__DTS__
 
@@ -425,9 +426,11 @@ cmd_efi_objcopy = $(OBJCOPY) -j .header -j .text -j .sdata -j .data -j \
 $(obj)/%.efi: $(obj)/%_efi.so
 	$(call cmd,efi_objcopy)
 
+KBUILD_EFILDFLAGS = -nostdlib -zexecstack -znocombreloc -znorelro
+KBUILD_EFILDFLAGS += $(call ld-option,--no-warn-rwx-segments)
 quiet_cmd_efi_ld = LD      $@
-cmd_efi_ld = $(LD) -nostdlib -zexecstack -znocombreloc -T $(EFI_LDS_PATH) \
-		-shared -Bsymbolic -znorelro -s $^ -o $@
+cmd_efi_ld = $(LD) $(KBUILD_EFILDFLAGS) -T $(EFI_LDS_PATH) \
+		-shared -Bsymbolic -s $^ -o $@
 
 EFI_LDS_PATH = $(srctree)/arch/$(ARCH)/lib/$(EFI_LDS)
 
diff --git a/scripts/dtc/README b/scripts/dtc/README
new file mode 100644
index 0000000000..a48312a422
--- /dev/null
+++ b/scripts/dtc/README
@@ -0,0 +1,106 @@
+The source tree contains the Device Tree Compiler (dtc) toolchain for
+working with device tree source and binary files and also libfdt, a
+utility library for reading and manipulating the binary format.
+
+DTC and LIBFDT are maintained by:
+
+David Gibson <david@gibson.dropbear.id.au>
+Jon Loeliger <loeliger@gmail.com>
+
+
+Python library
+--------------
+
+A Python library is also available. To build this you will need to install
+swig and Python development files. On Debian distributions:
+
+   sudo apt-get install swig python3-dev
+
+The library provides an Fdt class which you can use like this:
+
+$ PYTHONPATH=../pylibfdt python3
+>>> import libfdt
+>>> fdt = libfdt.Fdt(open('test_tree1.dtb', mode='rb').read())
+>>> node = fdt.path_offset('/subnode@1')
+>>> print(node)
+124
+>>> prop_offset = fdt.first_property_offset(node)
+>>> prop = fdt.get_property_by_offset(prop_offset)
+>>> print('%s=%s' % (prop.name, prop.as_str()))
+compatible=subnode1
+>>> node2 = fdt.path_offset('/')
+>>> print(fdt.getprop(node2, 'compatible').as_str())
+test_tree1
+
+You will find tests in tests/pylibfdt_tests.py showing how to use each
+method. Help is available using the Python help command, e.g.:
+
+    $ cd pylibfdt
+    $ python3 -c "import libfdt; help(libfdt)"
+
+If you add new features, please check code coverage:
+
+    $ sudo apt-get install python3-coverage
+    $ cd tests
+    # It's just 'coverage' on most other distributions
+    $ python3-coverage run pylibfdt_tests.py
+    $ python3-coverage html
+    # Open 'htmlcov/index.html' in your browser
+
+
+The library can be installed with pip from a local source tree:
+
+    pip install . [--user|--prefix=/path/to/install_dir]
+
+Or directly from a remote git repo:
+
+    pip install git+git://git.kernel.org/pub/scm/utils/dtc/dtc.git@main
+
+The install depends on libfdt shared library being installed on the host system
+first. Generally, using --user or --prefix is not necessary and pip will use the
+default location for the Python installation which varies if the user is root or
+not.
+
+You can also install everything via make if you like, but pip is recommended.
+
+To install both libfdt and pylibfdt you can use:
+
+    make install [PREFIX=/path/to/install_dir]
+
+To disable building the python library, even if swig and Python are available,
+use:
+
+    make NO_PYTHON=1
+
+
+More work remains to support all of libfdt, including access to numeric
+values.
+
+
+Adding a new function to libfdt.h
+---------------------------------
+
+The shared library uses libfdt/version.lds to list the exported functions, so
+add your new function there. Check that your function works with pylibfdt. If
+it cannot be supported, put the declaration in libfdt.h behind #ifndef SWIG so
+that swig ignores it.
+
+
+Tests
+-----
+
+Test files are kept in the tests/ directory. Use 'make check' to build and run
+all tests.
+
+If you want to adjust a test file, be aware that tree_tree1.dts is compiled
+and checked against a binary tree from assembler macros in trees.S. So
+if you change that file you must change tree.S also.
+
+
+Mailing list
+------------
+The following list is for discussion about dtc and libfdt implementation
+mailto:devicetree-compiler@vger.kernel.org
+
+Core device tree bindings are discussed on the devicetree-spec list:
+mailto:devicetree-spec@vger.kernel.org
diff --git a/scripts/dtc/pylibfdt/Makefile b/scripts/dtc/pylibfdt/Makefile
index 493995e303..e442d5c242 100644
--- a/scripts/dtc/pylibfdt/Makefile
+++ b/scripts/dtc/pylibfdt/Makefile
@@ -13,11 +13,14 @@ include $(LIBFDT_srcdir)/Makefile.libfdt
 PYLIBFDT_srcs = $(addprefix $(LIBFDT_srcdir)/,$(LIBFDT_SRCS)) \
 		$(obj)/libfdt.i
 
+# create a version string compliant with PEP 440
+PEP_VERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(subst -,,$(EXTRAVERSION))
+
 quiet_cmd_pymod = PYMOD   $@
       cmd_pymod = unset CROSS_COMPILE; unset CFLAGS; \
 		CC="$(HOSTCC)" LDSHARED="$(HOSTCC) -shared " \
 		LDFLAGS="$(HOSTLDFLAGS)" \
-		VERSION="u-boot-$(UBOOTVERSION)" \
+		VERSION="$(PEP_VERSION)" \
 		CPPFLAGS="$(HOSTCFLAGS) -I$(LIBFDT_srcdir)" OBJDIR=$(obj) \
 		SOURCES="$(PYLIBFDT_srcs)" \
 		SWIG_OPTS="-I$(LIBFDT_srcdir) -I$(LIBFDT_srcdir)/.." \
diff --git a/scripts/dtc/pylibfdt/libfdt.i_shipped b/scripts/dtc/pylibfdt/libfdt.i_shipped
index 27c29ea260..56cc5d48f4 100644
--- a/scripts/dtc/pylibfdt/libfdt.i_shipped
+++ b/scripts/dtc/pylibfdt/libfdt.i_shipped
@@ -7,6 +7,10 @@
 
 %module libfdt
 
+%begin %{
+#define PY_SSIZE_T_CLEAN
+%}
+
 %include <stdint.i>
 
 %{
diff --git a/scripts/dtc/pylibfdt/setup.py b/scripts/dtc/pylibfdt/setup.py
index 992cdec30f..8baae08770 100755
--- a/scripts/dtc/pylibfdt/setup.py
+++ b/scripts/dtc/pylibfdt/setup.py
@@ -1,11 +1,13 @@
 #!/usr/bin/env python3
+# SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
 
 """
 setup.py file for SWIG libfdt
 Copyright (C) 2017 Google, Inc.
 Written by Simon Glass <sjg@chromium.org>
 
-SPDX-License-Identifier:	GPL-2.0+ BSD-2-Clause
+This script is modified from the upstream version, to fit in with the U-Boot
+build system.
 
 Files to be built into the extension are provided in SOURCES
 C flags to use are provided in CPPFLAGS
@@ -18,14 +20,34 @@ allows this script to be run stand-alone, e.g.:
     ./pylibfdt/setup.py install [--prefix=...]
 """
 
-from distutils.core import setup, Extension
+from setuptools import setup, Extension
+from setuptools.command.build_py import build_py as _build_py
 import os
 import re
 import sys
 
+try:
+    from setuptools import sic
+except ImportError:
+    pass
+
+srcdir = os.path.dirname(__file__)
+
+with open(os.path.join(srcdir, "../README"), "r") as fh:
+    long_description = fh.read()
+
 # Decodes a Makefile assignment line into key and value (and plus for +=)
 RE_KEY_VALUE = re.compile('(?P<key>\w+) *(?P<plus>[+])?= *(?P<value>.*)$')
 
+def get_top_builddir():
+    if '--top-builddir' in sys.argv:
+        index = sys.argv.index('--top-builddir')
+        sys.argv.pop(index)
+        return sys.argv.pop(index)
+    else:
+        return os.path.join(srcdir, '..')
+
+top_builddir = get_top_builddir()
 
 def ParseMakefile(fname):
     """Parse a Makefile to obtain its variables.
@@ -86,7 +108,7 @@ def GetEnvFromMakefiles():
     makevars = ParseMakefile(os.path.join(basedir, 'libfdt', 'Makefile.libfdt'))
     files = makevars['LIBFDT_SRCS'].split()
     files = [os.path.join(basedir, 'libfdt', fname) for fname in files]
-    files.append('pylibfdt/libfdt.i')
+    files.append('libfdt.i')
     cflags = ['-I%s' % basedir, '-I%s/libfdt' % basedir]
     objdir = ''
     return swig_opts, version, files, cflags, objdir
@@ -96,7 +118,10 @@ progname = sys.argv[0]
 files = os.environ.get('SOURCES', '').split()
 cflags = os.environ.get('CPPFLAGS', '').split()
 objdir = os.environ.get('OBJDIR')
-version = os.environ.get('VERSION')
+try:
+    version = sic(os.environ.get('VERSION'))
+except:
+    version = os.environ.get('VERSION')
 swig_opts = os.environ.get('SWIG_OPTS', '').split()
 
 # If we were called directly rather than through our Makefile (which is often
@@ -107,17 +132,39 @@ if not all((swig_opts, version, files, cflags, objdir)):
 
 libfdt_module = Extension(
     '_libfdt',
-    sources = files,
-    extra_compile_args = cflags,
-    swig_opts = swig_opts,
+    sources=files,
+    include_dirs=[os.path.join(srcdir, 'libfdt')],
+    library_dirs=[os.path.join(top_builddir, 'libfdt')],
+    swig_opts=swig_opts,
 )
 
+class build_py(_build_py):
+    def run(self):
+        self.run_command("build_ext")
+        return super().run()
+
 setup(
     name='libfdt',
-    version= version,
-    author='Simon Glass <sjg@chromium.org>',
+    version=version,
+    cmdclass = {'build_py' : build_py},
+    author='Simon Glass',
+    author_email='sjg@chromium.org',
     description='Python binding for libfdt',
     ext_modules=[libfdt_module],
     package_dir={'': objdir},
-    py_modules=['pylibfdt/libfdt'],
+    py_modules=['libfdt'],
+
+    long_description=long_description,
+    long_description_content_type="text/plain",
+    url="https://git.kernel.org/pub/scm/utils/dtc/dtc.git",
+    license="BSD",
+    license_files=["GPL", "BSD-2-Clause"],
+
+    classifiers=[
+        "Programming Language :: Python :: 3",
+        "License :: OSI Approved :: BSD License",
+        "License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)",
+        "Operating System :: OS Independent",
+    ],
+
 )
diff --git a/test/dm/Makefile b/test/dm/Makefile
index 7543df8823..40c2287b56 100644
--- a/test/dm/Makefile
+++ b/test/dm/Makefile
@@ -47,6 +47,7 @@ ifneq ($(CONFIG_EFI_PARTITION),)
 obj-$(CONFIG_FASTBOOT_FLASH_MMC) += fastboot.o
 endif
 obj-$(CONFIG_FIRMWARE) += firmware.o
+obj-$(CONFIG_FWU_MDATA_GPT_BLK) += fwu_mdata.o
 obj-$(CONFIG_DM_HWSPINLOCK) += hwspinlock.o
 obj-$(CONFIG_DM_I2C) += i2c.o
 obj-$(CONFIG_SOUND) += i2s.o
diff --git a/test/dm/clk_ccf.c b/test/dm/clk_ccf.c
index e4ebb93cda..41d1c2190c 100644
--- a/test/dm/clk_ccf.c
+++ b/test/dm/clk_ccf.c
@@ -31,13 +31,13 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_assertok(uclass_get_device_by_name(UCLASS_CLK, "clk-ccf", &dev));
 
 	/* Test for clk_get_by_id() */
-	ret = clk_get_by_id(SANDBOX_CLK_ECSPI_ROOT, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_ECSPI_ROOT), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("ecspi_root", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_PARENT, clk->flags);
 
 	/* Test for clk_get_parent_rate() */
-	ret = clk_get_by_id(SANDBOX_CLK_ECSPI1, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_ECSPI1), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("ecspi1", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_PARENT, clk->flags);
@@ -46,7 +46,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(rate, 20000000);
 
 	/* test the gate of CCF */
-	ret = clk_get_by_id(SANDBOX_CLK_ECSPI0, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_ECSPI0), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("ecspi0", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_PARENT, clk->flags);
@@ -55,7 +55,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(rate, 20000000);
 
 	/* Test the mux of CCF */
-	ret = clk_get_by_id(SANDBOX_CLK_USDHC1_SEL, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_USDHC1_SEL), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("usdhc1_sel", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_NO_REPARENT, clk->flags);
@@ -66,7 +66,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	rate = clk_get_rate(clk);
 	ut_asserteq(rate, 60000000);
 
-	ret = clk_get_by_id(SANDBOX_CLK_PLL3_80M, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_PLL3_80M), &pclk);
 	ut_assertok(ret);
 
 	ret = clk_set_parent(clk, pclk);
@@ -75,7 +75,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	rate = clk_get_rate(clk);
 	ut_asserteq(rate, 80000000);
 
-	ret = clk_get_by_id(SANDBOX_CLK_USDHC2_SEL, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_USDHC2_SEL), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("usdhc2_sel", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_NO_REPARENT, clk->flags);
@@ -90,7 +90,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	rate = clk_get_rate(clk);
 	ut_asserteq(rate, 80000000);
 
-	ret = clk_get_by_id(SANDBOX_CLK_PLL3_60M, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_PLL3_60M), &pclk);
 	ut_assertok(ret);
 
 	ret = clk_set_parent(clk, pclk);
@@ -100,7 +100,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(rate, 60000000);
 
 	/* Test the composite of CCF */
-	ret = clk_get_by_id(SANDBOX_CLK_I2C, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("i2c", clk->dev->name);
 	ut_asserteq(CLK_SET_RATE_UNGATE, clk->flags);
@@ -110,7 +110,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 
 #if CONFIG_IS_ENABLED(CLK_CCF)
 	/* Test clk tree enable/disable */
-	ret = clk_get_by_id(SANDBOX_CLK_I2C_ROOT, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C_ROOT), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("i2c_root", clk->dev->name);
 
@@ -120,7 +120,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ret = sandbox_clk_enable_count(clk);
 	ut_asserteq(ret, 1);
 
-	ret = clk_get_by_id(SANDBOX_CLK_I2C, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C), &pclk);
 	ut_assertok(ret);
 
 	ret = sandbox_clk_enable_count(pclk);
@@ -136,7 +136,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq(ret, 0);
 
 	/* Test clock re-parenting. */
-	ret = clk_get_by_id(SANDBOX_CLK_USDHC1_SEL, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_USDHC1_SEL), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("usdhc1_sel", clk->dev->name);
 
@@ -150,7 +150,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 		clkid = SANDBOX_CLK_PLL3_60M;
 	}
 
-	ret = clk_get_by_id(clkid, &pclk);
+	ret = clk_get_by_id(CLK_ID(dev, clkid), &pclk);
 	ut_assertok(ret);
 	ret = clk_set_parent(clk, pclk);
 	ut_assertok(ret);
@@ -159,7 +159,7 @@ static int dm_test_clk_ccf(struct unit_test_state *uts)
 	ut_asserteq_str(clkname, pclk->dev->name);
 
 	/* Test disabling critical clock. */
-	ret = clk_get_by_id(SANDBOX_CLK_I2C_ROOT, &clk);
+	ret = clk_get_by_id(CLK_ID(dev, SANDBOX_CLK_I2C_ROOT), &clk);
 	ut_assertok(ret);
 	ut_asserteq_str("i2c_root", clk->dev->name);
 
diff --git a/test/dm/fwu_mdata.c b/test/dm/fwu_mdata.c
new file mode 100644
index 0000000000..621ba647d9
--- /dev/null
+++ b/test/dm/fwu_mdata.c
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2022, Linaro Limited
+ * Copyright (c) 2022, Heinrich Schuchardt <xypron.glpk@gmx.de>
+ */
+
+#include <blk.h>
+#include <common.h>
+#include <dm.h>
+#include <fwu.h>
+#include <fwu_mdata.h>
+#include <log.h>
+#include <malloc.h>
+#include <memalign.h>
+#include <part.h>
+
+#include <dm/test.h>
+#include <test/ut.h>
+
+#include "fwu_mdata_disk_image.h"
+
+/* Block size of compressed disk image */
+#define COMPRESSED_DISK_IMAGE_BLOCK_SIZE 8
+
+static struct udevice *mmc_dev;
+static struct blk_desc *dev_desc;
+
+/* One 8 byte block of the compressed disk image */
+struct line {
+	size_t addr;
+	char *line;
+};
+
+/* Compressed disk image */
+struct compressed_disk_image {
+	size_t length;
+	struct line lines[];
+};
+
+static const struct compressed_disk_image img = FWU_MDATA_DISK_IMG;
+
+/* Decompressed disk image */
+static u8 *image;
+
+static int setup_blk_device(struct unit_test_state *uts)
+{
+	ut_assertok(uclass_get_device(UCLASS_MMC, 0, &mmc_dev));
+	ut_assertok(blk_get_device_by_str("mmc", "0", &dev_desc));
+
+	return 0;
+}
+
+static int populate_mmc_disk_image(struct unit_test_state *uts)
+{
+	u8 *buf;
+	size_t i;
+	size_t addr;
+	size_t len;
+
+	buf = malloc(img.length);
+	if (!buf)
+		return -ENOMEM;
+
+	memset(buf, 0, img.length);
+
+	for (i = 0; ; i++) {
+		if (!img.lines[i].line)
+			break;
+		addr = img.lines[i].addr;
+		len = COMPRESSED_DISK_IMAGE_BLOCK_SIZE;
+		if (addr + len > img.length)
+			len = img.length - addr;
+		memcpy(buf + addr, img.lines[i].line, len);
+	}
+	image = buf;
+
+	return 0;
+}
+
+static int write_mmc_blk_device(struct unit_test_state *uts)
+{
+	lbaint_t blkcnt;
+
+	blkcnt = BLOCK_CNT(img.length, dev_desc);
+
+	ut_asserteq(blkcnt, blk_dwrite(dev_desc, 0, blkcnt, image));
+
+	return 0;
+}
+
+static int dm_test_fwu_mdata_read(struct unit_test_state *uts)
+{
+	struct udevice *dev;
+	struct fwu_mdata mdata = { 0 };
+
+	ut_assertok(setup_blk_device(uts));
+	ut_assertok(populate_mmc_disk_image(uts));
+	ut_assertok(write_mmc_blk_device(uts));
+
+	/*
+	 * Trigger lib/fwu_updates/fwu.c fwu_boottime_checks()
+	 * to populate g_dev global pointer in that library.
+	 */
+	event_notify_null(EVT_MAIN_LOOP);
+
+	ut_assertok(uclass_first_device_err(UCLASS_FWU_MDATA, &dev));
+	ut_assertok(fwu_init());
+
+	ut_assertok(fwu_get_mdata(&mdata));
+
+	ut_asserteq(mdata.version, 0x1);
+
+	return 0;
+}
+DM_TEST(dm_test_fwu_mdata_read, UT_TESTF_SCAN_FDT);
+
+static int dm_test_fwu_mdata_write(struct unit_test_state *uts)
+{
+	u32 active_idx;
+	struct udevice *dev;
+	struct fwu_mdata mdata = { 0 };
+
+	ut_assertok(setup_blk_device(uts));
+	ut_assertok(populate_mmc_disk_image(uts));
+	ut_assertok(write_mmc_blk_device(uts));
+
+	/*
+	 * Trigger lib/fwu_updates/fwu.c fwu_boottime_checks()
+	 * to populate g_dev global pointer in that library.
+	 */
+	event_notify_null(EVT_MAIN_LOOP);
+
+
+	ut_assertok(uclass_first_device_err(UCLASS_FWU_MDATA, &dev));
+
+	ut_assertok(fwu_init());
+	ut_assertok(fwu_get_mdata(&mdata));
+
+	active_idx = (mdata.active_index + 1) % CONFIG_FWU_NUM_BANKS;
+	ut_assertok(fwu_set_active_index(active_idx));
+
+	ut_assertok(fwu_get_mdata(&mdata));
+	ut_asserteq(mdata.active_index, active_idx);
+
+	return 0;
+}
+DM_TEST(dm_test_fwu_mdata_write, UT_TESTF_SCAN_FDT);
diff --git a/test/dm/fwu_mdata_disk_image.h b/test/dm/fwu_mdata_disk_image.h
new file mode 100644
index 0000000000..b9803417c8
--- /dev/null
+++ b/test/dm/fwu_mdata_disk_image.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ *  Non-zero 8 byte strings of a disk image
+ *
+ *  Generated with tools/file2include
+ */
+
+#define FWU_MDATA_DISK_IMG { 0x00010000, { \
+	{0x000001c0, "\x02\x00\xee\x02\x02\x00\x01\x00"}, /* ........ */ \
+	{0x000001c8, "\x00\x00\x7f\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x000001f8, "\x00\x00\x00\x00\x00\x00\x55\xaa"}, /* ......U. */ \
+	{0x00000200, "\x45\x46\x49\x20\x50\x41\x52\x54"}, /* EFI PART */ \
+	{0x00000208, "\x00\x00\x01\x00\x5c\x00\x00\x00"}, /* ....\... */ \
+	{0x00000210, "\xa6\xf6\x92\x20\x00\x00\x00\x00"}, /* ... .... */ \
+	{0x00000218, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00000220, "\x7f\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00000228, "\x22\x00\x00\x00\x00\x00\x00\x00"}, /* "....... */ \
+	{0x00000230, "\x5e\x00\x00\x00\x00\x00\x00\x00"}, /* ^....... */ \
+	{0x00000238, "\xde\x99\xa2\x7e\x46\x34\xeb\x47"}, /* ...~F4.G */ \
+	{0x00000240, "\x87\xf6\x4f\x75\xe8\xd5\x7d\xc7"}, /* ..Ou..}. */ \
+	{0x00000248, "\x02\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00000250, "\x80\x00\x00\x00\x80\x00\x00\x00"}, /* ........ */ \
+	{0x00000258, "\x2a\x64\x03\x83\x00\x00\x00\x00"}, /* .d...... */ \
+	{0x00000400, "\xa0\x84\x7a\x8a\x87\x83\xf6\x40"}, /* ..z....@ */ \
+	{0x00000408, "\xab\x41\xa8\xb9\xa5\xa6\x0d\x23"}, /* .A.....# */ \
+	{0x00000410, "\x3d\x6c\xb9\xaa\x20\xb2\x18\x4c"}, /* =l.. ..L */ \
+	{0x00000418, "\xbc\x87\x1c\x9f\xe0\x35\x9b\x73"}, /* .....5.s */ \
+	{0x00000420, "\x22\x00\x00\x00\x00\x00\x00\x00"}, /* "....... */ \
+	{0x00000428, "\x31\x00\x00\x00\x00\x00\x00\x00"}, /* 1....... */ \
+	{0x00000438, "\x55\x00\x6e\x00\x6b\x00\x6e\x00"}, /* U.n.k.n. */ \
+	{0x00000440, "\x6f\x00\x77\x00\x6e\x00\x00\x00"}, /* o.w.n... */ \
+	{0x00000480, "\xa0\x84\x7a\x8a\x87\x83\xf6\x40"}, /* ..z....@ */ \
+	{0x00000488, "\xab\x41\xa8\xb9\xa5\xa6\x0d\x23"}, /* .A.....# */ \
+	{0x00000490, "\x57\x24\xf6\xe6\x0b\x6f\x66\x4e"}, /* W$...ofN */ \
+	{0x00000498, "\xb3\xd5\x99\x50\xa5\xc6\x4e\xc1"}, /* ...P..N. */ \
+	{0x000004a0, "\x32\x00\x00\x00\x00\x00\x00\x00"}, /* 2....... */ \
+	{0x000004a8, "\x41\x00\x00\x00\x00\x00\x00\x00"}, /* A....... */ \
+	{0x000004b8, "\x55\x00\x6e\x00\x6b\x00\x6e\x00"}, /* U.n.k.n. */ \
+	{0x000004c0, "\x6f\x00\x77\x00\x6e\x00\x00\x00"}, /* o.w.n... */ \
+	{0x00004400, "\x4e\xd5\x3f\x43\x01\x00\x00\x00"}, /* N.?C.... */ \
+	{0x00004408, "\x00\x00\x00\x00\x01\x00\x00\x00"}, /* ........ */ \
+	{0x00004410, "\x52\xcf\xd7\x09\x20\x07\x10\x47"}, /* R... ..G */ \
+	{0x00004418, "\x91\xd1\x08\x46\x9b\x7f\xe9\xc8"}, /* ...F.... */ \
+	{0x00004420, "\xeb\x2b\x27\x49\xd8\x8d\xdf\x46"}, /* .+'I...F */ \
+	{0x00004428, "\x8d\x75\x35\x6c\x65\xef\xf4\x17"}, /* .u5le... */ \
+	{0x00004430, "\x86\x7a\x05\x10\xf1\xda\x93\x4f"}, /* .z.....O */ \
+	{0x00004438, "\xba\x7f\xb1\x95\xf7\xfa\x41\x70"}, /* ......Ap */ \
+	{0x00004440, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00004448, "\x3e\xed\x62\xdb\x37\x62\xb4\x4f"}, /* >.b.7b.O */ \
+	{0x00004450, "\x80\xc4\x1b\x74\xd8\x46\xa8\xe7"}, /* ...t.F.. */ \
+	{0x00004458, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00004460, "\xf5\x21\x70\x5a\xf2\xfe\xb4\x48"}, /* .!pZ...H */ \
+	{0x00004468, "\xaa\xba\x83\x2e\x77\x74\x18\xc0"}, /* ....wt.. */ \
+	{0x00004470, "\xeb\x2b\x27\x49\xd8\x8d\xdf\x46"}, /* .+'I...F */ \
+	{0x00004478, "\x8d\x75\x35\x6c\x65\xef\xf4\x17"}, /* .u5le... */ \
+	{0x00004480, "\x3b\x0e\xd2\x0b\x9f\xab\x86\x49"}, /* ;......I */ \
+	{0x00004488, "\xb7\x90\x8d\xf3\x9c\x9c\xa3\x82"}, /* ........ */ \
+	{0x00004490, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00004498, "\x6d\xe4\x25\x0e\x15\xb6\xd3\x4c"}, /* m.%....L */ \
+	{0x000044a0, "\x94\xda\x51\x79\x8f\xb1\x9e\xb1"}, /* ..Qy.... */ \
+	{0x000044a8, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00006400, "\x4e\xd5\x3f\x43\x01\x00\x00\x00"}, /* N.?C.... */ \
+	{0x00006408, "\x00\x00\x00\x00\x01\x00\x00\x00"}, /* ........ */ \
+	{0x00006410, "\x52\xcf\xd7\x09\x20\x07\x10\x47"}, /* R... ..G */ \
+	{0x00006418, "\x91\xd1\x08\x46\x9b\x7f\xe9\xc8"}, /* ...F.... */ \
+	{0x00006420, "\xeb\x2b\x27\x49\xd8\x8d\xdf\x46"}, /* .+'I...F */ \
+	{0x00006428, "\x8d\x75\x35\x6c\x65\xef\xf4\x17"}, /* .u5le... */ \
+	{0x00006430, "\x86\x7a\x05\x10\xf1\xda\x93\x4f"}, /* .z.....O */ \
+	{0x00006438, "\xba\x7f\xb1\x95\xf7\xfa\x41\x70"}, /* ......Ap */ \
+	{0x00006440, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00006448, "\x3e\xed\x62\xdb\x37\x62\xb4\x4f"}, /* >.b.7b.O */ \
+	{0x00006450, "\x80\xc4\x1b\x74\xd8\x46\xa8\xe7"}, /* ...t.F.. */ \
+	{0x00006458, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00006460, "\xf5\x21\x70\x5a\xf2\xfe\xb4\x48"}, /* .!pZ...H */ \
+	{0x00006468, "\xaa\xba\x83\x2e\x77\x74\x18\xc0"}, /* ....wt.. */ \
+	{0x00006470, "\xeb\x2b\x27\x49\xd8\x8d\xdf\x46"}, /* .+'I...F */ \
+	{0x00006478, "\x8d\x75\x35\x6c\x65\xef\xf4\x17"}, /* .u5le... */ \
+	{0x00006480, "\x3b\x0e\xd2\x0b\x9f\xab\x86\x49"}, /* ;......I */ \
+	{0x00006488, "\xb7\x90\x8d\xf3\x9c\x9c\xa3\x82"}, /* ........ */ \
+	{0x00006490, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x00006498, "\x6d\xe4\x25\x0e\x15\xb6\xd3\x4c"}, /* m.%....L */ \
+	{0x000064a0, "\x94\xda\x51\x79\x8f\xb1\x9e\xb1"}, /* ..Qy.... */ \
+	{0x000064a8, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x0000be00, "\xa0\x84\x7a\x8a\x87\x83\xf6\x40"}, /* ..z....@ */ \
+	{0x0000be08, "\xab\x41\xa8\xb9\xa5\xa6\x0d\x23"}, /* .A.....# */ \
+	{0x0000be10, "\x3d\x6c\xb9\xaa\x20\xb2\x18\x4c"}, /* =l.. ..L */ \
+	{0x0000be18, "\xbc\x87\x1c\x9f\xe0\x35\x9b\x73"}, /* .....5.s */ \
+	{0x0000be20, "\x22\x00\x00\x00\x00\x00\x00\x00"}, /* "....... */ \
+	{0x0000be28, "\x31\x00\x00\x00\x00\x00\x00\x00"}, /* 1....... */ \
+	{0x0000be38, "\x55\x00\x6e\x00\x6b\x00\x6e\x00"}, /* U.n.k.n. */ \
+	{0x0000be40, "\x6f\x00\x77\x00\x6e\x00\x00\x00"}, /* o.w.n... */ \
+	{0x0000be80, "\xa0\x84\x7a\x8a\x87\x83\xf6\x40"}, /* ..z....@ */ \
+	{0x0000be88, "\xab\x41\xa8\xb9\xa5\xa6\x0d\x23"}, /* .A.....# */ \
+	{0x0000be90, "\x57\x24\xf6\xe6\x0b\x6f\x66\x4e"}, /* W$...ofN */ \
+	{0x0000be98, "\xb3\xd5\x99\x50\xa5\xc6\x4e\xc1"}, /* ...P..N. */ \
+	{0x0000bea0, "\x32\x00\x00\x00\x00\x00\x00\x00"}, /* 2....... */ \
+	{0x0000bea8, "\x41\x00\x00\x00\x00\x00\x00\x00"}, /* A....... */ \
+	{0x0000beb8, "\x55\x00\x6e\x00\x6b\x00\x6e\x00"}, /* U.n.k.n. */ \
+	{0x0000bec0, "\x6f\x00\x77\x00\x6e\x00\x00\x00"}, /* o.w.n... */ \
+	{0x0000fe00, "\x45\x46\x49\x20\x50\x41\x52\x54"}, /* EFI PART */ \
+	{0x0000fe08, "\x00\x00\x01\x00\x5c\x00\x00\x00"}, /* ....\... */ \
+	{0x0000fe10, "\xa2\xce\x23\xfc\x00\x00\x00\x00"}, /* ..#..... */ \
+	{0x0000fe18, "\x7f\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x0000fe20, "\x01\x00\x00\x00\x00\x00\x00\x00"}, /* ........ */ \
+	{0x0000fe28, "\x22\x00\x00\x00\x00\x00\x00\x00"}, /* "....... */ \
+	{0x0000fe30, "\x5e\x00\x00\x00\x00\x00\x00\x00"}, /* ^....... */ \
+	{0x0000fe38, "\xde\x99\xa2\x7e\x46\x34\xeb\x47"}, /* ...~F4.G */ \
+	{0x0000fe40, "\x87\xf6\x4f\x75\xe8\xd5\x7d\xc7"}, /* ..Ou..}. */ \
+	{0x0000fe48, "\x5f\x00\x00\x00\x00\x00\x00\x00"}, /* _....... */ \
+	{0x0000fe50, "\x80\x00\x00\x00\x80\x00\x00\x00"}, /* ........ */ \
+	{0x0000fe58, "\x2a\x64\x03\x83\x00\x00\x00\x00"}, /* .d...... */ \
+	{0, NULL} } }
diff --git a/test/dm/gpio.c b/test/dm/gpio.c
index 33ae98701f..22a77b959c 100644
--- a/test/dm/gpio.c
+++ b/test/dm/gpio.c
@@ -113,6 +113,11 @@ static int dm_test_gpio(struct unit_test_state *uts)
 	ut_asserteq_str("a", name);
 	ut_asserteq(20, offset_count);
 
+	/* Flag a pin as protected, and check its status */
+	ut_assertok(gpio_lookup_name("a1", &dev, &offset, &gpio));
+	sandbox_gpio_set_flags(dev, 1, GPIOD_EXT_PROTECTED);
+	ut_asserteq(GPIOF_PROTECTED, gpio_get_raw_function(dev, 1, NULL));
+
 	/* add gpio hog tests */
 	ut_assertok(gpio_hog_lookup_name("hog_input_active_low", &desc));
 	ut_asserteq(GPIOD_IS_IN | GPIOD_ACTIVE_LOW, desc->flags);
@@ -778,3 +783,33 @@ static int dm_test_gpio_get_values_as_int_base3(struct unit_test_state *uts)
 }
 DM_TEST(dm_test_gpio_get_values_as_int_base3,
 	UT_TESTF_SCAN_PDATA | UT_TESTF_SCAN_FDT);
+
+/* Check that gpio_get_status return the label of a GPIO configured as GPIOD_AF */
+static int dm_test_gpio_function(struct unit_test_state *uts)
+{
+	struct gpio_desc desc;
+	struct udevice *dev;
+	ulong flags;
+	unsigned int offset, gpio;
+	char buf[80];
+
+	ut_assertok(uclass_get_device(UCLASS_TEST_FDT, 0, &dev));
+	ut_asserteq_str("a-test", dev->name);
+
+	/* request gpio_b 5 */
+	ut_assertok(gpio_request_by_name(dev, "test-gpios", 2, &desc, 0));
+	/* update gpio_b 5 function to GPIO_AF */
+	ut_assertok(dm_gpio_clrset_flags(&desc, GPIOD_IS_AF, GPIOD_IS_AF));
+	ut_assertok(dm_gpio_get_flags(&desc, &flags));
+	ut_asserteq(GPIOD_IS_AF, flags);
+	/* check using gpio_get_status that label is displayed for a pin with GPIO_AF function */
+	ut_assertok(gpio_lookup_name("b5", &dev, &offset, &gpio));
+	ut_assertok(gpio_get_status(dev, offset, buf, sizeof(buf)));
+	ut_asserteq_str("b5: func a-test.test-gpios2", buf);
+
+	ut_assertok(dm_gpio_free(dev, &desc));
+
+	return 0;
+}
+DM_TEST(dm_test_gpio_function,
+	UT_TESTF_SCAN_PDATA | UT_TESTF_SCAN_FDT);
diff --git a/test/dm/reset.c b/test/dm/reset.c
index 9c00452336..8ea7225b75 100644
--- a/test/dm/reset.c
+++ b/test/dm/reset.c
@@ -145,7 +145,29 @@ static int dm_test_reset_bulk(struct unit_test_state *uts)
 	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
 	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
 
+	/* reset release don't change the reset level */
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
+	ut_assertok(sandbox_reset_test_release_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(sandbox_reset_test_get_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(0, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	ut_assertok(sandbox_reset_test_assert_bulk(dev_test));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, TEST_RESET_ID));
+	ut_asserteq(1, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
+
+	/* reset release don't change the reset level */
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(1, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
 	ut_assertok(sandbox_reset_test_release_bulk(dev_test));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, OTHER_RESET_ID));
+	ut_asserteq(0, sandbox_reset_is_requested(dev_reset, TEST_RESET_ID));
 	ut_asserteq(1, sandbox_reset_query(dev_reset, TEST_RESET_ID));
 	ut_asserteq(1, sandbox_reset_query(dev_reset, OTHER_RESET_ID));
 
diff --git a/test/py/tests/test_efi_capsule/capsule_common.py b/test/py/tests/test_efi_capsule/capsule_common.py
new file mode 100644
index 0000000000..9eef6767a6
--- /dev/null
+++ b/test/py/tests/test_efi_capsule/capsule_common.py
@@ -0,0 +1,142 @@
+# SPDX-License-Identifier:      GPL-2.0+
+# Copyright (c) 2023, Linaro Limited
+
+
+"""Common function for UEFI capsule test."""
+
+from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
+
+def setup(u_boot_console, disk_img, osindications):
+    """setup the test
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        disk_img -- A path to disk image to be used for testing.
+        osindications -- String of osindications value.
+    """
+    u_boot_console.run_command_list([
+        f'host bind 0 {disk_img}',
+        'printenv -e PlatformLangCodes', # workaround for terminal size determination
+        'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
+        'efidebug boot order 1',
+        'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;'
+        'u-boot-env raw 0x150000 0x200000"'])
+
+    if osindications is None:
+        u_boot_console.run_command('env set -e OsIndications')
+    else:
+        u_boot_console.run_command(f'env set -e -nv -bs -rt OsIndications ={osindications}')
+
+    u_boot_console.run_command('env save')
+
+def init_content(u_boot_console, target, filename, expected):
+    """initialize test content
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        target -- Target address to place the content.
+        filename -- File name of the content.
+        expected -- Expected string of the content.
+    """
+    output = u_boot_console.run_command_list([
+        'sf probe 0:0',
+        f'fatload host 0:1 4000000 {CAPSULE_DATA_DIR}/{filename}',
+        f'sf write 4000000 {target} 10',
+        'sf read 5000000 100000 10',
+        'md.b 5000000 10'])
+    assert expected in ''.join(output)
+
+def place_capsule_file(u_boot_console, filenames):
+    """place the capsule file
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        filenames -- File name array of the target capsule files.
+    """
+    for name in filenames:
+        u_boot_console.run_command_list([
+            f'fatload host 0:1 4000000 {CAPSULE_DATA_DIR}/{name}',
+            f'fatwrite host 0:1 4000000 {CAPSULE_INSTALL_DIR}/{name} $filesize'])
+
+    output = u_boot_console.run_command(f'fatls host 0:1 {CAPSULE_INSTALL_DIR}')
+    for name in filenames:
+        assert name in ''.join(output)
+
+def exec_manual_update(u_boot_console, disk_img, filenames, need_reboot = True):
+    """execute capsule update manually
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        disk_img -- A path to disk image to be used for testing.
+        filenames -- File name array of the target capsule files.
+        need_reboot -- Flag indicates whether system reboot is required.
+    """
+    # make sure that dfu_alt_info exists even persistent variables
+    # are not available.
+    output = u_boot_console.run_command_list([
+        'env set dfu_alt_info '
+                '"sf 0:0=u-boot-bin raw 0x100000 0x50000;'
+                'u-boot-env raw 0x150000 0x200000"',
+        f'host bind 0 {disk_img}',
+        f'fatls host 0:1 {CAPSULE_INSTALL_DIR}'])
+    for name in filenames:
+        assert name in ''.join(output)
+
+    # need to run uefi command to initiate capsule handling
+    u_boot_console.run_command(
+        'env print -e Capsule0000', wait_for_reboot = need_reboot)
+
+def check_file_removed(u_boot_console, disk_img, filenames):
+    """check files are removed
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        disk_img -- A path to disk image to be used for testing.
+        filenames -- File name array of the target capsule files.
+    """
+    output = u_boot_console.run_command_list([
+        f'host bind 0 {disk_img}',
+        f'fatls host 0:1 {CAPSULE_INSTALL_DIR}'])
+    for name in filenames:
+        assert name not in ''.join(output)
+
+def check_file_exist(u_boot_console, disk_img, filenames):
+    """check files exist
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        disk_img -- A path to disk image to be used for testing.
+        filenames -- File name array of the target capsule files.
+    """
+    output = u_boot_console.run_command_list([
+        f'host bind 0 {disk_img}',
+        f'fatls host 0:1 {CAPSULE_INSTALL_DIR}'])
+    for name in filenames:
+        assert name in ''.join(output)
+
+def verify_content(u_boot_console, target, expected):
+    """verify the content
+
+    Args:
+        u_boot_console -- A console connection to U-Boot.
+        target -- Target address to verify.
+        expected -- Expected string of the content.
+    """
+    output = u_boot_console.run_command_list([
+        'sf probe 0:0',
+        f'sf read 4000000 {target} 10',
+        'md.b 4000000 10'])
+    assert expected in ''.join(output)
+
+def do_reboot_dtb_specified(u_boot_config, u_boot_console, dtb_filename):
+    """do reboot with specified DTB
+
+    Args:
+        u_boot_config -- U-boot configuration.
+        u_boot_console -- A console connection to U-Boot.
+        dtb_filename -- DTB file name.
+    """
+    mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
+    u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
+                                + f'/{dtb_filename}'
+    u_boot_console.restart_uboot()
diff --git a/test/py/tests/test_efi_capsule/conftest.py b/test/py/tests/test_efi_capsule/conftest.py
index 4879f2b5c2..1b6c4a9115 100644
--- a/test/py/tests/test_efi_capsule/conftest.py
+++ b/test/py/tests/test_efi_capsule/conftest.py
@@ -2,30 +2,21 @@
 # Copyright (c) 2020, Linaro Limited
 # Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
 
-import os
-import os.path
-import re
-from subprocess import call, check_call, check_output, CalledProcessError
-import pytest
-from capsule_defs import *
+"""Fixture for UEFI capsule test
+"""
 
-#
-# Fixture for UEFI capsule test
-#
+from subprocess import call, check_call, CalledProcessError
+import pytest
+from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR, EFITOOLS_PATH
 
 @pytest.fixture(scope='session')
 def efi_capsule_data(request, u_boot_config):
-    """Set up a file system to be used in UEFI capsule and
-       authentication test.
-
-    Args:
-        request: Pytest request object.
-        u_boot_config: U-boot configuration.
+    """Set up a file system to be used in UEFI capsule and authentication test
+    and return a ath to disk image to be used for testing
 
-    Return:
-        A path to disk image to be used for testing
+    request -- Pytest request object.
+    u_boot_config -- U-boot configuration.
     """
-    global CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
 
     mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
     data_dir = mnt_point + CAPSULE_DATA_DIR
@@ -70,6 +61,23 @@ def efi_capsule_data(request, u_boot_config):
                             '-out SIGNER2.crt -nodes -days 365'
                        % data_dir, shell=True)
 
+        # Update dtb to add the version information
+        check_call('cd %s; '
+                   'cp %s/test/py/tests/test_efi_capsule/version.dts .'
+                   % (data_dir, u_boot_config.source_dir), shell=True)
+        if capsule_auth_enabled:
+            check_call('cd %s; '
+                       'dtc -@ -I dts -O dtb -o version.dtbo version.dts; '
+                       'fdtoverlay -i test_sig.dtb '
+                            '-o test_ver.dtb version.dtbo'
+                       % (data_dir), shell=True)
+        else:
+            check_call('cd %s; '
+                       'dtc -@ -I dts -O dtb -o version.dtbo version.dts; '
+                       'fdtoverlay -i %s/arch/sandbox/dts/test.dtb '
+                            '-o test_ver.dtb version.dtbo'
+                       % (data_dir, u_boot_config.build_dir), shell=True)
+
         # Create capsule files
         # two regions: one for u-boot.bin and the other for u-boot.env
         check_call('cd %s; echo -n u-boot:Old > u-boot.bin.old; echo -n u-boot:New > u-boot.bin.new; echo -n u-boot-env:Old > u-boot.env.old; echo -n u-boot-env:New > u-boot.env.new' % data_dir,
@@ -95,6 +103,26 @@ def efi_capsule_data(request, u_boot_config):
         check_call('cd %s; %s/tools/mkeficapsule --index 1 --guid  058B7D83-50D5-4C47-A195-60D86AD341C4 uboot_bin_env.itb Test05' %
                    (data_dir, u_boot_config.build_dir),
                    shell=True)
+        check_call('cd %s; %s/tools/mkeficapsule --index 1 --fw-version 5 '
+                        '--guid 09D7CF52-0720-4710-91D1-08469B7FE9C8 u-boot.bin.new Test101' %
+                   (data_dir, u_boot_config.build_dir),
+                   shell=True)
+        check_call('cd %s; %s/tools/mkeficapsule --index 2 --fw-version 10 '
+                        '--guid 5A7021F5-FEF2-48B4-AABA-832E777418C0 u-boot.env.new Test102' %
+                   (data_dir, u_boot_config.build_dir),
+                   shell=True)
+        check_call('cd %s; %s/tools/mkeficapsule --index 1 --fw-version 2 '
+                        '--guid 09D7CF52-0720-4710-91D1-08469B7FE9C8 u-boot.bin.new Test103' %
+                   (data_dir, u_boot_config.build_dir),
+                   shell=True)
+        check_call('cd %s; %s/tools/mkeficapsule --index 1 --fw-version 5 '
+                        '--guid 3673B45D-6A7C-46F3-9E60-ADABB03F7937 uboot_bin_env.itb Test104' %
+                   (data_dir, u_boot_config.build_dir),
+                   shell=True)
+        check_call('cd %s; %s/tools/mkeficapsule --index 1 --fw-version 2 '
+                        '--guid 3673B45D-6A7C-46F3-9E60-ADABB03F7937 uboot_bin_env.itb Test105' %
+                   (data_dir, u_boot_config.build_dir),
+                   shell=True)
 
         if capsule_auth_enabled:
             # raw firmware signed with proper key
@@ -131,6 +159,51 @@ def efi_capsule_data(request, u_boot_config):
                             'uboot_bin_env.itb Test14'
                        % (data_dir, u_boot_config.build_dir),
                        shell=True)
+            # raw firmware signed with proper key with version information
+            check_call('cd %s; '
+                       '%s/tools/mkeficapsule --index 1 --monotonic-count 1 '
+                            '--fw-version 5 '
+                            '--private-key SIGNER.key --certificate SIGNER.crt '
+                            '--guid 09D7CF52-0720-4710-91D1-08469B7FE9C8 '
+                            'u-boot.bin.new Test111'
+                       % (data_dir, u_boot_config.build_dir),
+                       shell=True)
+            # raw firmware signed with proper key with version information
+            check_call('cd %s; '
+                       '%s/tools/mkeficapsule --index 2 --monotonic-count 1 '
+                            '--fw-version 10 '
+                            '--private-key SIGNER.key --certificate SIGNER.crt '
+                            '--guid 5A7021F5-FEF2-48B4-AABA-832E777418C0 '
+                            'u-boot.env.new Test112'
+                       % (data_dir, u_boot_config.build_dir),
+                       shell=True)
+            # raw firmware signed with proper key with lower version information
+            check_call('cd %s; '
+                       '%s/tools/mkeficapsule --index 1 --monotonic-count 1 '
+                            '--fw-version 2 '
+                            '--private-key SIGNER.key --certificate SIGNER.crt '
+                            '--guid 09D7CF52-0720-4710-91D1-08469B7FE9C8 '
+                            'u-boot.bin.new Test113'
+                       % (data_dir, u_boot_config.build_dir),
+                       shell=True)
+            # FIT firmware signed with proper key with version information
+            check_call('cd %s; '
+                       '%s/tools/mkeficapsule --index 1 --monotonic-count 1 '
+                            '--fw-version 5 '
+                            '--private-key SIGNER.key --certificate SIGNER.crt '
+                            '--guid 3673B45D-6A7C-46F3-9E60-ADABB03F7937 '
+                            'uboot_bin_env.itb Test114'
+                       % (data_dir, u_boot_config.build_dir),
+                       shell=True)
+            # FIT firmware signed with proper key with lower version information
+            check_call('cd %s; '
+                       '%s/tools/mkeficapsule --index 1 --monotonic-count 1 '
+                            '--fw-version 2 '
+                            '--private-key SIGNER.key --certificate SIGNER.crt '
+                            '--guid 3673B45D-6A7C-46F3-9E60-ADABB03F7937 '
+                            'uboot_bin_env.itb Test115'
+                       % (data_dir, u_boot_config.build_dir),
+                       shell=True)
 
         # Create a disk image with EFI system partition
         check_call('virt-make-fs --partition=gpt --size=+1M --type=vfat %s %s' %
diff --git a/test/py/tests/test_efi_capsule/test_capsule_firmware_fit.py b/test/py/tests/test_efi_capsule/test_capsule_firmware_fit.py
index 8f75b554ad..a3094c33f4 100644
--- a/test/py/tests/test_efi_capsule/test_capsule_firmware_fit.py
+++ b/test/py/tests/test_efi_capsule/test_capsule_firmware_fit.py
@@ -1,19 +1,22 @@
 # SPDX-License-Identifier:      GPL-2.0+
 # Copyright (c) 2020, Linaro Limited
 # Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
-#
-# U-Boot UEFI: Firmware Update Test
 
-"""
+"""U-Boot UEFI: Firmware Update Test
 This test verifies capsule-on-disk firmware update for FIT images
 """
 
-from subprocess import check_call, check_output, CalledProcessError
 import pytest
-from capsule_defs import *
-
+from capsule_common import (
+    setup,
+    init_content,
+    place_capsule_file,
+    exec_manual_update,
+    check_file_removed,
+    verify_content,
+    do_reboot_dtb_specified
+)
 
-@pytest.mark.boardspec('sandbox64')
 @pytest.mark.boardspec('sandbox_flattree')
 @pytest.mark.buildconfigspec('efi_capsule_firmware_fit')
 @pytest.mark.buildconfigspec('efi_capsule_on_disk')
@@ -25,15 +28,18 @@ from capsule_defs import *
 @pytest.mark.buildconfigspec('cmd_nvedit_efi')
 @pytest.mark.buildconfigspec('cmd_sf')
 @pytest.mark.slow
-class TestEfiCapsuleFirmwareFit(object):
+class TestEfiCapsuleFirmwareFit():
+    """Test capsule-on-disk firmware update for FIT images
+    """
+
     def test_efi_capsule_fw1(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 1 - Update U-Boot and U-Boot environment on SPI Flash
-                      but with an incorrect GUID value in the capsule
-                      No update should happen
-                      0x100000-0x150000: U-Boot binary (but dummy)
-                      0x150000-0x200000: U-Boot environment (but dummy)
+        """Test Case 1
+        Update U-Boot and U-Boot environment on SPI Flash
+        but with an incorrect GUID value in the capsule
+        No update should happen
+        0x100000-0x150000: U-Boot binary (but dummy)
+        0x150000-0x200000: U-Boot environment (but dummy)
         """
         # other tests might have run and the
         # system might not be in a clean state.
@@ -41,111 +47,44 @@ class TestEfiCapsuleFirmwareFit(object):
         u_boot_console.restart_uboot()
 
         disk_img = efi_capsule_data
+        capsule_files = ['Test05']
         with u_boot_console.log.section('Test Case 1-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi -s ""',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize contents
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.env.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 150000 10',
-                'sf read 5000000 150000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test05' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test05 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test05' in ''.join(output)
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
-        capsule_auth = u_boot_config.buildconfig.get(
-            'config_efi_capsule_authenticate')
 
         # reboot
         u_boot_console.restart_uboot(expect_reset = capsule_early)
 
         with u_boot_console.log.section('Test Case 1-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test05' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+            # deleted anyway
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf read 4000000 150000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot-env:Old' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
+            verify_content(u_boot_console, '150000', 'u-boot-env:Old')
 
     def test_efi_capsule_fw2(
             self, u_boot_config, u_boot_console, efi_capsule_data):
+        """Test Case 2
+        Update U-Boot and U-Boot environment on SPI Flash
+        0x100000-0x150000: U-Boot binary (but dummy)
+        0x150000-0x200000: U-Boot environment (but dummy)
         """
-        Test Case 2 - Update U-Boot and U-Boot environment on SPI Flash
-                      0x100000-0x150000: U-Boot binary (but dummy)
-                      0x150000-0x200000: U-Boot environment (but dummy)
-        """
+
         disk_img = efi_capsule_data
+        capsule_files = ['Test04']
         with u_boot_console.log.section('Test Case 2-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi -s ""',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize contents
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.env.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 150000 10',
-                'sf read 5000000 150000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test04' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test04 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test04' in ''.join(output)
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
@@ -157,36 +96,88 @@ class TestEfiCapsuleFirmwareFit(object):
 
         with u_boot_console.log.section('Test Case 2-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test04' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test04' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            if capsule_auth:
-                assert 'u-boot:Old' in ''.join(output)
-            else:
-                assert 'u-boot:New' in ''.join(output)
+            expected = 'u-boot:Old' if capsule_auth else 'u-boot:New'
+            verify_content(u_boot_console, '100000', expected)
+
+            expected = 'u-boot-env:Old' if capsule_auth else 'u-boot-env:New'
+            verify_content(u_boot_console, '150000', expected)
+
+    def test_efi_capsule_fw3(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """ Test Case 3
+        Update U-Boot on SPI Flash, raw image format with fw_version and lowest_supported_version
+        0x100000-0x150000: U-Boot binary (but dummy)
+        0x150000-0x200000: U-Boot environment (but dummy)
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test104']
+        with u_boot_console.log.section('Test Case 3-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        # reboot
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
 
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        capsule_auth = u_boot_config.buildconfig.get(
+            'config_efi_capsule_authenticate')
+        with u_boot_console.log.section('Test Case 3-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            # deleted anyway
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
+            # make sure the dfu_alt_info exists because it is required for making ESRT.
             output = u_boot_console.run_command_list([
-                'sf read 4000000 150000 10',
-                'md.b 4000000 10'])
+                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;'
+                'u-boot-env raw 0x150000 0x200000"',
+                'efidebug capsule esrt'])
+
             if capsule_auth:
-                assert 'u-boot-env:Old' in ''.join(output)
+                # capsule authentication failed
+                verify_content(u_boot_console, '100000', 'u-boot:Old')
+                verify_content(u_boot_console, '150000', 'u-boot-env:Old')
             else:
-                assert 'u-boot-env:New' in ''.join(output)
+                # ensure that SANDBOX_UBOOT_IMAGE_GUID is in the ESRT.
+                assert '3673B45D-6A7C-46F3-9E60-ADABB03F7937' in ''.join(output)
+                assert 'ESRT: fw_version=5' in ''.join(output)
+                assert 'ESRT: lowest_supported_fw_version=3' in ''.join(output)
+
+                verify_content(u_boot_console, '100000', 'u-boot:New')
+                verify_content(u_boot_console, '150000', 'u-boot-env:New')
+
+    def test_efi_capsule_fw4(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """ Test Case 4
+        Update U-Boot on SPI Flash, raw image format with fw_version and lowest_supported_version
+        but fw_version is lower than lowest_supported_version
+        No update should happen
+        0x100000-0x150000: U-Boot binary (but dummy)
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test105']
+        with u_boot_console.log.section('Test Case 4-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        # reboot
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        with u_boot_console.log.section('Test Case 4-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
diff --git a/test/py/tests/test_efi_capsule/test_capsule_firmware_raw.py b/test/py/tests/test_efi_capsule/test_capsule_firmware_raw.py
index 92bfb14932..80d791e3de 100644
--- a/test/py/tests/test_efi_capsule/test_capsule_firmware_raw.py
+++ b/test/py/tests/test_efi_capsule/test_capsule_firmware_raw.py
@@ -7,7 +7,16 @@ This test verifies capsule-on-disk firmware update for raw images
 """
 
 import pytest
-from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
+from capsule_common import (
+    setup,
+    init_content,
+    place_capsule_file,
+    exec_manual_update,
+    check_file_removed,
+    check_file_exist,
+    verify_content,
+    do_reboot_dtb_specified
+)
 
 @pytest.mark.boardspec('sandbox')
 @pytest.mark.buildconfigspec('efi_capsule_firmware_raw')
@@ -40,37 +49,12 @@ class TestEfiCapsuleFirmwareRaw:
         u_boot_console.restart_uboot()
 
         disk_img = efi_capsule_data
+        capsule_files = ['Test03']
         with u_boot_console.log.section('Test Case 1-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi -s ""',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize contents
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.env.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 150000 10',
-                'sf read 5000000 150000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test03' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test03 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test03' in ''.join(output)
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
 
         # reboot
         u_boot_console.restart_uboot()
@@ -80,28 +64,13 @@ class TestEfiCapsuleFirmwareRaw:
 
         with u_boot_console.log.section('Test Case 1-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test03' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+            # deleted anyway
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf read 4000000 150000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot-env:Old' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
+            verify_content(u_boot_console, '150000', 'u-boot-env:Old')
 
     def test_efi_capsule_fw2(
             self, u_boot_config, u_boot_console, efi_capsule_data):
@@ -112,44 +81,12 @@ class TestEfiCapsuleFirmwareRaw:
         0x150000-0x200000: U-Boot environment (but dummy)
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test01', 'Test02']
         with u_boot_console.log.section('Test Case 2-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi -s ""',
-                'efidebug boot order 1',
-                'env set -e OsIndications',
-                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize contents
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.env.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 150000 10',
-                'sf read 5000000 150000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place the capsule files
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test01' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test01 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test01' in ''.join(output)
-
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test02' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test02 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test02' in ''.join(output)
+            setup(u_boot_console, disk_img, None)
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
 
         # reboot
         u_boot_console.restart_uboot()
@@ -158,35 +95,12 @@ class TestEfiCapsuleFirmwareRaw:
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 2-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test01' in ''.join(output)
-                assert 'Test02' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000')
-
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test01' in ''.join(output)
-            assert 'Test02' in ''.join(output)
+                exec_manual_update(u_boot_console, disk_img, capsule_files, False)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+            check_file_exist(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf read 4000000 150000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot-env:Old' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
+            verify_content(u_boot_console, '150000', 'u-boot-env:Old')
 
     def test_efi_capsule_fw3(
             self, u_boot_config, u_boot_console, efi_capsule_data):
@@ -195,45 +109,12 @@ class TestEfiCapsuleFirmwareRaw:
         0x100000-0x150000: U-Boot binary (but dummy)
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test01', 'Test02']
         with u_boot_console.log.section('Test Case 3-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi -s ""',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize contents
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.env.old' % CAPSULE_DATA_DIR,
-                'sf write 4000000 150000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place the capsule files
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test01' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test01 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test01' in ''.join(output)
-
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test02' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test02 $filesize' % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test02' in ''.join(output)
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
@@ -245,18 +126,7 @@ class TestEfiCapsuleFirmwareRaw:
 
         with u_boot_console.log.section('Test Case 3-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test01' in ''.join(output)
-                assert 'Test02' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
             # make sure the dfu_alt_info exists because it is required for making ESRT.
             output = u_boot_console.run_command_list([
@@ -269,26 +139,91 @@ class TestEfiCapsuleFirmwareRaw:
             # ensure that SANDBOX_UBOOT_IMAGE_GUID is in the ESRT.
             assert '09D7CF52-0720-4710-91D1-08469B7FE9C8' in ''.join(output)
 
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test01' not in ''.join(output)
-            assert 'Test02' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            if capsule_auth:
-                assert 'u-boot:Old' in ''.join(output)
-            else:
-                assert 'u-boot:New' in ''.join(output)
+            expected = 'u-boot:Old' if capsule_auth else 'u-boot:New'
+            verify_content(u_boot_console, '100000', expected)
+
+            expected = 'u-boot-env:Old' if capsule_auth else 'u-boot-env:New'
+            verify_content(u_boot_console, '150000', expected)
 
+    def test_efi_capsule_fw4(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """ Test Case 4
+        Update U-Boot on SPI Flash, raw image format with fw_version and lowest_supported_version
+        0x100000-0x150000: U-Boot binary (but dummy)
+        0x150000-0x200000: U-Boot environment (but dummy)
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test101', 'Test102']
+        with u_boot_console.log.section('Test Case 4-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            init_content(u_boot_console, '150000', 'u-boot.env.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        # reboot
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        capsule_auth = u_boot_config.buildconfig.get(
+            'config_efi_capsule_authenticate')
+        with u_boot_console.log.section('Test Case 4-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            # deleted anyway
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
+            # make sure the dfu_alt_info exists because it is required for making ESRT.
             output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 150000 10',
-                'md.b 4000000 10'])
+                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000'
+                'u-boot-env raw 0x150000 0x200000"',
+                'efidebug capsule esrt'])
+
             if capsule_auth:
-                assert 'u-boot-env:Old' in ''.join(output)
+                # capsule authentication failed
+                verify_content(u_boot_console, '100000', 'u-boot:Old')
+                verify_content(u_boot_console, '150000', 'u-boot-env:Old')
             else:
-                assert 'u-boot-env:New' in ''.join(output)
+                # ensure that SANDBOX_UBOOT_IMAGE_GUID is in the ESRT.
+                assert '09D7CF52-0720-4710-91D1-08469B7FE9C8' in ''.join(output)
+                assert 'ESRT: fw_version=5' in ''.join(output)
+                assert 'ESRT: lowest_supported_fw_version=3' in ''.join(output)
+
+                # ensure that SANDBOX_UBOOT_ENV_IMAGE_GUID is in the ESRT.
+                assert '5A7021F5-FEF2-48B4-AABA-832E777418C0' in ''.join(output)
+                assert 'ESRT: fw_version=10' in ''.join(output)
+                assert 'ESRT: lowest_supported_fw_version=7' in ''.join(output)
+
+                verify_content(u_boot_console, '100000', 'u-boot:New')
+                verify_content(u_boot_console, '150000', 'u-boot-env:New')
+
+    def test_efi_capsule_fw5(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """ Test Case 5
+        Update U-Boot on SPI Flash, raw image format with fw_version and lowest_supported_version
+        but fw_version is lower than lowest_supported_version
+        No update should happen
+        0x100000-0x150000: U-Boot binary (but dummy)
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test103']
+        with u_boot_console.log.section('Test Case 5-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        # reboot
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        with u_boot_console.log.section('Test Case 5-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
diff --git a/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_fit.py b/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_fit.py
index d6ca9b1674..94d6c3eef0 100644
--- a/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_fit.py
+++ b/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_fit.py
@@ -3,18 +3,23 @@
 # Copyright (c) 2022, Arm Limited
 # Author: AKASHI Takahiro <takahiro.akashi@linaro.org>,
 #         adapted to FIT images by Vincent Stehlé <vincent.stehle@arm.com>
-#
-# U-Boot UEFI: Firmware Update (Signed capsule with FIT images) Test
 
-"""
+"""U-Boot UEFI: Firmware Update (Signed capsule with FIT images) Test
 This test verifies capsule-on-disk firmware update
 with signed capsule files containing FIT images
 """
 
 import pytest
-from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
+from capsule_common import (
+    setup,
+    init_content,
+    place_capsule_file,
+    exec_manual_update,
+    check_file_removed,
+    verify_content,
+    do_reboot_dtb_specified
+)
 
-@pytest.mark.boardspec('sandbox64')
 @pytest.mark.boardspec('sandbox_flattree')
 @pytest.mark.buildconfigspec('efi_capsule_firmware_fit')
 @pytest.mark.buildconfigspec('efi_capsule_authenticate')
@@ -26,235 +31,163 @@ from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
 @pytest.mark.buildconfigspec('cmd_nvedit_efi')
 @pytest.mark.buildconfigspec('cmd_sf')
 @pytest.mark.slow
-class TestEfiCapsuleFirmwareSignedFit(object):
+class TestEfiCapsuleFirmwareSignedFit():
+    """Capsule-on-disk firmware update test
+    """
+
     def test_efi_capsule_auth1(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 1 - Update U-Boot on SPI Flash, FIT image format
-                      0x100000-0x150000: U-Boot binary (but dummy)
+        """Test Case 1
+        Update U-Boot on SPI Flash, FIT image format
+        x150000: U-Boot binary (but dummy)
 
-                      If the capsule is properly signed, the authentication
-                      should pass and the firmware be updated.
+        If the capsule is properly signed, the authentication
+        should pass and the firmware be updated.
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test13']
         with u_boot_console.log.section('Test Case 1-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize content
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old'
-                        % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test13' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test13 $filesize'
-                        % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test13' in ''.join(output)
-
-        # reboot
-        mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
-        u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
-                                    + '/test_sig.dtb'
-        u_boot_console.restart_uboot()
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_sig.dtb')
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 1-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info '
-                            '"sf 0:0=u-boot-bin raw 0x100000 '
-                            '0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test13' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test13' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:New' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:New')
 
     def test_efi_capsule_auth2(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 2 - Update U-Boot on SPI Flash, FIT image format
-                      0x100000-0x150000: U-Boot binary (but dummy)
+        """Test Case 2
+        Update U-Boot on SPI Flash, FIT image format
+        0x100000-0x150000: U-Boot binary (but dummy)
 
-                      If the capsule is signed but with an invalid key,
-                      the authentication should fail and the firmware
-                      not be updated.
+        If the capsule is signed but with an invalid key,
+        the authentication should fail and the firmware
+        not be updated.
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test14']
         with u_boot_console.log.section('Test Case 2-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize content
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old'
-                        % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test14' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test14 $filesize'
-                                % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test14' in ''.join(output)
-
-        # reboot
-        mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
-        u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
-                                    + '/test_sig.dtb'
-        u_boot_console.restart_uboot()
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_sig.dtb')
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 2-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test14' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
             # deleted any way
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test14' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
             # TODO: check CapsuleStatus in CapsuleXXXX
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
 
     def test_efi_capsule_auth3(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 3 - Update U-Boot on SPI Flash, FIT image format
-                      0x100000-0x150000: U-Boot binary (but dummy)
+        """Test Case 3
+        Update U-Boot on SPI Flash, FIT image format
+        0x100000-0x150000: U-Boot binary (but dummy)
 
-                      If the capsule is not signed, the authentication
-                      should fail and the firmware not be updated.
+        If the capsule is not signed, the authentication
+        should fail and the firmware not be updated.
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test02']
         with u_boot_console.log.section('Test Case 3-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize content
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old'
-                        % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test02' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test02 $filesize'
-                            % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test02' in ''.join(output)
-
-        # reboot
-        mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
-        u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
-                                    + '/test_sig.dtb'
-        u_boot_console.restart_uboot()
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_sig.dtb')
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 3-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info '
-                            '"sf 0:0=u-boot-bin raw 0x100000 '
-                            '0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test02' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
             # deleted any way
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test02' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
             # TODO: check CapsuleStatus in CapsuleXXXX
 
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
+
+    def test_efi_capsule_auth4(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """Test Case 4 - Update U-Boot on SPI Flash, raw image format with version information
+        0x100000-0x150000: U-Boot binary (but dummy)
+
+        If the capsule is properly signed, the authentication
+        should pass and the firmware be updated.
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test114']
+        with u_boot_console.log.section('Test Case 4-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        with u_boot_console.log.section('Test Case 4-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
             output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;'
+                'u-boot-env raw 0x150000 0x200000"',
+                'efidebug capsule esrt'])
+
+            # ensure that SANDBOX_UBOOT_IMAGE_GUID is in the ESRT.
+            assert '3673B45D-6A7C-46F3-9E60-ADABB03F7937' in ''.join(output)
+            assert 'ESRT: fw_version=5' in ''.join(output)
+            assert 'ESRT: lowest_supported_fw_version=3' in ''.join(output)
+
+            verify_content(u_boot_console, '100000', 'u-boot:New')
+            verify_content(u_boot_console, '150000', 'u-boot-env:New')
+
+    def test_efi_capsule_auth5(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """Test Case 5 - Update U-Boot on SPI Flash, raw image format with version information
+        0x100000-0x150000: U-Boot binary (but dummy)
+
+        If the capsule is signed but fw_version is lower than lowest
+        supported version, the authentication should fail and the firmware
+        not be updated.
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test115']
+        with u_boot_console.log.section('Test Case 5-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        with u_boot_console.log.section('Test Case 5-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
diff --git a/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_raw.py b/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_raw.py
index 2bbaa9cc55..ad2b1c6324 100644
--- a/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_raw.py
+++ b/test/py/tests/test_efi_capsule/test_capsule_firmware_signed_raw.py
@@ -1,16 +1,22 @@
 # SPDX-License-Identifier:      GPL-2.0+
 # Copyright (c) 2021, Linaro Limited
 # Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
-#
-# U-Boot UEFI: Firmware Update (Signed capsule with raw images) Test
 
-"""
+"""U-Boot UEFI: Firmware Update (Signed capsule with raw images) Test
 This test verifies capsule-on-disk firmware update
 with signed capsule files containing raw images
 """
 
 import pytest
-from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
+from capsule_common import (
+    setup,
+    init_content,
+    place_capsule_file,
+    exec_manual_update,
+    check_file_removed,
+    verify_content,
+    do_reboot_dtb_specified
+)
 
 @pytest.mark.boardspec('sandbox')
 @pytest.mark.buildconfigspec('efi_capsule_firmware_raw')
@@ -23,234 +29,164 @@ from capsule_defs import CAPSULE_DATA_DIR, CAPSULE_INSTALL_DIR
 @pytest.mark.buildconfigspec('cmd_nvedit_efi')
 @pytest.mark.buildconfigspec('cmd_sf')
 @pytest.mark.slow
-class TestEfiCapsuleFirmwareSignedRaw(object):
+class TestEfiCapsuleFirmwareSignedRaw():
+    """Firmware Update (Signed capsule with raw images) Test
+    """
+
     def test_efi_capsule_auth1(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 1 - Update U-Boot on SPI Flash, raw image format
-                      0x100000-0x150000: U-Boot binary (but dummy)
+        """Test Case 1 - Update U-Boot on SPI Flash, raw image format
+        0x100000-0x150000: U-Boot binary (but dummy)
 
-                      If the capsule is properly signed, the authentication
-                      should pass and the firmware be updated.
+        If the capsule is properly signed, the authentication
+        should pass and the firmware be updated.
         """
         disk_img = efi_capsule_data
+        capsule_files =  ['Test11']
         with u_boot_console.log.section('Test Case 1-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize content
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old'
-                        % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test11' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test11 $filesize'
-                        % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test11' in ''.join(output)
-
-        # reboot
-        mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
-        u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
-                                    + '/test_sig.dtb'
-        u_boot_console.restart_uboot()
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_sig.dtb')
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 1-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info '
-                            '"sf 0:0=u-boot-bin raw 0x100000 '
-                            '0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test11' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test11' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:New' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:New')
 
     def test_efi_capsule_auth2(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 2 - Update U-Boot on SPI Flash, raw image format
-                      0x100000-0x150000: U-Boot binary (but dummy)
+        """Test Case 2 - Update U-Boot on SPI Flash, raw image format
+        0x100000-0x150000: U-Boot binary (but dummy)
 
-                      If the capsule is signed but with an invalid key,
-                      the authentication should fail and the firmware
-                      not be updated.
+        If the capsule is signed but with an invalid key,
+        the authentication should fail and the firmware
+        not be updated.
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test12']
         with u_boot_console.log.section('Test Case 2-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize content
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old'
-                        % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test12' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test12 $filesize'
-                                % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test12' in ''.join(output)
-
-        # reboot
-        mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
-        u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
-                                    + '/test_sig.dtb'
-        u_boot_console.restart_uboot()
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_sig.dtb')
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 2-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test12' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
-
-            # deleted any way
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test12' not in ''.join(output)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
             # TODO: check CapsuleStatus in CapsuleXXXX
 
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
 
     def test_efi_capsule_auth3(
             self, u_boot_config, u_boot_console, efi_capsule_data):
-        """
-        Test Case 3 - Update U-Boot on SPI Flash, raw image format
-                      0x100000-0x150000: U-Boot binary (but dummy)
+        """Test Case 3 - Update U-Boot on SPI Flash, raw image format
+        0x100000-0x150000: U-Boot binary (but dummy)
 
-                      If the capsule is not signed, the authentication
-                      should fail and the firmware not be updated.
+        If the capsule is not signed, the authentication
+        should fail and the firmware not be updated.
         """
         disk_img = efi_capsule_data
+        capsule_files = ['Test02']
         with u_boot_console.log.section('Test Case 3-a, before reboot'):
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'printenv -e PlatformLangCodes', # workaround for terminal size determination
-                'efidebug boot add -b 1 TEST host 0:1 /helloworld.efi',
-                'efidebug boot order 1',
-                'env set -e -nv -bs -rt OsIndications =0x0000000000000004',
-                'env set dfu_alt_info '
-                        '"sf 0:0=u-boot-bin raw 0x100000 '
-                        '0x50000;u-boot-env raw 0x150000 0x200000"',
-                'env save'])
-
-            # initialize content
-            output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'fatload host 0:1 4000000 %s/u-boot.bin.old'
-                        % CAPSULE_DATA_DIR,
-                'sf write 4000000 100000 10',
-                'sf read 5000000 100000 10',
-                'md.b 5000000 10'])
-            assert 'Old' in ''.join(output)
-
-            # place a capsule file
-            output = u_boot_console.run_command_list([
-                'fatload host 0:1 4000000 %s/Test02' % CAPSULE_DATA_DIR,
-                'fatwrite host 0:1 4000000 %s/Test02 $filesize'
-                            % CAPSULE_INSTALL_DIR,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test02' in ''.join(output)
-
-        # reboot
-        mnt_point = u_boot_config.persistent_data_dir + '/test_efi_capsule'
-        u_boot_console.config.dtb = mnt_point + CAPSULE_DATA_DIR \
-                                    + '/test_sig.dtb'
-        u_boot_console.restart_uboot()
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_sig.dtb')
 
         capsule_early = u_boot_config.buildconfig.get(
             'config_efi_capsule_on_disk_early')
         with u_boot_console.log.section('Test Case 3-b, after reboot'):
             if not capsule_early:
-                # make sure that dfu_alt_info exists even persistent variables
-                # are not available.
-                output = u_boot_console.run_command_list([
-                    'env set dfu_alt_info '
-                            '"sf 0:0=u-boot-bin raw 0x100000 '
-                            '0x50000;u-boot-env raw 0x150000 0x200000"',
-                    'host bind 0 %s' % disk_img,
-                    'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-                assert 'Test02' in ''.join(output)
-
-                # need to run uefi command to initiate capsule handling
-                output = u_boot_console.run_command(
-                    'env print -e Capsule0000', wait_for_reboot = True)
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
 
             # deleted anyway
-            output = u_boot_console.run_command_list([
-                'host bind 0 %s' % disk_img,
-                'fatls host 0:1 %s' % CAPSULE_INSTALL_DIR])
-            assert 'Test02' not in ''.join(output)
+            check_file_removed(u_boot_console, disk_img, capsule_files)
 
             # TODO: check CapsuleStatus in CapsuleXXXX
 
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
+
+    def test_efi_capsule_auth4(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """Test Case 4 - Update U-Boot on SPI Flash, raw image format with version information
+        0x100000-0x150000: U-Boot binary (but dummy)
+
+        If the capsule is properly signed, the authentication
+        should pass and the firmware be updated.
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test111', 'Test112']
+        with u_boot_console.log.section('Test Case 4-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        with u_boot_console.log.section('Test Case 4-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
             output = u_boot_console.run_command_list([
-                'sf probe 0:0',
-                'sf read 4000000 100000 10',
-                'md.b 4000000 10'])
-            assert 'u-boot:Old' in ''.join(output)
+                'env set dfu_alt_info "sf 0:0=u-boot-bin raw 0x100000 0x50000;'
+                'u-boot-env raw 0x150000 0x200000"',
+                'efidebug capsule esrt'])
+
+            # ensure that SANDBOX_UBOOT_IMAGE_GUID is in the ESRT.
+            assert '09D7CF52-0720-4710-91D1-08469B7FE9C8' in ''.join(output)
+            assert 'ESRT: fw_version=5' in ''.join(output)
+            assert 'ESRT: lowest_supported_fw_version=3' in ''.join(output)
+
+            # ensure that SANDBOX_UBOOT_ENV_IMAGE_GUID is in the ESRT.
+            assert '5A7021F5-FEF2-48B4-AABA-832E777418C0' in ''.join(output)
+            assert 'ESRT: fw_version=10' in ''.join(output)
+            assert 'ESRT: lowest_supported_fw_version=7' in ''.join(output)
+
+            verify_content(u_boot_console, '100000', 'u-boot:New')
+            verify_content(u_boot_console, '150000', 'u-boot-env:New')
+
+    def test_efi_capsule_auth5(
+            self, u_boot_config, u_boot_console, efi_capsule_data):
+        """Test Case 5 - Update U-Boot on SPI Flash, raw image format with version information
+        0x100000-0x150000: U-Boot binary (but dummy)
+
+        If the capsule is signed but fw_version is lower than lowest
+        supported version, the authentication should fail and the firmware
+        not be updated.
+        """
+        disk_img = efi_capsule_data
+        capsule_files = ['Test113']
+        with u_boot_console.log.section('Test Case 5-a, before reboot'):
+            setup(u_boot_console, disk_img, '0x0000000000000004')
+            init_content(u_boot_console, '100000', 'u-boot.bin.old', 'Old')
+            place_capsule_file(u_boot_console, capsule_files)
+
+        do_reboot_dtb_specified(u_boot_config, u_boot_console, 'test_ver.dtb')
+
+        capsule_early = u_boot_config.buildconfig.get(
+            'config_efi_capsule_on_disk_early')
+        with u_boot_console.log.section('Test Case 5-b, after reboot'):
+            if not capsule_early:
+                exec_manual_update(u_boot_console, disk_img, capsule_files)
+
+            check_file_removed(u_boot_console, disk_img, capsule_files)
+
+            verify_content(u_boot_console, '100000', 'u-boot:Old')
diff --git a/test/py/tests/test_efi_capsule/version.dts b/test/py/tests/test_efi_capsule/version.dts
new file mode 100644
index 0000000000..07850cc606
--- /dev/null
+++ b/test/py/tests/test_efi_capsule/version.dts
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/dts-v1/;
+/plugin/;
+
+&{/} {
+	firmware-version {
+		image1 {
+			lowest-supported-version = <3>;
+			image-index = <1>;
+			image-type-id = "09D7CF52-0720-4710-91D1-08469B7FE9C8";
+		};
+		image2 {
+			lowest-supported-version = <7>;
+			image-index = <2>;
+			image-type-id = "5A7021F5-FEF2-48B4-AABA-832E777418C0";
+		};
+		image3 {
+			lowest-supported-version = <3>;
+			image-index = <1>;
+			image-type-id = "3673B45D-6A7C-46F3-9E60-ADABB03F7937";
+		};
+	};
+};
diff --git a/test/py/tests/test_pinmux.py b/test/py/tests/test_pinmux.py
index b3ae2ab024..2411937773 100644
--- a/test/py/tests/test_pinmux.py
+++ b/test/py/tests/test_pinmux.py
@@ -24,19 +24,19 @@ def test_pinmux_status_all(u_boot_console):
     output = u_boot_console.run_command('pinmux status -a')
 
     assert ('pinctrl-gpio:' in output)
-    assert ('a5        : gpio output .' in output)
-    assert ('a6        : gpio output .' in output)
+    assert ('a5              : gpio output .' in output)
+    assert ('a6              : gpio output .' in output)
 
     assert ('pinctrl:' in output)
-    assert ('P0        : UART TX.' in output)
-    assert ('P1        : UART RX.' in output)
-    assert ('P2        : I2S SCK.' in output)
-    assert ('P3        : I2S SD.' in output)
-    assert ('P4        : I2S WS.' in output)
-    assert ('P5        : GPIO0 bias-pull-up input-disable.' in output)
-    assert ('P6        : GPIO1 drive-open-drain.' in output)
-    assert ('P7        : GPIO2 bias-pull-down input-enable.' in output)
-    assert ('P8        : GPIO3 bias-disable.' in output)
+    assert ('P0              : UART TX.' in output)
+    assert ('P1              : UART RX.' in output)
+    assert ('P2              : I2S SCK.' in output)
+    assert ('P3              : I2S SD.' in output)
+    assert ('P4              : I2S WS.' in output)
+    assert ('P5              : GPIO0 bias-pull-up input-disable.' in output)
+    assert ('P6              : GPIO1 drive-open-drain.' in output)
+    assert ('P7              : GPIO2 bias-pull-down input-enable.' in output)
+    assert ('P8              : GPIO3 bias-disable.' in output)
 
 @pytest.mark.buildconfigspec('cmd_pinmux')
 @pytest.mark.boardspec('sandbox')
@@ -73,12 +73,12 @@ def test_pinmux_status(u_boot_console):
     assert (not 'pinctrl-gpio:' in output)
     assert (not 'pinctrl:' in output)
 
-    assert ('P0        : UART TX.' in output)
-    assert ('P1        : UART RX.' in output)
-    assert ('P2        : I2S SCK.' in output)
-    assert ('P3        : I2S SD.' in output)
-    assert ('P4        : I2S WS.' in output)
-    assert ('P5        : GPIO0 bias-pull-up input-disable.' in output)
-    assert ('P6        : GPIO1 drive-open-drain.' in output)
-    assert ('P7        : GPIO2 bias-pull-down input-enable.' in output)
-    assert ('P8        : GPIO3 bias-disable.' in output)
+    assert ('P0              : UART TX.' in output)
+    assert ('P1              : UART RX.' in output)
+    assert ('P2              : I2S SCK.' in output)
+    assert ('P3              : I2S SD.' in output)
+    assert ('P4              : I2S WS.' in output)
+    assert ('P5              : GPIO0 bias-pull-up input-disable.' in output)
+    assert ('P6              : GPIO1 drive-open-drain.' in output)
+    assert ('P7              : GPIO2 bias-pull-down input-enable.' in output)
+    assert ('P8              : GPIO3 bias-disable.' in output)
diff --git a/tools/Kconfig b/tools/Kconfig
index 539708f277..6e23f44d55 100644
--- a/tools/Kconfig
+++ b/tools/Kconfig
@@ -157,4 +157,13 @@ config LUT_SEQUENCE
 	help
 	  Look Up Table Sequence
 
+config TOOLS_MKFWUMDATA
+	bool "Build mkfwumdata command"
+	default y if FWU_MULTI_BANK_UPDATE
+	help
+	  This command allows users to create a raw image of the FWU
+	  metadata for initial installation of the FWU multi bank
+	  update on the board. The installation method depends on
+	  the platform.
+
 endmenu
diff --git a/tools/Makefile b/tools/Makefile
index 3626919633..c8a72d2083 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -74,7 +74,9 @@ mkenvimage-objs := mkenvimage.o os_support.o lib/crc32.o
 hostprogs-y += dumpimage mkimage
 hostprogs-$(CONFIG_TOOLS_LIBCRYPTO) += fit_info fit_check_sign
 
-hostprogs-$(CONFIG_CMD_BOOTEFI_SELFTEST) += file2include
+ifneq ($(CONFIG_CMD_BOOTEFI_SELFTEST)$(CONFIG_FWU_MDATA_GPT_BLK),)
+hostprogs-y += file2include
+endif
 
 FIT_OBJS-y := fit_common.o fit_image.o image-host.o boot/image-fit.o
 FIT_SIG_OBJS-$(CONFIG_TOOLS_LIBCRYPTO) := image-sig-host.o boot/image-fit-sig.o
@@ -254,6 +256,10 @@ HOSTLDLIBS_mkeficapsule += \
 	$(shell pkg-config --libs uuid 2> /dev/null || echo "-luuid")
 hostprogs-$(CONFIG_TOOLS_MKEFICAPSULE) += mkeficapsule
 
+mkfwumdata-objs := mkfwumdata.o lib/crc32.o
+HOSTLDLIBS_mkfwumdata += -luuid
+hostprogs-$(CONFIG_TOOLS_MKFWUMDATA) += mkfwumdata
+
 # We build some files with extra pedantic flags to try to minimize things
 # that won't build on some weird host compiler -- though there are lots of
 # exceptions for files that aren't complaint.
@@ -267,7 +273,13 @@ HOSTCFLAGS_sha512.o := -pedantic -DCONFIG_SHA512 -DCONFIG_SHA384
 quiet_cmd_wrap = WRAP    $@
 cmd_wrap = echo "\#include <../$(patsubst $(obj)/%,%,$@)>" >$@
 
-$(obj)/boot/%.c $(obj)/common/%.c $(obj)/env/%.c $(obj)/lib/%.c:
+$(obj)/boot/%.c :
+	$(call cmd,wrap)
+$(obj)/common/%.c :
+	$(call cmd,wrap)
+$(obj)/env/%.c :
+	$(call cmd,wrap)
+$(obj)/lib/%.c :
 	$(call cmd,wrap)
 
 clean-dirs := lib common
diff --git a/tools/eficapsule.h b/tools/eficapsule.h
index d63b831443..c92736d035 100644
--- a/tools/eficapsule.h
+++ b/tools/eficapsule.h
@@ -22,6 +22,8 @@
 #define __aligned(x)	__attribute__((__aligned__(x)))
 #endif
 
+#define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
+
 typedef struct {
 	uint8_t b[16];
 } efi_guid_t __aligned(8);
@@ -41,6 +43,14 @@ typedef struct {
 	EFI_GUID(0x4aafd29d, 0x68df, 0x49ee, 0x8a, 0xa9, \
 		 0x34, 0x7d, 0x37, 0x56, 0x65, 0xa7)
 
+#define FW_ACCEPT_OS_GUID \
+	EFI_GUID(0x0c996046, 0xbcc0, 0x4d04, 0x85, 0xec, \
+		 0xe1, 0xfc, 0xed, 0xf1, 0xc6, 0xf8)
+
+#define FW_REVERT_OS_GUID \
+	EFI_GUID(0xacd58b4b, 0xc0e8, 0x475f, 0x99, 0xb5, \
+		 0x6b, 0x3f, 0x7e, 0x07, 0xaa, 0xf0)
+
 /* flags */
 #define CAPSULE_FLAGS_PERSIST_ACROSS_RESET      0x00010000
 
@@ -105,4 +115,34 @@ struct efi_firmware_image_authentication {
 	struct win_certificate_uefi_guid auth_info;
 } __packed;
 
+/* fmp payload header */
+#define SIGNATURE_16(A, B)	((A) | ((B) << 8))
+#define SIGNATURE_32(A, B, C, D)	\
+	(SIGNATURE_16(A, B) | (SIGNATURE_16(C, D) << 16))
+
+#define FMP_PAYLOAD_HDR_SIGNATURE	SIGNATURE_32('M', 'S', 'S', '1')
+
+/**
+ * struct fmp_payload_header - EDK2 header for the FMP payload
+ *
+ * This structure describes the header which is preprended to the
+ * FMP payload by the edk2 capsule generation scripts.
+ *
+ * @signature:			Header signature used to identify the header
+ * @header_size:		Size of the structure
+ * @fw_version:			Firmware versions used
+ * @lowest_supported_version:	Lowest supported version (not used)
+ */
+struct fmp_payload_header {
+	uint32_t signature;
+	uint32_t header_size;
+	uint32_t fw_version;
+	uint32_t lowest_supported_version;
+};
+
+struct fmp_payload_header_params {
+	bool have_header;
+	uint32_t fw_version;
+};
+
 #endif /* _EFI_CAPSULE_H */
diff --git a/tools/mkeficapsule.c b/tools/mkeficapsule.c
index 5f74d23b9e..57bddbe4d0 100644
--- a/tools/mkeficapsule.c
+++ b/tools/mkeficapsule.c
@@ -29,16 +29,27 @@ static const char *tool_name = "mkeficapsule";
 efi_guid_t efi_guid_fm_capsule = EFI_FIRMWARE_MANAGEMENT_CAPSULE_ID_GUID;
 efi_guid_t efi_guid_cert_type_pkcs7 = EFI_CERT_TYPE_PKCS7_GUID;
 
-static const char *opts_short = "g:i:I:v:p:c:m:dh";
+static const char *opts_short = "g:i:I:v:p:c:m:o:dhARD";
+
+enum {
+	CAPSULE_NORMAL_BLOB = 0,
+	CAPSULE_ACCEPT,
+	CAPSULE_REVERT,
+} capsule_type;
 
 static struct option options[] = {
 	{"guid", required_argument, NULL, 'g'},
 	{"index", required_argument, NULL, 'i'},
 	{"instance", required_argument, NULL, 'I'},
+	{"fw-version", required_argument, NULL, 'v'},
 	{"private-key", required_argument, NULL, 'p'},
 	{"certificate", required_argument, NULL, 'c'},
 	{"monotonic-count", required_argument, NULL, 'm'},
 	{"dump-sig", no_argument, NULL, 'd'},
+	{"fw-accept", no_argument, NULL, 'A'},
+	{"fw-revert", no_argument, NULL, 'R'},
+	{"capoemflag", required_argument, NULL, 'o'},
+	{"dump-capsule", no_argument, NULL, 'D'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
@@ -51,10 +62,15 @@ static void print_usage(void)
 		"\t-g, --guid <guid string>    guid for image blob type\n"
 		"\t-i, --index <index>         update image index\n"
 		"\t-I, --instance <instance>   update hardware instance\n"
+		"\t-v, --fw-version <version>  firmware version\n"
 		"\t-p, --private-key <privkey file>  private key file\n"
 		"\t-c, --certificate <cert file>     signer's certificate file\n"
 		"\t-m, --monotonic-count <count>     monotonic count\n"
 		"\t-d, --dump_sig              dump signature (*.p7)\n"
+		"\t-A, --fw-accept  firmware accept capsule, requires GUID, no image blob\n"
+		"\t-R, --fw-revert  firmware revert capsule, takes no GUID, no image blob\n"
+		"\t-o, --capoemflag Capsule OEM Flag, an integer between 0x0000 and 0xffff\n"
+		"\t-D, --dump-capsule          dump the contents of the capsule headers\n"
 		"\t-h, --help                  print a help message\n",
 		tool_name);
 }
@@ -377,6 +393,7 @@ static void free_sig_data(struct auth_context *ctx)
  * @mcount:	Monotonic count in authentication information
  * @private_file:	Path to a private key file
  * @cert_file:	Path to a certificate file
+ * @oemflags:  Capsule OEM Flags, bits 0-15
  *
  * This function actually does the job of creating an uefi capsule file.
  * All the arguments must be supplied.
@@ -389,17 +406,20 @@ static void free_sig_data(struct auth_context *ctx)
  */
 static int create_fwbin(char *path, char *bin, efi_guid_t *guid,
 			unsigned long index, unsigned long instance,
-			uint64_t mcount, char *privkey_file, char *cert_file)
+			struct fmp_payload_header_params *fmp_ph_params,
+			uint64_t mcount, char *privkey_file, char *cert_file,
+			uint16_t oemflags)
 {
 	struct efi_capsule_header header;
 	struct efi_firmware_management_capsule_header capsule;
 	struct efi_firmware_management_capsule_image_header image;
 	struct auth_context auth_context;
 	FILE *f;
-	uint8_t *data;
+	uint8_t *data, *new_data, *buf;
 	off_t bin_size;
 	uint64_t offset;
 	int ret;
+	struct fmp_payload_header payload_header;
 
 #ifdef DEBUG
 	fprintf(stderr, "For output: %s\n", path);
@@ -409,6 +429,7 @@ static int create_fwbin(char *path, char *bin, efi_guid_t *guid,
 	auth_context.sig_size = 0;
 	f = NULL;
 	data = NULL;
+	new_data = NULL;
 	ret = -1;
 
 	/*
@@ -417,12 +438,30 @@ static int create_fwbin(char *path, char *bin, efi_guid_t *guid,
 	if (read_bin_file(bin, &data, &bin_size))
 		goto err;
 
+	buf = data;
+
+	/* insert fmp payload header right before the payload */
+	if (fmp_ph_params->have_header) {
+		new_data = malloc(bin_size + sizeof(payload_header));
+		if (!new_data)
+			goto err;
+
+		payload_header.signature = FMP_PAYLOAD_HDR_SIGNATURE;
+		payload_header.header_size = sizeof(payload_header);
+		payload_header.fw_version = fmp_ph_params->fw_version;
+		payload_header.lowest_supported_version = 0; /* not used */
+		memcpy(new_data, &payload_header, sizeof(payload_header));
+		memcpy(new_data + sizeof(payload_header), data, bin_size);
+		buf = new_data;
+		bin_size += sizeof(payload_header);
+	}
+
 	/* first, calculate signature to determine its size */
 	if (privkey_file && cert_file) {
 		auth_context.key_file = privkey_file;
 		auth_context.cert_file = cert_file;
 		auth_context.auth.monotonic_count = mcount;
-		auth_context.image_data = data;
+		auth_context.image_data = buf;
 		auth_context.image_size = bin_size;
 
 		if (create_auth_data(&auth_context)) {
@@ -454,6 +493,8 @@ static int create_fwbin(char *path, char *bin, efi_guid_t *guid,
 	header.header_size = sizeof(header);
 	/* TODO: The current implementation ignores flags */
 	header.flags = CAPSULE_FLAGS_PERSIST_ACROSS_RESET;
+	if (oemflags)
+		header.flags |= oemflags;
 	header.capsule_image_size = sizeof(header)
 					+ sizeof(capsule) + sizeof(uint64_t)
 					+ sizeof(image)
@@ -520,7 +561,7 @@ static int create_fwbin(char *path, char *bin, efi_guid_t *guid,
 	/*
 	 * firmware binary
 	 */
-	if (write_capsule_file(f, data, bin_size, "Firmware binary"))
+	if (write_capsule_file(f, buf, bin_size, "Firmware binary"))
 		goto err;
 
 	ret = 0;
@@ -529,6 +570,7 @@ err:
 		fclose(f);
 	free_sig_data(&auth_context);
 	free(data);
+	free(new_data);
 
 	return ret;
 }
@@ -564,6 +606,254 @@ void convert_uuid_to_guid(unsigned char *buf)
 	buf[7] = c;
 }
 
+static int create_empty_capsule(char *path, efi_guid_t *guid, bool fw_accept)
+{
+	struct efi_capsule_header header = { 0 };
+	FILE *f = NULL;
+	int ret = -1;
+	efi_guid_t fw_accept_guid = FW_ACCEPT_OS_GUID;
+	efi_guid_t fw_revert_guid = FW_REVERT_OS_GUID;
+	efi_guid_t capsule_guid;
+
+	f = fopen(path, "w");
+	if (!f) {
+		fprintf(stderr, "cannot open %s\n", path);
+		goto err;
+	}
+
+	capsule_guid = fw_accept ? fw_accept_guid : fw_revert_guid;
+
+	memcpy(&header.capsule_guid, &capsule_guid, sizeof(efi_guid_t));
+	header.header_size = sizeof(header);
+	header.flags = 0;
+
+	header.capsule_image_size = fw_accept ?
+		sizeof(header) + sizeof(efi_guid_t) : sizeof(header);
+
+	if (write_capsule_file(f, &header, sizeof(header),
+			       "Capsule header"))
+		goto err;
+
+	if (fw_accept) {
+		if (write_capsule_file(f, guid, sizeof(*guid),
+				       "FW Accept Capsule Payload"))
+			goto err;
+	}
+
+	ret = 0;
+
+err:
+	if (f)
+		fclose(f);
+
+	return ret;
+}
+
+static void print_guid(void *ptr)
+{
+	int i;
+	efi_guid_t *guid = ptr;
+	const uint8_t seq[] = {
+		3, 2, 1, 0, '-', 5, 4, '-', 7, 6,
+		'-', 8, 9, '-', 10, 11, 12, 13, 14, 15 };
+
+	for (i = 0; i < ARRAY_SIZE(seq); i++) {
+		if (seq[i] == '-')
+			putchar(seq[i]);
+		else
+			printf("%02X", guid->b[seq[i]]);
+	}
+
+	printf("\n");
+}
+
+static uint32_t dump_fmp_payload_header(struct fmp_payload_header *fmp_payload_hdr)
+{
+	if (fmp_payload_hdr->signature == FMP_PAYLOAD_HDR_SIGNATURE) {
+		printf("--------\n");
+		printf("FMP_PAYLOAD_HDR.SIGNATURE\t\t\t: %08X\n",
+		       FMP_PAYLOAD_HDR_SIGNATURE);
+		printf("FMP_PAYLOAD_HDR.HEADER_SIZE\t\t\t: %08X\n",
+		       fmp_payload_hdr->header_size);
+		printf("FMP_PAYLOAD_HDR.FW_VERSION\t\t\t: %08X\n",
+		       fmp_payload_hdr->fw_version);
+		printf("FMP_PAYLOAD_HDR.LOWEST_SUPPORTED_VERSION\t: %08X\n",
+		       fmp_payload_hdr->lowest_supported_version);
+		return fmp_payload_hdr->header_size;
+	}
+
+	return 0;
+}
+
+static void dump_capsule_auth_header(struct efi_firmware_image_authentication *capsule_auth_hdr)
+{
+	printf("EFI_FIRMWARE_IMAGE_AUTH.MONOTONIC_COUNT\t\t: %08lX\n",
+	       capsule_auth_hdr->monotonic_count);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.HDR.dwLENGTH\t: %08X\n",
+	       capsule_auth_hdr->auth_info.hdr.dwLength);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.HDR.wREVISION\t: %08X\n",
+	       capsule_auth_hdr->auth_info.hdr.wRevision);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.HDR.wCERTTYPE\t: %08X\n",
+	       capsule_auth_hdr->auth_info.hdr.wCertificateType);
+	printf("EFI_FIRMWARE_IMAGE_AUTH.AUTH_INFO.CERT_TYPE\t: ");
+	print_guid(&capsule_auth_hdr->auth_info.cert_type);
+}
+
+static void dump_fmp_capsule_image_header(struct efi_firmware_management_capsule_image_header *image_hdr)
+{
+	void *capsule_auth_hdr;
+	void *fmp_payload_hdr;
+	uint64_t signature_size = 0;
+	uint32_t payload_size = 0;
+	uint32_t fmp_payload_hdr_size = 0;
+	struct efi_firmware_image_authentication *auth_hdr;
+
+	printf("--------\n");
+	printf("FMP_CAPSULE_IMAGE_HDR.VERSION\t\t\t: %08X\n",
+	       image_hdr->version);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_IMAGE_TYPE_ID\t: ");
+	print_guid(&image_hdr->update_image_type_id);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_IMAGE_INDEX\t: %08X\n",
+	       image_hdr->update_image_index);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_IMAGE_SIZE\t\t: %08X\n",
+	       image_hdr->update_image_size);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_VENDOR_CODE_SIZE\t: %08X\n",
+	       image_hdr->update_vendor_code_size);
+	printf("FMP_CAPSULE_IMAGE_HDR.UPDATE_HARDWARE_INSTANCE\t: %08lX\n",
+	       image_hdr->update_hardware_instance);
+	printf("FMP_CAPSULE_IMAGE_HDR.IMAGE_CAPSULE_SUPPORT\t: %08lX\n",
+	       image_hdr->image_capsule_support);
+
+	printf("--------\n");
+	if (image_hdr->image_capsule_support & CAPSULE_SUPPORT_AUTHENTICATION) {
+		capsule_auth_hdr = (char *)image_hdr + sizeof(*image_hdr);
+		dump_capsule_auth_header(capsule_auth_hdr);
+
+		auth_hdr = capsule_auth_hdr;
+		signature_size = sizeof(auth_hdr->monotonic_count) +
+			auth_hdr->auth_info.hdr.dwLength;
+		fmp_payload_hdr = (char *)capsule_auth_hdr + signature_size;
+	} else {
+		printf("Capsule Authentication Not Enabled\n");
+		fmp_payload_hdr = (char *)image_hdr + sizeof(*image_hdr);
+	}
+
+	fmp_payload_hdr_size = dump_fmp_payload_header(fmp_payload_hdr);
+
+	payload_size = image_hdr->update_image_size - signature_size -
+		fmp_payload_hdr_size;
+	printf("--------\n");
+	printf("Payload Image Size\t\t\t\t: %08X\n", payload_size);
+}
+
+static void dump_fmp_header(struct efi_firmware_management_capsule_header *fmp_hdr)
+{
+	int i;
+	void *capsule_image_hdr;
+
+	printf("EFI_FMP_HDR.VERSION\t\t\t\t: %08X\n", fmp_hdr->version);
+	printf("EFI_FMP_HDR.EMBEDDED_DRIVER_COUNT\t\t: %08X\n",
+	       fmp_hdr->embedded_driver_count);
+	printf("EFI_FMP_HDR.PAYLOAD_ITEM_COUNT\t\t\t: %08X\n",
+	       fmp_hdr->payload_item_count);
+
+	/*
+	 * We currently don't support Embedded Drivers.
+	 * Only worry about the payload items.
+	 */
+	for (i = 0; i < fmp_hdr->payload_item_count; i++) {
+		capsule_image_hdr = (char *)fmp_hdr +
+			fmp_hdr->item_offset_list[i];
+		dump_fmp_capsule_image_header(capsule_image_hdr);
+	}
+}
+
+static void dump_capsule_header(struct efi_capsule_header *capsule_hdr)
+{
+	printf("EFI_CAPSULE_HDR.CAPSULE_GUID\t\t\t: ");
+	print_guid((void *)&capsule_hdr->capsule_guid);
+	printf("EFI_CAPSULE_HDR.HEADER_SIZE\t\t\t: %08X\n",
+	       capsule_hdr->header_size);
+	printf("EFI_CAPSULE_HDR.FLAGS\t\t\t\t: %08X\n", capsule_hdr->flags);
+	printf("EFI_CAPSULE_HDR.CAPSULE_IMAGE_SIZE\t\t: %08X\n",
+	       capsule_hdr->capsule_image_size);
+}
+
+static void normal_capsule_dump(void *capsule_buf)
+{
+	void *fmp_hdr;
+	struct efi_capsule_header *hdr = capsule_buf;
+
+	dump_capsule_header(hdr);
+	printf("--------\n");
+
+	fmp_hdr = (char *)capsule_buf + sizeof(*hdr);
+	dump_fmp_header(fmp_hdr);
+}
+
+static void empty_capsule_dump(void *capsule_buf)
+{
+	efi_guid_t *accept_image_guid;
+	struct efi_capsule_header *hdr = capsule_buf;
+	efi_guid_t efi_empty_accept_capsule = FW_ACCEPT_OS_GUID;
+
+	dump_capsule_header(hdr);
+
+	if (!memcmp(&efi_empty_accept_capsule, &hdr->capsule_guid,
+		    sizeof(efi_guid_t))) {
+		accept_image_guid = (void *)(char *)capsule_buf +
+			sizeof(struct efi_capsule_header);
+		printf("--------\n");
+		printf("ACCEPT_IMAGE_GUID\t\t\t\t: ");
+		print_guid(accept_image_guid);
+	}
+}
+
+static void dump_capsule_contents(char *capsule_file)
+{
+	int fd;
+	char *ptr;
+	efi_guid_t efi_fmp_guid = EFI_FIRMWARE_MANAGEMENT_CAPSULE_ID_GUID;
+	efi_guid_t efi_empty_accept_capsule = FW_ACCEPT_OS_GUID;
+	efi_guid_t efi_empty_revert_capsule = FW_REVERT_OS_GUID;
+	struct stat sbuf;
+
+	if (!capsule_file) {
+		fprintf(stderr, "No capsule file provided\n");
+		exit(EXIT_FAILURE);
+	}
+
+	if ((fd = open(capsule_file, O_RDONLY)) < 0) {
+		fprintf(stderr, "Error opening capsule file: %s\n",
+			capsule_file);
+		exit(EXIT_FAILURE);
+	}
+
+	if (fstat(fd, &sbuf) < 0) {
+		fprintf(stderr, "Can't stat capsule file: %s\n", capsule_file);
+		exit(EXIT_FAILURE);
+	}
+
+	if ((ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, fd, 0))
+	    == MAP_FAILED) {
+		fprintf(stderr, "Can't mmap capsule file: %s\n", capsule_file);
+		exit(EXIT_FAILURE);
+	}
+
+	if (!memcmp(&efi_fmp_guid, ptr, sizeof(efi_guid_t))) {
+		normal_capsule_dump(ptr);
+	} else if (!memcmp(&efi_empty_accept_capsule, ptr,
+		   sizeof(efi_guid_t)) ||
+		   !memcmp(&efi_empty_revert_capsule, ptr,
+			   sizeof(efi_guid_t))) {
+		empty_capsule_dump(ptr);
+	} else {
+		fprintf(stderr, "Unable to decode the capsule file: %s\n",
+			capsule_file);
+		exit(EXIT_FAILURE);
+	}
+}
+
 /**
  * main - main entry function of mkeficapsule
  * @argc:	Number of arguments
@@ -582,8 +872,11 @@ int main(int argc, char **argv)
 	unsigned char uuid_buf[16];
 	unsigned long index, instance;
 	uint64_t mcount;
+	unsigned long oemflags;
+	bool capsule_dump;
 	char *privkey_file, *cert_file;
 	int c, idx;
+	struct fmp_payload_header_params fmp_ph_params = { 0 };
 
 	guid = NULL;
 	index = 0;
@@ -591,7 +884,10 @@ int main(int argc, char **argv)
 	mcount = 0;
 	privkey_file = NULL;
 	cert_file = NULL;
+	capsule_dump = false;
 	dump_sig = 0;
+	capsule_type = CAPSULE_NORMAL_BLOB;
+	oemflags = 0;
 	for (;;) {
 		c = getopt_long(argc, argv, opts_short, options, &idx);
 		if (c == -1)
@@ -617,6 +913,10 @@ int main(int argc, char **argv)
 		case 'I':
 			instance = strtoul(optarg, NULL, 0);
 			break;
+		case 'v':
+			fmp_ph_params.fw_version = strtoul(optarg, NULL, 0);
+			fmp_ph_params.have_header = true;
+			break;
 		case 'p':
 			if (privkey_file) {
 				fprintf(stderr,
@@ -639,22 +939,70 @@ int main(int argc, char **argv)
 		case 'd':
 			dump_sig = 1;
 			break;
-		case 'h':
+		case 'A':
+			if (capsule_type) {
+				fprintf(stderr,
+					"Select either of Accept or Revert capsule generation\n");
+				exit(1);
+			}
+			capsule_type = CAPSULE_ACCEPT;
+			break;
+		case 'R':
+			if (capsule_type) {
+				fprintf(stderr,
+					"Select either of Accept or Revert capsule generation\n");
+				exit(1);
+			}
+			capsule_type = CAPSULE_REVERT;
+			break;
+		case 'o':
+			oemflags = strtoul(optarg, NULL, 0);
+			if (oemflags > 0xffff) {
+				fprintf(stderr,
+					"oemflags must be between 0x0 and 0xffff\n");
+				exit(1);
+			}
+			break;
+		case 'D':
+			capsule_dump = true;
+			break;
+		default:
 			print_usage();
 			exit(EXIT_SUCCESS);
 		}
 	}
 
+	if (capsule_dump) {
+		if (argc != optind + 1) {
+			fprintf(stderr, "Must provide the capsule file to parse\n");
+			exit(EXIT_FAILURE);
+		}
+		dump_capsule_contents(argv[argc - 1]);
+		exit(EXIT_SUCCESS);
+	}
+
 	/* check necessary parameters */
-	if ((argc != optind + 2) || !guid ||
-	    ((privkey_file && !cert_file) ||
-	     (!privkey_file && cert_file))) {
+	if ((capsule_type == CAPSULE_NORMAL_BLOB &&
+	    ((argc != optind + 2) || !guid ||
+	     ((privkey_file && !cert_file) ||
+	      (!privkey_file && cert_file)))) ||
+	    (capsule_type != CAPSULE_NORMAL_BLOB &&
+	    ((argc != optind + 1) ||
+	     ((capsule_type == CAPSULE_ACCEPT) && !guid) ||
+	     ((capsule_type == CAPSULE_REVERT) && guid)))) {
 		print_usage();
 		exit(EXIT_FAILURE);
 	}
 
-	if (create_fwbin(argv[argc - 1], argv[argc - 2], guid, index, instance,
-			 mcount, privkey_file, cert_file) < 0) {
+	if (capsule_type != CAPSULE_NORMAL_BLOB) {
+		if (create_empty_capsule(argv[argc - 1], guid,
+					 capsule_type == CAPSULE_ACCEPT) < 0) {
+			fprintf(stderr, "Creating empty capsule failed\n");
+			exit(EXIT_FAILURE);
+		}
+	} else 	if (create_fwbin(argv[argc - 1], argv[argc - 2], guid,
+				 index, instance, &fmp_ph_params, mcount, privkey_file,
+				 cert_file, (uint16_t)oemflags) < 0) {
 		fprintf(stderr, "Creating firmware capsule failed\n");
 		exit(EXIT_FAILURE);
 	}
diff --git a/tools/mkfwumdata.c b/tools/mkfwumdata.c
new file mode 100644
index 0000000000..fbc2067bc1
--- /dev/null
+++ b/tools/mkfwumdata.c
@@ -0,0 +1,493 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2023, Linaro Limited
+ */
+
+#include <errno.h>
+#include <getopt.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <generated/autoconf.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <u-boot/crc.h>
+#include <uuid/uuid.h>
+
+typedef uint8_t u8;
+typedef int16_t s16;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+#undef CONFIG_FWU_NUM_BANKS
+#undef CONFIG_FWU_NUM_IMAGES_PER_BANK
+
+/* This will dynamically allocate the fwu_mdata */
+#define CONFIG_FWU_NUM_BANKS		0
+#define CONFIG_FWU_NUM_IMAGES_PER_BANK	0
+
+/* version 2 supports maximum of 4 banks */
+#define MAX_BANKS_V2			4
+
+#define BANK_INVALID			(u8)0xFF
+#define BANK_ACCEPTED			(u8)0xFC
+
+#include <fwu_mdata.h>
+
+static const char *opts_short = "b:i:a:p:v:V:gh";
+
+static struct option options[] = {
+	{"banks", required_argument, NULL, 'b'},
+	{"images", required_argument, NULL, 'i'},
+	{"guid", required_argument, NULL, 'g'},
+	{"active-bank", required_argument, NULL, 'a'},
+	{"previous-bank", required_argument, NULL, 'p'},
+	{"version", required_argument, NULL, 'v'},
+	{"vendor-file", required_argument, NULL, 'V'},
+	{"help", no_argument, NULL, 'h'},
+	{NULL, 0, NULL, 0},
+};
+
+static void print_usage(void)
+{
+	fprintf(stderr, "Usage: mkfwumdata [options] <UUIDs list> <output file>\n");
+	fprintf(stderr, "Options:\n"
+		"\t-i, --images <num>          Number of images (mandatory)\n"
+		"\t-b, --banks  <num>          Number of banks (mandatory)\n"
+		"\t-v, --version               Metadata version (mandatory)\n"
+		"\t-a, --active-bank  <num>    Active bank (default=0)\n"
+		"\t-p, --previous-bank  <num>  Previous active bank (default=active_bank - 1)\n"
+		"\t-g, --guid                  Use GUID instead of UUID\n"
+		"\t-V, --vendor-file           Vendor data file to append to the metadata\n"
+		"\t-h, --help                  print a help message\n"
+		);
+	fprintf(stderr, "  UUIDs list syntax:\n"
+		"\t  <location uuid>,<image type uuid>,<images uuid list>\n"
+		"\t     images uuid list syntax:\n"
+		"\t        img_uuid_00,img_uuid_01...img_uuid_0b,\n"
+		"\t        img_uuid_10,img_uuid_11...img_uuid_1b,\n"
+		"\t        ...,\n"
+		"\t        img_uuid_i0,img_uuid_i1...img_uuid_ib,\n"
+		"\t          where 'b' and 'i' are number of banks and number\n"
+		"\t          of images in a bank respectively.\n"
+	       );
+}
+
+struct fwu_mdata_object {
+	size_t images;
+	size_t banks;
+	size_t size;
+	u8 version;
+	size_t vsize;
+	void *vbuf;
+	struct fwu_mdata *mdata;
+};
+
+static int previous_bank, active_bank;
+static bool __use_guid;
+
+static bool supported_mdata_version(unsigned long version)
+{
+	switch (version) {
+	case 1:
+	case 2:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static struct fwu_mdata_object *fwu_alloc_mdata(size_t images, size_t banks,
+						u8 version, size_t vendor_size)
+{
+	struct fwu_mdata_object *mobj;
+
+	mobj = calloc(1, sizeof(*mobj));
+	if (!mobj)
+		return NULL;
+
+	if (version == 1) {
+		mobj->size = sizeof(struct fwu_mdata) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * banks) * images;
+	} else {
+		mobj->size = sizeof(struct fwu_mdata) +
+			sizeof(struct fwu_fw_store_desc) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * banks) * images;
+
+		mobj->size += vendor_size;
+		mobj->vsize = vendor_size;
+	}
+
+	mobj->images = images;
+	mobj->banks = banks;
+	mobj->version = version;
+
+	mobj->mdata = calloc(1, mobj->size);
+	if (!mobj->mdata)
+		goto alloc_err;
+
+	if (vendor_size) {
+		mobj->vbuf = calloc(1, mobj->vsize);
+		if (!mobj->vbuf)
+			goto alloc_err;
+	}
+
+	return mobj;
+
+alloc_err:
+	free(mobj->mdata);
+	free(mobj);
+	return NULL;
+}
+
+static struct fwu_image_entry *
+fwu_get_image(struct fwu_mdata_object *mobj, size_t idx)
+{
+	size_t offset;
+
+	if (mobj->version == 1) {
+		offset = sizeof(struct fwu_mdata) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			idx;
+	} else {
+		offset = sizeof(struct fwu_mdata) +
+			sizeof(struct fwu_fw_store_desc) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			idx;
+	}
+
+	return (struct fwu_image_entry *)((char *)mobj->mdata + offset);
+}
+
+static struct fwu_image_bank_info *
+fwu_get_bank(struct fwu_mdata_object *mobj, size_t img_idx, size_t bnk_idx)
+{
+	size_t offset;
+
+	if (mobj->version == 1) {
+		offset = sizeof(struct fwu_mdata) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			img_idx + sizeof(struct fwu_image_entry) +
+			sizeof(struct fwu_image_bank_info) * bnk_idx;
+	} else {
+		offset = sizeof(struct fwu_mdata) +
+			sizeof(struct fwu_fw_store_desc) +
+			(sizeof(struct fwu_image_entry) +
+			 sizeof(struct fwu_image_bank_info) * mobj->banks) *
+			img_idx + sizeof(struct fwu_image_entry) +
+			sizeof(struct fwu_image_bank_info) * bnk_idx;
+	}
+
+	return (struct fwu_image_bank_info *)((char *)mobj->mdata + offset);
+}
+
+/**
+ * convert_uuid_to_guid() - convert UUID to GUID
+ * @buf:	UUID binary
+ *
+ * UUID and GUID have the same data structure, but their binary
+ * formats are different due to the endianness. See lib/uuid.c.
+ * Since uuid_parse() can handle only UUID, this function must
+ * be called to get correct data for GUID when parsing a string.
+ *
+ * The correct data will be returned in @buf.
+ */
+static void convert_uuid_to_guid(unsigned char *buf)
+{
+	unsigned char c;
+
+	c = buf[0];
+	buf[0] = buf[3];
+	buf[3] = c;
+	c = buf[1];
+	buf[1] = buf[2];
+	buf[2] = c;
+
+	c = buf[4];
+	buf[4] = buf[5];
+	buf[5] = c;
+
+	c = buf[6];
+	buf[6] = buf[7];
+	buf[7] = c;
+}
+
+static int uuid_guid_parse(char *uuidstr, unsigned char *uuid)
+{
+	int ret;
+
+	ret = uuid_parse(uuidstr, uuid);
+	if (ret < 0)
+		return ret;
+
+	if (__use_guid)
+		convert_uuid_to_guid(uuid);
+
+	return ret;
+}
+
+static int
+fwu_parse_fill_image_uuid(struct fwu_mdata_object *mobj,
+			  size_t idx, char *uuids)
+{
+	struct fwu_image_entry *image = fwu_get_image(mobj, idx);
+	struct fwu_image_bank_info *bank;
+	char *p = uuids, *uuid;
+	int i;
+
+	if (!image)
+		return -ENOENT;
+
+	/* Image location UUID */
+	uuid = strsep(&p, ",");
+	if (!uuid)
+		return -EINVAL;
+
+	if (strcmp(uuid, "0") &&
+	    uuid_guid_parse(uuid, (unsigned char *)&image->location_guid) < 0)
+		return -EINVAL;
+
+	/* Image type UUID */
+	uuid = strsep(&p, ",");
+	if (!uuid)
+		return -EINVAL;
+
+	if (uuid_guid_parse(uuid, (unsigned char *)&image->image_type_guid) < 0)
+		return -EINVAL;
+
+	/* Fill bank image-UUID */
+	for (i = 0; i < mobj->banks; i++) {
+		bank = fwu_get_bank(mobj, idx, i);
+		if (!bank)
+			return -ENOENT;
+		bank->accepted = 1;
+		uuid = strsep(&p, ",");
+		if (!uuid)
+			return -EINVAL;
+
+		if (strcmp(uuid, "0") &&
+		    uuid_guid_parse(uuid, (unsigned char *)&bank->image_guid) < 0)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_FWU_MDATA_V1)
+static void fwu_fill_version_specific_mdata(struct fwu_mdata_object *mobj)
+{
+}
+#else
+static void fwu_fill_version_specific_mdata(struct fwu_mdata_object *mobj)
+{
+	int i;
+	struct fwu_fw_store_desc *fw_desc;
+	struct fwu_mdata *mdata = mobj->mdata;
+
+	mdata->metadata_size = mobj->size;
+	mdata->desc_offset = sizeof(struct fwu_mdata);
+
+	for (i = 0; i < MAX_BANKS_V2; i++)
+		mdata->bank_state[i] = i < mobj->banks ?
+			BANK_ACCEPTED : BANK_INVALID;
+
+	fw_desc = (struct fwu_fw_store_desc *)((u8 *)mdata + sizeof(*mdata));
+	fw_desc->num_banks = mobj->banks;
+	fw_desc->num_images = mobj->images;
+	fw_desc->img_entry_size = sizeof(struct fwu_image_entry) +
+		(sizeof(struct fwu_image_bank_info) * mobj->banks);
+	fw_desc->bank_info_entry_size =
+		sizeof(struct fwu_image_bank_info);
+}
+#endif /* CONFIG_FWU_MDATA_V1 */
+
+/* Caller must ensure that @uuids[] has @mobj->images entries. */
+static int fwu_parse_fill_uuids(struct fwu_mdata_object *mobj, char *uuids[])
+{
+	struct fwu_mdata *mdata = mobj->mdata;
+	char *vdata;
+	int i, ret;
+
+	mdata->version = mobj->version;
+	mdata->active_index = active_bank;
+	mdata->previous_active_index = previous_bank;
+
+	fwu_fill_version_specific_mdata(mobj);
+
+	for (i = 0; i < mobj->images; i++) {
+		ret = fwu_parse_fill_image_uuid(mobj, i, uuids[i]);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (mobj->vsize) {
+		vdata = (char *)mobj->mdata + (mobj->size - mobj->vsize);
+		memcpy(vdata, mobj->vbuf, mobj->vsize);
+	}
+
+	mdata->crc32 = crc32(0, (const unsigned char *)&mdata->version,
+			     mobj->size - sizeof(uint32_t));
+
+	return 0;
+}
+
+static int fwu_read_vendor_data(struct fwu_mdata_object *mobj,
+				const char *vendor_file)
+{
+	int ret = 0;
+	FILE *vfile = NULL;
+
+	vfile = fopen(vendor_file, "r");
+	if (!vfile) {
+		ret = -1;
+		goto out;
+	}
+
+	if (fread(mobj->vbuf, 1, mobj->vsize, vfile) != mobj->vsize)
+		ret = -1;
+
+out:
+	fclose(vfile);
+	return ret;
+}
+
+static int fwu_make_mdata(size_t images, size_t banks, u8 version,
+			  const char *vendor_file, char *uuids[],
+			  char *output)
+{
+	int ret;
+	FILE *file;
+	struct stat sbuf;
+	size_t vendor_size = 0;
+	struct fwu_mdata_object *mobj;
+
+	if (vendor_file) {
+		ret = stat(vendor_file, &sbuf);
+		if (ret)
+			return -errno;
+
+		vendor_size = sbuf.st_size;
+	}
+
+	mobj = fwu_alloc_mdata(images, banks, version, vendor_size);
+	if (!mobj)
+		return -ENOMEM;
+
+	if (vendor_file) {
+		ret = fwu_read_vendor_data(mobj, vendor_file);
+		if (ret)
+			goto done_make;
+	}
+
+	ret = fwu_parse_fill_uuids(mobj, uuids);
+	if (ret < 0)
+		goto done_make;
+
+	file = fopen(output, "w");
+	if (!file) {
+		ret = -errno;
+		goto done_make;
+	}
+
+	ret = fwrite(mobj->mdata, 1, mobj->size, file);
+	if (ret != mobj->size)
+		ret = -errno;
+	else
+		ret = 0;
+
+	fclose(file);
+
+done_make:
+	free(mobj->mdata);
+	free(mobj->vbuf);
+	free(mobj);
+
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	unsigned long banks = 0, images = 0, version = 0;
+	int c, ret;
+	const char *vendor_file;
+
+	/* Explicitly initialize defaults */
+	active_bank = 0;
+	__use_guid = false;
+	previous_bank = INT_MAX;
+	vendor_file = NULL;
+
+	do {
+		c = getopt_long(argc, argv, opts_short, options, NULL);
+		switch (c) {
+		case 'h':
+			print_usage();
+			return 0;
+		case 'b':
+			banks = strtoul(optarg, NULL, 0);
+			break;
+		case 'i':
+			images = strtoul(optarg, NULL, 0);
+			break;
+		case 'g':
+			__use_guid = true;
+			break;
+		case 'p':
+			previous_bank = strtoul(optarg, NULL, 0);
+			break;
+		case 'a':
+			active_bank = strtoul(optarg, NULL, 0);
+			break;
+		case 'v':
+			version = strtoul(optarg, NULL, 0);
+			break;
+		case 'V':
+			vendor_file = optarg;
+			break;
+		}
+	} while (c != -1);
+
+	if (!banks || !images) {
+		fprintf(stderr, "Error: The number of banks and images must not be 0.\n");
+		return -EINVAL;
+	}
+
+	if (!version || !supported_mdata_version(version)) {
+		fprintf(stderr, "Error: Version value can only be either 1 or 2, not %ld.\n",
+			version);
+		return -EINVAL;
+	}
+
+	if (version == 1 && vendor_file) {
+		fprintf(stderr, "Error: Vendor Data can only be appended in version 2 of FWU Metadata.\n");
+		return -EINVAL;
+	}
+
+	/* This command takes UUIDs * images and output file. */
+	if (optind + images + 1 != argc) {
+		fprintf(stderr, "Error: UUID list or output file is not specified or too much.\n");
+		print_usage();
+		return -ERANGE;
+	}
+
+	if (previous_bank == INT_MAX) {
+		/* set to the earlier bank in round-robin scheme */
+		previous_bank = active_bank > 0 ? active_bank - 1 : banks - 1;
+	}
+
+	ret = fwu_make_mdata(images, banks, (u8)version, vendor_file,
+			     argv + optind, argv[argc - 1]);
+	if (ret < 0)
+		fprintf(stderr, "Error: Failed to parse and write image: %s\n",
+			strerror(-ret));
+
+	return ret;
+}
-- 
2.34.1

